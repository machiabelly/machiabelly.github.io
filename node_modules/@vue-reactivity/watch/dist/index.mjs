// src/index.ts
import { ReactiveEffect, isReactive, isRef, isShallow } from "@vue/reactivity";
import { NOOP, hasChanged, isArray, isFunction as isFunction2, isObject } from "@vue/shared";

// src/errorHandling.ts
import { isFunction, isPromise } from "@vue/shared";
function callWithErrorHandling(fn, type, args) {
  let res;
  try {
    res = args ? fn(...args) : fn();
  } catch (err) {
    handleError(err, type);
  }
  return res;
}
function callWithAsyncErrorHandling(fn, type, args) {
  if (isFunction(fn)) {
    const res = callWithErrorHandling(fn, type, args);
    if (res && isPromise(res)) {
      res.catch((err) => {
        handleError(err, type);
      });
    }
    return res;
  }
  const values = [];
  for (let i = 0; i < fn.length; i++)
    values.push(callWithAsyncErrorHandling(fn[i], type, args));
  return values;
}
function handleError(err, type) {
  console.error(new Error(`[@vue-reactivity/watch]: ${type}`));
  console.error(err);
}
function warn(message) {
  console.warn(createError(message));
}
function createError(message) {
  return new Error(`[reactivue]: ${message}`);
}

// src/index.ts
var INITIAL_WATCHER_VALUE = {};
function watchEffect(effect, options) {
  return doWatch(effect, null, options);
}
function watch(source, cb, options) {
  return doWatch(source, cb, options);
}
function doWatch(source, cb, { immediate, deep, flush } = {}) {
  let getter;
  let forceTrigger = false;
  let isMultiSource = false;
  if (isRef(source)) {
    getter = () => source.value;
    forceTrigger = isShallow(source);
  } else if (isReactive(source)) {
    getter = () => source;
    deep = true;
  } else if (isArray(source)) {
    isMultiSource = true;
    forceTrigger = source.some(isReactive);
    getter = () => source.map((s) => {
      if (isRef(s))
        return s.value;
      else if (isReactive(s))
        return traverse(s);
      else if (isFunction2(s))
        return callWithErrorHandling(s, "watch getter");
      else
        return warn("invalid source");
    });
  } else if (isFunction2(source)) {
    if (cb) {
      getter = () => callWithErrorHandling(source, "watch getter");
    } else {
      getter = () => {
        if (cleanup)
          cleanup();
        return callWithAsyncErrorHandling(source, "watch callback", [onCleanup]);
      };
    }
  } else {
    getter = NOOP;
  }
  if (cb && deep) {
    const baseGetter = getter;
    getter = () => traverse(baseGetter());
  }
  let cleanup;
  let onCleanup = (fn) => {
    cleanup = effect.onStop = () => {
      callWithErrorHandling(fn, "watch cleanup");
    };
  };
  let oldValue = isMultiSource ? [] : INITIAL_WATCHER_VALUE;
  const job = () => {
    if (!effect.active)
      return;
    if (cb) {
      const newValue = effect.run();
      if (deep || forceTrigger || (isMultiSource ? newValue.some((v, i) => hasChanged(v, oldValue[i])) : hasChanged(newValue, oldValue))) {
        if (cleanup)
          cleanup();
        callWithAsyncErrorHandling(cb, "watch value", [
          newValue,
          oldValue === INITIAL_WATCHER_VALUE ? void 0 : oldValue,
          onCleanup
        ]);
        oldValue = newValue;
      }
    } else {
      effect.run();
    }
  };
  job.allowRecurse = !!cb;
  let scheduler;
  if (flush === "sync") {
    scheduler = job;
  } else {
    scheduler = () => {
      job();
    };
  }
  const effect = new ReactiveEffect(getter, scheduler);
  if (cb) {
    if (immediate)
      job();
    else
      oldValue = effect.run();
  } else {
    effect.run();
  }
  return () => effect.stop();
}
function traverse(value, seen = /* @__PURE__ */ new Set()) {
  if (!isObject(value) || seen.has(value))
    return value;
  seen.add(value);
  if (isArray(value)) {
    for (let i = 0; i < value.length; i++)
      traverse(value[i], seen);
  } else if (value instanceof Map) {
    value.forEach((_, key) => {
      traverse(value.get(key), seen);
    });
  } else if (value instanceof Set) {
    value.forEach((v) => {
      traverse(v, seen);
    });
  } else {
    for (const key of Object.keys(value))
      traverse(value[key], seen);
  }
  return value;
}
export {
  watch,
  watchEffect
};
