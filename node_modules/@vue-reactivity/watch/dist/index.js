var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __markAsModule = (target) => __defProp(target, "__esModule", { value: true });
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __reExport = (target, module2, copyDefault, desc) => {
  if (module2 && typeof module2 === "object" || typeof module2 === "function") {
    for (let key of __getOwnPropNames(module2))
      if (!__hasOwnProp.call(target, key) && (copyDefault || key !== "default"))
        __defProp(target, key, { get: () => module2[key], enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable });
  }
  return target;
};
var __toCommonJS = /* @__PURE__ */ ((cache) => {
  return (module2, temp) => {
    return cache && cache.get(module2) || (temp = __reExport(__markAsModule({}), module2, 1), cache && cache.set(module2, temp), temp);
  };
})(typeof WeakMap !== "undefined" ? /* @__PURE__ */ new WeakMap() : 0);

// src/index.ts
var src_exports = {};
__export(src_exports, {
  watch: () => watch,
  watchEffect: () => watchEffect
});
var import_reactivity = require("@vue/reactivity");
var import_shared2 = require("@vue/shared");

// src/errorHandling.ts
var import_shared = require("@vue/shared");
function callWithErrorHandling(fn, type, args) {
  let res;
  try {
    res = args ? fn(...args) : fn();
  } catch (err) {
    handleError(err, type);
  }
  return res;
}
function callWithAsyncErrorHandling(fn, type, args) {
  if ((0, import_shared.isFunction)(fn)) {
    const res = callWithErrorHandling(fn, type, args);
    if (res && (0, import_shared.isPromise)(res)) {
      res.catch((err) => {
        handleError(err, type);
      });
    }
    return res;
  }
  const values = [];
  for (let i = 0; i < fn.length; i++)
    values.push(callWithAsyncErrorHandling(fn[i], type, args));
  return values;
}
function handleError(err, type) {
  console.error(new Error(`[@vue-reactivity/watch]: ${type}`));
  console.error(err);
}
function warn(message) {
  console.warn(createError(message));
}
function createError(message) {
  return new Error(`[reactivue]: ${message}`);
}

// src/index.ts
var INITIAL_WATCHER_VALUE = {};
function watchEffect(effect, options) {
  return doWatch(effect, null, options);
}
function watch(source, cb, options) {
  return doWatch(source, cb, options);
}
function doWatch(source, cb, { immediate, deep, flush } = {}) {
  let getter;
  let forceTrigger = false;
  let isMultiSource = false;
  if ((0, import_reactivity.isRef)(source)) {
    getter = () => source.value;
    forceTrigger = (0, import_reactivity.isShallow)(source);
  } else if ((0, import_reactivity.isReactive)(source)) {
    getter = () => source;
    deep = true;
  } else if ((0, import_shared2.isArray)(source)) {
    isMultiSource = true;
    forceTrigger = source.some(import_reactivity.isReactive);
    getter = () => source.map((s) => {
      if ((0, import_reactivity.isRef)(s))
        return s.value;
      else if ((0, import_reactivity.isReactive)(s))
        return traverse(s);
      else if ((0, import_shared2.isFunction)(s))
        return callWithErrorHandling(s, "watch getter");
      else
        return warn("invalid source");
    });
  } else if ((0, import_shared2.isFunction)(source)) {
    if (cb) {
      getter = () => callWithErrorHandling(source, "watch getter");
    } else {
      getter = () => {
        if (cleanup)
          cleanup();
        return callWithAsyncErrorHandling(source, "watch callback", [onCleanup]);
      };
    }
  } else {
    getter = import_shared2.NOOP;
  }
  if (cb && deep) {
    const baseGetter = getter;
    getter = () => traverse(baseGetter());
  }
  let cleanup;
  let onCleanup = (fn) => {
    cleanup = effect.onStop = () => {
      callWithErrorHandling(fn, "watch cleanup");
    };
  };
  let oldValue = isMultiSource ? [] : INITIAL_WATCHER_VALUE;
  const job = () => {
    if (!effect.active)
      return;
    if (cb) {
      const newValue = effect.run();
      if (deep || forceTrigger || (isMultiSource ? newValue.some((v, i) => (0, import_shared2.hasChanged)(v, oldValue[i])) : (0, import_shared2.hasChanged)(newValue, oldValue))) {
        if (cleanup)
          cleanup();
        callWithAsyncErrorHandling(cb, "watch value", [
          newValue,
          oldValue === INITIAL_WATCHER_VALUE ? void 0 : oldValue,
          onCleanup
        ]);
        oldValue = newValue;
      }
    } else {
      effect.run();
    }
  };
  job.allowRecurse = !!cb;
  let scheduler;
  if (flush === "sync") {
    scheduler = job;
  } else {
    scheduler = () => {
      job();
    };
  }
  const effect = new import_reactivity.ReactiveEffect(getter, scheduler);
  if (cb) {
    if (immediate)
      job();
    else
      oldValue = effect.run();
  } else {
    effect.run();
  }
  return () => effect.stop();
}
function traverse(value, seen = /* @__PURE__ */ new Set()) {
  if (!(0, import_shared2.isObject)(value) || seen.has(value))
    return value;
  seen.add(value);
  if ((0, import_shared2.isArray)(value)) {
    for (let i = 0; i < value.length; i++)
      traverse(value[i], seen);
  } else if (value instanceof Map) {
    value.forEach((_, key) => {
      traverse(value.get(key), seen);
    });
  } else if (value instanceof Set) {
    value.forEach((v) => {
      traverse(v, seen);
    });
  } else {
    for (const key of Object.keys(value))
      traverse(value[key], seen);
  }
  return value;
}
module.exports = __toCommonJS(src_exports);
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  watch,
  watchEffect
});
