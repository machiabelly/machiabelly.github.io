(self["webpackChunk"] = self["webpackChunk"] || []).push([["_polygonjs_polygonjs_src_engine_nodes_mat_RayMarchingBuilder_ts"],{

/***/ 855:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "C": function() { return /* binding */ RAYMARCHING_UNIFORMS; }
/* harmony export */ });

const RAYMARCHING_UNIFORMS = {
  MAX_STEPS: {
    value: 100
  },
  MAX_DIST: {
    value: 100
  },
  SURF_DIST: {
    value: 1e-3
  },
  NORMALS_BIAS: {
    value: 0.01
  },
  SHADOW_BIAS: {
    value: 0
  },
  debugMinSteps: {
    value: 0
  },
  debugMaxSteps: {
    value: 128
  },
  debugMinDepth: {
    value: 0
  },
  debugMaxDepth: {
    value: 128
  },
  shadowDistanceMin: {
    value: 0
  },
  shadowDistanceMax: {
    value: 100
  },
  shadowDepthMin: {
    value: 0
  },
  shadowDepthMax: {
    value: 100
  },
  envMapRotationY: {
    value: 0
  }
};


/***/ }),

/***/ 13839:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {


// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  "n": function() { return /* binding */ RayMarchingBuilderMatNode; }
});

// UNUSED EXPORTS: AdvancedCommonParamConfig

// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/nodes/mat/_BaseBuilder.ts + 1 modules
var _BaseBuilder = __webpack_require__(88303);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/nodes/utils/params/ParamsConfig.ts
var ParamsConfig = __webpack_require__(96949);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/poly/NodeContext.ts
var NodeContext = __webpack_require__(52070);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/poly/Assert.ts
var Assert = __webpack_require__(68239);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/nodes/gl/gl/raymarching/uniforms.ts
var uniforms = __webpack_require__(855);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/core/Type.ts
var Type = __webpack_require__(19037);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/core/geometry/Material.ts
var geometry_Material = __webpack_require__(62026);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/nodes/mat/utils/customMaterials/_CustomMaterialBase.ts
var _CustomMaterialBase = __webpack_require__(11803);
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/mat/utils/customMaterials/CustomMaterialRayMarching.ts

var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));









function CustomMaterialRayMarchingParamConfig(Base) {
  return class Mixin extends Base {
    constructor() {
      super(...arguments);
      /** @param toggle on to choose which customMaterials will be generated */
      this.overrideCustomMaterials = ParamsConfig/* ParamConfig.BOOLEAN */.XC.BOOLEAN(0, __spreadProps(__spreadValues({}, _CustomMaterialBase/* CUSTOM_MAT_PARAM_OPTIONS */.z), {
        separatorBefore: true,
        separatorAfter: true
      }));
      /** @param creates a shadow material for point lights */
      this.createCustomMatDistance = ParamsConfig/* ParamConfig.BOOLEAN */.XC.BOOLEAN(1, __spreadValues({
        visibleIf: { overrideCustomMaterials: 1 }
      }, _CustomMaterialBase/* CUSTOM_MAT_PARAM_OPTIONS */.z));
      /** @param min shadow depth for point lights */
      this.shadowDistanceMin = ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(uniforms/* RAYMARCHING_UNIFORMS.shadowDistanceMin.value */.C.shadowDistanceMin.value, {
        range: [0, 100],
        rangeLocked: [true, false],
        step: 1,
        visibleIf: [{ overrideCustomMaterials: 0 }, { overrideCustomMaterials: 1, createCustomMatDistance: 1 }]
      });
      /** @param max shadow depth for point lights */
      this.shadowDistanceMax = ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(uniforms/* RAYMARCHING_UNIFORMS.shadowDistanceMax.value */.C.shadowDistanceMax.value, {
        range: [0, 100],
        rangeLocked: [true, false],
        step: 1,
        visibleIf: [{ overrideCustomMaterials: 0 }, { overrideCustomMaterials: 1, createCustomMatDistance: 1 }]
      });
      /** @param creates a shadow material for spot lights and directional lights */
      this.createCustomMatDepth = ParamsConfig/* ParamConfig.BOOLEAN */.XC.BOOLEAN(1, __spreadValues({
        visibleIf: { overrideCustomMaterials: 1 }
      }, _CustomMaterialBase/* CUSTOM_MAT_PARAM_OPTIONS */.z));
      /** @param min shadow depth for spot lights and directional lights */
      this.shadowDepthMin = ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(uniforms/* RAYMARCHING_UNIFORMS.shadowDepthMin.value */.C.shadowDepthMin.value, {
        range: [0, 100],
        rangeLocked: [true, false],
        step: 1,
        visibleIf: [{ overrideCustomMaterials: 0 }, { overrideCustomMaterials: 1, createCustomMatDepth: 1 }]
      });
      /** @param max shadow depth for spot lights and directional lights */
      this.shadowDepthMax = ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(uniforms/* RAYMARCHING_UNIFORMS.shadowDepthMax.value */.C.shadowDepthMax.value, {
        range: [0, 100],
        rangeLocked: [true, false],
        step: 1,
        visibleIf: [{ overrideCustomMaterials: 0 }, { overrideCustomMaterials: 1, createCustomMatDepth: 1 }]
      });
    }
  };
}
class CustomMaterialRayMarchingParamsConfig extends CustomMaterialRayMarchingParamConfig(
  (0,_BaseBuilder/* BaseBuilderParamConfig */.I)(ParamsConfig/* NodeParamsConfig */.yI)
) {
}
class CustomMaterialMatNode extends (/* unused pure expression or super */ null && (TypedMatNode)) {
}
function materialRayMarchingAssemblerCustomMaterialRequested(node, customName) {
  const param = node.p.overrideCustomMaterials;
  if (!param) {
    console.warn(`param overrideCustomMaterials not found on ${node.path()}, creating all customMaterials`);
    return true;
  }
  if (!(0,Type/* isBooleanTrue */.bI)(node.pv.overrideCustomMaterials)) {
    return true;
  }
  switch (customName) {
    case geometry_Material/* CustomMaterialName.DISTANCE */.RJ.DISTANCE: {
      return (0,Type/* isBooleanTrue */.bI)(node.pv.createCustomMatDistance);
    }
    case geometry_Material/* CustomMaterialName.DEPTH */.RJ.DEPTH: {
      return (0,Type/* isBooleanTrue */.bI)(node.pv.createCustomMatDepth);
    }
    case geometry_Material/* CustomMaterialName.DEPTH_DOF */.RJ.DEPTH_DOF: {
      return false;
    }
  }
  Assert/* TypeAssert.unreachable */.f.unreachable(customName);
}

// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/core/ThreeToGl.ts
var ThreeToGl = __webpack_require__(81556);
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/mat/utils/RayMarchingController.ts

var RayMarchingController_defProp = Object.defineProperty;
var RayMarchingController_defProps = Object.defineProperties;
var RayMarchingController_getOwnPropDescs = Object.getOwnPropertyDescriptors;
var RayMarchingController_getOwnPropSymbols = Object.getOwnPropertySymbols;
var RayMarchingController_hasOwnProp = Object.prototype.hasOwnProperty;
var RayMarchingController_propIsEnum = Object.prototype.propertyIsEnumerable;
var RayMarchingController_defNormalProp = (obj, key, value) => key in obj ? RayMarchingController_defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var RayMarchingController_spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (RayMarchingController_hasOwnProp.call(b, prop))
      RayMarchingController_defNormalProp(a, prop, b[prop]);
  if (RayMarchingController_getOwnPropSymbols)
    for (var prop of RayMarchingController_getOwnPropSymbols(b)) {
      if (RayMarchingController_propIsEnum.call(b, prop))
        RayMarchingController_defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var RayMarchingController_spreadProps = (a, b) => RayMarchingController_defProps(a, RayMarchingController_getOwnPropDescs(b));
var __async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};









var RayMarchingDebugMode = /* @__PURE__ */ ((RayMarchingDebugMode2) => {
  RayMarchingDebugMode2["STEPS_COUNT"] = "Steps Count";
  RayMarchingDebugMode2["DEPTH"] = "Depth";
  return RayMarchingDebugMode2;
})(RayMarchingDebugMode || {});
const RAYMARCHING_DEBUG_MODES = ["Steps Count" /* STEPS_COUNT */, "Depth" /* DEPTH */];
const DEBUG_STEPS_COUNT = RAYMARCHING_DEBUG_MODES.indexOf("Steps Count" /* STEPS_COUNT */);
function generateCubeUVSize(parameters) {
  const imageHeight = parameters.envMapCubeUVHeight;
  if (imageHeight === null)
    return null;
  const maxMip = Math.log2(imageHeight) - 2;
  const texelHeight = 1 / imageHeight;
  const texelWidth = 1 / (3 * Math.max(Math.pow(2, maxMip), 7 * 16));
  return { texelWidth, texelHeight, maxMip };
}
function setDefines(shaderMaterial, props) {
  shaderMaterial.defines["ENVMAP_TYPE_CUBE_UV"] = props ? 1 : 0;
  shaderMaterial.defines["CUBEUV_TEXEL_WIDTH"] = props ? props.texelWidth : ThreeToGl/* ThreeToGl.float */._.float(0.1);
  shaderMaterial.defines["CUBEUV_TEXEL_HEIGHT"] = props ? props.texelHeight : ThreeToGl/* ThreeToGl.float */._.float(0.1);
  shaderMaterial.defines["CUBEUV_MAX_MIP"] = props ? ThreeToGl/* ThreeToGl.float */._.float(props.maxMip) : ThreeToGl/* ThreeToGl.float */._.float(1);
  shaderMaterial.defines["ROTATE_ENV_MAP_Y"] = props ? props.tEnvMapRotate : 0;
}
function RayMarchingMainParamConfig(Base) {
  return class Mixin extends Base {
    constructor() {
      super(...arguments);
      /** @param maximum number of steps the raymarcher will run */
      this.maxSteps = ParamsConfig/* ParamConfig.INTEGER */.XC.INTEGER(uniforms/* RAYMARCHING_UNIFORMS.MAX_STEPS.value */.C.MAX_STEPS.value, {
        range: [1, 128],
        rangeLocked: [true, false]
      });
      /** @param maximum distance the raymarcher will step through */
      this.maxDist = ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(uniforms/* RAYMARCHING_UNIFORMS.MAX_DIST.value */.C.MAX_DIST.value, {
        range: [1, 100],
        rangeLocked: [true, false]
      });
      /** @param when the ray reaches this distance from a surface it will stop marching. You can lower this value to increase the precision of the raymarcher */
      this.surfDist = ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(uniforms/* RAYMARCHING_UNIFORMS.SURF_DIST.value */.C.SURF_DIST.value, {
        range: [0, 0.1],
        rangeLocked: [true, false],
        step: 1e-7
      });
      /** @param precision for normals computation */
      this.normalsBias = ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(uniforms/* RAYMARCHING_UNIFORMS.NORMALS_BIAS.value */.C.NORMALS_BIAS.value, {
        range: [0, 0.1],
        rangeLocked: [true, false],
        step: 1e-7
      });
      /** @param precision for shadows computation */
      this.shadowBias = ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(uniforms/* RAYMARCHING_UNIFORMS.SHADOW_BIAS.value */.C.SHADOW_BIAS.value, {
        range: [-0.1, 0.1],
        rangeLocked: [false, false],
        step: 1e-7
      });
    }
  };
}
function RayMarchingEnvMapParamConfig(Base) {
  return class Mixin extends Base {
    constructor() {
      super(...arguments);
      /** @param toggle if you want to use an environment map */
      this.useEnvMap = ParamsConfig/* ParamConfig.BOOLEAN */.XC.BOOLEAN(0, {
        separatorBefore: true
        // ...BooleanParamOptions(TextureEnvMapController),
      });
      /** @param specify the environment map COP node */
      this.envMap = ParamsConfig/* ParamConfig.NODE_PATH */.XC.NODE_PATH("", {
        visibleIf: { useEnvMap: 1 },
        nodeSelection: { context: NodeContext/* NodeContext.COP */.sy.COP }
      });
      /** @param environment intensity */
      this.envMapIntensity = ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(1, {
        visibleIf: { useEnvMap: 1 },
        cook: false,
        callback: (node) => RayMarchingController.updateUniformEnvMapIntensity(node)
      });
      /** @param environment roughness */
      this.envMapRoughness = ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(1, {
        visibleIf: { useEnvMap: 1 },
        cook: false,
        callback: (node) => RayMarchingController.updateUniformEnvMapRoughness(node)
      });
      /** @param allow env map rotation */
      this.tEnvMapRotate = ParamsConfig/* ParamConfig.BOOLEAN */.XC.BOOLEAN(0, {
        visibleIf: { useEnvMap: 1 }
      });
      /** @param env map rotation */
      this.envMapRotation = ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(0, {
        range: [-Math.PI, Math.PI],
        rangeLocked: [false, false],
        step: 1e-4,
        visibleIf: { useEnvMap: 1, tEnvMapRotate: 1 },
        cook: false,
        callback: (node) => RayMarchingController.updateUniformEnvMapRotate(node)
      });
    }
  };
}
function RayMarchingDebugParamConfig(Base) {
  return class Mixin extends Base {
    constructor() {
      super(...arguments);
      /** @param debug mode */
      this.debug = ParamsConfig/* ParamConfig.BOOLEAN */.XC.BOOLEAN(0, {
        separatorBefore: true
      });
      /** @param outputs color showing the number of steps required to solve the raymarching */
      this.debugMode = ParamsConfig/* ParamConfig.INTEGER */.XC.INTEGER(DEBUG_STEPS_COUNT, {
        menu: { entries: RAYMARCHING_DEBUG_MODES.map((name, value) => ({ name, value })) },
        visibleIf: { debug: true }
      });
      /** @param min steps count */
      this.debugMinSteps = ParamsConfig/* ParamConfig.INTEGER */.XC.INTEGER(uniforms/* RAYMARCHING_UNIFORMS.debugMinSteps.value */.C.debugMinSteps.value, {
        range: [0, 128],
        rangeLocked: [true, false],
        step: 1
        // visibleIf: {debug: true, debugMode: DEBUG_STEPS_COUNT},
      });
      /** @param max steps count */
      this.debugMaxSteps = ParamsConfig/* ParamConfig.INTEGER */.XC.INTEGER(uniforms/* RAYMARCHING_UNIFORMS.debugMaxSteps.value */.C.debugMaxSteps.value, {
        range: [0, 128],
        rangeLocked: [true, false],
        step: 1
        // visibleIf: {debug: true, debugMode: DEBUG_STEPS_COUNT},
      });
      /** @param min depth */
      this.debugMinDepth = ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(uniforms/* RAYMARCHING_UNIFORMS.debugMinDepth.value */.C.debugMinDepth.value, {
        range: [0, 128],
        rangeLocked: [true, false],
        step: 1
        // visibleIf: {debug: true, debugMode: DEBUG_DEPTH},
      });
      /** @param max depth */
      this.debugMaxDepth = ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(uniforms/* RAYMARCHING_UNIFORMS.debugMaxDepth.value */.C.debugMaxDepth.value, {
        range: [0, 128],
        rangeLocked: [true, false],
        step: 1
        // visibleIf: {debug: true, debugMode: DEBUG_DEPTH},
      });
    }
  };
}
class RayMarchingMaterial extends (/* unused pure expression or super */ null && (Material)) {
}
class RayMarchingParamsConfig extends CustomMaterialRayMarchingParamConfig(
  RayMarchingDebugParamConfig(RayMarchingEnvMapParamConfig(RayMarchingMainParamConfig(ParamsConfig/* NodeParamsConfig */.yI)))
) {
}
class RayMarchingMatNode extends (/* unused pure expression or super */ null && (PrimitiveMatNode)) {
}
class RayMarchingController {
  constructor(node) {
    this.node = node;
  }
  updateUniformsFromParams(shaderMaterial) {
    return __async(this, null, function* () {
      const uniforms = shaderMaterial.uniforms;
      if (!uniforms) {
        return;
      }
      const pv = this.node.pv;
      uniforms.MAX_STEPS.value = pv.maxSteps;
      uniforms.MAX_DIST.value = pv.maxDist;
      uniforms.SURF_DIST.value = pv.surfDist;
      uniforms.NORMALS_BIAS.value = pv.normalsBias;
      uniforms.SHADOW_BIAS.value = pv.shadowBias;
      uniforms.shadowDepthMin.value = pv.shadowDepthMin;
      uniforms.shadowDepthMax.value = pv.shadowDepthMax;
      uniforms.shadowDistanceMin.value = pv.shadowDistanceMin;
      uniforms.shadowDistanceMax.value = pv.shadowDistanceMax;
      this._updateUniforms(shaderMaterial);
      this._updateDebug(shaderMaterial, uniforms);
      yield this._updateEnvMap(shaderMaterial, uniforms);
    });
  }
  _updateDebug(shaderMaterial, uniforms) {
    const pv = this.node.pv;
    if ((0,Type/* isBooleanTrue */.bI)(pv.debug)) {
      let updateDebugMode2 = function(uniforms2) {
        const debugMode = RAYMARCHING_DEBUG_MODES[pv.debugMode];
        switch (debugMode) {
          case "Steps Count" /* STEPS_COUNT */: {
            uniforms2.debugMinSteps.value = pv.debugMinSteps;
            uniforms2.debugMaxSteps.value = pv.debugMaxSteps;
            shaderMaterial.defines["DEBUG_STEPS_COUNT"] = 1;
            delete shaderMaterial.defines["DEBUG_DEPTH"];
            shaderMaterial.needsUpdate = true;
            return;
          }
          case "Depth" /* DEPTH */: {
            uniforms2.debugMinDepth.value = pv.debugMinDepth;
            uniforms2.debugMaxDepth.value = pv.debugMaxDepth;
            shaderMaterial.defines["DEBUG_DEPTH"] = 1;
            delete shaderMaterial.defines["DEBUG_STEPS_COUNT"];
            shaderMaterial.needsUpdate = true;
            return;
          }
        }
        Assert/* TypeAssert.unreachable */.f.unreachable(debugMode);
      };
      var updateDebugMode = updateDebugMode2;
      updateDebugMode2(uniforms);
    } else {
      if (shaderMaterial.defines["DEBUG_STEPS_COUNT"] != null) {
        delete shaderMaterial.defines["DEBUG_STEPS_COUNT"];
        shaderMaterial.needsUpdate = true;
      }
      if (shaderMaterial.defines["DEBUG_DEPTH"] != null) {
        delete shaderMaterial.defines["DEBUG_DEPTH"];
        shaderMaterial.needsUpdate = true;
      }
    }
  }
  _updateEnvMap(shaderMaterial, uniforms) {
    return __async(this, null, function* () {
      const pv = this.node.pv;
      setDefines(shaderMaterial, null);
      const currentDefine = shaderMaterial.defines["ENVMAP_TYPE_CUBE_UV"];
      const _fetchTexture = () => __async(this, null, function* () {
        const pathParam = this.node.p.envMap;
        if (pathParam.isDirty()) {
          yield pathParam.compute();
        }
        const textureNode = pathParam.value.nodeWithContext(NodeContext/* NodeContext.COP */.sy.COP);
        if (textureNode) {
          const container = yield textureNode.compute();
          const texture = container.texture();
          return texture;
        }
      });
      const _applyTexture = (texture) => {
        uniforms["envMap"].value = texture;
        const props = generateCubeUVSize({ envMapCubeUVHeight: texture.image.height });
        setDefines(shaderMaterial, props ? RayMarchingController_spreadProps(RayMarchingController_spreadValues({}, props), { tEnvMapRotate: pv.tEnvMapRotate }) : null);
      };
      const _removeTexture = () => {
        uniforms["envMap"].value = null;
        setDefines(shaderMaterial, null);
      };
      const _updateNeedsUpdateIfRequired = () => {
        if (currentDefine != shaderMaterial.defines["ENVMAP_TYPE_CUBE_UV"]) {
          shaderMaterial.needsUpdate = true;
        }
      };
      if ((0,Type/* isBooleanTrue */.bI)(pv.useEnvMap)) {
        const texture = yield _fetchTexture();
        if (texture) {
          _applyTexture(texture);
        } else {
          _removeTexture();
        }
      } else {
        _removeTexture();
      }
      _updateNeedsUpdateIfRequired();
    });
  }
  /**
   *
   * uniforms
   *
   */
  _updateUniforms(shaderMaterial) {
    RayMarchingController._updateUniforms(this.node, shaderMaterial);
  }
  static _updateUniforms(node, shaderMaterial) {
    this._updateUniformEnvMapIntensity(node, shaderMaterial);
    this._updateUniformEnvMapRoughness(node, shaderMaterial);
    this._updateUniformEnvMapRotate(node, shaderMaterial);
  }
  static updateUniformEnvMapIntensity(node) {
    return __async(this, null, function* () {
      this._updateUniformEnvMapIntensity(node, yield node.material());
    });
  }
  static _updateUniformEnvMapIntensity(node, shaderMaterial) {
    const uniforms = shaderMaterial.uniforms;
    if (!uniforms) {
      return;
    }
    uniforms["envMapIntensity"].value = node.pv.envMapIntensity;
  }
  static updateUniformEnvMapRoughness(node) {
    return __async(this, null, function* () {
      this._updateUniformEnvMapRoughness(node, yield node.material());
    });
  }
  static _updateUniformEnvMapRoughness(node, shaderMaterial) {
    const uniforms = shaderMaterial.uniforms;
    if (!uniforms) {
      return;
    }
    uniforms["roughness"].value = node.pv.envMapRoughness;
  }
  static updateUniformEnvMapRotate(node) {
    return __async(this, null, function* () {
      this._updateUniformEnvMapRotate(node, yield node.material());
    });
  }
  static _updateUniformEnvMapRotate(node, shaderMaterial) {
    const uniforms = shaderMaterial.uniforms;
    if (!uniforms) {
      return;
    }
    uniforms["envMapRotationY"].value = node.pv.envMapRotation;
  }
}

// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/poly/registers/assemblers/_BaseRegister.ts
var _BaseRegister = __webpack_require__(33899);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/Poly.ts + 21 modules
var Poly = __webpack_require__(99934);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/nodes/mat/utils/DefaultFolder.ts
var DefaultFolder = __webpack_require__(99233);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/nodes/mat/utils/TexturesFolder.ts
var TexturesFolder = __webpack_require__(45231);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/nodes/mat/utils/AdvancedFolder.ts
var AdvancedFolder = __webpack_require__(73777);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/nodes/mat/utils/helpers/MaterialSideHelper.ts
var MaterialSideHelper = __webpack_require__(80985);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/nodes/mat/utils/UniformsFogController.ts
var UniformsFogController = __webpack_require__(9161);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/poly/registers/nodes/types/Mat.ts
var Mat = __webpack_require__(41545);
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/mat/RayMarchingBuilder.ts

var RayMarchingBuilder_async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};












function AdvancedCommonParamConfig(Base) {
  return class Mixin extends Base {
    constructor() {
      super(...arguments);
      /** @param defines if the material is double sided or not */
      this.doubleSided = ParamsConfig/* ParamConfig.BOOLEAN */.XC.BOOLEAN(0, {
        separatorBefore: true
      });
      /** @param if the material is not double sided, it can be front sided, or back sided */
      this.front = ParamsConfig/* ParamConfig.BOOLEAN */.XC.BOOLEAN(0, {
        visibleIf: { doubleSided: false }
      });
    }
  };
}
class RayMarchingBuilderMatParamsConfig extends RayMarchingDebugParamConfig(
  CustomMaterialRayMarchingParamConfig(
    (0,UniformsFogController/* FogParamConfig */.N)(
      AdvancedCommonParamConfig(
        (0,_BaseBuilder/* BaseBuilderParamConfig */.I)(
          (0,AdvancedFolder/* AdvancedFolderParamConfig */.A)(
            RayMarchingEnvMapParamConfig(
              (0,TexturesFolder/* TexturesFolderParamConfig */.o)(
                RayMarchingMainParamConfig((0,DefaultFolder/* DefaultFolderParamConfig */.b)(ParamsConfig/* NodeParamsConfig */.yI))
              )
            )
          )
        )
      )
    )
  )
) {
}
const RayMarchingBuilder_ParamsConfig = new RayMarchingBuilderMatParamsConfig();
class RayMarchingBuilderMatNode extends _BaseBuilder/* TypedBuilderMatNode */.T {
  constructor() {
    super(...arguments);
    this.paramsConfig = RayMarchingBuilder_ParamsConfig;
    this._rayMarchingController = new RayMarchingController(this);
    this.controllers = {
      uniformFog: new UniformsFogController/* UniformFogController */.z(this)
    };
  }
  static type() {
    return Mat/* MatType.RAY_MARCHING_BUILDER */.M.RAY_MARCHING_BUILDER;
  }
  usedAssembler() {
    return _BaseRegister/* AssemblerName.GL_RAYMARCHING */.Q.GL_RAYMARCHING;
  }
  _createAssemblerController() {
    return Poly/* Poly.assemblersRegister.assembler */.L.assemblersRegister.assembler(this, this.usedAssembler());
  }
  customMaterialRequested(customName) {
    return materialRayMarchingAssemblerCustomMaterialRequested(this, customName);
  }
  initializeNode() {
  }
  cook() {
    return RayMarchingBuilder_async(this, null, function* () {
      this._material = this._material || this.createMaterial();
      this._rayMarchingController.updateUniformsFromParams(this._material);
      this.compileIfRequired(this._material);
      UniformsFogController/* UniformFogController.update */.z.update(this);
      (0,MaterialSideHelper/* updateMaterialSide */.$M)(this._material, this.pv);
      this.setMaterial(this._material);
    });
  }
}


/***/ }),

/***/ 88303:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {


// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  "I": function() { return /* binding */ BaseBuilderParamConfig; },
  "T": function() { return /* binding */ TypedBuilderMatNode; }
});

// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/nodes/mat/_Base.ts
var _Base = __webpack_require__(78058);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/nodes/utils/params/ParamsConfig.ts
var ParamsConfig = __webpack_require__(96949);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/nodes/utils/BasePersistedConfig.ts
var BasePersistedConfig = __webpack_require__(14802);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/nodes/gl/code/assemblers/materials/OnBeforeCompile.ts
var OnBeforeCompile = __webpack_require__(43008);
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/gl/code/assemblers/materials/MaterialPersistedConfig.ts

var __async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};


function _removeShaders(data) {
  const onBeforeCompileDataJSONWithoutShaders = {
    paramConfigs: data.paramConfigs,
    timeDependent: data.timeDependent,
    resolutionDependent: data.resolutionDependent,
    raymarchingLightsWorldCoordsDependent: data.raymarchingLightsWorldCoordsDependent
  };
  return onBeforeCompileDataJSONWithoutShaders;
}
function _addShaders(data, options) {
  const onBeforeCompileDataJSON = {
    paramConfigs: data.paramConfigs,
    timeDependent: data.timeDependent,
    resolutionDependent: data.resolutionDependent,
    raymarchingLightsWorldCoordsDependent: data.raymarchingLightsWorldCoordsDependent,
    fragmentShader: options.fragment,
    vertexShader: options.vertex
  };
  return onBeforeCompileDataJSON;
}
function _shaderKey(shaderType, customMaterialName) {
  return customMaterialName ? `${customMaterialName}.${shaderType}` : shaderType;
}
class MaterialPersistedConfig extends BasePersistedConfig/* BasePersistedConfig */.p {
  constructor(node) {
    super(node);
    this.node = node;
  }
  toData() {
    return __async(this, null, function* () {
      const assemblerController = this.node.assemblerController();
      if (!assemblerController) {
        return;
      }
      const assembler = assemblerController.assembler;
      const onBeforeCompileData = assembler.onBeforeCompileData();
      if (!onBeforeCompileData) {
        return;
      }
      const onBeforeCompileDataJSON = OnBeforeCompile/* OnBeforeCompileDataConverter.toJSON */.zA.toJSON(onBeforeCompileData);
      const onBeforeCompileDataJSONWithoutShaders = _removeShaders(onBeforeCompileDataJSON);
      const shaders = {
        [_shaderKey("vertex")]: onBeforeCompileDataJSON.vertexShader,
        [_shaderKey("fragment")]: onBeforeCompileDataJSON.fragmentShader
      };
      const customMaterialsData = {};
      const material = yield this.node.material();
      if (!material) {
        return;
      }
      const customMaterials = material.customMaterials;
      if (customMaterials) {
        assembler.traverseCustomAssemblers((customAssembler, customMaterialName) => {
          const customOnBeforeCompileData = customAssembler.onBeforeCompileData();
          if (customOnBeforeCompileData) {
            const customMaterial = customMaterials[customMaterialName];
            if (customMaterial) {
              const customMaterialData = this._materialToJson(customMaterial, {
                node: this.node,
                suffix: customMaterialName
              });
              if (customMaterialData) {
                const data2 = OnBeforeCompile/* OnBeforeCompileDataConverter.toJSON */.zA.toJSON(customOnBeforeCompileData);
                const dataWithoutShaders = _removeShaders(data2);
                customMaterialsData[customMaterialName] = {
                  material: customMaterialData,
                  onBeforeCompileDataJSONWithoutShaders: dataWithoutShaders
                };
                shaders[_shaderKey("vertex", customMaterialName)] = data2.vertexShader;
                shaders[_shaderKey("fragment", customMaterialName)] = data2.fragmentShader;
              }
            }
          }
        });
      }
      const materialData = this._materialToJson(material, {
        node: this.node,
        suffix: "main"
      });
      if (!materialData) {
        console.warn("failed to save material from node", this.node.path());
      }
      const data = {
        material: materialData || {},
        onBeforeCompileDataJSONWithoutShaders,
        // uniforms_time_dependent: assemblerController.assembler.uniformsTimeDependent(),
        // uniforms_resolution_dependent: assemblerController.assembler.uniformsResolutionDependent(),
        // param_uniform_pairs: param_uniform_pairs,
        customMaterials: customMaterialsData,
        shaders
      };
      return data;
    });
  }
  load(data) {
    const assemblerController = this.node.assemblerController();
    if (assemblerController) {
      return;
    }
    this._material = this._loadMaterial(data.material);
    if (!this._material) {
      return;
    }
    const shaders = data.shaders;
    if (!shaders) {
      console.warn(`${this.node.path()}: persisted config has no shaders`);
      return;
    }
    const onBeforeCompileDataJSON = _addShaders(
      data.onBeforeCompileDataJSONWithoutShaders,
      {
        vertex: shaders[_shaderKey("vertex")],
        fragment: shaders[_shaderKey("fragment")]
      }
    );
    const onBeforeCompileData = OnBeforeCompile/* OnBeforeCompileDataConverter.fromJSON */.zA.fromJSON(onBeforeCompileDataJSON);
    const material = this._material;
    (0,OnBeforeCompile/* assignOnBeforeCompileDataAndFunction */.VX)(this.node.scene(), material, onBeforeCompileData);
    for (let paramConfig of onBeforeCompileData.paramConfigs) {
      paramConfig.applyToNode(this.node);
    }
    this._material.customMaterials = this._material.customMaterials || {};
    if (data.customMaterials) {
      const customMatNames = Object.keys(data.customMaterials);
      for (const customMatName of customMatNames) {
        const customMatData = data.customMaterials[customMatName];
        const customMat = this._loadMaterial(customMatData.material);
        if (customMat) {
          const onBeforeCompileDataJSON2 = _addShaders(
            customMatData.onBeforeCompileDataJSONWithoutShaders,
            {
              vertex: shaders[_shaderKey("vertex", customMatName)],
              fragment: shaders[_shaderKey("fragment", customMatName)]
            }
          );
          const customOnBeforeCompileData = OnBeforeCompile/* OnBeforeCompileDataConverter.fromJSON */.zA.fromJSON(onBeforeCompileDataJSON2);
          customOnBeforeCompileData.paramConfigs = onBeforeCompileData.paramConfigs;
          (0,OnBeforeCompile/* assignOnBeforeCompileDataAndFunction */.VX)(this.node.scene(), customMat, customOnBeforeCompileData);
          this._material.customMaterials[customMatName] = customMat;
        }
      }
    }
  }
  material() {
    return this._material;
  }
}

// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/poly/NodeContext.ts
var NodeContext = __webpack_require__(52070);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/core/Type.ts
var Type = __webpack_require__(19037);
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/mat/_BaseBuilder.ts






function BaseBuilderParamConfig(Base) {
  return class Mixin extends Base {
    constructor() {
      super(...arguments);
      /** @param if toggled on, the shader will be built from the gl nodes of another material. This can be useful to have multiple materials use the same gl network, but still set the uniforms differently */
      this.setBuilderNode = ParamsConfig/* ParamConfig.BOOLEAN */.XC.BOOLEAN(0, {
        callback: (node) => {
          TypedBuilderMatNode.PARAM_CALLBACK_setCompileRequired(node);
        }
      });
      /** @param builder node */
      this.builderNode = ParamsConfig/* ParamConfig.NODE_PATH */.XC.NODE_PATH("", {
        visibleIf: { setBuilderNode: true },
        callback: (node) => {
          TypedBuilderMatNode.PARAM_CALLBACK_setCompileRequired(node);
        }
      });
    }
  };
}
class MatBuilderParamsConfig extends BaseBuilderParamConfig(ParamsConfig/* NodeParamsConfig */.yI) {
}
class TypedBuilderMatNode extends _Base/* PrimitiveMatNode */.Q_ {
  constructor() {
    super(...arguments);
    this._childrenControllerContext = NodeContext/* NodeContext.GL */.sy.GL;
    this.persisted_config = new MaterialPersistedConfig(this);
  }
  //
  //
  // MATERIAL
  //
  //
  createMaterial() {
    var _a;
    let material;
    if (this.persisted_config) {
      material = this.persisted_config.material();
    }
    if (!material) {
      material = (_a = this.assemblerController()) == null ? void 0 : _a.assembler.createMaterial();
    }
    return material;
  }
  //
  //
  // ASSEMBLER
  //
  //
  assemblerController() {
    return this._assemblerController = this._assemblerController || this._createAssemblerController();
  }
  customMaterialRequested(customName) {
    return true;
  }
  createNode(node_class, options) {
    return super.createNode(node_class, options);
  }
  children() {
    return super.children();
  }
  nodesByType(type) {
    return super.nodesByType(type);
  }
  childrenAllowed() {
    if (this.assemblerController()) {
      return super.childrenAllowed();
    }
    return false;
  }
  sceneReadonly() {
    return this.assemblerController() == null;
  }
  //
  //
  // COMPILATION
  //
  //
  compileIfRequired(material) {
    var _a;
    if ((_a = this.assemblerController()) == null ? void 0 : _a.compileRequired()) {
      try {
        this._compile(material);
      } catch (err) {
        const message = err.message || "failed to compile";
        this.states.error.set(message);
      }
    }
  }
  _compile(material) {
    const assemblerController = this.assemblerController();
    if (material && assemblerController) {
      assemblerController.assembler.setGlParentNode(this);
      this._setAssemblerGlParentNode(assemblerController);
      assemblerController.assembler.compileMaterial(material);
      assemblerController.post_compile();
    }
  }
  _setAssemblerGlParentNode(assemblerController) {
    if (!(0,Type/* isBooleanTrue */.bI)(this.pv.setBuilderNode)) {
      return;
    }
    const resolvedNode = this.pv.builderNode.nodeWithContext(NodeContext/* NodeContext.MAT */.sy.MAT);
    if (!resolvedNode) {
      return;
    }
    const resolvedBuilderNode = resolvedNode;
    if (!resolvedBuilderNode.assemblerController()) {
      this.states.error.set(`resolved node '${resolvedNode.path()}' is not a builder node`);
      return;
    }
    if (resolvedBuilderNode.type() != this.type()) {
      this.states.error.set(
        `resolved node '${resolvedNode.path()}' does not have the same type '${resolvedNode.type()}' as current node '${this.type()}'`
      );
      return;
    }
    assemblerController.assembler.setGlParentNode(resolvedBuilderNode);
  }
  static PARAM_CALLBACK_setCompileRequired(node) {
    node.PARAM_CALLBACK_setCompileRequired();
  }
  PARAM_CALLBACK_setCompileRequired() {
    var _a;
    (_a = this.assemblerController()) == null ? void 0 : _a.setCompilationRequired(true);
  }
}


/***/ }),

/***/ 99233:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "b": function() { return /* binding */ DefaultFolderParamConfig; }
/* harmony export */ });
/* harmony import */ var _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(96949);


function DefaultFolderParamConfig(Base) {
  return class Mixin extends Base {
    constructor() {
      super(...arguments);
      this.default = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_0__/* .ParamConfig.FOLDER */ .XC.FOLDER(null);
    }
  };
}


/***/ }),

/***/ 45231:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "o": function() { return /* binding */ TexturesFolderParamConfig; }
/* harmony export */ });
/* harmony import */ var _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(96949);


function TexturesFolderParamConfig(Base) {
  return class Mixin extends Base {
    constructor() {
      super(...arguments);
      this.textures = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_0__/* .ParamConfig.FOLDER */ .XC.FOLDER(null);
    }
  };
}


/***/ }),

/***/ 9161:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "N": function() { return /* binding */ FogParamConfig; },
/* harmony export */   "z": function() { return /* binding */ UniformFogController; }
/* harmony export */ });
/* harmony import */ var _BaseController__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(4418);
/* harmony import */ var _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(96949);
/* harmony import */ var _core_BooleanValue__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(19037);

var __async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};




function FogParamConfig(Base) {
  return class Mixin extends Base {
    constructor() {
      super(...arguments);
      /** @param toggle on if you have a fog in the scene and the material should be affected by it */
      this.useFog = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_0__/* .ParamConfig.BOOLEAN */ .XC.BOOLEAN(0);
    }
  };
}
class FogUniformsParamsConfig extends FogParamConfig(_utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_0__/* .NodeParamsConfig */ .yI) {
}
function isValidFogMaterial(material) {
  if (!material) {
    return false;
  }
  return material.fog != null;
}
class FogUniformsMatNode extends (/* unused pure expression or super */ null && (TypedMatNode)) {
}
class UniformFogController extends _BaseController__WEBPACK_IMPORTED_MODULE_1__/* .BaseController */ .x {
  constructor(node) {
    super(node);
    this.node = node;
  }
  static update(node) {
    return __async(this, null, function* () {
      const material = yield node.material();
      if (!isValidFogMaterial(material)) {
        return;
      }
      node.controllers.uniformFog.updateMaterial(material);
    });
  }
  updateMaterial(material) {
    const pv = this.node.pv;
    material.fog = (0,_core_BooleanValue__WEBPACK_IMPORTED_MODULE_2__/* .isBooleanTrue */ .bI)(pv.useFog);
  }
  getTextures(material, record) {
  }
  setParamsFromMaterial(material, record) {
    this.node.p.useFog.set(material.fog);
  }
}


/***/ }),

/***/ 11803:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "z": function() { return /* binding */ CUSTOM_MAT_PARAM_OPTIONS; }
/* harmony export */ });

function customMaterialBaseSetRecompileRequired(node) {
  var _a;
  (_a = node.assemblerController()) == null ? void 0 : _a.setCompilationRequired();
}
const CUSTOM_MAT_PARAM_OPTIONS = {
  callback: (node) => customMaterialBaseSetRecompileRequired(node)
};


/***/ })

}])
//# sourceMappingURL=_polygonjs_polygonjs_src_engine_nodes_mat_RayMarchingBuilder_ts.bfcb20d625d084be0012.js.map