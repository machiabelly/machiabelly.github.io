(self["webpackChunk"] = self["webpackChunk"] || []).push([["src_engine_examples_examples_sop_PerspectiveCamera_lookAtClickedObject_ts"],{

/***/ 22231:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "createData": function() { return /* binding */ createData; }
/* harmony export */ });
/* harmony import */ var _polygonjs_polygonjs_src_engine_poly_ParamType__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(51254);
/* harmony import */ var _polygonjs_polygonjs_src_core_geometry_Constant__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(91568);



function createData(options) {
  const { scene } = options;
  const root = scene.root();
  const scene_root_nodes = {};
  function create_objects(parentNode) {
    var objects = parentNode.createNode("geo");
    objects.setName("objects");
    const objects_nodes = {};
    function create_BVH1(objects2) {
      var BVH1 = objects2.createNode("BVH");
      BVH1.setName("BVH1");
      const BVH1_nodes = {};
      BVH1.uiData.setComment(
        "this adds a BVH to the object, which is to optimize the intersection detection with the cursor. This isn't necessary in this scene, as the objects are pretty light, but it would be if the geometries had more polygons"
      );
      BVH1.uiData.setPosition(-500, 1150);
      BVH1.params.postCreateSpareParams();
      BVH1.params.runOnSceneLoadHooks();
      return { node: BVH1, children: BVH1_nodes };
    }
    function create_actor_appliedToIndividualObjects(objects2) {
      var actor_appliedToIndividualObjects = objects2.createNode("actor");
      actor_appliedToIndividualObjects.setName("actor_appliedToIndividualObjects");
      const actor_appliedToIndividualObjects_nodes = {};
      function create_getObject1(actor_appliedToIndividualObjects2) {
        var getObject1 = actor_appliedToIndividualObjects2.createNode("getObject");
        getObject1.setName("getObject1");
        const getObject1_nodes = {};
        getObject1.uiData.setPosition(-50, 550);
        getObject1.p.getCurrentObject.set(false);
        getObject1.p.mask.set("*perspectiveCamera_MAIN");
        getObject1.params.postCreateSpareParams();
        getObject1.params.runOnSceneLoadHooks();
        return { node: getObject1, children: getObject1_nodes };
      }
      function create_getObjectProperty1(actor_appliedToIndividualObjects2) {
        var getObjectProperty1 = actor_appliedToIndividualObjects2.createNode("getObjectProperty");
        getObjectProperty1.setName("getObjectProperty1");
        const getObjectProperty1_nodes = {};
        getObjectProperty1.uiData.setPosition(100, 700);
        getObjectProperty1.params.postCreateSpareParams();
        getObjectProperty1.params.runOnSceneLoadHooks();
        return { node: getObjectProperty1, children: getObjectProperty1_nodes };
      }
      function create_onObjectClick1(actor_appliedToIndividualObjects2) {
        var onObjectClick1 = actor_appliedToIndividualObjects2.createNode("onObjectClick");
        onObjectClick1.setName("onObjectClick1");
        const onObjectClick1_nodes = {};
        onObjectClick1.uiData.setComment(
          "this sends a trigger when an object is clicked. The trigger is then received by [setObjectAttribute1](../setObjectAttribute1), which, unlike [setObjectAttribute2](../setObjectAttribute2), will not set an attribute on the current object, but instead on the camera. This happens because we override the `Object3D` input, with the node [getObject1](../getObject1), which fetches the camera by its name, using a mask `*perspectiveCamera_MAIN`"
        );
        onObjectClick1.uiData.setPosition(-50, 50);
        onObjectClick1.params.postCreateSpareParams();
        onObjectClick1.params.runOnSceneLoadHooks();
        return { node: onObjectClick1, children: onObjectClick1_nodes };
      }
      function create_onObjectHover1(actor_appliedToIndividualObjects2) {
        var onObjectHover1 = actor_appliedToIndividualObjects2.createNode("onObjectHover");
        onObjectHover1.setName("onObjectHover1");
        const onObjectHover1_nodes = {};
        onObjectHover1.uiData.setComment(
          "this node sends a trigger whenever an object is hovered, or when the cursor does not hover it anymore. When that trigger is sent, it is received by [setObjectAttribute2](../setObjectAttribute2), which then sets the `hovered` attribute accordingly. This is then used by [actor_objectsParent](../../actor_objectsParent)"
        );
        onObjectHover1.uiData.setPosition(-50, -350);
        onObjectHover1.params.postCreateSpareParams();
        onObjectHover1.params.runOnSceneLoadHooks();
        return { node: onObjectHover1, children: onObjectHover1_nodes };
      }
      function create_setObjectAttribute1(actor_appliedToIndividualObjects2) {
        var setObjectAttribute1 = actor_appliedToIndividualObjects2.createNode("setObjectAttribute");
        setObjectAttribute1.setName("setObjectAttribute1");
        const setObjectAttribute1_nodes = {};
        setObjectAttribute1.uiData.setComment(
          "as this node sets the `lookAtTarget` attribute on the camera, it needs a way to know what value it should set it to.\n\nIt takes that value from its `value` input, which comes from the node [getObjectProperty1](../getObjectProperty1), which returns the value of t he clicked object."
        );
        setObjectAttribute1.uiData.setPosition(550, 150);
        setObjectAttribute1.setAttribName("lookAtTarget");
        setObjectAttribute1.p.type.set(6);
        setObjectAttribute1.addParam(_polygonjs_polygonjs_src_engine_poly_ParamType__WEBPACK_IMPORTED_MODULE_0__/* .ParamType.STRING */ ._.STRING, "attribName", "lookAtTarget", {
          spare: true,
          editable: true
        });
        setObjectAttribute1.addParam(_polygonjs_polygonjs_src_engine_poly_ParamType__WEBPACK_IMPORTED_MODULE_0__/* .ParamType.FLOAT */ ._.FLOAT, "lerp", 1, { spare: true, editable: true });
        setObjectAttribute1.addParam(_polygonjs_polygonjs_src_engine_poly_ParamType__WEBPACK_IMPORTED_MODULE_0__/* .ParamType.VECTOR3 */ ._.VECTOR3, "val", [0, 0, 0], { spare: true, editable: false });
        setObjectAttribute1.params.postCreateSpareParams();
        setObjectAttribute1.params.runOnSceneLoadHooks();
        return { node: setObjectAttribute1, children: setObjectAttribute1_nodes };
      }
      function create_setObjectAttribute2(actor_appliedToIndividualObjects2) {
        var setObjectAttribute2 = actor_appliedToIndividualObjects2.createNode("setObjectAttribute");
        setObjectAttribute2.setName("setObjectAttribute2");
        const setObjectAttribute2_nodes = {};
        setObjectAttribute2.uiData.setPosition(350, -350);
        setObjectAttribute2.setAttribName("hovered");
        setObjectAttribute2.p.type.set(0);
        setObjectAttribute2.addParam(_polygonjs_polygonjs_src_engine_poly_ParamType__WEBPACK_IMPORTED_MODULE_0__/* .ParamType.STRING */ ._.STRING, "attribName", "hovered", {
          spare: true,
          editable: true
        });
        setObjectAttribute2.addParam(_polygonjs_polygonjs_src_engine_poly_ParamType__WEBPACK_IMPORTED_MODULE_0__/* .ParamType.FLOAT */ ._.FLOAT, "lerp", 1, { spare: true, editable: true });
        setObjectAttribute2.addParam(_polygonjs_polygonjs_src_engine_poly_ParamType__WEBPACK_IMPORTED_MODULE_0__/* .ParamType.BOOLEAN */ ._.BOOLEAN, "val", false, { spare: true, editable: false });
        setObjectAttribute2.params.postCreateSpareParams();
        setObjectAttribute2.params.runOnSceneLoadHooks();
        return { node: setObjectAttribute2, children: setObjectAttribute2_nodes };
      }
      actor_appliedToIndividualObjects_nodes["getObject1"] = create_getObject1(actor_appliedToIndividualObjects);
      actor_appliedToIndividualObjects_nodes["getObjectProperty1"] = create_getObjectProperty1(
        actor_appliedToIndividualObjects
      );
      actor_appliedToIndividualObjects_nodes["onObjectClick1"] = create_onObjectClick1(
        actor_appliedToIndividualObjects
      );
      actor_appliedToIndividualObjects_nodes["onObjectHover1"] = create_onObjectHover1(
        actor_appliedToIndividualObjects
      );
      actor_appliedToIndividualObjects_nodes["setObjectAttribute1"] = create_setObjectAttribute1(
        actor_appliedToIndividualObjects
      );
      actor_appliedToIndividualObjects_nodes["setObjectAttribute2"] = create_setObjectAttribute2(
        actor_appliedToIndividualObjects
      );
      actor_appliedToIndividualObjects_nodes["setObjectAttribute1"].node.setInput(
        "trigger",
        actor_appliedToIndividualObjects_nodes["onObjectClick1"].node,
        "trigger",
        { noExceptionOnInvalidInput: true }
      );
      actor_appliedToIndividualObjects_nodes["setObjectAttribute1"].node.setInput(
        "Object3D",
        actor_appliedToIndividualObjects_nodes["getObject1"].node,
        "Object3D",
        { noExceptionOnInvalidInput: true }
      );
      actor_appliedToIndividualObjects_nodes["setObjectAttribute1"].node.setInput(
        "val",
        actor_appliedToIndividualObjects_nodes["getObjectProperty1"].node,
        "position",
        { noExceptionOnInvalidInput: true }
      );
      actor_appliedToIndividualObjects_nodes["setObjectAttribute2"].node.setInput(
        "trigger",
        actor_appliedToIndividualObjects_nodes["onObjectHover1"].node,
        "trigger",
        { noExceptionOnInvalidInput: true }
      );
      actor_appliedToIndividualObjects_nodes["setObjectAttribute2"].node.setInput(
        "val",
        actor_appliedToIndividualObjects_nodes["onObjectHover1"].node,
        "hovered",
        { noExceptionOnInvalidInput: true }
      );
      if (actor_appliedToIndividualObjects.childrenController) {
        actor_appliedToIndividualObjects.childrenController.selection.set([
          actor_appliedToIndividualObjects_nodes["getObjectProperty1"].node
        ]);
      }
      actor_appliedToIndividualObjects.uiData.setComment(
        "Here we have 2 actor nodes, [this one](.) and [actor_objectsParent](../actor_objectsParent).\n\nThis one serves 2 purposes:\n\n- setting a `hovered` attribute on an object which is hovered by the cursor. This is then used by the other actor node to change the viewer CSS, in order to change the cursor to a pointer, so that we understand that the object is clickable.\n- setting the camera `lookAtTarget` attribute when clicked, which is what will have the camera look at the object."
      );
      actor_appliedToIndividualObjects.uiData.setPosition(-500, 1550);
      actor_appliedToIndividualObjects.params.postCreateSpareParams();
      actor_appliedToIndividualObjects.params.runOnSceneLoadHooks();
      return { node: actor_appliedToIndividualObjects, children: actor_appliedToIndividualObjects_nodes };
    }
    function create_actor_objectsParent(objects2) {
      var actor_objectsParent = objects2.createNode("actor");
      actor_objectsParent.setName("actor_objectsParent");
      const actor_objectsParent_nodes = {};
      function create_onChildAttributeUpdate1(actor_objectsParent2) {
        var onChildAttributeUpdate1 = actor_objectsParent2.createNode("onChildAttributeUpdate");
        onChildAttributeUpdate1.setName("onChildAttributeUpdate1");
        const onChildAttributeUpdate1_nodes = {};
        onChildAttributeUpdate1.uiData.setComment(
          "this sends a trigger whenever one of its children `hovered` attribute changes.\n\nThis is then received by the [setViewer1](../setViewer1) node, which gets the value from the [or1](../or1) node, which returns `true` if any of its inputs is `true`, or `false` if none is. And its input is an array of the `hovered` attributes of its children."
        );
        onChildAttributeUpdate1.uiData.setPosition(-150, 0);
        onChildAttributeUpdate1.setAttribName("hovered");
        onChildAttributeUpdate1.p.type.set(0);
        onChildAttributeUpdate1.addParam(_polygonjs_polygonjs_src_engine_poly_ParamType__WEBPACK_IMPORTED_MODULE_0__/* .ParamType.STRING */ ._.STRING, "attribName", "hovered", {
          spare: true,
          editable: true
        });
        onChildAttributeUpdate1.params.postCreateSpareParams();
        onChildAttributeUpdate1.params.runOnSceneLoadHooks();
        return { node: onChildAttributeUpdate1, children: onChildAttributeUpdate1_nodes };
      }
      function create_or1(actor_objectsParent2) {
        var or1 = actor_objectsParent2.createNode("or");
        or1.setName("or1");
        const or1_nodes = {};
        or1.uiData.setPosition(200, 150);
        or1.params.postCreateSpareParams();
        or1.params.runOnSceneLoadHooks();
        return { node: or1, children: or1_nodes };
      }
      function create_setViewer1(actor_objectsParent2) {
        var setViewer1 = actor_objectsParent2.createNode("setViewer");
        setViewer1.setName("setViewer1");
        const setViewer1_nodes = {};
        setViewer1.uiData.setPosition(400, 0);
        setViewer1.params.postCreateSpareParams();
        setViewer1.params.runOnSceneLoadHooks();
        return { node: setViewer1, children: setViewer1_nodes };
      }
      actor_objectsParent_nodes["onChildAttributeUpdate1"] = create_onChildAttributeUpdate1(actor_objectsParent);
      actor_objectsParent_nodes["or1"] = create_or1(actor_objectsParent);
      actor_objectsParent_nodes["setViewer1"] = create_setViewer1(actor_objectsParent);
      actor_objectsParent_nodes["or1"].node.setInput(
        "boolean0",
        actor_objectsParent_nodes["onChildAttributeUpdate1"].node,
        "newValues",
        { noExceptionOnInvalidInput: true }
      );
      actor_objectsParent_nodes["setViewer1"].node.setInput(
        "trigger",
        actor_objectsParent_nodes["onChildAttributeUpdate1"].node,
        "trigger",
        { noExceptionOnInvalidInput: true }
      );
      actor_objectsParent_nodes["setViewer1"].node.setInput("set", actor_objectsParent_nodes["or1"].node, "or");
      if (actor_objectsParent.childrenController) {
        actor_objectsParent.childrenController.selection.set([]);
      }
      actor_objectsParent.uiData.setComment(
        "This actor node adds a behavior to the input object, so that it will look at the `hovered` attribute of its children. If any is `true`, it will change the viewer's CSS, which will then change the cursor to a pointer."
      );
      actor_objectsParent.uiData.setPosition(-500, 2400);
      actor_objectsParent.flags.display.set(true);
      actor_objectsParent.params.postCreateSpareParams();
      actor_objectsParent.params.runOnSceneLoadHooks();
      return { node: actor_objectsParent, children: actor_objectsParent_nodes };
    }
    function create_capsule1(objects2) {
      var capsule1 = objects2.createNode("capsule");
      capsule1.setName("capsule1");
      const capsule1_nodes = {};
      capsule1.uiData.setPosition(-950, 0);
      capsule1.params.postCreateSpareParams();
      capsule1.params.runOnSceneLoadHooks();
      return { node: capsule1, children: capsule1_nodes };
    }
    function create_cone1(objects2) {
      var cone1 = objects2.createNode("cone");
      cone1.setName("cone1");
      const cone1_nodes = {};
      cone1.uiData.setPosition(-700, 0);
      cone1.p.radius.set(0.81);
      cone1.p.segmentsRadial.set(26);
      cone1.p.direction.set([0, 1, 0]);
      cone1.params.postCreateSpareParams();
      cone1.params.runOnSceneLoadHooks();
      return { node: cone1, children: cone1_nodes };
    }
    function create_hierarchy1(objects2) {
      var hierarchy1 = objects2.createNode("hierarchy");
      hierarchy1.setName("hierarchy1");
      const hierarchy1_nodes = {};
      hierarchy1.uiData.setComment(
        "this adds a parent to the objects, so that the next actor node is only applied to this new parent"
      );
      hierarchy1.uiData.setPosition(-500, 2100);
      hierarchy1.params.postCreateSpareParams();
      hierarchy1.params.runOnSceneLoadHooks();
      return { node: hierarchy1, children: hierarchy1_nodes };
    }
    function create_merge1(objects2) {
      var merge1 = objects2.createNode("merge");
      merge1.setName("merge1");
      const merge1_nodes = {};
      merge1.uiData.setPosition(-500, 300);
      merge1.p.inputsCount.set(6);
      merge1.io.inputs.setCount(1, 6);
      merge1.params.postCreateSpareParams();
      merge1.params.runOnSceneLoadHooks();
      return { node: merge1, children: merge1_nodes };
    }
    function create_objectsLayout1(objects2) {
      var objectsLayout1 = objects2.createNode("objectsLayout");
      objectsLayout1.setName("objectsLayout1");
      const objectsLayout1_nodes = {};
      objectsLayout1.uiData.setComment("This simply arranges the input objects in a row/column pattern");
      objectsLayout1.uiData.setPosition(-500, 600);
      objectsLayout1.p.maxLayoutWidth.set(5.6);
      objectsLayout1.p.padding.set([0.7, 0.8]);
      objectsLayout1.params.postCreateSpareParams();
      objectsLayout1.params.runOnSceneLoadHooks();
      return { node: objectsLayout1, children: objectsLayout1_nodes };
    }
    function create_roundedBox1(objects2) {
      var roundedBox1 = objects2.createNode("roundedBox");
      roundedBox1.setName("roundedBox1");
      const roundedBox1_nodes = {};
      roundedBox1.uiData.setPosition(-1200, 0);
      roundedBox1.params.postCreateSpareParams();
      roundedBox1.params.runOnSceneLoadHooks();
      return { node: roundedBox1, children: roundedBox1_nodes };
    }
    function create_sphere1(objects2) {
      var sphere1 = objects2.createNode("sphere");
      sphere1.setName("sphere1");
      const sphere1_nodes = {};
      sphere1.uiData.setPosition(-450, 0);
      sphere1.params.postCreateSpareParams();
      sphere1.params.runOnSceneLoadHooks();
      return { node: sphere1, children: sphere1_nodes };
    }
    function create_subnet1(objects2) {
      var subnet1 = objects2.createNode("subnet");
      subnet1.setName("subnet1");
      const subnet1_nodes = {};
      function create_boolean1(subnet12) {
        var boolean1 = subnet12.createNode("boolean");
        boolean1.setName("boolean1");
        const boolean1_nodes = {};
        boolean1.uiData.setPosition(-100, -50);
        boolean1.p.operation.set(1);
        boolean1.params.postCreateSpareParams();
        boolean1.params.runOnSceneLoadHooks();
        return { node: boolean1, children: boolean1_nodes };
      }
      function create_box1(subnet12) {
        var box1 = subnet12.createNode("box");
        box1.setName("box1");
        const box1_nodes = {};
        box1.uiData.setPosition(-200, -250);
        box1.params.postCreateSpareParams();
        box1.params.runOnSceneLoadHooks();
        return { node: box1, children: box1_nodes };
      }
      function create_sphere12(subnet12) {
        var sphere1 = subnet12.createNode("sphere");
        sphere1.setName("sphere1");
        const sphere1_nodes = {};
        sphere1.uiData.setPosition(0, -250);
        sphere1.flags.display.set(true);
        sphere1.p.radius.set(0.63);
        sphere1.params.postCreateSpareParams();
        sphere1.params.runOnSceneLoadHooks();
        return { node: sphere1, children: sphere1_nodes };
      }
      function create_subnetOutput1(subnet12) {
        var subnetOutput1 = subnet12.createNode("subnetOutput");
        subnetOutput1.setName("subnetOutput1");
        const subnetOutput1_nodes = {};
        subnetOutput1.uiData.setPosition(-100, 100);
        subnetOutput1.params.postCreateSpareParams();
        subnetOutput1.params.runOnSceneLoadHooks();
        return { node: subnetOutput1, children: subnetOutput1_nodes };
      }
      subnet1_nodes["boolean1"] = create_boolean1(subnet1);
      subnet1_nodes["box1"] = create_box1(subnet1);
      subnet1_nodes["sphere1"] = create_sphere12(subnet1);
      subnet1_nodes["subnetOutput1"] = create_subnetOutput1(subnet1);
      subnet1_nodes["boolean1"].node.setInput(0, subnet1_nodes["box1"].node);
      subnet1_nodes["boolean1"].node.setInput(1, subnet1_nodes["sphere1"].node);
      subnet1_nodes["subnetOutput1"].node.setInput(0, subnet1_nodes["boolean1"].node);
      if (subnet1.childrenController) {
        subnet1.childrenController.selection.set([subnet1_nodes["boolean1"].node]);
      }
      subnet1.uiData.setPosition(100, 0);
      subnet1.params.postCreateSpareParams();
      subnet1.params.runOnSceneLoadHooks();
      return { node: subnet1, children: subnet1_nodes };
    }
    function create_subnet_colors(objects2) {
      var subnet_colors = objects2.createNode("subnet");
      subnet_colors.setName("subnet_colors");
      const subnet_colors_nodes = {};
      function create_MAT(subnet_colors2) {
        var MAT = subnet_colors2.createNode("materialsNetwork");
        MAT.setName("MAT");
        const MAT_nodes = {};
        function create_meshStandardBuilder1(MAT2) {
          var meshStandardBuilder1 = MAT2.createNode("meshStandardBuilder");
          meshStandardBuilder1.setName("meshStandardBuilder1");
          const meshStandardBuilder1_nodes = {};
          function create_attribute1(meshStandardBuilder12) {
            var attribute1 = meshStandardBuilder12.createNode("attribute");
            attribute1.setName("attribute1");
            const attribute1_nodes = {};
            attribute1.uiData.setPosition(-400, -200);
            attribute1.p.name.set("idn");
            attribute1.params.postCreateSpareParams();
            attribute1.params.runOnSceneLoadHooks();
            return { node: attribute1, children: attribute1_nodes };
          }
          function create_floatToVec3_1(meshStandardBuilder12) {
            var floatToVec3_1 = meshStandardBuilder12.createNode("floatToVec3");
            floatToVec3_1.setName("floatToVec3_1");
            const floatToVec3_1_nodes = {};
            floatToVec3_1.uiData.setPosition(-150, -200);
            floatToVec3_1.p.y.set(0.68);
            floatToVec3_1.p.z.set(0.71);
            floatToVec3_1.params.postCreateSpareParams();
            floatToVec3_1.params.runOnSceneLoadHooks();
            return { node: floatToVec3_1, children: floatToVec3_1_nodes };
          }
          function create_globals1(meshStandardBuilder12) {
            var globals1 = meshStandardBuilder12.createNode("globals");
            globals1.setName("globals1");
            const globals1_nodes = {};
            globals1.uiData.setPosition(-200, 0);
            globals1.params.postCreateSpareParams();
            globals1.params.runOnSceneLoadHooks();
            return { node: globals1, children: globals1_nodes };
          }
          function create_hsvToRgb1(meshStandardBuilder12) {
            var hsvToRgb1 = meshStandardBuilder12.createNode("hsvToRgb");
            hsvToRgb1.setName("hsvToRgb1");
            const hsvToRgb1_nodes = {};
            hsvToRgb1.uiData.setPosition(-50, -200);
            hsvToRgb1.params.postCreateSpareParams();
            hsvToRgb1.params.runOnSceneLoadHooks();
            return { node: hsvToRgb1, children: hsvToRgb1_nodes };
          }
          function create_multAdd1(meshStandardBuilder12) {
            var multAdd1 = meshStandardBuilder12.createNode("multAdd");
            multAdd1.setName("multAdd1");
            const multAdd1_nodes = {};
            multAdd1.uiData.setPosition(-300, -200);
            multAdd1.addParam(_polygonjs_polygonjs_src_engine_poly_ParamType__WEBPACK_IMPORTED_MODULE_0__/* .ParamType.FLOAT */ ._.FLOAT, "value", 0, { spare: true, editable: false });
            multAdd1.addParam(_polygonjs_polygonjs_src_engine_poly_ParamType__WEBPACK_IMPORTED_MODULE_0__/* .ParamType.FLOAT */ ._.FLOAT, "preAdd", 0, { spare: true, editable: true });
            multAdd1.addParam(_polygonjs_polygonjs_src_engine_poly_ParamType__WEBPACK_IMPORTED_MODULE_0__/* .ParamType.FLOAT */ ._.FLOAT, "mult", 1, { spare: true, editable: true });
            multAdd1.params.get("mult").set(0.92);
            multAdd1.addParam(_polygonjs_polygonjs_src_engine_poly_ParamType__WEBPACK_IMPORTED_MODULE_0__/* .ParamType.FLOAT */ ._.FLOAT, "postAdd", 0, { spare: true, editable: true });
            multAdd1.params.postCreateSpareParams();
            multAdd1.params.runOnSceneLoadHooks();
            return { node: multAdd1, children: multAdd1_nodes };
          }
          function create_output1(meshStandardBuilder12) {
            var output1 = meshStandardBuilder12.createNode("output");
            output1.setName("output1");
            const output1_nodes = {};
            output1.uiData.setPosition(200, 0);
            output1.params.postCreateSpareParams();
            output1.params.runOnSceneLoadHooks();
            return { node: output1, children: output1_nodes };
          }
          meshStandardBuilder1_nodes["attribute1"] = create_attribute1(meshStandardBuilder1);
          meshStandardBuilder1_nodes["floatToVec3_1"] = create_floatToVec3_1(meshStandardBuilder1);
          meshStandardBuilder1_nodes["globals1"] = create_globals1(meshStandardBuilder1);
          meshStandardBuilder1_nodes["hsvToRgb1"] = create_hsvToRgb1(meshStandardBuilder1);
          meshStandardBuilder1_nodes["multAdd1"] = create_multAdd1(meshStandardBuilder1);
          meshStandardBuilder1_nodes["output1"] = create_output1(meshStandardBuilder1);
          meshStandardBuilder1_nodes["floatToVec3_1"].node.setInput(
            "x",
            meshStandardBuilder1_nodes["multAdd1"].node,
            "val",
            { noExceptionOnInvalidInput: true }
          );
          meshStandardBuilder1_nodes["hsvToRgb1"].node.setInput(
            "hsv",
            meshStandardBuilder1_nodes["floatToVec3_1"].node,
            "vec3",
            { noExceptionOnInvalidInput: true }
          );
          meshStandardBuilder1_nodes["multAdd1"].node.setInput(
            "value",
            meshStandardBuilder1_nodes["attribute1"].node,
            "val",
            { noExceptionOnInvalidInput: true }
          );
          meshStandardBuilder1_nodes["output1"].node.setInput(
            "color",
            meshStandardBuilder1_nodes["hsvToRgb1"].node,
            "rgb",
            { noExceptionOnInvalidInput: true }
          );
          if (meshStandardBuilder1.childrenController) {
            meshStandardBuilder1.childrenController.selection.set([
              meshStandardBuilder1_nodes["multAdd1"].node
            ]);
          }
          meshStandardBuilder1.uiData.setPosition(0, 250);
          meshStandardBuilder1.params.postCreateSpareParams();
          meshStandardBuilder1.params.runOnSceneLoadHooks();
          return { node: meshStandardBuilder1, children: meshStandardBuilder1_nodes };
        }
        MAT_nodes["meshStandardBuilder1"] = create_meshStandardBuilder1(MAT);
        if (MAT.childrenController) {
          MAT.childrenController.selection.set([]);
        }
        MAT.uiData.setPosition(-200, 150);
        MAT.params.postCreateSpareParams();
        MAT.params.runOnSceneLoadHooks();
        return { node: MAT, children: MAT_nodes };
      }
      function create_attribId1(subnet_colors2) {
        var attribId1 = subnet_colors2.createNode("attribId");
        attribId1.setName("attribId1");
        const attribId1_nodes = {};
        attribId1.uiData.setPosition(0, -150);
        attribId1.setAttribClass(_polygonjs_polygonjs_src_core_geometry_Constant__WEBPACK_IMPORTED_MODULE_1__/* .AttribClass.OBJECT */ .io.OBJECT);
        attribId1.p.id.set(false);
        attribId1.params.postCreateSpareParams();
        attribId1.params.runOnSceneLoadHooks();
        return { node: attribId1, children: attribId1_nodes };
      }
      function create_attribPromote1(subnet_colors2) {
        var attribPromote1 = subnet_colors2.createNode("attribPromote");
        attribPromote1.setName("attribPromote1");
        const attribPromote1_nodes = {};
        attribPromote1.uiData.setPosition(0, 0);
        attribPromote1.setAttribClassFrom(_polygonjs_polygonjs_src_core_geometry_Constant__WEBPACK_IMPORTED_MODULE_1__/* .AttribClass.OBJECT */ .io.OBJECT);
        attribPromote1.setAttribClassTo(_polygonjs_polygonjs_src_core_geometry_Constant__WEBPACK_IMPORTED_MODULE_1__/* .AttribClass.POINT */ .io.POINT);
        attribPromote1.p.name.set("idn");
        attribPromote1.params.postCreateSpareParams();
        attribPromote1.params.runOnSceneLoadHooks();
        return { node: attribPromote1, children: attribPromote1_nodes };
      }
      function create_material1(subnet_colors2) {
        var material1 = subnet_colors2.createNode("material");
        material1.setName("material1");
        const material1_nodes = {};
        material1.uiData.setPosition(0, 150);
        material1.p.material.set("../MAT/meshStandardBuilder1");
        material1.params.postCreateSpareParams();
        material1.params.runOnSceneLoadHooks();
        return { node: material1, children: material1_nodes };
      }
      function create_subnetInput1(subnet_colors2) {
        var subnetInput1 = subnet_colors2.createNode("subnetInput");
        subnetInput1.setName("subnetInput1");
        const subnetInput1_nodes = {};
        subnetInput1.uiData.setPosition(0, -250);
        subnetInput1.flags.display.set(true);
        subnetInput1.params.postCreateSpareParams();
        subnetInput1.params.runOnSceneLoadHooks();
        return { node: subnetInput1, children: subnetInput1_nodes };
      }
      function create_subnetOutput1(subnet_colors2) {
        var subnetOutput1 = subnet_colors2.createNode("subnetOutput");
        subnetOutput1.setName("subnetOutput1");
        const subnetOutput1_nodes = {};
        subnetOutput1.uiData.setPosition(0, 250);
        subnetOutput1.params.postCreateSpareParams();
        subnetOutput1.params.runOnSceneLoadHooks();
        return { node: subnetOutput1, children: subnetOutput1_nodes };
      }
      subnet_colors_nodes["MAT"] = create_MAT(subnet_colors);
      subnet_colors_nodes["attribId1"] = create_attribId1(subnet_colors);
      subnet_colors_nodes["attribPromote1"] = create_attribPromote1(subnet_colors);
      subnet_colors_nodes["material1"] = create_material1(subnet_colors);
      subnet_colors_nodes["subnetInput1"] = create_subnetInput1(subnet_colors);
      subnet_colors_nodes["subnetOutput1"] = create_subnetOutput1(subnet_colors);
      subnet_colors_nodes["attribId1"].node.setInput(0, subnet_colors_nodes["subnetInput1"].node);
      subnet_colors_nodes["attribPromote1"].node.setInput(0, subnet_colors_nodes["attribId1"].node);
      subnet_colors_nodes["material1"].node.setInput(0, subnet_colors_nodes["attribPromote1"].node);
      subnet_colors_nodes["subnetOutput1"].node.setInput(0, subnet_colors_nodes["material1"].node);
      if (subnet_colors.childrenController) {
        subnet_colors.childrenController.selection.set([]);
      }
      subnet_colors.uiData.setComment(
        "this adds a material with some colors to the objects, just to make the scene a bit nicer to work with"
      );
      subnet_colors.uiData.setPosition(-500, 450);
      subnet_colors.params.postCreateSpareParams();
      subnet_colors.params.runOnSceneLoadHooks();
      return { node: subnet_colors, children: subnet_colors_nodes };
    }
    function create_torus1(objects2) {
      var torus1 = objects2.createNode("torus");
      torus1.setName("torus1");
      const torus1_nodes = {};
      torus1.uiData.setPosition(-150, 0);
      torus1.p.radius.set(0.13);
      torus1.p.radiusTube.set(0.06);
      torus1.p.direction.set([0, 0, 1]);
      torus1.params.postCreateSpareParams();
      torus1.params.runOnSceneLoadHooks();
      return { node: torus1, children: torus1_nodes };
    }
    function create_transform1(objects2) {
      var transform1 = objects2.createNode("transform");
      transform1.setName("transform1");
      const transform1_nodes = {};
      transform1.uiData.setComment(
        "this moves them up. Note that this transform node is set to `multiply matrix`, so that the translation set by the [objectsLayout1](../objectsLayout1) (or any other transform) is not cancelled."
      );
      transform1.uiData.setPosition(-500, 800);
      transform1.p.applyOn.set(1);
      transform1.p.objectMode.set(1);
      transform1.p.t.set([0, 1.7, 0]);
      transform1.params.postCreateSpareParams();
      transform1.params.runOnSceneLoadHooks();
      return { node: transform1, children: transform1_nodes };
    }
    objects_nodes["BVH1"] = create_BVH1(objects);
    objects_nodes["actor_appliedToIndividualObjects"] = create_actor_appliedToIndividualObjects(objects);
    objects_nodes["actor_objectsParent"] = create_actor_objectsParent(objects);
    objects_nodes["capsule1"] = create_capsule1(objects);
    objects_nodes["cone1"] = create_cone1(objects);
    objects_nodes["hierarchy1"] = create_hierarchy1(objects);
    objects_nodes["merge1"] = create_merge1(objects);
    objects_nodes["objectsLayout1"] = create_objectsLayout1(objects);
    objects_nodes["roundedBox1"] = create_roundedBox1(objects);
    objects_nodes["sphere1"] = create_sphere1(objects);
    objects_nodes["subnet1"] = create_subnet1(objects);
    objects_nodes["subnet_colors"] = create_subnet_colors(objects);
    objects_nodes["torus1"] = create_torus1(objects);
    objects_nodes["transform1"] = create_transform1(objects);
    objects_nodes["BVH1"].node.setInput(0, objects_nodes["transform1"].node);
    objects_nodes["actor_appliedToIndividualObjects"].node.setInput(0, objects_nodes["BVH1"].node);
    objects_nodes["actor_objectsParent"].node.setInput(0, objects_nodes["hierarchy1"].node);
    objects_nodes["hierarchy1"].node.setInput(0, objects_nodes["actor_appliedToIndividualObjects"].node);
    objects_nodes["merge1"].node.setInput(0, objects_nodes["roundedBox1"].node);
    objects_nodes["merge1"].node.setInput(1, objects_nodes["capsule1"].node);
    objects_nodes["merge1"].node.setInput(2, objects_nodes["cone1"].node);
    objects_nodes["merge1"].node.setInput(3, objects_nodes["sphere1"].node);
    objects_nodes["merge1"].node.setInput(4, objects_nodes["torus1"].node);
    objects_nodes["merge1"].node.setInput(5, objects_nodes["subnet1"].node);
    objects_nodes["objectsLayout1"].node.setInput(0, objects_nodes["subnet_colors"].node);
    objects_nodes["subnet_colors"].node.setInput(0, objects_nodes["merge1"].node);
    objects_nodes["transform1"].node.setInput(0, objects_nodes["objectsLayout1"].node);
    if (objects.childrenController) {
      objects.childrenController.selection.set([]);
    }
    objects.uiData.setComment(
      "This node contains the 6 objects.\n\nWe are using actor nodes [inside](.) to add a behavior to them, which is what will set an attribute on the main camera, which in turn is what will make the camera look at those objects when clicked"
    );
    objects.uiData.setPosition(-50, -150);
    objects.flags.display.set(true);
    objects.params.postCreateSpareParams();
    objects.params.runOnSceneLoadHooks();
    return { node: objects, children: objects_nodes };
  }
  function create_cameras(parentNode) {
    var cameras = parentNode.createNode("geo");
    cameras.setName("cameras");
    const cameras_nodes = {};
    function create_actor1(cameras2) {
      var actor1 = cameras2.createNode("actor");
      actor1.setName("actor1");
      const actor1_nodes = {};
      function create_getObjectAttribute2(actor12) {
        var getObjectAttribute2 = actor12.createNode("getObjectAttribute");
        getObjectAttribute2.setName("getObjectAttribute2");
        const getObjectAttribute2_nodes = {};
        getObjectAttribute2.uiData.setPosition(-150, 350);
        getObjectAttribute2.setAttribName("lookAtTarget");
        getObjectAttribute2.p.type.set(6);
        getObjectAttribute2.addParam(_polygonjs_polygonjs_src_engine_poly_ParamType__WEBPACK_IMPORTED_MODULE_0__/* .ParamType.STRING */ ._.STRING, "attribName", "lookAtTarget", {
          spare: true,
          editable: true
        });
        getObjectAttribute2.addParam(_polygonjs_polygonjs_src_engine_poly_ParamType__WEBPACK_IMPORTED_MODULE_0__/* .ParamType.VECTOR3 */ ._.VECTOR3, "defaultVector3", [0, 0, 0], {
          spare: true,
          editable: true
        });
        getObjectAttribute2.params.postCreateSpareParams();
        getObjectAttribute2.params.runOnSceneLoadHooks();
        return { node: getObjectAttribute2, children: getObjectAttribute2_nodes };
      }
      function create_onTick1(actor12) {
        var onTick1 = actor12.createNode("onTick");
        onTick1.setName("onTick1");
        const onTick1_nodes = {};
        onTick1.uiData.setComment("this triggers an event every frame.");
        onTick1.uiData.setPosition(-150, -100);
        onTick1.params.postCreateSpareParams();
        onTick1.params.runOnSceneLoadHooks();
        return { node: onTick1, children: onTick1_nodes };
      }
      function create_setObjectLookAt1(actor12) {
        var setObjectLookAt1 = actor12.createNode("setObjectLookAt");
        setObjectLookAt1.setName("setObjectLookAt1");
        const setObjectLookAt1_nodes = {};
        setObjectLookAt1.uiData.setComment(
          "as this is triggered every frame, this rotates the camera so that it looks at a specific position.This position in this case is defined by the `lookAtTarget` attribute.\n\nNotice we are using a `lerp` value, which is less than 1, so that the change in rotation is gradual. If lerp was set to 1, the rotation change would be instant."
        );
        setObjectLookAt1.uiData.setPosition(250, 150);
        setObjectLookAt1.p.lerp.set(0.05);
        setObjectLookAt1.params.postCreateSpareParams();
        setObjectLookAt1.params.runOnSceneLoadHooks();
        return { node: setObjectLookAt1, children: setObjectLookAt1_nodes };
      }
      actor1_nodes["getObjectAttribute2"] = create_getObjectAttribute2(actor1);
      actor1_nodes["onTick1"] = create_onTick1(actor1);
      actor1_nodes["setObjectLookAt1"] = create_setObjectLookAt1(actor1);
      actor1_nodes["setObjectLookAt1"].node.setInput("trigger", actor1_nodes["onTick1"].node, "trigger");
      actor1_nodes["setObjectLookAt1"].node.setInput(
        "targetPosition",
        actor1_nodes["getObjectAttribute2"].node,
        "val",
        { noExceptionOnInvalidInput: true }
      );
      if (actor1.childrenController) {
        actor1.childrenController.selection.set([]);
      }
      actor1.uiData.setComment(
        "The actor node is what will have the camera look at the position defined by its `lookAtTarget` attribute. [Enter it](.) to see the setup."
      );
      actor1.uiData.setPosition(-200, 0);
      actor1.params.postCreateSpareParams();
      actor1.params.runOnSceneLoadHooks();
      return { node: actor1, children: actor1_nodes };
    }
    function create_attribCreate1(cameras2) {
      var attribCreate1 = cameras2.createNode("attribCreate");
      attribCreate1.setName("attribCreate1");
      const attribCreate1_nodes = {};
      attribCreate1.uiData.setComment(
        "this node sets the lookAtTarget at the object level, on the camera. We'll use this attribute in the [actor node](../actor1) node below."
      );
      attribCreate1.uiData.setPosition(-200, -300);
      attribCreate1.setAttribClass(_polygonjs_polygonjs_src_core_geometry_Constant__WEBPACK_IMPORTED_MODULE_1__/* .AttribClass.OBJECT */ .io.OBJECT);
      attribCreate1.p.name.set("lookAtTarget");
      attribCreate1.p.size.set(3);
      attribCreate1.p.value3.set([0, 1.8, 0]);
      attribCreate1.params.postCreateSpareParams();
      attribCreate1.params.runOnSceneLoadHooks();
      return { node: attribCreate1, children: attribCreate1_nodes };
    }
    function create_cameraControls1(cameras2) {
      var cameraControls1 = cameras2.createNode("cameraControls");
      cameraControls1.setName("cameraControls1");
      const cameraControls1_nodes = {};
      function create_cameraOrbitControls1(cameraControls12) {
        var cameraOrbitControls1 = cameraControls12.createNode("cameraOrbitControls");
        cameraOrbitControls1.setName("cameraOrbitControls1");
        const cameraOrbitControls1_nodes = {};
        cameraOrbitControls1.uiData.setPosition(0, 0);
        cameraOrbitControls1.params.postCreateSpareParams();
        cameraOrbitControls1.params.runOnSceneLoadHooks();
        return { node: cameraOrbitControls1, children: cameraOrbitControls1_nodes };
      }
      cameraControls1_nodes["cameraOrbitControls1"] = create_cameraOrbitControls1(cameraControls1);
      if (cameraControls1.childrenController) {
        cameraControls1.childrenController.selection.set([]);
      }
      cameraControls1.uiData.setPosition(200, -100);
      cameraControls1.p.node.set("cameraOrbitControls1");
      cameraControls1.params.postCreateSpareParams();
      cameraControls1.params.runOnSceneLoadHooks();
      return { node: cameraControls1, children: cameraControls1_nodes };
    }
    function create_merge1(cameras2) {
      var merge1 = cameras2.createNode("merge");
      merge1.setName("merge1");
      const merge1_nodes = {};
      merge1.uiData.setPosition(-50, 300);
      merge1.flags.display.set(true);
      merge1.params.postCreateSpareParams();
      merge1.params.runOnSceneLoadHooks();
      return { node: merge1, children: merge1_nodes };
    }
    function create_perspectiveCamera_DEBUG(cameras2) {
      var perspectiveCamera_DEBUG = cameras2.createNode("perspectiveCamera");
      perspectiveCamera_DEBUG.setName("perspectiveCamera_DEBUG");
      const perspectiveCamera_DEBUG_nodes = {};
      perspectiveCamera_DEBUG.uiData.setPosition(200, -250);
      perspectiveCamera_DEBUG.params.postCreateSpareParams();
      perspectiveCamera_DEBUG.params.runOnSceneLoadHooks();
      return { node: perspectiveCamera_DEBUG, children: perspectiveCamera_DEBUG_nodes };
    }
    function create_perspectiveCamera_MAIN(cameras2) {
      var perspectiveCamera_MAIN = cameras2.createNode("perspectiveCamera");
      perspectiveCamera_MAIN.setName("perspectiveCamera_MAIN");
      const perspectiveCamera_MAIN_nodes = {};
      perspectiveCamera_MAIN.uiData.setComment(
        "this node creates the main camera. The name of the object is defined by the `name` parameter, currently set to the node name. This will help finding the camera from the [/objects](/objects) node."
      );
      perspectiveCamera_MAIN.uiData.setPosition(-200, -650);
      perspectiveCamera_MAIN.p.position.set([0, 1.8, 5.2]);
      perspectiveCamera_MAIN.params.postCreateSpareParams();
      perspectiveCamera_MAIN.params.runOnSceneLoadHooks();
      return { node: perspectiveCamera_MAIN, children: perspectiveCamera_MAIN_nodes };
    }
    cameras_nodes["actor1"] = create_actor1(cameras);
    cameras_nodes["attribCreate1"] = create_attribCreate1(cameras);
    cameras_nodes["cameraControls1"] = create_cameraControls1(cameras);
    cameras_nodes["merge1"] = create_merge1(cameras);
    cameras_nodes["perspectiveCamera_DEBUG"] = create_perspectiveCamera_DEBUG(cameras);
    cameras_nodes["perspectiveCamera_MAIN"] = create_perspectiveCamera_MAIN(cameras);
    cameras_nodes["actor1"].node.setInput(0, cameras_nodes["attribCreate1"].node);
    cameras_nodes["attribCreate1"].node.setInput(0, cameras_nodes["perspectiveCamera_MAIN"].node);
    cameras_nodes["cameraControls1"].node.setInput(0, cameras_nodes["perspectiveCamera_DEBUG"].node);
    cameras_nodes["merge1"].node.setInput(0, cameras_nodes["actor1"].node);
    cameras_nodes["merge1"].node.setInput(1, cameras_nodes["cameraControls1"].node);
    if (cameras.childrenController) {
      cameras.childrenController.selection.set([]);
    }
    cameras.uiData.setComment(
      "This node contains 2 cameras, the main one and the debug one.\n\n[Enter this node](.) to see how  they are set up."
    );
    cameras.uiData.setPosition(-50, 150);
    cameras.flags.display.set(true);
    cameras.params.postCreateSpareParams();
    cameras.params.runOnSceneLoadHooks();
    return { node: cameras, children: cameras_nodes };
  }
  function create_lights(parentNode) {
    var lights = parentNode.createNode("geo");
    lights.setName("lights");
    const lights_nodes = {};
    function create_hemisphereLight1(lights2) {
      var hemisphereLight1 = lights2.createNode("hemisphereLight");
      hemisphereLight1.setName("hemisphereLight1");
      const hemisphereLight1_nodes = {};
      hemisphereLight1.uiData.setPosition(0, -150);
      hemisphereLight1.flags.display.set(true);
      hemisphereLight1.params.postCreateSpareParams();
      hemisphereLight1.params.runOnSceneLoadHooks();
      return { node: hemisphereLight1, children: hemisphereLight1_nodes };
    }
    lights_nodes["hemisphereLight1"] = create_hemisphereLight1(lights);
    if (lights.childrenController) {
      lights.childrenController.selection.set([]);
    }
    lights.uiData.setPosition(-50, -250);
    lights.flags.display.set(true);
    lights.params.postCreateSpareParams();
    lights.params.runOnSceneLoadHooks();
    return { node: lights, children: lights_nodes };
  }
  function create_grid(parentNode) {
    var grid = parentNode.createNode("geo");
    grid.setName("grid");
    const grid_nodes = {};
    function create_planeHelper1(grid2) {
      var planeHelper1 = grid2.createNode("planeHelper");
      planeHelper1.setName("planeHelper1");
      const planeHelper1_nodes = {};
      planeHelper1.uiData.setPosition(-100, -150);
      planeHelper1.flags.display.set(true);
      planeHelper1.params.postCreateSpareParams();
      planeHelper1.params.runOnSceneLoadHooks();
      return { node: planeHelper1, children: planeHelper1_nodes };
    }
    grid_nodes["planeHelper1"] = create_planeHelper1(grid);
    if (grid.childrenController) {
      grid.childrenController.selection.set([]);
    }
    grid.uiData.setPosition(-50, -350);
    grid.flags.display.set(true);
    grid.params.postCreateSpareParams();
    grid.params.runOnSceneLoadHooks();
    return { node: grid, children: grid_nodes };
  }
  scene_root_nodes["objects"] = create_objects(root);
  scene_root_nodes["cameras"] = create_cameras(root);
  scene_root_nodes["lights"] = create_lights(root);
  scene_root_nodes["grid"] = create_grid(root);
  scene.setFrame(0);
  return {
    scene,
    cameraPath: "/cameras/cameras:sopGroup/perspectiveCamera_MAIN",
    focusedNodes: [],
    //Object.values(scene_root_nodes['geo1'].children).map((n) => n.node),
    autoLayout: false,
    playWhenLoaded: true
  };
}


/***/ })

}])
//# sourceMappingURL=src_engine_examples_examples_sop_PerspectiveCamera_lookAtClickedObject_ts.1886e4fabfb18d485d9f.js.map