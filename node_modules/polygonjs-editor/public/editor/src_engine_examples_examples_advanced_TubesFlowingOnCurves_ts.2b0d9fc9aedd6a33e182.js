(self["webpackChunk"] = self["webpackChunk"] || []).push([["src_engine_examples_examples_advanced_TubesFlowingOnCurves_ts"],{

/***/ 15348:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "createData": function() { return /* binding */ createData; }
/* harmony export */ });
/* harmony import */ var _polygonjs_polygonjs_src_engine_params_ramp_RampValue__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(32998);
/* harmony import */ var _polygonjs_polygonjs_src_engine_poly_ParamType__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(51254);
/* harmony import */ var _polygonjs_polygonjs_src_core_geometry_Constant__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(91568);




function createData(options) {
  const { scene } = options;
  const root = scene.root();
  const scene_root_nodes = {};
  function create_grid(parentNode) {
    var grid = parentNode.createNode("geo");
    grid.setName("grid");
    const grid_nodes = {};
    function create_planeHelper1(grid2) {
      var planeHelper1 = grid2.createNode("planeHelper");
      planeHelper1.setName("planeHelper1");
      const planeHelper1_nodes = {};
      planeHelper1.uiData.setPosition(0, 0);
      planeHelper1.flags.display.set(true);
      planeHelper1.params.postCreateSpareParams();
      planeHelper1.params.runOnSceneLoadHooks();
      return { node: planeHelper1, children: planeHelper1_nodes };
    }
    grid_nodes["planeHelper1"] = create_planeHelper1(grid);
    if (grid.childrenController) {
      grid.childrenController.selection.set([]);
    }
    grid.uiData.setPosition(-50, -250);
    grid.flags.display.set(true);
    grid.params.postCreateSpareParams();
    grid.params.runOnSceneLoadHooks();
    return { node: grid, children: grid_nodes };
  }
  function create_hemisphereLight1(parentNode) {
    var hemisphereLight1 = parentNode.createNode("hemisphereLight");
    hemisphereLight1.setName("hemisphereLight1");
    const hemisphereLight1_nodes = {};
    hemisphereLight1.uiData.setPosition(150, 100);
    hemisphereLight1.flags.display.set(true);
    hemisphereLight1.params.postCreateSpareParams();
    hemisphereLight1.params.runOnSceneLoadHooks();
    return { node: hemisphereLight1, children: hemisphereLight1_nodes };
  }
  function create_perspectiveCamera1(parentNode) {
    var perspectiveCamera1 = parentNode.createNode("perspectiveCamera");
    perspectiveCamera1.setName("perspectiveCamera1");
    const perspectiveCamera1_nodes = {};
    function create_events1(perspectiveCamera12) {
      var events1 = perspectiveCamera12.createNode("eventsNetwork");
      events1.setName("events1");
      const events1_nodes = {};
      function create_cameraOrbitControls1(events12) {
        var cameraOrbitControls1 = events12.createNode("cameraOrbitControls");
        cameraOrbitControls1.setName("cameraOrbitControls1");
        const cameraOrbitControls1_nodes = {};
        cameraOrbitControls1.uiData.setPosition(150, 50);
        cameraOrbitControls1.p.target.set([0.32907281179777914, 1.2384473370734157, -0.11753620559819757]);
        cameraOrbitControls1.params.postCreateSpareParams();
        cameraOrbitControls1.params.runOnSceneLoadHooks();
        return { node: cameraOrbitControls1, children: cameraOrbitControls1_nodes };
      }
      events1_nodes["cameraOrbitControls1"] = create_cameraOrbitControls1(events1);
      if (events1.childrenController) {
        events1.childrenController.selection.set([]);
      }
      events1.uiData.setPosition(-200, 50);
      events1.params.postCreateSpareParams();
      events1.params.runOnSceneLoadHooks();
      return { node: events1, children: events1_nodes };
    }
    perspectiveCamera1_nodes["events1"] = create_events1(perspectiveCamera1);
    if (perspectiveCamera1.childrenController) {
      perspectiveCamera1.childrenController.selection.set([]);
    }
    perspectiveCamera1.uiData.setPosition(-200, 100);
    perspectiveCamera1.flags.display.set(true);
    perspectiveCamera1.p.t.set([4.178093811862789, 1.1456250980634408, 0.8817708724388457]);
    perspectiveCamera1.p.r.set([5.30678306697928, 75.38586692900428, -5.136025997118324]);
    perspectiveCamera1.p.controls.set("./events1/cameraOrbitControls1");
    perspectiveCamera1.params.postCreateSpareParams();
    perspectiveCamera1.params.runOnSceneLoadHooks();
    return { node: perspectiveCamera1, children: perspectiveCamera1_nodes };
  }
  function create_COP(parentNode) {
    var COP = parentNode.createNode("copNetwork");
    COP.setName("COP");
    const COP_nodes = {};
    function create_envMap(COP2) {
      var envMap = COP2.createNode("envMap");
      envMap.setName("envMap");
      const envMap_nodes = {};
      envMap.uiData.setPosition(50, 200);
      envMap.params.postCreateSpareParams();
      envMap.params.runOnSceneLoadHooks();
      return { node: envMap, children: envMap_nodes };
    }
    function create_imageEnv(COP2) {
      var imageEnv = COP2.createNode("imageEXR");
      imageEnv.setName("imageEnv");
      const imageEnv_nodes = {};
      imageEnv.uiData.setPosition(50, 100);
      imageEnv.p.url.set(
        "https://raw.githubusercontent.com/polygonjs/polygonjs-assets/master/textures/piz_compressed.exr"
      );
      imageEnv.params.postCreateSpareParams();
      imageEnv.params.runOnSceneLoadHooks();
      return { node: imageEnv, children: imageEnv_nodes };
    }
    function create_imageUv(COP2) {
      var imageUv = COP2.createNode("image");
      imageUv.setName("imageUv");
      const imageUv_nodes = {};
      imageUv.uiData.setPosition(-100, 100);
      imageUv.p.url.set("https://raw.githubusercontent.com/polygonjs/polygonjs-assets/master/textures/uv.jpg");
      imageUv.p.tflipY.set(true);
      imageUv.params.postCreateSpareParams();
      imageUv.params.runOnSceneLoadHooks();
      return { node: imageUv, children: imageUv_nodes };
    }
    COP_nodes["envMap"] = create_envMap(COP);
    COP_nodes["imageEnv"] = create_imageEnv(COP);
    COP_nodes["imageUv"] = create_imageUv(COP);
    COP_nodes["envMap"].node.setInput(0, COP_nodes["imageEnv"].node);
    if (COP.childrenController) {
      COP.childrenController.selection.set([]);
    }
    COP.uiData.setPosition(-200, 200);
    COP.params.postCreateSpareParams();
    COP.params.runOnSceneLoadHooks();
    return { node: COP, children: COP_nodes };
  }
  function create_curvesEffect(parentNode) {
    var curvesEffect = parentNode.createNode("geo");
    curvesEffect.setName("curvesEffect");
    const curvesEffect_nodes = {};
    function create_MAT(curvesEffect2) {
      var MAT = curvesEffect2.createNode("materialsNetwork");
      MAT.setName("MAT");
      const MAT_nodes = {};
      function create_meshStandardBuilder1(MAT2) {
        var meshStandardBuilder1 = MAT2.createNode("meshStandardBuilder");
        meshStandardBuilder1.setName("meshStandardBuilder1");
        const meshStandardBuilder1_nodes = {};
        function create_abs1(meshStandardBuilder12) {
          var abs1 = meshStandardBuilder12.createNode("abs");
          abs1.setName("abs1");
          const abs1_nodes = {};
          abs1.uiData.setPosition(-500, -50);
          abs1.addParam(_polygonjs_polygonjs_src_engine_poly_ParamType__WEBPACK_IMPORTED_MODULE_0__/* .ParamType.FLOAT */ ._.FLOAT, "in", 0, { spare: true, editable: false });
          abs1.params.postCreateSpareParams();
          abs1.params.runOnSceneLoadHooks();
          return { node: abs1, children: abs1_nodes };
        }
        function create_attribute1(meshStandardBuilder12) {
          var attribute1 = meshStandardBuilder12.createNode("attribute");
          attribute1.setName("attribute1");
          const attribute1_nodes = {};
          attribute1.uiData.setComment("this attribute node reads the `id` attribute on the geometry");
          attribute1.uiData.setPosition(-650, 500);
          attribute1.p.name.set("id");
          attribute1.params.postCreateSpareParams();
          attribute1.params.runOnSceneLoadHooks();
          return { node: attribute1, children: attribute1_nodes };
        }
        function create_attribute2(meshStandardBuilder12) {
          var attribute2 = meshStandardBuilder12.createNode("attribute");
          attribute2.setName("attribute2");
          const attribute2_nodes = {};
          attribute2.uiData.setPosition(-500, -400);
          attribute2.p.name.set("restP");
          attribute2.p.type.set(2);
          attribute2.params.postCreateSpareParams();
          attribute2.params.runOnSceneLoadHooks();
          return { node: attribute2, children: attribute2_nodes };
        }
        function create_attribute3(meshStandardBuilder12) {
          var attribute3 = meshStandardBuilder12.createNode("attribute");
          attribute3.setName("attribute3");
          const attribute3_nodes = {};
          attribute3.uiData.setPosition(-850, -150);
          attribute3.p.name.set("idn");
          attribute3.params.postCreateSpareParams();
          attribute3.params.runOnSceneLoadHooks();
          return { node: attribute3, children: attribute3_nodes };
        }
        function create_constant_CURVE_LENGTH(meshStandardBuilder12) {
          var constant_CURVE_LENGTH = meshStandardBuilder12.createNode("constant");
          constant_CURVE_LENGTH.setName("constant_CURVE_LENGTH");
          const constant_CURVE_LENGTH_nodes = {};
          constant_CURVE_LENGTH.uiData.setComment(
            "Using the 3 constant nodes, you can control various aspects of the effect, such as `speed`, `delay` and `curve length`.\n\nAs you can see, those are simple constant plugged into various parts of the network. You could as easily add your own controls.\n\nAnd keep in mind that changing those values changes the shader itself. This makes it recompile, which can impact performance. If you want to change those values in realtime, use [param](https://polygonjs.com/docs/nodes/gl/param) nodes instead"
          );
          constant_CURVE_LENGTH.uiData.setPosition(-1200, 300);
          constant_CURVE_LENGTH.p.float.set(0.21);
          constant_CURVE_LENGTH.params.postCreateSpareParams();
          constant_CURVE_LENGTH.params.runOnSceneLoadHooks();
          return { node: constant_CURVE_LENGTH, children: constant_CURVE_LENGTH_nodes };
        }
        function create_constant_SPEED(meshStandardBuilder12) {
          var constant_SPEED = meshStandardBuilder12.createNode("constant");
          constant_SPEED.setName("constant_SPEED");
          const constant_SPEED_nodes = {};
          constant_SPEED.uiData.setPosition(-1200, 0);
          constant_SPEED.p.float.set(0.4);
          constant_SPEED.params.postCreateSpareParams();
          constant_SPEED.params.runOnSceneLoadHooks();
          return { node: constant_SPEED, children: constant_SPEED_nodes };
        }
        function create_constant_TIME_OFFSET(meshStandardBuilder12) {
          var constant_TIME_OFFSET = meshStandardBuilder12.createNode("constant");
          constant_TIME_OFFSET.setName("constant_TIME_OFFSET");
          const constant_TIME_OFFSET_nodes = {};
          constant_TIME_OFFSET.uiData.setPosition(-1200, 150);
          constant_TIME_OFFSET.p.float.set(0.29);
          constant_TIME_OFFSET.params.postCreateSpareParams();
          constant_TIME_OFFSET.params.runOnSceneLoadHooks();
          return { node: constant_TIME_OFFSET, children: constant_TIME_OFFSET_nodes };
        }
        function create_divide1(meshStandardBuilder12) {
          var divide1 = meshStandardBuilder12.createNode("divide");
          divide1.setName("divide1");
          const divide1_nodes = {};
          divide1.uiData.setPosition(-750, 250);
          divide1.addParam(_polygonjs_polygonjs_src_engine_poly_ParamType__WEBPACK_IMPORTED_MODULE_0__/* .ParamType.FLOAT */ ._.FLOAT, "div0", 1, { spare: true, editable: true });
          divide1.addParam(_polygonjs_polygonjs_src_engine_poly_ParamType__WEBPACK_IMPORTED_MODULE_0__/* .ParamType.FLOAT */ ._.FLOAT, "div1", 1, { spare: true, editable: false });
          divide1.addParam(_polygonjs_polygonjs_src_engine_poly_ParamType__WEBPACK_IMPORTED_MODULE_0__/* .ParamType.FLOAT */ ._.FLOAT, "div2", 1, { spare: true, editable: true });
          divide1.params.postCreateSpareParams();
          divide1.params.runOnSceneLoadHooks();
          return { node: divide1, children: divide1_nodes };
        }
        function create_floatToVec2_1(meshStandardBuilder12) {
          var floatToVec2_1 = meshStandardBuilder12.createNode("floatToVec2");
          floatToVec2_1.setName("floatToVec2_1");
          const floatToVec2_1_nodes = {};
          floatToVec2_1.uiData.setPosition(-300, 500);
          floatToVec2_1.p.y.set(0.53);
          floatToVec2_1.params.postCreateSpareParams();
          floatToVec2_1.params.runOnSceneLoadHooks();
          return { node: floatToVec2_1, children: floatToVec2_1_nodes };
        }
        function create_floatToVec3_1(meshStandardBuilder12) {
          var floatToVec3_1 = meshStandardBuilder12.createNode("floatToVec3");
          floatToVec3_1.setName("floatToVec3_1");
          const floatToVec3_1_nodes = {};
          floatToVec3_1.uiData.setPosition(0, 500);
          floatToVec3_1.p.y.set(0.87);
          floatToVec3_1.p.z.set(0.87);
          floatToVec3_1.params.postCreateSpareParams();
          floatToVec3_1.params.runOnSceneLoadHooks();
          return { node: floatToVec3_1, children: floatToVec3_1_nodes };
        }
        function create_globals1(meshStandardBuilder12) {
          var globals1 = meshStandardBuilder12.createNode("globals");
          globals1.setName("globals1");
          const globals1_nodes = {};
          globals1.uiData.setPosition(-950, -700);
          globals1.params.postCreateSpareParams();
          globals1.params.runOnSceneLoadHooks();
          return { node: globals1, children: globals1_nodes };
        }
        function create_hsvToRgb1(meshStandardBuilder12) {
          var hsvToRgb1 = meshStandardBuilder12.createNode("hsvToRgb");
          hsvToRgb1.setName("hsvToRgb1");
          const hsvToRgb1_nodes = {};
          hsvToRgb1.uiData.setComment("Here we use the `id` attribute to drive the color.");
          hsvToRgb1.uiData.setPosition(150, 500);
          hsvToRgb1.params.postCreateSpareParams();
          hsvToRgb1.params.runOnSceneLoadHooks();
          return { node: hsvToRgb1, children: hsvToRgb1_nodes };
        }
        function create_mix1(meshStandardBuilder12) {
          var mix1 = meshStandardBuilder12.createNode("mix");
          mix1.setName("mix1");
          const mix1_nodes = {};
          mix1.uiData.setComment(
            "This mix is doing a similar modification to the [blend](../../blend1) node at the geometry level, but is instead doing into in the shader, which is more performant.\n\nAlso, an important difference is that for the blend node, the `blend` parameter is global and affect the object uniformly.\n\nBut in with this mix node, the `blend` can be changed per point. So in this case, the blend depends on the `idn` attribute, as well as the time. And this is where we get the curve effect created."
          );
          mix1.uiData.setPosition(-200, -500);
          mix1.addParam(_polygonjs_polygonjs_src_engine_poly_ParamType__WEBPACK_IMPORTED_MODULE_0__/* .ParamType.VECTOR3 */ ._.VECTOR3, "value0", [0, 0, 0], { spare: true, editable: false });
          mix1.addParam(_polygonjs_polygonjs_src_engine_poly_ParamType__WEBPACK_IMPORTED_MODULE_0__/* .ParamType.VECTOR3 */ ._.VECTOR3, "value1", [0, 0, 0], { spare: true, editable: false });
          mix1.addParam(_polygonjs_polygonjs_src_engine_poly_ParamType__WEBPACK_IMPORTED_MODULE_0__/* .ParamType.FLOAT */ ._.FLOAT, "blend", 0.5, { spare: true, editable: false });
          mix1.params.get("blend").set(0.46);
          mix1.params.postCreateSpareParams();
          mix1.params.runOnSceneLoadHooks();
          return { node: mix1, children: mix1_nodes };
        }
        function create_multAdd1(meshStandardBuilder12) {
          var multAdd1 = meshStandardBuilder12.createNode("multAdd");
          multAdd1.setName("multAdd1");
          const multAdd1_nodes = {};
          multAdd1.uiData.setPosition(-850, 0);
          multAdd1.addParam(_polygonjs_polygonjs_src_engine_poly_ParamType__WEBPACK_IMPORTED_MODULE_0__/* .ParamType.FLOAT */ ._.FLOAT, "value", 0, { spare: true, editable: false });
          multAdd1.addParam(_polygonjs_polygonjs_src_engine_poly_ParamType__WEBPACK_IMPORTED_MODULE_0__/* .ParamType.FLOAT */ ._.FLOAT, "preAdd", 0, { spare: true, editable: true });
          multAdd1.params.get("preAdd").set(-1.0000000000000004);
          multAdd1.addParam(_polygonjs_polygonjs_src_engine_poly_ParamType__WEBPACK_IMPORTED_MODULE_0__/* .ParamType.FLOAT */ ._.FLOAT, "mult", 1, { spare: true, editable: false });
          multAdd1.params.get("mult").set(0.38);
          multAdd1.addParam(_polygonjs_polygonjs_src_engine_poly_ParamType__WEBPACK_IMPORTED_MODULE_0__/* .ParamType.FLOAT */ ._.FLOAT, "postAdd", 0, { spare: true, editable: false });
          multAdd1.params.postCreateSpareParams();
          multAdd1.params.runOnSceneLoadHooks();
          return { node: multAdd1, children: multAdd1_nodes };
        }
        function create_multAdd2(meshStandardBuilder12) {
          var multAdd2 = meshStandardBuilder12.createNode("multAdd");
          multAdd2.setName("multAdd2");
          const multAdd2_nodes = {};
          multAdd2.uiData.setPosition(-600, -50);
          multAdd2.addParam(_polygonjs_polygonjs_src_engine_poly_ParamType__WEBPACK_IMPORTED_MODULE_0__/* .ParamType.FLOAT */ ._.FLOAT, "value", 0, { spare: true, editable: false });
          multAdd2.addParam(_polygonjs_polygonjs_src_engine_poly_ParamType__WEBPACK_IMPORTED_MODULE_0__/* .ParamType.FLOAT */ ._.FLOAT, "preAdd", 0, { spare: true, editable: true });
          multAdd2.addParam(_polygonjs_polygonjs_src_engine_poly_ParamType__WEBPACK_IMPORTED_MODULE_0__/* .ParamType.FLOAT */ ._.FLOAT, "mult", 1, { spare: true, editable: false });
          multAdd2.params.get("mult").set(4.49);
          multAdd2.addParam(_polygonjs_polygonjs_src_engine_poly_ParamType__WEBPACK_IMPORTED_MODULE_0__/* .ParamType.FLOAT */ ._.FLOAT, "postAdd", 0, { spare: true, editable: true });
          multAdd2.params.postCreateSpareParams();
          multAdd2.params.runOnSceneLoadHooks();
          return { node: multAdd2, children: multAdd2_nodes };
        }
        function create_output1(meshStandardBuilder12) {
          var output1 = meshStandardBuilder12.createNode("output");
          output1.setName("output1");
          const output1_nodes = {};
          output1.uiData.setPosition(450, 0);
          output1.params.postCreateSpareParams();
          output1.params.runOnSceneLoadHooks();
          return { node: output1, children: output1_nodes };
        }
        function create_random1(meshStandardBuilder12) {
          var random1 = meshStandardBuilder12.createNode("random");
          random1.setName("random1");
          const random1_nodes = {};
          random1.uiData.setPosition(-150, 500);
          random1.params.postCreateSpareParams();
          random1.params.runOnSceneLoadHooks();
          return { node: random1, children: random1_nodes };
        }
        function create_round1(meshStandardBuilder12) {
          var round1 = meshStandardBuilder12.createNode("round");
          round1.setName("round1");
          const round1_nodes = {};
          round1.uiData.setPosition(-450, 500);
          round1.addParam(_polygonjs_polygonjs_src_engine_poly_ParamType__WEBPACK_IMPORTED_MODULE_0__/* .ParamType.FLOAT */ ._.FLOAT, "in", 0, { spare: true, editable: false });
          round1.params.postCreateSpareParams();
          round1.params.runOnSceneLoadHooks();
          return { node: round1, children: round1_nodes };
        }
        function create_smoothstep1(meshStandardBuilder12) {
          var smoothstep1 = meshStandardBuilder12.createNode("smoothstep");
          smoothstep1.setName("smoothstep1");
          const smoothstep1_nodes = {};
          smoothstep1.uiData.setPosition(-400, -50);
          smoothstep1.addParam(_polygonjs_polygonjs_src_engine_poly_ParamType__WEBPACK_IMPORTED_MODULE_0__/* .ParamType.FLOAT */ ._.FLOAT, "edge0", 0, { spare: true, editable: true });
          smoothstep1.addParam(_polygonjs_polygonjs_src_engine_poly_ParamType__WEBPACK_IMPORTED_MODULE_0__/* .ParamType.FLOAT */ ._.FLOAT, "edge1", 1, { spare: true, editable: true });
          smoothstep1.addParam(_polygonjs_polygonjs_src_engine_poly_ParamType__WEBPACK_IMPORTED_MODULE_0__/* .ParamType.FLOAT */ ._.FLOAT, "x", 0, { spare: true, editable: false });
          smoothstep1.params.postCreateSpareParams();
          smoothstep1.params.runOnSceneLoadHooks();
          return { node: smoothstep1, children: smoothstep1_nodes };
        }
        function create_smoothstep2(meshStandardBuilder12) {
          var smoothstep2 = meshStandardBuilder12.createNode("smoothstep");
          smoothstep2.setName("smoothstep2");
          const smoothstep2_nodes = {};
          smoothstep2.uiData.setComment(
            "Here we also control the alpha, to ensure that the polygons where the tube is the thinnest are fully hidden.\n\nUnplug this node from the output node to see the difference.\n\nNote that changing the alpha here has an effect because we've also set the alphaTest on the [material](..) itself to a non-zero value like `0.01`"
          );
          smoothstep2.uiData.setPosition(-400, 50);
          smoothstep2.addParam(_polygonjs_polygonjs_src_engine_poly_ParamType__WEBPACK_IMPORTED_MODULE_0__/* .ParamType.FLOAT */ ._.FLOAT, "edge0", 0, { spare: true, editable: true });
          smoothstep2.params.get("edge0").set(1);
          smoothstep2.addParam(_polygonjs_polygonjs_src_engine_poly_ParamType__WEBPACK_IMPORTED_MODULE_0__/* .ParamType.FLOAT */ ._.FLOAT, "edge1", 1, { spare: true, editable: true });
          smoothstep2.params.get("edge1").set(0.94);
          smoothstep2.addParam(_polygonjs_polygonjs_src_engine_poly_ParamType__WEBPACK_IMPORTED_MODULE_0__/* .ParamType.FLOAT */ ._.FLOAT, "x", 0, { spare: true, editable: false });
          smoothstep2.params.postCreateSpareParams();
          smoothstep2.params.runOnSceneLoadHooks();
          return { node: smoothstep2, children: smoothstep2_nodes };
        }
        function create_subtract1(meshStandardBuilder12) {
          var subtract1 = meshStandardBuilder12.createNode("subtract");
          subtract1.setName("subtract1");
          const subtract1_nodes = {};
          subtract1.uiData.setPosition(-700, -50);
          subtract1.addParam(_polygonjs_polygonjs_src_engine_poly_ParamType__WEBPACK_IMPORTED_MODULE_0__/* .ParamType.FLOAT */ ._.FLOAT, "sub0", 0, { spare: true, editable: false });
          subtract1.addParam(_polygonjs_polygonjs_src_engine_poly_ParamType__WEBPACK_IMPORTED_MODULE_0__/* .ParamType.FLOAT */ ._.FLOAT, "sub1", 0, { spare: true, editable: false });
          subtract1.addParam(_polygonjs_polygonjs_src_engine_poly_ParamType__WEBPACK_IMPORTED_MODULE_0__/* .ParamType.FLOAT */ ._.FLOAT, "sub2", 0, { spare: true, editable: true });
          subtract1.params.postCreateSpareParams();
          subtract1.params.runOnSceneLoadHooks();
          return { node: subtract1, children: subtract1_nodes };
        }
        meshStandardBuilder1_nodes["abs1"] = create_abs1(meshStandardBuilder1);
        meshStandardBuilder1_nodes["attribute1"] = create_attribute1(meshStandardBuilder1);
        meshStandardBuilder1_nodes["attribute2"] = create_attribute2(meshStandardBuilder1);
        meshStandardBuilder1_nodes["attribute3"] = create_attribute3(meshStandardBuilder1);
        meshStandardBuilder1_nodes["constant_CURVE_LENGTH"] = create_constant_CURVE_LENGTH(meshStandardBuilder1);
        meshStandardBuilder1_nodes["constant_SPEED"] = create_constant_SPEED(meshStandardBuilder1);
        meshStandardBuilder1_nodes["constant_TIME_OFFSET"] = create_constant_TIME_OFFSET(meshStandardBuilder1);
        meshStandardBuilder1_nodes["divide1"] = create_divide1(meshStandardBuilder1);
        meshStandardBuilder1_nodes["floatToVec2_1"] = create_floatToVec2_1(meshStandardBuilder1);
        meshStandardBuilder1_nodes["floatToVec3_1"] = create_floatToVec3_1(meshStandardBuilder1);
        meshStandardBuilder1_nodes["globals1"] = create_globals1(meshStandardBuilder1);
        meshStandardBuilder1_nodes["hsvToRgb1"] = create_hsvToRgb1(meshStandardBuilder1);
        meshStandardBuilder1_nodes["mix1"] = create_mix1(meshStandardBuilder1);
        meshStandardBuilder1_nodes["multAdd1"] = create_multAdd1(meshStandardBuilder1);
        meshStandardBuilder1_nodes["multAdd2"] = create_multAdd2(meshStandardBuilder1);
        meshStandardBuilder1_nodes["output1"] = create_output1(meshStandardBuilder1);
        meshStandardBuilder1_nodes["random1"] = create_random1(meshStandardBuilder1);
        meshStandardBuilder1_nodes["round1"] = create_round1(meshStandardBuilder1);
        meshStandardBuilder1_nodes["smoothstep1"] = create_smoothstep1(meshStandardBuilder1);
        meshStandardBuilder1_nodes["smoothstep2"] = create_smoothstep2(meshStandardBuilder1);
        meshStandardBuilder1_nodes["subtract1"] = create_subtract1(meshStandardBuilder1);
        meshStandardBuilder1_nodes["abs1"].node.setInput(
          "in",
          meshStandardBuilder1_nodes["multAdd2"].node,
          "val"
        );
        meshStandardBuilder1_nodes["divide1"].node.setInput(
          "div1",
          meshStandardBuilder1_nodes["constant_CURVE_LENGTH"].node,
          "val"
        );
        meshStandardBuilder1_nodes["floatToVec2_1"].node.setInput(
          "x",
          meshStandardBuilder1_nodes["round1"].node,
          "val"
        );
        meshStandardBuilder1_nodes["floatToVec3_1"].node.setInput(
          "x",
          meshStandardBuilder1_nodes["random1"].node,
          "rand"
        );
        meshStandardBuilder1_nodes["hsvToRgb1"].node.setInput(
          "hsv",
          meshStandardBuilder1_nodes["floatToVec3_1"].node,
          "vec3"
        );
        meshStandardBuilder1_nodes["mix1"].node.setInput(
          "value0",
          meshStandardBuilder1_nodes["globals1"].node,
          "position"
        );
        meshStandardBuilder1_nodes["mix1"].node.setInput(
          "value1",
          meshStandardBuilder1_nodes["attribute2"].node,
          "val"
        );
        meshStandardBuilder1_nodes["mix1"].node.setInput(
          "blend",
          meshStandardBuilder1_nodes["smoothstep1"].node,
          "val"
        );
        meshStandardBuilder1_nodes["multAdd1"].node.setInput(
          "value",
          meshStandardBuilder1_nodes["globals1"].node,
          "time"
        );
        meshStandardBuilder1_nodes["multAdd1"].node.setInput(
          "mult",
          meshStandardBuilder1_nodes["constant_SPEED"].node,
          "val"
        );
        meshStandardBuilder1_nodes["multAdd1"].node.setInput(
          "postAdd",
          meshStandardBuilder1_nodes["constant_TIME_OFFSET"].node,
          "val"
        );
        meshStandardBuilder1_nodes["multAdd2"].node.setInput(
          "value",
          meshStandardBuilder1_nodes["subtract1"].node,
          "subtract"
        );
        meshStandardBuilder1_nodes["multAdd2"].node.setInput(
          "mult",
          meshStandardBuilder1_nodes["divide1"].node,
          "divide"
        );
        meshStandardBuilder1_nodes["output1"].node.setInput(
          "position",
          meshStandardBuilder1_nodes["mix1"].node,
          "mix"
        );
        meshStandardBuilder1_nodes["output1"].node.setInput(
          "color",
          meshStandardBuilder1_nodes["hsvToRgb1"].node,
          "rgb"
        );
        meshStandardBuilder1_nodes["output1"].node.setInput(
          "alpha",
          meshStandardBuilder1_nodes["smoothstep2"].node,
          "val"
        );
        meshStandardBuilder1_nodes["random1"].node.setInput(
          "seed",
          meshStandardBuilder1_nodes["floatToVec2_1"].node,
          "vec2"
        );
        meshStandardBuilder1_nodes["round1"].node.setInput(
          "in",
          meshStandardBuilder1_nodes["attribute1"].node,
          "val"
        );
        meshStandardBuilder1_nodes["smoothstep1"].node.setInput(
          "x",
          meshStandardBuilder1_nodes["abs1"].node,
          "val"
        );
        meshStandardBuilder1_nodes["smoothstep2"].node.setInput(
          "x",
          meshStandardBuilder1_nodes["abs1"].node,
          "val"
        );
        meshStandardBuilder1_nodes["subtract1"].node.setInput(
          "sub0",
          meshStandardBuilder1_nodes["attribute3"].node,
          "val"
        );
        meshStandardBuilder1_nodes["subtract1"].node.setInput(
          "sub1",
          meshStandardBuilder1_nodes["multAdd1"].node,
          "val"
        );
        if (meshStandardBuilder1.childrenController) {
          meshStandardBuilder1.childrenController.selection.set([]);
        }
        meshStandardBuilder1.uiData.setComment(
          "This is the material applied onto the geometry. [Dive into it](.) to see how it is built."
        );
        meshStandardBuilder1.uiData.setPosition(0, 100);
        meshStandardBuilder1.p.alphaTest.set(0.01);
        meshStandardBuilder1.params.postCreateSpareParams();
        meshStandardBuilder1.params.runOnSceneLoadHooks();
        return { node: meshStandardBuilder1, children: meshStandardBuilder1_nodes };
      }
      MAT_nodes["meshStandardBuilder1"] = create_meshStandardBuilder1(MAT);
      if (MAT.childrenController) {
        MAT.childrenController.selection.set([]);
      }
      MAT.uiData.setPosition(-450, 3650);
      MAT.params.postCreateSpareParams();
      MAT.params.runOnSceneLoadHooks();
      return { node: MAT, children: MAT_nodes };
    }
    function create_add1(curvesEffect2) {
      var add1 = curvesEffect2.createNode("add");
      add1.setName("add1");
      const add1_nodes = {};
      add1.uiData.setPosition(-250, -1150);
      add1.params.postCreateSpareParams();
      add1.params.runOnSceneLoadHooks();
      return { node: add1, children: add1_nodes };
    }
    function create_attribCopy1(curvesEffect2) {
      var attribCopy1 = curvesEffect2.createNode("attribCopy");
      attribCopy1.setName("attribCopy1");
      const attribCopy1_nodes = {};
      attribCopy1.uiData.setComment(
        "With those nodes above, we first use the [polywire](../polywire1) to convert the curve into a tube. Then we use the [fuse](../fuse1) to merge points and ensure the normals look correct.\n\nWe then use the [ray](../ray1) node to move the tube points  **back onto the curve**. And we use save those point positions as a `restP` attribute. This attribute will then be used inside the [material](../MAT/meshStandardBuilder1)."
      );
      attribCopy1.uiData.setPosition(-100, 1900);
      attribCopy1.setAttribClass(_polygonjs_polygonjs_src_core_geometry_Constant__WEBPACK_IMPORTED_MODULE_1__/* .AttribClass.POINT */ .io.POINT);
      attribCopy1.p.name.set("P");
      attribCopy1.p.tnewName.set(true);
      attribCopy1.p.newName.set("restP");
      attribCopy1.params.postCreateSpareParams();
      attribCopy1.params.runOnSceneLoadHooks();
      return { node: attribCopy1, children: attribCopy1_nodes };
    }
    function create_attribCreate1(curvesEffect2) {
      var attribCreate1 = curvesEffect2.createNode("attribCreate");
      attribCreate1.setName("attribCreate1");
      const attribCreate1_nodes = {};
      attribCreate1.uiData.setPosition(50, -50);
      attribCreate1.p.name.set("amp");
      attribCreate1.p.value1.set("@ptnum / (pointsCount(0)-1)");
      attribCreate1.params.postCreateSpareParams();
      attribCreate1.params.runOnSceneLoadHooks();
      return { node: attribCreate1, children: attribCreate1_nodes };
    }
    function create_attribId1(curvesEffect2) {
      var attribId1 = curvesEffect2.createNode("attribId");
      attribId1.setName("attribId1");
      const attribId1_nodes = {};
      attribId1.uiData.setPosition(-100, 2800);
      attribId1.setAttribClass(_polygonjs_polygonjs_src_core_geometry_Constant__WEBPACK_IMPORTED_MODULE_1__/* .AttribClass.OBJECT */ .io.OBJECT);
      attribId1.p.idn.set(false);
      attribId1.params.postCreateSpareParams();
      attribId1.params.runOnSceneLoadHooks();
      return { node: attribId1, children: attribId1_nodes };
    }
    function create_attribId2(curvesEffect2) {
      var attribId2 = curvesEffect2.createNode("attribId");
      attribId2.setName("attribId2");
      const attribId2_nodes = {};
      attribId2.uiData.setComment(
        "here we add an `idn` attribute on the curve, that goes from `0` to `1`, which is used in the [material](../MAT/meshStandardBuilder1)"
      );
      attribId2.uiData.setPosition(50, 900);
      attribId2.p.id.set(false);
      attribId2.params.postCreateSpareParams();
      attribId2.params.runOnSceneLoadHooks();
      return { node: attribId2, children: attribId2_nodes };
    }
    function create_attribPromote1(curvesEffect2) {
      var attribPromote1 = curvesEffect2.createNode("attribPromote");
      attribPromote1.setName("attribPromote1");
      const attribPromote1_nodes = {};
      attribPromote1.uiData.setComment(
        "The 2 nodes above create an `id` parameter, which is used in the [material](../MAT/meshStandardBuilder1). First the `id` is created on the objects, and starts a `0`, incrementing by `1` for each object. With 4 curves, with therefore have `0`, `1`, `2` and `3`.\n\nThe attribPromote node then *promotes* this object attribute onto the points, so that the material can access it."
      );
      attribPromote1.uiData.setPosition(-100, 2950);
      attribPromote1.setAttribClassFrom(_polygonjs_polygonjs_src_core_geometry_Constant__WEBPACK_IMPORTED_MODULE_1__/* .AttribClass.OBJECT */ .io.OBJECT);
      attribPromote1.setAttribClassTo(_polygonjs_polygonjs_src_core_geometry_Constant__WEBPACK_IMPORTED_MODULE_1__/* .AttribClass.POINT */ .io.POINT);
      attribPromote1.p.name.set("id");
      attribPromote1.params.postCreateSpareParams();
      attribPromote1.params.runOnSceneLoadHooks();
      return { node: attribPromote1, children: attribPromote1_nodes };
    }
    function create_attribRemap1(curvesEffect2) {
      var attribRemap1 = curvesEffect2.createNode("attribRemap");
      attribRemap1.setName("attribRemap1");
      const attribRemap1_nodes = {};
      attribRemap1.uiData.setPosition(50, 150);
      attribRemap1.p.name.set("amp");
      attribRemap1.p.ramp.set({
        interpolation: _polygonjs_polygonjs_src_engine_params_ramp_RampValue__WEBPACK_IMPORTED_MODULE_2__/* .RampInterpolation.CUBIC */ .Wp.CUBIC,
        points: [
          { position: 0, value: 0 },
          { position: 0.060181368507831824, value: 0.15117187499999996 },
          { position: 0.1447253486109546, value: 0.7074218749999999 },
          { position: 0.8134194474345174, value: 0.719921875 },
          { position: 0.9351470184116516, value: 0.10742187500000011 },
          { position: 1, value: 0 }
        ]
      });
      attribRemap1.params.postCreateSpareParams();
      attribRemap1.params.runOnSceneLoadHooks();
      return { node: attribRemap1, children: attribRemap1_nodes };
    }
    function create_blend1(curvesEffect2) {
      var blend1 = curvesEffect2.createNode("blend");
      blend1.setName("blend1");
      const blend1_nodes = {};
      blend1.uiData.setComment(
        "This blend node is not necessary for this setup to work, but can still be used as a good debugging tool. You can for instance see the difference between the output of the [polywire](../polywire1) and of the [ray](../ray1) node.\n\nChange the `blend` param value to switch from one shape to the other."
      );
      blend1.uiData.setPosition(-500, 1900);
      blend1.p.blend.set(0.21);
      blend1.params.postCreateSpareParams();
      blend1.params.runOnSceneLoadHooks();
      return { node: blend1, children: blend1_nodes };
    }
    function create_copy1(curvesEffect2) {
      var copy1 = curvesEffect2.createNode("copy");
      copy1.setName("copy1");
      const copy1_nodes = {};
      copy1.uiData.setComment(
        "The copy node duplicates its input, and it therefore creates multiple curves.\n\nAnd in order to not have those curves identical, we have the `copy` expression in the [noise](../noise1) node, affecting the `offset` parameter."
      );
      copy1.uiData.setPosition(-100, 2400);
      copy1.p.count.set(4);
      copy1.params.postCreateSpareParams();
      copy1.params.runOnSceneLoadHooks();
      return { node: copy1, children: copy1_nodes };
    }
    function create_curveFromPoints1(curvesEffect2) {
      var curveFromPoints1 = curvesEffect2.createNode("curveFromPoints");
      curveFromPoints1.setName("curveFromPoints1");
      const curveFromPoints1_nodes = {};
      curveFromPoints1.uiData.setComment(
        "This node and the ones above create the curve. In this case, the points are manually placed, but the curve could also be created with a [sop/line](https://polygonjs.com/docs/nodes/sop/line) or [sop/circle](https://polygonjs.com/docs/nodes/sop/circle)"
      );
      curveFromPoints1.uiData.setPosition(50, -350);
      curveFromPoints1.params.postCreateSpareParams();
      curveFromPoints1.params.runOnSceneLoadHooks();
      return { node: curveFromPoints1, children: curveFromPoints1_nodes };
    }
    function create_fuse1(curvesEffect2) {
      var fuse1 = curvesEffect2.createNode("fuse");
      fuse1.setName("fuse1");
      const fuse1_nodes = {};
      fuse1.uiData.setPosition(-100, 1550);
      fuse1.p.dist.set(0.01);
      fuse1.params.postCreateSpareParams();
      fuse1.params.runOnSceneLoadHooks();
      return { node: fuse1, children: fuse1_nodes };
    }
    function create_material1(curvesEffect2) {
      var material1 = curvesEffect2.createNode("material");
      material1.setName("material1");
      const material1_nodes = {};
      material1.uiData.setComment("Here we assign the [material](../MAT/meshStandardBuilder1)");
      material1.uiData.setPosition(-100, 3650);
      material1.flags.display.set(true);
      material1.p.material.set("../MAT/meshStandardBuilder1");
      material1.params.postCreateSpareParams();
      material1.params.runOnSceneLoadHooks();
      return { node: material1, children: material1_nodes };
    }
    function create_merge1(curvesEffect2) {
      var merge1 = curvesEffect2.createNode("merge");
      merge1.setName("merge1");
      const merge1_nodes = {};
      merge1.uiData.setPosition(50, -500);
      merge1.p.compact.set(true);
      merge1.p.inputsCount.set(6);
      merge1.io.inputs.setCount(1, 6);
      merge1.params.postCreateSpareParams();
      merge1.params.runOnSceneLoadHooks();
      return { node: merge1, children: merge1_nodes };
    }
    function create_merge2(curvesEffect2) {
      var merge2 = curvesEffect2.createNode("merge");
      merge2.setName("merge2");
      const merge2_nodes = {};
      merge2.uiData.setComment(
        "This merges the input objects into a single one, as it's more performant. Note that we should only merge them once the `id` attribute has been promoted from the object to the geometry.\n\nAnd the performance difference would not be noticeable if you only have a handful of curves, but it's still a good habit."
      );
      merge2.uiData.setPosition(-100, 3300);
      merge2.p.compact.set(true);
      merge2.params.postCreateSpareParams();
      merge2.params.runOnSceneLoadHooks();
      return { node: merge2, children: merge2_nodes };
    }
    function create_noise1(curvesEffect2) {
      var noise1 = curvesEffect2.createNode("noise");
      noise1.setName("noise1");
      const noise1_nodes = {};
      noise1.uiData.setComment(
        "The 3 nodes above add noise to the curve.\n\nThere are several settings worth mentioning:\n\n- the frequency is set to a very low value\n\n- the noise amplitude is defined by the `amp` attribute on the points. That value is first set using the expression `@ptnum / (pointsCount(0)-1)` (which can be added using the presets on the [attribCreate1](../attribCreate1) node). This sets the amplitude going from 0 to 1.\n\n- The `amp` attribute is then remapped, so that it is 0 on both ends of the curve, but increases in the middle.\n\n- the `offset` param is using the `copy` expression (see [its documentation](https://polygonjs.com/docs/expressions/copy)), so that we can have multiple curves with different noises. "
      );
      noise1.uiData.setPosition(50, 250);
      noise1.p.tamplitudeAttrib.set(true);
      noise1.p.freq.set([0.040000000000000036, 0.040000000000000036, 0.040000000000000036]);
      noise1.p.offset.set([0, "123.34*copy('../copy1')", "129.14*copy('../copy1')"]);
      noise1.params.postCreateSpareParams();
      noise1.params.runOnSceneLoadHooks();
      return { node: noise1, children: noise1_nodes };
    }
    function create_null1(curvesEffect2) {
      var null1 = curvesEffect2.createNode("null");
      null1.setName("null1");
      const null1_nodes = {};
      null1.uiData.setPosition(50, 1250);
      null1.params.postCreateSpareParams();
      null1.params.runOnSceneLoadHooks();
      return { node: null1, children: null1_nodes };
    }
    function create_polywire1(curvesEffect2) {
      var polywire1 = curvesEffect2.createNode("polywire");
      polywire1.setName("polywire1");
      const polywire1_nodes = {};
      polywire1.uiData.setPosition(-100, 1400);
      polywire1.p.radius.set(0.09);
      polywire1.p.closed.set(false);
      polywire1.params.postCreateSpareParams();
      polywire1.params.runOnSceneLoadHooks();
      return { node: polywire1, children: polywire1_nodes };
    }
    function create_ray1(curvesEffect2) {
      var ray1 = curvesEffect2.createNode("ray");
      ray1.setName("ray1");
      const ray1_nodes = {};
      ray1.uiData.setPosition(50, 1700);
      ray1.p.mode.set(1);
      ray1.params.postCreateSpareParams();
      ray1.params.runOnSceneLoadHooks();
      return { node: ray1, children: ray1_nodes };
    }
    function create_transform1(curvesEffect2) {
      var transform1 = curvesEffect2.createNode("transform");
      transform1.setName("transform1");
      const transform1_nodes = {};
      transform1.uiData.setPosition(-250, -850);
      transform1.p.t.set([0, 0, 0.4280319101336397]);
      transform1.params.postCreateSpareParams();
      transform1.params.runOnSceneLoadHooks();
      return { node: transform1, children: transform1_nodes };
    }
    function create_transform2(curvesEffect2) {
      var transform2 = curvesEffect2.createNode("transform");
      transform2.setName("transform2");
      const transform2_nodes = {};
      transform2.uiData.setPosition(0, -850);
      transform2.p.t.set([-0.19472299708086527, 0.6423024806984343, 0]);
      transform2.params.postCreateSpareParams();
      transform2.params.runOnSceneLoadHooks();
      return { node: transform2, children: transform2_nodes };
    }
    function create_transform3(curvesEffect2) {
      var transform3 = curvesEffect2.createNode("transform");
      transform3.setName("transform3");
      const transform3_nodes = {};
      transform3.uiData.setPosition(450, -850);
      transform3.p.t.set([1.0566176796990638, 1.5511287721218017, 0.8041779203042947]);
      transform3.params.postCreateSpareParams();
      transform3.params.runOnSceneLoadHooks();
      return { node: transform3, children: transform3_nodes };
    }
    function create_transform4(curvesEffect2) {
      var transform4 = curvesEffect2.createNode("transform");
      transform4.setName("transform4");
      const transform4_nodes = {};
      transform4.uiData.setPosition(700, -850);
      transform4.p.t.set([-0.2925796796525524, 1.9977855233667556, 0.6158186906297098]);
      transform4.params.postCreateSpareParams();
      transform4.params.runOnSceneLoadHooks();
      return { node: transform4, children: transform4_nodes };
    }
    function create_transform5(curvesEffect2) {
      var transform5 = curvesEffect2.createNode("transform");
      transform5.setName("transform5");
      const transform5_nodes = {};
      transform5.uiData.setPosition(200, -850);
      transform5.p.t.set([0.6928346806469119, 1.1006481886541106, -0.33298850175673345]);
      transform5.params.postCreateSpareParams();
      transform5.params.runOnSceneLoadHooks();
      return { node: transform5, children: transform5_nodes };
    }
    function create_transform6(curvesEffect2) {
      var transform6 = curvesEffect2.createNode("transform");
      transform6.setName("transform6");
      const transform6_nodes = {};
      transform6.uiData.setPosition(900, -850);
      transform6.p.t.set([-0.2925796796525524, 2.201853515512034, -0.297023729249823]);
      transform6.params.postCreateSpareParams();
      transform6.params.runOnSceneLoadHooks();
      return { node: transform6, children: transform6_nodes };
    }
    curvesEffect_nodes["MAT"] = create_MAT(curvesEffect);
    curvesEffect_nodes["add1"] = create_add1(curvesEffect);
    curvesEffect_nodes["attribCopy1"] = create_attribCopy1(curvesEffect);
    curvesEffect_nodes["attribCreate1"] = create_attribCreate1(curvesEffect);
    curvesEffect_nodes["attribId1"] = create_attribId1(curvesEffect);
    curvesEffect_nodes["attribId2"] = create_attribId2(curvesEffect);
    curvesEffect_nodes["attribPromote1"] = create_attribPromote1(curvesEffect);
    curvesEffect_nodes["attribRemap1"] = create_attribRemap1(curvesEffect);
    curvesEffect_nodes["blend1"] = create_blend1(curvesEffect);
    curvesEffect_nodes["copy1"] = create_copy1(curvesEffect);
    curvesEffect_nodes["curveFromPoints1"] = create_curveFromPoints1(curvesEffect);
    curvesEffect_nodes["fuse1"] = create_fuse1(curvesEffect);
    curvesEffect_nodes["material1"] = create_material1(curvesEffect);
    curvesEffect_nodes["merge1"] = create_merge1(curvesEffect);
    curvesEffect_nodes["merge2"] = create_merge2(curvesEffect);
    curvesEffect_nodes["noise1"] = create_noise1(curvesEffect);
    curvesEffect_nodes["null1"] = create_null1(curvesEffect);
    curvesEffect_nodes["polywire1"] = create_polywire1(curvesEffect);
    curvesEffect_nodes["ray1"] = create_ray1(curvesEffect);
    curvesEffect_nodes["transform1"] = create_transform1(curvesEffect);
    curvesEffect_nodes["transform2"] = create_transform2(curvesEffect);
    curvesEffect_nodes["transform3"] = create_transform3(curvesEffect);
    curvesEffect_nodes["transform4"] = create_transform4(curvesEffect);
    curvesEffect_nodes["transform5"] = create_transform5(curvesEffect);
    curvesEffect_nodes["transform6"] = create_transform6(curvesEffect);
    curvesEffect_nodes["attribCopy1"].node.setInput(0, curvesEffect_nodes["fuse1"].node);
    curvesEffect_nodes["attribCopy1"].node.setInput(1, curvesEffect_nodes["ray1"].node);
    curvesEffect_nodes["attribCreate1"].node.setInput(0, curvesEffect_nodes["curveFromPoints1"].node);
    curvesEffect_nodes["attribId1"].node.setInput(0, curvesEffect_nodes["copy1"].node);
    curvesEffect_nodes["attribId2"].node.setInput(0, curvesEffect_nodes["noise1"].node);
    curvesEffect_nodes["attribPromote1"].node.setInput(0, curvesEffect_nodes["attribId1"].node);
    curvesEffect_nodes["attribRemap1"].node.setInput(0, curvesEffect_nodes["attribCreate1"].node);
    curvesEffect_nodes["blend1"].node.setInput(0, curvesEffect_nodes["fuse1"].node);
    curvesEffect_nodes["blend1"].node.setInput(1, curvesEffect_nodes["ray1"].node);
    curvesEffect_nodes["copy1"].node.setInput(0, curvesEffect_nodes["attribCopy1"].node);
    curvesEffect_nodes["curveFromPoints1"].node.setInput(0, curvesEffect_nodes["merge1"].node);
    curvesEffect_nodes["fuse1"].node.setInput(0, curvesEffect_nodes["polywire1"].node);
    curvesEffect_nodes["material1"].node.setInput(0, curvesEffect_nodes["merge2"].node);
    curvesEffect_nodes["merge1"].node.setInput(0, curvesEffect_nodes["transform1"].node);
    curvesEffect_nodes["merge1"].node.setInput(1, curvesEffect_nodes["transform2"].node);
    curvesEffect_nodes["merge1"].node.setInput(2, curvesEffect_nodes["transform5"].node);
    curvesEffect_nodes["merge1"].node.setInput(3, curvesEffect_nodes["transform3"].node);
    curvesEffect_nodes["merge1"].node.setInput(4, curvesEffect_nodes["transform4"].node);
    curvesEffect_nodes["merge1"].node.setInput(5, curvesEffect_nodes["transform6"].node);
    curvesEffect_nodes["merge2"].node.setInput(0, curvesEffect_nodes["attribPromote1"].node);
    curvesEffect_nodes["noise1"].node.setInput(0, curvesEffect_nodes["attribRemap1"].node);
    curvesEffect_nodes["null1"].node.setInput(0, curvesEffect_nodes["attribId2"].node);
    curvesEffect_nodes["polywire1"].node.setInput(0, curvesEffect_nodes["null1"].node);
    curvesEffect_nodes["ray1"].node.setInput(0, curvesEffect_nodes["fuse1"].node);
    curvesEffect_nodes["ray1"].node.setInput(1, curvesEffect_nodes["null1"].node);
    curvesEffect_nodes["transform1"].node.setInput(0, curvesEffect_nodes["add1"].node);
    curvesEffect_nodes["transform2"].node.setInput(0, curvesEffect_nodes["add1"].node);
    curvesEffect_nodes["transform3"].node.setInput(0, curvesEffect_nodes["add1"].node);
    curvesEffect_nodes["transform4"].node.setInput(0, curvesEffect_nodes["add1"].node);
    curvesEffect_nodes["transform5"].node.setInput(0, curvesEffect_nodes["add1"].node);
    curvesEffect_nodes["transform6"].node.setInput(0, curvesEffect_nodes["add1"].node);
    if (curvesEffect.childrenController) {
      curvesEffect.childrenController.selection.set([]);
    }
    curvesEffect.uiData.setPosition(-50, -150);
    curvesEffect.flags.display.set(true);
    curvesEffect.params.postCreateSpareParams();
    curvesEffect.params.runOnSceneLoadHooks();
    return { node: curvesEffect, children: curvesEffect_nodes };
  }
  scene_root_nodes["grid"] = create_grid(root);
  scene_root_nodes["hemisphereLight1"] = create_hemisphereLight1(root);
  scene_root_nodes["perspectiveCamera1"] = create_perspectiveCamera1(root);
  scene_root_nodes["COP"] = create_COP(root);
  scene_root_nodes["curvesEffect"] = create_curvesEffect(root);
  scene.setFrame(0);
  scene.play();
  return {
    scene,
    cameraPath: scene_root_nodes["perspectiveCamera1"].node.path(),
    focusedNodes: scene_root_nodes["curvesEffect"].node.children(),
    // no node is focused here, so that we don't have the transform gizmo appearing
    autoLayout: false
  };
}


/***/ })

}])
//# sourceMappingURL=src_engine_examples_examples_advanced_TubesFlowingOnCurves_ts.2b0d9fc9aedd6a33e182.js.map