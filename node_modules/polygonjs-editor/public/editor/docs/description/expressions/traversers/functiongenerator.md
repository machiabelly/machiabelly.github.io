The following expressions are available to use in most parameters:

## Variables

- `$F`: current frame
- `$T`: current time
- `$OS`: current node name
- `$CH`: current param name
- `$CEX`: input centroid x component
- `$CEY`: input centroid y component
- `$CEZ`: input centroid z component

Those variables are aliases to the javascript math module:

- `$E`
- `$LN2`
- `$LN10`
- `$LOG10E`
- `$LOG2E`
- `$PI`
- `$SQRT1_2`
- `$SQRT2`

In some parameters which can evaluate per entity (which means per point or per object),
it is also possible to use variables to access attributes:

- `@ptnum` will evaluate to the current point index
- `@vtxnum` will evaluate to the current vertex index
- `@primnum` will evaluate to the current primitive index
- `@objnum` will evaluate to the current object index
- And you can also refer to any existing attribute, **using @ following by the attribute name**.

For instance:

- `@P.x` evaluates to the **x** component of the position.
- `@P.y` evaluates to the **y** component of the position.
- `@P.z` evaluates to the **z** component of the position.
- `@N.x` evaluates to the **x** component of the normal.
- `@N.y` evaluates to the **y** component of the normal.
- `@N.z` evaluates to the **z** component of the normal.
- `@Cd.x` evaluates to the **x** component of the color.
- `@Cd.y` evaluates to the **y** component of the color.
- `@Cd.z` evaluates to the **z** component of the color.
- `@uv.x` evaluates to the **x** component of the uv.
- `@uv.y` evaluates to the **y** component of the uv.

Using the attribCreate, point or normal SOPs, you can mix and match them.
For instance, if in the point SOP, you set to the x component `@uv.x` and y component `@uv.y`
then the points will be transformed to look like in UV space.

Another common setup is to use an attribute create to add an attribute `id`, with `@ptnum`.
This way, every point will have a unique id.
You can then use this id in the following nodes, or even in a material.

Instead of having an attribute id that goes from 0 to the number of points in your geometry,
you can also create one that goes from 0 to 1, using `@ptnum / (pointsCount(0)-1)`


## Math expressions

The following are native javascript functions:

- abs
- acos
- acosh
- asin
- asinh
- atan
- atan2
- atanh
- ceil
- cos
- cosh
- exp
- expm1
- floor
- log
- log1p
- log2
- log10
- max
- min
- pow
- random (which aliases to Math.rand())
- round
- sign
- sin
- sinh
- sqrt
- tan
- tanh

If you are targetting ES6 (available in modern browsers), you can also have:

- cbrt
- hypot
- log10
- trunc

The following are aliases from the [Polygonjs CoreMath](https://github.com/polygonjs/polygonjs-engine/blob/master/src/core/math/_Module.ts) module:

- clamp
- degToRad
- fit
- fit01
- fitClamp
- fract
- mix
- radToDeg
- rand

And the following are alias to the [Polygonjs Easing](https://github.com/polygonjs/polygonjs-engine/blob/master/src/core/math/Easing.ts) module:

- `easeI2( number )`, is a shortcut for `ease_i( number, 2 )`
- `easeO2( number )`, is a shortcut for `ease_o( number, 2 )`
- `easeIO2( number )`, is a shortcut for `ease_io( number, 2 )`
- `easeI3( number )`, is a shortcut for `ease_i( number, 3 )`
- `easeO3( number )`, is a shortcut for `ease_o( number, 3 )`
- `easeIO3( number )`, is a shortcut for `ease_io( number, 3 )`
- `easeI4( number )`, is a shortcut for `ease_i( number, 4 )`
- `easeO4( number )`, is a shortcut for `ease_o( number, 4 )`
- `easeIO4( number )`, is a shortcut for `ease_io( number, 4 )`
- `easeSinI( number )`
- `easeSinO( number )`
- `easeSinIO( number )`
- `easeElasticI( number )`
- `easeElasticO( number )`
- `easeElasticIO( number )`


## String expressions:

- precision (alias to the [CoreString](https://github.com/polygonjs/polygonjs-engine/blob/master/src/core/String.ts) module precision method)
- [strCharsCount](/docs/expressions/strCharsCount)
- [strConcat](/docs/expressions/strConcat)
- [strIndex](/docs/expressions/strIndex)
- [strSub](/docs/expressions/strSub)

