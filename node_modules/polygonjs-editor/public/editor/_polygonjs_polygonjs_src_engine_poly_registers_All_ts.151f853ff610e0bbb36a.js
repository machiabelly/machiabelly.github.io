(self["webpackChunk"] = self["webpackChunk"] || []).push([["_polygonjs_polygonjs_src_engine_poly_registers_All_ts"],{

/***/ 31369:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {


// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  "$": function() { return /* binding */ Channel; }
});

// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/core/keyframes/KeyframeCommon.ts
var KeyframeCommon = __webpack_require__(21555);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/node_modules/three/build/three.module.js
var three_module = __webpack_require__(21410);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/core/keyframes/KeyframeTangent.ts
var KeyframeTangent = __webpack_require__(4726);
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/core/keyframes/channel/Cubic.ts



const _v2 = new three_module.Vector2();
const _endPt0 = new three_module.Vector2();
const _endPt1 = new three_module.Vector2();
const curve = new three_module.CubicBezierCurve(new three_module.Vector2(), new three_module.Vector2(), new three_module.Vector2(), new three_module.Vector2());
const setCurveFromKeyframePairCubic = (keyframeStart, keyframeEnd) => {
  (0,KeyframeTangent/* keyframeTangentToEndPoint */.Y2)(keyframeStart, false, _endPt0);
  (0,KeyframeTangent/* keyframeTangentToEndPoint */.Y2)(keyframeEnd, true, _endPt1);
  curve.v0.x = keyframeStart.pos;
  curve.v0.y = keyframeStart.value;
  curve.v1.x = keyframeStart.pos + _endPt0.x;
  curve.v1.y = keyframeStart.value + _endPt0.y;
  curve.v3.x = keyframeEnd.pos;
  curve.v3.y = keyframeEnd.value;
  curve.v2.x = keyframeEnd.pos - _endPt1.x;
  curve.v2.y = keyframeEnd.value - _endPt1.y;
};
function getX(t, curve2) {
  curve2.getPoint(t, _v2);
  return _v2.x;
}
const MAX_ITERATIONS = 500;
const EPSILON = 1e-6;
const range = { min: 0, max: 1 };
function findTForXCubic(expectedX) {
  const curveStartPos = curve.v0.x;
  const curveEndPos = curve.v3.x;
  range.min = curveStartPos;
  range.max = curveEndPos;
  function _normalizePos(_pos) {
    return (_pos - curveStartPos) / (curveEndPos - curveStartPos);
  }
  let currentX = expectedX;
  for (let iteration = 0; iteration < MAX_ITERATIONS; iteration++) {
    const foundX = getX(_normalizePos(currentX), curve);
    const delta = foundX - expectedX;
    if (Math.abs(delta) < EPSILON) {
      return _normalizePos(currentX);
    }
    if (foundX < expectedX) {
      range.min = currentX;
      currentX = (range.max + currentX) / 2;
    } else {
      range.max = currentX;
      currentX = (range.min + currentX) / 2;
    }
  }
  return _normalizePos(currentX);
}
function getValueCubic(pos) {
  const t = findTForXCubic(pos);
  curve.getPoint(t, _v2);
  return _v2.y;
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/core/keyframes/channel/Linear.ts


const Linear_curve = new three_module.LineCurve(new three_module.Vector2(), new three_module.Vector2());
const setCurveFromKeyframePairLinear = (keyframeStart, keyframeEnd) => {
  Linear_curve.v1.x = keyframeStart.pos;
  Linear_curve.v1.y = keyframeStart.value;
  Linear_curve.v2.x = keyframeEnd.pos;
  Linear_curve.v2.y = keyframeEnd.value;
};
function getValueLinear(pos) {
  const curveStartPos = Linear_curve.v1.x;
  const curveEndPos = Linear_curve.v2.x;
  const t = (pos - curveStartPos) / (curveEndPos - curveStartPos);
  const value = t * Linear_curve.v2.y + (1 - t) * Linear_curve.v1.y;
  return value;
}

// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/core/math/_Module.ts
var _Module = __webpack_require__(27462);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/core/MapUtils.ts
var MapUtils = __webpack_require__(94158);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/core/keyframes/KeyframeSerialize.ts
var KeyframeSerialize = __webpack_require__(33382);
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/core/keyframes/Channel.ts







class Channel {
  constructor(data) {
    this.data = data;
    this._valuesByPos = /* @__PURE__ */ new Map();
    this._setCurveCallback = setCurveFromKeyframePairLinear;
    this._getValueCallback = getValueLinear;
    Channel.validate(this.data);
    this.compute();
  }
  static fromJSON(data) {
    return new Channel(data);
  }
  value(t) {
    if (t == Math.floor(t)) {
      const value = this._valuesByPos.get(t);
      if (value != null) {
        return value;
      }
      const keyframes = this.data.keyframes;
      if (keyframes.length == 0) {
        return 0;
      }
      const firstPos = keyframes[0].pos;
      const lastPos = keyframes[keyframes.length - 1].pos;
      if (t < firstPos) {
        return this._valuesByPos.get(firstPos) || 0;
      }
      if (t > lastPos) {
        return this._valuesByPos.get(lastPos) || 0;
      }
    }
    const t0 = Math.floor(t);
    const t1 = Math.ceil(t);
    const v0 = this._valuesByPos.get(t0) || 0;
    const v1 = this._valuesByPos.get(t1) || 0;
    return (0,_Module/* mix */.CD)(v0, v1, t - t0);
  }
  static validate(data) {
    let keyframes = data.keyframes;
    const keyframesByPos = /* @__PURE__ */ new Map();
    for (const keyframe of keyframes) {
      MapUtils/* MapUtils.pushOnArrayAtEntry */.pl.pushOnArrayAtEntry(keyframesByPos, keyframe.pos, keyframe);
    }
    if (keyframes.length != keyframesByPos.size) {
      const expectedSize = keyframesByPos.size;
      const keptKeyframes = new Array(expectedSize);
      let i2 = 0;
      keyframesByPos.forEach((keyframes2, pos) => {
        keptKeyframes[i2] = keyframes2[0];
        i2++;
      });
      keyframes = keptKeyframes;
      data.keyframes.splice(expectedSize, data.keyframes.length - expectedSize);
    }
    const sortedKeyframes = keyframes.sort((k1, k2) => k1.pos - k2.pos).map((k) => {
      const target = (0,KeyframeSerialize/* createKeyframeData */.f7)();
      (0,KeyframeSerialize/* copyKeyframeData */.ik)(k, target);
      return target;
    });
    let i = 0;
    for (const keyframe of sortedKeyframes) {
      (0,KeyframeSerialize/* copyKeyframeData */.ik)(keyframe, data.keyframes[i]);
      i++;
    }
  }
  _setCallbacks() {
    switch (this.data.interpolation) {
      case KeyframeCommon/* ChannelInterpolation.CUBIC */.M.CUBIC: {
        this._setCurveCallback = setCurveFromKeyframePairCubic;
        this._getValueCallback = getValueCubic;
        return;
      }
      case KeyframeCommon/* ChannelInterpolation.LINEAR */.M.LINEAR: {
        this._setCurveCallback = setCurveFromKeyframePairLinear;
        this._getValueCallback = getValueLinear;
        return;
      }
    }
  }
  compute() {
    Channel.validate(this.data);
    const keyframes = this.data.keyframes;
    if (keyframes.length == 0) {
      return;
    }
    this._setCallbacks();
    const firstPos = keyframes[0].pos;
    const lastPos = keyframes[keyframes.length - 1].pos;
    this._valuesByPos.clear();
    if (keyframes.length == 0) {
      return;
    }
    if (keyframes.length == 1) {
      this._valuesByPos.set(keyframes[0].pos, keyframes[0].value);
      return;
    }
    let segmentIndex = 0;
    const keyframePair = { start: keyframes[0], end: keyframes[1] };
    this._setCurveCallback(keyframePair.start, keyframePair.end);
    for (let pos = firstPos; pos <= lastPos; pos++) {
      if (pos > keyframePair.end.pos) {
        segmentIndex++;
        keyframePair.start = keyframePair.end;
        keyframePair.end = keyframes[segmentIndex + 1];
        this._setCurveCallback(keyframePair.start, keyframePair.end);
      }
      const value = this._getValueCallback(pos);
      this._valuesByPos.set(pos, value);
    }
  }
  // private _computeValue(pos: number, curve: CubicBezierCurve): number {
  // 	const t = this._findTForXCallback(pos, curve);
  // 	curve.getPoint(t, _v2);
  // 	console.log(pos, t, _v2.x, _v2.y);
  // 	return _v2.y;
  // }
}


/***/ }),

/***/ 17009:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "M": function() { return /* binding */ CSS2DRenderer; }
/* harmony export */ });
/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(21410);


const _vector = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();
const _viewMatrix = new three__WEBPACK_IMPORTED_MODULE_0__.Matrix4();
const _viewProjectionMatrix = new three__WEBPACK_IMPORTED_MODULE_0__.Matrix4();
const _a = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();
const _b = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();
class CSS2DRenderer {
  constructor(parameters = {}) {
    this._width = 0;
    this._height = 0;
    this._widthHalf = 0;
    this._heightHalf = 0;
    this.dataByObject = /* @__PURE__ */ new WeakMap();
    this.appendedObjects = /* @__PURE__ */ new Set();
    this.objectsToRender = /* @__PURE__ */ new Set();
    this.objectsToRemove = /* @__PURE__ */ new Set();
    const domElement = parameters.element !== void 0 ? parameters.element : document.createElement("div");
    domElement.style.overflow = "hidden";
    this.domElement = domElement;
  }
  getSize() {
    return {
      width: this._width,
      height: this._height
    };
  }
  render(scene, camera) {
    _viewMatrix.copy(camera.matrixWorldInverse);
    _viewProjectionMatrix.multiplyMatrices(camera.projectionMatrix, _viewMatrix);
    this.removeElementsDeletedFromSceneGraph(scene);
    this.renderObject(scene, scene, camera);
    this.zOrder(scene);
  }
  removeElementsDeletedFromSceneGraph(scene) {
    this.objectsToRender.clear();
    scene.traverse((object) => {
      if (object.isCSS2DObject) {
        this.objectsToRender.add(object);
      }
    });
    this.objectsToRemove.clear();
    this.appendedObjects.forEach((appendedObject) => {
      if (!this.objectsToRender.has(appendedObject)) {
        this.objectsToRemove.add(appendedObject);
      }
    });
    this.objectsToRemove.forEach((object) => {
      this.domElement.removeChild(object.element);
      this.appendedObjects.delete(object);
    });
  }
  setSize(width, height) {
    this._width = width;
    this._height = height;
    this._widthHalf = this._width / 2;
    this._heightHalf = this._height / 2;
    this.domElement.style.width = width + "px";
    this.domElement.style.height = height + "px";
  }
  renderObject(object, scene, camera) {
    if (object.isCSS2DObject) {
      _vector.setFromMatrixPosition(object.matrixWorld);
      _vector.applyMatrix4(_viewProjectionMatrix);
      const visible = object.visible === true && _vector.z >= -1 && _vector.z <= 1 && object.layers.test(camera.layers) === true;
      object.element.style.display = visible === true ? "" : "none";
      if (visible === true) {
        object.onBeforeRender(this, scene, camera);
        const element = object.element;
        element.style.transform = "translate(-50%,-50%) translate(" + (_vector.x * this._widthHalf + this._widthHalf) + "px," + (-_vector.y * this._heightHalf + this._heightHalf) + "px)";
        if (element.parentNode !== this.domElement) {
          this.domElement.appendChild(element);
          this.appendedObjects.add(object);
        }
        object.onAfterRender(this, scene, camera);
      }
      let objectData = this.dataByObject.get(object);
      const distanceToCameraSquared = this.getDistanceToSquared(camera, object);
      if (!objectData) {
        objectData = {
          distanceToCameraSquared
        };
        this.dataByObject.set(object, objectData);
      } else {
        objectData.distanceToCameraSquared = distanceToCameraSquared;
      }
    }
    for (const child of object.children) {
      this.renderObject(child, scene, camera);
    }
  }
  getDistanceToSquared(object1, object2) {
    _a.setFromMatrixPosition(object1.matrixWorld);
    _b.setFromMatrixPosition(object2.matrixWorld);
    return _a.distanceToSquared(_b);
  }
  filterAndFlatten(scene) {
    const result = [];
    scene.traverse(function(object) {
      if (object.isCSS2DObject)
        result.push(object);
    });
    return result;
  }
  zOrder(scene) {
    const sorted = this.filterAndFlatten(scene).sort((a, b) => {
      var _a2, _b2;
      if (a.renderOrder !== b.renderOrder) {
        return b.renderOrder - a.renderOrder;
      }
      const distanceA = ((_a2 = this.dataByObject.get(a)) == null ? void 0 : _a2.distanceToCameraSquared) || 0;
      const distanceB = ((_b2 = this.dataByObject.get(b)) == null ? void 0 : _b2.distanceToCameraSquared) || 0;
      return distanceA - distanceB;
    });
    const zMax = sorted.length;
    for (let i = 0, l = sorted.length; i < l; i++) {
      sorted[i].element.style.zIndex = `${zMax - i}`;
    }
  }
}


/***/ }),

/***/ 39393:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "t": function() { return /* binding */ ExpressionType; }
/* harmony export */ });

var ExpressionType = /* @__PURE__ */ ((ExpressionType2) => {
  ExpressionType2["animationNames"] = "animationNames";
  ExpressionType2["arg"] = "arg";
  ExpressionType2["argc"] = "argc";
  ExpressionType2["bbox"] = "bbox";
  ExpressionType2["blob"] = "blob";
  ExpressionType2["cameraName"] = "cameraName";
  ExpressionType2["cameraNames"] = "cameraNames";
  ExpressionType2["camerasCount"] = "camerasCount";
  ExpressionType2["centroid"] = "centroid";
  ExpressionType2["ch"] = "ch";
  ExpressionType2["chsop"] = "chsop";
  ExpressionType2["copy"] = "copy";
  ExpressionType2["copRes"] = "copRes";
  ExpressionType2["isDeviceMobile"] = "isDeviceMobile";
  ExpressionType2["isDeviceTouch"] = "isDeviceTouch";
  ExpressionType2["len"] = "len";
  ExpressionType2["join"] = "join";
  ExpressionType2["js"] = "js";
  ExpressionType2["object"] = "object";
  ExpressionType2["objectsCount"] = "objectsCount";
  ExpressionType2["objectName"] = "objectName";
  ExpressionType2["objectNames"] = "objectNames";
  ExpressionType2["opdigits"] = "opdigits";
  ExpressionType2["opname"] = "opname";
  ExpressionType2["padzero"] = "padzero";
  ExpressionType2["playerMode"] = "playerMode";
  ExpressionType2["point"] = "point";
  ExpressionType2["pointsCount"] = "pointsCount";
  ExpressionType2["smoothstep"] = "smoothstep";
  ExpressionType2["smootherstep"] = "smootherstep";
  ExpressionType2["solverIteration"] = "solverIteration";
  ExpressionType2["strCharsCount"] = "strCharsCount";
  ExpressionType2["strConcat"] = "strConcat";
  ExpressionType2["strIndex"] = "strIndex";
  ExpressionType2["strSub"] = "strSub";
  ExpressionType2["viewerSize"] = "viewerSize";
  ExpressionType2["windowSize"] = "windowSize";
  return ExpressionType2;
})(ExpressionType || {});


/***/ }),

/***/ 17162:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "F": function() { return /* binding */ FetchCopNode; }
/* harmony export */ });
/* harmony import */ var _Base__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(65276);
/* harmony import */ var _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(96949);
/* harmony import */ var _poly_NodeContext__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(52070);
/* harmony import */ var _core_geometry_Mask__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(58290);
/* harmony import */ var _core_Type__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(19037);

var __async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};





class FetchCopParamsConfig extends _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_0__/* .NodeParamsConfig */ .yI {
  constructor() {
    super(...arguments);
    /** @param sop node */
    this.node = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_0__/* .ParamConfig.NODE_PATH */ .XC.NODE_PATH("", {
      nodeSelection: {
        context: _poly_NodeContext__WEBPACK_IMPORTED_MODULE_1__/* .NodeContext.SOP */ .sy.SOP
      }
    });
    /** @param group to read the material from */
    this.group = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_0__/* .ParamConfig.STRING */ .XC.STRING("", {
      objectMask: true
    });
    /** @param texture name */
    this.name = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_0__/* .ParamConfig.STRING */ .XC.STRING("");
  }
}
const ParamsConfig = new FetchCopParamsConfig();
class FetchCopNode extends _Base__WEBPACK_IMPORTED_MODULE_2__/* .TypedCopNode */ .z {
  constructor() {
    super(...arguments);
    this.paramsConfig = ParamsConfig;
  }
  static type() {
    return "fetch";
  }
  cook() {
    return __async(this, null, function* () {
      const geometryNode = this.pv.node.nodeWithContext(_poly_NodeContext__WEBPACK_IMPORTED_MODULE_1__/* .NodeContext.SOP */ .sy.SOP, this.states.error);
      if (!geometryNode) {
        this.states.error.set(`node not found at path '${this.pv.node.path()}'`);
        return;
      }
      const container = yield geometryNode.compute();
      const coreGroup = container.coreContent();
      if (!coreGroup) {
        this.states.error.set(`geometry invalid`);
        return;
      }
      const selectedObjects = _core_geometry_Mask__WEBPACK_IMPORTED_MODULE_3__/* .CoreMask.filterThreejsObjects */ .x0.filterThreejsObjects(coreGroup, this.pv);
      if (selectedObjects.length == 0) {
        this.states.error.set(`no object matching group`);
        return;
      }
      let texture;
      for (const selectedObject of selectedObjects) {
        const material = selectedObject.material;
        if (material) {
          if (_core_Type__WEBPACK_IMPORTED_MODULE_4__/* .CoreType.isArray */ .MR.isArray(material)) {
            for (const mat of material) {
              texture = texture || this._textureFromMaterial(mat);
            }
          } else {
            texture = texture || this._textureFromMaterial(material);
          }
        }
      }
      if (!texture) {
        this.states.error.set(`no texture found`);
        return;
      }
      this.setTexture(texture);
    });
  }
  _textureFromMaterial(material) {
    const textureName = this.pv.name;
    const texture = material[textureName];
    if (texture && texture.isTexture) {
      return texture;
    }
  }
}


/***/ }),

/***/ 76906:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "C": function() { return /* binding */ AnimationMixerJsNode; }
/* harmony export */ });
/* harmony import */ var _Base__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(38231);
/* harmony import */ var _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(96949);
/* harmony import */ var _utils_io_connections_Js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(38857);
/* harmony import */ var _BaseObject3D__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(75807);
/* harmony import */ var _Poly__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(99934);
/* harmony import */ var _poly_registers_nodes_types_Js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(16718);







const CONNECTION_OPTIONS = _utils_io_connections_Js__WEBPACK_IMPORTED_MODULE_0__/* .JS_CONNECTION_POINT_IN_NODE_DEF */ .mX;
class AnimationMixerJsParamsConfig extends _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .NodeParamsConfig */ .yI {
}
const ParamsConfig = new AnimationMixerJsParamsConfig();
class AnimationMixerJsNode extends _Base__WEBPACK_IMPORTED_MODULE_2__/* .TypedJsNode */ .xZ {
  constructor() {
    super(...arguments);
    this.paramsConfig = ParamsConfig;
  }
  static type() {
    return _poly_registers_nodes_types_Js__WEBPACK_IMPORTED_MODULE_3__/* .JsType.ANIMATION_MIXER */ .K.ANIMATION_MIXER;
  }
  initializeNode() {
    this.io.inputs.setNamedInputConnectionPoints([
      // new ActorConnectionPoint(TRIGGER_CONNECTION_NAME, ActorConnectionPointType.TRIGGER, CONNECTION_OPTIONS),
      new _utils_io_connections_Js__WEBPACK_IMPORTED_MODULE_0__/* .JsConnectionPoint */ .fp(_utils_io_connections_Js__WEBPACK_IMPORTED_MODULE_0__/* .JsConnectionPointType.OBJECT_3D */ .zF.OBJECT_3D, _utils_io_connections_Js__WEBPACK_IMPORTED_MODULE_0__/* .JsConnectionPointType.OBJECT_3D */ .zF.OBJECT_3D, CONNECTION_OPTIONS)
    ]);
    this.io.outputs.setNamedOutputConnectionPoints([
      new _utils_io_connections_Js__WEBPACK_IMPORTED_MODULE_0__/* .JsConnectionPoint */ .fp(_utils_io_connections_Js__WEBPACK_IMPORTED_MODULE_0__/* .JsConnectionPointType.ANIMATION_MIXER */ .zF.ANIMATION_MIXER, _utils_io_connections_Js__WEBPACK_IMPORTED_MODULE_0__/* .JsConnectionPointType.ANIMATION_MIXER */ .zF.ANIMATION_MIXER)
    ]);
  }
  setLines(shadersCollectionController) {
    const object3D = (0,_BaseObject3D__WEBPACK_IMPORTED_MODULE_4__/* .inputObject3D */ .iv)(this, shadersCollectionController);
    const varName = this.jsVarName(_utils_io_connections_Js__WEBPACK_IMPORTED_MODULE_0__/* .JsConnectionPointType.ANIMATION_MIXER */ .zF.ANIMATION_MIXER);
    const func = _Poly__WEBPACK_IMPORTED_MODULE_5__/* .Poly.namedFunctionsRegister.getFunction */ .L.namedFunctionsRegister.getFunction("getAnimationMixer", this, shadersCollectionController);
    shadersCollectionController.addBodyOrComputed(this, [
      { dataType: _utils_io_connections_Js__WEBPACK_IMPORTED_MODULE_0__/* .JsConnectionPointType.VECTOR3 */ .zF.VECTOR3, varName, value: func.asString(object3D) }
    ]);
  }
}
AnimationMixerJsNode.OUTPUT_NAME = "val";


/***/ }),

/***/ 75853:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "k": function() { return /* binding */ MeshLambertMatNode; }
/* harmony export */ });
/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(21410);
/* harmony import */ var _Base__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(78058);
/* harmony import */ var _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(96949);
/* harmony import */ var _utils_ColorsController__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(40330);
/* harmony import */ var _utils_AdvancedCommonController__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(90476);
/* harmony import */ var _utils_TextureMapController__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(87732);
/* harmony import */ var _utils_TextureAlphaMapController__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(71607);
/* harmony import */ var _utils_TextureEnvMapSimpleController__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(97564);
/* harmony import */ var _utils_TextureLightMapController__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(28985);
/* harmony import */ var _utils_TextureEmissiveMapController__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(69228);
/* harmony import */ var _utils_FlatShadingController__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(90201);
/* harmony import */ var _utils_TextureAOMapController__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(94135);
/* harmony import */ var _utils_WireframeController__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(58206);
/* harmony import */ var _utils_FogController__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(30082);
/* harmony import */ var _utils_DefaultFolder__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(99233);
/* harmony import */ var _utils_TexturesFolder__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(45231);
/* harmony import */ var _utils_AdvancedFolder__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(73777);
/* harmony import */ var _poly_registers_nodes_types_Mat__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(41545);

var __async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};



















class MeshLambertMatParamsConfig extends (0,_utils_FogController__WEBPACK_IMPORTED_MODULE_0__/* .FogParamConfig */ .N9)(
  (0,_utils_WireframeController__WEBPACK_IMPORTED_MODULE_1__/* .WireframeParamConfig */ .M)(
    (0,_utils_AdvancedCommonController__WEBPACK_IMPORTED_MODULE_2__/* .AdvancedCommonParamConfig */ .E)(
      (0,_utils_FlatShadingController__WEBPACK_IMPORTED_MODULE_3__/* .FlatShadingParamConfig */ .s)(
        /* advanced */
        (0,_utils_AdvancedFolder__WEBPACK_IMPORTED_MODULE_4__/* .AdvancedFolderParamConfig */ .A)(
          (0,_utils_TextureLightMapController__WEBPACK_IMPORTED_MODULE_5__/* .LightMapParamConfig */ .T)(
            (0,_utils_TextureEnvMapSimpleController__WEBPACK_IMPORTED_MODULE_6__/* .EnvMapSimpleParamConfig */ .R)(
              (0,_utils_TextureEmissiveMapController__WEBPACK_IMPORTED_MODULE_7__/* .EmissiveMapParamConfig */ .f)(
                (0,_utils_TextureAOMapController__WEBPACK_IMPORTED_MODULE_8__/* .AOMapParamConfig */ .T)(
                  (0,_utils_TextureAlphaMapController__WEBPACK_IMPORTED_MODULE_9__/* .AlphaMapParamConfig */ .T)(
                    (0,_utils_TextureMapController__WEBPACK_IMPORTED_MODULE_10__/* .MapParamConfig */ .D)(
                      /* textures */
                      (0,_utils_TexturesFolder__WEBPACK_IMPORTED_MODULE_11__/* .TexturesFolderParamConfig */ .o)(
                        (0,_utils_ColorsController__WEBPACK_IMPORTED_MODULE_12__/* .ColorParamConfig */ .Pn)((0,_utils_DefaultFolder__WEBPACK_IMPORTED_MODULE_13__/* .DefaultFolderParamConfig */ .b)(_utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_14__/* .NodeParamsConfig */ .yI))
                      )
                    )
                  )
                )
              )
            )
          )
        )
      )
    )
  )
) {
}
const ParamsConfig = new MeshLambertMatParamsConfig();
class MeshLambertMatNode extends _Base__WEBPACK_IMPORTED_MODULE_15__/* .PrimitiveMatNode */ .Q_ {
  constructor() {
    super(...arguments);
    this.paramsConfig = ParamsConfig;
    this.controllers = {
      colors: new _utils_ColorsController__WEBPACK_IMPORTED_MODULE_12__/* .ColorsController */ .br(this),
      advancedCommon: new _utils_AdvancedCommonController__WEBPACK_IMPORTED_MODULE_2__/* .AdvancedCommonController */ .h(this),
      alphaMap: new _utils_TextureAlphaMapController__WEBPACK_IMPORTED_MODULE_9__/* .TextureAlphaMapController */ .s(this),
      aoMap: new _utils_TextureAOMapController__WEBPACK_IMPORTED_MODULE_8__/* .TextureAOMapController */ .Z(this),
      emissiveMap: new _utils_TextureEmissiveMapController__WEBPACK_IMPORTED_MODULE_7__/* .TextureEmissiveMapController */ .z(this),
      envMap: new _utils_TextureEnvMapSimpleController__WEBPACK_IMPORTED_MODULE_6__/* .TextureEnvMapSimpleController */ .z(this),
      fog: new _utils_FogController__WEBPACK_IMPORTED_MODULE_0__/* .FogController */ .j2(this),
      flatShading: new _utils_FlatShadingController__WEBPACK_IMPORTED_MODULE_3__/* .FlatShadingController */ .C(this),
      lightMap: new _utils_TextureLightMapController__WEBPACK_IMPORTED_MODULE_5__/* .TextureLightMapController */ .$(this),
      map: new _utils_TextureMapController__WEBPACK_IMPORTED_MODULE_10__/* .TextureMapController */ .g(this),
      wireframe: new _utils_WireframeController__WEBPACK_IMPORTED_MODULE_1__/* .WireframeController */ .U(this)
    };
    this.controllersList = Object.values(this.controllers);
  }
  static type() {
    return _poly_registers_nodes_types_Mat__WEBPACK_IMPORTED_MODULE_16__/* .MatType.MESH_LAMBERT */ .M.MESH_LAMBERT;
  }
  createMaterial() {
    return new three__WEBPACK_IMPORTED_MODULE_17__.MeshLambertMaterial({
      vertexColors: false,
      side: three__WEBPACK_IMPORTED_MODULE_17__.FrontSide,
      color: 16777215,
      opacity: 1
    });
  }
  cook() {
    return __async(this, null, function* () {
      this._material = this._material || this.createMaterial();
      yield Promise.all(this.controllersPromises(this._material));
      this.setMaterial(this._material);
    });
  }
}


/***/ }),

/***/ 97886:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "S": function() { return /* binding */ MeshNormalMatNode; }
/* harmony export */ });
/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(21410);
/* harmony import */ var _Base__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(78058);
/* harmony import */ var _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(96949);
/* harmony import */ var _utils_AdvancedCommonController__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(90476);
/* harmony import */ var _utils_TextureBumpMapController__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(89328);
/* harmony import */ var _utils_TextureNormalMapController__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(19767);
/* harmony import */ var _utils_TextureDisplacementMapController__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(70967);
/* harmony import */ var _utils_FlatShadingController__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(90201);
/* harmony import */ var _utils_TexturesFolder__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(45231);
/* harmony import */ var _utils_DefaultFolder__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(99233);
/* harmony import */ var _poly_registers_nodes_types_Mat__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(41545);

var __async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};












class MeshNormalMatParamsConfig extends (0,_utils_AdvancedCommonController__WEBPACK_IMPORTED_MODULE_0__/* .AdvancedCommonParamConfig */ .E)(
  (0,_utils_FlatShadingController__WEBPACK_IMPORTED_MODULE_1__/* .FlatShadingParamConfig */ .s)(
    /* advanced */
    (0,_utils_TextureNormalMapController__WEBPACK_IMPORTED_MODULE_2__/* .NormalMapParamConfig */ .$)(
      (0,_utils_TextureDisplacementMapController__WEBPACK_IMPORTED_MODULE_3__/* .DisplacementMapParamConfig */ .n)(
        (0,_utils_TextureBumpMapController__WEBPACK_IMPORTED_MODULE_4__/* .BumpMapParamConfig */ .w)(
          /* textures */
          (0,_utils_TexturesFolder__WEBPACK_IMPORTED_MODULE_5__/* .TexturesFolderParamConfig */ .o)((0,_utils_DefaultFolder__WEBPACK_IMPORTED_MODULE_6__/* .DefaultFolderParamConfig */ .b)(_utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_7__/* .NodeParamsConfig */ .yI))
        )
      )
    )
  )
) {
}
const ParamsConfig = new MeshNormalMatParamsConfig();
class MeshNormalMatNode extends _Base__WEBPACK_IMPORTED_MODULE_8__/* .PrimitiveMatNode */ .Q_ {
  constructor() {
    super(...arguments);
    this.paramsConfig = ParamsConfig;
    this.controllers = {
      advancedCommon: new _utils_AdvancedCommonController__WEBPACK_IMPORTED_MODULE_0__/* .AdvancedCommonController */ .h(this),
      bumpMap: new _utils_TextureBumpMapController__WEBPACK_IMPORTED_MODULE_4__/* .TextureBumpMapController */ .T(this),
      displacementMap: new _utils_TextureDisplacementMapController__WEBPACK_IMPORTED_MODULE_3__/* .TextureDisplacementMapController */ .u(this),
      flatShading: new _utils_FlatShadingController__WEBPACK_IMPORTED_MODULE_1__/* .FlatShadingController */ .C(this),
      normalMap: new _utils_TextureNormalMapController__WEBPACK_IMPORTED_MODULE_2__/* .TextureNormalMapController */ .w(this)
    };
    this.controllersList = Object.values(this.controllers);
  }
  static type() {
    return _poly_registers_nodes_types_Mat__WEBPACK_IMPORTED_MODULE_9__/* .MatType.MESH_NORMAL */ .M.MESH_NORMAL;
  }
  createMaterial() {
    return new three__WEBPACK_IMPORTED_MODULE_10__.MeshNormalMaterial({
      vertexColors: false,
      side: three__WEBPACK_IMPORTED_MODULE_10__.FrontSide,
      opacity: 1
    });
  }
  cook() {
    return __async(this, null, function* () {
      this._material = this._material || this.createMaterial();
      yield Promise.all(this.controllersPromises(this._material));
      this.setMaterial(this._material);
    });
  }
}


/***/ }),

/***/ 67113:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

// ESM COMPAT FLAG
__webpack_require__.r(__webpack_exports__);

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  "AllRegister": function() { return /* binding */ AllRegister; }
});

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/poly/registers/nodes/Category.ts

const NETWORK = "networks";
const CATEGORY_ACTOR = {
  ACTION: "action",
  ADVANCED: "advanced",
  ANIMATION: "animation",
  AUDIO: "audio",
  COMPUTER_VISION: "computer vision",
  CONVERSION: "conversion",
  EVENTS: "events",
  FLOW: "flow",
  GET: "get",
  INPUTS: "inputs",
  LOGIC: "logic",
  MAPS: "maps",
  MATH: "math",
  NETWORK,
  MISC: "misc",
  PARTICLES: "particles",
  PHYSICS: "physics",
  WEBXR: "webXR"
};
const CATEGORY_ANIM = {
  MISC: "misc",
  MODIFIER: "modifiers",
  NETWORK,
  PROP: "prop",
  SUBNET: "subnet",
  TIMING: "timing"
};
const CATEGORY_AUDIO = {
  ANALYSER: "analyser",
  EFFECTS: "effects",
  INPUTS: "inputs",
  INSTRUMENTS: "instruments",
  MISC: "misc",
  NETWORK
};
const CATEGORY_CAD = {
  ADVANCED: "advanced",
  EXTRUDE: "extrude",
  FLOW: "flow",
  MODIFIER: "modifiers",
  PRIMITIVES_2D: "primitives 2D",
  PRIMITIVES_3D: "primitives 3D",
  TRANSFORM: "transform",
  NETWORK
};
const CATEGORY_COP = {
  ADVANCED: "advanced",
  SDF: "SDF",
  FILTER: "filters",
  INPUT: "inputs",
  MAPS: "maps",
  MISC: "misc",
  NETWORK
};
const CATEGORY_CSG = {
  ADVANCED: "advanced",
  EXTRUDE: "extrude",
  FLOW: "flow",
  MODIFIER: "modifiers",
  PRIMITIVES_2D: "primitives 2D",
  PRIMITIVES_3D: "primitives 3D",
  TRANSFORM: "transform",
  NETWORK
};
const CATEGORY_EVENT = {
  ADVANCED: "advanced",
  CAMERA: "cameras",
  INPUT: "inputs",
  MISC: "misc",
  SCENE: "scene",
  NETWORK
};
const CATEGORY_GL = {
  ADVANCED: "advanced",
  COLOR: "color",
  CONVERSION: "conversion",
  DYNAMICS: "dynamics",
  GEOMETRY: "geometry",
  GLOBALS: "globals",
  LIGHTING: "lighting",
  LOGIC: "logic",
  MATH: "math",
  PHYSICS: "physics",
  QUAT: "quat",
  SDF_PRIMITIVES_2D: "SDF prims 2D",
  SDF_PRIMITIVES: "SDF prims 3D",
  SDF_MODIFIERS: "SDF modifiers",
  TRIGO: "trigo",
  UTIL: "util",
  INSTANCE: "instance",
  NETWORK
};
const CATEGORY_JS = {
  ACTION: "action",
  ADVANCED: "advanced",
  ANIMATION: "animation",
  AUDIO: "audio",
  COLOR: "color",
  COMPUTER_VISION: "computer vision",
  CONVERSION: "conversion",
  DYNAMICS: "dynamics",
  EVENTS: "events",
  FLOW: "flow",
  GEOMETRY: "geometry",
  GET: "get",
  GLOBALS: "globals",
  INPUTS: "inputs",
  LOGIC: "logic",
  MATH: "math",
  PARTICLES: "particles",
  PHYSICS: "physics",
  QUAT: "quat",
  SDF_PRIMITIVES_2D: "SDF prims 2D",
  SDF_PRIMITIVES: "SDF prims 3D",
  SDF_MODIFIERS: "SDF modifiers",
  TRIGO: "trigo",
  UTIL: "util",
  INSTANCE: "instance",
  WEBXR: "webXR",
  WFC: "WFC"
};
const CATEGORY_MAT = {
  ADVANCED: "advanced",
  INSTANCE: "instances",
  LINE: "lines",
  MESH: "meshes",
  NETWORK,
  POINTS: "points",
  UPDATE: "update",
  VOLUME: "volumes"
};
const CATEGORY_OBJ = {
  ADVANCED: "advanced",
  AUDIO: "audio",
  CAMERA: "cameras",
  GEOMETRY: "geometries",
  LIGHT: "lights",
  NETWORK,
  TRANSFORM: "transform"
};
const CATEGORY_ROP = {
  CSS: "css",
  NETWORK,
  WEBGL: "webgl"
};
const CATEGORY_SOP = {
  ADVANCED: "advanced",
  ANIMATION: "animation",
  ATTRIBUTE: "attributes",
  AUDIO: "audio",
  CAD: "CAD",
  CAMERA: "cameras",
  CSG: "CSG",
  COMPUTER_VISION: "computer vision",
  DYNAMICS: "dynamics",
  FLOW: "flow",
  HELPERS: "helpers",
  INPUT: "inputs",
  INSTANCE: "instance",
  LIGHTS: "lights",
  MAPS: "maps",
  MISC: "misc",
  MODIFIER: "modifiers",
  NETWORK,
  OUTPUT: "outputs",
  PHYSICS: "physics",
  PRIMITIVES_2D: "primitives 2D",
  PRIMITIVES: "primitives 3D",
  QUAD: "QUAD",
  RENDER: "render",
  SDF: "SDF",
  SUBNET: "subnet",
  TET: "TET",
  WEBXR: "webXR",
  WFC: "WFC"
};
const CATEGORY_POST = {
  ADVANCED: "advanced",
  BLUR: "blur",
  COLOR: "color",
  EFFECT: "effect",
  MISC: "misc",
  NETWORK
};

// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/nodes/anim/Delay.ts
var Delay = __webpack_require__(42711);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/nodes/anim/Duration.ts
var Duration = __webpack_require__(2430);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/nodes/anim/Easing.ts
var Easing = __webpack_require__(39448);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/nodes/anim/Merge.ts
var Merge = __webpack_require__(17830);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/nodes/anim/Null.ts
var Null = __webpack_require__(12446);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/nodes/anim/Operation.ts
var Operation = __webpack_require__(42187);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/nodes/anim/Position.ts
var Position = __webpack_require__(2189);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/nodes/anim/PropertyName.ts
var PropertyName = __webpack_require__(74517);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/nodes/anim/PropertyValue.ts
var PropertyValue = __webpack_require__(66318);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/nodes/anim/Repeat.ts
var Repeat = __webpack_require__(34231);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/nodes/anim/Play.ts
var Play = __webpack_require__(58136);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/nodes/anim/Subnet.ts
var Subnet = __webpack_require__(70892);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/nodes/anim/_Base.ts
var _Base = __webpack_require__(44276);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/nodes/utils/params/ParamsConfig.ts
var params_ParamsConfig = __webpack_require__(96949);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/poly/NodeContext.ts
var poly_NodeContext = __webpack_require__(52070);
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/anim/SubnetInput.ts

var __async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};



class SubnetInputAnimParamsConfig extends params_ParamsConfig/* NodeParamsConfig */.yI {
  constructor() {
    super(...arguments);
    /** @param sets which input of the parent subnet node is used */
    this.input = params_ParamsConfig/* ParamConfig.INTEGER */.XC.INTEGER(0, {
      range: [0, 3],
      rangeLocked: [true, true],
      callback: (node) => {
        SubnetInputAnimNode.PARAM_CALLBACK_reset(node);
      }
    });
  }
}
const ParamsConfig = new SubnetInputAnimParamsConfig();
class SubnetInputAnimNode extends _Base/* TypedAnimNode */.D {
  constructor() {
    super(...arguments);
    this.paramsConfig = ParamsConfig;
  }
  static type() {
    return poly_NodeContext/* NetworkChildNodeType.INPUT */.G$.INPUT;
  }
  initializeNode() {
    this.io.inputs.setCount(0);
    this.lifecycle.onAfterAdded(() => {
      this._setParentInputDependency();
    });
  }
  cook() {
    return __async(this, null, function* () {
      const input_index = this.pv.input;
      const parent = this.parent();
      if (parent) {
        if (parent.io.inputs.hasInput(input_index)) {
          const container = yield parent.containerController.requestInputContainer(input_index);
          if (container) {
            const timelineBuilder = container.coreContent();
            if (timelineBuilder) {
              this.setTimelineBuilder(timelineBuilder);
              return;
            }
          }
        } else {
          this.states.error.set(`parent has no input ${input_index}`);
        }
        this.cookController.endCook();
      } else {
        this.states.error.set(`subnet input has no parent`);
      }
    });
  }
  static PARAM_CALLBACK_reset(node) {
    node._setParentInputDependency();
  }
  _setParentInputDependency() {
    if (this._currentParentInputGraphNode) {
      this.removeGraphInput(this._currentParentInputGraphNode);
    }
    const parent = this.parent();
    if (parent) {
      this._currentParentInputGraphNode = parent.io.inputs.inputGraphNode(this.pv.input);
      this.addGraphInput(this._currentParentInputGraphNode);
    }
  }
}

// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/nodes/anim/SubnetOutput.ts
var SubnetOutput = __webpack_require__(57124);
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/anim/Switch.ts



class SwitchAnimParamsConfig extends params_ParamsConfig/* NodeParamsConfig */.yI {
  constructor() {
    super(...arguments);
    /** @param input to process */
    this.input = params_ParamsConfig/* ParamConfig.INTEGER */.XC.INTEGER(0, {
      range: [0, 3],
      rangeLocked: [true, true]
    });
  }
}
const Switch_ParamsConfig = new SwitchAnimParamsConfig();
class SwitchAnimNode extends _Base/* TypedAnimNode */.D {
  constructor() {
    super(...arguments);
    this.paramsConfig = Switch_ParamsConfig;
  }
  static type() {
    return "switch";
  }
  initializeNode() {
    this.io.inputs.setCount(0, 4);
  }
  cook(input_contents) {
    const timeline_builder = input_contents[this.pv.input];
    if (timeline_builder) {
      this.setTimelineBuilder(timeline_builder);
    } else {
      this.states.error.set(`input ${this.pv.input} is not valid`);
    }
  }
}

// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/nodes/anim/Target.ts + 1 modules
var Target = __webpack_require__(31309);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/nodes/anim/_BaseManager.ts
var _BaseManager = __webpack_require__(68378);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/nodes/js/code/assemblers/actor/ActorPersistedConfig.ts
var ActorPersistedConfig = __webpack_require__(13320);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/poly/registers/assemblers/_BaseRegister.ts
var _BaseRegister = __webpack_require__(33899);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/core/actor/ActorCompilationController.ts
var ActorCompilationController = __webpack_require__(36642);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/Poly.ts + 21 modules
var Poly = __webpack_require__(99934);
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/anim/ActorsNetwork.ts







class ActorsNetworkAnimNode extends _BaseManager/* ParamLessBaseNetworkAnimNode */.q {
  constructor() {
    super(...arguments);
    this._childrenControllerContext = poly_NodeContext/* NodeContext.JS */.sy.JS;
    //
    // ASSEMBLERS
    //
    this.persisted_config = new ActorPersistedConfig/* ActorPersistedConfig */.R(this);
    this._assemblerController = this._createAssemblerController();
    //
    // compilation
    //
    this.compilationController = new ActorCompilationController/* ActorCompilationController */.z7(this);
  }
  static type() {
    return poly_NodeContext/* NetworkNodeType.ACTOR */.kX.ACTOR;
  }
  createNode(node_class, options) {
    return super.createNode(node_class, options);
  }
  children() {
    return super.children();
  }
  nodesByType(type) {
    return super.nodesByType(type);
  }
  //
  childrenAllowed() {
    if (this.assemblerController()) {
      return super.childrenAllowed();
    }
    return false;
  }
  sceneReadonly() {
    return this.assemblerController() == null;
  }
  assemblerController() {
    return this._assemblerController;
  }
  usedAssembler() {
    return _BaseRegister/* AssemblerName.JS_ACTOR */.Q.JS_ACTOR;
  }
  _createAssemblerController() {
    return Poly/* Poly.assemblersRegister.assembler */.L.assemblersRegister.assembler(this, this.usedAssembler());
  }
  compile() {
    this.compilationController.compile();
  }
  cook() {
    this.compilationController.compileIfRequired();
    this.cookController.endCook();
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/anim/AnimationsNetwork.ts



class AnimationsNetworkAnimNode extends _BaseManager/* ParamLessBaseNetworkAnimNode */.q {
  constructor() {
    super(...arguments);
    this._childrenControllerContext = poly_NodeContext/* NodeContext.ANIM */.sy.ANIM;
  }
  static type() {
    return poly_NodeContext/* NetworkNodeType.ANIM */.kX.ANIM;
  }
  createNode(node_class, options) {
    return super.createNode(node_class, options);
  }
  children() {
    return super.children();
  }
  nodesByType(type) {
    return super.nodesByType(type);
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/anim/AudioNetwork.ts



class AudioNetworkAnimNode extends _BaseManager/* ParamLessBaseNetworkAnimNode */.q {
  constructor() {
    super(...arguments);
    this._childrenControllerContext = poly_NodeContext/* NodeContext.AUDIO */.sy.AUDIO;
  }
  static type() {
    return poly_NodeContext/* NetworkNodeType.AUDIO */.kX.AUDIO;
  }
  createNode(node_class, options) {
    return super.createNode(node_class, options);
  }
  children() {
    return super.children();
  }
  nodesByType(type) {
    return super.nodesByType(type);
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/anim/CopNetwork.ts



class CopNetworkAnimNode extends _BaseManager/* ParamLessBaseNetworkAnimNode */.q {
  constructor() {
    super(...arguments);
    this._childrenControllerContext = poly_NodeContext/* NodeContext.COP */.sy.COP;
  }
  static type() {
    return poly_NodeContext/* NetworkNodeType.COP */.kX.COP;
  }
  createNode(node_class, options) {
    return super.createNode(node_class, options);
  }
  children() {
    return super.children();
  }
  nodesByType(type) {
    return super.nodesByType(type);
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/anim/EventsNetwork.ts



class EventsNetworkAnimNode extends _BaseManager/* ParamLessBaseNetworkAnimNode */.q {
  constructor() {
    super(...arguments);
    this._childrenControllerContext = poly_NodeContext/* NodeContext.EVENT */.sy.EVENT;
  }
  static type() {
    return poly_NodeContext/* NetworkNodeType.EVENT */.kX.EVENT;
  }
  createNode(node_class, options) {
    return super.createNode(node_class, options);
  }
  children() {
    return super.children();
  }
  nodesByType(type) {
    return super.nodesByType(type);
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/anim/MaterialsNetwork.ts



class MaterialsNetworkAnimNode extends _BaseManager/* ParamLessBaseNetworkAnimNode */.q {
  constructor() {
    super(...arguments);
    this._childrenControllerContext = poly_NodeContext/* NodeContext.MAT */.sy.MAT;
  }
  static type() {
    return poly_NodeContext/* NetworkNodeType.MAT */.kX.MAT;
  }
  createNode(node_class, options) {
    return super.createNode(node_class, options);
  }
  children() {
    return super.children();
  }
  nodesByType(type) {
    return super.nodesByType(type);
  }
}

// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/nodes/anim/PostProcessNetwork.ts
var PostProcessNetwork = __webpack_require__(13769);
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/anim/RenderersNetwork.ts



class RenderersNetworkAnimNode extends _BaseManager/* ParamLessBaseNetworkAnimNode */.q {
  constructor() {
    super(...arguments);
    this._childrenControllerContext = poly_NodeContext/* NodeContext.ROP */.sy.ROP;
  }
  static type() {
    return poly_NodeContext/* NetworkNodeType.ROP */.kX.ROP;
  }
  createNode(node_class, options) {
    return super.createNode(node_class, options);
  }
  children() {
    return super.children();
  }
  nodesByType(type) {
    return super.nodesByType(type);
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/poly/registers/nodes/Anim.ts


























class AnimRegister {
  static run(poly) {
    poly.registerNode(Delay/* DelayAnimNode */.E, CATEGORY_ANIM.TIMING);
    poly.registerNode(Duration/* DurationAnimNode */.N, CATEGORY_ANIM.MODIFIER);
    poly.registerNode(Easing/* EasingAnimNode */.v, CATEGORY_ANIM.MODIFIER);
    poly.registerNode(Merge/* MergeAnimNode */.C, CATEGORY_ANIM.MODIFIER);
    poly.registerNode(Null/* NullAnimNode */.D, CATEGORY_ANIM.MISC);
    poly.registerNode(Operation/* OperationAnimNode */.j, CATEGORY_ANIM.MODIFIER);
    poly.registerNode(Play/* PlayAnimNode */.n, CATEGORY_ANIM.MISC);
    poly.registerNode(Position/* PositionAnimNode */.y, CATEGORY_ANIM.TIMING);
    poly.registerNode(PropertyName/* PropertyNameAnimNode */.Z, CATEGORY_ANIM.PROP);
    poly.registerNode(PropertyValue/* PropertyValueAnimNode */.K, CATEGORY_ANIM.PROP);
    poly.registerNode(Repeat/* RepeatAnimNode */.Z, CATEGORY_ANIM.MODIFIER);
    poly.registerNode(Subnet/* SubnetAnimNode */.X, CATEGORY_ANIM.SUBNET);
    poly.registerNode(SubnetInputAnimNode, CATEGORY_ANIM.SUBNET);
    poly.registerNode(SubnetOutput/* SubnetOutputAnimNode */.p, CATEGORY_ANIM.SUBNET);
    poly.registerNode(SwitchAnimNode, CATEGORY_ANIM.MISC);
    poly.registerNode(Target/* TargetAnimNode */.vP, CATEGORY_ANIM.PROP);
    poly.registerNode(ActorsNetworkAnimNode, CATEGORY_ANIM.NETWORK);
    poly.registerNode(AnimationsNetworkAnimNode, CATEGORY_ANIM.NETWORK);
    poly.registerNode(AudioNetworkAnimNode, CATEGORY_ANIM.NETWORK);
    poly.registerNode(CopNetworkAnimNode, CATEGORY_ANIM.NETWORK);
    poly.registerNode(EventsNetworkAnimNode, CATEGORY_ANIM.NETWORK);
    poly.registerNode(MaterialsNetworkAnimNode, CATEGORY_ANIM.NETWORK);
    poly.registerNode(PostProcessNetwork/* PostProcessNetworkAnimNode */.U, CATEGORY_ANIM.NETWORK);
    poly.registerNode(RenderersNetworkAnimNode, CATEGORY_ANIM.NETWORK);
  }
}

// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/nodes/audio/_Base.ts
var audio_Base = __webpack_require__(46445);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/core/audio/AudioBuilder.ts
var AudioBuilder = __webpack_require__(4599);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/node_modules/tone/build/esm/instrument/AMSynth.js
var AMSynth = __webpack_require__(68969);
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/audio/Envelope.ts




const ENVELOPE_DEFAULTS = {
  attackCurve: "linear",
  attack: 0.01,
  decayCurve: "exponential",
  decay: 0.1,
  releaseCurve: "exponential",
  release: 1,
  sustain: 0.5
};
class EnvelopeAudioParamsConfig extends params_ParamsConfig/* NodeParamsConfig */.yI {
  constructor() {
    super(...arguments);
    /** @param The amount of time it takes for the envelope to go from 0 to it's maximum value. */
    this.attack = params_ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(ENVELOPE_DEFAULTS.attack, {
      range: [0, 0.1],
      rangeLocked: [true, false]
    });
    /** The period of time after the attack that it takes for the envelope to fall to the sustain value. */
    this.decay = params_ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(ENVELOPE_DEFAULTS.decay, {
      range: [0, 1],
      rangeLocked: [true, false]
    });
    /** The percent of the maximum value that the envelope rests at until the release is triggered. */
    this.sustain = params_ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(ENVELOPE_DEFAULTS.sustain, {
      range: [0, 1],
      rangeLocked: [true, false]
    });
    /** The amount of time after the release is triggered it takes to reach 0. */
    this.release = params_ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(ENVELOPE_DEFAULTS.release, {
      range: [0, 1],
      rangeLocked: [true, false]
    });
  }
}
const Envelope_ParamsConfig = new EnvelopeAudioParamsConfig();
class EnvelopeAudioNode extends audio_Base/* TypedAudioNode */.K {
  constructor() {
    super(...arguments);
    this.paramsConfig = Envelope_ParamsConfig;
  }
  static type() {
    return "envelope";
  }
  initializeNode() {
    this.io.inputs.setCount(0);
  }
  cook(inputContents) {
    const audioBuilder = new AudioBuilder/* AudioBuilder */.y();
    audioBuilder.setEnvelopeParams({
      attackCurve: "linear",
      attack: this.pv.attack,
      decayCurve: "exponential",
      decay: this.pv.decay,
      releaseCurve: "exponential",
      release: this.pv.release,
      sustain: this.pv.sustain
    });
    this.setAudioBuilder(audioBuilder);
  }
}

// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/poly/registers/nodes/types/Audio.ts
var Audio = __webpack_require__(97960);
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/audio/AMSynth.ts







class AMSynthAudioParamsConfig extends params_ParamsConfig/* NodeParamsConfig */.yI {
}
const AMSynth_ParamsConfig = new AMSynthAudioParamsConfig();
class AMSynthAudioNode extends audio_Base/* TypedAudioNode */.K {
  constructor() {
    super(...arguments);
    this.paramsConfig = AMSynth_ParamsConfig;
  }
  static type() {
    return Audio/* AudioType.AM_SYNTH */.w.AM_SYNTH;
  }
  initializeNode() {
    this.io.inputs.setCount(0, 1);
  }
  cook(inputContents) {
    const envelopeBuilder = inputContents[0];
    const envelopeParams = envelopeBuilder.envelopeParams() || ENVELOPE_DEFAULTS;
    const synth = new AMSynth/* AMSynth */.I({
      harmonicity: 2.5,
      oscillator: {
        type: "fatsawtooth"
      },
      envelope: envelopeParams,
      modulation: {
        type: "square"
      },
      modulationEnvelope: {
        attack: 0.5,
        decay: 0.01
      }
    });
    const audioBuilder = new AudioBuilder/* AudioBuilder */.y();
    audioBuilder.setInstrument(synth);
    this.setAudioBuilder(audioBuilder);
  }
}

// EXTERNAL MODULE: ../@polygonjs/polygonjs/node_modules/tone/build/esm/effect/AutoFilter.js + 1 modules
var AutoFilter = __webpack_require__(58289);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/nodes/audio/utils/EffectsController.ts
var EffectsController = __webpack_require__(23725);
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/audio/AutoFilter.ts

var __defProp = Object.defineProperty;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};

const DEFAULTS = {
  baseFrequency: 200,
  // depth: 1,
  // frequency: 1,
  octaves: 2.6
  // type: 'sine',
  // wet: 1,
};



const paramCallback = (node) => {
  AutoFilterAudioNode.PARAM_CALLBACK_updateEffect(node);
};
class AutoFilterAudioParamsConfig extends params_ParamsConfig/* NodeParamsConfig */.yI {
  constructor() {
    super(...arguments);
    /** @param baseFrequency */
    this.baseFrequency = params_ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(DEFAULTS.baseFrequency, __spreadValues({
      range: [0, 1e3],
      rangeLocked: [true, false]
    }, (0,EffectsController/* effectParamsOptions */.K)(paramCallback)));
    /** @param octaves */
    this.octaves = params_ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(DEFAULTS.octaves, __spreadValues({
      range: [0, 10],
      rangeLocked: [true, false]
    }, (0,EffectsController/* effectParamsOptions */.K)(paramCallback)));
  }
  // TODO: promote filter params
}
const AutoFilter_ParamsConfig = new AutoFilterAudioParamsConfig();
class AutoFilterAudioNode extends audio_Base/* TypedAudioNode */.K {
  constructor() {
    super(...arguments);
    this.paramsConfig = AutoFilter_ParamsConfig;
  }
  static type() {
    return "autoFilter";
  }
  initializeNode() {
    this.io.inputs.setCount(1);
  }
  cook(inputContents) {
    const audioBuilder = inputContents[0];
    const effect = this._effect();
    const inputNode = audioBuilder.audioNode();
    if (inputNode) {
      inputNode.connect(effect);
    }
    audioBuilder.setAudioNode(effect);
    this.setAudioBuilder(audioBuilder);
  }
  _effect() {
    return this.__effect__ = this.__effect__ || this._createEffect();
  }
  _createEffect() {
    return new AutoFilter/* AutoFilter */.a({
      baseFrequency: this.pv.baseFrequency,
      octaves: this.pv.octaves
    });
  }
  static PARAM_CALLBACK_updateEffect(node) {
    node._updateEffect();
  }
  _updateEffect() {
    const effect = this._effect();
    effect.baseFrequency = this.pv.baseFrequency;
    effect.octaves = this.pv.octaves;
  }
}

// EXTERNAL MODULE: ../@polygonjs/polygonjs/node_modules/tone/build/esm/effect/AutoWah.js + 4 modules
var AutoWah = __webpack_require__(66784);
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/audio/AutoWah.ts

var AutoWah_defProp = Object.defineProperty;
var AutoWah_getOwnPropSymbols = Object.getOwnPropertySymbols;
var AutoWah_hasOwnProp = Object.prototype.hasOwnProperty;
var AutoWah_propIsEnum = Object.prototype.propertyIsEnumerable;
var AutoWah_defNormalProp = (obj, key, value) => key in obj ? AutoWah_defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var AutoWah_spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (AutoWah_hasOwnProp.call(b, prop))
      AutoWah_defNormalProp(a, prop, b[prop]);
  if (AutoWah_getOwnPropSymbols)
    for (var prop of AutoWah_getOwnPropSymbols(b)) {
      if (AutoWah_propIsEnum.call(b, prop))
        AutoWah_defNormalProp(a, prop, b[prop]);
    }
  return a;
};

const AutoWah_DEFAULTS = {
  // Q: 2,
  baseFrequency: 100,
  follower: 0.2,
  // gain: 2,
  octaves: 6,
  sensitivity: 0
  // wet: 1,
};



const AutoWah_paramCallback = (node) => {
  AutoWahAudioNode.PARAM_CALLBACK_updateEffect(node);
};
class AutoWahAudioParamsConfig extends params_ParamsConfig/* NodeParamsConfig */.yI {
  constructor() {
    super(...arguments);
    /** @param baseFrequency */
    this.baseFrequency = params_ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(AutoWah_DEFAULTS.baseFrequency, AutoWah_spreadValues({
      range: [0, 1e3],
      rangeLocked: [true, false]
    }, (0,EffectsController/* effectParamsOptions */.K)(AutoWah_paramCallback)));
    /** @param octaves */
    this.octaves = params_ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(AutoWah_DEFAULTS.octaves, AutoWah_spreadValues({
      range: [0, 10],
      rangeLocked: [true, false]
    }, (0,EffectsController/* effectParamsOptions */.K)(AutoWah_paramCallback)));
    /** @param sensitivity */
    this.sensitivity = params_ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(AutoWah_DEFAULTS.sensitivity, AutoWah_spreadValues({
      range: [0, 1],
      rangeLocked: [true, false]
    }, (0,EffectsController/* effectParamsOptions */.K)(AutoWah_paramCallback)));
    /** @param follower */
    this.follower = params_ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(AutoWah_DEFAULTS.follower, AutoWah_spreadValues({
      range: [0, 1],
      rangeLocked: [true, false]
    }, (0,EffectsController/* effectParamsOptions */.K)(AutoWah_paramCallback)));
  }
  // TODO: promote filter params
}
const AutoWah_ParamsConfig = new AutoWahAudioParamsConfig();
class AutoWahAudioNode extends audio_Base/* TypedAudioNode */.K {
  constructor() {
    super(...arguments);
    this.paramsConfig = AutoWah_ParamsConfig;
  }
  static type() {
    return "autoWah";
  }
  initializeNode() {
    this.io.inputs.setCount(1);
  }
  cook(inputContents) {
    const audioBuilder = inputContents[0];
    const effect = this._effect();
    const inputNode = audioBuilder.audioNode();
    if (inputNode) {
      inputNode.connect(effect);
    }
    audioBuilder.setAudioNode(effect);
    this.setAudioBuilder(audioBuilder);
  }
  _effect() {
    return this.__effect__ = this.__effect__ || this._createEffect();
  }
  _createEffect() {
    return new AutoWah/* AutoWah */.o({
      baseFrequency: this.pv.baseFrequency,
      octaves: this.pv.octaves,
      sensitivity: this.pv.sensitivity,
      // Q: this.pv.Q,
      // gain: this.pv.gain,
      follower: this.pv.follower
    });
  }
  static PARAM_CALLBACK_updateEffect(node) {
    node._updateEffect();
  }
  _updateEffect() {
    const effect = this._effect();
    effect.baseFrequency = this.pv.baseFrequency;
    effect.octaves = this.pv.octaves;
    effect.sensitivity = this.pv.sensitivity;
    effect.follower = this.pv.follower;
  }
}

// EXTERNAL MODULE: ../@polygonjs/polygonjs/node_modules/tone/build/esm/effect/BitCrusher.js + 5 modules
var BitCrusher = __webpack_require__(66087);
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/audio/BitCrusher.ts


const BitCrusher_DEFAULTS = { bits: 4 };


class BitCrusherAudioParamsConfig extends params_ParamsConfig/* NodeParamsConfig */.yI {
  constructor() {
    super(...arguments);
    /** @param bits */
    this.bits = params_ParamsConfig/* ParamConfig.INTEGER */.XC.INTEGER(BitCrusher_DEFAULTS.bits, {
      range: [1, 16],
      rangeLocked: [true, true]
      // ...effectParamsOptions(paramCallback),
    });
  }
}
const BitCrusher_ParamsConfig = new BitCrusherAudioParamsConfig();
class BitCrusherAudioNode extends audio_Base/* TypedAudioNode */.K {
  constructor() {
    super(...arguments);
    this.paramsConfig = BitCrusher_ParamsConfig;
  }
  static type() {
    return "bitCrusher";
  }
  initializeNode() {
    this.io.inputs.setCount(1);
  }
  cook(inputContents) {
    const audioBuilder = inputContents[0];
    const effect = new BitCrusher/* BitCrusher */.M(this.pv.bits);
    const inputNode = audioBuilder.audioNode();
    if (inputNode) {
      inputNode.connect(effect);
    }
    audioBuilder.setAudioNode(effect);
    this.setAudioBuilder(audioBuilder);
  }
  // private __effect__: BitCrusher | undefined;
  // private _effect() {
  // 	return (this.__effect__ = this.__effect__ || this._createEffect());
  // }
  // private _createEffect() {
  // 	return new BitCrusher(this.pv.bits);
  // }
  // static PARAM_CALLBACK_updateEffect(node: BitCrusherAudioNode) {
  // 	node._updateEffect();
  // }
  // private _updateEffect() {
  // 	const effect = this._effect();
  // 	effect.bits = this.pv.bits;
  // }
}

// EXTERNAL MODULE: ../@polygonjs/polygonjs/node_modules/tone/build/esm/effect/Chebyshev.js
var Chebyshev = __webpack_require__(49832);
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/audio/Chebyshev.ts

var Chebyshev_defProp = Object.defineProperty;
var Chebyshev_getOwnPropSymbols = Object.getOwnPropertySymbols;
var Chebyshev_hasOwnProp = Object.prototype.hasOwnProperty;
var Chebyshev_propIsEnum = Object.prototype.propertyIsEnumerable;
var Chebyshev_defNormalProp = (obj, key, value) => key in obj ? Chebyshev_defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var Chebyshev_spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (Chebyshev_hasOwnProp.call(b, prop))
      Chebyshev_defNormalProp(a, prop, b[prop]);
  if (Chebyshev_getOwnPropSymbols)
    for (var prop of Chebyshev_getOwnPropSymbols(b)) {
      if (Chebyshev_propIsEnum.call(b, prop))
        Chebyshev_defNormalProp(a, prop, b[prop]);
    }
  return a;
};

const Chebyshev_DEFAULTS = { order: 4, oversample: "none" };
const OVER_SAMPLE_TYPES = ["2x", "4x", "none"];



const Chebyshev_paramCallback = (node) => {
  ChebyshevAudioNode.PARAM_CALLBACK_updateEffect(node);
};
class ChebyshevAudioParamsConfig extends params_ParamsConfig/* NodeParamsConfig */.yI {
  constructor() {
    super(...arguments);
    /** @param order */
    this.order = params_ParamsConfig/* ParamConfig.INTEGER */.XC.INTEGER(Chebyshev_DEFAULTS.order, Chebyshev_spreadValues({
      range: [1, 100],
      rangeLocked: [true, true]
    }, (0,EffectsController/* effectParamsOptions */.K)(Chebyshev_paramCallback)));
    /** @param oversample */
    this.oversample = params_ParamsConfig/* ParamConfig.INTEGER */.XC.INTEGER(OVER_SAMPLE_TYPES.indexOf(Chebyshev_DEFAULTS.oversample), {
      menu: {
        entries: OVER_SAMPLE_TYPES.map((name, value) => ({ name, value }))
      }
    });
  }
}
const Chebyshev_ParamsConfig = new ChebyshevAudioParamsConfig();
class ChebyshevAudioNode extends audio_Base/* TypedAudioNode */.K {
  constructor() {
    super(...arguments);
    this.paramsConfig = Chebyshev_ParamsConfig;
  }
  static type() {
    return "chebyshev";
  }
  initializeNode() {
    this.io.inputs.setCount(1);
  }
  cook(inputContents) {
    const audioBuilder = inputContents[0];
    const effect = this._effect();
    const inputNode = audioBuilder.audioNode();
    if (inputNode) {
      inputNode.connect(effect);
    }
    audioBuilder.setAudioNode(effect);
    this.setAudioBuilder(audioBuilder);
  }
  _effect() {
    return this.__effect__ = this.__effect__ || this._createEffect();
  }
  _createEffect() {
    return new Chebyshev/* Chebyshev */.t({
      order: this.pv.order,
      oversample: OVER_SAMPLE_TYPES[this.pv.oversample]
    });
  }
  static PARAM_CALLBACK_updateEffect(node) {
    node._updateEffect();
  }
  _updateEffect() {
    const effect = this._effect();
    effect.order = this.pv.order;
    effect.oversample = OVER_SAMPLE_TYPES[this.pv.oversample];
  }
}

// EXTERNAL MODULE: ../@polygonjs/polygonjs/node_modules/tone/build/esm/effect/Chorus.js
var Chorus = __webpack_require__(29083);
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/audio/Chorus.ts

var Chorus_defProp = Object.defineProperty;
var Chorus_getOwnPropSymbols = Object.getOwnPropertySymbols;
var Chorus_hasOwnProp = Object.prototype.hasOwnProperty;
var Chorus_propIsEnum = Object.prototype.propertyIsEnumerable;
var Chorus_defNormalProp = (obj, key, value) => key in obj ? Chorus_defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var Chorus_spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (Chorus_hasOwnProp.call(b, prop))
      Chorus_defNormalProp(a, prop, b[prop]);
  if (Chorus_getOwnPropSymbols)
    for (var prop of Chorus_getOwnPropSymbols(b)) {
      if (Chorus_propIsEnum.call(b, prop))
        Chorus_defNormalProp(a, prop, b[prop]);
    }
  return a;
};

const Chorus_DEFAULTS = { delayTime: 3.5, depth: 0.7, feedback: 0, frequency: 1.5, spread: 180, type: "sine", wet: 0.5 };



const Chorus_paramCallback = (node) => {
  ChorusAudioNode.PARAM_CALLBACK_updateEffect(node);
};
class ChorusAudioParamsConfig extends params_ParamsConfig/* NodeParamsConfig */.yI {
  constructor() {
    super(...arguments);
    /** @param The frequency of the LFO. */
    this.frequency = params_ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(Chorus_DEFAULTS.frequency, {
      range: [0, 10],
      rangeLocked: [true, false]
      // no callback allowed for frequency as it is a readonly property
      // ...effectParamsOptions(paramCallback),
    });
    /** The delay of the chorus effect in ms */
    this.delayTime = params_ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(Chorus_DEFAULTS.delayTime, Chorus_spreadValues({
      range: [0, 1],
      rangeLocked: [true, false]
    }, (0,EffectsController/* effectParamsOptions */.K)(Chorus_paramCallback)));
    /** The depth of the chorus */
    this.depth = params_ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(Chorus_DEFAULTS.depth, Chorus_spreadValues({
      range: [0, 1],
      rangeLocked: [true, false]
    }, (0,EffectsController/* effectParamsOptions */.K)(Chorus_paramCallback)));
  }
}
const Chorus_ParamsConfig = new ChorusAudioParamsConfig();
class ChorusAudioNode extends audio_Base/* TypedAudioNode */.K {
  constructor() {
    super(...arguments);
    this.paramsConfig = Chorus_ParamsConfig;
  }
  static type() {
    return "chorus";
  }
  initializeNode() {
    this.io.inputs.setCount(1);
  }
  cook(inputContents) {
    const audioBuilder = inputContents[0];
    const effect = this._effect();
    const inputNode = audioBuilder.audioNode();
    if (inputNode) {
      inputNode.connect(effect);
    }
    audioBuilder.setAudioNode(effect);
    this.setAudioBuilder(audioBuilder);
  }
  _effect() {
    return this.__effect__ = this.__effect__ || this._createEffect();
  }
  _createEffect() {
    return new Chorus/* Chorus */.b({
      frequency: this.pv.frequency,
      delayTime: this.pv.delayTime,
      depth: this.pv.depth
    });
  }
  static PARAM_CALLBACK_updateEffect(node) {
    node._updateEffect();
  }
  _updateEffect() {
    const effect = this._effect();
    effect.delayTime = this.pv.delayTime;
    effect.depth = this.pv.depth;
  }
}

// EXTERNAL MODULE: ../@polygonjs/polygonjs/node_modules/tone/build/esm/effect/Distortion.js
var Distortion = __webpack_require__(66568);
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/audio/Distortion.ts

var Distortion_defProp = Object.defineProperty;
var Distortion_getOwnPropSymbols = Object.getOwnPropertySymbols;
var Distortion_hasOwnProp = Object.prototype.hasOwnProperty;
var Distortion_propIsEnum = Object.prototype.propertyIsEnumerable;
var Distortion_defNormalProp = (obj, key, value) => key in obj ? Distortion_defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var Distortion_spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (Distortion_hasOwnProp.call(b, prop))
      Distortion_defNormalProp(a, prop, b[prop]);
  if (Distortion_getOwnPropSymbols)
    for (var prop of Distortion_getOwnPropSymbols(b)) {
      if (Distortion_propIsEnum.call(b, prop))
        Distortion_defNormalProp(a, prop, b[prop]);
    }
  return a;
};

const Distortion_DEFAULTS = {
  distortion: 0.4,
  oversample: "none"
};
const Distortion_OVER_SAMPLE_TYPES = ["2x", "4x", "none"];



const Distortion_paramCallback = (node) => {
  DistortionAudioNode.PARAM_CALLBACK_updateEffect(node);
};
class DistortionAudioParamsConfig extends params_ParamsConfig/* NodeParamsConfig */.yI {
  constructor() {
    super(...arguments);
    /** @param distortion */
    this.distortion = params_ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(Distortion_DEFAULTS.distortion, Distortion_spreadValues({
      range: [0, 1],
      rangeLocked: [true, true]
    }, (0,EffectsController/* effectParamsOptions */.K)(Distortion_paramCallback)));
    /** @param oversample */
    this.oversample = params_ParamsConfig/* ParamConfig.INTEGER */.XC.INTEGER(Distortion_OVER_SAMPLE_TYPES.indexOf(Distortion_DEFAULTS.oversample), {
      menu: {
        entries: Distortion_OVER_SAMPLE_TYPES.map((name, value) => ({ name, value }))
      }
    });
  }
}
const Distortion_ParamsConfig = new DistortionAudioParamsConfig();
class DistortionAudioNode extends audio_Base/* TypedAudioNode */.K {
  constructor() {
    super(...arguments);
    this.paramsConfig = Distortion_ParamsConfig;
  }
  static type() {
    return "distortion";
  }
  initializeNode() {
    this.io.inputs.setCount(1);
  }
  cook(inputContents) {
    const audioBuilder = inputContents[0];
    const effect = this._effect();
    const inputNode = audioBuilder.audioNode();
    if (inputNode) {
      inputNode.connect(effect);
    }
    audioBuilder.setAudioNode(effect);
    this.setAudioBuilder(audioBuilder);
  }
  _effect() {
    return this.__effect__ = this.__effect__ || this._createEffect();
  }
  _createEffect() {
    return new Distortion/* Distortion */.d({
      distortion: this.pv.distortion,
      oversample: Distortion_OVER_SAMPLE_TYPES[this.pv.oversample]
    });
  }
  static PARAM_CALLBACK_updateEffect(node) {
    node._updateEffect();
  }
  _updateEffect() {
    const effect = this._effect();
    effect.distortion = this.pv.distortion;
    effect.oversample = Distortion_OVER_SAMPLE_TYPES[this.pv.oversample];
  }
}

// EXTERNAL MODULE: ../@polygonjs/polygonjs/node_modules/tone/build/esm/component/analysis/FFT.js
var FFT = __webpack_require__(84052);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/core/Type.ts
var Type = __webpack_require__(19037);
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/audio/_BaseAnalyser.ts


class BaseAnalyserAudioNode extends audio_Base/* TypedAudioNode */.K {
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/core/audio/AudioConversion.ts

function convertFrequencyBandsToOctaveBandsDivisions2(values, target, divisions) {
  const divisionsMult = divisions;
  let octaveIndex = 0;
  let currentOctaveSize = 1;
  const valuesCount = values.length;
  const divideMethod = divisions == 2 ? divideOctave2 : divideOctave4;
  for (let i = 0; i < valuesCount; ) {
    const { octaveIndexTmp } = divideMethod({ values, target, currentOctaveSize, i, octaveIndex, divisionsMult });
    octaveIndex = octaveIndexTmp;
    i += currentOctaveSize;
    currentOctaveSize *= 2;
  }
}
function divideOctave2(params) {
  const { values, target, currentOctaveSize, i, octaveIndex, divisionsMult } = params;
  let octaveIndexTmp = octaveIndex;
  const [valuesCount0, valuesCount1] = octaveSubSizes(currentOctaveSize);
  let currentOctaveStart = 0;
  const sizes = [valuesCount0, valuesCount1];
  for (const size of sizes) {
    let currentOctaveValue = 0;
    for (let j = 0; j < size; j++) {
      const currentIndex = i + j + currentOctaveStart;
      currentOctaveValue += values[currentIndex];
    }
    currentOctaveStart += size;
    target[octaveIndexTmp] = currentOctaveValue * divisionsMult;
    octaveIndexTmp++;
  }
  return { octaveIndexTmp };
}
function octaveSubSizes(currentOctaveSize) {
  const valuesCount0 = Math.max(1, Math.floor(currentOctaveSize / 3));
  const valuesCount1 = currentOctaveSize - valuesCount0;
  return [valuesCount0, valuesCount1];
}
function divideOctave4(params) {
  const { values, target, currentOctaveSize, i, octaveIndex, divisionsMult } = params;
  let octaveIndexTmp = octaveIndex;
  const [valuesCount0, valuesCount1] = octaveSubSizes(currentOctaveSize);
  const [valuesCount00, valuesCount01] = octaveSubSizes(valuesCount0);
  const [valuesCount10, valuesCount11] = octaveSubSizes(valuesCount1);
  let currentOctaveStart = 0;
  const sizes = [valuesCount00, valuesCount01, valuesCount10, valuesCount11];
  for (const size of sizes) {
    let currentOctaveValue = 0;
    for (let j = 0; j < size; j++) {
      const currentIndex = i + j + currentOctaveStart;
      currentOctaveValue += values[currentIndex];
    }
    currentOctaveStart += size;
    target[octaveIndexTmp] = currentOctaveValue * divisionsMult;
    octaveIndexTmp++;
  }
  return { octaveIndexTmp };
}
function convertFrequencyBandsToOctaveBands(values, target) {
  let octaveIndex = 0;
  let currentOctaveSize = 1;
  const valuesCount = values.length;
  for (let i = 0; i < valuesCount; ) {
    let currentOctaveValue = 0;
    for (let j = 0; j < currentOctaveSize; j++) {
      currentOctaveValue += values[i + j];
    }
    target[octaveIndex] = currentOctaveValue;
    i += currentOctaveSize;
    currentOctaveSize *= 2;
    octaveIndex++;
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/audio/FFT.ts

var FFT_defProp = Object.defineProperty;
var FFT_getOwnPropSymbols = Object.getOwnPropertySymbols;
var FFT_hasOwnProp = Object.prototype.hasOwnProperty;
var FFT_propIsEnum = Object.prototype.propertyIsEnumerable;
var FFT_defNormalProp = (obj, key, value) => key in obj ? FFT_defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var FFT_spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (FFT_hasOwnProp.call(b, prop))
      FFT_defNormalProp(a, prop, b[prop]);
  if (FFT_getOwnPropSymbols)
    for (var prop of FFT_getOwnPropSymbols(b)) {
      if (FFT_propIsEnum.call(b, prop))
        FFT_defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var FFT_async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};







const FFT_DEFAULTS = {
  normalRange: false,
  size: 1024,
  smoothing: 0.8
};
const FFT_paramCallback = (node) => {
  FFTAudioNode.PARAM_CALLBACK_updateEffect(node);
};
const RANGE_DEFAULT = [1e4, -1e4];
class FFTAudioParamsConfig extends params_ParamsConfig/* NodeParamsConfig */.yI {
  constructor() {
    super(...arguments);
    /** @param array size will be 2**sizeExponent */
    this.sizeExponent = params_ParamsConfig/* ParamConfig.INTEGER */.XC.INTEGER(10, {
      range: [4, 14],
      rangeLocked: [true, true]
    });
    /** @param array size */
    this.arraySize = params_ParamsConfig/* ParamConfig.INTEGER */.XC.INTEGER(`2**ch('sizeExponent')`, {
      editable: false
    });
    /** @param a value from between 0 and 1 where 0 represents no time averaging with the last analysis frame */
    this.smoothing = params_ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(FFT_DEFAULTS.smoothing, FFT_spreadValues({
      range: [0, 1],
      rangeLocked: [true, true]
    }, (0,EffectsController/* effectParamsOptions */.K)(FFT_paramCallback)));
    /** @param normalizes the output between 0 and 1. The value will be in decibel otherwise. */
    this.normalRange = params_ParamsConfig/* ParamConfig.BOOLEAN */.XC.BOOLEAN(1, (0,EffectsController/* effectParamsOptions */.K)(FFT_paramCallback));
    /** @param groups the FFT frequency bands into octave bands */
    this.asOctaves = params_ParamsConfig/* ParamConfig.BOOLEAN */.XC.BOOLEAN(0, {
      // if cook is false, the materials reading the COP/audioAnalyser
      // do not seem to update the texture when this is changed.
      // I should investigate, as this should not be different than changing normalRange.
      //cook:false,
    });
    this.octaveDivisions = params_ParamsConfig/* ParamConfig.INTEGER */.XC.INTEGER(1, {
      range: [1, 2],
      rangeLocked: [true, true],
      visibleIf: { asOctaves: 1 },
      separatorAfter: true
    });
    /** @param display range param */
    this.updateRangeParam = params_ParamsConfig/* ParamConfig.BOOLEAN */.XC.BOOLEAN(1, {
      cook: false,
      callback: (node) => {
        FFTAudioNode.PARAM_CALLBACK_updateUpdateRangeParam(node);
      }
    });
    /** @param range value */
    this.range = params_ParamsConfig/* ParamConfig.VECTOR2 */.XC.VECTOR2([0, 0], {
      visibleIf: { updateRangeParam: 1 },
      editable: false,
      cook: false
    });
    /** @param accumulated range */
    this.maxRange = params_ParamsConfig/* ParamConfig.VECTOR2 */.XC.VECTOR2(RANGE_DEFAULT, {
      visibleIf: { updateRangeParam: 1 },
      editable: false,
      cook: false
    });
    /** @param resetMaxRange */
    this.resetMaxRange = params_ParamsConfig/* ParamConfig.BUTTON */.XC.BUTTON(null, {
      visibleIf: { updateRangeParam: 1 },
      callback: (node) => {
        FFTAudioNode.PARAM_CALLBACK_resetMaxRange(node);
      }
    });
  }
}
const FFT_ParamsConfig = new FFTAudioParamsConfig();
class FFTAudioNode extends BaseAnalyserAudioNode {
  constructor() {
    super(...arguments);
    this.paramsConfig = FFT_ParamsConfig;
  }
  static type() {
    return poly_NodeContext/* AudioNodeAnalyserType.FFT */.YX.FFT;
  }
  initializeNode() {
    this.io.inputs.setCount(1);
  }
  cook(inputContents) {
    const audioBuilder = inputContents[0];
    this._resetEffect();
    const fft = this._effect();
    this._updateOnTickHook();
    const inputNode = audioBuilder.audioNode();
    if (inputNode) {
      inputNode.connect(fft);
    }
    audioBuilder.setAudioNode(fft);
    this.setAudioBuilder(audioBuilder);
  }
  getAnalyserValue() {
    if (this.__effect__) {
      const fftValues = this.__effect__.getValue();
      if ((0,Type/* isBooleanTrue */.bI)(this.pv.asOctaves)) {
        const octaveValues = this._octaveValues();
        if (this._octaveDivisions() == 1) {
          convertFrequencyBandsToOctaveBands(fftValues, octaveValues);
        } else {
          convertFrequencyBandsToOctaveBandsDivisions2(fftValues, octaveValues, this._octaveDivisions());
        }
        return octaveValues;
      } else {
        return fftValues;
      }
    }
  }
  _octaveDivisions() {
    return 2 ** (this.pv.octaveDivisions - 1);
  }
  _octaveValues() {
    const requiredSize = (0,Type/* isBooleanTrue */.bI)(this.pv.asOctaves) ? this.pv.sizeExponent * this._octaveDivisions() : this.pv.sizeExponent;
    if (this.__octaveValues && this.__octaveValues.length != requiredSize) {
      this.__octaveValues = void 0;
    }
    return this.__octaveValues = this.__octaveValues || new Float32Array(requiredSize);
  }
  _effect() {
    return this.__effect__ = this.__effect__ || this._createEffect();
  }
  _createEffect() {
    return new FFT/* FFT */.v({
      size: this._FFTSize(),
      normalRange: (0,Type/* isBooleanTrue */.bI)(this.pv.normalRange),
      smoothing: this.pv.smoothing
    });
  }
  _resetEffect() {
    if (this.__effect__) {
      this.__effect__.dispose();
      this.__effect__ = void 0;
    }
  }
  static PARAM_CALLBACK_updateEffect(node) {
    node._updateEffect();
  }
  _updateEffect() {
    const effect = this._effect();
    effect.normalRange = (0,Type/* isBooleanTrue */.bI)(this.pv.normalRange);
    effect.smoothing = this.pv.smoothing;
  }
  _FFTSize() {
    return 2 ** this.pv.sizeExponent;
  }
  /*
   * UPDATE RANGE PARAM
   */
  static PARAM_CALLBACK_updateUpdateRangeParam(node) {
    node._updateRangeParam();
    node._updateOnTickHook();
  }
  static PARAM_CALLBACK_resetMaxRange(node) {
    node.p.maxRange.set(RANGE_DEFAULT);
  }
  _updateRangeParam() {
    if (!this.__effect__) {
      return;
    }
    const values = this.getAnalyserValue();
    if (!values) {
      return;
    }
    const min = Math.min(...values);
    const max = Math.max(...values);
    this.p.range.set([min, max]);
    if (min < this.pv.maxRange.x && Type/* CoreType.isNumber */.MR.isNumber(min) && isFinite(min)) {
      this.p.maxRange.x.set(min);
    }
    if (max > this.pv.maxRange.y && Type/* CoreType.isNumber */.MR.isNumber(max) && isFinite(max)) {
      this.p.maxRange.y.set(max);
    }
  }
  /*
   * REGISTER TICK CALLBACK
   */
  _updateOnTickHook() {
    if ((0,Type/* isBooleanTrue */.bI)(this.pv.updateRangeParam)) {
      this._registerOnTickHook();
    } else {
      this._unRegisterOnTickHook();
    }
  }
  _registerOnTickHook() {
    return FFT_async(this, null, function* () {
      if (this.scene().registeredBeforeTickCallbacks().has(this._tickCallbackName())) {
        return;
      }
      this.scene().registerOnBeforeTick(this._tickCallbackName(), this._updateRangeParam.bind(this));
    });
  }
  _unRegisterOnTickHook() {
    return FFT_async(this, null, function* () {
      this.scene().unRegisterOnBeforeTick(this._tickCallbackName());
    });
  }
  _tickCallbackName() {
    return `audio/FFT-${this.graphNodeId()}`;
  }
}

// EXTERNAL MODULE: ../@polygonjs/polygonjs/node_modules/tone/build/esm/instrument/FMSynth.js
var FMSynth = __webpack_require__(62364);
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/audio/FMSynth.ts







class FMSynthAudioParamsConfig extends params_ParamsConfig/* NodeParamsConfig */.yI {
}
const FMSynth_ParamsConfig = new FMSynthAudioParamsConfig();
class FMSynthAudioNode extends audio_Base/* TypedAudioNode */.K {
  constructor() {
    super(...arguments);
    this.paramsConfig = FMSynth_ParamsConfig;
  }
  static type() {
    return Audio/* AudioType.FM_SYNTH */.w.FM_SYNTH;
  }
  initializeNode() {
    this.io.inputs.setCount(0, 1);
  }
  cook(inputContents) {
    const envelopeBuilder = inputContents[0];
    const envelopeParams = envelopeBuilder.envelopeParams() || ENVELOPE_DEFAULTS;
    const synth = new FMSynth/* FMSynth */.t({
      modulationIndex: 12.22,
      envelope: envelopeParams,
      modulation: {
        type: "square"
      },
      modulationEnvelope: {
        attack: 0.2,
        decay: 0.01
      }
    });
    const audioBuilder = new AudioBuilder/* AudioBuilder */.y();
    audioBuilder.setInstrument(synth);
    this.setAudioBuilder(audioBuilder);
  }
}

// EXTERNAL MODULE: ../@polygonjs/polygonjs/node_modules/tone/build/esm/effect/FeedbackDelay.js
var FeedbackDelay = __webpack_require__(29647);
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/audio/FeedbackDelay.ts


const FeedbackDelay_DEFAULTS = {
  delayTime: 0.25,
  feedback: 0.125,
  maxDelay: 1
  // wet: 1,
};


class FeedbackDelayAudioParamsConfig extends params_ParamsConfig/* NodeParamsConfig */.yI {
  constructor() {
    super(...arguments);
    /** @param delayTime */
    this.delayTime = params_ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(FeedbackDelay_DEFAULTS.delayTime, {
      range: [0, 1],
      rangeLocked: [true, false]
    });
    /** @param maxDelay */
    this.maxDelay = params_ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(FeedbackDelay_DEFAULTS.maxDelay, {
      range: [0, 1],
      rangeLocked: [true, false]
    });
    /** @param feedback */
    this.feedback = params_ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(FeedbackDelay_DEFAULTS.feedback, {
      range: [0, 1],
      rangeLocked: [true, false]
    });
  }
}
const FeedbackDelay_ParamsConfig = new FeedbackDelayAudioParamsConfig();
class FeedbackDelayAudioNode extends audio_Base/* TypedAudioNode */.K {
  constructor() {
    super(...arguments);
    this.paramsConfig = FeedbackDelay_ParamsConfig;
  }
  static type() {
    return "feedbackDelay";
  }
  initializeNode() {
    this.io.inputs.setCount(1);
  }
  cook(inputContents) {
    const audioBuilder = inputContents[0];
    const effect = new FeedbackDelay/* FeedbackDelay */.w({
      delayTime: this.pv.delayTime,
      maxDelay: this.pv.maxDelay,
      feedback: this.pv.feedback
    });
    const inputNode = audioBuilder.audioNode();
    if (inputNode) {
      inputNode.connect(effect);
    }
    audioBuilder.setAudioNode(effect);
    this.setAudioBuilder(audioBuilder);
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/audio/Fetch.ts

var Fetch_async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};



class FetchAudioParamsConfig extends params_ParamsConfig/* NodeParamsConfig */.yI {
  constructor() {
    super(...arguments);
    /** @param which node to import */
    this.audioNode = params_ParamsConfig/* ParamConfig.NODE_PATH */.XC.NODE_PATH("");
  }
}
const Fetch_ParamsConfig = new FetchAudioParamsConfig();
class FetchAudioNode extends audio_Base/* TypedAudioNode */.K {
  constructor() {
    super(...arguments);
    this.paramsConfig = Fetch_ParamsConfig;
  }
  static type() {
    return "fetch";
  }
  initializeNode() {
    this.io.inputs.setCount(0);
  }
  cook(inputContents) {
    return Fetch_async(this, null, function* () {
      const baseAudioNode = this.pv.audioNode.nodeWithContext(poly_NodeContext/* NodeContext.AUDIO */.sy.AUDIO);
      if (!baseAudioNode) {
        this.states.error.set("no audio node found");
        return;
      }
      const audioContainer = yield baseAudioNode.compute();
      const audioBuilder = audioContainer.coreContentCloned();
      if (!audioBuilder) {
        this.states.error.set("invalid audio node");
        return;
      }
      this.setAudioBuilder(audioBuilder);
    });
  }
}

// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/nodes/audio/File.ts
var File = __webpack_require__(36815);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/node_modules/tone/build/esm/effect/FrequencyShifter.js + 1 modules
var FrequencyShifter = __webpack_require__(61715);
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/audio/FrequencyShifter.ts


const FrequencyShifter_DEFAULTS = { frequency: 0 };


class FrequencyShifterAudioParamsConfig extends params_ParamsConfig/* NodeParamsConfig */.yI {
  constructor() {
    super(...arguments);
    /** @param frequency */
    this.frequency = params_ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(FrequencyShifter_DEFAULTS.frequency, {
      range: [0, 100],
      rangeLocked: [true, false]
    });
  }
}
const FrequencyShifter_ParamsConfig = new FrequencyShifterAudioParamsConfig();
class FrequencyShifterAudioNode extends audio_Base/* TypedAudioNode */.K {
  constructor() {
    super(...arguments);
    this.paramsConfig = FrequencyShifter_ParamsConfig;
  }
  static type() {
    return "frequencyShifter";
  }
  initializeNode() {
    this.io.inputs.setCount(1);
  }
  cook(inputContents) {
    const audioBuilder = inputContents[0];
    const effect = new FrequencyShifter/* FrequencyShifter */.b({
      frequency: this.pv.frequency
    });
    const inputNode = audioBuilder.audioNode();
    if (inputNode) {
      inputNode.connect(effect);
    }
    audioBuilder.setAudioNode(effect);
    this.setAudioBuilder(audioBuilder);
  }
}

// EXTERNAL MODULE: ../@polygonjs/polygonjs/node_modules/tone/build/esm/component/analysis/Meter.js
var Meter = __webpack_require__(10282);
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/audio/Meter.ts

var Meter_defProp = Object.defineProperty;
var Meter_getOwnPropSymbols = Object.getOwnPropertySymbols;
var Meter_hasOwnProp = Object.prototype.hasOwnProperty;
var Meter_propIsEnum = Object.prototype.propertyIsEnumerable;
var Meter_defNormalProp = (obj, key, value) => key in obj ? Meter_defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var Meter_spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (Meter_hasOwnProp.call(b, prop))
      Meter_defNormalProp(a, prop, b[prop]);
  if (Meter_getOwnPropSymbols)
    for (var prop of Meter_getOwnPropSymbols(b)) {
      if (Meter_propIsEnum.call(b, prop))
        Meter_defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var Meter_async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};






const Meter_DEFAULTS = {
  smoothing: 0.8
};
const Meter_paramCallback = (node) => {
  MeterAudioNode.PARAM_CALLBACK_updateEffect(node);
};
const Meter_RANGE_DEFAULT = [1e4, -1e4];
class MeterAudioParamsConfig extends params_ParamsConfig/* NodeParamsConfig */.yI {
  constructor() {
    super(...arguments);
    /** @param a value from between 0 and 1 where 0 represents no time averaging with the last analysis frame */
    this.smoothing = params_ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(Meter_DEFAULTS.smoothing, Meter_spreadValues({
      range: [0, 1],
      rangeLocked: [true, true]
    }, (0,EffectsController/* effectParamsOptions */.K)(Meter_paramCallback)));
    /** @param normalizes the output between 0 and 1. The value will be in decibel otherwise. */
    this.normalRange = params_ParamsConfig/* ParamConfig.BOOLEAN */.XC.BOOLEAN(1, (0,EffectsController/* effectParamsOptions */.K)(Meter_paramCallback));
    /** @param display meter param */
    this.updateValueParam = params_ParamsConfig/* ParamConfig.BOOLEAN */.XC.BOOLEAN(1, {
      cook: false,
      callback: (node) => {
        MeterAudioNode.PARAM_CALLBACK_updateUpdateMeterParam(node);
      }
    });
    /** @param meter value */
    this.value = params_ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(0, {
      visibleIf: { updateValueParam: 1 },
      range: [-100, 100],
      editable: false,
      cook: false
    });
    /** @param display meter param */
    this.updateRangeParam = params_ParamsConfig/* ParamConfig.BOOLEAN */.XC.BOOLEAN(1, {
      cook: false,
      callback: (node) => {
        MeterAudioNode.PARAM_CALLBACK_updateUpdateMeterParam(node);
      }
    });
    /** @param accumulated range */
    this.maxRange = params_ParamsConfig/* ParamConfig.VECTOR2 */.XC.VECTOR2([1e4, -1e4], {
      visibleIf: { updateRangeParam: 1 },
      editable: false,
      cook: false
    });
    /** @param resetMaxRange */
    this.resetMaxRange = params_ParamsConfig/* ParamConfig.BUTTON */.XC.BUTTON(null, {
      visibleIf: { updateRangeParam: 1 },
      callback: (node) => {
        MeterAudioNode.PARAM_CALLBACK_resetMaxRange(node);
      }
    });
  }
}
const Meter_ParamsConfig = new MeterAudioParamsConfig();
class MeterAudioNode extends BaseAnalyserAudioNode {
  constructor() {
    super(...arguments);
    this.paramsConfig = Meter_ParamsConfig;
    this._arrayValue = new Float32Array(1);
  }
  static type() {
    return poly_NodeContext/* AudioNodeAnalyserType.METER */.YX.METER;
  }
  initializeNode() {
    this.io.inputs.setCount(1);
  }
  cook(inputContents) {
    const audioBuilder = inputContents[0];
    this._resetEffect();
    const meter = this._effect();
    this._updateOnTickHook();
    const inputNode = audioBuilder.audioNode();
    if (inputNode) {
      inputNode.connect(meter);
    }
    audioBuilder.setAudioNode(meter);
    this.setAudioBuilder(audioBuilder);
  }
  getAnalyserValue() {
    if (this.__effect__) {
      const value = this.__effect__.getValue();
      if (Type/* CoreType.isNumber */.MR.isNumber(value)) {
        this._arrayValue[0] = value;
        return this._arrayValue;
      } else {
        return value;
      }
    }
  }
  _effect() {
    return this.__effect__ = this.__effect__ || this._createEffect();
  }
  _createEffect() {
    return new Meter/* Meter */.Y({
      smoothing: this.pv.smoothing,
      normalRange: (0,Type/* isBooleanTrue */.bI)(this.pv.normalRange)
    });
  }
  _resetEffect() {
    if (this.__effect__) {
      this.__effect__.dispose();
      this.__effect__ = void 0;
    }
  }
  static PARAM_CALLBACK_updateEffect(node) {
    node._updateEffect();
  }
  _updateEffect() {
    const effect = this._effect();
    effect.normalRange = (0,Type/* isBooleanTrue */.bI)(this.pv.normalRange);
    effect.smoothing = this.pv.smoothing;
  }
  /*
   * UPDATE METER PARAM
   */
  static PARAM_CALLBACK_updateUpdateMeterParam(node) {
    node._updateMeterParam();
    node._updateOnTickHook();
  }
  static PARAM_CALLBACK_resetMaxRange(node) {
    node.p.maxRange.set(Meter_RANGE_DEFAULT);
  }
  _updateMeterParam() {
    if (!this.__effect__) {
      return;
    }
    const value = this.getAnalyserValue();
    if (!value) {
      return;
    }
    const valueN = value[0];
    if (!isFinite(valueN)) {
      return;
    }
    if ((0,Type/* isBooleanTrue */.bI)(this.pv.updateValueParam)) {
      if (Type/* CoreType.isNumber */.MR.isNumber(valueN)) {
        this.p.value.set(valueN);
      }
    }
    if ((0,Type/* isBooleanTrue */.bI)(this.pv.updateRangeParam)) {
      const newVal = valueN;
      if (newVal < this.pv.maxRange.x) {
        this.p.maxRange.x.set(newVal);
      } else {
        if (newVal > this.pv.maxRange.y) {
          this.p.maxRange.y.set(newVal);
        }
      }
    }
  }
  /*
   * REGISTER TICK CALLBACK
   */
  _updateOnTickHook() {
    if ((0,Type/* isBooleanTrue */.bI)(this.pv.updateValueParam) || (0,Type/* isBooleanTrue */.bI)(this.pv.updateRangeParam)) {
      this._registerOnTickHook();
    } else {
      this._unRegisterOnTickHook();
    }
  }
  _registerOnTickHook() {
    return Meter_async(this, null, function* () {
      if (this.scene().registeredBeforeTickCallbacks().has(this._tickCallbackName())) {
        return;
      }
      this.scene().registerOnBeforeTick(this._tickCallbackName(), this._updateMeterParam.bind(this));
    });
  }
  _unRegisterOnTickHook() {
    return Meter_async(this, null, function* () {
      this.scene().unRegisterOnBeforeTick(this._tickCallbackName());
    });
  }
  _tickCallbackName() {
    return `audio/Meter-${this.graphNodeId()}`;
  }
}

// EXTERNAL MODULE: ../@polygonjs/polygonjs/node_modules/tone/build/esm/instrument/MonoSynth.js + 1 modules
var MonoSynth = __webpack_require__(82486);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/node_modules/tone/build/esm/instrument/PolySynth.js + 1 modules
var PolySynth = __webpack_require__(10202);
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/audio/MonoSynth.ts








class MonoSynthAudioParamsConfig extends params_ParamsConfig/* NodeParamsConfig */.yI {
}
const MonoSynth_ParamsConfig = new MonoSynthAudioParamsConfig();
class MonoSynthAudioNode extends audio_Base/* TypedAudioNode */.K {
  constructor() {
    super(...arguments);
    this.paramsConfig = MonoSynth_ParamsConfig;
  }
  static type() {
    return Audio/* AudioType.MONO_SYNTH */.w.MONO_SYNTH;
  }
  initializeNode() {
    this.io.inputs.setCount(0, 1);
  }
  cook(inputContents) {
    const envelopeBuilder = inputContents[0];
    const envelopeParams = envelopeBuilder.envelopeParams() || ENVELOPE_DEFAULTS;
    const synth = new PolySynth/* PolySynth */.v(MonoSynth/* MonoSynth */.o, {
      volume: -8,
      oscillator: {
        type: "square8"
      },
      envelope: envelopeParams,
      filterEnvelope: {
        attack: 1e-3,
        decay: 0.7,
        sustain: 0.1,
        release: 0.8,
        baseFrequency: 300,
        octaves: 4
      }
    });
    const audioBuilder = new AudioBuilder/* AudioBuilder */.y();
    audioBuilder.setInstrument(synth);
    this.setAudioBuilder(audioBuilder);
  }
}

// EXTERNAL MODULE: ../@polygonjs/polygonjs/node_modules/tone/build/esm/source/Noise.js
var Noise = __webpack_require__(87321);
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/audio/Noise.ts

var Noise_defProp = Object.defineProperty;
var Noise_getOwnPropSymbols = Object.getOwnPropertySymbols;
var Noise_hasOwnProp = Object.prototype.hasOwnProperty;
var Noise_propIsEnum = Object.prototype.propertyIsEnumerable;
var Noise_defNormalProp = (obj, key, value) => key in obj ? Noise_defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var Noise_spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (Noise_hasOwnProp.call(b, prop))
      Noise_defNormalProp(a, prop, b[prop]);
  if (Noise_getOwnPropSymbols)
    for (var prop of Noise_getOwnPropSymbols(b)) {
      if (Noise_propIsEnum.call(b, prop))
        Noise_defNormalProp(a, prop, b[prop]);
    }
  return a;
};






const NOISE_TYPES = ["white", "brown", "pink"];
const NOISE_DEFAULTS = {
  fadeIn: 0,
  fadeOut: 0,
  mute: false,
  playbackRate: 1
  // type: "white",
  // volume: 0,
};
const Noise_paramCallback = (node) => {
  NoiseAudioNode.PARAM_CALLBACK_updateNoise(node);
};
class NoiseAudioParamsConfig extends params_ParamsConfig/* NodeParamsConfig */.yI {
  constructor() {
    super(...arguments);
    /** @param Noise type */
    this.type = params_ParamsConfig/* ParamConfig.INTEGER */.XC.INTEGER(0, Noise_spreadValues({
      menu: {
        entries: NOISE_TYPES.map((name, value) => ({ name, value }))
      }
    }, (0,EffectsController/* effectParamsOptions */.K)(Noise_paramCallback)));
    /** playbackRate */
    this.playbackRate = params_ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(NOISE_DEFAULTS.playbackRate, Noise_spreadValues({
      range: [0, 1],
      rangeLocked: [true, false]
    }, (0,EffectsController/* effectParamsOptions */.K)(Noise_paramCallback)));
    /** fadeIn */
    this.fadeIn = params_ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(NOISE_DEFAULTS.fadeIn, Noise_spreadValues({
      range: [0, 1],
      rangeLocked: [true, false]
    }, (0,EffectsController/* effectParamsOptions */.K)(Noise_paramCallback)));
    /** fadeOut */
    this.fadeOut = params_ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(NOISE_DEFAULTS.fadeOut, {
      range: [0, 1],
      rangeLocked: [true, false]
    });
    /** play */
    this.play = params_ParamsConfig/* ParamConfig.BOOLEAN */.XC.BOOLEAN(1, (0,EffectsController/* effectParamsOptions */.K)(Noise_paramCallback));
  }
}
const Noise_ParamsConfig = new NoiseAudioParamsConfig();
class NoiseAudioNode extends audio_Base/* TypedAudioNode */.K {
  constructor() {
    super(...arguments);
    this.paramsConfig = Noise_ParamsConfig;
  }
  static type() {
    return "noise";
  }
  initializeNode() {
    this.io.inputs.setCount(0);
  }
  cook(inputContents) {
    const noise = this._noise();
    this._updateNoise();
    const audioBuilder = new AudioBuilder/* AudioBuilder */.y();
    audioBuilder.setSource(noise);
    this.setAudioBuilder(audioBuilder);
  }
  _noise() {
    return this.__noise__ = this.__noise__ || this._createEffect();
  }
  _createEffect() {
    return new Noise/* Noise */.c({
      type: NOISE_TYPES[this.pv.type],
      playbackRate: this.pv.playbackRate,
      fadeIn: this.pv.fadeIn,
      fadeOut: this.pv.fadeOut
    });
  }
  static PARAM_CALLBACK_updateNoise(node) {
    node._updateNoise();
  }
  _updateNoise() {
    const noise = this._noise();
    noise.type = NOISE_TYPES[this.pv.type];
    noise.playbackRate = this.pv.playbackRate;
    noise.fadeIn = this.pv.fadeIn;
    noise.fadeOut = this.pv.fadeOut;
    if ((0,Type/* isBooleanTrue */.bI)(this.pv.play)) {
      noise.start();
    } else {
      noise.stop();
    }
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/audio/Null.ts



class NullAudioParamsConfig extends params_ParamsConfig/* NodeParamsConfig */.yI {
}
const Null_ParamsConfig = new NullAudioParamsConfig();
class NullAudioNode extends audio_Base/* TypedAudioNode */.K {
  constructor() {
    super(...arguments);
    this.paramsConfig = Null_ParamsConfig;
  }
  static type() {
    return "null";
  }
  initializeNode() {
    this.io.inputs.setCount(1);
  }
  cook(inputContents) {
    const audioBuilder = inputContents[0];
    this.setAudioBuilder(audioBuilder);
  }
}

// EXTERNAL MODULE: ../@polygonjs/polygonjs/node_modules/tone/build/esm/effect/Phaser.js
var Phaser = __webpack_require__(71919);
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/audio/Phaser.ts

var Phaser_defProp = Object.defineProperty;
var Phaser_getOwnPropSymbols = Object.getOwnPropertySymbols;
var Phaser_hasOwnProp = Object.prototype.hasOwnProperty;
var Phaser_propIsEnum = Object.prototype.propertyIsEnumerable;
var Phaser_defNormalProp = (obj, key, value) => key in obj ? Phaser_defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var Phaser_spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (Phaser_hasOwnProp.call(b, prop))
      Phaser_defNormalProp(a, prop, b[prop]);
  if (Phaser_getOwnPropSymbols)
    for (var prop of Phaser_getOwnPropSymbols(b)) {
      if (Phaser_propIsEnum.call(b, prop))
        Phaser_defNormalProp(a, prop, b[prop]);
    }
  return a;
};

const Phaser_DEFAULTS = {
  Q: 10,
  baseFrequency: 350,
  frequency: 0.5,
  octaves: 3,
  stages: 10
};



const Phaser_paramCallback = (node) => {
  PhaserAudioNode.PARAM_CALLBACK_updateEffect(node);
};
class PhaserAudioParamsConfig extends params_ParamsConfig/* NodeParamsConfig */.yI {
  constructor() {
    super(...arguments);
    /** @param frequency */
    this.frequency = params_ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(Phaser_DEFAULTS.frequency, {
      range: [0, 1e3],
      rangeLocked: [true, false]
    });
    /** @param baseFrequency */
    this.baseFrequency = params_ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(Phaser_DEFAULTS.baseFrequency, Phaser_spreadValues({
      range: [0, 1e3],
      rangeLocked: [true, false]
    }, (0,EffectsController/* effectParamsOptions */.K)(Phaser_paramCallback)));
    /** @param octaves */
    this.octaves = params_ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(Phaser_DEFAULTS.octaves, Phaser_spreadValues({
      range: [0, 10],
      rangeLocked: [true, false]
    }, (0,EffectsController/* effectParamsOptions */.K)(Phaser_paramCallback)));
    /** @param sensitivity */
    this.stages = params_ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(Phaser_DEFAULTS.stages, {
      range: [0, 1],
      rangeLocked: [true, false]
    });
    /** @param Q */
    this.Q = params_ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(Phaser_DEFAULTS.Q, {
      range: [0, 1],
      rangeLocked: [true, false]
    });
  }
}
const Phaser_ParamsConfig = new PhaserAudioParamsConfig();
class PhaserAudioNode extends audio_Base/* TypedAudioNode */.K {
  constructor() {
    super(...arguments);
    this.paramsConfig = Phaser_ParamsConfig;
  }
  static type() {
    return "phaser";
  }
  initializeNode() {
    this.io.inputs.setCount(1);
  }
  cook(inputContents) {
    const audioBuilder = inputContents[0];
    this._resetEffect();
    const effect = this._effect();
    const inputNode = audioBuilder.audioNode();
    if (inputNode) {
      inputNode.connect(effect);
    }
    audioBuilder.setAudioNode(effect);
    this.setAudioBuilder(audioBuilder);
  }
  _effect() {
    return this.__effect__ = this.__effect__ || this._createEffect();
  }
  _createEffect() {
    return new Phaser/* Phaser */.l({
      frequency: this.pv.frequency,
      baseFrequency: this.pv.baseFrequency,
      octaves: this.pv.octaves,
      stages: this.pv.stages,
      Q: this.pv.Q
    });
  }
  _resetEffect() {
    if (this.__effect__) {
      this.__effect__.dispose();
      this.__effect__ = void 0;
    }
  }
  static PARAM_CALLBACK_updateEffect(node) {
    node._updateEffect();
  }
  _updateEffect() {
    const effect = this._effect();
    effect.baseFrequency = this.pv.baseFrequency;
    effect.octaves = this.pv.octaves;
  }
}

// EXTERNAL MODULE: ../@polygonjs/polygonjs/node_modules/tone/build/esm/effect/PingPongDelay.js + 1 modules
var PingPongDelay = __webpack_require__(16747);
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/audio/PingPongDelay.ts


const PingPongDelay_DEFAULTS = {
  delayTime: 0.25,
  // feedback: 0.5,
  maxDelay: 1
};


class PingPongDelayAudioParamsConfig extends params_ParamsConfig/* NodeParamsConfig */.yI {
  constructor() {
    super(...arguments);
    /** @param delayTime */
    this.delayTime = params_ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(PingPongDelay_DEFAULTS.delayTime, {
      range: [0, 1],
      rangeLocked: [true, false]
    });
    /** @param maxDelay */
    this.maxDelay = params_ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(PingPongDelay_DEFAULTS.maxDelay, {
      range: [0, 1],
      rangeLocked: [true, false]
    });
  }
}
const PingPongDelay_ParamsConfig = new PingPongDelayAudioParamsConfig();
class PingPongDelayAudioNode extends audio_Base/* TypedAudioNode */.K {
  constructor() {
    super(...arguments);
    this.paramsConfig = PingPongDelay_ParamsConfig;
  }
  static type() {
    return "pingPongDelay";
  }
  initializeNode() {
    this.io.inputs.setCount(1);
  }
  cook(inputContents) {
    const audioBuilder = inputContents[0];
    const effect = this._createEffect();
    const inputNode = audioBuilder.audioNode();
    if (inputNode) {
      inputNode.connect(effect);
    }
    audioBuilder.setAudioNode(effect);
    this.setAudioBuilder(audioBuilder);
  }
  _createEffect() {
    return new PingPongDelay/* PingPongDelay */.D({
      delayTime: this.pv.delayTime,
      maxDelay: this.pv.maxDelay
    });
  }
}

// EXTERNAL MODULE: ../@polygonjs/polygonjs/node_modules/tone/build/esm/effect/PitchShift.js
var PitchShift = __webpack_require__(46265);
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/audio/PitchShift.ts

var PitchShift_defProp = Object.defineProperty;
var PitchShift_getOwnPropSymbols = Object.getOwnPropertySymbols;
var PitchShift_hasOwnProp = Object.prototype.hasOwnProperty;
var PitchShift_propIsEnum = Object.prototype.propertyIsEnumerable;
var PitchShift_defNormalProp = (obj, key, value) => key in obj ? PitchShift_defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var PitchShift_spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (PitchShift_hasOwnProp.call(b, prop))
      PitchShift_defNormalProp(a, prop, b[prop]);
  if (PitchShift_getOwnPropSymbols)
    for (var prop of PitchShift_getOwnPropSymbols(b)) {
      if (PitchShift_propIsEnum.call(b, prop))
        PitchShift_defNormalProp(a, prop, b[prop]);
    }
  return a;
};

const PitchShift_DEFAULTS = {
  // 	delayTime: 0,
  // feedback: 0,
  pitch: 0
};



const PitchShift_paramCallback = (node) => {
  PitchShiftAudioNode.PARAM_CALLBACK_updateEffect(node);
};
class PitchShiftAudioParamsConfig extends params_ParamsConfig/* NodeParamsConfig */.yI {
  constructor() {
    super(...arguments);
    /** @param The interval to transpose the incoming signal by */
    this.pitch = params_ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(PitchShift_DEFAULTS.pitch, PitchShift_spreadValues({
      range: [-10, 10],
      rangeLocked: [false, false]
    }, (0,EffectsController/* effectParamsOptions */.K)(PitchShift_paramCallback)));
  }
}
const PitchShift_ParamsConfig = new PitchShiftAudioParamsConfig();
class PitchShiftAudioNode extends audio_Base/* TypedAudioNode */.K {
  constructor() {
    super(...arguments);
    this.paramsConfig = PitchShift_ParamsConfig;
  }
  static type() {
    return "pitchShift";
  }
  initializeNode() {
    this.io.inputs.setCount(1);
  }
  cook(inputContents) {
    const audioBuilder = inputContents[0];
    const effect = this._effect();
    const inputNode = audioBuilder.audioNode();
    if (inputNode) {
      inputNode.connect(effect);
    }
    audioBuilder.setAudioNode(effect);
    this.setAudioBuilder(audioBuilder);
  }
  _effect() {
    return this.__effect__ = this.__effect__ || this._createEffect();
  }
  _createEffect() {
    return new PitchShift/* PitchShift */.y(this.pv.pitch);
  }
  static PARAM_CALLBACK_updateEffect(node) {
    node._updateEffect();
  }
  _updateEffect() {
    const effect = this._effect();
    effect.pitch = this.pv.pitch;
  }
}

// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/nodes/audio/PlayInstrument.ts
var PlayInstrument = __webpack_require__(62262);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/node_modules/tone/build/esm/instrument/Synth.js
var Synth = __webpack_require__(14313);
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/audio/PolySynth.ts







class PolySynthAudioParamsConfig extends params_ParamsConfig/* NodeParamsConfig */.yI {
}
const PolySynth_ParamsConfig = new PolySynthAudioParamsConfig();
class PolySynthAudioNode extends audio_Base/* TypedAudioNode */.K {
  constructor() {
    super(...arguments);
    this.paramsConfig = PolySynth_ParamsConfig;
  }
  static type() {
    return Audio/* AudioType.POLY_SYNTH */.w.POLY_SYNTH;
  }
  initializeNode() {
    this.io.inputs.setCount(0);
  }
  cook(inputContents) {
    const synth = new PolySynth/* PolySynth */.v(Synth/* Synth */.W, {
      oscillator: {
        partials: [0, 2, 3, 4]
      }
    });
    const audioBuilder = new AudioBuilder/* AudioBuilder */.y();
    audioBuilder.setInstrument(synth);
    this.setAudioBuilder(audioBuilder);
  }
}

// EXTERNAL MODULE: ../@polygonjs/polygonjs/node_modules/tone/build/esm/effect/Reverb.js
var Reverb = __webpack_require__(76349);
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/audio/Reverb.ts

var Reverb_defProp = Object.defineProperty;
var Reverb_getOwnPropSymbols = Object.getOwnPropertySymbols;
var Reverb_hasOwnProp = Object.prototype.hasOwnProperty;
var Reverb_propIsEnum = Object.prototype.propertyIsEnumerable;
var Reverb_defNormalProp = (obj, key, value) => key in obj ? Reverb_defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var Reverb_spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (Reverb_hasOwnProp.call(b, prop))
      Reverb_defNormalProp(a, prop, b[prop]);
  if (Reverb_getOwnPropSymbols)
    for (var prop of Reverb_getOwnPropSymbols(b)) {
      if (Reverb_propIsEnum.call(b, prop))
        Reverb_defNormalProp(a, prop, b[prop]);
    }
  return a;
};

const Reverb_DEFAULTS = {
  decay: 1.5,
  preDelay: 0.01
};



const Reverb_paramCallback = (node) => {
  ReverbAudioNode.PARAM_CALLBACK_updateEffect(node);
};
class ReverbAudioParamsConfig extends params_ParamsConfig/* NodeParamsConfig */.yI {
  constructor() {
    super(...arguments);
    /** @param The duration of the reverb. */
    this.decay = params_ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(Reverb_DEFAULTS.decay, Reverb_spreadValues({
      range: [1e-3, 10],
      rangeLocked: [true, false]
    }, (0,EffectsController/* effectParamsOptions */.K)(Reverb_paramCallback)));
    /** The amount of time before the reverb is fully ramped in */
    this.preDelay = params_ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(Reverb_DEFAULTS.preDelay, Reverb_spreadValues({
      range: [0, 1],
      rangeLocked: [true, false]
    }, (0,EffectsController/* effectParamsOptions */.K)(Reverb_paramCallback)));
  }
}
const Reverb_ParamsConfig = new ReverbAudioParamsConfig();
class ReverbAudioNode extends audio_Base/* TypedAudioNode */.K {
  constructor() {
    super(...arguments);
    this.paramsConfig = Reverb_ParamsConfig;
  }
  static type() {
    return "reverb";
  }
  initializeNode() {
    this.io.inputs.setCount(1);
  }
  cook(inputContents) {
    const audioBuilder = inputContents[0];
    const effect = this._effect();
    const inputNode = audioBuilder.audioNode();
    if (inputNode) {
      inputNode.connect(effect);
    }
    audioBuilder.setAudioNode(effect);
    this.setAudioBuilder(audioBuilder);
  }
  _effect() {
    return this.__effect__ = this.__effect__ || this._createEffect();
  }
  _createEffect() {
    return new Reverb/* Reverb */.E({
      decay: this.pv.decay,
      preDelay: this.pv.preDelay
    });
  }
  static PARAM_CALLBACK_updateEffect(node) {
    node._updateEffect();
  }
  _updateEffect() {
    const effect = this._effect();
    effect.decay = this.pv.decay;
    effect.preDelay = this.pv.preDelay;
  }
}

// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/nodes/audio/Sampler.ts + 2 modules
var Sampler = __webpack_require__(44342);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/node_modules/tone/build/esm/effect/StereoWidener.js + 4 modules
var StereoWidener = __webpack_require__(72912);
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/audio/StereoWidener.ts


const StereoWidener_DEFAULTS = { width: 0.5 };


class StereoWidenerAudioParamsConfig extends params_ParamsConfig/* NodeParamsConfig */.yI {
  constructor() {
    super(...arguments);
    /** @param width */
    this.width = params_ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(StereoWidener_DEFAULTS.width, {
      range: [0, 1],
      rangeLocked: [true, true]
    });
  }
}
const StereoWidener_ParamsConfig = new StereoWidenerAudioParamsConfig();
class StereoWidenerAudioNode extends audio_Base/* TypedAudioNode */.K {
  constructor() {
    super(...arguments);
    this.paramsConfig = StereoWidener_ParamsConfig;
  }
  static type() {
    return "stereoWidener";
  }
  initializeNode() {
    this.io.inputs.setCount(1);
  }
  cook(inputContents) {
    const audioBuilder = inputContents[0];
    const effect = new StereoWidener/* StereoWidener */.Z(this.pv.width);
    const inputNode = audioBuilder.audioNode();
    if (inputNode) {
      inputNode.connect(effect);
    }
    audioBuilder.setAudioNode(effect);
    this.setAudioBuilder(audioBuilder);
  }
}

// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/nodes/audio/Switch.ts
var Switch = __webpack_require__(89755);
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/audio/Synth.ts







const SYNTH_DEFAULTS = {
  detune: 0,
  portamento: 0
};
class SynthAudioParamsConfig extends params_ParamsConfig/* NodeParamsConfig */.yI {
  constructor() {
    super(...arguments);
    /** @param The glide time between notes. */
    this.portamento = params_ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(SYNTH_DEFAULTS.portamento, {
      range: [0, 1],
      rangeLocked: [true, false]
    });
  }
}
const Synth_ParamsConfig = new SynthAudioParamsConfig();
class SynthAudioNode extends audio_Base/* TypedAudioNode */.K {
  constructor() {
    super(...arguments);
    this.paramsConfig = Synth_ParamsConfig;
  }
  static type() {
    return Audio/* AudioType.SYNTH */.w.SYNTH;
  }
  initializeNode() {
    this.io.inputs.setCount(0, 1);
  }
  cook(inputContents) {
    const envelopeBuilder = inputContents[0];
    const envelopeParams = envelopeBuilder.envelopeParams() || ENVELOPE_DEFAULTS;
    const synth = new Synth/* Synth */.W({
      volume: 0,
      oscillator: {
        type: "amtriangle",
        harmonicity: 0.5,
        modulationType: "sine"
      },
      envelope: envelopeParams,
      portamento: this.pv.portamento
    });
    const audioBuilder = new AudioBuilder/* AudioBuilder */.y();
    audioBuilder.setInstrument(synth);
    this.setAudioBuilder(audioBuilder);
  }
}

// EXTERNAL MODULE: ../@polygonjs/polygonjs/node_modules/tone/build/esm/effect/Tremolo.js
var Tremolo = __webpack_require__(42680);
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/audio/Tremolo.ts


const Tremolo_DEFAULTS = {
  depth: 0.5,
  frequency: 10,
  spread: 180
  // type: "sine"
};


class TremoloAudioParamsConfig extends params_ParamsConfig/* NodeParamsConfig */.yI {
  constructor() {
    super(...arguments);
    /** @param frequency */
    this.frequency = params_ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(Tremolo_DEFAULTS.frequency, {
      range: [0, 1e3],
      rangeLocked: [true, false]
    });
    /** @param depth */
    this.depth = params_ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(Tremolo_DEFAULTS.depth, {
      range: [0, 1],
      rangeLocked: [true, true]
    });
    /** @param spread (degrees) */
    this.spread = params_ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(Tremolo_DEFAULTS.spread, {
      range: [-180, 180],
      rangeLocked: [true, true]
    });
  }
}
const Tremolo_ParamsConfig = new TremoloAudioParamsConfig();
class TremoloAudioNode extends audio_Base/* TypedAudioNode */.K {
  constructor() {
    super(...arguments);
    this.paramsConfig = Tremolo_ParamsConfig;
  }
  static type() {
    return "tremolo";
  }
  initializeNode() {
    this.io.inputs.setCount(1);
  }
  cook(inputContents) {
    const audioBuilder = inputContents[0];
    const effect = this._createEffect();
    const inputNode = audioBuilder.audioNode();
    if (inputNode) {
      inputNode.connect(effect);
    }
    audioBuilder.setAudioNode(effect);
    this.setAudioBuilder(audioBuilder);
  }
  _createEffect() {
    return new Tremolo/* Tremolo */.h({
      frequency: this.pv.frequency,
      depth: this.pv.depth,
      spread: this.pv.spread
    });
  }
}

// EXTERNAL MODULE: ../@polygonjs/polygonjs/node_modules/tone/build/esm/source/UserMedia.js
var UserMedia = __webpack_require__(8856);
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/audio/UserMedia.ts

var UserMedia_async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};





class UserMediaAudioParamsConfig extends params_ParamsConfig/* NodeParamsConfig */.yI {
  constructor() {
    super(...arguments);
    this.autostart = params_ParamsConfig/* ParamConfig.BOOLEAN */.XC.BOOLEAN(1);
    /** @param play the audio */
    this.open = params_ParamsConfig/* ParamConfig.BUTTON */.XC.BUTTON(null, {
      callback: (node) => {
        UserMediaAudioNode.PARAM_CALLBACK_open(node);
      }
    });
    /** @param stop the audio */
    this.close = params_ParamsConfig/* ParamConfig.BUTTON */.XC.BUTTON(null, {
      callback: (node) => {
        UserMediaAudioNode.PARAM_CALLBACK_close(node);
      }
    });
  }
}
const UserMedia_ParamsConfig = new UserMediaAudioParamsConfig();
class UserMediaAudioNode extends audio_Base/* TypedAudioNode */.K {
  constructor() {
    super(...arguments);
    this.paramsConfig = UserMedia_ParamsConfig;
  }
  static type() {
    return "userMedia";
  }
  initializeNode() {
    this.io.inputs.setCount(0);
  }
  cook(inputContents) {
    return UserMedia_async(this, null, function* () {
      const audioBuilder = new AudioBuilder/* AudioBuilder */.y();
      const userMedia = this._userMedia();
      if ((0,Type/* isBooleanTrue */.bI)(this.pv.autostart)) {
        yield userMedia.open();
      }
      audioBuilder.setSource(userMedia);
      this.setAudioBuilder(audioBuilder);
    });
  }
  _userMedia() {
    return this.__userMedia__ = this.__userMedia__ || this._createEffect();
  }
  _createEffect() {
    return new UserMedia/* UserMedia */.X();
  }
  open() {
    return UserMedia_async(this, null, function* () {
      return yield this._userMedia().open();
    });
  }
  close() {
    this._userMedia().close();
  }
  /*
   * STATIC CALLBACKS
   */
  static PARAM_CALLBACK_open(node) {
    node.open();
  }
  static PARAM_CALLBACK_close(node) {
    node.close();
  }
}

// EXTERNAL MODULE: ../@polygonjs/polygonjs/node_modules/tone/build/esm/effect/Vibrato.js
var Vibrato = __webpack_require__(33307);
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/audio/Vibrato.ts


const Vibrato_DEFAULTS = {
  depth: 0.1,
  frequency: 5,
  maxDelay: 5e-3
};


class VibratoAudioParamsConfig extends params_ParamsConfig/* NodeParamsConfig */.yI {
  constructor() {
    super(...arguments);
    /** @param maxDelay */
    this.maxDelay = params_ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(Vibrato_DEFAULTS.maxDelay, {
      range: [0, 1],
      rangeLocked: [true, false]
    });
    /** @param frequency */
    this.frequency = params_ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(Vibrato_DEFAULTS.frequency, {
      range: [0, 10],
      rangeLocked: [true, false]
    });
    /** @param depth */
    this.depth = params_ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(Vibrato_DEFAULTS.depth, {
      range: [0, 1],
      rangeLocked: [true, true]
    });
  }
}
const Vibrato_ParamsConfig = new VibratoAudioParamsConfig();
class VibratoAudioNode extends audio_Base/* TypedAudioNode */.K {
  constructor() {
    super(...arguments);
    this.paramsConfig = Vibrato_ParamsConfig;
  }
  static type() {
    return "vibrato";
  }
  initializeNode() {
    this.io.inputs.setCount(1);
  }
  cook(inputContents) {
    const audioBuilder = inputContents[0];
    const effect = this._createEffect();
    const inputNode = audioBuilder.audioNode();
    if (inputNode) {
      inputNode.connect(effect);
    }
    audioBuilder.setAudioNode(effect);
    this.setAudioBuilder(audioBuilder);
  }
  _createEffect() {
    return new Vibrato/* Vibrato */.Z({
      maxDelay: this.pv.maxDelay,
      frequency: this.pv.frequency,
      depth: this.pv.depth
    });
  }
}

// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/nodes/audio/Volume.ts
var Volume = __webpack_require__(62125);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/node_modules/tone/build/esm/component/analysis/Waveform.js
var Waveform = __webpack_require__(27509);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/node_modules/tone/build/esm/core/type/Conversions.js
var Conversions = __webpack_require__(51412);
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/audio/Waveform.ts

var Waveform_async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};






const Waveform_DEFAULTS = {
  // normalRange: false,
  size: 1024,
  smoothing: 0.8
};
const Waveform_RANGE_DEFAULT = [1e4, -1e4];
class WaveformAudioParamsConfig extends params_ParamsConfig/* NodeParamsConfig */.yI {
  constructor() {
    super(...arguments);
    /** @param array size will be 2**sizeExponent */
    this.sizeExponent = params_ParamsConfig/* ParamConfig.INTEGER */.XC.INTEGER(10, {
      range: [4, 14],
      rangeLocked: [true, true]
    });
    /** @param array size */
    this.arraySize = params_ParamsConfig/* ParamConfig.INTEGER */.XC.INTEGER(`2**ch('sizeExponent')`, {
      editable: false
    });
    /** @param a value from between 0 and 1 where 0 represents no time averaging with the last analysis frame */
    this.smoothing = params_ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(Waveform_DEFAULTS.smoothing, {
      range: [0, 1],
      rangeLocked: [true, true],
      cook: false
      // ...effectParamsOptions(paramCallback),
    });
    /** @param normalizes the output between 0 and 1. The value will be in decibel otherwise. */
    this.normalRange = params_ParamsConfig/* ParamConfig.BOOLEAN */.XC.BOOLEAN(1, {
      cook: false
      // ...effectParamsOptions(paramCallback)
    });
    /** @param display range param */
    this.updateRangeParam = params_ParamsConfig/* ParamConfig.BOOLEAN */.XC.BOOLEAN(1, {
      cook: false,
      callback: (node) => {
        WaveformAudioNode.PARAM_CALLBACK_updateUpdateRangeParam(node);
      }
    });
    /** @param range value */
    this.range = params_ParamsConfig/* ParamConfig.VECTOR2 */.XC.VECTOR2([0, 0], {
      visibleIf: { updateRangeParam: 1 },
      editable: false,
      cook: false
    });
    /** @param accumulated range */
    this.maxRange = params_ParamsConfig/* ParamConfig.VECTOR2 */.XC.VECTOR2(Waveform_RANGE_DEFAULT, {
      visibleIf: { updateRangeParam: 1 },
      editable: false,
      cook: false
    });
    /** @param resetMaxRange */
    this.resetMaxRange = params_ParamsConfig/* ParamConfig.BUTTON */.XC.BUTTON(null, {
      visibleIf: { updateRangeParam: 1 },
      callback: (node) => {
        WaveformAudioNode.PARAM_CALLBACK_resetMaxRange(node);
      }
    });
  }
}
const Waveform_ParamsConfig = new WaveformAudioParamsConfig();
class WaveformAudioNode extends BaseAnalyserAudioNode {
  constructor() {
    super(...arguments);
    this.paramsConfig = Waveform_ParamsConfig;
  }
  static type() {
    return poly_NodeContext/* AudioNodeAnalyserType.WAVEFORM */.YX.WAVEFORM;
  }
  initializeNode() {
    this.io.inputs.setCount(1);
  }
  cook(inputContents) {
    const audioBuilder = inputContents[0];
    this._resetEffect();
    const waveform = this._effect();
    this._updateOnTickHook();
    const inputNode = audioBuilder.audioNode();
    if (inputNode) {
      inputNode.connect(waveform);
    }
    audioBuilder.setAudioNode(waveform);
    this.setAudioBuilder(audioBuilder);
  }
  getAnalyserValue() {
    const currentValue = this._getWaveFormValue();
    if (!currentValue) {
      return;
    }
    const blendedValue = this._previousValue != null && currentValue.length == this._previousValue.length ? this._blendValue(currentValue, this._previousValue) : currentValue;
    if (!this._previousValue || currentValue.length != this._previousValue.length) {
      this._previousValue = new Float32Array(currentValue.length);
    }
    this._previousValue.set(currentValue);
    return blendedValue;
  }
  _getWaveFormValue() {
    if (this.__effect__) {
      const values = this.__effect__.getValue();
      if ((0,Type/* isBooleanTrue */.bI)(this.pv.normalRange)) {
        return values.map((v) => (0,Conversions/* dbToGain */.xz)(v));
      } else {
        return values;
      }
    }
  }
  _blendValue(currentValue, previousValue) {
    const smoothing = this.pv.smoothing;
    if (smoothing == 0) {
      return currentValue;
    }
    if (smoothing == 1) {
      return previousValue;
    }
    const count = currentValue.length;
    for (let i = 0; i < count; i++) {
      currentValue[i] = smoothing * previousValue[i] + (1 - smoothing) * currentValue[i];
    }
    return currentValue;
  }
  _effect() {
    return this.__effect__ = this.__effect__ || this._createEffect();
  }
  _createEffect() {
    const effect = new Waveform/* Waveform */.u({
      size: this._effectSize()
    });
    return effect;
  }
  _resetEffect() {
    if (this.__effect__) {
      this.__effect__.dispose();
      this.__effect__ = void 0;
    }
  }
  // static PARAM_CALLBACK_updateEffect(node: WaveformAudioNode) {
  // 	node._updateEffect();
  // }
  // private _updateEffect() {
  // 	// const effect = this._effect();
  // 	// const analyser = effect.getAnalyser();
  // 	// analyser.smoothing = this.pv.smoothing;
  // }
  _effectSize() {
    return 2 ** this.pv.sizeExponent;
  }
  /*
   * UPDATE RANGE PARAM
   */
  static PARAM_CALLBACK_updateUpdateRangeParam(node) {
    node._updateRangeParam();
    node._updateOnTickHook();
  }
  static PARAM_CALLBACK_resetMaxRange(node) {
    node.p.maxRange.set(Waveform_RANGE_DEFAULT);
  }
  _updateRangeParam() {
    if (!this.__effect__) {
      return;
    }
    const values = this.getAnalyserValue();
    if (!values) {
      return;
    }
    const min = Math.min(...values);
    const max = Math.max(...values);
    this.p.range.set([min, max]);
    if (min < this.pv.maxRange.x && Type/* CoreType.isNumber */.MR.isNumber(min) && isFinite(min)) {
      this.p.maxRange.x.set(min);
    }
    if (max > this.pv.maxRange.y && Type/* CoreType.isNumber */.MR.isNumber(max) && isFinite(max)) {
      this.p.maxRange.y.set(max);
    }
  }
  /*
   * REGISTER TICK CALLBACK
   */
  _updateOnTickHook() {
    if ((0,Type/* isBooleanTrue */.bI)(this.pv.updateRangeParam)) {
      this._registerOnTickHook();
    } else {
      this._unRegisterOnTickHook();
    }
  }
  _registerOnTickHook() {
    return Waveform_async(this, null, function* () {
      if (this.scene().registeredBeforeTickCallbacks().has(this._tickCallbackName())) {
        return;
      }
      this.scene().registerOnBeforeTick(this._tickCallbackName(), this._updateRangeParam.bind(this));
    });
  }
  _unRegisterOnTickHook() {
    return Waveform_async(this, null, function* () {
      this.scene().unRegisterOnBeforeTick(this._tickCallbackName());
    });
  }
  _tickCallbackName() {
    return `audio/FFT-${this.graphNodeId()}`;
  }
}

// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/nodes/_Base.ts + 47 modules
var nodes_Base = __webpack_require__(74386);
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/audio/_BaseManager.ts




class ParamLessNetworkAudioParamsConfig extends (/* unused pure expression or super */ null && (NodeParamsConfig)) {
}
class BaseNetworkAudioNode extends nodes_Base/* TypedNode */.Mv {
  static context() {
    return poly_NodeContext/* NodeContext.AUDIO */.sy.AUDIO;
  }
  cook() {
    this.cookController.endCook();
  }
}
class ParamLessBaseNetworkAudioNode extends BaseNetworkAudioNode {
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/audio/ActorsNetwork.ts







class ActorsNetworkAudioNode extends ParamLessBaseNetworkAudioNode {
  constructor() {
    super(...arguments);
    this._childrenControllerContext = poly_NodeContext/* NodeContext.JS */.sy.JS;
    //
    // ASSEMBLERS
    //
    this.persisted_config = new ActorPersistedConfig/* ActorPersistedConfig */.R(this);
    this._assemblerController = this._createAssemblerController();
    //
    // compilation
    //
    this.compilationController = new ActorCompilationController/* ActorCompilationController */.z7(this);
  }
  static type() {
    return poly_NodeContext/* NetworkNodeType.ACTOR */.kX.ACTOR;
  }
  createNode(node_class, options) {
    return super.createNode(node_class, options);
  }
  children() {
    return super.children();
  }
  nodesByType(type) {
    return super.nodesByType(type);
  }
  //
  childrenAllowed() {
    if (this.assemblerController()) {
      return super.childrenAllowed();
    }
    return false;
  }
  sceneReadonly() {
    return this.assemblerController() == null;
  }
  assemblerController() {
    return this._assemblerController;
  }
  usedAssembler() {
    return _BaseRegister/* AssemblerName.JS_ACTOR */.Q.JS_ACTOR;
  }
  _createAssemblerController() {
    return Poly/* Poly.assemblersRegister.assembler */.L.assemblersRegister.assembler(this, this.usedAssembler());
  }
  compile() {
    this.compilationController.compile();
  }
  cook() {
    this.compilationController.compileIfRequired();
    this.cookController.endCook();
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/audio/AnimationsNetwork.ts



class AnimationsNetworkAudioNode extends ParamLessBaseNetworkAudioNode {
  constructor() {
    super(...arguments);
    this._childrenControllerContext = poly_NodeContext/* NodeContext.ANIM */.sy.ANIM;
  }
  static type() {
    return poly_NodeContext/* NetworkNodeType.ANIM */.kX.ANIM;
  }
  createNode(node_class, options) {
    return super.createNode(node_class, options);
  }
  children() {
    return super.children();
  }
  nodesByType(type) {
    return super.nodesByType(type);
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/audio/AudioNetwork.ts



class AudioNetworkAudioNode extends ParamLessBaseNetworkAudioNode {
  constructor() {
    super(...arguments);
    this._childrenControllerContext = poly_NodeContext/* NodeContext.AUDIO */.sy.AUDIO;
  }
  static type() {
    return poly_NodeContext/* NetworkNodeType.AUDIO */.kX.AUDIO;
  }
  createNode(node_class, options) {
    return super.createNode(node_class, options);
  }
  children() {
    return super.children();
  }
  nodesByType(type) {
    return super.nodesByType(type);
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/audio/CopNetwork.ts



class CopNetworkAudioNode extends ParamLessBaseNetworkAudioNode {
  constructor() {
    super(...arguments);
    this._childrenControllerContext = poly_NodeContext/* NodeContext.COP */.sy.COP;
  }
  static type() {
    return poly_NodeContext/* NetworkNodeType.COP */.kX.COP;
  }
  createNode(node_class, options) {
    return super.createNode(node_class, options);
  }
  children() {
    return super.children();
  }
  nodesByType(type) {
    return super.nodesByType(type);
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/audio/EventsNetwork.ts



class EventsNetworkAudioNode extends ParamLessBaseNetworkAudioNode {
  constructor() {
    super(...arguments);
    this._childrenControllerContext = poly_NodeContext/* NodeContext.EVENT */.sy.EVENT;
  }
  static type() {
    return poly_NodeContext/* NetworkNodeType.EVENT */.kX.EVENT;
  }
  createNode(node_class, options) {
    return super.createNode(node_class, options);
  }
  children() {
    return super.children();
  }
  nodesByType(type) {
    return super.nodesByType(type);
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/audio/MaterialsNetwork.ts



class MaterialsNetworkAudioNode extends ParamLessBaseNetworkAudioNode {
  constructor() {
    super(...arguments);
    this._childrenControllerContext = poly_NodeContext/* NodeContext.MAT */.sy.MAT;
  }
  static type() {
    return poly_NodeContext/* NetworkNodeType.MAT */.kX.MAT;
  }
  createNode(node_class, options) {
    return super.createNode(node_class, options);
  }
  children() {
    return super.children();
  }
  nodesByType(type) {
    return super.nodesByType(type);
  }
}

// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/nodes/utils/DisplayNodeController.ts
var DisplayNodeController = __webpack_require__(35725);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/nodes/post/utils/EffectComposerController.ts
var EffectComposerController = __webpack_require__(32241);
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/audio/PostProcessNetwork.ts





class PostProcessNetworkAudioNode extends BaseNetworkAudioNode {
  constructor() {
    super(...arguments);
    this.paramsConfig = new EffectComposerController/* PostProcessNetworkParamsConfig */.Ab();
    this.effectsComposerController = new EffectComposerController/* EffectComposerController */.iy(this);
    this.displayNodeController = new DisplayNodeController/* DisplayNodeController */.v(
      this,
      this.effectsComposerController.displayNodeControllerCallbacks()
    );
    this._childrenControllerContext = poly_NodeContext/* NodeContext.POST */.sy.POST;
  }
  static type() {
    return poly_NodeContext/* NetworkNodeType.POST */.kX.POST;
  }
  createNode(node_class, options) {
    return super.createNode(node_class, options);
  }
  children() {
    return super.children();
  }
  nodesByType(type) {
    return super.nodesByType(type);
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/audio/RenderersNetwork.ts



class RenderersNetworkAudioNode extends ParamLessBaseNetworkAudioNode {
  constructor() {
    super(...arguments);
    this._childrenControllerContext = poly_NodeContext/* NodeContext.ROP */.sy.ROP;
  }
  static type() {
    return poly_NodeContext/* NetworkNodeType.ROP */.kX.ROP;
  }
  createNode(node_class, options) {
    return super.createNode(node_class, options);
  }
  children() {
    return super.children();
  }
  nodesByType(type) {
    return super.nodesByType(type);
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/poly/registers/nodes/Audio.ts











































class AudioRegister {
  static run(poly) {
    poly.registerNode(AMSynthAudioNode, CATEGORY_AUDIO.INSTRUMENTS);
    poly.registerNode(AutoFilterAudioNode, CATEGORY_AUDIO.EFFECTS);
    poly.registerNode(AutoWahAudioNode, CATEGORY_AUDIO.EFFECTS);
    poly.registerNode(BitCrusherAudioNode, CATEGORY_AUDIO.EFFECTS);
    poly.registerNode(ChebyshevAudioNode, CATEGORY_AUDIO.EFFECTS);
    poly.registerNode(ChorusAudioNode, CATEGORY_AUDIO.EFFECTS);
    poly.registerNode(DistortionAudioNode, CATEGORY_AUDIO.EFFECTS);
    poly.registerNode(EnvelopeAudioNode, CATEGORY_AUDIO.MISC);
    poly.registerNode(FFTAudioNode, CATEGORY_AUDIO.ANALYSER);
    poly.registerNode(FMSynthAudioNode, CATEGORY_AUDIO.INSTRUMENTS);
    poly.registerNode(FeedbackDelayAudioNode, CATEGORY_AUDIO.EFFECTS);
    poly.registerNode(FetchAudioNode, CATEGORY_AUDIO.INPUTS);
    poly.registerNode(File/* FileAudioNode */.r, CATEGORY_AUDIO.INPUTS);
    poly.registerNode(FrequencyShifterAudioNode, CATEGORY_AUDIO.EFFECTS);
    poly.registerNode(MeterAudioNode, CATEGORY_AUDIO.ANALYSER);
    poly.registerNode(MonoSynthAudioNode, CATEGORY_AUDIO.INSTRUMENTS);
    poly.registerNode(NoiseAudioNode, CATEGORY_AUDIO.INSTRUMENTS);
    poly.registerNode(NullAudioNode, CATEGORY_AUDIO.MISC);
    poly.registerNode(PhaserAudioNode, CATEGORY_AUDIO.EFFECTS);
    poly.registerNode(PingPongDelayAudioNode, CATEGORY_AUDIO.EFFECTS);
    poly.registerNode(PitchShiftAudioNode, CATEGORY_AUDIO.EFFECTS);
    poly.registerNode(PlayInstrument/* PlayInstrumentAudioNode */.R, CATEGORY_AUDIO.MISC);
    poly.registerNode(PolySynthAudioNode, CATEGORY_AUDIO.INSTRUMENTS);
    poly.registerNode(ReverbAudioNode, CATEGORY_AUDIO.EFFECTS);
    poly.registerNode(Sampler/* SamplerAudioNode */.O, CATEGORY_AUDIO.INSTRUMENTS);
    poly.registerNode(StereoWidenerAudioNode, CATEGORY_AUDIO.EFFECTS);
    poly.registerNode(Switch/* SwitchAudioNode */.P, CATEGORY_AUDIO.MISC);
    poly.registerNode(SynthAudioNode, CATEGORY_AUDIO.INSTRUMENTS);
    poly.registerNode(TremoloAudioNode, CATEGORY_AUDIO.EFFECTS);
    poly.registerNode(UserMediaAudioNode, CATEGORY_AUDIO.INPUTS);
    poly.registerNode(VibratoAudioNode, CATEGORY_AUDIO.EFFECTS);
    poly.registerNode(Volume/* VolumeAudioNode */.F, CATEGORY_AUDIO.MISC);
    poly.registerNode(WaveformAudioNode, CATEGORY_AUDIO.ANALYSER);
    poly.registerNode(ActorsNetworkAudioNode, CATEGORY_AUDIO.NETWORK);
    poly.registerNode(AnimationsNetworkAudioNode, CATEGORY_AUDIO.NETWORK);
    poly.registerNode(AudioNetworkAudioNode, CATEGORY_AUDIO.NETWORK);
    poly.registerNode(CopNetworkAudioNode, CATEGORY_AUDIO.NETWORK);
    poly.registerNode(EventsNetworkAudioNode, CATEGORY_AUDIO.NETWORK);
    poly.registerNode(MaterialsNetworkAudioNode, CATEGORY_AUDIO.NETWORK);
    poly.registerNode(PostProcessNetworkAudioNode, CATEGORY_AUDIO.NETWORK);
    poly.registerNode(RenderersNetworkAudioNode, CATEGORY_AUDIO.NETWORK);
  }
}

// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/nodes/cop/AudioAnalyser.ts
var AudioAnalyser = __webpack_require__(77834);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/nodes/cop/Builder.ts
var Builder = __webpack_require__(29011);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/nodes/cop/Builder2DArray.ts
var Builder2DArray = __webpack_require__(47642);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/nodes/cop/_Base.ts
var cop_Base = __webpack_require__(65276);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/nodes/cop/utils/TextureParamsController.ts + 2 modules
var TextureParamsController = __webpack_require__(20400);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/node_modules/three/build/three.module.js
var three_module = __webpack_require__(21410);
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/cop/Canvas.ts

var Canvas_async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};




function CanvasCopNodeParamConfig(Base) {
  return class Mixin extends Base {
    constructor() {
      super(...arguments);
      /** @param HTML id of the canvas element */
      this.canvasId = params_ParamsConfig/* ParamConfig.STRING */.XC.STRING("canvas-id");
      /** @param forces the texture to update */
      this.update = params_ParamsConfig/* ParamConfig.BUTTON */.XC.BUTTON(null, {
        cook: false,
        callback: (node) => {
          CanvasCopNode.PARAM_CALLBACK_update(node);
        }
      });
    }
  };
}
class CanvasCopParamConfig extends (0,TextureParamsController/* TextureParamConfig */.h)(CanvasCopNodeParamConfig(params_ParamsConfig/* NodeParamsConfig */.yI)) {
}
const Canvas_ParamsConfig = new CanvasCopParamConfig();
class CanvasCopNode extends cop_Base/* TypedCopNode */.z {
  constructor() {
    super(...arguments);
    this.paramsConfig = Canvas_ParamsConfig;
    this.textureParamsController = new TextureParamsController/* TextureParamsController */.V(this);
  }
  static type() {
    return "canvas";
  }
  cook() {
    return Canvas_async(this, null, function* () {
      const elementId = this.pv.canvasId;
      const element = document.getElementById(elementId);
      if (!element) {
        this.states.error.set(`element with id '${elementId}' not found`);
        this.cookController.endCook();
        return;
      }
      if (!(element instanceof HTMLCanvasElement)) {
        this.states.error.set(`element found is not a canvas`);
        this.cookController.endCook();
        return;
      }
      const texture = new three_module.CanvasTexture(element);
      yield this.textureParamsController.update(texture);
      this.setTexture(texture);
    });
  }
  //
  //
  // CALLBACK
  //
  //
  static PARAM_CALLBACK_update(node) {
    node.markTextureNeedsUpdate();
  }
  markTextureNeedsUpdate() {
    const texture = this.containerController.container().texture();
    if (!texture) {
      return;
    }
    texture.needsUpdate = true;
  }
}

// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/nodes/cop/Color.ts
var Color = __webpack_require__(86621);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/nodes/cop/CubeMap.ts + 1 modules
var CubeMap = __webpack_require__(16422);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/nodes/cop/CubeCamera.ts
var CubeCamera = __webpack_require__(59160);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/poly/registers/nodes/types/Cop.ts
var Cop = __webpack_require__(12764);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/nodes/cop/utils/RendererController.ts
var RendererController = __webpack_require__(77643);
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/cop/CubeMapFromScene.ts

var CubeMapFromScene_async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};







function CubeMapFromSceneCopParamConfig(Base) {
  return class Mixin extends Base {
    constructor() {
      super(...arguments);
      /** @param force Render */
      this.blur = params_ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(0, {
        range: [0, 0.1],
        step: 1e-4,
        rangeLocked: [true, false]
      });
      /** @param camera near */
      this.near = params_ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(0.1, {
        range: [1e-4, 1],
        step: 1e-4,
        rangeLocked: [true, false]
      });
      /** @param camera far */
      this.far = params_ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(100, {
        range: [0, 100],
        rangeLocked: [true, false]
      });
      /** @param force Render */
      this.render = params_ParamsConfig/* ParamConfig.BUTTON */.XC.BUTTON(null, {
        callback: (node) => CubeMapFromScene_async(this, null, function* () {
          yield CubeMapFromSceneCopNode.PARAM_CALLBACK_render(node);
        })
      });
    }
  };
}
class CubeMapFromSceneCopParamsConfig extends CubeMapFromSceneCopParamConfig(params_ParamsConfig/* NodeParamsConfig */.yI) {
}
const CubeMapFromScene_ParamsConfig = new CubeMapFromSceneCopParamsConfig();
class CubeMapFromSceneCopNode extends cop_Base/* TypedCopNode */.z {
  constructor() {
    super(...arguments);
    this.paramsConfig = CubeMapFromScene_ParamsConfig;
    // display_node and children_display controllers
    // private _renderCubeMapBound = this._renderCubeMap.bind(this);
    this._setDirtyBound = this._setDirty.bind(this);
    this.displayNodeController = new DisplayNodeController/* DisplayNodeController */.v(this, {
      onDisplayNodeRemove: this._setDirtyBound,
      onDisplayNodeSet: this._setDirtyBound,
      onDisplayNodeUpdate: this._setDirtyBound
    });
    //
    this._childrenControllerContext = poly_NodeContext/* NodeContext.SOP */.sy.SOP;
    this._cookMainWithoutInputsWhenDirtyBound = this._cookMainWithoutInputsWhenDirty.bind(this);
    this._renderScene = new three_module.Scene();
  }
  static type() {
    return Cop/* CopType.CUBE_MAP_FROM_SCENE */.y.CUBE_MAP_FROM_SCENE;
  }
  lastGeneratedRenderTarget() {
    return this._lastGeneratedRenderTarget;
  }
  initializeNode() {
    this.addPostDirtyHook("_cook_main_without_inputs_when_dirty", () => {
      setTimeout(this._cookMainWithoutInputsWhenDirtyBound, 0);
    });
  }
  dispose() {
    var _a;
    (_a = this._pmremGenerator) == null ? void 0 : _a.dispose();
    super.dispose();
  }
  createNode(node_class, options) {
    return super.createNode(node_class, options);
  }
  children() {
    return super.children();
  }
  nodesByType(type) {
    return super.nodesByType(type);
  }
  childrenAllowed() {
    return true;
  }
  _setDirty() {
    this.setDirty();
  }
  _cookMainWithoutInputsWhenDirty() {
    return CubeMapFromScene_async(this, null, function* () {
      yield this.cookController.cookMainWithoutInputs();
    });
  }
  cook() {
    return CubeMapFromScene_async(this, null, function* () {
      yield this._updateRenderScene();
      const texture = yield this._renderCubeMap();
      if (!texture) {
        this.cookController.endCook();
      }
    });
  }
  _updateRenderScene() {
    return CubeMapFromScene_async(this, null, function* () {
      if (!this.scene().loadingController.autoUpdating()) {
        return;
      }
      const displayNode = this.displayNodeController.displayNode();
      if (!displayNode) {
        return;
      }
      if (displayNode.context() != poly_NodeContext/* NodeContext.SOP */.sy.SOP) {
        return;
      }
      const sopNode = displayNode;
      const container = yield sopNode.compute();
      if (!container) {
        return;
      }
      const coreGroup = container.coreContent();
      if (!coreGroup) {
        return;
      }
      const currentChildren = [...this._renderScene.children];
      for (const child of currentChildren) {
        this._renderScene.remove(child);
      }
      const objects = coreGroup.threejsObjects();
      for (const object of objects) {
        this._renderScene.add(object);
      }
    });
  }
  _renderCubeMap() {
    return CubeMapFromScene_async(this, null, function* () {
      if (!this.scene().loadingController.autoUpdating()) {
        return;
      }
      this._rendererController = this._rendererController || new RendererController/* CopRendererController */.G(this);
      const renderer = yield this._rendererController.waitForRenderer();
      if (!renderer) {
        this.states.error.set("no renderer found to convert the texture to an env map");
        return;
      }
      if (!(renderer instanceof three_module.WebGLRenderer)) {
        this.states.error.set("found renderer is not a WebGLRenderer");
        return;
      }
      this._pmremGenerator = this._pmremGenerator || new three_module.PMREMGenerator(renderer);
      this._lastGeneratedRenderTarget = this._pmremGenerator.fromScene(
        this._renderScene,
        this.pv.blur,
        this.pv.near,
        this.pv.far
      );
      this.setTexture(this._lastGeneratedRenderTarget.texture);
      return this._lastGeneratedRenderTarget.texture;
    });
  }
  /*
   *
   * CALLBACK
   *
   */
  static PARAM_CALLBACK_render(node) {
    return CubeMapFromScene_async(this, null, function* () {
      yield node._renderCubeMap();
    });
  }
}

// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/poly/InputCloneMode.ts
var InputCloneMode = __webpack_require__(56752);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/nodes/cop/utils/DataTextureController.ts
var DataTextureController = __webpack_require__(50050);
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/cop/EnvMap.ts

var EnvMap_async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};










class EnvMapCopParamsConfig extends params_ParamsConfig/* NodeParamsConfig */.yI {
  constructor() {
    super(...arguments);
    /** @param defines if the shader is rendered via the same camera used to render the scene */
    this.useCameraRenderer = params_ParamsConfig/* ParamConfig.BOOLEAN */.XC.BOOLEAN(1);
  }
  // needs to be 1, as it does not work on firefox otherwise
  /** @param defines if the texture is used for reflection or refraction */
  // mode = ParamConfig.INTEGER(0, {
  // 	menu: {
  // 		entries: MAP_MODES.map((name, value) => {
  // 			return {name, value};
  // 		}),
  // 	},
  // });
}
const EnvMap_ParamsConfig = new EnvMapCopParamsConfig();
class EnvMapCopNode extends cop_Base/* TypedCopNode */.z {
  constructor() {
    super(...arguments);
    this.paramsConfig = EnvMap_ParamsConfig;
  }
  static type() {
    return Cop/* CopType.ENV_MAP */.y.ENV_MAP;
  }
  initializeNode() {
    this.io.inputs.setCount(1);
    this.io.inputs.initInputsClonedState(InputCloneMode/* InputCloneMode.NEVER */.m.NEVER);
  }
  cook(inputTextures) {
    return EnvMap_async(this, null, function* () {
      const texture = inputTextures[0];
      yield this._convertTextureToEnvMap(texture);
    });
  }
  _convertTextureToEnvMap(inputTexture) {
    return EnvMap_async(this, null, function* () {
      this._rendererController = this._rendererController || new RendererController/* CopRendererController */.G(this);
      const renderer = yield this._rendererController.waitForRenderer();
      if (!renderer) {
        this.states.error.set("no renderer found to convert the texture to an env map");
        return this.cookController.endCook();
      }
      if (!(renderer instanceof three_module.WebGLRenderer)) {
        this.states.error.set("renderer found is not WebGLRenderer");
        console.log({ renderer });
        return this.cookController.endCook();
      }
      const pmremGenerator = new three_module.PMREMGenerator(renderer);
      const exrCubeRenderTarget = pmremGenerator.fromEquirectangular(inputTexture);
      if ((0,Type/* isBooleanTrue */.bI)(this.pv.useCameraRenderer)) {
        this._setMapping(exrCubeRenderTarget.texture);
        this.setTexture(exrCubeRenderTarget.texture);
      } else {
        this._dataTextureController = this._dataTextureController || new DataTextureController/* DataTextureController */.y(DataTextureController/* DataTextureControllerBufferType.Uint16Array */.A.Uint16Array);
        const texture = this._dataTextureController.fromRenderTarget(renderer, exrCubeRenderTarget);
        this._setMapping(texture);
        this.setTexture(texture);
      }
    });
  }
  _setMapping(texture) {
    texture.mapping = three_module.CubeUVReflectionMapping;
  }
}

// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/nodes/cop/GeometryAttribute.ts
var GeometryAttribute = __webpack_require__(53198);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/nodes/cop/Gif.ts
var Gif = __webpack_require__(44955);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/nodes/cop/Image.ts + 1 modules
var Image = __webpack_require__(64033);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/nodes/cop/ImageEXR.ts + 2 modules
var ImageEXR = __webpack_require__(3880);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/nodes/cop/ImageHDR.ts + 1 modules
var ImageHDR = __webpack_require__(5874);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/nodes/cop/ImageKTX2.ts
var ImageKTX2 = __webpack_require__(9772);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/nodes/cop/LightMap.ts + 8 modules
var LightMap = __webpack_require__(83704);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/nodes/cop/Lut.ts
var Lut = __webpack_require__(1469);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/nodes/cop/MapboxElevation.ts
var MapboxElevation = __webpack_require__(41752);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/nodes/cop/MapboxSatellite.ts
var MapboxSatellite = __webpack_require__(76202);
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/cop/Null.ts

var Null_async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};



const cop_Null_ParamsConfig = new params_ParamsConfig/* NodeParamsConfig */.yI();
class NullCopNode extends cop_Base/* TypedCopNode */.z {
  constructor() {
    super(...arguments);
    this.paramsConfig = cop_Null_ParamsConfig;
  }
  static type() {
    return "null";
  }
  initializeNode() {
    this.io.inputs.setCount(1);
    this.io.inputs.initInputsClonedState(InputCloneMode/* InputCloneMode.NEVER */.m.NEVER);
  }
  cook(input_contents) {
    return Null_async(this, null, function* () {
      const texture = input_contents[0];
      this.setTexture(texture);
    });
  }
}

// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/core/color/chromotomeWrapper.ts
var chromotomeWrapper = __webpack_require__(89151);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/nodes/utils/color/PaletteController.ts
var PaletteController = __webpack_require__(32842);
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/cop/Palette.ts

var Palette_defProp = Object.defineProperty;
var Palette_getOwnPropSymbols = Object.getOwnPropertySymbols;
var Palette_hasOwnProp = Object.prototype.hasOwnProperty;
var Palette_propIsEnum = Object.prototype.propertyIsEnumerable;
var Palette_defNormalProp = (obj, key, value) => key in obj ? Palette_defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var Palette_spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (Palette_hasOwnProp.call(b, prop))
      Palette_defNormalProp(a, prop, b[prop]);
  if (Palette_getOwnPropSymbols)
    for (var prop of Palette_getOwnPropSymbols(b)) {
      if (Palette_propIsEnum.call(b, prop))
        Palette_defNormalProp(a, prop, b[prop]);
    }
  return a;
};






class PaletteCopParamsConfig extends params_ParamsConfig/* NodeParamsConfig */.yI {
  constructor() {
    super(...arguments);
    /** @param texture resolution */
    this.resolution = params_ParamsConfig/* ParamConfig.VECTOR2 */.XC.VECTOR2([256, 256], {
      callback: (node) => {
        PaletteCopNode.PARAM_CALLBACK_reset(node);
      }
    });
    /** @param name of the palette */
    this.paletteName = params_ParamsConfig/* ParamConfig.STRING */.XC.STRING(chromotomeWrapper/* SORTED_PALETTE_NAMES.0 */.QK[0], Palette_spreadValues({
      menuString: {
        entries: chromotomeWrapper/* SORTED_PALETTE_NAMES.map */.QK.map((name, value) => {
          return { name, value: name };
        })
      }
    }, (0,PaletteController/* paletteControllerCallbackOptions */.Sk)(PaletteController/* PaletteController.PARAM_CALLBACK_updateColors */.qT.PARAM_CALLBACK_updateColors)));
    /** @param click to set the node to the next palette */
    this.pickNext = params_ParamsConfig/* ParamConfig.BUTTON */.XC.BUTTON(null, (0,PaletteController/* paletteControllerCallbackOptions */.Sk)(PaletteController/* PaletteController.PARAM_CALLBACK_pickNext */.qT.PARAM_CALLBACK_pickNext));
    /** @param click to set the node to the previous palette */
    this.pickPrevious = params_ParamsConfig/* ParamConfig.BUTTON */.XC.BUTTON(
      null,
      (0,PaletteController/* paletteControllerCallbackOptions */.Sk)(PaletteController/* PaletteController.PARAM_CALLBACK_pickPrevious */.qT.PARAM_CALLBACK_pickPrevious)
    );
    /** @param click to set the node to a random palette */
    this.pickRandom = params_ParamsConfig/* ParamConfig.BUTTON */.XC.BUTTON(
      null,
      (0,PaletteController/* paletteControllerCallbackOptions */.Sk)(PaletteController/* PaletteController.PARAM_CALLBACK_pickRandom */.qT.PARAM_CALLBACK_pickRandom)
    );
    this.colorsCount = params_ParamsConfig/* ParamConfig.INTEGER */.XC.INTEGER(0, {
      hidden: true,
      range: [0, chromotomeWrapper/* MAX_PALETTE_COLORS_COUNT */.JT],
      separatorAfter: true
    });
    /** @param palette color 1 */
    this.color1 = params_ParamsConfig/* ParamConfig.COLOR */.XC.COLOR([0, 0, 0], {
      visibleIf: (0,chromotomeWrapper/* visibleIfColorsCountAtLeast */.i2)(1)
      // conversion: ColorConversion.SRGB_TO_LINEAR,
    });
    /** @param palette color 2 */
    this.color2 = params_ParamsConfig/* ParamConfig.COLOR */.XC.COLOR([0, 0, 0], {
      visibleIf: (0,chromotomeWrapper/* visibleIfColorsCountAtLeast */.i2)(2)
      // conversion: ColorConversion.SRGB_TO_LINEAR,
    });
    /** @param palette color 3 */
    this.color3 = params_ParamsConfig/* ParamConfig.COLOR */.XC.COLOR([0, 0, 0], {
      visibleIf: (0,chromotomeWrapper/* visibleIfColorsCountAtLeast */.i2)(3)
      // conversion: ColorConversion.SRGB_TO_LINEAR,
    });
    /** @param palette color 4 */
    this.color4 = params_ParamsConfig/* ParamConfig.COLOR */.XC.COLOR([0, 0, 0], {
      visibleIf: (0,chromotomeWrapper/* visibleIfColorsCountAtLeast */.i2)(4)
      // conversion: ColorConversion.SRGB_TO_LINEAR,
    });
    /** @param palette color 5 */
    this.color5 = params_ParamsConfig/* ParamConfig.COLOR */.XC.COLOR([0, 0, 0], {
      visibleIf: (0,chromotomeWrapper/* visibleIfColorsCountAtLeast */.i2)(5)
      // conversion: ColorConversion.SRGB_TO_LINEAR,
    });
  }
}
const Palette_ParamsConfig = new PaletteCopParamsConfig();
class PaletteCopNode extends cop_Base/* TypedCopNode */.z {
  constructor() {
    super(...arguments);
    this.paramsConfig = Palette_ParamsConfig;
    this.paletteController = new PaletteController/* PaletteController */.qT(
      this
    );
    this._colors = [new three_module.Color(), new three_module.Color(), new three_module.Color(), new three_module.Color(), new three_module.Color()];
  }
  static type() {
    return "palette";
  }
  initializeNode() {
    this.params.onParamsCreated("palette_init", () => {
      PaletteController/* PaletteController.PARAM_CALLBACK_updateColors */.qT.PARAM_CALLBACK_updateColors(this);
    });
  }
  cook() {
    const w = this.pv.resolution.x;
    const h = this.pv.resolution.y;
    this._dataTexture = this._dataTexture || this._createDataTexture(w, h);
    const alpha = 255;
    const data = this._dataTexture.image.data;
    data.fill(alpha);
    const colorsCount = this.pv.colorsCount;
    this._colorParams = this._colorParams || [
      this.p.color1,
      this.p.color2,
      this.p.color3,
      this.p.color4,
      this.p.color5
    ];
    this._colorParams.forEach((p, i) => {
      this._colors[i].copy(p.value).multiplyScalar(255);
    });
    for (let i = 0; i < w; i++) {
      const intervalIndex = this._intervalIndex(i / w, colorsCount);
      const color = this._colors[intervalIndex];
      for (let j = 0; j < h; j++) {
        const offset = i + j * w;
        color.toArray(data, offset * 4);
      }
    }
    this._dataTexture.needsUpdate = true;
    this.setTexture(this._dataTexture);
  }
  _intervalIndex(ratio, colorsCount) {
    const interval = 1 / colorsCount;
    return Math.floor(ratio / interval);
  }
  _createDataTexture(width, height) {
    const pixel_buffer = this._createPixelBuffer(width, height);
    return new three_module.DataTexture(pixel_buffer, width, height);
  }
  _createPixelBuffer(width, height) {
    const size = width * height * 4;
    return new Uint8Array(size);
  }
  static PARAM_CALLBACK_reset(node) {
    node._reset();
  }
  _reset() {
    this._dataTexture = void 0;
  }
}

// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/nodes/cop/Fetch.ts
var Fetch = __webpack_require__(17162);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/nodes/cop/Render.ts
var Render = __webpack_require__(45853);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/nodes/cop/SDFExporter.ts
var SDFExporter = __webpack_require__(2714);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/nodes/cop/SDFFromObject.ts
var SDFFromObject = __webpack_require__(24285);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/nodes/cop/SDFFromUrl.ts
var SDFFromUrl = __webpack_require__(80786);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/core/DomUtils.ts
var DomUtils = __webpack_require__(1895);
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/cop/Snapshot.ts

var Snapshot_async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};







function SnapshotCopParamConfig(Base) {
  return class Mixin extends Base {
    constructor() {
      super(...arguments);
      /** @param capture */
      this.capture = params_ParamsConfig/* ParamConfig.BUTTON */.XC.BUTTON(null, {
        callback: (node) => {
          SnapshotCopNode.PARAM_CALLBACK_snapshot(node);
        }
      });
    }
  };
}
class SnapshotCopParamsConfig extends SnapshotCopParamConfig(params_ParamsConfig/* NodeParamsConfig */.yI) {
}
const Snapshot_ParamsConfig = new SnapshotCopParamsConfig();
class SnapshotCopNode extends cop_Base/* TypedCopNode */.z {
  constructor() {
    super(...arguments);
    this.paramsConfig = Snapshot_ParamsConfig;
  }
  static type() {
    return Cop/* CopType.SNAPSHOT */.y.SNAPSHOT;
  }
  initializeNode() {
    this.io.inputs.setCount(1);
    this.io.inputs.initInputsClonedState(InputCloneMode/* InputCloneMode.NEVER */.m.NEVER);
  }
  cook(inputTextures) {
    return Snapshot_async(this, null, function* () {
      const inputTexture = inputTextures[0];
      if (inputTexture && inputTexture instanceof three_module.VideoTexture) {
        const texture = this._videoSnapshotCanvas(inputTexture);
        if (texture) {
          TextureParamsController/* TextureParamsController.copyTextureAttributes */.V.copyTextureAttributes(texture, inputTexture);
          this.setTexture(texture);
          return;
        }
      } else {
        this.states.error.set("input texture is not a video");
      }
      this.cookController.endCook();
    });
  }
  static PARAM_CALLBACK_snapshot(node) {
    node.paramCallbackSnapshot();
  }
  paramCallbackSnapshot() {
    this.setDirty();
  }
  _videoSnapshotCanvas(inputTexture) {
    const videoElement = inputTexture.image;
    if (!DomUtils/* CoreDomUtils.isHTMLVideoElementLoaded */.O.isHTMLVideoElementLoaded(videoElement)) {
      this.states.error.set("video not loaded");
      return;
    }
    this._canvas = this._canvas || document.createElement("canvas");
    this._canvasTexture = this._canvasTexture || new three_module.CanvasTexture(this._canvas);
    this._canvas.width = inputTexture.image.videoWidth;
    this._canvas.height = inputTexture.image.videoHeight;
    const canvasCtx = this._canvas.getContext("2d");
    canvasCtx.drawImage(inputTexture.image, 0, 0, this._canvas.width, this._canvas.height);
    this._canvasTexture.needsUpdate = true;
    return this._canvasTexture;
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/cop/Switch.ts

var Switch_async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};



class SwitchCopParamsConfig extends params_ParamsConfig/* NodeParamsConfig */.yI {
  constructor() {
    super(...arguments);
    /** @param input index */
    this.input = params_ParamsConfig/* ParamConfig.INTEGER */.XC.INTEGER(0, {
      range: [0, 3],
      rangeLocked: [true, true],
      callback: (node) => {
        SwitchCopNode.PARAM_CALLBACK_setInputsEvaluation(node);
      }
    });
  }
}
const cop_Switch_ParamsConfig = new SwitchCopParamsConfig();
class SwitchCopNode extends cop_Base/* TypedCopNode */.z {
  constructor() {
    super(...arguments);
    this.paramsConfig = cop_Switch_ParamsConfig;
  }
  static type() {
    return "switch";
  }
  initializeNode() {
    this.io.inputs.setCount(0, 4);
    this.io.inputs.initInputsClonedState(InputCloneMode/* InputCloneMode.NEVER */.m.NEVER);
    this.io.inputs.onEnsureListenToSingleInputIndexUpdated(() => Switch_async(this, null, function* () {
      yield this._callbackUpdateInputsEvaluation();
    }));
  }
  cook() {
    return Switch_async(this, null, function* () {
      const input_index = this.pv.input;
      if (this.io.inputs.hasInput(input_index)) {
        const container = yield this.containerController.requestInputContainer(input_index);
        if (container) {
          this.setTexture(container.texture());
          return;
        }
      } else {
        this.states.error.set(`no input ${input_index}`);
      }
      this.cookController.endCook();
    });
  }
  _callbackUpdateInputsEvaluation() {
    return Switch_async(this, null, function* () {
      if (this.p.input.isDirty()) {
        yield this.p.input.compute();
      }
      this.io.inputs.listenToSingleInputIndex(this.pv.input);
    });
  }
  static PARAM_CALLBACK_setInputsEvaluation(node) {
    node._callbackUpdateInputsEvaluation();
  }
}

// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/nodes/cop/Text.ts + 1 modules
var Text = __webpack_require__(38759);
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/cop/TextureProperties.ts

var TextureProperties_async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};




class TexturePropertiesCopParamsConfig extends (0,TextureParamsController/* TextureParamConfig */.h)(params_ParamsConfig/* NodeParamsConfig */.yI) {
}
const TextureProperties_ParamsConfig = new TexturePropertiesCopParamsConfig();
class TexturePropertiesCopNode extends cop_Base/* TypedCopNode */.z {
  constructor() {
    super(...arguments);
    this.paramsConfig = TextureProperties_ParamsConfig;
    this.textureParamsController = new TextureParamsController/* TextureParamsController */.V(this);
  }
  static type() {
    return "textureProperties";
  }
  initializeNode() {
    this.io.inputs.setCount(1);
    this.io.inputs.initInputsClonedState([InputCloneMode/* InputCloneMode.FROM_NODE */.m.FROM_NODE]);
  }
  cook(input_contents) {
    return TextureProperties_async(this, null, function* () {
      const texture = input_contents[0];
      this.textureParamsController.update(texture);
      this.setTexture(texture);
    });
  }
}

// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/nodes/cop/Video.ts + 1 modules
var Video = __webpack_require__(59407);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/nodes/cop/WebCam.ts
var WebCam = __webpack_require__(37346);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/nodes/cop/_BaseManager.ts
var cop_BaseManager = __webpack_require__(41069);
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/cop/ActorsNetwork.ts







class ActorsNetworkCopNode extends cop_BaseManager/* ParamLessBaseNetworkCopNode */.Q {
  constructor() {
    super(...arguments);
    this._childrenControllerContext = poly_NodeContext/* NodeContext.JS */.sy.JS;
    //
    // ASSEMBLERS
    //
    this.persisted_config = new ActorPersistedConfig/* ActorPersistedConfig */.R(this);
    this._assemblerController = this._createAssemblerController();
    //
    // compilation
    //
    this.compilationController = new ActorCompilationController/* ActorCompilationController */.z7(this);
  }
  static type() {
    return poly_NodeContext/* NetworkNodeType.ACTOR */.kX.ACTOR;
  }
  createNode(node_class, options) {
    return super.createNode(node_class, options);
  }
  children() {
    return super.children();
  }
  nodesByType(type) {
    return super.nodesByType(type);
  }
  //
  childrenAllowed() {
    if (this.assemblerController()) {
      return super.childrenAllowed();
    }
    return false;
  }
  sceneReadonly() {
    return this.assemblerController() == null;
  }
  assemblerController() {
    return this._assemblerController;
  }
  usedAssembler() {
    return _BaseRegister/* AssemblerName.JS_ACTOR */.Q.JS_ACTOR;
  }
  _createAssemblerController() {
    return Poly/* Poly.assemblersRegister.assembler */.L.assemblersRegister.assembler(this, this.usedAssembler());
  }
  compile() {
    this.compilationController.compile();
  }
  cook() {
    this.compilationController.compileIfRequired();
    this.cookController.endCook();
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/cop/AnimationsNetwork.ts



class AnimationsNetworkCopNode extends cop_BaseManager/* ParamLessBaseNetworkCopNode */.Q {
  constructor() {
    super(...arguments);
    this._childrenControllerContext = poly_NodeContext/* NodeContext.ANIM */.sy.ANIM;
  }
  static type() {
    return poly_NodeContext/* NetworkNodeType.ANIM */.kX.ANIM;
  }
  createNode(node_class, options) {
    return super.createNode(node_class, options);
  }
  children() {
    return super.children();
  }
  nodesByType(type) {
    return super.nodesByType(type);
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/cop/AudioNetwork.ts



class AudioNetworkCopNode extends cop_BaseManager/* ParamLessBaseNetworkCopNode */.Q {
  constructor() {
    super(...arguments);
    this._childrenControllerContext = poly_NodeContext/* NodeContext.AUDIO */.sy.AUDIO;
  }
  static type() {
    return poly_NodeContext/* NetworkNodeType.AUDIO */.kX.AUDIO;
  }
  createNode(node_class, options) {
    return super.createNode(node_class, options);
  }
  children() {
    return super.children();
  }
  nodesByType(type) {
    return super.nodesByType(type);
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/cop/EventsNetwork.ts



class EventsNetworkCopNode extends cop_BaseManager/* ParamLessBaseNetworkCopNode */.Q {
  constructor() {
    super(...arguments);
    this._childrenControllerContext = poly_NodeContext/* NodeContext.EVENT */.sy.EVENT;
  }
  static type() {
    return poly_NodeContext/* NetworkNodeType.EVENT */.kX.EVENT;
  }
  createNode(node_class, options) {
    return super.createNode(node_class, options);
  }
  children() {
    return super.children();
  }
  nodesByType(type) {
    return super.nodesByType(type);
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/cop/CopNetwork.ts



class CopNetworkCopNode extends cop_BaseManager/* ParamLessBaseNetworkCopNode */.Q {
  constructor() {
    super(...arguments);
    this._childrenControllerContext = poly_NodeContext/* NodeContext.COP */.sy.COP;
  }
  static type() {
    return poly_NodeContext/* NetworkNodeType.COP */.kX.COP;
  }
  createNode(node_class, options) {
    return super.createNode(node_class, options);
  }
  children() {
    return super.children();
  }
  nodesByType(type) {
    return super.nodesByType(type);
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/cop/MaterialsNetwork.ts



class MaterialsNetworkCopNode extends cop_BaseManager/* ParamLessBaseNetworkCopNode */.Q {
  constructor() {
    super(...arguments);
    this._childrenControllerContext = poly_NodeContext/* NodeContext.MAT */.sy.MAT;
  }
  static type() {
    return poly_NodeContext/* NetworkNodeType.MAT */.kX.MAT;
  }
  createNode(node_class, options) {
    return super.createNode(node_class, options);
  }
  children() {
    return super.children();
  }
  nodesByType(type) {
    return super.nodesByType(type);
  }
}

// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/nodes/cop/PostProcessNetwork.ts
var cop_PostProcessNetwork = __webpack_require__(78124);
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/cop/RenderersNetwork.ts



class RenderersNetworkCopNode extends cop_BaseManager/* ParamLessBaseNetworkCopNode */.Q {
  constructor() {
    super(...arguments);
    this._childrenControllerContext = poly_NodeContext/* NodeContext.ROP */.sy.ROP;
  }
  static type() {
    return poly_NodeContext/* NetworkNodeType.ROP */.kX.ROP;
  }
  createNode(node_class, options) {
    return super.createNode(node_class, options);
  }
  children() {
    return super.children();
  }
  nodesByType(type) {
    return super.nodesByType(type);
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/poly/registers/nodes/Cop.ts











































class CopRegister {
  static run(poly) {
    poly.registerNode(AudioAnalyser/* AudioAnalyserCopNode */.y, CATEGORY_COP.ADVANCED);
    poly.registerNode(Builder/* BuilderCopNode */.G, CATEGORY_COP.ADVANCED);
    poly.registerNode(Builder2DArray/* Builder2DArrayCopNode */.k, CATEGORY_COP.ADVANCED);
    poly.registerNode(CanvasCopNode, CATEGORY_COP.INPUT);
    poly.registerNode(Color/* ColorCopNode */.y, CATEGORY_COP.INPUT);
    poly.registerNode(CubeMap/* CubeMapCopNode */.h, CATEGORY_COP.INPUT);
    poly.registerNode(CubeCamera/* CubeCameraCopNode */.F, CATEGORY_COP.INPUT);
    poly.registerNode(CubeMapFromSceneCopNode, CATEGORY_COP.INPUT);
    poly.registerNode(EnvMapCopNode, CATEGORY_COP.INPUT);
    poly.registerNode(GeometryAttribute/* GeometryAttributeCopNode */.m, CATEGORY_COP.ADVANCED);
    poly.registerNode(Gif/* GifCopNode */.r, CATEGORY_COP.INPUT);
    poly.registerNode(Image/* ImageCopNode */.c, CATEGORY_COP.INPUT);
    poly.registerNode(ImageEXR/* ImageEXRCopNode */.E, CATEGORY_COP.INPUT);
    poly.registerNode(ImageHDR/* ImageHDRCopNode */.E, CATEGORY_COP.INPUT);
    poly.registerNode(ImageKTX2/* ImageKTX2CopNode */.C, CATEGORY_COP.INPUT);
    poly.registerNode(LightMap/* LightMapCopNode */.e, CATEGORY_COP.MISC);
    poly.registerNode(Lut/* LutCopNode */.E, CATEGORY_COP.MISC);
    poly.registerNode(MapboxElevation/* MapboxElevationCopNode */.F, CATEGORY_COP.MAPS);
    poly.registerNode(MapboxSatellite/* MapboxSatelliteCopNode */.w, CATEGORY_COP.MAPS);
    poly.registerNode(NullCopNode, CATEGORY_COP.MISC);
    poly.registerNode(PaletteCopNode, CATEGORY_COP.INPUT);
    poly.registerNode(Fetch/* FetchCopNode */.F, CATEGORY_COP.MISC);
    poly.registerNode(Render/* RenderCopNode */.j, CATEGORY_COP.MISC);
    if (false) {}
    poly.registerNode(SDFExporter/* SDFExporterCopNode */.t, CATEGORY_COP.SDF);
    poly.registerNode(SDFFromObject/* SDFFromObjectCopNode */.g, CATEGORY_COP.SDF);
    poly.registerNode(SDFFromUrl/* SDFFromUrlCopNode */.W, CATEGORY_COP.SDF);
    poly.registerNode(SnapshotCopNode, CATEGORY_COP.MISC);
    poly.registerNode(SwitchCopNode, CATEGORY_COP.MISC);
    poly.registerNode(Text/* TextCopNode */.l, CATEGORY_COP.INPUT);
    poly.registerNode(TexturePropertiesCopNode, CATEGORY_COP.ADVANCED);
    poly.registerNode(Video/* VideoCopNode */.T, CATEGORY_COP.INPUT);
    poly.registerNode(WebCam/* WebCamCopNode */.C, CATEGORY_COP.ADVANCED);
    poly.registerNode(ActorsNetworkCopNode, CATEGORY_COP.NETWORK);
    poly.registerNode(AnimationsNetworkCopNode, CATEGORY_COP.NETWORK);
    poly.registerNode(AudioNetworkCopNode, CATEGORY_COP.NETWORK);
    poly.registerNode(CopNetworkCopNode, CATEGORY_COP.NETWORK);
    poly.registerNode(EventsNetworkCopNode, CATEGORY_COP.NETWORK);
    poly.registerNode(MaterialsNetworkCopNode, CATEGORY_COP.NETWORK);
    poly.registerNode(cop_PostProcessNetwork/* PostProcessNetworkCopNode */.u, CATEGORY_COP.NETWORK);
    poly.registerNode(RenderersNetworkCopNode, CATEGORY_COP.NETWORK);
  }
}

// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/nodes/event/Animation.ts
var Animation = __webpack_require__(91440);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/nodes/event/_Base.ts
var event_Base = __webpack_require__(79282);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/nodes/utils/io/connections/Event.ts
var Event = __webpack_require__(18162);
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/event/Any.ts

var Any_async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};


const OUTPUT_NAME = "event";


class AnyEventParamsConfig extends params_ParamsConfig/* NodeParamsConfig */.yI {
  constructor() {
    super(...arguments);
    /** @param toggle on to ensure events are transfered */
    this.active = params_ParamsConfig/* ParamConfig.BOOLEAN */.XC.BOOLEAN(1);
    /** @param number of possible events */
    this.inputsCount = params_ParamsConfig/* ParamConfig.INTEGER */.XC.INTEGER(5, {
      range: [1, 10],
      rangeLocked: [true, false]
    });
  }
}
const Any_ParamsConfig = new AnyEventParamsConfig();
class AnyEventNode extends event_Base/* TypedEventNode */.F {
  constructor() {
    super(...arguments);
    this.paramsConfig = Any_ParamsConfig;
  }
  static type() {
    return "any";
  }
  initializeNode() {
    this.io.connection_points.set_expected_input_types_function(this._expected_input_types.bind(this));
    this.io.connection_points.set_input_name_function(this._input_name.bind(this));
    this.io.connection_points.set_output_name_function(() => OUTPUT_NAME);
    this.io.connection_points.set_expected_output_types_function(() => [Event/* EventConnectionPointType.BASE */.M$.BASE]);
  }
  _expected_input_types() {
    const list = new Array(this.pv.inputsCount);
    list.fill(Event/* EventConnectionPointType.BASE */.M$.BASE);
    return list;
  }
  _input_name(index) {
    return `trigger${index}`;
  }
  processEvent(event_context) {
    return Any_async(this, null, function* () {
      if (this.p.active.isDirty()) {
        yield this.p.active.compute();
      }
      if ((0,Type/* isBooleanTrue */.bI)(this.pv.active)) {
        this.dispatchEventToOutput(OUTPUT_NAME, event_context);
      }
    });
  }
}

// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/core/audio/Notes.ts
var Notes = __webpack_require__(19286);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/nodes/obj/AudioListener.ts + 1 modules
var AudioListener = __webpack_require__(88012);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/node_modules/tone/build/esm/source/buffer/Player.js
var Player = __webpack_require__(89394);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/core/audio/PlayerCallbacksManager.ts
var PlayerCallbacksManager = __webpack_require__(31222);
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/event/Audio.ts

var Audio_async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};








var AudioEventOutput = /* @__PURE__ */ ((AudioEventOutput2) => {
  AudioEventOutput2["ON_STOP"] = "onStop";
  return AudioEventOutput2;
})(AudioEventOutput || {});
class AudioEventParamsConfig extends params_ParamsConfig/* NodeParamsConfig */.yI {
  constructor() {
    super(...arguments);
    /** @parm audio node */
    this.audio = params_ParamsConfig/* ParamConfig.NODE_PATH */.XC.NODE_PATH("", {
      nodeSelection: { context: poly_NodeContext/* NodeContext.AUDIO */.sy.AUDIO },
      dependentOnFoundNode: false
    });
    /** @param note */
    this.note = params_ParamsConfig/* ParamConfig.STRING */.XC.STRING(Notes/* DEFAULT_NOTE */.Q, {
      menuString: {
        entries: Notes/* ALL_NOTES.sort */.z.sort().map((note) => {
          return { value: note, name: note };
        })
      },
      cook: false
    });
    /** @param duration */
    this.duration = params_ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(0.125, {
      range: [0, 1],
      rangeLocked: [true, false],
      cook: false
    });
    /** @param button to presse to trigger the event */
    this.play = params_ParamsConfig/* ParamConfig.BUTTON */.XC.BUTTON(null, {
      callback: (node) => {
        AudioEventNode.PARAM_CALLBACK_play(node);
      }
    });
  }
  /** @param button to presse to trigger the event */
  // stop = ParamConfig.BUTTON(null, {
  // 	callback: (node: BaseNodeType) => {
  // 		AudioEventNode.PARAM_CALLBACK_stop(node as AudioEventNode);
  // 	},
  // });
}
const Audio_ParamsConfig = new AudioEventParamsConfig();
class AudioEventNode extends event_Base/* TypedEventNode */.F {
  constructor() {
    super(...arguments);
    this.paramsConfig = Audio_ParamsConfig;
    this._onSourcePlayerStopBound = this._onSourcePlayerStop.bind(this);
  }
  static type() {
    return "audio";
  }
  initializeNode() {
    this.io.inputs.setNamedInputConnectionPoints([
      new Event/* EventConnectionPoint */.TG("play", Event/* EventConnectionPointType.BASE */.M$.BASE, this._triggerPlay.bind(this))
      // new EventConnectionPoint('stop', EventConnectionPointType.BASE, this._triggerPlay.bind(this)),
    ]);
    this.io.outputs.setNamedOutputConnectionPoints([
      new Event/* EventConnectionPoint */.TG("onStop" /* ON_STOP */, Event/* EventConnectionPointType.BASE */.M$.BASE)
    ]);
  }
  _triggerPlay(context) {
    this._play();
  }
  _play() {
    return Audio_async(this, null, function* () {
      if (!AudioListener/* AudioListenerObjNode.soundActivated */.C.soundActivated()) {
        console.warn("sound not activated");
        return;
      }
      this.states.error.clear();
      const playable = yield this._getPlayable();
      if (!playable) {
        return;
      }
      const { instrument, source } = playable;
      if (!(instrument || source)) {
        return;
      }
      if (instrument) {
        const note = this.pv.note;
        if (note == "") {
          return;
        }
        instrument.triggerAttackRelease(note, this.pv.duration);
      } else {
        if (source) {
          if (source instanceof Player/* Player */.J) {
            this._sourcePlayer = source;
            this._addPlayerEvent(source);
            source.start();
          }
        }
      }
    });
  }
  dispose() {
    super.dispose();
    this._removePlayerEvent();
  }
  _addPlayerEvent(sourcePlayer) {
    PlayerCallbacksManager/* AudioPlayerCallbacksManager.onStop */.K.onStop(sourcePlayer, this._onSourcePlayerStopBound);
  }
  _removePlayerEvent() {
    if (!this._sourcePlayer) {
      return;
    }
    PlayerCallbacksManager/* AudioPlayerCallbacksManager.removeOnStop */.K.removeOnStop(this._sourcePlayer, this._onSourcePlayerStopBound);
  }
  _onSourcePlayerStop() {
    this.dispatchEventToOutput("onStop" /* ON_STOP */, {});
  }
  // private _stop() {
  // 	const instrument = await this._getInstrument()
  // 	if(!instrument){return}
  // 	instrument.triggerAttackRelease(this.pv.note, this.pv.duration)
  // 	// if (this._prevNote) {
  // 	// 	this._currentSynth.triggerRelease(undefined!);
  // 	// }
  // }
  _getPlayable() {
    return Audio_async(this, null, function* () {
      const param = this.p.audio;
      if (param.isDirty()) {
        yield param.compute();
      }
      const node = param.value.nodeWithContext(poly_NodeContext/* NodeContext.AUDIO */.sy.AUDIO);
      if (!node) {
        return;
      }
      const container = yield node.compute();
      if (!container) {
        return;
      }
      const audioBuilder = container.coreContent();
      if (!audioBuilder) {
        return;
      }
      const instrument = audioBuilder.instrument();
      const source = audioBuilder.source();
      return { instrument, source };
    });
  }
  static PARAM_CALLBACK_play(node) {
    node._play();
  }
  // static PARAM_CALLBACK_stop(node: AudioEventNode) {
  // 	node._stop();
  // }
}

// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/nodes/event/Block.ts
var Block = __webpack_require__(11942);
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/event/Button.ts



var ButtonEventOutput = /* @__PURE__ */ ((ButtonEventOutput2) => {
  ButtonEventOutput2["OUT"] = "out";
  return ButtonEventOutput2;
})(ButtonEventOutput || {});

class ButtonEventParamsConfig extends params_ParamsConfig/* NodeParamsConfig */.yI {
  constructor() {
    super(...arguments);
    /** @param button to presse to trigger the event */
    this.dispatch = params_ParamsConfig/* ParamConfig.BUTTON */.XC.BUTTON(null, {
      callback: (node) => {
        ButtonEventNode.PARAM_CALLBACK_execute(node);
      }
    });
  }
}
const Button_ParamsConfig = new ButtonEventParamsConfig();
class ButtonEventNode extends event_Base/* TypedEventNode */.F {
  constructor() {
    super(...arguments);
    this.paramsConfig = Button_ParamsConfig;
  }
  static type() {
    return "button";
  }
  initializeNode() {
    this.io.outputs.setNamedOutputConnectionPoints([
      new Event/* EventConnectionPoint */.TG("out" /* OUT */, Event/* EventConnectionPointType.BASE */.M$.BASE)
    ]);
  }
  processEvent(event_context) {
  }
  process_event_execute(event_context) {
    this.dispatchEventToOutput("out" /* OUT */, event_context);
  }
  static PARAM_CALLBACK_execute(node) {
    node.process_event_execute({});
  }
}

// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/nodes/event/CameraMapControls.ts + 1 modules
var CameraMapControls = __webpack_require__(99546);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/nodes/event/CameraOrbitControls.ts
var CameraOrbitControls = __webpack_require__(48141);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/nodes/event/_BaseCameraControls.ts
var _BaseCameraControls = __webpack_require__(80359);
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/modules/core/controls/PanZoomControls.ts


const _changeEvent = { type: "change" };
const _startEvent = { type: "start" };
const _endEvent = { type: "end" };
const STATE = {
  NONE: -1,
  // ROTATE: 0,
  DOLLY: 1,
  PAN: 2,
  // TOUCH_ROTATE: 3,
  TOUCH_PAN: 4,
  TOUCH_DOLLY_PAN: 5
  // TOUCH_DOLLY_ROTATE: 6,
};
const EPS = 1e-6;
class PanZoomControls extends three_module.EventDispatcher {
  constructor(object, domElement) {
    super();
    this.object = object;
    this.domElement = domElement;
    this.enabled = true;
    this.enablePan = true;
    this.enableZoom = true;
    this.enableDamping = true;
    this.dampingFactor = 0.05;
    this.panSpeed = 1;
    this.minZoom = 0.1;
    this.maxZoom = 50;
    this.zoomSpeed = 1;
    this.screenSpacePanning = true;
    this.zoomToCursor = true;
    this.clampPosition = false;
    this.positionBounds = new three_module.Box3(
      new three_module.Vector3(-Infinity, -Infinity, -Infinity),
      new three_module.Vector3(Infinity, Infinity, Infinity)
    );
    this.mouseButtons = { LEFT: three_module.MOUSE.ROTATE, MIDDLE: three_module.MOUSE.DOLLY, RIGHT: three_module.MOUSE.PAN };
    this.touches = { ONE: three_module.TOUCH.PAN, TWO: three_module.TOUCH.DOLLY_PAN };
    const panStart = new three_module.Vector2();
    const panEnd = new three_module.Vector2();
    const panDelta = new three_module.Vector2();
    const panOffset = new three_module.Vector3();
    const dollyStart = new three_module.Vector2();
    const dollyEnd = new three_module.Vector2();
    const dollyDelta = new three_module.Vector2();
    this.domElement.style.touchAction = "none";
    const pointers = [];
    const pointerPositions = {};
    let state = STATE.NONE;
    let scale = 1;
    const dollyDirection = new three_module.Vector3();
    const mouse = new three_module.Vector2();
    let performCursorZoom = false;
    const mouseBefore = new three_module.Vector3(0, 0, 0);
    const mouseAfter = new three_module.Vector3(0, 0, 0);
    const getZoomScale = () => {
      return Math.pow(0.95, this.zoomSpeed);
    };
    function addPointer(event) {
      pointers.push(event);
    }
    function removePointer(event) {
      delete pointerPositions[event.pointerId];
      for (let i = 0; i < pointers.length; i++) {
        if (pointers[i].pointerId == event.pointerId) {
          pointers.splice(i, 1);
          return;
        }
      }
    }
    function trackPointer(event) {
      let position = pointerPositions[event.pointerId];
      if (position === void 0) {
        position = new three_module.Vector2();
        pointerPositions[event.pointerId] = position;
      }
      position.set(event.pageX, event.pageY);
    }
    const onContextMenu = (event) => {
      if (this.enabled === false)
        return;
      event.preventDefault();
    };
    const onPointerDown = (event) => {
      if (this.enabled === false)
        return;
      if (pointers.length === 0) {
        this.domElement.setPointerCapture(event.pointerId);
        this.domElement.ownerDocument.addEventListener("pointermove", onPointerMove);
        this.domElement.ownerDocument.addEventListener("pointerup", onPointerUp);
      }
      addPointer(event);
      if (event.pointerType === "touch") {
        onTouchStart(event);
      } else {
        onMouseDown(event);
      }
    };
    const onPointerMove = (event) => {
      if (this.enabled === false)
        return;
      if (event.pointerType === "touch") {
        onTouchMove(event);
      } else {
        onMouseMove(event);
      }
    };
    const onPointerUp = (event) => {
      removePointer(event);
      if (pointers.length === 0) {
        this.domElement.releasePointerCapture(event.pointerId);
        this.domElement.ownerDocument.removeEventListener("pointermove", onPointerMove);
        this.domElement.ownerDocument.removeEventListener("pointerup", onPointerUp);
      }
      this.dispatchEvent(_endEvent);
      state = STATE.NONE;
    };
    const getSecondPointerPosition = (event) => {
      const pointer = event.pointerId === pointers[0].pointerId ? pointers[1] : pointers[0];
      return pointerPositions[pointer.pointerId];
    };
    const handleTouchStartPan = () => {
      if (pointers.length === 1) {
        panStart.set(pointers[0].pageX, pointers[0].pageY);
      } else {
        const x = 0.5 * (pointers[0].pageX + pointers[1].pageX);
        const y = 0.5 * (pointers[0].pageY + pointers[1].pageY);
        panStart.set(x, y);
      }
    };
    const handleTouchStartDolly = () => {
      const dx = pointers[0].pageX - pointers[1].pageX;
      const dy = pointers[0].pageY - pointers[1].pageY;
      const distance = Math.sqrt(dx * dx + dy * dy);
      dollyStart.set(0, distance);
    };
    const handleTouchStartDollyPan = () => {
      if (this.enableZoom)
        handleTouchStartDolly();
      if (this.enablePan)
        handleTouchStartPan();
    };
    const handleMouseDownDolly = (event) => {
      updateMouseParameters(event);
      dollyStart.set(event.clientX, event.clientY);
    };
    const handleMouseDownPan = (event) => {
      panStart.set(event.clientX, event.clientY);
    };
    const handleTouchMovePan = (event) => {
      if (pointers.length === 1) {
        panEnd.set(event.pageX, event.pageY);
      } else {
        const position = getSecondPointerPosition(event);
        const x = 0.5 * (event.pageX + position.x);
        const y = 0.5 * (event.pageY + position.y);
        panEnd.set(x, y);
      }
      panDelta.subVectors(panEnd, panStart).multiplyScalar(this.panSpeed);
      pan(panDelta.x, panDelta.y);
      panStart.copy(panEnd);
    };
    const handleTouchMoveDolly = (event) => {
      const position = getSecondPointerPosition(event);
      const dx = event.pageX - position.x;
      const dy = event.pageY - position.y;
      const distance = Math.sqrt(dx * dx + dy * dy);
      dollyEnd.set(0, distance);
      dollyDelta.set(0, Math.pow(dollyEnd.y / dollyStart.y, this.zoomSpeed));
      dollyOut(dollyDelta.y);
      dollyStart.copy(dollyEnd);
    };
    const handleTouchMoveDollyPan = (event) => {
      if (this.enableZoom)
        handleTouchMoveDolly(event);
      if (this.enablePan)
        handleTouchMovePan(event);
    };
    const handleMouseMoveDolly = (event) => {
      dollyEnd.set(event.clientX, event.clientY);
      dollyDelta.subVectors(dollyEnd, dollyStart);
      if (dollyDelta.y > 0) {
        dollyOut(getZoomScale());
      } else if (dollyDelta.y < 0) {
        dollyIn(getZoomScale());
      }
      dollyStart.copy(dollyEnd);
      this.update(null);
    };
    const handleMouseMovePan = (event) => {
      panEnd.set(event.clientX, event.clientY);
      panDelta.subVectors(panEnd, panStart).multiplyScalar(this.panSpeed);
      pan(panDelta.x, panDelta.y);
      panStart.copy(panEnd);
      this.update(null);
    };
    const dollyOut = (dollyScale) => {
      if (this.object.isPerspectiveCamera || this.object.isOrthographicCamera) {
        scale /= dollyScale;
      } else {
        console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled.");
        this.enableZoom = false;
      }
    };
    const dollyIn = (dollyScale) => {
      if (this.object.isPerspectiveCamera || this.object.isOrthographicCamera) {
        scale *= dollyScale;
      } else {
        console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled.");
        this.enableZoom = false;
      }
    };
    const handleMouseWheel = (event) => {
      updateMouseParameters(event);
      if (event.deltaY < 0) {
        dollyIn(getZoomScale());
      } else if (event.deltaY > 0) {
        dollyOut(getZoomScale());
      }
      this.update(null);
    };
    const onMouseWheel = (event) => {
      if (this.enabled === false || this.enableZoom === false || state !== STATE.NONE)
        return;
      event.preventDefault();
      this.dispatchEvent(_startEvent);
      handleMouseWheel(event);
      this.dispatchEvent(_endEvent);
    };
    const panLeft = (() => {
      const v = new three_module.Vector3();
      const _panLeft = (distance, objectMatrix) => {
        v.setFromMatrixColumn(objectMatrix, 0);
        v.multiplyScalar(-distance);
        panOffset.add(v);
      };
      return _panLeft;
    })();
    const panUp = (() => {
      const v = new three_module.Vector3();
      const _panUp = (distance, objectMatrix) => {
        if (this.screenSpacePanning === true) {
          v.setFromMatrixColumn(objectMatrix, 1);
        } else {
          v.setFromMatrixColumn(objectMatrix, 0);
          v.crossVectors(this.object.up, v);
        }
        v.multiplyScalar(distance);
        panOffset.add(v);
      };
      return _panUp;
    })();
    const pan = (() => {
      const _pan = (deltaX, deltaY) => {
        const element = this.domElement;
        if (this.object.isPerspectiveCamera) {
          const targetDistance = 1;
          panLeft(2 * deltaX * targetDistance / element.clientHeight, this.object.matrix);
          panUp(2 * deltaY * targetDistance / element.clientHeight, this.object.matrix);
        } else if (this.object.isOrthographicCamera) {
          panLeft(
            deltaX * (this.object.right - this.object.left) / this.object.zoom / element.clientWidth,
            this.object.matrix
          );
          panUp(
            deltaY * (this.object.top - this.object.bottom) / this.object.zoom / element.clientHeight,
            this.object.matrix
          );
        } else {
          console.warn("WARNING: PanZoomControls.js encountered an unknown camera type - pan disabled.");
          this.enablePan = false;
        }
      };
      return _pan;
    })();
    const updateMouseParameters = (event) => {
      if (!this.zoomToCursor) {
        return;
      }
      performCursorZoom = true;
      const rect = this.domElement.getBoundingClientRect();
      const x = event.clientX - rect.left;
      const y = event.clientY - rect.top;
      const w = rect.width;
      const h = rect.height;
      mouse.x = x / w * 2 - 1;
      mouse.y = -(y / h) * 2 + 1;
      dollyDirection.set(mouse.x, mouse.y, 1).unproject(this.object).sub(this.object.position).normalize();
    };
    const onTouchStart = (event) => {
      trackPointer(event);
      switch (pointers.length) {
        case 1:
          switch (this.touches.ONE) {
            case three_module.TOUCH.PAN:
              if (this.enablePan === false)
                return;
              handleTouchStartPan();
              state = STATE.TOUCH_PAN;
              break;
            default:
              state = STATE.NONE;
          }
          break;
        case 2:
          switch (this.touches.TWO) {
            case three_module.TOUCH.DOLLY_PAN:
              if (this.enableZoom === false && this.enablePan === false)
                return;
              handleTouchStartDollyPan();
              state = STATE.TOUCH_DOLLY_PAN;
              break;
            default:
              state = STATE.NONE;
          }
          break;
        default:
          state = STATE.NONE;
      }
      if (state !== STATE.NONE) {
        this.dispatchEvent(_startEvent);
      }
    };
    const onMouseDown = (event) => {
      let mouseAction;
      switch (event.button) {
        case 0:
          mouseAction = this.mouseButtons.LEFT;
          break;
        case 1:
          mouseAction = this.mouseButtons.MIDDLE;
          break;
        case 2:
          mouseAction = this.mouseButtons.RIGHT;
          break;
        default:
          mouseAction = -1;
      }
      switch (mouseAction) {
        case three_module.MOUSE.DOLLY:
          if (this.enableZoom === false)
            return;
          handleMouseDownDolly(event);
          state = STATE.DOLLY;
          break;
        case three_module.MOUSE.PAN:
          if (this.enablePan === false)
            return;
          handleMouseDownPan(event);
          state = STATE.PAN;
          break;
        default:
          state = STATE.NONE;
      }
      if (state !== STATE.NONE) {
        this.dispatchEvent(_startEvent);
      }
    };
    const onTouchMove = (event) => {
      trackPointer(event);
      switch (state) {
        case STATE.TOUCH_PAN:
          if (this.enablePan === false)
            return;
          handleTouchMovePan(event);
          this.update(null);
          break;
        case STATE.TOUCH_DOLLY_PAN:
          if (this.enableZoom === false && this.enablePan === false)
            return;
          handleTouchMoveDollyPan(event);
          this.update(null);
          break;
        default:
          state = STATE.NONE;
      }
    };
    const onMouseMove = (event) => {
      switch (state) {
        case STATE.DOLLY:
          if (this.enableZoom === false)
            return;
          handleMouseMoveDolly(event);
          break;
        case STATE.PAN:
          if (this.enablePan === false)
            return;
          handleMouseMovePan(event);
          break;
      }
    };
    this.update = (() => {
      const lastPosition = new three_module.Vector3();
      const _update = (deltaTime = null) => {
        const position = this.object.position;
        if (this.enableDamping === true) {
          this.object.position.addScaledVector(panOffset, this.dampingFactor);
        } else {
          this.object.position.add(panOffset);
        }
        const _clampPosition = () => {
          if (this.clampPosition) {
            position.clamp(this.positionBounds.min, this.positionBounds.max);
          }
        };
        _clampPosition();
        if (this.enableDamping === true) {
          panOffset.multiplyScalar(1 - this.dampingFactor);
        } else {
          panOffset.set(0, 0, 0);
        }
        let zoomChanged = false;
        if (this.zoomToCursor && performCursorZoom) {
          if (this.object.isPerspectiveCamera) {
            console.warn("zoom currently unsupported for perspective cameras");
          } else if (this.object.isOrthographicCamera) {
            mouseBefore.x = mouse.x;
            mouseBefore.y = mouse.y;
            mouseBefore.z = 0;
            mouseBefore.unproject(this.object);
            this.object.zoom = Math.max(
              this.minZoom,
              Math.min(this.maxZoom, this.object.zoom / scale)
            );
            this.object.updateProjectionMatrix();
            zoomChanged = true;
            mouseAfter.x = mouse.x;
            mouseAfter.y = mouse.y;
            mouseAfter.z = 0;
            mouseAfter.unproject(this.object);
            this.object.position.sub(mouseAfter).add(mouseBefore);
            _clampPosition();
            this.object.updateMatrixWorld();
          } else {
            console.warn(
              "WARNING: OrbitControls.js encountered an unknown camera type - zoom to cursor disabled."
            );
            this.zoomToCursor = false;
          }
        }
        if (this.object.isOrthographicCamera) {
          this.object.zoom = Math.max(
            this.minZoom,
            Math.min(this.maxZoom, this.object.zoom / scale)
          );
          this.object.updateProjectionMatrix();
          zoomChanged = true;
        }
        scale = 1;
        performCursorZoom = false;
        if (zoomChanged || lastPosition.distanceToSquared(this.object.position) > EPS) {
          this.dispatchEvent(_changeEvent);
          lastPosition.copy(this.object.position);
          zoomChanged = false;
          return true;
        }
        return false;
      };
      return _update;
    })();
    this.dispose = () => {
      this.domElement.removeEventListener("contextmenu", onContextMenu);
      this.domElement.removeEventListener("pointerdown", onPointerDown);
      this.domElement.removeEventListener("pointercancel", onPointerUp);
      this.domElement.removeEventListener("wheel", onMouseWheel);
      this.domElement.ownerDocument.removeEventListener("pointermove", onPointerMove);
      this.domElement.ownerDocument.removeEventListener("pointerup", onPointerUp);
    };
    this.domElement.addEventListener("contextmenu", onContextMenu);
    this.domElement.addEventListener("pointerdown", onPointerDown);
    this.domElement.addEventListener("pointercancel", onPointerUp);
    this.domElement.addEventListener("wheel", onMouseWheel, { passive: false });
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/event/CameraPanZoomControls.ts

var CameraPanZoomControls_async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};







const OUTPUT_START = "start";
const OUTPUT_CHANGE = "change";
const OUTPUT_END = "end";
var MouseControl = /* @__PURE__ */ ((MouseControl2) => {
  MouseControl2["PAN"] = "pan";
  MouseControl2["DOLLY"] = "dolly";
  MouseControl2["NO_ACTION"] = "no action";
  return MouseControl2;
})(MouseControl || {});
const MOUSE_CONTROLS = ["dolly" /* DOLLY */, "pan" /* PAN */, "no action" /* NO_ACTION */];
var TouchControl = /* @__PURE__ */ ((TouchControl2) => {
  TouchControl2["PAN"] = "pan";
  TouchControl2["DOLLY_PAN"] = "dolly + pan";
  TouchControl2["NO_ACTION"] = "no action";
  return TouchControl2;
})(TouchControl || {});
const TOUCH_CONTROLS = ["pan" /* PAN */, "dolly + pan" /* DOLLY_PAN */, "no action" /* NO_ACTION */];
const THREE_MOUSE_BY_MOUSE_CONTROL = {
  ["dolly" /* DOLLY */]: three_module.MOUSE.DOLLY,
  ["pan" /* PAN */]: three_module.MOUSE.PAN,
  ["no action" /* NO_ACTION */]: null
};
const THREE_TOUCH_BY_TOUCH_CONTROL = {
  ["pan" /* PAN */]: three_module.TOUCH.PAN,
  ["dolly + pan" /* DOLLY_PAN */]: three_module.TOUCH.DOLLY_PAN,
  ["no action" /* NO_ACTION */]: null
};
class CameraPanZoomEventParamsConfig extends params_ParamsConfig/* NodeParamsConfig */.yI {
  constructor() {
    super(...arguments);
    this.main = params_ParamsConfig/* ParamConfig.FOLDER */.XC.FOLDER();
    /** @param enable/disable */
    this.enabled = params_ParamsConfig/* ParamConfig.BOOLEAN */.XC.BOOLEAN(1);
    /** @param toggle on to allow pan */
    this.allowPan = params_ParamsConfig/* ParamConfig.BOOLEAN */.XC.BOOLEAN(1);
    /** @param toggle on to allow zoom */
    this.allowZoom = params_ParamsConfig/* ParamConfig.BOOLEAN */.XC.BOOLEAN(1);
    /** @param zoom speed */
    this.zoomSpeed = params_ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(1, {
      range: [0, 2],
      rangeLocked: [true, false],
      visibleIf: {
        allowZoom: 1
      }
    });
    /** @param zoom to cursor */
    this.zoomToCursor = params_ParamsConfig/* ParamConfig.BOOLEAN */.XC.BOOLEAN(1, {
      visibleIf: {
        allowZoom: 1
      }
    });
    /** @param toggle on to have damping */
    this.tdamping = params_ParamsConfig/* ParamConfig.BOOLEAN */.XC.BOOLEAN(1);
    /** @param damping value */
    this.damping = params_ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(0.1, {
      visibleIf: { tdamping: true }
    });
    /** @param toggle on to have the pan in screen space */
    this.screenSpacePanning = params_ParamsConfig/* ParamConfig.BOOLEAN */.XC.BOOLEAN(1);
    this.limits = params_ParamsConfig/* ParamConfig.FOLDER */.XC.FOLDER();
    /** @param smallest distance the camera can go to the target (perspective cameras only) */
    // minDistance = ParamConfig.FLOAT(0.1, {
    // 	range: [0.1, 100],
    // 	rangeLocked: [true, false],
    // });
    // /** @param max distance the camera can go away the target (perspective cameras only) */
    // maxDistance = ParamConfig.FLOAT(50, {
    // 	range: [0, 100],
    // 	rangeLocked: [true, false],
    // });
    /** @param min zoom (orthographic cameras only) */
    this.minZoom = params_ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(0.01, {
      range: [0.01, 100],
      rangeLocked: [true, false]
    });
    /** @param max zoom (orthographic cameras only) */
    this.maxZoom = params_ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(50, {
      range: [0, 100],
      rangeLocked: [true, false]
    });
    /** @param clamp position */
    this.clampPosition = params_ParamsConfig/* ParamConfig.BOOLEAN */.XC.BOOLEAN(false);
    /** @param min position */
    this.positionMin = params_ParamsConfig/* ParamConfig.VECTOR3 */.XC.VECTOR3([-10, -10, -10], {
      visibleIf: { clampPosition: 1 }
    });
    /** @param max position */
    this.positionMax = params_ParamsConfig/* ParamConfig.VECTOR3 */.XC.VECTOR3([10, 10, 10], {
      visibleIf: { clampPosition: 1 }
    });
    this.controls = params_ParamsConfig/* ParamConfig.FOLDER */.XC.FOLDER();
    /** @param leftMouseButton */
    this.leftMouseButton = params_ParamsConfig/* ParamConfig.INTEGER */.XC.INTEGER(MOUSE_CONTROLS.indexOf("pan" /* PAN */), {
      menu: {
        entries: MOUSE_CONTROLS.map((name, value) => ({ name, value }))
      }
    });
    /** @param leftMouseButton */
    this.middleMouseButton = params_ParamsConfig/* ParamConfig.INTEGER */.XC.INTEGER(MOUSE_CONTROLS.indexOf("dolly" /* DOLLY */), {
      menu: {
        entries: MOUSE_CONTROLS.map((name, value) => ({ name, value }))
      }
    });
    /** @param leftMouseButton */
    this.rightMouseButton = params_ParamsConfig/* ParamConfig.INTEGER */.XC.INTEGER(MOUSE_CONTROLS.indexOf("pan" /* PAN */), {
      menu: {
        entries: MOUSE_CONTROLS.map((name, value) => ({ name, value }))
      }
    });
    /** @param 1 finger touch */
    this.oneFingerTouch = params_ParamsConfig/* ParamConfig.INTEGER */.XC.INTEGER(TOUCH_CONTROLS.indexOf("pan" /* PAN */), {
      menu: {
        entries: TOUCH_CONTROLS.map((name, value) => ({ name, value }))
      },
      separatorBefore: true
    });
    /** @param 2 fingers touch */
    this.twoFingersTouch = params_ParamsConfig/* ParamConfig.INTEGER */.XC.INTEGER(TOUCH_CONTROLS.indexOf("dolly + pan" /* DOLLY_PAN */), {
      menu: {
        entries: TOUCH_CONTROLS.map((name, value) => ({ name, value }))
      }
    });
  }
}
const CameraPanZoomControls_ParamsConfig = new CameraPanZoomEventParamsConfig();
class CameraPanZoomControlsEventNode extends _BaseCameraControls/* TypedCameraControlsEventNode */.l {
  constructor() {
    super(...arguments);
    this.paramsConfig = CameraPanZoomControls_ParamsConfig;
    this._controlsByElementId = /* @__PURE__ */ new Map();
  }
  static type() {
    return poly_NodeContext/* CameraControlsNodeType.PAN_ZOOM */.MN.PAN_ZOOM;
  }
  endEventName() {
    return "end";
  }
  initializeNode() {
    this.io.outputs.setNamedOutputConnectionPoints([
      new Event/* EventConnectionPoint */.TG(OUTPUT_START, Event/* EventConnectionPointType.BASE */.M$.BASE),
      new Event/* EventConnectionPoint */.TG(OUTPUT_CHANGE, Event/* EventConnectionPointType.BASE */.M$.BASE),
      new Event/* EventConnectionPoint */.TG(OUTPUT_END, Event/* EventConnectionPointType.BASE */.M$.BASE)
    ]);
  }
  _createControls(camera, element) {
    return new PanZoomControls(camera, element);
  }
  createControlsInstance(camera, element) {
    return CameraPanZoomControls_async(this, null, function* () {
      const controls = this._createControls(camera, element);
      this._controlsByElementId.set(element.id, controls);
      this._updateCache();
      this._bind_listeners_to_controls_instance(controls);
      return controls;
    });
  }
  _bind_listeners_to_controls_instance(controls) {
    controls.addEventListener("start", () => {
      this.dispatchEventToOutput(OUTPUT_START, {});
    });
    controls.addEventListener("change", () => {
      this.dispatchEventToOutput(OUTPUT_CHANGE, {});
    });
    controls.addEventListener("end", () => {
      this.dispatchEventToOutput(OUTPUT_END, {});
    });
  }
  setupControls(controls) {
    controls.enabled = (0,Type/* isBooleanTrue */.bI)(this.pv.enabled);
    controls.enablePan = (0,Type/* isBooleanTrue */.bI)(this.pv.allowPan);
    controls.enableZoom = (0,Type/* isBooleanTrue */.bI)(this.pv.allowZoom);
    controls.zoomSpeed = this.pv.zoomSpeed;
    controls.zoomToCursor = (0,Type/* isBooleanTrue */.bI)(this.pv.zoomToCursor);
    controls.enableDamping = (0,Type/* isBooleanTrue */.bI)(this.pv.tdamping);
    controls.dampingFactor = this.pv.damping;
    controls.screenSpacePanning = (0,Type/* isBooleanTrue */.bI)(this.pv.screenSpacePanning);
    controls.minZoom = this.pv.minZoom;
    controls.maxZoom = this.pv.maxZoom;
    controls.clampPosition = this.pv.clampPosition;
    controls.positionBounds.min.copy(this.pv.positionMin);
    controls.positionBounds.max.copy(this.pv.positionMax);
    if (controls.enabled) {
      controls.update(null);
    }
    controls.mouseButtons.LEFT = THREE_MOUSE_BY_MOUSE_CONTROL[MOUSE_CONTROLS[this.pv.leftMouseButton]];
    controls.mouseButtons.MIDDLE = THREE_MOUSE_BY_MOUSE_CONTROL[MOUSE_CONTROLS[this.pv.middleMouseButton]];
    controls.mouseButtons.RIGHT = THREE_MOUSE_BY_MOUSE_CONTROL[MOUSE_CONTROLS[this.pv.rightMouseButton]];
    controls.touches.ONE = THREE_TOUCH_BY_TOUCH_CONTROL[TOUCH_CONTROLS[this.pv.oneFingerTouch]];
    controls.touches.TWO = THREE_TOUCH_BY_TOUCH_CONTROL[TOUCH_CONTROLS[this.pv.twoFingersTouch]];
  }
  // private _set_azimuth_angle(controls: OrbitControls) {
  // 	if (isBooleanTrue(this.pv.limitAzimuthAngle)) {
  // 		controls.minAzimuthAngle = this.pv.azimuthAngleRange.x;
  // 		controls.maxAzimuthAngle = this.pv.azimuthAngleRange.y;
  // 	} else {
  // 		controls.minAzimuthAngle = Infinity;
  // 		controls.maxAzimuthAngle = Infinity;
  // 	}
  // }
  updateRequired() {
    return false;
  }
  // set_from_camera_node(controls: CameraControls, camera_node: BaseCameraObjNodeType): void {
  // 	const target = camera_node.params.vector3('target');
  // 	controls.target.copy(target);
  // 	console.warn('set from camera node');
  // }
  // private _on_controls_end(controls: OrbitControls) {
  // 	if (!isBooleanTrue(this.pv.updateTargetEndMoveEnd)) {
  // 		return;
  // 	}
  // 	if (!isBooleanTrue(this.pv.allowPan)) {
  // 		// target should not be updated if pan is not allowed
  // 		return;
  // 	}
  // 	controls.target.toArray(_targetArray);
  // 	this.p.target.set(_targetArray);
  // }
  // static PARAM_CALLBACK_updateTarget(node: CameraPanZoomControlsEventNode) {
  // 	node._updateTarget();
  // }
  // private _updateTarget() {
  // 	this.setTarget(this.pv.target);
  // }
  // target(target: Vector3) {
  // 	if (!this._firstControls) {
  // 		return;
  // 	}
  // 	target.copy(this._firstControls.target);
  // }
  // setTarget(newTarget: Vector3) {
  // 	this._controlsByElementId.forEach((control, element_id) => {
  // 		const destTarget = control.target;
  // 		if (!destTarget.equals(newTarget)) {
  // 			destTarget.copy(newTarget);
  // 			control.update();
  // 		}
  // 	});
  // }
  disposeControlsForHtmlElementId(html_element_id) {
    const controls = this._controlsByElementId.get(html_element_id);
    if (controls) {
      this._controlsByElementId.delete(html_element_id);
    }
    this._updateCache();
  }
  _updateCache() {
    this._firstControls = void 0;
    this._controlsByElementId.forEach((controls) => {
      this._firstControls = this._firstControls || controls;
    });
  }
}

// EXTERNAL MODULE: ../@polygonjs/polygonjs/node_modules/lodash-es/debounce.js + 5 modules
var debounce = __webpack_require__(67773);
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/event/Debounce.ts

var Debounce_defProp = Object.defineProperty;
var Debounce_getOwnPropSymbols = Object.getOwnPropertySymbols;
var Debounce_hasOwnProp = Object.prototype.hasOwnProperty;
var Debounce_propIsEnum = Object.prototype.propertyIsEnumerable;
var Debounce_defNormalProp = (obj, key, value) => key in obj ? Debounce_defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var Debounce_spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (Debounce_hasOwnProp.call(b, prop))
      Debounce_defNormalProp(a, prop, b[prop]);
  if (Debounce_getOwnPropSymbols)
    for (var prop of Debounce_getOwnPropSymbols(b)) {
      if (Debounce_propIsEnum.call(b, prop))
        Debounce_defNormalProp(a, prop, b[prop]);
    }
  return a;
};




const callbackOption = {
  callback: (node) => {
    DebounceEventNode.PARAM_CALLBACK_resetDebouncedFunc(node);
  }
};
class DebounceEventParamsConfig extends params_ParamsConfig/* NodeParamsConfig */.yI {
  constructor() {
    super(...arguments);
    /** @param max wait time between each event, in milliseconds */
    this.maxwait = params_ParamsConfig/* ParamConfig.INTEGER */.XC.INTEGER(100, Debounce_spreadValues({
      range: [0, 1e3],
      rangeLocked: [true, false]
    }, callbackOption));
    /** @param defines if event is dispatched on the leading edge of the timeout */
    this.leading = params_ParamsConfig/* ParamConfig.BOOLEAN */.XC.BOOLEAN(false, callbackOption);
    /** @param defines if event is trailing on the leading edge of the timeout */
    this.trailing = params_ParamsConfig/* ParamConfig.BOOLEAN */.XC.BOOLEAN(true, callbackOption);
  }
}
const Debounce_ParamsConfig = new DebounceEventParamsConfig();
const _DebounceEventNode = class extends event_Base/* TypedEventNode */.F {
  constructor() {
    super(...arguments);
    this.paramsConfig = Debounce_ParamsConfig;
  }
  static type() {
    return "debounce";
  }
  initializeNode() {
    this.io.inputs.setNamedInputConnectionPoints([
      new Event/* EventConnectionPoint */.TG("trigger", Event/* EventConnectionPointType.BASE */.M$.BASE)
    ]);
    this.io.outputs.setNamedOutputConnectionPoints([
      new Event/* EventConnectionPoint */.TG(_DebounceEventNode.OUTPUT_NAME, Event/* EventConnectionPointType.BASE */.M$.BASE)
    ]);
  }
  processEvent(eventContext) {
    this._lastEventContextReceived = eventContext;
    this._debouncedFunc = this._debouncedFunc || this._buildDebouncedFunc();
    this._debouncedFunc();
  }
  _buildDebouncedFunc() {
    const { leading, trailing, maxwait } = this.pv;
    const func = () => {
      if (this._lastEventContextReceived) {
        this.dispatchEventToOutput(_DebounceEventNode.OUTPUT_NAME, this._lastEventContextReceived);
      }
    };
    return (0,debounce/* default */.Z)(func, maxwait, { leading, trailing });
  }
  _resetDebouncedFunc() {
    this._debouncedFunc = void 0;
  }
  static PARAM_CALLBACK_resetDebouncedFunc(node) {
    node._resetDebouncedFunc();
  }
};
let DebounceEventNode = _DebounceEventNode;
DebounceEventNode.OUTPUT_NAME = "output";

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/event/Delay.ts


const INPUT_NAME = "in";
const Delay_OUTPUT_NAME = "out";


class DelayEventParamsConfig extends params_ParamsConfig/* NodeParamsConfig */.yI {
  constructor() {
    super(...arguments);
    /** @param delay before dispatching (in milliseconds) */
    this.delay = params_ParamsConfig/* ParamConfig.INTEGER */.XC.INTEGER(1e3, {
      range: [0, 1e3],
      rangeLocked: [true, false]
    });
  }
}
const Delay_ParamsConfig = new DelayEventParamsConfig();
class DelayEventNode extends event_Base/* TypedEventNode */.F {
  constructor() {
    super(...arguments);
    this.paramsConfig = Delay_ParamsConfig;
  }
  static type() {
    return "delay";
  }
  initializeNode() {
    this.io.inputs.setNamedInputConnectionPoints([
      new Event/* EventConnectionPoint */.TG(INPUT_NAME, Event/* EventConnectionPointType.BASE */.M$.BASE, this._process_input.bind(this))
    ]);
    this.io.outputs.setNamedOutputConnectionPoints([
      new Event/* EventConnectionPoint */.TG(Delay_OUTPUT_NAME, Event/* EventConnectionPointType.BASE */.M$.BASE)
    ]);
  }
  _process_input(event_context) {
    setTimeout(() => {
      this.dispatchEventToOutput(Delay_OUTPUT_NAME, event_context);
    }, this.pv.delay);
  }
}

// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/params/utils/OptionsController.ts
var OptionsController = __webpack_require__(94051);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/nodes/utils/code/controllers/TranspiledFilter.ts
var TranspiledFilter = __webpack_require__(89487);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/core/code/FunctionBuilderUtils.ts
var FunctionBuilderUtils = __webpack_require__(99882);
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/event/Code.ts








const DEFAULT_TS = `
export class EventProcessor extends BaseCodeEventProcessor {
	override initializeProcessor(){
	}
	override processTrigger0(eventContext: EventContext<MouseEvent>){
		this.dispatchEventToOutput('output0', eventContext);
	}
	override processTrigger1(eventContext: EventContext<MouseEvent>){
		this.dispatchEventToOutput('output1', eventContext);
	}
	override processTrigger2(eventContext: EventContext<MouseEvent>){
		this.dispatchEventToOutput('output2', eventContext);
	}
	override processTrigger3(eventContext: EventContext<MouseEvent>){
		this.dispatchEventToOutput('output3', eventContext);
	}
	override processTrigger4(eventContext: EventContext<MouseEvent>){
		this.dispatchEventToOutput('output4', eventContext);
	}
}
`;
const DEFAULT_JS = DEFAULT_TS.replace(/\:\sEventContext<MouseEvent>/g, "").replace(/override\s/g, "");
class BaseCodeEventProcessor extends FunctionBuilderUtils/* BaseCodeProcessor */.h {
  constructor(node) {
    super(node);
    this.node = node;
    this.initializeProcessor();
  }
  get pv() {
    return this.node.pv;
  }
  get p() {
    return this.node.p;
  }
  get io() {
    return this.node.io;
  }
  initializeProcessor() {
  }
  processTrigger0(eventContext) {
  }
  processTrigger1(eventContext) {
  }
  processTrigger2(eventContext) {
  }
  processTrigger3(eventContext) {
  }
  processTrigger4(eventContext) {
  }
  dispatchEventToOutput(outputName, eventContext) {
    this.node._dispatchEventToOutputFromProcessor(outputName, eventContext);
  }
}
class CodeEventParamsConfig extends params_ParamsConfig/* NodeParamsConfig */.yI {
  constructor() {
    super(...arguments);
    this.codeTypescript = params_ParamsConfig/* ParamConfig.STRING */.XC.STRING(DEFAULT_TS, {
      hideLabel: true,
      language: OptionsController/* StringParamLanguage.TYPESCRIPT */.qs.TYPESCRIPT
    });
    this.codeJavascript = params_ParamsConfig/* ParamConfig.STRING */.XC.STRING(DEFAULT_JS, { hidden: true });
  }
}
const Code_ParamsConfig = new CodeEventParamsConfig();
class CodeEventNode extends event_Base/* TypedEventNode */.F {
  constructor() {
    super(...arguments);
    this.paramsConfig = Code_ParamsConfig;
  }
  static type() {
    return "code";
  }
  initializeNode() {
    this.io.inputs.setNamedInputConnectionPoints([
      new Event/* EventConnectionPoint */.TG("trigger0", Event/* EventConnectionPointType.BASE */.M$.BASE, this._processTrigger0.bind(this)),
      new Event/* EventConnectionPoint */.TG("trigger1", Event/* EventConnectionPointType.BASE */.M$.BASE, this._processTrigger1.bind(this)),
      new Event/* EventConnectionPoint */.TG("trigger2", Event/* EventConnectionPointType.BASE */.M$.BASE, this._processTrigger2.bind(this)),
      new Event/* EventConnectionPoint */.TG("trigger3", Event/* EventConnectionPointType.BASE */.M$.BASE, this._processTrigger3.bind(this)),
      new Event/* EventConnectionPoint */.TG("trigger4", Event/* EventConnectionPointType.BASE */.M$.BASE, this._processTrigger4.bind(this))
    ]);
    this.io.outputs.setNamedOutputConnectionPoints([
      new Event/* EventConnectionPoint */.TG("output0", Event/* EventConnectionPointType.BASE */.M$.BASE),
      new Event/* EventConnectionPoint */.TG("output1", Event/* EventConnectionPointType.BASE */.M$.BASE),
      new Event/* EventConnectionPoint */.TG("output2", Event/* EventConnectionPointType.BASE */.M$.BASE),
      new Event/* EventConnectionPoint */.TG("output3", Event/* EventConnectionPointType.BASE */.M$.BASE),
      new Event/* EventConnectionPoint */.TG("output4", Event/* EventConnectionPointType.BASE */.M$.BASE)
    ]);
  }
  _processTrigger0(event_context) {
    var _a;
    this._compileIfRequired();
    (_a = this._processor) == null ? void 0 : _a.processTrigger0(event_context);
  }
  _processTrigger1(event_context) {
    var _a;
    this._compileIfRequired();
    (_a = this._processor) == null ? void 0 : _a.processTrigger1(event_context);
  }
  _processTrigger2(event_context) {
    var _a;
    this._compileIfRequired();
    (_a = this._processor) == null ? void 0 : _a.processTrigger2(event_context);
  }
  _processTrigger3(event_context) {
    var _a;
    this._compileIfRequired();
    (_a = this._processor) == null ? void 0 : _a.processTrigger3(event_context);
  }
  _processTrigger4(event_context) {
    var _a;
    this._compileIfRequired();
    (_a = this._processor) == null ? void 0 : _a.processTrigger4(event_context);
  }
  _dispatchEventToOutputFromProcessor(outputName, eventContext) {
    this.dispatchEventToOutput(outputName, eventContext);
  }
  _compileIfRequired() {
    if (!this._processor || this._lastCompiledCode != this.pv.codeJavascript) {
      this._compile();
    }
  }
  _compile() {
    this._processor = void 0;
    try {
      const functionBody = `try {
				${TranspiledFilter/* TranspiledFilter.filter */.k.filter(this.pv.codeJavascript)}
			} catch(e) {
				states.error.set(e)
			}`;
      const ProcessorClass = (0,FunctionBuilderUtils/* buildCodeNodeFunction */.A)({
        BaseCodeProcessor: BaseCodeEventProcessor,
        BaseCodeProcessorName: "BaseCodeEventProcessor",
        node: this,
        functionBody
      });
      if (ProcessorClass) {
        this._processor = new ProcessorClass(this);
        this._lastCompiledCode = this.pv.codeJavascript;
      } else {
        this.states.error.set(`cannot generate function`);
        Poly/* Poly.warn */.L.warn(functionBody);
      }
    } catch (e) {
      Poly/* Poly.warn */.L.warn(e);
      this.states.error.set(`cannot generate function (${e})`);
    }
  }
}
// adding BaseCodeEventProcessor seems necessary to have the bundled types include it
CodeEventNode.BaseCodeEventProcessor = BaseCodeEventProcessor;

// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/nodes/event/Drag.ts
var Drag = __webpack_require__(39015);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/nodes/event/FirstPersonControls.ts + 2 modules
var FirstPersonControls = __webpack_require__(28962);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/core/geometry/Constant.ts
var Constant = __webpack_require__(91568);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/poly/Assert.ts
var Assert = __webpack_require__(68239);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/core/geometry/CoreObjectFactory.ts
var CoreObjectFactory = __webpack_require__(17353);
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/core/geometry/intersect/CoreIntersect.ts





const _vA = new three_module.Vector3();
const _vB = new three_module.Vector3();
const _vC = new three_module.Vector3();
const _uvA = new three_module.Vector2();
const _uvB = new three_module.Vector2();
const _uvC = new three_module.Vector2();
const _hitUV = new three_module.Vector2();
function resolveIntersectGeometryAttribute(intersection, attribName, attribType) {
  const objectType = (0,Constant/* objectTypeFromObject */.c9)(intersection.object);
  switch (objectType) {
    case Constant/* ObjectType.MESH */.LP.MESH:
      return resolveGeometryAttributeForMesh(intersection, attribName, attribType);
    case Constant/* ObjectType.POINTS */.LP.POINTS:
      return resolveGeometryAttributeForPoint(intersection, attribName, attribType);
  }
}
function resolveGeometryAttributeForMesh(intersection, attribName, attribType) {
  const geometry = intersection.object.geometry;
  if (geometry) {
    const attribute = geometry.getAttribute(attribName);
    if (attribute) {
      switch (attribType) {
        case Constant/* AttribType.NUMERIC */.rp.NUMERIC: {
          const position = geometry.getAttribute("position");
          if (intersection.face) {
            _vA.fromBufferAttribute(position, intersection.face.a);
            _vB.fromBufferAttribute(position, intersection.face.b);
            _vC.fromBufferAttribute(position, intersection.face.c);
            _uvA.fromBufferAttribute(attribute, intersection.face.a);
            _uvB.fromBufferAttribute(attribute, intersection.face.b);
            _uvC.fromBufferAttribute(attribute, intersection.face.c);
            intersection.uv = three_module.Triangle.getInterpolation(
              intersection.point,
              _vA,
              _vB,
              _vC,
              _uvA,
              _uvB,
              _uvC,
              _hitUV
            );
            return _hitUV.x;
          }
          return;
        }
        case Constant/* AttribType.STRING */.rp.STRING: {
          const corePointClass = (0,CoreObjectFactory/* corePointClassFactory */.E_)(intersection.object);
          return corePointClass.stringAttribValue(intersection.object, 0, attribName);
        }
      }
      Assert/* TypeAssert.unreachable */.f.unreachable(attribType);
    }
  }
}
function resolveGeometryAttributeForPoint(intersection, attribName, attribType) {
  const geometry = intersection.object.geometry;
  if (geometry && intersection.index != null) {
    switch (attribType) {
      case Constant/* AttribType.NUMERIC */.rp.NUMERIC: {
        const attribute = geometry.getAttribute(attribName);
        if (attribute) {
          return attribute.array[intersection.index];
        }
        return;
      }
      case Constant/* AttribType.STRING */.rp.STRING: {
        const corePointClass = (0,CoreObjectFactory/* corePointClassFactory */.E_)(intersection.object);
        return corePointClass.stringAttribValue(intersection.object, intersection.index, attribName);
      }
    }
    Assert/* TypeAssert.unreachable */.f.unreachable(attribType);
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/event/IntersectData.ts









var TargetType = /* @__PURE__ */ ((TargetType2) => {
  TargetType2["SCENE_GRAPH"] = "scene graph";
  TargetType2["NODE"] = "node";
  return TargetType2;
})(TargetType || {});
const TARGET_TYPES = (/* unused pure expression or super */ null && (["scene graph" /* SCENE_GRAPH */, "node" /* NODE */]));
class IntersectDataParamsConfig extends params_ParamsConfig/* NodeParamsConfig */.yI {
  constructor() {
    super(...arguments);
    /** @param geometry vertex attribute to read */
    this.attributeName = params_ParamsConfig/* ParamConfig.STRING */.XC.STRING("id", {
      cook: false
    });
    /** @param type of attribute */
    this.attributeType = params_ParamsConfig/* ParamConfig.INTEGER */.XC.INTEGER(Constant/* ATTRIBUTE_TYPES.indexOf */.Xu.indexOf(Constant/* AttribType.NUMERIC */.rp.NUMERIC), {
      menu: {
        entries: Constant/* AttribTypeMenuEntries */.mb
      }
    });
    /** @param attribute value for float */
    this.attributeValue1 = params_ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(0, {
      cook: false,
      visibleIf: {
        attributeType: Constant/* ATTRIBUTE_TYPES.indexOf */.Xu.indexOf(Constant/* AttribType.NUMERIC */.rp.NUMERIC)
      }
    });
    /** @param attribute value that attributeValue1 is set to when no object is intersected */
    this.resetValue1 = params_ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(-1, {
      cook: false,
      visibleIf: {
        attributeType: Constant/* ATTRIBUTE_TYPES.indexOf */.Xu.indexOf(Constant/* AttribType.NUMERIC */.rp.NUMERIC)
      }
    });
    /** @param attribute value for string */
    this.attributeValues = params_ParamsConfig/* ParamConfig.STRING */.XC.STRING("", {
      visibleIf: {
        attributeType: Constant/* ATTRIBUTE_TYPES.indexOf */.Xu.indexOf(Constant/* AttribType.STRING */.rp.STRING)
      }
    });
    /** @param attribute value that attributeValues is set to when no object is intersected */
    this.resetValues = params_ParamsConfig/* ParamConfig.STRING */.XC.STRING("", {
      visibleIf: {
        attributeType: Constant/* ATTRIBUTE_TYPES.indexOf */.Xu.indexOf(Constant/* AttribType.STRING */.rp.STRING)
      }
    });
  }
}
const IntersectData_ParamsConfig = new IntersectDataParamsConfig();
const _IntersectDataEventNode = class extends event_Base/* TypedEventNode */.F {
  constructor() {
    super(...arguments);
    this.paramsConfig = IntersectData_ParamsConfig;
  }
  static type() {
    return "intersectData";
  }
  initializeNode() {
    this.io.inputs.setNamedInputConnectionPoints([
      new Event/* EventConnectionPoint */.TG(
        _IntersectDataEventNode.INPUT_HIT,
        Event/* EventConnectionPointType.BASE */.M$.BASE,
        this._processHit.bind(this)
      ),
      new Event/* EventConnectionPoint */.TG(
        _IntersectDataEventNode.INPUT_MISS,
        Event/* EventConnectionPointType.BASE */.M$.BASE,
        this._processMiss.bind(this)
      )
    ]);
  }
  _processHit(context) {
    var _a;
    const intersect = (_a = context.value) == null ? void 0 : _a.intersect;
    if (!intersect) {
      return;
    }
    this._resolveIntersectAttribute(intersect);
  }
  _processMiss(context) {
    const attribType = Constant/* ATTRIBUTE_TYPES */.Xu[this.pv.attributeType];
    switch (attribType) {
      case Constant/* AttribType.NUMERIC */.rp.NUMERIC: {
        this.p.attributeValue1.set(this.pv.resetValue1);
        return;
      }
      case Constant/* AttribType.STRING */.rp.STRING: {
        this.p.attributeValues.set(this.pv.resetValues);
        return;
      }
    }
    Assert/* TypeAssert.unreachable */.f.unreachable(attribType);
  }
  _resolveIntersectAttribute(intersection) {
    const attribType = Constant/* ATTRIBUTE_TYPES */.Xu[this.pv.attributeType];
    let attribValue = _IntersectDataEventNode.resolveObjectAttribute(
      intersection,
      this.pv.attributeName
    );
    if (attribValue == null) {
      attribValue = resolveIntersectGeometryAttribute(intersection, this.pv.attributeName, attribType);
    }
    if (attribValue != null) {
      switch (attribType) {
        case Constant/* AttribType.NUMERIC */.rp.NUMERIC: {
          this.p.attributeValue1.set(attribValue);
          return;
        }
        case Constant/* AttribType.STRING */.rp.STRING: {
          if (Type/* CoreType.isString */.MR.isString(attribValue)) {
            this.p.attributeValues.set(attribValue);
          }
          return;
        }
      }
      Assert/* TypeAssert.unreachable */.f.unreachable(attribType);
    }
  }
  static resolveObjectAttribute(intersection, attribName) {
    const value = (0,CoreObjectFactory/* coreObjectClassFactory */.Xr)(intersection.object).attribValue(intersection.object, attribName);
    if (value == null) {
      return;
    }
    if (Type/* CoreType.isNumber */.MR.isNumber(value) || Type/* CoreType.isString */.MR.isString(value)) {
      return value;
    }
    if (Type/* CoreType.isArray */.MR.isArray(value)) {
      return value[0];
    }
    if (Type/* CoreType.isVector */.MR.isVector(value)) {
      return value.x;
    }
  }
};
let IntersectDataEventNode = _IntersectDataEventNode;
IntersectDataEventNode.INPUT_HIT = "hit";
IntersectDataEventNode.INPUT_MISS = "miss";

// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/nodes/event/Keyboard.ts
var Keyboard = __webpack_require__(53687);
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/event/Limit.ts



var LimitEventInput = /* @__PURE__ */ ((LimitEventInput2) => {
  LimitEventInput2["TRIGGER"] = "trigger";
  LimitEventInput2["RESET"] = "reset";
  return LimitEventInput2;
})(LimitEventInput || {});
var LimitEventOutput = /* @__PURE__ */ ((LimitEventOutput2) => {
  LimitEventOutput2["OUT"] = "out";
  LimitEventOutput2["LAST"] = "last";
  return LimitEventOutput2;
})(LimitEventOutput || {});

class LimitEventParamsConfig extends params_ParamsConfig/* NodeParamsConfig */.yI {
  constructor() {
    super(...arguments);
    /** @param max number of events that can be processed */
    this.maxCount = params_ParamsConfig/* ParamConfig.INTEGER */.XC.INTEGER(5, {
      range: [0, 10],
      rangeLocked: [true, false]
    });
    /** @param resets the count */
    this.reset = params_ParamsConfig/* ParamConfig.BUTTON */.XC.BUTTON(null, {
      callback: (node) => {
        LimitEventNode.PARAM_CALLBACK_reset(node);
      }
    });
  }
}
const Limit_ParamsConfig = new LimitEventParamsConfig();
class LimitEventNode extends event_Base/* TypedEventNode */.F {
  constructor() {
    super(...arguments);
    this.paramsConfig = Limit_ParamsConfig;
    this._process_count = 0;
    this._last_dispatched = false;
  }
  static type() {
    return "limit";
  }
  initializeNode() {
    this.io.inputs.setNamedInputConnectionPoints([
      new Event/* EventConnectionPoint */.TG(
        "trigger" /* TRIGGER */,
        Event/* EventConnectionPointType.BASE */.M$.BASE,
        this.processEventTrigger.bind(this)
      ),
      new Event/* EventConnectionPoint */.TG(
        "reset" /* RESET */,
        Event/* EventConnectionPointType.BASE */.M$.BASE,
        this.process_event_reset.bind(this)
      )
    ]);
    this.io.outputs.setNamedOutputConnectionPoints([
      new Event/* EventConnectionPoint */.TG("out" /* OUT */, Event/* EventConnectionPointType.BASE */.M$.BASE),
      new Event/* EventConnectionPoint */.TG("last" /* LAST */, Event/* EventConnectionPointType.BASE */.M$.BASE)
    ]);
  }
  processEvent(event_context) {
  }
  processEventTrigger(event_context) {
    if (this._process_count < this.pv.maxCount) {
      this._process_count += 1;
      this.dispatchEventToOutput("out" /* OUT */, event_context);
    } else {
      if (!this._last_dispatched) {
        this._last_dispatched = true;
        this.dispatchEventToOutput("last" /* LAST */, event_context);
      }
    }
  }
  process_event_reset(event_context) {
    this._process_count = 0;
    this._last_dispatched = false;
  }
  static PARAM_CALLBACK_reset(node) {
    node.process_event_reset({});
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/event/Message.ts





class MessageParamsConfig extends params_ParamsConfig/* NodeParamsConfig */.yI {
  constructor() {
    super(...arguments);
    /** @param toggle on for the message to be displayed in a popup */
    this.alert = params_ParamsConfig/* ParamConfig.BOOLEAN */.XC.BOOLEAN(0);
    /** @param toggle on for the message to be printed in the console */
    this.console = params_ParamsConfig/* ParamConfig.BOOLEAN */.XC.BOOLEAN(1);
  }
}
const Message_ParamsConfig = new MessageParamsConfig();
const _MessageEventNode = class extends event_Base/* TypedEventNode */.F {
  constructor() {
    super(...arguments);
    this.paramsConfig = Message_ParamsConfig;
  }
  static type() {
    return "message";
  }
  initializeNode() {
    this.io.inputs.setNamedInputConnectionPoints([
      new Event/* EventConnectionPoint */.TG("trigger", Event/* EventConnectionPointType.BASE */.M$.BASE, this._process_trigger_event.bind(this))
    ]);
    this.io.outputs.setNamedOutputConnectionPoints([
      new Event/* EventConnectionPoint */.TG(_MessageEventNode.OUTPUT, Event/* EventConnectionPointType.BASE */.M$.BASE)
    ]);
  }
  trigger_output(context) {
    this.dispatchEventToOutput(_MessageEventNode.OUTPUT, context);
  }
  _process_trigger_event(context) {
    if ((0,Type/* isBooleanTrue */.bI)(this.pv.alert)) {
      alert(context);
    }
    if ((0,Type/* isBooleanTrue */.bI)(this.pv.console)) {
      console.log(this.path(), Date.now(), context);
    }
    this.trigger_output(context);
  }
};
let MessageEventNode = _MessageEventNode;
MessageEventNode.OUTPUT = "output";

// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/nodes/event/MobileJoystickControls.ts + 5 modules
var MobileJoystickControls = __webpack_require__(89518);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/nodes/event/Mouse.ts
var Mouse = __webpack_require__(61473);
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/event/NodeCook.ts

var NodeCook_async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};


var CookMode = /* @__PURE__ */ ((CookMode2) => {
  CookMode2["ALL_TOGETHER"] = "all together";
  CookMode2["BATCH"] = "batch";
  return CookMode2;
})(CookMode || {});
const COOK_MODES = ["all together" /* ALL_TOGETHER */, "batch" /* BATCH */];



class NodeCookEventParamsConfig extends params_ParamsConfig/* NodeParamsConfig */.yI {
  constructor() {
    super(...arguments);
    /** @param mask to select which nodes this will cook or listen to */
    this.mask = params_ParamsConfig/* ParamConfig.STRING */.XC.STRING("/geo*", {
      callback: (node) => {
        NodeCookEventNode.PARAM_CALLBACK_updateResolvedNodes(node);
      }
    });
    /** @param forces cook of nodes mentioned in the mask param */
    this.force = params_ParamsConfig/* ParamConfig.BOOLEAN */.XC.BOOLEAN(0);
    /** @param defines if the nodes should cook one after the other or in parallel */
    this.cookMode = params_ParamsConfig/* ParamConfig.INTEGER */.XC.INTEGER(COOK_MODES.indexOf("all together" /* ALL_TOGETHER */), {
      menu: {
        entries: COOK_MODES.map((name, value) => {
          return { name, value };
        })
      }
    });
    /** @param batch size */
    this.batchSize = params_ParamsConfig/* ParamConfig.INTEGER */.XC.INTEGER(1, {
      visibleIf: { cookMode: COOK_MODES.indexOf("batch" /* BATCH */) },
      separatorAfter: true
    });
    /** @param if on, we only trigger the first time a specific node has cooked. If false, we register every time a node cooks */
    this.registerOnlyFirstCooks = params_ParamsConfig/* ParamConfig.BOOLEAN */.XC.BOOLEAN(true);
    /** @param updates the list of nodes from the mask parameter. This can be useful if nodes are added or removed from the scene */
    this.updateResolve = params_ParamsConfig/* ParamConfig.BUTTON */.XC.BUTTON(null, {
      callback: (node, param) => {
        NodeCookEventNode.PARAM_CALLBACK_updateResolve(node);
      }
    });
    /** @param prints the list of nodes the mask resolves to to the console. Useful for debugging */
    this.printResolve = params_ParamsConfig/* ParamConfig.BUTTON */.XC.BUTTON(null, {
      callback: (node, param) => {
        NodeCookEventNode.PARAM_CALLBACK_printResolve(node);
      }
    });
  }
}
const NodeCook_ParamsConfig = new NodeCookEventParamsConfig();
const _NodeCookEventNode = class extends event_Base/* TypedEventNode */.F {
  constructor() {
    super(...arguments);
    this.paramsConfig = NodeCook_ParamsConfig;
    this._resolvedNodes = [];
    this._dispatchedFirstNodeCooked = false;
    this._dispatchedAllNodesCooked = false;
    this._cookStateByNodeId = /* @__PURE__ */ new Map();
  }
  static type() {
    return "nodeCook";
  }
  initializeNode() {
    this.io.inputs.setNamedInputConnectionPoints([
      new Event/* EventConnectionPoint */.TG(
        _NodeCookEventNode.INPUT_TRIGGER,
        Event/* EventConnectionPointType.BASE */.M$.BASE,
        this.processEventTrigger.bind(this)
      )
    ]);
    this.io.outputs.setNamedOutputConnectionPoints([
      new Event/* EventConnectionPoint */.TG(_NodeCookEventNode.OUTPUT_FIRST_NODE, Event/* EventConnectionPointType.BASE */.M$.BASE),
      new Event/* EventConnectionPoint */.TG(_NodeCookEventNode.OUTPUT_EACH_NODE, Event/* EventConnectionPointType.BASE */.M$.BASE),
      new Event/* EventConnectionPoint */.TG(_NodeCookEventNode.OUTPUT_ALL_NODES, Event/* EventConnectionPointType.BASE */.M$.BASE)
    ]);
  }
  // for public api
  // TODO: make it more generic, with input being an enum of input names
  trigger() {
    this.processEventTrigger({});
  }
  cook() {
    this._updateResolvedNodes();
    this.cookController.endCook();
  }
  dispose() {
    super.dispose();
    this._reset();
  }
  resolvedNodes() {
    return this._resolvedNodes;
  }
  processEventTrigger(event_context) {
    this._cookNodesWithMode();
  }
  _cookNodesWithMode() {
    this._updateResolvedNodes();
    const mode = COOK_MODES[this.pv.cookMode];
    switch (mode) {
      case "all together" /* ALL_TOGETHER */:
        return this._cookNodesAllTogether();
      case "batch" /* BATCH */:
        return this._cookNodesInBatch();
    }
    Assert/* TypeAssert.unreachable */.f.unreachable(mode);
  }
  _cookNodesAllTogether() {
    this._cookNodes(this._resolvedNodes);
  }
  _cookNodesInBatch() {
    return NodeCook_async(this, null, function* () {
      const batch_size = this.pv.batchSize;
      const batches_count = Math.ceil(this._resolvedNodes.length / batch_size);
      for (let i = 0; i < batches_count; i++) {
        const start = i * batch_size;
        const end = (i + 1) * batch_size;
        const nodes_in_batch = this._resolvedNodes.slice(start, end);
        yield this._cookNodes(nodes_in_batch);
      }
    });
  }
  _cookNodes(nodes) {
    return NodeCook_async(this, null, function* () {
      const promises = [];
      for (const node of nodes) {
        promises.push(this._cookNode(node));
      }
      return yield Promise.all(promises);
    });
  }
  _cookNode(node) {
    if ((0,Type/* isBooleanTrue */.bI)(this.pv.force)) {
      node.setDirty(this);
    }
    return node.compute();
  }
  static PARAM_CALLBACK_updateResolvedNodes(node) {
    node._updateResolvedNodes();
  }
  _updateResolvedNodes() {
    this._reset();
    this._resolvedNodes = this.scene().nodesController.nodesFromMask(this.pv.mask || "");
    for (const node of this._resolvedNodes) {
      node.cookController.registerOnCookEnd(this._callbackNameForNode(node), () => {
        this._onNodeCookComplete(node);
      });
      this._cookStateByNodeId.set(node.graphNodeId(), false);
    }
  }
  _callbackNameForNode(node) {
    return `[event/nodeCook] nodeCook=${this.graphNodeId()} target=${node.graphNodeId()}`;
  }
  _reset() {
    this._dispatchedFirstNodeCooked = false;
    this._cookStateByNodeId.clear();
    for (const node of this._resolvedNodes) {
      node.cookController.deregisterOnCookEnd(this._callbackNameForNode(node));
    }
    this._resolvedNodes = [];
  }
  _allNodesHaveCooked() {
    for (const node of this._resolvedNodes) {
      const state = this._cookStateByNodeId.get(node.graphNodeId());
      if (!state) {
        return false;
      }
    }
    return true;
  }
  _onNodeCookComplete(node) {
    const registerOnlyFirstCook = (0,Type/* isBooleanTrue */.bI)(this.pv.registerOnlyFirstCooks);
    const eventContext = { value: { node } };
    if (!this._dispatchedFirstNodeCooked || !registerOnlyFirstCook) {
      this._dispatchedFirstNodeCooked = true;
      this.dispatchEventToOutput(_NodeCookEventNode.OUTPUT_FIRST_NODE, eventContext);
    }
    const nodeHasCooked = this._cookStateByNodeId.get(node.graphNodeId());
    if (!nodeHasCooked || !registerOnlyFirstCook) {
      this.dispatchEventToOutput(_NodeCookEventNode.OUTPUT_EACH_NODE, eventContext);
    }
    this._cookStateByNodeId.set(node.graphNodeId(), true);
    if (!this._dispatchedAllNodesCooked || !registerOnlyFirstCook) {
      if (this._allNodesHaveCooked()) {
        this._dispatchedAllNodesCooked = true;
        this.dispatchEventToOutput(_NodeCookEventNode.OUTPUT_ALL_NODES, {});
      }
    }
  }
  static PARAM_CALLBACK_updateResolve(node) {
    node._updateResolvedNodes();
  }
  static PARAM_CALLBACK_printResolve(node) {
    node.printResolve();
  }
  printResolve() {
    console.log(this._resolvedNodes);
  }
};
let NodeCookEventNode = _NodeCookEventNode;
NodeCookEventNode.INPUT_TRIGGER = "trigger";
NodeCookEventNode.OUTPUT_FIRST_NODE = "first";
NodeCookEventNode.OUTPUT_EACH_NODE = "each";
NodeCookEventNode.OUTPUT_ALL_NODES = "all";

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/event/Null.ts



var NullEventInput = /* @__PURE__ */ ((NullEventInput2) => {
  NullEventInput2["TRIGGER"] = "trigger";
  return NullEventInput2;
})(NullEventInput || {});
var NullEventOutput = /* @__PURE__ */ ((NullEventOutput2) => {
  NullEventOutput2["OUT"] = "out";
  return NullEventOutput2;
})(NullEventOutput || {});

class NullEventParamsConfig extends params_ParamsConfig/* NodeParamsConfig */.yI {
}
const event_Null_ParamsConfig = new NullEventParamsConfig();
class NullEventNode extends event_Base/* TypedEventNode */.F {
  constructor() {
    super(...arguments);
    this.paramsConfig = event_Null_ParamsConfig;
  }
  static type() {
    return "null";
  }
  initializeNode() {
    this.io.inputs.setNamedInputConnectionPoints([
      new Event/* EventConnectionPoint */.TG(
        "trigger" /* TRIGGER */,
        Event/* EventConnectionPointType.BASE */.M$.BASE,
        this.processEventTrigger.bind(this)
      )
    ]);
    this.io.outputs.setNamedOutputConnectionPoints([
      new Event/* EventConnectionPoint */.TG("out" /* OUT */, Event/* EventConnectionPointType.BASE */.M$.BASE)
    ]);
  }
  processEvent(event_context) {
  }
  processEventTrigger(event_context) {
    this.dispatchEventToOutput("out" /* OUT */, event_context);
  }
}

// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/nodes/event/Param.ts
var Param = __webpack_require__(58036);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/nodes/event/Pointer.ts
var Pointer = __webpack_require__(77131);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/poly/ParamType.ts
var ParamType = __webpack_require__(51254);
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/event/utils/raycast/VelocityController.ts




var CPUIntersectWith = /* @__PURE__ */ ((CPUIntersectWith2) => {
  CPUIntersectWith2["GEOMETRY"] = "geometry";
  CPUIntersectWith2["PLANE"] = "plane";
  return CPUIntersectWith2;
})(CPUIntersectWith || {});
const CPU_INTERSECT_WITH_OPTIONS = (/* unused pure expression or super */ null && (["geometry" /* GEOMETRY */, "plane" /* PLANE */]));
class RaycastCPUVelocityController {
  constructor(_node) {
    this._node = _node;
    this._hitVelocity = new three_module.Vector3(0, 0, 0);
    this._hitVelocityArray = [0, 0, 0];
  }
  process(hitPosition) {
    var _a;
    if (!(0,Type/* isBooleanTrue */.bI)(this._node.pv.tvelocity)) {
      return;
    }
    if (!this._prevPosition) {
      this._prevPosition = this._prevPosition || new three_module.Vector3();
      this._prevPosition.copy(hitPosition);
      return;
    }
    const delta = this._node.scene().timeController.delta();
    this._hitVelocity.copy(hitPosition).sub(this._prevPosition).divideScalar(delta).multiplyScalar(1e3);
    this._hitVelocity.toArray(this._hitVelocityArray);
    if ((0,Type/* isBooleanTrue */.bI)(this._node.pv.tvelocityTarget)) {
      if (this._foundVelocityTargetParam == null || (0,Type/* isBooleanTrue */.bI)(this._foundVelocityTargetParam.disposed())) {
        const targetParam = this._node.pv.velocityTarget;
        this._foundVelocityTargetParam = targetParam.paramWithType(ParamType/* ParamType.VECTOR3 */._.VECTOR3);
      }
      (_a = this._foundVelocityTargetParam) == null ? void 0 : _a.set(this._hitVelocityArray);
    } else {
      this._node.p.velocity.set(this._hitVelocityArray);
    }
    this._prevPosition.copy(hitPosition);
  }
  reset() {
    this._prevPosition = void 0;
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/event/utils/raycast/CpuConstants.ts

var CpuConstants_CPUIntersectWith = /* @__PURE__ */ ((CPUIntersectWith2) => {
  CPUIntersectWith2["GEOMETRY"] = "geometry";
  CPUIntersectWith2["PLANE"] = "plane";
  return CPUIntersectWith2;
})(CpuConstants_CPUIntersectWith || {});
const CpuConstants_CPU_INTERSECT_WITH_OPTIONS = ["geometry" /* GEOMETRY */, "plane" /* PLANE */];

// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/nodes/event/utils/CursorHelper.ts + 1 modules
var CursorHelper = __webpack_require__(43695);
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/event/utils/raycast/BaseRaycastController.ts



class BaseRaycastController {
  constructor() {
    // private _offset: CursorOffset = {offsetX: 0, offsetY: 0};
    this._cursorHelper = new CursorHelper/* CursorHelper */.A();
    this._cursor = new three_module.Vector2();
  }
  // protected _setCursor(eventContext: EventContext<MouseEvent | DragEvent | PointerEvent | TouchEvent>) {
  // 	this._cursorHelper.setCursor(eventContext, this._cursor);
  // 	if (CoreVector.isVector2Valid(this._cursor)) {
  // 		this._remapCursor();
  // 	}
  // }
  // protected _remapCursor() {}
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/event/utils/raycast/CPUController.ts















class RaycastCPUController extends BaseRaycastController {
  constructor(_node) {
    super();
    this._node = _node;
    // private _offset: CursorOffset = {offsetX: 0, offsetY: 0};
    // private _mouse: Vector2 = new Vector2();
    this._cursorArray = [0, 0];
    this._plane = new three_module.Plane();
    this._plane_intersect_target = new three_module.Vector3();
    this._intersections = [];
    this._hitPositionArray = [0, 0, 0];
    this.velocityController = new RaycastCPUVelocityController(this._node);
  }
  updateMouse(eventContext) {
    const viewer = eventContext.viewer;
    if (!viewer) {
      return;
    }
    const camera = viewer.camera();
    if (!camera) {
      return;
    }
    this._cursorHelper.setCursorForCPU(eventContext, this._cursor);
    if ((0,Type/* isBooleanTrue */.bI)(this._node.pv.tmouse)) {
      this._cursor.toArray(this._cursorArray);
      this._node.p.mouse.set(this._cursorArray);
    }
    viewer.raycastersController.raycaster0().setFromCamera(this._cursor, camera);
  }
  // protected override _remapCursor() {
  // 	this._cursor.x = this._cursor.x * 2 - 1;
  // 	this._cursor.y = -this._cursor.y * 2 + 1;
  // }
  // private _updateFromCursor(canvas: HTMLCanvasElement){
  // 	if (canvas.offsetWidth <= 0 || canvas.offsetHeight <= 0) {
  // 		// the canvas can have a size of 0 if it has been removed from the scene
  // 		this._mouse.set(0, 0);
  // 	} else {
  // 		this._mouse.x = (this._offset.offsetX / canvas.offsetWidth) * 2 - 1;
  // 		this._mouse.y = -(this._offset.offsetY / canvas.offsetHeight) * 2 + 1;
  // 		this._mouse.toArray(this._mouse_array);
  // 	}
  // 	// there can be some conditions leading to an infinite mouse number, so we check here what we got
  // 	if (isNaN(this._mouse.x) || !isFinite(this._mouse.x) || isNaN(this._mouse.y) || !isFinite(this._mouse.y)) {
  // 		console.warn('invalid number detected');
  // 		console.warn(
  // 			this._mouse.toArray(),
  // 			this._offset.offsetX,
  // 			this._offset.offsetY,
  // 			canvas.offsetWidth,
  // 			canvas.offsetHeight
  // 		);
  // 		return;
  // 	}
  // 	if (isBooleanTrue(this._node.pv.tmouse)) {
  // 		this._node.p.mouse.set(this._mouse_array);
  // 	}
  // };
  processEvent(context) {
    this._prepareRaycaster(context);
    const type = CpuConstants_CPU_INTERSECT_WITH_OPTIONS[this._node.pv.intersectWith];
    switch (type) {
      case CpuConstants_CPUIntersectWith.GEOMETRY: {
        return this._intersectGeometry(context);
      }
      case CpuConstants_CPUIntersectWith.PLANE: {
        return this._intersectPlane(context);
      }
    }
    Assert/* TypeAssert.unreachable */.f.unreachable(type);
  }
  _intersectPlane(eventContext) {
    const viewer = eventContext.viewer;
    if (!viewer) {
      return;
    }
    this._plane.normal.copy(this._node.pv.planeDirection);
    this._plane.constant = this._node.pv.planeOffset;
    viewer.raycastersController.raycaster0().ray.intersectPlane(this._plane, this._plane_intersect_target);
    this._setPositionParam(this._plane_intersect_target);
    this._node.triggerHit(eventContext);
  }
  _intersectGeometry(eventContext) {
    const viewer = eventContext.viewer;
    if (!viewer) {
      return;
    }
    if (!this._resolvedTargets) {
      this.updateTarget();
    }
    if (this._resolvedTargets) {
      this._intersections.length = 0;
      const intersections = viewer.raycastersController.raycaster0().intersectObjects(
        this._resolvedTargets,
        (0,Type/* isBooleanTrue */.bI)(this._node.pv.traverseChildren),
        this._intersections
      );
      const intersection = intersections[0];
      if (intersection) {
        this._node.scene().batchUpdates(() => {
          if ((0,Type/* isBooleanTrue */.bI)(this._node.pv.tposition)) {
            this._setPositionParam(intersection.point);
          }
          if ((0,Type/* isBooleanTrue */.bI)(this._node.pv.geoAttribute)) {
            this._resolveIntersectAttribute(intersection);
          }
        });
        eventContext.value = { intersect: intersection };
        this._node.triggerHit(eventContext);
      } else {
        this._node.triggerMiss(eventContext);
      }
    }
  }
  _resolveIntersectAttribute(intersection) {
    const attribType = Constant/* ATTRIBUTE_TYPES */.Xu[this._node.pv.geoAttributeType];
    let attribValue = IntersectDataEventNode.resolveObjectAttribute(
      intersection,
      this._node.pv.geoAttributeName
    );
    if (attribValue == null) {
      attribValue = resolveIntersectGeometryAttribute(intersection, this._node.pv.geoAttributeName, attribType);
    }
    if (attribValue != null) {
      switch (attribType) {
        case Constant/* AttribType.NUMERIC */.rp.NUMERIC: {
          this._node.p.geoAttributeValue1.set(attribValue);
          return;
        }
        case Constant/* AttribType.STRING */.rp.STRING: {
          if (Type/* CoreType.isString */.MR.isString(attribValue)) {
            this._node.p.geoAttributeValues.set(attribValue);
          }
          return;
        }
      }
      Assert/* TypeAssert.unreachable */.f.unreachable(attribType);
    }
  }
  _setPositionParam(hitPosition) {
    var _a;
    hitPosition.toArray(this._hitPositionArray);
    if ((0,Type/* isBooleanTrue */.bI)(this._node.pv.tpositionTarget)) {
      const targetParam = this._node.pv.positionTarget;
      if (this._foundPositionTargetParam == null || (0,Type/* isBooleanTrue */.bI)(this._foundPositionTargetParam.disposed())) {
        this._foundPositionTargetParam = targetParam.paramWithType(ParamType/* ParamType.VECTOR3 */._.VECTOR3);
      }
      (_a = this._foundPositionTargetParam) == null ? void 0 : _a.set(this._hitPositionArray);
    } else {
      this._node.p.position.set(this._hitPositionArray);
    }
    this.velocityController.process(hitPosition);
  }
  _prepareRaycaster(eventContext) {
    const viewer = eventContext.viewer;
    if (!viewer) {
      return;
    }
    const pointsParam = viewer.raycastersController.raycaster0().params.Points;
    if (pointsParam) {
      pointsParam.threshold = this._node.pv.pointsThreshold;
    }
  }
  updateTarget() {
    const targetType = Raycast_TARGET_TYPES[this._node.pv.targetType];
    switch (targetType) {
      case Raycast_TargetType.NODE: {
        return this._updateTargetFromNode();
      }
      case Raycast_TargetType.SCENE_GRAPH: {
        return this._updateTargetFromSceneGraph();
      }
    }
    Assert/* TypeAssert.unreachable */.f.unreachable(targetType);
  }
  _updateTargetFromNode() {
    const node = this._node.p.targetNode.value.nodeWithContext(poly_NodeContext/* NodeContext.OBJ */.sy.OBJ);
    if (node) {
      const found_obj = (0,Type/* isBooleanTrue */.bI)(this._node.pv.traverseChildren) ? node.object : node.childrenDisplayController.sopGroup();
      if (found_obj) {
        this._resolvedTargets = [found_obj];
      } else {
        this._resolvedTargets = void 0;
      }
    } else {
      this._node.states.error.set("node is not an object");
    }
  }
  _updateTargetFromSceneGraph() {
    const objects = this._node.scene().objectsByMask(this._node.pv.objectMask);
    if (objects.length > 0) {
      this._resolvedTargets = objects;
    } else {
      this._resolvedTargets = void 0;
    }
  }
  static PARAM_CALLBACK_updateTarget(node) {
    node.cpuController.updateTarget();
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/event/utils/raycast/GPUController.ts

var GPUController_async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};




class RaycastGPUController extends BaseRaycastController {
  constructor(_node) {
    super();
    this._node = _node;
    this._resolvedMaterial = null;
    this._restoreContext = {
      scene: {
        overrideMaterial: null,
        background: null
      },
      renderer: {
        toneMapping: three_module.NoToneMapping,
        outputColorSpace: three_module.NoColorSpace
      }
    };
    // private _mouse: Vector2 = new Vector2();
    this._cursorArray = [0, 0];
    this._read = new Float32Array(4);
    this._paramColor = [0, 0, 0];
    this._paramAlpha = 0;
  }
  updateMouse(eventContext) {
    this._cursorHelper.setCursorForGPU(eventContext, this._cursor);
    if ((0,Type/* isBooleanTrue */.bI)(this._node.pv.tmouse)) {
      this._cursor.toArray(this._cursorArray);
      this._node.p.mouse.set(this._cursorArray);
    }
  }
  processEvent(context) {
    var _a, _b;
    const canvas = (_a = context.viewer) == null ? void 0 : _a.canvas();
    const camera = (_b = context.viewer) == null ? void 0 : _b.camera();
    if (!(canvas && camera)) {
      return;
    }
    this._renderTarget = this._renderTarget || new three_module.WebGLRenderTarget(1, 1, {
      minFilter: three_module.LinearFilter,
      magFilter: three_module.NearestFilter,
      format: three_module.RGBAFormat,
      type: three_module.FloatType
    });
    const scene = this._node.scene().threejsScene();
    const renderer = this._node.scene().renderersRegister.lastRegisteredRenderer();
    if (!renderer) {
      return;
    }
    if (!(renderer instanceof three_module.WebGLRenderer)) {
      console.log("renderer found is not WebGLRenderer");
      return;
    }
    this._modifySceneAndRenderer(scene, renderer);
    camera.setViewOffset(
      canvas.offsetWidth,
      canvas.offsetHeight,
      this._cursor.x * canvas.offsetWidth,
      (1 - this._cursor.y) * canvas.offsetHeight,
      1,
      1
    );
    renderer.setRenderTarget(this._renderTarget);
    renderer.clear();
    renderer.render(scene, camera);
    renderer.setRenderTarget(null);
    camera.clearViewOffset();
    this._restoreSceneAndRenderer(scene, renderer);
    renderer.readRenderTargetPixels(this._renderTarget, 0, 0, 1, 1, this._read);
    this._paramColor[0] = this._read[0];
    this._paramColor[1] = this._read[1];
    this._paramColor[2] = this._read[2];
    this._paramAlpha = this._read[3];
    this._node.scene().batchUpdates(() => {
      this._node.p.pixelColor.set(this._paramColor);
      this._node.p.pixelAlpha.set(this._paramAlpha);
    });
    if (this._node.pv.pixelColor.r > this._node.pv.hitThreshold) {
      this._node.triggerHit(context);
    } else {
      this._node.triggerMiss(context);
    }
  }
  _modifySceneAndRenderer(scene, renderer) {
    this._restoreContext.scene.overrideMaterial = scene.overrideMaterial;
    this._restoreContext.scene.background = scene.background;
    this._restoreContext.renderer.outputColorSpace = renderer.outputColorSpace;
    this._restoreContext.renderer.toneMapping = renderer.toneMapping;
    if ((0,Type/* isBooleanTrue */.bI)(this._node.pv.overrideMaterial)) {
      if (this._resolvedMaterial == null) {
        this._updateMaterial();
      }
      scene.overrideMaterial = this._resolvedMaterial;
    }
    scene.background = null;
    renderer.toneMapping = three_module.NoToneMapping;
    renderer.outputColorSpace = three_module.NoColorSpace;
  }
  _restoreSceneAndRenderer(scene, renderer) {
    scene.overrideMaterial = this._restoreContext.scene.overrideMaterial;
    scene.background = this._restoreContext.scene.background;
    renderer.outputColorSpace = this._restoreContext.renderer.outputColorSpace;
    renderer.toneMapping = this._restoreContext.renderer.toneMapping;
  }
  _updateMaterial() {
    return GPUController_async(this, null, function* () {
      const node = this._node.pv.material.nodeWithContext(poly_NodeContext/* NodeContext.MAT */.sy.MAT, this._node.states.error);
      if (node) {
        if (node.context() == poly_NodeContext/* NodeContext.MAT */.sy.MAT) {
          this._resolvedMaterial = (yield node.material()) || null;
        } else {
          this._node.states.error.set("material is not a mat node");
        }
      } else {
        this._node.states.error.set("no override material found");
      }
    });
  }
  static PARAM_CALLBACK_updateMaterial(node) {
    node.gpuController._updateMaterial();
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/event/Raycast.ts

var Raycast_defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var Raycast_getOwnPropSymbols = Object.getOwnPropertySymbols;
var Raycast_hasOwnProp = Object.prototype.hasOwnProperty;
var Raycast_propIsEnum = Object.prototype.propertyIsEnumerable;
var Raycast_defNormalProp = (obj, key, value) => key in obj ? Raycast_defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var Raycast_spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (Raycast_hasOwnProp.call(b, prop))
      Raycast_defNormalProp(a, prop, b[prop]);
  if (Raycast_getOwnPropSymbols)
    for (var prop of Raycast_getOwnPropSymbols(b)) {
      if (Raycast_propIsEnum.call(b, prop))
        Raycast_defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));








const TIMESTAMP = 1e3 / 60;
var RaycastMode = /* @__PURE__ */ ((RaycastMode2) => {
  RaycastMode2["CPU"] = "cpu";
  RaycastMode2["GPU"] = "gpu";
  return RaycastMode2;
})(RaycastMode || {});
const RAYCAST_MODES = ["cpu" /* CPU */, "gpu" /* GPU */];
function visible_for_cpu(options = {}) {
  options["mode"] = RAYCAST_MODES.indexOf("cpu" /* CPU */);
  return { visibleIf: options };
}
function visible_for_cpu_geometry(options = {}) {
  options["mode"] = RAYCAST_MODES.indexOf("cpu" /* CPU */);
  options["intersectWith"] = CpuConstants_CPU_INTERSECT_WITH_OPTIONS.indexOf(CpuConstants_CPUIntersectWith.GEOMETRY);
  return { visibleIf: options };
}
function visible_for_cpu_plane(options = {}) {
  options["mode"] = RAYCAST_MODES.indexOf("cpu" /* CPU */);
  options["intersectWith"] = CpuConstants_CPU_INTERSECT_WITH_OPTIONS.indexOf(CpuConstants_CPUIntersectWith.PLANE);
  return { visibleIf: options };
}
function visible_for_gpu(options = {}) {
  options["mode"] = RAYCAST_MODES.indexOf("gpu" /* GPU */);
  return { visibleIf: options };
}
var Raycast_TargetType = /* @__PURE__ */ ((TargetType2) => {
  TargetType2["SCENE_GRAPH"] = "scene graph";
  TargetType2["NODE"] = "node";
  return TargetType2;
})(Raycast_TargetType || {});
const Raycast_TARGET_TYPES = ["scene graph" /* SCENE_GRAPH */, "node" /* NODE */];


class RaycastParamsConfig extends params_ParamsConfig/* NodeParamsConfig */.yI {
  constructor() {
    super(...arguments);
    /** @param defines if the ray detection is done on the CPU or GPU (GPU being currently experimental) */
    this.mode = params_ParamsConfig/* ParamConfig.INTEGER */.XC.INTEGER(RAYCAST_MODES.indexOf("cpu" /* CPU */), {
      menu: {
        entries: RAYCAST_MODES.map((name, value) => {
          return {
            name,
            value
          };
        })
      }
    });
    //
    //
    // COMMON
    //
    //
    /** @param defines if the mouse parameter is update when the cursor screen position changes */
    this.tmouse = params_ParamsConfig/* ParamConfig.BOOLEAN */.XC.BOOLEAN(1, { cook: false });
    /** @param mouse coordinates (0,0) being the center of the screen, (-1,-1) being the bottom left corner and (1,1) being the top right corner */
    this.mouse = params_ParamsConfig/* ParamConfig.VECTOR2 */.XC.VECTOR2([0, 0], {
      cook: false,
      visibleIf: { tmouse: 1 }
    });
    /** @param by default the ray is sent from the current camera, but this allows to set another camera */
    // overrideCamera = ParamConfig.BOOLEAN(0, visible_for_cpu());
    /** @param by default the ray is sent from the current camera, but this allows to set a custom ray */
    // overrideRay = ParamConfig.BOOLEAN(0, {
    // 	visibleIf: {
    // 		mode: RAYCAST_MODES.indexOf(RaycastMode.CPU),
    // 		overrideCamera: 1,
    // 	},
    // });
    /** @param the camera to override to */
    // camera = ParamConfig.NODE_PATH('', {
    // 	nodeSelection: {
    // 		context: NodeContext.OBJ,
    // 		types: CAMERA_TYPES,
    // 	},
    // 	dependentOnFoundNode: false,
    // 	...visible_for_cpu({
    // 		overrideCamera: 1,
    // 		overrideRay: 0,
    // 	}),
    // });
    /** @param the ray origin */
    // rayOrigin = ParamConfig.VECTOR3([0, 0, 0], {
    // 	visibleIf: {
    // 		overrideCamera: 1,
    // 		overrideRay: 1,
    // 	},
    // });
    /** @param the ray direction */
    // rayDirection = ParamConfig.VECTOR3([0, 0, 1], {
    // 	visibleIf: {
    // 		overrideCamera: 1,
    // 		overrideRay: 1,
    // 	},
    // });
    //
    //
    // GPU
    //
    //
    /** @param the material to use on the scene for GPU detection */
    this.overrideMaterial = params_ParamsConfig/* ParamConfig.BOOLEAN */.XC.BOOLEAN(0, Raycast_spreadValues({
      callback: (node, param) => {
        RaycastGPUController.PARAM_CALLBACK_updateMaterial(node);
      }
    }, visible_for_gpu()));
    /** @param the material to use on the scene for GPU detection */
    this.material = params_ParamsConfig/* ParamConfig.NODE_PATH */.XC.NODE_PATH("", Raycast_spreadValues({
      nodeSelection: {
        context: poly_NodeContext/* NodeContext.MAT */.sy.MAT
      },
      dependentOnFoundNode: false,
      computeOnDirty: true,
      callback: (node, param) => {
        RaycastGPUController.PARAM_CALLBACK_updateMaterial(node);
      }
    }, visible_for_gpu({ overrideMaterial: 1 })));
    /** @param the current pixel color being read */
    this.pixelColor = params_ParamsConfig/* ParamConfig.COLOR */.XC.COLOR([0, 0, 0], Raycast_spreadValues({
      cook: false
    }, visible_for_gpu()));
    this.pixelAlpha = params_ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(0, Raycast_spreadValues({
      range: [0, 1],
      cook: false
    }, visible_for_gpu()));
    /** @param the value threshold for which a hit is detected */
    this.hitThreshold = params_ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(0.5, Raycast_spreadValues({
      cook: false
    }, visible_for_gpu()));
    //
    //
    // CPU
    //
    //
    /** @param defines the hit it tested against geometry or just a plane */
    this.intersectWith = params_ParamsConfig/* ParamConfig.INTEGER */.XC.INTEGER(CpuConstants_CPU_INTERSECT_WITH_OPTIONS.indexOf(CpuConstants_CPUIntersectWith.GEOMETRY), Raycast_spreadValues({
      menu: {
        entries: CpuConstants_CPU_INTERSECT_WITH_OPTIONS.map((name, value) => {
          return { name, value };
        })
      }
    }, visible_for_cpu()));
    /** @param threshold used to test hit with points */
    this.pointsThreshold = params_ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(1, Raycast_spreadValues({
      range: [0, 100],
      rangeLocked: [true, false]
    }, visible_for_cpu()));
    //
    //
    // CPU PLANE
    //
    //
    /** @param plane direction if the hit is tested against a plane */
    this.planeDirection = params_ParamsConfig/* ParamConfig.VECTOR3 */.XC.VECTOR3([0, 1, 0], Raycast_spreadValues({}, visible_for_cpu_plane()));
    /** @param plane offset if the hit is tested against a plane */
    this.planeOffset = params_ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(0, Raycast_spreadValues({}, visible_for_cpu_plane()));
    //
    //
    // CPU GEOMETRY
    //
    //
    this.targetType = params_ParamsConfig/* ParamConfig.INTEGER */.XC.INTEGER(0, Raycast_spreadValues({
      menu: {
        entries: Raycast_TARGET_TYPES.map((name, value) => {
          return { name, value };
        })
      }
    }, visible_for_cpu_geometry()));
    /** @param node whose objects to test hit against, when testing against geometries */
    this.targetNode = params_ParamsConfig/* ParamConfig.NODE_PATH */.XC.NODE_PATH("", Raycast_spreadValues({
      nodeSelection: {
        context: poly_NodeContext/* NodeContext.OBJ */.sy.OBJ
      },
      dependentOnFoundNode: false,
      callback: (node, param) => {
        RaycastCPUController.PARAM_CALLBACK_updateTarget(node);
      }
    }, visible_for_cpu_geometry({ targetType: Raycast_TARGET_TYPES.indexOf("node" /* NODE */) })));
    /** @param objects to test hit against, when testing against geometries */
    this.objectMask = params_ParamsConfig/* ParamConfig.STRING */.XC.STRING("*geo1*", Raycast_spreadValues({
      callback: (node, param) => {
        RaycastCPUController.PARAM_CALLBACK_updateTarget(node);
      },
      objectMask: true
    }, visible_for_cpu_geometry({ targetType: Raycast_TARGET_TYPES.indexOf("scene graph" /* SCENE_GRAPH */) })));
    /** @param toggle to hit if tested against children */
    this.traverseChildren = params_ParamsConfig/* ParamConfig.BOOLEAN */.XC.BOOLEAN(true, __spreadProps(Raycast_spreadValues({
      callback: (node, param) => {
        RaycastCPUController.PARAM_CALLBACK_updateTarget(node);
      }
    }, visible_for_cpu_geometry()), {
      separatorAfter: true
    }));
    //
    //
    // POSITION (common between plane and geo intersection)
    //
    //
    /** @param toggle on to update hit position */
    this.tposition = params_ParamsConfig/* ParamConfig.BOOLEAN */.XC.BOOLEAN(1, Raycast_spreadValues({
      cook: false
    }, visible_for_cpu()));
    /** @param toggle on to set the param to the hit position */
    this.tpositionTarget = params_ParamsConfig/* ParamConfig.BOOLEAN */.XC.BOOLEAN(0, Raycast_spreadValues({
      cook: false
    }, visible_for_cpu({ tposition: 1 })));
    /** @param this will be set to the hit position */
    this.position = params_ParamsConfig/* ParamConfig.VECTOR3 */.XC.VECTOR3([0, 0, 0], Raycast_spreadValues({
      cook: false
    }, visible_for_cpu({ tposition: 1, tpositionTarget: 0 })));
    /** @param this parameter will be set to the hit position */
    this.positionTarget = params_ParamsConfig/* ParamConfig.PARAM_PATH */.XC.PARAM_PATH("", __spreadProps(Raycast_spreadValues({
      // positionTarget param should not be dependent
      // on found Param, otherwise, as soon as the target param is change,
      // this param would have to cook
      dependentOnFoundParam: false,
      cook: false
    }, visible_for_cpu({ tposition: 1, tpositionTarget: 1 })), {
      paramSelection: ParamType/* ParamType.VECTOR3 */._.VECTOR3,
      computeOnDirty: true
    }));
    /** @param toggle on to set the param to the mouse velocity (experimental) */
    this.tvelocity = params_ParamsConfig/* ParamConfig.BOOLEAN */.XC.BOOLEAN(0, Raycast_spreadValues({
      cook: false
    }, visible_for_cpu()));
    /** @param toggle on to set the param to the mouse velocity */
    this.tvelocityTarget = params_ParamsConfig/* ParamConfig.BOOLEAN */.XC.BOOLEAN(0, Raycast_spreadValues({
      cook: false
    }, visible_for_cpu({ tvelocity: 1 })));
    /** @param this will be set to the mouse velocity */
    this.velocity = params_ParamsConfig/* ParamConfig.VECTOR3 */.XC.VECTOR3([0, 0, 0], Raycast_spreadValues({
      cook: false
    }, visible_for_cpu({ tvelocity: 1, tvelocityTarget: 0 })));
    /** @param this will be set to the mouse velocity */
    this.velocityTarget = params_ParamsConfig/* ParamConfig.PARAM_PATH */.XC.PARAM_PATH("", __spreadProps(Raycast_spreadValues({
      dependentOnFoundParam: false,
      cook: false
    }, visible_for_cpu({ tvelocity: 1, tvelocityTarget: 1 })), {
      paramSelection: ParamType/* ParamType.VECTOR3 */._.VECTOR3,
      computeOnDirty: true
    }));
    //
    //
    // GEO ATTRIB
    //
    //
    /** @param for geometry hit tests, a vertex attribute can be read */
    this.geoAttribute = params_ParamsConfig/* ParamConfig.BOOLEAN */.XC.BOOLEAN(0, visible_for_cpu_geometry());
    /** @param geometry vertex attribute to read */
    this.geoAttributeName = params_ParamsConfig/* ParamConfig.STRING */.XC.STRING("id", Raycast_spreadValues({
      cook: false
    }, visible_for_cpu_geometry({ geoAttribute: 1 })));
    /** @param type of attribute */
    this.geoAttributeType = params_ParamsConfig/* ParamConfig.INTEGER */.XC.INTEGER(Constant/* ATTRIBUTE_TYPES.indexOf */.Xu.indexOf(Constant/* AttribType.NUMERIC */.rp.NUMERIC), Raycast_spreadValues({
      menu: {
        entries: Constant/* AttribTypeMenuEntries */.mb
      }
    }, visible_for_cpu_geometry({ geoAttribute: 1 })));
    /** @param attribute value for float */
    this.geoAttributeValue1 = params_ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(0, Raycast_spreadValues({
      cook: false
    }, visible_for_cpu_geometry({
      geoAttribute: 1,
      geoAttributeType: Constant/* ATTRIBUTE_TYPES.indexOf */.Xu.indexOf(Constant/* AttribType.NUMERIC */.rp.NUMERIC)
    })));
    /** @param attribute value for string */
    this.geoAttributeValues = params_ParamsConfig/* ParamConfig.STRING */.XC.STRING("", Raycast_spreadValues({}, visible_for_cpu_geometry({
      geoAttribute: 1,
      geoAttributeType: Constant/* ATTRIBUTE_TYPES.indexOf */.Xu.indexOf(Constant/* AttribType.STRING */.rp.STRING)
    })));
  }
}
const Raycast_ParamsConfig = new RaycastParamsConfig();
const _RaycastEventNode = class extends event_Base/* TypedEventNode */.F {
  constructor() {
    super(...arguments);
    this.paramsConfig = Raycast_ParamsConfig;
    this.cpuController = new RaycastCPUController(this);
    this.gpuController = new RaycastGPUController(this);
    this._lastEventProcessedAt = -1;
  }
  static type() {
    return "raycast";
  }
  initializeNode() {
    this.io.inputs.setNamedInputConnectionPoints([
      new Event/* EventConnectionPoint */.TG(
        _RaycastEventNode.INPUT_TRIGGER,
        Event/* EventConnectionPointType.BASE */.M$.BASE,
        this._processTriggerEventThrottled.bind(this)
      ),
      new Event/* EventConnectionPoint */.TG(
        _RaycastEventNode.INPUT_MOUSE,
        Event/* EventConnectionPointType.MOUSE */.M$.MOUSE,
        this._processMouseEvent.bind(this)
      ),
      new Event/* EventConnectionPoint */.TG(
        _RaycastEventNode.INPUT_UPDATE_OBJECTS,
        Event/* EventConnectionPointType.BASE */.M$.BASE,
        this._processTriggerUpdateObjects.bind(this)
      ),
      new Event/* EventConnectionPoint */.TG(
        _RaycastEventNode.INPUT_TRIGGER_VEL_RESET,
        Event/* EventConnectionPointType.BASE */.M$.BASE,
        this._processTriggerVelReset.bind(this)
      )
    ]);
    this.io.outputs.setNamedOutputConnectionPoints([
      new Event/* EventConnectionPoint */.TG(_RaycastEventNode.OUTPUT_HIT, Event/* EventConnectionPointType.BASE */.M$.BASE),
      new Event/* EventConnectionPoint */.TG(_RaycastEventNode.OUTPUT_MISS, Event/* EventConnectionPointType.BASE */.M$.BASE)
    ]);
  }
  triggerHit(context) {
    this.dispatchEventToOutput(_RaycastEventNode.OUTPUT_HIT, context);
  }
  triggerMiss(context) {
    this.dispatchEventToOutput(_RaycastEventNode.OUTPUT_MISS, context);
  }
  _processMouseEvent(context) {
    if (this.pv.mode == RAYCAST_MODES.indexOf("cpu" /* CPU */)) {
      this.cpuController.updateMouse(context);
    } else {
      this.gpuController.updateMouse(context);
    }
  }
  _processTriggerEventThrottled(context) {
    const now = Poly/* Poly.performance.performanceManager */.L.performance.performanceManager().now();
    const getDelta = (now2) => {
      const previous = this._lastEventProcessedAt;
      const delta2 = now2 - previous;
      return delta2;
    };
    const delta = getDelta(now);
    if (delta < TIMESTAMP) {
      setTimeout(() => {
        const delta2 = getDelta(now);
        if (delta2 < TIMESTAMP) {
          this._processTriggerEvent(context);
        }
      }, TIMESTAMP - delta);
    } else {
      this._processTriggerEvent(context);
    }
  }
  _processTriggerEvent(context) {
    this._processMouseEvent(context);
    this._lastEventProcessedAt = Poly/* Poly.performance.performanceManager */.L.performance.performanceManager().now();
    if (this.pv.mode == RAYCAST_MODES.indexOf("cpu" /* CPU */)) {
      this.cpuController.processEvent(context);
    } else {
      this.gpuController.processEvent(context);
    }
  }
  _processTriggerUpdateObjects(context) {
    if (this.pv.mode == RAYCAST_MODES.indexOf("cpu" /* CPU */)) {
      this.cpuController.updateTarget();
    }
  }
  _processTriggerVelReset(context) {
    if (this.pv.mode == RAYCAST_MODES.indexOf("cpu" /* CPU */)) {
      this.cpuController.velocityController.reset();
    }
  }
};
let RaycastEventNode = _RaycastEventNode;
RaycastEventNode.INPUT_TRIGGER = "trigger";
RaycastEventNode.INPUT_MOUSE = "mouse";
RaycastEventNode.INPUT_UPDATE_OBJECTS = "updateObjects";
RaycastEventNode.INPUT_TRIGGER_VEL_RESET = "triggerVelReset";
RaycastEventNode.OUTPUT_HIT = "hit";
RaycastEventNode.OUTPUT_MISS = "miss";

// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/nodes/event/Scene.ts
var Scene = __webpack_require__(84635);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/nodes/event/ScrollTrigger.ts
var ScrollTrigger = __webpack_require__(24732);
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/event/SetFlag.ts

var SetFlag_async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};





var FlagUpdateMode = /* @__PURE__ */ ((FlagUpdateMode2) => {
  FlagUpdateMode2["SET"] = "set";
  FlagUpdateMode2["TOGGLE"] = "toggle";
  return FlagUpdateMode2;
})(FlagUpdateMode || {});
const FLAG_UPDATE_MODES = ["set" /* SET */, "toggle" /* TOGGLE */];
class SetFlagParamsConfig extends params_ParamsConfig/* NodeParamsConfig */.yI {
  constructor() {
    super(...arguments);
    /** @param mask to select which nodes this can change the flags of */
    this.mask = params_ParamsConfig/* ParamConfig.STRING */.XC.STRING("/geo*", { separatorAfter: true });
    /** @param toggle on to update the display flag */
    this.tdisplay = params_ParamsConfig/* ParamConfig.BOOLEAN */.XC.BOOLEAN(0);
    /** @param sets how the display flag will be updated (set to a value or toggle) */
    this.displayMode = params_ParamsConfig/* ParamConfig.INTEGER */.XC.INTEGER(FLAG_UPDATE_MODES.indexOf("set" /* SET */), {
      visibleIf: { tdisplay: 1 },
      menu: {
        entries: FLAG_UPDATE_MODES.map((name, value) => {
          return { name, value };
        })
      }
    });
    /** @param new display flag state */
    this.display = params_ParamsConfig/* ParamConfig.BOOLEAN */.XC.BOOLEAN(0, {
      visibleIf: { tdisplay: 1, displayMode: FLAG_UPDATE_MODES.indexOf("set" /* SET */) },
      separatorAfter: true
    });
    /** @param toggle on to update the bypass flag */
    this.tbypass = params_ParamsConfig/* ParamConfig.BOOLEAN */.XC.BOOLEAN(0);
    /** @param sets how the bypass flag will be updated (set to a value or toggle) */
    this.bypassMode = params_ParamsConfig/* ParamConfig.INTEGER */.XC.INTEGER(FLAG_UPDATE_MODES.indexOf("set" /* SET */), {
      visibleIf: { tbypass: 1 },
      menu: {
        entries: FLAG_UPDATE_MODES.map((name, value) => {
          return { name, value };
        })
      }
    });
    /** @param new bypass flag state */
    this.bypass = params_ParamsConfig/* ParamConfig.BOOLEAN */.XC.BOOLEAN(0, {
      visibleIf: { tbypass: 1, displayMode: FLAG_UPDATE_MODES.indexOf("set" /* SET */) }
    });
    /** @param button to trigger the node. Useful to debug */
    this.execute = params_ParamsConfig/* ParamConfig.BUTTON */.XC.BUTTON(null, {
      callback: (node) => {
        SetFlagEventNode.PARAM_CALLBACK_execute(node);
      }
    });
  }
}
const SetFlag_ParamsConfig = new SetFlagParamsConfig();
class SetFlagEventNode extends event_Base/* TypedEventNode */.F {
  constructor() {
    super(...arguments);
    this.paramsConfig = SetFlag_ParamsConfig;
  }
  static type() {
    return "setFlag";
  }
  initializeNode() {
    this.io.inputs.setNamedInputConnectionPoints([
      new Event/* EventConnectionPoint */.TG("trigger", Event/* EventConnectionPointType.BASE */.M$.BASE)
    ]);
  }
  processEvent(eventContext) {
    return SetFlag_async(this, null, function* () {
      let mask = this.pv.mask;
      if (eventContext.value) {
        const node = eventContext.value.node;
        if (node) {
          const parent = node.parent();
          if (parent) {
            mask = `${parent.path()}/${mask}`;
          }
        }
      }
      const nodes = this.scene().nodesController.nodesFromMask(mask);
      for (const node of nodes) {
        this._updateNodeFlags(node);
      }
    });
  }
  _updateNodeFlags(node) {
    this._updateNodeDisplayFlag(node);
    this._updateNodeBypassFlag(node);
  }
  _updateNodeDisplayFlag(node) {
    var _a;
    if (!(0,Type/* isBooleanTrue */.bI)(this.pv.tdisplay)) {
      return;
    }
    if (!((_a = node.flags) == null ? void 0 : _a.hasDisplay())) {
      return;
    }
    const displayFlag = node.flags.display;
    if (!displayFlag) {
      return;
    }
    const mode = FLAG_UPDATE_MODES[this.pv.displayMode];
    switch (mode) {
      case "set" /* SET */: {
        displayFlag.set((0,Type/* isBooleanTrue */.bI)(this.pv.display));
        return;
      }
      case "toggle" /* TOGGLE */: {
        displayFlag.set(!displayFlag.active());
        return;
      }
    }
    Assert/* TypeAssert.unreachable */.f.unreachable(mode);
  }
  _updateNodeBypassFlag(node) {
    var _a;
    if (!(0,Type/* isBooleanTrue */.bI)(this.pv.tbypass)) {
      return;
    }
    if (!((_a = node.flags) == null ? void 0 : _a.hasBypass())) {
      return;
    }
    const bypassFlag = node.flags.bypass;
    if (!bypassFlag) {
      return;
    }
    const mode = FLAG_UPDATE_MODES[this.pv.bypassMode];
    switch (mode) {
      case "set" /* SET */: {
        bypassFlag.set((0,Type/* isBooleanTrue */.bI)(this.pv.bypass));
        return;
      }
      case "toggle" /* TOGGLE */: {
        bypassFlag.set(!bypassFlag.active());
        return;
      }
    }
    Assert/* TypeAssert.unreachable */.f.unreachable(mode);
  }
  static PARAM_CALLBACK_execute(node) {
    node.processEvent({});
  }
}

// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/nodes/event/SetParam.ts
var SetParam = __webpack_require__(27436);
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/event/Sequence.ts



const Sequence_INPUT_NAME = "trigger";

class PassEventParamsConfig extends params_ParamsConfig/* NodeParamsConfig */.yI {
  constructor() {
    super(...arguments);
    /** @param number of possible outputs */
    this.outputsCount = params_ParamsConfig/* ParamConfig.INTEGER */.XC.INTEGER(5, {
      range: [1, 10],
      rangeLocked: [true, false]
    });
  }
}
const Sequence_ParamsConfig = new PassEventParamsConfig();
class SequenceEventNode extends event_Base/* TypedEventNode */.F {
  constructor() {
    super(...arguments);
    this.paramsConfig = Sequence_ParamsConfig;
  }
  static type() {
    return "sequence";
  }
  initializeNode() {
    this.io.connection_points.set_input_name_function(() => Sequence_INPUT_NAME);
    this.io.connection_points.set_expected_input_types_function(() => [Event/* EventConnectionPointType.BASE */.M$.BASE]);
    this.io.connection_points.set_expected_output_types_function(this._expected_output_types.bind(this));
    this.io.connection_points.set_output_name_function(this._output_name.bind(this));
  }
  _expected_output_types() {
    const list = new Array(this.pv.outputsCount);
    list.fill(Event/* EventConnectionPointType.BASE */.M$.BASE);
    return list;
  }
  _output_name(index) {
    return `out${index}`;
  }
  processEvent(event_context) {
    const connectionPoints = this.io.outputs.namedOutputConnectionPoints();
    if (!connectionPoints) {
      return;
    }
    for (const connectionPoint of connectionPoints) {
      this.dispatchEventToOutput(connectionPoint.name(), event_context);
    }
  }
}

// EXTERNAL MODULE: ../@polygonjs/polygonjs/node_modules/lodash-es/throttle.js
var throttle = __webpack_require__(54514);
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/event/Throttle.ts

var Throttle_defProp = Object.defineProperty;
var Throttle_getOwnPropSymbols = Object.getOwnPropertySymbols;
var Throttle_hasOwnProp = Object.prototype.hasOwnProperty;
var Throttle_propIsEnum = Object.prototype.propertyIsEnumerable;
var Throttle_defNormalProp = (obj, key, value) => key in obj ? Throttle_defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var Throttle_spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (Throttle_hasOwnProp.call(b, prop))
      Throttle_defNormalProp(a, prop, b[prop]);
  if (Throttle_getOwnPropSymbols)
    for (var prop of Throttle_getOwnPropSymbols(b)) {
      if (Throttle_propIsEnum.call(b, prop))
        Throttle_defNormalProp(a, prop, b[prop]);
    }
  return a;
};




const Throttle_callbackOption = {
  callback: (node) => {
    ThrottleEventNode.PARAM_CALLBACK_resetDebouncedFunc(node);
  }
};
class ThrottleEventParamsConfig extends params_ParamsConfig/* NodeParamsConfig */.yI {
  constructor() {
    super(...arguments);
    /** @param max time between each event */
    this.time = params_ParamsConfig/* ParamConfig.INTEGER */.XC.INTEGER(100, Throttle_spreadValues({
      range: [0, 1e3],
      rangeLocked: [true, false]
    }, Throttle_callbackOption));
    /** @param defines if event is dispatched on the leading edge of the timeout */
    this.leading = params_ParamsConfig/* ParamConfig.BOOLEAN */.XC.BOOLEAN(true, Throttle_callbackOption);
    /** @param defines if event is trailing on the leading edge of the timeout */
    this.trailing = params_ParamsConfig/* ParamConfig.BOOLEAN */.XC.BOOLEAN(true, Throttle_callbackOption);
  }
}
const Throttle_ParamsConfig = new ThrottleEventParamsConfig();
const _ThrottleEventNode = class extends event_Base/* TypedEventNode */.F {
  constructor() {
    super(...arguments);
    this.paramsConfig = Throttle_ParamsConfig;
  }
  static type() {
    return "throttle";
  }
  initializeNode() {
    this.io.inputs.setNamedInputConnectionPoints([
      new Event/* EventConnectionPoint */.TG("trigger", Event/* EventConnectionPointType.BASE */.M$.BASE)
    ]);
    this.io.outputs.setNamedOutputConnectionPoints([
      new Event/* EventConnectionPoint */.TG(_ThrottleEventNode.OUTPUT_NAME, Event/* EventConnectionPointType.BASE */.M$.BASE)
    ]);
  }
  processEvent(eventContext) {
    this._lastEventContextReceived = eventContext;
    this._debouncedFunc = this._debouncedFunc || this._buildDebouncedFunc();
    this._debouncedFunc();
  }
  _buildDebouncedFunc() {
    const { leading, trailing, time } = this.pv;
    const func = () => {
      if (this._lastEventContextReceived) {
        this.dispatchEventToOutput(_ThrottleEventNode.OUTPUT_NAME, this._lastEventContextReceived);
      }
    };
    return (0,throttle/* default */.Z)(func, time, { leading, trailing });
  }
  _resetDebouncedFunc() {
    this._debouncedFunc = void 0;
  }
  static PARAM_CALLBACK_resetDebouncedFunc(node) {
    node._resetDebouncedFunc();
  }
};
let ThrottleEventNode = _ThrottleEventNode;
ThrottleEventNode.OUTPUT_NAME = "output";

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/event/Timer.ts


const INPUT_START_NAME = "start";
const INPUT_END_NAME = "stop";
const Timer_OUTPUT_NAME = "tick";


class TimerEventParamsConfig extends params_ParamsConfig/* NodeParamsConfig */.yI {
  constructor() {
    super(...arguments);
    /** @param period between each interval */
    this.period = params_ParamsConfig/* ParamConfig.INTEGER */.XC.INTEGER(1e3);
    /** @param number of times the timer should repeat. Set to -1 to never stop */
    this.count = params_ParamsConfig/* ParamConfig.INTEGER */.XC.INTEGER(-1);
  }
}
const Timer_ParamsConfig = new TimerEventParamsConfig();
class TimerEventNode extends event_Base/* TypedEventNode */.F {
  constructor() {
    super(...arguments);
    this.paramsConfig = Timer_ParamsConfig;
    this._timer_active = false;
    this._current_count = 0;
  }
  static type() {
    return "timer";
  }
  initializeNode() {
    this.io.inputs.setNamedInputConnectionPoints([
      new Event/* EventConnectionPoint */.TG(INPUT_START_NAME, Event/* EventConnectionPointType.BASE */.M$.BASE, this._start_timer.bind(this)),
      new Event/* EventConnectionPoint */.TG(INPUT_END_NAME, Event/* EventConnectionPointType.BASE */.M$.BASE, this._stop_timer.bind(this))
    ]);
    this.io.outputs.setNamedOutputConnectionPoints([
      new Event/* EventConnectionPoint */.TG(Timer_OUTPUT_NAME, Event/* EventConnectionPointType.BASE */.M$.BASE)
    ]);
  }
  _start_timer(event_context) {
    if (!this._timer_active) {
      this._timer_active = true;
      this._current_count = 0;
    }
    this._run_timer(event_context);
  }
  _stop_timer() {
    this._timer_active = false;
  }
  _run_timer(event_context) {
    setTimeout(() => {
      if (this._timer_active) {
        if (this.pv.count <= 0 || this._current_count < this.pv.count) {
          this.dispatchEventToOutput(Timer_OUTPUT_NAME, event_context);
          this._current_count += 1;
          this._run_timer(event_context);
        } else {
          this._stop_timer();
        }
      }
    }, this.pv.period);
  }
}

// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/nodes/event/Touch.ts
var Touch = __webpack_require__(94248);
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/event/Viewer.ts




class ViewerParamsConfig extends params_ParamsConfig/* NodeParamsConfig */.yI {
  constructor() {
    super(...arguments);
    /** @param sets the class of the viewer */
    this.className = params_ParamsConfig/* ParamConfig.STRING */.XC.STRING("active");
  }
}
const Viewer_ParamsConfig = new ViewerParamsConfig();
class ViewerEventNode extends event_Base/* TypedEventNode */.F {
  constructor() {
    super(...arguments);
    this.paramsConfig = Viewer_ParamsConfig;
  }
  static type() {
    return "viewer";
  }
  initializeNode() {
    this.io.inputs.setNamedInputConnectionPoints([
      // class
      new Event/* EventConnectionPoint */.TG(
        "setCss",
        Event/* EventConnectionPointType.BASE */.M$.BASE,
        this._process_trigger_setClass.bind(this)
      ),
      new Event/* EventConnectionPoint */.TG(
        "unSetCss",
        Event/* EventConnectionPointType.BASE */.M$.BASE,
        this._process_trigger_unsetClass.bind(this)
      )
      // controls
      // new EventConnectionPoint(
      // 	'createControls',
      // 	EventConnectionPointType.BASE,
      // 	this._process_trigger_createControls.bind(this)
      // ),
      // new EventConnectionPoint(
      // 	'disposeControls',
      // 	EventConnectionPointType.BASE,
      // 	this._process_trigger_disposeControls.bind(this)
      // ),
    ]);
  }
  _getViewer(context) {
    if (context.viewer) {
      return context.viewer;
    } else {
      return this.scene().viewersRegister.firstViewer();
    }
  }
  _process_trigger_setClass(context) {
    var _a;
    const canvas = (_a = this._getViewer(context)) == null ? void 0 : _a.canvas();
    if (canvas) {
      canvas.classList.add(this.pv.className);
    }
  }
  _process_trigger_unsetClass(context) {
    var _a;
    const canvas = (_a = this._getViewer(context)) == null ? void 0 : _a.canvas();
    if (canvas) {
      canvas.classList.remove(this.pv.className);
    }
  }
  // private _process_trigger_createControls(context: EventContext<Event>) {
  // 	this.scene().viewersRegister.traverseViewers((v) => {
  // 		v.controlsController()?.create_controls();
  // 	});
  // }
  // private _process_trigger_disposeControls(context: EventContext<Event>) {
  // 	this.scene().viewersRegister.traverseViewers((v) => {
  // 		v.controlsController()?.dispose_controls();
  // 	});
  // }
}

// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/nodes/event/Window.ts
var Window = __webpack_require__(58558);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/nodes/event/_BaseManager.ts
var event_BaseManager = __webpack_require__(1814);
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/event/ActorsNetwork.ts







class ActorsNetworkEventNode extends event_BaseManager/* ParamLessBaseNetworkEventNode */.t {
  constructor() {
    super(...arguments);
    this._childrenControllerContext = poly_NodeContext/* NodeContext.JS */.sy.JS;
    //
    // ASSEMBLERS
    //
    this.persisted_config = new ActorPersistedConfig/* ActorPersistedConfig */.R(this);
    this._assemblerController = this._createAssemblerController();
    //
    // compilation
    //
    this.compilationController = new ActorCompilationController/* ActorCompilationController */.z7(this);
  }
  static type() {
    return poly_NodeContext/* NetworkNodeType.ACTOR */.kX.ACTOR;
  }
  createNode(node_class, options) {
    return super.createNode(node_class, options);
  }
  children() {
    return super.children();
  }
  nodesByType(type) {
    return super.nodesByType(type);
  }
  //
  childrenAllowed() {
    if (this.assemblerController()) {
      return super.childrenAllowed();
    }
    return false;
  }
  sceneReadonly() {
    return this.assemblerController() == null;
  }
  assemblerController() {
    return this._assemblerController;
  }
  usedAssembler() {
    return _BaseRegister/* AssemblerName.JS_ACTOR */.Q.JS_ACTOR;
  }
  _createAssemblerController() {
    return Poly/* Poly.assemblersRegister.assembler */.L.assemblersRegister.assembler(this, this.usedAssembler());
  }
  compile() {
    this.compilationController.compile();
  }
  cook() {
    this.compilationController.compileIfRequired();
    this.cookController.endCook();
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/event/AnimationsNetwork.ts



class AnimationsNetworkEventNode extends event_BaseManager/* ParamLessBaseNetworkEventNode */.t {
  constructor() {
    super(...arguments);
    this._childrenControllerContext = poly_NodeContext/* NodeContext.ANIM */.sy.ANIM;
  }
  static type() {
    return poly_NodeContext/* NetworkNodeType.ANIM */.kX.ANIM;
  }
  createNode(node_class, options) {
    return super.createNode(node_class, options);
  }
  children() {
    return super.children();
  }
  nodesByType(type) {
    return super.nodesByType(type);
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/event/AudioNetwork.ts



class AudioNetworkEventNode extends event_BaseManager/* ParamLessBaseNetworkEventNode */.t {
  constructor() {
    super(...arguments);
    this._childrenControllerContext = poly_NodeContext/* NodeContext.AUDIO */.sy.AUDIO;
  }
  static type() {
    return poly_NodeContext/* NetworkNodeType.AUDIO */.kX.AUDIO;
  }
  createNode(node_class, options) {
    return super.createNode(node_class, options);
  }
  children() {
    return super.children();
  }
  nodesByType(type) {
    return super.nodesByType(type);
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/event/CopNetwork.ts



class CopNetworkEventNode extends event_BaseManager/* ParamLessBaseNetworkEventNode */.t {
  constructor() {
    super(...arguments);
    this._childrenControllerContext = poly_NodeContext/* NodeContext.COP */.sy.COP;
  }
  static type() {
    return poly_NodeContext/* NetworkNodeType.COP */.kX.COP;
  }
  createNode(node_class, options) {
    return super.createNode(node_class, options);
  }
  children() {
    return super.children();
  }
  nodesByType(type) {
    return super.nodesByType(type);
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/event/EventsNetwork.ts



class EventsNetworkEventNode extends event_BaseManager/* ParamLessBaseNetworkEventNode */.t {
  constructor() {
    super(...arguments);
    this._childrenControllerContext = poly_NodeContext/* NodeContext.EVENT */.sy.EVENT;
  }
  static type() {
    return poly_NodeContext/* NetworkNodeType.EVENT */.kX.EVENT;
  }
  createNode(node_class, options) {
    return super.createNode(node_class, options);
  }
  children() {
    return super.children();
  }
  nodesByType(type) {
    return super.nodesByType(type);
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/event/MaterialsNetwork.ts



class MaterialsNetworkEventNode extends event_BaseManager/* ParamLessBaseNetworkEventNode */.t {
  constructor() {
    super(...arguments);
    this._childrenControllerContext = poly_NodeContext/* NodeContext.MAT */.sy.MAT;
  }
  static type() {
    return poly_NodeContext/* NetworkNodeType.MAT */.kX.MAT;
  }
  createNode(node_class, options) {
    return super.createNode(node_class, options);
  }
  children() {
    return super.children();
  }
  nodesByType(type) {
    return super.nodesByType(type);
  }
}

// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/nodes/event/PostProcessNetwork.ts
var event_PostProcessNetwork = __webpack_require__(83015);
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/event/RenderersNetwork.ts



class RenderersNetworkEventNode extends event_BaseManager/* ParamLessBaseNetworkEventNode */.t {
  constructor() {
    super(...arguments);
    this._childrenControllerContext = poly_NodeContext/* NodeContext.ROP */.sy.ROP;
  }
  static type() {
    return poly_NodeContext/* NetworkNodeType.ROP */.kX.ROP;
  }
  createNode(node_class, options) {
    return super.createNode(node_class, options);
  }
  children() {
    return super.children();
  }
  nodesByType(type) {
    return super.nodesByType(type);
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/poly/registers/nodes/Event.ts












































class EventRegister {
  static run(poly) {
    poly.registerNode(Animation/* AnimationEventNode */.N, CATEGORY_EVENT.SCENE);
    poly.registerNode(AnyEventNode, CATEGORY_EVENT.MISC);
    poly.registerNode(AudioEventNode, CATEGORY_EVENT.MISC);
    poly.registerNode(Block/* BlockEventNode */.G, CATEGORY_EVENT.MISC);
    poly.registerNode(ButtonEventNode, CATEGORY_EVENT.MISC);
    poly.registerNode(CameraMapControls/* CameraMapControlsEventNode */.K, CATEGORY_EVENT.CAMERA);
    poly.registerNode(CameraOrbitControls/* CameraOrbitControlsEventNode */.Oc, CATEGORY_EVENT.CAMERA);
    poly.registerNode(CameraPanZoomControlsEventNode, CATEGORY_EVENT.CAMERA);
    poly.registerNode(DebounceEventNode, CATEGORY_EVENT.MISC);
    poly.registerNode(DelayEventNode, CATEGORY_EVENT.MISC);
    poly.registerNode(CodeEventNode, CATEGORY_EVENT.ADVANCED);
    poly.registerNode(Drag/* DragEventNode */.l, CATEGORY_EVENT.INPUT);
    poly.registerNode(FirstPersonControls/* FirstPersonControlsEventNode */.a, CATEGORY_EVENT.CAMERA);
    poly.registerNode(IntersectDataEventNode, CATEGORY_EVENT.MISC);
    poly.registerNode(Keyboard/* KeyboardEventNode */.b, CATEGORY_EVENT.INPUT);
    poly.registerNode(LimitEventNode, CATEGORY_EVENT.MISC);
    poly.registerNode(MessageEventNode, CATEGORY_EVENT.MISC);
    poly.registerNode(MobileJoystickControls/* MobileJoystickControlsEventNode */.w, CATEGORY_EVENT.CAMERA);
    poly.registerNode(Mouse/* MouseEventNode */.F, CATEGORY_EVENT.INPUT);
    poly.registerNode(NodeCookEventNode, CATEGORY_EVENT.SCENE);
    poly.registerNode(NullEventNode, CATEGORY_EVENT.MISC);
    poly.registerNode(Param/* ParamEventNode */.v, CATEGORY_EVENT.INPUT);
    poly.registerNode(Pointer/* PointerEventNode */.B, CATEGORY_EVENT.INPUT);
    poly.registerNode(RaycastEventNode, CATEGORY_EVENT.MISC);
    poly.registerNode(Scene/* SceneEventNode */.y, CATEGORY_EVENT.SCENE);
    poly.registerNode(ScrollTrigger/* ScrollTriggerEventNode */.n, CATEGORY_EVENT.MISC);
    poly.registerNode(SetFlagEventNode, CATEGORY_EVENT.SCENE);
    poly.registerNode(SetParam/* SetParamEventNode */.N, CATEGORY_EVENT.SCENE);
    poly.registerNode(SequenceEventNode, CATEGORY_EVENT.MISC);
    poly.registerNode(ThrottleEventNode, CATEGORY_EVENT.MISC);
    poly.registerNode(TimerEventNode, CATEGORY_EVENT.MISC);
    poly.registerNode(Touch/* TouchEventNode */.F, CATEGORY_EVENT.INPUT);
    poly.registerNode(ViewerEventNode, CATEGORY_EVENT.MISC);
    poly.registerNode(Window/* WindowEventNode */.l, CATEGORY_EVENT.INPUT);
    poly.registerNode(ActorsNetworkEventNode, CATEGORY_EVENT.NETWORK);
    poly.registerNode(AnimationsNetworkEventNode, CATEGORY_EVENT.NETWORK);
    poly.registerNode(AudioNetworkEventNode, CATEGORY_EVENT.NETWORK);
    poly.registerNode(CopNetworkEventNode, CATEGORY_EVENT.NETWORK);
    poly.registerNode(EventsNetworkEventNode, CATEGORY_EVENT.NETWORK);
    poly.registerNode(MaterialsNetworkEventNode, CATEGORY_EVENT.NETWORK);
    poly.registerNode(event_PostProcessNetwork/* PostProcessNetworkEventNode */.p, CATEGORY_EVENT.NETWORK);
    poly.registerNode(RenderersNetworkEventNode, CATEGORY_EVENT.NETWORK);
  }
}

// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/nodes/gl/_Base.ts
var gl_Base = __webpack_require__(69444);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/core/ThreeToGl.ts
var ThreeToGl = __webpack_require__(81556);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/nodes/utils/io/connections/Gl.ts
var Gl = __webpack_require__(63060);
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/gl/_ConversionMisc.ts





const OUTPUT_NAME_INT = "int";
class FloatToIntGlParamsConfig extends params_ParamsConfig/* NodeParamsConfig */.yI {
  constructor() {
    super(...arguments);
    this.float = params_ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(0);
  }
}
const ParamsConfigFloatToInt = new FloatToIntGlParamsConfig();
class FloatToIntGlNode extends gl_Base/* TypedGlNode */.hD {
  constructor() {
    super(...arguments);
    this.paramsConfig = ParamsConfigFloatToInt;
  }
  static type() {
    return "floatToInt";
  }
  initializeNode() {
    this.io.outputs.setNamedOutputConnectionPoints([
      new Gl/* GlConnectionPoint */.E(OUTPUT_NAME_INT, Gl/* GlConnectionPointType.INT */.Dv.INT)
    ]);
  }
  setLines(shaders_collection_controller) {
    const float = this.variableForInputParam(this.p.float);
    const int = this.glVarName(OUTPUT_NAME_INT);
    const body_line = `int ${int} = int(${ThreeToGl/* ThreeToGl.float */._.float(float)})`;
    shaders_collection_controller.addBodyLines(this, [body_line]);
  }
}
const OUTPUT_NAME_FLOAT = "float";
class IntToFloatGlParamsConfig extends params_ParamsConfig/* NodeParamsConfig */.yI {
  constructor() {
    super(...arguments);
    this.int = params_ParamsConfig/* ParamConfig.INTEGER */.XC.INTEGER(0);
  }
}
const ParamsConfigIntToFloat = new IntToFloatGlParamsConfig();
class IntToFloatGlNode extends gl_Base/* TypedGlNode */.hD {
  constructor() {
    super(...arguments);
    this.paramsConfig = ParamsConfigIntToFloat;
  }
  static type() {
    return "intToFloat";
  }
  initializeNode() {
    this.io.outputs.setNamedOutputConnectionPoints([
      new Gl/* GlConnectionPoint */.E(OUTPUT_NAME_FLOAT, Gl/* GlConnectionPointType.FLOAT */.Dv.FLOAT)
    ]);
  }
  setLines(shaders_collection_controller) {
    const int = this.variableForInputParam(this.p.int);
    const float = this.glVarName(OUTPUT_NAME_FLOAT);
    const body_line = `float ${float} = float(${ThreeToGl/* ThreeToGl.integer */._.integer(int)})`;
    shaders_collection_controller.addBodyLines(this, [body_line]);
  }
}
const OUTPUT_NAME_BOOL = "bool";
class IntToBoolGlParamsConfig extends params_ParamsConfig/* NodeParamsConfig */.yI {
  constructor() {
    super(...arguments);
    this.int = params_ParamsConfig/* ParamConfig.INTEGER */.XC.INTEGER(0);
  }
}
const ParamsConfigIntToBool = new IntToBoolGlParamsConfig();
class IntToBoolGlNode extends gl_Base/* TypedGlNode */.hD {
  constructor() {
    super(...arguments);
    this.paramsConfig = ParamsConfigIntToBool;
  }
  static type() {
    return "intToBool";
  }
  initializeNode() {
    this.io.outputs.setNamedOutputConnectionPoints([
      new Gl/* GlConnectionPoint */.E(OUTPUT_NAME_BOOL, Gl/* GlConnectionPointType.BOOL */.Dv.BOOL)
    ]);
  }
  setLines(shaders_collection_controller) {
    const int = this.variableForInputParam(this.p.int);
    const bool = this.glVarName(OUTPUT_NAME_BOOL);
    const body_line = `bool ${bool} = bool(${ThreeToGl/* ThreeToGl.integer */._.integer(int)})`;
    shaders_collection_controller.addBodyLines(this, [body_line]);
  }
}
class BoolToIntGlParamsConfig extends params_ParamsConfig/* NodeParamsConfig */.yI {
  constructor() {
    super(...arguments);
    this.bool = params_ParamsConfig/* ParamConfig.BOOLEAN */.XC.BOOLEAN(0);
  }
}
const ParamsConfigBoolToInt = new BoolToIntGlParamsConfig();
class BoolToIntGlNode extends gl_Base/* TypedGlNode */.hD {
  constructor() {
    super(...arguments);
    this.paramsConfig = ParamsConfigBoolToInt;
  }
  static type() {
    return "boolToInt";
  }
  initializeNode() {
    this.io.outputs.setNamedOutputConnectionPoints([
      new Gl/* GlConnectionPoint */.E(OUTPUT_NAME_INT, Gl/* GlConnectionPointType.INT */.Dv.INT)
    ]);
  }
  setLines(shaders_collection_controller) {
    const bool = this.variableForInputParam(this.p.bool);
    const int = this.glVarName(OUTPUT_NAME_INT);
    const body_line = `int ${int} = int(${ThreeToGl/* ThreeToGl.bool */._.bool(bool)})`;
    shaders_collection_controller.addBodyLines(this, [body_line]);
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/gl/_ConversionToVec.ts





class FloatToVec2GlParamsConfig extends params_ParamsConfig/* NodeParamsConfig */.yI {
  constructor() {
    super(...arguments);
    this.x = params_ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(0);
    this.y = params_ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(0);
  }
}
const ParamsConfig2 = new FloatToVec2GlParamsConfig();
const _FloatToVec2GlNode = class extends gl_Base/* TypedGlNode */.hD {
  constructor() {
    super(...arguments);
    this.paramsConfig = ParamsConfig2;
  }
  static type() {
    return "floatToVec2";
  }
  initializeNode() {
    this.io.outputs.setNamedOutputConnectionPoints([
      new Gl/* GlConnectionPoint */.E(_FloatToVec2GlNode.OUTPUT_NAME, Gl/* GlConnectionPointType.VEC2 */.Dv.VEC2)
    ]);
  }
  setLines(shaders_collection_controller) {
    const x = this.variableForInputParam(this.p.x);
    const y = this.variableForInputParam(this.p.y);
    const vec = this.glVarName(_FloatToVec2GlNode.OUTPUT_NAME);
    const body_line = `vec2 ${vec} = ${ThreeToGl/* ThreeToGl.float2 */._.float2(x, y)}`;
    shaders_collection_controller.addBodyLines(this, [body_line]);
  }
};
let FloatToVec2GlNode = _FloatToVec2GlNode;
FloatToVec2GlNode.OUTPUT_NAME = "vec2";
class FloatToVec3GlParamsConfig extends params_ParamsConfig/* NodeParamsConfig */.yI {
  constructor() {
    super(...arguments);
    this.x = params_ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(0);
    this.y = params_ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(0);
    this.z = params_ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(0);
  }
}
const ParamsConfig3 = new FloatToVec3GlParamsConfig();
const _FloatToVec3GlNode = class extends gl_Base/* TypedGlNode */.hD {
  constructor() {
    super(...arguments);
    this.paramsConfig = ParamsConfig3;
  }
  static type() {
    return "floatToVec3";
  }
  initializeNode() {
    this.io.outputs.setNamedOutputConnectionPoints([
      new Gl/* GlConnectionPoint */.E(_FloatToVec3GlNode.OUTPUT_NAME, Gl/* GlConnectionPointType.VEC3 */.Dv.VEC3)
    ]);
  }
  setLines(shaders_collection_controller) {
    const x = this.variableForInputParam(this.p.x);
    const y = this.variableForInputParam(this.p.y);
    const z = this.variableForInputParam(this.p.z);
    const vec = this.glVarName(_FloatToVec3GlNode.OUTPUT_NAME);
    const body_line = `vec3 ${vec} = ${ThreeToGl/* ThreeToGl.float3 */._.float3(x, y, z)}`;
    shaders_collection_controller.addBodyLines(this, [body_line]);
  }
};
let FloatToVec3GlNode = _FloatToVec3GlNode;
FloatToVec3GlNode.OUTPUT_NAME = "vec3";
class FloatToVec4GlParamsConfig extends params_ParamsConfig/* NodeParamsConfig */.yI {
  constructor() {
    super(...arguments);
    this.x = params_ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(0);
    this.y = params_ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(0);
    this.z = params_ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(0);
    this.w = params_ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(0);
  }
}
const ParamsConfig4 = new FloatToVec4GlParamsConfig();
const _FloatToVec4GlNode = class extends gl_Base/* TypedGlNode */.hD {
  constructor() {
    super(...arguments);
    this.paramsConfig = ParamsConfig4;
  }
  static type() {
    return "floatToVec4";
  }
  initializeNode() {
    this.io.outputs.setNamedOutputConnectionPoints([
      new Gl/* GlConnectionPoint */.E(_FloatToVec4GlNode.OUTPUT_NAME, Gl/* GlConnectionPointType.VEC4 */.Dv.VEC4)
    ]);
  }
  setLines(shaders_collection_controller) {
    const x = this.variableForInputParam(this.p.x);
    const y = this.variableForInputParam(this.p.y);
    const z = this.variableForInputParam(this.p.z);
    const w = this.variableForInputParam(this.p.w);
    const vec = this.glVarName(_FloatToVec4GlNode.OUTPUT_NAME);
    const body_line = `vec4 ${vec} = ${ThreeToGl/* ThreeToGl.float4 */._.float4(x, y, z, w)}`;
    shaders_collection_controller.addBodyLines(this, [body_line]);
  }
};
let FloatToVec4GlNode = _FloatToVec4GlNode;
FloatToVec4GlNode.OUTPUT_NAME = "vec4";

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/gl/_ConversionVecTo.ts





class VecToParamsGlConfig extends params_ParamsConfig/* NodeParamsConfig */.yI {
}
const _ConversionVecTo_ParamsConfig = new VecToParamsGlConfig();
class BaseVecToGlNode extends gl_Base/* TypedGlNode */.hD {
  constructor() {
    super(...arguments);
    this.paramsConfig = _ConversionVecTo_ParamsConfig;
  }
}
function VecToGlFactory(type, options) {
  const components = options.components;
  const param_type = options.param_type;
  return class VecToGlNode extends BaseVecToGlNode {
    static type() {
      return type;
    }
    initializeNode() {
      this.io.outputs.setNamedOutputConnectionPoints(
        components.map((c) => {
          return new Gl/* GlConnectionPoint */.E(c, Gl/* GlConnectionPointType.FLOAT */.Dv.FLOAT);
        })
      );
    }
    createParams() {
      this.addParam(param_type, "vec", components.map((c) => 0));
    }
    setLines(shaders_collection_controller) {
      const body_lines = [];
      const vec = this.variableForInput("vec");
      this.io.outputs.used_output_names().forEach((c) => {
        const var_name = this.glVarName(c);
        body_lines.push(`float ${var_name} = ${vec}.${c}`);
      });
      shaders_collection_controller.addBodyLines(this, body_lines);
    }
  };
}
const components_v2 = ["x", "y"];
const components_v3 = ["x", "y", "z"];
const components_v4 = ["x", "y", "z", "w"];
class Vec2ToFloatGlNode extends VecToGlFactory("vec2ToFloat", {
  components: ["x", "y"],
  param_type: ParamType/* ParamType.VECTOR2 */._.VECTOR2
}) {
}
class Vec3ToFloatGlNode extends VecToGlFactory("vec3ToFloat", {
  components: ["x", "y", "z"],
  param_type: ParamType/* ParamType.VECTOR3 */._.VECTOR3
}) {
}
class Vec4ToFloatGlNode extends VecToGlFactory("vec4ToFloat", {
  components: components_v4,
  param_type: ParamType/* ParamType.VECTOR4 */._.VECTOR4
}) {
}
const _Vec4ToVec3GlNode = class extends BaseVecToGlNode {
  static type() {
    return "vec4ToVec3";
  }
  initializeNode() {
    this.io.outputs.setNamedOutputConnectionPoints([
      new Gl/* GlConnectionPoint */.E(_Vec4ToVec3GlNode.OUTPUT_NAME_VEC3, Gl/* GlConnectionPointType.VEC3 */.Dv.VEC3),
      new Gl/* GlConnectionPoint */.E(_Vec4ToVec3GlNode.OUTPUT_NAME_W, Gl/* GlConnectionPointType.FLOAT */.Dv.FLOAT)
    ]);
  }
  createParams() {
    this.addParam(ParamType/* ParamType.VECTOR4 */._.VECTOR4, _Vec4ToVec3GlNode.INPUT_NAME_VEC4, components_v4.map((c) => 0));
  }
  setLines(shaders_collection_controller) {
    const body_lines = [];
    const in_vec4 = _Vec4ToVec3GlNode.INPUT_NAME_VEC4;
    const out_vec3 = _Vec4ToVec3GlNode.OUTPUT_NAME_VEC3;
    const out_w = _Vec4ToVec3GlNode.OUTPUT_NAME_W;
    const vec = this.variableForInput(in_vec4);
    const used_output_names = this.io.outputs.used_output_names();
    if (used_output_names.indexOf(out_vec3) >= 0) {
      const var_name = this.glVarName(out_vec3);
      body_lines.push(`vec3 ${var_name} = ${vec}.xyz`);
    }
    if (used_output_names.indexOf(out_w) >= 0) {
      const var_name = this.glVarName(out_w);
      body_lines.push(`float ${var_name} = ${vec}.w`);
    }
    shaders_collection_controller.addBodyLines(this, body_lines);
  }
};
let Vec4ToVec3GlNode = _Vec4ToVec3GlNode;
Vec4ToVec3GlNode.INPUT_NAME_VEC4 = "vec4";
Vec4ToVec3GlNode.OUTPUT_NAME_VEC3 = "vec3";
Vec4ToVec3GlNode.OUTPUT_NAME_W = "w";
const _Vec3ToVec2GlNode = class extends BaseVecToGlNode {
  static type() {
    return "vec3ToVec2";
  }
  initializeNode() {
    this.io.outputs.setNamedOutputConnectionPoints([
      new Gl/* GlConnectionPoint */.E(_Vec3ToVec2GlNode.OUTPUT_NAME_VEC2, Gl/* GlConnectionPointType.VEC2 */.Dv.VEC2),
      new Gl/* GlConnectionPoint */.E(_Vec3ToVec2GlNode.OUTPUT_NAME_Z, Gl/* GlConnectionPointType.FLOAT */.Dv.FLOAT)
    ]);
  }
  createParams() {
    this.addParam(ParamType/* ParamType.VECTOR3 */._.VECTOR3, _Vec3ToVec2GlNode.INPUT_NAME_VEC3, components_v3.map((c) => 0));
  }
  setLines(shaders_collection_controller) {
    const body_lines = [];
    const in_vec3 = _Vec3ToVec2GlNode.INPUT_NAME_VEC3;
    const out_vec2 = _Vec3ToVec2GlNode.OUTPUT_NAME_VEC2;
    const out_z = _Vec3ToVec2GlNode.OUTPUT_NAME_Z;
    const vec = this.variableForInput(in_vec3);
    const used_output_names = this.io.outputs.used_output_names();
    if (used_output_names.indexOf(out_vec2) >= 0) {
      const var_name = this.glVarName(out_vec2);
      body_lines.push(`vec2 ${var_name} = ${vec}.xy`);
    }
    if (used_output_names.indexOf(out_z) >= 0) {
      const var_name = this.glVarName(out_z);
      body_lines.push(`float ${var_name} = ${vec}.z`);
    }
    shaders_collection_controller.addBodyLines(this, body_lines);
  }
};
let Vec3ToVec2GlNode = _Vec3ToVec2GlNode;
Vec3ToVec2GlNode.INPUT_NAME_VEC3 = "vec3";
Vec3ToVec2GlNode.OUTPUT_NAME_VEC2 = "vec2";
Vec3ToVec2GlNode.OUTPUT_NAME_Z = "z";
const _Vec2ToVec3GlNode = class extends BaseVecToGlNode {
  static type() {
    return "vec2ToVec3";
  }
  initializeNode() {
    this.io.outputs.setNamedOutputConnectionPoints([
      new Gl/* GlConnectionPoint */.E(_Vec2ToVec3GlNode.OUTPUT_NAME_VEC3, Gl/* GlConnectionPointType.VEC3 */.Dv.VEC3)
    ]);
  }
  createParams() {
    this.addParam(ParamType/* ParamType.VECTOR2 */._.VECTOR2, _Vec2ToVec3GlNode.INPUT_NAME_VEC2, components_v2.map((c) => 0));
    this.addParam(ParamType/* ParamType.FLOAT */._.FLOAT, _Vec2ToVec3GlNode.INPUT_NAME_Z, 0);
  }
  setLines(shaders_collection_controller) {
    const body_lines = [];
    const in_vec2 = _Vec2ToVec3GlNode.INPUT_NAME_VEC2;
    const in_z = _Vec2ToVec3GlNode.INPUT_NAME_Z;
    const out_vec3 = _Vec2ToVec3GlNode.OUTPUT_NAME_VEC3;
    const vec2 = this.variableForInput(in_vec2);
    const z = this.variableForInput(in_z);
    const var_name = this.glVarName(out_vec3);
    body_lines.push(`vec3 ${var_name} = vec3(${vec2}.xy, ${z})`);
    shaders_collection_controller.addBodyLines(this, body_lines);
  }
};
let Vec2ToVec3GlNode = _Vec2ToVec3GlNode;
Vec2ToVec3GlNode.INPUT_NAME_VEC2 = "vec2";
Vec2ToVec3GlNode.INPUT_NAME_Z = "z";
Vec2ToVec3GlNode.OUTPUT_NAME_VEC3 = "vec3";
const _Vec3ToVec4GlNode = class extends BaseVecToGlNode {
  static type() {
    return "vec3ToVec4";
  }
  initializeNode() {
    this.io.outputs.setNamedOutputConnectionPoints([
      new Gl/* GlConnectionPoint */.E(_Vec3ToVec4GlNode.OUTPUT_NAME_VEC4, Gl/* GlConnectionPointType.VEC4 */.Dv.VEC4)
    ]);
  }
  createParams() {
    this.addParam(ParamType/* ParamType.VECTOR3 */._.VECTOR3, _Vec3ToVec4GlNode.INPUT_NAME_VEC3, components_v3.map((c) => 0));
    this.addParam(ParamType/* ParamType.FLOAT */._.FLOAT, _Vec3ToVec4GlNode.INPUT_NAME_W, 0);
  }
  setLines(shaders_collection_controller) {
    const body_lines = [];
    const in_vec3 = _Vec3ToVec4GlNode.INPUT_NAME_VEC3;
    const in_w = _Vec3ToVec4GlNode.INPUT_NAME_W;
    const out_vec4 = _Vec3ToVec4GlNode.OUTPUT_NAME_VEC4;
    const vec3 = this.variableForInput(in_vec3);
    const w = this.variableForInput(in_w);
    const var_name = this.glVarName(out_vec4);
    body_lines.push(`vec4 ${var_name} = vec4(${vec3}.xyz, ${w})`);
    shaders_collection_controller.addBodyLines(this, body_lines);
  }
};
let Vec3ToVec4GlNode = _Vec3ToVec4GlNode;
Vec3ToVec4GlNode.INPUT_NAME_VEC3 = "vec3";
Vec3ToVec4GlNode.INPUT_NAME_W = "w";
Vec3ToVec4GlNode.OUTPUT_NAME_VEC4 = "vec4";

// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/core/ArrayUtils.ts
var ArrayUtils = __webpack_require__(87132);
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/gl/_BaseMathFunction.ts






class BaseGlMathFunctionParamsConfig extends params_ParamsConfig/* NodeParamsConfig */.yI {
}
const _BaseMathFunction_ParamsConfig = new BaseGlMathFunctionParamsConfig();
class BaseGlMathFunctionGlNode extends gl_Base/* TypedGlNode */.hD {
  constructor() {
    super(...arguments);
    this.paramsConfig = _BaseMathFunction_ParamsConfig;
  }
  gl_method_name() {
    return "";
  }
  gl_function_definitions() {
    return [];
  }
  initializeNode() {
    super.initializeNode();
    this.io.connection_points.set_expected_input_types_function(this._expected_input_types.bind(this));
    this.io.connection_points.set_expected_output_types_function(this._expected_output_types.bind(this));
    this.io.connection_points.set_input_name_function(this._gl_input_name.bind(this));
  }
  _expected_input_types() {
    const type = this.io.connection_points.first_input_connection_type() || Gl/* GlConnectionPointType.FLOAT */.Dv.FLOAT;
    if (this.io.connections.firstInputConnection()) {
      const connections = this.io.connections.inputConnections();
      if (connections) {
        const compactConnections = [];
        (0,ArrayUtils/* arrayCompact */.k)(connections, compactConnections);
        let count = Math.max(compactConnections.length + 1, 2);
        return (0,ArrayUtils/* rangeWithEnd */.Zi)(count).map((i) => type);
      } else {
        return [];
      }
    } else {
      return (0,ArrayUtils/* rangeWithEnd */.Zi)(2).map((i) => type);
    }
  }
  _expected_output_types() {
    const type = this._expected_input_types()[0];
    return [type];
  }
  _gl_input_name(index) {
    return "in";
  }
  setLines(shaders_collection_controller) {
    const inputConnectionPoints = this.io.inputs.namedInputConnectionPoints();
    const outputConnectionPoints = this.io.outputs.namedOutputConnectionPoints();
    if (!(inputConnectionPoints && outputConnectionPoints)) {
      return;
    }
    const firstConnectionPoint = outputConnectionPoints[0];
    if (!firstConnectionPoint) {
      return;
    }
    const var_type = firstConnectionPoint.type();
    const args = inputConnectionPoints.map((connection, i) => {
      const name = connection.name();
      return ThreeToGl/* ThreeToGl.any */._.any(this.variableForInput(name));
    });
    const joined_args = args.join(", ");
    const sum = this.glVarName(this.io.connection_points.output_name(0));
    const body_line = `${var_type} ${sum} = ${this.gl_method_name()}(${joined_args})`;
    shaders_collection_controller.addBodyLines(this, [body_line]);
    shaders_collection_controller.addDefinitions(this, this.gl_function_definitions());
  }
}
function inputTypeOrFloatExceptBool(inputType) {
  if (inputType == Gl/* GlConnectionPointType.BOOL */.Dv.BOOL) {
    inputType = Gl/* GlConnectionPointType.FLOAT */.Dv.FLOAT;
  }
  const type = inputType || Gl/* GlConnectionPointType.FLOAT */.Dv.FLOAT;
  return type;
}
class BaseNodeGlMathFunctionArg1GlNode extends BaseGlMathFunctionGlNode {
  _gl_input_name(index) {
    return "in";
  }
  _expected_input_types() {
    const type = inputTypeOrFloatExceptBool(this.io.connection_points.first_input_connection_type());
    return [type];
  }
}
class BaseNodeGlMathFunctionArg2GlNode extends BaseGlMathFunctionGlNode {
  _expected_input_types() {
    const type = inputTypeOrFloatExceptBool(this.io.connection_points.first_input_connection_type());
    return [type, type];
  }
}
class BaseNodeGlMathFunctionArg3GlNode extends BaseGlMathFunctionGlNode {
  _expected_input_types() {
    const type = inputTypeOrFloatExceptBool(this.io.connection_points.first_input_connection_type());
    return [type, type, type];
  }
}
class BaseNodeGlMathFunctionArg4GlNode extends BaseGlMathFunctionGlNode {
  _expected_input_types() {
    const type = inputTypeOrFloatExceptBool(this.io.connection_points.first_input_connection_type());
    return [type, type, type, type];
  }
}
class BaseNodeGlMathFunctionArg5GlNode extends BaseGlMathFunctionGlNode {
  _expected_input_types() {
    const type = inputTypeOrFloatExceptBool(this.io.connection_points.first_input_connection_type());
    return [type, type, type, type, type];
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/gl/_Math_Arg1.ts


function MathFunctionArg1Factory(type, options = {}) {
  const gl_method_name = options.method || type;
  const gl_output_name = options.out || "val";
  const gl_input_name = options.in || "in";
  return class Node extends BaseNodeGlMathFunctionArg1GlNode {
    static type() {
      return type;
    }
    initializeNode() {
      super.initializeNode();
      this.io.connection_points.set_input_name_function(this._gl_input_name.bind(this));
      this.io.connection_points.set_output_name_function(this._gl_output_name.bind(this));
    }
    _gl_input_name(index) {
      return gl_input_name;
    }
    _gl_output_name(index) {
      return gl_output_name;
    }
    gl_method_name() {
      return gl_method_name;
    }
  };
}
class AbsGlNode extends MathFunctionArg1Factory("abs") {
}
class AcosGlNode extends MathFunctionArg1Factory("acos", { out: "radians" }) {
}
class AsinGlNode extends MathFunctionArg1Factory("asin", { out: "radians" }) {
}
class AtanGlNode extends MathFunctionArg1Factory("atan", { out: "radians" }) {
}
class CeilGlNode extends MathFunctionArg1Factory("ceil") {
}
class CosGlNode extends MathFunctionArg1Factory("cos", { in: "radians" }) {
}
class DegreesGlNode extends MathFunctionArg1Factory("degrees", { in: "radians", out: "degrees" }) {
}
class ExpGlNode extends MathFunctionArg1Factory("exp") {
}
class Exp2GlNode extends MathFunctionArg1Factory("exp2") {
}
class FloorGlNode extends MathFunctionArg1Factory("floor") {
}
class FractGlNode extends MathFunctionArg1Factory("fract") {
}
class InverseSqrtGlNode extends MathFunctionArg1Factory("inverseSqrt", { method: "inversesqrt" }) {
}
class LogGlNode extends MathFunctionArg1Factory("log") {
}
class Log2GlNode extends MathFunctionArg1Factory("log2") {
}
class NormalizeGlNode extends MathFunctionArg1Factory("normalize", { out: "normalized" }) {
}
class RadiansGlNode extends MathFunctionArg1Factory("radians", { in: "degrees", out: "radians" }) {
}
class SignGlNode extends MathFunctionArg1Factory("sign") {
}
class SinGlNode extends MathFunctionArg1Factory("sin", { in: "radians" }) {
}
class SqrtGlNode extends MathFunctionArg1Factory("sqrt") {
}
class TanGlNode extends MathFunctionArg1Factory("tan") {
}

// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/nodes/gl/utils/GLDefinition.ts
var GLDefinition = __webpack_require__(95475);
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/gl/_Math_Arg2.ts




function MathFunctionArg2Factory(type, options = {}) {
  const gl_method_name = options.method || type;
  const gl_output_name = options.out || "val";
  const gl_input_names = options.in || ["in0", "in1"];
  const default_in_type = options.default_in_type;
  const allowed_in_types = options.allowed_in_types;
  const out_type = options.out_type;
  const functions = options.functions || [];
  return class Node extends BaseNodeGlMathFunctionArg2GlNode {
    static type() {
      return type;
    }
    initializeNode() {
      super.initializeNode();
      this.io.connection_points.set_input_name_function(this._gl_input_name.bind(this));
      this.io.connection_points.set_output_name_function(this._gl_output_name.bind(this));
      this.io.connection_points.set_expected_input_types_function(this._expected_input_types.bind(this));
      if (out_type) {
        this.io.connection_points.set_expected_output_types_function(() => [out_type]);
      }
    }
    _gl_input_name(index) {
      return gl_input_names[index];
    }
    _gl_output_name(index) {
      return gl_output_name;
    }
    gl_method_name() {
      return gl_method_name;
    }
    gl_function_definitions() {
      if (functions) {
        return functions.map((f) => new GLDefinition/* FunctionGLDefinition */.MR(this, f));
      } else {
        return [];
      }
    }
    _expected_input_types() {
      let first_input_type = this.io.connection_points.first_input_connection_type();
      const connectionPoints = this.io.inputs.namedInputConnectionPoints();
      if (first_input_type && allowed_in_types && connectionPoints) {
        if (!allowed_in_types.includes(first_input_type)) {
          const first_connection = connectionPoints[0];
          if (first_connection) {
            first_input_type = first_connection.type();
          } else {
            first_input_type = default_in_type;
          }
        }
      }
      const type2 = first_input_type || default_in_type || Gl/* GlConnectionPointType.FLOAT */.Dv.FLOAT;
      return [type2, type2];
    }
  };
}
class DistanceGlNode extends MathFunctionArg2Factory("distance", {
  in: ["p0", "p1"],
  default_in_type: Gl/* GlConnectionPointType.VEC3 */.Dv.VEC3,
  allowed_in_types: [Gl/* GlConnectionPointType.VEC2 */.Dv.VEC2, Gl/* GlConnectionPointType.VEC3 */.Dv.VEC3, Gl/* GlConnectionPointType.VEC4 */.Dv.VEC4],
  out_type: Gl/* GlConnectionPointType.FLOAT */.Dv.FLOAT
}) {
}
class DotGlNode extends MathFunctionArg2Factory("dot", {
  in: ["vec0", "vec1"],
  default_in_type: Gl/* GlConnectionPointType.VEC3 */.Dv.VEC3,
  allowed_in_types: [Gl/* GlConnectionPointType.VEC2 */.Dv.VEC2, Gl/* GlConnectionPointType.VEC3 */.Dv.VEC3, Gl/* GlConnectionPointType.VEC4 */.Dv.VEC4],
  out_type: Gl/* GlConnectionPointType.FLOAT */.Dv.FLOAT
}) {
}
class MaxGlNode extends MathFunctionArg2Factory("max") {
}
class MinGlNode extends MathFunctionArg2Factory("min") {
}
class ModGlNode extends MathFunctionArg2Factory("mod") {
  paramDefaultValue(name) {
    return { in1: 1 }[name];
  }
  // mod can only take floats
  _expected_input_types() {
    const type = Gl/* GlConnectionPointType.FLOAT */.Dv.FLOAT;
    return [type, type];
  }
}
class PowGlNode extends MathFunctionArg2Factory("pow", { in: ["x", "y"] }) {
}
class ReflectGlNode extends MathFunctionArg2Factory("reflect", {
  in: ["I", "N"],
  default_in_type: Gl/* GlConnectionPointType.VEC3 */.Dv.VEC3
}) {
}
class StepGlNode extends MathFunctionArg2Factory("step", { in: ["edge", "x"] }) {
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/gl/_Math_Arg3.ts




function MathFunctionArg3Factory(type, options = {}) {
  const gl_method_name = options.method || type;
  const gl_output_name = options.out || "val";
  const gl_input_names = options.in || ["in0", "in1", "in2"];
  const param_default_values = options.default || {};
  const out_type = options.out_type || Gl/* GlConnectionPointType.FLOAT */.Dv.FLOAT;
  const functions = options.functions || [];
  return class Node extends BaseNodeGlMathFunctionArg3GlNode {
    static type() {
      return type;
    }
    initializeNode() {
      super.initializeNode();
      this.io.connection_points.set_input_name_function(this._gl_input_name.bind(this));
      this.io.connection_points.set_output_name_function(this._gl_output_name.bind(this));
      this.io.connection_points.set_expected_output_types_function(this._expected_output_types.bind(this));
    }
    _gl_input_name(index) {
      return gl_input_names[index];
    }
    _gl_output_name(index) {
      return gl_output_name;
    }
    gl_method_name() {
      return gl_method_name;
    }
    _expected_output_types() {
      return [out_type];
    }
    paramDefaultValue(name) {
      return param_default_values[name];
    }
    gl_function_definitions() {
      return functions.map((f) => new GLDefinition/* FunctionGLDefinition */.MR(this, f));
    }
  };
}
class ClampGlNode extends MathFunctionArg3Factory("clamp", { in: ["value", "min", "max"], default: { max: 1 } }) {
  _expected_output_types() {
    return [this._expected_input_types()[0]];
  }
}
class FaceforwardGlNode extends MathFunctionArg3Factory("faceForward", { in: ["N", "I", "Nref"] }) {
}
class SmoothstepGlNode extends MathFunctionArg3Factory("smoothstep", {
  in: ["edge0", "edge1", "x"],
  default: { edge1: 1 }
}) {
  _expected_output_types() {
    return [this._expected_input_types()[0]];
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/gl/_Math_Arg2Operation.ts




function MathFunctionArg2OperationFactory(type, options) {
  const in_prefix = options.in_prefix || type;
  const output_name = options.out || "val";
  const operation = options.operation;
  const allowed_in_types = options.allowed_in_types;
  return class Node extends BaseNodeGlMathFunctionArg2GlNode {
    static type() {
      return type;
    }
    initializeNode() {
      super.initializeNode();
      this.io.connection_points.set_input_name_function(this._gl_input_name.bind(this));
      this.io.connection_points.set_output_name_function(this._gl_output_name.bind(this));
      this.io.connection_points.set_expected_input_types_function(this._expected_input_types.bind(this));
      this.io.connection_points.set_expected_output_types_function(this._expected_output_types.bind(this));
    }
    setLines(shaders_collection_controller) {
      const inputConnectionPoints = this.io.inputs.namedInputConnectionPoints();
      const outputConnectionPoints = this.io.outputs.namedOutputConnectionPoints();
      if (!(inputConnectionPoints && outputConnectionPoints)) {
        return;
      }
      const firstConnectionPoint = outputConnectionPoints[0];
      if (!firstConnectionPoint) {
        return;
      }
      const var_type = firstConnectionPoint.type();
      const args = inputConnectionPoints.map((connection, i) => {
        const name = connection.name();
        const variable = this.variableForInput(name);
        if (variable) {
          return ThreeToGl/* ThreeToGl.any */._.any(variable);
        }
      });
      const joined_args = args.join(` ${this.gl_operation()} `);
      const sum = this.glVarName(this.io.connection_points.output_name(0));
      const body_line = `${var_type} ${sum} = ${this.gl_method_name()}(${joined_args})`;
      shaders_collection_controller.addBodyLines(this, [body_line]);
    }
    _gl_input_name(index) {
      return `${in_prefix}${index}`;
    }
    _gl_output_name(index) {
      return output_name;
    }
    gl_operation() {
      return operation;
    }
    _expected_input_types() {
      const inputConnectionPoints = this.io.inputs.namedInputConnectionPoints();
      if (!inputConnectionPoints) {
        return [];
      }
      let first_input_type = this.io.connection_points.first_input_connection_type();
      if (first_input_type && allowed_in_types) {
        if (!allowed_in_types.includes(first_input_type)) {
          const first_connection = inputConnectionPoints[0];
          if (first_connection) {
            first_input_type = first_connection.type();
          }
        }
      }
      const type2 = first_input_type || Gl/* GlConnectionPointType.FLOAT */.Dv.FLOAT;
      const current_connections = this.io.connections.existingInputConnections();
      const expected_count = current_connections ? Math.max(current_connections.length + 1, 2) : 2;
      const expected_input_types = [];
      for (let i = 0; i < expected_count; i++) {
        expected_input_types.push(type2);
      }
      return expected_input_types;
    }
    _expected_output_types() {
      const input_types = this._expected_input_types();
      const type2 = input_types[1] || input_types[0] || Gl/* GlConnectionPointType.FLOAT */.Dv.FLOAT;
      return [type2];
    }
  };
}
class AddGlNode extends MathFunctionArg2OperationFactory("add", {
  in_prefix: "add",
  out: "sum",
  operation: "+"
}) {
}
class DivideGlNode extends MathFunctionArg2OperationFactory("divide", {
  in_prefix: "div",
  out: "divide",
  operation: "/"
}) {
  paramDefaultValue(name) {
    return 1;
  }
}
class SubtractGlNode extends MathFunctionArg2OperationFactory("subtract", {
  in_prefix: "sub",
  out: "subtract",
  operation: "-"
}) {
}
class MultGlNode extends MathFunctionArg2OperationFactory("mult", {
  in_prefix: "mult",
  out: "product",
  operation: "*"
}) {
  static type() {
    return "mult";
  }
  paramDefaultValue(name) {
    return 1;
  }
  initializeNode() {
    super.initializeNode();
    this.io.connection_points.set_expected_input_types_function(this._expected_input_types.bind(this));
    this.io.connection_points.set_expected_output_types_function(this._expected_output_types.bind(this));
  }
  _expected_output_type() {
    const input_types = this._expected_input_types();
    const type = input_types[input_types.length - 1];
    return [type];
  }
  _expected_input_types() {
    const input_connections = this.io.connections.existingInputConnections();
    if (input_connections) {
      const first_connection = input_connections[0];
      if (first_connection) {
        const firstConnectionOutputConnectionPoints = first_connection.nodeSrc().io.outputs.namedOutputConnectionPoints();
        if (!firstConnectionOutputConnectionPoints) {
          return [];
        }
        const connection_point_for_first_connection = firstConnectionOutputConnectionPoints[first_connection.outputIndex()];
        const type = connection_point_for_first_connection.type();
        const expected_count = Math.max(input_connections.length + 1, 2);
        const empty_array = new Array(expected_count);
        if (type == Gl/* GlConnectionPointType.FLOAT */.Dv.FLOAT) {
          const second_connection = input_connections[1];
          if (second_connection) {
            const secondConnectionOuputConnectionPoints = second_connection.nodeSrc().io.outputs.namedOutputConnectionPoints();
            if (!secondConnectionOuputConnectionPoints) {
              return [];
            }
            const connection_point_for_second_connection = secondConnectionOuputConnectionPoints[second_connection.outputIndex()];
            const second_type = connection_point_for_second_connection.type();
            if (second_type == Gl/* GlConnectionPointType.FLOAT */.Dv.FLOAT) {
              return empty_array.fill(type);
            } else {
              return [type, second_type];
            }
          } else {
            return [type, type];
          }
        } else {
          return empty_array.fill(type);
        }
      } else {
      }
    }
    return [Gl/* GlConnectionPointType.FLOAT */.Dv.FLOAT, Gl/* GlConnectionPointType.FLOAT */.Dv.FLOAT];
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/gl/_BaseMathFunctionArgBoolean2.ts




class BaseNodeGlMathFunctionArgBoolean2GlNode extends BaseNodeGlMathFunctionArg2GlNode {
  initializeNode() {
    super.initializeNode();
    this.io.connection_points.set_expected_input_types_function(this._expected_input_types.bind(this));
    this.io.connection_points.set_expected_output_types_function(this._expected_output_types.bind(this));
  }
  _expected_input_types() {
    return [Gl/* GlConnectionPointType.BOOL */.Dv.BOOL, Gl/* GlConnectionPointType.BOOL */.Dv.BOOL];
  }
  _expected_output_types() {
    return [Gl/* GlConnectionPointType.BOOL */.Dv.BOOL];
  }
  boolean_operation() {
    return "boolean_operation to be defined";
  }
  setLines(shaders_collection_controller) {
    const connectionPoints = this.io.inputs.namedInputConnectionPoints();
    if (!connectionPoints) {
      return;
    }
    const args = connectionPoints.map((named_input, i) => {
      const name = named_input.name();
      return ThreeToGl/* ThreeToGl.any */._.any(this.variableForInput(name));
    });
    const joined_args = args.join(` ${this.boolean_operation()} `);
    const sum = this.glVarName(this.io.connection_points.output_name(0));
    const body_line = `bool ${sum} = ${joined_args}`;
    shaders_collection_controller.addBodyLines(this, [body_line]);
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/gl/_Math_Arg2Boolean.ts


function MathFunctionArg2BooleanFactory(type, options) {
  return class Node extends BaseNodeGlMathFunctionArgBoolean2GlNode {
    static type() {
      return type;
    }
    initializeNode() {
      super.initializeNode();
      this.io.connection_points.set_input_name_function(this._gl_input_name.bind(this));
      this.io.connection_points.set_output_name_function(this._gl_output_name.bind(this));
    }
    boolean_operation() {
      return options.op;
    }
    _gl_output_name(index) {
      return type;
    }
    _gl_input_name(index = 0) {
      return `${type}${index}`;
    }
  };
}
class AndGlNode extends MathFunctionArg2BooleanFactory("and", { op: "&&" }) {
}
class OrGlNode extends MathFunctionArg2BooleanFactory("or", { op: "||" }) {
}

// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/core/geometry/GlConstant.ts
var GlConstant = __webpack_require__(11031);
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/gl/gl/physics.glsl
/* harmony default export */ var physics = ("float velFromAccel(float vel, float force, float mass, float time_delta){\n\tfloat impulse = (time_delta * mass) * force;\n\treturn vel + impulse;\n}\nvec2 velFromAccel(vec2 vel, vec2 force, float mass, float time_delta){\n\tvec2 impulse = (time_delta * mass) * force;\n\treturn vel + impulse;\n}\nvec3 velFromAccel(vec3 vel, vec3 force, float mass, float time_delta){\n\tvec3 impulse = (time_delta * mass) * force;\n\treturn vel + impulse;\n}\nvec4 velFromAccel(vec4 vel, vec4 force, float mass, float time_delta){\n\tvec4 impulse = (time_delta * mass) * force;\n\treturn vel + impulse;\n}\nfloat posFromVel(float position, float velocity, float time_delta){\n\treturn position + (time_delta * velocity);\n}\nvec2 posFromVel(vec2 position, vec2 velocity, float time_delta){\n\treturn position + (time_delta * velocity);\n}\nvec3 posFromVel(vec3 position, vec3 velocity, float time_delta){\n\treturn position + (time_delta * velocity);\n}\nvec4 posFromVel(vec4 position, vec4 velocity, float time_delta){\n\treturn position + (time_delta * velocity);\n}");
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/gl/Acceleration.ts







var AccelerationGlInput = /* @__PURE__ */ ((AccelerationGlInput2) => {
  AccelerationGlInput2["POSITION"] = "position";
  AccelerationGlInput2["VELOCITY"] = "velocity";
  AccelerationGlInput2["MASS"] = "mass";
  AccelerationGlInput2["FORCE"] = "force";
  return AccelerationGlInput2;
})(AccelerationGlInput || {});
var AccelerationGlOutput = /* @__PURE__ */ ((AccelerationGlOutput2) => {
  AccelerationGlOutput2["POSITION"] = "position";
  AccelerationGlOutput2["VELOCITY"] = "velocity";
  return AccelerationGlOutput2;
})(AccelerationGlOutput || {});
const INPUT_NAMES = [
  "position" /* POSITION */,
  "velocity" /* VELOCITY */,
  "mass" /* MASS */,
  "force" /* FORCE */
];
const OUTPUT_NAMES = ["position" /* POSITION */, "velocity" /* VELOCITY */];
const INPUT_DEFAULT_VALUE = {
  ["position" /* POSITION */]: [0, 0, 0],
  ["velocity" /* VELOCITY */]: [0, 0, 0],
  ["mass" /* MASS */]: 1,
  ["force" /* FORCE */]: [0, -9.8, 0]
};

class AccelerationGlParamsConfig extends params_ParamsConfig/* NodeParamsConfig */.yI {
  // position = ParamConfig.VECTOR3([0, 0, 0]);
  // velocity = ParamConfig.VECTOR3([0, 0, 0]);
  // mass = ParamConfig.FLOAT(1);
  // force = ParamConfig.VECTOR3([0, -9.8, 0]);
}
const Acceleration_ParamsConfig = new AccelerationGlParamsConfig();
class AccelerationGlNode extends gl_Base/* TypedGlNode */.hD {
  constructor() {
    super(...arguments);
    this.paramsConfig = Acceleration_ParamsConfig;
  }
  static type() {
    return "acceleration";
  }
  initializeNode() {
    super.initializeNode();
    this.io.outputs.setNamedOutputConnectionPoints([
      new Gl/* GlConnectionPoint */.E("position" /* POSITION */, Gl/* GlConnectionPointType.VEC3 */.Dv.VEC3),
      new Gl/* GlConnectionPoint */.E("velocity" /* VELOCITY */, Gl/* GlConnectionPointType.VEC3 */.Dv.VEC3)
    ]);
    this.io.connection_points.set_expected_input_types_function(this._expected_input_types.bind(this));
    this.io.connection_points.set_expected_output_types_function(this._expected_output_types.bind(this));
    this.io.connection_points.set_input_name_function(this._gl_input_name.bind(this));
    this.io.connection_points.set_output_name_function(this._gl_output_name.bind(this));
  }
  _expected_input_types() {
    const type = this.io.connection_points.first_input_connection_type() || Gl/* GlConnectionPointType.VEC3 */.Dv.VEC3;
    return [type, type, Gl/* GlConnectionPointType.FLOAT */.Dv.FLOAT, type];
  }
  _expected_output_types() {
    const in_type = this._expected_input_types()[0];
    return [in_type, in_type];
  }
  _gl_input_name(index) {
    return INPUT_NAMES[index];
  }
  _gl_output_name(index) {
    return OUTPUT_NAMES[index];
  }
  paramDefaultValue(name) {
    return INPUT_DEFAULT_VALUE[name];
  }
  setLines(shaders_collection_controller) {
    const outputConnectionPoints = this.io.outputs.namedOutputConnectionPoints();
    if (!outputConnectionPoints) {
      return;
    }
    const var_type = outputConnectionPoints[0].type();
    const delta_definition = new GLDefinition/* UniformGLDefinition */.oA(this, Gl/* GlConnectionPointType.FLOAT */.Dv.FLOAT, GlConstant/* GlConstant.DELTA_TIME */.d.DELTA_TIME);
    const function_definition = new GLDefinition/* FunctionGLDefinition */.MR(this, physics);
    shaders_collection_controller.addDefinitions(this, [delta_definition, function_definition]);
    const input_position = ThreeToGl/* ThreeToGl.any */._.any(this.variableForInput("position" /* POSITION */));
    const input_velocity = ThreeToGl/* ThreeToGl.any */._.any(this.variableForInput("velocity" /* VELOCITY */));
    const input_mass = ThreeToGl/* ThreeToGl.float */._.float(this.variableForInput("mass" /* MASS */));
    const input_force = ThreeToGl/* ThreeToGl.any */._.any(this.variableForInput("force" /* FORCE */));
    const position_result = this.glVarName("position" /* POSITION */);
    const velocity_result = this.glVarName("velocity" /* VELOCITY */);
    const velocity_args = [input_velocity, input_force, input_mass, GlConstant/* GlConstant.DELTA_TIME */.d.DELTA_TIME].join(", ");
    const velocity_body_line = `${var_type} ${velocity_result} = velFromAccel(${velocity_args})`;
    const position_args = [input_position, velocity_result, GlConstant/* GlConstant.DELTA_TIME */.d.DELTA_TIME].join(", ");
    const position_body_line = `${var_type} ${position_result} = posFromVel(${position_args})`;
    shaders_collection_controller.addBodyLines(this, [velocity_body_line, position_body_line]);
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/gl/gl/neighbour/adjacentPointsAttribSmooth.glsl
/* harmony default export */ var adjacentPointsAttribSmooth = ("\n\nfloat __FUNCTION__NAME__(\n\tsampler2D texturePosition,\n\tvec2 particleUv,\n\tvec3 currentPosition,\n\t//\n\tvec2 textureSize,\n\t// attribSmooth\n\tsampler2D textureAttribute,\n\tfloat currentAttributeValue,\n\tfloat deltaThreshold,\n\tfloat smoothAmount,\n\t__ADJACENCY_SAMPLERS_ARGUMENTS__\n\t){\n\n\tvec3 otherPosition;\n\tfloat dist, delta, otherAttribute;\n\t// float neighbourCount = 0.0;\n\tfloat offset = 0.0;\n\n\t__ADJACENCY_VALUES_FROM_SAMPLERS__\n\tvec2 adjacencyAttributesArray__ADJACENCY_ARRAY_VALUE__;\n\n\tfor(int faceIndex = 0; faceIndex < __ADJACENCY_COUNT__; faceIndex++){\n\n\t\tvec2 currentAdjacentIdForFace = adjacencyAttributesArray[faceIndex];\n\n\t\tif(currentAdjacentIdForFace.x > -0.5 && currentAdjacentIdForFace.y >= -0.5){\n\n\t\t\tfor( int vertexIndex = 0; vertexIndex < 1; vertexIndex++ ){\n\n\t\t\t\tfloat vertexId = vertexIndex == 0 ? currentAdjacentIdForFace.x : currentAdjacentIdForFace.y;\n\t\t\t\tvec2 adjacentPointUv = geometryAttributesLookupUv(vertexId, textureSize);\n\t\t\t\t\n\t\t\t\totherPosition = texture2D( texturePosition, adjacentPointUv ).__COMPONENT__;\n\t\t\t\totherAttribute = texture2D( textureAttribute, adjacentPointUv ).__COMPONENT_ATTRIB__;\n\n\t\t\t\tdist = distance( otherPosition, currentPosition );\n\n\t\t\t\tdelta = (otherAttribute - currentAttributeValue) / dist;\n\n\t\t\t\tfloat excess = abs(delta) - deltaThreshold;\n\n\t\t\t\tif(excess > 0.0){\n\t\t\t\t\toffset += (excess * smoothAmount * sign(delta));\n\t\t\t\t\t//neighbourCount++;\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\t}\n\n\t//offset = neighbourCount >= 1.0 ? (offset / neighbourCount) : 0.0;\n\treturn currentAttributeValue + offset;\n\n}");
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/nodes/gl/gl/geometryAttributes/geometryAttributesLookupUv.glsl
var geometryAttributesLookupUv = __webpack_require__(94077);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/core/geometry/operation/Adjacency.ts
var Adjacency = __webpack_require__(2700);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/poly/registers/nodes/types/Gl.ts
var types_Gl = __webpack_require__(93218);
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/gl/AdjacentPointsAttribSmooth.ts











const AdjacentPointsAttribSmooth_OUTPUT_NAME = "attrib";
class AdjacentPointsAttribSmoothGlParamsConfig extends params_ParamsConfig/* NodeParamsConfig */.yI {
  constructor() {
    super(...arguments);
    this.positionAttribName = params_ParamsConfig/* ParamConfig.STRING */.XC.STRING("position");
    this.position = params_ParamsConfig/* ParamConfig.VECTOR3 */.XC.VECTOR3([0, 0, 0], {
      separatorAfter: true
    });
    // attribType = ParamConfig.INTEGER(GL_CONNECTION_POINT_TYPES.indexOf(GlConnectionPointType.FLOAT), {
    // 	menu: {
    // 		entries: GL_CONNECTION_POINT_TYPES.map((name, i) => {
    // 			return {name: name, value: i};
    // 		}),
    // 	},
    // 	separatorBefore: true,
    // });
    this.textureSize = params_ParamsConfig/* ParamConfig.VECTOR2 */.XC.VECTOR2([128, 128]);
    this.adjacencyCount = params_ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(6, {
      range: [0, 8],
      rangeLocked: [true, false]
    });
    this.adjacencyBaseName = params_ParamsConfig/* ParamConfig.STRING */.XC.STRING(Adjacency/* AttribAdjacency.BASE_NAME */.im.BASE_NAME);
    this.attribName = params_ParamsConfig/* ParamConfig.STRING */.XC.STRING("h");
    this.attribValue = params_ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(0);
    this.deltaThreshold = params_ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(1, {
      range: [0, 1],
      rangeLocked: [true, false]
    });
    this.smoothAmount = params_ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(0.01, {
      range: [0, 1],
      rangeLocked: [true, false]
    });
  }
}
const AdjacentPointsAttribSmooth_ParamsConfig = new AdjacentPointsAttribSmoothGlParamsConfig();
class AdjacentPointsAttribSmoothGlNode extends gl_Base/* TypedGlNode */.hD {
  constructor() {
    super(...arguments);
    this.paramsConfig = AdjacentPointsAttribSmooth_ParamsConfig;
  }
  static type() {
    return types_Gl/* GlType.ADJACENT_POINTS_ATTRIB_SMOOTH */.P.ADJACENT_POINTS_ATTRIB_SMOOTH;
  }
  initializeNode() {
    super.initializeNode();
    this.io.connection_points.spare_params.setInputlessParamNames(["adjacencyCount", "adjacencyBaseName"]);
    this.io.outputs.setNamedOutputConnectionPoints([
      new Gl/* GlConnectionPoint */.E(AdjacentPointsAttribSmooth_OUTPUT_NAME, Gl/* GlConnectionPointType.FLOAT */.Dv.FLOAT)
    ]);
  }
  glType() {
    return Gl/* GlConnectionPointType.FLOAT */.Dv.FLOAT;
  }
  attributeName() {
    return this.pv.attribName;
  }
  setLines(linesController) {
    const bodyLines = [];
    const textureSize = ThreeToGl/* ThreeToGl.vector2 */._.vector2(this.variableForInputParam(this.p.textureSize));
    const position = ThreeToGl/* ThreeToGl.vector3 */._.vector3(this.variableForInputParam(this.p.position));
    const attribValue = ThreeToGl/* ThreeToGl.float */._.float(this.variableForInputParam(this.p.attribValue));
    const deltaThreshold = ThreeToGl/* ThreeToGl.float */._.float(this.variableForInputParam(this.p.deltaThreshold));
    const smoothAmount = ThreeToGl/* ThreeToGl.float */._.float(this.variableForInputParam(this.p.smoothAmount));
    const out = this.glVarName(AdjacentPointsAttribSmooth_OUTPUT_NAME);
    const assembler = linesController.assembler();
    const globalsHandler = assembler.globalsHandler();
    if (!globalsHandler) {
      return;
    }
    if (globalsHandler.attribTextureData) {
      const globalsTextureHandler = globalsHandler;
      const positionTextureData = globalsTextureHandler.attribTextureData(
        this.pv.positionAttribName
      );
      const attribTextureData = globalsTextureHandler.attribTextureData(
        this.pv.attribName
      );
      const textureAllocationData = this.textureAllocationData();
      const adjacencyTextureDatas = textureAllocationData.map(
        (d) => globalsTextureHandler.attribTextureData(d)
      );
      if (positionTextureData && attribTextureData && adjacencyTextureDatas.length == textureAllocationData.length) {
        const { textureName, uvName } = positionTextureData;
        const attribTextureName = attribTextureData.textureName;
        const attribComponent = attribTextureData.component;
        const positionComponent = positionTextureData.component;
        const args = [
          textureName,
          uvName,
          position,
          textureSize,
          //
          attribTextureName,
          attribValue,
          deltaThreshold,
          smoothAmount
        ];
        const { functionName, functionDeclaration } = this._templateFunctionDefinition({
          positionComponent,
          attribComponent,
          adjacencyTextureDatas
        });
        linesController.addDefinitions(this, [new GLDefinition/* FunctionGLDefinition */.MR(this, geometryAttributesLookupUv/* default */.Z)]);
        linesController.addDefinitions(this, [new GLDefinition/* FunctionGLDefinition */.MR(this, functionDeclaration)]);
        for (const textureData of adjacencyTextureDatas) {
          if (textureData) {
            linesController.addDefinitions(this, [
              new GLDefinition/* UniformGLDefinition */.oA(this, Gl/* GlConnectionPointType.SAMPLER_2D */.Dv.SAMPLER_2D, textureData.textureName)
            ]);
            if (!args.includes(textureData.textureName)) {
              args.push(textureData.textureName);
            }
          }
        }
        bodyLines.push(`float ${out} = ${functionName}(${args.join(",\n")})`);
      }
    }
    linesController.addBodyLines(this, bodyLines);
  }
  textureAllocationData() {
    const count = this.pv.adjacencyCount;
    const attribNames = [];
    for (let i = 0; i < count; i++) {
      const attribName = (0,Adjacency/* adjacencyAttribName */._7)(this.pv.adjacencyBaseName, i);
      attribNames.push(attribName);
    }
    return attribNames;
  }
  _templateFunctionDefinition(options) {
    const adjacencyCount = ThreeToGl/* ThreeToGl.integer */._.integer(this.pv.adjacencyCount);
    const adjacencyVariableNames = [];
    const adjacencyTextureRead = [];
    const textureNames = [];
    let i = 0;
    for (const textureData of options.adjacencyTextureDatas) {
      if (textureData) {
        const { textureName, uvName, component } = textureData;
        const varName = (0,Adjacency/* adjacencyAttribName */._7)(this.pv.adjacencyBaseName, i);
        adjacencyVariableNames.push(varName);
        adjacencyTextureRead.push(`vec2 ${varName} = texture2D( ${textureName}, ${uvName} ).${component};`);
        if (!textureNames.includes(textureName)) {
          textureNames.push(textureName);
        }
      }
      i++;
    }
    const adjacencySamplersArguments = textureNames.map((textureName) => `sampler2D ${textureName}`).join(`,
`);
    const adjacencyArrayFromSamplers = `
${adjacencyTextureRead.join("\n")}
`;
    const adjacencyArrayValue = `[${adjacencyCount}] = vec2[${adjacencyCount}](
			${adjacencyVariableNames.join(",\n")}
					)`;
    const functionName = `${this.type()}${this.graphNodeId()}`;
    const functionDeclaration = adjacentPointsAttribSmooth.replace("__FUNCTION__NAME__", functionName).replace("__COMPONENT__", options.positionComponent).replace("__COMPONENT_ATTRIB__", options.attribComponent).replace("__ADJACENCY_COUNT__", adjacencyCount).replace("__ADJACENCY_VALUES_FROM_SAMPLERS__", adjacencyArrayFromSamplers).replace("__ADJACENCY_ARRAY_VALUE__", adjacencyArrayValue).replace("__ADJACENCY_SAMPLERS_ARGUMENTS__", adjacencySamplersArguments);
    return {
      functionName,
      functionDeclaration
    };
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/gl/gl/neighbour/adjacentUvAttribSmooth.glsl
/* harmony default export */ var adjacentUvAttribSmooth = ("\nfloat __SUB_FUNCTION__NAME__(\n\tvec2 particleUv,\n\tvec2 textureSize,\n\tsampler2D textureAttribute,\n\tfloat currentAttributeValue,\n\tfloat deltaThreshold,\n\tfloat smoothAmount,\n\tvec2 textureOffset,\n\tfloat dist\n){\n\tfloat otherAttribute = texture2D(\n\t\ttextureAttribute,\n\t\tparticleUv + (textureOffset / textureSize)\n\t).__COMPONENT_ATTRIB__;\n\n\tfloat delta = (otherAttribute - currentAttributeValue) / dist;\n\n\tfloat excess = abs(delta) - deltaThreshold;\n\n\treturn excess > 0.0 ? (excess * smoothAmount * sign(delta)) : 0.;\n}\n\nfloat __FUNCTION__NAME__(\n\tvec2 particleUv,\n\tvec2 textureSize,\n\t// attribSmooth\n\tsampler2D textureAttribute,\n\tfloat currentAttributeValue,\n\tfloat deltaThreshold,\n\tfloat smoothAmount\n\t){\n\n\tfloat sqrt2 = 1.4142135623730951;\n\n\tfloat offset = __SUB_FUNCTION__NAME__( particleUv, textureSize, textureAttribute, currentAttributeValue, deltaThreshold, smoothAmount, vec2(-1., 0.), 1.);\n\toffset += __SUB_FUNCTION__NAME__( particleUv, textureSize, textureAttribute, currentAttributeValue, deltaThreshold, smoothAmount, vec2(-1., -1.), sqrt2);\n\toffset += __SUB_FUNCTION__NAME__( particleUv, textureSize, textureAttribute, currentAttributeValue, deltaThreshold, smoothAmount, vec2(0., -1.), 1.);\n\toffset += __SUB_FUNCTION__NAME__( particleUv, textureSize, textureAttribute, currentAttributeValue, deltaThreshold, smoothAmount, vec2(1., -1.), sqrt2);\n\toffset += __SUB_FUNCTION__NAME__( particleUv, textureSize, textureAttribute, currentAttributeValue, deltaThreshold, smoothAmount, vec2(1., 0.), 1.);\n\toffset += __SUB_FUNCTION__NAME__( particleUv, textureSize, textureAttribute, currentAttributeValue, deltaThreshold, smoothAmount, vec2(1., 1.), sqrt2);\n\toffset += __SUB_FUNCTION__NAME__( particleUv, textureSize, textureAttribute, currentAttributeValue, deltaThreshold, smoothAmount, vec2(0., 1.), 1.);\n\toffset += __SUB_FUNCTION__NAME__( particleUv, textureSize, textureAttribute, currentAttributeValue, deltaThreshold, smoothAmount, vec2(-1., 1.), sqrt2);\n\n\treturn currentAttributeValue + offset;\n}");
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/gl/AdjacentUvAttribSmooth.ts








const AdjacentUvAttribSmooth_OUTPUT_NAME = "attrib";
class AdjacentUvAttribSmoothGlParamsConfig extends params_ParamsConfig/* NodeParamsConfig */.yI {
  constructor() {
    super(...arguments);
    this.textureSize = params_ParamsConfig/* ParamConfig.VECTOR2 */.XC.VECTOR2([128, 128]);
    this.attribName = params_ParamsConfig/* ParamConfig.STRING */.XC.STRING("h");
    this.attribValue = params_ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(0);
    this.deltaThreshold = params_ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(1, {
      range: [0, 1],
      rangeLocked: [true, false]
    });
    this.smoothAmount = params_ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(0.01, {
      range: [0, 1],
      rangeLocked: [true, false]
    });
  }
}
const AdjacentUvAttribSmooth_ParamsConfig = new AdjacentUvAttribSmoothGlParamsConfig();
class AdjacentUvAttribSmoothGlNode extends gl_Base/* TypedGlNode */.hD {
  constructor() {
    super(...arguments);
    this.paramsConfig = AdjacentUvAttribSmooth_ParamsConfig;
  }
  static type() {
    return types_Gl/* GlType.ADJACENT_UV_ATTRIB_SMOOTH */.P.ADJACENT_UV_ATTRIB_SMOOTH;
  }
  initializeNode() {
    super.initializeNode();
    this.io.outputs.setNamedOutputConnectionPoints([
      new Gl/* GlConnectionPoint */.E(AdjacentUvAttribSmooth_OUTPUT_NAME, Gl/* GlConnectionPointType.FLOAT */.Dv.FLOAT)
    ]);
  }
  glType() {
    return Gl/* GlConnectionPointType.FLOAT */.Dv.FLOAT;
  }
  attributeName() {
    return this.pv.attribName;
  }
  setLines(linesController) {
    const bodyLines = [];
    const textureSize = ThreeToGl/* ThreeToGl.vector2 */._.vector2(this.variableForInputParam(this.p.textureSize));
    const attribValue = ThreeToGl/* ThreeToGl.float */._.float(this.variableForInputParam(this.p.attribValue));
    const deltaThreshold = ThreeToGl/* ThreeToGl.float */._.float(this.variableForInputParam(this.p.deltaThreshold));
    const smoothAmount = ThreeToGl/* ThreeToGl.float */._.float(this.variableForInputParam(this.p.smoothAmount));
    const out = this.glVarName(AdjacentUvAttribSmooth_OUTPUT_NAME);
    const assembler = linesController.assembler();
    const globalsHandler = assembler.globalsHandler();
    if (!globalsHandler) {
      return;
    }
    if (globalsHandler.attribTextureData) {
      const globalsTextureHandler = globalsHandler;
      const attribTextureData = globalsTextureHandler.attribTextureData(
        this.pv.attribName
      );
      if (attribTextureData) {
        const { uvName } = attribTextureData;
        const attribTextureName = attribTextureData.textureName;
        const attribComponent = attribTextureData.component;
        const args = [
          uvName,
          textureSize,
          //
          attribTextureName,
          attribValue,
          deltaThreshold,
          smoothAmount
        ];
        const { functionName, functionDeclaration } = this._templateFunctionDefinition({
          attribComponent
        });
        linesController.addDefinitions(this, [new GLDefinition/* FunctionGLDefinition */.MR(this, functionDeclaration)]);
        bodyLines.push(`float ${out} = ${functionName}(${args.join(",\n")})`);
      }
    }
    linesController.addBodyLines(this, bodyLines);
  }
  _templateFunctionDefinition(options) {
    const functionName = `${this.type()}${this.graphNodeId()}`;
    const subFunctionName = `sub${this.type()}${this.graphNodeId()}`;
    const functionDeclaration = adjacentUvAttribSmooth.replace("__FUNCTION__NAME__", functionName).replace(/__SUB_FUNCTION__NAME__/g, subFunctionName).replace("__COMPONENT_ATTRIB__", options.attribComponent);
    return {
      functionName,
      functionDeclaration
    };
  }
}

// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/nodes/gl/gl/quaternion.glsl
var quaternion = __webpack_require__(69086);
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/gl/Align.ts





var AlignGlNodeInputName = /* @__PURE__ */ ((AlignGlNodeInputName2) => {
  AlignGlNodeInputName2["DIR"] = "dir";
  AlignGlNodeInputName2["UP"] = "up";
  return AlignGlNodeInputName2;
})(AlignGlNodeInputName || {});
const InputNames = ["dir" /* DIR */, "up" /* UP */];
const DEFAULT_DIR = [0, 0, 1];
const DEFAULT_UP = [0, 1, 0];
const DefaultValues = {
  ["dir" /* DIR */]: DEFAULT_DIR,
  ["up" /* UP */]: DEFAULT_UP
};
class AlignGlNode extends BaseNodeGlMathFunctionArg2GlNode {
  static type() {
    return "align";
  }
  initializeNode() {
    super.initializeNode();
    this.io.connection_points.set_input_name_function((index) => InputNames[index]);
    this.io.connection_points.set_expected_input_types_function(() => [
      Gl/* GlConnectionPointType.VEC3 */.Dv.VEC3,
      Gl/* GlConnectionPointType.VEC3 */.Dv.VEC3
    ]);
    this.io.connection_points.set_expected_output_types_function(() => [Gl/* GlConnectionPointType.VEC4 */.Dv.VEC4]);
  }
  // gl_input_name(index: number) {
  // 	return InputNames[index];
  // }
  paramDefaultValue(name) {
    return DefaultValues[name];
  }
  gl_method_name() {
    return "align";
  }
  // protected expected_input_types() {
  // 	return [ConnectionPointType.VEC3, ConnectionPointType.VEC3];
  // }
  // protected expected_output_types() {
  // 	return [ConnectionPointType.VEC4];
  // }
  gl_function_definitions() {
    return [new GLDefinition/* FunctionGLDefinition */.MR(this, quaternion/* default */.Z)];
  }
}

// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/nodes/gl/Attribute.ts
var Attribute = __webpack_require__(96677);
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/gl/gl/polar.glsl
/* harmony default export */ var gl_polar = ("vec3 cartesianToPolar(vec3 w){\n\tfloat wr = sqrt(dot(w,w));\n\tfloat wo = acos(w.y/wr);\n\tfloat wi = atan(w.x,w.z);\n\treturn vec3(wr,wo,wi);\n}\nvec3 polarToCartesian(vec3 p){\n\tfloat x = p.x * sin(p.y)*sin(p.z);\n\tfloat y = p.x * cos(p.y);\n\tfloat z = p.x * sin(p.y)*cos(p.z);\n\treturn vec3(x,y,z);\n}");
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/gl/CartesianToPolar.ts







const CartesianToPolar_OUTPUT_NAME = "polar";
class CartesianToPolarGlParamsConfig extends params_ParamsConfig/* NodeParamsConfig */.yI {
  constructor() {
    super(...arguments);
    this.xyz = params_ParamsConfig/* ParamConfig.VECTOR3 */.XC.VECTOR3([1, 1, 1]);
  }
}
const CartesianToPolar_ParamsConfig = new CartesianToPolarGlParamsConfig();
class CartesianToPolarGlNode extends gl_Base/* TypedGlNode */.hD {
  constructor() {
    super(...arguments);
    this.paramsConfig = CartesianToPolar_ParamsConfig;
  }
  static type() {
    return "cartesianToPolar";
  }
  initializeNode() {
    super.initializeNode();
    this.io.outputs.setNamedOutputConnectionPoints([
      new Gl/* GlConnectionPoint */.E(CartesianToPolar_OUTPUT_NAME, Gl/* GlConnectionPointType.VEC3 */.Dv.VEC3)
    ]);
  }
  setLines(shadersCollectionController) {
    const out = this.glVarName(CartesianToPolar_OUTPUT_NAME);
    const xyz = ThreeToGl/* ThreeToGl.vector3 */._.vector3(this.variableForInputParam(this.p.xyz));
    const bodyLine = `vec3 ${out} = cartesianToPolar(${xyz})`;
    shadersCollectionController.addBodyLines(this, [bodyLine]);
    shadersCollectionController.addDefinitions(this, [new GLDefinition/* FunctionGLDefinition */.MR(this, gl_polar)]);
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/gl/gl/checkers.glsl
/* harmony default export */ var checkers = ("// https://iquilezles.org/articles/checkerfiltering/\nfloat checkers(vec2 p) {\n\tvec2 s = sign(fract(p*.5)-.5);\n\treturn .5 - .5*s.x*s.y;\n}\nfloat checkersGrad( in vec2 p, in vec2 ddx, in vec2 ddy )\n{\n    // filter kernel\n    vec2 w = max(abs(ddx), abs(ddy)) + 0.01;\n    // analytical integral (box filter)\n    vec2 i = 2.0*(abs(fract((p-0.5*w)/2.0)-0.5)-abs(fract((p+0.5*w)/2.0)-0.5))/w;\n    // xor pattern\n    return 0.5 - 0.5*i.x*i.y;\n}\n");
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/gl/Checkers.ts








const Checkers_OUTPUT_NAME = "checker";
class CheckersGlParamsConfig extends params_ParamsConfig/* NodeParamsConfig */.yI {
  constructor() {
    super(...arguments);
    this.uv = params_ParamsConfig/* ParamConfig.VECTOR2 */.XC.VECTOR2([0, 0]);
    this.freq = params_ParamsConfig/* ParamConfig.VECTOR2 */.XC.VECTOR2([1, 1]);
    this.freqMult = params_ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(1, {
      range: [0, 10],
      rangeLocked: [false, false]
    });
    this.filtered = params_ParamsConfig/* ParamConfig.BOOLEAN */.XC.BOOLEAN(1);
  }
}
const Checkers_ParamsConfig = new CheckersGlParamsConfig();
class CheckersGlNode extends gl_Base/* TypedGlNode */.hD {
  constructor() {
    super(...arguments);
    this.paramsConfig = Checkers_ParamsConfig;
  }
  static type() {
    return "checkers";
  }
  initializeNode() {
    super.initializeNode();
    this.io.connection_points.spare_params.setInputlessParamNames(["filtered"]);
    this.io.outputs.setNamedOutputConnectionPoints([
      new Gl/* GlConnectionPoint */.E(Checkers_OUTPUT_NAME, Gl/* GlConnectionPointType.FLOAT */.Dv.FLOAT)
    ]);
  }
  setLines(shadersCollectionController) {
    const uv = ThreeToGl/* ThreeToGl.vector2 */._.vector2(this.variableForInputParam(this.p.uv));
    const freq = ThreeToGl/* ThreeToGl.vector2 */._.vector2(this.variableForInputParam(this.p.freq));
    const freqMult = ThreeToGl/* ThreeToGl.float */._.float(this.variableForInputParam(this.p.freqMult));
    const coord = this.glVarName("coord");
    const float = this.glVarName(Checkers_OUTPUT_NAME);
    const coordLine = `vec2 ${coord} = ${uv}*${freq}*${freqMult}`;
    const functionCall = (0,Type/* isBooleanTrue */.bI)(this.pv.filtered) ? `checkersGrad(${coord}, dFdx(${coord}), dFdy(${coord}))` : `checkers(${coord})`;
    const bodyLine = `float ${float} = ${functionCall}`;
    shadersCollectionController.addBodyLines(this, [coordLine, bodyLine]);
    shadersCollectionController.addDefinitions(this, [new GLDefinition/* FunctionGLDefinition */.MR(this, checkers)]);
  }
}

// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/nodes/utils/code/controllers/ParamConfigsController.ts
var ParamConfigsController = __webpack_require__(94717);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/nodes/gl/code/utils/GLParamConfig.ts
var GLParamConfig = __webpack_require__(28491);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/core/material/uniform.ts
var uniform = __webpack_require__(34639);
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/core/cloth/glsl/common/getUV.glsl
/* harmony default export */ var getUV = ("// get vec2 tex coordinate from index\nvec2 getClothSolverUV( float id, vec2 textureSize ) { \n\n\tvec2 coords = vec2(\n\t\tfloor( mod( ( id + 0.5 ), textureSize.x ) ),\n\t\tfloor( ( id + 0.5 ) / textureSize.x )\n\t) + 0.5;\n\n\treturn coords / textureSize;\n\n}\n");
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/core/cloth/glsl/render/ClothSolverPosition.glsl
/* harmony default export */ var ClothSolverPosition = ("\nvec3 clothSolverPosition(sampler2D tPosition0, sampler2D tPosition1, vec2 clothSolverUv) {\n\treturn ( texture2D( tPosition0, clothSolverUv ).xyz + texture2D( tPosition1, clothSolverUv ).xyz ) / 1024.0;\n}\nvec3 clothSolverNormal(sampler2D tNormal, vec2 clothSolverUv) {\n\treturn normalize( texture2D( tNormal, clothSolverUv ).xyz );\n}");
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/core/cloth/ClothAttribute.ts

var ClothIdAttribute = /* @__PURE__ */ ((ClothIdAttribute2) => {
  ClothIdAttribute2["OBJECT"] = "ClothIdAttribute_object";
  return ClothIdAttribute2;
})(ClothIdAttribute || {});
var ClothSolverUniformName = /* @__PURE__ */ ((ClothSolverUniformName2) => {
  ClothSolverUniformName2["SIZE"] = "tSize";
  ClothSolverUniformName2["POSITION0"] = "tPosition0";
  ClothSolverUniformName2["POSITION1"] = "tPosition1";
  ClothSolverUniformName2["NORMAL"] = "tNormal";
  return ClothSolverUniformName2;
})(ClothSolverUniformName || {});
var ClothGeometryAttributeName = /* @__PURE__ */ ((ClothGeometryAttributeName2) => {
  ClothGeometryAttributeName2["VISCOSITY"] = "viscosity";
  ClothGeometryAttributeName2["SPRING"] = "spring";
  return ClothGeometryAttributeName2;
})(ClothGeometryAttributeName || {});

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/gl/ClothSolverPosition.ts













var ClothSolverPositionOutputName = /* @__PURE__ */ ((ClothSolverPositionOutputName2) => {
  ClothSolverPositionOutputName2["POSITION"] = "position";
  ClothSolverPositionOutputName2["NORMAL"] = "normal";
  return ClothSolverPositionOutputName2;
})(ClothSolverPositionOutputName || {});
class ClothSolverPositionGlParamsConfig extends params_ParamsConfig/* NodeParamsConfig */.yI {
  constructor() {
    super(...arguments);
    this.id = params_ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(0);
    this.size = params_ParamsConfig/* ParamConfig.STRING */.XC.STRING(ClothSolverUniformName.SIZE);
    this.position0 = params_ParamsConfig/* ParamConfig.STRING */.XC.STRING(ClothSolverUniformName.POSITION0);
    this.position1 = params_ParamsConfig/* ParamConfig.STRING */.XC.STRING(ClothSolverUniformName.POSITION1);
    this.normal = params_ParamsConfig/* ParamConfig.STRING */.XC.STRING(ClothSolverUniformName.NORMAL);
  }
}
const ClothSolverPosition_ParamsConfig = new ClothSolverPositionGlParamsConfig();
class ClothSolverPositionGlNode extends gl_Base/* TypedGlNode */.hD {
  constructor() {
    super(...arguments);
    this.paramsConfig = ClothSolverPosition_ParamsConfig;
  }
  static type() {
    return "clothSolverPosition";
  }
  initializeNode() {
    this.addPostDirtyHook("_setMatToRecompile", this._setMatToRecompile.bind(this));
    this.lifecycle.onAfterAdded(this._setMatToRecompile.bind(this));
    this.lifecycle.onBeforeDeleted(this._setMatToRecompile.bind(this));
    this.io.outputs.setNamedOutputConnectionPoints([
      new Gl/* GlConnectionPoint */.E("position" /* POSITION */, Gl/* GlConnectionPointType.VEC3 */.Dv.VEC3),
      new Gl/* GlConnectionPoint */.E("normal" /* NORMAL */, Gl/* GlConnectionPointType.VEC3 */.Dv.VEC3)
    ]);
  }
  setLines(shaders_collection_controller) {
    const id = ThreeToGl/* ThreeToGl.vector2 */._.vector2(this.variableForInputParam(this.p.id));
    const uv = this.glVarName("clothSolverUv");
    const position = this.glVarName("position" /* POSITION */);
    const normal = this.glVarName("normal" /* NORMAL */);
    const uniformSize = this.uniformNameSize();
    const uniformPosition0 = this.uniformNamePosition0();
    const uniformPosition1 = this.uniformNamePosition1();
    const uniformNormal = this.uniformNameNormal();
    const definitions = [
      new GLDefinition/* UniformGLDefinition */.oA(this, Gl/* GlConnectionPointType.VEC2 */.Dv.VEC2, uniformSize),
      new GLDefinition/* UniformGLDefinition */.oA(this, Gl/* GlConnectionPointType.SAMPLER_2D */.Dv.SAMPLER_2D, uniformPosition0),
      new GLDefinition/* UniformGLDefinition */.oA(this, Gl/* GlConnectionPointType.SAMPLER_2D */.Dv.SAMPLER_2D, uniformPosition1),
      new GLDefinition/* UniformGLDefinition */.oA(this, Gl/* GlConnectionPointType.SAMPLER_2D */.Dv.SAMPLER_2D, uniformNormal),
      new GLDefinition/* FunctionGLDefinition */.MR(this, getUV),
      new GLDefinition/* FunctionGLDefinition */.MR(this, ClothSolverPosition)
    ];
    const bodyLines = [];
    bodyLines.push(`vec2 ${uv} = getClothSolverUV(${id}, ${uniformSize})`);
    bodyLines.push(`vec3 ${position} = clothSolverPosition(${uniformPosition0}, ${uniformPosition1}, ${uv})`);
    bodyLines.push(`vec3 ${normal} = clothSolverNormal(${uniformNormal}, ${uv})`);
    shaders_collection_controller.addDefinitions(this, definitions);
    shaders_collection_controller.addBodyLines(this, bodyLines);
  }
  paramsGenerating() {
    return true;
  }
  setParamConfigs() {
    this._param_configs_controller = this._param_configs_controller || new ParamConfigsController/* ParamConfigsController */.e();
    this._param_configs_controller.reset();
    const size = new GLParamConfig/* GlParamConfig */.b(ParamType/* ParamType.VECTOR2 */._.VECTOR2, this.pv.size, [1, 1], this.uniformNameSize());
    const position0 = new GLParamConfig/* GlParamConfig */.b(ParamType/* ParamType.NODE_PATH */._.NODE_PATH, this.pv.position0, "", this.uniformNamePosition0());
    const position1 = new GLParamConfig/* GlParamConfig */.b(ParamType/* ParamType.NODE_PATH */._.NODE_PATH, this.pv.position1, "", this.uniformNamePosition1());
    const normal = new GLParamConfig/* GlParamConfig */.b(ParamType/* ParamType.NODE_PATH */._.NODE_PATH, this.pv.normal, "", this.uniformNameNormal());
    this._param_configs_controller.push(size);
    this._param_configs_controller.push(position0);
    this._param_configs_controller.push(position1);
    this._param_configs_controller.push(normal);
  }
  uniformNameSize() {
    return `${uniform/* UNIFORM_PARAM_PREFIX */.l}${this.pv.size}`;
  }
  uniformNamePosition0() {
    return `${uniform/* UNIFORM_TEXTURE_PREFIX */.f}${this.pv.position0}`;
  }
  uniformNamePosition1() {
    return `${uniform/* UNIFORM_TEXTURE_PREFIX */.f}${this.pv.position1}`;
  }
  uniformNameNormal() {
    return `${uniform/* UNIFORM_TEXTURE_PREFIX */.f}${this.pv.normal}`;
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/gl/ClothSolverUv.ts













var ClothSolverUvOutputName = /* @__PURE__ */ ((ClothSolverUvOutputName2) => {
  ClothSolverUvOutputName2["UV"] = "uv";
  return ClothSolverUvOutputName2;
})(ClothSolverUvOutputName || {});
class ClothSolverUvGlParamsConfig extends params_ParamsConfig/* NodeParamsConfig */.yI {
  constructor() {
    super(...arguments);
    this.id = params_ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(0);
    this.size = params_ParamsConfig/* ParamConfig.STRING */.XC.STRING(ClothSolverUniformName.SIZE);
  }
}
const ClothSolverUv_ParamsConfig = new ClothSolverUvGlParamsConfig();
class ClothSolverUvGlNode extends gl_Base/* TypedGlNode */.hD {
  constructor() {
    super(...arguments);
    this.paramsConfig = ClothSolverUv_ParamsConfig;
  }
  static type() {
    return "clothSolverUv";
  }
  initializeNode() {
    this.addPostDirtyHook("_setMatToRecompile", this._setMatToRecompile.bind(this));
    this.lifecycle.onAfterAdded(this._setMatToRecompile.bind(this));
    this.lifecycle.onBeforeDeleted(this._setMatToRecompile.bind(this));
    this.io.outputs.setNamedOutputConnectionPoints([
      new Gl/* GlConnectionPoint */.E("uv" /* UV */, Gl/* GlConnectionPointType.VEC2 */.Dv.VEC2)
    ]);
  }
  setLines(shaders_collection_controller) {
    const id = ThreeToGl/* ThreeToGl.vector2 */._.vector2(this.variableForInputParam(this.p.id));
    const uv = this.glVarName("uv" /* UV */);
    const uniformSize = this.uniformNameSize();
    const definitions = [
      new GLDefinition/* UniformGLDefinition */.oA(this, Gl/* GlConnectionPointType.VEC2 */.Dv.VEC2, uniformSize),
      // new UniformGLDefinition(this, GlConnectionPointType.SAMPLER_2D, uniformPosition0),
      // new UniformGLDefinition(this, GlConnectionPointType.SAMPLER_2D, uniformPosition1),
      // new UniformGLDefinition(this, GlConnectionPointType.SAMPLER_2D, uniformNormal),
      new GLDefinition/* FunctionGLDefinition */.MR(this, getUV),
      new GLDefinition/* FunctionGLDefinition */.MR(this, ClothSolverPosition)
    ];
    const bodyLines = [];
    bodyLines.push(`vec2 ${uv} = getClothSolverUV(${id}, ${uniformSize})`);
    shaders_collection_controller.addDefinitions(this, definitions);
    shaders_collection_controller.addBodyLines(this, bodyLines);
  }
  paramsGenerating() {
    return true;
  }
  setParamConfigs() {
    this._param_configs_controller = this._param_configs_controller || new ParamConfigsController/* ParamConfigsController */.e();
    this._param_configs_controller.reset();
    const size = new GLParamConfig/* GlParamConfig */.b(ParamType/* ParamType.VECTOR2 */._.VECTOR2, this.pv.size, [1, 1], this.uniformNameSize());
    this._param_configs_controller.push(size);
  }
  uniformNameSize() {
    return `${uniform/* UNIFORM_PARAM_PREFIX */.l}${this.pv.size}`;
  }
  // uniformNamePosition0() {
  // 	return `${UNIFORM_TEXTURE_PREFIX}${this.pv.position0}`;
  // }
  // uniformNamePosition1() {
  // 	return `${UNIFORM_TEXTURE_PREFIX}${this.pv.position1}`;
  // }
  // uniformNameNormal() {
  // 	return `${UNIFORM_TEXTURE_PREFIX}${this.pv.normal}`;
  // }
}

// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/nodes/gl/ColorCorrect.ts
var ColorCorrect = __webpack_require__(90979);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/nodes/gl/Compare.ts
var Compare = __webpack_require__(928);
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/gl/gl/complement.glsl
/* harmony default export */ var complement = ("float complement(float x){return 1.0-x;}\nvec2 complement(vec2 x){return vec2(1.0-x.x, 1.0-x.y);}\nvec3 complement(vec3 x){return vec3(1.0-x.x, 1.0-x.y, 1.0-x.z);}\nvec4 complement(vec4 x){return vec4(1.0-x.x, 1.0-x.y, 1.0-x.z, 1.0-x.w);}\n");
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/gl/Complement.ts




class ComplementGlNode extends BaseNodeGlMathFunctionArg1GlNode {
  static type() {
    return "complement";
  }
  gl_method_name() {
    return "complement";
  }
  gl_function_definitions() {
    return [new GLDefinition/* FunctionGLDefinition */.MR(this, complement)];
  }
}

// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/nodes/gl/ComputeNormals.ts
var ComputeNormals = __webpack_require__(49177);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/nodes/gl/Constant.ts
var gl_Constant = __webpack_require__(94962);
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/gl/Cross.ts





const Cross_OUTPUT_NAME = "cross";
class CrossGlParamsConfig extends params_ParamsConfig/* NodeParamsConfig */.yI {
  constructor() {
    super(...arguments);
    this.x = params_ParamsConfig/* ParamConfig.VECTOR3 */.XC.VECTOR3([0, 0, 1]);
    this.y = params_ParamsConfig/* ParamConfig.VECTOR3 */.XC.VECTOR3([0, 1, 0]);
  }
}
const Cross_ParamsConfig = new CrossGlParamsConfig();
class CrossGlNode extends gl_Base/* TypedGlNode */.hD {
  constructor() {
    super(...arguments);
    this.paramsConfig = Cross_ParamsConfig;
  }
  static type() {
    return "cross";
  }
  initializeNode() {
    super.initializeNode();
    this.io.outputs.setNamedOutputConnectionPoints([
      new Gl/* GlConnectionPoint */.E(Cross_OUTPUT_NAME, Gl/* GlConnectionPointType.VEC3 */.Dv.VEC3)
    ]);
  }
  setLines(shaders_collection_controller) {
    const x = ThreeToGl/* ThreeToGl.float */._.float(this.variableForInputParam(this.p.x));
    const y = ThreeToGl/* ThreeToGl.float */._.float(this.variableForInputParam(this.p.y));
    const result = this.glVarName(Cross_OUTPUT_NAME);
    const body_line = `vec3 ${result} = cross(${x}, ${y})`;
    shaders_collection_controller.addBodyLines(this, [body_line]);
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/gl/gl/cycle.glsl
/* harmony default export */ var cycle = ("float cycle(float val, float val_min, float val_max){\n\tif(val >= val_min && val < val_max){\n\t\treturn val;\n\t} else {\n\t\tfloat range = val_max - val_min;\n\t\tif(val >= val_max){\n\t\t\tfloat delta = (val - val_max);\n\t\t\treturn val_min + mod(delta, range);\n\t\t} else {\n\t\t\tfloat delta = (val_min - val);\n\t\t\treturn val_max - mod(delta, range);\n\t\t}\n\t}\n}");
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/gl/Cycle.ts



class CycleGlNode extends MathFunctionArg3Factory("cycle", {
  in: ["in", "min", "max"],
  default: { max: 1 },
  functions: [cycle]
}) {
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/gl/gl/disk.glsl
/* harmony default export */ var disk = ("float disk_feather(float dist, float radius, float feather){\n\tif(feather <= 0.0){\n\t\tif(dist < radius){return 1.0;}else{return 0.0;}\n\t} else {\n\t\tfloat half_feather = feather * 0.5;\n\t\tif(dist < (radius - half_feather)){\n\t\t\treturn 1.0;\n\t\t} else {\n\t\t\tif(dist > (radius + half_feather)){\n\t\t\t\treturn 0.0;\n\t\t\t} else {\n\t\t\t\tfloat feather_start = (radius - half_feather);\n\t\t\t\tfloat blend = 1.0 - (dist - feather_start) / feather;\n\t\t\t\treturn blend;\n\t\t\t}\n\t\t}\n\t}\n}\n\nfloat disk2d(vec2 pos, vec2 center, float radius, float feather){\n\tfloat dist = distance(pos, center);\n\treturn disk_feather(dist, radius, feather);\n}\n\n// function could be called sphere, but is an overload of disk, and is the same\nfloat disk3d(vec3 pos, vec3 center, float radius, float feather){\n\tfloat dist = distance(pos, center);\n\treturn disk_feather(dist, radius, feather);\n}");
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/gl/Disk.ts







const Disk_OUTPUT_NAME = "float";
class DiskGlParamsConfig extends params_ParamsConfig/* NodeParamsConfig */.yI {
  constructor() {
    super(...arguments);
    this.position = params_ParamsConfig/* ParamConfig.VECTOR2 */.XC.VECTOR2([0, 0]);
    this.center = params_ParamsConfig/* ParamConfig.VECTOR2 */.XC.VECTOR2([0, 0]);
    this.radius = params_ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(1);
    this.feather = params_ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(0.1);
  }
}
const Disk_ParamsConfig = new DiskGlParamsConfig();
class DiskGlNode extends gl_Base/* TypedGlNode */.hD {
  constructor() {
    super(...arguments);
    this.paramsConfig = Disk_ParamsConfig;
  }
  static type() {
    return "disk";
  }
  initializeNode() {
    super.initializeNode();
    this.io.outputs.setNamedOutputConnectionPoints([
      new Gl/* GlConnectionPoint */.E(Disk_OUTPUT_NAME, Gl/* GlConnectionPointType.FLOAT */.Dv.FLOAT)
    ]);
  }
  setLines(shaders_collection_controller) {
    const position = ThreeToGl/* ThreeToGl.vector2 */._.vector2(this.variableForInputParam(this.p.position));
    const center = ThreeToGl/* ThreeToGl.vector2 */._.vector2(this.variableForInputParam(this.p.center));
    const radius = ThreeToGl/* ThreeToGl.float */._.float(this.variableForInputParam(this.p.radius));
    const feather = ThreeToGl/* ThreeToGl.float */._.float(this.variableForInputParam(this.p.feather));
    const float = this.glVarName(Disk_OUTPUT_NAME);
    const body_line = `float ${float} = disk2d(${position}, ${center}, ${radius}, ${feather})`;
    shaders_collection_controller.addBodyLines(this, [body_line]);
    shaders_collection_controller.addDefinitions(this, [new GLDefinition/* FunctionGLDefinition */.MR(this, disk)]);
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/gl/gl/dither.glsl
/* harmony default export */ var dither = ("const vec4 ditherVec0 = vec4(0.0,  8.0,  2.0,  10.0);\nconst vec4 ditherVec1 = vec4(12.0, 4.0,  14.0, 6.0);\nconst vec4 ditherVec2 = vec4(3.0,  11.0, 1.0,  9.0);\nconst vec4 ditherVec3 = vec4(15.0, 7.0,  13.0, 5.0);\nfloat vec4Component(vec4 v, int y){\n\tif(y == 0){\n\t\treturn v.x;\n\t} else if(y == 1){\n\t\treturn v.y;\n\t} else if(y == 2){\n\t\treturn v.z;\n\t}\n\treturn v.w;\n}\nfloat indexValue() {\n\tint x = int(mod(gl_FragCoord.x, 4.0));\n\tint y = int(mod(gl_FragCoord.y, 4.0));\n\tif(x == 0){\n\t\treturn vec4Component(ditherVec0, y);\n\t} else if(x == 1){\n\t\treturn vec4Component(ditherVec1, y);\n\t} else if(x == 2){\n\t\treturn vec4Component(ditherVec2, y);\n\t}\n\treturn vec4Component(ditherVec3, y);\n}\nfloat computeDither(float alpha, float alphaTest) {\n\tfloat closestColor = (alpha < alphaTest) ? 0.0 : 1.0;\n\tfloat secondClosestColor = 1.0 - closestColor;\n\tfloat d = indexValue();\n\tfloat distance = abs(closestColor - alpha);\n\treturn (distance < d) ? closestColor : secondClosestColor;\n}\nfloat dither(float alpha, float alphaTest) {\n\tif( alpha <= 0.0 ){ discard; }\n\tif( alpha < 1.0 ) { alpha = computeDither(alpha, alphaTest); }\n\tif( alpha < 0.5 ) { discard; }\n\treturn alpha;\n}");
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/gl/Dither.ts







const Dither_OUTPUT_NAME = "dither";
class DitherGlParamsConfig extends params_ParamsConfig/* NodeParamsConfig */.yI {
  constructor() {
    super(...arguments);
    this.alpha = params_ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(1);
    this.alphaTest = params_ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(0.5);
  }
}
const Dither_ParamsConfig = new DitherGlParamsConfig();
class DitherGlNode extends gl_Base/* TypedGlNode */.hD {
  constructor() {
    super(...arguments);
    this.paramsConfig = Dither_ParamsConfig;
  }
  static type() {
    return "dither";
  }
  initializeNode() {
    super.initializeNode();
    this.io.outputs.setNamedOutputConnectionPoints([
      new Gl/* GlConnectionPoint */.E(Dither_OUTPUT_NAME, Gl/* GlConnectionPointType.FLOAT */.Dv.FLOAT)
    ]);
  }
  setLines(shadersCollectionController) {
    const alpha = ThreeToGl/* ThreeToGl.float */._.float(this.variableForInputParam(this.p.alpha));
    const alphaTest = ThreeToGl/* ThreeToGl.float */._.float(this.variableForInputParam(this.p.alphaTest));
    const output = this.glVarName(Dither_OUTPUT_NAME);
    const body_line = `float ${output} = dither(${alpha}, ${alphaTest})`;
    shadersCollectionController.addBodyLines(this, [body_line]);
    shadersCollectionController.addDefinitions(this, [new GLDefinition/* FunctionGLDefinition */.MR(this, dither)]);
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/gl/gl/easing/circular-in-out.glsl
/* harmony default export */ var circular_in_out = ("float circularInOut(float t) {\n  return t < 0.5\n    ? 0.5 * (1.0 - sqrt(1.0 - 4.0 * t * t))\n    : 0.5 * (sqrt((3.0 - 2.0 * t) * (2.0 * t - 1.0)) + 1.0);\n}\n\n");
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/gl/gl/easing/exponential-in-out.glsl
/* harmony default export */ var exponential_in_out = ("float exponentialInOut(float t) {\n  return t == 0.0 || t == 1.0\n    ? t\n    : t < 0.5\n      ? +0.5 * pow(2.0, (20.0 * t) - 10.0)\n      : -0.5 * pow(2.0, 10.0 - (t * 20.0)) + 1.0;\n}\n\n");
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/gl/gl/easing/circular-in.glsl
/* harmony default export */ var circular_in = ("float circularIn(float t) {\n  return 1.0 - sqrt(1.0 - t * t);\n}\n\n");
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/gl/gl/easing/elastic-out.glsl
/* harmony default export */ var elastic_out = ("#ifndef HALF_PI\n#define HALF_PI 1.5707963267948966\n#endif\n\nfloat elasticOut(float t) {\n  return sin(-13.0 * (t + 1.0) * HALF_PI) * pow(2.0, -10.0 * t) + 1.0;\n}\n\n");
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/gl/gl/easing/cubic-in.glsl
/* harmony default export */ var cubic_in = ("float cubicIn(float t) {\n  return t * t * t;\n}\n\n");
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/gl/gl/easing/exponential-out.glsl
/* harmony default export */ var exponential_out = ("float exponentialOut(float t) {\n  return t == 1.0 ? t : 1.0 - pow(2.0, -10.0 * t);\n}\n\n");
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/gl/gl/easing/quintic-out.glsl
/* harmony default export */ var quintic_out = ("float quinticOut(float t) {\n  return 1.0 - (pow(t - 1.0, 5.0));\n}\n\n");
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/gl/gl/easing/elastic-in-out.glsl
/* harmony default export */ var elastic_in_out = ("#ifndef HALF_PI\n#define HALF_PI 1.5707963267948966\n#endif\n\nfloat elasticInOut(float t) {\n  return t < 0.5\n    ? 0.5 * sin(+13.0 * HALF_PI * 2.0 * t) * pow(2.0, 10.0 * (2.0 * t - 1.0))\n    : 0.5 * sin(-13.0 * HALF_PI * ((2.0 * t - 1.0) + 1.0)) * pow(2.0, -10.0 * (2.0 * t - 1.0)) + 1.0;\n}\n\n");
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/gl/gl/easing/linear.glsl
/* harmony default export */ var linear = ("float linear(float t) {\n  return t;\n}\n\n");
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/gl/gl/easing/circular-out.glsl
/* harmony default export */ var circular_out = ("float circularOut(float t) {\n  return sqrt((2.0 - t) * t);\n}\n\n");
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/gl/gl/easing/back-in-out.glsl
/* harmony default export */ var back_in_out = ("\nfloat backInOut(float t) {\n  float f = t < 0.5\n    ? 2.0 * t\n    : 1.0 - (2.0 * t - 1.0);\n\n  float g = pow(f, 3.0) - f * sin(f * PI);\n\n  return t < 0.5\n    ? 0.5 * g\n    : 0.5 * (1.0 - g) + 0.5;\n}\n\n");
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/gl/gl/easing/back-in.glsl
/* harmony default export */ var back_in = ("\nfloat backIn(float t) {\n  return pow(t, 3.0) - t * sin(t * PI);\n}\n\n");
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/gl/gl/easing/sine-in.glsl
/* harmony default export */ var sine_in = ("#ifndef HALF_PI\n#define HALF_PI 1.5707963267948966\n#endif\n\nfloat sineIn(float t) {\n  return sin((t - 1.0) * HALF_PI) + 1.0;\n}\n\n");
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/gl/gl/easing/back-out.glsl
/* harmony default export */ var back_out = ("\nfloat backOut(float t) {\n  float f = 1.0 - t;\n  return 1.0 - (pow(f, 3.0) - f * sin(f * PI));\n}\n\n");
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/gl/gl/easing/quartic-in-out.glsl
/* harmony default export */ var quartic_in_out = ("float quarticInOut(float t) {\n  return t < 0.5\n    ? +8.0 * pow(t, 4.0)\n    : -8.0 * pow(t - 1.0, 4.0) + 1.0;\n}\n\n");
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/gl/gl/easing/quadratic-in.glsl
/* harmony default export */ var quadratic_in = ("float quadraticIn(float t) {\n  return t * t;\n}\n\n");
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/gl/gl/easing/cubic-in-out.glsl
/* harmony default export */ var cubic_in_out = ("float cubicInOut(float t) {\n  return t < 0.5\n    ? 4.0 * t * t * t\n    : 0.5 * pow(2.0 * t - 2.0, 3.0) + 1.0;\n}\n\n");
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/gl/gl/easing/elastic-in.glsl
/* harmony default export */ var elastic_in = ("#ifndef HALF_PI\n#define HALF_PI 1.5707963267948966\n#endif\n\nfloat elasticIn(float t) {\n  return sin(13.0 * t * HALF_PI) * pow(2.0, 10.0 * (t - 1.0));\n}\n\n");
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/gl/gl/easing/bounce-out.glsl
/* harmony default export */ var bounce_out = ("\nfloat bounceOut(float t) {\n  const float a = 4.0 / 11.0;\n  const float b = 8.0 / 11.0;\n  const float c = 9.0 / 10.0;\n\n  const float ca = 4356.0 / 361.0;\n  const float cb = 35442.0 / 1805.0;\n  const float cc = 16061.0 / 1805.0;\n\n  float t2 = t * t;\n\n  return t < a\n    ? 7.5625 * t2\n    : t < b\n      ? 9.075 * t2 - 9.9 * t + 3.4\n      : t < c\n        ? ca * t2 - cb * t + cc\n        : 10.8 * t * t - 20.52 * t + 10.72;\n}\n\n");
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/gl/gl/easing/quadratic-in-out.glsl
/* harmony default export */ var quadratic_in_out = ("float quadraticInOut(float t) {\n  float p = 2.0 * t * t;\n  return t < 0.5 ? p : -p + (4.0 * t) - 1.0;\n}\n\n");
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/gl/gl/easing/exponential-in.glsl
/* harmony default export */ var exponential_in = ("float exponentialIn(float t) {\n  return t == 0.0 ? t : pow(2.0, 10.0 * (t - 1.0));\n}\n\n");
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/gl/gl/easing/quintic-in-out.glsl
/* harmony default export */ var quintic_in_out = ("float quinticInOut(float t) {\n  return t < 0.5\n    ? +16.0 * pow(t, 5.0)\n    : -0.5 * pow(2.0 * t - 2.0, 5.0) + 1.0;\n}\n\n");
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/gl/gl/easing/sine-in-out.glsl
/* harmony default export */ var sine_in_out = ("\nfloat sineInOut(float t) {\n  return -0.5 * (cos(PI * t) - 1.0);\n}\n\n");
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/gl/gl/easing/cubic-out.glsl
/* harmony default export */ var cubic_out = ("float cubicOut(float t) {\n  float f = t - 1.0;\n  return f * f * f + 1.0;\n}\n\n");
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/gl/gl/easing/quadratic-out.glsl
/* harmony default export */ var quadratic_out = ("float quadraticOut(float t) {\n  return -t * (t - 2.0);\n}\n\n");
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/gl/gl/easing/bounce-in-out.glsl
/* harmony default export */ var bounce_in_out = ("\nfloat bounceInOut(float t) {\n  return t < 0.5\n    ? 0.5 * (1.0 - bounceOut(1.0 - t * 2.0))\n    : 0.5 * bounceOut(t * 2.0 - 1.0) + 0.5;\n}\n\n\n\n");
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/gl/gl/easing/quintic-in.glsl
/* harmony default export */ var quintic_in = ("float quinticIn(float t) {\n  return pow(t, 5.0);\n}\n\n");
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/gl/gl/easing/quartic-in.glsl
/* harmony default export */ var quartic_in = ("float quarticIn(float t) {\n  return pow(t, 4.0);\n}\n\n");
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/gl/gl/easing/quartic-out.glsl
/* harmony default export */ var quartic_out = ("float quarticOut(float t) {\n  return pow(t - 1.0, 3.0) * (1.0 - t) + 1.0;\n}\n\n");
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/gl/gl/easing/bounce-in.glsl
/* harmony default export */ var bounce_in = ("\nfloat bounceIn(float t) {\n  return 1.0 - bounceOut(1.0 - t);\n}\n\n");
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/gl/gl/easing/sine-out.glsl
/* harmony default export */ var sine_out = ("#ifndef HALF_PI\n#define HALF_PI 1.5707963267948966\n#endif\n\nfloat sineOut(float t) {\n  return sin(t * HALF_PI);\n}\n\n");
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/gl/Easing.ts





































const EASE_NAMES = [
  "back-in-out",
  "back-in",
  "back-out",
  "bounce-in-out",
  "bounce-in",
  "bounce-out",
  "circular-in-out",
  "circular-in",
  "circular-out",
  "cubic-in-out",
  "cubic-in",
  "cubic-out",
  "elastic-in-out",
  "elastic-in",
  "elastic-out",
  "exponential-in-out",
  "exponential-in",
  "exponential-out",
  "linear",
  "quadratic-in-out",
  "quadratic-in",
  "quadratic-out",
  // "quartic-in-out",
  // "quartic-in",
  // "quartic-out",
  // "quintic-in-out",
  // "quintic-in",
  // "quintic-out",
  "sine-in-out",
  "sine-in",
  "sine-out"
];
const IMPORT_BY_EASE_NAME = {
  "circular-in-out": circular_in_out,
  "exponential-in-out": exponential_in_out,
  "circular-in": circular_in,
  "elastic-out": elastic_out,
  "cubic-in": cubic_in,
  "exponential-out": exponential_out,
  "quintic-out": quintic_out,
  "elastic-in-out": elastic_in_out,
  linear: linear,
  "circular-out": circular_out,
  "back-in-out": back_in_out,
  "back-in": back_in,
  "sine-in": sine_in,
  "back-out": back_out,
  "quartic-in-out": quartic_in_out,
  "quadratic-in": quadratic_in,
  "cubic-in-out": cubic_in_out,
  "elastic-in": elastic_in,
  "bounce-out": bounce_out,
  "quadratic-in-out": quadratic_in_out,
  "exponential-in": exponential_in,
  "quintic-in-out": quintic_in_out,
  "sine-in-out": sine_in_out,
  "cubic-out": cubic_out,
  "quadratic-out": quadratic_out,
  "bounce-in-out": bounce_in_out,
  "quintic-in": quintic_in,
  "quartic-in": quartic_in,
  "quartic-out": quartic_out,
  "bounce-in": bounce_in,
  "sine-out": sine_out
};
const IMPORT_DEPENDENCIES_BY_EASE_NAME = {
  "bounce-in": [bounce_out],
  "bounce-in-out": [bounce_out]
};
const METHOD_NAMES_BY_EASE_NAME = {
  "circular-in-out": "circularInOut",
  "exponential-in-out": "exponentialInOut",
  "circular-in": "circularIn",
  "elastic-out": "elasticOut",
  "cubic-in": "cubicIn",
  "exponential-out": "exponentialOut",
  "quintic-out": "quinticOut",
  "elastic-in-out": "elasticInOut",
  linear: "linear",
  "circular-out": "circularOut",
  "back-in-out": "backInOut",
  "back-in": "backIn",
  "sine-in": "sineIn",
  "back-out": "backOut",
  "quartic-in-out": "quarticInOut",
  "quadratic-in": "quadraticIn",
  "cubic-in-out": "cubicInOut",
  "elastic-in": "elasticIn",
  "bounce-out": "bounceOut",
  "quadratic-in-out": "quadraticInOut",
  "exponential-in": "exponentialIn",
  "quintic-in-out": "quinticInOut",
  "sine-in-out": "sineInOut",
  "cubic-out": "cubicOut",
  "quadratic-out": "quadraticOut",
  "bounce-in-out": "bounceInOut",
  "quintic-in": "quinticIn",
  "quartic-in": "quarticIn",
  "quartic-out": "quarticOut",
  "bounce-in": "bounceIn",
  "sine-out": "sineOut"
};
const ALLOWED_INPUTS = [
  Gl/* GlConnectionPointType.FLOAT */.Dv.FLOAT,
  Gl/* GlConnectionPointType.VEC2 */.Dv.VEC2,
  Gl/* GlConnectionPointType.VEC3 */.Dv.VEC3,
  Gl/* GlConnectionPointType.VEC4 */.Dv.VEC4
];
const Easing_INPUT_NAME = "in";
const Easing_OUTPUT_NAME = "out";
const default_ease_type = EASE_NAMES.indexOf("sine-in-out");
class EasingGlParamsConfig extends params_ParamsConfig/* NodeParamsConfig */.yI {
  constructor() {
    super(...arguments);
    this.type = params_ParamsConfig/* ParamConfig.INTEGER */.XC.INTEGER(default_ease_type, {
      menu: {
        entries: EASE_NAMES.map((name, i) => {
          return { name, value: i };
        })
      }
    });
  }
  // input = ParamConfig.FLOAT(0);
}
const Easing_ParamsConfig = new EasingGlParamsConfig();
class EasingGlNode extends gl_Base/* TypedGlNode */.hD {
  constructor() {
    super(...arguments);
    this.paramsConfig = Easing_ParamsConfig;
  }
  static type() {
    return "easing";
  }
  initializeNode() {
    super.initializeNode();
    this.io.connection_points.spare_params.setInputlessParamNames(["type"]);
    this.io.connection_points.set_expected_input_types_function(this._expected_input_types.bind(this));
    this.io.connection_points.set_expected_output_types_function(this._expected_output_types.bind(this));
    this.io.connection_points.set_input_name_function(this._gl_input_name.bind(this));
    this.io.connection_points.set_output_name_function(this._gl_output_name.bind(this));
    this.io.outputs.setNamedOutputConnectionPoints([
      new Gl/* GlConnectionPoint */.E(Easing_OUTPUT_NAME, Gl/* GlConnectionPointType.FLOAT */.Dv.FLOAT)
    ]);
  }
  _expected_input_types() {
    const type = this.io.connection_points.first_input_connection_type() || Gl/* GlConnectionPointType.FLOAT */.Dv.FLOAT;
    if (ALLOWED_INPUTS.includes(type)) {
      return [type];
    } else {
      return [Gl/* GlConnectionPointType.FLOAT */.Dv.FLOAT];
    }
  }
  _expected_output_types() {
    return [this._expected_input_types()[0]];
  }
  _gl_input_name(index) {
    return Easing_INPUT_NAME;
  }
  _gl_output_name(index) {
    return Easing_OUTPUT_NAME;
  }
  setLines(shaders_collection_controller) {
    const easeName = EASE_NAMES[this.pv.type];
    const glslFunctionCode = IMPORT_BY_EASE_NAME[easeName];
    let easeFunctions = [new GLDefinition/* FunctionGLDefinition */.MR(this, glslFunctionCode)];
    const functionDependencies = (IMPORT_DEPENDENCIES_BY_EASE_NAME[easeName] || []).map(
      (f) => new GLDefinition/* FunctionGLDefinition */.MR(this, f)
    );
    if (functionDependencies) {
      easeFunctions = functionDependencies.concat(easeFunctions);
    }
    shaders_collection_controller.addDefinitions(this, easeFunctions);
    shaders_collection_controller.addBodyLines(this, this._buildBodyLines(easeName));
  }
  _buildBodyLines(easeName) {
    const functionName = METHOD_NAMES_BY_EASE_NAME[easeName];
    const outValue = this.glVarName(Easing_OUTPUT_NAME);
    const outGlType = this._expected_output_types()[0];
    switch (outGlType) {
      case Gl/* GlConnectionPointType.FLOAT */.Dv.FLOAT: {
        const inValue = ThreeToGl/* ThreeToGl.float */._.float(this.variableForInput(Easing_INPUT_NAME));
        return [`${outGlType} ${outValue} = ${functionName}(${inValue})`];
      }
      default: {
        const bodyLines = [];
        const inValue = ThreeToGl/* ThreeToGl.glType */._.glType(outGlType, this.variableForInput(Easing_INPUT_NAME));
        const components = ThreeToGl/* COMPONENTS_BY_GL_TYPE */.r[outGlType];
        if (components) {
          const args = components.map((c) => `${functionName}(${inValue}.${c})`).join(", ");
          bodyLines.push(`${outGlType} ${outValue} = ${outGlType}(${args})`);
          return bodyLines;
        } else {
          return [];
        }
      }
    }
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/gl/gl/fit.glsl
/* harmony default export */ var fit = ("//\n//\n// FIT\n//\n//\nfloat fit(float val, float srcMin, float srcMax, float destMin, float destMax){\n\tfloat src_range = srcMax - srcMin;\n\tfloat dest_range = destMax - destMin;\n\n\tfloat r = (val - srcMin) / src_range;\n\treturn (r * dest_range) + destMin;\n}\nvec2 fit(vec2 val, vec2 srcMin, vec2 srcMax, vec2 destMin, vec2 destMax){\n\treturn vec2(\n\t\tfit(val.x, srcMin.x, srcMax.x, destMin.x, destMax.x),\n\t\tfit(val.y, srcMin.y, srcMax.y, destMin.y, destMax.y)\n\t);\n}\nvec3 fit(vec3 val, vec3 srcMin, vec3 srcMax, vec3 destMin, vec3 destMax){\n\treturn vec3(\n\t\tfit(val.x, srcMin.x, srcMax.x, destMin.x, destMax.x),\n\t\tfit(val.y, srcMin.y, srcMax.y, destMin.y, destMax.y),\n\t\tfit(val.z, srcMin.z, srcMax.z, destMin.z, destMax.z)\n\t);\n}\nvec4 fit(vec4 val, vec4 srcMin, vec4 srcMax, vec4 destMin, vec4 destMax){\n\treturn vec4(\n\t\tfit(val.x, srcMin.x, srcMax.x, destMin.x, destMax.x),\n\t\tfit(val.y, srcMin.y, srcMax.y, destMin.y, destMax.y),\n\t\tfit(val.z, srcMin.z, srcMax.z, destMin.z, destMax.z),\n\t\tfit(val.w, srcMin.w, srcMax.w, destMin.w, destMax.w)\n\t);\n}\n\n//\n//\n// FIT TO 01\n// fits the range [srcMin, srcMax] to [0, 1]\n//\nfloat fitTo01(float val, float srcMin, float srcMax){\n\tfloat size = srcMax - srcMin;\n\treturn (val - srcMin) / size;\n}\nvec2 fitTo01(vec2 val, vec2 srcMin, vec2 srcMax){\n\treturn vec2(\n\t\tfitTo01(val.x, srcMin.x, srcMax.x),\n\t\tfitTo01(val.y, srcMin.y, srcMax.y)\n\t);\n}\nvec3 fitTo01(vec3 val, vec3 srcMin, vec3 srcMax){\n\treturn vec3(\n\t\tfitTo01(val.x, srcMin.x, srcMax.x),\n\t\tfitTo01(val.y, srcMin.y, srcMax.y),\n\t\tfitTo01(val.z, srcMin.z, srcMax.z)\n\t);\n}\nvec4 fitTo01(vec4 val, vec4 srcMin, vec4 srcMax){\n\treturn vec4(\n\t\tfitTo01(val.x, srcMin.x, srcMax.x),\n\t\tfitTo01(val.y, srcMin.y, srcMax.y),\n\t\tfitTo01(val.z, srcMin.z, srcMax.z),\n\t\tfitTo01(val.w, srcMin.w, srcMax.w)\n\t);\n}\n\n//\n//\n// FIT FROM 01\n// fits the range [0, 1] to [destMin, destMax]\n//\nfloat fitFrom01(float val, float destMin, float destMax){\n\treturn fit(val, 0.0, 1.0, destMin, destMax);\n}\nvec2 fitFrom01(vec2 val, vec2 srcMin, vec2 srcMax){\n\treturn vec2(\n\t\tfitFrom01(val.x, srcMin.x, srcMax.x),\n\t\tfitFrom01(val.y, srcMin.y, srcMax.y)\n\t);\n}\nvec3 fitFrom01(vec3 val, vec3 srcMin, vec3 srcMax){\n\treturn vec3(\n\t\tfitFrom01(val.x, srcMin.x, srcMax.x),\n\t\tfitFrom01(val.y, srcMin.y, srcMax.y),\n\t\tfitFrom01(val.z, srcMin.z, srcMax.z)\n\t);\n}\nvec4 fitFrom01(vec4 val, vec4 srcMin, vec4 srcMax){\n\treturn vec4(\n\t\tfitFrom01(val.x, srcMin.x, srcMax.x),\n\t\tfitFrom01(val.y, srcMin.y, srcMax.y),\n\t\tfitFrom01(val.z, srcMin.z, srcMax.z),\n\t\tfitFrom01(val.w, srcMin.w, srcMax.w)\n\t);\n}\n\n//\n//\n// FIT FROM 01 TO VARIANCE\n// fits the range [0, 1] to [center - variance, center + variance]\n//\nfloat fitFrom01ToVariance(float val, float center, float variance){\n\treturn fitFrom01(val, center - variance, center + variance);\n}\nvec2 fitFrom01ToVariance(vec2 val, vec2 center, vec2 variance){\n\treturn vec2(\n\t\tfitFrom01ToVariance(val.x, center.x, variance.x),\n\t\tfitFrom01ToVariance(val.y, center.y, variance.y)\n\t);\n}\nvec3 fitFrom01ToVariance(vec3 val, vec3 center, vec3 variance){\n\treturn vec3(\n\t\tfitFrom01ToVariance(val.x, center.x, variance.x),\n\t\tfitFrom01ToVariance(val.y, center.y, variance.y),\n\t\tfitFrom01ToVariance(val.z, center.z, variance.z)\n\t);\n}\nvec4 fitFrom01ToVariance(vec4 val, vec4 center, vec4 variance){\n\treturn vec4(\n\t\tfitFrom01ToVariance(val.x, center.x, variance.x),\n\t\tfitFrom01ToVariance(val.y, center.y, variance.y),\n\t\tfitFrom01ToVariance(val.z, center.z, variance.z),\n\t\tfitFrom01ToVariance(val.w, center.w, variance.w)\n\t);\n}");
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/gl/Fit.ts





const FitDefaultValues = {
  srcMin: 0,
  srcMax: 1,
  destMin: 0,
  destMax: 1
};
class FitGlNode extends BaseNodeGlMathFunctionArg5GlNode {
  static type() {
    return "fit";
  }
  _gl_input_name(index) {
    return ["val", "srcMin", "srcMax", "destMin", "destMax"][index];
  }
  paramDefaultValue(name) {
    return FitDefaultValues[name];
  }
  gl_method_name() {
    return "fit";
  }
  gl_function_definitions() {
    return [new GLDefinition/* FunctionGLDefinition */.MR(this, fit)];
  }
}
const FitTo01DefaultValues = {
  srcMin: 0,
  srcMax: 1
};
class FitTo01GlNode extends BaseNodeGlMathFunctionArg3GlNode {
  static type() {
    return "fitTo01";
  }
  _gl_input_name(index) {
    return ["val", "srcMin", "srcMax"][index];
  }
  paramDefaultValue(name) {
    return FitTo01DefaultValues[name];
  }
  gl_method_name() {
    return "fitTo01";
  }
  gl_function_definitions() {
    return [new GLDefinition/* FunctionGLDefinition */.MR(this, fit)];
  }
}
const FitFrom01DefaultValues = {
  destMin: 0,
  destMax: 1
};
class FitFrom01GlNode extends BaseNodeGlMathFunctionArg3GlNode {
  static type() {
    return "fitFrom01";
  }
  _gl_input_name(index) {
    return ["val", "destMin", "destMax"][index];
  }
  paramDefaultValue(name) {
    return FitFrom01DefaultValues[name];
  }
  gl_method_name() {
    return "fitFrom01";
  }
  gl_function_definitions() {
    return [new GLDefinition/* FunctionGLDefinition */.MR(this, fit)];
  }
}
const FitFrom01ToVarianceDefaultValues = {
  center: 0.5,
  variance: 0.5
};
class FitFrom01ToVarianceGlNode extends BaseNodeGlMathFunctionArg3GlNode {
  static type() {
    return "fitFrom01ToVariance";
  }
  _gl_input_name(index) {
    return ["val", "center", "variance"][index];
  }
  paramDefaultValue(name) {
    return FitFrom01ToVarianceDefaultValues[name];
  }
  gl_method_name() {
    return "fitFrom01ToVariance";
  }
  gl_function_definitions() {
    return [new GLDefinition/* FunctionGLDefinition */.MR(this, fit)];
  }
}

// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/nodes/utils/shaders/ShaderName.ts
var ShaderName = __webpack_require__(76606);
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/gl/gl/fog.glsl
/* harmony default export */ var fog = ("vec3 compute_fog(vec4 mvPosition, vec3 base_color, vec3 fog_color, float near, float far) {\n\tfloat blend = (-mvPosition.z - near) / (far - near);\n\tblend = clamp(blend, 0.0, 1.0);\n\treturn blend * fog_color + (1.0 - blend) * base_color;\n}");
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/gl/Fog.ts








const Fog_OUTPUT_NAME = "color";
class FogGlParamsConfig extends params_ParamsConfig/* NodeParamsConfig */.yI {
  constructor() {
    super(...arguments);
    this.mvPosition = params_ParamsConfig/* ParamConfig.VECTOR4 */.XC.VECTOR4([0, 0, 0, 0]);
    this.baseColor = params_ParamsConfig/* ParamConfig.COLOR */.XC.COLOR([0, 0, 0]);
    this.fogColor = params_ParamsConfig/* ParamConfig.COLOR */.XC.COLOR([1, 1, 1]);
    this.near = params_ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(0);
    this.far = params_ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(0);
  }
}
const Fog_ParamsConfig = new FogGlParamsConfig();
class FogGlNode extends gl_Base/* TypedGlNode */.hD {
  constructor() {
    super(...arguments);
    this.paramsConfig = Fog_ParamsConfig;
  }
  static type() {
    return "fog";
  }
  initializeNode() {
    super.initializeNode();
    this.io.outputs.setNamedOutputConnectionPoints([
      new Gl/* GlConnectionPoint */.E(Fog_OUTPUT_NAME, Gl/* GlConnectionPointType.VEC3 */.Dv.VEC3)
    ]);
  }
  setLines(shaders_collection_controller) {
    if (shaders_collection_controller.currentShaderName() == ShaderName/* ShaderName.FRAGMENT */.k.FRAGMENT) {
      const varying_name = this.glVarName(this.name());
      const definition = new GLDefinition/* VaryingGLDefinition */.W9(this, Gl/* GlConnectionPointType.VEC4 */.Dv.VEC4, varying_name);
      const vertex_body_line = `${varying_name} = modelViewMatrix * vec4(position, 1.0)`;
      shaders_collection_controller.addDefinitions(this, [definition], ShaderName/* ShaderName.VERTEX */.k.VERTEX);
      shaders_collection_controller.addBodyLines(this, [vertex_body_line], ShaderName/* ShaderName.VERTEX */.k.VERTEX);
      const function_definition = new GLDefinition/* FunctionGLDefinition */.MR(this, fog);
      const mvPosition = ThreeToGl/* ThreeToGl.vector4 */._.vector4(this.variableForInputParam(this.p.mvPosition));
      const baseColor = ThreeToGl/* ThreeToGl.vector3 */._.vector3(this.variableForInputParam(this.p.baseColor));
      const fogColor = ThreeToGl/* ThreeToGl.vector3 */._.vector3(this.variableForInputParam(this.p.fogColor));
      const near = ThreeToGl/* ThreeToGl.vector3 */._.vector3(this.variableForInputParam(this.p.near));
      const far = ThreeToGl/* ThreeToGl.vector3 */._.vector3(this.variableForInputParam(this.p.far));
      const out_value = this.glVarName(Fog_OUTPUT_NAME);
      const args = [mvPosition, baseColor, fogColor, near, far].join(", ");
      const body_line = `vec3 ${out_value} = compute_fog(${args})`;
      shaders_collection_controller.addDefinitions(this, [definition, function_definition]);
      shaders_collection_controller.addBodyLines(this, [body_line]);
    }
  }
}

// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/nodes/gl/ForLoop.ts
var ForLoop = __webpack_require__(18169);
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/gl/gl/fresnel.glsl
/* harmony default export */ var fresnel = ("float fresnel(vec4 worldPosition, vec3 worldNormal, vec3 cameraPosition){\n\treturn dot(\n\t\tnormalize(worldNormal),\n\t\tnormalize(cameraPosition - worldPosition.xyz)\n\t);\n}");
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/params/Vector3.ts
var Vector3 = __webpack_require__(65703);
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/gl/Fresnel.ts








const Fresnel_OUTPUT_NAME = "fresnel";
class FresnelGlParamsConfig extends params_ParamsConfig/* NodeParamsConfig */.yI {
  constructor() {
    super(...arguments);
    this.worldPosition = params_ParamsConfig/* ParamConfig.VECTOR4 */.XC.VECTOR4([0, 0, 0, 0]);
    this.worldNormal = params_ParamsConfig/* ParamConfig.VECTOR3 */.XC.VECTOR3([0, 0, 0]);
    this.cameraPosition = params_ParamsConfig/* ParamConfig.VECTOR3 */.XC.VECTOR3([0, 0, 0]);
  }
}
const Fresnel_ParamsConfig = new FresnelGlParamsConfig();
class FresnelGlNode extends gl_Base/* TypedGlNode */.hD {
  constructor() {
    super(...arguments);
    this.paramsConfig = Fresnel_ParamsConfig;
  }
  static type() {
    return "fresnel";
  }
  initializeNode() {
    super.initializeNode();
    this.io.outputs.setNamedOutputConnectionPoints([
      new Gl/* GlConnectionPoint */.E(Fresnel_OUTPUT_NAME, Gl/* GlConnectionPointType.FLOAT */.Dv.FLOAT)
    ]);
  }
  setLines(shadersCollectionController) {
    const args = [
      this._varFromParam(this.p.worldPosition, ThreeToGl/* ThreeToGl.vector4 */._.vector4, shadersCollectionController),
      this._varFromParam(this.p.worldNormal, ThreeToGl/* ThreeToGl.vector3 */._.vector3, shadersCollectionController),
      this._varFromParam(this.p.cameraPosition, ThreeToGl/* ThreeToGl.vector3 */._.vector3, shadersCollectionController)
    ];
    const output = this.glVarName(Fresnel_OUTPUT_NAME);
    const body_line = `float ${output} = fresnel(${args.join(",")})`;
    shadersCollectionController.addBodyLines(this, [body_line]);
    shadersCollectionController.addDefinitions(this, [new GLDefinition/* FunctionGLDefinition */.MR(this, fresnel)]);
  }
  _varFromParam(param, convertMethod, shadersCollectionController) {
    const varName = param.name();
    const input = this.io.inputs.named_input(param.name());
    if (input) {
      return convertMethod(this.variableForInputParam(param));
    } else {
      const glType = param instanceof Vector3/* Vector3Param */.q ? Gl/* GlConnectionPointType.VEC3 */.Dv.VEC3 : Gl/* GlConnectionPointType.VEC4 */.Dv.VEC4;
      this._getGlobalVar(varName, glType, shadersCollectionController);
      return this.glVarName(varName);
    }
  }
  _getGlobalVar(varName, glType, shadersCollectionController) {
    var _a;
    const assembler = shadersCollectionController.assembler();
    (_a = assembler.globalsHandler()) == null ? void 0 : _a.handleGlobalVar(this, varName, glType, shadersCollectionController);
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/gl/GeometryAttributeLookupUv.ts







const GeometryAttributeLookupUv_OUTPUT_NAME = "uv";
class GeometryAttributeLookupUvGlParamsConfig extends params_ParamsConfig/* NodeParamsConfig */.yI {
  constructor() {
    super(...arguments);
    this.id = params_ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(0);
    this.textureSize = params_ParamsConfig/* ParamConfig.VECTOR2 */.XC.VECTOR2([1, 1]);
  }
}
const GeometryAttributeLookupUv_ParamsConfig = new GeometryAttributeLookupUvGlParamsConfig();
class GeometryAttributeLookupUvGlNode extends gl_Base/* TypedGlNode */.hD {
  constructor() {
    super(...arguments);
    this.paramsConfig = GeometryAttributeLookupUv_ParamsConfig;
  }
  static type() {
    return "geometryAttributeLookupUv";
  }
  initializeNode() {
    super.initializeNode();
    this.io.outputs.setNamedOutputConnectionPoints([
      new Gl/* GlConnectionPoint */.E(GeometryAttributeLookupUv_OUTPUT_NAME, Gl/* GlConnectionPointType.VEC2 */.Dv.VEC2)
    ]);
  }
  setLines(shadersCollectionController) {
    const id = ThreeToGl/* ThreeToGl.float */._.float(this.variableForInputParam(this.p.id));
    const textureSize = ThreeToGl/* ThreeToGl.vector2 */._.vector2(this.variableForInputParam(this.p.textureSize));
    const uv = this.glVarName(GeometryAttributeLookupUv_OUTPUT_NAME);
    const functionCall = `geometryAttributesLookupUv(${id},${textureSize})`;
    const bodyLine = `vec2 ${uv} = ${functionCall}`;
    shadersCollectionController.addBodyLines(this, [bodyLine]);
    shadersCollectionController.addDefinitions(this, [new GLDefinition/* FunctionGLDefinition */.MR(this, geometryAttributesLookupUv/* default */.Z)]);
  }
}

// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/nodes/gl/Globals.ts
var Globals = __webpack_require__(81583);
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/gl/gl/grid.glsl
/* harmony default export */ var grid = ("// https://www.shadertoy.com/view/XtBfzz\n// https://iquilezles.org/articles/checkerfiltering/\n\nfloat gridTextureGradBox( in vec2 p, in float lineWidth, in vec2 ddx, in vec2 ddy )\n{\n\t// filter kernel\n\tvec2 w = max(abs(ddx), abs(ddy)) + 0.01;\n\n\t// analytic (box) filtering\n\tvec2 a = p + 0.5*w;\n\tvec2 b = p - 0.5*w;\n\tvec2 i = (floor(a)+min(fract(a)/lineWidth,1.0)-\n\t\t\t\tfloor(b)-min(fract(b)/lineWidth,1.0))/(w/lineWidth);\n\t//pattern\n\treturn (1.0-i.x)*(1.0-i.y);\n}\n\nfloat grid( in vec2 p, in float lineWidth )\n{\n    // coordinates\n    vec2 i = step( fract(p), vec2(1.0*lineWidth) );\n    //pattern\n    return (1.0-i.x)*(1.0-i.y);   // grid (N=10)\n    \n    // other possible patterns are these\n    //return 1.0-i.x*i.y;           // squares (N=4)\n    //return 1.0-i.x-i.y+2.0*i.x*i.y; // checker (N=2)\n}");
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/gl/Grid.ts








const Grid_OUTPUT_NAME = "grid";
class GridGlParamsConfig extends params_ParamsConfig/* NodeParamsConfig */.yI {
  constructor() {
    super(...arguments);
    this.uv = params_ParamsConfig/* ParamConfig.VECTOR2 */.XC.VECTOR2([0, 0]);
    this.lineWidth = params_ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(0.1, {
      range: [0, 1],
      rangeLocked: [false, false]
    });
    this.freq = params_ParamsConfig/* ParamConfig.VECTOR2 */.XC.VECTOR2([1, 1]);
    this.freqMult = params_ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(1, {
      range: [0, 10],
      rangeLocked: [false, false]
    });
    this.filtered = params_ParamsConfig/* ParamConfig.BOOLEAN */.XC.BOOLEAN(1);
  }
}
const Grid_ParamsConfig = new GridGlParamsConfig();
class GridGlNode extends gl_Base/* TypedGlNode */.hD {
  constructor() {
    super(...arguments);
    this.paramsConfig = Grid_ParamsConfig;
  }
  static type() {
    return "grid";
  }
  initializeNode() {
    super.initializeNode();
    this.io.connection_points.spare_params.setInputlessParamNames(["filtered"]);
    this.io.outputs.setNamedOutputConnectionPoints([
      new Gl/* GlConnectionPoint */.E(Grid_OUTPUT_NAME, Gl/* GlConnectionPointType.FLOAT */.Dv.FLOAT)
    ]);
  }
  setLines(shadersCollectionController) {
    const uv = ThreeToGl/* ThreeToGl.vector2 */._.vector2(this.variableForInputParam(this.p.uv));
    const lineWidth = ThreeToGl/* ThreeToGl.float */._.float(this.variableForInputParam(this.p.lineWidth));
    const freq = ThreeToGl/* ThreeToGl.vector2 */._.vector2(this.variableForInputParam(this.p.freq));
    const freqMult = ThreeToGl/* ThreeToGl.float */._.float(this.variableForInputParam(this.p.freqMult));
    const coord = this.glVarName("coord");
    const float = this.glVarName(Grid_OUTPUT_NAME);
    const coordLine = `vec2 ${coord} = ${uv}*${freq}*${freqMult}`;
    const functionCall = (0,Type/* isBooleanTrue */.bI)(this.pv.filtered) ? `gridTextureGradBox(${coord}, ${lineWidth}, dFdx(${coord}), dFdy(${coord}))` : `grid(${coord}, ${lineWidth})`;
    const bodyLine = `float ${float} = ${functionCall}`;
    shadersCollectionController.addBodyLines(this, [coordLine, bodyLine]);
    shadersCollectionController.addDefinitions(this, [new GLDefinition/* FunctionGLDefinition */.MR(this, grid)]);
  }
}

// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/nodes/gl/gl/color.glsl
var color = __webpack_require__(18361);
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/gl/HsluvToRgb.ts






const HsluvToRgb_OUTPUT_NAME = "rgb";

class LabToRgbGlParamsConfig extends params_ParamsConfig/* NodeParamsConfig */.yI {
  constructor() {
    super(...arguments);
    this.hsluv = params_ParamsConfig/* ParamConfig.VECTOR3 */.XC.VECTOR3([1, 1, 1]);
  }
}
const HsluvToRgb_ParamsConfig = new LabToRgbGlParamsConfig();
class HsluvToRgbGlNode extends gl_Base/* TypedGlNode */.hD {
  constructor() {
    super(...arguments);
    this.paramsConfig = HsluvToRgb_ParamsConfig;
  }
  static type() {
    return "hsluvToRgb";
  }
  initializeNode() {
    super.initializeNode();
    this.io.outputs.setNamedOutputConnectionPoints([
      new Gl/* GlConnectionPoint */.E(HsluvToRgb_OUTPUT_NAME, Gl/* GlConnectionPointType.VEC3 */.Dv.VEC3)
    ]);
  }
  setLines(shaders_collection_controller) {
    const function_declaration_lines = [];
    const body_lines = [];
    function_declaration_lines.push(new GLDefinition/* FunctionGLDefinition */.MR(this, color/* default */.Z));
    const value = ThreeToGl/* ThreeToGl.vector3 */._.vector3(this.variableForInputParam(this.p.hsluv));
    const rgb = this.glVarName(HsluvToRgb_OUTPUT_NAME);
    body_lines.push(`vec3 ${rgb} = hsluvToRgb(${value}.x * 360.0, ${value}.y * 100.0, ${value}.z * 100.0)`);
    shaders_collection_controller.addDefinitions(this, function_declaration_lines);
    shaders_collection_controller.addBodyLines(this, body_lines);
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/gl/gl/hsv2rgb.glsl
/* harmony default export */ var hsv2rgb = ("// https://github.com/hughsk/glsl-hsv2rgb\n// https://stackoverflow.com/questions/15095909/from-rgb-to-hsv-in-opengl-glsl\nvec3 hsv2rgb(vec3 c) {\n\tvec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n\tvec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n\treturn c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}");
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/gl/HsvToRgb.ts






const HsvToRgb_OUTPUT_NAME = "rgb";

class HsvToRgbGlParamsConfig extends params_ParamsConfig/* NodeParamsConfig */.yI {
  constructor() {
    super(...arguments);
    this.hsv = params_ParamsConfig/* ParamConfig.VECTOR3 */.XC.VECTOR3([1, 1, 1]);
  }
}
const HsvToRgb_ParamsConfig = new HsvToRgbGlParamsConfig();
class HsvToRgbGlNode extends gl_Base/* TypedGlNode */.hD {
  constructor() {
    super(...arguments);
    this.paramsConfig = HsvToRgb_ParamsConfig;
  }
  static type() {
    return "hsvToRgb";
  }
  initializeNode() {
    super.initializeNode();
    this.io.outputs.setNamedOutputConnectionPoints([
      new Gl/* GlConnectionPoint */.E(HsvToRgb_OUTPUT_NAME, Gl/* GlConnectionPointType.VEC3 */.Dv.VEC3)
    ]);
  }
  setLines(shaders_collection_controller) {
    const function_declaration_lines = [];
    const body_lines = [];
    function_declaration_lines.push(new GLDefinition/* FunctionGLDefinition */.MR(this, hsv2rgb));
    const value = ThreeToGl/* ThreeToGl.vector3 */._.vector3(this.variableForInputParam(this.p.hsv));
    const rgb = this.glVarName(HsvToRgb_OUTPUT_NAME);
    body_lines.push(`vec3 ${rgb} = hsv2rgb(${value})`);
    shaders_collection_controller.addDefinitions(this, function_declaration_lines);
    shaders_collection_controller.addBodyLines(this, body_lines);
  }
}

// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/nodes/gl/IfThen.ts
var IfThen = __webpack_require__(91561);
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/gl/InRange.ts





class InRangeGlParamsConfig extends params_ParamsConfig/* NodeParamsConfig */.yI {
  // input = ParamConfig.FLOAT(0.5);
  // min = ParamConfig.FLOAT(0);
  // max = ParamConfig.FLOAT(1);
}
const InRange_ParamsConfig = new InRangeGlParamsConfig();
const _InRangeGlNode = class extends gl_Base/* TypedGlNode */.hD {
  constructor() {
    super(...arguments);
    this.paramsConfig = InRange_ParamsConfig;
  }
  static type() {
    return "inRange";
  }
  initializeNode() {
    super.initializeNode();
    this.io.connection_points.set_input_name_function(
      (i) => [_InRangeGlNode.INPUT, _InRangeGlNode.INPUT_MIN, _InRangeGlNode.INPUT_MAX][i]
    );
    this.io.connection_points.set_output_name_function(() => _InRangeGlNode.OUTPUT);
    this.io.connection_points.set_expected_input_types_function(this._expected_input_types.bind(this));
    this.io.connection_points.set_expected_output_types_function(() => [Gl/* GlConnectionPointType.BOOL */.Dv.BOOL]);
  }
  _expected_input_types() {
    const type = Gl/* GlConnectionPointType.FLOAT */.Dv.FLOAT;
    return [type, type, type];
  }
  setLines(shadersCollectionController) {
    const glOutType = Gl/* GlConnectionPointType.BOOL */.Dv.BOOL;
    const input = ThreeToGl/* ThreeToGl.float */._.float(this.variableForInput(_InRangeGlNode.INPUT));
    const inputMin = ThreeToGl/* ThreeToGl.float */._.float(this.variableForInput(_InRangeGlNode.INPUT_MIN));
    const inputMax = ThreeToGl/* ThreeToGl.float */._.float(this.variableForInput(_InRangeGlNode.INPUT_MAX));
    const out = this.glVarName(this.io.connection_points.output_name(0));
    const bodyLine = `${glOutType} ${out} = ${input} > ${inputMin} && ${input} < ${inputMax}`;
    shadersCollectionController.addBodyLines(this, [bodyLine]);
  }
};
let InRangeGlNode = _InRangeGlNode;
InRangeGlNode.OUTPUT = "out";
InRangeGlNode.INPUT = "input";
InRangeGlNode.INPUT_MIN = "min";
InRangeGlNode.INPUT_MAX = "max";

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/gl/IsInfOrNan.ts




const IS_INF_DEFINE = "#define isInf(x) ( (x) == (x)+1. )";
const IS_NAN_DEFINE = "#define isNaN(x) ( (x) != (x)    )";
const DEFINES = [IS_INF_DEFINE, IS_NAN_DEFINE].join("\n");
const IsInfOrNan_ALLOWED_INPUTS = [
  Gl/* GlConnectionPointType.FLOAT */.Dv.FLOAT,
  Gl/* GlConnectionPointType.VEC2 */.Dv.VEC2,
  Gl/* GlConnectionPointType.VEC3 */.Dv.VEC3,
  Gl/* GlConnectionPointType.VEC4 */.Dv.VEC4
];



class IsInfOrNanGlParamsConfig extends params_ParamsConfig/* NodeParamsConfig */.yI {
  constructor() {
    super(...arguments);
    this.testIsInf = params_ParamsConfig/* ParamConfig.BOOLEAN */.XC.BOOLEAN(1);
    this.testIsNan = params_ParamsConfig/* ParamConfig.BOOLEAN */.XC.BOOLEAN(1);
  }
}
const IsInfOrNan_ParamsConfig = new IsInfOrNanGlParamsConfig();
const _IsInfOrNanGlNode = class extends gl_Base/* TypedGlNode */.hD {
  constructor() {
    super(...arguments);
    this.paramsConfig = IsInfOrNan_ParamsConfig;
  }
  static type() {
    return "isInfOrNan";
  }
  initializeNode() {
    super.initializeNode();
    this.io.connection_points.set_input_name_function(() => _IsInfOrNanGlNode.INPUT);
    this.io.connection_points.set_output_name_function(() => _IsInfOrNanGlNode.OUTPUT);
    this.io.connection_points.set_expected_input_types_function(this._expected_input_types.bind(this));
    this.io.connection_points.set_expected_output_types_function(() => [Gl/* GlConnectionPointType.BOOL */.Dv.BOOL]);
  }
  _expected_input_types() {
    const type = this.io.connection_points.first_input_connection_type() || Gl/* GlConnectionPointType.FLOAT */.Dv.FLOAT;
    if (IsInfOrNan_ALLOWED_INPUTS.includes(type)) {
      return [type];
    } else {
      return [Gl/* GlConnectionPointType.FLOAT */.Dv.FLOAT];
    }
  }
  setLines(shadersCollectionController) {
    const glOutType = Gl/* GlConnectionPointType.BOOL */.Dv.BOOL;
    const out = this.glVarName(this.io.connection_points.output_name(0));
    const bodyLine = `${glOutType} ${out} = ${this._functionCalls()}`;
    shadersCollectionController.addBodyLines(this, [bodyLine]);
    shadersCollectionController.addDefinitions(this, [new GLDefinition/* FunctionGLDefinition */.MR(this, DEFINES)]);
  }
  _functionCalls() {
    const inValue = ThreeToGl/* ThreeToGl.any */._.any(this.variableForInput(_IsInfOrNanGlNode.INPUT));
    const connectionPoints = this.io.inputs.namedInputConnectionPoints();
    if (!connectionPoints) {
      return;
    }
    const glInType = connectionPoints[0].type();
    const testFunction = (inputVal) => {
      const functions = [];
      if ((0,Type/* isBooleanTrue */.bI)(this.pv.testIsInf)) {
        functions.push(`isInf(${inputVal})`);
      }
      if ((0,Type/* isBooleanTrue */.bI)(this.pv.testIsNan)) {
        functions.push(`isNaN(${inputVal})`);
      }
      if (functions.length > 0) {
        return functions.join(" || ");
      } else {
        return true;
      }
    };
    const testFunctionsForComponents = (components2) => {
      return components2.map((c) => testFunction(`${inValue}.${c}`)).join(" || ");
    };
    const components = ThreeToGl/* COMPONENTS_BY_GL_TYPE */.r[glInType];
    if (components) {
      return testFunctionsForComponents(components);
    } else {
      return testFunction(inValue);
    }
  }
};
let IsInfOrNanGlNode = _IsInfOrNanGlNode;
IsInfOrNanGlNode.OUTPUT = "out";
IsInfOrNanGlNode.INPUT = "in";

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/gl/gl/impostor.glsl
/* harmony default export */ var impostor = ("// ANGLE_NORMALIZER = 1 / (2*PI)\n# define IMPOSTOR_UV_ANGLE_NORMALIZER 0.15915494309189535\nvec2 impostor_uv(vec3 center, vec3 camera_pos, vec2 imp_uv, float tiles_count, float offset){\n\timp_uv.x /= tiles_count;\n\n\tcamera_pos.y = center.y;\n\tvec3 delta = normalize(center - camera_pos);\n\tvec3 angle_start = vec3(-1.0,0.0,0.0);\n\tfloat angle = vector_angle(delta, angle_start) + offset;\n\tangle *= IMPOSTOR_UV_ANGLE_NORMALIZER;\n\tangle *= tiles_count;\n\tangle = floor(angle);\n\tangle /= tiles_count;\n\timp_uv.x -= angle;\n\n\treturn imp_uv;\n}\n");
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/gl/ImpostorUv.ts








const ImpostorUv_OUTPUT_NAME = "uv";
class ImpostorUvGlParamsConfig extends params_ParamsConfig/* NodeParamsConfig */.yI {
  constructor() {
    super(...arguments);
    this.center = params_ParamsConfig/* ParamConfig.VECTOR3 */.XC.VECTOR3([0, 0, 0]);
    this.cameraPos = params_ParamsConfig/* ParamConfig.VECTOR3 */.XC.VECTOR3([0, 0, 0]);
    this.uv = params_ParamsConfig/* ParamConfig.VECTOR2 */.XC.VECTOR2([0, 0]);
    this.tilesCount = params_ParamsConfig/* ParamConfig.INTEGER */.XC.INTEGER(8, {
      range: [0, 32],
      rangeLocked: [true, false]
    });
    this.offset = params_ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(0);
  }
}
const ImpostorUv_ParamsConfig = new ImpostorUvGlParamsConfig();
class ImpostorUvGlNode extends gl_Base/* TypedGlNode */.hD {
  constructor() {
    super(...arguments);
    this.paramsConfig = ImpostorUv_ParamsConfig;
  }
  static type() {
    return "impostorUv";
  }
  initializeNode() {
    super.initializeNode();
    this.io.outputs.setNamedOutputConnectionPoints([
      new Gl/* GlConnectionPoint */.E(ImpostorUv_OUTPUT_NAME, Gl/* GlConnectionPointType.VEC2 */.Dv.VEC2)
    ]);
  }
  setLines(shaders_collection_controller) {
    const body_lines = [];
    shaders_collection_controller.addDefinitions(this, [
      new GLDefinition/* FunctionGLDefinition */.MR(this, quaternion/* default */.Z),
      new GLDefinition/* FunctionGLDefinition */.MR(this, impostor)
    ]);
    const center = ThreeToGl/* ThreeToGl.vector3 */._.vector3(this.variableForInputParam(this.p.center));
    const cameraPos = ThreeToGl/* ThreeToGl.vector3 */._.vector3(this.variableForInputParam(this.p.cameraPos));
    const uv = ThreeToGl/* ThreeToGl.vector2 */._.vector2(this.variableForInputParam(this.p.uv));
    const tilesCount = ThreeToGl/* ThreeToGl.float */._.float(this.variableForInputParam(this.p.tilesCount));
    const offset = ThreeToGl/* ThreeToGl.float */._.float(this.variableForInputParam(this.p.offset));
    const impostor_uv = this.glVarName(ImpostorUv_OUTPUT_NAME);
    const args = [center, cameraPos, uv, tilesCount, offset].join(", ");
    body_lines.push(`vec2 ${impostor_uv} = impostor_uv(${args})`);
    shaders_collection_controller.addBodyLines(this, body_lines);
  }
}

// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/core/geometry/Attribute.ts
var geometry_Attribute = __webpack_require__(32558);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/core/geometry/Instancer.ts
var Instancer = __webpack_require__(23786);
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/gl/InstanceTransform.ts









const VARS = {
  position: geometry_Attribute/* Attribute.POSITION */.ah.POSITION,
  normal: geometry_Attribute/* Attribute.NORMAL */.ah.NORMAL,
  instancePosition: Instancer/* InstanceAttrib.POSITION */.R.POSITION,
  instanceQuaternion: Instancer/* InstanceAttrib.QUATERNION */.R.QUATERNION,
  instanceScale: Instancer/* InstanceAttrib.SCALE */.R.SCALE
};
class InstanceTransformGlParamsConfig extends params_ParamsConfig/* NodeParamsConfig */.yI {
  constructor() {
    super(...arguments);
    this.position = params_ParamsConfig/* ParamConfig.VECTOR3 */.XC.VECTOR3([0, 0, 0]);
    this.normal = params_ParamsConfig/* ParamConfig.VECTOR3 */.XC.VECTOR3([0, 0, 1]);
    this.instancePosition = params_ParamsConfig/* ParamConfig.VECTOR3 */.XC.VECTOR3([0, 0, 0]);
    this.instanceQuaternion = params_ParamsConfig/* ParamConfig.VECTOR4 */.XC.VECTOR4([0, 0, 0, 0]);
    this.instanceScale = params_ParamsConfig/* ParamConfig.VECTOR3 */.XC.VECTOR3([1, 1, 1]);
  }
}
const InstanceTransform_ParamsConfig = new InstanceTransformGlParamsConfig();
class InstanceTransformGlNode extends gl_Base/* TypedGlNode */.hD {
  constructor() {
    super(...arguments);
    this.paramsConfig = InstanceTransform_ParamsConfig;
  }
  static type() {
    return "instanceTransform";
  }
  initializeNode() {
    super.initializeNode();
    this.io.outputs.setNamedOutputConnectionPoints([
      new Gl/* GlConnectionPoint */.E(this.gl_output_name_position(), Gl/* GlConnectionPointType.VEC3 */.Dv.VEC3),
      new Gl/* GlConnectionPoint */.E(this.gl_output_name_normal(), Gl/* GlConnectionPointType.VEC3 */.Dv.VEC3)
    ]);
  }
  setLines(shaders_collection_controller) {
    const bodyLines = [];
    const functionDeclarationLines = [];
    functionDeclarationLines.push(new GLDefinition/* FunctionGLDefinition */.MR(this, quaternion/* default */.Z));
    const inputPosition = this.io.inputs.named_input(this.p.position.name());
    const position = inputPosition ? ThreeToGl/* ThreeToGl.float */._.float(this.variableForInputParam(this.p.position)) : this._defaultPosition();
    const inputNormal = this.io.inputs.named_input(this.p.normal.name());
    const normal = inputNormal ? ThreeToGl/* ThreeToGl.float */._.float(this.variableForInputParam(this.p.normal)) : this._defaultNormal();
    const inputInstancePosition = this.io.inputs.named_input(this.p.instancePosition.name());
    const instancePosition = inputInstancePosition ? ThreeToGl/* ThreeToGl.float */._.float(this.variableForInputParam(this.p.instancePosition)) : this._defaultInstancePosition(shaders_collection_controller);
    const inputInstanceQuaternion = this.io.inputs.named_input(this.p.instanceQuaternion.name());
    const instanceQuaternion = inputInstanceQuaternion ? ThreeToGl/* ThreeToGl.float */._.float(this.variableForInputParam(this.p.instanceQuaternion)) : this._defaultInputInstanceQuaternion(shaders_collection_controller);
    const inputInstanceScale = this.io.inputs.named_input(this.p.instanceScale.name());
    const instanceScale = inputInstanceScale ? ThreeToGl/* ThreeToGl.float */._.float(this.variableForInputParam(this.p.instanceScale)) : this._defaultInputInstanceScale(shaders_collection_controller);
    const resultPosition = this.glVarName(this.gl_output_name_position());
    const resultNormal = this.glVarName(this.gl_output_name_normal());
    bodyLines.push(`vec3 ${resultPosition} = vec3(${position})`);
    bodyLines.push(`${resultPosition} *= ${instanceScale}`);
    bodyLines.push(`${resultPosition} = rotateWithQuat( ${resultPosition}, ${instanceQuaternion} )`);
    bodyLines.push(`${resultPosition} += ${instancePosition}`);
    bodyLines.push(`vec3 ${resultNormal} = vec3(${normal})`);
    bodyLines.push(`${resultNormal} = rotateWithQuat( ${resultNormal}, ${instanceQuaternion} )`);
    shaders_collection_controller.addBodyLines(this, bodyLines);
    shaders_collection_controller.addDefinitions(this, functionDeclarationLines);
  }
  gl_output_name_position() {
    return "position";
  }
  gl_output_name_normal() {
    return "normal";
  }
  _defaultPosition() {
    return VARS.position;
  }
  _defaultNormal() {
    return VARS.normal;
  }
  _defaultInstancePosition(shaders_collection_controller) {
    var _a;
    const assembler = shaders_collection_controller.assembler();
    return (_a = assembler.globalsHandler()) == null ? void 0 : _a.readAttribute(this, Gl/* GlConnectionPointType.VEC3 */.Dv.VEC3, VARS.instancePosition, shaders_collection_controller);
  }
  _defaultInputInstanceQuaternion(shaders_collection_controller) {
    var _a;
    const assembler = shaders_collection_controller.assembler();
    return (_a = assembler.globalsHandler()) == null ? void 0 : _a.readAttribute(this, Gl/* GlConnectionPointType.VEC4 */.Dv.VEC4, VARS.instanceQuaternion, shaders_collection_controller);
  }
  _defaultInputInstanceScale(shaders_collection_controller) {
    var _a;
    const assembler = shaders_collection_controller.assembler();
    return (_a = assembler.globalsHandler()) == null ? void 0 : _a.readAttribute(this, Gl/* GlConnectionPointType.VEC3 */.Dv.VEC3, VARS.instanceScale, shaders_collection_controller);
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/gl/InverseTransformDirection.ts






const InverseTransformDirection_OUTPUT_NAME = "normal";
class InverseTransformDirectionGlParamsConfig extends params_ParamsConfig/* NodeParamsConfig */.yI {
  constructor() {
    super(...arguments);
    this.normal = params_ParamsConfig/* ParamConfig.VECTOR3 */.XC.VECTOR3([0, 1, 0]);
  }
}
const InverseTransformDirection_ParamsConfig = new InverseTransformDirectionGlParamsConfig();
class InverseTransformDirectionGlNode extends gl_Base/* TypedGlNode */.hD {
  constructor() {
    super(...arguments);
    this.paramsConfig = InverseTransformDirection_ParamsConfig;
  }
  static type() {
    return "inverseTransformDirection";
  }
  initializeNode() {
    super.initializeNode();
    this.io.outputs.setNamedOutputConnectionPoints([
      new Gl/* GlConnectionPoint */.E(InverseTransformDirection_OUTPUT_NAME, Gl/* GlConnectionPointType.VEC3 */.Dv.VEC3)
    ]);
  }
  setLines(linesController) {
    if (linesController.currentShaderName() == ShaderName/* ShaderName.VERTEX */.k.VERTEX) {
      const input = ThreeToGl/* ThreeToGl.vector3 */._.vector3(this.variableForInputParam(this.p.normal));
      const outValue = this.glVarName(InverseTransformDirection_OUTPUT_NAME);
      const bodyLine = `vec3 ${outValue} = inverseTransformDirection(${input}, modelMatrix)`;
      linesController.addBodyLines(this, [bodyLine], ShaderName/* ShaderName.VERTEX */.k.VERTEX);
    }
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/gl/Length.ts



class LengthGlNode extends BaseNodeGlMathFunctionArg1GlNode {
  static type() {
    return "length";
  }
  initializeNode() {
    super.initializeNode();
    this.io.connection_points.set_input_name_function(this._gl_input_name.bind(this));
    this.io.connection_points.set_expected_output_types_function(this._expected_output_types.bind(this));
  }
  _gl_input_name(index) {
    return ["x"][index];
  }
  gl_method_name() {
    return "length";
  }
  _expected_output_types() {
    return [Gl/* GlConnectionPointType.FLOAT */.Dv.FLOAT];
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/gl/Luminance.ts






const Luminance_OUTPUT_NAME = "lum";

class LuminanceGlParamsConfig extends params_ParamsConfig/* NodeParamsConfig */.yI {
  constructor() {
    super(...arguments);
    this.color = params_ParamsConfig/* ParamConfig.VECTOR3 */.XC.VECTOR3([1, 1, 1]);
  }
}
const Luminance_ParamsConfig = new LuminanceGlParamsConfig();
class LuminanceGlNode extends gl_Base/* TypedGlNode */.hD {
  constructor() {
    super(...arguments);
    this.paramsConfig = Luminance_ParamsConfig;
  }
  static type() {
    return "luminance";
  }
  initializeNode() {
    super.initializeNode();
    this.io.outputs.setNamedOutputConnectionPoints([
      new Gl/* GlConnectionPoint */.E(Luminance_OUTPUT_NAME, Gl/* GlConnectionPointType.FLOAT */.Dv.FLOAT)
    ]);
  }
  setLines(shadersCollectionController) {
    const value = ThreeToGl/* ThreeToGl.vector3 */._.vector3(this.variableForInputParam(this.p.color));
    const lum = this.glVarName(Luminance_OUTPUT_NAME);
    const bodyLine = `float ${lum} = luminance(${value})`;
    shadersCollectionController.addBodyLines(this, [bodyLine]);
    shadersCollectionController.addDefinitions(this, [new GLDefinition/* FunctionGLDefinition */.MR(this, fit)]);
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/gl/gl/max_length.glsl
/* harmony default export */ var max_length = ("//\n//\n// CLAMP_LENGTH\n//\n//\nfloat maxLength(float val, float max_l){\n\treturn min(val, max_l);\n}\nvec2 maxLength(vec2 val, float max_l){\n\tfloat vec_length = length(val);\n\tif(vec_length == 0.0){\n\t\treturn val;\n\t} else {\n\t\tfloat new_length = min(vec_length, max_l);\n\t\treturn new_length * normalize(val);\n\t}\n}\nvec3 maxLength(vec3 val, float max_l){\n\tfloat vec_length = length(val);\n\tif(vec_length == 0.0){\n\t\treturn val;\n\t} else {\n\t\tfloat new_length = min(vec_length, max_l);\n\t\treturn new_length * normalize(val);\n\t}\n}\nvec4 maxLength(vec4 val, float max_l){\n\tfloat vec_length = length(val);\n\tif(vec_length == 0.0){\n\t\treturn val;\n\t} else {\n\t\tfloat new_length = min(vec_length, max_l);\n\t\treturn new_length * normalize(val);\n\t}\n}\n");
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/gl/MaxLength.ts





const MaxLengthDefaultValues = {
  max: 1
};
class MaxLengthGlNode extends BaseNodeGlMathFunctionArg2GlNode {
  static type() {
    return "maxLength";
  }
  _expected_input_types() {
    const type = this.io.connection_points.first_input_connection_type() || Gl/* GlConnectionPointType.VEC3 */.Dv.VEC3;
    return [type, Gl/* GlConnectionPointType.FLOAT */.Dv.FLOAT];
  }
  _gl_input_name(index) {
    return ["val", "max"][index];
  }
  paramDefaultValue(name) {
    return MaxLengthDefaultValues[name];
  }
  gl_method_name() {
    return "maxLength";
  }
  gl_function_definitions() {
    return [new GLDefinition/* FunctionGLDefinition */.MR(this, max_length)];
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/gl/Mix.ts



const Mix_DefaultValues = {
  blend: 0.5
};
class MixGlNode extends BaseGlMathFunctionGlNode {
  static type() {
    return "mix";
  }
  gl_method_name() {
    return "mix";
  }
  paramDefaultValue(name) {
    return Mix_DefaultValues[name];
  }
  initializeNode() {
    super.initializeNode();
    this.io.connection_points.set_input_name_function((index) => ["value0", "value1", "blend"][index]);
    this.io.connection_points.set_output_name_function(this._gl_output_name.bind(this));
    this.io.connection_points.set_expected_input_types_function(this._expected_input_types.bind(this));
    this.io.connection_points.set_expected_output_types_function(this._expected_output_types.bind(this));
  }
  _gl_output_name() {
    return "mix";
  }
  _expected_input_types() {
    const type = this.io.connection_points.first_input_connection_type() || Gl/* GlConnectionPointType.FLOAT */.Dv.FLOAT;
    return [type, type, Gl/* GlConnectionPointType.FLOAT */.Dv.FLOAT];
  }
  _expected_output_types() {
    const type = this._expected_input_types()[0];
    return [type];
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/gl/ModelMatrixMult.ts






const ModelMatrixMult_OUTPUT_NAME = "mvMult";
class ModelMatrixMultGlParamsConfig extends params_ParamsConfig/* NodeParamsConfig */.yI {
  constructor() {
    super(...arguments);
    this.vector = params_ParamsConfig/* ParamConfig.VECTOR3 */.XC.VECTOR3([0, 0, 0]);
  }
}
const ModelMatrixMult_ParamsConfig = new ModelMatrixMultGlParamsConfig();
class ModelMatrixMultGlNode extends gl_Base/* TypedGlNode */.hD {
  constructor() {
    super(...arguments);
    this.paramsConfig = ModelMatrixMult_ParamsConfig;
  }
  static type() {
    return "modelMatrixMult";
  }
  initializeNode() {
    super.initializeNode();
    this.io.outputs.setNamedOutputConnectionPoints([
      new Gl/* GlConnectionPoint */.E(ModelMatrixMult_OUTPUT_NAME, Gl/* GlConnectionPointType.VEC4 */.Dv.VEC4)
    ]);
  }
  setLines(linesController) {
    if (linesController.currentShaderName() == ShaderName/* ShaderName.VERTEX */.k.VERTEX) {
      const input = ThreeToGl/* ThreeToGl.vector3 */._.vector3(this.variableForInputParam(this.p.vector));
      const outValue = this.glVarName(ModelMatrixMult_OUTPUT_NAME);
      const bodyLine = `vec4 ${outValue} = modelMatrix * vec4(${input}, 1.0)`;
      linesController.addBodyLines(this, [bodyLine], ShaderName/* ShaderName.VERTEX */.k.VERTEX);
    }
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/gl/ModelViewMatrixMult.ts






const ModelViewMatrixMult_OUTPUT_NAME = "mvMult";
class ModelViewMatrixMultGlParamsConfig extends params_ParamsConfig/* NodeParamsConfig */.yI {
  constructor() {
    super(...arguments);
    this.vector = params_ParamsConfig/* ParamConfig.VECTOR3 */.XC.VECTOR3([0, 0, 0]);
  }
}
const ModelViewMatrixMult_ParamsConfig = new ModelViewMatrixMultGlParamsConfig();
class ModelViewMatrixMultGlNode extends gl_Base/* TypedGlNode */.hD {
  constructor() {
    super(...arguments);
    this.paramsConfig = ModelViewMatrixMult_ParamsConfig;
  }
  static type() {
    return "modelViewMatrixMult";
  }
  initializeNode() {
    super.initializeNode();
    this.io.outputs.setNamedOutputConnectionPoints([
      new Gl/* GlConnectionPoint */.E(ModelViewMatrixMult_OUTPUT_NAME, Gl/* GlConnectionPointType.VEC4 */.Dv.VEC4)
    ]);
  }
  setLines(linesController) {
    if (linesController.currentShaderName() == ShaderName/* ShaderName.VERTEX */.k.VERTEX) {
      const input = ThreeToGl/* ThreeToGl.vector3 */._.vector3(this.variableForInputParam(this.p.vector));
      const outValue = this.glVarName(ModelViewMatrixMult_OUTPUT_NAME);
      const bodyLine = `vec4 ${outValue} = modelViewMatrix * vec4(${input}, 1.0)`;
      linesController.addBodyLines(this, [bodyLine], ShaderName/* ShaderName.VERTEX */.k.VERTEX);
    }
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/gl/MultAdd.ts



const MultAdd_DefaultValues = {
  mult: 1
};
var MultAddGlNodeInputName = /* @__PURE__ */ ((MultAddGlNodeInputName2) => {
  MultAddGlNodeInputName2["VALUE"] = "value";
  MultAddGlNodeInputName2["PRE_ADD"] = "preAdd";
  MultAddGlNodeInputName2["MULT"] = "mult";
  MultAddGlNodeInputName2["POST_ADD"] = "postAdd";
  return MultAddGlNodeInputName2;
})(MultAddGlNodeInputName || {});
class MultAddGlNode extends BaseNodeGlMathFunctionArg4GlNode {
  static type() {
    return "multAdd";
  }
  _gl_input_name(index) {
    return [
      "value" /* VALUE */,
      "preAdd" /* PRE_ADD */,
      "mult" /* MULT */,
      "postAdd" /* POST_ADD */
    ][index];
  }
  paramDefaultValue(name) {
    return MultAdd_DefaultValues[name];
  }
  setLines(shaders_collection_controller) {
    const ouputConnectionPoints = this.io.outputs.namedOutputConnectionPoints();
    if (!ouputConnectionPoints) {
      return;
    }
    const value = ThreeToGl/* ThreeToGl.any */._.any(this.variableForInput("value" /* VALUE */));
    const preAdd = ThreeToGl/* ThreeToGl.any */._.any(this.variableForInput("preAdd" /* PRE_ADD */));
    const mult = ThreeToGl/* ThreeToGl.any */._.any(this.variableForInput("mult" /* MULT */));
    const postAdd = ThreeToGl/* ThreeToGl.any */._.any(this.variableForInput("postAdd" /* POST_ADD */));
    const gl_type = this._expected_output_types()[0];
    const out_name = ouputConnectionPoints[0].name();
    const out = this.glVarName(out_name);
    const body_line = `${gl_type} ${out} = (${mult}*(${value} + ${preAdd})) + ${postAdd}`;
    shaders_collection_controller.addBodyLines(this, [body_line]);
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/gl/MultScalar.ts




const MultScalar_DefaultValues = {
  value: 1,
  mult: 1
};
var MultScalarGlNodeInputName = /* @__PURE__ */ ((MultScalarGlNodeInputName2) => {
  MultScalarGlNodeInputName2["VALUE"] = "value";
  MultScalarGlNodeInputName2["MULT"] = "mult";
  return MultScalarGlNodeInputName2;
})(MultScalarGlNodeInputName || {});
class MultScalarGlNode extends BaseNodeGlMathFunctionArg2GlNode {
  static type() {
    return "multScalar";
  }
  _expected_input_types() {
    const type = this.io.connection_points.first_input_connection_type() || Gl/* GlConnectionPointType.VEC3 */.Dv.VEC3;
    return [type, Gl/* GlConnectionPointType.FLOAT */.Dv.FLOAT];
  }
  _gl_input_name(index) {
    return ["value" /* VALUE */, "mult" /* MULT */][index];
  }
  paramDefaultValue(name) {
    return MultScalar_DefaultValues[name];
  }
  setLines(shaders_collection_controller) {
    const outputConnectionPoints = this.io.outputs.namedOutputConnectionPoints();
    if (!outputConnectionPoints) {
      return;
    }
    const value = ThreeToGl/* ThreeToGl.any */._.any(this.variableForInput("value" /* VALUE */));
    const mult = ThreeToGl/* ThreeToGl.any */._.any(this.variableForInput("mult" /* MULT */));
    const gl_type = this._expected_output_types()[0];
    const out_name = outputConnectionPoints[0].name();
    const out = this.glVarName(out_name);
    const body_line = `${gl_type} ${out} = (${mult}*${value})`;
    shaders_collection_controller.addBodyLines(this, [body_line]);
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/gl/code/utils/ConnectionsUtils.ts


function glConnectionType(connection) {
  const connectionPoints = connection.nodeSrc().io.outputs.namedOutputConnectionPoints();
  return connectionPoints ? connectionPoints[connection.outputIndex()].type() : Gl/* GlConnectionPointType.FLOAT */.Dv.FLOAT;
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/gl/MultVectorMatrix.ts







const DEFAULT_INPUT_TYPES = [Gl/* GlConnectionPointType.VEC4 */.Dv.VEC4, Gl/* GlConnectionPointType.MAT4 */.Dv.MAT4];
class MultVectorMatrixGlParamsConfig extends params_ParamsConfig/* NodeParamsConfig */.yI {
}
const MultVectorMatrix_ParamsConfig = new MultVectorMatrixGlParamsConfig();
class MultVectorMatrixGlNode extends gl_Base/* TypedGlNode */.hD {
  constructor() {
    super(...arguments);
    this.paramsConfig = MultVectorMatrix_ParamsConfig;
  }
  static type() {
    return "multVectorMatrix";
  }
  initializeNode() {
    super.initializeNode();
    this.io.connection_points.set_expected_input_types_function(this._expectedInputTypes.bind(this));
    this.io.connection_points.set_expected_output_types_function(this._expectedOutputTypes.bind(this));
    this.io.connection_points.set_input_name_function(this._glInputName.bind(this));
    this.io.connection_points.set_output_name_function(this._glOutputName.bind(this));
  }
  _expectedInputTypes() {
    const inputConnections = this.io.connections.existingInputConnections();
    if (!inputConnections) {
      return DEFAULT_INPUT_TYPES;
    }
    const connection0 = inputConnections[0];
    if (!connection0) {
      return DEFAULT_INPUT_TYPES;
    }
    const type0 = glConnectionType(connection0);
    const connection1 = inputConnections[1];
    const type1 = connection1 ? glConnectionType(connection1) : Gl/* GlConnectionPointType.MAT4 */.Dv.MAT4;
    switch (type0) {
      case Gl/* GlConnectionPointType.VEC4 */.Dv.VEC4: {
        return [type0, type1];
      }
      case Gl/* GlConnectionPointType.VEC3 */.Dv.VEC3: {
        return [type0, type1];
      }
      default: {
        return DEFAULT_INPUT_TYPES;
      }
    }
  }
  _expectedOutputTypes() {
    return [this._expectedInputTypes()[0]];
  }
  _glInputName(index) {
    return this._expectedInputTypes()[index];
  }
  _glOutputName(index) {
    return this._expectedOutputTypes()[index];
  }
  setLines(linesController) {
    const inputVec = ThreeToGl/* ThreeToGl.mat4 */._.mat4(this.variableForInput(this._glInputName(0)));
    const inputMat = ThreeToGl/* ThreeToGl.mat4 */._.mat4(this.variableForInput(this._glInputName(1)));
    const outValue = this.glVarName(this._glOutputName(0));
    const outType = this._expectedOutputTypes()[0];
    const bodyLine = `${outType} ${outValue} = ${inputMat} * ${inputVec}`;
    linesController.addBodyLines(this, [bodyLine], ShaderName/* ShaderName.VERTEX */.k.VERTEX);
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/gl/Negate.ts



class NegateGlNode extends BaseNodeGlMathFunctionArg1GlNode {
  static type() {
    return "negate";
  }
  initializeNode() {
    super.initializeNode();
    this.io.connection_points.set_input_name_function((index) => ["in"][index]);
  }
  _gl_input_name(index) {
    return ["in"][index];
  }
  setLines(shaders_collection_controller) {
    const connectionPoints = this.io.inputs.namedInputConnectionPoints();
    if (!connectionPoints) {
      return;
    }
    const in_value = ThreeToGl/* ThreeToGl.any */._.any(this.variableForInput(this._gl_input_name(0)));
    const gl_type = connectionPoints[0].type();
    const out = this.glVarName(this.io.connection_points.output_name(0));
    const body_line = `${gl_type} ${out} = -1.0 * ${in_value}`;
    shaders_collection_controller.addBodyLines(this, [body_line]);
  }
}

// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/nodes/gl/NeighbourAttract.ts + 1 modules
var NeighbourAttract = __webpack_require__(48134);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/nodes/gl/NeighbourAttractRepulse.ts + 1 modules
var NeighbourAttractRepulse = __webpack_require__(47166);
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/gl/gl/neighbour/attribSmooth.glsl
/* harmony default export */ var attribSmooth = ("\n\nfloat __FUNCTION__NAME__(\n\tsampler2D texturePosition,\n\tvec2 particleUv,\n\tvec3 currentPosition,\n\t// attribSmooth\n\tsampler2D textureAttribute,\n\tfloat currentAttributeValue,\n\tfloat maxDist,\n\tfloat deltaThreshold,\n\tfloat smoothAmount\n\t){\n\n\tvec3 otherPosition;\n\tfloat dist, delta, otherAttribute;\n\tfloat neighbourCount = 0.0;\n\tfloat offset = 0.0;\n\n\tconst float width = resolution.x;\n\tconst float height = resolution.y;\n\tfor ( float y = 0.0; y < height; y++ ) {\n\t\tfor ( float x = 0.0; x < width; x++ ) {\n\n\t\t\t// ignore if this is self\n\t\t\tif(x == particleUv.x && y == particleUv.y) continue;\n\n\t\t\tvec2 ref = vec2( x + 0.5, y + 0.5 ) / resolution.xy;\n\t\t\totherPosition = texture2D( texturePosition, ref ).__COMPONENT__;\n\t\t\totherAttribute = texture2D( textureAttribute, ref ).__COMPONENT_ATTRIB__;\n\t\t\tdist = distance( otherPosition, currentPosition );\n\n\t\t\tif(dist < maxDist){\n\t\t\t\tdelta = (otherAttribute - currentAttributeValue) / dist;\n\t\t\t\tfloat excess = abs(delta) - deltaThreshold;\n\n\t\t\t\tif(excess > 0.0){\n\t\t\t\t\toffset += (excess * smoothAmount * sign(delta)) * (1.0 - (dist / maxDist));\n\t\t\t\t\tneighbourCount++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\toffset = neighbourCount >= 1.0 ? (offset / neighbourCount) : 0.0;\n\treturn currentAttributeValue + offset;\n\n}");
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/gl/NeighbourAttribSmooth.ts







const NeighbourAttribSmooth_OUTPUT_NAME = "attrib";
class NeighbourAttribSmoothGlParamsConfig extends params_ParamsConfig/* NodeParamsConfig */.yI {
  constructor() {
    super(...arguments);
    this.positionAttribName = params_ParamsConfig/* ParamConfig.STRING */.XC.STRING("position");
    this.position = params_ParamsConfig/* ParamConfig.VECTOR3 */.XC.VECTOR3([0, 0, 0], {
      separatorAfter: true
    });
    // attribType = ParamConfig.INTEGER(GL_CONNECTION_POINT_TYPES.indexOf(GlConnectionPointType.FLOAT), {
    // 	menu: {
    // 		entries: GL_CONNECTION_POINT_TYPES.map((name, i) => {
    // 			return {name: name, value: i};
    // 		}),
    // 	},
    // 	separatorBefore: true,
    // });
    this.attribName = params_ParamsConfig/* ParamConfig.STRING */.XC.STRING("h");
    this.attribValue = params_ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(0);
    this.maxDist = params_ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(2, {
      range: [0, 10],
      rangeLocked: [true, false],
      separatorBefore: true
    });
    this.deltaThreshold = params_ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(1, {
      range: [0, 1],
      rangeLocked: [true, false]
    });
    this.smoothAmount = params_ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(1, {
      range: [0, 1],
      rangeLocked: [true, false]
    });
  }
}
const NeighbourAttribSmooth_ParamsConfig = new NeighbourAttribSmoothGlParamsConfig();
class NeighbourAttribSmoothGlNode extends gl_Base/* TypedGlNode */.hD {
  constructor() {
    super(...arguments);
    this.paramsConfig = NeighbourAttribSmooth_ParamsConfig;
  }
  static type() {
    return "neighbourAttribSmooth";
  }
  initializeNode() {
    super.initializeNode();
    this.io.outputs.setNamedOutputConnectionPoints([
      new Gl/* GlConnectionPoint */.E(NeighbourAttribSmooth_OUTPUT_NAME, Gl/* GlConnectionPointType.FLOAT */.Dv.FLOAT)
    ]);
  }
  setLines(shadersCollectionController) {
    const bodyLines = [];
    const position = ThreeToGl/* ThreeToGl.vector3 */._.vector3(this.variableForInputParam(this.p.position));
    const maxDist = ThreeToGl/* ThreeToGl.float */._.float(this.variableForInputParam(this.p.maxDist));
    const attribValue = ThreeToGl/* ThreeToGl.float */._.float(this.variableForInputParam(this.p.attribValue));
    const deltaThreshold = ThreeToGl/* ThreeToGl.float */._.float(this.variableForInputParam(this.p.deltaThreshold));
    const smoothAmount = ThreeToGl/* ThreeToGl.float */._.float(this.variableForInputParam(this.p.smoothAmount));
    const out = this.glVarName(NeighbourAttribSmooth_OUTPUT_NAME);
    const assembler = shadersCollectionController.assembler();
    const globalsHandler = assembler.globalsHandler();
    if (!globalsHandler) {
      return;
    }
    if (globalsHandler.attribTextureData) {
      const globalsTextureHandler = globalsHandler;
      const positionTextureData = globalsTextureHandler.attribTextureData(this.pv.positionAttribName);
      const attribTextureData = globalsTextureHandler.attribTextureData(this.pv.attribName);
      if (positionTextureData && attribTextureData) {
        const { textureName, uvName } = positionTextureData;
        const attribTextureName = attribTextureData.textureName;
        const attribComponent = attribTextureData.component;
        const positionComponent = positionTextureData.component;
        const args = [
          textureName,
          uvName,
          position,
          // smooth
          attribTextureName,
          attribValue,
          maxDist,
          deltaThreshold,
          smoothAmount
        ].join(", ");
        const { functionName, functionDeclaration } = this._templateFunctionDefinition({
          positionComponent,
          attribComponent
        });
        shadersCollectionController.addDefinitions(this, [new GLDefinition/* FunctionGLDefinition */.MR(this, functionDeclaration)]);
        bodyLines.push(`float ${out} = ${functionName}(${args})`);
      }
    }
    shadersCollectionController.addBodyLines(this, bodyLines);
  }
  _templateFunctionDefinition(options) {
    const functionName = `${this.type()}${this.graphNodeId()}`;
    const functionDeclaration = attribSmooth.replace("__FUNCTION__NAME__", functionName).replace("__COMPONENT__", options.positionComponent).replace("__COMPONENT_ATTRIB__", options.attribComponent);
    return {
      functionName,
      functionDeclaration
    };
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/gl/gl/neighbour/density.glsl
/* harmony default export */ var density = ("\n\nfloat __FUNCTION__NAME__(\n\tsampler2D texturePosition,\n\tvec2 particleUv,\n\tvec3 currentPosition,\n\t// density\n\tfloat maxDist\n\t){\n\n\tvec3 otherPosition;\n\tfloat dist;\n\n\tfloat density = 0.;\n\tfloat range = abs(maxDist);\n\n\tconst float width = resolution.x;\n\tconst float height = resolution.y;\n\tfor ( float y = 0.0; y < height; y++ ) {\n\t\tfor ( float x = 0.0; x < width; x++ ) {\n\n\t\t\t// ignore if this is self\n\t\t\tif(x == particleUv.x && y == particleUv.y) continue;\n\n\t\t\tvec2 ref = vec2( x + 0.5, y + 0.5 ) / resolution.xy;\n\t\t\totherPosition = texture2D( texturePosition, ref ).__COMPONENT__;\n\n\t\t\tdist = distance( otherPosition, currentPosition );\n\n\t\t\tif(dist < maxDist){\n\t\t\t\tfloat weight = 1.0 - dist / range;\n\t\t\t\tdensity += weight;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn density;\n\n}");
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/gl/NeighbourDensity.ts







const NeighbourDensity_OUTPUT_NAME = "density";
class NeighbourDensityGlParamsConfig extends params_ParamsConfig/* NodeParamsConfig */.yI {
  constructor() {
    super(...arguments);
    this.positionAttribName = params_ParamsConfig/* ParamConfig.STRING */.XC.STRING("position");
    this.position = params_ParamsConfig/* ParamConfig.VECTOR3 */.XC.VECTOR3([0, 0, 0]);
    this.maxDist = params_ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(2, {
      range: [0, 10],
      rangeLocked: [true, false]
    });
  }
}
const NeighbourDensity_ParamsConfig = new NeighbourDensityGlParamsConfig();
class NeighbourDensityGlNode extends gl_Base/* TypedGlNode */.hD {
  constructor() {
    super(...arguments);
    this.paramsConfig = NeighbourDensity_ParamsConfig;
  }
  static type() {
    return "neighbourDensity";
  }
  initializeNode() {
    super.initializeNode();
    this.io.outputs.setNamedOutputConnectionPoints([
      new Gl/* GlConnectionPoint */.E(NeighbourDensity_OUTPUT_NAME, Gl/* GlConnectionPointType.FLOAT */.Dv.FLOAT)
    ]);
  }
  setLines(shadersCollectionController) {
    const bodyLines = [];
    const position = ThreeToGl/* ThreeToGl.vector3 */._.vector3(this.variableForInputParam(this.p.position));
    const maxDist = ThreeToGl/* ThreeToGl.float */._.float(this.variableForInputParam(this.p.maxDist));
    const out = this.glVarName(NeighbourDensity_OUTPUT_NAME);
    const assembler = shadersCollectionController.assembler();
    const globalsHandler = assembler.globalsHandler();
    if (!globalsHandler) {
      return;
    }
    if (globalsHandler.attribTextureData) {
      const globalsTextureHandler = globalsHandler;
      const textureData = globalsTextureHandler.attribTextureData(this.pv.positionAttribName);
      if (textureData) {
        const { textureName, component, uvName } = textureData;
        const args = [
          textureName,
          uvName,
          position,
          // density
          maxDist
        ].join(", ");
        const { functionName, functionDeclaration } = this._templateFunctionDefinition(component);
        shadersCollectionController.addDefinitions(this, [new GLDefinition/* FunctionGLDefinition */.MR(this, functionDeclaration)]);
        bodyLines.push(`float ${out} = ${functionName}(${args})`);
      }
    }
    shadersCollectionController.addBodyLines(this, bodyLines);
  }
  _templateFunctionDefinition(component) {
    const functionName = `${this.type()}${this.graphNodeId()}`;
    const functionDeclaration = density.replace("__FUNCTION__NAME__", functionName).replace(
      "__COMPONENT__",
      component
    );
    return {
      functionName,
      functionDeclaration
    };
  }
}

// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/nodes/gl/NeighbourRepulse.ts + 1 modules
var NeighbourRepulse = __webpack_require__(66511);
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/gl/gl/noise/common.glsl
/* harmony default export */ var common = ("// Modulo 289 without a division (only multiplications)\nfloat mod289(float x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\nvec2 mod289(vec2 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\nvec3 mod289(vec3 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\nvec4 mod289(vec4 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n// Modulo 7 without a division\nvec3 mod7(vec3 x) {\n  return x - floor(x * (1.0 / 7.0)) * 7.0;\n}\n\n// Permutation polynomial: (34x^2 + x) mod 289\nfloat permute(float x) {\n     return mod289(((x*34.0)+1.0)*x);\n}\nvec3 permute(vec3 x) {\n  return mod289((34.0 * x + 1.0) * x);\n}\nvec4 permute(vec4 x) {\n     return mod289(((x*34.0)+1.0)*x);\n}\n\nfloat taylorInvSqrt(float r)\n{\n  return 1.79284291400159 - 0.85373472095314 * r;\n}\nvec4 taylorInvSqrt(vec4 r)\n{\n  return 1.79284291400159 - 0.85373472095314 * r;\n}\n\nvec2 fade(vec2 t) {\n  return t*t*t*(t*(t*6.0-15.0)+10.0);\n}\nvec3 fade(vec3 t) {\n  return t*t*t*(t*(t*6.0-15.0)+10.0);\n}\nvec4 fade(vec4 t) {\n  return t*t*t*(t*(t*6.0-15.0)+10.0);\n}");
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/gl/gl/noise/classicnoise2D.glsl
/* harmony default export */ var classicnoise2D = ("//\n// GLSL textureless classic 2D noise \"cnoise\",\n// with an RSL-style periodic variant \"pnoise\".\n// Author:  Stefan Gustavson (stefan.gustavson@liu.se)\n// Version: 2011-08-22\n//\n// Many thanks to Ian McEwan of Ashima Arts for the\n// ideas for permutation and gradient selection.\n//\n// Copyright (c) 2011 Stefan Gustavson. All rights reserved.\n// Distributed under the MIT license. See LICENSE file.\n// https://github.com/stegu/webgl-noise\n//\n\n\n// Classic Perlin noise\nfloat cnoise(vec2 P)\n{\n  vec4 Pi = floor(P.xyxy) + vec4(0.0, 0.0, 1.0, 1.0);\n  vec4 Pf = fract(P.xyxy) - vec4(0.0, 0.0, 1.0, 1.0);\n  Pi = mod289(Pi); // To avoid truncation effects in permutation\n  vec4 ix = Pi.xzxz;\n  vec4 iy = Pi.yyww;\n  vec4 fx = Pf.xzxz;\n  vec4 fy = Pf.yyww;\n\n  vec4 i = permute(permute(ix) + iy);\n\n  vec4 gx = fract(i * (1.0 / 41.0)) * 2.0 - 1.0 ;\n  vec4 gy = abs(gx) - 0.5 ;\n  vec4 tx = floor(gx + 0.5);\n  gx = gx - tx;\n\n  vec2 g00 = vec2(gx.x,gy.x);\n  vec2 g10 = vec2(gx.y,gy.y);\n  vec2 g01 = vec2(gx.z,gy.z);\n  vec2 g11 = vec2(gx.w,gy.w);\n\n  vec4 norm = taylorInvSqrt(vec4(dot(g00, g00), dot(g01, g01), dot(g10, g10), dot(g11, g11)));\n  g00 *= norm.x;  \n  g01 *= norm.y;  \n  g10 *= norm.z;  \n  g11 *= norm.w;  \n\n  float n00 = dot(g00, vec2(fx.x, fy.x));\n  float n10 = dot(g10, vec2(fx.y, fy.y));\n  float n01 = dot(g01, vec2(fx.z, fy.z));\n  float n11 = dot(g11, vec2(fx.w, fy.w));\n\n  vec2 fade_xy = fade(Pf.xy);\n  vec2 n_x = mix(vec2(n00, n01), vec2(n10, n11), fade_xy.x);\n  float n_xy = mix(n_x.x, n_x.y, fade_xy.y);\n  return 2.3 * n_xy;\n}\n\n// Classic Perlin noise, periodic variant\nfloat pnoise(vec2 P, vec2 rep)\n{\n  vec4 Pi = floor(P.xyxy) + vec4(0.0, 0.0, 1.0, 1.0);\n  vec4 Pf = fract(P.xyxy) - vec4(0.0, 0.0, 1.0, 1.0);\n  Pi = mod(Pi, rep.xyxy); // To create noise with explicit period\n  Pi = mod289(Pi);        // To avoid truncation effects in permutation\n  vec4 ix = Pi.xzxz;\n  vec4 iy = Pi.yyww;\n  vec4 fx = Pf.xzxz;\n  vec4 fy = Pf.yyww;\n\n  vec4 i = permute(permute(ix) + iy);\n\n  vec4 gx = fract(i * (1.0 / 41.0)) * 2.0 - 1.0 ;\n  vec4 gy = abs(gx) - 0.5 ;\n  vec4 tx = floor(gx + 0.5);\n  gx = gx - tx;\n\n  vec2 g00 = vec2(gx.x,gy.x);\n  vec2 g10 = vec2(gx.y,gy.y);\n  vec2 g01 = vec2(gx.z,gy.z);\n  vec2 g11 = vec2(gx.w,gy.w);\n\n  vec4 norm = taylorInvSqrt(vec4(dot(g00, g00), dot(g01, g01), dot(g10, g10), dot(g11, g11)));\n  g00 *= norm.x;  \n  g01 *= norm.y;  \n  g10 *= norm.z;  \n  g11 *= norm.w;  \n\n  float n00 = dot(g00, vec2(fx.x, fy.x));\n  float n10 = dot(g10, vec2(fx.y, fy.y));\n  float n01 = dot(g01, vec2(fx.z, fy.z));\n  float n11 = dot(g11, vec2(fx.w, fy.w));\n\n  vec2 fade_xy = fade(Pf.xy);\n  vec2 n_x = mix(vec2(n00, n01), vec2(n10, n11), fade_xy.x);\n  float n_xy = mix(n_x.x, n_x.y, fade_xy.y);\n  return 2.3 * n_xy;\n}\n");
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/gl/gl/noise/classicnoise3D.glsl
/* harmony default export */ var classicnoise3D = ("//\n// GLSL textureless classic 3D noise \"cnoise\",\n// with an RSL-style periodic variant \"pnoise\".\n// Author:  Stefan Gustavson (stefan.gustavson@liu.se)\n// Version: 2011-10-11\n//\n// Many thanks to Ian McEwan of Ashima Arts for the\n// ideas for permutation and gradient selection.\n//\n// Copyright (c) 2011 Stefan Gustavson. All rights reserved.\n// Distributed under the MIT license. See LICENSE file.\n// https://github.com/stegu/webgl-noise\n//\n\n// Classic Perlin noise\nfloat cnoise(vec3 P)\n{\n  vec3 Pi0 = floor(P); // Integer part for indexing\n  vec3 Pi1 = Pi0 + vec3(1.0); // Integer part + 1\n  Pi0 = mod289(Pi0);\n  Pi1 = mod289(Pi1);\n  vec3 Pf0 = fract(P); // Fractional part for interpolation\n  vec3 Pf1 = Pf0 - vec3(1.0); // Fractional part - 1.0\n  vec4 ix = vec4(Pi0.x, Pi1.x, Pi0.x, Pi1.x);\n  vec4 iy = vec4(Pi0.yy, Pi1.yy);\n  vec4 iz0 = Pi0.zzzz;\n  vec4 iz1 = Pi1.zzzz;\n\n  vec4 ixy = permute(permute(ix) + iy);\n  vec4 ixy0 = permute(ixy + iz0);\n  vec4 ixy1 = permute(ixy + iz1);\n\n  vec4 gx0 = ixy0 * (1.0 / 7.0);\n  vec4 gy0 = fract(floor(gx0) * (1.0 / 7.0)) - 0.5;\n  gx0 = fract(gx0);\n  vec4 gz0 = vec4(0.5) - abs(gx0) - abs(gy0);\n  vec4 sz0 = step(gz0, vec4(0.0));\n  gx0 -= sz0 * (step(0.0, gx0) - 0.5);\n  gy0 -= sz0 * (step(0.0, gy0) - 0.5);\n\n  vec4 gx1 = ixy1 * (1.0 / 7.0);\n  vec4 gy1 = fract(floor(gx1) * (1.0 / 7.0)) - 0.5;\n  gx1 = fract(gx1);\n  vec4 gz1 = vec4(0.5) - abs(gx1) - abs(gy1);\n  vec4 sz1 = step(gz1, vec4(0.0));\n  gx1 -= sz1 * (step(0.0, gx1) - 0.5);\n  gy1 -= sz1 * (step(0.0, gy1) - 0.5);\n\n  vec3 g000 = vec3(gx0.x,gy0.x,gz0.x);\n  vec3 g100 = vec3(gx0.y,gy0.y,gz0.y);\n  vec3 g010 = vec3(gx0.z,gy0.z,gz0.z);\n  vec3 g110 = vec3(gx0.w,gy0.w,gz0.w);\n  vec3 g001 = vec3(gx1.x,gy1.x,gz1.x);\n  vec3 g101 = vec3(gx1.y,gy1.y,gz1.y);\n  vec3 g011 = vec3(gx1.z,gy1.z,gz1.z);\n  vec3 g111 = vec3(gx1.w,gy1.w,gz1.w);\n\n  vec4 norm0 = taylorInvSqrt(vec4(dot(g000, g000), dot(g010, g010), dot(g100, g100), dot(g110, g110)));\n  g000 *= norm0.x;\n  g010 *= norm0.y;\n  g100 *= norm0.z;\n  g110 *= norm0.w;\n  vec4 norm1 = taylorInvSqrt(vec4(dot(g001, g001), dot(g011, g011), dot(g101, g101), dot(g111, g111)));\n  g001 *= norm1.x;\n  g011 *= norm1.y;\n  g101 *= norm1.z;\n  g111 *= norm1.w;\n\n  float n000 = dot(g000, Pf0);\n  float n100 = dot(g100, vec3(Pf1.x, Pf0.yz));\n  float n010 = dot(g010, vec3(Pf0.x, Pf1.y, Pf0.z));\n  float n110 = dot(g110, vec3(Pf1.xy, Pf0.z));\n  float n001 = dot(g001, vec3(Pf0.xy, Pf1.z));\n  float n101 = dot(g101, vec3(Pf1.x, Pf0.y, Pf1.z));\n  float n011 = dot(g011, vec3(Pf0.x, Pf1.yz));\n  float n111 = dot(g111, Pf1);\n\n  vec3 fade_xyz = fade(Pf0);\n  vec4 n_z = mix(vec4(n000, n100, n010, n110), vec4(n001, n101, n011, n111), fade_xyz.z);\n  vec2 n_yz = mix(n_z.xy, n_z.zw, fade_xyz.y);\n  float n_xyz = mix(n_yz.x, n_yz.y, fade_xyz.x); \n  return 2.2 * n_xyz;\n}\n\n// Classic Perlin noise, periodic variant\nfloat pnoise(vec3 P, vec3 rep)\n{\n  vec3 Pi0 = mod(floor(P), rep); // Integer part, modulo period\n  vec3 Pi1 = mod(Pi0 + vec3(1.0), rep); // Integer part + 1, mod period\n  Pi0 = mod289(Pi0);\n  Pi1 = mod289(Pi1);\n  vec3 Pf0 = fract(P); // Fractional part for interpolation\n  vec3 Pf1 = Pf0 - vec3(1.0); // Fractional part - 1.0\n  vec4 ix = vec4(Pi0.x, Pi1.x, Pi0.x, Pi1.x);\n  vec4 iy = vec4(Pi0.yy, Pi1.yy);\n  vec4 iz0 = Pi0.zzzz;\n  vec4 iz1 = Pi1.zzzz;\n\n  vec4 ixy = permute(permute(ix) + iy);\n  vec4 ixy0 = permute(ixy + iz0);\n  vec4 ixy1 = permute(ixy + iz1);\n\n  vec4 gx0 = ixy0 * (1.0 / 7.0);\n  vec4 gy0 = fract(floor(gx0) * (1.0 / 7.0)) - 0.5;\n  gx0 = fract(gx0);\n  vec4 gz0 = vec4(0.5) - abs(gx0) - abs(gy0);\n  vec4 sz0 = step(gz0, vec4(0.0));\n  gx0 -= sz0 * (step(0.0, gx0) - 0.5);\n  gy0 -= sz0 * (step(0.0, gy0) - 0.5);\n\n  vec4 gx1 = ixy1 * (1.0 / 7.0);\n  vec4 gy1 = fract(floor(gx1) * (1.0 / 7.0)) - 0.5;\n  gx1 = fract(gx1);\n  vec4 gz1 = vec4(0.5) - abs(gx1) - abs(gy1);\n  vec4 sz1 = step(gz1, vec4(0.0));\n  gx1 -= sz1 * (step(0.0, gx1) - 0.5);\n  gy1 -= sz1 * (step(0.0, gy1) - 0.5);\n\n  vec3 g000 = vec3(gx0.x,gy0.x,gz0.x);\n  vec3 g100 = vec3(gx0.y,gy0.y,gz0.y);\n  vec3 g010 = vec3(gx0.z,gy0.z,gz0.z);\n  vec3 g110 = vec3(gx0.w,gy0.w,gz0.w);\n  vec3 g001 = vec3(gx1.x,gy1.x,gz1.x);\n  vec3 g101 = vec3(gx1.y,gy1.y,gz1.y);\n  vec3 g011 = vec3(gx1.z,gy1.z,gz1.z);\n  vec3 g111 = vec3(gx1.w,gy1.w,gz1.w);\n\n  vec4 norm0 = taylorInvSqrt(vec4(dot(g000, g000), dot(g010, g010), dot(g100, g100), dot(g110, g110)));\n  g000 *= norm0.x;\n  g010 *= norm0.y;\n  g100 *= norm0.z;\n  g110 *= norm0.w;\n  vec4 norm1 = taylorInvSqrt(vec4(dot(g001, g001), dot(g011, g011), dot(g101, g101), dot(g111, g111)));\n  g001 *= norm1.x;\n  g011 *= norm1.y;\n  g101 *= norm1.z;\n  g111 *= norm1.w;\n\n  float n000 = dot(g000, Pf0);\n  float n100 = dot(g100, vec3(Pf1.x, Pf0.yz));\n  float n010 = dot(g010, vec3(Pf0.x, Pf1.y, Pf0.z));\n  float n110 = dot(g110, vec3(Pf1.xy, Pf0.z));\n  float n001 = dot(g001, vec3(Pf0.xy, Pf1.z));\n  float n101 = dot(g101, vec3(Pf1.x, Pf0.y, Pf1.z));\n  float n011 = dot(g011, vec3(Pf0.x, Pf1.yz));\n  float n111 = dot(g111, Pf1);\n\n  vec3 fade_xyz = fade(Pf0);\n  vec4 n_z = mix(vec4(n000, n100, n010, n110), vec4(n001, n101, n011, n111), fade_xyz.z);\n  vec2 n_yz = mix(n_z.xy, n_z.zw, fade_xyz.y);\n  float n_xyz = mix(n_yz.x, n_yz.y, fade_xyz.x); \n  return 2.2 * n_xyz;\n}\n");
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/gl/gl/noise/classicnoise4D.glsl
/* harmony default export */ var classicnoise4D = ("//\n// GLSL textureless classic 4D noise \"cnoise\",\n// with an RSL-style periodic variant \"pnoise\".\n// Author:  Stefan Gustavson (stefan.gustavson@liu.se)\n// Version: 2011-08-22\n//\n// Many thanks to Ian McEwan of Ashima Arts for the\n// ideas for permutation and gradient selection.\n//\n// Copyright (c) 2011 Stefan Gustavson. All rights reserved.\n// Distributed under the MIT license. See LICENSE file.\n// https://github.com/stegu/webgl-noise\n//\n\n\n\n// Classic Perlin noise\nfloat cnoise(vec4 P)\n{\n  vec4 Pi0 = floor(P); // Integer part for indexing\n  vec4 Pi1 = Pi0 + 1.0; // Integer part + 1\n  Pi0 = mod289(Pi0);\n  Pi1 = mod289(Pi1);\n  vec4 Pf0 = fract(P); // Fractional part for interpolation\n  vec4 Pf1 = Pf0 - 1.0; // Fractional part - 1.0\n  vec4 ix = vec4(Pi0.x, Pi1.x, Pi0.x, Pi1.x);\n  vec4 iy = vec4(Pi0.yy, Pi1.yy);\n  vec4 iz0 = vec4(Pi0.zzzz);\n  vec4 iz1 = vec4(Pi1.zzzz);\n  vec4 iw0 = vec4(Pi0.wwww);\n  vec4 iw1 = vec4(Pi1.wwww);\n\n  vec4 ixy = permute(permute(ix) + iy);\n  vec4 ixy0 = permute(ixy + iz0);\n  vec4 ixy1 = permute(ixy + iz1);\n  vec4 ixy00 = permute(ixy0 + iw0);\n  vec4 ixy01 = permute(ixy0 + iw1);\n  vec4 ixy10 = permute(ixy1 + iw0);\n  vec4 ixy11 = permute(ixy1 + iw1);\n\n  vec4 gx00 = ixy00 * (1.0 / 7.0);\n  vec4 gy00 = floor(gx00) * (1.0 / 7.0);\n  vec4 gz00 = floor(gy00) * (1.0 / 6.0);\n  gx00 = fract(gx00) - 0.5;\n  gy00 = fract(gy00) - 0.5;\n  gz00 = fract(gz00) - 0.5;\n  vec4 gw00 = vec4(0.75) - abs(gx00) - abs(gy00) - abs(gz00);\n  vec4 sw00 = step(gw00, vec4(0.0));\n  gx00 -= sw00 * (step(0.0, gx00) - 0.5);\n  gy00 -= sw00 * (step(0.0, gy00) - 0.5);\n\n  vec4 gx01 = ixy01 * (1.0 / 7.0);\n  vec4 gy01 = floor(gx01) * (1.0 / 7.0);\n  vec4 gz01 = floor(gy01) * (1.0 / 6.0);\n  gx01 = fract(gx01) - 0.5;\n  gy01 = fract(gy01) - 0.5;\n  gz01 = fract(gz01) - 0.5;\n  vec4 gw01 = vec4(0.75) - abs(gx01) - abs(gy01) - abs(gz01);\n  vec4 sw01 = step(gw01, vec4(0.0));\n  gx01 -= sw01 * (step(0.0, gx01) - 0.5);\n  gy01 -= sw01 * (step(0.0, gy01) - 0.5);\n\n  vec4 gx10 = ixy10 * (1.0 / 7.0);\n  vec4 gy10 = floor(gx10) * (1.0 / 7.0);\n  vec4 gz10 = floor(gy10) * (1.0 / 6.0);\n  gx10 = fract(gx10) - 0.5;\n  gy10 = fract(gy10) - 0.5;\n  gz10 = fract(gz10) - 0.5;\n  vec4 gw10 = vec4(0.75) - abs(gx10) - abs(gy10) - abs(gz10);\n  vec4 sw10 = step(gw10, vec4(0.0));\n  gx10 -= sw10 * (step(0.0, gx10) - 0.5);\n  gy10 -= sw10 * (step(0.0, gy10) - 0.5);\n\n  vec4 gx11 = ixy11 * (1.0 / 7.0);\n  vec4 gy11 = floor(gx11) * (1.0 / 7.0);\n  vec4 gz11 = floor(gy11) * (1.0 / 6.0);\n  gx11 = fract(gx11) - 0.5;\n  gy11 = fract(gy11) - 0.5;\n  gz11 = fract(gz11) - 0.5;\n  vec4 gw11 = vec4(0.75) - abs(gx11) - abs(gy11) - abs(gz11);\n  vec4 sw11 = step(gw11, vec4(0.0));\n  gx11 -= sw11 * (step(0.0, gx11) - 0.5);\n  gy11 -= sw11 * (step(0.0, gy11) - 0.5);\n\n  vec4 g0000 = vec4(gx00.x,gy00.x,gz00.x,gw00.x);\n  vec4 g1000 = vec4(gx00.y,gy00.y,gz00.y,gw00.y);\n  vec4 g0100 = vec4(gx00.z,gy00.z,gz00.z,gw00.z);\n  vec4 g1100 = vec4(gx00.w,gy00.w,gz00.w,gw00.w);\n  vec4 g0010 = vec4(gx10.x,gy10.x,gz10.x,gw10.x);\n  vec4 g1010 = vec4(gx10.y,gy10.y,gz10.y,gw10.y);\n  vec4 g0110 = vec4(gx10.z,gy10.z,gz10.z,gw10.z);\n  vec4 g1110 = vec4(gx10.w,gy10.w,gz10.w,gw10.w);\n  vec4 g0001 = vec4(gx01.x,gy01.x,gz01.x,gw01.x);\n  vec4 g1001 = vec4(gx01.y,gy01.y,gz01.y,gw01.y);\n  vec4 g0101 = vec4(gx01.z,gy01.z,gz01.z,gw01.z);\n  vec4 g1101 = vec4(gx01.w,gy01.w,gz01.w,gw01.w);\n  vec4 g0011 = vec4(gx11.x,gy11.x,gz11.x,gw11.x);\n  vec4 g1011 = vec4(gx11.y,gy11.y,gz11.y,gw11.y);\n  vec4 g0111 = vec4(gx11.z,gy11.z,gz11.z,gw11.z);\n  vec4 g1111 = vec4(gx11.w,gy11.w,gz11.w,gw11.w);\n\n  vec4 norm00 = taylorInvSqrt(vec4(dot(g0000, g0000), dot(g0100, g0100), dot(g1000, g1000), dot(g1100, g1100)));\n  g0000 *= norm00.x;\n  g0100 *= norm00.y;\n  g1000 *= norm00.z;\n  g1100 *= norm00.w;\n\n  vec4 norm01 = taylorInvSqrt(vec4(dot(g0001, g0001), dot(g0101, g0101), dot(g1001, g1001), dot(g1101, g1101)));\n  g0001 *= norm01.x;\n  g0101 *= norm01.y;\n  g1001 *= norm01.z;\n  g1101 *= norm01.w;\n\n  vec4 norm10 = taylorInvSqrt(vec4(dot(g0010, g0010), dot(g0110, g0110), dot(g1010, g1010), dot(g1110, g1110)));\n  g0010 *= norm10.x;\n  g0110 *= norm10.y;\n  g1010 *= norm10.z;\n  g1110 *= norm10.w;\n\n  vec4 norm11 = taylorInvSqrt(vec4(dot(g0011, g0011), dot(g0111, g0111), dot(g1011, g1011), dot(g1111, g1111)));\n  g0011 *= norm11.x;\n  g0111 *= norm11.y;\n  g1011 *= norm11.z;\n  g1111 *= norm11.w;\n\n  float n0000 = dot(g0000, Pf0);\n  float n1000 = dot(g1000, vec4(Pf1.x, Pf0.yzw));\n  float n0100 = dot(g0100, vec4(Pf0.x, Pf1.y, Pf0.zw));\n  float n1100 = dot(g1100, vec4(Pf1.xy, Pf0.zw));\n  float n0010 = dot(g0010, vec4(Pf0.xy, Pf1.z, Pf0.w));\n  float n1010 = dot(g1010, vec4(Pf1.x, Pf0.y, Pf1.z, Pf0.w));\n  float n0110 = dot(g0110, vec4(Pf0.x, Pf1.yz, Pf0.w));\n  float n1110 = dot(g1110, vec4(Pf1.xyz, Pf0.w));\n  float n0001 = dot(g0001, vec4(Pf0.xyz, Pf1.w));\n  float n1001 = dot(g1001, vec4(Pf1.x, Pf0.yz, Pf1.w));\n  float n0101 = dot(g0101, vec4(Pf0.x, Pf1.y, Pf0.z, Pf1.w));\n  float n1101 = dot(g1101, vec4(Pf1.xy, Pf0.z, Pf1.w));\n  float n0011 = dot(g0011, vec4(Pf0.xy, Pf1.zw));\n  float n1011 = dot(g1011, vec4(Pf1.x, Pf0.y, Pf1.zw));\n  float n0111 = dot(g0111, vec4(Pf0.x, Pf1.yzw));\n  float n1111 = dot(g1111, Pf1);\n\n  vec4 fade_xyzw = fade(Pf0);\n  vec4 n_0w = mix(vec4(n0000, n1000, n0100, n1100), vec4(n0001, n1001, n0101, n1101), fade_xyzw.w);\n  vec4 n_1w = mix(vec4(n0010, n1010, n0110, n1110), vec4(n0011, n1011, n0111, n1111), fade_xyzw.w);\n  vec4 n_zw = mix(n_0w, n_1w, fade_xyzw.z);\n  vec2 n_yzw = mix(n_zw.xy, n_zw.zw, fade_xyzw.y);\n  float n_xyzw = mix(n_yzw.x, n_yzw.y, fade_xyzw.x);\n  return 2.2 * n_xyzw;\n}\n\n// Classic Perlin noise, periodic version\nfloat pnoise(vec4 P, vec4 rep)\n{\n  vec4 Pi0 = mod(floor(P), rep); // Integer part modulo rep\n  vec4 Pi1 = mod(Pi0 + 1.0, rep); // Integer part + 1 mod rep\n  Pi0 = mod289(Pi0);\n  Pi1 = mod289(Pi1);\n  vec4 Pf0 = fract(P); // Fractional part for interpolation\n  vec4 Pf1 = Pf0 - 1.0; // Fractional part - 1.0\n  vec4 ix = vec4(Pi0.x, Pi1.x, Pi0.x, Pi1.x);\n  vec4 iy = vec4(Pi0.yy, Pi1.yy);\n  vec4 iz0 = vec4(Pi0.zzzz);\n  vec4 iz1 = vec4(Pi1.zzzz);\n  vec4 iw0 = vec4(Pi0.wwww);\n  vec4 iw1 = vec4(Pi1.wwww);\n\n  vec4 ixy = permute(permute(ix) + iy);\n  vec4 ixy0 = permute(ixy + iz0);\n  vec4 ixy1 = permute(ixy + iz1);\n  vec4 ixy00 = permute(ixy0 + iw0);\n  vec4 ixy01 = permute(ixy0 + iw1);\n  vec4 ixy10 = permute(ixy1 + iw0);\n  vec4 ixy11 = permute(ixy1 + iw1);\n\n  vec4 gx00 = ixy00 * (1.0 / 7.0);\n  vec4 gy00 = floor(gx00) * (1.0 / 7.0);\n  vec4 gz00 = floor(gy00) * (1.0 / 6.0);\n  gx00 = fract(gx00) - 0.5;\n  gy00 = fract(gy00) - 0.5;\n  gz00 = fract(gz00) - 0.5;\n  vec4 gw00 = vec4(0.75) - abs(gx00) - abs(gy00) - abs(gz00);\n  vec4 sw00 = step(gw00, vec4(0.0));\n  gx00 -= sw00 * (step(0.0, gx00) - 0.5);\n  gy00 -= sw00 * (step(0.0, gy00) - 0.5);\n\n  vec4 gx01 = ixy01 * (1.0 / 7.0);\n  vec4 gy01 = floor(gx01) * (1.0 / 7.0);\n  vec4 gz01 = floor(gy01) * (1.0 / 6.0);\n  gx01 = fract(gx01) - 0.5;\n  gy01 = fract(gy01) - 0.5;\n  gz01 = fract(gz01) - 0.5;\n  vec4 gw01 = vec4(0.75) - abs(gx01) - abs(gy01) - abs(gz01);\n  vec4 sw01 = step(gw01, vec4(0.0));\n  gx01 -= sw01 * (step(0.0, gx01) - 0.5);\n  gy01 -= sw01 * (step(0.0, gy01) - 0.5);\n\n  vec4 gx10 = ixy10 * (1.0 / 7.0);\n  vec4 gy10 = floor(gx10) * (1.0 / 7.0);\n  vec4 gz10 = floor(gy10) * (1.0 / 6.0);\n  gx10 = fract(gx10) - 0.5;\n  gy10 = fract(gy10) - 0.5;\n  gz10 = fract(gz10) - 0.5;\n  vec4 gw10 = vec4(0.75) - abs(gx10) - abs(gy10) - abs(gz10);\n  vec4 sw10 = step(gw10, vec4(0.0));\n  gx10 -= sw10 * (step(0.0, gx10) - 0.5);\n  gy10 -= sw10 * (step(0.0, gy10) - 0.5);\n\n  vec4 gx11 = ixy11 * (1.0 / 7.0);\n  vec4 gy11 = floor(gx11) * (1.0 / 7.0);\n  vec4 gz11 = floor(gy11) * (1.0 / 6.0);\n  gx11 = fract(gx11) - 0.5;\n  gy11 = fract(gy11) - 0.5;\n  gz11 = fract(gz11) - 0.5;\n  vec4 gw11 = vec4(0.75) - abs(gx11) - abs(gy11) - abs(gz11);\n  vec4 sw11 = step(gw11, vec4(0.0));\n  gx11 -= sw11 * (step(0.0, gx11) - 0.5);\n  gy11 -= sw11 * (step(0.0, gy11) - 0.5);\n\n  vec4 g0000 = vec4(gx00.x,gy00.x,gz00.x,gw00.x);\n  vec4 g1000 = vec4(gx00.y,gy00.y,gz00.y,gw00.y);\n  vec4 g0100 = vec4(gx00.z,gy00.z,gz00.z,gw00.z);\n  vec4 g1100 = vec4(gx00.w,gy00.w,gz00.w,gw00.w);\n  vec4 g0010 = vec4(gx10.x,gy10.x,gz10.x,gw10.x);\n  vec4 g1010 = vec4(gx10.y,gy10.y,gz10.y,gw10.y);\n  vec4 g0110 = vec4(gx10.z,gy10.z,gz10.z,gw10.z);\n  vec4 g1110 = vec4(gx10.w,gy10.w,gz10.w,gw10.w);\n  vec4 g0001 = vec4(gx01.x,gy01.x,gz01.x,gw01.x);\n  vec4 g1001 = vec4(gx01.y,gy01.y,gz01.y,gw01.y);\n  vec4 g0101 = vec4(gx01.z,gy01.z,gz01.z,gw01.z);\n  vec4 g1101 = vec4(gx01.w,gy01.w,gz01.w,gw01.w);\n  vec4 g0011 = vec4(gx11.x,gy11.x,gz11.x,gw11.x);\n  vec4 g1011 = vec4(gx11.y,gy11.y,gz11.y,gw11.y);\n  vec4 g0111 = vec4(gx11.z,gy11.z,gz11.z,gw11.z);\n  vec4 g1111 = vec4(gx11.w,gy11.w,gz11.w,gw11.w);\n\n  vec4 norm00 = taylorInvSqrt(vec4(dot(g0000, g0000), dot(g0100, g0100), dot(g1000, g1000), dot(g1100, g1100)));\n  g0000 *= norm00.x;\n  g0100 *= norm00.y;\n  g1000 *= norm00.z;\n  g1100 *= norm00.w;\n\n  vec4 norm01 = taylorInvSqrt(vec4(dot(g0001, g0001), dot(g0101, g0101), dot(g1001, g1001), dot(g1101, g1101)));\n  g0001 *= norm01.x;\n  g0101 *= norm01.y;\n  g1001 *= norm01.z;\n  g1101 *= norm01.w;\n\n  vec4 norm10 = taylorInvSqrt(vec4(dot(g0010, g0010), dot(g0110, g0110), dot(g1010, g1010), dot(g1110, g1110)));\n  g0010 *= norm10.x;\n  g0110 *= norm10.y;\n  g1010 *= norm10.z;\n  g1110 *= norm10.w;\n\n  vec4 norm11 = taylorInvSqrt(vec4(dot(g0011, g0011), dot(g0111, g0111), dot(g1011, g1011), dot(g1111, g1111)));\n  g0011 *= norm11.x;\n  g0111 *= norm11.y;\n  g1011 *= norm11.z;\n  g1111 *= norm11.w;\n\n  float n0000 = dot(g0000, Pf0);\n  float n1000 = dot(g1000, vec4(Pf1.x, Pf0.yzw));\n  float n0100 = dot(g0100, vec4(Pf0.x, Pf1.y, Pf0.zw));\n  float n1100 = dot(g1100, vec4(Pf1.xy, Pf0.zw));\n  float n0010 = dot(g0010, vec4(Pf0.xy, Pf1.z, Pf0.w));\n  float n1010 = dot(g1010, vec4(Pf1.x, Pf0.y, Pf1.z, Pf0.w));\n  float n0110 = dot(g0110, vec4(Pf0.x, Pf1.yz, Pf0.w));\n  float n1110 = dot(g1110, vec4(Pf1.xyz, Pf0.w));\n  float n0001 = dot(g0001, vec4(Pf0.xyz, Pf1.w));\n  float n1001 = dot(g1001, vec4(Pf1.x, Pf0.yz, Pf1.w));\n  float n0101 = dot(g0101, vec4(Pf0.x, Pf1.y, Pf0.z, Pf1.w));\n  float n1101 = dot(g1101, vec4(Pf1.xy, Pf0.z, Pf1.w));\n  float n0011 = dot(g0011, vec4(Pf0.xy, Pf1.zw));\n  float n1011 = dot(g1011, vec4(Pf1.x, Pf0.y, Pf1.zw));\n  float n0111 = dot(g0111, vec4(Pf0.x, Pf1.yzw));\n  float n1111 = dot(g1111, Pf1);\n\n  vec4 fade_xyzw = fade(Pf0);\n  vec4 n_0w = mix(vec4(n0000, n1000, n0100, n1100), vec4(n0001, n1001, n0101, n1101), fade_xyzw.w);\n  vec4 n_1w = mix(vec4(n0010, n1010, n0110, n1110), vec4(n0011, n1011, n0111, n1111), fade_xyzw.w);\n  vec4 n_zw = mix(n_0w, n_1w, fade_xyzw.z);\n  vec2 n_yzw = mix(n_zw.xy, n_zw.zw, fade_xyzw.y);\n  float n_xyzw = mix(n_yzw.x, n_yzw.y, fade_xyzw.x);\n  return 2.2 * n_xyzw;\n}\n");
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/gl/gl/noise/noise2D.glsl
/* harmony default export */ var noise2D = ("//\n// Description : Array and textureless GLSL 2D simplex noise function.\n//      Author : Ian McEwan, Ashima Arts.\n//  Maintainer : stegu\n//     Lastmod : 20110822 (ijm)\n//     License : Copyright (C) 2011 Ashima Arts. All rights reserved.\n//               Distributed under the MIT License. See LICENSE file.\n//               https://github.com/ashima/webgl-noise\n//               https://github.com/stegu/webgl-noise\n// \n\n\nfloat snoise(vec2 v)\n  {\n  const vec4 C = vec4(0.211324865405187,  // (3.0-sqrt(3.0))/6.0\n                      0.366025403784439,  // 0.5*(sqrt(3.0)-1.0)\n                     -0.577350269189626,  // -1.0 + 2.0 * C.x\n                      0.024390243902439); // 1.0 / 41.0\n// First corner\n  vec2 i  = floor(v + dot(v, C.yy) );\n  vec2 x0 = v -   i + dot(i, C.xx);\n\n// Other corners\n  vec2 i1;\n  //i1.x = step( x0.y, x0.x ); // x0.x > x0.y ? 1.0 : 0.0\n  //i1.y = 1.0 - i1.x;\n  i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);\n  // x0 = x0 - 0.0 + 0.0 * C.xx ;\n  // x1 = x0 - i1 + 1.0 * C.xx ;\n  // x2 = x0 - 1.0 + 2.0 * C.xx ;\n  vec4 x12 = x0.xyxy + C.xxzz;\n  x12.xy -= i1;\n\n// Permutations\n  i = mod289(i); // Avoid truncation effects in permutation\n  vec3 p = permute( permute( i.y + vec3(0.0, i1.y, 1.0 ))\n\t\t+ i.x + vec3(0.0, i1.x, 1.0 ));\n\n  vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy), dot(x12.zw,x12.zw)), 0.0);\n  m = m*m ;\n  m = m*m ;\n\n// Gradients: 41 points uniformly over a line, mapped onto a diamond.\n// The ring size 17*17 = 289 is close to a multiple of 41 (41*7 = 287)\n\n  vec3 x = 2.0 * fract(p * C.www) - 1.0;\n  vec3 h = abs(x) - 0.5;\n  vec3 ox = floor(x + 0.5);\n  vec3 a0 = x - ox;\n\n// Normalise gradients implicitly by scaling m\n// Approximation of: m *= inversesqrt( a0*a0 + h*h );\n  m *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );\n\n// Compute final noise value at P\n  vec3 g;\n  g.x  = a0.x  * x0.x  + h.x  * x0.y;\n  g.yz = a0.yz * x12.xz + h.yz * x12.yw;\n  return 130.0 * dot(m, g);\n}\n");
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/gl/gl/noise/noise3D.glsl
/* harmony default export */ var noise3D = ("//\n// Description : Array and textureless GLSL 2D/3D/4D simplex \n//               noise functions.\n//      Author : Ian McEwan, Ashima Arts.\n//  Maintainer : stegu\n//     Lastmod : 20110822 (ijm)\n//     License : Copyright (C) 2011 Ashima Arts. All rights reserved.\n//               Distributed under the MIT License. See LICENSE file.\n//               https://github.com/ashima/webgl-noise\n//               https://github.com/stegu/webgl-noise\n// \n\n\n\nfloat snoise(vec3 v)\n  { \n  const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;\n  const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);\n\n// First corner\n  vec3 i  = floor(v + dot(v, C.yyy) );\n  vec3 x0 =   v - i + dot(i, C.xxx) ;\n\n// Other corners\n  vec3 g = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g;\n  vec3 i1 = min( g.xyz, l.zxy );\n  vec3 i2 = max( g.xyz, l.zxy );\n\n  //   x0 = x0 - 0.0 + 0.0 * C.xxx;\n  //   x1 = x0 - i1  + 1.0 * C.xxx;\n  //   x2 = x0 - i2  + 2.0 * C.xxx;\n  //   x3 = x0 - 1.0 + 3.0 * C.xxx;\n  vec3 x1 = x0 - i1 + C.xxx;\n  vec3 x2 = x0 - i2 + C.yyy; // 2.0*C.x = 1/3 = C.y\n  vec3 x3 = x0 - D.yyy;      // -1.0+3.0*C.x = -0.5 = -D.y\n\n// Permutations\n  i = mod289(i); \n  vec4 p = permute( permute( permute( \n             i.z + vec4(0.0, i1.z, i2.z, 1.0 ))\n           + i.y + vec4(0.0, i1.y, i2.y, 1.0 )) \n           + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));\n\n// Gradients: 7x7 points over a square, mapped onto an octahedron.\n// The ring size 17*17 = 289 is close to a multiple of 49 (49*6 = 294)\n  float n_ = 0.142857142857; // 1.0/7.0\n  vec3  ns = n_ * D.wyz - D.xzx;\n\n  vec4 j = p - 49.0 * floor(p * ns.z * ns.z);  //  mod(p,7*7)\n\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_ );    // mod(j,N)\n\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = y_ *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n\n  vec4 b0 = vec4( x.xy, y.xy );\n  vec4 b1 = vec4( x.zw, y.zw );\n\n  //vec4 s0 = vec4(lessThan(b0,0.0))*2.0 - 1.0;\n  //vec4 s1 = vec4(lessThan(b1,0.0))*2.0 - 1.0;\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;\n\n  vec3 p0 = vec3(a0.xy,h.x);\n  vec3 p1 = vec3(a0.zw,h.y);\n  vec3 p2 = vec3(a1.xy,h.z);\n  vec3 p3 = vec3(a1.zw,h.w);\n\n//Normalise gradients\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n\n// Mix final noise value\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  m = m * m;\n  return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1), \n                                dot(p2,x2), dot(p3,x3) ) );\n  }\n");
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/gl/gl/noise/noise4D.glsl
/* harmony default export */ var noise4D = ("//\n// Description : Array and textureless GLSL 2D/3D/4D simplex \n//               noise functions.\n//      Author : Ian McEwan, Ashima Arts.\n//  Maintainer : stegu\n//     Lastmod : 20110822 (ijm)\n//     License : Copyright (C) 2011 Ashima Arts. All rights reserved.\n//               Distributed under the MIT License. See LICENSE file.\n//               https://github.com/ashima/webgl-noise\n//               https://github.com/stegu/webgl-noise\n// \n\n\n\n\n\n\n\nvec4 grad4(float j, vec4 ip)\n  {\n  const vec4 ones = vec4(1.0, 1.0, 1.0, -1.0);\n  vec4 p,s;\n\n  p.xyz = floor( fract (vec3(j) * ip.xyz) * 7.0) * ip.z - 1.0;\n  p.w = 1.5 - dot(abs(p.xyz), ones.xyz);\n  s = vec4(lessThan(p, vec4(0.0)));\n  p.xyz = p.xyz + (s.xyz*2.0 - 1.0) * s.www; \n\n  return p;\n  }\n\t\t\t\t\t\t\n// (sqrt(5) - 1)/4 = F4, used once below\n#define F4 0.309016994374947451\n\nfloat snoise(vec4 v)\n  {\n  const vec4  C = vec4( 0.138196601125011,  // (5 - sqrt(5))/20  G4\n                        0.276393202250021,  // 2 * G4\n                        0.414589803375032,  // 3 * G4\n                       -0.447213595499958); // -1 + 4 * G4\n\n// First corner\n  vec4 i  = floor(v + dot(v, vec4(F4)) );\n  vec4 x0 = v -   i + dot(i, C.xxxx);\n\n// Other corners\n\n// Rank sorting originally contributed by Bill Licea-Kane, AMD (formerly ATI)\n  vec4 i0;\n  vec3 isX = step( x0.yzw, x0.xxx );\n  vec3 isYZ = step( x0.zww, x0.yyz );\n//  i0.x = dot( isX, vec3( 1.0 ) );\n  i0.x = isX.x + isX.y + isX.z;\n  i0.yzw = 1.0 - isX;\n//  i0.y += dot( isYZ.xy, vec2( 1.0 ) );\n  i0.y += isYZ.x + isYZ.y;\n  i0.zw += 1.0 - isYZ.xy;\n  i0.z += isYZ.z;\n  i0.w += 1.0 - isYZ.z;\n\n  // i0 now contains the unique values 0,1,2,3 in each channel\n  vec4 i3 = clamp( i0, 0.0, 1.0 );\n  vec4 i2 = clamp( i0-1.0, 0.0, 1.0 );\n  vec4 i1 = clamp( i0-2.0, 0.0, 1.0 );\n\n  //  x0 = x0 - 0.0 + 0.0 * C.xxxx\n  //  x1 = x0 - i1  + 1.0 * C.xxxx\n  //  x2 = x0 - i2  + 2.0 * C.xxxx\n  //  x3 = x0 - i3  + 3.0 * C.xxxx\n  //  x4 = x0 - 1.0 + 4.0 * C.xxxx\n  vec4 x1 = x0 - i1 + C.xxxx;\n  vec4 x2 = x0 - i2 + C.yyyy;\n  vec4 x3 = x0 - i3 + C.zzzz;\n  vec4 x4 = x0 + C.wwww;\n\n// Permutations\n  i = mod289(i); \n  float j0 = permute( permute( permute( permute(i.w) + i.z) + i.y) + i.x);\n  vec4 j1 = permute( permute( permute( permute (\n             i.w + vec4(i1.w, i2.w, i3.w, 1.0 ))\n           + i.z + vec4(i1.z, i2.z, i3.z, 1.0 ))\n           + i.y + vec4(i1.y, i2.y, i3.y, 1.0 ))\n           + i.x + vec4(i1.x, i2.x, i3.x, 1.0 ));\n\n// Gradients: 7x7x6 points over a cube, mapped onto a 4-cross polytope\n// 7*7*6 = 294, which is close to the ring size 17*17 = 289.\n  vec4 ip = vec4(1.0/294.0, 1.0/49.0, 1.0/7.0, 0.0) ;\n\n  vec4 p0 = grad4(j0,   ip);\n  vec4 p1 = grad4(j1.x, ip);\n  vec4 p2 = grad4(j1.y, ip);\n  vec4 p3 = grad4(j1.z, ip);\n  vec4 p4 = grad4(j1.w, ip);\n\n// Normalise gradients\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n  p4 *= taylorInvSqrt(dot(p4,p4));\n\n// Mix contributions from the five corners\n  vec3 m0 = max(0.6 - vec3(dot(x0,x0), dot(x1,x1), dot(x2,x2)), 0.0);\n  vec2 m1 = max(0.6 - vec2(dot(x3,x3), dot(x4,x4)            ), 0.0);\n  m0 = m0 * m0;\n  m1 = m1 * m1;\n  return 49.0 * ( dot(m0*m0, vec3( dot( p0, x0 ), dot( p1, x1 ), dot( p2, x2 )))\n               + dot(m1*m1, vec2( dot( p3, x3 ), dot( p4, x4 ) ) ) ) ;\n\n  }\n");
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/gl/Noise.ts











var NoiseName = /* @__PURE__ */ ((NoiseName2) => {
  NoiseName2["CLASSIC_PERLIN_2D"] = "Classic Perlin 2D";
  NoiseName2["CLASSIC_PERLIN_3D"] = "Classic Perlin 3D";
  NoiseName2["CLASSIC_PERLIN_4D"] = "Classic Perlin 4D";
  NoiseName2["NOISE_2D"] = "noise2D";
  NoiseName2["NOISE_3D"] = "noise3D";
  NoiseName2["NOISE_4D"] = "noise4D";
  return NoiseName2;
})(NoiseName || {});
const NOISE_NAMES = [
  "Classic Perlin 2D" /* CLASSIC_PERLIN_2D */,
  "Classic Perlin 3D" /* CLASSIC_PERLIN_3D */,
  "Classic Perlin 4D" /* CLASSIC_PERLIN_4D */,
  "noise2D" /* NOISE_2D */,
  "noise3D" /* NOISE_3D */,
  "noise4D" /* NOISE_4D */
];
const IMPORT_BY_NOISE_NAME = {
  ["Classic Perlin 2D" /* CLASSIC_PERLIN_2D */]: classicnoise2D,
  ["Classic Perlin 3D" /* CLASSIC_PERLIN_3D */]: classicnoise3D,
  ["Classic Perlin 4D" /* CLASSIC_PERLIN_4D */]: classicnoise4D,
  ["noise2D" /* NOISE_2D */]: noise2D,
  ["noise3D" /* NOISE_3D */]: noise3D,
  ["noise4D" /* NOISE_4D */]: noise4D
};
const INPUT_TYPES_BY_NOISE_NAME = {
  ["Classic Perlin 2D" /* CLASSIC_PERLIN_2D */]: Gl/* GlConnectionPointType.VEC2 */.Dv.VEC2,
  ["Classic Perlin 3D" /* CLASSIC_PERLIN_3D */]: Gl/* GlConnectionPointType.VEC3 */.Dv.VEC3,
  ["Classic Perlin 4D" /* CLASSIC_PERLIN_4D */]: Gl/* GlConnectionPointType.VEC4 */.Dv.VEC4,
  ["noise2D" /* NOISE_2D */]: Gl/* GlConnectionPointType.VEC2 */.Dv.VEC2,
  ["noise3D" /* NOISE_3D */]: Gl/* GlConnectionPointType.VEC3 */.Dv.VEC3,
  ["noise4D" /* NOISE_4D */]: Gl/* GlConnectionPointType.VEC4 */.Dv.VEC4
};
const OUTPUT_TYPE_BY_NOISE_NAME = {
  ["Classic Perlin 2D" /* CLASSIC_PERLIN_2D */]: Gl/* GlConnectionPointType.FLOAT */.Dv.FLOAT,
  ["Classic Perlin 3D" /* CLASSIC_PERLIN_3D */]: Gl/* GlConnectionPointType.FLOAT */.Dv.FLOAT,
  ["Classic Perlin 4D" /* CLASSIC_PERLIN_4D */]: Gl/* GlConnectionPointType.FLOAT */.Dv.FLOAT,
  ["noise2D" /* NOISE_2D */]: Gl/* GlConnectionPointType.FLOAT */.Dv.FLOAT,
  ["noise3D" /* NOISE_3D */]: Gl/* GlConnectionPointType.FLOAT */.Dv.FLOAT,
  ["noise4D" /* NOISE_4D */]: Gl/* GlConnectionPointType.FLOAT */.Dv.FLOAT
};
const METHOD_NAMES_BY_NOISE_NAME = {
  ["Classic Perlin 2D" /* CLASSIC_PERLIN_2D */]: "cnoise",
  ["Classic Perlin 3D" /* CLASSIC_PERLIN_3D */]: "cnoise",
  ["Classic Perlin 4D" /* CLASSIC_PERLIN_4D */]: "cnoise",
  ["noise2D" /* NOISE_2D */]: "snoise",
  ["noise3D" /* NOISE_3D */]: "snoise",
  ["noise4D" /* NOISE_4D */]: "snoise"
};
var NoiseOutputType = /* @__PURE__ */ ((NoiseOutputType2) => {
  NoiseOutputType2[NoiseOutputType2["NoChange"] = 0] = "NoChange";
  NoiseOutputType2[NoiseOutputType2["Float"] = 1] = "Float";
  NoiseOutputType2[NoiseOutputType2["Vec2"] = 2] = "Vec2";
  NoiseOutputType2[NoiseOutputType2["Vec3"] = 3] = "Vec3";
  NoiseOutputType2[NoiseOutputType2["Vec4"] = 4] = "Vec4";
  return NoiseOutputType2;
})(NoiseOutputType || {});
const OUTPUT_TYPES = [
  0 /* NoChange */,
  1 /* Float */,
  2 /* Vec2 */,
  3 /* Vec3 */,
  4 /* Vec4 */
];
const OUTPUT_TYPE_LABEL = {
  [0 /* NoChange */]: "Same as noise",
  [1 /* Float */]: "Float",
  [2 /* Vec2 */]: "Vec2",
  [3 /* Vec3 */]: "Vec3",
  [4 /* Vec4 */]: "Vec4"
};
const CONNECTION_TYPE_BY_OUTPUT_TYPE = {
  [0 /* NoChange */]: Gl/* GlConnectionPointType.FLOAT */.Dv.FLOAT,
  [1 /* Float */]: Gl/* GlConnectionPointType.FLOAT */.Dv.FLOAT,
  [2 /* Vec2 */]: Gl/* GlConnectionPointType.VEC2 */.Dv.VEC2,
  [3 /* Vec3 */]: Gl/* GlConnectionPointType.VEC3 */.Dv.VEC3,
  [4 /* Vec4 */]: Gl/* GlConnectionPointType.VEC4 */.Dv.VEC4
};
const ALL_COMPONENTS = ["x", "y", "z", "w"];
const Noise_OUTPUT_NAME = "noise";
const default_noise_type = NOISE_NAMES.indexOf("noise3D" /* NOISE_3D */);
const default_output_type = 0 /* NoChange */;
const Noise_DefaultValues = {
  amp: 1,
  freq: 1
};
var NoiseGlNodeInputName = /* @__PURE__ */ ((NoiseGlNodeInputName2) => {
  NoiseGlNodeInputName2["AMP"] = "amp";
  NoiseGlNodeInputName2["POSITION"] = "position";
  NoiseGlNodeInputName2["FREQ"] = "freq";
  NoiseGlNodeInputName2["OFFSET"] = "offset";
  return NoiseGlNodeInputName2;
})(NoiseGlNodeInputName || {});




class NoiseGlParamsConfig extends params_ParamsConfig/* NodeParamsConfig */.yI {
  constructor() {
    super(...arguments);
    this.type = params_ParamsConfig/* ParamConfig.INTEGER */.XC.INTEGER(default_noise_type, {
      menu: {
        entries: NOISE_NAMES.map((noise_name, i) => {
          const noise_output_type = OUTPUT_TYPE_BY_NOISE_NAME[noise_name];
          const name = `${noise_name} (output: ${noise_output_type})`;
          return { name, value: i };
        })
      }
    });
    this.outputType = params_ParamsConfig/* ParamConfig.INTEGER */.XC.INTEGER(default_output_type, {
      menu: {
        entries: OUTPUT_TYPES.map((output_type) => {
          const val = OUTPUT_TYPES[output_type];
          const name = OUTPUT_TYPE_LABEL[val];
          return { name, value: val };
        })
      }
    });
    this.octaves = params_ParamsConfig/* ParamConfig.INTEGER */.XC.INTEGER(3, { range: [1, 10], rangeLocked: [true, false] });
    this.ampAttenuation = params_ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(0.5, { range: [0, 1] });
    this.freqIncrease = params_ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(2, {
      range: [0, 10],
      separatorAfter: true
    });
  }
}
const gl_Noise_ParamsConfig = new NoiseGlParamsConfig();
class NoiseGlNode extends gl_Base/* TypedGlNode */.hD {
  constructor() {
    super(...arguments);
    this.paramsConfig = gl_Noise_ParamsConfig;
  }
  static type() {
    return types_Gl/* GlType.NOISE */.P.NOISE;
  }
  // public readonly gl_connections_controller: GlConnectionsController = new GlConnectionsController(this);
  initializeNode() {
    super.initializeNode();
    this.io.connection_points.initializeNode();
    this.io.connection_points.spare_params.setInputlessParamNames(["octaves", "ampAttenuation", "freqIncrease"]);
    this.io.outputs.setNamedOutputConnectionPoints([
      new Gl/* GlConnectionPoint */.E(Noise_OUTPUT_NAME, Gl/* GlConnectionPointType.FLOAT */.Dv.FLOAT)
    ]);
    this.io.connection_points.set_expected_input_types_function(this._expected_input_types.bind(this));
    this.io.connection_points.set_expected_output_types_function(this._expected_output_types.bind(this));
    this.io.connection_points.set_input_name_function(this._gl_input_name.bind(this));
    this.io.connection_points.set_output_name_function(() => Noise_OUTPUT_NAME);
  }
  setNoiseName(noiseName) {
    this.p.type.set(NOISE_NAMES.indexOf(noiseName));
  }
  setOutputType(outputType) {
    this.p.outputType.set(OUTPUT_TYPES.indexOf(outputType));
  }
  _gl_input_name(index) {
    return [
      "amp" /* AMP */,
      "position" /* POSITION */,
      "freq" /* FREQ */,
      "offset" /* OFFSET */
    ][index];
  }
  paramDefaultValue(name) {
    return Noise_DefaultValues[name];
  }
  _expected_input_types() {
    const noiseName = NOISE_NAMES[this.pv.type];
    const amplitudeType = this._expected_output_types()[0];
    const type = INPUT_TYPES_BY_NOISE_NAME[noiseName];
    return [amplitudeType, type, type, type];
  }
  _expected_output_types() {
    const noise_name = NOISE_NAMES[this.pv.type];
    const output_type = OUTPUT_TYPES[this.pv.outputType];
    if (output_type == 0 /* NoChange */) {
      return [INPUT_TYPES_BY_NOISE_NAME[noise_name]];
    } else {
      return [CONNECTION_TYPE_BY_OUTPUT_TYPE[output_type]];
    }
  }
  setLines(shaders_collection_controller) {
    const function_declaration_lines = [];
    const body_lines = [];
    const noise_name = NOISE_NAMES[this.pv.type];
    const noise_function = IMPORT_BY_NOISE_NAME[noise_name];
    const noise_output_gl_type = OUTPUT_TYPE_BY_NOISE_NAME[noise_name];
    function_declaration_lines.push(new GLDefinition/* FunctionGLDefinition */.MR(this, common));
    function_declaration_lines.push(new GLDefinition/* FunctionGLDefinition */.MR(this, noise_function));
    function_declaration_lines.push(new GLDefinition/* FunctionGLDefinition */.MR(this, this.fbmFunction()));
    const output_gl_type = this._expected_output_types()[0];
    if (output_gl_type == noise_output_gl_type) {
      const line = this.singleNoiseLine();
      body_lines.push(line);
    } else {
      const requested_components_count = Gl/* GlConnectionPointComponentsCountMap */.Od[output_gl_type];
      const lines_count_required = requested_components_count;
      const assembly_args = [];
      const noise = this.glVarName(Noise_OUTPUT_NAME);
      for (let i = 0; i < lines_count_required; i++) {
        const component = ALL_COMPONENTS[i];
        assembly_args.push(`${noise}${component}`);
        const input_type = INPUT_TYPES_BY_NOISE_NAME[noise_name];
        const offset_gl_type = input_type;
        const offset_components_count = Gl/* GlConnectionPointComponentsCountMap */.Od[offset_gl_type];
        const offset_values = (0,ArrayUtils/* rangeWithEnd */.Zi)(offset_components_count).map((j) => ThreeToGl/* ThreeToGl.float */._.float(1e3 * i)).join(", ");
        const offset2 = `${offset_gl_type}(${offset_values})`;
        const line = this.singleNoiseLine(component, component, offset2);
        body_lines.push(line);
      }
      const joined_args = assembly_args.join(", ");
      const assembly_line = `vec${lines_count_required} ${noise} = vec${lines_count_required}(${joined_args})`;
      body_lines.push(assembly_line);
    }
    shaders_collection_controller.addDefinitions(this, function_declaration_lines);
    shaders_collection_controller.addBodyLines(this, body_lines);
  }
  fbmMethodName() {
    const noiseName = NOISE_NAMES[this.pv.type];
    const methodName = METHOD_NAMES_BY_NOISE_NAME[noiseName];
    return `fbm_${methodName}${this.path().replace(/\//g, "_")}`;
  }
  fbmFunction() {
    const noiseName = NOISE_NAMES[this.pv.type];
    const methodName = METHOD_NAMES_BY_NOISE_NAME[noiseName];
    const inputType = INPUT_TYPES_BY_NOISE_NAME[noiseName];
    return `
float ${this.fbmMethodName()}(in ${inputType} st) {
	float value = 0.0;
	float amplitude = 1.0;
	for (int i = 0; i < ${ThreeToGl/* ThreeToGl.integer */._.integer(this.pv.octaves)}; i++) {
		value += amplitude * ${methodName}(st);
		st *= ${ThreeToGl/* ThreeToGl.float */._.float(this.pv.freqIncrease)};
		amplitude *= ${ThreeToGl/* ThreeToGl.float */._.float(this.pv.ampAttenuation)};
	}
	return value;
}
`;
  }
  singleNoiseLine(output_name_suffix, component, offset2) {
    const method_name = this.fbmMethodName();
    const amp = ThreeToGl/* ThreeToGl.any */._.any(this.variableForInput("amp" /* AMP */));
    const position = ThreeToGl/* ThreeToGl.any */._.any(this.variableForInput("position" /* POSITION */));
    const freq = ThreeToGl/* ThreeToGl.any */._.any(this.variableForInput("freq" /* FREQ */));
    let offset = ThreeToGl/* ThreeToGl.any */._.any(this.variableForInput("offset" /* OFFSET */));
    if (offset2) {
      offset = `(${offset}+${offset2})`;
    }
    const args = [`(${position}*${freq})+${offset}`];
    const joinedArgs = args.join(", ");
    const noise = this.glVarName(Noise_OUTPUT_NAME);
    const rightHand = `${amp}*${method_name}(${joinedArgs})`;
    if (component) {
      return `float ${noise}${output_name_suffix} = (${rightHand}).${component}`;
    } else {
      const namedOutputConnectionPoints = this.io.outputs.namedOutputConnectionPoints();
      const outputType = namedOutputConnectionPoints ? namedOutputConnectionPoints[0].type() : Gl/* GlConnectionPointType.FLOAT */.Dv.FLOAT;
      return `${outputType} ${noise} = ${rightHand}`;
    }
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/gl/NormalToWorld.ts






const NormalToWorld_OUTPUT_NAME = "worldNormal";
class NormalToWorldGlParamsConfig extends params_ParamsConfig/* NodeParamsConfig */.yI {
  constructor() {
    super(...arguments);
    this.normal = params_ParamsConfig/* ParamConfig.VECTOR3 */.XC.VECTOR3([0, 1, 0]);
  }
}
const NormalToWorld_ParamsConfig = new NormalToWorldGlParamsConfig();
class NormalToWorldGlNode extends gl_Base/* TypedGlNode */.hD {
  constructor() {
    super(...arguments);
    this.paramsConfig = NormalToWorld_ParamsConfig;
  }
  static type() {
    return "normalToWorld";
  }
  initializeNode() {
    super.initializeNode();
    this.io.outputs.setNamedOutputConnectionPoints([
      new Gl/* GlConnectionPoint */.E(NormalToWorld_OUTPUT_NAME, Gl/* GlConnectionPointType.VEC3 */.Dv.VEC3)
    ]);
  }
  setLines(linesController) {
    if (linesController.currentShaderName() == ShaderName/* ShaderName.VERTEX */.k.VERTEX) {
      const input = ThreeToGl/* ThreeToGl.vector3 */._.vector3(this.variableForInputParam(this.p.normal));
      const outValue = this.glVarName(NormalToWorld_OUTPUT_NAME);
      const bodyLine = `vec3 ${outValue} = normalize( mat3( modelMatrix[0].xyz, modelMatrix[1].xyz, modelMatrix[2].xyz ) * ${input} )`;
      linesController.addBodyLines(this, [bodyLine], ShaderName/* ShaderName.VERTEX */.k.VERTEX);
    }
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/gl/Null.ts



class NullGlNode extends BaseNodeGlMathFunctionArg1GlNode {
  static type() {
    return "null";
  }
  setLines(shaders_collection_controller) {
    const namedOutputConnectionPoints = this.io.outputs.namedOutputConnectionPoints();
    if (!namedOutputConnectionPoints) {
      return;
    }
    const in_value = ThreeToGl/* ThreeToGl.any */._.any(this.variableForInput(this._gl_input_name(0)));
    const out_connection_point = namedOutputConnectionPoints[0];
    const gl_type = out_connection_point.type();
    const out = this.glVarName(out_connection_point.name());
    const body_line = `${gl_type} ${out} = ${in_value}`;
    shaders_collection_controller.addBodyLines(this, [body_line]);
  }
}

// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/nodes/gl/Output.ts
var Output = __webpack_require__(91560);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/nodes/gl/Param.ts
var gl_Param = __webpack_require__(67167);
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/gl/PositionToWorld.ts






const PositionToWorld_OUTPUT_NAME = "worldPosition";
class PositionToWorldGlParamsConfig extends params_ParamsConfig/* NodeParamsConfig */.yI {
  constructor() {
    super(...arguments);
    this.position = params_ParamsConfig/* ParamConfig.VECTOR3 */.XC.VECTOR3([0, 1, 0]);
  }
}
const PositionToWorld_ParamsConfig = new PositionToWorldGlParamsConfig();
class PositionToWorldGlNode extends gl_Base/* TypedGlNode */.hD {
  constructor() {
    super(...arguments);
    this.paramsConfig = PositionToWorld_ParamsConfig;
  }
  static type() {
    return "positionToWorld";
  }
  initializeNode() {
    super.initializeNode();
    this.io.outputs.setNamedOutputConnectionPoints([
      new Gl/* GlConnectionPoint */.E(PositionToWorld_OUTPUT_NAME, Gl/* GlConnectionPointType.VEC4 */.Dv.VEC4)
    ]);
  }
  setLines(linesController) {
    if (linesController.currentShaderName() == ShaderName/* ShaderName.VERTEX */.k.VERTEX) {
      const input = ThreeToGl/* ThreeToGl.vector3 */._.vector3(this.variableForInputParam(this.p.position));
      const outValue = this.glVarName(PositionToWorld_OUTPUT_NAME);
      const bodyLine = `vec4 ${outValue} = modelMatrix * vec4(${input}, 1.0)`;
      linesController.addBodyLines(this, [bodyLine], ShaderName/* ShaderName.VERTEX */.k.VERTEX);
    }
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/gl/gl/oklab.glsl
/* harmony default export */ var oklab = ("//////////////////////////////////////////////////////////////////////\n//\n// Visualizing Björn Ottosson's \"oklab\" colorspace\n//\n// shadertoy implementation by mattz\n//\n// license CC0 (public domain)\n// https://creativecommons.org/share-your-work/public-domain/cc0/\n//\n// Click and drag to set lightness (mouse x) and chroma (mouse y).\n// Hue varies linearly across the image from left to right.\n//\n// While mouse is down, plotted curves show oklab components\n// L (red), a (green), and b (blue). \n//\n// To test the inverse mapping, the plotted curves are generated\n// by mapping the (pre-clipping) linear RGB color back to oklab \n// space.\n//\n// White bars on top of the image (and black bars on the bottom of\n// the image) indicate clipping when one or more of the R, G, B \n// components are greater than 1.0 (or less than 0.0 respectively).\n//\n// The color accompanying the black/white bar shows which channels\n// are out of gamut.\n//\n// Click in the bottom left to reset the view.\n//\n// Hit the 'G' key to toggle displaying a gamut test:\n//\n//   * black pixels indicate that RGB values for some hues\n//     were clipped to 0 at the given lightness/chroma pair.\n//\n//   * white pixels indicate that RGB values for some hues\n//     were clipped to 1 at the given lightness/chroma pair\n//\n//   * gray pixels indicate that both types of clipping happened\n//\n// Hit the 'U' key to display a uniform sampling of linear sRGB \n// space, converted into oklab lightness (x position) and chroma\n// (y position) coordinates. If you mouse over a colored dot, the\n// spectrum on screen should include that exact color.\n//\n//////////////////////////////////////////////////////////////////////\n\n//////////////////////////////////////////////////////////////////////\n// sRGB color transform and inverse from \n// https://bottosson.github.io/posts/colorwrong/#what-can-we-do%3F\n\nvec3 srgb_from_linear_srgb(vec3 x) {\n\n    vec3 xlo = 12.92*x;\n    vec3 xhi = 1.055 * pow(x, vec3(0.4166666666666667)) - 0.055;\n    \n    return mix(xlo, xhi, step(vec3(0.0031308), x));\n\n}\n\nvec3 linear_srgb_from_srgb(vec3 x) {\n\n    vec3 xlo = x / 12.92;\n    vec3 xhi = pow((x + 0.055)/(1.055), vec3(2.4));\n    \n    return mix(xlo, xhi, step(vec3(0.04045), x));\n\n}\n\n//////////////////////////////////////////////////////////////////////\n// oklab transform and inverse from\n// https://bottosson.github.io/posts/oklab/\n\n\nconst mat3 fwdA = mat3(1.0, 1.0, 1.0,\n                       0.3963377774, -0.1055613458, -0.0894841775,\n                       0.2158037573, -0.0638541728, -1.2914855480);\n                       \nconst mat3 fwdB = mat3(4.0767245293, -1.2681437731, -0.0041119885,\n                       -3.3072168827, 2.6093323231, -0.7034763098,\n                       0.2307590544, -0.3411344290,  1.7068625689);\n\nconst mat3 invB = mat3(0.4121656120, 0.2118591070, 0.0883097947,\n                       0.5362752080, 0.6807189584, 0.2818474174,\n                       0.0514575653, 0.1074065790, 0.6302613616);\n                       \nconst mat3 invA = mat3(0.2104542553, 1.9779984951, 0.0259040371,\n                       0.7936177850, -2.4285922050, 0.7827717662,\n                       -0.0040720468, 0.4505937099, -0.8086757660);\n\nvec3 oklab_from_linear_srgb(vec3 c) {\n\n    vec3 lms = invB * c;\n            \n    return invA * (sign(lms)*pow(abs(lms), vec3(0.3333333333333)));\n    \n}\n\nvec3 linear_srgb_from_oklab(vec3 c) {\n\n    vec3 lms = fwdA * c;\n    \n    return fwdB * (lms * lms * lms);\n    \n}\n\n\n// https://www.shadertoy.com/view/WtccD7\nconst float max_chroma = 0.33;\nvec3 uvToOklab(vec3 uvw){\n\n    // setup oklab color\n    float theta = 2.*3.141592653589793*uvw.x;\n    \n    float L = 0.8;\n    float chroma = 0.1;\n    \n    //if (max(iMouse.x, iMouse.y) > 0.05 * iResolution.y) {\n        L = uvw.y;//iMouse.x / iResolution.x;\n        chroma = uvw.z * max_chroma;// / iResolution.y;\n    //}\n    \n    float a = chroma*cos(theta);\n    float b = chroma*sin(theta);\n    \n    vec3 lab = vec3(L, a, b);\n\treturn lab;\n\n    // convert to rgb \n    // vec3 rgb = linear_srgb_from_oklab(lab);\n\n}");
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/gl/OklabToRgb.ts






const OklabToRgb_OUTPUT_NAME = "rgb";

class OklabToRgbGlParamsConfig extends params_ParamsConfig/* NodeParamsConfig */.yI {
  constructor() {
    super(...arguments);
    this.oklab = params_ParamsConfig/* ParamConfig.VECTOR3 */.XC.VECTOR3([1, 1, 1]);
  }
}
const OklabToRgb_ParamsConfig = new OklabToRgbGlParamsConfig();
class OklabToRgbGlNode extends gl_Base/* TypedGlNode */.hD {
  constructor() {
    super(...arguments);
    this.paramsConfig = OklabToRgb_ParamsConfig;
  }
  static type() {
    return "oklabToRgb";
  }
  initializeNode() {
    super.initializeNode();
    this.io.outputs.setNamedOutputConnectionPoints([
      new Gl/* GlConnectionPoint */.E(OklabToRgb_OUTPUT_NAME, Gl/* GlConnectionPointType.VEC3 */.Dv.VEC3)
    ]);
  }
  setLines(shaders_collection_controller) {
    const function_declaration_lines = [];
    const body_lines = [];
    function_declaration_lines.push(new GLDefinition/* FunctionGLDefinition */.MR(this, oklab));
    const value = ThreeToGl/* ThreeToGl.vector3 */._.vector3(this.variableForInputParam(this.p.oklab));
    const rgb = this.glVarName(OklabToRgb_OUTPUT_NAME);
    body_lines.push(`vec3 ${rgb} = linear_srgb_from_oklab(${value})`);
    shaders_collection_controller.addDefinitions(this, function_declaration_lines);
    shaders_collection_controller.addBodyLines(this, body_lines);
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/gl/PolarToCartesian.ts







const PolarToCartesian_OUTPUT_NAME = "xyz";
class PolarToCartesianGlParamsConfig extends params_ParamsConfig/* NodeParamsConfig */.yI {
  constructor() {
    super(...arguments);
    this.polar = params_ParamsConfig/* ParamConfig.VECTOR3 */.XC.VECTOR3([1, 1, 1]);
  }
}
const PolarToCartesian_ParamsConfig = new PolarToCartesianGlParamsConfig();
class PolarToCartesianGlNode extends gl_Base/* TypedGlNode */.hD {
  constructor() {
    super(...arguments);
    this.paramsConfig = PolarToCartesian_ParamsConfig;
  }
  static type() {
    return "polarToCartesian";
  }
  initializeNode() {
    super.initializeNode();
    this.io.outputs.setNamedOutputConnectionPoints([
      new Gl/* GlConnectionPoint */.E(PolarToCartesian_OUTPUT_NAME, Gl/* GlConnectionPointType.VEC3 */.Dv.VEC3)
    ]);
  }
  setLines(shadersCollectionController) {
    const out = this.glVarName(PolarToCartesian_OUTPUT_NAME);
    const polar = ThreeToGl/* ThreeToGl.vector3 */._.vector3(this.variableForInputParam(this.p.polar));
    const bodyLine = `vec3 ${out} = polarToCartesian(${polar})`;
    shadersCollectionController.addBodyLines(this, [bodyLine]);
    shadersCollectionController.addDefinitions(this, [new GLDefinition/* FunctionGLDefinition */.MR(this, gl_polar)]);
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/gl/QuatMult.ts





class QuatMultGlNode extends BaseNodeGlMathFunctionArg1GlNode {
  static type() {
    return "quatMult";
  }
  initializeNode() {
    super.initializeNode();
    this.io.connection_points.set_input_name_function((index) => ["quat0", "quat1"][index]);
    this.io.connection_points.set_expected_input_types_function(() => [
      Gl/* GlConnectionPointType.VEC4 */.Dv.VEC4,
      Gl/* GlConnectionPointType.VEC4 */.Dv.VEC4
    ]);
    this.io.connection_points.set_expected_output_types_function(() => [Gl/* GlConnectionPointType.VEC4 */.Dv.VEC4]);
  }
  // protected _gl_input_name(index: number) {
  // 	return ['quat0', 'quat1'][index];
  // }
  gl_method_name() {
    return "quatMult";
  }
  // protected _expected_input_types() {
  // 	return [ConnectionPointType.VEC4, ConnectionPointType.VEC4];
  // }
  // protected _expected_output_types() {
  // 	return [ConnectionPointType.VEC4];
  // }
  gl_function_definitions() {
    return [new GLDefinition/* FunctionGLDefinition */.MR(this, quaternion/* default */.Z)];
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/gl/QuatFromAxisAngle.ts





var QuatFromAxisAngleGlNodeInputName = /* @__PURE__ */ ((QuatFromAxisAngleGlNodeInputName2) => {
  QuatFromAxisAngleGlNodeInputName2["AXIS"] = "axis";
  QuatFromAxisAngleGlNodeInputName2["ANGLE"] = "angle";
  return QuatFromAxisAngleGlNodeInputName2;
})(QuatFromAxisAngleGlNodeInputName || {});
const QuatFromAxisAngle_InputNames = [
  "axis" /* AXIS */,
  "angle" /* ANGLE */
];
const DEFAULT_AXIS = [0, 0, 1];
const DEFAULT_ANGLE = 0;
const QuatFromAxisAngle_DefaultValues = {
  ["axis" /* AXIS */]: DEFAULT_AXIS,
  ["angle" /* ANGLE */]: DEFAULT_ANGLE
};
class QuatFromAxisAngleGlNode extends BaseNodeGlMathFunctionArg2GlNode {
  static type() {
    return "quatFromAxisAngle";
  }
  initializeNode() {
    super.initializeNode();
    this.io.connection_points.set_input_name_function((index) => QuatFromAxisAngle_InputNames[index]);
    this.io.connection_points.set_expected_input_types_function(() => [
      Gl/* GlConnectionPointType.VEC3 */.Dv.VEC3,
      Gl/* GlConnectionPointType.FLOAT */.Dv.FLOAT
    ]);
    this.io.connection_points.set_expected_output_types_function(() => [Gl/* GlConnectionPointType.VEC4 */.Dv.VEC4]);
  }
  // protected _gl_input_name(index: number) {
  // 	return InputNames[index];
  // }
  paramDefaultValue(name) {
    return QuatFromAxisAngle_DefaultValues[name];
  }
  gl_method_name() {
    return "quatFromAxisAngle";
  }
  // protected _expected_input_types() {
  // 	return [ConnectionPointType.VEC3, ConnectionPointType.FLOAT];
  // }
  // protected expected_output_types() {
  // 	return [ConnectionPointType.VEC4];
  // }
  gl_function_definitions() {
    return [new GLDefinition/* FunctionGLDefinition */.MR(this, quaternion/* default */.Z)];
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/gl/QuatSlerp.ts





class QuatSlerpGlNode extends BaseNodeGlMathFunctionArg1GlNode {
  static type() {
    return "quatSlerp";
  }
  initializeNode() {
    super.initializeNode();
    this.io.connection_points.set_input_name_function((index) => ["quat0", "quat1", "blend"][index]);
    this.io.connection_points.set_expected_input_types_function(() => [
      Gl/* GlConnectionPointType.VEC4 */.Dv.VEC4,
      Gl/* GlConnectionPointType.VEC4 */.Dv.VEC4,
      Gl/* GlConnectionPointType.FLOAT */.Dv.FLOAT
    ]);
    this.io.connection_points.set_expected_output_types_function(() => [Gl/* GlConnectionPointType.VEC4 */.Dv.VEC4]);
  }
  // protected _gl_input_name(index: number) {
  // 	return ['quat0', 'quat1'][index];
  // }
  gl_method_name() {
    return "quatSlerp";
  }
  // protected _expected_input_types() {
  // 	return [ConnectionPointType.VEC4, ConnectionPointType.VEC4];
  // }
  // protected _expected_output_types() {
  // 	return [ConnectionPointType.VEC4];
  // }
  gl_function_definitions() {
    return [new GLDefinition/* FunctionGLDefinition */.MR(this, quaternion/* default */.Z)];
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/gl/QuatToAngle.ts





class QuatToAngleGlNode extends BaseNodeGlMathFunctionArg1GlNode {
  static type() {
    return "quatToAngle";
  }
  initializeNode() {
    super.initializeNode();
    this.io.connection_points.set_input_name_function((index) => ["quat"][index]);
    this.io.connection_points.set_expected_input_types_function(() => [Gl/* GlConnectionPointType.VEC4 */.Dv.VEC4]);
    this.io.connection_points.set_expected_output_types_function(() => [Gl/* GlConnectionPointType.FLOAT */.Dv.FLOAT]);
  }
  // protected _gl_input_name(index: number) {
  // 	return ['quat'][index];
  // }
  gl_method_name() {
    return "quatToAngle";
  }
  // protected _expected_input_types() {
  // 	return [ConnectionPointType.VEC4];
  // }
  // protected _expected_output_types() {
  // 	return [ConnectionPointType.FLOAT];
  // }
  gl_function_definitions() {
    return [new GLDefinition/* FunctionGLDefinition */.MR(this, quaternion/* default */.Z)];
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/gl/QuatToAxis.ts





class QuatToAxisGlNode extends BaseNodeGlMathFunctionArg1GlNode {
  static type() {
    return "quatToAxis";
  }
  initializeNode() {
    super.initializeNode();
    this.io.connection_points.set_input_name_function((index) => ["quat"][index]);
    this.io.connection_points.set_expected_input_types_function(() => [Gl/* GlConnectionPointType.VEC4 */.Dv.VEC4]);
    this.io.connection_points.set_expected_output_types_function(() => [Gl/* GlConnectionPointType.VEC3 */.Dv.VEC3]);
  }
  // protected _gl_input_name(index: number) {
  // 	return ['quat'][index];
  // }
  gl_method_name() {
    return "quatToAxis";
  }
  // protected _expected_input_types() {
  // 	return [ConnectionPointType.VEC4];
  // }
  // protected _expected_output_types() {
  // 	return [ConnectionPointType.VEC3];
  // }
  gl_function_definitions() {
    return [new GLDefinition/* FunctionGLDefinition */.MR(this, quaternion/* default */.Z)];
  }
}

// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/nodes/gl/Ramp.ts
var Ramp = __webpack_require__(20525);
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/gl/Random.ts





const Random_OUTPUT_NAME = "rand";
class RandomGlParamsConfig extends params_ParamsConfig/* NodeParamsConfig */.yI {
  constructor() {
    super(...arguments);
    this.seed = params_ParamsConfig/* ParamConfig.VECTOR2 */.XC.VECTOR2([1, 1]);
  }
}
const Random_ParamsConfig = new RandomGlParamsConfig();
class RandomGlNode extends gl_Base/* TypedGlNode */.hD {
  constructor() {
    super(...arguments);
    this.paramsConfig = Random_ParamsConfig;
  }
  static type() {
    return "random";
  }
  initializeNode() {
    super.initializeNode();
    this.io.outputs.setNamedOutputConnectionPoints([
      new Gl/* GlConnectionPoint */.E(Random_OUTPUT_NAME, Gl/* GlConnectionPointType.FLOAT */.Dv.FLOAT)
    ]);
  }
  setLines(shaders_collection_controller) {
    const connectionPoints = this.io.inputs.namedInputConnectionPoints();
    if (!connectionPoints) {
      return;
    }
    const input_name = connectionPoints[0].name();
    const value = ThreeToGl/* ThreeToGl.vector2 */._.vector2(this.variableForInput(input_name));
    const float = this.glVarName(Random_OUTPUT_NAME);
    const body_line = `float ${float} = rand(${value})`;
    shaders_collection_controller.addBodyLines(this, [body_line]);
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/gl/Refract.ts



class RefractGlNode extends BaseGlMathFunctionGlNode {
  static type() {
    return "refract";
  }
  initializeNode() {
    super.initializeNode();
    this.io.connection_points.set_input_name_function((index) => ["I", "N", "eta"][index]);
    this.io.connection_points.set_output_name_function((index) => "refract");
    this.io.connection_points.set_expected_input_types_function(this._expected_input_types.bind(this));
    this.io.connection_points.set_expected_output_types_function(this._expected_output_types.bind(this));
  }
  gl_method_name() {
    return "refract";
  }
  _expected_input_types() {
    const type = this.io.connection_points.first_input_connection_type() || Gl/* GlConnectionPointType.VEC3 */.Dv.VEC3;
    return [type, type, Gl/* GlConnectionPointType.FLOAT */.Dv.FLOAT];
  }
  _expected_output_types() {
    const type = this._expected_input_types()[0];
    return [type];
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/gl/gl/rgb2hsv.glsl
/* harmony default export */ var rgb2hsv = ("// https://stackoverflow.com/questions/15095909/from-rgb-to-hsv-in-opengl-glsl\nvec3 rgb2hsv(vec3 c)\n{\n\tvec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n\tvec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));\n\tvec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));\n\n\tfloat d = q.x - min(q.w, q.y);\n\tfloat e = 1.0e-10;\n\treturn vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\n}");
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/gl/RgbToHsv.ts







const RgbToHsv_OUTPUT_NAME = "hsv";
class RgbToHsvGlParamsConfig extends params_ParamsConfig/* NodeParamsConfig */.yI {
  constructor() {
    super(...arguments);
    this.rgb = params_ParamsConfig/* ParamConfig.VECTOR3 */.XC.VECTOR3([1, 1, 1]);
  }
}
const RgbToHsv_ParamsConfig = new RgbToHsvGlParamsConfig();
class RgbToHsvGlNode extends gl_Base/* TypedGlNode */.hD {
  constructor() {
    super(...arguments);
    this.paramsConfig = RgbToHsv_ParamsConfig;
  }
  static type() {
    return "rgbToHsv";
  }
  initializeNode() {
    this.io.outputs.setNamedOutputConnectionPoints([
      new Gl/* GlConnectionPoint */.E(RgbToHsv_OUTPUT_NAME, Gl/* GlConnectionPointType.VEC3 */.Dv.VEC3)
    ]);
  }
  setLines(shaders_collection_controller) {
    const function_declaration_lines = [];
    const body_lines = [];
    function_declaration_lines.push(new GLDefinition/* FunctionGLDefinition */.MR(this, rgb2hsv));
    const rgb = ThreeToGl/* ThreeToGl.vector3 */._.vector3(this.variableForInputParam(this.p.rgb));
    const hsv = this.glVarName(RgbToHsv_OUTPUT_NAME);
    body_lines.push(`vec3 ${hsv} = rgb2hsv(${rgb})`);
    shaders_collection_controller.addDefinitions(this, function_declaration_lines);
    shaders_collection_controller.addBodyLines(this, body_lines);
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/gl/RgbToOklab.ts







const RgbToOklab_OUTPUT_NAME = "oklab";
class RgbToOklabGlParamsConfig extends params_ParamsConfig/* NodeParamsConfig */.yI {
  constructor() {
    super(...arguments);
    this.rgb = params_ParamsConfig/* ParamConfig.VECTOR3 */.XC.VECTOR3([1, 1, 1]);
  }
}
const RgbToOklab_ParamsConfig = new RgbToOklabGlParamsConfig();
class RgbToOklabGlNode extends gl_Base/* TypedGlNode */.hD {
  constructor() {
    super(...arguments);
    this.paramsConfig = RgbToOklab_ParamsConfig;
  }
  static type() {
    return "rgbToOklab";
  }
  initializeNode() {
    this.io.outputs.setNamedOutputConnectionPoints([
      new Gl/* GlConnectionPoint */.E(RgbToOklab_OUTPUT_NAME, Gl/* GlConnectionPointType.VEC3 */.Dv.VEC3)
    ]);
  }
  setLines(shaders_collection_controller) {
    const function_declaration_lines = [];
    const body_lines = [];
    function_declaration_lines.push(new GLDefinition/* FunctionGLDefinition */.MR(this, oklab));
    const rgb = ThreeToGl/* ThreeToGl.vector3 */._.vector3(this.variableForInputParam(this.p.rgb));
    const oklabOut = this.glVarName(RgbToOklab_OUTPUT_NAME);
    body_lines.push(`vec3 ${oklabOut} = oklab_from_linear_srgb(${rgb})`);
    shaders_collection_controller.addDefinitions(this, function_declaration_lines);
    shaders_collection_controller.addBodyLines(this, body_lines);
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/gl/Rotate.ts







var GlRotateMode = /* @__PURE__ */ ((GlRotateMode2) => {
  GlRotateMode2[GlRotateMode2["AXIS"] = 0] = "AXIS";
  GlRotateMode2[GlRotateMode2["QUAT"] = 1] = "QUAT";
  return GlRotateMode2;
})(GlRotateMode || {});
const Modes = [0 /* AXIS */, 1 /* QUAT */];
const LabelByMode = {
  [0 /* AXIS */]: "from axis + angle",
  [1 /* QUAT */]: "from quaternion"
};
const InputNamesByMode = {
  [0 /* AXIS */]: ["vector", "axis", "angle"],
  [1 /* QUAT */]: ["vector", "quat"]
};
const MethodNameByMode = {
  [0 /* AXIS */]: "rotateWithAxisAngle",
  [1 /* QUAT */]: "rotateWithQuat"
};
const InputTypesByMode = {
  [0 /* AXIS */]: [Gl/* GlConnectionPointType.VEC3 */.Dv.VEC3, Gl/* GlConnectionPointType.VEC3 */.Dv.VEC3, Gl/* GlConnectionPointType.FLOAT */.Dv.FLOAT],
  [1 /* QUAT */]: [Gl/* GlConnectionPointType.VEC3 */.Dv.VEC3, Gl/* GlConnectionPointType.VEC4 */.Dv.VEC4]
};
const Rotate_DefaultValues = {
  vector: [0, 0, 1],
  axis: [0, 1, 0]
};
class RotateParamsConfig extends params_ParamsConfig/* NodeParamsConfig */.yI {
  constructor() {
    super(...arguments);
    this.signature = params_ParamsConfig/* ParamConfig.INTEGER */.XC.INTEGER(0 /* AXIS */, {
      menu: {
        entries: Modes.map((mode, i) => {
          const label = LabelByMode[mode];
          return { name: label, value: i };
        })
      }
    });
  }
}
const Rotate_ParamsConfig = new RotateParamsConfig();
class RotateGlNode extends gl_Base/* TypedGlNode */.hD {
  constructor() {
    super(...arguments);
    this.paramsConfig = Rotate_ParamsConfig;
  }
  static type() {
    return "rotate";
  }
  initializeNode() {
    super.initializeNode();
    this.io.connection_points.set_expected_input_types_function(this._expectedInputTypes.bind(this));
    this.io.connection_points.set_expected_output_types_function(this._expectedOutputTypes.bind(this));
    this.io.connection_points.set_input_name_function(this._expectedInputName.bind(this));
  }
  setSignature(mode) {
    const index = Modes.indexOf(mode);
    this.p.signature.set(index);
  }
  mode() {
    return Modes[this.pv.signature] || 0 /* AXIS */;
  }
  _expectedInputName(index) {
    return InputNamesByMode[this.mode()][index];
  }
  paramDefaultValue(name) {
    return Rotate_DefaultValues[name];
  }
  functionName() {
    return MethodNameByMode[this.mode()];
  }
  _expectedInputTypes() {
    return InputTypesByMode[this.mode()];
  }
  _expectedOutputTypes() {
    return [Gl/* GlConnectionPointType.VEC3 */.Dv.VEC3];
  }
  functionDefinitions() {
    return [new GLDefinition/* FunctionGLDefinition */.MR(this, quaternion/* default */.Z)];
  }
  setLines(shadersCollectionController) {
    const connectionPoints = this.io.inputs.namedInputConnectionPoints();
    if (!connectionPoints) {
      return;
    }
    const varType = this._expectedInputTypes()[0];
    const args = connectionPoints.map((connection, i) => {
      const name = connection.name();
      return ThreeToGl/* ThreeToGl.any */._.any(this.variableForInput(name));
    });
    const joinedArgs = args.join(", ");
    const sum = this.glVarName(this.io.connection_points.output_name(0));
    const bodyLine = `${varType} ${sum} = ${this.functionName()}(${joinedArgs})`;
    shadersCollectionController.addBodyLines(this, [bodyLine]);
    shadersCollectionController.addDefinitions(this, this.functionDefinitions());
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/gl/Round.ts




const Round_ALL_COMPONENTS = ["x", "y", "z", "w"];
class RoundGlNode extends BaseNodeGlMathFunctionArg1GlNode {
  static type() {
    return "round";
  }
  // https://hub.jmonkeyengine.org/t/round-with-glsl/8186/6
  setLines(shadersCollectionController) {
    const namedInputConnectionPoints = this.io.inputs.namedInputConnectionPoints();
    const namedOutputConnectionPoints = this.io.outputs.namedOutputConnectionPoints();
    if (!(namedInputConnectionPoints && namedOutputConnectionPoints)) {
      return;
    }
    const inputConnection = namedInputConnectionPoints[0];
    const value = ThreeToGl/* ThreeToGl.vector2 */._.vector2(this.variableForInput(inputConnection.name()));
    const outputConnection = namedOutputConnectionPoints[0];
    const outputType = outputConnection.type();
    const varName = this.glVarName(outputConnection.name());
    const bodyLines = [];
    const linesCount = Gl/* GlConnectionPointComponentsCountMap */.Od[outputType];
    if (linesCount == 1) {
      bodyLines.push(`${outputType} ${varName} = ${this._singleLine(value)}`);
    } else {
      const singleLines = Round_ALL_COMPONENTS.slice(0, linesCount).map((c) => {
        return this._singleLine(`${value}.${c}`);
      });
      bodyLines.push(`${outputType} ${varName} = ${outputType}(${singleLines.join(",")})`);
    }
    shadersCollectionController.addBodyLines(this, bodyLines);
  }
  _singleLine(value) {
    return `sign(${value})*floor(abs(${value})+0.5)`;
  }
}

// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/nodes/gl/gl/raymarching/sdfCommon.glsl
var sdfCommon = __webpack_require__(25864);
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/gl/gl/raymarching/sdf2D.glsl
/* harmony default export */ var sdf2D = ("float sdBox( in vec2 p, in vec2 b )\n{\n\tvec2 d = abs(p)-b;\n\treturn length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\nfloat sdCircle( vec2 p, float r )\n{\n\treturn length(p) - r;\n}\nfloat sdHeart( in vec2 p )\n{\n\tp.x = abs(p.x);\n\n\tif( p.y+p.x>1.0 )\n\t\treturn sqrt(dot2(p-vec2(0.25,0.75))) - sqrt(2.0)/4.0;\n\treturn sqrt(min(dot2(p-vec2(0.00,1.00)),\n\t\t\t\t\tdot2(p-0.5*max(p.x+p.y,0.0)))) * sign(p.x-p.y);\n}\nfloat sdCross( in vec2 p, in vec2 b, float r ) \n{\n\tp = abs(p); p = (p.y>p.x) ? p.yx : p.xy;\n\tvec2  q = p - b;\n\tfloat k = max(q.y,q.x);\n\tvec2  w = (k>0.0) ? q : vec2(b.y-p.x,-k);\n\treturn sign(k)*length(max(w,0.0)) + r;\n}\nfloat sdRoundedX( in vec2 p, in float w, in float r )\n{\n\tp = abs(p);\n\treturn length(p-min(p.x+p.y,w)*0.5) - r;\n}\nfloat sdStairs( in vec2 p, in vec2 wh, in float n )\n{\n\tvec2 ba = wh*n;\n\tfloat d = min(dot2(p-vec2(clamp(p.x,0.0,ba.x),0.0)), \n\t\t\t\t  dot2(p-vec2(ba.x,clamp(p.y,0.0,ba.y))) );\n\tfloat s = sign(max(-p.y,p.x-ba.x) );\n\n\tfloat dia = length(wh);\n\tp = mat2(wh.x,-wh.y, wh.y,wh.x)*p/dia;\n\tfloat id = clamp(round(p.x/dia),0.0,n-1.0);\n\tp.x = p.x - id*dia;\n\tp = mat2(wh.x, wh.y,-wh.y,wh.x)*p/dia;\n\n\tfloat hh = wh.y/2.0;\n\tp.y -= hh;\n\tif( p.y>hh*sign(p.x) ) s=1.0;\n\tp = (id<0.5 || p.x>0.0) ? p : -p;\n\td = min( d, dot2(p-vec2(0.0,clamp(p.y,-hh,hh))) );\n\td = min( d, dot2(p-vec2(clamp(p.x,0.0,wh.x),hh)) );\n\t\t\n\treturn sqrt(d)*s;\n}\n\nfloat SDFExtrudeX( in vec3 p, in float sdf, in float h )\n{\n\tvec2 w = vec2( sdf, abs(p.x) - h );\n\treturn min(max(w.x,w.y),0.0) + length(max(w,0.0));\n}\nfloat SDFExtrudeY( in vec3 p, in float sdf, in float h )\n{\n\tvec2 w = vec2( sdf, abs(p.y) - h );\n\treturn min(max(w.x,w.y),0.0) + length(max(w,0.0));\n}\nfloat SDFExtrudeZ( in vec3 p, in float sdf, in float h )\n{\n\tvec2 w = vec2( sdf, abs(p.z) - h );\n\treturn min(max(w.x,w.y),0.0) + length(max(w,0.0));\n}\n\nvec2 SDFRevolutionX( in vec3 p, float o )\n{\n\treturn vec2( length(p.yz) - o, p.x );\n}\nvec2 SDFRevolutionY( in vec3 p, float o )\n{\n\treturn vec2( length(p.xz) - o, p.y );\n}\nvec2 SDFRevolutionZ( in vec3 p, float o )\n{\n\treturn vec2( length(p.xy) - o, p.z );\n}");
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/gl/_BaseSDF2D.ts







const _BaseSDF2D_VARS = {
  position: "p.xy"
};
class BaseSDF2DGlParamsConfig extends (/* unused pure expression or super */ null && (NodeParamsConfig)) {
  constructor() {
    super(...arguments);
    this.position = ParamConfig.VECTOR2([0, 0]);
  }
}
class BaseSDF2DGlNode extends gl_Base/* TypedGlNode */.hD {
  position() {
    const inputPosition = this.io.inputs.named_input(this.p.position.name());
    const position = inputPosition ? ThreeToGl/* ThreeToGl.vector2 */._.vector2(this.variableForInputParam(this.p.position)) : this._defaultPosition();
    return position;
  }
  _defaultPosition() {
    return _BaseSDF2D_VARS.position;
  }
  _addSDF2DMethods(shadersCollectionController) {
    shadersCollectionController.addDefinitions(this, [new GLDefinition/* FunctionGLDefinition */.MR(this, sdfCommon/* default */.Z)]);
    shadersCollectionController.addDefinitions(this, [new GLDefinition/* FunctionGLDefinition */.MR(this, sdf2D)]);
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/gl/SDF2DBox.ts






const SDF2DBox_OUTPUT_NAME = "float";
class SDF2DBoxGlParamsConfig extends params_ParamsConfig/* NodeParamsConfig */.yI {
  constructor() {
    super(...arguments);
    this.position = params_ParamsConfig/* ParamConfig.VECTOR2 */.XC.VECTOR2([0, 0], { hidden: true });
    this.center = params_ParamsConfig/* ParamConfig.VECTOR2 */.XC.VECTOR2([0, 0]);
    this.size = params_ParamsConfig/* ParamConfig.VECTOR2 */.XC.VECTOR2([1, 1]);
  }
}
const SDF2DBox_ParamsConfig = new SDF2DBoxGlParamsConfig();
class SDF2DBoxGlNode extends BaseSDF2DGlNode {
  constructor() {
    super(...arguments);
    this.paramsConfig = SDF2DBox_ParamsConfig;
  }
  static type() {
    return types_Gl/* GlType.SDF_2D_BOX */.P.SDF_2D_BOX;
  }
  initializeNode() {
    super.initializeNode();
    this.io.outputs.setNamedOutputConnectionPoints([
      new Gl/* GlConnectionPoint */.E(SDF2DBox_OUTPUT_NAME, Gl/* GlConnectionPointType.FLOAT */.Dv.FLOAT)
    ]);
  }
  setLines(shadersCollectionController) {
    const position = this.position();
    const center = ThreeToGl/* ThreeToGl.vector3 */._.vector3(this.variableForInputParam(this.p.center));
    const size = ThreeToGl/* ThreeToGl.vector2 */._.vector2(this.variableForInputParam(this.p.size));
    const float = this.glVarName(SDF2DBox_OUTPUT_NAME);
    const bodyLine = `float ${float} = sdBox(${position} - ${center}, ${size})`;
    shadersCollectionController.addBodyLines(this, [bodyLine]);
    this._addSDF2DMethods(shadersCollectionController);
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/gl/SDF2DCircle.ts






const SDF2DCircle_OUTPUT_NAME = "float";
class SDF2DCircleGlParamsConfig extends params_ParamsConfig/* NodeParamsConfig */.yI {
  constructor() {
    super(...arguments);
    this.position = params_ParamsConfig/* ParamConfig.VECTOR2 */.XC.VECTOR2([0, 0], { hidden: true });
    this.center = params_ParamsConfig/* ParamConfig.VECTOR2 */.XC.VECTOR2([0, 0]);
    this.radius = params_ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(1);
  }
}
const SDF2DCircle_ParamsConfig = new SDF2DCircleGlParamsConfig();
class SDF2DCircleGlNode extends BaseSDF2DGlNode {
  constructor() {
    super(...arguments);
    this.paramsConfig = SDF2DCircle_ParamsConfig;
  }
  static type() {
    return types_Gl/* GlType.SDF_2D_CIRCLE */.P.SDF_2D_CIRCLE;
  }
  initializeNode() {
    super.initializeNode();
    this.io.outputs.setNamedOutputConnectionPoints([
      new Gl/* GlConnectionPoint */.E(SDF2DCircle_OUTPUT_NAME, Gl/* GlConnectionPointType.FLOAT */.Dv.FLOAT)
    ]);
  }
  setLines(shadersCollectionController) {
    const position = this.position();
    const center = ThreeToGl/* ThreeToGl.vector3 */._.vector3(this.variableForInputParam(this.p.center));
    const radius = ThreeToGl/* ThreeToGl.float */._.float(this.variableForInputParam(this.p.radius));
    const float = this.glVarName(SDF2DCircle_OUTPUT_NAME);
    const bodyLine = `float ${float} = sdCircle(${position} - ${center}, ${radius})`;
    shadersCollectionController.addBodyLines(this, [bodyLine]);
    this._addSDF2DMethods(shadersCollectionController);
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/gl/SDF2DCross.ts






const SDF2DCross_OUTPUT_NAME = "float";
class SDF2DCrossGlParamsConfig extends params_ParamsConfig/* NodeParamsConfig */.yI {
  constructor() {
    super(...arguments);
    this.position = params_ParamsConfig/* ParamConfig.VECTOR2 */.XC.VECTOR2([0, 0], { hidden: true });
    this.center = params_ParamsConfig/* ParamConfig.VECTOR2 */.XC.VECTOR2([0, 0]);
    this.length = params_ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(1);
    this.width = params_ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(0.3);
    this.radius = params_ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(0, {
      range: [-1, 1]
    });
  }
}
const SDF2DCross_ParamsConfig = new SDF2DCrossGlParamsConfig();
class SDF2DCrossGlNode extends BaseSDF2DGlNode {
  constructor() {
    super(...arguments);
    this.paramsConfig = SDF2DCross_ParamsConfig;
  }
  static type() {
    return types_Gl/* GlType.SDF_2D_CROSS */.P.SDF_2D_CROSS;
  }
  initializeNode() {
    super.initializeNode();
    this.io.outputs.setNamedOutputConnectionPoints([
      new Gl/* GlConnectionPoint */.E(SDF2DCross_OUTPUT_NAME, Gl/* GlConnectionPointType.FLOAT */.Dv.FLOAT)
    ]);
  }
  setLines(shadersCollectionController) {
    const position = this.position();
    const center = ThreeToGl/* ThreeToGl.vector3 */._.vector3(this.variableForInputParam(this.p.center));
    const length = ThreeToGl/* ThreeToGl.float */._.float(this.variableForInputParam(this.p.length));
    const width = ThreeToGl/* ThreeToGl.float */._.float(this.variableForInputParam(this.p.width));
    const radius = ThreeToGl/* ThreeToGl.float */._.float(this.variableForInputParam(this.p.radius));
    const float = this.glVarName(SDF2DCross_OUTPUT_NAME);
    const bodyLine = `float ${float} = sdCross(${position} - ${center}, vec2(${length}, ${width}), ${radius})`;
    shadersCollectionController.addBodyLines(this, [bodyLine]);
    this._addSDF2DMethods(shadersCollectionController);
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/gl/SDF2DHeart.ts






const SDF2DHeart_OUTPUT_NAME = "float";
class SDF2DHeartGlParamsConfig extends params_ParamsConfig/* NodeParamsConfig */.yI {
  constructor() {
    super(...arguments);
    this.position = params_ParamsConfig/* ParamConfig.VECTOR2 */.XC.VECTOR2([0, 0], { hidden: true });
    this.center = params_ParamsConfig/* ParamConfig.VECTOR2 */.XC.VECTOR2([0, 0]);
  }
}
const SDF2DHeart_ParamsConfig = new SDF2DHeartGlParamsConfig();
class SDF2DHeartGlNode extends BaseSDF2DGlNode {
  constructor() {
    super(...arguments);
    this.paramsConfig = SDF2DHeart_ParamsConfig;
  }
  static type() {
    return types_Gl/* GlType.SDF_2D_HEART */.P.SDF_2D_HEART;
  }
  initializeNode() {
    super.initializeNode();
    this.io.outputs.setNamedOutputConnectionPoints([
      new Gl/* GlConnectionPoint */.E(SDF2DHeart_OUTPUT_NAME, Gl/* GlConnectionPointType.FLOAT */.Dv.FLOAT)
    ]);
  }
  setLines(shadersCollectionController) {
    const position = this.position();
    const center = ThreeToGl/* ThreeToGl.vector3 */._.vector3(this.variableForInputParam(this.p.center));
    const float = this.glVarName(SDF2DHeart_OUTPUT_NAME);
    const bodyLine = `float ${float} = sdHeart(${position} - ${center})`;
    shadersCollectionController.addBodyLines(this, [bodyLine]);
    this._addSDF2DMethods(shadersCollectionController);
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/gl/SDF2DRoundedX.ts






const SDF2DRoundedX_OUTPUT_NAME = "float";
class SDF2DRoundedXGlParamsConfig extends params_ParamsConfig/* NodeParamsConfig */.yI {
  constructor() {
    super(...arguments);
    this.position = params_ParamsConfig/* ParamConfig.VECTOR2 */.XC.VECTOR2([0, 0], { hidden: true });
    this.center = params_ParamsConfig/* ParamConfig.VECTOR2 */.XC.VECTOR2([0, 0]);
    this.length = params_ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(1);
    this.radius = params_ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(0.1);
  }
}
const SDF2DRoundedX_ParamsConfig = new SDF2DRoundedXGlParamsConfig();
class SDF2DRoundedXGlNode extends BaseSDF2DGlNode {
  constructor() {
    super(...arguments);
    this.paramsConfig = SDF2DRoundedX_ParamsConfig;
  }
  static type() {
    return types_Gl/* GlType.SDF_2D_ROUNDED_X */.P.SDF_2D_ROUNDED_X;
  }
  initializeNode() {
    super.initializeNode();
    this.io.outputs.setNamedOutputConnectionPoints([
      new Gl/* GlConnectionPoint */.E(SDF2DRoundedX_OUTPUT_NAME, Gl/* GlConnectionPointType.FLOAT */.Dv.FLOAT)
    ]);
  }
  setLines(shadersCollectionController) {
    const position = this.position();
    const center = ThreeToGl/* ThreeToGl.vector3 */._.vector3(this.variableForInputParam(this.p.center));
    const length = ThreeToGl/* ThreeToGl.float */._.float(this.variableForInputParam(this.p.length));
    const radius = ThreeToGl/* ThreeToGl.float */._.float(this.variableForInputParam(this.p.radius));
    const float = this.glVarName(SDF2DRoundedX_OUTPUT_NAME);
    const bodyLine = `float ${float} = sdRoundedX(${position} - ${center}, ${length}, ${radius})`;
    shadersCollectionController.addBodyLines(this, [bodyLine]);
    this._addSDF2DMethods(shadersCollectionController);
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/gl/SDF2DStairs.ts






const SDF2DStairs_OUTPUT_NAME = "float";
class SDF2DStairsGlParamsConfig extends params_ParamsConfig/* NodeParamsConfig */.yI {
  constructor() {
    super(...arguments);
    this.position = params_ParamsConfig/* ParamConfig.VECTOR2 */.XC.VECTOR2([0, 0], { hidden: true });
    this.center = params_ParamsConfig/* ParamConfig.VECTOR2 */.XC.VECTOR2([0, 0]);
    this.width = params_ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(1);
    this.height = params_ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(1);
    this.steps = params_ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(5, {
      range: [0, 10],
      rangeLocked: [true, false]
    });
  }
}
const SDF2DStairs_ParamsConfig = new SDF2DStairsGlParamsConfig();
class SDF2DStairsGlNode extends BaseSDF2DGlNode {
  constructor() {
    super(...arguments);
    this.paramsConfig = SDF2DStairs_ParamsConfig;
  }
  static type() {
    return types_Gl/* GlType.SDF_2D_STAIRS */.P.SDF_2D_STAIRS;
  }
  initializeNode() {
    super.initializeNode();
    this.io.outputs.setNamedOutputConnectionPoints([
      new Gl/* GlConnectionPoint */.E(SDF2DStairs_OUTPUT_NAME, Gl/* GlConnectionPointType.FLOAT */.Dv.FLOAT)
    ]);
  }
  setLines(shadersCollectionController) {
    const position = this.position();
    const center = ThreeToGl/* ThreeToGl.vector3 */._.vector3(this.variableForInputParam(this.p.center));
    const width = ThreeToGl/* ThreeToGl.float */._.float(this.variableForInputParam(this.p.width));
    const height = ThreeToGl/* ThreeToGl.float */._.float(this.variableForInputParam(this.p.height));
    const steps = ThreeToGl/* ThreeToGl.float */._.float(this.variableForInputParam(this.p.steps));
    const float = this.glVarName(SDF2DStairs_OUTPUT_NAME);
    const bodyLine = `float ${float} = sdStairs(${position} - ${center}, vec2(${width}, ${height}), ${steps})`;
    shadersCollectionController.addBodyLines(this, [bodyLine]);
    this._addSDF2DMethods(shadersCollectionController);
  }
}

// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/nodes/gl/_BaseSDF.ts + 1 modules
var _BaseSDF = __webpack_require__(79952);
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/gl/SDFBox.ts






const SDFBox_OUTPUT_NAME = "float";
class SDFBoxGlParamsConfig extends params_ParamsConfig/* NodeParamsConfig */.yI {
  constructor() {
    super(...arguments);
    this.position = params_ParamsConfig/* ParamConfig.VECTOR3 */.XC.VECTOR3([0, 0, 0], { hidden: true });
    this.center = params_ParamsConfig/* ParamConfig.VECTOR3 */.XC.VECTOR3([0, 0, 0]);
    this.size = params_ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(1);
    this.sizes = params_ParamsConfig/* ParamConfig.VECTOR3 */.XC.VECTOR3([1, 1, 1]);
  }
}
const SDFBox_ParamsConfig = new SDFBoxGlParamsConfig();
class SDFBoxGlNode extends _BaseSDF/* BaseSDFGlNode */.s {
  constructor() {
    super(...arguments);
    this.paramsConfig = SDFBox_ParamsConfig;
  }
  static type() {
    return types_Gl/* GlType.SDF_BOX */.P.SDF_BOX;
  }
  initializeNode() {
    super.initializeNode();
    this.io.outputs.setNamedOutputConnectionPoints([
      new Gl/* GlConnectionPoint */.E(SDFBox_OUTPUT_NAME, Gl/* GlConnectionPointType.FLOAT */.Dv.FLOAT)
    ]);
  }
  setLines(shadersCollectionController) {
    const position = this.position();
    const center = ThreeToGl/* ThreeToGl.vector3 */._.vector3(this.variableForInputParam(this.p.center));
    const size = ThreeToGl/* ThreeToGl.float */._.float(this.variableForInputParam(this.p.size));
    const sizes = ThreeToGl/* ThreeToGl.vector3 */._.vector3(this.variableForInputParam(this.p.sizes));
    const float = this.glVarName(SDFBox_OUTPUT_NAME);
    const bodyLine = `float ${float} = sdBox(${position} - ${center}, ${sizes}*${size})`;
    shadersCollectionController.addBodyLines(this, [bodyLine]);
    this._addSDFMethods(shadersCollectionController);
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/gl/SDFBoxFrame.ts






const SDFBoxFrame_OUTPUT_NAME = "float";
class SDFBoxFrameGlParamsConfig extends params_ParamsConfig/* NodeParamsConfig */.yI {
  constructor() {
    super(...arguments);
    this.position = params_ParamsConfig/* ParamConfig.VECTOR3 */.XC.VECTOR3([0, 0, 0], { hidden: true });
    this.center = params_ParamsConfig/* ParamConfig.VECTOR3 */.XC.VECTOR3([0, 0, 0]);
    this.size = params_ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(1);
    this.sizes = params_ParamsConfig/* ParamConfig.VECTOR3 */.XC.VECTOR3([1, 1, 1]);
    this.width = params_ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(0.1);
  }
}
const SDFBoxFrame_ParamsConfig = new SDFBoxFrameGlParamsConfig();
class SDFBoxFrameGlNode extends _BaseSDF/* BaseSDFGlNode */.s {
  constructor() {
    super(...arguments);
    this.paramsConfig = SDFBoxFrame_ParamsConfig;
  }
  static type() {
    return types_Gl/* GlType.SDF_BOX_FRAME */.P.SDF_BOX_FRAME;
  }
  initializeNode() {
    super.initializeNode();
    this.io.outputs.setNamedOutputConnectionPoints([
      new Gl/* GlConnectionPoint */.E(SDFBoxFrame_OUTPUT_NAME, Gl/* GlConnectionPointType.FLOAT */.Dv.FLOAT)
    ]);
  }
  setLines(shadersCollectionController) {
    const position = this.position();
    const center = ThreeToGl/* ThreeToGl.vector3 */._.vector3(this.variableForInputParam(this.p.center));
    const size = ThreeToGl/* ThreeToGl.float */._.float(this.variableForInputParam(this.p.size));
    const sizes = ThreeToGl/* ThreeToGl.vector3 */._.vector3(this.variableForInputParam(this.p.sizes));
    const width = ThreeToGl/* ThreeToGl.vector3 */._.vector3(this.variableForInputParam(this.p.width));
    const float = this.glVarName(SDFBoxFrame_OUTPUT_NAME);
    const bodyLine = `float ${float} = sdBoxFrame(${position} - ${center}, ${sizes}*${size}, ${width})`;
    shadersCollectionController.addBodyLines(this, [bodyLine]);
    this._addSDFMethods(shadersCollectionController);
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/gl/SDFBoxRound.ts






const SDFBoxRound_OUTPUT_NAME = "float";
class SDFBoxRoundGlParamsConfig extends params_ParamsConfig/* NodeParamsConfig */.yI {
  constructor() {
    super(...arguments);
    this.position = params_ParamsConfig/* ParamConfig.VECTOR3 */.XC.VECTOR3([0, 0, 0], { hidden: true });
    this.center = params_ParamsConfig/* ParamConfig.VECTOR3 */.XC.VECTOR3([0, 0, 0]);
    this.size = params_ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(1);
    this.sizes = params_ParamsConfig/* ParamConfig.VECTOR3 */.XC.VECTOR3([1, 1, 1]);
    this.radius = params_ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(0.1);
  }
}
const SDFBoxRound_ParamsConfig = new SDFBoxRoundGlParamsConfig();
class SDFBoxRoundGlNode extends _BaseSDF/* BaseSDFGlNode */.s {
  constructor() {
    super(...arguments);
    this.paramsConfig = SDFBoxRound_ParamsConfig;
  }
  static type() {
    return types_Gl/* GlType.SDF_BOX_ROUND */.P.SDF_BOX_ROUND;
  }
  initializeNode() {
    super.initializeNode();
    this.io.outputs.setNamedOutputConnectionPoints([
      new Gl/* GlConnectionPoint */.E(SDFBoxRound_OUTPUT_NAME, Gl/* GlConnectionPointType.FLOAT */.Dv.FLOAT)
    ]);
  }
  setLines(shadersCollectionController) {
    const position = this.position();
    const center = ThreeToGl/* ThreeToGl.vector3 */._.vector3(this.variableForInputParam(this.p.center));
    const size = ThreeToGl/* ThreeToGl.float */._.float(this.variableForInputParam(this.p.size));
    const sizes = ThreeToGl/* ThreeToGl.vector3 */._.vector3(this.variableForInputParam(this.p.sizes));
    const radius = ThreeToGl/* ThreeToGl.float */._.float(this.variableForInputParam(this.p.radius));
    const float = this.glVarName(SDFBoxRound_OUTPUT_NAME);
    const bodyLine = `float ${float} = sdRoundBox(${position} - ${center}, ${sizes}*${size}, ${radius})`;
    shadersCollectionController.addBodyLines(this, [bodyLine]);
    this._addSDFMethods(shadersCollectionController);
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/gl/SDFCapsule.ts






const SDFCapsule_OUTPUT_NAME = "float";
class SDFCapsuleGlParamsConfig extends params_ParamsConfig/* NodeParamsConfig */.yI {
  constructor() {
    super(...arguments);
    this.position = params_ParamsConfig/* ParamConfig.VECTOR3 */.XC.VECTOR3([0, 0, 0], { hidden: true });
    this.center = params_ParamsConfig/* ParamConfig.VECTOR3 */.XC.VECTOR3([0, 0, 0]);
    this.start = params_ParamsConfig/* ParamConfig.VECTOR3 */.XC.VECTOR3([0, 0, 0]);
    this.end = params_ParamsConfig/* ParamConfig.VECTOR3 */.XC.VECTOR3([0, 1, 0]);
    this.radius = params_ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(0.2, {
      range: [0, 1],
      rangeLocked: [true, false],
      step: 1e-5
    });
  }
}
const SDFCapsule_ParamsConfig = new SDFCapsuleGlParamsConfig();
class SDFCapsuleGlNode extends _BaseSDF/* BaseSDFGlNode */.s {
  constructor() {
    super(...arguments);
    this.paramsConfig = SDFCapsule_ParamsConfig;
  }
  static type() {
    return types_Gl/* GlType.SDF_CAPSULE */.P.SDF_CAPSULE;
  }
  initializeNode() {
    super.initializeNode();
    this.io.outputs.setNamedOutputConnectionPoints([
      new Gl/* GlConnectionPoint */.E(SDFCapsule_OUTPUT_NAME, Gl/* GlConnectionPointType.FLOAT */.Dv.FLOAT)
    ]);
  }
  setLines(shadersCollectionController) {
    const position = this.position();
    const center = ThreeToGl/* ThreeToGl.vector3 */._.vector3(this.variableForInputParam(this.p.center));
    const startPos = ThreeToGl/* ThreeToGl.vector3 */._.vector3(this.variableForInputParam(this.p.start));
    const endPos = ThreeToGl/* ThreeToGl.vector3 */._.vector3(this.variableForInputParam(this.p.end));
    const radius = ThreeToGl/* ThreeToGl.vector2 */._.vector2(this.variableForInputParam(this.p.radius));
    const float = this.glVarName(SDFCapsule_OUTPUT_NAME);
    const bodyLine = `float ${float} = sdCapsule(${position} - ${center}, ${startPos}, ${endPos}, ${radius})`;
    shadersCollectionController.addBodyLines(this, [bodyLine]);
    this._addSDFMethods(shadersCollectionController);
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/gl/SDFCapsuleVertical.ts






const SDFCapsuleVertical_OUTPUT_NAME = "float";
class SDFCapsuleVerticalGlParamsConfig extends params_ParamsConfig/* NodeParamsConfig */.yI {
  constructor() {
    super(...arguments);
    this.position = params_ParamsConfig/* ParamConfig.VECTOR3 */.XC.VECTOR3([0, 0, 0], { hidden: true });
    this.center = params_ParamsConfig/* ParamConfig.VECTOR3 */.XC.VECTOR3([0, 0, 0]);
    this.height = params_ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(1);
    this.radius = params_ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(0.2, {
      range: [0, 1],
      rangeLocked: [true, false],
      step: 1e-5
    });
  }
}
const SDFCapsuleVertical_ParamsConfig = new SDFCapsuleVerticalGlParamsConfig();
class SDFCapsuleVerticalGlNode extends _BaseSDF/* BaseSDFGlNode */.s {
  constructor() {
    super(...arguments);
    this.paramsConfig = SDFCapsuleVertical_ParamsConfig;
  }
  static type() {
    return types_Gl/* GlType.SDF_CAPSULE_VERTICAL */.P.SDF_CAPSULE_VERTICAL;
  }
  initializeNode() {
    super.initializeNode();
    this.io.outputs.setNamedOutputConnectionPoints([
      new Gl/* GlConnectionPoint */.E(SDFCapsuleVertical_OUTPUT_NAME, Gl/* GlConnectionPointType.FLOAT */.Dv.FLOAT)
    ]);
  }
  setLines(shadersCollectionController) {
    const position = this.position();
    const center = ThreeToGl/* ThreeToGl.vector3 */._.vector3(this.variableForInputParam(this.p.center));
    const height = ThreeToGl/* ThreeToGl.float */._.float(this.variableForInputParam(this.p.height));
    const radius = ThreeToGl/* ThreeToGl.float */._.float(this.variableForInputParam(this.p.radius));
    const float = this.glVarName(SDFCapsuleVertical_OUTPUT_NAME);
    const bodyLine = `float ${float} = sdVerticalCapsule(${position} - ${center}, ${height}, ${radius})`;
    shadersCollectionController.addBodyLines(this, [bodyLine]);
    this._addSDFMethods(shadersCollectionController);
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/gl/SDFCone.ts






const SDFCone_OUTPUT_NAME = "float";
class SDFConeGlParamsConfig extends params_ParamsConfig/* NodeParamsConfig */.yI {
  constructor() {
    super(...arguments);
    this.position = params_ParamsConfig/* ParamConfig.VECTOR3 */.XC.VECTOR3([0, 0, 0], { hidden: true });
    this.center = params_ParamsConfig/* ParamConfig.VECTOR3 */.XC.VECTOR3([0, 0, 0]);
    this.height = params_ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(1);
    this.angle = params_ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(0.25 * Math.PI, {
      range: [0, Math.PI],
      rangeLocked: [true, false],
      step: 1e-5
    });
  }
}
const SDFCone_ParamsConfig = new SDFConeGlParamsConfig();
class SDFConeGlNode extends _BaseSDF/* BaseSDFGlNode */.s {
  constructor() {
    super(...arguments);
    this.paramsConfig = SDFCone_ParamsConfig;
  }
  static type() {
    return types_Gl/* GlType.SDF_CONE */.P.SDF_CONE;
  }
  initializeNode() {
    super.initializeNode();
    this.io.outputs.setNamedOutputConnectionPoints([
      new Gl/* GlConnectionPoint */.E(SDFCone_OUTPUT_NAME, Gl/* GlConnectionPointType.FLOAT */.Dv.FLOAT)
    ]);
  }
  setLines(shadersCollectionController) {
    const position = this.position();
    const center = ThreeToGl/* ThreeToGl.vector3 */._.vector3(this.variableForInputParam(this.p.center));
    const angle = ThreeToGl/* ThreeToGl.vector2 */._.vector2(this.variableForInputParam(this.p.angle));
    const height = ThreeToGl/* ThreeToGl.float */._.float(this.variableForInputParam(this.p.height));
    const float = this.glVarName(SDFCone_OUTPUT_NAME);
    const bodyLine = `float ${float} = sdConeWrapped(${position} - ${center}, ${angle}, ${height})`;
    shadersCollectionController.addBodyLines(this, [bodyLine]);
    this._addSDFMethods(shadersCollectionController);
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/gl/SDFConeRound.ts






const SDFConeRound_OUTPUT_NAME = "float";
class SDFConeRoundGlParamsConfig extends params_ParamsConfig/* NodeParamsConfig */.yI {
  constructor() {
    super(...arguments);
    this.position = params_ParamsConfig/* ParamConfig.VECTOR3 */.XC.VECTOR3([0, 0, 0], { hidden: true });
    this.center = params_ParamsConfig/* ParamConfig.VECTOR3 */.XC.VECTOR3([0, 0, 0]);
    this.height = params_ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(1);
    this.radius1 = params_ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(0.5);
    this.radius2 = params_ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(0.2);
  }
}
const SDFConeRound_ParamsConfig = new SDFConeRoundGlParamsConfig();
class SDFConeRoundGlNode extends _BaseSDF/* BaseSDFGlNode */.s {
  constructor() {
    super(...arguments);
    this.paramsConfig = SDFConeRound_ParamsConfig;
  }
  static type() {
    return types_Gl/* GlType.SDF_CONE_ROUND */.P.SDF_CONE_ROUND;
  }
  initializeNode() {
    super.initializeNode();
    this.io.outputs.setNamedOutputConnectionPoints([
      new Gl/* GlConnectionPoint */.E(SDFConeRound_OUTPUT_NAME, Gl/* GlConnectionPointType.FLOAT */.Dv.FLOAT)
    ]);
  }
  setLines(shadersCollectionController) {
    const position = this.position();
    const center = ThreeToGl/* ThreeToGl.vector3 */._.vector3(this.variableForInputParam(this.p.center));
    const height = ThreeToGl/* ThreeToGl.float */._.float(this.variableForInputParam(this.p.height));
    const radius1 = ThreeToGl/* ThreeToGl.float */._.float(this.variableForInputParam(this.p.radius1));
    const radius2 = ThreeToGl/* ThreeToGl.float */._.float(this.variableForInputParam(this.p.radius2));
    const float = this.glVarName(SDFConeRound_OUTPUT_NAME);
    const bodyLine = `float ${float} = sdRoundCone(${position} - ${center}, ${radius1}, ${radius2}, ${height})`;
    shadersCollectionController.addBodyLines(this, [bodyLine]);
    this._addSDFMethods(shadersCollectionController);
  }
}

// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/nodes/gl/SDFMaterial.ts + 3 modules
var SDFMaterial = __webpack_require__(45135);
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/gl/SDFContext.ts







const SDFContext_INPUT_NAME = {
  SDF: "sdf",
  MATERIAL: "material"
};
const SDFContext_OUTPUT_NAME = types_Gl/* GlType.SDF_CONTEXT */.P.SDF_CONTEXT;
class SDFContextGlParamsConfig extends params_ParamsConfig/* NodeParamsConfig */.yI {
}
const SDFContext_ParamsConfig = new SDFContextGlParamsConfig();
class SDFContextGlNode extends gl_Base/* TypedGlNode */.hD {
  constructor() {
    super(...arguments);
    this.paramsConfig = SDFContext_ParamsConfig;
  }
  static type() {
    return types_Gl/* GlType.SDF_CONTEXT */.P.SDF_CONTEXT;
  }
  initializeNode() {
    super.initializeNode();
    this.io.connection_points.set_expected_input_types_function(this._expectedInputTypes.bind(this));
    this.io.connection_points.set_input_name_function(this._glInputNames.bind(this));
    this.io.connection_points.set_expected_output_types_function(this._expectedOutputTypes.bind(this));
    this.io.connection_points.set_output_name_function(this._glOutputNames.bind(this));
  }
  _expectedInputTypes() {
    return [Gl/* GlConnectionPointType.FLOAT */.Dv.FLOAT, Gl/* GlConnectionPointType.SDF_MATERIAL */.Dv.SDF_MATERIAL];
  }
  _expectedOutputTypes() {
    return [Gl/* GlConnectionPointType.SDF_CONTEXT */.Dv.SDF_CONTEXT];
  }
  _glInputNames(i) {
    return [SDFContext_INPUT_NAME.SDF, SDFContext_INPUT_NAME.MATERIAL][i];
  }
  _glOutputNames(i) {
    return [SDFContext_OUTPUT_NAME][i];
  }
  setLines(shaders_collection_controller) {
    const sdf = ThreeToGl/* ThreeToGl.float */._.float(this.variableForInput(SDFContext_INPUT_NAME.SDF));
    const materialNode = this.io.inputs.input(1);
    let matId = -1;
    if (materialNode && materialNode instanceof SDFMaterial/* SDFMaterialGlNode */.K) {
      matId = materialNode.materialIdName();
    }
    const sdfContext = this.glVarName(SDFContext_OUTPUT_NAME);
    const body_line = `SDFContext ${sdfContext} = SDFContext(${sdf}, 0, ${matId}, ${matId}, 0.)`;
    shaders_collection_controller.addBodyLines(this, [body_line]);
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/gl/SDFElongate.ts







const SDFElongate_OUTPUT_NAME = "p";
class SDFElongateGlParamsConfig extends params_ParamsConfig/* NodeParamsConfig */.yI {
  constructor() {
    super(...arguments);
    this.position = params_ParamsConfig/* ParamConfig.VECTOR3 */.XC.VECTOR3([0, 0, 0], { hidden: true });
    this.center = params_ParamsConfig/* ParamConfig.VECTOR3 */.XC.VECTOR3([0, 0, 0]);
    this.mult = params_ParamsConfig/* ParamConfig.VECTOR3 */.XC.VECTOR3([0, 0, 0]);
    this.fast = params_ParamsConfig/* ParamConfig.BOOLEAN */.XC.BOOLEAN(1);
  }
}
const SDFElongate_ParamsConfig = new SDFElongateGlParamsConfig();
class SDFElongateGlNode extends _BaseSDF/* BaseSDFGlNode */.s {
  constructor() {
    super(...arguments);
    this.paramsConfig = SDFElongate_ParamsConfig;
  }
  static type() {
    return types_Gl/* GlType.SDF_ELONGATE */.P.SDF_ELONGATE;
  }
  initializeNode() {
    super.initializeNode();
    this.io.connection_points.spare_params.setInputlessParamNames(["fast"]);
    this.io.outputs.setNamedOutputConnectionPoints([
      new Gl/* GlConnectionPoint */.E(SDFElongate_OUTPUT_NAME, Gl/* GlConnectionPointType.VEC3 */.Dv.VEC3)
    ]);
  }
  setLines(shadersCollectionController) {
    const position = this.position();
    const center = ThreeToGl/* ThreeToGl.vector3 */._.vector3(this.variableForInputParam(this.p.center));
    const mult = ThreeToGl/* ThreeToGl.vector3 */._.vector3(this.variableForInputParam(this.p.mult));
    const out = this.glVarName(SDFElongate_OUTPUT_NAME);
    const functionName = (0,Type/* isBooleanTrue */.bI)(this.pv.fast) ? "SDFElongateFast" : "SDFElongateSlow";
    const suffix = (0,Type/* isBooleanTrue */.bI)(this.pv.fast) ? ".xyz" : ".xyz";
    const bodyLine = `vec3 ${out} = ${functionName}(${position} - ${center}, ${mult})${suffix}`;
    shadersCollectionController.addBodyLines(this, [bodyLine]);
    this._addSDFMethods(shadersCollectionController);
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/gl/SDFExtrude.ts





var SDFExtrudeAxis = /* @__PURE__ */ ((SDFExtrudeAxis2) => {
  SDFExtrudeAxis2["X"] = "X";
  SDFExtrudeAxis2["Y"] = "Y";
  SDFExtrudeAxis2["Z"] = "Z";
  return SDFExtrudeAxis2;
})(SDFExtrudeAxis || {});
const SDF_Extrude_AXISES = ["X" /* X */, "Y" /* Y */, "Z" /* Z */];
const SDFExtrude_OUTPUT_NAME = "d";
class SDFExtrudeGlParamsConfig extends params_ParamsConfig/* NodeParamsConfig */.yI {
  constructor() {
    super(...arguments);
    this.position = params_ParamsConfig/* ParamConfig.VECTOR3 */.XC.VECTOR3([0, 0, 0], { hidden: true });
    this.center = params_ParamsConfig/* ParamConfig.VECTOR3 */.XC.VECTOR3([0, 0, 0]);
    this.height = params_ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(1);
    this.d = params_ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(1);
    this.axis = params_ParamsConfig/* ParamConfig.INTEGER */.XC.INTEGER(SDF_Extrude_AXISES.indexOf("Z" /* Z */), {
      menu: {
        entries: SDF_Extrude_AXISES.map((name, value) => ({ name, value }))
      }
    });
  }
}
const SDFExtrude_ParamsConfig = new SDFExtrudeGlParamsConfig();
class SDFExtrudeGlNode extends _BaseSDF/* BaseSDFGlNode */.s {
  constructor() {
    super(...arguments);
    this.paramsConfig = SDFExtrude_ParamsConfig;
  }
  static type() {
    return "SDFExtrude";
  }
  initializeNode() {
    super.initializeNode();
    this.io.outputs.setNamedOutputConnectionPoints([
      new Gl/* GlConnectionPoint */.E(SDFExtrude_OUTPUT_NAME, Gl/* GlConnectionPointType.FLOAT */.Dv.FLOAT)
    ]);
  }
  setAxis(axis) {
    this.p.axis.set(SDF_Extrude_AXISES.indexOf(axis));
  }
  setLines(shadersCollectionController) {
    const position = this.position();
    const center = ThreeToGl/* ThreeToGl.vector3 */._.vector3(this.variableForInputParam(this.p.center));
    const height = ThreeToGl/* ThreeToGl.float */._.float(this.variableForInputParam(this.p.height));
    const d = ThreeToGl/* ThreeToGl.float */._.float(this.variableForInputParam(this.p.d));
    const out = this.glVarName(SDFExtrude_OUTPUT_NAME);
    const functionName = this._functionName();
    const bodyLine = `float ${out} = ${functionName}(${position} - ${center}, ${d}, ${height})`;
    shadersCollectionController.addBodyLines(this, [bodyLine]);
    this._addSDFMethods(shadersCollectionController);
  }
  _functionName() {
    const axis = SDF_Extrude_AXISES[this.pv.axis];
    return `SDFExtrude${axis}`;
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/gl/gl/fractal/mandelbrot.glsl
/* harmony default export */ var mandelbrot = ("// https://www.shadertoy.com/view/XsXXWS\n// http://blog.hvidtfeldts.net/index.php/2011/09/distance-estimated-3d-fractals-v-the-mandelbulb-different-de-approximations/\t\n\n// A point this close to the surface is considered to be on the surface.\n// Larger numbers lead to faster convergence but \"blur\" out the shape\n// const float minimumDistanceToSurface = SURF_DIST;//0.0003;\n\nstruct MandelbrotArgs {\n\tfloat power;\n\tvec3 QPreMult;\n\tvec3 QPostMult;\n\tfloat thetaMult;\n\tfloat externalBoundingRadius;\n};\n\n#ifndef SURF_DIST\n\t#define SURF_DIST 0.001\n#endif\n\n////////////////////////////////////////////////////////////\n\nfloat mandelbrot(vec3 P, out float AO, MandelbrotArgs args) {\n\n\tAO = 1.0;\n\t\n\tvec3 Q = P;\n\t\n\t// Put the whole shape in a bounding sphere to \n\t// speed up distant ray marching. This is necessary\n\t// to ensure that we don't expend all ray march iterations\n\t// before even approaching the surface\n\t{\n\t\tfloat r = length(P) - args.externalBoundingRadius;\n\t\t// If we're more than 1 unit away from the\n\t\t// surface, return that distance\n\t\tif (r > 1.0) { return r; }\n\t}\n\tfloat escapeRadius = 2. * args.externalBoundingRadius;\n\n\t// Embed a sphere within the fractal to fill in holes under low iteration counts\n\tconst float internalBoundingRadius = 0.72;\n\n\t// Used to smooth discrete iterations into continuous distance field\n\t// (similar to the trick used for coloring the Mandelbrot set)\t\n\tfloat derivative = 1.0;\n\t\n\tfor (int i = 0; i < ___ITERATIONS___; ++i) {\n\t\t// Darken as we go deeper\n\t\tAO *= 0.725;\n\t\tfloat r = length(Q);\n\t\t\n\t\tif (r > escapeRadius) {\t\n\t\t\t// The point escaped. Remap AO for more brightness and return\n\t\t\tAO = min((AO + 0.075) * 4.1, 1.0);\n\t\t\treturn min(length(P) - internalBoundingRadius, 0.5 * log(r) * r / derivative);\n\t\t} else {\t\t\n\t\t\t// Convert to polar coordinates and then rotate by the power\n\t\t\t//float theta = acos(Q.z*(0.8+.2*sin(iTime*1.)) / r) * power;\n\t\t\tvec3 preMult = vec3(\n\t\t\t\targs.QPreMult.x,// * (1.+float(i)),\n\t\t\t\targs.QPreMult.y,// * (1.+float(i)),\n\t\t\t\targs.QPreMult.z// * (1.+float(i))\n\t\t\t);\n\t\t\tfloat theta = acos(preMult.z * Q.z / r) * args.power;\n\t\t\tfloat phi   = atan(preMult.y * Q.y, preMult.x * Q.x) * args.power;\t\t\t\n\t\t\t\n\t\t\t// Update the derivative\n\t\t\tderivative = pow(r, args.power - 1.0) * args.power * derivative + 1.0;\n\t\t\t\n\t\t\t// Convert back to Cartesian coordinates and \n\t\t\t// offset by the original point (which we're orbiting)\n\t\t\tfloat sinTheta = sin(theta * args.thetaMult);\n\t\t\t\n\t\t\tQ = vec3(sinTheta * cos(phi) * args.QPostMult.x,\n\t\t\t\t\t    sinTheta * sin(phi) * args.QPostMult.y,\n\t\t\t\t\t    cos(theta) * args.QPostMult.z) * pow(r, args.power) + P;\n\t\t}\t\t\t\n\t}\n\t\n\t// Never escaped, so either already in the set...or a complete miss\n\treturn SURF_DIST;\n}\n");
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/gl/SDFFractalMandelbrot.ts








var OutputName = /* @__PURE__ */ ((OutputName2) => {
  OutputName2["D"] = "d";
  OutputName2["AO"] = "ao";
  return OutputName2;
})(OutputName || {});
class SDFFractalMandelbrotGlParamsConfig extends params_ParamsConfig/* NodeParamsConfig */.yI {
  constructor() {
    super(...arguments);
    this.position = params_ParamsConfig/* ParamConfig.VECTOR3 */.XC.VECTOR3([0, 0, 0], { hidden: true });
    this.center = params_ParamsConfig/* ParamConfig.VECTOR3 */.XC.VECTOR3([0, 0, 0]);
    this.power = params_ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(8, {
      range: [0, 10],
      rangeLocked: [false, false]
    });
    this.QPreMult = params_ParamsConfig/* ParamConfig.VECTOR3 */.XC.VECTOR3([1, 1, 1]);
    this.QPostMult = params_ParamsConfig/* ParamConfig.VECTOR3 */.XC.VECTOR3([1, 1, 1]);
    this.thetaMult = params_ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(1, {
      range: [-2, 2],
      rangeLocked: [true, false]
    });
    this.iterations = params_ParamsConfig/* ParamConfig.INTEGER */.XC.INTEGER(8, {
      range: [1, 32],
      rangeLocked: [true, false]
    });
    this.externalBoundingRadius = params_ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(1.2, {
      range: [0, 2],
      rangeLocked: [true, false]
    });
  }
}
const SDFFractalMandelbrot_ParamsConfig = new SDFFractalMandelbrotGlParamsConfig();
class SDFFractalMandelbrotGlNode extends _BaseSDF/* BaseSDFGlNode */.s {
  constructor() {
    super(...arguments);
    this.paramsConfig = SDFFractalMandelbrot_ParamsConfig;
  }
  static type() {
    return types_Gl/* GlType.SDF_FRACTAL_MANDELBROT */.P.SDF_FRACTAL_MANDELBROT;
  }
  initializeNode() {
    super.initializeNode();
    this.io.outputs.setNamedOutputConnectionPoints([
      new Gl/* GlConnectionPoint */.E("d" /* D */, Gl/* GlConnectionPointType.FLOAT */.Dv.FLOAT),
      new Gl/* GlConnectionPoint */.E("ao" /* AO */, Gl/* GlConnectionPointType.FLOAT */.Dv.FLOAT)
    ]);
  }
  setLines(shadersCollectionController) {
    const position = this.position();
    const center = ThreeToGl/* ThreeToGl.vector3 */._.vector3(this.variableForInputParam(this.p.center));
    const power = ThreeToGl/* ThreeToGl.float */._.float(this.variableForInputParam(this.p.power));
    const externalBoundingRadius = ThreeToGl/* ThreeToGl.float */._.float(this.variableForInputParam(this.p.externalBoundingRadius));
    const thetaMult = ThreeToGl/* ThreeToGl.float */._.float(this.variableForInputParam(this.p.thetaMult));
    const QPreMult = ThreeToGl/* ThreeToGl.vector3 */._.vector3(this.variableForInputParam(this.p.QPreMult));
    const QPostMult = ThreeToGl/* ThreeToGl.vector3 */._.vector3(this.variableForInputParam(this.p.QPostMult));
    const d = this.glVarName("d" /* D */);
    const ao = this.glVarName("ao" /* AO */);
    const mandelbrotStructArgs = [power, QPreMult, QPostMult, thetaMult, externalBoundingRadius];
    const mandelbrotStruct = `MandelbrotArgs(${mandelbrotStructArgs.join(", ")})`;
    const bodyLines = [
      `float ${ao}`,
      `float ${d} = mandelbrot(${position} - ${center}, ${ao}, ${mandelbrotStruct})`
    ];
    shadersCollectionController.addBodyLines(this, bodyLines);
    shadersCollectionController.addDefinitions(this, [
      new GLDefinition/* FunctionGLDefinition */.MR(this, mandelbrot.replace("___ITERATIONS___", `${this.pv.iterations}`))
    ]);
  }
}

// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/nodes/gl/Subnet.ts
var gl_Subnet = __webpack_require__(89434);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/nodes/gl/code/utils/LineType.ts
var LineType = __webpack_require__(81855);
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/gl/SDFGradient.ts








const POSITION_INPUT_NAME = "position";
const GRADIENT_OUTPUT_NAME = "gradient";
const SDF_OUTPUT_NAME = "sdf";
const GRADIENT_FUNCTION_NAME = "gradientFunction";
const SDF_FUNCTION_NAME = "sdfFunction";
function gradientFunction(options) {
  const { sdfFunctionName, gradientFunctionName, epsilon, additionalArguments } = options;
  additionalArguments.shift();
  const otherArgsDefinition = additionalArguments.length > 0 ? `, ${additionalArguments.join(", ")}` : "";
  const otherArgsWithoutGlType = additionalArguments.map((arg) => {
    const elements = arg.split(" ");
    return elements[elements.length - 1];
  });
  const otherArgsCall = otherArgsWithoutGlType.length > 0 ? `, ${otherArgsWithoutGlType.join(", ")}` : "";
  const functionDefinition = `
vec3 ${gradientFunctionName}( in vec3 p${otherArgsDefinition} )
{
	const float eps = ${epsilon};
	const vec2 h = vec2(eps,0);
	return normalize(
		vec3(
			${sdfFunctionName}(p+h.xyy${otherArgsCall}) - ${sdfFunctionName}(p-h.xyy${otherArgsCall}),
			${sdfFunctionName}(p+h.yxy${otherArgsCall}) - ${sdfFunctionName}(p-h.yxy${otherArgsCall}),
			${sdfFunctionName}(p+h.yyx${otherArgsCall}) - ${sdfFunctionName}(p-h.yyx${otherArgsCall})
		)
	);
}
`;
  return functionDefinition;
}
class SDFGradientGlParamsConfig extends (0,gl_Subnet/* TypedSubnetGlParamsConfigMixin */.Qm)(params_ParamsConfig/* NodeParamsConfig */.yI) {
  constructor() {
    super(...arguments);
    this.epsilon = params_ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(1e-4, {
      range: [1e-9, 1],
      rangeLocked: [false, false]
    });
  }
}
const SDFGradient_ParamsConfig = new SDFGradientGlParamsConfig();
class SDFGradientGlNode extends gl_Subnet/* TypedSubnetGlNode */.EZ {
  constructor() {
    super(...arguments);
    this.paramsConfig = SDFGradient_ParamsConfig;
  }
  static type() {
    return types_Gl/* GlType.SDF_GRADIENT */.P.SDF_GRADIENT;
  }
  _expectedInputsCount() {
    return super._expectedInputsCount() + 1;
  }
  _expectedInputTypes() {
    return [Gl/* GlConnectionPointType.VEC3 */.Dv.VEC3].concat(super._expectedInputTypes());
  }
  _expectedOutputTypes() {
    return [Gl/* GlConnectionPointType.FLOAT */.Dv.FLOAT, Gl/* GlConnectionPointType.VEC3 */.Dv.VEC3];
  }
  _expectedInputName(index) {
    if (index == 0) {
      return POSITION_INPUT_NAME;
    } else {
      return super._expectedInputName(index - 1);
    }
  }
  _expectedOutputName(index) {
    return [SDF_OUTPUT_NAME, GRADIENT_OUTPUT_NAME][index];
  }
  childExpectedOutputConnectionPointTypes() {
    return [Gl/* GlConnectionPointType.FLOAT */.Dv.FLOAT];
  }
  childExpectedOutputConnectionPointName(index) {
    return SDF_OUTPUT_NAME;
  }
  //
  //
  // set_lines
  //
  //
  setSubnetInputLines(shadersCollectionController, childNode) {
    const bodyLines = [];
    const position = childNode.glVarName(POSITION_INPUT_NAME);
    bodyLines.push(`	vec3 ${position} = ${POSITION_INPUT_NAME}`);
    const otherInputsCount = this.pv.inputsCount;
    for (let i = 0; i < otherInputsCount; i++) {
      const inputName = this._inputNameParams()[i].value;
      const varName = childNode.glVarName(inputName);
      const glType = Gl/* GL_CONNECTION_POINT_TYPES */.$J[this._inputTypeParams()[i].value];
      bodyLines.push(`	${glType} ${varName} = ${inputName}`);
    }
    shadersCollectionController.addBodyLines(childNode, bodyLines);
  }
  setSubnetOutputLines(shadersCollectionController, childNode) {
    const connections = childNode.io.connections.inputConnections();
    const connection = connections ? connections[0] : null;
    if (!connection) {
      shadersCollectionController.addBodyLines(childNode, [`return 0.0`]);
      return;
    }
    const connectionPoint = connection.destConnectionPoint();
    if (!connectionPoint) {
      return;
    }
    const inValue = ThreeToGl/* ThreeToGl.any */._.any(childNode.variableForInput(connectionPoint.name()));
    const bodyLine = `return ${inValue}`;
    shadersCollectionController.addBodyLines(childNode, [bodyLine]);
  }
  setLines(shadersCollectionController) {
    const functionArguments = {
      definition: [],
      call: []
    };
    const position = ThreeToGl/* ThreeToGl.any */._.any(this.variableForInput(POSITION_INPUT_NAME));
    functionArguments.definition.push(`vec3 ${POSITION_INPUT_NAME}`);
    functionArguments.call.push(position);
    const otherInputsCount = this.pv.inputsCount;
    for (let i = 0; i < otherInputsCount; i++) {
      const inputName = this._inputNameParams()[i].value;
      const glType = Gl/* GL_CONNECTION_POINT_TYPES */.$J[this._inputTypeParams()[i].value];
      const inputVal = ThreeToGl/* ThreeToGl.any */._.any(this.variableForInput(inputName));
      functionArguments.definition.push(`${glType} ${inputName}`);
      functionArguments.call.push(inputVal);
    }
    const options = {
      name: {
        sdf: this.glVarName(SDF_FUNCTION_NAME),
        gradient: this.glVarName(GRADIENT_FUNCTION_NAME)
      },
      arguments: functionArguments
    };
    this._declareFunctions(shadersCollectionController, options);
    this._callFunctions(shadersCollectionController, options);
  }
  _declareFunctions(shadersCollectionController, options) {
    const codeBuilder = this._runCodeBuilder(shadersCollectionController);
    if (!codeBuilder) {
      return;
    }
    const shadername = shadersCollectionController.currentShaderName();
    const bodyLines = codeBuilder.lines(shadername, LineType/* LineType.BODY */.S.BODY);
    const sdfFunctionLines = [
      `float ${options.name.sdf}(${options.arguments.definition.join(", ")}){`,
      ...this._sanitizeBodyLines(bodyLines),
      `}`
    ].join("\n");
    const gradientFunctionLines = gradientFunction({
      epsilon: this.pv.epsilon,
      sdfFunctionName: options.name.sdf,
      gradientFunctionName: options.name.gradient,
      additionalArguments: options.arguments.definition
    });
    shadersCollectionController.addDefinitions(this, [
      new GLDefinition/* FunctionGLDefinition */.MR(this, sdfFunctionLines),
      new GLDefinition/* FunctionGLDefinition */.MR(this, gradientFunctionLines)
    ]);
  }
  _callFunctions(shadersCollectionController, options) {
    const used_output_names = this.io.outputs.used_output_names();
    const bodyLines = [];
    if (used_output_names.indexOf(SDF_OUTPUT_NAME) >= 0) {
      const varName = this.glVarName(SDF_OUTPUT_NAME);
      bodyLines.push(`float ${varName} = ${options.name.sdf}(${options.arguments.call.join(", ")})`);
    }
    if (used_output_names.indexOf(GRADIENT_OUTPUT_NAME) >= 0) {
      const varName = this.glVarName(GRADIENT_OUTPUT_NAME);
      bodyLines.push(`vec3 ${varName} = ${options.name.gradient}(${options.arguments.call.join(", ")})`);
    }
    shadersCollectionController.addBodyLines(this, bodyLines);
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/gl/SDFHexagonalPrism.ts






const SDFHexagonalPrism_OUTPUT_NAME = "float";
class SDFHexagonalPrismGlParamsConfig extends params_ParamsConfig/* NodeParamsConfig */.yI {
  constructor() {
    super(...arguments);
    this.position = params_ParamsConfig/* ParamConfig.VECTOR3 */.XC.VECTOR3([0, 0, 0], { hidden: true });
    this.center = params_ParamsConfig/* ParamConfig.VECTOR3 */.XC.VECTOR3([0, 0, 0]);
    this.radius = params_ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(0.1);
    this.height = params_ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(1);
  }
}
const SDFHexagonalPrism_ParamsConfig = new SDFHexagonalPrismGlParamsConfig();
class SDFHexagonalPrismGlNode extends _BaseSDF/* BaseSDFGlNode */.s {
  constructor() {
    super(...arguments);
    this.paramsConfig = SDFHexagonalPrism_ParamsConfig;
  }
  static type() {
    return types_Gl/* GlType.SDF_HEXAGONAL_PRISM */.P.SDF_HEXAGONAL_PRISM;
  }
  initializeNode() {
    super.initializeNode();
    this.io.outputs.setNamedOutputConnectionPoints([
      new Gl/* GlConnectionPoint */.E(SDFHexagonalPrism_OUTPUT_NAME, Gl/* GlConnectionPointType.FLOAT */.Dv.FLOAT)
    ]);
  }
  setLines(shadersCollectionController) {
    const position = this.position();
    const center = ThreeToGl/* ThreeToGl.vector3 */._.vector3(this.variableForInputParam(this.p.center));
    const radius = ThreeToGl/* ThreeToGl.float */._.float(this.variableForInputParam(this.p.radius));
    const height = ThreeToGl/* ThreeToGl.float */._.float(this.variableForInputParam(this.p.height));
    const float = this.glVarName(SDFHexagonalPrism_OUTPUT_NAME);
    const bodyLine = `float ${float} = sdHexPrism(${position} - ${center}, vec2(${radius},${height}))`;
    shadersCollectionController.addBodyLines(this, [bodyLine]);
    this._addSDFMethods(shadersCollectionController);
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/gl/SDFHorseShoe.ts






const SDFHorseShoe_OUTPUT_NAME = "float";
class SDFHorseShoeGlParamsConfig extends params_ParamsConfig/* NodeParamsConfig */.yI {
  constructor() {
    super(...arguments);
    this.position = params_ParamsConfig/* ParamConfig.VECTOR3 */.XC.VECTOR3([0, 0, 0], { hidden: true });
    this.center = params_ParamsConfig/* ParamConfig.VECTOR3 */.XC.VECTOR3([0, 0, 0]);
    this.angle = params_ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(1, {
      range: [0, Math.PI],
      rangeLocked: [true, true],
      step: 1e-5
    });
    this.radius = params_ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(1);
    this.length = params_ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(1);
    this.thickness = params_ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(0.1);
    this.width = params_ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(0.1);
  }
}
const SDFHorseShoe_ParamsConfig = new SDFHorseShoeGlParamsConfig();
class SDFHorseShoeGlNode extends _BaseSDF/* BaseSDFGlNode */.s {
  constructor() {
    super(...arguments);
    this.paramsConfig = SDFHorseShoe_ParamsConfig;
  }
  static type() {
    return types_Gl/* GlType.SDF_HORSE_SHOE */.P.SDF_HORSE_SHOE;
  }
  initializeNode() {
    super.initializeNode();
    this.io.outputs.setNamedOutputConnectionPoints([
      new Gl/* GlConnectionPoint */.E(SDFHorseShoe_OUTPUT_NAME, Gl/* GlConnectionPointType.FLOAT */.Dv.FLOAT)
    ]);
  }
  setLines(shadersCollectionController) {
    const position = this.position();
    const center = ThreeToGl/* ThreeToGl.vector3 */._.vector3(this.variableForInputParam(this.p.center));
    const angle = ThreeToGl/* ThreeToGl.float */._.float(this.variableForInputParam(this.p.angle));
    const radius = ThreeToGl/* ThreeToGl.float */._.float(this.variableForInputParam(this.p.radius));
    const length = ThreeToGl/* ThreeToGl.float */._.float(this.variableForInputParam(this.p.length));
    const thickness = ThreeToGl/* ThreeToGl.float */._.float(this.variableForInputParam(this.p.thickness));
    const width = ThreeToGl/* ThreeToGl.float */._.float(this.variableForInputParam(this.p.width));
    const float = this.glVarName(SDFHorseShoe_OUTPUT_NAME);
    const bodyLine = `float ${float} = sdHorseshoe(${position} - ${center}, ${angle}, ${radius}, ${length}, vec2(${thickness}, ${width}))`;
    shadersCollectionController.addBodyLines(this, [bodyLine]);
    this._addSDFMethods(shadersCollectionController);
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/gl/utils/SDFSmoothUtils.ts

function sdfSmoothLines(options) {
  const { node, vars, bodyLines, functionNames } = options;
  const { sdfContext, sdf0, sdf1, smooth, matBlendDist, smoothFactor } = vars;
  const functionNameSmooth = functionNames.smooth;
  const functionNameNonSmooth = functionNames.default;
  const side = node.glVarName("side");
  const matId = node.glVarName("matId");
  const matId2 = node.glVarName("matId2");
  const d = node.glVarName("d");
  const setSide = `bool ${side} = ${sdf0}.d < ${sdf1}.d`;
  const setMatId = `int ${matId} = ${side} ? ${sdf0}.matId : ${sdf1}.matId`;
  const setMatId2 = `int ${matId2} = ${side} ? ${sdf1}.matId : ${sdf0}.matId`;
  bodyLines.push(setSide);
  bodyLines.push(setMatId);
  bodyLines.push(setMatId2);
  if (smooth) {
    const matBlend = node.glVarName("matBlend");
    const dist = node.glVarName("dist");
    const halfBlendDist = node.glVarName("halfBlendDist");
    const setHalfBlendDist = `float ${halfBlendDist} = ${matBlendDist} * 0.5`;
    const setDist = `float ${dist} = ${sdf0}.d - ${sdf1}.d`;
    const setMatBlend = `float ${matBlend} = smoothstep(-${halfBlendDist},${halfBlendDist}, ${dist})`;
    const setMatBlend2 = `${matBlend} = ${dist} > 0. ? 1.0-${matBlend} : ${matBlend}`;
    const setDistance = `float ${d} = ${functionNameSmooth}(${sdf0}.d, ${sdf1}.d, ${smoothFactor})`;
    const withSmooth = `SDFContext(${d}, 0, ${matId}, ${matId2}, ${matBlend})`;
    bodyLines.push(setDist);
    bodyLines.push(setHalfBlendDist);
    bodyLines.push(setMatBlend);
    bodyLines.push(setMatBlend2);
    bodyLines.push(setDistance);
    bodyLines.push(`SDFContext ${sdfContext} = ${withSmooth}`);
  } else {
    const setDistance = `float ${d} = ${functionNameNonSmooth}(${sdf0}.d, ${sdf1}.d)`;
    const withoutSmooth = `SDFContext(${d}, 0, ${matId}, ${matId}, 0.)`;
    bodyLines.push(setDistance);
    bodyLines.push(`SDFContext ${sdfContext} = ${withoutSmooth}`);
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/gl/SDFIntersect.ts









var InputName = /* @__PURE__ */ ((InputName2) => {
  InputName2["SDF0"] = "sdf0";
  InputName2["SDF1"] = "sdf1";
  InputName2["SMOOTH_FACTOR"] = "smoothFactor";
  InputName2["MAT_BLEND_DIST"] = "matBlendDist";
  return InputName2;
})(InputName || {});
const SDFIntersect_OUTPUT_NAME = "intersect";
const ALLOWED_TYPES = [Gl/* GlConnectionPointType.FLOAT */.Dv.FLOAT, Gl/* GlConnectionPointType.SDF_CONTEXT */.Dv.SDF_CONTEXT];
class SDFIntersectGlParamsConfig extends params_ParamsConfig/* NodeParamsConfig */.yI {
  constructor() {
    super(...arguments);
    this.smooth = params_ParamsConfig/* ParamConfig.BOOLEAN */.XC.BOOLEAN(1);
  }
}
const SDFIntersect_ParamsConfig = new SDFIntersectGlParamsConfig();
class SDFIntersectGlNode extends gl_Base/* TypedGlNode */.hD {
  constructor() {
    super(...arguments);
    this.paramsConfig = SDFIntersect_ParamsConfig;
  }
  static type() {
    return "SDFIntersect";
  }
  initializeNode() {
    super.initializeNode();
    this.io.connection_points.spare_params.setInputlessParamNames(["smooth"]);
    this.io.connection_points.set_input_name_function(this._glInputName.bind(this));
    this.io.connection_points.set_output_name_function(this._glOutputName.bind(this));
    this.io.connection_points.set_expected_input_types_function(this._expectedInputTypes.bind(this));
    this.io.connection_points.set_expected_output_types_function(this._expectedOutputTypes.bind(this));
  }
  _glInputName(index) {
    return ["sdf0" /* SDF0 */, "sdf1" /* SDF1 */, "smoothFactor" /* SMOOTH_FACTOR */, "matBlendDist" /* MAT_BLEND_DIST */][index];
  }
  _glOutputName(index) {
    return SDFIntersect_OUTPUT_NAME;
  }
  _expectedInputTypes() {
    let firstInputType = this.io.connection_points.first_input_connection_type();
    if (!firstInputType || !ALLOWED_TYPES.includes(firstInputType)) {
      firstInputType = Gl/* GlConnectionPointType.FLOAT */.Dv.FLOAT;
    }
    return [firstInputType, firstInputType, Gl/* GlConnectionPointType.FLOAT */.Dv.FLOAT, Gl/* GlConnectionPointType.FLOAT */.Dv.FLOAT];
  }
  _expectedOutputTypes() {
    return [this._expectedInputTypes()[0]];
  }
  setLines(shadersCollectionController) {
    const smooth = (0,Type/* isBooleanTrue */.bI)(this.pv.smooth);
    const sdf0 = ThreeToGl/* ThreeToGl.float */._.float(this.variableForInput("sdf0" /* SDF0 */));
    const sdf1 = ThreeToGl/* ThreeToGl.float */._.float(this.variableForInput("sdf1" /* SDF1 */));
    const smoothFactor = ThreeToGl/* ThreeToGl.float */._.float(this.variableForInput("smoothFactor" /* SMOOTH_FACTOR */));
    const firstInputType = this._expectedInputTypes()[0];
    const bodyLines = [];
    if (firstInputType == Gl/* GlConnectionPointType.FLOAT */.Dv.FLOAT) {
      const float = this.glVarName(SDFIntersect_OUTPUT_NAME);
      const withSmooth = `SDFSmoothIntersect(${sdf0}, ${sdf1}, ${smoothFactor})`;
      const withoutSmooth = `SDFIntersect(${sdf0}, ${sdf1})`;
      const functionCall = smooth ? withSmooth : withoutSmooth;
      const bodyLine = `float ${float} = ${functionCall}`;
      bodyLines.push(bodyLine);
    } else {
      const sdfContext = this.glVarName(SDFIntersect_OUTPUT_NAME);
      const matBlendDist = ThreeToGl/* ThreeToGl.float */._.float(this.variableForInput("matBlendDist" /* MAT_BLEND_DIST */));
      sdfSmoothLines({
        node: this,
        vars: {
          sdf0,
          sdf1,
          sdfContext,
          smooth,
          matBlendDist,
          smoothFactor
        },
        functionNames: {
          smooth: "SDFSmoothIntersect",
          default: "SDFIntersect"
        },
        bodyLines
      });
    }
    shadersCollectionController.addBodyLines(this, bodyLines);
    _BaseSDF/* BaseSDFGlNode.addSDFMethods */.s.addSDFMethods(shadersCollectionController, this);
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/gl/SDFLink.ts






const SDFLink_OUTPUT_NAME = "float";
class SDFLinkGlParamsConfig extends params_ParamsConfig/* NodeParamsConfig */.yI {
  constructor() {
    super(...arguments);
    this.position = params_ParamsConfig/* ParamConfig.VECTOR3 */.XC.VECTOR3([0, 0, 0], { hidden: true });
    this.center = params_ParamsConfig/* ParamConfig.VECTOR3 */.XC.VECTOR3([0, 0, 0]);
    this.halfLength = params_ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(1);
    this.radius1 = params_ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(0.5);
    this.radius2 = params_ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(0.2);
  }
}
const SDFLink_ParamsConfig = new SDFLinkGlParamsConfig();
class SDFLinkGlNode extends _BaseSDF/* BaseSDFGlNode */.s {
  constructor() {
    super(...arguments);
    this.paramsConfig = SDFLink_ParamsConfig;
  }
  static type() {
    return types_Gl/* GlType.SDF_LINK */.P.SDF_LINK;
  }
  initializeNode() {
    super.initializeNode();
    this.io.outputs.setNamedOutputConnectionPoints([
      new Gl/* GlConnectionPoint */.E(SDFLink_OUTPUT_NAME, Gl/* GlConnectionPointType.FLOAT */.Dv.FLOAT)
    ]);
  }
  setLines(shadersCollectionController) {
    const position = this.position();
    const center = ThreeToGl/* ThreeToGl.vector3 */._.vector3(this.variableForInputParam(this.p.center));
    const halfLength = ThreeToGl/* ThreeToGl.float */._.float(this.variableForInputParam(this.p.halfLength));
    const radius1 = ThreeToGl/* ThreeToGl.float */._.float(this.variableForInputParam(this.p.radius1));
    const radius2 = ThreeToGl/* ThreeToGl.float */._.float(this.variableForInputParam(this.p.radius2));
    const float = this.glVarName(SDFLink_OUTPUT_NAME);
    const bodyLine = `float ${float} = sdLink(${position} - ${center}, ${halfLength}, ${radius1}, ${radius2})`;
    shadersCollectionController.addBodyLines(this, [bodyLine]);
    this._addSDFMethods(shadersCollectionController);
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/gl/SDFMax.ts






var SDFMax_InputName = /* @__PURE__ */ ((InputName2) => {
  InputName2["SDF0"] = "sdf0";
  InputName2["SDF1"] = "sdf1";
  return InputName2;
})(SDFMax_InputName || {});
const SDFMax_OUTPUT_NAME = "max";
const SDFMax_ALLOWED_TYPES = [Gl/* GlConnectionPointType.FLOAT */.Dv.FLOAT, Gl/* GlConnectionPointType.SDF_CONTEXT */.Dv.SDF_CONTEXT];
class SDFMaxGlParamsConfig extends params_ParamsConfig/* NodeParamsConfig */.yI {
}
const SDFMax_ParamsConfig = new SDFMaxGlParamsConfig();
class SDFMaxGlNode extends gl_Base/* TypedGlNode */.hD {
  constructor() {
    super(...arguments);
    this.paramsConfig = SDFMax_ParamsConfig;
  }
  static type() {
    return "SDFMax";
  }
  initializeNode() {
    super.initializeNode();
    this.io.connection_points.set_input_name_function(this._glInputName.bind(this));
    this.io.connection_points.set_output_name_function(this._glOutputName.bind(this));
    this.io.connection_points.set_expected_input_types_function(this._expectedInputTypes.bind(this));
    this.io.connection_points.set_expected_output_types_function(this._expectedOutputTypes.bind(this));
  }
  _glInputName(index) {
    return ["sdf0" /* SDF0 */, "sdf1" /* SDF1 */][index];
  }
  _glOutputName(index) {
    return SDFMax_OUTPUT_NAME;
  }
  _expectedInputTypes() {
    let firstInputType = this.io.connection_points.first_input_connection_type();
    if (firstInputType && SDFMax_ALLOWED_TYPES.includes(firstInputType)) {
      return [firstInputType, firstInputType];
    }
    return [Gl/* GlConnectionPointType.FLOAT */.Dv.FLOAT, Gl/* GlConnectionPointType.FLOAT */.Dv.FLOAT];
  }
  _expectedOutputTypes() {
    return [this._expectedInputTypes()[0]];
  }
  setLines(shadersCollectionController) {
    const firstInputType = this._expectedInputTypes()[0];
    switch (firstInputType) {
      case Gl/* GlConnectionPointType.FLOAT */.Dv.FLOAT: {
        return this._setLinesFloat(shadersCollectionController);
      }
      case Gl/* GlConnectionPointType.SDF_CONTEXT */.Dv.SDF_CONTEXT: {
        return this._setLinesSDFContext(shadersCollectionController);
      }
    }
  }
  _setLinesFloat(shadersCollectionController) {
    const sdf0 = ThreeToGl/* ThreeToGl.float */._.float(this.variableForInput("sdf0" /* SDF0 */));
    const sdf1 = ThreeToGl/* ThreeToGl.float */._.float(this.variableForInput("sdf1" /* SDF1 */));
    const float = this.glVarName(SDFMax_OUTPUT_NAME);
    const bodyLine = `float ${float} = max(${sdf0}, ${sdf1})`;
    shadersCollectionController.addBodyLines(this, [bodyLine]);
    _BaseSDF/* BaseSDFGlNode.addSDFMethods */.s.addSDFMethods(shadersCollectionController, this);
  }
  _setLinesSDFContext(shadersCollectionController) {
    const sdf0 = ThreeToGl/* ThreeToGl.vector2 */._.vector2(this.variableForInput("sdf0" /* SDF0 */));
    const sdf1 = ThreeToGl/* ThreeToGl.vector2 */._.vector2(this.variableForInput("sdf1" /* SDF1 */));
    const sdfContext = this.glVarName(SDFMax_OUTPUT_NAME);
    const side = this.glVarName("side");
    const setSide = `bool ${side} = ${sdf0}.d < ${sdf1}.d`;
    const matId = `${side} ? ${sdf0}.matId : ${sdf1}.matId`;
    const matId2 = `${side} ? ${sdf1}.matId : ${sdf0}.matId`;
    const bodyLines = [
      setSide,
      `SDFContext ${sdfContext} = SDFContext(max(${sdf0}.d, ${sdf1}.d), 0, ${matId}, ${matId2}, 0.)`
    ];
    shadersCollectionController.addBodyLines(this, bodyLines);
    _BaseSDF/* BaseSDFGlNode.addSDFMethods */.s.addSDFMethods(shadersCollectionController, this);
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/gl/SDFMin.ts






var SDFMin_InputName = /* @__PURE__ */ ((InputName2) => {
  InputName2["SDF0"] = "sdf0";
  InputName2["SDF1"] = "sdf1";
  return InputName2;
})(SDFMin_InputName || {});
const SDFMin_OUTPUT_NAME = "min";
const SDFMin_ALLOWED_TYPES = [Gl/* GlConnectionPointType.FLOAT */.Dv.FLOAT, Gl/* GlConnectionPointType.SDF_CONTEXT */.Dv.SDF_CONTEXT];
class SDFMinGlParamsConfig extends params_ParamsConfig/* NodeParamsConfig */.yI {
}
const SDFMin_ParamsConfig = new SDFMinGlParamsConfig();
class SDFMinGlNode extends gl_Base/* TypedGlNode */.hD {
  constructor() {
    super(...arguments);
    this.paramsConfig = SDFMin_ParamsConfig;
  }
  static type() {
    return "SDFMin";
  }
  initializeNode() {
    super.initializeNode();
    this.io.connection_points.set_input_name_function(this._glInputName.bind(this));
    this.io.connection_points.set_output_name_function(this._glOutputName.bind(this));
    this.io.connection_points.set_expected_input_types_function(this._expectedInputTypes.bind(this));
    this.io.connection_points.set_expected_output_types_function(this._expectedOutputTypes.bind(this));
  }
  _glInputName(index) {
    return ["sdf0" /* SDF0 */, "sdf1" /* SDF1 */][index];
  }
  _glOutputName(index) {
    return SDFMin_OUTPUT_NAME;
  }
  _expectedInputTypes() {
    let firstInputType = this.io.connection_points.first_input_connection_type();
    if (firstInputType && SDFMin_ALLOWED_TYPES.includes(firstInputType)) {
      return [firstInputType, firstInputType];
    }
    return [Gl/* GlConnectionPointType.FLOAT */.Dv.FLOAT, Gl/* GlConnectionPointType.FLOAT */.Dv.FLOAT];
  }
  _expectedOutputTypes() {
    return [this._expectedInputTypes()[0]];
  }
  setLines(shadersCollectionController) {
    const firstInputType = this._expectedInputTypes()[0];
    switch (firstInputType) {
      case Gl/* GlConnectionPointType.FLOAT */.Dv.FLOAT: {
        return this._setLinesFloat(shadersCollectionController);
      }
      case Gl/* GlConnectionPointType.SDF_CONTEXT */.Dv.SDF_CONTEXT: {
        return this._setLinesSDFContext(shadersCollectionController);
      }
    }
  }
  _setLinesFloat(shadersCollectionController) {
    const sdf0 = ThreeToGl/* ThreeToGl.float */._.float(this.variableForInput("sdf0" /* SDF0 */));
    const sdf1 = ThreeToGl/* ThreeToGl.float */._.float(this.variableForInput("sdf1" /* SDF1 */));
    const float = this.glVarName(SDFMin_OUTPUT_NAME);
    const bodyLine = `float ${float} = min(${sdf0}, ${sdf1})`;
    shadersCollectionController.addBodyLines(this, [bodyLine]);
    _BaseSDF/* BaseSDFGlNode.addSDFMethods */.s.addSDFMethods(shadersCollectionController, this);
  }
  _setLinesSDFContext(shadersCollectionController) {
    const sdf0 = ThreeToGl/* ThreeToGl.vector2 */._.vector2(this.variableForInput("sdf0" /* SDF0 */));
    const sdf1 = ThreeToGl/* ThreeToGl.vector2 */._.vector2(this.variableForInput("sdf1" /* SDF1 */));
    const sdfContext = this.glVarName(SDFMin_OUTPUT_NAME);
    const side = this.glVarName("side");
    const setSide = `bool ${side} = ${sdf0}.d < ${sdf1}.d`;
    const matId = `${side} ? ${sdf0}.matId : ${sdf1}.matId`;
    const matId2 = `${side} ? ${sdf1}.matId : ${sdf0}.matId`;
    const bodyLines = [
      setSide,
      `SDFContext ${sdfContext} = SDFContext(min(${sdf0}.d, ${sdf1}.d), 0, ${matId}, ${matId2}, 0.)`
    ];
    shadersCollectionController.addBodyLines(this, bodyLines);
    _BaseSDF/* BaseSDFGlNode.addSDFMethods */.s.addSDFMethods(shadersCollectionController, this);
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/gl/gl/raymarching/sdfMirror.glsl
/* harmony default export */ var sdfMirror = ("\n/*\nSDF Mirror\n*/\nvec3 SDFMirrorX( in vec3 p )\n{\n\tp.x = abs(p.x);\n\treturn p;\n}\nvec3 SDFMirrorY( in vec3 p )\n{\n\tp.y = abs(p.y);\n\treturn p;\n}\nvec3 SDFMirrorZ( in vec3 p )\n{\n\tp.z = abs(p.z);\n\treturn p;\n}\nvec3 SDFMirrorXY( in vec3 p )\n{\n\tp.x = abs(p.x);\n\tp.y = abs(p.y);\n\treturn p;\n}\nvec3 SDFMirrorXZ( in vec3 p )\n{\n\tp.x = abs(p.x);\n\tp.z = abs(p.z);\n\treturn p;\n}\nvec3 SDFMirrorYZ( in vec3 p )\n{\n\tp.y = abs(p.y);\n\tp.z = abs(p.z);\n\treturn p;\n}\nvec3 SDFMirrorXYZ( in vec3 p )\n{\n\tp.x = abs(p.x);\n\tp.y = abs(p.y);\n\tp.z = abs(p.z);\n\treturn p;\n}\n\nvec3 SDFMirrorXSmooth( in vec3 p, float c )\n{\n\tp.x = sqrt(pow(p.x,2.) + c);\n\treturn p;\n}\nvec3 SDFMirrorYSmooth( in vec3 p, float c )\n{\n\tp.y = sqrt(pow(p.y,2.) + c);\n\treturn p;\n}\nvec3 SDFMirrorZSmooth( in vec3 p, float c )\n{\n\tp.z = sqrt(pow(p.z,2.) + c);\n\treturn p;\n}\nvec3 SDFMirrorXYSmooth( in vec3 p, float c )\n{\n\tp.x = sqrt(pow(p.x,2.) + c);\n\tp.y = sqrt(pow(p.y,2.) + c);\n\treturn p;\n}\nvec3 SDFMirrorXZSmooth( in vec3 p, float c )\n{\n\tp.x = sqrt(pow(p.x,2.) + c);\n\tp.z = sqrt(pow(p.z,2.) + c);\n\treturn p;\n}\nvec3 SDFMirrorYZSmooth( in vec3 p, float c )\n{\n\tp.y = sqrt(pow(p.y,2.) + c);\n\tp.z = sqrt(pow(p.z,2.) + c);\n\treturn p;\n}\nvec3 SDFMirrorXYZSmooth( in vec3 p, float c )\n{\n\tp.x = sqrt(pow(p.x,2.) + c);\n\tp.y = sqrt(pow(p.y,2.) + c);\n\tp.z = sqrt(pow(p.z,2.) + c);\n\treturn p;\n}\n");
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/gl/SDFMirror.ts








const SDFMirror_OUTPUT_NAME = "p";
class SDFMirrorGlParamsConfig extends params_ParamsConfig/* NodeParamsConfig */.yI {
  constructor() {
    super(...arguments);
    this.position = params_ParamsConfig/* ParamConfig.VECTOR3 */.XC.VECTOR3([0, 0, 0], { hidden: true });
    this.center = params_ParamsConfig/* ParamConfig.VECTOR3 */.XC.VECTOR3([0, 0, 0]);
    this.smooth = params_ParamsConfig/* ParamConfig.BOOLEAN */.XC.BOOLEAN(0);
    this.smoothFactor = params_ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(0, {
      visibleIf: { smooth: 1 },
      step: 1e-4
    });
    this.mirrorX = params_ParamsConfig/* ParamConfig.BOOLEAN */.XC.BOOLEAN(1);
    this.mirrorY = params_ParamsConfig/* ParamConfig.BOOLEAN */.XC.BOOLEAN(1);
    this.mirrorZ = params_ParamsConfig/* ParamConfig.BOOLEAN */.XC.BOOLEAN(1);
  }
}
const SDFMirror_ParamsConfig = new SDFMirrorGlParamsConfig();
class SDFMirrorGlNode extends _BaseSDF/* BaseSDFGlNode */.s {
  constructor() {
    super(...arguments);
    this.paramsConfig = SDFMirror_ParamsConfig;
  }
  static type() {
    return "SDFMirror";
  }
  initializeNode() {
    super.initializeNode();
    this.io.connection_points.spare_params.setInputlessParamNames(["mirrorX", "mirrorY", "mirrorZ"]);
    this.io.outputs.setNamedOutputConnectionPoints([
      new Gl/* GlConnectionPoint */.E(SDFMirror_OUTPUT_NAME, Gl/* GlConnectionPointType.VEC3 */.Dv.VEC3)
    ]);
  }
  setLines(shadersCollectionController) {
    const position = this.position();
    const center = ThreeToGl/* ThreeToGl.vector3 */._.vector3(this.variableForInputParam(this.p.center));
    const output = this.glVarName(SDFMirror_OUTPUT_NAME);
    const suffix = this._functionSuffix();
    const bodyLines = [];
    if (suffix) {
      const functionName = `SDFMirror${suffix}`;
      const args = [`${position} - ${center}`];
      if ((0,Type/* isBooleanTrue */.bI)(this.pv.smooth)) {
        const smoothFactor = ThreeToGl/* ThreeToGl.float */._.float(this.variableForInputParam(this.p.smoothFactor));
        args.push(smoothFactor);
      }
      const bodyLine = `vec3 ${output} = ${functionName}(${args.join(",")})`;
      bodyLines.push(bodyLine);
    } else {
      const bodyLine = `vec3 ${output} = ${position} - ${center}`;
      bodyLines.push(bodyLine);
    }
    shadersCollectionController.addBodyLines(this, bodyLines);
    shadersCollectionController.addDefinitions(this, [new GLDefinition/* FunctionGLDefinition */.MR(this, sdfMirror)]);
  }
  _functionSuffix() {
    const x = (0,Type/* isBooleanTrue */.bI)(this.pv.mirrorX);
    const y = (0,Type/* isBooleanTrue */.bI)(this.pv.mirrorY);
    const z = (0,Type/* isBooleanTrue */.bI)(this.pv.mirrorZ);
    if (!(x || y || z)) {
      return null;
    }
    const args = [];
    if (x)
      args.push("X");
    if (y)
      args.push("Y");
    if (z)
      args.push("Z");
    if ((0,Type/* isBooleanTrue */.bI)(this.pv.smooth)) {
      args.push("Smooth");
    }
    return args.join("");
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/gl/SDFOctahedron.ts






const SDFOctahedron_OUTPUT_NAME = "float";
class SDFOctahedronGlParamsConfig extends params_ParamsConfig/* NodeParamsConfig */.yI {
  constructor() {
    super(...arguments);
    this.position = params_ParamsConfig/* ParamConfig.VECTOR3 */.XC.VECTOR3([0, 0, 0], { hidden: true });
    this.center = params_ParamsConfig/* ParamConfig.VECTOR3 */.XC.VECTOR3([0, 0, 0]);
    this.size = params_ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(1);
  }
}
const SDFOctahedron_ParamsConfig = new SDFOctahedronGlParamsConfig();
class SDFOctahedronGlNode extends _BaseSDF/* BaseSDFGlNode */.s {
  constructor() {
    super(...arguments);
    this.paramsConfig = SDFOctahedron_ParamsConfig;
  }
  static type() {
    return types_Gl/* GlType.SDF_OCTAHEDRON */.P.SDF_OCTAHEDRON;
  }
  initializeNode() {
    super.initializeNode();
    this.io.outputs.setNamedOutputConnectionPoints([
      new Gl/* GlConnectionPoint */.E(SDFOctahedron_OUTPUT_NAME, Gl/* GlConnectionPointType.FLOAT */.Dv.FLOAT)
    ]);
  }
  setLines(shadersCollectionController) {
    const position = this.position();
    const center = ThreeToGl/* ThreeToGl.vector3 */._.vector3(this.variableForInputParam(this.p.center));
    const size = ThreeToGl/* ThreeToGl.float */._.float(this.variableForInputParam(this.p.size));
    const float = this.glVarName(SDFOctahedron_OUTPUT_NAME);
    const bodyLine = `float ${float} = sdOctahedron(${position} - ${center}, ${size})`;
    shadersCollectionController.addBodyLines(this, [bodyLine]);
    this._addSDFMethods(shadersCollectionController);
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/gl/SDFOctogonalPrism.ts






const SDFOctogonalPrism_OUTPUT_NAME = "float";
class SDFOctogonalPrismGlParamsConfig extends params_ParamsConfig/* NodeParamsConfig */.yI {
  constructor() {
    super(...arguments);
    this.position = params_ParamsConfig/* ParamConfig.VECTOR3 */.XC.VECTOR3([0, 0, 0], { hidden: true });
    this.center = params_ParamsConfig/* ParamConfig.VECTOR3 */.XC.VECTOR3([0, 0, 0]);
    this.radius = params_ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(0.1);
    this.height = params_ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(1);
  }
}
const SDFOctogonalPrism_ParamsConfig = new SDFOctogonalPrismGlParamsConfig();
class SDFOctogonalPrismGlNode extends _BaseSDF/* BaseSDFGlNode */.s {
  constructor() {
    super(...arguments);
    this.paramsConfig = SDFOctogonalPrism_ParamsConfig;
  }
  static type() {
    return types_Gl/* GlType.SDF_OCTOGONAL_PRISM */.P.SDF_OCTOGONAL_PRISM;
  }
  initializeNode() {
    super.initializeNode();
    this.io.outputs.setNamedOutputConnectionPoints([
      new Gl/* GlConnectionPoint */.E(SDFOctogonalPrism_OUTPUT_NAME, Gl/* GlConnectionPointType.FLOAT */.Dv.FLOAT)
    ]);
  }
  setLines(shadersCollectionController) {
    const position = this.position();
    const center = ThreeToGl/* ThreeToGl.vector2 */._.vector2(this.variableForInputParam(this.p.center));
    const radius = ThreeToGl/* ThreeToGl.float */._.float(this.variableForInputParam(this.p.radius));
    const height = ThreeToGl/* ThreeToGl.float */._.float(this.variableForInputParam(this.p.height));
    const float = this.glVarName(SDFOctogonalPrism_OUTPUT_NAME);
    const bodyLine = `float ${float} = sdOctogonPrism(${position} - ${center}, ${radius}, ${height})`;
    shadersCollectionController.addBodyLines(this, [bodyLine]);
    this._addSDFMethods(shadersCollectionController);
  }
}

// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/poly/registers/nodes/types/Js.ts
var Js = __webpack_require__(16718);
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/gl/SDFOnion.ts







var SDFOnion_InputName = /* @__PURE__ */ ((InputName2) => {
  InputName2["SDF"] = "sdf";
  InputName2["THICKNESS"] = "thickness";
  return InputName2;
})(SDFOnion_InputName || {});
const SDFOnion_DefaultValues = {
  thickness: 0.1
};
const SDFOnion_OUTPUT_NAME = "sdf";
const SDFOnion_ALLOWED_TYPES = [Gl/* GlConnectionPointType.FLOAT */.Dv.FLOAT, Gl/* GlConnectionPointType.SDF_CONTEXT */.Dv.SDF_CONTEXT];
class SDFOnionGlParamsConfig extends params_ParamsConfig/* NodeParamsConfig */.yI {
}
const SDFOnion_ParamsConfig = new SDFOnionGlParamsConfig();
class SDFOnionGlNode extends gl_Base/* TypedGlNode */.hD {
  constructor() {
    super(...arguments);
    this.paramsConfig = SDFOnion_ParamsConfig;
  }
  static type() {
    return Js/* JsType.SDF_ONION */.K.SDF_ONION;
  }
  initializeNode() {
    super.initializeNode();
    this.io.connection_points.set_input_name_function(this._glInputName.bind(this));
    this.io.connection_points.set_output_name_function(this._glOutputName.bind(this));
    this.io.connection_points.set_expected_input_types_function(this._expectedInputTypes.bind(this));
    this.io.connection_points.set_expected_output_types_function(this._expectedOutputTypes.bind(this));
  }
  paramDefaultValue(name) {
    return SDFOnion_DefaultValues[name];
  }
  _glInputName(index) {
    return ["sdf" /* SDF */, "thickness" /* THICKNESS */][index];
  }
  _glOutputName(index) {
    return SDFOnion_OUTPUT_NAME;
  }
  _expectedInputTypes() {
    let firstInputType = this.io.connection_points.first_input_connection_type();
    if (!firstInputType || SDFOnion_ALLOWED_TYPES.includes(firstInputType)) {
      firstInputType = Gl/* GlConnectionPointType.FLOAT */.Dv.FLOAT;
    }
    return [firstInputType, Gl/* GlConnectionPointType.FLOAT */.Dv.FLOAT];
  }
  _expectedOutputTypes() {
    return [this._expectedInputTypes()[0]];
  }
  setLines(shadersCollectionController) {
    const sdf = ThreeToGl/* ThreeToGl.float */._.float(this.variableForInput("sdf" /* SDF */));
    const thickness = ThreeToGl/* ThreeToGl.float */._.float(this.variableForInput("thickness" /* THICKNESS */));
    const firstInputType = this._expectedInputTypes()[0];
    const bodyLines = [];
    if (firstInputType == Gl/* GlConnectionPointType.FLOAT */.Dv.FLOAT) {
      const float = this.glVarName(SDFOnion_OUTPUT_NAME);
      const bodyLine = `float ${float} = SDFOnion(${sdf}, ${thickness})`;
      bodyLines.push(bodyLine);
    } else {
      const sdfContext = this.glVarName(SDFOnion_OUTPUT_NAME);
      const matId = `${sdf}.d`;
      const bodyLine = `SDFContext ${sdfContext} = SDFContext(SDFOnion(${sdf}.d, ${thickness}), 0, ${matId}, ${matId}, 0.)`;
      bodyLines.push(bodyLine);
    }
    shadersCollectionController.addBodyLines(this, bodyLines);
    _BaseSDF/* BaseSDFGlNode.addSDFMethods */.s.addSDFMethods(shadersCollectionController, this);
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/gl/SDFPlane.ts






const SDFPlane_OUTPUT_NAME = "float";
class SDFPlaneGlParamsConfig extends params_ParamsConfig/* NodeParamsConfig */.yI {
  constructor() {
    super(...arguments);
    this.position = params_ParamsConfig/* ParamConfig.VECTOR3 */.XC.VECTOR3([0, 0, 0], { hidden: true });
    this.center = params_ParamsConfig/* ParamConfig.VECTOR3 */.XC.VECTOR3([0, 0, 0]);
    this.normal = params_ParamsConfig/* ParamConfig.VECTOR3 */.XC.VECTOR3([0, 1, 0]);
    this.offset = params_ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(0, {
      range: [-1, 1],
      rangeLocked: [false, false]
    });
  }
}
const SDFPlane_ParamsConfig = new SDFPlaneGlParamsConfig();
class SDFPlaneGlNode extends _BaseSDF/* BaseSDFGlNode */.s {
  constructor() {
    super(...arguments);
    this.paramsConfig = SDFPlane_ParamsConfig;
  }
  static type() {
    return types_Gl/* GlType.SDF_PLANE */.P.SDF_PLANE;
  }
  initializeNode() {
    super.initializeNode();
    this.io.outputs.setNamedOutputConnectionPoints([
      new Gl/* GlConnectionPoint */.E(SDFPlane_OUTPUT_NAME, Gl/* GlConnectionPointType.FLOAT */.Dv.FLOAT)
    ]);
  }
  setLines(shadersCollectionController) {
    const position = this.position();
    const center = ThreeToGl/* ThreeToGl.vector3 */._.vector3(this.variableForInputParam(this.p.center));
    const normal = ThreeToGl/* ThreeToGl.vector3 */._.vector3(this.variableForInputParam(this.p.normal));
    const offset = ThreeToGl/* ThreeToGl.float */._.float(this.variableForInputParam(this.p.offset));
    const float = this.glVarName(SDFPlane_OUTPUT_NAME);
    const bodyLine = `float ${float} = sdPlane(${position}-${center}, ${normal}, ${offset})`;
    shadersCollectionController.addBodyLines(this, [bodyLine]);
    this._addSDFMethods(shadersCollectionController);
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/gl/SDFPyramid.ts






const SDFPyramid_OUTPUT_NAME = "float";
class SDFPyramidGlParamsConfig extends params_ParamsConfig/* NodeParamsConfig */.yI {
  constructor() {
    super(...arguments);
    this.position = params_ParamsConfig/* ParamConfig.VECTOR3 */.XC.VECTOR3([0, 0, 0], { hidden: true });
    this.center = params_ParamsConfig/* ParamConfig.VECTOR3 */.XC.VECTOR3([0, 0, 0]);
    this.height = params_ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(1);
  }
}
const SDFPyramid_ParamsConfig = new SDFPyramidGlParamsConfig();
class SDFPyramidGlNode extends _BaseSDF/* BaseSDFGlNode */.s {
  constructor() {
    super(...arguments);
    this.paramsConfig = SDFPyramid_ParamsConfig;
  }
  static type() {
    return types_Gl/* GlType.SDF_PYRAMID */.P.SDF_PYRAMID;
  }
  initializeNode() {
    super.initializeNode();
    this.io.outputs.setNamedOutputConnectionPoints([
      new Gl/* GlConnectionPoint */.E(SDFPyramid_OUTPUT_NAME, Gl/* GlConnectionPointType.FLOAT */.Dv.FLOAT)
    ]);
  }
  setLines(shadersCollectionController) {
    const position = this.position();
    const center = ThreeToGl/* ThreeToGl.vector3 */._.vector3(this.variableForInputParam(this.p.center));
    const height = ThreeToGl/* ThreeToGl.float */._.float(this.variableForInputParam(this.p.height));
    const float = this.glVarName(SDFPyramid_OUTPUT_NAME);
    const bodyLine = `float ${float} = sdPyramid(${position} - ${center}, ${height})`;
    shadersCollectionController.addBodyLines(this, [bodyLine]);
    this._addSDFMethods(shadersCollectionController);
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/gl/SDFQuad.ts






const SDFQuad_OUTPUT_NAME = "float";
class SDFQuadGlParamsConfig extends params_ParamsConfig/* NodeParamsConfig */.yI {
  constructor() {
    super(...arguments);
    this.position = params_ParamsConfig/* ParamConfig.VECTOR3 */.XC.VECTOR3([0, 0, 0], { hidden: true });
    this.center = params_ParamsConfig/* ParamConfig.VECTOR3 */.XC.VECTOR3([0, 0, 0]);
    this.a = params_ParamsConfig/* ParamConfig.VECTOR3 */.XC.VECTOR3([0, 0, 0]);
    this.b = params_ParamsConfig/* ParamConfig.VECTOR3 */.XC.VECTOR3([0, 1, 0]);
    this.c = params_ParamsConfig/* ParamConfig.VECTOR3 */.XC.VECTOR3([0, 1, 1]);
    this.d = params_ParamsConfig/* ParamConfig.VECTOR3 */.XC.VECTOR3([0, 0, 1]);
    this.thickness = params_ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(0.1);
  }
}
const SDFQuad_ParamsConfig = new SDFQuadGlParamsConfig();
class SDFQuadGlNode extends _BaseSDF/* BaseSDFGlNode */.s {
  constructor() {
    super(...arguments);
    this.paramsConfig = SDFQuad_ParamsConfig;
  }
  static type() {
    return types_Gl/* GlType.SDF_QUAD */.P.SDF_QUAD;
  }
  initializeNode() {
    super.initializeNode();
    this.io.outputs.setNamedOutputConnectionPoints([
      new Gl/* GlConnectionPoint */.E(SDFQuad_OUTPUT_NAME, Gl/* GlConnectionPointType.FLOAT */.Dv.FLOAT)
    ]);
  }
  setLines(shadersCollectionController) {
    const position = this.position();
    const center = ThreeToGl/* ThreeToGl.vector3 */._.vector3(this.variableForInputParam(this.p.center));
    const a = ThreeToGl/* ThreeToGl.float */._.float(this.variableForInputParam(this.p.a));
    const b = ThreeToGl/* ThreeToGl.float */._.float(this.variableForInputParam(this.p.b));
    const c = ThreeToGl/* ThreeToGl.float */._.float(this.variableForInputParam(this.p.c));
    const d = ThreeToGl/* ThreeToGl.float */._.float(this.variableForInputParam(this.p.d));
    const thickness = ThreeToGl/* ThreeToGl.float */._.float(this.variableForInputParam(this.p.thickness));
    const float = this.glVarName(SDFQuad_OUTPUT_NAME);
    const bodyLine = `float ${float} = udQuad(${position} - ${center}, ${a}, ${b}, ${c}, ${d}, ${thickness})`;
    shadersCollectionController.addBodyLines(this, [bodyLine]);
    this._addSDFMethods(shadersCollectionController);
  }
}

// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/nodes/gl/SDFRepeat.ts
var SDFRepeat = __webpack_require__(47375);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/nodes/gl/gl/raymarching/sdfRepeat.glsl
var sdfRepeat = __webpack_require__(914);
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/gl/gl/raymarching/sdfRepeatPolar.glsl
/* harmony default export */ var sdfRepeatPolar = ("\n/*\nSDF Repeat in polar coordinates\n*/\n// vec3 SDFRepeatPolar( vec3 p, in vec3 c )\n// {\n// \tvec3 polar = cartesianToPolar(p);\n// \tpolar.x = SDFRepeat(polar.x, c.x);\n// \tpolar.y = SDFRepeat(polar.y, c.y);\n// \tpolar.z = SDFRepeat(polar.z, c.z);\n// \treturn polarToCartesian(polar);\n// }\n// vec3 SDFRepeatPolarX( vec3 p, in vec3 c )\n// {\n// \tvec3 polar = cartesianToPolar(p);\n// \tpolar.x = SDFRepeat(polar.x, c.x);\n// \treturn polarToCartesian(polar);\n// }\n// vec3 SDFRepeatPolarY( vec3 p, in vec3 c )\n// {\n// \tvec3 polar = cartesianToPolar(p);\n// \tpolar.y = SDFRepeat(polar.y, c.y);\n// \treturn polarToCartesian(polar);\n// }\nvec3 SDFRepeatPolarZ( in vec3 p, in float c )\n{\n\tvec3 polar = cartesianToPolar(p);\n\tpolar.z = SDFRepeat(polar.z, c);\n\treturn polarToCartesian(polar);\n}\n// vec3 SDFRepeatPolarXY( vec3 p, in vec3 c )\n// {\n// \tvec3 polar = cartesianToPolar(p);\n// \tpolar.x = SDFRepeat(polar.x, c.x);\n// \tpolar.y = SDFRepeat(polar.y, c.y);\n// \treturn polarToCartesian(polar);\n// }\n// vec3 SDFRepeatPolarXZ( vec3 p, in vec3 c )\n// {\n// \tvec3 polar = cartesianToPolar(p);\n// \tpolar.x = SDFRepeat(polar.x, c.x);\n// \tpolar.z = SDFRepeat(polar.z, c.z);\n// \treturn polarToCartesian(polar);\n// }\n// vec3 SDFRepeatPolarYZ( vec3 p, in vec3 c )\n// {\n// \tvec3 polar = cartesianToPolar(p);\n// \tpolar.y = SDFRepeat(polar.y, c.y);\n// \tpolar.z = SDFRepeat(polar.z, c.z);\n// \treturn polarToCartesian(polar);\n// }");
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/gl/SDFRepeatPolar.ts









const SDFRepeatPolar_OUTPUT_NAME = "p";
class SDFRepeatPolarGlParamsConfig extends params_ParamsConfig/* NodeParamsConfig */.yI {
  constructor() {
    super(...arguments);
    this.position = params_ParamsConfig/* ParamConfig.VECTOR3 */.XC.VECTOR3([0, 0, 0], { hidden: true });
    this.center = params_ParamsConfig/* ParamConfig.VECTOR3 */.XC.VECTOR3([0, 0, 0]);
    // repeatLon = ParamConfig.BOOLEAN(1);
    this.periodLon = params_ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(1, {
      // visibleIf: {repeatLon: true},
      range: [0, Math.PI]
    });
  }
  // repeatLat = ParamConfig.BOOLEAN(1);
  // periodLat = ParamConfig.FLOAT(1, {
  // 	visibleIf: {repeatLat: true},
  // 	range: [0, 0.5 * Math.PI],
  // });
  // repeatDepth = ParamConfig.BOOLEAN(1);
  // periodDepth = ParamConfig.FLOAT(1, {
  // 	visibleIf: {repeatDepth: true},
  // });
}
const SDFRepeatPolar_ParamsConfig = new SDFRepeatPolarGlParamsConfig();
class SDFRepeatPolarGlNode extends _BaseSDF/* BaseSDFGlNode */.s {
  constructor() {
    super(...arguments);
    this.paramsConfig = SDFRepeatPolar_ParamsConfig;
  }
  static type() {
    return "SDFRepeatPolar";
  }
  initializeNode() {
    super.initializeNode();
    this.io.outputs.setNamedOutputConnectionPoints([
      new Gl/* GlConnectionPoint */.E(SDFRepeatPolar_OUTPUT_NAME, Gl/* GlConnectionPointType.VEC3 */.Dv.VEC3)
    ]);
  }
  setLines(shadersCollectionController) {
    const position = this.position();
    const center = ThreeToGl/* ThreeToGl.vector3 */._.vector3(this.variableForInputParam(this.p.center));
    const periodLon = ThreeToGl/* ThreeToGl.float */._.float(this.variableForInputParam(this.p.periodLon));
    const float = this.glVarName(SDFRepeatPolar_OUTPUT_NAME);
    const functionName = "SDFRepeatPolarZ";
    const bodyLine = `vec3 ${float} = ${functionName}(${position} - ${center}, ${periodLon})`;
    shadersCollectionController.addBodyLines(this, [bodyLine]);
    shadersCollectionController.addDefinitions(this, [
      new GLDefinition/* FunctionGLDefinition */.MR(this, gl_polar),
      new GLDefinition/* FunctionGLDefinition */.MR(this, sdfRepeat/* default */.Z),
      new GLDefinition/* FunctionGLDefinition */.MR(this, sdfRepeatPolar)
    ]);
  }
  // protected _functionSuffix() {
  // 	const lon = isBooleanTrue(this.pv.repeatLon);
  // 	const lat = isBooleanTrue(this.pv.repeatLat);
  // 	const d = isBooleanTrue(this.pv.repeatDepth);
  // 	if (lon && lat && d) {
  // 		return '';
  // 	}
  // 	const args: string[] = [];
  // 	if (d) args.push('X');
  // 	if (lat) args.push('Y');
  // 	if (lon) args.push('Z');
  // 	return args.join('');
  // }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/gl/SDFRevolution.ts






var SDFRevolutionGlAxis = /* @__PURE__ */ ((SDFRevolutionGlAxis2) => {
  SDFRevolutionGlAxis2["X"] = "X";
  SDFRevolutionGlAxis2["Y"] = "Y";
  SDFRevolutionGlAxis2["Z"] = "Z";
  return SDFRevolutionGlAxis2;
})(SDFRevolutionGlAxis || {});
const SDF_REVOLUTION_AXISES = [
  "X" /* X */,
  "Y" /* Y */,
  "Z" /* Z */
];
const SDFRevolution_OUTPUT_NAME = "p";
class SDFRevolutionGlParamsConfig extends params_ParamsConfig/* NodeParamsConfig */.yI {
  constructor() {
    super(...arguments);
    this.position = params_ParamsConfig/* ParamConfig.VECTOR3 */.XC.VECTOR3([0, 0, 0], { hidden: true });
    this.center = params_ParamsConfig/* ParamConfig.VECTOR3 */.XC.VECTOR3([0, 0, 0]);
    this.radius = params_ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(1);
    this.axis = params_ParamsConfig/* ParamConfig.INTEGER */.XC.INTEGER(SDF_REVOLUTION_AXISES.indexOf("Y" /* Y */), {
      menu: {
        entries: SDF_REVOLUTION_AXISES.map((name, value) => ({ name, value }))
      }
    });
  }
}
const SDFRevolution_ParamsConfig = new SDFRevolutionGlParamsConfig();
class SDFRevolutionGlNode extends _BaseSDF/* BaseSDFGlNode */.s {
  constructor() {
    super(...arguments);
    this.paramsConfig = SDFRevolution_ParamsConfig;
  }
  static type() {
    return types_Gl/* GlType.SDF_REVOLUTION */.P.SDF_REVOLUTION;
  }
  initializeNode() {
    super.initializeNode();
    this.io.outputs.setNamedOutputConnectionPoints([
      new Gl/* GlConnectionPoint */.E(SDFRevolution_OUTPUT_NAME, Gl/* GlConnectionPointType.VEC2 */.Dv.VEC2)
    ]);
  }
  setAxis(axis) {
    this.p.axis.set(SDF_REVOLUTION_AXISES.indexOf(axis));
  }
  setLines(shadersCollectionController) {
    const position = this.position();
    const center = ThreeToGl/* ThreeToGl.vector3 */._.vector3(this.variableForInputParam(this.p.center));
    const radius = ThreeToGl/* ThreeToGl.float */._.float(this.variableForInputParam(this.p.radius));
    const out = this.glVarName(SDFRevolution_OUTPUT_NAME);
    const functionName = this._functionName();
    const bodyLine = `vec2 ${out} = ${functionName}(${position} - ${center}, ${radius})`;
    shadersCollectionController.addBodyLines(this, [bodyLine]);
    this._addSDFMethods(shadersCollectionController);
  }
  _functionName() {
    const axis = SDF_REVOLUTION_AXISES[this.pv.axis];
    return `SDFRevolution${axis}`;
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/gl/gl/raymarching/sdfRhombus.glsl
/* harmony default export */ var sdfRhombus = ("float sdRhombus(vec3 p, float la, float lb, float h, float ra)\n{\n\tp = abs(p);\n\tvec2 b = vec2(la,lb);\n\tfloat f = clamp( (ndot(b,b-2.0*p.xz))/dot(b,b), -1.0, 1.0 );\n\tvec2 q = vec2(length(p.xz-0.5*b*vec2(1.0-f,1.0+f))*sign(p.x*b.y+p.z*b.x-b.x*b.y)-ra, p.y-h);\n\treturn min(max(q.x,q.y),0.0) + length(max(q,0.0));\n}");
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/gl/SDFRhombus.ts








const SDFRhombus_OUTPUT_NAME = "float";
class SDFRhombusGlParamsConfig extends params_ParamsConfig/* NodeParamsConfig */.yI {
  constructor() {
    super(...arguments);
    this.position = params_ParamsConfig/* ParamConfig.VECTOR3 */.XC.VECTOR3([0, 0, 0], { hidden: true });
    this.center = params_ParamsConfig/* ParamConfig.VECTOR3 */.XC.VECTOR3([0, 0, 0]);
    this.length1 = params_ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(1);
    this.length2 = params_ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(0.5);
    this.height = params_ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(0.2);
    this.radius = params_ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(0.05);
  }
}
const SDFRhombus_ParamsConfig = new SDFRhombusGlParamsConfig();
class SDFRhombusGlNode extends _BaseSDF/* BaseSDFGlNode */.s {
  constructor() {
    super(...arguments);
    this.paramsConfig = SDFRhombus_ParamsConfig;
  }
  static type() {
    return types_Gl/* GlType.SDF_RHOMBUS */.P.SDF_RHOMBUS;
  }
  initializeNode() {
    super.initializeNode();
    this.io.outputs.setNamedOutputConnectionPoints([
      new Gl/* GlConnectionPoint */.E(SDFRhombus_OUTPUT_NAME, Gl/* GlConnectionPointType.FLOAT */.Dv.FLOAT)
    ]);
  }
  setLines(shadersCollectionController) {
    const position = this.position();
    const center = ThreeToGl/* ThreeToGl.vector3 */._.vector3(this.variableForInputParam(this.p.center));
    const length1 = ThreeToGl/* ThreeToGl.float */._.float(this.variableForInputParam(this.p.length1));
    const length2 = ThreeToGl/* ThreeToGl.float */._.float(this.variableForInputParam(this.p.length2));
    const height = ThreeToGl/* ThreeToGl.float */._.float(this.variableForInputParam(this.p.height));
    const radius = ThreeToGl/* ThreeToGl.float */._.float(this.variableForInputParam(this.p.radius));
    const float = this.glVarName(SDFRhombus_OUTPUT_NAME);
    const bodyLine = `float ${float} = sdRhombus(${position} - ${center}, ${length1}, ${length2}, ${height}, ${radius})`;
    shadersCollectionController.addBodyLines(this, [bodyLine]);
    this._addSDFMethods(shadersCollectionController);
    shadersCollectionController.addDefinitions(this, [new GLDefinition/* FunctionGLDefinition */.MR(this, sdfRhombus)]);
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/gl/gl/raymarching/sdfRhombusTriacontahedron.glsl
/* harmony default export */ var sdfRhombusTriacontahedron = ("// https://www.shadertoy.com/view/sllGDN\nfloat sdRhombusTriacontahedron(vec3 p, float m1, float m2, float f)\n{\n\tfloat d = sdBox(p, vec3(1));\n\n\tfloat c = cos(3.1415 * m1);\n\tfloat s=sqrt(m2-c*c);\n\tvec3 n = vec3(-0.5, -c, s);\n\n\tp = abs(p);\n\tp -= f*min(0., dot(p, n))*n;\n\n\tp.xy = abs(p.xy);\n\tp -= f*min(0., dot(p, n))*n;\n\n\tp.xy = abs(p.xy);\n\tp -= f*min(0., dot(p, n))*n;\n\n\td = p.z-1.;\n\treturn d;\n}");
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/gl/SDFRhombusTriacontahedron.ts








const SDFRhombusTriacontahedron_OUTPUT_NAME = "float";
class SDFRhombusTriacontahedronGlParamsConfig extends params_ParamsConfig/* NodeParamsConfig */.yI {
  constructor() {
    super(...arguments);
    this.position = params_ParamsConfig/* ParamConfig.VECTOR3 */.XC.VECTOR3([0, 0, 0], { hidden: true });
    this.center = params_ParamsConfig/* ParamConfig.VECTOR3 */.XC.VECTOR3([0, 0, 0]);
    this.m1 = params_ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(0.2);
    this.m2 = params_ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(0.75);
    this.f = params_ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(2, {
      range: [0, 4]
    });
  }
}
const SDFRhombusTriacontahedron_ParamsConfig = new SDFRhombusTriacontahedronGlParamsConfig();
class SDFRhombusTriacontahedronGlNode extends _BaseSDF/* BaseSDFGlNode */.s {
  constructor() {
    super(...arguments);
    this.paramsConfig = SDFRhombusTriacontahedron_ParamsConfig;
  }
  static type() {
    return types_Gl/* GlType.SDF_RHOMBUS_TRIACONTAHEDRON */.P.SDF_RHOMBUS_TRIACONTAHEDRON;
  }
  initializeNode() {
    super.initializeNode();
    this.io.outputs.setNamedOutputConnectionPoints([
      new Gl/* GlConnectionPoint */.E(SDFRhombusTriacontahedron_OUTPUT_NAME, Gl/* GlConnectionPointType.FLOAT */.Dv.FLOAT)
    ]);
  }
  setLines(shadersCollectionController) {
    const position = this.position();
    const center = ThreeToGl/* ThreeToGl.vector3 */._.vector3(this.variableForInputParam(this.p.center));
    const m1 = ThreeToGl/* ThreeToGl.float */._.float(this.variableForInputParam(this.p.m1));
    const m2 = ThreeToGl/* ThreeToGl.float */._.float(this.variableForInputParam(this.p.m2));
    const f = ThreeToGl/* ThreeToGl.float */._.float(this.variableForInputParam(this.p.f));
    const float = this.glVarName(SDFRhombusTriacontahedron_OUTPUT_NAME);
    const bodyLine = `float ${float} = sdRhombusTriacontahedron(${position} - ${center}, ${m1}, ${m2}, ${f})`;
    shadersCollectionController.addBodyLines(this, [bodyLine]);
    this._addSDFMethods(shadersCollectionController);
    shadersCollectionController.addDefinitions(this, [new GLDefinition/* FunctionGLDefinition */.MR(this, sdfRhombusTriacontahedron)]);
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/gl/SDFSolidAngle.ts






const SDFSolidAngle_OUTPUT_NAME = "float";
class SDFSolidAngleGlParamsConfig extends params_ParamsConfig/* NodeParamsConfig */.yI {
  constructor() {
    super(...arguments);
    this.position = params_ParamsConfig/* ParamConfig.VECTOR3 */.XC.VECTOR3([0, 0, 0], { hidden: true });
    this.center = params_ParamsConfig/* ParamConfig.VECTOR3 */.XC.VECTOR3([0, 0, 0]);
    this.angle = params_ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(0.25 * Math.PI, {
      range: [0, Math.PI],
      rangeLocked: [true, false],
      step: 1e-5
    });
    this.radius = params_ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(0.5);
  }
}
const SDFSolidAngle_ParamsConfig = new SDFSolidAngleGlParamsConfig();
class SDFSolidAngleGlNode extends _BaseSDF/* BaseSDFGlNode */.s {
  constructor() {
    super(...arguments);
    this.paramsConfig = SDFSolidAngle_ParamsConfig;
  }
  static type() {
    return types_Gl/* GlType.SDF_SOLID_ANGLE */.P.SDF_SOLID_ANGLE;
  }
  initializeNode() {
    super.initializeNode();
    this.io.outputs.setNamedOutputConnectionPoints([
      new Gl/* GlConnectionPoint */.E(SDFSolidAngle_OUTPUT_NAME, Gl/* GlConnectionPointType.FLOAT */.Dv.FLOAT)
    ]);
  }
  setLines(shadersCollectionController) {
    const position = this.position();
    const center = ThreeToGl/* ThreeToGl.vector3 */._.vector3(this.variableForInputParam(this.p.center));
    const angle = ThreeToGl/* ThreeToGl.vector2 */._.vector2(this.variableForInputParam(this.p.angle));
    const radius = ThreeToGl/* ThreeToGl.float */._.float(this.variableForInputParam(this.p.radius));
    const float = this.glVarName(SDFSolidAngle_OUTPUT_NAME);
    const bodyLine = `float ${float} = sdSolidAngleWrapped(${position} - ${center}, ${angle}, ${radius})`;
    shadersCollectionController.addBodyLines(this, [bodyLine]);
    this._addSDFMethods(shadersCollectionController);
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/gl/SDFSphere.ts






const SDFSphere_OUTPUT_NAME = "float";
class SDFSphereGlParamsConfig extends params_ParamsConfig/* NodeParamsConfig */.yI {
  constructor() {
    super(...arguments);
    this.position = params_ParamsConfig/* ParamConfig.VECTOR3 */.XC.VECTOR3([0, 0, 0], { hidden: true });
    this.center = params_ParamsConfig/* ParamConfig.VECTOR3 */.XC.VECTOR3([0, 0, 0]);
    this.radius = params_ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(1);
  }
}
const SDFSphere_ParamsConfig = new SDFSphereGlParamsConfig();
class SDFSphereGlNode extends _BaseSDF/* BaseSDFGlNode */.s {
  constructor() {
    super(...arguments);
    this.paramsConfig = SDFSphere_ParamsConfig;
  }
  static type() {
    return types_Gl/* GlType.SDF_SPHERE */.P.SDF_SPHERE;
  }
  initializeNode() {
    super.initializeNode();
    this.io.outputs.setNamedOutputConnectionPoints([
      new Gl/* GlConnectionPoint */.E(SDFSphere_OUTPUT_NAME, Gl/* GlConnectionPointType.FLOAT */.Dv.FLOAT)
    ]);
  }
  setLines(shadersCollectionController) {
    const position = this.position();
    const center = ThreeToGl/* ThreeToGl.vector3 */._.vector3(this.variableForInputParam(this.p.center));
    const radius = ThreeToGl/* ThreeToGl.float */._.float(this.variableForInputParam(this.p.radius));
    const float = this.glVarName(SDFSphere_OUTPUT_NAME);
    const bodyLine = `float ${float} = sdSphere(${position} - ${center}, ${radius})`;
    shadersCollectionController.addBodyLines(this, [bodyLine]);
    this._addSDFMethods(shadersCollectionController);
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/gl/SDFSphereCut.ts






const SDFSphereCut_OUTPUT_NAME = "float";
class SDFSphereCutGlParamsConfig extends params_ParamsConfig/* NodeParamsConfig */.yI {
  constructor() {
    super(...arguments);
    this.position = params_ParamsConfig/* ParamConfig.VECTOR3 */.XC.VECTOR3([0, 0, 0], { hidden: true });
    this.center = params_ParamsConfig/* ParamConfig.VECTOR3 */.XC.VECTOR3([0, 0, 0]);
    this.radius = params_ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(1);
    this.height = params_ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(0, {
      range: [-1, 1],
      rangeLocked: [false, false]
    });
  }
}
const SDFSphereCut_ParamsConfig = new SDFSphereCutGlParamsConfig();
class SDFSphereCutGlNode extends _BaseSDF/* BaseSDFGlNode */.s {
  constructor() {
    super(...arguments);
    this.paramsConfig = SDFSphereCut_ParamsConfig;
  }
  static type() {
    return types_Gl/* GlType.SDF_SPHERE_CUT */.P.SDF_SPHERE_CUT;
  }
  initializeNode() {
    super.initializeNode();
    this.io.outputs.setNamedOutputConnectionPoints([
      new Gl/* GlConnectionPoint */.E(SDFSphereCut_OUTPUT_NAME, Gl/* GlConnectionPointType.FLOAT */.Dv.FLOAT)
    ]);
  }
  setLines(shadersCollectionController) {
    const position = this.position();
    const center = ThreeToGl/* ThreeToGl.vector3 */._.vector3(this.variableForInputParam(this.p.center));
    const radius = ThreeToGl/* ThreeToGl.float */._.float(this.variableForInputParam(this.p.radius));
    const height = ThreeToGl/* ThreeToGl.float */._.float(this.variableForInputParam(this.p.height));
    const float = this.glVarName(SDFSphereCut_OUTPUT_NAME);
    const bodyLine = `float ${float} = sdCutSphere(${position} - ${center}, ${radius}, ${height})`;
    shadersCollectionController.addBodyLines(this, [bodyLine]);
    this._addSDFMethods(shadersCollectionController);
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/gl/SDFSphereHollow.ts






const SDFSphereHollow_OUTPUT_NAME = "float";
class SDFSphereHollowGlParamsConfig extends params_ParamsConfig/* NodeParamsConfig */.yI {
  constructor() {
    super(...arguments);
    this.position = params_ParamsConfig/* ParamConfig.VECTOR3 */.XC.VECTOR3([0, 0, 0], { hidden: true });
    this.center = params_ParamsConfig/* ParamConfig.VECTOR3 */.XC.VECTOR3([0, 0, 0]);
    this.radius = params_ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(1);
    this.height = params_ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(0, {
      range: [-1, 1],
      rangeLocked: [false, false]
    });
    this.thickness = params_ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(0.1, {
      range: [0, 1],
      rangeLocked: [false, false]
    });
  }
}
const SDFSphereHollow_ParamsConfig = new SDFSphereHollowGlParamsConfig();
class SDFSphereHollowGlNode extends _BaseSDF/* BaseSDFGlNode */.s {
  constructor() {
    super(...arguments);
    this.paramsConfig = SDFSphereHollow_ParamsConfig;
  }
  static type() {
    return types_Gl/* GlType.SDF_SPHERE_HOLLOW */.P.SDF_SPHERE_HOLLOW;
  }
  initializeNode() {
    super.initializeNode();
    this.io.outputs.setNamedOutputConnectionPoints([
      new Gl/* GlConnectionPoint */.E(SDFSphereHollow_OUTPUT_NAME, Gl/* GlConnectionPointType.FLOAT */.Dv.FLOAT)
    ]);
  }
  setLines(shadersCollectionController) {
    const position = this.position();
    const center = ThreeToGl/* ThreeToGl.vector3 */._.vector3(this.variableForInputParam(this.p.center));
    const radius = ThreeToGl/* ThreeToGl.float */._.float(this.variableForInputParam(this.p.radius));
    const height = ThreeToGl/* ThreeToGl.float */._.float(this.variableForInputParam(this.p.height));
    const thickness = ThreeToGl/* ThreeToGl.float */._.float(this.variableForInputParam(this.p.thickness));
    const float = this.glVarName(SDFSphereHollow_OUTPUT_NAME);
    const bodyLine = `float ${float} = sdCutHollowSphere(${position} - ${center}, ${radius}, ${height}, ${thickness})`;
    shadersCollectionController.addBodyLines(this, [bodyLine]);
    this._addSDFMethods(shadersCollectionController);
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/gl/SDFSubtract.ts









var SDFSubtract_InputName = /* @__PURE__ */ ((InputName2) => {
  InputName2["SDF0"] = "sdf0";
  InputName2["SDF1"] = "sdf1";
  InputName2["SMOOTH_FACTOR"] = "smoothFactor";
  InputName2["MAT_BLEND_DIST"] = "matBlendDist";
  return InputName2;
})(SDFSubtract_InputName || {});
const SDFSubtract_OUTPUT_NAME = "subtract";
const SDFSubtract_ALLOWED_TYPES = [Gl/* GlConnectionPointType.FLOAT */.Dv.FLOAT, Gl/* GlConnectionPointType.SDF_CONTEXT */.Dv.SDF_CONTEXT];
class SDFSubtractGlParamsConfig extends params_ParamsConfig/* NodeParamsConfig */.yI {
  constructor() {
    super(...arguments);
    this.smooth = params_ParamsConfig/* ParamConfig.BOOLEAN */.XC.BOOLEAN(1);
  }
}
const SDFSubtract_ParamsConfig = new SDFSubtractGlParamsConfig();
class SDFSubtractGlNode extends gl_Base/* TypedGlNode */.hD {
  constructor() {
    super(...arguments);
    this.paramsConfig = SDFSubtract_ParamsConfig;
  }
  static type() {
    return "SDFSubtract";
  }
  initializeNode() {
    super.initializeNode();
    this.io.connection_points.spare_params.setInputlessParamNames(["smooth"]);
    this.io.connection_points.set_input_name_function(this._glInputName.bind(this));
    this.io.connection_points.set_output_name_function(this._glOutputName.bind(this));
    this.io.connection_points.set_expected_input_types_function(this._expectedInputTypes.bind(this));
    this.io.connection_points.set_expected_output_types_function(this._expectedOutputTypes.bind(this));
  }
  _glInputName(index) {
    return ["sdf0" /* SDF0 */, "sdf1" /* SDF1 */, "smoothFactor" /* SMOOTH_FACTOR */, "matBlendDist" /* MAT_BLEND_DIST */][index];
  }
  _glOutputName(index) {
    return SDFSubtract_OUTPUT_NAME;
  }
  _expectedInputTypes() {
    let firstInputType = this.io.connection_points.first_input_connection_type();
    if (!firstInputType || !SDFSubtract_ALLOWED_TYPES.includes(firstInputType)) {
      firstInputType = Gl/* GlConnectionPointType.FLOAT */.Dv.FLOAT;
    }
    return [firstInputType, firstInputType, Gl/* GlConnectionPointType.FLOAT */.Dv.FLOAT, Gl/* GlConnectionPointType.FLOAT */.Dv.FLOAT];
  }
  _expectedOutputTypes() {
    return [this._expectedInputTypes()[0]];
  }
  setLines(shadersCollectionController) {
    const smooth = (0,Type/* isBooleanTrue */.bI)(this.pv.smooth);
    const sdf0 = ThreeToGl/* ThreeToGl.float */._.float(this.variableForInput("sdf0" /* SDF0 */));
    const sdf1 = ThreeToGl/* ThreeToGl.float */._.float(this.variableForInput("sdf1" /* SDF1 */));
    const smoothFactor = ThreeToGl/* ThreeToGl.float */._.float(this.variableForInput("smoothFactor" /* SMOOTH_FACTOR */));
    const firstInputType = this._expectedInputTypes()[0];
    const bodyLines = [];
    if (firstInputType == Gl/* GlConnectionPointType.FLOAT */.Dv.FLOAT) {
      const float = this.glVarName(SDFSubtract_OUTPUT_NAME);
      const withSmooth = `SDFSmoothSubtract(${sdf0}, ${sdf1}, ${smoothFactor})`;
      const withoutSmooth = `SDFSubtract(${sdf0}, ${sdf1})`;
      const functionCall = smooth ? withSmooth : withoutSmooth;
      const bodyLine = `float ${float} = ${functionCall}`;
      bodyLines.push(bodyLine);
    } else {
      const sdfContext = this.glVarName(SDFSubtract_OUTPUT_NAME);
      const matBlendDist = ThreeToGl/* ThreeToGl.float */._.float(this.variableForInput("matBlendDist" /* MAT_BLEND_DIST */));
      sdfSmoothLines({
        node: this,
        vars: {
          sdf0,
          sdf1,
          sdfContext,
          smooth,
          matBlendDist,
          smoothFactor
        },
        functionNames: {
          smooth: "SDFSmoothSubtract",
          default: "SDFSubtract"
        },
        bodyLines
      });
    }
    shadersCollectionController.addBodyLines(this, bodyLines);
    _BaseSDF/* BaseSDFGlNode.addSDFMethods */.s.addSDFMethods(shadersCollectionController, this);
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/gl/SDFTorus.ts







const SDFTorus_OUTPUT_NAME = "float";
class SDFTorusGlParamsConfig extends params_ParamsConfig/* NodeParamsConfig */.yI {
  constructor() {
    super(...arguments);
    this.position = params_ParamsConfig/* ParamConfig.VECTOR3 */.XC.VECTOR3([0, 0, 0], { hidden: true });
    this.center = params_ParamsConfig/* ParamConfig.VECTOR3 */.XC.VECTOR3([0, 0, 0]);
    this.radius1 = params_ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(1);
    this.radius2 = params_ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(0.1);
    this.capped = params_ParamsConfig/* ParamConfig.BOOLEAN */.XC.BOOLEAN(0);
    this.angle = params_ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(0.5 * Math.PI, {
      range: [0, Math.PI],
      rangeLocked: [true, true],
      step: 1e-4,
      visibleIf: { capped: 1 }
    });
  }
}
const SDFTorus_ParamsConfig = new SDFTorusGlParamsConfig();
class SDFTorusGlNode extends _BaseSDF/* BaseSDFGlNode */.s {
  constructor() {
    super(...arguments);
    this.paramsConfig = SDFTorus_ParamsConfig;
  }
  static type() {
    return types_Gl/* GlType.SDF_TORUS */.P.SDF_TORUS;
  }
  initializeNode() {
    super.initializeNode();
    this.io.connection_points.spare_params.setInputlessParamNames(["capped"]);
    this.io.outputs.setNamedOutputConnectionPoints([
      new Gl/* GlConnectionPoint */.E(SDFTorus_OUTPUT_NAME, Gl/* GlConnectionPointType.FLOAT */.Dv.FLOAT)
    ]);
  }
  setLines(shadersCollectionController) {
    const position = this.position();
    const center = ThreeToGl/* ThreeToGl.vector3 */._.vector3(this.variableForInputParam(this.p.center));
    const radius1 = ThreeToGl/* ThreeToGl.float */._.float(this.variableForInputParam(this.p.radius1));
    const radius2 = ThreeToGl/* ThreeToGl.float */._.float(this.variableForInputParam(this.p.radius2));
    const float = this.glVarName(SDFTorus_OUTPUT_NAME);
    if ((0,Type/* isBooleanTrue */.bI)(this.pv.capped)) {
      const angle = ThreeToGl/* ThreeToGl.float */._.float(this.variableForInputParam(this.p.angle));
      const torusCapped = `sdCappedTorus(${position} - ${center}, ${angle}, ${radius1}, ${radius2})`;
      const bodyLine = `float ${float} = ${torusCapped}`;
      shadersCollectionController.addBodyLines(this, [bodyLine]);
    } else {
      const torus = `sdTorus(${position} - ${center}, vec2(${radius1}, ${radius2}))`;
      const bodyLine = `float ${float} = ${torus}`;
      shadersCollectionController.addBodyLines(this, [bodyLine]);
    }
    this._addSDFMethods(shadersCollectionController);
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/gl/gl/raymarching/sdfTransform.glsl
/* harmony default export */ var sdfTransform = ("mat4 translate( vec3 t )\n{\n    return mat4( 1.0, 0.0, 0.0, 0.0,\n\t\t\t\t 0.0, 1.0, 0.0, 0.0,\n\t\t\t\t 0.0, 0.0, 1.0, 0.0,\n\t\t\t\t t.x,   t.y,   t.z,   1.0 );\n}\n\nvec3 SDFTransform( in vec3 p, vec3 t, vec3 rot )\n{\t\n\tmat4 rotx = rotationMatrix( normalize(vec3(1.0,0.0,0.0)), rot.x );\n\tmat4 roty = rotationMatrix( normalize(vec3(0.0,1.0,0.0)), rot.y );\n\tmat4 rotz = rotationMatrix( normalize(vec3(0.0,0.0,1.0)), rot.z );\n\tmat4 tra = translate( t );\n\tmat4 mat = tra * rotx * roty * rotz; \n\tmat4 matInverse = inverse( mat );\n\treturn (matInverse * vec4(p, 1.)).xyz;\n}\n");
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/gl/SDFTransform.ts









const SDFTransform_OUTPUT_NAME = "p";
class SDFTransformGlParamsConfig extends params_ParamsConfig/* NodeParamsConfig */.yI {
  constructor() {
    super(...arguments);
    this.position = params_ParamsConfig/* ParamConfig.VECTOR3 */.XC.VECTOR3([0, 0, 0], { hidden: true });
    this.t = params_ParamsConfig/* ParamConfig.VECTOR3 */.XC.VECTOR3([0, 0, 0]);
    this.r = params_ParamsConfig/* ParamConfig.VECTOR3 */.XC.VECTOR3([0, 0, 0]);
  }
}
const SDFTransform_ParamsConfig = new SDFTransformGlParamsConfig();
class SDFTransformGlNode extends _BaseSDF/* BaseSDFGlNode */.s {
  constructor() {
    super(...arguments);
    this.paramsConfig = SDFTransform_ParamsConfig;
  }
  static type() {
    return types_Gl/* GlType.SDF_TRANSFORM */.P.SDF_TRANSFORM;
  }
  initializeNode() {
    super.initializeNode();
    this.io.outputs.setNamedOutputConnectionPoints([
      new Gl/* GlConnectionPoint */.E(SDFTransform_OUTPUT_NAME, Gl/* GlConnectionPointType.VEC3 */.Dv.VEC3)
    ]);
  }
  setLines(shadersCollectionController) {
    const position = this.position();
    const t = ThreeToGl/* ThreeToGl.vector3 */._.vector3(this.variableForInputParam(this.p.t));
    const r = ThreeToGl/* ThreeToGl.vector3 */._.vector3(this.variableForInputParam(this.p.r));
    const float = this.glVarName(SDFTransform_OUTPUT_NAME);
    const bodyLine = `vec3 ${float} = SDFTransform(${position}, ${t}, ${r})`;
    shadersCollectionController.addBodyLines(this, [bodyLine]);
    shadersCollectionController.addDefinitions(this, [new GLDefinition/* FunctionGLDefinition */.MR(this, quaternion/* default */.Z)]);
    shadersCollectionController.addDefinitions(this, [new GLDefinition/* FunctionGLDefinition */.MR(this, sdfTransform)]);
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/gl/SDFTriangle.ts






const SDFTriangle_OUTPUT_NAME = "float";
class SDFTriangleGlParamsConfig extends params_ParamsConfig/* NodeParamsConfig */.yI {
  constructor() {
    super(...arguments);
    this.position = params_ParamsConfig/* ParamConfig.VECTOR3 */.XC.VECTOR3([0, 0, 0], { hidden: true });
    this.center = params_ParamsConfig/* ParamConfig.VECTOR3 */.XC.VECTOR3([0, 0, 0]);
    this.a = params_ParamsConfig/* ParamConfig.VECTOR3 */.XC.VECTOR3([0, 0, 0]);
    this.b = params_ParamsConfig/* ParamConfig.VECTOR3 */.XC.VECTOR3([0, 1, 0]);
    this.c = params_ParamsConfig/* ParamConfig.VECTOR3 */.XC.VECTOR3([0, 0, 1]);
    this.thickness = params_ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(0.1);
  }
}
const SDFTriangle_ParamsConfig = new SDFTriangleGlParamsConfig();
class SDFTriangleGlNode extends _BaseSDF/* BaseSDFGlNode */.s {
  constructor() {
    super(...arguments);
    this.paramsConfig = SDFTriangle_ParamsConfig;
  }
  static type() {
    return types_Gl/* GlType.SDF_TRIANGLE */.P.SDF_TRIANGLE;
  }
  initializeNode() {
    super.initializeNode();
    this.io.outputs.setNamedOutputConnectionPoints([
      new Gl/* GlConnectionPoint */.E(SDFTriangle_OUTPUT_NAME, Gl/* GlConnectionPointType.FLOAT */.Dv.FLOAT)
    ]);
  }
  setLines(shadersCollectionController) {
    const position = this.position();
    const center = ThreeToGl/* ThreeToGl.vector3 */._.vector3(this.variableForInputParam(this.p.center));
    const a = ThreeToGl/* ThreeToGl.float */._.float(this.variableForInputParam(this.p.a));
    const b = ThreeToGl/* ThreeToGl.float */._.float(this.variableForInputParam(this.p.b));
    const c = ThreeToGl/* ThreeToGl.float */._.float(this.variableForInputParam(this.p.c));
    const thickness = ThreeToGl/* ThreeToGl.float */._.float(this.variableForInputParam(this.p.thickness));
    const float = this.glVarName(SDFTriangle_OUTPUT_NAME);
    const bodyLine = `float ${float} = udTriangle(${position} - ${center}, ${a}, ${b}, ${c}, ${thickness})`;
    shadersCollectionController.addBodyLines(this, [bodyLine]);
    this._addSDFMethods(shadersCollectionController);
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/gl/SDFTriangularPrism.ts






const SDFTriangularPrism_OUTPUT_NAME = "float";
class SDFTriangularPrismGlParamsConfig extends params_ParamsConfig/* NodeParamsConfig */.yI {
  constructor() {
    super(...arguments);
    this.position = params_ParamsConfig/* ParamConfig.VECTOR3 */.XC.VECTOR3([0, 0, 0], { hidden: true });
    this.center = params_ParamsConfig/* ParamConfig.VECTOR3 */.XC.VECTOR3([0, 0, 0]);
    this.radius = params_ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(0.1);
    this.height = params_ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(1);
  }
}
const SDFTriangularPrism_ParamsConfig = new SDFTriangularPrismGlParamsConfig();
class SDFTriangularPrismGlNode extends _BaseSDF/* BaseSDFGlNode */.s {
  constructor() {
    super(...arguments);
    this.paramsConfig = SDFTriangularPrism_ParamsConfig;
  }
  static type() {
    return types_Gl/* GlType.SDF_TRIANGULAR_PRISM */.P.SDF_TRIANGULAR_PRISM;
  }
  initializeNode() {
    super.initializeNode();
    this.io.outputs.setNamedOutputConnectionPoints([
      new Gl/* GlConnectionPoint */.E(SDFTriangularPrism_OUTPUT_NAME, Gl/* GlConnectionPointType.FLOAT */.Dv.FLOAT)
    ]);
  }
  setLines(shadersCollectionController) {
    const position = this.position();
    const center = ThreeToGl/* ThreeToGl.vector3 */._.vector3(this.variableForInputParam(this.p.center));
    const radius = ThreeToGl/* ThreeToGl.float */._.float(this.variableForInputParam(this.p.radius));
    const height = ThreeToGl/* ThreeToGl.float */._.float(this.variableForInputParam(this.p.height));
    const float = this.glVarName(SDFTriangularPrism_OUTPUT_NAME);
    const bodyLine = `float ${float} = sdTriPrism(${position} - ${center}, vec2(${radius},${height}))`;
    shadersCollectionController.addBodyLines(this, [bodyLine]);
    this._addSDFMethods(shadersCollectionController);
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/gl/SDFTube.ts







const SDFTube_OUTPUT_NAME = "float";
class SDFTubeGlParamsConfig extends params_ParamsConfig/* NodeParamsConfig */.yI {
  constructor() {
    super(...arguments);
    this.position = params_ParamsConfig/* ParamConfig.VECTOR3 */.XC.VECTOR3([0, 0, 0], { hidden: true });
    this.center = params_ParamsConfig/* ParamConfig.VECTOR3 */.XC.VECTOR3([0, 0, 0]);
    this.capped = params_ParamsConfig/* ParamConfig.BOOLEAN */.XC.BOOLEAN(1);
    this.radius = params_ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(0.1);
    this.height = params_ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(1, {
      visibleIf: { capped: 1 }
    });
  }
}
const SDFTube_ParamsConfig = new SDFTubeGlParamsConfig();
class SDFTubeGlNode extends _BaseSDF/* BaseSDFGlNode */.s {
  constructor() {
    super(...arguments);
    this.paramsConfig = SDFTube_ParamsConfig;
  }
  static type() {
    return types_Gl/* GlType.SDF_TUBE */.P.SDF_TUBE;
  }
  initializeNode() {
    super.initializeNode();
    this.io.connection_points.spare_params.setInputlessParamNames(["capped"]);
    this.io.outputs.setNamedOutputConnectionPoints([
      new Gl/* GlConnectionPoint */.E(SDFTube_OUTPUT_NAME, Gl/* GlConnectionPointType.FLOAT */.Dv.FLOAT)
    ]);
  }
  setLines(shadersCollectionController) {
    const position = this.position();
    const center = ThreeToGl/* ThreeToGl.vector3 */._.vector3(this.variableForInputParam(this.p.center));
    const radius = ThreeToGl/* ThreeToGl.float */._.float(this.variableForInputParam(this.p.radius));
    const float = this.glVarName(SDFTube_OUTPUT_NAME);
    if ((0,Type/* isBooleanTrue */.bI)(this.pv.capped)) {
      const height = ThreeToGl/* ThreeToGl.float */._.float(this.variableForInputParam(this.p.height));
      const bodyLine = `float ${float} = sdTubeCapped(${position} - ${center}, ${height}, ${radius})`;
      shadersCollectionController.addBodyLines(this, [bodyLine]);
    } else {
      const bodyLine = `float ${float} = sdTube(${position} - ${center}, ${radius})`;
      shadersCollectionController.addBodyLines(this, [bodyLine]);
    }
    this._addSDFMethods(shadersCollectionController);
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/gl/gl/raymarching/sdfTwist.glsl
/* harmony default export */ var sdfTwist = ("vec3 SDFTwistX( in vec3 p, float twist )\n{\n\tfloat c = cos(twist*p.x);\n\tfloat s = sin(twist*p.x);\n\tmat2 m = mat2(c,-s,s,c);\n\treturn vec3(p.x,m*p.yz);\n}\nvec3 SDFTwistY( in vec3 p, float twist )\n{\n\tfloat c = cos(twist*p.y);\n\tfloat s = sin(twist*p.y);\n\tmat2 m = mat2(c,-s,s,c);\n\tvec2 t = m*p.xz;\n\treturn vec3(t.x,p.y,t.y);\n}\nvec3 SDFTwistZ( in vec3 p, float twist )\n{\n\tfloat c = cos(twist*p.z);\n\tfloat s = sin(twist*p.z);\n\tmat2 m = mat2(c,-s,s,c);\n\treturn vec3(m*p.xy,p.z);\n}");
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/gl/SDFTwist.ts







const AXISES = ["x", "y", "z"];
const SDFTwist_OUTPUT_NAME = "p";
class SDFTwistGlParamsConfig extends params_ParamsConfig/* NodeParamsConfig */.yI {
  constructor() {
    super(...arguments);
    this.position = params_ParamsConfig/* ParamConfig.VECTOR3 */.XC.VECTOR3([0, 0, 0], { hidden: true });
    this.center = params_ParamsConfig/* ParamConfig.VECTOR3 */.XC.VECTOR3([0, 0, 0]);
    this.twist = params_ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(0, {
      range: [-1, 1]
    });
    this.axis = params_ParamsConfig/* ParamConfig.INTEGER */.XC.INTEGER(1, {
      menu: { entries: [0, 1, 2].map((i) => ({ name: AXISES[i], value: i })) }
    });
  }
}
const SDFTwist_ParamsConfig = new SDFTwistGlParamsConfig();
class SDFTwistGlNode extends _BaseSDF/* BaseSDFGlNode */.s {
  constructor() {
    super(...arguments);
    this.paramsConfig = SDFTwist_ParamsConfig;
  }
  static type() {
    return "SDFTwist";
  }
  initializeNode() {
    super.initializeNode();
    this.io.connection_points.spare_params.setInputlessParamNames(["axis"]);
    this.io.outputs.setNamedOutputConnectionPoints([
      new Gl/* GlConnectionPoint */.E(SDFTwist_OUTPUT_NAME, Gl/* GlConnectionPointType.VEC3 */.Dv.VEC3)
    ]);
  }
  setLines(shadersCollectionController) {
    const position = this.position();
    const center = ThreeToGl/* ThreeToGl.vector3 */._.vector3(this.variableForInputParam(this.p.center));
    const twist = ThreeToGl/* ThreeToGl.float */._.float(this.variableForInputParam(this.p.twist));
    const float = this.glVarName(SDFTwist_OUTPUT_NAME);
    const functionName = `SDFTwist${this._functionSuffix()}`;
    const bodyLine = `vec3 ${float} = ${functionName}(${position} - ${center}, ${twist})`;
    shadersCollectionController.addBodyLines(this, [bodyLine]);
    shadersCollectionController.addDefinitions(this, [new GLDefinition/* FunctionGLDefinition */.MR(this, sdfTwist)]);
  }
  _functionSuffix() {
    return AXISES[this.pv.axis].toUpperCase();
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/gl/SDFUnion.ts









var SDFUnion_InputName = /* @__PURE__ */ ((InputName2) => {
  InputName2["SDF0"] = "sdf0";
  InputName2["SDF1"] = "sdf1";
  InputName2["SMOOTH_FACTOR"] = "smoothFactor";
  InputName2["MAT_BLEND_DIST"] = "matBlendDist";
  return InputName2;
})(SDFUnion_InputName || {});
const SDFUnion_OUTPUT_NAME = "union";
const SDFUnion_ALLOWED_TYPES = [Gl/* GlConnectionPointType.FLOAT */.Dv.FLOAT, Gl/* GlConnectionPointType.SDF_CONTEXT */.Dv.SDF_CONTEXT];
class SDFUnionGlParamsConfig extends params_ParamsConfig/* NodeParamsConfig */.yI {
  constructor() {
    super(...arguments);
    this.smooth = params_ParamsConfig/* ParamConfig.BOOLEAN */.XC.BOOLEAN(1);
  }
}
const SDFUnion_ParamsConfig = new SDFUnionGlParamsConfig();
class SDFUnionGlNode extends gl_Base/* TypedGlNode */.hD {
  constructor() {
    super(...arguments);
    this.paramsConfig = SDFUnion_ParamsConfig;
  }
  static type() {
    return "SDFUnion";
  }
  initializeNode() {
    super.initializeNode();
    this.io.connection_points.spare_params.setInputlessParamNames(["smooth"]);
    this.io.connection_points.set_input_name_function(this._glInputName.bind(this));
    this.io.connection_points.set_output_name_function(this._glOutputName.bind(this));
    this.io.connection_points.set_expected_input_types_function(this._expectedInputTypes.bind(this));
    this.io.connection_points.set_expected_output_types_function(this._expectedOutputTypes.bind(this));
  }
  _glInputName(index) {
    return ["sdf0" /* SDF0 */, "sdf1" /* SDF1 */, "smoothFactor" /* SMOOTH_FACTOR */, "matBlendDist" /* MAT_BLEND_DIST */][index];
  }
  _glOutputName(index) {
    return SDFUnion_OUTPUT_NAME;
  }
  _expectedInputTypes() {
    let firstInputType = this.io.connection_points.first_input_connection_type();
    if (!firstInputType || !SDFUnion_ALLOWED_TYPES.includes(firstInputType)) {
      firstInputType = Gl/* GlConnectionPointType.FLOAT */.Dv.FLOAT;
    }
    return [firstInputType, firstInputType, Gl/* GlConnectionPointType.FLOAT */.Dv.FLOAT, Gl/* GlConnectionPointType.FLOAT */.Dv.FLOAT];
  }
  _expectedOutputTypes() {
    return [this._expectedInputTypes()[0]];
  }
  setLines(shadersCollectionController) {
    const smooth = (0,Type/* isBooleanTrue */.bI)(this.pv.smooth);
    const sdf0 = ThreeToGl/* ThreeToGl.float */._.float(this.variableForInput("sdf0" /* SDF0 */));
    const sdf1 = ThreeToGl/* ThreeToGl.float */._.float(this.variableForInput("sdf1" /* SDF1 */));
    const smoothFactor = ThreeToGl/* ThreeToGl.float */._.float(this.variableForInput("smoothFactor" /* SMOOTH_FACTOR */));
    const firstInputType = this._expectedInputTypes()[0];
    const bodyLines = [];
    if (firstInputType == Gl/* GlConnectionPointType.FLOAT */.Dv.FLOAT) {
      const float = this.glVarName(SDFUnion_OUTPUT_NAME);
      const withSmooth = `SDFSmoothUnion(${sdf0}, ${sdf1}, ${smoothFactor})`;
      const withoutSmooth = `SDFUnion(${sdf0}, ${sdf1})`;
      const functionCall = smooth ? withSmooth : withoutSmooth;
      const bodyLine = `float ${float} = ${functionCall}`;
      bodyLines.push(bodyLine);
    } else {
      const sdfContext = this.glVarName(SDFUnion_OUTPUT_NAME);
      const matBlendDist = ThreeToGl/* ThreeToGl.float */._.float(this.variableForInput("matBlendDist" /* MAT_BLEND_DIST */));
      sdfSmoothLines({
        node: this,
        vars: {
          sdf0,
          sdf1,
          sdfContext,
          smooth,
          matBlendDist,
          smoothFactor
        },
        functionNames: {
          smooth: "SDFSmoothUnion",
          default: "SDFUnion"
        },
        bodyLines
      });
    }
    shadersCollectionController.addBodyLines(this, bodyLines);
    _BaseSDF/* BaseSDFGlNode.addSDFMethods */.s.addSDFMethods(shadersCollectionController, this);
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/gl/gl/skinning.glsl
/* harmony default export */ var skinning = ("#include <skinbase_vertex>\n#include <skinning_vertex>\n#include <skinnormal_vertex>");
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/nodes/gl/code/assemblers/_Base.ts
var assemblers_Base = __webpack_require__(59955);
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/gl/Skinning.ts









const TEMPLATE = assemblers_Base/* BaseGlShaderAssembler.expandShader */.X.expandShader(skinning);
const TO_REPLACE_INPUT_POS = `vec4( transformed, 1.0 )`;
const TO_REPLACE_INPUT_NORMAL = `vec4( objectNormal, 0.0 )`;
const TO_REPLACE_OUTPUT_POS = `transformed = `;
const TO_REPLACE_OUTPUT_NORMAL = `objectNormal = `;
const TO_REPLACE_OUTPUT_TANGENT = `objectTangent = `;
const ARGS = {
  inputPos: { type: "vec3", name: "inputPos" },
  inputNormal: { type: "vec3", name: "inputNormal" },
  skinIndex: { type: "vec4", name: "skinIndex" }
};
function createFunction(options) {
  const skinningStructName = `skinningOut`;
  let withReplaced = TEMPLATE.replace(TO_REPLACE_INPUT_POS, `vec4(${ARGS.inputPos.name}, 1.0)`).replace(TO_REPLACE_INPUT_NORMAL, `vec4(${ARGS.inputNormal.name}, 0.0)`).replace(TO_REPLACE_OUTPUT_POS, `${skinningStructName}.position = `).replace(TO_REPLACE_OUTPUT_NORMAL, `${skinningStructName}.normal = `).replace(TO_REPLACE_OUTPUT_TANGENT, `${skinningStructName}.tangent = `);
  const structDefinition = `struct ${options.structDefinitionName} {
	vec3 position;
	vec3 normal;
	vec3 tangent;
};`;
  const argsInDefinition = Object.values(ARGS).map((arg) => `${arg.type} ${arg.name}`).join(", ");
  const functionDeclaration = `
${structDefinition}
${options.structDefinitionName} ${options.functionName}(${argsInDefinition}){
${options.structDefinitionName} ${skinningStructName};
${withReplaced}
return ${skinningStructName};
}`;
  return { functionDeclaration };
}
var SkinningOutput = /* @__PURE__ */ ((SkinningOutput2) => {
  SkinningOutput2["POSITION"] = "position";
  SkinningOutput2["NORMAL"] = "normal";
  SkinningOutput2["TANGENT"] = "tangent";
  return SkinningOutput2;
})(SkinningOutput || {});
class SkinningGlParamsConfig extends params_ParamsConfig/* NodeParamsConfig */.yI {
  constructor() {
    super(...arguments);
    this.position = params_ParamsConfig/* ParamConfig.VECTOR3 */.XC.VECTOR3([0, 0, 0]);
    this.normal = params_ParamsConfig/* ParamConfig.VECTOR3 */.XC.VECTOR3([0, 1, 0]);
  }
}
const Skinning_ParamsConfig = new SkinningGlParamsConfig();
class SkinningGlNode extends gl_Base/* TypedGlNode */.hD {
  constructor() {
    super(...arguments);
    this.paramsConfig = Skinning_ParamsConfig;
  }
  static type() {
    return "skinning";
  }
  initializeNode() {
    super.initializeNode();
    this.io.outputs.setNamedOutputConnectionPoints([
      new Gl/* GlConnectionPoint */.E("position" /* POSITION */, Gl/* GlConnectionPointType.VEC3 */.Dv.VEC3),
      new Gl/* GlConnectionPoint */.E("normal" /* NORMAL */, Gl/* GlConnectionPointType.VEC3 */.Dv.VEC3),
      new Gl/* GlConnectionPoint */.E("tangent" /* TANGENT */, Gl/* GlConnectionPointType.VEC3 */.Dv.VEC3)
    ]);
  }
  setLines(linesController) {
    if (linesController.currentShaderName() == ShaderName/* ShaderName.VERTEX */.k.VERTEX) {
      const inputPosition = ThreeToGl/* ThreeToGl.vector3 */._.vector3(this.variableForInputParam(this.p.position));
      const inputNormal = ThreeToGl/* ThreeToGl.vector3 */._.vector3(this.variableForInputParam(this.p.normal));
      const outPosition = this.glVarName("position" /* POSITION */);
      const outNormal = this.glVarName("normal" /* NORMAL */);
      const outTangent = this.glVarName("tangent" /* TANGENT */);
      const outValue = this.glVarName("out");
      const functionName = `computeSkinningData_${this.graphNodeId()}`;
      const structDefinitionName = `SkinningData_${this.graphNodeId()}`;
      const { functionDeclaration } = createFunction({ functionName, structDefinitionName });
      const bodyLines = [
        `#ifdef USE_SKINNING`,
        `${structDefinitionName} ${outValue} = ${functionName}(${inputPosition}, ${inputNormal}, ${ARGS.skinIndex.name})`,
        `vec3 ${outPosition} = ${outValue}.position;`,
        `vec3 ${outNormal} = ${outValue}.normal;`,
        `vec3 ${outTangent} = ${outValue}.tangent;`,
        `#else`,
        `vec3 ${outPosition} = ${inputPosition}`,
        `vec3 ${outNormal} = ${inputNormal}`,
        `vec3 ${outTangent} = vec3(0.)`,
        `#endif`
      ];
      const definitionLines = [];
      definitionLines.push(new GLDefinition/* FunctionGLDefinition */.MR(this, functionDeclaration));
      linesController.addBodyLines(this, bodyLines, ShaderName/* ShaderName.VERTEX */.k.VERTEX);
      linesController.addDefinitions(this, definitionLines);
    }
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/gl/SSSModel.ts





const OUTPUT = {
  SSS_MODEL: "SSSModel"
};
class VATDataGlParamsConfig extends params_ParamsConfig/* NodeParamsConfig */.yI {
  constructor() {
    super(...arguments);
    this.color = params_ParamsConfig/* ParamConfig.COLOR */.XC.COLOR([1, 1, 1]);
    this.thickness = params_ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(0.1);
    this.power = params_ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(2);
    this.scale = params_ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(16);
    this.distortion = params_ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(0.1);
    this.ambient = params_ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(0.4);
    this.attenuation = params_ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(0.8);
  }
}
const SSSModel_ParamsConfig = new VATDataGlParamsConfig();
class SSSModelGlNode extends gl_Base/* TypedGlNode */.hD {
  constructor() {
    super(...arguments);
    this.paramsConfig = SSSModel_ParamsConfig;
  }
  static type() {
    return "SSSModel";
  }
  initializeNode() {
    this.io.outputs.setNamedOutputConnectionPoints([
      new Gl/* GlConnectionPoint */.E(OUTPUT.SSS_MODEL, Gl/* GlConnectionPointType.SSS_MODEL */.Dv.SSS_MODEL)
    ]);
  }
  setLines(shaders_collection_controller) {
    const body_lines = [];
    const outSSModel = this.glVarName(OUTPUT.SSS_MODEL);
    body_lines.push(`SSSModel ${outSSModel}`);
    body_lines.push(`${outSSModel}.isActive = true;`);
    body_lines.push(this._paramLineFloat(outSSModel, this.p.color));
    body_lines.push(this._paramLineFloat(outSSModel, this.p.thickness));
    body_lines.push(this._paramLineFloat(outSSModel, this.p.power));
    body_lines.push(this._paramLineFloat(outSSModel, this.p.scale));
    body_lines.push(this._paramLineFloat(outSSModel, this.p.distortion));
    body_lines.push(this._paramLineFloat(outSSModel, this.p.ambient));
    body_lines.push(this._paramLineFloat(outSSModel, this.p.attenuation));
    shaders_collection_controller.addBodyLines(this, body_lines);
  }
  _paramLineFloat(varName, param) {
    return `${varName}.${param.name()} = ${ThreeToGl/* ThreeToGl.vector3 */._.vector3(this.variableForInputParam(param))};`;
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/gl/Sphere.ts







const OUTPUT_NAME_VALUE = "value";
const OUTPUT_NAME_GRADIENT = "gradient";
class SphereGlParamsConfig extends params_ParamsConfig/* NodeParamsConfig */.yI {
  constructor() {
    super(...arguments);
    this.position = params_ParamsConfig/* ParamConfig.VECTOR3 */.XC.VECTOR3([0, 0, 0]);
    this.center = params_ParamsConfig/* ParamConfig.VECTOR3 */.XC.VECTOR3([0, 0, 0]);
    this.radius = params_ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(1);
    this.feather = params_ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(0.1);
  }
}
const Sphere_ParamsConfig = new SphereGlParamsConfig();
class SphereGlNode extends gl_Base/* TypedGlNode */.hD {
  constructor() {
    super(...arguments);
    this.paramsConfig = Sphere_ParamsConfig;
  }
  static type() {
    return "sphere";
  }
  initializeNode() {
    super.initializeNode();
    this.io.outputs.setNamedOutputConnectionPoints([
      new Gl/* GlConnectionPoint */.E(OUTPUT_NAME_VALUE, Gl/* GlConnectionPointType.FLOAT */.Dv.FLOAT),
      new Gl/* GlConnectionPoint */.E(OUTPUT_NAME_GRADIENT, Gl/* GlConnectionPointType.VEC3 */.Dv.VEC3)
    ]);
  }
  setLines(shaders_collection_controller) {
    const position = ThreeToGl/* ThreeToGl.vector2 */._.vector2(this.variableForInputParam(this.p.position));
    const center = ThreeToGl/* ThreeToGl.vector3 */._.vector3(this.variableForInputParam(this.p.center));
    const radius = ThreeToGl/* ThreeToGl.float */._.float(this.variableForInputParam(this.p.radius));
    const feather = ThreeToGl/* ThreeToGl.float */._.float(this.variableForInputParam(this.p.feather));
    const value = this.glVarName(OUTPUT_NAME_VALUE);
    const gradient = this.glVarName(OUTPUT_NAME_GRADIENT);
    const bodyLineValue = `float ${value} = disk3d(${position}, ${center}, ${radius}, ${feather})`;
    const bodyLineGradient = `vec3 ${gradient} = ${value}*(${position}-${center})`;
    shaders_collection_controller.addBodyLines(this, [bodyLineValue, bodyLineGradient]);
    shaders_collection_controller.addDefinitions(this, [new GLDefinition/* FunctionGLDefinition */.MR(this, disk)]);
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/gl/SubnetInput.ts




class SubnetInputGlParamsConfig extends params_ParamsConfig/* NodeParamsConfig */.yI {
}
const SubnetInput_ParamsConfig = new SubnetInputGlParamsConfig();
class SubnetInputGlNode extends gl_Base/* TypedGlNode */.hD {
  constructor() {
    super(...arguments);
    this.paramsConfig = SubnetInput_ParamsConfig;
  }
  static type() {
    return poly_NodeContext/* NetworkChildNodeType.INPUT */.G$.INPUT;
  }
  initializeNode() {
    this.io.connection_points.set_output_name_function(this._expected_output_names.bind(this));
    this.io.connection_points.set_expected_input_types_function(() => []);
    this.io.connection_points.set_expected_output_types_function(this._expected_output_types.bind(this));
  }
  parent() {
    return super.parent();
  }
  _expected_output_names(index) {
    const parent = this.parent();
    return (parent == null ? void 0 : parent.childExpectedInputConnectionPointName(index)) || `out${index}`;
  }
  _expected_output_types() {
    const parent = this.parent();
    return (parent == null ? void 0 : parent.childExpectedInputConnectionPointTypes()) || [];
  }
  // private _connect_to_parent_connections_controller() {
  // 	// this will make the node update its connections when the parent changes them
  // 	if (this.parent) {
  // 		this.addGraphInput(this.parent);
  // 	}
  // }
  setLines(shaders_collection_controller) {
    const parent = this.parent();
    if (!parent) {
      return;
    }
    parent.setSubnetInputLines(shaders_collection_controller, this);
  }
}

// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/nodes/gl/SubnetOutput.ts
var gl_SubnetOutput = __webpack_require__(26614);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/core/math/_Module.ts
var _Module = __webpack_require__(27462);
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/gl/Switch.ts






const MAX_INPUTS_COUNT = 16;
class SwitchParamsConfig extends params_ParamsConfig/* NodeParamsConfig */.yI {
}
const gl_Switch_ParamsConfig = new SwitchParamsConfig();
const _SwitchGlNode = class extends gl_Base/* TypedGlNode */.hD {
  constructor() {
    super(...arguments);
    this.paramsConfig = gl_Switch_ParamsConfig;
  }
  static type() {
    return "switch";
  }
  initializeNode() {
    this.io.connection_points.set_input_name_function(this._gl_input_name.bind(this));
    this.io.connection_points.set_expected_input_types_function(this._expected_input_types.bind(this));
    this.io.connection_points.set_expected_output_types_function(this._expected_output_types.bind(this));
  }
  _gl_input_name(index) {
    if (index == 0) {
      return _SwitchGlNode.INPUT_INDEX;
    } else {
      return `in${index - 1}`;
    }
  }
  _expected_input_types() {
    const secondInputType = this.io.connection_points.input_connection_type(1);
    const type = secondInputType || Gl/* GlConnectionPointType.FLOAT */.Dv.FLOAT;
    const currentConnections = this.io.connections.inputConnections() || [];
    let lastValidConnectionIndex = 1;
    let i = 0;
    for (const connection of currentConnections) {
      if (connection) {
        lastValidConnectionIndex = i;
      }
      i++;
    }
    const expected_count = _Module/* CoreMath.clamp */.Gj.clamp(lastValidConnectionIndex + 1, 2, MAX_INPUTS_COUNT);
    const expected_input_types = [Gl/* GlConnectionPointType.INT */.Dv.INT];
    for (let i2 = 0; i2 < expected_count; i2++) {
      expected_input_types.push(type);
    }
    return expected_input_types;
  }
  _expected_output_types() {
    const input_types = this._expected_input_types();
    const type = input_types[1] || Gl/* GlConnectionPointType.FLOAT */.Dv.FLOAT;
    return [type];
  }
  setLines(shaders_collection_controller) {
    const namedOutputConnectionPoints = this.io.outputs.namedOutputConnectionPoints();
    if (!namedOutputConnectionPoints) {
      return;
    }
    const var_type = namedOutputConnectionPoints[0].type();
    const out = this.glVarName(this.io.connection_points.output_name(0));
    const index_point_name = this.io.connection_points.input_name(0);
    const arg_index = ThreeToGl/* ThreeToGl.integer */._.integer(this.variableForInput(index_point_name));
    const switch_index_var_name = this.glVarName("index");
    const body_lines = [`${var_type} ${out};`, `int ${switch_index_var_name} = ${arg_index}`];
    const lines_count = this._expected_input_types().length - 1;
    for (let i = 0; i < lines_count; i++) {
      const if_else = i == 0 ? "if" : "else if";
      const condition = `${switch_index_var_name} == ${i}`;
      const connection_point_name = this.io.connection_points.input_name(i + 1);
      const assignment = `${out} = ${ThreeToGl/* ThreeToGl.any */._.any(this.variableForInput(connection_point_name))};`;
      const body_line = `${if_else}(${condition}){${assignment}}`;
      body_lines.push(body_line);
    }
    shaders_collection_controller.addBodyLines(this, body_lines);
  }
};
let SwitchGlNode = _SwitchGlNode;
SwitchGlNode.INPUT_INDEX = "index";

// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/nodes/gl/Texture.ts + 1 modules
var Texture = __webpack_require__(61745);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/nodes/gl/Texture2DArray.ts
var Texture2DArray = __webpack_require__(41027);
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/gl/gl/textureDisplacement_4pts.glsl
/* harmony default export */ var textureDisplacement_4pts = ("float textureDisplacementDisplace__COMPONENT__(sampler2D displacementMap, float amount, vec2 vUv) {\n\treturn texture2D(displacementMap, vUv).__COMPONENT__ * amount;\n}\n\nTextureDisplacementResult textureDisplacement__COMPONENT__(\n\tsampler2D displacementMap,\n\tvec2 vUv,\n\tvec2 textureSize,\n\tfloat amount,\n\tvec3 position,\n\tvec3 normal,\n\tvec2 tangentsPosOffset\n\t){\n\n\tTextureDisplacementResult result;\n\n\tresult.position = position + normal * textureDisplacementDisplace__COMPONENT__( displacementMap, amount, vUv );\n\n\tvec3 tangent = vec3(0.0, 0.0, 1.0);\n\tvec3 bitangent = vec3(1.0, 0.0, 0.0);\n\tvec2 texelSize = vec2( 1.0 / textureSize.x, 1.0 / textureSize.y );\n\n\t// tangent\n\tvec3 PosT0 = position + tangent * tangentsPosOffset.y;\n\tvec3 PosT1 = position - tangent * tangentsPosOffset.y;\n\tvec2 uvT0 = vUv + vec2(0.0, -texelSize.y);\n\tvec2 uvT1 = vUv + vec2(0.0, +texelSize.y);\n\n\t// bittangent\n\tvec3 PosBT0 = position + bitangent * tangentsPosOffset.x;\n\tvec3 PosBT1 = position - bitangent * tangentsPosOffset.x;\n\tvec2 uvBT0 = vUv + vec2(+texelSize.x, 0.0);\n\tvec2 uvBT1 = vUv + vec2(-texelSize.x, 0.0);\n\n\t// disp\n\tvec3 dispT0 = PosT0 + normal * textureDisplacementDisplace__COMPONENT__( displacementMap, amount, uvT0 );\n\tvec3 dispT1 = PosT1 + normal * textureDisplacementDisplace__COMPONENT__( displacementMap, amount, uvT1 );\n\tvec3 dispBT0 = PosBT0 + normal * textureDisplacementDisplace__COMPONENT__( displacementMap, amount, uvBT0 );\n\tvec3 dispBT1 = PosBT1 + normal * textureDisplacementDisplace__COMPONENT__( displacementMap, amount, uvBT1 );\n\n\tvec3 dispT = normalize(dispT0 - dispT1);\n\tvec3 dispBT = normalize(dispBT0 - dispBT1);\n\tresult.normal = normalize(cross(dispT, dispBT));\n\n\treturn result;\n\n}");
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/gl/gl/textureDisplacement_8pts.glsl
/* harmony default export */ var textureDisplacement_8pts = ("float textureDisplacementDisplace__COMPONENT__(sampler2D displacementMap, float amount, vec2 vUv) {\n\treturn texture2D(displacementMap, vUv).__COMPONENT__ * amount;\n}\n\nTextureDisplacementResult textureDisplacement__COMPONENT__(\n\tsampler2D displacementMap,\n\tvec2 vUv,\n\tvec2 textureSize,\n\tfloat amount,\n\tvec3 position,\n\tvec3 normal,\n\tvec2 tangentsPosOffset\n\t){\n\n\tTextureDisplacementResult result;\n\tfloat diagonal = 1.0;//0.707;\n\n\tvec2 uvLookup = vec2( vUv.x, vUv.y );\n\tvec3 currentP = position + normal * textureDisplacementDisplace__COMPONENT__( displacementMap, amount, vUv );\n\n\tvec2 texelSize = vec2( 1.0 / textureSize.x, - 1.0 / textureSize.y );\n\n\tvec2 posOffset = vec2(tangentsPosOffset.x, tangentsPosOffset.y);\n\n\tvec3 offset0 = position + vec3( 0.0, \t\t\t\t\t\t0.0, \tposOffset.y);\n\tvec3 offset1 = position + vec3( diagonal * posOffset.x, \t0.0, \tdiagonal * posOffset.y);\n\tvec3 offset2 = position + vec3( posOffset.x, \t\t\t\t0.0, \t0.0);\n\tvec3 offset3 = position + vec3( diagonal * posOffset.x, \t0.0, \t- diagonal * posOffset.y);\n\tvec3 offset4 = position + vec3( 0.0, \t\t\t\t\t\t0.0, \t- posOffset.y);\n\tvec3 offset5 = position + vec3( - diagonal * posOffset.x, \t0.0, \t- diagonal * posOffset.y);\n\tvec3 offset6 = position + vec3( - posOffset.x, \t\t\t\t0.0, \t0.0);\n\tvec3 offset7 = position + vec3( - diagonal * posOffset.x, \t0.0, \tdiagonal * posOffset.y);\n\n\tvec2 uv0 = vec2( 0.0, \t\t\t\t\t\ttexelSize.y);\n\tvec2 uv1 = vec2( diagonal * texelSize.x, \tdiagonal * texelSize.y);\n\tvec2 uv2 = vec2( texelSize.x, \t\t\t\t0.0);\n\tvec2 uv3 = vec2( diagonal * texelSize.x, \t- diagonal * texelSize.y);\n\tvec2 uv4 = vec2( 0.0, \t\t\t\t\t\t- texelSize.y);\n\tvec2 uv5 = vec2( - diagonal * texelSize.x, \t- diagonal * texelSize.y);\n\tvec2 uv6 = vec2( - texelSize.x, \t\t\t\t0.0);\n\tvec2 uv7 = vec2( - diagonal * texelSize.x, \tdiagonal * texelSize.y);\n\n\tvec3 p0 = offset0 + normal * textureDisplacementDisplace__COMPONENT__( displacementMap, amount, uvLookup + uv0 );\n\tvec3 p1 = offset1 + normal * textureDisplacementDisplace__COMPONENT__( displacementMap, amount, uvLookup + uv1 );\n\tvec3 p2 = offset2 + normal * textureDisplacementDisplace__COMPONENT__( displacementMap, amount, uvLookup + uv2 );\n\tvec3 p3 = offset3 + normal * textureDisplacementDisplace__COMPONENT__( displacementMap, amount, uvLookup + uv3 );\n\tvec3 p4 = offset4 + normal * textureDisplacementDisplace__COMPONENT__( displacementMap, amount, uvLookup + uv4 );\n\tvec3 p5 = offset5 + normal * textureDisplacementDisplace__COMPONENT__( displacementMap, amount, uvLookup + uv5 );\n\tvec3 p6 = offset6 + normal * textureDisplacementDisplace__COMPONENT__( displacementMap, amount, uvLookup + uv6 );\n\tvec3 p7 = offset7 + normal * textureDisplacementDisplace__COMPONENT__( displacementMap, amount, uvLookup + uv7 );\n\n\tvec3 d0 = (p0 - currentP);\n\tvec3 d1 = (p1 - currentP);\n\tvec3 d2 = (p2 - currentP);\n\tvec3 d3 = (p3 - currentP);\n\tvec3 d4 = (p4 - currentP);\n\tvec3 d5 = (p5 - currentP);\n\tvec3 d6 = (p6 - currentP);\n\tvec3 d7 = (p7 - currentP);\n\n\tvec3 computedNormal = vec3(0.);\n\t// computedNormal += cross(d0, d1);\n\t// computedNormal += cross(d1, d2);\n\t// computedNormal += cross(d2, d3);\n\t// computedNormal += cross(d3, d4);\n\t// computedNormal += cross(d4, d5);\n\t// computedNormal += cross(d5, d6);\n\t// computedNormal += cross(d6, d7);\n\t// computedNormal += cross(d7, d0);\n\tbool a = 1.0 > 0.5;\n\tif(a){\n\t\tcomputedNormal += cross(d0, d2);\n\t\tcomputedNormal += cross(d2, d3);\n\t\tcomputedNormal += cross(d3, d4);\n\t\tcomputedNormal += cross(d4, d6);\n\t\tcomputedNormal += cross(d6, d7);\n\t\tcomputedNormal += cross(d7, d0);\n\t}else{\n\t\tcomputedNormal += cross(d0, d1);\n\t\tcomputedNormal += cross(d1, d2);\n\t\tcomputedNormal += cross(d2, d4);\n\t\tcomputedNormal += cross(d4, d5);\n\t\tcomputedNormal += cross(d5, d6);\n\t\tcomputedNormal += cross(d6, d0);\n\t}\n\tresult.normal = normalize(computedNormal);\n\tresult.position = currentP;\n\n\treturn result;\n\n}");
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/gl/gl/textureDisplacementResult.glsl
/* harmony default export */ var textureDisplacementResult = ("struct TextureDisplacementResult {\n\tvec3 position;\n\tvec3 normal;\n};");
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/gl/TextureDisplacement.ts














var DisplacementTextureOutput = /* @__PURE__ */ ((DisplacementTextureOutput2) => {
  DisplacementTextureOutput2["P"] = "P";
  DisplacementTextureOutput2["N"] = "N";
  return DisplacementTextureOutput2;
})(DisplacementTextureOutput || {});
const COMPONENTS = ["x", "y", "z", "w"];
class TextureDisplacementGlParamsConfig extends params_ParamsConfig/* NodeParamsConfig */.yI {
  constructor() {
    super(...arguments);
    this.paramName = params_ParamsConfig/* ParamConfig.STRING */.XC.STRING("");
    this.computeAllNeighbours = params_ParamsConfig/* ParamConfig.BOOLEAN */.XC.BOOLEAN(0);
    this.position = params_ParamsConfig/* ParamConfig.VECTOR3 */.XC.VECTOR3([0, 0, 0]);
    this.normal = params_ParamsConfig/* ParamConfig.VECTOR3 */.XC.VECTOR3([0, 0, 0]);
    this.uv = params_ParamsConfig/* ParamConfig.VECTOR2 */.XC.VECTOR2([0, 0]);
    this.amount = params_ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(1, {
      range: [-1, 1],
      rangeLocked: [false, false]
    });
    this.textureSize = params_ParamsConfig/* ParamConfig.VECTOR2 */.XC.VECTOR2([512, 512]);
    this.tangentsPosOffset = params_ParamsConfig/* ParamConfig.VECTOR2 */.XC.VECTOR2([0.01, 0.01]);
    this.textureComponent = params_ParamsConfig/* ParamConfig.INTEGER */.XC.INTEGER(0, {
      range: [0, 3],
      rangeLocked: [true, true]
    });
  }
}
const TextureDisplacement_ParamsConfig = new TextureDisplacementGlParamsConfig();
class TextureDisplacementGlNode extends gl_Base/* TypedGlNode */.hD {
  constructor() {
    super(...arguments);
    this.paramsConfig = TextureDisplacement_ParamsConfig;
  }
  static type() {
    return types_Gl/* GlType.TEXTURE_DISPLACEMENT */.P.TEXTURE_DISPLACEMENT;
  }
  initializeNode() {
    this.addPostDirtyHook("_setMatToRecompile", this._setMatToRecompile.bind(this));
    this.lifecycle.onAfterAdded(this._setMatToRecompile.bind(this));
    this.lifecycle.onBeforeDeleted(this._setMatToRecompile.bind(this));
    this.io.outputs.setNamedOutputConnectionPoints([
      new Gl/* GlConnectionPoint */.E("P" /* P */, Gl/* GlConnectionPointType.VEC3 */.Dv.VEC3),
      new Gl/* GlConnectionPoint */.E("N" /* N */, Gl/* GlConnectionPointType.VEC3 */.Dv.VEC3)
    ]);
    this.io.connection_points.spare_params.setInputlessParamNames(["computeAllNeighbours", "textureComponent"]);
  }
  setLines(linesController) {
    const map = this.uniformName();
    const uv = ThreeToGl/* ThreeToGl.vector2 */._.vector2(this.variableForInputParam(this.p.uv));
    const textureSize = ThreeToGl/* ThreeToGl.vector2 */._.vector2(this.variableForInputParam(this.p.textureSize));
    const amount = ThreeToGl/* ThreeToGl.float */._.float(this.variableForInputParam(this.p.amount));
    const position = ThreeToGl/* ThreeToGl.vector3 */._.vector3(this.variableForInputParam(this.p.position));
    const normal = ThreeToGl/* ThreeToGl.vector3 */._.vector3(this.variableForInputParam(this.p.normal));
    const tangentsPosOffset = ThreeToGl/* ThreeToGl.vector3 */._.vector3(this.variableForInputParam(this.p.tangentsPosOffset));
    const component = COMPONENTS[this.pv.textureComponent];
    const template = this.pv.computeAllNeighbours ? textureDisplacement_8pts : textureDisplacement_4pts;
    const textureDisplacementFunctionDeclaration = template.replace(/__COMPONENT__/g, component);
    const textureDisplacementFunctionName = `textureDisplacement__COMPONENT__`.replace(/__COMPONENT__/g, component);
    const out = this.glVarName("out");
    const outPosition = this.glVarName("P" /* P */);
    const outNormal = this.glVarName("N" /* N */);
    const definitions = [
      new GLDefinition/* UniformGLDefinition */.oA(this, Gl/* GlConnectionPointType.SAMPLER_2D */.Dv.SAMPLER_2D, map),
      new GLDefinition/* FunctionGLDefinition */.MR(this, textureDisplacementResult),
      new GLDefinition/* FunctionGLDefinition */.MR(this, textureDisplacementFunctionDeclaration)
    ];
    const args = [map, uv, textureSize, amount, position, normal, tangentsPosOffset];
    const functionCall = `${textureDisplacementFunctionName}(${args.join(", ")})`;
    const bodyLines = [
      `TextureDisplacementResult ${out} = ${functionCall}`,
      `vec3 ${outPosition} = ${out}.position`,
      `vec3 ${outNormal} = ${out}.normal`
    ];
    linesController.addDefinitions(this, definitions);
    linesController.addBodyLines(this, bodyLines);
  }
  paramsGenerating() {
    return true;
  }
  setParamConfigs() {
    this._param_configs_controller = this._param_configs_controller || new ParamConfigsController/* ParamConfigsController */.e();
    this._param_configs_controller.reset();
    const param_config = new GLParamConfig/* GlParamConfig */.b(
      ParamType/* ParamType.NODE_PATH */._.NODE_PATH,
      this.pv.paramName,
      "",
      //this.pv.defaultValue,
      this.uniformName()
    );
    this._param_configs_controller.push(param_config);
  }
  uniformName() {
    return `${uniform/* UNIFORM_TEXTURE_PREFIX */.f}${this.pv.paramName}`;
  }
}

// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/nodes/gl/TextureSDF.ts
var TextureSDF = __webpack_require__(22404);
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/gl/gl/tileUv.glsl
/* harmony default export */ var tileUv = ("\nvec2 tileUv(vec2 uv, float tile, vec2 tilesCount){\n\tuv /= tilesCount;\n\n\tfloat row = floor(tile / tilesCount.x);\n\tfloat column = mod(tile, tilesCount.x);\n\tuv.x += column / tilesCount.x;\n\tuv.y += row / tilesCount.y;\n\n\treturn uv;\n}\n");
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/gl/TileUv.ts







const TileUv_OUTPUT_NAME = "uv";
class TileUvGlParamsConfig extends params_ParamsConfig/* NodeParamsConfig */.yI {
  constructor() {
    super(...arguments);
    this.uv = params_ParamsConfig/* ParamConfig.VECTOR2 */.XC.VECTOR2([0, 0]);
    this.tile = params_ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(0, {
      range: [0, 64],
      rangeLocked: [true, false]
    });
    this.tilesCount = params_ParamsConfig/* ParamConfig.VECTOR2 */.XC.VECTOR2([8, 8]);
  }
}
const TileUv_ParamsConfig = new TileUvGlParamsConfig();
class TileUvGlNode extends gl_Base/* TypedGlNode */.hD {
  constructor() {
    super(...arguments);
    this.paramsConfig = TileUv_ParamsConfig;
  }
  static type() {
    return "tileUv";
  }
  initializeNode() {
    super.initializeNode();
    this.io.outputs.setNamedOutputConnectionPoints([
      new Gl/* GlConnectionPoint */.E(TileUv_OUTPUT_NAME, Gl/* GlConnectionPointType.VEC2 */.Dv.VEC2)
    ]);
  }
  setLines(shaders_collection_controller) {
    const body_lines = [];
    shaders_collection_controller.addDefinitions(this, [new GLDefinition/* FunctionGLDefinition */.MR(this, tileUv)]);
    const uv = ThreeToGl/* ThreeToGl.vector2 */._.vector2(this.variableForInputParam(this.p.uv));
    const tile = ThreeToGl/* ThreeToGl.float */._.float(this.variableForInputParam(this.p.tile));
    const tilesCount = ThreeToGl/* ThreeToGl.vector2 */._.vector2(this.variableForInputParam(this.p.tilesCount));
    const out = this.glVarName(TileUv_OUTPUT_NAME);
    const args = [uv, tile, tilesCount].join(", ");
    body_lines.push(`vec2 ${out} = tileUv(${args})`);
    shaders_collection_controller.addBodyLines(this, body_lines);
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/gl/ToWorldSpace.ts





var Interpretation = /* @__PURE__ */ ((Interpretation2) => {
  Interpretation2["POSITION"] = "position";
  Interpretation2["DIR_VEC"] = "direction vector";
  return Interpretation2;
})(Interpretation || {});
const INTERPRETATIONS = ["position" /* POSITION */, "direction vector" /* DIR_VEC */];
const ToWorldSpace_OUTPUT_NAME = "out";
class ToWorldSpaceGlParamsConfig extends params_ParamsConfig/* NodeParamsConfig */.yI {
  constructor() {
    super(...arguments);
    this.vec = params_ParamsConfig/* ParamConfig.VECTOR3 */.XC.VECTOR3([0, 0, 0]);
    this.interpretation = params_ParamsConfig/* ParamConfig.INTEGER */.XC.INTEGER(0, {
      menu: {
        entries: INTERPRETATIONS.map((name, value) => {
          return { name, value };
        })
      }
    });
  }
}
const ToWorldSpace_ParamsConfig = new ToWorldSpaceGlParamsConfig();
class ToWorldSpaceGlNode extends gl_Base/* TypedGlNode */.hD {
  constructor() {
    super(...arguments);
    this.paramsConfig = ToWorldSpace_ParamsConfig;
  }
  static type() {
    return "toWorldSpace";
  }
  initializeNode() {
    this.io.connection_points.spare_params.setInputlessParamNames(["interpretation"]);
    this.io.outputs.setNamedOutputConnectionPoints([
      new Gl/* GlConnectionPoint */.E(ToWorldSpace_OUTPUT_NAME, Gl/* GlConnectionPointType.VEC3 */.Dv.VEC3)
    ]);
  }
  setLines(shaders_collection_controller) {
    const body_lines = [];
    const vec = ThreeToGl/* ThreeToGl.vector3 */._.vector3(this.variableForInputParam(this.p.vec));
    const out = this.glVarName(ToWorldSpace_OUTPUT_NAME);
    const interpretation = INTERPRETATIONS[this.pv.interpretation];
    switch (interpretation) {
      case "position" /* POSITION */: {
        body_lines.push(`vec3 ${out} = (modelMatrix * vec4( ${vec}, 1.0 )).xyz`);
        break;
      }
      case "direction vector" /* DIR_VEC */: {
        body_lines.push(
          `vec3 ${out} = normalize( mat3( modelMatrix[0].xyz, modelMatrix[1].xyz, modelMatrix[2].xyz ) * ${vec} )`
        );
        break;
      }
    }
    shaders_collection_controller.addBodyLines(this, body_lines);
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/gl/TwoWaySwitch.ts



const TwoWaySwitch_OUTPUT_NAME = "val";
var TwoWaySwitchGlNodeInputName = /* @__PURE__ */ ((TwoWaySwitchGlNodeInputName2) => {
  TwoWaySwitchGlNodeInputName2["CONDITION"] = "condition";
  TwoWaySwitchGlNodeInputName2["IF_TRUE"] = "ifTrue";
  TwoWaySwitchGlNodeInputName2["IF_FALSE"] = "ifFalse";
  return TwoWaySwitchGlNodeInputName2;
})(TwoWaySwitchGlNodeInputName || {});
const TwoWaySwitch_InputNames = [
  "condition" /* CONDITION */,
  "ifTrue" /* IF_TRUE */,
  "ifFalse" /* IF_FALSE */
];

class TwoWaySwitchGlNode extends gl_Base/* ParamlessTypedGlNode */.N2 {
  static type() {
    return "twoWaySwitch";
  }
  // public readonly gl_connections_controller: GlConnectionsController = new GlConnectionsController(this);
  initializeNode() {
    super.initializeNode();
    this.io.connection_points.initializeNode();
    this.io.connection_points.set_expected_input_types_function(this._expected_input_types.bind(this));
    this.io.connection_points.set_expected_output_types_function(this._expected_output_types.bind(this));
    this.io.connection_points.set_input_name_function(this._gl_input_name.bind(this));
    this.io.connection_points.set_output_name_function(this._gl_output_name.bind(this));
  }
  _gl_input_name(index) {
    return TwoWaySwitch_InputNames[index];
  }
  _gl_output_name() {
    return TwoWaySwitch_OUTPUT_NAME;
  }
  _expected_input_types() {
    const second_or_third_connection = this.io.connections.inputConnection(1) || this.io.connections.inputConnection(2);
    const srcConnectionPoint = second_or_third_connection == null ? void 0 : second_or_third_connection.srcConnectionPoint();
    const type = (srcConnectionPoint == null ? void 0 : srcConnectionPoint.type()) || Gl/* GlConnectionPointType.FLOAT */.Dv.FLOAT;
    return [Gl/* GlConnectionPointType.BOOL */.Dv.BOOL, type, type];
  }
  _expected_output_types() {
    const type = this._expected_input_types()[1];
    return [type];
  }
  setLines(shaders_collection_controller) {
    const value = this.glVarName(TwoWaySwitch_OUTPUT_NAME);
    const condition = ThreeToGl/* ThreeToGl.bool */._.bool(this.variableForInput("condition" /* CONDITION */));
    const ifTrue = ThreeToGl/* ThreeToGl.any */._.any(this.variableForInput("ifTrue" /* IF_TRUE */));
    const ifFalse = ThreeToGl/* ThreeToGl.any */._.any(this.variableForInput("ifFalse" /* IF_FALSE */));
    const glType = this._expected_output_types()[0];
    const bodyLines = [];
    bodyLines.push(`${glType} ${value}`);
    bodyLines.push(`if(${condition}){`);
    bodyLines.push(`${value} = ${ifTrue}`);
    bodyLines.push(`} else {`);
    bodyLines.push(`${value} = ${ifFalse}`);
    bodyLines.push(`}`);
    shaders_collection_controller.addBodyLines(this, bodyLines);
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/gl/UvToOklab.ts







const UvToOklab_OUTPUT_NAME = "oklab";
class UvToOklabGlParamsConfig extends params_ParamsConfig/* NodeParamsConfig */.yI {
  constructor() {
    super(...arguments);
    this.uvw = params_ParamsConfig/* ParamConfig.VECTOR3 */.XC.VECTOR3([1, 1, 1]);
  }
}
const UvToOklab_ParamsConfig = new UvToOklabGlParamsConfig();
class UvToOklabGlNode extends gl_Base/* TypedGlNode */.hD {
  constructor() {
    super(...arguments);
    this.paramsConfig = UvToOklab_ParamsConfig;
  }
  static type() {
    return "uvToOklab";
  }
  initializeNode() {
    this.io.outputs.setNamedOutputConnectionPoints([
      new Gl/* GlConnectionPoint */.E(UvToOklab_OUTPUT_NAME, Gl/* GlConnectionPointType.VEC3 */.Dv.VEC3)
    ]);
  }
  setLines(shaders_collection_controller) {
    const function_declaration_lines = [];
    const body_lines = [];
    function_declaration_lines.push(new GLDefinition/* FunctionGLDefinition */.MR(this, oklab));
    const uvw = ThreeToGl/* ThreeToGl.vector3 */._.vector3(this.variableForInputParam(this.p.uvw));
    const oklabOut = this.glVarName(UvToOklab_OUTPUT_NAME);
    body_lines.push(`vec3 ${oklabOut} = uvToOklab(${uvw})`);
    shaders_collection_controller.addDefinitions(this, function_declaration_lines);
    shaders_collection_controller.addBodyLines(this, body_lines);
  }
}

// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/nodes/gl/VaryingWrite.ts
var VaryingWrite = __webpack_require__(65670);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/nodes/gl/VaryingRead.ts
var VaryingRead = __webpack_require__(75910);
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/gl/VectorAlign.ts




const VectorAlign_DefaultValues = {
  start: [0, 0, 1],
  end: [1, 0, 0],
  up: [0, 1, 0]
};
class VectorAlignGlNode extends MathFunctionArg3Factory("vectorAlign", {
  in: ["start", "end", "up"],
  method: "vectorAlignWithUp",
  functions: [quaternion/* default */.Z]
}) {
  _expected_input_types() {
    const type = Gl/* GlConnectionPointType.VEC3 */.Dv.VEC3;
    return [type, type, type];
  }
  _expected_output_types() {
    return [Gl/* GlConnectionPointType.VEC4 */.Dv.VEC4];
  }
  paramDefaultValue(name) {
    return VectorAlign_DefaultValues[name];
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/gl/VectorAngle.ts




const VectorAngle_DefaultValues = {
  start: [0, 0, 1],
  end: [1, 0, 0]
};
class VectorAngleGlNode extends MathFunctionArg2Factory("vectorAngle", {
  in: ["start", "end"],
  method: "vectorAngle",
  functions: [quaternion/* default */.Z]
}) {
  _expected_input_types() {
    const type = Gl/* GlConnectionPointType.VEC3 */.Dv.VEC3;
    return [type, type];
  }
  _expected_output_types() {
    return [Gl/* GlConnectionPointType.FLOAT */.Dv.FLOAT];
  }
  paramDefaultValue(name) {
    return VectorAngle_DefaultValues[name];
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/gl/gl/vertexAnimationTexture.glsl
/* harmony default export */ var vertexAnimationTexture = ("struct VATDataInfoBasic {\n\tfloat frame;\n\tfloat framesCount;\n\tvec2 paddedRatio;\n\tvec2 uv;\n};\n\nstruct BoundingBox {\n\tfloat min;\n\tfloat max;\n};\nstruct VATDataInfoInterpolated {\n\tfloat speed;\n\tBoundingBox Pbound;\n\tvec3 Poffset;\n\tVATDataInfoBasic infoBasic;\n};\nstruct VATDataResult {\n\tvec3 P;\n\tvec3 N;\n};\n\nvec3 FitInBoundingBox(vec3 pos, BoundingBox box){\n\tfloat delta = box.max - box.min;\n\tpos *= delta;\n\tpos += box.min;\n\treturn pos;\n}\n\nvec2 VATDataUv(VATDataInfoBasic info){\n\t// mod(<value>, 1.0) is required for iphone,\n\t// as texture will not wrap otherwise, even with wrapS and wrapT = THREE.RepeatWrapping\n\tfloat x = mod((info.paddedRatio.x * info.uv.x), 1.0);\n\tfloat y0 = 1.0 - info.paddedRatio.y * (1.0 - info.uv.y);\n\tfloat y1 = 1.0 - info.paddedRatio.y * (info.frame / info.framesCount);\n\tfloat y = mod((y0+y1), 1.0);\n\treturn vec2(x, y);\n}\n\nvec3 VATDataP(vec2 uv, sampler2D mapP, sampler2D mapP2){\n\tvec3 P = texture2D(mapP, uv).xyz;\n\tvec3 P2 = texture2D(mapP2, uv).xyz * 0.01;\n\treturn P + P2;\n}\nvec3 VATDataN(vec2 uv, sampler2D mapN){\n\tvec3 N = (texture2D(mapN, uv).xyz * 2.0) - 1.0;\n\treturn normalize(N);\n}\n\n\nVATDataResult VATData(VATDataInfoBasic info, sampler2D mapP, sampler2D mapP2, sampler2D mapN){\n\tvec2 uvTmp = VATDataUv(info);\n\tvec3 P = VATDataP(uvTmp, mapP, mapP2);\n\tvec3 N = VATDataN(uvTmp, mapN);\n\treturn VATDataResult(P,N);\n}\nVATDataResult VATDataInterpolated(VATDataInfoInterpolated info, sampler2D mapP, sampler2D mapP2, sampler2D mapN){\n\tfloat frameWithSpeed = info.speed * float(info.infoBasic.frame);\n\tfloat previousFrame = floor(frameWithSpeed);\n\tfloat nextFrame = ceil(frameWithSpeed);\n\n\tVATDataInfoBasic infoPreviousFrame = VATDataInfoBasic(\n\t\tpreviousFrame,\n\t\tinfo.infoBasic.framesCount,\n\t\tinfo.infoBasic.paddedRatio,\n\t\tinfo.infoBasic.uv\n\t);\n\tVATDataInfoBasic infoNextFrame = VATDataInfoBasic(\n\t\tnextFrame,\n\t\tinfo.infoBasic.framesCount,\n\t\tinfo.infoBasic.paddedRatio,\n\t\tinfo.infoBasic.uv\n\t);\n\tVATDataResult resultPreviousFrame = VATData(infoPreviousFrame, mapP, mapP2, mapN);\n\tVATDataResult resultNextFrame = VATData(infoNextFrame, mapP, mapP2, mapN);\n\n\tfloat blend = 1.0 - ( nextFrame - frameWithSpeed );\n\n\tvec3 P = mix(resultPreviousFrame.P, resultNextFrame.P, blend);\n\tP = FitInBoundingBox(P, info.Pbound) + info.Poffset;\n\n\tvec3 N = mix(resultPreviousFrame.N, resultNextFrame.N, blend);\n\n\treturn VATDataResult(P,N);\n}");
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/gl/VertexAnimationTexture.ts











const VertexAnimationTexture_OUTPUT = {
  P: "position",
  N: "normal"
};
class VertexAnimationTextureGlParamsConfig extends params_ParamsConfig/* NodeParamsConfig */.yI {
  constructor() {
    super(...arguments);
    this.frame = params_ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(0);
    this.framesCount = params_ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(100);
    this.uv = params_ParamsConfig/* ParamConfig.VECTOR2 */.XC.VECTOR2([0, 0]);
    this.paddedRatio = params_ParamsConfig/* ParamConfig.VECTOR2 */.XC.VECTOR2([1, 1]);
    this.textureP = params_ParamsConfig/* ParamConfig.STRING */.XC.STRING("textureP");
    this.textureP2 = params_ParamsConfig/* ParamConfig.STRING */.XC.STRING("textureP2");
    this.textureN = params_ParamsConfig/* ParamConfig.STRING */.XC.STRING("textureN");
  }
}
const VertexAnimationTexture_ParamsConfig = new VertexAnimationTextureGlParamsConfig();
class VertexAnimationTextureGlNode extends gl_Base/* TypedGlNode */.hD {
  constructor() {
    super(...arguments);
    this.paramsConfig = VertexAnimationTexture_ParamsConfig;
  }
  static type() {
    return types_Gl/* GlType.VERTEX_ANIMATION_TEXTURE */.P.VERTEX_ANIMATION_TEXTURE;
  }
  initializeNode() {
    this.io.outputs.setNamedOutputConnectionPoints([
      new Gl/* GlConnectionPoint */.E(VertexAnimationTexture_OUTPUT.P, Gl/* GlConnectionPointType.VEC3 */.Dv.VEC3),
      new Gl/* GlConnectionPoint */.E(VertexAnimationTexture_OUTPUT.N, Gl/* GlConnectionPointType.VEC3 */.Dv.VEC3)
    ]);
  }
  setLines(shadersCollectionController) {
    const functionDeclarationLines = [];
    const bodyLines = [];
    functionDeclarationLines.push(new GLDefinition/* FunctionGLDefinition */.MR(this, vertexAnimationTexture));
    const frame = ThreeToGl/* ThreeToGl.float */._.float(this.variableForInputParam(this.p.frame));
    const framesCount = ThreeToGl/* ThreeToGl.float */._.float(this.variableForInputParam(this.p.framesCount));
    const uv = ThreeToGl/* ThreeToGl.vector2 */._.vector2(this.variableForInputParam(this.p.uv));
    const paddedRatio = ThreeToGl/* ThreeToGl.vector2 */._.vector2(this.variableForInputParam(this.p.paddedRatio));
    const mapP = this._uniformName(this.pv.textureP);
    const mapP2 = this._uniformName(this.pv.textureP2);
    const mapN = this._uniformName(this.pv.textureN);
    const VATInfo = this.glVarName("VATInfo");
    const VATDataResult = this.glVarName("VATDataResultTmp");
    const outP = this.glVarName(VertexAnimationTexture_OUTPUT.P);
    const outN = this.glVarName(VertexAnimationTexture_OUTPUT.N);
    bodyLines.push(
      `VATDataInfoBasic ${VATInfo} = VATDataInfoBasic(${frame}, ${framesCount}, ${paddedRatio}, ${uv});`
    );
    bodyLines.push(`VATDataResult ${VATDataResult} = VATData(${VATInfo}, ${mapP}, ${mapP2}, ${mapN})`);
    bodyLines.push(`vec3 ${outP} = ${VATDataResult}.P;`);
    bodyLines.push(`vec3 ${outN} = ${VATDataResult}.N;`);
    shadersCollectionController.addDefinitions(this, functionDeclarationLines);
    shadersCollectionController.addBodyLines(this, bodyLines);
    const definitionP = new GLDefinition/* UniformGLDefinition */.oA(
      this,
      Gl/* GlConnectionPointType.SAMPLER_2D */.Dv.SAMPLER_2D,
      this._uniformName(this.pv.textureP)
    );
    const definitionP2 = new GLDefinition/* UniformGLDefinition */.oA(
      this,
      Gl/* GlConnectionPointType.SAMPLER_2D */.Dv.SAMPLER_2D,
      this._uniformName(this.pv.textureP2)
    );
    const definitionN = new GLDefinition/* UniformGLDefinition */.oA(
      this,
      Gl/* GlConnectionPointType.SAMPLER_2D */.Dv.SAMPLER_2D,
      this._uniformName(this.pv.textureN)
    );
    shadersCollectionController.addDefinitions(this, [definitionP, definitionP2, definitionN]);
  }
  paramsGenerating() {
    return true;
  }
  setParamConfigs() {
    this._param_configs_controller = this._param_configs_controller || new ParamConfigsController/* ParamConfigsController */.e();
    this._param_configs_controller.reset();
    const paramConfigP = new GLParamConfig/* GlParamConfig */.b(
      ParamType/* ParamType.NODE_PATH */._.NODE_PATH,
      this.pv.textureP,
      "",
      this._uniformName(this.pv.textureP)
    );
    const paramConfigP2 = new GLParamConfig/* GlParamConfig */.b(
      ParamType/* ParamType.NODE_PATH */._.NODE_PATH,
      this.pv.textureP2,
      "",
      this._uniformName(this.pv.textureP2)
    );
    const paramConfigN = new GLParamConfig/* GlParamConfig */.b(
      ParamType/* ParamType.NODE_PATH */._.NODE_PATH,
      this.pv.textureN,
      "",
      this._uniformName(this.pv.textureN)
    );
    this._param_configs_controller.push(paramConfigP);
    this._param_configs_controller.push(paramConfigP2);
    this._param_configs_controller.push(paramConfigN);
  }
  _uniformName(name) {
    return this.glVarName(name);
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/gl/gl/waves.glsl
/* harmony default export */ var waves = ("// https://www.shadertoy.com/view/Xdlczl\n#define DRAG_MULT 0.048\n#define ITERATIONS_NORMAL 48\nvec2 wavedx(vec2 position, vec2 direction, float speed, float frequency, float timeshift) {\n\tfloat x = dot(direction, position) * frequency + timeshift * speed;\n\tfloat wave = exp(sin(x) - 1.0);\n\tfloat dx = wave * cos(x);\n\treturn vec2(wave, -dx);\n}\nfloat getwaves(vec2 position, float currentTime, float freq, float freqMult, float speedMult){\n\tfloat iter = 0.0;\n\tfloat speed = 2.0;\n\tfloat weight = 1.0;\n\tfloat w = 0.0;\n\tfloat ws = 0.0;\n\tfor(int i=0;i<ITERATIONS_NORMAL;i++){\n\t\tvec2 p = vec2(sin(iter), cos(iter));\n\t\tvec2 res = wavedx(position, p, speed, freq, currentTime);\n\t\tposition += p * res.y * weight * DRAG_MULT;\n\t\tw += res.x * weight;\n\t\titer += 12.0;\n\t\tws += weight;\n\t\tweight = mix(weight, 0.0, 0.2);\n\t\tfreq *= freqMult;\n\t\tspeed *= speedMult;\n\t}\n\treturn (w / ws);\n}");
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/gl/Waves.ts







const Waves_OUTPUT_NAME = "h";
class WavesGlParamsConfig extends params_ParamsConfig/* NodeParamsConfig */.yI {
  constructor() {
    super(...arguments);
    this.position = params_ParamsConfig/* ParamConfig.VECTOR2 */.XC.VECTOR2([0, 0]);
    this.time = params_ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(0);
    this.freq = params_ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(6, {
      range: [0, 10],
      rangeLocked: [false, false]
    });
    this.freqMult = params_ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(1.18, {
      range: [0, 2],
      rangeLocked: [false, false]
    });
    this.speedMult = params_ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(1.07, {
      range: [0, 2],
      rangeLocked: [false, false]
    });
  }
}
const Waves_ParamsConfig = new WavesGlParamsConfig();
class WavesGlNode extends gl_Base/* TypedGlNode */.hD {
  constructor() {
    super(...arguments);
    this.paramsConfig = Waves_ParamsConfig;
  }
  static type() {
    return "waves";
  }
  initializeNode() {
    super.initializeNode();
    this.io.outputs.setNamedOutputConnectionPoints([
      new Gl/* GlConnectionPoint */.E(Waves_OUTPUT_NAME, Gl/* GlConnectionPointType.FLOAT */.Dv.FLOAT)
    ]);
  }
  setLines(linesController) {
    const position = ThreeToGl/* ThreeToGl.vector3 */._.vector3(this.variableForInputParam(this.p.position));
    const time = ThreeToGl/* ThreeToGl.float */._.float(this.variableForInputParam(this.p.time));
    const freq = ThreeToGl/* ThreeToGl.float */._.float(this.variableForInputParam(this.p.freq));
    const freqMult = ThreeToGl/* ThreeToGl.float */._.float(this.variableForInputParam(this.p.freqMult));
    const speedMult = ThreeToGl/* ThreeToGl.float */._.float(this.variableForInputParam(this.p.speedMult));
    const float = this.glVarName(Waves_OUTPUT_NAME);
    const args = [position, time, freq, freqMult, speedMult];
    const bodyLine = `float ${float} = getwaves(${args.join(",")})`;
    linesController.addBodyLines(this, [bodyLine]);
    linesController.addDefinitions(this, [new GLDefinition/* FunctionGLDefinition */.MR(this, waves)]);
  }
}

// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/poly/registers/nodes/types/Sop.ts
var Sop = __webpack_require__(58986);
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/poly/registers/nodes/Gl.ts

























































































































































const SUBNET_CHILD_OPTION = {
  only: [
    `${ComputeNormals/* ComputeNormalsGlNode.context */.z.context()}/${ComputeNormals/* ComputeNormalsGlNode.type */.z.type()}`,
    `${IfThen/* IfThenGlNode.context */.O.context()}/${IfThen/* IfThenGlNode.type */.O.type()}`,
    `${gl_Subnet/* SubnetGlNode.context */.Op.context()}/${gl_Subnet/* SubnetGlNode.type */.Op.type()}`,
    `${ForLoop/* ForLoopGlNode.context */.T.context()}/${ForLoop/* ForLoopGlNode.type */.T.type()}`,
    `${SDFGradientGlNode.context()}/${SDFGradientGlNode.type()}`
  ]
};
const particlesOnlyOption = {
  only: [`${poly_NodeContext/* NodeContext.SOP */.sy.SOP}/${Sop/* SopType.PARTICLES_SYSTEM_GPU */.aB.PARTICLES_SYSTEM_GPU}`]
};
class GlRegister {
  static run(poly) {
    poly.registerNode(AbsGlNode, CATEGORY_GL.MATH);
    poly.registerNode(AccelerationGlNode, CATEGORY_GL.PHYSICS);
    poly.registerNode(AcosGlNode, CATEGORY_GL.TRIGO);
    poly.registerNode(AddGlNode, CATEGORY_GL.MATH);
    poly.registerNode(AdjacentPointsAttribSmoothGlNode, CATEGORY_GL.ADVANCED, particlesOnlyOption);
    poly.registerNode(AdjacentUvAttribSmoothGlNode, CATEGORY_GL.ADVANCED, particlesOnlyOption);
    poly.registerNode(AlignGlNode, CATEGORY_GL.TRIGO);
    poly.registerNode(AndGlNode, CATEGORY_GL.LOGIC);
    poly.registerNode(AsinGlNode, CATEGORY_GL.TRIGO);
    poly.registerNode(AtanGlNode, CATEGORY_GL.TRIGO);
    poly.registerNode(Attribute/* AttributeGlNode */.W, CATEGORY_GL.GLOBALS, { except: [`${poly_NodeContext/* NodeContext.COP */.sy.COP}/${Cop/* CopType.BUILDER */.y.BUILDER}`] });
    poly.registerNode(BoolToIntGlNode, CATEGORY_GL.CONVERSION);
    poly.registerNode(CartesianToPolarGlNode, CATEGORY_GL.MATH);
    poly.registerNode(CeilGlNode, CATEGORY_GL.MATH);
    poly.registerNode(ClampGlNode, CATEGORY_GL.MATH);
    poly.registerNode(CheckersGlNode, CATEGORY_GL.GEOMETRY);
    poly.registerNode(ClothSolverPositionGlNode, CATEGORY_GL.ADVANCED);
    poly.registerNode(ClothSolverUvGlNode, CATEGORY_GL.ADVANCED);
    poly.registerNode(ColorCorrect/* ColorCorrectGlNode */.W, CATEGORY_GL.COLOR);
    poly.registerNode(Compare/* CompareGlNode */._, CATEGORY_GL.LOGIC);
    poly.registerNode(ComplementGlNode, CATEGORY_GL.MATH);
    poly.registerNode(ComputeNormals/* ComputeNormalsGlNode */.z, CATEGORY_GL.GEOMETRY);
    poly.registerNode(gl_Constant/* ConstantGlNode */.$, CATEGORY_GL.GLOBALS);
    poly.registerNode(CosGlNode, CATEGORY_GL.TRIGO);
    poly.registerNode(CrossGlNode, CATEGORY_GL.GEOMETRY);
    poly.registerNode(CycleGlNode, CATEGORY_GL.MATH);
    poly.registerNode(DegreesGlNode, CATEGORY_GL.CONVERSION);
    poly.registerNode(DiskGlNode, CATEGORY_GL.GEOMETRY);
    poly.registerNode(DistanceGlNode, CATEGORY_GL.GEOMETRY);
    poly.registerNode(DitherGlNode, CATEGORY_GL.ADVANCED);
    poly.registerNode(DivideGlNode, CATEGORY_GL.MATH);
    poly.registerNode(DotGlNode, CATEGORY_GL.GEOMETRY);
    poly.registerNode(EasingGlNode, CATEGORY_GL.MATH);
    poly.registerNode(ExpGlNode, CATEGORY_GL.MATH);
    poly.registerNode(Exp2GlNode, CATEGORY_GL.MATH);
    poly.registerNode(FaceforwardGlNode, CATEGORY_GL.GEOMETRY);
    poly.registerNode(FitGlNode, CATEGORY_GL.MATH);
    poly.registerNode(FitTo01GlNode, CATEGORY_GL.MATH);
    poly.registerNode(FitFrom01GlNode, CATEGORY_GL.MATH);
    poly.registerNode(FitFrom01ToVarianceGlNode, CATEGORY_GL.MATH);
    poly.registerNode(FloatToIntGlNode, CATEGORY_GL.CONVERSION);
    poly.registerNode(FloatToVec2GlNode, CATEGORY_GL.CONVERSION);
    poly.registerNode(FloatToVec3GlNode, CATEGORY_GL.CONVERSION);
    poly.registerNode(FloatToVec4GlNode, CATEGORY_GL.CONVERSION);
    poly.registerNode(FloorGlNode, CATEGORY_GL.MATH);
    poly.registerNode(FogGlNode, CATEGORY_GL.COLOR);
    poly.registerNode(ForLoop/* ForLoopGlNode */.T, CATEGORY_GL.LOGIC);
    poly.registerNode(FractGlNode, CATEGORY_GL.MATH);
    poly.registerNode(FresnelGlNode, CATEGORY_GL.ADVANCED);
    poly.registerNode(GeometryAttributeLookupUvGlNode, CATEGORY_GL.ADVANCED);
    poly.registerNode(Globals/* GlobalsGlNode */.D, CATEGORY_GL.GLOBALS);
    poly.registerNode(GridGlNode, CATEGORY_GL.GEOMETRY);
    poly.registerNode(HsluvToRgbGlNode, CATEGORY_GL.COLOR);
    poly.registerNode(HsvToRgbGlNode, CATEGORY_GL.COLOR);
    poly.registerNode(IfThen/* IfThenGlNode */.O, CATEGORY_GL.LOGIC);
    poly.registerNode(IsInfOrNanGlNode, CATEGORY_GL.LOGIC);
    poly.registerNode(ImpostorUvGlNode, CATEGORY_GL.UTIL);
    poly.registerNode(InRangeGlNode, CATEGORY_GL.UTIL);
    poly.registerNode(IntToBoolGlNode, CATEGORY_GL.CONVERSION);
    poly.registerNode(IntToFloatGlNode, CATEGORY_GL.CONVERSION);
    poly.registerNode(InstanceTransformGlNode, CATEGORY_GL.GEOMETRY);
    poly.registerNode(InverseSqrtGlNode, CATEGORY_GL.MATH);
    poly.registerNode(InverseTransformDirectionGlNode, CATEGORY_GL.GEOMETRY);
    poly.registerNode(LengthGlNode, CATEGORY_GL.GEOMETRY);
    poly.registerNode(LuminanceGlNode, CATEGORY_GL.COLOR);
    poly.registerNode(LogGlNode, CATEGORY_GL.MATH);
    poly.registerNode(Log2GlNode, CATEGORY_GL.MATH);
    poly.registerNode(MaxGlNode, CATEGORY_GL.MATH);
    poly.registerNode(MaxLengthGlNode, CATEGORY_GL.MATH);
    poly.registerNode(MinGlNode, CATEGORY_GL.MATH);
    poly.registerNode(MixGlNode, CATEGORY_GL.MATH);
    poly.registerNode(ModGlNode, CATEGORY_GL.MATH);
    poly.registerNode(ModelMatrixMultGlNode, CATEGORY_GL.MATH);
    poly.registerNode(ModelViewMatrixMultGlNode, CATEGORY_GL.MATH);
    poly.registerNode(MultGlNode, CATEGORY_GL.MATH);
    poly.registerNode(MultAddGlNode, CATEGORY_GL.MATH);
    poly.registerNode(MultScalarGlNode, CATEGORY_GL.MATH);
    poly.registerNode(MultVectorMatrixGlNode, CATEGORY_GL.MATH);
    poly.registerNode(NegateGlNode, CATEGORY_GL.MATH);
    poly.registerNode(NeighbourAttract/* NeighbourAttractGlNode */.p, CATEGORY_GL.ADVANCED, particlesOnlyOption);
    poly.registerNode(NeighbourAttractRepulse/* NeighbourAttractRepulseGlNode */.x, CATEGORY_GL.ADVANCED, particlesOnlyOption);
    poly.registerNode(NeighbourAttribSmoothGlNode, CATEGORY_GL.ADVANCED, particlesOnlyOption);
    poly.registerNode(NeighbourDensityGlNode, CATEGORY_GL.ADVANCED, particlesOnlyOption);
    poly.registerNode(NeighbourRepulse/* NeighbourRepulseGlNode */.L, CATEGORY_GL.ADVANCED, particlesOnlyOption);
    poly.registerNode(NullGlNode, CATEGORY_GL.UTIL);
    poly.registerNode(NoiseGlNode, CATEGORY_GL.GEOMETRY);
    poly.registerNode(NormalToWorldGlNode, CATEGORY_GL.GEOMETRY);
    poly.registerNode(NormalizeGlNode, CATEGORY_GL.MATH);
    poly.registerNode(OklabToRgbGlNode, CATEGORY_GL.COLOR);
    poly.registerNode(OrGlNode, CATEGORY_GL.LOGIC);
    poly.registerNode(Output/* OutputGlNode */.H, CATEGORY_GL.GLOBALS);
    poly.registerNode(gl_Param/* ParamGlNode */.X, CATEGORY_GL.GLOBALS);
    poly.registerNode(PolarToCartesianGlNode, CATEGORY_GL.MATH);
    poly.registerNode(PositionToWorldGlNode, CATEGORY_GL.MATH);
    poly.registerNode(PowGlNode, CATEGORY_GL.MATH);
    poly.registerNode(QuatMultGlNode, CATEGORY_GL.QUAT);
    poly.registerNode(QuatFromAxisAngleGlNode, CATEGORY_GL.QUAT);
    poly.registerNode(QuatSlerpGlNode, CATEGORY_GL.QUAT);
    poly.registerNode(QuatToAngleGlNode, CATEGORY_GL.QUAT);
    poly.registerNode(QuatToAxisGlNode, CATEGORY_GL.QUAT);
    poly.registerNode(Ramp/* RampGlNode */.d, CATEGORY_GL.GLOBALS);
    poly.registerNode(RandomGlNode, CATEGORY_GL.MATH);
    poly.registerNode(RadiansGlNode, CATEGORY_GL.CONVERSION);
    poly.registerNode(ReflectGlNode, CATEGORY_GL.GEOMETRY);
    poly.registerNode(RefractGlNode, CATEGORY_GL.GEOMETRY);
    poly.registerNode(RgbToHsvGlNode, CATEGORY_GL.COLOR);
    poly.registerNode(RgbToOklabGlNode, CATEGORY_GL.COLOR);
    poly.registerNode(RotateGlNode, CATEGORY_GL.GEOMETRY);
    poly.registerNode(RoundGlNode, CATEGORY_GL.MATH);
    poly.registerNode(SDF2DBoxGlNode, CATEGORY_GL.SDF_PRIMITIVES_2D);
    poly.registerNode(SDF2DCircleGlNode, CATEGORY_GL.SDF_PRIMITIVES_2D);
    poly.registerNode(SDF2DCrossGlNode, CATEGORY_GL.SDF_PRIMITIVES_2D);
    poly.registerNode(SDF2DHeartGlNode, CATEGORY_GL.SDF_PRIMITIVES_2D);
    poly.registerNode(SDF2DRoundedXGlNode, CATEGORY_GL.SDF_PRIMITIVES_2D);
    poly.registerNode(SDF2DStairsGlNode, CATEGORY_GL.SDF_PRIMITIVES_2D);
    poly.registerNode(SDFBoxGlNode, CATEGORY_GL.SDF_PRIMITIVES);
    poly.registerNode(SDFBoxFrameGlNode, CATEGORY_GL.SDF_PRIMITIVES);
    poly.registerNode(SDFBoxRoundGlNode, CATEGORY_GL.SDF_PRIMITIVES);
    poly.registerNode(SDFCapsuleGlNode, CATEGORY_GL.SDF_PRIMITIVES);
    poly.registerNode(SDFCapsuleVerticalGlNode, CATEGORY_GL.SDF_PRIMITIVES);
    poly.registerNode(SDFConeGlNode, CATEGORY_GL.SDF_PRIMITIVES);
    poly.registerNode(SDFConeRoundGlNode, CATEGORY_GL.SDF_PRIMITIVES);
    poly.registerNode(SDFContextGlNode, CATEGORY_GL.SDF_MODIFIERS);
    poly.registerNode(SDFElongateGlNode, CATEGORY_GL.SDF_MODIFIERS);
    poly.registerNode(SDFExtrudeGlNode, CATEGORY_GL.SDF_MODIFIERS);
    poly.registerNode(SDFFractalMandelbrotGlNode, CATEGORY_GL.SDF_PRIMITIVES);
    poly.registerNode(SDFGradientGlNode, CATEGORY_GL.SDF_MODIFIERS);
    poly.registerNode(SDFHexagonalPrismGlNode, CATEGORY_GL.SDF_PRIMITIVES);
    poly.registerNode(SDFHorseShoeGlNode, CATEGORY_GL.SDF_PRIMITIVES);
    poly.registerNode(SDFIntersectGlNode, CATEGORY_GL.SDF_MODIFIERS);
    poly.registerNode(SDFLinkGlNode, CATEGORY_GL.SDF_PRIMITIVES);
    poly.registerNode(SDFMaterial/* SDFMaterialGlNode */.K, CATEGORY_GL.SDF_MODIFIERS);
    poly.registerNode(SDFMaxGlNode, CATEGORY_GL.SDF_MODIFIERS);
    poly.registerNode(SDFMinGlNode, CATEGORY_GL.SDF_MODIFIERS);
    poly.registerNode(SDFMirrorGlNode, CATEGORY_GL.SDF_MODIFIERS);
    poly.registerNode(SDFOctahedronGlNode, CATEGORY_GL.SDF_PRIMITIVES);
    poly.registerNode(SDFOctogonalPrismGlNode, CATEGORY_GL.SDF_PRIMITIVES);
    poly.registerNode(SDFOnionGlNode, CATEGORY_GL.SDF_MODIFIERS);
    poly.registerNode(SDFPlaneGlNode, CATEGORY_GL.SDF_PRIMITIVES);
    poly.registerNode(SDFPyramidGlNode, CATEGORY_GL.SDF_PRIMITIVES);
    poly.registerNode(SDFQuadGlNode, CATEGORY_GL.SDF_PRIMITIVES);
    poly.registerNode(SDFRepeat/* SDFRepeatGlNode */.H, CATEGORY_GL.SDF_MODIFIERS);
    poly.registerNode(SDFRepeatPolarGlNode, CATEGORY_GL.SDF_MODIFIERS);
    poly.registerNode(SDFRevolutionGlNode, CATEGORY_GL.SDF_MODIFIERS);
    poly.registerNode(SDFRhombusGlNode, CATEGORY_GL.SDF_PRIMITIVES);
    poly.registerNode(SDFRhombusTriacontahedronGlNode, CATEGORY_GL.SDF_PRIMITIVES);
    poly.registerNode(SDFSolidAngleGlNode, CATEGORY_GL.SDF_PRIMITIVES);
    poly.registerNode(SDFSphereGlNode, CATEGORY_GL.SDF_PRIMITIVES);
    poly.registerNode(SDFSphereCutGlNode, CATEGORY_GL.SDF_PRIMITIVES);
    poly.registerNode(SDFSphereHollowGlNode, CATEGORY_GL.SDF_PRIMITIVES);
    poly.registerNode(SDFSubtractGlNode, CATEGORY_GL.SDF_MODIFIERS);
    poly.registerNode(SDFTorusGlNode, CATEGORY_GL.SDF_PRIMITIVES);
    poly.registerNode(SDFTransformGlNode, CATEGORY_GL.SDF_MODIFIERS);
    poly.registerNode(SDFTriangleGlNode, CATEGORY_GL.SDF_PRIMITIVES);
    poly.registerNode(SDFTriangularPrismGlNode, CATEGORY_GL.SDF_PRIMITIVES);
    poly.registerNode(SDFTubeGlNode, CATEGORY_GL.SDF_PRIMITIVES);
    poly.registerNode(SDFTwistGlNode, CATEGORY_GL.SDF_MODIFIERS);
    poly.registerNode(SDFUnionGlNode, CATEGORY_GL.SDF_MODIFIERS);
    poly.registerNode(SignGlNode, CATEGORY_GL.MATH);
    poly.registerNode(SinGlNode, CATEGORY_GL.TRIGO);
    poly.registerNode(SkinningGlNode, CATEGORY_GL.GEOMETRY);
    poly.registerNode(SmoothstepGlNode, CATEGORY_GL.MATH);
    poly.registerNode(SphereGlNode, CATEGORY_GL.GEOMETRY);
    poly.registerNode(SqrtGlNode, CATEGORY_GL.MATH);
    poly.registerNode(SSSModelGlNode, CATEGORY_GL.LIGHTING);
    poly.registerNode(StepGlNode, CATEGORY_GL.GEOMETRY);
    poly.registerNode(gl_Subnet/* SubnetGlNode */.Op, CATEGORY_GL.LOGIC);
    poly.registerNode(SubnetInputGlNode, CATEGORY_GL.LOGIC, SUBNET_CHILD_OPTION);
    poly.registerNode(gl_SubnetOutput/* SubnetOutputGlNode */.U, CATEGORY_GL.LOGIC, SUBNET_CHILD_OPTION);
    poly.registerNode(SubtractGlNode, CATEGORY_GL.MATH);
    poly.registerNode(SwitchGlNode, CATEGORY_GL.LOGIC);
    poly.registerNode(TanGlNode, CATEGORY_GL.TRIGO);
    poly.registerNode(Texture/* TextureGlNode */.q, CATEGORY_GL.COLOR);
    poly.registerNode(Texture2DArray/* Texture2DArrayGlNode */.E, CATEGORY_GL.COLOR);
    poly.registerNode(TextureDisplacementGlNode, CATEGORY_GL.COLOR);
    poly.registerNode(TextureSDF/* TextureSDFGlNode */.k, CATEGORY_GL.COLOR);
    poly.registerNode(TileUvGlNode, CATEGORY_GL.UTIL);
    poly.registerNode(ToWorldSpaceGlNode, CATEGORY_GL.GLOBALS);
    poly.registerNode(TwoWaySwitchGlNode, CATEGORY_GL.LOGIC);
    poly.registerNode(UvToOklabGlNode, CATEGORY_GL.COLOR);
    poly.registerNode(VaryingWrite/* VaryingWriteGlNode */.N, CATEGORY_GL.GLOBALS);
    poly.registerNode(VaryingRead/* VaryingReadGlNode */.V, CATEGORY_GL.GLOBALS);
    poly.registerNode(Vec2ToFloatGlNode, CATEGORY_GL.CONVERSION);
    poly.registerNode(Vec2ToVec3GlNode, CATEGORY_GL.CONVERSION);
    poly.registerNode(Vec3ToFloatGlNode, CATEGORY_GL.CONVERSION);
    poly.registerNode(Vec3ToVec2GlNode, CATEGORY_GL.CONVERSION);
    poly.registerNode(Vec3ToVec4GlNode, CATEGORY_GL.CONVERSION);
    poly.registerNode(Vec4ToFloatGlNode, CATEGORY_GL.CONVERSION);
    poly.registerNode(Vec4ToVec3GlNode, CATEGORY_GL.CONVERSION);
    poly.registerNode(VectorAlignGlNode, CATEGORY_GL.GEOMETRY);
    poly.registerNode(VectorAngleGlNode, CATEGORY_GL.GEOMETRY);
    poly.registerNode(VertexAnimationTextureGlNode, CATEGORY_GL.ADVANCED);
    if (false) {}
    poly.registerNode(WavesGlNode, CATEGORY_GL.GEOMETRY);
  }
}

// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/nodes/js/_Base.ts + 1 modules
var js_Base = __webpack_require__(38231);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/nodes/utils/io/connections/Js.ts
var connections_Js = __webpack_require__(38857);
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/js/_BaseMathFunction.ts





class BaseJsMathFunctionParamsConfig extends params_ParamsConfig/* NodeParamsConfig */.yI {
}
const js_BaseMathFunction_ParamsConfig = new BaseJsMathFunctionParamsConfig();
class BaseMathFunctionJsNode extends js_Base/* TypedJsNode */.xZ {
  constructor() {
    super(...arguments);
    this.paramsConfig = js_BaseMathFunction_ParamsConfig;
  }
  initializeNode() {
    super.initializeNode();
    this.io.connection_points.set_expected_input_types_function(this._expectedInputTypes.bind(this));
    this.io.connection_points.set_expected_output_types_function(this._expectedOutputTypes.bind(this));
    this.io.connection_points.set_input_name_function(this._expectedInputName.bind(this));
  }
  _expectedInputTypes() {
    const type = this.io.connection_points.first_input_connection_type() || connections_Js/* JsConnectionPointType.FLOAT */.zF.FLOAT;
    if (this.io.connections.firstInputConnection()) {
      const connections = this.io.connections.inputConnections();
      if (connections) {
        const compactConnections = [];
        (0,ArrayUtils/* arrayCompact */.k)(connections, compactConnections);
        let count = Math.max(compactConnections.length + 1, 2);
        return (0,ArrayUtils/* rangeWithEnd */.Zi)(count).map((i) => type);
      } else {
        return [];
      }
    } else {
      return (0,ArrayUtils/* rangeWithEnd */.Zi)(2).map((i) => type);
    }
  }
  _expectedOutputTypes() {
    const type = this._expectedInputTypes()[0];
    return [type];
  }
  _expectedInputName(index) {
    return "in";
  }
  _expectedOutputName(index) {
    return "val";
  }
}

// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/nodes/js/code/assemblers/_BaseJsPersistedConfigUtils.ts
var _BaseJsPersistedConfigUtils = __webpack_require__(99463);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/functions/_MathGeneric.ts
var _MathGeneric = __webpack_require__(55681);
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/js/_Math_Arg1Operation.ts






const PRIMITIVE_ALLOWED_TYPES = [
  connections_Js/* JsConnectionPointType.INT */.zF.INT,
  connections_Js/* JsConnectionPointType.COLOR */.zF.COLOR,
  connections_Js/* JsConnectionPointType.FLOAT */.zF.FLOAT,
  connections_Js/* JsConnectionPointType.VECTOR2 */.zF.VECTOR2,
  connections_Js/* JsConnectionPointType.VECTOR3 */.zF.VECTOR3,
  connections_Js/* JsConnectionPointType.VECTOR4 */.zF.VECTOR4
];
const ARRAY_ALLOWED_TYPES = PRIMITIVE_ALLOWED_TYPES.map((type) => connections_Js/* JsConnectionPointTypeToArrayTypeMap */.RC[type]);
const DEFAULT_ALLOWED_TYPES = [...PRIMITIVE_ALLOWED_TYPES, ...ARRAY_ALLOWED_TYPES];
const FUNC_ARG_NAME = "_mathFunc";
function MathFunctionArgXOperationFactory(type, options) {
  const inputPrefix = options.inputPrefix || type;
  const outputName = options.out || "val";
  const allowed_in_types = options.allowed_in_types || DEFAULT_ALLOWED_TYPES;
  return class Node extends BaseMathFunctionJsNode {
    static type() {
      return type;
    }
    initializeNode() {
      super.initializeNode();
      this.io.connection_points.set_input_name_function(this._expectedInputName.bind(this));
      this.io.connection_points.set_output_name_function(this._expectedOutputName.bind(this));
      this.io.connection_points.set_expected_input_types_function(this._expectedInputTypes.bind(this));
      this.io.connection_points.set_expected_output_types_function(this._expectedOutputTypes.bind(this));
    }
    setLines(shadersCollectionController) {
      const varName = this.jsVarName(this._expectedOutputName(0));
      const inputType = this._expectedInputTypes()[0];
      const variable = (0,_BaseJsPersistedConfigUtils/* createVariable */.Os)(inputType);
      const tmpVarName = variable != null ? shadersCollectionController.addVariable(this, variable) : void 0;
      const mainFunction = this._mainFunction(shadersCollectionController, tmpVarName);
      if (!mainFunction) {
        return;
      }
      shadersCollectionController.addBodyOrComputed(this, [{ dataType: inputType, varName, value: mainFunction }]);
    }
    _mainFunction(shadersCollectionController, tmpVarName) {
      const functionData = this._functionData();
      const { vectorFunctionNameFunction, mathFloat, mathPrimArray, mathVectorArray } = functionData;
      const args = this._inputArgs(shadersCollectionController);
      const inputType = this._expectedInputTypes()[0];
      const isPrimitive = (0,connections_Js/* isJsConnectionPointPrimitive */.wY)(inputType);
      const coreFunction = this._coreFunction(shadersCollectionController);
      if (isPrimitive) {
        return Poly/* Poly.namedFunctionsRegister.getFunction */.L.namedFunctionsRegister.getFunction(mathFloat, this, shadersCollectionController).asString(...[coreFunction, ...args]);
      }
      if (!tmpVarName) {
        return;
      }
      const vectorFunctionName = vectorFunctionNameFunction(inputType);
      if (vectorFunctionName) {
        return Poly/* Poly.namedFunctionsRegister.getFunction */.L.namedFunctionsRegister.getFunction(vectorFunctionName, this, shadersCollectionController).asString(...[coreFunction, ...args, tmpVarName]);
      }
      if ((0,connections_Js/* isJsConnectionPointArray */.$c)(inputType)) {
        const elementInputType = connections_Js/* JsConnectionPointTypeFromArrayTypeMap */.RR[inputType];
        const vectorElementInputFunctionName = vectorFunctionNameFunction(elementInputType);
        if (vectorElementInputFunctionName) {
          Poly/* Poly.namedFunctionsRegister.getFunction */.L.namedFunctionsRegister.getFunction(vectorElementInputFunctionName, this, shadersCollectionController).asString("", "", "");
          return Poly/* Poly.namedFunctionsRegister.getFunction */.L.namedFunctionsRegister.getFunction(mathVectorArray, this, shadersCollectionController).asString(...[coreFunction, vectorElementInputFunctionName, ...args, tmpVarName]);
        } else {
          return Poly/* Poly.namedFunctionsRegister.getFunction */.L.namedFunctionsRegister.getFunction(mathPrimArray, this, shadersCollectionController).asString(...[coreFunction, ...args, tmpVarName]);
        }
      }
    }
    _coreFunction(shadersCollectionController) {
      return `Math.${type}`;
    }
    _functionData() {
      return {
        vectorFunctionNameFunction: _MathGeneric/* _vectorFunctionName_1 */.vr,
        mathFloat: "mathFloat_1",
        mathPrimArray: "mathPrimArray_1",
        mathVectorArray: "mathVectorArray_1"
      };
    }
    _inputValuesCount() {
      const inputTypes = this._expectedInputTypes();
      const inputValuesCount = inputTypes.length;
      return inputValuesCount;
    }
    _inputArgs(shadersCollectionController) {
      const inputValuesCount = this._inputValuesCount();
      const inputArgs = [];
      for (let i = 0; i < inputValuesCount; i++) {
        const arg = this.variableForInput(shadersCollectionController, this._expectedInputName(i));
        inputArgs.push(arg);
      }
      return inputArgs;
    }
    _expectedInputName(index) {
      return inputPrefix;
    }
    _expectedOutputName(index) {
      return outputName;
    }
    _expectedInputTypes() {
      let first_input_type = this.io.connection_points.first_input_connection_type();
      const connectionPoints = this.io.inputs.namedInputConnectionPoints();
      if (first_input_type && connectionPoints) {
        if (!allowed_in_types.includes(first_input_type)) {
          const first_connection = connectionPoints[0];
          if (first_connection) {
            first_input_type = first_connection.type();
          }
        }
      }
      const type2 = first_input_type || connections_Js/* JsConnectionPointType.FLOAT */.zF.FLOAT;
      return [type2];
    }
    _expectedOutputTypes() {
      return [this._expectedInputTypes()[0]];
    }
  };
}
function MathFunctionArg1OperationFactory(type, options) {
  return class Node extends MathFunctionArgXOperationFactory(type, options) {
  };
}
function _Math_Arg1Operation_MathFunctionArg2OperationFactory(type, options) {
  return class Node extends MathFunctionArgXOperationFactory(type, options) {
    // TODO: this should ideally be inherited from the class created by MathFunctionArgXOperationFactory
    // and would therefore require an override statement,
    // and would then automatically have the return type FunctionData<MathVectorFunction2>
    _functionData() {
      return {
        vectorFunctionNameFunction: _MathGeneric/* _vectorFunctionName_2 */.nB,
        mathFloat: "mathFloat_2",
        mathPrimArray: "mathPrimArray_2",
        mathVectorArray: "mathVectorArray_2"
      };
    }
  };
}
function MathFunctionArg3OperationFactory(type, options) {
  return class Node extends MathFunctionArgXOperationFactory(type, options) {
    // TODO: this should ideally be inherited from the class created by MathFunctionArgXOperationFactory
    // and would therefore require an override statement,
    // and would then automatically have the return type FunctionData<MathVectorFunction2>
    _functionData() {
      return {
        vectorFunctionNameFunction: _MathGeneric/* _vectorFunctionName_3 */.tU,
        mathFloat: "mathFloat_3",
        mathPrimArray: "mathPrimArray_3",
        mathVectorArray: "mathVectorArray_3"
      };
    }
  };
}
function MathFunctionArg4OperationFactory(type, options) {
  return class Node extends MathFunctionArgXOperationFactory(type, options) {
    // TODO: this should ideally be inherited from the class created by MathFunctionArgXOperationFactory
    // and would therefore require an override statement,
    // and would then automatically have the return type FunctionData<MathVectorFunction2>
    _functionData() {
      return {
        vectorFunctionNameFunction: _MathGeneric/* _vectorFunctionName_4 */.Et,
        mathFloat: "mathFloat_4",
        mathPrimArray: "mathPrimArray_4",
        mathVectorArray: "mathVectorArray_4"
      };
    }
  };
}
function MathFunctionArg5OperationFactory(type, options) {
  return class Node extends MathFunctionArgXOperationFactory(type, options) {
    // TODO: this should ideally be inherited from the class created by MathFunctionArgXOperationFactory
    // and would therefore require an override statement,
    // and would then automatically have the return type FunctionData<MathVectorFunction2>
    _functionData() {
      return {
        vectorFunctionNameFunction: _MathGeneric/* _vectorFunctionName_5 */.cm,
        mathFloat: "mathFloat_5",
        mathPrimArray: "mathPrimArray_5",
        mathVectorArray: "mathVectorArray_5"
      };
    }
  };
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/js/Abs.ts


class AbsJsNode extends MathFunctionArg1OperationFactory("abs", {
  inputPrefix: "val",
  out: "abs"
}) {
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/js/Acos.ts


class AcosJsNode extends MathFunctionArg1OperationFactory("acos", {
  inputPrefix: "val",
  out: "acos"
}) {
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/js/_Math_ArgNOperation.ts




const VECTOR_TYPES = [connections_Js/* JsConnectionPointType.VECTOR2 */.zF.VECTOR2, connections_Js/* JsConnectionPointType.VECTOR3 */.zF.VECTOR3, connections_Js/* JsConnectionPointType.VECTOR4 */.zF.VECTOR4];
function MathFunctionArgNOperationFactory(type, options) {
  const inputPrefix = options.inputPrefix || type;
  const outputName = options.out || "val";
  const allowedInTypes = options.allowedInTypes;
  const operator = options.operator;
  return class Node extends BaseMathFunctionJsNode {
    static type() {
      return type;
    }
    initializeNode() {
      super.initializeNode();
      this.io.connection_points.set_input_name_function(this._expectedInputName.bind(this));
      this.io.connection_points.set_output_name_function(this._expectedOutputName.bind(this));
      this.io.connection_points.set_expected_input_types_function(this._expectedInputTypes.bind(this));
      this.io.connection_points.set_expected_output_types_function(this._expectedOutputTypes.bind(this));
    }
    setLines(linesController) {
      const firstType = this._expectedInputTypes()[0];
      const varName = this.jsVarName(outputName);
      const funcString = this._functionString(linesController);
      if (!funcString) {
        console.warn("no function found");
        return;
      }
      linesController.addBodyOrComputed(this, [
        {
          dataType: firstType,
          varName,
          value: funcString
        }
      ]);
    }
    _functionString(linesController) {
      const values = [];
      const connectionPoints = this.io.inputs.namedInputConnectionPoints();
      if (!connectionPoints) {
        return;
      }
      for (let connectionPoint of connectionPoints) {
        const connectionPointName = connectionPoint.name();
        const value = this.variableForInput(linesController, connectionPointName);
        values.push(value);
      }
      const expectedTypes = this._expectedInputTypes();
      const firstType = expectedTypes[0];
      const secondInputType = expectedTypes[1];
      const isPrimitive = (0,connections_Js/* isJsConnectionPointPrimitive */.wY)(firstType);
      if (isPrimitive) {
        return Poly/* Poly.namedFunctionsRegister.getFunction */.L.namedFunctionsRegister.getFunction(operator.primitive, this, linesController).asString(...values);
      }
      const isFirstInputVector = (0,connections_Js/* isJsConnectionPointVector */.wJ)(firstType);
      const isSecondInputScalar = secondInputType != null && (0,connections_Js/* isJsConnectionPointNumber */.kb)(secondInputType);
      const isVectorScalar = isFirstInputVector && isSecondInputScalar;
      if (isVectorScalar) {
        return Poly/* Poly.namedFunctionsRegister.getFunction */.L.namedFunctionsRegister.getFunction(operator.vectorScalar, this, linesController).asString(values[0], values[1]);
      }
      if (operator.vector) {
        return Poly/* Poly.namedFunctionsRegister.getFunction */.L.namedFunctionsRegister.getFunction(operator.vector, this, linesController).asString(...values);
      }
    }
    _expectedInputName(index) {
      return `${inputPrefix}${index}`;
    }
    _expectedOutputName(index) {
      return outputName;
    }
    _expectedInputTypes() {
      let firstInputType = this.io.connection_points.first_input_connection_type();
      const connectionPoints = this.io.inputs.namedInputConnectionPoints();
      if (firstInputType && allowedInTypes && connectionPoints) {
        if (!allowedInTypes.includes(firstInputType)) {
          const firstConnection = connectionPoints[0];
          if (firstConnection) {
            firstInputType = firstConnection.type();
          }
        }
      }
      const type2 = firstInputType || connections_Js/* JsConnectionPointType.FLOAT */.zF.FLOAT;
      if (VECTOR_TYPES.includes(type2)) {
        const secondInputType = this.io.connection_points.input_connection_type(1);
        if (secondInputType != null && secondInputType == connections_Js/* JsConnectionPointType.FLOAT */.zF.FLOAT) {
          const expectedInputTypes2 = [type2, secondInputType];
          return expectedInputTypes2;
        }
      }
      const currentConnections = this.io.connections.existingInputConnections();
      const expectedCount = currentConnections ? Math.max(currentConnections.length + 1, 2) : 2;
      const expectedInputTypes = [];
      for (let i = 0; i < expectedCount; i++) {
        if (i == 0) {
          expectedInputTypes.push(type2);
        } else {
          const nextType = operator.vector != null ? type2 : connections_Js/* JsConnectionPointType.FLOAT */.zF.FLOAT;
          expectedInputTypes.push(nextType);
        }
      }
      return expectedInputTypes;
    }
    _expectedOutputTypes() {
      const inputTypes = this._expectedInputTypes();
      const type2 = inputTypes[0] || connections_Js/* JsConnectionPointType.FLOAT */.zF.FLOAT;
      return [type2];
    }
  };
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/js/Add.ts


class AddJsNode extends MathFunctionArgNOperationFactory("add", {
  inputPrefix: "add",
  out: "sum",
  operator: {
    primitive: "addNumber",
    vector: "addVector",
    vectorScalar: "addVectorNumber"
  }
}) {
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/js/_BaseLogicOperation.ts




const _BaseLogicOperation_ALLOWED_TYPES = [connections_Js/* JsConnectionPointType.BOOLEAN */.zF.BOOLEAN, connections_Js/* JsConnectionPointType.BOOLEAN_ARRAY */.zF.BOOLEAN_ARRAY];
class BaseLogicOperationJsNode extends js_Base/* ParamlessTypedJsNode */.au {
  initializeNode() {
    super.initializeNode();
    this.io.connection_points.set_expected_input_types_function(this._expectedInputTypes.bind(this));
    this.io.connection_points.set_expected_output_types_function(this._expectedOutputTypes.bind(this));
    this.io.connection_points.set_input_name_function(this._expectedInputName.bind(this));
    this.io.connection_points.set_output_name_function(this._expectedOutputName.bind(this));
  }
  _expectedInputName(index) {
    const type = this._expectedInputTypes()[0];
    return `${type}${index}`;
  }
  _expectedInputTypes() {
    const firstInputType = this.io.connection_points.first_input_connection_type();
    const type = firstInputType != null && _BaseLogicOperation_ALLOWED_TYPES.includes(firstInputType) ? firstInputType : connections_Js/* JsConnectionPointType.BOOLEAN */.zF.BOOLEAN;
    const currentConnections = this.io.connections.existingInputConnections();
    const expectedCount = currentConnections ? Math.max(currentConnections.length + 1, 2) : 2;
    const expectedInputTypes = [];
    for (let i = 0; i < expectedCount; i++) {
      expectedInputTypes.push(type);
    }
    return expectedInputTypes;
  }
  _expectedOutputTypes() {
    return [connections_Js/* JsConnectionPointType.BOOLEAN */.zF.BOOLEAN];
  }
  setLines(shadersCollectionController) {
    const inputValuesCount = this._expectedInputTypes().length - 1;
    const inputArgs = [];
    for (let i = 0; i < inputValuesCount; i++) {
      const element = this.variableForInput(shadersCollectionController, this._expectedInputName(i));
      inputArgs.push(element);
    }
    const inputElements = `[${inputArgs.join(",")}]`;
    const dataType = this._expectedInputTypes()[0];
    const varName = this.jsVarName(this._expectedOutputName(0));
    const firstType = this._expectedInputTypes()[0];
    const functionName = this._functionName(firstType);
    const func = Poly/* Poly.namedFunctionsRegister.getFunction */.L.namedFunctionsRegister.getFunction(functionName, this, shadersCollectionController);
    shadersCollectionController.addBodyOrComputed(this, [
      {
        dataType,
        varName,
        value: func.asString(inputElements)
      }
    ]);
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/js/And.ts



class AndJsNode extends BaseLogicOperationJsNode {
  static type() {
    return "and";
  }
  _expectedOutputName() {
    return "and";
  }
  _functionName(firstType) {
    return firstType == connections_Js/* JsConnectionPointType.BOOLEAN */.zF.BOOLEAN ? "andBooleans" : "andArrays";
  }
}

// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/nodes/js/AnimationAction.ts
var AnimationAction = __webpack_require__(67964);
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/js/AnimationActionCrossFade.ts






const CONNECTION_OPTIONS = connections_Js/* JS_CONNECTION_POINT_IN_NODE_DEF */.mX;
var AnimationActionCrossFadeJsNodeInputName = /* @__PURE__ */ ((AnimationActionCrossFadeJsNodeInputName2) => {
  AnimationActionCrossFadeJsNodeInputName2["FROM"] = "from";
  AnimationActionCrossFadeJsNodeInputName2["TO"] = "to";
  return AnimationActionCrossFadeJsNodeInputName2;
})(AnimationActionCrossFadeJsNodeInputName || {});
class AnimationActionCrossFadeJsParamsConfig extends params_ParamsConfig/* NodeParamsConfig */.yI {
  constructor() {
    super(...arguments);
    /** @param fadeIn duration */
    this.duration = params_ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(1);
    /** @param additional warping (gradually changes of the time scales) will be applied */
    this.warp = params_ParamsConfig/* ParamConfig.BOOLEAN */.XC.BOOLEAN(1);
    /** @param starts cross fade when the from action ends */
    this.startOnFromActionEnd = params_ParamsConfig/* ParamConfig.BOOLEAN */.XC.BOOLEAN(1);
  }
}
const AnimationActionCrossFade_ParamsConfig = new AnimationActionCrossFadeJsParamsConfig();
class AnimationActionCrossFadeJsNode extends js_Base/* TypedJsNode */.xZ {
  constructor() {
    super(...arguments);
    this.paramsConfig = AnimationActionCrossFade_ParamsConfig;
  }
  static type() {
    return "animationActionCrossFade";
  }
  initializeNode() {
    this.io.inputs.setNamedInputConnectionPoints([
      new connections_Js/* JsConnectionPoint */.fp(js_Base/* TRIGGER_CONNECTION_NAME */.w6, connections_Js/* JsConnectionPointType.TRIGGER */.zF.TRIGGER, CONNECTION_OPTIONS),
      new connections_Js/* JsConnectionPoint */.fp(
        "from" /* FROM */,
        connections_Js/* JsConnectionPointType.ANIMATION_ACTION */.zF.ANIMATION_ACTION,
        CONNECTION_OPTIONS
      ),
      new connections_Js/* JsConnectionPoint */.fp(
        "to" /* TO */,
        connections_Js/* JsConnectionPointType.ANIMATION_ACTION */.zF.ANIMATION_ACTION,
        CONNECTION_OPTIONS
      )
    ]);
  }
  setTriggerableLines(shadersCollectionController) {
    const actionFrom = this.variableForInput(
      shadersCollectionController,
      "from" /* FROM */
    );
    const actionTo = this.variableForInput(shadersCollectionController, "to" /* TO */);
    const duration = this.variableForInputParam(shadersCollectionController, this.p.duration);
    const warp = this.variableForInputParam(shadersCollectionController, this.p.warp);
    const startOnFromActionEnd = this.variableForInputParam(
      shadersCollectionController,
      this.p.startOnFromActionEnd
    );
    const func = Poly/* Poly.namedFunctionsRegister.getFunction */.L.namedFunctionsRegister.getFunction(
      "animationActionCrossFade",
      this,
      shadersCollectionController
    );
    const bodyLine = func.asString(actionFrom, `()=>${actionTo}`, duration, warp, startOnFromActionEnd);
    shadersCollectionController.addTriggerableLines(this, [bodyLine]);
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/js/AnimationActionFadeOut.ts






const AnimationActionFadeOut_CONNECTION_OPTIONS = connections_Js/* JS_CONNECTION_POINT_IN_NODE_DEF */.mX;
class AnimationActionFadeOutJsParamsConfig extends params_ParamsConfig/* NodeParamsConfig */.yI {
  constructor() {
    super(...arguments);
    /** @param manual trigger */
    // trigger = ParamConfig.BUTTON(null, ACTOR_NODE_SELF_TRIGGER_CALLBACK);
    /** @param fadeIn duration */
    this.duration = params_ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(1);
  }
}
const AnimationActionFadeOut_ParamsConfig = new AnimationActionFadeOutJsParamsConfig();
class AnimationActionFadeOutJsNode extends js_Base/* TypedJsNode */.xZ {
  constructor() {
    super(...arguments);
    this.paramsConfig = AnimationActionFadeOut_ParamsConfig;
  }
  static type() {
    return "animationActionFadeOut";
  }
  initializeNode() {
    this.io.inputs.setNamedInputConnectionPoints([
      new connections_Js/* JsConnectionPoint */.fp(js_Base/* TRIGGER_CONNECTION_NAME */.w6, connections_Js/* JsConnectionPointType.TRIGGER */.zF.TRIGGER, AnimationActionFadeOut_CONNECTION_OPTIONS),
      new connections_Js/* JsConnectionPoint */.fp(
        connections_Js/* JsConnectionPointType.ANIMATION_ACTION */.zF.ANIMATION_ACTION,
        connections_Js/* JsConnectionPointType.ANIMATION_ACTION */.zF.ANIMATION_ACTION,
        AnimationActionFadeOut_CONNECTION_OPTIONS
      )
    ]);
  }
  setTriggerableLines(shadersCollectionController) {
    const action = this.variableForInput(shadersCollectionController, connections_Js/* JsConnectionPointType.ANIMATION_ACTION */.zF.ANIMATION_ACTION);
    const duration = this.variableForInputParam(shadersCollectionController, this.p.duration);
    const func = Poly/* Poly.namedFunctionsRegister.getFunction */.L.namedFunctionsRegister.getFunction(
      "animationActionFadeOut",
      this,
      shadersCollectionController
    );
    const bodyLine = func.asString(action, duration);
    shadersCollectionController.addTriggerableLines(this, [bodyLine]);
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/js/AnimationActionFadeIn.ts






const AnimationActionFadeIn_CONNECTION_OPTIONS = connections_Js/* JS_CONNECTION_POINT_IN_NODE_DEF */.mX;
class AnimationActionFadeInJsParamsConfig extends params_ParamsConfig/* NodeParamsConfig */.yI {
  constructor() {
    super(...arguments);
    /** @param fadeIn duration */
    this.duration = params_ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(1);
    /** @param fade out other actions */
    this.fadeOutOtherActions = params_ParamsConfig/* ParamConfig.BOOLEAN */.XC.BOOLEAN(1);
    /** @param additional warping (gradually changes of the time scales) will be applied */
    this.warp = params_ParamsConfig/* ParamConfig.BOOLEAN */.XC.BOOLEAN(1, {
      visibleIf: { fadeOutOtherActions: 1 }
    });
    /** @param starts cross fade when the from action ends */
    this.startOnFromActionEnd = params_ParamsConfig/* ParamConfig.BOOLEAN */.XC.BOOLEAN(1, {
      visibleIf: { fadeOutOtherActions: 1 }
    });
  }
}
const AnimationActionFadeIn_ParamsConfig = new AnimationActionFadeInJsParamsConfig();
class AnimationActionFadeInJsNode extends js_Base/* TypedJsNode */.xZ {
  constructor() {
    super(...arguments);
    this.paramsConfig = AnimationActionFadeIn_ParamsConfig;
  }
  static type() {
    return "animationActionFadeIn";
  }
  initializeNode() {
    this.io.inputs.setNamedInputConnectionPoints([
      new connections_Js/* JsConnectionPoint */.fp(js_Base/* TRIGGER_CONNECTION_NAME */.w6, connections_Js/* JsConnectionPointType.TRIGGER */.zF.TRIGGER, AnimationActionFadeIn_CONNECTION_OPTIONS),
      new connections_Js/* JsConnectionPoint */.fp(
        connections_Js/* JsConnectionPointType.ANIMATION_ACTION */.zF.ANIMATION_ACTION,
        connections_Js/* JsConnectionPointType.ANIMATION_ACTION */.zF.ANIMATION_ACTION,
        AnimationActionFadeIn_CONNECTION_OPTIONS
      )
    ]);
  }
  setTriggerableLines(shadersCollectionController) {
    const action = this.variableForInput(shadersCollectionController, connections_Js/* JsConnectionPointType.ANIMATION_ACTION */.zF.ANIMATION_ACTION);
    const duration = this.variableForInputParam(shadersCollectionController, this.p.duration);
    const fadeOutOtherActions = this.variableForInputParam(shadersCollectionController, this.p.fadeOutOtherActions);
    const warp = this.variableForInputParam(shadersCollectionController, this.p.warp);
    const startOnFromActionEnd = this.variableForInputParam(
      shadersCollectionController,
      this.p.startOnFromActionEnd
    );
    const func = Poly/* Poly.namedFunctionsRegister.getFunction */.L.namedFunctionsRegister.getFunction(
      "animationActionFadeIn",
      this,
      shadersCollectionController
    );
    const bodyLine = func.asString(action, duration, fadeOutOtherActions, warp, startOnFromActionEnd);
    shadersCollectionController.addTriggerableLines(this, [bodyLine]);
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/js/AnimationActionPlay.ts






const AnimationActionPlay_CONNECTION_OPTIONS = connections_Js/* JS_CONNECTION_POINT_IN_NODE_DEF */.mX;
class AnimationActionPlayJsParamsConfig extends params_ParamsConfig/* NodeParamsConfig */.yI {
  /** @param manual trigger */
  // trigger = ParamConfig.BUTTON(null, ACTOR_NODE_SELF_TRIGGER_CALLBACK);
}
const AnimationActionPlay_ParamsConfig = new AnimationActionPlayJsParamsConfig();
class AnimationActionPlayJsNode extends js_Base/* TypedJsNode */.xZ {
  constructor() {
    super(...arguments);
    this.paramsConfig = AnimationActionPlay_ParamsConfig;
  }
  static type() {
    return "animationActionPlay";
  }
  initializeNode() {
    this.io.inputs.setNamedInputConnectionPoints([
      new connections_Js/* JsConnectionPoint */.fp(js_Base/* TRIGGER_CONNECTION_NAME */.w6, connections_Js/* JsConnectionPointType.TRIGGER */.zF.TRIGGER, AnimationActionPlay_CONNECTION_OPTIONS),
      new connections_Js/* JsConnectionPoint */.fp(
        connections_Js/* JsConnectionPointType.ANIMATION_ACTION */.zF.ANIMATION_ACTION,
        connections_Js/* JsConnectionPointType.ANIMATION_ACTION */.zF.ANIMATION_ACTION,
        AnimationActionPlay_CONNECTION_OPTIONS
      )
    ]);
  }
  setTriggerableLines(shadersCollectionController) {
    const action = this.variableForInput(shadersCollectionController, connections_Js/* JsConnectionPointType.ANIMATION_ACTION */.zF.ANIMATION_ACTION);
    const func = Poly/* Poly.namedFunctionsRegister.getFunction */.L.namedFunctionsRegister.getFunction("animationActionPlay", this, shadersCollectionController);
    const bodyLine = func.asString(action);
    shadersCollectionController.addTriggerableLines(this, [bodyLine]);
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/js/AnimationActionStop.ts






const AnimationActionStop_CONNECTION_OPTIONS = connections_Js/* JS_CONNECTION_POINT_IN_NODE_DEF */.mX;
class AnimationActionStopJsParamsConfig extends params_ParamsConfig/* NodeParamsConfig */.yI {
  /** @param manual trigger */
  // trigger = ParamConfig.BUTTON(null, ACTOR_NODE_SELF_TRIGGER_CALLBACK);
}
const AnimationActionStop_ParamsConfig = new AnimationActionStopJsParamsConfig();
class AnimationActionStopJsNode extends js_Base/* TypedJsNode */.xZ {
  constructor() {
    super(...arguments);
    this.paramsConfig = AnimationActionStop_ParamsConfig;
  }
  static type() {
    return "animationActionStop";
  }
  initializeNode() {
    this.io.inputs.setNamedInputConnectionPoints([
      new connections_Js/* JsConnectionPoint */.fp(js_Base/* TRIGGER_CONNECTION_NAME */.w6, connections_Js/* JsConnectionPointType.TRIGGER */.zF.TRIGGER, AnimationActionStop_CONNECTION_OPTIONS),
      new connections_Js/* JsConnectionPoint */.fp(
        connections_Js/* JsConnectionPointType.ANIMATION_ACTION */.zF.ANIMATION_ACTION,
        connections_Js/* JsConnectionPointType.ANIMATION_ACTION */.zF.ANIMATION_ACTION,
        AnimationActionStop_CONNECTION_OPTIONS
      )
    ]);
  }
  setTriggerableLines(shadersCollectionController) {
    const action = this.variableForInput(shadersCollectionController, connections_Js/* JsConnectionPointType.ANIMATION_ACTION */.zF.ANIMATION_ACTION);
    const func = Poly/* Poly.namedFunctionsRegister.getFunction */.L.namedFunctionsRegister.getFunction("animationActionStop", this, shadersCollectionController);
    const bodyLine = func.asString(action);
    shadersCollectionController.addTriggerableLines(this, [bodyLine]);
  }
}

// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/nodes/js/AnimationMixer.ts
var AnimationMixer = __webpack_require__(76906);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/nodes/js/_BaseObject3D.ts
var _BaseObject3D = __webpack_require__(75807);
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/js/AnimationMixerUpdate.ts







const AnimationMixerUpdate_CONNECTION_OPTIONS = connections_Js/* JS_CONNECTION_POINT_IN_NODE_DEF */.mX;
class AnimationMixerUpdateJsParamsConfig extends params_ParamsConfig/* NodeParamsConfig */.yI {
}
const AnimationMixerUpdate_ParamsConfig = new AnimationMixerUpdateJsParamsConfig();
class AnimationMixerUpdateJsNode extends js_Base/* TypedJsNode */.xZ {
  constructor() {
    super(...arguments);
    this.paramsConfig = AnimationMixerUpdate_ParamsConfig;
  }
  static type() {
    return Js/* JsType.ANIMATION_MIXER_UPDATE */.K.ANIMATION_MIXER_UPDATE;
  }
  initializeNode() {
    this.io.inputs.setNamedInputConnectionPoints([
      new connections_Js/* JsConnectionPoint */.fp(connections_Js/* JsConnectionPointType.TRIGGER */.zF.TRIGGER, connections_Js/* JsConnectionPointType.TRIGGER */.zF.TRIGGER, AnimationMixerUpdate_CONNECTION_OPTIONS),
      new connections_Js/* JsConnectionPoint */.fp(
        connections_Js/* JsConnectionPointType.ANIMATION_MIXER */.zF.ANIMATION_MIXER,
        connections_Js/* JsConnectionPointType.ANIMATION_MIXER */.zF.ANIMATION_MIXER,
        AnimationMixerUpdate_CONNECTION_OPTIONS
      )
    ]);
  }
  setTriggerableLines(shadersCollectionController) {
    const object3D = (0,_BaseObject3D/* inputObject3D */.iv)(this, shadersCollectionController);
    const func = Poly/* Poly.namedFunctionsRegister.getFunction */.L.namedFunctionsRegister.getFunction("animationMixerUpdate", this, shadersCollectionController);
    const bodyLine = func.asString(object3D);
    shadersCollectionController.addTriggerableLines(this, [bodyLine]);
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/js/AnyTrigger.ts




class AnyTriggerJsParamsConfig extends params_ParamsConfig/* NodeParamsConfig */.yI {
  constructor() {
    super(...arguments);
    /** @param audio node */
    this.condition = params_ParamsConfig/* ParamConfig.BOOLEAN */.XC.BOOLEAN(1);
  }
}
const AnyTrigger_ParamsConfig = new AnyTriggerJsParamsConfig();
class AnyTriggerJsNode extends js_Base/* TypedJsNode */.xZ {
  constructor() {
    super(...arguments);
    this.paramsConfig = AnyTrigger_ParamsConfig;
  }
  static type() {
    return "anyTrigger";
  }
  initializeNode() {
    super.initializeNode();
    this.io.connection_points.set_expected_input_types_function(this._expectedInputTypes.bind(this));
    this.io.connection_points.set_expected_output_types_function(this._expectedOutputTypes.bind(this));
    this.io.connection_points.set_input_name_function(this._expectedInputName.bind(this));
    this.io.connection_points.set_output_name_function(this._expectedOutputName.bind(this));
  }
  _expectedInputTypes() {
    const current_connections = this.io.connections.existingInputConnections();
    const expected_count = current_connections ? Math.max(current_connections.length + 1, 2) : 2;
    return new Array(expected_count).fill(connections_Js/* JsConnectionPointType.TRIGGER */.zF.TRIGGER);
  }
  _expectedOutputTypes() {
    return [connections_Js/* JsConnectionPointType.TRIGGER */.zF.TRIGGER];
  }
  _expectedInputName(index) {
    return `${connections_Js/* JsConnectionPointType.TRIGGER */.zF.TRIGGER}${index}`;
  }
  _expectedOutputName(index) {
    return connections_Js/* JsConnectionPointType.TRIGGER */.zF.TRIGGER;
  }
  setTriggerableLines(shadersCollectionController) {
    shadersCollectionController.addTriggerableLines(this, []);
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/js/_BaseArrayToElement.ts




const ALLOWED_INPUT_TYPES = connections_Js/* ARRAY_JS_CONNECTION_TYPES_SET */.vm;
class BaseArrayElementJsNode extends js_Base/* TypedJsNode */.xZ {
  initializeNode() {
    super.initializeNode();
    this.io.connection_points.set_expected_input_types_function(this._expectedInputTypes.bind(this));
    this.io.connection_points.set_expected_output_types_function(this._expectedOutputTypes.bind(this));
    this.io.connection_points.set_input_name_function(this._expectedInputName.bind(this));
    this.io.connection_points.set_output_name_function(this._expectedOutputName.bind(this));
  }
  _expectedInputTypes() {
    const firstType = this.io.connection_points.first_input_connection_type();
    const type = firstType != null && ALLOWED_INPUT_TYPES.has(firstType) ? firstType : connections_Js/* JsConnectionPointType.FLOAT_ARRAY */.zF.FLOAT_ARRAY;
    return [type];
  }
  _expectedInputName(index) {
    const type = this._expectedInputTypes()[0];
    return [`${type}`][index];
  }
  _expectedOutputName(index) {
    const type = this._expectedOutputTypes()[0];
    return `${type}`;
  }
  _expectedOutputTypes() {
    const firstType = this._expectedInputTypes()[0];
    const outputType = connections_Js/* JsConnectionPointTypeFromArrayTypeMap */.RR[firstType] || connections_Js/* JsConnectionPointType.FLOAT */.zF.FLOAT;
    return [outputType];
  }
  setLines(linesController) {
    const firstType = this._expectedInputTypes()[0];
    switch (firstType) {
      case connections_Js/* JsConnectionPointType.BOOLEAN_ARRAY */.zF.BOOLEAN_ARRAY:
      case connections_Js/* JsConnectionPointType.FLOAT_ARRAY */.zF.FLOAT_ARRAY:
      case connections_Js/* JsConnectionPointType.INT_ARRAY */.zF.INT_ARRAY:
      case connections_Js/* JsConnectionPointType.STRING_ARRAY */.zF.STRING_ARRAY: {
        return this._setLinesAsPrimitive(linesController);
      }
      case connections_Js/* JsConnectionPointType.COLOR_ARRAY */.zF.COLOR_ARRAY:
      case connections_Js/* JsConnectionPointType.MATRIX4_ARRAY */.zF.MATRIX4_ARRAY:
      case connections_Js/* JsConnectionPointType.QUATERNION_ARRAY */.zF.QUATERNION_ARRAY:
      case connections_Js/* JsConnectionPointType.VECTOR2_ARRAY */.zF.VECTOR2_ARRAY:
      case connections_Js/* JsConnectionPointType.VECTOR3_ARRAY */.zF.VECTOR3_ARRAY:
      case connections_Js/* JsConnectionPointType.VECTOR4_ARRAY */.zF.VECTOR4_ARRAY: {
        return this._setLinesAsVector(linesController);
      }
      case connections_Js/* JsConnectionPointType.OBJECT_3D_ARRAY */.zF.OBJECT_3D_ARRAY: {
        return this._setLinesAsPrimitive(linesController);
      }
      case connections_Js/* JsConnectionPointType.INTERSECTION_ARRAY */.zF.INTERSECTION_ARRAY: {
        return this._setLinesAsPrimitive(linesController);
      }
      case connections_Js/* JsConnectionPointType.TEXTURE_ARRAY */.zF.TEXTURE_ARRAY: {
        return this._setLinesAsPrimitive(linesController);
      }
    }
    Assert/* TypeAssert.unreachable */.f.unreachable(firstType);
  }
  _setLinesAsPrimitive(linesController) {
  }
  _setLinesAsVector(linesController) {
  }
  // private _setLinesAsObject(linesController: JsLinesCollectionController) {
  // 	console.warn('not implemented');
  // }
  // private _setLinesAsIntersection(linesController: JsLinesCollectionController) {
  // 	console.warn('not implemented');
  // }
  // private _setLinesAsTexture(linesController: JsLinesCollectionController) {
  // 	console.warn('not implemented');
  // }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/js/ArrayElement.ts






var IndexInput = /* @__PURE__ */ ((IndexInput2) => {
  IndexInput2["index"] = "index";
  return IndexInput2;
})(IndexInput || {});
class ArrayElementJsParamsConfig extends params_ParamsConfig/* NodeParamsConfig */.yI {
  constructor() {
    super(...arguments);
    this.index = params_ParamsConfig/* ParamConfig.INTEGER */.XC.INTEGER(0, {
      range: [0, 9],
      rangeLocked: [true, false]
    });
  }
}
const ArrayElement_ParamsConfig = new ArrayElementJsParamsConfig();
class ArrayElementJsNode extends BaseArrayElementJsNode {
  constructor() {
    super(...arguments);
    this.paramsConfig = ArrayElement_ParamsConfig;
  }
  static type() {
    return "arrayElement";
  }
  _expectedInputTypes() {
    const firstType = this.io.connection_points.first_input_connection_type();
    const type = firstType != null && ALLOWED_INPUT_TYPES.has(firstType) ? firstType : connections_Js/* JsConnectionPointType.FLOAT_ARRAY */.zF.FLOAT_ARRAY;
    return [type, connections_Js/* JsConnectionPointType.INT */.zF.INT];
  }
  _expectedInputName(index) {
    const type = this._expectedInputTypes()[0];
    return [`${type}`, "index" /* index */][index];
  }
  _setLinesAsPrimitive(linesController) {
    const array = this.variableForInput(linesController, this._expectedInputName(0));
    const index = this.variableForInputParam(linesController, this.p.index);
    const dataType = this._expectedInputTypes()[0];
    const varName = this.jsVarName(this._expectedOutputName(0));
    const func = Poly/* Poly.namedFunctionsRegister.getFunction */.L.namedFunctionsRegister.getFunction("arrayElementPrimitive", this, linesController);
    linesController.addBodyOrComputed(this, [
      {
        dataType,
        varName,
        value: func.asString(array, index)
      }
    ]);
  }
  _setLinesAsVector(linesController) {
    const array = this.variableForInput(linesController, this._expectedInputName(0));
    const index = this.variableForInputParam(linesController, this.p.index);
    const dataType = this._expectedInputTypes()[0];
    const varName = this.jsVarName(this._expectedOutputName(0));
    const elementType = connections_Js/* JsConnectionPointTypeFromArrayTypeMap */.RR[dataType];
    const tmpVarName = linesController.addVariable(this, (0,_BaseJsPersistedConfigUtils/* createVariable */.Os)(elementType));
    const func = Poly/* Poly.namedFunctionsRegister.getFunction */.L.namedFunctionsRegister.getFunction("arrayElementVector", this, linesController);
    linesController.addBodyOrComputed(this, [
      {
        dataType,
        varName,
        value: func.asString(array, index, tmpVarName)
      }
    ]);
  }
  // private _setLinesAsObject(linesController: JsLinesCollectionController) {
  // 	console.warn('not implemented');
  // }
  // private _setLinesAsIntersection(linesController: JsLinesCollectionController) {
  // 	console.warn('not implemented');
  // }
  // private _setLinesAsTexture(linesController: JsLinesCollectionController) {
  // 	console.warn('not implemented');
  // }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/js/ArrayLength.ts





const ArrayLength_ALLOWED_INPUT_TYPES = connections_Js/* ARRAY_JS_CONNECTION_TYPES_SET */.vm;
class ArrayLengthJsParamsConfig extends params_ParamsConfig/* NodeParamsConfig */.yI {
}
const ArrayLength_ParamsConfig = new ArrayLengthJsParamsConfig();
class ArrayLengthJsNode extends js_Base/* TypedJsNode */.xZ {
  constructor() {
    super(...arguments);
    this.paramsConfig = ArrayLength_ParamsConfig;
  }
  static type() {
    return "arrayLength";
  }
  initializeNode() {
    super.initializeNode();
    this.io.connection_points.set_expected_input_types_function(this._expectedInputTypes.bind(this));
    this.io.connection_points.set_expected_output_types_function(this._expectedOutputTypes.bind(this));
    this.io.connection_points.set_input_name_function(this._expectedInputName.bind(this));
    this.io.connection_points.set_output_name_function(this._expectedOutputName.bind(this));
  }
  _expectedInputTypes() {
    const firstType = this.io.connection_points.first_input_connection_type();
    const type = firstType != null && ArrayLength_ALLOWED_INPUT_TYPES.has(firstType) ? firstType : connections_Js/* JsConnectionPointType.FLOAT_ARRAY */.zF.FLOAT_ARRAY;
    return [type];
  }
  _expectedInputName(index) {
    const type = this._expectedInputTypes()[0];
    return `${type}`;
  }
  _expectedOutputName(index) {
    return `length`;
  }
  _expectedOutputTypes() {
    return [connections_Js/* JsConnectionPointType.INT */.zF.INT];
  }
  setLines(shadersCollectionController) {
    const array = this.variableForInput(shadersCollectionController, this._expectedInputName(0));
    const dataType = this._expectedInputTypes()[0];
    const varName = this.jsVarName(this._expectedOutputName(0));
    const func = Poly/* Poly.namedFunctionsRegister.getFunction */.L.namedFunctionsRegister.getFunction("arrayLength", this, shadersCollectionController);
    shadersCollectionController.addBodyOrComputed(this, [
      {
        dataType,
        varName,
        value: func.asString(array)
      }
    ]);
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/js/ArrayPop.ts






class ArrayPopJsParamsConfig extends params_ParamsConfig/* NodeParamsConfig */.yI {
}
const ArrayPop_ParamsConfig = new ArrayPopJsParamsConfig();
class ArrayPopJsNode extends BaseArrayElementJsNode {
  constructor() {
    super(...arguments);
    this.paramsConfig = ArrayPop_ParamsConfig;
  }
  static type() {
    return "arrayPop";
  }
  _setLinesAsPrimitive(linesController) {
    const array = this.variableForInput(linesController, this._expectedInputName(0));
    const dataType = this._expectedInputTypes()[0];
    const varName = this.jsVarName(this._expectedOutputName(0));
    const func = Poly/* Poly.namedFunctionsRegister.getFunction */.L.namedFunctionsRegister.getFunction("arrayPopPrimitive", this, linesController);
    linesController.addBodyOrComputed(this, [
      {
        dataType,
        varName,
        value: func.asString(array)
      }
    ]);
  }
  _setLinesAsVector(linesController) {
    const array = this.variableForInput(linesController, this._expectedInputName(0));
    const dataType = this._expectedInputTypes()[0];
    const varName = this.jsVarName(this._expectedOutputName(0));
    const elementType = connections_Js/* JsConnectionPointTypeFromArrayTypeMap */.RR[dataType];
    const tmpVarName = linesController.addVariable(this, (0,_BaseJsPersistedConfigUtils/* createVariable */.Os)(elementType));
    const func = Poly/* Poly.namedFunctionsRegister.getFunction */.L.namedFunctionsRegister.getFunction("arrayPopVector", this, linesController);
    linesController.addBodyOrComputed(this, [
      {
        dataType,
        varName,
        value: func.asString(array, tmpVarName)
      }
    ]);
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/js/ArrayShift.ts






class ArrayShiftJsParamsConfig extends params_ParamsConfig/* NodeParamsConfig */.yI {
}
const ArrayShift_ParamsConfig = new ArrayShiftJsParamsConfig();
class ArrayShiftJsNode extends BaseArrayElementJsNode {
  constructor() {
    super(...arguments);
    this.paramsConfig = ArrayShift_ParamsConfig;
  }
  static type() {
    return "arrayShift";
  }
  _setLinesAsPrimitive(linesController) {
    const array = this.variableForInput(linesController, this._expectedInputName(0));
    const dataType = this._expectedInputTypes()[0];
    const varName = this.jsVarName(this._expectedOutputName(0));
    const func = Poly/* Poly.namedFunctionsRegister.getFunction */.L.namedFunctionsRegister.getFunction("arrayShiftPrimitive", this, linesController);
    linesController.addBodyOrComputed(this, [
      {
        dataType,
        varName,
        value: func.asString(array)
      }
    ]);
  }
  _setLinesAsVector(linesController) {
    const array = this.variableForInput(linesController, this._expectedInputName(0));
    const dataType = this._expectedInputTypes()[0];
    const varName = this.jsVarName(this._expectedOutputName(0));
    const elementType = connections_Js/* JsConnectionPointTypeFromArrayTypeMap */.RR[dataType];
    const tmpVarName = linesController.addVariable(this, (0,_BaseJsPersistedConfigUtils/* createVariable */.Os)(elementType));
    const func = Poly/* Poly.namedFunctionsRegister.getFunction */.L.namedFunctionsRegister.getFunction("arrayShiftVector", this, linesController);
    linesController.addBodyOrComputed(this, [
      {
        dataType,
        varName,
        value: func.asString(array, tmpVarName)
      }
    ]);
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/js/Asin.ts


class AsinJsNode extends MathFunctionArg1OperationFactory("asin", {
  inputPrefix: "val",
  out: "asin"
}) {
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/js/Atan.ts


class AtanJsNode extends MathFunctionArg1OperationFactory("atan", {
  inputPrefix: "val",
  out: "atan"
}) {
}

// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/nodes/js/Attribute.ts
var js_Attribute = __webpack_require__(6145);
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/js/_ConversionPrimitives.ts





class IntToBoolJsParamsConfig extends params_ParamsConfig/* NodeParamsConfig */.yI {
  constructor() {
    super(...arguments);
    this.int = params_ParamsConfig/* ParamConfig.INTEGER */.XC.INTEGER(0);
  }
}
const ParamsConfig_IntToBool = new IntToBoolJsParamsConfig();
class IntToBoolJsNode extends js_Base/* TypedJsNode */.xZ {
  constructor() {
    super(...arguments);
    this.paramsConfig = ParamsConfig_IntToBool;
  }
  static type() {
    return "intToBool";
  }
  initializeNode() {
    this.io.outputs.setNamedOutputConnectionPoints([
      new connections_Js/* JsConnectionPoint */.fp(connections_Js/* JsConnectionPointType.BOOLEAN */.zF.BOOLEAN, connections_Js/* JsConnectionPointType.BOOLEAN */.zF.BOOLEAN)
    ]);
  }
  setLines(shadersCollectionController) {
    const arg0 = this.variableForInputParam(shadersCollectionController, this.p.int);
    const varName = this.jsVarName(connections_Js/* JsConnectionPointType.BOOLEAN */.zF.BOOLEAN);
    const func = Poly/* Poly.namedFunctionsRegister.getFunction */.L.namedFunctionsRegister.getFunction("intToBool", this, shadersCollectionController);
    shadersCollectionController.addBodyOrComputed(this, [
      { dataType: connections_Js/* JsConnectionPointType.VECTOR3 */.zF.VECTOR3, varName, value: func.asString(arg0) }
    ]);
  }
}
class BoolToIntJsParamsConfig extends params_ParamsConfig/* NodeParamsConfig */.yI {
  constructor() {
    super(...arguments);
    this.bool = params_ParamsConfig/* ParamConfig.INTEGER */.XC.INTEGER(0);
  }
}
const ParamsConfig_BoolToInt = new BoolToIntJsParamsConfig();
class BoolToIntJsNode extends js_Base/* TypedJsNode */.xZ {
  constructor() {
    super(...arguments);
    this.paramsConfig = ParamsConfig_BoolToInt;
  }
  static type() {
    return "boolToInt";
  }
  initializeNode() {
    this.io.outputs.setNamedOutputConnectionPoints([
      new connections_Js/* JsConnectionPoint */.fp(connections_Js/* JsConnectionPointType.INT */.zF.INT, connections_Js/* JsConnectionPointType.INT */.zF.INT)
    ]);
  }
  setLines(shadersCollectionController) {
    const arg0 = this.variableForInputParam(shadersCollectionController, this.p.bool);
    const varName = this.jsVarName(connections_Js/* JsConnectionPointType.INT */.zF.INT);
    const func = Poly/* Poly.namedFunctionsRegister.getFunction */.L.namedFunctionsRegister.getFunction("boolToInt", this, shadersCollectionController);
    shadersCollectionController.addBodyOrComputed(this, [
      { dataType: connections_Js/* JsConnectionPointType.VECTOR3 */.zF.VECTOR3, varName, value: func.asString(arg0) }
    ]);
  }
}
class IntToFloatJsParamsConfig extends params_ParamsConfig/* NodeParamsConfig */.yI {
  constructor() {
    super(...arguments);
    this.int = params_ParamsConfig/* ParamConfig.INTEGER */.XC.INTEGER(0);
  }
}
const ParamsConfig_IntToFloat = new IntToFloatJsParamsConfig();
class IntToFloatJsNode extends js_Base/* TypedJsNode */.xZ {
  constructor() {
    super(...arguments);
    this.paramsConfig = ParamsConfig_IntToFloat;
  }
  static type() {
    return "intToFloat";
  }
  initializeNode() {
    this.io.outputs.setNamedOutputConnectionPoints([
      new connections_Js/* JsConnectionPoint */.fp(connections_Js/* JsConnectionPointType.FLOAT */.zF.FLOAT, connections_Js/* JsConnectionPointType.FLOAT */.zF.FLOAT)
    ]);
  }
  setLines(shadersCollectionController) {
    const arg0 = this.variableForInputParam(shadersCollectionController, this.p.int);
    const varName = this.jsVarName(connections_Js/* JsConnectionPointType.FLOAT */.zF.FLOAT);
    const func = Poly/* Poly.namedFunctionsRegister.getFunction */.L.namedFunctionsRegister.getFunction("intToFloat", this, shadersCollectionController);
    shadersCollectionController.addBodyOrComputed(this, [
      { dataType: connections_Js/* JsConnectionPointType.VECTOR3 */.zF.VECTOR3, varName, value: func.asString(arg0) }
    ]);
  }
}
class FloatToIntJsParamsConfig extends params_ParamsConfig/* NodeParamsConfig */.yI {
  constructor() {
    super(...arguments);
    this.float = params_ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(0);
  }
}
const ParamsConfig_FloatToInt = new FloatToIntJsParamsConfig();
class FloatToIntJsNode extends js_Base/* TypedJsNode */.xZ {
  constructor() {
    super(...arguments);
    this.paramsConfig = ParamsConfig_FloatToInt;
  }
  static type() {
    return "floatToInt";
  }
  initializeNode() {
    this.io.outputs.setNamedOutputConnectionPoints([
      new connections_Js/* JsConnectionPoint */.fp(connections_Js/* JsConnectionPointType.INT */.zF.INT, connections_Js/* JsConnectionPointType.INT */.zF.INT)
    ]);
  }
  setLines(shadersCollectionController) {
    const arg0 = this.variableForInputParam(shadersCollectionController, this.p.float);
    const varName = this.jsVarName(connections_Js/* JsConnectionPointType.INT */.zF.INT);
    const func = Poly/* Poly.namedFunctionsRegister.getFunction */.L.namedFunctionsRegister.getFunction("floatToInt", this, shadersCollectionController);
    shadersCollectionController.addBodyOrComputed(this, [
      { dataType: connections_Js/* JsConnectionPointType.VECTOR3 */.zF.VECTOR3, varName, value: func.asString(arg0) }
    ]);
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/js/Box3.ts






const Box3_CONNECTION_OPTIONS = connections_Js/* JS_CONNECTION_POINT_IN_NODE_DEF */.mX;
class Box3JsParamsConfig extends params_ParamsConfig/* NodeParamsConfig */.yI {
  constructor() {
    super(...arguments);
    /** @param position representing the lower bound of the box */
    this.min = params_ParamsConfig/* ParamConfig.VECTOR3 */.XC.VECTOR3([-1, -1, -1]);
    /** @param position representing the upper bound of the box */
    this.max = params_ParamsConfig/* ParamConfig.VECTOR3 */.XC.VECTOR3([1, 1, 1]);
  }
}
const Box3_ParamsConfig = new Box3JsParamsConfig();
class Box3JsNode extends js_Base/* TypedJsNode */.xZ {
  constructor() {
    super(...arguments);
    this.paramsConfig = Box3_ParamsConfig;
  }
  static type() {
    return "box3";
  }
  initializeNode() {
    this.io.outputs.setNamedOutputConnectionPoints([
      new connections_Js/* JsConnectionPoint */.fp(connections_Js/* JsConnectionPointType.BOX3 */.zF.BOX3, connections_Js/* JsConnectionPointType.BOX3 */.zF.BOX3, Box3_CONNECTION_OPTIONS)
    ]);
  }
  setLines(shadersCollectionController) {
    const min = this.variableForInputParam(shadersCollectionController, this.p.min);
    const max = this.variableForInputParam(shadersCollectionController, this.p.max);
    const out = this.jsVarName(connections_Js/* JsConnectionPointType.BOX3 */.zF.BOX3);
    const tmpVarName = shadersCollectionController.addVariable(this, new three_module.Box3());
    const func = Poly/* Poly.namedFunctionsRegister.getFunction */.L.namedFunctionsRegister.getFunction("box3Set", this, shadersCollectionController);
    const bodyLine = func.asString(min, max, tmpVarName);
    shadersCollectionController.addBodyOrComputed(this, [
      { dataType: connections_Js/* JsConnectionPointType.PLANE */.zF.PLANE, varName: out, value: bodyLine }
    ]);
  }
  // override initializeNode() {
  // 	super.initializeNode();
  // 	this.io.connection_points.initializeNode();
  // 	// this.io.connection_points.set_input_name_function(this._expectedInputName.bind(this));
  // 	this.io.connection_points.set_output_name_function((index: number) => OUTPUT_NAME);
  // 	this.io.connection_points.set_expected_input_types_function(() => []);
  // 	this.io.connection_points.set_expected_output_types_function(() => [ActorConnectionPointType.BOX3]);
  // }
  // private _box3 = new Box3();
  // private _box3Updated = false;
  // public override outputValue(context: ActorNodeTriggerContext) {
  // 	if (!this._box3Updated) {
  // 		this._updateBox3();
  // 		this._box3Updated = true;
  // 	}
  // 	return this._box3;
  // }
  // static PARAM_CALLBACK_updateBox3(node: Box3ActorNode) {
  // 	node._updateBox3();
  // }
  // private _updateBox3() {
  // 	this._box3.min.copy(this.pv.min);
  // 	this._box3.max.copy(this.pv.max);
  // }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/js/Box3ContainsPoint.ts





const Box3ContainsPoint_CONNECTION_OPTIONS = connections_Js/* JS_CONNECTION_POINT_IN_NODE_DEF */.mX;
var Box3ContainsPointOutputName = /* @__PURE__ */ ((Box3ContainsPointOutputName2) => {
  Box3ContainsPointOutputName2["CONTAINS"] = "contains";
  return Box3ContainsPointOutputName2;
})(Box3ContainsPointOutputName || {});
class Box3ContainsPointJsParamsConfig extends params_ParamsConfig/* NodeParamsConfig */.yI {
  constructor() {
    super(...arguments);
    this.position = params_ParamsConfig/* ParamConfig.VECTOR3 */.XC.VECTOR3([0, 0, 0]);
  }
}
const Box3ContainsPoint_ParamsConfig = new Box3ContainsPointJsParamsConfig();
class Box3ContainsPointJsNode extends js_Base/* TypedJsNode */.xZ {
  constructor() {
    super(...arguments);
    this.paramsConfig = Box3ContainsPoint_ParamsConfig;
  }
  static type() {
    return "box3ContainsPoint";
  }
  initializeNode() {
    this.io.inputs.setNamedInputConnectionPoints([
      new connections_Js/* JsConnectionPoint */.fp(connections_Js/* JsConnectionPointType.BOX3 */.zF.BOX3, connections_Js/* JsConnectionPointType.BOX3 */.zF.BOX3, Box3ContainsPoint_CONNECTION_OPTIONS)
      // new JsConnectionPoint(JsConnectionPointType.VECTOR3, JsConnectionPointType.VECTOR3, CONNECTION_OPTIONS),
    ]);
    this.io.outputs.setNamedOutputConnectionPoints([
      new connections_Js/* JsConnectionPoint */.fp(
        "contains" /* CONTAINS */,
        connections_Js/* JsConnectionPointType.BOOLEAN */.zF.BOOLEAN,
        Box3ContainsPoint_CONNECTION_OPTIONS
      )
    ]);
  }
  setLines(linesController) {
    const box3 = this.variableForInput(linesController, connections_Js/* JsConnectionPointType.BOX3 */.zF.BOX3);
    const position = this.variableForInputParam(linesController, this.p.position);
    const out = this.jsVarName("contains" /* CONTAINS */);
    const func = Poly/* Poly.namedFunctionsRegister.getFunction */.L.namedFunctionsRegister.getFunction("box3ContainsPoint", this, linesController);
    const bodyLine = func.asString(box3, position);
    linesController.addBodyOrComputed(this, [
      { dataType: connections_Js/* JsConnectionPointType.PLANE */.zF.PLANE, varName: out, value: bodyLine }
    ]);
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/js/Box3IntersectsBox3.ts





const Box3IntersectsBox3_CONNECTION_OPTIONS = connections_Js/* JS_CONNECTION_POINT_IN_NODE_DEF */.mX;
var Box3IntersectsBox3InputName = /* @__PURE__ */ ((Box3IntersectsBox3InputName2) => {
  Box3IntersectsBox3InputName2["BOX3a"] = "Box3a";
  Box3IntersectsBox3InputName2["BOX3b"] = "Box3b";
  return Box3IntersectsBox3InputName2;
})(Box3IntersectsBox3InputName || {});
var Box3IntersectsBox3OutputName = /* @__PURE__ */ ((Box3IntersectsBox3OutputName2) => {
  Box3IntersectsBox3OutputName2["INTERSECTS"] = "intersects";
  return Box3IntersectsBox3OutputName2;
})(Box3IntersectsBox3OutputName || {});
class Box3IntersectsBox3JsParamsConfig extends params_ParamsConfig/* NodeParamsConfig */.yI {
}
const Box3IntersectsBox3_ParamsConfig = new Box3IntersectsBox3JsParamsConfig();
class Box3IntersectsBox3JsNode extends js_Base/* TypedJsNode */.xZ {
  constructor() {
    super(...arguments);
    this.paramsConfig = Box3IntersectsBox3_ParamsConfig;
  }
  static type() {
    return "box3IntersectsBox3";
  }
  initializeNode() {
    this.io.inputs.setNamedInputConnectionPoints([
      new connections_Js/* JsConnectionPoint */.fp("Box3a" /* BOX3a */, connections_Js/* JsConnectionPointType.BOX3 */.zF.BOX3, Box3IntersectsBox3_CONNECTION_OPTIONS),
      new connections_Js/* JsConnectionPoint */.fp("Box3b" /* BOX3b */, connections_Js/* JsConnectionPointType.BOX3 */.zF.BOX3, Box3IntersectsBox3_CONNECTION_OPTIONS)
    ]);
    this.io.outputs.setNamedOutputConnectionPoints([
      new connections_Js/* JsConnectionPoint */.fp(
        "intersects" /* INTERSECTS */,
        connections_Js/* JsConnectionPointType.BOOLEAN */.zF.BOOLEAN,
        Box3IntersectsBox3_CONNECTION_OPTIONS
      )
    ]);
  }
  setLines(linesController) {
    const box3a = this.variableForInput(linesController, "Box3a" /* BOX3a */);
    const box3b = this.variableForInput(linesController, "Box3b" /* BOX3b */);
    const out = this.jsVarName("intersects" /* INTERSECTS */);
    const func = Poly/* Poly.namedFunctionsRegister.getFunction */.L.namedFunctionsRegister.getFunction("box3IntersectsBox3", this, linesController);
    const bodyLine = func.asString(box3a, box3b);
    linesController.addBodyOrComputed(this, [
      { dataType: connections_Js/* JsConnectionPointType.PLANE */.zF.PLANE, varName: out, value: bodyLine }
    ]);
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/js/Box3SetFromObject.ts







const Box3SetFromObject_CONNECTION_OPTIONS = connections_Js/* JS_CONNECTION_POINT_IN_NODE_DEF */.mX;
class Box3SetFromObjectJsParamsConfig extends params_ParamsConfig/* NodeParamsConfig */.yI {
  constructor() {
    super(...arguments);
    /** @param precise */
    this.precise = params_ParamsConfig/* ParamConfig.BOOLEAN */.XC.BOOLEAN(false);
  }
}
const Box3SetFromObject_ParamsConfig = new Box3SetFromObjectJsParamsConfig();
class Box3SetFromObjectJsNode extends js_Base/* TypedJsNode */.xZ {
  constructor() {
    super(...arguments);
    this.paramsConfig = Box3SetFromObject_ParamsConfig;
  }
  static type() {
    return "box3SetFromObject";
  }
  initializeNode() {
    this.io.inputs.setNamedInputConnectionPoints([
      new connections_Js/* JsConnectionPoint */.fp(connections_Js/* JsConnectionPointType.OBJECT_3D */.zF.OBJECT_3D, connections_Js/* JsConnectionPointType.OBJECT_3D */.zF.OBJECT_3D, Box3SetFromObject_CONNECTION_OPTIONS)
    ]);
    this.io.outputs.setNamedOutputConnectionPoints([
      new connections_Js/* JsConnectionPoint */.fp(connections_Js/* JsConnectionPointType.BOX3 */.zF.BOX3, connections_Js/* JsConnectionPointType.BOX3 */.zF.BOX3, Box3SetFromObject_CONNECTION_OPTIONS)
    ]);
  }
  setLines(linesController) {
    const object3D = (0,_BaseObject3D/* inputObject3D */.iv)(this, linesController);
    const precise = this.variableForInputParam(linesController, this.p.precise);
    const out = this.jsVarName(connections_Js/* JsConnectionPointType.BOX3 */.zF.BOX3);
    const tmpVarName = linesController.addVariable(this, new three_module.Box3());
    const func = Poly/* Poly.namedFunctionsRegister.getFunction */.L.namedFunctionsRegister.getFunction("box3SetFromObject", this, linesController);
    const bodyLine = func.asString(object3D, precise, tmpVarName);
    linesController.addBodyOrComputed(this, [
      { dataType: connections_Js/* JsConnectionPointType.PLANE */.zF.PLANE, varName: out, value: bodyLine }
    ]);
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/js/CatmullRomCurve3GetPoint.ts






const CatmullRomCurve3GetPoint_CONNECTION_OPTIONS = connections_Js/* JS_CONNECTION_POINT_IN_NODE_DEF */.mX;
const T_NAME = "t";
const CatmullRomCurve3GetPoint_OUTPUT_NAME = "position";
class CatmullRomCurve3GetPointJsParamsConfig extends params_ParamsConfig/* NodeParamsConfig */.yI {
  constructor() {
    super(...arguments);
    this.t = params_ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(0, {
      range: [0, 1],
      rangeLocked: [true, true]
    });
  }
}
const CatmullRomCurve3GetPoint_ParamsConfig = new CatmullRomCurve3GetPointJsParamsConfig();
class CatmullRomCurve3GetPointJsNode extends js_Base/* TypedJsNode */.xZ {
  constructor() {
    super(...arguments);
    this.paramsConfig = CatmullRomCurve3GetPoint_ParamsConfig;
  }
  static type() {
    return "catmullRomCurve3GetPoint";
  }
  initializeNode() {
    this.io.inputs.setNamedInputConnectionPoints([
      new connections_Js/* JsConnectionPoint */.fp(
        connections_Js/* JsConnectionPointType.CATMULL_ROM_CURVE3 */.zF.CATMULL_ROM_CURVE3,
        connections_Js/* JsConnectionPointType.CATMULL_ROM_CURVE3 */.zF.CATMULL_ROM_CURVE3,
        CatmullRomCurve3GetPoint_CONNECTION_OPTIONS
      ),
      new connections_Js/* JsConnectionPoint */.fp(T_NAME, connections_Js/* JsConnectionPointType.FLOAT */.zF.FLOAT, CatmullRomCurve3GetPoint_CONNECTION_OPTIONS)
    ]);
    this.io.outputs.setNamedOutputConnectionPoints([
      new connections_Js/* JsConnectionPoint */.fp(CatmullRomCurve3GetPoint_OUTPUT_NAME, connections_Js/* JsConnectionPointType.VECTOR3 */.zF.VECTOR3)
    ]);
  }
  setLines(shadersCollectionController) {
    const inputCurve = this.variableForInput(shadersCollectionController, connections_Js/* JsConnectionPointType.CATMULL_ROM_CURVE3 */.zF.CATMULL_ROM_CURVE3);
    const t = this.variableForInputParam(shadersCollectionController, this.p.t);
    const varName = this.jsVarName(CatmullRomCurve3GetPoint_OUTPUT_NAME);
    const tmpVarName = shadersCollectionController.addVariable(this, new three_module.Vector3());
    const func = Poly/* Poly.namedFunctionsRegister.getFunction */.L.namedFunctionsRegister.getFunction(
      "catmullRomCurve3GetPoint",
      this,
      shadersCollectionController
    );
    shadersCollectionController.addBodyOrComputed(this, [
      {
        dataType: connections_Js/* JsConnectionPointType.VECTOR3 */.zF.VECTOR3,
        varName,
        value: func.asString(inputCurve, t, tmpVarName)
      }
    ]);
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/js/Ceil.ts


class CeilJsNode extends MathFunctionArg1OperationFactory("ceil", {
  inputPrefix: "val",
  out: "ceil"
}) {
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/js/Clamp.ts




var ClampInput = /* @__PURE__ */ ((ClampInput2) => {
  ClampInput2["val"] = "val";
  ClampInput2["min"] = "min";
  ClampInput2["max"] = "max";
  return ClampInput2;
})(ClampInput || {});
const Clamp_DefaultValues = {
  ["val" /* val */]: 0,
  ["min" /* min */]: 0,
  ["max" /* max */]: 1
};
const FUNCTION_NAME = "clamp";
class ClampJsNode extends MathFunctionArg3OperationFactory("clamp", {
  inputPrefix: "in",
  out: "clamped"
}) {
  _coreFunction(shadersCollectionController) {
    Poly/* Poly.namedFunctionsRegister.getFunction */.L.namedFunctionsRegister.getFunction(FUNCTION_NAME, this, shadersCollectionController).asString("", "", "");
    return FUNCTION_NAME;
  }
  paramDefaultValue(name) {
    return Clamp_DefaultValues[name];
  }
  _expectedInputName(index) {
    return ["val" /* val */, "min" /* min */, "max" /* max */][index];
  }
  _expectedInputTypes() {
    let first_input_type = this.io.connection_points.first_input_connection_type();
    const connectionPoints = this.io.inputs.namedInputConnectionPoints();
    if (first_input_type && connectionPoints) {
      if (!DEFAULT_ALLOWED_TYPES.includes(first_input_type)) {
        const first_connection = connectionPoints[0];
        if (first_connection) {
          first_input_type = first_connection.type();
        }
      }
    }
    const type = first_input_type || connections_Js/* JsConnectionPointType.FLOAT */.zF.FLOAT;
    const boundType = connections_Js/* JsConnectionPointTypeFromArrayTypeMap */.RR[type];
    return [type, boundType, boundType];
  }
}

// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/nodes/js/_BaseTriggerAndObject.ts
var _BaseTriggerAndObject = __webpack_require__(49846);
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/js/ClothSolverReset.ts




class ClothSolverResetJsNode extends _BaseTriggerAndObject/* ParamlessBaseTriggerAndObjectJsNode */.c {
  static type() {
    return "clothSolverReset";
  }
  setTriggerableLines(shadersCollectionController) {
    const object3D = (0,_BaseObject3D/* inputObject3D */.iv)(this, shadersCollectionController);
    const func = Poly/* Poly.namedFunctionsRegister.getFunction */.L.namedFunctionsRegister.getFunction("clothSolverReset", this, shadersCollectionController);
    const bodyLine = func.asString(object3D);
    shadersCollectionController.addTriggerableLines(this, [bodyLine]);
  }
}

// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/nodes/js/ClothSolverStepSimulation.ts
var ClothSolverStepSimulation = __webpack_require__(43284);
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/js/ClothSolverUpdateMaterial.ts








const ClothSolverUpdateMaterial_CONNECTION_OPTIONS = connections_Js/* JS_CONNECTION_POINT_IN_NODE_DEF */.mX;
class ClothSolverUpdateMaterialJsParamsConfig extends params_ParamsConfig/* NodeParamsConfig */.yI {
  constructor() {
    super(...arguments);
    this.tSizeName = params_ParamsConfig/* ParamConfig.STRING */.XC.STRING(ClothSolverUniformName.SIZE);
    this.tPosition0Name = params_ParamsConfig/* ParamConfig.STRING */.XC.STRING(ClothSolverUniformName.POSITION0);
    this.tPosition1Name = params_ParamsConfig/* ParamConfig.STRING */.XC.STRING(ClothSolverUniformName.POSITION1);
    this.tNormalName = params_ParamsConfig/* ParamConfig.STRING */.XC.STRING(ClothSolverUniformName.NORMAL);
  }
}
const ClothSolverUpdateMaterial_ParamsConfig = new ClothSolverUpdateMaterialJsParamsConfig();
class ClothSolverUpdateMaterialJsNode extends js_Base/* TypedJsNode */.xZ {
  constructor() {
    super(...arguments);
    this.paramsConfig = ClothSolverUpdateMaterial_ParamsConfig;
  }
  static type() {
    return "clothSolverUpdateMaterial";
  }
  initializeNode() {
    this.io.inputs.setNamedInputConnectionPoints([
      new connections_Js/* JsConnectionPoint */.fp(js_Base/* TRIGGER_CONNECTION_NAME */.w6, connections_Js/* JsConnectionPointType.TRIGGER */.zF.TRIGGER, ClothSolverUpdateMaterial_CONNECTION_OPTIONS),
      new connections_Js/* JsConnectionPoint */.fp(connections_Js/* JsConnectionPointType.MATERIAL */.zF.MATERIAL, connections_Js/* JsConnectionPointType.MATERIAL */.zF.MATERIAL, ClothSolverUpdateMaterial_CONNECTION_OPTIONS),
      new connections_Js/* JsConnectionPoint */.fp(
        ClothSolverStepSimulation/* ClothSolverStepSimulationOutput.TEXTURE_SIZE */.W.TEXTURE_SIZE,
        connections_Js/* JsConnectionPointType.VECTOR2 */.zF.VECTOR2,
        ClothSolverUpdateMaterial_CONNECTION_OPTIONS
      ),
      new connections_Js/* JsConnectionPoint */.fp(
        ClothSolverStepSimulation/* ClothSolverStepSimulationOutput.TEXTURE_POSITION0 */.W.TEXTURE_POSITION0,
        connections_Js/* JsConnectionPointType.TEXTURE */.zF.TEXTURE,
        ClothSolverUpdateMaterial_CONNECTION_OPTIONS
      ),
      new connections_Js/* JsConnectionPoint */.fp(
        ClothSolverStepSimulation/* ClothSolverStepSimulationOutput.TEXTURE_POSITION1 */.W.TEXTURE_POSITION1,
        connections_Js/* JsConnectionPointType.TEXTURE */.zF.TEXTURE,
        ClothSolverUpdateMaterial_CONNECTION_OPTIONS
      ),
      new connections_Js/* JsConnectionPoint */.fp(
        ClothSolverStepSimulation/* ClothSolverStepSimulationOutput.TEXTURE_NORMAL */.W.TEXTURE_NORMAL,
        connections_Js/* JsConnectionPointType.TEXTURE */.zF.TEXTURE,
        ClothSolverUpdateMaterial_CONNECTION_OPTIONS
      )
    ]);
    this.io.outputs.setNamedOutputConnectionPoints([
      new connections_Js/* JsConnectionPoint */.fp(js_Base/* TRIGGER_CONNECTION_NAME */.w6, connections_Js/* JsConnectionPointType.TRIGGER */.zF.TRIGGER),
      new connections_Js/* JsConnectionPoint */.fp(connections_Js/* JsConnectionPointType.MATERIAL */.zF.MATERIAL, connections_Js/* JsConnectionPointType.MATERIAL */.zF.MATERIAL, ClothSolverUpdateMaterial_CONNECTION_OPTIONS)
    ]);
  }
  setTriggerableLines(linesController) {
    const material = (0,_BaseObject3D/* inputObject3DMaterial */.kI)(this, linesController);
    const tSizeName = this.variableForInputParam(linesController, this.p.tSizeName);
    const tPosition0Name = this.variableForInputParam(linesController, this.p.tPosition0Name);
    const tPosition1Name = this.variableForInputParam(linesController, this.p.tPosition1Name);
    const tNormalName = this.variableForInputParam(linesController, this.p.tNormalName);
    const tSize = this.variableForInput(linesController, ClothSolverStepSimulation/* ClothSolverStepSimulationOutput.TEXTURE_SIZE */.W.TEXTURE_SIZE);
    const tPosition0 = this.variableForInput(linesController, ClothSolverStepSimulation/* ClothSolverStepSimulationOutput.TEXTURE_POSITION0 */.W.TEXTURE_POSITION0);
    const tPosition1 = this.variableForInput(linesController, ClothSolverStepSimulation/* ClothSolverStepSimulationOutput.TEXTURE_POSITION1 */.W.TEXTURE_POSITION1);
    const tNormal = this.variableForInput(linesController, ClothSolverStepSimulation/* ClothSolverStepSimulationOutput.TEXTURE_NORMAL */.W.TEXTURE_NORMAL);
    const func = Poly/* Poly.namedFunctionsRegister.getFunction */.L.namedFunctionsRegister.getFunction("clothSolverUpdateMaterial", this, linesController);
    const bodyLine = func.asString(
      material,
      tSizeName,
      tPosition0Name,
      tPosition1Name,
      tNormalName,
      tSize,
      tPosition0,
      tPosition1,
      tNormal
    );
    linesController.addTriggerableLines(this, [bodyLine]);
  }
}

// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/nodes/js/code/utils/JsLinesCollectionController.ts + 1 modules
var JsLinesCollectionController = __webpack_require__(84367);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/nodes/js/code/assemblers/_Base.ts
var code_assemblers_Base = __webpack_require__(19253);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/nodes/js/code/assemblers/actor/ActorAssemblerUtils.ts
var ActorAssemblerUtils = __webpack_require__(15945);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/core/SetUtils.ts
var SetUtils = __webpack_require__(55407);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/core/code/PrettierController.ts
var PrettierController = __webpack_require__(52733);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/nodes/js/code/assemblers/actor/ActorAssemblerCommon.ts
var ActorAssemblerCommon = __webpack_require__(45381);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/nodes/js/code/configs/ShaderConfig.ts
var ShaderConfig = __webpack_require__(3180);
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/js/code/assemblers/actor/ActorAssembler.ts











const ActorAssembler_TEMPLATE = `
${code_assemblers_Base/* INSERT_DEFINE_AFTER */.Zf}
class CustomActorEvaluator extends ActorEvaluator {
	${code_assemblers_Base/* INSERT_MEMBERS_AFTER */.FD}
	constructor(node, object3D){
		super(node, object3D);
		${code_assemblers_Base/* INSERT_CONSTRUCTOR_AFTER */.Yx}
	}
	${code_assemblers_Base/* INSERT_BODY_AFTER */.xP}
`;
const CLOSE_CLASS_DEFINITION = `};
return CustomActorEvaluator;`;
const _tmp = [];
class JsAssemblerActor extends code_assemblers_Base/* BaseJsShaderAssembler */.SD {
  makeFunctionNodeDirtyOnChange() {
    return false;
  }
  templateShader() {
    return {
      main: ActorAssembler_TEMPLATE
    };
  }
  inputNamesForShaderName(rootNode, shaderName) {
    return (rootNode.io.inputs.namedInputConnectionPoints() || []).filter((cp) => cp.type() != connections_Js/* JsConnectionPointType.TRIGGER */.zF.TRIGGER).map((cp) => cp.name());
  }
  computedVariablesAllowed() {
    return true;
  }
  spareParamsOptions(options) {
    const { type } = options;
    const _options = {
      spare: true,
      computeOnDirty: type != ParamType/* ParamType.PARAM_PATH */._.PARAM_PATH,
      cook: false
      // dependentOnFoundNode: true,
      // there is no point in setting the callback option here,
      // as it would then not be present when reloading the scene
      // callback: (node, param) => {
      // 	touchParamRef(node, param.name());
      // },
    };
    return _options;
  }
  defaultObjectVariable() {
    return ActorAssemblerCommon/* ActorAssemblerConstant.OBJECT_3D */.e.OBJECT_3D;
  }
  defaultObject3DMaterialVariable() {
    return ActorAssemblerCommon/* ActorAssemblerConstant.MATERIAL */.e.MATERIAL;
  }
  defaultPrimitiveGraph() {
    return ActorAssemblerCommon/* ActorAssemblerConstant.PRIMITIVE_GRAPH */.e.PRIMITIVE_GRAPH;
  }
  createFunctionData(additionalRootNodes) {
    const node = this.currentJsParentNode();
    this._reset();
    const triggeringNodes = (0,ActorAssemblerUtils/* findTriggeringNodes */.D8)(node);
    const triggerableNodes = /* @__PURE__ */ new Set();
    (0,ActorAssemblerUtils/* connectedTriggerableNodes */.a9)({ triggeringNodes, triggerableNodes, recursive: true });
    const shaderNames = this.shaderNames();
    const functionData = this._createFunctionData(
      additionalRootNodes,
      triggeringNodes,
      triggerableNodes,
      shaderNames
    );
    return functionData;
  }
  _createFunctionData(additionalRootNodes, triggeringNodes, triggerableNodes, shaderNames) {
    var _a;
    const functionNode = this.currentJsParentNode();
    const _addComputedProps = () => {
      const rootNodesSet = /* @__PURE__ */ new Set();
      triggerableNodes.forEach((trigerrableNode) => {
        const rootNodes2 = (0,ActorAssemblerUtils/* inputNodesExceptTrigger */.iZ)(trigerrableNode, _tmp);
        for (const rootNode of rootNodes2) {
          rootNodesSet.add(rootNode);
        }
      });
      (0,SetUtils/* setToArray */.T_)(rootNodesSet, _tmp);
      const rootNodes = _tmp.concat(additionalRootNodes);
      this.set_root_nodes(rootNodes);
      this.buildCodeFromNodes(this._root_nodes, {
        actor: {
          functionNode,
          triggeringNodes,
          triggerableNodes
        }
      });
      this._buildLines();
      for (const shaderName of shaderNames) {
        const lines = this._lines.get(shaderName);
        if (lines) {
          this._shaders_by_name.set(shaderName, lines.join("\n"));
        }
      }
    };
    _addComputedProps();
    const _buildFunctionBody = () => {
      const bodyLines = this._shaders_by_name.get(ShaderName/* JsFunctionName.MAIN */.J.MAIN) || ActorAssembler_TEMPLATE;
      const functionBodyElements = [bodyLines, CLOSE_CLASS_DEFINITION];
      const functionBody2 = PrettierController/* PrettierController.formatJs */.u.formatJs(functionBodyElements.join("\n"));
      return functionBody2;
    };
    const functionBody = _buildFunctionBody();
    const variableNames = [];
    const functionNames = [];
    const variablesByName = {};
    const functionsByName = {};
    this.traverseRegisteredVariables((variable, varName) => {
      variableNames.push(varName);
      variablesByName[varName] = variable;
    });
    this.traverseRegisteredFunctions((namedFunction) => {
      functionNames.push(namedFunction.type());
      functionsByName[namedFunction.type()] = namedFunction.func.bind(namedFunction);
    });
    const paramConfigs = this.param_configs();
    const variables = [];
    const functions = [];
    for (const variableName of variableNames) {
      const variable = variablesByName[variableName];
      variables.push(variable);
    }
    for (const functionName of functionNames) {
      const _func = functionsByName[functionName];
      functions.push(_func);
    }
    const eventDatas = [];
    (_a = this.currentJsParentNode().childrenController) == null ? void 0 : _a.traverseChildren((child) => {
      const eventDataFunction = child.eventData;
      if (eventDataFunction && Type/* CoreType.isFunction */.MR.isFunction(eventDataFunction)) {
        const eventData = child.eventData();
        if (eventData) {
          if (Type/* CoreType.isArray */.MR.isArray(eventData)) {
            eventDatas.push(...eventData);
          } else {
            eventDatas.push(eventData);
          }
        }
      }
    });
    const functionData = {
      functionBody,
      variableNames,
      variablesByName,
      functionNames,
      functionsByName,
      paramConfigs: [...paramConfigs],
      eventDatas
    };
    return functionData;
  }
  rootNodesByShaderName(shaderName, rootNodes) {
    return rootNodes;
  }
  //
  //
  // CONFIGS
  //
  //
  create_shader_configs() {
    return [new ShaderConfig/* JsShaderConfig */.s(ShaderName/* JsFunctionName.MAIN */.J.MAIN, [], [])];
  }
  create_variable_configs() {
    return [];
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/js/Code.ts












const Code_CONNECTION_OPTIONS = connections_Js/* JS_CONNECTION_POINT_IN_NODE_DEF */.mX;
const JS_CODE_DEFAULT_TS = `
export class CodeJsProcessor extends BaseCodeJsProcessor {
	override initializeProcessor(){
		this.io.inputs.setNamedInputConnectionPoints([
			new JsConnectionPoint('myBoolParam', JsConnectionPointType.BOOLEAN),
		]);
		this.io.outputs.setNamedOutputConnectionPoints([
			new JsConnectionPoint(JsConnectionPointType.TRIGGER, JsConnectionPointType.TRIGGER),
		]);
	}
	override setTriggerableLines(controller: JsLinesCollectionController) {
		const object3D = this.inputObject3D(this, controller);
		const myBoolParam = this.variableForInput(controller, 'myBoolParam');

		const bodyLines = [
			object3D + '.position.y += ' + myBoolParam + ' ? -1 : 1;',
			object3D + '.updateMatrix()'
		];
		this.addTriggerableLines(controller, bodyLines);
	}
}
`;
const Code_DEFAULT_JS = JS_CODE_DEFAULT_TS.replace(/\:\sJsLinesCollectionController/g, "").replace(/override\s/g, "");
class BaseCodeJsProcessor extends FunctionBuilderUtils/* BaseCodeProcessor */.h {
  constructor(node) {
    super(node);
    this.node = node;
  }
  get pv() {
    return this.node.pv;
  }
  get p() {
    return this.node.p;
  }
  get io() {
    return this.node.io;
  }
  initializeProcessor() {
  }
  setTriggerableLines(controller) {
  }
  inputObject3D(processor, controller) {
    return (0,_BaseObject3D/* inputObject3D */.iv)(this.node, controller);
  }
  variableForInput(controller, inputName) {
    return this.node.variableForInput(controller, inputName);
  }
  addTriggerableLines(controller, bodyLines) {
    return controller.addTriggerableLines(this.node, bodyLines);
  }
}
class CodeJsParamsConfig extends params_ParamsConfig/* NodeParamsConfig */.yI {
  constructor() {
    super(...arguments);
    // compile = ParamConfig.BUTTON(null, {
    // 	callback: (node: BaseNodeType) => {
    // 		CodeJsNode.PARAM_CALLBACK_compile(node as CodeJsNode);
    // 	},
    // 	cook: false,
    // });
    this.codeTypescript = params_ParamsConfig/* ParamConfig.STRING */.XC.STRING(JS_CODE_DEFAULT_TS, {
      hideLabel: true,
      language: OptionsController/* StringParamLanguage.TYPESCRIPT */.qs.TYPESCRIPT,
      cook: false
    });
    this.codeJavascript = params_ParamsConfig/* ParamConfig.STRING */.XC.STRING(Code_DEFAULT_JS, {
      hidden: true,
      cook: false,
      callback: (node) => {
        CodeJsNode.PARAM_CALLBACK_requestCompile(node);
      }
    });
  }
}
const js_Code_ParamsConfig = new CodeJsParamsConfig();
class CodeJsNode extends js_Base/* TypedJsNode */.xZ {
  constructor() {
    super(...arguments);
    this.paramsConfig = js_Code_ParamsConfig;
    this._compilationSuccessful = false;
  }
  static type() {
    return Js/* JsType.CODE */.K.CODE;
  }
  initializeNode() {
    this.io.connection_points.spare_params.setInputlessParamNames(["codeTypescript", "codeJavascript"]);
    this.io.inputs.setNamedInputConnectionPoints([
      new connections_Js/* JsConnectionPoint */.fp(js_Base/* TRIGGER_CONNECTION_NAME */.w6, connections_Js/* JsConnectionPointType.TRIGGER */.zF.TRIGGER, Code_CONNECTION_OPTIONS),
      new connections_Js/* JsConnectionPoint */.fp(connections_Js/* JsConnectionPointType.OBJECT_3D */.zF.OBJECT_3D, connections_Js/* JsConnectionPointType.OBJECT_3D */.zF.OBJECT_3D, Code_CONNECTION_OPTIONS)
    ]);
    this.io.outputs.setNamedOutputConnectionPoints([
      new connections_Js/* JsConnectionPoint */.fp(js_Base/* TRIGGER_CONNECTION_NAME */.w6, connections_Js/* JsConnectionPointType.TRIGGER */.zF.TRIGGER)
    ]);
    this.params.onParamsCreated("compile", () => {
      this.compile({ triggerFunctionNode: false });
    });
  }
  // override cook() {
  // 	// try {
  // 	// }catch(err){
  // 	// }
  // 	this.compile({triggerFunctionNode: false});
  // 	console.log('COOK: this.compiled()', this.compiled());
  // 	// if (this.compiled()) {
  // 	// } // else {
  // 	//	this.states.error.set(`cannot generate function`);
  // 	//}
  // 	this.cookController.endCook();
  // }
  setTriggerableLines(controller) {
    var _a;
    (_a = this._processor) == null ? void 0 : _a.setTriggerableLines(controller);
  }
  compiled() {
    return this._compilationSuccessful;
  }
  compile(options) {
    const content = TranspiledFilter/* TranspiledFilter.filter */.k.filter(this.pv.codeJavascript);
    if (this._lastCompiledCode == content) {
      return;
    }
    this._compilationSuccessful = false;
    this._lastCompiledCode = void 0;
    this._processor = void 0;
    this.states.error.clear();
    const _preventSelfCompilation = () => {
      this._setFunctionNodeToRecompileAllowed(false);
      this.setSelfDirtyForbidden(true);
      this.io.inputs.graphNode().setForbiddenTriggerNodes(this);
    };
    const _restore = () => {
      this._setFunctionNodeToRecompileAllowed(true);
      this.setSelfDirtyForbidden(false);
      this.io.inputs.graphNode().clearForbiddenTriggerNodes();
    };
    try {
      const functionBody = `try {
	${content}
} catch(e) {
		states.error.set(e);
}`;
      const ProcessorClass = (0,FunctionBuilderUtils/* buildCodeNodeFunction */.A)({
        BaseCodeProcessor: BaseCodeJsProcessor,
        BaseCodeProcessorName: "BaseCodeJsProcessor",
        node: this,
        functionBody,
        otherVariables: {
          ["JsConnectionPoint"]: connections_Js/* JsConnectionPoint */.fp,
          ["JsConnectionPointType"]: connections_Js/* JsConnectionPointType */.zF
        }
      });
      if (!ProcessorClass) {
        throw new Error(`cannot generate function`);
      }
      if (ProcessorClass) {
        this._processor = new ProcessorClass(this);
        _preventSelfCompilation();
        this._processor.initializeProcessor();
        const dummyAssembler = new JsAssemblerActor(this.functionNode());
        const dummyShadersCollectionController = new JsLinesCollectionController/* JsLinesCollectionController */.K(
          [ShaderName/* JsFunctionName.MAIN */.J.MAIN],
          ShaderName/* JsFunctionName.MAIN */.J.MAIN,
          dummyAssembler
        );
        this._processor.setTriggerableLines(dummyShadersCollectionController);
        _restore();
        this._compilationSuccessful = true;
        this._lastCompiledCode = content;
        this.states.error.clear();
        if (options.triggerFunctionNode) {
          this._setFunctionNodeToRecompile();
        }
      }
    } catch (e) {
      _restore();
      this.states.error.set(`cannot generate function (${e})`);
      if (options.triggerFunctionNode) {
        this._setFunctionNodeToRecompile();
      }
    }
  }
  static PARAM_CALLBACK_requestCompile(node) {
    node.compile({ triggerFunctionNode: true });
  }
}
// adding BaseCodeJsProcessor seems necessary to have the bundled types include it
CodeJsNode.BaseCodeJsProcessor = BaseCodeJsProcessor;

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/js/_ConversionVecTo.ts







class VecToParamsJsConfig extends params_ParamsConfig/* NodeParamsConfig */.yI {
}
const js_ConversionVecTo_ParamsConfig = new VecToParamsJsConfig();
class BaseVecToJsNode extends js_Base/* TypedJsNode */.xZ {
  constructor() {
    super(...arguments);
    this.paramsConfig = js_ConversionVecTo_ParamsConfig;
  }
}
function VecToJsFactory(type, options) {
  const { components, paramType, inputName } = options;
  return class VecToJsNode extends BaseVecToJsNode {
    static type() {
      return type;
    }
    initializeNode() {
      this.io.outputs.setNamedOutputConnectionPoints(
        components.map((c) => {
          return new connections_Js/* JsConnectionPoint */.fp(c, connections_Js/* JsConnectionPointType.FLOAT */.zF.FLOAT);
        })
      );
    }
    createParams() {
      this.addParam(paramType, inputName, components.map((c) => 0));
    }
    setLines(shadersCollectionController) {
      const vec = this.variableForInput(shadersCollectionController, inputName);
      this.io.outputs.used_output_names().forEach((c) => {
        const varName = this.jsVarName(c);
        shadersCollectionController.addBodyOrComputed(this, [
          {
            dataType: connections_Js/* JsConnectionPointType.FLOAT */.zF.FLOAT,
            varName,
            value: `${vec}.${c}`
          }
        ]);
      });
    }
  };
}
const _ConversionVecTo_components_v2 = ["x", "y"];
const _ConversionVecTo_components_v3 = ["x", "y", "z"];
const _ConversionVecTo_components_v4 = ["x", "y", "z", "w"];
class Vec2ToFloatJsNode extends VecToJsFactory("vec2ToFloat", {
  components: _ConversionVecTo_components_v2,
  paramType: ParamType/* ParamType.VECTOR2 */._.VECTOR2,
  inputName: "vec2"
}) {
}
class Vec3ToFloatJsNode extends VecToJsFactory("vec3ToFloat", {
  components: _ConversionVecTo_components_v3,
  paramType: ParamType/* ParamType.VECTOR3 */._.VECTOR3,
  inputName: "vec3"
}) {
}
class Vec4ToFloatJsNode extends VecToJsFactory("vec4ToFloat", {
  components: _ConversionVecTo_components_v4,
  paramType: ParamType/* ParamType.VECTOR4 */._.VECTOR4,
  inputName: "vec4"
}) {
}
class Vec3ToVec2ParamsJsConfig extends params_ParamsConfig/* NodeParamsConfig */.yI {
  constructor() {
    super(...arguments);
    this.vec3 = params_ParamsConfig/* ParamConfig.VECTOR3 */.XC.VECTOR3([0, 0, 0]);
  }
}
const ParamsConfig_Vec3ToVec2 = new Vec3ToVec2ParamsJsConfig();
const _Vec3ToVec2JsNode = class extends js_Base/* TypedJsNode */.xZ {
  constructor() {
    super(...arguments);
    this.paramsConfig = ParamsConfig_Vec3ToVec2;
  }
  static type() {
    return "vec3ToVec2";
  }
  initializeNode() {
    this.io.outputs.setNamedOutputConnectionPoints([
      new connections_Js/* JsConnectionPoint */.fp(_Vec3ToVec2JsNode.OUTPUT_NAME_VEC2, connections_Js/* JsConnectionPointType.VECTOR2 */.zF.VECTOR2),
      new connections_Js/* JsConnectionPoint */.fp(_Vec3ToVec2JsNode.OUTPUT_NAME_Z, connections_Js/* JsConnectionPointType.FLOAT */.zF.FLOAT)
    ]);
  }
  setLines(shadersCollectionController) {
    const linesData = [];
    const out_vec2 = _Vec3ToVec2JsNode.OUTPUT_NAME_VEC2;
    const out_z = _Vec3ToVec2JsNode.OUTPUT_NAME_Z;
    const vec = this.variableForInputParam(shadersCollectionController, this.p.vec3);
    const used_output_names = this.io.outputs.used_output_names();
    if (used_output_names.indexOf(out_vec2) >= 0) {
      const varName = this.jsVarName(out_vec2);
      const tmpVar = shadersCollectionController.addVariable(this, new three_module.Vector2());
      const func = Poly/* Poly.namedFunctionsRegister.getFunction */.L.namedFunctionsRegister.getFunction("sizzleVec3XY", this, shadersCollectionController);
      linesData.push({
        dataType: connections_Js/* JsConnectionPointType.VECTOR2 */.zF.VECTOR2,
        varName,
        value: func.asString(vec, tmpVar)
      });
    }
    if (used_output_names.indexOf(out_z) >= 0) {
      const varName = this.jsVarName(out_z);
      linesData.push({
        dataType: connections_Js/* JsConnectionPointType.FLOAT */.zF.FLOAT,
        varName,
        value: `${vec}.z`
      });
    }
    shadersCollectionController.addBodyOrComputed(this, linesData);
  }
};
let Vec3ToVec2JsNode = _Vec3ToVec2JsNode;
Vec3ToVec2JsNode.OUTPUT_NAME_VEC2 = "vec2";
Vec3ToVec2JsNode.OUTPUT_NAME_Z = "z";
class Vec2ToVec3ParamsJsConfig extends params_ParamsConfig/* NodeParamsConfig */.yI {
  constructor() {
    super(...arguments);
    this.Vector2 = params_ParamsConfig/* ParamConfig.VECTOR2 */.XC.VECTOR2([0, 0]);
    this.z = params_ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(0);
  }
}
const ParamsConfig_Vec2ToVec3 = new Vec2ToVec3ParamsJsConfig();
const _Vec2ToVec3JsNode = class extends js_Base/* TypedJsNode */.xZ {
  constructor() {
    super(...arguments);
    this.paramsConfig = ParamsConfig_Vec2ToVec3;
  }
  static type() {
    return "vec2ToVec3";
  }
  initializeNode() {
    this.io.outputs.setNamedOutputConnectionPoints([
      new connections_Js/* JsConnectionPoint */.fp(_Vec2ToVec3JsNode.OUTPUT_NAME_VEC3, connections_Js/* JsConnectionPointType.VECTOR3 */.zF.VECTOR3)
    ]);
  }
  setLines(shadersCollectionController) {
    const linesData = [];
    const out_vec3 = _Vec2ToVec3JsNode.OUTPUT_NAME_VEC3;
    const vec2 = this.variableForInputParam(shadersCollectionController, this.p.Vector2);
    const z = this.variableForInputParam(shadersCollectionController, this.p.z);
    const varName = this.jsVarName(out_vec3);
    const tmpVar = shadersCollectionController.addVariable(this, new three_module.Vector3());
    const func = Poly/* Poly.namedFunctionsRegister.getFunction */.L.namedFunctionsRegister.getFunction("vec2ToVec3", this, shadersCollectionController);
    linesData.push({
      dataType: connections_Js/* JsConnectionPointType.VECTOR3 */.zF.VECTOR3,
      varName,
      value: func.asString(vec2, z, tmpVar)
    });
    shadersCollectionController.addBodyOrComputed(this, linesData);
  }
};
let Vec2ToVec3JsNode = _Vec2ToVec3JsNode;
Vec2ToVec3JsNode.OUTPUT_NAME_VEC3 = "vec3";
class Vec3ToVec4ParamsJsConfig extends params_ParamsConfig/* NodeParamsConfig */.yI {
  constructor() {
    super(...arguments);
    this.vec3 = params_ParamsConfig/* ParamConfig.VECTOR3 */.XC.VECTOR3([0, 0, 0]);
    this.w = params_ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(0);
  }
}
const ParamsConfig_Vec3ToVec4 = new Vec3ToVec4ParamsJsConfig();
const _Vec3ToVec4JsNode = class extends js_Base/* TypedJsNode */.xZ {
  constructor() {
    super(...arguments);
    this.paramsConfig = ParamsConfig_Vec3ToVec4;
  }
  static type() {
    return "vec3ToVec4";
  }
  initializeNode() {
    this.io.outputs.setNamedOutputConnectionPoints([
      new connections_Js/* JsConnectionPoint */.fp(_Vec3ToVec4JsNode.OUTPUT_NAME_VEC4, connections_Js/* JsConnectionPointType.VECTOR4 */.zF.VECTOR4)
    ]);
  }
  setLines(shadersCollectionController) {
    const linesData = [];
    const out_vec4 = _Vec3ToVec4JsNode.OUTPUT_NAME_VEC4;
    const vec3 = this.variableForInputParam(shadersCollectionController, this.p.vec3);
    const w = this.variableForInputParam(shadersCollectionController, this.p.w);
    const varName = this.jsVarName(out_vec4);
    const tmpVar = shadersCollectionController.addVariable(this, new three_module.Vector4());
    const func = Poly/* Poly.namedFunctionsRegister.getFunction */.L.namedFunctionsRegister.getFunction("vec3ToVec4", this, shadersCollectionController);
    linesData.push({
      dataType: connections_Js/* JsConnectionPointType.VECTOR4 */.zF.VECTOR4,
      varName,
      value: func.asString(vec3, w, tmpVar)
    });
    shadersCollectionController.addBodyOrComputed(this, linesData);
  }
};
let Vec3ToVec4JsNode = _Vec3ToVec4JsNode;
// static readonly INPUT_NAME_VEC3 = 'vec3';
// static readonly INPUT_NAME_W = 'w';
Vec3ToVec4JsNode.OUTPUT_NAME_VEC4 = "vec4";
class Vec3ToColorParamsJsConfig extends params_ParamsConfig/* NodeParamsConfig */.yI {
  constructor() {
    super(...arguments);
    this.vec3 = params_ParamsConfig/* ParamConfig.VECTOR3 */.XC.VECTOR3([0, 0, 0]);
  }
}
const ParamsConfig_Vec3ToColor = new Vec3ToColorParamsJsConfig();
class Vec3ToColorJsNode extends js_Base/* TypedJsNode */.xZ {
  constructor() {
    super(...arguments);
    this.paramsConfig = ParamsConfig_Vec3ToColor;
  }
  static type() {
    return "vec3ToColor";
  }
  initializeNode() {
    this.io.outputs.setNamedOutputConnectionPoints([
      new connections_Js/* JsConnectionPoint */.fp(connections_Js/* JsConnectionPointType.COLOR */.zF.COLOR, connections_Js/* JsConnectionPointType.COLOR */.zF.COLOR)
    ]);
  }
  setLines(shadersCollectionController) {
    const linesData = [];
    const vec3 = this.variableForInputParam(shadersCollectionController, this.p.vec3);
    const varName = this.jsVarName(connections_Js/* JsConnectionPointType.COLOR */.zF.COLOR);
    const tmpVar = shadersCollectionController.addVariable(this, new three_module.Color());
    const func = Poly/* Poly.namedFunctionsRegister.getFunction */.L.namedFunctionsRegister.getFunction("vec3ToColor", this, shadersCollectionController);
    linesData.push({
      dataType: connections_Js/* JsConnectionPointType.COLOR */.zF.COLOR,
      varName,
      value: func.asString(vec3, tmpVar)
    });
    shadersCollectionController.addBodyOrComputed(this, linesData);
  }
}
class ColorToVec3ParamsJsConfig extends params_ParamsConfig/* NodeParamsConfig */.yI {
  constructor() {
    super(...arguments);
    this.color = params_ParamsConfig/* ParamConfig.COLOR */.XC.COLOR([0, 0, 0]);
  }
}
const ParamsConfig_ColorToVec3 = new ColorToVec3ParamsJsConfig();
class ColorToVec3JsNode extends js_Base/* TypedJsNode */.xZ {
  constructor() {
    super(...arguments);
    this.paramsConfig = ParamsConfig_ColorToVec3;
  }
  static type() {
    return "colorToVec3";
  }
  initializeNode() {
    this.io.outputs.setNamedOutputConnectionPoints([
      new connections_Js/* JsConnectionPoint */.fp(connections_Js/* JsConnectionPointType.VECTOR3 */.zF.VECTOR3, connections_Js/* JsConnectionPointType.VECTOR3 */.zF.VECTOR3)
    ]);
  }
  setLines(shadersCollectionController) {
    const linesData = [];
    const color = this.variableForInputParam(shadersCollectionController, this.p.color);
    const varName = this.jsVarName(connections_Js/* JsConnectionPointType.VECTOR3 */.zF.VECTOR3);
    const tmpVar = shadersCollectionController.addVariable(this, new three_module.Vector3());
    const func = Poly/* Poly.namedFunctionsRegister.getFunction */.L.namedFunctionsRegister.getFunction("colorToVec3", this, shadersCollectionController);
    linesData.push({
      dataType: connections_Js/* JsConnectionPointType.COLOR */.zF.COLOR,
      varName,
      value: func.asString(color, tmpVar)
    });
    shadersCollectionController.addBodyOrComputed(this, linesData);
  }
}

// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/nodes/js/Compare.ts
var js_Compare = __webpack_require__(4561);
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/js/Complement.ts



const Complement_FUNCTION_NAME = "complement";
class ComplementJsNode extends MathFunctionArg1OperationFactory("complement", {
  inputPrefix: "in",
  out: "out"
}) {
  _coreFunction(shadersCollectionController) {
    Poly/* Poly.namedFunctionsRegister.getFunction */.L.namedFunctionsRegister.getFunction(Complement_FUNCTION_NAME, this, shadersCollectionController).asString("");
    return Complement_FUNCTION_NAME;
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/js/ComputeVelocity.ts






const ComputeVelocity_OUTPUT_NAME = "velocity";
class ComputeVelocityJsParamsConfig extends params_ParamsConfig/* NodeParamsConfig */.yI {
  constructor() {
    super(...arguments);
    /** @param forces */
    this.forces = params_ParamsConfig/* ParamConfig.VECTOR3 */.XC.VECTOR3([0, -9.8, 0]);
    /** @param velocity */
    this.velocity = params_ParamsConfig/* ParamConfig.VECTOR3 */.XC.VECTOR3([0, 0, 0]);
    /** @param dt */
    this.delta = params_ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(1);
    /** @param drag */
    this.drag = params_ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(1);
  }
}
const ComputeVelocity_ParamsConfig = new ComputeVelocityJsParamsConfig();
class ComputeVelocityJsNode extends js_Base/* TypedJsNode */.xZ {
  constructor() {
    super(...arguments);
    this.paramsConfig = ComputeVelocity_ParamsConfig;
  }
  static type() {
    return "computeVelocity";
  }
  initializeNode() {
    super.initializeNode();
    this.io.outputs.setNamedOutputConnectionPoints([
      new connections_Js/* JsConnectionPoint */.fp(ComputeVelocity_OUTPUT_NAME, connections_Js/* JsConnectionPointType.VECTOR3 */.zF.VECTOR3)
    ]);
  }
  setLines(linesController) {
    const velocity = this.variableForInputParam(linesController, this.p.velocity);
    const forces = this.variableForInputParam(linesController, this.p.forces);
    const delta = this.variableForInputParam(linesController, this.p.delta);
    const drag = this.variableForInputParam(linesController, this.p.drag);
    const out = this.jsVarName(ComputeVelocity_OUTPUT_NAME);
    const tmpVarName = linesController.addVariable(this, new three_module.Vector3());
    const func = Poly/* Poly.namedFunctionsRegister.getFunction */.L.namedFunctionsRegister.getFunction("computeVelocity", this, linesController);
    const bodyLine = func.asString(velocity, forces, delta, drag, tmpVarName);
    linesController.addBodyOrComputed(this, [
      { dataType: connections_Js/* JsConnectionPointType.VECTOR3 */.zF.VECTOR3, varName: out, value: bodyLine }
    ]);
  }
}

// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/nodes/js/Constant.ts
var js_Constant = __webpack_require__(34253);
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/js/CookNode.ts





const CookNode_CONNECTION_OPTIONS = connections_Js/* JS_CONNECTION_POINT_IN_NODE_DEF */.mX;
class CookNodeJsParamsConfig extends params_ParamsConfig/* NodeParamsConfig */.yI {
  constructor() {
    super(...arguments);
    /** @param  node to cook */
    this.node = params_ParamsConfig/* ParamConfig.NODE_PATH */.XC.NODE_PATH("", {
      dependentOnFoundNode: false,
      computeOnDirty: true
    });
  }
}
const CookNode_ParamsConfig = new CookNodeJsParamsConfig();
class CookNodeJsNode extends js_Base/* TypedJsNode */.xZ {
  constructor() {
    super(...arguments);
    this.paramsConfig = CookNode_ParamsConfig;
  }
  static type() {
    return "cookNode";
  }
  initializeNode() {
    this.io.inputs.setNamedInputConnectionPoints([
      new connections_Js/* JsConnectionPoint */.fp(js_Base/* TRIGGER_CONNECTION_NAME */.w6, connections_Js/* JsConnectionPointType.TRIGGER */.zF.TRIGGER, CookNode_CONNECTION_OPTIONS)
    ]);
  }
  setTriggerableLines(shadersCollectionController) {
    const node = this.pv.node.node();
    if (!node) {
      return;
    }
    const nodePath = `'${node.path()}'`;
    const func = Poly/* Poly.namedFunctionsRegister.getFunction */.L.namedFunctionsRegister.getFunction("cookNode", this, shadersCollectionController);
    const bodyLine = func.asString(nodePath);
    shadersCollectionController.addTriggerableLines(this, [bodyLine]);
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/js/Cos.ts


class CosJsNode extends MathFunctionArg1OperationFactory("cos", {
  inputPrefix: "angle",
  out: "cos"
}) {
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/js/CreateClothConstraint.ts





class CreateClothConstraintJsParamsConfig extends params_ParamsConfig/* NodeParamsConfig */.yI {
  constructor() {
    super(...arguments);
    this.index = params_ParamsConfig/* ParamConfig.INTEGER */.XC.INTEGER(0, {
      range: [-1, 100],
      rangeLocked: [true, false]
    });
  }
}
const CreateClothConstraint_ParamsConfig = new CreateClothConstraintJsParamsConfig();
class CreateClothConstraintJsNode extends _BaseTriggerAndObject/* BaseTriggerAndObjectJsNode */.e {
  constructor() {
    super(...arguments);
    this.paramsConfig = CreateClothConstraint_ParamsConfig;
  }
  static type() {
    return "createClothConstraint";
  }
  setTriggerableLines(linesController) {
    const object3D = (0,_BaseObject3D/* inputObject3D */.iv)(this, linesController);
    const index = this.variableForInputParam(linesController, this.p.index);
    const func = Poly/* Poly.namedFunctionsRegister.getFunction */.L.namedFunctionsRegister.getFunction("clothCreateConstraint", this, linesController);
    const bodyLine = func.asString(object3D, index);
    linesController.addTriggerableLines(this, [bodyLine]);
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/js/CreateObjects.ts






var CreateObjectsJsNodeInput = /* @__PURE__ */ ((CreateObjectsJsNodeInput2) => {
  CreateObjectsJsNodeInput2["CHILD"] = "child";
  CreateObjectsJsNodeInput2["CHILDREN"] = "children";
  return CreateObjectsJsNodeInput2;
})(CreateObjectsJsNodeInput || {});
class CreateObjectsJsParamsConfig extends params_ParamsConfig/* NodeParamsConfig */.yI {
}
const CreateObjects_ParamsConfig = new CreateObjectsJsParamsConfig();
class CreateObjectsJsNode extends _BaseTriggerAndObject/* BaseTriggerAndObjectJsNode */.e {
  constructor() {
    super(...arguments);
    this.paramsConfig = CreateObjects_ParamsConfig;
  }
  static type() {
    return "createObjects";
  }
  initializeNode() {
    super.initializeNode();
    this.io.connection_points.set_input_name_function(this._expectedInputName.bind(this));
    this.io.connection_points.set_output_name_function(this._expectedOutputName.bind(this));
    this.io.connection_points.set_expected_input_types_function(this._expectedInputTypes.bind(this));
    this.io.connection_points.set_expected_output_types_function(this._expectedOutputTypes.bind(this));
  }
  _expectedInputName(index) {
    return [connections_Js/* JsConnectionPointType.TRIGGER */.zF.TRIGGER, connections_Js/* JsConnectionPointType.OBJECT_3D */.zF.OBJECT_3D, this._childInputName()][index];
  }
  _expectedOutputName(index) {
    return [connections_Js/* JsConnectionPointType.TRIGGER */.zF.TRIGGER, connections_Js/* JsConnectionPointType.OBJECT_3D */.zF.OBJECT_3D, this._childOutputName()][index];
  }
  _expectedInputTypes() {
    return [connections_Js/* JsConnectionPointType.TRIGGER */.zF.TRIGGER, connections_Js/* JsConnectionPointType.OBJECT_3D */.zF.OBJECT_3D, this._childInputType()];
  }
  _expectedOutputTypes() {
    return this._expectedInputTypes();
  }
  _isInputArray() {
    const firstInputType = this.io.connection_points.input_connection_type(2);
    return firstInputType == connections_Js/* JsConnectionPointType.OBJECT_3D_ARRAY */.zF.OBJECT_3D_ARRAY;
  }
  _childInputName() {
    return this._isInputArray() ? "children" /* CHILDREN */ : "child" /* CHILD */;
  }
  _childOutputName() {
    return this._childInputName();
  }
  _childInputType() {
    return this._isInputArray() ? connections_Js/* JsConnectionPointType.OBJECT_3D_ARRAY */.zF.OBJECT_3D_ARRAY : connections_Js/* JsConnectionPointType.OBJECT_3D */.zF.OBJECT_3D;
  }
  setLines(linesController) {
    super.setLines(linesController);
    const object3D = this.variableForInput(linesController, this._childOutputName());
    const out = this.jsVarName(this._childOutputName());
    linesController.addBodyOrComputed(this, [
      { dataType: connections_Js/* JsConnectionPointType.OBJECT_3D */.zF.OBJECT_3D, varName: out, value: object3D }
    ]);
  }
  setTriggerableLines(linesController) {
    const object3D = (0,_BaseObject3D/* inputObject3D */.iv)(this, linesController);
    const inputName = this._childInputName();
    const inputChildObjects = this.variableForInput(linesController, inputName);
    const functionName = this._isInputArray() ? "createObjects" : "createObject";
    const func = Poly/* Poly.namedFunctionsRegister.getFunction */.L.namedFunctionsRegister.getFunction(functionName, this, linesController);
    const bodyLine = func.asString(object3D, inputChildObjects);
    linesController.addTriggerableLines(this, [bodyLine]);
  }
}

// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/nodes/js/utils/JsDefinition.ts
var JsDefinition = __webpack_require__(36343);
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/js/CreatePhysicsRBDKinematicConstraint.ts







var CreatePhysicsRBDKinematicConstraintJsNodeOutput = /* @__PURE__ */ ((CreatePhysicsRBDKinematicConstraintJsNodeOutput2) => {
  CreatePhysicsRBDKinematicConstraintJsNodeOutput2["RBD_ID"] = "rbdId";
  return CreatePhysicsRBDKinematicConstraintJsNodeOutput2;
})(CreatePhysicsRBDKinematicConstraintJsNodeOutput || {});
class CreatePhysicsRBDKinematicConstraintJsParamsConfig extends params_ParamsConfig/* NodeParamsConfig */.yI {
  constructor() {
    super(...arguments);
    this.anchor = params_ParamsConfig/* ParamConfig.VECTOR3 */.XC.VECTOR3([0, 0, 0]);
  }
}
const CreatePhysicsRBDKinematicConstraint_ParamsConfig = new CreatePhysicsRBDKinematicConstraintJsParamsConfig();
class CreatePhysicsRBDKinematicConstraintJsNode extends _BaseTriggerAndObject/* BaseTriggerAndObjectJsNode */.e {
  constructor() {
    super(...arguments);
    this.paramsConfig = CreatePhysicsRBDKinematicConstraint_ParamsConfig;
  }
  static type() {
    return "createPhysicsRBDKinematicConstraint";
  }
  _additionalOutputs() {
    return [
      new connections_Js/* JsConnectionPoint */.fp("rbdId" /* RBD_ID */, connections_Js/* JsConnectionPointType.STRING */.zF.STRING)
    ];
  }
  setLines(linesController) {
    const usedOutputNames = this.io.outputs.used_output_names();
    if (usedOutputNames.includes("rbdId" /* RBD_ID */)) {
      const outRBDIds = this._addRBDIdRef(linesController);
      const out = this.jsVarName("rbdId" /* RBD_ID */);
      linesController.addBodyOrComputed(this, [
        { dataType: connections_Js/* JsConnectionPointType.OBJECT_3D */.zF.OBJECT_3D, varName: out, value: `this.${outRBDIds}.value` }
      ]);
      if (!usedOutputNames.includes(connections_Js/* JsConnectionPointType.TRIGGER */.zF.TRIGGER)) {
        this.setTriggeringLines(linesController, "");
      }
    }
  }
  setTriggerableLines(linesController) {
    const object3D = (0,_BaseObject3D/* inputObject3D */.iv)(this, linesController);
    const anchor = this.variableForInputParam(linesController, this.p.anchor);
    const rbdId = this._addRBDIdRef(linesController);
    const func = Poly/* Poly.namedFunctionsRegister.getFunction */.L.namedFunctionsRegister.getFunction(
      "createPhysicsRBDKinematicConstraint",
      this,
      linesController
    );
    const bodyLine = func.asString(object3D, anchor, `this.${rbdId}`);
    linesController.addTriggerableLines(this, [bodyLine]);
  }
  _addRBDIdRef(linesController) {
    const outRBDIds = this.jsVarName("rbdId" /* RBD_ID */);
    linesController.addDefinitions(this, [
      // do not use a ref, as it makes the object reactive
      new JsDefinition/* RefJsDefinition */.Z(this, linesController, connections_Js/* JsConnectionPointType.STRING */.zF.STRING, outRBDIds, `''`)
    ]);
    return outRBDIds;
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/js/CreatePhysicsRBDs.ts







var CreatePhysicsRBDsJsNodeInput = /* @__PURE__ */ ((CreatePhysicsRBDsJsNodeInput2) => {
  CreatePhysicsRBDsJsNodeInput2["OBJECT_3D"] = "rbdObject";
  CreatePhysicsRBDsJsNodeInput2["OBJECT_3DS"] = "rbdObjects";
  return CreatePhysicsRBDsJsNodeInput2;
})(CreatePhysicsRBDsJsNodeInput || {});
var CreatePhysicsRBDsJsNodeOutput = /* @__PURE__ */ ((CreatePhysicsRBDsJsNodeOutput2) => {
  CreatePhysicsRBDsJsNodeOutput2["RBD_ID"] = "RBDId";
  CreatePhysicsRBDsJsNodeOutput2["RBD_IDS"] = "RBDIds";
  return CreatePhysicsRBDsJsNodeOutput2;
})(CreatePhysicsRBDsJsNodeOutput || {});
class CreatePhysicsRBDsJsParamsConfig extends params_ParamsConfig/* NodeParamsConfig */.yI {
}
const CreatePhysicsRBDs_ParamsConfig = new CreatePhysicsRBDsJsParamsConfig();
class CreatePhysicsRBDsJsNode extends _BaseTriggerAndObject/* BaseTriggerAndObjectJsNode */.e {
  constructor() {
    super(...arguments);
    this.paramsConfig = CreatePhysicsRBDs_ParamsConfig;
  }
  static type() {
    return "createPhysicsRBDs";
  }
  initializeNode() {
    super.initializeNode();
    this.io.connection_points.set_input_name_function(this._expectedInputName.bind(this));
    this.io.connection_points.set_output_name_function(this._expectedOutputName.bind(this));
    this.io.connection_points.set_expected_input_types_function(this._expectedInputTypes.bind(this));
    this.io.connection_points.set_expected_output_types_function(this._expectedOutputTypes.bind(this));
  }
  _expectedInputName(index) {
    return [connections_Js/* JsConnectionPointType.TRIGGER */.zF.TRIGGER, connections_Js/* JsConnectionPointType.OBJECT_3D */.zF.OBJECT_3D, this._childInputName()][index];
  }
  _expectedOutputName(index) {
    return [connections_Js/* JsConnectionPointType.TRIGGER */.zF.TRIGGER, connections_Js/* JsConnectionPointType.OBJECT_3D */.zF.OBJECT_3D, this._childOutputName()][index];
  }
  _expectedInputTypes() {
    return [connections_Js/* JsConnectionPointType.TRIGGER */.zF.TRIGGER, connections_Js/* JsConnectionPointType.OBJECT_3D */.zF.OBJECT_3D, this._childInputType()];
  }
  _expectedOutputTypes() {
    return [connections_Js/* JsConnectionPointType.TRIGGER */.zF.TRIGGER, connections_Js/* JsConnectionPointType.OBJECT_3D */.zF.OBJECT_3D, this._childOutputType()];
  }
  _isInputArray() {
    const firstInputType = this.io.connection_points.input_connection_type(2);
    return firstInputType == connections_Js/* JsConnectionPointType.OBJECT_3D_ARRAY */.zF.OBJECT_3D_ARRAY;
  }
  _childInputName() {
    return this._isInputArray() ? "rbdObjects" /* OBJECT_3DS */ : "rbdObject" /* OBJECT_3D */;
  }
  _childOutputName() {
    return this._isInputArray() ? "RBDIds" /* RBD_IDS */ : "RBDId" /* RBD_ID */;
  }
  _childInputType() {
    return this._isInputArray() ? connections_Js/* JsConnectionPointType.OBJECT_3D_ARRAY */.zF.OBJECT_3D_ARRAY : connections_Js/* JsConnectionPointType.OBJECT_3D */.zF.OBJECT_3D;
  }
  _childOutputType() {
    return this._isInputArray() ? connections_Js/* JsConnectionPointType.STRING_ARRAY */.zF.STRING_ARRAY : connections_Js/* JsConnectionPointType.STRING */.zF.STRING;
  }
  setLines(linesController) {
    super.setLines(linesController);
    const outRBDIds = this._addRBDIdRef(linesController);
    const out = this.jsVarName(this._childOutputName());
    linesController.addBodyOrComputed(this, [
      { dataType: connections_Js/* JsConnectionPointType.OBJECT_3D */.zF.OBJECT_3D, varName: out, value: `this.${outRBDIds}.value` }
    ]);
  }
  setTriggerableLines(linesController) {
    const object3D = (0,_BaseObject3D/* inputObject3D */.iv)(this, linesController);
    const inputName = this._childInputName();
    const inputObjects = this.variableForInput(linesController, inputName);
    const functionName = this._isInputArray() ? "createPhysicsRBDs" : "createPhysicsRBD";
    const outRBDIds = this._addRBDIdRef(linesController);
    const func = Poly/* Poly.namedFunctionsRegister.getFunction */.L.namedFunctionsRegister.getFunction(functionName, this, linesController);
    const bodyLine = func.asString(object3D, inputObjects, `this.${outRBDIds}`);
    linesController.addTriggerableLines(this, [bodyLine]);
  }
  _addRBDIdRef(linesController) {
    const outRBDIds = this.jsVarName("rbdIds");
    linesController.addDefinitions(this, [
      // do not use a ref, as it makes the object reactive
      new JsDefinition/* RefJsDefinition */.Z(this, linesController, connections_Js/* JsConnectionPointType.STRING */.zF.STRING, outRBDIds, `''`)
    ]);
    return outRBDIds;
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/js/CreateSoftBodyConstraint.ts







var CreateSoftBodyConstraintOutput = /* @__PURE__ */ ((CreateSoftBodyConstraintOutput2) => {
  CreateSoftBodyConstraintOutput2["ID"] = "id";
  return CreateSoftBodyConstraintOutput2;
})(CreateSoftBodyConstraintOutput || {});
class CreateSoftBodyConstraintJsParamsConfig extends params_ParamsConfig/* NodeParamsConfig */.yI {
  constructor() {
    super(...arguments);
    this.index = params_ParamsConfig/* ParamConfig.INTEGER */.XC.INTEGER(0, {
      range: [-1, 100],
      rangeLocked: [true, false]
    });
  }
}
const CreateSoftBodyConstraint_ParamsConfig = new CreateSoftBodyConstraintJsParamsConfig();
class CreateSoftBodyConstraintJsNode extends _BaseTriggerAndObject/* BaseTriggerAndObjectJsNode */.e {
  constructor() {
    super(...arguments);
    this.paramsConfig = CreateSoftBodyConstraint_ParamsConfig;
  }
  static type() {
    return "createSoftBodyConstraint";
  }
  initializeNode() {
    super.initializeNode();
    this.io.outputs.setNamedOutputConnectionPoints([
      new connections_Js/* JsConnectionPoint */.fp(connections_Js/* JsConnectionPointType.TRIGGER */.zF.TRIGGER, connections_Js/* JsConnectionPointType.TRIGGER */.zF.TRIGGER),
      new connections_Js/* JsConnectionPoint */.fp(connections_Js/* JsConnectionPointType.OBJECT_3D */.zF.OBJECT_3D, connections_Js/* JsConnectionPointType.OBJECT_3D */.zF.OBJECT_3D),
      new connections_Js/* JsConnectionPoint */.fp("id" /* ID */, connections_Js/* JsConnectionPointType.INT */.zF.INT)
    ]);
  }
  setTriggerableLines(linesController) {
    const object3D = (0,_BaseObject3D/* inputObject3D */.iv)(this, linesController);
    const index = this.variableForInputParam(linesController, this.p.index);
    const outConstraintId = this._addConstraintIdRef(linesController);
    const func = Poly/* Poly.namedFunctionsRegister.getFunction */.L.namedFunctionsRegister.getFunction("softBodyConstraintCreate", this, linesController);
    const bodyLine = func.asString(object3D, index, `this.${outConstraintId}`);
    linesController.addTriggerableLines(this, [bodyLine]);
  }
  setLines(linesController) {
    super.setLines(linesController);
    const usedOutputNames = this.io.outputs.used_output_names();
    if (usedOutputNames.includes("id" /* ID */)) {
      this._addConstraintIdRef(linesController);
    }
  }
  _addConstraintIdRef(linesController) {
    const outConstraintId = this.jsVarName("id" /* ID */);
    linesController.addDefinitions(this, [
      new JsDefinition/* RefJsDefinition */.Z(this, linesController, connections_Js/* JsConnectionPointType.INT */.zF.INT, outConstraintId, `-1`)
    ]);
    return outConstraintId;
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/js/Cross.ts





var CrossJsNodeInputName = /* @__PURE__ */ ((CrossJsNodeInputName2) => {
  CrossJsNodeInputName2["VALUE0"] = "v0";
  CrossJsNodeInputName2["VALUE1"] = "v1";
  return CrossJsNodeInputName2;
})(CrossJsNodeInputName || {});
const Cross_DefaultValues = {
  ["v0" /* VALUE0 */]: 1,
  ["v1" /* VALUE1 */]: 1
};
const js_Cross_OUTPUT_NAME = "val";
const Cross_ALLOWED_INPUT_TYPES = [connections_Js/* JsConnectionPointType.VECTOR2 */.zF.VECTOR2, connections_Js/* JsConnectionPointType.VECTOR3 */.zF.VECTOR3];
function functionNameByType(type) {
  switch (type) {
    case connections_Js/* JsConnectionPointType.VECTOR2 */.zF.VECTOR2: {
      return "crossVector2";
    }
    case connections_Js/* JsConnectionPointType.VECTOR3 */.zF.VECTOR3: {
      return "crossVector3";
    }
  }
}
class CrossJsNode extends js_Base/* ParamlessTypedJsNode */.au {
  static type() {
    return "cross";
  }
  initializeNode() {
    super.initializeNode();
    this.io.connection_points.set_expected_input_types_function(this._expectedInputTypes.bind(this));
    this.io.connection_points.set_expected_output_types_function(this._expectedOutputTypes.bind(this));
    this.io.connection_points.set_input_name_function(this._expectedInputName.bind(this));
    this.io.connection_points.set_output_name_function(this._expectedOutputName.bind(this));
  }
  setLines(shadersCollectionController) {
    const value0 = this.variableForInput(shadersCollectionController, "v0" /* VALUE0 */);
    const value1 = this.variableForInput(shadersCollectionController, "v1" /* VALUE1 */);
    const varName = this.jsVarName(this._expectedOutputName(0));
    const inputType = this._expectedInputTypes()[0];
    const variable = (0,_BaseJsPersistedConfigUtils/* createVariable */.Os)(inputType);
    const tmpVarName = variable ? shadersCollectionController.addVariable(this, variable) : void 0;
    const functionName = functionNameByType(inputType);
    if (functionName && tmpVarName) {
      const func = Poly/* Poly.namedFunctionsRegister.getFunction */.L.namedFunctionsRegister.getFunction(functionName, this, shadersCollectionController);
      shadersCollectionController.addBodyOrComputed(this, [
        { dataType: inputType, varName, value: func.asString(value0, value1, tmpVarName) }
      ]);
      return;
    }
  }
  _expectedInputTypes() {
    const firstType = this.io.connection_points.first_input_connection_type();
    const type = firstType && Cross_ALLOWED_INPUT_TYPES.includes(firstType) ? firstType : connections_Js/* JsConnectionPointType.VECTOR3 */.zF.VECTOR3;
    return [type, type];
  }
  _expectedOutputTypes() {
    const inputType = this._expectedInputTypes()[0];
    const elementInputType = connections_Js/* JsConnectionPointTypeFromArrayTypeMap */.RR[inputType];
    function arrayOrElement(type) {
      return (0,connections_Js/* isJsConnectionPointArray */.$c)(inputType) ? connections_Js/* JsConnectionPointTypeToArrayTypeMap */.RC[type] : type;
    }
    function _outputType() {
      switch (elementInputType) {
        case connections_Js/* JsConnectionPointType.VECTOR2 */.zF.VECTOR2: {
          return arrayOrElement(connections_Js/* JsConnectionPointType.FLOAT */.zF.FLOAT);
        }
        case connections_Js/* JsConnectionPointType.VECTOR3 */.zF.VECTOR3: {
          return arrayOrElement(connections_Js/* JsConnectionPointType.VECTOR3 */.zF.VECTOR3);
        }
      }
      return arrayOrElement(connections_Js/* JsConnectionPointType.VECTOR3 */.zF.VECTOR3);
    }
    return [_outputType()];
  }
  _expectedInputName(index) {
    return ["v0" /* VALUE0 */, "v1" /* VALUE1 */][index];
  }
  _expectedOutputName(index) {
    return js_Cross_OUTPUT_NAME;
  }
  paramDefaultValue(name) {
    return Cross_DefaultValues[name];
  }
}

// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/nodes/js/Cursor.ts
var Cursor = __webpack_require__(30645);
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/js/CursorToUv.ts






const CursorToUv_CONNECTION_OPTIONS = connections_Js/* JS_CONNECTION_POINT_IN_NODE_DEF */.mX;
var CursorToUvJsNodeOutputName = /* @__PURE__ */ ((CursorToUvJsNodeOutputName2) => {
  CursorToUvJsNodeOutputName2["uv"] = "uv";
  return CursorToUvJsNodeOutputName2;
})(CursorToUvJsNodeOutputName || {});
class CursorToUvJsParamsConfig extends params_ParamsConfig/* NodeParamsConfig */.yI {
  constructor() {
    super(...arguments);
    this.cursor = params_ParamsConfig/* ParamConfig.VECTOR2 */.XC.VECTOR2([0, 0]);
  }
}
const CursorToUv_ParamsConfig = new CursorToUvJsParamsConfig();
class CursorToUvJsNode extends js_Base/* TypedJsNode */.xZ {
  constructor() {
    super(...arguments);
    this.paramsConfig = CursorToUv_ParamsConfig;
  }
  static type() {
    return "cursorToUv";
  }
  initializeNode() {
    this.io.outputs.setNamedOutputConnectionPoints([
      new connections_Js/* JsConnectionPoint */.fp("uv" /* uv */, connections_Js/* JsConnectionPointType.VECTOR2 */.zF.VECTOR2, CursorToUv_CONNECTION_OPTIONS)
    ]);
  }
  setLines(linesController) {
    const cursor = this.variableForInputParam(linesController, this.p.cursor);
    const varName = this.jsVarName("uv" /* uv */);
    const tmpVarName = linesController.addVariable(this, new three_module.Vector2());
    const func = Poly/* Poly.namedFunctionsRegister.getFunction */.L.namedFunctionsRegister.getFunction("cursorToUv", this, linesController);
    linesController.addBodyOrComputed(this, [
      { dataType: connections_Js/* JsConnectionPointType.VECTOR2 */.zF.VECTOR2, varName, value: func.asString(cursor, tmpVarName) }
    ]);
  }
}

// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/nodes/js/Debug.ts
var Debug = __webpack_require__(87943);
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/core/geometry/operation/CubeLatticeDeform.ts



const DEFAULT_POSITIONS = [
  new three_module.Vector3(0, 0, 0),
  new three_module.Vector3(1, 0, 0),
  new three_module.Vector3(1, 0, 1),
  new three_module.Vector3(0, 0, 1),
  //
  new three_module.Vector3(0, 1, 0),
  new three_module.Vector3(1, 1, 0),
  new three_module.Vector3(1, 1, 1),
  new three_module.Vector3(0, 1, 1)
];
const _v3 = new three_module.Vector3();
const lb0 = new three_module.Line3();
const lb1 = new three_module.Line3();
const lt0 = new three_module.Line3();
const lt1 = new three_module.Line3();
const pb0 = new three_module.Vector3();
const pb1 = new three_module.Vector3();
const pt0 = new three_module.Vector3();
const pt1 = new three_module.Vector3();
const pb = new three_module.Vector3();
const pt = new three_module.Vector3();
const target = new three_module.Vector3();
const _box3 = new three_module.Box3();
const _box3Size = new three_module.Vector3();
const _originalObjectPosition = new three_module.Vector3();
const _positionDelta = new three_module.Vector3();
const _positionRatio = new three_module.Vector3();
function CubeLatticeDeform_cubeLatticeDeform(object, points, options) {
  const geometry = object.geometry;
  if (!geometry) {
    return;
  }
  const positionAttribute = geometry.attributes[geometry_Attribute/* Attribute.POSITION */.ah.POSITION];
  if (!positionAttribute) {
    return;
  }
  const positionArray = positionAttribute.array;
  const { offset, moveObjectPosition } = options;
  if (moveObjectPosition) {
    _box3.setFromObject(object);
    _box3.getSize(_box3Size);
    _originalObjectPosition.copy(object.position);
    _positionRatio.copy(object.position).sub(_box3.min).divide(_box3Size);
  }
  lb0.start = points[0];
  lb0.end = points[1];
  lb1.start = points[3];
  lb1.end = points[2];
  lt0.start = points[4];
  lt0.end = points[5];
  lt1.start = points[7];
  lt1.end = points[6];
  const pointsCount = positionArray.length / 3;
  for (let i = 0; i < pointsCount; i++) {
    _v3.fromArray(positionArray, i * 3);
    _v3.add(offset);
    interpolate(_v3, lb0, lb1, lt0, lt1, target);
    target.toArray(positionArray, i * 3);
  }
  if (moveObjectPosition) {
    geometry.computeBoundingBox();
    _box3.setFromObject(object);
    _box3.getCenter(_positionDelta);
    _positionDelta.sub(_originalObjectPosition);
    object.position.add(_positionDelta);
    object.updateMatrix();
    for (let i = 0; i < pointsCount; i++) {
      _v3.fromArray(positionArray, i * 3);
      _v3.sub(_positionDelta);
      _v3.toArray(positionArray, i * 3);
    }
  }
  positionAttribute.needsUpdate = true;
  geometry.computeVertexNormals();
}
function interpolate(p, lb02, lb12, lt02, lt12, target2) {
  pb0.copy(lb02.start).lerp(lb02.end, p.x);
  pb1.copy(lb12.start).lerp(lb12.end, p.x);
  pt0.copy(lt02.start).lerp(lt02.end, p.x);
  pt1.copy(lt12.start).lerp(lt12.end, p.x);
  pb.copy(pb0).lerp(pb1, p.z);
  pt.copy(pt0).lerp(pt1, p.z);
  target2.copy(pb).lerp(pt, p.y);
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/js/DeformGeometryCubeLattice.ts







const DeformGeometryCubeLattice_CONNECTION_OPTIONS = connections_Js/* JS_CONNECTION_POINT_IN_NODE_DEF */.mX;
class DeformGeometryCubeLatticeJsParamsConfig extends params_ParamsConfig/* NodeParamsConfig */.yI {
  constructor() {
    super(...arguments);
    this.p0 = params_ParamsConfig/* ParamConfig.VECTOR3 */.XC.VECTOR3(DEFAULT_POSITIONS[0]);
    this.p1 = params_ParamsConfig/* ParamConfig.VECTOR3 */.XC.VECTOR3(DEFAULT_POSITIONS[1]);
    this.p2 = params_ParamsConfig/* ParamConfig.VECTOR3 */.XC.VECTOR3(DEFAULT_POSITIONS[2]);
    this.p3 = params_ParamsConfig/* ParamConfig.VECTOR3 */.XC.VECTOR3(DEFAULT_POSITIONS[3]);
    this.p4 = params_ParamsConfig/* ParamConfig.VECTOR3 */.XC.VECTOR3(DEFAULT_POSITIONS[4]);
    this.p5 = params_ParamsConfig/* ParamConfig.VECTOR3 */.XC.VECTOR3(DEFAULT_POSITIONS[5]);
    this.p6 = params_ParamsConfig/* ParamConfig.VECTOR3 */.XC.VECTOR3(DEFAULT_POSITIONS[6]);
    this.p7 = params_ParamsConfig/* ParamConfig.VECTOR3 */.XC.VECTOR3(DEFAULT_POSITIONS[7]);
  }
}
const DeformGeometryCubeLattice_ParamsConfig = new DeformGeometryCubeLatticeJsParamsConfig();
class DeformGeometryCubeLatticeJsNode extends js_Base/* TypedJsNode */.xZ {
  constructor() {
    super(...arguments);
    this.paramsConfig = DeformGeometryCubeLattice_ParamsConfig;
  }
  static type() {
    return "deformGeometryCubeLattice";
  }
  initializeNode() {
    this.io.inputs.setNamedInputConnectionPoints([
      new connections_Js/* JsConnectionPoint */.fp(js_Base/* TRIGGER_CONNECTION_NAME */.w6, connections_Js/* JsConnectionPointType.TRIGGER */.zF.TRIGGER, DeformGeometryCubeLattice_CONNECTION_OPTIONS),
      new connections_Js/* JsConnectionPoint */.fp(connections_Js/* JsConnectionPointType.OBJECT_3D */.zF.OBJECT_3D, connections_Js/* JsConnectionPointType.OBJECT_3D */.zF.OBJECT_3D, DeformGeometryCubeLattice_CONNECTION_OPTIONS)
    ]);
    this.io.outputs.setNamedOutputConnectionPoints([
      new connections_Js/* JsConnectionPoint */.fp(js_Base/* TRIGGER_CONNECTION_NAME */.w6, connections_Js/* JsConnectionPointType.TRIGGER */.zF.TRIGGER)
    ]);
  }
  setTriggerableLines(shadersCollectionController) {
    const object3D = (0,_BaseObject3D/* inputObject3D */.iv)(this, shadersCollectionController);
    const p0 = this.variableForInputParam(shadersCollectionController, this.p.p0);
    const p1 = this.variableForInputParam(shadersCollectionController, this.p.p1);
    const p2 = this.variableForInputParam(shadersCollectionController, this.p.p2);
    const p3 = this.variableForInputParam(shadersCollectionController, this.p.p3);
    const p4 = this.variableForInputParam(shadersCollectionController, this.p.p4);
    const p5 = this.variableForInputParam(shadersCollectionController, this.p.p5);
    const p6 = this.variableForInputParam(shadersCollectionController, this.p.p6);
    const p7 = this.variableForInputParam(shadersCollectionController, this.p.p7);
    const pointsStr = [p0, p1, p2, p3, p4, p5, p6, p7];
    const pointsJSON = JSON.stringify(pointsStr).replace(/"/g, "");
    const func = Poly/* Poly.namedFunctionsRegister.getFunction */.L.namedFunctionsRegister.getFunction("cubeLatticeDeform", this, shadersCollectionController);
    const bodyLine = func.asString(object3D, pointsJSON);
    shadersCollectionController.addTriggerableLines(this, [bodyLine]);
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/js/DeleteClothConstraint.ts





class DeleteClothConstraintJsParamsConfig extends params_ParamsConfig/* NodeParamsConfig */.yI {
}
const DeleteClothConstraint_ParamsConfig = new DeleteClothConstraintJsParamsConfig();
class DeleteClothConstraintJsNode extends _BaseTriggerAndObject/* BaseTriggerAndObjectJsNode */.e {
  constructor() {
    super(...arguments);
    this.paramsConfig = DeleteClothConstraint_ParamsConfig;
  }
  static type() {
    return "deleteClothConstraint";
  }
  setTriggerableLines(linesController) {
    const object3D = (0,_BaseObject3D/* inputObject3D */.iv)(this, linesController);
    const func = Poly/* Poly.namedFunctionsRegister.getFunction */.L.namedFunctionsRegister.getFunction("clothDeleteConstraint", this, linesController);
    const bodyLine = func.asString(object3D);
    linesController.addTriggerableLines(this, [bodyLine]);
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/js/DeleteObject.ts





class DeleteObjectJsParamsConfig extends params_ParamsConfig/* NodeParamsConfig */.yI {
}
const DeleteObject_ParamsConfig = new DeleteObjectJsParamsConfig();
class DeleteObjectJsNode extends _BaseTriggerAndObject/* BaseTriggerAndObjectJsNode */.e {
  constructor() {
    super(...arguments);
    this.paramsConfig = DeleteObject_ParamsConfig;
  }
  static type() {
    return "deleteObject";
  }
  setTriggerableLines(linesController) {
    const object3D = (0,_BaseObject3D/* inputObject3D */.iv)(this, linesController);
    const func = Poly/* Poly.namedFunctionsRegister.getFunction */.L.namedFunctionsRegister.getFunction("objectDelete", this, linesController);
    const bodyLine = func.asString(object3D);
    linesController.addTriggerableLines(this, [bodyLine]);
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/js/DeletePhysicsRBD.ts





class DeletePhysicsRBDJsParamsConfig extends params_ParamsConfig/* NodeParamsConfig */.yI {
}
const DeletePhysicsRBD_ParamsConfig = new DeletePhysicsRBDJsParamsConfig();
class DeletePhysicsRBDJsNode extends _BaseTriggerAndObject/* BaseTriggerAndObjectJsNode */.e {
  constructor() {
    super(...arguments);
    this.paramsConfig = DeletePhysicsRBD_ParamsConfig;
  }
  static type() {
    return "deletePhysicsRBD";
  }
  setTriggerableLines(linesController) {
    const object3D = (0,_BaseObject3D/* inputObject3D */.iv)(this, linesController);
    const func = Poly/* Poly.namedFunctionsRegister.getFunction */.L.namedFunctionsRegister.getFunction("physicsRBDDelete", this, linesController);
    const bodyLine = func.asString(object3D);
    linesController.addTriggerableLines(this, [bodyLine]);
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/js/DeletePhysicsRBDKinematicConstraint.ts





class DeletePhysicsRBDKinematicConstraintJsParamsConfig extends params_ParamsConfig/* NodeParamsConfig */.yI {
}
const DeletePhysicsRBDKinematicConstraint_ParamsConfig = new DeletePhysicsRBDKinematicConstraintJsParamsConfig();
class DeletePhysicsRBDKinematicConstraintJsNode extends _BaseTriggerAndObject/* BaseTriggerAndObjectJsNode */.e {
  constructor() {
    super(...arguments);
    this.paramsConfig = DeletePhysicsRBDKinematicConstraint_ParamsConfig;
  }
  static type() {
    return "deletePhysicsRBDKinematicConstraint";
  }
  setTriggerableLines(linesController) {
    const object3D = (0,_BaseObject3D/* inputObject3D */.iv)(this, linesController);
    const func = Poly/* Poly.namedFunctionsRegister.getFunction */.L.namedFunctionsRegister.getFunction(
      "deletePhysicsRBDKinematicConstraint",
      this,
      linesController
    );
    const bodyLine = func.asString(object3D);
    linesController.addTriggerableLines(this, [bodyLine]);
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/js/DeletePhysicsRBDConstraints.ts





class DeletePhysicsRBDConstraintsJsParamsConfig extends params_ParamsConfig/* NodeParamsConfig */.yI {
}
const DeletePhysicsRBDConstraints_ParamsConfig = new DeletePhysicsRBDConstraintsJsParamsConfig();
class DeletePhysicsRBDConstraintsJsNode extends _BaseTriggerAndObject/* BaseTriggerAndObjectJsNode */.e {
  constructor() {
    super(...arguments);
    this.paramsConfig = DeletePhysicsRBDConstraints_ParamsConfig;
  }
  static type() {
    return "deletePhysicsRBDConstraints";
  }
  setTriggerableLines(linesController) {
    const object3D = (0,_BaseObject3D/* inputObject3D */.iv)(this, linesController);
    const func = Poly/* Poly.namedFunctionsRegister.getFunction */.L.namedFunctionsRegister.getFunction("deletePhysicsRBDConstraints", this, linesController);
    const bodyLine = func.asString(object3D);
    linesController.addTriggerableLines(this, [bodyLine]);
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/js/DeleteSoftBodyConstraint.ts





class DeleteSoftBodyConstraintJsParamsConfig extends params_ParamsConfig/* NodeParamsConfig */.yI {
  constructor() {
    super(...arguments);
    this.id = params_ParamsConfig/* ParamConfig.INTEGER */.XC.INTEGER(0, {
      range: [-1, 100],
      rangeLocked: [true, false]
    });
  }
}
const DeleteSoftBodyConstraint_ParamsConfig = new DeleteSoftBodyConstraintJsParamsConfig();
class DeleteSoftBodyConstraintJsNode extends _BaseTriggerAndObject/* BaseTriggerAndObjectJsNode */.e {
  constructor() {
    super(...arguments);
    this.paramsConfig = DeleteSoftBodyConstraint_ParamsConfig;
  }
  static type() {
    return "deleteSoftBodyConstraint";
  }
  setTriggerableLines(shadersCollectionController) {
    const object3D = (0,_BaseObject3D/* inputObject3D */.iv)(this, shadersCollectionController);
    const id = this.variableForInputParam(shadersCollectionController, this.p.id);
    const func = Poly/* Poly.namedFunctionsRegister.getFunction */.L.namedFunctionsRegister.getFunction(
      "softBodyConstraintDelete",
      this,
      shadersCollectionController
    );
    const bodyLine = func.asString(object3D, id);
    shadersCollectionController.addTriggerableLines(this, [bodyLine]);
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/js/DegToRad.ts



const DegToRad_FUNCTION_NAME = "degToRad";
class DegToRadJsNode extends MathFunctionArg1OperationFactory("degToRad", {
  inputPrefix: "in",
  out: "out"
}) {
  _coreFunction(shadersCollectionController) {
    Poly/* Poly.namedFunctionsRegister.getFunction */.L.namedFunctionsRegister.getFunction(DegToRad_FUNCTION_NAME, this, shadersCollectionController).asString("");
    return DegToRad_FUNCTION_NAME;
  }
}

// EXTERNAL MODULE: ../@polygonjs/polygonjs/node_modules/three/src/math/MathUtils.js
var MathUtils = __webpack_require__(3972);
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/core/camera/controls/DeviceOrientationControlsUtils.ts



const CHANGE_EVENT = { type: "change" };
const DeviceOrientationControlsUtils_EPS = 1e-6;
const PI_DEG = (0,MathUtils/* radToDeg */.ZY)(Math.PI);
const PI_DEG2 = 2 * (0,MathUtils/* radToDeg */.ZY)(Math.PI);
const AXIS_Z = new three_module.Vector3(0, 0, 1);
const euler = new three_module.Euler();
const q0 = new three_module.Quaternion();
const q1 = new three_module.Quaternion(-Math.sqrt(0.5), 0, 0, Math.sqrt(0.5));
const q2 = new three_module.Quaternion();
const ROTATION_ORDER_YXZ = "YXZ";
function _setQuaternionFromAlphaBetaGamma(alpha, beta, gamma, orient, target) {
  euler.set(beta, alpha, -gamma, ROTATION_ORDER_YXZ);
  target.setFromEuler(euler);
  target.multiply(q1);
  target.multiply(q0.setFromAxisAngle(AXIS_Z, -orient));
}
const alphaOffset = 0;
function setQuaternionFromEvent(event, screenOrientation, target) {
  const alpha = event.alpha ? (0,MathUtils/* degToRad */.Id)(event.alpha) + alphaOffset : 0;
  const beta = event.beta ? (0,MathUtils/* degToRad */.Id)(event.beta) : 0;
  const gamma = event.gamma ? (0,MathUtils/* degToRad */.Id)(event.gamma) : 0;
  const orient = screenOrientation ? (0,MathUtils/* degToRad */.Id)(screenOrientation) : 0;
  _setQuaternionFromAlphaBetaGamma(alpha, beta, gamma, orient, target);
}
function quaternionYAngle(relativeQuaternion) {
  euler.setFromQuaternion(relativeQuaternion);
  return -(0,MathUtils/* radToDeg */.ZY)(euler.y);
}
function yAngleFromEvent(event, screenOrientation) {
  setQuaternionFromEvent(event, screenOrientation, q2);
  return quaternionYAngle(q2);
}
function _createObjects() {
  const ryOffset = new three_module.Object3D();
  const ry = new three_module.Object3D();
  const rx = new three_module.Object3D();
  const rz = new three_module.Object3D();
  ryOffset.add(ry);
  ry.add(rx);
  rx.add(rz);
  return {
    ryOffset,
    ry,
    rx,
    rz
  };
}
let _rotationHierarchy;
function _getRotationHierarchy() {
  return _rotationHierarchy || (_rotationHierarchy = _createObjects());
}
function blendQuaternionToAbsoluteYAngle(relativeQuaternion, yAngleOffset, target) {
  euler.setFromQuaternion(relativeQuaternion);
  const rotationHierarchy = _getRotationHierarchy();
  rotationHierarchy.ryOffset.rotation.set(0, -(0,MathUtils/* degToRad */.Id)(yAngleOffset), 0);
  rotationHierarchy.ry.rotation.set(0, euler.y, 0);
  rotationHierarchy.rx.rotation.set(euler.x, 0, 0);
  rotationHierarchy.rz.rotation.set(0, 0, euler.z);
  rotationHierarchy.rz.updateWorldMatrix(true, true);
  target.setFromRotationMatrix(rotationHierarchy.rz.matrixWorld);
}

// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/core/UserAgent.ts
var UserAgent = __webpack_require__(66689);
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/core/camera/controls/DeviceOrientationControls.ts




const DEFAULT_SMOOTH_AMOUNT = 0.01;
const COMPASS_READJUST_TIMESTEP_START = 1e3;
const COMPASS_READJUST_TIMESTEP_MAX = 5e3;
const COMPASS_READJUST_TIMESTEP_INCREMENT = 1e3;
class DeviceOrientationControls extends three_module.EventDispatcher {
  constructor() {
    super();
    this._relativeQuaternion = new three_module.Quaternion();
    this._blendedQuaternion = new three_module.Quaternion();
    this.enabled = true;
    this._relativeEvent = { alpha: 0, beta: 0, gamma: 0 };
    this._screenOrientation = 0;
    this.alphaOffset = 0;
    // radians
    this._smoothAmount = DEFAULT_SMOOTH_AMOUNT;
    this._currentYAngleOffset = 0;
    this._targetYAngleOffset = 0;
    this._compassReadjustTimestep = COMPASS_READJUST_TIMESTEP_START;
    // in milliseconds
    this._absoluteYAngleProcessedAt = -1;
    this._bound = {
      onDeviceOrientationChangeEvent: this.onDeviceOrientationChangeEvent.bind(this),
      onDeviceOrientationAbsoluteChangeEvent: this.onDeviceOrientationAbsoluteChangeEvent.bind(this),
      onScreenOrientationChangeEvent: this.onScreenOrientationChangeEvent.bind(this)
    };
    this.lastQuaternion = new three_module.Quaternion();
    this.dispose = () => this.disconnect();
    this.connect();
  }
  onDeviceOrientationChangeEvent(event) {
    this._relativeEvent = event;
    const webkitCompassHeading = event.webkitCompassHeading;
    if (webkitCompassHeading != null) {
      this._setAbsoluteAngleY(webkitCompassHeading + this._screenOrientation);
    }
  }
  onDeviceOrientationAbsoluteChangeEvent(event) {
    if (event.alpha == null) {
      return;
    }
    const yAngleAbsolute = yAngleFromEvent(event, this._screenOrientation);
    this._setAbsoluteAngleY(yAngleAbsolute);
  }
  _setAbsoluteAngleY(y) {
    this._absoluteYAngle = y;
  }
  onScreenOrientationChangeEvent() {
    this._screenOrientation = (0,UserAgent/* screenOrientation */.fc)();
    this._absoluteYAngleProcessedAt = -1;
  }
  connect() {
    this.onScreenOrientationChangeEvent();
    if (window.DeviceOrientationEvent !== void 0 && // @ts-ignore
    typeof window.DeviceOrientationEvent.requestPermission === "function") {
      window.DeviceOrientationEvent.requestPermission().then((response) => {
        if (response == "granted") {
          window.addEventListener("orientationchange", this._bound.onScreenOrientationChangeEvent);
          window.addEventListener("deviceorientation", this._bound.onDeviceOrientationChangeEvent);
          window.addEventListener(
            "deviceorientationabsolute",
            this._bound.onDeviceOrientationAbsoluteChangeEvent
          );
        }
      }).catch((error) => {
        console.error("THREE.DeviceOrientationControls: Unable to use DeviceOrientation API:", error);
      });
    } else {
      window.addEventListener("orientationchange", this._bound.onScreenOrientationChangeEvent);
      window.addEventListener("deviceorientation", this._bound.onDeviceOrientationChangeEvent);
      window.addEventListener("deviceorientationabsolute", this._bound.onDeviceOrientationAbsoluteChangeEvent);
    }
    this.enabled = true;
  }
  disconnect() {
    window.removeEventListener("orientationchange", this.onScreenOrientationChangeEvent);
    window.removeEventListener("deviceorientation", this.onDeviceOrientationChangeEvent);
    this.enabled = false;
  }
  update() {
    if (this.enabled === false)
      return;
    setQuaternionFromEvent(this._relativeEvent, this._screenOrientation, this._relativeQuaternion);
    const currentYAngle = quaternionYAngle(this._relativeQuaternion);
    const now = performance.now();
    const timeSinceLastCompassReadjust = now - this._absoluteYAngleProcessedAt;
    const updateYAngleRequired = this._absoluteYAngleProcessedAt < 0 || timeSinceLastCompassReadjust > this._compassReadjustTimestep;
    if (updateYAngleRequired && this._absoluteYAngle != null) {
      this._targetYAngleOffset = this._absoluteYAngle - currentYAngle;
      if (Math.abs(this._targetYAngleOffset) > PI_DEG) {
        if (this._targetYAngleOffset > 0) {
          this._targetYAngleOffset -= PI_DEG2;
        } else {
          this._targetYAngleOffset += PI_DEG2;
        }
      }
      const delta = this._targetYAngleOffset - this._currentYAngleOffset;
      if (Math.abs(delta) > PI_DEG) {
        if (delta > 0) {
          this._targetYAngleOffset -= PI_DEG2;
        } else {
          this._targetYAngleOffset += PI_DEG2;
        }
      }
      this._absoluteYAngle = void 0;
      this._absoluteYAngleProcessedAt = now;
      this._compassReadjustTimestep = Math.min(
        this._compassReadjustTimestep + COMPASS_READJUST_TIMESTEP_INCREMENT,
        COMPASS_READJUST_TIMESTEP_MAX
      );
    }
    this._currentYAngleOffset = (1 - this._smoothAmount) * this._currentYAngleOffset + this._smoothAmount * this._targetYAngleOffset;
    blendQuaternionToAbsoluteYAngle(this._relativeQuaternion, this._currentYAngleOffset, this._blendedQuaternion);
    if (8 * (1 - this.lastQuaternion.dot(this._blendedQuaternion)) > DeviceOrientationControlsUtils_EPS) {
      this.lastQuaternion.copy(this._blendedQuaternion);
      this.dispatchEvent(CHANGE_EVENT);
    }
  }
  quaternion(target) {
    target.copy(this._blendedQuaternion);
  }
  setSmoothAmount(smoothAmount) {
    this._smoothAmount = smoothAmount;
  }
}


;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/js/DeviceOrientation.ts








class DeviceOrientationJsParamsConfig extends params_ParamsConfig/* NodeParamsConfig */.yI {
  constructor() {
    super(...arguments);
    this.smoothAmount = params_ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(DEFAULT_SMOOTH_AMOUNT, {
      range: [0, 1],
      rangeLocked: [true, true]
    });
  }
}
const DeviceOrientation_ParamsConfig = new DeviceOrientationJsParamsConfig();
class DeviceOrientationJsNode extends js_Base/* TypedJsNode */.xZ {
  constructor() {
    super(...arguments);
    this.paramsConfig = DeviceOrientation_ParamsConfig;
  }
  static type() {
    return "deviceOrientation";
  }
  initializeNode() {
    super.initializeNode();
    this.io.outputs.setNamedOutputConnectionPoints([
      new connections_Js/* JsConnectionPoint */.fp(connections_Js/* JsConnectionPointType.QUATERNION */.zF.QUATERNION, connections_Js/* JsConnectionPointType.QUATERNION */.zF.QUATERNION)
    ]);
  }
  setLines(linesController) {
    const varName = this.jsVarName(connections_Js/* JsConnectionPointType.QUATERNION */.zF.QUATERNION);
    const smoothAmount = this.variableForInputParam(linesController, this.p.smoothAmount);
    const func = Poly/* Poly.namedFunctionsRegister.getFunction */.L.namedFunctionsRegister.getFunction("deviceOrientation", this, linesController);
    const variable = (0,_BaseJsPersistedConfigUtils/* createVariable */.Os)(connections_Js/* JsConnectionPointType.QUATERNION */.zF.QUATERNION);
    if (variable) {
      const tmpVarName = linesController.addVariable(this, variable);
      linesController.addDefinitions(this, [
        new JsDefinition/* ComputedValueJsDefinition */.fV(
          this,
          linesController,
          connections_Js/* JsConnectionPointType.QUATERNION */.zF.QUATERNION,
          varName,
          func.asString(tmpVarName, smoothAmount)
        )
      ]);
    }
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/js/Distance.ts




var DistanceJsNodeInputName = /* @__PURE__ */ ((DistanceJsNodeInputName2) => {
  DistanceJsNodeInputName2["VALUE0"] = "v0";
  DistanceJsNodeInputName2["VALUE1"] = "v1";
  return DistanceJsNodeInputName2;
})(DistanceJsNodeInputName || {});
const Distance_DefaultValues = {
  ["v0" /* VALUE0 */]: [1, 0, 0],
  ["v1" /* VALUE1 */]: [0, 1, 0]
};
const Distance_OUTPUT_NAME = "val";
const Distance_ALLOWED_INPUT_TYPES = [connections_Js/* JsConnectionPointType.VECTOR2 */.zF.VECTOR2, connections_Js/* JsConnectionPointType.VECTOR3 */.zF.VECTOR3];
function Distance_functionNameByType(type) {
  switch (type) {
    case connections_Js/* JsConnectionPointType.VECTOR2 */.zF.VECTOR2: {
      return "distanceVector2";
    }
    case connections_Js/* JsConnectionPointType.VECTOR3 */.zF.VECTOR3: {
      return "distanceVector3";
    }
  }
}
class DistanceJsNode extends js_Base/* ParamlessTypedJsNode */.au {
  static type() {
    return "distance";
  }
  initializeNode() {
    super.initializeNode();
    this.io.connection_points.set_expected_input_types_function(this._expectedInputTypes.bind(this));
    this.io.connection_points.set_expected_output_types_function(this._expectedOutputTypes.bind(this));
    this.io.connection_points.set_input_name_function(this._expectedInputName.bind(this));
    this.io.connection_points.set_output_name_function(this._expectedOutputName.bind(this));
  }
  setLines(shadersCollectionController) {
    const value0 = this.variableForInput(shadersCollectionController, "v0" /* VALUE0 */);
    const value1 = this.variableForInput(shadersCollectionController, "v1" /* VALUE1 */);
    const varName = this.jsVarName(this._expectedOutputName(0));
    const inputType = this._expectedInputTypes()[0];
    const functionName = Distance_functionNameByType(inputType);
    if (functionName) {
      const func = Poly/* Poly.namedFunctionsRegister.getFunction */.L.namedFunctionsRegister.getFunction(functionName, this, shadersCollectionController);
      shadersCollectionController.addBodyOrComputed(this, [
        { dataType: inputType, varName, value: func.asString(value0, value1) }
      ]);
      return;
    }
  }
  _expectedInputTypes() {
    const firstType = this.io.connection_points.first_input_connection_type();
    const type = firstType && Distance_ALLOWED_INPUT_TYPES.includes(firstType) ? firstType : connections_Js/* JsConnectionPointType.VECTOR3 */.zF.VECTOR3;
    return [type, type];
  }
  _expectedOutputTypes() {
    const inputType = this._expectedInputTypes()[0];
    const outputType = (0,connections_Js/* isJsConnectionPointArray */.$c)(inputType) ? connections_Js/* JsConnectionPointType.FLOAT_ARRAY */.zF.FLOAT_ARRAY : connections_Js/* JsConnectionPointType.FLOAT */.zF.FLOAT;
    return [outputType];
  }
  _expectedInputName(index) {
    return ["v0" /* VALUE0 */, "v1" /* VALUE1 */][index];
  }
  _expectedOutputName(index) {
    return Distance_OUTPUT_NAME;
  }
  paramDefaultValue(name) {
    return Distance_DefaultValues[name];
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/js/Divide.ts


class DivideJsNode extends MathFunctionArgNOperationFactory("divide", {
  inputPrefix: "div",
  out: "divide",
  operator: {
    primitive: "divideNumber",
    // vector: 'multVector',
    vectorScalar: "divideVectorNumber"
  }
}) {
  paramDefaultValue(name) {
    return 1;
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/js/Dot.ts





var DotJsNodeInputName = /* @__PURE__ */ ((DotJsNodeInputName2) => {
  DotJsNodeInputName2["VALUE0"] = "v0";
  DotJsNodeInputName2["VALUE1"] = "v1";
  return DotJsNodeInputName2;
})(DotJsNodeInputName || {});
const Dot_DefaultValues = {
  ["v0" /* VALUE0 */]: 1,
  ["v1" /* VALUE1 */]: 1
};
const Dot_OUTPUT_NAME = "val";
const Dot_ALLOWED_INPUT_TYPES = [connections_Js/* JsConnectionPointType.VECTOR2 */.zF.VECTOR2, connections_Js/* JsConnectionPointType.VECTOR3 */.zF.VECTOR3];
function Dot_functionNameByType(type) {
  switch (type) {
    case connections_Js/* JsConnectionPointType.VECTOR2 */.zF.VECTOR2: {
      return "dotVector2";
    }
    case connections_Js/* JsConnectionPointType.VECTOR3 */.zF.VECTOR3: {
      return "dotVector3";
    }
  }
}
class DotJsNode extends js_Base/* ParamlessTypedJsNode */.au {
  static type() {
    return "dot";
  }
  initializeNode() {
    super.initializeNode();
    this.io.connection_points.set_expected_input_types_function(this._expectedInputTypes.bind(this));
    this.io.connection_points.set_expected_output_types_function(this._expectedOutputTypes.bind(this));
    this.io.connection_points.set_input_name_function(this._expectedInputName.bind(this));
    this.io.connection_points.set_output_name_function(this._expectedOutputName.bind(this));
  }
  setLines(shadersCollectionController) {
    const value0 = this.variableForInput(shadersCollectionController, "v0" /* VALUE0 */);
    const value1 = this.variableForInput(shadersCollectionController, "v1" /* VALUE1 */);
    const varName = this.jsVarName(this._expectedOutputName(0));
    const inputType = this._expectedInputTypes()[0];
    if ((0,connections_Js/* isJsConnectionPointArray */.$c)(inputType)) {
      const variable = (0,_BaseJsPersistedConfigUtils/* createVariable */.Os)(inputType);
      if (variable) {
        shadersCollectionController.addVariable(this, variable);
      }
    }
    const functionName = Dot_functionNameByType(inputType);
    if (functionName) {
      const func = Poly/* Poly.namedFunctionsRegister.getFunction */.L.namedFunctionsRegister.getFunction(functionName, this, shadersCollectionController);
      shadersCollectionController.addBodyOrComputed(this, [
        { dataType: inputType, varName, value: func.asString(value0, value1) }
      ]);
      return;
    }
  }
  _expectedInputTypes() {
    const firstType = this.io.connection_points.first_input_connection_type();
    const type = firstType && Dot_ALLOWED_INPUT_TYPES.includes(firstType) ? firstType : connections_Js/* JsConnectionPointType.VECTOR3 */.zF.VECTOR3;
    return [type, type];
  }
  _expectedOutputTypes() {
    const inputType = this._expectedInputTypes()[0];
    const outputType = (0,connections_Js/* isJsConnectionPointArray */.$c)(inputType) ? connections_Js/* JsConnectionPointType.FLOAT_ARRAY */.zF.FLOAT_ARRAY : connections_Js/* JsConnectionPointType.FLOAT */.zF.FLOAT;
    return [outputType];
  }
  _expectedInputName(index) {
    return ["v0" /* VALUE0 */, "v1" /* VALUE1 */][index];
  }
  _expectedOutputName(index) {
    return Dot_OUTPUT_NAME;
  }
  paramDefaultValue(name) {
    return Dot_DefaultValues[name];
  }
}

// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/nodes/js/Easing.ts
var js_Easing = __webpack_require__(61038);
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/js/ElementsToArray.ts






const ElementsToArray_ALLOWED_INPUT_TYPES = connections_Js/* ARRAYABLE_CONNECTION_TYPES */.Kh;
class ElementsToArrayJsParamsConfig extends params_ParamsConfig/* NodeParamsConfig */.yI {
}
const ElementsToArray_ParamsConfig = new ElementsToArrayJsParamsConfig();
class ElementsToArrayJsNode extends js_Base/* TypedJsNode */.xZ {
  constructor() {
    super(...arguments);
    this.paramsConfig = ElementsToArray_ParamsConfig;
  }
  static type() {
    return "elementsToArray";
  }
  initializeNode() {
    super.initializeNode();
    this.io.connection_points.set_expected_input_types_function(this._expectedInputTypes.bind(this));
    this.io.connection_points.set_expected_output_types_function(this._expectedOutputTypes.bind(this));
    this.io.connection_points.set_input_name_function(this._expectedInputName.bind(this));
    this.io.connection_points.set_output_name_function(this._expectedOutputName.bind(this));
  }
  _expectedInputTypes() {
    const firstType = this.io.connection_points.first_input_connection_type();
    const type = firstType != null && ElementsToArray_ALLOWED_INPUT_TYPES.has(firstType) ? firstType : connections_Js/* JsConnectionPointType.FLOAT */.zF.FLOAT;
    const currentConnections = this.io.connections.existingInputConnections();
    const expectedCount = currentConnections ? Math.max(currentConnections.length + 1, 2) : 2;
    const expectedInputTypes = [];
    for (let i = 0; i < expectedCount; i++) {
      expectedInputTypes.push(type);
    }
    return expectedInputTypes;
  }
  _expectedInputName(index) {
    return `element${index}`;
  }
  _expectedOutputName(index) {
    const type = this._expectedInputTypes()[0];
    return `${type}[]`;
  }
  _expectedOutputTypes() {
    const firstType = this._expectedInputTypes()[0];
    const outputType = connections_Js/* JsConnectionPointTypeToArrayTypeMap */.RC[firstType] || connections_Js/* JsConnectionPointType.FLOAT_ARRAY */.zF.FLOAT_ARRAY;
    return [outputType];
  }
  setLines(shadersCollectionController) {
    const inputValuesCount = this._expectedInputTypes().length - 1;
    const inputArgs = [];
    for (let i = 0; i < inputValuesCount; i++) {
      const element = this.variableForInput(shadersCollectionController, this._expectedInputName(i));
      inputArgs.push(element);
    }
    const inputElements = `[${inputArgs.join(",")}]`;
    const dataType = this._expectedInputTypes()[0];
    const varName = this.jsVarName(this._expectedOutputName(0));
    const options = {
      shadersCollectionController,
      inputElements,
      dataType,
      varName
    };
    const firstType = this._expectedInputTypes()[0];
    switch (firstType) {
      case connections_Js/* JsConnectionPointType.BOOLEAN */.zF.BOOLEAN:
      case connections_Js/* JsConnectionPointType.FLOAT */.zF.FLOAT:
      case connections_Js/* JsConnectionPointType.INT */.zF.INT:
      case connections_Js/* JsConnectionPointType.STRING */.zF.STRING: {
        return this._setLinesAsPrimitive(options);
      }
      case connections_Js/* JsConnectionPointType.COLOR */.zF.COLOR:
      case connections_Js/* JsConnectionPointType.MATRIX4 */.zF.MATRIX4:
      case connections_Js/* JsConnectionPointType.QUATERNION */.zF.QUATERNION:
      case connections_Js/* JsConnectionPointType.VECTOR2 */.zF.VECTOR2:
      case connections_Js/* JsConnectionPointType.VECTOR3 */.zF.VECTOR3:
      case connections_Js/* JsConnectionPointType.VECTOR4 */.zF.VECTOR4: {
        return this._setLinesAsVector(options);
      }
      case connections_Js/* JsConnectionPointType.INTERSECTION */.zF.INTERSECTION: {
        return this._setLinesAsIntersection(options);
      }
      case connections_Js/* JsConnectionPointType.TEXTURE */.zF.TEXTURE: {
        return this._setLinesAsTexture(options);
      }
    }
  }
  _setLinesAsPrimitive(options) {
    const { shadersCollectionController, varName, dataType, inputElements } = options;
    const tmpVarName = shadersCollectionController.addVariable(
      this,
      (0,_BaseJsPersistedConfigUtils/* createPrimitiveArray */.vh)(dataType)
    );
    const func = Poly/* Poly.namedFunctionsRegister.getFunction */.L.namedFunctionsRegister.getFunction(
      "elementsToArrayPrimitive",
      this,
      shadersCollectionController
    );
    shadersCollectionController.addBodyOrComputed(this, [
      {
        dataType,
        varName,
        value: func.asString(inputElements, tmpVarName)
      }
    ]);
  }
  _setLinesAsVector(options) {
    const { shadersCollectionController, varName, dataType, inputElements } = options;
    const tmpVarName = shadersCollectionController.addVariable(
      this,
      (0,_BaseJsPersistedConfigUtils/* createVectorArray */.QH)(dataType)
    );
    const func = Poly/* Poly.namedFunctionsRegister.getFunction */.L.namedFunctionsRegister.getFunction(
      "elementsToArrayPrimitive",
      this,
      shadersCollectionController
    );
    shadersCollectionController.addBodyOrComputed(this, [
      {
        dataType,
        varName,
        value: func.asString(inputElements, tmpVarName)
      }
    ]);
  }
  _setLinesAsIntersection(options) {
    console.warn("not implemented");
  }
  _setLinesAsTexture(options) {
    console.warn("not implemented");
  }
  // public override outputValue(context: JsNodeTriggerContext) {
  // 	const inputsCount = this.io.inputs.namedInputConnectionPoints().length - 1;
  // 	const array = new Array(inputsCount);
  // 	for (let i = 0; i < inputsCount; i++) {
  // 		const inputName = this._expectedInputName(i);
  // 		array[i] = this._inputValue<ArrayabeonnectionPointType>(inputName, context);
  // 	}
  // 	return array;
  // }
}

// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/core/Transform.ts
var Transform = __webpack_require__(87883);
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/js/Euler.ts







class EulerJsParamsConfig extends params_ParamsConfig/* NodeParamsConfig */.yI {
  constructor() {
    super(...arguments);
    /** @param euler value */
    this.Euler = params_ParamsConfig/* ParamConfig.VECTOR3 */.XC.VECTOR3([0, 0, 0]);
    /** @param rotation order */
    this.order = params_ParamsConfig/* ParamConfig.INTEGER */.XC.INTEGER(Transform/* ROTATION_ORDERS.indexOf */.Is.indexOf(Transform/* RotationOrder.XYZ */.tM.XYZ), {
      menu: {
        entries: Transform/* ROTATION_ORDERS.map */.Is.map((order, v) => {
          return { name: order, value: v };
        })
      }
    });
  }
}
const Euler_ParamsConfig = new EulerJsParamsConfig();
class EulerJsNode extends js_Base/* TypedJsNode */.xZ {
  constructor() {
    super(...arguments);
    this.paramsConfig = Euler_ParamsConfig;
  }
  static type() {
    return "euler";
  }
  initializeNode() {
    super.initializeNode();
    this.io.outputs.setNamedOutputConnectionPoints([
      new connections_Js/* JsConnectionPoint */.fp(connections_Js/* JsConnectionPointType.EULER */.zF.EULER, connections_Js/* JsConnectionPointType.EULER */.zF.EULER)
    ]);
  }
  setLines(linesController) {
    const inputValue = this.variableForInputParam(linesController, this.p.Euler);
    const order = this.variableForInputParam(linesController, this.p.order);
    const varName = this.jsVarName(connections_Js/* JsConnectionPointType.EULER */.zF.EULER);
    const tmpVarName = linesController.addVariable(this, new three_module.Euler());
    const func = Poly/* Poly.namedFunctionsRegister.getFunction */.L.namedFunctionsRegister.getFunction("eulerSetFromVector3", this, linesController);
    linesController.addBodyOrComputed(this, [
      {
        dataType: connections_Js/* JsConnectionPointType.EULER */.zF.EULER,
        varName,
        value: func.asString(inputValue, order, tmpVarName)
      }
    ]);
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/js/EulerFromQuaternion.ts






const EulerFromQuaternion_CONNECTION_OPTIONS = connections_Js/* JS_CONNECTION_POINT_IN_NODE_DEF */.mX;
class EulerFromQuaternionJsParamsConfig extends params_ParamsConfig/* NodeParamsConfig */.yI {
}
const EulerFromQuaternion_ParamsConfig = new EulerFromQuaternionJsParamsConfig();
class EulerFromQuaternionJsNode extends js_Base/* TypedJsNode */.xZ {
  constructor() {
    super(...arguments);
    this.paramsConfig = EulerFromQuaternion_ParamsConfig;
  }
  static type() {
    return "eulerFromQuaternion";
  }
  initializeNode() {
    super.initializeNode();
    this.io.inputs.setNamedInputConnectionPoints([
      new connections_Js/* JsConnectionPoint */.fp(
        connections_Js/* JsConnectionPointType.QUATERNION */.zF.QUATERNION,
        connections_Js/* JsConnectionPointType.QUATERNION */.zF.QUATERNION,
        EulerFromQuaternion_CONNECTION_OPTIONS
      )
    ]);
    this.io.outputs.setNamedOutputConnectionPoints([
      new connections_Js/* JsConnectionPoint */.fp(connections_Js/* JsConnectionPointType.EULER */.zF.EULER, connections_Js/* JsConnectionPointType.EULER */.zF.EULER)
    ]);
  }
  setLines(linesController) {
    const quaternion = this.variableForInput(linesController, connections_Js/* JsConnectionPointType.QUATERNION */.zF.QUATERNION);
    const varName = this.jsVarName(connections_Js/* JsConnectionPointType.EULER */.zF.EULER);
    const tmpVarName = linesController.addVariable(this, new three_module.Euler());
    const func = Poly/* Poly.namedFunctionsRegister.getFunction */.L.namedFunctionsRegister.getFunction("eulerSetFromQuaternion", this, linesController);
    linesController.addBodyOrComputed(this, [
      {
        dataType: connections_Js/* JsConnectionPointType.EULER */.zF.EULER,
        varName,
        value: func.asString(quaternion, tmpVarName)
      }
    ]);
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/js/Fit.ts




var FitInput = /* @__PURE__ */ ((FitInput2) => {
  FitInput2["VALUE"] = "val";
  FitInput2["SRC_MIN"] = "srcMin";
  FitInput2["SRC_MAX"] = "srcMax";
  FitInput2["DEST_MIN"] = "destMin";
  FitInput2["DEST_MAX"] = "destMax";
  FitInput2["CLAMP_TO_DEST_RANGE"] = "clampToDestRange";
  return FitInput2;
})(FitInput || {});
const Fit_DefaultValues = {
  ["val" /* VALUE */]: 0,
  ["srcMin" /* SRC_MIN */]: 0,
  ["srcMax" /* SRC_MAX */]: 1,
  ["destMin" /* DEST_MIN */]: 0,
  ["destMax" /* DEST_MAX */]: 1,
  ["clampToDestRange" /* CLAMP_TO_DEST_RANGE */]: 0
};
const FUNCTION_NAME_FIT = "fit";
const FUNCTION_NAME_FIT_CLAMP = "fitClamp";
const FUNCTION_NAMES = [FUNCTION_NAME_FIT, FUNCTION_NAME_FIT_CLAMP];
class FitJsNode extends MathFunctionArg5OperationFactory("fit", {
  inputPrefix: "in",
  out: "val"
}) {
  _coreFunction(shadersCollectionController) {
    FUNCTION_NAMES.forEach((functionName) => {
      Poly/* Poly.namedFunctionsRegister.getFunction */.L.namedFunctionsRegister.getFunction(functionName, this, shadersCollectionController).asString("", "", "", "", "");
    });
    const doClamp = this.variableForInput(shadersCollectionController, "clampToDestRange" /* CLAMP_TO_DEST_RANGE */);
    return `${doClamp} ? ${FUNCTION_NAME_FIT_CLAMP}: ${FUNCTION_NAME_FIT}`;
  }
  _inputValuesCount() {
    const inputTypes = this._expectedInputTypes();
    const inputValuesCount = inputTypes.length;
    return inputValuesCount - 1;
  }
  paramDefaultValue(name) {
    return Fit_DefaultValues[name];
  }
  _expectedInputName(index) {
    return [
      "val" /* VALUE */,
      "srcMin" /* SRC_MIN */,
      "srcMax" /* SRC_MAX */,
      "destMin" /* DEST_MIN */,
      "destMax" /* DEST_MAX */,
      "clampToDestRange" /* CLAMP_TO_DEST_RANGE */
    ][index];
  }
  _expectedInputTypes() {
    let first_input_type = this.io.connection_points.first_input_connection_type();
    const connectionPoints = this.io.inputs.namedInputConnectionPoints();
    if (first_input_type && connectionPoints) {
      if (!DEFAULT_ALLOWED_TYPES.includes(first_input_type)) {
        const first_connection = connectionPoints[0];
        if (first_connection) {
          first_input_type = first_connection.type();
        }
      }
    }
    const type = first_input_type || connections_Js/* JsConnectionPointType.FLOAT */.zF.FLOAT;
    const boundType = connections_Js/* JsConnectionPointTypeFromArrayTypeMap */.RR[type];
    return [type, boundType, boundType, boundType, boundType, connections_Js/* JsConnectionPointType.BOOLEAN */.zF.BOOLEAN];
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/js/_ConversionFloatTo.ts






class FloatToColorJsParamsConfig extends params_ParamsConfig/* NodeParamsConfig */.yI {
  constructor() {
    super(...arguments);
    this.r = params_ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(0);
    this.g = params_ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(0);
    this.b = params_ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(0);
  }
}
const ParamsConfig_Color = new FloatToColorJsParamsConfig();
class FloatToColorJsNode extends js_Base/* TypedJsNode */.xZ {
  constructor() {
    super(...arguments);
    this.paramsConfig = ParamsConfig_Color;
  }
  static type() {
    return "floatToColor";
  }
  initializeNode() {
    this.io.outputs.setNamedOutputConnectionPoints([
      new connections_Js/* JsConnectionPoint */.fp(FloatToVec3JsNode.OUTPUT_NAME, connections_Js/* JsConnectionPointType.COLOR */.zF.COLOR)
    ]);
  }
  setLines(shadersCollectionController) {
    const r = this.variableForInputParam(shadersCollectionController, this.p.r);
    const g = this.variableForInputParam(shadersCollectionController, this.p.g);
    const b = this.variableForInputParam(shadersCollectionController, this.p.b);
    const out = this.jsVarName(FloatToVec3JsNode.OUTPUT_NAME);
    const tmpVarName = shadersCollectionController.addVariable(this, new three_module.Color());
    const func = Poly/* Poly.namedFunctionsRegister.getFunction */.L.namedFunctionsRegister.getFunction("floatToColor", this, shadersCollectionController);
    shadersCollectionController.addBodyOrComputed(this, [
      { dataType: connections_Js/* JsConnectionPointType.VECTOR3 */.zF.VECTOR3, varName: out, value: func.asString(r, g, b, tmpVarName) }
    ]);
  }
}
FloatToColorJsNode.OUTPUT_NAME = "Color";
class FloatToVec2JsParamsConfig extends params_ParamsConfig/* NodeParamsConfig */.yI {
  constructor() {
    super(...arguments);
    this.x = params_ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(0);
    this.y = params_ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(0);
  }
}
const ParamsConfig_Vector2 = new FloatToVec2JsParamsConfig();
const _FloatToVec2JsNode = class extends js_Base/* TypedJsNode */.xZ {
  constructor() {
    super(...arguments);
    this.paramsConfig = ParamsConfig_Vector2;
  }
  static type() {
    return "floatToVec2";
  }
  initializeNode() {
    this.io.outputs.setNamedOutputConnectionPoints([
      new connections_Js/* JsConnectionPoint */.fp(_FloatToVec2JsNode.OUTPUT_NAME, connections_Js/* JsConnectionPointType.VECTOR2 */.zF.VECTOR2)
    ]);
  }
  setLines(shadersCollectionController) {
    const x = this.variableForInputParam(shadersCollectionController, this.p.x);
    const y = this.variableForInputParam(shadersCollectionController, this.p.y);
    const varName = this.jsVarName(_FloatToVec2JsNode.OUTPUT_NAME);
    const tmpVarName = shadersCollectionController.addVariable(this, new three_module.Vector2());
    const func = Poly/* Poly.namedFunctionsRegister.getFunction */.L.namedFunctionsRegister.getFunction("floatToVec2", this, shadersCollectionController);
    shadersCollectionController.addBodyOrComputed(this, [
      { dataType: connections_Js/* JsConnectionPointType.VECTOR3 */.zF.VECTOR3, varName, value: func.asString(x, y, tmpVarName) }
    ]);
  }
};
let FloatToVec2JsNode = _FloatToVec2JsNode;
FloatToVec2JsNode.OUTPUT_NAME = "vec2";
class FloatToVec3JsParamsConfig extends params_ParamsConfig/* NodeParamsConfig */.yI {
  constructor() {
    super(...arguments);
    this.x = params_ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(0);
    this.y = params_ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(0);
    this.z = params_ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(0);
  }
}
const ParamsConfig_Vector3 = new FloatToVec3JsParamsConfig();
const _FloatToVec3JsNode = class extends js_Base/* TypedJsNode */.xZ {
  constructor() {
    super(...arguments);
    this.paramsConfig = ParamsConfig_Vector3;
  }
  static type() {
    return "floatToVec3";
  }
  initializeNode() {
    this.io.outputs.setNamedOutputConnectionPoints([
      new connections_Js/* JsConnectionPoint */.fp(_FloatToVec3JsNode.OUTPUT_NAME, connections_Js/* JsConnectionPointType.VECTOR3 */.zF.VECTOR3)
    ]);
  }
  setLines(shadersCollectionController) {
    const x = this.variableForInputParam(shadersCollectionController, this.p.x);
    const y = this.variableForInputParam(shadersCollectionController, this.p.y);
    const z = this.variableForInputParam(shadersCollectionController, this.p.z);
    const out = this.jsVarName(_FloatToVec3JsNode.OUTPUT_NAME);
    const tmpVarName = shadersCollectionController.addVariable(this, new three_module.Vector3());
    const func = Poly/* Poly.namedFunctionsRegister.getFunction */.L.namedFunctionsRegister.getFunction("floatToVec3", this, shadersCollectionController);
    shadersCollectionController.addBodyOrComputed(this, [
      { dataType: connections_Js/* JsConnectionPointType.VECTOR3 */.zF.VECTOR3, varName: out, value: func.asString(x, y, z, tmpVarName) }
    ]);
  }
};
let FloatToVec3JsNode = _FloatToVec3JsNode;
FloatToVec3JsNode.OUTPUT_NAME = "vec3";
class FloatToVec4JsParamsConfig extends params_ParamsConfig/* NodeParamsConfig */.yI {
  constructor() {
    super(...arguments);
    this.x = params_ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(0);
    this.y = params_ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(0);
    this.z = params_ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(0);
    this.w = params_ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(0);
  }
}
const ParamsConfig_Vector4 = new FloatToVec4JsParamsConfig();
class FloatToVec4JsNode extends js_Base/* TypedJsNode */.xZ {
  constructor() {
    super(...arguments);
    this.paramsConfig = ParamsConfig_Vector4;
  }
  static type() {
    return "floatToVec4";
  }
  initializeNode() {
    this.io.outputs.setNamedOutputConnectionPoints([
      new connections_Js/* JsConnectionPoint */.fp(FloatToVec3JsNode.OUTPUT_NAME, connections_Js/* JsConnectionPointType.VECTOR4 */.zF.VECTOR4)
    ]);
  }
  setLines(shadersCollectionController) {
    const x = this.variableForInputParam(shadersCollectionController, this.p.x);
    const y = this.variableForInputParam(shadersCollectionController, this.p.y);
    const z = this.variableForInputParam(shadersCollectionController, this.p.z);
    const w = this.variableForInputParam(shadersCollectionController, this.p.w);
    const varName = this.jsVarName(FloatToVec3JsNode.OUTPUT_NAME);
    const tmpVarName = shadersCollectionController.addVariable(this, new three_module.Vector4());
    const func = Poly/* Poly.namedFunctionsRegister.getFunction */.L.namedFunctionsRegister.getFunction("floatToVec4", this, shadersCollectionController);
    shadersCollectionController.addBodyOrComputed(this, [
      { dataType: connections_Js/* JsConnectionPointType.VECTOR3 */.zF.VECTOR3, varName, value: func.asString(x, y, z, w, tmpVarName) }
    ]);
  }
}
FloatToVec4JsNode.OUTPUT_NAME = "vec4";

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/js/Floor.ts


class FloorJsNode extends MathFunctionArg1OperationFactory("floor", {
  inputPrefix: "val",
  out: "floor"
}) {
}

// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/nodes/js/Subnet.ts
var js_Subnet = __webpack_require__(70374);
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/js/ForLoop.ts





var ForLoopJsInputName = /* @__PURE__ */ ((ForLoopJsInputName2) => {
  ForLoopJsInputName2["START"] = "start";
  ForLoopJsInputName2["MAX"] = "max";
  ForLoopJsInputName2["STEP"] = "step";
  ForLoopJsInputName2["I"] = "i";
  return ForLoopJsInputName2;
})(ForLoopJsInputName || {});
const DEFAULT_VALUES = {
  ["start" /* START */]: 0,
  ["max" /* MAX */]: 10,
  ["step" /* STEP */]: 1
};
const FOR_LOOP_INPUT_NAMES = [
  "start" /* START */,
  "max" /* MAX */,
  "step" /* STEP */,
  "i" /* I */
];
class ForLoopJsParamsConfig extends (0,js_Subnet/* TypedSubnetJsParamsConfigMixin */.Du)(params_ParamsConfig/* NodeParamsConfig */.yI) {
  constructor() {
    super(...arguments);
    this.start = params_ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(0);
    this.max = params_ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(10, {
      range: [0, 100],
      rangeLocked: [false, false]
    });
    this.step = params_ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(1);
  }
}
const ForLoop_ParamsConfig = new ForLoopJsParamsConfig();
class ForLoopJsNode extends js_Subnet/* TypedSubnetJsNode */.RY {
  constructor() {
    super(...arguments);
    this.paramsConfig = ForLoop_ParamsConfig;
  }
  static type() {
    return Js/* JsType.FOR_LOOP */.K.FOR_LOOP;
  }
  paramDefaultValue(name) {
    return DEFAULT_VALUES[name];
  }
  _expectedInputTypes() {
    const type = connections_Js/* JsConnectionPointType.INT */.zF.INT;
    const forLoopInputTypes = [type, type, type];
    return forLoopInputTypes.concat(super._expectedInputTypes());
  }
  _expectedInputName(index) {
    if (index <= 2) {
      return FOR_LOOP_INPUT_NAMES[index];
    } else {
      return super._expectedInputName(index - 3);
    }
  }
  childExpectedInputConnectionPointTypes() {
    const type = connections_Js/* JsConnectionPointType.INT */.zF.INT;
    const forLoopInputTypes = [type, type, type, type];
    return forLoopInputTypes.concat(super._expectedInputTypes());
  }
  childExpectedInputConnectionPointName(index) {
    if (index <= 3) {
      return FOR_LOOP_INPUT_NAMES[index];
    } else {
      return super._expectedInputName(index - 4);
    }
  }
  inputNameForSubnetInput(index) {
    return this.childExpectedInputConnectionPointName(index);
  }
  //
  //
  // set_lines
  //
  //
  setLinesBlockStart(linesController) {
    const start = this.jsVarName("start" /* START */);
    const max = this.jsVarName("max" /* MAX */);
    const step = this.jsVarName("step" /* STEP */);
    const i = this.jsVarName("i" /* I */);
    const bodyLine = `for( ${i} = ${start}; ${i} < ${max}; ${i}+= ${step}){`;
    linesController._addBodyLines(this, [bodyLine]);
  }
  setSubnetInputLines(linesController, childNode) {
    const outputTypes = childNode.expectedOutputTypes();
    let i = 0;
    for (const _ of outputTypes) {
      const inputName = this.inputNameForSubnetInput(i);
      const inputValue = this.jsVarName(inputName);
      const varName = childNode.jsVarName(inputName);
      linesController._addBodyLines(childNode, [`${varName}=${inputValue}`]);
      i++;
    }
  }
  // override setSubnetInputLines(linesController: JsLinesCollectionController, childNode: SubnetInputJsNode) {
  // 	const start = this.variableForInputParam(linesController, this.p.start);
  // 	const max = this.variableForInputParam(linesController, this.p.max);
  // 	const step = this.variableForInputParam(linesController, this.p.step);
  // 	const body_lines: string[] = [];
  // 	// i
  // 	const iterator_name = this.jsVarName(ForLoopInput.I);
  // 	const i = childNode.jsVarName(ForLoopInput.I);
  // 	body_lines.push(`	const ${i} = ${iterator_name}`);
  // 	// start
  // 	const startVar = childNode.jsVarName(ForLoopInput.START);
  // 	body_lines.push(`	const ${startVar} = ${start}`);
  // 	// end
  // 	const maxVar = childNode.jsVarName(ForLoopInput.MAX);
  // 	body_lines.push(`	const ${maxVar} = ${max}`);
  // 	// step
  // 	const stepVar = childNode.jsVarName(ForLoopInput.STEP);
  // 	body_lines.push(`	const ${stepVar} = ${step}`);
  // 	const connections = this.io.connections.inputConnections();
  // 	if (connections) {
  // 		for (const connection of connections) {
  // 			if (connection) {
  // 				if (connection.inputIndex() >= OFFSET) {
  // 					const connection_point = connection.destConnectionPoint();
  // 					if (connection_point) {
  // 						const in_value = this.jsVarName(connection_point.name());
  // 						const gl_type = connection_point.type();
  // 						const out = childNode.jsVarName(connection_point.name());
  // 						const body_line = `	${gl_type} ${out} = ${in_value}`;
  // 						body_lines.push(body_line);
  // 					}
  // 				}
  // 			}
  // 		}
  // 	}
  // 	linesController._addBodyLines(childNode, body_lines);
  // }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/js/GeolocationCurrentPosition.ts







const GeolocationCurrentPosition_CONNECTION_OPTIONS = connections_Js/* JS_CONNECTION_POINT_IN_NODE_DEF */.mX;
var GeolocationCurrentPositionOutput = /* @__PURE__ */ ((GeolocationCurrentPositionOutput2) => {
  GeolocationCurrentPositionOutput2["LAT"] = "lat";
  GeolocationCurrentPositionOutput2["LNG"] = "lng";
  return GeolocationCurrentPositionOutput2;
})(GeolocationCurrentPositionOutput || {});
class GeolocationCurrentPositionJsNode extends js_Base/* ParamlessTypedJsNode */.au {
  static type() {
    return Js/* JsType.GEOLOCATION_CURRENT_POSITION */.K.GEOLOCATION_CURRENT_POSITION;
  }
  isTriggering() {
    return true;
  }
  initializeNode() {
    super.initializeNode();
    this.io.inputs.setNamedInputConnectionPoints([
      new connections_Js/* JsConnectionPoint */.fp(connections_Js/* JsConnectionPointType.TRIGGER */.zF.TRIGGER, connections_Js/* JsConnectionPointType.TRIGGER */.zF.TRIGGER, GeolocationCurrentPosition_CONNECTION_OPTIONS)
    ]);
    this.io.outputs.setNamedOutputConnectionPoints([
      new connections_Js/* JsConnectionPoint */.fp(connections_Js/* JsConnectionPointType.TRIGGER */.zF.TRIGGER, connections_Js/* JsConnectionPointType.TRIGGER */.zF.TRIGGER, GeolocationCurrentPosition_CONNECTION_OPTIONS),
      new connections_Js/* JsConnectionPoint */.fp(
        "lat" /* LAT */,
        connections_Js/* JsConnectionPointType.FLOAT */.zF.FLOAT,
        GeolocationCurrentPosition_CONNECTION_OPTIONS
      ),
      new connections_Js/* JsConnectionPoint */.fp(
        "lng" /* LNG */,
        connections_Js/* JsConnectionPointType.FLOAT */.zF.FLOAT,
        GeolocationCurrentPosition_CONNECTION_OPTIONS
      )
    ]);
  }
  setLines(linesController) {
    const usedOutputNames = this.io.outputs.used_output_names();
    const _val = (propertyName, functionName, type) => {
      if (!usedOutputNames.includes(propertyName)) {
        return;
      }
      const func = Poly/* Poly.namedFunctionsRegister.getFunction */.L.namedFunctionsRegister.getFunction(functionName, this, linesController);
      const varName = this.jsVarName(propertyName);
      linesController.addBodyOrComputed(this, [
        {
          dataType: type,
          varName,
          value: func.asString()
        }
      ]);
    };
    _val("lat" /* LAT */, "geolocationLatitude", connections_Js/* JsConnectionPointType.FLOAT */.zF.FLOAT);
    _val("lng" /* LNG */, "geolocationLongitude", connections_Js/* JsConnectionPointType.FLOAT */.zF.FLOAT);
  }
  setTriggeringLines(linesController, triggeredMethods) {
    const geolocationCurrentPositionRef = Poly/* Poly.namedFunctionsRegister.getFunction */.L.namedFunctionsRegister.getFunction(
      "geolocationCurrentPositionRef",
      this,
      linesController
    );
    linesController.addDefinitions(this, [
      new JsDefinition/* WatchedValueJsDefinition */.Vu(
        this,
        linesController,
        connections_Js/* JsConnectionPointType.VECTOR2 */.zF.VECTOR2,
        geolocationCurrentPositionRef.asString(),
        `this.${(0,ActorAssemblerUtils/* nodeMethodName */.Bp)(this)}()`,
        {
          deep: true
        }
      )
    ]);
    linesController.addTriggeringLines(this, [triggeredMethods], {
      gatherable: false
    });
  }
  setTriggerableLines(linesController) {
    const func = Poly/* Poly.namedFunctionsRegister.getFunction */.L.namedFunctionsRegister.getFunction("geolocationGetCurrentPosition", this, linesController);
    const bodyLine = func.asString();
    linesController.addTriggerableLines(this, [bodyLine]);
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/js/GetBox3Property.ts





const GetBox3Property_CONNECTION_OPTIONS = connections_Js/* JS_CONNECTION_POINT_IN_NODE_DEF */.mX;
var GetBox3PropertyJsNodeInputName = /* @__PURE__ */ ((GetBox3PropertyJsNodeInputName2) => {
  GetBox3PropertyJsNodeInputName2["min"] = "min";
  GetBox3PropertyJsNodeInputName2["max"] = "max";
  GetBox3PropertyJsNodeInputName2["center"] = "center";
  return GetBox3PropertyJsNodeInputName2;
})(GetBox3PropertyJsNodeInputName || {});
class GetBox3PropertyJsNode extends js_Base/* ParamlessTypedJsNode */.au {
  static type() {
    return "getBox3Property";
  }
  initializeNode() {
    this.io.inputs.setNamedInputConnectionPoints([
      new connections_Js/* JsConnectionPoint */.fp(connections_Js/* JsConnectionPointType.BOX3 */.zF.BOX3, connections_Js/* JsConnectionPointType.BOX3 */.zF.BOX3, GetBox3Property_CONNECTION_OPTIONS)
    ]);
    this.io.outputs.setNamedOutputConnectionPoints([
      new connections_Js/* JsConnectionPoint */.fp("min" /* min */, connections_Js/* JsConnectionPointType.VECTOR3 */.zF.VECTOR3),
      new connections_Js/* JsConnectionPoint */.fp("max" /* max */, connections_Js/* JsConnectionPointType.VECTOR3 */.zF.VECTOR3),
      new connections_Js/* JsConnectionPoint */.fp("center" /* center */, connections_Js/* JsConnectionPointType.VECTOR3 */.zF.VECTOR3)
    ]);
  }
  setLines(shadersCollectionController) {
    const usedOutputNames = this.io.outputs.used_output_names();
    const box3 = this.variableForInput(shadersCollectionController, connections_Js/* JsConnectionPointType.BOX3 */.zF.BOX3);
    const _f = (propertyName, functionName, type) => {
      if (!usedOutputNames.includes(propertyName)) {
        return;
      }
      const out = this.jsVarName(propertyName);
      const tmpVarName = shadersCollectionController.addVariable(this, new three_module.Vector3());
      const func = Poly/* Poly.namedFunctionsRegister.getFunction */.L.namedFunctionsRegister.getFunction(functionName, this, shadersCollectionController);
      shadersCollectionController.addBodyOrComputed(this, [
        {
          dataType: type,
          varName: out,
          value: func.asString(box3, tmpVarName)
        }
      ]);
    };
    _f("min" /* min */, "getBox3Min", connections_Js/* JsConnectionPointType.VECTOR3 */.zF.VECTOR3);
    _f("max" /* max */, "getBox3Max", connections_Js/* JsConnectionPointType.VECTOR3 */.zF.VECTOR3);
    _f("center" /* center */, "getBox3Center", connections_Js/* JsConnectionPointType.VECTOR3 */.zF.VECTOR3);
  }
}

// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/nodes/js/GetChildrenAttributes.ts
var GetChildrenAttributes = __webpack_require__(11919);
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/js/GetChildrenPhysicsRBDProperties.ts







const GetChildrenPhysicsRBDProperties_CONNECTION_OPTIONS = connections_Js/* JS_CONNECTION_POINT_IN_NODE_DEF */.mX;
var GetChildrenPhysicsRBDPropertiesJsNodeInputName = /* @__PURE__ */ ((GetChildrenPhysicsRBDPropertiesJsNodeInputName2) => {
  GetChildrenPhysicsRBDPropertiesJsNodeInputName2["linVel"] = "linVel";
  GetChildrenPhysicsRBDPropertiesJsNodeInputName2["angVel"] = "angVel";
  GetChildrenPhysicsRBDPropertiesJsNodeInputName2["linearDamping"] = "linearDamping";
  GetChildrenPhysicsRBDPropertiesJsNodeInputName2["angularDamping"] = "angularDamping";
  GetChildrenPhysicsRBDPropertiesJsNodeInputName2["isSleeping"] = "isSleeping";
  GetChildrenPhysicsRBDPropertiesJsNodeInputName2["isMoving"] = "isMoving";
  return GetChildrenPhysicsRBDPropertiesJsNodeInputName2;
})(GetChildrenPhysicsRBDPropertiesJsNodeInputName || {});
class GetChildrenPhysicsRBDPropertiesJsNode extends js_Base/* ParamlessTypedJsNode */.au {
  static type() {
    return "getChildrenPhysicsRBDProperties";
  }
  initializeNode() {
    this.io.inputs.setNamedInputConnectionPoints([
      new connections_Js/* JsConnectionPoint */.fp(connections_Js/* JsConnectionPointType.OBJECT_3D */.zF.OBJECT_3D, connections_Js/* JsConnectionPointType.OBJECT_3D */.zF.OBJECT_3D, GetChildrenPhysicsRBDProperties_CONNECTION_OPTIONS)
    ]);
    this.io.outputs.setNamedOutputConnectionPoints([
      new connections_Js/* JsConnectionPoint */.fp(
        "linVel" /* linVel */,
        connections_Js/* JsConnectionPointType.VECTOR3_ARRAY */.zF.VECTOR3_ARRAY
      ),
      new connections_Js/* JsConnectionPoint */.fp(
        "angVel" /* angVel */,
        connections_Js/* JsConnectionPointType.VECTOR3_ARRAY */.zF.VECTOR3_ARRAY
      ),
      new connections_Js/* JsConnectionPoint */.fp(
        "linearDamping" /* linearDamping */,
        connections_Js/* JsConnectionPointType.FLOAT_ARRAY */.zF.FLOAT_ARRAY
      ),
      new connections_Js/* JsConnectionPoint */.fp(
        "angularDamping" /* angularDamping */,
        connections_Js/* JsConnectionPointType.FLOAT_ARRAY */.zF.FLOAT_ARRAY
      ),
      new connections_Js/* JsConnectionPoint */.fp(
        "isSleeping" /* isSleeping */,
        connections_Js/* JsConnectionPointType.BOOLEAN_ARRAY */.zF.BOOLEAN_ARRAY
      ),
      new connections_Js/* JsConnectionPoint */.fp(
        "isMoving" /* isMoving */,
        connections_Js/* JsConnectionPointType.BOOLEAN_ARRAY */.zF.BOOLEAN_ARRAY
      )
    ]);
  }
  setLines(shadersCollectionController) {
    const usedOutputNames = this.io.outputs.used_output_names();
    const object3D = (0,_BaseObject3D/* inputObject3D */.iv)(this, shadersCollectionController);
    const _v3 = (propertyName, functionName, type) => {
      if (!usedOutputNames.includes(propertyName)) {
        return;
      }
      const varName = this.jsVarName(propertyName);
      const tmpVarName = shadersCollectionController.addVariable(this, new _BaseJsPersistedConfigUtils/* VectorArray */.ex([new three_module.Vector3()]));
      const func = Poly/* Poly.namedFunctionsRegister.getFunction */.L.namedFunctionsRegister.getFunction(functionName, this, shadersCollectionController);
      shadersCollectionController.addBodyOrComputed(this, [
        {
          dataType: type,
          varName,
          value: func.asString(object3D, tmpVarName)
        }
      ]);
    };
    const _f = (propertyName, functionName, type) => {
      if (!usedOutputNames.includes(propertyName)) {
        return;
      }
      const varName = this.jsVarName(propertyName);
      const tmpVarName = shadersCollectionController.addVariable(this, new _BaseJsPersistedConfigUtils/* PrimitiveArray */.QP([0]));
      const func = Poly/* Poly.namedFunctionsRegister.getFunction */.L.namedFunctionsRegister.getFunction(functionName, this, shadersCollectionController);
      shadersCollectionController.addBodyOrComputed(this, [
        {
          dataType: type,
          varName,
          value: func.asString(object3D, tmpVarName)
        }
      ]);
    };
    const _b = (propertyName, functionName, type) => {
      if (!usedOutputNames.includes(propertyName)) {
        return;
      }
      const varName = this.jsVarName(propertyName);
      const tmpVarName = shadersCollectionController.addVariable(this, new _BaseJsPersistedConfigUtils/* PrimitiveArray */.QP([0]));
      const func = Poly/* Poly.namedFunctionsRegister.getFunction */.L.namedFunctionsRegister.getFunction(functionName, this, shadersCollectionController);
      shadersCollectionController.addBodyOrComputed(this, [
        {
          dataType: type,
          varName,
          value: func.asString(object3D, tmpVarName)
        }
      ]);
    };
    _v3(
      "angVel" /* angVel */,
      "getChildrenPhysicsRBDPropertiesAngularVelocity",
      connections_Js/* JsConnectionPointType.VECTOR3_ARRAY */.zF.VECTOR3_ARRAY
    );
    _v3(
      "linVel" /* linVel */,
      "getChildrenPhysicsRBDPropertiesLinearVelocity",
      connections_Js/* JsConnectionPointType.VECTOR3_ARRAY */.zF.VECTOR3_ARRAY
    );
    _f(
      "angularDamping" /* angularDamping */,
      "getChildrenPhysicsRBDPropertiesAngularDamping",
      connections_Js/* JsConnectionPointType.FLOAT_ARRAY */.zF.FLOAT_ARRAY
    );
    _f(
      "linearDamping" /* linearDamping */,
      "getChildrenPhysicsRBDPropertiesLinearDamping",
      connections_Js/* JsConnectionPointType.FLOAT_ARRAY */.zF.FLOAT_ARRAY
    );
    _b(
      "isMoving" /* isMoving */,
      "getChildrenPhysicsRBDPropertiesIsMoving",
      connections_Js/* JsConnectionPointType.BOOLEAN_ARRAY */.zF.BOOLEAN_ARRAY
    );
    _b(
      "isSleeping" /* isSleeping */,
      "getChildrenPhysicsRBDPropertiesIsSleeping",
      connections_Js/* JsConnectionPointType.BOOLEAN_ARRAY */.zF.BOOLEAN_ARRAY
    );
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/js/GetChildrenProperties.ts







const GetChildrenProperties_CONNECTION_OPTIONS = connections_Js/* JS_CONNECTION_POINT_IN_NODE_DEF */.mX;
var GetChildrenPropertiesJsNodeOutputName = /* @__PURE__ */ ((GetChildrenPropertiesJsNodeOutputName2) => {
  GetChildrenPropertiesJsNodeOutputName2["position"] = "position";
  GetChildrenPropertiesJsNodeOutputName2["quaternion"] = "quaternion";
  GetChildrenPropertiesJsNodeOutputName2["scale"] = "scale";
  GetChildrenPropertiesJsNodeOutputName2["visible"] = "visible";
  GetChildrenPropertiesJsNodeOutputName2["castShadow"] = "castShadow";
  GetChildrenPropertiesJsNodeOutputName2["receiveShadow"] = "receiveShadow";
  GetChildrenPropertiesJsNodeOutputName2["frustumCulled"] = "frustumCulled";
  GetChildrenPropertiesJsNodeOutputName2["up"] = "up";
  GetChildrenPropertiesJsNodeOutputName2["matrixAutoUpdate"] = "matrixAutoUpdate";
  return GetChildrenPropertiesJsNodeOutputName2;
})(GetChildrenPropertiesJsNodeOutputName || {});
class GetChildrenPropertiesJsNode extends js_Base/* ParamlessTypedJsNode */.au {
  static type() {
    return "getChildrenProperties";
  }
  initializeNode() {
    this.io.inputs.setNamedInputConnectionPoints([
      new connections_Js/* JsConnectionPoint */.fp(connections_Js/* JsConnectionPointType.OBJECT_3D */.zF.OBJECT_3D, connections_Js/* JsConnectionPointType.OBJECT_3D */.zF.OBJECT_3D, GetChildrenProperties_CONNECTION_OPTIONS)
    ]);
    this.io.outputs.setNamedOutputConnectionPoints([
      new connections_Js/* JsConnectionPoint */.fp("position" /* position */, connections_Js/* JsConnectionPointType.VECTOR3_ARRAY */.zF.VECTOR3_ARRAY),
      new connections_Js/* JsConnectionPoint */.fp(
        "quaternion" /* quaternion */,
        connections_Js/* JsConnectionPointType.QUATERNION_ARRAY */.zF.QUATERNION_ARRAY
      ),
      new connections_Js/* JsConnectionPoint */.fp("scale" /* scale */, connections_Js/* JsConnectionPointType.VECTOR3_ARRAY */.zF.VECTOR3_ARRAY),
      // new JsConnectionPoint(
      // 	GetChildrenPropertiesJsNodeInputName.matrix,
      // 	JsConnectionPointType.MATRIX4_ARRAY
      // ),
      new connections_Js/* JsConnectionPoint */.fp("up" /* up */, connections_Js/* JsConnectionPointType.VECTOR3_ARRAY */.zF.VECTOR3_ARRAY),
      new connections_Js/* JsConnectionPoint */.fp("visible" /* visible */, connections_Js/* JsConnectionPointType.BOOLEAN_ARRAY */.zF.BOOLEAN_ARRAY),
      new connections_Js/* JsConnectionPoint */.fp(
        "matrixAutoUpdate" /* matrixAutoUpdate */,
        connections_Js/* JsConnectionPointType.BOOLEAN_ARRAY */.zF.BOOLEAN_ARRAY
      ),
      new connections_Js/* JsConnectionPoint */.fp(
        "castShadow" /* castShadow */,
        connections_Js/* JsConnectionPointType.BOOLEAN_ARRAY */.zF.BOOLEAN_ARRAY
      ),
      new connections_Js/* JsConnectionPoint */.fp(
        "receiveShadow" /* receiveShadow */,
        connections_Js/* JsConnectionPointType.BOOLEAN_ARRAY */.zF.BOOLEAN_ARRAY
      ),
      new connections_Js/* JsConnectionPoint */.fp(
        "frustumCulled" /* frustumCulled */,
        connections_Js/* JsConnectionPointType.BOOLEAN_ARRAY */.zF.BOOLEAN_ARRAY
      )
      // new JsConnectionPoint(GetChildrenPropertiesJsNodeInputName.id, JsConnectionPointType.INTEGER),
      // new JsConnectionPoint(GetChildrenPropertiesJsNodeInputName.uuid, JsConnectionPointType.BOOLEAN),
      //  new JsConnectionPoint(MATERIAL_OUTPUT, JsConnectionPointType.MATERIAL),
    ]);
  }
  setLines(shadersCollectionController) {
    const usedOutputNames = this.io.outputs.used_output_names();
    const object3D = (0,_BaseObject3D/* inputObject3D */.iv)(this, shadersCollectionController);
    const _v3 = (propertyName, functionName, type) => {
      if (!usedOutputNames.includes(propertyName)) {
        return;
      }
      const varName = this.jsVarName(propertyName);
      const tmpVarName = shadersCollectionController.addVariable(this, new _BaseJsPersistedConfigUtils/* VectorArray */.ex([new three_module.Vector3()]));
      const func = Poly/* Poly.namedFunctionsRegister.getFunction */.L.namedFunctionsRegister.getFunction(functionName, this, shadersCollectionController);
      shadersCollectionController.addBodyOrComputed(this, [
        {
          dataType: type,
          varName,
          value: func.asString(object3D, tmpVarName)
        }
      ]);
    };
    const _q = (propertyName, functionName, type) => {
      if (!usedOutputNames.includes(propertyName)) {
        return;
      }
      const varName = this.jsVarName(propertyName);
      const tmpVarName = shadersCollectionController.addVariable(this, new _BaseJsPersistedConfigUtils/* VectorArray */.ex([new three_module.Quaternion()]));
      const func = Poly/* Poly.namedFunctionsRegister.getFunction */.L.namedFunctionsRegister.getFunction(functionName, this, shadersCollectionController);
      shadersCollectionController.addBodyOrComputed(this, [
        {
          dataType: type,
          varName,
          value: func.asString(object3D, tmpVarName)
        }
      ]);
    };
    const _b = (propertyName, functionName, type) => {
      if (!usedOutputNames.includes(propertyName)) {
        return;
      }
      const varName = this.jsVarName(propertyName);
      const tmpVarName = shadersCollectionController.addVariable(this, new _BaseJsPersistedConfigUtils/* PrimitiveArray */.QP([false]));
      const func = Poly/* Poly.namedFunctionsRegister.getFunction */.L.namedFunctionsRegister.getFunction(functionName, this, shadersCollectionController);
      shadersCollectionController.addBodyOrComputed(this, [
        {
          dataType: type,
          varName,
          value: func.asString(object3D, tmpVarName)
        }
      ]);
    };
    _v3(
      "position" /* position */,
      "getChildrenPropertiesPosition",
      connections_Js/* JsConnectionPointType.VECTOR3_ARRAY */.zF.VECTOR3_ARRAY
    );
    _v3(
      "scale" /* scale */,
      "getChildrenPropertiesScale",
      connections_Js/* JsConnectionPointType.VECTOR3_ARRAY */.zF.VECTOR3_ARRAY
    );
    _v3("up" /* up */, "getChildrenPropertiesUp", connections_Js/* JsConnectionPointType.VECTOR3_ARRAY */.zF.VECTOR3_ARRAY);
    _q(
      "quaternion" /* quaternion */,
      "getChildrenPropertiesQuaternion",
      connections_Js/* JsConnectionPointType.QUATERNION_ARRAY */.zF.QUATERNION_ARRAY
    );
    _b(
      "visible" /* visible */,
      "getChildrenPropertiesVisible",
      connections_Js/* JsConnectionPointType.BOOLEAN_ARRAY */.zF.BOOLEAN_ARRAY
    );
    _b(
      "matrixAutoUpdate" /* matrixAutoUpdate */,
      "getChildrenPropertiesMatrixAutoUpdate",
      connections_Js/* JsConnectionPointType.BOOLEAN_ARRAY */.zF.BOOLEAN_ARRAY
    );
    _b(
      "castShadow" /* castShadow */,
      "getChildrenPropertiesCastShadow",
      connections_Js/* JsConnectionPointType.BOOLEAN_ARRAY */.zF.BOOLEAN_ARRAY
    );
    _b(
      "receiveShadow" /* receiveShadow */,
      "getChildrenPropertiesReceiveShadow",
      connections_Js/* JsConnectionPointType.BOOLEAN_ARRAY */.zF.BOOLEAN_ARRAY
    );
    _b(
      "frustumCulled" /* frustumCulled */,
      "getChildrenPropertiesFrustumCulled",
      connections_Js/* JsConnectionPointType.BOOLEAN_ARRAY */.zF.BOOLEAN_ARRAY
    );
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/js/GetDefaultCamera.ts





class GetDefaultCameraJsParamsConfig extends params_ParamsConfig/* NodeParamsConfig */.yI {
}
const GetDefaultCamera_ParamsConfig = new GetDefaultCameraJsParamsConfig();
class GetDefaultCameraJsNode extends js_Base/* TypedJsNode */.xZ {
  constructor() {
    super(...arguments);
    this.paramsConfig = GetDefaultCamera_ParamsConfig;
  }
  static type() {
    return "getDefaultCamera";
  }
  initializeNode() {
    this.io.inputs.setNamedInputConnectionPoints([]);
    this.io.outputs.setNamedOutputConnectionPoints([
      new connections_Js/* JsConnectionPoint */.fp(connections_Js/* JsConnectionPointType.CAMERA */.zF.CAMERA, connections_Js/* JsConnectionPointType.CAMERA */.zF.CAMERA)
    ]);
  }
  setLines(shadersCollectionController) {
    const varName = this.jsVarName(connections_Js/* JsConnectionPointType.CAMERA */.zF.CAMERA);
    const func = Poly/* Poly.namedFunctionsRegister.getFunction */.L.namedFunctionsRegister.getFunction("getDefaultCamera", this, shadersCollectionController);
    shadersCollectionController.addBodyOrComputed(this, [
      {
        dataType: connections_Js/* JsConnectionPointType.CAMERA */.zF.CAMERA,
        varName,
        value: func.asString()
      }
    ]);
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/js/GetGeometryBoundingBox.ts







const GetGeometryBoundingBox_CONNECTION_OPTIONS = connections_Js/* JS_CONNECTION_POINT_IN_NODE_DEF */.mX;
const GetGeometryBoundingBoxInputName = {
  [connections_Js/* JsConnectionPointType.OBJECT_3D */.zF.OBJECT_3D]: connections_Js/* JsConnectionPointType.OBJECT_3D */.zF.OBJECT_3D
};
var GetGeometryBoundingBoxOutputName = /* @__PURE__ */ ((GetGeometryBoundingBoxOutputName2) => {
  GetGeometryBoundingBoxOutputName2["BOX3"] = "Box3";
  return GetGeometryBoundingBoxOutputName2;
})(GetGeometryBoundingBoxOutputName || {});
class GetGeometryBoundingBoxJsParamsConfig extends params_ParamsConfig/* NodeParamsConfig */.yI {
  constructor() {
    super(...arguments);
    this.forceCompute = params_ParamsConfig/* ParamConfig.BOOLEAN */.XC.BOOLEAN(1);
  }
}
const GetGeometryBoundingBox_ParamsConfig = new GetGeometryBoundingBoxJsParamsConfig();
class GetGeometryBoundingBoxJsNode extends js_Base/* TypedJsNode */.xZ {
  constructor() {
    super(...arguments);
    this.paramsConfig = GetGeometryBoundingBox_ParamsConfig;
  }
  static type() {
    return "getGeometryBoundingBox";
  }
  initializeNode() {
    this.io.inputs.setNamedInputConnectionPoints([
      new connections_Js/* JsConnectionPoint */.fp(connections_Js/* JsConnectionPointType.OBJECT_3D */.zF.OBJECT_3D, connections_Js/* JsConnectionPointType.OBJECT_3D */.zF.OBJECT_3D, GetGeometryBoundingBox_CONNECTION_OPTIONS)
    ]);
    this.io.outputs.setNamedOutputConnectionPoints([
      new connections_Js/* JsConnectionPoint */.fp(connections_Js/* JsConnectionPointType.OBJECT_3D */.zF.OBJECT_3D, connections_Js/* JsConnectionPointType.OBJECT_3D */.zF.OBJECT_3D),
      new connections_Js/* JsConnectionPoint */.fp("Box3" /* BOX3 */, connections_Js/* JsConnectionPointType.BOX3 */.zF.BOX3)
    ]);
  }
  setLines(linesController) {
    (0,_BaseObject3D/* setObject3DOutputLine */.PV)(this, linesController);
    const usedOutputNames = this.io.outputs.used_output_names();
    const forceCompute = this.variableForInputParam(linesController, this.p.forceCompute);
    const object3D = (0,_BaseObject3D/* inputObject3D */.iv)(this, linesController);
    const _b3 = (propertyName, functionName, type) => {
      if (!usedOutputNames.includes(propertyName)) {
        return;
      }
      const varName = this.jsVarName(propertyName);
      const tmpVarName = linesController.addVariable(this, new three_module.Box3());
      const func = Poly/* Poly.namedFunctionsRegister.getFunction */.L.namedFunctionsRegister.getFunction(functionName, this, linesController);
      linesController.addBodyOrComputed(this, [
        {
          dataType: type,
          varName,
          value: func.asString(object3D, forceCompute, tmpVarName)
        }
      ]);
    };
    _b3("Box3" /* BOX3 */, "getGeometryBoundingBox", connections_Js/* JsConnectionPointType.BOX3 */.zF.BOX3);
  }
}

// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/nodes/js/GetGeometryNodeObjects.ts
var GetGeometryNodeObjects = __webpack_require__(90223);
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/js/GetGeometryPositions.ts








const GetGeometryPositions_CONNECTION_OPTIONS = connections_Js/* JS_CONNECTION_POINT_IN_NODE_DEF */.mX;
const GetGeometryPositionsInputName = {
  [connections_Js/* JsConnectionPointType.OBJECT_3D */.zF.OBJECT_3D]: connections_Js/* JsConnectionPointType.OBJECT_3D */.zF.OBJECT_3D
};
var GetGeometryPositionsOutputName = /* @__PURE__ */ ((GetGeometryPositionsOutputName2) => {
  GetGeometryPositionsOutputName2["P"] = "positions";
  return GetGeometryPositionsOutputName2;
})(GetGeometryPositionsOutputName || {});
class GetGeometryPositionsJsParamsConfig extends params_ParamsConfig/* NodeParamsConfig */.yI {
}
const GetGeometryPositions_ParamsConfig = new GetGeometryPositionsJsParamsConfig();
class GetGeometryPositionsJsNode extends js_Base/* TypedJsNode */.xZ {
  constructor() {
    super(...arguments);
    this.paramsConfig = GetGeometryPositions_ParamsConfig;
  }
  static type() {
    return "getGeometryPositions";
  }
  initializeNode() {
    this.io.inputs.setNamedInputConnectionPoints([
      new connections_Js/* JsConnectionPoint */.fp(connections_Js/* JsConnectionPointType.OBJECT_3D */.zF.OBJECT_3D, connections_Js/* JsConnectionPointType.OBJECT_3D */.zF.OBJECT_3D, GetGeometryPositions_CONNECTION_OPTIONS)
    ]);
    this.io.outputs.setNamedOutputConnectionPoints([
      new connections_Js/* JsConnectionPoint */.fp(connections_Js/* JsConnectionPointType.OBJECT_3D */.zF.OBJECT_3D, connections_Js/* JsConnectionPointType.OBJECT_3D */.zF.OBJECT_3D),
      new connections_Js/* JsConnectionPoint */.fp("positions" /* P */, connections_Js/* JsConnectionPointType.VECTOR3_ARRAY */.zF.VECTOR3_ARRAY)
    ]);
  }
  setLines(linesController) {
    (0,_BaseObject3D/* setObject3DOutputLine */.PV)(this, linesController);
    const usedOutputNames = this.io.outputs.used_output_names();
    const object3D = (0,_BaseObject3D/* inputObject3D */.iv)(this, linesController);
    const _v3 = (propertyName, functionName, type) => {
      if (!usedOutputNames.includes(propertyName)) {
        return;
      }
      const varName = this.jsVarName(propertyName);
      const tmpVarName = linesController.addVariable(this, new _BaseJsPersistedConfigUtils/* VectorArray */.ex([new three_module.Vector3()]));
      const func = Poly/* Poly.namedFunctionsRegister.getFunction */.L.namedFunctionsRegister.getFunction(functionName, this, linesController);
      linesController.addBodyOrComputed(this, [
        {
          dataType: type,
          varName,
          value: func.asString(object3D, tmpVarName)
        }
      ]);
    };
    _v3("positions" /* P */, "getGeometryPositions", connections_Js/* JsConnectionPointType.VECTOR3_ARRAY */.zF.VECTOR3_ARRAY);
  }
}

// EXTERNAL MODULE: ../@polygonjs/polygonjs/node_modules/@vue/reactivity/dist/reactivity.esm-bundler.js
var reactivity_esm_bundler = __webpack_require__(66316);
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/core/reactivity/PointPropertyReactivity.ts


var GetPointPropertyJsNodeInputName = /* @__PURE__ */ ((GetPointPropertyJsNodeInputName2) => {
  GetPointPropertyJsNodeInputName2["ptnum"] = "ptnum";
  GetPointPropertyJsNodeInputName2["position"] = "position";
  return GetPointPropertyJsNodeInputName2;
})(GetPointPropertyJsNodeInputName || {});
const ptnumRefByObjectUuid = /* @__PURE__ */ new Map();
function getObjectPtnumRef(object3D) {
  let _ref = ptnumRefByObjectUuid.get(object3D.uuid);
  if (!_ref) {
    _ref = (0,reactivity_esm_bundler/* ref */.iH)(-1);
    ptnumRefByObjectUuid.set(object3D.uuid, _ref);
  }
  return _ref;
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/js/GetPointAttribute.ts

var GetPointAttribute_defProp = Object.defineProperty;
var GetPointAttribute_getOwnPropSymbols = Object.getOwnPropertySymbols;
var GetPointAttribute_hasOwnProp = Object.prototype.hasOwnProperty;
var GetPointAttribute_propIsEnum = Object.prototype.propertyIsEnumerable;
var GetPointAttribute_defNormalProp = (obj, key, value) => key in obj ? GetPointAttribute_defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var GetPointAttribute_spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (GetPointAttribute_hasOwnProp.call(b, prop))
      GetPointAttribute_defNormalProp(a, prop, b[prop]);
  if (GetPointAttribute_getOwnPropSymbols)
    for (var prop of GetPointAttribute_getOwnPropSymbols(b)) {
      if (GetPointAttribute_propIsEnum.call(b, prop))
        GetPointAttribute_defNormalProp(a, prop, b[prop]);
    }
  return a;
};









const GetPointAttribute_CONNECTION_OPTIONS = connections_Js/* JS_CONNECTION_POINT_IN_NODE_DEF */.mX;
const AVAILABLE_TYPES = [
  connections_Js/* JsConnectionPointType.FLOAT */.zF.FLOAT,
  connections_Js/* JsConnectionPointType.INT */.zF.INT,
  connections_Js/* JsConnectionPointType.VECTOR2 */.zF.VECTOR2,
  connections_Js/* JsConnectionPointType.VECTOR3 */.zF.VECTOR3,
  connections_Js/* JsConnectionPointType.VECTOR4 */.zF.VECTOR4
];
function typedVisibleOptions(type, otherParamVal = {}) {
  const val = AVAILABLE_TYPES.indexOf(type);
  return { visibleIf: GetPointAttribute_spreadValues({ type: val }, otherParamVal) };
}
var GetPointAttributeInputName = /* @__PURE__ */ ((GetPointAttributeInputName2) => {
  GetPointAttributeInputName2["attribName"] = "attribName";
  return GetPointAttributeInputName2;
})(GetPointAttributeInputName || {});
var GetPointAttributeOutputName = /* @__PURE__ */ ((GetPointAttributeOutputName2) => {
  GetPointAttributeOutputName2["VALUE"] = "val";
  return GetPointAttributeOutputName2;
})(GetPointAttributeOutputName || {});
class GetObjectAttributeJsParamsConfig extends params_ParamsConfig/* NodeParamsConfig */.yI {
  constructor() {
    super(...arguments);
    // attribName = ParamConfig.STRING('');
    this.type = params_ParamsConfig/* ParamConfig.INTEGER */.XC.INTEGER(AVAILABLE_TYPES.indexOf(connections_Js/* JsConnectionPointType.FLOAT */.zF.FLOAT), {
      menu: {
        entries: AVAILABLE_TYPES.map((name, value) => ({ name, value }))
      }
    });
    this.defaultFloat = params_ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(0, typedVisibleOptions(connections_Js/* JsConnectionPointType.FLOAT */.zF.FLOAT));
    this.defaultInteger = params_ParamsConfig/* ParamConfig.INTEGER */.XC.INTEGER(0, typedVisibleOptions(connections_Js/* JsConnectionPointType.INT */.zF.INT));
    this.defaultVector2 = params_ParamsConfig/* ParamConfig.VECTOR2 */.XC.VECTOR2([0, 0], typedVisibleOptions(connections_Js/* JsConnectionPointType.VECTOR2 */.zF.VECTOR2));
    this.defaultVector3 = params_ParamsConfig/* ParamConfig.VECTOR3 */.XC.VECTOR3([0, 0, 0], typedVisibleOptions(connections_Js/* JsConnectionPointType.VECTOR3 */.zF.VECTOR3));
    this.defaultVector4 = params_ParamsConfig/* ParamConfig.VECTOR4 */.XC.VECTOR4([0, 0, 0, 0], typedVisibleOptions(connections_Js/* JsConnectionPointType.VECTOR4 */.zF.VECTOR4));
  }
}
const GetPointAttribute_ParamsConfig = new GetObjectAttributeJsParamsConfig();
class GetPointAttributeJsNode extends js_Base/* TypedJsNode */.xZ {
  constructor() {
    super(...arguments);
    this.paramsConfig = GetPointAttribute_ParamsConfig;
    this._nextAttribName = "";
  }
  static type() {
    return Js/* JsType.GET_POINT_ATTRIBUTE */.K.GET_POINT_ATTRIBUTE;
  }
  initializeNode() {
    this.io.inputs.setNamedInputConnectionPoints([
      new connections_Js/* JsConnectionPoint */.fp(connections_Js/* JsConnectionPointType.OBJECT_3D */.zF.OBJECT_3D, connections_Js/* JsConnectionPointType.OBJECT_3D */.zF.OBJECT_3D, GetPointAttribute_CONNECTION_OPTIONS),
      new connections_Js/* JsConnectionPoint */.fp(GetPointPropertyJsNodeInputName.ptnum, connections_Js/* JsConnectionPointType.INT */.zF.INT, GetPointAttribute_CONNECTION_OPTIONS),
      new connections_Js/* JsConnectionPoint */.fp(
        "attribName" /* attribName */,
        connections_Js/* JsConnectionPointType.STRING */.zF.STRING,
        GetPointAttribute_CONNECTION_OPTIONS
      )
    ]);
    this.io.connection_points.set_expected_input_types_function(() => []);
    this.io.connection_points.set_expected_output_types_function(() => [
      connections_Js/* JsConnectionPointType.INT */.zF.INT,
      this._currentConnectionType()
    ]);
    this.io.connection_points.set_output_name_function(
      (index) => [GetPointPropertyJsNodeInputName.ptnum, "val" /* VALUE */][index]
    );
  }
  _currentConnectionType() {
    if (this.pv.type == null) {
      console.warn(`${this.type()} js node type not valid`);
    }
    const type = this.attribType();
    if (type == null) {
      console.warn(`${this.type()} js node type not valid`);
    }
    return type;
  }
  defaultValueParam() {
    const type = this.attribType();
    switch (type) {
      case connections_Js/* JsConnectionPointType.FLOAT */.zF.FLOAT: {
        return this.p.defaultFloat;
      }
      case connections_Js/* JsConnectionPointType.INT */.zF.INT: {
        return this.p.defaultInteger;
      }
      case connections_Js/* JsConnectionPointType.VECTOR2 */.zF.VECTOR2: {
        return this.p.defaultVector2;
      }
      case connections_Js/* JsConnectionPointType.VECTOR3 */.zF.VECTOR3: {
        return this.p.defaultVector3;
      }
      case connections_Js/* JsConnectionPointType.VECTOR4 */.zF.VECTOR4: {
        return this.p.defaultVector4;
      }
    }
    Assert/* TypeAssert.unreachable */.f.unreachable(type);
  }
  _bodyLine(linesController) {
    const object3D = (0,_BaseObject3D/* inputObject3D */.iv)(this, linesController);
    const ptnum = (0,_BaseObject3D/* inputPointIndex */.m7)(this, linesController);
    const attribName = this.variableForInput(linesController, "attribName" /* attribName */);
    const defaultParam = this.defaultValueParam();
    const defaultValue = this.variableForInputParam(linesController, defaultParam);
    const type = this.attribType();
    switch (type) {
      case connections_Js/* JsConnectionPointType.FLOAT */.zF.FLOAT:
      case connections_Js/* JsConnectionPointType.INT */.zF.INT: {
        const func = Poly/* Poly.namedFunctionsRegister.getFunction */.L.namedFunctionsRegister.getFunction("getPointAttributeNumber", this, linesController);
        return func.asString(object3D, ptnum, attribName, defaultValue);
      }
      case connections_Js/* JsConnectionPointType.VECTOR2 */.zF.VECTOR2:
      case connections_Js/* JsConnectionPointType.VECTOR3 */.zF.VECTOR3:
      case connections_Js/* JsConnectionPointType.VECTOR4 */.zF.VECTOR4: {
        const functionName = type == connections_Js/* JsConnectionPointType.VECTOR2 */.zF.VECTOR2 ? "getPointAttributeVector2" : type == connections_Js/* JsConnectionPointType.VECTOR3 */.zF.VECTOR3 ? "getPointAttributeVector3" : "getPointAttributeVector4";
        const tmpVar = type == connections_Js/* JsConnectionPointType.VECTOR2 */.zF.VECTOR2 ? new three_module.Vector2() : type == connections_Js/* JsConnectionPointType.VECTOR3 */.zF.VECTOR3 ? new three_module.Vector3() : new three_module.Vector4();
        const tmpVarName = linesController.addVariable(this, tmpVar);
        const func = Poly/* Poly.namedFunctionsRegister.getFunction */.L.namedFunctionsRegister.getFunction(functionName, this, linesController);
        return func.asString(object3D, ptnum, attribName, defaultValue, tmpVarName);
      }
    }
    Assert/* TypeAssert.unreachable */.f.unreachable(type);
  }
  paramDefaultValue(name) {
    return {
      ["attribName" /* attribName */]: this._nextAttribName
    }[name];
  }
  setAttribType(type) {
    this.p.type.set(AVAILABLE_TYPES.indexOf(type));
  }
  attribType() {
    const type = AVAILABLE_TYPES[this.pv.type];
    return type;
  }
  setAttribName(attribName) {
    const param = this.params.get("attribName" /* attribName */);
    if (param) {
      param.set(attribName);
    } else {
      this._nextAttribName = attribName;
    }
  }
  attributeName() {
    return this.params.get("attribName" /* attribName */).value;
  }
  setLines(linesController) {
    const out = this.jsVarName("val" /* VALUE */);
    const dataType = AVAILABLE_TYPES[this.pv.type];
    const bodyLine = this._bodyLine(linesController);
    linesController.addBodyOrComputed(this, [{ dataType, varName: out, value: bodyLine }]);
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/js/GetInstanceAttribute.ts



class GetInstanceAttributeJsNode extends GetPointAttributeJsNode {
  static type() {
    return Js/* JsType.GET_INSTANCE_ATTRIBUTE */.K.GET_INSTANCE_ATTRIBUTE;
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/core/reactivity/InstancePropertyReactivity.ts

var GetInstancePropertyJsNodeInputName = /* @__PURE__ */ ((GetInstancePropertyJsNodeInputName2) => {
  GetInstancePropertyJsNodeInputName2["ptnum"] = "ptnum";
  GetInstancePropertyJsNodeInputName2["instancePosition"] = "instancePosition";
  GetInstancePropertyJsNodeInputName2["instanceQuaternion"] = "instanceQuaternion";
  GetInstancePropertyJsNodeInputName2["instanceScale"] = "instanceScale";
  return GetInstancePropertyJsNodeInputName2;
})(GetInstancePropertyJsNodeInputName || {});

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/js/GetInstanceProperty.ts








const GetInstanceProperty_CONNECTION_OPTIONS = connections_Js/* JS_CONNECTION_POINT_IN_NODE_DEF */.mX;
class GetInstancePropertyJsNode extends js_Base/* ParamlessTypedJsNode */.au {
  static type() {
    return Js/* JsType.GET_INSTANCE_PROPERTY */.K.GET_INSTANCE_PROPERTY;
  }
  initializeNode() {
    this.io.inputs.setNamedInputConnectionPoints([
      new connections_Js/* JsConnectionPoint */.fp(connections_Js/* JsConnectionPointType.OBJECT_3D */.zF.OBJECT_3D, connections_Js/* JsConnectionPointType.OBJECT_3D */.zF.OBJECT_3D, GetInstanceProperty_CONNECTION_OPTIONS),
      new connections_Js/* JsConnectionPoint */.fp(
        GetInstancePropertyJsNodeInputName.ptnum,
        connections_Js/* JsConnectionPointType.INT */.zF.INT,
        GetInstanceProperty_CONNECTION_OPTIONS
      )
    ]);
    this.io.outputs.setNamedOutputConnectionPoints([
      new connections_Js/* JsConnectionPoint */.fp(
        GetInstancePropertyJsNodeInputName.ptnum,
        connections_Js/* JsConnectionPointType.INT */.zF.INT,
        GetInstanceProperty_CONNECTION_OPTIONS
      ),
      new connections_Js/* JsConnectionPoint */.fp(GetInstancePropertyJsNodeInputName.instancePosition, connections_Js/* JsConnectionPointType.VECTOR3 */.zF.VECTOR3),
      new connections_Js/* JsConnectionPoint */.fp(
        GetInstancePropertyJsNodeInputName.instanceQuaternion,
        connections_Js/* JsConnectionPointType.QUATERNION */.zF.QUATERNION
      ),
      new connections_Js/* JsConnectionPoint */.fp(GetInstancePropertyJsNodeInputName.instanceScale, connections_Js/* JsConnectionPointType.VECTOR3 */.zF.VECTOR3)
    ]);
  }
  setLines(linesController) {
    const usedOutputNames = this.io.outputs.used_output_names();
    const object3D = (0,_BaseObject3D/* inputObject3D */.iv)(this, linesController);
    const ptnum = (0,_BaseObject3D/* inputPointIndex */.m7)(this, linesController);
    const _v3 = (propertyName, functionName) => {
      if (!usedOutputNames.includes(propertyName)) {
        return;
      }
      const func = Poly/* Poly.namedFunctionsRegister.getFunction */.L.namedFunctionsRegister.getFunction(functionName, this, linesController);
      const tmpVarName = linesController.addVariable(this, new three_module.Vector3());
      linesController.addBodyOrComputed(this, [
        {
          dataType: connections_Js/* JsConnectionPointType.VECTOR3 */.zF.VECTOR3,
          varName: this.jsVarName(propertyName),
          value: func.asString(object3D, ptnum, tmpVarName)
        }
      ]);
    };
    const _q = (propertyName, functionName) => {
      if (!usedOutputNames.includes(propertyName)) {
        return;
      }
      const func = Poly/* Poly.namedFunctionsRegister.getFunction */.L.namedFunctionsRegister.getFunction(functionName, this, linesController);
      const tmpVarName = linesController.addVariable(this, new three_module.Quaternion());
      linesController.addBodyOrComputed(this, [
        {
          dataType: connections_Js/* JsConnectionPointType.VECTOR3 */.zF.VECTOR3,
          varName: this.jsVarName(propertyName),
          value: func.asString(object3D, ptnum, tmpVarName)
        }
      ]);
    };
    const _int = (propertyName, functionName) => {
      if (!usedOutputNames.includes(propertyName)) {
        return;
      }
      const func = Poly/* Poly.namedFunctionsRegister.getFunction */.L.namedFunctionsRegister.getFunction(functionName, this, linesController);
      linesController.addBodyOrComputed(this, [
        {
          dataType: connections_Js/* JsConnectionPointType.INT */.zF.INT,
          varName: this.jsVarName(propertyName),
          value: func.asString(object3D)
        }
      ]);
    };
    _int(GetInstancePropertyJsNodeInputName.ptnum, "getPointIndex");
    _v3(GetInstancePropertyJsNodeInputName.instancePosition, "getPointInstancePosition");
    _q(GetInstancePropertyJsNodeInputName.instanceQuaternion, "getPointInstanceQuaternion");
    _v3(GetInstancePropertyJsNodeInputName.instanceScale, "getPointInstanceScale");
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/js/GetIntersectionAttribute.ts







var GetIntersectionAttributeInputName = /* @__PURE__ */ ((GetIntersectionAttributeInputName2) => {
  GetIntersectionAttributeInputName2["attribName"] = "attribName";
  GetIntersectionAttributeInputName2["notFoundValue"] = "notFoundValue";
  return GetIntersectionAttributeInputName2;
})(GetIntersectionAttributeInputName || {});
class GetIntersectionAttributeJsParamsConfig extends params_ParamsConfig/* NodeParamsConfig */.yI {
  constructor() {
    super(...arguments);
    this.type = params_ParamsConfig/* ParamConfig.INTEGER */.XC.INTEGER(connections_Js/* PARAM_CONVERTIBLE_JS_CONNECTION_POINT_TYPES.indexOf */.mH.indexOf(connections_Js/* JsConnectionPointType.FLOAT */.zF.FLOAT), {
      menu: {
        entries: connections_Js/* PARAM_CONVERTIBLE_JS_CONNECTION_POINT_TYPES.map */.mH.map((name, value) => ({ name, value }))
      }
    });
    this.interpolated = params_ParamsConfig/* ParamConfig.BOOLEAN */.XC.BOOLEAN(1);
  }
}
const GetIntersectionAttribute_ParamsConfig = new GetIntersectionAttributeJsParamsConfig();
const _GetIntersectionAttributeJsNode = class extends js_Base/* TypedJsNode */.xZ {
  constructor() {
    super(...arguments);
    this.paramsConfig = GetIntersectionAttribute_ParamsConfig;
    this._nextAttribName = "";
  }
  static type() {
    return "getIntersectionAttribute";
  }
  initializeNode() {
    this.io.connection_points.spare_params.setInputlessParamNames(["interpolated"]);
    this.io.connection_points.set_expected_input_types_function(this._expectedInputTypes.bind(this));
    this.io.connection_points.set_expected_output_types_function(() => [this.attribType()]);
    this.io.connection_points.set_input_name_function(this._expectedInputNames.bind(this));
    this.io.connection_points.set_output_name_function(
      (index) => _GetIntersectionAttributeJsNode.OUTPUT_NAME
    );
  }
  _expectedInputTypes() {
    return [connections_Js/* JsConnectionPointType.INTERSECTION */.zF.INTERSECTION, connections_Js/* JsConnectionPointType.STRING */.zF.STRING, this.attribType()];
  }
  _expectedInputNames(index) {
    return [
      connections_Js/* JsConnectionPointType.INTERSECTION */.zF.INTERSECTION,
      "attribName" /* attribName */,
      "notFoundValue" /* notFoundValue */
    ][index];
  }
  paramDefaultValue(name) {
    return {
      ["attribName" /* attribName */]: this._nextAttribName,
      ["notFoundValue" /* notFoundValue */]: -1
    }[name];
  }
  setAttribType(type) {
    this.p.type.set(connections_Js/* PARAM_CONVERTIBLE_JS_CONNECTION_POINT_TYPES.indexOf */.mH.indexOf(type));
  }
  attribType() {
    return connections_Js/* PARAM_CONVERTIBLE_JS_CONNECTION_POINT_TYPES */.mH[this.pv.type];
  }
  setAttribName(attribName) {
    const param = this.params.get("attribName" /* attribName */);
    if (param) {
      param.set(attribName);
    } else {
      this._nextAttribName = attribName;
    }
  }
  attributeName() {
    return this.params.get("attribName" /* attribName */).value;
  }
  setLines(shadersCollectionController) {
    const varName = this.jsVarName(_GetIntersectionAttributeJsNode.OUTPUT_NAME);
    const dataType = this.attribType();
    const bodyLine = this._getBodyLine(shadersCollectionController);
    if (bodyLine) {
      shadersCollectionController.addBodyOrComputed(this, [{ dataType, varName, value: bodyLine }]);
    }
  }
  _getBodyLine(shadersCollectionController) {
    const intersection = this.variableForInput(shadersCollectionController, connections_Js/* JsConnectionPointType.INTERSECTION */.zF.INTERSECTION);
    const attribName = this.variableForInput(
      shadersCollectionController,
      "attribName" /* attribName */
    );
    const notFoundValue = this.variableForInput(
      shadersCollectionController,
      "notFoundValue" /* notFoundValue */
    );
    const interpolated = this.pv.interpolated;
    const dataType = this.attribType();
    switch (dataType) {
      case connections_Js/* JsConnectionPointType.BOOLEAN */.zF.BOOLEAN:
      case connections_Js/* JsConnectionPointType.FLOAT */.zF.FLOAT:
      case connections_Js/* JsConnectionPointType.INT */.zF.INT: {
        const functionName = interpolated ? "getIntersectionAttributeNumberInterpolated" : "getIntersectionAttributeNumberNearest";
        const func = Poly/* Poly.namedFunctionsRegister.getFunction */.L.namedFunctionsRegister.getFunction(functionName, this, shadersCollectionController);
        return func.asString(intersection, attribName, notFoundValue);
      }
      case connections_Js/* JsConnectionPointType.COLOR */.zF.COLOR: {
        const functionName = interpolated ? "getIntersectionAttributeColorInterpolated" : "getIntersectionAttributeColorNearest";
        const func = Poly/* Poly.namedFunctionsRegister.getFunction */.L.namedFunctionsRegister.getFunction(functionName, this, shadersCollectionController);
        const variable = (0,_BaseJsPersistedConfigUtils/* createVariable */.Os)(dataType);
        if (variable) {
          const tmpVarName = shadersCollectionController.addVariable(this, variable);
          func.asString(intersection, attribName, notFoundValue, tmpVarName);
        }
        return;
      }
      case connections_Js/* JsConnectionPointType.STRING */.zF.STRING: {
        const functionName = "getIntersectionAttributeStringNearest";
        const func = Poly/* Poly.namedFunctionsRegister.getFunction */.L.namedFunctionsRegister.getFunction(functionName, this, shadersCollectionController);
        func.asString(intersection, attribName);
        return;
      }
      case connections_Js/* JsConnectionPointType.VECTOR2 */.zF.VECTOR2: {
        const functionName = interpolated ? "getIntersectionAttributeVector2Interpolated" : "getIntersectionAttributeVector2Nearest";
        const func = Poly/* Poly.namedFunctionsRegister.getFunction */.L.namedFunctionsRegister.getFunction(functionName, this, shadersCollectionController);
        const variable = (0,_BaseJsPersistedConfigUtils/* createVariable */.Os)(dataType);
        if (variable) {
          const tmpVarName = shadersCollectionController.addVariable(this, variable);
          func.asString(intersection, attribName, notFoundValue, tmpVarName);
        }
        return;
      }
      case connections_Js/* JsConnectionPointType.VECTOR3 */.zF.VECTOR3: {
        const functionName = interpolated ? "getIntersectionAttributeVector3Interpolated" : "getIntersectionAttributeVector3Nearest";
        const func = Poly/* Poly.namedFunctionsRegister.getFunction */.L.namedFunctionsRegister.getFunction(functionName, this, shadersCollectionController);
        const variable = (0,_BaseJsPersistedConfigUtils/* createVariable */.Os)(dataType);
        if (variable) {
          const tmpVarName = shadersCollectionController.addVariable(this, variable);
          func.asString(intersection, attribName, notFoundValue, tmpVarName);
        }
        return;
      }
      case connections_Js/* JsConnectionPointType.VECTOR4 */.zF.VECTOR4: {
        const functionName = interpolated ? "getIntersectionAttributeVector4Interpolated" : "getIntersectionAttributeVector4Nearest";
        const func = Poly/* Poly.namedFunctionsRegister.getFunction */.L.namedFunctionsRegister.getFunction(functionName, this, shadersCollectionController);
        const variable = (0,_BaseJsPersistedConfigUtils/* createVariable */.Os)(dataType);
        if (variable) {
          const tmpVarName = shadersCollectionController.addVariable(this, variable);
          func.asString(intersection, attribName, notFoundValue, tmpVarName);
        }
        return;
      }
    }
    Assert/* TypeAssert.unreachable */.f.unreachable(dataType);
  }
};
let GetIntersectionAttributeJsNode = _GetIntersectionAttributeJsNode;
GetIntersectionAttributeJsNode.OUTPUT_NAME = "val";

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/js/GetIntersectionProperty.ts






const GetIntersectionProperty_CONNECTION_OPTIONS = connections_Js/* JS_CONNECTION_POINT_IN_NODE_DEF */.mX;
var GetIntersectionPropertyJsNodeOutputName = /* @__PURE__ */ ((GetIntersectionPropertyJsNodeOutputName2) => {
  GetIntersectionPropertyJsNodeOutputName2["distance"] = "distance";
  GetIntersectionPropertyJsNodeOutputName2["object"] = "object";
  GetIntersectionPropertyJsNodeOutputName2["point"] = "point";
  GetIntersectionPropertyJsNodeOutputName2["normal"] = "normal";
  GetIntersectionPropertyJsNodeOutputName2["uv"] = "uv";
  GetIntersectionPropertyJsNodeOutputName2["faceIndex"] = "faceIndex";
  return GetIntersectionPropertyJsNodeOutputName2;
})(GetIntersectionPropertyJsNodeOutputName || {});
class GetIntersectionPropertyJsNode extends js_Base/* ParamlessTypedJsNode */.au {
  static type() {
    return "getIntersectionProperty";
  }
  initializeNode() {
    this.io.inputs.setNamedInputConnectionPoints([
      new connections_Js/* JsConnectionPoint */.fp(
        connections_Js/* JsConnectionPointType.INTERSECTION */.zF.INTERSECTION,
        connections_Js/* JsConnectionPointType.INTERSECTION */.zF.INTERSECTION,
        GetIntersectionProperty_CONNECTION_OPTIONS
      )
    ]);
    this.io.outputs.setNamedOutputConnectionPoints([
      new connections_Js/* JsConnectionPoint */.fp("distance" /* distance */, connections_Js/* JsConnectionPointType.FLOAT */.zF.FLOAT),
      new connections_Js/* JsConnectionPoint */.fp("object" /* object */, connections_Js/* JsConnectionPointType.OBJECT_3D */.zF.OBJECT_3D),
      new connections_Js/* JsConnectionPoint */.fp("point" /* point */, connections_Js/* JsConnectionPointType.VECTOR3 */.zF.VECTOR3),
      new connections_Js/* JsConnectionPoint */.fp("normal" /* normal */, connections_Js/* JsConnectionPointType.VECTOR3 */.zF.VECTOR3),
      new connections_Js/* JsConnectionPoint */.fp("uv" /* uv */, connections_Js/* JsConnectionPointType.VECTOR2 */.zF.VECTOR2),
      new connections_Js/* JsConnectionPoint */.fp("faceIndex" /* faceIndex */, connections_Js/* JsConnectionPointType.INT */.zF.INT)
    ]);
  }
  setLines(shadersCollectionController) {
    const usedOutputNames = this.io.outputs.used_output_names();
    const object3D = (0,_BaseObject3D/* inputObject3D */.iv)(this, shadersCollectionController);
    const intersection = this.variableForInput(shadersCollectionController, connections_Js/* JsConnectionPointType.INTERSECTION */.zF.INTERSECTION);
    const _i = (propertyName, functionName, type) => {
      if (!usedOutputNames.includes(propertyName)) {
        return;
      }
      const varName = this.jsVarName(propertyName);
      const func = Poly/* Poly.namedFunctionsRegister.getFunction */.L.namedFunctionsRegister.getFunction(functionName, this, shadersCollectionController);
      shadersCollectionController.addBodyOrComputed(this, [
        {
          dataType: type,
          varName,
          value: func.asString(intersection)
        }
      ]);
    };
    const _f = (propertyName, functionName, type) => {
      if (!usedOutputNames.includes(propertyName)) {
        return;
      }
      const varName = this.jsVarName(propertyName);
      const func = Poly/* Poly.namedFunctionsRegister.getFunction */.L.namedFunctionsRegister.getFunction(functionName, this, shadersCollectionController);
      shadersCollectionController.addBodyOrComputed(this, [
        {
          dataType: type,
          varName,
          value: func.asString(intersection)
        }
      ]);
    };
    const _v2 = (propertyName, functionName, type) => {
      if (!usedOutputNames.includes(propertyName)) {
        return;
      }
      const varName = this.jsVarName(propertyName);
      const tmpVarName = shadersCollectionController.addVariable(this, new three_module.Vector2());
      const func = Poly/* Poly.namedFunctionsRegister.getFunction */.L.namedFunctionsRegister.getFunction(functionName, this, shadersCollectionController);
      shadersCollectionController.addBodyOrComputed(this, [
        {
          dataType: type,
          varName,
          value: func.asString(intersection, tmpVarName)
        }
      ]);
    };
    const _v3 = (propertyName, functionName, type) => {
      if (!usedOutputNames.includes(propertyName)) {
        return;
      }
      const varName = this.jsVarName(propertyName);
      const tmpVarName = shadersCollectionController.addVariable(this, new three_module.Vector3());
      const func = Poly/* Poly.namedFunctionsRegister.getFunction */.L.namedFunctionsRegister.getFunction(functionName, this, shadersCollectionController);
      shadersCollectionController.addBodyOrComputed(this, [
        {
          dataType: type,
          varName,
          value: func.asString(intersection, tmpVarName)
        }
      ]);
    };
    const _object = (propertyName, functionName, type) => {
      if (!usedOutputNames.includes(propertyName)) {
        return;
      }
      const varName = this.jsVarName(propertyName);
      const func = Poly/* Poly.namedFunctionsRegister.getFunction */.L.namedFunctionsRegister.getFunction(functionName, this, shadersCollectionController);
      shadersCollectionController.addBodyOrComputed(this, [
        {
          dataType: type,
          varName,
          value: func.asString(object3D, intersection)
        }
      ]);
    };
    _i(
      "faceIndex" /* faceIndex */,
      "getIntersectionPropertyFaceIndex",
      connections_Js/* JsConnectionPointType.INT */.zF.INT
    );
    _f(
      "distance" /* distance */,
      "getIntersectionPropertyDistance",
      connections_Js/* JsConnectionPointType.FLOAT */.zF.FLOAT
    );
    _v3(
      "point" /* point */,
      "getIntersectionPropertyPoint",
      connections_Js/* JsConnectionPointType.VECTOR3 */.zF.VECTOR3
    );
    _v3(
      "normal" /* normal */,
      "getIntersectionPropertyNormal",
      connections_Js/* JsConnectionPointType.VECTOR3 */.zF.VECTOR3
    );
    _v2("uv" /* uv */, "getIntersectionPropertyUv", connections_Js/* JsConnectionPointType.VECTOR2 */.zF.VECTOR2);
    _object(
      "object" /* object */,
      "getIntersectionPropertyObject",
      connections_Js/* JsConnectionPointType.OBJECT_3D */.zF.OBJECT_3D
    );
  }
}

// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/nodes/js/GetMaterial.ts
var GetMaterial = __webpack_require__(67946);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/nodes/js/GetNode.ts
var GetNode = __webpack_require__(44642);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/nodes/js/GetObject.ts
var GetObject = __webpack_require__(46208);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/nodes/js/GetObjectAttribute.ts
var GetObjectAttribute = __webpack_require__(76706);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/nodes/js/GetObjectChild.ts
var GetObjectChild = __webpack_require__(85528);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/core/reactivity/ObjectPropertyReactivity.ts
var ObjectPropertyReactivity = __webpack_require__(6098);
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/js/GetObjectProperty.ts







const GetObjectProperty_CONNECTION_OPTIONS = connections_Js/* JS_CONNECTION_POINT_IN_NODE_DEF */.mX;
class GetObjectPropertyJsNode extends js_Base/* ParamlessTypedJsNode */.au {
  static type() {
    return Js/* JsType.GET_OBJECT_PROPERTY */.K.GET_OBJECT_PROPERTY;
  }
  initializeNode() {
    this.io.inputs.setNamedInputConnectionPoints([
      new connections_Js/* JsConnectionPoint */.fp(connections_Js/* JsConnectionPointType.OBJECT_3D */.zF.OBJECT_3D, connections_Js/* JsConnectionPointType.OBJECT_3D */.zF.OBJECT_3D, GetObjectProperty_CONNECTION_OPTIONS)
    ]);
    this.io.outputs.setNamedOutputConnectionPoints([
      new connections_Js/* JsConnectionPoint */.fp(ObjectPropertyReactivity/* GetObjectPropertyJsNodeInputName.position */.De.position, connections_Js/* JsConnectionPointType.VECTOR3 */.zF.VECTOR3),
      new connections_Js/* JsConnectionPoint */.fp(ObjectPropertyReactivity/* GetObjectPropertyJsNodeInputName.rotation */.De.rotation, connections_Js/* JsConnectionPointType.EULER */.zF.EULER),
      new connections_Js/* JsConnectionPoint */.fp(ObjectPropertyReactivity/* GetObjectPropertyJsNodeInputName.quaternion */.De.quaternion, connections_Js/* JsConnectionPointType.QUATERNION */.zF.QUATERNION),
      new connections_Js/* JsConnectionPoint */.fp(ObjectPropertyReactivity/* GetObjectPropertyJsNodeInputName.scale */.De.scale, connections_Js/* JsConnectionPointType.VECTOR3 */.zF.VECTOR3),
      new connections_Js/* JsConnectionPoint */.fp(ObjectPropertyReactivity/* GetObjectPropertyJsNodeInputName.matrix */.De.matrix, connections_Js/* JsConnectionPointType.MATRIX4 */.zF.MATRIX4),
      new connections_Js/* JsConnectionPoint */.fp(ObjectPropertyReactivity/* GetObjectPropertyJsNodeInputName.up */.De.up, connections_Js/* JsConnectionPointType.VECTOR3 */.zF.VECTOR3),
      new connections_Js/* JsConnectionPoint */.fp(ObjectPropertyReactivity/* GetObjectPropertyJsNodeInputName.visible */.De.visible, connections_Js/* JsConnectionPointType.BOOLEAN */.zF.BOOLEAN),
      new connections_Js/* JsConnectionPoint */.fp(ObjectPropertyReactivity/* GetObjectPropertyJsNodeInputName.matrixAutoUpdate */.De.matrixAutoUpdate, connections_Js/* JsConnectionPointType.BOOLEAN */.zF.BOOLEAN),
      new connections_Js/* JsConnectionPoint */.fp(ObjectPropertyReactivity/* GetObjectPropertyJsNodeInputName.castShadow */.De.castShadow, connections_Js/* JsConnectionPointType.BOOLEAN */.zF.BOOLEAN),
      new connections_Js/* JsConnectionPoint */.fp(ObjectPropertyReactivity/* GetObjectPropertyJsNodeInputName.receiveShadow */.De.receiveShadow, connections_Js/* JsConnectionPointType.BOOLEAN */.zF.BOOLEAN),
      new connections_Js/* JsConnectionPoint */.fp(ObjectPropertyReactivity/* GetObjectPropertyJsNodeInputName.frustumCulled */.De.frustumCulled, connections_Js/* JsConnectionPointType.BOOLEAN */.zF.BOOLEAN),
      // new ActorConnectionPoint(GetObjectPropertyActorNodeInputName.id, ActorConnectionPointType.INTEGER),
      // new ActorConnectionPoint(GetObjectPropertyActorNodeInputName.uuid, ActorConnectionPointType.BOOLEAN),
      new connections_Js/* JsConnectionPoint */.fp(ObjectPropertyReactivity/* GetObjectPropertyJsNodeInputName.material */.De.material, connections_Js/* JsConnectionPointType.MATERIAL */.zF.MATERIAL)
    ]);
  }
  setLines(linesController) {
    const usedOutputNames = this.io.outputs.used_output_names();
    const object3D = (0,_BaseObject3D/* inputObject3D */.iv)(this, linesController);
    const _f = (propertyName, type) => {
      if (!usedOutputNames.includes(propertyName)) {
        return;
      }
      const func = Poly/* Poly.namedFunctionsRegister.getFunction */.L.namedFunctionsRegister.getFunction("getObjectProperty", this, linesController);
      linesController.addBodyOrComputed(this, [
        {
          dataType: type,
          varName: this.jsVarName(propertyName),
          value: func.asString(object3D, `'${propertyName}'`)
        }
      ]);
    };
    ObjectPropertyReactivity/* OBJECT_VECTOR3_PROPERTIES.forEach */.pz.forEach((propertyName) => {
      _f(propertyName, connections_Js/* JsConnectionPointType.VECTOR3 */.zF.VECTOR3);
    });
    ObjectPropertyReactivity/* OBJECT_BOOLEAN_PROPERTIES.forEach */.ue.forEach((propertyName) => {
      _f(propertyName, connections_Js/* JsConnectionPointType.BOOLEAN */.zF.BOOLEAN);
    });
    _f("rotation", connections_Js/* JsConnectionPointType.EULER */.zF.EULER);
    _f("quaternion", connections_Js/* JsConnectionPointType.QUATERNION */.zF.QUATERNION);
    _f("matrix", connections_Js/* JsConnectionPointType.MATRIX4 */.zF.MATRIX4);
    _f("material", connections_Js/* JsConnectionPointType.MATERIAL */.zF.MATERIAL);
  }
}

// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/nodes/js/GetObjectUserData.ts
var GetObjectUserData = __webpack_require__(17832);
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/js/GetObjectWorldPosition.ts






const GetObjectWorldPosition_CONNECTION_OPTIONS = connections_Js/* JS_CONNECTION_POINT_IN_NODE_DEF */.mX;
var GetObjectWorldPositionJsNodeInputName = /* @__PURE__ */ ((GetObjectWorldPositionJsNodeInputName2) => {
  GetObjectWorldPositionJsNodeInputName2["worldPosition"] = "worldPosition";
  return GetObjectWorldPositionJsNodeInputName2;
})(GetObjectWorldPositionJsNodeInputName || {});
class GetObjectWorldPositionJsNode extends js_Base/* ParamlessTypedJsNode */.au {
  static type() {
    return "getObjectWorldPosition";
  }
  initializeNode() {
    this.io.inputs.setNamedInputConnectionPoints([
      new connections_Js/* JsConnectionPoint */.fp(connections_Js/* JsConnectionPointType.OBJECT_3D */.zF.OBJECT_3D, connections_Js/* JsConnectionPointType.OBJECT_3D */.zF.OBJECT_3D, GetObjectWorldPosition_CONNECTION_OPTIONS)
    ]);
    this.io.outputs.setNamedOutputConnectionPoints([
      new connections_Js/* JsConnectionPoint */.fp("worldPosition" /* worldPosition */, connections_Js/* JsConnectionPointType.VECTOR3 */.zF.VECTOR3)
    ]);
  }
  setLines(shadersCollectionController) {
    const object3D = (0,_BaseObject3D/* inputObject3D */.iv)(this, shadersCollectionController);
    const varName = this.jsVarName("worldPosition" /* worldPosition */);
    const variable = (0,_BaseJsPersistedConfigUtils/* createVariable */.Os)(connections_Js/* JsConnectionPointType.VECTOR3 */.zF.VECTOR3);
    const tmpVarName = variable ? shadersCollectionController.addVariable(this, variable) : void 0;
    if (!tmpVarName) {
      return;
    }
    const func = Poly/* Poly.namedFunctionsRegister.getFunction */.L.namedFunctionsRegister.getFunction(
      "getObjectWorldPosition",
      this,
      shadersCollectionController
    );
    shadersCollectionController.addBodyOrComputed(this, [
      { dataType: connections_Js/* JsConnectionPointType.PLANE */.zF.PLANE, varName, value: func.asString(object3D, tmpVarName) }
    ]);
  }
}

// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/nodes/js/GetParam.ts
var GetParam = __webpack_require__(13941);
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/js/GetParent.ts






const GetParent_CONNECTION_OPTIONS = connections_Js/* JS_CONNECTION_POINT_IN_NODE_DEF */.mX;
class GetParentJsParamsConfig extends params_ParamsConfig/* NodeParamsConfig */.yI {
}
const GetParent_ParamsConfig = new GetParentJsParamsConfig();
class GetParentJsNode extends js_Base/* TypedJsNode */.xZ {
  constructor() {
    super(...arguments);
    this.paramsConfig = GetParent_ParamsConfig;
  }
  static type() {
    return "getParent";
  }
  initializeNode() {
    this.io.inputs.setNamedInputConnectionPoints([
      new connections_Js/* JsConnectionPoint */.fp(connections_Js/* JsConnectionPointType.OBJECT_3D */.zF.OBJECT_3D, connections_Js/* JsConnectionPointType.OBJECT_3D */.zF.OBJECT_3D, GetParent_CONNECTION_OPTIONS)
    ]);
    this.io.outputs.setNamedOutputConnectionPoints([
      new connections_Js/* JsConnectionPoint */.fp(connections_Js/* JsConnectionPointType.OBJECT_3D */.zF.OBJECT_3D, connections_Js/* JsConnectionPointType.OBJECT_3D */.zF.OBJECT_3D)
    ]);
  }
  setLines(shadersCollectionController) {
    const object3D = (0,_BaseObject3D/* inputObject3D */.iv)(this, shadersCollectionController);
    const out = this.jsVarName(connections_Js/* JsConnectionPointType.OBJECT_3D */.zF.OBJECT_3D);
    const func = Poly/* Poly.namedFunctionsRegister.getFunction */.L.namedFunctionsRegister.getFunction("getParent", this, shadersCollectionController);
    const bodyLine = func.asString(object3D);
    shadersCollectionController.addBodyOrComputed(this, [
      { dataType: connections_Js/* JsConnectionPointType.PLANE */.zF.PLANE, varName: out, value: bodyLine }
    ]);
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/js/GetPhysicsRBD.ts




const GetPhysicsRBD_CONNECTION_OPTIONS = connections_Js/* JS_CONNECTION_POINT_IN_NODE_DEF */.mX;
var GetPhysicsRBDJsNodeOutput = /* @__PURE__ */ ((GetPhysicsRBDJsNodeOutput2) => {
  GetPhysicsRBDJsNodeOutput2["RBD_ID"] = "RBDId";
  return GetPhysicsRBDJsNodeOutput2;
})(GetPhysicsRBDJsNodeOutput || {});
class GetPhysicsRBDJsNode extends js_Base/* ParamlessTypedJsNode */.au {
  static type() {
    return "getPhysicsRBD";
  }
  initializeNode() {
    this.io.inputs.setNamedInputConnectionPoints([
      new connections_Js/* JsConnectionPoint */.fp("RBDId" /* RBD_ID */, connections_Js/* JsConnectionPointType.STRING */.zF.STRING, GetPhysicsRBD_CONNECTION_OPTIONS)
    ]);
    this.io.outputs.setNamedOutputConnectionPoints([
      new connections_Js/* JsConnectionPoint */.fp(connections_Js/* JsConnectionPointType.OBJECT_3D */.zF.OBJECT_3D, connections_Js/* JsConnectionPointType.OBJECT_3D */.zF.OBJECT_3D, GetPhysicsRBD_CONNECTION_OPTIONS)
    ]);
  }
  setLines(linesController) {
    const rbdId = this.variableForInput(linesController, "RBDId" /* RBD_ID */);
    const out = this.jsVarName(connections_Js/* JsConnectionPointType.OBJECT_3D */.zF.OBJECT_3D);
    const func = Poly/* Poly.namedFunctionsRegister.getFunction */.L.namedFunctionsRegister.getFunction("getPhysicsRBD", this, linesController);
    linesController.addBodyOrComputed(this, [
      {
        dataType: connections_Js/* JsConnectionPointType.OBJECT_3D */.zF.OBJECT_3D,
        varName: out,
        value: func.asString(rbdId)
      }
    ]);
  }
}

// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/core/physics/shapes/_CommonHeightRadius.ts
var _CommonHeightRadius = __webpack_require__(42971);
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/js/GetPhysicsRBDConeProperty.ts






const GetPhysicsRBDConeProperty_CONNECTION_OPTIONS = connections_Js/* JS_CONNECTION_POINT_IN_NODE_DEF */.mX;
class GetPhysicsRBDConePropertyJsNode extends js_Base/* ParamlessTypedJsNode */.au {
  static type() {
    return "getPhysicsRBDConeproperty";
  }
  initializeNode() {
    this.io.inputs.setNamedInputConnectionPoints([
      new connections_Js/* JsConnectionPoint */.fp(connections_Js/* JsConnectionPointType.OBJECT_3D */.zF.OBJECT_3D, connections_Js/* JsConnectionPointType.OBJECT_3D */.zF.OBJECT_3D, GetPhysicsRBDConeProperty_CONNECTION_OPTIONS)
    ]);
    this.io.outputs.setNamedOutputConnectionPoints([
      new connections_Js/* JsConnectionPoint */.fp(_CommonHeightRadius/* RBDCommonProperty.RADIUS */.n7.RADIUS, connections_Js/* JsConnectionPointType.FLOAT */.zF.FLOAT),
      new connections_Js/* JsConnectionPoint */.fp(_CommonHeightRadius/* RBDCommonProperty.HEIGHT */.n7.HEIGHT, connections_Js/* JsConnectionPointType.FLOAT */.zF.FLOAT)
    ]);
  }
  setLines(shadersCollectionController) {
    const usedOutputNames = this.io.outputs.used_output_names();
    const object3D = (0,_BaseObject3D/* inputObject3D */.iv)(this, shadersCollectionController);
    const _f = (propertyName, functionName, type) => {
      if (!usedOutputNames.includes(propertyName)) {
        return;
      }
      const func = Poly/* Poly.namedFunctionsRegister.getFunction */.L.namedFunctionsRegister.getFunction(functionName, this, shadersCollectionController);
      shadersCollectionController.addBodyOrComputed(this, [
        {
          dataType: type,
          varName: this.jsVarName(propertyName),
          value: func.asString(object3D)
        }
      ]);
    };
    _f(_CommonHeightRadius/* RBDCommonProperty.RADIUS */.n7.RADIUS, "getPhysicsRBDConeRadius", connections_Js/* JsConnectionPointType.FLOAT */.zF.FLOAT);
    _f(_CommonHeightRadius/* RBDCommonProperty.HEIGHT */.n7.HEIGHT, "getPhysicsRBDConeHeight", connections_Js/* JsConnectionPointType.FLOAT */.zF.FLOAT);
  }
}

// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/core/physics/shapes/RBDCapsule.ts
var RBDCapsule = __webpack_require__(22915);
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/js/GetPhysicsRBDCapsuleProperty.ts






const GetPhysicsRBDCapsuleProperty_CONNECTION_OPTIONS = connections_Js/* JS_CONNECTION_POINT_IN_NODE_DEF */.mX;
class GetPhysicsRBDCapsulePropertyJsNode extends js_Base/* ParamlessTypedJsNode */.au {
  static type() {
    return "getPhysicsRBDCapsuleproperty";
  }
  initializeNode() {
    this.io.inputs.setNamedInputConnectionPoints([
      new connections_Js/* JsConnectionPoint */.fp(connections_Js/* JsConnectionPointType.OBJECT_3D */.zF.OBJECT_3D, connections_Js/* JsConnectionPointType.OBJECT_3D */.zF.OBJECT_3D, GetPhysicsRBDCapsuleProperty_CONNECTION_OPTIONS)
    ]);
    this.io.outputs.setNamedOutputConnectionPoints([
      new connections_Js/* JsConnectionPoint */.fp(RBDCapsule/* RBDCapsuleProperty.RADIUS */.ND.RADIUS, connections_Js/* JsConnectionPointType.FLOAT */.zF.FLOAT),
      new connections_Js/* JsConnectionPoint */.fp(RBDCapsule/* RBDCapsuleProperty.HEIGHT */.ND.HEIGHT, connections_Js/* JsConnectionPointType.FLOAT */.zF.FLOAT)
    ]);
  }
  setLines(shadersCollectionController) {
    const usedOutputNames = this.io.outputs.used_output_names();
    const object3D = (0,_BaseObject3D/* inputObject3D */.iv)(this, shadersCollectionController);
    const _f = (propertyName, functionName, type) => {
      if (!usedOutputNames.includes(propertyName)) {
        return;
      }
      const func = Poly/* Poly.namedFunctionsRegister.getFunction */.L.namedFunctionsRegister.getFunction(functionName, this, shadersCollectionController);
      shadersCollectionController.addBodyOrComputed(this, [
        {
          dataType: type,
          varName: this.jsVarName(propertyName),
          value: func.asString(object3D)
        }
      ]);
    };
    _f(RBDCapsule/* RBDCapsuleProperty.RADIUS */.ND.RADIUS, "getPhysicsRBDCapsuleRadius", connections_Js/* JsConnectionPointType.FLOAT */.zF.FLOAT);
    _f(RBDCapsule/* RBDCapsuleProperty.HEIGHT */.ND.HEIGHT, "getPhysicsRBDCapsuleHeight", connections_Js/* JsConnectionPointType.FLOAT */.zF.FLOAT);
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/js/GetPhysicsRBDCylinderProperty.ts






const GetPhysicsRBDCylinderProperty_CONNECTION_OPTIONS = connections_Js/* JS_CONNECTION_POINT_IN_NODE_DEF */.mX;
class GetPhysicsRBDCylinderPropertyJsNode extends js_Base/* ParamlessTypedJsNode */.au {
  static type() {
    return "getPhysicsRBDCylinderproperty";
  }
  initializeNode() {
    this.io.inputs.setNamedInputConnectionPoints([
      new connections_Js/* JsConnectionPoint */.fp(connections_Js/* JsConnectionPointType.OBJECT_3D */.zF.OBJECT_3D, connections_Js/* JsConnectionPointType.OBJECT_3D */.zF.OBJECT_3D, GetPhysicsRBDCylinderProperty_CONNECTION_OPTIONS)
    ]);
    this.io.outputs.setNamedOutputConnectionPoints([
      new connections_Js/* JsConnectionPoint */.fp(_CommonHeightRadius/* RBDCommonProperty.RADIUS */.n7.RADIUS, connections_Js/* JsConnectionPointType.FLOAT */.zF.FLOAT),
      new connections_Js/* JsConnectionPoint */.fp(_CommonHeightRadius/* RBDCommonProperty.HEIGHT */.n7.HEIGHT, connections_Js/* JsConnectionPointType.FLOAT */.zF.FLOAT)
    ]);
  }
  setLines(shadersCollectionController) {
    const usedOutputNames = this.io.outputs.used_output_names();
    const object3D = (0,_BaseObject3D/* inputObject3D */.iv)(this, shadersCollectionController);
    const _f = (propertyName, functionName, type) => {
      if (!usedOutputNames.includes(propertyName)) {
        return;
      }
      const func = Poly/* Poly.namedFunctionsRegister.getFunction */.L.namedFunctionsRegister.getFunction(functionName, this, shadersCollectionController);
      shadersCollectionController.addBodyOrComputed(this, [
        {
          dataType: type,
          varName: this.jsVarName(propertyName),
          value: func.asString(object3D)
        }
      ]);
    };
    _f(_CommonHeightRadius/* RBDCommonProperty.RADIUS */.n7.RADIUS, "getPhysicsRBDCylinderRadius", connections_Js/* JsConnectionPointType.FLOAT */.zF.FLOAT);
    _f(_CommonHeightRadius/* RBDCommonProperty.HEIGHT */.n7.HEIGHT, "getPhysicsRBDCylinderHeight", connections_Js/* JsConnectionPointType.FLOAT */.zF.FLOAT);
  }
}

// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/core/physics/shapes/RBDCuboid.ts
var RBDCuboid = __webpack_require__(18708);
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/js/GetPhysicsRBDCuboidProperty.ts







const GetPhysicsRBDCuboidProperty_CONNECTION_OPTIONS = connections_Js/* JS_CONNECTION_POINT_IN_NODE_DEF */.mX;
class GetPhysicsRBDCuboidPropertyJsNode extends js_Base/* ParamlessTypedJsNode */.au {
  static type() {
    return "getPhysicsRBDCuboidproperty";
  }
  initializeNode() {
    this.io.inputs.setNamedInputConnectionPoints([
      new connections_Js/* JsConnectionPoint */.fp(connections_Js/* JsConnectionPointType.OBJECT_3D */.zF.OBJECT_3D, connections_Js/* JsConnectionPointType.OBJECT_3D */.zF.OBJECT_3D, GetPhysicsRBDCuboidProperty_CONNECTION_OPTIONS)
    ]);
    this.io.outputs.setNamedOutputConnectionPoints([
      new connections_Js/* JsConnectionPoint */.fp(RBDCuboid/* RBDCuboidProperty.SIZES */.oF.SIZES, connections_Js/* JsConnectionPointType.VECTOR3 */.zF.VECTOR3)
    ]);
  }
  setLines(shadersCollectionController) {
    const usedOutputNames = this.io.outputs.used_output_names();
    const object3D = (0,_BaseObject3D/* inputObject3D */.iv)(this, shadersCollectionController);
    const _f = (propertyName, functionName, type) => {
      if (!usedOutputNames.includes(propertyName)) {
        return;
      }
      const func = Poly/* Poly.namedFunctionsRegister.getFunction */.L.namedFunctionsRegister.getFunction(functionName, this, shadersCollectionController);
      const out = this.jsVarName(propertyName);
      const tmpVarName = shadersCollectionController.addVariable(this, new three_module.Vector3());
      shadersCollectionController.addBodyOrComputed(this, [
        {
          dataType: type,
          varName: out,
          value: func.asString(object3D, tmpVarName)
        }
      ]);
    };
    _f(RBDCuboid/* RBDCuboidProperty.SIZES */.oF.SIZES, "getPhysicsRBDCuboidSizes", connections_Js/* JsConnectionPointType.FLOAT */.zF.FLOAT);
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/js/GetPhysicsRBDSphereProperty.ts






const GetPhysicsRBDSphereProperty_CONNECTION_OPTIONS = connections_Js/* JS_CONNECTION_POINT_IN_NODE_DEF */.mX;
class GetPhysicsRBDSpherePropertyJsNode extends js_Base/* ParamlessTypedJsNode */.au {
  static type() {
    return "getPhysicsRBDSphereproperty";
  }
  initializeNode() {
    this.io.inputs.setNamedInputConnectionPoints([
      new connections_Js/* JsConnectionPoint */.fp(connections_Js/* JsConnectionPointType.OBJECT_3D */.zF.OBJECT_3D, connections_Js/* JsConnectionPointType.OBJECT_3D */.zF.OBJECT_3D, GetPhysicsRBDSphereProperty_CONNECTION_OPTIONS)
    ]);
    this.io.outputs.setNamedOutputConnectionPoints([
      new connections_Js/* JsConnectionPoint */.fp(_CommonHeightRadius/* RBDCommonProperty.RADIUS */.n7.RADIUS, connections_Js/* JsConnectionPointType.FLOAT */.zF.FLOAT)
    ]);
  }
  setLines(shadersCollectionController) {
    const usedOutputNames = this.io.outputs.used_output_names();
    const object3D = (0,_BaseObject3D/* inputObject3D */.iv)(this, shadersCollectionController);
    const _f = (propertyName, functionName, type) => {
      if (!usedOutputNames.includes(propertyName)) {
        return;
      }
      const func = Poly/* Poly.namedFunctionsRegister.getFunction */.L.namedFunctionsRegister.getFunction(functionName, this, shadersCollectionController);
      shadersCollectionController.addBodyOrComputed(this, [
        {
          dataType: type,
          varName: this.jsVarName(propertyName),
          value: func.asString(object3D)
        }
      ]);
    };
    _f(_CommonHeightRadius/* RBDCommonProperty.RADIUS */.n7.RADIUS, "getPhysicsRBDSphereRadius", connections_Js/* JsConnectionPointType.FLOAT */.zF.FLOAT);
  }
}

// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/core/physics/PhysicsRBD.ts + 3 modules
var PhysicsRBD = __webpack_require__(30864);
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/js/GetPhysicsRBDProperty.ts







const GetPhysicsRBDProperty_CONNECTION_OPTIONS = connections_Js/* JS_CONNECTION_POINT_IN_NODE_DEF */.mX;
class GetPhysicsRBDPropertyJsNode extends js_Base/* ParamlessTypedJsNode */.au {
  static type() {
    return "getPhysicsRBDproperty";
  }
  initializeNode() {
    this.io.inputs.setNamedInputConnectionPoints([
      new connections_Js/* JsConnectionPoint */.fp(connections_Js/* JsConnectionPointType.OBJECT_3D */.zF.OBJECT_3D, connections_Js/* JsConnectionPointType.OBJECT_3D */.zF.OBJECT_3D, GetPhysicsRBDProperty_CONNECTION_OPTIONS)
    ]);
    this.io.outputs.setNamedOutputConnectionPoints([
      new connections_Js/* JsConnectionPoint */.fp(PhysicsRBD/* RBDProperty.ANGULAR_VELOCITY */.mj.ANGULAR_VELOCITY, connections_Js/* JsConnectionPointType.VECTOR3 */.zF.VECTOR3),
      new connections_Js/* JsConnectionPoint */.fp(PhysicsRBD/* RBDProperty.LINEAR_VELOCITY */.mj.LINEAR_VELOCITY, connections_Js/* JsConnectionPointType.VECTOR3 */.zF.VECTOR3),
      new connections_Js/* JsConnectionPoint */.fp(PhysicsRBD/* RBDProperty.ANGULAR_DAMPING */.mj.ANGULAR_DAMPING, connections_Js/* JsConnectionPointType.FLOAT */.zF.FLOAT),
      new connections_Js/* JsConnectionPoint */.fp(PhysicsRBD/* RBDProperty.LINEAR_DAMPING */.mj.LINEAR_DAMPING, connections_Js/* JsConnectionPointType.FLOAT */.zF.FLOAT),
      new connections_Js/* JsConnectionPoint */.fp(PhysicsRBD/* RBDProperty.IS_MOVING */.mj.IS_MOVING, connections_Js/* JsConnectionPointType.BOOLEAN */.zF.BOOLEAN),
      new connections_Js/* JsConnectionPoint */.fp(PhysicsRBD/* RBDProperty.IS_SLEEPING */.mj.IS_SLEEPING, connections_Js/* JsConnectionPointType.BOOLEAN */.zF.BOOLEAN)
    ]);
  }
  setLines(shadersCollectionController) {
    const usedOutputNames = this.io.outputs.used_output_names();
    const object3D = (0,_BaseObject3D/* inputObject3D */.iv)(this, shadersCollectionController);
    const _v3 = (propertyName, functionName, type) => {
      if (!usedOutputNames.includes(propertyName)) {
        return;
      }
      const out = this.jsVarName(propertyName);
      const tmpVarName = shadersCollectionController.addVariable(this, new three_module.Vector3());
      const func = Poly/* Poly.namedFunctionsRegister.getFunction */.L.namedFunctionsRegister.getFunction(functionName, this, shadersCollectionController);
      shadersCollectionController.addBodyOrComputed(this, [
        {
          dataType: type,
          varName: out,
          value: func.asString(object3D, tmpVarName)
        }
      ]);
    };
    const _p = (propertyName, functionName, type) => {
      if (!usedOutputNames.includes(propertyName)) {
        return;
      }
      const func = Poly/* Poly.namedFunctionsRegister.getFunction */.L.namedFunctionsRegister.getFunction(functionName, this, shadersCollectionController);
      shadersCollectionController.addBodyOrComputed(this, [
        {
          dataType: type,
          varName: this.jsVarName(propertyName),
          value: func.asString(object3D)
        }
      ]);
    };
    _v3(PhysicsRBD/* RBDProperty.ANGULAR_VELOCITY */.mj.ANGULAR_VELOCITY, "getPhysicsRBDAngularVelocity", connections_Js/* JsConnectionPointType.VECTOR3 */.zF.VECTOR3);
    _v3(PhysicsRBD/* RBDProperty.LINEAR_VELOCITY */.mj.LINEAR_VELOCITY, "getPhysicsRBDLinearVelocity", connections_Js/* JsConnectionPointType.VECTOR3 */.zF.VECTOR3);
    _p(PhysicsRBD/* RBDProperty.ANGULAR_DAMPING */.mj.ANGULAR_DAMPING, "getPhysicsRBDAngularDamping", connections_Js/* JsConnectionPointType.FLOAT */.zF.FLOAT);
    _p(PhysicsRBD/* RBDProperty.LINEAR_DAMPING */.mj.LINEAR_DAMPING, "getPhysicsRBDLinearDamping", connections_Js/* JsConnectionPointType.FLOAT */.zF.FLOAT);
    _p(PhysicsRBD/* RBDProperty.IS_MOVING */.mj.IS_MOVING, "getPhysicsRBDIsMoving", connections_Js/* JsConnectionPointType.BOOLEAN */.zF.BOOLEAN);
    _p(PhysicsRBD/* RBDProperty.IS_SLEEPING */.mj.IS_SLEEPING, "getPhysicsRBDIsSleeping", connections_Js/* JsConnectionPointType.BOOLEAN */.zF.BOOLEAN);
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/js/GetPlaneProperty.ts





const GetPlaneProperty_CONNECTION_OPTIONS = connections_Js/* JS_CONNECTION_POINT_IN_NODE_DEF */.mX;
var GetPlanePropertyJsNodeInputName = /* @__PURE__ */ ((GetPlanePropertyJsNodeInputName2) => {
  GetPlanePropertyJsNodeInputName2["normal"] = "normal";
  GetPlanePropertyJsNodeInputName2["constant"] = "constant";
  return GetPlanePropertyJsNodeInputName2;
})(GetPlanePropertyJsNodeInputName || {});
class GetPlanePropertyJsNode extends js_Base/* ParamlessTypedJsNode */.au {
  static type() {
    return "getPlaneProperty";
  }
  initializeNode() {
    this.io.inputs.setNamedInputConnectionPoints([
      new connections_Js/* JsConnectionPoint */.fp(connections_Js/* JsConnectionPointType.PLANE */.zF.PLANE, connections_Js/* JsConnectionPointType.PLANE */.zF.PLANE, GetPlaneProperty_CONNECTION_OPTIONS)
    ]);
    this.io.outputs.setNamedOutputConnectionPoints([
      new connections_Js/* JsConnectionPoint */.fp("normal" /* normal */, connections_Js/* JsConnectionPointType.VECTOR3 */.zF.VECTOR3),
      new connections_Js/* JsConnectionPoint */.fp("constant" /* constant */, connections_Js/* JsConnectionPointType.FLOAT */.zF.FLOAT)
    ]);
  }
  setLines(shadersCollectionController) {
    const usedOutputNames = this.io.outputs.used_output_names();
    const plane = this.variableForInput(shadersCollectionController, connections_Js/* JsConnectionPointType.PLANE */.zF.PLANE);
    const _v3 = (propertyName, functionName, type) => {
      if (!usedOutputNames.includes(propertyName)) {
        return;
      }
      const varName = this.jsVarName(propertyName);
      const tmpVarName = shadersCollectionController.addVariable(this, new three_module.Vector3());
      const func = Poly/* Poly.namedFunctionsRegister.getFunction */.L.namedFunctionsRegister.getFunction(functionName, this, shadersCollectionController);
      shadersCollectionController.addBodyOrComputed(this, [
        {
          dataType: type,
          varName,
          value: func.asString(plane, tmpVarName)
        }
      ]);
    };
    const _f = (propertyName, functionName, type) => {
      if (!usedOutputNames.includes(propertyName)) {
        return;
      }
      const func = Poly/* Poly.namedFunctionsRegister.getFunction */.L.namedFunctionsRegister.getFunction(functionName, this, shadersCollectionController);
      shadersCollectionController.addBodyOrComputed(this, [
        {
          dataType: type,
          varName: this.jsVarName(propertyName),
          value: func.asString(plane)
        }
      ]);
    };
    _v3("normal" /* normal */, "getPlaneNormal", connections_Js/* JsConnectionPointType.VECTOR3 */.zF.VECTOR3);
    _f("constant" /* constant */, "getPlaneConstant", connections_Js/* JsConnectionPointType.FLOAT */.zF.FLOAT);
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/js/GetPointProperty.ts








const GetPointProperty_CONNECTION_OPTIONS = connections_Js/* JS_CONNECTION_POINT_IN_NODE_DEF */.mX;
class GetPointPropertyJsNode extends js_Base/* ParamlessTypedJsNode */.au {
  static type() {
    return Js/* JsType.GET_POINT_PROPERTY */.K.GET_POINT_PROPERTY;
  }
  initializeNode() {
    this.io.inputs.setNamedInputConnectionPoints([
      new connections_Js/* JsConnectionPoint */.fp(connections_Js/* JsConnectionPointType.OBJECT_3D */.zF.OBJECT_3D, connections_Js/* JsConnectionPointType.OBJECT_3D */.zF.OBJECT_3D, GetPointProperty_CONNECTION_OPTIONS),
      new connections_Js/* JsConnectionPoint */.fp(GetPointPropertyJsNodeInputName.ptnum, connections_Js/* JsConnectionPointType.INT */.zF.INT, GetPointProperty_CONNECTION_OPTIONS)
    ]);
    this.io.outputs.setNamedOutputConnectionPoints([
      new connections_Js/* JsConnectionPoint */.fp(GetPointPropertyJsNodeInputName.ptnum, connections_Js/* JsConnectionPointType.INT */.zF.INT, GetPointProperty_CONNECTION_OPTIONS),
      new connections_Js/* JsConnectionPoint */.fp(GetPointPropertyJsNodeInputName.position, connections_Js/* JsConnectionPointType.VECTOR3 */.zF.VECTOR3)
    ]);
  }
  setLines(linesController) {
    const usedOutputNames = this.io.outputs.used_output_names();
    const object3D = (0,_BaseObject3D/* inputObject3D */.iv)(this, linesController);
    const ptnum = (0,_BaseObject3D/* inputPointIndex */.m7)(this, linesController);
    const _v3 = (propertyName, functionName) => {
      if (!usedOutputNames.includes(propertyName)) {
        return;
      }
      const func = Poly/* Poly.namedFunctionsRegister.getFunction */.L.namedFunctionsRegister.getFunction(functionName, this, linesController);
      const tmpVarName = linesController.addVariable(this, new three_module.Vector3());
      linesController.addBodyOrComputed(this, [
        {
          dataType: connections_Js/* JsConnectionPointType.VECTOR3 */.zF.VECTOR3,
          varName: this.jsVarName(propertyName),
          value: func.asString(object3D, ptnum, tmpVarName)
        }
      ]);
    };
    const _int = (propertyName, functionName) => {
      if (!usedOutputNames.includes(propertyName)) {
        return;
      }
      const func = Poly/* Poly.namedFunctionsRegister.getFunction */.L.namedFunctionsRegister.getFunction(functionName, this, linesController);
      linesController.addBodyOrComputed(this, [
        {
          dataType: connections_Js/* JsConnectionPointType.INT */.zF.INT,
          varName: this.jsVarName(propertyName),
          value: func.asString(object3D)
        }
      ]);
    };
    _int(GetPointPropertyJsNodeInputName.ptnum, "getPointIndex");
    _v3(GetPointPropertyJsNodeInputName.position, "getPointPosition");
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/js/GetPrimitiveAttribute.ts








var GetPrimitiveAttributeInputName = /* @__PURE__ */ ((GetPrimitiveAttributeInputName2) => {
  GetPrimitiveAttributeInputName2["attribName"] = "attribName";
  GetPrimitiveAttributeInputName2["primitiveIndex"] = "primitiveIndex";
  return GetPrimitiveAttributeInputName2;
})(GetPrimitiveAttributeInputName || {});
var GetPrimitiveAttributeOutputName = /* @__PURE__ */ ((GetPrimitiveAttributeOutputName2) => {
  GetPrimitiveAttributeOutputName2["VALUE"] = "val";
  return GetPrimitiveAttributeOutputName2;
})(GetPrimitiveAttributeOutputName || {});
class GetPrimitiveAttributeJsParamsConfig extends params_ParamsConfig/* NodeParamsConfig */.yI {
  constructor() {
    super(...arguments);
    // attribName = ParamConfig.STRING('');
    this.type = params_ParamsConfig/* ParamConfig.INTEGER */.XC.INTEGER(connections_Js/* PARAM_CONVERTIBLE_JS_CONNECTION_POINT_TYPES.indexOf */.mH.indexOf(connections_Js/* JsConnectionPointType.FLOAT */.zF.FLOAT), {
      menu: {
        entries: connections_Js/* PARAM_CONVERTIBLE_JS_CONNECTION_POINT_TYPES.map */.mH.map((name, value) => ({ name, value }))
      }
    });
  }
  // defaultBoolean = ParamConfig.BOOLEAN(0, typedVisibleOptions(JsConnectionPointType.BOOLEAN));
  // defaultColor = ParamConfig.COLOR([0, 0, 0], typedVisibleOptions(JsConnectionPointType.COLOR));
  // defaultFloat = ParamConfig.FLOAT(0, typedVisibleOptions(JsConnectionPointType.FLOAT));
  // defaultInteger = ParamConfig.INTEGER(0, typedVisibleOptions(JsConnectionPointType.INT));
  // defaultString = ParamConfig.STRING('', typedVisibleOptions(JsConnectionPointType.STRING));
  // defaultVector2 = ParamConfig.VECTOR2([0, 0], typedVisibleOptions(JsConnectionPointType.VECTOR2));
  // defaultVector3 = ParamConfig.VECTOR3([0, 0, 0], typedVisibleOptions(JsConnectionPointType.VECTOR3));
  // defaultVector4 = ParamConfig.VECTOR4([0, 0, 0, 0], typedVisibleOptions(JsConnectionPointType.VECTOR4));
}
const GetPrimitiveAttribute_ParamsConfig = new GetPrimitiveAttributeJsParamsConfig();
class GetPrimitiveAttributeJsNode extends js_Base/* TypedJsNode */.xZ {
  constructor() {
    super(...arguments);
    this.paramsConfig = GetPrimitiveAttribute_ParamsConfig;
    this._nextAttribName = "";
  }
  static type() {
    return Js/* JsType.GET_PRIMITIVE_ATTRIBUTE */.K.GET_PRIMITIVE_ATTRIBUTE;
  }
  initializeNode() {
    this.io.connection_points.set_expected_input_types_function(this._expectedInputTypes.bind(this));
    this.io.connection_points.set_input_name_function(this._expectedInputNames.bind(this));
    this.io.connection_points.set_expected_output_types_function(this._expectedOutputTypes.bind(this));
    this.io.connection_points.set_output_name_function(this._expectedOutputNames.bind(this));
  }
  _expectedInputTypes() {
    return [
      connections_Js/* JsConnectionPointType.OBJECT_3D */.zF.OBJECT_3D,
      connections_Js/* JsConnectionPointType.STRING */.zF.STRING,
      connections_Js/* JsConnectionPointType.INT */.zF.INT,
      this._currentConnectionType()
    ];
  }
  _expectedInputNames(index) {
    return [
      connections_Js/* JsConnectionPointType.OBJECT_3D */.zF.OBJECT_3D,
      "attribName" /* attribName */,
      "primitiveIndex" /* primitiveIndex */,
      this.defaultValueName()
    ][index];
  }
  _expectedOutputTypes() {
    return [this._currentConnectionType()];
  }
  _expectedOutputNames(index) {
    return ["val" /* VALUE */][index];
  }
  _currentConnectionType() {
    if (this.pv.type == null) {
      console.warn(`${this.type()} js node type not valid`);
    }
    const connection_type = connections_Js/* PARAM_CONVERTIBLE_JS_CONNECTION_POINT_TYPES */.mH[this.pv.type];
    if (connection_type == null) {
      console.warn(`${this.type()} js node type not valid`);
    }
    return connection_type;
  }
  // defaultValueParam() {
  // 	const type = PARAM_CONVERTIBLE_JS_CONNECTION_POINT_TYPES[this.pv.type] as ParamConvertibleJsType;
  // 	switch (type) {
  // 		case JsConnectionPointType.BOOLEAN: {
  // 			return this.p.defaultBoolean;
  // 		}
  // 		case JsConnectionPointType.COLOR: {
  // 			return this.p.defaultColor;
  // 		}
  // 		case JsConnectionPointType.FLOAT: {
  // 			return this.p.defaultFloat;
  // 		}
  // 		case JsConnectionPointType.INT: {
  // 			return this.p.defaultInteger;
  // 		}
  // 		case JsConnectionPointType.STRING: {
  // 			return this.p.defaultString;
  // 		}
  // 		case JsConnectionPointType.VECTOR2: {
  // 			return this.p.defaultVector2;
  // 		}
  // 		case JsConnectionPointType.VECTOR3: {
  // 			return this.p.defaultVector3;
  // 		}
  // 		case JsConnectionPointType.VECTOR4: {
  // 			return this.p.defaultVector4;
  // 		}
  // 	}
  // 	TypeAssert.unreachable(type);
  // }
  defaultValueName() {
    const type = connections_Js/* PARAM_CONVERTIBLE_JS_CONNECTION_POINT_TYPES */.mH[this.pv.type];
    switch (type) {
      case connections_Js/* JsConnectionPointType.BOOLEAN */.zF.BOOLEAN: {
        return "defaultBoolean";
      }
      case connections_Js/* JsConnectionPointType.COLOR */.zF.COLOR: {
        return "defaultColor";
      }
      case connections_Js/* JsConnectionPointType.FLOAT */.zF.FLOAT: {
        return "defaultFloat";
      }
      case connections_Js/* JsConnectionPointType.INT */.zF.INT: {
        return "defaultInteger";
      }
      case connections_Js/* JsConnectionPointType.STRING */.zF.STRING: {
        return "defaultString";
      }
      case connections_Js/* JsConnectionPointType.VECTOR2 */.zF.VECTOR2: {
        return "defaultVector2";
      }
      case connections_Js/* JsConnectionPointType.VECTOR3 */.zF.VECTOR3: {
        return "defaultVector3";
      }
      case connections_Js/* JsConnectionPointType.VECTOR4 */.zF.VECTOR4: {
        return "defaultVector4";
      }
    }
    Assert/* TypeAssert.unreachable */.f.unreachable(type);
  }
  paramDefaultValue(name) {
    return {
      ["attribName" /* attribName */]: this._nextAttribName,
      ["primitiveIndex" /* primitiveIndex */]: 0
    }[name];
  }
  setAttribType(type) {
    this.p.type.set(connections_Js/* PARAM_CONVERTIBLE_JS_CONNECTION_POINT_TYPES.indexOf */.mH.indexOf(type));
  }
  setAttribName(attribName) {
    const param = this.params.get("attribName" /* attribName */);
    if (param) {
      param.set(attribName);
    } else {
      this._nextAttribName = attribName;
    }
  }
  attributeName() {
    return this.params.get("attribName" /* attribName */).value;
  }
  setLines(linesController) {
    const object3D = (0,_BaseObject3D/* inputObject3D */.iv)(this, linesController);
    const attribName = this.variableForInput(linesController, "attribName" /* attribName */);
    const primitiveIndex = this.variableForInput(linesController, "primitiveIndex" /* primitiveIndex */);
    const defaultValue = this.variableForInput(linesController, this.defaultValueName());
    const out = this.jsVarName("val" /* VALUE */);
    const dataType = connections_Js/* PARAM_CONVERTIBLE_JS_CONNECTION_POINT_TYPES */.mH[this.pv.type];
    const func = Poly/* Poly.namedFunctionsRegister.getFunction */.L.namedFunctionsRegister.getFunction("getPrimitiveAttribute", this, linesController);
    const bodyLine = func.asString(object3D, primitiveIndex, attribName, `'${dataType}'`, defaultValue);
    linesController.addBodyOrComputed(this, [{ dataType, varName: out, value: bodyLine }]);
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/js/GetRayProperty.ts





const GetRayProperty_CONNECTION_OPTIONS = connections_Js/* JS_CONNECTION_POINT_IN_NODE_DEF */.mX;
var GetRayPropertyJsNodeInputName = /* @__PURE__ */ ((GetRayPropertyJsNodeInputName2) => {
  GetRayPropertyJsNodeInputName2["origin"] = "origin";
  GetRayPropertyJsNodeInputName2["direction"] = "direction";
  return GetRayPropertyJsNodeInputName2;
})(GetRayPropertyJsNodeInputName || {});
class GetRayPropertyJsNode extends js_Base/* ParamlessTypedJsNode */.au {
  static type() {
    return "getRayProperty";
  }
  initializeNode() {
    this.io.inputs.setNamedInputConnectionPoints([
      new connections_Js/* JsConnectionPoint */.fp(connections_Js/* JsConnectionPointType.RAY */.zF.RAY, connections_Js/* JsConnectionPointType.RAY */.zF.RAY, GetRayProperty_CONNECTION_OPTIONS)
    ]);
    this.io.outputs.setNamedOutputConnectionPoints([
      new connections_Js/* JsConnectionPoint */.fp("origin" /* origin */, connections_Js/* JsConnectionPointType.VECTOR3 */.zF.VECTOR3),
      new connections_Js/* JsConnectionPoint */.fp("direction" /* direction */, connections_Js/* JsConnectionPointType.VECTOR3 */.zF.VECTOR3)
    ]);
  }
  setLines(shadersCollectionController) {
    const usedOutputNames = this.io.outputs.used_output_names();
    const ray = this.variableForInput(shadersCollectionController, connections_Js/* JsConnectionPointType.RAY */.zF.RAY);
    const _v3 = (propertyName, functionName, type) => {
      if (!usedOutputNames.includes(propertyName)) {
        return;
      }
      const varName = this.jsVarName(propertyName);
      const tmpVarName = shadersCollectionController.addVariable(this, new three_module.Vector3());
      const func = Poly/* Poly.namedFunctionsRegister.getFunction */.L.namedFunctionsRegister.getFunction(functionName, this, shadersCollectionController);
      shadersCollectionController.addBodyOrComputed(this, [
        {
          dataType: type,
          varName,
          value: func.asString(ray, tmpVarName)
        }
      ]);
    };
    _v3("origin" /* origin */, "getRayOrigin", connections_Js/* JsConnectionPointType.VECTOR3 */.zF.VECTOR3);
    _v3("direction" /* direction */, "getRayDirection", connections_Js/* JsConnectionPointType.VECTOR3 */.zF.VECTOR3);
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/js/GetSibbling.ts






const GetSibbling_CONNECTION_OPTIONS = connections_Js/* JS_CONNECTION_POINT_IN_NODE_DEF */.mX;
class GetSibblingJsParamsConfig extends params_ParamsConfig/* NodeParamsConfig */.yI {
  constructor() {
    super(...arguments);
    this.offset = params_ParamsConfig/* ParamConfig.INTEGER */.XC.INTEGER(1, {
      range: [-10, 10],
      rangeLocked: [false, false]
    });
  }
}
const GetSibbling_ParamsConfig = new GetSibblingJsParamsConfig();
class GetSibblingJsNode extends js_Base/* TypedJsNode */.xZ {
  constructor() {
    super(...arguments);
    this.paramsConfig = GetSibbling_ParamsConfig;
  }
  static type() {
    return "getSibbling";
  }
  initializeNode() {
    this.io.inputs.setNamedInputConnectionPoints([
      new connections_Js/* JsConnectionPoint */.fp(connections_Js/* JsConnectionPointType.OBJECT_3D */.zF.OBJECT_3D, connections_Js/* JsConnectionPointType.OBJECT_3D */.zF.OBJECT_3D, GetSibbling_CONNECTION_OPTIONS)
    ]);
    this.io.outputs.setNamedOutputConnectionPoints([
      new connections_Js/* JsConnectionPoint */.fp(connections_Js/* JsConnectionPointType.OBJECT_3D */.zF.OBJECT_3D, connections_Js/* JsConnectionPointType.OBJECT_3D */.zF.OBJECT_3D)
    ]);
  }
  setLines(shadersCollectionController) {
    const object3D = (0,_BaseObject3D/* inputObject3D */.iv)(this, shadersCollectionController);
    const offset = this.variableForInputParam(shadersCollectionController, this.p.offset);
    const out = this.jsVarName(connections_Js/* JsConnectionPointType.OBJECT_3D */.zF.OBJECT_3D);
    const func = Poly/* Poly.namedFunctionsRegister.getFunction */.L.namedFunctionsRegister.getFunction("getSibbling", this, shadersCollectionController);
    const bodyLine = func.asString(object3D, offset);
    shadersCollectionController.addBodyOrComputed(this, [
      { dataType: connections_Js/* JsConnectionPointType.PLANE */.zF.PLANE, varName: out, value: bodyLine }
    ]);
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/js/GetSphereProperty.ts





const GetSphereProperty_CONNECTION_OPTIONS = connections_Js/* JS_CONNECTION_POINT_IN_NODE_DEF */.mX;
var GetSpherePropertyJsNodeInputName = /* @__PURE__ */ ((GetSpherePropertyJsNodeInputName2) => {
  GetSpherePropertyJsNodeInputName2["center"] = "center";
  GetSpherePropertyJsNodeInputName2["radius"] = "radius";
  return GetSpherePropertyJsNodeInputName2;
})(GetSpherePropertyJsNodeInputName || {});
class GetSpherePropertyJsNode extends js_Base/* ParamlessTypedJsNode */.au {
  static type() {
    return "getSphereProperty";
  }
  initializeNode() {
    this.io.inputs.setNamedInputConnectionPoints([
      new connections_Js/* JsConnectionPoint */.fp(connections_Js/* JsConnectionPointType.SPHERE */.zF.SPHERE, connections_Js/* JsConnectionPointType.SPHERE */.zF.SPHERE, GetSphereProperty_CONNECTION_OPTIONS)
    ]);
    this.io.outputs.setNamedOutputConnectionPoints([
      new connections_Js/* JsConnectionPoint */.fp("center" /* center */, connections_Js/* JsConnectionPointType.VECTOR3 */.zF.VECTOR3),
      new connections_Js/* JsConnectionPoint */.fp("radius" /* radius */, connections_Js/* JsConnectionPointType.FLOAT */.zF.FLOAT)
    ]);
  }
  setLines(shadersCollectionController) {
    const usedOutputNames = this.io.outputs.used_output_names();
    const sphere = this.variableForInput(shadersCollectionController, connections_Js/* JsConnectionPointType.SPHERE */.zF.SPHERE);
    const _v3 = (propertyName, functionName, type) => {
      if (!usedOutputNames.includes(propertyName)) {
        return;
      }
      const varName = this.jsVarName(propertyName);
      const tmpVarName = shadersCollectionController.addVariable(this, new three_module.Vector3());
      const func = Poly/* Poly.namedFunctionsRegister.getFunction */.L.namedFunctionsRegister.getFunction(functionName, this, shadersCollectionController);
      shadersCollectionController.addBodyOrComputed(this, [
        {
          dataType: type,
          varName,
          value: func.asString(sphere, tmpVarName)
        }
      ]);
    };
    const _f = (propertyName, functionName, type) => {
      if (!usedOutputNames.includes(propertyName)) {
        return;
      }
      const func = Poly/* Poly.namedFunctionsRegister.getFunction */.L.namedFunctionsRegister.getFunction(functionName, this, shadersCollectionController);
      shadersCollectionController.addBodyOrComputed(this, [
        {
          dataType: type,
          varName: this.jsVarName(propertyName),
          value: func.asString(sphere)
        }
      ]);
    };
    _v3("center" /* center */, "getSphereCenter", connections_Js/* JsConnectionPointType.VECTOR3 */.zF.VECTOR3);
    _f("radius" /* radius */, "getSphereRadius", connections_Js/* JsConnectionPointType.FLOAT */.zF.FLOAT);
  }
}

// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/nodes/js/GetTexture.ts
var GetTexture = __webpack_require__(99860);
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/js/GetTrackedHandProperty.ts





const GetTrackedHandProperty_CONNECTION_OPTIONS = connections_Js/* JS_CONNECTION_POINT_IN_NODE_DEF */.mX;
var GetTrackedHandPropertyJsNodeInputName = /* @__PURE__ */ ((GetTrackedHandPropertyJsNodeInputName2) => {
  GetTrackedHandPropertyJsNodeInputName2["thumbDirection"] = "thumbDirection";
  GetTrackedHandPropertyJsNodeInputName2["indexDirection"] = "indexDirection";
  GetTrackedHandPropertyJsNodeInputName2["middleDirection"] = "middleDirection";
  GetTrackedHandPropertyJsNodeInputName2["ringDirection"] = "ringDirection";
  GetTrackedHandPropertyJsNodeInputName2["pinkyDirection"] = "pinkyDirection";
  return GetTrackedHandPropertyJsNodeInputName2;
})(GetTrackedHandPropertyJsNodeInputName || {});
const DIRECTION_PROPERTIES = [
  "thumbDirection" /* thumbDirection */,
  "indexDirection" /* indexDirection */,
  "middleDirection" /* middleDirection */,
  "ringDirection" /* ringDirection */,
  "pinkyDirection" /* pinkyDirection */
];
class GetTrackedHandPropertyJsNode extends js_Base/* ParamlessTypedJsNode */.au {
  static type() {
    return "getTrackedHandProperty";
  }
  initializeNode() {
    this.io.inputs.setNamedInputConnectionPoints([
      new connections_Js/* JsConnectionPoint */.fp(
        connections_Js/* JsConnectionPointType.VECTOR4_ARRAY */.zF.VECTOR4_ARRAY,
        connections_Js/* JsConnectionPointType.VECTOR4_ARRAY */.zF.VECTOR4_ARRAY,
        GetTrackedHandProperty_CONNECTION_OPTIONS
      )
    ]);
    this.io.outputs.setNamedOutputConnectionPoints([
      ...DIRECTION_PROPERTIES.map((prop) => new connections_Js/* JsConnectionPoint */.fp(prop, connections_Js/* JsConnectionPointType.VECTOR3 */.zF.VECTOR3))
    ]);
  }
  setLines(shadersCollectionController) {
    const usedOutputNames = this.io.outputs.used_output_names();
    const values = this.variableForInput(shadersCollectionController, connections_Js/* JsConnectionPointType.VECTOR4_ARRAY */.zF.VECTOR4_ARRAY);
    const _v3 = (propertyName, functionName, type) => {
      if (!usedOutputNames.includes(propertyName)) {
        return;
      }
      const varName = this.jsVarName(propertyName);
      const tmpVarName = shadersCollectionController.addVariable(this, new three_module.Vector3());
      const func = Poly/* Poly.namedFunctionsRegister.getFunction */.L.namedFunctionsRegister.getFunction(functionName, this, shadersCollectionController);
      shadersCollectionController.addBodyOrComputed(this, [
        {
          dataType: type,
          varName,
          value: func.asString(values, tmpVarName)
        }
      ]);
    };
    _v3(
      "thumbDirection" /* thumbDirection */,
      "getTrackedHandThumbDirection",
      connections_Js/* JsConnectionPointType.VECTOR3 */.zF.VECTOR3
    );
    _v3(
      "indexDirection" /* indexDirection */,
      "getTrackedHandIndexDirection",
      connections_Js/* JsConnectionPointType.VECTOR3 */.zF.VECTOR3
    );
    _v3(
      "middleDirection" /* middleDirection */,
      "getTrackedHandIndexDirection",
      connections_Js/* JsConnectionPointType.VECTOR3 */.zF.VECTOR3
    );
    _v3(
      "ringDirection" /* ringDirection */,
      "getTrackedHandRingDirection",
      connections_Js/* JsConnectionPointType.VECTOR3 */.zF.VECTOR3
    );
    _v3(
      "pinkyDirection" /* pinkyDirection */,
      "getTrackedHandPinkyDirection",
      connections_Js/* JsConnectionPointType.VECTOR3 */.zF.VECTOR3
    );
  }
}

// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/nodes/js/GetVideoProperty.ts
var GetVideoProperty = __webpack_require__(84283);
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/js/GetWebXRARSessionProperty.ts






var GetARSessionPropertyJsNodeOutputName = /* @__PURE__ */ ((GetARSessionPropertyJsNodeOutputName2) => {
  GetARSessionPropertyJsNodeOutputName2["hitDetected"] = "hitDetected";
  GetARSessionPropertyJsNodeOutputName2["hitMatrix"] = "hitMatrix";
  GetARSessionPropertyJsNodeOutputName2["hitPosition"] = "hitPosition";
  GetARSessionPropertyJsNodeOutputName2["hitQuaternion"] = "hitQuaternion";
  return GetARSessionPropertyJsNodeOutputName2;
})(GetARSessionPropertyJsNodeOutputName || {});
class GetWebXRARSessionPropertyJsParamsConfig extends params_ParamsConfig/* NodeParamsConfig */.yI {
}
const GetWebXRARSessionProperty_ParamsConfig = new GetWebXRARSessionPropertyJsParamsConfig();
class GetWebXRARSessionPropertyJsNode extends js_Base/* TypedJsNode */.xZ {
  constructor() {
    super(...arguments);
    this.paramsConfig = GetWebXRARSessionProperty_ParamsConfig;
  }
  static type() {
    return "getWebXRARSessionProperty";
  }
  initializeNode() {
    this.io.inputs.setNamedInputConnectionPoints([]);
    this.io.outputs.setNamedOutputConnectionPoints([
      new connections_Js/* JsConnectionPoint */.fp("hitDetected" /* hitDetected */, connections_Js/* JsConnectionPointType.BOOLEAN */.zF.BOOLEAN),
      new connections_Js/* JsConnectionPoint */.fp("hitMatrix" /* hitMatrix */, connections_Js/* JsConnectionPointType.MATRIX4 */.zF.MATRIX4),
      new connections_Js/* JsConnectionPoint */.fp("hitPosition" /* hitPosition */, connections_Js/* JsConnectionPointType.VECTOR3 */.zF.VECTOR3),
      new connections_Js/* JsConnectionPoint */.fp("hitQuaternion" /* hitQuaternion */, connections_Js/* JsConnectionPointType.QUATERNION */.zF.QUATERNION)
    ]);
  }
  setLines(shadersCollectionController) {
    const usedOutputNames = this.io.outputs.used_output_names();
    const _b = (propertyName, functionName, type) => {
      if (!usedOutputNames.includes(propertyName)) {
        return;
      }
      const varName = this.jsVarName(propertyName);
      const func = Poly/* Poly.namedFunctionsRegister.getFunction */.L.namedFunctionsRegister.getFunction(functionName, this, shadersCollectionController);
      shadersCollectionController.addBodyOrComputed(this, [
        {
          dataType: type,
          varName,
          value: func.asString()
        }
      ]);
    };
    const _v3 = (propertyName, functionName, type) => {
      if (!usedOutputNames.includes(propertyName)) {
        return;
      }
      const varName = this.jsVarName(propertyName);
      const tmpVarName = shadersCollectionController.addVariable(this, new three_module.Vector3());
      const func = Poly/* Poly.namedFunctionsRegister.getFunction */.L.namedFunctionsRegister.getFunction(functionName, this, shadersCollectionController);
      shadersCollectionController.addBodyOrComputed(this, [
        {
          dataType: type,
          varName,
          value: func.asString(tmpVarName)
        }
      ]);
    };
    const _m4 = (propertyName, functionName, type) => {
      if (!usedOutputNames.includes(propertyName)) {
        return;
      }
      const varName = this.jsVarName(propertyName);
      const tmpVarName = shadersCollectionController.addVariable(this, new three_module.Matrix4());
      const func = Poly/* Poly.namedFunctionsRegister.getFunction */.L.namedFunctionsRegister.getFunction(functionName, this, shadersCollectionController);
      shadersCollectionController.addBodyOrComputed(this, [
        {
          dataType: type,
          varName,
          value: func.asString(tmpVarName)
        }
      ]);
    };
    const _q = (propertyName, functionName, type) => {
      if (!usedOutputNames.includes(propertyName)) {
        return;
      }
      const varName = this.jsVarName(propertyName);
      const tmpVarName = shadersCollectionController.addVariable(this, new three_module.Quaternion());
      const func = Poly/* Poly.namedFunctionsRegister.getFunction */.L.namedFunctionsRegister.getFunction(functionName, this, shadersCollectionController);
      shadersCollectionController.addBodyOrComputed(this, [
        {
          dataType: type,
          varName,
          value: func.asString(tmpVarName)
        }
      ]);
    };
    _b("hitDetected" /* hitDetected */, "getWebXRARHitDetected", connections_Js/* JsConnectionPointType.BOOLEAN */.zF.BOOLEAN);
    _m4("hitMatrix" /* hitMatrix */, "getWebXRARHitMatrix", connections_Js/* JsConnectionPointType.MATRIX4 */.zF.MATRIX4);
    _v3("hitPosition" /* hitPosition */, "getWebXRARHitPosition", connections_Js/* JsConnectionPointType.VECTOR3 */.zF.VECTOR3);
    _q(
      "hitQuaternion" /* hitQuaternion */,
      "getWebXRARHitQuaternion",
      connections_Js/* JsConnectionPointType.QUATERNION */.zF.QUATERNION
    );
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/js/GetWebXRControllerProperty.ts







var GetWebXRControllerPropertyJsNodeInputName = /* @__PURE__ */ ((GetWebXRControllerPropertyJsNodeInputName2) => {
  GetWebXRControllerPropertyJsNodeInputName2["Object3D"] = "Object3D";
  GetWebXRControllerPropertyJsNodeInputName2["Ray"] = "Ray";
  GetWebXRControllerPropertyJsNodeInputName2["hasLinearVelocity"] = "hasLinearVelocity";
  GetWebXRControllerPropertyJsNodeInputName2["linearVelocity"] = "linearVelocity";
  GetWebXRControllerPropertyJsNodeInputName2["hasAngularVelocity"] = "hasAngularVelocity";
  GetWebXRControllerPropertyJsNodeInputName2["angularVelocity"] = "angularVelocity";
  return GetWebXRControllerPropertyJsNodeInputName2;
})(GetWebXRControllerPropertyJsNodeInputName || {});
class GetWebXRControllerPropertyJsParamsConfig extends params_ParamsConfig/* NodeParamsConfig */.yI {
  constructor() {
    super(...arguments);
    /** @param  controller index */
    this.controllerIndex = params_ParamsConfig/* ParamConfig.INTEGER */.XC.INTEGER(0, {
      range: [0, 1],
      rangeLocked: [true, true]
    });
  }
}
const GetWebXRControllerProperty_ParamsConfig = new GetWebXRControllerPropertyJsParamsConfig();
class GetWebXRControllerPropertyJsNode extends js_Base/* TypedJsNode */.xZ {
  constructor() {
    super(...arguments);
    this.paramsConfig = GetWebXRControllerProperty_ParamsConfig;
  }
  static type() {
    return "getWebXRControllerProperty";
  }
  initializeNode() {
    this.io.inputs.setNamedInputConnectionPoints([]);
    this.io.outputs.setNamedOutputConnectionPoints([
      new connections_Js/* JsConnectionPoint */.fp("Object3D" /* Object3D */, connections_Js/* JsConnectionPointType.OBJECT_3D */.zF.OBJECT_3D),
      new connections_Js/* JsConnectionPoint */.fp("Ray" /* Ray */, connections_Js/* JsConnectionPointType.RAY */.zF.RAY),
      new connections_Js/* JsConnectionPoint */.fp(
        "hasLinearVelocity" /* hasLinearVelocity */,
        connections_Js/* JsConnectionPointType.BOOLEAN */.zF.BOOLEAN
      ),
      new connections_Js/* JsConnectionPoint */.fp(
        "linearVelocity" /* linearVelocity */,
        connections_Js/* JsConnectionPointType.VECTOR3 */.zF.VECTOR3
      ),
      new connections_Js/* JsConnectionPoint */.fp(
        "hasAngularVelocity" /* hasAngularVelocity */,
        connections_Js/* JsConnectionPointType.BOOLEAN */.zF.BOOLEAN
      ),
      new connections_Js/* JsConnectionPoint */.fp(
        "angularVelocity" /* angularVelocity */,
        connections_Js/* JsConnectionPointType.VECTOR3 */.zF.VECTOR3
      )
    ]);
  }
  setLines(shadersCollectionController) {
    const usedOutputNames = this.io.outputs.used_output_names();
    const object3D = (0,_BaseObject3D/* inputObject3D */.iv)(this, shadersCollectionController);
    const controllerIndex = this.variableForInputParam(shadersCollectionController, this.p.controllerIndex);
    const _object = (propertyName, functionName, type) => {
      if (!usedOutputNames.includes(propertyName)) {
        return;
      }
      const varName = this.jsVarName(propertyName);
      const func = Poly/* Poly.namedFunctionsRegister.getFunction */.L.namedFunctionsRegister.getFunction(functionName, this, shadersCollectionController);
      shadersCollectionController.addBodyOrComputed(this, [
        {
          dataType: type,
          varName,
          value: func.asString(object3D, controllerIndex)
        }
      ]);
    };
    const _ray = (propertyName, functionName, type) => {
      if (!usedOutputNames.includes(propertyName)) {
        return;
      }
      const varName = this.jsVarName(propertyName);
      const tmpVarName = shadersCollectionController.addVariable(this, new three_module.Ray());
      const func = Poly/* Poly.namedFunctionsRegister.getFunction */.L.namedFunctionsRegister.getFunction(functionName, this, shadersCollectionController);
      shadersCollectionController.addBodyOrComputed(this, [
        {
          dataType: type,
          varName,
          value: func.asString(object3D, controllerIndex, tmpVarName)
        }
      ]);
    };
    const _b = (propertyName, functionName, type) => {
      if (!usedOutputNames.includes(propertyName)) {
        return;
      }
      const varName = this.jsVarName(propertyName);
      const func = Poly/* Poly.namedFunctionsRegister.getFunction */.L.namedFunctionsRegister.getFunction(functionName, this, shadersCollectionController);
      shadersCollectionController.addBodyOrComputed(this, [
        {
          dataType: type,
          varName,
          value: func.asString(object3D, controllerIndex)
        }
      ]);
    };
    const _v3 = (propertyName, functionName, type) => {
      if (!usedOutputNames.includes(propertyName)) {
        return;
      }
      const varName = this.jsVarName(propertyName);
      const tmpVarName = shadersCollectionController.addVariable(this, new three_module.Vector3());
      const func = Poly/* Poly.namedFunctionsRegister.getFunction */.L.namedFunctionsRegister.getFunction(functionName, this, shadersCollectionController);
      shadersCollectionController.addBodyOrComputed(this, [
        {
          dataType: type,
          varName,
          value: func.asString(object3D, controllerIndex, tmpVarName)
        }
      ]);
    };
    _object(
      "Object3D" /* Object3D */,
      "getWebXRControllerObject",
      connections_Js/* JsConnectionPointType.OBJECT_3D */.zF.OBJECT_3D
    );
    _ray("Ray" /* Ray */, "getWebXRControllerRay", connections_Js/* JsConnectionPointType.RAY */.zF.RAY);
    _b(
      "hasAngularVelocity" /* hasAngularVelocity */,
      "getWebXRControllerHasAngularVelocity",
      connections_Js/* JsConnectionPointType.BOOLEAN */.zF.BOOLEAN
    );
    _v3(
      "angularVelocity" /* angularVelocity */,
      "getWebXRControllerAngularVelocity",
      connections_Js/* JsConnectionPointType.VECTOR3 */.zF.VECTOR3
    );
    _b(
      "hasLinearVelocity" /* hasLinearVelocity */,
      "getWebXRControllerHasLinearVelocity",
      connections_Js/* JsConnectionPointType.BOOLEAN */.zF.BOOLEAN
    );
    _v3(
      "linearVelocity" /* linearVelocity */,
      "getWebXRControllerLinearVelocity",
      connections_Js/* JsConnectionPointType.VECTOR3 */.zF.VECTOR3
    );
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/js/GetWebXRTrackedMarkerProperty.ts






var GetWebXRTrackedMarkerJsNodeInputName = /* @__PURE__ */ ((GetWebXRTrackedMarkerJsNodeInputName2) => {
  GetWebXRTrackedMarkerJsNodeInputName2["matrix"] = "matrix";
  return GetWebXRTrackedMarkerJsNodeInputName2;
})(GetWebXRTrackedMarkerJsNodeInputName || {});
class GetWebXRTrackedMarkerJsParamsConfig extends params_ParamsConfig/* NodeParamsConfig */.yI {
}
const GetWebXRTrackedMarkerProperty_ParamsConfig = new GetWebXRTrackedMarkerJsParamsConfig();
class GetWebXRTrackedMarkerPropertyJsNode extends js_Base/* TypedJsNode */.xZ {
  constructor() {
    super(...arguments);
    this.paramsConfig = GetWebXRTrackedMarkerProperty_ParamsConfig;
  }
  static type() {
    return "getWebXRTrackedMarkerProperty";
  }
  initializeNode() {
    this.io.inputs.setNamedInputConnectionPoints([]);
    this.io.outputs.setNamedOutputConnectionPoints([
      new connections_Js/* JsConnectionPoint */.fp("matrix" /* matrix */, connections_Js/* JsConnectionPointType.MATRIX4 */.zF.MATRIX4)
    ]);
  }
  setLines(shadersCollectionController) {
    const usedOutputNames = this.io.outputs.used_output_names();
    const _m4 = (propertyName, functionName, type) => {
      if (!usedOutputNames.includes(propertyName)) {
        return;
      }
      const varName = this.jsVarName(propertyName);
      const tmpVarName = shadersCollectionController.addVariable(this, new three_module.Matrix4());
      const func = Poly/* Poly.namedFunctionsRegister.getFunction */.L.namedFunctionsRegister.getFunction(functionName, this, shadersCollectionController);
      shadersCollectionController.addBodyOrComputed(this, [
        {
          dataType: type,
          varName,
          value: func.asString(tmpVarName)
        }
      ]);
    };
    _m4("matrix" /* matrix */, "getWebXRTrackedMarkerMatrix", connections_Js/* JsConnectionPointType.MATRIX4 */.zF.MATRIX4);
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/js/Globals.ts




class GlobalsJsParamsConfig extends params_ParamsConfig/* NodeParamsConfig */.yI {
}
const Globals_ParamsConfig = new GlobalsJsParamsConfig();
class GlobalsJsNode extends js_Base/* TypedJsNode */.xZ {
  constructor() {
    super(...arguments);
    this.paramsConfig = Globals_ParamsConfig;
  }
  static type() {
    return Js/* JsType.GLOBALS */.K.GLOBALS;
  }
  initializeNode() {
    super.initializeNode();
    this.lifecycle.onAfterAdded(() => {
      var _a, _b;
      (_b = (_a = this.functionNode()) == null ? void 0 : _a.assemblerController()) == null ? void 0 : _b.add_globals_outputs(this);
    });
  }
  setLines(linesController) {
    var _a, _b;
    (_b = (_a = this.functionNode()) == null ? void 0 : _a.assemblerController()) == null ? void 0 : _b.assembler.setNodeLinesGlobals(this, linesController);
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/js/code/assemblers/objectBuilder/ObjectVariables.ts

var ObjectVariableLight = /* @__PURE__ */ ((ObjectVariableLight2) => {
  ObjectVariableLight2["INTENSITY"] = "intensity";
  ObjectVariableLight2["COLOR"] = "color";
  return ObjectVariableLight2;
})(ObjectVariableLight || {});
var ObjectVariableAreaLight = /* @__PURE__ */ ((ObjectVariableAreaLight2) => {
  ObjectVariableAreaLight2["WIDTH"] = "width";
  ObjectVariableAreaLight2["HEIGHT"] = "height";
  return ObjectVariableAreaLight2;
})(ObjectVariableAreaLight || {});
var ObjectVariableDirectionalLight = /* @__PURE__ */ ((ObjectVariableDirectionalLight2) => {
  ObjectVariableDirectionalLight2["DISTANCE"] = "distance";
  ObjectVariableDirectionalLight2["SHADOW_BIAS"] = "shadowBias";
  ObjectVariableDirectionalLight2["SHADOW_RADIUS"] = "shadowRadius";
  return ObjectVariableDirectionalLight2;
})(ObjectVariableDirectionalLight || {});
var ObjectVariableHemisphereLight = /* @__PURE__ */ ((ObjectVariableHemisphereLight2) => {
  ObjectVariableHemisphereLight2["SKY_COLOR"] = "skyColor";
  ObjectVariableHemisphereLight2["GROUND_COLOR"] = "groundColor";
  return ObjectVariableHemisphereLight2;
})(ObjectVariableHemisphereLight || {});
var ObjectVariablePointLight = /* @__PURE__ */ ((ObjectVariablePointLight2) => {
  ObjectVariablePointLight2["DECAY"] = "decay";
  ObjectVariablePointLight2["DISTANCE"] = "distance";
  ObjectVariablePointLight2["SHADOW_BIAS"] = "shadowBias";
  ObjectVariablePointLight2["SHADOW_NEAR"] = "shadowNear";
  ObjectVariablePointLight2["SHADOW_FAR"] = "shadowFar";
  return ObjectVariablePointLight2;
})(ObjectVariablePointLight || {});
var ObjectVariableSpotLight = /* @__PURE__ */ ((ObjectVariableSpotLight2) => {
  ObjectVariableSpotLight2["ANGLE"] = "angle";
  ObjectVariableSpotLight2["PENUMBRA"] = "penumbra";
  ObjectVariableSpotLight2["DECAY"] = "decay";
  ObjectVariableSpotLight2["DISTANCE"] = "distance";
  ObjectVariableSpotLight2["SHADOW_BIAS"] = "shadowBias";
  ObjectVariableSpotLight2["SHADOW_NEAR"] = "shadowNear";
  ObjectVariableSpotLight2["SHADOW_FAR"] = "shadowFar";
  ObjectVariableSpotLight2["SHADOW_RADIUS"] = "shadowRadius";
  return ObjectVariableSpotLight2;
})(ObjectVariableSpotLight || {});

// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/nodes/js/code/assemblers/objectBuilder/ObjectBuilderAssemblerCommon.ts
var ObjectBuilderAssemblerCommon = __webpack_require__(20924);
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/js/GlobalsAmbientLight.ts








class GlobalsAmbientLightJsParamsConfig extends params_ParamsConfig/* NodeParamsConfig */.yI {
}
const GlobalsAmbientLight_ParamsConfig = new GlobalsAmbientLightJsParamsConfig();
class GlobalsAmbientLightJsNode extends js_Base/* TypedJsNode */.xZ {
  constructor() {
    super(...arguments);
    this.paramsConfig = GlobalsAmbientLight_ParamsConfig;
  }
  static type() {
    return Js/* JsType.GLOBALS_AMBIENT_LIGHT */.K.GLOBALS_AMBIENT_LIGHT;
  }
  initializeNode() {
    super.initializeNode();
    this.io.outputs.setNamedOutputConnectionPoints([
      new connections_Js/* JsConnectionPoint */.fp(ObjectVariableLight.INTENSITY, connections_Js/* JsConnectionPointType.FLOAT */.zF.FLOAT),
      new connections_Js/* JsConnectionPoint */.fp(ObjectVariableLight.COLOR, connections_Js/* JsConnectionPointType.COLOR */.zF.COLOR)
    ]);
  }
  setLines(linesController) {
    const bodyLines = [];
    const usedOutputNames = this.io.outputs.used_output_names();
    for (const outputName of usedOutputNames) {
      const varName = this.jsVarName(outputName);
      switch (outputName) {
        case ObjectVariableLight.INTENSITY: {
          bodyLines.push(`if( ${ObjectBuilderAssemblerCommon/* ObjectBuilderAssemblerConstant.OBJECT_3D */.F.OBJECT_3D}.${outputName} != null ){
						${varName} = ${ObjectBuilderAssemblerCommon/* ObjectBuilderAssemblerConstant.OBJECT_3D */.F.OBJECT_3D}.${outputName}
					} else {
						${varName} = 0;
					}`);
          break;
        }
        case ObjectVariableLight.COLOR: {
          linesController.addVariable(this, new three_module.Color(), varName);
          bodyLines.push(`if( ${ObjectBuilderAssemblerCommon/* ObjectBuilderAssemblerConstant.OBJECT_3D */.F.OBJECT_3D}.${outputName} != null ) {
						${varName}.copy(${ObjectBuilderAssemblerCommon/* ObjectBuilderAssemblerConstant.OBJECT_3D */.F.OBJECT_3D}.${outputName})
					}`);
          break;
        }
      }
    }
    linesController._addBodyLines(this, bodyLines);
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/js/GlobalsAreaLight.ts








class GlobalsAreaLightJsParamsConfig extends params_ParamsConfig/* NodeParamsConfig */.yI {
}
const GlobalsAreaLight_ParamsConfig = new GlobalsAreaLightJsParamsConfig();
class GlobalsAreaLightJsNode extends js_Base/* TypedJsNode */.xZ {
  constructor() {
    super(...arguments);
    this.paramsConfig = GlobalsAreaLight_ParamsConfig;
  }
  static type() {
    return Js/* JsType.GLOBALS_AREA_LIGHT */.K.GLOBALS_AREA_LIGHT;
  }
  initializeNode() {
    super.initializeNode();
    this.io.outputs.setNamedOutputConnectionPoints([
      new connections_Js/* JsConnectionPoint */.fp(ObjectVariableLight.INTENSITY, connections_Js/* JsConnectionPointType.FLOAT */.zF.FLOAT),
      new connections_Js/* JsConnectionPoint */.fp(ObjectVariableLight.COLOR, connections_Js/* JsConnectionPointType.COLOR */.zF.COLOR),
      new connections_Js/* JsConnectionPoint */.fp(ObjectVariableAreaLight.WIDTH, connections_Js/* JsConnectionPointType.FLOAT */.zF.FLOAT),
      new connections_Js/* JsConnectionPoint */.fp(ObjectVariableAreaLight.HEIGHT, connections_Js/* JsConnectionPointType.FLOAT */.zF.FLOAT)
    ]);
  }
  setLines(linesController) {
    const bodyLines = [];
    const usedOutputNames = this.io.outputs.used_output_names();
    for (const outputName of usedOutputNames) {
      const varName = this.jsVarName(outputName);
      switch (outputName) {
        case ObjectVariableLight.INTENSITY:
        case ObjectVariableAreaLight.WIDTH:
        case ObjectVariableAreaLight.HEIGHT: {
          bodyLines.push(`if( ${ObjectBuilderAssemblerCommon/* ObjectBuilderAssemblerConstant.OBJECT_3D */.F.OBJECT_3D}.${outputName} != null ){
						${varName} = ${ObjectBuilderAssemblerCommon/* ObjectBuilderAssemblerConstant.OBJECT_3D */.F.OBJECT_3D}.${outputName}
					} else {
						${varName} = 0;
					}`);
          break;
        }
        case ObjectVariableLight.COLOR: {
          linesController.addVariable(this, new three_module.Color(), varName);
          bodyLines.push(`if( ${ObjectBuilderAssemblerCommon/* ObjectBuilderAssemblerConstant.OBJECT_3D */.F.OBJECT_3D}.${outputName} != null ){
						${varName}.copy(${ObjectBuilderAssemblerCommon/* ObjectBuilderAssemblerConstant.OBJECT_3D */.F.OBJECT_3D}.${outputName})
					}`);
          break;
        }
      }
    }
    linesController._addBodyLines(this, bodyLines);
  }
}

// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/core/lights/Common.ts
var Common = __webpack_require__(30654);
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/js/GlobalsDirectionalLight.ts









class GlobalsDirectionalLightJsParamsConfig extends params_ParamsConfig/* NodeParamsConfig */.yI {
}
const GlobalsDirectionalLight_ParamsConfig = new GlobalsDirectionalLightJsParamsConfig();
class GlobalsDirectionalLightJsNode extends js_Base/* TypedJsNode */.xZ {
  constructor() {
    super(...arguments);
    this.paramsConfig = GlobalsDirectionalLight_ParamsConfig;
  }
  static type() {
    return Js/* JsType.GLOBALS_DIRECTIONAL_LIGHT */.K.GLOBALS_DIRECTIONAL_LIGHT;
  }
  initializeNode() {
    super.initializeNode();
    this.io.outputs.setNamedOutputConnectionPoints([
      new connections_Js/* JsConnectionPoint */.fp(ObjectVariableLight.INTENSITY, connections_Js/* JsConnectionPointType.FLOAT */.zF.FLOAT),
      new connections_Js/* JsConnectionPoint */.fp(ObjectVariableLight.COLOR, connections_Js/* JsConnectionPointType.COLOR */.zF.COLOR),
      new connections_Js/* JsConnectionPoint */.fp(ObjectVariableDirectionalLight.DISTANCE, connections_Js/* JsConnectionPointType.FLOAT */.zF.FLOAT),
      new connections_Js/* JsConnectionPoint */.fp(ObjectVariableDirectionalLight.SHADOW_BIAS, connections_Js/* JsConnectionPointType.FLOAT */.zF.FLOAT),
      new connections_Js/* JsConnectionPoint */.fp(ObjectVariableDirectionalLight.SHADOW_RADIUS, connections_Js/* JsConnectionPointType.FLOAT */.zF.FLOAT),
      new connections_Js/* JsConnectionPoint */.fp(Common/* LightUserDataRaymarching.PENUMBRA */.W.PENUMBRA, connections_Js/* JsConnectionPointType.FLOAT */.zF.FLOAT),
      new connections_Js/* JsConnectionPoint */.fp(Common/* LightUserDataRaymarching.SHADOW_BIAS_ANGLE */.W.SHADOW_BIAS_ANGLE, connections_Js/* JsConnectionPointType.FLOAT */.zF.FLOAT),
      new connections_Js/* JsConnectionPoint */.fp(Common/* LightUserDataRaymarching.SHADOW_BIAS_DISTANCE */.W.SHADOW_BIAS_DISTANCE, connections_Js/* JsConnectionPointType.FLOAT */.zF.FLOAT)
    ]);
  }
  setLines(linesController) {
    const bodyLines = [];
    const usedOutputNames = this.io.outputs.used_output_names();
    for (const outputName of usedOutputNames) {
      const varName = this.jsVarName(outputName);
      switch (outputName) {
        case ObjectVariableLight.INTENSITY: {
          bodyLines.push(`if( ${ObjectBuilderAssemblerCommon/* ObjectBuilderAssemblerConstant.OBJECT_3D */.F.OBJECT_3D}.${outputName} != null ){
						${varName} = ${ObjectBuilderAssemblerCommon/* ObjectBuilderAssemblerConstant.OBJECT_3D */.F.OBJECT_3D}.${outputName}
					} else {
						${varName} = 0;
					}`);
          break;
        }
        case ObjectVariableDirectionalLight.DISTANCE: {
          bodyLines.push(`if( ${ObjectBuilderAssemblerCommon/* ObjectBuilderAssemblerConstant.OBJECT_3D */.F.OBJECT_3D}.shadow && ${ObjectBuilderAssemblerCommon/* ObjectBuilderAssemblerConstant.OBJECT_3D */.F.OBJECT_3D}.shadow.camera && ${ObjectBuilderAssemblerCommon/* ObjectBuilderAssemblerConstant.OBJECT_3D */.F.OBJECT_3D}.shadow.camera.far != null ){
						${varName} = ${ObjectBuilderAssemblerCommon/* ObjectBuilderAssemblerConstant.OBJECT_3D */.F.OBJECT_3D}.shadow.camera.far
					} else {
						${varName} = 0;
					}`);
          break;
        }
        case ObjectVariableDirectionalLight.SHADOW_BIAS:
        case ObjectVariableDirectionalLight.SHADOW_RADIUS: {
          const shadowParameter = outputName.replace("shadow", "").toLowerCase();
          bodyLines.push(`if(
						${ObjectBuilderAssemblerCommon/* ObjectBuilderAssemblerConstant.OBJECT_3D */.F.OBJECT_3D}.shadow != null &&
						${ObjectBuilderAssemblerCommon/* ObjectBuilderAssemblerConstant.OBJECT_3D */.F.OBJECT_3D}.shadow.${shadowParameter} != null )
						{
							${varName} = ${ObjectBuilderAssemblerCommon/* ObjectBuilderAssemblerConstant.OBJECT_3D */.F.OBJECT_3D}.shadow.${shadowParameter}
						} else {
							${varName} = 0;
						}`);
          break;
        }
        case ObjectVariableLight.COLOR: {
          linesController.addVariable(this, new three_module.Color(), varName);
          bodyLines.push(`if( ${ObjectBuilderAssemblerCommon/* ObjectBuilderAssemblerConstant.OBJECT_3D */.F.OBJECT_3D}.${outputName} != null ){
						${varName}.copy(${ObjectBuilderAssemblerCommon/* ObjectBuilderAssemblerConstant.OBJECT_3D */.F.OBJECT_3D}.${outputName})
					}`);
          break;
        }
        case Common/* LightUserDataRaymarching.PENUMBRA */.W.PENUMBRA:
        case Common/* LightUserDataRaymarching.SHADOW_BIAS_ANGLE */.W.SHADOW_BIAS_ANGLE:
        case Common/* LightUserDataRaymarching.SHADOW_BIAS_DISTANCE */.W.SHADOW_BIAS_DISTANCE: {
          bodyLines.push(`if( ${ObjectBuilderAssemblerCommon/* ObjectBuilderAssemblerConstant.OBJECT_3D */.F.OBJECT_3D}.userData['${outputName}'] != null ){
								${varName} = ${ObjectBuilderAssemblerCommon/* ObjectBuilderAssemblerConstant.OBJECT_3D */.F.OBJECT_3D}.userData['${outputName}']
							} else {
								${varName} = 0;
							}`);
        }
      }
    }
    linesController._addBodyLines(this, bodyLines);
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/js/GlobalsHemisphereLight.ts








class GlobalsHemisphereLightJsParamsConfig extends params_ParamsConfig/* NodeParamsConfig */.yI {
}
const GlobalsHemisphereLight_ParamsConfig = new GlobalsHemisphereLightJsParamsConfig();
class GlobalsHemisphereLightJsNode extends js_Base/* TypedJsNode */.xZ {
  constructor() {
    super(...arguments);
    this.paramsConfig = GlobalsHemisphereLight_ParamsConfig;
  }
  static type() {
    return Js/* JsType.GLOBALS_HEMISPHERE_LIGHT */.K.GLOBALS_HEMISPHERE_LIGHT;
  }
  initializeNode() {
    super.initializeNode();
    this.io.outputs.setNamedOutputConnectionPoints([
      new connections_Js/* JsConnectionPoint */.fp(ObjectVariableLight.INTENSITY, connections_Js/* JsConnectionPointType.FLOAT */.zF.FLOAT),
      new connections_Js/* JsConnectionPoint */.fp(ObjectVariableHemisphereLight.SKY_COLOR, connections_Js/* JsConnectionPointType.COLOR */.zF.COLOR),
      new connections_Js/* JsConnectionPoint */.fp(ObjectVariableHemisphereLight.GROUND_COLOR, connections_Js/* JsConnectionPointType.COLOR */.zF.COLOR)
    ]);
  }
  setLines(linesController) {
    const bodyLines = [];
    const usedOutputNames = this.io.outputs.used_output_names();
    for (const outputName of usedOutputNames) {
      const varName = this.jsVarName(outputName);
      switch (outputName) {
        case ObjectVariableLight.INTENSITY: {
          bodyLines.push(`if( ${ObjectBuilderAssemblerCommon/* ObjectBuilderAssemblerConstant.OBJECT_3D */.F.OBJECT_3D}.${outputName} != null ){
						${varName} = ${ObjectBuilderAssemblerCommon/* ObjectBuilderAssemblerConstant.OBJECT_3D */.F.OBJECT_3D}.${outputName}
					} else {
						${varName} = 0;
					}`);
          break;
        }
        case ObjectVariableHemisphereLight.SKY_COLOR:
        case ObjectVariableHemisphereLight.GROUND_COLOR: {
          const paramName = outputName == ObjectVariableHemisphereLight.SKY_COLOR ? "color" : "groundColor";
          linesController.addVariable(this, new three_module.Color(), varName);
          bodyLines.push(`if( ${ObjectBuilderAssemblerCommon/* ObjectBuilderAssemblerConstant.OBJECT_3D */.F.OBJECT_3D}.${paramName} != null ){
						${varName}.copy(${ObjectBuilderAssemblerCommon/* ObjectBuilderAssemblerConstant.OBJECT_3D */.F.OBJECT_3D}.${paramName})
					}`);
          break;
        }
      }
    }
    linesController._addBodyLines(this, bodyLines);
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/js/GlobalsPointLight.ts









class GlobalsPointLightJsParamsConfig extends params_ParamsConfig/* NodeParamsConfig */.yI {
}
const GlobalsPointLight_ParamsConfig = new GlobalsPointLightJsParamsConfig();
class GlobalsPointLightJsNode extends js_Base/* TypedJsNode */.xZ {
  constructor() {
    super(...arguments);
    this.paramsConfig = GlobalsPointLight_ParamsConfig;
  }
  static type() {
    return Js/* JsType.GLOBALS_POINT_LIGHT */.K.GLOBALS_POINT_LIGHT;
  }
  initializeNode() {
    super.initializeNode();
    this.io.outputs.setNamedOutputConnectionPoints([
      new connections_Js/* JsConnectionPoint */.fp(ObjectVariableLight.INTENSITY, connections_Js/* JsConnectionPointType.FLOAT */.zF.FLOAT),
      new connections_Js/* JsConnectionPoint */.fp(ObjectVariableLight.COLOR, connections_Js/* JsConnectionPointType.COLOR */.zF.COLOR),
      new connections_Js/* JsConnectionPoint */.fp(ObjectVariablePointLight.DECAY, connections_Js/* JsConnectionPointType.FLOAT */.zF.FLOAT),
      new connections_Js/* JsConnectionPoint */.fp(ObjectVariablePointLight.DISTANCE, connections_Js/* JsConnectionPointType.FLOAT */.zF.FLOAT),
      new connections_Js/* JsConnectionPoint */.fp(ObjectVariablePointLight.SHADOW_BIAS, connections_Js/* JsConnectionPointType.FLOAT */.zF.FLOAT),
      new connections_Js/* JsConnectionPoint */.fp(ObjectVariablePointLight.SHADOW_NEAR, connections_Js/* JsConnectionPointType.FLOAT */.zF.FLOAT),
      new connections_Js/* JsConnectionPoint */.fp(ObjectVariablePointLight.SHADOW_FAR, connections_Js/* JsConnectionPointType.FLOAT */.zF.FLOAT),
      new connections_Js/* JsConnectionPoint */.fp(Common/* LightUserDataRaymarching.PENUMBRA */.W.PENUMBRA, connections_Js/* JsConnectionPointType.FLOAT */.zF.FLOAT),
      new connections_Js/* JsConnectionPoint */.fp(Common/* LightUserDataRaymarching.SHADOW_BIAS_ANGLE */.W.SHADOW_BIAS_ANGLE, connections_Js/* JsConnectionPointType.FLOAT */.zF.FLOAT),
      new connections_Js/* JsConnectionPoint */.fp(Common/* LightUserDataRaymarching.SHADOW_BIAS_DISTANCE */.W.SHADOW_BIAS_DISTANCE, connections_Js/* JsConnectionPointType.FLOAT */.zF.FLOAT)
    ]);
  }
  setLines(linesController) {
    const bodyLines = [];
    const usedOutputNames = this.io.outputs.used_output_names();
    for (const outputName of usedOutputNames) {
      const varName = this.jsVarName(outputName);
      switch (outputName) {
        case ObjectVariableLight.INTENSITY:
        case ObjectVariablePointLight.DECAY:
        case ObjectVariablePointLight.DISTANCE: {
          bodyLines.push(`if( ${ObjectBuilderAssemblerCommon/* ObjectBuilderAssemblerConstant.OBJECT_3D */.F.OBJECT_3D}.${outputName} != null ){
						${varName} = ${ObjectBuilderAssemblerCommon/* ObjectBuilderAssemblerConstant.OBJECT_3D */.F.OBJECT_3D}.${outputName}
					} else {
						${varName} = 0;
					}`);
          break;
        }
        case ObjectVariablePointLight.SHADOW_BIAS:
        case ObjectVariablePointLight.SHADOW_NEAR:
        case ObjectVariablePointLight.SHADOW_FAR: {
          const shadowParameter = outputName.replace("shadow", "").toLowerCase();
          bodyLines.push(`if(
						${ObjectBuilderAssemblerCommon/* ObjectBuilderAssemblerConstant.OBJECT_3D */.F.OBJECT_3D}.shadow != null &&
						${ObjectBuilderAssemblerCommon/* ObjectBuilderAssemblerConstant.OBJECT_3D */.F.OBJECT_3D}.shadow.${shadowParameter} != null )
						{
							${varName} = ${ObjectBuilderAssemblerCommon/* ObjectBuilderAssemblerConstant.OBJECT_3D */.F.OBJECT_3D}.shadow.${shadowParameter}
						} else {
							${varName} = 0;
						}`);
          break;
        }
        case ObjectVariableLight.COLOR: {
          linesController.addVariable(this, new three_module.Color(), varName);
          bodyLines.push(`if( ${ObjectBuilderAssemblerCommon/* ObjectBuilderAssemblerConstant.OBJECT_3D */.F.OBJECT_3D}.${outputName} != null ){
						${varName}.copy(${ObjectBuilderAssemblerCommon/* ObjectBuilderAssemblerConstant.OBJECT_3D */.F.OBJECT_3D}.${outputName})
					}`);
          break;
        }
        case Common/* LightUserDataRaymarching.PENUMBRA */.W.PENUMBRA:
        case Common/* LightUserDataRaymarching.SHADOW_BIAS_ANGLE */.W.SHADOW_BIAS_ANGLE:
        case Common/* LightUserDataRaymarching.SHADOW_BIAS_DISTANCE */.W.SHADOW_BIAS_DISTANCE: {
          bodyLines.push(`if( ${ObjectBuilderAssemblerCommon/* ObjectBuilderAssemblerConstant.OBJECT_3D */.F.OBJECT_3D}.userData['${outputName}'] != null ){
								${varName} = ${ObjectBuilderAssemblerCommon/* ObjectBuilderAssemblerConstant.OBJECT_3D */.F.OBJECT_3D}.userData['${outputName}']
							} else {
								${varName} = 0;
							}`);
        }
      }
    }
    linesController._addBodyLines(this, bodyLines);
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/js/GlobalsSpotLight.ts









class GlobalsSpotLightJsParamsConfig extends params_ParamsConfig/* NodeParamsConfig */.yI {
}
const GlobalsSpotLight_ParamsConfig = new GlobalsSpotLightJsParamsConfig();
class GlobalsSpotLightJsNode extends js_Base/* TypedJsNode */.xZ {
  constructor() {
    super(...arguments);
    this.paramsConfig = GlobalsSpotLight_ParamsConfig;
  }
  static type() {
    return Js/* JsType.GLOBALS_SPOT_LIGHT */.K.GLOBALS_SPOT_LIGHT;
  }
  initializeNode() {
    super.initializeNode();
    this.io.outputs.setNamedOutputConnectionPoints([
      new connections_Js/* JsConnectionPoint */.fp(ObjectVariableLight.INTENSITY, connections_Js/* JsConnectionPointType.FLOAT */.zF.FLOAT),
      new connections_Js/* JsConnectionPoint */.fp(ObjectVariableLight.COLOR, connections_Js/* JsConnectionPointType.COLOR */.zF.COLOR),
      new connections_Js/* JsConnectionPoint */.fp(ObjectVariableSpotLight.ANGLE, connections_Js/* JsConnectionPointType.FLOAT */.zF.FLOAT),
      new connections_Js/* JsConnectionPoint */.fp(ObjectVariableSpotLight.PENUMBRA, connections_Js/* JsConnectionPointType.FLOAT */.zF.FLOAT),
      new connections_Js/* JsConnectionPoint */.fp(ObjectVariableSpotLight.DECAY, connections_Js/* JsConnectionPointType.FLOAT */.zF.FLOAT),
      new connections_Js/* JsConnectionPoint */.fp(ObjectVariableSpotLight.DISTANCE, connections_Js/* JsConnectionPointType.FLOAT */.zF.FLOAT),
      new connections_Js/* JsConnectionPoint */.fp(ObjectVariableSpotLight.SHADOW_BIAS, connections_Js/* JsConnectionPointType.FLOAT */.zF.FLOAT),
      new connections_Js/* JsConnectionPoint */.fp(ObjectVariableSpotLight.SHADOW_NEAR, connections_Js/* JsConnectionPointType.FLOAT */.zF.FLOAT),
      new connections_Js/* JsConnectionPoint */.fp(ObjectVariableSpotLight.SHADOW_FAR, connections_Js/* JsConnectionPointType.FLOAT */.zF.FLOAT),
      new connections_Js/* JsConnectionPoint */.fp(ObjectVariableSpotLight.SHADOW_RADIUS, connections_Js/* JsConnectionPointType.FLOAT */.zF.FLOAT),
      new connections_Js/* JsConnectionPoint */.fp(Common/* LightUserDataRaymarching.PENUMBRA */.W.PENUMBRA, connections_Js/* JsConnectionPointType.FLOAT */.zF.FLOAT),
      new connections_Js/* JsConnectionPoint */.fp(Common/* LightUserDataRaymarching.SHADOW_BIAS_ANGLE */.W.SHADOW_BIAS_ANGLE, connections_Js/* JsConnectionPointType.FLOAT */.zF.FLOAT),
      new connections_Js/* JsConnectionPoint */.fp(Common/* LightUserDataRaymarching.SHADOW_BIAS_DISTANCE */.W.SHADOW_BIAS_DISTANCE, connections_Js/* JsConnectionPointType.FLOAT */.zF.FLOAT)
    ]);
  }
  setLines(linesController) {
    const bodyLines = [];
    const usedOutputNames = this.io.outputs.used_output_names();
    for (const outputName of usedOutputNames) {
      const varName = this.jsVarName(outputName);
      switch (outputName) {
        case ObjectVariableLight.INTENSITY:
        case ObjectVariableSpotLight.ANGLE:
        case ObjectVariableSpotLight.PENUMBRA:
        case ObjectVariableSpotLight.DECAY:
        case ObjectVariableSpotLight.DISTANCE: {
          bodyLines.push(`if( ${ObjectBuilderAssemblerCommon/* ObjectBuilderAssemblerConstant.OBJECT_3D */.F.OBJECT_3D}.${outputName} != null ){
						${varName} = ${ObjectBuilderAssemblerCommon/* ObjectBuilderAssemblerConstant.OBJECT_3D */.F.OBJECT_3D}.${outputName}
					} else {
						${varName} = 0;
					}`);
          break;
        }
        case ObjectVariableSpotLight.SHADOW_BIAS:
        case ObjectVariableSpotLight.SHADOW_NEAR:
        case ObjectVariableSpotLight.SHADOW_FAR:
        case ObjectVariableSpotLight.SHADOW_RADIUS: {
          const shadowParameter = outputName.replace("shadow", "").toLowerCase();
          bodyLines.push(`if(
						${ObjectBuilderAssemblerCommon/* ObjectBuilderAssemblerConstant.OBJECT_3D */.F.OBJECT_3D}.shadow != null &&
						${ObjectBuilderAssemblerCommon/* ObjectBuilderAssemblerConstant.OBJECT_3D */.F.OBJECT_3D}.shadow.${shadowParameter} != null )
						{
							${varName} = ${ObjectBuilderAssemblerCommon/* ObjectBuilderAssemblerConstant.OBJECT_3D */.F.OBJECT_3D}.shadow.${shadowParameter}
						} else {
							${varName} = 0;
						}`);
          break;
        }
        case ObjectVariableLight.COLOR: {
          linesController.addVariable(this, new three_module.Color(), varName);
          bodyLines.push(`if( ${ObjectBuilderAssemblerCommon/* ObjectBuilderAssemblerConstant.OBJECT_3D */.F.OBJECT_3D}.${outputName} != null ){
						${varName}.copy(${ObjectBuilderAssemblerCommon/* ObjectBuilderAssemblerConstant.OBJECT_3D */.F.OBJECT_3D}.${outputName})
					}`);
          break;
        }
        case Common/* LightUserDataRaymarching.PENUMBRA */.W.PENUMBRA:
        case Common/* LightUserDataRaymarching.SHADOW_BIAS_ANGLE */.W.SHADOW_BIAS_ANGLE:
        case Common/* LightUserDataRaymarching.SHADOW_BIAS_DISTANCE */.W.SHADOW_BIAS_DISTANCE: {
          bodyLines.push(`if( ${ObjectBuilderAssemblerCommon/* ObjectBuilderAssemblerConstant.OBJECT_3D */.F.OBJECT_3D}.userData['${outputName}'] != null ){
								${varName} = ${ObjectBuilderAssemblerCommon/* ObjectBuilderAssemblerConstant.OBJECT_3D */.F.OBJECT_3D}.userData['${outputName}']
							} else {
								${varName} = 0;
							}`);
        }
      }
    }
    linesController._addBodyLines(this, bodyLines);
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/js/HsvToRgb.ts






class HsvToRgbParamsJsConfig extends params_ParamsConfig/* NodeParamsConfig */.yI {
  constructor() {
    super(...arguments);
    this.hsv = params_ParamsConfig/* ParamConfig.VECTOR3 */.XC.VECTOR3([0, 0, 0]);
  }
}
const ParamsConfig_HsvToRgb = new HsvToRgbParamsJsConfig();
class HsvToRgbJsNode extends js_Base/* TypedJsNode */.xZ {
  constructor() {
    super(...arguments);
    this.paramsConfig = ParamsConfig_HsvToRgb;
  }
  static type() {
    return "hsvToRgb";
  }
  initializeNode() {
    this.io.outputs.setNamedOutputConnectionPoints([
      new connections_Js/* JsConnectionPoint */.fp(connections_Js/* JsConnectionPointType.COLOR */.zF.COLOR, connections_Js/* JsConnectionPointType.COLOR */.zF.COLOR)
    ]);
  }
  setLines(linesController) {
    const linesData = [];
    const vec3 = this.variableForInputParam(linesController, this.p.hsv);
    const varName = this.jsVarName(connections_Js/* JsConnectionPointType.COLOR */.zF.COLOR);
    const tmpVar = linesController.addVariable(this, new three_module.Color());
    const func = Poly/* Poly.namedFunctionsRegister.getFunction */.L.namedFunctionsRegister.getFunction("hsvToRgb", this, linesController);
    linesData.push({
      dataType: connections_Js/* JsConnectionPointType.COLOR */.zF.COLOR,
      varName,
      value: func.asString(vec3, tmpVar)
    });
    linesController.addBodyOrComputed(this, linesData);
  }
}

// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/nodes/js/ImportAttribute.ts
var ImportAttribute = __webpack_require__(19633);
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/js/IsDefined.ts





const IsDefined_ALLOWED_TYPES = [
  connections_Js/* JsConnectionPointType.BOOLEAN */.zF.BOOLEAN,
  connections_Js/* JsConnectionPointType.INT */.zF.INT,
  connections_Js/* JsConnectionPointType.COLOR */.zF.COLOR,
  connections_Js/* JsConnectionPointType.FLOAT */.zF.FLOAT,
  connections_Js/* JsConnectionPointType.INTERSECTION */.zF.INTERSECTION,
  connections_Js/* JsConnectionPointType.MATERIAL */.zF.MATERIAL,
  connections_Js/* JsConnectionPointType.OBJECT_3D */.zF.OBJECT_3D,
  connections_Js/* JsConnectionPointType.STRING */.zF.STRING,
  connections_Js/* JsConnectionPointType.TEXTURE */.zF.TEXTURE,
  connections_Js/* JsConnectionPointType.VECTOR2 */.zF.VECTOR2,
  connections_Js/* JsConnectionPointType.VECTOR3 */.zF.VECTOR3,
  connections_Js/* JsConnectionPointType.VECTOR4 */.zF.VECTOR4
];
const IsDefined_OUTPUT_NAME = "defined";
var IsDefinedInputName = /* @__PURE__ */ ((IsDefinedInputName2) => {
  IsDefinedInputName2["VALUE"] = "value";
  return IsDefinedInputName2;
})(IsDefinedInputName || {});
class IsDefinedJsParamsConfig extends params_ParamsConfig/* NodeParamsConfig */.yI {
}
const IsDefined_ParamsConfig = new IsDefinedJsParamsConfig();
class IsDefinedJsNode extends js_Base/* TypedJsNode */.xZ {
  constructor() {
    super(...arguments);
    this.paramsConfig = IsDefined_ParamsConfig;
  }
  static type() {
    return "isDefined";
  }
  initializeNode() {
    super.initializeNode();
    this.io.connection_points.initializeNode();
    this.io.connection_points.set_input_name_function(this._expectedInputName.bind(this));
    this.io.connection_points.set_output_name_function(this._expectedOutputName.bind(this));
    this.io.connection_points.set_expected_input_types_function(this._expectedInputTypes.bind(this));
    this.io.connection_points.set_expected_output_types_function(this._expectedOutputTypes.bind(this));
  }
  _expectedInputName(index) {
    return ["value" /* VALUE */][index];
  }
  _expectedInputTypes() {
    let first_input_type = this.io.connection_points.first_input_connection_type();
    const connectionPoints = this.io.inputs.namedInputConnectionPoints();
    if (first_input_type && connectionPoints) {
      if (!IsDefined_ALLOWED_TYPES.includes(first_input_type)) {
        const first_connection = connectionPoints[0];
        if (first_connection) {
          first_input_type = first_connection.type();
        }
      }
    }
    const type = first_input_type || connections_Js/* JsConnectionPointType.FLOAT */.zF.FLOAT;
    return [type];
  }
  _expectedOutputTypes() {
    return [connections_Js/* JsConnectionPointType.BOOLEAN */.zF.BOOLEAN];
  }
  _expectedOutputName(index) {
    return IsDefined_OUTPUT_NAME;
  }
  setLines(linesController) {
    const varName = this.jsVarName(this._expectedOutputName(0));
    const inputType = this._expectedInputTypes()[0];
    const variable = (0,_BaseJsPersistedConfigUtils/* createVariable */.Os)(inputType);
    if (variable) {
      linesController.addVariable(this, variable);
    }
    const value = this.variableForInput(linesController, "value" /* VALUE */);
    const mainFunction = `${value} != null`;
    linesController.addBodyOrComputed(this, [{ dataType: inputType, varName, value: mainFunction }]);
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/js/IsTouchDevice.ts





const IsTouchDevice_OUTPUT_NAME = "isTouchDevice";
class IsTouchDeviceJsParamsConfig extends params_ParamsConfig/* NodeParamsConfig */.yI {
}
const IsTouchDevice_ParamsConfig = new IsTouchDeviceJsParamsConfig();
class IsTouchDeviceJsNode extends js_Base/* TypedJsNode */.xZ {
  constructor() {
    super(...arguments);
    this.paramsConfig = IsTouchDevice_ParamsConfig;
  }
  static type() {
    return "isTouchDevice";
  }
  initializeNode() {
    super.initializeNode();
    this.io.outputs.setNamedOutputConnectionPoints([
      new connections_Js/* JsConnectionPoint */.fp(IsTouchDevice_OUTPUT_NAME, connections_Js/* JsConnectionPointType.BOOLEAN */.zF.BOOLEAN)
    ]);
  }
  setLines(linesController) {
    const varName = this.jsVarName(IsTouchDevice_OUTPUT_NAME);
    const func = Poly/* Poly.namedFunctionsRegister.getFunction */.L.namedFunctionsRegister.getFunction("isTouchDevice", this, linesController);
    linesController.addBodyOrComputed(this, [
      { dataType: connections_Js/* JsConnectionPointType.BOOLEAN */.zF.BOOLEAN, varName, value: func.asString() }
    ]);
    return;
  }
}

// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/nodes/js/Keyframes.ts
var Keyframes = __webpack_require__(10330);
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/js/Length.ts




var LengthJsNodeInputName = /* @__PURE__ */ ((LengthJsNodeInputName2) => {
  LengthJsNodeInputName2["VALUE"] = "v";
  return LengthJsNodeInputName2;
})(LengthJsNodeInputName || {});
const Length_DefaultValues = {
  ["v" /* VALUE */]: 1
};
const Length_OUTPUT_NAME = "val";
const Length_ALLOWED_INPUT_TYPES = [
  connections_Js/* JsConnectionPointType.VECTOR2 */.zF.VECTOR2,
  connections_Js/* JsConnectionPointType.VECTOR3 */.zF.VECTOR3,
  connections_Js/* JsConnectionPointType.VECTOR4 */.zF.VECTOR4
];
function Length_functionNameByType(type) {
  switch (type) {
    case connections_Js/* JsConnectionPointType.VECTOR2 */.zF.VECTOR2:
    case connections_Js/* JsConnectionPointType.VECTOR3 */.zF.VECTOR3:
    case connections_Js/* JsConnectionPointType.VECTOR4 */.zF.VECTOR4: {
      return "lengthVector";
    }
  }
}
class LengthJsNode extends js_Base/* ParamlessTypedJsNode */.au {
  static type() {
    return "length";
  }
  initializeNode() {
    super.initializeNode();
    this.io.connection_points.set_expected_input_types_function(this._expectedInputTypes.bind(this));
    this.io.connection_points.set_expected_output_types_function(this._expectedOutputTypes.bind(this));
    this.io.connection_points.set_input_name_function(this._expectedInputName.bind(this));
    this.io.connection_points.set_output_name_function(this._expectedOutputName.bind(this));
  }
  setLines(shadersCollectionController) {
    const input = this.variableForInput(shadersCollectionController, this._expectedInputName(0));
    const varName = this.jsVarName(this._expectedOutputName(0));
    const inputType = this._expectedInputTypes()[0];
    const functionName = Length_functionNameByType(inputType);
    if (functionName) {
      const func = Poly/* Poly.namedFunctionsRegister.getFunction */.L.namedFunctionsRegister.getFunction(functionName, this, shadersCollectionController);
      shadersCollectionController.addBodyOrComputed(this, [
        { dataType: inputType, varName, value: func.asString(input) }
      ]);
      return;
    }
  }
  _expectedInputTypes() {
    const firstType = this.io.connection_points.first_input_connection_type();
    const type = firstType && Length_ALLOWED_INPUT_TYPES.includes(firstType) ? firstType : connections_Js/* JsConnectionPointType.VECTOR3 */.zF.VECTOR3;
    return [type];
  }
  _expectedOutputTypes() {
    const inputType = this._expectedInputTypes()[0];
    const outputType = (0,connections_Js/* isJsConnectionPointArray */.$c)(inputType) ? connections_Js/* JsConnectionPointType.FLOAT_ARRAY */.zF.FLOAT_ARRAY : connections_Js/* JsConnectionPointType.FLOAT */.zF.FLOAT;
    return [outputType];
  }
  _expectedInputName(index) {
    return ["v" /* VALUE */][index];
  }
  _expectedOutputName(index) {
    return Length_OUTPUT_NAME;
  }
  paramDefaultValue(name) {
    return Length_DefaultValues[name];
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/js/Lerp.ts





var LerpInput = /* @__PURE__ */ ((LerpInput2) => {
  LerpInput2["v0"] = "v0";
  LerpInput2["v1"] = "v1";
  LerpInput2["alpha"] = "alpha";
  return LerpInput2;
})(LerpInput || {});
const Lerp_DefaultValues = {
  ["v0" /* v0 */]: 0,
  ["v1" /* v1 */]: 1,
  ["alpha" /* alpha */]: 0.5
};
const Lerp_FUNCTION_NAME = "mix";
class LerpJsNode extends MathFunctionArg3OperationFactory("lerp", {
  inputPrefix: "in",
  out: "lerp"
}) {
  _coreFunction(shadersCollectionController) {
    Poly/* Poly.namedFunctionsRegister.getFunction */.L.namedFunctionsRegister.getFunction(Lerp_FUNCTION_NAME, this, shadersCollectionController).asString("", "", "");
    return Lerp_FUNCTION_NAME;
  }
  _functionData() {
    return {
      vectorFunctionNameFunction: _MathGeneric/* _vectorFunctionName_3vvf */.ah,
      mathFloat: "mathFloat_3",
      mathPrimArray: "mathPrimArray_3",
      mathVectorArray: "mathVectorArray_3"
    };
  }
  paramDefaultValue(name) {
    return Lerp_DefaultValues[name];
  }
  _expectedInputName(index) {
    return ["v0" /* v0 */, "v1" /* v1 */, "alpha" /* alpha */][index];
  }
  _expectedInputTypes() {
    let first_input_type = this.io.connection_points.first_input_connection_type();
    const connectionPoints = this.io.inputs.namedInputConnectionPoints();
    if (first_input_type && connectionPoints) {
      if (!DEFAULT_ALLOWED_TYPES.includes(first_input_type)) {
        const first_connection = connectionPoints[0];
        if (first_connection) {
          first_input_type = first_connection.type();
        }
      }
    }
    const type = first_input_type || connections_Js/* JsConnectionPointType.FLOAT */.zF.FLOAT;
    const boundType = connections_Js/* JsConnectionPointTypeFromArrayTypeMap */.RR[type];
    return [type, boundType, connections_Js/* JsConnectionPointType.FLOAT */.zF.FLOAT];
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/js/ManhattanDistance.ts




var ManhattanDistanceJsNodeInputName = /* @__PURE__ */ ((ManhattanDistanceJsNodeInputName2) => {
  ManhattanDistanceJsNodeInputName2["VALUE0"] = "v0";
  ManhattanDistanceJsNodeInputName2["VALUE1"] = "v1";
  return ManhattanDistanceJsNodeInputName2;
})(ManhattanDistanceJsNodeInputName || {});
const ManhattanDistance_DefaultValues = {
  ["v0" /* VALUE0 */]: 1,
  ["v1" /* VALUE1 */]: 1
};
const ManhattanDistance_OUTPUT_NAME = "val";
const ManhattanDistance_ALLOWED_INPUT_TYPES = [connections_Js/* JsConnectionPointType.VECTOR2 */.zF.VECTOR2, connections_Js/* JsConnectionPointType.VECTOR3 */.zF.VECTOR3];
function ManhattanDistance_functionNameByType(type) {
  switch (type) {
    case connections_Js/* JsConnectionPointType.VECTOR2 */.zF.VECTOR2: {
      return "manhattanDistanceVector2";
    }
    case connections_Js/* JsConnectionPointType.VECTOR3 */.zF.VECTOR3: {
      return "manhattanDistanceVector3";
    }
  }
}
class ManhattanDistanceJsNode extends js_Base/* ParamlessTypedJsNode */.au {
  static type() {
    return "manhattandistance";
  }
  initializeNode() {
    super.initializeNode();
    this.io.connection_points.set_expected_input_types_function(this._expectedInputTypes.bind(this));
    this.io.connection_points.set_expected_output_types_function(this._expectedOutputTypes.bind(this));
    this.io.connection_points.set_input_name_function(this._expectedInputName.bind(this));
    this.io.connection_points.set_output_name_function(this._expectedOutputName.bind(this));
  }
  setLines(shadersCollectionController) {
    const value0 = this.variableForInput(shadersCollectionController, "v0" /* VALUE0 */);
    const value1 = this.variableForInput(shadersCollectionController, "v1" /* VALUE1 */);
    const varName = this.jsVarName(this._expectedOutputName(0));
    const inputType = this._expectedInputTypes()[0];
    const functionName = ManhattanDistance_functionNameByType(inputType);
    if (functionName) {
      const func = Poly/* Poly.namedFunctionsRegister.getFunction */.L.namedFunctionsRegister.getFunction(functionName, this, shadersCollectionController);
      shadersCollectionController.addBodyOrComputed(this, [
        { dataType: inputType, varName, value: func.asString(value0, value1) }
      ]);
      return;
    }
  }
  _expectedInputTypes() {
    const firstType = this.io.connection_points.first_input_connection_type();
    const type = firstType && ManhattanDistance_ALLOWED_INPUT_TYPES.includes(firstType) ? firstType : connections_Js/* JsConnectionPointType.VECTOR3 */.zF.VECTOR3;
    return [type, type];
  }
  _expectedOutputTypes() {
    const inputType = this._expectedInputTypes()[0];
    const outputType = (0,connections_Js/* isJsConnectionPointArray */.$c)(inputType) ? connections_Js/* JsConnectionPointType.FLOAT_ARRAY */.zF.FLOAT_ARRAY : connections_Js/* JsConnectionPointType.FLOAT */.zF.FLOAT;
    return [outputType];
  }
  _expectedInputName(index) {
    return ["v0" /* VALUE0 */, "v1" /* VALUE1 */][index];
  }
  _expectedOutputName(index) {
    return ManhattanDistance_OUTPUT_NAME;
  }
  paramDefaultValue(name) {
    return ManhattanDistance_DefaultValues[name];
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/js/Matrix4LookAt.ts






class Matrix4LookAtJsParamsConfig extends params_ParamsConfig/* NodeParamsConfig */.yI {
  constructor() {
    super(...arguments);
    /** @param eye */
    this.eye = params_ParamsConfig/* ParamConfig.VECTOR3 */.XC.VECTOR3([0, 0, 0]);
    /** @param target */
    this.target = params_ParamsConfig/* ParamConfig.VECTOR3 */.XC.VECTOR3([0, 0, 1]);
    /** @param up */
    this.up = params_ParamsConfig/* ParamConfig.VECTOR3 */.XC.VECTOR3([0, 1, 0]);
  }
}
const Matrix4LookAt_ParamsConfig = new Matrix4LookAtJsParamsConfig();
class Matrix4LookAtJsNode extends js_Base/* TypedJsNode */.xZ {
  constructor() {
    super(...arguments);
    this.paramsConfig = Matrix4LookAt_ParamsConfig;
  }
  static type() {
    return "matrix4LookAt";
  }
  initializeNode() {
    super.initializeNode();
    this.io.outputs.setNamedOutputConnectionPoints([
      new connections_Js/* JsConnectionPoint */.fp(connections_Js/* JsConnectionPointType.MATRIX4 */.zF.MATRIX4, connections_Js/* JsConnectionPointType.MATRIX4 */.zF.MATRIX4)
    ]);
  }
  setLines(linesController) {
    const eye = this.variableForInputParam(linesController, this.p.eye);
    const target = this.variableForInputParam(linesController, this.p.target);
    const up = this.variableForInputParam(linesController, this.p.up);
    const varName = this.jsVarName(connections_Js/* JsConnectionPointType.MATRIX4 */.zF.MATRIX4);
    const tmpVarName = linesController.addVariable(this, new three_module.Matrix4());
    const func = Poly/* Poly.namedFunctionsRegister.getFunction */.L.namedFunctionsRegister.getFunction("matrix4LookAt", this, linesController);
    linesController.addBodyOrComputed(this, [
      {
        dataType: connections_Js/* JsConnectionPointType.MATRIX4 */.zF.MATRIX4,
        varName,
        value: func.asString(eye, target, up, tmpVarName)
      }
    ]);
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/js/Matrix4MakeTranslation.ts






class Matrix4MakeTranslationJsParamsConfig extends params_ParamsConfig/* NodeParamsConfig */.yI {
  constructor() {
    super(...arguments);
    /** @param t */
    this.t = params_ParamsConfig/* ParamConfig.VECTOR3 */.XC.VECTOR3([0, 0, 0]);
  }
}
const Matrix4MakeTranslation_ParamsConfig = new Matrix4MakeTranslationJsParamsConfig();
class Matrix4MakeTranslationJsNode extends js_Base/* TypedJsNode */.xZ {
  constructor() {
    super(...arguments);
    this.paramsConfig = Matrix4MakeTranslation_ParamsConfig;
  }
  static type() {
    return "matrix4MakeTranslation";
  }
  initializeNode() {
    super.initializeNode();
    this.io.outputs.setNamedOutputConnectionPoints([
      new connections_Js/* JsConnectionPoint */.fp(connections_Js/* JsConnectionPointType.MATRIX4 */.zF.MATRIX4, connections_Js/* JsConnectionPointType.MATRIX4 */.zF.MATRIX4)
    ]);
  }
  setLines(linesController) {
    const t = this.variableForInputParam(linesController, this.p.t);
    const varName = this.jsVarName(connections_Js/* JsConnectionPointType.MATRIX4 */.zF.MATRIX4);
    const tmpVarName = linesController.addVariable(this, new three_module.Matrix4());
    const func = Poly/* Poly.namedFunctionsRegister.getFunction */.L.namedFunctionsRegister.getFunction("matrix4MakeTranslation", this, linesController);
    linesController.addBodyOrComputed(this, [
      {
        dataType: connections_Js/* JsConnectionPointType.MATRIX4 */.zF.MATRIX4,
        varName,
        value: func.asString(t, tmpVarName)
      }
    ]);
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/js/Matrix4Multiply.ts






const Matrix4Multiply_CONNECTION_OPTIONS = connections_Js/* JS_CONNECTION_POINT_IN_NODE_DEF */.mX;
var Matrix4MultiplyInputName = /* @__PURE__ */ ((Matrix4MultiplyInputName2) => {
  Matrix4MultiplyInputName2["m1"] = "m1";
  Matrix4MultiplyInputName2["m2"] = "m2";
  return Matrix4MultiplyInputName2;
})(Matrix4MultiplyInputName || {});
class Matrix4MultiplyJsParamsConfig extends params_ParamsConfig/* NodeParamsConfig */.yI {
}
const Matrix4Multiply_ParamsConfig = new Matrix4MultiplyJsParamsConfig();
class Matrix4MultiplyJsNode extends js_Base/* TypedJsNode */.xZ {
  constructor() {
    super(...arguments);
    this.paramsConfig = Matrix4Multiply_ParamsConfig;
  }
  static type() {
    return "matrix4Multiply";
  }
  initializeNode() {
    super.initializeNode();
    this.io.inputs.setNamedInputConnectionPoints([
      new connections_Js/* JsConnectionPoint */.fp("m1" /* m1 */, connections_Js/* JsConnectionPointType.MATRIX4 */.zF.MATRIX4, Matrix4Multiply_CONNECTION_OPTIONS),
      new connections_Js/* JsConnectionPoint */.fp("m2" /* m2 */, connections_Js/* JsConnectionPointType.MATRIX4 */.zF.MATRIX4, Matrix4Multiply_CONNECTION_OPTIONS)
    ]);
    this.io.outputs.setNamedOutputConnectionPoints([
      new connections_Js/* JsConnectionPoint */.fp(connections_Js/* JsConnectionPointType.MATRIX4 */.zF.MATRIX4, connections_Js/* JsConnectionPointType.MATRIX4 */.zF.MATRIX4)
    ]);
  }
  setLines(linesController) {
    const m1 = this.variableForInput(linesController, "m1" /* m1 */);
    const m2 = this.variableForInput(linesController, "m2" /* m2 */);
    const varName = this.jsVarName(connections_Js/* JsConnectionPointType.MATRIX4 */.zF.MATRIX4);
    const tmpVarName = linesController.addVariable(this, new three_module.Matrix4());
    const func = Poly/* Poly.namedFunctionsRegister.getFunction */.L.namedFunctionsRegister.getFunction("matrix4Multiply", this, linesController);
    linesController.addBodyOrComputed(this, [
      {
        dataType: connections_Js/* JsConnectionPointType.MATRIX4 */.zF.MATRIX4,
        varName,
        value: func.asString(m1, m2, tmpVarName)
      }
    ]);
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/js/Max.ts



var MaxInput = /* @__PURE__ */ ((MaxInput2) => {
  MaxInput2["src"] = "src";
  MaxInput2["max"] = "max";
  return MaxInput2;
})(MaxInput || {});
const Max_DefaultValues = {
  ["src" /* src */]: 0,
  ["max" /* max */]: 1
};
class MaxJsNode extends _Math_Arg1Operation_MathFunctionArg2OperationFactory("max", {
  inputPrefix: "in",
  out: "max"
}) {
  paramDefaultValue(name) {
    return Max_DefaultValues[name];
  }
  _expectedInputName(index) {
    return ["src" /* src */, "max" /* max */][index];
  }
  _expectedInputTypes() {
    let first_input_type = this.io.connection_points.first_input_connection_type();
    const connectionPoints = this.io.inputs.namedInputConnectionPoints();
    if (first_input_type && connectionPoints) {
      if (!DEFAULT_ALLOWED_TYPES.includes(first_input_type)) {
        const first_connection = connectionPoints[0];
        if (first_connection) {
          first_input_type = first_connection.type();
        }
      }
    }
    const type = first_input_type || connections_Js/* JsConnectionPointType.FLOAT */.zF.FLOAT;
    const boundType = connections_Js/* JsConnectionPointTypeFromArrayTypeMap */.RR[type];
    return [type, boundType];
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/js/MaxLength.ts





var MaxLengthJsNodeInputName = /* @__PURE__ */ ((MaxLengthJsNodeInputName2) => {
  MaxLengthJsNodeInputName2["VALUE"] = "value";
  MaxLengthJsNodeInputName2["MAX"] = "max";
  return MaxLengthJsNodeInputName2;
})(MaxLengthJsNodeInputName || {});
const MaxLength_DefaultValues = {
  ["value" /* VALUE */]: 1,
  ["max" /* MAX */]: 1
};
const MaxLength_OUTPUT_NAME = "vector";
const MaxLength_ALLOWED_INPUT_TYPES = [
  connections_Js/* JsConnectionPointType.VECTOR2 */.zF.VECTOR2,
  connections_Js/* JsConnectionPointType.VECTOR3 */.zF.VECTOR3,
  connections_Js/* JsConnectionPointType.VECTOR4 */.zF.VECTOR4
];
function MaxLength_functionNameByType(type) {
  switch (type) {
    case connections_Js/* JsConnectionPointType.VECTOR2 */.zF.VECTOR2: {
      return "maxLengthVector2";
    }
    case connections_Js/* JsConnectionPointType.VECTOR3 */.zF.VECTOR3: {
      return "maxLengthVector3";
    }
    case connections_Js/* JsConnectionPointType.VECTOR4 */.zF.VECTOR4: {
      return "maxLengthVector4";
    }
  }
}
class MaxLengthJsNode extends js_Base/* ParamlessTypedJsNode */.au {
  static type() {
    return "maxLength";
  }
  initializeNode() {
    super.initializeNode();
    this.io.connection_points.set_expected_input_types_function(this._expectedInputTypes.bind(this));
    this.io.connection_points.set_expected_output_types_function(this._expectedOutputTypes.bind(this));
    this.io.connection_points.set_input_name_function(this._expectedInputName.bind(this));
    this.io.connection_points.set_output_name_function(this._expectedOutputName.bind(this));
  }
  setLines(shadersCollectionController) {
    const input = this.variableForInput(shadersCollectionController, this._expectedInputName(0));
    const scalar = this.variableForInput(shadersCollectionController, this._expectedInputName(1));
    const varName = this.jsVarName(this._expectedOutputName(0));
    const inputType = this._expectedInputTypes()[0];
    const variable = (0,_BaseJsPersistedConfigUtils/* createVariable */.Os)(inputType);
    const tmpVarName = variable ? shadersCollectionController.addVariable(this, variable) : void 0;
    const functionName = MaxLength_functionNameByType(inputType);
    if (functionName && tmpVarName) {
      const func = Poly/* Poly.namedFunctionsRegister.getFunction */.L.namedFunctionsRegister.getFunction(functionName, this, shadersCollectionController);
      shadersCollectionController.addBodyOrComputed(this, [
        { dataType: inputType, varName, value: func.asString(input, scalar, tmpVarName) }
      ]);
      return;
    }
  }
  _expectedInputTypes() {
    const firstType = this.io.connection_points.first_input_connection_type();
    const type = firstType && MaxLength_ALLOWED_INPUT_TYPES.includes(firstType) ? firstType : connections_Js/* JsConnectionPointType.VECTOR3 */.zF.VECTOR3;
    return [type, connections_Js/* JsConnectionPointType.FLOAT */.zF.FLOAT];
  }
  _expectedOutputTypes() {
    return [this._expectedInputTypes()[0]];
  }
  _expectedInputName(index) {
    return ["value" /* VALUE */, "max" /* MAX */][index];
  }
  _expectedOutputName(index) {
    return MaxLength_OUTPUT_NAME;
  }
  paramDefaultValue(name) {
    return MaxLength_DefaultValues[name];
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/js/Min.ts



var MinInput = /* @__PURE__ */ ((MinInput2) => {
  MinInput2["src"] = "src";
  MinInput2["min"] = "min";
  return MinInput2;
})(MinInput || {});
const Min_DefaultValues = {
  ["src" /* src */]: 0,
  ["min" /* min */]: 0
};
class MinJsNode extends _Math_Arg1Operation_MathFunctionArg2OperationFactory("min", {
  inputPrefix: "in",
  out: "min"
}) {
  paramDefaultValue(name) {
    return Min_DefaultValues[name];
  }
  _expectedInputName(index) {
    return ["src" /* src */, "min" /* min */][index];
  }
  _expectedInputTypes() {
    let first_input_type = this.io.connection_points.first_input_connection_type();
    const connectionPoints = this.io.inputs.namedInputConnectionPoints();
    if (first_input_type && connectionPoints) {
      if (!DEFAULT_ALLOWED_TYPES.includes(first_input_type)) {
        const first_connection = connectionPoints[0];
        if (first_connection) {
          first_input_type = first_connection.type();
        }
      }
    }
    const type = first_input_type || connections_Js/* JsConnectionPointType.FLOAT */.zF.FLOAT;
    const boundType = connections_Js/* JsConnectionPointTypeFromArrayTypeMap */.RR[type];
    return [type, boundType];
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/js/Mix.ts





var MixInput = /* @__PURE__ */ ((MixInput2) => {
  MixInput2["value0"] = "value0";
  MixInput2["value1"] = "value1";
  MixInput2["blend"] = "blend";
  return MixInput2;
})(MixInput || {});
const js_Mix_DefaultValues = {
  ["value0" /* value0 */]: 0,
  ["value1" /* value1 */]: 1,
  ["blend" /* blend */]: 0.5
};
const Mix_FUNCTION_NAME = "mix";
class MixJsNode extends MathFunctionArg3OperationFactory("mix", {
  inputPrefix: "in",
  out: "mix"
}) {
  _coreFunction(shadersCollectionController) {
    Poly/* Poly.namedFunctionsRegister.getFunction */.L.namedFunctionsRegister.getFunction(Mix_FUNCTION_NAME, this, shadersCollectionController).asString("", "", "");
    return Mix_FUNCTION_NAME;
  }
  _functionData() {
    return {
      vectorFunctionNameFunction: _MathGeneric/* _vectorFunctionName_3vvf */.ah,
      mathFloat: "mathFloat_3",
      mathPrimArray: "mathPrimArray_3",
      mathVectorArray: "mathVectorArray_3"
    };
  }
  paramDefaultValue(name) {
    return js_Mix_DefaultValues[name];
  }
  _expectedInputName(index) {
    return ["value0" /* value0 */, "value1" /* value1 */, "blend" /* blend */][index];
  }
  _expectedInputTypes() {
    let first_input_type = this.io.connection_points.first_input_connection_type();
    const connectionPoints = this.io.inputs.namedInputConnectionPoints();
    if (first_input_type && connectionPoints) {
      if (!DEFAULT_ALLOWED_TYPES.includes(first_input_type)) {
        const first_connection = connectionPoints[0];
        if (first_connection) {
          first_input_type = first_connection.type();
        }
      }
    }
    const type = first_input_type || connections_Js/* JsConnectionPointType.FLOAT */.zF.FLOAT;
    const boundType = connections_Js/* JsConnectionPointTypeFromArrayTypeMap */.RR[type];
    return [type, boundType, connections_Js/* JsConnectionPointType.FLOAT */.zF.FLOAT];
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/js/Mod.ts




var ModInput = /* @__PURE__ */ ((ModInput2) => {
  ModInput2["value0"] = "value0";
  ModInput2["value1"] = "value1";
  return ModInput2;
})(ModInput || {});
const Mod_DefaultValues = {
  ["value0" /* value0 */]: 0,
  ["value1" /* value1 */]: 1
};
const Mod_FUNCTION_NAME = "mod";
class ModJsNode extends _Math_Arg1Operation_MathFunctionArg2OperationFactory("mod", {
  inputPrefix: "in",
  out: "mod"
}) {
  _coreFunction(shadersCollectionController) {
    Poly/* Poly.namedFunctionsRegister.getFunction */.L.namedFunctionsRegister.getFunction(Mod_FUNCTION_NAME, this, shadersCollectionController).asString("", "");
    return Mod_FUNCTION_NAME;
  }
  paramDefaultValue(name) {
    return Mod_DefaultValues[name];
  }
  _expectedInputName(index) {
    return ["value0" /* value0 */, "value1" /* value1 */][index];
  }
  _expectedInputTypes() {
    return [connections_Js/* JsConnectionPointType.FLOAT */.zF.FLOAT, connections_Js/* JsConnectionPointType.FLOAT */.zF.FLOAT];
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/js/Mult.ts


class MultJsNode extends MathFunctionArgNOperationFactory("mult", {
  inputPrefix: "mult",
  out: "product",
  operator: {
    primitive: "multNumber",
    vector: "multVector",
    vectorScalar: "multVectorNumber"
  }
}) {
  // static override type() {
  // 	return 'mult';
  // }
  paramDefaultValue(name) {
    return 1;
  }
  // protected _applyOperation<T extends number>(arg1: T, arg2: T): any {
  // 	return arg1 * arg2;
  // }
  // override initializeNode() {
  // 	super.initializeNode();
  // 	this.io.connection_points.set_expected_input_types_function(this._expectedInputTypes.bind(this));
  // 	this.io.connection_points.set_expected_output_types_function(this._expectedOutputType.bind(this));
  // }
  // protected _expectedOutputType() {
  // 	const inputTypes = this._expectedInputTypes();
  // 	const type = inputTypes[inputTypes.length - 1];
  // 	return [type];
  // }
  // protected override _expectedInputTypes(): JsConnectionPointType[] {
  // 	const input_connections = this.io.connections.existingInputConnections();
  // 	if (input_connections) {
  // 		const first_connection = input_connections[0];
  // 		if (first_connection) {
  // 			const connection_point_for_first_connection =
  // 				first_connection.node_src.io.outputs.namedOutputConnectionPoints()[first_connection.output_index];
  // 			// this.io.inputs.namedInputConnectionPoints()[
  // 			// 	first_connection.input_index
  // 			// ];
  // 			const type = connection_point_for_first_connection.type();
  // 			const expected_count = Math.max(input_connections.length + 1, 2);
  // 			const empty_array = new Array(expected_count);
  // 			if (type == JsConnectionPointType.FLOAT) {
  // 				const second_connection = input_connections[1];
  // 				if (second_connection) {
  // 					const connection_point_for_second_connection =
  // 						second_connection.node_src.io.outputs.namedOutputConnectionPoints()[
  // 							second_connection.output_index
  // 						];
  // 					const second_type = connection_point_for_second_connection.type();
  // 					if (second_type == JsConnectionPointType.FLOAT) {
  // 						// if first 2 inputs are float: n+1 float inputs
  // 						return empty_array.fill(type);
  // 					} else {
  // 						// if first input is float and 2nd is different: 1 float, 1 like second, and no other input
  // 						return [type, second_type];
  // 					}
  // 				} else {
  // 					// if only 1 input: 2 with same type
  // 					return [type, type];
  // 				}
  // 			} else {
  // 				// if first input is not a float: n+1 inputs with same type
  // 				return empty_array.fill(type);
  // 			}
  // 		} else {
  // 			// if we arrive here, we simply go to the last return statement
  // 		}
  // 	}
  // 	return [JsConnectionPointType.FLOAT, JsConnectionPointType.FLOAT];
  // }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/js/MultAdd.ts




var MultAddInput = /* @__PURE__ */ ((MultAddInput2) => {
  MultAddInput2["VALUE"] = "value";
  MultAddInput2["PRE_ADD"] = "preAdd";
  MultAddInput2["MULT"] = "mult";
  MultAddInput2["POST_ADD"] = "postAdd";
  return MultAddInput2;
})(MultAddInput || {});
const js_MultAdd_DefaultValues = {
  ["value" /* VALUE */]: 0,
  ["preAdd" /* PRE_ADD */]: 0,
  ["mult" /* MULT */]: 1,
  ["postAdd" /* POST_ADD */]: 0
};
const MultAdd_FUNCTION_NAME = "multAdd";
class MultAddJsNode extends MathFunctionArg4OperationFactory("multAdd", {
  inputPrefix: "in",
  out: "val"
}) {
  _coreFunction(shadersCollectionController) {
    Poly/* Poly.namedFunctionsRegister.getFunction */.L.namedFunctionsRegister.getFunction(MultAdd_FUNCTION_NAME, this, shadersCollectionController).asString("", "", "", "");
    return MultAdd_FUNCTION_NAME;
  }
  paramDefaultValue(name) {
    return js_MultAdd_DefaultValues[name];
  }
  _expectedInputName(index) {
    return ["value" /* VALUE */, "preAdd" /* PRE_ADD */, "mult" /* MULT */, "postAdd" /* POST_ADD */][index];
  }
  _expectedInputTypes() {
    let first_input_type = this.io.connection_points.first_input_connection_type();
    const connectionPoints = this.io.inputs.namedInputConnectionPoints();
    if (first_input_type && connectionPoints) {
      if (!DEFAULT_ALLOWED_TYPES.includes(first_input_type)) {
        const first_connection = connectionPoints[0];
        if (first_connection) {
          first_input_type = first_connection.type();
        }
      }
    }
    const type = first_input_type || connections_Js/* JsConnectionPointType.FLOAT */.zF.FLOAT;
    const boundType = connections_Js/* JsConnectionPointTypeFromArrayTypeMap */.RR[type];
    return [type, boundType, boundType, boundType];
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/js/MultScalar.ts





var MultScalarJsNodeInputName = /* @__PURE__ */ ((MultScalarJsNodeInputName2) => {
  MultScalarJsNodeInputName2["VALUE"] = "value";
  MultScalarJsNodeInputName2["MULT"] = "mult";
  return MultScalarJsNodeInputName2;
})(MultScalarJsNodeInputName || {});
const js_MultScalar_DefaultValues = {
  ["value" /* VALUE */]: 1,
  ["mult" /* MULT */]: 1
};
const MultScalar_OUTPUT_NAME = "val";
const MultScalar_ALLOWED_INPUT_TYPES = [
  connections_Js/* JsConnectionPointType.COLOR */.zF.COLOR,
  connections_Js/* JsConnectionPointType.VECTOR2 */.zF.VECTOR2,
  connections_Js/* JsConnectionPointType.VECTOR3 */.zF.VECTOR3,
  connections_Js/* JsConnectionPointType.VECTOR4 */.zF.VECTOR4
];
function MultScalar_functionNameByType(type) {
  switch (type) {
    case connections_Js/* JsConnectionPointType.COLOR */.zF.COLOR: {
      return "multScalarColor";
    }
    case connections_Js/* JsConnectionPointType.VECTOR2 */.zF.VECTOR2: {
      return "multScalarVector2";
    }
    case connections_Js/* JsConnectionPointType.VECTOR3 */.zF.VECTOR3: {
      return "multScalarVector3";
    }
    case connections_Js/* JsConnectionPointType.VECTOR4 */.zF.VECTOR4: {
      return "multScalarVector4";
    }
  }
}
class MultScalarJsNode extends js_Base/* ParamlessTypedJsNode */.au {
  static type() {
    return "multScalar";
  }
  initializeNode() {
    super.initializeNode();
    this.io.connection_points.set_expected_input_types_function(this._expectedInputTypes.bind(this));
    this.io.connection_points.set_expected_output_types_function(this._expectedOutputTypes.bind(this));
    this.io.connection_points.set_input_name_function(this._expectedInputName.bind(this));
    this.io.connection_points.set_output_name_function(this._expectedOutputName.bind(this));
  }
  setLines(shadersCollectionController) {
    const input = this.variableForInput(shadersCollectionController, this._expectedInputName(0));
    const scalar = this.variableForInput(shadersCollectionController, this._expectedInputName(1));
    const varName = this.jsVarName(this._expectedOutputName(0));
    const inputType = this._expectedInputTypes()[0];
    const variable = (0,_BaseJsPersistedConfigUtils/* createVariable */.Os)(inputType);
    const tmpVarName = variable ? shadersCollectionController.addVariable(this, variable) : void 0;
    const functionName = MultScalar_functionNameByType(inputType);
    if (functionName && tmpVarName) {
      const func = Poly/* Poly.namedFunctionsRegister.getFunction */.L.namedFunctionsRegister.getFunction(functionName, this, shadersCollectionController);
      shadersCollectionController.addBodyOrComputed(this, [
        { dataType: inputType, varName, value: func.asString(input, scalar, tmpVarName) }
      ]);
      return;
    }
  }
  _expectedInputTypes() {
    const firstType = this.io.connection_points.first_input_connection_type();
    const type = firstType && MultScalar_ALLOWED_INPUT_TYPES.includes(firstType) ? firstType : connections_Js/* JsConnectionPointType.VECTOR3 */.zF.VECTOR3;
    return [type, connections_Js/* JsConnectionPointType.FLOAT */.zF.FLOAT];
  }
  _expectedOutputTypes() {
    return [this._expectedInputTypes()[0]];
  }
  _expectedInputName(index) {
    return ["value" /* VALUE */, "mult" /* MULT */][index];
  }
  _expectedOutputName(index) {
    return MultScalar_OUTPUT_NAME;
  }
  paramDefaultValue(name) {
    return js_MultScalar_DefaultValues[name];
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/js/NearestPosition.ts






const NearestPosition_CONNECTION_OPTIONS = connections_Js/* JS_CONNECTION_POINT_IN_NODE_DEF */.mX;
const NearestPosition_OUTPUT_NAME = "position";
class NearestPositionJsParamsConfig extends params_ParamsConfig/* NodeParamsConfig */.yI {
  constructor() {
    super(...arguments);
    /** @param vector3 */
    this.Vector3 = params_ParamsConfig/* ParamConfig.VECTOR3 */.XC.VECTOR3([0, 0, 0]);
  }
}
const NearestPosition_ParamsConfig = new NearestPositionJsParamsConfig();
class NearestPositionJsNode extends js_Base/* TypedJsNode */.xZ {
  constructor() {
    super(...arguments);
    this.paramsConfig = NearestPosition_ParamsConfig;
  }
  static type() {
    return "nearestPosition";
  }
  initializeNode() {
    super.initializeNode();
    this.io.inputs.setNamedInputConnectionPoints([
      new connections_Js/* JsConnectionPoint */.fp(connections_Js/* JsConnectionPointType.VECTOR3 */.zF.VECTOR3, connections_Js/* JsConnectionPointType.VECTOR3 */.zF.VECTOR3, NearestPosition_CONNECTION_OPTIONS),
      new connections_Js/* JsConnectionPoint */.fp(
        connections_Js/* JsConnectionPointType.VECTOR3_ARRAY */.zF.VECTOR3_ARRAY,
        connections_Js/* JsConnectionPointType.VECTOR3_ARRAY */.zF.VECTOR3_ARRAY,
        NearestPosition_CONNECTION_OPTIONS
      )
    ]);
    this.io.outputs.setNamedOutputConnectionPoints([
      new connections_Js/* JsConnectionPoint */.fp(NearestPosition_OUTPUT_NAME, connections_Js/* JsConnectionPointType.VECTOR3 */.zF.VECTOR3)
    ]);
  }
  setLines(shadersCollectionController) {
    const v3 = this.variableForInputParam(shadersCollectionController, this.p.Vector3);
    const positions = this.variableForInput(shadersCollectionController, connections_Js/* JsConnectionPointType.VECTOR3_ARRAY */.zF.VECTOR3_ARRAY);
    const varName = this.jsVarName(NearestPosition_OUTPUT_NAME);
    const variable = (0,_BaseJsPersistedConfigUtils/* createVariable */.Os)(connections_Js/* JsConnectionPointType.VECTOR3 */.zF.VECTOR3);
    const tmpVarName = variable ? shadersCollectionController.addVariable(this, variable) : void 0;
    if (!tmpVarName) {
      return;
    }
    const func = Poly/* Poly.namedFunctionsRegister.getFunction */.L.namedFunctionsRegister.getFunction("nearestPosition", this, shadersCollectionController);
    shadersCollectionController.addBodyOrComputed(this, [
      { dataType: connections_Js/* JsConnectionPointType.VECTOR3 */.zF.VECTOR3, varName, value: func.asString(v3, positions, tmpVarName) }
    ]);
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/js/Negate.ts




const Negate_FUNCTION_NAME = "negate";
class NegateJsNode extends MathFunctionArg1OperationFactory("negate", {
  inputPrefix: "value",
  out: "negate",
  allowed_in_types: [connections_Js/* JsConnectionPointType.BOOLEAN */.zF.BOOLEAN, ...PRIMITIVE_ALLOWED_TYPES]
}) {
  _coreFunction(shadersCollectionController) {
    Poly/* Poly.namedFunctionsRegister.getFunction */.L.namedFunctionsRegister.getFunction(Negate_FUNCTION_NAME, this, shadersCollectionController).asString("");
    return Negate_FUNCTION_NAME;
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/js/NoiseImproved.ts




var NoiseImprovedJsNodeInputName = /* @__PURE__ */ ((NoiseImprovedJsNodeInputName2) => {
  NoiseImprovedJsNodeInputName2["POSITION"] = "position";
  NoiseImprovedJsNodeInputName2["AMP"] = "amp";
  NoiseImprovedJsNodeInputName2["FREQ"] = "freq";
  NoiseImprovedJsNodeInputName2["OFFSET"] = "offset";
  NoiseImprovedJsNodeInputName2["OCTAVES"] = "octaves";
  NoiseImprovedJsNodeInputName2["AMP_MULT"] = "ampMult";
  NoiseImprovedJsNodeInputName2["FREQ_MULT"] = "freqMult";
  return NoiseImprovedJsNodeInputName2;
})(NoiseImprovedJsNodeInputName || {});
const NoiseImproved_DefaultValues = {
  ["position" /* POSITION */]: 0,
  ["amp" /* AMP */]: 1,
  ["freq" /* FREQ */]: 1,
  ["offset" /* OFFSET */]: 0,
  ["octaves" /* OCTAVES */]: 3,
  ["ampMult" /* AMP_MULT */]: 0.5,
  ["freqMult" /* FREQ_MULT */]: 2
};
const NoiseImproved_OUTPUT_NAME = "noise";
const NoiseImproved_ALLOWED_INPUT_TYPES = [connections_Js/* JsConnectionPointType.VECTOR3 */.zF.VECTOR3];
function NoiseImproved_functionNameByType(type) {
  switch (type) {
    case connections_Js/* JsConnectionPointType.VECTOR3 */.zF.VECTOR3: {
      return "noiseImprovedVector3";
    }
  }
}
class NoiseImprovedJsNode extends js_Base/* ParamlessTypedJsNode */.au {
  static type() {
    return "noiseImproved";
  }
  initializeNode() {
    super.initializeNode();
    this.io.connection_points.set_expected_input_types_function(this._expectedInputTypes.bind(this));
    this.io.connection_points.set_expected_output_types_function(this._expectedOutputTypes.bind(this));
    this.io.connection_points.set_input_name_function(this._expectedInputName.bind(this));
    this.io.connection_points.set_output_name_function(this._expectedOutputName.bind(this));
  }
  _firstType() {
    const firstType = this.io.connection_points.first_input_connection_type();
    const type = firstType && NoiseImproved_ALLOWED_INPUT_TYPES.includes(firstType) ? firstType : connections_Js/* JsConnectionPointType.VECTOR3 */.zF.VECTOR3;
    return type;
  }
  _expectedInputTypes() {
    const type = this._firstType();
    return [
      type,
      connections_Js/* JsConnectionPointType.FLOAT */.zF.FLOAT,
      type,
      type,
      connections_Js/* JsConnectionPointType.INT */.zF.INT,
      connections_Js/* JsConnectionPointType.FLOAT */.zF.FLOAT,
      connections_Js/* JsConnectionPointType.FLOAT */.zF.FLOAT
    ];
  }
  _expectedOutputTypes() {
    const type = connections_Js/* JsConnectionPointType.FLOAT */.zF.FLOAT;
    return [type];
  }
  _expectedInputName(index) {
    return [
      "position" /* POSITION */,
      "amp" /* AMP */,
      "freq" /* FREQ */,
      "offset" /* OFFSET */,
      "octaves" /* OCTAVES */,
      "ampMult" /* AMP_MULT */,
      "freqMult" /* FREQ_MULT */
    ][index];
  }
  _expectedOutputName(index) {
    return NoiseImproved_OUTPUT_NAME;
  }
  paramDefaultValue(name) {
    return NoiseImproved_DefaultValues[name];
  }
  setLines(shadersCollectionController) {
    const position = this.variableForInput(shadersCollectionController, "position" /* POSITION */);
    const amp = this.variableForInput(shadersCollectionController, "amp" /* AMP */);
    const freq = this.variableForInput(shadersCollectionController, "freq" /* FREQ */);
    const offset = this.variableForInput(shadersCollectionController, "offset" /* OFFSET */);
    const octaves = this.variableForInput(shadersCollectionController, "octaves" /* OCTAVES */);
    const ampMult = this.variableForInput(shadersCollectionController, "ampMult" /* AMP_MULT */);
    const freqMult = this.variableForInput(shadersCollectionController, "freqMult" /* FREQ_MULT */);
    const varName = this.jsVarName(this._expectedOutputName(0));
    const inputType = this._expectedInputTypes()[0];
    const functionName = NoiseImproved_functionNameByType(inputType);
    if (functionName) {
      const func = Poly/* Poly.namedFunctionsRegister.getFunction */.L.namedFunctionsRegister.getFunction(functionName, this, shadersCollectionController);
      shadersCollectionController.addBodyOrComputed(this, [
        {
          dataType: inputType,
          varName,
          value: func.asString(position, amp, freq, offset, octaves, ampMult, freqMult)
        }
      ]);
      return;
    }
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/js/NoiseSimplex.ts




var NoiseSimplexJsNodeInputName = /* @__PURE__ */ ((NoiseSimplexJsNodeInputName2) => {
  NoiseSimplexJsNodeInputName2["POSITION"] = "position";
  NoiseSimplexJsNodeInputName2["AMP"] = "amp";
  NoiseSimplexJsNodeInputName2["FREQ"] = "freq";
  NoiseSimplexJsNodeInputName2["OFFSET"] = "offset";
  NoiseSimplexJsNodeInputName2["OCTAVES"] = "octaves";
  NoiseSimplexJsNodeInputName2["AMP_MULT"] = "ampMult";
  NoiseSimplexJsNodeInputName2["FREQ_MULT"] = "freqMult";
  NoiseSimplexJsNodeInputName2["SEED"] = "seed";
  return NoiseSimplexJsNodeInputName2;
})(NoiseSimplexJsNodeInputName || {});
const NoiseSimplex_DefaultValues = {
  ["position" /* POSITION */]: 0,
  ["amp" /* AMP */]: 1,
  ["freq" /* FREQ */]: 1,
  ["offset" /* OFFSET */]: 0,
  ["octaves" /* OCTAVES */]: 3,
  ["ampMult" /* AMP_MULT */]: 0.5,
  ["freqMult" /* FREQ_MULT */]: 2,
  ["seed" /* SEED */]: 0
};
const NoiseSimplex_OUTPUT_NAME = "noise";
const NoiseSimplex_ALLOWED_INPUT_TYPES = [
  connections_Js/* JsConnectionPointType.VECTOR2 */.zF.VECTOR2,
  connections_Js/* JsConnectionPointType.VECTOR3 */.zF.VECTOR3,
  connections_Js/* JsConnectionPointType.VECTOR4 */.zF.VECTOR4
];
function NoiseSimplex_functionNameByType(type) {
  switch (type) {
    case connections_Js/* JsConnectionPointType.VECTOR2 */.zF.VECTOR2: {
      return "noiseSimplexVector2";
    }
    case connections_Js/* JsConnectionPointType.VECTOR3 */.zF.VECTOR3: {
      return "noiseSimplexVector3";
    }
    case connections_Js/* JsConnectionPointType.VECTOR4 */.zF.VECTOR4: {
      return "noiseSimplexVector4";
    }
  }
}
class NoiseSimplexJsNode extends js_Base/* ParamlessTypedJsNode */.au {
  static type() {
    return "noiseSimplex";
  }
  initializeNode() {
    super.initializeNode();
    this.io.connection_points.set_expected_input_types_function(this._expectedInputTypes.bind(this));
    this.io.connection_points.set_expected_output_types_function(this._expectedOutputTypes.bind(this));
    this.io.connection_points.set_input_name_function(this._expectedInputName.bind(this));
    this.io.connection_points.set_output_name_function(this._expectedOutputName.bind(this));
  }
  _firstType() {
    const firstType = this.io.connection_points.first_input_connection_type();
    const type = firstType && NoiseSimplex_ALLOWED_INPUT_TYPES.includes(firstType) ? firstType : connections_Js/* JsConnectionPointType.VECTOR3 */.zF.VECTOR3;
    return type;
  }
  _expectedInputTypes() {
    const type = this._firstType();
    return [
      type,
      connections_Js/* JsConnectionPointType.FLOAT */.zF.FLOAT,
      type,
      type,
      connections_Js/* JsConnectionPointType.INT */.zF.INT,
      connections_Js/* JsConnectionPointType.FLOAT */.zF.FLOAT,
      connections_Js/* JsConnectionPointType.FLOAT */.zF.FLOAT,
      connections_Js/* JsConnectionPointType.FLOAT */.zF.FLOAT
    ];
  }
  _expectedOutputTypes() {
    const type = connections_Js/* JsConnectionPointType.FLOAT */.zF.FLOAT;
    return [type];
  }
  _expectedInputName(index) {
    return [
      "position" /* POSITION */,
      "amp" /* AMP */,
      "freq" /* FREQ */,
      "offset" /* OFFSET */,
      "octaves" /* OCTAVES */,
      "ampMult" /* AMP_MULT */,
      "freqMult" /* FREQ_MULT */,
      "seed" /* SEED */
    ][index];
  }
  _expectedOutputName(index) {
    return NoiseSimplex_OUTPUT_NAME;
  }
  paramDefaultValue(name) {
    return NoiseSimplex_DefaultValues[name];
  }
  setLines(shadersCollectionController) {
    const position = this.variableForInput(shadersCollectionController, "position" /* POSITION */);
    const amp = this.variableForInput(shadersCollectionController, "amp" /* AMP */);
    const freq = this.variableForInput(shadersCollectionController, "freq" /* FREQ */);
    const offset = this.variableForInput(shadersCollectionController, "offset" /* OFFSET */);
    const octaves = this.variableForInput(shadersCollectionController, "octaves" /* OCTAVES */);
    const ampMult = this.variableForInput(shadersCollectionController, "ampMult" /* AMP_MULT */);
    const freqMult = this.variableForInput(shadersCollectionController, "freqMult" /* FREQ_MULT */);
    const seed = this.variableForInput(shadersCollectionController, "seed" /* SEED */);
    const varName = this.jsVarName(this._expectedOutputName(0));
    const inputType = this._expectedInputTypes()[0];
    const functionName = NoiseSimplex_functionNameByType(inputType);
    if (functionName) {
      const func = Poly/* Poly.namedFunctionsRegister.getFunction */.L.namedFunctionsRegister.getFunction(functionName, this, shadersCollectionController);
      shadersCollectionController.addBodyOrComputed(this, [
        {
          dataType: inputType,
          varName,
          value: func.asString(position, amp, freq, offset, octaves, ampMult, freqMult, seed)
        }
      ]);
      return;
    }
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/js/Normalize.ts





var NormalizeJsNodeInputName = /* @__PURE__ */ ((NormalizeJsNodeInputName2) => {
  NormalizeJsNodeInputName2["VALUE"] = "v";
  return NormalizeJsNodeInputName2;
})(NormalizeJsNodeInputName || {});
const Normalize_DefaultValues = {
  ["v" /* VALUE */]: 1
};
const Normalize_OUTPUT_NAME = "val";
const Normalize_ALLOWED_INPUT_TYPES = [
  connections_Js/* JsConnectionPointType.VECTOR2 */.zF.VECTOR2,
  connections_Js/* JsConnectionPointType.VECTOR3 */.zF.VECTOR3,
  connections_Js/* JsConnectionPointType.VECTOR4 */.zF.VECTOR4
];
function Normalize_functionNameByType(type) {
  switch (type) {
    case connections_Js/* JsConnectionPointType.VECTOR2 */.zF.VECTOR2: {
      return "normalizeVector2";
    }
    case connections_Js/* JsConnectionPointType.VECTOR3 */.zF.VECTOR3: {
      return "normalizeVector3";
    }
    case connections_Js/* JsConnectionPointType.VECTOR4 */.zF.VECTOR4: {
      return "normalizeVector4";
    }
  }
}
class NormalizeJsNode extends js_Base/* ParamlessTypedJsNode */.au {
  static type() {
    return "normalize";
  }
  initializeNode() {
    super.initializeNode();
    this.io.connection_points.set_expected_input_types_function(this._expectedInputTypes.bind(this));
    this.io.connection_points.set_expected_output_types_function(this._expectedOutputTypes.bind(this));
    this.io.connection_points.set_input_name_function(this._expectedInputName.bind(this));
    this.io.connection_points.set_output_name_function(this._expectedOutputName.bind(this));
  }
  setLines(shadersCollectionController) {
    const input = this.variableForInput(shadersCollectionController, this._expectedInputName(0));
    const varName = this.jsVarName(this._expectedOutputName(0));
    const inputType = this._expectedInputTypes()[0];
    const variable = (0,_BaseJsPersistedConfigUtils/* createVariable */.Os)(inputType);
    const tmpVarName = variable ? shadersCollectionController.addVariable(this, variable) : void 0;
    if (!tmpVarName) {
      return;
    }
    const functionName = Normalize_functionNameByType(inputType);
    if (functionName) {
      const func = Poly/* Poly.namedFunctionsRegister.getFunction */.L.namedFunctionsRegister.getFunction(functionName, this, shadersCollectionController);
      shadersCollectionController.addBodyOrComputed(this, [
        { dataType: inputType, varName, value: func.asString(input, tmpVarName) }
      ]);
      return;
    }
  }
  _expectedInputTypes() {
    const firstType = this.io.connection_points.first_input_connection_type();
    const type = firstType && Normalize_ALLOWED_INPUT_TYPES.includes(firstType) ? firstType : connections_Js/* JsConnectionPointType.VECTOR3 */.zF.VECTOR3;
    return [type];
  }
  _expectedOutputTypes() {
    const inputType = this._expectedInputTypes()[0];
    return [inputType];
  }
  _expectedInputName(index) {
    return ["v" /* VALUE */][index];
  }
  _expectedOutputName(index) {
    return Normalize_OUTPUT_NAME;
  }
  paramDefaultValue(name) {
    return Normalize_DefaultValues[name];
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/js/Null.ts




class NullJsParamsConfig extends params_ParamsConfig/* NodeParamsConfig */.yI {
}
const js_Null_ParamsConfig = new NullJsParamsConfig();
class NullJsNode extends js_Base/* TypedJsNode */.xZ {
  constructor() {
    super(...arguments);
    this.paramsConfig = js_Null_ParamsConfig;
  }
  static type() {
    return "null";
  }
  initializeNode() {
    super.initializeNode();
    this.io.connection_points.set_expected_input_types_function(this._expectedInputTypes.bind(this));
    this.io.connection_points.set_expected_output_types_function(this._expectedOutputTypes.bind(this));
    this.io.connection_points.set_input_name_function(this._expectedInputName.bind(this));
    this.io.connection_points.set_output_name_function(this._expectedOutputName.bind(this));
  }
  _expectedInputTypes() {
    const firstType = this.io.connection_points.first_input_connection_type() || connections_Js/* JsConnectionPointType.FLOAT_ARRAY */.zF.FLOAT_ARRAY;
    return [firstType];
  }
  _expectedInputName(index) {
    return "in";
  }
  _expectedOutputName(index) {
    return "out";
  }
  _expectedOutputTypes() {
    const firstType = this._expectedInputTypes()[0];
    return [firstType];
  }
  setLines(shadersCollectionController) {
    const inputValue = this.variableForInput(shadersCollectionController, this._expectedInputName(0));
    const dataType = this._expectedInputTypes()[0];
    const varName = this.jsVarName(this._expectedOutputName(0));
    shadersCollectionController.addBodyOrComputed(this, [
      {
        dataType,
        varName,
        value: inputValue
      }
    ]);
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/js/Object3DLocalToWorld.ts







const Object3DLocalToWorld_CONNECTION_OPTIONS = connections_Js/* JS_CONNECTION_POINT_IN_NODE_DEF */.mX;
const Object3DLocalToWorld_OUTPUT_NAME = "world";
class Object3DLocalToWorldJsParamsConfig extends params_ParamsConfig/* NodeParamsConfig */.yI {
  constructor() {
    super(...arguments);
    /** @param vector3 */
    this.Vector3 = params_ParamsConfig/* ParamConfig.VECTOR3 */.XC.VECTOR3([0, 0, 0]);
  }
}
const Object3DLocalToWorld_ParamsConfig = new Object3DLocalToWorldJsParamsConfig();
class Object3DLocalToWorldJsNode extends js_Base/* TypedJsNode */.xZ {
  constructor() {
    super(...arguments);
    this.paramsConfig = Object3DLocalToWorld_ParamsConfig;
  }
  static type() {
    return "object3DLocalToWorld";
  }
  initializeNode() {
    super.initializeNode();
    this.io.inputs.setNamedInputConnectionPoints([
      new connections_Js/* JsConnectionPoint */.fp(connections_Js/* JsConnectionPointType.OBJECT_3D */.zF.OBJECT_3D, connections_Js/* JsConnectionPointType.OBJECT_3D */.zF.OBJECT_3D, Object3DLocalToWorld_CONNECTION_OPTIONS)
      // new JsConnectionPoint(JsConnectionPointType.VECTOR3, JsConnectionPointType.VECTOR3, CONNECTION_OPTIONS),
    ]);
    this.io.outputs.setNamedOutputConnectionPoints([
      new connections_Js/* JsConnectionPoint */.fp(Object3DLocalToWorld_OUTPUT_NAME, connections_Js/* JsConnectionPointType.VECTOR3 */.zF.VECTOR3)
    ]);
  }
  setLines(shadersCollectionController) {
    const object3D = (0,_BaseObject3D/* inputObject3D */.iv)(this, shadersCollectionController);
    const position = this.variableForInputParam(shadersCollectionController, this.p.Vector3);
    const varName = this.jsVarName(Object3DLocalToWorld_OUTPUT_NAME);
    const variable = (0,_BaseJsPersistedConfigUtils/* createVariable */.Os)(connections_Js/* JsConnectionPointType.VECTOR3 */.zF.VECTOR3);
    const tmpVarName = variable ? shadersCollectionController.addVariable(this, variable) : void 0;
    if (!tmpVarName) {
      return;
    }
    const func = Poly/* Poly.namedFunctionsRegister.getFunction */.L.namedFunctionsRegister.getFunction("object3DLocalToWorld", this, shadersCollectionController);
    shadersCollectionController.addBodyOrComputed(this, [
      { dataType: connections_Js/* JsConnectionPointType.PLANE */.zF.PLANE, varName, value: func.asString(object3D, position, tmpVarName) }
    ]);
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/js/Object3DWorldToLocal.ts







const Object3DWorldToLocal_CONNECTION_OPTIONS = connections_Js/* JS_CONNECTION_POINT_IN_NODE_DEF */.mX;
const Object3DWorldToLocal_OUTPUT_NAME = "local";
class Object3DWorldToLocalJsParamsConfig extends params_ParamsConfig/* NodeParamsConfig */.yI {
  constructor() {
    super(...arguments);
    /** @param vector3 */
    this.Vector3 = params_ParamsConfig/* ParamConfig.VECTOR3 */.XC.VECTOR3([0, 0, 0]);
  }
}
const Object3DWorldToLocal_ParamsConfig = new Object3DWorldToLocalJsParamsConfig();
class Object3DWorldToLocalJsNode extends js_Base/* TypedJsNode */.xZ {
  constructor() {
    super(...arguments);
    this.paramsConfig = Object3DWorldToLocal_ParamsConfig;
  }
  static type() {
    return "object3DWorldToLocal";
  }
  initializeNode() {
    super.initializeNode();
    this.io.inputs.setNamedInputConnectionPoints([
      new connections_Js/* JsConnectionPoint */.fp(connections_Js/* JsConnectionPointType.OBJECT_3D */.zF.OBJECT_3D, connections_Js/* JsConnectionPointType.OBJECT_3D */.zF.OBJECT_3D, Object3DWorldToLocal_CONNECTION_OPTIONS)
      // new JsConnectionPoint(JsConnectionPointType.VECTOR3, JsConnectionPointType.VECTOR3, CONNECTION_OPTIONS),
    ]);
    this.io.outputs.setNamedOutputConnectionPoints([
      new connections_Js/* JsConnectionPoint */.fp(Object3DWorldToLocal_OUTPUT_NAME, connections_Js/* JsConnectionPointType.VECTOR3 */.zF.VECTOR3)
    ]);
  }
  setLines(shadersCollectionController) {
    const object3D = (0,_BaseObject3D/* inputObject3D */.iv)(this, shadersCollectionController);
    const position = this.variableForInputParam(shadersCollectionController, this.p.Vector3);
    const varName = this.jsVarName(Object3DWorldToLocal_OUTPUT_NAME);
    const variable = (0,_BaseJsPersistedConfigUtils/* createVariable */.Os)(connections_Js/* JsConnectionPointType.VECTOR3 */.zF.VECTOR3);
    const tmpVarName = variable ? shadersCollectionController.addVariable(this, variable) : void 0;
    if (!tmpVarName) {
      return;
    }
    const func = Poly/* Poly.namedFunctionsRegister.getFunction */.L.namedFunctionsRegister.getFunction("object3DWorldToLocal", this, shadersCollectionController);
    shadersCollectionController.addBodyOrComputed(this, [
      { dataType: connections_Js/* JsConnectionPointType.PLANE */.zF.PLANE, varName, value: func.asString(object3D, position, tmpVarName) }
    ]);
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/js/Object3DUpdateMatrix.ts






const Object3DUpdateMatrix_CONNECTION_OPTIONS = connections_Js/* JS_CONNECTION_POINT_IN_NODE_DEF */.mX;
class Object3DUpdateMatrixJsParamsConfig extends params_ParamsConfig/* NodeParamsConfig */.yI {
}
const Object3DUpdateMatrix_ParamsConfig = new Object3DUpdateMatrixJsParamsConfig();
class Object3DUpdateMatrixJsNode extends js_Base/* TypedJsNode */.xZ {
  constructor() {
    super(...arguments);
    this.paramsConfig = Object3DUpdateMatrix_ParamsConfig;
  }
  static type() {
    return "object3DUpdateMatrix";
  }
  initializeNode() {
    super.initializeNode();
    this.io.inputs.setNamedInputConnectionPoints([
      new connections_Js/* JsConnectionPoint */.fp(js_Base/* TRIGGER_CONNECTION_NAME */.w6, connections_Js/* JsConnectionPointType.TRIGGER */.zF.TRIGGER, Object3DUpdateMatrix_CONNECTION_OPTIONS),
      new connections_Js/* JsConnectionPoint */.fp(connections_Js/* JsConnectionPointType.OBJECT_3D */.zF.OBJECT_3D, connections_Js/* JsConnectionPointType.OBJECT_3D */.zF.OBJECT_3D, Object3DUpdateMatrix_CONNECTION_OPTIONS)
    ]);
    this.io.outputs.setNamedOutputConnectionPoints([
      new connections_Js/* JsConnectionPoint */.fp(js_Base/* TRIGGER_CONNECTION_NAME */.w6, connections_Js/* JsConnectionPointType.TRIGGER */.zF.TRIGGER)
    ]);
  }
  setTriggerableLines(shadersCollectionController) {
    const object3D = (0,_BaseObject3D/* inputObject3D */.iv)(this, shadersCollectionController);
    const func = Poly/* Poly.namedFunctionsRegister.getFunction */.L.namedFunctionsRegister.getFunction("objectUpdateMatrix", this, shadersCollectionController);
    const bodyLine = func.asString(object3D);
    shadersCollectionController.addTriggerableLines(this, [bodyLine]);
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/js/Object3DUpdateWorldMatrix.ts






const Object3DUpdateWorldMatrix_CONNECTION_OPTIONS = connections_Js/* JS_CONNECTION_POINT_IN_NODE_DEF */.mX;
class Object3DUpdateWorldMatrixJsParamsConfig extends params_ParamsConfig/* NodeParamsConfig */.yI {
  constructor() {
    super(...arguments);
    /** @param updates the matrix of the parents */
    this.updateParents = params_ParamsConfig/* ParamConfig.BOOLEAN */.XC.BOOLEAN(1);
    /** @param updates the matrix of the children */
    this.updateChildren = params_ParamsConfig/* ParamConfig.BOOLEAN */.XC.BOOLEAN(1);
  }
}
const Object3DUpdateWorldMatrix_ParamsConfig = new Object3DUpdateWorldMatrixJsParamsConfig();
class Object3DUpdateWorldMatrixJsNode extends js_Base/* TypedJsNode */.xZ {
  constructor() {
    super(...arguments);
    this.paramsConfig = Object3DUpdateWorldMatrix_ParamsConfig;
  }
  static type() {
    return "object3DUpdateWorldMatrix";
  }
  initializeNode() {
    super.initializeNode();
    this.io.inputs.setNamedInputConnectionPoints([
      new connections_Js/* JsConnectionPoint */.fp(js_Base/* TRIGGER_CONNECTION_NAME */.w6, connections_Js/* JsConnectionPointType.TRIGGER */.zF.TRIGGER, Object3DUpdateWorldMatrix_CONNECTION_OPTIONS),
      new connections_Js/* JsConnectionPoint */.fp(connections_Js/* JsConnectionPointType.OBJECT_3D */.zF.OBJECT_3D, connections_Js/* JsConnectionPointType.OBJECT_3D */.zF.OBJECT_3D, Object3DUpdateWorldMatrix_CONNECTION_OPTIONS)
    ]);
    this.io.outputs.setNamedOutputConnectionPoints([
      new connections_Js/* JsConnectionPoint */.fp(js_Base/* TRIGGER_CONNECTION_NAME */.w6, connections_Js/* JsConnectionPointType.TRIGGER */.zF.TRIGGER)
    ]);
  }
  setTriggerableLines(shadersCollectionController) {
    const object3D = (0,_BaseObject3D/* inputObject3D */.iv)(this, shadersCollectionController);
    const updateParents = this.variableForInputParam(shadersCollectionController, this.p.updateParents);
    const updateChildren = this.variableForInputParam(shadersCollectionController, this.p.updateChildren);
    const func = Poly/* Poly.namedFunctionsRegister.getFunction */.L.namedFunctionsRegister.getFunction(
      "objectUpdateWorldMatrix",
      this,
      shadersCollectionController
    );
    const bodyLine = func.asString(object3D, updateParents, updateChildren);
    shadersCollectionController.addTriggerableLines(this, [bodyLine]);
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/js/ObjectDispatchEvent.ts






const ObjectDispatchEvent_CONNECTION_OPTIONS = connections_Js/* JS_CONNECTION_POINT_IN_NODE_DEF */.mX;
class ObjectDispatchEventJsParamsConfig extends params_ParamsConfig/* NodeParamsConfig */.yI {
  constructor() {
    super(...arguments);
    /** @param event name */
    this.eventName = params_ParamsConfig/* ParamConfig.STRING */.XC.STRING("my-event");
  }
}
const ObjectDispatchEvent_ParamsConfig = new ObjectDispatchEventJsParamsConfig();
class ObjectDispatchEventJsNode extends js_Base/* TypedJsNode */.xZ {
  constructor() {
    super(...arguments);
    this.paramsConfig = ObjectDispatchEvent_ParamsConfig;
  }
  static type() {
    return "objectDispatchEvent";
  }
  initializeNode() {
    super.initializeNode();
    this.io.inputs.setNamedInputConnectionPoints([
      new connections_Js/* JsConnectionPoint */.fp(js_Base/* TRIGGER_CONNECTION_NAME */.w6, connections_Js/* JsConnectionPointType.TRIGGER */.zF.TRIGGER, ObjectDispatchEvent_CONNECTION_OPTIONS),
      new connections_Js/* JsConnectionPoint */.fp(connections_Js/* JsConnectionPointType.OBJECT_3D */.zF.OBJECT_3D, connections_Js/* JsConnectionPointType.OBJECT_3D */.zF.OBJECT_3D, ObjectDispatchEvent_CONNECTION_OPTIONS)
    ]);
    this.io.outputs.setNamedOutputConnectionPoints([
      new connections_Js/* JsConnectionPoint */.fp(js_Base/* TRIGGER_CONNECTION_NAME */.w6, connections_Js/* JsConnectionPointType.TRIGGER */.zF.TRIGGER),
      new connections_Js/* JsConnectionPoint */.fp(connections_Js/* JsConnectionPointType.OBJECT_3D */.zF.OBJECT_3D, connections_Js/* JsConnectionPointType.OBJECT_3D */.zF.OBJECT_3D, ObjectDispatchEvent_CONNECTION_OPTIONS)
    ]);
  }
  setTriggerableLines(shadersCollectionController) {
    const object3D = (0,_BaseObject3D/* inputObject3D */.iv)(this, shadersCollectionController);
    const eventName = this.variableForInputParam(shadersCollectionController, this.p.eventName);
    const func = Poly/* Poly.namedFunctionsRegister.getFunction */.L.namedFunctionsRegister.getFunction("objectDispatchEvent", this, shadersCollectionController);
    const bodyLine = func.asString(object3D, eventName);
    shadersCollectionController.addTriggerableLines(this, [bodyLine]);
  }
}

// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/nodes/js/OnChildAttributeUpdate.ts
var OnChildAttributeUpdate = __webpack_require__(11205);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/nodes/js/OnKey.ts
var OnKey = __webpack_require__(96274);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/nodes/js/OnKeydown.ts
var OnKeydown = __webpack_require__(36332);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/nodes/js/OnKeypress.ts
var OnKeypress = __webpack_require__(69600);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/nodes/js/OnKeyup.ts
var OnKeyup = __webpack_require__(64607);
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/js/OnManualTrigger.ts






class OnManualTriggerJsParamsConfig extends params_ParamsConfig/* NodeParamsConfig */.yI {
  constructor() {
    super(...arguments);
    this.trigger = params_ParamsConfig/* ParamConfig.BUTTON */.XC.BUTTON(null, {
      cook: false,
      callback: (node) => {
        OnManualTriggerJsNode.PARAM_CALLBACK_sendTrigger(node);
      }
    });
  }
}
const OnManualTrigger_ParamsConfig = new OnManualTriggerJsParamsConfig();
class OnManualTriggerJsNode extends js_Base/* TypedJsNode */.xZ {
  constructor() {
    super(...arguments);
    this.paramsConfig = OnManualTrigger_ParamsConfig;
  }
  static type() {
    return Js/* JsType.ON_MANUAL_TRIGGER */.K.ON_MANUAL_TRIGGER;
  }
  isTriggering() {
    return true;
  }
  initializeNode() {
    this.io.outputs.setNamedOutputConnectionPoints([
      new connections_Js/* JsConnectionPoint */.fp(js_Base/* TRIGGER_CONNECTION_NAME */.w6, connections_Js/* JsConnectionPointType.TRIGGER */.zF.TRIGGER)
    ]);
  }
  static PARAM_CALLBACK_sendTrigger(node) {
    node._triggerWithNode();
  }
  setTriggeringLines(shadersCollectionController, triggeredMethods) {
    shadersCollectionController.addTriggeringLines(this, [triggeredMethods], {
      gatherable: false,
      triggeringMethodName: (0,ActorAssemblerUtils/* nodeMethodName */.Bp)(this)
    });
  }
  _triggerWithNode() {
    const functionNode = this.functionNode();
    if (!functionNode) {
      console.warn("no function node found");
      return;
    }
    const actorNode = functionNode;
    if (!actorNode.compilationController.evaluatorGenerator()) {
      console.warn("no evaluator found");
    }
    this.scene().actorsManager.manualTriggerController.runTriggerFromFunctionNode(actorNode, (0,ActorAssemblerUtils/* nodeMethodName */.Bp)(this));
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/js/OnMapboxCameraMove.ts





class OnMapboxCameraMoveJsParamsConfig extends params_ParamsConfig/* NodeParamsConfig */.yI {
}
const OnMapboxCameraMove_ParamsConfig = new OnMapboxCameraMoveJsParamsConfig();
class OnMapboxCameraMoveJsNode extends js_Base/* TypedJsNode */.xZ {
  constructor() {
    super(...arguments);
    this.paramsConfig = OnMapboxCameraMove_ParamsConfig;
  }
  static type() {
    return Js/* JsType.ON_MAPBOX_CAMERA_MOVE */.K.ON_MAPBOX_CAMERA_MOVE;
  }
  isTriggering() {
    return true;
  }
  initializeNode() {
    this.io.outputs.setNamedOutputConnectionPoints([
      new connections_Js/* JsConnectionPoint */.fp(js_Base/* TRIGGER_CONNECTION_NAME */.w6, connections_Js/* JsConnectionPointType.TRIGGER */.zF.TRIGGER)
    ]);
  }
  setTriggeringLines(shadersCollectionController, triggeredMethods) {
    shadersCollectionController.addTriggeringLines(this, [triggeredMethods], {
      gatherable: true
    });
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/js/OnMapboxCameraMoveEnd.ts





class OnMapboxCameraMoveEndJsParamsConfig extends params_ParamsConfig/* NodeParamsConfig */.yI {
}
const OnMapboxCameraMoveEnd_ParamsConfig = new OnMapboxCameraMoveEndJsParamsConfig();
class OnMapboxCameraMoveEndJsNode extends js_Base/* TypedJsNode */.xZ {
  constructor() {
    super(...arguments);
    this.paramsConfig = OnMapboxCameraMoveEnd_ParamsConfig;
  }
  static type() {
    return Js/* JsType.ON_MAPBOX_CAMERA_MOVE_END */.K.ON_MAPBOX_CAMERA_MOVE_END;
  }
  isTriggering() {
    return true;
  }
  initializeNode() {
    this.io.outputs.setNamedOutputConnectionPoints([
      new connections_Js/* JsConnectionPoint */.fp(js_Base/* TRIGGER_CONNECTION_NAME */.w6, connections_Js/* JsConnectionPointType.TRIGGER */.zF.TRIGGER)
    ]);
  }
  setTriggeringLines(shadersCollectionController, triggeredMethods) {
    shadersCollectionController.addTriggeringLines(this, [triggeredMethods], {
      gatherable: true
    });
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/js/OnMapboxCameraMoveStart.ts





class OnMapboxCameraMoveStartJsParamsConfig extends params_ParamsConfig/* NodeParamsConfig */.yI {
}
const OnMapboxCameraMoveStart_ParamsConfig = new OnMapboxCameraMoveStartJsParamsConfig();
class OnMapboxCameraMoveStartJsNode extends js_Base/* TypedJsNode */.xZ {
  constructor() {
    super(...arguments);
    this.paramsConfig = OnMapboxCameraMoveStart_ParamsConfig;
  }
  static type() {
    return Js/* JsType.ON_MAPBOX_CAMERA_MOVE_START */.K.ON_MAPBOX_CAMERA_MOVE_START;
  }
  isTriggering() {
    return true;
  }
  initializeNode() {
    this.io.outputs.setNamedOutputConnectionPoints([
      new connections_Js/* JsConnectionPoint */.fp(js_Base/* TRIGGER_CONNECTION_NAME */.w6, connections_Js/* JsConnectionPointType.TRIGGER */.zF.TRIGGER)
    ]);
  }
  setTriggeringLines(shadersCollectionController, triggeredMethods) {
    shadersCollectionController.addTriggeringLines(this, [triggeredMethods], {
      gatherable: true
    });
  }
}

// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/nodes/js/OnObjectAttributeUpdate.ts
var OnObjectAttributeUpdate = __webpack_require__(38324);
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/js/OnObjectBeforeDelete.ts









const OnObjectBeforeDelete_CONNECTION_OPTIONS = connections_Js/* JS_CONNECTION_POINT_IN_NODE_DEF */.mX;
class OnObjectBeforeDeleteJsParamsConfig extends params_ParamsConfig/* NodeParamsConfig */.yI {
}
const OnObjectBeforeDelete_ParamsConfig = new OnObjectBeforeDeleteJsParamsConfig();
class OnObjectBeforeDeleteJsNode extends js_Base/* TypedJsNode */.xZ {
  constructor() {
    super(...arguments);
    this.paramsConfig = OnObjectBeforeDelete_ParamsConfig;
  }
  static type() {
    return Js/* JsType.ON_OBJECT_BEFORE_DELETE */.K.ON_OBJECT_BEFORE_DELETE;
  }
  isTriggering() {
    return true;
  }
  initializeNode() {
    super.initializeNode();
    this.io.inputs.setNamedInputConnectionPoints([]);
    this.io.outputs.setNamedOutputConnectionPoints([
      new connections_Js/* JsConnectionPoint */.fp(js_Base/* TRIGGER_CONNECTION_NAME */.w6, connections_Js/* JsConnectionPointType.TRIGGER */.zF.TRIGGER, OnObjectBeforeDelete_CONNECTION_OPTIONS)
    ]);
  }
  setTriggeringLines(linesController, triggeredMethods) {
    const object3D = (0,_BaseObject3D/* inputObject3D */.iv)(this, linesController);
    const func = Poly/* Poly.namedFunctionsRegister.getFunction */.L.namedFunctionsRegister.getFunction(
      "objectAddOnBeforeDeleteEventListener",
      this,
      linesController
    );
    const bodyLine = func.asString(object3D, `this`, `this.${(0,ActorAssemblerUtils/* nodeMethodName */.Bp)(this)}.bind(this)`);
    linesController.addDefinitions(this, [
      new JsDefinition/* InitFunctionJsDefinition */.TN(this, linesController, connections_Js/* JsConnectionPointType.OBJECT_3D */.zF.OBJECT_3D, this.path(), bodyLine)
    ]);
    linesController.addTriggeringLines(this, [triggeredMethods], { gatherable: false });
  }
}

// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/nodes/js/OnObjectClick.ts
var OnObjectClick = __webpack_require__(75115);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/nodes/js/_BaseOnObjectPointerEvent.ts
var _BaseOnObjectPointerEvent = __webpack_require__(62700);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/core/event/PointerEventType.ts
var PointerEventType = __webpack_require__(43843);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/scene/utils/actors/rayObjectIntersection/RayObjectIntersectionsClickController.ts
var RayObjectIntersectionsClickController = __webpack_require__(45389);
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/js/OnObjectClickGPU.ts











const OnObjectClickGPU_CONNECTION_OPTIONS = connections_Js/* JS_CONNECTION_POINT_IN_NODE_DEF */.mX;
class OnObjectClickGPUJsParamsConfig extends (0,_BaseOnObjectPointerEvent/* PointerEventConfigParamConfig */.qd)(
  (0,RayObjectIntersectionsClickController/* ClickParamConfig */.s)(_BaseOnObjectPointerEvent/* GPUOnObjectPointerEventJsParamsConfig */.MR)
) {
}
const OnObjectClickGPU_ParamsConfig = new OnObjectClickGPUJsParamsConfig();
class OnObjectClickGPUJsNode extends _BaseOnObjectPointerEvent/* ExtendableOnObjectPointerEventJsNode */.hs {
  constructor() {
    super(...arguments);
    this.paramsConfig = OnObjectClickGPU_ParamsConfig;
  }
  static type() {
    return Js/* JsType.ON_OBJECT_CLICK_GPU */.K.ON_OBJECT_CLICK_GPU;
  }
  isTriggering() {
    return true;
  }
  eventData() {
    return [
      {
        type: PointerEventType/* PointerEventType.pointerdown */.by.pointerdown,
        emitter: this.eventEmitter(),
        jsType: Js/* JsType.ON_OBJECT_POINTERDOWN */.K.ON_OBJECT_POINTERDOWN
      },
      {
        type: PointerEventType/* PointerEventType.pointerup */.by.pointerup,
        emitter: this.eventEmitter(),
        jsType: Js/* JsType.ON_OBJECT_POINTERUP */.K.ON_OBJECT_POINTERUP
      }
    ];
  }
  initializeNode() {
    super.initializeNode();
    this.io.inputs.setNamedInputConnectionPoints([
      new connections_Js/* JsConnectionPoint */.fp(connections_Js/* JsConnectionPointType.OBJECT_3D */.zF.OBJECT_3D, connections_Js/* JsConnectionPointType.OBJECT_3D */.zF.OBJECT_3D, OnObjectClickGPU_CONNECTION_OPTIONS),
      new connections_Js/* JsConnectionPoint */.fp(
        _BaseOnObjectPointerEvent/* OnObjectPointerEventGPUJsNodeInputName.worldPosMaterial */.yD.worldPosMaterial,
        connections_Js/* JsConnectionPointType.MATERIAL */.zF.MATERIAL,
        OnObjectClickGPU_CONNECTION_OPTIONS
      )
    ]);
    this.io.outputs.setNamedOutputConnectionPoints([
      new connections_Js/* JsConnectionPoint */.fp(js_Base/* TRIGGER_CONNECTION_NAME */.w6, connections_Js/* JsConnectionPointType.TRIGGER */.zF.TRIGGER, OnObjectClickGPU_CONNECTION_OPTIONS),
      new connections_Js/* JsConnectionPoint */.fp(
        _BaseOnObjectPointerEvent/* OnObjectPointerEventGPUJsNodeOutputName.distance */.C_.distance,
        connections_Js/* JsConnectionPointType.FLOAT */.zF.FLOAT,
        OnObjectClickGPU_CONNECTION_OPTIONS
      )
    ]);
  }
  setLines(linesController) {
    const usedOutputNames = this.io.outputs.used_output_names();
    if (usedOutputNames.includes(_BaseOnObjectPointerEvent/* OnObjectPointerEventGPUJsNodeOutputName.distance */.C_.distance)) {
      this._addDistanceRef(linesController);
    }
  }
  setTriggeringLines(linesController, triggeredMethods) {
    const object3D = (0,_BaseObject3D/* inputObject3D */.iv)(this, linesController);
    const blockObjectsBehind = this.variableForInputParam(linesController, this.p.blockObjectsBehind);
    const skipIfObjectsInFront = this.variableForInputParam(linesController, this.p.skipIfObjectsInFront);
    const worldPosMaterial = this.variableForInput(
      linesController,
      _BaseOnObjectPointerEvent/* OnObjectPointerEventGPUJsNodeInputName.worldPosMaterial */.yD.worldPosMaterial
    );
    const maxCursorMoveDistance = this.variableForInputParam(linesController, this.p.maxCursorMoveDistance);
    const maxDuration = this.variableForInputParam(linesController, this.p.maxDuration);
    const distanceRef = this._addDistanceRef(linesController);
    const func = Poly/* Poly.namedFunctionsRegister.getFunction */.L.namedFunctionsRegister.getFunction("addObjectToObjectClickCheck", this, linesController);
    const options = {
      priority: {
        blockObjectsBehind,
        skipIfObjectsInFront
      },
      gpu: {
        worldPosMaterial,
        distanceRef: `this.${distanceRef}`
      },
      click: {
        maxCursorMoveDistance,
        maxDuration,
        callback: `this.${(0,ActorAssemblerUtils/* nodeMethodName */.Bp)(this)}.bind(this)`
      },
      config: (0,_BaseOnObjectPointerEvent/* pointerButtonConfig */.AI)(this, linesController)
    };
    const jsonOptions = JSON.stringify(options).replace(/"/g, "");
    const bodyLine = func.asString(object3D, `this`, jsonOptions);
    linesController.addDefinitions(this, [
      new JsDefinition/* InitFunctionJsDefinition */.TN(this, linesController, connections_Js/* JsConnectionPointType.OBJECT_3D */.zF.OBJECT_3D, this.path(), bodyLine)
    ]);
    linesController.addTriggeringLines(this, [triggeredMethods], { gatherable: true });
  }
  _addDistanceRef(linesController) {
    const outDistance = this.jsVarName(_BaseOnObjectPointerEvent/* OnObjectPointerEventGPUJsNodeOutputName.distance */.C_.distance);
    linesController.addDefinitions(this, [
      new JsDefinition/* RefJsDefinition */.Z(this, linesController, connections_Js/* JsConnectionPointType.FLOAT */.zF.FLOAT, outDistance, `-1`)
    ]);
    return outDistance;
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/js/OnObjectContextMenu.ts










const OnObjectContextMenu_CONNECTION_OPTIONS = connections_Js/* JS_CONNECTION_POINT_IN_NODE_DEF */.mX;
class OnObjectContextMenuJsNode extends _BaseOnObjectPointerEvent/* BaseOnObjectPointerEventJsNode */.Uz {
  static type() {
    return Js/* JsType.ON_OBJECT_CONTEXT_MENU */.K.ON_OBJECT_CONTEXT_MENU;
  }
  isTriggering() {
    return true;
  }
  eventData() {
    return {
      type: PointerEventType/* PointerEventType.contextmenu */.by.contextmenu,
      emitter: this.eventEmitter(),
      jsType: Js/* JsType.ON_OBJECT_CONTEXT_MENU */.K.ON_OBJECT_CONTEXT_MENU
    };
  }
  initializeNode() {
    super.initializeNode();
    this.io.inputs.setNamedInputConnectionPoints([
      new connections_Js/* JsConnectionPoint */.fp(connections_Js/* JsConnectionPointType.OBJECT_3D */.zF.OBJECT_3D, connections_Js/* JsConnectionPointType.OBJECT_3D */.zF.OBJECT_3D, OnObjectContextMenu_CONNECTION_OPTIONS)
    ]);
    this.io.outputs.setNamedOutputConnectionPoints([
      new connections_Js/* JsConnectionPoint */.fp(js_Base/* TRIGGER_CONNECTION_NAME */.w6, connections_Js/* JsConnectionPointType.TRIGGER */.zF.TRIGGER, OnObjectContextMenu_CONNECTION_OPTIONS),
      new connections_Js/* JsConnectionPoint */.fp(
        connections_Js/* JsConnectionPointType.INTERSECTION */.zF.INTERSECTION,
        connections_Js/* JsConnectionPointType.INTERSECTION */.zF.INTERSECTION,
        OnObjectContextMenu_CONNECTION_OPTIONS
      )
    ]);
  }
  setLines(linesController) {
    const usedOutputNames = this.io.outputs.used_output_names();
    if (usedOutputNames.includes(connections_Js/* JsConnectionPointType.INTERSECTION */.zF.INTERSECTION)) {
      this._addIntersectionRef(linesController);
    }
  }
  setTriggeringLines(linesController, triggeredMethods) {
    const object3D = (0,_BaseObject3D/* inputObject3D */.iv)(this, linesController);
    const blockObjectsBehind = this.variableForInputParam(linesController, this.p.blockObjectsBehind);
    const skipIfObjectsInFront = this.variableForInputParam(linesController, this.p.skipIfObjectsInFront);
    const traverseChildren = this.variableForInputParam(linesController, this.p.traverseChildren);
    const lineThreshold = this.variableForInputParam(linesController, this.p.lineThreshold);
    const pointsThreshold = this.variableForInputParam(linesController, this.p.pointsThreshold);
    const intersectionRef = this._addIntersectionRef(linesController);
    const func = Poly/* Poly.namedFunctionsRegister.getFunction */.L.namedFunctionsRegister.getFunction(
      "addObjectToObjectContextmenuCheck",
      this,
      linesController
    );
    const options = {
      priority: {
        blockObjectsBehind,
        skipIfObjectsInFront
      },
      cpu: {
        traverseChildren,
        pointsThreshold,
        lineThreshold,
        intersectionRef: `this.${intersectionRef}`
      },
      contextmenu: {
        callback: `this.${(0,ActorAssemblerUtils/* nodeMethodName */.Bp)(this)}.bind(this)`
      }
    };
    const jsonOptions = JSON.stringify(options).replace(/"/g, "");
    const bodyLine = func.asString(object3D, `this`, jsonOptions);
    linesController.addDefinitions(this, [
      new JsDefinition/* InitFunctionJsDefinition */.TN(this, linesController, connections_Js/* JsConnectionPointType.OBJECT_3D */.zF.OBJECT_3D, this.path(), bodyLine)
    ]);
    linesController.addTriggeringLines(this, [triggeredMethods], { gatherable: true });
  }
  _addIntersectionRef(shadersCollectionController) {
    const outIntersection = this.jsVarName(connections_Js/* JsConnectionPointType.INTERSECTION */.zF.INTERSECTION);
    shadersCollectionController.addDefinitions(this, [
      new JsDefinition/* RefJsDefinition */.Z(
        this,
        shadersCollectionController,
        connections_Js/* JsConnectionPointType.INTERSECTION */.zF.INTERSECTION,
        outIntersection,
        `null`
      )
    ]);
    return outIntersection;
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/js/OnObjectContextMenuGPU.ts










const OnObjectContextMenuGPU_CONNECTION_OPTIONS = connections_Js/* JS_CONNECTION_POINT_IN_NODE_DEF */.mX;
class OnObjectContextMenuGPUJsNode extends _BaseOnObjectPointerEvent/* BaseOnObjectPointerGPUEventJsNode */.eu {
  static type() {
    return Js/* JsType.ON_OBJECT_CONTEXT_MENU_GPU */.K.ON_OBJECT_CONTEXT_MENU_GPU;
  }
  eventData() {
    return {
      type: PointerEventType/* PointerEventType.contextmenu */.by.contextmenu,
      emitter: this.eventEmitter(),
      jsType: Js/* JsType.ON_OBJECT_CONTEXT_MENU */.K.ON_OBJECT_CONTEXT_MENU
    };
  }
  initializeNode() {
    super.initializeNode();
    this.io.inputs.setNamedInputConnectionPoints([
      new connections_Js/* JsConnectionPoint */.fp(connections_Js/* JsConnectionPointType.OBJECT_3D */.zF.OBJECT_3D, connections_Js/* JsConnectionPointType.OBJECT_3D */.zF.OBJECT_3D, OnObjectContextMenuGPU_CONNECTION_OPTIONS),
      new connections_Js/* JsConnectionPoint */.fp(
        _BaseOnObjectPointerEvent/* OnObjectPointerEventGPUJsNodeInputName.worldPosMaterial */.yD.worldPosMaterial,
        connections_Js/* JsConnectionPointType.MATERIAL */.zF.MATERIAL,
        OnObjectContextMenuGPU_CONNECTION_OPTIONS
      )
    ]);
    this.io.outputs.setNamedOutputConnectionPoints([
      new connections_Js/* JsConnectionPoint */.fp(js_Base/* TRIGGER_CONNECTION_NAME */.w6, connections_Js/* JsConnectionPointType.TRIGGER */.zF.TRIGGER, OnObjectContextMenuGPU_CONNECTION_OPTIONS),
      new connections_Js/* JsConnectionPoint */.fp(
        _BaseOnObjectPointerEvent/* OnObjectPointerEventGPUJsNodeOutputName.distance */.C_.distance,
        connections_Js/* JsConnectionPointType.FLOAT */.zF.FLOAT,
        OnObjectContextMenuGPU_CONNECTION_OPTIONS
      )
    ]);
  }
  setLines(linesController) {
    const usedOutputNames = this.io.outputs.used_output_names();
    if (usedOutputNames.includes(_BaseOnObjectPointerEvent/* OnObjectPointerEventGPUJsNodeOutputName.distance */.C_.distance)) {
      this._addDistanceRef(linesController);
    }
  }
  setTriggeringLines(linesController, triggeredMethods) {
    const object3D = (0,_BaseObject3D/* inputObject3D */.iv)(this, linesController);
    const blockObjectsBehind = this.variableForInputParam(linesController, this.p.blockObjectsBehind);
    const skipIfObjectsInFront = this.variableForInputParam(linesController, this.p.skipIfObjectsInFront);
    const worldPosMaterial = this.variableForInput(
      linesController,
      _BaseOnObjectPointerEvent/* OnObjectPointerEventGPUJsNodeInputName.worldPosMaterial */.yD.worldPosMaterial
    );
    const distanceRef = this._addDistanceRef(linesController);
    const func = Poly/* Poly.namedFunctionsRegister.getFunction */.L.namedFunctionsRegister.getFunction(
      "addObjectToObjectContextmenuCheck",
      this,
      linesController
    );
    const options = {
      priority: {
        blockObjectsBehind,
        skipIfObjectsInFront
      },
      gpu: {
        worldPosMaterial,
        distanceRef: `this.${distanceRef}`
      },
      contextmenu: {
        callback: `this.${(0,ActorAssemblerUtils/* nodeMethodName */.Bp)(this)}.bind(this)`
      }
    };
    const jsonOptions = JSON.stringify(options).replace(/"/g, "");
    const bodyLine = func.asString(object3D, `this`, jsonOptions);
    linesController.addDefinitions(this, [
      new JsDefinition/* InitFunctionJsDefinition */.TN(this, linesController, connections_Js/* JsConnectionPointType.OBJECT_3D */.zF.OBJECT_3D, this.path(), bodyLine)
    ]);
    linesController.addTriggeringLines(this, [triggeredMethods], { gatherable: true });
  }
  _addDistanceRef(linesController) {
    const outDistance = this.jsVarName(_BaseOnObjectPointerEvent/* OnObjectPointerEventGPUJsNodeOutputName.distance */.C_.distance);
    linesController.addDefinitions(this, [
      new JsDefinition/* RefJsDefinition */.Z(this, linesController, connections_Js/* JsConnectionPointType.FLOAT */.zF.FLOAT, outDistance, `-1`)
    ]);
    return outDistance;
  }
}

// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/nodes/js/OnObjectDispatchEvent.ts
var OnObjectDispatchEvent = __webpack_require__(42329);
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/js/OnObjectHover.ts










const OnObjectHover_CONNECTION_OPTIONS = connections_Js/* JS_CONNECTION_POINT_IN_NODE_DEF */.mX;
var OnObjectHoverJsNodeOutputName = /* @__PURE__ */ ((OnObjectHoverJsNodeOutputName2) => {
  OnObjectHoverJsNodeOutputName2["hovered"] = "hovered";
  return OnObjectHoverJsNodeOutputName2;
})(OnObjectHoverJsNodeOutputName || {});
class OnObjectHoverJsNode extends _BaseOnObjectPointerEvent/* BaseOnObjectPointerEventJsNode */.Uz {
  static type() {
    return Js/* JsType.ON_OBJECT_HOVER */.K.ON_OBJECT_HOVER;
  }
  isTriggering() {
    return true;
  }
  eventData() {
    return {
      type: PointerEventType/* PointerEventType.pointermove */.by.pointermove,
      emitter: this.eventEmitter(),
      jsType: Js/* JsType.ON_OBJECT_HOVER */.K.ON_OBJECT_HOVER
    };
  }
  initializeNode() {
    super.initializeNode();
    this.io.inputs.setNamedInputConnectionPoints([
      new connections_Js/* JsConnectionPoint */.fp(connections_Js/* JsConnectionPointType.OBJECT_3D */.zF.OBJECT_3D, connections_Js/* JsConnectionPointType.OBJECT_3D */.zF.OBJECT_3D, OnObjectHover_CONNECTION_OPTIONS)
    ]);
    this.io.outputs.setNamedOutputConnectionPoints([
      new connections_Js/* JsConnectionPoint */.fp(js_Base/* TRIGGER_CONNECTION_NAME */.w6, connections_Js/* JsConnectionPointType.TRIGGER */.zF.TRIGGER, OnObjectHover_CONNECTION_OPTIONS),
      new connections_Js/* JsConnectionPoint */.fp(
        "hovered" /* hovered */,
        connections_Js/* JsConnectionPointType.BOOLEAN */.zF.BOOLEAN,
        OnObjectHover_CONNECTION_OPTIONS
      ),
      new connections_Js/* JsConnectionPoint */.fp(
        connections_Js/* JsConnectionPointType.INTERSECTION */.zF.INTERSECTION,
        connections_Js/* JsConnectionPointType.INTERSECTION */.zF.INTERSECTION,
        OnObjectHover_CONNECTION_OPTIONS
      )
    ]);
  }
  setLines(linesController) {
    const usedOutputNames = this.io.outputs.used_output_names();
    if (usedOutputNames.includes("hovered" /* hovered */)) {
      this._addHoveredRef(linesController);
    }
    if (usedOutputNames.includes(connections_Js/* JsConnectionPointType.INTERSECTION */.zF.INTERSECTION)) {
      this._addIntersectionRef(linesController);
      if (!usedOutputNames.includes(connections_Js/* JsConnectionPointType.TRIGGER */.zF.TRIGGER)) {
        this.setTriggeringLines(linesController, "");
      }
    }
  }
  setTriggeringLines(linesController, triggeredMethods) {
    const object3D = (0,_BaseObject3D/* inputObject3D */.iv)(this, linesController);
    const blockObjectsBehind = this.variableForInputParam(linesController, this.p.blockObjectsBehind);
    const skipIfObjectsInFront = this.variableForInputParam(linesController, this.p.skipIfObjectsInFront);
    const traverseChildren = this.variableForInputParam(linesController, this.p.traverseChildren);
    const lineThreshold = this.variableForInputParam(linesController, this.p.lineThreshold);
    const pointsThreshold = this.variableForInputParam(linesController, this.p.pointsThreshold);
    const intersectionRef = this._addIntersectionRef(linesController);
    const hoveredStateRef = this._addHoveredRef(linesController);
    const func = Poly/* Poly.namedFunctionsRegister.getFunction */.L.namedFunctionsRegister.getFunction("addObjectToObjectHoveredCheck", this, linesController);
    const options = {
      priority: {
        blockObjectsBehind,
        skipIfObjectsInFront
      },
      cpu: {
        traverseChildren,
        pointsThreshold,
        lineThreshold,
        intersectionRef: `this.${intersectionRef}`
      },
      hover: {
        hoveredStateRef: `this.${hoveredStateRef}`,
        onHoveredStateChange: `this.${(0,ActorAssemblerUtils/* nodeMethodName */.Bp)(this)}.bind(this)`
      }
    };
    const jsonOptions = JSON.stringify(options).replace(/"/g, "");
    const bodyLine = func.asString(object3D, `this`, jsonOptions);
    linesController.addDefinitions(this, [
      new JsDefinition/* InitFunctionJsDefinition */.TN(this, linesController, connections_Js/* JsConnectionPointType.OBJECT_3D */.zF.OBJECT_3D, this.path(), bodyLine)
    ]);
    linesController.addTriggeringLines(this, [triggeredMethods], { gatherable: true });
  }
  // override setTriggeringLines(linesController: JsLinesCollectionController, triggeredMethods: string) {
  // 	const object3D = inputObject3D(this, linesController);
  // 	const traverseChildren = this.variableForInputParam(linesController, this.p.traverseChildren);
  // 	const lineThreshold = this.variableForInputParam(linesController, this.p.lineThreshold);
  // 	const pointsThreshold = this.variableForInputParam(linesController, this.p.pointsThreshold);
  // 	const newHovered = `newHovered`;
  // 	const currentHovered = `currentHovered`;
  // 	const outIntersection = this._addIntersectionRef(linesController);
  // 	const outHovered = this._addHoveredRef(linesController);
  // 	const _getObjectHoveredState_ = () => {
  // 		const func = Poly.namedFunctionsRegister.getFunction('getObjectHoveredState', this, linesController);
  // 		return func.asString(object3D, traverseChildren, lineThreshold, pointsThreshold, `this.${outIntersection}`);
  // 	};
  // 	const _getObjectHoveredState = _getObjectHoveredState_();
  // 	const bodyLines = [
  // 		`const ${newHovered} = ${_getObjectHoveredState};`,
  // 		`const ${currentHovered} = this.${outHovered}.value;`,
  // 		`this.${outHovered}.value = ${newHovered};`,
  // 		`if( ${newHovered} != ${currentHovered} ){`,
  // 		`${triggeredMethods}`,
  // 		`}`,
  // 	];
  // 	linesController.addTriggeringLines(this, bodyLines, {
  // 		gatherable: true,
  // 		triggeringMethodName: 'onPointermove',
  // 	});
  // }
  _addIntersectionRef(linesController) {
    const outIntersection = this.jsVarName(connections_Js/* JsConnectionPointType.INTERSECTION */.zF.INTERSECTION);
    linesController.addDefinitions(this, [
      new JsDefinition/* RefJsDefinition */.Z(this, linesController, connections_Js/* JsConnectionPointType.INTERSECTION */.zF.INTERSECTION, outIntersection, `null`)
    ]);
    return outIntersection;
  }
  _addHoveredRef(linesController) {
    const outHovered = this.jsVarName("hovered" /* hovered */);
    linesController.addDefinitions(this, [
      new JsDefinition/* RefJsDefinition */.Z(this, linesController, connections_Js/* JsConnectionPointType.BOOLEAN */.zF.BOOLEAN, outHovered, `false`)
    ]);
    return outHovered;
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/js/OnObjectHoverGPU.ts










const OnObjectHoverGPU_CONNECTION_OPTIONS = connections_Js/* JS_CONNECTION_POINT_IN_NODE_DEF */.mX;
var OnObjectHoverGPUJsNodeOutputName = /* @__PURE__ */ ((OnObjectHoverGPUJsNodeOutputName2) => {
  OnObjectHoverGPUJsNodeOutputName2["hovered"] = "hovered";
  return OnObjectHoverGPUJsNodeOutputName2;
})(OnObjectHoverGPUJsNodeOutputName || {});
class OnObjectHoverGPUJsNode extends _BaseOnObjectPointerEvent/* BaseOnObjectPointerGPUEventJsNode */.eu {
  static type() {
    return Js/* JsType.ON_OBJECT_HOVER_GPU */.K.ON_OBJECT_HOVER_GPU;
  }
  isTriggering() {
    return true;
  }
  eventData() {
    return {
      type: PointerEventType/* PointerEventType.pointermove */.by.pointermove,
      emitter: this.eventEmitter(),
      jsType: Js/* JsType.ON_OBJECT_HOVER */.K.ON_OBJECT_HOVER
    };
  }
  initializeNode() {
    super.initializeNode();
    this.io.inputs.setNamedInputConnectionPoints([
      new connections_Js/* JsConnectionPoint */.fp(connections_Js/* JsConnectionPointType.OBJECT_3D */.zF.OBJECT_3D, connections_Js/* JsConnectionPointType.OBJECT_3D */.zF.OBJECT_3D, OnObjectHoverGPU_CONNECTION_OPTIONS),
      new connections_Js/* JsConnectionPoint */.fp(
        _BaseOnObjectPointerEvent/* OnObjectPointerEventGPUJsNodeInputName.worldPosMaterial */.yD.worldPosMaterial,
        connections_Js/* JsConnectionPointType.MATERIAL */.zF.MATERIAL,
        OnObjectHoverGPU_CONNECTION_OPTIONS
      )
    ]);
    this.io.outputs.setNamedOutputConnectionPoints([
      new connections_Js/* JsConnectionPoint */.fp(js_Base/* TRIGGER_CONNECTION_NAME */.w6, connections_Js/* JsConnectionPointType.TRIGGER */.zF.TRIGGER, OnObjectHoverGPU_CONNECTION_OPTIONS),
      new connections_Js/* JsConnectionPoint */.fp(
        "hovered" /* hovered */,
        connections_Js/* JsConnectionPointType.BOOLEAN */.zF.BOOLEAN,
        OnObjectHoverGPU_CONNECTION_OPTIONS
      ),
      new connections_Js/* JsConnectionPoint */.fp(
        _BaseOnObjectPointerEvent/* OnObjectPointerEventGPUJsNodeOutputName.distance */.C_.distance,
        connections_Js/* JsConnectionPointType.FLOAT */.zF.FLOAT,
        OnObjectHoverGPU_CONNECTION_OPTIONS
      )
    ]);
  }
  setLines(linesController) {
    const usedOutputNames = this.io.outputs.used_output_names();
    if (usedOutputNames.includes("hovered" /* hovered */)) {
      this._addHoveredRef(linesController);
    }
    if (usedOutputNames.includes(_BaseOnObjectPointerEvent/* OnObjectPointerEventGPUJsNodeOutputName.distance */.C_.distance)) {
      this._addDistanceRef(linesController);
    }
  }
  setTriggeringLines(linesController, triggeredMethods) {
    const object3D = (0,_BaseObject3D/* inputObject3D */.iv)(this, linesController);
    const blockObjectsBehind = this.variableForInputParam(linesController, this.p.blockObjectsBehind);
    const skipIfObjectsInFront = this.variableForInputParam(linesController, this.p.skipIfObjectsInFront);
    const worldPosMaterial = this.variableForInput(
      linesController,
      _BaseOnObjectPointerEvent/* OnObjectPointerEventGPUJsNodeInputName.worldPosMaterial */.yD.worldPosMaterial
    );
    const distanceRef = this._addDistanceRef(linesController);
    const hoveredStateRef = this._addHoveredRef(linesController);
    const func = Poly/* Poly.namedFunctionsRegister.getFunction */.L.namedFunctionsRegister.getFunction("addObjectToObjectHoveredCheck", this, linesController);
    const options = {
      priority: {
        blockObjectsBehind,
        skipIfObjectsInFront
      },
      gpu: {
        worldPosMaterial,
        distanceRef: `this.${distanceRef}`
      },
      hover: {
        hoveredStateRef: `this.${hoveredStateRef}`,
        onHoveredStateChange: `this.${(0,ActorAssemblerUtils/* nodeMethodName */.Bp)(this)}.bind(this)`
      }
    };
    const jsonOptions = JSON.stringify(options).replace(/"/g, "");
    const bodyLine = func.asString(object3D, `this`, jsonOptions);
    linesController.addDefinitions(this, [
      new JsDefinition/* InitFunctionJsDefinition */.TN(this, linesController, connections_Js/* JsConnectionPointType.OBJECT_3D */.zF.OBJECT_3D, this.path(), bodyLine)
    ]);
    linesController.addTriggeringLines(this, [triggeredMethods], { gatherable: true });
  }
  _addDistanceRef(linesController) {
    const outDistance = this.jsVarName(_BaseOnObjectPointerEvent/* OnObjectPointerEventGPUJsNodeOutputName.distance */.C_.distance);
    linesController.addDefinitions(this, [
      new JsDefinition/* RefJsDefinition */.Z(this, linesController, connections_Js/* JsConnectionPointType.FLOAT */.zF.FLOAT, outDistance, `-1`)
    ]);
    return outDistance;
  }
  _addHoveredRef(linesController) {
    const outHovered = this.jsVarName("hovered" /* hovered */);
    linesController.addDefinitions(this, [
      new JsDefinition/* RefJsDefinition */.Z(this, linesController, connections_Js/* JsConnectionPointType.BOOLEAN */.zF.BOOLEAN, outHovered, `false`)
    ]);
    return outHovered;
  }
}

// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/scene/utils/actors/rayObjectIntersection/RayObjectIntersectionsLongPressController.ts
var RayObjectIntersectionsLongPressController = __webpack_require__(70916);
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/js/OnObjectLongPress.ts











const OnObjectLongPress_CONNECTION_OPTIONS = connections_Js/* JS_CONNECTION_POINT_IN_NODE_DEF */.mX;
class OnObjectLongPressJsParamsConfig extends (0,_BaseOnObjectPointerEvent/* PointerEventConfigParamConfig */.qd)(
  (0,RayObjectIntersectionsLongPressController/* LongPressParamConfig */.Un)(_BaseOnObjectPointerEvent/* CPUOnObjectPointerEventJsParamsConfig */.hq)
) {
}
const OnObjectLongPress_ParamsConfig = new OnObjectLongPressJsParamsConfig();
class OnObjectLongPressJsNode extends _BaseOnObjectPointerEvent/* ExtendableOnObjectPointerEventJsNode */.hs {
  constructor() {
    super(...arguments);
    this.paramsConfig = OnObjectLongPress_ParamsConfig;
  }
  static type() {
    return Js/* JsType.ON_OBJECT_LONG_PRESS */.K.ON_OBJECT_LONG_PRESS;
  }
  eventData() {
    return [
      {
        type: PointerEventType/* PointerEventType.pointerdown */.by.pointerdown,
        emitter: this.eventEmitter(),
        jsType: Js/* JsType.ON_OBJECT_POINTERDOWN */.K.ON_OBJECT_POINTERDOWN
      },
      // pointerup is currently needed to update the pointerEventsController cursor
      {
        type: PointerEventType/* PointerEventType.pointerup */.by.pointerup,
        emitter: this.eventEmitter(),
        jsType: Js/* JsType.ON_OBJECT_POINTERUP */.K.ON_OBJECT_POINTERUP
      }
    ];
  }
  initializeNode() {
    super.initializeNode();
    this.io.outputs.setNamedOutputConnectionPoints([
      new connections_Js/* JsConnectionPoint */.fp(js_Base/* TRIGGER_CONNECTION_NAME */.w6, connections_Js/* JsConnectionPointType.TRIGGER */.zF.TRIGGER, OnObjectLongPress_CONNECTION_OPTIONS),
      new connections_Js/* JsConnectionPoint */.fp(
        connections_Js/* JsConnectionPointType.INTERSECTION */.zF.INTERSECTION,
        connections_Js/* JsConnectionPointType.INTERSECTION */.zF.INTERSECTION,
        OnObjectLongPress_CONNECTION_OPTIONS
      )
    ]);
    this.io.connection_points.spare_params.setInputlessParamNames(["pointsThreshold", "lineThreshold", "element"]);
  }
  _additionalInputs() {
    return [new connections_Js/* JsConnectionPoint */.fp("duration", connections_Js/* JsConnectionPointType.INT */.zF.INT, OnObjectLongPress_CONNECTION_OPTIONS)];
  }
  setLines(linesController) {
    const usedOutputNames = this.io.outputs.used_output_names();
    if (usedOutputNames.includes(connections_Js/* JsConnectionPointType.INTERSECTION */.zF.INTERSECTION)) {
      this._addIntersectionRef(linesController);
    }
  }
  setTriggeringLines(linesController, triggeredMethods) {
    const object3D = (0,_BaseObject3D/* inputObject3D */.iv)(this, linesController);
    const blockObjectsBehind = this.variableForInputParam(linesController, this.p.blockObjectsBehind);
    const skipIfObjectsInFront = this.variableForInputParam(linesController, this.p.skipIfObjectsInFront);
    const traverseChildren = this.variableForInputParam(linesController, this.p.traverseChildren);
    const lineThreshold = this.variableForInputParam(linesController, this.p.lineThreshold);
    const pointsThreshold = this.variableForInputParam(linesController, this.p.pointsThreshold);
    const duration = this.variableForInputParam(linesController, this.p.duration);
    const maxCursorMoveDistance = this.variableForInputParam(linesController, this.p.maxCursorMoveDistance);
    const intersectionRef = this._addIntersectionRef(linesController);
    const func = Poly/* Poly.namedFunctionsRegister.getFunction */.L.namedFunctionsRegister.getFunction("addObjectToObjectLongPressCheck", this, linesController);
    const options = {
      priority: {
        blockObjectsBehind,
        skipIfObjectsInFront
      },
      cpu: {
        traverseChildren,
        pointsThreshold,
        lineThreshold,
        intersectionRef: `this.${intersectionRef}`
      },
      longPress: {
        duration,
        maxCursorMoveDistance,
        callback: `this.${(0,ActorAssemblerUtils/* nodeMethodName */.Bp)(this)}.bind(this)`
      },
      config: (0,_BaseOnObjectPointerEvent/* pointerButtonConfig */.AI)(this, linesController)
    };
    const jsonOptions = JSON.stringify(options).replace(/"/g, "");
    const bodyLine = func.asString(object3D, `this`, jsonOptions);
    linesController.addDefinitions(this, [
      new JsDefinition/* InitFunctionJsDefinition */.TN(this, linesController, connections_Js/* JsConnectionPointType.OBJECT_3D */.zF.OBJECT_3D, this.path(), bodyLine)
    ]);
    linesController.addTriggeringLines(this, [triggeredMethods], { gatherable: true });
  }
  _addIntersectionRef(linesController) {
    const outIntersection = this.jsVarName(connections_Js/* JsConnectionPointType.INTERSECTION */.zF.INTERSECTION);
    linesController.addDefinitions(this, [
      new JsDefinition/* RefJsDefinition */.Z(this, linesController, connections_Js/* JsConnectionPointType.INTERSECTION */.zF.INTERSECTION, outIntersection, `null`)
    ]);
    return outIntersection;
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/js/OnObjectLongPressGPU.ts











const OnObjectLongPressGPU_CONNECTION_OPTIONS = connections_Js/* JS_CONNECTION_POINT_IN_NODE_DEF */.mX;
class OnObjectLongPressGPUJsParamsConfig extends (0,_BaseOnObjectPointerEvent/* PointerEventConfigParamConfig */.qd)(
  (0,RayObjectIntersectionsLongPressController/* LongPressParamConfig */.Un)(_BaseOnObjectPointerEvent/* GPUOnObjectPointerEventJsParamsConfig */.MR)
) {
}
const OnObjectLongPressGPU_ParamsConfig = new OnObjectLongPressGPUJsParamsConfig();
class OnObjectLongPressGPUJsNode extends _BaseOnObjectPointerEvent/* ExtendableOnObjectPointerEventJsNode */.hs {
  constructor() {
    super(...arguments);
    this.paramsConfig = OnObjectLongPressGPU_ParamsConfig;
  }
  static type() {
    return Js/* JsType.ON_OBJECT_LONG_PRESS_GPU */.K.ON_OBJECT_LONG_PRESS_GPU;
  }
  isTriggering() {
    return true;
  }
  eventData() {
    return [
      {
        type: PointerEventType/* PointerEventType.pointerdown */.by.pointerdown,
        emitter: this.eventEmitter(),
        jsType: Js/* JsType.ON_OBJECT_POINTERDOWN */.K.ON_OBJECT_POINTERDOWN
      },
      // pointerup is currently needed to update the pointerEventsController cursor
      {
        type: PointerEventType/* PointerEventType.pointerup */.by.pointerup,
        emitter: this.eventEmitter(),
        jsType: Js/* JsType.ON_OBJECT_POINTERUP */.K.ON_OBJECT_POINTERUP
      }
    ];
  }
  initializeNode() {
    super.initializeNode();
    this.io.inputs.setNamedInputConnectionPoints([
      new connections_Js/* JsConnectionPoint */.fp(connections_Js/* JsConnectionPointType.OBJECT_3D */.zF.OBJECT_3D, connections_Js/* JsConnectionPointType.OBJECT_3D */.zF.OBJECT_3D, OnObjectLongPressGPU_CONNECTION_OPTIONS),
      new connections_Js/* JsConnectionPoint */.fp(
        _BaseOnObjectPointerEvent/* OnObjectPointerEventGPUJsNodeInputName.worldPosMaterial */.yD.worldPosMaterial,
        connections_Js/* JsConnectionPointType.MATERIAL */.zF.MATERIAL,
        OnObjectLongPressGPU_CONNECTION_OPTIONS
      )
    ]);
    this.io.outputs.setNamedOutputConnectionPoints([
      new connections_Js/* JsConnectionPoint */.fp(js_Base/* TRIGGER_CONNECTION_NAME */.w6, connections_Js/* JsConnectionPointType.TRIGGER */.zF.TRIGGER, OnObjectLongPressGPU_CONNECTION_OPTIONS),
      new connections_Js/* JsConnectionPoint */.fp(
        _BaseOnObjectPointerEvent/* OnObjectPointerEventGPUJsNodeOutputName.distance */.C_.distance,
        connections_Js/* JsConnectionPointType.FLOAT */.zF.FLOAT,
        OnObjectLongPressGPU_CONNECTION_OPTIONS
      )
    ]);
  }
  setLines(linesController) {
    const usedOutputNames = this.io.outputs.used_output_names();
    if (usedOutputNames.includes(_BaseOnObjectPointerEvent/* OnObjectPointerEventGPUJsNodeOutputName.distance */.C_.distance)) {
      this._addDistanceRef(linesController);
    }
  }
  setTriggeringLines(linesController, triggeredMethods) {
    const object3D = (0,_BaseObject3D/* inputObject3D */.iv)(this, linesController);
    const blockObjectsBehind = this.variableForInputParam(linesController, this.p.blockObjectsBehind);
    const skipIfObjectsInFront = this.variableForInputParam(linesController, this.p.skipIfObjectsInFront);
    const worldPosMaterial = this.variableForInput(
      linesController,
      _BaseOnObjectPointerEvent/* OnObjectPointerEventGPUJsNodeInputName.worldPosMaterial */.yD.worldPosMaterial
    );
    const distanceRef = this._addDistanceRef(linesController);
    const duration = this.variableForInputParam(linesController, this.p.duration);
    const maxCursorMoveDistance = this.variableForInputParam(linesController, this.p.maxCursorMoveDistance);
    const func = Poly/* Poly.namedFunctionsRegister.getFunction */.L.namedFunctionsRegister.getFunction("addObjectToObjectLongPressCheck", this, linesController);
    const options = {
      priority: {
        blockObjectsBehind,
        skipIfObjectsInFront
      },
      gpu: {
        worldPosMaterial,
        distanceRef: `this.${distanceRef}`
      },
      longPress: {
        duration,
        maxCursorMoveDistance,
        callback: `this.${(0,ActorAssemblerUtils/* nodeMethodName */.Bp)(this)}.bind(this)`
      },
      config: (0,_BaseOnObjectPointerEvent/* pointerButtonConfig */.AI)(this, linesController)
    };
    const jsonOptions = JSON.stringify(options).replace(/"/g, "");
    const bodyLine = func.asString(object3D, `this`, jsonOptions);
    linesController.addDefinitions(this, [
      new JsDefinition/* InitFunctionJsDefinition */.TN(this, linesController, connections_Js/* JsConnectionPointType.OBJECT_3D */.zF.OBJECT_3D, this.path(), bodyLine)
    ]);
    linesController.addTriggeringLines(this, [triggeredMethods], { gatherable: true });
  }
  _addDistanceRef(linesController) {
    const outDistance = this.jsVarName(_BaseOnObjectPointerEvent/* OnObjectPointerEventGPUJsNodeOutputName.distance */.C_.distance);
    linesController.addDefinitions(this, [
      new JsDefinition/* RefJsDefinition */.Z(this, linesController, connections_Js/* JsConnectionPointType.FLOAT */.zF.FLOAT, outDistance, `-1`)
    ]);
    return outDistance;
  }
}

// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/core/event/MouseEventType.ts
var MouseEventType = __webpack_require__(96370);
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/js/OnObjectMouseClick.ts











const OnObjectMouseClick_CONNECTION_OPTIONS = connections_Js/* JS_CONNECTION_POINT_IN_NODE_DEF */.mX;
class OnObjectMouseClickJsParamsConfig extends (0,_BaseOnObjectPointerEvent/* MouseEventConfigParamConfig */.rn)(
  (0,RayObjectIntersectionsClickController/* ClickParamConfig */.s)(_BaseOnObjectPointerEvent/* CPUOnObjectPointerEventJsParamsConfig */.hq)
) {
}
const OnObjectMouseClick_ParamsConfig = new OnObjectMouseClickJsParamsConfig();
class OnObjectMouseClickJsNode extends _BaseOnObjectPointerEvent/* ExtendableOnObjectPointerEventJsNode */.hs {
  constructor() {
    super(...arguments);
    this.paramsConfig = OnObjectMouseClick_ParamsConfig;
  }
  static type() {
    return Js/* JsType.ON_OBJECT_MOUSE_CLICK */.K.ON_OBJECT_MOUSE_CLICK;
  }
  isTriggering() {
    return true;
  }
  eventData() {
    return [
      {
        type: MouseEventType/* MouseEventType.mousedown */.k.mousedown,
        emitter: this.eventEmitter(),
        jsType: Js/* JsType.ON_OBJECT_MOUSE_CLICK */.K.ON_OBJECT_MOUSE_CLICK
      },
      {
        type: MouseEventType/* MouseEventType.mouseup */.k.mouseup,
        emitter: this.eventEmitter(),
        jsType: Js/* JsType.ON_OBJECT_MOUSE_CLICK */.K.ON_OBJECT_MOUSE_CLICK
      }
    ];
  }
  initializeNode() {
    super.initializeNode();
    this.io.inputs.setNamedInputConnectionPoints([
      new connections_Js/* JsConnectionPoint */.fp(connections_Js/* JsConnectionPointType.OBJECT_3D */.zF.OBJECT_3D, connections_Js/* JsConnectionPointType.OBJECT_3D */.zF.OBJECT_3D, OnObjectMouseClick_CONNECTION_OPTIONS)
    ]);
    this.io.outputs.setNamedOutputConnectionPoints([
      new connections_Js/* JsConnectionPoint */.fp(js_Base/* TRIGGER_CONNECTION_NAME */.w6, connections_Js/* JsConnectionPointType.TRIGGER */.zF.TRIGGER, OnObjectMouseClick_CONNECTION_OPTIONS),
      new connections_Js/* JsConnectionPoint */.fp(
        connections_Js/* JsConnectionPointType.INTERSECTION */.zF.INTERSECTION,
        connections_Js/* JsConnectionPointType.INTERSECTION */.zF.INTERSECTION,
        OnObjectMouseClick_CONNECTION_OPTIONS
      )
    ]);
  }
  setLines(linesController) {
    const usedOutputNames = this.io.outputs.used_output_names();
    if (usedOutputNames.includes(connections_Js/* JsConnectionPointType.INTERSECTION */.zF.INTERSECTION)) {
      this._addIntersectionRef(linesController);
    }
  }
  setTriggeringLines(linesController, triggeredMethods) {
    const object3D = (0,_BaseObject3D/* inputObject3D */.iv)(this, linesController);
    const blockObjectsBehind = this.variableForInputParam(linesController, this.p.blockObjectsBehind);
    const skipIfObjectsInFront = this.variableForInputParam(linesController, this.p.skipIfObjectsInFront);
    const traverseChildren = this.variableForInputParam(linesController, this.p.traverseChildren);
    const lineThreshold = this.variableForInputParam(linesController, this.p.lineThreshold);
    const pointsThreshold = this.variableForInputParam(linesController, this.p.pointsThreshold);
    const maxCursorMoveDistance = this.variableForInputParam(linesController, this.p.maxCursorMoveDistance);
    const maxDuration = this.variableForInputParam(linesController, this.p.maxDuration);
    const intersectionRef = this._addIntersectionRef(linesController);
    const func = Poly/* Poly.namedFunctionsRegister.getFunction */.L.namedFunctionsRegister.getFunction("addObjectToObjectMouseClickCheck", this, linesController);
    const options = {
      priority: {
        blockObjectsBehind,
        skipIfObjectsInFront
      },
      cpu: {
        traverseChildren,
        pointsThreshold,
        lineThreshold,
        intersectionRef: `this.${intersectionRef}`
      },
      click: {
        maxCursorMoveDistance,
        maxDuration,
        callback: `this.${(0,ActorAssemblerUtils/* nodeMethodName */.Bp)(this)}.bind(this)`
      },
      config: (0,_BaseOnObjectPointerEvent/* mouseButtonsConfig */.TZ)(this, linesController)
    };
    const jsonOptions = JSON.stringify(options).replace(/"/g, "");
    const bodyLine = func.asString(object3D, `this`, jsonOptions);
    linesController.addDefinitions(this, [
      new JsDefinition/* InitFunctionJsDefinition */.TN(this, linesController, connections_Js/* JsConnectionPointType.OBJECT_3D */.zF.OBJECT_3D, this.path(), bodyLine)
    ]);
    linesController.addTriggeringLines(this, [triggeredMethods], { gatherable: true });
  }
  _addIntersectionRef(linesController) {
    const outIntersection = this.jsVarName(connections_Js/* JsConnectionPointType.INTERSECTION */.zF.INTERSECTION);
    linesController.addDefinitions(this, [
      new JsDefinition/* RefJsDefinition */.Z(this, linesController, connections_Js/* JsConnectionPointType.INTERSECTION */.zF.INTERSECTION, outIntersection, `null`)
    ]);
    return outIntersection;
  }
}

// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/nodes/js/OnObjectPointerdown.ts
var OnObjectPointerdown = __webpack_require__(55149);
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/js/OnObjectPointerdownGPU.ts










const OnObjectPointerdownGPU_CONNECTION_OPTIONS = connections_Js/* JS_CONNECTION_POINT_IN_NODE_DEF */.mX;
class OnObjectPointerdownGPUJsParamsConfig extends (0,_BaseOnObjectPointerEvent/* PointerEventConfigParamConfig */.qd)(
  _BaseOnObjectPointerEvent/* GPUOnObjectPointerEventJsParamsConfig */.MR
) {
}
const OnObjectPointerdownGPU_ParamsConfig = new OnObjectPointerdownGPUJsParamsConfig();
class OnObjectPointerdownGPUJsNode extends _BaseOnObjectPointerEvent/* ExtendableOnObjectPointerEventJsNode */.hs {
  constructor() {
    super(...arguments);
    this.paramsConfig = OnObjectPointerdownGPU_ParamsConfig;
  }
  static type() {
    return Js/* JsType.ON_OBJECT_POINTERDOWN_GPU */.K.ON_OBJECT_POINTERDOWN_GPU;
  }
  eventData() {
    return {
      type: PointerEventType/* PointerEventType.pointerdown */.by.pointerdown,
      emitter: this.eventEmitter(),
      jsType: Js/* JsType.ON_OBJECT_POINTERDOWN */.K.ON_OBJECT_POINTERDOWN
    };
  }
  initializeNode() {
    super.initializeNode();
    this.io.inputs.setNamedInputConnectionPoints([
      new connections_Js/* JsConnectionPoint */.fp(connections_Js/* JsConnectionPointType.OBJECT_3D */.zF.OBJECT_3D, connections_Js/* JsConnectionPointType.OBJECT_3D */.zF.OBJECT_3D, OnObjectPointerdownGPU_CONNECTION_OPTIONS),
      new connections_Js/* JsConnectionPoint */.fp(
        _BaseOnObjectPointerEvent/* OnObjectPointerEventGPUJsNodeInputName.worldPosMaterial */.yD.worldPosMaterial,
        connections_Js/* JsConnectionPointType.MATERIAL */.zF.MATERIAL,
        OnObjectPointerdownGPU_CONNECTION_OPTIONS
      )
    ]);
    this.io.outputs.setNamedOutputConnectionPoints([
      new connections_Js/* JsConnectionPoint */.fp(js_Base/* TRIGGER_CONNECTION_NAME */.w6, connections_Js/* JsConnectionPointType.TRIGGER */.zF.TRIGGER, OnObjectPointerdownGPU_CONNECTION_OPTIONS),
      new connections_Js/* JsConnectionPoint */.fp(
        _BaseOnObjectPointerEvent/* OnObjectPointerEventGPUJsNodeOutputName.distance */.C_.distance,
        connections_Js/* JsConnectionPointType.FLOAT */.zF.FLOAT,
        OnObjectPointerdownGPU_CONNECTION_OPTIONS
      )
    ]);
  }
  setLines(linesController) {
    const usedOutputNames = this.io.outputs.used_output_names();
    if (usedOutputNames.includes(_BaseOnObjectPointerEvent/* OnObjectPointerEventGPUJsNodeOutputName.distance */.C_.distance)) {
      this._addDistanceRef(linesController);
    }
  }
  setTriggeringLines(linesController, triggeredMethods) {
    const object3D = (0,_BaseObject3D/* inputObject3D */.iv)(this, linesController);
    const blockObjectsBehind = this.variableForInputParam(linesController, this.p.blockObjectsBehind);
    const skipIfObjectsInFront = this.variableForInputParam(linesController, this.p.skipIfObjectsInFront);
    const worldPosMaterial = this.variableForInput(
      linesController,
      _BaseOnObjectPointerEvent/* OnObjectPointerEventGPUJsNodeInputName.worldPosMaterial */.yD.worldPosMaterial
    );
    const distanceRef = this._addDistanceRef(linesController);
    const func = Poly/* Poly.namedFunctionsRegister.getFunction */.L.namedFunctionsRegister.getFunction(
      "addObjectToObjectPointerdownCheck",
      this,
      linesController
    );
    const options = {
      priority: {
        blockObjectsBehind,
        skipIfObjectsInFront
      },
      gpu: {
        worldPosMaterial,
        distanceRef: `this.${distanceRef}`
      },
      pointerdown: {
        callback: `this.${(0,ActorAssemblerUtils/* nodeMethodName */.Bp)(this)}.bind(this)`
      },
      config: (0,_BaseOnObjectPointerEvent/* pointerButtonConfig */.AI)(this, linesController)
    };
    const jsonOptions = JSON.stringify(options).replace(/"/g, "");
    const bodyLine = func.asString(object3D, `this`, jsonOptions);
    linesController.addDefinitions(this, [
      new JsDefinition/* InitFunctionJsDefinition */.TN(this, linesController, connections_Js/* JsConnectionPointType.OBJECT_3D */.zF.OBJECT_3D, this.path(), bodyLine)
    ]);
    linesController.addTriggeringLines(this, [triggeredMethods], { gatherable: true });
  }
  _addDistanceRef(linesController) {
    const outDistance = this.jsVarName(_BaseOnObjectPointerEvent/* OnObjectPointerEventGPUJsNodeOutputName.distance */.C_.distance);
    linesController.addDefinitions(this, [
      new JsDefinition/* RefJsDefinition */.Z(this, linesController, connections_Js/* JsConnectionPointType.FLOAT */.zF.FLOAT, outDistance, `-1`)
    ]);
    return outDistance;
  }
}

// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/nodes/js/OnObjectPointerup.ts
var OnObjectPointerup = __webpack_require__(7164);
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/js/OnObjectPointerupGPU.ts










const OnObjectPointerupGPU_CONNECTION_OPTIONS = connections_Js/* JS_CONNECTION_POINT_IN_NODE_DEF */.mX;
class OnObjectPointerupGPUJsParamsConfig extends (0,_BaseOnObjectPointerEvent/* PointerEventConfigParamConfig */.qd)(
  _BaseOnObjectPointerEvent/* GPUOnObjectPointerEventJsParamsConfig */.MR
) {
}
const OnObjectPointerupGPU_ParamsConfig = new OnObjectPointerupGPUJsParamsConfig();
class OnObjectPointerupGPUJsNode extends _BaseOnObjectPointerEvent/* ExtendableOnObjectPointerEventJsNode */.hs {
  constructor() {
    super(...arguments);
    this.paramsConfig = OnObjectPointerupGPU_ParamsConfig;
  }
  static type() {
    return Js/* JsType.ON_OBJECT_POINTERUP_GPU */.K.ON_OBJECT_POINTERUP_GPU;
  }
  eventData() {
    return {
      type: PointerEventType/* PointerEventType.pointerup */.by.pointerup,
      emitter: this.eventEmitter(),
      jsType: Js/* JsType.ON_OBJECT_POINTERUP */.K.ON_OBJECT_POINTERUP
    };
  }
  initializeNode() {
    super.initializeNode();
    this.io.inputs.setNamedInputConnectionPoints([
      new connections_Js/* JsConnectionPoint */.fp(connections_Js/* JsConnectionPointType.OBJECT_3D */.zF.OBJECT_3D, connections_Js/* JsConnectionPointType.OBJECT_3D */.zF.OBJECT_3D, OnObjectPointerupGPU_CONNECTION_OPTIONS),
      new connections_Js/* JsConnectionPoint */.fp(
        _BaseOnObjectPointerEvent/* OnObjectPointerEventGPUJsNodeInputName.worldPosMaterial */.yD.worldPosMaterial,
        connections_Js/* JsConnectionPointType.MATERIAL */.zF.MATERIAL,
        OnObjectPointerupGPU_CONNECTION_OPTIONS
      )
    ]);
    this.io.outputs.setNamedOutputConnectionPoints([
      new connections_Js/* JsConnectionPoint */.fp(js_Base/* TRIGGER_CONNECTION_NAME */.w6, connections_Js/* JsConnectionPointType.TRIGGER */.zF.TRIGGER, OnObjectPointerupGPU_CONNECTION_OPTIONS),
      new connections_Js/* JsConnectionPoint */.fp(
        _BaseOnObjectPointerEvent/* OnObjectPointerEventGPUJsNodeOutputName.distance */.C_.distance,
        connections_Js/* JsConnectionPointType.FLOAT */.zF.FLOAT,
        OnObjectPointerupGPU_CONNECTION_OPTIONS
      )
    ]);
  }
  setLines(linesController) {
    const usedOutputNames = this.io.outputs.used_output_names();
    if (usedOutputNames.includes(_BaseOnObjectPointerEvent/* OnObjectPointerEventGPUJsNodeOutputName.distance */.C_.distance)) {
      this._addDistanceRef(linesController);
    }
  }
  setTriggeringLines(linesController, triggeredMethods) {
    const object3D = (0,_BaseObject3D/* inputObject3D */.iv)(this, linesController);
    const blockObjectsBehind = this.variableForInputParam(linesController, this.p.blockObjectsBehind);
    const skipIfObjectsInFront = this.variableForInputParam(linesController, this.p.skipIfObjectsInFront);
    const worldPosMaterial = this.variableForInput(
      linesController,
      _BaseOnObjectPointerEvent/* OnObjectPointerEventGPUJsNodeInputName.worldPosMaterial */.yD.worldPosMaterial
    );
    const distanceRef = this._addDistanceRef(linesController);
    const func = Poly/* Poly.namedFunctionsRegister.getFunction */.L.namedFunctionsRegister.getFunction("addObjectToObjectPointerupCheck", this, linesController);
    const options = {
      priority: {
        blockObjectsBehind,
        skipIfObjectsInFront
      },
      gpu: {
        worldPosMaterial,
        distanceRef: `this.${distanceRef}`
      },
      pointerup: {
        callback: `this.${(0,ActorAssemblerUtils/* nodeMethodName */.Bp)(this)}.bind(this)`
      },
      config: (0,_BaseOnObjectPointerEvent/* pointerButtonConfig */.AI)(this, linesController)
    };
    const jsonOptions = JSON.stringify(options).replace(/"/g, "");
    const bodyLine = func.asString(object3D, `this`, jsonOptions);
    linesController.addDefinitions(this, [
      new JsDefinition/* InitFunctionJsDefinition */.TN(this, linesController, connections_Js/* JsConnectionPointType.OBJECT_3D */.zF.OBJECT_3D, this.path(), bodyLine)
    ]);
    linesController.addTriggeringLines(this, [triggeredMethods], { gatherable: true });
  }
  _addDistanceRef(linesController) {
    const outDistance = this.jsVarName(_BaseOnObjectPointerEvent/* OnObjectPointerEventGPUJsNodeOutputName.distance */.C_.distance);
    linesController.addDefinitions(this, [
      new JsDefinition/* RefJsDefinition */.Z(this, linesController, connections_Js/* JsConnectionPointType.FLOAT */.zF.FLOAT, outDistance, `-1`)
    ]);
    return outDistance;
  }
}

// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/nodes/js/OnObjectSwipe.ts
var OnObjectSwipe = __webpack_require__(27496);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/nodes/js/OnObjectSwipeGPU.ts
var OnObjectSwipeGPU = __webpack_require__(43588);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/node_modules/@vue-reactivity/watch/dist/index.mjs
var dist = __webpack_require__(14404);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/functions/_Base.ts
var functions_Base = __webpack_require__(52419);
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/functions/_Performance.ts



var PerformanceChangeEvent = /* @__PURE__ */ ((PerformanceChangeEvent2) => {
  PerformanceChangeEvent2["aboveThreshold"] = "aboveThreshold";
  PerformanceChangeEvent2["belowThreshold"] = "belowThreshold";
  return PerformanceChangeEvent2;
})(PerformanceChangeEvent || {});
const PERFORMANCE_CHANGE_EVENTS = [
  "aboveThreshold" /* aboveThreshold */,
  "belowThreshold" /* belowThreshold */
];
class onPerformanceChange extends functions_Base/* NamedFunction3 */.Dv {
  static type() {
    return "onPerformanceChange";
  }
  func(threshold, callbacks, evaluator) {
    const performanceRef = this.scene.perfMonitor.ref();
    const watchFallsBelow = () => {
      const isAboveThresholdRef = (0,reactivity_esm_bundler/* ref */.iH)(true);
      const _isBelowThreshold = (0,reactivity_esm_bundler/* computed */.Fl)(() => performanceRef.value < threshold);
      const stopWatch1 = (0,dist/* watch */.Y)(_isBelowThreshold, () => {
        if (_isBelowThreshold.value == true) {
          isAboveThresholdRef.value = false;
        }
      });
      const stopWatch2 = (0,dist/* watch */.Y)(isAboveThresholdRef, () => {
        callbacks.belowThreshold();
      });
      evaluator.onDispose(() => {
        stopWatch1();
        stopWatch2();
      });
    };
    const watchFallsAbove = () => {
      const isBelowThresholdRef = (0,reactivity_esm_bundler/* ref */.iH)(true);
      const _isAboveThreshold = (0,reactivity_esm_bundler/* computed */.Fl)(() => performanceRef.value > threshold);
      const stopWatch1 = (0,dist/* watch */.Y)(_isAboveThreshold, (newVal, oldVal) => {
        if (_isAboveThreshold.value == true) {
          isBelowThresholdRef.value = false;
        }
      });
      const stopWatch2 = (0,dist/* watch */.Y)(isBelowThresholdRef, () => {
        callbacks.aboveThreshold();
      });
      evaluator.onDispose(() => {
        stopWatch1();
        stopWatch2();
      });
    };
    watchFallsBelow();
    watchFallsAbove();
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/js/OnPerformanceChange.ts










function _outputName(eventName) {
  return `${js_Base/* TRIGGER_CONNECTION_NAME */.w6}${eventName}`;
}
class OnPerformanceChangeJsParamsConfig extends params_ParamsConfig/* NodeParamsConfig */.yI {
  constructor() {
    super(...arguments);
    this.threshold = params_ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(0.8, {
      range: [0, 1],
      rangeLocked: [true, true]
    });
  }
  // delay = ParamConfig.INTEGER(3000, {
  // 	range: [0, 5000],
  // 	rangeLocked: [true, false],
  // });
}
const OnPerformanceChange_ParamsConfig = new OnPerformanceChangeJsParamsConfig();
const _OnPerformanceChangeJsNode = class extends js_Base/* TypedJsNode */.xZ {
  constructor() {
    super(...arguments);
    this.paramsConfig = OnPerformanceChange_ParamsConfig;
  }
  static type() {
    return Js/* JsType.ON_PERFORMANCE_CHANGE */.K.ON_PERFORMANCE_CHANGE;
  }
  isTriggering() {
    return true;
  }
  // static OUTPUT_TRIGGER_NAMES = [this.OUTPUT_NAME_ABOVE, this.OUTPUT_NAME_BELOW];
  initializeNode() {
    this.io.outputs.setNamedOutputConnectionPoints([
      new connections_Js/* JsConnectionPoint */.fp(_OnPerformanceChangeJsNode.OUTPUT_NAME_ABOVE, connections_Js/* JsConnectionPointType.TRIGGER */.zF.TRIGGER),
      new connections_Js/* JsConnectionPoint */.fp(_OnPerformanceChangeJsNode.OUTPUT_NAME_BELOW, connections_Js/* JsConnectionPointType.TRIGGER */.zF.TRIGGER)
      // new JsConnectionPoint(OnPerformanceChangeOutputName.aboveThreshold, JsConnectionPointType.BOOLEAN),
      // new JsConnectionPoint(OnPerformanceChangeOutputName.performance, JsConnectionPointType.FLOAT),
    ]);
  }
  setTriggeringLines(shadersCollectionController, triggeredMethods) {
    const listeners = {
      [PerformanceChangeEvent.aboveThreshold]: "",
      [PerformanceChangeEvent.belowThreshold]: ""
    };
    PERFORMANCE_CHANGE_EVENTS.forEach((eventName) => {
      const triggeredMethods2 = triggerMethod(this, _outputName(eventName));
      const _nodeMethodName = (0,ActorAssemblerUtils/* nodeMethodName */.Bp)(this, _outputName(eventName));
      listeners[eventName] = `this.${_nodeMethodName}.bind(this)`;
      const value = triggeredMethods2;
      const dataType = connections_Js/* JsConnectionPointType.BOOLEAN */.zF.BOOLEAN;
      shadersCollectionController.addDefinitions(this, [
        new JsDefinition/* TriggeringJsDefinition */.id(this, shadersCollectionController, dataType, _nodeMethodName, value, {
          triggeringMethodName: eventName,
          gatherable: false,
          nodeMethodName: _nodeMethodName
        })
      ]);
    });
    const threshold = this.variableForInputParam(shadersCollectionController, this.p.threshold);
    const func = Poly/* Poly.namedFunctionsRegister.getFunction */.L.namedFunctionsRegister.getFunction("onPerformanceChange", this, shadersCollectionController);
    const bodyLine = func.asString(threshold, JSON.stringify(listeners).replace(/\"/g, ""), `this`);
    shadersCollectionController.addDefinitions(this, [
      new JsDefinition/* InitFunctionJsDefinition */.TN(
        this,
        shadersCollectionController,
        connections_Js/* JsConnectionPointType.OBJECT_3D */.zF.OBJECT_3D,
        this.path(),
        bodyLine
      )
    ]);
  }
  // initOnPlay() {
  // 	this._currentPerfAboveThreshold = undefined;
  // 	this.scene().perfMonitor.addThreshold(this.pv.threshold);
  // }
  // disposeOnPause() {
  // 	this.scene().perfMonitor.reset();
  // }
  // protected _currentPerfAboveThreshold: boolean | undefined;
  // private _lastChangeAt: number | undefined;
  // runTriggerIfRequired(context: JsNodeTriggerContext) {
  // 	// const now = performance.now();
  // 	// if (this._lastChangeAt != null && now - this._lastChangeAt < this.pv.delay) {
  // 	// 	return;
  // 	// }
  // 	const perf = this.scene().perfMonitor.performance();
  // 	const perfAboveThreshold = perf > this.pv.threshold;
  // 	if (perfAboveThreshold != this._currentPerfAboveThreshold) {
  // 		this._currentPerfAboveThreshold = perfAboveThreshold;
  // 		// this._lastChangeAt = now;
  // 		const outputIndex = OnPerformanceChangeJsNode.OUTPUT_TRIGGER_NAMES.indexOf(
  // 			perfAboveThreshold
  // 				? OnPerformanceChangeJsNode.OUTPUT_NAME_ABOVE
  // 				: OnPerformanceChangeJsNode.OUTPUT_NAME_BELOW
  // 		);
  // 		this.runTrigger(context, outputIndex);
  // 	}
  // }
  // public override outputValue(
  // 	context: JsNodeTriggerContext,
  // 	outputName: OnPerformanceChangeOutputName
  // ): boolean | number {
  // 	const perf = this.scene().perfMonitor.performance();
  // 	switch (outputName) {
  // 		case OnPerformanceChangeOutputName.aboveThreshold: {
  // 			return this._currentPerfAboveThreshold || true;
  // 		}
  // 		case OnPerformanceChangeOutputName.performance: {
  // 			return perf;
  // 		}
  // 	}
  // 	TypeAssert.unreachable(outputName);
  // }
};
let OnPerformanceChangeJsNode = _OnPerformanceChangeJsNode;
OnPerformanceChangeJsNode.OUTPUT_NAME_ABOVE = _outputName(PerformanceChangeEvent.aboveThreshold);
OnPerformanceChangeJsNode.OUTPUT_NAME_BELOW = _outputName(PerformanceChangeEvent.belowThreshold);
function triggerMethod(node, outputName) {
  const outputIndex = (0,ActorAssemblerUtils/* getOutputIndices */.D0)(node, (c) => c.name() == outputName)[0];
  const triggerableNodes = /* @__PURE__ */ new Set();
  (0,ActorAssemblerUtils/* getConnectedOutputNodes */.YZ)({
    node,
    triggerOutputIndices: [outputIndex],
    triggerableNodes,
    recursive: false
  });
  const triggerableMethodNames = (0,SetUtils/* setToArray */.T_)(triggerableNodes, []).map((triggerableNode) => {
    const argIndex = (0,ActorAssemblerUtils/* triggerInputIndex */.D6)(node, triggerableNode);
    const m = (0,ActorAssemblerUtils/* nodeMethodName */.Bp)(triggerableNode);
    return `this.${m}(${argIndex})`;
  });
  return `${triggerableMethodNames.join(";")}`;
}

// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/nodes/js/OnPointerdown.ts
var OnPointerdown = __webpack_require__(52093);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/nodes/js/OnPointerup.ts
var OnPointerup = __webpack_require__(19705);
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/js/OnScenePause.ts





class OnScenePauseJsParamsConfig extends params_ParamsConfig/* NodeParamsConfig */.yI {
}
const OnScenePause_ParamsConfig = new OnScenePauseJsParamsConfig();
class OnScenePauseJsNode extends js_Base/* TypedJsNode */.xZ {
  constructor() {
    super(...arguments);
    this.paramsConfig = OnScenePause_ParamsConfig;
  }
  static type() {
    return Js/* JsType.ON_SCENE_PAUSE */.K.ON_SCENE_PAUSE;
  }
  isTriggering() {
    return true;
  }
  initializeNode() {
    this.io.outputs.setNamedOutputConnectionPoints([
      new connections_Js/* JsConnectionPoint */.fp(connections_Js/* JsConnectionPointType.TRIGGER */.zF.TRIGGER, connections_Js/* JsConnectionPointType.TRIGGER */.zF.TRIGGER)
    ]);
  }
  setTriggeringLines(shadersCollectionController, triggeredMethods) {
    shadersCollectionController.addTriggeringLines(this, [triggeredMethods], {
      gatherable: true
    });
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/js/OnScenePlay.ts





class OnScenePlayJsParamsConfig extends params_ParamsConfig/* NodeParamsConfig */.yI {
}
const OnScenePlay_ParamsConfig = new OnScenePlayJsParamsConfig();
class OnScenePlayJsNode extends js_Base/* TypedJsNode */.xZ {
  constructor() {
    super(...arguments);
    this.paramsConfig = OnScenePlay_ParamsConfig;
  }
  static type() {
    return Js/* JsType.ON_SCENE_PLAY */.K.ON_SCENE_PLAY;
  }
  isTriggering() {
    return true;
  }
  initializeNode() {
    this.io.outputs.setNamedOutputConnectionPoints([
      new connections_Js/* JsConnectionPoint */.fp(connections_Js/* JsConnectionPointType.TRIGGER */.zF.TRIGGER, connections_Js/* JsConnectionPointType.TRIGGER */.zF.TRIGGER)
    ]);
  }
  setTriggeringLines(shadersCollectionController, triggeredMethods) {
    shadersCollectionController.addTriggeringLines(this, [triggeredMethods], {
      gatherable: true
    });
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/js/OnSceneReset.ts





class OnSceneResetJsParamsConfig extends params_ParamsConfig/* NodeParamsConfig */.yI {
}
const OnSceneReset_ParamsConfig = new OnSceneResetJsParamsConfig();
class OnSceneResetJsNode extends js_Base/* TypedJsNode */.xZ {
  constructor() {
    super(...arguments);
    this.paramsConfig = OnSceneReset_ParamsConfig;
  }
  static type() {
    return Js/* JsType.ON_SCENE_RESET */.K.ON_SCENE_RESET;
  }
  isTriggering() {
    return true;
  }
  initializeNode() {
    this.io.outputs.setNamedOutputConnectionPoints([
      new connections_Js/* JsConnectionPoint */.fp(js_Base/* TRIGGER_CONNECTION_NAME */.w6, connections_Js/* JsConnectionPointType.TRIGGER */.zF.TRIGGER)
    ]);
  }
  setTriggeringLines(shadersCollectionController, triggeredMethods) {
    shadersCollectionController.addTriggeringLines(this, [triggeredMethods], {
      gatherable: true
    });
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/core/scroll/Common.ts

var ScrollEvent = /* @__PURE__ */ ((ScrollEvent2) => {
  ScrollEvent2["onUpdate"] = "onUpdate";
  ScrollEvent2["onToggle"] = "onToggle";
  ScrollEvent2["onEnter"] = "onEnter";
  ScrollEvent2["onLeave"] = "onLeave";
  ScrollEvent2["onEnterBack"] = "onEnterBack";
  ScrollEvent2["onLeaveBack"] = "onLeaveBack";
  return ScrollEvent2;
})(ScrollEvent || {});
const SCROLL_EVENTS = [
  "onUpdate" /* onUpdate */,
  "onToggle" /* onToggle */,
  "onEnter" /* onEnter */,
  "onLeave" /* onLeave */,
  "onEnterBack" /* onEnterBack */,
  "onLeaveBack" /* onLeaveBack */
];

// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/poly/registers/modules/Common.ts
var modules_Common = __webpack_require__(26280);
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/js/OnScroll.ts











var OnScrollInputName = /* @__PURE__ */ ((OnScrollInputName2) => {
  OnScrollInputName2["attribName"] = "attribName";
  return OnScrollInputName2;
})(OnScrollInputName || {});
var OnScrollOutputName = /* @__PURE__ */ ((OnScrollOutputName2) => {
  OnScrollOutputName2["progress"] = "progress";
  return OnScrollOutputName2;
})(OnScrollOutputName || {});
const OnScroll_CONNECTION_OPTIONS = connections_Js/* JS_CONNECTION_POINT_IN_NODE_DEF */.mX;
class OnScrollJsParamsConfig extends params_ParamsConfig/* NodeParamsConfig */.yI {
  constructor() {
    super(...arguments);
    this.element = params_ParamsConfig/* ParamConfig.STRING */.XC.STRING("#checkpoint1");
    this.useViewport = params_ParamsConfig/* ParamConfig.BOOLEAN */.XC.BOOLEAN(false);
    this.scroller = params_ParamsConfig/* ParamConfig.STRING */.XC.STRING("#scroll-container", {
      visibleIf: {
        useViewport: false
      }
    });
    this.displayMarkers = params_ParamsConfig/* ParamConfig.BOOLEAN */.XC.BOOLEAN(false);
  }
}
const OnScroll_ParamsConfig = new OnScrollJsParamsConfig();
class OnScrollJsNode extends js_Base/* TypedJsNode */.xZ {
  constructor() {
    super(...arguments);
    this.paramsConfig = OnScroll_ParamsConfig;
  }
  static type() {
    return Js/* JsType.ON_SCROLL */.K.ON_SCROLL;
  }
  requiredModules() {
    return [modules_Common/* ModuleName.GSAP */.r.GSAP];
  }
  isTriggering() {
    return true;
  }
  initializeNode() {
    this.io.outputs.setNamedOutputConnectionPoints([
      ...SCROLL_EVENTS.map((triggerName) => new connections_Js/* JsConnectionPoint */.fp(triggerName, connections_Js/* JsConnectionPointType.TRIGGER */.zF.TRIGGER)),
      new connections_Js/* JsConnectionPoint */.fp("progress" /* progress */, connections_Js/* JsConnectionPointType.FLOAT */.zF.FLOAT, OnScroll_CONNECTION_OPTIONS)
    ]);
  }
  setLines(linesController) {
    const usedOutputNames = this.io.outputs.used_output_names();
    if (usedOutputNames.includes("progress" /* progress */)) {
      this._addProgressRef(linesController);
    }
    if (usedOutputNames.length > 0) {
      this._addCreateScrollListenerLines(linesController);
    }
  }
  setTriggeringLines(linesController, triggeredMethods) {
    this._addCreateScrollListenerLines(linesController);
  }
  _addCreateScrollListenerLines(linesController) {
    const element = this.variableForInputParam(linesController, this.p.element);
    const scroller = this.variableForInputParam(linesController, this.p.scroller);
    const useViewport = this.variableForInputParam(linesController, this.p.useViewport);
    const displayMarkers = this.variableForInputParam(linesController, this.p.displayMarkers);
    const outProgress = this._addProgressRef(linesController);
    const listeners = {
      [ScrollEvent.onUpdate]: "",
      [ScrollEvent.onToggle]: "",
      [ScrollEvent.onEnter]: "",
      [ScrollEvent.onLeave]: "",
      [ScrollEvent.onEnterBack]: "",
      [ScrollEvent.onLeaveBack]: ""
    };
    const createOptions = {
      element,
      useViewport,
      scroller,
      displayMarkers,
      nodePath: `'${this.path()}'`
    };
    SCROLL_EVENTS.forEach((eventName) => {
      const triggeredMethods = OnScroll_triggerMethod(this, eventName);
      const _nodeMethodName = (0,ActorAssemblerUtils/* nodeMethodName */.Bp)(this, eventName);
      listeners[eventName] = `this.${_nodeMethodName}.bind(this)`;
      const value = triggeredMethods;
      const dataType = connections_Js/* JsConnectionPointType.BOOLEAN */.zF.BOOLEAN;
      linesController.addDefinitions(this, [
        new JsDefinition/* TriggeringJsDefinition */.id(this, linesController, dataType, _nodeMethodName, value, {
          triggeringMethodName: eventName,
          gatherable: false,
          nodeMethodName: _nodeMethodName
        })
      ]);
    });
    const func = Poly/* Poly.namedFunctionsRegister.getFunction */.L.namedFunctionsRegister.getFunction("createScrollListener", this, linesController);
    const bodyLine = func.asString(
      shallowJSONStringify(createOptions),
      JSON.stringify(listeners).replace(/\"/g, ""),
      `this`,
      `this.${outProgress}`
    );
    linesController.addDefinitions(this, [
      new JsDefinition/* InitFunctionJsDefinition */.TN(this, linesController, connections_Js/* JsConnectionPointType.OBJECT_3D */.zF.OBJECT_3D, this.path(), bodyLine)
    ]);
  }
  _addProgressRef(linesController) {
    const outProgress = this.jsVarName("progress" /* progress */);
    linesController.addDefinitions(this, [
      new JsDefinition/* RefJsDefinition */.Z(this, linesController, connections_Js/* JsConnectionPointType.FLOAT */.zF.FLOAT, outProgress, `0`)
    ]);
    return outProgress;
  }
}
function OnScroll_triggerMethod(node, outputName) {
  const outputIndex = (0,ActorAssemblerUtils/* getOutputIndices */.D0)(node, (c) => c.name() == outputName)[0];
  const triggerableNodes = /* @__PURE__ */ new Set();
  (0,ActorAssemblerUtils/* getConnectedOutputNodes */.YZ)({
    node,
    triggerOutputIndices: [outputIndex],
    triggerableNodes,
    recursive: false
  });
  const triggerableMethodNames = (0,SetUtils/* setToArray */.T_)(triggerableNodes, []).map((triggerableNode) => {
    const argIndex = (0,ActorAssemblerUtils/* triggerInputIndex */.D6)(node, triggerableNode);
    const m = (0,ActorAssemblerUtils/* nodeMethodName */.Bp)(triggerableNode);
    return `this.${m}(${argIndex})`;
  });
  return `${triggerableMethodNames.join(";")}`;
}
function shallowJSONStringify(options) {
  const keys = Object.keys(options);
  const values = keys.map((key) => `${key}:${options[key]}`);
  return `{${values}}`;
}

// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/nodes/js/OnTick.ts
var OnTick = __webpack_require__(12936);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/nodes/js/OnVideoEvent.ts
var OnVideoEvent = __webpack_require__(94027);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/viewers/utils/ViewerControlsController.ts
var ViewerControlsController = __webpack_require__(80218);
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/js/OnViewerControlsEvent.ts










function OnViewerControlsEvent_outputName(eventName) {
  return `${js_Base/* TRIGGER_CONNECTION_NAME */.w6}${eventName}`;
}
class OnViewerControlsEventJsParamsConfig extends params_ParamsConfig/* NodeParamsConfig */.yI {
}
const OnViewerControlsEvent_ParamsConfig = new OnViewerControlsEventJsParamsConfig();
const _OnViewerControlsEventJsNode = class extends js_Base/* TypedJsNode */.xZ {
  constructor() {
    super(...arguments);
    this.paramsConfig = OnViewerControlsEvent_ParamsConfig;
  }
  static type() {
    return Js/* JsType.ON_VIEWER_CONTROLS_EVENT */.K.ON_VIEWER_CONTROLS_EVENT;
  }
  isTriggering() {
    return true;
  }
  initializeNode() {
    this.io.outputs.setNamedOutputConnectionPoints([
      new connections_Js/* JsConnectionPoint */.fp(_OnViewerControlsEventJsNode.OUTPUT_NAME_START, connections_Js/* JsConnectionPointType.TRIGGER */.zF.TRIGGER),
      new connections_Js/* JsConnectionPoint */.fp(_OnViewerControlsEventJsNode.OUTPUT_NAME_END, connections_Js/* JsConnectionPointType.TRIGGER */.zF.TRIGGER)
      // new JsConnectionPoint(OnPerformanceChangeOutputName.aboveThreshold, JsConnectionPointType.BOOLEAN),
      // new JsConnectionPoint(OnPerformanceChangeOutputName.performance, JsConnectionPointType.FLOAT),
    ]);
  }
  setTriggeringLines(linesController, triggeredMethods) {
    const listeners = {
      [ViewerControlsController/* CameraControlsEvent.start */.ZI.start]: "",
      [ViewerControlsController/* CameraControlsEvent.end */.ZI.end]: ""
    };
    ViewerControlsController/* CAMERA_CONTROLS_EVENTS.forEach */.tB.forEach((eventName) => {
      const triggeredMethods2 = OnViewerControlsEvent_triggerMethod(this, OnViewerControlsEvent_outputName(eventName));
      const _nodeMethodName = (0,ActorAssemblerUtils/* nodeMethodName */.Bp)(this, OnViewerControlsEvent_outputName(eventName));
      listeners[eventName] = `this.${_nodeMethodName}.bind(this)`;
      const value = triggeredMethods2;
      const dataType = connections_Js/* JsConnectionPointType.BOOLEAN */.zF.BOOLEAN;
      linesController.addDefinitions(this, [
        new JsDefinition/* TriggeringJsDefinition */.id(this, linesController, dataType, _nodeMethodName, value, {
          triggeringMethodName: eventName,
          gatherable: false,
          nodeMethodName: _nodeMethodName
        })
      ]);
    });
    const func = Poly/* Poly.namedFunctionsRegister.getFunction */.L.namedFunctionsRegister.getFunction("onViewerControlsEvent", this, linesController);
    const bodyLine = func.asString(JSON.stringify(listeners).replace(/\"/g, ""), `this`);
    linesController.addDefinitions(this, [
      new JsDefinition/* InitFunctionJsDefinition */.TN(this, linesController, connections_Js/* JsConnectionPointType.OBJECT_3D */.zF.OBJECT_3D, this.path(), bodyLine)
    ]);
  }
};
let OnViewerControlsEventJsNode = _OnViewerControlsEventJsNode;
OnViewerControlsEventJsNode.OUTPUT_NAME_START = OnViewerControlsEvent_outputName(ViewerControlsController/* CameraControlsEvent.start */.ZI.start);
OnViewerControlsEventJsNode.OUTPUT_NAME_END = OnViewerControlsEvent_outputName(ViewerControlsController/* CameraControlsEvent.end */.ZI.end);
function OnViewerControlsEvent_triggerMethod(node, outputName) {
  const outputIndex = (0,ActorAssemblerUtils/* getOutputIndices */.D0)(node, (c) => c.name() == outputName)[0];
  const triggerableNodes = /* @__PURE__ */ new Set();
  (0,ActorAssemblerUtils/* getConnectedOutputNodes */.YZ)({
    node,
    triggerOutputIndices: [outputIndex],
    triggerableNodes,
    recursive: false
  });
  const triggerableMethodNames = (0,SetUtils/* setToArray */.T_)(triggerableNodes, []).map((triggerableNode) => {
    const argIndex = (0,ActorAssemblerUtils/* triggerInputIndex */.D6)(node, triggerableNode);
    const m = (0,ActorAssemblerUtils/* nodeMethodName */.Bp)(triggerableNode);
    return `this.${m}(${argIndex})`;
  });
  return `${triggerableMethodNames.join(";")}`;
}

// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/core/webXR/Common.ts
var webXR_Common = __webpack_require__(25226);
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/js/OnWebXRControllerEvent.ts

var OnWebXRControllerEvent_async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};





class OnWebXRControllerEventJsParamsConfig extends params_ParamsConfig/* NodeParamsConfig */.yI {
  constructor() {
    super(...arguments);
    /** @param  controller index */
    this.controllerIndex = params_ParamsConfig/* ParamConfig.INTEGER */.XC.INTEGER(0, {
      range: [0, 1],
      rangeLocked: [true, true]
    });
  }
}
const OnWebXRControllerEvent_ParamsConfig = new OnWebXRControllerEventJsParamsConfig();
class OnWebXRControllerEventJsNode extends js_Base/* TypedJsNode */.xZ {
  constructor() {
    super(...arguments);
    this.paramsConfig = OnWebXRControllerEvent_ParamsConfig;
    this._listenerByObjectByControllerIndex = /* @__PURE__ */ new Map();
  }
  static type() {
    return Js/* JsType.ON_WEBXR_CONTROLLER_EVENT */.K.ON_WEBXR_CONTROLLER_EVENT;
  }
  isTriggering() {
    return true;
  }
  initializeNode() {
    this.io.connection_points.spare_params.setInputlessParamNames(["controllerIndex"]);
    this.io.outputs.setNamedOutputConnectionPoints(
      webXR_Common/* BASE_XR_SESSION_EVENT_NAMES.map */.Rc.map(
        (triggerName) => new connections_Js/* JsConnectionPoint */.fp(triggerName, connections_Js/* JsConnectionPointType.TRIGGER */.zF.TRIGGER)
      )
    );
  }
  initOnPlay() {
    this._addEventListenersToObjects();
  }
  disposeOnPause() {
  }
  _addEventListenersToObjects() {
    return OnWebXRControllerEvent_async(this, null, function* () {
    });
  }
  // private _createEventListener(Object3D: Object3D) {
  // 	const xrController = this.scene().webXR.activeXRController();
  // 	if (!xrController) {
  // 		return;
  // 	}
  // 	const controllerIndex = this.pv.controllerIndex;
  // 	let listenerByObject = this._listenerByObjectByControllerIndex.get(controllerIndex);
  // 	if (!listenerByObject) {
  // 		listenerByObject = new Map();
  // 		this._listenerByObjectByControllerIndex.set(controllerIndex, listenerByObject);
  // 	}
  // 	let listeners = listenerByObject.get(Object3D);
  // 	if (!listeners) {
  // 		const createListener = (eventName: BaseXRSessionEventName) => {
  // 			const listener = (event: BaseCoreXRControllerEvent) => {
  // 				const controllerContainer = event.controllerContainer;
  // 				if (controllerContainer.index != controllerIndex) {
  // 					return;
  // 				}
  // 				this.runTrigger({Object3D}, BASE_XR_EVENT_INDICES.get(eventName));
  // 			};
  // 			return listener;
  // 		};
  // 		listeners = {
  // 			[BaseXRSessionEventName.CONNECTED]: createListener(BaseXRSessionEventName.CONNECTED),
  // 			[BaseXRSessionEventName.DISCONNECTED]: createListener(BaseXRSessionEventName.DISCONNECTED),
  // 			[BaseXRSessionEventName.SELECT]: createListener(BaseXRSessionEventName.SELECT),
  // 			[BaseXRSessionEventName.SELECT_START]: createListener(BaseXRSessionEventName.SELECT_START),
  // 			[BaseXRSessionEventName.SELECT_END]: createListener(BaseXRSessionEventName.SELECT_END),
  // 		};
  // 		listenerByObject.set(Object3D, listeners);
  // 		const controller = xrController.getController(controllerIndex);
  // 		for (let eventName of BASE_XR_SESSION_EVENT_NAMES) {
  // 			controller.addEventListener(eventName, listeners[eventName]);
  // 		}
  // 	}
  // }
  dispose() {
    this._removeWebXREventListener();
    super.dispose();
  }
  _removeWebXREventListener() {
    const xrController = this.scene().webXR.activeXRController();
    if (!xrController) {
      return;
    }
    this._listenerByObjectByControllerIndex.forEach((listenerByObject, controllerIndex) => {
      const controller = xrController.getController(controllerIndex);
      listenerByObject.forEach((listeners, Object3D2) => {
        for (const eventName of webXR_Common/* BASE_XR_SESSION_EVENT_NAMES */.Rc) {
          controller.removeEventListener(eventName, listeners[eventName]);
        }
      });
    });
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/js/Or.ts



class OrJsNode extends BaseLogicOperationJsNode {
  static type() {
    return "or";
  }
  _expectedOutputName() {
    return "or";
  }
  _functionName(firstType) {
    return firstType == connections_Js/* JsConnectionPointType.BOOLEAN */.zF.BOOLEAN ? "orBooleans" : "orArrays";
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/js/Output.ts




class OutputJsParamsConfig extends params_ParamsConfig/* NodeParamsConfig */.yI {
}
const Output_ParamsConfig = new OutputJsParamsConfig();
class OutputJsNode extends js_Base/* TypedJsNode */.xZ {
  constructor() {
    super(...arguments);
    this.paramsConfig = Output_ParamsConfig;
  }
  static type() {
    return Js/* JsType.OUTPUT */.K.OUTPUT;
  }
  initializeNode() {
    super.initializeNode();
    this.lifecycle.onAfterAdded(() => {
      var _a, _b;
      (_b = (_a = this.functionNode()) == null ? void 0 : _a.assemblerController()) == null ? void 0 : _b.add_output_inputs(this);
    });
  }
  setLines(linesController) {
    var _a, _b;
    (_b = (_a = this.functionNode()) == null ? void 0 : _a.assemblerController()) == null ? void 0 : _b.assembler.setNodeLinesOutput(this, linesController);
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/js/OutputAmbientLight.ts







const OutputAmbientLight_CONNECTION_OPTIONS = connections_Js/* JS_CONNECTION_POINT_IN_NODE_DEF */.mX;
class OutputAmbientLightJsParamsConfig extends params_ParamsConfig/* NodeParamsConfig */.yI {
}
const OutputAmbientLight_ParamsConfig = new OutputAmbientLightJsParamsConfig();
class OutputAmbientLightJsNode extends js_Base/* TypedJsNode */.xZ {
  constructor() {
    super(...arguments);
    this.paramsConfig = OutputAmbientLight_ParamsConfig;
  }
  static type() {
    return Js/* JsType.OUTPUT_AMBIENT_LIGHT */.K.OUTPUT_AMBIENT_LIGHT;
  }
  initializeNode() {
    super.initializeNode();
    this.io.inputs.setNamedInputConnectionPoints([
      new connections_Js/* JsConnectionPoint */.fp(ObjectVariableLight.INTENSITY, connections_Js/* JsConnectionPointType.FLOAT */.zF.FLOAT, OutputAmbientLight_CONNECTION_OPTIONS),
      new connections_Js/* JsConnectionPoint */.fp(ObjectVariableLight.COLOR, connections_Js/* JsConnectionPointType.COLOR */.zF.COLOR, OutputAmbientLight_CONNECTION_OPTIONS)
    ]);
  }
  setLines(linesController) {
    const connectionPoints = this.io.inputs.namedInputConnectionPoints();
    if (!connectionPoints) {
      return;
    }
    const inputNames = connectionPoints.map((c) => c.name());
    const bodyLines = [];
    if (inputNames) {
      for (const inputName of inputNames) {
        const input = this.io.inputs.named_input(inputName);
        if (input) {
          const varName = this.variableForInput(linesController, inputName);
          switch (inputName) {
            case ObjectVariableLight.INTENSITY: {
              bodyLines.push(`${ObjectBuilderAssemblerCommon/* ObjectBuilderAssemblerConstant.OBJECT_3D */.F.OBJECT_3D}.${inputName} = ${varName}`);
              break;
            }
            case ObjectVariableLight.COLOR: {
              bodyLines.push(`
								if(${ObjectBuilderAssemblerCommon/* ObjectBuilderAssemblerConstant.OBJECT_3D */.F.OBJECT_3D}.${inputName} != null){
									${ObjectBuilderAssemblerCommon/* ObjectBuilderAssemblerConstant.OBJECT_3D */.F.OBJECT_3D}.${inputName}.copy(${varName})
								}`);
              break;
            }
          }
        }
      }
    }
    linesController._addBodyLines(this, bodyLines);
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/js/OutputAreaLight.ts







const OutputAreaLight_CONNECTION_OPTIONS = connections_Js/* JS_CONNECTION_POINT_IN_NODE_DEF */.mX;
class OutputAreaLightJsParamsConfig extends params_ParamsConfig/* NodeParamsConfig */.yI {
}
const OutputAreaLight_ParamsConfig = new OutputAreaLightJsParamsConfig();
class OutputAreaLightJsNode extends js_Base/* TypedJsNode */.xZ {
  constructor() {
    super(...arguments);
    this.paramsConfig = OutputAreaLight_ParamsConfig;
  }
  static type() {
    return Js/* JsType.OUTPUT_AREA_LIGHT */.K.OUTPUT_AREA_LIGHT;
  }
  initializeNode() {
    super.initializeNode();
    this.io.inputs.setNamedInputConnectionPoints([
      new connections_Js/* JsConnectionPoint */.fp(ObjectVariableLight.INTENSITY, connections_Js/* JsConnectionPointType.FLOAT */.zF.FLOAT, OutputAreaLight_CONNECTION_OPTIONS),
      new connections_Js/* JsConnectionPoint */.fp(ObjectVariableLight.COLOR, connections_Js/* JsConnectionPointType.COLOR */.zF.COLOR, OutputAreaLight_CONNECTION_OPTIONS),
      new connections_Js/* JsConnectionPoint */.fp(ObjectVariableAreaLight.WIDTH, connections_Js/* JsConnectionPointType.FLOAT */.zF.FLOAT, OutputAreaLight_CONNECTION_OPTIONS),
      new connections_Js/* JsConnectionPoint */.fp(ObjectVariableAreaLight.HEIGHT, connections_Js/* JsConnectionPointType.FLOAT */.zF.FLOAT, OutputAreaLight_CONNECTION_OPTIONS)
    ]);
  }
  setLines(linesController) {
    const connectionPoints = this.io.inputs.namedInputConnectionPoints();
    if (!connectionPoints) {
      return;
    }
    const inputNames = connectionPoints.map((c) => c.name());
    const bodyLines = [];
    if (inputNames) {
      for (const inputName of inputNames) {
        const input = this.io.inputs.named_input(inputName);
        if (input) {
          const varName = this.variableForInput(linesController, inputName);
          switch (inputName) {
            case ObjectVariableLight.INTENSITY:
            case ObjectVariableAreaLight.WIDTH:
            case ObjectVariableAreaLight.HEIGHT: {
              bodyLines.push(`${ObjectBuilderAssemblerCommon/* ObjectBuilderAssemblerConstant.OBJECT_3D */.F.OBJECT_3D}.${inputName} = ${varName}`);
              break;
            }
            case ObjectVariableLight.COLOR: {
              bodyLines.push(`
								if(${ObjectBuilderAssemblerCommon/* ObjectBuilderAssemblerConstant.OBJECT_3D */.F.OBJECT_3D}.${inputName} != null){
									${ObjectBuilderAssemblerCommon/* ObjectBuilderAssemblerConstant.OBJECT_3D */.F.OBJECT_3D}.${inputName}.copy(${varName})
								}`);
              break;
            }
          }
        }
      }
    }
    linesController._addBodyLines(this, bodyLines);
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/js/OutputDirectionalLight.ts








const OutputDirectionalLight_CONNECTION_OPTIONS = connections_Js/* JS_CONNECTION_POINT_IN_NODE_DEF */.mX;
class OutputDirectionalLightJsParamsConfig extends params_ParamsConfig/* NodeParamsConfig */.yI {
}
const OutputDirectionalLight_ParamsConfig = new OutputDirectionalLightJsParamsConfig();
class OutputDirectionalLightJsNode extends js_Base/* TypedJsNode */.xZ {
  constructor() {
    super(...arguments);
    this.paramsConfig = OutputDirectionalLight_ParamsConfig;
  }
  static type() {
    return Js/* JsType.OUTPUT_DIRECTIONAL_LIGHT */.K.OUTPUT_DIRECTIONAL_LIGHT;
  }
  initializeNode() {
    super.initializeNode();
    this.io.inputs.setNamedInputConnectionPoints([
      new connections_Js/* JsConnectionPoint */.fp(ObjectVariableLight.INTENSITY, connections_Js/* JsConnectionPointType.FLOAT */.zF.FLOAT, OutputDirectionalLight_CONNECTION_OPTIONS),
      new connections_Js/* JsConnectionPoint */.fp(ObjectVariableLight.COLOR, connections_Js/* JsConnectionPointType.COLOR */.zF.COLOR, OutputDirectionalLight_CONNECTION_OPTIONS),
      new connections_Js/* JsConnectionPoint */.fp(
        ObjectVariableDirectionalLight.DISTANCE,
        connections_Js/* JsConnectionPointType.FLOAT */.zF.FLOAT,
        OutputDirectionalLight_CONNECTION_OPTIONS
      ),
      new connections_Js/* JsConnectionPoint */.fp(
        ObjectVariableDirectionalLight.SHADOW_BIAS,
        connections_Js/* JsConnectionPointType.FLOAT */.zF.FLOAT,
        OutputDirectionalLight_CONNECTION_OPTIONS
      ),
      new connections_Js/* JsConnectionPoint */.fp(
        ObjectVariableDirectionalLight.SHADOW_RADIUS,
        connections_Js/* JsConnectionPointType.FLOAT */.zF.FLOAT,
        OutputDirectionalLight_CONNECTION_OPTIONS
      ),
      new connections_Js/* JsConnectionPoint */.fp(Common/* LightUserDataRaymarching.PENUMBRA */.W.PENUMBRA, connections_Js/* JsConnectionPointType.FLOAT */.zF.FLOAT, OutputDirectionalLight_CONNECTION_OPTIONS),
      new connections_Js/* JsConnectionPoint */.fp(
        Common/* LightUserDataRaymarching.SHADOW_BIAS_ANGLE */.W.SHADOW_BIAS_ANGLE,
        connections_Js/* JsConnectionPointType.FLOAT */.zF.FLOAT,
        OutputDirectionalLight_CONNECTION_OPTIONS
      ),
      new connections_Js/* JsConnectionPoint */.fp(
        Common/* LightUserDataRaymarching.SHADOW_BIAS_DISTANCE */.W.SHADOW_BIAS_DISTANCE,
        connections_Js/* JsConnectionPointType.FLOAT */.zF.FLOAT,
        OutputDirectionalLight_CONNECTION_OPTIONS
      )
    ]);
  }
  setLines(linesController) {
    const connectionPoints = this.io.inputs.namedInputConnectionPoints();
    if (!connectionPoints) {
      return;
    }
    const inputNames = connectionPoints.map((c) => c.name());
    const bodyLines = [];
    if (inputNames) {
      for (const inputName of inputNames) {
        const input = this.io.inputs.named_input(inputName);
        if (input) {
          const varName = this.variableForInput(linesController, inputName);
          switch (inputName) {
            case ObjectVariableLight.INTENSITY: {
              bodyLines.push(`${ObjectBuilderAssemblerCommon/* ObjectBuilderAssemblerConstant.OBJECT_3D */.F.OBJECT_3D}.${inputName} = ${varName}`);
              break;
            }
            case ObjectVariableDirectionalLight.DISTANCE: {
              bodyLines.push(
                `if(
										${ObjectBuilderAssemblerCommon/* ObjectBuilderAssemblerConstant.OBJECT_3D */.F.OBJECT_3D}.shadow != null &&
										${ObjectBuilderAssemblerCommon/* ObjectBuilderAssemblerConstant.OBJECT_3D */.F.OBJECT_3D}.shadow.camera != null &&
										${ObjectBuilderAssemblerCommon/* ObjectBuilderAssemblerConstant.OBJECT_3D */.F.OBJECT_3D}.shadow.camera.far != null ){
									${ObjectBuilderAssemblerCommon/* ObjectBuilderAssemblerConstant.OBJECT_3D */.F.OBJECT_3D}.shadow.camera.far = ${varName}
								}`
              );
              break;
            }
            case ObjectVariableDirectionalLight.SHADOW_BIAS:
            case ObjectVariableDirectionalLight.SHADOW_RADIUS: {
              const shadowParameter = inputName.replace("shadow", "").toLowerCase();
              bodyLines.push(`if(
						${ObjectBuilderAssemblerCommon/* ObjectBuilderAssemblerConstant.OBJECT_3D */.F.OBJECT_3D}.shadow != null &&
						${ObjectBuilderAssemblerCommon/* ObjectBuilderAssemblerConstant.OBJECT_3D */.F.OBJECT_3D}.shadow.${shadowParameter} != null )
						{
							${ObjectBuilderAssemblerCommon/* ObjectBuilderAssemblerConstant.OBJECT_3D */.F.OBJECT_3D}.shadow.${shadowParameter} = ${varName}
						}`);
              break;
            }
            case ObjectVariableLight.COLOR: {
              bodyLines.push(`
								if(${ObjectBuilderAssemblerCommon/* ObjectBuilderAssemblerConstant.OBJECT_3D */.F.OBJECT_3D}.${inputName} != null){
									${ObjectBuilderAssemblerCommon/* ObjectBuilderAssemblerConstant.OBJECT_3D */.F.OBJECT_3D}.${inputName}.copy(${varName})
								}`);
              break;
            }
            case Common/* LightUserDataRaymarching.PENUMBRA */.W.PENUMBRA:
            case Common/* LightUserDataRaymarching.SHADOW_BIAS_ANGLE */.W.SHADOW_BIAS_ANGLE:
            case Common/* LightUserDataRaymarching.SHADOW_BIAS_DISTANCE */.W.SHADOW_BIAS_DISTANCE: {
              bodyLines.push(
                `${ObjectBuilderAssemblerCommon/* ObjectBuilderAssemblerConstant.OBJECT_3D */.F.OBJECT_3D}.userData['${inputName}'] = ${varName}`
              );
              break;
            }
          }
        }
      }
    }
    linesController._addBodyLines(this, bodyLines);
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/js/OutputHemisphereLight.ts







const OutputHemisphereLight_CONNECTION_OPTIONS = connections_Js/* JS_CONNECTION_POINT_IN_NODE_DEF */.mX;
class OutputHemisphereLightJsParamsConfig extends params_ParamsConfig/* NodeParamsConfig */.yI {
}
const OutputHemisphereLight_ParamsConfig = new OutputHemisphereLightJsParamsConfig();
class OutputHemisphereLightJsNode extends js_Base/* TypedJsNode */.xZ {
  constructor() {
    super(...arguments);
    this.paramsConfig = OutputHemisphereLight_ParamsConfig;
  }
  static type() {
    return Js/* JsType.OUTPUT_HEMISPHERE_LIGHT */.K.OUTPUT_HEMISPHERE_LIGHT;
  }
  initializeNode() {
    super.initializeNode();
    this.io.inputs.setNamedInputConnectionPoints([
      new connections_Js/* JsConnectionPoint */.fp(ObjectVariableLight.INTENSITY, connections_Js/* JsConnectionPointType.FLOAT */.zF.FLOAT, OutputHemisphereLight_CONNECTION_OPTIONS),
      new connections_Js/* JsConnectionPoint */.fp(
        ObjectVariableHemisphereLight.SKY_COLOR,
        connections_Js/* JsConnectionPointType.COLOR */.zF.COLOR,
        OutputHemisphereLight_CONNECTION_OPTIONS
      ),
      new connections_Js/* JsConnectionPoint */.fp(
        ObjectVariableHemisphereLight.GROUND_COLOR,
        connections_Js/* JsConnectionPointType.COLOR */.zF.COLOR,
        OutputHemisphereLight_CONNECTION_OPTIONS
      )
    ]);
  }
  setLines(linesController) {
    const connectionPoints = this.io.inputs.namedInputConnectionPoints();
    if (!connectionPoints) {
      return;
    }
    const inputNames = connectionPoints.map((c) => c.name());
    const bodyLines = [];
    if (inputNames) {
      for (const inputName of inputNames) {
        const input = this.io.inputs.named_input(inputName);
        if (input) {
          const varName = this.variableForInput(linesController, inputName);
          switch (inputName) {
            case ObjectVariableLight.INTENSITY: {
              bodyLines.push(`${ObjectBuilderAssemblerCommon/* ObjectBuilderAssemblerConstant.OBJECT_3D */.F.OBJECT_3D}.${inputName} = ${varName}`);
              break;
            }
            case ObjectVariableHemisphereLight.SKY_COLOR:
            case ObjectVariableHemisphereLight.GROUND_COLOR: {
              const paramName = inputName == ObjectVariableHemisphereLight.SKY_COLOR ? "color" : "groundColor";
              bodyLines.push(`
								if(${ObjectBuilderAssemblerCommon/* ObjectBuilderAssemblerConstant.OBJECT_3D */.F.OBJECT_3D}.${paramName} != null){
									${ObjectBuilderAssemblerCommon/* ObjectBuilderAssemblerConstant.OBJECT_3D */.F.OBJECT_3D}.${paramName}.copy(${varName})
								}`);
              break;
            }
          }
        }
      }
    }
    linesController._addBodyLines(this, bodyLines);
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/js/OutputPointLight.ts








const OutputPointLight_CONNECTION_OPTIONS = connections_Js/* JS_CONNECTION_POINT_IN_NODE_DEF */.mX;
class OutputPointLightJsParamsConfig extends params_ParamsConfig/* NodeParamsConfig */.yI {
}
const OutputPointLight_ParamsConfig = new OutputPointLightJsParamsConfig();
class OutputPointLightJsNode extends js_Base/* TypedJsNode */.xZ {
  constructor() {
    super(...arguments);
    this.paramsConfig = OutputPointLight_ParamsConfig;
  }
  static type() {
    return Js/* JsType.OUTPUT_POINT_LIGHT */.K.OUTPUT_POINT_LIGHT;
  }
  initializeNode() {
    super.initializeNode();
    this.io.inputs.setNamedInputConnectionPoints([
      new connections_Js/* JsConnectionPoint */.fp(ObjectVariableLight.INTENSITY, connections_Js/* JsConnectionPointType.FLOAT */.zF.FLOAT, OutputPointLight_CONNECTION_OPTIONS),
      new connections_Js/* JsConnectionPoint */.fp(ObjectVariableLight.COLOR, connections_Js/* JsConnectionPointType.COLOR */.zF.COLOR, OutputPointLight_CONNECTION_OPTIONS),
      new connections_Js/* JsConnectionPoint */.fp(ObjectVariablePointLight.DECAY, connections_Js/* JsConnectionPointType.FLOAT */.zF.FLOAT, OutputPointLight_CONNECTION_OPTIONS),
      new connections_Js/* JsConnectionPoint */.fp(ObjectVariablePointLight.DISTANCE, connections_Js/* JsConnectionPointType.FLOAT */.zF.FLOAT, OutputPointLight_CONNECTION_OPTIONS),
      new connections_Js/* JsConnectionPoint */.fp(
        ObjectVariablePointLight.SHADOW_BIAS,
        connections_Js/* JsConnectionPointType.FLOAT */.zF.FLOAT,
        OutputPointLight_CONNECTION_OPTIONS
      ),
      new connections_Js/* JsConnectionPoint */.fp(
        ObjectVariablePointLight.SHADOW_NEAR,
        connections_Js/* JsConnectionPointType.FLOAT */.zF.FLOAT,
        OutputPointLight_CONNECTION_OPTIONS
      ),
      new connections_Js/* JsConnectionPoint */.fp(ObjectVariablePointLight.SHADOW_FAR, connections_Js/* JsConnectionPointType.FLOAT */.zF.FLOAT, OutputPointLight_CONNECTION_OPTIONS),
      new connections_Js/* JsConnectionPoint */.fp(Common/* LightUserDataRaymarching.PENUMBRA */.W.PENUMBRA, connections_Js/* JsConnectionPointType.FLOAT */.zF.FLOAT, OutputPointLight_CONNECTION_OPTIONS),
      new connections_Js/* JsConnectionPoint */.fp(
        Common/* LightUserDataRaymarching.SHADOW_BIAS_ANGLE */.W.SHADOW_BIAS_ANGLE,
        connections_Js/* JsConnectionPointType.FLOAT */.zF.FLOAT,
        OutputPointLight_CONNECTION_OPTIONS
      ),
      new connections_Js/* JsConnectionPoint */.fp(
        Common/* LightUserDataRaymarching.SHADOW_BIAS_DISTANCE */.W.SHADOW_BIAS_DISTANCE,
        connections_Js/* JsConnectionPointType.FLOAT */.zF.FLOAT,
        OutputPointLight_CONNECTION_OPTIONS
      )
    ]);
  }
  setLines(linesController) {
    const connectionPoints = this.io.inputs.namedInputConnectionPoints();
    if (!connectionPoints) {
      return;
    }
    const inputNames = connectionPoints.map((c) => c.name());
    const bodyLines = [];
    if (inputNames) {
      for (const inputName of inputNames) {
        const input = this.io.inputs.named_input(inputName);
        if (input) {
          const varName = this.variableForInput(linesController, inputName);
          switch (inputName) {
            case ObjectVariableLight.INTENSITY:
            case ObjectVariablePointLight.DECAY:
            case ObjectVariablePointLight.DISTANCE: {
              bodyLines.push(`${ObjectBuilderAssemblerCommon/* ObjectBuilderAssemblerConstant.OBJECT_3D */.F.OBJECT_3D}.${inputName} = ${varName}`);
              break;
            }
            case ObjectVariablePointLight.SHADOW_BIAS:
            case ObjectVariablePointLight.SHADOW_NEAR:
            case ObjectVariablePointLight.SHADOW_FAR: {
              const shadowParameter = inputName.replace("shadow", "").toLowerCase();
              bodyLines.push(`if(
						${ObjectBuilderAssemblerCommon/* ObjectBuilderAssemblerConstant.OBJECT_3D */.F.OBJECT_3D}.shadow != null &&
						${ObjectBuilderAssemblerCommon/* ObjectBuilderAssemblerConstant.OBJECT_3D */.F.OBJECT_3D}.shadow.${shadowParameter} != null )
						{
							${ObjectBuilderAssemblerCommon/* ObjectBuilderAssemblerConstant.OBJECT_3D */.F.OBJECT_3D}.shadow.${shadowParameter} = ${varName}
						}`);
              break;
            }
            case ObjectVariableLight.COLOR: {
              bodyLines.push(`
								if(${ObjectBuilderAssemblerCommon/* ObjectBuilderAssemblerConstant.OBJECT_3D */.F.OBJECT_3D}.${inputName} != null){
									${ObjectBuilderAssemblerCommon/* ObjectBuilderAssemblerConstant.OBJECT_3D */.F.OBJECT_3D}.${inputName}.copy(${varName})
								}`);
              break;
            }
            case Common/* LightUserDataRaymarching.PENUMBRA */.W.PENUMBRA:
            case Common/* LightUserDataRaymarching.SHADOW_BIAS_ANGLE */.W.SHADOW_BIAS_ANGLE:
            case Common/* LightUserDataRaymarching.SHADOW_BIAS_DISTANCE */.W.SHADOW_BIAS_DISTANCE: {
              bodyLines.push(
                `${ObjectBuilderAssemblerCommon/* ObjectBuilderAssemblerConstant.OBJECT_3D */.F.OBJECT_3D}.userData['${inputName}'] = ${varName}`
              );
              break;
            }
          }
        }
      }
    }
    linesController._addBodyLines(this, bodyLines);
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/js/OutputSpotLight.ts








const OutputSpotLight_CONNECTION_OPTIONS = connections_Js/* JS_CONNECTION_POINT_IN_NODE_DEF */.mX;
class OutputSpotLightJsParamsConfig extends params_ParamsConfig/* NodeParamsConfig */.yI {
}
const OutputSpotLight_ParamsConfig = new OutputSpotLightJsParamsConfig();
class OutputSpotLightJsNode extends js_Base/* TypedJsNode */.xZ {
  constructor() {
    super(...arguments);
    this.paramsConfig = OutputSpotLight_ParamsConfig;
  }
  static type() {
    return Js/* JsType.OUTPUT_SPOT_LIGHT */.K.OUTPUT_SPOT_LIGHT;
  }
  initializeNode() {
    super.initializeNode();
    this.io.inputs.setNamedInputConnectionPoints([
      new connections_Js/* JsConnectionPoint */.fp(ObjectVariableLight.INTENSITY, connections_Js/* JsConnectionPointType.FLOAT */.zF.FLOAT, OutputSpotLight_CONNECTION_OPTIONS),
      new connections_Js/* JsConnectionPoint */.fp(ObjectVariableLight.COLOR, connections_Js/* JsConnectionPointType.COLOR */.zF.COLOR, OutputSpotLight_CONNECTION_OPTIONS),
      new connections_Js/* JsConnectionPoint */.fp(ObjectVariableSpotLight.ANGLE, connections_Js/* JsConnectionPointType.FLOAT */.zF.FLOAT, OutputSpotLight_CONNECTION_OPTIONS),
      new connections_Js/* JsConnectionPoint */.fp(ObjectVariableSpotLight.PENUMBRA, connections_Js/* JsConnectionPointType.FLOAT */.zF.FLOAT, OutputSpotLight_CONNECTION_OPTIONS),
      new connections_Js/* JsConnectionPoint */.fp(ObjectVariableSpotLight.DECAY, connections_Js/* JsConnectionPointType.FLOAT */.zF.FLOAT, OutputSpotLight_CONNECTION_OPTIONS),
      new connections_Js/* JsConnectionPoint */.fp(ObjectVariableSpotLight.DISTANCE, connections_Js/* JsConnectionPointType.FLOAT */.zF.FLOAT, OutputSpotLight_CONNECTION_OPTIONS),
      new connections_Js/* JsConnectionPoint */.fp(ObjectVariableSpotLight.SHADOW_BIAS, connections_Js/* JsConnectionPointType.FLOAT */.zF.FLOAT, OutputSpotLight_CONNECTION_OPTIONS),
      new connections_Js/* JsConnectionPoint */.fp(ObjectVariableSpotLight.SHADOW_NEAR, connections_Js/* JsConnectionPointType.FLOAT */.zF.FLOAT, OutputSpotLight_CONNECTION_OPTIONS),
      new connections_Js/* JsConnectionPoint */.fp(ObjectVariableSpotLight.SHADOW_FAR, connections_Js/* JsConnectionPointType.FLOAT */.zF.FLOAT, OutputSpotLight_CONNECTION_OPTIONS),
      new connections_Js/* JsConnectionPoint */.fp(
        ObjectVariableSpotLight.SHADOW_RADIUS,
        connections_Js/* JsConnectionPointType.FLOAT */.zF.FLOAT,
        OutputSpotLight_CONNECTION_OPTIONS
      ),
      new connections_Js/* JsConnectionPoint */.fp(Common/* LightUserDataRaymarching.PENUMBRA */.W.PENUMBRA, connections_Js/* JsConnectionPointType.FLOAT */.zF.FLOAT, OutputSpotLight_CONNECTION_OPTIONS),
      new connections_Js/* JsConnectionPoint */.fp(
        Common/* LightUserDataRaymarching.SHADOW_BIAS_ANGLE */.W.SHADOW_BIAS_ANGLE,
        connections_Js/* JsConnectionPointType.FLOAT */.zF.FLOAT,
        OutputSpotLight_CONNECTION_OPTIONS
      ),
      new connections_Js/* JsConnectionPoint */.fp(
        Common/* LightUserDataRaymarching.SHADOW_BIAS_DISTANCE */.W.SHADOW_BIAS_DISTANCE,
        connections_Js/* JsConnectionPointType.FLOAT */.zF.FLOAT,
        OutputSpotLight_CONNECTION_OPTIONS
      )
    ]);
  }
  setLines(linesController) {
    const connectionPoints = this.io.inputs.namedInputConnectionPoints();
    if (!connectionPoints) {
      return;
    }
    const inputNames = connectionPoints.map((c) => c.name());
    const bodyLines = [];
    if (inputNames) {
      for (const inputName of inputNames) {
        const input = this.io.inputs.named_input(inputName);
        if (input) {
          const varName = this.variableForInput(linesController, inputName);
          switch (inputName) {
            case ObjectVariableLight.INTENSITY:
            case ObjectVariableSpotLight.ANGLE:
            case ObjectVariableSpotLight.PENUMBRA:
            case ObjectVariableSpotLight.DECAY:
            case ObjectVariableSpotLight.DISTANCE: {
              bodyLines.push(`${ObjectBuilderAssemblerCommon/* ObjectBuilderAssemblerConstant.OBJECT_3D */.F.OBJECT_3D}.${inputName} = ${varName}`);
              break;
            }
            case ObjectVariableSpotLight.SHADOW_BIAS:
            case ObjectVariableSpotLight.SHADOW_NEAR:
            case ObjectVariableSpotLight.SHADOW_FAR:
            case ObjectVariableSpotLight.SHADOW_RADIUS: {
              const shadowParameter = inputName.replace("shadow", "").toLowerCase();
              bodyLines.push(`if(
						${ObjectBuilderAssemblerCommon/* ObjectBuilderAssemblerConstant.OBJECT_3D */.F.OBJECT_3D}.shadow != null &&
						${ObjectBuilderAssemblerCommon/* ObjectBuilderAssemblerConstant.OBJECT_3D */.F.OBJECT_3D}.shadow.${shadowParameter} != null )
						{
							${ObjectBuilderAssemblerCommon/* ObjectBuilderAssemblerConstant.OBJECT_3D */.F.OBJECT_3D}.shadow.${shadowParameter} = ${varName}
						}`);
              break;
            }
            case ObjectVariableLight.COLOR: {
              bodyLines.push(`
								if(${ObjectBuilderAssemblerCommon/* ObjectBuilderAssemblerConstant.OBJECT_3D */.F.OBJECT_3D}.${inputName} != null){
									${ObjectBuilderAssemblerCommon/* ObjectBuilderAssemblerConstant.OBJECT_3D */.F.OBJECT_3D}.${inputName}.copy(${varName})
								}`);
              break;
            }
            case Common/* LightUserDataRaymarching.PENUMBRA */.W.PENUMBRA:
            case Common/* LightUserDataRaymarching.SHADOW_BIAS_ANGLE */.W.SHADOW_BIAS_ANGLE:
            case Common/* LightUserDataRaymarching.SHADOW_BIAS_DISTANCE */.W.SHADOW_BIAS_DISTANCE: {
              bodyLines.push(
                `${ObjectBuilderAssemblerCommon/* ObjectBuilderAssemblerConstant.OBJECT_3D */.F.OBJECT_3D}.userData['${inputName}'] = ${varName}`
              );
              break;
            }
          }
        }
      }
    }
    linesController._addBodyLines(this, bodyLines);
  }
}

// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/nodes/js/Param.ts
var js_Param = __webpack_require__(27568);
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/js/ParticlesSystemReset.ts




class ParticlesSystemResetJsNode extends _BaseTriggerAndObject/* ParamlessBaseTriggerAndObjectJsNode */.c {
  static type() {
    return "particlesSystemReset";
  }
  setTriggerableLines(shadersCollectionController) {
    const object3D = (0,_BaseObject3D/* inputObject3D */.iv)(this, shadersCollectionController);
    const func = Poly/* Poly.namedFunctionsRegister.getFunction */.L.namedFunctionsRegister.getFunction("particlesSystemReset", this, shadersCollectionController);
    const bodyLine = func.asString(object3D);
    shadersCollectionController.addTriggerableLines(this, [bodyLine]);
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/utils/poly/PolyNodeParamsConfig.ts


class PolyNodeParamsConfig {
  static ParamsConfig(data, paramsConfig = new params_ParamsConfig/* NodeParamsConfig */.yI()) {
    if (data.params) {
      for (const paramData of data.params) {
        const paramName = paramData.name;
        const paramType = paramData.type;
        const initValue = paramData.initValue;
        const options = paramData.options;
        paramsConfig[paramName] = new params_ParamsConfig/* ParamTemplate */.oC(paramType, initValue, options);
      }
    }
    return paramsConfig;
  }
}

// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/nodes/gl/code/utils/TextureAllocation.ts
var TextureAllocation = __webpack_require__(86456);
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/js/ParticlesSystemStepSimulation.ts

var ParticlesSystemStepSimulation_defProp = Object.defineProperty;
var ParticlesSystemStepSimulation_getOwnPropSymbols = Object.getOwnPropertySymbols;
var ParticlesSystemStepSimulation_hasOwnProp = Object.prototype.hasOwnProperty;
var ParticlesSystemStepSimulation_propIsEnum = Object.prototype.propertyIsEnumerable;
var ParticlesSystemStepSimulation_defNormalProp = (obj, key, value) => key in obj ? ParticlesSystemStepSimulation_defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var ParticlesSystemStepSimulation_spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (ParticlesSystemStepSimulation_hasOwnProp.call(b, prop))
      ParticlesSystemStepSimulation_defNormalProp(a, prop, b[prop]);
  if (ParticlesSystemStepSimulation_getOwnPropSymbols)
    for (var prop of ParticlesSystemStepSimulation_getOwnPropSymbols(b)) {
      if (ParticlesSystemStepSimulation_propIsEnum.call(b, prop))
        ParticlesSystemStepSimulation_defNormalProp(a, prop, b[prop]);
    }
  return a;
};









function visibleIfTexturessCountAtLeast(index) {
  return {
    visibleIf: (0,ArrayUtils/* rangeStartEnd */.Dr)(index + 1, 10).map((i) => ({ texturesCount: i }))
  };
}
function textureNameParam(index) {
  return params_ParamsConfig/* ParamConfig.STRING */.XC.STRING("", ParticlesSystemStepSimulation_spreadValues({}, visibleIfTexturessCountAtLeast(index)));
}
class ParticlesSystemStepSimulationJsParamsConfig extends PolyNodeParamsConfig {
  constructor() {
    super(...arguments);
    this.texturesCount = params_ParamsConfig/* ParamConfig.INTEGER */.XC.INTEGER(1, {
      range: [0, 10],
      rangeLocked: [true, false]
    });
    this.textureName0 = textureNameParam(0);
    this.textureName1 = textureNameParam(1);
    this.textureName2 = textureNameParam(2);
    this.textureName3 = textureNameParam(3);
    this.textureName4 = textureNameParam(4);
    this.textureName5 = textureNameParam(5);
    this.textureName6 = textureNameParam(6);
    this.textureName7 = textureNameParam(7);
    this.textureName8 = textureNameParam(8);
    this.textureName9 = textureNameParam(9);
  }
}
const ParticlesSystemStepSimulation_ParamsConfig = new ParticlesSystemStepSimulationJsParamsConfig();
class ParticlesSystemStepSimulationJsNode extends js_Base/* TypedJsNode */.xZ {
  constructor() {
    super(...arguments);
    this.paramsConfig = ParticlesSystemStepSimulation_ParamsConfig;
  }
  static type() {
    return "particlesSystemStepSimulation";
  }
  initializeNode() {
    this.io.connection_points.set_input_name_function(this._expectedInputName.bind(this));
    this.io.connection_points.set_expected_input_types_function(this._expectedInputTypes.bind(this));
    this.io.connection_points.set_expected_output_types_function(this._expectedOutputTypes.bind(this));
    this.io.connection_points.set_output_name_function(this._expectedOutputName.bind(this));
  }
  _textureNameParams() {
    return [
      this.p.textureName0,
      this.p.textureName1,
      this.p.textureName2,
      this.p.textureName3,
      this.p.textureName4,
      this.p.textureName5,
      this.p.textureName6,
      this.p.textureName7,
      this.p.textureName8,
      this.p.textureName9
    ];
  }
  setTextureName(index, textureName) {
    const param = this._textureNameParams()[index];
    if (!param) {
      return;
    }
    param.set(textureName);
  }
  _expectedInputTypes() {
    return [connections_Js/* JsConnectionPointType.TRIGGER */.zF.TRIGGER, connections_Js/* JsConnectionPointType.OBJECT_3D */.zF.OBJECT_3D];
  }
  _expectedInputName(index) {
    return this._expectedInputTypes()[index];
  }
  _expectedOutputTypes() {
    const count = this.pv.texturesCount;
    return this._expectedInputTypes().concat(
      (0,ArrayUtils/* rangeStartEnd */.Dr)(0, count).map((value, i) => connections_Js/* JsConnectionPointType.TEXTURE */.zF.TEXTURE)
    );
  }
  _expectedOutputName(index) {
    if (index <= 1) {
      return this._expectedInputName(index);
    } else {
      return this._textureNameParams()[index - 2].value;
    }
  }
  setLines(linesController) {
    this._addRefs(linesController);
    (0,_BaseObject3D/* setObject3DOutputLine */.PV)(this, linesController);
  }
  setTriggerableLines(linesController) {
    const object3D = (0,_BaseObject3D/* inputObject3D */.iv)(this, linesController);
    const configRef = this._addRefs(linesController);
    const func = Poly/* Poly.namedFunctionsRegister.getFunction */.L.namedFunctionsRegister.getFunction("particlesSystemStepSimulation", this, linesController);
    const bodyLine = func.asString(object3D, this._refToString(configRef));
    linesController.addTriggerableLines(this, [bodyLine]);
  }
  _refToString(refs) {
    const keys = Object.keys(refs);
    const data = [];
    for (const key of keys) {
      data.push(`${key}:this.${refs[key]}`);
    }
    return `{${data.join(",")}}`;
  }
  _addRefs(linesController) {
    const count = this.pv.texturesCount;
    const textureParams = this._textureNameParams();
    const textureNames = (0,ArrayUtils/* rangeStartEnd */.Dr)(0, count).map((value, i) => `${textureParams[i].value}`);
    const varNames = textureNames.map((textureName) => this.jsVarName(textureName));
    for (const texture of varNames) {
      linesController.addDefinitions(this, [
        new JsDefinition/* ConstantJsDefinition */.mF(this, linesController, connections_Js/* JsConnectionPointType.TEXTURE */.zF.TEXTURE, texture, `null`)
      ]);
    }
    const ref = {};
    for (let i = 0; i < count; i++) {
      const textureName = textureNames[i];
      const textureNameWithPrefix = `${TextureAllocation/* TEXTURE_ALLOCATION_PREFIX */.b$}${textureName}`;
      const varName = varNames[i];
      ref[textureNameWithPrefix] = varName;
    }
    return ref;
  }
}

// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/nodes/js/PauseAudioSource.ts
var PauseAudioSource = __webpack_require__(2794);
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/js/PhysicsDebugUpdate.ts




class PhysicsDebugUpdateJsNode extends _BaseTriggerAndObject/* ParamlessBaseTriggerAndObjectJsNode */.c {
  static type() {
    return "physicsDebugUpdate";
  }
  setTriggerableLines(shadersCollectionController) {
    const object3D = (0,_BaseObject3D/* inputObject3D */.iv)(this, shadersCollectionController);
    const func = Poly/* Poly.namedFunctionsRegister.getFunction */.L.namedFunctionsRegister.getFunction("physicsDebugUpdate", this, shadersCollectionController);
    const bodyLine = func.asString(object3D);
    shadersCollectionController.addTriggerableLines(this, [bodyLine]);
  }
}

// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/core/player/PlayerCommon.ts
var PlayerCommon = __webpack_require__(52729);
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/js/PhysicsPlayerUpdate.ts







const PhysicsPlayerUpdate_CONNECTION_OPTIONS = connections_Js/* JS_CONNECTION_POINT_IN_NODE_DEF */.mX;
class PhysicsPlayerUpdateJsParamsConfig extends params_ParamsConfig/* NodeParamsConfig */.yI {
  constructor() {
    super(...arguments);
    /** @param travel speed */
    this.speed = params_ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(0.5, {
      range: [0, 10],
      rangeLocked: [true, false]
    });
    /** @param run Allowed */
    this.runAllowed = params_ParamsConfig/* ParamConfig.BOOLEAN */.XC.BOOLEAN(true);
    /** @param jump Force */
    this.runSpeedMult = params_ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(3, {
      range: [0, 10],
      rangeLocked: [true, false],
      visibleIf: { runAllowed: 1 }
    });
    /** @param jump Allowed */
    this.jumpAllowed = params_ParamsConfig/* ParamConfig.BOOLEAN */.XC.BOOLEAN(true);
    /** @param jump Force */
    this.jumpStrength = params_ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(0.2, {
      range: [0, 10],
      rangeLocked: [true, false],
      visibleIf: { jumpAllowed: 1 }
    });
    /** @param reset if position is below a threshold */
    this.resetIfBelowThreshold = params_ParamsConfig/* ParamConfig.BOOLEAN */.XC.BOOLEAN(true);
    /** @param height under which the player gets reset */
    this.resetThreshold = params_ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(-5, {
      range: [-10, 10],
      rangeLocked: [false, false],
      visibleIf: { resetIfBelowThreshold: 1 }
    });
  }
}
const PhysicsPlayerUpdate_ParamsConfig = new PhysicsPlayerUpdateJsParamsConfig();
class PhysicsPlayerUpdateJsNode extends js_Base/* TypedJsNode */.xZ {
  constructor() {
    super(...arguments);
    this.paramsConfig = PhysicsPlayerUpdate_ParamsConfig;
  }
  static type() {
    return "physicsPlayerUpdate";
  }
  initializeNode() {
    this.io.inputs.setNamedInputConnectionPoints([
      new connections_Js/* JsConnectionPoint */.fp(js_Base/* TRIGGER_CONNECTION_NAME */.w6, connections_Js/* JsConnectionPointType.TRIGGER */.zF.TRIGGER, PhysicsPlayerUpdate_CONNECTION_OPTIONS),
      new connections_Js/* JsConnectionPoint */.fp(connections_Js/* JsConnectionPointType.OBJECT_3D */.zF.OBJECT_3D, connections_Js/* JsConnectionPointType.OBJECT_3D */.zF.OBJECT_3D, PhysicsPlayerUpdate_CONNECTION_OPTIONS),
      ...PlayerCommon/* CORE_PLAYER_INPUTS.map */.o.map(
        (inputName) => new connections_Js/* JsConnectionPoint */.fp(inputName, connections_Js/* JsConnectionPointType.BOOLEAN */.zF.BOOLEAN, PhysicsPlayerUpdate_CONNECTION_OPTIONS)
      )
    ]);
    this.io.outputs.setNamedOutputConnectionPoints([
      new connections_Js/* JsConnectionPoint */.fp(js_Base/* TRIGGER_CONNECTION_NAME */.w6, connections_Js/* JsConnectionPointType.TRIGGER */.zF.TRIGGER)
    ]);
  }
  setTriggerableLines(shadersCollectionController) {
    const object3D = (0,_BaseObject3D/* inputObject3D */.iv)(this, shadersCollectionController);
    const data = {};
    PlayerCommon/* CORE_PLAYER_INPUTS.forEach */.o.forEach((inputName) => {
      data[inputName] = this.variableForInput(shadersCollectionController, inputName);
    });
    const params = [
      this.p.speed,
      this.p.runAllowed,
      this.p.runSpeedMult,
      this.p.jumpAllowed,
      this.p.jumpStrength,
      this.p.resetIfBelowThreshold,
      this.p.resetThreshold
    ];
    params.forEach((param) => {
      data[param.name()] = this.variableForInputParam(shadersCollectionController, param);
    });
    const coreInputDict = JSON.stringify(data).replace(/\"/g, "");
    const func = Poly/* Poly.namedFunctionsRegister.getFunction */.L.namedFunctionsRegister.getFunction("playerPhysicsUpdate", this, shadersCollectionController);
    const bodyLine = func.asString(object3D, coreInputDict);
    shadersCollectionController.addTriggerableLines(this, [bodyLine]);
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/js/PhysicsRBDAddForce.ts







const PhysicsRBDAddForce_CONNECTION_OPTIONS = connections_Js/* JS_CONNECTION_POINT_IN_NODE_DEF */.mX;
class PhysicsRBDAddForceJsParamsConfig extends params_ParamsConfig/* NodeParamsConfig */.yI {
  constructor() {
    super(...arguments);
    /** @param force */
    this.force = params_ParamsConfig/* ParamConfig.VECTOR3 */.XC.VECTOR3([0, 0, 0]);
  }
}
const PhysicsRBDAddForce_ParamsConfig = new PhysicsRBDAddForceJsParamsConfig();
class PhysicsRBDAddForceJsNode extends js_Base/* TypedJsNode */.xZ {
  constructor() {
    super(...arguments);
    this.paramsConfig = PhysicsRBDAddForce_ParamsConfig;
  }
  static type() {
    return "physicsRBDAddForce";
  }
  initializeNode() {
    this.io.inputs.setNamedInputConnectionPoints([
      new connections_Js/* JsConnectionPoint */.fp(js_Base/* TRIGGER_CONNECTION_NAME */.w6, connections_Js/* JsConnectionPointType.TRIGGER */.zF.TRIGGER, PhysicsRBDAddForce_CONNECTION_OPTIONS),
      new connections_Js/* JsConnectionPoint */.fp(connections_Js/* JsConnectionPointType.OBJECT_3D */.zF.OBJECT_3D, connections_Js/* JsConnectionPointType.OBJECT_3D */.zF.OBJECT_3D, PhysicsRBDAddForce_CONNECTION_OPTIONS)
    ]);
    this.io.outputs.setNamedOutputConnectionPoints([
      new connections_Js/* JsConnectionPoint */.fp(js_Base/* TRIGGER_CONNECTION_NAME */.w6, connections_Js/* JsConnectionPointType.TRIGGER */.zF.TRIGGER),
      new connections_Js/* JsConnectionPoint */.fp(connections_Js/* JsConnectionPointType.OBJECT_3D */.zF.OBJECT_3D, connections_Js/* JsConnectionPointType.OBJECT_3D */.zF.OBJECT_3D, PhysicsRBDAddForce_CONNECTION_OPTIONS)
    ]);
  }
  setTriggerableLines(shadersCollectionController) {
    const object3D = (0,_BaseObject3D/* inputObject3D */.iv)(this, shadersCollectionController);
    const force = this.variableForInputParam(shadersCollectionController, this.p.force);
    const func = Poly/* Poly.namedFunctionsRegister.getFunction */.L.namedFunctionsRegister.getFunction("physicsRBDAddForce", this, shadersCollectionController);
    const bodyLine = func.asString(object3D, force);
    shadersCollectionController.addTriggerableLines(this, [bodyLine]);
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/js/PhysicsRBDAddForceAtPoint.ts







const PhysicsRBDAddForceAtPoint_CONNECTION_OPTIONS = connections_Js/* JS_CONNECTION_POINT_IN_NODE_DEF */.mX;
class PhysicsRBDAddForceAtPointJsParamsConfig extends params_ParamsConfig/* NodeParamsConfig */.yI {
  constructor() {
    super(...arguments);
    /** @param force */
    this.force = params_ParamsConfig/* ParamConfig.VECTOR3 */.XC.VECTOR3([0, 0, 0]);
    /** @param point */
    this.point = params_ParamsConfig/* ParamConfig.VECTOR3 */.XC.VECTOR3([0, 0, 0]);
  }
}
const PhysicsRBDAddForceAtPoint_ParamsConfig = new PhysicsRBDAddForceAtPointJsParamsConfig();
class PhysicsRBDAddForceAtPointJsNode extends js_Base/* TypedJsNode */.xZ {
  constructor() {
    super(...arguments);
    this.paramsConfig = PhysicsRBDAddForceAtPoint_ParamsConfig;
  }
  static type() {
    return "physicsRBDAddForceAtPoint";
  }
  initializeNode() {
    this.io.inputs.setNamedInputConnectionPoints([
      new connections_Js/* JsConnectionPoint */.fp(js_Base/* TRIGGER_CONNECTION_NAME */.w6, connections_Js/* JsConnectionPointType.TRIGGER */.zF.TRIGGER, PhysicsRBDAddForceAtPoint_CONNECTION_OPTIONS),
      new connections_Js/* JsConnectionPoint */.fp(connections_Js/* JsConnectionPointType.OBJECT_3D */.zF.OBJECT_3D, connections_Js/* JsConnectionPointType.OBJECT_3D */.zF.OBJECT_3D, PhysicsRBDAddForceAtPoint_CONNECTION_OPTIONS)
    ]);
    this.io.outputs.setNamedOutputConnectionPoints([
      new connections_Js/* JsConnectionPoint */.fp(js_Base/* TRIGGER_CONNECTION_NAME */.w6, connections_Js/* JsConnectionPointType.TRIGGER */.zF.TRIGGER),
      new connections_Js/* JsConnectionPoint */.fp(connections_Js/* JsConnectionPointType.OBJECT_3D */.zF.OBJECT_3D, connections_Js/* JsConnectionPointType.OBJECT_3D */.zF.OBJECT_3D, PhysicsRBDAddForceAtPoint_CONNECTION_OPTIONS)
    ]);
  }
  setTriggerableLines(shadersCollectionController) {
    const object3D = (0,_BaseObject3D/* inputObject3D */.iv)(this, shadersCollectionController);
    const force = this.variableForInputParam(shadersCollectionController, this.p.force);
    const point = this.variableForInputParam(shadersCollectionController, this.p.point);
    const func = Poly/* Poly.namedFunctionsRegister.getFunction */.L.namedFunctionsRegister.getFunction(
      "physicsRBDAddForceAtPoint",
      this,
      shadersCollectionController
    );
    const bodyLine = func.asString(object3D, force, point);
    shadersCollectionController.addTriggerableLines(this, [bodyLine]);
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/js/PhysicsRBDAddTorque.ts







const PhysicsRBDAddTorque_CONNECTION_OPTIONS = connections_Js/* JS_CONNECTION_POINT_IN_NODE_DEF */.mX;
class PhysicsRBDAddTorqueJsParamsConfig extends params_ParamsConfig/* NodeParamsConfig */.yI {
  constructor() {
    super(...arguments);
    /** @param torque */
    this.torque = params_ParamsConfig/* ParamConfig.VECTOR3 */.XC.VECTOR3([0, 0, 0]);
  }
}
const PhysicsRBDAddTorque_ParamsConfig = new PhysicsRBDAddTorqueJsParamsConfig();
class PhysicsRBDAddTorqueJsNode extends js_Base/* TypedJsNode */.xZ {
  constructor() {
    super(...arguments);
    this.paramsConfig = PhysicsRBDAddTorque_ParamsConfig;
  }
  static type() {
    return "physicsRBDAddTorque";
  }
  initializeNode() {
    this.io.inputs.setNamedInputConnectionPoints([
      new connections_Js/* JsConnectionPoint */.fp(js_Base/* TRIGGER_CONNECTION_NAME */.w6, connections_Js/* JsConnectionPointType.TRIGGER */.zF.TRIGGER, PhysicsRBDAddTorque_CONNECTION_OPTIONS),
      new connections_Js/* JsConnectionPoint */.fp(connections_Js/* JsConnectionPointType.OBJECT_3D */.zF.OBJECT_3D, connections_Js/* JsConnectionPointType.OBJECT_3D */.zF.OBJECT_3D, PhysicsRBDAddTorque_CONNECTION_OPTIONS)
    ]);
    this.io.outputs.setNamedOutputConnectionPoints([
      new connections_Js/* JsConnectionPoint */.fp(js_Base/* TRIGGER_CONNECTION_NAME */.w6, connections_Js/* JsConnectionPointType.TRIGGER */.zF.TRIGGER),
      new connections_Js/* JsConnectionPoint */.fp(connections_Js/* JsConnectionPointType.OBJECT_3D */.zF.OBJECT_3D, connections_Js/* JsConnectionPointType.OBJECT_3D */.zF.OBJECT_3D, PhysicsRBDAddTorque_CONNECTION_OPTIONS)
    ]);
  }
  setTriggerableLines(shadersCollectionController) {
    const object3D = (0,_BaseObject3D/* inputObject3D */.iv)(this, shadersCollectionController);
    const torque = this.variableForInputParam(shadersCollectionController, this.p.torque);
    const func = Poly/* Poly.namedFunctionsRegister.getFunction */.L.namedFunctionsRegister.getFunction("physicsRBDAddTorque", this, shadersCollectionController);
    const bodyLine = func.asString(object3D, torque);
    shadersCollectionController.addTriggerableLines(this, [bodyLine]);
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/js/PhysicsRBDApplyImpulse.ts







const PhysicsRBDApplyImpulse_CONNECTION_OPTIONS = connections_Js/* JS_CONNECTION_POINT_IN_NODE_DEF */.mX;
class PhysicsRBDApplyImpulseJsParamsConfig extends params_ParamsConfig/* NodeParamsConfig */.yI {
  constructor() {
    super(...arguments);
    /** @param impulse */
    this.impulse = params_ParamsConfig/* ParamConfig.VECTOR3 */.XC.VECTOR3([0, 0, 0]);
  }
}
const PhysicsRBDApplyImpulse_ParamsConfig = new PhysicsRBDApplyImpulseJsParamsConfig();
class PhysicsRBDApplyImpulseJsNode extends js_Base/* TypedJsNode */.xZ {
  constructor() {
    super(...arguments);
    this.paramsConfig = PhysicsRBDApplyImpulse_ParamsConfig;
  }
  static type() {
    return "physicsRBDApplyImpulse";
  }
  initializeNode() {
    this.io.inputs.setNamedInputConnectionPoints([
      new connections_Js/* JsConnectionPoint */.fp(js_Base/* TRIGGER_CONNECTION_NAME */.w6, connections_Js/* JsConnectionPointType.TRIGGER */.zF.TRIGGER, PhysicsRBDApplyImpulse_CONNECTION_OPTIONS),
      new connections_Js/* JsConnectionPoint */.fp(connections_Js/* JsConnectionPointType.OBJECT_3D */.zF.OBJECT_3D, connections_Js/* JsConnectionPointType.OBJECT_3D */.zF.OBJECT_3D, PhysicsRBDApplyImpulse_CONNECTION_OPTIONS)
    ]);
    this.io.outputs.setNamedOutputConnectionPoints([
      new connections_Js/* JsConnectionPoint */.fp(js_Base/* TRIGGER_CONNECTION_NAME */.w6, connections_Js/* JsConnectionPointType.TRIGGER */.zF.TRIGGER),
      new connections_Js/* JsConnectionPoint */.fp(connections_Js/* JsConnectionPointType.OBJECT_3D */.zF.OBJECT_3D, connections_Js/* JsConnectionPointType.OBJECT_3D */.zF.OBJECT_3D, PhysicsRBDApplyImpulse_CONNECTION_OPTIONS)
    ]);
  }
  setTriggerableLines(shadersCollectionController) {
    const object3D = (0,_BaseObject3D/* inputObject3D */.iv)(this, shadersCollectionController);
    const impulse = this.variableForInputParam(shadersCollectionController, this.p.impulse);
    const func = Poly/* Poly.namedFunctionsRegister.getFunction */.L.namedFunctionsRegister.getFunction(
      "physicsRBDApplyImpulse",
      this,
      shadersCollectionController
    );
    const bodyLine = func.asString(object3D, impulse);
    shadersCollectionController.addTriggerableLines(this, [bodyLine]);
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/js/PhysicsRBDApplyTorqueImpulse.ts







const PhysicsRBDApplyTorqueImpulse_CONNECTION_OPTIONS = connections_Js/* JS_CONNECTION_POINT_IN_NODE_DEF */.mX;
class PhysicsRBDApplyTorqueImpulseJsParamsConfig extends params_ParamsConfig/* NodeParamsConfig */.yI {
  constructor() {
    super(...arguments);
    /** @param impulse */
    this.impulse = params_ParamsConfig/* ParamConfig.VECTOR3 */.XC.VECTOR3([0, 0, 0]);
  }
}
const PhysicsRBDApplyTorqueImpulse_ParamsConfig = new PhysicsRBDApplyTorqueImpulseJsParamsConfig();
class PhysicsRBDApplyTorqueImpulseJsNode extends js_Base/* TypedJsNode */.xZ {
  constructor() {
    super(...arguments);
    this.paramsConfig = PhysicsRBDApplyTorqueImpulse_ParamsConfig;
  }
  static type() {
    return "physicsRBDApplyTorqueImpulse";
  }
  initializeNode() {
    this.io.inputs.setNamedInputConnectionPoints([
      new connections_Js/* JsConnectionPoint */.fp(js_Base/* TRIGGER_CONNECTION_NAME */.w6, connections_Js/* JsConnectionPointType.TRIGGER */.zF.TRIGGER, PhysicsRBDApplyTorqueImpulse_CONNECTION_OPTIONS),
      new connections_Js/* JsConnectionPoint */.fp(connections_Js/* JsConnectionPointType.OBJECT_3D */.zF.OBJECT_3D, connections_Js/* JsConnectionPointType.OBJECT_3D */.zF.OBJECT_3D, PhysicsRBDApplyTorqueImpulse_CONNECTION_OPTIONS)
    ]);
    this.io.outputs.setNamedOutputConnectionPoints([
      new connections_Js/* JsConnectionPoint */.fp(js_Base/* TRIGGER_CONNECTION_NAME */.w6, connections_Js/* JsConnectionPointType.TRIGGER */.zF.TRIGGER),
      new connections_Js/* JsConnectionPoint */.fp(connections_Js/* JsConnectionPointType.OBJECT_3D */.zF.OBJECT_3D, connections_Js/* JsConnectionPointType.OBJECT_3D */.zF.OBJECT_3D, PhysicsRBDApplyTorqueImpulse_CONNECTION_OPTIONS)
    ]);
  }
  setTriggerableLines(shadersCollectionController) {
    const object3D = (0,_BaseObject3D/* inputObject3D */.iv)(this, shadersCollectionController);
    const impulse = this.variableForInputParam(shadersCollectionController, this.p.impulse);
    const func = Poly/* Poly.namedFunctionsRegister.getFunction */.L.namedFunctionsRegister.getFunction(
      "physicsRBDApplyTorqueImpulse",
      this,
      shadersCollectionController
    );
    const bodyLine = func.asString(object3D, impulse);
    shadersCollectionController.addTriggerableLines(this, [bodyLine]);
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/js/PhysicsRBDApplyImpulseAtPoint.ts







const PhysicsRBDApplyImpulseAtPoint_CONNECTION_OPTIONS = connections_Js/* JS_CONNECTION_POINT_IN_NODE_DEF */.mX;
class PhysicsRBDApplyImpulseAtPointJsParamsConfig extends params_ParamsConfig/* NodeParamsConfig */.yI {
  constructor() {
    super(...arguments);
    /** @param impulse */
    this.impulse = params_ParamsConfig/* ParamConfig.VECTOR3 */.XC.VECTOR3([0, 0, 0]);
    /** @param point */
    this.point = params_ParamsConfig/* ParamConfig.VECTOR3 */.XC.VECTOR3([0, 0, 0]);
  }
}
const PhysicsRBDApplyImpulseAtPoint_ParamsConfig = new PhysicsRBDApplyImpulseAtPointJsParamsConfig();
class PhysicsRBDApplyImpulseAtPointJsNode extends js_Base/* TypedJsNode */.xZ {
  constructor() {
    super(...arguments);
    this.paramsConfig = PhysicsRBDApplyImpulseAtPoint_ParamsConfig;
  }
  static type() {
    return "physicsRBDApplyImpulseAtPoint";
  }
  initializeNode() {
    this.io.inputs.setNamedInputConnectionPoints([
      new connections_Js/* JsConnectionPoint */.fp(js_Base/* TRIGGER_CONNECTION_NAME */.w6, connections_Js/* JsConnectionPointType.TRIGGER */.zF.TRIGGER, PhysicsRBDApplyImpulseAtPoint_CONNECTION_OPTIONS),
      new connections_Js/* JsConnectionPoint */.fp(connections_Js/* JsConnectionPointType.OBJECT_3D */.zF.OBJECT_3D, connections_Js/* JsConnectionPointType.OBJECT_3D */.zF.OBJECT_3D, PhysicsRBDApplyImpulseAtPoint_CONNECTION_OPTIONS)
    ]);
    this.io.outputs.setNamedOutputConnectionPoints([
      new connections_Js/* JsConnectionPoint */.fp(js_Base/* TRIGGER_CONNECTION_NAME */.w6, connections_Js/* JsConnectionPointType.TRIGGER */.zF.TRIGGER),
      new connections_Js/* JsConnectionPoint */.fp(connections_Js/* JsConnectionPointType.OBJECT_3D */.zF.OBJECT_3D, connections_Js/* JsConnectionPointType.OBJECT_3D */.zF.OBJECT_3D, PhysicsRBDApplyImpulseAtPoint_CONNECTION_OPTIONS)
    ]);
  }
  setTriggerableLines(shadersCollectionController) {
    const object3D = (0,_BaseObject3D/* inputObject3D */.iv)(this, shadersCollectionController);
    const impulse = this.variableForInputParam(shadersCollectionController, this.p.impulse);
    const point = this.variableForInputParam(shadersCollectionController, this.p.point);
    const func = Poly/* Poly.namedFunctionsRegister.getFunction */.L.namedFunctionsRegister.getFunction(
      "physicsRBDApplyImpulseAtPoint",
      this,
      shadersCollectionController
    );
    const bodyLine = func.asString(object3D, impulse, point);
    shadersCollectionController.addTriggerableLines(this, [bodyLine]);
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/js/PhysicsRBDResetAll.ts







const PhysicsRBDResetAll_CONNECTION_OPTIONS = connections_Js/* JS_CONNECTION_POINT_IN_NODE_DEF */.mX;
class PhysicsRBDResetAllJsParamsConfig extends params_ParamsConfig/* NodeParamsConfig */.yI {
  constructor() {
    super(...arguments);
    /** @param wakeup */
    this.wakeup = params_ParamsConfig/* ParamConfig.BOOLEAN */.XC.BOOLEAN(0);
  }
}
const PhysicsRBDResetAll_ParamsConfig = new PhysicsRBDResetAllJsParamsConfig();
class PhysicsRBDResetAllJsNode extends js_Base/* TypedJsNode */.xZ {
  constructor() {
    super(...arguments);
    this.paramsConfig = PhysicsRBDResetAll_ParamsConfig;
  }
  static type() {
    return "physicsRBDResetAll";
  }
  initializeNode() {
    this.io.inputs.setNamedInputConnectionPoints([
      new connections_Js/* JsConnectionPoint */.fp(js_Base/* TRIGGER_CONNECTION_NAME */.w6, connections_Js/* JsConnectionPointType.TRIGGER */.zF.TRIGGER, PhysicsRBDResetAll_CONNECTION_OPTIONS),
      new connections_Js/* JsConnectionPoint */.fp(connections_Js/* JsConnectionPointType.OBJECT_3D */.zF.OBJECT_3D, connections_Js/* JsConnectionPointType.OBJECT_3D */.zF.OBJECT_3D, PhysicsRBDResetAll_CONNECTION_OPTIONS)
    ]);
    this.io.outputs.setNamedOutputConnectionPoints([
      new connections_Js/* JsConnectionPoint */.fp(js_Base/* TRIGGER_CONNECTION_NAME */.w6, connections_Js/* JsConnectionPointType.TRIGGER */.zF.TRIGGER),
      new connections_Js/* JsConnectionPoint */.fp(connections_Js/* JsConnectionPointType.OBJECT_3D */.zF.OBJECT_3D, connections_Js/* JsConnectionPointType.OBJECT_3D */.zF.OBJECT_3D, PhysicsRBDResetAll_CONNECTION_OPTIONS)
    ]);
  }
  setTriggerableLines(shadersCollectionController) {
    const object3D = (0,_BaseObject3D/* inputObject3D */.iv)(this, shadersCollectionController);
    const wakeup = this.variableForInputParam(shadersCollectionController, this.p.wakeup);
    const func = Poly/* Poly.namedFunctionsRegister.getFunction */.L.namedFunctionsRegister.getFunction("physicsRBDResetAll", this, shadersCollectionController);
    const bodyLine = func.asString(object3D, wakeup);
    shadersCollectionController.addTriggerableLines(this, [bodyLine]);
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/js/PhysicsRBDResetForces.ts







const PhysicsRBDResetForces_CONNECTION_OPTIONS = connections_Js/* JS_CONNECTION_POINT_IN_NODE_DEF */.mX;
class PhysicsRBDResetForcesJsParamsConfig extends params_ParamsConfig/* NodeParamsConfig */.yI {
  constructor() {
    super(...arguments);
    /** @param wakeup */
    this.wakeup = params_ParamsConfig/* ParamConfig.BOOLEAN */.XC.BOOLEAN(0);
  }
}
const PhysicsRBDResetForces_ParamsConfig = new PhysicsRBDResetForcesJsParamsConfig();
class PhysicsRBDResetForcesJsNode extends js_Base/* TypedJsNode */.xZ {
  constructor() {
    super(...arguments);
    this.paramsConfig = PhysicsRBDResetForces_ParamsConfig;
  }
  static type() {
    return "physicsRBDResetForces";
  }
  initializeNode() {
    this.io.inputs.setNamedInputConnectionPoints([
      new connections_Js/* JsConnectionPoint */.fp(js_Base/* TRIGGER_CONNECTION_NAME */.w6, connections_Js/* JsConnectionPointType.TRIGGER */.zF.TRIGGER, PhysicsRBDResetForces_CONNECTION_OPTIONS),
      new connections_Js/* JsConnectionPoint */.fp(connections_Js/* JsConnectionPointType.OBJECT_3D */.zF.OBJECT_3D, connections_Js/* JsConnectionPointType.OBJECT_3D */.zF.OBJECT_3D, PhysicsRBDResetForces_CONNECTION_OPTIONS)
    ]);
    this.io.outputs.setNamedOutputConnectionPoints([
      new connections_Js/* JsConnectionPoint */.fp(js_Base/* TRIGGER_CONNECTION_NAME */.w6, connections_Js/* JsConnectionPointType.TRIGGER */.zF.TRIGGER),
      new connections_Js/* JsConnectionPoint */.fp(connections_Js/* JsConnectionPointType.OBJECT_3D */.zF.OBJECT_3D, connections_Js/* JsConnectionPointType.OBJECT_3D */.zF.OBJECT_3D, PhysicsRBDResetForces_CONNECTION_OPTIONS)
    ]);
  }
  setTriggerableLines(shadersCollectionController) {
    const object3D = (0,_BaseObject3D/* inputObject3D */.iv)(this, shadersCollectionController);
    const wakeup = this.variableForInputParam(shadersCollectionController, this.p.wakeup);
    const func = Poly/* Poly.namedFunctionsRegister.getFunction */.L.namedFunctionsRegister.getFunction(
      "physicsRBDResetForces",
      this,
      shadersCollectionController
    );
    const bodyLine = func.asString(object3D, wakeup);
    shadersCollectionController.addTriggerableLines(this, [bodyLine]);
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/js/PhysicsRBDResetTorques.ts







const PhysicsRBDResetTorques_CONNECTION_OPTIONS = connections_Js/* JS_CONNECTION_POINT_IN_NODE_DEF */.mX;
class PhysicsRBDResetTorquesJsParamsConfig extends params_ParamsConfig/* NodeParamsConfig */.yI {
  constructor() {
    super(...arguments);
    /** @param wakeup */
    this.wakeup = params_ParamsConfig/* ParamConfig.BOOLEAN */.XC.BOOLEAN(0);
  }
}
const PhysicsRBDResetTorques_ParamsConfig = new PhysicsRBDResetTorquesJsParamsConfig();
class PhysicsRBDResetTorquesJsNode extends js_Base/* TypedJsNode */.xZ {
  constructor() {
    super(...arguments);
    this.paramsConfig = PhysicsRBDResetTorques_ParamsConfig;
  }
  static type() {
    return "physicsRBDResetTorques";
  }
  initializeNode() {
    this.io.inputs.setNamedInputConnectionPoints([
      new connections_Js/* JsConnectionPoint */.fp(js_Base/* TRIGGER_CONNECTION_NAME */.w6, connections_Js/* JsConnectionPointType.TRIGGER */.zF.TRIGGER, PhysicsRBDResetTorques_CONNECTION_OPTIONS),
      new connections_Js/* JsConnectionPoint */.fp(connections_Js/* JsConnectionPointType.OBJECT_3D */.zF.OBJECT_3D, connections_Js/* JsConnectionPointType.OBJECT_3D */.zF.OBJECT_3D, PhysicsRBDResetTorques_CONNECTION_OPTIONS)
    ]);
    this.io.outputs.setNamedOutputConnectionPoints([
      new connections_Js/* JsConnectionPoint */.fp(js_Base/* TRIGGER_CONNECTION_NAME */.w6, connections_Js/* JsConnectionPointType.TRIGGER */.zF.TRIGGER),
      new connections_Js/* JsConnectionPoint */.fp(connections_Js/* JsConnectionPointType.OBJECT_3D */.zF.OBJECT_3D, connections_Js/* JsConnectionPointType.OBJECT_3D */.zF.OBJECT_3D, PhysicsRBDResetTorques_CONNECTION_OPTIONS)
    ]);
  }
  setTriggerableLines(shadersCollectionController) {
    const object3D = (0,_BaseObject3D/* inputObject3D */.iv)(this, shadersCollectionController);
    const wakeup = this.variableForInputParam(shadersCollectionController, this.p.wakeup);
    const func = Poly/* Poly.namedFunctionsRegister.getFunction */.L.namedFunctionsRegister.getFunction(
      "physicsRBDResetTorques",
      this,
      shadersCollectionController
    );
    const bodyLine = func.asString(object3D, wakeup);
    shadersCollectionController.addTriggerableLines(this, [bodyLine]);
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/js/PhysicsWorldReset.ts




class PhysicsWorldResetJsNode extends _BaseTriggerAndObject/* ParamlessBaseTriggerAndObjectJsNode */.c {
  static type() {
    return "physicsWorldReset";
  }
  setTriggerableLines(shadersCollectionController) {
    const object3D = (0,_BaseObject3D/* inputObject3D */.iv)(this, shadersCollectionController);
    const func = Poly/* Poly.namedFunctionsRegister.getFunction */.L.namedFunctionsRegister.getFunction("physicsWorldReset", this, shadersCollectionController);
    const bodyLine = func.asString(object3D);
    shadersCollectionController.addTriggerableLines(this, [bodyLine]);
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/js/PhysicsWorldStepSimulation.ts




class PhysicsWorldStepSimulationJsNode extends _BaseTriggerAndObject/* ParamlessBaseTriggerAndObjectJsNode */.c {
  static type() {
    return "physicsWorldStepSimulation";
  }
  setTriggerableLines(shadersCollectionController) {
    const object3D = (0,_BaseObject3D/* inputObject3D */.iv)(this, shadersCollectionController);
    const func = Poly/* Poly.namedFunctionsRegister.getFunction */.L.namedFunctionsRegister.getFunction(
      "physicsWorldStepSimulation",
      this,
      shadersCollectionController
    );
    const bodyLine = func.asString(object3D);
    shadersCollectionController.addTriggerableLines(this, [bodyLine]);
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/js/Plane.ts






const Plane_OUTPUT_NAME = connections_Js/* JsConnectionPointType.PLANE */.zF.PLANE;
class PlaneJsParamsConfig extends params_ParamsConfig/* NodeParamsConfig */.yI {
  constructor() {
    super(...arguments);
    /** @param a unit length vector defining the normal of the plane */
    this.normal = params_ParamsConfig/* ParamConfig.VECTOR3 */.XC.VECTOR3([0, 1, 0]);
    /** @param the signed distance from the origin to the plane */
    this.constant = params_ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(0, {
      range: [-1, 1],
      rangeLocked: [false, false]
    });
  }
}
const Plane_ParamsConfig = new PlaneJsParamsConfig();
class PlaneJsNode extends js_Base/* TypedJsNode */.xZ {
  constructor() {
    super(...arguments);
    this.paramsConfig = Plane_ParamsConfig;
  }
  static type() {
    return "plane";
  }
  initializeNode() {
    super.initializeNode();
    this.io.outputs.setNamedOutputConnectionPoints([
      new connections_Js/* JsConnectionPoint */.fp(Plane_OUTPUT_NAME, connections_Js/* JsConnectionPointType.PLANE */.zF.PLANE)
    ]);
  }
  setLines(shadersCollectionController) {
    const normal = this.variableForInputParam(shadersCollectionController, this.p.normal);
    const constant = this.variableForInputParam(shadersCollectionController, this.p.constant);
    const out = this.jsVarName(Plane_OUTPUT_NAME);
    const tmpVarName = shadersCollectionController.addVariable(this, new three_module.Plane());
    const func = Poly/* Poly.namedFunctionsRegister.getFunction */.L.namedFunctionsRegister.getFunction("planeSet", this, shadersCollectionController);
    const bodyLine = func.asString(normal, constant, tmpVarName);
    shadersCollectionController.addBodyOrComputed(this, [
      { dataType: connections_Js/* JsConnectionPointType.PLANE */.zF.PLANE, varName: out, value: bodyLine }
    ]);
  }
}

// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/nodes/js/PlayAnimation.ts
var PlayAnimation = __webpack_require__(97179);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/nodes/js/PlayAudioSource.ts
var PlayAudioSource = __webpack_require__(80701);
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/js/PlayerMode.ts





class PlayerModeJsParamsConfig extends params_ParamsConfig/* NodeParamsConfig */.yI {
}
const PlayerMode_ParamsConfig = new PlayerModeJsParamsConfig();
const _PlayerModeJsNode = class extends js_Base/* TypedJsNode */.xZ {
  constructor() {
    super(...arguments);
    this.paramsConfig = PlayerMode_ParamsConfig;
  }
  static type() {
    return "playerMode";
  }
  initializeNode() {
    this.io.outputs.setNamedOutputConnectionPoints([
      new connections_Js/* JsConnectionPoint */.fp(_PlayerModeJsNode.OUTPUT_NAME, connections_Js/* JsConnectionPointType.BOOLEAN */.zF.BOOLEAN)
    ]);
  }
  setLines(linesController) {
    const func = Poly/* Poly.namedFunctionsRegister.getFunction */.L.namedFunctionsRegister.getFunction("playerMode", this, linesController);
    const varName = this.jsVarName(_PlayerModeJsNode.OUTPUT_NAME);
    linesController.addBodyOrComputed(this, [
      {
        dataType: connections_Js/* JsConnectionPointType.BOOLEAN */.zF.BOOLEAN,
        varName,
        value: func.asString()
      }
    ]);
  }
};
let PlayerModeJsNode = _PlayerModeJsNode;
PlayerModeJsNode.OUTPUT_NAME = "mode";

// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/operations/sop/Capsule.ts + 1 modules
var Capsule = __webpack_require__(69291);
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/js/PlayerUpdate.ts









const PlayerUpdate_CONNECTION_OPTIONS = connections_Js/* JS_CONNECTION_POINT_IN_NODE_DEF */.mX;
var PlayerUpdateInput = /* @__PURE__ */ ((PlayerUpdateInput2) => {
  PlayerUpdateInput2["COLLIDER"] = "collider";
  return PlayerUpdateInput2;
})(PlayerUpdateInput || {});
var PlayerUpdateOutput = /* @__PURE__ */ ((PlayerUpdateOutput2) => {
  PlayerUpdateOutput2["VELOCITY"] = "velocity";
  PlayerUpdateOutput2["ON_GROUND"] = "onGround";
  return PlayerUpdateOutput2;
})(PlayerUpdateOutput || {});
class PlayerUpdateJsParamsConfig extends params_ParamsConfig/* NodeParamsConfig */.yI {
  constructor() {
    super(...arguments);
    /** @param travel speed */
    this.speed = params_ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(2, {
      range: [0, 10],
      rangeLocked: [true, false]
    });
    /** @param run Allowed */
    this.runAllowed = params_ParamsConfig/* ParamConfig.BOOLEAN */.XC.BOOLEAN(true);
    /** @param jump Force */
    this.runSpeedMult = params_ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(2, {
      range: [0, 10],
      rangeLocked: [true, false],
      visibleIf: { runAllowed: 1 }
    });
    /** @param jump Allowed */
    this.jumpAllowed = params_ParamsConfig/* ParamConfig.BOOLEAN */.XC.BOOLEAN(true);
    /** @param jump Force */
    this.jumpStrength = params_ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(10, {
      range: [0, 100],
      rangeLocked: [true, false],
      visibleIf: { jumpAllowed: 1 }
    });
    /** @param physics Steps */
    this.physicsSteps = params_ParamsConfig/* ParamConfig.INTEGER */.XC.INTEGER(5, {
      range: [1, 10],
      rangeLocked: [true, false],
      separatorBefore: true
    });
    /** @param gravity */
    this.gravity = params_ParamsConfig/* ParamConfig.VECTOR3 */.XC.VECTOR3([0, -9.8, 0]);
    /** @param collision Capsule Radius */
    this.capsuleRadius = params_ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(Capsule/* CapsuleSopOperation.DEFAULT_PARAMS.radius */.e.DEFAULT_PARAMS.radius, {
      range: [0, 1],
      rangeLocked: [true, false]
    });
    /** @param collision Capsule Height */
    this.capsuleHeight = params_ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(Capsule/* CapsuleSopOperation.DEFAULT_PARAMS.height */.e.DEFAULT_PARAMS.height, {
      range: [0, 2],
      rangeLocked: [true, false]
    });
  }
}
const PlayerUpdate_ParamsConfig = new PlayerUpdateJsParamsConfig();
class PlayerUpdateJsNode extends js_Base/* TypedJsNode */.xZ {
  constructor() {
    super(...arguments);
    this.paramsConfig = PlayerUpdate_ParamsConfig;
  }
  static type() {
    return "playerUpdate";
  }
  initializeNode() {
    this.io.inputs.setNamedInputConnectionPoints([
      new connections_Js/* JsConnectionPoint */.fp(js_Base/* TRIGGER_CONNECTION_NAME */.w6, connections_Js/* JsConnectionPointType.TRIGGER */.zF.TRIGGER, PlayerUpdate_CONNECTION_OPTIONS),
      // new JsConnectionPoint(JsConnectionPointType.OBJECT_3D, JsConnectionPointType.OBJECT_3D, CONNECTION_OPTIONS),
      new connections_Js/* JsConnectionPoint */.fp("collider" /* COLLIDER */, connections_Js/* JsConnectionPointType.OBJECT_3D */.zF.OBJECT_3D, PlayerUpdate_CONNECTION_OPTIONS),
      ...PlayerCommon/* CORE_PLAYER_INPUTS.map */.o.map(
        (inputName) => new connections_Js/* JsConnectionPoint */.fp(inputName, connections_Js/* JsConnectionPointType.BOOLEAN */.zF.BOOLEAN, PlayerUpdate_CONNECTION_OPTIONS)
      )
    ]);
    this.io.outputs.setNamedOutputConnectionPoints([
      new connections_Js/* JsConnectionPoint */.fp(js_Base/* TRIGGER_CONNECTION_NAME */.w6, connections_Js/* JsConnectionPointType.TRIGGER */.zF.TRIGGER),
      new connections_Js/* JsConnectionPoint */.fp("onGround" /* ON_GROUND */, connections_Js/* JsConnectionPointType.BOOLEAN */.zF.BOOLEAN),
      new connections_Js/* JsConnectionPoint */.fp("velocity" /* VELOCITY */, connections_Js/* JsConnectionPointType.VECTOR3 */.zF.VECTOR3)
    ]);
  }
  setTriggerableLines(shadersCollectionController) {
    const object3D = (0,_BaseObject3D/* inputObject3D */.iv)(this, shadersCollectionController);
    const collider = this.variableForInput(shadersCollectionController, "collider" /* COLLIDER */);
    const data = { collider };
    PlayerCommon/* CORE_PLAYER_INPUTS.map */.o.map((inputName) => {
      data[inputName] = this.variableForInput(shadersCollectionController, inputName);
    });
    const coreInputDict = JSON.stringify(PlayerCommon/* CORE_PLAYER_INPUTS */.o);
    const func = Poly/* Poly.namedFunctionsRegister.getFunction */.L.namedFunctionsRegister.getFunction("playerSimpleUpdate", this, shadersCollectionController);
    const bodyLine = func.asString(object3D, coreInputDict);
    shadersCollectionController.addTriggerableLines(this, [bodyLine]);
  }
  setLines(shadersCollectionController) {
    const object3D = (0,_BaseObject3D/* inputObject3D */.iv)(this, shadersCollectionController);
    const usedOutputNames = this.io.outputs.used_output_names();
    const _b = (propertyName, functionName, type) => {
      if (!usedOutputNames.includes(propertyName)) {
        return;
      }
      const varName = this.jsVarName(propertyName);
      const func = Poly/* Poly.namedFunctionsRegister.getFunction */.L.namedFunctionsRegister.getFunction(functionName, this, shadersCollectionController);
      shadersCollectionController.addBodyOrComputed(this, [
        {
          dataType: type,
          varName,
          value: func.asString(object3D)
        }
      ]);
    };
    const _v3 = (propertyName, functionName, type) => {
      if (!usedOutputNames.includes(propertyName)) {
        return;
      }
      const varName = this.jsVarName(propertyName);
      const tmpVarName = shadersCollectionController.addVariable(this, new three_module.Vector3());
      const func = Poly/* Poly.namedFunctionsRegister.getFunction */.L.namedFunctionsRegister.getFunction(functionName, this, shadersCollectionController);
      shadersCollectionController.addBodyOrComputed(this, [
        {
          dataType: type,
          varName,
          value: func.asString(object3D, tmpVarName)
        }
      ]);
    };
    _b("onGround" /* ON_GROUND */, "getPlayerSimplePropertyOnGround", connections_Js/* JsConnectionPointType.BOOLEAN */.zF.BOOLEAN);
    _v3("velocity" /* VELOCITY */, "getPlayerSimplePropertyVelocity", connections_Js/* JsConnectionPointType.VECTOR3 */.zF.VECTOR3);
  }
}

// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/nodes/js/PlayInstrumentNote.ts
var PlayInstrumentNote = __webpack_require__(6365);
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/js/PolarTransform.ts






const PolarTransform_CONNECTION_OPTIONS = connections_Js/* JS_CONNECTION_POINT_IN_NODE_DEF */.mX;
class PolarTransformJsParamsConfig extends params_ParamsConfig/* NodeParamsConfig */.yI {
  constructor() {
    super(...arguments);
    /** @param center of the transform */
    this.center = params_ParamsConfig/* ParamConfig.VECTOR3 */.XC.VECTOR3([0, 0, 0]);
    /** @param moves the objects along the longitude, which is equivalent to a rotation on the y axis */
    this.longitude = params_ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(0, {
      range: [-360, 360]
    });
    /** @param moves the objects along the latitude, which is equivalent to a rotation on the z or x axis */
    this.latitude = params_ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(0, {
      range: [-180, 180]
    });
    /** @param moves the point aways from the center */
    this.depth = params_ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(1, {
      range: [0, 10]
    });
  }
  /** @param lerp factor */
  // lerp = ParamConfig.FLOAT(1);
  /** @param sets if the matrix should be updated as the animation progresses */
  // updateMatrix = ParamConfig.BOOLEAN(1);
}
const PolarTransform_ParamsConfig = new PolarTransformJsParamsConfig();
class PolarTransformJsNode extends js_Base/* TypedJsNode */.xZ {
  constructor() {
    super(...arguments);
    this.paramsConfig = PolarTransform_ParamsConfig;
  }
  static type() {
    return "polarTransform";
  }
  initializeNode() {
    this.io.outputs.setNamedOutputConnectionPoints([
      new connections_Js/* JsConnectionPoint */.fp(connections_Js/* JsConnectionPointType.MATRIX4 */.zF.MATRIX4, connections_Js/* JsConnectionPointType.MATRIX4 */.zF.MATRIX4, PolarTransform_CONNECTION_OPTIONS)
    ]);
  }
  setLines(linesController) {
    const center = this.variableForInputParam(linesController, this.p.center);
    const longitude = this.variableForInputParam(linesController, this.p.longitude);
    const latitude = this.variableForInputParam(linesController, this.p.latitude);
    const depth = this.variableForInputParam(linesController, this.p.depth);
    const varName = this.jsVarName(connections_Js/* JsConnectionPointType.MATRIX4 */.zF.MATRIX4);
    const tmpVarName = linesController.addVariable(this, new three_module.Matrix4());
    const func = Poly/* Poly.namedFunctionsRegister.getFunction */.L.namedFunctionsRegister.getFunction("polarTransform", this, linesController);
    linesController.addBodyOrComputed(this, [
      {
        dataType: connections_Js/* JsConnectionPointType.MATRIX4 */.zF.MATRIX4,
        varName,
        value: func.asString(center, longitude, latitude, depth, tmpVarName)
      }
    ]);
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/js/Pow.ts



var PowInput = /* @__PURE__ */ ((PowInput2) => {
  PowInput2["src"] = "src";
  PowInput2["exp"] = "exp";
  return PowInput2;
})(PowInput || {});
const Pow_DefaultValues = {
  ["src" /* src */]: 0,
  ["exp" /* exp */]: 1
};
class PowJsNode extends _Math_Arg1Operation_MathFunctionArg2OperationFactory("pow", {
  inputPrefix: "in",
  out: "pow"
}) {
  paramDefaultValue(name) {
    return Pow_DefaultValues[name];
  }
  _expectedInputName(index) {
    return ["src" /* src */, "exp" /* exp */][index];
  }
  _expectedInputTypes() {
    let first_input_type = this.io.connection_points.first_input_connection_type();
    const connectionPoints = this.io.inputs.namedInputConnectionPoints();
    if (first_input_type && connectionPoints) {
      if (!DEFAULT_ALLOWED_TYPES.includes(first_input_type)) {
        const first_connection = connectionPoints[0];
        if (first_connection) {
          first_input_type = first_connection.type();
        }
      }
    }
    const type = first_input_type || connections_Js/* JsConnectionPointType.FLOAT */.zF.FLOAT;
    const boundType = connections_Js/* JsConnectionPointTypeFromArrayTypeMap */.RR[type];
    return [type, boundType];
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/js/PressButtonParam.ts







const PressButtonParam_CONNECTION_OPTIONS = connections_Js/* JS_CONNECTION_POINT_IN_NODE_DEF */.mX;
class PressButtonParamJsParamsConfig extends params_ParamsConfig/* NodeParamsConfig */.yI {
  constructor() {
    super(...arguments);
    /** @param the parameter to update */
    this.Param = params_ParamsConfig/* ParamConfig.PARAM_PATH */.XC.PARAM_PATH("", {
      dependentOnFoundParam: false,
      paramSelection: ParamType/* ParamType.BUTTON */._.BUTTON,
      computeOnDirty: true
    });
  }
}
const PressButtonParam_ParamsConfig = new PressButtonParamJsParamsConfig();
class PressButtonParamJsNode extends js_Base/* TypedJsNode */.xZ {
  constructor() {
    super(...arguments);
    this.paramsConfig = PressButtonParam_ParamsConfig;
  }
  static type() {
    return "pressButtonParam";
  }
  initializeNode() {
    this.io.inputs.setNamedInputConnectionPoints([
      new connections_Js/* JsConnectionPoint */.fp(connections_Js/* JsConnectionPointType.TRIGGER */.zF.TRIGGER, connections_Js/* JsConnectionPointType.TRIGGER */.zF.TRIGGER, PressButtonParam_CONNECTION_OPTIONS)
    ]);
    this.io.outputs.setNamedOutputConnectionPoints([
      new connections_Js/* JsConnectionPoint */.fp(connections_Js/* JsConnectionPointType.TRIGGER */.zF.TRIGGER, connections_Js/* JsConnectionPointType.TRIGGER */.zF.TRIGGER)
    ]);
  }
  setParamPath(paramPath) {
    this.p.Param.set(paramPath);
  }
  setParamParam(param) {
    this.p.Param.setParam(param);
  }
  setTriggerableLines(linesController) {
    const param = (0,_BaseObject3D/* inputParam */.PQ)(this, linesController);
    const func = Poly/* Poly.namedFunctionsRegister.getFunction */.L.namedFunctionsRegister.getFunction("pressButtonParam", this, linesController);
    const bodyLine = func.asString(param);
    linesController.addTriggerableLines(this, [bodyLine]);
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/js/PreviousValue.ts






var PreviousValueJsNodeInputName = /* @__PURE__ */ ((PreviousValueJsNodeInputName2) => {
  PreviousValueJsNodeInputName2["current"] = "current";
  PreviousValueJsNodeInputName2["offset"] = "offset";
  return PreviousValueJsNodeInputName2;
})(PreviousValueJsNodeInputName || {});
const PreviousValue_DefaultValues = {
  ["current" /* current */]: 0,
  ["offset" /* offset */]: 1
};
class PreviousJsParamsConfig extends params_ParamsConfig/* NodeParamsConfig */.yI {
  constructor() {
    super(...arguments);
    this.offset = params_ParamsConfig/* ParamConfig.INTEGER */.XC.INTEGER(1, {
      range: [0, 10],
      rangeLocked: [true, false]
    });
  }
}
const PreviousValue_ParamsConfig = new PreviousJsParamsConfig();
const _PreviousValueJsNode = class extends js_Base/* TypedJsNode */.xZ {
  constructor() {
    super(...arguments);
    this.paramsConfig = PreviousValue_ParamsConfig;
  }
  static type() {
    return "previousValue";
  }
  initializeNode() {
    super.initializeNode();
    this.io.connection_points.set_expected_input_types_function(this._expectedInputTypes.bind(this));
    this.io.connection_points.set_expected_output_types_function(this._expectedOutputTypes.bind(this));
    this.io.connection_points.set_input_name_function(this._expectedInputName.bind(this));
    this.io.connection_points.set_output_name_function(this._expectedOutputName.bind(this));
  }
  paramDefaultValue(name) {
    return PreviousValue_DefaultValues[name];
  }
  _expectedInputTypes() {
    let firstType = this.io.connection_points.first_input_connection_type();
    if (firstType == null || !connections_Js/* PARAM_CONVERTIBLE_JS_CONNECTION_POINT_TYPES.includes */.mH.includes(firstType)) {
      firstType = connections_Js/* JsConnectionPointType.FLOAT */.zF.FLOAT;
    }
    return [firstType, connections_Js/* JsConnectionPointType.INT */.zF.INT];
  }
  _expectedInputName(index) {
    return ["current" /* current */, "offset" /* offset */][index];
  }
  _expectedOutputName(index) {
    return _PreviousValueJsNode.OUTPUT_NAME;
  }
  _expectedOutputTypes() {
    return [this._expectedInputTypes()[0]];
  }
  setLines(shadersCollectionController) {
    const out = this.jsVarName(_PreviousValueJsNode.OUTPUT_NAME);
    const offset = this.variableForInputParam(shadersCollectionController, this.p.offset);
    const inputValue = this.variableForInput(shadersCollectionController, "current" /* current */);
    const _func = Poly/* Poly.namedFunctionsRegister.getFunction */.L.namedFunctionsRegister.getFunction(this._functionName(), this, shadersCollectionController);
    shadersCollectionController.addBodyOrComputed(this, [
      {
        dataType: this._expectedInputTypes()[0],
        varName: out,
        value: _func.asString(`'${this.path()}'`, offset, inputValue)
      }
    ]);
  }
  _functionName() {
    const type = this._expectedInputTypes()[0];
    switch (type) {
      case connections_Js/* JsConnectionPointType.BOOLEAN */.zF.BOOLEAN:
      case connections_Js/* JsConnectionPointType.FLOAT */.zF.FLOAT:
      case connections_Js/* JsConnectionPointType.INT */.zF.INT:
      case connections_Js/* JsConnectionPointType.STRING */.zF.STRING: {
        return "previousValuePrimitive";
      }
      case connections_Js/* JsConnectionPointType.COLOR */.zF.COLOR: {
        return "previousValueColor";
      }
      case connections_Js/* JsConnectionPointType.VECTOR2 */.zF.VECTOR2: {
        return "previousValueVector2";
      }
      case connections_Js/* JsConnectionPointType.VECTOR3 */.zF.VECTOR3: {
        return "previousValueVector3";
      }
      case connections_Js/* JsConnectionPointType.VECTOR4 */.zF.VECTOR4: {
        return "previousValueVector4";
      }
    }
    Assert/* TypeAssert.unreachable */.f.unreachable(type);
  }
};
let PreviousValueJsNode = _PreviousValueJsNode;
PreviousValueJsNode.OUTPUT_NAME = "prev";

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/js/PrimitiveNeighbourIndex.ts






const PrimitiveNeighbourIndex_CONNECTION_OPTIONS = connections_Js/* JS_CONNECTION_POINT_IN_NODE_DEF */.mX;
class PrimitiveNeighbourIndexJsParamsConfig extends params_ParamsConfig/* NodeParamsConfig */.yI {
  constructor() {
    super(...arguments);
    /** @param entity index */
    this.index = params_ParamsConfig/* ParamConfig.INTEGER */.XC.INTEGER(0);
    /** @param neighbour index */
    this.neighbourIndex = params_ParamsConfig/* ParamConfig.INTEGER */.XC.INTEGER(0);
    /** @param require a shared edge */
    this.sharedEdgeOnly = params_ParamsConfig/* ParamConfig.BOOLEAN */.XC.BOOLEAN(0);
  }
}
const PrimitiveNeighbourIndex_ParamsConfig = new PrimitiveNeighbourIndexJsParamsConfig();
class PrimitiveNeighbourIndexJsNode extends js_Base/* TypedJsNode */.xZ {
  constructor() {
    super(...arguments);
    this.paramsConfig = PrimitiveNeighbourIndex_ParamsConfig;
  }
  static type() {
    return "primitiveNeighbourIndex";
  }
  initializeNode() {
    super.initializeNode();
    this.io.outputs.setNamedOutputConnectionPoints([
      new connections_Js/* JsConnectionPoint */.fp(connections_Js/* JsConnectionPointType.INT */.zF.INT, connections_Js/* JsConnectionPointType.INT */.zF.INT, PrimitiveNeighbourIndex_CONNECTION_OPTIONS)
    ]);
  }
  setLines(linesController) {
    const primitiveGraph = (0,_BaseObject3D/* defaultPrimitiveGraph */.T4)(linesController);
    const index = this.variableForInputParam(linesController, this.p.index);
    const neighbourIndex = this.variableForInputParam(linesController, this.p.neighbourIndex);
    const sharedEdgeOnly = this.variableForInputParam(linesController, this.p.sharedEdgeOnly);
    const out = this.jsVarName(connections_Js/* JsConnectionPointType.INT */.zF.INT);
    const func = Poly/* Poly.namedFunctionsRegister.getFunction */.L.namedFunctionsRegister.getFunction("primitiveNeighbourIndex", this, linesController);
    const bodyLine = func.asString(primitiveGraph, index, neighbourIndex, sharedEdgeOnly);
    linesController.addBodyOrComputed(this, [{ dataType: connections_Js/* JsConnectionPointType.INT */.zF.INT, varName: out, value: bodyLine }]);
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/js/PrimitiveNeighboursCount.ts






const PrimitiveNeighboursCount_CONNECTION_OPTIONS = connections_Js/* JS_CONNECTION_POINT_IN_NODE_DEF */.mX;
class PrimitiveNeighboursCountJsParamsConfig extends params_ParamsConfig/* NodeParamsConfig */.yI {
  constructor() {
    super(...arguments);
    /** @param entity index */
    this.index = params_ParamsConfig/* ParamConfig.INTEGER */.XC.INTEGER(0);
    /** @param require a shared edge */
    this.sharedEdgeOnly = params_ParamsConfig/* ParamConfig.BOOLEAN */.XC.BOOLEAN(0);
  }
}
const PrimitiveNeighboursCount_ParamsConfig = new PrimitiveNeighboursCountJsParamsConfig();
class PrimitiveNeighboursCountJsNode extends js_Base/* TypedJsNode */.xZ {
  constructor() {
    super(...arguments);
    this.paramsConfig = PrimitiveNeighboursCount_ParamsConfig;
  }
  static type() {
    return "primitiveNeighboursCount";
  }
  initializeNode() {
    super.initializeNode();
    this.io.outputs.setNamedOutputConnectionPoints([
      new connections_Js/* JsConnectionPoint */.fp(connections_Js/* JsConnectionPointType.INT */.zF.INT, connections_Js/* JsConnectionPointType.INT */.zF.INT, PrimitiveNeighboursCount_CONNECTION_OPTIONS)
    ]);
  }
  setLines(linesController) {
    const primitiveGraph = (0,_BaseObject3D/* defaultPrimitiveGraph */.T4)(linesController);
    const index = this.variableForInputParam(linesController, this.p.index);
    const sharedEdgeOnly = this.variableForInputParam(linesController, this.p.sharedEdgeOnly);
    const out = this.jsVarName(connections_Js/* JsConnectionPointType.INT */.zF.INT);
    const func = Poly/* Poly.namedFunctionsRegister.getFunction */.L.namedFunctionsRegister.getFunction("primitiveNeighboursCount", this, linesController);
    const bodyLine = func.asString(primitiveGraph, index, sharedEdgeOnly);
    linesController.addBodyOrComputed(this, [{ dataType: connections_Js/* JsConnectionPointType.INT */.zF.INT, varName: out, value: bodyLine }]);
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/js/Quaternion.ts






class QuaternionJsParamsConfig extends params_ParamsConfig/* NodeParamsConfig */.yI {
  constructor() {
    super(...arguments);
    /** @param axis */
    this.axis = params_ParamsConfig/* ParamConfig.VECTOR3 */.XC.VECTOR3([0, 1, 0]);
    /** @param rotation order */
    this.angle = params_ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(0, {
      range: [-Math.PI, Math.PI],
      rangeLocked: [false, false]
    });
  }
}
const Quaternion_ParamsConfig = new QuaternionJsParamsConfig();
class QuaternionJsNode extends js_Base/* TypedJsNode */.xZ {
  constructor() {
    super(...arguments);
    this.paramsConfig = Quaternion_ParamsConfig;
  }
  static type() {
    return "quaternion";
  }
  initializeNode() {
    super.initializeNode();
    this.io.outputs.setNamedOutputConnectionPoints([
      new connections_Js/* JsConnectionPoint */.fp(connections_Js/* JsConnectionPointType.QUATERNION */.zF.QUATERNION, connections_Js/* JsConnectionPointType.QUATERNION */.zF.QUATERNION)
    ]);
  }
  setLines(linesController) {
    const axis = this.variableForInputParam(linesController, this.p.axis);
    const angle = this.variableForInputParam(linesController, this.p.angle);
    const varName = this.jsVarName(connections_Js/* JsConnectionPointType.QUATERNION */.zF.QUATERNION);
    const tmpVarName = linesController.addVariable(this, new three_module.Quaternion());
    const func = Poly/* Poly.namedFunctionsRegister.getFunction */.L.namedFunctionsRegister.getFunction("quaternionSetFromAxisAngle", this, linesController);
    linesController.addBodyOrComputed(this, [
      {
        dataType: connections_Js/* JsConnectionPointType.EULER */.zF.EULER,
        varName,
        value: func.asString(axis, angle, tmpVarName)
      }
    ]);
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/js/QuaternionAngleTo.ts





const QuaternionAngleTo_CONNECTION_OPTIONS = connections_Js/* JS_CONNECTION_POINT_IN_NODE_DEF */.mX;
var QuaternionAngleToInputName = /* @__PURE__ */ ((QuaternionAngleToInputName2) => {
  QuaternionAngleToInputName2["q1"] = "q1";
  QuaternionAngleToInputName2["q2"] = "q2";
  return QuaternionAngleToInputName2;
})(QuaternionAngleToInputName || {});
var QuaternionAngleToOutputName = /* @__PURE__ */ ((QuaternionAngleToOutputName2) => {
  QuaternionAngleToOutputName2["angle"] = "angle";
  return QuaternionAngleToOutputName2;
})(QuaternionAngleToOutputName || {});
class QuaternionAngleToJsParamsConfig extends params_ParamsConfig/* NodeParamsConfig */.yI {
}
const QuaternionAngleTo_ParamsConfig = new QuaternionAngleToJsParamsConfig();
class QuaternionAngleToJsNode extends js_Base/* TypedJsNode */.xZ {
  constructor() {
    super(...arguments);
    this.paramsConfig = QuaternionAngleTo_ParamsConfig;
  }
  static type() {
    return "quaternionAngleTo";
  }
  initializeNode() {
    super.initializeNode();
    this.io.inputs.setNamedInputConnectionPoints([
      new connections_Js/* JsConnectionPoint */.fp("q1" /* q1 */, connections_Js/* JsConnectionPointType.QUATERNION */.zF.QUATERNION, QuaternionAngleTo_CONNECTION_OPTIONS),
      new connections_Js/* JsConnectionPoint */.fp("q2" /* q2 */, connections_Js/* JsConnectionPointType.QUATERNION */.zF.QUATERNION, QuaternionAngleTo_CONNECTION_OPTIONS)
    ]);
    this.io.outputs.setNamedOutputConnectionPoints([
      new connections_Js/* JsConnectionPoint */.fp("angle" /* angle */, connections_Js/* JsConnectionPointType.FLOAT */.zF.FLOAT)
    ]);
  }
  setLines(linesController) {
    const q1 = this.variableForInput(linesController, "q1" /* q1 */);
    const q2 = this.variableForInput(linesController, "q2" /* q2 */);
    const varName = this.jsVarName("angle" /* angle */);
    const func = Poly/* Poly.namedFunctionsRegister.getFunction */.L.namedFunctionsRegister.getFunction("quaternionAngleTo", this, linesController);
    linesController.addBodyOrComputed(this, [
      {
        dataType: connections_Js/* JsConnectionPointType.EULER */.zF.EULER,
        varName,
        value: func.asString(q1, q2)
      }
    ]);
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/js/QuaternionSlerp.ts






const QuaternionSlerp_CONNECTION_OPTIONS = connections_Js/* JS_CONNECTION_POINT_IN_NODE_DEF */.mX;
var QuaternionSlerpInputName = /* @__PURE__ */ ((QuaternionSlerpInputName2) => {
  QuaternionSlerpInputName2["q1"] = "q1";
  QuaternionSlerpInputName2["q2"] = "q2";
  return QuaternionSlerpInputName2;
})(QuaternionSlerpInputName || {});
class QuaternionSlerpJsParamsConfig extends params_ParamsConfig/* NodeParamsConfig */.yI {
  constructor() {
    super(...arguments);
    this.lerp = params_ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(0.5);
  }
}
const QuaternionSlerp_ParamsConfig = new QuaternionSlerpJsParamsConfig();
class QuaternionSlerpJsNode extends js_Base/* TypedJsNode */.xZ {
  constructor() {
    super(...arguments);
    this.paramsConfig = QuaternionSlerp_ParamsConfig;
  }
  static type() {
    return "quaternionSlerp";
  }
  initializeNode() {
    super.initializeNode();
    this.io.inputs.setNamedInputConnectionPoints([
      new connections_Js/* JsConnectionPoint */.fp("q1" /* q1 */, connections_Js/* JsConnectionPointType.QUATERNION */.zF.QUATERNION, QuaternionSlerp_CONNECTION_OPTIONS),
      new connections_Js/* JsConnectionPoint */.fp("q2" /* q2 */, connections_Js/* JsConnectionPointType.QUATERNION */.zF.QUATERNION, QuaternionSlerp_CONNECTION_OPTIONS)
      // new JsConnectionPoint(QuaternionSlerpInputName.lerp, JsConnectionPointType.FLOAT, CONNECTION_OPTIONS),
    ]);
    this.io.outputs.setNamedOutputConnectionPoints([
      new connections_Js/* JsConnectionPoint */.fp(connections_Js/* JsConnectionPointType.QUATERNION */.zF.QUATERNION, connections_Js/* JsConnectionPointType.QUATERNION */.zF.QUATERNION)
    ]);
  }
  setLines(linesController) {
    const q1 = this.variableForInput(linesController, "q1" /* q1 */);
    const q2 = this.variableForInput(linesController, "q2" /* q2 */);
    const lerp = this.variableForInputParam(linesController, this.p.lerp);
    const varName = this.jsVarName(connections_Js/* JsConnectionPointType.QUATERNION */.zF.QUATERNION);
    const tmpVarName = linesController.addVariable(this, new three_module.Quaternion());
    const func = Poly/* Poly.namedFunctionsRegister.getFunction */.L.namedFunctionsRegister.getFunction("quaternionSlerp", this, linesController);
    linesController.addBodyOrComputed(this, [
      {
        dataType: connections_Js/* JsConnectionPointType.EULER */.zF.EULER,
        varName,
        value: func.asString(q1, q2, lerp, tmpVarName)
      }
    ]);
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/js/RadToDeg.ts



const RadToDeg_FUNCTION_NAME = "radToDeg";
class RadToDegJsNode extends MathFunctionArg1OperationFactory("radToDeg", {
  inputPrefix: "in",
  out: "out"
}) {
  _coreFunction(shadersCollectionController) {
    Poly/* Poly.namedFunctionsRegister.getFunction */.L.namedFunctionsRegister.getFunction(RadToDeg_FUNCTION_NAME, this, shadersCollectionController).asString("");
    return RadToDeg_FUNCTION_NAME;
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/js/Rand.ts




var RandInput = /* @__PURE__ */ ((RandInput2) => {
  RandInput2["value0"] = "value0";
  RandInput2["value1"] = "value1";
  return RandInput2;
})(RandInput || {});
const Rand_DefaultValues = {
  ["value0" /* value0 */]: 0,
  ["value1" /* value1 */]: 0
};
const Rand_FUNCTION_NAME = "rand";
class RandJsNode extends _Math_Arg1Operation_MathFunctionArg2OperationFactory("rand", {
  inputPrefix: "in",
  out: "rand"
}) {
  _coreFunction(shadersCollectionController) {
    Poly/* Poly.namedFunctionsRegister.getFunction */.L.namedFunctionsRegister.getFunction(Rand_FUNCTION_NAME, this, shadersCollectionController).asString("", "");
    return Rand_FUNCTION_NAME;
  }
  paramDefaultValue(name) {
    return Rand_DefaultValues[name];
  }
  _expectedInputName(index) {
    return ["value0" /* value0 */, "value1" /* value1 */][index];
  }
  _expectedInputTypes() {
    return [connections_Js/* JsConnectionPointType.FLOAT */.zF.FLOAT, connections_Js/* JsConnectionPointType.FLOAT */.zF.FLOAT];
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/js/Random.ts





const js_Random_OUTPUT_NAME = "random";
class RandomJsParamsConfig extends params_ParamsConfig/* NodeParamsConfig */.yI {
}
const js_Random_ParamsConfig = new RandomJsParamsConfig();
class RandomJsNode extends js_Base/* TypedJsNode */.xZ {
  constructor() {
    super(...arguments);
    this.paramsConfig = js_Random_ParamsConfig;
  }
  static type() {
    return "random";
  }
  initializeNode() {
    this.io.inputs.setNamedInputConnectionPoints([]);
    this.io.outputs.setNamedOutputConnectionPoints([
      new connections_Js/* JsConnectionPoint */.fp(js_Random_OUTPUT_NAME, connections_Js/* JsConnectionPointType.FLOAT */.zF.FLOAT)
    ]);
  }
  setLines(shadersCollectionController) {
    const varName = this.jsVarName(js_Random_OUTPUT_NAME);
    const _func = Poly/* Poly.namedFunctionsRegister.getFunction */.L.namedFunctionsRegister.getFunction("random", this, shadersCollectionController).asString();
    shadersCollectionController.addBodyOrComputed(this, [
      { dataType: connections_Js/* JsConnectionPointType.FLOAT */.zF.FLOAT, varName, value: _func }
    ]);
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/js/Ray.ts






class RayJsParamsConfig extends params_ParamsConfig/* NodeParamsConfig */.yI {
  constructor() {
    super(...arguments);
    /** @param ray origin */
    this.origin = params_ParamsConfig/* ParamConfig.VECTOR3 */.XC.VECTOR3([0, 0, 0]);
    /** @param ray direction */
    this.direction = params_ParamsConfig/* ParamConfig.VECTOR3 */.XC.VECTOR3([0, 0, 1]);
  }
}
const Ray_ParamsConfig = new RayJsParamsConfig();
class RayJsNode extends js_Base/* TypedJsNode */.xZ {
  constructor() {
    super(...arguments);
    this.paramsConfig = Ray_ParamsConfig;
  }
  static type() {
    return "ray";
  }
  initializeNode() {
    super.initializeNode();
    this.io.outputs.setNamedOutputConnectionPoints([
      new connections_Js/* JsConnectionPoint */.fp(connections_Js/* JsConnectionPointType.RAY */.zF.RAY, connections_Js/* JsConnectionPointType.RAY */.zF.RAY)
    ]);
  }
  setLines(shadersCollectionController) {
    const origin = this.variableForInputParam(shadersCollectionController, this.p.origin);
    const direction = this.variableForInputParam(shadersCollectionController, this.p.direction);
    const out = this.jsVarName(connections_Js/* JsConnectionPointType.RAY */.zF.RAY);
    const tmpVarName = shadersCollectionController.addVariable(this, new three_module.Ray());
    const func = Poly/* Poly.namedFunctionsRegister.getFunction */.L.namedFunctionsRegister.getFunction("raySet", this, shadersCollectionController);
    const bodyLine = func.asString(origin, direction, tmpVarName);
    shadersCollectionController.addBodyOrComputed(this, [
      { dataType: connections_Js/* JsConnectionPointType.RAY */.zF.RAY, varName: out, value: bodyLine }
    ]);
  }
}

// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/nodes/js/RayFromCamera.ts
var RayFromCamera = __webpack_require__(54038);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/nodes/js/RayFromCursor.ts
var RayFromCursor = __webpack_require__(81025);
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/js/_BaseRayBox3.ts




const _BaseRayBox3_CONNECTION_OPTIONS = connections_Js/* JS_CONNECTION_POINT_IN_NODE_DEF */.mX;
class BaseRayBox3JsParamsConfig extends params_ParamsConfig/* NodeParamsConfig */.yI {
}
const _BaseRayBox3_ParamsConfig = new BaseRayBox3JsParamsConfig();
class BaseRayBox3JsNode extends js_Base/* TypedJsNode */.xZ {
  constructor() {
    super(...arguments);
    this.paramsConfig = _BaseRayBox3_ParamsConfig;
  }
  initializeNode() {
    this.io.inputs.setNamedInputConnectionPoints([
      new connections_Js/* JsConnectionPoint */.fp(connections_Js/* JsConnectionPointType.RAY */.zF.RAY, connections_Js/* JsConnectionPointType.RAY */.zF.RAY, _BaseRayBox3_CONNECTION_OPTIONS),
      new connections_Js/* JsConnectionPoint */.fp(connections_Js/* JsConnectionPointType.BOX3 */.zF.BOX3, connections_Js/* JsConnectionPointType.BOX3 */.zF.BOX3, _BaseRayBox3_CONNECTION_OPTIONS)
    ]);
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/js/RayIntersectBox.ts





const RayIntersectBox_CONNECTION_OPTIONS = connections_Js/* JS_CONNECTION_POINT_IN_NODE_DEF */.mX;
const RayIntersectBox_OUTPUT_NAME = "position";
class RayIntersectBoxJsNode extends BaseRayBox3JsNode {
  static type() {
    return "rayIntersectBox";
  }
  initializeNode() {
    super.initializeNode();
    this.io.outputs.setNamedOutputConnectionPoints([
      new connections_Js/* JsConnectionPoint */.fp(RayIntersectBox_OUTPUT_NAME, connections_Js/* JsConnectionPointType.VECTOR3 */.zF.VECTOR3, RayIntersectBox_CONNECTION_OPTIONS)
    ]);
  }
  setLines(shadersCollectionController) {
    const ray = this.variableForInput(shadersCollectionController, connections_Js/* JsConnectionPointType.RAY */.zF.RAY);
    const box3 = this.variableForInput(shadersCollectionController, connections_Js/* JsConnectionPointType.BOX3 */.zF.BOX3);
    const out = this.jsVarName(RayIntersectBox_OUTPUT_NAME);
    const tmpVarName = shadersCollectionController.addVariable(this, new three_module.Vector3());
    const func = Poly/* Poly.namedFunctionsRegister.getFunction */.L.namedFunctionsRegister.getFunction("rayIntersectBox3", this, shadersCollectionController);
    const bodyLine = func.asString(ray, box3, tmpVarName);
    shadersCollectionController.addBodyOrComputed(this, [
      { dataType: connections_Js/* JsConnectionPointType.VECTOR3 */.zF.VECTOR3, varName: out, value: bodyLine }
    ]);
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/js/RayIntersectsBox.ts




const RayIntersectsBox_CONNECTION_OPTIONS = connections_Js/* JS_CONNECTION_POINT_IN_NODE_DEF */.mX;
const RayIntersectsBox_OUTPUT_NAME = "intersects";
class RayIntersectsBoxJsNode extends BaseRayBox3JsNode {
  static type() {
    return "rayIntersectsBox";
  }
  initializeNode() {
    super.initializeNode();
    this.io.outputs.setNamedOutputConnectionPoints([
      new connections_Js/* JsConnectionPoint */.fp(RayIntersectsBox_OUTPUT_NAME, connections_Js/* JsConnectionPointType.BOOLEAN */.zF.BOOLEAN, RayIntersectsBox_CONNECTION_OPTIONS)
    ]);
  }
  setLines(shadersCollectionController) {
    const ray = this.variableForInput(shadersCollectionController, connections_Js/* JsConnectionPointType.RAY */.zF.RAY);
    const box3 = this.variableForInput(shadersCollectionController, connections_Js/* JsConnectionPointType.BOX3 */.zF.BOX3);
    const out = this.jsVarName(RayIntersectsBox_OUTPUT_NAME);
    const func = Poly/* Poly.namedFunctionsRegister.getFunction */.L.namedFunctionsRegister.getFunction("rayIntersectsBox3", this, shadersCollectionController);
    const bodyLine = func.asString(ray, box3);
    shadersCollectionController.addBodyOrComputed(this, [
      { dataType: connections_Js/* JsConnectionPointType.VECTOR3 */.zF.VECTOR3, varName: out, value: bodyLine }
    ]);
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/js/RayIntersectObject.ts






const RayIntersectObject_CONNECTION_OPTIONS = connections_Js/* JS_CONNECTION_POINT_IN_NODE_DEF */.mX;
class RayIntersectObjectJsParamsConfig extends params_ParamsConfig/* NodeParamsConfig */.yI {
  constructor() {
    super(...arguments);
    this.recursive = params_ParamsConfig/* ParamConfig.BOOLEAN */.XC.BOOLEAN(0);
  }
}
const RayIntersectObject_ParamsConfig = new RayIntersectObjectJsParamsConfig();
class RayIntersectObjectJsNode extends js_Base/* TypedJsNode */.xZ {
  constructor() {
    super(...arguments);
    this.paramsConfig = RayIntersectObject_ParamsConfig;
  }
  static type() {
    return "rayIntersectObject";
  }
  initializeNode() {
    this.io.inputs.setNamedInputConnectionPoints([
      new connections_Js/* JsConnectionPoint */.fp(connections_Js/* JsConnectionPointType.RAY */.zF.RAY, connections_Js/* JsConnectionPointType.RAY */.zF.RAY, RayIntersectObject_CONNECTION_OPTIONS),
      new connections_Js/* JsConnectionPoint */.fp(connections_Js/* JsConnectionPointType.OBJECT_3D */.zF.OBJECT_3D, connections_Js/* JsConnectionPointType.OBJECT_3D */.zF.OBJECT_3D, RayIntersectObject_CONNECTION_OPTIONS)
    ]);
    this.io.outputs.setNamedOutputConnectionPoints([
      new connections_Js/* JsConnectionPoint */.fp(
        connections_Js/* JsConnectionPointType.INTERSECTION */.zF.INTERSECTION,
        connections_Js/* JsConnectionPointType.INTERSECTION */.zF.INTERSECTION,
        RayIntersectObject_CONNECTION_OPTIONS
      )
    ]);
  }
  setLines(linesController) {
    const object3D = (0,_BaseObject3D/* inputObject3D */.iv)(this, linesController);
    const ray = this.variableForInput(linesController, connections_Js/* JsConnectionPointType.RAY */.zF.RAY);
    const recursive = this.variableForInputParam(linesController, this.p.recursive);
    const varName = this.jsVarName(connections_Js/* JsConnectionPointType.INTERSECTION */.zF.INTERSECTION);
    const func = Poly/* Poly.namedFunctionsRegister.getFunction */.L.namedFunctionsRegister.getFunction("rayIntersectObject3D", this, linesController);
    const bodyLine = func.asString(ray, object3D, recursive);
    linesController.addBodyOrComputed(this, [{ dataType: connections_Js/* JsConnectionPointType.VECTOR3 */.zF.VECTOR3, varName, value: bodyLine }]);
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/js/_BaseRayObject.ts




const _BaseRayObject_CONNECTION_OPTIONS = connections_Js/* JS_CONNECTION_POINT_IN_NODE_DEF */.mX;
class BaseRayObjectJsParamsConfig extends params_ParamsConfig/* NodeParamsConfig */.yI {
}
const _BaseRayObject_ParamsConfig = new BaseRayObjectJsParamsConfig();
class BaseRayObjectJsNode extends js_Base/* TypedJsNode */.xZ {
  constructor() {
    super(...arguments);
    this.paramsConfig = _BaseRayObject_ParamsConfig;
  }
  initializeNode() {
    this.io.inputs.setNamedInputConnectionPoints([
      new connections_Js/* JsConnectionPoint */.fp(connections_Js/* JsConnectionPointType.RAY */.zF.RAY, connections_Js/* JsConnectionPointType.RAY */.zF.RAY, _BaseRayObject_CONNECTION_OPTIONS),
      new connections_Js/* JsConnectionPoint */.fp(connections_Js/* JsConnectionPointType.OBJECT_3D */.zF.OBJECT_3D, connections_Js/* JsConnectionPointType.OBJECT_3D */.zF.OBJECT_3D, _BaseRayObject_CONNECTION_OPTIONS),
      ...this._additionalInputs()
    ]);
  }
  _additionalInputs() {
    return [];
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/js/RayIntersectsObject.ts





const RayIntersectsObject_CONNECTION_OPTIONS = connections_Js/* JS_CONNECTION_POINT_IN_NODE_DEF */.mX;
const RayIntersectsObject_OUTPUT_NAME = "intersects";
var RayIntersectsObjectJsNodeInputName = /* @__PURE__ */ ((RayIntersectsObjectJsNodeInputName2) => {
  RayIntersectsObjectJsNodeInputName2["RECURSIVE"] = "recursive";
  return RayIntersectsObjectJsNodeInputName2;
})(RayIntersectsObjectJsNodeInputName || {});
class RayIntersectsObjectJsNode extends BaseRayObjectJsNode {
  static type() {
    return "rayIntersectsObject";
  }
  initializeNode() {
    super.initializeNode();
    this.io.outputs.setNamedOutputConnectionPoints([
      new connections_Js/* JsConnectionPoint */.fp(RayIntersectsObject_OUTPUT_NAME, connections_Js/* JsConnectionPointType.BOOLEAN */.zF.BOOLEAN, RayIntersectsObject_CONNECTION_OPTIONS)
    ]);
  }
  _additionalInputs() {
    return [
      new connections_Js/* JsConnectionPoint */.fp(
        "recursive" /* RECURSIVE */,
        connections_Js/* JsConnectionPointType.BOOLEAN */.zF.BOOLEAN,
        RayIntersectsObject_CONNECTION_OPTIONS
      )
    ];
  }
  setLines(linesController) {
    const object3D = (0,_BaseObject3D/* inputObject3D */.iv)(this, linesController);
    const ray = this.variableForInput(linesController, connections_Js/* JsConnectionPointType.RAY */.zF.RAY);
    const recursive = this.variableForInput(linesController, "recursive" /* RECURSIVE */);
    const out = this.jsVarName(RayIntersectsObject_OUTPUT_NAME);
    const func = Poly/* Poly.namedFunctionsRegister.getFunction */.L.namedFunctionsRegister.getFunction("rayIntersectsObject3D", this, linesController);
    const bodyLine = func.asString(ray, object3D, recursive);
    linesController.addBodyOrComputed(this, [
      { dataType: connections_Js/* JsConnectionPointType.VECTOR3 */.zF.VECTOR3, varName: out, value: bodyLine }
    ]);
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/js/_BaseRayPlane.ts




const _BaseRayPlane_CONNECTION_OPTIONS = connections_Js/* JS_CONNECTION_POINT_IN_NODE_DEF */.mX;
class BaseRayPlaneJsParamsConfig extends params_ParamsConfig/* NodeParamsConfig */.yI {
}
const _BaseRayPlane_ParamsConfig = new BaseRayPlaneJsParamsConfig();
class BaseRayPlaneJsNode extends js_Base/* TypedJsNode */.xZ {
  constructor() {
    super(...arguments);
    this.paramsConfig = _BaseRayPlane_ParamsConfig;
  }
  initializeNode() {
    this.io.inputs.setNamedInputConnectionPoints([
      new connections_Js/* JsConnectionPoint */.fp(connections_Js/* JsConnectionPointType.RAY */.zF.RAY, connections_Js/* JsConnectionPointType.RAY */.zF.RAY, _BaseRayPlane_CONNECTION_OPTIONS),
      new connections_Js/* JsConnectionPoint */.fp(connections_Js/* JsConnectionPointType.PLANE */.zF.PLANE, connections_Js/* JsConnectionPointType.PLANE */.zF.PLANE, _BaseRayPlane_CONNECTION_OPTIONS)
    ]);
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/js/RayDistanceToPlane.ts




const RayDistanceToPlane_OUTPUT_NAME = "distance";
class RayDistanceToPlaneJsNode extends BaseRayPlaneJsNode {
  static type() {
    return "rayDistanceToPlane";
  }
  initializeNode() {
    super.initializeNode();
    this.io.outputs.setNamedOutputConnectionPoints([
      new connections_Js/* JsConnectionPoint */.fp(RayDistanceToPlane_OUTPUT_NAME, connections_Js/* JsConnectionPointType.FLOAT */.zF.FLOAT)
    ]);
  }
  setLines(shadersCollectionController) {
    const ray = this.variableForInput(shadersCollectionController, connections_Js/* JsConnectionPointType.RAY */.zF.RAY);
    const plane = this.variableForInput(shadersCollectionController, connections_Js/* JsConnectionPointType.PLANE */.zF.PLANE);
    const out = this.jsVarName(RayDistanceToPlane_OUTPUT_NAME);
    const func = Poly/* Poly.namedFunctionsRegister.getFunction */.L.namedFunctionsRegister.getFunction("rayDistanceToPlane", this, shadersCollectionController);
    const bodyLine = func.asString(ray, plane);
    shadersCollectionController.addBodyOrComputed(this, [
      { dataType: connections_Js/* JsConnectionPointType.FLOAT */.zF.FLOAT, varName: out, value: bodyLine }
    ]);
  }
  // protected _expectedOutputName(index: number) {
  // 	return OUTPUT_NAME;
  // }
  // protected _expectedOutputType(): ActorConnectionPointType.FLOAT {
  // 	return ActorConnectionPointType.FLOAT;
  // }
  // protected _processRayData() {
  // 	if (this._processData.ray && this._processData.plane) {
  // 		return this._processData.ray.distanceToPlane(this._processData.plane);
  // 	} else {
  // 		return 0;
  // 	}
  // }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/js/RayIntersectPlane.ts





const RayIntersectPlane_OUTPUT_NAME = "position";
class RayIntersectPlaneJsNode extends BaseRayPlaneJsNode {
  static type() {
    return "rayIntersectPlane";
  }
  initializeNode() {
    super.initializeNode();
    this.io.outputs.setNamedOutputConnectionPoints([
      new connections_Js/* JsConnectionPoint */.fp(RayIntersectPlane_OUTPUT_NAME, connections_Js/* JsConnectionPointType.VECTOR3 */.zF.VECTOR3)
    ]);
  }
  setLines(shadersCollectionController) {
    const ray = this.variableForInput(shadersCollectionController, connections_Js/* JsConnectionPointType.RAY */.zF.RAY);
    const plane = this.variableForInput(shadersCollectionController, connections_Js/* JsConnectionPointType.PLANE */.zF.PLANE);
    const out = this.jsVarName(RayIntersectPlane_OUTPUT_NAME);
    const tmpVarName = shadersCollectionController.addVariable(this, new three_module.Vector3());
    const func = Poly/* Poly.namedFunctionsRegister.getFunction */.L.namedFunctionsRegister.getFunction("rayIntersectPlane", this, shadersCollectionController);
    const bodyLine = func.asString(ray, plane, tmpVarName);
    shadersCollectionController.addBodyOrComputed(this, [
      { dataType: connections_Js/* JsConnectionPointType.VECTOR3 */.zF.VECTOR3, varName: out, value: bodyLine }
    ]);
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/js/RayIntersectsPlane.ts




const RayIntersectsPlane_OUTPUT_NAME = "intersects";
class RayIntersectsPlaneJsNode extends BaseRayPlaneJsNode {
  static type() {
    return "rayIntersectsPlane";
  }
  initializeNode() {
    super.initializeNode();
    this.io.outputs.setNamedOutputConnectionPoints([
      new connections_Js/* JsConnectionPoint */.fp(RayIntersectsPlane_OUTPUT_NAME, connections_Js/* JsConnectionPointType.BOOLEAN */.zF.BOOLEAN)
    ]);
  }
  setLines(shadersCollectionController) {
    const ray = this.variableForInput(shadersCollectionController, connections_Js/* JsConnectionPointType.RAY */.zF.RAY);
    const plane = this.variableForInput(shadersCollectionController, connections_Js/* JsConnectionPointType.PLANE */.zF.PLANE);
    const out = this.jsVarName(RayIntersectsPlane_OUTPUT_NAME);
    const func = Poly/* Poly.namedFunctionsRegister.getFunction */.L.namedFunctionsRegister.getFunction("rayIntersectsPlane", this, shadersCollectionController);
    const bodyLine = func.asString(ray, plane);
    shadersCollectionController.addBodyOrComputed(this, [
      { dataType: connections_Js/* JsConnectionPointType.VECTOR3 */.zF.VECTOR3, varName: out, value: bodyLine }
    ]);
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/js/_BaseRaySphere.ts




const _BaseRaySphere_CONNECTION_OPTIONS = connections_Js/* JS_CONNECTION_POINT_IN_NODE_DEF */.mX;
class BaseRaySphereJsParamsConfig extends params_ParamsConfig/* NodeParamsConfig */.yI {
}
const _BaseRaySphere_ParamsConfig = new BaseRaySphereJsParamsConfig();
class BaseRaySphereJsNode extends js_Base/* TypedJsNode */.xZ {
  constructor() {
    super(...arguments);
    this.paramsConfig = _BaseRaySphere_ParamsConfig;
  }
  initializeNode() {
    this.io.inputs.setNamedInputConnectionPoints([
      new connections_Js/* JsConnectionPoint */.fp(connections_Js/* JsConnectionPointType.RAY */.zF.RAY, connections_Js/* JsConnectionPointType.RAY */.zF.RAY, _BaseRaySphere_CONNECTION_OPTIONS),
      new connections_Js/* JsConnectionPoint */.fp(connections_Js/* JsConnectionPointType.SPHERE */.zF.SPHERE, connections_Js/* JsConnectionPointType.SPHERE */.zF.SPHERE, _BaseRaySphere_CONNECTION_OPTIONS)
    ]);
  }
  // override initializeNode() {
  // 	super.initializeNode();
  // 	this.io.connection_points.initializeNode();
  // 	this.io.connection_points.set_input_name_function(this._expectedInputName.bind(this));
  // 	this.io.connection_points.set_output_name_function(this._expectedOutputName.bind(this));
  // 	this.io.connection_points.set_expected_input_types_function(this._expectedInputType.bind(this));
  // 	this.io.connection_points.set_expected_output_types_function(() => [this._expectedOutputType()]);
  // }
  // protected abstract _expectedOutputName(index: number): string;
  // protected abstract _expectedOutputType(): T;
  // protected _processData: RayProcessData = {};
  // protected abstract _processRayData(): ReturnValueTypeByActorConnectionPointType[T];
  // protected _expectedInputName(index: number) {
  // 	return this._expectedInputType()[index];
  // }
  // protected _expectedInputType() {
  // 	return [ActorConnectionPointType.RAY, ActorConnectionPointType.SPHERE];
  // }
  // public override outputValue(context: ActorNodeTriggerContext) {
  // 	this._processData.ray = this._inputValue<ActorConnectionPointType.RAY>(ActorConnectionPointType.RAY, context);
  // 	this._processData.sphere = this._inputValue<ActorConnectionPointType.SPHERE>(
  // 		ActorConnectionPointType.SPHERE,
  // 		context
  // 	);
  // 	return this._processRayData();
  // }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/js/RayIntersectSphere.ts





const RayIntersectSphere_CONNECTION_OPTIONS = connections_Js/* JS_CONNECTION_POINT_IN_NODE_DEF */.mX;
const RayIntersectSphere_OUTPUT_NAME = "position";
class RayIntersectSphereJsNode extends BaseRaySphereJsNode {
  static type() {
    return "rayIntersectSphere";
  }
  initializeNode() {
    super.initializeNode();
    this.io.outputs.setNamedOutputConnectionPoints([
      new connections_Js/* JsConnectionPoint */.fp(RayIntersectSphere_OUTPUT_NAME, connections_Js/* JsConnectionPointType.BOOLEAN */.zF.BOOLEAN, RayIntersectSphere_CONNECTION_OPTIONS)
    ]);
  }
  setLines(shadersCollectionController) {
    const ray = this.variableForInput(shadersCollectionController, connections_Js/* JsConnectionPointType.RAY */.zF.RAY);
    const sphere = this.variableForInput(shadersCollectionController, connections_Js/* JsConnectionPointType.SPHERE */.zF.SPHERE);
    const out = this.jsVarName(RayIntersectSphere_OUTPUT_NAME);
    const tmpVarName = shadersCollectionController.addVariable(this, new three_module.Vector3());
    const func = Poly/* Poly.namedFunctionsRegister.getFunction */.L.namedFunctionsRegister.getFunction("rayIntersectSphere", this, shadersCollectionController);
    const bodyLine = func.asString(ray, sphere, tmpVarName);
    shadersCollectionController.addBodyOrComputed(this, [
      { dataType: connections_Js/* JsConnectionPointType.VECTOR3 */.zF.VECTOR3, varName: out, value: bodyLine }
    ]);
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/js/RayIntersectsSphere.ts




const RayIntersectsSphere_CONNECTION_OPTIONS = connections_Js/* JS_CONNECTION_POINT_IN_NODE_DEF */.mX;
const RayIntersectsSphere_OUTPUT_NAME = "intersects";
class RayIntersectsSphereJsNode extends BaseRaySphereJsNode {
  static type() {
    return "rayIntersectsSphere";
  }
  initializeNode() {
    super.initializeNode();
    this.io.outputs.setNamedOutputConnectionPoints([
      new connections_Js/* JsConnectionPoint */.fp(RayIntersectsSphere_OUTPUT_NAME, connections_Js/* JsConnectionPointType.BOOLEAN */.zF.BOOLEAN, RayIntersectsSphere_CONNECTION_OPTIONS)
    ]);
  }
  setLines(shadersCollectionController) {
    const ray = this.variableForInput(shadersCollectionController, connections_Js/* JsConnectionPointType.RAY */.zF.RAY);
    const sphere = this.variableForInput(shadersCollectionController, connections_Js/* JsConnectionPointType.SPHERE */.zF.SPHERE);
    const out = this.jsVarName(RayIntersectsSphere_OUTPUT_NAME);
    const func = Poly/* Poly.namedFunctionsRegister.getFunction */.L.namedFunctionsRegister.getFunction("rayIntersectsSphere", this, shadersCollectionController);
    const bodyLine = func.asString(ray, sphere);
    shadersCollectionController.addBodyOrComputed(this, [
      { dataType: connections_Js/* JsConnectionPointType.VECTOR3 */.zF.VECTOR3, varName: out, value: bodyLine }
    ]);
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/js/RenderPixel.ts








const RenderPixel_CONNECTION_OPTIONS = connections_Js/* JS_CONNECTION_POINT_IN_NODE_DEF */.mX;
var RenderPixelJsNodeOutputName = /* @__PURE__ */ ((RenderPixelJsNodeOutputName2) => {
  RenderPixelJsNodeOutputName2["value"] = "value";
  return RenderPixelJsNodeOutputName2;
})(RenderPixelJsNodeOutputName || {});
class RenderPixelJsParamsConfig extends params_ParamsConfig/* NodeParamsConfig */.yI {
  constructor() {
    super(...arguments);
    this.uv = params_ParamsConfig/* ParamConfig.VECTOR2 */.XC.VECTOR2([0, 0]);
    this.backgroundColor = params_ParamsConfig/* ParamConfig.COLOR */.XC.COLOR([0, 0, 0]);
  }
}
const RenderPixel_ParamsConfig = new RenderPixelJsParamsConfig();
class RenderPixelJsNode extends js_Base/* TypedJsNode */.xZ {
  constructor() {
    super(...arguments);
    this.paramsConfig = RenderPixel_ParamsConfig;
  }
  static type() {
    return "renderPixel";
  }
  initializeNode() {
    this.io.inputs.setNamedInputConnectionPoints([
      new connections_Js/* JsConnectionPoint */.fp(js_Base/* TRIGGER_CONNECTION_NAME */.w6, connections_Js/* JsConnectionPointType.TRIGGER */.zF.TRIGGER, RenderPixel_CONNECTION_OPTIONS),
      new connections_Js/* JsConnectionPoint */.fp(connections_Js/* JsConnectionPointType.OBJECT_3D */.zF.OBJECT_3D, connections_Js/* JsConnectionPointType.OBJECT_3D */.zF.OBJECT_3D, RenderPixel_CONNECTION_OPTIONS),
      new connections_Js/* JsConnectionPoint */.fp(connections_Js/* JsConnectionPointType.MATERIAL */.zF.MATERIAL, connections_Js/* JsConnectionPointType.MATERIAL */.zF.MATERIAL, RenderPixel_CONNECTION_OPTIONS),
      new connections_Js/* JsConnectionPoint */.fp(connections_Js/* JsConnectionPointType.CAMERA */.zF.CAMERA, connections_Js/* JsConnectionPointType.CAMERA */.zF.CAMERA, RenderPixel_CONNECTION_OPTIONS)
    ]);
    this.io.outputs.setNamedOutputConnectionPoints([
      new connections_Js/* JsConnectionPoint */.fp(js_Base/* TRIGGER_CONNECTION_NAME */.w6, connections_Js/* JsConnectionPointType.TRIGGER */.zF.TRIGGER),
      new connections_Js/* JsConnectionPoint */.fp(connections_Js/* JsConnectionPointType.OBJECT_3D */.zF.OBJECT_3D, connections_Js/* JsConnectionPointType.OBJECT_3D */.zF.OBJECT_3D),
      new connections_Js/* JsConnectionPoint */.fp(connections_Js/* JsConnectionPointType.MATERIAL */.zF.MATERIAL, connections_Js/* JsConnectionPointType.MATERIAL */.zF.MATERIAL, RenderPixel_CONNECTION_OPTIONS),
      new connections_Js/* JsConnectionPoint */.fp("value" /* value */, connections_Js/* JsConnectionPointType.VECTOR4 */.zF.VECTOR4, RenderPixel_CONNECTION_OPTIONS)
    ]);
  }
  setLines(linesController) {
    const usedOutputNames = this.io.outputs.used_output_names();
    if (usedOutputNames.includes("value" /* value */)) {
      this._addValueRef(linesController);
      if (!usedOutputNames.includes(connections_Js/* JsConnectionPointType.TRIGGER */.zF.TRIGGER)) {
        this.setTriggeringLines(linesController, "");
      }
    }
    (0,_BaseObject3D/* setObject3DOutputLine */.PV)(this, linesController);
  }
  setTriggerableLines(linesController) {
    const object3D = (0,_BaseObject3D/* inputObject3D */.iv)(this, linesController);
    const material = this.variableForInput(linesController, connections_Js/* JsConnectionPointType.MATERIAL */.zF.MATERIAL);
    const camera = this.variableForInput(linesController, connections_Js/* JsConnectionPointType.CAMERA */.zF.CAMERA);
    const backgroundColor = this.variableForInputParam(linesController, this.p.backgroundColor);
    const uv = this.variableForInputParam(linesController, this.p.uv);
    const refValue = this._addValueRef(linesController);
    const func = Poly/* Poly.namedFunctionsRegister.getFunction */.L.namedFunctionsRegister.getFunction("renderPixel", this, linesController);
    const bodyLine = func.asString(object3D, material, camera, backgroundColor, uv, `this.${refValue}.value`);
    linesController.addTriggerableLines(this, [bodyLine]);
  }
  _addValueRef(linesController) {
    const outValue = this.jsVarName("value" /* value */);
    const tmpVarName = linesController.addVariable(this, new three_module.Vector4());
    linesController.addDefinitions(this, [
      new JsDefinition/* RefJsDefinition */.Z(this, linesController, connections_Js/* JsConnectionPointType.BOOLEAN */.zF.BOOLEAN, outValue, tmpVarName)
    ]);
    return outValue;
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/js/Rotate.ts






var JsRotateMode = /* @__PURE__ */ ((JsRotateMode2) => {
  JsRotateMode2[JsRotateMode2["AXIS"] = 0] = "AXIS";
  JsRotateMode2[JsRotateMode2["QUAT"] = 1] = "QUAT";
  return JsRotateMode2;
})(JsRotateMode || {});
const Rotate_Modes = [0 /* AXIS */, 1 /* QUAT */];
var JsRotateInputNameAxisMode = /* @__PURE__ */ ((JsRotateInputNameAxisMode2) => {
  JsRotateInputNameAxisMode2["AXIS"] = "axis";
  JsRotateInputNameAxisMode2["ANGLE"] = "angle";
  return JsRotateInputNameAxisMode2;
})(JsRotateInputNameAxisMode || {});
const Rotate_LabelByMode = {
  [0 /* AXIS */]: "from axis + angle",
  [1 /* QUAT */]: "from quaternion"
};
const Rotate_InputNamesByMode = {
  [0 /* AXIS */]: [
    connections_Js/* JsConnectionPointType.VECTOR3 */.zF.VECTOR3,
    "axis" /* AXIS */,
    "angle" /* ANGLE */
  ],
  [1 /* QUAT */]: [connections_Js/* JsConnectionPointType.VECTOR3 */.zF.VECTOR3, connections_Js/* JsConnectionPointType.QUATERNION */.zF.QUATERNION]
};
const Rotate_MethodNameByMode = {
  [0 /* AXIS */]: "rotateWithAxisAngle",
  [1 /* QUAT */]: "rotateWithQuat"
};
const Rotate_InputTypesByMode = {
  [0 /* AXIS */]: [connections_Js/* JsConnectionPointType.VECTOR3 */.zF.VECTOR3, connections_Js/* JsConnectionPointType.VECTOR3 */.zF.VECTOR3, connections_Js/* JsConnectionPointType.FLOAT */.zF.FLOAT],
  [1 /* QUAT */]: [connections_Js/* JsConnectionPointType.VECTOR3 */.zF.VECTOR3, connections_Js/* JsConnectionPointType.QUATERNION */.zF.QUATERNION]
};
const js_Rotate_DefaultValues = {
  vector: [0, 0, 1],
  axis: [0, 1, 0]
};
class Rotate_RotateParamsConfig extends params_ParamsConfig/* NodeParamsConfig */.yI {
  constructor() {
    super(...arguments);
    this.mode = params_ParamsConfig/* ParamConfig.INTEGER */.XC.INTEGER(0 /* AXIS */, {
      menu: {
        entries: Rotate_Modes.map((mode, i) => {
          const label = Rotate_LabelByMode[mode];
          return { name: label, value: i };
        })
      }
    });
  }
}
const js_Rotate_ParamsConfig = new Rotate_RotateParamsConfig();
class RotateJsNode extends js_Base/* TypedJsNode */.xZ {
  constructor() {
    super(...arguments);
    this.paramsConfig = js_Rotate_ParamsConfig;
  }
  static type() {
    return "rotate";
  }
  initializeNode() {
    super.initializeNode();
    this.io.connection_points.set_expected_input_types_function(this._expectedInputTypes.bind(this));
    this.io.connection_points.set_expected_output_types_function(this._expectedOutputTypes.bind(this));
    this.io.connection_points.set_input_name_function(this._expectedInputName.bind(this));
    this.io.connection_points.set_output_name_function(this._expectedOutputName.bind(this));
  }
  setMode(mode) {
    const index = Rotate_Modes.indexOf(mode);
    this.p.mode.set(index);
  }
  mode() {
    return Rotate_Modes[this.pv.mode] || 0 /* AXIS */;
  }
  _expectedInputName(index) {
    return Rotate_InputNamesByMode[this.mode()][index];
  }
  _expectedOutputName(index) {
    return connections_Js/* JsConnectionPointType.VECTOR3 */.zF.VECTOR3;
  }
  paramDefaultValue(name) {
    return js_Rotate_DefaultValues[name];
  }
  functionName() {
    return Rotate_MethodNameByMode[this.mode()];
  }
  _expectedInputTypes() {
    return Rotate_InputTypesByMode[this.mode()];
  }
  _expectedOutputTypes() {
    return [connections_Js/* JsConnectionPointType.VECTOR3 */.zF.VECTOR3];
  }
  setLines(linesController) {
    const mode = this.mode();
    switch (mode) {
      case 0 /* AXIS */:
        this._setLinesForAxisAngle(linesController);
        break;
      case 1 /* QUAT */:
        this._setLinesForQuat(linesController);
        break;
    }
  }
  _setLinesForAxisAngle(linesController) {
    const inputNames = Rotate_InputNamesByMode[0 /* AXIS */];
    const vector = this.variableForInput(linesController, inputNames[0]);
    const axis = this.variableForInput(linesController, inputNames[1]);
    const angle = this.variableForInput(linesController, inputNames[2]);
    const varName = this.jsVarName(connections_Js/* JsConnectionPointType.VECTOR3 */.zF.VECTOR3);
    const tmpVarName = linesController.addVariable(this, new three_module.Vector3());
    const func = Poly/* Poly.namedFunctionsRegister.getFunction */.L.namedFunctionsRegister.getFunction("rotateWithAxisAngle", this, linesController);
    linesController.addBodyOrComputed(this, [
      {
        dataType: connections_Js/* JsConnectionPointType.EULER */.zF.EULER,
        varName,
        value: func.asString(vector, axis, angle, tmpVarName)
      }
    ]);
  }
  _setLinesForQuat(linesController) {
    const inputNames = Rotate_InputNamesByMode[1 /* QUAT */];
    const vector = this.variableForInput(linesController, inputNames[0]);
    const quat = this.variableForInput(linesController, inputNames[1]);
    const varName = this.jsVarName(connections_Js/* JsConnectionPointType.VECTOR3 */.zF.VECTOR3);
    const tmpVarName = linesController.addVariable(this, new three_module.Vector3());
    const func = Poly/* Poly.namedFunctionsRegister.getFunction */.L.namedFunctionsRegister.getFunction("rotateWithQuaternion", this, linesController);
    linesController.addBodyOrComputed(this, [
      {
        dataType: connections_Js/* JsConnectionPointType.EULER */.zF.EULER,
        varName,
        value: func.asString(vector, quat, tmpVarName)
      }
    ]);
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/js/Round.ts


class RoundJsNode extends MathFunctionArg1OperationFactory("round", {
  inputPrefix: "val",
  out: "round"
}) {
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/js/_BaseSDF2D.ts



class BaseSDF2DJsParamsConfig extends (/* unused pure expression or super */ null && (NodeParamsConfig)) {
  constructor() {
    super(...arguments);
    this.position = ParamConfig.VECTOR2([0, 0]);
  }
}
class BaseSDF2DJsNode extends js_Base/* TypedJsNode */.xZ {
  // protected position(shadersCollectionController: ShadersCollectionController) {
  // 	const inputPosition = this.io.inputs.named_input(this.p.position.name());
  // 	const position = inputPosition
  // 		? this.variableForInputParam(shadersCollectionController, this.p.position)
  // 		: this._defaultPosition(shadersCollectionController);
  // 	return position;
  // }
  // private _defaultPosition(shadersCollectionController: ShadersCollectionController): string {
  // 	const sanitizedNodePath = CoreString.sanitizeName(this.path());
  // 	const varName = `${sanitizedNodePath}_${this.p.position.name()}`;
  // 	shadersCollectionController.addVariable(this, varName, new Vector3());
  // 	return `${varName}.copy(${VARS.position})`;
  // }
  // protected _addSDF2DMethods(shadersCollectionController: ShadersCollectionController) {
  // 	shadersCollectionController.addDefinitions(this, [new FunctionGLDefinition(this, SDFMethodsCommon)]);
  // 	shadersCollectionController.addDefinitions(this, [new FunctionGLDefinition(this, SDFMethods2D)]);
  // }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/js/SDF2DBox.ts






const js_SDF2DBox_OUTPUT_NAME = "float";
class SDF2DBoxJsParamsConfig extends params_ParamsConfig/* NodeParamsConfig */.yI {
  constructor() {
    super(...arguments);
    this.position = params_ParamsConfig/* ParamConfig.VECTOR2 */.XC.VECTOR2([0, 0], { hidden: true });
    this.center = params_ParamsConfig/* ParamConfig.VECTOR2 */.XC.VECTOR2([0, 0]);
    this.sizes = params_ParamsConfig/* ParamConfig.VECTOR2 */.XC.VECTOR2([1, 1]);
  }
}
const js_SDF2DBox_ParamsConfig = new SDF2DBoxJsParamsConfig();
class SDF2DBoxJsNode extends BaseSDF2DJsNode {
  constructor() {
    super(...arguments);
    this.paramsConfig = js_SDF2DBox_ParamsConfig;
  }
  static type() {
    return Js/* JsType.SDF_2D_BOX */.K.SDF_2D_BOX;
  }
  initializeNode() {
    super.initializeNode();
    this.io.outputs.setNamedOutputConnectionPoints([
      new connections_Js/* JsConnectionPoint */.fp(js_SDF2DBox_OUTPUT_NAME, connections_Js/* JsConnectionPointType.FLOAT */.zF.FLOAT)
    ]);
  }
  setLines(shadersCollectionController) {
    const position = this.variableForInputParam(shadersCollectionController, this.p.position);
    const center = this.variableForInputParam(shadersCollectionController, this.p.center);
    const sizes = this.variableForInputParam(shadersCollectionController, this.p.sizes);
    const float = this.jsVarName(js_SDF2DBox_OUTPUT_NAME);
    const func = Poly/* Poly.namedFunctionsRegister.getFunction */.L.namedFunctionsRegister.getFunction("SDF2DBox", this, shadersCollectionController);
    shadersCollectionController.addBodyOrComputed(this, [
      {
        dataType: connections_Js/* JsConnectionPointType.FLOAT */.zF.FLOAT,
        varName: float,
        value: func.asString(position, center, sizes)
      }
    ]);
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/js/SDF2DCircle.ts






const js_SDF2DCircle_OUTPUT_NAME = "float";
class SDF2DCircleJsParamsConfig extends params_ParamsConfig/* NodeParamsConfig */.yI {
  constructor() {
    super(...arguments);
    this.position = params_ParamsConfig/* ParamConfig.VECTOR2 */.XC.VECTOR2([0, 0], { hidden: true });
    this.center = params_ParamsConfig/* ParamConfig.VECTOR2 */.XC.VECTOR2([0, 0]);
    this.radius = params_ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(1);
  }
}
const js_SDF2DCircle_ParamsConfig = new SDF2DCircleJsParamsConfig();
class SDF2DCircleJsNode extends BaseSDF2DJsNode {
  constructor() {
    super(...arguments);
    this.paramsConfig = js_SDF2DCircle_ParamsConfig;
  }
  static type() {
    return Js/* JsType.SDF_2D_CIRCLE */.K.SDF_2D_CIRCLE;
  }
  initializeNode() {
    super.initializeNode();
    this.io.outputs.setNamedOutputConnectionPoints([
      new connections_Js/* JsConnectionPoint */.fp(js_SDF2DCircle_OUTPUT_NAME, connections_Js/* JsConnectionPointType.FLOAT */.zF.FLOAT)
    ]);
  }
  setLines(shadersCollectionController) {
    const position = this.variableForInputParam(shadersCollectionController, this.p.position);
    const center = this.variableForInputParam(shadersCollectionController, this.p.center);
    const radius = this.variableForInputParam(shadersCollectionController, this.p.radius);
    const float = this.jsVarName(js_SDF2DCircle_OUTPUT_NAME);
    const func = Poly/* Poly.namedFunctionsRegister.getFunction */.L.namedFunctionsRegister.getFunction("SDF2DCircle", this, shadersCollectionController);
    shadersCollectionController.addBodyOrComputed(this, [
      {
        dataType: connections_Js/* JsConnectionPointType.FLOAT */.zF.FLOAT,
        varName: float,
        value: func.asString(position, center, radius)
      }
    ]);
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/js/SDF2DCross.ts






const js_SDF2DCross_OUTPUT_NAME = "float";
class SDF2DCrossJsParamsConfig extends params_ParamsConfig/* NodeParamsConfig */.yI {
  constructor() {
    super(...arguments);
    this.position = params_ParamsConfig/* ParamConfig.VECTOR2 */.XC.VECTOR2([0, 0], { hidden: true });
    this.center = params_ParamsConfig/* ParamConfig.VECTOR2 */.XC.VECTOR2([0, 0]);
    this.length = params_ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(1);
    this.width = params_ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(0.3);
    this.radius = params_ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(0, {
      range: [-1, 1]
    });
  }
}
const js_SDF2DCross_ParamsConfig = new SDF2DCrossJsParamsConfig();
class SDF2DCrossJsNode extends BaseSDF2DJsNode {
  constructor() {
    super(...arguments);
    this.paramsConfig = js_SDF2DCross_ParamsConfig;
  }
  static type() {
    return Js/* JsType.SDF_2D_CROSS */.K.SDF_2D_CROSS;
  }
  initializeNode() {
    super.initializeNode();
    this.io.outputs.setNamedOutputConnectionPoints([
      new connections_Js/* JsConnectionPoint */.fp(js_SDF2DCross_OUTPUT_NAME, connections_Js/* JsConnectionPointType.FLOAT */.zF.FLOAT)
    ]);
  }
  setLines(shadersCollectionController) {
    const position = this.variableForInputParam(shadersCollectionController, this.p.position);
    const center = this.variableForInputParam(shadersCollectionController, this.p.center);
    const length = this.variableForInputParam(shadersCollectionController, this.p.length);
    const width = this.variableForInputParam(shadersCollectionController, this.p.width);
    const radius = this.variableForInputParam(shadersCollectionController, this.p.radius);
    const float = this.jsVarName(js_SDF2DCross_OUTPUT_NAME);
    const func = Poly/* Poly.namedFunctionsRegister.getFunction */.L.namedFunctionsRegister.getFunction("SDF2DCross", this, shadersCollectionController);
    shadersCollectionController.addBodyOrComputed(this, [
      {
        dataType: connections_Js/* JsConnectionPointType.FLOAT */.zF.FLOAT,
        varName: float,
        value: func.asString(position, center, length, width, radius)
      }
    ]);
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/js/SDF2DHeart.ts






const js_SDF2DHeart_OUTPUT_NAME = "float";
class SDF2DHeartJsParamsConfig extends params_ParamsConfig/* NodeParamsConfig */.yI {
  constructor() {
    super(...arguments);
    this.position = params_ParamsConfig/* ParamConfig.VECTOR2 */.XC.VECTOR2([0, 0], { hidden: true });
    this.center = params_ParamsConfig/* ParamConfig.VECTOR2 */.XC.VECTOR2([0, 0]);
  }
}
const js_SDF2DHeart_ParamsConfig = new SDF2DHeartJsParamsConfig();
class SDF2DHeartJsNode extends BaseSDF2DJsNode {
  constructor() {
    super(...arguments);
    this.paramsConfig = js_SDF2DHeart_ParamsConfig;
  }
  static type() {
    return Js/* JsType.SDF_2D_HEART */.K.SDF_2D_HEART;
  }
  initializeNode() {
    super.initializeNode();
    this.io.outputs.setNamedOutputConnectionPoints([
      new connections_Js/* JsConnectionPoint */.fp(js_SDF2DHeart_OUTPUT_NAME, connections_Js/* JsConnectionPointType.FLOAT */.zF.FLOAT)
    ]);
  }
  setLines(shadersCollectionController) {
    const position = this.variableForInputParam(shadersCollectionController, this.p.position);
    const center = this.variableForInputParam(shadersCollectionController, this.p.center);
    const float = this.jsVarName(js_SDF2DHeart_OUTPUT_NAME);
    const func = Poly/* Poly.namedFunctionsRegister.getFunction */.L.namedFunctionsRegister.getFunction("SDF2DHeart", this, shadersCollectionController);
    shadersCollectionController.addBodyOrComputed(this, [
      {
        dataType: connections_Js/* JsConnectionPointType.FLOAT */.zF.FLOAT,
        varName: float,
        value: func.asString(position, center)
      }
    ]);
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/js/SDF2DRoundedX.ts






const js_SDF2DRoundedX_OUTPUT_NAME = "float";
class SDF2DRoundedXJsParamsConfig extends params_ParamsConfig/* NodeParamsConfig */.yI {
  constructor() {
    super(...arguments);
    this.position = params_ParamsConfig/* ParamConfig.VECTOR2 */.XC.VECTOR2([0, 0], { hidden: true });
    this.center = params_ParamsConfig/* ParamConfig.VECTOR2 */.XC.VECTOR2([0, 0]);
    this.length = params_ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(1);
    this.radius = params_ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(0.1);
  }
}
const js_SDF2DRoundedX_ParamsConfig = new SDF2DRoundedXJsParamsConfig();
class SDF2DRoundedXJsNode extends BaseSDF2DJsNode {
  constructor() {
    super(...arguments);
    this.paramsConfig = js_SDF2DRoundedX_ParamsConfig;
  }
  static type() {
    return Js/* JsType.SDF_2D_ROUNDED_X */.K.SDF_2D_ROUNDED_X;
  }
  initializeNode() {
    super.initializeNode();
    this.io.outputs.setNamedOutputConnectionPoints([
      new connections_Js/* JsConnectionPoint */.fp(js_SDF2DRoundedX_OUTPUT_NAME, connections_Js/* JsConnectionPointType.FLOAT */.zF.FLOAT)
    ]);
  }
  setLines(shadersCollectionController) {
    const position = this.variableForInputParam(shadersCollectionController, this.p.position);
    const center = this.variableForInputParam(shadersCollectionController, this.p.center);
    const length = this.variableForInputParam(shadersCollectionController, this.p.length);
    const radius = this.variableForInputParam(shadersCollectionController, this.p.radius);
    const float = this.jsVarName(js_SDF2DRoundedX_OUTPUT_NAME);
    const func = Poly/* Poly.namedFunctionsRegister.getFunction */.L.namedFunctionsRegister.getFunction("SDF2DRoundedX", this, shadersCollectionController);
    shadersCollectionController.addBodyOrComputed(this, [
      {
        dataType: connections_Js/* JsConnectionPointType.FLOAT */.zF.FLOAT,
        varName: float,
        value: func.asString(position, center, length, radius)
      }
    ]);
  }
}

// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/core/String.ts
var core_String = __webpack_require__(40065);
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/js/_BaseSDF.ts





const POSITION_NAME = "position";
const _BaseSDF_VARS = {
  position: POSITION_NAME
};
class BaseSDFJsParamsConfig extends (/* unused pure expression or super */ null && (NodeParamsConfig)) {
  constructor() {
    super(...arguments);
    this.position = ParamConfig.VECTOR3([0, 0, 0]);
  }
}
function defaultPosition(linesController, node) {
  const sanitizedNodePath = core_String/* CoreString.sanitizeName */.YE.sanitizeName(node.path());
  const varName = `${sanitizedNodePath}_${POSITION_NAME}`;
  linesController.addVariable(node, new three_module.Vector3(), varName);
  return `${varName}.copy(${_BaseSDF_VARS.position})`;
}
class BaseSDFJsNode extends js_Base/* TypedJsNode */.xZ {
  position(linesController) {
    const inputPosition = this.io.inputs.named_input(POSITION_NAME);
    const position = inputPosition ? this.variableForInputParam(linesController, this.p.position) : defaultPosition(linesController, this);
    return position;
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/js/SDFBox.ts






const js_SDFBox_OUTPUT_NAME = "float";
class SDFBoxJsParamsConfig extends params_ParamsConfig/* NodeParamsConfig */.yI {
  constructor() {
    super(...arguments);
    this.position = params_ParamsConfig/* ParamConfig.VECTOR3 */.XC.VECTOR3([0, 0, 0], { hidden: true });
    this.center = params_ParamsConfig/* ParamConfig.VECTOR3 */.XC.VECTOR3([0, 0, 0]);
    this.size = params_ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(1);
    this.sizes = params_ParamsConfig/* ParamConfig.VECTOR3 */.XC.VECTOR3([1, 1, 1]);
  }
}
const js_SDFBox_ParamsConfig = new SDFBoxJsParamsConfig();
class SDFBoxJsNode extends BaseSDFJsNode {
  constructor() {
    super(...arguments);
    this.paramsConfig = js_SDFBox_ParamsConfig;
  }
  static type() {
    return Js/* JsType.SDF_BOX */.K.SDF_BOX;
  }
  initializeNode() {
    super.initializeNode();
    this.io.outputs.setNamedOutputConnectionPoints([
      new connections_Js/* JsConnectionPoint */.fp(js_SDFBox_OUTPUT_NAME, connections_Js/* JsConnectionPointType.FLOAT */.zF.FLOAT)
    ]);
  }
  setLines(linesController) {
    const position = this.position(linesController);
    const center = this.variableForInputParam(linesController, this.p.center);
    const size = this.variableForInputParam(linesController, this.p.size);
    const sizes = this.variableForInputParam(linesController, this.p.sizes);
    const float = this.jsVarName(js_SDFBox_OUTPUT_NAME);
    const func = Poly/* Poly.namedFunctionsRegister.getFunction */.L.namedFunctionsRegister.getFunction("SDFBox", this, linesController);
    linesController.addBodyOrComputed(this, [
      {
        dataType: connections_Js/* JsConnectionPointType.FLOAT */.zF.FLOAT,
        varName: float,
        value: func.asString(position, center, sizes, size)
      }
    ]);
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/js/SDFElongate.ts







const js_SDFElongate_OUTPUT_NAME = "p";
class SDFElongateJsParamsConfig extends params_ParamsConfig/* NodeParamsConfig */.yI {
  constructor() {
    super(...arguments);
    this.position = params_ParamsConfig/* ParamConfig.VECTOR3 */.XC.VECTOR3([0, 0, 0], { hidden: true });
    this.center = params_ParamsConfig/* ParamConfig.VECTOR3 */.XC.VECTOR3([0, 0, 0]);
    this.mult = params_ParamsConfig/* ParamConfig.VECTOR3 */.XC.VECTOR3([0, 0, 0]);
    this.fast = params_ParamsConfig/* ParamConfig.BOOLEAN */.XC.BOOLEAN(1);
  }
}
const js_SDFElongate_ParamsConfig = new SDFElongateJsParamsConfig();
class SDFElongateJsNode extends BaseSDFJsNode {
  constructor() {
    super(...arguments);
    this.paramsConfig = js_SDFElongate_ParamsConfig;
  }
  static type() {
    return "SDFElongate";
  }
  initializeNode() {
    super.initializeNode();
    this.io.connection_points.spare_params.setInputlessParamNames(["fast"]);
    this.io.outputs.setNamedOutputConnectionPoints([
      new connections_Js/* JsConnectionPoint */.fp(js_SDFElongate_OUTPUT_NAME, connections_Js/* JsConnectionPointType.VECTOR3 */.zF.VECTOR3)
    ]);
  }
  setLines(linesController) {
    const functionName = (0,Type/* isBooleanTrue */.bI)(this.pv.fast) ? "SDFElongateFast" : "SDFElongateSlow";
    const position = this.position(linesController);
    const center = this.variableForInputParam(linesController, this.p.center);
    const mult = this.variableForInputParam(linesController, this.p.mult);
    const out = this.jsVarName(js_SDFElongate_OUTPUT_NAME);
    const tmpVarName = linesController.addVariable(this, new three_module.Vector3());
    const func = Poly/* Poly.namedFunctionsRegister.getFunction */.L.namedFunctionsRegister.getFunction(functionName, this, linesController);
    linesController.addBodyOrComputed(this, [
      {
        dataType: connections_Js/* JsConnectionPointType.VECTOR3 */.zF.VECTOR3,
        varName: out,
        value: func.asString(position, center, mult, tmpVarName)
      }
    ]);
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/js/SDFIntersect.ts






const js_SDFIntersect_OUTPUT_NAME = "intersect";
class SDFIntersectJsParamsConfig extends params_ParamsConfig/* NodeParamsConfig */.yI {
  constructor() {
    super(...arguments);
    this.sdf0 = params_ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(1);
    this.sdf1 = params_ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(1);
    this.smooth = params_ParamsConfig/* ParamConfig.BOOLEAN */.XC.BOOLEAN(1);
    this.smoothFactor = params_ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(1, {
      visibleIf: { smooth: 1 }
    });
  }
}
const js_SDFIntersect_ParamsConfig = new SDFIntersectJsParamsConfig();
class SDFIntersectJsNode extends js_Base/* TypedJsNode */.xZ {
  constructor() {
    super(...arguments);
    this.paramsConfig = js_SDFIntersect_ParamsConfig;
  }
  static type() {
    return "SDFIntersect";
  }
  initializeNode() {
    super.initializeNode();
    this.io.outputs.setNamedOutputConnectionPoints([
      new connections_Js/* JsConnectionPoint */.fp(js_SDFIntersect_OUTPUT_NAME, connections_Js/* JsConnectionPointType.FLOAT */.zF.FLOAT)
    ]);
  }
  setLines(shadersCollectionController) {
    const sdf0 = this.variableForInputParam(shadersCollectionController, this.p.sdf0);
    const sdf1 = this.variableForInputParam(shadersCollectionController, this.p.sdf1);
    const smoothFactor = this.variableForInputParam(shadersCollectionController, this.p.smoothFactor);
    const functionName = (0,Type/* isBooleanTrue */.bI)(this.pv.smooth) ? "SDFSmoothIntersect" : "SDFIntersect";
    const func = Poly/* Poly.namedFunctionsRegister.getFunction */.L.namedFunctionsRegister.getFunction(functionName, this, shadersCollectionController);
    const float = this.jsVarName(js_SDFIntersect_OUTPUT_NAME);
    shadersCollectionController.addBodyOrComputed(this, [
      {
        dataType: connections_Js/* JsConnectionPointType.FLOAT */.zF.FLOAT,
        varName: float,
        value: func.asString(sdf0, sdf1, smoothFactor)
      }
    ]);
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/js/SDFOnion.ts






const js_SDFOnion_OUTPUT_NAME = "onion";
class SDFOnionJsParamsConfig extends params_ParamsConfig/* NodeParamsConfig */.yI {
  constructor() {
    super(...arguments);
    this.sdf = params_ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(0);
    this.thickness = params_ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(0.1);
  }
}
const js_SDFOnion_ParamsConfig = new SDFOnionJsParamsConfig();
class SDFOnionJsNode extends js_Base/* TypedJsNode */.xZ {
  constructor() {
    super(...arguments);
    this.paramsConfig = js_SDFOnion_ParamsConfig;
  }
  static type() {
    return Js/* JsType.SDF_ONION */.K.SDF_ONION;
  }
  initializeNode() {
    super.initializeNode();
    this.io.outputs.setNamedOutputConnectionPoints([
      new connections_Js/* JsConnectionPoint */.fp(js_SDFOnion_OUTPUT_NAME, connections_Js/* JsConnectionPointType.FLOAT */.zF.FLOAT)
    ]);
  }
  setLines(linesController) {
    const sdf = this.variableForInputParam(linesController, this.p.sdf);
    const thickness = this.variableForInputParam(linesController, this.p.thickness);
    const out = this.jsVarName(js_SDFOnion_OUTPUT_NAME);
    const func = Poly/* Poly.namedFunctionsRegister.getFunction */.L.namedFunctionsRegister.getFunction("SDFOnion", this, linesController);
    linesController.addBodyOrComputed(this, [
      {
        dataType: connections_Js/* JsConnectionPointType.FLOAT */.zF.FLOAT,
        varName: out,
        value: func.asString(sdf, thickness)
      }
    ]);
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/js/SDFPlane.ts






const js_SDFPlane_OUTPUT_NAME = "float";
class SDFPlaneJsParamsConfig extends params_ParamsConfig/* NodeParamsConfig */.yI {
  constructor() {
    super(...arguments);
    this.position = params_ParamsConfig/* ParamConfig.VECTOR3 */.XC.VECTOR3([0, 0, 0], { hidden: true });
    this.center = params_ParamsConfig/* ParamConfig.VECTOR3 */.XC.VECTOR3([0, 0, 0]);
    this.normal = params_ParamsConfig/* ParamConfig.VECTOR3 */.XC.VECTOR3([0, 1, 0]);
    this.offset = params_ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(0, {
      range: [-1, 1],
      rangeLocked: [false, false]
    });
  }
}
const js_SDFPlane_ParamsConfig = new SDFPlaneJsParamsConfig();
class SDFPlaneJsNode extends BaseSDFJsNode {
  constructor() {
    super(...arguments);
    this.paramsConfig = js_SDFPlane_ParamsConfig;
  }
  static type() {
    return Js/* JsType.SDF_PLANE */.K.SDF_PLANE;
  }
  initializeNode() {
    super.initializeNode();
    this.io.outputs.setNamedOutputConnectionPoints([
      new connections_Js/* JsConnectionPoint */.fp(js_SDFPlane_OUTPUT_NAME, connections_Js/* JsConnectionPointType.FLOAT */.zF.FLOAT)
    ]);
  }
  setLines(shadersCollectionController) {
    const position = this.position(shadersCollectionController);
    const center = this.variableForInputParam(shadersCollectionController, this.p.center);
    const normal = this.variableForInputParam(shadersCollectionController, this.p.normal);
    const offset = this.variableForInputParam(shadersCollectionController, this.p.offset);
    const out = this.jsVarName(js_SDFPlane_OUTPUT_NAME);
    const func = Poly/* Poly.namedFunctionsRegister.getFunction */.L.namedFunctionsRegister.getFunction("SDFPlane", this, shadersCollectionController);
    shadersCollectionController.addBodyOrComputed(this, [
      {
        dataType: connections_Js/* JsConnectionPointType.FLOAT */.zF.FLOAT,
        varName: out,
        value: func.asString(position, center, normal, offset)
      }
    ]);
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/js/SDFRevolution.ts








var SDFRevolutionJsAxis = /* @__PURE__ */ ((SDFRevolutionJsAxis2) => {
  SDFRevolutionJsAxis2["X"] = "X";
  SDFRevolutionJsAxis2["Y"] = "Y";
  SDFRevolutionJsAxis2["Z"] = "Z";
  return SDFRevolutionJsAxis2;
})(SDFRevolutionJsAxis || {});
const SDFRevolution_SDF_REVOLUTION_AXISES = [
  "X" /* X */,
  "Y" /* Y */,
  "Z" /* Z */
];
const js_SDFRevolution_OUTPUT_NAME = "p";
class SDFRevolutionJsParamsConfig extends params_ParamsConfig/* NodeParamsConfig */.yI {
  constructor() {
    super(...arguments);
    this.position = params_ParamsConfig/* ParamConfig.VECTOR3 */.XC.VECTOR3([0, 0, 0], { hidden: true });
    this.center = params_ParamsConfig/* ParamConfig.VECTOR3 */.XC.VECTOR3([0, 0, 0]);
    this.radius = params_ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(1);
    this.axis = params_ParamsConfig/* ParamConfig.INTEGER */.XC.INTEGER(SDFRevolution_SDF_REVOLUTION_AXISES.indexOf("Y" /* Y */), {
      menu: {
        entries: SDFRevolution_SDF_REVOLUTION_AXISES.map((name, value) => ({ name, value }))
      }
    });
  }
}
const js_SDFRevolution_ParamsConfig = new SDFRevolutionJsParamsConfig();
class SDFRevolutionJsNode extends BaseSDFJsNode {
  constructor() {
    super(...arguments);
    this.paramsConfig = js_SDFRevolution_ParamsConfig;
  }
  static type() {
    return Js/* JsType.SDF_REVOLUTION */.K.SDF_REVOLUTION;
  }
  initializeNode() {
    super.initializeNode();
    this.io.outputs.setNamedOutputConnectionPoints([
      new connections_Js/* JsConnectionPoint */.fp(js_SDFRevolution_OUTPUT_NAME, connections_Js/* JsConnectionPointType.VECTOR2 */.zF.VECTOR2)
    ]);
  }
  setAxis(axis) {
    this.p.axis.set(SDFRevolution_SDF_REVOLUTION_AXISES.indexOf(axis));
  }
  setLines(linesController) {
    const position = this.position(linesController);
    const center = this.variableForInputParam(linesController, this.p.center);
    const radius = this.variableForInputParam(linesController, this.p.radius);
    const out = this.jsVarName(js_SDFRevolution_OUTPUT_NAME);
    const tmpVarName = linesController.addVariable(this, new three_module.Vector2());
    const func = Poly/* Poly.namedFunctionsRegister.getFunction */.L.namedFunctionsRegister.getFunction(this._functionName(), this, linesController);
    linesController.addBodyOrComputed(this, [
      {
        dataType: connections_Js/* JsConnectionPointType.VECTOR2 */.zF.VECTOR2,
        varName: out,
        value: func.asString(position, center, radius, tmpVarName)
      }
    ]);
  }
  _functionName() {
    const axis = SDFRevolution_SDF_REVOLUTION_AXISES[this.pv.axis];
    switch (axis) {
      case "X" /* X */: {
        return "SDFRevolutionX";
      }
      case "Y" /* Y */: {
        return "SDFRevolutionY";
      }
      case "Z" /* Z */: {
        return "SDFRevolutionZ";
      }
    }
    Assert/* TypeAssert.unreachable */.f.unreachable(axis);
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/js/SDFSphere.ts






const js_SDFSphere_OUTPUT_NAME = "float";
class SDFSphereJsParamsConfig extends params_ParamsConfig/* NodeParamsConfig */.yI {
  constructor() {
    super(...arguments);
    this.position = params_ParamsConfig/* ParamConfig.VECTOR3 */.XC.VECTOR3([0, 0, 0], { hidden: true });
    this.center = params_ParamsConfig/* ParamConfig.VECTOR3 */.XC.VECTOR3([0, 0, 0]);
    this.radius = params_ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(1);
  }
}
const js_SDFSphere_ParamsConfig = new SDFSphereJsParamsConfig();
class SDFSphereJsNode extends BaseSDFJsNode {
  constructor() {
    super(...arguments);
    this.paramsConfig = js_SDFSphere_ParamsConfig;
  }
  static type() {
    return Js/* JsType.SDF_SPHERE */.K.SDF_SPHERE;
  }
  initializeNode() {
    super.initializeNode();
    this.io.outputs.setNamedOutputConnectionPoints([
      new connections_Js/* JsConnectionPoint */.fp(js_SDFSphere_OUTPUT_NAME, connections_Js/* JsConnectionPointType.FLOAT */.zF.FLOAT)
    ]);
  }
  setLines(shadersCollectionController) {
    const position = this.position(shadersCollectionController);
    const center = this.variableForInputParam(shadersCollectionController, this.p.center);
    const radius = this.variableForInputParam(shadersCollectionController, this.p.radius);
    const out = this.jsVarName(js_SDFSphere_OUTPUT_NAME);
    const func = Poly/* Poly.namedFunctionsRegister.getFunction */.L.namedFunctionsRegister.getFunction("SDFSphere", this, shadersCollectionController);
    shadersCollectionController.addBodyOrComputed(this, [
      {
        dataType: connections_Js/* JsConnectionPointType.FLOAT */.zF.FLOAT,
        varName: out,
        value: func.asString(position, center, radius)
      }
    ]);
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/js/SDFSubtract.ts






const js_SDFSubtract_OUTPUT_NAME = "subtract";
class SDFSubtractJsParamsConfig extends params_ParamsConfig/* NodeParamsConfig */.yI {
  constructor() {
    super(...arguments);
    this.sdf0 = params_ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(1);
    this.sdf1 = params_ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(1);
    this.smooth = params_ParamsConfig/* ParamConfig.BOOLEAN */.XC.BOOLEAN(1);
    this.smoothFactor = params_ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(1, {
      visibleIf: { smooth: 1 }
    });
  }
}
const js_SDFSubtract_ParamsConfig = new SDFSubtractJsParamsConfig();
class SDFSubtractJsNode extends js_Base/* TypedJsNode */.xZ {
  constructor() {
    super(...arguments);
    this.paramsConfig = js_SDFSubtract_ParamsConfig;
  }
  static type() {
    return "SDFSubtract";
  }
  initializeNode() {
    super.initializeNode();
    this.io.outputs.setNamedOutputConnectionPoints([
      new connections_Js/* JsConnectionPoint */.fp(js_SDFSubtract_OUTPUT_NAME, connections_Js/* JsConnectionPointType.FLOAT */.zF.FLOAT)
    ]);
  }
  setLines(shadersCollectionController) {
    const sdf0 = this.variableForInputParam(shadersCollectionController, this.p.sdf0);
    const sdf1 = this.variableForInputParam(shadersCollectionController, this.p.sdf1);
    const smoothFactor = this.variableForInputParam(shadersCollectionController, this.p.smoothFactor);
    const functionName = (0,Type/* isBooleanTrue */.bI)(this.pv.smooth) ? "SDFSmoothSubtract" : "SDFSubtract";
    const func = Poly/* Poly.namedFunctionsRegister.getFunction */.L.namedFunctionsRegister.getFunction(functionName, this, shadersCollectionController);
    const float = this.jsVarName(js_SDFSubtract_OUTPUT_NAME);
    shadersCollectionController.addBodyOrComputed(this, [
      {
        dataType: connections_Js/* JsConnectionPointType.FLOAT */.zF.FLOAT,
        varName: float,
        value: func.asString(sdf0, sdf1, smoothFactor)
      }
    ]);
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/js/SDFTorus.ts






const js_SDFTorus_OUTPUT_NAME = "float";
class SDFTorusJsParamsConfig extends params_ParamsConfig/* NodeParamsConfig */.yI {
  constructor() {
    super(...arguments);
    this.position = params_ParamsConfig/* ParamConfig.VECTOR3 */.XC.VECTOR3([0, 0, 0], { hidden: true });
    this.center = params_ParamsConfig/* ParamConfig.VECTOR3 */.XC.VECTOR3([0, 0, 0]);
    this.radius1 = params_ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(1);
    this.radius2 = params_ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(0.5);
  }
}
const js_SDFTorus_ParamsConfig = new SDFTorusJsParamsConfig();
class SDFTorusJsNode extends BaseSDFJsNode {
  constructor() {
    super(...arguments);
    this.paramsConfig = js_SDFTorus_ParamsConfig;
  }
  static type() {
    return Js/* JsType.SDF_TORUS */.K.SDF_TORUS;
  }
  initializeNode() {
    super.initializeNode();
    this.io.outputs.setNamedOutputConnectionPoints([
      new connections_Js/* JsConnectionPoint */.fp(js_SDFTorus_OUTPUT_NAME, connections_Js/* JsConnectionPointType.FLOAT */.zF.FLOAT)
    ]);
  }
  setLines(shadersCollectionController) {
    const position = this.position(shadersCollectionController);
    const center = this.variableForInputParam(shadersCollectionController, this.p.center);
    const radius1 = this.variableForInputParam(shadersCollectionController, this.p.radius1);
    const radius2 = this.variableForInputParam(shadersCollectionController, this.p.radius2);
    const out = this.jsVarName(js_SDFTorus_OUTPUT_NAME);
    const func = Poly/* Poly.namedFunctionsRegister.getFunction */.L.namedFunctionsRegister.getFunction("SDFTorus", this, shadersCollectionController);
    shadersCollectionController.addBodyOrComputed(this, [
      {
        dataType: connections_Js/* JsConnectionPointType.FLOAT */.zF.FLOAT,
        varName: out,
        value: func.asString(position, center, radius1, radius2)
      }
    ]);
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/js/SDFTransform.ts







const js_SDFTransform_OUTPUT_NAME = "p";
class SDFTransformJsParamsConfig extends params_ParamsConfig/* NodeParamsConfig */.yI {
  constructor() {
    super(...arguments);
    this.position = params_ParamsConfig/* ParamConfig.VECTOR3 */.XC.VECTOR3([0, 0, 0], { hidden: true });
    this.t = params_ParamsConfig/* ParamConfig.VECTOR3 */.XC.VECTOR3([0, 0, 0]);
    this.r = params_ParamsConfig/* ParamConfig.VECTOR3 */.XC.VECTOR3([0, 0, 0]);
  }
}
const js_SDFTransform_ParamsConfig = new SDFTransformJsParamsConfig();
class SDFTransformJsNode extends BaseSDFJsNode {
  constructor() {
    super(...arguments);
    this.paramsConfig = js_SDFTransform_ParamsConfig;
  }
  static type() {
    return Js/* JsType.SDF_TRANSFORM */.K.SDF_TRANSFORM;
  }
  initializeNode() {
    super.initializeNode();
    this.io.outputs.setNamedOutputConnectionPoints([
      new connections_Js/* JsConnectionPoint */.fp(js_SDFTransform_OUTPUT_NAME, connections_Js/* JsConnectionPointType.VECTOR3 */.zF.VECTOR3)
    ]);
  }
  setLines(linesController) {
    const position = this.position(linesController);
    const t = this.variableForInputParam(linesController, this.p.t);
    const r = this.variableForInputParam(linesController, this.p.r);
    const out = this.jsVarName(js_SDFTransform_OUTPUT_NAME);
    const tmpVarName = linesController.addVariable(this, new three_module.Vector3());
    const func = Poly/* Poly.namedFunctionsRegister.getFunction */.L.namedFunctionsRegister.getFunction("SDFTransform", this, linesController);
    linesController.addBodyOrComputed(this, [
      {
        dataType: connections_Js/* JsConnectionPointType.FLOAT */.zF.FLOAT,
        varName: out,
        value: func.asString(position, t, r, tmpVarName)
      }
    ]);
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/js/SDFTube.ts






const js_SDFTube_OUTPUT_NAME = "float";
class SDFTubeJsParamsConfig extends params_ParamsConfig/* NodeParamsConfig */.yI {
  constructor() {
    super(...arguments);
    this.position = params_ParamsConfig/* ParamConfig.VECTOR3 */.XC.VECTOR3([0, 0, 0], { hidden: true });
    this.center = params_ParamsConfig/* ParamConfig.VECTOR3 */.XC.VECTOR3([0, 0, 0]);
    this.radius = params_ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(0.5);
  }
}
const js_SDFTube_ParamsConfig = new SDFTubeJsParamsConfig();
class SDFTubeJsNode extends BaseSDFJsNode {
  constructor() {
    super(...arguments);
    this.paramsConfig = js_SDFTube_ParamsConfig;
  }
  static type() {
    return Js/* JsType.SDF_TUBE */.K.SDF_TUBE;
  }
  initializeNode() {
    super.initializeNode();
    this.io.outputs.setNamedOutputConnectionPoints([
      new connections_Js/* JsConnectionPoint */.fp(js_SDFTube_OUTPUT_NAME, connections_Js/* JsConnectionPointType.FLOAT */.zF.FLOAT)
    ]);
  }
  setLines(shadersCollectionController) {
    const position = this.position(shadersCollectionController);
    const center = this.variableForInputParam(shadersCollectionController, this.p.center);
    const radius = this.variableForInputParam(shadersCollectionController, this.p.radius);
    const out = this.jsVarName(js_SDFTube_OUTPUT_NAME);
    const func = Poly/* Poly.namedFunctionsRegister.getFunction */.L.namedFunctionsRegister.getFunction("SDFTube", this, shadersCollectionController);
    shadersCollectionController.addBodyOrComputed(this, [
      {
        dataType: connections_Js/* JsConnectionPointType.FLOAT */.zF.FLOAT,
        varName: out,
        value: func.asString(position, center, radius)
      }
    ]);
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/js/SDFUnion.ts






const js_SDFUnion_OUTPUT_NAME = "union";
class SDFUnionJsParamsConfig extends params_ParamsConfig/* NodeParamsConfig */.yI {
  constructor() {
    super(...arguments);
    this.sdf0 = params_ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(1);
    this.sdf1 = params_ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(1);
    this.smooth = params_ParamsConfig/* ParamConfig.BOOLEAN */.XC.BOOLEAN(1);
    this.smoothFactor = params_ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(1, {
      visibleIf: { smooth: 1 }
    });
  }
}
const js_SDFUnion_ParamsConfig = new SDFUnionJsParamsConfig();
class SDFUnionJsNode extends js_Base/* TypedJsNode */.xZ {
  constructor() {
    super(...arguments);
    this.paramsConfig = js_SDFUnion_ParamsConfig;
  }
  static type() {
    return "SDFUnion";
  }
  initializeNode() {
    super.initializeNode();
    this.io.outputs.setNamedOutputConnectionPoints([
      new connections_Js/* JsConnectionPoint */.fp(js_SDFUnion_OUTPUT_NAME, connections_Js/* JsConnectionPointType.FLOAT */.zF.FLOAT)
    ]);
  }
  setLines(shadersCollectionController) {
    const sdf0 = this.variableForInputParam(shadersCollectionController, this.p.sdf0);
    const sdf1 = this.variableForInputParam(shadersCollectionController, this.p.sdf1);
    const smoothFactor = this.variableForInputParam(shadersCollectionController, this.p.smoothFactor);
    const functionName = (0,Type/* isBooleanTrue */.bI)(this.pv.smooth) ? "SDFSmoothUnion" : "SDFUnion";
    const func = Poly/* Poly.namedFunctionsRegister.getFunction */.L.namedFunctionsRegister.getFunction(functionName, this, shadersCollectionController);
    const out = this.jsVarName(js_SDFUnion_OUTPUT_NAME);
    shadersCollectionController.addBodyOrComputed(this, [
      {
        dataType: connections_Js/* JsConnectionPointType.FLOAT */.zF.FLOAT,
        varName: out,
        value: func.asString(sdf0, sdf1, smoothFactor)
      }
    ]);
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/js/SetCameraViewOffset.ts






const SetCameraViewOffset_CONNECTION_OPTIONS = connections_Js/* JS_CONNECTION_POINT_IN_NODE_DEF */.mX;
class SetCameraViewOffsetJsParamsConfig extends params_ParamsConfig/* NodeParamsConfig */.yI {
  constructor() {
    super(...arguments);
    /** @param min */
    this.min = params_ParamsConfig/* ParamConfig.VECTOR2 */.XC.VECTOR2([0, 0]);
    /** @param max */
    this.max = params_ParamsConfig/* ParamConfig.VECTOR2 */.XC.VECTOR2([1, 1]);
  }
}
const SetCameraViewOffset_ParamsConfig = new SetCameraViewOffsetJsParamsConfig();
class SetCameraViewOffsetJsNode extends js_Base/* TypedJsNode */.xZ {
  constructor() {
    super(...arguments);
    this.paramsConfig = SetCameraViewOffset_ParamsConfig;
  }
  static type() {
    return "SetCameraViewOffset";
  }
  initializeNode() {
    this.io.inputs.setNamedInputConnectionPoints([
      new connections_Js/* JsConnectionPoint */.fp(js_Base/* TRIGGER_CONNECTION_NAME */.w6, connections_Js/* JsConnectionPointType.TRIGGER */.zF.TRIGGER, SetCameraViewOffset_CONNECTION_OPTIONS),
      new connections_Js/* JsConnectionPoint */.fp(connections_Js/* JsConnectionPointType.OBJECT_3D */.zF.OBJECT_3D, connections_Js/* JsConnectionPointType.OBJECT_3D */.zF.OBJECT_3D, SetCameraViewOffset_CONNECTION_OPTIONS)
    ]);
    this.io.outputs.setNamedOutputConnectionPoints([
      new connections_Js/* JsConnectionPoint */.fp(js_Base/* TRIGGER_CONNECTION_NAME */.w6, connections_Js/* JsConnectionPointType.TRIGGER */.zF.TRIGGER),
      new connections_Js/* JsConnectionPoint */.fp(connections_Js/* JsConnectionPointType.OBJECT_3D */.zF.OBJECT_3D, connections_Js/* JsConnectionPointType.OBJECT_3D */.zF.OBJECT_3D, SetCameraViewOffset_CONNECTION_OPTIONS)
    ]);
  }
  setLines(linesController) {
    (0,_BaseObject3D/* setObject3DOutputLine */.PV)(this, linesController);
  }
  setTriggerableLines(shadersCollectionController) {
    const object3D = (0,_BaseObject3D/* inputObject3D */.iv)(this, shadersCollectionController);
    const min = this.variableForInputParam(shadersCollectionController, this.p.min);
    const max = this.variableForInputParam(shadersCollectionController, this.p.max);
    const func = Poly/* Poly.namedFunctionsRegister.getFunction */.L.namedFunctionsRegister.getFunction("setCameraViewOffset", this, shadersCollectionController);
    const bodyLine = func.asString(object3D, min, max);
    shadersCollectionController.addTriggerableLines(this, [bodyLine]);
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/js/SetClothConstraintPosition.ts





class SetClothConstraintPositionJsParamsConfig extends params_ParamsConfig/* NodeParamsConfig */.yI {
  constructor() {
    super(...arguments);
    this.position = params_ParamsConfig/* ParamConfig.VECTOR3 */.XC.VECTOR3([0, 0, 0]);
    this.lerp = params_ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(1, {
      range: [0, 1],
      rangeLocked: [true, true]
    });
  }
}
const SetClothConstraintPosition_ParamsConfig = new SetClothConstraintPositionJsParamsConfig();
class SetClothConstraintPositionJsNode extends _BaseTriggerAndObject/* BaseTriggerAndObjectJsNode */.e {
  constructor() {
    super(...arguments);
    this.paramsConfig = SetClothConstraintPosition_ParamsConfig;
  }
  static type() {
    return "setClothConstraintPosition";
  }
  setTriggerableLines(shadersCollectionController) {
    const object3D = (0,_BaseObject3D/* inputObject3D */.iv)(this, shadersCollectionController);
    const position = this.variableForInputParam(shadersCollectionController, this.p.position);
    const lerp = this.variableForInputParam(shadersCollectionController, this.p.lerp);
    const func = Poly/* Poly.namedFunctionsRegister.getFunction */.L.namedFunctionsRegister.getFunction(
      "clothConstraintSetPosition",
      this,
      shadersCollectionController
    );
    const bodyLine = func.asString(object3D, position, lerp);
    shadersCollectionController.addTriggerableLines(this, [bodyLine]);
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/js/SetCSSObjectClass.ts






const SetCSSObjectClass_CONNECTION_OPTIONS = connections_Js/* JS_CONNECTION_POINT_IN_NODE_DEF */.mX;
class SetCSSObjectClassJsParamsConfig extends params_ParamsConfig/* NodeParamsConfig */.yI {
  constructor() {
    super(...arguments);
    /** @param class */
    this.class = params_ParamsConfig/* ParamConfig.STRING */.XC.STRING("active");
    /** @param set to true to add the class, or false to remove */
    this.addRemove = params_ParamsConfig/* ParamConfig.BOOLEAN */.XC.BOOLEAN(1);
  }
}
const SetCSSObjectClass_ParamsConfig = new SetCSSObjectClassJsParamsConfig();
class SetCSSObjectClassJsNode extends js_Base/* TypedJsNode */.xZ {
  constructor() {
    super(...arguments);
    this.paramsConfig = SetCSSObjectClass_ParamsConfig;
  }
  static type() {
    return "setCSSObjectClass";
  }
  initializeNode() {
    this.io.inputs.setNamedInputConnectionPoints([
      new connections_Js/* JsConnectionPoint */.fp(js_Base/* TRIGGER_CONNECTION_NAME */.w6, connections_Js/* JsConnectionPointType.TRIGGER */.zF.TRIGGER, SetCSSObjectClass_CONNECTION_OPTIONS),
      new connections_Js/* JsConnectionPoint */.fp(connections_Js/* JsConnectionPointType.OBJECT_3D */.zF.OBJECT_3D, connections_Js/* JsConnectionPointType.OBJECT_3D */.zF.OBJECT_3D, SetCSSObjectClass_CONNECTION_OPTIONS)
    ]);
    this.io.outputs.setNamedOutputConnectionPoints([
      new connections_Js/* JsConnectionPoint */.fp(js_Base/* TRIGGER_CONNECTION_NAME */.w6, connections_Js/* JsConnectionPointType.TRIGGER */.zF.TRIGGER),
      new connections_Js/* JsConnectionPoint */.fp(connections_Js/* JsConnectionPointType.OBJECT_3D */.zF.OBJECT_3D, connections_Js/* JsConnectionPointType.OBJECT_3D */.zF.OBJECT_3D)
    ]);
  }
  setLines(linesController) {
    (0,_BaseObject3D/* setObject3DOutputLine */.PV)(this, linesController);
  }
  setTriggerableLines(linesController) {
    const object3D = (0,_BaseObject3D/* inputObject3D */.iv)(this, linesController);
    const className = this.variableForInputParam(linesController, this.p.class);
    const addRemove = this.variableForInputParam(linesController, this.p.addRemove);
    const func = Poly/* Poly.namedFunctionsRegister.getFunction */.L.namedFunctionsRegister.getFunction("setCSSObjectClass", this, linesController);
    const bodyLine = func.asString(object3D, className, addRemove);
    linesController.addTriggerableLines(this, [bodyLine]);
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/js/SetGeometryInstanceAttribute.ts






const SetGeometryInstanceAttribute_CONNECTION_OPTIONS = connections_Js/* JS_CONNECTION_POINT_IN_NODE_DEF */.mX;
const SetGeometryInstanceAttributeInputName = {
  // [JsConnectionPointType.TRIGGER]: JsConnectionPointType.TRIGGER,
  // [JsConnectionPointType.OBJECT_3D]: JsConnectionPointType.OBJECT_3D,
  values: "values",
  lerp: "lerp",
  attributeNeedsUpdate: "attributeNeedsUpdate"
};
const SetGeometryInstanceAttribute_INPUT_NAMES = [
  // SetGeometryInstancePositionsInputName.trigger,
  // SetGeometryInstancePositionsInputName.Object3D,
  SetGeometryInstanceAttributeInputName.values,
  SetGeometryInstanceAttributeInputName.lerp,
  SetGeometryInstanceAttributeInputName.attributeNeedsUpdate
];
const SetGeometryInstanceAttribute_DefaultValues = {
  [SetGeometryInstanceAttributeInputName.lerp]: 1,
  [SetGeometryInstanceAttributeInputName.attributeNeedsUpdate]: true
};
const SetGeometryInstanceAttribute_ALLOWED_TYPES = [
  connections_Js/* JsConnectionPointType.FLOAT_ARRAY */.zF.FLOAT_ARRAY,
  connections_Js/* JsConnectionPointType.COLOR_ARRAY */.zF.COLOR_ARRAY,
  connections_Js/* JsConnectionPointType.QUATERNION_ARRAY */.zF.QUATERNION_ARRAY,
  connections_Js/* JsConnectionPointType.VECTOR2_ARRAY */.zF.VECTOR2_ARRAY,
  connections_Js/* JsConnectionPointType.VECTOR3_ARRAY */.zF.VECTOR3_ARRAY,
  connections_Js/* JsConnectionPointType.VECTOR4_ARRAY */.zF.VECTOR4_ARRAY
];
class SetGeometryInstanceAttributeJsParamsConfig extends params_ParamsConfig/* NodeParamsConfig */.yI {
  constructor() {
    super(...arguments);
    /** @param attribute name */
    this.attribName = params_ParamsConfig/* ParamConfig.STRING */.XC.STRING("");
  }
}
const SetGeometryInstanceAttribute_ParamsConfig = new SetGeometryInstanceAttributeJsParamsConfig();
class SetGeometryInstanceAttributeJsNode extends js_Base/* TypedJsNode */.xZ {
  constructor() {
    super(...arguments);
    this.paramsConfig = SetGeometryInstanceAttribute_ParamsConfig;
  }
  static type() {
    return "setGeometryInstanceAttribute";
  }
  initializeNode() {
    super.initializeNode();
    this.io.connection_points.spare_params.setInputlessParamNames(["attribName", "size"]);
    this.io.inputs.setNamedInputConnectionPoints([
      new connections_Js/* JsConnectionPoint */.fp(connections_Js/* JsConnectionPointType.TRIGGER */.zF.TRIGGER, connections_Js/* JsConnectionPointType.TRIGGER */.zF.TRIGGER, SetGeometryInstanceAttribute_CONNECTION_OPTIONS),
      new connections_Js/* JsConnectionPoint */.fp(connections_Js/* JsConnectionPointType.OBJECT_3D */.zF.OBJECT_3D, connections_Js/* JsConnectionPointType.OBJECT_3D */.zF.OBJECT_3D, SetGeometryInstanceAttribute_CONNECTION_OPTIONS)
    ]);
    this.io.connection_points.set_input_name_function((i) => this._expectedInputName(i));
    this.io.connection_points.set_expected_input_types_function(() => this._expectedInputTypes());
    this.io.connection_points.set_output_name_function(
      (i) => [connections_Js/* JsConnectionPointType.TRIGGER */.zF.TRIGGER, connections_Js/* JsConnectionPointType.OBJECT_3D */.zF.OBJECT_3D][i]
    );
    this.io.connection_points.set_expected_output_types_function(() => [
      connections_Js/* JsConnectionPointType.TRIGGER */.zF.TRIGGER,
      connections_Js/* JsConnectionPointType.OBJECT_3D */.zF.OBJECT_3D
    ]);
  }
  _expectedInputTypes() {
    const firstInputType = this.io.connection_points.first_input_connection_type();
    const type = firstInputType && SetGeometryInstanceAttribute_ALLOWED_TYPES.includes(firstInputType) ? firstInputType : connections_Js/* JsConnectionPointType.FLOAT_ARRAY */.zF.FLOAT_ARRAY;
    return [type, connections_Js/* JsConnectionPointType.FLOAT */.zF.FLOAT, connections_Js/* JsConnectionPointType.BOOLEAN */.zF.BOOLEAN];
  }
  paramDefaultValue(name) {
    return SetGeometryInstanceAttribute_DefaultValues[name];
  }
  // expectedInputTypes() {
  // 	return [
  // 		JsConnectionPointType.TRIGGER,
  // 		JsConnectionPointType.OBJECT_3D,
  // 		JsConnectionPointType.VECTOR3_ARRAY,
  // 		JsConnectionPointType.FLOAT,
  // 		JsConnectionPointType.BOOLEAN,
  // 	];
  // }
  // protected _expectedOutputTypes() {
  // 	return [JsConnectionPointType.TRIGGER];
  // }
  setLines(linesController) {
    (0,_BaseObject3D/* setObject3DOutputLine */.PV)(this, linesController);
  }
  _expectedInputName(index) {
    return SetGeometryInstanceAttribute_INPUT_NAMES[index];
  }
  setTriggerableLines(shadersCollectionController) {
    const object3D = (0,_BaseObject3D/* inputObject3D */.iv)(this, shadersCollectionController);
    const attribName = this.pv.attribName;
    const values = this.variableForInput(shadersCollectionController, SetGeometryInstanceAttributeInputName.values);
    const lerp = this.variableForInput(shadersCollectionController, SetGeometryInstanceAttributeInputName.lerp);
    const attributeNeedsUpdate = this.variableForInput(
      shadersCollectionController,
      SetGeometryInstanceAttributeInputName.attributeNeedsUpdate
    );
    const functionName = this._functionName();
    const func = Poly/* Poly.namedFunctionsRegister.getFunction */.L.namedFunctionsRegister.getFunction(functionName, this, shadersCollectionController);
    const bodyLine = func.asString(object3D, attribName, values, lerp, attributeNeedsUpdate);
    shadersCollectionController.addTriggerableLines(this, [bodyLine]);
  }
  _functionName() {
    const type = this._expectedInputTypes()[0];
    switch (type) {
      case connections_Js/* JsConnectionPointType.FLOAT_ARRAY */.zF.FLOAT_ARRAY: {
        return "setGeometryInstanceAttributeFloat";
      }
      case connections_Js/* JsConnectionPointType.COLOR_ARRAY */.zF.COLOR_ARRAY: {
        return "setGeometryInstanceAttributeColor";
      }
      case connections_Js/* JsConnectionPointType.QUATERNION_ARRAY */.zF.QUATERNION_ARRAY: {
        return "setGeometryInstanceAttributeQuaternion";
      }
      case connections_Js/* JsConnectionPointType.VECTOR2_ARRAY */.zF.VECTOR2_ARRAY: {
        return "setGeometryInstanceAttributeVector2";
      }
      case connections_Js/* JsConnectionPointType.VECTOR3_ARRAY */.zF.VECTOR3_ARRAY: {
        return "setGeometryInstanceAttributeVector3";
      }
      case connections_Js/* JsConnectionPointType.VECTOR4_ARRAY */.zF.VECTOR4_ARRAY: {
        return "setGeometryInstanceAttributeVector4";
      }
    }
    return "setGeometryInstanceAttributeFloat";
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/js/SetGeometryInstancePositions.ts






const SetGeometryInstancePositionsInputName = {
  [connections_Js/* JsConnectionPointType.TRIGGER */.zF.TRIGGER]: connections_Js/* JsConnectionPointType.TRIGGER */.zF.TRIGGER,
  [connections_Js/* JsConnectionPointType.OBJECT_3D */.zF.OBJECT_3D]: connections_Js/* JsConnectionPointType.OBJECT_3D */.zF.OBJECT_3D,
  position: "position",
  lerp: "lerp",
  attributeNeedsUpdate: "attributeNeedsUpdate"
};
const SetGeometryInstancePositions_INPUT_NAMES = [
  SetGeometryInstancePositionsInputName.trigger,
  SetGeometryInstancePositionsInputName.Object3D,
  SetGeometryInstancePositionsInputName.position,
  SetGeometryInstancePositionsInputName.lerp,
  SetGeometryInstancePositionsInputName.attributeNeedsUpdate
];
const SetGeometryInstancePositions_DefaultValues = {
  [SetGeometryInstancePositionsInputName.lerp]: 1,
  [SetGeometryInstancePositionsInputName.attributeNeedsUpdate]: true
};
class SetGeometryInstancePositionsJsParamsConfig extends params_ParamsConfig/* NodeParamsConfig */.yI {
}
const SetGeometryInstancePositions_ParamsConfig = new SetGeometryInstancePositionsJsParamsConfig();
class SetGeometryInstancePositionsJsNode extends js_Base/* TypedJsNode */.xZ {
  constructor() {
    super(...arguments);
    this.paramsConfig = SetGeometryInstancePositions_ParamsConfig;
  }
  static type() {
    return "setGeometryInstancePositions";
  }
  initializeNode() {
    super.initializeNode();
    this.io.connection_points.set_expected_input_types_function(this.expectedInputTypes.bind(this));
    this.io.connection_points.set_expected_output_types_function(this._expectedOutputTypes.bind(this));
    this.io.connection_points.set_output_name_function(
      (i) => [connections_Js/* JsConnectionPointType.TRIGGER */.zF.TRIGGER, connections_Js/* JsConnectionPointType.OBJECT_3D */.zF.OBJECT_3D][i]
    );
    this.io.connection_points.set_input_name_function(this._expectedInputName.bind(this));
  }
  paramDefaultValue(name) {
    return SetGeometryInstancePositions_DefaultValues[name];
  }
  expectedInputTypes() {
    return [
      connections_Js/* JsConnectionPointType.TRIGGER */.zF.TRIGGER,
      connections_Js/* JsConnectionPointType.OBJECT_3D */.zF.OBJECT_3D,
      connections_Js/* JsConnectionPointType.VECTOR3_ARRAY */.zF.VECTOR3_ARRAY,
      connections_Js/* JsConnectionPointType.FLOAT */.zF.FLOAT,
      connections_Js/* JsConnectionPointType.BOOLEAN */.zF.BOOLEAN
    ];
  }
  _expectedOutputTypes() {
    return [connections_Js/* JsConnectionPointType.TRIGGER */.zF.TRIGGER, connections_Js/* JsConnectionPointType.OBJECT_3D */.zF.OBJECT_3D];
  }
  _expectedInputName(index) {
    return SetGeometryInstancePositions_INPUT_NAMES[index];
  }
  setLines(linesController) {
    (0,_BaseObject3D/* setObject3DOutputLine */.PV)(this, linesController);
  }
  setTriggerableLines(shadersCollectionController) {
    const object3D = (0,_BaseObject3D/* inputObject3D */.iv)(this, shadersCollectionController);
    const positions = this.variableForInput(
      shadersCollectionController,
      SetGeometryInstancePositionsInputName.position
    );
    const lerp = this.variableForInput(shadersCollectionController, SetGeometryInstancePositionsInputName.lerp);
    const attributeNeedsUpdate = this.variableForInput(
      shadersCollectionController,
      SetGeometryInstancePositionsInputName.attributeNeedsUpdate
    );
    const func = Poly/* Poly.namedFunctionsRegister.getFunction */.L.namedFunctionsRegister.getFunction(
      "setGeometryInstancePositions",
      this,
      shadersCollectionController
    );
    const bodyLine = func.asString(object3D, positions, lerp, attributeNeedsUpdate);
    shadersCollectionController.addTriggerableLines(this, [bodyLine]);
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/js/SetGeometryInstanceQuaternions.ts






const SetGeometryInstanceQuaternionsInputName = {
  [connections_Js/* JsConnectionPointType.TRIGGER */.zF.TRIGGER]: connections_Js/* JsConnectionPointType.TRIGGER */.zF.TRIGGER,
  [connections_Js/* JsConnectionPointType.OBJECT_3D */.zF.OBJECT_3D]: connections_Js/* JsConnectionPointType.OBJECT_3D */.zF.OBJECT_3D,
  quaternion: "quaternion",
  lerp: "lerp",
  attributeNeedsUpdate: "attributeNeedsUpdate"
};
const SetGeometryInstanceQuaternions_INPUT_NAMES = [
  SetGeometryInstanceQuaternionsInputName.trigger,
  SetGeometryInstanceQuaternionsInputName.Object3D,
  SetGeometryInstanceQuaternionsInputName.quaternion,
  SetGeometryInstanceQuaternionsInputName.lerp,
  SetGeometryInstanceQuaternionsInputName.attributeNeedsUpdate
];
const SetGeometryInstanceQuaternions_DefaultValues = {
  [SetGeometryInstanceQuaternionsInputName.lerp]: 1,
  [SetGeometryInstanceQuaternionsInputName.attributeNeedsUpdate]: true
};
class SetGeometryInstanceQuaternionsJsParamsConfig extends params_ParamsConfig/* NodeParamsConfig */.yI {
}
const SetGeometryInstanceQuaternions_ParamsConfig = new SetGeometryInstanceQuaternionsJsParamsConfig();
class SetGeometryInstanceQuaternionsJsNode extends js_Base/* TypedJsNode */.xZ {
  constructor() {
    super(...arguments);
    this.paramsConfig = SetGeometryInstanceQuaternions_ParamsConfig;
  }
  static type() {
    return "setGeometryInstanceQuaternions";
  }
  initializeNode() {
    super.initializeNode();
    this.io.connection_points.set_expected_input_types_function(this.expectedInputTypes.bind(this));
    this.io.connection_points.set_expected_output_types_function(this._expectedOutputTypes.bind(this));
    this.io.connection_points.set_output_name_function(
      (i) => [connections_Js/* JsConnectionPointType.TRIGGER */.zF.TRIGGER, connections_Js/* JsConnectionPointType.OBJECT_3D */.zF.OBJECT_3D][i]
    );
    this.io.connection_points.set_input_name_function(this._expectedInputName.bind(this));
  }
  paramDefaultValue(name) {
    return SetGeometryInstanceQuaternions_DefaultValues[name];
  }
  expectedInputTypes() {
    return [
      connections_Js/* JsConnectionPointType.TRIGGER */.zF.TRIGGER,
      connections_Js/* JsConnectionPointType.OBJECT_3D */.zF.OBJECT_3D,
      connections_Js/* JsConnectionPointType.QUATERNION_ARRAY */.zF.QUATERNION_ARRAY,
      connections_Js/* JsConnectionPointType.FLOAT */.zF.FLOAT,
      connections_Js/* JsConnectionPointType.BOOLEAN */.zF.BOOLEAN
    ];
  }
  _expectedOutputTypes() {
    return [connections_Js/* JsConnectionPointType.TRIGGER */.zF.TRIGGER, connections_Js/* JsConnectionPointType.OBJECT_3D */.zF.OBJECT_3D];
  }
  _expectedInputName(index) {
    return SetGeometryInstanceQuaternions_INPUT_NAMES[index];
  }
  setLines(linesController) {
    (0,_BaseObject3D/* setObject3DOutputLine */.PV)(this, linesController);
  }
  setTriggerableLines(shadersCollectionController) {
    const object3D = (0,_BaseObject3D/* inputObject3D */.iv)(this, shadersCollectionController);
    const quaternions = this.variableForInput(
      shadersCollectionController,
      SetGeometryInstanceQuaternionsInputName.quaternion
    );
    const lerp = this.variableForInput(shadersCollectionController, SetGeometryInstanceQuaternionsInputName.lerp);
    const attributeNeedsUpdate = this.variableForInput(
      shadersCollectionController,
      SetGeometryInstanceQuaternionsInputName.attributeNeedsUpdate
    );
    const func = Poly/* Poly.namedFunctionsRegister.getFunction */.L.namedFunctionsRegister.getFunction(
      "setGeometryInstanceQuaternions",
      this,
      shadersCollectionController
    );
    const bodyLine = func.asString(object3D, quaternions, lerp, attributeNeedsUpdate);
    shadersCollectionController.addTriggerableLines(this, [bodyLine]);
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/js/SetGeometryInstanceScales.ts






const SetGeometryInstanceScalesInputName = {
  [connections_Js/* JsConnectionPointType.TRIGGER */.zF.TRIGGER]: connections_Js/* JsConnectionPointType.TRIGGER */.zF.TRIGGER,
  [connections_Js/* JsConnectionPointType.OBJECT_3D */.zF.OBJECT_3D]: connections_Js/* JsConnectionPointType.OBJECT_3D */.zF.OBJECT_3D,
  scale: "scale",
  mult: "mult",
  lerp: "lerp",
  attributeNeedsUpdate: "attributeNeedsUpdate"
};
const SetGeometryInstanceScales_INPUT_NAMES = [
  SetGeometryInstanceScalesInputName.trigger,
  SetGeometryInstanceScalesInputName.Object3D,
  SetGeometryInstanceScalesInputName.scale,
  SetGeometryInstanceScalesInputName.mult,
  SetGeometryInstanceScalesInputName.lerp,
  SetGeometryInstanceScalesInputName.attributeNeedsUpdate
];
const SetGeometryInstanceScales_DefaultValues = {
  [SetGeometryInstanceScalesInputName.lerp]: 1,
  [SetGeometryInstanceScalesInputName.attributeNeedsUpdate]: true
};
class SetGeometryInstanceScalesJsParamsConfig extends params_ParamsConfig/* NodeParamsConfig */.yI {
}
const SetGeometryInstanceScales_ParamsConfig = new SetGeometryInstanceScalesJsParamsConfig();
class SetGeometryInstanceScalesJsNode extends js_Base/* TypedJsNode */.xZ {
  constructor() {
    super(...arguments);
    this.paramsConfig = SetGeometryInstanceScales_ParamsConfig;
  }
  static type() {
    return "setGeometryInstanceScales";
  }
  initializeNode() {
    super.initializeNode();
    this.io.connection_points.set_expected_input_types_function(this.expectedInputTypes.bind(this));
    this.io.connection_points.set_expected_output_types_function(this._expectedOutputTypes.bind(this));
    this.io.connection_points.set_output_name_function(
      (i) => [connections_Js/* JsConnectionPointType.TRIGGER */.zF.TRIGGER, connections_Js/* JsConnectionPointType.OBJECT_3D */.zF.OBJECT_3D][i]
    );
    this.io.connection_points.set_input_name_function(this._expectedInputName.bind(this));
  }
  paramDefaultValue(name) {
    return SetGeometryInstanceScales_DefaultValues[name];
  }
  expectedInputTypes() {
    return [
      connections_Js/* JsConnectionPointType.TRIGGER */.zF.TRIGGER,
      connections_Js/* JsConnectionPointType.OBJECT_3D */.zF.OBJECT_3D,
      connections_Js/* JsConnectionPointType.VECTOR3_ARRAY */.zF.VECTOR3_ARRAY,
      connections_Js/* JsConnectionPointType.FLOAT_ARRAY */.zF.FLOAT_ARRAY,
      connections_Js/* JsConnectionPointType.FLOAT */.zF.FLOAT,
      connections_Js/* JsConnectionPointType.BOOLEAN */.zF.BOOLEAN
    ];
  }
  _expectedOutputTypes() {
    return [connections_Js/* JsConnectionPointType.TRIGGER */.zF.TRIGGER, connections_Js/* JsConnectionPointType.OBJECT_3D */.zF.OBJECT_3D];
  }
  _expectedInputName(index) {
    return SetGeometryInstanceScales_INPUT_NAMES[index];
  }
  setLines(linesController) {
    (0,_BaseObject3D/* setObject3DOutputLine */.PV)(this, linesController);
  }
  setTriggerableLines(shadersCollectionController) {
    const object3D = (0,_BaseObject3D/* inputObject3D */.iv)(this, shadersCollectionController);
    const scales = this.variableForInput(shadersCollectionController, SetGeometryInstanceScalesInputName.scale);
    const mult = this.variableForInput(shadersCollectionController, SetGeometryInstanceScalesInputName.mult);
    const lerp = this.variableForInput(shadersCollectionController, SetGeometryInstanceScalesInputName.lerp);
    const attributeNeedsUpdate = this.variableForInput(
      shadersCollectionController,
      SetGeometryInstanceScalesInputName.attributeNeedsUpdate
    );
    const func = Poly/* Poly.namedFunctionsRegister.getFunction */.L.namedFunctionsRegister.getFunction(
      "setGeometryInstanceScales",
      this,
      shadersCollectionController
    );
    const bodyLine = func.asString(object3D, scales, mult, lerp, attributeNeedsUpdate);
    shadersCollectionController.addTriggerableLines(this, [bodyLine]);
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/js/SetGeometryInstanceTransforms.ts






const SetGeometryInstanceTransformsInputName = {
  [connections_Js/* JsConnectionPointType.TRIGGER */.zF.TRIGGER]: connections_Js/* JsConnectionPointType.TRIGGER */.zF.TRIGGER,
  [connections_Js/* JsConnectionPointType.OBJECT_3D */.zF.OBJECT_3D]: connections_Js/* JsConnectionPointType.OBJECT_3D */.zF.OBJECT_3D,
  position: "position",
  quaternion: "quaternion",
  scale: "scale",
  mult: "mult",
  lerp: "lerp",
  attributeNeedsUpdate: "attributeNeedsUpdate"
};
const SetGeometryInstanceTransforms_INPUT_NAMES = [
  SetGeometryInstanceTransformsInputName.trigger,
  SetGeometryInstanceTransformsInputName.Object3D,
  SetGeometryInstanceTransformsInputName.position,
  SetGeometryInstanceTransformsInputName.quaternion,
  SetGeometryInstanceTransformsInputName.scale,
  SetGeometryInstanceTransformsInputName.mult,
  SetGeometryInstanceTransformsInputName.lerp,
  SetGeometryInstanceTransformsInputName.attributeNeedsUpdate
];
const SetGeometryInstanceTransforms_DefaultValues = {
  [SetGeometryInstanceTransformsInputName.lerp]: 1,
  [SetGeometryInstanceTransformsInputName.attributeNeedsUpdate]: true
};
class SetGeometryInstanceTransformsJsParamsConfig extends params_ParamsConfig/* NodeParamsConfig */.yI {
}
const SetGeometryInstanceTransforms_ParamsConfig = new SetGeometryInstanceTransformsJsParamsConfig();
class SetGeometryInstanceTransformsJsNode extends js_Base/* TypedJsNode */.xZ {
  constructor() {
    super(...arguments);
    this.paramsConfig = SetGeometryInstanceTransforms_ParamsConfig;
  }
  static type() {
    return "setGeometryInstanceTransforms";
  }
  initializeNode() {
    super.initializeNode();
    this.io.connection_points.set_expected_input_types_function(this.expectedInputTypes.bind(this));
    this.io.connection_points.set_expected_output_types_function(this._expectedOutputTypes.bind(this));
    this.io.connection_points.set_output_name_function(
      (i) => [connections_Js/* JsConnectionPointType.TRIGGER */.zF.TRIGGER, connections_Js/* JsConnectionPointType.OBJECT_3D */.zF.OBJECT_3D][i]
    );
    this.io.connection_points.set_input_name_function(this._expectedInputName.bind(this));
  }
  paramDefaultValue(name) {
    return SetGeometryInstanceTransforms_DefaultValues[name];
  }
  expectedInputTypes() {
    return [
      connections_Js/* JsConnectionPointType.TRIGGER */.zF.TRIGGER,
      connections_Js/* JsConnectionPointType.OBJECT_3D */.zF.OBJECT_3D,
      connections_Js/* JsConnectionPointType.VECTOR3_ARRAY */.zF.VECTOR3_ARRAY,
      connections_Js/* JsConnectionPointType.QUATERNION_ARRAY */.zF.QUATERNION_ARRAY,
      connections_Js/* JsConnectionPointType.VECTOR3_ARRAY */.zF.VECTOR3_ARRAY,
      connections_Js/* JsConnectionPointType.FLOAT_ARRAY */.zF.FLOAT_ARRAY,
      connections_Js/* JsConnectionPointType.FLOAT */.zF.FLOAT,
      connections_Js/* JsConnectionPointType.BOOLEAN */.zF.BOOLEAN
    ];
  }
  _expectedOutputTypes() {
    return [connections_Js/* JsConnectionPointType.TRIGGER */.zF.TRIGGER, connections_Js/* JsConnectionPointType.OBJECT_3D */.zF.OBJECT_3D];
  }
  _expectedInputName(index) {
    return SetGeometryInstanceTransforms_INPUT_NAMES[index];
  }
  setLines(linesController) {
    (0,_BaseObject3D/* setObject3DOutputLine */.PV)(this, linesController);
  }
  setTriggerableLines(shadersCollectionController) {
    const object3D = (0,_BaseObject3D/* inputObject3D */.iv)(this, shadersCollectionController);
    const positions = this.variableForInput(
      shadersCollectionController,
      SetGeometryInstanceTransformsInputName.position
    );
    const quaternions = this.variableForInput(
      shadersCollectionController,
      SetGeometryInstanceTransformsInputName.quaternion
    );
    const scales = this.variableForInput(shadersCollectionController, SetGeometryInstanceTransformsInputName.scale);
    const mult = this.variableForInput(shadersCollectionController, SetGeometryInstanceTransformsInputName.mult);
    const lerp = this.variableForInput(shadersCollectionController, SetGeometryInstanceTransformsInputName.lerp);
    const attributeNeedsUpdate = this.variableForInput(
      shadersCollectionController,
      SetGeometryInstanceTransformsInputName.attributeNeedsUpdate
    );
    const func = Poly/* Poly.namedFunctionsRegister.getFunction */.L.namedFunctionsRegister.getFunction(
      "setGeometryInstanceTransforms",
      this,
      shadersCollectionController
    );
    const bodyLine = func.asString(object3D, positions, quaternions, scales, mult, lerp, attributeNeedsUpdate);
    shadersCollectionController.addTriggerableLines(this, [bodyLine]);
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/js/SetGeometryPositions.ts






const SetGeometryPositionsInputName = {
  [connections_Js/* JsConnectionPointType.TRIGGER */.zF.TRIGGER]: connections_Js/* JsConnectionPointType.TRIGGER */.zF.TRIGGER,
  [connections_Js/* JsConnectionPointType.OBJECT_3D */.zF.OBJECT_3D]: connections_Js/* JsConnectionPointType.OBJECT_3D */.zF.OBJECT_3D,
  values: "values",
  lerp: "lerp",
  attributeNeedsUpdate: "attributeNeedsUpdate",
  computeNormals: "computeNormals",
  computeTangents: "computeTangents"
};
const SetGeometryPositions_INPUT_NAMES = [
  SetGeometryPositionsInputName.trigger,
  SetGeometryPositionsInputName.Object3D,
  SetGeometryPositionsInputName.values,
  SetGeometryPositionsInputName.lerp,
  SetGeometryPositionsInputName.attributeNeedsUpdate,
  SetGeometryPositionsInputName.computeNormals,
  SetGeometryPositionsInputName.computeTangents
];
const SetGeometryPositions_DefaultValues = {
  [SetGeometryPositionsInputName.lerp]: 1,
  [SetGeometryPositionsInputName.attributeNeedsUpdate]: true,
  [SetGeometryPositionsInputName.computeNormals]: true,
  [SetGeometryPositionsInputName.computeTangents]: true
};
class SetGeometryPositionsJsParamsConfig extends params_ParamsConfig/* NodeParamsConfig */.yI {
  constructor() {
    super(...arguments);
    this.lerp = params_ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(1, {
      range: [0, 1]
    });
    this.attributeNeedsUpdate = params_ParamsConfig/* ParamConfig.BOOLEAN */.XC.BOOLEAN(1);
    this.computeNormals = params_ParamsConfig/* ParamConfig.BOOLEAN */.XC.BOOLEAN(1);
    this.computeTangents = params_ParamsConfig/* ParamConfig.BOOLEAN */.XC.BOOLEAN(1);
  }
}
const SetGeometryPositions_ParamsConfig = new SetGeometryPositionsJsParamsConfig();
class SetGeometryPositionsJsNode extends js_Base/* TypedJsNode */.xZ {
  constructor() {
    super(...arguments);
    this.paramsConfig = SetGeometryPositions_ParamsConfig;
  }
  static type() {
    return "setGeometryPositions";
  }
  initializeNode() {
    super.initializeNode();
    this.io.connection_points.set_expected_input_types_function(this.expectedInputTypes.bind(this));
    this.io.connection_points.set_input_name_function(this._expectedInputName.bind(this));
    this.io.connection_points.set_expected_output_types_function(this._expectedOutputTypes.bind(this));
    this.io.connection_points.set_output_name_function(this._expectedOutputNames.bind(this));
  }
  paramDefaultValue(name) {
    return SetGeometryPositions_DefaultValues[name];
  }
  expectedInputTypes() {
    return [
      connections_Js/* JsConnectionPointType.TRIGGER */.zF.TRIGGER,
      connections_Js/* JsConnectionPointType.OBJECT_3D */.zF.OBJECT_3D,
      connections_Js/* JsConnectionPointType.VECTOR3_ARRAY */.zF.VECTOR3_ARRAY,
      connections_Js/* JsConnectionPointType.FLOAT */.zF.FLOAT,
      connections_Js/* JsConnectionPointType.BOOLEAN */.zF.BOOLEAN,
      connections_Js/* JsConnectionPointType.BOOLEAN */.zF.BOOLEAN,
      connections_Js/* JsConnectionPointType.BOOLEAN */.zF.BOOLEAN
    ];
  }
  _expectedInputName(index) {
    return SetGeometryPositions_INPUT_NAMES[index];
  }
  _expectedOutputTypes() {
    return [connections_Js/* JsConnectionPointType.TRIGGER */.zF.TRIGGER, connections_Js/* JsConnectionPointType.OBJECT_3D */.zF.OBJECT_3D];
  }
  _expectedOutputNames(i) {
    return [connections_Js/* JsConnectionPointType.TRIGGER */.zF.TRIGGER, connections_Js/* JsConnectionPointType.OBJECT_3D */.zF.OBJECT_3D][i];
  }
  setLines(linesController) {
    (0,_BaseObject3D/* setObject3DOutputLine */.PV)(this, linesController);
  }
  setTriggerableLines(shadersCollectionController) {
    const object3D = (0,_BaseObject3D/* inputObject3D */.iv)(this, shadersCollectionController);
    const values = this.variableForInput(shadersCollectionController, SetGeometryPositionsInputName.values);
    const lerp = this.variableForInputParam(shadersCollectionController, this.p.lerp);
    const attributeNeedsUpdate = this.variableForInputParam(
      shadersCollectionController,
      this.p.attributeNeedsUpdate
    );
    const computeNormals = this.variableForInputParam(shadersCollectionController, this.p.computeNormals);
    const computeTangents = this.variableForInputParam(shadersCollectionController, this.p.computeTangents);
    const func = Poly/* Poly.namedFunctionsRegister.getFunction */.L.namedFunctionsRegister.getFunction("setGeometryPositions", this, shadersCollectionController);
    const bodyLine = func.asString(object3D, values, lerp, attributeNeedsUpdate, computeNormals, computeTangents);
    shadersCollectionController.addTriggerableLines(this, [bodyLine]);
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/js/SetPointAttribute.ts

var SetPointAttribute_defProp = Object.defineProperty;
var SetPointAttribute_defProps = Object.defineProperties;
var SetPointAttribute_getOwnPropDescs = Object.getOwnPropertyDescriptors;
var SetPointAttribute_getOwnPropSymbols = Object.getOwnPropertySymbols;
var SetPointAttribute_hasOwnProp = Object.prototype.hasOwnProperty;
var SetPointAttribute_propIsEnum = Object.prototype.propertyIsEnumerable;
var SetPointAttribute_defNormalProp = (obj, key, value) => key in obj ? SetPointAttribute_defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var SetPointAttribute_spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (SetPointAttribute_hasOwnProp.call(b, prop))
      SetPointAttribute_defNormalProp(a, prop, b[prop]);
  if (SetPointAttribute_getOwnPropSymbols)
    for (var prop of SetPointAttribute_getOwnPropSymbols(b)) {
      if (SetPointAttribute_propIsEnum.call(b, prop))
        SetPointAttribute_defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var SetPointAttribute_spreadProps = (a, b) => SetPointAttribute_defProps(a, SetPointAttribute_getOwnPropDescs(b));







var SetPointAttributeInputName = /* @__PURE__ */ ((SetPointAttributeInputName2) => {
  SetPointAttributeInputName2["ptnum"] = "ptnum";
  SetPointAttributeInputName2["attribName"] = "attribName";
  SetPointAttributeInputName2["lerp"] = "lerp";
  SetPointAttributeInputName2["val"] = "val";
  return SetPointAttributeInputName2;
})(SetPointAttributeInputName || {});
const SetPointAttribute_CONNECTION_OPTIONS = connections_Js/* JS_CONNECTION_POINT_IN_NODE_DEF */.mX;
class SetPointAttributeJsParamsConfig extends params_ParamsConfig/* NodeParamsConfig */.yI {
  constructor() {
    super(...arguments);
    /** @param attribute type */
    this.type = params_ParamsConfig/* ParamConfig.INTEGER */.XC.INTEGER(connections_Js/* POINT_ATTRIBUTE_JS_CONNECTION_POINT_TYPES.indexOf */.Z.indexOf(connections_Js/* JsConnectionPointType.FLOAT */.zF.FLOAT), {
      menu: {
        entries: connections_Js/* POINT_ATTRIBUTE_JS_CONNECTION_POINT_TYPES.map */.Z.map((name, i) => {
          return { name, value: i };
        })
      }
    });
    /** @param attribName */
    this.attribName = params_ParamsConfig/* ParamConfig.STRING */.XC.STRING("");
    /** @param point index */
    this.ptnum = params_ParamsConfig/* ParamConfig.INTEGER */.XC.INTEGER(0);
    /** @param lerp factor */
    this.lerp = params_ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(1);
  }
}
const SetPointAttribute_ParamsConfig = new SetPointAttributeJsParamsConfig();
class SetPointAttributeJsNode extends js_Base/* TypedJsNode */.xZ {
  constructor() {
    super(...arguments);
    this.paramsConfig = SetPointAttribute_ParamsConfig;
  }
  static type() {
    return Js/* JsType.SET_POINT_ATTRIBUTE */.K.SET_POINT_ATTRIBUTE;
  }
  initializeNode() {
    this.io.inputs.setNamedInputConnectionPoints([
      new connections_Js/* JsConnectionPoint */.fp(connections_Js/* JsConnectionPointType.TRIGGER */.zF.TRIGGER, connections_Js/* JsConnectionPointType.TRIGGER */.zF.TRIGGER, SetPointAttribute_CONNECTION_OPTIONS),
      new connections_Js/* JsConnectionPoint */.fp(connections_Js/* JsConnectionPointType.OBJECT_3D */.zF.OBJECT_3D, connections_Js/* JsConnectionPointType.OBJECT_3D */.zF.OBJECT_3D, SetPointAttribute_CONNECTION_OPTIONS),
      new connections_Js/* JsConnectionPoint */.fp("ptnum" /* ptnum */, connections_Js/* JsConnectionPointType.INT */.zF.INT, SetPointAttribute_CONNECTION_OPTIONS),
      new connections_Js/* JsConnectionPoint */.fp(
        "attribName" /* attribName */,
        connections_Js/* JsConnectionPointType.STRING */.zF.STRING,
        SetPointAttribute_CONNECTION_OPTIONS
      ),
      new connections_Js/* JsConnectionPoint */.fp("lerp", connections_Js/* JsConnectionPointType.FLOAT */.zF.FLOAT, SetPointAttribute_spreadProps(SetPointAttribute_spreadValues({}, SetPointAttribute_CONNECTION_OPTIONS), {
        init_value: 1
      }))
    ]);
    this.io.connection_points.set_input_name_function(this._expectedInputName.bind(this));
    this.io.connection_points.set_expected_input_types_function(this._expectedInputType.bind(this));
    this.io.connection_points.set_output_name_function(this._expectedOutputName.bind(this));
    this.io.connection_points.set_expected_output_types_function(this._expectedOutputTypes.bind(this));
  }
  _expectedInputType() {
    return [this._currentConnectionType()];
  }
  _expectedOutputTypes() {
    return [
      connections_Js/* JsConnectionPointType.TRIGGER */.zF.TRIGGER,
      connections_Js/* JsConnectionPointType.OBJECT_3D */.zF.OBJECT_3D,
      connections_Js/* JsConnectionPointType.INT */.zF.INT,
      connections_Js/* JsConnectionPointType.STRING */.zF.STRING,
      connections_Js/* JsConnectionPointType.FLOAT */.zF.FLOAT,
      this._currentConnectionType()
    ];
  }
  _expectedInputName(index) {
    return "val" /* val */;
  }
  _expectedOutputName(index) {
    return [
      connections_Js/* JsConnectionPointType.TRIGGER */.zF.TRIGGER,
      connections_Js/* JsConnectionPointType.OBJECT_3D */.zF.OBJECT_3D,
      "ptnum" /* ptnum */,
      "attribName" /* attribName */,
      "lerp" /* lerp */,
      "val" /* val */
    ][index];
  }
  _currentConnectionType() {
    if (this.pv.type == null) {
      console.warn(`${this.type()} js node type not valid`);
    }
    const connectionType = connections_Js/* POINT_ATTRIBUTE_JS_CONNECTION_POINT_TYPES */.Z[this.pv.type];
    if (connectionType == null) {
      console.warn(`${this.type()} js node type not valid`);
    }
    return connectionType || connections_Js/* JsConnectionPointType.FLOAT */.zF.FLOAT;
  }
  setAttribType(type) {
    this.p.type.set(connections_Js/* POINT_ATTRIBUTE_JS_CONNECTION_POINT_TYPES.indexOf */.Z.indexOf(type));
  }
  setAttribName(attribName) {
    this.params.get("attribName" /* attribName */).set(attribName);
  }
  setLines(linesController) {
    (0,_BaseObject3D/* setObject3DOutputLine */.PV)(this, linesController);
    (0,_BaseObject3D/* integerOutputFromInput */.FM)(this, "ptnum" /* ptnum */, linesController);
    (0,_BaseObject3D/* vector3OutputFromInput */._L)(this, "attribName" /* attribName */, linesController);
    (0,_BaseObject3D/* floatOutputFromInput */.Cj)(this, "lerp" /* lerp */, linesController);
  }
  setTriggerableLines(linesController) {
    const object3D = (0,_BaseObject3D/* inputObject3D */.iv)(this, linesController);
    const ptnum = (0,_BaseObject3D/* inputPointIndex */.m7)(this, linesController);
    const attribName = this.variableForInput(linesController, "attribName" /* attribName */);
    const lerp = this.variableForInput(linesController, "lerp" /* lerp */);
    const newValue = this.variableForInput(linesController, "val" /* val */);
    const functionName = this._functionName();
    const func = Poly/* Poly.namedFunctionsRegister.getFunction */.L.namedFunctionsRegister.getFunction(functionName, this, linesController);
    const bodyLine = func.asString(object3D, attribName, ptnum, newValue, lerp);
    linesController.addTriggerableLines(this, [bodyLine]);
  }
  _functionName() {
    const type = this._currentConnectionType();
    switch (type) {
      case connections_Js/* JsConnectionPointType.INT */.zF.INT:
      case connections_Js/* JsConnectionPointType.FLOAT */.zF.FLOAT:
        return "setPointAttributeNumber";
      case connections_Js/* JsConnectionPointType.COLOR */.zF.COLOR:
        return "setPointAttributeColor";
      case connections_Js/* JsConnectionPointType.VECTOR2 */.zF.VECTOR2:
        return "setPointAttributeVector2";
      case connections_Js/* JsConnectionPointType.VECTOR3 */.zF.VECTOR3:
        return "setPointAttributeVector3";
      case connections_Js/* JsConnectionPointType.VECTOR4 */.zF.VECTOR4:
        return "setPointAttributeVector4";
    }
    Assert/* TypeAssert.unreachable */.f.unreachable(type);
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/js/SetInstanceAttribute.ts



class SetInstanceAttributeJsNode extends SetPointAttributeJsNode {
  static type() {
    return Js/* JsType.SET_INSTANCE_ATTRIBUTE */.K.SET_INSTANCE_ATTRIBUTE;
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/js/SetInstanceLookAt.ts







const SetInstanceLookAt_CONNECTION_OPTIONS = connections_Js/* JS_CONNECTION_POINT_IN_NODE_DEF */.mX;
class SetInstanceLookAtJsParamsConfig extends params_ParamsConfig/* NodeParamsConfig */.yI {
  constructor() {
    super(...arguments);
    /** @param point index */
    this.ptnum = params_ParamsConfig/* ParamConfig.INTEGER */.XC.INTEGER(0);
    /** @param target position */
    this.targetPosition = params_ParamsConfig/* ParamConfig.VECTOR3 */.XC.VECTOR3([0, 0, 0]);
    /** @param up */
    this.up = params_ParamsConfig/* ParamConfig.VECTOR3 */.XC.VECTOR3([0, 1, 0]);
    /** @param lerp factor */
    this.lerp = params_ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(1);
  }
}
const SetInstanceLookAt_ParamsConfig = new SetInstanceLookAtJsParamsConfig();
class SetInstanceLookAtJsNode extends _BaseTriggerAndObject/* BaseTriggerAndObjectJsNode */.e {
  constructor() {
    super(...arguments);
    this.paramsConfig = SetInstanceLookAt_ParamsConfig;
  }
  static type() {
    return Js/* JsType.SET_INSTANCE_LOOK_AT */.K.SET_INSTANCE_LOOK_AT;
  }
  _additionalOutputs() {
    return [
      new connections_Js/* JsConnectionPoint */.fp("ptnum", connections_Js/* JsConnectionPointType.INT */.zF.INT, SetInstanceLookAt_CONNECTION_OPTIONS),
      new connections_Js/* JsConnectionPoint */.fp("targetPosition", connections_Js/* JsConnectionPointType.VECTOR3 */.zF.VECTOR3, SetInstanceLookAt_CONNECTION_OPTIONS),
      new connections_Js/* JsConnectionPoint */.fp("up", connections_Js/* JsConnectionPointType.VECTOR3 */.zF.VECTOR3, SetInstanceLookAt_CONNECTION_OPTIONS),
      new connections_Js/* JsConnectionPoint */.fp("lerp", connections_Js/* JsConnectionPointType.FLOAT */.zF.FLOAT, SetInstanceLookAt_CONNECTION_OPTIONS)
    ];
  }
  setLines(linesController) {
    super.setLines(linesController);
    (0,_BaseObject3D/* integerOutputFromParam */.rq)(this, this.p.ptnum, linesController);
    (0,_BaseObject3D/* vector3OutputFromParam */.uM)(this, this.p.targetPosition, linesController);
    (0,_BaseObject3D/* floatOutputFromParam */.q3)(this, this.p.lerp, linesController);
  }
  setTriggerableLines(linesController) {
    const object3D = (0,_BaseObject3D/* inputObject3D */.iv)(this, linesController);
    const ptnum = (0,_BaseObject3D/* inputPointIndex */.m7)(this, linesController);
    const targetPosition = this.variableForInputParam(linesController, this.p.targetPosition);
    const up = this.variableForInputParam(linesController, this.p.up);
    const lerp = this.variableForInputParam(linesController, this.p.lerp);
    const func = Poly/* Poly.namedFunctionsRegister.getFunction */.L.namedFunctionsRegister.getFunction("setPointInstanceLookAt", this, linesController);
    const bodyLine = func.asString(object3D, ptnum, targetPosition, up, lerp);
    linesController.addTriggerableLines(this, [bodyLine]);
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/js/SetInstancePosition.ts







const SetInstancePosition_CONNECTION_OPTIONS = connections_Js/* JS_CONNECTION_POINT_IN_NODE_DEF */.mX;
class SetInstancePositionJsParamsConfig extends params_ParamsConfig/* NodeParamsConfig */.yI {
  constructor() {
    super(...arguments);
    /** @param point index */
    this.ptnum = params_ParamsConfig/* ParamConfig.INTEGER */.XC.INTEGER(0);
    /** @param target position */
    this.position = params_ParamsConfig/* ParamConfig.VECTOR3 */.XC.VECTOR3([0, 0, 0]);
    /** @param lerp factor */
    this.lerp = params_ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(1);
  }
}
const SetInstancePosition_ParamsConfig = new SetInstancePositionJsParamsConfig();
class SetInstancePositionJsNode extends _BaseTriggerAndObject/* BaseTriggerAndObjectJsNode */.e {
  constructor() {
    super(...arguments);
    this.paramsConfig = SetInstancePosition_ParamsConfig;
  }
  static type() {
    return Js/* JsType.SET_INSTANCE_POSITION */.K.SET_INSTANCE_POSITION;
  }
  _additionalOutputs() {
    return [
      new connections_Js/* JsConnectionPoint */.fp("ptnum", connections_Js/* JsConnectionPointType.INT */.zF.INT, SetInstancePosition_CONNECTION_OPTIONS),
      new connections_Js/* JsConnectionPoint */.fp("position", connections_Js/* JsConnectionPointType.VECTOR3 */.zF.VECTOR3, SetInstancePosition_CONNECTION_OPTIONS),
      new connections_Js/* JsConnectionPoint */.fp("lerp", connections_Js/* JsConnectionPointType.FLOAT */.zF.FLOAT, SetInstancePosition_CONNECTION_OPTIONS)
    ];
  }
  setLines(linesController) {
    super.setLines(linesController);
    (0,_BaseObject3D/* integerOutputFromParam */.rq)(this, this.p.ptnum, linesController);
    (0,_BaseObject3D/* vector3OutputFromParam */.uM)(this, this.p.position, linesController);
    (0,_BaseObject3D/* floatOutputFromParam */.q3)(this, this.p.lerp, linesController);
  }
  setTriggerableLines(linesController) {
    const object3D = (0,_BaseObject3D/* inputObject3D */.iv)(this, linesController);
    const ptnum = (0,_BaseObject3D/* inputPointIndex */.m7)(this, linesController);
    const position = this.variableForInputParam(linesController, this.p.position);
    const lerp = this.variableForInputParam(linesController, this.p.lerp);
    const func = Poly/* Poly.namedFunctionsRegister.getFunction */.L.namedFunctionsRegister.getFunction("setPointInstancePosition", this, linesController);
    const bodyLine = func.asString(object3D, ptnum, position, lerp);
    linesController.addTriggerableLines(this, [bodyLine]);
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/js/SetInstanceQuaternion.ts







const SetInstanceQuaternion_CONNECTION_OPTIONS = connections_Js/* JS_CONNECTION_POINT_IN_NODE_DEF */.mX;
class SetInstanceQuaternionJsParamsConfig extends params_ParamsConfig/* NodeParamsConfig */.yI {
  constructor() {
    super(...arguments);
    /** @param point index */
    this.ptnum = params_ParamsConfig/* ParamConfig.INTEGER */.XC.INTEGER(0);
    /** @param lerp factor */
    this.lerp = params_ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(1);
  }
}
const SetInstanceQuaternion_ParamsConfig = new SetInstanceQuaternionJsParamsConfig();
class SetInstanceQuaternionJsNode extends js_Base/* TypedJsNode */.xZ {
  constructor() {
    super(...arguments);
    this.paramsConfig = SetInstanceQuaternion_ParamsConfig;
  }
  static type() {
    return Js/* JsType.SET_INSTANCE_QUATERNION */.K.SET_INSTANCE_QUATERNION;
  }
  initializeNode() {
    this.io.inputs.setNamedInputConnectionPoints([
      new connections_Js/* JsConnectionPoint */.fp(js_Base/* TRIGGER_CONNECTION_NAME */.w6, connections_Js/* JsConnectionPointType.TRIGGER */.zF.TRIGGER, SetInstanceQuaternion_CONNECTION_OPTIONS),
      new connections_Js/* JsConnectionPoint */.fp(connections_Js/* JsConnectionPointType.OBJECT_3D */.zF.OBJECT_3D, connections_Js/* JsConnectionPointType.OBJECT_3D */.zF.OBJECT_3D, SetInstanceQuaternion_CONNECTION_OPTIONS),
      new connections_Js/* JsConnectionPoint */.fp("ptnum", connections_Js/* JsConnectionPointType.INT */.zF.INT, SetInstanceQuaternion_CONNECTION_OPTIONS),
      new connections_Js/* JsConnectionPoint */.fp(
        connections_Js/* JsConnectionPointType.QUATERNION */.zF.QUATERNION,
        connections_Js/* JsConnectionPointType.QUATERNION */.zF.QUATERNION,
        SetInstanceQuaternion_CONNECTION_OPTIONS
      )
    ]);
    this.io.outputs.setNamedOutputConnectionPoints([
      new connections_Js/* JsConnectionPoint */.fp(js_Base/* TRIGGER_CONNECTION_NAME */.w6, connections_Js/* JsConnectionPointType.TRIGGER */.zF.TRIGGER),
      new connections_Js/* JsConnectionPoint */.fp(connections_Js/* JsConnectionPointType.OBJECT_3D */.zF.OBJECT_3D, connections_Js/* JsConnectionPointType.OBJECT_3D */.zF.OBJECT_3D, SetInstanceQuaternion_CONNECTION_OPTIONS),
      new connections_Js/* JsConnectionPoint */.fp("ptnum", connections_Js/* JsConnectionPointType.INT */.zF.INT, SetInstanceQuaternion_CONNECTION_OPTIONS),
      new connections_Js/* JsConnectionPoint */.fp(connections_Js/* JsConnectionPointType.QUATERNION */.zF.QUATERNION, connections_Js/* JsConnectionPointType.VECTOR3 */.zF.VECTOR3, SetInstanceQuaternion_CONNECTION_OPTIONS),
      new connections_Js/* JsConnectionPoint */.fp("lerp", connections_Js/* JsConnectionPointType.FLOAT */.zF.FLOAT, SetInstanceQuaternion_CONNECTION_OPTIONS)
    ]);
  }
  setLines(linesController) {
    (0,_BaseObject3D/* setObject3DOutputLine */.PV)(this, linesController);
    (0,_BaseObject3D/* integerOutputFromParam */.rq)(this, this.p.ptnum, linesController);
    (0,_BaseObject3D/* vector4OutputFromInput */.Yr)(this, connections_Js/* JsConnectionPointType.QUATERNION */.zF.QUATERNION, linesController);
    (0,_BaseObject3D/* floatOutputFromParam */.q3)(this, this.p.lerp, linesController);
  }
  setTriggerableLines(linesController) {
    const object3D = (0,_BaseObject3D/* inputObject3D */.iv)(this, linesController);
    const ptnum = (0,_BaseObject3D/* inputPointIndex */.m7)(this, linesController);
    const quaternion = this.variableForInput(linesController, connections_Js/* JsConnectionPointType.QUATERNION */.zF.QUATERNION);
    const lerp = this.variableForInputParam(linesController, this.p.lerp);
    const func = Poly/* Poly.namedFunctionsRegister.getFunction */.L.namedFunctionsRegister.getFunction("setPointInstanceQuaternion", this, linesController);
    const bodyLine = func.asString(object3D, ptnum, quaternion, lerp);
    linesController.addTriggerableLines(this, [bodyLine]);
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/js/SetInstanceScale.ts







const SetInstanceScale_CONNECTION_OPTIONS = connections_Js/* JS_CONNECTION_POINT_IN_NODE_DEF */.mX;
class SetInstanceScaleJsParamsConfig extends params_ParamsConfig/* NodeParamsConfig */.yI {
  constructor() {
    super(...arguments);
    /** @param point index */
    this.ptnum = params_ParamsConfig/* ParamConfig.INTEGER */.XC.INTEGER(0);
    /** @param target scale */
    this.scale = params_ParamsConfig/* ParamConfig.VECTOR3 */.XC.VECTOR3([1, 1, 1]);
    /** @param target scale */
    this.mult = params_ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(1, {
      range: [0, 2],
      rangeLocked: [false, false]
    });
    /** @param lerp factor */
    this.lerp = params_ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(1);
  }
}
const SetInstanceScale_ParamsConfig = new SetInstanceScaleJsParamsConfig();
class SetInstanceScaleJsNode extends _BaseTriggerAndObject/* BaseTriggerAndObjectJsNode */.e {
  constructor() {
    super(...arguments);
    this.paramsConfig = SetInstanceScale_ParamsConfig;
  }
  static type() {
    return Js/* JsType.SET_INSTANCE_SCALE */.K.SET_INSTANCE_SCALE;
  }
  _additionalOutputs() {
    return [
      new connections_Js/* JsConnectionPoint */.fp("ptnum", connections_Js/* JsConnectionPointType.INT */.zF.INT, SetInstanceScale_CONNECTION_OPTIONS),
      new connections_Js/* JsConnectionPoint */.fp("scale", connections_Js/* JsConnectionPointType.VECTOR3 */.zF.VECTOR3, SetInstanceScale_CONNECTION_OPTIONS),
      new connections_Js/* JsConnectionPoint */.fp("mult", connections_Js/* JsConnectionPointType.FLOAT */.zF.FLOAT, SetInstanceScale_CONNECTION_OPTIONS),
      new connections_Js/* JsConnectionPoint */.fp("lerp", connections_Js/* JsConnectionPointType.FLOAT */.zF.FLOAT, SetInstanceScale_CONNECTION_OPTIONS)
    ];
  }
  setLines(linesController) {
    super.setLines(linesController);
    (0,_BaseObject3D/* integerOutputFromParam */.rq)(this, this.p.ptnum, linesController);
    (0,_BaseObject3D/* vector3OutputFromParam */.uM)(this, this.p.scale, linesController);
    (0,_BaseObject3D/* floatOutputFromParam */.q3)(this, this.p.mult, linesController);
    (0,_BaseObject3D/* floatOutputFromParam */.q3)(this, this.p.lerp, linesController);
  }
  setTriggerableLines(linesController) {
    const object3D = (0,_BaseObject3D/* inputObject3D */.iv)(this, linesController);
    const ptnum = (0,_BaseObject3D/* inputPointIndex */.m7)(this, linesController);
    const scale = this.variableForInputParam(linesController, this.p.scale);
    const mult = this.variableForInputParam(linesController, this.p.mult);
    const lerp = this.variableForInputParam(linesController, this.p.lerp);
    const func = Poly/* Poly.namedFunctionsRegister.getFunction */.L.namedFunctionsRegister.getFunction("setPointInstanceScale", this, linesController);
    const bodyLine = func.asString(object3D, ptnum, scale, mult, lerp);
    linesController.addTriggerableLines(this, [bodyLine]);
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/js/_BaseSetMaterialTexture.ts






const _BaseSetMaterialTexture_CONNECTION_OPTIONS = connections_Js/* JS_CONNECTION_POINT_IN_NODE_DEF */.mX;
class BaseSetMaterialTextureJsParamsConfig extends params_ParamsConfig/* NodeParamsConfig */.yI {
}
const _BaseSetMaterialTexture_ParamsConfig = new BaseSetMaterialTextureJsParamsConfig();
class BaseSetMaterialTextureJsNode extends js_Base/* TypedJsNode */.xZ {
  constructor() {
    super(...arguments);
    this.paramsConfig = _BaseSetMaterialTexture_ParamsConfig;
  }
  initializeNode() {
    this.io.inputs.setNamedInputConnectionPoints([
      new connections_Js/* JsConnectionPoint */.fp(js_Base/* TRIGGER_CONNECTION_NAME */.w6, connections_Js/* JsConnectionPointType.TRIGGER */.zF.TRIGGER, _BaseSetMaterialTexture_CONNECTION_OPTIONS),
      new connections_Js/* JsConnectionPoint */.fp(connections_Js/* JsConnectionPointType.MATERIAL */.zF.MATERIAL, connections_Js/* JsConnectionPointType.MATERIAL */.zF.MATERIAL, _BaseSetMaterialTexture_CONNECTION_OPTIONS),
      new connections_Js/* JsConnectionPoint */.fp(connections_Js/* JsConnectionPointType.TEXTURE */.zF.TEXTURE, connections_Js/* JsConnectionPointType.TEXTURE */.zF.TEXTURE, _BaseSetMaterialTexture_CONNECTION_OPTIONS)
    ]);
    this.io.outputs.setNamedOutputConnectionPoints([
      new connections_Js/* JsConnectionPoint */.fp(js_Base/* TRIGGER_CONNECTION_NAME */.w6, connections_Js/* JsConnectionPointType.TRIGGER */.zF.TRIGGER),
      new connections_Js/* JsConnectionPoint */.fp(connections_Js/* JsConnectionPointType.MATERIAL */.zF.MATERIAL, connections_Js/* JsConnectionPointType.MATERIAL */.zF.MATERIAL, _BaseSetMaterialTexture_CONNECTION_OPTIONS)
    ]);
  }
  setLines(linesController) {
    (0,_BaseObject3D/* setObject3DOutputLine */.PV)(this, linesController);
  }
  setTriggerableLines(linesController) {
    const material = (0,_BaseObject3D/* inputObject3DMaterial */.kI)(this, linesController);
    const texture = this.variableForInput(linesController, connections_Js/* JsConnectionPointType.TEXTURE */.zF.TEXTURE);
    const func = Poly/* Poly.namedFunctionsRegister.getFunction */.L.namedFunctionsRegister.getFunction(this._functionName(), this, linesController);
    const bodyLine = func.asString(material, texture);
    linesController.addTriggerableLines(this, [bodyLine]);
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/js/SetMaterialAlphaMap.ts


class SetMaterialAlphaMapJsNode extends BaseSetMaterialTextureJsNode {
  static type() {
    return "setMaterialAlphaMap";
  }
  _functionName() {
    return "setMaterialAlphaMap";
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/js/SetMaterialAOMap.ts


class SetMaterialAOMapJsNode extends BaseSetMaterialTextureJsNode {
  static type() {
    return "setMaterialAOMap";
  }
  _functionName() {
    return "setMaterialAOMap";
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/js/_BaseSetMaterialColor.ts






const _BaseSetMaterialColor_CONNECTION_OPTIONS = connections_Js/* JS_CONNECTION_POINT_IN_NODE_DEF */.mX;
class BaseSetMaterialColorJsParamsConfig extends params_ParamsConfig/* NodeParamsConfig */.yI {
  constructor() {
    super(...arguments);
    /** @param color */
    this.color = params_ParamsConfig/* ParamConfig.COLOR */.XC.COLOR([1, 1, 1]);
    /** @param lerp factor */
    this.lerp = params_ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(1);
  }
}
const _BaseSetMaterialColor_ParamsConfig = new BaseSetMaterialColorJsParamsConfig();
class BaseSetMaterialColorJsNode extends js_Base/* TypedJsNode */.xZ {
  constructor() {
    super(...arguments);
    this.paramsConfig = _BaseSetMaterialColor_ParamsConfig;
  }
  initializeNode() {
    this.io.inputs.setNamedInputConnectionPoints([
      new connections_Js/* JsConnectionPoint */.fp(js_Base/* TRIGGER_CONNECTION_NAME */.w6, connections_Js/* JsConnectionPointType.TRIGGER */.zF.TRIGGER, _BaseSetMaterialColor_CONNECTION_OPTIONS),
      new connections_Js/* JsConnectionPoint */.fp(connections_Js/* JsConnectionPointType.MATERIAL */.zF.MATERIAL, connections_Js/* JsConnectionPointType.MATERIAL */.zF.MATERIAL, _BaseSetMaterialColor_CONNECTION_OPTIONS)
    ]);
    this.io.outputs.setNamedOutputConnectionPoints([
      new connections_Js/* JsConnectionPoint */.fp(js_Base/* TRIGGER_CONNECTION_NAME */.w6, connections_Js/* JsConnectionPointType.TRIGGER */.zF.TRIGGER),
      new connections_Js/* JsConnectionPoint */.fp(connections_Js/* JsConnectionPointType.MATERIAL */.zF.MATERIAL, connections_Js/* JsConnectionPointType.MATERIAL */.zF.MATERIAL, _BaseSetMaterialColor_CONNECTION_OPTIONS)
    ]);
  }
  setLines(linesController) {
    (0,_BaseObject3D/* setObject3DOutputLine */.PV)(this, linesController);
  }
  setTriggerableLines(shadersCollectionController) {
    const material = (0,_BaseObject3D/* inputObject3DMaterial */.kI)(this, shadersCollectionController);
    const color = this.variableForInputParam(shadersCollectionController, this.p.color);
    const lerp = this.variableForInputParam(shadersCollectionController, this.p.lerp);
    const func = Poly/* Poly.namedFunctionsRegister.getFunction */.L.namedFunctionsRegister.getFunction(this._functionName(), this, shadersCollectionController);
    const bodyLine = func.asString(material, color, lerp);
    shadersCollectionController.addTriggerableLines(this, [bodyLine]);
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/js/SetMaterialColor.ts


class SetMaterialColorJsNode extends BaseSetMaterialColorJsNode {
  static type() {
    return "setMaterialColor";
  }
  _functionName() {
    return "setMaterialColor";
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/js/SetMaterialDisplacementMap.ts


class SetMaterialDisplacementMapJsNode extends BaseSetMaterialTextureJsNode {
  static type() {
    return "setMaterialDisplacementMap";
  }
  _functionName() {
    return "setMaterialDisplacementMap";
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/js/SetMaterialEmissiveColor.ts


class SetMaterialEmissiveColorJsNode extends BaseSetMaterialColorJsNode {
  static type() {
    return "setMaterialEmissiveColor";
  }
  _functionName() {
    return "setMaterialEmissiveColor";
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/js/SetMaterialEnvMap.ts


class SetMaterialEnvMapJsNode extends BaseSetMaterialTextureJsNode {
  static type() {
    return "setMaterialEnvMap";
  }
  _functionName() {
    return "setMaterialEnvMap";
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/js/SetMaterialEmissiveMap.ts


class SetMaterialEmissiveMapJsNode extends BaseSetMaterialTextureJsNode {
  static type() {
    return "setMaterialEmissiveMap";
  }
  _functionName() {
    return "setMaterialEmissiveMap";
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/js/SetMaterialMap.ts


class SetMaterialMapJsNode extends BaseSetMaterialTextureJsNode {
  static type() {
    return "setMaterialMap";
  }
  _functionName() {
    return "setMaterialMap";
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/js/SetMaterialMetalnessMap.ts


class SetMaterialMetalnessMapJsNode extends BaseSetMaterialTextureJsNode {
  static type() {
    return "setMaterialMetalnessMap";
  }
  _functionName() {
    return "setMaterialMetalnessMap";
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/js/SetMaterialRoughnessMap.ts


class SetMaterialRoughnessMapJsNode extends BaseSetMaterialTextureJsNode {
  static type() {
    return "setMaterialRoughnessMap";
  }
  _functionName() {
    return "setMaterialRoughnessMap";
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/js/_BaseSetMaterialFloat.ts






const _BaseSetMaterialFloat_CONNECTION_OPTIONS = connections_Js/* JS_CONNECTION_POINT_IN_NODE_DEF */.mX;
class BaseSetMaterialFloatJsParamsConfig extends params_ParamsConfig/* NodeParamsConfig */.yI {
  constructor() {
    super(...arguments);
    /** @param float */
    this.float = params_ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(1);
    /** @param lerp factor */
    this.lerp = params_ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(1);
  }
}
const _BaseSetMaterialFloat_ParamsConfig = new BaseSetMaterialFloatJsParamsConfig();
class BaseSetMaterialFloatJsNode extends js_Base/* TypedJsNode */.xZ {
  constructor() {
    super(...arguments);
    this.paramsConfig = _BaseSetMaterialFloat_ParamsConfig;
  }
  initializeNode() {
    this.io.inputs.setNamedInputConnectionPoints([
      new connections_Js/* JsConnectionPoint */.fp(js_Base/* TRIGGER_CONNECTION_NAME */.w6, connections_Js/* JsConnectionPointType.TRIGGER */.zF.TRIGGER, _BaseSetMaterialFloat_CONNECTION_OPTIONS),
      new connections_Js/* JsConnectionPoint */.fp(connections_Js/* JsConnectionPointType.MATERIAL */.zF.MATERIAL, connections_Js/* JsConnectionPointType.MATERIAL */.zF.MATERIAL, _BaseSetMaterialFloat_CONNECTION_OPTIONS)
    ]);
    this.io.outputs.setNamedOutputConnectionPoints([
      new connections_Js/* JsConnectionPoint */.fp(js_Base/* TRIGGER_CONNECTION_NAME */.w6, connections_Js/* JsConnectionPointType.TRIGGER */.zF.TRIGGER),
      new connections_Js/* JsConnectionPoint */.fp(connections_Js/* JsConnectionPointType.MATERIAL */.zF.MATERIAL, connections_Js/* JsConnectionPointType.MATERIAL */.zF.MATERIAL, _BaseSetMaterialFloat_CONNECTION_OPTIONS)
    ]);
  }
  setLines(linesController) {
    (0,_BaseObject3D/* setObject3DOutputLine */.PV)(this, linesController);
  }
  setTriggerableLines(shadersCollectionController) {
    const material = (0,_BaseObject3D/* inputObject3DMaterial */.kI)(this, shadersCollectionController);
    const float = this.variableForInputParam(shadersCollectionController, this.p.float);
    const lerp = this.variableForInputParam(shadersCollectionController, this.p.lerp);
    const func = Poly/* Poly.namedFunctionsRegister.getFunction */.L.namedFunctionsRegister.getFunction(this._functionName(), this, shadersCollectionController);
    const bodyLine = func.asString(material, float, lerp);
    shadersCollectionController.addTriggerableLines(this, [bodyLine]);
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/js/SetMaterialOpacity.ts


class SetMaterialOpacityJsNode extends BaseSetMaterialFloatJsNode {
  static type() {
    return "setMaterialOpacity";
  }
  _functionName() {
    return "setMaterialOpacity";
  }
}

// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/nodes/js/SetMaterialUniform.ts
var SetMaterialUniform = __webpack_require__(21615);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/nodes/js/SetObjectAttribute.ts
var SetObjectAttribute = __webpack_require__(8660);
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/js/SetObjectCastShadow.ts






const SetObjectCastShadow_CONNECTION_OPTIONS = connections_Js/* JS_CONNECTION_POINT_IN_NODE_DEF */.mX;
class SetObjectCastShadowJsParamsConfig extends params_ParamsConfig/* NodeParamsConfig */.yI {
  constructor() {
    super(...arguments);
    /** @param target castShadow state */
    this.castShadow = params_ParamsConfig/* ParamConfig.BOOLEAN */.XC.BOOLEAN(true);
  }
}
const SetObjectCastShadow_ParamsConfig = new SetObjectCastShadowJsParamsConfig();
class SetObjectCastShadowJsNode extends js_Base/* TypedJsNode */.xZ {
  constructor() {
    super(...arguments);
    this.paramsConfig = SetObjectCastShadow_ParamsConfig;
  }
  static type() {
    return "setObjectCastShadow";
  }
  initializeNode() {
    this.io.inputs.setNamedInputConnectionPoints([
      new connections_Js/* JsConnectionPoint */.fp(js_Base/* TRIGGER_CONNECTION_NAME */.w6, connections_Js/* JsConnectionPointType.TRIGGER */.zF.TRIGGER, SetObjectCastShadow_CONNECTION_OPTIONS),
      new connections_Js/* JsConnectionPoint */.fp(connections_Js/* JsConnectionPointType.OBJECT_3D */.zF.OBJECT_3D, connections_Js/* JsConnectionPointType.OBJECT_3D */.zF.OBJECT_3D, SetObjectCastShadow_CONNECTION_OPTIONS)
    ]);
    this.io.outputs.setNamedOutputConnectionPoints([
      new connections_Js/* JsConnectionPoint */.fp(js_Base/* TRIGGER_CONNECTION_NAME */.w6, connections_Js/* JsConnectionPointType.TRIGGER */.zF.TRIGGER),
      new connections_Js/* JsConnectionPoint */.fp(connections_Js/* JsConnectionPointType.OBJECT_3D */.zF.OBJECT_3D, connections_Js/* JsConnectionPointType.OBJECT_3D */.zF.OBJECT_3D, SetObjectCastShadow_CONNECTION_OPTIONS)
    ]);
  }
  setLines(linesController) {
    (0,_BaseObject3D/* setObject3DOutputLine */.PV)(this, linesController);
  }
  setTriggerableLines(shadersCollectionController) {
    const object3D = (0,_BaseObject3D/* inputObject3D */.iv)(this, shadersCollectionController);
    const castShadow = this.variableForInputParam(shadersCollectionController, this.p.castShadow);
    const func = Poly/* Poly.namedFunctionsRegister.getFunction */.L.namedFunctionsRegister.getFunction("setObjectCastShadow", this, shadersCollectionController);
    const bodyLine = func.asString(object3D, castShadow);
    shadersCollectionController.addTriggerableLines(this, [bodyLine]);
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/js/SetObjectFrustumCulled.ts






const SetObjectFrustumCulled_CONNECTION_OPTIONS = connections_Js/* JS_CONNECTION_POINT_IN_NODE_DEF */.mX;
class SetObjectFrustumCulledJsParamsConfig extends params_ParamsConfig/* NodeParamsConfig */.yI {
  constructor() {
    super(...arguments);
    /** @param target FrustumCulled state */
    this.frustumCulled = params_ParamsConfig/* ParamConfig.BOOLEAN */.XC.BOOLEAN(true);
  }
}
const SetObjectFrustumCulled_ParamsConfig = new SetObjectFrustumCulledJsParamsConfig();
class SetObjectFrustumCulledJsNode extends js_Base/* TypedJsNode */.xZ {
  constructor() {
    super(...arguments);
    this.paramsConfig = SetObjectFrustumCulled_ParamsConfig;
  }
  static type() {
    return "setObjectFrustumCulled";
  }
  initializeNode() {
    this.io.inputs.setNamedInputConnectionPoints([
      new connections_Js/* JsConnectionPoint */.fp(js_Base/* TRIGGER_CONNECTION_NAME */.w6, connections_Js/* JsConnectionPointType.TRIGGER */.zF.TRIGGER, SetObjectFrustumCulled_CONNECTION_OPTIONS),
      new connections_Js/* JsConnectionPoint */.fp(connections_Js/* JsConnectionPointType.OBJECT_3D */.zF.OBJECT_3D, connections_Js/* JsConnectionPointType.OBJECT_3D */.zF.OBJECT_3D, SetObjectFrustumCulled_CONNECTION_OPTIONS)
    ]);
    this.io.outputs.setNamedOutputConnectionPoints([
      new connections_Js/* JsConnectionPoint */.fp(js_Base/* TRIGGER_CONNECTION_NAME */.w6, connections_Js/* JsConnectionPointType.TRIGGER */.zF.TRIGGER),
      new connections_Js/* JsConnectionPoint */.fp(connections_Js/* JsConnectionPointType.OBJECT_3D */.zF.OBJECT_3D, connections_Js/* JsConnectionPointType.OBJECT_3D */.zF.OBJECT_3D, SetObjectFrustumCulled_CONNECTION_OPTIONS)
    ]);
  }
  setLines(linesController) {
    (0,_BaseObject3D/* setObject3DOutputLine */.PV)(this, linesController);
  }
  setTriggerableLines(shadersCollectionController) {
    const object3D = (0,_BaseObject3D/* inputObject3D */.iv)(this, shadersCollectionController);
    const frustumCulled = this.variableForInputParam(shadersCollectionController, this.p.frustumCulled);
    const func = Poly/* Poly.namedFunctionsRegister.getFunction */.L.namedFunctionsRegister.getFunction(
      "setObjectFrustumCulled",
      this,
      shadersCollectionController
    );
    const bodyLine = func.asString(object3D, frustumCulled);
    shadersCollectionController.addTriggerableLines(this, [bodyLine]);
  }
}

// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/nodes/js/SetObjectLookAt.ts
var SetObjectLookAt = __webpack_require__(25532);
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/js/SetObjectMaterial.ts





const SetObjectMaterial_CONNECTION_OPTIONS = connections_Js/* JS_CONNECTION_POINT_IN_NODE_DEF */.mX;
class SetObjectMaterialJsNode extends js_Base/* ParamlessTypedJsNode */.au {
  static type() {
    return "setObjectMaterial";
  }
  initializeNode() {
    this.io.inputs.setNamedInputConnectionPoints([
      new connections_Js/* JsConnectionPoint */.fp(js_Base/* TRIGGER_CONNECTION_NAME */.w6, connections_Js/* JsConnectionPointType.TRIGGER */.zF.TRIGGER, SetObjectMaterial_CONNECTION_OPTIONS),
      new connections_Js/* JsConnectionPoint */.fp(connections_Js/* JsConnectionPointType.OBJECT_3D */.zF.OBJECT_3D, connections_Js/* JsConnectionPointType.OBJECT_3D */.zF.OBJECT_3D, SetObjectMaterial_CONNECTION_OPTIONS),
      new connections_Js/* JsConnectionPoint */.fp(connections_Js/* JsConnectionPointType.MATERIAL */.zF.MATERIAL, connections_Js/* JsConnectionPointType.MATERIAL */.zF.MATERIAL, SetObjectMaterial_CONNECTION_OPTIONS)
    ]);
    this.io.outputs.setNamedOutputConnectionPoints([
      new connections_Js/* JsConnectionPoint */.fp(js_Base/* TRIGGER_CONNECTION_NAME */.w6, connections_Js/* JsConnectionPointType.TRIGGER */.zF.TRIGGER)
    ]);
  }
  setLines(linesController) {
    (0,_BaseObject3D/* setObject3DOutputLine */.PV)(this, linesController);
  }
  setTriggerableLines(shadersCollectionController) {
    const object3D = (0,_BaseObject3D/* inputObject3D */.iv)(this, shadersCollectionController);
    const material = this.variableForInput(shadersCollectionController, connections_Js/* JsConnectionPointType.MATERIAL */.zF.MATERIAL);
    const func = Poly/* Poly.namedFunctionsRegister.getFunction */.L.namedFunctionsRegister.getFunction("setObjectMaterial", this, shadersCollectionController);
    const bodyLine = func.asString(object3D, material);
    shadersCollectionController.addTriggerableLines(this, [bodyLine]);
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/js/SetObjectMaterialColor.ts






const SetObjectMaterialColor_CONNECTION_OPTIONS = connections_Js/* JS_CONNECTION_POINT_IN_NODE_DEF */.mX;
class SetObjectMaterialColorJsParamsConfig extends params_ParamsConfig/* NodeParamsConfig */.yI {
  constructor() {
    super(...arguments);
    /** @param color */
    this.color = params_ParamsConfig/* ParamConfig.COLOR */.XC.COLOR([1, 1, 1]);
    /** @param lerp factor */
    this.lerp = params_ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(1);
  }
}
const SetObjectMaterialColor_ParamsConfig = new SetObjectMaterialColorJsParamsConfig();
class SetObjectMaterialColorJsNode extends js_Base/* TypedJsNode */.xZ {
  constructor() {
    super(...arguments);
    this.paramsConfig = SetObjectMaterialColor_ParamsConfig;
  }
  static type() {
    return "setObjectMaterialColor";
  }
  initializeNode() {
    this.io.inputs.setNamedInputConnectionPoints([
      new connections_Js/* JsConnectionPoint */.fp(js_Base/* TRIGGER_CONNECTION_NAME */.w6, connections_Js/* JsConnectionPointType.TRIGGER */.zF.TRIGGER, SetObjectMaterialColor_CONNECTION_OPTIONS),
      new connections_Js/* JsConnectionPoint */.fp(connections_Js/* JsConnectionPointType.OBJECT_3D */.zF.OBJECT_3D, connections_Js/* JsConnectionPointType.OBJECT_3D */.zF.OBJECT_3D, SetObjectMaterialColor_CONNECTION_OPTIONS)
    ]);
    this.io.outputs.setNamedOutputConnectionPoints([
      new connections_Js/* JsConnectionPoint */.fp(js_Base/* TRIGGER_CONNECTION_NAME */.w6, connections_Js/* JsConnectionPointType.TRIGGER */.zF.TRIGGER)
    ]);
  }
  setLines(linesController) {
    (0,_BaseObject3D/* setObject3DOutputLine */.PV)(this, linesController);
  }
  setTriggerableLines(shadersCollectionController) {
    const object3D = (0,_BaseObject3D/* inputObject3D */.iv)(this, shadersCollectionController);
    const color = this.variableForInputParam(shadersCollectionController, this.p.color);
    const lerp = this.variableForInputParam(shadersCollectionController, this.p.lerp);
    const func = Poly/* Poly.namedFunctionsRegister.getFunction */.L.namedFunctionsRegister.getFunction(
      "setObjectMaterialColor",
      this,
      shadersCollectionController
    );
    const bodyLine = func.asString(object3D, color, lerp);
    shadersCollectionController.addTriggerableLines(this, [bodyLine]);
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/js/SetObjectMatrix.ts






const SetObjectMatrix_CONNECTION_OPTIONS = connections_Js/* JS_CONNECTION_POINT_IN_NODE_DEF */.mX;
class SetObjectMatrixJsParamsConfig extends params_ParamsConfig/* NodeParamsConfig */.yI {
}
const SetObjectMatrix_ParamsConfig = new SetObjectMatrixJsParamsConfig();
class SetObjectMatrixJsNode extends js_Base/* TypedJsNode */.xZ {
  constructor() {
    super(...arguments);
    this.paramsConfig = SetObjectMatrix_ParamsConfig;
  }
  static type() {
    return "setObjectMatrix";
  }
  initializeNode() {
    this.io.inputs.setNamedInputConnectionPoints([
      new connections_Js/* JsConnectionPoint */.fp(js_Base/* TRIGGER_CONNECTION_NAME */.w6, connections_Js/* JsConnectionPointType.TRIGGER */.zF.TRIGGER, SetObjectMatrix_CONNECTION_OPTIONS),
      new connections_Js/* JsConnectionPoint */.fp(connections_Js/* JsConnectionPointType.OBJECT_3D */.zF.OBJECT_3D, connections_Js/* JsConnectionPointType.OBJECT_3D */.zF.OBJECT_3D, SetObjectMatrix_CONNECTION_OPTIONS),
      new connections_Js/* JsConnectionPoint */.fp(connections_Js/* JsConnectionPointType.MATRIX4 */.zF.MATRIX4, connections_Js/* JsConnectionPointType.MATRIX4 */.zF.MATRIX4, SetObjectMatrix_CONNECTION_OPTIONS)
    ]);
    this.io.outputs.setNamedOutputConnectionPoints([
      new connections_Js/* JsConnectionPoint */.fp(js_Base/* TRIGGER_CONNECTION_NAME */.w6, connections_Js/* JsConnectionPointType.TRIGGER */.zF.TRIGGER),
      new connections_Js/* JsConnectionPoint */.fp(connections_Js/* JsConnectionPointType.OBJECT_3D */.zF.OBJECT_3D, connections_Js/* JsConnectionPointType.OBJECT_3D */.zF.OBJECT_3D, SetObjectMatrix_CONNECTION_OPTIONS)
    ]);
  }
  setLines(linesController) {
    (0,_BaseObject3D/* setObject3DOutputLine */.PV)(this, linesController);
  }
  setTriggerableLines(shadersCollectionController) {
    const object3D = (0,_BaseObject3D/* inputObject3D */.iv)(this, shadersCollectionController);
    const frustumCulled = this.variableForInput(shadersCollectionController, connections_Js/* JsConnectionPointType.MATRIX4 */.zF.MATRIX4);
    const func = Poly/* Poly.namedFunctionsRegister.getFunction */.L.namedFunctionsRegister.getFunction("setObjectMatrix", this, shadersCollectionController);
    const bodyLine = func.asString(object3D, frustumCulled);
    shadersCollectionController.addTriggerableLines(this, [bodyLine]);
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/js/SetObjectMatrixAutoUpdate.ts






const SetObjectMatrixAutoUpdate_CONNECTION_OPTIONS = connections_Js/* JS_CONNECTION_POINT_IN_NODE_DEF */.mX;
class SetObjectMatrixAutoUpdateJsParamsConfig extends params_ParamsConfig/* NodeParamsConfig */.yI {
  constructor() {
    super(...arguments);
    /** @param target MatrixAutoUpdate state */
    this.matrixAutoUpdate = params_ParamsConfig/* ParamConfig.BOOLEAN */.XC.BOOLEAN(true);
  }
}
const SetObjectMatrixAutoUpdate_ParamsConfig = new SetObjectMatrixAutoUpdateJsParamsConfig();
class SetObjectMatrixAutoUpdateJsNode extends js_Base/* TypedJsNode */.xZ {
  constructor() {
    super(...arguments);
    this.paramsConfig = SetObjectMatrixAutoUpdate_ParamsConfig;
  }
  static type() {
    return "setObjectMatrixAutoUpdate";
  }
  initializeNode() {
    this.io.inputs.setNamedInputConnectionPoints([
      new connections_Js/* JsConnectionPoint */.fp(js_Base/* TRIGGER_CONNECTION_NAME */.w6, connections_Js/* JsConnectionPointType.TRIGGER */.zF.TRIGGER, SetObjectMatrixAutoUpdate_CONNECTION_OPTIONS),
      new connections_Js/* JsConnectionPoint */.fp(connections_Js/* JsConnectionPointType.OBJECT_3D */.zF.OBJECT_3D, connections_Js/* JsConnectionPointType.OBJECT_3D */.zF.OBJECT_3D, SetObjectMatrixAutoUpdate_CONNECTION_OPTIONS)
    ]);
    this.io.outputs.setNamedOutputConnectionPoints([
      new connections_Js/* JsConnectionPoint */.fp(js_Base/* TRIGGER_CONNECTION_NAME */.w6, connections_Js/* JsConnectionPointType.TRIGGER */.zF.TRIGGER),
      new connections_Js/* JsConnectionPoint */.fp(connections_Js/* JsConnectionPointType.OBJECT_3D */.zF.OBJECT_3D, connections_Js/* JsConnectionPointType.OBJECT_3D */.zF.OBJECT_3D, SetObjectMatrixAutoUpdate_CONNECTION_OPTIONS)
    ]);
  }
  setLines(linesController) {
    (0,_BaseObject3D/* setObject3DOutputLine */.PV)(this, linesController);
  }
  setTriggerableLines(shadersCollectionController) {
    const object3D = (0,_BaseObject3D/* inputObject3D */.iv)(this, shadersCollectionController);
    const matrixAutoUpdate = this.variableForInputParam(shadersCollectionController, this.p.matrixAutoUpdate);
    const func = Poly/* Poly.namedFunctionsRegister.getFunction */.L.namedFunctionsRegister.getFunction(
      "setObjectMatrixAutoUpdate",
      this,
      shadersCollectionController
    );
    const bodyLine = func.asString(object3D, matrixAutoUpdate);
    shadersCollectionController.addTriggerableLines(this, [bodyLine]);
  }
}

// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/nodes/js/SetObjectPosition.ts
var SetObjectPosition = __webpack_require__(71484);
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/js/SetObjectReceiveShadow.ts






const SetObjectReceiveShadow_CONNECTION_OPTIONS = connections_Js/* JS_CONNECTION_POINT_IN_NODE_DEF */.mX;
class SetObjectReceiveShadowJsParamsConfig extends params_ParamsConfig/* NodeParamsConfig */.yI {
  constructor() {
    super(...arguments);
    /** @param target ReceiveShadow state */
    this.receiveShadow = params_ParamsConfig/* ParamConfig.BOOLEAN */.XC.BOOLEAN(true);
  }
}
const SetObjectReceiveShadow_ParamsConfig = new SetObjectReceiveShadowJsParamsConfig();
class SetObjectReceiveShadowJsNode extends js_Base/* TypedJsNode */.xZ {
  constructor() {
    super(...arguments);
    this.paramsConfig = SetObjectReceiveShadow_ParamsConfig;
  }
  static type() {
    return "setObjectReceiveShadow";
  }
  initializeNode() {
    this.io.inputs.setNamedInputConnectionPoints([
      new connections_Js/* JsConnectionPoint */.fp(js_Base/* TRIGGER_CONNECTION_NAME */.w6, connections_Js/* JsConnectionPointType.TRIGGER */.zF.TRIGGER, SetObjectReceiveShadow_CONNECTION_OPTIONS),
      new connections_Js/* JsConnectionPoint */.fp(connections_Js/* JsConnectionPointType.OBJECT_3D */.zF.OBJECT_3D, connections_Js/* JsConnectionPointType.OBJECT_3D */.zF.OBJECT_3D, SetObjectReceiveShadow_CONNECTION_OPTIONS)
    ]);
    this.io.outputs.setNamedOutputConnectionPoints([
      new connections_Js/* JsConnectionPoint */.fp(js_Base/* TRIGGER_CONNECTION_NAME */.w6, connections_Js/* JsConnectionPointType.TRIGGER */.zF.TRIGGER),
      new connections_Js/* JsConnectionPoint */.fp(connections_Js/* JsConnectionPointType.OBJECT_3D */.zF.OBJECT_3D, connections_Js/* JsConnectionPointType.OBJECT_3D */.zF.OBJECT_3D, SetObjectReceiveShadow_CONNECTION_OPTIONS)
    ]);
  }
  setLines(linesController) {
    (0,_BaseObject3D/* setObject3DOutputLine */.PV)(this, linesController);
  }
  setTriggerableLines(shadersCollectionController) {
    const object3D = (0,_BaseObject3D/* inputObject3D */.iv)(this, shadersCollectionController);
    const receiveShadow = this.variableForInputParam(shadersCollectionController, this.p.receiveShadow);
    const func = Poly/* Poly.namedFunctionsRegister.getFunction */.L.namedFunctionsRegister.getFunction(
      "setObjectReceiveShadow",
      this,
      shadersCollectionController
    );
    const bodyLine = func.asString(object3D, receiveShadow);
    shadersCollectionController.addTriggerableLines(this, [bodyLine]);
  }
}

// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/nodes/js/SetObjectRotation.ts
var SetObjectRotation = __webpack_require__(53866);
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/js/SetObjectQuaternion.ts







const SetObjectQuaternion_CONNECTION_OPTIONS = connections_Js/* JS_CONNECTION_POINT_IN_NODE_DEF */.mX;
class SetObjectQuaternionJsParamsConfig extends params_ParamsConfig/* NodeParamsConfig */.yI {
  constructor() {
    super(...arguments);
    /** @param lerp factor */
    this.lerp = params_ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(1);
    /** @param sets if the matrix should be updated as the animation progresses */
    this.updateMatrix = params_ParamsConfig/* ParamConfig.BOOLEAN */.XC.BOOLEAN(1);
  }
}
const SetObjectQuaternion_ParamsConfig = new SetObjectQuaternionJsParamsConfig();
class SetObjectQuaternionJsNode extends js_Base/* TypedJsNode */.xZ {
  constructor() {
    super(...arguments);
    this.paramsConfig = SetObjectQuaternion_ParamsConfig;
  }
  static type() {
    return Js/* JsType.SET_OBJECT_QUATERNION */.K.SET_OBJECT_QUATERNION;
  }
  initializeNode() {
    this.io.inputs.setNamedInputConnectionPoints([
      new connections_Js/* JsConnectionPoint */.fp(js_Base/* TRIGGER_CONNECTION_NAME */.w6, connections_Js/* JsConnectionPointType.TRIGGER */.zF.TRIGGER, SetObjectQuaternion_CONNECTION_OPTIONS),
      new connections_Js/* JsConnectionPoint */.fp(connections_Js/* JsConnectionPointType.OBJECT_3D */.zF.OBJECT_3D, connections_Js/* JsConnectionPointType.OBJECT_3D */.zF.OBJECT_3D, SetObjectQuaternion_CONNECTION_OPTIONS),
      new connections_Js/* JsConnectionPoint */.fp(
        connections_Js/* JsConnectionPointType.QUATERNION */.zF.QUATERNION,
        connections_Js/* JsConnectionPointType.QUATERNION */.zF.QUATERNION,
        SetObjectQuaternion_CONNECTION_OPTIONS
      )
    ]);
    this.io.outputs.setNamedOutputConnectionPoints([
      new connections_Js/* JsConnectionPoint */.fp(js_Base/* TRIGGER_CONNECTION_NAME */.w6, connections_Js/* JsConnectionPointType.TRIGGER */.zF.TRIGGER),
      new connections_Js/* JsConnectionPoint */.fp(connections_Js/* JsConnectionPointType.OBJECT_3D */.zF.OBJECT_3D, connections_Js/* JsConnectionPointType.OBJECT_3D */.zF.OBJECT_3D, SetObjectQuaternion_CONNECTION_OPTIONS)
    ]);
  }
  setLines(linesController) {
    (0,_BaseObject3D/* setObject3DOutputLine */.PV)(this, linesController);
  }
  setTriggerableLines(shadersCollectionController) {
    const object3D = (0,_BaseObject3D/* inputObject3D */.iv)(this, shadersCollectionController);
    const quaternion = this.variableForInput(shadersCollectionController, connections_Js/* JsConnectionPointType.QUATERNION */.zF.QUATERNION);
    const lerp = this.variableForInputParam(shadersCollectionController, this.p.lerp);
    const updateMatrix = this.variableForInputParam(shadersCollectionController, this.p.updateMatrix);
    const func = Poly/* Poly.namedFunctionsRegister.getFunction */.L.namedFunctionsRegister.getFunction("setObjectQuaternion", this, shadersCollectionController);
    const bodyLine = func.asString(object3D, quaternion, lerp, updateMatrix);
    shadersCollectionController.addTriggerableLines(this, [bodyLine]);
  }
}

// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/nodes/js/SetObjectPolarTransform.ts
var SetObjectPolarTransform = __webpack_require__(99291);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/nodes/js/SetObjectScale.ts
var SetObjectScale = __webpack_require__(99669);
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/js/SetObjectVisible.ts






const SetObjectVisible_CONNECTION_OPTIONS = connections_Js/* JS_CONNECTION_POINT_IN_NODE_DEF */.mX;
class SetObjectVisibleJsParamsConfig extends params_ParamsConfig/* NodeParamsConfig */.yI {
  constructor() {
    super(...arguments);
    /** @param target visible state */
    this.visible = params_ParamsConfig/* ParamConfig.BOOLEAN */.XC.BOOLEAN(true);
  }
}
const SetObjectVisible_ParamsConfig = new SetObjectVisibleJsParamsConfig();
class SetObjectVisibleJsNode extends js_Base/* TypedJsNode */.xZ {
  constructor() {
    super(...arguments);
    this.paramsConfig = SetObjectVisible_ParamsConfig;
  }
  static type() {
    return "setObjectVisible";
  }
  initializeNode() {
    this.io.inputs.setNamedInputConnectionPoints([
      new connections_Js/* JsConnectionPoint */.fp(js_Base/* TRIGGER_CONNECTION_NAME */.w6, connections_Js/* JsConnectionPointType.TRIGGER */.zF.TRIGGER, SetObjectVisible_CONNECTION_OPTIONS),
      new connections_Js/* JsConnectionPoint */.fp(connections_Js/* JsConnectionPointType.OBJECT_3D */.zF.OBJECT_3D, connections_Js/* JsConnectionPointType.OBJECT_3D */.zF.OBJECT_3D, SetObjectVisible_CONNECTION_OPTIONS)
    ]);
    this.io.outputs.setNamedOutputConnectionPoints([
      new connections_Js/* JsConnectionPoint */.fp(js_Base/* TRIGGER_CONNECTION_NAME */.w6, connections_Js/* JsConnectionPointType.TRIGGER */.zF.TRIGGER),
      new connections_Js/* JsConnectionPoint */.fp(connections_Js/* JsConnectionPointType.OBJECT_3D */.zF.OBJECT_3D, connections_Js/* JsConnectionPointType.OBJECT_3D */.zF.OBJECT_3D, SetObjectVisible_CONNECTION_OPTIONS)
    ]);
  }
  setLines(linesController) {
    (0,_BaseObject3D/* setObject3DOutputLine */.PV)(this, linesController);
  }
  setTriggerableLines(shadersCollectionController) {
    const object3D = (0,_BaseObject3D/* inputObject3D */.iv)(this, shadersCollectionController);
    const visible = this.variableForInputParam(shadersCollectionController, this.p.visible);
    const func = Poly/* Poly.namedFunctionsRegister.getFunction */.L.namedFunctionsRegister.getFunction("setObjectVisible", this, shadersCollectionController);
    const bodyLine = func.asString(object3D, visible);
    shadersCollectionController.addTriggerableLines(this, [bodyLine]);
  }
}

// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/nodes/js/SetParam.ts
var js_SetParam = __webpack_require__(16130);
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/js/SetPerspectiveCameraFov.ts






const SetPerspectiveCameraFov_CONNECTION_OPTIONS = connections_Js/* JS_CONNECTION_POINT_IN_NODE_DEF */.mX;
class SetPerspectiveCameraFovJsParamsConfig extends params_ParamsConfig/* NodeParamsConfig */.yI {
  constructor() {
    super(...arguments);
    /** @param focal length */
    this.fov = params_ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(50);
    /** @param lerp factor */
    this.lerp = params_ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(1);
    /** @param sets if the projection matrix should be updated as the animation progresses */
    this.updateProjectionMatrix = params_ParamsConfig/* ParamConfig.BOOLEAN */.XC.BOOLEAN(1);
  }
}
const SetPerspectiveCameraFov_ParamsConfig = new SetPerspectiveCameraFovJsParamsConfig();
class SetPerspectiveCameraFovJsNode extends js_Base/* TypedJsNode */.xZ {
  constructor() {
    super(...arguments);
    this.paramsConfig = SetPerspectiveCameraFov_ParamsConfig;
  }
  static type() {
    return "setPerspectiveCameraFov";
  }
  initializeNode() {
    this.io.inputs.setNamedInputConnectionPoints([
      new connections_Js/* JsConnectionPoint */.fp(js_Base/* TRIGGER_CONNECTION_NAME */.w6, connections_Js/* JsConnectionPointType.TRIGGER */.zF.TRIGGER, SetPerspectiveCameraFov_CONNECTION_OPTIONS),
      new connections_Js/* JsConnectionPoint */.fp(connections_Js/* JsConnectionPointType.OBJECT_3D */.zF.OBJECT_3D, connections_Js/* JsConnectionPointType.OBJECT_3D */.zF.OBJECT_3D, SetPerspectiveCameraFov_CONNECTION_OPTIONS)
    ]);
    this.io.outputs.setNamedOutputConnectionPoints([
      new connections_Js/* JsConnectionPoint */.fp(js_Base/* TRIGGER_CONNECTION_NAME */.w6, connections_Js/* JsConnectionPointType.TRIGGER */.zF.TRIGGER),
      new connections_Js/* JsConnectionPoint */.fp(connections_Js/* JsConnectionPointType.OBJECT_3D */.zF.OBJECT_3D, connections_Js/* JsConnectionPointType.OBJECT_3D */.zF.OBJECT_3D, SetPerspectiveCameraFov_CONNECTION_OPTIONS)
    ]);
  }
  setLines(linesController) {
    (0,_BaseObject3D/* setObject3DOutputLine */.PV)(this, linesController);
  }
  setTriggerableLines(shadersCollectionController) {
    const object3D = (0,_BaseObject3D/* inputObject3D */.iv)(this, shadersCollectionController);
    const fov = this.variableForInputParam(shadersCollectionController, this.p.fov);
    const lerp = this.variableForInputParam(shadersCollectionController, this.p.lerp);
    const updateProjectionMatrix = this.variableForInputParam(
      shadersCollectionController,
      this.p.updateProjectionMatrix
    );
    const func = Poly/* Poly.namedFunctionsRegister.getFunction */.L.namedFunctionsRegister.getFunction(
      "setPerspectiveCameraFov",
      this,
      shadersCollectionController
    );
    const bodyLine = func.asString(object3D, fov, lerp, updateProjectionMatrix);
    shadersCollectionController.addTriggerableLines(this, [bodyLine]);
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/js/SetPerspectiveCameraNearFar.ts






const SetPerspectiveCameraNearFar_CONNECTION_OPTIONS = connections_Js/* JS_CONNECTION_POINT_IN_NODE_DEF */.mX;
class SetPerspectiveCameraNearFarJsParamsConfig extends params_ParamsConfig/* NodeParamsConfig */.yI {
  constructor() {
    super(...arguments);
    /** @param near */
    this.near = params_ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(1);
    /** @param far */
    this.far = params_ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(100);
    /** @param lerp factor */
    this.lerp = params_ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(1);
    /** @param sets if the projection matrix should be updated as the animation progresses */
    this.updateProjectionMatrix = params_ParamsConfig/* ParamConfig.BOOLEAN */.XC.BOOLEAN(1);
  }
}
const SetPerspectiveCameraNearFar_ParamsConfig = new SetPerspectiveCameraNearFarJsParamsConfig();
class SetPerspectiveCameraNearFarJsNode extends js_Base/* TypedJsNode */.xZ {
  constructor() {
    super(...arguments);
    this.paramsConfig = SetPerspectiveCameraNearFar_ParamsConfig;
  }
  static type() {
    return "setPerspectiveCameraNearFar";
  }
  initializeNode() {
    this.io.inputs.setNamedInputConnectionPoints([
      new connections_Js/* JsConnectionPoint */.fp(js_Base/* TRIGGER_CONNECTION_NAME */.w6, connections_Js/* JsConnectionPointType.TRIGGER */.zF.TRIGGER, SetPerspectiveCameraNearFar_CONNECTION_OPTIONS),
      new connections_Js/* JsConnectionPoint */.fp(connections_Js/* JsConnectionPointType.OBJECT_3D */.zF.OBJECT_3D, connections_Js/* JsConnectionPointType.OBJECT_3D */.zF.OBJECT_3D, SetPerspectiveCameraNearFar_CONNECTION_OPTIONS)
    ]);
    this.io.outputs.setNamedOutputConnectionPoints([
      new connections_Js/* JsConnectionPoint */.fp(js_Base/* TRIGGER_CONNECTION_NAME */.w6, connections_Js/* JsConnectionPointType.TRIGGER */.zF.TRIGGER),
      new connections_Js/* JsConnectionPoint */.fp(connections_Js/* JsConnectionPointType.OBJECT_3D */.zF.OBJECT_3D, connections_Js/* JsConnectionPointType.OBJECT_3D */.zF.OBJECT_3D, SetPerspectiveCameraNearFar_CONNECTION_OPTIONS)
    ]);
  }
  setLines(linesController) {
    (0,_BaseObject3D/* setObject3DOutputLine */.PV)(this, linesController);
  }
  setTriggerableLines(shadersCollectionController) {
    const object3D = (0,_BaseObject3D/* inputObject3D */.iv)(this, shadersCollectionController);
    const near = this.variableForInputParam(shadersCollectionController, this.p.near);
    const far = this.variableForInputParam(shadersCollectionController, this.p.far);
    const lerp = this.variableForInputParam(shadersCollectionController, this.p.lerp);
    const updateProjectionMatrix = this.variableForInputParam(
      shadersCollectionController,
      this.p.updateProjectionMatrix
    );
    const func = Poly/* Poly.namedFunctionsRegister.getFunction */.L.namedFunctionsRegister.getFunction(
      "setPerspectiveCameraNearFar",
      this,
      shadersCollectionController
    );
    const bodyLine = func.asString(object3D, near, far, lerp, updateProjectionMatrix);
    shadersCollectionController.addTriggerableLines(this, [bodyLine]);
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/js/SetPhysicsRBDAngularVelocity.ts







const SetPhysicsRBDAngularVelocity_CONNECTION_OPTIONS = connections_Js/* JS_CONNECTION_POINT_IN_NODE_DEF */.mX;
class SetPhysicsRBDAngularVelocityJsParamsConfig extends params_ParamsConfig/* NodeParamsConfig */.yI {
  constructor() {
    super(...arguments);
    /** @param target velocity */
    this.velocity = params_ParamsConfig/* ParamConfig.VECTOR3 */.XC.VECTOR3([0, 0, 0]);
    /** @param lerp factor */
    this.lerp = params_ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(1);
  }
}
const SetPhysicsRBDAngularVelocity_ParamsConfig = new SetPhysicsRBDAngularVelocityJsParamsConfig();
class SetPhysicsRBDAngularVelocityJsNode extends js_Base/* TypedJsNode */.xZ {
  constructor() {
    super(...arguments);
    this.paramsConfig = SetPhysicsRBDAngularVelocity_ParamsConfig;
  }
  static type() {
    return "setPhysicsRBDAngularVelocity";
  }
  initializeNode() {
    this.io.inputs.setNamedInputConnectionPoints([
      new connections_Js/* JsConnectionPoint */.fp(js_Base/* TRIGGER_CONNECTION_NAME */.w6, connections_Js/* JsConnectionPointType.TRIGGER */.zF.TRIGGER, SetPhysicsRBDAngularVelocity_CONNECTION_OPTIONS),
      new connections_Js/* JsConnectionPoint */.fp(connections_Js/* JsConnectionPointType.OBJECT_3D */.zF.OBJECT_3D, connections_Js/* JsConnectionPointType.OBJECT_3D */.zF.OBJECT_3D, SetPhysicsRBDAngularVelocity_CONNECTION_OPTIONS)
    ]);
    this.io.outputs.setNamedOutputConnectionPoints([
      new connections_Js/* JsConnectionPoint */.fp(js_Base/* TRIGGER_CONNECTION_NAME */.w6, connections_Js/* JsConnectionPointType.TRIGGER */.zF.TRIGGER),
      new connections_Js/* JsConnectionPoint */.fp(connections_Js/* JsConnectionPointType.OBJECT_3D */.zF.OBJECT_3D, connections_Js/* JsConnectionPointType.OBJECT_3D */.zF.OBJECT_3D, SetPhysicsRBDAngularVelocity_CONNECTION_OPTIONS)
    ]);
  }
  setLines(linesController) {
    (0,_BaseObject3D/* setObject3DOutputLine */.PV)(this, linesController);
  }
  setTriggerableLines(shadersCollectionController) {
    const object3D = (0,_BaseObject3D/* inputObject3D */.iv)(this, shadersCollectionController);
    const velocity = this.variableForInputParam(shadersCollectionController, this.p.velocity);
    const lerp = this.variableForInputParam(shadersCollectionController, this.p.lerp);
    const func = Poly/* Poly.namedFunctionsRegister.getFunction */.L.namedFunctionsRegister.getFunction(
      "setPhysicsRBDAngularVelocity",
      this,
      shadersCollectionController
    );
    const bodyLine = func.asString(object3D, velocity, lerp);
    shadersCollectionController.addTriggerableLines(this, [bodyLine]);
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/js/SetPhysicsRBDLinearVelocity.ts







const SetPhysicsRBDLinearVelocity_CONNECTION_OPTIONS = connections_Js/* JS_CONNECTION_POINT_IN_NODE_DEF */.mX;
class SetPhysicsRBDLinearVelocityJsParamsConfig extends params_ParamsConfig/* NodeParamsConfig */.yI {
  constructor() {
    super(...arguments);
    /** @param target position */
    this.velocity = params_ParamsConfig/* ParamConfig.VECTOR3 */.XC.VECTOR3([0, 0, 0]);
    /** @param lerp factor */
    this.lerp = params_ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(1);
  }
}
const SetPhysicsRBDLinearVelocity_ParamsConfig = new SetPhysicsRBDLinearVelocityJsParamsConfig();
class SetPhysicsRBDLinearVelocityJsNode extends js_Base/* TypedJsNode */.xZ {
  constructor() {
    super(...arguments);
    this.paramsConfig = SetPhysicsRBDLinearVelocity_ParamsConfig;
  }
  static type() {
    return "setPhysicsRBDLinearVelocity";
  }
  initializeNode() {
    this.io.inputs.setNamedInputConnectionPoints([
      new connections_Js/* JsConnectionPoint */.fp(js_Base/* TRIGGER_CONNECTION_NAME */.w6, connections_Js/* JsConnectionPointType.TRIGGER */.zF.TRIGGER, SetPhysicsRBDLinearVelocity_CONNECTION_OPTIONS),
      new connections_Js/* JsConnectionPoint */.fp(connections_Js/* JsConnectionPointType.OBJECT_3D */.zF.OBJECT_3D, connections_Js/* JsConnectionPointType.OBJECT_3D */.zF.OBJECT_3D, SetPhysicsRBDLinearVelocity_CONNECTION_OPTIONS)
    ]);
    this.io.outputs.setNamedOutputConnectionPoints([
      new connections_Js/* JsConnectionPoint */.fp(js_Base/* TRIGGER_CONNECTION_NAME */.w6, connections_Js/* JsConnectionPointType.TRIGGER */.zF.TRIGGER),
      new connections_Js/* JsConnectionPoint */.fp(connections_Js/* JsConnectionPointType.OBJECT_3D */.zF.OBJECT_3D, connections_Js/* JsConnectionPointType.OBJECT_3D */.zF.OBJECT_3D, SetPhysicsRBDLinearVelocity_CONNECTION_OPTIONS)
    ]);
  }
  setLines(linesController) {
    (0,_BaseObject3D/* setObject3DOutputLine */.PV)(this, linesController);
  }
  setTriggerableLines(shadersCollectionController) {
    const object3D = (0,_BaseObject3D/* inputObject3D */.iv)(this, shadersCollectionController);
    const velocity = this.variableForInputParam(shadersCollectionController, this.p.velocity);
    const lerp = this.variableForInputParam(shadersCollectionController, this.p.lerp);
    const func = Poly/* Poly.namedFunctionsRegister.getFunction */.L.namedFunctionsRegister.getFunction(
      "setPhysicsRBDLinearVelocity",
      this,
      shadersCollectionController
    );
    const bodyLine = func.asString(object3D, velocity, lerp);
    shadersCollectionController.addTriggerableLines(this, [bodyLine]);
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/js/SetPhysicsRBDPosition.ts








const SetPhysicsRBDPosition_CONNECTION_OPTIONS = connections_Js/* JS_CONNECTION_POINT_IN_NODE_DEF */.mX;
class SetPhysicsRBDPositionJsParamsConfig extends params_ParamsConfig/* NodeParamsConfig */.yI {
  constructor() {
    super(...arguments);
    /** @param target position */
    this.position = params_ParamsConfig/* ParamConfig.VECTOR3 */.XC.VECTOR3([0, 0, 0]);
    /** @param lerp factor */
    this.lerp = params_ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(1);
  }
}
const SetPhysicsRBDPosition_ParamsConfig = new SetPhysicsRBDPositionJsParamsConfig();
class SetPhysicsRBDPositionJsNode extends js_Base/* TypedJsNode */.xZ {
  constructor() {
    super(...arguments);
    this.paramsConfig = SetPhysicsRBDPosition_ParamsConfig;
  }
  static type() {
    return Js/* JsType.SET_PHYSICS_RBD_POSITION */.K.SET_PHYSICS_RBD_POSITION;
  }
  initializeNode() {
    this.io.inputs.setNamedInputConnectionPoints([
      new connections_Js/* JsConnectionPoint */.fp(js_Base/* TRIGGER_CONNECTION_NAME */.w6, connections_Js/* JsConnectionPointType.TRIGGER */.zF.TRIGGER, SetPhysicsRBDPosition_CONNECTION_OPTIONS),
      new connections_Js/* JsConnectionPoint */.fp(connections_Js/* JsConnectionPointType.OBJECT_3D */.zF.OBJECT_3D, connections_Js/* JsConnectionPointType.OBJECT_3D */.zF.OBJECT_3D, SetPhysicsRBDPosition_CONNECTION_OPTIONS)
    ]);
    this.io.outputs.setNamedOutputConnectionPoints([
      new connections_Js/* JsConnectionPoint */.fp(js_Base/* TRIGGER_CONNECTION_NAME */.w6, connections_Js/* JsConnectionPointType.TRIGGER */.zF.TRIGGER),
      new connections_Js/* JsConnectionPoint */.fp(connections_Js/* JsConnectionPointType.OBJECT_3D */.zF.OBJECT_3D, connections_Js/* JsConnectionPointType.OBJECT_3D */.zF.OBJECT_3D, SetPhysicsRBDPosition_CONNECTION_OPTIONS)
    ]);
  }
  setLines(linesController) {
    (0,_BaseObject3D/* setObject3DOutputLine */.PV)(this, linesController);
  }
  setTriggerableLines(shadersCollectionController) {
    const object3D = (0,_BaseObject3D/* inputObject3D */.iv)(this, shadersCollectionController);
    const position = this.variableForInputParam(shadersCollectionController, this.p.position);
    const lerp = this.variableForInputParam(shadersCollectionController, this.p.lerp);
    const func = Poly/* Poly.namedFunctionsRegister.getFunction */.L.namedFunctionsRegister.getFunction(
      "setPhysicsRBDPosition",
      this,
      shadersCollectionController
    );
    const bodyLine = func.asString(object3D, position, lerp);
    shadersCollectionController.addTriggerableLines(this, [bodyLine]);
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/js/SetPhysicsRBDRotation.ts







const SetPhysicsRBDRotation_CONNECTION_OPTIONS = connections_Js/* JS_CONNECTION_POINT_IN_NODE_DEF */.mX;
class SetPhysicsRBDRotationJsParamsConfig extends params_ParamsConfig/* NodeParamsConfig */.yI {
  constructor() {
    super(...arguments);
    /** @param target rotation */
    this.quaternion = params_ParamsConfig/* ParamConfig.VECTOR4 */.XC.VECTOR4([0, 0, 0, 0], {
      asQuaternion: true
    });
    /** @param lerp factor */
    this.lerp = params_ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(1);
  }
}
const SetPhysicsRBDRotation_ParamsConfig = new SetPhysicsRBDRotationJsParamsConfig();
class SetPhysicsRBDRotationJsNode extends js_Base/* TypedJsNode */.xZ {
  constructor() {
    super(...arguments);
    this.paramsConfig = SetPhysicsRBDRotation_ParamsConfig;
  }
  static type() {
    return "setPhysicsRBDRotation";
  }
  initializeNode() {
    this.io.inputs.setNamedInputConnectionPoints([
      new connections_Js/* JsConnectionPoint */.fp(js_Base/* TRIGGER_CONNECTION_NAME */.w6, connections_Js/* JsConnectionPointType.TRIGGER */.zF.TRIGGER, SetPhysicsRBDRotation_CONNECTION_OPTIONS),
      new connections_Js/* JsConnectionPoint */.fp(connections_Js/* JsConnectionPointType.OBJECT_3D */.zF.OBJECT_3D, connections_Js/* JsConnectionPointType.OBJECT_3D */.zF.OBJECT_3D, SetPhysicsRBDRotation_CONNECTION_OPTIONS)
    ]);
    this.io.outputs.setNamedOutputConnectionPoints([
      new connections_Js/* JsConnectionPoint */.fp(js_Base/* TRIGGER_CONNECTION_NAME */.w6, connections_Js/* JsConnectionPointType.TRIGGER */.zF.TRIGGER),
      new connections_Js/* JsConnectionPoint */.fp(connections_Js/* JsConnectionPointType.OBJECT_3D */.zF.OBJECT_3D, connections_Js/* JsConnectionPointType.OBJECT_3D */.zF.OBJECT_3D, SetPhysicsRBDRotation_CONNECTION_OPTIONS)
    ]);
  }
  setLines(linesController) {
    (0,_BaseObject3D/* setObject3DOutputLine */.PV)(this, linesController);
  }
  setTriggerableLines(shadersCollectionController) {
    const object3D = (0,_BaseObject3D/* inputObject3D */.iv)(this, shadersCollectionController);
    const quaternion = this.variableForInputParam(shadersCollectionController, this.p.quaternion);
    const lerp = this.variableForInputParam(shadersCollectionController, this.p.lerp);
    const func = Poly/* Poly.namedFunctionsRegister.getFunction */.L.namedFunctionsRegister.getFunction(
      "setPhysicsRBDRotation",
      this,
      shadersCollectionController
    );
    const bodyLine = func.asString(object3D, quaternion, lerp);
    shadersCollectionController.addTriggerableLines(this, [bodyLine]);
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/js/SetPhysicsRBDCapsuleProperty.ts







const SetPhysicsRBDCapsuleProperty_CONNECTION_OPTIONS = connections_Js/* JS_CONNECTION_POINT_IN_NODE_DEF */.mX;
class SetPhysicsRBDCapsulePropertyJsParamsConfig extends params_ParamsConfig/* NodeParamsConfig */.yI {
  constructor() {
    super(...arguments);
    /** @param target scale */
    this.scale = params_ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(1);
    /** @param lerp factor */
    this.lerp = params_ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(1);
    /** @param sets if the matrix should be updated as the animation progresses */
    this.updateMatrix = params_ParamsConfig/* ParamConfig.BOOLEAN */.XC.BOOLEAN(1);
  }
}
const SetPhysicsRBDCapsuleProperty_ParamsConfig = new SetPhysicsRBDCapsulePropertyJsParamsConfig();
class SetPhysicsRBDCapsulePropertyJsNode extends js_Base/* TypedJsNode */.xZ {
  constructor() {
    super(...arguments);
    this.paramsConfig = SetPhysicsRBDCapsuleProperty_ParamsConfig;
  }
  static type() {
    return "setPhysicsRBDCapsuleProperty";
  }
  initializeNode() {
    this.io.inputs.setNamedInputConnectionPoints([
      new connections_Js/* JsConnectionPoint */.fp(js_Base/* TRIGGER_CONNECTION_NAME */.w6, connections_Js/* JsConnectionPointType.TRIGGER */.zF.TRIGGER, SetPhysicsRBDCapsuleProperty_CONNECTION_OPTIONS),
      new connections_Js/* JsConnectionPoint */.fp(connections_Js/* JsConnectionPointType.OBJECT_3D */.zF.OBJECT_3D, connections_Js/* JsConnectionPointType.OBJECT_3D */.zF.OBJECT_3D, SetPhysicsRBDCapsuleProperty_CONNECTION_OPTIONS)
    ]);
    this.io.outputs.setNamedOutputConnectionPoints([
      new connections_Js/* JsConnectionPoint */.fp(js_Base/* TRIGGER_CONNECTION_NAME */.w6, connections_Js/* JsConnectionPointType.TRIGGER */.zF.TRIGGER),
      new connections_Js/* JsConnectionPoint */.fp(connections_Js/* JsConnectionPointType.OBJECT_3D */.zF.OBJECT_3D, connections_Js/* JsConnectionPointType.OBJECT_3D */.zF.OBJECT_3D, SetPhysicsRBDCapsuleProperty_CONNECTION_OPTIONS)
    ]);
  }
  setLines(linesController) {
    (0,_BaseObject3D/* setObject3DOutputLine */.PV)(this, linesController);
  }
  setTriggerableLines(shadersCollectionController) {
    const object3D = (0,_BaseObject3D/* inputObject3D */.iv)(this, shadersCollectionController);
    const scale = this.variableForInputParam(shadersCollectionController, this.p.scale);
    const lerp = this.variableForInputParam(shadersCollectionController, this.p.lerp);
    const updateMatrix = this.variableForInputParam(shadersCollectionController, this.p.updateMatrix);
    const func = Poly/* Poly.namedFunctionsRegister.getFunction */.L.namedFunctionsRegister.getFunction(
      "setPhysicsRBDCapsuleProperty",
      this,
      shadersCollectionController
    );
    const bodyLine = func.asString(object3D, scale, lerp, updateMatrix);
    shadersCollectionController.addTriggerableLines(this, [bodyLine]);
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/js/SetPhysicsRBDConeProperty.ts







const SetPhysicsRBDConeProperty_CONNECTION_OPTIONS = connections_Js/* JS_CONNECTION_POINT_IN_NODE_DEF */.mX;
class SetPhysicsRBDConePropertyJsParamsConfig extends params_ParamsConfig/* NodeParamsConfig */.yI {
  constructor() {
    super(...arguments);
    /** @param target radius */
    this.radius = params_ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(1);
    /** @param target height */
    this.height = params_ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(1);
    /** @param lerp factor */
    this.lerp = params_ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(1);
    /** @param sets if the matrix should be updated as the animation progresses */
    this.updateMatrix = params_ParamsConfig/* ParamConfig.BOOLEAN */.XC.BOOLEAN(1);
  }
}
const SetPhysicsRBDConeProperty_ParamsConfig = new SetPhysicsRBDConePropertyJsParamsConfig();
class SetPhysicsRBDConePropertyJsNode extends js_Base/* TypedJsNode */.xZ {
  constructor() {
    super(...arguments);
    this.paramsConfig = SetPhysicsRBDConeProperty_ParamsConfig;
  }
  static type() {
    return "setPhysicsRBDConeProperty";
  }
  initializeNode() {
    this.io.inputs.setNamedInputConnectionPoints([
      new connections_Js/* JsConnectionPoint */.fp(js_Base/* TRIGGER_CONNECTION_NAME */.w6, connections_Js/* JsConnectionPointType.TRIGGER */.zF.TRIGGER, SetPhysicsRBDConeProperty_CONNECTION_OPTIONS),
      new connections_Js/* JsConnectionPoint */.fp(connections_Js/* JsConnectionPointType.OBJECT_3D */.zF.OBJECT_3D, connections_Js/* JsConnectionPointType.OBJECT_3D */.zF.OBJECT_3D, SetPhysicsRBDConeProperty_CONNECTION_OPTIONS)
    ]);
    this.io.outputs.setNamedOutputConnectionPoints([
      new connections_Js/* JsConnectionPoint */.fp(js_Base/* TRIGGER_CONNECTION_NAME */.w6, connections_Js/* JsConnectionPointType.TRIGGER */.zF.TRIGGER),
      new connections_Js/* JsConnectionPoint */.fp(connections_Js/* JsConnectionPointType.OBJECT_3D */.zF.OBJECT_3D, connections_Js/* JsConnectionPointType.OBJECT_3D */.zF.OBJECT_3D, SetPhysicsRBDConeProperty_CONNECTION_OPTIONS)
    ]);
  }
  setLines(linesController) {
    (0,_BaseObject3D/* setObject3DOutputLine */.PV)(this, linesController);
  }
  setTriggerableLines(shadersCollectionController) {
    const object3D = (0,_BaseObject3D/* inputObject3D */.iv)(this, shadersCollectionController);
    const radius = this.variableForInputParam(shadersCollectionController, this.p.radius);
    const height = this.variableForInputParam(shadersCollectionController, this.p.height);
    const lerp = this.variableForInputParam(shadersCollectionController, this.p.lerp);
    const updateMatrix = this.variableForInputParam(shadersCollectionController, this.p.updateMatrix);
    const func = Poly/* Poly.namedFunctionsRegister.getFunction */.L.namedFunctionsRegister.getFunction(
      "setPhysicsRBDConeProperty",
      this,
      shadersCollectionController
    );
    const bodyLine = func.asString(object3D, radius, height, lerp, updateMatrix);
    shadersCollectionController.addTriggerableLines(this, [bodyLine]);
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/js/SetPhysicsRBDCylinderProperty.ts







const SetPhysicsRBDCylinderProperty_CONNECTION_OPTIONS = connections_Js/* JS_CONNECTION_POINT_IN_NODE_DEF */.mX;
class SetPhysicsRBDCylinderPropertyJsParamsConfig extends params_ParamsConfig/* NodeParamsConfig */.yI {
  constructor() {
    super(...arguments);
    /** @param target radius */
    this.radius = params_ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(1);
    /** @param target height */
    this.height = params_ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(1);
    /** @param lerp factor */
    this.lerp = params_ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(1);
    /** @param sets if the matrix should be updated as the animation progresses */
    this.updateMatrix = params_ParamsConfig/* ParamConfig.BOOLEAN */.XC.BOOLEAN(1);
  }
}
const SetPhysicsRBDCylinderProperty_ParamsConfig = new SetPhysicsRBDCylinderPropertyJsParamsConfig();
class SetPhysicsRBDCylinderPropertyJsNode extends js_Base/* TypedJsNode */.xZ {
  constructor() {
    super(...arguments);
    this.paramsConfig = SetPhysicsRBDCylinderProperty_ParamsConfig;
  }
  static type() {
    return "setPhysicsRBDCylinderProperty";
  }
  initializeNode() {
    this.io.inputs.setNamedInputConnectionPoints([
      new connections_Js/* JsConnectionPoint */.fp(js_Base/* TRIGGER_CONNECTION_NAME */.w6, connections_Js/* JsConnectionPointType.TRIGGER */.zF.TRIGGER, SetPhysicsRBDCylinderProperty_CONNECTION_OPTIONS),
      new connections_Js/* JsConnectionPoint */.fp(connections_Js/* JsConnectionPointType.OBJECT_3D */.zF.OBJECT_3D, connections_Js/* JsConnectionPointType.OBJECT_3D */.zF.OBJECT_3D, SetPhysicsRBDCylinderProperty_CONNECTION_OPTIONS)
    ]);
    this.io.outputs.setNamedOutputConnectionPoints([
      new connections_Js/* JsConnectionPoint */.fp(js_Base/* TRIGGER_CONNECTION_NAME */.w6, connections_Js/* JsConnectionPointType.TRIGGER */.zF.TRIGGER),
      new connections_Js/* JsConnectionPoint */.fp(connections_Js/* JsConnectionPointType.OBJECT_3D */.zF.OBJECT_3D, connections_Js/* JsConnectionPointType.OBJECT_3D */.zF.OBJECT_3D, SetPhysicsRBDCylinderProperty_CONNECTION_OPTIONS)
    ]);
  }
  setLines(linesController) {
    (0,_BaseObject3D/* setObject3DOutputLine */.PV)(this, linesController);
  }
  setTriggerableLines(shadersCollectionController) {
    const object3D = (0,_BaseObject3D/* inputObject3D */.iv)(this, shadersCollectionController);
    const radius = this.variableForInputParam(shadersCollectionController, this.p.radius);
    const height = this.variableForInputParam(shadersCollectionController, this.p.height);
    const lerp = this.variableForInputParam(shadersCollectionController, this.p.lerp);
    const updateMatrix = this.variableForInputParam(shadersCollectionController, this.p.updateMatrix);
    const func = Poly/* Poly.namedFunctionsRegister.getFunction */.L.namedFunctionsRegister.getFunction(
      "setPhysicsRBDCylinderProperty",
      this,
      shadersCollectionController
    );
    const bodyLine = func.asString(object3D, radius, height, lerp, updateMatrix);
    shadersCollectionController.addTriggerableLines(this, [bodyLine]);
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/js/SetPhysicsRBDCuboidProperty.ts







const SetPhysicsRBDCuboidProperty_CONNECTION_OPTIONS = connections_Js/* JS_CONNECTION_POINT_IN_NODE_DEF */.mX;
class SetPhysicsRBDCuboidPropertyJsParamsConfig extends params_ParamsConfig/* NodeParamsConfig */.yI {
  constructor() {
    super(...arguments);
    /** @param target sizes */
    this.sizes = params_ParamsConfig/* ParamConfig.VECTOR3 */.XC.VECTOR3([1, 1, 1]);
    /** @param target size */
    this.size = params_ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(1);
    /** @param lerp factor */
    this.lerp = params_ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(1);
    /** @param sets if the matrix should be updated as the animation progresses */
    this.updateMatrix = params_ParamsConfig/* ParamConfig.BOOLEAN */.XC.BOOLEAN(1);
  }
}
const SetPhysicsRBDCuboidProperty_ParamsConfig = new SetPhysicsRBDCuboidPropertyJsParamsConfig();
class SetPhysicsRBDCuboidPropertyJsNode extends js_Base/* TypedJsNode */.xZ {
  constructor() {
    super(...arguments);
    this.paramsConfig = SetPhysicsRBDCuboidProperty_ParamsConfig;
  }
  static type() {
    return "setPhysicsRBDCuboidProperty";
  }
  initializeNode() {
    this.io.inputs.setNamedInputConnectionPoints([
      new connections_Js/* JsConnectionPoint */.fp(js_Base/* TRIGGER_CONNECTION_NAME */.w6, connections_Js/* JsConnectionPointType.TRIGGER */.zF.TRIGGER, SetPhysicsRBDCuboidProperty_CONNECTION_OPTIONS),
      new connections_Js/* JsConnectionPoint */.fp(connections_Js/* JsConnectionPointType.OBJECT_3D */.zF.OBJECT_3D, connections_Js/* JsConnectionPointType.OBJECT_3D */.zF.OBJECT_3D, SetPhysicsRBDCuboidProperty_CONNECTION_OPTIONS)
    ]);
    this.io.outputs.setNamedOutputConnectionPoints([
      new connections_Js/* JsConnectionPoint */.fp(js_Base/* TRIGGER_CONNECTION_NAME */.w6, connections_Js/* JsConnectionPointType.TRIGGER */.zF.TRIGGER),
      new connections_Js/* JsConnectionPoint */.fp(connections_Js/* JsConnectionPointType.OBJECT_3D */.zF.OBJECT_3D, connections_Js/* JsConnectionPointType.OBJECT_3D */.zF.OBJECT_3D, SetPhysicsRBDCuboidProperty_CONNECTION_OPTIONS)
    ]);
  }
  setLines(linesController) {
    (0,_BaseObject3D/* setObject3DOutputLine */.PV)(this, linesController);
  }
  setTriggerableLines(shadersCollectionController) {
    const object3D = (0,_BaseObject3D/* inputObject3D */.iv)(this, shadersCollectionController);
    const sizes = this.variableForInputParam(shadersCollectionController, this.p.sizes);
    const size = this.variableForInputParam(shadersCollectionController, this.p.size);
    const lerp = this.variableForInputParam(shadersCollectionController, this.p.lerp);
    const updateMatrix = this.variableForInputParam(shadersCollectionController, this.p.updateMatrix);
    const func = Poly/* Poly.namedFunctionsRegister.getFunction */.L.namedFunctionsRegister.getFunction(
      "setPhysicsRBDCuboidProperty",
      this,
      shadersCollectionController
    );
    const bodyLine = func.asString(object3D, sizes, size, lerp, updateMatrix);
    shadersCollectionController.addTriggerableLines(this, [bodyLine]);
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/js/SetPhysicsRBDSphereProperty.ts







const SetPhysicsRBDSphereProperty_CONNECTION_OPTIONS = connections_Js/* JS_CONNECTION_POINT_IN_NODE_DEF */.mX;
class SetPhysicsRBDSpherePropertyJsParamsConfig extends params_ParamsConfig/* NodeParamsConfig */.yI {
  constructor() {
    super(...arguments);
    /** @param target radois */
    this.radius = params_ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(1);
    /** @param lerp factor */
    this.lerp = params_ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(1);
    /** @param sets if the matrix should be updated as the animation progresses */
    this.updateMatrix = params_ParamsConfig/* ParamConfig.BOOLEAN */.XC.BOOLEAN(1);
  }
}
const SetPhysicsRBDSphereProperty_ParamsConfig = new SetPhysicsRBDSpherePropertyJsParamsConfig();
class SetPhysicsRBDSpherePropertyJsNode extends js_Base/* TypedJsNode */.xZ {
  constructor() {
    super(...arguments);
    this.paramsConfig = SetPhysicsRBDSphereProperty_ParamsConfig;
  }
  static type() {
    return "setPhysicsRBDSphereProperty";
  }
  initializeNode() {
    this.io.inputs.setNamedInputConnectionPoints([
      new connections_Js/* JsConnectionPoint */.fp(js_Base/* TRIGGER_CONNECTION_NAME */.w6, connections_Js/* JsConnectionPointType.TRIGGER */.zF.TRIGGER, SetPhysicsRBDSphereProperty_CONNECTION_OPTIONS),
      new connections_Js/* JsConnectionPoint */.fp(connections_Js/* JsConnectionPointType.OBJECT_3D */.zF.OBJECT_3D, connections_Js/* JsConnectionPointType.OBJECT_3D */.zF.OBJECT_3D, SetPhysicsRBDSphereProperty_CONNECTION_OPTIONS)
    ]);
    this.io.outputs.setNamedOutputConnectionPoints([
      new connections_Js/* JsConnectionPoint */.fp(js_Base/* TRIGGER_CONNECTION_NAME */.w6, connections_Js/* JsConnectionPointType.TRIGGER */.zF.TRIGGER),
      new connections_Js/* JsConnectionPoint */.fp(connections_Js/* JsConnectionPointType.OBJECT_3D */.zF.OBJECT_3D, connections_Js/* JsConnectionPointType.OBJECT_3D */.zF.OBJECT_3D, SetPhysicsRBDSphereProperty_CONNECTION_OPTIONS)
    ]);
  }
  setLines(linesController) {
    (0,_BaseObject3D/* setObject3DOutputLine */.PV)(this, linesController);
  }
  setTriggerableLines(shadersCollectionController) {
    const object3D = (0,_BaseObject3D/* inputObject3D */.iv)(this, shadersCollectionController);
    const radius = this.variableForInputParam(shadersCollectionController, this.p.radius);
    const lerp = this.variableForInputParam(shadersCollectionController, this.p.lerp);
    const updateMatrix = this.variableForInputParam(shadersCollectionController, this.p.updateMatrix);
    const func = Poly/* Poly.namedFunctionsRegister.getFunction */.L.namedFunctionsRegister.getFunction(
      "setPhysicsRBDSphereProperty",
      this,
      shadersCollectionController
    );
    const bodyLine = func.asString(object3D, radius, lerp, updateMatrix);
    shadersCollectionController.addTriggerableLines(this, [bodyLine]);
  }
}

// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/core/physics/PhysicsWorld.ts
var PhysicsWorld = __webpack_require__(3338);
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/js/SetPhysicsWorldGravity.ts








const SetPhysicsWorldGravity_CONNECTION_OPTIONS = connections_Js/* JS_CONNECTION_POINT_IN_NODE_DEF */.mX;
class SetPhysicsWorldGravityJsParamsConfig extends params_ParamsConfig/* NodeParamsConfig */.yI {
  constructor() {
    super(...arguments);
    this.gravity = params_ParamsConfig/* ParamConfig.VECTOR3 */.XC.VECTOR3(PhysicsWorld/* PHYSICS_GRAVITY_DEFAULT */.tB);
    this.lerp = params_ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(1, {
      range: [0, 1],
      rangeLocked: [true, true]
    });
  }
}
const SetPhysicsWorldGravity_ParamsConfig = new SetPhysicsWorldGravityJsParamsConfig();
class SetPhysicsWorldGravityJsNode extends js_Base/* TypedJsNode */.xZ {
  constructor() {
    super(...arguments);
    this.paramsConfig = SetPhysicsWorldGravity_ParamsConfig;
  }
  static type() {
    return "setPhysicsWorldGravity";
  }
  initializeNode() {
    this.io.inputs.setNamedInputConnectionPoints([
      new connections_Js/* JsConnectionPoint */.fp(js_Base/* TRIGGER_CONNECTION_NAME */.w6, connections_Js/* JsConnectionPointType.TRIGGER */.zF.TRIGGER, SetPhysicsWorldGravity_CONNECTION_OPTIONS),
      new connections_Js/* JsConnectionPoint */.fp(connections_Js/* JsConnectionPointType.OBJECT_3D */.zF.OBJECT_3D, connections_Js/* JsConnectionPointType.OBJECT_3D */.zF.OBJECT_3D, SetPhysicsWorldGravity_CONNECTION_OPTIONS)
    ]);
    this.io.outputs.setNamedOutputConnectionPoints([
      new connections_Js/* JsConnectionPoint */.fp(js_Base/* TRIGGER_CONNECTION_NAME */.w6, connections_Js/* JsConnectionPointType.TRIGGER */.zF.TRIGGER),
      new connections_Js/* JsConnectionPoint */.fp(connections_Js/* JsConnectionPointType.OBJECT_3D */.zF.OBJECT_3D, connections_Js/* JsConnectionPointType.OBJECT_3D */.zF.OBJECT_3D, SetPhysicsWorldGravity_CONNECTION_OPTIONS)
    ]);
  }
  setLines(linesController) {
    (0,_BaseObject3D/* setObject3DOutputLine */.PV)(this, linesController);
  }
  setTriggerableLines(shadersCollectionController) {
    const object3D = (0,_BaseObject3D/* inputObject3D */.iv)(this, shadersCollectionController);
    const gravity = this.variableForInputParam(shadersCollectionController, this.p.gravity);
    const lerp = this.variableForInputParam(shadersCollectionController, this.p.lerp);
    const func = Poly/* Poly.namedFunctionsRegister.getFunction */.L.namedFunctionsRegister.getFunction(
      "setPhysicsWorldGravity",
      this,
      shadersCollectionController
    );
    const bodyLine = func.asString(object3D, gravity, lerp);
    shadersCollectionController.addTriggerableLines(this, [bodyLine]);
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/js/SetPlayerInput.ts








const SetPlayerInput_CONNECTION_OPTIONS = connections_Js/* JS_CONNECTION_POINT_IN_NODE_DEF */.mX;
class SetPlayerInputParamsConfig extends params_ParamsConfig/* NodeParamsConfig */.yI {
  constructor() {
    super(...arguments);
    /** @param stopEventsPropagation: even though this node can intercept keydown and keyup events, you may encounter situations where pressing spare or arrow keys would trigger a page scroll. This node currently does not handle those situation, and it is recommended to manually intercept those and call event.stopImmediatePropagation() and event.stopPropagation() on keypress events */
    this.stopEventsPropagation = params_ParamsConfig/* ParamConfig.BOOLEAN */.XC.BOOLEAN(1);
  }
}
const SetPlayerInput_ParamsConfig = new SetPlayerInputParamsConfig();
class SetPlayerInputJsNode extends js_Base/* TypedJsNode */.xZ {
  constructor() {
    super(...arguments);
    this.paramsConfig = SetPlayerInput_ParamsConfig;
  }
  static type() {
    return Js/* JsType.SET_PLAYER_INPUT */.K.SET_PLAYER_INPUT;
  }
  initializeNode() {
    super.initializeNode();
    this.io.inputs.setNamedInputConnectionPoints([
      new connections_Js/* JsConnectionPoint */.fp(connections_Js/* JsConnectionPointType.TRIGGER */.zF.TRIGGER, connections_Js/* JsConnectionPointType.TRIGGER */.zF.TRIGGER, SetPlayerInput_CONNECTION_OPTIONS)
      // new JsConnectionPoint(JsConnectionPointType.OBJECT_3D, JsConnectionPointType.OBJECT_3D, CONNECTION_OPTIONS),
    ]);
    this.io.outputs.setNamedOutputConnectionPoints([
      // new JsConnectionPoint(TRIGGER_CONNECTION_NAME, JsConnectionPointType.TRIGGER),
      ...PlayerCommon/* CORE_PLAYER_INPUTS.map */.o.map(
        (inputName) => new connections_Js/* JsConnectionPoint */.fp(inputName, connections_Js/* JsConnectionPointType.BOOLEAN */.zF.BOOLEAN, SetPlayerInput_CONNECTION_OPTIONS)
      )
    ]);
  }
  // override wrappedBodyLines(
  // 	shadersCollectionController: ShadersCollectionController,
  // 	bodyLines: string[],
  // 	existingMethodNames: Set<string>
  // ) {
  // 	const object3D = inputObject3D(this, shadersCollectionController);
  // 	// const keyCodes = this.variableForInputParam(shadersCollectionController, this.p.keyCodes);
  // 	// const ctrlKey = this.variableForInputParam(shadersCollectionController, this.p.ctrlKey);
  // 	// const altKey = this.variableForInputParam(shadersCollectionController, this.p.altKey);
  // 	// const shiftKey = this.variableForInputParam(shadersCollectionController, this.p.shiftKey);
  // 	// const metaKey = this.variableForInputParam(shadersCollectionController, this.p.metaKey);
  // 	// const options: SetPlayerInputOptionsString = {
  // 	// 	stopPropagation: this.variableForInputParam(shadersCollectionController, this.p.stopPropagation),
  // 	// 	useWASDkeys: this.variableForInputParam(shadersCollectionController, this.p.useWASDkeys),
  // 	// 	useArrowkeys: this.variableForInputParam(shadersCollectionController, this.p.useArrowkeys),
  // 	// };
  // 	const optionsStr = JSON.stringify(options);
  // 	const func = Poly.namedFunctionsRegister.getFunction('setPlayerInput', this, shadersCollectionController);
  // 	const bodyLine = func.asString(object3D, optionsStr);
  // 	const methodName = this.type();
  // 	//
  // 	const wrappedLines: string = `${methodName}(){
  // 		${bodyLines.join('\n')}
  // 	}`;
  // 	return {methodNames: [methodName], wrappedLines};
  // }
  setTriggerableLines(shadersCollectionController) {
    const object3D = (0,_BaseObject3D/* inputObject3D */.iv)(this, shadersCollectionController);
    const stopEventsPropagation = this.variableForInputParam(
      shadersCollectionController,
      this.p.stopEventsPropagation
    );
    const func = Poly/* Poly.namedFunctionsRegister.getFunction */.L.namedFunctionsRegister.getFunction("setPlayerInput", this, shadersCollectionController);
    const bodyLine = func.asString(object3D, stopEventsPropagation);
    shadersCollectionController.addTriggerableLines(this, [bodyLine]);
  }
  setLines(shadersCollectionController) {
    const object3D = (0,_BaseObject3D/* inputObject3D */.iv)(this, shadersCollectionController);
    const usedOutputNames = this.io.outputs.used_output_names();
    const _b = (propertyName, functionName, type) => {
      if (!usedOutputNames.includes(propertyName)) {
        return;
      }
      const varName = this.jsVarName(propertyName);
      const func = Poly/* Poly.namedFunctionsRegister.getFunction */.L.namedFunctionsRegister.getFunction(functionName, this, shadersCollectionController);
      shadersCollectionController.addBodyOrComputed(this, [
        {
          dataType: type,
          varName,
          value: func.asString(object3D)
        }
      ]);
    };
    _b(PlayerCommon/* CorePlayerInput.LEFT */.Z.LEFT, "getPlayerInputDataLeft", connections_Js/* JsConnectionPointType.BOOLEAN */.zF.BOOLEAN);
    _b(PlayerCommon/* CorePlayerInput.RIGHT */.Z.RIGHT, "getPlayerInputDataRight", connections_Js/* JsConnectionPointType.BOOLEAN */.zF.BOOLEAN);
    _b(PlayerCommon/* CorePlayerInput.FORWARD */.Z.FORWARD, "getPlayerInputDataForward", connections_Js/* JsConnectionPointType.BOOLEAN */.zF.BOOLEAN);
    _b(PlayerCommon/* CorePlayerInput.BACKWARD */.Z.BACKWARD, "getPlayerInputDataBackward", connections_Js/* JsConnectionPointType.BOOLEAN */.zF.BOOLEAN);
    _b(PlayerCommon/* CorePlayerInput.JUMP */.Z.JUMP, "getPlayerInputDataJump", connections_Js/* JsConnectionPointType.BOOLEAN */.zF.BOOLEAN);
    _b(PlayerCommon/* CorePlayerInput.RUN */.Z.RUN, "getPlayerInputDataRun", connections_Js/* JsConnectionPointType.BOOLEAN */.zF.BOOLEAN);
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/js/SetPointPosition.ts







const SetPointPosition_CONNECTION_OPTIONS = connections_Js/* JS_CONNECTION_POINT_IN_NODE_DEF */.mX;
class SetPointPositionJsParamsConfig extends params_ParamsConfig/* NodeParamsConfig */.yI {
  constructor() {
    super(...arguments);
    /** @param point index */
    this.ptnum = params_ParamsConfig/* ParamConfig.INTEGER */.XC.INTEGER(0);
    /** @param target position */
    this.position = params_ParamsConfig/* ParamConfig.VECTOR3 */.XC.VECTOR3([0, 0, 0]);
    /** @param lerp factor */
    this.lerp = params_ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(1);
  }
}
const SetPointPosition_ParamsConfig = new SetPointPositionJsParamsConfig();
class SetPointPositionJsNode extends _BaseTriggerAndObject/* BaseTriggerAndObjectJsNode */.e {
  constructor() {
    super(...arguments);
    this.paramsConfig = SetPointPosition_ParamsConfig;
  }
  static type() {
    return Js/* JsType.SET_POINT_POSITION */.K.SET_POINT_POSITION;
  }
  _additionalOutputs() {
    return [
      new connections_Js/* JsConnectionPoint */.fp("ptnum", connections_Js/* JsConnectionPointType.INT */.zF.INT, SetPointPosition_CONNECTION_OPTIONS),
      new connections_Js/* JsConnectionPoint */.fp("position", connections_Js/* JsConnectionPointType.VECTOR3 */.zF.VECTOR3, SetPointPosition_CONNECTION_OPTIONS),
      new connections_Js/* JsConnectionPoint */.fp("lerp", connections_Js/* JsConnectionPointType.FLOAT */.zF.FLOAT, SetPointPosition_CONNECTION_OPTIONS)
    ];
  }
  setLines(linesController) {
    super.setLines(linesController);
    (0,_BaseObject3D/* integerOutputFromParam */.rq)(this, this.p.ptnum, linesController);
    (0,_BaseObject3D/* vector3OutputFromParam */.uM)(this, this.p.position, linesController);
    (0,_BaseObject3D/* floatOutputFromParam */.q3)(this, this.p.lerp, linesController);
  }
  setTriggerableLines(linesController) {
    const object3D = (0,_BaseObject3D/* inputObject3D */.iv)(this, linesController);
    const ptnum = (0,_BaseObject3D/* inputPointIndex */.m7)(this, linesController);
    const position = this.variableForInputParam(linesController, this.p.position);
    const lerp = this.variableForInputParam(linesController, this.p.lerp);
    const func = Poly/* Poly.namedFunctionsRegister.getFunction */.L.namedFunctionsRegister.getFunction("setPointPosition", this, linesController);
    const bodyLine = func.asString(object3D, ptnum, position, lerp);
    linesController.addTriggerableLines(this, [bodyLine]);
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/js/SetSoftBodyPosition.ts







const SetSoftBodyPosition_CONNECTION_OPTIONS = connections_Js/* JS_CONNECTION_POINT_IN_NODE_DEF */.mX;
class SetSoftBodyPositionJsParamsConfig extends params_ParamsConfig/* NodeParamsConfig */.yI {
  constructor() {
    super(...arguments);
    /** @param target position */
    this.position = params_ParamsConfig/* ParamConfig.VECTOR3 */.XC.VECTOR3([0, 0, 0]);
    /** @param lerp factor */
    this.lerp = params_ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(1);
  }
}
const SetSoftBodyPosition_ParamsConfig = new SetSoftBodyPositionJsParamsConfig();
class SetSoftBodyPositionJsNode extends _BaseTriggerAndObject/* BaseTriggerAndObjectJsNode */.e {
  constructor() {
    super(...arguments);
    this.paramsConfig = SetSoftBodyPosition_ParamsConfig;
  }
  static type() {
    return Js/* JsType.SET_SOFT_BODY_POSITION */.K.SET_SOFT_BODY_POSITION;
  }
  _additionalOutputs() {
    return [
      new connections_Js/* JsConnectionPoint */.fp("position", connections_Js/* JsConnectionPointType.VECTOR3 */.zF.VECTOR3, SetSoftBodyPosition_CONNECTION_OPTIONS),
      new connections_Js/* JsConnectionPoint */.fp("lerp", connections_Js/* JsConnectionPointType.FLOAT */.zF.FLOAT, SetSoftBodyPosition_CONNECTION_OPTIONS)
    ];
  }
  setLines(linesController) {
    super.setLines(linesController);
    (0,_BaseObject3D/* vector3OutputFromParam */.uM)(this, this.p.position, linesController);
    (0,_BaseObject3D/* floatOutputFromParam */.q3)(this, this.p.lerp, linesController);
  }
  setTriggerableLines(shadersCollectionController) {
    const object3D = (0,_BaseObject3D/* inputObject3D */.iv)(this, shadersCollectionController);
    const position = this.variableForInputParam(shadersCollectionController, this.p.position);
    const lerp = this.variableForInputParam(shadersCollectionController, this.p.lerp);
    const func = Poly/* Poly.namedFunctionsRegister.getFunction */.L.namedFunctionsRegister.getFunction("softBodySetPosition", this, shadersCollectionController);
    const bodyLine = func.asString(object3D, position, lerp);
    shadersCollectionController.addTriggerableLines(this, [bodyLine]);
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/js/SetSoftBodyVelocity.ts







const SetSoftBodyVelocity_CONNECTION_OPTIONS = connections_Js/* JS_CONNECTION_POINT_IN_NODE_DEF */.mX;
class SetSoftBodyVelocityJsParamsConfig extends params_ParamsConfig/* NodeParamsConfig */.yI {
  constructor() {
    super(...arguments);
    /** @param multiplier */
    this.mult = params_ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(1);
  }
}
const SetSoftBodyVelocity_ParamsConfig = new SetSoftBodyVelocityJsParamsConfig();
class SetSoftBodyVelocityJsNode extends _BaseTriggerAndObject/* BaseTriggerAndObjectJsNode */.e {
  constructor() {
    super(...arguments);
    this.paramsConfig = SetSoftBodyVelocity_ParamsConfig;
  }
  static type() {
    return Js/* JsType.SET_SOFT_BODY_VELOCITY */.K.SET_SOFT_BODY_VELOCITY;
  }
  _additionalOutputs() {
    return [new connections_Js/* JsConnectionPoint */.fp("mult", connections_Js/* JsConnectionPointType.FLOAT */.zF.FLOAT, SetSoftBodyVelocity_CONNECTION_OPTIONS)];
  }
  setLines(linesController) {
    super.setLines(linesController);
    (0,_BaseObject3D/* floatOutputFromParam */.q3)(this, this.p.mult, linesController);
  }
  setTriggerableLines(shadersCollectionController) {
    const object3D = (0,_BaseObject3D/* inputObject3D */.iv)(this, shadersCollectionController);
    const mult = this.variableForInputParam(shadersCollectionController, this.p.mult);
    const func = Poly/* Poly.namedFunctionsRegister.getFunction */.L.namedFunctionsRegister.getFunction(
      "softBodyMultiplyVelocity",
      this,
      shadersCollectionController
    );
    const bodyLine = func.asString(object3D, mult);
    shadersCollectionController.addTriggerableLines(this, [bodyLine]);
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/js/SetSoftBodyConstraintPosition.ts






class SetSoftBodyConstraintPositionJsParamsConfig extends params_ParamsConfig/* NodeParamsConfig */.yI {
  constructor() {
    super(...arguments);
    this.id = params_ParamsConfig/* ParamConfig.INTEGER */.XC.INTEGER(0, {
      range: [-1, 100],
      rangeLocked: [true, false]
    });
    this.position = params_ParamsConfig/* ParamConfig.VECTOR3 */.XC.VECTOR3([0, 0, 0]);
    this.lerp = params_ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(1, {
      range: [0, 1],
      rangeLocked: [true, true]
    });
  }
}
const SetSoftBodyConstraintPosition_ParamsConfig = new SetSoftBodyConstraintPositionJsParamsConfig();
class SetSoftBodyConstraintPositionJsNode extends _BaseTriggerAndObject/* BaseTriggerAndObjectJsNode */.e {
  constructor() {
    super(...arguments);
    this.paramsConfig = SetSoftBodyConstraintPosition_ParamsConfig;
  }
  static type() {
    return Js/* JsType.SET_SOFT_BODY_CONSTRAINT_POSITION */.K.SET_SOFT_BODY_CONSTRAINT_POSITION;
  }
  setTriggerableLines(shadersCollectionController) {
    const object3D = (0,_BaseObject3D/* inputObject3D */.iv)(this, shadersCollectionController);
    const id = this.variableForInputParam(shadersCollectionController, this.p.id);
    const position = this.variableForInputParam(shadersCollectionController, this.p.position);
    const lerp = this.variableForInputParam(shadersCollectionController, this.p.lerp);
    const func = Poly/* Poly.namedFunctionsRegister.getFunction */.L.namedFunctionsRegister.getFunction(
      "softBodyConstraintSetPosition",
      this,
      shadersCollectionController
    );
    const bodyLine = func.asString(object3D, id, position, lerp);
    shadersCollectionController.addTriggerableLines(this, [bodyLine]);
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/js/SetSpotLightIntensity.ts






const SetSpotLightIntensity_CONNECTION_OPTIONS = connections_Js/* JS_CONNECTION_POINT_IN_NODE_DEF */.mX;
class SetSpotLightIntensityJsParamsConfig extends params_ParamsConfig/* NodeParamsConfig */.yI {
  constructor() {
    super(...arguments);
    /** @param intensity */
    this.intensity = params_ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(1);
    /** @param lerp factor */
    this.lerp = params_ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(1);
  }
}
const SetSpotLightIntensity_ParamsConfig = new SetSpotLightIntensityJsParamsConfig();
class SetSpotLightIntensityJsNode extends js_Base/* TypedJsNode */.xZ {
  constructor() {
    super(...arguments);
    this.paramsConfig = SetSpotLightIntensity_ParamsConfig;
  }
  static type() {
    return "setSpotLightIntensity";
  }
  initializeNode() {
    this.io.inputs.setNamedInputConnectionPoints([
      new connections_Js/* JsConnectionPoint */.fp(js_Base/* TRIGGER_CONNECTION_NAME */.w6, connections_Js/* JsConnectionPointType.TRIGGER */.zF.TRIGGER, SetSpotLightIntensity_CONNECTION_OPTIONS),
      new connections_Js/* JsConnectionPoint */.fp(connections_Js/* JsConnectionPointType.OBJECT_3D */.zF.OBJECT_3D, connections_Js/* JsConnectionPointType.OBJECT_3D */.zF.OBJECT_3D, SetSpotLightIntensity_CONNECTION_OPTIONS)
    ]);
    this.io.outputs.setNamedOutputConnectionPoints([
      new connections_Js/* JsConnectionPoint */.fp(js_Base/* TRIGGER_CONNECTION_NAME */.w6, connections_Js/* JsConnectionPointType.TRIGGER */.zF.TRIGGER),
      new connections_Js/* JsConnectionPoint */.fp(connections_Js/* JsConnectionPointType.OBJECT_3D */.zF.OBJECT_3D, connections_Js/* JsConnectionPointType.OBJECT_3D */.zF.OBJECT_3D, SetSpotLightIntensity_CONNECTION_OPTIONS)
    ]);
  }
  setLines(linesController) {
    (0,_BaseObject3D/* setObject3DOutputLine */.PV)(this, linesController);
  }
  setTriggerableLines(shadersCollectionController) {
    const object3D = (0,_BaseObject3D/* inputObject3D */.iv)(this, shadersCollectionController);
    const intensity = this.variableForInputParam(shadersCollectionController, this.p.intensity);
    const lerp = this.variableForInputParam(shadersCollectionController, this.p.lerp);
    const func = Poly/* Poly.namedFunctionsRegister.getFunction */.L.namedFunctionsRegister.getFunction(
      "setSpotLightIntensity",
      this,
      shadersCollectionController
    );
    const bodyLine = func.asString(object3D, intensity, lerp);
    shadersCollectionController.addTriggerableLines(this, [bodyLine]);
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/js/SetViewer.ts





const SetViewer_CONNECTION_OPTIONS = connections_Js/* JS_CONNECTION_POINT_IN_NODE_DEF */.mX;
class SetViewerJsParamsConfig extends params_ParamsConfig/* NodeParamsConfig */.yI {
  constructor() {
    super(...arguments);
    /** @param sets the class of the viewer */
    this.className = params_ParamsConfig/* ParamConfig.STRING */.XC.STRING("active");
    /** @param set or unset */
    this.set = params_ParamsConfig/* ParamConfig.BOOLEAN */.XC.BOOLEAN(1);
  }
}
const SetViewer_ParamsConfig = new SetViewerJsParamsConfig();
class SetViewerJsNode extends js_Base/* TypedJsNode */.xZ {
  constructor() {
    super(...arguments);
    this.paramsConfig = SetViewer_ParamsConfig;
  }
  static type() {
    return "setViewer";
  }
  initializeNode() {
    this.io.inputs.setNamedInputConnectionPoints([
      new connections_Js/* JsConnectionPoint */.fp(js_Base/* TRIGGER_CONNECTION_NAME */.w6, connections_Js/* JsConnectionPointType.TRIGGER */.zF.TRIGGER, SetViewer_CONNECTION_OPTIONS)
    ]);
    this.io.outputs.setNamedOutputConnectionPoints([
      new connections_Js/* JsConnectionPoint */.fp(js_Base/* TRIGGER_CONNECTION_NAME */.w6, connections_Js/* JsConnectionPointType.TRIGGER */.zF.TRIGGER)
    ]);
  }
  setTriggerableLines(shadersCollectionController) {
    const className = this.variableForInputParam(shadersCollectionController, this.p.className);
    const set = this.variableForInputParam(shadersCollectionController, this.p.set);
    const func = Poly/* Poly.namedFunctionsRegister.getFunction */.L.namedFunctionsRegister.getFunction("setViewer", this, shadersCollectionController);
    const bodyLine = func.asString(className, set);
    shadersCollectionController.addTriggerableLines(this, [bodyLine]);
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/js/SetViewerControls.ts





const SetViewerControls_CONNECTION_OPTIONS = connections_Js/* JS_CONNECTION_POINT_IN_NODE_DEF */.mX;
class SetViewerControlsJsParamsConfig extends params_ParamsConfig/* NodeParamsConfig */.yI {
  constructor() {
    super(...arguments);
    /** @param set or unset */
    this.active = params_ParamsConfig/* ParamConfig.BOOLEAN */.XC.BOOLEAN(1);
    /** @param updateTarget */
    this.updateTarget = params_ParamsConfig/* ParamConfig.BOOLEAN */.XC.BOOLEAN(0);
    /** @param target */
    this.target = params_ParamsConfig/* ParamConfig.VECTOR3 */.XC.VECTOR3([0, 0, 0], {
      visibleIf: { updateTarget: 1 }
    });
  }
}
const SetViewerControls_ParamsConfig = new SetViewerControlsJsParamsConfig();
class SetViewerControlsJsNode extends js_Base/* TypedJsNode */.xZ {
  constructor() {
    super(...arguments);
    this.paramsConfig = SetViewerControls_ParamsConfig;
  }
  static type() {
    return "setViewerControls";
  }
  initializeNode() {
    this.io.inputs.setNamedInputConnectionPoints([
      new connections_Js/* JsConnectionPoint */.fp(js_Base/* TRIGGER_CONNECTION_NAME */.w6, connections_Js/* JsConnectionPointType.TRIGGER */.zF.TRIGGER, SetViewerControls_CONNECTION_OPTIONS)
    ]);
    this.io.outputs.setNamedOutputConnectionPoints([
      new connections_Js/* JsConnectionPoint */.fp(js_Base/* TRIGGER_CONNECTION_NAME */.w6, connections_Js/* JsConnectionPointType.TRIGGER */.zF.TRIGGER)
    ]);
  }
  setTriggerableLines(shadersCollectionController) {
    const active = this.variableForInputParam(shadersCollectionController, this.p.active);
    const updateTarget = this.variableForInputParam(shadersCollectionController, this.p.updateTarget);
    const target = this.variableForInputParam(shadersCollectionController, this.p.target);
    const func = Poly/* Poly.namedFunctionsRegister.getFunction */.L.namedFunctionsRegister.getFunction("setViewerControls", this, shadersCollectionController);
    const bodyLine = func.asString(active, updateTarget, target);
    shadersCollectionController.addTriggerableLines(this, [bodyLine]);
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/js/Sign.ts


class SignJsNode extends MathFunctionArg1OperationFactory("sign", {
  inputPrefix: "val",
  out: "sign"
}) {
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/js/Sin.ts


class SinJsNode extends MathFunctionArg1OperationFactory("sin", {
  inputPrefix: "angle",
  out: "sin"
}) {
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/js/Smoothstep.ts




var SmoothstepInput = /* @__PURE__ */ ((SmoothstepInput2) => {
  SmoothstepInput2["X"] = "x";
  SmoothstepInput2["EDGE0"] = "edge0";
  SmoothstepInput2["EDGE1"] = "edge1";
  return SmoothstepInput2;
})(SmoothstepInput || {});
const Smoothstep_DefaultValues = {
  ["x" /* X */]: 0,
  ["edge0" /* EDGE0 */]: 0,
  ["edge1" /* EDGE1 */]: 1
};
const Smoothstep_FUNCTION_NAME = "smoothstep";
class SmoothstepJsNode extends MathFunctionArg3OperationFactory("smoothstep", {
  inputPrefix: "in",
  out: "smoothstep"
}) {
  _coreFunction(shadersCollectionController) {
    const mainArg = "x";
    const _min = this.variableForInput(shadersCollectionController, "edge0" /* EDGE0 */);
    const _max = this.variableForInput(shadersCollectionController, "edge1" /* EDGE1 */);
    Poly/* Poly.namedFunctionsRegister.getFunction */.L.namedFunctionsRegister.getFunction(Smoothstep_FUNCTION_NAME, this, shadersCollectionController).asString(mainArg, _min, _max);
    return Smoothstep_FUNCTION_NAME;
  }
  paramDefaultValue(name) {
    return Smoothstep_DefaultValues[name];
  }
  _expectedInputName(index) {
    return ["x" /* X */, "edge0" /* EDGE0 */, "edge1" /* EDGE1 */][index];
  }
  _expectedInputTypes() {
    let first_input_type = this.io.connection_points.first_input_connection_type();
    if (first_input_type) {
      if (!DEFAULT_ALLOWED_TYPES.includes(first_input_type)) {
        const connectionPoints = this.io.inputs.namedInputConnectionPoints();
        if (connectionPoints) {
          const first_connection = connectionPoints[0];
          if (first_connection) {
            first_input_type = first_connection.type();
          }
        }
      }
    }
    const type = first_input_type || connections_Js/* JsConnectionPointType.FLOAT */.zF.FLOAT;
    const boundType = connections_Js/* JsConnectionPointTypeFromArrayTypeMap */.RR[type];
    return [type, boundType, boundType];
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/js/Smootherstep.ts




var SmootherstepInput = /* @__PURE__ */ ((SmootherstepInput2) => {
  SmootherstepInput2["X"] = "x";
  SmootherstepInput2["EDGE0"] = "edge0";
  SmootherstepInput2["EDGE1"] = "edge1";
  return SmootherstepInput2;
})(SmootherstepInput || {});
const Smootherstep_DefaultValues = {
  ["x" /* X */]: 0,
  ["edge0" /* EDGE0 */]: 0,
  ["edge1" /* EDGE1 */]: 1
};
const Smootherstep_FUNCTION_NAME = "smootherstep";
class SmootherstepJsNode extends MathFunctionArg3OperationFactory("smootherstep", {
  inputPrefix: "in",
  out: "smootherstep"
}) {
  _coreFunction(shadersCollectionController) {
    const mainArg = "x";
    const _min = this.variableForInput(shadersCollectionController, "edge0" /* EDGE0 */);
    const _max = this.variableForInput(shadersCollectionController, "edge1" /* EDGE1 */);
    Poly/* Poly.namedFunctionsRegister.getFunction */.L.namedFunctionsRegister.getFunction(Smootherstep_FUNCTION_NAME, this, shadersCollectionController).asString(mainArg, _min, _max);
    return Smootherstep_FUNCTION_NAME;
  }
  paramDefaultValue(name) {
    return Smootherstep_DefaultValues[name];
  }
  _expectedInputName(index) {
    return ["x" /* X */, "edge0" /* EDGE0 */, "edge1" /* EDGE1 */][index];
  }
  _expectedInputTypes() {
    let first_input_type = this.io.connection_points.first_input_connection_type();
    const inputConnectionPoints = this.io.inputs.namedInputConnectionPoints();
    if (!inputConnectionPoints) {
      return [];
    }
    if (first_input_type) {
      if (!DEFAULT_ALLOWED_TYPES.includes(first_input_type)) {
        const first_connection = inputConnectionPoints[0];
        if (first_connection) {
          first_input_type = first_connection.type();
        }
      }
    }
    const type = first_input_type || connections_Js/* JsConnectionPointType.FLOAT */.zF.FLOAT;
    const boundType = connections_Js/* JsConnectionPointTypeFromArrayTypeMap */.RR[type];
    return [type, boundType, boundType];
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/js/SoftBodySolverStepSimulation.ts






const SoftBodySolverStepSimulation_CONNECTION_OPTIONS = connections_Js/* JS_CONNECTION_POINT_IN_NODE_DEF */.mX;
class SoftBodySolverStepSimulationJsParamsConfig extends params_ParamsConfig/* NodeParamsConfig */.yI {
  constructor() {
    super(...arguments);
    this.stepsCount = params_ParamsConfig/* ParamConfig.INTEGER */.XC.INTEGER(10, {
      range: [1, 100],
      rangeLocked: [true, false]
    });
    /** @param edgeCompliance */
    this.edgeCompliance = params_ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(0, {
      range: [0, 100],
      rangeLocked: [true, false]
    });
    /** @param volumeCompliance */
    this.volumeCompliance = params_ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(0, {
      range: [0, 1],
      rangeLocked: [true, false]
    });
    /** @param preciseCollisions */
    this.preciseCollisions = params_ParamsConfig/* ParamConfig.BOOLEAN */.XC.BOOLEAN(0);
  }
}
const SoftBodySolverStepSimulation_ParamsConfig = new SoftBodySolverStepSimulationJsParamsConfig();
class SoftBodySolverStepSimulationJsNode extends js_Base/* TypedJsNode */.xZ {
  constructor() {
    super(...arguments);
    this.paramsConfig = SoftBodySolverStepSimulation_ParamsConfig;
  }
  static type() {
    return "softBodySolverStepSimulation";
  }
  initializeNode() {
    this.io.inputs.setNamedInputConnectionPoints([
      new connections_Js/* JsConnectionPoint */.fp(js_Base/* TRIGGER_CONNECTION_NAME */.w6, connections_Js/* JsConnectionPointType.TRIGGER */.zF.TRIGGER, SoftBodySolverStepSimulation_CONNECTION_OPTIONS),
      new connections_Js/* JsConnectionPoint */.fp(connections_Js/* JsConnectionPointType.OBJECT_3D */.zF.OBJECT_3D, connections_Js/* JsConnectionPointType.OBJECT_3D */.zF.OBJECT_3D, SoftBodySolverStepSimulation_CONNECTION_OPTIONS)
    ]);
    this.io.outputs.setNamedOutputConnectionPoints([
      new connections_Js/* JsConnectionPoint */.fp(js_Base/* TRIGGER_CONNECTION_NAME */.w6, connections_Js/* JsConnectionPointType.TRIGGER */.zF.TRIGGER),
      new connections_Js/* JsConnectionPoint */.fp(connections_Js/* JsConnectionPointType.OBJECT_3D */.zF.OBJECT_3D, connections_Js/* JsConnectionPointType.OBJECT_3D */.zF.OBJECT_3D)
    ]);
  }
  setLines(linesController) {
    (0,_BaseObject3D/* setObject3DOutputLine */.PV)(this, linesController);
  }
  setTriggerableLines(linesController) {
    const object3D = (0,_BaseObject3D/* inputObject3D */.iv)(this, linesController);
    const stepsCount = this.variableForInputParam(linesController, this.p.stepsCount);
    const edgeCompliance = this.variableForInputParam(linesController, this.p.edgeCompliance);
    const volumeCompliance = this.variableForInputParam(linesController, this.p.volumeCompliance);
    const preciseCollisions = this.variableForInputParam(linesController, this.p.preciseCollisions);
    const func = Poly/* Poly.namedFunctionsRegister.getFunction */.L.namedFunctionsRegister.getFunction("softBodySolverStepSimulation", this, linesController);
    const bodyLine = func.asString(object3D, stepsCount, edgeCompliance, volumeCompliance, preciseCollisions);
    linesController.addTriggerableLines(this, [bodyLine]);
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/js/Sphere.ts






const Sphere_CONNECTION_OPTIONS = connections_Js/* JS_CONNECTION_POINT_IN_NODE_DEF */.mX;
class SphereJsParamsConfig extends params_ParamsConfig/* NodeParamsConfig */.yI {
  constructor() {
    super(...arguments);
    /** @param sphere center */
    this.center = params_ParamsConfig/* ParamConfig.VECTOR3 */.XC.VECTOR3([0, 0, 0]);
    /** @param sphere radius */
    this.radius = params_ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(1, {
      range: [0, 10],
      rangeLocked: [true, false]
    });
  }
}
const js_Sphere_ParamsConfig = new SphereJsParamsConfig();
class SphereJsNode extends js_Base/* TypedJsNode */.xZ {
  constructor() {
    super(...arguments);
    this.paramsConfig = js_Sphere_ParamsConfig;
  }
  static type() {
    return "sphere";
  }
  initializeNode() {
    super.initializeNode();
    this.io.outputs.setNamedOutputConnectionPoints([
      new connections_Js/* JsConnectionPoint */.fp(connections_Js/* JsConnectionPointType.SPHERE */.zF.SPHERE, connections_Js/* JsConnectionPointType.SPHERE */.zF.SPHERE, Sphere_CONNECTION_OPTIONS)
    ]);
  }
  setLines(shadersCollectionController) {
    const center = this.variableForInputParam(shadersCollectionController, this.p.center);
    const radius = this.variableForInputParam(shadersCollectionController, this.p.radius);
    const out = this.jsVarName(connections_Js/* JsConnectionPointType.SPHERE */.zF.SPHERE);
    const tmpVarName = shadersCollectionController.addVariable(this, new three_module.Sphere());
    const func = Poly/* Poly.namedFunctionsRegister.getFunction */.L.namedFunctionsRegister.getFunction("sphereSet", this, shadersCollectionController);
    const bodyLine = func.asString(center, radius, tmpVarName);
    shadersCollectionController.addBodyOrComputed(this, [
      { dataType: connections_Js/* JsConnectionPointType.SPHERE */.zF.SPHERE, varName: out, value: bodyLine }
    ]);
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/js/Sqrt.ts


class SqrtJsNode extends MathFunctionArg1OperationFactory("sqrt", {
  inputPrefix: "val",
  out: "sqrt"
}) {
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/js/SubnetInput.ts




class SubnetInputJsParamsConfig extends params_ParamsConfig/* NodeParamsConfig */.yI {
}
const js_SubnetInput_ParamsConfig = new SubnetInputJsParamsConfig();
class SubnetInputJsNode extends js_Base/* TypedJsNode */.xZ {
  constructor() {
    super(...arguments);
    this.paramsConfig = js_SubnetInput_ParamsConfig;
  }
  static type() {
    return poly_NodeContext/* NetworkChildNodeType.INPUT */.G$.INPUT;
  }
  initializeNode() {
    this.io.connection_points.set_output_name_function(this._expectedOutputNames.bind(this));
    this.io.connection_points.set_expected_input_types_function(() => []);
    this.io.connection_points.set_expected_output_types_function(this.expectedOutputTypes.bind(this));
  }
  parent() {
    return super.parent();
  }
  _expectedOutputNames(index) {
    const parent = this.parent();
    return (parent == null ? void 0 : parent.childExpectedInputConnectionPointName(index)) || `out${index}`;
  }
  expectedOutputTypes() {
    const parent = this.parent();
    return (parent == null ? void 0 : parent.childExpectedInputConnectionPointTypes()) || [];
  }
  setLines(shadersCollectionController) {
    const parent = this.parent();
    parent == null ? void 0 : parent.setSubnetInputLines(shadersCollectionController, this);
  }
  // public override outputValue(context: JsNodeTriggerContext, outputName: string) {
  // 	return this.parent()?.inputValueForSubnetInput(context, outputName);
  // }
}

// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/nodes/js/SubnetOutput.ts
var js_SubnetOutput = __webpack_require__(24171);
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/js/Subtract.ts


class SubtractJsNode extends MathFunctionArgNOperationFactory("subtract", {
  inputPrefix: "sub",
  out: "sub",
  operator: {
    primitive: "subtractNumber",
    vector: "subtractVector",
    vectorScalar: "subtractVectorNumber"
  }
}) {
}

// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/core/ThreeToJs.ts
var ThreeToJs = __webpack_require__(14753);
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/js/Switch.ts




const INPUT_TYPES_ALLOWING_NON_CONNECTED_INPUT = /* @__PURE__ */ new Set([
  connections_Js/* JsConnectionPointType.BOOLEAN */.zF.BOOLEAN,
  connections_Js/* JsConnectionPointType.COLOR */.zF.COLOR,
  connections_Js/* JsConnectionPointType.INT */.zF.INT,
  connections_Js/* JsConnectionPointType.STRING */.zF.STRING,
  connections_Js/* JsConnectionPointType.VECTOR2 */.zF.VECTOR2,
  connections_Js/* JsConnectionPointType.VECTOR3 */.zF.VECTOR3,
  connections_Js/* JsConnectionPointType.VECTOR4 */.zF.VECTOR4
]);
const _SwitchJsNode = class extends js_Base/* ParamlessTypedJsNode */.au {
  static type() {
    return "switch";
  }
  initializeNode() {
    super.initializeNode();
    this.io.connection_points.initializeNode();
    this.io.connection_points.set_expected_input_types_function(this._expectedInputTypes.bind(this));
    this.io.connection_points.set_expected_output_types_function(this._expectedOutputTypes.bind(this));
    this.io.connection_points.set_input_name_function(this._expectedInputName.bind(this));
    this.io.connection_points.set_output_name_function(this._expectedOutputName.bind(this));
  }
  _expectedInputName(index) {
    if (index == 0) {
      return _SwitchJsNode.INPUT_INDEX_NAME;
    } else {
      return `in${index - 1}`;
    }
  }
  _expectedOutputName() {
    return _SwitchJsNode.OUTPUT_NAME;
  }
  _expectedInputTypes() {
    const secondInputType = this.io.connection_points.input_connection_type(1);
    const type = secondInputType || connections_Js/* JsConnectionPointType.FLOAT */.zF.FLOAT;
    const currentConnections = this.io.connections.inputConnections() || [];
    let lastValidConnectionIndex = 1;
    let i = 0;
    for (const connection of currentConnections) {
      if (connection) {
        lastValidConnectionIndex = i;
      }
      i++;
    }
    const expectedCount = Math.max(lastValidConnectionIndex + 1, 2);
    const expectedInputTypes = [connections_Js/* JsConnectionPointType.INT */.zF.INT];
    for (let i2 = 0; i2 < expectedCount; i2++) {
      expectedInputTypes.push(type);
    }
    return expectedInputTypes;
  }
  _expectedOutputTypes() {
    const inputTypes = this._expectedInputTypes();
    const type = inputTypes[1] || connections_Js/* JsConnectionPointType.FLOAT */.zF.FLOAT;
    return [type];
  }
  setLines(shadersCollectionController) {
    const inputIndex = ThreeToJs/* ThreeToJs.integer */.m.integer(
      this.variableForInput(shadersCollectionController, _SwitchJsNode.INPUT_INDEX_NAME)
    );
    const inputTypes = this._expectedInputTypes();
    const inputValuesCount = this._expectedInputTypes().length - 1;
    const inputArgs = [];
    for (let i = 0; i <= inputValuesCount; i++) {
      const inputIndex2 = i + 1;
      const inputType = inputTypes[inputIndex2];
      if (this.io.connections.inputConnection(inputIndex2) || INPUT_TYPES_ALLOWING_NON_CONNECTED_INPUT.has(inputType)) {
        const inputArg = ThreeToJs/* ThreeToJs.valueWrap */.m.valueWrap(
          this.variableForInput(shadersCollectionController, this._expectedInputName(inputIndex2))
        );
        inputArgs.push(inputArg);
      }
    }
    const arrayElement = `[${inputArgs.join(", ")}][${inputIndex}]`;
    const value = shadersCollectionController.assembler().computedVariablesAllowed() ? `${arrayElement}.value` : arrayElement;
    const varName = this.jsVarName(_SwitchJsNode.OUTPUT_NAME);
    const dataType = this._expectedOutputTypes()[0];
    shadersCollectionController.addBodyOrComputed(this, [{ dataType, varName, value }]);
  }
};
let SwitchJsNode = _SwitchJsNode;
SwitchJsNode.INPUT_INDEX_NAME = "index";
SwitchJsNode.OUTPUT_NAME = "val";

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/js/Tan.ts


class TanJsNode extends MathFunctionArg1OperationFactory("tan", {
  inputPrefix: "angle",
  out: "tan"
}) {
}

// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/nodes/js/TrackFace.ts
var TrackFace = __webpack_require__(7396);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/nodes/js/TrackHand.ts
var TrackHand = __webpack_require__(11500);
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/js/TriggerDelay.ts





const TriggerDelay_CONNECTION_OPTIONS = connections_Js/* JS_CONNECTION_POINT_IN_NODE_DEF */.mX;
class TriggerDelayJsParamsConfig extends params_ParamsConfig/* NodeParamsConfig */.yI {
  constructor() {
    super(...arguments);
    /** @param delay (in milliseconds) */
    this.delay = params_ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(1e3, {
      range: [0, 1e4],
      rangeLocked: [true, false]
    });
  }
}
const TriggerDelay_ParamsConfig = new TriggerDelayJsParamsConfig();
class TriggerDelayJsNode extends js_Base/* TypedJsNode */.xZ {
  constructor() {
    super(...arguments);
    this.paramsConfig = TriggerDelay_ParamsConfig;
  }
  static type() {
    return "triggerDelay";
  }
  initializeNode() {
    this.io.inputs.setNamedInputConnectionPoints([
      new connections_Js/* JsConnectionPoint */.fp(js_Base/* TRIGGER_CONNECTION_NAME */.w6, connections_Js/* JsConnectionPointType.TRIGGER */.zF.TRIGGER, TriggerDelay_CONNECTION_OPTIONS)
    ]);
    this.io.outputs.setNamedOutputConnectionPoints([
      new connections_Js/* JsConnectionPoint */.fp(js_Base/* TRIGGER_CONNECTION_NAME */.w6, connections_Js/* JsConnectionPointType.TRIGGER */.zF.TRIGGER)
    ]);
  }
  setTriggerableLines(shadersCollectionController) {
    const delay = this.variableForInputParam(shadersCollectionController, this.p.delay);
    const func = Poly/* Poly.namedFunctionsRegister.getFunction */.L.namedFunctionsRegister.getFunction("sleep", this, shadersCollectionController);
    const bodyLine = func.asString(delay);
    shadersCollectionController.addTriggerableLines(this, [bodyLine], { async: true });
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/js/TriggerFilter.ts





const TriggerFilter_CONNECTION_OPTIONS = connections_Js/* JS_CONNECTION_POINT_IN_NODE_DEF */.mX;
class TriggerFilterJsParamsConfig extends params_ParamsConfig/* NodeParamsConfig */.yI {
  constructor() {
    super(...arguments);
    /** @param If true, the trigger will be forwarded. If false, it will not be. */
    this.condition = params_ParamsConfig/* ParamConfig.BOOLEAN */.XC.BOOLEAN(1);
  }
}
const TriggerFilter_ParamsConfig = new TriggerFilterJsParamsConfig();
class TriggerFilterJsNode extends js_Base/* TypedJsNode */.xZ {
  constructor() {
    super(...arguments);
    this.paramsConfig = TriggerFilter_ParamsConfig;
  }
  static type() {
    return "triggerFilter";
  }
  initializeNode() {
    this.io.inputs.setNamedInputConnectionPoints([
      new connections_Js/* JsConnectionPoint */.fp(js_Base/* TRIGGER_CONNECTION_NAME */.w6, connections_Js/* JsConnectionPointType.TRIGGER */.zF.TRIGGER, TriggerFilter_CONNECTION_OPTIONS)
    ]);
    this.io.outputs.setNamedOutputConnectionPoints([
      new connections_Js/* JsConnectionPoint */.fp(js_Base/* TRIGGER_CONNECTION_NAME */.w6, connections_Js/* JsConnectionPointType.TRIGGER */.zF.TRIGGER)
    ]);
  }
  setTriggerableLines(shadersCollectionController) {
    const condition = this.variableForInputParam(shadersCollectionController, this.p.condition);
    const func = Poly/* Poly.namedFunctionsRegister.getFunction */.L.namedFunctionsRegister.getFunction("triggerFilter", this, shadersCollectionController);
    const bodyLine = func.asString(condition);
    shadersCollectionController.addTriggerableLines(this, [bodyLine]);
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/js/TriggerSwitch.ts







const TriggerSwitch_CONNECTION_OPTIONS = connections_Js/* JS_CONNECTION_POINT_IN_NODE_DEF */.mX;
class TriggerSwitchJsParamsConfig extends params_ParamsConfig/* NodeParamsConfig */.yI {
  constructor() {
    super(...arguments);
    /** @param triggersCount */
    this.triggersCount = params_ParamsConfig/* ParamConfig.INTEGER */.XC.INTEGER(4, {
      range: [1, 10],
      rangeLocked: [true, false]
    });
    /** @param defines which trigger will be dispatched */
    this.index = params_ParamsConfig/* ParamConfig.INTEGER */.XC.INTEGER(0, {
      range: [0, 10],
      rangeLocked: [true, false]
    });
  }
}
const TriggerSwitch_ParamsConfig = new TriggerSwitchJsParamsConfig();
class TriggerSwitchJsNode extends js_Base/* TypedJsNode */.xZ {
  constructor() {
    super(...arguments);
    this.paramsConfig = TriggerSwitch_ParamsConfig;
  }
  static type() {
    return "triggerSwitch";
  }
  initializeNode() {
    super.initializeNode();
    this.io.inputs.setNamedInputConnectionPoints([
      new connections_Js/* JsConnectionPoint */.fp(connections_Js/* JsConnectionPointType.TRIGGER */.zF.TRIGGER, connections_Js/* JsConnectionPointType.TRIGGER */.zF.TRIGGER, TriggerSwitch_CONNECTION_OPTIONS),
      new connections_Js/* JsConnectionPoint */.fp("index", connections_Js/* JsConnectionPointType.INT */.zF.INT, TriggerSwitch_CONNECTION_OPTIONS)
    ]);
    this.io.connection_points.set_output_name_function(this._expectedOutputNames.bind(this));
    this.io.connection_points.set_expected_input_types_function(() => []);
    this.io.connection_points.set_expected_output_types_function(this._expectedOutputTypes.bind(this));
  }
  _expectedOutputNames(index) {
    return `${connections_Js/* JsConnectionPointType.TRIGGER */.zF.TRIGGER}${index}`;
  }
  _expectedOutputTypes() {
    const array = new Array(this.pv.triggersCount).fill(connections_Js/* JsConnectionPointType.TRIGGER */.zF.TRIGGER);
    return array;
  }
  setTriggerableLines(shadersCollectionController) {
    const index = this.variableForInputParam(shadersCollectionController, this.p.index);
    const methodNames = this._expectedOutputTypes().map((_, i) => TriggerSwitch_triggerMethod(this, this._expectedOutputNames(i))).join(",");
    const func = Poly/* Poly.namedFunctionsRegister.getFunction */.L.namedFunctionsRegister.getFunction("triggerSwitch", this, shadersCollectionController);
    const bodyLine = func.asString(index, `[${methodNames}]`);
    shadersCollectionController.addTriggerableLines(this, [bodyLine], { addTriggeredLines: false });
  }
}
function TriggerSwitch_triggerMethod(node, outputName) {
  const outputIndex = (0,ActorAssemblerUtils/* getOutputIndices */.D0)(node, (c) => c.name() == outputName)[0];
  const triggerableNodes = /* @__PURE__ */ new Set();
  (0,ActorAssemblerUtils/* getConnectedOutputNodes */.YZ)({
    node,
    triggerOutputIndices: [outputIndex],
    triggerableNodes,
    recursive: false
  });
  const triggerableMethodNames = (0,SetUtils/* setToArray */.T_)(triggerableNodes, []).map((triggerableNode) => {
    const argIndex = (0,ActorAssemblerUtils/* triggerInputIndex */.D6)(node, triggerableNode);
    const m = (0,ActorAssemblerUtils/* nodeMethodName */.Bp)(triggerableNode);
    return `this.${m}(${argIndex})`;
  });
  return `()=>{ ${triggerableMethodNames.join(";")} }`;
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/js/TriggerTwoWaySwitch.ts







const TriggerTwoWaySwitch_CONNECTION_OPTIONS = connections_Js/* JS_CONNECTION_POINT_IN_NODE_DEF */.mX;
class TriggerTwoWaySwitchJsParamsConfig extends params_ParamsConfig/* NodeParamsConfig */.yI {
  constructor() {
    super(...arguments);
    /** @param if true, trigger will be forward through the 1st output. If false, it will be forwarded through the 2nd output. */
    this.condition = params_ParamsConfig/* ParamConfig.BOOLEAN */.XC.BOOLEAN(1);
  }
}
const TriggerTwoWaySwitch_ParamsConfig = new TriggerTwoWaySwitchJsParamsConfig();
const _TriggerTwoWaySwitchJsNode = class extends js_Base/* TypedJsNode */.xZ {
  constructor() {
    super(...arguments);
    this.paramsConfig = TriggerTwoWaySwitch_ParamsConfig;
  }
  static type() {
    return "triggerTwoWaySwitch";
  }
  initializeNode() {
    super.initializeNode();
    this.io.inputs.setNamedInputConnectionPoints([
      new connections_Js/* JsConnectionPoint */.fp(js_Base/* TRIGGER_CONNECTION_NAME */.w6, connections_Js/* JsConnectionPointType.TRIGGER */.zF.TRIGGER, TriggerTwoWaySwitch_CONNECTION_OPTIONS)
    ]);
    this.io.outputs.setNamedOutputConnectionPoints([
      new connections_Js/* JsConnectionPoint */.fp(
        _TriggerTwoWaySwitchJsNode.OUTPUT_NAME_IF_TRUE,
        connections_Js/* JsConnectionPointType.TRIGGER */.zF.TRIGGER,
        TriggerTwoWaySwitch_CONNECTION_OPTIONS
      ),
      new connections_Js/* JsConnectionPoint */.fp(
        _TriggerTwoWaySwitchJsNode.OUTPUT_NAME_IF_FALSE,
        connections_Js/* JsConnectionPointType.TRIGGER */.zF.TRIGGER,
        TriggerTwoWaySwitch_CONNECTION_OPTIONS
      )
    ]);
  }
  setTriggerableLines(shadersCollectionController) {
    const condition = this.variableForInputParam(shadersCollectionController, this.p.condition);
    const methodNamesIfTrue = TriggerTwoWaySwitch_triggerMethod(this, _TriggerTwoWaySwitchJsNode.OUTPUT_NAME_IF_TRUE);
    const methodNamesIfFalse = TriggerTwoWaySwitch_triggerMethod(this, _TriggerTwoWaySwitchJsNode.OUTPUT_NAME_IF_FALSE);
    const func = Poly/* Poly.namedFunctionsRegister.getFunction */.L.namedFunctionsRegister.getFunction("triggerTwoWaySwitch", this, shadersCollectionController);
    const bodyLine = func.asString(condition, methodNamesIfTrue, methodNamesIfFalse);
    shadersCollectionController.addTriggerableLines(this, [bodyLine], { addTriggeredLines: false });
  }
};
let TriggerTwoWaySwitchJsNode = _TriggerTwoWaySwitchJsNode;
TriggerTwoWaySwitchJsNode.OUTPUT_NAME_IF_TRUE = `${js_Base/* TRIGGER_CONNECTION_NAME */.w6}IfTrue`;
TriggerTwoWaySwitchJsNode.OUTPUT_NAME_IF_FALSE = `${js_Base/* TRIGGER_CONNECTION_NAME */.w6}IfFalse`;
function TriggerTwoWaySwitch_triggerMethod(node, outputName) {
  const outputIndex = (0,ActorAssemblerUtils/* getOutputIndices */.D0)(node, (c) => c.name() == outputName)[0];
  const triggerableNodes = /* @__PURE__ */ new Set();
  (0,ActorAssemblerUtils/* getConnectedOutputNodes */.YZ)({
    node,
    triggerOutputIndices: [outputIndex],
    triggerableNodes,
    recursive: false
  });
  const triggerableMethodNames = (0,SetUtils/* setToArray */.T_)(triggerableNodes, []).map((triggerableNode) => {
    const argIndex = (0,ActorAssemblerUtils/* triggerInputIndex */.D6)(node, triggerableNode);
    const m = (0,ActorAssemblerUtils/* nodeMethodName */.Bp)(triggerableNode);
    return `this.${m}(${argIndex})`;
  });
  return `()=>{ ${triggerableMethodNames.join(";")} }`;
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/js/TwoWaySwitch.ts



const js_TwoWaySwitch_OUTPUT_NAME = "val";
var TwoWaySwitchJsNodeInputName = /* @__PURE__ */ ((TwoWaySwitchJsNodeInputName2) => {
  TwoWaySwitchJsNodeInputName2["CONDITION"] = "condition";
  TwoWaySwitchJsNodeInputName2["IF_TRUE"] = "ifTrue";
  TwoWaySwitchJsNodeInputName2["IF_FALSE"] = "ifFalse";
  return TwoWaySwitchJsNodeInputName2;
})(TwoWaySwitchJsNodeInputName || {});
const js_TwoWaySwitch_InputNames = [
  "condition" /* CONDITION */,
  "ifTrue" /* IF_TRUE */,
  "ifFalse" /* IF_FALSE */
];
class TwoWaySwitchJsNode extends js_Base/* ParamlessTypedJsNode */.au {
  static type() {
    return "twoWaySwitch";
  }
  // public readonly gl_connections_controller: GlConnectionsController = new GlConnectionsController(this);
  initializeNode() {
    super.initializeNode();
    this.io.connection_points.initializeNode();
    this.io.connection_points.set_expected_input_types_function(this._expectedInputTypes.bind(this));
    this.io.connection_points.set_expected_output_types_function(this._expectedOutputTypes.bind(this));
    this.io.connection_points.set_input_name_function(this._expectedInputName.bind(this));
    this.io.connection_points.set_output_name_function(this._expectedOutputName.bind(this));
  }
  _expectedInputName(index) {
    return js_TwoWaySwitch_InputNames[index];
  }
  _expectedOutputName() {
    return js_TwoWaySwitch_OUTPUT_NAME;
  }
  _expectedInputTypes() {
    const second_or_third_connection = this.io.connections.inputConnection(1) || this.io.connections.inputConnection(2);
    const srcConnectionPoint = second_or_third_connection ? second_or_third_connection.srcConnectionPoint() : null;
    const type = (srcConnectionPoint == null ? void 0 : srcConnectionPoint.type()) || connections_Js/* JsConnectionPointType.FLOAT */.zF.FLOAT;
    return [connections_Js/* JsConnectionPointType.BOOLEAN */.zF.BOOLEAN, type, type];
  }
  _expectedOutputTypes() {
    const type = this._expectedInputTypes()[1];
    return [type];
  }
  setLines(shadersCollectionController) {
    const condition = this.variableForInput(shadersCollectionController, "condition" /* CONDITION */);
    const ifTrue = this.variableForInput(shadersCollectionController, "ifTrue" /* IF_TRUE */);
    const ifFalse = this.variableForInput(shadersCollectionController, "ifFalse" /* IF_FALSE */);
    const out = this.jsVarName(js_TwoWaySwitch_OUTPUT_NAME);
    const bodyLine = `${condition} ? ${ifTrue} : ${ifFalse}`;
    shadersCollectionController.addBodyOrComputed(this, [
      { dataType: connections_Js/* JsConnectionPointType.PLANE */.zF.PLANE, varName: out, value: bodyLine }
    ]);
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/js/Vector3AngleTo.ts





const Vector3AngleTo_OUTPUT_NAME = "radians";
class Vector3AngleToJsParamsConfig extends params_ParamsConfig/* NodeParamsConfig */.yI {
  constructor() {
    super(...arguments);
    /** @param vector 1 */
    this.v1 = params_ParamsConfig/* ParamConfig.VECTOR3 */.XC.VECTOR3([0, 0, 0]);
    /** @param vector 2 */
    this.v2 = params_ParamsConfig/* ParamConfig.VECTOR3 */.XC.VECTOR3([0, 0, 0]);
  }
}
const Vector3AngleTo_ParamsConfig = new Vector3AngleToJsParamsConfig();
class Vector3AngleToJsNode extends js_Base/* TypedJsNode */.xZ {
  constructor() {
    super(...arguments);
    this.paramsConfig = Vector3AngleTo_ParamsConfig;
  }
  static type() {
    return "vector3AngleTo";
  }
  initializeNode() {
    super.initializeNode();
    this.io.outputs.setNamedOutputConnectionPoints([
      new connections_Js/* JsConnectionPoint */.fp(Vector3AngleTo_OUTPUT_NAME, connections_Js/* JsConnectionPointType.FLOAT */.zF.FLOAT)
    ]);
  }
  setLines(shadersCollectionController) {
    const v1 = this.variableForInputParam(shadersCollectionController, this.p.v1);
    const v2 = this.variableForInputParam(shadersCollectionController, this.p.v2);
    const out = this.jsVarName(Vector3AngleTo_OUTPUT_NAME);
    const func = Poly/* Poly.namedFunctionsRegister.getFunction */.L.namedFunctionsRegister.getFunction("vector3AngleTo", this, shadersCollectionController);
    const bodyLine = func.asString(v1, v2);
    shadersCollectionController.addBodyOrComputed(this, [
      { dataType: connections_Js/* JsConnectionPointType.SPHERE */.zF.SPHERE, varName: out, value: bodyLine }
    ]);
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/js/Vector3Project.ts






const Vector3Project_CONNECTION_OPTIONS = connections_Js/* JS_CONNECTION_POINT_IN_NODE_DEF */.mX;
const Vector3Project_OUTPUT_NAME = "position";
class Vector3ProjectJsParamsConfig extends params_ParamsConfig/* NodeParamsConfig */.yI {
  constructor() {
    super(...arguments);
    /** @param vector3 */
    this.Vector3 = params_ParamsConfig/* ParamConfig.VECTOR3 */.XC.VECTOR3([0, 0, 0]);
  }
}
const Vector3Project_ParamsConfig = new Vector3ProjectJsParamsConfig();
class Vector3ProjectJsNode extends js_Base/* TypedJsNode */.xZ {
  constructor() {
    super(...arguments);
    this.paramsConfig = Vector3Project_ParamsConfig;
  }
  static type() {
    return "vector3Project";
  }
  initializeNode() {
    super.initializeNode();
    this.io.inputs.setNamedInputConnectionPoints([
      new connections_Js/* JsConnectionPoint */.fp(connections_Js/* JsConnectionPointType.VECTOR3 */.zF.VECTOR3, connections_Js/* JsConnectionPointType.VECTOR3 */.zF.VECTOR3, Vector3Project_CONNECTION_OPTIONS),
      new connections_Js/* JsConnectionPoint */.fp(connections_Js/* JsConnectionPointType.CAMERA */.zF.CAMERA, connections_Js/* JsConnectionPointType.CAMERA */.zF.CAMERA, Vector3Project_CONNECTION_OPTIONS)
    ]);
    this.io.outputs.setNamedOutputConnectionPoints([
      new connections_Js/* JsConnectionPoint */.fp(Vector3Project_OUTPUT_NAME, connections_Js/* JsConnectionPointType.VECTOR3 */.zF.VECTOR3)
    ]);
  }
  setLines(shadersCollectionController) {
    const vector3 = this.variableForInputParam(shadersCollectionController, this.p.Vector3);
    const camera = this.variableForInput(shadersCollectionController, connections_Js/* JsConnectionPointType.CAMERA */.zF.CAMERA);
    const out = this.jsVarName(Vector3Project_OUTPUT_NAME);
    const tmpVarName = shadersCollectionController.addVariable(this, new three_module.Vector3());
    const func = Poly/* Poly.namedFunctionsRegister.getFunction */.L.namedFunctionsRegister.getFunction("vector3Project", this, shadersCollectionController);
    const bodyLine = func.asString(vector3, camera, tmpVarName);
    shadersCollectionController.addBodyOrComputed(this, [
      { dataType: connections_Js/* JsConnectionPointType.VECTOR3 */.zF.VECTOR3, varName: out, value: bodyLine }
    ]);
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/js/Vector3ProjectOnPlane.ts






const Vector3ProjectOnPlane_OUTPUT_NAME = "position";
class Vector3ProjectOnPlaneJsParamsConfig extends params_ParamsConfig/* NodeParamsConfig */.yI {
  constructor() {
    super(...arguments);
    /** @param vector3 */
    this.Vector3 = params_ParamsConfig/* ParamConfig.VECTOR3 */.XC.VECTOR3([1, 0, 0]);
    /** @param planeNormal */
    this.planeNormal = params_ParamsConfig/* ParamConfig.VECTOR3 */.XC.VECTOR3([0, 1, 0]);
  }
}
const Vector3ProjectOnPlane_ParamsConfig = new Vector3ProjectOnPlaneJsParamsConfig();
class Vector3ProjectOnPlaneJsNode extends js_Base/* TypedJsNode */.xZ {
  constructor() {
    super(...arguments);
    this.paramsConfig = Vector3ProjectOnPlane_ParamsConfig;
  }
  static type() {
    return "vector3ProjectOnPlane";
  }
  initializeNode() {
    super.initializeNode();
    this.io.outputs.setNamedOutputConnectionPoints([
      new connections_Js/* JsConnectionPoint */.fp(Vector3ProjectOnPlane_OUTPUT_NAME, connections_Js/* JsConnectionPointType.VECTOR3 */.zF.VECTOR3)
    ]);
  }
  setLines(shadersCollectionController) {
    const vector3 = this.variableForInputParam(shadersCollectionController, this.p.Vector3);
    const planeNormal = this.variableForInputParam(shadersCollectionController, this.p.planeNormal);
    const out = this.jsVarName(Vector3ProjectOnPlane_OUTPUT_NAME);
    const tmpVarName = shadersCollectionController.addVariable(this, new three_module.Vector3());
    const func = Poly/* Poly.namedFunctionsRegister.getFunction */.L.namedFunctionsRegister.getFunction(
      "vector3ProjectOnPlane",
      this,
      shadersCollectionController
    );
    const bodyLine = func.asString(vector3, planeNormal, tmpVarName);
    shadersCollectionController.addBodyOrComputed(this, [
      { dataType: connections_Js/* JsConnectionPointType.VECTOR3 */.zF.VECTOR3, varName: out, value: bodyLine }
    ]);
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/js/Vector3Unproject.ts






const Vector3Unproject_CONNECTION_OPTIONS = connections_Js/* JS_CONNECTION_POINT_IN_NODE_DEF */.mX;
const Vector3Unproject_OUTPUT_NAME = "position";
class Vector3UnprojectJsParamsConfig extends params_ParamsConfig/* NodeParamsConfig */.yI {
  constructor() {
    super(...arguments);
    /** @param vector3 */
    this.Vector3 = params_ParamsConfig/* ParamConfig.VECTOR3 */.XC.VECTOR3([0, 0, 0]);
  }
}
const Vector3Unproject_ParamsConfig = new Vector3UnprojectJsParamsConfig();
class Vector3UnprojectJsNode extends js_Base/* TypedJsNode */.xZ {
  constructor() {
    super(...arguments);
    this.paramsConfig = Vector3Unproject_ParamsConfig;
  }
  static type() {
    return "vector3Unproject";
  }
  initializeNode() {
    super.initializeNode();
    this.io.inputs.setNamedInputConnectionPoints([
      new connections_Js/* JsConnectionPoint */.fp(connections_Js/* JsConnectionPointType.VECTOR3 */.zF.VECTOR3, connections_Js/* JsConnectionPointType.VECTOR3 */.zF.VECTOR3, Vector3Unproject_CONNECTION_OPTIONS),
      new connections_Js/* JsConnectionPoint */.fp(connections_Js/* JsConnectionPointType.CAMERA */.zF.CAMERA, connections_Js/* JsConnectionPointType.CAMERA */.zF.CAMERA, Vector3Unproject_CONNECTION_OPTIONS)
    ]);
    this.io.outputs.setNamedOutputConnectionPoints([
      new connections_Js/* JsConnectionPoint */.fp(Vector3Unproject_OUTPUT_NAME, connections_Js/* JsConnectionPointType.VECTOR3 */.zF.VECTOR3)
    ]);
  }
  setLines(shadersCollectionController) {
    const vector3 = this.variableForInputParam(shadersCollectionController, this.p.Vector3);
    const camera = this.variableForInput(shadersCollectionController, connections_Js/* JsConnectionPointType.CAMERA */.zF.CAMERA);
    const out = this.jsVarName(Vector3Unproject_OUTPUT_NAME);
    const tmpVarName = shadersCollectionController.addVariable(this, new three_module.Vector3());
    const func = Poly/* Poly.namedFunctionsRegister.getFunction */.L.namedFunctionsRegister.getFunction("vector3Unproject", this, shadersCollectionController);
    const bodyLine = func.asString(vector3, camera, tmpVarName);
    shadersCollectionController.addBodyOrComputed(this, [
      { dataType: connections_Js/* JsConnectionPointType.VECTOR3 */.zF.VECTOR3, varName: out, value: bodyLine }
    ]);
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/js/Vec4ToVec3.ts







const Vec4ToVec3_ALLOWED_TYPES = [connections_Js/* JsConnectionPointType.VECTOR4 */.zF.VECTOR4, connections_Js/* JsConnectionPointType.VECTOR4_ARRAY */.zF.VECTOR4_ARRAY];
var Vec4ToVec3_OutputName = /* @__PURE__ */ ((OutputName2) => {
  OutputName2["Vector3"] = "Vector3";
  OutputName2["w"] = "w";
  return OutputName2;
})(Vec4ToVec3_OutputName || {});
class Vec4ToVec3ParamsJsConfig extends params_ParamsConfig/* NodeParamsConfig */.yI {
  constructor() {
    super(...arguments);
    this.Vector4 = params_ParamsConfig/* ParamConfig.VECTOR4 */.XC.VECTOR4([0, 0, 0, 0]);
  }
}
const ParamsConfig_Vec4ToVec3 = new Vec4ToVec3ParamsJsConfig();
class Vec4ToVec3JsNode extends js_Base/* TypedJsNode */.xZ {
  constructor() {
    super(...arguments);
    this.paramsConfig = ParamsConfig_Vec4ToVec3;
  }
  static type() {
    return "vec4ToVec3";
  }
  // static readonly INPUT_NAME_VEC4 = 'vec4';
  // static readonly OUTPUT_NAME_VEC3 = 'vec3';
  // static readonly OUTPUT_NAME_W = 'w';
  initializeNode() {
    this.io.connection_points.set_input_name_function(this._expectedInputName.bind(this));
    this.io.connection_points.set_output_name_function(this._expectedOutputName.bind(this));
    this.io.connection_points.set_expected_input_types_function(this._expectedInputTypes.bind(this));
    this.io.connection_points.set_expected_output_types_function(this._expectedOutputTypes.bind(this));
  }
  _expectedInputName(index) {
    return this._expectedInputTypes()[0];
  }
  _expectedOutputName(index) {
    return ["Vector3" /* Vector3 */, "w" /* w */][index];
  }
  _expectedInputTypes() {
    const firstInputType = this.io.connection_points.first_input_connection_type();
    const type = firstInputType != null && Vec4ToVec3_ALLOWED_TYPES.includes(firstInputType) ? firstInputType : connections_Js/* JsConnectionPointType.VECTOR4 */.zF.VECTOR4;
    return [type];
  }
  _expectedOutputTypes() {
    const firstInputTypes = this._expectedInputTypes()[0];
    switch (firstInputTypes) {
      case connections_Js/* JsConnectionPointType.VECTOR4_ARRAY */.zF.VECTOR4_ARRAY: {
        return [connections_Js/* JsConnectionPointType.VECTOR3_ARRAY */.zF.VECTOR3_ARRAY, connections_Js/* JsConnectionPointType.FLOAT_ARRAY */.zF.FLOAT_ARRAY];
      }
      default: {
        return [connections_Js/* JsConnectionPointType.VECTOR3 */.zF.VECTOR3, connections_Js/* JsConnectionPointType.FLOAT */.zF.FLOAT];
      }
    }
  }
  setLines(shadersCollectionController) {
    const firstType = this._expectedInputTypes()[0];
    switch (firstType) {
      case connections_Js/* JsConnectionPointType.VECTOR4 */.zF.VECTOR4: {
        return this._setLinesAsVector4(shadersCollectionController);
      }
      case connections_Js/* JsConnectionPointType.VECTOR4_ARRAY */.zF.VECTOR4_ARRAY: {
        return this._setLinesAsVector4Array(shadersCollectionController);
      }
    }
  }
  _setLinesAsVector4(shadersCollectionController) {
    const usedOutputNames = this.io.outputs.used_output_names();
    const vec4 = this.variableForInput(shadersCollectionController, this._expectedInputName(0));
    const _v3 = (propertyName, functionName, type) => {
      if (!usedOutputNames.includes(propertyName)) {
        return;
      }
      const varName = this.jsVarName(propertyName);
      const tmpVarName = shadersCollectionController.addVariable(this, new three_module.Vector3());
      const func = Poly/* Poly.namedFunctionsRegister.getFunction */.L.namedFunctionsRegister.getFunction(functionName, this, shadersCollectionController);
      shadersCollectionController.addBodyOrComputed(this, [
        {
          dataType: type,
          varName,
          value: func.asString(vec4, tmpVarName)
        }
      ]);
    };
    const _f = (propertyName, type) => {
      if (!usedOutputNames.includes(propertyName)) {
        return;
      }
      shadersCollectionController.addBodyOrComputed(this, [
        {
          dataType: type,
          varName: this.jsVarName(propertyName),
          value: `${vec4}.w`
        }
      ]);
    };
    _v3("Vector3" /* Vector3 */, "sizzleVec4XYZ", connections_Js/* JsConnectionPointType.VECTOR3 */.zF.VECTOR3);
    _f("w" /* w */, connections_Js/* JsConnectionPointType.FLOAT */.zF.FLOAT);
  }
  _setLinesAsVector4Array(shadersCollectionController) {
    const usedOutputNames = this.io.outputs.used_output_names();
    const vec4 = this.variableForInput(shadersCollectionController, this._expectedInputName(0));
    const _v3 = (propertyName, functionName, type) => {
      if (!usedOutputNames.includes(propertyName)) {
        return;
      }
      const varName = this.jsVarName(propertyName);
      const tmpVarName = shadersCollectionController.addVariable(this, new _BaseJsPersistedConfigUtils/* VectorArray */.ex([new three_module.Vector3()]));
      const func = Poly/* Poly.namedFunctionsRegister.getFunction */.L.namedFunctionsRegister.getFunction(functionName, this, shadersCollectionController);
      shadersCollectionController.addBodyOrComputed(this, [
        {
          dataType: type,
          varName,
          value: func.asString(vec4, tmpVarName)
        }
      ]);
    };
    const _f = (propertyName, functionName, type) => {
      if (!usedOutputNames.includes(propertyName)) {
        return;
      }
      const varName = this.jsVarName(propertyName);
      const tmpVarName = shadersCollectionController.addVariable(this, new _BaseJsPersistedConfigUtils/* PrimitiveArray */.QP([0]));
      const func = Poly/* Poly.namedFunctionsRegister.getFunction */.L.namedFunctionsRegister.getFunction(functionName, this, shadersCollectionController);
      shadersCollectionController.addBodyOrComputed(this, [
        {
          dataType: type,
          varName,
          value: func.asString(vec4, tmpVarName)
        }
      ]);
    };
    _v3("Vector3" /* Vector3 */, "sizzleVec4XYZArray", connections_Js/* JsConnectionPointType.VECTOR3_ARRAY */.zF.VECTOR3_ARRAY);
    _f("w" /* w */, "sizzleVec4WArray", connections_Js/* JsConnectionPointType.FLOAT_ARRAY */.zF.FLOAT_ARRAY);
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/js/Vector2.ts




const Vector2_OUTPUT_NAME = connections_Js/* JsConnectionPointType.VECTOR3 */.zF.VECTOR3;
class Vector2JsParamsConfig extends params_ParamsConfig/* NodeParamsConfig */.yI {
  constructor() {
    super(...arguments);
    /** @param vector value */
    this.Vector2 = params_ParamsConfig/* ParamConfig.VECTOR2 */.XC.VECTOR2([0, 0]);
  }
}
const Vector2_ParamsConfig = new Vector2JsParamsConfig();
class Vector2JsNode extends js_Base/* TypedJsNode */.xZ {
  constructor() {
    super(...arguments);
    this.paramsConfig = Vector2_ParamsConfig;
  }
  static type() {
    return "vector2";
  }
  initializeNode() {
    super.initializeNode();
    this.io.outputs.setNamedOutputConnectionPoints([
      new connections_Js/* JsConnectionPoint */.fp(Vector2_OUTPUT_NAME, connections_Js/* JsConnectionPointType.VECTOR2 */.zF.VECTOR2)
    ]);
  }
  setLines(shadersCollectionController) {
    const inputValue = this.variableForInputParam(shadersCollectionController, this.p.Vector2);
    const varName = this.jsVarName(Vector2_OUTPUT_NAME);
    shadersCollectionController.addBodyOrComputed(this, [
      {
        dataType: connections_Js/* JsConnectionPointType.VECTOR2 */.zF.VECTOR2,
        varName,
        value: inputValue
      }
    ]);
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/js/Vector3.ts




const Vector3_OUTPUT_NAME = connections_Js/* JsConnectionPointType.VECTOR3 */.zF.VECTOR3;
class Vector3JsParamsConfig extends params_ParamsConfig/* NodeParamsConfig */.yI {
  constructor() {
    super(...arguments);
    /** @param vector value */
    this.Vector3 = params_ParamsConfig/* ParamConfig.VECTOR3 */.XC.VECTOR3([0, 0, 0]);
  }
}
const Vector3_ParamsConfig = new Vector3JsParamsConfig();
class Vector3JsNode extends js_Base/* TypedJsNode */.xZ {
  constructor() {
    super(...arguments);
    this.paramsConfig = Vector3_ParamsConfig;
  }
  static type() {
    return "vector3";
  }
  initializeNode() {
    super.initializeNode();
    this.io.outputs.setNamedOutputConnectionPoints([
      new connections_Js/* JsConnectionPoint */.fp(Vector3_OUTPUT_NAME, connections_Js/* JsConnectionPointType.VECTOR3 */.zF.VECTOR3)
    ]);
  }
  setLines(shadersCollectionController) {
    const inputValue = this.variableForInputParam(shadersCollectionController, this.p.Vector3);
    const varName = this.jsVarName(Vector3_OUTPUT_NAME);
    shadersCollectionController.addBodyOrComputed(this, [
      {
        dataType: connections_Js/* JsConnectionPointType.VECTOR3 */.zF.VECTOR3,
        varName,
        value: inputValue
      }
    ]);
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/js/Vector4.ts




const Vector4_OUTPUT_NAME = connections_Js/* JsConnectionPointType.VECTOR3 */.zF.VECTOR3;
class Vector4JsParamsConfig extends params_ParamsConfig/* NodeParamsConfig */.yI {
  constructor() {
    super(...arguments);
    /** @param vector value */
    this.Vector4 = params_ParamsConfig/* ParamConfig.VECTOR4 */.XC.VECTOR4([0, 0, 0, 0]);
  }
}
const Vector4_ParamsConfig = new Vector4JsParamsConfig();
class Vector4JsNode extends js_Base/* TypedJsNode */.xZ {
  constructor() {
    super(...arguments);
    this.paramsConfig = Vector4_ParamsConfig;
  }
  static type() {
    return "vector4";
  }
  initializeNode() {
    super.initializeNode();
    this.io.outputs.setNamedOutputConnectionPoints([
      new connections_Js/* JsConnectionPoint */.fp(Vector4_OUTPUT_NAME, connections_Js/* JsConnectionPointType.VECTOR4 */.zF.VECTOR4)
    ]);
  }
  setLines(shadersCollectionController) {
    const inputValue = this.variableForInputParam(shadersCollectionController, this.p.Vector4);
    const varName = this.jsVarName(Vector4_OUTPUT_NAME);
    shadersCollectionController.addBodyOrComputed(this, [
      {
        dataType: connections_Js/* JsConnectionPointType.VECTOR4 */.zF.VECTOR4,
        varName,
        value: inputValue
      }
    ]);
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/poly/registers/nodes/Js.ts




















































































































































































































































































































































































const sopType = (type) => `${poly_NodeContext/* NodeContext.SOP */.sy.SOP}/${type}`;
const jsType = (type) => `${poly_NodeContext/* NodeContext.JS */.sy.JS}/${type}`;
const JS_SUBNET_TYPE = jsType(poly_NodeContext/* NetworkNodeType.SUBNET */.kX.SUBNET);
const JS_FOR_LOOP_TYPE = jsType(Js/* JsType.FOR_LOOP */.K.FOR_LOOP);
const JS_SUBNET_TYPES = [JS_SUBNET_TYPE, JS_FOR_LOOP_TYPE];
const Js_SUBNET_CHILD_OPTION = {
  only: JS_SUBNET_TYPES
};
const ONLY_WITH_GLOBALS = {
  only: [
    sopType(Sop/* SopType.ENTITY_BUILDER */.aB.ENTITY_BUILDER),
    sopType(Sop/* SopType.INSTANCE_BUILDER */.aB.INSTANCE_BUILDER),
    sopType(Sop/* SopType.OBJECT_BUILDER */.aB.OBJECT_BUILDER),
    sopType(Sop/* SopType.POINT_BUILDER */.aB.POINT_BUILDER),
    sopType(Sop/* SopType.SDF_BUILDER */.aB.SDF_BUILDER),
    sopType(Sop/* SopType.TET_SOFT_BODY_SOLVER */.aB.TET_SOFT_BODY_SOLVER)
  ]
};
const ONLY_OBJECT_BUILDER = {
  only: [sopType(Sop/* SopType.OBJECT_BUILDER */.aB.OBJECT_BUILDER), ...JS_SUBNET_TYPES]
};
const ONLY_ENTITY_BUILDERS = {
  only: [
    sopType(Sop/* SopType.ENTITY_BUILDER */.aB.ENTITY_BUILDER),
    sopType(Sop/* SopType.INSTANCE_BUILDER */.aB.INSTANCE_BUILDER),
    sopType(Sop/* SopType.OBJECT_BUILDER */.aB.OBJECT_BUILDER),
    sopType(Sop/* SopType.POINT_BUILDER */.aB.POINT_BUILDER),
    ...JS_SUBNET_TYPES
  ]
};
const ONLY_ENTITY_BUILDER = {
  only: [sopType(Sop/* SopType.ENTITY_BUILDER */.aB.ENTITY_BUILDER), ...JS_SUBNET_TYPES]
};
const ACTOR_OBJECTS = [
  sopType(Sop/* SopType.ACTOR */.aB.ACTOR),
  sopType(Sop/* SopType.PHYSICS_WORLD */.aB.PHYSICS_WORLD),
  sopType(Sop/* SopType.PHYSICS_DEBUG */.aB.PHYSICS_DEBUG),
  sopType(Sop/* SopType.PHYSICS_PLAYER */.aB.PHYSICS_PLAYER),
  // sopType(SopType.TET_SOFT_BODY_SOLVER),
  ...[
    poly_NodeContext/* NodeContext.ANIM */.sy.ANIM,
    poly_NodeContext/* NodeContext.AUDIO */.sy.AUDIO,
    poly_NodeContext/* NodeContext.COP */.sy.COP,
    poly_NodeContext/* NodeContext.EVENT */.sy.EVENT,
    poly_NodeContext/* NodeContext.MAT */.sy.MAT,
    poly_NodeContext/* NodeContext.OBJ */.sy.OBJ,
    poly_NodeContext/* NodeContext.POST */.sy.POST,
    poly_NodeContext/* NodeContext.ROP */.sy.ROP,
    poly_NodeContext/* NodeContext.SOP */.sy.SOP
  ].map((c) => `${c}/${poly_NodeContext/* NetworkNodeType.ACTOR */.kX.ACTOR}`)
];
const ACTOR_POINTS = [sopType(Sop/* SopType.ACTOR_POINT */.aB.ACTOR_POINT)];
const ACTOR_INSTANCES = [sopType(Sop/* SopType.ACTOR_INSTANCE */.aB.ACTOR_INSTANCE)];
const ONLY_ACTOR = {
  only: ACTOR_OBJECTS
};
const ONLY_ACTOR_POINT = {
  only: ACTOR_POINTS
};
const ONLY_ACTOR_INSTANCE = {
  only: ACTOR_INSTANCES
};
const ONLY_ACTOR_AND_POINT = {
  only: [...ACTOR_OBJECTS, ...ACTOR_POINTS, ...ACTOR_INSTANCES]
};
class JsRegister {
  static run(poly) {
    poly.registerNode(js_Attribute/* AttributeJsNode */.Lq, CATEGORY_JS.GLOBALS, ONLY_ENTITY_BUILDERS);
    poly.registerNode(AbsJsNode, CATEGORY_JS.MATH);
    poly.registerNode(AcosJsNode, CATEGORY_JS.MATH);
    poly.registerNode(AddJsNode, CATEGORY_JS.MATH);
    poly.registerNode(AndJsNode, CATEGORY_JS.LOGIC);
    poly.registerNode(AnimationAction/* AnimationActionJsNode */.h, CATEGORY_JS.ANIMATION, ONLY_ACTOR);
    poly.registerNode(AnimationActionCrossFadeJsNode, CATEGORY_JS.ANIMATION, ONLY_ACTOR);
    poly.registerNode(AnimationActionFadeOutJsNode, CATEGORY_JS.ANIMATION, ONLY_ACTOR);
    poly.registerNode(AnimationActionFadeInJsNode, CATEGORY_JS.ANIMATION, ONLY_ACTOR);
    poly.registerNode(AnimationActionPlayJsNode, CATEGORY_JS.ANIMATION, ONLY_ACTOR);
    poly.registerNode(AnimationActionStopJsNode, CATEGORY_JS.ANIMATION, ONLY_ACTOR);
    poly.registerNode(AnimationMixer/* AnimationMixerJsNode */.C, CATEGORY_JS.ANIMATION, ONLY_ACTOR);
    poly.registerNode(AnimationMixerUpdateJsNode, CATEGORY_JS.ANIMATION, ONLY_ACTOR);
    poly.registerNode(AnyTriggerJsNode, CATEGORY_JS.ANIMATION, ONLY_ACTOR);
    poly.registerNode(ArrayElementJsNode, CATEGORY_JS.CONVERSION);
    poly.registerNode(ArrayLengthJsNode, CATEGORY_JS.LOGIC);
    poly.registerNode(ArrayPopJsNode, CATEGORY_JS.LOGIC);
    poly.registerNode(ArrayShiftJsNode, CATEGORY_JS.LOGIC);
    poly.registerNode(AsinJsNode, CATEGORY_JS.MATH);
    poly.registerNode(AtanJsNode, CATEGORY_JS.MATH);
    poly.registerNode(BoolToIntJsNode, CATEGORY_JS.CONVERSION);
    poly.registerNode(Box3JsNode, CATEGORY_JS.MATH);
    poly.registerNode(Box3ContainsPointJsNode, CATEGORY_JS.MATH);
    poly.registerNode(Box3IntersectsBox3JsNode, CATEGORY_JS.MATH);
    poly.registerNode(Box3SetFromObjectJsNode, CATEGORY_JS.MATH);
    poly.registerNode(CatmullRomCurve3GetPointJsNode, CATEGORY_JS.MATH);
    poly.registerNode(CeilJsNode, CATEGORY_JS.MATH);
    poly.registerNode(ClampJsNode, CATEGORY_JS.MATH);
    poly.registerNode(ClothSolverResetJsNode, CATEGORY_JS.PHYSICS);
    poly.registerNode(ClothSolverStepSimulation/* ClothSolverStepSimulationJsNode */.R, CATEGORY_JS.PHYSICS);
    poly.registerNode(ClothSolverUpdateMaterialJsNode, CATEGORY_JS.PHYSICS);
    poly.registerNode(CodeJsNode, CATEGORY_JS.ADVANCED, ONLY_ACTOR);
    poly.registerNode(ColorToVec3JsNode, CATEGORY_JS.CONVERSION);
    poly.registerNode(js_Compare/* CompareJsNode */._, CATEGORY_JS.LOGIC);
    poly.registerNode(ComplementJsNode, CATEGORY_JS.MATH);
    poly.registerNode(ComputeVelocityJsNode, CATEGORY_JS.MATH);
    poly.registerNode(js_Constant/* ConstantJsNode */.g, CATEGORY_JS.GLOBALS);
    poly.registerNode(CookNodeJsNode, CATEGORY_JS.ACTION, ONLY_ACTOR);
    poly.registerNode(CosJsNode, CATEGORY_JS.MATH);
    poly.registerNode(CreateClothConstraintJsNode, CATEGORY_JS.PHYSICS);
    poly.registerNode(CreateObjectsJsNode, CATEGORY_JS.ACTION);
    poly.registerNode(CreatePhysicsRBDKinematicConstraintJsNode, CATEGORY_JS.PHYSICS);
    poly.registerNode(CreatePhysicsRBDsJsNode, CATEGORY_JS.PHYSICS);
    poly.registerNode(CreateSoftBodyConstraintJsNode, CATEGORY_JS.PHYSICS);
    poly.registerNode(CrossJsNode, CATEGORY_JS.MATH);
    poly.registerNode(Cursor/* CursorJsNode */.T, CATEGORY_JS.INPUTS, ONLY_ACTOR);
    poly.registerNode(CursorToUvJsNode, CATEGORY_JS.INPUTS);
    poly.registerNode(Debug/* DebugJsNode */.F, CATEGORY_JS.FLOW, ONLY_ACTOR);
    poly.registerNode(DeformGeometryCubeLatticeJsNode, CATEGORY_JS.GEOMETRY, ONLY_ACTOR);
    poly.registerNode(DeleteClothConstraintJsNode, CATEGORY_JS.ACTION, ONLY_ACTOR);
    poly.registerNode(DeleteObjectJsNode, CATEGORY_JS.ACTION, ONLY_ACTOR);
    poly.registerNode(DeletePhysicsRBDJsNode, CATEGORY_JS.ACTION, ONLY_ACTOR);
    poly.registerNode(DeletePhysicsRBDKinematicConstraintJsNode, CATEGORY_JS.ACTION, ONLY_ACTOR);
    poly.registerNode(DeletePhysicsRBDConstraintsJsNode, CATEGORY_JS.ACTION, ONLY_ACTOR);
    poly.registerNode(DeleteSoftBodyConstraintJsNode, CATEGORY_JS.ACTION, ONLY_ACTOR);
    poly.registerNode(DegToRadJsNode, CATEGORY_JS.MATH);
    poly.registerNode(DeviceOrientationJsNode, CATEGORY_JS.GLOBALS, ONLY_ACTOR);
    poly.registerNode(DistanceJsNode, CATEGORY_JS.MATH);
    poly.registerNode(DivideJsNode, CATEGORY_JS.MATH);
    poly.registerNode(DotJsNode, CATEGORY_JS.MATH);
    poly.registerNode(js_Easing/* EasingJsNode */.H, CATEGORY_JS.MATH);
    poly.registerNode(ElementsToArrayJsNode, CATEGORY_JS.CONVERSION);
    poly.registerNode(EulerJsNode, CATEGORY_JS.MATH);
    poly.registerNode(EulerFromQuaternionJsNode, CATEGORY_JS.MATH);
    poly.registerNode(FitJsNode, CATEGORY_JS.MATH);
    poly.registerNode(FloatToColorJsNode, CATEGORY_JS.CONVERSION);
    poly.registerNode(FloatToIntJsNode, CATEGORY_JS.CONVERSION);
    poly.registerNode(FloatToVec2JsNode, CATEGORY_JS.CONVERSION);
    poly.registerNode(FloatToVec3JsNode, CATEGORY_JS.CONVERSION);
    poly.registerNode(FloatToVec4JsNode, CATEGORY_JS.CONVERSION);
    poly.registerNode(FloorJsNode, CATEGORY_JS.MATH);
    poly.registerNode(ForLoopJsNode, CATEGORY_JS.FLOW, ONLY_ENTITY_BUILDER);
    poly.registerNode(GeolocationCurrentPositionJsNode, CATEGORY_JS.GLOBALS, ONLY_ACTOR);
    poly.registerNode(GetBox3PropertyJsNode, CATEGORY_JS.MATH);
    poly.registerNode(GetChildrenAttributes/* GetChildrenAttributesJsNode */.y, CATEGORY_JS.GET, ONLY_ACTOR);
    poly.registerNode(GetChildrenPhysicsRBDPropertiesJsNode, CATEGORY_JS.PHYSICS, ONLY_ACTOR);
    poly.registerNode(GetChildrenPropertiesJsNode, CATEGORY_JS.GET, ONLY_ACTOR);
    poly.registerNode(GetDefaultCameraJsNode, CATEGORY_JS.GET, ONLY_ACTOR);
    poly.registerNode(GetGeometryBoundingBoxJsNode, CATEGORY_JS.GET, ONLY_ACTOR);
    poly.registerNode(GetGeometryNodeObjects/* GetGeometryNodeObjectsJsNode */.s, CATEGORY_JS.GET, ONLY_ACTOR);
    poly.registerNode(GetGeometryPositionsJsNode, CATEGORY_JS.GET, ONLY_ACTOR);
    poly.registerNode(GetIntersectionAttributeJsNode, CATEGORY_JS.GET);
    poly.registerNode(GetIntersectionPropertyJsNode, CATEGORY_JS.GET);
    poly.registerNode(GetInstanceAttributeJsNode, CATEGORY_JS.GET, ONLY_ACTOR_INSTANCE);
    poly.registerNode(GetInstancePropertyJsNode, CATEGORY_JS.GET, ONLY_ACTOR_INSTANCE);
    poly.registerNode(GetMaterial/* GetMaterialJsNode */.X, CATEGORY_JS.GET, ONLY_ACTOR);
    poly.registerNode(GetObjectChild/* GetObjectChildJsNode */.H, CATEGORY_JS.GET, ONLY_ACTOR);
    poly.registerNode(GetObject/* GetObjectJsNode */.l, CATEGORY_JS.GET, ONLY_ACTOR);
    poly.registerNode(GetObjectAttribute/* GetObjectAttributeJsNode */.h, CATEGORY_JS.GET, ONLY_ACTOR);
    poly.registerNode(GetObjectPropertyJsNode, CATEGORY_JS.GET);
    poly.registerNode(GetObjectUserData/* GetObjectUserDataJsNode */.r, CATEGORY_JS.GET, ONLY_ACTOR);
    poly.registerNode(GetObjectWorldPositionJsNode, CATEGORY_JS.GET, ONLY_ACTOR);
    poly.registerNode(GetNode/* GetNodeJsNode */.z, CATEGORY_JS.GET, ONLY_ACTOR);
    poly.registerNode(GetParam/* GetParamJsNode */.V, CATEGORY_JS.GET, ONLY_ACTOR);
    poly.registerNode(GetParentJsNode, CATEGORY_JS.GET, ONLY_ACTOR);
    poly.registerNode(GetPlanePropertyJsNode, CATEGORY_JS.MATH);
    poly.registerNode(GetPhysicsRBDJsNode, CATEGORY_JS.PHYSICS, ONLY_ACTOR);
    poly.registerNode(GetPhysicsRBDCapsulePropertyJsNode, CATEGORY_JS.PHYSICS, ONLY_ACTOR);
    poly.registerNode(GetPhysicsRBDConePropertyJsNode, CATEGORY_JS.PHYSICS, ONLY_ACTOR);
    poly.registerNode(GetPhysicsRBDCylinderPropertyJsNode, CATEGORY_JS.PHYSICS, ONLY_ACTOR);
    poly.registerNode(GetPhysicsRBDCuboidPropertyJsNode, CATEGORY_JS.PHYSICS, ONLY_ACTOR);
    poly.registerNode(GetPhysicsRBDSpherePropertyJsNode, CATEGORY_JS.PHYSICS, ONLY_ACTOR);
    poly.registerNode(GetPhysicsRBDPropertyJsNode, CATEGORY_JS.PHYSICS, ONLY_ACTOR);
    poly.registerNode(GetRayPropertyJsNode, CATEGORY_JS.MATH);
    poly.registerNode(GetPointAttributeJsNode, CATEGORY_JS.GET, ONLY_ACTOR_POINT);
    poly.registerNode(GetPointPropertyJsNode, CATEGORY_JS.GET, ONLY_ACTOR_POINT);
    poly.registerNode(GetPrimitiveAttributeJsNode, CATEGORY_JS.GET, ONLY_ACTOR);
    poly.registerNode(GetSibblingJsNode, CATEGORY_JS.GET);
    poly.registerNode(GetSpherePropertyJsNode, CATEGORY_JS.MATH);
    poly.registerNode(GetTexture/* GetTextureJsNode */.D, CATEGORY_JS.GET, ONLY_ACTOR);
    poly.registerNode(GetTrackedHandPropertyJsNode, CATEGORY_JS.COMPUTER_VISION, ONLY_ACTOR);
    poly.registerNode(GetVideoProperty/* GetVideoPropertyJsNode */.S, CATEGORY_JS.GET, ONLY_ACTOR);
    poly.registerNode(GetWebXRARSessionPropertyJsNode, CATEGORY_JS.WEBXR, ONLY_ACTOR);
    poly.registerNode(GetWebXRControllerPropertyJsNode, CATEGORY_JS.WEBXR, ONLY_ACTOR);
    poly.registerNode(GetWebXRTrackedMarkerPropertyJsNode, CATEGORY_JS.WEBXR, ONLY_ACTOR);
    poly.registerNode(GlobalsJsNode, CATEGORY_JS.GLOBALS, ONLY_WITH_GLOBALS);
    poly.registerNode(GlobalsAmbientLightJsNode, CATEGORY_JS.GLOBALS, ONLY_OBJECT_BUILDER);
    poly.registerNode(GlobalsAreaLightJsNode, CATEGORY_JS.GLOBALS, ONLY_OBJECT_BUILDER);
    poly.registerNode(GlobalsDirectionalLightJsNode, CATEGORY_JS.GLOBALS, ONLY_OBJECT_BUILDER);
    poly.registerNode(GlobalsHemisphereLightJsNode, CATEGORY_JS.GLOBALS, ONLY_OBJECT_BUILDER);
    poly.registerNode(GlobalsPointLightJsNode, CATEGORY_JS.GLOBALS, ONLY_OBJECT_BUILDER);
    poly.registerNode(GlobalsSpotLightJsNode, CATEGORY_JS.GLOBALS, ONLY_OBJECT_BUILDER);
    poly.registerNode(HsvToRgbJsNode, CATEGORY_JS.CONVERSION);
    poly.registerNode(ImportAttribute/* ImportAttributeJsNode */.dQ, CATEGORY_JS.GLOBALS, ONLY_ENTITY_BUILDER);
    poly.registerNode(IntToBoolJsNode, CATEGORY_JS.CONVERSION);
    poly.registerNode(IntToFloatJsNode, CATEGORY_JS.CONVERSION);
    poly.registerNode(IsDefinedJsNode, CATEGORY_JS.FLOW);
    poly.registerNode(IsTouchDeviceJsNode, CATEGORY_JS.FLOW);
    poly.registerNode(Keyframes/* KeyframesJsNode */.BK, CATEGORY_JS.ANIMATION);
    poly.registerNode(LengthJsNode, CATEGORY_JS.MATH);
    poly.registerNode(LerpJsNode, CATEGORY_JS.MATH);
    poly.registerNode(ManhattanDistanceJsNode, CATEGORY_JS.MATH);
    poly.registerNode(Matrix4LookAtJsNode, CATEGORY_JS.MATH);
    poly.registerNode(Matrix4MakeTranslationJsNode, CATEGORY_JS.MATH);
    poly.registerNode(Matrix4MultiplyJsNode, CATEGORY_JS.MATH);
    poly.registerNode(MaxJsNode, CATEGORY_JS.MATH);
    poly.registerNode(MaxLengthJsNode, CATEGORY_JS.MATH);
    poly.registerNode(MinJsNode, CATEGORY_JS.MATH);
    poly.registerNode(MixJsNode, CATEGORY_JS.MATH);
    poly.registerNode(ModJsNode, CATEGORY_JS.MATH);
    poly.registerNode(MultJsNode, CATEGORY_JS.MATH);
    poly.registerNode(MultAddJsNode, CATEGORY_JS.MATH);
    poly.registerNode(MultScalarJsNode, CATEGORY_JS.MATH);
    poly.registerNode(NearestPositionJsNode, CATEGORY_JS.MATH);
    poly.registerNode(NegateJsNode, CATEGORY_JS.MATH);
    poly.registerNode(NoiseImprovedJsNode, CATEGORY_JS.MATH);
    poly.registerNode(NoiseSimplexJsNode, CATEGORY_JS.MATH);
    poly.registerNode(NormalizeJsNode, CATEGORY_JS.MATH);
    poly.registerNode(NullJsNode, CATEGORY_JS.FLOW);
    poly.registerNode(Object3DLocalToWorldJsNode, CATEGORY_JS.GET, ONLY_ACTOR);
    poly.registerNode(Object3DWorldToLocalJsNode, CATEGORY_JS.GET, ONLY_ACTOR);
    poly.registerNode(Object3DUpdateMatrixJsNode, CATEGORY_JS.GET, ONLY_ACTOR);
    poly.registerNode(Object3DUpdateWorldMatrixJsNode, CATEGORY_JS.GET, ONLY_ACTOR);
    poly.registerNode(ObjectDispatchEventJsNode, CATEGORY_JS.GET, ONLY_ACTOR);
    poly.registerNode(OnChildAttributeUpdate/* OnChildAttributeUpdateJsNode */.i, CATEGORY_JS.EVENTS, ONLY_ACTOR);
    poly.registerNode(OnKey/* OnKeyJsNode */.F, CATEGORY_JS.EVENTS, ONLY_ACTOR);
    poly.registerNode(OnKeydown/* OnKeydownJsNode */.Y, CATEGORY_JS.EVENTS, ONLY_ACTOR);
    poly.registerNode(OnKeypress/* OnKeypressJsNode */.f, CATEGORY_JS.EVENTS, ONLY_ACTOR);
    poly.registerNode(OnKeyup/* OnKeyupJsNode */.y, CATEGORY_JS.EVENTS, ONLY_ACTOR);
    poly.registerNode(OnManualTriggerJsNode, CATEGORY_JS.EVENTS, ONLY_ACTOR);
    poly.registerNode(OnMapboxCameraMoveJsNode, CATEGORY_JS.EVENTS, ONLY_ACTOR);
    poly.registerNode(OnMapboxCameraMoveEndJsNode, CATEGORY_JS.EVENTS, ONLY_ACTOR);
    poly.registerNode(OnMapboxCameraMoveStartJsNode, CATEGORY_JS.EVENTS, ONLY_ACTOR);
    poly.registerNode(OnObjectAttributeUpdate/* OnObjectAttributeUpdateJsNode */.v, CATEGORY_JS.EVENTS, ONLY_ACTOR);
    poly.registerNode(OnObjectBeforeDeleteJsNode, CATEGORY_JS.EVENTS, ONLY_ACTOR);
    poly.registerNode(OnObjectClick/* OnObjectClickJsNode */.U, CATEGORY_JS.EVENTS, ONLY_ACTOR);
    poly.registerNode(OnObjectClickGPUJsNode, CATEGORY_JS.EVENTS, ONLY_ACTOR);
    poly.registerNode(OnObjectContextMenuJsNode, CATEGORY_JS.EVENTS, ONLY_ACTOR);
    poly.registerNode(OnObjectContextMenuGPUJsNode, CATEGORY_JS.EVENTS, ONLY_ACTOR);
    poly.registerNode(OnObjectDispatchEvent/* OnObjectDispatchEventJsNode */.$, CATEGORY_JS.EVENTS, ONLY_ACTOR);
    poly.registerNode(OnObjectHoverJsNode, CATEGORY_JS.EVENTS, ONLY_ACTOR);
    poly.registerNode(OnObjectHoverGPUJsNode, CATEGORY_JS.EVENTS, ONLY_ACTOR);
    poly.registerNode(OnObjectLongPressJsNode, CATEGORY_JS.EVENTS, ONLY_ACTOR);
    poly.registerNode(OnObjectLongPressGPUJsNode, CATEGORY_JS.EVENTS, ONLY_ACTOR);
    poly.registerNode(OnObjectMouseClickJsNode, CATEGORY_JS.EVENTS, ONLY_ACTOR);
    poly.registerNode(OnObjectPointerdown/* OnObjectPointerdownJsNode */.Q, CATEGORY_JS.EVENTS, ONLY_ACTOR);
    poly.registerNode(OnObjectPointerdownGPUJsNode, CATEGORY_JS.EVENTS, ONLY_ACTOR);
    poly.registerNode(OnObjectPointerup/* OnObjectPointerupJsNode */.z, CATEGORY_JS.EVENTS, ONLY_ACTOR);
    poly.registerNode(OnObjectPointerupGPUJsNode, CATEGORY_JS.EVENTS, ONLY_ACTOR);
    poly.registerNode(OnObjectSwipe/* OnObjectSwipeJsNode */.t, CATEGORY_JS.EVENTS, ONLY_ACTOR);
    poly.registerNode(OnObjectSwipeGPU/* OnObjectSwipeGPUJsNode */.o, CATEGORY_JS.EVENTS, ONLY_ACTOR);
    poly.registerNode(OnPerformanceChangeJsNode, CATEGORY_JS.EVENTS, ONLY_ACTOR);
    poly.registerNode(OnPointerdown/* OnPointerdownJsNode */.y, CATEGORY_JS.EVENTS, ONLY_ACTOR);
    poly.registerNode(OnPointerup/* OnPointerupJsNode */.b, CATEGORY_JS.EVENTS, ONLY_ACTOR);
    poly.registerNode(OnScenePauseJsNode, CATEGORY_JS.EVENTS, ONLY_ACTOR);
    poly.registerNode(OnScenePlayJsNode, CATEGORY_JS.EVENTS, ONLY_ACTOR);
    poly.registerNode(OnSceneResetJsNode, CATEGORY_JS.EVENTS, ONLY_ACTOR);
    poly.registerNode(OnScrollJsNode, CATEGORY_JS.EVENTS, ONLY_ACTOR);
    poly.registerNode(OnTick/* OnTickJsNode */.o, CATEGORY_JS.EVENTS, ONLY_ACTOR_AND_POINT);
    poly.registerNode(OnVideoEvent/* OnVideoEventJsNode */.$, CATEGORY_JS.EVENTS, ONLY_ACTOR);
    poly.registerNode(OnViewerControlsEventJsNode, CATEGORY_JS.EVENTS, ONLY_ACTOR);
    poly.registerNode(OnWebXRControllerEventJsNode, CATEGORY_JS.EVENTS, ONLY_ACTOR);
    poly.registerNode(OrJsNode, CATEGORY_JS.LOGIC);
    poly.registerNode(OutputJsNode, CATEGORY_JS.GLOBALS, ONLY_WITH_GLOBALS);
    poly.registerNode(OutputAmbientLightJsNode, CATEGORY_JS.GLOBALS, ONLY_OBJECT_BUILDER);
    poly.registerNode(OutputAreaLightJsNode, CATEGORY_JS.GLOBALS, ONLY_OBJECT_BUILDER);
    poly.registerNode(OutputDirectionalLightJsNode, CATEGORY_JS.GLOBALS, ONLY_OBJECT_BUILDER);
    poly.registerNode(OutputHemisphereLightJsNode, CATEGORY_JS.GLOBALS, ONLY_OBJECT_BUILDER);
    poly.registerNode(OutputPointLightJsNode, CATEGORY_JS.GLOBALS, ONLY_OBJECT_BUILDER);
    poly.registerNode(OutputSpotLightJsNode, CATEGORY_JS.GLOBALS, ONLY_OBJECT_BUILDER);
    poly.registerNode(js_Param/* ParamJsNode */.p, CATEGORY_JS.GLOBALS);
    poly.registerNode(ParticlesSystemResetJsNode, CATEGORY_JS.PARTICLES, ONLY_ACTOR);
    poly.registerNode(ParticlesSystemStepSimulationJsNode, CATEGORY_JS.PARTICLES, ONLY_ACTOR);
    poly.registerNode(PauseAudioSource/* PauseAudioSourceJsNode */.s, CATEGORY_JS.AUDIO, ONLY_ACTOR);
    poly.registerNode(PhysicsDebugUpdateJsNode, CATEGORY_JS.PHYSICS, ONLY_ACTOR);
    poly.registerNode(PhysicsPlayerUpdateJsNode, CATEGORY_JS.PHYSICS, ONLY_ACTOR);
    poly.registerNode(PhysicsRBDAddForceJsNode, CATEGORY_JS.PHYSICS, ONLY_ACTOR);
    poly.registerNode(PhysicsRBDAddForceAtPointJsNode, CATEGORY_JS.PHYSICS, ONLY_ACTOR);
    poly.registerNode(PhysicsRBDAddTorqueJsNode, CATEGORY_JS.PHYSICS, ONLY_ACTOR);
    poly.registerNode(PhysicsRBDApplyImpulseJsNode, CATEGORY_JS.PHYSICS, ONLY_ACTOR);
    poly.registerNode(PhysicsRBDApplyTorqueImpulseJsNode, CATEGORY_JS.PHYSICS, ONLY_ACTOR);
    poly.registerNode(PhysicsRBDApplyImpulseAtPointJsNode, CATEGORY_JS.PHYSICS, ONLY_ACTOR);
    poly.registerNode(PhysicsRBDResetAllJsNode, CATEGORY_JS.PHYSICS, ONLY_ACTOR);
    poly.registerNode(PhysicsRBDResetForcesJsNode, CATEGORY_JS.PHYSICS, ONLY_ACTOR);
    poly.registerNode(PhysicsRBDResetTorquesJsNode, CATEGORY_JS.PHYSICS, ONLY_ACTOR);
    poly.registerNode(PhysicsWorldResetJsNode, CATEGORY_JS.PHYSICS, ONLY_ACTOR);
    poly.registerNode(PhysicsWorldStepSimulationJsNode, CATEGORY_JS.PHYSICS, ONLY_ACTOR);
    poly.registerNode(PlaneJsNode, CATEGORY_JS.MATH);
    poly.registerNode(PlayAnimation/* PlayAnimationJsNode */.r, CATEGORY_JS.ACTION, ONLY_ACTOR);
    poly.registerNode(PlayAudioSource/* PlayAudioSourceJsNode */.J, CATEGORY_JS.AUDIO, ONLY_ACTOR);
    poly.registerNode(PlayInstrumentNote/* PlayInstrumentNoteJsNode */.D, CATEGORY_JS.AUDIO, ONLY_ACTOR);
    poly.registerNode(PlayerModeJsNode, CATEGORY_JS.LOGIC);
    poly.registerNode(PlayerUpdateJsNode, CATEGORY_JS.ACTION, ONLY_ACTOR);
    poly.registerNode(PolarTransformJsNode, CATEGORY_JS.MATH);
    poly.registerNode(PowJsNode, CATEGORY_JS.MATH);
    poly.registerNode(PressButtonParamJsNode, CATEGORY_JS.ACTION, ONLY_ACTOR);
    poly.registerNode(PreviousValueJsNode, CATEGORY_JS.ADVANCED, ONLY_ACTOR);
    poly.registerNode(PrimitiveNeighbourIndexJsNode, CATEGORY_JS.ADVANCED, ONLY_ENTITY_BUILDER);
    poly.registerNode(PrimitiveNeighboursCountJsNode, CATEGORY_JS.ADVANCED, ONLY_ENTITY_BUILDER);
    poly.registerNode(QuaternionJsNode, CATEGORY_JS.MATH);
    poly.registerNode(QuaternionAngleToJsNode, CATEGORY_JS.MATH);
    poly.registerNode(QuaternionSlerpJsNode, CATEGORY_JS.MATH);
    poly.registerNode(RadToDegJsNode, CATEGORY_JS.MATH);
    poly.registerNode(RandJsNode, CATEGORY_JS.MATH);
    poly.registerNode(RandomJsNode, CATEGORY_JS.MATH);
    poly.registerNode(RayJsNode, CATEGORY_JS.MATH);
    poly.registerNode(RayFromCamera/* RayFromCameraJsNode */.L, CATEGORY_JS.INPUTS);
    poly.registerNode(RayFromCursor/* RayFromCursorJsNode */.C, CATEGORY_JS.INPUTS);
    poly.registerNode(RayIntersectBoxJsNode, CATEGORY_JS.MATH);
    poly.registerNode(RayIntersectsBoxJsNode, CATEGORY_JS.MATH);
    poly.registerNode(RayIntersectObjectJsNode, CATEGORY_JS.MATH);
    poly.registerNode(RayIntersectsObjectJsNode, CATEGORY_JS.MATH);
    poly.registerNode(RayDistanceToPlaneJsNode, CATEGORY_JS.MATH);
    poly.registerNode(RayIntersectPlaneJsNode, CATEGORY_JS.MATH);
    poly.registerNode(RayIntersectsPlaneJsNode, CATEGORY_JS.MATH);
    poly.registerNode(RayIntersectSphereJsNode, CATEGORY_JS.MATH);
    poly.registerNode(RayIntersectsSphereJsNode, CATEGORY_JS.MATH);
    poly.registerNode(RenderPixelJsNode, CATEGORY_JS.ADVANCED, ONLY_ACTOR);
    poly.registerNode(RotateJsNode, CATEGORY_JS.MATH);
    poly.registerNode(RoundJsNode, CATEGORY_JS.MATH);
    poly.registerNode(SDF2DBoxJsNode, CATEGORY_JS.SDF_PRIMITIVES_2D);
    poly.registerNode(SDF2DCircleJsNode, CATEGORY_JS.SDF_PRIMITIVES_2D);
    poly.registerNode(SDF2DCrossJsNode, CATEGORY_JS.SDF_PRIMITIVES_2D);
    poly.registerNode(SDF2DHeartJsNode, CATEGORY_JS.SDF_PRIMITIVES_2D);
    poly.registerNode(SDF2DRoundedXJsNode, CATEGORY_JS.SDF_PRIMITIVES_2D);
    poly.registerNode(SDFBoxJsNode, CATEGORY_JS.SDF_PRIMITIVES);
    poly.registerNode(SDFElongateJsNode, CATEGORY_JS.SDF_MODIFIERS);
    poly.registerNode(SDFIntersectJsNode, CATEGORY_JS.SDF_MODIFIERS);
    poly.registerNode(SDFOnionJsNode, CATEGORY_JS.SDF_PRIMITIVES);
    poly.registerNode(SDFPlaneJsNode, CATEGORY_JS.SDF_PRIMITIVES);
    poly.registerNode(SDFRevolutionJsNode, CATEGORY_JS.SDF_MODIFIERS);
    poly.registerNode(SDFSphereJsNode, CATEGORY_JS.SDF_PRIMITIVES);
    poly.registerNode(SDFSubtractJsNode, CATEGORY_JS.SDF_MODIFIERS);
    poly.registerNode(SDFTorusJsNode, CATEGORY_JS.SDF_PRIMITIVES);
    poly.registerNode(SDFTransformJsNode, CATEGORY_JS.SDF_PRIMITIVES);
    poly.registerNode(SDFTubeJsNode, CATEGORY_JS.SDF_PRIMITIVES);
    poly.registerNode(SDFUnionJsNode, CATEGORY_JS.SDF_MODIFIERS);
    poly.registerNode(SetCameraViewOffsetJsNode, CATEGORY_JS.ACTION, ONLY_ACTOR);
    poly.registerNode(SetClothConstraintPositionJsNode, CATEGORY_JS.EVENTS, ONLY_ACTOR);
    poly.registerNode(SetCSSObjectClassJsNode, CATEGORY_JS.ACTION, ONLY_ACTOR);
    poly.registerNode(SetGeometryInstanceAttributeJsNode, CATEGORY_JS.ACTION, ONLY_ACTOR);
    poly.registerNode(SetGeometryInstancePositionsJsNode, CATEGORY_JS.ACTION, ONLY_ACTOR);
    poly.registerNode(SetGeometryInstanceQuaternionsJsNode, CATEGORY_JS.ACTION, ONLY_ACTOR);
    poly.registerNode(SetGeometryInstanceScalesJsNode, CATEGORY_JS.ACTION, ONLY_ACTOR);
    poly.registerNode(SetGeometryInstanceTransformsJsNode, CATEGORY_JS.ACTION, ONLY_ACTOR);
    poly.registerNode(SetGeometryPositionsJsNode, CATEGORY_JS.ACTION, ONLY_ACTOR);
    poly.registerNode(SetInstanceAttributeJsNode, CATEGORY_JS.ACTION, ONLY_ACTOR_INSTANCE);
    poly.registerNode(SetInstanceLookAtJsNode, CATEGORY_JS.ACTION, ONLY_ACTOR_INSTANCE);
    poly.registerNode(SetInstancePositionJsNode, CATEGORY_JS.ACTION, ONLY_ACTOR_INSTANCE);
    poly.registerNode(SetInstanceQuaternionJsNode, CATEGORY_JS.ACTION, ONLY_ACTOR_INSTANCE);
    poly.registerNode(SetInstanceScaleJsNode, CATEGORY_JS.ACTION, ONLY_ACTOR_INSTANCE);
    poly.registerNode(SetMaterialAlphaMapJsNode, CATEGORY_JS.ACTION, ONLY_ACTOR);
    poly.registerNode(SetMaterialAOMapJsNode, CATEGORY_JS.ACTION, ONLY_ACTOR);
    poly.registerNode(SetMaterialColorJsNode, CATEGORY_JS.ACTION, ONLY_ACTOR);
    poly.registerNode(SetMaterialDisplacementMapJsNode, CATEGORY_JS.ACTION, ONLY_ACTOR);
    poly.registerNode(SetMaterialEmissiveColorJsNode, CATEGORY_JS.ACTION, ONLY_ACTOR);
    poly.registerNode(SetMaterialEnvMapJsNode, CATEGORY_JS.ACTION, ONLY_ACTOR);
    poly.registerNode(SetMaterialEmissiveMapJsNode, CATEGORY_JS.ACTION, ONLY_ACTOR);
    poly.registerNode(SetMaterialMapJsNode, CATEGORY_JS.ACTION, ONLY_ACTOR);
    poly.registerNode(SetMaterialMetalnessMapJsNode, CATEGORY_JS.ACTION, ONLY_ACTOR);
    poly.registerNode(SetMaterialOpacityJsNode, CATEGORY_JS.ACTION, ONLY_ACTOR);
    poly.registerNode(SetMaterialRoughnessMapJsNode, CATEGORY_JS.ACTION, ONLY_ACTOR);
    poly.registerNode(SetMaterialUniform/* SetMaterialUniformJsNode */.d, CATEGORY_JS.ACTION, ONLY_ACTOR);
    poly.registerNode(SetObjectAttribute/* SetObjectAttributeJsNode */.c, CATEGORY_JS.ACTION, ONLY_ACTOR);
    poly.registerNode(SetObjectCastShadowJsNode, CATEGORY_JS.ACTION, ONLY_ACTOR);
    poly.registerNode(SetObjectFrustumCulledJsNode, CATEGORY_JS.ACTION, ONLY_ACTOR);
    poly.registerNode(SetObjectLookAt/* SetObjectLookAtJsNode */.c, CATEGORY_JS.ACTION, ONLY_ACTOR);
    poly.registerNode(SetObjectMaterialJsNode, CATEGORY_JS.ACTION, ONLY_ACTOR);
    poly.registerNode(SetObjectMaterialColorJsNode, CATEGORY_JS.ACTION, ONLY_ACTOR);
    poly.registerNode(SetObjectMatrixJsNode, CATEGORY_JS.ACTION, ONLY_ACTOR);
    poly.registerNode(SetObjectMatrixAutoUpdateJsNode, CATEGORY_JS.ACTION, ONLY_ACTOR);
    poly.registerNode(SetObjectPosition/* SetObjectPositionJsNode */.S, CATEGORY_JS.ACTION, ONLY_ACTOR);
    poly.registerNode(SetObjectPolarTransform/* SetObjectPolarTransformJsNode */.M, CATEGORY_JS.ACTION, ONLY_ACTOR);
    poly.registerNode(SetObjectQuaternionJsNode, CATEGORY_JS.ACTION, ONLY_ACTOR);
    poly.registerNode(SetObjectReceiveShadowJsNode, CATEGORY_JS.ACTION, ONLY_ACTOR);
    poly.registerNode(SetObjectRotation/* SetObjectRotationJsNode */.D, CATEGORY_JS.ACTION, ONLY_ACTOR);
    poly.registerNode(SetObjectScale/* SetObjectScaleJsNode */.w, CATEGORY_JS.ACTION, ONLY_ACTOR);
    poly.registerNode(SetObjectVisibleJsNode, CATEGORY_JS.ACTION, ONLY_ACTOR);
    poly.registerNode(js_SetParam/* SetParamJsNode */.g, CATEGORY_JS.ACTION, ONLY_ACTOR);
    poly.registerNode(SetPerspectiveCameraFovJsNode, CATEGORY_JS.ACTION, ONLY_ACTOR);
    poly.registerNode(SetPerspectiveCameraNearFarJsNode, CATEGORY_JS.ACTION, ONLY_ACTOR);
    poly.registerNode(SetPhysicsRBDAngularVelocityJsNode, CATEGORY_JS.PHYSICS, ONLY_ACTOR);
    poly.registerNode(SetPhysicsRBDLinearVelocityJsNode, CATEGORY_JS.PHYSICS, ONLY_ACTOR);
    poly.registerNode(SetPhysicsRBDPositionJsNode, CATEGORY_JS.PHYSICS, ONLY_ACTOR);
    poly.registerNode(SetPhysicsRBDRotationJsNode, CATEGORY_JS.PHYSICS, ONLY_ACTOR);
    poly.registerNode(SetPhysicsRBDCapsulePropertyJsNode, CATEGORY_JS.PHYSICS, ONLY_ACTOR);
    poly.registerNode(SetPhysicsRBDConePropertyJsNode, CATEGORY_JS.PHYSICS, ONLY_ACTOR);
    poly.registerNode(SetPhysicsRBDCylinderPropertyJsNode, CATEGORY_JS.PHYSICS, ONLY_ACTOR);
    poly.registerNode(SetPhysicsRBDCuboidPropertyJsNode, CATEGORY_JS.PHYSICS, ONLY_ACTOR);
    poly.registerNode(SetPhysicsRBDSpherePropertyJsNode, CATEGORY_JS.PHYSICS, ONLY_ACTOR);
    poly.registerNode(SetPhysicsWorldGravityJsNode, CATEGORY_JS.PHYSICS, ONLY_ACTOR);
    poly.registerNode(SetPlayerInputJsNode, CATEGORY_JS.EVENTS, ONLY_ACTOR);
    poly.registerNode(SetPointAttributeJsNode, CATEGORY_JS.ACTION, ONLY_ACTOR_POINT);
    poly.registerNode(SetPointPositionJsNode, CATEGORY_JS.ACTION, ONLY_ACTOR_POINT);
    poly.registerNode(SetSoftBodyPositionJsNode, CATEGORY_JS.EVENTS, ONLY_ACTOR);
    poly.registerNode(SetSoftBodyVelocityJsNode, CATEGORY_JS.EVENTS, ONLY_ACTOR);
    poly.registerNode(SetSoftBodyConstraintPositionJsNode, CATEGORY_JS.EVENTS, ONLY_ACTOR);
    poly.registerNode(SetSpotLightIntensityJsNode, CATEGORY_JS.PHYSICS, ONLY_ACTOR);
    poly.registerNode(SetViewerJsNode, CATEGORY_JS.ACTION, ONLY_ACTOR);
    poly.registerNode(SetViewerControlsJsNode, CATEGORY_JS.ACTION, ONLY_ACTOR);
    if (false) {}
    poly.registerNode(SignJsNode, CATEGORY_JS.MATH);
    poly.registerNode(SinJsNode, CATEGORY_JS.MATH);
    poly.registerNode(SmoothstepJsNode, CATEGORY_JS.MATH);
    poly.registerNode(SmootherstepJsNode, CATEGORY_JS.MATH);
    poly.registerNode(SoftBodySolverStepSimulationJsNode, CATEGORY_JS.PHYSICS);
    poly.registerNode(SphereJsNode, CATEGORY_JS.MATH);
    poly.registerNode(SqrtJsNode, CATEGORY_JS.MATH);
    poly.registerNode(js_Subnet/* SubnetJsNode */.tD, CATEGORY_JS.LOGIC);
    poly.registerNode(SubnetInputJsNode, CATEGORY_JS.LOGIC, Js_SUBNET_CHILD_OPTION);
    poly.registerNode(js_SubnetOutput/* SubnetOutputJsNode */.h, CATEGORY_JS.LOGIC, Js_SUBNET_CHILD_OPTION);
    poly.registerNode(SubtractJsNode, CATEGORY_JS.MATH);
    poly.registerNode(SwitchJsNode, CATEGORY_JS.LOGIC);
    poly.registerNode(TanJsNode, CATEGORY_JS.MATH);
    poly.registerNode(TrackFace/* TrackFaceJsNode */.A, CATEGORY_JS.COMPUTER_VISION);
    poly.registerNode(TrackHand/* TrackHandJsNode */.S, CATEGORY_JS.COMPUTER_VISION);
    poly.registerNode(TriggerDelayJsNode, CATEGORY_JS.FLOW, ONLY_ACTOR);
    poly.registerNode(TriggerFilterJsNode, CATEGORY_JS.FLOW, ONLY_ACTOR);
    poly.registerNode(TriggerSwitchJsNode, CATEGORY_JS.FLOW, ONLY_ACTOR_AND_POINT);
    poly.registerNode(TriggerTwoWaySwitchJsNode, CATEGORY_JS.FLOW, ONLY_ACTOR_AND_POINT);
    poly.registerNode(TwoWaySwitchJsNode, CATEGORY_JS.LOGIC);
    poly.registerNode(Vector3AngleToJsNode, CATEGORY_JS.MATH);
    poly.registerNode(Vector3ProjectJsNode, CATEGORY_JS.MATH);
    poly.registerNode(Vector3ProjectOnPlaneJsNode, CATEGORY_JS.MATH);
    poly.registerNode(Vector3UnprojectJsNode, CATEGORY_JS.MATH);
    poly.registerNode(Vec2ToFloatJsNode, CATEGORY_JS.CONVERSION);
    poly.registerNode(Vec2ToVec3JsNode, CATEGORY_JS.CONVERSION);
    poly.registerNode(Vec3ToFloatJsNode, CATEGORY_JS.CONVERSION);
    poly.registerNode(Vec3ToColorJsNode, CATEGORY_JS.CONVERSION);
    poly.registerNode(Vec3ToVec2JsNode, CATEGORY_JS.CONVERSION);
    poly.registerNode(Vec3ToVec4JsNode, CATEGORY_JS.CONVERSION);
    poly.registerNode(Vec4ToFloatJsNode, CATEGORY_JS.CONVERSION);
    poly.registerNode(Vec4ToVec3JsNode, CATEGORY_JS.CONVERSION);
    poly.registerNode(Vector2JsNode, CATEGORY_JS.MATH);
    poly.registerNode(Vector3JsNode, CATEGORY_JS.MATH);
    poly.registerNode(Vector4JsNode, CATEGORY_JS.MATH);
    if (false) {}
  }
}

// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/nodes/mat/_Base.ts
var mat_Base = __webpack_require__(78058);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/nodes/gl/code/assemblers/materials/OnBeforeCompile.ts
var OnBeforeCompile = __webpack_require__(43008);
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/mat/BuilderUniformUpdate.ts

var BuilderUniformUpdate_defProp = Object.defineProperty;
var BuilderUniformUpdate_defProps = Object.defineProperties;
var BuilderUniformUpdate_getOwnPropDescs = Object.getOwnPropertyDescriptors;
var BuilderUniformUpdate_getOwnPropSymbols = Object.getOwnPropertySymbols;
var BuilderUniformUpdate_hasOwnProp = Object.prototype.hasOwnProperty;
var BuilderUniformUpdate_propIsEnum = Object.prototype.propertyIsEnumerable;
var BuilderUniformUpdate_defNormalProp = (obj, key, value) => key in obj ? BuilderUniformUpdate_defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var BuilderUniformUpdate_spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (BuilderUniformUpdate_hasOwnProp.call(b, prop))
      BuilderUniformUpdate_defNormalProp(a, prop, b[prop]);
  if (BuilderUniformUpdate_getOwnPropSymbols)
    for (var prop of BuilderUniformUpdate_getOwnPropSymbols(b)) {
      if (BuilderUniformUpdate_propIsEnum.call(b, prop))
        BuilderUniformUpdate_defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var BuilderUniformUpdate_spreadProps = (a, b) => BuilderUniformUpdate_defProps(a, BuilderUniformUpdate_getOwnPropDescs(b));
var BuilderUniformUpdate_async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};








var AdditionalType = /* @__PURE__ */ ((AdditionalType2) => {
  AdditionalType2["COLOR"] = "color";
  AdditionalType2["TEXTURE"] = "texture";
  return AdditionalType2;
})(AdditionalType || {});
const BuilderUniformUpdate_AVAILABLE_TYPES = [...Gl/* GL_CONNECTION_POINT_TYPES_FOR_CONSTANT */.oq, "color" /* COLOR */, "texture" /* TEXTURE */];
function BuilderUniformUpdate_typedVisibleOptions(type, otherParamVal = {}) {
  const val = BuilderUniformUpdate_AVAILABLE_TYPES.indexOf(type);
  return {
    visibleIf: BuilderUniformUpdate_spreadValues({ type: val }, otherParamVal),
    cook: false,
    callback: (node) => {
      BuilderUniformUpdateMatNode.PARAM_CALLBACK_applyCurrentParam(node);
    }
  };
}
class BuilderUniformUpdateMatParamsConfig extends params_ParamsConfig/* NodeParamsConfig */.yI {
  constructor() {
    super(...arguments);
    /** @param name of the uniform */
    this.uniformName = params_ParamsConfig/* ParamConfig.STRING */.XC.STRING("");
    /** @param type of the uniform */
    this.type = params_ParamsConfig/* ParamConfig.INTEGER */.XC.INTEGER(BuilderUniformUpdate_AVAILABLE_TYPES.indexOf(Gl/* GlConnectionPointType.FLOAT */.Dv.FLOAT), {
      menu: {
        entries: BuilderUniformUpdate_AVAILABLE_TYPES.map((name, value) => ({ name, value }))
      }
    });
    this.bool = params_ParamsConfig/* ParamConfig.BOOLEAN */.XC.BOOLEAN(0, BuilderUniformUpdate_typedVisibleOptions(Gl/* GlConnectionPointType.BOOL */.Dv.BOOL));
    this.int = params_ParamsConfig/* ParamConfig.INTEGER */.XC.INTEGER(0, BuilderUniformUpdate_typedVisibleOptions(Gl/* GlConnectionPointType.INT */.Dv.INT));
    this.float = params_ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(0, BuilderUniformUpdate_typedVisibleOptions(Gl/* GlConnectionPointType.FLOAT */.Dv.FLOAT));
    this.vec2 = params_ParamsConfig/* ParamConfig.VECTOR2 */.XC.VECTOR2([0, 0], BuilderUniformUpdate_typedVisibleOptions(Gl/* GlConnectionPointType.VEC2 */.Dv.VEC2));
    this.vec3 = params_ParamsConfig/* ParamConfig.VECTOR3 */.XC.VECTOR3([0, 0, 0], BuilderUniformUpdate_typedVisibleOptions(Gl/* GlConnectionPointType.VEC3 */.Dv.VEC3));
    this.color = params_ParamsConfig/* ParamConfig.COLOR */.XC.COLOR([0, 0, 0], BuilderUniformUpdate_typedVisibleOptions("color" /* COLOR */));
    this.vec4 = params_ParamsConfig/* ParamConfig.VECTOR4 */.XC.VECTOR4([0, 0, 0, 0], BuilderUniformUpdate_typedVisibleOptions(Gl/* GlConnectionPointType.VEC4 */.Dv.VEC4));
    this.texture = params_ParamsConfig/* ParamConfig.NODE_PATH */.XC.NODE_PATH("", BuilderUniformUpdate_spreadProps(BuilderUniformUpdate_spreadValues({}, BuilderUniformUpdate_typedVisibleOptions("texture" /* TEXTURE */)), {
      nodeSelection: { context: poly_NodeContext/* NodeContext.COP */.sy.COP }
    }));
  }
}
const BuilderUniformUpdate_ParamsConfig = new BuilderUniformUpdateMatParamsConfig();
class BuilderUniformUpdateMatNode extends mat_Base/* UpdateMatNode */.ic {
  constructor() {
    super(...arguments);
    this.paramsConfig = BuilderUniformUpdate_ParamsConfig;
  }
  static type() {
    return "builderUniformUpdate";
  }
  cook(inputMaterials) {
    return BuilderUniformUpdate_async(this, null, function* () {
      const inputMaterial = inputMaterials[0];
      inputMaterial.needsUpdate = true;
      const uniformName = this.pv.uniformName;
      if (uniformName.trim() == "") {
        this.states.error.set(`uniform name is empty`);
        this.setMaterial(inputMaterial);
        return;
      }
      const inputMaterialData = OnBeforeCompile/* OnBeforeCompileDataHandler.getData */.dQ.getData(inputMaterial);
      if (!inputMaterialData) {
        this.states.error.set(`input material does not come from a builder material`);
        this.setMaterial(inputMaterial);
        return;
      }
      const clonedData = (0,OnBeforeCompile/* cloneOnBeforeCompileData */.Gz)(inputMaterialData, {
        clonedParamConfigName: this.pv.uniformName
      });
      const { paramConfigs } = clonedData;
      this._paramConfig = paramConfigs.find((p) => p.name() == this.pv.uniformName);
      if (!this._paramConfig) {
        this.states.error.set(`uniform '${this.pv.uniformName}' not found`);
        this.setMaterial(inputMaterial);
        return;
      }
      yield this._applyCurrentParam();
      (0,OnBeforeCompile/* assignOnBeforeCompileDataAndFunction */.VX)(this.scene(), inputMaterial, clonedData);
      if (inputMaterial.customMaterials) {
        const customMaterialNames = Object.keys(inputMaterial.customMaterials);
        for (const customMaterialName of customMaterialNames) {
          const customMaterial = inputMaterial.customMaterials[customMaterialName];
          if (customMaterial) {
            this._handleCustomMaterial(customMaterial);
          }
        }
      }
      this.setMaterial(inputMaterial);
    });
  }
  _handleCustomMaterial(customMaterial) {
    const inputMaterialData = OnBeforeCompile/* OnBeforeCompileDataHandler.getData */.dQ.getData(customMaterial);
    if (!inputMaterialData) {
      return;
    }
    const clonedData = (0,OnBeforeCompile/* cloneOnBeforeCompileData */.Gz)(inputMaterialData, {
      clonedParamConfigName: this.pv.uniformName,
      clonedParamConfig: this._paramConfig
    });
    (0,OnBeforeCompile/* assignOnBeforeCompileDataAndFunction */.VX)(this.scene(), customMaterial, clonedData);
  }
  setType(type) {
    this.p.type.set(BuilderUniformUpdate_AVAILABLE_TYPES.indexOf(type));
  }
  static PARAM_CALLBACK_applyCurrentParam(node) {
    node._applyCurrentParam();
  }
  _applyCurrentParam() {
    return BuilderUniformUpdate_async(this, null, function* () {
      if (!this._paramConfig) {
        return;
      }
      const type = BuilderUniformUpdate_AVAILABLE_TYPES[this.pv.type];
      const uniform = this._paramConfig.uniform();
      switch (type) {
        case Gl/* GlConnectionPointType.BOOL */.Dv.BOOL: {
          if ((0,Type/* isBoolean */.jn)(uniform.value)) {
            uniform.value = this.pv.bool;
          } else {
            this.states.error.set("uniform is not a boolean");
          }
          return;
        }
        case Gl/* GlConnectionPointType.INT */.Dv.INT: {
          if ((0,Type/* isNumber */.hj)(uniform.value)) {
            uniform.value = this.pv.int;
          } else {
            this.states.error.set("uniform is not an int");
          }
          return;
        }
        case Gl/* GlConnectionPointType.FLOAT */.Dv.FLOAT: {
          if ((0,Type/* isNumber */.hj)(uniform.value)) {
            uniform.value = this.pv.float;
          } else {
            this.states.error.set("uniform is not a float");
          }
          return;
        }
        case Gl/* GlConnectionPointType.VEC2 */.Dv.VEC2: {
          if (uniform.value instanceof three_module.Vector2) {
            uniform.value = this.pv.vec2;
          } else {
            this.states.error.set("uniform is not a vec2");
          }
          return;
        }
        case Gl/* GlConnectionPointType.VEC3 */.Dv.VEC3: {
          if (uniform.value instanceof three_module.Vector3) {
            uniform.value = this.pv.vec3;
          } else {
            this.states.error.set("uniform is not a vec3");
          }
          return;
        }
        case Gl/* GlConnectionPointType.VEC4 */.Dv.VEC4: {
          if (uniform.value instanceof three_module.Vector4) {
            uniform.value = this.pv.vec4;
          } else {
            this.states.error.set("uniform is not a vec4");
          }
          return;
        }
        case "color" /* COLOR */: {
          if (uniform.value instanceof three_module.Color) {
            uniform.value = this.pv.color;
          } else {
            this.states.error.set("uniform is not a color");
          }
          return;
        }
        case "texture" /* TEXTURE */: {
          yield this._updateTexture();
          return;
        }
      }
    });
  }
  _updateTexture() {
    return BuilderUniformUpdate_async(this, null, function* () {
      if (!this._paramConfig) {
        return;
      }
      const textureNode = this.p.texture.value.nodeWithContext(poly_NodeContext/* NodeContext.COP */.sy.COP);
      if (textureNode) {
        const container = yield textureNode.compute();
        const texture = container.texture();
        this._paramConfig.uniform().value = texture;
      } else {
        this._paramConfig.uniform().value = null;
      }
    });
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/mat/ClippingPlane.ts

var ClippingPlane_async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};



class ClippingPlaneMatParamsConfig extends params_ParamsConfig/* NodeParamsConfig */.yI {
  constructor() {
    super(...arguments);
    /** @param plane normal */
    this.normal = params_ParamsConfig/* ParamConfig.VECTOR3 */.XC.VECTOR3([0, 1, 0]);
    /** @param plane constant */
    this.constant = params_ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(0, {
      range: [-1, 1],
      rangeLocked: [false, false]
    });
  }
}
const ClippingPlane_ParamsConfig = new ClippingPlaneMatParamsConfig();
class ClippingPlaneMatNode extends mat_Base/* UpdateMatNode */.ic {
  constructor() {
    super(...arguments);
    this.paramsConfig = ClippingPlane_ParamsConfig;
    this._plane = new three_module.Plane();
  }
  static type() {
    return "clippingPlane";
  }
  cook(inputMaterials) {
    return ClippingPlane_async(this, null, function* () {
      const inputMaterial = inputMaterials[0];
      this._plane.normal.copy(this.pv.normal);
      this._plane.constant = this.pv.constant;
      if (!inputMaterial.clippingPlanes) {
        inputMaterial.clippingPlanes = [];
      }
      inputMaterial.clippingPlanes.push(this._plane);
      this.setMaterial(inputMaterial);
    });
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/mat/ClipProperties.ts

var ClipProperties_async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};


class ClipPropertiesMatParamsConfig extends params_ParamsConfig/* NodeParamsConfig */.yI {
  constructor() {
    super(...arguments);
    /** @param clipIntersection */
    this.clipIntersection = params_ParamsConfig/* ParamConfig.BOOLEAN */.XC.BOOLEAN(0);
    /** @param clipShadows */
    this.clipShadows = params_ParamsConfig/* ParamConfig.BOOLEAN */.XC.BOOLEAN(1);
  }
}
const ClipProperties_ParamsConfig = new ClipPropertiesMatParamsConfig();
class ClipPropertiesMatNode extends mat_Base/* UpdateMatNode */.ic {
  constructor() {
    super(...arguments);
    this.paramsConfig = ClipProperties_ParamsConfig;
  }
  static type() {
    return "clipProperties";
  }
  cook(inputMaterials) {
    return ClipProperties_async(this, null, function* () {
      const inputMaterial = inputMaterials[0];
      inputMaterial.clipIntersection = this.pv.clipIntersection;
      inputMaterial.clipShadows = this.pv.clipShadows;
      this.setMaterial(inputMaterial);
    });
  }
}

// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/nodes/mat/Code.ts
var Code = __webpack_require__(64787);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/nodes/mat/LineBasic.ts
var LineBasic = __webpack_require__(87000);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/nodes/mat/utils/UniformsTransparencyController.ts
var UniformsTransparencyController = __webpack_require__(70573);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/nodes/mat/utils/AdvancedCommonController.ts
var AdvancedCommonController = __webpack_require__(90476);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/nodes/mat/_BaseBuilder.ts + 1 modules
var _BaseBuilder = __webpack_require__(88303);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/nodes/mat/utils/DefaultFolder.ts
var DefaultFolder = __webpack_require__(99233);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/nodes/mat/utils/AdvancedFolder.ts
var AdvancedFolder = __webpack_require__(73777);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/poly/registers/nodes/types/Mat.ts
var Mat = __webpack_require__(41545);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/core/geometry/Material.ts
var geometry_Material = __webpack_require__(62026);
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/mat/utils/customMaterials/CustomMaterialLine.ts








function CustomMaterialLineParamConfig(Base) {
  return class Mixin extends Base {
    constructor() {
      super(...arguments);
      /** @param toggle off to choose which customMaterials will be generated */
      this.overrideCustomMaterials = params_ParamsConfig/* ParamConfig.BOOLEAN */.XC.BOOLEAN(0);
      /** @param distance */
      this.createCustomMatDistance = params_ParamsConfig/* ParamConfig.BOOLEAN */.XC.BOOLEAN(1, {
        visibleIf: { overrideCustomMaterials: 1 }
      });
      /** @param depth */
      this.createCustomMatDepth = params_ParamsConfig/* ParamConfig.BOOLEAN */.XC.BOOLEAN(1, {
        visibleIf: { overrideCustomMaterials: 1 }
      });
      /** @param depth DOF */
      this.createCustomMatDepthDOF = params_ParamsConfig/* ParamConfig.BOOLEAN */.XC.BOOLEAN(1, {
        visibleIf: { overrideCustomMaterials: 1 }
      });
    }
  };
}
class CustomMaterialLineParamsConfig extends CustomMaterialLineParamConfig((0,_BaseBuilder/* BaseBuilderParamConfig */.I)(params_ParamsConfig/* NodeParamsConfig */.yI)) {
}
class CustomMaterialMatNode extends (/* unused pure expression or super */ null && (TypedMatNode)) {
}
function materialLineAssemblerCustomMaterialRequested(node, customName) {
  if (!(0,Type/* isBooleanTrue */.bI)(node.pv.overrideCustomMaterials)) {
    return true;
  }
  switch (customName) {
    case geometry_Material/* CustomMaterialName.DISTANCE */.RJ.DISTANCE: {
      return (0,Type/* isBooleanTrue */.bI)(node.pv.createCustomMatDistance);
    }
    case geometry_Material/* CustomMaterialName.DEPTH */.RJ.DEPTH: {
      return (0,Type/* isBooleanTrue */.bI)(node.pv.createCustomMatDepth);
    }
    case geometry_Material/* CustomMaterialName.DEPTH_DOF */.RJ.DEPTH_DOF: {
      return (0,Type/* isBooleanTrue */.bI)(node.pv.createCustomMatDepthDOF);
    }
  }
  Assert/* TypeAssert.unreachable */.f.unreachable(customName);
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/mat/LineBasicBuilder.ts

var LineBasicBuilder_async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};










class LineBasicBuilderMatParamsConfig extends CustomMaterialLineParamConfig(
  (0,AdvancedCommonController/* AdvancedCommonParamConfig */.E)(
    (0,_BaseBuilder/* BaseBuilderParamConfig */.I)(
      /* advanced */
      (0,AdvancedFolder/* AdvancedFolderParamConfig */.A)(
        (0,UniformsTransparencyController/* UniformsTransparencyParamConfig */.F)((0,DefaultFolder/* DefaultFolderParamConfig */.b)(params_ParamsConfig/* NodeParamsConfig */.yI))
      )
    )
  )
) {
  constructor() {
    super(...arguments);
    this.linewidth = params_ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(1, {
      range: [0, 10],
      rangeLocked: [true, false]
    });
  }
}
const LineBasicBuilder_ParamsConfig = new LineBasicBuilderMatParamsConfig();
class LineBasicBuilderMatNode extends _BaseBuilder/* TypedBuilderMatNode */.T {
  constructor() {
    super(...arguments);
    this.paramsConfig = LineBasicBuilder_ParamsConfig;
    this.controllers = {
      advancedCommon: new AdvancedCommonController/* AdvancedCommonController */.h(this),
      uniformTransparency: new UniformsTransparencyController/* UniformsTransparencyController */.N(this)
    };
    this.controllersList = Object.values(this.controllers);
  }
  static type() {
    return Mat/* MatType.LINE_BASIC_BUILDER */.M.LINE_BASIC_BUILDER;
  }
  usedAssembler() {
    return _BaseRegister/* AssemblerName.GL_LINE */.Q.GL_LINE;
  }
  _createAssemblerController() {
    return Poly/* Poly.assemblersRegister.assembler */.L.assemblersRegister.assembler(this, this.usedAssembler());
  }
  customMaterialRequested(customName) {
    return materialLineAssemblerCustomMaterialRequested(this, customName);
  }
  cook() {
    return LineBasicBuilder_async(this, null, function* () {
      this._material = this._material || this.createMaterial();
      yield Promise.all(this.controllersPromises(this._material));
      this.compileIfRequired(this._material);
      this._material.linewidth = this.pv.linewidth;
      this.setMaterial(this._material);
    });
  }
}

// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/nodes/mat/MeshBasic.ts
var MeshBasic = __webpack_require__(94978);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/nodes/mat/utils/TextureMapController.ts
var TextureMapController = __webpack_require__(87732);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/nodes/mat/utils/TextureAlphaMapController.ts
var TextureAlphaMapController = __webpack_require__(71607);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/nodes/mat/utils/TextureAOMapController.ts
var TextureAOMapController = __webpack_require__(94135);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/nodes/mat/utils/UniformsFogController.ts
var UniformsFogController = __webpack_require__(9161);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/nodes/mat/utils/WireframeShaderMaterialController.ts
var WireframeShaderMaterialController = __webpack_require__(91419);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/nodes/mat/utils/TextureEnvMapSimpleController.ts
var TextureEnvMapSimpleController = __webpack_require__(97564);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/nodes/mat/utils/TexturesFolder.ts
var TexturesFolder = __webpack_require__(45231);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/nodes/mat/utils/customMaterials/CustomMaterialMesh.ts
var CustomMaterialMesh = __webpack_require__(92874);
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/mat/MeshBasicBuilder.ts

var MeshBasicBuilder_async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};

















class MeshBasicBuilderMatParamsConfig extends (0,CustomMaterialMesh/* CustomMaterialMeshParamConfig */.B)(
  (0,UniformsFogController/* FogParamConfig */.N)(
    (0,WireframeShaderMaterialController/* WireframeShaderMaterialParamsConfig */.j)(
      (0,AdvancedCommonController/* AdvancedCommonParamConfig */.E)(
        (0,_BaseBuilder/* BaseBuilderParamConfig */.I)(
          /* advanced */
          (0,AdvancedFolder/* AdvancedFolderParamConfig */.A)(
            (0,TextureEnvMapSimpleController/* EnvMapSimpleParamConfig */.R)(
              (0,TextureAOMapController/* AOMapParamConfig */.T)(
                (0,TextureAlphaMapController/* AlphaMapParamConfig */.T)(
                  (0,TextureMapController/* MapParamConfig */.D)(
                    /* textures */
                    (0,TexturesFolder/* TexturesFolderParamConfig */.o)(
                      (0,UniformsTransparencyController/* UniformsTransparencyParamConfig */.F)((0,DefaultFolder/* DefaultFolderParamConfig */.b)(params_ParamsConfig/* NodeParamsConfig */.yI))
                    )
                  )
                )
              )
            )
          )
        )
      )
    )
  )
) {
}
const MeshBasicBuilder_ParamsConfig = new MeshBasicBuilderMatParamsConfig();
class MeshBasicBuilderMatNode extends _BaseBuilder/* TypedBuilderMatNode */.T {
  constructor() {
    super(...arguments);
    this.paramsConfig = MeshBasicBuilder_ParamsConfig;
    this.controllers = {
      advancedCommon: new AdvancedCommonController/* AdvancedCommonController */.h(this),
      alphaMap: new TextureAlphaMapController/* TextureAlphaMapController */.s(this),
      aoMap: new TextureAOMapController/* TextureAOMapController */.Z(this),
      envMap: new TextureEnvMapSimpleController/* TextureEnvMapSimpleController */.z(this),
      uniformFog: new UniformsFogController/* UniformFogController */.z(this),
      map: new TextureMapController/* TextureMapController */.g(this),
      uniformTransparency: new UniformsTransparencyController/* UniformsTransparencyController */.N(this),
      wireframeShader: new WireframeShaderMaterialController/* WireframeShaderMaterialController */.w(this)
    };
    this.controllersList = Object.values(this.controllers);
  }
  static type() {
    return Mat/* MatType.MESH_BASIC_BUILDER */.M.MESH_BASIC_BUILDER;
  }
  usedAssembler() {
    return _BaseRegister/* AssemblerName.GL_MESH_BASIC */.Q.GL_MESH_BASIC;
  }
  _createAssemblerController() {
    return Poly/* Poly.assemblersRegister.assembler */.L.assemblersRegister.assembler(this, this.usedAssembler());
  }
  customMaterialRequested(customName) {
    return (0,CustomMaterialMesh/* materialMeshAssemblerCustomMaterialRequested */.F)(this, customName);
  }
  cook() {
    return MeshBasicBuilder_async(this, null, function* () {
      this._material = this._material || this.createMaterial();
      yield Promise.all(this.controllersPromises(this._material));
      this.compileIfRequired(this._material);
      this._material.needsUpdate = true;
      this.setMaterial(this._material);
    });
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/mat/MeshDepth.ts

var MeshDepth_async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};





class MeshDepthMatParamsConfig extends (0,AdvancedCommonController/* AdvancedCommonParamConfig */.E)(params_ParamsConfig/* NodeParamsConfig */.yI) {
}
const MeshDepth_ParamsConfig = new MeshDepthMatParamsConfig();
class MeshDepthMatNode extends mat_Base/* PrimitiveMatNode */.Q_ {
  constructor() {
    super(...arguments);
    this.paramsConfig = MeshDepth_ParamsConfig;
    this.controllers = {
      advancedCommon: new AdvancedCommonController/* AdvancedCommonController */.h(this)
    };
    this.controllersList = Object.values(this.controllers);
  }
  static type() {
    return "meshDepth";
  }
  createMaterial() {
    return new three_module.MeshDepthMaterial({
      side: three_module.FrontSide
    });
  }
  cook() {
    return MeshDepth_async(this, null, function* () {
      this._material = this._material || this.createMaterial();
      yield Promise.all(this.controllersPromises(this._material));
      this.setMaterial(this._material);
    });
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/mat/MeshDepthBuilder.ts

var MeshDepthBuilder_async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};







class MeshDepthBuilderMatParamsConfig extends (0,AdvancedCommonController/* AdvancedCommonParamConfig */.E)(
  (0,_BaseBuilder/* BaseBuilderParamConfig */.I)((0,UniformsTransparencyController/* UniformsTransparencyParamConfig */.F)(params_ParamsConfig/* NodeParamsConfig */.yI))
) {
}
const MeshDepthBuilder_ParamsConfig = new MeshDepthBuilderMatParamsConfig();
class MeshDepthBuilderMatNode extends _BaseBuilder/* TypedBuilderMatNode */.T {
  constructor() {
    super(...arguments);
    this.paramsConfig = MeshDepthBuilder_ParamsConfig;
    this.controllers = {
      advancedCommon: new AdvancedCommonController/* AdvancedCommonController */.h(this),
      uniformTransparency: new UniformsTransparencyController/* UniformsTransparencyController */.N(this)
    };
    this.controllersList = Object.values(this.controllers);
  }
  static type() {
    return Mat/* MatType.MESH_DEPTH_BUILDER */.M.MESH_DEPTH_BUILDER;
  }
  usedAssembler() {
    return _BaseRegister/* AssemblerName.GL_MESH_DEPTH */.Q.GL_MESH_DEPTH;
  }
  _createAssemblerController() {
    return Poly/* Poly.assemblersRegister.assembler */.L.assemblersRegister.assembler(this, this.usedAssembler());
  }
  customMaterialRequested(customName) {
    return false;
  }
  cook() {
    return MeshDepthBuilder_async(this, null, function* () {
      this._material = this._material || this.createMaterial();
      yield Promise.all(this.controllersPromises(this._material));
      this.compileIfRequired(this._material);
      this.setMaterial(this._material);
    });
  }
}

// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/nodes/mat/MeshLambert.ts
var MeshLambert = __webpack_require__(75853);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/nodes/mat/utils/TextureLightMapController.ts
var TextureLightMapController = __webpack_require__(28985);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/nodes/mat/utils/TextureEmissiveMapController.ts
var TextureEmissiveMapController = __webpack_require__(69228);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/nodes/mat/utils/PCSSController.ts + 2 modules
var PCSSController = __webpack_require__(8745);
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/mat/MeshLambertBuilder.ts

var MeshLambertBuilder_async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};




















class MeshLambertBuilderMatParamsConfig extends (0,CustomMaterialMesh/* CustomMaterialMeshParamConfig */.B)(
  (0,PCSSController/* PCSSParamConfig */.y)(
    (0,UniformsFogController/* FogParamConfig */.N)(
      (0,WireframeShaderMaterialController/* WireframeShaderMaterialParamsConfig */.j)(
        (0,AdvancedCommonController/* AdvancedCommonParamConfig */.E)(
          (0,_BaseBuilder/* BaseBuilderParamConfig */.I)(
            /* advanced */
            (0,AdvancedFolder/* AdvancedFolderParamConfig */.A)(
              (0,TextureLightMapController/* LightMapParamConfig */.T)(
                (0,TextureEnvMapSimpleController/* EnvMapSimpleParamConfig */.R)(
                  (0,TextureEmissiveMapController/* EmissiveMapParamConfig */.f)(
                    (0,TextureAOMapController/* AOMapParamConfig */.T)(
                      (0,TextureAlphaMapController/* AlphaMapParamConfig */.T)(
                        (0,TextureMapController/* MapParamConfig */.D)(
                          /* textures */
                          (0,TexturesFolder/* TexturesFolderParamConfig */.o)(
                            (0,UniformsTransparencyController/* UniformsTransparencyParamConfig */.F)(
                              (0,DefaultFolder/* DefaultFolderParamConfig */.b)(params_ParamsConfig/* NodeParamsConfig */.yI)
                            )
                          )
                        )
                      )
                    )
                  )
                )
              )
            )
          )
        )
      )
    )
  )
) {
}
const MeshLambertBuilder_ParamsConfig = new MeshLambertBuilderMatParamsConfig();
class MeshLambertBuilderMatNode extends _BaseBuilder/* TypedBuilderMatNode */.T {
  constructor() {
    super(...arguments);
    this.paramsConfig = MeshLambertBuilder_ParamsConfig;
    this.controllers = {
      advancedCommon: new AdvancedCommonController/* AdvancedCommonController */.h(this),
      alphaMap: new TextureAlphaMapController/* TextureAlphaMapController */.s(this),
      aoMap: new TextureAOMapController/* TextureAOMapController */.Z(this),
      emissiveMap: new TextureEmissiveMapController/* TextureEmissiveMapController */.z(this),
      envMap: new TextureEnvMapSimpleController/* TextureEnvMapSimpleController */.z(this),
      lightMap: new TextureLightMapController/* TextureLightMapController */.$(this),
      map: new TextureMapController/* TextureMapController */.g(this),
      PCSS: new PCSSController/* PCSSController */.P(this),
      uniformFog: new UniformsFogController/* UniformFogController */.z(this),
      uniformTransparency: new UniformsTransparencyController/* UniformsTransparencyController */.N(this),
      wireframeShader: new WireframeShaderMaterialController/* WireframeShaderMaterialController */.w(this)
    };
    this.controllersList = Object.values(this.controllers);
  }
  static type() {
    return Mat/* MatType.MESH_LAMBERT_BUILDER */.M.MESH_LAMBERT_BUILDER;
  }
  usedAssembler() {
    return _BaseRegister/* AssemblerName.GL_MESH_LAMBERT */.Q.GL_MESH_LAMBERT;
  }
  _createAssemblerController() {
    return Poly/* Poly.assemblersRegister.assembler */.L.assemblersRegister.assembler(this, this.usedAssembler());
  }
  customMaterialRequested(customName) {
    return (0,CustomMaterialMesh/* materialMeshAssemblerCustomMaterialRequested */.F)(this, customName);
  }
  cook() {
    return MeshLambertBuilder_async(this, null, function* () {
      this._material = this._material || this.createMaterial();
      yield Promise.all(this.controllersPromises(this._material));
      this.compileIfRequired(this._material);
      this.setMaterial(this._material);
    });
  }
}

// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/nodes/mat/MeshMatcap.ts + 1 modules
var MeshMatcap = __webpack_require__(40453);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/nodes/mat/MeshNormal.ts
var MeshNormal = __webpack_require__(97886);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/nodes/mat/MeshPhong.ts
var MeshPhong = __webpack_require__(69312);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/nodes/mat/utils/TextureBumpMapController.ts
var TextureBumpMapController = __webpack_require__(89328);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/nodes/mat/utils/TextureDisplacementMapController.ts
var TextureDisplacementMapController = __webpack_require__(70967);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/nodes/mat/utils/TextureNormalMapController.ts
var TextureNormalMapController = __webpack_require__(19767);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/nodes/mat/utils/TextureSpecularMapController.ts
var TextureSpecularMapController = __webpack_require__(36725);
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/mat/MeshPhongBuilder.ts

var MeshPhongBuilder_async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};
























class MeshPhongBuilderMatParamsConfig extends (0,CustomMaterialMesh/* CustomMaterialMeshParamConfig */.B)(
  (0,PCSSController/* PCSSParamConfig */.y)(
    (0,UniformsFogController/* FogParamConfig */.N)(
      (0,WireframeShaderMaterialController/* WireframeShaderMaterialParamsConfig */.j)(
        (0,AdvancedCommonController/* AdvancedCommonParamConfig */.E)(
          (0,_BaseBuilder/* BaseBuilderParamConfig */.I)(
            /* advanced */
            (0,AdvancedFolder/* AdvancedFolderParamConfig */.A)(
              (0,TextureSpecularMapController/* SpecularMapParamConfig */.E)(
                (0,TextureNormalMapController/* NormalMapParamConfig */.$)(
                  (0,TextureLightMapController/* LightMapParamConfig */.T)(
                    (0,TextureEnvMapSimpleController/* EnvMapSimpleParamConfig */.R)(
                      (0,TextureEmissiveMapController/* EmissiveMapParamConfig */.f)(
                        (0,TextureDisplacementMapController/* DisplacementMapParamConfig */.n)(
                          (0,TextureBumpMapController/* BumpMapParamConfig */.w)(
                            (0,TextureAOMapController/* AOMapParamConfig */.T)(
                              (0,TextureAlphaMapController/* AlphaMapParamConfig */.T)(
                                (0,TextureMapController/* MapParamConfig */.D)(
                                  /* textures */
                                  (0,TexturesFolder/* TexturesFolderParamConfig */.o)(
                                    (0,UniformsTransparencyController/* UniformsTransparencyParamConfig */.F)(
                                      (0,DefaultFolder/* DefaultFolderParamConfig */.b)(params_ParamsConfig/* NodeParamsConfig */.yI)
                                    )
                                  )
                                )
                              )
                            )
                          )
                        )
                      )
                    )
                  )
                )
              )
            )
          )
        )
      )
    )
  )
) {
}
const MeshPhongBuilder_ParamsConfig = new MeshPhongBuilderMatParamsConfig();
class MeshPhongBuilderMatNode extends _BaseBuilder/* TypedBuilderMatNode */.T {
  constructor() {
    super(...arguments);
    this.paramsConfig = MeshPhongBuilder_ParamsConfig;
    this.controllers = {
      advancedCommon: new AdvancedCommonController/* AdvancedCommonController */.h(this),
      alphaMap: new TextureAlphaMapController/* TextureAlphaMapController */.s(this),
      aoMap: new TextureAOMapController/* TextureAOMapController */.Z(this),
      bumpMap: new TextureBumpMapController/* TextureBumpMapController */.T(this),
      displacementMap: new TextureDisplacementMapController/* TextureDisplacementMapController */.u(this),
      emissiveMap: new TextureEmissiveMapController/* TextureEmissiveMapController */.z(this),
      envMap: new TextureEnvMapSimpleController/* TextureEnvMapSimpleController */.z(this),
      lightMap: new TextureLightMapController/* TextureLightMapController */.$(this),
      map: new TextureMapController/* TextureMapController */.g(this),
      normalMap: new TextureNormalMapController/* TextureNormalMapController */.w(this),
      specularMap: new TextureSpecularMapController/* TextureSpecularMapController */.M(this),
      PCSS: new PCSSController/* PCSSController */.P(this),
      uniformFog: new UniformsFogController/* UniformFogController */.z(this),
      uniformTransparency: new UniformsTransparencyController/* UniformsTransparencyController */.N(this),
      wireframeShader: new WireframeShaderMaterialController/* WireframeShaderMaterialController */.w(this)
    };
    this.controllersList = Object.values(this.controllers);
  }
  static type() {
    return Mat/* MatType.MESH_PHONG_BUILDER */.M.MESH_PHONG_BUILDER;
  }
  usedAssembler() {
    return _BaseRegister/* AssemblerName.GL_MESH_PHONG */.Q.GL_MESH_PHONG;
  }
  _createAssemblerController() {
    return Poly/* Poly.assemblersRegister.assembler */.L.assemblersRegister.assembler(this, this.usedAssembler());
  }
  customMaterialRequested(customName) {
    return (0,CustomMaterialMesh/* materialMeshAssemblerCustomMaterialRequested */.F)(this, customName);
  }
  cook() {
    return MeshPhongBuilder_async(this, null, function* () {
      this._material = this._material || this.createMaterial();
      yield Promise.all(this.controllersPromises(this._material));
      this.compileIfRequired(this._material);
      this.setMaterial(this._material);
    });
  }
}

// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/nodes/mat/MeshPhysical.ts
var MeshPhysical = __webpack_require__(65349);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/nodes/mat/MeshPhysicalBuilder.ts
var MeshPhysicalBuilder = __webpack_require__(80388);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/nodes/mat/MeshStandard.ts
var MeshStandard = __webpack_require__(13076);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/nodes/mat/MeshStandardBuilder.ts
var MeshStandardBuilder = __webpack_require__(53950);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/nodes/mat/MeshToon.ts
var MeshToon = __webpack_require__(46584);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/nodes/mat/utils/TextureGradientMapController.ts
var TextureGradientMapController = __webpack_require__(69602);
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/mat/MeshToonBuilder.ts

var MeshToonBuilder_async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};























class MeshToonBuilderMatParamsConfig extends (0,CustomMaterialMesh/* CustomMaterialMeshParamConfig */.B)(
  (0,PCSSController/* PCSSParamConfig */.y)(
    (0,UniformsFogController/* FogParamConfig */.N)(
      (0,WireframeShaderMaterialController/* WireframeShaderMaterialParamsConfig */.j)(
        (0,AdvancedCommonController/* AdvancedCommonParamConfig */.E)(
          (0,_BaseBuilder/* BaseBuilderParamConfig */.I)(
            /* advanced */
            (0,AdvancedFolder/* AdvancedFolderParamConfig */.A)(
              (0,TextureNormalMapController/* NormalMapParamConfig */.$)(
                (0,TextureLightMapController/* LightMapParamConfig */.T)(
                  (0,TextureGradientMapController/* GradientMapParamConfig */.P)(
                    (0,TextureEmissiveMapController/* EmissiveMapParamConfig */.f)(
                      (0,TextureDisplacementMapController/* DisplacementMapParamConfig */.n)(
                        (0,TextureBumpMapController/* BumpMapParamConfig */.w)(
                          (0,TextureAOMapController/* AOMapParamConfig */.T)(
                            (0,TextureAlphaMapController/* AlphaMapParamConfig */.T)(
                              (0,TextureMapController/* MapParamConfig */.D)(
                                /* textures */
                                (0,TexturesFolder/* TexturesFolderParamConfig */.o)(
                                  (0,UniformsTransparencyController/* UniformsTransparencyParamConfig */.F)(
                                    (0,DefaultFolder/* DefaultFolderParamConfig */.b)(params_ParamsConfig/* NodeParamsConfig */.yI)
                                  )
                                )
                              )
                            )
                          )
                        )
                      )
                    )
                  )
                )
              )
            )
          )
        )
      )
    )
  )
) {
}
const MeshToonBuilder_ParamsConfig = new MeshToonBuilderMatParamsConfig();
class MeshToonBuilderMatNode extends _BaseBuilder/* TypedBuilderMatNode */.T {
  constructor() {
    super(...arguments);
    this.paramsConfig = MeshToonBuilder_ParamsConfig;
    this.controllers = {
      advancedCommon: new AdvancedCommonController/* AdvancedCommonController */.h(this),
      alphaMap: new TextureAlphaMapController/* TextureAlphaMapController */.s(this),
      aoMap: new TextureAOMapController/* TextureAOMapController */.Z(this),
      bumpMap: new TextureBumpMapController/* TextureBumpMapController */.T(this),
      displacementMap: new TextureDisplacementMapController/* TextureDisplacementMapController */.u(this),
      emissiveMap: new TextureEmissiveMapController/* TextureEmissiveMapController */.z(this),
      gradientMap: new TextureGradientMapController/* TextureGradientMapController */.o(this),
      lightMap: new TextureLightMapController/* TextureLightMapController */.$(this),
      map: new TextureMapController/* TextureMapController */.g(this),
      normalMap: new TextureNormalMapController/* TextureNormalMapController */.w(this),
      PCSS: new PCSSController/* PCSSController */.P(this),
      uniformFog: new UniformsFogController/* UniformFogController */.z(this),
      uniformTransparency: new UniformsTransparencyController/* UniformsTransparencyController */.N(this),
      wireframeShader: new WireframeShaderMaterialController/* WireframeShaderMaterialController */.w(this)
    };
    this.controllersList = Object.values(this.controllers);
  }
  static type() {
    return Mat/* MatType.MESH_TOON_BUILDER */.M.MESH_TOON_BUILDER;
  }
  usedAssembler() {
    return _BaseRegister/* AssemblerName.GL_MESH_TOON */.Q.GL_MESH_TOON;
  }
  _createAssemblerController() {
    return Poly/* Poly.assemblersRegister.assembler */.L.assemblersRegister.assembler(this, this.usedAssembler());
  }
  customMaterialRequested(customName) {
    return (0,CustomMaterialMesh/* materialMeshAssemblerCustomMaterialRequested */.F)(this, customName);
  }
  cook() {
    return MeshToonBuilder_async(this, null, function* () {
      this._material = this._material || this.createMaterial();
      yield Promise.all(this.controllersPromises(this._material));
      this.compileIfRequired(this._material);
      this.setMaterial(this._material);
    });
  }
}

// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/nodes/mat/Points.ts
var Points = __webpack_require__(83760);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/nodes/mat/utils/PointsSizeController.ts
var PointsSizeController = __webpack_require__(46049);
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/mat/utils/customMaterials/CustomMaterialPoints.ts








function CustomMaterialPointsParamConfig(Base) {
  return class Mixin extends Base {
    constructor() {
      super(...arguments);
      /** @param toggle off to choose which customMaterials will be generated */
      this.overrideCustomMaterials = params_ParamsConfig/* ParamConfig.BOOLEAN */.XC.BOOLEAN(0);
      /** @param distance */
      this.createCustomMatDistance = params_ParamsConfig/* ParamConfig.BOOLEAN */.XC.BOOLEAN(1, {
        visibleIf: { overrideCustomMaterials: 1 }
      });
      /** @param depth */
      this.createCustomMatDepth = params_ParamsConfig/* ParamConfig.BOOLEAN */.XC.BOOLEAN(1, {
        visibleIf: { overrideCustomMaterials: 1 }
      });
      /** @param depth DOF */
      this.createCustomMatDepthDOF = params_ParamsConfig/* ParamConfig.BOOLEAN */.XC.BOOLEAN(1, {
        visibleIf: { overrideCustomMaterials: 1 }
      });
    }
  };
}
class CustomMaterialPointsParamsConfig extends CustomMaterialPointsParamConfig(
  (0,_BaseBuilder/* BaseBuilderParamConfig */.I)(params_ParamsConfig/* NodeParamsConfig */.yI)
) {
}
class CustomMaterialPoints_CustomMaterialMatNode extends (/* unused pure expression or super */ null && (TypedMatNode)) {
}
function materialPointsAssemblerCustomMaterialRequested(node, customName) {
  const param = node.p.overrideCustomMaterials;
  if (!param) {
    console.warn(`param overrideCustomMaterials not found on ${node.path()}, creating all customMaterials`);
    return true;
  }
  if (!(0,Type/* isBooleanTrue */.bI)(node.pv.overrideCustomMaterials)) {
    return true;
  }
  switch (customName) {
    case geometry_Material/* CustomMaterialName.DISTANCE */.RJ.DISTANCE: {
      return (0,Type/* isBooleanTrue */.bI)(node.pv.createCustomMatDistance);
    }
    case geometry_Material/* CustomMaterialName.DEPTH */.RJ.DEPTH: {
      return (0,Type/* isBooleanTrue */.bI)(node.pv.createCustomMatDepth);
    }
    case geometry_Material/* CustomMaterialName.DEPTH_DOF */.RJ.DEPTH_DOF: {
      return (0,Type/* isBooleanTrue */.bI)(node.pv.createCustomMatDepthDOF);
    }
  }
  Assert/* TypeAssert.unreachable */.f.unreachable(customName);
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/mat/PointsBuilder.ts

var PointsBuilder_async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};












class PointsBuilderMatParamsConfig extends CustomMaterialPointsParamConfig(
  (0,UniformsFogController/* FogParamConfig */.N)(
    (0,AdvancedCommonController/* AdvancedCommonParamConfig */.E)(
      (0,_BaseBuilder/* BaseBuilderParamConfig */.I)(
        /* advanced */
        (0,AdvancedFolder/* AdvancedFolderParamConfig */.A)(
          (0,UniformsTransparencyController/* UniformsTransparencyParamConfig */.F)((0,PointsSizeController/* PointsParamConfig */.v)((0,DefaultFolder/* DefaultFolderParamConfig */.b)(params_ParamsConfig/* NodeParamsConfig */.yI)))
        )
      )
    )
  )
) {
}
const PointsBuilder_ParamsConfig = new PointsBuilderMatParamsConfig();
class PointsBuilderMatNode extends _BaseBuilder/* TypedBuilderMatNode */.T {
  constructor() {
    super(...arguments);
    this.paramsConfig = PointsBuilder_ParamsConfig;
    this.controllers = {
      advancedCommon: new AdvancedCommonController/* AdvancedCommonController */.h(this),
      pointsSize: new PointsSizeController/* PointsSizeController */.E(this),
      uniformFog: new UniformsFogController/* UniformFogController */.z(this),
      uniformTransparency: new UniformsTransparencyController/* UniformsTransparencyController */.N(this)
    };
    this.controllersList = Object.values(this.controllers);
  }
  static type() {
    return Mat/* MatType.POINTS_BUILDER */.M.POINTS_BUILDER;
  }
  usedAssembler() {
    return _BaseRegister/* AssemblerName.GL_POINTS */.Q.GL_POINTS;
  }
  _createAssemblerController() {
    return Poly/* Poly.assemblersRegister.assembler */.L.assemblersRegister.assembler(this, this.usedAssembler());
  }
  customMaterialRequested(customName) {
    return materialPointsAssemblerCustomMaterialRequested(this, customName);
  }
  cook() {
    return PointsBuilder_async(this, null, function* () {
      this._material = this._material || this.createMaterial();
      yield Promise.all(this.controllersPromises(this._material));
      this.compileIfRequired(this._material);
      this.setMaterial(this._material);
    });
  }
}

// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/nodes/mat/RayMarchingBuilder.ts + 2 modules
var RayMarchingBuilder = __webpack_require__(13839);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/nodes/mat/utils/ColorsController.ts
var ColorsController = __webpack_require__(40330);
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/mat/Shadow.ts

var Shadow_async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};







class ShadowMatParamsConfig extends (0,AdvancedCommonController/* AdvancedCommonParamConfig */.E)((0,ColorsController/* ColorParamConfig */.Pn)(params_ParamsConfig/* NodeParamsConfig */.yI)) {
}
const Shadow_ParamsConfig = new ShadowMatParamsConfig();
class ShadowMatNode extends mat_Base/* PrimitiveMatNode */.Q_ {
  constructor() {
    super(...arguments);
    this.paramsConfig = Shadow_ParamsConfig;
    this.controllers = {
      colors: new ColorsController/* ColorsController */.br(this),
      advancedCommon: new AdvancedCommonController/* AdvancedCommonController */.h(this)
    };
    this.controllersList = Object.values(this.controllers);
  }
  static type() {
    return Mat/* MatType.SHADOW */.M.SHADOW;
  }
  createMaterial() {
    return new three_module.ShadowMaterial({
      vertexColors: false,
      side: three_module.FrontSide,
      color: 16777215,
      opacity: 1
    });
  }
  cook() {
    return Shadow_async(this, null, function* () {
      this._material = this._material || this.createMaterial();
      yield Promise.all(this.controllersPromises(this._material));
      this.setMaterial(this._material);
    });
  }
}

// EXTERNAL MODULE: ../@polygonjs/polygonjs/node_modules/three/examples/jsm/objects/Sky.js
var Sky = __webpack_require__(47556);
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/mat/Sky.ts

var Sky_async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};




class SkyMatParamsConfig extends params_ParamsConfig/* NodeParamsConfig */.yI {
  constructor() {
    super(...arguments);
    /** @param turbidity */
    this.turbidity = params_ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(2, {
      range: [0, 20]
    });
    /** @param rayleigh */
    this.rayleigh = params_ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(1, {
      range: [0, 4]
    });
    /** @param mieCoefficient */
    this.mieCoefficient = params_ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(5e-3);
    /** @param mieDirectional */
    this.mieDirectional = params_ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(0.8);
    /** @param inclination */
    this.inclination = params_ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(0.5);
    /** @param azimuth */
    this.azimuth = params_ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(0.25);
    /** @param up */
    this.up = params_ParamsConfig/* ParamConfig.VECTOR3 */.XC.VECTOR3([0, 1, 0]);
  }
}
const Sky_ParamsConfig = new SkyMatParamsConfig();
class SkyMatNode extends mat_Base/* PrimitiveMatNode */.Q_ {
  constructor() {
    super(...arguments);
    this.paramsConfig = Sky_ParamsConfig;
  }
  static type() {
    return Mat/* MatType.SKY */.M.SKY;
  }
  createMaterial() {
    const object = new Sky/* Sky */.q();
    const mat = object.material;
    mat.depthWrite = true;
    return mat;
  }
  cook() {
    return Sky_async(this, null, function* () {
      this._material = this._material || this.createMaterial();
      const uniforms = this._material.uniforms;
      uniforms.turbidity.value = this.pv.turbidity;
      uniforms.rayleigh.value = this.pv.rayleigh;
      uniforms.mieCoefficient.value = this.pv.mieCoefficient;
      uniforms.mieDirectionalG.value = this.pv.mieDirectional;
      uniforms.up.value.copy(this.pv.up);
      const theta = Math.PI * (this.pv.inclination - 0.5);
      const phi = 2 * Math.PI * (this.pv.azimuth - 0.5);
      uniforms.sunPosition.value.x = Math.cos(phi);
      uniforms.sunPosition.value.y = Math.sin(phi) * Math.sin(theta);
      uniforms.sunPosition.value.z = Math.sin(phi) * Math.cos(theta);
      this.setMaterial(this._material);
    });
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/mat/StencilProperties.ts

var StencilProperties_async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};



const STENCIL_FUNCTIONS = [
  { NeverStencilFunc: three_module.NeverStencilFunc },
  { LessStencilFunc: three_module.LessStencilFunc },
  { EqualStencilFunc: three_module.EqualStencilFunc },
  { LessEqualStencilFunc: three_module.LessEqualStencilFunc },
  { GreaterStencilFunc: three_module.GreaterStencilFunc },
  { NotEqualStencilFunc: three_module.NotEqualStencilFunc },
  { GreaterEqualStencilFunc: three_module.GreaterEqualStencilFunc },
  { AlwaysStencilFunc: three_module.AlwaysStencilFunc }
];
const STENCIL_FUNCTIONS_NAMES = STENCIL_FUNCTIONS.map((obj) => Object.keys(obj)[0]);
const STENCIL_FUNCTION_BY_NAME = {};
for (const k of STENCIL_FUNCTIONS) {
  const key = Object.keys(k)[0];
  const value = Object.values(k)[0];
  STENCIL_FUNCTION_BY_NAME[key] = value;
}
const STENCIL_FUNC_ENTRIES = STENCIL_FUNCTIONS_NAMES.map((name, value) => {
  return { name, value: STENCIL_FUNCTION_BY_NAME[name] };
});
const STENCIL_OPS = [
  { ZeroStencilOp: three_module.ZeroStencilOp },
  { KeepStencilOp: three_module.KeepStencilOp },
  { ReplaceStencilOp: three_module.ReplaceStencilOp },
  { IncrementStencilOp: three_module.IncrementStencilOp },
  { DecrementStencilOp: three_module.DecrementStencilOp },
  { IncrementWrapStencilOp: three_module.IncrementWrapStencilOp },
  { DecrementWrapStencilOp: three_module.DecrementWrapStencilOp },
  { InvertStencilOp: three_module.InvertStencilOp }
];
const STENCIL_OPS_NAMES = STENCIL_OPS.map((obj) => Object.keys(obj)[0]);
const STENCIL_OP_BY_NAME = {};
for (const k of STENCIL_OPS) {
  const key = Object.keys(k)[0];
  const value = Object.values(k)[0];
  STENCIL_OP_BY_NAME[key] = value;
}
const STENCIL_OP_ENTRIES = STENCIL_OPS_NAMES.map((name, value) => {
  return { name, value: STENCIL_OP_BY_NAME[name] };
});
class StencilPropertiesMatParamsConfig extends params_ParamsConfig/* NodeParamsConfig */.yI {
  constructor() {
    super(...arguments);
    /** @param stencilWrite */
    this.stencilWrite = params_ParamsConfig/* ParamConfig.BOOLEAN */.XC.BOOLEAN(1);
    /** @param stencilFunc */
    this.stencilFunc = params_ParamsConfig/* ParamConfig.INTEGER */.XC.INTEGER(three_module.EqualStencilFunc, {
      menu: {
        entries: STENCIL_FUNC_ENTRIES
      }
    });
    /** @param stencilWriteMask */
    this.stencilWriteMask = params_ParamsConfig/* ParamConfig.INTEGER */.XC.INTEGER(255, {
      range: [0, 255],
      rangeLocked: [true, true]
    });
    /** @param stencilWriteMask */
    this.stencilFuncMask = params_ParamsConfig/* ParamConfig.INTEGER */.XC.INTEGER(255, {
      range: [0, 255],
      rangeLocked: [true, true]
    });
    /** @param stencilRef */
    this.stencilRef = params_ParamsConfig/* ParamConfig.INTEGER */.XC.INTEGER(0);
    /** @param stencilFail */
    this.stencilFail = params_ParamsConfig/* ParamConfig.INTEGER */.XC.INTEGER(three_module.KeepStencilOp, {
      menu: {
        entries: STENCIL_OP_ENTRIES
      }
    });
    /** @param stencilZFail */
    this.stencilZFail = params_ParamsConfig/* ParamConfig.INTEGER */.XC.INTEGER(three_module.KeepStencilOp, {
      menu: {
        entries: STENCIL_OP_ENTRIES
      }
    });
    /** @param stencilZPass */
    this.stencilZPass = params_ParamsConfig/* ParamConfig.INTEGER */.XC.INTEGER(three_module.KeepStencilOp, {
      menu: {
        entries: STENCIL_OP_ENTRIES
      }
    });
  }
}
const StencilProperties_ParamsConfig = new StencilPropertiesMatParamsConfig();
class StencilPropertiesMatNode extends mat_Base/* UpdateMatNode */.ic {
  constructor() {
    super(...arguments);
    this.paramsConfig = StencilProperties_ParamsConfig;
  }
  static type() {
    return "stencilProperties";
  }
  cook(inputMaterials) {
    return StencilProperties_async(this, null, function* () {
      const inputMaterial = inputMaterials[0];
      inputMaterial.stencilWrite = this.pv.stencilWrite;
      inputMaterial.stencilFunc = this.pv.stencilFunc;
      inputMaterial.stencilWriteMask = this.pv.stencilWriteMask;
      inputMaterial.stencilFuncMask = this.pv.stencilFuncMask;
      inputMaterial.stencilRef = this.pv.stencilRef;
      inputMaterial.stencilFail = this.pv.stencilFail;
      inputMaterial.stencilZFail = this.pv.stencilZFail;
      inputMaterial.stencilZPass = this.pv.stencilZPass;
      this.setMaterial(inputMaterial);
    });
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/gl/gl/volume/vert.glsl
/* harmony default export */ var vert = ("precision highp float;\nprecision highp int;\n\nvarying vec3 vPw;\n\n#include <common>\n\nvoid main()\t{\n\n\t// start builder body code\n\n\tvPw = (modelMatrix * vec4( position, 1.0 )).xyz;\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n}");
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/gl/gl/volume/frag.glsl
/* harmony default export */ var frag = ("precision highp float;\nprecision highp int;\n\n#include <common>\n\n#define DIR_LIGHTS_COUNT 1\n#define MAX_STEPS_COUNT 4096\n\nuniform vec3 u_Color;\nuniform float u_VolumeDensity;\nuniform float u_ShadowDensity;\nuniform float u_StepSize;\nuniform vec3 u_BoundingBoxMin;\nuniform vec3 u_BoundingBoxMax;\n//const int u_PointsCount = 3;\n//uniform vec3 u_Points[3];\nuniform sampler2D u_Map;\n\n//const int u_DirectionalLightsCount = 1;\nuniform vec3 u_DirectionalLightDirection; //[DIR_LIGHTS_COUNT];\n\nvarying vec3 vPw;\n// varying vec3 vN;\n// varying vec2 vUV;\n//varying vec3 vPCameraSpace;\n// varying vec4 vCd;\n\nvec3 normalize_in_bbox(vec3 point){\n\n\tvec3 min = u_BoundingBoxMin;\n\tvec3 max = u_BoundingBoxMax;\n\n\treturn vec3(\n\t\t(point.x - min.x) / (max.x - min.x),\n\t\t(point.y - min.y) / (max.y - min.y),\n\t\t(point.z - min.z) / (max.z - min.z)\n\t);\n}\n\nbool is_inside_bbox(vec3 Pw){\n\n\tvec3 min = u_BoundingBoxMin;\n\tvec3 max = u_BoundingBoxMax;\n\n\treturn (\n\t\tPw.x > min.x &&\n\t\tPw.y > min.y &&\n\t\tPw.z > min.z &&\n\n\t\tPw.x < max.x &&\n\t\tPw.y < max.y &&\n\t\tPw.z < max.z\n\t\t);\n}\n\nfloat density_to_opacity(float density, float step_size){\n\tfloat curent_density = density;\n\tcurent_density = max(0.0, curent_density);\n\n\tfloat opacity = (1.0-exp(-curent_density * step_size));\n\treturn max(opacity,0.0);\n}\n\nfloat density_function(vec3 position_for_step){\n\tfloat density = 1.0;\n\t// start builder body code\n\n\treturn density;\n}\n\nvec4 raymarch_light(vec3 ray_dir, vec3 start_pos){\n\n\tfloat step_size = u_StepSize;\n\tvec3 step_vector = ray_dir * step_size;\n\n\tvec3 current_pos = start_pos + step_vector*rand(start_pos.x*ray_dir.xy);\n\tfloat opacity = 0.0;\n\tfor(int i=0; i<MAX_STEPS_COUNT; i++){\n\t\tif(opacity >= 0.99){ break; }\n\n\t\tif( is_inside_bbox(current_pos) ){\n\n\t\t\tfloat density = density_function(current_pos) * u_ShadowDensity;\n\t\t\topacity += density_to_opacity(density, step_size);\n\t\t\tcurrent_pos += step_vector;\n\n\t\t}else{\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tvec3 light_color = vec3(1.0, 1.0, 1.0) * u_Color;\n\tlight_color *= (1.0-opacity);\n\treturn vec4(light_color, 1.0-opacity);\n}\n\nvec4 raymarch_bbox(vec3 start_pos, vec3 ray_dir){\n\n\tfloat step_size = u_StepSize;\n\tvec3 step_vector = ray_dir * step_size;\n\n\tvec3 current_pos = start_pos - step_vector*rand(ray_dir.xz);\n\tfloat opacity = 0.0;\n\tvec3 color = vec3(0.0, 0.0, 0.0);\n\tfloat steps_count = 0.0;\n\tbool was_inside_bbox = false;\n\tfor(int i=0; i<MAX_STEPS_COUNT; i++){\n\t\tif(opacity >= 0.99){ break; }\n\n\t\tif( i==0 || is_inside_bbox(current_pos) ){\n\t\t\twas_inside_bbox = true;\n\n\t\t\tfloat density = density_function(current_pos) * u_VolumeDensity;\n\t\t\topacity += density_to_opacity(density, step_size);\n\n\t\t\tvec4 light_color = vec4(0.0,0.0,0.0,1.0); //vec4(1.0,1.0,1.0,1.0);\n\t\t\t// vec3 directional_light_direction;\n\t\t\t// for ( int l = 0; l < DIR_LIGHTS_COUNT; l++ ) {\n\t\t\t// directional_light_direction = u_DirectionalLightsDirection[ l ];\n\t\t\tlight_color += raymarch_light(-u_DirectionalLightDirection, current_pos);\n\t\t\t// }\n\t\t\tfloat blend = 1.0-opacity;\n\t\t\tcolor = mix( color.xyz, light_color.xyz, vec3(blend, blend, blend) );\n\t\t\tsteps_count += 1.0;\n\n\t\t}else{\n\t\t\tif (was_inside_bbox) { break; }\n\t\t}\n\t\tcurrent_pos += step_vector;\n\t}\n\n\treturn vec4(color, opacity);\n\t// steps_count = steps_count / 5.0;\n\t// return vec4(vec3(steps_count, steps_count, steps_count), 1.0);\n}\n\nvoid main()\t{\n\n\tvec3 eye = normalize(vPw - cameraPosition);\n\t// we can start from the bbox, as we are front facing\n\tvec3 start_pos = vPw;\n\n\tvec4 color = raymarch_bbox(start_pos, eye);\n\tgl_FragColor = color;\n\n}");
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/gl/gl/volume/uniforms.ts



const VOLUME_UNIFORMS = {
  u_Color: { value: new three_module.Color(1, 1, 1) },
  u_VolumeDensity: { value: 5 },
  u_ShadowDensity: { value: 2 },
  u_StepSize: { value: 0.01 },
  u_BoundingBoxMin: { value: new three_module.Vector3(-1, -1, -1) },
  // geometry.boundingBox.min
  u_BoundingBoxMax: { value: new three_module.Vector3(1, 1, 1) },
  //geometry.boundingBox.max
  u_DirectionalLightDirection: {
    // do not use an array, as currently loading and saving a uniform with an array does not work via the MaterialLoader
    value: new three_module.Vector3(-1, -1, -1)
  }
};

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/mat/utils/VolumeController.ts





function VolumeParamConfig(Base) {
  return class Mixin extends Base {
    constructor() {
      super(...arguments);
      /** @param color */
      this.color = params_ParamsConfig/* ParamConfig.COLOR */.XC.COLOR([1, 1, 1]);
      /** @param stepSize. The smaller the value the more step the shader will make */
      this.stepSize = params_ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(0.01);
      /** @param volume density */
      this.density = params_ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(1);
      /** @param volume shadow density */
      this.shadowDensity = params_ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(1);
      /** @param this volume material currently can only use a single white light, whose direction is defined by this parameter */
      this.lightDir = params_ParamsConfig/* ParamConfig.VECTOR3 */.XC.VECTOR3([-1, -1, -1]);
    }
  };
}
class VolumeMaterial extends (/* unused pure expression or super */ null && (Material)) {
}
class VolumeParamsConfig extends VolumeParamConfig(params_ParamsConfig/* NodeParamsConfig */.yI) {
}
class VolumeMatNode extends (/* unused pure expression or super */ null && (TypedMatNode)) {
}
class VolumeController {
  constructor(node) {
    this.node = node;
  }
  static renderHook(renderer, scene, camera, geometry, material, group, object) {
    if (object) {
      this._objectBbox.setFromObject(object);
      const shader_material = material;
      shader_material.uniforms.u_BoundingBoxMin.value.copy(this._objectBbox.min);
      shader_material.uniforms.u_BoundingBoxMax.value.copy(this._objectBbox.max);
    }
  }
  updateUniformsFromParams(material) {
    const shaderMaterial = material;
    const uniforms = shaderMaterial.uniforms;
    if (!uniforms) {
      return;
    }
    uniforms.u_Color.value.copy(this.node.pv.color);
    uniforms.u_StepSize.value = this.node.pv.stepSize;
    uniforms.u_VolumeDensity.value = this.node.pv.density;
    uniforms.u_ShadowDensity.value = this.node.pv.shadowDensity;
    const dir_light = uniforms.u_DirectionalLightDirection.value;
    const pv_dir_light = this.node.pv.lightDir;
    if (dir_light) {
      dir_light.x = pv_dir_light.x;
      dir_light.y = pv_dir_light.y;
      dir_light.z = pv_dir_light.z;
    }
  }
}
VolumeController._objectBbox = new three_module.Box3();

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/mat/Volume.ts

var Volume_async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};











class VolumeMatParamsConfig extends VolumeParamConfig(params_ParamsConfig/* NodeParamsConfig */.yI) {
}
const Volume_ParamsConfig = new VolumeMatParamsConfig();
class Volume_VolumeMatNode extends mat_Base/* PrimitiveMatNode */.Q_ {
  constructor() {
    super(...arguments);
    this.paramsConfig = Volume_ParamsConfig;
    this._volumeController = new VolumeController(this);
  }
  static type() {
    return Mat/* MatType.VOLUME */.M.VOLUME;
  }
  createMaterial() {
    const mat = new three_module.ShaderMaterial({
      vertexShader: vert,
      fragmentShader: frag,
      side: three_module.FrontSide,
      transparent: true,
      depthTest: true,
      uniforms: three_module.UniformsUtils.clone(VOLUME_UNIFORMS)
    });
    (0,geometry_Material/* addUserDataRenderHook */.HP)(mat, VolumeController.renderHook.bind(VolumeController));
    return mat;
  }
  initializeNode() {
  }
  cook() {
    return Volume_async(this, null, function* () {
      this._material = this._material || this.createMaterial();
      this._volumeController.updateUniformsFromParams(this._material);
      this.setMaterial(this._material);
    });
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/mat/VolumeBuilder.ts

var VolumeBuilder_async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};






class VolumeBuilderMatParamsConfig extends (0,_BaseBuilder/* BaseBuilderParamConfig */.I)(VolumeParamConfig(params_ParamsConfig/* NodeParamsConfig */.yI)) {
}
const VolumeBuilder_ParamsConfig = new VolumeBuilderMatParamsConfig();
class VolumeBuilderMatNode extends _BaseBuilder/* TypedBuilderMatNode */.T {
  constructor() {
    super(...arguments);
    this.paramsConfig = VolumeBuilder_ParamsConfig;
    // public override customMaterialRequested(customName: CustomMaterialName): boolean {
    // 	return materialVolumeAssemblerCustomMaterialRequested(this, customName);
    // }
    this._volumeController = new VolumeController(this);
  }
  static type() {
    return Mat/* MatType.VOLUME_BUILDER */.M.VOLUME_BUILDER;
  }
  usedAssembler() {
    return _BaseRegister/* AssemblerName.GL_VOLUME */.Q.GL_VOLUME;
  }
  _createAssemblerController() {
    return Poly/* Poly.assemblersRegister.assembler */.L.assemblersRegister.assembler(this, this.usedAssembler());
  }
  initializeNode() {
  }
  cook() {
    return VolumeBuilder_async(this, null, function* () {
      this._material = this._material || this.createMaterial();
      this._volumeController.updateUniformsFromParams(this._material);
      this.compileIfRequired(this._material);
      this.setMaterial(this._material);
    });
  }
}

// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/nodes/mat/_BaseManager.ts
var mat_BaseManager = __webpack_require__(26642);
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/mat/ActorsNetwork.ts







class ActorsNetworkMatNode extends mat_BaseManager/* ParamLessBaseNetworkMatNode */.t {
  constructor() {
    super(...arguments);
    this._childrenControllerContext = poly_NodeContext/* NodeContext.JS */.sy.JS;
    //
    // ASSEMBLERS
    //
    this.persisted_config = new ActorPersistedConfig/* ActorPersistedConfig */.R(this);
    this._assemblerController = this._createAssemblerController();
    //
    // compilation
    //
    this.compilationController = new ActorCompilationController/* ActorCompilationController */.z7(this);
  }
  static type() {
    return poly_NodeContext/* NetworkNodeType.ACTOR */.kX.ACTOR;
  }
  createNode(node_class, options) {
    return super.createNode(node_class, options);
  }
  children() {
    return super.children();
  }
  nodesByType(type) {
    return super.nodesByType(type);
  }
  //
  childrenAllowed() {
    if (this.assemblerController()) {
      return super.childrenAllowed();
    }
    return false;
  }
  sceneReadonly() {
    return this.assemblerController() == null;
  }
  assemblerController() {
    return this._assemblerController;
  }
  usedAssembler() {
    return _BaseRegister/* AssemblerName.JS_ACTOR */.Q.JS_ACTOR;
  }
  _createAssemblerController() {
    return Poly/* Poly.assemblersRegister.assembler */.L.assemblersRegister.assembler(this, this.usedAssembler());
  }
  compile() {
    this.compilationController.compile();
  }
  cook() {
    this.compilationController.compileIfRequired();
    this.cookController.endCook();
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/mat/AnimationsNetwork.ts



class AnimationsNetworkMatNode extends mat_BaseManager/* ParamLessBaseNetworkMatNode */.t {
  constructor() {
    super(...arguments);
    this._childrenControllerContext = poly_NodeContext/* NodeContext.ANIM */.sy.ANIM;
  }
  static type() {
    return poly_NodeContext/* NetworkNodeType.ANIM */.kX.ANIM;
  }
  createNode(node_class, options) {
    return super.createNode(node_class, options);
  }
  children() {
    return super.children();
  }
  nodesByType(type) {
    return super.nodesByType(type);
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/mat/AudioNetwork.ts



class AudioNetworkMatNode extends mat_BaseManager/* ParamLessBaseNetworkMatNode */.t {
  constructor() {
    super(...arguments);
    this._childrenControllerContext = poly_NodeContext/* NodeContext.AUDIO */.sy.AUDIO;
  }
  static type() {
    return poly_NodeContext/* NetworkNodeType.AUDIO */.kX.AUDIO;
  }
  createNode(node_class, options) {
    return super.createNode(node_class, options);
  }
  children() {
    return super.children();
  }
  nodesByType(type) {
    return super.nodesByType(type);
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/mat/CopNetwork.ts



class CopNetworkMatNode extends mat_BaseManager/* ParamLessBaseNetworkMatNode */.t {
  constructor() {
    super(...arguments);
    this._childrenControllerContext = poly_NodeContext/* NodeContext.COP */.sy.COP;
  }
  static type() {
    return poly_NodeContext/* NetworkNodeType.COP */.kX.COP;
  }
  createNode(node_class, options) {
    return super.createNode(node_class, options);
  }
  children() {
    return super.children();
  }
  nodesByType(type) {
    return super.nodesByType(type);
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/mat/EventsNetwork.ts



class EventsNetworkMatNode extends mat_BaseManager/* ParamLessBaseNetworkMatNode */.t {
  constructor() {
    super(...arguments);
    this._childrenControllerContext = poly_NodeContext/* NodeContext.EVENT */.sy.EVENT;
  }
  static type() {
    return poly_NodeContext/* NetworkNodeType.EVENT */.kX.EVENT;
  }
  createNode(node_class, options) {
    return super.createNode(node_class, options);
  }
  children() {
    return super.children();
  }
  nodesByType(type) {
    return super.nodesByType(type);
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/mat/MaterialsNetwork.ts



class MaterialsNetworkMatNode extends mat_BaseManager/* ParamLessBaseNetworkMatNode */.t {
  constructor() {
    super(...arguments);
    this._childrenControllerContext = poly_NodeContext/* NodeContext.MAT */.sy.MAT;
  }
  static type() {
    return poly_NodeContext/* NetworkNodeType.MAT */.kX.MAT;
  }
  createNode(node_class, options) {
    return super.createNode(node_class, options);
  }
  children() {
    return super.children();
  }
  nodesByType(type) {
    return super.nodesByType(type);
  }
}

// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/nodes/mat/PostProcessNetwork.ts
var mat_PostProcessNetwork = __webpack_require__(1487);
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/mat/RenderersNetwork.ts



class RenderersNetworkMatNode extends mat_BaseManager/* ParamLessBaseNetworkMatNode */.t {
  constructor() {
    super(...arguments);
    this._childrenControllerContext = poly_NodeContext/* NodeContext.ROP */.sy.ROP;
  }
  static type() {
    return poly_NodeContext/* NetworkNodeType.ROP */.kX.ROP;
  }
  createNode(node_class, options) {
    return super.createNode(node_class, options);
  }
  children() {
    return super.children();
  }
  nodesByType(type) {
    return super.nodesByType(type);
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/poly/registers/nodes/Mat.ts












































class MatRegister {
  static run(poly) {
    poly.registerNode(BuilderUniformUpdateMatNode, CATEGORY_MAT.ADVANCED);
    poly.registerNode(ClippingPlaneMatNode, CATEGORY_MAT.ADVANCED);
    poly.registerNode(ClipPropertiesMatNode, CATEGORY_MAT.ADVANCED);
    poly.registerNode(Code/* CodeMatNode */.u1, CATEGORY_MAT.ADVANCED);
    if (false) {}
    poly.registerNode(LineBasic/* LineBasicMatNode */.N, CATEGORY_MAT.LINE);
    poly.registerNode(LineBasicBuilderMatNode, CATEGORY_MAT.LINE);
    poly.registerNode(MeshBasic/* MeshBasicMatNode */.F, CATEGORY_MAT.MESH);
    poly.registerNode(MeshBasicBuilderMatNode, CATEGORY_MAT.ADVANCED);
    poly.registerNode(MeshDepthMatNode, CATEGORY_MAT.MESH);
    poly.registerNode(MeshDepthBuilderMatNode, CATEGORY_MAT.ADVANCED);
    if (false) {}
    poly.registerNode(MeshLambert/* MeshLambertMatNode */.k, CATEGORY_MAT.MESH);
    poly.registerNode(MeshLambertBuilderMatNode, CATEGORY_MAT.ADVANCED);
    poly.registerNode(MeshMatcap/* MeshMatcapMatNode */.p, CATEGORY_MAT.MESH);
    poly.registerNode(MeshNormal/* MeshNormalMatNode */.S, CATEGORY_MAT.MESH);
    poly.registerNode(MeshPhong/* MeshPhongMatNode */.b, CATEGORY_MAT.MESH);
    poly.registerNode(MeshPhongBuilderMatNode, CATEGORY_MAT.ADVANCED);
    poly.registerNode(MeshPhysical/* MeshPhysicalMatNode */.l, CATEGORY_MAT.MESH);
    poly.registerNode(MeshPhysicalBuilder/* MeshPhysicalBuilderMatNode */.Z, CATEGORY_MAT.ADVANCED);
    poly.registerNode(MeshStandard/* MeshStandardMatNode */.Q, CATEGORY_MAT.MESH);
    poly.registerNode(MeshStandardBuilder/* MeshStandardBuilderMatNode */.k, CATEGORY_MAT.ADVANCED);
    poly.registerNode(MeshToon/* MeshToonMatNode */.a, CATEGORY_MAT.MESH);
    poly.registerNode(MeshToonBuilderMatNode, CATEGORY_MAT.ADVANCED);
    poly.registerNode(Points/* PointsMatNode */.k, CATEGORY_MAT.POINTS);
    poly.registerNode(PointsBuilderMatNode, CATEGORY_MAT.ADVANCED);
    poly.registerNode(RayMarchingBuilder/* RayMarchingBuilderMatNode */.n, CATEGORY_MAT.ADVANCED);
    poly.registerNode(ShadowMatNode, CATEGORY_MAT.ADVANCED);
    poly.registerNode(SkyMatNode, CATEGORY_MAT.MESH);
    poly.registerNode(StencilPropertiesMatNode, CATEGORY_MAT.ADVANCED);
    poly.registerNode(Volume_VolumeMatNode, CATEGORY_MAT.VOLUME);
    poly.registerNode(VolumeBuilderMatNode, CATEGORY_MAT.VOLUME);
    poly.registerNode(ActorsNetworkMatNode, CATEGORY_MAT.NETWORK);
    poly.registerNode(AnimationsNetworkMatNode, CATEGORY_MAT.NETWORK);
    poly.registerNode(AudioNetworkMatNode, CATEGORY_MAT.NETWORK);
    poly.registerNode(CopNetworkMatNode, CATEGORY_MAT.NETWORK);
    poly.registerNode(EventsNetworkMatNode, CATEGORY_MAT.NETWORK);
    poly.registerNode(MaterialsNetworkMatNode, CATEGORY_MAT.NETWORK);
    poly.registerNode(mat_PostProcessNetwork/* PostProcessNetworkMatNode */.e, CATEGORY_MAT.NETWORK);
    poly.registerNode(RenderersNetworkMatNode, CATEGORY_MAT.NETWORK);
  }
}

// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/nodes/obj/AmbientLight.ts
var AmbientLight = __webpack_require__(83409);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/nodes/obj/AreaLight.ts
var AreaLight = __webpack_require__(31787);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/nodes/obj/DirectionalLight.ts
var DirectionalLight = __webpack_require__(64303);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/nodes/obj/HemisphereLight.ts
var HemisphereLight = __webpack_require__(98971);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/nodes/obj/_BaseLight.ts
var _BaseLight = __webpack_require__(88336);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/poly/registers/nodes/types/Light.ts
var Light = __webpack_require__(18244);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/core/lights/LightProbe.ts
var LightProbe = __webpack_require__(63771);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/operations/sop/LightProbe.ts
var sop_LightProbe = __webpack_require__(32409);
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/obj/LightProbe.ts

var LightProbe_async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};





class LightProbeObjParamsConfig extends (0,LightProbe/* LightProbeParamConfig */.H)(params_ParamsConfig/* NodeParamsConfig */.yI) {
}
const LightProbe_ParamsConfig = new LightProbeObjParamsConfig();
class LightProbeObjNode extends _BaseLight/* TypedLightObjNode */.i {
  constructor() {
    super(...arguments);
    this.paramsConfig = LightProbe_ParamsConfig;
  }
  static type() {
    return Light/* LightType.PROBE */.v.PROBE;
  }
  _operation() {
    return this.__operation__ = this.__operation__ || new sop_LightProbe/* LightProbeSopOperation */.v(this._scene, this.states, this);
  }
  createLight() {
    return this._operation().createLight();
  }
  updateLightParams() {
    return LightProbe_async(this, null, function* () {
      yield this._operation().updateLightParams(this.light, this.pv);
    });
  }
}

// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/nodes/obj/PointLight.ts + 3 modules
var PointLight = __webpack_require__(56701);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/nodes/obj/SpotLight.ts
var SpotLight = __webpack_require__(78166);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/nodes/obj/_Base.ts
var obj_Base = __webpack_require__(48803);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/nodes/utils/FlagsController.ts + 4 modules
var FlagsController = __webpack_require__(162);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/nodes/obj/utils/HierarchyController.ts
var HierarchyController = __webpack_require__(70848);
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/obj/Blend.ts

var Blend_async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};








var BlendMode = /* @__PURE__ */ ((BlendMode2) => {
  BlendMode2["TOGETHER"] = "translate + rotate together";
  BlendMode2["SEPARATELY"] = "translate + rotate separately";
  return BlendMode2;
})(BlendMode || {});
const BLEND_MODES = ["translate + rotate together" /* TOGETHER */, "translate + rotate separately" /* SEPARATELY */];



class BlendObjParamConfig extends params_ParamsConfig/* NodeParamsConfig */.yI {
  constructor() {
    super(...arguments);
    /** @param object to blend transform from */
    this.object0 = params_ParamsConfig/* ParamConfig.NODE_PATH */.XC.NODE_PATH("", {
      nodeSelection: {
        context: poly_NodeContext/* NodeContext.OBJ */.sy.OBJ
      }
    });
    /** @param object to blend transform to */
    this.object1 = params_ParamsConfig/* ParamConfig.NODE_PATH */.XC.NODE_PATH("", {
      nodeSelection: {
        context: poly_NodeContext/* NodeContext.OBJ */.sy.OBJ
      }
    });
    /** @param blend mode */
    this.mode = params_ParamsConfig/* ParamConfig.INTEGER */.XC.INTEGER(BLEND_MODES.indexOf("translate + rotate together" /* TOGETHER */), {
      menu: {
        entries: BLEND_MODES.map((name, value) => {
          return { name, value };
        })
      }
    });
    /** @param blend value */
    this.blend = params_ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(0, {
      visibleIf: { mode: BLEND_MODES.indexOf("translate + rotate together" /* TOGETHER */) },
      range: [0, 1],
      rangeLocked: [false, false]
    });
    /** @param blend translation value */
    this.blendT = params_ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(0, {
      visibleIf: { mode: BLEND_MODES.indexOf("translate + rotate separately" /* SEPARATELY */) },
      range: [0, 1],
      rangeLocked: [false, false]
    });
    /** @param blend rotation value */
    this.blendR = params_ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(0, {
      visibleIf: { mode: BLEND_MODES.indexOf("translate + rotate separately" /* SEPARATELY */) },
      range: [0, 1],
      rangeLocked: [false, false]
    });
    /** @param updateOnRender */
    this.updateOnRender = params_ParamsConfig/* ParamConfig.BOOLEAN */.XC.BOOLEAN(1);
  }
}
const Blend_ParamsConfig = new BlendObjParamConfig();
class BlendObjNode extends obj_Base/* TypedObjNode */.Mx {
  constructor() {
    super(...arguments);
    this.paramsConfig = Blend_ParamsConfig;
    this.hierarchyController = new HierarchyController/* HierarchyController */.O(this);
    this.flags = new FlagsController/* FlagsControllerD */.ZR(this);
    this._helper = new three_module.AxesHelper(1);
    this._t0 = new three_module.Vector3();
    this._q0 = new three_module.Quaternion();
    this._s0 = new three_module.Vector3();
    this._t1 = new three_module.Vector3();
    this._q1 = new three_module.Quaternion();
    this._s1 = new three_module.Vector3();
  }
  static type() {
    return "blend";
  }
  createObject() {
    const object = new three_module.Mesh();
    object.matrixAutoUpdate = false;
    object.onBeforeRender = this._onBeforeRender.bind(this);
    return object;
  }
  initializeNode() {
    this.hierarchyController.initializeNode();
    this.io.inputs.setCount(0);
    this.addPostDirtyHook("blendOnDirty", () => {
      this.cookController.cookMainWithoutInputs();
    });
    this._updateHelperHierarchy();
    this.flags.display.onUpdate(() => {
      this._updateHelperHierarchy();
    });
  }
  _updateHelperHierarchy() {
    if (this.flags.display.active()) {
      this.object.add(this._helper);
    } else {
      this.object.remove(this._helper);
    }
  }
  cook() {
    return Blend_async(this, null, function* () {
      this.object.frustumCulled = !this.pv.updateOnRender;
      const objNode0 = this.pv.object0.nodeWithContext(poly_NodeContext/* NodeContext.OBJ */.sy.OBJ, this.states.error);
      const objNode1 = this.pv.object1.nodeWithContext(poly_NodeContext/* NodeContext.OBJ */.sy.OBJ, this.states.error);
      if (objNode0 && objNode1) {
        if (objNode0.isDirty()) {
          yield objNode0.compute();
        }
        if (objNode1.isDirty()) {
          yield objNode1.compute();
        }
        this._object0 = objNode0.object;
        this._object1 = objNode1.object;
        this._computeBlendedMatrix();
      } else {
        this.states.error.set("blend targets not found");
      }
      this.cookController.endCook();
    });
  }
  _onBeforeRender() {
    if (!(0,Type/* isBooleanTrue */.bI)(this.pv.updateOnRender)) {
      return;
    }
    this._computeBlendedMatrix();
  }
  _computeBlendedMatrix() {
    if (!(this._object0 && this._object1)) {
      return;
    }
    const mode = BLEND_MODES[this.pv.mode];
    switch (mode) {
      case "translate + rotate together" /* TOGETHER */:
        return this._blendTogether(this._object0, this._object1);
      case "translate + rotate separately" /* SEPARATELY */:
        return this._blendSeparately(this._object0, this._object1);
    }
    Assert/* TypeAssert.unreachable */.f.unreachable(mode);
  }
  _blendTogether(object0, object1) {
    this._decomposeMatrices(object0, object1);
    this._object.position.copy(this._t0).lerp(this._t1, this.pv.blend);
    this._object.quaternion.copy(this._q0).slerp(this._q1, this.pv.blend);
    if (!this._object.matrixAutoUpdate) {
      this._object.updateMatrix();
    }
  }
  _blendSeparately(object0, object1) {
    this._decomposeMatrices(object0, object1);
    this._object.position.copy(this._t0).lerp(this._t1, this.pv.blendT);
    this._object.quaternion.copy(this._q0).slerp(this._q1, this.pv.blendR);
    if (!this._object.matrixAutoUpdate) {
      this._object.updateMatrix();
    }
  }
  _decomposeMatrices(object0, object1) {
    this._updateMatrix(object0);
    this._updateMatrix(object1);
    object0.matrixWorld.decompose(this._t0, this._q0, this._s0);
    object1.matrixWorld.decompose(this._t1, this._q1, this._s1);
  }
  _updateMatrix(object) {
    if (!object.matrixAutoUpdate) {
      object.updateMatrix();
      object.updateMatrixWorld(true);
      object.updateWorldMatrix(true, true);
    }
  }
}

// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/nodes/obj/Geo.ts + 2 modules
var Geo = __webpack_require__(69226);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/nodes/obj/utils/TransformController.ts
var TransformController = __webpack_require__(87498);
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/obj/Null.ts








class NullObjParamConfig extends (0,TransformController/* TransformedParamConfig */.s7)(params_ParamsConfig/* NodeParamsConfig */.yI) {
}
const obj_Null_ParamsConfig = new NullObjParamConfig();
class NullObjNode extends obj_Base/* TypedObjNode */.Mx {
  constructor() {
    super(...arguments);
    this.paramsConfig = obj_Null_ParamsConfig;
    this.hierarchyController = new HierarchyController/* HierarchyController */.O(this);
    this.transformController = new TransformController/* TransformController */.hJ(this);
    this.flags = new FlagsController/* FlagsControllerD */.ZR(this);
    this._helper = new three_module.AxesHelper(1);
  }
  static type() {
    return "null";
  }
  createObject() {
    const group = new three_module.Group();
    group.matrixAutoUpdate = false;
    return group;
  }
  initializeNode() {
    this.hierarchyController.initializeNode();
    this.transformController.initializeNode();
    this._updateHelperHierarchy();
    this._helper.matrixAutoUpdate = false;
    this.flags.display.onUpdate(() => {
      this._updateHelperHierarchy();
    });
  }
  _updateHelperHierarchy() {
    if (this.flags.display.active()) {
      this.object.add(this._helper);
      this._helper.updateMatrix();
    } else {
      this.object.remove(this._helper);
    }
  }
  cook() {
    this.transformController.update();
    this.cookController.endCook();
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/obj/PolarTransform.ts

var PolarTransform_async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};











class PolarTransformObjParamConfig extends params_ParamsConfig/* NodeParamsConfig */.yI {
  constructor() {
    super(...arguments);
    /** @param center of the transform */
    this.center = params_ParamsConfig/* ParamConfig.VECTOR3 */.XC.VECTOR3([0, 0, 0]);
    /** @param moves the objects along the longitude, which is equivalent to a rotation on the y axis */
    this.longitude = params_ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(0, {
      range: [-360, 360]
    });
    /** @param moves the objects along the latitude, which is equivalent to a rotation on the z or x axis */
    this.latitude = params_ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(0, {
      range: [-180, 180]
    });
    /** @param moves the point aways from the center */
    this.depth = params_ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(1, {
      range: [0, 10]
    });
  }
}
const obj_PolarTransform_ParamsConfig = new PolarTransformObjParamConfig();
const HOOK_NAME = "_cook_main_without_inputs_when_dirty";
const AXIS_VERTICAL = new three_module.Vector3(0, 1, 0);
const AXIS_HORIZONTAL = new three_module.Vector3(-1, 0, 0);
class PolarTransformObjNode extends obj_Base/* TypedObjNode */.Mx {
  constructor() {
    super(...arguments);
    this.paramsConfig = obj_PolarTransform_ParamsConfig;
    this.hierarchyController = new HierarchyController/* HierarchyController */.O(this);
    this.flags = new FlagsController/* FlagsControllerD */.ZR(this);
    this._helper = this._createHelper();
    // TODO: this will have to be checked via the parent, when I will have obj managers at lower levels than root
    this._cook_main_without_inputs_when_dirty_bound = this._cook_main_without_inputs_when_dirty.bind(this);
    this._centerMatrix = new three_module.Matrix4();
    this._longitudeMatrix = new three_module.Matrix4();
    this._latitudeMatrix = new three_module.Matrix4();
    this._depthMatrix = new three_module.Matrix4();
    this._fullMatrix = new three_module.Matrix4();
    this._decomposed = {
      t: new three_module.Vector3(),
      q: new three_module.Quaternion(),
      s: new three_module.Vector3()
    };
  }
  static type() {
    return "polarTransform";
  }
  createObject() {
    const group = new three_module.Group();
    group.matrixAutoUpdate = false;
    return group;
  }
  initializeNode() {
    this.hierarchyController.initializeNode();
    if (!this.dirtyController.hasHook(HOOK_NAME)) {
      this.dirtyController.addPostDirtyHook(HOOK_NAME, this._cook_main_without_inputs_when_dirty_bound);
    }
    this._updateHelperHierarchy();
    this._helper.matrixAutoUpdate = false;
    this.flags.display.onUpdate(() => {
      this._updateHelperHierarchy();
    });
  }
  _updateHelperHierarchy() {
    if (this._displayedHelper()) {
      this.object.add(this._helper);
      this._updateHelper();
    } else {
      this.object.remove(this._helper);
    }
  }
  _displayedHelper() {
    return this.flags.display.active();
  }
  _axisHelper() {
    return this.__axisHelper__ = this.__axisHelper__ || this._createAxisHelper();
  }
  _createAxisHelper() {
    const axisHelper = new three_module.AxesHelper(1);
    axisHelper.matrixAutoUpdate = false;
    return axisHelper;
  }
  _polarGridHelper() {
    return this.__polarGridHelper__ = this.__polarGridHelper__ || this._createPolarGridHelper();
  }
  _createPolarGridHelper() {
    const radius = this.pv.depth;
    const radials = 16;
    const circles = 8;
    const divisions = 64;
    const polarGridHelper = new three_module.PolarGridHelper(radius, radials, circles, divisions);
    polarGridHelper.matrixAutoUpdate = false;
    return polarGridHelper;
  }
  _createHelper() {
    const group = new three_module.Group();
    group.name = "PolarTransformHelper";
    group.matrixAutoUpdate = false;
    group.add(this._axisHelper());
    group.add(this._polarGridHelper());
    return group;
  }
  _cook_main_without_inputs_when_dirty() {
    return PolarTransform_async(this, null, function* () {
      yield this.cookController.cookMainWithoutInputs();
    });
  }
  cook() {
    const object = this.object;
    this._centerMatrix.identity();
    this._longitudeMatrix.identity();
    this._latitudeMatrix.identity();
    this._depthMatrix.identity();
    this._centerMatrix.makeTranslation(this.pv.center.x, this.pv.center.y, this.pv.center.z);
    this._longitudeMatrix.makeRotationAxis(AXIS_VERTICAL, three_module.MathUtils.degToRad(this.pv.longitude));
    this._latitudeMatrix.makeRotationAxis(AXIS_HORIZONTAL, three_module.MathUtils.degToRad(this.pv.latitude));
    this._depthMatrix.makeTranslation(0, 0, this.pv.depth);
    this._fullMatrix.copy(this._centerMatrix).multiply(this._longitudeMatrix).multiply(this._latitudeMatrix).multiply(this._depthMatrix);
    this._fullMatrix.decompose(this._decomposed.t, this._decomposed.q, this._decomposed.s);
    object.position.copy(this._decomposed.t);
    object.quaternion.copy(this._decomposed.q);
    object.scale.copy(this._decomposed.s);
    object.updateMatrix();
    this._updateHelper();
    this.cookController.endCook();
  }
  _updateHelper() {
    if (!this._displayedHelper()) {
      return;
    }
    this._helper.updateMatrix();
    this._polarGridHelper().matrix.copy(this.object.matrix);
    this._polarGridHelper().matrix.invert();
    this._polarGridHelper().matrix.multiply(this._centerMatrix);
  }
}

// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/poly/registers/nodes/types/Obj.ts
var Obj = __webpack_require__(71501);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/node_modules/tone/build/esm/component/channel/Panner3D.js
var Panner3D = __webpack_require__(96566);
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/core/audio/PositionalAudio.ts





const _position = new three_module.Vector3();
const _quaternion = new three_module.Quaternion();
const _scale = new three_module.Vector3();
const _orientation = new three_module.Vector3();
var DistanceModel = /* @__PURE__ */ ((DistanceModel2) => {
  DistanceModel2["LINEAR"] = "linear";
  DistanceModel2["INVERSE"] = "inverse";
  DistanceModel2["EXPONENTIAL"] = "exponential";
  return DistanceModel2;
})(DistanceModel || {});
const DISTANCE_MODELS = [
  "linear" /* LINEAR */,
  "inverse" /* INVERSE */,
  "exponential" /* EXPONENTIAL */
];
class CorePositionalAudio extends three_module.Object3D {
  constructor() {
    super();
    this.listenerTransformAutoUpdate = true;
    this.tonePanner = new Panner3D/* Panner3D */.n();
    this.pannerNode = this.tonePanner.input;
  }
  disconnect() {
    this.tonePanner.disconnect();
  }
  setInput(audioNode) {
    if (this._currentAudioNode) {
      this._currentAudioNode.disconnect(this.tonePanner);
    }
    if (audioNode) {
      audioNode.connect(this.tonePanner);
    }
    this._currentAudioNode = audioNode;
  }
  connect(audioNode) {
    this.tonePanner.connect(audioNode);
  }
  // getOutput() {
  // 	return this.panner;
  // }
  getRefDistance() {
    return this.pannerNode.refDistance;
  }
  setRefDistance(value) {
    this.pannerNode.refDistance = value;
    return this;
  }
  getRolloffFactor() {
    return this.pannerNode.rolloffFactor;
  }
  setRolloffFactor(value) {
    this.pannerNode.rolloffFactor = value;
    return this;
  }
  getDistanceModel() {
    return this.pannerNode.distanceModel;
  }
  setDistanceModel(value) {
    this.pannerNode.distanceModel = value;
    return this;
  }
  getMaxDistance() {
    return this.pannerNode.maxDistance;
  }
  setMaxDistance(value) {
    this.pannerNode.maxDistance = value;
    return this;
  }
  setDirectionalCone(coneInnerAngle, coneOuterAngle, coneOuterGain) {
    this.pannerNode.coneInnerAngle = coneInnerAngle;
    this.pannerNode.coneOuterAngle = coneOuterAngle;
    this.pannerNode.coneOuterGain = coneOuterGain;
    return this;
  }
  coneInnerAngle() {
    return this.pannerNode.coneInnerAngle;
  }
  coneOuterAngle() {
    return this.pannerNode.coneOuterAngle;
  }
  updateMatrixWorld(force) {
    super.updateMatrixWorld(force);
    if (!this.listenerTransformAutoUpdate) {
      return;
    }
    this.matrixWorld.decompose(_position, _quaternion, _scale);
    _orientation.set(0, 0, 1).applyQuaternion(_quaternion);
    const duration = "+1";
    const panner = this.tonePanner;
    if (panner.positionX) {
      panner.positionX.linearRampToValueAtTime(_position.x, duration);
      panner.positionY.linearRampToValueAtTime(_position.y, duration);
      panner.positionZ.linearRampToValueAtTime(_position.z, duration);
      panner.orientationX.linearRampToValueAtTime(_orientation.x, duration);
      panner.orientationY.linearRampToValueAtTime(_orientation.y, duration);
      panner.orientationZ.linearRampToValueAtTime(_orientation.z, duration);
    } else {
      panner.setPosition(_position.x, _position.y, _position.z);
      panner.setOrientation(_orientation.x, _orientation.y, _orientation.z);
    }
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/core/audio/PositionalAudioHelper.ts






function createGeometry(divisionsInnerAngle, divisionsOuterAngle) {
  const geometry = new three_module.BufferGeometry();
  const divisions = divisionsInnerAngle + divisionsOuterAngle * 2;
  const positions = new Float32Array((divisions * 3 + 3) * 3);
  geometry.setAttribute("position", new three_module.BufferAttribute(positions, 3));
  return geometry;
}
function createInnerAngleMaterial() {
  return new three_module.LineBasicMaterial({ color: 65280 });
}
function createOuterAngleMaterial() {
  return new three_module.LineBasicMaterial({ color: 16776960 });
}
class CorePositionalAudioHelper extends three_module.Line {
  constructor(audio, range = 1, divisionsInnerAngle = 16, divisionsOuterAngle = 2) {
    super(createGeometry(divisionsInnerAngle, divisionsOuterAngle), [
      createInnerAngleMaterial(),
      createOuterAngleMaterial()
    ]);
    this.audio = audio;
    this.range = range;
    this.divisionsInnerAngle = divisionsInnerAngle;
    this.divisionsOuterAngle = divisionsOuterAngle;
    this.type = "PositionalAudioHelper";
    this.update();
  }
  update() {
    const audio = this.audio;
    const range = this.range;
    const divisionsInnerAngle = this.divisionsInnerAngle;
    const divisionsOuterAngle = this.divisionsOuterAngle;
    const coneInnerAngle = three_module.MathUtils.degToRad(audio.coneInnerAngle());
    const coneOuterAngle = three_module.MathUtils.degToRad(audio.coneOuterAngle());
    const halfConeInnerAngle = coneInnerAngle / 2;
    const halfConeOuterAngle = coneOuterAngle / 2;
    let start = 0;
    let count = 0;
    let i;
    let stride;
    const geometry = this.geometry;
    const positionAttribute = geometry.attributes.position;
    geometry.clearGroups();
    function generateSegment(from, to, divisions, materialIndex) {
      const step = (to - from) / divisions;
      positionAttribute.setXYZ(start, 0, 0, 0);
      count++;
      for (i = from; i < to; i += step) {
        stride = start + count;
        positionAttribute.setXYZ(stride, Math.sin(i) * range, 0, Math.cos(i) * range);
        positionAttribute.setXYZ(
          stride + 1,
          Math.sin(Math.min(i + step, to)) * range,
          0,
          Math.cos(Math.min(i + step, to)) * range
        );
        positionAttribute.setXYZ(stride + 2, 0, 0, 0);
        count += 3;
      }
      geometry.addGroup(start, count, materialIndex);
      start += count;
      count = 0;
    }
    generateSegment(-halfConeOuterAngle, -halfConeInnerAngle, divisionsOuterAngle, 0);
    generateSegment(-halfConeInnerAngle, halfConeInnerAngle, divisionsInnerAngle, 1);
    generateSegment(halfConeInnerAngle, halfConeOuterAngle, divisionsOuterAngle, 0);
    positionAttribute.needsUpdate = true;
    if (coneInnerAngle === coneOuterAngle) {
      const materials = this.material;
      materials[0].visible = false;
    }
  }
  dispose() {
    this.geometry.dispose();
    const materials = this.material;
    materials[0].dispose();
    materials[1].dispose();
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/obj/PositionalAudio.ts

var PositionalAudio_defProp = Object.defineProperty;
var PositionalAudio_getOwnPropSymbols = Object.getOwnPropertySymbols;
var PositionalAudio_hasOwnProp = Object.prototype.hasOwnProperty;
var PositionalAudio_propIsEnum = Object.prototype.propertyIsEnumerable;
var PositionalAudio_defNormalProp = (obj, key, value) => key in obj ? PositionalAudio_defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var PositionalAudio_spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (PositionalAudio_hasOwnProp.call(b, prop))
      PositionalAudio_defNormalProp(a, prop, b[prop]);
  if (PositionalAudio_getOwnPropSymbols)
    for (var prop of PositionalAudio_getOwnPropSymbols(b)) {
      if (PositionalAudio_propIsEnum.call(b, prop))
        PositionalAudio_defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var PositionalAudio_async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};











const PositionalAudio_paramCallback = () => {
  return {
    cook: false,
    callback: (node) => {
      PositionalAudioObjNode.PARAM_CALLBACK_updatePositionalAudio(node);
    }
  };
};
class PositionalAudioParamConfig extends (0,TransformController/* TransformedParamConfig */.s7)(params_ParamsConfig/* NodeParamsConfig */.yI) {
  constructor() {
    super(...arguments);
    this.audio = params_ParamsConfig/* ParamConfig.FOLDER */.XC.FOLDER();
    /** @param audio node */
    this.audioNode = params_ParamsConfig/* ParamConfig.NODE_PATH */.XC.NODE_PATH("", {
      nodeSelection: {
        context: poly_NodeContext/* NodeContext.AUDIO */.sy.AUDIO
      }
      // dependentOnFoundNode: false,
    });
    /** @param refDistance. See https://developer.mozilla.org/en-US/docs/Web/API/PannerNode/refDistance*/
    this.refDistance = params_ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(10, PositionalAudio_spreadValues({
      range: [0, 10],
      rangeLocked: [true, false]
    }, PositionalAudio_paramCallback()));
    /** @param rolloffFactor. See https://developer.mozilla.org/en-US/docs/Web/API/PannerNode/rolloffFactor */
    this.rolloffFactor = params_ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(10, PositionalAudio_spreadValues({
      range: [0, 10],
      rangeLocked: [true, false]
    }, PositionalAudio_paramCallback()));
    /** @param maxDistance. See https://developer.mozilla.org/en-US/docs/Web/API/PannerNode/maxDistance */
    this.maxDistance = params_ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(100, PositionalAudio_spreadValues({
      range: [1e-3, 100],
      rangeLocked: [true, false]
    }, PositionalAudio_paramCallback()));
    /** @param distanceModel. See https://developer.mozilla.org/en-US/docs/Web/API/PannerNode/distanceModel */
    this.distanceModel = params_ParamsConfig/* ParamConfig.INTEGER */.XC.INTEGER(DISTANCE_MODELS.indexOf(DistanceModel.LINEAR), PositionalAudio_spreadValues({
      menu: {
        entries: DISTANCE_MODELS.map((name, value) => {
          return { name, value };
        })
      }
    }, PositionalAudio_paramCallback()));
    /** @param coneInnerAngle. See https://developer.mozilla.org/en-US/docs/Web/API/PannerNode */
    this.coneInnerAngle = params_ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(360, PositionalAudio_spreadValues({
      range: [0, 360],
      rangeLocked: [true, true]
    }, PositionalAudio_paramCallback()));
    /** @param coneOuterAngle. See https://developer.mozilla.org/en-US/docs/Web/API/PannerNode */
    this.coneOuterAngle = params_ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(230, PositionalAudio_spreadValues({
      range: [0, 360],
      rangeLocked: [true, true]
    }, PositionalAudio_paramCallback()));
    /** @param coneOuterGain. See https://developer.mozilla.org/en-US/docs/Web/API/PannerNode */
    this.coneOuterGain = params_ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(0.1, PositionalAudio_spreadValues({
      range: [0, 1],
      rangeLocked: [true, true]
    }, PositionalAudio_paramCallback()));
    /** @param ensures the transform of the audio listener is updated on very frame */
    this.listenerTransformAutoUpdate = params_ParamsConfig/* ParamConfig.BOOLEAN */.XC.BOOLEAN(1);
    /** @param show helper */
    this.showHelper = params_ParamsConfig/* ParamConfig.BOOLEAN */.XC.BOOLEAN(1);
    /** @param helper size */
    this.helperSize = params_ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(1, PositionalAudio_spreadValues({
      range: [0, 10],
      rangeLocked: [true, false],
      visibleIf: { showHelper: true }
    }, PositionalAudio_paramCallback()));
  }
}
const PositionalAudio_ParamsConfig = new PositionalAudioParamConfig();
function createPositionalAudio() {
  const positionalAudio = new CorePositionalAudio();
  positionalAudio.matrixAutoUpdate = false;
  return positionalAudio;
}
class PositionalAudioObjNode extends obj_Base/* TypedObjNode */.Mx {
  constructor() {
    super(...arguments);
    this.paramsConfig = PositionalAudio_ParamsConfig;
    this.hierarchyController = new HierarchyController/* HierarchyController */.O(this);
    this.transformController = new TransformController/* TransformController */.hJ(this);
    this.flags = new FlagsController/* FlagsControllerD */.ZR(this);
    this._positionalAudio = createPositionalAudio();
    /*
     *
     * CHILDREN
     *
     */
    this._childrenControllerContext = poly_NodeContext/* NodeContext.AUDIO */.sy.AUDIO;
  }
  static type() {
    return Obj/* ObjType.POSITIONAL_AUDIO */.B.POSITIONAL_AUDIO;
  }
  createObject() {
    const group = new three_module.Group();
    group.matrixAutoUpdate = false;
    group.add(this._positionalAudio);
    return group;
  }
  initializeNode() {
    this.hierarchyController.initializeNode();
    this.transformController.initializeNode();
    this._updateHelperHierarchy();
    this.flags.display.onUpdate(() => PositionalAudio_async(this, null, function* () {
      yield this._updateToDestination();
      yield this._updateHelperHierarchy();
    }));
  }
  _updateToDestination() {
    return PositionalAudio_async(this, null, function* () {
      if (this.flags.display.active()) {
        const listener = this.root().audioController.audioListeners()[0];
        if (!listener) {
          this.states.error.set("a listener is required in the scene");
          return;
        }
        listener.object.addInput(this._positionalAudio);
      } else {
        this._positionalAudio.disconnect();
      }
    });
  }
  _updateHelperHierarchy() {
    if (!this._helper) {
      return;
    }
    if (this.flags.display.active()) {
      this.object.add(this._helper);
    } else {
      this.object.remove(this._helper);
    }
  }
  cook() {
    return PositionalAudio_async(this, null, function* () {
      this.transformController.update();
      yield this._updateToDestination();
      this._updatePositionalAudio();
      this._connectAudioNode();
      this.cookController.endCook();
    });
  }
  _updatePositionalAudio() {
    return PositionalAudio_async(this, null, function* () {
      this._positionalAudio.setRefDistance(this.pv.refDistance);
      this._positionalAudio.setRolloffFactor(this.pv.rolloffFactor);
      this._positionalAudio.setMaxDistance(this.pv.maxDistance);
      this._positionalAudio.setDistanceModel(DISTANCE_MODELS[this.pv.distanceModel]);
      this._positionalAudio.setDirectionalCone(this.pv.coneInnerAngle, this.pv.coneOuterAngle, this.pv.coneOuterGain);
      this._positionalAudio.listenerTransformAutoUpdate = (0,Type/* isBooleanTrue */.bI)(this.pv.listenerTransformAutoUpdate);
      if ((0,Type/* isBooleanTrue */.bI)(this.pv.showHelper)) {
        this._helper = this._helper || this._createHelper(this._positionalAudio);
        this.object.add(this._helper);
      }
      if (this._helper) {
        this._helper.visible = (0,Type/* isBooleanTrue */.bI)(this.pv.showHelper);
        this._helper.range = this.pv.helperSize;
        this._helper.update();
      }
    });
  }
  _createHelper(positionalAudio) {
    const helper = new CorePositionalAudioHelper(positionalAudio);
    helper.matrixAutoUpdate = false;
    return helper;
  }
  _resetAudioNode() {
    this._positionalAudio.setInput(void 0);
  }
  _connectAudioNode() {
    return PositionalAudio_async(this, null, function* () {
      this._resetAudioNode();
      const baseAudioNode = this.pv.audioNode.nodeWithContext(poly_NodeContext/* NodeContext.AUDIO */.sy.AUDIO);
      if (!baseAudioNode) {
        this.states.error.set("no audio node found");
        this._resetAudioNode();
        return;
      }
      const audioContainer = yield baseAudioNode.compute();
      const audioBuilder = audioContainer.coreContent();
      if (!audioBuilder) {
        this.states.error.set("invalid audio node");
        this._resetAudioNode();
        return;
      }
      const toneAudioNode = audioBuilder.audioNode();
      if (!toneAudioNode) {
        this.states.error.set("no valid audio node given");
        this._resetAudioNode();
        return;
      }
      this._positionalAudio.setInput(toneAudioNode);
    });
  }
  static PARAM_CALLBACK_updatePositionalAudio(node) {
    node._updatePositionalAudio();
  }
  createNode(node_class, options) {
    return super.createNode(node_class, options);
  }
  children() {
    return super.children();
  }
  nodesByType(type) {
    return super.nodesByType(type);
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/obj/Rivet.ts

var Rivet_async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};










var RivetUpdateMode = /* @__PURE__ */ ((RivetUpdateMode2) => {
  RivetUpdateMode2["ON_RENDER"] = "On Every Render";
  RivetUpdateMode2["MANUAL"] = "Manual";
  return RivetUpdateMode2;
})(RivetUpdateMode || {});
const UPDATE_MODES = ["On Every Render" /* ON_RENDER */, "Manual" /* MANUAL */];
class RivetObjParamConfig extends params_ParamsConfig/* NodeParamsConfig */.yI {
  constructor() {
    super(...arguments);
    this.object = params_ParamsConfig/* ParamConfig.NODE_PATH */.XC.NODE_PATH("", {
      nodeSelection: {
        context: poly_NodeContext/* NodeContext.OBJ */.sy.OBJ,
        types: [Geo/* GeoObjNode.type */.p.type()]
      },
      dependentOnFoundNode: false,
      computeOnDirty: true,
      callback: (node) => {
        RivetObjNode.PARAM_CALLBACK_update_resolved_object(node);
      }
    });
    this.pointIndex = params_ParamsConfig/* ParamConfig.INTEGER */.XC.INTEGER(0, {
      range: [0, 100]
      // callback: (node: BaseNodeType) => {
      // 	RivetObjNode.PARAM_CALLBACK_update_object_position(node as RivetObjNode);
      // },
    });
    // active = ParamConfig.BOOLEAN(true, {
    // 	callback: (node: BaseNodeType) => {
    // 		RivetObjNode.PARAM_CALLBACK_update_active_state(node as RivetObjNode);
    // 	},
    // });
    this.updateMode = params_ParamsConfig/* ParamConfig.INTEGER */.XC.INTEGER(UPDATE_MODES.indexOf("On Every Render" /* ON_RENDER */), {
      callback: (node) => {
        RivetObjNode.PARAM_CALLBACK_update_updateMode(node);
      },
      menu: {
        entries: UPDATE_MODES.map((name, value) => {
          return { name, value };
        })
      }
      // visibleIf: {active: true},
    });
    this.update = params_ParamsConfig/* ParamConfig.BUTTON */.XC.BUTTON(null, {
      callback: (node) => {
        RivetObjNode.PARAM_CALLBACK_update(node);
      },
      visibleIf: { updateMode: UPDATE_MODES.indexOf("Manual" /* MANUAL */) }
    });
  }
  // update = ParamConfig.BUTTON(null, {
  // 	callback: (node: BaseNodeType) => {
  // 		RivetObjNode.PARAM_CALLBACK_update_object_position(node as RivetObjNode);
  // 	},
  // });
}
const Rivet_ParamsConfig = new RivetObjParamConfig();
class RivetObjNode extends obj_Base/* TypedObjNode */.Mx {
  constructor() {
    super(...arguments);
    this.paramsConfig = Rivet_ParamsConfig;
    this.hierarchyController = new HierarchyController/* HierarchyController */.O(this);
    this.flags = new FlagsController/* FlagsControllerD */.ZR(this);
    this._helper = new three_module.AxesHelper(1);
    this._found_point_post = new three_module.Vector3();
    this._on_object_before_render_bound = this._update.bind(this);
  }
  static type() {
    return "rivet";
  }
  createObject() {
    const mesh = new three_module.Mesh();
    mesh.matrixAutoUpdate = false;
    return mesh;
  }
  initializeNode() {
    this.hierarchyController.initializeNode();
    this.addPostDirtyHook("rivet_on_dirty", () => {
      this.cookController.cookMainWithoutInputs();
    });
    this._updateHelperHierarchy();
    this.flags.display.onUpdate(() => {
      this._updateHelperHierarchy();
    });
  }
  _updateHelperHierarchy() {
    if (this.flags.display.active()) {
      this.object.add(this._helper);
    } else {
      this.object.remove(this._helper);
    }
  }
  cook() {
    return Rivet_async(this, null, function* () {
      yield this._update_resolved_object();
      this._updateRenderHook();
      this.cookController.endCook();
    });
  }
  // private _remove_render_hook() {
  // 	if (this._previous_on_before_render) {
  // 		this.object.onBeforeRender = this._previous_on_before_render;
  // 	}
  // }
  // private _update_updateMode(){
  // The problem with a frame dependency is that if there is a hierarchy
  // of rivets, the update chain will be in the wrong order, and therefore wrong.
  // It is then better to update it via a code node.
  // 	const mode = UPDATE_MODES[this.pv.mode]
  // 	switch(mode){
  // 		case RivetUpdateMode.ON_RENDER: {
  // 			this._remove_frame_dependency()
  // 			return this._add_render_hook()
  // 		}
  // 		case RivetUpdateMode.ON_FRAME_CHANGE: {
  // 			this._remove_render_hook()
  // 			return this._add_frame_depedency()
  // 		}
  // 	}
  // 	TypeAssert.unreachable(mode)
  // }
  // private _remove_frame_dependency(){
  // 	const frame_graph_node = this.scene.time_controller.graph_node
  // 	this.removeGraphInput(frame_graph_node)
  // }
  // private _add_frame_depedency(){
  // 	const frame_graph_node = this.scene.time_controller.graph_node
  // 	this.addGraphInput(frame_graph_node)
  // }
  _updateRenderHook() {
    const mode = UPDATE_MODES[this.pv.updateMode];
    switch (mode) {
      case "On Every Render" /* ON_RENDER */: {
        return this._addRenderHook();
      }
      case "Manual" /* MANUAL */: {
        return this._removeRenderHook();
      }
    }
    Assert/* TypeAssert.unreachable */.f.unreachable(mode);
  }
  _addRenderHook() {
    this.object.onBeforeRender = this._on_object_before_render_bound;
    this.object.frustumCulled = false;
  }
  _removeRenderHook() {
    this.object.onBeforeRender = () => {
    };
  }
  // private _previous_on_before_render: RenderHook | undefined;
  _update(renderer, scene, camera, geometry, material, group) {
    const resolved_object = this._resolvedObject();
    if (resolved_object) {
      const geometry2 = resolved_object.geometry;
      if (geometry2) {
        const position_attrib = geometry2.attributes["position"];
        if (position_attrib) {
          const position_array = position_attrib.array;
          this._found_point_post.fromArray(position_array, this.pv.pointIndex * 3);
          resolved_object.updateWorldMatrix(true, false);
          resolved_object.localToWorld(this._found_point_post);
          this.object.matrix.makeTranslation(
            this._found_point_post.x,
            this._found_point_post.y,
            this._found_point_post.z
          );
        }
      }
    }
  }
  //
  //
  // RESOLVE
  //
  //
  static PARAM_CALLBACK_update_resolved_object(node) {
    node._update_resolved_object();
  }
  _update_resolved_object() {
    return Rivet_async(this, null, function* () {
      if (this.p.object.isDirty()) {
        yield this.p.object.compute();
      }
      const node = this.pv.object.nodeWithContext(poly_NodeContext/* NodeContext.OBJ */.sy.OBJ);
      if (node) {
        if (node.type() == Geo/* GeoObjNode.type */.p.type()) {
          const geoNode = node;
          this._resolvedSopGroup = geoNode.childrenDisplayController.sopGroup();
        } else {
          this.states.error.set("found node is not a geo node");
        }
      }
    });
  }
  _resolvedObject() {
    if (!this._resolvedSopGroup) {
      return;
    }
    const object = this._resolvedSopGroup.children[0];
    if (object) {
      return object;
    }
  }
  //
  //
  // ACTIVE
  //
  //
  static PARAM_CALLBACK_update_updateMode(node) {
    node._updateRenderHook();
  }
  // private async _update_active_state() {
  // 	// await this.p.active.compute();
  // 	this._update_render_hook();
  // }
  //
  //
  // UPDATE
  //
  //
  static PARAM_CALLBACK_update(node) {
    node._update();
  }
  // private _reset() {
  // 	this._resolved_sop_group = undefined;
  // 	// this._resolved_sop_group_child = undefined;
  // 	this._update_resolved_object();
  // }
}

// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/nodes/obj/Scene.ts
var obj_Scene = __webpack_require__(92211);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/nodes/obj/OrthographicCamera.ts
var OrthographicCamera = __webpack_require__(38917);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/nodes/obj/PerspectiveCamera.ts + 1 modules
var PerspectiveCamera = __webpack_require__(22387);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/nodes/obj/_BaseManager.ts
var obj_BaseManager = __webpack_require__(40918);
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/obj/ActorsNetwork.ts







class ActorsNetworkObjNode extends obj_BaseManager/* ParamLessBaseManagerObjNode */.C {
  constructor() {
    super(...arguments);
    this._childrenControllerContext = poly_NodeContext/* NodeContext.JS */.sy.JS;
    //
    // ASSEMBLERS
    //
    this.persisted_config = new ActorPersistedConfig/* ActorPersistedConfig */.R(this);
    this._assemblerController = this._createAssemblerController();
    //
    // compilation
    //
    this.compilationController = new ActorCompilationController/* ActorCompilationController */.z7(this);
  }
  static type() {
    return poly_NodeContext/* NetworkNodeType.ACTOR */.kX.ACTOR;
  }
  createNode(node_class, options) {
    return super.createNode(node_class, options);
  }
  children() {
    return super.children();
  }
  nodesByType(type) {
    return super.nodesByType(type);
  }
  //
  childrenAllowed() {
    if (this.assemblerController()) {
      return super.childrenAllowed();
    }
    return false;
  }
  sceneReadonly() {
    return this.assemblerController() == null;
  }
  assemblerController() {
    return this._assemblerController;
  }
  usedAssembler() {
    return _BaseRegister/* AssemblerName.JS_ACTOR */.Q.JS_ACTOR;
  }
  _createAssemblerController() {
    return Poly/* Poly.assemblersRegister.assembler */.L.assemblersRegister.assembler(this, this.usedAssembler());
  }
  compile() {
    this.compilationController.compile();
  }
  cook() {
    this.compilationController.compileIfRequired();
    this.cookController.endCook();
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/obj/AnimationsNetwork.ts




class BaseAnimationsObjNode extends obj_BaseManager/* ParamLessBaseManagerObjNode */.C {
  constructor() {
    super(...arguments);
    this._childrenControllerContext = poly_NodeContext/* NodeContext.ANIM */.sy.ANIM;
  }
  static type() {
    return poly_NodeContext/* NetworkNodeType.ANIM */.kX.ANIM;
  }
  createNode(node_class, options) {
    return super.createNode(node_class, options);
  }
  children() {
    return super.children();
  }
  nodesByType(type) {
    return super.nodesByType(type);
  }
}
class AnimationsNetworkObjNode extends BaseAnimationsObjNode {
  constructor() {
    super(...arguments);
    this.renderOrder = obj_Base/* ObjNodeRenderOrder.MANAGER */.FE.MANAGER;
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/obj/AudioNetwork.ts




class BaseAudioObjNode extends obj_BaseManager/* ParamLessBaseManagerObjNode */.C {
  constructor() {
    super(...arguments);
    this._childrenControllerContext = poly_NodeContext/* NodeContext.AUDIO */.sy.AUDIO;
  }
  static type() {
    return poly_NodeContext/* NetworkNodeType.AUDIO */.kX.AUDIO;
  }
  createNode(node_class, options) {
    return super.createNode(node_class, options);
  }
  children() {
    return super.children();
  }
  nodesByType(type) {
    return super.nodesByType(type);
  }
}
class AudioNetworkObjNode extends BaseAudioObjNode {
  constructor() {
    super(...arguments);
    this.renderOrder = obj_Base/* ObjNodeRenderOrder.MANAGER */.FE.MANAGER;
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/obj/CopNetwork.ts



class CopNetworkObjNode extends obj_BaseManager/* ParamLessBaseManagerObjNode */.C {
  constructor() {
    super(...arguments);
    this._childrenControllerContext = poly_NodeContext/* NodeContext.COP */.sy.COP;
  }
  static type() {
    return poly_NodeContext/* NetworkNodeType.COP */.kX.COP;
  }
  createNode(node_class, options) {
    return super.createNode(node_class, options);
  }
  children() {
    return super.children();
  }
  nodesByType(type) {
    return super.nodesByType(type);
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/obj/EventsNetwork.ts




class EventsNetworkObjNode extends obj_BaseManager/* ParamLessBaseManagerObjNode */.C {
  constructor() {
    super(...arguments);
    this.renderOrder = obj_Base/* ObjNodeRenderOrder.MANAGER */.FE.MANAGER;
    this._childrenControllerContext = poly_NodeContext/* NodeContext.EVENT */.sy.EVENT;
  }
  static type() {
    return poly_NodeContext/* NetworkNodeType.EVENT */.kX.EVENT;
  }
  createNode(node_class, options) {
    return super.createNode(node_class, options);
  }
  children() {
    return super.children();
  }
  nodesByType(type) {
    return super.nodesByType(type);
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/obj/MaterialsNetwork.ts




class MaterialsNetworkObjNode extends obj_BaseManager/* ParamLessBaseManagerObjNode */.C {
  constructor() {
    super(...arguments);
    this.renderOrder = obj_Base/* ObjNodeRenderOrder.MANAGER */.FE.MANAGER;
    this._childrenControllerContext = poly_NodeContext/* NodeContext.MAT */.sy.MAT;
  }
  static type() {
    return poly_NodeContext/* NetworkNodeType.MAT */.kX.MAT;
  }
  createNode(node_class, options) {
    return super.createNode(node_class, options);
  }
  children() {
    return super.children();
  }
  nodesByType(type) {
    return super.nodesByType(type);
  }
}

// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/nodes/obj/PostProcessNetwork.ts
var obj_PostProcessNetwork = __webpack_require__(31518);
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/obj/RenderersNetwork.ts




class RenderersNetworkObjNode extends obj_BaseManager/* ParamLessBaseManagerObjNode */.C {
  constructor() {
    super(...arguments);
    this.renderOrder = obj_Base/* ObjNodeRenderOrder.MANAGER */.FE.MANAGER;
    this._childrenControllerContext = poly_NodeContext/* NodeContext.ROP */.sy.ROP;
  }
  static type() {
    return poly_NodeContext/* NetworkNodeType.ROP */.kX.ROP;
  }
  createNode(node_class, options) {
    return super.createNode(node_class, options);
  }
  children() {
    return super.children();
  }
  nodesByType(type) {
    return super.nodesByType(type);
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/poly/registers/nodes/Obj.ts



























class ObjRegister {
  static run(poly) {
    poly.registerNode(AmbientLight/* AmbientLightObjNode */.D, CATEGORY_OBJ.LIGHT);
    poly.registerNode(AreaLight/* AreaLightObjNode */.$, CATEGORY_OBJ.LIGHT);
    poly.registerNode(DirectionalLight/* DirectionalLightObjNode */.g, CATEGORY_OBJ.LIGHT);
    poly.registerNode(HemisphereLight/* HemisphereLightObjNode */.f, CATEGORY_OBJ.LIGHT);
    poly.registerNode(LightProbeObjNode, CATEGORY_OBJ.LIGHT);
    poly.registerNode(PointLight/* PointLightObjNode */.b, CATEGORY_OBJ.LIGHT);
    poly.registerNode(SpotLight/* SpotLightObjNode */.c, CATEGORY_OBJ.LIGHT);
    poly.registerNode(AudioListener/* AudioListenerObjNode */.C, CATEGORY_OBJ.AUDIO);
    poly.registerNode(BlendObjNode, CATEGORY_OBJ.TRANSFORM);
    poly.registerNode(Geo/* GeoObjNode */.p, CATEGORY_OBJ.GEOMETRY);
    poly.registerNode(NullObjNode, CATEGORY_OBJ.TRANSFORM);
    poly.registerNode(PolarTransformObjNode, CATEGORY_OBJ.TRANSFORM);
    poly.registerNode(PositionalAudioObjNode, CATEGORY_OBJ.AUDIO);
    poly.registerNode(RivetObjNode, CATEGORY_OBJ.TRANSFORM);
    poly.registerNode(obj_Scene/* SceneObjNode */.H, CATEGORY_OBJ.ADVANCED);
    poly.registerNode(OrthographicCamera/* OrthographicCameraObjNode */.A, CATEGORY_OBJ.CAMERA);
    poly.registerNode(PerspectiveCamera/* PerspectiveCameraObjNode */.n, CATEGORY_OBJ.CAMERA);
    poly.registerNode(ActorsNetworkObjNode, CATEGORY_OBJ.NETWORK);
    poly.registerNode(AnimationsNetworkObjNode, CATEGORY_OBJ.NETWORK);
    poly.registerNode(AudioNetworkObjNode, CATEGORY_OBJ.NETWORK);
    poly.registerNode(CopNetworkObjNode, CATEGORY_OBJ.NETWORK);
    poly.registerNode(EventsNetworkObjNode, CATEGORY_OBJ.NETWORK);
    poly.registerNode(MaterialsNetworkObjNode, CATEGORY_OBJ.NETWORK);
    poly.registerNode(obj_PostProcessNetwork/* PostProcessNetworkObjNode */.h, CATEGORY_OBJ.NETWORK);
    poly.registerNode(RenderersNetworkObjNode, CATEGORY_OBJ.NETWORK);
  }
}

// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/nodes/post/_Base.ts
var post_Base = __webpack_require__(30538);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/node_modules/postprocessing/build/index.js
var build = __webpack_require__(43109);
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/post/Antialiasing.ts

var Antialiasing_defProp = Object.defineProperty;
var Antialiasing_getOwnPropSymbols = Object.getOwnPropertySymbols;
var Antialiasing_hasOwnProp = Object.prototype.hasOwnProperty;
var Antialiasing_propIsEnum = Object.prototype.propertyIsEnumerable;
var Antialiasing_defNormalProp = (obj, key, value) => key in obj ? Antialiasing_defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var Antialiasing_spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (Antialiasing_hasOwnProp.call(b, prop))
      Antialiasing_defNormalProp(a, prop, b[prop]);
  if (Antialiasing_getOwnPropSymbols)
    for (var prop of Antialiasing_getOwnPropSymbols(b)) {
      if (Antialiasing_propIsEnum.call(b, prop))
        Antialiasing_defNormalProp(a, prop, b[prop]);
    }
  return a;
};



class AntialiasingPostParamsConfig extends params_ParamsConfig/* NodeParamsConfig */.yI {
  constructor() {
    super(...arguments);
    /** @param opacity */
    this.opacity = params_ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(1, Antialiasing_spreadValues({
      range: [0, 1],
      rangeLocked: [true, true]
    }, post_Base/* PostParamOptions */._3));
  }
}
const Antialiasing_ParamsConfig = new AntialiasingPostParamsConfig();
class AntialiasingPostNode extends post_Base/* TypedPostNode */.mN {
  constructor() {
    super(...arguments);
    this.paramsConfig = Antialiasing_ParamsConfig;
  }
  static type() {
    return "antialiasing";
  }
  createPass(context) {
    const smaaEffect = new build/* SMAAEffect */.fY(
      {
        preset: build/* SMAAPreset.ULTRA */.F9.ULTRA
      }
      // assets.get("smaa-search"),
      // assets.get("smaa-area"),
      // SMAAPreset.HIGH,
      // EdgeDetectionMode.COLOR
    );
    smaaEffect.edgeDetectionMaterial.edgeDetectionThreshold = 0.02;
    smaaEffect.edgeDetectionMaterial.predicationMode = build/* PredicationMode.DEPTH */.Eb.DEPTH;
    smaaEffect.edgeDetectionMaterial.predicationThreshold = 2e-3;
    smaaEffect.edgeDetectionMaterial.predicationScale = 1;
    const edgesTextureEffect = new build/* TextureEffect */.tq({
      blendFunction: build/* BlendFunction.SKIP */.YQ.SKIP,
      texture: smaaEffect.edgesTexture
    });
    const weightsTextureEffect = new build/* TextureEffect */.tq({
      blendFunction: build/* BlendFunction.SKIP */.YQ.SKIP,
      texture: smaaEffect.weightsTexture
    });
    const pass = new build/* EffectPass */.H5(context.camera, smaaEffect, edgesTextureEffect, weightsTextureEffect);
    this.updatePass(pass);
    return pass;
  }
  updatePass(pass) {
    const effect = pass.effects[0];
    effect.blendMode.opacity.value = this.pv.opacity;
  }
}

// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/nodes/post/Bloom.ts
var Bloom = __webpack_require__(90278);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/core/post/KernelSize.ts
var KernelSize = __webpack_require__(51417);
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/post/Blur.ts

var Blur_defProp = Object.defineProperty;
var Blur_getOwnPropSymbols = Object.getOwnPropertySymbols;
var Blur_hasOwnProp = Object.prototype.hasOwnProperty;
var Blur_propIsEnum = Object.prototype.propertyIsEnumerable;
var Blur_defNormalProp = (obj, key, value) => key in obj ? Blur_defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var Blur_spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (Blur_hasOwnProp.call(b, prop))
      Blur_defNormalProp(a, prop, b[prop]);
  if (Blur_getOwnPropSymbols)
    for (var prop of Blur_getOwnPropSymbols(b)) {
      if (Blur_propIsEnum.call(b, prop))
        Blur_defNormalProp(a, prop, b[prop]);
    }
  return a;
};




class BlurPostParamsConfig extends params_ParamsConfig/* NodeParamsConfig */.yI {
  constructor() {
    super(...arguments);
    /** @param amount */
    this.amount = params_ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(1, Blur_spreadValues({
      range: [0, 2],
      rangeLocked: [true, false],
      step: 0.01
    }, post_Base/* PostParamOptions */._3));
    /** @param kernel size */
    this.kernelSize = params_ParamsConfig/* ParamConfig.INTEGER */.XC.INTEGER(build/* KernelSize.LARGE */.DD.LARGE, Blur_spreadValues(Blur_spreadValues({}, post_Base/* PostParamOptions */._3), KernelSize/* KERNEL_SIZE_MENU_OPTIONS */.N));
  }
}
const Blur_ParamsConfig = new BlurPostParamsConfig();
class BlurPostNode extends post_Base/* TypedPostNode */.mN {
  constructor() {
    super(...arguments);
    this.paramsConfig = Blur_ParamsConfig;
  }
  static type() {
    return "blur";
  }
  createPass(context) {
    const pass = new build/* KawaseBlurPass */.ki();
    this.updatePass(pass);
    return pass;
  }
  updatePass(pass) {
    pass.scale = this.pv.amount;
    pass.blurMaterial.kernelSize = KernelSize/* KERNEL_SIZES */.l[this.pv.kernelSize];
  }
}

// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/core/post/BlendFunction.ts
var BlendFunction = __webpack_require__(45415);
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/post/BrightnessContrast.ts

var BrightnessContrast_defProp = Object.defineProperty;
var BrightnessContrast_getOwnPropSymbols = Object.getOwnPropertySymbols;
var BrightnessContrast_hasOwnProp = Object.prototype.hasOwnProperty;
var BrightnessContrast_propIsEnum = Object.prototype.propertyIsEnumerable;
var BrightnessContrast_defNormalProp = (obj, key, value) => key in obj ? BrightnessContrast_defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var BrightnessContrast_spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (BrightnessContrast_hasOwnProp.call(b, prop))
      BrightnessContrast_defNormalProp(a, prop, b[prop]);
  if (BrightnessContrast_getOwnPropSymbols)
    for (var prop of BrightnessContrast_getOwnPropSymbols(b)) {
      if (BrightnessContrast_propIsEnum.call(b, prop))
        BrightnessContrast_defNormalProp(a, prop, b[prop]);
    }
  return a;
};




class BrightnessContrastPostParamsConfig extends params_ParamsConfig/* NodeParamsConfig */.yI {
  constructor() {
    super(...arguments);
    /** @param brightness */
    this.brightness = params_ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(0, BrightnessContrast_spreadValues({
      range: [-1, 1],
      rangeLocked: [false, false]
    }, post_Base/* PostParamOptions */._3));
    /** @param contrast */
    this.contrast = params_ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(0, BrightnessContrast_spreadValues({
      range: [-1, 1],
      rangeLocked: [false, false]
    }, post_Base/* PostParamOptions */._3));
    /** @param effect opacity */
    this.opacity = params_ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(1, BrightnessContrast_spreadValues({
      range: [0, 1],
      rangeLocked: [true, false]
    }, post_Base/* PostParamOptions */._3));
    /** @param render mode */
    this.blendFunction = params_ParamsConfig/* ParamConfig.INTEGER */.XC.INTEGER(build/* BlendFunction.NORMAL */.YQ.NORMAL, BrightnessContrast_spreadValues(BrightnessContrast_spreadValues({}, post_Base/* PostParamOptions */._3), BlendFunction/* BLEND_FUNCTION_MENU_OPTIONS */.z));
  }
}
const BrightnessContrast_ParamsConfig = new BrightnessContrastPostParamsConfig();
class BrightnessContrastPostNode extends post_Base/* TypedPostNode */.mN {
  constructor() {
    super(...arguments);
    this.paramsConfig = BrightnessContrast_ParamsConfig;
  }
  static type() {
    return "brightnessContrast";
  }
  createPass(context) {
    const effect = new build/* BrightnessContrastEffect */.at();
    const camera = context.camera;
    const pass = new build/* EffectPass */.H5(camera, effect);
    this.updatePass(pass);
    return pass;
  }
  updatePass(pass) {
    const effect = pass.effects[0];
    effect.brightness = this.pv.brightness;
    effect.contrast = this.pv.contrast;
    effect.blendMode.opacity.value = this.pv.opacity;
    effect.blendMode.blendFunction = this.pv.blendFunction;
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/post/utils/BuilderEffect.ts




class BuilderEffect extends build/* Effect */.Qm {
  constructor(_composerInput1, options) {
    super("BuilderEffect", options.fragmentShader, {
      blendFunction: build/* BlendFunction.NORMAL */.YQ.NORMAL,
      uniforms: /* @__PURE__ */ new Map([
        // ['texture1', new Uniform(null)],
        ["textureInput1", new three_module.Uniform(null)]
      ])
    });
    this._composerInput1 = _composerInput1;
    this.options = options;
  }
  updateFragmentShader(fragmentShader) {
    this.setFragmentShader(fragmentShader);
  }
  updateUniforms(uniforms) {
    const uniformNames = Object.keys(uniforms);
    for (const uniformName of uniformNames) {
      if (uniformName != "time") {
        this.uniforms.set(uniformName, uniforms[uniformName]);
      }
    }
  }
  update(renderer, inputBuffer, deltaTime) {
    this._composerInput1.render(deltaTime);
    const textureInput1 = this.uniforms.get("textureInput1");
    if (textureInput1) {
      textureInput1.value = this.options.useOutputBuffer ? this._composerInput1.outputBuffer.texture : this._composerInput1.inputBuffer.texture;
    } else {
      console.warn("missing texture2");
    }
    super.update(renderer, inputBuffer, deltaTime);
  }
  setSize(width, height) {
    super.setSize(width, height);
    const pixelRatio = this._composerInput1.getRenderer().getPixelRatio();
    this._composerInput1.setSize(width / pixelRatio, height / pixelRatio, false);
  }
}

// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/nodes/gl/code/globals/Geometry.ts
var Geometry = __webpack_require__(21806);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/nodes/gl/code/utils/NodeFinder.ts
var NodeFinder = __webpack_require__(69904);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/nodes/utils/BasePersistedConfig.ts
var BasePersistedConfig = __webpack_require__(14802);
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/gl/code/assemblers/post/PostPersistedConfig.ts

var PostPersistedConfig_async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};



const FRAGMENT_KEY = "fragment";
class PostPersistedConfig extends BasePersistedConfig/* BasePersistedConfig */.p {
  constructor(node) {
    super(node);
    this.node = node;
  }
  toData() {
    return PostPersistedConfig_async(this, null, function* () {
      const assemblerController = this.node.assemblerController();
      if (!assemblerController) {
        return;
      }
      const param_uniform_pairs = [];
      const param_configs = assemblerController.assembler.param_configs();
      for (const param_config of param_configs) {
        param_uniform_pairs.push([param_config.name(), param_config.uniformName()]);
      }
      const data = {
        // fragment_shader: this.node.fragmentShader(),
        uniforms: this.node.uniforms(),
        param_uniform_pairs,
        uniforms_time_dependent: assemblerController.assembler.uniformsTimeDependent(),
        uniforms_resolution_dependent: assemblerController.assembler.uniformsResolutionDependent(),
        shaders: {
          [FRAGMENT_KEY]: this.node.fragmentShader()
        }
      };
      return data;
    });
  }
  load(data) {
    const assemblerController = this.node.assemblerController();
    if (assemblerController) {
      return;
    }
    const shaders = data.shaders;
    if (shaders && shaders[FRAGMENT_KEY] != null) {
      this.node.setFragmentShader(shaders[FRAGMENT_KEY]);
    } else {
      console.warn(`${this.node.path()}: persisted config has no fragment shader`);
    }
    this.node.setUniforms(data.uniforms);
    BuilderPostNode.handleDependencies(
      this.node,
      data.uniforms_time_dependent || false,
      data.uniforms
    );
    for (const pair of data.param_uniform_pairs) {
      const param = this.node.params.get(pair[0]);
      const uniform = data.uniforms[pair[1]];
      if (param && uniform) {
        const callback = () => {
          GLParamConfig/* GlParamConfig.callback */.b.callback(param, uniform);
        };
        param.options.set({
          callback
        });
        callback();
      }
    }
  }
}

// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/poly/registers/nodes/types/Post.ts
var Post = __webpack_require__(4138);
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/post/gl/builder.glsl
/* harmony default export */ var builder = ("void mainImage(const in vec4 inputColor, const in vec2 uv, out vec4 outputColor) {\n\n\toutputColor = inputColor;\n\n}");
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/post/Builder.ts

var Builder_defProp = Object.defineProperty;
var Builder_getOwnPropSymbols = Object.getOwnPropertySymbols;
var Builder_hasOwnProp = Object.prototype.hasOwnProperty;
var Builder_propIsEnum = Object.prototype.propertyIsEnumerable;
var Builder_defNormalProp = (obj, key, value) => key in obj ? Builder_defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var Builder_spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (Builder_hasOwnProp.call(b, prop))
      Builder_defNormalProp(a, prop, b[prop]);
  if (Builder_getOwnPropSymbols)
    for (var prop of Builder_getOwnPropSymbols(b)) {
      if (Builder_propIsEnum.call(b, prop))
        Builder_defNormalProp(a, prop, b[prop]);
    }
  return a;
};












class BuilderPostParamsConfig extends params_ParamsConfig/* NodeParamsConfig */.yI {
  constructor() {
    super(...arguments);
    /** @param effect amount */
    this.useInput1OuputBuffer = params_ParamsConfig/* ParamConfig.BOOLEAN */.XC.BOOLEAN(1, Builder_spreadValues({}, post_Base/* PostParamOptions */._3));
  }
}
const Builder_ParamsConfig = new BuilderPostParamsConfig();
class BuilderPostNode extends post_Base/* TypedPostNode */.mN {
  constructor() {
    super(...arguments);
    this.paramsConfig = Builder_ParamsConfig;
    this.persisted_config = new PostPersistedConfig(this);
    this._assemblerController = this._createAssemblerController();
    this._childrenControllerContext = poly_NodeContext/* NodeContext.GL */.sy.GL;
    // private _cook_main_without_inputs_when_dirty_bound = this._cook_main_without_inputs_when_dirty.bind(this);
    // private async _cook_main_without_inputs_when_dirty() {
    // 	await this.cookController.cookMainWithoutInputs();
    // }
    // override cook() {
    // 	this.compileIfRequired();
    // 	this.cookController.endCook();
    // }
    /**
     *
     * FRAGMENT SHADER UPDATE
     *
     */
    this._fragmentShader = builder;
    this._uniforms = {};
  }
  static type() {
    return Post/* PostType.BUILDER */.h.BUILDER;
  }
  usedAssembler() {
    return _BaseRegister/* AssemblerName.GL_POST */.Q.GL_POST;
  }
  _createAssemblerController() {
    const assemblerController = Poly/* Poly.assemblersRegister.assembler */.L.assemblersRegister.assembler(this, this.usedAssembler());
    if (assemblerController) {
      const globalsHandler = new Geometry/* GlobalsGeometryHandler */.f();
      assemblerController.setAssemblerGlobalsHandler(globalsHandler);
      return assemblerController;
    }
  }
  assemblerController() {
    return this._assemblerController;
  }
  initializeNode() {
    super.initializeNode();
    this.io.inputs.setCount(0, 2);
    this.addPostDirtyHook("_cook_main_without_inputs_when_dirty", () => {
      this.compileIfRequired();
    });
  }
  createNode(node_class, options) {
    return super.createNode(node_class, options);
  }
  children() {
    return super.children();
  }
  nodesByType(type) {
    return super.nodesByType(type);
  }
  childrenAllowed() {
    if (this.assemblerController()) {
      return super.childrenAllowed();
    }
    return false;
  }
  sceneReadonly() {
    return this.assemblerController() == null;
  }
  fragmentShader() {
    return this._fragmentShader;
  }
  setFragmentShader(fragmentShader) {
    this._fragmentShader = fragmentShader;
    this._updatePasses();
  }
  uniforms() {
    return this._uniforms;
  }
  setUniforms(uniforms) {
    this._uniforms = uniforms;
    this._updatePasses();
  }
  shaders_by_name() {
    return {
      fragment: this._fragmentShader
    };
  }
  compileIfRequired() {
    var _a;
    if ((_a = this.assemblerController()) == null ? void 0 : _a.compileRequired()) {
      try {
        this.compile();
      } catch (err) {
        const message = err.message || "failed to compile";
        this.states.error.set(message);
      }
    }
  }
  compile() {
    const assemblerController = this.assemblerController();
    if (!assemblerController) {
      return;
    }
    const outputNodes = NodeFinder/* GlNodeFinder.findOutputNodes */.W.findOutputNodes(this);
    if (outputNodes.length == 0) {
      this.states.error.set("one output node is required");
      return;
    }
    if (outputNodes.length > 1) {
      this.states.error.set("only one output node allowed");
      return;
    }
    const outputNode = outputNodes[0];
    if (outputNode) {
      const rootNodes = outputNodes;
      assemblerController.assembler.set_root_nodes(rootNodes);
      assemblerController.assembler.updateFragmentShader();
      const fragmentShader = assemblerController.assembler.fragment_shader();
      const uniforms = assemblerController.assembler.uniforms();
      if (fragmentShader && uniforms) {
        this._fragmentShader = fragmentShader;
        this._uniforms = uniforms;
      }
      BuilderPostNode.handleDependencies(this, assemblerController.assembler.uniformsTimeDependent());
    }
    if (this._fragmentShader && this._uniforms) {
      this._updatePasses();
    }
    assemblerController.post_compile();
  }
  static handleDependencies(node, timeDependent, uniforms) {
  }
  /**
   *
   * PASS CREATE / UPDATE
   *
   */
  createPass(context) {
    this.compileIfRequired();
    const composerInput1 = this._createEffectComposer(context);
    composerInput1.autoRenderToScreen = false;
    const clonedContextInput1 = Builder_spreadValues({}, context);
    clonedContextInput1.composer = composerInput1;
    this._addPassFromInput(1, clonedContextInput1);
    const effect = new BuilderEffect(composerInput1, {
      fragmentShader: this._fragmentShader,
      useOutputBuffer: this.pv.useInput1OuputBuffer
    });
    const pass = new build/* EffectPass */.H5(context.camera, effect);
    this.updatePass(pass);
    return pass;
  }
  updatePass(pass) {
    const effect = pass.effects[0];
    effect.updateUniforms(this._uniforms);
    effect.updateFragmentShader(this._fragmentShader);
    pass.fullscreenMaterial.needsUpdate = true;
  }
  _createEffectComposer(context) {
    const parentNode = this._postProcessNetworkNode();
    return parentNode.effectsComposerController.createEffectsComposer(context);
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/post/ChromaticAberration.ts

var ChromaticAberration_defProp = Object.defineProperty;
var ChromaticAberration_getOwnPropSymbols = Object.getOwnPropertySymbols;
var ChromaticAberration_hasOwnProp = Object.prototype.hasOwnProperty;
var ChromaticAberration_propIsEnum = Object.prototype.propertyIsEnumerable;
var ChromaticAberration_defNormalProp = (obj, key, value) => key in obj ? ChromaticAberration_defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var ChromaticAberration_spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (ChromaticAberration_hasOwnProp.call(b, prop))
      ChromaticAberration_defNormalProp(a, prop, b[prop]);
  if (ChromaticAberration_getOwnPropSymbols)
    for (var prop of ChromaticAberration_getOwnPropSymbols(b)) {
      if (ChromaticAberration_propIsEnum.call(b, prop))
        ChromaticAberration_defNormalProp(a, prop, b[prop]);
    }
  return a;
};




const v2 = new three_module.Vector2();
class ChromaticAberrationPostParamsConfig extends params_ParamsConfig/* NodeParamsConfig */.yI {
  constructor() {
    super(...arguments);
    /** @param effect amount */
    this.amount = params_ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(5e-3, ChromaticAberration_spreadValues({
      range: [0, 0.01],
      rangeLocked: [true, false]
    }, post_Base/* PostParamOptions */._3));
    /** @param effect dir */
    this.direction = params_ParamsConfig/* ParamConfig.VECTOR2 */.XC.VECTOR2([1, 1], ChromaticAberration_spreadValues({}, post_Base/* PostParamOptions */._3));
  }
}
const ChromaticAberration_ParamsConfig = new ChromaticAberrationPostParamsConfig();
class ChromaticAberrationPostNode extends post_Base/* TypedPostNode */.mN {
  constructor() {
    super(...arguments);
    this.paramsConfig = ChromaticAberration_ParamsConfig;
  }
  static type() {
    return "chromaticAberration";
  }
  createPass(context) {
    const effect = new build/* ChromaticAberrationEffect */.YY();
    const pass = new build/* EffectPass */.H5(context.camera, effect);
    this.updatePass(pass);
    return pass;
  }
  updatePass(pass) {
    const effect = pass.effects[0];
    v2.copy(this.pv.direction).normalize().multiplyScalar(this.pv.amount);
    effect.offset.copy(v2);
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/post/DepthOfField.ts

var DepthOfField_defProp = Object.defineProperty;
var DepthOfField_defProps = Object.defineProperties;
var DepthOfField_getOwnPropDescs = Object.getOwnPropertyDescriptors;
var DepthOfField_getOwnPropSymbols = Object.getOwnPropertySymbols;
var DepthOfField_hasOwnProp = Object.prototype.hasOwnProperty;
var DepthOfField_propIsEnum = Object.prototype.propertyIsEnumerable;
var DepthOfField_defNormalProp = (obj, key, value) => key in obj ? DepthOfField_defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var DepthOfField_spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (DepthOfField_hasOwnProp.call(b, prop))
      DepthOfField_defNormalProp(a, prop, b[prop]);
  if (DepthOfField_getOwnPropSymbols)
    for (var prop of DepthOfField_getOwnPropSymbols(b)) {
      if (DepthOfField_propIsEnum.call(b, prop))
        DepthOfField_defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var DepthOfField_spreadProps = (a, b) => DepthOfField_defProps(a, DepthOfField_getOwnPropDescs(b));




const VIGNETTE_TECHNIQUES = [build/* VignetteTechnique.DEFAULT */.sv.DEFAULT, build/* VignetteTechnique.ESKIL */.sv.ESKIL];
const VIGNETTE_TECHNIQUE_NAME_BY_TECHNIQUE = {
  [build/* VignetteTechnique.DEFAULT */.sv.DEFAULT]: "DEFAULT",
  [build/* VignetteTechnique.ESKIL */.sv.ESKIL]: "ESKIL"
};
var RenderMode = /* @__PURE__ */ ((RenderMode2) => {
  RenderMode2["DEFAULT"] = "DEFAULT";
  RenderMode2["DEPTH"] = "DEPTH";
  RenderMode2["COC"] = "CIRCLE_OF_CONFUSION";
  return RenderMode2;
})(RenderMode || {});
const RENDER_MODES = ["DEFAULT" /* DEFAULT */, "DEPTH" /* DEPTH */, "CIRCLE_OF_CONFUSION" /* COC */];
class DepthOfFieldPostParamsConfig extends params_ParamsConfig/* NodeParamsConfig */.yI {
  constructor() {
    super(...arguments);
    this.depthOfField = params_ParamsConfig/* ParamConfig.FOLDER */.XC.FOLDER();
    /** @param focalDepth */
    this.focusDistance = params_ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(10, DepthOfField_spreadValues({
      range: [0, 1],
      rangeLocked: [true, false]
    }, post_Base/* PostParamOptions */._3));
    /** @param focalDepth */
    this.focusRange = params_ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(1, DepthOfField_spreadValues({
      range: [0, 1],
      rangeLocked: [true, true]
    }, post_Base/* PostParamOptions */._3));
    /** @param bokeh scale */
    this.bokehScale = params_ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(2, DepthOfField_spreadValues({
      range: [0, 5],
      rangeLocked: [true, false]
    }, post_Base/* PostParamOptions */._3));
    this.vignette = params_ParamsConfig/* ParamConfig.FOLDER */.XC.FOLDER();
    /** @param vignetting */
    this.vignetting = params_ParamsConfig/* ParamConfig.BOOLEAN */.XC.BOOLEAN(0, DepthOfField_spreadValues({}, post_Base/* PostParamOptions */._3));
    /** @param vignette technique */
    this.vignettingTechnique = params_ParamsConfig/* ParamConfig.INTEGER */.XC.INTEGER(0, DepthOfField_spreadProps(DepthOfField_spreadValues({}, post_Base/* PostParamOptions */._3), {
      menu: {
        entries: VIGNETTE_TECHNIQUES.map((value) => {
          return {
            name: VIGNETTE_TECHNIQUE_NAME_BY_TECHNIQUE[value],
            value
          };
        })
      }
    }));
    /** @param vignette darkness */
    this.vignetteDarkness = params_ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(0.5, DepthOfField_spreadValues({
      range: [0, 1],
      rangeLocked: [true, false],
      step: 1e-3
    }, post_Base/* PostParamOptions */._3));
    /** @param vignette offset */
    this.vignetteOffset = params_ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(0.35, DepthOfField_spreadValues({
      range: [0, 1],
      rangeLocked: [true, false],
      step: 1e-3
    }, post_Base/* PostParamOptions */._3));
    this.debug = params_ParamsConfig/* ParamConfig.FOLDER */.XC.FOLDER();
    /** @param render mode */
    this.renderMode = params_ParamsConfig/* ParamConfig.INTEGER */.XC.INTEGER(0, DepthOfField_spreadProps(DepthOfField_spreadValues({}, post_Base/* PostParamOptions */._3), {
      menu: {
        entries: RENDER_MODES.map((name, value) => ({ name, value }))
      }
    }));
  }
}
const DepthOfField_ParamsConfig = new DepthOfFieldPostParamsConfig();
class DepthOfFieldPostNode extends post_Base/* TypedPostNode */.mN {
  constructor() {
    super(...arguments);
    this.paramsConfig = DepthOfField_ParamsConfig;
  }
  static type() {
    return "depthOfField";
  }
  createPass(context) {
    const depthOfFieldEffect = new build/* DepthOfFieldEffect */.Jy(context.camera, {
      blendFunction: build/* BlendFunction.NORMAL */.YQ.NORMAL,
      focusDistance: 0,
      // focalLength: 0.048,
      focusRange: 1,
      bokehScale: 2,
      height: 480,
      worldFocusDistance: 1,
      worldFocusRange: 1
    });
    const depthEffect = new build/* DepthEffect */.AL({
      blendFunction: build/* BlendFunction.SKIP */.YQ.SKIP
    });
    const vignetteEffect = new build/* VignetteEffect */.Dd({
      eskil: false,
      offset: 0.35,
      darkness: 0.5
    });
    const cocTextureEffect = new build/* TextureEffect */.tq({
      blendFunction: build/* BlendFunction.SKIP */.YQ.SKIP,
      texture: depthOfFieldEffect.cocTexture
    });
    const DOFPass = new build/* EffectPass */.H5(
      context.camera,
      depthOfFieldEffect,
      vignetteEffect,
      cocTextureEffect,
      depthEffect
    );
    this.updatePass(DOFPass);
    return DOFPass;
  }
  updatePass(pass) {
    const effects = pass.effects;
    const vignetteEffect = effects.find((effect) => effect instanceof build/* VignetteEffect */.Dd);
    if (vignetteEffect) {
      this._updateDOFPass(pass);
    } else {
      this._updateSmaaPass(pass);
    }
  }
  _updateSmaaPass(pass) {
    const renderMode = RENDER_MODES[this.pv.renderMode];
    pass.enabled = renderMode === "DEFAULT" /* DEFAULT */;
  }
  _updateDOFPass(pass) {
    const effects = pass.effects;
    const vignetteEffect = effects.find((effect) => effect instanceof build/* VignetteEffect */.Dd);
    const DOF = effects.find((effect) => effect instanceof build/* DepthOfFieldEffect */.Jy);
    const depthEffect = effects.find((effect) => effect instanceof build/* DepthEffect */.AL);
    const cocTextureEffect = effects.find((effect) => effect instanceof build/* TextureEffect */.tq);
    const vignetteEnabled = (0,Type/* isBooleanTrue */.bI)(this.pv.vignetting);
    const renderMode = RENDER_MODES[this.pv.renderMode];
    depthEffect.blendMode.blendFunction = renderMode === "DEPTH" /* DEPTH */ ? build/* BlendFunction.NORMAL */.YQ.NORMAL : build/* BlendFunction.SKIP */.YQ.SKIP;
    cocTextureEffect.blendMode.blendFunction = renderMode === "CIRCLE_OF_CONFUSION" /* COC */ ? build/* BlendFunction.NORMAL */.YQ.NORMAL : build/* BlendFunction.SKIP */.YQ.SKIP;
    vignetteEffect.blendMode.blendFunction = renderMode === "DEFAULT" /* DEFAULT */ && vignetteEnabled ? build/* BlendFunction.NORMAL */.YQ.NORMAL : build/* BlendFunction.SKIP */.YQ.SKIP;
    DOF.circleOfConfusionMaterial.focusDistance = this.pv.focusDistance;
    DOF.circleOfConfusionMaterial.focusRange = this.pv.focusRange;
    DOF.bokehScale = this.pv.bokehScale;
    vignetteEffect.blendMode.opacity.value = vignetteEnabled ? 1 : 0;
    vignetteEffect.darkness = this.pv.vignetteDarkness;
    vignetteEffect.offset = this.pv.vignetteOffset;
  }
}

// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/nodes/post/EffectPass.ts
var EffectPass = __webpack_require__(10679);
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/post/Glitch.ts

var Glitch_defProp = Object.defineProperty;
var Glitch_defProps = Object.defineProperties;
var Glitch_getOwnPropDescs = Object.getOwnPropertyDescriptors;
var Glitch_getOwnPropSymbols = Object.getOwnPropertySymbols;
var Glitch_hasOwnProp = Object.prototype.hasOwnProperty;
var Glitch_propIsEnum = Object.prototype.propertyIsEnumerable;
var Glitch_defNormalProp = (obj, key, value) => key in obj ? Glitch_defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var Glitch_spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (Glitch_hasOwnProp.call(b, prop))
      Glitch_defNormalProp(a, prop, b[prop]);
  if (Glitch_getOwnPropSymbols)
    for (var prop of Glitch_getOwnPropSymbols(b)) {
      if (Glitch_propIsEnum.call(b, prop))
        Glitch_defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var Glitch_spreadProps = (a, b) => Glitch_defProps(a, Glitch_getOwnPropDescs(b));
var Glitch_async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};






const GLITCH_MODES = [
  build/* GlitchMode.DISABLED */.O7.DISABLED,
  build/* GlitchMode.SPORADIC */.O7.SPORADIC,
  build/* GlitchMode.CONSTANT_MILD */.O7.CONSTANT_MILD,
  build/* GlitchMode.CONSTANT_WILD */.O7.CONSTANT_WILD
];
const GLITCH_MODE_BY_INDEX = ["DISABLED", "SPORADIC", "CONSTANT_MILD", "CONSTANT_WILD"];
const GLITCH_MODE_MENU_OPTIONS = {
  menu: {
    entries: GLITCH_MODES.map((value) => {
      return {
        name: GLITCH_MODE_BY_INDEX[value],
        value
      };
    })
  }
};
class GlitchPostParamsConfig extends params_ParamsConfig/* NodeParamsConfig */.yI {
  constructor() {
    super(...arguments);
    // useTexture = ParamConfig.BOOLEAN(0, {
    // 	...PostParamOptions,
    // });
    this.texture = params_ParamsConfig/* ParamConfig.NODE_PATH */.XC.NODE_PATH("", Glitch_spreadValues({
      nodeSelection: {
        context: poly_NodeContext/* NodeContext.COP */.sy.COP
      },
      dependentOnFoundNode: false
    }, post_Base/* PostParamOptions */._3));
    // dtSize = ParamConfig.INTEGER(64, {
    // 	separatorBefore: true,
    // 	...PostParamOptions,
    // 	range: [2, 128],
    // 	rangeLocked: [true, false],
    // 	visibleIf: {useTexture: 0},
    // });
    /** @param mode */
    this.mode = params_ParamsConfig/* ParamConfig.INTEGER */.XC.INTEGER(GLITCH_MODES.indexOf(build/* GlitchMode.CONSTANT_MILD */.O7.CONSTANT_MILD), Glitch_spreadValues(Glitch_spreadValues({}, GLITCH_MODE_MENU_OPTIONS), post_Base/* PostParamOptions */._3));
    this.minDelay = params_ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(0.5, Glitch_spreadProps(Glitch_spreadValues({
      separatorBefore: true
    }, post_Base/* PostParamOptions */._3), {
      range: [0, 1],
      rangeLocked: [true, false]
    }));
    this.maxDelay = params_ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(0.5, Glitch_spreadProps(Glitch_spreadValues({}, post_Base/* PostParamOptions */._3), {
      range: [0, 1],
      rangeLocked: [true, false]
    }));
    this.minDuration = params_ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(0.5, Glitch_spreadProps(Glitch_spreadValues({
      separatorBefore: true
    }, post_Base/* PostParamOptions */._3), {
      range: [0, 1],
      rangeLocked: [true, false]
    }));
    this.maxDuration = params_ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(0.5, Glitch_spreadProps(Glitch_spreadValues({}, post_Base/* PostParamOptions */._3), {
      range: [0, 1],
      rangeLocked: [true, false]
    }));
    this.minStrength = params_ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(0.5, Glitch_spreadProps(Glitch_spreadValues({
      separatorBefore: true
    }, post_Base/* PostParamOptions */._3), {
      range: [0, 1],
      rangeLocked: [true, false]
    }));
    this.maxStrength = params_ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(0.5, Glitch_spreadProps(Glitch_spreadValues({}, post_Base/* PostParamOptions */._3), {
      range: [0, 1],
      rangeLocked: [true, false]
    }));
    /** @param columns */
    this.columns = params_ParamsConfig/* ParamConfig.INTEGER */.XC.INTEGER(2, Glitch_spreadProps(Glitch_spreadValues({}, post_Base/* PostParamOptions */._3), {
      range: [0, 20],
      rangeLocked: [true, false]
    }));
    /** @param ratio */
    this.ratio = params_ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(1, Glitch_spreadValues({
      range: [0, 1],
      rangeLocked: [true, true]
    }, post_Base/* PostParamOptions */._3));
    /** @param blend function */
    this.blendFunction = params_ParamsConfig/* ParamConfig.INTEGER */.XC.INTEGER(build/* BlendFunction.SCREEN */.YQ.SCREEN, Glitch_spreadValues(Glitch_spreadValues({}, post_Base/* PostParamOptions */._3), BlendFunction/* BLEND_FUNCTION_MENU_OPTIONS */.z));
    /** @param if true, the offset parameter will be updated on each render to reflect the intensity of the glitch. This can be used to drive other effects with it */
    this.updateOffset = params_ParamsConfig/* ParamConfig.BOOLEAN */.XC.BOOLEAN(0, Glitch_spreadValues({
      separatorBefore: true
    }, post_Base/* PostParamOptions */._3));
    this.offset = params_ParamsConfig/* ParamConfig.VECTOR2 */.XC.VECTOR2([0, 0], {
      cook: false,
      visibleIf: {
        updateOffset: 1
      }
    });
  }
}
const Glitch_ParamsConfig = new GlitchPostParamsConfig();
class GlitchPostNode extends post_Base/* TypedPostNode */.mN {
  constructor() {
    super(...arguments);
    this.paramsConfig = Glitch_ParamsConfig;
    this._rendererSize = new three_module.Vector2();
    this._offsetArray = [0, 0];
    this._onRenderBound = this._onRender.bind(this);
  }
  static type() {
    return "glitch";
  }
  createPass(context) {
    this._lastViewer = context.viewer;
    context.renderer.getSize(this._rendererSize);
    this._lastEffect = new build/* GlitchEffect */.sy({
      blendFunction: this.pv.blendFunction,
      chromaticAberrationOffset: new three_module.Vector2(0, 0)
      // delay:this.pv.delay,
      // duration:this.pv.duration,
      // strength:this.pv.strength,
      // dtSize: this.pv.dtSize,
    });
    const pass = new build/* EffectPass */.H5(context.camera, this._lastEffect);
    this.updatePass(pass);
    return pass;
  }
  updatePass(pass) {
    return Glitch_async(this, null, function* () {
      const effect = pass.effects[0];
      effect.blendFunction = this.pv.blendFunction;
      effect.mode = GLITCH_MODES[this.pv.mode];
      effect.minDelay = this.pv.minDelay;
      effect.maxDelay = this.pv.maxDelay;
      effect.minDuration = this.pv.minDuration;
      effect.maxDuration = this.pv.maxDuration;
      effect.minStrength = this.pv.minStrength;
      effect.maxStrength = this.pv.maxStrength;
      effect.columns = this.pv.columns;
      effect.ratio = this.pv.ratio;
      const texture = yield this._fetchTexture();
      if (texture) {
        effect.perturbationMap = texture;
      }
      this._updateOnTickCallback();
    });
  }
  _fetchTexture() {
    return Glitch_async(this, null, function* () {
      var _a;
      const textureNode = this.pv.texture.nodeWithContext(poly_NodeContext/* NodeContext.COP */.sy.COP, (_a = this.states) == null ? void 0 : _a.error);
      if (textureNode) {
        const container = yield textureNode.compute();
        return container.coreContent();
      }
    });
  }
  _onTickCallbackName() {
    return `post/glitch-${this.graphNodeId()}`;
  }
  _updateOnTickCallback() {
    if (!this._lastViewer) {
      return;
    }
    const callbackName = this._onTickCallbackName();
    if (this.pv.updateOffset) {
      if (!this._lastViewer.registeredAfterRenderCallbacks().has(callbackName)) {
        this._lastViewer.registerOnAfterRender(callbackName, this._onRenderBound);
      }
    } else {
      this._lastViewer.unRegisterOnAfterRender(callbackName);
    }
  }
  _onRender() {
    if (!this._lastEffect) {
      return;
    }
    this._lastEffect.chromaticAberrationOffset.toArray(this._offsetArray);
    this.p.offset.set(this._offsetArray);
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/post/GodRays.ts

var GodRays_defProp = Object.defineProperty;
var GodRays_getOwnPropSymbols = Object.getOwnPropertySymbols;
var GodRays_hasOwnProp = Object.prototype.hasOwnProperty;
var GodRays_propIsEnum = Object.prototype.propertyIsEnumerable;
var GodRays_defNormalProp = (obj, key, value) => key in obj ? GodRays_defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var GodRays_spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (GodRays_hasOwnProp.call(b, prop))
      GodRays_defNormalProp(a, prop, b[prop]);
  if (GodRays_getOwnPropSymbols)
    for (var prop of GodRays_getOwnPropSymbols(b)) {
      if (GodRays_propIsEnum.call(b, prop))
        GodRays_defNormalProp(a, prop, b[prop]);
    }
  return a;
};







const tmpParent = new three_module.Group();
const tmpLightSource = new three_module.Mesh(new three_module.BufferGeometry(), new three_module.MeshBasicMaterial());
tmpParent.add(tmpLightSource);
function _updateLightSourceMaterial(material) {
  material.depthWrite = false;
  material.transparent = true;
}
function _findLightSource(scene, objectMask) {
  let foundObject = void 0;
  const objects = scene.objectsByMask(objectMask);
  for (const object of objects) {
    if (object.isMesh || object.isPoints) {
      foundObject = object;
      break;
    }
  }
  return foundObject;
}
class GodRaysPostParamsConfig extends params_ParamsConfig/* NodeParamsConfig */.yI {
  constructor() {
    super(...arguments);
    /** @param objects to emit godrays from. Note that while the mask can resolve multiple objects, only the first mesh or points will be used */
    this.objectMask = params_ParamsConfig/* ParamConfig.STRING */.XC.STRING("*geo1*", {
      objectMask: true
    });
    /** @param samples */
    this.samples = params_ParamsConfig/* ParamConfig.INTEGER */.XC.INTEGER(60, GodRays_spreadValues({
      range: [1, 128],
      rangeLocked: [true, false]
    }, post_Base/* PostParamOptions */._3));
    /** @param density */
    this.density = params_ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(0.96, GodRays_spreadValues({
      range: [0, 1],
      rangeLocked: [true, true]
    }, post_Base/* PostParamOptions */._3));
    /** @param decay */
    this.decay = params_ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(0.9, GodRays_spreadValues({
      range: [0, 1],
      rangeLocked: [true, true]
    }, post_Base/* PostParamOptions */._3));
    /** @param weight */
    this.weight = params_ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(0.4, GodRays_spreadValues({
      range: [0, 1],
      rangeLocked: [true, true]
    }, post_Base/* PostParamOptions */._3));
    /** @param exposure */
    this.exposure = params_ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(0.6, GodRays_spreadValues({
      range: [0, 1],
      rangeLocked: [true, true]
    }, post_Base/* PostParamOptions */._3));
    /** @param blur */
    this.blur = params_ParamsConfig/* ParamConfig.BOOLEAN */.XC.BOOLEAN(1, GodRays_spreadValues({}, post_Base/* PostParamOptions */._3));
    /** @param kernel size */
    this.kernelSize = params_ParamsConfig/* ParamConfig.INTEGER */.XC.INTEGER(build/* KernelSize.LARGE */.DD.LARGE, GodRays_spreadValues(GodRays_spreadValues({
      visibleIf: { blur: 1 }
    }, post_Base/* PostParamOptions */._3), KernelSize/* KERNEL_SIZE_MENU_OPTIONS */.N));
    /** @param resolutionScale */
    this.resolutionScale = params_ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(0.5, GodRays_spreadValues({}, post_Base/* PostParamOptions */._3));
    /** @param effect opacity */
    this.opacity = params_ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(1, GodRays_spreadValues({
      range: [0, 1],
      rangeLocked: [true, false]
    }, post_Base/* PostParamOptions */._3));
    /** @param render mode */
    this.blendFunction = params_ParamsConfig/* ParamConfig.INTEGER */.XC.INTEGER(build/* BlendFunction.SCREEN */.YQ.SCREEN, GodRays_spreadValues(GodRays_spreadValues({}, post_Base/* PostParamOptions */._3), BlendFunction/* BLEND_FUNCTION_MENU_OPTIONS */.z));
  }
}
const GodRays_ParamsConfig = new GodRaysPostParamsConfig();
class GodRaysPostNode extends post_Base/* TypedPostNode */.mN {
  constructor() {
    super(...arguments);
    this.paramsConfig = GodRays_ParamsConfig;
    this._rendererSize = new three_module.Vector2();
  }
  static type() {
    return "godRays";
  }
  createPass(context) {
    context.renderer.getSize(this._rendererSize);
    const effect = new build/* GodRaysEffect */.KI(context.camera, tmpLightSource, {
      blendFunction: build/* BlendFunction.SCREEN */.YQ.SCREEN,
      kernelSize: KernelSize/* KERNEL_SIZES */.l[this.pv.kernelSize],
      blur: this.pv.blur,
      samples: this.pv.samples,
      density: this.pv.density,
      decay: this.pv.decay,
      weight: this.pv.weight,
      exposure: this.pv.exposure
    });
    const pass = new build/* EffectPass */.H5(context.camera, effect);
    this.updatePass(pass);
    return pass;
  }
  updatePass(pass) {
    const effect = pass.effects[0];
    effect.godRaysMaterial.samples = this.pv.samples;
    effect.godRaysMaterial.density = this.pv.density;
    effect.godRaysMaterial.decay = this.pv.decay;
    effect.godRaysMaterial.weight = this.pv.weight;
    effect.godRaysMaterial.exposure = this.pv.exposure;
    effect.blur = this.pv.blur;
    effect.blurPass.blurMaterial.kernelSize = KernelSize/* KERNEL_SIZES */.l[this.pv.kernelSize];
    effect.blurPass.resolution.scale = this.pv.resolutionScale;
    effect.blendMode.opacity.value = this.pv.opacity;
    effect.blendMode.blendFunction = this.pv.blendFunction;
    const lightSource = _findLightSource(this.scene(), this.pv.objectMask);
    if (lightSource) {
      effect.lightSource = lightSource;
      const material = lightSource.material;
      if (Type/* CoreType.isArray */.MR.isArray(material)) {
        for (const m of material) {
          _updateLightSourceMaterial(m);
        }
      } else {
        _updateLightSourceMaterial(material);
      }
    } else {
      effect.lightSource = tmpLightSource;
    }
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/post/utils/GodRaysVolumetric/utils/GodRaysConstant.ts

const GODRAYS_RESOLUTION_SCALE = 0.5;

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/post/utils/GodRaysVolumetric/gl/godrays.frag.glsl
/* harmony default export */ var godrays_frag = ("/*\n * Code taken from this demo: https://n8python.github.io/goodGodRays/\n * By: https://github.com/n8python\n *\n * With cleanup and minor changes\n */\n\nvarying vec2 vUv;\n\nuniform sampler2D sceneDepth;\nuniform sampler2D blueNoise;\nuniform vec3 lightPos;\nuniform vec3 cameraPos;\nuniform vec2 resolution;\nuniform mat4 lightCameraProjectionMatrix;\nuniform mat4 lightCameraMatrixWorldInverse;\nuniform mat4 cameraProjectionMatrixInv;\nuniform mat4 cameraMatrixWorld;\nuniform sampler2D shadowMap;\nuniform vec2 noiseResolution;\nuniform float mapSize;\nuniform float lightCameraNear;\nuniform float lightCameraFar;\nuniform float density;\nuniform float maxDensity;\nuniform float distanceAttenuation;\nuniform vec3[6] fNormals;\nuniform float[6] fConstants;\n#include <packing>\n\nvec3 WorldPosFromDepth(float depth, vec2 coord) {\n  float z = depth * 2.0 - 1.0;\n  vec4 clipSpacePosition = vec4(coord * 2.0 - 1.0, z, 1.0);\n  vec4 viewSpacePosition = cameraProjectionMatrixInv * clipSpacePosition;\n  // Perspective division\n  viewSpacePosition /= viewSpacePosition.w;\n  vec4 worldSpacePosition = cameraMatrixWorld * viewSpacePosition;\n  return worldSpacePosition.xyz;\n}\n\nfloat linearize_depth(float d,float zNear,float zFar) {\n  return zNear * zFar / (zFar + d * (zNear - zFar));\n}\n\n/**\n * Converts angle between light and a world position to a coordinate\n * in a point light cube shadow map\n */\nvec2 cubeToUV( vec3 v, float texelSizeY ) {\n  // Number of texels to avoid at the edge of each square\n  vec3 absV = abs( v );\n  // Intersect unit cube\n  float scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n  absV *= scaleToCube;\n  // Apply scale to avoid seams\n  // two texels less per square (one texel will do for NEAREST)\n  v *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n  // Unwrap\n  // space: -1 ... 1 range for each square\n  //\n  // #X##        dim    := ( 4 , 2 )\n  //  # #        center := ( 1 , 1 )\n  vec2 planar = v.xy;\n  float almostATexel = 1.5 * texelSizeY;\n  float almostOne = 1.0 - almostATexel;\n  if ( absV.z >= almostOne ) {\n    if ( v.z > 0.0 )\n      planar.x = 4.0 - v.x;\n  } else if ( absV.x >= almostOne ) {\n    float signX = sign( v.x );\n    planar.x = v.z * signX + 2.0 * signX;\n  } else if ( absV.y >= almostOne ) {\n    float signY = sign( v.y );\n    planar.x = v.x + 2.0 * signY + 2.0;\n    planar.y = v.z * signY - 2.0;\n  }\n  // Transform to UV space\n  // scale := 0.5 / dim\n  // translate := ( center + 0.5 ) / dim\n  return vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n}\n\n/**\n * Projects `worldPos` onto the shadow map of a directional light and returns\n * that position in UV space.\n */\nvec3 projectToShadowMap(vec3 worldPos) {\n  vec4 lightSpacePos = lightCameraProjectionMatrix * lightCameraMatrixWorldInverse * vec4(worldPos, 1.0);\n  lightSpacePos /= lightSpacePos.w;\n  lightSpacePos = lightSpacePos * 0.5 + 0.5;\n  return lightSpacePos.xyz;\n}\n\nvec2 inShadow(vec3 worldPos) {\n  #if defined(IS_POINT_LIGHT)\n    float texelSizeY = 1.0 / (mapSize * 2.0);\n    vec2 shadowMapUV = cubeToUV(normalize(worldPos - lightPos), texelSizeY);\n  #elif defined(IS_DIRECTIONAL_LIGHT)\n    vec3 shadowMapUV = projectToShadowMap(worldPos);\n    if (shadowMapUV.x < 0.0 || shadowMapUV.x > 1.0 || shadowMapUV.y < 0.0 || shadowMapUV.y > 1.0 || shadowMapUV.z < 0.0 || shadowMapUV.z > 1.0) {\n      return vec2(1.0, 0.0);\n    }\n  #endif\n\n  vec4 packedDepth = texture2D(shadowMap, shadowMapUV.xy);\n  float depth = unpackRGBAToDepth(packedDepth);\n  depth = lightCameraNear + (lightCameraFar - lightCameraNear) * depth;\n  #if defined(IS_POINT_LIGHT)\n    float lightDist = distance(worldPos, lightPos);\n  #elif defined(IS_DIRECTIONAL_LIGHT)\n    float lightDist = (lightCameraNear + (lightCameraFar - lightCameraNear) * shadowMapUV.z);\n  #endif\n  #if defined(IS_POINT_LIGHT)\n      float difference = lightDist - depth;\n  #elif defined(IS_DIRECTIONAL_LIGHT)\n      float difference = lightDist - depth;\n  #endif\n  return vec2(float(difference > 0.0), lightDist);\n}\n\nfloat sdPlane( vec3 p, vec3 n, float h )\n{\n  // n must be normalized\n  return dot(p,n) + h;\n}\nvoid main() {\n  float depth = texture2D(sceneDepth, vUv).x;\n\n  vec3 worldPos = WorldPosFromDepth(depth, vUv);\n  // vec2 tempUV = projectToShadowMap(worldPos);\n  // if (tempUV.x < 0.0 || tempUV.x > 1.0 || tempUV.y < 0.0 || tempUV.y > 1.0) {\n  //   gl_FragColor = vec4(0.0);\n  //   return;\n  // }\n  // gl_FragColor = vec4(tempUV, 0.0, 1.0);\n  // return;\n  float inBoxDist = -10000.0;\n  for(int i = 0; i < 6; i++) {\n    inBoxDist = max(inBoxDist, sdPlane(cameraPos, fNormals[i], fConstants[i]));\n  }\n  bool inBox = false;\n  if (inBoxDist < 0.0) {\n    inBox = true;\n  }\n  vec3 startPos = cameraPos;\n  if (inBox) {\n    for(int i = 0; i < 6; i++) {\n      if (sdPlane(worldPos, fNormals[i], fConstants[i]) > 0.0) {\n          vec3 direction = normalize(worldPos - cameraPos);\n          float denom = dot(fNormals[i], direction);\n          float t = -(dot(cameraPos, fNormals[i]) + fConstants[i]) / denom;\n          worldPos = cameraPos + t * direction;\n      }\n    }\n  } else {\n    vec3 direction = normalize(worldPos - cameraPos);\n    float minT = 10000.0;\n     for(int i = 0; i < 6; i++) {\n        float denom = dot(fNormals[i], direction);\n        float t = -(dot(cameraPos, fNormals[i]) + fConstants[i]) / denom;\n        if (t < minT && t > 0.0) {\n          minT = t;\n        }\n    }\n    if (minT == 10000.0) {\n      gl_FragColor = vec4(1.0, 0.0, 0.0, 1.0);\n      return;\n    } else {\n      startPos = cameraPos + (minT + 0.001) * direction;\n    }\n   float  endInBoxDist = -10000.0;\n    for(int i = 0; i < 6; i++) {\n      endInBoxDist = max(endInBoxDist, sdPlane(worldPos, fNormals[i], fConstants[i]));\n    }\n    bool endInBox = false;\n    if (endInBoxDist < 0.0) {\n      endInBox = true;\n    }\n    if (!endInBox) {\n       float minT = 10000.0;\n        for(int i = 0; i < 6; i++) {\n            if (sdPlane(worldPos, fNormals[i], fConstants[i]) > 0.0) {\n            float denom = dot(fNormals[i], direction);\n            float t = -(dot(startPos, fNormals[i]) + fConstants[i]) / denom;\n            if (t < minT && t > 0.0) {\n              minT = t;\n            }\n            }\n        }\n        if (minT < distance(worldPos, startPos)) {\n          worldPos = startPos + minT * direction;\n        }\n    }\n  }\n  float illum = 0.0;\n\n  vec4 blueNoiseSample = texture2D(blueNoise, vUv * (resolution / noiseResolution));\n  float samples = round(60.0 + 8.0 * blueNoiseSample.x);\n  for (float i = 0.0; i < samples; i++) {\n    vec3 samplePos = mix(startPos, worldPos, i / samples);\n    vec2 shadowInfo = inShadow(samplePos);\n    float shadowAmount = (1.0 - shadowInfo.x);\n    illum += shadowAmount * (distance(startPos, worldPos) * density) * pow(1.0 - shadowInfo.y / lightCameraFar, distanceAttenuation);// * exp(-distanceAttenuation * shadowInfo.y);\n  }\n  illum /= samples;\n  gl_FragColor = vec4(vec3(clamp((1.0 - exp(-illum)), 0.0, maxDensity)), depth);\n}\n");
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/post/utils/GodRaysVolumetric/gl/godrays.vert.glsl
/* harmony default export */ var godrays_vert = ("/*\n * Code taken from this demo: https://n8python.github.io/goodGodRays/\n * By: https://github.com/n8python\n *\n * With cleanup and minor changes\n */\n\nvarying vec2 vUv;\n\nvoid main() {\n\tvUv = position.xy * 0.5 + 0.5;\n\tgl_Position = vec4(position.xy, 1.0, 1.0);\n}\n");
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/post/utils/GodRaysVolumetric/gl/bluenoise.ts

const BlueNoiseTextureDataURI = "data:image/png;base64,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";

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/post/utils/GodRaysVolumetric/utils/GodRaysMaterial.ts

var GodRaysMaterial_async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};




const getBlueNoiseTexture = () => GodRaysMaterial_async(void 0, null, function* () {
  const textureLoader = new three_module.TextureLoader();
  const blueNoiseTexture = yield textureLoader.loadAsync(BlueNoiseTextureDataURI);
  blueNoiseTexture.wrapS = three_module.RepeatWrapping;
  blueNoiseTexture.wrapT = three_module.RepeatWrapping;
  blueNoiseTexture.magFilter = three_module.NearestFilter;
  blueNoiseTexture.minFilter = three_module.NearestFilter;
  return blueNoiseTexture;
});
class GodraysMaterial extends three_module.ShaderMaterial {
  constructor(props) {
    const uniforms = {
      density: { value: 1 / 128 },
      maxDensity: { value: 0.5 },
      distanceAttenuation: { value: 2 },
      sceneDepth: { value: null },
      lightPos: { value: new three_module.Vector3(0, 0, 0) },
      cameraPos: { value: new three_module.Vector3(0, 0, 0) },
      resolution: { value: new three_module.Vector2(1, 1) },
      lightCameraProjectionMatrix: { value: new three_module.Matrix4() },
      lightCameraMatrixWorldInverse: { value: new three_module.Matrix4() },
      cameraProjectionMatrixInv: { value: new three_module.Matrix4() },
      cameraMatrixWorld: { value: new three_module.Matrix4() },
      shadowMap: { value: null },
      mapSize: { value: 1 },
      lightCameraNear: { value: 0.1 },
      lightCameraFar: { value: 1e3 },
      blueNoise: { value: null },
      noiseResolution: { value: new three_module.Vector2(1, 1) },
      fNormals: { value: [] },
      fConstants: { value: [] }
    };
    const defines = {};
    if (props.light instanceof three_module.PointLight || props.light.isPointLight) {
      defines.IS_POINT_LIGHT = "";
    } else if (props.light instanceof three_module.DirectionalLight || props.light.isDirectionalLight) {
      defines.IS_DIRECTIONAL_LIGHT = "";
    }
    super({
      name: "GodraysMaterial",
      uniforms,
      fragmentShader: godrays_frag,
      vertexShader: godrays_vert,
      defines
    });
    getBlueNoiseTexture().then((blueNoiseTexture) => {
      uniforms.blueNoise.value = blueNoiseTexture;
      uniforms.noiseResolution.value.set(blueNoiseTexture.image.width, blueNoiseTexture.image.height);
    });
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/post/utils/GodRaysVolumetric/utils/GodRaysIlluminationPass.ts





class GodraysIllumPass extends build/* Pass */.w2 {
  constructor(props, params) {
    super("GodraysPass");
    this.params = params;
    this.shadowMapSet = false;
    this.lightWorldPos = new three_module.Vector3();
    this.props = props;
    this.lastParams = params;
    this.material = new GodraysMaterial(this.props);
    this.updateUniforms(this.props, this.params);
    this.fullscreenMaterial = this.material;
  }
  setSize(width, height) {
    this.material.uniforms.resolution.value.set(
      Math.ceil(width * GODRAYS_RESOLUTION_SCALE),
      Math.ceil(height * GODRAYS_RESOLUTION_SCALE)
    );
  }
  render(renderer, _inputBuffer, outputBuffer, _deltaTime, _stencilTest) {
    var _a;
    if (!this.shadowMapSet && ((_a = this.props.light.shadow.map) == null ? void 0 : _a.texture)) {
      this.updateUniforms(this.props, this.lastParams);
      this.shadowMapSet = true;
    }
    this._updateLightPosition(this.props);
    renderer.setRenderTarget(outputBuffer);
    renderer.render(this.scene, this.camera);
  }
  setDepthTexture(depthTexture, depthPacking) {
    this.material.uniforms.sceneDepth.value = depthTexture;
    if (depthPacking && depthPacking !== three_module.BasicDepthPacking) {
      throw new Error("Only BasicDepthPacking is supported");
    }
  }
  _updateLightPosition({ light, camera }) {
    light.getWorldPosition(this.lightWorldPos);
  }
  updateUniforms({ light, camera }, params) {
    var _a, _b, _c, _d, _e, _f;
    const shadow = light.shadow;
    if (!shadow) {
      throw new Error("Light used for godrays must have shadow");
    }
    const shadowMap = (_b = (_a = shadow.map) == null ? void 0 : _a.texture) != null ? _b : null;
    const mapSize = (_d = (_c = shadow.map) == null ? void 0 : _c.height) != null ? _d : 1;
    const uniforms = this.material.uniforms;
    uniforms.density.value = params.density;
    uniforms.maxDensity.value = params.maxDensity;
    uniforms.lightPos.value = this.lightWorldPos;
    uniforms.cameraPos.value = camera.position;
    uniforms.lightCameraProjectionMatrix.value = light.shadow.camera.projectionMatrix;
    uniforms.lightCameraMatrixWorldInverse.value = light.shadow.camera.matrixWorldInverse;
    uniforms.cameraProjectionMatrixInv.value = camera.projectionMatrixInverse;
    uniforms.cameraMatrixWorld.value = camera.matrixWorld;
    uniforms.shadowMap.value = shadowMap;
    uniforms.mapSize.value = mapSize;
    uniforms.lightCameraNear.value = (_e = shadow == null ? void 0 : shadow.camera.near) != null ? _e : 0.1;
    uniforms.lightCameraFar.value = (_f = shadow == null ? void 0 : shadow.camera.far) != null ? _f : 1e3;
    uniforms.density.value = params.density;
    uniforms.maxDensity.value = params.maxDensity;
    uniforms.distanceAttenuation.value = params.distanceAttenuation;
    if (light instanceof three_module.PointLight || light.isPointLight) {
      const planes = [];
      const directions = [
        new three_module.Vector3(1, 0, 0),
        new three_module.Vector3(-1, 0, 0),
        new three_module.Vector3(0, 1, 0),
        new three_module.Vector3(0, -1, 0),
        new three_module.Vector3(0, 0, 1),
        new three_module.Vector3(0, 0, -1)
      ];
      for (const direction of directions) {
        planes.push(
          new three_module.Plane().setFromNormalAndCoplanarPoint(
            direction,
            light.position.clone().add(direction.clone().multiplyScalar(uniforms.lightCameraFar.value))
          )
        );
      }
      uniforms.fNormals.value = planes.map((x) => x.normal.clone());
      uniforms.fConstants.value = planes.map((x) => x.constant);
    } else if (light instanceof three_module.DirectionalLight || light.isDirectionalLight) {
      const frustum = new three_module.Frustum();
      frustum.setFromProjectionMatrix(
        new three_module.Matrix4().multiplyMatrices(
          light.shadow.camera.projectionMatrix,
          light.shadow.camera.matrixWorldInverse
        )
      );
      uniforms.fNormals.value = frustum.planes.map((x) => x.normal.clone().multiplyScalar(-1));
      uniforms.fConstants.value = frustum.planes.map((x) => x.constant * -1);
    }
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/post/utils/GodRaysVolumetric/gl/compositor.frag.glsl
/* harmony default export */ var compositor_frag = ("/*\n * Code taken from this demo: https://n8python.github.io/goodGodRays/\n * By: https://github.com/n8python\n *\n * With cleanup and minor changes\n */\n\n#include <common>\n\nuniform sampler2D godrays;\nuniform sampler2D sceneDiffuse;\nuniform sampler2D sceneDepth;\nuniform float edgeStrength;\nuniform float edgeRadius;\nuniform vec2 resolution;\nuniform float near;\nuniform float far;\nuniform vec3 color;\nvarying vec2 vUv;\n\n#define DITHERING\n#include <dithering_pars_fragment>\n\nfloat linearize_depth (float d, float zNear, float zFar) {\n  return zNear * zFar / (zFar + d * (zNear - zFar));\n}\n\nvoid main() {\n  vec4 diffuse = texture2D(sceneDiffuse, vUv);\n\n  float rawDepth = texture2D(sceneDepth, vUv).x;\n  float correctDepth = linearize_depth(rawDepth, near, far);\n\n  vec2 pushDir = vec2(0.0);\n  float count = 0.0;\n  for (float x = -edgeRadius; x <= edgeRadius; x++) {\n    for (float y = -edgeRadius; y <= edgeRadius; y++) {\n      vec2 sampleUv = (vUv * resolution + vec2(x, y)) / resolution;\n      float sampleDepth = linearize_depth(texture2D(sceneDepth, sampleUv).x, near, far);\n      if (abs(sampleDepth - correctDepth) < 0.05 * correctDepth) {\n        pushDir += vec2(x, y);\n        count += 1.0;\n      }\n    }\n  }\n\n  if (count == 0.0) {\n    count = 1.0;\n  }\n\n  pushDir /= count;\n  pushDir = normalize(pushDir);\n  vec2 sampleUv = length(pushDir) > 0.0 ? vUv + edgeStrength * (pushDir / resolution) : vUv;\n  float bestChoice = texture2D(godrays, sampleUv).x;\n\n  gl_FragColor = vec4(mix(diffuse.rgb, color, bestChoice), 1.0);\n\n  #include <dithering_fragment>\n}\n");
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/post/utils/GodRaysVolumetric/gl/compositor.vert.glsl
/* harmony default export */ var compositor_vert = ("/*\n * Code taken from this demo: https://n8python.github.io/goodGodRays/\n * By: https://github.com/n8python\n *\n * With cleanup and minor changes\n */\n\nvarying vec2 vUv;\n\nvoid main() {\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}\n");
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/post/utils/GodRaysVolumetric/utils/GodRaysCompositorMaterial.ts




class GodraysCompositorMaterial extends three_module.ShaderMaterial {
  constructor({ godrays, edgeStrength, edgeRadius, color, camera }) {
    const uniforms = {
      godrays: { value: godrays },
      sceneDiffuse: { value: null },
      sceneDepth: { value: null },
      edgeStrength: { value: edgeStrength },
      edgeRadius: { value: edgeRadius },
      near: { value: 0.1 },
      far: { value: 1e3 },
      color: { value: color },
      resolution: { value: new three_module.Vector2(1, 1) }
    };
    super({
      name: "GodraysCompositorMaterial",
      uniforms,
      depthWrite: false,
      depthTest: false,
      fragmentShader: compositor_frag,
      vertexShader: compositor_vert
    });
    this.updateUniforms(edgeStrength, edgeRadius, color, camera.near, camera.far);
  }
  updateUniforms(edgeStrength, edgeRadius, color, near, far) {
    this.uniforms.edgeStrength.value = edgeStrength;
    this.uniforms.edgeRadius.value = edgeRadius;
    this.uniforms.color.value = color;
    this.uniforms.near.value = near;
    this.uniforms.far.value = far;
  }
  setSize(width, height) {
    this.uniforms.resolution.value.set(width, height);
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/post/utils/GodRaysVolumetric/utils/GodRaysPassParams.ts


const GodRaysPassDefaultParams = {
  density: 1 / 128,
  maxDensity: 0.5,
  edgeStrength: 2,
  edgeRadius: 2,
  distanceAttenuation: 2,
  color: new three_module.Color(16777215)
};

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/post/utils/GodRaysVolumetric/GodRaysPass.ts

var GodRaysPass_defProp = Object.defineProperty;
var GodRaysPass_defProps = Object.defineProperties;
var GodRaysPass_getOwnPropDescs = Object.getOwnPropertyDescriptors;
var GodRaysPass_getOwnPropSymbols = Object.getOwnPropertySymbols;
var GodRaysPass_hasOwnProp = Object.prototype.hasOwnProperty;
var GodRaysPass_propIsEnum = Object.prototype.propertyIsEnumerable;
var GodRaysPass_defNormalProp = (obj, key, value) => key in obj ? GodRaysPass_defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var GodRaysPass_spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (GodRaysPass_hasOwnProp.call(b, prop))
      GodRaysPass_defNormalProp(a, prop, b[prop]);
  if (GodRaysPass_getOwnPropSymbols)
    for (var prop of GodRaysPass_getOwnPropSymbols(b)) {
      if (GodRaysPass_propIsEnum.call(b, prop))
        GodRaysPass_defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var GodRaysPass_spreadProps = (a, b) => GodRaysPass_defProps(a, GodRaysPass_getOwnPropDescs(b));






class GodraysCompositorPass extends build/* Pass */.w2 {
  constructor(props) {
    super("GodraysCompositorPass");
    this.fullscreenMaterial = new GodraysCompositorMaterial(props);
    this.sceneCamera = props.camera;
  }
  updateUniforms(params) {
    this.fullscreenMaterial.updateUniforms(
      params.edgeStrength,
      params.edgeRadius,
      params.color,
      this.sceneCamera.near,
      this.sceneCamera.far
    );
  }
  render(renderer, inputBuffer, outputBuffer, _deltaTime, _stencilTest) {
    this.fullscreenMaterial.uniforms.sceneDiffuse.value = inputBuffer.texture;
    renderer.setRenderTarget(outputBuffer);
    renderer.render(this.scene, this.camera);
  }
  setDepthTexture(depthTexture, depthPacking) {
    if (depthPacking && depthPacking !== three_module.BasicDepthPacking) {
      throw new Error("Only BasicDepthPacking is supported");
    }
    this.fullscreenMaterial.uniforms.sceneDepth.value = depthTexture;
  }
  setSize(width, height) {
    this.fullscreenMaterial.setSize(width, height);
  }
}
const populateParams = (partialParams) => {
  var _a;
  return GodRaysPass_spreadProps(GodRaysPass_spreadValues(GodRaysPass_spreadValues({}, GodRaysPassDefaultParams), partialParams), {
    color: new three_module.Color((_a = partialParams.color) != null ? _a : GodRaysPassDefaultParams.color)
  });
};
class GodraysPass extends build/* Pass */.w2 {
  /**
   * Constructs a new GodraysPass.  Casts godrays from a point light source.  Add to your scene's composer like this:
   *
   * ```ts
   * import { EffectComposer, RenderPass } from 'postprocessing';
   * import { GodraysPass } from 'three-good-godrays';
   *
   * const composer = new EffectComposer(renderer);
   * const renderPass = new RenderPass(scene, camera);
   * renderPass.renderToScreen = false;
   * composer.addPass(renderPass);
   *
   * const godraysPass = new GodraysPass(pointLight, camera);
   * godraysPass.renderToScreen = true;
   * composer.addPass(godraysPass);
   *
   * function animate() {
   *   composer.render(scene, camera);
   * }
   * ```
   *
   * @param light The light source to use for the godrays.
   * @param camera The camera used to render the scene.
   * @param partialParams The parameters to use for the godrays effect.  Will use default values for any parameters not specified.
   */
  constructor(light, camera, partialParams = {}) {
    super("GodraysPass");
    this.godraysRenderTarget = new three_module.WebGLRenderTarget(1, 1, {
      minFilter: three_module.LinearFilter,
      magFilter: three_module.LinearFilter,
      format: three_module.RGBAFormat
    });
    this.props = {
      light,
      camera
    };
    const params = populateParams(partialParams);
    this.illumPass = new GodraysIllumPass(this.props, params);
    this.illumPass.needsDepthTexture = true;
    this.compositorPass = new GodraysCompositorPass({
      godrays: this.godraysRenderTarget.texture,
      edgeStrength: params.edgeStrength,
      edgeRadius: params.edgeRadius,
      color: params.color,
      camera
    });
    this.compositorPass.needsDepthTexture = true;
    this.needsDepthTexture = true;
    this.setParams(params);
  }
  setLight(light) {
    this.props.light = light;
  }
  /**
   * Updates the parameters used for the godrays effect.  Will use default values for any parameters not specified.
   */
  setParams(partialParams) {
    const params = populateParams(partialParams);
    this.illumPass.updateUniforms(this.props, params);
    this.compositorPass.updateUniforms(params);
  }
  render(renderer, inputBuffer, outputBuffer, _deltaTime, _stencilTest) {
    this.illumPass.render(renderer, inputBuffer, this.godraysRenderTarget);
    this.compositorPass.render(renderer, inputBuffer, this.renderToScreen ? null : outputBuffer);
  }
  setDepthTexture(depthTexture, depthPacking) {
    this.illumPass.setDepthTexture(depthTexture, depthPacking);
    this.compositorPass.setDepthTexture(depthTexture, depthPacking);
  }
  setSize(width, height) {
    this.godraysRenderTarget.setSize(
      Math.ceil(width * GODRAYS_RESOLUTION_SCALE),
      Math.ceil(height * GODRAYS_RESOLUTION_SCALE)
    );
    this.illumPass.setSize(width, height);
    this.compositorPass.setSize(width, height);
  }
  dispose() {
    this.godraysRenderTarget.dispose();
    this.illumPass.dispose();
    this.compositorPass.dispose();
    super.dispose();
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/post/GodRaysVolumetric.ts

var GodRaysVolumetric_defProp = Object.defineProperty;
var GodRaysVolumetric_getOwnPropSymbols = Object.getOwnPropertySymbols;
var GodRaysVolumetric_hasOwnProp = Object.prototype.hasOwnProperty;
var GodRaysVolumetric_propIsEnum = Object.prototype.propertyIsEnumerable;
var GodRaysVolumetric_defNormalProp = (obj, key, value) => key in obj ? GodRaysVolumetric_defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var GodRaysVolumetric_spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (GodRaysVolumetric_hasOwnProp.call(b, prop))
      GodRaysVolumetric_defNormalProp(a, prop, b[prop]);
  if (GodRaysVolumetric_getOwnPropSymbols)
    for (var prop of GodRaysVolumetric_getOwnPropSymbols(b)) {
      if (GodRaysVolumetric_propIsEnum.call(b, prop))
        GodRaysVolumetric_defNormalProp(a, prop, b[prop]);
    }
  return a;
};





const tmpPointLight = new three_module.PointLight();
const tmpDirectionalLight = new three_module.DirectionalLight();
for (const l of [tmpPointLight, tmpDirectionalLight]) {
  l.intensity = 1e-4;
  l.castShadow = true;
  l.shadow.mapSize.width = 1024;
  l.shadow.mapSize.height = 1024;
  l.shadow.autoUpdate = true;
  l.shadow.camera.near = 0.1;
  l.shadow.camera.far = 1e3;
  l.shadow.camera.updateProjectionMatrix();
}
var LightType = /* @__PURE__ */ ((LightType2) => {
  LightType2["POINT"] = "point";
  LightType2["DIRECTIONAL"] = "directional";
  return LightType2;
})(LightType || {});
const LIGHT_TYPES = ["directional" /* DIRECTIONAL */, "point" /* POINT */];
function GodRaysVolumetric_findLightSource(scene, objectMask, lightType) {
  let foundLigthObject = void 0;
  const objects = scene.objectsByMask(objectMask);
  function _isExpectedLightType(object) {
    switch (lightType) {
      case "point" /* POINT */: {
        return object.isPointLight;
      }
      case "directional" /* DIRECTIONAL */: {
        return object.isDirectionalLight;
      }
    }
    Assert/* TypeAssert.unreachable */.f.unreachable(lightType);
  }
  for (const object of objects) {
    if (_isExpectedLightType(object)) {
      foundLigthObject = object;
      break;
    }
  }
  return foundLigthObject;
}
class GodRaysVolumetricPostParamsConfig extends params_ParamsConfig/* NodeParamsConfig */.yI {
  constructor() {
    super(...arguments);
    /** @param light type */
    this.lightType = params_ParamsConfig/* ParamConfig.INTEGER */.XC.INTEGER(LIGHT_TYPES.indexOf("point" /* POINT */), {
      menu: {
        entries: LIGHT_TYPES.map((name, value) => ({ name, value }))
      }
    });
    /** @param light to emit godrays from. Note that while the mask can resolve multiple objects, only the first light will be used */
    this.lightMask = params_ParamsConfig/* ParamConfig.STRING */.XC.STRING("*Light*", GodRaysVolumetric_spreadValues({
      objectMask: true
    }, post_Base/* PostParamOptions */._3));
    /** @param color */
    this.color = params_ParamsConfig/* ParamConfig.COLOR */.XC.COLOR([1, 1, 1], GodRaysVolumetric_spreadValues({}, post_Base/* PostParamOptions */._3));
    /** @param density */
    this.density = params_ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(6e-3, GodRaysVolumetric_spreadValues({
      range: [0, 1],
      rangeLocked: [true, true]
    }, post_Base/* PostParamOptions */._3));
    /** @param maxDensity */
    this.maxDensity = params_ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(0.67, GodRaysVolumetric_spreadValues({
      range: [0, 1],
      rangeLocked: [true, true]
    }, post_Base/* PostParamOptions */._3));
    /** @param distanceAttenuation */
    this.distanceAttenuation = params_ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(2, GodRaysVolumetric_spreadValues({
      range: [0, 10],
      rangeLocked: [true, false]
    }, post_Base/* PostParamOptions */._3));
    /** @param edgeStrength */
    this.edgeStrength = params_ParamsConfig/* ParamConfig.INTEGER */.XC.INTEGER(2, GodRaysVolumetric_spreadValues({
      range: [0, 10],
      rangeLocked: [true, false]
    }, post_Base/* PostParamOptions */._3));
    /** @param edgeRadius */
    this.edgeRadius = params_ParamsConfig/* ParamConfig.INTEGER */.XC.INTEGER(2, GodRaysVolumetric_spreadValues({
      range: [0, 10],
      rangeLocked: [true, false]
    }, post_Base/* PostParamOptions */._3));
  }
}
const GodRaysVolumetric_ParamsConfig = new GodRaysVolumetricPostParamsConfig();
class GodRaysVolumetricPostNode extends post_Base/* TypedPostNode */.mN {
  constructor() {
    super(...arguments);
    this.paramsConfig = GodRaysVolumetric_ParamsConfig;
    this._rendererSize = new three_module.Vector2();
  }
  static type() {
    return "godRaysVolumetric";
  }
  createPass(context) {
    context.renderer.getSize(this._rendererSize);
    this.scene().threejsScene().add(this._tmpLightSource());
    const pass = new GodraysPass(this._tmpLightSource(), context.camera, {
      color: this.pv.color,
      density: this.pv.density,
      maxDensity: this.pv.maxDensity,
      distanceAttenuation: this.pv.distanceAttenuation,
      edgeStrength: this.pv.edgeStrength,
      edgeRadius: this.pv.edgeRadius
    });
    this.updatePass(pass);
    return pass;
  }
  updatePass(pass) {
    pass.setParams({
      color: this.pv.color,
      density: this.pv.density,
      maxDensity: this.pv.maxDensity,
      distanceAttenuation: this.pv.distanceAttenuation,
      edgeStrength: this.pv.edgeStrength,
      edgeRadius: this.pv.edgeRadius
    });
    const lightType = LIGHT_TYPES[this.pv.lightType];
    const lightSource = GodRaysVolumetric_findLightSource(this.scene(), this.pv.lightMask, lightType);
    if (lightSource) {
      lightSource.add(this._tmpLightSource());
    } else {
      pass.light = this._tmpLightSource();
    }
  }
  _tmpLightSource() {
    const lightType = LIGHT_TYPES[this.pv.lightType];
    switch (lightType) {
      case "point" /* POINT */: {
        return tmpPointLight;
      }
      case "directional" /* DIRECTIONAL */: {
        return tmpDirectionalLight;
      }
    }
    Assert/* TypeAssert.unreachable */.f.unreachable(lightType);
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/post/HueSaturation.ts

var HueSaturation_defProp = Object.defineProperty;
var HueSaturation_getOwnPropSymbols = Object.getOwnPropertySymbols;
var HueSaturation_hasOwnProp = Object.prototype.hasOwnProperty;
var HueSaturation_propIsEnum = Object.prototype.propertyIsEnumerable;
var HueSaturation_defNormalProp = (obj, key, value) => key in obj ? HueSaturation_defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var HueSaturation_spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (HueSaturation_hasOwnProp.call(b, prop))
      HueSaturation_defNormalProp(a, prop, b[prop]);
  if (HueSaturation_getOwnPropSymbols)
    for (var prop of HueSaturation_getOwnPropSymbols(b)) {
      if (HueSaturation_propIsEnum.call(b, prop))
        HueSaturation_defNormalProp(a, prop, b[prop]);
    }
  return a;
};




class HueSaturationPostParamsConfig extends params_ParamsConfig/* NodeParamsConfig */.yI {
  constructor() {
    super(...arguments);
    /** @param hue */
    this.hue = params_ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(0, HueSaturation_spreadValues({
      range: [0, Math.PI],
      rangeLocked: [false, false],
      step: 1e-5
    }, post_Base/* PostParamOptions */._3));
    /** @param saturation */
    this.saturation = params_ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(0, HueSaturation_spreadValues({
      range: [-1, 1],
      rangeLocked: [false, false]
    }, post_Base/* PostParamOptions */._3));
    /** @param effect opacity */
    this.opacity = params_ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(1, HueSaturation_spreadValues({
      range: [0, 1],
      rangeLocked: [true, false]
    }, post_Base/* PostParamOptions */._3));
    /** @param render mode */
    this.blendFunction = params_ParamsConfig/* ParamConfig.INTEGER */.XC.INTEGER(build/* BlendFunction.MULTIPLY */.YQ.MULTIPLY, HueSaturation_spreadValues(HueSaturation_spreadValues({}, post_Base/* PostParamOptions */._3), BlendFunction/* BLEND_FUNCTION_MENU_OPTIONS */.z));
  }
}
const HueSaturation_ParamsConfig = new HueSaturationPostParamsConfig();
class HueSaturationPostNode extends post_Base/* TypedPostNode */.mN {
  constructor() {
    super(...arguments);
    this.paramsConfig = HueSaturation_ParamsConfig;
  }
  static type() {
    return "hueSaturation";
  }
  createPass(context) {
    const effect = new build/* HueSaturationEffect */.JL();
    const camera = context.camera;
    const pass = new build/* EffectPass */.H5(camera, effect);
    this.updatePass(pass);
    return pass;
  }
  updatePass(pass) {
    const effect = pass.effects[0];
    effect.hue = this.pv.hue;
    effect.saturation = this.pv.saturation;
    effect.blendMode.opacity.value = this.pv.opacity;
    effect.blendMode.blendFunction = this.pv.blendFunction;
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/post/Luminance.ts




class LuminanceParamsConfig extends params_ParamsConfig/* NodeParamsConfig */.yI {
}
const post_Luminance_ParamsConfig = new LuminanceParamsConfig();
class LuminancePostNode extends post_Base/* TypedPostNode */.mN {
  constructor() {
    super(...arguments);
    this.paramsConfig = post_Luminance_ParamsConfig;
  }
  static type() {
    return "luminance";
  }
  createPass(context) {
    const pass = new build/* LuminancePass */.qH();
    return pass;
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/post/Lut.ts

var Lut_defProp = Object.defineProperty;
var Lut_getOwnPropSymbols = Object.getOwnPropertySymbols;
var Lut_hasOwnProp = Object.prototype.hasOwnProperty;
var Lut_propIsEnum = Object.prototype.propertyIsEnumerable;
var Lut_defNormalProp = (obj, key, value) => key in obj ? Lut_defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var Lut_spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (Lut_hasOwnProp.call(b, prop))
      Lut_defNormalProp(a, prop, b[prop]);
  if (Lut_getOwnPropSymbols)
    for (var prop of Lut_getOwnPropSymbols(b)) {
      if (Lut_propIsEnum.call(b, prop))
        Lut_defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var Lut_async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};





class LutPostParamsConfig extends params_ParamsConfig/* NodeParamsConfig */.yI {
  constructor() {
    super(...arguments);
    /** @param texture */
    this.texture = params_ParamsConfig/* ParamConfig.NODE_PATH */.XC.NODE_PATH("", Lut_spreadValues({
      nodeSelection: {
        context: poly_NodeContext/* NodeContext.COP */.sy.COP
      },
      dependentOnFoundNode: false
    }, post_Base/* PostParamOptions */._3));
    /** @param effect opacity */
    this.opacity = params_ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(1, Lut_spreadValues({
      range: [0, 1],
      rangeLocked: [true, false]
    }, post_Base/* PostParamOptions */._3));
    /** @param render mode */
    this.blendFunction = params_ParamsConfig/* ParamConfig.INTEGER */.XC.INTEGER(build/* BlendFunction.NORMAL */.YQ.NORMAL, Lut_spreadValues(Lut_spreadValues({}, post_Base/* PostParamOptions */._3), BlendFunction/* BLEND_FUNCTION_MENU_OPTIONS */.z));
  }
}
const Lut_ParamsConfig = new LutPostParamsConfig();
class LutPostNode extends post_Base/* TypedPostNode */.mN {
  constructor() {
    super(...arguments);
    this.paramsConfig = Lut_ParamsConfig;
  }
  static type() {
    return "lut";
  }
  createPass(context) {
    const passes = [];
    const texture = null;
    const effect = context.renderer.capabilities.isWebGL2 ? new build/* LUT3DEffect */.CI(texture) : new build/* LUT3DEffect */.CI(null);
    const pass = new build/* EffectPass */.H5(context.camera, effect);
    passes.push(pass);
    this.updatePass(pass);
    return passes;
  }
  updatePass(pass) {
    return Lut_async(this, null, function* () {
      const effect = pass.effects[0];
      if (!effect) {
        return;
      }
      effect.blendMode.opacity.value = this.pv.opacity;
      effect.blendMode.blendFunction = this.pv.blendFunction;
      const texture = yield this._fetchTexture();
      if (texture) {
        effect.lut = texture;
      }
    });
  }
  _fetchTexture() {
    return Lut_async(this, null, function* () {
      var _a;
      const textureNode = this.pv.texture.nodeWithContext(poly_NodeContext/* NodeContext.COP */.sy.COP, (_a = this.states) == null ? void 0 : _a.error);
      if (textureNode) {
        const container = yield textureNode.compute();
        return container.coreContent();
      }
    });
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/post/Normal.ts




class NormalParamsConfig extends params_ParamsConfig/* NodeParamsConfig */.yI {
}
const Normal_ParamsConfig = new NormalParamsConfig();
class NormalPostNode extends post_Base/* TypedPostNode */.mN {
  constructor() {
    super(...arguments);
    this.paramsConfig = Normal_ParamsConfig;
  }
  static type() {
    return "normal";
  }
  createPass(context) {
    const normalPass = new build/* NormalPass */.gh(context.scene, context.camera);
    return normalPass;
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/post/Noise.ts

var post_Noise_defProp = Object.defineProperty;
var post_Noise_getOwnPropSymbols = Object.getOwnPropertySymbols;
var post_Noise_hasOwnProp = Object.prototype.hasOwnProperty;
var post_Noise_propIsEnum = Object.prototype.propertyIsEnumerable;
var post_Noise_defNormalProp = (obj, key, value) => key in obj ? post_Noise_defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var post_Noise_spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (post_Noise_hasOwnProp.call(b, prop))
      post_Noise_defNormalProp(a, prop, b[prop]);
  if (post_Noise_getOwnPropSymbols)
    for (var prop of post_Noise_getOwnPropSymbols(b)) {
      if (post_Noise_propIsEnum.call(b, prop))
        post_Noise_defNormalProp(a, prop, b[prop]);
    }
  return a;
};




class NoisePostParamsConfig extends params_ParamsConfig/* NodeParamsConfig */.yI {
  constructor() {
    super(...arguments);
    /** @param effect strength */
    this.strength = params_ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(1, post_Noise_spreadValues({
      range: [0, 1],
      rangeLocked: [true, false]
    }, post_Base/* PostParamOptions */._3));
    /** @param premultiply */
    this.premultiply = params_ParamsConfig/* ParamConfig.BOOLEAN */.XC.BOOLEAN(1, post_Noise_spreadValues({}, post_Base/* PostParamOptions */._3));
  }
}
const post_Noise_ParamsConfig = new NoisePostParamsConfig();
class NoisePostNode extends post_Base/* TypedPostNode */.mN {
  constructor() {
    super(...arguments);
    this.paramsConfig = post_Noise_ParamsConfig;
    this._rendererSize = new three_module.Vector2();
  }
  static type() {
    return "noise";
  }
  createPass(context) {
    context.renderer.getSize(this._rendererSize);
    const effect = new build/* NoiseEffect */.xV({});
    const pass = new build/* EffectPass */.H5(context.camera, effect);
    this.updatePass(pass);
    return pass;
  }
  updatePass(pass) {
    const effect = pass.effects[0];
    effect.premultiply = this.pv.premultiply;
    effect.blendMode.opacity.value = this.pv.strength;
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/post/Null.ts



class NullPostParamsConfig extends params_ParamsConfig/* NodeParamsConfig */.yI {
}
const post_Null_ParamsConfig = new NullPostParamsConfig();
class NullPostNode extends post_Base/* TypedPostNode */.mN {
  constructor() {
    super(...arguments);
    this.paramsConfig = post_Null_ParamsConfig;
  }
  static type() {
    return "null";
  }
}

// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/nodes/post/Outline.ts
var Outline = __webpack_require__(41365);
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/post/Pixel.ts

var Pixel_defProp = Object.defineProperty;
var Pixel_getOwnPropSymbols = Object.getOwnPropertySymbols;
var Pixel_hasOwnProp = Object.prototype.hasOwnProperty;
var Pixel_propIsEnum = Object.prototype.propertyIsEnumerable;
var Pixel_defNormalProp = (obj, key, value) => key in obj ? Pixel_defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var Pixel_spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (Pixel_hasOwnProp.call(b, prop))
      Pixel_defNormalProp(a, prop, b[prop]);
  if (Pixel_getOwnPropSymbols)
    for (var prop of Pixel_getOwnPropSymbols(b)) {
      if (Pixel_propIsEnum.call(b, prop))
        Pixel_defNormalProp(a, prop, b[prop]);
    }
  return a;
};



class PixelPostParamsConfig extends params_ParamsConfig/* NodeParamsConfig */.yI {
  constructor() {
    super(...arguments);
    /** @param pixelSize */
    this.pixelSize = params_ParamsConfig/* ParamConfig.INTEGER */.XC.INTEGER(16, Pixel_spreadValues({
      range: [1, 50],
      rangeLocked: [true, false]
    }, post_Base/* PostParamOptions */._3));
  }
}
const Pixel_ParamsConfig = new PixelPostParamsConfig();
class PixelPostNode extends post_Base/* TypedPostNode */.mN {
  constructor() {
    super(...arguments);
    this.paramsConfig = Pixel_ParamsConfig;
  }
  static type() {
    return "pixel";
  }
  createPass(context) {
    const effect = new build/* PixelationEffect */.Qg(5);
    const pass = new build/* EffectPass */.H5(context.camera, effect);
    this.updatePass(pass);
    return pass;
  }
  updatePass(pass) {
    const effect = pass.effects[0];
    effect.granularity = this.pv.pixelSize;
  }
}

// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/nodes/post/Render.ts
var post_Render = __webpack_require__(10538);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/node_modules/n8ao/dist/N8AO.js
var N8AO = __webpack_require__(28737);
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/post/ScreenSpaceAmbientOcclusion.ts

var ScreenSpaceAmbientOcclusion_defProp = Object.defineProperty;
var ScreenSpaceAmbientOcclusion_getOwnPropSymbols = Object.getOwnPropertySymbols;
var ScreenSpaceAmbientOcclusion_hasOwnProp = Object.prototype.hasOwnProperty;
var ScreenSpaceAmbientOcclusion_propIsEnum = Object.prototype.propertyIsEnumerable;
var ScreenSpaceAmbientOcclusion_defNormalProp = (obj, key, value) => key in obj ? ScreenSpaceAmbientOcclusion_defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var ScreenSpaceAmbientOcclusion_spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (ScreenSpaceAmbientOcclusion_hasOwnProp.call(b, prop))
      ScreenSpaceAmbientOcclusion_defNormalProp(a, prop, b[prop]);
  if (ScreenSpaceAmbientOcclusion_getOwnPropSymbols)
    for (var prop of ScreenSpaceAmbientOcclusion_getOwnPropSymbols(b)) {
      if (ScreenSpaceAmbientOcclusion_propIsEnum.call(b, prop))
        ScreenSpaceAmbientOcclusion_defNormalProp(a, prop, b[prop]);
    }
  return a;
};



var DisplayMode = /* @__PURE__ */ ((DisplayMode2) => {
  DisplayMode2["COMBINED"] = "Combined";
  DisplayMode2["AO"] = "AO";
  DisplayMode2["NO_AO"] = "No AO";
  DisplayMode2["SPLIT"] = "Split";
  DisplayMode2["SPLIT_AO"] = "Split AO";
  return DisplayMode2;
})(DisplayMode || {});
const DISPLAY_MODES = [
  "Combined" /* COMBINED */,
  "AO" /* AO */,
  "No AO" /* NO_AO */,
  "Split" /* SPLIT */,
  "Split AO" /* SPLIT_AO */
];
class ScreenSpaceAmbientOcclusionParamsConfig extends params_ParamsConfig/* NodeParamsConfig */.yI {
  constructor() {
    super(...arguments);
    this.main = params_ParamsConfig/* ParamConfig.FOLDER */.XC.FOLDER();
    /** @param color */
    this.color = params_ParamsConfig/* ParamConfig.COLOR */.XC.COLOR([0, 0, 0], ScreenSpaceAmbientOcclusion_spreadValues({}, post_Base/* PostParamOptions */._3));
    /** @param aoSamples */
    this.samples = params_ParamsConfig/* ParamConfig.INTEGER */.XC.INTEGER(16, ScreenSpaceAmbientOcclusion_spreadValues({
      range: [0, 32],
      rangeLocked: [true, false]
    }, post_Base/* PostParamOptions */._3));
    /** @param intensity */
    this.intensity = params_ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(5, ScreenSpaceAmbientOcclusion_spreadValues({
      range: [0, 10],
      rangeLocked: [true, false]
    }, post_Base/* PostParamOptions */._3));
    /** @param radius */
    this.radius = params_ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(5, ScreenSpaceAmbientOcclusion_spreadValues({
      range: [0, 20],
      rangeLocked: [true, false]
    }, post_Base/* PostParamOptions */._3));
    /** @param distanceFallOff */
    this.distanceFallOff = params_ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(1, ScreenSpaceAmbientOcclusion_spreadValues({
      range: [0, 1],
      rangeLocked: [true, false]
    }, post_Base/* PostParamOptions */._3));
    /** @param halfRes */
    this.halfRes = params_ParamsConfig/* ParamConfig.BOOLEAN */.XC.BOOLEAN(0, ScreenSpaceAmbientOcclusion_spreadValues({}, post_Base/* PostParamOptions */._3));
    /** @param screenSpaceRadius */
    this.screenSpaceRadius = params_ParamsConfig/* ParamConfig.BOOLEAN */.XC.BOOLEAN(0, ScreenSpaceAmbientOcclusion_spreadValues({}, post_Base/* PostParamOptions */._3));
    /** @param denoise samples  */
    this.denoiseSamples = params_ParamsConfig/* ParamConfig.INTEGER */.XC.INTEGER(8, ScreenSpaceAmbientOcclusion_spreadValues({
      range: [0, 32],
      rangeLocked: [true, false]
    }, post_Base/* PostParamOptions */._3));
    /** @param denoise radius */
    this.denoiseRadius = params_ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(12, ScreenSpaceAmbientOcclusion_spreadValues({
      range: [0, 20],
      rangeLocked: [true, false]
    }, post_Base/* PostParamOptions */._3));
    /** @param denoise iterations  */
    this.denoiseIterations = params_ParamsConfig/* ParamConfig.INTEGER */.XC.INTEGER(2, ScreenSpaceAmbientOcclusion_spreadValues({
      range: [0, 4],
      rangeLocked: [true, false]
    }, post_Base/* PostParamOptions */._3));
    this.displayMode = params_ParamsConfig/* ParamConfig.INTEGER */.XC.INTEGER(DISPLAY_MODES.indexOf("Combined" /* COMBINED */), {
      menu: {
        entries: DISPLAY_MODES.map((name, value) => {
          return { name, value };
        })
      }
    });
  }
}
const ScreenSpaceAmbientOcclusion_ParamsConfig = new ScreenSpaceAmbientOcclusionParamsConfig();
class ScreenSpaceAmbientOcclusionPostNode extends post_Base/* TypedPostNode */.mN {
  constructor() {
    super(...arguments);
    this.paramsConfig = ScreenSpaceAmbientOcclusion_ParamsConfig;
  }
  static type() {
    return "screenSpaceAmbientOcclusion";
  }
  createPass(context) {
    const n8aoPass = new N8AO/* N8AOPostPass */.A(context.scene, context.camera);
    this.updatePass(n8aoPass);
    const passes = [n8aoPass];
    return passes;
  }
  updatePass(pass) {
    pass.configuration.aoSamples = this.pv.samples;
    pass.configuration.aoRadius = this.pv.radius;
    pass.configuration.distanceFalloff = this.pv.distanceFallOff;
    pass.configuration.intensity = this.pv.intensity;
    pass.configuration.color.copy(this.pv.color);
    pass.configuration.halfRes = this.pv.halfRes;
    pass.configuration.screenSpaceRadius = this.pv.screenSpaceRadius;
    pass.configuration.denoiseSamples = this.pv.denoiseSamples;
    pass.configuration.denoiseRadius = this.pv.denoiseRadius;
    pass.configuration.denoiseIterations = this.pv.denoiseIterations;
    const displayMode = DISPLAY_MODES[this.pv.displayMode];
    pass.setDisplayMode(displayMode);
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/post/Sepia.ts

var Sepia_defProp = Object.defineProperty;
var Sepia_getOwnPropSymbols = Object.getOwnPropertySymbols;
var Sepia_hasOwnProp = Object.prototype.hasOwnProperty;
var Sepia_propIsEnum = Object.prototype.propertyIsEnumerable;
var Sepia_defNormalProp = (obj, key, value) => key in obj ? Sepia_defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var Sepia_spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (Sepia_hasOwnProp.call(b, prop))
      Sepia_defNormalProp(a, prop, b[prop]);
  if (Sepia_getOwnPropSymbols)
    for (var prop of Sepia_getOwnPropSymbols(b)) {
      if (Sepia_propIsEnum.call(b, prop))
        Sepia_defNormalProp(a, prop, b[prop]);
    }
  return a;
};



class SepiaPostParamsConfig extends params_ParamsConfig/* NodeParamsConfig */.yI {
  constructor() {
    super(...arguments);
    /** @param amount */
    this.amount = params_ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(0.5, Sepia_spreadValues({
      range: [0, 1],
      rangeLocked: [false, false]
    }, post_Base/* PostParamOptions */._3));
  }
}
const Sepia_ParamsConfig = new SepiaPostParamsConfig();
class SepiaPostNode extends post_Base/* TypedPostNode */.mN {
  constructor() {
    super(...arguments);
    this.paramsConfig = Sepia_ParamsConfig;
  }
  static type() {
    return "sepia";
  }
  createPass(context) {
    const effect = new build/* SepiaEffect */.wL();
    const pass = new build/* EffectPass */.H5(context.camera, effect);
    this.updatePass(pass);
    return pass;
  }
  updatePass(pass) {
    const effect = pass.effects[0];
    effect.intensity = this.pv.amount;
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/post/Sequence.ts



class SequencePostParamsConfig extends params_ParamsConfig/* NodeParamsConfig */.yI {
}
const post_Sequence_ParamsConfig = new SequencePostParamsConfig();
class SequencePostNode extends post_Base/* TypedPostNode */.mN {
  constructor() {
    super(...arguments);
    this.paramsConfig = post_Sequence_ParamsConfig;
  }
  static type() {
    return "sequence";
  }
  initializeNode() {
    super.initializeNode();
    this.io.inputs.setCount(0, 4);
  }
  setupComposer(context) {
    this._addPassFromInput(0, context);
    this._addPassFromInput(1, context);
    this._addPassFromInput(2, context);
    this._addPassFromInput(3, context);
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/post/Texture.ts

var Texture_defProp = Object.defineProperty;
var Texture_getOwnPropSymbols = Object.getOwnPropertySymbols;
var Texture_hasOwnProp = Object.prototype.hasOwnProperty;
var Texture_propIsEnum = Object.prototype.propertyIsEnumerable;
var Texture_defNormalProp = (obj, key, value) => key in obj ? Texture_defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var Texture_spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (Texture_hasOwnProp.call(b, prop))
      Texture_defNormalProp(a, prop, b[prop]);
  if (Texture_getOwnPropSymbols)
    for (var prop of Texture_getOwnPropSymbols(b)) {
      if (Texture_propIsEnum.call(b, prop))
        Texture_defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var Texture_async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};







const tmpTexture = new three_module.Texture();
class TexturePostParamsConfig extends params_ParamsConfig/* NodeParamsConfig */.yI {
  constructor() {
    super(...arguments);
    /** @param texture */
    this.texture = params_ParamsConfig/* ParamConfig.NODE_PATH */.XC.NODE_PATH("", Texture_spreadValues({
      nodeSelection: {
        context: poly_NodeContext/* NodeContext.COP */.sy.COP
      },
      dependentOnFoundNode: false
    }, post_Base/* PostParamOptions */._3));
    /** @param opacity */
    this.opacity = params_ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(1, Texture_spreadValues({
      range: [0, 1],
      rangeLocked: [true, false]
    }, post_Base/* PostParamOptions */._3));
    /** @param render mode */
    this.blendFunction = params_ParamsConfig/* ParamConfig.INTEGER */.XC.INTEGER(build/* BlendFunction.COLOR_DODGE */.YQ.COLOR_DODGE, Texture_spreadValues(Texture_spreadValues({}, post_Base/* PostParamOptions */._3), BlendFunction/* BLEND_FUNCTION_MENU_OPTIONS */.z));
  }
}
const Texture_ParamsConfig = new TexturePostParamsConfig();
class TexturePostNode extends post_Base/* TypedPostNode */.mN {
  constructor() {
    super(...arguments);
    this.paramsConfig = Texture_ParamsConfig;
    this._rendererSize = new three_module.Vector2();
  }
  static type() {
    return Post/* PostType.TEXTURE */.h.TEXTURE;
  }
  createPass(context) {
    context.renderer.getSize(this._rendererSize);
    const effect = new build/* TextureEffect */.tq({ texture: tmpTexture });
    const pass = new build/* EffectPass */.H5(context.camera, effect);
    this.updatePass(pass);
    return pass;
  }
  updatePass(pass) {
    return Texture_async(this, null, function* () {
      var _a;
      const effect = pass.effects[0];
      effect.blendMode.opacity.value = this.pv.opacity;
      effect.blendMode.blendFunction = this.pv.blendFunction;
      const textureNode = this.pv.texture.nodeWithContext(poly_NodeContext/* NodeContext.COP */.sy.COP, (_a = this.states) == null ? void 0 : _a.error);
      if (textureNode) {
        const container = yield textureNode.compute();
        effect.texture = container.coreContent();
      }
    });
  }
}

// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/nodes/post/ToneMapping.ts
var ToneMapping = __webpack_require__(39072);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/nodes/post/UpdateScene.ts + 1 modules
var UpdateScene = __webpack_require__(12614);
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/post/Vignette.ts

var Vignette_defProp = Object.defineProperty;
var Vignette_getOwnPropSymbols = Object.getOwnPropertySymbols;
var Vignette_hasOwnProp = Object.prototype.hasOwnProperty;
var Vignette_propIsEnum = Object.prototype.propertyIsEnumerable;
var Vignette_defNormalProp = (obj, key, value) => key in obj ? Vignette_defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var Vignette_spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (Vignette_hasOwnProp.call(b, prop))
      Vignette_defNormalProp(a, prop, b[prop]);
  if (Vignette_getOwnPropSymbols)
    for (var prop of Vignette_getOwnPropSymbols(b)) {
      if (Vignette_propIsEnum.call(b, prop))
        Vignette_defNormalProp(a, prop, b[prop]);
    }
  return a;
};



class VignettePostParamsConfig extends params_ParamsConfig/* NodeParamsConfig */.yI {
  constructor() {
    super(...arguments);
    /** @param offset */
    this.offset = params_ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(0, Vignette_spreadValues({
      range: [0, 1],
      rangeLocked: [false, false]
    }, post_Base/* PostParamOptions */._3));
    /** @param darkness */
    this.darkness = params_ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(1, Vignette_spreadValues({
      range: [0, 2],
      rangeLocked: [true, false]
    }, post_Base/* PostParamOptions */._3));
  }
}
const Vignette_ParamsConfig = new VignettePostParamsConfig();
class VignettePostNode extends post_Base/* TypedPostNode */.mN {
  constructor() {
    super(...arguments);
    this.paramsConfig = Vignette_ParamsConfig;
  }
  static type() {
    return "vignette";
  }
  createPass(context) {
    const effect = new build/* VignetteEffect */.Dd({
      technique: build/* VignetteTechnique.DEFAULT */.sv.DEFAULT,
      offset: this.pv.offset,
      darkness: this.pv.darkness
    });
    const pass = new build/* EffectPass */.H5(context.camera, effect);
    this.updatePass(pass);
    return pass;
  }
  updatePass(pass) {
    const effect = pass.effects[0];
    const uniforms = effect.uniforms;
    uniforms.get("offset").value = this.pv.offset;
    uniforms.get("darkness").value = this.pv.darkness;
  }
}

// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/nodes/post/_BaseManager.ts
var post_BaseManager = __webpack_require__(37316);
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/post/ActorsNetwork.ts







class ActorsNetworkPostNode extends post_BaseManager/* ParamLessBaseNetworkPostNode */.A {
  constructor() {
    super(...arguments);
    this._childrenControllerContext = poly_NodeContext/* NodeContext.JS */.sy.JS;
    //
    // ASSEMBLERS
    //
    this.persisted_config = new ActorPersistedConfig/* ActorPersistedConfig */.R(this);
    this._assemblerController = this._createAssemblerController();
    //
    // compilation
    //
    this.compilationController = new ActorCompilationController/* ActorCompilationController */.z7(this);
  }
  static type() {
    return poly_NodeContext/* NetworkNodeType.ACTOR */.kX.ACTOR;
  }
  createNode(node_class, options) {
    return super.createNode(node_class, options);
  }
  children() {
    return super.children();
  }
  nodesByType(type) {
    return super.nodesByType(type);
  }
  //
  childrenAllowed() {
    if (this.assemblerController()) {
      return super.childrenAllowed();
    }
    return false;
  }
  sceneReadonly() {
    return this.assemblerController() == null;
  }
  assemblerController() {
    return this._assemblerController;
  }
  usedAssembler() {
    return _BaseRegister/* AssemblerName.JS_ACTOR */.Q.JS_ACTOR;
  }
  _createAssemblerController() {
    return Poly/* Poly.assemblersRegister.assembler */.L.assemblersRegister.assembler(this, this.usedAssembler());
  }
  compile() {
    this.compilationController.compile();
  }
  cook() {
    this.compilationController.compileIfRequired();
    this.cookController.endCook();
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/post/AnimationsNetwork.ts



class AnimationsNetworkPostNode extends post_BaseManager/* ParamLessBaseNetworkPostNode */.A {
  constructor() {
    super(...arguments);
    this._childrenControllerContext = poly_NodeContext/* NodeContext.ANIM */.sy.ANIM;
  }
  static type() {
    return poly_NodeContext/* NetworkNodeType.ANIM */.kX.ANIM;
  }
  createNode(node_class, options) {
    return super.createNode(node_class, options);
  }
  children() {
    return super.children();
  }
  nodesByType(type) {
    return super.nodesByType(type);
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/post/AudioNetwork.ts



class AudioNetworkPostNode extends post_BaseManager/* ParamLessBaseNetworkPostNode */.A {
  constructor() {
    super(...arguments);
    this._childrenControllerContext = poly_NodeContext/* NodeContext.AUDIO */.sy.AUDIO;
  }
  static type() {
    return poly_NodeContext/* NetworkNodeType.AUDIO */.kX.AUDIO;
  }
  createNode(node_class, options) {
    return super.createNode(node_class, options);
  }
  children() {
    return super.children();
  }
  nodesByType(type) {
    return super.nodesByType(type);
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/post/CopNetwork.ts



class CopNetworkPostNode extends post_BaseManager/* ParamLessBaseNetworkPostNode */.A {
  constructor() {
    super(...arguments);
    this._childrenControllerContext = poly_NodeContext/* NodeContext.COP */.sy.COP;
  }
  static type() {
    return poly_NodeContext/* NetworkNodeType.COP */.kX.COP;
  }
  createNode(node_class, options) {
    return super.createNode(node_class, options);
  }
  children() {
    return super.children();
  }
  nodesByType(type) {
    return super.nodesByType(type);
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/post/EventsNetwork.ts



class EventsNetworkPostNode extends post_BaseManager/* ParamLessBaseNetworkPostNode */.A {
  constructor() {
    super(...arguments);
    this._childrenControllerContext = poly_NodeContext/* NodeContext.EVENT */.sy.EVENT;
  }
  static type() {
    return poly_NodeContext/* NetworkNodeType.EVENT */.kX.EVENT;
  }
  createNode(node_class, options) {
    return super.createNode(node_class, options);
  }
  children() {
    return super.children();
  }
  nodesByType(type) {
    return super.nodesByType(type);
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/post/MaterialsNetwork.ts



class MaterialsNetworkPostNode extends post_BaseManager/* ParamLessBaseNetworkPostNode */.A {
  constructor() {
    super(...arguments);
    this._childrenControllerContext = poly_NodeContext/* NodeContext.MAT */.sy.MAT;
  }
  static type() {
    return poly_NodeContext/* NetworkNodeType.MAT */.kX.MAT;
  }
  createNode(node_class, options) {
    return super.createNode(node_class, options);
  }
  children() {
    return super.children();
  }
  nodesByType(type) {
    return super.nodesByType(type);
  }
}

// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/nodes/post/PostProcessNetwork.ts
var post_PostProcessNetwork = __webpack_require__(11427);
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/post/RenderersNetwork.ts



class RenderersNetworkPostNode extends post_BaseManager/* ParamLessBaseNetworkPostNode */.A {
  constructor() {
    super(...arguments);
    this._childrenControllerContext = poly_NodeContext/* NodeContext.ROP */.sy.ROP;
  }
  static type() {
    return poly_NodeContext/* NetworkNodeType.ROP */.kX.ROP;
  }
  createNode(node_class, options) {
    return super.createNode(node_class, options);
  }
  children() {
    return super.children();
  }
  nodesByType(type) {
    return super.nodesByType(type);
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/poly/registers/nodes/Post.ts





































class PostRegister {
  static run(poly) {
    poly.registerNode(AntialiasingPostNode, CATEGORY_POST.EFFECT);
    poly.registerNode(Bloom/* BloomPostNode */.H, CATEGORY_POST.EFFECT);
    poly.registerNode(BlurPostNode, CATEGORY_POST.BLUR);
    poly.registerNode(BrightnessContrastPostNode, CATEGORY_POST.COLOR);
    poly.registerNode(BuilderPostNode, CATEGORY_POST.ADVANCED);
    poly.registerNode(ChromaticAberrationPostNode, CATEGORY_POST.EFFECT);
    poly.registerNode(DepthOfFieldPostNode, CATEGORY_POST.EFFECT);
    poly.registerNode(EffectPass/* EffectPassPostNode */.B, CATEGORY_POST.EFFECT);
    poly.registerNode(GlitchPostNode, CATEGORY_POST.EFFECT);
    poly.registerNode(GodRaysPostNode, CATEGORY_POST.EFFECT);
    poly.registerNode(GodRaysVolumetricPostNode, CATEGORY_POST.EFFECT);
    poly.registerNode(HueSaturationPostNode, CATEGORY_POST.COLOR);
    poly.registerNode(LuminancePostNode, CATEGORY_POST.COLOR);
    poly.registerNode(LutPostNode, CATEGORY_POST.COLOR);
    poly.registerNode(NoisePostNode, CATEGORY_POST.EFFECT);
    poly.registerNode(NormalPostNode, CATEGORY_POST.MISC);
    poly.registerNode(NullPostNode, CATEGORY_POST.MISC);
    poly.registerNode(Outline/* OutlinePostNode */.F, CATEGORY_POST.EFFECT);
    poly.registerNode(PixelPostNode, CATEGORY_POST.EFFECT);
    poly.registerNode(post_Render/* RenderPostNode */.k, CATEGORY_POST.MISC);
    poly.registerNode(ScreenSpaceAmbientOcclusionPostNode, CATEGORY_POST.EFFECT);
    poly.registerNode(SepiaPostNode, CATEGORY_POST.COLOR);
    poly.registerNode(SequencePostNode, CATEGORY_POST.MISC);
    poly.registerNode(TexturePostNode, CATEGORY_POST.MISC);
    poly.registerNode(ToneMapping/* ToneMappingPostNode */.G, CATEGORY_POST.EFFECT);
    poly.registerNode(UpdateScene/* UpdateScenePostNode */.E, CATEGORY_POST.ADVANCED);
    poly.registerNode(VignettePostNode, CATEGORY_POST.EFFECT);
    poly.registerNode(ActorsNetworkPostNode, CATEGORY_POST.NETWORK);
    poly.registerNode(AnimationsNetworkPostNode, CATEGORY_POST.NETWORK);
    poly.registerNode(AudioNetworkPostNode, CATEGORY_POST.NETWORK);
    poly.registerNode(CopNetworkPostNode, CATEGORY_POST.NETWORK);
    poly.registerNode(EventsNetworkPostNode, CATEGORY_POST.NETWORK);
    poly.registerNode(MaterialsNetworkPostNode, CATEGORY_POST.NETWORK);
    poly.registerNode(post_PostProcessNetwork/* PostProcessNetworkPostNode */.v, CATEGORY_POST.NETWORK);
    poly.registerNode(RenderersNetworkPostNode, CATEGORY_POST.NETWORK);
  }
}

// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/core/render/CSSRenderers/CSSObjectAttribute.ts
var CSSObjectAttribute = __webpack_require__(5215);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/nodes/rop/_Base.ts
var rop_Base = __webpack_require__(5058);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/core/render/CSSRenderers/CSS2DRenderer.ts
var CSS2DRenderer = __webpack_require__(17009);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/poly/registers/nodes/types/Rop.ts
var Rop = __webpack_require__(58273);
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/rop/CSS2DRenderer.ts







const DEFAULT_CSS = `.${CSSObjectAttribute/* DEFAULT_CSS2DOBJECT.className */.Ce.className} {
	color: white;
	background-color: black;
	padding: 5px 10px;
	border: 1px solid blue;
	border-radius: 5px;
	pointer-events: auto;
	user-select: none;
}`;
class CSS2DRendererRopParamsConfig extends params_ParamsConfig/* NodeParamsConfig */.yI {
  constructor() {
    super(...arguments);
    /** @param css rules to be added in the html document */
    this.css = params_ParamsConfig/* ParamConfig.STRING */.XC.STRING(DEFAULT_CSS, {
      language: OptionsController/* StringParamLanguage.CSS */.qs.CSS
    });
  }
}
const CSS2DRenderer_ParamsConfig = new CSS2DRendererRopParamsConfig();
class CSS2DRendererRopNode extends rop_Base/* TypedRopNode */.E {
  constructor() {
    super(...arguments);
    this.paramsConfig = CSS2DRenderer_ParamsConfig;
    this._renderersByCanvasId = /* @__PURE__ */ new Map();
  }
  static type() {
    return Rop/* RopType.CSS2D */.X.CSS2D;
  }
  createRenderer(canvas) {
    const renderer = new CSS2DRenderer/* CSS2DRenderer */.M();
    this._renderersByCanvasId.set(canvas.id, renderer);
    renderer.domElement.style.position = "absolute";
    renderer.domElement.style.top = "0px";
    renderer.domElement.style.left = "0px";
    renderer.domElement.style.pointerEvents = "none";
    this._updateRenderer(renderer);
    return renderer;
  }
  mountRenderer(canvas) {
    const renderer = this._renderersByCanvasId.get(canvas.id);
    if (!renderer) {
      console.warn(`no render found for canvas ${canvas.id}. cannot mount CSS2DRenderer`);
      return;
    }
    const parent = canvas.parentElement;
    if (parent) {
      parent.prepend(renderer.domElement);
      parent.style.position = "relative";
    } else {
      console.warn("canvas has no parent");
    }
    const rect = canvas.getBoundingClientRect();
    renderer.setSize(rect.width, rect.height);
  }
  unmountRenderer(canvas) {
    var _a;
    const renderer = this._renderersByCanvasId.get(canvas.id);
    if (!renderer) {
      return;
    }
    (_a = renderer.domElement.parentElement) == null ? void 0 : _a.removeChild(renderer.domElement);
  }
  renderer(canvas) {
    return this._renderersByCanvasId.get(canvas.id) || this.createRenderer(canvas);
  }
  // remove_renderer_element(canvas: HTMLCanvasElement) {
  // 	// not ideal, because I could not re-add it back
  // 	const renderer = this.renderer(canvas);
  // 	if (renderer) {
  // 		const parent = canvas.parentElement;
  // 		if (parent) {
  // 			parent.removeChild(renderer.domElement);
  // 		}
  // 	}
  // }
  cook() {
    this._updateCSS();
    this._renderersByCanvasId.forEach((renderer) => {
      this._updateRenderer(renderer);
    });
    this.cookController.endCook();
  }
  _updateRenderer(renderer) {
  }
  _updateCSS() {
    const element = this._CSSElement();
    element.innerHTML = this.pv.css;
  }
  // = new CSSStyleSheet();
  _CSSElement() {
    return this.__CSSElement = this.__CSSElement || this._findElement() || this._createElement();
  }
  _findElement() {
    return document.getElementById(this._CSSElementId());
  }
  _createElement() {
    const style = document.createElement("style");
    style.appendChild(document.createTextNode(""));
    document.head.appendChild(style);
    style.id = this._CSSElementId();
    return style;
  }
  _CSSElementId() {
    return `CSS2DRenderer-${this.graphNodeId()}`;
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/core/render/CSSRenderers/CSS3DRenderer.ts


const CSS3DRenderer_position = new three_module.Vector3();
const CSS3DRenderer_quaternion = new three_module.Quaternion();
const CSS3DRenderer_scale = new three_module.Vector3();
const _matrix = new three_module.Matrix4();
const _matrix2 = new three_module.Matrix4();
function epsilon(value) {
  return Math.abs(value) < 1e-10 ? 0 : value;
}
function getObjectCSSMatrix(matrix) {
  const elements = matrix.elements;
  const matrix3d = "matrix3d(" + epsilon(elements[0]) + "," + epsilon(elements[1]) + "," + epsilon(elements[2]) + "," + epsilon(elements[3]) + "," + epsilon(-elements[4]) + "," + epsilon(-elements[5]) + "," + epsilon(-elements[6]) + "," + epsilon(-elements[7]) + "," + epsilon(elements[8]) + "," + epsilon(elements[9]) + "," + epsilon(elements[10]) + "," + epsilon(elements[11]) + "," + epsilon(elements[12]) + "," + epsilon(elements[13]) + "," + epsilon(elements[14]) + "," + epsilon(elements[15]) + ")";
  return "translate(-50%,-50%)" + matrix3d;
}
function getCameraCSSMatrix(matrix) {
  const elements = matrix.elements;
  return "matrix3d(" + epsilon(elements[0]) + "," + epsilon(-elements[1]) + "," + epsilon(elements[2]) + "," + epsilon(elements[3]) + "," + epsilon(elements[4]) + "," + epsilon(-elements[5]) + "," + epsilon(elements[6]) + "," + epsilon(elements[7]) + "," + epsilon(elements[8]) + "," + epsilon(-elements[9]) + "," + epsilon(elements[10]) + "," + epsilon(elements[11]) + "," + epsilon(elements[12]) + "," + epsilon(-elements[13]) + "," + epsilon(elements[14]) + "," + epsilon(elements[15]) + ")";
}
class CSS3DRenderer {
  constructor(parameters = {}) {
    this._width = 0;
    this._height = 0;
    this._widthHalf = 0;
    this._heightHalf = 0;
    this.cache = {
      camera: { style: "" },
      objects: /* @__PURE__ */ new WeakMap()
    };
    this.appendedObjects = /* @__PURE__ */ new Set();
    this.objectsToRender = /* @__PURE__ */ new Set();
    this.objectsToRemove = /* @__PURE__ */ new Set();
    const domElement = parameters.element !== void 0 ? parameters.element : document.createElement("div");
    domElement.style.overflow = "hidden";
    this.domElement = domElement;
    this.cameraElement = document.createElement("div");
    this.cameraElement.style.transformStyle = "preserve-3d";
    this.cameraElement.style.pointerEvents = "none";
    domElement.appendChild(this.cameraElement);
  }
  getSize() {
    return {
      width: this._width,
      height: this._height
    };
  }
  render(scene, camera) {
    const fov = camera.projectionMatrix.elements[5] * this._heightHalf;
    let tx = 0;
    let ty = 0;
    if (camera.isOrthographicCamera) {
      tx = -(camera.right + camera.left) / 2;
      ty = (camera.top + camera.bottom) / 2;
    }
    const cameraCSSMatrix = camera.isOrthographicCamera ? "scale(" + fov + ")translate(" + epsilon(tx) + "px," + epsilon(ty) + "px)" + getCameraCSSMatrix(camera.matrixWorldInverse) : "translateZ(" + fov + "px)" + getCameraCSSMatrix(camera.matrixWorldInverse);
    const perspective = camera.isPerspectiveCamera ? "perspective(" + fov + "px) " : "";
    const style = perspective + cameraCSSMatrix + "translate(" + this._widthHalf + "px," + this._heightHalf + "px)";
    if (this.cache.camera.style !== style) {
      this.cameraElement.style.transform = style;
      this.cache.camera.style = style;
    }
    this.removeElementsDeletedFromSceneGraph(scene);
    this.renderObject(scene, scene, camera, cameraCSSMatrix);
  }
  removeElementsDeletedFromSceneGraph(scene) {
    this.objectsToRender.clear();
    scene.traverse((object) => {
      if (object.isCSS3DObject) {
        this.objectsToRender.add(object);
      }
    });
    this.objectsToRemove.clear();
    this.appendedObjects.forEach((appendedObject) => {
      if (!this.objectsToRender.has(appendedObject)) {
        this.objectsToRemove.add(appendedObject);
      }
    });
    this.objectsToRemove.forEach((object) => {
      this.cameraElement.removeChild(object.element);
      this.appendedObjects.delete(object);
    });
  }
  setSize(width, height) {
    this._width = width;
    this._height = height;
    this._widthHalf = this._width / 2;
    this._heightHalf = this._height / 2;
    this.domElement.style.width = width + "px";
    this.domElement.style.height = height + "px";
    this.cameraElement.style.width = width + "px";
    this.cameraElement.style.height = height + "px";
  }
  renderObject(object, scene, camera, cameraCSSMatrix) {
    if (object.isCSS3DObject) {
      const visible = object.visible === true && object.layers.test(camera.layers) === true;
      object.element.style.display = visible === true ? "" : "none";
      if (visible === true) {
        object.onBeforeRender(this, scene, camera);
        let style;
        if (object.isCSS3DSprite) {
          _matrix.copy(camera.matrixWorldInverse);
          _matrix.transpose();
          if (object.rotation2D !== 0)
            _matrix.multiply(_matrix2.makeRotationZ(object.rotation2D));
          object.matrixWorld.decompose(CSS3DRenderer_position, CSS3DRenderer_quaternion, CSS3DRenderer_scale);
          _matrix.setPosition(CSS3DRenderer_position);
          _matrix.scale(CSS3DRenderer_scale);
          _matrix.elements[3] = 0;
          _matrix.elements[7] = 0;
          _matrix.elements[11] = 0;
          _matrix.elements[15] = 1;
          style = getObjectCSSMatrix(_matrix);
        } else {
          style = getObjectCSSMatrix(object.matrixWorld);
        }
        const element = object.element;
        const cachedObject = this.cache.objects.get(object);
        if (cachedObject === void 0 || cachedObject.style !== style) {
          element.style.transform = style;
          const objectData = { style };
          this.cache.objects.set(object, objectData);
        }
        if (element.parentNode !== this.cameraElement) {
          this.cameraElement.appendChild(element);
          this.appendedObjects.add(object);
        }
        object.onAfterRender(this, scene, camera);
      }
    }
    for (let i = 0, l = object.children.length; i < l; i++) {
      this.renderObject(object.children[i], scene, camera, cameraCSSMatrix);
    }
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/rop/CSS3DRenderer.ts







const CSS3DRenderer_DEFAULT_CSS = `.${CSSObjectAttribute/* DEFAULT_CSS3DOBJECT.className */.jq.className} {
	will-change: transform;
	color: white;
	background-color: black;
	padding: 5px 10px;
	border: 1px solid blue;
	border-radius: 5px;
	pointer-events: auto;
	user-select: none;
	-webkit-font-smoothing: antialiased;
	-moz-osx-font-smoothing: grayscale;
	text-rendering: optimizeLegibility;
	font-smooth: always;
}`;
class CSS3DRendererRopParamsConfig extends params_ParamsConfig/* NodeParamsConfig */.yI {
  constructor() {
    super(...arguments);
    /** @param css rules to be added in the html document */
    this.css = params_ParamsConfig/* ParamConfig.STRING */.XC.STRING(CSS3DRenderer_DEFAULT_CSS, {
      language: OptionsController/* StringParamLanguage.CSS */.qs.CSS
    });
  }
}
const CSS3DRenderer_ParamsConfig = new CSS3DRendererRopParamsConfig();
class CSS3DRendererRopNode extends rop_Base/* TypedRopNode */.E {
  constructor() {
    super(...arguments);
    this.paramsConfig = CSS3DRenderer_ParamsConfig;
    this._renderersByCanvasId = /* @__PURE__ */ new Map();
  }
  static type() {
    return Rop/* RopType.CSS3D */.X.CSS3D;
  }
  createRenderer(canvas) {
    const renderer = new CSS3DRenderer();
    this._renderersByCanvasId.set(canvas.id, renderer);
    renderer.domElement.style.position = "absolute";
    renderer.domElement.style.top = "0px";
    renderer.domElement.style.left = "0px";
    renderer.domElement.style.pointerEvents = "none";
    renderer.domElement.style.willChange = "transform";
    this._updateRenderer(renderer);
    return renderer;
  }
  mountRenderer(canvas) {
    const renderer = this._renderersByCanvasId.get(canvas.id);
    if (!renderer) {
      console.warn(`no render found for canvas ${canvas.id}. cannot mount CSS2DRenderer`);
      return;
    }
    const parent = canvas.parentElement;
    if (parent) {
      parent.prepend(renderer.domElement);
      parent.style.position = "relative";
    } else {
      console.warn("canvas has no parent");
    }
    const rect = canvas.getBoundingClientRect();
    renderer.setSize(rect.width, rect.height);
  }
  unmountRenderer(canvas) {
    var _a;
    const renderer = this._renderersByCanvasId.get(canvas.id);
    if (!renderer) {
      return;
    }
    (_a = renderer.domElement.parentElement) == null ? void 0 : _a.removeChild(renderer.domElement);
  }
  renderer(canvas) {
    return this._renderersByCanvasId.get(canvas.id) || this.createRenderer(canvas);
  }
  // remove_renderer_element(canvas: HTMLCanvasElement) {
  // 	// not ideal, because I could not re-add it back
  // 	const renderer = this.renderer(canvas);
  // 	if (renderer) {
  // 		const parent = canvas.parentElement;
  // 		if (parent) {
  // 			parent.removeChild(renderer.domElement);
  // 		}
  // 	}
  // }
  cook() {
    this._updateCSS();
    this._renderersByCanvasId.forEach((renderer) => {
      this._updateRenderer(renderer);
    });
    this.cookController.endCook();
  }
  _updateRenderer(renderer) {
  }
  _updateCSS() {
    const element = this._CSSElement();
    element.innerHTML = this.pv.css;
  }
  // = new CSSStyleSheet();
  _CSSElement() {
    return this.__CSSElement = this.__CSSElement || this._findElement() || this._createElement();
  }
  _findElement() {
    return document.getElementById(this._CSSElementId());
  }
  _createElement() {
    const style = document.createElement("style");
    style.appendChild(document.createTextNode(""));
    document.head.appendChild(style);
    style.id = this._CSSElementId();
    return style;
  }
  _CSSElementId() {
    return `CSS2DRenderer-${this.graphNodeId()}`;
  }
}

// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/nodes/rop/PathTracingRenderer.ts + 43 modules
var PathTracingRenderer = __webpack_require__(76310);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/nodes/rop/WebGLRenderer.ts
var WebGLRenderer = __webpack_require__(31207);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/nodes/rop/_BaseManager.ts
var rop_BaseManager = __webpack_require__(57469);
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/rop/ActorsNetwork.ts







class ActorsNetworkRopNode extends rop_BaseManager/* ParamLessBaseNetworkRopNode */.$ {
  constructor() {
    super(...arguments);
    this._childrenControllerContext = poly_NodeContext/* NodeContext.JS */.sy.JS;
    //
    // ASSEMBLERS
    //
    this.persisted_config = new ActorPersistedConfig/* ActorPersistedConfig */.R(this);
    this._assemblerController = this._createAssemblerController();
    //
    // compilation
    //
    this.compilationController = new ActorCompilationController/* ActorCompilationController */.z7(this);
  }
  static type() {
    return poly_NodeContext/* NetworkNodeType.ACTOR */.kX.ACTOR;
  }
  createNode(node_class, options) {
    return super.createNode(node_class, options);
  }
  children() {
    return super.children();
  }
  nodesByType(type) {
    return super.nodesByType(type);
  }
  //
  childrenAllowed() {
    if (this.assemblerController()) {
      return super.childrenAllowed();
    }
    return false;
  }
  sceneReadonly() {
    return this.assemblerController() == null;
  }
  assemblerController() {
    return this._assemblerController;
  }
  usedAssembler() {
    return _BaseRegister/* AssemblerName.JS_ACTOR */.Q.JS_ACTOR;
  }
  _createAssemblerController() {
    return Poly/* Poly.assemblersRegister.assembler */.L.assemblersRegister.assembler(this, this.usedAssembler());
  }
  compile() {
    this.compilationController.compile();
  }
  cook() {
    this.compilationController.compileIfRequired();
    this.cookController.endCook();
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/rop/AnimationsNetwork.ts



class AnimationsNetworkRopNode extends rop_BaseManager/* ParamLessBaseNetworkRopNode */.$ {
  constructor() {
    super(...arguments);
    this._childrenControllerContext = poly_NodeContext/* NodeContext.ANIM */.sy.ANIM;
  }
  static type() {
    return poly_NodeContext/* NetworkNodeType.ANIM */.kX.ANIM;
  }
  createNode(node_class, options) {
    return super.createNode(node_class, options);
  }
  children() {
    return super.children();
  }
  nodesByType(type) {
    return super.nodesByType(type);
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/rop/AudioNetwork.ts



class AudioNetworkRopNode extends rop_BaseManager/* ParamLessBaseNetworkRopNode */.$ {
  constructor() {
    super(...arguments);
    this._childrenControllerContext = poly_NodeContext/* NodeContext.AUDIO */.sy.AUDIO;
  }
  static type() {
    return poly_NodeContext/* NetworkNodeType.AUDIO */.kX.AUDIO;
  }
  createNode(node_class, options) {
    return super.createNode(node_class, options);
  }
  children() {
    return super.children();
  }
  nodesByType(type) {
    return super.nodesByType(type);
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/rop/CopNetwork.ts



class CopNetworkRopNode extends rop_BaseManager/* ParamLessBaseNetworkRopNode */.$ {
  constructor() {
    super(...arguments);
    this._childrenControllerContext = poly_NodeContext/* NodeContext.COP */.sy.COP;
  }
  static type() {
    return poly_NodeContext/* NetworkNodeType.COP */.kX.COP;
  }
  createNode(node_class, options) {
    return super.createNode(node_class, options);
  }
  children() {
    return super.children();
  }
  nodesByType(type) {
    return super.nodesByType(type);
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/rop/EventsNetwork.ts



class EventsNetworkRopNode extends rop_BaseManager/* ParamLessBaseNetworkRopNode */.$ {
  constructor() {
    super(...arguments);
    this._childrenControllerContext = poly_NodeContext/* NodeContext.EVENT */.sy.EVENT;
  }
  static type() {
    return poly_NodeContext/* NetworkNodeType.EVENT */.kX.EVENT;
  }
  createNode(node_class, options) {
    return super.createNode(node_class, options);
  }
  children() {
    return super.children();
  }
  nodesByType(type) {
    return super.nodesByType(type);
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/rop/MaterialsNetwork.ts



class MaterialsNetworkRopNode extends rop_BaseManager/* ParamLessBaseNetworkRopNode */.$ {
  constructor() {
    super(...arguments);
    this._childrenControllerContext = poly_NodeContext/* NodeContext.MAT */.sy.MAT;
  }
  static type() {
    return poly_NodeContext/* NetworkNodeType.MAT */.kX.MAT;
  }
  createNode(node_class, options) {
    return super.createNode(node_class, options);
  }
  children() {
    return super.children();
  }
  nodesByType(type) {
    return super.nodesByType(type);
  }
}

// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/nodes/rop/PostProcessNetwork.ts
var rop_PostProcessNetwork = __webpack_require__(88013);
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/rop/RenderersNetwork.ts



class RenderersNetworkRopNode extends rop_BaseManager/* ParamLessBaseNetworkRopNode */.$ {
  constructor() {
    super(...arguments);
    this._childrenControllerContext = poly_NodeContext/* NodeContext.ROP */.sy.ROP;
  }
  static type() {
    return poly_NodeContext/* NetworkNodeType.ROP */.kX.ROP;
  }
  createNode(node_class, options) {
    return super.createNode(node_class, options);
  }
  children() {
    return super.children();
  }
  nodesByType(type) {
    return super.nodesByType(type);
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/poly/registers/nodes/Rop.ts














class RopRegister {
  static run(poly) {
    poly.registerNode(CSS2DRendererRopNode, CATEGORY_ROP.CSS);
    poly.registerNode(CSS3DRendererRopNode, CATEGORY_ROP.CSS);
    poly.registerNode(PathTracingRenderer/* PathTracingRendererRopNode */.A, CATEGORY_ROP.WEBGL);
    poly.registerNode(WebGLRenderer/* WebGLRendererRopNode */.Ou, CATEGORY_ROP.WEBGL);
    poly.registerNode(ActorsNetworkRopNode, CATEGORY_ROP.NETWORK);
    poly.registerNode(AnimationsNetworkRopNode, CATEGORY_ROP.NETWORK);
    poly.registerNode(AudioNetworkRopNode, CATEGORY_ROP.NETWORK);
    poly.registerNode(CopNetworkRopNode, CATEGORY_ROP.NETWORK);
    poly.registerNode(EventsNetworkRopNode, CATEGORY_ROP.NETWORK);
    poly.registerNode(MaterialsNetworkRopNode, CATEGORY_ROP.NETWORK);
    poly.registerNode(rop_PostProcessNetwork/* PostProcessNetworkRopNode */.f, CATEGORY_ROP.NETWORK);
    poly.registerNode(RenderersNetworkRopNode, CATEGORY_ROP.NETWORK);
  }
}

// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/nodes/sop/Actor.ts
var Actor = __webpack_require__(98517);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/nodes/sop/ActorInstance.ts
var ActorInstance = __webpack_require__(83655);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/nodes/sop/ActorPoint.ts
var ActorPoint = __webpack_require__(36138);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/nodes/sop/Add.ts
var Add = __webpack_require__(48950);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/nodes/sop/_Base.ts
var sop_Base = __webpack_require__(55839);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/operations/sop/_Base.ts
var operations_sop_Base = __webpack_require__(82612);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/core/geometry/Mask.ts
var Mask = __webpack_require__(58290);
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/operations/sop/Adjacency.ts

var Adjacency_defProp = Object.defineProperty;
var Adjacency_getOwnPropSymbols = Object.getOwnPropertySymbols;
var Adjacency_hasOwnProp = Object.prototype.hasOwnProperty;
var Adjacency_propIsEnum = Object.prototype.propertyIsEnumerable;
var Adjacency_defNormalProp = (obj, key, value) => key in obj ? Adjacency_defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var Adjacency_spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (Adjacency_hasOwnProp.call(b, prop))
      Adjacency_defNormalProp(a, prop, b[prop]);
  if (Adjacency_getOwnPropSymbols)
    for (var prop of Adjacency_getOwnPropSymbols(b)) {
      if (Adjacency_propIsEnum.call(b, prop))
        Adjacency_defNormalProp(a, prop, b[prop]);
    }
  return a;
};




class AdjacencySopOperation extends operations_sop_Base/* BaseSopOperation */.U {
  static type() {
    return Sop/* SopType.ADJACENCY */.aB.ADJACENCY;
  }
  cook(inputCoreGroups, params) {
    const coreGroup = inputCoreGroups[0];
    const objects = (0,Mask/* filterThreejsObjects */.zl)(coreGroup, params);
    for (let object of objects) {
      (0,Adjacency/* populateAdjacency3 */.w3)(object, params);
    }
    return coreGroup;
  }
}
AdjacencySopOperation.DEFAULT_PARAMS = Adjacency_spreadValues({
  group: ""
}, Adjacency/* POPULATE_ADJACENCY_DEFAULT */.Vc);

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/sop/Adjacency.ts






const DEFAULT = AdjacencySopOperation.DEFAULT_PARAMS;
class AdjacencySopParamsConfig extends params_ParamsConfig/* NodeParamsConfig */.yI {
  constructor() {
    super(...arguments);
    /** @param select which objects this add adjacency attributes to */
    this.group = params_ParamsConfig/* ParamConfig.STRING */.XC.STRING("", {
      objectMask: true
    });
    /** @param name of attribute with count of adjacency attributes */
    this.adjacencyCountName = params_ParamsConfig/* ParamConfig.STRING */.XC.STRING(DEFAULT.adjacencyCountName);
    /** @param name of adjacency attribute */
    this.adjacencyBaseName = params_ParamsConfig/* ParamConfig.STRING */.XC.STRING(DEFAULT.adjacencyBaseName);
  }
}
const Adjacency_ParamsConfig = new AdjacencySopParamsConfig();
class AdjacencySopNode extends sop_Base/* TypedSopNode */.x {
  constructor() {
    super(...arguments);
    this.paramsConfig = Adjacency_ParamsConfig;
  }
  static type() {
    return Sop/* SopType.ADJACENCY */.aB.ADJACENCY;
  }
  initializeNode() {
    this.io.inputs.setCount(1);
    this.io.inputs.initInputsClonedState([InputCloneMode/* InputCloneMode.FROM_NODE */.m.FROM_NODE]);
  }
  cook(inputCoreGroups) {
    this._operation = this._operation || new AdjacencySopOperation(this.scene(), this.states, this);
    const coreGroup = this._operation.cook(inputCoreGroups, this.pv);
    this.setCoreGroup(coreGroup);
  }
}

// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/nodes/sop/AmbientLight.ts
var sop_AmbientLight = __webpack_require__(87322);
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/sop/AnimationCopy.ts





class AnimationCopySopParamsConfig extends params_ParamsConfig/* NodeParamsConfig */.yI {
}
const AnimationCopy_ParamsConfig = new AnimationCopySopParamsConfig();
class AnimationCopySopNode extends sop_Base/* TypedSopNode */.x {
  constructor() {
    super(...arguments);
    this.paramsConfig = AnimationCopy_ParamsConfig;
  }
  static type() {
    return Sop/* SopType.ANIMATION_COPY */.aB.ANIMATION_COPY;
  }
  initializeNode() {
    this.io.inputs.setCount(2);
    this.io.inputs.initInputsClonedState([InputCloneMode/* InputCloneMode.FROM_NODE */.m.FROM_NODE, InputCloneMode/* InputCloneMode.NEVER */.m.NEVER]);
  }
  cook(input_contents) {
    const core_group_target = input_contents[0];
    const core_group_src = input_contents[1];
    const src_object = core_group_src.threejsObjects()[0];
    const target_object = core_group_target.threejsObjects()[0];
    const src_animations = src_object.animations;
    if (src_animations) {
      target_object.animations = src_animations.map((a) => a.clone());
      this.setCoreGroup(core_group_target);
    } else {
      this.states.error.set("no animation found");
    }
  }
}

// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/nodes/sop/AreaLight.ts
var sop_AreaLight = __webpack_require__(4455);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/nodes/sop/AttribAddMult.ts
var AttribAddMult = __webpack_require__(92417);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/nodes/sop/AttribCast.ts
var AttribCast = __webpack_require__(17490);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/nodes/sop/AttribCopy.ts
var AttribCopy = __webpack_require__(8415);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/nodes/sop/AttribCreate.ts + 6 modules
var AttribCreate = __webpack_require__(11750);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/nodes/sop/AttribDelete.ts
var AttribDelete = __webpack_require__(56090);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/nodes/sop/AttribFromTexture.ts
var AttribFromTexture = __webpack_require__(66330);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/nodes/sop/AttribId.ts
var AttribId = __webpack_require__(92635);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/nodes/sop/AttribNormalize.ts
var AttribNormalize = __webpack_require__(94692);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/nodes/sop/AttribPromote.ts
var AttribPromote = __webpack_require__(84092);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/nodes/sop/AttribRemap.ts
var AttribRemap = __webpack_require__(34692);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/nodes/sop/AttribRename.ts
var AttribRename = __webpack_require__(33523);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/nodes/sop/AttribSetAtIndex.ts
var AttribSetAtIndex = __webpack_require__(99861);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/nodes/sop/AttribTransfer.ts + 4 modules
var AttribTransfer = __webpack_require__(6479);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/nodes/sop/AudioNotes.ts
var AudioNotes = __webpack_require__(97619);
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/operations/sop/AxesHelper.ts





class AxesHelperSopOperation extends operations_sop_Base/* BaseSopOperation */.U {
  static type() {
    return "axesHelper";
  }
  cook(input_contents, params) {
    const helper = new three_module.AxesHelper();
    helper.geometry.translate(params.center.x, params.center.y, params.center.z);
    helper.matrixAutoUpdate = false;
    if (this._node) {
      helper.name = this._node.name();
    }
    return this.createCoreGroupFromObjects([helper]);
  }
}
AxesHelperSopOperation.DEFAULT_PARAMS = {
  center: new three_module.Vector3(0, 0, 0)
};
AxesHelperSopOperation.INPUT_CLONED_STATE = InputCloneMode/* InputCloneMode.NEVER */.m.NEVER;

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/sop/AxesHelper.ts





const AxesHelper_DEFAULT = AxesHelperSopOperation.DEFAULT_PARAMS;
class AxesHelperSopParamsConfig extends params_ParamsConfig/* NodeParamsConfig */.yI {
  constructor() {
    super(...arguments);
    /** @param center of the geometry */
    this.center = params_ParamsConfig/* ParamConfig.VECTOR3 */.XC.VECTOR3(AxesHelper_DEFAULT.center);
  }
}
const AxesHelper_ParamsConfig = new AxesHelperSopParamsConfig();
class AxesHelperSopNode extends sop_Base/* TypedSopNode */.x {
  constructor() {
    super(...arguments);
    this.paramsConfig = AxesHelper_ParamsConfig;
  }
  static type() {
    return Sop/* SopType.AXES_HELPER */.aB.AXES_HELPER;
  }
  initializeNode() {
    this.io.inputs.setCount(0);
  }
  cook(input_contents) {
    this._operation = this._operation || new AxesHelperSopOperation(this.scene(), this.states, this);
    const core_group = this._operation.cook(input_contents, this.pv);
    this.setCoreGroup(core_group);
  }
}

// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/nodes/sop/BboxScatter.ts
var BboxScatter = __webpack_require__(80444);
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/sop/Blend.ts






class BlendSopParamsConfig extends params_ParamsConfig/* NodeParamsConfig */.yI {
  constructor() {
    super(...arguments);
    /** @param name of the attribute to blend */
    this.attribName = params_ParamsConfig/* ParamConfig.STRING */.XC.STRING("position");
    /** @param blend value. 0 means the result will equal the left input, 1 will equal the right input, and 0.5 will be an average of both. */
    this.blend = params_ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(0.5, {
      range: [0, 1],
      rangeLocked: [true, true]
    });
    /** @param update normals */
    this.updateNormals = params_ParamsConfig/* ParamConfig.BOOLEAN */.XC.BOOLEAN(1);
  }
}
const sop_Blend_ParamsConfig = new BlendSopParamsConfig();
class BlendSopNode extends sop_Base/* TypedSopNode */.x {
  constructor() {
    super(...arguments);
    this.paramsConfig = sop_Blend_ParamsConfig;
  }
  static type() {
    return Sop/* SopType.BLEND */.aB.BLEND;
  }
  initializeNode() {
    this.io.inputs.setCount(2);
    this.io.inputs.initInputsClonedState([InputCloneMode/* InputCloneMode.FROM_NODE */.m.FROM_NODE, InputCloneMode/* InputCloneMode.NEVER */.m.NEVER]);
  }
  cook(inputCoreGroups) {
    const coreGroup0 = inputCoreGroups[0];
    const coreGroup1 = inputCoreGroups[1];
    const objects0 = coreGroup0.threejsObjects();
    const objects1 = coreGroup1.threejsObjects();
    for (let i = 0; i < objects0.length; i++) {
      this.blend(objects0[i], objects1[i], this.pv.blend);
    }
    this.setCoreGroup(coreGroup0);
  }
  blend(object0, object1, blend) {
    const geometry0 = object0.geometry;
    const geometry1 = object1.geometry;
    if (geometry0 == null || geometry1 == null) {
      return;
    }
    const attrib0 = geometry0.getAttribute(this.pv.attribName);
    const attrib1 = geometry1.getAttribute(this.pv.attribName);
    if (attrib0 == null || attrib1 == null) {
      return;
    }
    const attrib0_array = attrib0.array;
    const attrib1_array = attrib1.array;
    let c0, c1;
    for (let i = 0; i < attrib0_array.length; i++) {
      c0 = attrib0_array[i];
      c1 = attrib1_array[i];
      if (c1 != null) {
        attrib0_array[i] = (1 - blend) * c0 + blend * c1;
      }
    }
    if ((0,Type/* isBooleanTrue */.bI)(this.pv.updateNormals)) {
      geometry0.computeVertexNormals();
    }
  }
}

// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/nodes/sop/Boolean.ts
var sop_Boolean = __webpack_require__(85976);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/nodes/sop/Box.ts
var Box = __webpack_require__(3934);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/nodes/sop/BoxLines.ts
var BoxLines = __webpack_require__(95456);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/core/geometry/bvh/ThreeMeshBVHHelper.ts + 2 modules
var ThreeMeshBVHHelper = __webpack_require__(17862);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/node_modules/three-mesh-bvh/src/core/Constants.js
var Constants = __webpack_require__(20690);
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/operations/sop/BVH.ts





const nameByStragery = {
  [Constants/* CENTER */.dv]: "center",
  [Constants/* AVERAGE */.$V]: "average",
  [Constants/* SAH */.ms]: "sah"
};
const STRAGERY_MENU_ENTRIES = [Constants/* CENTER */.dv, Constants/* AVERAGE */.$V, Constants/* SAH */.ms].map((value) => {
  return { name: nameByStragery[value], value };
});
class BVHSopOperation extends operations_sop_Base/* BaseSopOperation */.U {
  static type() {
    return "BVH";
  }
  cook(inputCoreGroups, params) {
    const inputCoreGroup = inputCoreGroups[0];
    if (inputCoreGroup) {
      const objects = inputCoreGroup.threejsObjects();
      for (let object of objects) {
        object.traverse((child) => {
          const mesh = child;
          if (mesh.isMesh) {
            const bvh = ThreeMeshBVHHelper/* ThreeMeshBVHHelper.createBVH */.h.createBVH(mesh, {
              strategy: params.strategy,
              maxLeafTris: params.maxLeafTris,
              maxDepth: params.maxDepth,
              verbose: params.verbose
            });
            ThreeMeshBVHHelper/* ThreeMeshBVHHelper.assignBVH */.h.assignBVH(mesh, bvh);
          }
        });
      }
    }
    return inputCoreGroup;
  }
  // private _makeCompact(allMeshes: Mesh[]) {
  // 	const geometries: BufferGeometry[] = [];
  // 	let material: Material | undefined;
  // 	for (let mesh of allMeshes) {
  // 		material = material || (mesh.material as Material);
  // 		const geometry = mesh.geometry;
  // 		geometry.applyMatrix4(mesh.matrix);
  // 		geometries.push(geometry);
  // 	}
  // 	// TODO: test that this works with geometries with same attributes
  // 	try {
  // 		const mergedGeometry = CoreGeometryBuilderMerge.merge(geometries);
  // 		if (mergedGeometry) {
  // 			const mesh = this.createObject(mergedGeometry, ObjectType.MESH, material);
  // 			return mesh;
  // 		} else {
  // 			this.states?.error.set('merge failed, check that input geometries have the same attributes');
  // 		}
  // 	} catch (e) {
  // 		this.states?.error.set((e as Error).message);
  // 	}
  // }
}
BVHSopOperation.DEFAULT_PARAMS = {
  strategy: Constants/* CENTER */.dv,
  maxLeafTris: 10,
  maxDepth: 40,
  verbose: false,
  keepOnlyPosition: false
};
BVHSopOperation.INPUT_CLONED_STATE = InputCloneMode/* InputCloneMode.ALWAYS */.m.ALWAYS;

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/sop/BVH.ts





const BVH_DEFAULT = BVHSopOperation.DEFAULT_PARAMS;
class BVHSopParamsConfig extends params_ParamsConfig/* NodeParamsConfig */.yI {
  constructor() {
    super(...arguments);
    this.strategy = params_ParamsConfig/* ParamConfig.INTEGER */.XC.INTEGER(BVH_DEFAULT.strategy, {
      menu: {
        entries: STRAGERY_MENU_ENTRIES
      }
    });
    this.maxDepth = params_ParamsConfig/* ParamConfig.INTEGER */.XC.INTEGER(BVH_DEFAULT.maxDepth, {
      range: [1, 128],
      rangeLocked: [true, false]
    });
    this.maxLeafTris = params_ParamsConfig/* ParamConfig.INTEGER */.XC.INTEGER(BVH_DEFAULT.maxLeafTris, {
      range: [1, 16],
      rangeLocked: [true, false]
    });
    this.verbose = params_ParamsConfig/* ParamConfig.BOOLEAN */.XC.BOOLEAN(BVH_DEFAULT.verbose);
    this.keepOnlyPosition = params_ParamsConfig/* ParamConfig.BOOLEAN */.XC.BOOLEAN(BVH_DEFAULT.keepOnlyPosition);
  }
}
const BVH_ParamsConfig = new BVHSopParamsConfig();
class BVHSopNode extends sop_Base/* TypedSopNode */.x {
  constructor() {
    super(...arguments);
    this.paramsConfig = BVH_ParamsConfig;
  }
  static type() {
    return Sop/* SopType.BVH */.aB.BVH;
  }
  initializeNode() {
    this.io.inputs.setCount(1);
    this.io.inputs.initInputsClonedState(BVHSopOperation.INPUT_CLONED_STATE);
  }
  cook(input_contents) {
    this._operation = this._operation || new BVHSopOperation(this._scene, this.states, this);
    const core_group = this._operation.cook(input_contents, this.pv);
    this.setCoreGroup(core_group);
  }
}

// EXTERNAL MODULE: ../@polygonjs/polygonjs/node_modules/three-mesh-bvh/src/objects/MeshBVHVisualizer.js
var MeshBVHVisualizer = __webpack_require__(70359);
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/operations/sop/BVHVisualizer.ts




class BVHVisualizerSopOperation extends operations_sop_Base/* BaseSopOperation */.U {
  static type() {
    return "BVHVisualizer";
  }
  cook(inputCoreGroups, params) {
    const inputCoreGroup = inputCoreGroups[0];
    const objects = inputCoreGroup.threejsObjects();
    const newObjects = [];
    for (let object of objects) {
      newObjects.push(object);
      object.traverse((childObject) => {
        const mesh = childObject;
        if (mesh.isMesh) {
          const visualizer = new MeshBVHVisualizer/* MeshBVHVisualizer */.y(mesh, params.depth);
          visualizer.opacity = params.opacity;
          visualizer.displayEdges = params.displayEdges;
          visualizer.displayParents = params.displayParents;
          visualizer.update();
          const parent = mesh.parent;
          if (parent) {
            parent.add(visualizer);
          } else {
            newObjects.push(visualizer);
          }
          mesh.geometry.drawRange.count = 0;
        }
      });
    }
    return this.createCoreGroupFromObjects(newObjects);
  }
}
BVHVisualizerSopOperation.DEFAULT_PARAMS = {
  depth: 0,
  opacity: 0.2,
  displayEdges: true,
  displayParents: false
};
BVHVisualizerSopOperation.INPUT_CLONED_STATE = InputCloneMode/* InputCloneMode.ALWAYS */.m.ALWAYS;

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/sop/BVHVisualizer.ts





const BVHVisualizer_DEFAULT = BVHVisualizerSopOperation.DEFAULT_PARAMS;
class BVHVisualizerSopParamsConfig extends params_ParamsConfig/* NodeParamsConfig */.yI {
  constructor() {
    super(...arguments);
    /** @param depth */
    this.depth = params_ParamsConfig/* ParamConfig.INTEGER */.XC.INTEGER(BVHVisualizer_DEFAULT.depth, {
      range: [0, 128],
      rangeLocked: [true, false]
    });
    /** @param opacity */
    this.opacity = params_ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(BVHVisualizer_DEFAULT.opacity, {
      range: [0, 1],
      rangeLocked: [true, true]
    });
    /** @param depth */
    this.displayEdges = params_ParamsConfig/* ParamConfig.BOOLEAN */.XC.BOOLEAN(BVHVisualizer_DEFAULT.displayEdges);
    /** @param depth */
    this.displayParents = params_ParamsConfig/* ParamConfig.BOOLEAN */.XC.BOOLEAN(BVHVisualizer_DEFAULT.displayParents);
  }
}
const BVHVisualizer_ParamsConfig = new BVHVisualizerSopParamsConfig();
class BVHVisualizerSopNode extends sop_Base/* TypedSopNode */.x {
  constructor() {
    super(...arguments);
    this.paramsConfig = BVHVisualizer_ParamsConfig;
  }
  static type() {
    return Sop/* SopType.BVH_VISUALIZER */.aB.BVH_VISUALIZER;
  }
  initializeNode() {
    this.io.inputs.setCount(1);
    this.io.inputs.initInputsClonedState(BVHVisualizerSopOperation.INPUT_CLONED_STATE);
  }
  cook(input_contents) {
    this._operation = this._operation || new BVHVisualizerSopOperation(this._scene, this.states, this);
    const core_group = this._operation.cook(input_contents, this.pv);
    this.setCoreGroup(core_group);
  }
}

// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/nodes/sop/Cache.ts
var Cache = __webpack_require__(10664);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/nodes/sop/CADBoolean.ts
var CADBoolean = __webpack_require__(54389);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/nodes/sop/_BaseCAD.ts
var _BaseCAD = __webpack_require__(85315);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/core/geometry/modules/cad/CadConstant.ts
var CadConstant = __webpack_require__(30416);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/core/geometry/modules/cad/CadLoader.ts + 1 modules
var CadLoader = __webpack_require__(3781);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/core/geometry/modules/cad/toObject3D/CadShapeCommon.ts
var CadShapeCommon = __webpack_require__(14194);
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/sop/CADBox.ts

var CADBox_async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step2(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step2(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step2 = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step2((generator = generator.apply(__this, __arguments)).next());
  });
};







const size = new three_module.Vector3();
const centerOffset = new three_module.Vector3();
class CADBoxSopParamsConfig extends params_ParamsConfig/* NodeParamsConfig */.yI {
  constructor() {
    super(...arguments);
    /** @param size */
    this.size = params_ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(1, {
      range: [0, 10],
      rangeLocked: [true, false],
      step: CadConstant/* step */.Nb
    });
    /** @param sizes */
    this.sizes = params_ParamsConfig/* ParamConfig.VECTOR3 */.XC.VECTOR3([1, 1, 1]);
    /** @param center */
    this.center = params_ParamsConfig/* ParamConfig.VECTOR3 */.XC.VECTOR3([0, 0, 0]);
  }
}
const CADBox_ParamsConfig = new CADBoxSopParamsConfig();
class CADBoxSopNode extends _BaseCAD/* CADSopNode */.M {
  constructor() {
    super(...arguments);
    this.paramsConfig = CADBox_ParamsConfig;
  }
  static type() {
    return Sop/* SopType.CAD_BOX */.aB.CAD_BOX;
  }
  cook() {
    return CADBox_async(this, null, function* () {
      const oc = yield CadLoader/* CadLoader.core */.i.core(this);
      size.copy(this.pv.sizes).multiplyScalar(this.pv.size);
      const api = new oc.BRepPrimAPI_MakeBox_2(size.x, size.y, size.z);
      centerOffset.copy(size).multiplyScalar(-0.5);
      const centered = (0,CadShapeCommon/* cadShapeTranslate */.ew)(api.Shape(), centerOffset);
      const shape = (0,CadShapeCommon/* cadShapeTranslate */.ew)(centered, this.pv.center);
      api.delete();
      this.setCADShape(shape);
    });
  }
}

// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/core/geometry/modules/cad/CadLoaderSync.ts
var CadLoaderSync = __webpack_require__(16457);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/core/geometry/modules/cad/toObject3D/CadEdge.ts
var CadEdge = __webpack_require__(57860);
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/sop/CADCircle.ts

var CADCircle_async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step2(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step2(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step2 = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step2((generator = generator.apply(__this, __arguments)).next());
  });
};







class CADCircleSopParamsConfig extends params_ParamsConfig/* NodeParamsConfig */.yI {
  constructor() {
    super(...arguments);
    /** @param radius */
    this.radius = params_ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(1, {
      range: [0, 2],
      rangeLocked: [true, false],
      step: CadConstant/* step */.Nb
    });
    /** @param axis */
    this.axis = params_ParamsConfig/* ParamConfig.VECTOR3 */.XC.VECTOR3([0, 1, 0]);
    /** @param center */
    this.center = params_ParamsConfig/* ParamConfig.VECTOR3 */.XC.VECTOR3([0, 0, 0]);
  }
}
const CADCircle_ParamsConfig = new CADCircleSopParamsConfig();
class CADCircleSopNode extends _BaseCAD/* CADSopNode */.M {
  constructor() {
    super(...arguments);
    this.paramsConfig = CADCircle_ParamsConfig;
  }
  static type() {
    return Sop/* SopType.CAD_CIRCLE */.aB.CAD_CIRCLE;
  }
  cook(inputCoreGroups) {
    return CADCircle_async(this, null, function* () {
      const oc = yield CadLoader/* CadLoader.core */.i.core(this);
      const axis1 = CadLoaderSync/* CadLoaderSync.gp_Ax1 */.T.gp_Ax1;
      const dir = CadLoaderSync/* CadLoaderSync.gp_Dir */.T.gp_Dir;
      dir.SetCoord_2(this.pv.axis.x, this.pv.axis.y, this.pv.axis.z);
      axis1.SetDirection(dir);
      const axis = CadLoaderSync/* CadLoaderSync.gp_Ax2 */.T.gp_Ax2;
      axis.SetAxis(axis1);
      const circle = new oc.Geom_Circle_2(axis, this.pv.radius);
      const t = CadLoaderSync/* CadLoaderSync.gp_Vec */.T.gp_Vec;
      t.SetCoord_2(this.pv.center.x, this.pv.center.y, this.pv.center.z);
      circle.Translate_1(t);
      const edge = (0,CadEdge/* cadEdgeCreate */.Ll)(oc, circle);
      this.setCADShape(edge);
    });
  }
}

// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/core/geometry/modules/cad/toObject3D/CadGeom2dCurve.ts
var CadGeom2dCurve = __webpack_require__(94871);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/core/geometry/modules/cad/CadCommon.ts
var CadCommon = __webpack_require__(39244);
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/sop/CADCircle2D.ts

var CADCircle2D_async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step2(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step2(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step2 = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step2((generator = generator.apply(__this, __arguments)).next());
  });
};







class CADCircle2DSopParamsConfig extends params_ParamsConfig/* NodeParamsConfig */.yI {
  constructor() {
    super(...arguments);
    /** @param radius */
    this.radius = params_ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(1, {
      range: [0, 2],
      rangeLocked: [true, false],
      step: CadConstant/* step */.Nb
    });
    /** @param center */
    this.center = params_ParamsConfig/* ParamConfig.VECTOR2 */.XC.VECTOR2([0, 0]);
  }
}
const CADCircle2D_ParamsConfig = new CADCircle2DSopParamsConfig();
class CADCircle2DSopNode extends _BaseCAD/* CADSopNode */.M {
  constructor() {
    super(...arguments);
    this.paramsConfig = CADCircle2D_ParamsConfig;
  }
  static type() {
    return Sop/* SopType.CAD_CIRCLE_2D */.aB.CAD_CIRCLE_2D;
  }
  cook(inputCoreGroups) {
    return CADCircle2D_async(this, null, function* () {
      const oc = yield CadLoader/* CadLoader.core */.i.core(this);
      CadCommon/* CadGC.withGC */.Jd.withGC((r) => {
        const axis = r(new oc.gp_Ax22d_1());
        const circle = new oc.Geom2d_Circle_3(axis, this.pv.radius);
        (0,CadGeom2dCurve/* cadGeom2dCurveTranslate */.H5)(circle, this.pv.center);
        this.setCADGeom2dCurve(circle);
      });
    });
  }
}

// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/core/geometry/modules/cad/CadCoreType.ts
var CadCoreType = __webpack_require__(76514);
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/sop/CADCircle3Points.ts

var CADCircle3Points_async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};






class CADCircle3PointsSopParamsConfig extends params_ParamsConfig/* NodeParamsConfig */.yI {
}
const CADCircle3Points_ParamsConfig = new CADCircle3PointsSopParamsConfig();
class CADCircle3PointsSopNode extends _BaseCAD/* CADSopNode */.M {
  constructor() {
    super(...arguments);
    this.paramsConfig = CADCircle3Points_ParamsConfig;
  }
  static type() {
    return Sop/* SopType.CAD_CIRCLE_3_POINTS */.aB.CAD_CIRCLE_3_POINTS;
  }
  initializeNode() {
    this.io.inputs.setCount(1);
  }
  cook(inputCoreGroups) {
    return CADCircle3Points_async(this, null, function* () {
      const cadObjects = inputCoreGroups[0].cadObjects();
      const vertices = [];
      if (cadObjects) {
        for (const object of cadObjects) {
          if (CadCoreType/* CoreCadType.isVertex */.c.isVertex(object)) {
            vertices.push(object.cadGeometry());
          }
        }
      }
      if (vertices.length >= 3) {
        const oc = yield CadLoader/* CadLoader.core */.i.core(this);
        const point0 = oc.BRep_Tool.Pnt(vertices[0]);
        const point1 = oc.BRep_Tool.Pnt(vertices[1]);
        const point2 = oc.BRep_Tool.Pnt(vertices[2]);
        const api = new oc.GC_MakeArcOfCircle_4(point0, point1, point2);
        const curve = api.Value().get();
        const edge = (0,CadEdge/* cadEdgeCreate */.Ll)(oc, curve);
        api.delete();
        this.setCADShape(edge);
      } else {
        this.setCADObjects([]);
      }
    });
  }
}

// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/core/geometry/modules/cad/CadMath.ts
var CadMath = __webpack_require__(21133);
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/sop/CADCone.ts

var CADCone_async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step2(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step2(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step2 = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step2((generator = generator.apply(__this, __arguments)).next());
  });
};







class CADConeSopParamsConfig extends params_ParamsConfig/* NodeParamsConfig */.yI {
  constructor() {
    super(...arguments);
    /** @param base radius */
    this.baseRadius = params_ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(0.5, {
      range: [0, 2],
      rangeLocked: [true, false],
      step: CadConstant/* step */.Nb
    });
    /** @param top radius */
    this.topRadius = params_ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(0, {
      range: [0, 2],
      rangeLocked: [true, false],
      step: CadConstant/* step */.Nb
    });
    /** @param height */
    this.height = params_ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(1, {
      range: [0, 2],
      rangeLocked: [true, false],
      step: CadConstant/* step */.Nb
    });
    /** @param center */
    this.center = params_ParamsConfig/* ParamConfig.VECTOR3 */.XC.VECTOR3([0, 0, 0]);
    /** @param axis */
    this.axis = params_ParamsConfig/* ParamConfig.VECTOR3 */.XC.VECTOR3([0, 1, 0]);
    /** @param closed */
    this.closed = params_ParamsConfig/* ParamConfig.BOOLEAN */.XC.BOOLEAN(true);
    /** @param phi */
    this.phi = params_ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(`2*$PI`, {
      range: [0, 2 * Math.PI],
      rangeLocked: [true, true],
      step: CadConstant/* step */.Nb,
      visibleIf: { closed: false }
    });
  }
}
const CADCone_ParamsConfig = new CADConeSopParamsConfig();
class CADConeSopNode extends _BaseCAD/* CADSopNode */.M {
  constructor() {
    super(...arguments);
    this.paramsConfig = CADCone_ParamsConfig;
  }
  static type() {
    return Sop/* SopType.CAD_CONE */.aB.CAD_CONE;
  }
  cook(inputCoreGroups) {
    return CADCone_async(this, null, function* () {
      const oc = yield CadLoader/* CadLoader.core */.i.core(this);
      const axis = (0,CadMath/* cadAxis */.Dh)(this.pv.axis);
      const api = this.pv.closed ? new oc.BRepPrimAPI_MakeCone_3(axis, this.pv.baseRadius, this.pv.topRadius, this.pv.height) : new oc.BRepPrimAPI_MakeCone_4(axis, this.pv.baseRadius, this.pv.topRadius, this.pv.height, this.pv.phi);
      const shape = (0,CadShapeCommon/* cadShapeTranslate */.ew)(api.Shape(), this.pv.center);
      api.delete();
      this.setCADShape(shape);
    });
  }
}

// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/nodes/sop/CADConvertDimension.ts
var CADConvertDimension = __webpack_require__(13567);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/core/geometry/modules/cad/CadObject.ts + 2 modules
var CadObject = __webpack_require__(48376);
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/core/geometry/modules/cad/utils/CadFilter.ts



function cadFilterObjects(cadObjects, type) {
  if (!cadObjects) {
    return void 0;
  }
  if (Type/* CoreType.isArray */.MR.isArray(type)) {
    return cadObjects.filter((o) => type.includes(o.type));
  } else {
    return cadObjects.filter((o) => o.type == type);
  }
}
function cadFilterShapes(cadObjects) {
  if (!cadObjects) {
    return void 0;
  }
  return cadObjects.filter((o) => CadCoreType/* CoreCadType.isShape */.c.isShape(o));
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/sop/CADCurve2DToSurface.ts








class CADCurve2DToSurfaceSopParamsConfig extends params_ParamsConfig/* NodeParamsConfig */.yI {
}
const CADCurve2DToSurface_ParamsConfig = new CADCurve2DToSurfaceSopParamsConfig();
class CADCurve2DToSurfaceSopNode extends _BaseCAD/* CADSopNode */.M {
  constructor() {
    super(...arguments);
    this.paramsConfig = CADCurve2DToSurface_ParamsConfig;
  }
  static type() {
    return Sop/* SopType.CAD_CURVE_2D_TO_SURFACE */.aB.CAD_CURVE_2D_TO_SURFACE;
  }
  initializeNode() {
    this.io.inputs.setCount(2);
  }
  cook(inputCoreGroups) {
    const oc = CadLoaderSync/* CadLoaderSync.oc */.T.oc();
    const inputCurves = cadFilterObjects(
      inputCoreGroups[0].cadObjects(),
      CadCommon/* CadGeometryType.CURVE_2D */.dT.CURVE_2D
    );
    const inputSurfaces = cadFilterShapes(inputCoreGroups[1].cadObjectsWithShape());
    const newObjects = [];
    if (inputCurves && inputSurfaces) {
      let i = 0;
      CadCommon/* CadGC.withGC */.Jd.withGC((r) => {
        for (const inputCurve of inputCurves) {
          const inputFaceObject = inputSurfaces[i] || inputSurfaces[inputSurfaces.length - 1];
          const shape = inputFaceObject.cadGeometry();
          const curve = inputCurve.cadGeometry();
          const curveHandle = r(new oc.Handle_Geom2d_Curve_2(curve));
          const findSurface = r(new oc.BRepLib_FindSurface_2(shape, 0, false, false));
          const surfaceHandle = findSurface.Surface();
          const api = r(new oc.BRepBuilderAPI_MakeEdge_30(curveHandle, surfaceHandle));
          if (api.IsDone()) {
            const edge = api.Edge();
            const result = oc.BRepLib.BuildCurves3d_2(edge);
            if (result) {
              newObjects.push(new CadObject/* CadObject */.K(edge, CadCommon/* CadGeometryType.EDGE */.dT.EDGE));
            }
          }
          i++;
        }
      });
    }
    this.setCADObjects(newObjects);
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/sop/CADCurveFromPoints.ts








class CADCurveFromPointsSopParamsConfig extends params_ParamsConfig/* NodeParamsConfig */.yI {
}
const CADCurveFromPoints_ParamsConfig = new CADCurveFromPointsSopParamsConfig();
class CADCurveFromPointsSopNode extends _BaseCAD/* CADSopNode */.M {
  constructor() {
    super(...arguments);
    this.paramsConfig = CADCurveFromPoints_ParamsConfig;
  }
  static type() {
    return Sop/* SopType.CAD_CURVE_FROM_POINTS */.aB.CAD_CURVE_FROM_POINTS;
  }
  initializeNode() {
    this.io.inputs.setCount(1);
  }
  cook(inputCoreGroups) {
    const objects = inputCoreGroups[0].cadObjects();
    const vertices = [];
    if (objects) {
      for (const object of objects) {
        if (CadCoreType/* CoreCadType.isVertex */.c.isVertex(object)) {
          vertices.push(object.cadGeometry());
        }
      }
    }
    if (vertices.length >= 3) {
      const oc = CadLoaderSync/* CadLoaderSync.oc */.T.oc();
      CadCommon/* CadGC.withGC */.Jd.withGC((r) => {
        const positions = r(new oc.TColgp_Array1OfPnt_2(0, vertices.length - 1));
        const points = [];
        let index = 0;
        for (const vertex of vertices) {
          const point = oc.BRep_Tool.Pnt(vertex);
          points.push(point);
          positions.SetValue(index, point);
          index++;
        }
        const _createBezier = () => {
          const curve = new oc.Geom_BezierCurve_1(positions);
          const edge2 = (0,CadEdge/* cadEdgeCreate */.Ll)(oc, curve);
          return edge2;
        };
        const createFunction = _createBezier;
        const edge = createFunction();
        for (const point of points) {
          point.delete();
        }
        if (edge) {
          this.setCADShape(edge);
        } else {
          this.setCADObjects([]);
        }
      });
    } else {
      this.setCADObjects([]);
    }
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/sop/CADCurveFromPoints2D.ts






class CADCurveFromPoints2DSopParamsConfig extends params_ParamsConfig/* NodeParamsConfig */.yI {
}
const CADCurveFromPoints2D_ParamsConfig = new CADCurveFromPoints2DSopParamsConfig();
class CADCurveFromPoints2DSopNode extends _BaseCAD/* CADSopNode */.M {
  constructor() {
    super(...arguments);
    this.paramsConfig = CADCurveFromPoints2D_ParamsConfig;
  }
  static type() {
    return Sop/* SopType.CAD_CURVE_FROM_POINTS_2D */.aB.CAD_CURVE_FROM_POINTS_2D;
  }
  initializeNode() {
    this.io.inputs.setCount(1);
  }
  cook(inputCoreGroups) {
    const cadObjects = inputCoreGroups[0].cadObjects();
    const points = [];
    if (cadObjects) {
      for (const object of cadObjects) {
        if (CadCoreType/* CoreCadType.isPoint2d */.c.isPoint2d(object)) {
          points.push(object.cadGeometry());
        }
      }
    }
    if (points.length >= 3) {
      const oc = CadLoaderSync/* CadLoaderSync.oc */.T.oc();
      const positions = new oc.TColgp_Array1OfPnt2d_2(0, points.length - 1);
      let index = 0;
      for (const point of points) {
        positions.SetValue(index, point);
        index++;
      }
      const curve = new oc.Geom2d_BezierCurve_1(positions);
      this.setCADGeom2dCurve(curve);
    } else {
      this.setCADObjects([]);
    }
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/sop/CADCurveTrim.ts










const v0 = (0,CadCommon/* _createCadNumberHandle */.IV)();
const v1 = (0,CadCommon/* _createCadNumberHandle */.IV)();
class CADCurveTrimSopParamsConfig extends params_ParamsConfig/* NodeParamsConfig */.yI {
  constructor() {
    super(...arguments);
    /** @param min */
    this.min = params_ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(0, {
      range: [0, 1],
      rangeLocked: [false, false],
      step: CadConstant/* step */.Nb
    });
    /** @param max */
    this.max = params_ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(1, {
      range: [0, 1],
      rangeLocked: [false, false],
      step: CadConstant/* step */.Nb
    });
  }
}
const CADCurveTrim_ParamsConfig = new CADCurveTrimSopParamsConfig();
class CADCurveTrimSopNode extends _BaseCAD/* CADSopNode */.M {
  constructor() {
    super(...arguments);
    this.paramsConfig = CADCurveTrim_ParamsConfig;
  }
  static type() {
    return Sop/* SopType.CAD_CURVE_TRIM */.aB.CAD_CURVE_TRIM;
  }
  initializeNode() {
    this.io.inputs.setCount(1);
  }
  cook(inputCoreGroups) {
    const oc = CadLoaderSync/* CadLoaderSync.oc */.T.oc();
    const inputCoreGroup = inputCoreGroups[0];
    const inputObjects = inputCoreGroup.cadObjects();
    const newObjects = [];
    if (inputObjects) {
      CadCommon/* CadGC.withGC */.Jd.withGC((r) => {
        for (const inputObject of inputObjects) {
          if (CadCoreType/* CoreCadType.isGeom2dCurve */.c.isGeom2dCurve(inputObject)) {
            const curve = inputObject.cadGeometry();
            const handle = r(new oc.Handle_Geom2d_Curve_2(curve));
            const trimmedCurve = new oc.Geom2d_TrimmedCurve(handle, this.pv.min, this.pv.max, true, true);
            newObjects.push(new CadObject/* CadObject */.K(trimmedCurve, CadCommon/* CadGeometryType.CURVE_2D */.dT.CURVE_2D));
          } else if (CadCoreType/* CoreCadType.isEdge */.c.isEdge(inputObject)) {
            const edge = inputObject.cadGeometry();
            oc.BRep_Tool.Range_1(edge, v0, v1);
            const handle = oc.BRep_Tool.Curve_2(edge, v0.current, v1.current);
            const trimmedCurve = new oc.Geom_TrimmedCurve(handle, this.pv.min, this.pv.max, true, true);
            const newEdge = (0,CadEdge/* cadEdgeCreate */.Ll)(oc, trimmedCurve);
            newObjects.push(new CadObject/* CadObject */.K(newEdge, CadCommon/* CadGeometryType.EDGE */.dT.EDGE));
          }
        }
      });
    }
    this.setCADObjects(newObjects);
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/sop/CADEllipse.ts

var CADEllipse_async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step2(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step2(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step2 = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step2((generator = generator.apply(__this, __arguments)).next());
  });
};







class CADEllipseSopParamsConfig extends params_ParamsConfig/* NodeParamsConfig */.yI {
  constructor() {
    super(...arguments);
    /** @param major radius */
    this.majorRadius = params_ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(1, {
      range: [0, 2],
      rangeLocked: [true, false],
      step: CadConstant/* step */.Nb
    });
    /** @param minor radius */
    this.minorRadius = params_ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(1, {
      range: [0, 2],
      rangeLocked: [true, false],
      step: CadConstant/* step */.Nb
    });
    /** @param axis */
    this.axis = params_ParamsConfig/* ParamConfig.VECTOR3 */.XC.VECTOR3([0, 1, 0]);
    /** @param center */
    this.center = params_ParamsConfig/* ParamConfig.VECTOR3 */.XC.VECTOR3([0, 0, 0]);
  }
}
const CADEllipse_ParamsConfig = new CADEllipseSopParamsConfig();
class CADEllipseSopNode extends _BaseCAD/* CADSopNode */.M {
  constructor() {
    super(...arguments);
    this.paramsConfig = CADEllipse_ParamsConfig;
  }
  static type() {
    return Sop/* SopType.CAD_ELLIPSE */.aB.CAD_ELLIPSE;
  }
  cook(inputCoreGroups) {
    return CADEllipse_async(this, null, function* () {
      const oc = yield CadLoader/* CadLoader.core */.i.core(this);
      const axis1 = CadLoaderSync/* CadLoaderSync.gp_Ax1 */.T.gp_Ax1;
      const dir = CadLoaderSync/* CadLoaderSync.gp_Dir */.T.gp_Dir;
      dir.SetCoord_2(this.pv.axis.x, this.pv.axis.y, this.pv.axis.z);
      axis1.SetDirection(dir);
      const axis = CadLoaderSync/* CadLoaderSync.gp_Ax2 */.T.gp_Ax2;
      axis.SetAxis(axis1);
      const majorRadius = Math.max(this.pv.majorRadius, this.pv.minorRadius);
      const minorRadius = Math.min(this.pv.majorRadius, this.pv.minorRadius);
      const ellipse = new oc.Geom_Ellipse_2(axis, majorRadius, minorRadius);
      const t = CadLoaderSync/* CadLoaderSync.gp_Vec */.T.gp_Vec;
      t.SetCoord_2(this.pv.center.x, this.pv.center.y, this.pv.center.z);
      ellipse.Translate_1(t);
      const edge = (0,CadEdge/* cadEdgeCreate */.Ll)(oc, ellipse);
      this.setCADShape(edge);
    });
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/sop/CADEllipse2D.ts

var CADEllipse2D_async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step2(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step2(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step2 = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step2((generator = generator.apply(__this, __arguments)).next());
  });
};







class CADEllipse2DSopParamsConfig extends params_ParamsConfig/* NodeParamsConfig */.yI {
  constructor() {
    super(...arguments);
    /** @param major radius */
    this.majorRadius = params_ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(1, {
      range: [0, 2],
      rangeLocked: [true, false],
      step: CadConstant/* step */.Nb
    });
    /** @param minor radius */
    this.minorRadius = params_ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(1, {
      range: [0, 2],
      rangeLocked: [true, false],
      step: CadConstant/* step */.Nb
    });
    /** @param axis */
    // axis = ParamConfig.VECTOR2([0, 1]);
    /** @param center */
    this.center = params_ParamsConfig/* ParamConfig.VECTOR2 */.XC.VECTOR2([0, 0]);
  }
}
const CADEllipse2D_ParamsConfig = new CADEllipse2DSopParamsConfig();
class CADEllipse2DSopNode extends _BaseCAD/* CADSopNode */.M {
  constructor() {
    super(...arguments);
    this.paramsConfig = CADEllipse2D_ParamsConfig;
  }
  static type() {
    return Sop/* SopType.CAD_ELLIPSE_2D */.aB.CAD_ELLIPSE_2D;
  }
  cook(inputCoreGroups) {
    return CADEllipse2D_async(this, null, function* () {
      const oc = yield CadLoader/* CadLoader.core */.i.core(this);
      CadCommon/* CadGC.withGC */.Jd.withGC((r) => {
        const axis = r(new oc.gp_Ax22d_1());
        const majorRadius = Math.max(this.pv.majorRadius, this.pv.minorRadius);
        const minorRadius = Math.min(this.pv.majorRadius, this.pv.minorRadius);
        const ellipse = new oc.Geom2d_Ellipse_3(axis, majorRadius, minorRadius);
        (0,CadGeom2dCurve/* cadGeom2dCurveTranslate */.H5)(ellipse, this.pv.center);
        this.setCADGeom2dCurve(ellipse);
      });
    });
  }
}

// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/nodes/sop/CADExporterSTEP.ts + 1 modules
var CADExporterSTEP = __webpack_require__(25598);
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/sop/CADExtrude.ts








class CADExtrudeSopParamsConfig extends params_ParamsConfig/* NodeParamsConfig */.yI {
  constructor() {
    super(...arguments);
    /** @param direction */
    this.dir = params_ParamsConfig/* ParamConfig.VECTOR3 */.XC.VECTOR3([0, 1, 0]);
    /** @param height */
    this.height = params_ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(1, {
      range: [-10, 10],
      rangeLocked: [false, false]
    });
    /** @param create caps */
    this.cap = params_ParamsConfig/* ParamConfig.BOOLEAN */.XC.BOOLEAN(1);
    /** @param convert caps to faces */
    this.capsAsFaces = params_ParamsConfig/* ParamConfig.BOOLEAN */.XC.BOOLEAN(1);
  }
}
const CADExtrude_ParamsConfig = new CADExtrudeSopParamsConfig();
class CADExtrudeSopNode extends _BaseCAD/* CADSopNode */.M {
  constructor() {
    super(...arguments);
    this.paramsConfig = CADExtrude_ParamsConfig;
  }
  static type() {
    return Sop/* SopType.CAD_EXTRUDE */.aB.CAD_EXTRUDE;
  }
  initializeNode() {
    this.io.inputs.setCount(1);
  }
  cook(inputCoreGroups) {
    const inputCoreGroup = inputCoreGroups[0];
    const extrudeDir = CadLoaderSync/* CadLoaderSync.gp_Vec */.T.gp_Vec;
    extrudeDir.SetCoord_2(
      this.pv.dir.x * this.pv.height,
      this.pv.dir.y * this.pv.height,
      this.pv.dir.z * this.pv.height
    );
    const newObjects = [];
    const inputObjects = inputCoreGroup.cadObjects();
    if (inputObjects) {
      const oc = CadLoaderSync/* CadLoaderSync.oc */.T.oc();
      CadCommon/* CadGC.withGC */.Jd.withGC((r) => {
        const options = {
          oc,
          r,
          newObjects,
          extrudeDir
        };
        for (const object of inputObjects) {
          this._processObject(object, options);
        }
      });
    }
    this.setCADObjects(newObjects);
  }
  _processObject(object, options) {
    const type = object.type;
    switch (type) {
      case CadCommon/* CadGeometryType.VERTEX */.dT.VERTEX: {
        return this._processVertexObject(object, options);
      }
      case CadCommon/* CadGeometryType.EDGE */.dT.EDGE: {
        return this._processEdgeObject(object, options);
      }
      case CadCommon/* CadGeometryType.WIRE */.dT.WIRE: {
        return this._processWireObject(object, options);
      }
      case CadCommon/* CadGeometryType.FACE */.dT.FACE: {
        return this._processFaceObject(object, options);
      }
      case CadCommon/* CadGeometryType.SHELL */.dT.SHELL: {
        return this._processShellObject(object, options);
      }
      default: {
        return options.newObjects.push(object);
      }
    }
  }
  _processVertexObject(object, options) {
    const { oc, r, newObjects, extrudeDir } = options;
    const vertex = object.cadGeometry();
    const prismApi = r(new oc.BRepPrimAPI_MakePrism_1(vertex, extrudeDir, false, true));
    const prism = prismApi.Shape();
    const type = (0,CadCommon/* cadGeometryTypeFromShape */.dJ)(oc, prism);
    if (type) {
      const newObject = new CadObject/* CadObject */.K(prism, type);
      newObjects.push(newObject);
    }
  }
  _processEdgeObject(object, options) {
    const { oc, r, extrudeDir, newObjects } = options;
    const edge = object.cadGeometry();
    const api = r(new oc.BRepPrimAPI_MakePrism_1(edge, extrudeDir, false, true));
    const shapes = [api.Shape()];
    for (const shape of shapes) {
      const type = (0,CadCommon/* cadGeometryTypeFromShape */.dJ)(oc, shape);
      if (type) {
        const newObject = new CadObject/* CadObject */.K(shape, type);
        newObjects.push(newObject);
      }
    }
  }
  _processWireObject(object, options) {
    const wire = object.cadGeometry();
    this._processWire(wire, options);
  }
  _processWire(wire, options) {
    const { oc, r, extrudeDir, newObjects } = options;
    const api = r(new oc.BRepPrimAPI_MakePrism_1(wire, extrudeDir, false, true));
    const shapes = [api.Shape()];
    if ((0,Type/* isBooleanTrue */.bI)(this.pv.cap)) {
      const addCap = (capShape, invert) => {
        if (!capShape) {
          return;
        }
        if ((0,CadCommon/* cadGeometryTypeFromShape */.dJ)(oc, capShape) == CadCommon/* CadGeometryType.WIRE */.dT.WIRE) {
          const wire2 = (0,CadCommon/* cadDowncast */.wK)(oc, capShape);
          if ((0,Type/* isBooleanTrue */.bI)(this.pv.capsAsFaces)) {
            const capApi = r(new oc.BRepBuilderAPI_MakeFace_15(wire2, true));
            if (capApi.IsDone()) {
              const face = capApi.Face();
              shapes.push(invert ? face.Complemented() : face);
            }
          } else {
            shapes.push(capShape);
          }
        }
      };
      addCap(api.FirstShape(), false);
      addCap(api.LastShape(), true);
    }
    for (const shape of shapes) {
      const type = (0,CadCommon/* cadGeometryTypeFromShape */.dJ)(oc, shape);
      if (type) {
        const newObject = new CadObject/* CadObject */.K(shape, type);
        newObjects.push(newObject);
      }
    }
  }
  _processFaceObject(object, options) {
    this._processFace(object.cadGeometry(), options);
  }
  _processFace(face, options) {
    const { oc, r, newObjects, extrudeDir } = options;
    const api = r(new oc.BRepPrimAPI_MakePrism_1(face, extrudeDir, false, true));
    const shapes = [api.Shape()];
    for (const shape of shapes) {
      const type = (0,CadCommon/* cadGeometryTypeFromShape */.dJ)(oc, shape);
      if (type) {
        const newObject = new CadObject/* CadObject */.K(shape, type);
        newObjects.push(newObject);
      }
    }
  }
  _processShellObject(object, options) {
    const { oc, r, newObjects, extrudeDir } = options;
    const shell = object.cadGeometry();
    const prismApi = r(new oc.BRepPrimAPI_MakePrism_1(shell, extrudeDir, false, true));
    const prism = prismApi.Shape();
    const type = (0,CadCommon/* cadGeometryTypeFromShape */.dJ)(oc, prism);
    if (type) {
      const newObject = new CadObject/* CadObject */.K(prism, type);
      newObjects.push(newObject);
    }
  }
}

// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/nodes/sop/CADFileSTEP.ts + 1 modules
var CADFileSTEP = __webpack_require__(76777);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/nodes/sop/CADFillet.ts
var CADFillet = __webpack_require__(49121);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/nodes/sop/CADGroup.ts + 5 modules
var CADGroup = __webpack_require__(3195);
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/sop/CADLoft.ts










class CADLoftSopParamsConfig extends params_ParamsConfig/* NodeParamsConfig */.yI {
  constructor() {
    super(...arguments);
    /** @param create solid */
    this.solid = params_ParamsConfig/* ParamConfig.BOOLEAN */.XC.BOOLEAN(1);
  }
  /** @param create caps */
  // cap = ParamConfig.BOOLEAN(1);
}
const CADLoft_ParamsConfig = new CADLoftSopParamsConfig();
class CADLoftSopNode extends _BaseCAD/* CADSopNode */.M {
  constructor() {
    super(...arguments);
    this.paramsConfig = CADLoft_ParamsConfig;
  }
  static type() {
    return Sop/* SopType.CAD_LOFT */.aB.CAD_LOFT;
  }
  initializeNode() {
    this.io.inputs.setCount(1);
  }
  cook(inputCoreGroups) {
    const oc = CadLoaderSync/* CadLoaderSync.oc */.T.oc();
    const inputCoreGroup = inputCoreGroups[0];
    const newObjects = [];
    const inputObjects = cadFilterObjects(inputCoreGroup.cadObjects(), [
      CadCommon/* CadGeometryType.VERTEX */.dT.VERTEX,
      // CadGeometryType.EDGE,
      CadCommon/* CadGeometryType.WIRE */.dT.WIRE
      // CadGeometryType.FACE,
      // CadGeometryType.SHELL,
    ]);
    if (inputObjects && inputObjects.length != 0) {
      CadCommon/* CadGC.withGC */.Jd.withGC((r) => {
        const isSolid = (0,Type/* isBooleanTrue */.bI)(this.pv.solid);
        const ruled = true;
        const precision = oc.Precision.Approximation();
        const api = r(new oc.BRepOffsetAPI_ThruSections(isSolid, ruled, precision));
        for (const inputObject of inputObjects) {
          if (CadCoreType/* CoreCadType.isWire */.c.isWire(inputObject)) {
            api.AddWire((0,CadCommon/* cadDowncast */.wK)(oc, inputObject.cadGeometry()));
          } else if (CadCoreType/* CoreCadType.isVertex */.c.isVertex(inputObject)) {
            api.AddVertex((0,CadCommon/* cadDowncast */.wK)(oc, inputObject.cadGeometry()));
          }
        }
        const shape = api.Shape();
        const type = (0,CadCommon/* cadGeometryTypeFromShape */.dJ)(oc, shape);
        if (type) {
          const newObject = new CadObject/* CadObject */.K(shape, type);
          newObjects.push(newObject);
        }
      });
    }
    this.setCADObjects(newObjects);
  }
}

// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/nodes/sop/CADMirror.ts
var CADMirror = __webpack_require__(9345);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/core/geometry/modules/cad/toObject3D/CadWire.ts
var CadWire = __webpack_require__(25191);
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/sop/CADPipe.ts











class CADPipeSopParamsConfig extends params_ParamsConfig/* NodeParamsConfig */.yI {
  constructor() {
    super(...arguments);
    /** @param create caps */
    this.cap = params_ParamsConfig/* ParamConfig.BOOLEAN */.XC.BOOLEAN(1);
    /** @param convert caps to faces */
    this.capsAsFaces = params_ParamsConfig/* ParamConfig.BOOLEAN */.XC.BOOLEAN(1);
  }
}
const CADPipe_ParamsConfig = new CADPipeSopParamsConfig();
class CADPipeSopNode extends _BaseCAD/* CADSopNode */.M {
  constructor() {
    super(...arguments);
    this.paramsConfig = CADPipe_ParamsConfig;
  }
  static type() {
    return Sop/* SopType.CAD_PIPE */.aB.CAD_PIPE;
  }
  initializeNode() {
    this.io.inputs.setCount(2);
  }
  cook(inputCoreGroups) {
    const oc = CadLoaderSync/* CadLoaderSync.oc */.T.oc();
    const profilesCoreGroup = inputCoreGroups[0];
    const pathsCoreGroup = inputCoreGroups[1];
    const newObjects = [];
    const profilesObjects = cadFilterObjects(profilesCoreGroup.cadObjects(), [
      CadCommon/* CadGeometryType.VERTEX */.dT.VERTEX,
      CadCommon/* CadGeometryType.EDGE */.dT.EDGE,
      CadCommon/* CadGeometryType.WIRE */.dT.WIRE,
      CadCommon/* CadGeometryType.FACE */.dT.FACE,
      CadCommon/* CadGeometryType.SHELL */.dT.SHELL
    ]);
    const pathObjects = cadFilterObjects(pathsCoreGroup.cadObjects(), [CadCommon/* CadGeometryType.EDGE */.dT.EDGE, CadCommon/* CadGeometryType.WIRE */.dT.WIRE]);
    if (profilesObjects && pathObjects) {
      CadCommon/* CadGC.withGC */.Jd.withGC((r) => {
        const minObjectsCount = Math.min(profilesObjects.length, pathObjects.length);
        for (let i = 0; i < minObjectsCount; i++) {
          const profileObject = profilesObjects[i];
          const pathObject = pathObjects[i];
          const wirePath = CadCoreType/* CoreCadType.isWire */.c.isWire(pathObject) ? pathObject.cadGeometry() : (0,CadWire/* cadWireFromEdge */.Gi)(oc, pathObject.cadGeometry());
          const api = r(new oc.BRepOffsetAPI_MakePipe_1(wirePath, profileObject.cadGeometry()));
          if (api.IsDone()) {
            const shapes = [api.Shape()];
            if ((0,Type/* isBooleanTrue */.bI)(this.pv.cap)) {
              const addCap = (capShape, invert) => {
                if (!capShape) {
                  return;
                }
                if ((0,CadCommon/* cadGeometryTypeFromShape */.dJ)(oc, capShape) == CadCommon/* CadGeometryType.WIRE */.dT.WIRE) {
                  const wire = (0,CadCommon/* cadDowncast */.wK)(oc, capShape);
                  if ((0,Type/* isBooleanTrue */.bI)(this.pv.capsAsFaces)) {
                    const capApi = r(new oc.BRepBuilderAPI_MakeFace_15(wire, true));
                    if (capApi.IsDone()) {
                      const face = capApi.Face();
                      shapes.push(invert ? face.Complemented() : face);
                    }
                  } else {
                    shapes.push(capShape);
                  }
                }
              };
              addCap(api.FirstShape(), true);
              addCap(api.LastShape(), false);
            }
            for (const shape of shapes) {
              const type = (0,CadCommon/* cadGeometryTypeFromShape */.dJ)(oc, shape);
              if (type) {
                const newObject = new CadObject/* CadObject */.K(shape, type);
                newObjects.push(newObject);
              }
            }
          }
        }
      });
    }
    this.setCADObjects(newObjects);
  }
}

// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/core/geometry/modules/cad/toObject3D/CadVertex.ts
var CadVertex = __webpack_require__(83255);
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/sop/CADPoint.ts

var CADPoint_async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};





class CADPointSopParamsConfig extends params_ParamsConfig/* NodeParamsConfig */.yI {
  constructor() {
    super(...arguments);
    /** @param translate */
    this.center = params_ParamsConfig/* ParamConfig.VECTOR3 */.XC.VECTOR3([0, 0, 0]);
  }
}
const CADPoint_ParamsConfig = new CADPointSopParamsConfig();
class CADPointSopNode extends _BaseCAD/* CADSopNode */.M {
  constructor() {
    super(...arguments);
    this.paramsConfig = CADPoint_ParamsConfig;
  }
  static type() {
    return Sop/* SopType.CAD_POINT */.aB.CAD_POINT;
  }
  cook(inputCoreGroups) {
    return CADPoint_async(this, null, function* () {
      const oc = yield CadLoader/* CadLoader.core */.i.core(this);
      const vertex = (0,CadVertex/* cadVertexCreate */.SW)(oc, this.pv.center);
      this.setCADShape(vertex);
    });
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/sop/CADPoint2D.ts

var CADPoint2D_async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};






class CADPoint2DSopParamsConfig extends params_ParamsConfig/* NodeParamsConfig */.yI {
  constructor() {
    super(...arguments);
    /** @param center */
    this.center = params_ParamsConfig/* ParamConfig.VECTOR2 */.XC.VECTOR2([0, 0]);
  }
}
const CADPoint2D_ParamsConfig = new CADPoint2DSopParamsConfig();
class CADPoint2DSopNode extends _BaseCAD/* CADSopNode */.M {
  constructor() {
    super(...arguments);
    this.paramsConfig = CADPoint2D_ParamsConfig;
  }
  static type() {
    return Sop/* SopType.CAD_POINT_2D */.aB.CAD_POINT_2D;
  }
  cook() {
    return CADPoint2D_async(this, null, function* () {
      const oc = yield CadLoader/* CadLoader.core */.i.core(this);
      const point = new oc.gp_Pnt2d_3(this.pv.center.x, this.pv.center.y);
      const cadObject = new CadObject/* CadObject */.K(point, CadCommon/* CadGeometryType.POINT_2D */.dT.POINT_2D);
      this.setCADObject(cadObject);
    });
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/sop/CADPointsFromCurve.ts











const CADPointsFromCurve_v0 = (0,CadCommon/* _createCadNumberHandle */.IV)();
const CADPointsFromCurve_v1 = (0,CadCommon/* _createCadNumberHandle */.IV)();
const tmpV3 = new three_module.Vector3();
class CADPointsFromCurveSopParamsConfig extends params_ParamsConfig/* NodeParamsConfig */.yI {
  constructor() {
    super(...arguments);
    /** @param points count */
    this.count = params_ParamsConfig/* ParamConfig.INTEGER */.XC.INTEGER(1, {
      range: [0, 100],
      rangeLocked: [true, false],
      step: CadConstant/* step */.Nb
    });
    /** @param min */
    this.min = params_ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(0, {
      range: [0, 1],
      rangeLocked: [false, false],
      step: CadConstant/* step */.Nb
    });
    /** @param max */
    this.max = params_ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(1, {
      range: [0, 1],
      rangeLocked: [false, false],
      step: CadConstant/* step */.Nb
    });
  }
}
const CADPointsFromCurve_ParamsConfig = new CADPointsFromCurveSopParamsConfig();
class CADPointsFromCurveSopNode extends _BaseCAD/* CADSopNode */.M {
  constructor() {
    super(...arguments);
    this.paramsConfig = CADPointsFromCurve_ParamsConfig;
  }
  static type() {
    return Sop/* SopType.CAD_POINTS_FROM_CURVE */.aB.CAD_POINTS_FROM_CURVE;
  }
  initializeNode() {
    this.io.inputs.setCount(1);
  }
  cook(inputCoreGroups) {
    const oc = CadLoaderSync/* CadLoaderSync.oc */.T.oc();
    const inputCoreGroup = inputCoreGroups[0];
    const inputObjects = inputCoreGroup.cadObjects();
    const newObjects = [];
    const { min, max, count } = this.pv;
    const delta = max - min;
    if (inputObjects) {
      CadCommon/* CadGC.withGC */.Jd.withGC((r) => {
        for (const inputObject of inputObjects) {
          if (CadCoreType/* CoreCadType.isGeom2dCurve */.c.isGeom2dCurve(inputObject)) {
            const curve = inputObject.cadGeometry();
            for (let i = 0; i < count; i++) {
              const d0 = min + delta * (i / count);
              const pt = r(new oc.gp_Pnt2d_1());
              curve.D0(d0, pt);
              newObjects.push(new CadObject/* CadObject */.K(pt, CadCommon/* CadGeometryType.POINT_2D */.dT.POINT_2D));
            }
          } else if (CadCoreType/* CoreCadType.isEdge */.c.isEdge(inputObject)) {
            const edge = inputObject.cadGeometry();
            oc.BRep_Tool.Range_1(edge, CADPointsFromCurve_v0, CADPointsFromCurve_v1);
            const handle = oc.BRep_Tool.Curve_2(edge, CADPointsFromCurve_v0.current, CADPointsFromCurve_v1.current);
            const curve = handle.get();
            const pt = r(new oc.gp_Pnt_1());
            for (let i = 0; i < count; i++) {
              const d0 = min + delta * (i / count);
              curve.D0(d0, pt);
              tmpV3.set(pt.X(), pt.Y(), pt.Z());
              const vertex = (0,CadVertex/* cadVertexCreate */.SW)(oc, tmpV3);
              newObjects.push(new CadObject/* CadObject */.K(vertex, CadCommon/* CadGeometryType.VERTEX */.dT.VERTEX));
            }
          }
        }
      });
    }
    this.setCADObjects(newObjects);
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/sop/CADRectangle.ts

var CADRectangle_async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step2(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step2(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step2 = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step2((generator = generator.apply(__this, __arguments)).next());
  });
};








const FILLET_RADIUS_SAFETY_MARGIN = 0.01;
const HALF_PI = 0.5 * Math.PI;
class CADRectangleSopParamsConfig extends params_ParamsConfig/* NodeParamsConfig */.yI {
  constructor() {
    super(...arguments);
    /** @param size */
    this.size = params_ParamsConfig/* ParamConfig.VECTOR2 */.XC.VECTOR2([1, 1]);
    /** @param center */
    this.center = params_ParamsConfig/* ParamConfig.VECTOR3 */.XC.VECTOR3([0, 0, 0]);
    /** @param fillet radius */
    this.filletRadius = params_ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(0.1, {
      range: [0, 1],
      rangeLocked: [true, false],
      step: CadConstant/* step */.Nb
    });
  }
}
const CADRectangle_ParamsConfig = new CADRectangleSopParamsConfig();
class CADRectangleSopNode extends _BaseCAD/* CADSopNode */.M {
  constructor() {
    super(...arguments);
    this.paramsConfig = CADRectangle_ParamsConfig;
  }
  static type() {
    return Sop/* SopType.CAD_RECTANGLE */.aB.CAD_RECTANGLE;
  }
  cook(inputCoreGroups) {
    return CADRectangle_async(this, null, function* () {
      const oc = yield CadLoader/* CadLoader.core */.i.core(this);
      CadCommon/* CadGC.withGC */.Jd.withGC((r) => {
        const w = this.pv.size.x;
        const h = this.pv.size.y;
        const minDim = Math.min(w, h);
        const rad = Math.min(this.pv.filletRadius, minDim / 2 - FILLET_RADIUS_SAFETY_MARGIN);
        const x = w / 2 - rad;
        const z = h / 2 - rad;
        const arc0 = _createArc(oc, r, x, z, rad, 3);
        const arc1 = _createArc(oc, r, x, -z, rad, 0);
        const arc2 = _createArc(oc, r, -x, -z, rad, 1);
        const arc3 = _createArc(oc, r, -x, z, rad, 2);
        const edgesCount = 8;
        const linesCount = 4;
        const edges = r(new oc.TopTools_Array1OfShape_2(0, edgesCount - 1));
        const vertices = r(new oc.TopTools_Array1OfShape_2(0, 7));
        edges.SetValue(0, arc0.edge);
        edges.SetValue(2, arc1.edge);
        edges.SetValue(4, arc2.edge);
        edges.SetValue(6, arc3.edge);
        vertices.SetValue(0, arc0.vertex1);
        vertices.SetValue(1, arc1.vertex0);
        vertices.SetValue(2, arc1.vertex1);
        vertices.SetValue(3, arc2.vertex0);
        vertices.SetValue(4, arc2.vertex1);
        vertices.SetValue(5, arc3.vertex0);
        vertices.SetValue(6, arc3.vertex1);
        vertices.SetValue(7, arc0.vertex0);
        for (let i = 0; i < linesCount; i += 1) {
          const startVertex = oc.TopoDS.Vertex_2(vertices.Value(i * 2));
          const endVertex = oc.TopoDS.Vertex_2(vertices.Value(i * 2 + 1));
          const edgeApi = r(new oc.BRepBuilderAPI_MakeEdge_2(startVertex, endVertex));
          const edge = edgeApi.Edge();
          edges.SetValue(i * 2 + 1, edge);
        }
        const wireApi = r(new oc.BRepBuilderAPI_MakeWire_1());
        for (let i = 0; i < edgesCount; i++) {
          wireApi.Add_1(oc.TopoDS.Edge_2(edges.Value(i)));
        }
        const wire = wireApi.Wire();
        const shape = (0,CadShapeCommon/* cadShapeTranslate */.ew)(wire, this.pv.center);
        this.setCADShape(shape);
      });
    });
  }
}
function _createArc(oc, r, x, z, radius, angleIncrement) {
  const dir = CadLoaderSync/* CadLoaderSync.gp_Dir */.T.gp_Dir;
  dir.SetCoord_2(0, 1, 0);
  const axis = r(new oc.gp_Ax2_1());
  axis.SetDirection(dir);
  const offset = r(new oc.gp_Vec_4(x, 0, z));
  axis.Translate_1(offset);
  const circle = new oc.gp_Circ_2(axis, radius);
  const angleStart = angleIncrement * HALF_PI;
  const angleEnd = (angleIncrement + 1) * HALF_PI;
  const api = r(new oc.BRepBuilderAPI_MakeEdge_9(circle, angleStart, angleEnd));
  const edge = api.Edge();
  return {
    edge,
    vertex0: api.Vertex1(),
    vertex1: api.Vertex2()
  };
}

// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/core/geometry/modules/cad/CadTraverse.ts
var CadTraverse = __webpack_require__(35546);
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/sop/CADRevolution.ts












class CADRevolutionSopParamsConfig extends params_ParamsConfig/* NodeParamsConfig */.yI {
  constructor() {
    super(...arguments);
    /** @param axis */
    this.axis = params_ParamsConfig/* ParamConfig.VECTOR3 */.XC.VECTOR3([0, 1, 0]);
    /** @param closed */
    this.closed = params_ParamsConfig/* ParamConfig.BOOLEAN */.XC.BOOLEAN(true);
    /** @param thetaMin */
    // thetaMin = ParamConfig.FLOAT(0, {
    // 	range: [0, 2 * Math.PI],
    // 	rangeLocked: [false, false],
    // 	step,
    // 	visibleIf: {closed: false},
    // });
    /** @param thetaMax */
    // thetaMax = ParamConfig.FLOAT(`2*$PI`, {
    // 	range: [0, 2 * Math.PI],
    // 	rangeLocked: [false, false],
    // 	step,
    // 	visibleIf: {closed: false},
    // });
    /** @param phi */
    this.phi = params_ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(`2*$PI`, {
      range: [0, 2 * Math.PI],
      rangeLocked: [true, true],
      step: CadConstant/* step */.Nb,
      visibleIf: { closed: false }
    });
  }
}
const CADRevolution_ParamsConfig = new CADRevolutionSopParamsConfig();
class CADRevolutionSopNode extends _BaseCAD/* CADSopNode */.M {
  constructor() {
    super(...arguments);
    this.paramsConfig = CADRevolution_ParamsConfig;
  }
  static type() {
    return Sop/* SopType.CAD_REVOLUTION */.aB.CAD_REVOLUTION;
  }
  initializeNode() {
    this.io.inputs.setCount(1);
  }
  cook(inputCoreGroups) {
    const oc = CadLoaderSync/* CadLoaderSync.oc */.T.oc();
    const coreGroup0 = inputCoreGroups[0];
    const newObjects = [];
    const axis = (0,CadMath/* cadAxis */.Dh)(this.pv.axis);
    const createRevolution = (edge) => {
      const handle = (0,CadEdge/* curveDataFromEdge */.Bc)(oc, edge).curveHandle;
      const api = new oc.BRepPrimAPI_MakeRevolution_6(axis, handle, this.pv.phi);
      const newShape = api.Shape();
      api.delete();
      const type = (0,CadCommon/* cadGeometryTypeFromShape */.dJ)(oc, newShape);
      if (type) {
        newObjects.push(new CadObject/* CadObject */.K(newShape, type));
      } else {
        console.log("no type", newShape);
      }
    };
    const inputObjects = coreGroup0.cadObjects();
    if (inputObjects) {
      for (const inputObject of inputObjects) {
        const type = inputObject.type;
        switch (type) {
          case CadCommon/* CadGeometryType.CURVE_2D */.dT.CURVE_2D: {
          }
          case CadCommon/* CadGeometryType.EDGE */.dT.EDGE: {
            if (CadCoreType/* CoreCadType.isEdge */.c.isEdge(inputObject)) {
              createRevolution(inputObject.cadGeometry());
            }
            break;
          }
          case CadCommon/* CadGeometryType.WIRE */.dT.WIRE: {
            if (CadCoreType/* CoreCadType.isWire */.c.isWire(inputObject)) {
              (0,CadTraverse/* traverseEdges */.y9)(oc, inputObject.cadGeometry(), (edge) => {
                createRevolution(edge);
              });
            }
            break;
          }
        }
      }
    }
    this.setCADObjects(newObjects);
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/sop/CADSegment.ts

var CADSegment_async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};









var SegmentMode = /* @__PURE__ */ ((SegmentMode2) => {
  SegmentMode2["FROM_PAIRS"] = "from pairs";
  SegmentMode2["LINK_ALL"] = "link all";
  return SegmentMode2;
})(SegmentMode || {});
const SEGMENT_MODES = ["from pairs" /* FROM_PAIRS */, "link all" /* LINK_ALL */];
class CADSegmentSopParamsConfig extends params_ParamsConfig/* NodeParamsConfig */.yI {
  constructor() {
    super(...arguments);
    /** @param mode */
    this.mode = params_ParamsConfig/* ParamConfig.INTEGER */.XC.INTEGER(SEGMENT_MODES.indexOf("link all" /* LINK_ALL */), {
      menu: {
        entries: SEGMENT_MODES.map((name, value) => ({ name, value }))
      }
    });
  }
}
const CADSegment_ParamsConfig = new CADSegmentSopParamsConfig();
class CADSegmentSopNode extends _BaseCAD/* CADSopNode */.M {
  constructor() {
    super(...arguments);
    this.paramsConfig = CADSegment_ParamsConfig;
  }
  static type() {
    return Sop/* SopType.CAD_SEGMENT */.aB.CAD_SEGMENT;
  }
  initializeNode() {
    this.io.inputs.setCount(1, 2);
  }
  cook(inputCoreGroups) {
    return CADSegment_async(this, null, function* () {
      const oc = yield CadLoader/* CadLoader.core */.i.core(this);
      const mode = SEGMENT_MODES[this.pv.mode];
      switch (mode) {
        case "from pairs" /* FROM_PAIRS */: {
          return this._createSegmentsFromPairs(oc, inputCoreGroups);
        }
        case "link all" /* LINK_ALL */: {
          return this._createSegmentsFromAll(oc, inputCoreGroups);
        }
      }
      Assert/* TypeAssert.unreachable */.f.unreachable(mode);
    });
  }
  _createSegmentsFromPairs(oc, inputCoreGroups) {
    const newObjects = [];
    const inputCoreGroup0 = inputCoreGroups[0];
    const inputCoreGroup1 = inputCoreGroups[1];
    if (!inputCoreGroup1) {
      this.states.error.set("input 1 required for this mode");
      return;
    }
    _createSegmentsFromVertexPairs(oc, inputCoreGroup0, inputCoreGroup1, newObjects);
    _createSegmentsFromPoint2DPairs(oc, inputCoreGroup0, inputCoreGroup1, newObjects);
    this.setCADObjects(newObjects);
  }
  _createSegmentsFromAll(oc, inputCoreGroups) {
    const newObjects = [];
    const inputCoreGroup0 = inputCoreGroups[0];
    const inputCoreGroup1 = inputCoreGroups[1];
    let vertexObjects = cadFilterObjects(inputCoreGroup0.cadObjects(), CadCommon/* CadGeometryType.VERTEX */.dT.VERTEX);
    let point2DObjects = cadFilterObjects(inputCoreGroup0.cadObjects(), CadCommon/* CadGeometryType.POINT_2D */.dT.POINT_2D);
    if (vertexObjects) {
      if (inputCoreGroup1) {
        const vertexObjects1 = cadFilterObjects(inputCoreGroup1.cadObjects(), CadCommon/* CadGeometryType.VERTEX */.dT.VERTEX);
        if (vertexObjects1) {
          vertexObjects = vertexObjects.concat(vertexObjects1);
        }
      }
      _createSegmentsFromAllVertices(oc, vertexObjects, newObjects);
    }
    if (point2DObjects) {
      if (inputCoreGroup1) {
        const pointObjects1 = cadFilterObjects(inputCoreGroup1.cadObjects(), CadCommon/* CadGeometryType.POINT_2D */.dT.POINT_2D);
        if (pointObjects1) {
          point2DObjects = point2DObjects.concat(pointObjects1);
        }
      }
      _createSegmentsFromAllPoint2D(oc, point2DObjects, newObjects);
    }
    this.setCADObjects(newObjects);
  }
}
function _createSegmentsFromAllVertices(oc, coreObjects, newObjects) {
  let previousVertexObject;
  for (const inputObject of coreObjects) {
    if (previousVertexObject) {
      newObjects.push(_createSegment(oc, previousVertexObject.cadGeometry(), inputObject.cadGeometry()));
    }
    previousVertexObject = inputObject;
  }
}
function _createSegmentsFromAllPoint2D(oc, coreObjects, newObjects) {
  let previousPoint2DObject;
  for (const inputObject of coreObjects) {
    if (previousPoint2DObject) {
      newObjects.push(_createSegment2d(oc, previousPoint2DObject.cadGeometry(), inputObject.cadGeometry()));
    }
    previousPoint2DObject = inputObject;
  }
}
function _createSegmentsFromVertexPairs(oc, inputCoreGroup0, inputCoreGroup1, newObjects) {
  const inputVertexObjects0 = cadFilterObjects(inputCoreGroup0.cadObjects(), CadCommon/* CadGeometryType.VERTEX */.dT.VERTEX);
  const inputVertexObjects1 = cadFilterObjects(inputCoreGroup1.cadObjects(), CadCommon/* CadGeometryType.VERTEX */.dT.VERTEX);
  if (inputVertexObjects0 && inputVertexObjects1) {
    const minVerticesCount = Math.min(inputVertexObjects0.length, inputVertexObjects1.length);
    for (let i = 0; i < minVerticesCount; i++) {
      const vertex0 = inputVertexObjects0[i].cadGeometry();
      const vertex1 = inputVertexObjects1[i].cadGeometry();
      newObjects.push(_createSegment(oc, vertex0, vertex1));
    }
  }
}
function _createSegmentsFromPoint2DPairs(oc, inputCoreGroup0, inputCoreGroup1, newObjects) {
  const inputPoint2DObjects0 = cadFilterObjects(inputCoreGroup0.cadObjects(), CadCommon/* CadGeometryType.POINT_2D */.dT.POINT_2D);
  const inputPoint2DObjects1 = cadFilterObjects(inputCoreGroup1.cadObjects(), CadCommon/* CadGeometryType.POINT_2D */.dT.POINT_2D);
  if (inputPoint2DObjects0 && inputPoint2DObjects1) {
    const minPoint2DCount = Math.min(inputPoint2DObjects0.length, inputPoint2DObjects1.length);
    for (let i = 0; i < minPoint2DCount; i++) {
      const point2D0 = inputPoint2DObjects0[i].cadGeometry();
      const point2D1 = inputPoint2DObjects1[i].cadGeometry();
      newObjects.push(_createSegment2d(oc, point2D0, point2D1));
    }
  }
}
function _createSegment(oc, vertex0, vertex1) {
  const point0 = oc.BRep_Tool.Pnt(vertex0);
  const point1 = oc.BRep_Tool.Pnt(vertex1);
  const api = new oc.GC_MakeSegment_1(point0, point1);
  const curve = api.Value().get();
  const edge = (0,CadEdge/* cadEdgeCreate */.Ll)(oc, curve);
  api.delete();
  return new CadObject/* CadObject */.K(edge, CadCommon/* CadGeometryType.EDGE */.dT.EDGE);
}
function _createSegment2d(oc, point0, point1) {
  const api = new oc.GCE2d_MakeSegment_1(point0, point1);
  const curve = api.Value().get();
  api.delete();
  return new CadObject/* CadObject */.K(curve, CadCommon/* CadGeometryType.CURVE_2D */.dT.CURVE_2D);
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/sop/CADSphere.ts

var CADSphere_async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step2(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step2(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step2 = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step2((generator = generator.apply(__this, __arguments)).next());
  });
};







class CADSphereSopParamsConfig extends params_ParamsConfig/* NodeParamsConfig */.yI {
  constructor() {
    super(...arguments);
    /** @param radius */
    this.radius = params_ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(1, {
      range: [0, 2],
      rangeLocked: [true, false],
      step: CadConstant/* step */.Nb
    });
    /** @param center */
    this.center = params_ParamsConfig/* ParamConfig.VECTOR3 */.XC.VECTOR3([0, 0, 0]);
    /** @param axis */
    this.axis = params_ParamsConfig/* ParamConfig.VECTOR3 */.XC.VECTOR3([0, 1, 0]);
    /** @param closed */
    this.closed = params_ParamsConfig/* ParamConfig.BOOLEAN */.XC.BOOLEAN(true);
    /** @param thetaMin */
    this.thetaMin = params_ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(`1.5*$PI`, {
      range: [1.5 * Math.PI, 2.5 * Math.PI],
      rangeLocked: [true, true],
      step: CadConstant/* step */.Nb,
      visibleIf: { closed: false }
    });
    /** @param thetaMax */
    this.thetaMax = params_ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(`2.5*$PI`, {
      range: [1.5 * Math.PI, 2.5 * Math.PI],
      rangeLocked: [true, true],
      step: CadConstant/* step */.Nb,
      visibleIf: { closed: false }
    });
    /** @param phi */
    this.phi = params_ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(`2*$PI`, {
      range: [0, 2 * Math.PI],
      rangeLocked: [true, true],
      step: CadConstant/* step */.Nb,
      visibleIf: { closed: false }
    });
  }
}
const CADSphere_ParamsConfig = new CADSphereSopParamsConfig();
class CADSphereSopNode extends _BaseCAD/* CADSopNode */.M {
  constructor() {
    super(...arguments);
    this.paramsConfig = CADSphere_ParamsConfig;
  }
  static type() {
    return Sop/* SopType.CAD_SPHERE */.aB.CAD_SPHERE;
  }
  cook(inputCoreGroups) {
    return CADSphere_async(this, null, function* () {
      const oc = yield CadLoader/* CadLoader.core */.i.core(this);
      const axis = (0,CadMath/* cadAxis */.Dh)(this.pv.axis);
      const api = this.pv.closed ? new oc.BRepPrimAPI_MakeSphere_9(axis, this.pv.radius) : (() => {
        const thetaMin = Math.min(this.pv.thetaMin, this.pv.thetaMax);
        const thetaMax = Math.max(this.pv.thetaMin, this.pv.thetaMax);
        return new oc.BRepPrimAPI_MakeSphere_12(axis, this.pv.radius, thetaMin, thetaMax, this.pv.phi);
      })();
      const shape = (0,CadShapeCommon/* cadShapeTranslate */.ew)(api.Shape(), this.pv.center);
      api.delete();
      this.setCADShape(shape);
    });
  }
}

// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/nodes/sop/CADThickness.ts
var CADThickness = __webpack_require__(793);
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/sop/CADTorus.ts

var CADTorus_async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step2(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step2(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step2 = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step2((generator = generator.apply(__this, __arguments)).next());
  });
};







class CADTorusSopParamsConfig extends params_ParamsConfig/* NodeParamsConfig */.yI {
  constructor() {
    super(...arguments);
    /** @param outer radius */
    this.outerRadius = params_ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(1, {
      range: [0, 2],
      rangeLocked: [true, false],
      step: CadConstant/* step */.Nb
    });
    /** @param inner radius */
    this.innerRadius = params_ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(0.5, {
      range: [0, 2],
      rangeLocked: [true, false],
      step: CadConstant/* step */.Nb
    });
    /** @param center */
    this.center = params_ParamsConfig/* ParamConfig.VECTOR3 */.XC.VECTOR3([0, 0, 0]);
    /** @param axis */
    this.axis = params_ParamsConfig/* ParamConfig.VECTOR3 */.XC.VECTOR3([0, 1, 0]);
    /** @param closed */
    this.closed = params_ParamsConfig/* ParamConfig.BOOLEAN */.XC.BOOLEAN(true);
    /** @param phi */
    this.phi = params_ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(`2*$PI`, {
      range: [0, 2 * Math.PI],
      rangeLocked: [true, true],
      step: CadConstant/* step */.Nb,
      visibleIf: { closed: false }
    });
  }
}
const CADTorus_ParamsConfig = new CADTorusSopParamsConfig();
class CADTorusSopNode extends _BaseCAD/* CADSopNode */.M {
  constructor() {
    super(...arguments);
    this.paramsConfig = CADTorus_ParamsConfig;
  }
  static type() {
    return Sop/* SopType.CAD_TORUS */.aB.CAD_TORUS;
  }
  cook(inputCoreGroups) {
    return CADTorus_async(this, null, function* () {
      const oc = yield CadLoader/* CadLoader.core */.i.core(this);
      const axis = (0,CadMath/* cadAxis */.Dh)(this.pv.axis);
      const api = this.pv.closed ? new oc.BRepPrimAPI_MakeTorus_5(axis, this.pv.outerRadius, this.pv.innerRadius) : new oc.BRepPrimAPI_MakeTorus_6(axis, this.pv.outerRadius, this.pv.innerRadius, this.pv.phi);
      const shape = (0,CadShapeCommon/* cadShapeTranslate */.ew)(api.Shape(), this.pv.center);
      api.delete();
      this.setCADShape(shape);
    });
  }
}

// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/core/geometry/modules/cad/operations/CadTransform.ts
var CadTransform = __webpack_require__(89742);
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/sop/CADTransform.ts






class CADTransformSopParamConfig extends params_ParamsConfig/* NodeParamsConfig */.yI {
  constructor() {
    super(...arguments);
    /** @param translate */
    this.t = params_ParamsConfig/* ParamConfig.VECTOR3 */.XC.VECTOR3([0, 0, 0]);
    /** @param rotation */
    this.r = params_ParamsConfig/* ParamConfig.VECTOR3 */.XC.VECTOR3([0, 0, 0]);
    /** @param scale (as a float) */
    this.s = params_ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(1, {
      range: [0, 2],
      step: 0.01
    });
    /** @param pivot */
    this.pivot = params_ParamsConfig/* ParamConfig.VECTOR3 */.XC.VECTOR3([0, 0, 0]);
  }
}
const CADTransform_ParamsConfig = new CADTransformSopParamConfig();
class CADTransformSopNode extends _BaseCAD/* CADSopNode */.M {
  constructor() {
    super(...arguments);
    this.paramsConfig = CADTransform_ParamsConfig;
  }
  static type() {
    return Sop/* SopType.CAD_TRANSFORM */.aB.CAD_TRANSFORM;
  }
  initializeNode() {
    this.io.inputs.setCount(1);
    this.io.inputs.initInputsClonedState(InputCloneMode/* InputCloneMode.FROM_NODE */.m.FROM_NODE);
  }
  cook(inputCoreGroups) {
    const coreGroup0 = inputCoreGroups[0];
    const newObjects = [];
    const cadObjects = coreGroup0.cadObjects();
    if (cadObjects) {
      for (const cadObject of cadObjects) {
        (0,CadTransform/* cadTransform */.k)(cadObject, this.pv.t, this.pv.r, this.pv.s, this.pv.pivot);
        newObjects.push(cadObject);
      }
    }
    this.setCADObjects(newObjects);
  }
}

// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/core/geometry/modules/cad/toObject3D/CadPnt2d.ts
var CadPnt2d = __webpack_require__(28678);
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/sop/CADTransform2D.ts

var CADTransform2D_async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};






class CADTransform2DSopParamsConfig extends params_ParamsConfig/* NodeParamsConfig */.yI {
  constructor() {
    super(...arguments);
    /** @param translate */
    this.t = params_ParamsConfig/* ParamConfig.VECTOR2 */.XC.VECTOR2([0, 0]);
    /** @param rotation */
    this.r = params_ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(0, {
      range: [-180, 180],
      rangeLocked: [false, false]
    });
    /** @param scale (as a float) */
    this.s = params_ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(1, {
      range: [0, 2],
      step: 0.01
    });
    /** @param pivot */
    this.pivot = params_ParamsConfig/* ParamConfig.VECTOR2 */.XC.VECTOR2([0, 0]);
  }
}
const CADTransform2D_ParamsConfig = new CADTransform2DSopParamsConfig();
class CADTransform2DSopNode extends _BaseCAD/* CADSopNode */.M {
  constructor() {
    super(...arguments);
    this.paramsConfig = CADTransform2D_ParamsConfig;
  }
  static type() {
    return Sop/* SopType.CAD_TRANSFORM_2D */.aB.CAD_TRANSFORM_2D;
  }
  initializeNode() {
    this.io.inputs.setCount(1);
  }
  cook(inputCoreGroups) {
    return CADTransform2D_async(this, null, function* () {
      const coreGroup0 = inputCoreGroups[0];
      const newObjects = [];
      const cadObjects = coreGroup0.cadObjects();
      if (cadObjects) {
        for (const cadObject of cadObjects) {
          transform2D(cadObject, this.pv.t, this.pv.r, this.pv.s, this.pv.pivot);
          newObjects.push(cadObject);
        }
      }
      this.setCADObjects(newObjects);
    });
  }
}
function transform2D(cadObject, t, r, s, pivot) {
  switch (cadObject.type) {
    case CadCommon/* CadGeometryType.POINT_2D */.dT.POINT_2D: {
      return (0,CadPnt2d/* cadPnt2dTransform */.YW)(cadObject.cadGeometry(), t);
    }
    case CadCommon/* CadGeometryType.CURVE_2D */.dT.CURVE_2D: {
      return (0,CadGeom2dCurve/* cadGeom2dCurveTransform */.Kt)(cadObject.cadGeometry(), t, r, s, pivot);
    }
  }
}

// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/core/geometry/modules/cad/utils/TesselationParamsConfig.ts
var TesselationParamsConfig = __webpack_require__(78611);
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/sop/CADTriangulate.ts

var CADTriangulate_async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};





class CADTriangulateSopParamsConfig extends (0,TesselationParamsConfig/* SOPCADTesselationParamConfig */.tG)(params_ParamsConfig/* NodeParamsConfig */.yI) {
}
const CADTriangulate_ParamsConfig = new CADTriangulateSopParamsConfig();
class CADTriangulateSopNode extends _BaseCAD/* CADSopNode */.M {
  constructor() {
    super(...arguments);
    this.paramsConfig = CADTriangulate_ParamsConfig;
  }
  static type() {
    return Sop/* SopType.CAD_TRIANGULATE */.aB.CAD_TRIANGULATE;
  }
  initializeNode() {
    this.io.inputs.setCount(1);
  }
  cook(inputCoreGroups) {
    return CADTriangulate_async(this, null, function* () {
      const cadObjects = inputCoreGroups[0].cadObjects();
      if (cadObjects) {
        const newObjects = [];
        for (const cadObject of cadObjects) {
          const objects = cadObject.toObject3D(this.pv, this);
          if (objects) {
            if (Type/* CoreType.isArray */.MR.isArray(objects)) {
              newObjects.push(...objects);
            } else {
              newObjects.push(objects);
            }
          }
        }
        this.setObjects(newObjects);
      } else {
        this.setObjects([]);
      }
    });
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/sop/CADTube.ts

var CADTube_async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step2(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step2(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step2 = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step2((generator = generator.apply(__this, __arguments)).next());
  });
};







class CADTubeSopParamsConfig extends params_ParamsConfig/* NodeParamsConfig */.yI {
  constructor() {
    super(...arguments);
    /** @param radius */
    this.radius = params_ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(1, {
      range: [0, 2],
      rangeLocked: [true, false],
      step: CadConstant/* step */.Nb
    });
    /** @param height */
    this.height = params_ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(1, {
      range: [0, 2],
      rangeLocked: [true, false],
      step: CadConstant/* step */.Nb
    });
    /** @param center */
    this.center = params_ParamsConfig/* ParamConfig.VECTOR3 */.XC.VECTOR3([0, 0, 0]);
    /** @param axis */
    this.axis = params_ParamsConfig/* ParamConfig.VECTOR3 */.XC.VECTOR3([0, 1, 0]);
    /** @param closed */
    this.closed = params_ParamsConfig/* ParamConfig.BOOLEAN */.XC.BOOLEAN(true);
    /** @param angle */
    this.angle = params_ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(`2*$PI`, {
      range: [0, 2 * Math.PI],
      rangeLocked: [true, true],
      step: CadConstant/* step */.Nb,
      visibleIf: { closed: false }
    });
  }
}
const CADTube_ParamsConfig = new CADTubeSopParamsConfig();
class CADTubeSopNode extends _BaseCAD/* CADSopNode */.M {
  constructor() {
    super(...arguments);
    this.paramsConfig = CADTube_ParamsConfig;
  }
  static type() {
    return Sop/* SopType.CAD_TUBE */.aB.CAD_TUBE;
  }
  cook(inputCoreGroups) {
    return CADTube_async(this, null, function* () {
      const oc = yield CadLoader/* CadLoader.core */.i.core(this);
      const axis = (0,CadMath/* cadAxis */.Dh)(this.pv.axis);
      const api = this.pv.closed ? new oc.BRepPrimAPI_MakeCylinder_3(axis, this.pv.radius, this.pv.height) : new oc.BRepPrimAPI_MakeCylinder_4(axis, this.pv.radius, this.pv.height, this.pv.angle);
      const shape = (0,CadShapeCommon/* cadShapeTranslate */.ew)(api.Shape(), this.pv.center);
      api.delete();
      this.setCADShape(shape);
    });
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/sop/CADUnpack.ts








class CADUnpackSopParamsConfig extends params_ParamsConfig/* NodeParamsConfig */.yI {
}
const CADUnpack_ParamsConfig = new CADUnpackSopParamsConfig();
class CADUnpackSopNode extends _BaseCAD/* CADSopNode */.M {
  constructor() {
    super(...arguments);
    this.paramsConfig = CADUnpack_ParamsConfig;
  }
  static type() {
    return Sop/* SopType.CAD_UNPACK */.aB.CAD_UNPACK;
  }
  initializeNode() {
    this.io.inputs.setCount(1);
  }
  cook(inputCoreGroups) {
    const inputCoreGroup = inputCoreGroups[0];
    const newObjects = [];
    const inputObjects = inputCoreGroup.cadObjects();
    if (inputObjects) {
      const oc = CadLoaderSync/* CadLoaderSync.oc */.T.oc();
      for (const inputObject of inputObjects) {
        const shape = inputObject.cadGeometry();
        if (CadCoreType/* CoreCadType.isGeometryShape */.c.isGeometryShape(shape)) {
          const iterator = new oc.TopoDS_Iterator_2(shape, true, true);
          while (iterator.More()) {
            const newShape = (0,CadCommon/* cadDowncast */.wK)(oc, iterator.Value());
            const type = (0,CadCommon/* cadGeometryTypeFromShape */.dJ)(oc, newShape);
            if (type) {
              const newObject = new CadObject/* CadObject */.K(newShape, type);
              newObjects.push(newObject);
            }
            iterator.Next();
          }
          iterator.delete();
        } else {
          newObjects.push(inputObject);
        }
      }
    }
    this.setCADObjects(newObjects);
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/sop/CADWedge.ts

var CADWedge_async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step2(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step2(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step2 = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step2((generator = generator.apply(__this, __arguments)).next());
  });
};







const CADWedge_size = new three_module.Vector3();
const CADWedge_centerOffset = new three_module.Vector3();
class CADWedgeSopParamsConfig extends params_ParamsConfig/* NodeParamsConfig */.yI {
  constructor() {
    super(...arguments);
    /** @param size */
    this.size = params_ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(1, {
      range: [0, 10],
      rangeLocked: [true, false],
      step: CadConstant/* step */.Nb
    });
    /** @param sizes */
    this.sizes = params_ParamsConfig/* ParamConfig.VECTOR3 */.XC.VECTOR3([1, 1, 1]);
    /** @param center */
    this.center = params_ParamsConfig/* ParamConfig.VECTOR3 */.XC.VECTOR3([0, 0, 0]);
    /** @param end width */
    this.endWidth = params_ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(0.5);
  }
}
const CADWedge_ParamsConfig = new CADWedgeSopParamsConfig();
class CADWedgeSopNode extends _BaseCAD/* CADSopNode */.M {
  constructor() {
    super(...arguments);
    this.paramsConfig = CADWedge_ParamsConfig;
  }
  static type() {
    return Sop/* SopType.CAD_WEDGE */.aB.CAD_WEDGE;
  }
  cook() {
    return CADWedge_async(this, null, function* () {
      const oc = yield CadLoader/* CadLoader.core */.i.core(this);
      CADWedge_size.copy(this.pv.sizes).multiplyScalar(this.pv.size);
      const api = new oc.BRepPrimAPI_MakeWedge_1(CADWedge_size.x, CADWedge_size.y, CADWedge_size.z, this.pv.endWidth);
      CADWedge_centerOffset.copy(CADWedge_size).multiplyScalar(-0.5);
      const centered = (0,CadShapeCommon/* cadShapeTranslate */.ew)(api.Shape(), CADWedge_centerOffset);
      const shape = (0,CadShapeCommon/* cadShapeTranslate */.ew)(centered, this.pv.center);
      api.delete();
      this.setCADShape(shape);
    });
  }
}

// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/nodes/sop/CameraControls.ts
var CameraControls = __webpack_require__(92550);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/operations/sop/CameraCSSRenderer.ts
var CameraCSSRenderer = __webpack_require__(42669);
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/sop/CameraCSSRenderer.ts





class CameraCSSRendererSopParamsConfig extends params_ParamsConfig/* HierarchyParamConfigAll */.Nc {
  constructor() {
    super(...arguments);
    /** @param renderer */
    this.node = params_ParamsConfig/* ParamConfig.NODE_PATH */.XC.NODE_PATH("", {
      nodeSelection: {
        context: poly_NodeContext/* NodeContext.ROP */.sy.ROP
      },
      dependentOnFoundNode: true
    });
  }
}
const CameraCSSRenderer_ParamsConfig = new CameraCSSRendererSopParamsConfig();
class CameraCSSRendererSopNode extends sop_Base/* TypedSopNode */.x {
  constructor() {
    super(...arguments);
    this.paramsConfig = CameraCSSRenderer_ParamsConfig;
    /*
    children
    */
    this._childrenControllerContext = poly_NodeContext/* NodeContext.ROP */.sy.ROP;
  }
  static type() {
    return poly_NodeContext/* CameraSopNodeType.CSS_RENDERER */.$4.CSS_RENDERER;
  }
  initializeNode() {
    this.io.inputs.setCount(1);
    this.io.inputs.initInputsClonedState(CameraCSSRenderer/* CameraCSSRendererSopOperation.INPUT_CLONED_STATE */.G.INPUT_CLONED_STATE);
  }
  cook(inputCoreGroups) {
    this._operation = this._operation || new CameraCSSRenderer/* CameraCSSRendererSopOperation */.G(this._scene, this.states, this);
    const core_group = this._operation.cook(inputCoreGroups, this.pv);
    this.setCoreGroup(core_group);
  }
  createNode(node_class, options) {
    return super.createNode(node_class, options);
  }
  children() {
    return super.children();
  }
  nodesByType(type) {
    return super.nodesByType(type);
  }
}

// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/nodes/sop/CameraFPS.ts
var CameraFPS = __webpack_require__(7999);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/nodes/sop/CameraFrameMode.ts
var CameraFrameMode = __webpack_require__(15303);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/core/RaycastHelper.ts
var RaycastHelper = __webpack_require__(71003);
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/sop/CameraPlane.ts

var CameraPlane_async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};






const CameraPlane_DEFAULT = {
  direction: new three_module.Vector3(0, 1, 0)
};
const SCREEN_CORNERS = [new three_module.Vector2(-1, -1), new three_module.Vector2(-1, 1), new three_module.Vector2(1, 1), new three_module.Vector2(1, -1)];
const CameraPlane_DEFAULT_UP = new three_module.Vector3(0, 0, 1);
const segmentsCount = new three_module.Vector2(1, 1);
const planeSize = new three_module.Vector2();
const _plane = new three_module.Plane();
const _planeCorners = [new three_module.Vector3(), new three_module.Vector3(), new three_module.Vector3(), new three_module.Vector3()];
const _planeCenter = new three_module.Vector3();
class CameraPlaneSopParamsConfig extends params_ParamsConfig/* NodeParamsConfig */.yI {
  constructor() {
    super(...arguments);
    /** @param axis perpendicular to the plane */
    this.direction = params_ParamsConfig/* ParamConfig.VECTOR3 */.XC.VECTOR3(CameraPlane_DEFAULT.direction);
    /** @param plane offset */
    this.offset = params_ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(0, {
      range: [-10, 10],
      rangeLocked: [false, false]
    });
    /** @param defines if the plane resolution is sets via the number of segments or via the step size */
    this.useSegmentsCount = params_ParamsConfig/* ParamConfig.BOOLEAN */.XC.BOOLEAN(true);
    /** @param step size */
    this.stepSize = params_ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(1, {
      range: [1e-3, 1],
      rangeLocked: [false, false],
      visibleIf: { useSegmentsCount: 0 }
    });
    /** @param segments count */
    this.segments = params_ParamsConfig/* ParamConfig.VECTOR2 */.XC.VECTOR2([10, 10], {
      visibleIf: { useSegmentsCount: 1 }
    });
    /** @param multiplies the size of the plane. This can be useful to scale down the plane. While it would cover a smaller part of the view, it would be faster to create  */
    this.sizeMult = params_ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(1, {
      range: [0, 2],
      rangeLocked: [true, false]
    });
    /** @param update on window resize  */
    this.updateOnWindowResize = params_ParamsConfig/* ParamConfig.BOOLEAN */.XC.BOOLEAN(1);
    /** @param update */
    this.update = params_ParamsConfig/* ParamConfig.BUTTON */.XC.BUTTON(null, {
      callback: (node) => {
        CameraPlaneSopNode.PARAM_CALLBACK_update(node);
      }
    });
  }
}
const CameraPlane_ParamsConfig = new CameraPlaneSopParamsConfig();
class CameraPlaneSopNode extends sop_Base/* TypedSopNode */.x {
  constructor() {
    super(...arguments);
    this.paramsConfig = CameraPlane_ParamsConfig;
    this._raycaster = (0,RaycastHelper/* createRaycaster */.j)();
    this._coreTransform = new Transform/* CoreTransform */.ZR();
  }
  static type() {
    return "cameraPlane";
  }
  cook() {
    return CameraPlane_async(this, null, function* () {
      this._updateWindowControllerDependency();
      const camera = yield this.scene().camerasController.mainCamera();
      if (camera) {
        this._computePlaneParams(camera);
      } else {
        this.states.error.set("no main camera found");
      }
    });
  }
  _updateWindowControllerDependency() {
    if ((0,Type/* isBooleanTrue */.bI)(this.pv.updateOnWindowResize)) {
      this.addGraphInput(this.scene().viewersRegister.graphNode());
    } else {
      this.removeGraphInput(this.scene().viewersRegister.graphNode());
    }
  }
  _computePlaneParams(camera) {
    _plane.normal.copy(this.pv.direction);
    _plane.constant = this.pv.offset;
    let i = 0;
    _planeCenter.set(0, 0, 0);
    for (const corner of SCREEN_CORNERS) {
      this._raycaster.setFromCamera(corner, camera);
      const targetCorner = _planeCorners[i];
      this._raycaster.ray.intersectPlane(_plane, targetCorner);
      _planeCenter.add(targetCorner);
      i++;
    }
    _planeCenter.multiplyScalar(0.25);
    const w0 = _planeCorners[1].distanceTo(_planeCorners[2]);
    const w1 = _planeCorners[0].distanceTo(_planeCorners[3]);
    const h0 = _planeCorners[0].distanceTo(_planeCorners[1]);
    const h1 = _planeCorners[2].distanceTo(_planeCorners[3]);
    const width = Math.max(w0, w1) * this.pv.sizeMult;
    const height = Math.max(h0, h1) * this.pv.sizeMult;
    planeSize.set(width, height);
    const geometry = this._createPlane(planeSize);
    (0,Transform/* rotateGeometry */.bP)(geometry, CameraPlane_DEFAULT_UP, this.pv.direction);
    const matrix = this._coreTransform.translationMatrix(_planeCenter);
    geometry.applyMatrix4(matrix);
    this.setGeometry(geometry);
  }
  _createPlane(size) {
    size = size.clone();
    if ((0,Type/* isBooleanTrue */.bI)(this.pv.useSegmentsCount)) {
      segmentsCount.x = Math.floor(this.pv.segments.x);
      segmentsCount.y = Math.floor(this.pv.segments.y);
    } else {
      if (this.pv.stepSize > 0) {
        segmentsCount.x = Math.floor(size.x / this.pv.stepSize);
        segmentsCount.y = Math.floor(size.y / this.pv.stepSize);
        size.x = segmentsCount.x * this.pv.stepSize;
        size.y = segmentsCount.y * this.pv.stepSize;
      }
    }
    return new three_module.PlaneGeometry(size.x, size.y, segmentsCount.x, segmentsCount.y);
  }
  //
  //
  // CALLBACK
  //
  //
  static PARAM_CALLBACK_update(node) {
    node._paramCallbackUpdate();
  }
  _paramCallbackUpdate() {
    this.setDirty();
  }
}

// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/nodes/sop/CameraPostProcess.ts
var CameraPostProcess = __webpack_require__(31708);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/nodes/sop/CameraProject.ts
var CameraProject = __webpack_require__(84732);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/nodes/sop/CameraRenderScene.ts
var CameraRenderScene = __webpack_require__(8341);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/operations/sop/CameraRenderer.ts
var CameraRenderer = __webpack_require__(63282);
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/sop/CameraRenderer.ts





class CameraRendererSopParamsConfig extends params_ParamsConfig/* HierarchyParamConfigAll */.Nc {
  constructor() {
    super(...arguments);
    /** @param renderer */
    this.node = params_ParamsConfig/* ParamConfig.NODE_PATH */.XC.NODE_PATH("", {
      nodeSelection: {
        context: poly_NodeContext/* NodeContext.ROP */.sy.ROP
      },
      dependentOnFoundNode: true
    });
  }
}
const CameraRenderer_ParamsConfig = new CameraRendererSopParamsConfig();
class CameraRendererSopNode extends sop_Base/* TypedSopNode */.x {
  constructor() {
    super(...arguments);
    this.paramsConfig = CameraRenderer_ParamsConfig;
    /*
    children
    */
    this._childrenControllerContext = poly_NodeContext/* NodeContext.ROP */.sy.ROP;
  }
  static type() {
    return poly_NodeContext/* CameraSopNodeType.RENDERER */.$4.RENDERER;
  }
  initializeNode() {
    this.io.inputs.setCount(1);
    this.io.inputs.initInputsClonedState(CameraRenderer/* CameraRendererSopOperation.INPUT_CLONED_STATE */.Q.INPUT_CLONED_STATE);
  }
  cook(inputCoreGroups) {
    this._operation = this._operation || new CameraRenderer/* CameraRendererSopOperation */.Q(this._scene, this.states, this);
    const coreGroup = this._operation.cook(inputCoreGroups, this.pv);
    this.setCoreGroup(coreGroup);
  }
  createNode(node_class, options) {
    return super.createNode(node_class, options);
  }
  children() {
    return super.children();
  }
  nodesByType(type) {
    return super.nodesByType(type);
  }
}

// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/nodes/sop/CameraViewerCode.ts
var CameraViewerCode = __webpack_require__(2586);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/nodes/sop/CameraViewOffset.ts
var CameraViewOffset = __webpack_require__(61065);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/nodes/sop/CameraWebXRARMarkerTracking.ts
var CameraWebXRARMarkerTracking = __webpack_require__(5972);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/nodes/sop/CameraWebXRAR.ts + 1 modules
var CameraWebXRAR = __webpack_require__(22952);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/nodes/sop/CameraWebXRVR.ts + 1 modules
var CameraWebXRVR = __webpack_require__(18735);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/nodes/sop/Capsule.ts
var sop_Capsule = __webpack_require__(11517);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/nodes/sop/Center.ts
var Center = __webpack_require__(61763);
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/core/geometry/util/Circle.ts





class CoreGeometryUtilCircle {
  static positions(options) {
    const { radius, segments } = options;
    const arcAngle = options.arcAngle || 360;
    const segmentsCount = segments + 1;
    const radianPerSegment = (0,_Module/* degToRad */.Id)(arcAngle) / (segmentsCount - 1);
    const positions = [];
    for (let i = 0; i < segmentsCount; i++) {
      const pointRadian = radianPerSegment * i;
      const x = radius * Math.cos(pointRadian);
      const y = radius * Math.sin(pointRadian);
      if (!(arcAngle == 360 && i == segmentsCount - 1)) {
        positions.push(new three_module.Vector2(x, y));
      }
    }
    return positions;
  }
  static create(options) {
    const { segments, arcAngle } = options;
    let { connectLastPoint } = options;
    if (arcAngle == 360) {
      connectLastPoint = true;
    }
    const segmentsCount = segments;
    const positions2d = this.positions(options);
    const positions = [];
    const indices = [];
    let position2d;
    for (let i = 0; i < positions2d.length; i++) {
      position2d = positions2d[i];
      positions.push(position2d.x);
      positions.push(position2d.y);
      positions.push(0);
      if (i > 0) {
        indices.push(i - 1);
        indices.push(i);
      }
    }
    if (connectLastPoint) {
      if (arcAngle == 360) {
        indices.push(segmentsCount - 1);
      } else {
        indices.push(segmentsCount);
      }
      indices.push(0);
    }
    const geometry = new three_module.BufferGeometry();
    geometry.setAttribute("position", new three_module.Float32BufferAttribute(positions, 3));
    geometry.setIndex(indices);
    return geometry;
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/operations/sop/Circle.ts







const Circle_DEFAULT_UP = new three_module.Vector3(0, 0, 1);
class CircleSopOperation extends operations_sop_Base/* BaseSopOperation */.U {
  static type() {
    return "circle";
  }
  cook(input_contents, params) {
    if ((0,Type/* isBooleanTrue */.bI)(params.open)) {
      return this._createCircle(params);
    } else {
      return this._createDisk(params);
    }
  }
  _createCircle(params) {
    const geometry = CoreGeometryUtilCircle.create(params);
    this._setCenterAndDirection(geometry, params);
    return this.createCoreGroupFromGeometry(geometry, Constant/* ObjectType.LINE_SEGMENTS */.LP.LINE_SEGMENTS);
  }
  _createDisk(params) {
    const geometry = new three_module.CircleGeometry(params.radius, params.segments);
    this._setCenterAndDirection(geometry, params);
    return this.createCoreGroupFromGeometry(geometry);
  }
  _setCenterAndDirection(geometry, params) {
    (0,Transform/* rotateGeometry */.bP)(geometry, Circle_DEFAULT_UP, params.direction);
    geometry.translate(params.center.x, params.center.y, params.center.z);
  }
}
CircleSopOperation.DEFAULT_PARAMS = {
  radius: 1,
  segments: 12,
  open: true,
  arcAngle: 360,
  direction: new three_module.Vector3(0, 1, 0),
  center: new three_module.Vector3(0, 0, 0),
  connectLastPoint: true
};

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/sop/Circle.ts





const Circle_DEFAULT = CircleSopOperation.DEFAULT_PARAMS;
class CircleSopParamsConfig extends params_ParamsConfig/* NodeParamsConfig */.yI {
  constructor() {
    super(...arguments);
    /** @param circle radius */
    this.radius = params_ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(Circle_DEFAULT.radius);
    /** @param segments count */
    this.segments = params_ParamsConfig/* ParamConfig.INTEGER */.XC.INTEGER(Circle_DEFAULT.segments, {
      range: [1, 50],
      rangeLocked: [true, false]
    });
    /** @param toggle on to have an arc instead of a closed circle */
    this.open = params_ParamsConfig/* ParamConfig.BOOLEAN */.XC.BOOLEAN(Circle_DEFAULT.open);
    /** @param connects last dot for open circle */
    this.connectLastPoint = params_ParamsConfig/* ParamConfig.BOOLEAN */.XC.BOOLEAN(Circle_DEFAULT.connectLastPoint, {
      visibleIf: { open: 1 }
    });
    /** @param angle fo the arc */
    this.arcAngle = params_ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(Circle_DEFAULT.arcAngle, {
      range: [0, 360],
      rangeLocked: [false, false],
      visibleIf: { open: 1 }
    });
    /** @param direction of the axis perpendicular to the circle plane */
    this.direction = params_ParamsConfig/* ParamConfig.VECTOR3 */.XC.VECTOR3(Circle_DEFAULT.direction);
    /** @param center */
    this.center = params_ParamsConfig/* ParamConfig.VECTOR3 */.XC.VECTOR3(Circle_DEFAULT.center);
  }
}
const Circle_ParamsConfig = new CircleSopParamsConfig();
class CircleSopNode extends sop_Base/* TypedSopNode */.x {
  constructor() {
    super(...arguments);
    this.paramsConfig = Circle_ParamsConfig;
  }
  static type() {
    return Sop/* SopType.CIRCLE */.aB.CIRCLE;
  }
  cook() {
    this._operation = this._operation || new CircleSopOperation(this._scene, this.states, this);
    const coreGroup = this._operation.cook([], this.pv);
    this.setCoreGroup(coreGroup);
  }
}

// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/nodes/sop/Circle3Points.ts
var Circle3Points = __webpack_require__(57568);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/node_modules/three-bvh-csg/src/core/Evaluator.js + 7 modules
var Evaluator = __webpack_require__(27087);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/node_modules/three-bvh-csg/src/core/Brush.js + 5 modules
var Brush = __webpack_require__(32188);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/node_modules/three-bvh-csg/src/core/constants.js
var constants = __webpack_require__(60444);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/core/geometry/modules/three/builders/Mesh.ts
var Mesh = __webpack_require__(86433);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/core/geometry/entities/point/CorePointUtils.ts
var CorePointUtils = __webpack_require__(50253);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/core/geometry/ObjectContent.ts
var ObjectContent = __webpack_require__(91057);
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/core/geometry/modules/three/ThreejsObjectUtils.ts



function copyObject3DProperties(srcObject, destObject) {
  (0,ObjectContent/* objectContentCopyProperties */.Br)(srcObject, destObject);
  destObject.position.copy(srcObject.position);
  destObject.quaternion.copy(srcObject.quaternion);
  destObject.scale.copy(srcObject.scale);
  destObject.matrix.copy(srcObject.matrix);
}
const UNCOPYABLE_PROPERTIES = /* @__PURE__ */ new Set(["animations", "children", "layers", "parent", "userData"]);
function copyObjectAllProperties(srcObject, destObject) {
  const keys = Object.keys(destObject);
  for (const key of keys) {
    if (UNCOPYABLE_PROPERTIES.has(key)) {
      continue;
    }
    const destProperty = destObject[key];
    if (destProperty instanceof three_module.Vector3 || destProperty instanceof three_module.Euler || destProperty instanceof three_module.Quaternion || destProperty instanceof three_module.Matrix4) {
      destProperty.copy(srcObject[key]);
    } else {
      destObject[key] = srcObject[key];
    }
  }
  return destObject;
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/operations/sop/Clip.ts













const tempVector = new three_module.Vector3();
const tempLine = new three_module.Line3();
const Clip_plane = new three_module.Plane();
const Clip_DEFAULT_UP = new three_module.Vector3(0, 1, 0);
const TMP_KEEP_ATTRIBUTE_NAME = "___keep___";
const TMP_KEEP_ATTRIBUTE_SIZE = 1;
const objectsToRemove = /* @__PURE__ */ new Set();
const BOOLEAN_SIZE = 1e4;
const _points = [];
class ClipSopOperation extends operations_sop_Base/* BaseSopOperation */.U {
  static type() {
    return "clip";
  }
  cook(inputCoreGroups, params) {
    const coreGroup = inputCoreGroups[0];
    const newObjects = [];
    Clip_plane.set(params.direction, -params.distance);
    Clip_plane.translate(params.origin);
    const inputObjects = coreGroup.threejsObjects();
    objectsToRemove.clear();
    for (const object of inputObjects) {
      object.traverse((child) => {
        _processObjectClipped(child, params, newObjects);
      });
    }
    objectsToRemove.forEach((child) => {
      child.removeFromParent();
    });
    return this.createCoreGroupFromObjects(newObjects);
  }
}
ClipSopOperation.DEFAULT_PARAMS = {
  origin: new three_module.Vector3(0, 0, 0),
  distance: 0,
  direction: new three_module.Vector3(0, 1, 0),
  intersectionEdges: false,
  keepBelowPlane: true,
  keepAbovePlane: false
};
ClipSopOperation.INPUT_CLONED_STATE = InputCloneMode/* InputCloneMode.ALWAYS */.m.ALWAYS;
function _processObjectClipped(object, params, newObjects) {
  const geometry = object.geometry;
  if (!geometry) {
    return;
  }
  const mesh = object;
  function _addObject(newObject) {
    newObjects.push(newObject);
    copyObject3DProperties(object, newObject);
    objectsToRemove.add(object);
  }
  if ((0,Type/* isBooleanTrue */.bI)(params.keepBelowPlane) || (0,Type/* isBooleanTrue */.bI)(params.keepAbovePlane)) {
    if ((0,Type/* isBooleanTrue */.bI)(params.keepBelowPlane)) {
      const box = _createBox(params, true);
      const belowPlane = _createClipped(mesh, box);
      _addObject(belowPlane);
    }
    if ((0,Type/* isBooleanTrue */.bI)(params.keepAbovePlane)) {
      const box = _createBox(params, false);
      const abovePlane = _createClipped(mesh, box);
      _addObject(abovePlane);
    }
  }
  if ((0,Type/* isBooleanTrue */.bI)(params.intersectionEdges)) {
    const intersectionEdges = _createClipGeo(mesh);
    if (intersectionEdges) {
      const oldMaterial = intersectionEdges.material;
      _addObject(intersectionEdges);
      intersectionEdges.material = oldMaterial;
    }
  }
}
function _createClipped(mesh, box) {
  const csgEvaluator = new Evaluator/* Evaluator */.v();
  const corePointClass = (0,CoreObjectFactory/* corePointClassFactory */.E_)(mesh);
  function _addKeepAttribute(object2, value) {
    corePointClass.addNumericAttribute(object2, TMP_KEEP_ATTRIBUTE_NAME, TMP_KEEP_ATTRIBUTE_SIZE, value);
  }
  _addKeepAttribute(mesh, 1);
  _addKeepAttribute(box, 0);
  const brush1 = new Brush/* Brush */.B(mesh.geometry, mesh.material);
  const brush2 = new Brush/* Brush */.B(box.geometry);
  const existingAttributes = corePointClass.attributeNames(mesh);
  csgEvaluator.attributes = [...existingAttributes, TMP_KEEP_ATTRIBUTE_NAME];
  const output = csgEvaluator.evaluate(brush1, brush2, constants/* SUBTRACTION */.vC);
  output.disposeCacheData();
  operations_sop_Base/* BaseSopOperation.createIndexIfNone */.U.createIndexIfNone(output.geometry);
  (0,CorePointUtils/* pointsFromObject */.u_)(output, _points);
  const keptPoints = _points.filter((p) => p.attribValue(TMP_KEEP_ATTRIBUTE_NAME) == 1);
  const builder = new Mesh/* CoreGeometryBuilderMesh */.t();
  const newGeometry = builder.fromPoints(output, keptPoints);
  const object = operations_sop_Base/* BaseSopOperation.createObject */.U.createObject(newGeometry, Constant/* ObjectType.MESH */.LP.MESH);
  return object;
}
function _createBox(params, above) {
  const { origin, direction, distance } = params;
  const geometry = new three_module.BoxGeometry(BOOLEAN_SIZE, BOOLEAN_SIZE, BOOLEAN_SIZE, 2, 2, 2);
  geometry.translate(0, BOOLEAN_SIZE * 0.5 * (above ? 1 : -1), 0);
  geometry.translate(origin.x, origin.y + distance, origin.z);
  (0,Transform/* rotateGeometry */.bP)(geometry, Clip_DEFAULT_UP, direction);
  const object = operations_sop_Base/* BaseSopOperation.createObject */.U.createObject(geometry, Constant/* ObjectType.MESH */.LP.MESH);
  return object;
}
function _createClipGeo(mesh) {
  const meshBVH = mesh;
  let bvh = meshBVH.geometry.boundsTree;
  if (!bvh) {
    ThreeMeshBVHHelper/* ThreeMeshBVHHelper.assignDefaultBVHIfNone */.h.assignDefaultBVHIfNone(mesh);
    bvh = meshBVH.geometry.boundsTree;
  }
  const performIntersection = (posAttrib) => {
    let index2 = 0;
    const intersectsBounds = (box, isLeaf, score, depth, nodeIndex) => {
      return Clip_plane.intersectsBox(box);
    };
    const intersectsTriangle = (tri) => {
      let count = 0;
      tempLine.start.copy(tri.a);
      tempLine.end.copy(tri.b);
      if (Clip_plane.intersectLine(tempLine, tempVector)) {
        posAttrib == null ? void 0 : posAttrib.setXYZ(index2, tempVector.x, tempVector.y, tempVector.z);
        index2++;
        count++;
      }
      tempLine.start.copy(tri.b);
      tempLine.end.copy(tri.c);
      if (Clip_plane.intersectLine(tempLine, tempVector)) {
        posAttrib == null ? void 0 : posAttrib.setXYZ(index2, tempVector.x, tempVector.y, tempVector.z);
        count++;
        index2++;
      }
      tempLine.start.copy(tri.c);
      tempLine.end.copy(tri.a);
      if (Clip_plane.intersectLine(tempLine, tempVector)) {
        posAttrib == null ? void 0 : posAttrib.setXYZ(index2, tempVector.x, tempVector.y, tempVector.z);
        count++;
        index2++;
      }
      if (count !== 2) {
        index2 -= count;
      }
    };
    bvh.shapecast({
      intersectsBounds,
      intersectsTriangle
    });
    return { index: index2 };
  };
  const { index } = performIntersection();
  const lineGeometry = new three_module.BufferGeometry();
  const linePosAttr = new three_module.BufferAttribute(new Float32Array(index * 3), 3, false);
  lineGeometry.setAttribute("position", linePosAttr);
  const outlineLines = new three_module.LineSegments(lineGeometry, Constant/* DEFAULT_MATERIALS */.ee[Constant/* ObjectType.LINE_SEGMENTS */.LP.LINE_SEGMENTS]);
  outlineLines.frustumCulled = false;
  const posAttr = outlineLines.geometry.attributes.position;
  performIntersection(posAttr);
  return outlineLines;
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/sop/Clip.ts




const Clip_DEFAULT = ClipSopOperation.DEFAULT_PARAMS;
class ClipSopParamsConfig extends params_ParamsConfig/* NodeParamsConfig */.yI {
  constructor() {
    super(...arguments);
    /** @param origin */
    this.origin = params_ParamsConfig/* ParamConfig.VECTOR3 */.XC.VECTOR3(Clip_DEFAULT.origin);
    /** @param distance */
    this.distance = params_ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(Clip_DEFAULT.distance, {
      range: [-10, 10],
      rangeLocked: [false, false]
    });
    /** @param direction */
    this.direction = params_ParamsConfig/* ParamConfig.VECTOR3 */.XC.VECTOR3(Clip_DEFAULT.direction, {
      separatorAfter: true
    });
    /** @param intersectionEdges */
    this.intersectionEdges = params_ParamsConfig/* ParamConfig.BOOLEAN */.XC.BOOLEAN(Clip_DEFAULT.intersectionEdges);
    /** @param keepBelowPlane */
    this.keepBelowPlane = params_ParamsConfig/* ParamConfig.BOOLEAN */.XC.BOOLEAN(Clip_DEFAULT.keepBelowPlane);
    /** @param keepAbovePlane */
    this.keepAbovePlane = params_ParamsConfig/* ParamConfig.BOOLEAN */.XC.BOOLEAN(Clip_DEFAULT.keepAbovePlane);
  }
}
const Clip_ParamsConfig = new ClipSopParamsConfig();
class ClipSopNode extends sop_Base/* TypedSopNode */.x {
  constructor() {
    super(...arguments);
    this.paramsConfig = Clip_ParamsConfig;
  }
  static type() {
    return "clip";
  }
  initializeNode() {
    this.io.inputs.setCount(1);
    this.io.inputs.initInputsClonedState(ClipSopOperation.INPUT_CLONED_STATE);
  }
  cook(inputCoreGroups) {
    this._operation = this._operation || new ClipSopOperation(this._scene, this.states, this);
    const coreGroup = this._operation.cook(inputCoreGroups, this.pv);
    this.setCoreGroup(coreGroup);
  }
}

// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/core/geometry/operation/Fuse.ts
var Fuse = __webpack_require__(90651);
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/sop/ClothPrepare.ts

var ClothPrepare_async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};











class ClothPrepareSopParamsConfig extends params_ParamsConfig/* NodeParamsConfig */.yI {
  constructor() {
    super(...arguments);
    this.fuseDist = params_ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(1e-3);
    this.viscosity = params_ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(0.1, {
      range: [0, 1],
      rangeLocked: [true, false],
      expression: { forEntities: true }
    });
    this.spring = params_ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(2, {
      range: [0, 5],
      rangeLocked: [true, false],
      expression: { forEntities: true }
    });
  }
}
const ClothPrepare_ParamsConfig = new ClothPrepareSopParamsConfig();
class ClothPrepareSopNode extends sop_Base/* TypedSopNode */.x {
  constructor() {
    super(...arguments);
    this.paramsConfig = ClothPrepare_ParamsConfig;
  }
  static type() {
    return Sop/* SopType.CLOTH_PREPARE */.aB.CLOTH_PREPARE;
  }
  initializeNode() {
    this.io.inputs.setCount(1);
    this.io.inputs.initInputsClonedState(InputCloneMode/* InputCloneMode.FROM_NODE */.m.FROM_NODE);
  }
  cook(inputCoreGroups) {
    return ClothPrepare_async(this, null, function* () {
      const coreGroup = inputCoreGroups[0];
      const inputMeshes = coreGroup.threejsObjectsWithGeo();
      for (const inputMesh of inputMeshes) {
        const geometry = inputMesh.geometry;
        if (!geometry) {
          return;
        }
        this._applyFuse(inputMesh);
        this._addIdAttribute(inputMesh);
        this._addViscosityAttribute(inputMesh);
        this._addSpringAttribute(inputMesh);
        this._addAdjacencyAttributes(inputMesh);
      }
      this.setCoreGroup(coreGroup);
    });
  }
  _applyFuse(mesh) {
    (0,Fuse/* mergeFaces */.X)(mesh.geometry, this.pv.fuseDist);
  }
  _addIdAttribute(mesh) {
    return ClothPrepare_async(this, null, function* () {
      const geometry = mesh.geometry;
      const positionAttrib = geometry.getAttribute(geometry_Attribute/* Attribute.POSITION */.ah.POSITION);
      if (!positionAttrib) {
        return;
      }
      const pointsCount = positionAttrib.count;
      const idValues = new Array(pointsCount);
      for (let i = 0; i < pointsCount; i++) {
        idValues[i] = i;
      }
      const idArray = new Float32Array(idValues);
      geometry.setAttribute(geometry_Attribute/* Attribute.ID */.ah.ID, new three_module.BufferAttribute(idArray, 1));
    });
  }
  _addViscosityAttribute(mesh) {
    return ClothPrepare_async(this, null, function* () {
      yield this._addFloatAttribute(mesh, this.p.viscosity, ClothGeometryAttributeName.VISCOSITY);
    });
  }
  _addSpringAttribute(mesh) {
    return ClothPrepare_async(this, null, function* () {
      yield this._addFloatAttribute(mesh, this.p.spring, ClothGeometryAttributeName.SPRING);
    });
  }
  _addFloatAttribute(mesh, param, attribName) {
    return ClothPrepare_async(this, null, function* () {
      const corePointClass = (0,CoreObjectFactory/* corePointClassFactory */.E_)(mesh);
      if (param.hasExpression() && param.expressionController) {
        if (!corePointClass.hasAttribute(mesh, attribName)) {
          corePointClass.addNumericAttribute(mesh, attribName, 1, param.value);
        }
        const attrib = corePointClass.attribute(mesh, attribName);
        attrib.needsUpdate = true;
        const array = attrib.array;
        const points = [];
        (0,CorePointUtils/* pointsFromObject */.u_)(mesh, points);
        yield param.expressionController.computeExpressionForPoints(points, (point, value) => {
          array[point.index()] = value;
        });
      } else {
        corePointClass.addNumericAttribute(mesh, attribName, 1, param.value);
      }
    });
  }
  _addAdjacencyAttributes(mesh) {
    (0,Adjacency/* populateAdjacency3 */.w3)(mesh, Adjacency/* POPULATE_ADJACENCY_DEFAULT */.Vc);
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/core/cloth/glsl/common/packPosition.glsl
/* harmony default export */ var packPosition = ("// pack float16 position into float32\nvec3 packPosition( vec2 uv ) {\n\n\treturn ( texture2D( tPosition0, uv ).xyz + texture2D( tPosition1, uv ).xyz ) / 1024.0;\n\n}");
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/core/cloth/glsl/common/unpackPosition.glsl
/* harmony default export */ var unpackPosition = ("\nvec3 unpackPosition( vec3 pos, float order ) {\n\n\tpos *= 1024.0;\n\n\treturn ( order > 0.0 ) ? floor( pos ) : fract( pos );\n\n}\n\nvec4 unpackPosition( vec4 pos, float order ) {\n\n\tpos *= 1024.0;\n\n\treturn ( order > 0.0 ) ? floor( pos ) : fract( pos );\n\n}");
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/core/cloth/glsl/through.vert.glsl
/* harmony default export */ var through_vert = ("precision highp float;\n\nattribute vec2 position;\n\nvoid main() {\n\n\tgl_Position = vec4( position, vec2(1.0) );\n\n}\n");
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/core/cloth/glsl/through.frag.glsl
/* harmony default export */ var through_frag = ("precision highp float;\nprecision highp sampler2D;\n\nuniform vec2 tSize;\nuniform float order;\nuniform sampler2D texture;\n\n// *** ADD COMMON ***\n\nvoid main() {\n\n\tvec2 uv = gl_FragCoord.xy / tSize.xy;\n\n\tgl_FragColor = unpackPosition( texture2D( texture, uv ), order );\n\n}\n");
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/core/cloth/glsl/constraints.frag.glsl
/* harmony default export */ var constraints_frag = ("precision highp float;\nprecision highp sampler2D;\n\nuniform vec2 tSize;\nuniform float order;\nuniform float constraintInfluence;\nuniform sampler2D tPosition0;\nuniform sampler2D tPosition1;\n\nuniform sampler2D tDistancesA;\nuniform sampler2D tDistancesB;\n\nuniform sampler2D tAdjacentsA;\nuniform sampler2D tAdjacentsB;\n\n\n\n// compute offset based on current distance and spring rest distance\nvec3 getDisplacement( vec3 point0, vec3 point1, float restDistance ) {\n\n\tfloat curDistance = distance( point0, point1 );\n\treturn constraintInfluence * ( curDistance - restDistance ) * ( point1 - point0 ) / curDistance;\n\n}\n\n// *** ADD COMMON ***\n\nvec2 getUV( float id ) {\n\treturn getClothSolverUV( id, tSize );\n}\n\n\nvoid main() {\n\n\tvec3 displacement;\n\tvec2 uv = gl_FragCoord.xy / tSize.xy;\n\n\t// indices of adjacent vertices\n\tvec4 adjacentA = texture2D( tAdjacentsA, uv );\n\tvec4 adjacentB = texture2D( tAdjacentsB, uv );\n\n\t// distances of adjacent vertices\n\tvec4 distancesA = texture2D( tDistancesA, uv );\n\tvec4 distancesB = texture2D( tDistancesB, uv );\n\n\t// vertex position\n\tvec3 p0 = packPosition( uv );\n\tfloat count = 0.0;\n\n\t// adjacent vertices positions\n\tfloat Ax = adjacentA.x;\n\tif( Ax >= 0.0 ){\n\t\tvec3 p1 = packPosition( getUV( Ax ) );\n\t\tdisplacement += getDisplacement( p0, p1, distancesA.x );\n\t\tcount += 1.0;\n\t}\n\tfloat Ay = adjacentA.y;\n\tif( Ay >= 0.0 ){\n\t\tvec3 p2 = packPosition( getUV( adjacentA.y ) );\n\t\tdisplacement += getDisplacement( p0, p2, distancesA.y );\n\t\tcount += 1.0;\n\t}\n\tfloat Az = adjacentA.z;\n\tif( Az >= 0.0 ){\n\t\tvec3 p3 = packPosition( getUV( adjacentA.z ) );\n\t\tdisplacement += getDisplacement( p0, p3, distancesA.z );\n\t\tcount += 1.0;\n\t}\n\tfloat Aw = adjacentA.w;\n\tif( Aw >= 0.0 ){\n\t\tvec3 p4 = packPosition( getUV( adjacentA.w ) );\n\t\tdisplacement += getDisplacement( p0, p4, distancesA.w );\n\t\tcount += 1.0;\n\t}\n\n\tfloat Bx = adjacentB.x;\n\tif( Bx >= 0.0 ){\n\t\tvec3 p5 = packPosition( getUV( Bx ) );\n\t\tdisplacement += getDisplacement( p0, p5, distancesB.x );\n\t\tcount += 1.0;\n\t}\n\tfloat By = adjacentB.y;\n\tif( By >= 0.0 ){\n\t\tvec3 p6 = packPosition( getUV( By ) );\n\t\tdisplacement += getDisplacement( p0, p6, distancesB.y );\n\t\tcount += 1.0;\n\t}\n\tfloat Bz = adjacentB.z;\n\tif( Bz >= 0.0 ){\n\t\tvec3 p7 = packPosition( getUV( Bz ) );\n\t\tdisplacement += getDisplacement( p0, p7, distancesB.z );\n\t\tcount += 1.0;\n\t}\n\tfloat Bw = adjacentB.w;\n\tif( Bw >= 0.0 ){\n\t\tvec3 p8 = packPosition( getUV( Bw ) );\n\t\tdisplacement += getDisplacement( p0, p8, distancesB.w );\n\t\tcount += 1.0;\n\t}\n\n\tp0 += displacement / count;\n\n\tgl_FragColor = vec4( unpackPosition( p0, order ), 1.0 );\n\n}\n");
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/core/cloth/glsl/mouse.frag.glsl
/* harmony default export */ var mouse_frag = ("precision highp float;\nprecision highp sampler2D;\n\nuniform float vertex;\nuniform vec3 coordinates;\n\nuniform vec2 tSize;\nuniform float order;\nuniform sampler2D tPosition0;\nuniform sampler2D tPosition1;\nuniform sampler2D tOriginal;\n\n// *** ADD COMMON ***\n\nvec2 getUV( float id ) {\n\treturn getClothSolverUV( id, tSize );\n}\n\nvoid main() {\n\n\tvec2 uv = gl_FragCoord.xy / tSize.xy;\n\n\tvec3 position = packPosition( uv );\n\tvec3 original = texture2D( tOriginal, uv ).xyz;\n\n\tvec3 ref, diff, proj, offset;\n\n\tif ( vertex != - 1.0 ){\n\n\t\tref = texture2D( tOriginal, getUV( vertex ) ).xyz;\n\t\toffset = coordinates - ref;\n\n\t\tif ( distance( original, ref ) <= 0.1 ) {\n\n\t\t\tdiff = ref - original;\n\n\t\t\tproj = dot( diff, offset ) / dot( offset, offset ) * original;\n\n\t\t\tposition = original + proj + offset;\n\n\t\t}\n\t}\n\n\tgl_FragColor = vec4( unpackPosition( position, order ), 1.0 );\n\n}\n");
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/core/cloth/glsl/normals.frag.glsl
/* harmony default export */ var normals_frag = ("precision highp float;\nprecision highp sampler2D;\n\nuniform vec2 tSize;\n\nuniform sampler2D tPosition0;\nuniform sampler2D tPosition1;\n\nuniform sampler2D tAdjacentsA;\nuniform sampler2D tAdjacentsB;\n\n// *** ADD COMMON ***\n\nvec2 getUV( float id ) { \n\treturn getClothSolverUV( id, tSize );\n}\n\nvoid main () {\n\n\tvec3 normal;\n\tvec2 uv = gl_FragCoord.xy / tSize.xy;\n\n\t// indices of adjacent vertices\n\tvec4 adjacentA = texture2D( tAdjacentsA, uv );\n\tvec4 adjacentB = texture2D( tAdjacentsB, uv );\n\n\t// vertex position\n\tvec3 p0 = ( texture2D( tPosition0, uv ).xyz + texture2D( tPosition1, uv ).xyz ) / 1024.0;\n\n\t// adjacent vertices positions\n\tvec3 p1 = packPosition( getUV( adjacentA.x ) );\n\tvec3 p2 = packPosition( getUV( adjacentA.y ) );\n\tvec3 p3 = packPosition( getUV( adjacentA.z ) );\n\tvec3 p4 = packPosition( getUV( adjacentA.w ) );\n\n\t// compute vertex normal contribution\n\tnormal += cross( p1 - p0, p2 - p0 );\n\tnormal += cross( p2 - p0, p3 - p0 );\n\tnormal += cross( p3 - p0, p4 - p0 );\n\n\tfloat Bx = adjacentB.x;\n\tvec3 p5 = Bx >= 0.0 ? packPosition( getUV( Bx ) ) : vec3(0.0);\n\tif( Bx >= 0.0 ){\n\t\tnormal += cross( p4 - p0, p5 - p0 );\n\t}\n\tfloat By = adjacentB.y;\n\tvec3 p6 = By >= 0.0 ? packPosition( getUV( By ) ) : vec3(0.0);\n\tif( By >= 0.0 ){\n\t\tnormal += cross( p5 - p0, p6 - p0 );\n\t}\n\tfloat Bz = adjacentB.z;\n\tvec3 p7 = Bz >= 0.0 ? packPosition( getUV( Bz ) ) : vec3(0.0);\n\tif( Bz >= 0.0 ){\n\t\tnormal += cross( p6 - p0, p7 - p0 );\n\t}\n\tfloat Bw = adjacentB.w;\n\tvec3 p8 = Bw >= 0.0 ? packPosition( getUV( Bw ) ) : vec3(0.0);\n\tif( Bw >= 0.0 ){\n\t\tnormal += cross( p7 - p0, p8 - p0 );\n\t}\n\n\tgl_FragColor = vec4( normalize( normal ), 1.0 );\n}");
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/core/cloth/modules/ClothMaterialsController.ts









const LINE_BREAK = "\n";
const ADD_COMMON_LINE = "// *** ADD COMMON ***";
function _addCommon(core, commonFunctions) {
  const common = commonFunctions.join(LINE_BREAK);
  return core.replace(ADD_COMMON_LINE, common);
}
const THROUGH_FRAG = _addCommon(through_frag, [unpackPosition]);
const CONTRAINTS_FRAG = _addCommon(constraints_frag, [getUV, packPosition, unpackPosition]);
const MOUSE_FRAG = _addCommon(mouse_frag, [getUV, packPosition, unpackPosition]);
const NORMALS_FRAG = _addCommon(normals_frag, [getUV, packPosition, unpackPosition]);

function createRawMaterial() {
  return new three_module.RawShaderMaterial({
    uniforms: {
      order: { value: null },
      tSize: { value: new three_module.Vector2() },
      texture: { value: null }
    },
    vertexShader: through_vert,
    fragmentShader: THROUGH_FRAG,
    fog: false,
    lights: false,
    depthWrite: false,
    depthTest: false
  });
}
class ClothMaterialController {
  constructor(mainController) {
    this.mainController = mainController;
    // copyToRenderTarget
    this.copyShader = createRawMaterial();
    // forward-integration
    this.integrateShader = createRawMaterial();
    // mouse displacement
    this.mouseShader = createRawMaterial();
    // vertices relaxation
    this.constraintsShader = createRawMaterial();
    // calculate normals
    this.normalsShader = createRawMaterial();
    const integrationFragmentShader = this.mainController.integrationFragmentShader();
    if (!integrationFragmentShader) {
      throw "no integrationFragmentShader";
    }
    this.integrateShader.fragmentShader = _addCommon(integrationFragmentShader, [unpackPosition]);
    this.integrateShader.uniforms = {
      timeDelta: this.mainController.scene.timeController.timeDeltaUniform(),
      time: this.mainController.scene.timeController.timeUniform(),
      viscosity: { value: 0.1 },
      spring: { value: 1 },
      tSize: { value: new three_module.Vector2() },
      order: { value: -1 },
      tOriginal: { value: null },
      tPrevious0: { value: null },
      tPrevious1: { value: null },
      tPosition0: { value: null },
      tPosition1: { value: null },
      tViscositySpring: { value: null }
    };
    this.mainController.addMaterialUniforms(this.integrateShader);
    this.mouseShader.fragmentShader = MOUSE_FRAG;
    this.mouseShader.uniforms = {
      time: this.mainController.scene.timeController.timeUniform(),
      vertex: { value: -1 },
      coordinates: { value: new three_module.Vector3() },
      order: { value: -1 },
      tSize: { value: new three_module.Vector2() },
      tOriginal: { value: null },
      tPosition0: { value: null },
      tPosition1: { value: null }
    };
    this.constraintsShader.fragmentShader = CONTRAINTS_FRAG;
    this.constraintsShader.uniforms = {
      time: this.mainController.scene.timeController.timeUniform(),
      tSize: { value: new three_module.Vector2() },
      order: { value: -1 },
      constraintInfluence: { value: 0 },
      tPosition0: { value: null },
      tPosition1: { value: null },
      tAdjacentsA: { value: null },
      tAdjacentsB: { value: null },
      tDistancesA: { value: null },
      tDistancesB: { value: null },
      secondaryMotionMult: { value: 0 }
    };
    this.normalsShader.fragmentShader = NORMALS_FRAG;
    this.normalsShader.uniforms = {
      tSize: { value: new three_module.Vector2() },
      tPosition0: { value: null },
      tPosition1: { value: null },
      tAdjacentsA: { value: null },
      tAdjacentsB: { value: null }
    };
  }
}

// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/core/geometry/operation/TextureFromAttribute.ts
var TextureFromAttribute = __webpack_require__(52598);
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/core/cloth/modules/ClothGeometryInitController.ts





class ClothGeometryInitController {
  constructor(mesh) {
    this.mesh = mesh;
    this.adjacency = [];
    this.resolution = new three_module.Vector2();
    this.geometry = mesh.geometry;
    ThreeMeshBVHHelper/* ThreeMeshBVHHelper.assignDefaultBVHIfNone */.h.assignDefaultBVHIfNone(this.mesh);
    this.adjacency = (0,Adjacency/* unpackAdjacency3 */.uf)(this.mesh, Adjacency/* POPULATE_ADJACENCY_DEFAULT */.Vc);
    (0,TextureFromAttribute/* textureSizeFromPointsCount */.DK)(this.geometry, this.resolution);
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/core/cloth/modules/ClothAttributeToTexture.ts





const ClothAttributeToTexture_v3 = new three_module.Vector3();
const _v3b = new three_module.Vector3();
function positionTexture(geometry, resolution) {
  const data = new Float32Array(resolution.x * resolution.y * 4);
  const positionAttribute = geometry.getAttribute(geometry_Attribute/* Attribute.POSITION */.ah.POSITION);
  const array = positionAttribute.array;
  const pointsCount = positionAttribute.count;
  for (let i = 0; i < pointsCount; i++) {
    ClothAttributeToTexture_v3.fromArray(array, i * 3);
    const i4 = i * 4;
    ClothAttributeToTexture_v3.toArray(data, i4);
  }
  const texture = new three_module.DataTexture(data, resolution.x, resolution.y, three_module.RGBAFormat, three_module.FloatType);
  texture.needsUpdate = true;
  return texture;
}
function adjacencyTexture(geometry, resolution, adjacency, k) {
  const data = new Float32Array(resolution.x * resolution.y * 4);
  const positionAttribute = geometry.getAttribute(geometry_Attribute/* Attribute.POSITION */.ah.POSITION);
  const pointsCount = positionAttribute.count;
  for (let i = 0; i < pointsCount; i++) {
    const i4 = i * 4;
    const adj = adjacency[i];
    for (let j = 0; j < 4; j++) {
      const adjacentIndex = adj[k * 4 + j];
      if (adjacentIndex != null) {
        data[i4 + j] = adjacentIndex;
      } else {
        data[i4 + j] = -1;
      }
    }
  }
  const texture = new three_module.DataTexture(data, resolution.x, resolution.y, three_module.RGBAFormat, three_module.FloatType);
  texture.needsUpdate = true;
  return texture;
}
function distancesTexture(geometry, resolution, adjacency, k) {
  const data = new Float32Array(resolution.x * resolution.y * 4).fill(-1);
  const positionAttribute = geometry.getAttribute(geometry_Attribute/* Attribute.POSITION */.ah.POSITION);
  const pointsCount = positionAttribute.count;
  const array = positionAttribute.array;
  for (let i = 0; i < pointsCount; i++) {
    ClothAttributeToTexture_v3.fromArray(array, i * 3);
    const i4 = i * 4;
    const adj = adjacency[i];
    const len = adj.length - 1;
    for (let j = 0; j < 4; j++) {
      if (len < k * 4 + j) {
        data[i4 + j] = -1;
      } else {
        const adjacentIndex = adj[k * 4 + j];
        if (adjacentIndex < 0) {
          data[i4 + j] = -1;
        } else {
          _v3b.fromArray(array, adjacentIndex * 3);
          const dist = ClothAttributeToTexture_v3.distanceTo(_v3b);
          data[i4 + j] = dist;
          if (dist < 1e-4) {
            console.log("bad dist");
          }
        }
      }
    }
  }
  const texture = new three_module.DataTexture(data, resolution.x, resolution.y, three_module.RGBAFormat, three_module.FloatType);
  texture.needsUpdate = true;
  return texture;
}
function viscositySpringTexture(geometry, resolution) {
  return (0,TextureFromAttribute/* textureFromAttributes */.K0)(geometry, [ClothGeometryAttributeName.VISCOSITY, ClothGeometryAttributeName.SPRING]);
}
function createTexturesFromAllocation(geometry, resolution, allocationsController) {
  const data = {};
  const positionAttribute = geometry.getAttribute(geometry_Attribute/* Attribute.POSITION */.ah.POSITION);
  const pointsCount = positionAttribute.count;
  allocationsController.readonlyAllocations().forEach((allocation) => {
    var _a;
    const textureData = new Float32Array(resolution.x * resolution.y * 4);
    const texture = new three_module.DataTexture(textureData, resolution.x, resolution.y, three_module.RGBAFormat, three_module.FloatType);
    data[allocation.textureName()] = texture;
    let offset = 0;
    (_a = allocation.variables()) == null ? void 0 : _a.forEach((variable) => {
      const attribName = variable.name();
      const attribSize = variable.size();
      const attribute = geometry.getAttribute(attribName);
      if (attribute) {
        const array = attribute.array;
        for (let i = 0; i < pointsCount; i++) {
          const i4 = i * 4 + offset;
          for (let j = 0; j < attribSize; j++) {
            textureData[i4 + j] = array[i * attribSize + j];
          }
        }
        texture.needsUpdate = true;
      }
      offset += attribSize;
    });
  });
  return data;
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/core/cloth/modules/ClothFBOController.ts



function clothMaterialCopyConfigRef(src, target) {
  target.tSize.value.copy(src.tSize.value);
}
function textureContainerToRef(src, ref) {
  if (src.texture) {
    ref.value = src.texture;
  }
}
class ClothFBOController {
  constructor(mainController) {
    this.mainController = mainController;
    this.tSize = new three_module.Vector2();
    this.fboScene = new three_module.Scene();
    this.fboCamera = new three_module.OrthographicCamera();
    this.RESOLUTION = new three_module.Vector2();
    this.originalRT = { texture: null };
    this.viscositySpringT = { texture: null };
    this.previousRT = new Array(2);
    this.targetRT = new Array(2);
    this.positionRT = new Array(2);
    this.adjacentsRT = new Array(2);
    this.distancesRT = new Array(2);
    this._initialized = false;
    this.RESOLUTION.copy(this.mainController.geometryInit.resolution);
    this.tSize.set(this.RESOLUTION.x, this.RESOLUTION.y);
    const geometry = new three_module.BufferGeometry();
    const positions = new Float32Array([-1, -1, 3, -1, -1, 3]);
    geometry.setAttribute("position", new three_module.BufferAttribute(positions, 2));
    geometry.boundingSphere = new three_module.Sphere(new three_module.Vector3(0, 0, 0), 5);
    this.fboMesh = new three_module.Mesh(geometry, this.mainController.materials.copyShader);
    this.fboMesh.frustumCulled = false;
    this.fboScene.add(this.fboMesh);
    this.fboScene.updateMatrixWorld = function() {
    };
    this.normalsRT = createRenderTarget(this.RESOLUTION);
  }
  init(renderer) {
    if (this._initialized) {
      return;
    }
    this._initialized = true;
    this.renderer = renderer;
    const originalRenderTarget = renderer.getRenderTarget();
    this.createPositionTexture();
    this.createViscositySpringTexture();
    this.createTexturesFromAllocation();
    for (let i = 0; i < 2; i++) {
      this.createAdjacentsTexture(i);
      this.createDistancesTexture(i);
      this.positionRT[i] = createRenderTarget(this.RESOLUTION);
      this.previousRT[i] = createRenderTarget(this.RESOLUTION);
      this.targetRT[i] = createRenderTarget(this.RESOLUTION);
      this.copyTexture(this.originalRT, this.positionRT[i], !i, renderer);
      this.copyTexture(this.originalRT, this.previousRT[i], !i, renderer);
    }
    renderer.setRenderTarget(originalRenderTarget);
  }
  copyTexture(input, output, order, renderer) {
    const copyShader = this.mainController.materials.copyShader;
    this.fboMesh.material = copyShader;
    copyShader.uniforms.order.value = order ? 1 : -1;
    copyShader.uniforms.tSize.value = this.tSize;
    copyShader.uniforms.texture.value = input.texture;
    renderer.setRenderTarget(output);
    renderer.render(this.fboScene, this.fboCamera);
  }
  //
  //
  // create textures
  //
  //
  createPositionTexture() {
    this.originalRT = {
      texture: positionTexture(
        this.mainController.geometryInit.geometry,
        // this.mainController.geometryInit.vertices,
        this.RESOLUTION
      )
    };
  }
  createViscositySpringTexture() {
    const texture = viscositySpringTexture(this.mainController.geometryInit.geometry, this.RESOLUTION);
    if (texture) {
      this.viscositySpringT = {
        texture
      };
    }
  }
  createTexturesFromAllocation() {
    const allocation = this.mainController.textureAllocationsController();
    if (!allocation) {
      return;
    }
    const texturesByName = createTexturesFromAllocation(
      this.mainController.geometryInit.geometry,
      this.RESOLUTION,
      allocation
    );
    this.mainController.assignReadonlyTextures(this.mainController.materials.integrateShader, texturesByName);
  }
  createAdjacentsTexture(k) {
    this.adjacentsRT[k] = {
      texture: adjacencyTexture(
        this.mainController.geometryInit.geometry,
        this.RESOLUTION,
        this.mainController.geometryInit.adjacency,
        k
      )
    };
  }
  createDistancesTexture(k) {
    this.distancesRT[k] = {
      texture: distancesTexture(
        this.mainController.geometryInit.geometry,
        // this.mainController.geometryInit.vertices,
        this.RESOLUTION,
        this.mainController.geometryInit.adjacency,
        k
      )
    };
  }
  //
  //
  // update
  //
  //
  update(config) {
    const renderer = this.renderer;
    if (!(renderer && this._initialized)) {
      return;
    }
    const originalRenderTarget = renderer.getRenderTarget();
    this.integrate(renderer);
    const selectedVertexIndex = this.mainController.selectedVertexIndex();
    const steps = this.mainController.stepsCount;
    for (let i = 0; i < steps; i++) {
      if (selectedVertexIndex >= 0 && i < steps - 5) {
        this.mouseOffset(renderer);
      }
      this.solveConstraints(renderer, i == steps - 1 ? 1 : 0);
    }
    this.computeVertexNormals(renderer);
    renderer.setRenderTarget(originalRenderTarget);
    if (config) {
      this._updateTextureRefs(config);
    }
  }
  _updateTextureRefs(config) {
    config.tSize.value = this.mainController.fbo.tSize;
    config.tPosition0.value = this.positionRT[0].texture;
    config.tPosition1.value = this.positionRT[1].texture;
    config.tNormal.value = this.normalsRT.texture;
    textureContainerToRef(this.originalRT, config.tOriginalRT);
    textureContainerToRef(this.viscositySpringT, config.tViscositySpringT);
    config.tPreviousRT0.value = this.previousRT[0].texture;
    config.tPreviousRT1.value = this.previousRT[1].texture;
    config.tTargetRT0.value = this.targetRT[0].texture;
    config.tTargetRT1.value = this.targetRT[1].texture;
    config.tNormalsRT.value = this.normalsRT.texture;
    config.tPositionRT0.value = this.positionRT[0].texture;
    config.tPositionRT1.value = this.positionRT[1].texture;
    textureContainerToRef(this.adjacentsRT[0], config.tAdjacentsRT0);
    textureContainerToRef(this.adjacentsRT[1], config.tAdjacentsRT1);
    textureContainerToRef(this.distancesRT[0], config.tDistanceRT0);
    textureContainerToRef(this.distancesRT[1], config.tDistanceRT1);
    config.integrationMat.value = this.mainController.materials.integrateShader;
  }
  integrate(renderer) {
    const integrateShader = this.mainController.materials.integrateShader;
    this.fboMesh.material = integrateShader;
    integrateShader.uniforms.viscosity.value = this.mainController.viscosity;
    integrateShader.uniforms.spring.value = this.mainController.spring;
    integrateShader.uniforms.tSize.value.copy(this.tSize);
    integrateShader.uniforms.tOriginal.value = this.originalRT.texture;
    integrateShader.uniforms.tPrevious0.value = this.previousRT[0].texture;
    integrateShader.uniforms.tPrevious1.value = this.previousRT[1].texture;
    integrateShader.uniforms.tPosition0.value = this.positionRT[0].texture;
    integrateShader.uniforms.tPosition1.value = this.positionRT[1].texture;
    integrateShader.uniforms.tViscositySpring.value = this.viscositySpringT.texture;
    integrateShader.uniforms.order.value = 1;
    renderer.setRenderTarget(this.targetRT[0]);
    renderer.render(this.fboScene, this.fboCamera);
    integrateShader.uniforms.order.value = -1;
    renderer.setRenderTarget(this.targetRT[1]);
    renderer.render(this.fboScene, this.fboCamera);
    let tmp = this.previousRT[0];
    this.previousRT[0] = this.positionRT[0];
    this.positionRT[0] = this.targetRT[0];
    this.targetRT[0] = tmp;
    tmp = this.previousRT[1];
    this.previousRT[1] = this.positionRT[1];
    this.positionRT[1] = this.targetRT[1];
    this.targetRT[1] = tmp;
  }
  solveConstraints(renderer, secondaryMotionMult) {
    const constraintsShader = this.mainController.materials.constraintsShader;
    this.fboMesh.material = constraintsShader;
    constraintsShader.uniforms.constraintInfluence.value = this.mainController.constraintInfluence;
    constraintsShader.uniforms.tSize.value.copy(this.tSize);
    constraintsShader.uniforms.tPosition0.value = this.positionRT[0].texture;
    constraintsShader.uniforms.tPosition1.value = this.positionRT[1].texture;
    constraintsShader.uniforms.tAdjacentsA.value = this.adjacentsRT[0].texture;
    constraintsShader.uniforms.tAdjacentsB.value = this.adjacentsRT[1].texture;
    constraintsShader.uniforms.tDistancesA.value = this.distancesRT[0].texture;
    constraintsShader.uniforms.tDistancesB.value = this.distancesRT[1].texture;
    constraintsShader.uniforms.secondaryMotionMult.value = secondaryMotionMult;
    constraintsShader.uniforms.order.value = 1;
    renderer.setRenderTarget(this.targetRT[0]);
    renderer.render(this.fboScene, this.fboCamera);
    constraintsShader.uniforms.order.value = -1;
    renderer.setRenderTarget(this.targetRT[1]);
    renderer.render(this.fboScene, this.fboCamera);
    let tmp = this.positionRT[0];
    this.positionRT[0] = this.targetRT[0];
    this.targetRT[0] = tmp;
    tmp = this.positionRT[1];
    this.positionRT[1] = this.targetRT[1];
    this.targetRT[1] = tmp;
  }
  mouseOffset(renderer) {
    const mouseShader = this.mainController.materials.mouseShader;
    this.fboMesh.material = mouseShader;
    mouseShader.uniforms.tSize.value.copy(this.tSize);
    mouseShader.uniforms.vertex.value = this.mainController.selectedVertexIndex();
    this.mainController.constraintPosition(mouseShader.uniforms.coordinates.value);
    mouseShader.uniforms.tOriginal.value = this.originalRT.texture;
    mouseShader.uniforms.tPosition0.value = this.positionRT[0].texture;
    mouseShader.uniforms.tPosition1.value = this.positionRT[1].texture;
    mouseShader.uniforms.order.value = 1;
    renderer.setRenderTarget(this.targetRT[0]);
    renderer.render(this.fboScene, this.fboCamera);
    mouseShader.uniforms.order.value = -1;
    renderer.setRenderTarget(this.targetRT[1]);
    renderer.render(this.fboScene, this.fboCamera);
    let tmp = this.positionRT[0];
    this.positionRT[0] = this.targetRT[0];
    this.targetRT[0] = tmp;
    tmp = this.positionRT[1];
    this.positionRT[1] = this.targetRT[1];
    this.targetRT[1] = tmp;
  }
  computeVertexNormals(renderer) {
    const normalsShader = this.mainController.materials.normalsShader;
    this.fboMesh.material = normalsShader;
    normalsShader.uniforms.tSize.value.copy(this.tSize);
    normalsShader.uniforms.tPosition0.value = this.positionRT[0].texture;
    normalsShader.uniforms.tPosition1.value = this.positionRT[1].texture;
    normalsShader.uniforms.tAdjacentsA.value = this.adjacentsRT[0].texture;
    normalsShader.uniforms.tAdjacentsB.value = this.adjacentsRT[1].texture;
    renderer.setRenderTarget(this.normalsRT);
    renderer.render(this.fboScene, this.fboCamera);
  }
}
function createRenderTarget(resolution) {
  return new three_module.WebGLRenderTarget(resolution.x, resolution.y, {
    wrapS: three_module.ClampToEdgeWrapping,
    wrapT: three_module.ClampToEdgeWrapping,
    minFilter: three_module.NearestFilter,
    magFilter: three_module.NearestFilter,
    format: three_module.RGBAFormat,
    type: three_module.HalfFloatType,
    // depthTest: false,
    // depthWrite: false,
    depthBuffer: false,
    stencilBuffer: false
  });
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/core/cloth/ClothController.ts






class ClothController {
  constructor(scene, _node, clothObject) {
    this.scene = scene;
    this._node = _node;
    this.clothObject = clothObject;
    //
    this.stepsCount = 40;
    this.constraintInfluence = 0.1;
    this.viscosity = 0.1;
    this.spring = 1;
    this._selectedVertexIndex = -1;
    this._selectedVertexPosition = new three_module.Vector3();
    this._node.initCoreClothControllerFromPersistedConfig(this);
    this.materials = new ClothMaterialController(this);
    this.geometryInit = new ClothGeometryInitController(this.clothObject);
    this.fbo = new ClothFBOController(this);
  }
  dispose() {
    if (this._persistedTextureAllocationsController) {
      this._persistedTextureAllocationsController.dispose();
      this._persistedTextureAllocationsController = void 0;
    }
  }
  setPersistedTextureAllocationController(controller) {
    this._persistedTextureAllocationsController = controller;
  }
  integrationFragmentShader() {
    let fragmentShader;
    this._node.shadersByName().forEach((shader, shaderName) => {
      fragmentShader = shader;
    });
    return fragmentShader;
  }
  textureAllocationsController() {
    var _a;
    const node = this._node;
    return ((_a = node.assemblerController()) == null ? void 0 : _a.assembler.textureAllocationsController()) || this._persistedTextureAllocationsController;
  }
  assignReadonlyTextures(material, texturesByName) {
    const textureNames = Object.keys(texturesByName);
    for (const textureName of textureNames) {
      const texture = texturesByName[textureName];
      const uniformName = textureName;
      material.uniforms[uniformName] = { value: texture };
    }
  }
  addMaterialUniforms(material) {
    var _a;
    const node = this._node;
    const assembler = (_a = node.assemblerController()) == null ? void 0 : _a.assembler;
    if (assembler) {
      for (const param_config of assembler.param_configs()) {
        material.uniforms[param_config.uniformName()] = param_config.uniform();
      }
    } else {
      const persisted_data = node.persisted_config.loaded_data();
      if (persisted_data) {
        const persisted_uniforms = node.persisted_config.uniforms();
        if (persisted_uniforms) {
          const param_uniform_pairs = persisted_data.param_uniform_pairs;
          for (const pair of param_uniform_pairs) {
            const param_name = pair[0];
            const uniform_name = pair[1];
            const param = node.params.get(param_name);
            const uniform = persisted_uniforms[uniform_name];
            material.uniforms[uniform_name] = uniform;
            if (param && uniform) {
              const callback = () => {
                GLParamConfig/* GlParamConfig.callback */.b.callback(param, material.uniforms[uniform_name]);
              };
              param.options.setOption("callback", callback);
              callback();
            }
          }
        }
      }
    }
  }
  init(renderer) {
    this.fbo.init(renderer);
  }
  update(config) {
    this.fbo.update(config);
  }
  _setSelectedVertexIndex(index) {
    if (index == null) {
      this._selectedVertexIndex = -1;
    } else {
      this._selectedVertexIndex = index;
    }
  }
  createConstraint(index) {
    this._setSelectedVertexIndex(index);
  }
  deleteConstraint() {
    this._setSelectedVertexIndex(null);
  }
  selectedVertexIndex() {
    return this._selectedVertexIndex;
  }
  setConstraintPosition(position) {
    this._selectedVertexPosition.copy(position);
  }
  constraintPosition(target) {
    target.copy(this._selectedVertexPosition);
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/core/cloth/ClothControllerRegister.ts





const clothControllerByGraphNodeId = /* @__PURE__ */ new Map();
function createOrFindClothController(scene, node, clothObject) {
  let controller = clothControllerByGraphNodeId.get(clothObject.uuid);
  if (!controller) {
    if (!(clothObject instanceof three_module.Mesh)) {
      return;
    }
    controller = new ClothController(scene, node, clothObject);
    clothControllerByGraphNodeId.set(clothObject.uuid, controller);
  }
  return { controller };
}
function clothControllerNodeIdFromObject(clothObject) {
  const nodeId = (0,CoreObjectFactory/* coreObjectClassFactory */.Xr)(clothObject).attribValue(clothObject, ClothIdAttribute.OBJECT);
  return nodeId;
}
function clothControllerFromObject(clothObject) {
  return clothControllerByGraphNodeId.get(clothObject.uuid);
}

// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/nodes/gl/code/utils/TextureAllocationsController.ts
var TextureAllocationsController = __webpack_require__(20969);
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/gl/code/assemblers/cloth/ClothPersistedConfig.ts

var ClothPersistedConfig_async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};



class ClothPersistedConfig extends BasePersistedConfig/* BasePersistedConfig */.p {
  constructor(node) {
    super(node);
    this.node = node;
  }
  toData() {
    return ClothPersistedConfig_async(this, null, function* () {
      const assemblerController = this.node.assemblerController();
      if (!assemblerController) {
        return;
      }
      const shaders_by_name = {};
      const node_shaders_by_name = this.node.shadersByName();
      node_shaders_by_name.forEach((shader, shader_name) => {
        shaders_by_name[shader_name] = shader;
      });
      const texture_allocations_data = assemblerController.assembler.textureAllocationsController().toJSON(this.node.scene());
      const param_uniform_pairs = [];
      const uniforms_owner = new three_module.ShaderMaterial();
      const param_configs = assemblerController.assembler.param_configs();
      for (let param_config of param_configs) {
        param_uniform_pairs.push([param_config.name(), param_config.uniformName()]);
        uniforms_owner.uniforms[param_config.uniformName()] = param_config.uniform();
      }
      const material_data = this._materialToJson(uniforms_owner, {
        node: this.node,
        suffix: "main"
      });
      const data = {
        texture_allocations: texture_allocations_data,
        param_uniform_pairs,
        uniforms_owner: material_data || {},
        shaders: shaders_by_name
      };
      return data;
    });
  }
  load(data) {
    const assemblerController = this.node.assemblerController();
    if (assemblerController) {
      return;
    }
    this._loaded_data = data;
    this.node.init_with_persisted_config();
  }
  loaded_data() {
    return this._loaded_data;
  }
  shaders_by_name() {
    if (this._loaded_data) {
      const shaders_by_name = /* @__PURE__ */ new Map();
      const shaders = this._loaded_data.shaders;
      if (shaders) {
        const shader_names = Object.keys(shaders);
        for (let shader_name of shader_names) {
          shaders_by_name.set(shader_name, shaders[shader_name]);
        }
      }
      return shaders_by_name;
    }
  }
  texture_allocations_controller() {
    if (this._loaded_data) {
      return TextureAllocationsController/* TextureAllocationsController.fromJSON */.T.fromJSON(this._loaded_data.texture_allocations);
    }
  }
  uniforms() {
    if (this._loaded_data) {
      const uniforms_owner = this._loadMaterial(this._loaded_data.uniforms_owner);
      const uniforms = (uniforms_owner == null ? void 0 : uniforms_owner.uniforms) || {};
      return uniforms;
    }
  }
}

// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/nodes/gl/code/globals/Texture.ts
var globals_Texture = __webpack_require__(77642);
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/sop/ClothSolver.ts

var ClothSolver_async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};















class ClothSolverSopParamsConfig extends params_ParamsConfig/* NodeParamsConfig */.yI {
}
const ClothSolver_ParamsConfig = new ClothSolverSopParamsConfig();
class ClothSolverSopNode extends sop_Base/* TypedSopNode */.x {
  constructor() {
    super(...arguments);
    this.paramsConfig = ClothSolver_ParamsConfig;
    this._assemblerController = this._createAssemblerController();
    this.persisted_config = new ClothPersistedConfig(this);
    this._globalsHandler = new globals_Texture/* GlobalsTextureHandler */.f(
      globals_Texture/* GlobalsTextureHandler.PARTICLE_SIM_UV */.f.PARTICLE_SIM_UV,
      globals_Texture/* GlobalsTextureHandlerPurpose.PARTICLES_SHADER */.o.PARTICLES_SHADER
    );
    this._shadersByName = /* @__PURE__ */ new Map();
    this._childrenControllerContext = poly_NodeContext/* NodeContext.GL */.sy.GL;
  }
  static type() {
    return Sop/* SopType.CLOTH_SOLVER */.aB.CLOTH_SOLVER;
  }
  assemblerController() {
    return this._assemblerController;
  }
  usedAssembler() {
    return _BaseRegister/* AssemblerName.GL_CLOTH */.Q.GL_CLOTH;
  }
  _createAssemblerController() {
    return Poly/* Poly.assemblersRegister.assembler */.L.assemblersRegister.assembler(this, this.usedAssembler());
  }
  shadersByName() {
    return this._shadersByName;
  }
  initializeNode() {
    this.io.inputs.setCount(1);
    this.io.inputs.initInputsClonedState(InputCloneMode/* InputCloneMode.ALWAYS */.m.ALWAYS);
  }
  createNode(node_class, options) {
    return super.createNode(node_class, options);
  }
  children() {
    return super.children();
  }
  nodesByType(type) {
    return super.nodesByType(type);
  }
  childrenAllowed() {
    if (this.assemblerController()) {
      return super.childrenAllowed();
    }
    return false;
  }
  sceneReadonly() {
    return this.assemblerController() == null;
  }
  cook(inputCoreGroups) {
    return ClothSolver_async(this, null, function* () {
      this.compileIfRequired();
      const coreGroup = inputCoreGroups[0];
      const objects = coreGroup.allObjects();
      const object = objects[0];
      const existingActorIds = this.scene().actorsManager.objectActorNodeIds(object);
      if (existingActorIds == null || existingActorIds.length == 0) {
        this.states.error.set(`the input objects requires an actor node assigned to it`);
      }
      (0,CoreObjectFactory/* coreObjectClassFactory */.Xr)(object).addAttribute(object, ClothIdAttribute.OBJECT, this.graphNodeId());
      Poly/* Poly.onObjectsAddRemoveHooks.assignOnAddHookHandler */.L.onObjectsAddRemoveHooks.assignOnAddHookHandler(object, this);
      this.setObject(object);
    });
  }
  updateObjectOnAdd(object) {
    const clothSolverNodeId = (0,CoreObjectFactory/* coreObjectClassFactory */.Xr)(object).attribValue(object, ClothIdAttribute.OBJECT);
    if (clothSolverNodeId != null) {
      if (clothSolverNodeId != this.graphNodeId()) {
        return;
      }
      const clothObject = object;
      const result = createOrFindClothController(this.scene(), this, clothObject);
      if (!result) {
        return;
      }
      const { controller } = result;
      this.scene().renderersRegister.waitForRenderer().then((renderer) => {
        if (!renderer) {
          console.warn("no renderer");
          return;
        }
        if (!(renderer instanceof three_module.WebGLRenderer)) {
          console.warn("not a WebGLRenderer");
          return;
        }
        controller.init(renderer);
      });
    }
  }
  compileIfRequired() {
    var _a;
    if ((_a = this.assemblerController()) == null ? void 0 : _a.compileRequired()) {
      try {
        this.run_assembler();
      } catch (err) {
        const message = err.message || "failed to compile";
        this.states.error.set(message);
      }
    }
  }
  run_assembler() {
    const assemblerController = this.assemblerController();
    if (!assemblerController) {
      return;
    }
    const export_nodes = this._findExportNodes();
    if (export_nodes.length > 0) {
      const root_nodes = export_nodes;
      assemblerController.setAssemblerGlobalsHandler(this._globalsHandler);
      assemblerController.assembler.set_root_nodes(root_nodes);
      assemblerController.assembler.compile();
      assemblerController.post_compile();
    }
    const shadersByName = assemblerController.assembler.shaders_by_name();
    this._setShaderNames(shadersByName);
  }
  _setShaderNames(shadersByName) {
    this._shadersByName = shadersByName;
  }
  init_with_persisted_config() {
    const shaders_by_name = this.persisted_config.shaders_by_name();
    const texture_allocations_controller = this.persisted_config.texture_allocations_controller();
    if (shaders_by_name && texture_allocations_controller) {
      this._setShaderNames(shaders_by_name);
    }
  }
  initCoreClothControllerFromPersistedConfig(coreClothController) {
    const shaders_by_name = this.persisted_config.shaders_by_name();
    const texture_allocations_controller = this.persisted_config.texture_allocations_controller();
    if (shaders_by_name && texture_allocations_controller) {
      coreClothController.setPersistedTextureAllocationController(texture_allocations_controller);
    }
  }
  _findExportNodes() {
    const nodes = [];
    const outputNodes = NodeFinder/* GlNodeFinder.findOutputNodes */.W.findOutputNodes(this);
    if (outputNodes.length == 0) {
      this.states.error.set("one output node is required");
    }
    if (outputNodes.length > 1) {
      this.states.error.set("only one output node is allowed");
      return [];
    }
    const outputNode = outputNodes[0];
    if (outputNode) {
      nodes.push(outputNode);
    }
    return nodes;
  }
  // private _findActorNode() {
  // 	// if (isBooleanTrue(this.pv.useThisNode)) {
  // 	return this;
  // 	// } else {
  // 	// 	return this.pv.node.node() as ActorBuilderNode | undefined;
  // 	// }
  // }
}
function getClothControllerNodeFromWorldObject(clothObject, scene) {
  const nodeId = clothControllerNodeIdFromObject(clothObject);
  if (nodeId == null) {
    return;
  }
  const graphNode = scene.graph.nodeFromId(nodeId);
  if (!graphNode) {
    return;
  }
  const node = Type/* CoreType.isFunction */.MR.isFunction(graphNode.context) ? graphNode : null;
  if (!node) {
    return;
  }
  if (node.context() != poly_NodeContext/* NodeContext.SOP */.sy.SOP) {
    return;
  }
  if (node.type() != Sop/* SopType.CLOTH_SOLVER */.aB.CLOTH_SOLVER) {
    return;
  }
  return node;
}

// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/nodes/sop/Code.ts + 1 modules
var sop_Code = __webpack_require__(58793);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/nodes/sop/Color.ts + 1 modules
var sop_Color = __webpack_require__(14826);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/nodes/sop/Cone.ts
var Cone = __webpack_require__(52330);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/core/helpers/CameraHelper.ts
var CameraHelper = __webpack_require__(15745);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/node_modules/three/examples/jsm/shaders/HorizontalBlurShader.js
var HorizontalBlurShader = __webpack_require__(32502);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/node_modules/three/examples/jsm/shaders/VerticalBlurShader.js
var VerticalBlurShader = __webpack_require__(5912);
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/core/render/Blur.ts




const PLANE_WIDTH = 1;
const PLANE_HEIGHT = 1;
const CAMERA_HEIGHT = 1;
const BLUR_MULT = 1 / (256 * 1e3);
class CoreRenderBlur {
  constructor(res) {
    this._renderTargetBlur = this._createRenderTarget(res);
    this._camera = this._createCamera();
    this._blurPlane = this._createBlurPlane();
    this._horizontalBlurMaterial = new three_module.ShaderMaterial(HorizontalBlurShader/* HorizontalBlurShader */.P);
    this._horizontalBlurMaterial.depthTest = false;
    this._verticalBlurMaterial = new three_module.ShaderMaterial(VerticalBlurShader/* VerticalBlurShader */.Z);
    this._verticalBlurMaterial.depthTest = false;
  }
  dispose() {
    this._horizontalBlurMaterial.dispose();
    this._verticalBlurMaterial.dispose();
    this._renderTargetBlur.dispose();
  }
  setSize(w, h) {
    this._renderTargetBlur.setSize(w, h);
  }
  _createRenderTarget(res) {
    const renderTarget = new three_module.WebGLRenderTarget(res.x, res.y);
    renderTarget.texture.generateMipmaps = false;
    return renderTarget;
  }
  _createCamera() {
    const camera = new three_module.OrthographicCamera(
      -PLANE_WIDTH / 2,
      PLANE_WIDTH / 2,
      PLANE_HEIGHT / 2,
      -PLANE_HEIGHT / 2,
      0,
      CAMERA_HEIGHT
    );
    camera.position.z = CAMERA_HEIGHT * 0.5;
    return camera;
  }
  _createBlurPlane() {
    const planeGeometry = new three_module.PlaneGeometry(PLANE_WIDTH, PLANE_HEIGHT);
    const plane = new three_module.Mesh(planeGeometry);
    return plane;
  }
  applyBlur(renderTarget, renderer, amountH, amountV) {
    const mult = Math.max(this._renderTargetBlur.width, this._renderTargetBlur.height);
    this._horizontalBlurMaterial.uniforms.tDiffuse.value = renderTarget.texture;
    this._horizontalBlurMaterial.uniforms.h.value = amountH * mult * BLUR_MULT;
    this._blurPlane.material = this._horizontalBlurMaterial;
    renderer.setRenderTarget(this._renderTargetBlur);
    renderer.render(this._blurPlane, this._camera);
    this._verticalBlurMaterial.uniforms.tDiffuse.value = this._renderTargetBlur.texture;
    this._verticalBlurMaterial.uniforms.v.value = amountV * mult * BLUR_MULT;
    this._blurPlane.material = this._verticalBlurMaterial;
    renderer.setRenderTarget(renderTarget);
    renderer.render(this._blurPlane, this._camera);
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/core/contactShadows/ContactShadow.ts





function _createRenderTarget(res) {
  const renderTarget = new three_module.WebGLRenderTarget(res.x, res.y);
  renderTarget.texture.generateMipmaps = false;
  renderTarget.texture.repeat.set(1, -1);
  renderTarget.texture.wrapS = renderTarget.texture.wrapT = three_module.RepeatWrapping;
  return renderTarget;
}
function _createCoreRenderBlur(res) {
  return new CoreRenderBlur(res);
}
const _center = new three_module.Vector3();
const _size = new three_module.Vector3();
class ContactShadowController {
  constructor(_options) {
    this._options = _options;
    // hooks
    this._emptyOnBeforeRender = () => {
    };
    this._initialVisibilityState = /* @__PURE__ */ new WeakMap();
    this._includedObjects = /* @__PURE__ */ new Set();
    this._mesh = this._options.mesh;
    this._scene = this._options.scene.threejsScene();
    this._darknessUniform = { value: this._options.darkness };
    this.renderTarget = _createRenderTarget(this._options.renderTargetSize);
    this._coreRenderBlur = _createCoreRenderBlur(this._options.renderTargetSize);
    this._planeMaterial = new three_module.MeshBasicMaterial({
      map: this.renderTarget.texture,
      opacity: 1,
      transparent: true,
      depthWrite: false
    });
    this._mesh.material = this._planeMaterial;
    const cameraObjects = this._createDepthCamera();
    this._shadowCamera = cameraObjects.camera;
    this._helper = cameraObjects.helper;
    this._mesh.add(this._shadowCamera);
    this._depthMaterial = this._createMaterials();
    this._mesh.onBeforeRender = this.renderShadow.bind(this);
  }
  renderShadow(renderer, scene) {
    if (this._options.showHelper) {
      this._helper.update();
    }
    const previousOnBeforeRender = this._options.mesh.onBeforeRender;
    const initialBackground = scene.background;
    const helperVisible = this._helper.visible;
    scene.background = null;
    this._options.mesh.onBeforeRender = this._emptyOnBeforeRender;
    this._helper.visible = false;
    scene.overrideMaterial = this._depthMaterial;
    this._initVisibility(scene);
    const initialClearAlpha = renderer.getClearAlpha();
    renderer.setClearAlpha(0);
    renderer.setRenderTarget(this.renderTarget);
    renderer.render(scene, this._shadowCamera);
    this._coreRenderBlur.applyBlur(this.renderTarget, renderer, this._options.blur, this._options.blur);
    if ((0,Type/* isBooleanTrue */.bI)(this._options.tblur2)) {
      this._coreRenderBlur.applyBlur(this.renderTarget, renderer, this._options.blur2, this._options.blur2);
    }
    this._restoreVisibility(scene);
    scene.overrideMaterial = null;
    this._helper.visible = helperVisible;
    renderer.setRenderTarget(null);
    renderer.setClearAlpha(initialClearAlpha);
    scene.background = initialBackground;
    this._mesh.onBeforeRender = previousOnBeforeRender;
  }
  _createMaterials() {
    const depthMaterial = new three_module.MeshDepthMaterial();
    depthMaterial.onBeforeCompile = (shader) => {
      shader.uniforms.darkness = this._darknessUniform;
      shader.fragmentShader = /* glsl */
      `
			uniform float darkness;
			${shader.fragmentShader.replace(
        "gl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );",
        "gl_FragColor = vec4( vec3( 0.0 ), ( 1.0 - fragCoordZ ) * darkness );"
      )}
		`;
    };
    depthMaterial.depthTest = false;
    depthMaterial.depthWrite = false;
    return depthMaterial;
  }
  _createDepthCamera() {
    this._mesh.geometry.computeBoundingBox();
    if (this._mesh.geometry.boundingBox) {
      this._mesh.geometry.boundingBox.getCenter(_center);
      this._mesh.geometry.boundingBox.getSize(_size);
    } else {
      _center.set(0, 0, 0);
      _size.set(10, 0, 10);
    }
    const w = _size.x;
    const h = _size.z;
    const dist = this._options.dist;
    const camera = new three_module.OrthographicCamera();
    camera.left = -w / 2;
    camera.right = w / 2;
    camera.bottom = -h / 2;
    camera.top = h / 2;
    camera.far = dist;
    camera.rotation.x = Math.PI / 2;
    camera.position.copy(_center);
    const helper = new CameraHelper/* CameraHelper */.R(camera);
    helper.visible = this._options.showHelper;
    camera.add(helper);
    return { camera, helper };
  }
  /**
   *
   * VISIBILITY
   *
   */
  _initVisibility(scene) {
    if ((0,Type/* isBooleanTrue */.bI)(this._options.renderAllObjects)) {
      return;
    }
    this._includedObjects.clear();
    this._scene.traverse((object) => {
      this._initialVisibilityState.set(object, object.visible);
      object.visible = false;
    });
    this._options.scene.objectsController.traverseObjectsWithMask(
      this._options.objectsMask,
      (object) => {
        object.visible = true;
        this._includedObjects.add(object);
      },
      void 0
    );
    this._includedObjects.forEach((object) => {
      object.traverseAncestors((parent) => {
        parent.visible = true;
      });
    });
  }
  _restoreVisibility(scene) {
    if ((0,Type/* isBooleanTrue */.bI)(this._options.renderAllObjects)) {
      return;
    }
    scene.traverse((object) => {
      const state = this._initialVisibilityState.get(object);
      if (state != null)
        object.visible = state;
    });
  }
}

// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/operations/sop/Plane.ts
var Plane = __webpack_require__(81927);
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/sop/ContactShadows.ts

var ContactShadows_defProp = Object.defineProperty;
var ContactShadows_defProps = Object.defineProperties;
var ContactShadows_getOwnPropDescs = Object.getOwnPropertyDescriptors;
var ContactShadows_getOwnPropSymbols = Object.getOwnPropertySymbols;
var ContactShadows_hasOwnProp = Object.prototype.hasOwnProperty;
var ContactShadows_propIsEnum = Object.prototype.propertyIsEnumerable;
var ContactShadows_defNormalProp = (obj, key, value) => key in obj ? ContactShadows_defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var ContactShadows_spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (ContactShadows_hasOwnProp.call(b, prop))
      ContactShadows_defNormalProp(a, prop, b[prop]);
  if (ContactShadows_getOwnPropSymbols)
    for (var prop of ContactShadows_getOwnPropSymbols(b)) {
      if (ContactShadows_propIsEnum.call(b, prop))
        ContactShadows_defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var ContactShadows_spreadProps = (a, b) => ContactShadows_defProps(a, ContactShadows_getOwnPropDescs(b));








const DEFAULT_PLANE_SIZE = new three_module.Vector2(10, 10);
const DEFAULT_PLANE_CENTER = new three_module.Vector3(0, 0.01, 0);
class ContactShadowsSopParamsConfig extends params_ParamsConfig/* NodeParamsConfig */.yI {
  constructor() {
    super(...arguments);
    this.renderAllObjects = params_ParamsConfig/* ParamConfig.BOOLEAN */.XC.BOOLEAN(true);
    this.objects = params_ParamsConfig/* ParamConfig.STRING */.XC.STRING("", {
      visibleIf: { renderAllObjects: 0 },
      objectMask: { fromInputOnly: false }
    });
    /** @param distance from the ground up to which shadows are visible */
    this.dist = params_ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(1, {
      range: [0, 10],
      rangeLocked: [true, false]
    });
    /** @param shadow resolution */
    this.shadowRes = params_ParamsConfig/* ParamConfig.VECTOR2 */.XC.VECTOR2([256, 256]);
    /** @param shadow opacity */
    this.opacity = params_ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(1);
    /** @param blur amount */
    this.blur = params_ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(1, {
      range: [0, 10],
      rangeLocked: [true, false],
      separatorBefore: true
    });
    /** @param toggle on to add a secondary blur, which may be useful to get rid of artefacts */
    this.tblur2 = params_ParamsConfig/* ParamConfig.BOOLEAN */.XC.BOOLEAN(1);
    /** @param secondary blur amount */
    this.blur2 = params_ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(1, {
      range: [0, 10],
      rangeLocked: [true, false],
      visibleIf: { tblur2: 1 }
    });
    /** @param show helper */
    this.showHelper = params_ParamsConfig/* ParamConfig.BOOLEAN */.XC.BOOLEAN(0, {
      separatorBefore: true
    });
  }
}
const ContactShadows_ParamsConfig = new ContactShadowsSopParamsConfig();
class ContactShadowsSopNode extends sop_Base/* TypedSopNode */.x {
  constructor() {
    super(...arguments);
    this.paramsConfig = ContactShadows_ParamsConfig;
  }
  static type() {
    return Sop/* SopType.CONTACT_SHADOWS */.aB.CONTACT_SHADOWS;
  }
  initializeNode() {
    this.io.inputs.setCount(0, 1);
    this.io.inputs.initInputsClonedState(InputCloneMode/* InputCloneMode.FROM_NODE */.m.FROM_NODE);
  }
  cook(inputCoreGroups) {
    const coreGroup = inputCoreGroups[0] || this._defaultCoreGroup();
    const objects = coreGroup.threejsObjectsWithGeo();
    for (const object of objects) {
      Poly/* Poly.onObjectsAddRemoveHooks.assignOnAddHookHandler */.L.onObjectsAddRemoveHooks.assignOnAddHookHandler(object, this);
    }
    this.setCoreGroup(coreGroup);
  }
  _defaultCoreGroup() {
    this._planeOperation = this._planeOperation || new Plane/* PlaneSopOperation */.j(this.scene(), this.states, this);
    const coreGroup = this._planeOperation.cook([], ContactShadows_spreadProps(ContactShadows_spreadValues({}, Plane/* DEFAULT_PARAMS */.t), {
      size: DEFAULT_PLANE_SIZE,
      center: DEFAULT_PLANE_CENTER
    }));
    return coreGroup;
  }
  updateObjectOnAdd(object, parent) {
    const geometry = object.geometry;
    if (!geometry) {
      return;
    }
    this._lastContactShadowsController = new ContactShadowController({
      scene: this.scene(),
      mesh: object,
      dist: this.pv.dist,
      renderTargetSize: this.pv.shadowRes,
      darkness: this.pv.opacity,
      blur: this.pv.blur,
      tblur2: this.pv.tblur2,
      blur2: this.pv.blur2,
      renderAllObjects: this.pv.renderAllObjects,
      objectsMask: this.pv.objects,
      showHelper: this.pv.showHelper
    });
  }
  lastContactShadowsController() {
    return this._lastContactShadowsController;
  }
}

// EXTERNAL MODULE: ../@polygonjs/polygonjs/node_modules/three/examples/jsm/geometries/ConvexGeometry.js + 1 modules
var ConvexGeometry = __webpack_require__(37160);
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/operations/sop/ConvexHull.ts






class ConvexHullSopOperation extends operations_sop_Base/* BaseSopOperation */.U {
  static type() {
    return "convexHull";
  }
  cook(inputCoreGroups, params) {
    const inputCoreGroup = inputCoreGroups[0];
    const objects = inputCoreGroup.threejsObjectsWithGeo();
    const newObjects = objects.map((object) => this._createConvexHull(object));
    return this.createCoreGroupFromObjects(newObjects);
  }
  _createConvexHull(object) {
    const srcGeo = object.geometry;
    const positionAttribute = srcGeo.getAttribute("position");
    const vertices = [];
    for (let i = 0; i < positionAttribute.count; i++) {
      const vertex = new three_module.Vector3();
      vertex.fromBufferAttribute(positionAttribute, i);
      vertices.push(vertex);
    }
    const newGeo = new ConvexGeometry/* ConvexGeometry */.u(vertices);
    return this.createObject(newGeo, Constant/* ObjectType.MESH */.LP.MESH);
  }
}
ConvexHullSopOperation.DEFAULT_PARAMS = {};
ConvexHullSopOperation.INPUT_CLONED_STATE = InputCloneMode/* InputCloneMode.NEVER */.m.NEVER;

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/sop/ConvexHull.ts




class ConvexHullSopParamsConfig extends params_ParamsConfig/* NodeParamsConfig */.yI {
}
const ConvexHull_ParamsConfig = new ConvexHullSopParamsConfig();
class ConvexHullSopNode extends sop_Base/* TypedSopNode */.x {
  constructor() {
    super(...arguments);
    this.paramsConfig = ConvexHull_ParamsConfig;
  }
  static type() {
    return "convexHull";
  }
  initializeNode() {
    this.io.inputs.setCount(0, 1);
    this.io.inputs.initInputsClonedState(ConvexHullSopOperation.INPUT_CLONED_STATE);
  }
  cook(inputCoreGroups) {
    this._operation = this._operation || new ConvexHullSopOperation(this._scene, this.states, this);
    const coreGroup = this._operation.cook(inputCoreGroups, this.pv);
    this.setCoreGroup(coreGroup);
  }
}

// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/nodes/sop/Copy.ts + 2 modules
var Copy = __webpack_require__(37554);
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/core/geometry/Curve.ts

var SplineCurveType = /* @__PURE__ */ ((SplineCurveType2) => {
  SplineCurveType2["CATMULLROM"] = "catmullrom";
  SplineCurveType2["CENTRIPETAL"] = "centripetal";
  SplineCurveType2["CHORDAL"] = "chordal";
  return SplineCurveType2;
})(SplineCurveType || {});
const SPLINE_CURVE_TYPES = [
  "catmullrom" /* CATMULLROM */,
  "centripetal" /* CENTRIPETAL */,
  "chordal" /* CHORDAL */
];

// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/core/UserData.ts
var UserData = __webpack_require__(36021);
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/operations/sop/CurveFromPoints.ts









const tmpV2 = new three_module.Vector2();
const current = new three_module.Vector3();
const next = new three_module.Vector3();
const CurveFromPoints_points = [];
class CurveFromPointsSopOperation extends operations_sop_Base/* BaseSopOperation */.U {
  static type() {
    return "curveFromPoint";
  }
  cook(inputCoreGroups, params) {
    const inputCoreGroup = inputCoreGroups[0];
    const objects = inputCoreGroup.allObjects();
    const newObjects = [];
    for (let object of objects) {
      const newObject = this._createCurveFromCoreObject(object, params);
      if (newObject) {
        newObjects.push(newObject);
      }
    }
    return this.createCoreGroupFromObjects(newObjects);
  }
  _createCurveFromCoreObject(object, params) {
    const { pointsCount, closed, curveType, tension, tTangent } = params;
    const corePointClass = (0,CoreObjectFactory/* corePointClassFactory */.E_)(object);
    (0,CorePointUtils/* pointsFromObject */.u_)(object, CurveFromPoints_points);
    const pointPositions = CurveFromPoints_points.map((p) => p.position(new three_module.Vector3()));
    if (pointPositions.length < 2) {
      return;
    }
    const curveTypeName = SPLINE_CURVE_TYPES[curveType];
    const curve = new three_module.CatmullRomCurve3(pointPositions, closed, curveTypeName, tension);
    const indices = new Array(pointsCount);
    for (let i = 0; i < pointsCount; i++) {
      if (i > 0) {
        indices[(i - 1) * 2] = i - 1;
        indices[(i - 1) * 2 + 1] = i;
      }
    }
    const geometry = new three_module.BufferGeometry();
    geometry.setIndex(indices);
    const attribNamesToInterpolate = ["position"];
    for (const attribName of attribNamesToInterpolate) {
      const attribSize = corePointClass.attribSize(object, attribName);
      let attribPositions = [];
      switch (attribSize) {
        case 1: {
          attribPositions = CurveFromPoints_points.map((p) => new three_module.Vector3(p.attribValue(attribName), 0, 0));
          break;
        }
        case 2: {
          attribPositions = CurveFromPoints_points.map((p) => {
            p.attribValue(attribName, tmpV2);
            return new three_module.Vector3(tmpV2.x, tmpV2.y, 0);
          });
          break;
        }
        case 3: {
          attribPositions = CurveFromPoints_points.map((p) => {
            p.attribValue(attribName, current);
            return current.clone();
          });
          break;
        }
      }
      const curveTypeName2 = SPLINE_CURVE_TYPES[curveType];
      const curve2 = new three_module.CatmullRomCurve3(attribPositions, closed, curveTypeName2, tension);
      const attribValues = new Array(pointsCount * attribSize);
      for (let i = 0; i < pointsCount; i++) {
        const t = i / (pointsCount - 1);
        curve2.getPoint(t, current);
        switch (attribSize) {
          case 1: {
            attribValues[i] = current.x;
            break;
          }
          case 2: {
            attribValues[2 * i] = current.x;
            attribValues[2 * i + 1] = current.y;
            break;
          }
          case 3: {
            current.toArray(attribValues, i * 3);
            break;
          }
        }
      }
      geometry.setAttribute(attribName, new three_module.Float32BufferAttribute(attribValues, attribSize));
    }
    if (tTangent) {
      const positions = geometry.getAttribute("position").array;
      const tangentName = params.tangentName;
      const tangents = new Array(pointsCount * 3);
      for (let i = 0; i < pointsCount - 1; i++) {
        current.fromArray(positions, i * 3);
        next.fromArray(positions, (i + 1) * 3);
        next.sub(current).normalize();
        next.toArray(tangents, i * 3);
      }
      current.fromArray(positions, (pointsCount - 1) * 3);
      next.fromArray(positions, (pointsCount - 2) * 3);
      current.sub(next).normalize();
      next.toArray(tangents, (pointsCount - 1) * 3);
      geometry.setAttribute(tangentName, new three_module.Float32BufferAttribute(tangents, 3));
    }
    const newObject = operations_sop_Base/* BaseSopOperation.createObject */.U.createObject(geometry, Constant/* ObjectType.LINE_SEGMENTS */.LP.LINE_SEGMENTS);
    newObject.userData[UserData/* ObjectUserData.PATH */.D.PATH] = curve;
    return newObject;
  }
}
CurveFromPointsSopOperation.DEFAULT_PARAMS = {
  pointsCount: 100,
  closed: false,
  curveType: 0,
  tension: 0.5,
  tTangent: false,
  tangentName: "tangent"
  // attributesToInterpolate: '',
};
CurveFromPointsSopOperation.INPUT_CLONED_STATE = InputCloneMode/* InputCloneMode.NEVER */.m.NEVER;

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/sop/CurveFromPoints.ts






const CurveFromPoints_DEFAULT = CurveFromPointsSopOperation.DEFAULT_PARAMS;
class CurveFromPointsSopParamsConfig extends params_ParamsConfig/* NodeParamsConfig */.yI {
  constructor() {
    super(...arguments);
    /** @param points Count */
    this.pointsCount = params_ParamsConfig/* ParamConfig.INTEGER */.XC.INTEGER(CurveFromPoints_DEFAULT.pointsCount, {
      range: [2, 1e3],
      rangeLocked: [true, false]
    });
    /** @param closed */
    this.closed = params_ParamsConfig/* ParamConfig.BOOLEAN */.XC.BOOLEAN(CurveFromPoints_DEFAULT.closed);
    /** @param curve type */
    this.curveType = params_ParamsConfig/* ParamConfig.INTEGER */.XC.INTEGER(CurveFromPoints_DEFAULT.curveType, {
      menu: {
        entries: SPLINE_CURVE_TYPES.map((name, value) => ({ name, value }))
      }
    });
    /** @param tension */
    this.tension = params_ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(CurveFromPoints_DEFAULT.tension, {
      range: [0, 1],
      rangeLocked: [false, false],
      visibleIf: { curveType: SPLINE_CURVE_TYPES.indexOf(SplineCurveType.CATMULLROM) }
    });
    /** @param add tangent attribute */
    this.tTangent = params_ParamsConfig/* ParamConfig.BOOLEAN */.XC.BOOLEAN(CurveFromPoints_DEFAULT.tTangent);
    /** @param tangent attribute name */
    this.tangentName = params_ParamsConfig/* ParamConfig.STRING */.XC.STRING(CurveFromPoints_DEFAULT.tangentName, {
      visibleIf: { tTangent: true }
    });
  }
  /** @param attributes */
  // attributesToInterpolate = ParamConfig.STRING(DEFAULT.attributesToInterpolate);
}
const CurveFromPoints_ParamsConfig = new CurveFromPointsSopParamsConfig();
class CurveFromPointsSopNode extends sop_Base/* TypedSopNode */.x {
  constructor() {
    super(...arguments);
    this.paramsConfig = CurveFromPoints_ParamsConfig;
  }
  static type() {
    return Sop/* SopType.CURVE_FROM_POINTS */.aB.CURVE_FROM_POINTS;
  }
  initializeNode() {
    this.io.inputs.setCount(0, 1);
    this.io.inputs.initInputsClonedState(CurveFromPointsSopOperation.INPUT_CLONED_STATE);
  }
  cook(inputCoreGroups) {
    this._operation = this._operation || new CurveFromPointsSopOperation(this._scene, this.states, this);
    const coreGroup = this._operation.cook(inputCoreGroups, this.pv);
    this.setCoreGroup(coreGroup);
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/operations/sop/CurveGetPoint.ts







const EPSILON = 1e-3;
const CurveGetPoint_points = [];
class CurveGetPointSopOperation extends operations_sop_Base/* BaseSopOperation */.U {
  constructor() {
    super(...arguments);
    this._current = new three_module.Vector3();
    this._next = new three_module.Vector3();
  }
  static type() {
    return "curveGetPoint";
  }
  cook(inputCoreGroups, params) {
    const inputCoreGroup = inputCoreGroups[0];
    const objects = inputCoreGroup.allObjects();
    const newObjects = [];
    for (let object of objects) {
      const newObject = this._createSplineFromCoreObject(object, params);
      if (newObject) {
        newObjects.push(newObject);
      }
    }
    return this.createCoreGroupFromObjects(newObjects);
  }
  _createSplineFromCoreObject(object, params) {
    const { t, closed, curveType, tension, tTangent } = params;
    (0,CorePointUtils/* pointsFromObject */.u_)(object, CurveGetPoint_points);
    if (CurveGetPoint_points.length < 2) {
      return;
    }
    const pointPositions = CurveGetPoint_points.map((p) => p.position(new three_module.Vector3()));
    const curveTypeName = SPLINE_CURVE_TYPES[curveType];
    const curve = new three_module.CatmullRomCurve3(pointPositions, closed, curveTypeName, tension);
    const positions = new Array(3);
    curve.getPoint(t, this._current);
    this._current.toArray(positions, 0);
    const geometry = new three_module.BufferGeometry();
    geometry.setAttribute("position", new three_module.Float32BufferAttribute(positions, 3));
    if (tTangent) {
      const tangents = new Array(3);
      const tangentName = params.tangentName;
      const inFirstHalf = t < 0.5;
      const t2 = inFirstHalf ? t + EPSILON : t - EPSILON;
      curve.getPoint(t2, this._next);
      if (inFirstHalf) {
        this._next.sub(this._current).normalize();
      } else {
        this._current.sub(this._next).normalize();
        this._next.copy(this._current);
      }
      this._next.toArray(tangents, 0);
      geometry.setAttribute(tangentName, new three_module.Float32BufferAttribute(tangents, 3));
    }
    const newObject = operations_sop_Base/* BaseSopOperation.createObject */.U.createObject(geometry, Constant/* ObjectType.POINTS */.LP.POINTS);
    return newObject;
  }
}
CurveGetPointSopOperation.DEFAULT_PARAMS = {
  t: 0,
  closed: false,
  curveType: 0,
  tension: 0.5,
  tTangent: false,
  tangentName: "tangent"
};
CurveGetPointSopOperation.INPUT_CLONED_STATE = InputCloneMode/* InputCloneMode.NEVER */.m.NEVER;

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/sop/CurveGetPoint.ts





const CurveGetPoint_DEFAULT = CurveGetPointSopOperation.DEFAULT_PARAMS;
class CurveGetPointSopParamsConfig extends params_ParamsConfig/* NodeParamsConfig */.yI {
  constructor() {
    super(...arguments);
    /** @param t */
    this.t = params_ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(CurveGetPoint_DEFAULT.t, {
      range: [0, 1],
      rangeLocked: [false, false]
    });
    /** @param closed */
    this.closed = params_ParamsConfig/* ParamConfig.BOOLEAN */.XC.BOOLEAN(CurveGetPoint_DEFAULT.closed);
    /** @param curve type */
    this.curveType = params_ParamsConfig/* ParamConfig.INTEGER */.XC.INTEGER(CurveGetPoint_DEFAULT.curveType, {
      menu: {
        entries: SPLINE_CURVE_TYPES.map((name, value) => ({ name, value }))
      }
    });
    /** @param tension */
    this.tension = params_ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(CurveGetPoint_DEFAULT.tension, {
      range: [0, 1],
      rangeLocked: [false, false],
      visibleIf: { curveType: SPLINE_CURVE_TYPES.indexOf(SplineCurveType.CATMULLROM) }
    });
    /** @param add tangent attribute */
    this.tTangent = params_ParamsConfig/* ParamConfig.BOOLEAN */.XC.BOOLEAN(CurveGetPoint_DEFAULT.tTangent);
    /** @param tangent attribute name */
    this.tangentName = params_ParamsConfig/* ParamConfig.STRING */.XC.STRING(CurveGetPoint_DEFAULT.tangentName, {
      visibleIf: { tTangent: true }
    });
  }
}
const CurveGetPoint_ParamsConfig = new CurveGetPointSopParamsConfig();
class CurveGetPointSopNode extends sop_Base/* TypedSopNode */.x {
  constructor() {
    super(...arguments);
    this.paramsConfig = CurveGetPoint_ParamsConfig;
  }
  static type() {
    return "curveGetPoint";
  }
  initializeNode() {
    this.io.inputs.setCount(0, 1);
    this.io.inputs.initInputsClonedState(CurveGetPointSopOperation.INPUT_CLONED_STATE);
  }
  cook(inputCoreGroups) {
    this._operation = this._operation || new CurveGetPointSopOperation(this._scene, this.states, this);
    const coreGroup = this._operation.cook(inputCoreGroups, this.pv);
    this.setCoreGroup(coreGroup);
  }
}

// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/nodes/sop/_BaseCSG.ts
var _BaseCSG = __webpack_require__(72290);
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/core/geometry/modules/csg/CsgVecToVector.ts

function csgVec3ToVector3(src, target) {
  target.x = src[0];
  target.y = src[1];
  target.z = src[2];
}
function vector3ToCsgVec3(src, target) {
  target[0] = src.x;
  target[1] = src.y;
  target[2] = src.z;
}
function vector2ToCsgVec2(src, target) {
  target[0] = src.x;
  target[1] = src.y;
}
function colorToCsgRGB(src, target) {
  target[0] = src.r;
  target[1] = src.g;
  target[2] = src.b;
}

// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/core/geometry/modules/csg/CsgConstant.ts
var CsgConstant = __webpack_require__(18613);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/node_modules/@jscad/modeling/src/index.js
var src = __webpack_require__(93187);
var src_default = /*#__PURE__*/__webpack_require__.n(src);
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/sop/CSGArc.ts







const { arc } = src.primitives;
class CSGArcSopParamsConfig extends params_ParamsConfig/* NodeParamsConfig */.yI {
  constructor() {
    super(...arguments);
    /** @param radius */
    this.radius = params_ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(1, { range: [0, 10] });
    /** @param segments */
    this.segments = params_ParamsConfig/* ParamConfig.INTEGER */.XC.INTEGER(32, {
      range: [4, 128],
      rangeLocked: [true, false]
    });
    /** @param center */
    this.center = params_ParamsConfig/* ParamConfig.VECTOR2 */.XC.VECTOR2([0, 0]);
    /** @param make tangents */
    this.makeTangent = params_ParamsConfig/* ParamConfig.BOOLEAN */.XC.BOOLEAN(0);
    /** @param start angle */
    this.startAngle = params_ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(0, {
      range: [0, 2 * Math.PI],
      rangeLocked: [true, true],
      step: CsgConstant/* step */.Nb
    });
    /** @param end angle */
    this.endAngle = params_ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT("$PI", {
      range: [0, 2 * Math.PI],
      rangeLocked: [true, true],
      step: CsgConstant/* step */.Nb
    });
  }
}
const CSGArc_ParamsConfig = new CSGArcSopParamsConfig();
class CSGArcSopNode extends _BaseCSG/* CSGSopNode */.O {
  constructor() {
    super(...arguments);
    this.paramsConfig = CSGArc_ParamsConfig;
    this._center = [0, 0];
  }
  static type() {
    return Sop/* SopType.CSG_ARC */.aB.CSG_ARC;
  }
  cook(inputCoreGroups) {
    vector2ToCsgVec2(this.pv.center, this._center);
    const { radius, segments, makeTangent, startAngle, endAngle } = this.pv;
    const geo = arc({
      center: this._center,
      radius,
      segments,
      makeTangent,
      startAngle,
      endAngle
    });
    this.setCSGGeometry(geo);
  }
}

// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/nodes/sop/CSGBoolean.ts
var CSGBoolean = __webpack_require__(37946);
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/core/geometry/modules/csg/math/CsgMathVec3.ts

function csgVec3MultScalar(src, scalar) {
  src[0] *= scalar;
  src[1] *= scalar;
  src[2] *= scalar;
}
function csgVec3ToJSON(src) {
  return src;
}
function csgVec3sToJSON(src) {
  return src.map((v) => csgVec3ToJSON(v));
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/sop/CSGBox.ts

var CSGBox_defProp = Object.defineProperty;
var CSGBox_defProps = Object.defineProperties;
var CSGBox_getOwnPropDescs = Object.getOwnPropertyDescriptors;
var CSGBox_getOwnPropSymbols = Object.getOwnPropertySymbols;
var CSGBox_hasOwnProp = Object.prototype.hasOwnProperty;
var CSGBox_propIsEnum = Object.prototype.propertyIsEnumerable;
var CSGBox_defNormalProp = (obj, key, value) => key in obj ? CSGBox_defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var CSGBox_spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (CSGBox_hasOwnProp.call(b, prop))
      CSGBox_defNormalProp(a, prop, b[prop]);
  if (CSGBox_getOwnPropSymbols)
    for (var prop of CSGBox_getOwnPropSymbols(b)) {
      if (CSGBox_propIsEnum.call(b, prop))
        CSGBox_defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var CSGBox_spreadProps = (a, b) => CSGBox_defProps(a, CSGBox_getOwnPropDescs(b));








const { cuboid, roundedCuboid } = src.primitives;
class CSGBoxSopParamsConfig extends params_ParamsConfig/* NodeParamsConfig */.yI {
  constructor() {
    super(...arguments);
    /** @param size */
    this.size = params_ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(1, {
      range: [0, 10],
      rangeLocked: [true, false],
      step: CsgConstant/* step */.Nb
    });
    /** @param sizes */
    this.sizes = params_ParamsConfig/* ParamConfig.VECTOR3 */.XC.VECTOR3([1, 1, 1]);
    /** @param center */
    this.center = params_ParamsConfig/* ParamConfig.VECTOR3 */.XC.VECTOR3([0, 0, 0]);
    /** @param bevel */
    this.rounded = params_ParamsConfig/* ParamConfig.BOOLEAN */.XC.BOOLEAN(0);
    /** @param bevel radius */
    this.roundedRadius = params_ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(0.1, {
      range: [0, 1],
      rangeLocked: [true, false],
      visibleIf: { rounded: 1 }
    });
    /** @param bevel segments */
    this.roundedSegments = params_ParamsConfig/* ParamConfig.INTEGER */.XC.INTEGER(4, {
      range: [1, 8],
      rangeLocked: [true, false],
      visibleIf: { rounded: 1 }
    });
  }
}
const CSGBox_ParamsConfig = new CSGBoxSopParamsConfig();
class CSGBoxSopNode extends _BaseCSG/* CSGSopNode */.O {
  constructor() {
    super(...arguments);
    this.paramsConfig = CSGBox_ParamsConfig;
    this._center = [0, 0, 0];
    this._sizes = [0, 0, 0];
  }
  static type() {
    return Sop/* SopType.CSG_BOX */.aB.CSG_BOX;
  }
  cook(inputCoreGroups) {
    vector3ToCsgVec3(this.pv.center, this._center);
    vector3ToCsgVec3(this.pv.sizes, this._sizes);
    csgVec3MultScalar(this._sizes, this.pv.size);
    try {
      const cuboidOptions = {
        center: this._center,
        size: this._sizes
      };
      const createRoundedCuboid = () => {
        const maxSize = Math.min(this._sizes[0], this._sizes[1], this._sizes[2]) * 0.5 - 2 * src.maths.constants.EPS;
        const minSize = 2 * src.maths.constants.EPS;
        const roundRadius = _Module/* CoreMath.clamp */.Gj.clamp(this.pv.roundedRadius, minSize, maxSize);
        const roundedCuboidOptions = CSGBox_spreadProps(CSGBox_spreadValues({}, cuboidOptions), {
          roundRadius,
          segments: this.pv.roundedSegments * 4
        });
        return roundedCuboid(roundedCuboidOptions);
      };
      const geo = this.pv.rounded ? createRoundedCuboid() : cuboid(cuboidOptions);
      this.setCSGGeometry(geo);
    } catch (err) {
      const message = err instanceof Error ? err.message : "failed to create geometry";
      this.states.error.set(message);
      this.setCSGObjects([]);
    }
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/sop/CSGCenter.ts






const { center } = src.transforms;
class CSGCenterSopParamsConfig extends params_ParamsConfig/* NodeParamsConfig */.yI {
  constructor() {
    super(...arguments);
    /** @param x */
    this.x = params_ParamsConfig/* ParamConfig.BOOLEAN */.XC.BOOLEAN(1);
    /** @param y */
    this.y = params_ParamsConfig/* ParamConfig.BOOLEAN */.XC.BOOLEAN(1);
    /** @param z */
    this.z = params_ParamsConfig/* ParamConfig.BOOLEAN */.XC.BOOLEAN(1);
    /** @param relativeTo */
    this.relativeTo = params_ParamsConfig/* ParamConfig.VECTOR3 */.XC.VECTOR3([0, 0, 0]);
  }
}
const CSGCenter_ParamsConfig = new CSGCenterSopParamsConfig();
class CSGCenterSopNode extends _BaseCSG/* CSGSopNode */.O {
  constructor() {
    super(...arguments);
    this.paramsConfig = CSGCenter_ParamsConfig;
    this._relativeTo = [0, 0, 0];
    this._axes = [true, true, true];
  }
  static type() {
    return Sop/* SopType.CSG_CENTER */.aB.CSG_CENTER;
  }
  initializeNode() {
    this.io.inputs.setCount(1);
  }
  cook(inputCoreGroups) {
    vector3ToCsgVec3(this.pv.relativeTo, this._relativeTo);
    this._axes[0] = this.pv.x;
    this._axes[1] = this.pv.y;
    this._axes[2] = this.pv.z;
    const options = {
      axes: this._axes,
      relativeTo: this._relativeTo
    };
    const inputObjects = inputCoreGroups[0].csgObjects();
    if (inputObjects) {
      const newObjects = inputObjects.map((o) => center(options, o.csgGeometry()));
      this.setCSGGeometries(newObjects);
    } else {
      this.setCSGObjects([]);
    }
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/sop/CSGCircle.ts







const { circle } = src.primitives;
class CSGCircleSopParamsConfig extends params_ParamsConfig/* NodeParamsConfig */.yI {
  constructor() {
    super(...arguments);
    /** @param radius */
    this.radius = params_ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(1, {
      range: [0, 10],
      rangeLocked: [true, false]
    });
    /** @param segments */
    this.segments = params_ParamsConfig/* ParamConfig.INTEGER */.XC.INTEGER(32, {
      range: [4, 128],
      rangeLocked: [true, false]
    });
    /** @param center */
    this.center = params_ParamsConfig/* ParamConfig.VECTOR2 */.XC.VECTOR2([0, 0]);
    /** @param open */
    this.open = params_ParamsConfig/* ParamConfig.BOOLEAN */.XC.BOOLEAN(0);
    /** @param start angle */
    this.startAngle = params_ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(0, {
      range: [0, 2 * Math.PI],
      rangeLocked: [true, true],
      step: CsgConstant/* step */.Nb,
      visibleIf: { open: 1 }
    });
    /** @param end angle */
    this.endAngle = params_ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT("$PI", {
      range: [0, 2 * Math.PI],
      rangeLocked: [true, true],
      step: CsgConstant/* step */.Nb,
      visibleIf: { open: 1 }
    });
  }
}
const CSGCircle_ParamsConfig = new CSGCircleSopParamsConfig();
class CSGCircleSopNode extends _BaseCSG/* CSGSopNode */.O {
  constructor() {
    super(...arguments);
    this.paramsConfig = CSGCircle_ParamsConfig;
    this._center = [0, 0];
  }
  static type() {
    return Sop/* SopType.CSG_CIRCLE */.aB.CSG_CIRCLE;
  }
  cook(inputCoreGroups) {
    vector2ToCsgVec2(this.pv.center, this._center);
    try {
      const { radius, startAngle, endAngle, segments, open } = this.pv;
      const geo = circle({
        center: this._center,
        radius,
        segments,
        startAngle: open ? startAngle : 0,
        endAngle: open ? endAngle : 0
      });
      this.setCSGGeometry(geo);
    } catch (err) {
      const message = err instanceof Error ? err.message : "failed to create geometry";
      this.states.error.set(message);
      this.setCSGObjects([]);
    }
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/sop/CSGDodecahedron.ts





const { cuboid: CSGDodecahedron_cuboid } = src.primitives;
const { intersect } = src.booleans;
const { rotateX, rotateZ, scale } = src.transforms;
const { degToRad } = src.utils;
const dodecahedron = (h) => {
  let cuboid1 = CSGDodecahedron_cuboid({ size: [20, 20, 10] });
  for (let i = 0; i <= 4; i++) {
    cuboid1 = intersect(
      cuboid1,
      rotateZ(i * degToRad(72), rotateX(degToRad(116.565), CSGDodecahedron_cuboid({ size: [20, 20, 10] })))
    );
  }
  return scale([h, h, h], cuboid1);
};
class CSGDodecahedronSopParamsConfig extends params_ParamsConfig/* NodeParamsConfig */.yI {
  constructor() {
    super(...arguments);
    /** @param radius */
    this.radius = params_ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(1, {
      range: [src.maths.constants.EPS, 1],
      rangeLocked: [true, false]
    });
  }
}
const CSGDodecahedron_ParamsConfig = new CSGDodecahedronSopParamsConfig();
class CSGDodecahedronSopNode extends _BaseCSG/* CSGSopNode */.O {
  constructor() {
    super(...arguments);
    this.paramsConfig = CSGDodecahedron_ParamsConfig;
  }
  static type() {
    return Sop/* SopType.CSG_DODECAHEDRON */.aB.CSG_DODECAHEDRON;
  }
  initializeNode() {
    this.io.inputs.setCount(0);
  }
  cook(inputCoreGroups) {
    const object = dodecahedron(this.pv.radius * 0.1);
    this.setCSGGeometry(object);
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/sop/CSGEllipse.ts







const { ellipse } = src.primitives;
class CSGEllipseSopParamsConfig extends params_ParamsConfig/* NodeParamsConfig */.yI {
  constructor() {
    super(...arguments);
    /** @param radius */
    this.radius = params_ParamsConfig/* ParamConfig.VECTOR2 */.XC.VECTOR2([1, 1]);
    /** @param segments */
    this.segments = params_ParamsConfig/* ParamConfig.INTEGER */.XC.INTEGER(32, {
      range: [4, 128],
      rangeLocked: [true, false]
    });
    /** @param center */
    this.center = params_ParamsConfig/* ParamConfig.VECTOR2 */.XC.VECTOR2([0, 0]);
    /** @param open */
    this.open = params_ParamsConfig/* ParamConfig.BOOLEAN */.XC.BOOLEAN(0);
    /** @param start angle */
    this.startAngle = params_ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(0, {
      range: [0, 2 * Math.PI],
      rangeLocked: [true, true],
      step: CsgConstant/* step */.Nb,
      visibleIf: { open: 1 }
    });
    /** @param end angle */
    this.endAngle = params_ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(Math.PI, {
      range: [0, 2 * Math.PI],
      rangeLocked: [true, true],
      step: CsgConstant/* step */.Nb,
      visibleIf: { open: 1 }
    });
  }
}
const CSGEllipse_ParamsConfig = new CSGEllipseSopParamsConfig();
class CSGEllipseSopNode extends _BaseCSG/* CSGSopNode */.O {
  constructor() {
    super(...arguments);
    this.paramsConfig = CSGEllipse_ParamsConfig;
    this._center = [0, 0];
    this._radius = [0, 0];
  }
  static type() {
    return Sop/* SopType.CSG_ELLIPSE */.aB.CSG_ELLIPSE;
  }
  cook(inputCoreGroups) {
    vector2ToCsgVec2(this.pv.center, this._center);
    vector2ToCsgVec2(this.pv.radius, this._radius);
    const { segments, open, startAngle, endAngle } = this.pv;
    const geo = ellipse({
      center: this._center,
      radius: this._radius,
      segments,
      startAngle: open ? startAngle : 0,
      endAngle: open ? endAngle : 0
    });
    this.setCSGGeometry(geo);
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/sop/CSGEllipsoid.ts






const { ellipsoid } = src.primitives;
class CSGEllipsoidSopParamsConfig extends params_ParamsConfig/* NodeParamsConfig */.yI {
  constructor() {
    super(...arguments);
    /** @param center */
    this.center = params_ParamsConfig/* ParamConfig.VECTOR3 */.XC.VECTOR3([0, 0, 0]);
    /** @param radius */
    this.radius = params_ParamsConfig/* ParamConfig.VECTOR3 */.XC.VECTOR3([1, 1, 1]);
    /** @param segments */
    this.segments = params_ParamsConfig/* ParamConfig.INTEGER */.XC.INTEGER(32, {
      range: [4, 128],
      rangeLocked: [true, false]
    });
  }
  /** @param axes */
  // axes = ParamConfig.VECTOR3([0, 1, 0]);
}
const CSGEllipsoid_ParamsConfig = new CSGEllipsoidSopParamsConfig();
class CSGEllipsoidSopNode extends _BaseCSG/* CSGSopNode */.O {
  constructor() {
    super(...arguments);
    this.paramsConfig = CSGEllipsoid_ParamsConfig;
    this._center = [0, 0, 0];
    this._radius = [0, 0, 0];
  }
  static type() {
    return Sop/* SopType.CSG_ELLIPSOID */.aB.CSG_ELLIPSOID;
  }
  // private _axes: maths.vec3.Vec3 = [0, 0, 0];
  cook(inputCoreGroups) {
    vector3ToCsgVec3(this.pv.center, this._center);
    vector3ToCsgVec3(this.pv.radius, this._radius);
    const geo = ellipsoid({
      center: this._center,
      radius: this._radius,
      segments: this.pv.segments
      // axes: this._axes,
    });
    this.setCSGGeometry(geo);
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/core/geometry/modules/csg/operations/CsgCorner.ts

var CsgCorner = /* @__PURE__ */ ((CsgCorner2) => {
  CsgCorner2["EDGE"] = "edge";
  CsgCorner2["CHAMFER"] = "chamfer";
  CsgCorner2["ROUND"] = "round";
  return CsgCorner2;
})(CsgCorner || {});
const CSG_CORNERS = ["edge" /* EDGE */, "chamfer" /* CHAMFER */, "round" /* ROUND */];

// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/core/geometry/modules/csg/CsgCommon.ts
var CsgCommon = __webpack_require__(87831);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/core/geometry/modules/csg/CsgCoreType.ts
var CsgCoreType = __webpack_require__(70083);
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/sop/CSGExpand.ts









const { expand } = src.expansions;
var ExpandMode = /* @__PURE__ */ ((ExpandMode2) => {
  ExpandMode2["_2D_ONLY"] = "2D Only";
  ExpandMode2["_2D_AND_3D_ONLY"] = "2D & 3D (Slow)";
  return ExpandMode2;
})(ExpandMode || {});
const EXPAND_MODES = ["2D Only" /* _2D_ONLY */, "2D & 3D (Slow)" /* _2D_AND_3D_ONLY */];
class CSGExpandSopParamsConfig extends params_ParamsConfig/* NodeParamsConfig */.yI {
  constructor() {
    super(...arguments);
    /** @param mode */
    this.mode = params_ParamsConfig/* ParamConfig.INTEGER */.XC.INTEGER(EXPAND_MODES.indexOf("2D Only" /* _2D_ONLY */), {
      menu: { entries: EXPAND_MODES.map((name, value) => ({ name, value })) }
    });
    /** @param delta */
    this.delta = params_ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(0.1, {
      range: [1 * src.maths.constants.EPS, 1],
      rangeLocked: [true, false]
    });
    /** @param corners */
    this.corners = params_ParamsConfig/* ParamConfig.INTEGER */.XC.INTEGER(CSG_CORNERS.indexOf(CsgCorner.ROUND), {
      menu: { entries: CSG_CORNERS.map((name, value) => ({ name, value })) }
    });
    /** @param segments */
    this.segments = params_ParamsConfig/* ParamConfig.INTEGER */.XC.INTEGER(1, {
      range: [1, 8],
      rangeLocked: [true, false]
    });
    /** @param allow 3D expand (can be very slow) */
    this.allowExpand3D = params_ParamsConfig/* ParamConfig.BOOLEAN */.XC.BOOLEAN(false, {
      // label: 'allow 3D geometries (slow)',
    });
  }
}
const CSGExpand_ParamsConfig = new CSGExpandSopParamsConfig();
class CSGExpandSopNode extends _BaseCSG/* CSGSopNode */.O {
  constructor() {
    super(...arguments);
    this.paramsConfig = CSGExpand_ParamsConfig;
  }
  static type() {
    return Sop/* SopType.CSG_EXPAND */.aB.CSG_EXPAND;
  }
  initializeNode() {
    this.io.inputs.setCount(1);
  }
  setMode(mode) {
    this.p.mode.set(EXPAND_MODES.indexOf(mode));
  }
  cook(inputCoreGroups) {
    const inputObjects = inputCoreGroups[0].csgObjects();
    if (inputObjects && inputObjects.length != 0) {
      const minDelta = 1 * src.maths.constants.EPS;
      const delta = Math.max(this.pv.delta, minDelta);
      const options = {
        delta,
        corners: CSG_CORNERS[this.pv.corners],
        segments: this.pv.segments * 4
      };
      const mode = EXPAND_MODES[this.pv.mode];
      const newGeometries = [];
      for (const inputObject of inputObjects) {
        const inputGeometry = inputObject.csgGeometry();
        const type = (0,CsgCoreType/* csgGeometryTypeFromGeometry */.HZ)(inputGeometry);
        const is2D = type == CsgCommon/* CsgGeometryType.PATH2 */.d.PATH2 || type == CsgCommon/* CsgGeometryType.GEOM2 */.d.GEOM2;
        if (is2D || mode == "2D & 3D (Slow)" /* _2D_AND_3D_ONLY */) {
          const result = expand(options, inputObject.csgGeometry());
          if (Type/* CoreType.isArray */.MR.isArray(result)) {
            newGeometries.push(...result);
          } else {
            newGeometries.push(result);
          }
        }
      }
      this.setCSGGeometries(newGeometries);
    } else {
      this.setCSGObjects([]);
    }
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/sop/CSGExtrudeLinear.ts






const { extrudeLinear } = src.extrusions;
class CSGExtrudeLinearSopParamsConfig extends params_ParamsConfig/* NodeParamsConfig */.yI {
  constructor() {
    super(...arguments);
    /** @param height */
    this.height = params_ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(0.5, {
      range: [1e-8, 1],
      rangeLocked: [true, false]
    });
    /** @param twistAngle */
    this.twistAngle = params_ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(0, {
      range: [0, 2 * Math.PI],
      rangeLocked: [true, false]
    });
    /** @param twistSteps */
    this.twistSteps = params_ParamsConfig/* ParamConfig.INTEGER */.XC.INTEGER(1, {
      range: [0, 10],
      rangeLocked: [true, false]
    });
  }
}
const CSGExtrudeLinear_ParamsConfig = new CSGExtrudeLinearSopParamsConfig();
class CSGExtrudeLinearSopNode extends _BaseCSG/* CSGSopNode */.O {
  constructor() {
    super(...arguments);
    this.paramsConfig = CSGExtrudeLinear_ParamsConfig;
  }
  static type() {
    return Sop/* SopType.CSG_EXTRUDE_LINEAR */.aB.CSG_EXTRUDE_LINEAR;
  }
  initializeNode() {
    this.io.inputs.setCount(1);
  }
  cook(inputCoreGroups) {
    const inputObjects = inputCoreGroups[0].csgObjects();
    if (inputObjects && inputObjects.length != 0) {
      const options = {
        height: this.pv.height,
        twistAngle: this.pv.twistAngle,
        twistSteps: this.pv.twistSteps
      };
      const newGeometries = [];
      for (const inputObject of inputObjects) {
        const inputGeometry = inputObject.csgGeometry();
        if ((0,CsgCoreType/* csgIsPath2 */.tB)(inputGeometry) || (0,CsgCoreType/* csgIsGeom2 */.IY)(inputGeometry)) {
          newGeometries.push(extrudeLinear(options, inputGeometry));
        } else {
          newGeometries.push(inputGeometry);
        }
      }
      this.setCSGGeometries(newGeometries);
    } else {
      this.setCSGObjects([]);
    }
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/sop/CSGExtrudeRectangular.ts






const { extrudeRectangular } = src.extrusions;
class CSGExtrudeRectangularSopParamsConfig extends params_ParamsConfig/* NodeParamsConfig */.yI {
  constructor() {
    super(...arguments);
    /** @param size */
    this.size = params_ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(0.5, {
      range: [1e-8, 1],
      rangeLocked: [true, false]
    });
    /** @param height */
    this.height = params_ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(0.5, {
      range: [1e-8, 1],
      rangeLocked: [true, false]
    });
  }
}
const CSGExtrudeRectangular_ParamsConfig = new CSGExtrudeRectangularSopParamsConfig();
class CSGExtrudeRectangularSopNode extends _BaseCSG/* CSGSopNode */.O {
  constructor() {
    super(...arguments);
    this.paramsConfig = CSGExtrudeRectangular_ParamsConfig;
  }
  static type() {
    return Sop/* SopType.CSG_EXTRUDE_RECTANGULAR */.aB.CSG_EXTRUDE_RECTANGULAR;
  }
  initializeNode() {
    this.io.inputs.setCount(1);
  }
  cook(inputCoreGroups) {
    const inputObjects = inputCoreGroups[0].csgObjects();
    if (inputObjects && inputObjects.length != 0) {
      const options = {
        size: this.pv.size,
        height: this.pv.height
      };
      const newGeometries = [];
      for (const inputObject of inputObjects) {
        const inputGeometry = inputObject.csgGeometry();
        if ((0,CsgCoreType/* csgIsPath2 */.tB)(inputGeometry) || (0,CsgCoreType/* csgIsGeom2 */.IY)(inputGeometry)) {
          newGeometries.push(extrudeRectangular(options, inputGeometry));
        } else {
          newGeometries.push(inputGeometry);
        }
      }
      this.setCSGGeometries(newGeometries);
    } else {
      this.setCSGObjects([]);
    }
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/sop/CSGExtrudeRotate.ts







const { extrudeRotate } = src.extrusions;
class CSGExtrudeRotateSopParamsConfig extends params_ParamsConfig/* NodeParamsConfig */.yI {
  constructor() {
    super(...arguments);
    /** @param angle */
    this.angle = params_ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(0, {
      range: [-2 * Math.PI, 2 * Math.PI],
      rangeLocked: [false, false],
      step: CsgConstant/* step */.Nb
    });
    /** @param start angle */
    this.startAngle = params_ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(0, {
      range: [-2 * Math.PI, 2 * Math.PI],
      rangeLocked: [false, false],
      step: CsgConstant/* step */.Nb
    });
    /** @param segments */
    this.segments = params_ParamsConfig/* ParamConfig.INTEGER */.XC.INTEGER(4, {
      range: [1, 64],
      rangeLocked: [true, false]
    });
  }
}
const CSGExtrudeRotate_ParamsConfig = new CSGExtrudeRotateSopParamsConfig();
class CSGExtrudeRotateSopNode extends _BaseCSG/* CSGSopNode */.O {
  constructor() {
    super(...arguments);
    this.paramsConfig = CSGExtrudeRotate_ParamsConfig;
  }
  static type() {
    return Sop/* SopType.CSG_EXTRUDE_ROTATE */.aB.CSG_EXTRUDE_ROTATE;
  }
  initializeNode() {
    this.io.inputs.setCount(1);
  }
  cook(inputCoreGroups) {
    const inputObjects = inputCoreGroups[0].csgObjects();
    if (inputObjects && inputObjects.length != 0) {
      const options = {
        angle: this.pv.angle,
        startAngle: this.pv.startAngle,
        segments: this.pv.segments * 4
      };
      const newGeometries = [];
      for (const inputObject of inputObjects) {
        const inputGeometry = inputObject.csgGeometry();
        if ((0,CsgCoreType/* csgIsGeom2 */.IY)(inputGeometry)) {
          newGeometries.push(extrudeRotate(options, inputGeometry));
        } else {
          newGeometries.push(inputGeometry);
        }
      }
      this.setCSGGeometries(newGeometries);
    } else {
      this.setCSGObjects([]);
    }
  }
}

// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/core/geometry/modules/csg/math/CsgMat4.ts
var CsgMat4 = __webpack_require__(37862);
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/sop/CSGHull.ts







const { hull, hullChain } = src.hulls;
class CSGHullSopParamsConfig extends params_ParamsConfig/* NodeParamsConfig */.yI {
  constructor() {
    super(...arguments);
    /** @param chain */
    this.chain = params_ParamsConfig/* ParamConfig.BOOLEAN */.XC.BOOLEAN(0);
  }
}
const CSGHull_ParamsConfig = new CSGHullSopParamsConfig();
class CSGHullSopNode extends _BaseCSG/* CSGSopNode */.O {
  constructor() {
    super(...arguments);
    this.paramsConfig = CSGHull_ParamsConfig;
  }
  static type() {
    return Sop/* SopType.CSG_HULL */.aB.CSG_HULL;
  }
  initializeNode() {
    this.io.inputs.setCount(1);
  }
  cook(inputCoreGroups) {
    const geom3 = [];
    const geom2 = [];
    const path2 = [];
    const objects = inputCoreGroups[0].csgObjects();
    if (objects) {
      for (const object of objects) {
        const geometry = object.csgGeometry();
        if ((0,CsgCoreType/* csgIsGeom3 */.Mq)(geometry)) {
          geom3.push(geometry);
        }
        if ((0,CsgCoreType/* csgIsGeom2 */.IY)(geometry)) {
          (0,CsgMat4/* geom2ApplyTransforms */.Qm)(geometry);
          geom2.push(geometry);
        }
        if ((0,CsgCoreType/* csgIsPath2 */.tB)(geometry)) {
          path2.push(geometry);
        }
      }
      if (geom3.length == 1) {
        geom3.push(geom3[0]);
      }
      if (geom2.length == 1) {
        geom2.push(geom2[0]);
      }
      if (path2.length == 1) {
        path2.push(path2[0]);
      }
      const method = this.pv.chain ? hullChain : hull;
      const newGeometries = [];
      if (geom3.length >= 2) {
        newGeometries.push(method(geom3));
      }
      if (geom2.length >= 2) {
        newGeometries.push(method(geom2));
      }
      if (path2.length >= 2) {
        newGeometries.push(method(path2));
      }
      this.setCSGGeometries(newGeometries);
    } else {
      this.setCSGObjects([]);
    }
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/sop/CSGLine.ts







const { line } = src.primitives;
const _lastPt = new three_module.Vector2();
const _pos = new three_module.Vector2();
class CSGLineSopParamsConfig extends params_ParamsConfig/* NodeParamsConfig */.yI {
  constructor() {
    super(...arguments);
    /** @param length */
    this.length = params_ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(1, { range: [0, 10] });
    /** @param points count */
    this.pointsCount = params_ParamsConfig/* ParamConfig.INTEGER */.XC.INTEGER(2, {
      range: [2, 128],
      rangeLocked: [true, false]
    });
    /** @param origin */
    this.origin = params_ParamsConfig/* ParamConfig.VECTOR2 */.XC.VECTOR2([0, 0]);
    /** @param direction */
    this.direction = params_ParamsConfig/* ParamConfig.VECTOR2 */.XC.VECTOR2([1, 0]);
  }
}
const CSGLine_ParamsConfig = new CSGLineSopParamsConfig();
class CSGLineSopNode extends _BaseCSG/* CSGSopNode */.O {
  constructor() {
    super(...arguments);
    this.paramsConfig = CSGLine_ParamsConfig;
  }
  static type() {
    return Sop/* SopType.CSG_LINE */.aB.CSG_LINE;
  }
  cook(inputCoreGroups) {
    const pointsCount = this.pv.pointsCount;
    const vec2s = new Array(pointsCount);
    _lastPt.copy(this.pv.direction).normalize().multiplyScalar(this.pv.length);
    for (let i = 0; i < pointsCount; i++) {
      const i_n = i / (pointsCount - 1);
      _pos.copy(_lastPt).multiplyScalar(i_n);
      _pos.add(this.pv.origin);
      const vec2 = [0, 0];
      vec2s[i] = vec2;
      vector2ToCsgVec2(_pos, vec2);
    }
    const geo = line(vec2s);
    this.setCSGGeometry(geo);
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/sop/CSGMirror.ts









const { mirror } = src.transforms;
class CSGMirrorSopParamsConfig extends params_ParamsConfig/* NodeParamsConfig */.yI {
  constructor() {
    super(...arguments);
    /** @param origin */
    this.origin = params_ParamsConfig/* ParamConfig.VECTOR3 */.XC.VECTOR3([0, 0, 0]);
    /** @param normal */
    this.normal = params_ParamsConfig/* ParamConfig.VECTOR3 */.XC.VECTOR3([0, 1, 0]);
    /** @param invert */
    this.invert = params_ParamsConfig/* ParamConfig.BOOLEAN */.XC.BOOLEAN(1);
  }
}
const CSGMirror_ParamsConfig = new CSGMirrorSopParamsConfig();
class CSGMirrorSopNode extends _BaseCSG/* CSGSopNode */.O {
  constructor() {
    super(...arguments);
    this.paramsConfig = CSGMirror_ParamsConfig;
    this._origin = [0, 0, 0];
    this._normal = [0, 0, 0];
  }
  static type() {
    return Sop/* SopType.CSG_MIRROR */.aB.CSG_MIRROR;
  }
  initializeNode() {
    this.io.inputs.setCount(1);
  }
  cook(inputCoreGroups) {
    const inputObjects = inputCoreGroups[0].csgObjects();
    if (inputObjects && inputObjects.length != 0) {
      vector3ToCsgVec3(this.pv.origin, this._origin);
      vector3ToCsgVec3(this.pv.normal, this._normal);
      const options = {
        origin: this._origin,
        normal: this._normal
      };
      const newGeometries = [];
      for (const inputObject of inputObjects) {
        const inputGeometry = inputObject.csgGeometry();
        let newGeometry = mirror(options, inputGeometry);
        (0,CsgMat4/* csgApplyTransform */.l6)(newGeometry);
        if ((0,CsgCoreType/* csgIsGeom3 */.Mq)(newGeometry)) {
          if ((0,Type/* isBooleanTrue */.bI)(this.pv.invert)) {
            const invertedGeometry = src.geometries.geom3.invert(newGeometry);
            newGeometry = invertedGeometry;
          }
        }
        newGeometries.push(newGeometry);
      }
      this.setCSGGeometries(newGeometries);
    } else {
      this.setCSGObjects([]);
    }
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/sop/CSGOffset.ts







const { offset } = (src_default()).expansions;
class CSGOffsetSopParamsConfig extends params_ParamsConfig/* NodeParamsConfig */.yI {
  constructor() {
    super(...arguments);
    /** @param delta */
    this.delta = params_ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(0, {
      range: [-1, 1],
      rangeLocked: [false, false]
    });
    /** @param corners */
    this.corners = params_ParamsConfig/* ParamConfig.INTEGER */.XC.INTEGER(CSG_CORNERS.indexOf(CsgCorner.ROUND), {
      menu: { entries: CSG_CORNERS.map((name, value) => ({ name, value })) }
    });
    /** @param segments */
    this.segments = params_ParamsConfig/* ParamConfig.INTEGER */.XC.INTEGER(1, {
      range: [1, 8],
      rangeLocked: [true, false]
    });
  }
}
const CSGOffset_ParamsConfig = new CSGOffsetSopParamsConfig();
class CSGOffsetSopNode extends _BaseCSG/* CSGSopNode */.O {
  constructor() {
    super(...arguments);
    this.paramsConfig = CSGOffset_ParamsConfig;
  }
  static type() {
    return Sop/* SopType.CSG_OFFSET */.aB.CSG_OFFSET;
  }
  initializeNode() {
    this.io.inputs.setCount(1);
  }
  cook(inputCoreGroups) {
    const inputObjects = inputCoreGroups[0].csgObjects();
    if (inputObjects && inputObjects.length != 0) {
      const options = {
        delta: this.pv.delta,
        corners: CSG_CORNERS[this.pv.corners],
        segments: this.pv.segments * 4
      };
      const newGeometries = [];
      for (const inputObject of inputObjects) {
        const inputGeometry = inputObject.csgGeometry();
        if ((0,CsgCoreType/* csgIsGeom2 */.IY)(inputGeometry) || (0,CsgCoreType/* csgIsPath2 */.tB)(inputGeometry)) {
          newGeometries.push(offset(options, inputGeometry));
        } else {
          newGeometries.push(inputGeometry);
        }
      }
      this.setCSGGeometries(newGeometries);
    } else {
      this.setCSGObjects([]);
    }
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/core/geometry/modules/csg/math/CsgMathVec2.ts

function csgVec2MultScalar(src, scalar) {
  src[0] *= scalar;
  src[1] *= scalar;
}
function csgVec2ToJSON(src) {
  return src;
}
function csgVec2sToJSON(src) {
  return src.map((v) => csgVec2ToJSON(v));
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/sop/CSGPolygon.ts






const { polygon } = src.primitives;
const DEFAULT_POINTS = [
  [-1, -1],
  [-1, 1],
  [1, 1],
  [1, -1]
];
const DEFAULT_PATHS = [[0, 1, 2, 3]];
class CSGPolygonSopParamsConfig extends params_ParamsConfig/* NodeParamsConfig */.yI {
  constructor() {
    super(...arguments);
    /** @param points */
    this.points = params_ParamsConfig/* ParamConfig.STRING */.XC.STRING(JSON.stringify(csgVec2sToJSON(DEFAULT_POINTS)));
    /** @param paths */
    this.paths = params_ParamsConfig/* ParamConfig.STRING */.XC.STRING(JSON.stringify(DEFAULT_PATHS));
  }
}
const CSGPolygon_ParamsConfig = new CSGPolygonSopParamsConfig();
class CSGPolygonSopNode extends _BaseCSG/* CSGSopNode */.O {
  constructor() {
    super(...arguments);
    this.paramsConfig = CSGPolygon_ParamsConfig;
  }
  static type() {
    return Sop/* SopType.CSG_POLYGON */.aB.CSG_POLYGON;
  }
  cook(inputCoreGroups) {
    try {
      const points = JSON.parse(this.pv.points);
      const paths = JSON.parse(this.pv.paths);
      const geo = polygon({
        points,
        paths
      });
      this.setCSGGeometry(geo);
    } catch (err) {
      const message = err instanceof Error ? err.message : "failed to create geometry";
      this.states.error.set(message);
      this.setCSGObjects([]);
    }
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/sop/CSGPolyhedron.ts






const { polyhedron } = src.primitives;
const CSGPolyhedron_DEFAULT_POINTS = [
  [-1, -1, -1],
  [-1, -1, 1],
  [1, 1, 1],
  [1, 1, -1]
];
const DEFAULT_FACES = [[0, 1, 2, 3]];
class CSGPolyhedronSopParamsConfig extends params_ParamsConfig/* NodeParamsConfig */.yI {
  constructor() {
    super(...arguments);
    /** @param points */
    this.points = params_ParamsConfig/* ParamConfig.STRING */.XC.STRING(JSON.stringify(csgVec3sToJSON(CSGPolyhedron_DEFAULT_POINTS)));
    /** @param paths */
    this.faces = params_ParamsConfig/* ParamConfig.STRING */.XC.STRING(JSON.stringify(DEFAULT_FACES));
    /** @param outward */
    this.outward = params_ParamsConfig/* ParamConfig.BOOLEAN */.XC.BOOLEAN(1);
  }
}
const CSGPolyhedron_ParamsConfig = new CSGPolyhedronSopParamsConfig();
class CSGPolyhedronSopNode extends _BaseCSG/* CSGSopNode */.O {
  constructor() {
    super(...arguments);
    this.paramsConfig = CSGPolyhedron_ParamsConfig;
  }
  static type() {
    return Sop/* SopType.CSG_POLYHEDRON */.aB.CSG_POLYHEDRON;
  }
  cook(inputCoreGroups) {
    try {
      const points = JSON.parse(this.pv.points);
      const faces = JSON.parse(this.pv.faces);
      const geo = polyhedron({
        points,
        faces,
        orientation: this.pv.outward ? "outward" : "inward"
      });
      this.setCSGGeometry(geo);
    } catch (err) {
      const message = err instanceof Error ? err.message : "failed to create geometry";
      this.states.error.set(message);
      this.setCSGObjects([]);
    }
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/sop/CSGProject.ts







const { project } = src.extrusions;
class CSGProjectSopParamsConfig extends params_ParamsConfig/* NodeParamsConfig */.yI {
  constructor() {
    super(...arguments);
    /** @param axis */
    this.axis = params_ParamsConfig/* ParamConfig.VECTOR3 */.XC.VECTOR3([0, 1, 0]);
    /** @param origin */
    this.origin = params_ParamsConfig/* ParamConfig.VECTOR3 */.XC.VECTOR3([0, 0, 0]);
  }
}
const CSGProject_ParamsConfig = new CSGProjectSopParamsConfig();
class CSGProjectSopNode extends _BaseCSG/* CSGSopNode */.O {
  constructor() {
    super(...arguments);
    this.paramsConfig = CSGProject_ParamsConfig;
    this._axis = [0, 0, 0];
    this._origin = [0, 0, 0];
  }
  static type() {
    return Sop/* SopType.CSG_PROJECT */.aB.CSG_PROJECT;
  }
  initializeNode() {
    this.io.inputs.setCount(1);
  }
  cook(inputCoreGroups) {
    const inputObjects = inputCoreGroups[0].csgObjects();
    if (inputObjects && inputObjects.length != 0) {
      vector3ToCsgVec3(this.pv.axis, this._axis);
      vector3ToCsgVec3(this.pv.origin, this._origin);
      const options = {
        axis: this._axis,
        origin: this._origin
      };
      const newGeometries = [];
      for (const inputObject of inputObjects) {
        const inputGeometry = inputObject.csgGeometry();
        if ((0,CsgCoreType/* csgIsGeom3 */.Mq)(inputGeometry)) {
          newGeometries.push(project(options, inputGeometry));
        } else {
          newGeometries.push(inputGeometry);
        }
      }
      this.setCSGGeometries(newGeometries);
    } else {
      this.setCSGObjects([]);
    }
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/sop/CSGRectangle.ts

var CSGRectangle_defProp = Object.defineProperty;
var CSGRectangle_defProps = Object.defineProperties;
var CSGRectangle_getOwnPropDescs = Object.getOwnPropertyDescriptors;
var CSGRectangle_getOwnPropSymbols = Object.getOwnPropertySymbols;
var CSGRectangle_hasOwnProp = Object.prototype.hasOwnProperty;
var CSGRectangle_propIsEnum = Object.prototype.propertyIsEnumerable;
var CSGRectangle_defNormalProp = (obj, key, value) => key in obj ? CSGRectangle_defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var CSGRectangle_spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (CSGRectangle_hasOwnProp.call(b, prop))
      CSGRectangle_defNormalProp(a, prop, b[prop]);
  if (CSGRectangle_getOwnPropSymbols)
    for (var prop of CSGRectangle_getOwnPropSymbols(b)) {
      if (CSGRectangle_propIsEnum.call(b, prop))
        CSGRectangle_defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var CSGRectangle_spreadProps = (a, b) => CSGRectangle_defProps(a, CSGRectangle_getOwnPropDescs(b));







const { rectangle, roundedRectangle } = src.primitives;
class CSGRectangleSopParamsConfig extends params_ParamsConfig/* NodeParamsConfig */.yI {
  constructor() {
    super(...arguments);
    /** @param size */
    this.size = params_ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(1);
    /** @param sizes */
    this.sizes = params_ParamsConfig/* ParamConfig.VECTOR2 */.XC.VECTOR2([1, 1]);
    /** @param center */
    this.center = params_ParamsConfig/* ParamConfig.VECTOR2 */.XC.VECTOR2([0, 0]);
    /** @param rounded */
    this.rounded = params_ParamsConfig/* ParamConfig.BOOLEAN */.XC.BOOLEAN(0);
    /** @param rounded radius */
    this.roundedRadius = params_ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(0.1, {
      range: [0, 1],
      rangeLocked: [true, false],
      visibleIf: { rounded: 1 }
    });
    /** @param rounded segments */
    this.roundedSegments = params_ParamsConfig/* ParamConfig.INTEGER */.XC.INTEGER(1, {
      range: [1, 10],
      rangeLocked: [true, false],
      visibleIf: { rounded: 1 }
    });
  }
}
const CSGRectangle_ParamsConfig = new CSGRectangleSopParamsConfig();
class CSGRectangleSopNode extends _BaseCSG/* CSGSopNode */.O {
  constructor() {
    super(...arguments);
    this.paramsConfig = CSGRectangle_ParamsConfig;
    this._center = [0, 0];
    this._sizes = [0, 0];
  }
  static type() {
    return Sop/* SopType.CSG_RECTANGLE */.aB.CSG_RECTANGLE;
  }
  cook(inputCoreGroups) {
    try {
      vector2ToCsgVec2(this.pv.center, this._center);
      vector2ToCsgVec2(this.pv.sizes, this._sizes);
      csgVec2MultScalar(this._sizes, this.pv.size);
      const rectangleOptions = {
        center: this._center,
        size: this._sizes
      };
      const createRoundedRectangle = () => {
        const maxSize = Math.min(this._sizes[0], this._sizes[1]) * 0.5 - 2 * src.maths.constants.EPS;
        const minSize = 2 * src.maths.constants.EPS;
        const roundRadius = _Module/* CoreMath.clamp */.Gj.clamp(this.pv.roundedRadius, minSize, maxSize);
        const roundedRectangleOptions = CSGRectangle_spreadProps(CSGRectangle_spreadValues({}, rectangleOptions), {
          roundRadius,
          segments: this.pv.roundedSegments * 4
        });
        return roundedRectangle(roundedRectangleOptions);
      };
      const geo = this.pv.rounded ? createRoundedRectangle() : rectangle(rectangleOptions);
      this.setCSGGeometry(geo);
    } catch (err) {
      const message = err instanceof Error ? err.message : "failed to create geometry";
      this.states.error.set(message);
      this.setCSGObjects([]);
    }
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/sop/CSGTransformReset.ts






const { mat4 } = src.maths;
class CSGTransformResetSopParamsConfig extends params_ParamsConfig/* NodeParamsConfig */.yI {
  constructor() {
    super(...arguments);
    /** @param bake matrix onto points */
    this.extract = params_ParamsConfig/* ParamConfig.BOOLEAN */.XC.BOOLEAN(0);
  }
}
const CSGTransformReset_ParamsConfig = new CSGTransformResetSopParamsConfig();
class CSGTransformResetSopNode extends _BaseCSG/* CSGSopNode */.O {
  constructor() {
    super(...arguments);
    this.paramsConfig = CSGTransformReset_ParamsConfig;
  }
  static type() {
    return Sop/* SopType.CSG_TRANSFORM_RESET */.aB.CSG_TRANSFORM_RESET;
  }
  initializeNode() {
    this.io.inputs.setCount(1);
  }
  cook(inputCoreGroups) {
    const objects = inputCoreGroups[0].csgObjects();
    if (objects) {
      for (const object of objects) {
        if (this.pv.extract) {
          (0,CsgMat4/* csgApplyTransform */.l6)(object.csgGeometry());
        } else {
          mat4.identity(object.csgGeometry().transforms);
        }
      }
      this.setCSGObjects(objects);
    } else {
      this.setCSGObjects([]);
    }
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/sop/CSGSphere.ts








const { sphere, geodesicSphere } = src.primitives;
class CSGSphereSopParamsConfig extends params_ParamsConfig/* NodeParamsConfig */.yI {
  constructor() {
    super(...arguments);
    /** @param radius */
    this.radius = params_ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(1, { range: [0, 10] });
    /** @param center */
    this.center = params_ParamsConfig/* ParamConfig.VECTOR3 */.XC.VECTOR3([0, 0, 0]);
    /** @param geodesic */
    this.geodesic = params_ParamsConfig/* ParamConfig.BOOLEAN */.XC.BOOLEAN(0);
    /** @param segments */
    this.segments = params_ParamsConfig/* ParamConfig.INTEGER */.XC.INTEGER(16, {
      range: [4, 128],
      rangeLocked: [true, false],
      visibleIf: { geodesic: 0 }
    });
    /** @param frequency */
    this.frequency = params_ParamsConfig/* ParamConfig.INTEGER */.XC.INTEGER(4, {
      range: [1, 32],
      rangeLocked: [true, false],
      visibleIf: { geodesic: 1 }
    });
  }
  /** @param axes */
  // axes = ParamConfig.VECTOR3([0, 1, 0]);
}
const CSGSphere_ParamsConfig = new CSGSphereSopParamsConfig();
class CSGSphereSopNode extends _BaseCSG/* CSGSopNode */.O {
  constructor() {
    super(...arguments);
    this.paramsConfig = CSGSphere_ParamsConfig;
    this._center = [0, 0, 0];
    this._matrix4 = new three_module.Matrix4();
  }
  static type() {
    return Sop/* SopType.CSG_SPHERE */.aB.CSG_SPHERE;
  }
  // private _axes: maths.vec3.Vec3 = [0, 1, 0];
  cook(inputCoreGroups) {
    vector3ToCsgVec3(this.pv.center, this._center);
    const geo = this.pv.geodesic ? this._createGeodesicSphere() : this._createSphere();
    this.setCSGGeometry(geo);
  }
  _createSphere() {
    return sphere({
      center: this._center,
      radius: this.pv.radius,
      segments: this.pv.segments
      // axes: this._axes,
    });
  }
  _createGeodesicSphere() {
    const geo = geodesicSphere({
      radius: this.pv.radius,
      frequency: this.pv.frequency * 6
      // mult by 6 here to make it more intuitive
    });
    if (this.pv.center.length() > 0) {
      this._matrix4.identity();
      this._matrix4.makeTranslation(this.pv.center.x, this.pv.center.y, this.pv.center.z);
      (0,CsgMat4/* csgApplyMatrix4 */.PL)(geo, this._matrix4);
    }
    return geo;
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/sop/CSGStar.ts






const { star } = src.primitives;
class CSGStarSopParamsConfig extends params_ParamsConfig/* NodeParamsConfig */.yI {
  constructor() {
    super(...arguments);
    /** @param center */
    this.center = params_ParamsConfig/* ParamConfig.VECTOR2 */.XC.VECTOR2([0, 0]);
    /** @param vertices */
    this.vertices = params_ParamsConfig/* ParamConfig.INTEGER */.XC.INTEGER(5, {
      range: [2, 10],
      rangeLocked: [true, false]
    });
    /** @param outer radius */
    this.innerRadius = params_ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(1, {
      range: [2 * src.maths.constants.EPS, 10],
      rangeLocked: [true, false]
    });
    /** @param outer radius */
    this.outerRadius = params_ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(2, {
      range: [2 * src.maths.constants.EPS, 10],
      rangeLocked: [true, false]
    });
    /** @param start angle */
    this.startAngle = params_ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(0, {
      range: [0, 2 * Math.PI],
      rangeLocked: [true, true]
    });
  }
}
const CSGStar_ParamsConfig = new CSGStarSopParamsConfig();
class CSGStarSopNode extends _BaseCSG/* CSGSopNode */.O {
  constructor() {
    super(...arguments);
    this.paramsConfig = CSGStar_ParamsConfig;
    this._center = [0, 0];
  }
  static type() {
    return Sop/* SopType.CSG_STAR */.aB.CSG_STAR;
  }
  cook(inputCoreGroups) {
    try {
      vector2ToCsgVec2(this.pv.center, this._center);
      const { vertices, outerRadius, innerRadius, startAngle } = this.pv;
      const geo = star({
        center: this._center,
        vertices,
        outerRadius,
        innerRadius,
        startAngle
      });
      this.setCSGGeometry(geo);
    } catch (err) {
      const message = err instanceof Error ? err.message : "failed to create geometry";
      this.states.error.set(message);
      this.setCSGObjects([]);
    }
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/sop/CSGTorus.ts






const { torus } = src.primitives;
class CSGTorusSopParamsConfig extends params_ParamsConfig/* NodeParamsConfig */.yI {
  constructor() {
    super(...arguments);
    /** @param inner radius */
    this.innerRadius = params_ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(0.25, {
      range: [2 * src.maths.constants.EPS, 1],
      rangeLocked: [true, false]
    });
    /** @param outer radius */
    this.outerRadius = params_ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(1, {
      range: [2 * src.maths.constants.EPS, 1],
      rangeLocked: [true, false]
    });
    /** @param inner segments */
    this.innerSegments = params_ParamsConfig/* ParamConfig.INTEGER */.XC.INTEGER(12, {
      range: [3, 32],
      rangeLocked: [true, false]
    });
    /** @param outer segments */
    this.outerSegments = params_ParamsConfig/* ParamConfig.INTEGER */.XC.INTEGER(32, {
      range: [3, 32],
      rangeLocked: [true, false]
    });
    /** @param inner rotation */
    this.innerRotation = params_ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(0, {
      range: [0, 2 * Math.PI],
      rangeLocked: [false, false]
    });
    /** @param open */
    this.open = params_ParamsConfig/* ParamConfig.BOOLEAN */.XC.BOOLEAN(0);
    /** @param start angle */
    this.startAngle = params_ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(0, {
      range: [0, 2 * Math.PI],
      rangeLocked: [false, false],
      step: CsgConstant/* step */.Nb,
      visibleIf: { open: 1 }
    });
    /** @param outer rotation */
    this.outerRotation = params_ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT("2 * $PI", {
      range: [0, 2 * Math.PI],
      rangeLocked: [false, false],
      step: CsgConstant/* step */.Nb,
      visibleIf: { open: 1 }
    });
  }
}
const CSGTorus_ParamsConfig = new CSGTorusSopParamsConfig();
class CSGTorusSopNode extends _BaseCSG/* CSGSopNode */.O {
  constructor() {
    super(...arguments);
    this.paramsConfig = CSGTorus_ParamsConfig;
  }
  static type() {
    return Sop/* SopType.CSG_TORUS */.aB.CSG_TORUS;
  }
  cook(inputCoreGroups) {
    try {
      const {
        innerRadius,
        outerRadius,
        innerSegments,
        outerSegments,
        innerRotation,
        open,
        outerRotation,
        startAngle
      } = this.pv;
      const innerRadius2 = Math.min(innerRadius, outerRadius - 1 * src.maths.constants.EPS);
      const geo = torus({
        innerRadius: innerRadius2,
        outerRadius,
        innerSegments,
        outerSegments,
        innerRotation,
        outerRotation: open ? outerRotation : 2 * Math.PI,
        startAngle: open ? startAngle : 0
      });
      this.setCSGGeometry(geo);
    } catch (err) {
      const message = err instanceof Error ? err.message : "failed to create geometry";
      this.states.error.set(message);
      this.setCSGObjects([]);
    }
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/sop/CSGTransform2D.ts

var CSGTransform2D_async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};




const _t = new three_module.Vector3();
const _r = new three_module.Vector3();
const _euler = new three_module.Euler();
const _q = new three_module.Quaternion();
const _s = new three_module.Vector3();
const _mat4 = new three_module.Matrix4();
class CSGTransform2DSopParamsConfig extends params_ParamsConfig/* NodeParamsConfig */.yI {
  constructor() {
    super(...arguments);
    /** @param translate */
    this.t = params_ParamsConfig/* ParamConfig.VECTOR2 */.XC.VECTOR2([0, 0]);
    /** @param rotation */
    this.r = params_ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(0, {
      range: [-180, 180],
      rangeLocked: [false, false]
    });
    /** @param scale (as a float) */
    this.s = params_ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(1, {
      range: [0, 2],
      step: 0.01
    });
  }
  /** @param pivot */
  // pivot = ParamConfig.VECTOR2([0, 0]);
}
const CSGTransform2D_ParamsConfig = new CSGTransform2DSopParamsConfig();
class CSGTransform2DSopNode extends _BaseCSG/* CSGSopNode */.O {
  constructor() {
    super(...arguments);
    this.paramsConfig = CSGTransform2D_ParamsConfig;
  }
  static type() {
    return Sop/* SopType.CSG_TRANSFORM_2D */.aB.CSG_TRANSFORM_2D;
  }
  initializeNode() {
    this.io.inputs.setCount(1);
  }
  cook(inputCoreGroups) {
    return CSGTransform2D_async(this, null, function* () {
      const coreGroup0 = inputCoreGroups[0];
      const newObjects = [];
      const csgObjects = coreGroup0.csgObjects();
      if (csgObjects) {
        _t.set(this.pv.t.x, 0, this.pv.t.y);
        _r.set(0, this.pv.r, 0).multiplyScalar(three_module.MathUtils.DEG2RAD);
        _euler.y = _r.y;
        _q.setFromEuler(_euler);
        _s.set(1, 1, 1).multiplyScalar(this.pv.s);
        _mat4.compose(_t, _q, _s);
        for (const csgObject of csgObjects) {
          csgObject.applyMatrix4(_mat4);
          newObjects.push(csgObject);
        }
      }
      this.setCSGObjects(newObjects);
    });
  }
}

// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/core/geometry/modules/csg/utils/TesselationParamsConfig.ts
var utils_TesselationParamsConfig = __webpack_require__(46447);
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/sop/CSGTriangulate.ts

var CSGTriangulate_async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};





class CSGTriangulateSopParamsConfig extends (0,utils_TesselationParamsConfig/* SOPCSGTesselationParamConfig */.kM)(params_ParamsConfig/* NodeParamsConfig */.yI) {
}
const CSGTriangulate_ParamsConfig = new CSGTriangulateSopParamsConfig();
class CSGTriangulateSopNode extends _BaseCSG/* CSGSopNode */.O {
  constructor() {
    super(...arguments);
    this.paramsConfig = CSGTriangulate_ParamsConfig;
  }
  static type() {
    return Sop/* SopType.CSG_TRIANGULATE */.aB.CSG_TRIANGULATE;
  }
  initializeNode() {
    this.io.inputs.setCount(1);
  }
  cook(inputCoreGroups) {
    return CSGTriangulate_async(this, null, function* () {
      const csgObjects = inputCoreGroups[0].csgObjects();
      if (csgObjects) {
        const newObjects = [];
        for (const cadObject of csgObjects) {
          const objects = cadObject.toObject3D(this.pv);
          if (objects) {
            if (Type/* CoreType.isArray */.MR.isArray(objects)) {
              newObjects.push(...objects);
            } else {
              newObjects.push(objects);
            }
          }
        }
        this.setObjects(newObjects);
      } else {
        this.setObjects([]);
      }
    });
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/sop/CSGTriangle.ts






const { degToRad: CSGTriangle_degToRad } = three_module.MathUtils;
const { triangle } = src.primitives;
var TriangleType = /* @__PURE__ */ ((TriangleType2) => {
  TriangleType2["AAA"] = "AAA";
  TriangleType2["AAS"] = "AAS";
  TriangleType2["ASA"] = "ASA";
  TriangleType2["SAS"] = "SAS";
  TriangleType2["SSA"] = "SSA";
  TriangleType2["SSS"] = "SSS";
  return TriangleType2;
})(TriangleType || {});
const TRIANGLE_TYPES = [
  "AAA" /* AAA */,
  "AAS" /* AAS */,
  "ASA" /* ASA */,
  "SAS" /* SAS */,
  "SSA" /* SSA */,
  "SSS" /* SSS */
];
class CSGTriangleSopParamsConfig extends params_ParamsConfig/* NodeParamsConfig */.yI {
  constructor() {
    super(...arguments);
    /** @param type */
    this.type = params_ParamsConfig/* ParamConfig.INTEGER */.XC.INTEGER(TRIANGLE_TYPES.indexOf("AAA" /* AAA */), {
      menu: { entries: TRIANGLE_TYPES.map((name, value) => ({ name, value })) }
    });
    /** @param angles */
    this.angles = params_ParamsConfig/* ParamConfig.VECTOR2 */.XC.VECTOR2([60, 60]);
  }
}
const CSGTriangle_ParamsConfig = new CSGTriangleSopParamsConfig();
class CSGTriangleSopNode extends _BaseCSG/* CSGSopNode */.O {
  constructor() {
    super(...arguments);
    this.paramsConfig = CSGTriangle_ParamsConfig;
    this._angles = [0, 0, 0];
  }
  static type() {
    return Sop/* SopType.CSG_TRIANGLE */.aB.CSG_TRIANGLE;
  }
  cook(inputCoreGroups) {
    try {
      const angles = this.pv.angles;
      const angle0 = CSGTriangle_degToRad(angles.x);
      const angle1 = CSGTriangle_degToRad(angles.y);
      const angle2 = Math.PI - (angle0 + angle1);
      this._angles[0] = angle0;
      this._angles[1] = angle1;
      this._angles[2] = angle2;
      const geo = triangle({
        type: TRIANGLE_TYPES[this.pv.type],
        values: this._angles
      });
      this.setCSGGeometry(geo);
    } catch (err) {
      const message = err instanceof Error ? err.message : "failed to create geometry";
      this.states.error.set(message);
      this.setCSGObjects([]);
    }
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/sop/CSGTube.ts

var CSGTube_defProp = Object.defineProperty;
var CSGTube_defProps = Object.defineProperties;
var CSGTube_getOwnPropDescs = Object.getOwnPropertyDescriptors;
var CSGTube_getOwnPropSymbols = Object.getOwnPropertySymbols;
var CSGTube_hasOwnProp = Object.prototype.hasOwnProperty;
var CSGTube_propIsEnum = Object.prototype.propertyIsEnumerable;
var CSGTube_defNormalProp = (obj, key, value) => key in obj ? CSGTube_defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var CSGTube_spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (CSGTube_hasOwnProp.call(b, prop))
      CSGTube_defNormalProp(a, prop, b[prop]);
  if (CSGTube_getOwnPropSymbols)
    for (var prop of CSGTube_getOwnPropSymbols(b)) {
      if (CSGTube_propIsEnum.call(b, prop))
        CSGTube_defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var CSGTube_spreadProps = (a, b) => CSGTube_defProps(a, CSGTube_getOwnPropDescs(b));






const { cylinder, roundedCylinder } = src.primitives;
class CSGTubeSopParamsConfig extends params_ParamsConfig/* NodeParamsConfig */.yI {
  constructor() {
    super(...arguments);
    /** @param height */
    this.height = params_ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(1, { range: [0, 10] });
    /** @param radius */
    this.radius = params_ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(1, { range: [0, 10] });
    /** @param segments */
    this.segments = params_ParamsConfig/* ParamConfig.INTEGER */.XC.INTEGER(32, {
      range: [4, 128],
      rangeLocked: [true, false]
    });
    /** @param center */
    this.center = params_ParamsConfig/* ParamConfig.VECTOR3 */.XC.VECTOR3([0, 0, 0]);
    /** @param rounded */
    this.rounded = params_ParamsConfig/* ParamConfig.BOOLEAN */.XC.BOOLEAN(0);
    /** @param rounded radius */
    this.roundedRadius = params_ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(0.1, {
      range: [0, 1],
      rangeLocked: [true, false],
      visibleIf: { rounded: 1 }
    });
  }
}
const CSGTube_ParamsConfig = new CSGTubeSopParamsConfig();
class CSGTubeSopNode extends _BaseCSG/* CSGSopNode */.O {
  constructor() {
    super(...arguments);
    this.paramsConfig = CSGTube_ParamsConfig;
    this._center = [0, 0, 0];
  }
  static type() {
    return Sop/* SopType.CSG_TUBE */.aB.CSG_TUBE;
  }
  cook(inputCoreGroups) {
    try {
      vector3ToCsgVec3(this.pv.center, this._center);
      const { height, radius, segments } = this.pv;
      const cylinderOptions = {
        center: this._center,
        height,
        radius,
        segments
      };
      const createRoundedCylinder = () => {
        const maxSize = Math.min(height * 0.5 - 2 * src.maths.constants.EPS, radius - 2 * src.maths.constants.EPS);
        const minSize = 2 * src.maths.constants.EPS;
        const roundRadius = _Module/* CoreMath.clamp */.Gj.clamp(this.pv.roundedRadius, minSize, maxSize);
        const roundedCylinderOptions = CSGTube_spreadProps(CSGTube_spreadValues({}, cylinderOptions), {
          roundRadius
        });
        return roundedCylinder(roundedCylinderOptions);
      };
      const geo = this.pv.rounded ? createRoundedCylinder() : cylinder(cylinderOptions);
      this.setCSGGeometry(geo);
    } catch (err) {
      const message = err instanceof Error ? err.message : "failed to create geometry";
      this.states.error.set(message);
      this.setCSGObjects([]);
    }
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/sop/CSGTubeElliptic.ts








const { cylinderElliptic } = src.primitives;
class CSGTubeEllipticSopParamsConfig extends params_ParamsConfig/* NodeParamsConfig */.yI {
  constructor() {
    super(...arguments);
    /** @param height */
    this.height = params_ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(1, { range: [0, 10] });
    /** @param start radius */
    this.startRadius = params_ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(1, {
      range: [0, 10],
      rangeLocked: [true, false]
    });
    /** @param start radiuses */
    this.startRadiuses = params_ParamsConfig/* ParamConfig.VECTOR2 */.XC.VECTOR2([1, 1]);
    /** @param end radius */
    this.endRadius = params_ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(1, {
      range: [0, 10],
      rangeLocked: [true, false]
    });
    /** @param end radius */
    this.endRadiuses = params_ParamsConfig/* ParamConfig.VECTOR2 */.XC.VECTOR2([1, 1]);
    /** @param segments */
    this.segments = params_ParamsConfig/* ParamConfig.INTEGER */.XC.INTEGER(32, {
      range: [4, 128],
      rangeLocked: [true, false]
    });
    /** @param center */
    this.center = params_ParamsConfig/* ParamConfig.VECTOR3 */.XC.VECTOR3([0, 0, 0]);
    /** @param open */
    this.open = params_ParamsConfig/* ParamConfig.BOOLEAN */.XC.BOOLEAN(0);
    /** @param start angle */
    this.startAngle = params_ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(0, {
      range: [0, 2 * Math.PI],
      rangeLocked: [true, true],
      step: CsgConstant/* step */.Nb,
      visibleIf: { open: 1 }
    });
    /** @param end angle */
    this.endAngle = params_ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT("$PI", {
      range: [0, 2 * Math.PI],
      rangeLocked: [true, true],
      step: CsgConstant/* step */.Nb,
      visibleIf: { open: 1 }
    });
  }
}
const CSGTubeElliptic_ParamsConfig = new CSGTubeEllipticSopParamsConfig();
class CSGTubeEllipticSopNode extends _BaseCSG/* CSGSopNode */.O {
  constructor() {
    super(...arguments);
    this.paramsConfig = CSGTubeElliptic_ParamsConfig;
    this._center = [0, 0, 0];
    this._startRadiuses = [0, 0];
    this._endRadiuses = [0, 0];
  }
  static type() {
    return Sop/* SopType.CSG_TUBE_ELLIPTIC */.aB.CSG_TUBE_ELLIPTIC;
  }
  cook(inputCoreGroups) {
    vector3ToCsgVec3(this.pv.center, this._center);
    vector2ToCsgVec2(this.pv.startRadiuses, this._startRadiuses);
    vector2ToCsgVec2(this.pv.endRadiuses, this._endRadiuses);
    const { startRadius, endRadius, height, segments, open } = this.pv;
    csgVec2MultScalar(this._startRadiuses, startRadius);
    csgVec2MultScalar(this._endRadiuses, endRadius);
    const geo = cylinderElliptic({
      center: this._center,
      height,
      startRadius: this._startRadiuses,
      endRadius: this._endRadiuses,
      segments,
      startAngle: open ? this.pv.startAngle : 0,
      endAngle: open ? this.pv.endAngle : 0
    });
    this.setCSGGeometry(geo);
  }
}

// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/nodes/sop/CSS2DObject.ts
var CSS2DObject = __webpack_require__(77418);
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/core/render/CSSRenderers/CSS3DObject.ts

var CSS3DObject_defProp = Object.defineProperty;
var CSS3DObject_defProps = Object.defineProperties;
var CSS3DObject_getOwnPropDescs = Object.getOwnPropertyDescriptors;
var CSS3DObject_getOwnPropSymbols = Object.getOwnPropertySymbols;
var CSS3DObject_hasOwnProp = Object.prototype.hasOwnProperty;
var CSS3DObject_propIsEnum = Object.prototype.propertyIsEnumerable;
var CSS3DObject_defNormalProp = (obj, key, value) => key in obj ? CSS3DObject_defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var CSS3DObject_spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (CSS3DObject_hasOwnProp.call(b, prop))
      CSS3DObject_defNormalProp(a, prop, b[prop]);
  if (CSS3DObject_getOwnPropSymbols)
    for (var prop of CSS3DObject_getOwnPropSymbols(b)) {
      if (CSS3DObject_propIsEnum.call(b, prop))
        CSS3DObject_defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var CSS3DObject_spreadProps = (a, b) => CSS3DObject_defProps(a, CSS3DObject_getOwnPropDescs(b));


class CSS3DObject extends three_module.Object3D {
  constructor(element = document.createElement("div")) {
    super();
    this.element = element;
    this.isCSS3DObject = true;
    this.element = element;
    this.element.style.position = "absolute";
    this.element.setAttribute("draggable", false);
  }
  copy(source, recursive) {
    super.copy(source, recursive);
    this.element = source.element.cloneNode(true);
    return this;
  }
}
class CSS3DSprite extends (/* unused pure expression or super */ null && (CSS3DObject)) {
  constructor(element) {
    super(element);
    this.isCSS3DSprite = true;
    this.rotation2D = 0;
    this.rotation2D = 0;
  }
  copy(source, recursive) {
    super.copy(source, recursive);
    this.rotation2D = source.rotation2D;
    return this;
  }
}
function createCSS3DObject(options) {
  const { id, className, html, scale } = options;
  const element = document.createElement("div");
  element.id = id;
  element.className = className;
  element.innerHTML = html;
  const CSSObject = new CSS3DObject(element);
  CSSObject.matrixAutoUpdate = false;
  if (options.object) {
    (0,CSSObjectAttribute/* CSSObjectElementCopyObjectAttributes */.Ff)(element, CSS3DObject_spreadProps(CSS3DObject_spreadValues({}, options), {
      object: options.object,
      CSSObject
    }));
    let child;
    while (child = options.object.children.pop()) {
      CSSObject.add(child);
    }
    CSSObject.position.copy(options.object.position);
    CSSObject.quaternion.copy(options.object.quaternion);
    CSSObject.scale.multiplyScalar(scale);
    CSSObject.updateMatrix();
  }
  return CSSObject;
}

// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/poly/PolyOnObjectsAddRemoveHooksController.ts
var PolyOnObjectsAddRemoveHooksController = __webpack_require__(34053);
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/sop/CSS3DObject.ts












class CSS3DObjectSopParamsConfig extends params_ParamsConfig/* NodeParamsConfig */.yI {
  constructor() {
    super(...arguments);
    /** @param toggles on if attributes are copied from the geometry to the html element */
    this.copyAttributes = params_ParamsConfig/* ParamConfig.BOOLEAN */.XC.BOOLEAN(true);
    /** @param names of the attributes that are copied from the geometry to the html element */
    this.attributesToCopy = params_ParamsConfig/* ParamConfig.STRING */.XC.STRING("", {
      visibleIf: { copyAttributes: true }
    });
    /** @param HTML elements may appear to large at first, so this gives you a quick way to scale them down */
    this.scale = params_ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(0.02);
    /** @param defines if the vertex id attribute is used to create the html id attribute */
    this.overrideId = params_ParamsConfig/* ParamConfig.BOOLEAN */.XC.BOOLEAN(true);
    /** @param value of the html element id attribute */
    this.id = params_ParamsConfig/* ParamConfig.STRING */.XC.STRING(CSSObjectAttribute/* DEFAULT_CSS3DOBJECT.id */.jq.id, {
      visibleIf: { overrideId: 1 }
    });
    /** @param defines if the vertex class attribute is used to create the html class */
    this.overrideClassName = params_ParamsConfig/* ParamConfig.BOOLEAN */.XC.BOOLEAN(true);
    /** @param value of the html class */
    this.className = params_ParamsConfig/* ParamConfig.STRING */.XC.STRING(CSSObjectAttribute/* DEFAULT_CSS3DOBJECT.className */.jq.className, {
      visibleIf: { overrideClassName: 1 }
    });
    /** @param defines if the vertex html attribute is used to create the html content */
    this.overrideHTML = params_ParamsConfig/* ParamConfig.BOOLEAN */.XC.BOOLEAN(true);
    /** @param value of the html content */
    this.html = params_ParamsConfig/* ParamConfig.STRING */.XC.STRING(CSSObjectAttribute/* DEFAULT_CSS3DOBJECT.html */.jq.html, {
      visibleIf: { overrideHTML: 1 },
      language: OptionsController/* StringParamLanguage.HTML */.qs.HTML
    });
  }
}
const CSS3DObject_ParamsConfig = new CSS3DObjectSopParamsConfig();
class CSS3DObjectSopNode extends sop_Base/* TypedSopNode */.x {
  constructor() {
    super(...arguments);
    this.paramsConfig = CSS3DObject_ParamsConfig;
  }
  static type() {
    return Sop/* SopType.CSS3D_OBJECT */.aB.CSS3D_OBJECT;
  }
  initializeNode() {
    this.io.inputs.setCount(0, 1);
    this.io.inputs.initInputsClonedState(InputCloneMode/* InputCloneMode.FROM_NODE */.m.FROM_NODE);
  }
  cook(inputCoreGroups) {
    const coreGroup = inputCoreGroups[0];
    if (coreGroup) {
      const objects = coreGroup.allObjects();
      for (const object of objects) {
        this._addAttributes(object);
      }
      this.setCoreGroup(coreGroup);
    } else {
      const object = new three_module.Object3D();
      object.name = this.name();
      this._addAttributes(object);
      this.setObjects([object]);
    }
  }
  _addAttributes(object) {
    Poly/* Poly.onObjectsAddRemoveHooks.assignOnAddHookHandler */.L.onObjectsAddRemoveHooks.assignOnAddHookHandler(object, this);
    if (this.pv.overrideId) {
      CSSObjectAttribute/* CoreCSSObjectAttribute.setElementId */.oD.setElementId(object, this.pv.id);
    }
    if (this.pv.overrideClassName) {
      CSSObjectAttribute/* CoreCSSObjectAttribute.setElementClass */.oD.setElementClass(object, this.pv.className);
    }
    if (this.pv.overrideHTML) {
      CSSObjectAttribute/* CoreCSSObjectAttribute.setElementHTML */.oD.setElementHTML(object, this.pv.html);
    }
    CSSObjectAttribute/* CoreCSSObjectAttribute.setCopyAttributes */.oD.setCopyAttributes(object, this.pv.copyAttributes);
    CSSObjectAttribute/* CoreCSSObjectAttribute.setAttributesToCopy */.oD.setAttributesToCopy(object, this.pv.attributesToCopy);
    CSSObjectAttribute/* CoreCSSObjectAttribute.setScale */.oD.setScale(object, this.pv.scale);
  }
  updateObjectOnAdd(object, parent) {
    const id = CSSObjectAttribute/* CoreCSSObjectAttribute.getElementId */.oD.getElementId(object);
    const className = CSSObjectAttribute/* CoreCSSObjectAttribute.getElementClass */.oD.getElementClass(object);
    const html = CSSObjectAttribute/* CoreCSSObjectAttribute.getElementHTML */.oD.getElementHTML(object);
    const copyAttributes = CSSObjectAttribute/* CoreCSSObjectAttribute.getCopyAttributes */.oD.getCopyAttributes(object);
    const attributesToCopy = CSSObjectAttribute/* CoreCSSObjectAttribute.getAttributesToCopy */.oD.getAttributesToCopy(object);
    const scale = CSSObjectAttribute/* CoreCSSObjectAttribute.getScale */.oD.getScale(object);
    const attribNames = [];
    const CSSObject = createCSS3DObject({
      object,
      id,
      className,
      html,
      copyAttributes,
      attributesToCopy: (0,core_String/* stringToAttribNames */.Fz)(attributesToCopy, attribNames),
      scale
    });
    (0,PolyOnObjectsAddRemoveHooksController/* replaceChild */.rS)(parent, object, CSSObject);
  }
}

// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/nodes/sop/CubeCamera.ts
var sop_CubeCamera = __webpack_require__(71716);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/nodes/sop/Data.ts
var Data = __webpack_require__(46627);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/nodes/sop/DataUrl.ts + 2 modules
var DataUrl = __webpack_require__(73141);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/node_modules/three/examples/jsm/geometries/DecalGeometry.js
var DecalGeometry = __webpack_require__(74991);
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/operations/sop/Decal.ts








class DecalSopOperation extends operations_sop_Base/* BaseSopOperation */.U {
  constructor() {
    super(...arguments);
    this._r = new three_module.Vector3();
    this._rotation = new three_module.Euler(0, 0, 0);
    this._scale = new three_module.Vector3(1, 1, 1);
  }
  static type() {
    return "decal";
  }
  cook(inputContents, params) {
    const inputCoreGroup = inputContents[0];
    this._r.copy(params.r).multiplyScalar(three_module.MathUtils.DEG2RAD);
    this._rotation.set(this._r.x, this._r.y, this._r.z);
    this._scale.copy(params.s).multiplyScalar(params.scale);
    const objects = inputCoreGroup.threejsObjectsWithGeo();
    const decalObjects = [];
    for (let object of objects) {
      if (object.isMesh) {
        const decal = new DecalGeometry/* DecalGeometry */.k(object, params.t, this._rotation, this._scale);
        const decalObject = new three_module.Mesh(decal, object.material);
        decalObjects.push(decalObject);
      }
    }
    return this.createCoreGroupFromObjects(decalObjects);
  }
}
DecalSopOperation.DEFAULT_PARAMS = {
  t: new three_module.Vector3(0, 0, 0),
  r: new three_module.Vector3(0, 0, 0),
  s: new three_module.Vector3(1, 1, 1),
  scale: 1
};
DecalSopOperation.INPUT_CLONED_STATE = InputCloneMode/* InputCloneMode.NEVER */.m.NEVER;

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/sop/Decal.ts





const Decal_DEFAULT = DecalSopOperation.DEFAULT_PARAMS;
class DecalSopParamsConfig extends params_ParamsConfig/* NodeParamsConfig */.yI {
  constructor() {
    super(...arguments);
    /** @param decal position */
    this.t = params_ParamsConfig/* ParamConfig.VECTOR3 */.XC.VECTOR3(Decal_DEFAULT.t);
    /** @param decal rotation */
    this.r = params_ParamsConfig/* ParamConfig.VECTOR3 */.XC.VECTOR3(Decal_DEFAULT.r);
    /** @param decal scale */
    this.s = params_ParamsConfig/* ParamConfig.VECTOR3 */.XC.VECTOR3(Decal_DEFAULT.s);
    /** @param decal scale multipler */
    this.scale = params_ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(Decal_DEFAULT.scale);
  }
}
const Decal_ParamsConfig = new DecalSopParamsConfig();
class DecalSopNode extends sop_Base/* TypedSopNode */.x {
  constructor() {
    super(...arguments);
    this.paramsConfig = Decal_ParamsConfig;
  }
  static type() {
    return Sop/* SopType.DECAL */.aB.DECAL;
  }
  initializeNode() {
    this.io.inputs.setCount(0, 1);
    this.io.inputs.initInputsClonedState(DecalSopOperation.INPUT_CLONED_STATE);
  }
  cook(input_contents) {
    this._operation = this._operation || new DecalSopOperation(this._scene, this.states, this);
    const core_group = this._operation.cook(input_contents, this.pv);
    this.setCoreGroup(core_group);
  }
}

// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/nodes/sop/Decompose.ts
var Decompose = __webpack_require__(26805);
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/sop/Delay.ts




class DelaySopParamsConfig extends params_ParamsConfig/* NodeParamsConfig */.yI {
  constructor() {
    super(...arguments);
    /** @param duration in milliseconds */
    this.duration = params_ParamsConfig/* ParamConfig.INTEGER */.XC.INTEGER(1e3, {
      range: [0, 1e3],
      rangeLocked: [true, false]
    });
  }
}
const sop_Delay_ParamsConfig = new DelaySopParamsConfig();
class DelaySopNode extends sop_Base/* TypedSopNode */.x {
  constructor() {
    super(...arguments);
    this.paramsConfig = sop_Delay_ParamsConfig;
  }
  static type() {
    return "delay";
  }
  initializeNode() {
    this.io.inputs.setCount(1);
    this.io.inputs.initInputsClonedState(InputCloneMode/* InputCloneMode.ALWAYS */.m.ALWAYS);
  }
  cook(inputs_contents) {
    const core_group = inputs_contents[0];
    const c = () => {
      this.setCoreGroup(core_group);
    };
    setTimeout(c, Math.max(this.pv.duration, 0));
  }
}

// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/nodes/sop/Delete.ts + 6 modules
var Delete = __webpack_require__(33742);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/nodes/sop/DeleteByName.ts
var DeleteByName = __webpack_require__(14063);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/nodes/sop/DirectionalLight.ts
var sop_DirectionalLight = __webpack_require__(70448);
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/sop/DrawRange.ts





class DrawRangeSopParamsConfig extends params_ParamsConfig/* NodeParamsConfig */.yI {
  constructor() {
    super(...arguments);
    /** @param start of the draw range */
    this.start = params_ParamsConfig/* ParamConfig.INTEGER */.XC.INTEGER(0, {
      range: [0, 100],
      rangeLocked: [true, false]
    });
    /** @param defines if count is used */
    this.useCount = params_ParamsConfig/* ParamConfig.BOOLEAN */.XC.BOOLEAN(0);
    /** @param number of items in the draw range */
    this.count = params_ParamsConfig/* ParamConfig.INTEGER */.XC.INTEGER(0, {
      range: [0, 100],
      rangeLocked: [true, false],
      visibleIf: { useCount: 1 }
    });
  }
}
const DrawRange_ParamsConfig = new DrawRangeSopParamsConfig();
class DrawRangeSopNode extends sop_Base/* TypedSopNode */.x {
  constructor() {
    super(...arguments);
    this.paramsConfig = DrawRange_ParamsConfig;
  }
  static type() {
    return "drawRange";
  }
  initializeNode() {
    this.io.inputs.setCount(0, 1);
    this.io.inputs.initInputsClonedState(InputCloneMode/* InputCloneMode.FROM_NODE */.m.FROM_NODE);
  }
  cook(input_contents) {
    const core_group = input_contents[0];
    const objects = core_group.threejsObjects();
    for (const object of objects) {
      const geometry = object.geometry;
      if (geometry) {
        const draw_range = geometry.drawRange;
        draw_range.start = this.pv.start;
        if ((0,Type/* isBooleanTrue */.bI)(this.pv.useCount)) {
          draw_range.count = this.pv.count;
        } else {
          draw_range.count = Infinity;
        }
      }
    }
    this.setCoreGroup(core_group);
  }
}

// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/nodes/sop/EmptyObject.ts
var EmptyObject = __webpack_require__(57649);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/nodes/sop/EntityBuilder.ts + 3 modules
var EntityBuilder = __webpack_require__(57966);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/nodes/sop/ExporterGLTF.ts + 2 modules
var ExporterGLTF = __webpack_require__(65361);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/nodes/sop/ExporterOBJ.ts + 1 modules
var ExporterOBJ = __webpack_require__(22977);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/nodes/sop/ExporterPLY.ts + 1 modules
var ExporterPLY = __webpack_require__(78831);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/nodes/sop/ExporterSTL.ts + 1 modules
var ExporterSTL = __webpack_require__(99222);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/core/geometry/modules/three/ThreejsPoint.ts
var ThreejsPoint = __webpack_require__(78471);
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/core/geometry/modules/three/CoreFace.ts




const dummyMesh = new three_module.Mesh();
const _positions = [new three_module.Vector3(), new three_module.Vector3(), new three_module.Vector3()];
const _triangle = new three_module.Triangle();
const barycentricCoordinates = new three_module.Vector3();
const barycentricCoordinatesArray = [0, 0, 0];
class CoreFace {
  constructor() {
    this._index = 0;
    this._corePoint = new ThreejsPoint/* ThreejsPoint */.B(dummyMesh, 0);
    this._points = [
      new ThreejsPoint/* ThreejsPoint */.B(dummyMesh, 0),
      new ThreejsPoint/* ThreejsPoint */.B(dummyMesh, 0),
      new ThreejsPoint/* ThreejsPoint */.B(dummyMesh, 0)
    ];
  }
  setGeometry(geometry) {
    this._geometry = geometry;
    return this;
  }
  setIndex(index, geometry) {
    this._index = index;
    if (geometry) {
      this._geometry = geometry;
    }
    return this;
  }
  index() {
    return this._index;
  }
  // points() {
  // 	return (this._points = this._points || this._getPoints());
  // }
  // applyMatrix4(matrix: Matrix4) {
  // 	for (let point of this.points()) {
  // 		point.applyMatrix4(matrix);
  // 	}
  // }
  points(points) {
    var _a;
    if (!this._geometry) {
      console.warn("no geometry");
      return;
    }
    const indexArray = ((_a = this._geometry.index) == null ? void 0 : _a.array) || [];
    const start = this._index * 3;
    dummyMesh.geometry = this._geometry;
    points[0].setIndex(indexArray[start + 0], dummyMesh);
    points[1].setIndex(indexArray[start + 1], dummyMesh);
    points[2].setIndex(indexArray[start + 2], dummyMesh);
  }
  // positions() {
  // 	return (this._positions = this._positions || this._getPositions());
  // }
  positions(target) {
    if (!this._geometry) {
      return;
    }
    dummyMesh.geometry = this._geometry;
    this._corePoint.setIndex(this._index * 3 + 0, dummyMesh).position(target[0]);
    this._corePoint.setIndex(this._index * 3 + 1, dummyMesh).position(target[1]);
    this._corePoint.setIndex(this._index * 3 + 2, dummyMesh).position(target[2]);
  }
  triangle(target) {
    this.positions(_positions);
    target.a.copy(_positions[0]);
    target.b.copy(_positions[1]);
    target.c.copy(_positions[2]);
  }
  // private _get_triangle(target:Triangle): void {
  // 	const positions = this.positions();
  // 	return new Triangle(positions[0], positions[1], positions[2]);
  // }
  deltas(target) {
    this.positions(_positions);
    target[0].copy(_positions[1]).sub(_positions[0]);
    target[1].copy(_positions[2]).sub(_positions[0]);
  }
  // private _getDeltas(): Vector3Array2 {
  // 	const positions = this.positions();
  // 	// return [positions[1].clone().sub(positions[0]), positions[2].clone().sub(positions[0])];
  // }
  area() {
    this.triangle(_triangle);
    return _triangle.getArea();
  }
  center(target) {
    this.positions(_positions);
    target.x = (_positions[0].x + _positions[1].x + _positions[2].x) / 3;
    target.y = (_positions[0].y + _positions[1].y + _positions[2].y) / 3;
    target.z = (_positions[0].z + _positions[1].z + _positions[2].z) / 3;
    return target;
  }
  // randomPosition(seed: number, target: Vector3) {
  // 	let weight0 = CoreMath.randFloat(seed);
  // 	let weight1 = CoreMath.randFloat(seed * 6541);
  // 	// let weights = [, CoreMath.randFloat(seed * 6541)];
  // 	if (weight0 + weight1 > 1) {
  // 		weight0 = 1 - weight0;
  // 		weight1 = 1 - weight1;
  // 	}
  // 	this.positions(_positions);
  // 	this.deltas(_deltas);
  // 	target.copy(_positions[0]).add(_deltas[0].multiplyScalar(weight0)).add(_deltas[1].multiplyScalar(weight1));
  // 	// return [0]
  // 	// 	.clone()
  // 	// 	.add(this.deltas()[0].clone().multiplyScalar(weights[0]))
  // 	// 	.add(this.deltas()[1].clone().multiplyScalar(weights[1]));
  // }
  // random_position(seed: number){
  // 	let weights = [
  // 		CoreMath.rand_float(seed),
  // 		CoreMath.rand_float(seed*524),
  // 		CoreMath.rand_float(seed*4631)
  // 	]
  // 	const sum = ArrayUtils.sum(weights)
  // 	weights = weights.map(w=>w/sum)
  // 	const pos = new Vector3()
  // 	let positions = this.positions().map((p,i)=> p.multiplyScalar(weights[i]))
  // 	positions.forEach(p=>{
  // 		pos.add(p)
  // 	})
  // 	return pos
  // }
  attribValueAtPosition(attrib_name, position) {
    if (!this._geometry) {
      return;
    }
    this.triangle(_triangle);
    _triangle.getBarycoord(position, barycentricCoordinates);
    barycentricCoordinates.toArray(barycentricCoordinatesArray);
    const weights = barycentricCoordinatesArray;
    const attrib = this._geometry.attributes[attrib_name];
    const attribSize = attrib.itemSize;
    this.points(this._points);
    const pointValues = this._points.map((point) => point.attribValue(attrib_name));
    let newAttribValue;
    let sum;
    let index = 0;
    switch (attribSize) {
      case 1: {
        sum = 0;
        for (const pointValue of pointValues) {
          sum += pointValue * weights[index];
          index++;
        }
        newAttribValue = sum;
        break;
      }
      default: {
        for (const pointValue of pointValues) {
          const weightedValue = pointValue.multiplyScalar(weights[index]);
          if (sum) {
            sum.add(weightedValue);
          } else {
            sum = weightedValue;
          }
          index++;
        }
        newAttribValue = sum;
      }
    }
    return newAttribValue;
  }
  static interpolatedValue(geometry, face, intersectPoint, attrib) {
    const pointIndices = [face.a, face.b, face.c];
    const positionAttrib = geometry.getAttribute("position");
    const positionAttribArray = positionAttrib.array;
    const pointPositions = pointIndices.map(
      (i) => new three_module.Vector3(
        positionAttribArray[i * 3 + 0],
        positionAttribArray[i * 3 + 1],
        positionAttribArray[i * 3 + 2]
      )
    );
    const attribSize = attrib.itemSize;
    const attribArray = attrib.array;
    let attribValues = [];
    switch (attribSize) {
      case 1:
        attribValues = pointIndices.map((i) => attribArray[i]);
        break;
      case 2:
        attribValues = pointIndices.map((i) => new three_module.Vector2(attribArray[i * 2 + 0], attribArray[i * 2 + 1]));
        break;
      case 3:
        attribValues = pointIndices.map(
          (i) => new three_module.Vector3(attribArray[i * 3 + 0], attribArray[i * 3 + 1], attribArray[i * 3 + 2])
        );
        break;
    }
    const distToPoints = pointIndices.map((point_index, i) => intersectPoint.distanceTo(pointPositions[i]));
    const distanceTotal = (0,ArrayUtils/* arraySum */.dD)([
      distToPoints[0] * distToPoints[1],
      distToPoints[0] * distToPoints[2],
      distToPoints[1] * distToPoints[2]
    ]);
    const weights = [
      distToPoints[1] * distToPoints[2] / distanceTotal,
      distToPoints[0] * distToPoints[2] / distanceTotal,
      distToPoints[0] * distToPoints[1] / distanceTotal
    ];
    let newAttribValue;
    switch (attribSize) {
      case 1:
        newAttribValue = (0,ArrayUtils/* arraySum */.dD)(
          pointIndices.map((point_indx, i) => weights[i] * attribValues[i])
        );
        break;
      default:
        var values = pointIndices.map(
          (point_index, i) => attribValues[i].multiplyScalar(weights[i])
        );
        newAttribValue = null;
        for (const value of values) {
          if (newAttribValue) {
            newAttribValue.add(value);
          } else {
            newAttribValue = value;
          }
        }
    }
    return newAttribValue;
  }
}

// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/core/geometry/modules/three/ThreejsPrimitiveTriangle.ts
var ThreejsPrimitiveTriangle = __webpack_require__(36083);
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/sop/Face.ts











const Face_dummyMesh = new three_module.Mesh();
var FaceAttribName = /* @__PURE__ */ ((FaceAttribName2) => {
  FaceAttribName2["CENTER"] = "faceCenter";
  FaceAttribName2["ID"] = "faceId";
  FaceAttribName2["POSITION"] = "position";
  return FaceAttribName2;
})(FaceAttribName || {});
const _faceCenter = new three_module.Vector3();
const Face_position = new three_module.Vector3();
const _newPosition = new three_module.Vector3();
class FaceSopParamsConfig extends params_ParamsConfig/* NodeParamsConfig */.yI {
  constructor() {
    super(...arguments);
    /** @param makes faces unique */
    this.makeFacesUnique = params_ParamsConfig/* ParamConfig.BOOLEAN */.XC.BOOLEAN(0);
    /** @param adds a vector3 attribute that represents the center of a face */
    this.addFaceCenterAttribute = params_ParamsConfig/* ParamConfig.BOOLEAN */.XC.BOOLEAN(0, {
      visibleIf: { makeFacesUnique: 1 }
    });
    /** @param add an id attribute for each face */
    this.addFaceId = params_ParamsConfig/* ParamConfig.BOOLEAN */.XC.BOOLEAN(0, {
      visibleIf: { makeFacesUnique: 1 }
    });
    /** @param allows to transform each face */
    this.transform = params_ParamsConfig/* ParamConfig.BOOLEAN */.XC.BOOLEAN(0, {
      visibleIf: { makeFacesUnique: 1 }
    });
    /** @param scales the faces indepedently */
    this.scale = params_ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(1, {
      visibleIf: { makeFacesUnique: 1, transform: 1 }
    });
  }
}
const Face_ParamsConfig = new FaceSopParamsConfig();
class FaceSopNode extends sop_Base/* TypedSopNode */.x {
  constructor() {
    super(...arguments);
    this.paramsConfig = Face_ParamsConfig;
    this._face = new CoreFace();
    this._points = [
      new ThreejsPoint/* ThreejsPoint */.B(Face_dummyMesh, 0),
      new ThreejsPoint/* ThreejsPoint */.B(Face_dummyMesh, 0),
      new ThreejsPoint/* ThreejsPoint */.B(Face_dummyMesh, 0)
    ];
  }
  static type() {
    return "face";
  }
  initializeNode() {
    this.io.inputs.setCount(1);
    this.io.inputs.initInputsClonedState(InputCloneMode/* InputCloneMode.FROM_NODE */.m.FROM_NODE);
  }
  cook(input_contents) {
    const core_group = input_contents[0];
    if ((0,Type/* isBooleanTrue */.bI)(this.pv.makeFacesUnique)) {
      this._makeFacesUnique(core_group);
      if ((0,Type/* isBooleanTrue */.bI)(this.pv.addFaceCenterAttribute)) {
        this._addFaceCenterAttribute(core_group);
      }
      if ((0,Type/* isBooleanTrue */.bI)(this.pv.addFaceId)) {
        this._addFaceId(core_group);
      }
      if ((0,Type/* isBooleanTrue */.bI)(this.pv.transform)) {
        this._transformFaces(core_group);
      }
    }
    this.setCoreGroup(core_group);
  }
  _makeFacesUnique(core_group) {
    var _a;
    const objects = core_group.threejsObjects();
    for (const object of objects) {
      if (object.isMesh) {
        const geometry = object.geometry;
        const index = (_a = geometry.index) == null ? void 0 : _a.array;
        if (index) {
          const faces = (0,ArrayUtils/* arrayChunk */.Zq)([...index], 3);
          const pointsCount = faces.length * 3;
          for (const attrib_name of Object.keys(geometry.attributes)) {
            const attrib = geometry.attributes[attrib_name];
            const attrib_size = attrib.itemSize;
            const new_values = new Float32Array(pointsCount * attrib_size);
            let new_value_index = 0;
            faces.forEach((face) => {
              face.forEach((index2) => {
                for (let i = 0; i < attrib_size; i++) {
                  const current_value = attrib.array[index2 * attrib_size + i];
                  new_values[new_value_index] = current_value;
                  new_value_index += 1;
                }
              });
            });
            geometry.setAttribute(attrib_name, new three_module.BufferAttribute(new_values, attrib_size));
          }
          const newIndices = (0,ArrayUtils/* rangeWithEnd */.Zi)(pointsCount);
          geometry.setIndex(newIndices);
        }
      }
    }
  }
  _addFaceCenterAttribute(coreGroup) {
    const coreObjects = coreGroup.threejsCoreObjects();
    for (const coreObject of coreObjects) {
      const object = coreObject.object();
      const corePointClass = (0,CoreObjectFactory/* corePointClassFactory */.E_)(object);
      if (object.isMesh) {
        if (!corePointClass.hasAttribute(object, "faceCenter" /* CENTER */)) {
          corePointClass.addNumericAttribute(object, "faceCenter" /* CENTER */, 3, -1);
        }
        const facesCount = ThreejsPrimitiveTriangle/* ThreejsPrimitiveTriangle.entitiesCount */.G.entitiesCount(object);
        this._face.setGeometry(object.geometry);
        for (let fi = 0; fi < facesCount; fi++) {
          this._face.setIndex(fi);
          this._face.center(_faceCenter);
          this._face.points(this._points);
          for (const point of this._points) {
            point.setAttribValue("faceCenter" /* CENTER */, _faceCenter);
          }
        }
      }
    }
  }
  _addFaceId(coreGroup) {
    const coreObjects = coreGroup.threejsCoreObjects();
    for (const coreObject of coreObjects) {
      const object = coreObject.object();
      const corePointClass = (0,CoreObjectFactory/* corePointClassFactory */.E_)(object);
      if (object.isMesh) {
        if (!corePointClass.hasAttribute(object, "faceId" /* ID */)) {
          corePointClass.addNumericAttribute(object, "faceId" /* ID */, 1, -1);
        }
        const facesCount = ThreejsPrimitiveTriangle/* ThreejsPrimitiveTriangle.entitiesCount */.G.entitiesCount(object);
        this._face.setGeometry(object.geometry);
        for (let i = 0; i < facesCount; i++) {
          this._face.setIndex(i);
          this._face.points(this._points);
          for (const point of this._points) {
            point.setAttribValue("faceId" /* ID */, i);
          }
        }
      }
    }
  }
  _transformFaces(coreGroup) {
    const scale = this.pv.scale;
    const coreObjects = coreGroup.threejsCoreObjects();
    for (const coreObject of coreObjects) {
      const object = coreObject.object();
      const corePointClass = (0,CoreObjectFactory/* corePointClassFactory */.E_)(object);
      if (object.isMesh) {
        if (!corePointClass.hasAttribute(object, "position" /* POSITION */)) {
          corePointClass.addNumericAttribute(object, "position" /* POSITION */, 3, -1);
        }
        const facesCount = ThreejsPrimitiveTriangle/* ThreejsPrimitiveTriangle.entitiesCount */.G.entitiesCount(object);
        this._face.setGeometry(object.geometry);
        for (let fi = 0; fi < facesCount; fi++) {
          this._face.setIndex(fi);
          this._face.center(_faceCenter);
          this._face.points(this._points);
          for (const point of this._points) {
            point.position(Face_position);
            _newPosition.x = Face_position.x * scale + _faceCenter.x * (1 - scale);
            _newPosition.y = Face_position.y * scale + _faceCenter.y * (1 - scale);
            _newPosition.z = Face_position.z * scale + _faceCenter.z * (1 - scale);
            point.setAttribValue("position" /* POSITION */, _newPosition);
          }
        }
      }
    }
  }
}

// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/nodes/sop/Facet.ts
var Facet = __webpack_require__(12071);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/core/loader/AssetsUtils.ts
var AssetsUtils = __webpack_require__(29248);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/node_modules/three/examples/jsm/loaders/TDSLoader.js
var TDSLoader = __webpack_require__(95094);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/core/loader/geometry/_BaseLoaderHandler.ts + 1 modules
var _BaseLoaderHandler = __webpack_require__(53976);
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/core/loader/geometry/TDS.ts

var TDS_async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};


class TDSLoaderHandler extends _BaseLoaderHandler/* BaseObject3DLoaderHandler */.Mr {
  _getLoader(options) {
    return TDS_async(this, null, function* () {
      this._loader = this._loader || new TDSLoader/* TDSLoader */.e(this.loadingManager);
      if (this._resourceUrl) {
        this._loader.setResourcePath(this._resourceUrl);
      }
      return this._loader;
    });
  }
  _onLoadSuccess(object) {
    return [object];
  }
  setResourceUrl(resourceUrl) {
    this._resourceUrl = resourceUrl;
    if (this._loader) {
      this._loader.setResourcePath(resourceUrl);
    }
  }
}

// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/core/UrlHelper.ts
var UrlHelper = __webpack_require__(51529);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/operations/sop/utils/File/_BaseFileOperation.ts
var _BaseFileOperation = __webpack_require__(22012);
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/operations/sop/File3DS.ts






class File3DSSopOperation extends _BaseFileOperation/* BaseFileSopOperation */.Z {
  static type() {
    return Sop/* SopTypeFile.FILE_3DS */.GF.FILE_3DS;
  }
  _createGeoLoaderHandler(params) {
    const loader = new TDSLoaderHandler(params.url, this._node);
    loader.setResourceUrl(params.resourceUrl);
    return loader;
  }
}
File3DSSopOperation.DEFAULT_PARAMS = {
  url: (0,UrlHelper/* sanitizeUrl */.N)(`${AssetsUtils/* ASSETS_ROOT */.V}/models/3ds/portalgun/portalgun.3ds`),
  resourceUrl: (0,UrlHelper/* sanitizeUrl */.N)(`${AssetsUtils/* ASSETS_ROOT */.V}/models/3ds/portalgun/textures/`),
  matrixAutoUpdate: false
};

// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/core/loader/FileExtensionRegister.ts
var FileExtensionRegister = __webpack_require__(15060);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/poly/ParamEvent.ts
var ParamEvent = __webpack_require__(98267);
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/sop/File3DS.ts

var File3DS_async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};








const File3DS_DEFAULT = File3DSSopOperation.DEFAULT_PARAMS;
class File3DSParamsConfig extends params_ParamsConfig/* NodeParamsConfig */.yI {
  constructor() {
    super(...arguments);
    /** @param url to load the geometry from */
    this.url = params_ParamsConfig/* ParamConfig.STRING */.XC.STRING(File3DS_DEFAULT.url, {
      fileBrowse: { extensions: FileExtensionRegister/* EXTENSIONS_BY_NODE_TYPE_BY_CONTEXT */.P[poly_NodeContext/* NodeContext.SOP */.sy.SOP][Sop/* SopTypeFile.FILE_3DS */.GF.FILE_3DS] }
    });
    /** @param texture folder url */
    this.resourceUrl = params_ParamsConfig/* ParamConfig.STRING */.XC.STRING(File3DS_DEFAULT.resourceUrl);
    /** @param sets the matrixAutoUpdate attribute for the objects loaded */
    this.matrixAutoUpdate = params_ParamsConfig/* ParamConfig.BOOLEAN */.XC.BOOLEAN(File3DS_DEFAULT.matrixAutoUpdate);
    /** @param reload the geometry */
    this.reload = params_ParamsConfig/* ParamConfig.BUTTON */.XC.BUTTON(null, {
      callback: (node) => {
        File3DSSopNode.PARAM_CALLBACK_reload(node);
      }
    });
  }
}
const File3DS_ParamsConfig = new File3DSParamsConfig();
class File3DSSopNode extends sop_Base/* TypedSopNode */.x {
  constructor() {
    super(...arguments);
    this.paramsConfig = File3DS_ParamsConfig;
  }
  static type() {
    return Sop/* SopTypeFile.FILE_3DS */.GF.FILE_3DS;
  }
  dispose() {
    super.dispose();
    Poly/* Poly.blobs.clearBlobsForNode */.L.blobs.clearBlobsForNode(this);
  }
  cook(inputCoreGroups) {
    return File3DS_async(this, null, function* () {
      this._operation = this._operation || new File3DSSopOperation(this.scene(), this.states, this);
      const coreGroup = yield this._operation.cook(inputCoreGroups, this.pv);
      this.setCoreGroup(coreGroup);
    });
  }
  static PARAM_CALLBACK_reload(node) {
    node._paramCallbackReload();
  }
  _paramCallbackReload() {
    this.p.url.setDirty();
    this.p.url.emit(ParamEvent/* ParamEvent.ASSET_RELOAD_REQUEST */.X.ASSET_RELOAD_REQUEST);
  }
}

// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/nodes/sop/FileDRC.ts
var FileDRC = __webpack_require__(26745);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/nodes/sop/FileFBX.ts
var FileFBX = __webpack_require__(8315);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/nodes/sop/FileGEOJSON.ts
var FileGEOJSON = __webpack_require__(9320);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/nodes/sop/FileGLTF.ts
var FileGLTF = __webpack_require__(27952);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/nodes/sop/FileJSON.ts
var FileJSON = __webpack_require__(82741);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/nodes/sop/FileMPD.ts
var FileMPD = __webpack_require__(63063);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/nodes/sop/utils/file/_BaseSopFileMulti.ts
var _BaseSopFileMulti = __webpack_require__(51992);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/core/loader/geometry/GLTF.ts + 1 modules
var GLTF = __webpack_require__(78491);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/operations/sop/FileGLTF.ts
var sop_FileGLTF = __webpack_require__(92414);
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/sop/FileMultiGLTF.ts









const FileMultiGLTF_DEFAULT = sop_FileGLTF/* FileGLTFSopOperation.DEFAULT_PARAMS */.j.DEFAULT_PARAMS;
class FileMultiGLTFParamsConfig extends params_ParamsConfig/* NodeParamsConfig */.yI {
  constructor() {
    super(...arguments);
    /** @param url to load the geometry from */
    this.url = params_ParamsConfig/* ParamConfig.STRING */.XC.STRING(`${AssetsUtils/* ASSETS_ROOT */.V}/models/\`@name\`.glb`, {
      fileBrowse: { extensions: FileExtensionRegister/* EXTENSIONS_BY_NODE_TYPE_BY_CONTEXT */.P[poly_NodeContext/* NodeContext.SOP */.sy.SOP][Sop/* SopTypeFileMulti.FILE_GLTF */.dk.FILE_GLTF] },
      expression: { forEntities: true }
    });
    /** @param uses draco compression */
    this.draco = params_ParamsConfig/* ParamConfig.BOOLEAN */.XC.BOOLEAN(FileMultiGLTF_DEFAULT.draco);
    /** @param uses ktx2 compression */
    this.ktx2 = params_ParamsConfig/* ParamConfig.BOOLEAN */.XC.BOOLEAN(FileMultiGLTF_DEFAULT.ktx2);
    /** @param sets the matrixAutoUpdate attribute for the objects loaded */
    this.matrixAutoUpdate = params_ParamsConfig/* ParamConfig.BOOLEAN */.XC.BOOLEAN(false);
    /** @param reload the geometry */
    this.reload = params_ParamsConfig/* ParamConfig.BUTTON */.XC.BUTTON(null, {
      callback: (node) => {
        _BaseSopFileMulti/* BaseFileMultiSopNode.PARAM_CALLBACK_reload */.AE.PARAM_CALLBACK_reload(node);
      }
    });
  }
}
const FileMultiGLTF_ParamsConfig = new FileMultiGLTFParamsConfig();
class FileMultiGLTFSopNode extends _BaseSopFileMulti/* BaseFileMultiSopNode */.AE {
  constructor() {
    super(...arguments);
    this.paramsConfig = FileMultiGLTF_ParamsConfig;
  }
  static type() {
    return Sop/* SopTypeFileMulti.FILE_GLTF */.dk.FILE_GLTF;
  }
  _createLoader(url) {
    return new GLTF/* GLTFLoaderHandler */.B(url, this);
  }
  _loadWithLoader(loader) {
    return loader.load({
      draco: this.pv.draco,
      ktx2: this.pv.ktx2,
      node: this
    });
  }
}

// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/nodes/sop/FileMultiOBJ.ts
var FileMultiOBJ = __webpack_require__(61999);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/nodes/sop/FileOBJ.ts
var FileOBJ = __webpack_require__(48112);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/nodes/sop/FilePDB.ts
var FilePDB = __webpack_require__(86084);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/nodes/sop/FilePLY.ts
var FilePLY = __webpack_require__(26633);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/nodes/sop/FileSTL.ts
var FileSTL = __webpack_require__(10079);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/nodes/sop/FileSVG.ts
var FileSVG = __webpack_require__(87588);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/node_modules/three/examples/jsm/loaders/USDZLoader.js
var USDZLoader = __webpack_require__(87738);
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/core/loader/geometry/USDZ.ts

var USDZ_async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};


class USDZLoaderHandler extends _BaseLoaderHandler/* BaseObject3DLoaderHandler */.Mr {
  _getLoader() {
    return USDZ_async(this, null, function* () {
      return this._loader = this._loader || (yield new USDZLoader/* USDZLoader */.n(this.loadingManager));
    });
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/operations/sop/FileUSDZ.ts






class FileUSDZSopOperation extends _BaseFileOperation/* BaseFileSopOperation */.Z {
  static type() {
    return Sop/* SopTypeFile.FILE_USDZ */.GF.FILE_USDZ;
  }
  _createGeoLoaderHandler(params) {
    return new USDZLoaderHandler(params.url, this._node);
  }
}
FileUSDZSopOperation.DEFAULT_PARAMS = {
  url: (0,UrlHelper/* sanitizeUrl */.N)(`${AssetsUtils/* ASSETS_ROOT */.V}/models/saeukkang.usdz`),
  matrixAutoUpdate: false
};

// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/nodes/sop/utils/file/_BaseSopFile.ts
var _BaseSopFile = __webpack_require__(84179);
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/sop/FileUSDZ.ts






class FileUSDZSopNode extends (0,_BaseSopFile/* fileSopNodeFactory */.pd)({
  type: Sop/* SopTypeFile.FILE_USDZ */.GF.FILE_USDZ,
  operation: FileUSDZSopOperation,
  extensions: FileExtensionRegister/* EXTENSIONS_BY_NODE_TYPE_BY_CONTEXT */.P[poly_NodeContext/* NodeContext.SOP */.sy.SOP][Sop/* SopTypeFile.FILE_USDZ */.GF.FILE_USDZ]
}) {
}

// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/nodes/sop/FileVOX.ts
var FileVOX = __webpack_require__(47617);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/nodes/sop/Fuse.ts
var sop_Fuse = __webpack_require__(19210);
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/core/geometry/builders/groundProjectedSkybox/GroundProjectedSkybox.vert.glsl
/* harmony default export */ var GroundProjectedSkybox_vert = ("varying vec3 vWorldPosition;\n\nvoid main() {\n\n\tvec4 worldPosition = ( modelMatrix * vec4( position, 1.0 ) );\n\tvWorldPosition = worldPosition.xyz;\n\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n}");
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/core/geometry/builders/groundProjectedSkybox/GroundProjectedSkybox.frag.glsl
/* harmony default export */ var GroundProjectedSkybox_frag = ("varying vec3 vWorldPosition;\n\nuniform float radius;\nuniform float height;\nuniform float angle;\n\n#ifdef ENVMAP_TYPE_CUBE\n\n\tuniform samplerCube map;\n\n#else\n\n\tuniform sampler2D map;\n\n#endif\n\n// From: https://www.shadertoy.com/view/4tsBD7\nfloat diskIntersectWithBackFaceCulling( vec3 ro, vec3 rd, vec3 c, vec3 n, float r ) {\n\n\tfloat d = dot ( rd, n );\n\n\tif( d > 0.0 ) { return 1e6; }\n\n\tvec3  o = ro - c;\n\tfloat t = - dot( n, o ) / d;\n\tvec3  q = o + rd * t;\n\n\treturn ( dot( q, q ) < r * r ) ? t : 1e6;\n\n}\n\n// From: https://www.iquilezles.org/www/articles/intersectors/intersectors.htm\nfloat sphereIntersect( vec3 ro, vec3 rd, vec3 ce, float ra ) {\n\n\tvec3 oc = ro - ce;\n\tfloat b = dot( oc, rd );\n\tfloat c = dot( oc, oc ) - ra * ra;\n\tfloat h = b * b - c;\n\n\tif( h < 0.0 ) { return -1.0; }\n\n\th = sqrt( h );\n\n\treturn - b + h;\n\n}\n\nvec3 project() {\n\n\tvec3 p = normalize( vWorldPosition );\n\tvec3 camPos = cameraPosition;\n\tcamPos.y -= height;\n\n\tfloat intersection = sphereIntersect( camPos, p, vec3( 0.0 ), radius );\n\tif( intersection > 0.0 ) {\n\n\t\tvec3 h = vec3( 0.0, - height, 0.0 );\n\t\tfloat intersection2 = diskIntersectWithBackFaceCulling( camPos, p, h, vec3( 0.0, 1.0, 0.0 ), radius );\n\t\tp = ( camPos + min( intersection, intersection2 ) * p ) / radius;\n\n\t} else {\n\n\t\tp = vec3( 0.0, 1.0, 0.0 );\n\n\t}\n\n\treturn p;\n\n}\n\n#include <common>\n\nvoid main() {\n\n\tvec3 projectedWorldPosition = project();\n\n\t#ifdef ENVMAP_TYPE_CUBE\n\n\t\tvec3 outcolor = textureCube( map, projectedWorldPosition ).rgb;\n\n\t#else\n\n\t\tvec3 direction = normalize( projectedWorldPosition );\n\t\tvec2 uv = equirectUv( direction );\n\t\tvec3 outcolor = texture2D( map, uv ).rgb;\n\n\t#endif\n\n\tgl_FragColor = vec4( outcolor, 1.0 );\n\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\n}");
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/core/geometry/builders/groundProjectedSkybox/GroundProjectedSkybox.ts




function _geometry() {
  return new three_module.IcosahedronGeometry(1, 16);
}
function _material() {
  const uniforms = {
    map: { value: null },
    height: { value: 15 },
    radius: { value: 100 }
  };
  const material = new three_module.ShaderMaterial({
    uniforms,
    fragmentShader: "",
    vertexShader: GroundProjectedSkybox_vert,
    side: three_module.DoubleSide
  });
  return material;
}
class GroundProjectedSkybox extends three_module.Mesh {
  constructor(geometry, material) {
    super(_geometry(), _material());
    this.geometry = new three_module.IcosahedronGeometry(1, 16);
  }
  setTexture(texture) {
    const isCubeMap = texture.isCubeTexture;
    const defines = [isCubeMap ? "#define ENVMAP_TYPE_CUBE" : ""];
    const fragmentShader = defines.join("\n") + GroundProjectedSkybox_frag;
    this.material.fragmentShader = fragmentShader;
    this.material.needsUpdate = true;
    this.material.uniforms.map.value = texture;
  }
  set radius(radius) {
    this.material.uniforms.radius.value = radius;
  }
  get radius() {
    return this.material.uniforms.radius.value;
  }
  set height(height) {
    this.material.uniforms.height.value = height;
  }
  get height() {
    return this.material.uniforms.height.value;
  }
  copy(source, recursive) {
    super.copy(source, recursive);
    this.radius = source.radius;
    this.height = source.height;
    return this;
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/sop/GroundProjectedSkybox.ts

var GroundProjectedSkybox_async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};





class GroundProjectedSkyboxSopParamsConfig extends params_ParamsConfig/* NodeParamsConfig */.yI {
  constructor() {
    super(...arguments);
    /** @param envMap */
    this.envMap = params_ParamsConfig/* ParamConfig.NODE_PATH */.XC.NODE_PATH("", {
      nodeSelection: {
        context: poly_NodeContext/* NodeContext.COP */.sy.COP
      },
      dependentOnFoundNode: false
    });
    /** @param scale */
    this.scale = params_ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(50, {
      range: [0, 100],
      rangeLocked: [true, false]
    });
    /** @param radius */
    this.radius = params_ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(200, {
      range: [0, 1e3],
      rangeLocked: [true, false]
    });
    /** @param height */
    this.height = params_ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(20, {
      range: [0, 100],
      rangeLocked: [true, false]
    });
  }
}
const GroundProjectedSkybox_ParamsConfig = new GroundProjectedSkyboxSopParamsConfig();
class GroundProjectedSkyboxSopNode extends sop_Base/* TypedSopNode */.x {
  constructor() {
    super(...arguments);
    this.paramsConfig = GroundProjectedSkybox_ParamsConfig;
  }
  static type() {
    return Sop/* SopType.GROUND_PROJECTED_SKYBOX */.aB.GROUND_PROJECTED_SKYBOX;
  }
  initializeNode() {
    this.io.inputs.setCount(0);
  }
  cook(inputCoreGroups) {
    return GroundProjectedSkybox_async(this, null, function* () {
      var _a, _b;
      const textureNode = this.pv.envMap.nodeWithContext(poly_NodeContext/* NodeContext.COP */.sy.COP, (_a = this.states) == null ? void 0 : _a.error);
      if (!textureNode) {
        (_b = this.states) == null ? void 0 : _b.error.set(`no texture node found`);
        return;
      }
      const container = yield textureNode.compute();
      const texture = container.texture();
      const skybox = new GroundProjectedSkybox();
      const scale = this.pv.scale;
      skybox.scale.set(scale, scale, scale);
      skybox.updateMatrix();
      skybox.matrixAutoUpdate = false;
      skybox.setTexture(texture);
      skybox.radius = this.pv.radius;
      skybox.height = this.pv.height;
      this.setObject(skybox);
    });
  }
}

// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/nodes/sop/Hexagons.ts
var Hexagons = __webpack_require__(10288);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/nodes/sop/Hierarchy.ts
var Hierarchy = __webpack_require__(79463);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/core/Image.ts
var core_Image = __webpack_require__(33450);
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/sop/HeightMap.ts

var HeightMap_async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};







class HeightMapSopParamsConfig extends params_ParamsConfig/* NodeParamsConfig */.yI {
  constructor() {
    super(...arguments);
    /** @param texture node to load the heightmap from */
    this.texture = params_ParamsConfig/* ParamConfig.NODE_PATH */.XC.NODE_PATH("", {
      nodeSelection: { context: poly_NodeContext/* NodeContext.COP */.sy.COP }
    });
    /** @param values multiplier */
    this.mult = params_ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(1);
  }
}
const HeightMap_ParamsConfig = new HeightMapSopParamsConfig();
class HeightMapSopNode extends sop_Base/* TypedSopNode */.x {
  constructor() {
    super(...arguments);
    this.paramsConfig = HeightMap_ParamsConfig;
  }
  static type() {
    return "heightMap";
  }
  initializeNode() {
    this.io.inputs.setCount(1);
    this.io.inputs.initInputsClonedState(InputCloneMode/* InputCloneMode.FROM_NODE */.m.FROM_NODE);
  }
  cook(inputCoreGroups) {
    return HeightMap_async(this, null, function* () {
      const coreGroup = inputCoreGroups[0];
      const node = this.pv.texture.nodeWithContext(poly_NodeContext/* NodeContext.COP */.sy.COP, this.states.error);
      if (node) {
        const node_context = node.context();
        if (node_context == poly_NodeContext/* NodeContext.COP */.sy.COP) {
          const texture_node = node;
          const container = yield texture_node.compute();
          const texture = container.texture();
          const objects2 = coreGroup.allObjects();
          for (const object of objects2) {
            this._setPositionFromDataTexture(object, texture);
          }
        } else {
          this.states.error.set("found node is not a texture");
        }
      }
      const objects = coreGroup.threejsObjectsWithGeo();
      for (const object of objects) {
        object.geometry.computeVertexNormals();
      }
      this.setCoreGroup(coreGroup);
    });
  }
  _setPositionFromDataTexture(object, texture) {
    const textureData = this._dataFromTexture(texture);
    if (!textureData) {
      return;
    }
    const { data, resx, resy } = textureData;
    const texture_component_size = data.length / (resx * resy);
    const corePointClass = (0,CoreObjectFactory/* corePointClassFactory */.E_)(object);
    const positions = corePointClass.attribute(object, geometry_Attribute/* Attribute.POSITION */.ah.POSITION).array;
    const uvAttrib = corePointClass.attribute(object, geometry_Attribute/* Attribute.UV */.ah.UV);
    const normalAttrib = corePointClass.attribute(object, geometry_Attribute/* Attribute.NORMAL */.ah.NORMAL);
    if (uvAttrib == null) {
      this.states.error.set("uvs are required");
      return;
    }
    if (normalAttrib == null) {
      this.states.error.set("normals are required");
      return;
    }
    const uvs = uvAttrib.array;
    const normals = normalAttrib.array;
    const points_count = positions.length / 3;
    let uv_stride, uvx, uvy, x, y, j, val;
    let index = 0;
    for (let i = 0; i < points_count; i++) {
      uv_stride = i * 2;
      uvx = uvs[uv_stride];
      uvy = uvs[uv_stride + 1];
      x = Math.floor((resx - 1) * uvx);
      y = Math.floor((resy - 1) * (1 - uvy));
      j = y * resx + x;
      val = data[texture_component_size * j];
      index = i * 3;
      positions[index + 0] += normals[index + 0] * val * this.pv.mult;
      positions[index + 1] += normals[index + 1] * val * this.pv.mult;
      positions[index + 2] += normals[index + 2] * val * this.pv.mult;
    }
  }
  _dataFromTexture(texture) {
    if (texture.image) {
      if (texture.image.data) {
        return this._dataFromDataTexture(texture);
      }
      return this._dataFromDefaultTexture(texture);
    }
  }
  _dataFromDefaultTexture(texture) {
    const resx = texture.image.width;
    const resy = texture.image.height;
    const image_data = core_Image/* CoreImage.data_from_image */.p.data_from_image(texture.image);
    const data = image_data.data;
    return {
      data,
      resx,
      resy
    };
  }
  _dataFromDataTexture(texture) {
    const data = texture.image.data;
    const resx = texture.image.width;
    const resy = texture.image.height;
    return {
      data,
      resx,
      resy
    };
  }
}

// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/nodes/sop/HemisphereLight.ts
var sop_HemisphereLight = __webpack_require__(83545);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/nodes/sop/Icosahedron.ts
var Icosahedron = __webpack_require__(82263);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/nodes/sop/Instance.ts
var Instance = __webpack_require__(15432);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/nodes/js/code/utils/JsParamConfig.ts
var JsParamConfig = __webpack_require__(35833);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/nodes/js/code/assemblers/_BaseJsPersistedConfig.ts
var _BaseJsPersistedConfig = __webpack_require__(35446);
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/js/code/assemblers/pointBuilder/_BasePointBuilderPersistedConfig.ts

var _BasePointBuilderPersistedConfig_async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};



class BasePointBuilderPersistedConfig extends BasePersistedConfig/* BasePersistedConfig */.p {
  constructor(node) {
    super(node);
    this.node = node;
  }
  toData() {
    return _BasePointBuilderPersistedConfig_async(this, null, function* () {
      yield this.node.compile();
      const assemblerController = this.node.assemblerController();
      if (!assemblerController) {
        return;
      }
      const functionData = this.node.functionData();
      if (!functionData) {
        return;
      }
      const { functionBody, variableNames, functionNames, paramConfigs, attributesData } = functionData;
      const data = {
        functionBody,
        variableNames,
        variables: (0,_BaseJsPersistedConfig/* serializedVariablesFromFunctionData */.ve)(functionData),
        functionNames,
        serializedParamConfigs: paramConfigs.map((p) => p.toJSON()),
        attributesData
      };
      return data;
    });
  }
  load(data) {
    const assemblerController = this.node.assemblerController();
    if (assemblerController) {
      return;
    }
    const { functionBody, variableNames, functionNames, serializedParamConfigs, attributesData } = data;
    const functionData = {
      functionBody,
      variableNames,
      variablesByName: (0,_BaseJsPersistedConfig/* variablesByNameFromPersistedConfigData */.pw)(data),
      functionNames,
      functionsByName: (0,_BaseJsPersistedConfig/* functionsByNameFromPersistedConfigData */.Kg)(data, this.node),
      paramConfigs: serializedParamConfigs.map((json) => JsParamConfig/* JsParamConfig.fromJSON */.M.fromJSON(json)),
      attributesData
    };
    this.node.updateFromFunctionData(functionData);
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/js/code/assemblers/instanceBuilder/InstanceBuilderPersistedConfig.ts


class InstanceBuilderPersistedConfig extends BasePointBuilderPersistedConfig {
  constructor(node) {
    super(node);
    this.node = node;
  }
}

// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/nodes/js/code/assemblers/pointBuilder/PointBuilderAssemblerCommon.ts
var PointBuilderAssemblerCommon = __webpack_require__(38934);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/nodes/js/code/utils/NodeFinder.ts
var utils_NodeFinder = __webpack_require__(72648);
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/sop/_BasePointBuilder.ts

var _BasePointBuilder_async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};















class BasePointBuilderSopParamsConfig extends params_ParamsConfig/* NodeParamsConfig */.yI {
  constructor() {
    super(...arguments);
    /** @param group to assign the material to */
    this.group = params_ParamsConfig/* ParamConfig.STRING */.XC.STRING("", {
      objectMask: true
    });
  }
}
class BasePointBuilderSopNode extends sop_Base/* TypedSopNode */.x {
  constructor() {
    super(...arguments);
    this._assemblerController = this._createAssemblerController();
    this._childrenControllerContext = poly_NodeContext/* NodeContext.JS */.sy.JS;
    this._paramConfigs = [];
    this._functionCreationArgs = [];
    this._functionEvalArgs = [];
    this._attributesDict = /* @__PURE__ */ new Map();
  }
  assemblerController() {
    return this._assemblerController;
  }
  usedAssembler() {
    return _BaseRegister/* AssemblerName.JS_POINT_BUILDER */.Q.JS_POINT_BUILDER;
  }
  _createAssemblerController() {
    return Poly/* Poly.assemblersRegister.assembler */.L.assemblersRegister.assembler(this, this.usedAssembler());
  }
  createNode(node_class, options) {
    return super.createNode(node_class, options);
  }
  children() {
    return super.children();
  }
  nodesByType(type) {
    return super.nodesByType(type);
  }
  childrenAllowed() {
    if (this.assemblerController()) {
      return super.childrenAllowed();
    }
    return false;
  }
  sceneReadonly() {
    return this.assemblerController() == null;
  }
  initializeNode() {
    this.io.inputs.setCount(1);
    this.io.inputs.initInputsClonedState(InputCloneMode/* InputCloneMode.FROM_NODE */.m.FROM_NODE);
  }
  cook(inputCoreGroups) {
    return _BasePointBuilder_async(this, null, function* () {
      const coreGroup = inputCoreGroups[0];
      this.compileIfRequired();
      const _func = this._function;
      if (_func) {
        const args = this.functionEvalArgsWithParamConfigs();
        const evaluator = _func(...args);
        const objects = (0,Mask/* filterObjectsFromCoreGroup */.sH)(coreGroup, this.pv);
        let objnum = 0;
        for (const object of objects) {
          this._processObject(object, objnum, evaluator);
          objnum++;
        }
        this.setObjects(objects);
      } else {
        this.setObjects([]);
      }
    });
  }
  _resetRequiredAttributes() {
    this._attributesDict.clear();
  }
  _checkRequiredReadAttributes(object) {
    var _a;
    const pointsCount = (0,CorePointUtils/* pointsCountFromObject */.En)(object);
    if (pointsCount == 0) {
      return;
    }
    const corePointClass = (0,CoreObjectFactory/* corePointClassFactory */.E_)(object);
    const readAttributesData = (_a = this._functionData) == null ? void 0 : _a.attributesData.read;
    if (!readAttributesData) {
      return;
    }
    for (const attribData of readAttributesData) {
      const attribute = corePointClass.attribute(object, attribData.attribName);
      if (!attribute) {
        const message = `attribute ${attribData.attribName} is missing`;
        this.states.error.set(message);
        throw message;
        return;
      } else {
        const expectedAttribSize = connections_Js/* JsConnectionPointComponentsCountMap */.N5[attribData.attribType];
        if (attribute.itemSize != expectedAttribSize) {
          this.states.error.set("attribute size mismatch");
        }
      }
    }
    const attribNames = [];
    const attributeByName = /* @__PURE__ */ new Map();
    const attribTypeByName = /* @__PURE__ */ new Map();
    for (const attribData of readAttributesData) {
      const attribName = attribData.attribName;
      const attribute = corePointClass.attribute(object, attribName);
      if (attribute) {
        attribNames.push(attribName);
        attributeByName.set(attribName, attribute);
        attribTypeByName.set(attribName, attribData.attribType);
      }
    }
    return { attribNames, attributeByName, attribTypeByName };
  }
  _checkRequiredWriteAttributes(object) {
    var _a;
    const writeAttributesData = (_a = this._functionData) == null ? void 0 : _a.attributesData.write;
    if (!writeAttributesData) {
      return;
    }
    const corePointClass = (0,CoreObjectFactory/* corePointClassFactory */.E_)(object);
    for (const attribData of writeAttributesData) {
      let attribute = corePointClass.attribute(object, attribData.attribName);
      const expectedAttribSize = connections_Js/* JsConnectionPointComponentsCountMap */.N5[attribData.attribType];
      if (!attribute) {
        const pointsCount = corePointClass.entitiesCount(object);
        const newArray = new Array(pointsCount * expectedAttribSize).fill(0);
        attribute = new three_module.BufferAttribute(new Float32Array(newArray), expectedAttribSize);
        corePointClass.addAttribute(object, attribData.attribName, attribute);
      }
      if (attribute.itemSize != expectedAttribSize) {
        this.states.error.set("attribute size mismatch");
      }
    }
    const attribNames = [];
    const attributeByName = /* @__PURE__ */ new Map();
    const attribTypeByName = /* @__PURE__ */ new Map();
    for (const attribData of writeAttributesData) {
      const attribName = attribData.attribName;
      const attribute = corePointClass.attribute(object, attribName);
      if (attribute) {
        attribNames.push(attribName);
        attributeByName.set(attribName, attribute);
        attribTypeByName.set(attribName, attribData.attribType);
      }
    }
    return { attribNames, attributeByName, attribTypeByName };
  }
  _readRequiredAttributes(ptnum, attribNames, attributeByName, attribTypeByName) {
    for (const attribName of attribNames) {
      const attribute = attributeByName.get(attribName);
      const attribType = attribTypeByName.get(attribName);
      const variable = (0,_BaseJsPersistedConfigUtils/* createVariable */.Os)(attribType);
      if (!variable) {
        const attribValue = attribute.array[ptnum * attribute.itemSize];
        this._attributesDict.set(attribName, attribValue);
      } else if ((0,Type/* isVector */.NR)(variable) || (0,Type/* isColor */.D5)(variable)) {
        variable.fromBufferAttribute(attribute, ptnum);
        this._attributesDict.set(attribName, variable);
      }
    }
  }
  _writeRequiredAttributes(ptnum, attribNames, attributeByName) {
    for (const attribName of attribNames) {
      const attribute = attributeByName.get(attribName);
      const variable = this._attributesDict.get(attribName);
      if ((0,Type/* isVector */.NR)(variable) || (0,Type/* isColor */.D5)(variable)) {
        variable.toArray(attribute.array, ptnum * attribute.itemSize);
      } else {
        if ((0,Type/* isNumber */.hj)(variable)) {
          attribute.array[ptnum] = variable;
        }
      }
    }
  }
  compileIfRequired() {
    var _a;
    if ((_a = this.assemblerController()) == null ? void 0 : _a.compileRequired()) {
      this.compile();
    }
  }
  functionData() {
    return this._functionData;
  }
  compile() {
    const assemblerController = this.assemblerController();
    if (!assemblerController) {
      return;
    }
    const outputNodes = utils_NodeFinder/* JsNodeFinder.findOutputNodes */.K.findOutputNodes(this);
    if (outputNodes.length == 0) {
      this.states.error.set("one output node is required");
      return;
    }
    if (outputNodes.length > 1) {
      this.states.error.set("only one output node allowed");
      return;
    }
    const outputNode = outputNodes[0];
    if (outputNode) {
      const paramNodes = utils_NodeFinder/* JsNodeFinder.findParamGeneratingNodes */.K.findParamGeneratingNodes(this);
      const attributeExportNodes = utils_NodeFinder/* JsNodeFinder.findAttributeExportNodes */.K.findAttributeExportNodes(this);
      const rootNodes = outputNodes.concat(paramNodes).concat(attributeExportNodes);
      assemblerController.assembler.set_root_nodes(rootNodes);
      assemblerController.assembler.updateFunction();
      const functionData = assemblerController.assembler.functionData();
      if (!functionData) {
        this.states.error.set("failed to compile ");
        return;
      }
      this.updateFromFunctionData(functionData);
    }
    assemblerController.post_compile();
  }
  updateFromFunctionData(functionData) {
    this._functionData = functionData;
    const { functionBody, variableNames, variablesByName, functionNames, functionsByName, paramConfigs } = this._functionData;
    const wrappedBody = `
		try {
			${functionBody}
		} catch(e) {
			_setErrorFromError(e)
			return 0;
		}`;
    const _setErrorFromError = (e) => {
      this.states.error.set(e.message);
    };
    const variables = [];
    const functions = [];
    for (const variableName of variableNames) {
      const variable = variablesByName[variableName];
      variables.push(variable);
    }
    for (const functionName of functionNames) {
      const _func = functionsByName[functionName];
      functions.push(_func);
    }
    this._paramConfigs = [...paramConfigs];
    const paramConfigNames = paramConfigs.map((pc) => pc.uniformName());
    paramConfigs.forEach((p) => p.applyToNode(this));
    this._functionCreationArgs = [
      PointBuilderAssemblerCommon/* PointBuilderAssemblerConstant.POINT_CONTAINER */.X.POINT_CONTAINER,
      "_setErrorFromError",
      ...variableNames,
      ...functionNames,
      PointBuilderAssemblerCommon/* PointBuilderAssemblerConstant.ATTRIBUTES_DICT */.X.ATTRIBUTES_DICT,
      ...paramConfigNames,
      wrappedBody
    ];
    this._functionEvalArgs = [
      this._pointContainer,
      _setErrorFromError,
      ...variables,
      ...functions,
      this._attributesDict
      // paramConfigs are added dynamically during cook
    ];
    try {
      this._function = new Function(...this._functionCreationArgs);
    } catch (e) {
      console.warn(e);
      this.states.error.set("failed to compile");
    }
  }
  functionEvalArgsWithParamConfigs() {
    const list = [...this._functionEvalArgs];
    for (const paramConfig of this._paramConfigs) {
      const paramName = paramConfig.name();
      const spareParam = this.params.get(paramName);
      if (spareParam && spareParam.value != null) {
        if (Type/* CoreType.isBoolean */.MR.isBoolean(spareParam.value) || Type/* CoreType.isNumberValid */.MR.isNumberValid(spareParam.value) || Type/* CoreType.isColor */.MR.isColor(spareParam.value) || Type/* CoreType.isVector */.MR.isVector(spareParam.value)) {
          list.push(spareParam.value);
        } else {
          console.warn(`spareParam not found but type not yet copied to function args:'${paramName}'`);
        }
      } else {
        console.warn(`spareParam not found:'${paramName}'`);
      }
    }
    return list;
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/sop/InstanceBuilder.ts









const InstanceBuilder_ParamsConfig = new BasePointBuilderSopParamsConfig();
class InstanceBuilderSopNode extends BasePointBuilderSopNode {
  constructor() {
    super(...arguments);
    this.paramsConfig = InstanceBuilder_ParamsConfig;
    this.persisted_config = new InstanceBuilderPersistedConfig(this);
    this._pointContainer = {
      instancePosition: new three_module.Vector3(),
      instanceQuaternion: new three_module.Quaternion(),
      instanceScale: new three_module.Vector3(),
      ptnum: -1,
      objnum: -1
    };
  }
  static type() {
    return Sop/* SopType.INSTANCE_BUILDER */.aB.INSTANCE_BUILDER;
  }
  usedAssembler() {
    return _BaseRegister/* AssemblerName.JS_INSTANCE_BUILDER */.Q.JS_INSTANCE_BUILDER;
  }
  _processObject(object, objnum, evaluator) {
    this._pointContainer.objnum = objnum;
    const readAttributeOptions = this._checkRequiredReadAttributes(object);
    const writeAttributeOptions = this._checkRequiredWriteAttributes(object);
    const readAttribNames = readAttributeOptions ? readAttributeOptions.attribNames : [];
    const readAttributeByName = readAttributeOptions ? readAttributeOptions.attributeByName : /* @__PURE__ */ new Map();
    const attribTypeByName = readAttributeOptions ? readAttributeOptions.attribTypeByName : /* @__PURE__ */ new Map();
    const writeAttribNames = writeAttributeOptions ? writeAttributeOptions.attribNames : [];
    const writeAttributeByName = writeAttributeOptions ? writeAttributeOptions.attributeByName : /* @__PURE__ */ new Map();
    this._resetRequiredAttributes();
    const pointsCount = (0,CorePointUtils/* pointsCountFromObject */.En)(object);
    const corePointClass = (0,CoreObjectFactory/* corePointClassFactory */.E_)(object);
    const positionAttrib = corePointClass.attribute(object, Instancer/* InstanceAttrib.POSITION */.R.POSITION);
    const quaternionAttrib = corePointClass.attribute(object, Instancer/* InstanceAttrib.QUATERNION */.R.QUATERNION);
    const scaleAttrib = corePointClass.attribute(object, Instancer/* InstanceAttrib.SCALE */.R.SCALE);
    const hasPosition = positionAttrib != null;
    const hasQuaternion = quaternionAttrib != null;
    const hasScale = scaleAttrib != null;
    if (!hasPosition) {
      this._pointContainer.instancePosition.set(0, 0, 0);
    }
    if (!hasQuaternion) {
      this._pointContainer.instanceQuaternion.identity();
    }
    if (!hasScale) {
      this._pointContainer.instanceScale.set(1, 1, 1);
    }
    for (let ptnum = 0; ptnum < pointsCount; ptnum++) {
      this._pointContainer.ptnum = ptnum;
      if (hasPosition) {
        this._pointContainer.instancePosition.fromBufferAttribute(positionAttrib, ptnum);
      }
      if (hasQuaternion) {
        this._pointContainer.instanceQuaternion.fromBufferAttribute(quaternionAttrib, ptnum);
      }
      if (hasScale) {
        this._pointContainer.instanceScale.fromBufferAttribute(scaleAttrib, ptnum);
      }
      this._readRequiredAttributes(ptnum, readAttribNames, readAttributeByName, attribTypeByName);
      evaluator();
      if (hasPosition) {
        positionAttrib.setXYZ(
          ptnum,
          this._pointContainer.instancePosition.x,
          this._pointContainer.instancePosition.y,
          this._pointContainer.instancePosition.z
        );
      }
      if (hasQuaternion) {
        quaternionAttrib.setXYZW(
          ptnum,
          this._pointContainer.instanceQuaternion.x,
          this._pointContainer.instanceQuaternion.y,
          this._pointContainer.instanceQuaternion.z,
          this._pointContainer.instanceQuaternion.w
        );
      }
      if (hasScale) {
        scaleAttrib.setXYZ(
          ptnum,
          this._pointContainer.instanceScale.x,
          this._pointContainer.instanceScale.y,
          this._pointContainer.instanceScale.z
        );
      }
      this._writeRequiredAttributes(ptnum, writeAttribNames, writeAttributeByName);
    }
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/operations/sop/InstancedMeshToMesh.ts

var InstancedMeshToMesh_async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};






class InstancedMeshToMeshSopOperation extends operations_sop_Base/* BaseSopOperation */.U {
  static type() {
    return Sop/* SopType.INSTANCED_MESH_TO_MESH */.aB.INSTANCED_MESH_TO_MESH;
  }
  cook(coreGroups, params) {
    return InstancedMeshToMesh_async(this, null, function* () {
      var _a;
      const coreGroup = coreGroups[0];
      const inputObjects = coreGroup.threejsObjects();
      const newObjects = [];
      const childrenToRemove = [];
      for (const inputObject of inputObjects) {
        inputObject.traverse((child) => {
          if (child.isInstancedMesh) {
            childrenToRemove.push(child);
            const count = child.count;
            const geometry = child.geometry;
            const material = child.material;
            for (let i = 0; i < count; i++) {
              const newMesh = copyObjectAllProperties(child, new three_module.Mesh());
              newMesh.geometry = params.cloneGeometry ? geometry.clone() : geometry;
              newMesh.material = (0,Type/* isArray */.kJ)(material) ? material[0] : material;
              child.getMatrixAt(i, newMesh.matrix);
              newMesh.matrix.decompose(newMesh.position, newMesh.quaternion, newMesh.scale);
              const parent = child.parent;
              if (parent) {
                parent.add(newMesh);
              } else {
                newObjects.push(newMesh);
              }
            }
          } else {
            if (child === inputObject) {
              newObjects.push(child);
            }
          }
        });
      }
      for (const childToRemove of childrenToRemove) {
        (_a = childToRemove.parent) == null ? void 0 : _a.remove(childToRemove);
      }
      return this.createCoreGroupFromObjects(newObjects);
    });
  }
}
InstancedMeshToMeshSopOperation.DEFAULT_PARAMS = {
  cloneGeometry: true
};
InstancedMeshToMeshSopOperation.INPUT_CLONED_STATE = [InputCloneMode/* InputCloneMode.ALWAYS */.m.ALWAYS, InputCloneMode/* InputCloneMode.NEVER */.m.NEVER];

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/sop/InstancedMeshToMesh.ts

var sop_InstancedMeshToMesh_async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};






const InstancedMeshToMesh_DEFAULT = InstancedMeshToMeshSopOperation.DEFAULT_PARAMS;
class InstancedMeshToMeshSopParamsConfig extends params_ParamsConfig/* NodeParamsConfig */.yI {
  constructor() {
    super(...arguments);
    this.cloneGeometry = params_ParamsConfig/* ParamConfig.BOOLEAN */.XC.BOOLEAN(InstancedMeshToMesh_DEFAULT.cloneGeometry);
  }
}
const InstancedMeshToMesh_ParamsConfig = new InstancedMeshToMeshSopParamsConfig();
class InstancedMeshToMeshSopNode extends sop_Base/* TypedSopNode */.x {
  constructor() {
    super(...arguments);
    this.paramsConfig = InstancedMeshToMesh_ParamsConfig;
  }
  static type() {
    return Sop/* SopType.INSTANCED_MESH_TO_MESH */.aB.INSTANCED_MESH_TO_MESH;
  }
  initializeNode() {
    super.initializeNode();
    this.io.inputs.setCount(1);
    this.io.inputs.initInputsClonedState(InstancedMeshToMeshSopOperation.INPUT_CLONED_STATE);
    (0,Constant/* registerObjectType */.UX)({
      type: Constant/* ObjectType.INSTANCED_MESH */.LP.INSTANCED_MESH,
      checkFunc: (o) => {
        if (o.isInstancedMesh) {
          return Constant/* ObjectType.INSTANCED_MESH */.LP.INSTANCED_MESH;
        }
      },
      ctor: three_module.InstancedMesh,
      humanName: "InstancedMesh"
    });
  }
  cook(inputCoreGroups) {
    return sop_InstancedMeshToMesh_async(this, null, function* () {
      this._operation = this._operation || new InstancedMeshToMeshSopOperation(this.scene(), this.states, this);
      const coreGroup = yield this._operation.cook(inputCoreGroups, this.pv);
      this.setCoreGroup(coreGroup);
    });
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/operations/sop/InstanceUpdate.ts





const _instancePts = [];
var InstanceUpdateMode = /* @__PURE__ */ ((InstanceUpdateMode2) => {
  InstanceUpdateMode2["GEO"] = "geo";
  InstanceUpdateMode2["POINTS"] = "points";
  return InstanceUpdateMode2;
})(InstanceUpdateMode || {});
const INSTANCE_UPDATE_MODES = ["geo" /* GEO */, "points" /* POINTS */];
class InstanceUpdateSopOperation extends operations_sop_Base/* BaseSopOperation */.U {
  static type() {
    return "instanceUpdate";
  }
  cook(inputCoreGroups, params) {
    this._cookFromUpdateMode(inputCoreGroups, params);
    return inputCoreGroups[0];
  }
  _cookFromUpdateMode(inputCoreGroups, params) {
    const mode = INSTANCE_UPDATE_MODES[params.mode];
    switch (mode) {
      case "geo" /* GEO */: {
        return this._updateGeo(inputCoreGroups, params);
      }
      case "points" /* POINTS */: {
        return this._updatePoints(inputCoreGroups, params);
      }
    }
    Assert/* TypeAssert.unreachable */.f.unreachable(mode);
  }
  _updateGeo(inputCoreGroups, params) {
    const instanceCoreGroup = inputCoreGroups[0];
    const updatingCoreGroup = inputCoreGroups[1];
    const instanceObject = instanceCoreGroup.threejsObjects()[0];
    const instanceGeometry = instanceObject.geometry;
    const updatingMesh = updatingCoreGroup.threejsObjectsWithGeo()[0];
    const updatingGeometry = updatingMesh.geometry;
    const attribNames = instanceCoreGroup.pointAttribNamesMatchingMask(params.geoAttributes);
    for (const attribName of attribNames) {
      const updatingAttrib = updatingGeometry.getAttribute(attribName);
      instanceGeometry.setAttribute(attribName, updatingAttrib);
      const instanceAttrib = instanceGeometry.getAttribute(attribName);
      instanceAttrib.needsUpdate = true;
    }
    if (updatingGeometry.index) {
      instanceGeometry.setIndex(updatingGeometry.index);
      const index = instanceGeometry.getIndex();
      if (index) {
        index.needsUpdate = true;
      }
    } else {
      instanceGeometry.setIndex(null);
    }
    instanceGeometry.groups = updatingGeometry.groups;
  }
  _updatePoints(inputCoreGroups, params) {
    const instanceCoreGroup = inputCoreGroups[0];
    const updatingCoreGroup = inputCoreGroups[1];
    const instanceObject = instanceCoreGroup.threejsObjects()[0];
    const instanceBufferGeo = instanceObject.geometry;
    const attribNames = instanceCoreGroup.pointAttribNamesMatchingMask(params.pointAttributes).map((attribName) => Instancer/* CoreInstancer.remapName */.t.remapName(attribName));
    let updateTransforms = false;
    for (const attribName of attribNames) {
      if (Instancer/* CoreInstancer.transformAttributeNames.includes */.t.transformAttributeNames.includes(attribName)) {
        updateTransforms = true;
      }
    }
    updatingCoreGroup.points(_instancePts);
    if (updateTransforms) {
      Instancer/* CoreInstancer.updateTransformInstanceAttributes */.t.updateTransformInstanceAttributes(_instancePts, updatingCoreGroup, instanceBufferGeo);
      for (const attribName of Instancer/* CoreInstancer.transformAttributeNames */.t.transformAttributeNames) {
        const attrib = instanceBufferGeo.getAttribute(attribName);
        if (attrib) {
          attrib.needsUpdate = true;
        }
      }
    }
  }
}
InstanceUpdateSopOperation.DEFAULT_PARAMS = {
  mode: INSTANCE_UPDATE_MODES.indexOf("geo" /* GEO */),
  geoAttributes: "P N",
  pointAttributes: "P"
};
InstanceUpdateSopOperation.INPUT_CLONED_STATE = [InputCloneMode/* InputCloneMode.FROM_NODE */.m.FROM_NODE, InputCloneMode/* InputCloneMode.NEVER */.m.NEVER];

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/sop/InstanceUpdate.ts





const InstanceUpdate_DEFAULT = InstanceUpdateSopOperation.DEFAULT_PARAMS;
class InstanceUpdateSopParamsConfig extends params_ParamsConfig/* NodeParamsConfig */.yI {
  constructor() {
    super(...arguments);
    /** @param defines what this node updates, either the instanced geometry or the instance points. */
    this.mode = params_ParamsConfig/* ParamConfig.INTEGER */.XC.INTEGER(InstanceUpdate_DEFAULT.mode, {
      menu: {
        entries: INSTANCE_UPDATE_MODES.map((name, value) => {
          return { value, name };
        })
      }
    });
    /** @param which attributes will be updated on the instanced geometry */
    this.geoAttributes = params_ParamsConfig/* ParamConfig.STRING */.XC.STRING(InstanceUpdate_DEFAULT.geoAttributes, {
      visibleIf: { mode: INSTANCE_UPDATE_MODES.indexOf(InstanceUpdateMode.GEO) }
    });
    /** @param which attributes will be updated ont the instance points */
    this.pointAttributes = params_ParamsConfig/* ParamConfig.STRING */.XC.STRING(InstanceUpdate_DEFAULT.pointAttributes, {
      visibleIf: { mode: INSTANCE_UPDATE_MODES.indexOf(InstanceUpdateMode.POINTS) }
    });
  }
}
const InstanceUpdate_ParamsConfig = new InstanceUpdateSopParamsConfig();
class InstanceUpdateSopNode extends sop_Base/* TypedSopNode */.x {
  constructor() {
    super(...arguments);
    this.paramsConfig = InstanceUpdate_ParamsConfig;
  }
  static type() {
    return Sop/* SopType.INSTANCE_UPDATE */.aB.INSTANCE_UPDATE;
  }
  initializeNode() {
    super.initializeNode();
    this.io.inputs.setCount(2);
    this.io.inputs.initInputsClonedState(InstanceUpdateSopOperation.INPUT_CLONED_STATE);
  }
  setMode(mode) {
    this.p.mode.set(INSTANCE_UPDATE_MODES.indexOf(mode));
  }
  cook(input_contents) {
    this._operation = this._operation || new InstanceUpdateSopOperation(this.scene(), this.states, this);
    const core_group = this._operation.cook(input_contents, this.pv);
    this.setCoreGroup(core_group);
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/sop/InstancesCount.ts






class InstancesCountSopParamsConfig extends params_ParamsConfig/* NodeParamsConfig */.yI {
  constructor() {
    super(...arguments);
    /** @param sets if max is used */
    this.useMax = params_ParamsConfig/* ParamConfig.BOOLEAN */.XC.BOOLEAN(0);
    /** @param max number of instances to display */
    this.max = params_ParamsConfig/* ParamConfig.INTEGER */.XC.INTEGER(1, {
      range: [0, 100],
      rangeLocked: [true, false],
      visibleIf: { useMax: 1 }
    });
  }
}
const InstancesCount_ParamsConfig = new InstancesCountSopParamsConfig();
class InstancesCountSopNode extends sop_Base/* TypedSopNode */.x {
  constructor() {
    super(...arguments);
    this.paramsConfig = InstancesCount_ParamsConfig;
  }
  static type() {
    return "instancesCount";
  }
  initializeNode() {
    this.io.inputs.setCount(1);
    this.io.inputs.initInputsClonedState(InputCloneMode/* InputCloneMode.FROM_NODE */.m.FROM_NODE);
  }
  cook(input_contents) {
    const core_group = input_contents[0];
    const objects = core_group.threejsObjectsWithGeo();
    for (const object of objects) {
      const geometry = object.geometry;
      if (geometry) {
        if (geometry instanceof three_module.InstancedBufferGeometry) {
          if ((0,Type/* isBooleanTrue */.bI)(this.pv.useMax)) {
            geometry.instanceCount = this.pv.max;
          } else {
            geometry.instanceCount = Infinity;
          }
        }
      }
    }
    this.setCoreGroup(core_group);
  }
}

// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/nodes/sop/Jitter.ts
var Jitter = __webpack_require__(28310);
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/operations/sop/Lattice.ts







const cubeLatticeDeformPoints = [
  new three_module.Vector3(),
  new three_module.Vector3(),
  new three_module.Vector3(),
  new three_module.Vector3(),
  new three_module.Vector3(),
  new three_module.Vector3(),
  new three_module.Vector3(),
  new three_module.Vector3()
];
class LatticeSopOperation extends operations_sop_Base/* BaseSopOperation */.U {
  static type() {
    return Sop/* SopType.LATTICE */.aB.LATTICE;
  }
  cook(inputCoreGroups, params) {
    const coreGroup = inputCoreGroups[0];
    cubeLatticeDeformPoints[0].copy(params.p0);
    cubeLatticeDeformPoints[1].copy(params.p1);
    cubeLatticeDeformPoints[2].copy(params.p2);
    cubeLatticeDeformPoints[3].copy(params.p3);
    cubeLatticeDeformPoints[4].copy(params.p4);
    cubeLatticeDeformPoints[5].copy(params.p5);
    cubeLatticeDeformPoints[6].copy(params.p6);
    cubeLatticeDeformPoints[7].copy(params.p7);
    const objects = Mask/* CoreMask.filterThreejsObjects */.x0.filterThreejsObjects(coreGroup, params);
    for (const object of objects) {
      const geometry = object.geometry;
      if (geometry) {
        CubeLatticeDeform_cubeLatticeDeform(object, cubeLatticeDeformPoints, params);
      }
    }
    return coreGroup;
  }
}
LatticeSopOperation.DEFAULT_PARAMS = {
  group: "",
  p0: DEFAULT_POSITIONS[0].clone(),
  p1: DEFAULT_POSITIONS[1].clone(),
  p2: DEFAULT_POSITIONS[2].clone(),
  p3: DEFAULT_POSITIONS[3].clone(),
  p4: DEFAULT_POSITIONS[4].clone(),
  p5: DEFAULT_POSITIONS[5].clone(),
  p6: DEFAULT_POSITIONS[6].clone(),
  p7: DEFAULT_POSITIONS[7].clone(),
  offset: new three_module.Vector3(0, 0, 0),
  moveObjectPosition: true
};
LatticeSopOperation.INPUT_CLONED_STATE = InputCloneMode/* InputCloneMode.FROM_NODE */.m.FROM_NODE;

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/sop/Lattice.ts





const Lattice_DEFAULT = LatticeSopOperation.DEFAULT_PARAMS;
class LatticeSopParamConfig extends params_ParamsConfig/* NodeParamsConfig */.yI {
  constructor() {
    super(...arguments);
    this.group = params_ParamsConfig/* ParamConfig.STRING */.XC.STRING(Lattice_DEFAULT.group, {
      objectMask: true
    });
    this.p0 = params_ParamsConfig/* ParamConfig.VECTOR3 */.XC.VECTOR3(Lattice_DEFAULT.p0);
    this.p1 = params_ParamsConfig/* ParamConfig.VECTOR3 */.XC.VECTOR3(Lattice_DEFAULT.p1);
    this.p2 = params_ParamsConfig/* ParamConfig.VECTOR3 */.XC.VECTOR3(Lattice_DEFAULT.p2);
    this.p3 = params_ParamsConfig/* ParamConfig.VECTOR3 */.XC.VECTOR3(Lattice_DEFAULT.p3);
    this.p4 = params_ParamsConfig/* ParamConfig.VECTOR3 */.XC.VECTOR3(Lattice_DEFAULT.p4);
    this.p5 = params_ParamsConfig/* ParamConfig.VECTOR3 */.XC.VECTOR3(Lattice_DEFAULT.p5);
    this.p6 = params_ParamsConfig/* ParamConfig.VECTOR3 */.XC.VECTOR3(Lattice_DEFAULT.p6);
    this.p7 = params_ParamsConfig/* ParamConfig.VECTOR3 */.XC.VECTOR3(Lattice_DEFAULT.p7);
    this.offset = params_ParamsConfig/* ParamConfig.VECTOR3 */.XC.VECTOR3(Lattice_DEFAULT.offset);
    this.moveObjectPosition = params_ParamsConfig/* ParamConfig.BOOLEAN */.XC.BOOLEAN(Lattice_DEFAULT.moveObjectPosition);
  }
}
const Lattice_ParamsConfig = new LatticeSopParamConfig();
class LatticeSopNode extends sop_Base/* TypedSopNode */.x {
  constructor() {
    super(...arguments);
    this.paramsConfig = Lattice_ParamsConfig;
  }
  static type() {
    return Sop/* SopType.LATTICE */.aB.LATTICE;
  }
  initializeNode() {
    this.io.inputs.setCount(1);
    this.io.inputs.initInputsClonedState(LatticeSopOperation.INPUT_CLONED_STATE);
  }
  cook(inputCoreGroups) {
    this._operation = this._operation || new LatticeSopOperation(this.scene(), this.states, this);
    const coreGroup = this._operation.cook(inputCoreGroups, this.pv);
    this.setCoreGroup(coreGroup);
  }
}

// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/nodes/sop/Layer.ts
var Layer = __webpack_require__(11655);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/params/Float.ts
var Float = __webpack_require__(76356);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/params/Color.ts
var params_Color = __webpack_require__(50673);
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/sop/LightMixer.ts

var LightMixer_async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};






var SUFFIX = /* @__PURE__ */ ((SUFFIX2) => {
  SUFFIX2["INTENSITY"] = "_int";
  SUFFIX2["COLOR"] = "_col";
  return SUFFIX2;
})(SUFFIX || {});
function intensityParamName(lightName) {
  return `${lightName}${"_int" /* INTENSITY */}`;
}
function colorParamName(lightName) {
  return `${lightName}${"_col" /* COLOR */}`;
}
class LightMixerParamsConfig extends params_ParamsConfig/* NodeParamsConfig */.yI {
  constructor() {
    super(...arguments);
    /** @param size of the box */
    this.setup = params_ParamsConfig/* ParamConfig.BUTTON */.XC.BUTTON(null, {
      callback: (node) => {
        LightMixerSopNode.PARAM_CALLBACK_setup(node);
      }
    });
  }
}
const LightMixer_ParamsConfig = new LightMixerParamsConfig();
class LightMixerSopNode extends sop_Base/* TypedSopNode */.x {
  constructor() {
    super(...arguments);
    this.paramsConfig = LightMixer_ParamsConfig;
    this._lightsByName = /* @__PURE__ */ new Map();
  }
  static type() {
    return "lightMixer";
  }
  initializeNode() {
    this.io.inputs.setCount(0, 1);
    this.io.inputs.initInputsClonedState(InputCloneMode/* InputCloneMode.FROM_NODE */.m.FROM_NODE);
  }
  cook(inputCoreGroups) {
    const coreGroup = inputCoreGroups[0];
    this._findLights(coreGroup);
    this._lightsByName.forEach((light, lightName) => {
      const intensityParam = this.params.get(intensityParamName(lightName));
      const colorParam = this.params.get(colorParamName(lightName));
      if (intensityParam && intensityParam instanceof Float/* FloatParam */.Z) {
        light.intensity = intensityParam.value;
      }
      if (colorParam && colorParam instanceof params_Color/* ColorParam */.A) {
        light.color.copy(colorParam.value);
      }
    });
    this.setCoreGroup(coreGroup);
  }
  _findLights(coreGroup) {
    this._lightsByName.clear();
    const objects = coreGroup.threejsObjects();
    for (const object of objects) {
      object.traverse((child) => {
        if (child.isLight) {
          this._lightsByName.set(child.name, child);
        }
      });
    }
  }
  static PARAM_CALLBACK_setup(node) {
    node._paramCallbackSetup();
  }
  _paramCallbackSetup() {
    return LightMixer_async(this, null, function* () {
      this.states.error.clear();
      this.params.updateParams({ namesToDelete: this.params.spare.map((p) => p.name()) });
      const inputNode = this.io.inputs.input(0);
      if (!inputNode) {
        this.states.error.set("no input node");
        return;
      }
      const container = yield inputNode.compute();
      const coreGroup = container.coreContent();
      if (!coreGroup) {
        this.states.error.set("failed to cook input node");
        return;
      }
      this._findLights(coreGroup);
      const paramsDataToAdd = [];
      this._lightsByName.forEach((light, lightName) => {
        const intensity = {
          name: intensityParamName(lightName),
          type: ParamType/* ParamType.FLOAT */._.FLOAT,
          initValue: light.intensity,
          rawInput: light.intensity,
          options: {
            range: [0, 2],
            rangeLocked: [true, false],
            spare: true
          }
        };
        const color = {
          name: colorParamName(lightName),
          type: ParamType/* ParamType.COLOR */._.COLOR,
          initValue: light.color.toArray(),
          rawInput: light.color.toArray(),
          options: {
            separatorAfter: true,
            spare: true
          }
        };
        paramsDataToAdd.push(intensity);
        paramsDataToAdd.push(color);
      });
      this.params.updateParams({ toAdd: paramsDataToAdd });
    });
  }
}

// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/nodes/sop/LightProbe.ts
var nodes_sop_LightProbe = __webpack_require__(2885);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/nodes/sop/Line.ts
var Line = __webpack_require__(87330);
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/sop/Lod.ts

var Lod_async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};









class LODSopParamsConfig extends params_ParamsConfig/* NodeParamsConfig */.yI {
  constructor() {
    super(...arguments);
    /** @param distance when switching between high res and mid res (first input and second input) */
    this.distance0 = params_ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(10, {
      range: [0, 100],
      rangeLocked: [true, false]
    });
    /** @param distance when switching between mid res and low res (second input and third input) */
    this.distance1 = params_ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(20, {
      range: [0, 100],
      rangeLocked: [true, false]
    });
    /** @param Threshold used to avoid flickering at LOD boundaries, as a fraction of distance */
    this.hysteresis = params_ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(0, {
      range: [0, 1],
      rangeLocked: [true, true]
    });
    /** @param sets if the switch is done automatically */
    this.autoUpdate = params_ParamsConfig/* ParamConfig.BOOLEAN */.XC.BOOLEAN(1);
    /** @param updates which object is displayed manually */
    this.update = params_ParamsConfig/* ParamConfig.BUTTON */.XC.BUTTON(null, {
      callback: (node) => {
        LodSopNode.PARAM_CALLBACK_update(node);
      }
    });
    /** @param sets which camera will be used when the switch is to be done manually */
    this.camera = params_ParamsConfig/* ParamConfig.NODE_PATH */.XC.NODE_PATH("", {
      nodeSelection: {
        context: poly_NodeContext/* NodeContext.OBJ */.sy.OBJ,
        types: poly_NodeContext/* CAMERA_TYPES */.o2
      },
      visibleIf: { autoUpdate: 0 },
      dependentOnFoundNode: false
    });
  }
}
const Lod_ParamsConfig = new LODSopParamsConfig();
class LodSopNode extends sop_Base/* TypedSopNode */.x {
  constructor() {
    super(...arguments);
    this.paramsConfig = Lod_ParamsConfig;
    this._lod = this._createLOD();
  }
  static type() {
    return Sop/* SopType.LOD */.aB.LOD;
  }
  initializeNode() {
    this.io.inputs.setCount(1, 3);
    this.io.inputs.initInputsClonedState(InputCloneMode/* InputCloneMode.FROM_NODE */.m.FROM_NODE);
  }
  _createLOD() {
    (0,Constant/* registerObjectType */.UX)({
      type: Constant/* ObjectType.LOD */.LP.LOD,
      checkFunc: (o) => {
        if (o.isLOD) {
          return Constant/* ObjectType.LOD */.LP.LOD;
        }
      },
      ctor: three_module.LOD,
      humanName: "LOD"
    });
    const lod = new three_module.LOD();
    lod.matrixAutoUpdate = false;
    return lod;
  }
  cook(inputCoreGroups) {
    this._clearLOD();
    this._addLevel(inputCoreGroups[0], 0);
    this._addLevel(inputCoreGroups[1], this.pv.distance0);
    this._addLevel(inputCoreGroups[2], this.pv.distance1);
    this._lod.autoUpdate = (0,Type/* isBooleanTrue */.bI)(this.pv.autoUpdate);
    this.setObject(this._lod);
  }
  _addLevel(coreGroup, level) {
    if (coreGroup) {
      const objects = coreGroup.threejsObjects();
      let object;
      for (let i = 0; i < objects.length; i++) {
        object = objects[i];
        object.visible = true;
        this._lod.addLevel(object, level, this.pv.hysteresis);
        if (level == 0) {
          if (i == 0) {
            this._lod.matrix.copy(object.matrix);
            Transform/* CoreTransform.decomposeMatrix */.ZR.decomposeMatrix(this._lod);
          }
        }
        object.matrix.identity();
        Transform/* CoreTransform.decomposeMatrix */.ZR.decomposeMatrix(object);
      }
    }
  }
  _clearLOD() {
    let child;
    while (child = this._lod.children[0]) {
      this._lod.remove(child);
      child.matrix.multiply(this._lod.matrix);
      Transform/* CoreTransform.decomposeMatrix */.ZR.decomposeMatrix(child);
    }
    while (this._lod.levels.pop()) {
    }
  }
  static PARAM_CALLBACK_update(node) {
    node._updateLOD();
  }
  _updateLOD() {
    return Lod_async(this, null, function* () {
      if ((0,Type/* isBooleanTrue */.bI)(this.pv.autoUpdate)) {
        return;
      }
      const cameraNode = this.pv.camera.nodeWithContext(poly_NodeContext/* NodeContext.OBJ */.sy.OBJ, this.states.error);
      if (!cameraNode) {
        this.states.error.set("no camera node found");
        return;
      }
      if (!poly_NodeContext/* CAMERA_TYPES.includes */.o2.includes(cameraNode.type())) {
        this.states.error.set("node is not a camera node");
        return;
      }
      const object = cameraNode.object;
      this._lod.update(object);
    });
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/core/LookAt.ts


const t = new three_module.Vector3();
const _m4 = new three_module.Matrix4();
function quatLookAt(position, targetPosition, up, target) {
  _m4.lookAt(targetPosition, position, up);
  target.setFromRotationMatrix(_m4);
}
class CoreLookAt {
  static applyLookAt(object, target, invert) {
    if (invert) {
      t.copy(object.position);
      object.position.copy(target);
      object.updateMatrix();
      object.lookAt(t);
      object.position.copy(t);
      object.updateMatrix();
    } else {
      object.lookAt(target);
    }
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/operations/sop/LookAt.ts





const LookAt_q1 = new three_module.Quaternion();
const LookAt_q2 = new three_module.Quaternion();
class LookAtSopOperation extends operations_sop_Base/* BaseSopOperation */.U {
  static type() {
    return "lookAt";
  }
  cook(inputCoreGroups, params) {
    const objects = inputCoreGroups[0].threejsObjects();
    for (let object of objects) {
      object.up.copy(params.up);
      if (params.lerp >= 1) {
        CoreLookAt.applyLookAt(object, params.target, params.invertDirection);
      } else {
        LookAt_q1.copy(object.quaternion);
        CoreLookAt.applyLookAt(object, params.target, params.invertDirection);
        LookAt_q2.copy(object.quaternion);
        LookAt_q1.slerp(LookAt_q2, params.lerp);
        object.quaternion.copy(LookAt_q1);
      }
      object.updateMatrix();
    }
    return inputCoreGroups[0];
  }
}
LookAtSopOperation.DEFAULT_PARAMS = {
  target: new three_module.Vector3(0, 0, 1),
  up: new three_module.Vector3(0, 1, 0),
  lerp: 1,
  invertDirection: false
};
LookAtSopOperation.INPUT_CLONED_STATE = InputCloneMode/* InputCloneMode.FROM_NODE */.m.FROM_NODE;

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/sop/LookAt.ts





const LookAt_DEFAULT = LookAtSopOperation.DEFAULT_PARAMS;
class LookAtSopParamConfig extends params_ParamsConfig/* NodeParamsConfig */.yI {
  constructor() {
    super(...arguments);
    /** @param target */
    this.target = params_ParamsConfig/* ParamConfig.VECTOR3 */.XC.VECTOR3(LookAt_DEFAULT.target);
    /** @param up vector */
    this.up = params_ParamsConfig/* ParamConfig.VECTOR3 */.XC.VECTOR3(LookAt_DEFAULT.up);
    /** @param lerp */
    this.lerp = params_ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(LookAt_DEFAULT.lerp, {
      range: [0, 1],
      rangeLocked: [true, true]
    });
    /** @param invertDirection */
    this.invertDirection = params_ParamsConfig/* ParamConfig.BOOLEAN */.XC.BOOLEAN(LookAt_DEFAULT.invertDirection);
  }
}
const LookAt_ParamsConfig = new LookAtSopParamConfig();
class LookAtSopNode extends sop_Base/* TypedSopNode */.x {
  constructor() {
    super(...arguments);
    this.paramsConfig = LookAt_ParamsConfig;
  }
  static type() {
    return Sop/* SopType.LOOK_AT */.aB.LOOK_AT;
  }
  initializeNode() {
    this.io.inputs.setCount(1);
    this.io.inputs.initInputsClonedState(LookAtSopOperation.INPUT_CLONED_STATE);
  }
  cook(inputCoreGroups) {
    this._operation = this._operation || new LookAtSopOperation(this.scene(), this.states, this);
    const coreGroup = this._operation.cook(inputCoreGroups, this.pv);
    this.setCoreGroup(coreGroup);
  }
}

// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/nodes/sop/MapboxCamera.ts
var MapboxCamera = __webpack_require__(62092);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/nodes/sop/MapboxLayer.ts + 3 modules
var MapboxLayer = __webpack_require__(82710);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/nodes/sop/MapboxPlane.ts + 1 modules
var MapboxPlane = __webpack_require__(55986);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/nodes/sop/MapboxTransform.ts
var MapboxTransform = __webpack_require__(55680);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/nodes/sop/Material.ts
var sop_Material = __webpack_require__(74874);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/nodes/mat/utils/helpers/MaterialSideHelper.ts
var MaterialSideHelper = __webpack_require__(80985);
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/operations/sop/MaterialProperties.ts






class MaterialPropertiesSopOperation extends operations_sop_Base/* BaseSopOperation */.U {
  static type() {
    return "materialProperties";
  }
  cook(inputCoreGroups, params) {
    const coreGroup = inputCoreGroups[0];
    const selectedObjects = Mask/* CoreMask.filterThreejsObjects */.x0.filterThreejsObjects(coreGroup, params);
    for (let selectedObject of selectedObjects) {
      this._updateObject(selectedObject, params);
    }
    return coreGroup;
  }
  _updateObject(object, params) {
    const material = object.material;
    if (material) {
      this._updateMaterial(material, params);
    }
  }
  _updateMaterial(material, params) {
    if ((0,Type/* isBooleanTrue */.bI)(params.tside)) {
      (0,MaterialSideHelper/* updateMaterialSideWithShadow */.N1)(material, params);
    }
    if ((0,Type/* isBooleanTrue */.bI)(params.twireframe)) {
      if (material.wireframe != void 0) {
        material.wireframe = params.wireframe;
      }
    }
  }
}
MaterialPropertiesSopOperation.DEFAULT_PARAMS = {
  group: "",
  // side
  tside: false,
  doubleSided: false,
  front: true,
  overrideShadowSide: false,
  shadowDoubleSided: false,
  shadowFront: true,
  // wireframe
  twireframe: false,
  wireframe: false
};
MaterialPropertiesSopOperation.INPUT_CLONED_STATE = InputCloneMode/* InputCloneMode.FROM_NODE */.m.FROM_NODE;

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/sop/MaterialProperties.ts





const MaterialProperties_DEFAULT = MaterialPropertiesSopOperation.DEFAULT_PARAMS;
class MaterialPropertiesSopParamsConfig extends params_ParamsConfig/* NodeParamsConfig */.yI {
  constructor() {
    super(...arguments);
    /** @param group to assign the material to */
    this.group = params_ParamsConfig/* ParamConfig.STRING */.XC.STRING(MaterialProperties_DEFAULT.group, {
      objectMask: true
    });
    /** @param toggle on to allow updating the side properties of the materials */
    this.tside = params_ParamsConfig/* ParamConfig.BOOLEAN */.XC.BOOLEAN(MaterialProperties_DEFAULT.tside);
    /** @param defines if the material is double sided or not */
    this.doubleSided = params_ParamsConfig/* ParamConfig.BOOLEAN */.XC.BOOLEAN(0, {
      visibleIf: { tside: true }
    });
    /** @param if the material is not double sided, it can be front sided, or back sided */
    this.front = params_ParamsConfig/* ParamConfig.BOOLEAN */.XC.BOOLEAN(1, { visibleIf: { tside: true, doubleSided: false } });
    /** @param override the default shadowSide behavior */
    this.overrideShadowSide = params_ParamsConfig/* ParamConfig.BOOLEAN */.XC.BOOLEAN(MaterialProperties_DEFAULT.overrideShadowSide, { visibleIf: { tside: true } });
    /** @param defines which side(s) are used when rendering shadows */
    this.shadowDoubleSided = params_ParamsConfig/* ParamConfig.BOOLEAN */.XC.BOOLEAN(MaterialProperties_DEFAULT.shadowDoubleSided, {
      visibleIf: { tside: true, overrideShadowSide: true }
    });
    /** @param if the material is not double sided, it can be front sided, or back sided, when computing shadows */
    this.shadowFront = params_ParamsConfig/* ParamConfig.BOOLEAN */.XC.BOOLEAN(1, {
      visibleIf: { tside: true, overrideShadowSide: true, shadowDoubleSided: false }
    });
    /** @param toggle on to allow updating the wireframe properties of the materials */
    this.twireframe = params_ParamsConfig/* ParamConfig.BOOLEAN */.XC.BOOLEAN(MaterialProperties_DEFAULT.twireframe);
    /** @param defines if the material is double sided or not */
    this.wireframe = params_ParamsConfig/* ParamConfig.BOOLEAN */.XC.BOOLEAN(MaterialProperties_DEFAULT.wireframe, {
      visibleIf: { twireframe: true }
    });
  }
}
const MaterialProperties_ParamsConfig = new MaterialPropertiesSopParamsConfig();
class MaterialPropertiesSopNode extends sop_Base/* TypedSopNode */.x {
  constructor() {
    super(...arguments);
    this.paramsConfig = MaterialProperties_ParamsConfig;
  }
  static type() {
    return Sop/* SopType.MATERIAL_PROPERTIES */.aB.MATERIAL_PROPERTIES;
  }
  initializeNode() {
    this.io.inputs.setCount(1);
    this.io.inputs.initInputsClonedState(MaterialPropertiesSopOperation.INPUT_CLONED_STATE);
  }
  cook(inputCoreGroups) {
    this._operation = this._operation || new MaterialPropertiesSopOperation(this.scene(), this.states, this);
    const coreGroup = this._operation.cook(inputCoreGroups, this.pv);
    this.setCoreGroup(coreGroup);
  }
}

// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/nodes/sop/Merge.ts
var sop_Merge = __webpack_require__(27929);
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/modules/core/objects/MarchingCubes.ts




const vlist = new Float32Array(12 * 3);
const nlist = new Float32Array(12 * 3);
const clist = new Float32Array(12 * 3);
function lerp(a, b, t) {
  return a + (b - a) * t;
}
class MarchingCubes extends three_module.BufferGeometry {
  constructor(resolution, enableUvs, enableColors) {
    super();
    this.resolution = resolution;
    this.isMarchingCubes = true;
    this.isolation = 80;
    this.size = -1;
    this.size2 = -1;
    this.size3 = -1;
    this.halfsize = -1;
    this.delta = -1;
    this.yd = -1;
    this.zd = -1;
    this.count = -1;
    this.maxCount = -1;
    this.enableUvs = enableUvs !== void 0 ? enableUvs : false;
    this.enableColors = enableColors !== void 0 ? enableColors : false;
    this.size = this.resolution;
    this.size2 = this.size * this.size;
    this.size3 = this.size2 * this.size;
    this.halfsize = this.size / 2;
    this.delta = 2 / this.size;
    this.yd = this.size;
    this.zd = this.size2;
    this.field = new Float32Array(this.size3);
    this.normal_cache = new Float32Array(this.size3 * 3);
    this.palette = new Float32Array(this.size3 * 3);
    this.maxCount = this.size3;
    this.count = 0;
    this.positionArray = new Float32Array(this.maxCount * 3);
    this.setAttribute("position", new three_module.BufferAttribute(this.positionArray, 3));
    this.normalArray = new Float32Array(this.maxCount * 3);
    this.setAttribute("normal", new three_module.BufferAttribute(this.normalArray, 3));
    if (this.enableUvs) {
      this.uvArray = new Float32Array(this.maxCount * 2);
      this.setAttribute("uv", new three_module.BufferAttribute(this.uvArray, 2));
    }
    if (this.enableColors) {
      this.colorArray = new Float32Array(this.maxCount * 3);
      this.setAttribute("color", new three_module.BufferAttribute(this.colorArray, 3));
    }
    const polygonize = (fx, fy, fz, q, isol) => {
      const q1 = q + 1, qy = q + this.yd, qz = q + this.zd, q1y = q1 + this.yd, q1z = q1 + this.zd, qyz = q + this.yd + this.zd, q1yz = q1 + this.yd + this.zd;
      let cubeindex = 0;
      const field0 = this.field[q], field1 = this.field[q1], field2 = this.field[qy], field3 = this.field[q1y], field4 = this.field[qz], field5 = this.field[q1z], field6 = this.field[qyz], field7 = this.field[q1yz];
      if (field0 < isol)
        cubeindex |= 1;
      if (field1 < isol)
        cubeindex |= 2;
      if (field2 < isol)
        cubeindex |= 8;
      if (field3 < isol)
        cubeindex |= 4;
      if (field4 < isol)
        cubeindex |= 16;
      if (field5 < isol)
        cubeindex |= 32;
      if (field6 < isol)
        cubeindex |= 128;
      if (field7 < isol)
        cubeindex |= 64;
      const bits = edgeTable[cubeindex];
      if (bits === 0)
        return 0;
      const d = this.delta, fx2 = fx + d, fy2 = fy + d, fz2 = fz + d;
      if (bits & 1) {
        compNorm(q);
        compNorm(q1);
        VIntX(q * 3, 0, isol, fx, fy, fz, field0, field1, q, q1);
      }
      if (bits & 2) {
        compNorm(q1);
        compNorm(q1y);
        VIntY(q1 * 3, 3, isol, fx2, fy, fz, field1, field3, q1, q1y);
      }
      if (bits & 4) {
        compNorm(qy);
        compNorm(q1y);
        VIntX(qy * 3, 6, isol, fx, fy2, fz, field2, field3, qy, q1y);
      }
      if (bits & 8) {
        compNorm(q);
        compNorm(qy);
        VIntY(q * 3, 9, isol, fx, fy, fz, field0, field2, q, qy);
      }
      if (bits & 16) {
        compNorm(qz);
        compNorm(q1z);
        VIntX(qz * 3, 12, isol, fx, fy, fz2, field4, field5, qz, q1z);
      }
      if (bits & 32) {
        compNorm(q1z);
        compNorm(q1yz);
        VIntY(q1z * 3, 15, isol, fx2, fy, fz2, field5, field7, q1z, q1yz);
      }
      if (bits & 64) {
        compNorm(qyz);
        compNorm(q1yz);
        VIntX(qyz * 3, 18, isol, fx, fy2, fz2, field6, field7, qyz, q1yz);
      }
      if (bits & 128) {
        compNorm(qz);
        compNorm(qyz);
        VIntY(qz * 3, 21, isol, fx, fy, fz2, field4, field6, qz, qyz);
      }
      if (bits & 256) {
        compNorm(q);
        compNorm(qz);
        VIntZ(q * 3, 24, isol, fx, fy, fz, field0, field4, q, qz);
      }
      if (bits & 512) {
        compNorm(q1);
        compNorm(q1z);
        VIntZ(q1 * 3, 27, isol, fx2, fy, fz, field1, field5, q1, q1z);
      }
      if (bits & 1024) {
        compNorm(q1y);
        compNorm(q1yz);
        VIntZ(q1y * 3, 30, isol, fx2, fy2, fz, field3, field7, q1y, q1yz);
      }
      if (bits & 2048) {
        compNorm(qy);
        compNorm(qyz);
        VIntZ(qy * 3, 33, isol, fx, fy2, fz, field2, field6, qy, qyz);
      }
      cubeindex <<= 4;
      let o1, o2, o3, numtris = 0, i = 0;
      while (triTable[cubeindex + i] != -1) {
        o1 = cubeindex + i;
        o2 = o1 + 1;
        o3 = o1 + 2;
        posnormtriv(
          vlist,
          nlist,
          clist,
          3 * triTable[o1],
          3 * triTable[o2],
          3 * triTable[o3]
          /*, renderCallback*/
        );
        i += 3;
        numtris++;
      }
      return numtris;
    };
    this._createPolygons = () => {
      const smin2 = this.size - 2;
      for (let z = 1; z < smin2; z++) {
        const z_offset = this.size2 * z;
        const fz = (z - this.halfsize) / this.halfsize;
        for (let y = 1; y < smin2; y++) {
          const y_offset = z_offset + this.size * y;
          const fy = (y - this.halfsize) / this.halfsize;
          for (let x = 1; x < smin2; x++) {
            const fx = (x - this.halfsize) / this.halfsize;
            const q = y_offset + x;
            polygonize(
              fx,
              fy,
              fz,
              q,
              this.isolation
              /*, renderCallback*/
            );
          }
        }
      }
    };
    const VIntX = (q, offset, isol, x, y, z, valp1, valp2, c_offset1, c_offset2) => {
      const mu = (isol - valp1) / (valp2 - valp1), nc = this.normal_cache;
      vlist[offset + 0] = x + mu * this.delta;
      vlist[offset + 1] = y;
      vlist[offset + 2] = z;
      nlist[offset + 0] = lerp(nc[q + 0], nc[q + 3], mu);
      nlist[offset + 1] = lerp(nc[q + 1], nc[q + 4], mu);
      nlist[offset + 2] = lerp(nc[q + 2], nc[q + 5], mu);
      clist[offset + 0] = lerp(this.palette[c_offset1 * 3 + 0], this.palette[c_offset2 * 3 + 0], mu);
      clist[offset + 1] = lerp(this.palette[c_offset1 * 3 + 1], this.palette[c_offset2 * 3 + 1], mu);
      clist[offset + 2] = lerp(this.palette[c_offset1 * 3 + 2], this.palette[c_offset2 * 3 + 2], mu);
    };
    const VIntY = (q, offset, isol, x, y, z, valp1, valp2, c_offset1, c_offset2) => {
      const mu = (isol - valp1) / (valp2 - valp1), nc = this.normal_cache;
      vlist[offset + 0] = x;
      vlist[offset + 1] = y + mu * this.delta;
      vlist[offset + 2] = z;
      const q2 = q + this.yd * 3;
      nlist[offset + 0] = lerp(nc[q + 0], nc[q2 + 0], mu);
      nlist[offset + 1] = lerp(nc[q + 1], nc[q2 + 1], mu);
      nlist[offset + 2] = lerp(nc[q + 2], nc[q2 + 2], mu);
      clist[offset + 0] = lerp(this.palette[c_offset1 * 3 + 0], this.palette[c_offset2 * 3 + 0], mu);
      clist[offset + 1] = lerp(this.palette[c_offset1 * 3 + 1], this.palette[c_offset2 * 3 + 1], mu);
      clist[offset + 2] = lerp(this.palette[c_offset1 * 3 + 2], this.palette[c_offset2 * 3 + 2], mu);
    };
    const VIntZ = (q, offset, isol, x, y, z, valp1, valp2, c_offset1, c_offset2) => {
      const mu = (isol - valp1) / (valp2 - valp1), nc = this.normal_cache;
      vlist[offset + 0] = x;
      vlist[offset + 1] = y;
      vlist[offset + 2] = z + mu * this.delta;
      const q2 = q + this.zd * 3;
      nlist[offset + 0] = lerp(nc[q + 0], nc[q2 + 0], mu);
      nlist[offset + 1] = lerp(nc[q + 1], nc[q2 + 1], mu);
      nlist[offset + 2] = lerp(nc[q + 2], nc[q2 + 2], mu);
      clist[offset + 0] = lerp(this.palette[c_offset1 * 3 + 0], this.palette[c_offset2 * 3 + 0], mu);
      clist[offset + 1] = lerp(this.palette[c_offset1 * 3 + 1], this.palette[c_offset2 * 3 + 1], mu);
      clist[offset + 2] = lerp(this.palette[c_offset1 * 3 + 2], this.palette[c_offset2 * 3 + 2], mu);
    };
    const compNorm = (q) => {
      const q3 = q * 3;
      if (this.normal_cache[q3] === 0) {
        this.normal_cache[q3 + 0] = this.field[q - 1] - this.field[q + 1];
        this.normal_cache[q3 + 1] = this.field[q - this.yd] - this.field[q + this.yd];
        this.normal_cache[q3 + 2] = this.field[q - this.zd] - this.field[q + this.zd];
      }
    };
    const posnormtriv = (pos, norm, colors, o1, o2, o3) => {
      const c = this.count * 3;
      if (!this.positionArray) {
        return;
      }
      if (!this.normalArray) {
        return;
      }
      this.positionArray[c + 0] = pos[o1];
      this.positionArray[c + 1] = pos[o1 + 1];
      this.positionArray[c + 2] = pos[o1 + 2];
      this.positionArray[c + 3] = pos[o2];
      this.positionArray[c + 4] = pos[o2 + 1];
      this.positionArray[c + 5] = pos[o2 + 2];
      this.positionArray[c + 6] = pos[o3];
      this.positionArray[c + 7] = pos[o3 + 1];
      this.positionArray[c + 8] = pos[o3 + 2];
      this.normalArray[c + 0] = norm[o1 + 0];
      this.normalArray[c + 1] = norm[o1 + 1];
      this.normalArray[c + 2] = norm[o1 + 2];
      this.normalArray[c + 3] = norm[o2 + 0];
      this.normalArray[c + 4] = norm[o2 + 1];
      this.normalArray[c + 5] = norm[o2 + 2];
      this.normalArray[c + 6] = norm[o3 + 0];
      this.normalArray[c + 7] = norm[o3 + 1];
      this.normalArray[c + 8] = norm[o3 + 2];
      if (this.enableUvs && this.uvArray) {
        const d = this.count * 2;
        this.uvArray[d + 0] = pos[o1 + 0];
        this.uvArray[d + 1] = pos[o1 + 2];
        this.uvArray[d + 2] = pos[o2 + 0];
        this.uvArray[d + 3] = pos[o2 + 2];
        this.uvArray[d + 4] = pos[o3 + 0];
        this.uvArray[d + 5] = pos[o3 + 2];
      }
      if (this.enableColors && this.colorArray) {
        this.colorArray[c + 0] = colors[o1 + 0];
        this.colorArray[c + 1] = colors[o1 + 1];
        this.colorArray[c + 2] = colors[o1 + 2];
        this.colorArray[c + 3] = colors[o2 + 0];
        this.colorArray[c + 4] = colors[o2 + 1];
        this.colorArray[c + 5] = colors[o2 + 2];
        this.colorArray[c + 6] = colors[o3 + 0];
        this.colorArray[c + 7] = colors[o3 + 1];
        this.colorArray[c + 8] = colors[o3 + 2];
      }
      this.count += 3;
    };
  }
  createPolygons() {
    this._createPolygons();
  }
  addBall(ballx, bally, ballz, strength, subtract, colors) {
    const sign = Math.sign(strength);
    strength = Math.abs(strength);
    const userDefineColor = !(colors === void 0 || colors === null);
    let ballColor = new three_module.Color(ballx, bally, ballz);
    if (userDefineColor) {
      try {
        if (colors)
          ballColor = colors;
      } catch (err) {
        ballColor = new three_module.Color(ballx, bally, ballz);
      }
    }
    const radius = this.size * Math.sqrt(strength / subtract), zs = ballz * this.size, ys = bally * this.size, xs = ballx * this.size;
    let min_z = Math.floor(zs - radius);
    if (min_z < 1)
      min_z = 1;
    let max_z = Math.floor(zs + radius);
    if (max_z > this.size - 1)
      max_z = this.size - 1;
    let min_y = Math.floor(ys - radius);
    if (min_y < 1)
      min_y = 1;
    let max_y = Math.floor(ys + radius);
    if (max_y > this.size - 1)
      max_y = this.size - 1;
    let min_x = Math.floor(xs - radius);
    if (min_x < 1)
      min_x = 1;
    let max_x = Math.floor(xs + radius);
    if (max_x > this.size - 1)
      max_x = this.size - 1;
    let x, y, z, y_offset, z_offset, fx, fy, fz, fz2, fy2, val;
    for (z = min_z; z < max_z; z++) {
      z_offset = this.size2 * z;
      fz = z / this.size - ballz;
      fz2 = fz * fz;
      for (y = min_y; y < max_y; y++) {
        y_offset = z_offset + this.size * y;
        fy = y / this.size - bally;
        fy2 = fy * fy;
        for (x = min_x; x < max_x; x++) {
          fx = x / this.size - ballx;
          val = strength / (1e-6 + fx * fx + fy2 + fz2) - subtract;
          if (val > 0) {
            this.field[y_offset + x] += val * sign;
            const ratio = Math.sqrt((x - xs) * (x - xs) + (y - ys) * (y - ys) + (z - zs) * (z - zs)) / radius;
            const contrib = 1 - ratio * ratio * ratio * (ratio * (ratio * 6 - 15) + 10);
            this.palette[(y_offset + x) * 3 + 0] += ballColor.r * contrib;
            this.palette[(y_offset + x) * 3 + 1] += ballColor.g * contrib;
            this.palette[(y_offset + x) * 3 + 2] += ballColor.b * contrib;
          }
        }
      }
    }
  }
}
const edgeTable = new Int32Array([
  0,
  265,
  515,
  778,
  1030,
  1295,
  1541,
  1804,
  2060,
  2309,
  2575,
  2822,
  3082,
  3331,
  3593,
  3840,
  400,
  153,
  915,
  666,
  1430,
  1183,
  1941,
  1692,
  2460,
  2197,
  2975,
  2710,
  3482,
  3219,
  3993,
  3728,
  560,
  825,
  51,
  314,
  1590,
  1855,
  1077,
  1340,
  2620,
  2869,
  2111,
  2358,
  3642,
  3891,
  3129,
  3376,
  928,
  681,
  419,
  170,
  1958,
  1711,
  1445,
  1196,
  2988,
  2725,
  2479,
  2214,
  4010,
  3747,
  3497,
  3232,
  1120,
  1385,
  1635,
  1898,
  102,
  367,
  613,
  876,
  3180,
  3429,
  3695,
  3942,
  2154,
  2403,
  2665,
  2912,
  1520,
  1273,
  2035,
  1786,
  502,
  255,
  1013,
  764,
  3580,
  3317,
  4095,
  3830,
  2554,
  2291,
  3065,
  2800,
  1616,
  1881,
  1107,
  1370,
  598,
  863,
  85,
  348,
  3676,
  3925,
  3167,
  3414,
  2650,
  2899,
  2137,
  2384,
  1984,
  1737,
  1475,
  1226,
  966,
  719,
  453,
  204,
  4044,
  3781,
  3535,
  3270,
  3018,
  2755,
  2505,
  2240,
  2240,
  2505,
  2755,
  3018,
  3270,
  3535,
  3781,
  4044,
  204,
  453,
  719,
  966,
  1226,
  1475,
  1737,
  1984,
  2384,
  2137,
  2899,
  2650,
  3414,
  3167,
  3925,
  3676,
  348,
  85,
  863,
  598,
  1370,
  1107,
  1881,
  1616,
  2800,
  3065,
  2291,
  2554,
  3830,
  4095,
  3317,
  3580,
  764,
  1013,
  255,
  502,
  1786,
  2035,
  1273,
  1520,
  2912,
  2665,
  2403,
  2154,
  3942,
  3695,
  3429,
  3180,
  876,
  613,
  367,
  102,
  1898,
  1635,
  1385,
  1120,
  3232,
  3497,
  3747,
  4010,
  2214,
  2479,
  2725,
  2988,
  1196,
  1445,
  1711,
  1958,
  170,
  419,
  681,
  928,
  3376,
  3129,
  3891,
  3642,
  2358,
  2111,
  2869,
  2620,
  1340,
  1077,
  1855,
  1590,
  314,
  51,
  825,
  560,
  3728,
  3993,
  3219,
  3482,
  2710,
  2975,
  2197,
  2460,
  1692,
  1941,
  1183,
  1430,
  666,
  915,
  153,
  400,
  3840,
  3593,
  3331,
  3082,
  2822,
  2575,
  2309,
  2060,
  1804,
  1541,
  1295,
  1030,
  778,
  515,
  265,
  0
]);
const triTable = new Int32Array([
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  0,
  8,
  3,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  0,
  1,
  9,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  1,
  8,
  3,
  9,
  8,
  1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  1,
  2,
  10,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  0,
  8,
  3,
  1,
  2,
  10,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  9,
  2,
  10,
  0,
  2,
  9,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  2,
  8,
  3,
  2,
  10,
  8,
  10,
  9,
  8,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  3,
  11,
  2,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  0,
  11,
  2,
  8,
  11,
  0,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  1,
  9,
  0,
  2,
  3,
  11,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  1,
  11,
  2,
  1,
  9,
  11,
  9,
  8,
  11,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  3,
  10,
  1,
  11,
  10,
  3,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  0,
  10,
  1,
  0,
  8,
  10,
  8,
  11,
  10,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  3,
  9,
  0,
  3,
  11,
  9,
  11,
  10,
  9,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  9,
  8,
  10,
  10,
  8,
  11,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  4,
  7,
  8,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  4,
  3,
  0,
  7,
  3,
  4,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  0,
  1,
  9,
  8,
  4,
  7,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  4,
  1,
  9,
  4,
  7,
  1,
  7,
  3,
  1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  1,
  2,
  10,
  8,
  4,
  7,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  3,
  4,
  7,
  3,
  0,
  4,
  1,
  2,
  10,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  9,
  2,
  10,
  9,
  0,
  2,
  8,
  4,
  7,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  2,
  10,
  9,
  2,
  9,
  7,
  2,
  7,
  3,
  7,
  9,
  4,
  -1,
  -1,
  -1,
  -1,
  8,
  4,
  7,
  3,
  11,
  2,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  11,
  4,
  7,
  11,
  2,
  4,
  2,
  0,
  4,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  9,
  0,
  1,
  8,
  4,
  7,
  2,
  3,
  11,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  4,
  7,
  11,
  9,
  4,
  11,
  9,
  11,
  2,
  9,
  2,
  1,
  -1,
  -1,
  -1,
  -1,
  3,
  10,
  1,
  3,
  11,
  10,
  7,
  8,
  4,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  1,
  11,
  10,
  1,
  4,
  11,
  1,
  0,
  4,
  7,
  11,
  4,
  -1,
  -1,
  -1,
  -1,
  4,
  7,
  8,
  9,
  0,
  11,
  9,
  11,
  10,
  11,
  0,
  3,
  -1,
  -1,
  -1,
  -1,
  4,
  7,
  11,
  4,
  11,
  9,
  9,
  11,
  10,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  9,
  5,
  4,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  9,
  5,
  4,
  0,
  8,
  3,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  0,
  5,
  4,
  1,
  5,
  0,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  8,
  5,
  4,
  8,
  3,
  5,
  3,
  1,
  5,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  1,
  2,
  10,
  9,
  5,
  4,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  3,
  0,
  8,
  1,
  2,
  10,
  4,
  9,
  5,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  5,
  2,
  10,
  5,
  4,
  2,
  4,
  0,
  2,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  2,
  10,
  5,
  3,
  2,
  5,
  3,
  5,
  4,
  3,
  4,
  8,
  -1,
  -1,
  -1,
  -1,
  9,
  5,
  4,
  2,
  3,
  11,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  0,
  11,
  2,
  0,
  8,
  11,
  4,
  9,
  5,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  0,
  5,
  4,
  0,
  1,
  5,
  2,
  3,
  11,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  2,
  1,
  5,
  2,
  5,
  8,
  2,
  8,
  11,
  4,
  8,
  5,
  -1,
  -1,
  -1,
  -1,
  10,
  3,
  11,
  10,
  1,
  3,
  9,
  5,
  4,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  4,
  9,
  5,
  0,
  8,
  1,
  8,
  10,
  1,
  8,
  11,
  10,
  -1,
  -1,
  -1,
  -1,
  5,
  4,
  0,
  5,
  0,
  11,
  5,
  11,
  10,
  11,
  0,
  3,
  -1,
  -1,
  -1,
  -1,
  5,
  4,
  8,
  5,
  8,
  10,
  10,
  8,
  11,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  9,
  7,
  8,
  5,
  7,
  9,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  9,
  3,
  0,
  9,
  5,
  3,
  5,
  7,
  3,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  0,
  7,
  8,
  0,
  1,
  7,
  1,
  5,
  7,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  1,
  5,
  3,
  3,
  5,
  7,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  9,
  7,
  8,
  9,
  5,
  7,
  10,
  1,
  2,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  10,
  1,
  2,
  9,
  5,
  0,
  5,
  3,
  0,
  5,
  7,
  3,
  -1,
  -1,
  -1,
  -1,
  8,
  0,
  2,
  8,
  2,
  5,
  8,
  5,
  7,
  10,
  5,
  2,
  -1,
  -1,
  -1,
  -1,
  2,
  10,
  5,
  2,
  5,
  3,
  3,
  5,
  7,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  7,
  9,
  5,
  7,
  8,
  9,
  3,
  11,
  2,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  9,
  5,
  7,
  9,
  7,
  2,
  9,
  2,
  0,
  2,
  7,
  11,
  -1,
  -1,
  -1,
  -1,
  2,
  3,
  11,
  0,
  1,
  8,
  1,
  7,
  8,
  1,
  5,
  7,
  -1,
  -1,
  -1,
  -1,
  11,
  2,
  1,
  11,
  1,
  7,
  7,
  1,
  5,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  9,
  5,
  8,
  8,
  5,
  7,
  10,
  1,
  3,
  10,
  3,
  11,
  -1,
  -1,
  -1,
  -1,
  5,
  7,
  0,
  5,
  0,
  9,
  7,
  11,
  0,
  1,
  0,
  10,
  11,
  10,
  0,
  -1,
  11,
  10,
  0,
  11,
  0,
  3,
  10,
  5,
  0,
  8,
  0,
  7,
  5,
  7,
  0,
  -1,
  11,
  10,
  5,
  7,
  11,
  5,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  10,
  6,
  5,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  0,
  8,
  3,
  5,
  10,
  6,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  9,
  0,
  1,
  5,
  10,
  6,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  1,
  8,
  3,
  1,
  9,
  8,
  5,
  10,
  6,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  1,
  6,
  5,
  2,
  6,
  1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  1,
  6,
  5,
  1,
  2,
  6,
  3,
  0,
  8,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  9,
  6,
  5,
  9,
  0,
  6,
  0,
  2,
  6,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  5,
  9,
  8,
  5,
  8,
  2,
  5,
  2,
  6,
  3,
  2,
  8,
  -1,
  -1,
  -1,
  -1,
  2,
  3,
  11,
  10,
  6,
  5,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  11,
  0,
  8,
  11,
  2,
  0,
  10,
  6,
  5,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  0,
  1,
  9,
  2,
  3,
  11,
  5,
  10,
  6,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  5,
  10,
  6,
  1,
  9,
  2,
  9,
  11,
  2,
  9,
  8,
  11,
  -1,
  -1,
  -1,
  -1,
  6,
  3,
  11,
  6,
  5,
  3,
  5,
  1,
  3,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  0,
  8,
  11,
  0,
  11,
  5,
  0,
  5,
  1,
  5,
  11,
  6,
  -1,
  -1,
  -1,
  -1,
  3,
  11,
  6,
  0,
  3,
  6,
  0,
  6,
  5,
  0,
  5,
  9,
  -1,
  -1,
  -1,
  -1,
  6,
  5,
  9,
  6,
  9,
  11,
  11,
  9,
  8,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  5,
  10,
  6,
  4,
  7,
  8,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  4,
  3,
  0,
  4,
  7,
  3,
  6,
  5,
  10,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  1,
  9,
  0,
  5,
  10,
  6,
  8,
  4,
  7,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  10,
  6,
  5,
  1,
  9,
  7,
  1,
  7,
  3,
  7,
  9,
  4,
  -1,
  -1,
  -1,
  -1,
  6,
  1,
  2,
  6,
  5,
  1,
  4,
  7,
  8,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  1,
  2,
  5,
  5,
  2,
  6,
  3,
  0,
  4,
  3,
  4,
  7,
  -1,
  -1,
  -1,
  -1,
  8,
  4,
  7,
  9,
  0,
  5,
  0,
  6,
  5,
  0,
  2,
  6,
  -1,
  -1,
  -1,
  -1,
  7,
  3,
  9,
  7,
  9,
  4,
  3,
  2,
  9,
  5,
  9,
  6,
  2,
  6,
  9,
  -1,
  3,
  11,
  2,
  7,
  8,
  4,
  10,
  6,
  5,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  5,
  10,
  6,
  4,
  7,
  2,
  4,
  2,
  0,
  2,
  7,
  11,
  -1,
  -1,
  -1,
  -1,
  0,
  1,
  9,
  4,
  7,
  8,
  2,
  3,
  11,
  5,
  10,
  6,
  -1,
  -1,
  -1,
  -1,
  9,
  2,
  1,
  9,
  11,
  2,
  9,
  4,
  11,
  7,
  11,
  4,
  5,
  10,
  6,
  -1,
  8,
  4,
  7,
  3,
  11,
  5,
  3,
  5,
  1,
  5,
  11,
  6,
  -1,
  -1,
  -1,
  -1,
  5,
  1,
  11,
  5,
  11,
  6,
  1,
  0,
  11,
  7,
  11,
  4,
  0,
  4,
  11,
  -1,
  0,
  5,
  9,
  0,
  6,
  5,
  0,
  3,
  6,
  11,
  6,
  3,
  8,
  4,
  7,
  -1,
  6,
  5,
  9,
  6,
  9,
  11,
  4,
  7,
  9,
  7,
  11,
  9,
  -1,
  -1,
  -1,
  -1,
  10,
  4,
  9,
  6,
  4,
  10,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  4,
  10,
  6,
  4,
  9,
  10,
  0,
  8,
  3,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  10,
  0,
  1,
  10,
  6,
  0,
  6,
  4,
  0,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  8,
  3,
  1,
  8,
  1,
  6,
  8,
  6,
  4,
  6,
  1,
  10,
  -1,
  -1,
  -1,
  -1,
  1,
  4,
  9,
  1,
  2,
  4,
  2,
  6,
  4,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  3,
  0,
  8,
  1,
  2,
  9,
  2,
  4,
  9,
  2,
  6,
  4,
  -1,
  -1,
  -1,
  -1,
  0,
  2,
  4,
  4,
  2,
  6,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  8,
  3,
  2,
  8,
  2,
  4,
  4,
  2,
  6,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  10,
  4,
  9,
  10,
  6,
  4,
  11,
  2,
  3,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  0,
  8,
  2,
  2,
  8,
  11,
  4,
  9,
  10,
  4,
  10,
  6,
  -1,
  -1,
  -1,
  -1,
  3,
  11,
  2,
  0,
  1,
  6,
  0,
  6,
  4,
  6,
  1,
  10,
  -1,
  -1,
  -1,
  -1,
  6,
  4,
  1,
  6,
  1,
  10,
  4,
  8,
  1,
  2,
  1,
  11,
  8,
  11,
  1,
  -1,
  9,
  6,
  4,
  9,
  3,
  6,
  9,
  1,
  3,
  11,
  6,
  3,
  -1,
  -1,
  -1,
  -1,
  8,
  11,
  1,
  8,
  1,
  0,
  11,
  6,
  1,
  9,
  1,
  4,
  6,
  4,
  1,
  -1,
  3,
  11,
  6,
  3,
  6,
  0,
  0,
  6,
  4,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  6,
  4,
  8,
  11,
  6,
  8,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  7,
  10,
  6,
  7,
  8,
  10,
  8,
  9,
  10,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  0,
  7,
  3,
  0,
  10,
  7,
  0,
  9,
  10,
  6,
  7,
  10,
  -1,
  -1,
  -1,
  -1,
  10,
  6,
  7,
  1,
  10,
  7,
  1,
  7,
  8,
  1,
  8,
  0,
  -1,
  -1,
  -1,
  -1,
  10,
  6,
  7,
  10,
  7,
  1,
  1,
  7,
  3,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  1,
  2,
  6,
  1,
  6,
  8,
  1,
  8,
  9,
  8,
  6,
  7,
  -1,
  -1,
  -1,
  -1,
  2,
  6,
  9,
  2,
  9,
  1,
  6,
  7,
  9,
  0,
  9,
  3,
  7,
  3,
  9,
  -1,
  7,
  8,
  0,
  7,
  0,
  6,
  6,
  0,
  2,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  7,
  3,
  2,
  6,
  7,
  2,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  2,
  3,
  11,
  10,
  6,
  8,
  10,
  8,
  9,
  8,
  6,
  7,
  -1,
  -1,
  -1,
  -1,
  2,
  0,
  7,
  2,
  7,
  11,
  0,
  9,
  7,
  6,
  7,
  10,
  9,
  10,
  7,
  -1,
  1,
  8,
  0,
  1,
  7,
  8,
  1,
  10,
  7,
  6,
  7,
  10,
  2,
  3,
  11,
  -1,
  11,
  2,
  1,
  11,
  1,
  7,
  10,
  6,
  1,
  6,
  7,
  1,
  -1,
  -1,
  -1,
  -1,
  8,
  9,
  6,
  8,
  6,
  7,
  9,
  1,
  6,
  11,
  6,
  3,
  1,
  3,
  6,
  -1,
  0,
  9,
  1,
  11,
  6,
  7,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  7,
  8,
  0,
  7,
  0,
  6,
  3,
  11,
  0,
  11,
  6,
  0,
  -1,
  -1,
  -1,
  -1,
  7,
  11,
  6,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  7,
  6,
  11,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  3,
  0,
  8,
  11,
  7,
  6,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  0,
  1,
  9,
  11,
  7,
  6,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  8,
  1,
  9,
  8,
  3,
  1,
  11,
  7,
  6,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  10,
  1,
  2,
  6,
  11,
  7,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  1,
  2,
  10,
  3,
  0,
  8,
  6,
  11,
  7,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  2,
  9,
  0,
  2,
  10,
  9,
  6,
  11,
  7,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  6,
  11,
  7,
  2,
  10,
  3,
  10,
  8,
  3,
  10,
  9,
  8,
  -1,
  -1,
  -1,
  -1,
  7,
  2,
  3,
  6,
  2,
  7,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  7,
  0,
  8,
  7,
  6,
  0,
  6,
  2,
  0,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  2,
  7,
  6,
  2,
  3,
  7,
  0,
  1,
  9,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  1,
  6,
  2,
  1,
  8,
  6,
  1,
  9,
  8,
  8,
  7,
  6,
  -1,
  -1,
  -1,
  -1,
  10,
  7,
  6,
  10,
  1,
  7,
  1,
  3,
  7,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  10,
  7,
  6,
  1,
  7,
  10,
  1,
  8,
  7,
  1,
  0,
  8,
  -1,
  -1,
  -1,
  -1,
  0,
  3,
  7,
  0,
  7,
  10,
  0,
  10,
  9,
  6,
  10,
  7,
  -1,
  -1,
  -1,
  -1,
  7,
  6,
  10,
  7,
  10,
  8,
  8,
  10,
  9,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  6,
  8,
  4,
  11,
  8,
  6,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  3,
  6,
  11,
  3,
  0,
  6,
  0,
  4,
  6,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  8,
  6,
  11,
  8,
  4,
  6,
  9,
  0,
  1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  9,
  4,
  6,
  9,
  6,
  3,
  9,
  3,
  1,
  11,
  3,
  6,
  -1,
  -1,
  -1,
  -1,
  6,
  8,
  4,
  6,
  11,
  8,
  2,
  10,
  1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  1,
  2,
  10,
  3,
  0,
  11,
  0,
  6,
  11,
  0,
  4,
  6,
  -1,
  -1,
  -1,
  -1,
  4,
  11,
  8,
  4,
  6,
  11,
  0,
  2,
  9,
  2,
  10,
  9,
  -1,
  -1,
  -1,
  -1,
  10,
  9,
  3,
  10,
  3,
  2,
  9,
  4,
  3,
  11,
  3,
  6,
  4,
  6,
  3,
  -1,
  8,
  2,
  3,
  8,
  4,
  2,
  4,
  6,
  2,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  0,
  4,
  2,
  4,
  6,
  2,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  1,
  9,
  0,
  2,
  3,
  4,
  2,
  4,
  6,
  4,
  3,
  8,
  -1,
  -1,
  -1,
  -1,
  1,
  9,
  4,
  1,
  4,
  2,
  2,
  4,
  6,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  8,
  1,
  3,
  8,
  6,
  1,
  8,
  4,
  6,
  6,
  10,
  1,
  -1,
  -1,
  -1,
  -1,
  10,
  1,
  0,
  10,
  0,
  6,
  6,
  0,
  4,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  4,
  6,
  3,
  4,
  3,
  8,
  6,
  10,
  3,
  0,
  3,
  9,
  10,
  9,
  3,
  -1,
  10,
  9,
  4,
  6,
  10,
  4,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  4,
  9,
  5,
  7,
  6,
  11,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  0,
  8,
  3,
  4,
  9,
  5,
  11,
  7,
  6,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  5,
  0,
  1,
  5,
  4,
  0,
  7,
  6,
  11,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  11,
  7,
  6,
  8,
  3,
  4,
  3,
  5,
  4,
  3,
  1,
  5,
  -1,
  -1,
  -1,
  -1,
  9,
  5,
  4,
  10,
  1,
  2,
  7,
  6,
  11,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  6,
  11,
  7,
  1,
  2,
  10,
  0,
  8,
  3,
  4,
  9,
  5,
  -1,
  -1,
  -1,
  -1,
  7,
  6,
  11,
  5,
  4,
  10,
  4,
  2,
  10,
  4,
  0,
  2,
  -1,
  -1,
  -1,
  -1,
  3,
  4,
  8,
  3,
  5,
  4,
  3,
  2,
  5,
  10,
  5,
  2,
  11,
  7,
  6,
  -1,
  7,
  2,
  3,
  7,
  6,
  2,
  5,
  4,
  9,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  9,
  5,
  4,
  0,
  8,
  6,
  0,
  6,
  2,
  6,
  8,
  7,
  -1,
  -1,
  -1,
  -1,
  3,
  6,
  2,
  3,
  7,
  6,
  1,
  5,
  0,
  5,
  4,
  0,
  -1,
  -1,
  -1,
  -1,
  6,
  2,
  8,
  6,
  8,
  7,
  2,
  1,
  8,
  4,
  8,
  5,
  1,
  5,
  8,
  -1,
  9,
  5,
  4,
  10,
  1,
  6,
  1,
  7,
  6,
  1,
  3,
  7,
  -1,
  -1,
  -1,
  -1,
  1,
  6,
  10,
  1,
  7,
  6,
  1,
  0,
  7,
  8,
  7,
  0,
  9,
  5,
  4,
  -1,
  4,
  0,
  10,
  4,
  10,
  5,
  0,
  3,
  10,
  6,
  10,
  7,
  3,
  7,
  10,
  -1,
  7,
  6,
  10,
  7,
  10,
  8,
  5,
  4,
  10,
  4,
  8,
  10,
  -1,
  -1,
  -1,
  -1,
  6,
  9,
  5,
  6,
  11,
  9,
  11,
  8,
  9,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  3,
  6,
  11,
  0,
  6,
  3,
  0,
  5,
  6,
  0,
  9,
  5,
  -1,
  -1,
  -1,
  -1,
  0,
  11,
  8,
  0,
  5,
  11,
  0,
  1,
  5,
  5,
  6,
  11,
  -1,
  -1,
  -1,
  -1,
  6,
  11,
  3,
  6,
  3,
  5,
  5,
  3,
  1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  1,
  2,
  10,
  9,
  5,
  11,
  9,
  11,
  8,
  11,
  5,
  6,
  -1,
  -1,
  -1,
  -1,
  0,
  11,
  3,
  0,
  6,
  11,
  0,
  9,
  6,
  5,
  6,
  9,
  1,
  2,
  10,
  -1,
  11,
  8,
  5,
  11,
  5,
  6,
  8,
  0,
  5,
  10,
  5,
  2,
  0,
  2,
  5,
  -1,
  6,
  11,
  3,
  6,
  3,
  5,
  2,
  10,
  3,
  10,
  5,
  3,
  -1,
  -1,
  -1,
  -1,
  5,
  8,
  9,
  5,
  2,
  8,
  5,
  6,
  2,
  3,
  8,
  2,
  -1,
  -1,
  -1,
  -1,
  9,
  5,
  6,
  9,
  6,
  0,
  0,
  6,
  2,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  1,
  5,
  8,
  1,
  8,
  0,
  5,
  6,
  8,
  3,
  8,
  2,
  6,
  2,
  8,
  -1,
  1,
  5,
  6,
  2,
  1,
  6,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  1,
  3,
  6,
  1,
  6,
  10,
  3,
  8,
  6,
  5,
  6,
  9,
  8,
  9,
  6,
  -1,
  10,
  1,
  0,
  10,
  0,
  6,
  9,
  5,
  0,
  5,
  6,
  0,
  -1,
  -1,
  -1,
  -1,
  0,
  3,
  8,
  5,
  6,
  10,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  10,
  5,
  6,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  11,
  5,
  10,
  7,
  5,
  11,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  11,
  5,
  10,
  11,
  7,
  5,
  8,
  3,
  0,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  5,
  11,
  7,
  5,
  10,
  11,
  1,
  9,
  0,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  10,
  7,
  5,
  10,
  11,
  7,
  9,
  8,
  1,
  8,
  3,
  1,
  -1,
  -1,
  -1,
  -1,
  11,
  1,
  2,
  11,
  7,
  1,
  7,
  5,
  1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  0,
  8,
  3,
  1,
  2,
  7,
  1,
  7,
  5,
  7,
  2,
  11,
  -1,
  -1,
  -1,
  -1,
  9,
  7,
  5,
  9,
  2,
  7,
  9,
  0,
  2,
  2,
  11,
  7,
  -1,
  -1,
  -1,
  -1,
  7,
  5,
  2,
  7,
  2,
  11,
  5,
  9,
  2,
  3,
  2,
  8,
  9,
  8,
  2,
  -1,
  2,
  5,
  10,
  2,
  3,
  5,
  3,
  7,
  5,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  8,
  2,
  0,
  8,
  5,
  2,
  8,
  7,
  5,
  10,
  2,
  5,
  -1,
  -1,
  -1,
  -1,
  9,
  0,
  1,
  5,
  10,
  3,
  5,
  3,
  7,
  3,
  10,
  2,
  -1,
  -1,
  -1,
  -1,
  9,
  8,
  2,
  9,
  2,
  1,
  8,
  7,
  2,
  10,
  2,
  5,
  7,
  5,
  2,
  -1,
  1,
  3,
  5,
  3,
  7,
  5,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  0,
  8,
  7,
  0,
  7,
  1,
  1,
  7,
  5,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  9,
  0,
  3,
  9,
  3,
  5,
  5,
  3,
  7,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  9,
  8,
  7,
  5,
  9,
  7,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  5,
  8,
  4,
  5,
  10,
  8,
  10,
  11,
  8,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  5,
  0,
  4,
  5,
  11,
  0,
  5,
  10,
  11,
  11,
  3,
  0,
  -1,
  -1,
  -1,
  -1,
  0,
  1,
  9,
  8,
  4,
  10,
  8,
  10,
  11,
  10,
  4,
  5,
  -1,
  -1,
  -1,
  -1,
  10,
  11,
  4,
  10,
  4,
  5,
  11,
  3,
  4,
  9,
  4,
  1,
  3,
  1,
  4,
  -1,
  2,
  5,
  1,
  2,
  8,
  5,
  2,
  11,
  8,
  4,
  5,
  8,
  -1,
  -1,
  -1,
  -1,
  0,
  4,
  11,
  0,
  11,
  3,
  4,
  5,
  11,
  2,
  11,
  1,
  5,
  1,
  11,
  -1,
  0,
  2,
  5,
  0,
  5,
  9,
  2,
  11,
  5,
  4,
  5,
  8,
  11,
  8,
  5,
  -1,
  9,
  4,
  5,
  2,
  11,
  3,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  2,
  5,
  10,
  3,
  5,
  2,
  3,
  4,
  5,
  3,
  8,
  4,
  -1,
  -1,
  -1,
  -1,
  5,
  10,
  2,
  5,
  2,
  4,
  4,
  2,
  0,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  3,
  10,
  2,
  3,
  5,
  10,
  3,
  8,
  5,
  4,
  5,
  8,
  0,
  1,
  9,
  -1,
  5,
  10,
  2,
  5,
  2,
  4,
  1,
  9,
  2,
  9,
  4,
  2,
  -1,
  -1,
  -1,
  -1,
  8,
  4,
  5,
  8,
  5,
  3,
  3,
  5,
  1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  0,
  4,
  5,
  1,
  0,
  5,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  8,
  4,
  5,
  8,
  5,
  3,
  9,
  0,
  5,
  0,
  3,
  5,
  -1,
  -1,
  -1,
  -1,
  9,
  4,
  5,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  4,
  11,
  7,
  4,
  9,
  11,
  9,
  10,
  11,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  0,
  8,
  3,
  4,
  9,
  7,
  9,
  11,
  7,
  9,
  10,
  11,
  -1,
  -1,
  -1,
  -1,
  1,
  10,
  11,
  1,
  11,
  4,
  1,
  4,
  0,
  7,
  4,
  11,
  -1,
  -1,
  -1,
  -1,
  3,
  1,
  4,
  3,
  4,
  8,
  1,
  10,
  4,
  7,
  4,
  11,
  10,
  11,
  4,
  -1,
  4,
  11,
  7,
  9,
  11,
  4,
  9,
  2,
  11,
  9,
  1,
  2,
  -1,
  -1,
  -1,
  -1,
  9,
  7,
  4,
  9,
  11,
  7,
  9,
  1,
  11,
  2,
  11,
  1,
  0,
  8,
  3,
  -1,
  11,
  7,
  4,
  11,
  4,
  2,
  2,
  4,
  0,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  11,
  7,
  4,
  11,
  4,
  2,
  8,
  3,
  4,
  3,
  2,
  4,
  -1,
  -1,
  -1,
  -1,
  2,
  9,
  10,
  2,
  7,
  9,
  2,
  3,
  7,
  7,
  4,
  9,
  -1,
  -1,
  -1,
  -1,
  9,
  10,
  7,
  9,
  7,
  4,
  10,
  2,
  7,
  8,
  7,
  0,
  2,
  0,
  7,
  -1,
  3,
  7,
  10,
  3,
  10,
  2,
  7,
  4,
  10,
  1,
  10,
  0,
  4,
  0,
  10,
  -1,
  1,
  10,
  2,
  8,
  7,
  4,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  4,
  9,
  1,
  4,
  1,
  7,
  7,
  1,
  3,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  4,
  9,
  1,
  4,
  1,
  7,
  0,
  8,
  1,
  8,
  7,
  1,
  -1,
  -1,
  -1,
  -1,
  4,
  0,
  3,
  7,
  4,
  3,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  4,
  8,
  7,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  9,
  10,
  8,
  10,
  11,
  8,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  3,
  0,
  9,
  3,
  9,
  11,
  11,
  9,
  10,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  0,
  1,
  10,
  0,
  10,
  8,
  8,
  10,
  11,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  3,
  1,
  10,
  11,
  3,
  10,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  1,
  2,
  11,
  1,
  11,
  9,
  9,
  11,
  8,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  3,
  0,
  9,
  3,
  9,
  11,
  1,
  2,
  9,
  2,
  11,
  9,
  -1,
  -1,
  -1,
  -1,
  0,
  2,
  11,
  8,
  0,
  11,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  3,
  2,
  11,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  2,
  3,
  8,
  2,
  8,
  10,
  10,
  8,
  9,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  9,
  10,
  2,
  0,
  9,
  2,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  2,
  3,
  8,
  2,
  8,
  10,
  0,
  1,
  8,
  1,
  10,
  8,
  -1,
  -1,
  -1,
  -1,
  1,
  10,
  2,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  1,
  3,
  8,
  9,
  1,
  8,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  0,
  9,
  1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  0,
  3,
  8,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1
]);


;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/operations/sop/Metaball.ts








const pos = new three_module.Vector3();
const Metaball_points = [];
class MetaballSopOperation extends operations_sop_Base/* BaseSopOperation */.U {
  static type() {
    return "metaball";
  }
  cook(inputContents, params) {
    var _a;
    const inputCoreGroup = inputContents[0];
    try {
      const geometry = this._createMetaballsGeometry(inputCoreGroup, params);
      return this.createCoreGroupFromGeometry(geometry);
    } catch (err) {
      (_a = this.states) == null ? void 0 : _a.error.set(`failed to create metaballs, possibly a memory issue`);
      console.error("metaballs failed");
      return this.createCoreGroupFromObjects([]);
    }
  }
  _createMetaballsGeometry(inputCoreGroup, params) {
    const metaballs = new MarchingCubes(
      params.resolution,
      // CoreConstant.MATERIALS[ObjectType.MESH],
      params.enableUVs,
      params.enableColors
    );
    metaballs.isolation = params.isolation;
    inputCoreGroup.points(Metaball_points);
    for (const point of Metaball_points) {
      point.position(pos);
      pos.multiplyScalar(0.5).addScalar(0.5);
      let metaStrength = params.metaStrength;
      if ((0,Type/* isBooleanTrue */.bI)(params.useMetaStrengthAttrib)) {
        let metaStrengthAttrib = point.attribValue("metaStrength");
        if (Type/* CoreType.isNumber */.MR.isNumber(metaStrengthAttrib)) {
          metaStrength *= metaStrengthAttrib;
        }
      }
      let metaSubtract = params.metaSubtract;
      if ((0,Type/* isBooleanTrue */.bI)(params.useMetaSubtractAttrib)) {
        let metaSubtractAttrib = point.attribValue("metaSubtract");
        if (Type/* CoreType.isNumber */.MR.isNumber(metaSubtractAttrib)) {
          metaSubtract *= metaSubtractAttrib;
        }
      }
      metaballs.addBall(pos.x, pos.y, pos.z, metaStrength, metaSubtract, void 0);
    }
    metaballs.createPolygons();
    const geometry = new three_module.BufferGeometry();
    const attribNames = Object.keys(metaballs.attributes);
    for (let attribName of attribNames) {
      const attrib = metaballs.attributes[attribName];
      geometry.setAttribute(attribName, attrib);
    }
    return geometry;
  }
}
MetaballSopOperation.DEFAULT_PARAMS = {
  resolution: 40,
  isolation: 30,
  useMetaStrengthAttrib: false,
  metaStrength: 0.1,
  useMetaSubtractAttrib: false,
  metaSubtract: 1,
  enableUVs: false,
  enableColors: false
};
MetaballSopOperation.INPUT_CLONED_STATE = InputCloneMode/* InputCloneMode.NEVER */.m.NEVER;

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/sop/Metaball.ts




const Metaball_DEFAULT = MetaballSopOperation.DEFAULT_PARAMS;
class MetaballSopParamsConfig extends params_ParamsConfig/* NodeParamsConfig */.yI {
  constructor() {
    super(...arguments);
    /** @param resolution */
    this.resolution = params_ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(Metaball_DEFAULT.resolution, {
      range: [0, 100],
      rangeLocked: [true, false]
    });
    /** @param isolation */
    this.isolation = params_ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(Metaball_DEFAULT.isolation, {
      range: [0, 100],
      rangeLocked: [true, false]
    });
    /** @param useMetaStrengthAttrib */
    this.useMetaStrengthAttrib = params_ParamsConfig/* ParamConfig.BOOLEAN */.XC.BOOLEAN(Metaball_DEFAULT.useMetaStrengthAttrib);
    /** @param metaStrength */
    this.metaStrength = params_ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(Metaball_DEFAULT.metaStrength, {
      range: [0, 1],
      rangeLocked: [true, false]
    });
    /** @param useMetaSubtractAttrib */
    this.useMetaSubtractAttrib = params_ParamsConfig/* ParamConfig.BOOLEAN */.XC.BOOLEAN(Metaball_DEFAULT.useMetaSubtractAttrib);
    /** @param metaStrength */
    this.metaSubtract = params_ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(Metaball_DEFAULT.metaSubtract, {
      range: [0, 10],
      rangeLocked: [true, false]
    });
    /** @param enableUVs */
    this.enableUVs = params_ParamsConfig/* ParamConfig.BOOLEAN */.XC.BOOLEAN(Metaball_DEFAULT.enableUVs);
    /** @param enableColors */
    this.enableColors = params_ParamsConfig/* ParamConfig.BOOLEAN */.XC.BOOLEAN(Metaball_DEFAULT.enableColors);
  }
}
const Metaball_ParamsConfig = new MetaballSopParamsConfig();
class MetaballSopNode extends sop_Base/* TypedSopNode */.x {
  constructor() {
    super(...arguments);
    this.paramsConfig = Metaball_ParamsConfig;
  }
  static type() {
    return "metaball";
  }
  initializeNode() {
    this.io.inputs.setCount(1);
    this.io.inputs.initInputsClonedState(MetaballSopOperation.INPUT_CLONED_STATE);
  }
  cook(input_contents) {
    this._operation = this._operation || new MetaballSopOperation(this._scene, this.states, this);
    const core_group = this._operation.cook(input_contents, this.pv);
    this.setCoreGroup(core_group);
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/core/geometry/util/HierarchyRemoved.ts

function withChildrenRemoved(object, callback) {
  const children = object.children;
  for (const child of children) {
    object.remove(child);
  }
  const result = callback();
  for (const child of children) {
    object.add(child);
  }
  return result;
}

// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/core/geometry/GeometryUtils.ts
var GeometryUtils = __webpack_require__(31170);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/core/geometry/modules/three/ThreejsCoreObject.ts + 1 modules
var ThreejsCoreObject = __webpack_require__(2318);
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/core/geometry/util/MeshInverse.ts

function meshInverse(mesh) {
  const index = mesh.geometry.getIndex();
  if (!index) {
    return;
  }
  const facesCount = index.count / 3;
  const array = index.array;
  for (let i = 0; i < facesCount; i++) {
    const a = array[i * 3];
    const b = array[i * 3 + 1];
    const c = array[i * 3 + 2];
    array[i * 3] = c;
    array[i * 3 + 1] = b;
    array[i * 3 + 2] = a;
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/operations/sop/Mirror.ts










const _axis = new three_module.Vector3();
const Mirror_pos = new three_module.Vector3();
const _projectedPos = new three_module.Vector3();
const _delta = new three_module.Vector3();
const Mirror_plane = new three_module.Plane();
class MirrorSopOperation extends operations_sop_Base/* BaseSopOperation */.U {
  static type() {
    return Sop/* SopType.MIRROR */.aB.MIRROR;
  }
  cook(inputCoreGroups, params) {
    const coreGroup = inputCoreGroups[0];
    const newObjects = coreGroup.allObjects();
    const objects = Mask/* CoreMask.filterThreejsObjects */.x0.filterThreejsObjects(coreGroup, {
      group: params.group
    }).filter(GeometryUtils/* object3DHasGeometry */.I_);
    _axis.copy(params.axis).normalize();
    Mirror_plane.constant = -params.center.dot(_axis);
    Mirror_plane.normal.copy(_axis);
    for (const object of objects) {
      this._applyOrCreateMirrorObject(object, Mirror_plane, params, newObjects);
    }
    return this.createCoreGroupFromObjects(newObjects);
  }
  _applyOrCreateMirrorObject(object, plane, params, newObjects) {
    if (params.preserveInput) {
      const clonedObject = withChildrenRemoved(object, () => ThreejsCoreObject/* ThreejsCoreObject.clone */.W.clone(object));
      this._mirrorObject(clonedObject, plane);
      if (clonedObject) {
        if (object.parent) {
          object.parent.add(clonedObject);
        } else {
          newObjects.push(clonedObject);
        }
      }
    } else {
      this._mirrorObject(object, plane);
    }
  }
  _mirrorObject(object, plane) {
    const geometry = object.geometry;
    if (!geometry) {
      return;
    }
    const position = geometry.getAttribute("position");
    const pointsCount = position.count;
    const positions = position.array;
    for (let i = 0; i < pointsCount; i++) {
      Mirror_pos.fromArray(positions, i * 3);
      plane.projectPoint(Mirror_pos, _projectedPos);
      _delta.copy(Mirror_pos).sub(_projectedPos);
      _projectedPos.sub(_delta);
      _projectedPos.toArray(positions, i * 3);
    }
    if (object.isMesh) {
      meshInverse(object);
    }
  }
}
MirrorSopOperation.DEFAULT_PARAMS = {
  group: "*",
  axis: new three_module.Vector3(1, 0, 0),
  center: new three_module.Vector3(0, 0, 0),
  preserveInput: true
};
MirrorSopOperation.INPUT_CLONED_STATE = InputCloneMode/* InputCloneMode.FROM_NODE */.m.FROM_NODE;

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/sop/Mirror.ts





const Mirror_DEFAULT = MirrorSopOperation.DEFAULT_PARAMS;
class MirrorSopParamConfig extends params_ParamsConfig/* NodeParamsConfig */.yI {
  constructor() {
    super(...arguments);
    /** @param group to assign the material to */
    this.group = params_ParamsConfig/* ParamConfig.STRING */.XC.STRING(Mirror_DEFAULT.group, {
      objectMask: true
    });
    /** @param axis */
    this.axis = params_ParamsConfig/* ParamConfig.VECTOR3 */.XC.VECTOR3(Mirror_DEFAULT.axis);
    /** @param center */
    this.center = params_ParamsConfig/* ParamConfig.VECTOR3 */.XC.VECTOR3(Mirror_DEFAULT.center);
    /** @param preserve input */
    this.preserveInput = params_ParamsConfig/* ParamConfig.BOOLEAN */.XC.BOOLEAN(Mirror_DEFAULT.preserveInput);
  }
}
const Mirror_ParamsConfig = new MirrorSopParamConfig();
class MirrorSopNode extends sop_Base/* TypedSopNode */.x {
  constructor() {
    super(...arguments);
    this.paramsConfig = Mirror_ParamsConfig;
  }
  static type() {
    return Sop/* SopType.MIRROR */.aB.MIRROR;
  }
  initializeNode() {
    this.io.inputs.setCount(1);
    this.io.inputs.initInputsClonedState(MirrorSopOperation.INPUT_CLONED_STATE);
  }
  cook(inputCoreGroups) {
    this._operation = this._operation || new MirrorSopOperation(this.scene(), this.states, this);
    const coreGroup = this._operation.cook(inputCoreGroups, this.pv);
    this.setCoreGroup(coreGroup);
  }
}

// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/nodes/sop/Noise.ts
var sop_Noise = __webpack_require__(72613);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/nodes/sop/Normals.ts
var Normals = __webpack_require__(52753);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/node_modules/three/examples/jsm/helpers/VertexNormalsHelper.js
var VertexNormalsHelper = __webpack_require__(32280);
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/sop/NormalsHelper.ts









class NormalsHelperSopParamsConfig extends params_ParamsConfig/* NodeParamsConfig */.yI {
  constructor() {
    super(...arguments);
    /** @param group to assign the material to */
    this.group = params_ParamsConfig/* ParamConfig.STRING */.XC.STRING("", {
      objectMask: true
    });
    /** @param keep input */
    this.keepInput = params_ParamsConfig/* ParamConfig.BOOLEAN */.XC.BOOLEAN(1);
    /** @param size of the box */
    this.size = params_ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(1, {
      range: [0, 1],
      rangeLocked: [false, false]
    });
  }
}
const NormalsHelper_ParamsConfig = new NormalsHelperSopParamsConfig();
class NormalsHelperSopNode extends sop_Base/* TypedSopNode */.x {
  constructor() {
    super(...arguments);
    this.paramsConfig = NormalsHelper_ParamsConfig;
  }
  static type() {
    return Sop/* SopType.NORMALS_HELPER */.aB.NORMALS_HELPER;
  }
  initializeNode() {
    this.io.outputs.setHasNoOutput();
    this.io.inputs.setCount(1);
    this.io.inputs.initInputsClonedState(InputCloneMode/* InputCloneMode.NEVER */.m.NEVER);
  }
  cook(inputCoreGroups) {
    const inputCoreGroup = inputCoreGroups[0];
    const selectedObjects = Mask/* CoreMask.filterThreejsObjects */.x0.filterThreejsObjects(inputCoreGroup, this.pv).filter(GeometryUtils/* object3DHasGeometry */.I_);
    const newObjects = [];
    for (const object of selectedObjects) {
      const helper = new VertexNormalsHelper/* VertexNormalsHelper */.M(object, this.pv.size);
      if ((0,Type/* isBooleanTrue */.bI)(this.pv.keepInput)) {
        newObjects.push(object);
      }
      newObjects.push(helper);
    }
    this.setObjects(newObjects);
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/operations/sop/Null.ts



class NullSopOperation extends operations_sop_Base/* BaseSopOperation */.U {
  static type() {
    return "null";
  }
  cook(input_contents, params) {
    const core_group = input_contents[0];
    if (core_group) {
      return core_group;
    } else {
      return this.createCoreGroupFromObjects([]);
    }
  }
  convertExportParamData(options) {
  }
}
NullSopOperation.DEFAULT_PARAMS = {};
NullSopOperation.INPUT_CLONED_STATE = InputCloneMode/* InputCloneMode.FROM_NODE */.m.FROM_NODE;

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/sop/Null.ts




class NullSopParamsConfig extends params_ParamsConfig/* NodeParamsConfig */.yI {
}
const sop_Null_ParamsConfig = new NullSopParamsConfig();
class NullSopNode extends sop_Base/* TypedSopNode */.x {
  constructor() {
    super(...arguments);
    this.paramsConfig = sop_Null_ParamsConfig;
  }
  static type() {
    return "null";
  }
  initializeNode() {
    this.io.inputs.setCount(0, 1);
    this.io.inputs.initInputsClonedState(NullSopOperation.INPUT_CLONED_STATE);
  }
  cook(input_contents) {
    this._operation = this._operation || new NullSopOperation(this.scene(), this.states, this);
    const core_group = this._operation.cook(input_contents, this.pv);
    this.setCoreGroup(core_group);
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/js/code/assemblers/objectBuilder/ObjectBuilderPersistedConfig.ts

var ObjectBuilderPersistedConfig_async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};



class ObjectBuilderPersistedConfig extends BasePersistedConfig/* BasePersistedConfig */.p {
  constructor(node) {
    super(node);
    this.node = node;
  }
  toData() {
    return ObjectBuilderPersistedConfig_async(this, null, function* () {
      yield this.node.compile();
      const assemblerController = this.node.assemblerController();
      if (!assemblerController) {
        return;
      }
      const functionData = this.node.functionData();
      if (!functionData) {
        return;
      }
      const { functionBody, variableNames, functionNames, paramConfigs } = functionData;
      const data = {
        functionBody,
        variableNames,
        variables: (0,_BaseJsPersistedConfig/* serializedVariablesFromFunctionData */.ve)(functionData),
        functionNames,
        serializedParamConfigs: paramConfigs.map((p) => p.toJSON())
      };
      return data;
    });
  }
  load(data) {
    const assemblerController = this.node.assemblerController();
    if (assemblerController) {
      return;
    }
    const { functionBody, variableNames, functionNames, serializedParamConfigs } = data;
    const functionData = {
      functionBody,
      variableNames,
      variablesByName: (0,_BaseJsPersistedConfig/* variablesByNameFromPersistedConfigData */.pw)(data),
      functionNames,
      functionsByName: (0,_BaseJsPersistedConfig/* functionsByNameFromPersistedConfigData */.Kg)(data, this.node),
      paramConfigs: serializedParamConfigs.map((json) => JsParamConfig/* JsParamConfig.fromJSON */.M.fromJSON(json))
    };
    this.node.updateFromFunctionData(functionData);
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/sop/ObjectBuilder.ts

var ObjectBuilder_async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};













const DUMMY = new three_module.Object3D();
class ObjectBuilderSopParamsConfig extends params_ParamsConfig/* NodeParamsConfig */.yI {
  constructor() {
    super(...arguments);
    /** @param group to assign the material to */
    this.group = params_ParamsConfig/* ParamConfig.STRING */.XC.STRING("", {
      objectMask: true
    });
  }
}
const ObjectBuilder_ParamsConfig = new ObjectBuilderSopParamsConfig();
class ObjectBuilderSopNode extends sop_Base/* TypedSopNode */.x {
  constructor() {
    super(...arguments);
    this.paramsConfig = ObjectBuilder_ParamsConfig;
    this.persisted_config = new ObjectBuilderPersistedConfig(this);
    this._assemblerController = this._createAssemblerController();
    this._childrenControllerContext = poly_NodeContext/* NodeContext.JS */.sy.JS;
    this._tmpParent = new three_module.Group();
    this._objectContainer = { Object3D: DUMMY, objnum: -1 };
    this._paramConfigs = [];
    this._functionCreationArgs = [];
    this._functionEvalArgs = [];
  }
  static type() {
    return Sop/* SopType.OBJECT_BUILDER */.aB.OBJECT_BUILDER;
  }
  assemblerController() {
    return this._assemblerController;
  }
  usedAssembler() {
    return _BaseRegister/* AssemblerName.JS_OBJECT_BUILDER */.Q.JS_OBJECT_BUILDER;
  }
  _createAssemblerController() {
    return Poly/* Poly.assemblersRegister.assembler */.L.assemblersRegister.assembler(this, this.usedAssembler());
  }
  createNode(node_class, options) {
    return super.createNode(node_class, options);
  }
  children() {
    return super.children();
  }
  nodesByType(type) {
    return super.nodesByType(type);
  }
  childrenAllowed() {
    if (this.assemblerController()) {
      return super.childrenAllowed();
    }
    return false;
  }
  sceneReadonly() {
    return this.assemblerController() == null;
  }
  initializeNode() {
    this.io.inputs.setCount(1);
    this.io.inputs.initInputsClonedState(InputCloneMode/* InputCloneMode.FROM_NODE */.m.FROM_NODE);
  }
  cook(inputCoreGroups) {
    return ObjectBuilder_async(this, null, function* () {
      const coreGroup = inputCoreGroups[0];
      this.compileIfRequired();
      const _func = this._function;
      if (_func) {
        const args = this.functionEvalArgsWithParamConfigs();
        const evaluator = _func(...args);
        const inputObjects = this._getObjects(coreGroup);
        for (const inputObject of inputObjects) {
          if (inputObject.parent == null) {
            this._tmpParent.add(inputObject);
          }
        }
        let objnum = 0;
        for (const inputObject of inputObjects) {
          this._objectContainer.Object3D = inputObject;
          this._objectContainer.objnum = objnum;
          evaluator();
          inputObject.updateMatrix();
          objnum++;
        }
        const tmpChildren = [...this._tmpParent.children];
        for (const inputObject of tmpChildren) {
          this._tmpParent.remove(inputObject);
        }
        this.setCoreGroup(coreGroup);
      } else {
        this.setObjects([]);
      }
    });
  }
  _getObjects(coreGroup) {
    return Mask/* CoreMask.filterThreejsObjects */.x0.filterThreejsObjects(coreGroup, this.pv);
  }
  compileIfRequired() {
    var _a;
    if ((_a = this.assemblerController()) == null ? void 0 : _a.compileRequired()) {
      this.compile();
    }
  }
  functionData() {
    return this._functionData;
  }
  compile() {
    const assemblerController = this.assemblerController();
    if (!assemblerController) {
      return;
    }
    const outputNodes = utils_NodeFinder/* JsNodeFinder.findOutputNodes */.K.findOutputNodes(this);
    if (outputNodes.length == 0) {
      this.states.error.set("one output node is required");
      return;
    }
    const outputNode = outputNodes[0];
    if (outputNode) {
      const paramNodes = utils_NodeFinder/* JsNodeFinder.findParamGeneratingNodes */.K.findParamGeneratingNodes(this);
      const attributeExportNodes = utils_NodeFinder/* JsNodeFinder.findAttributeExportNodes */.K.findAttributeExportNodes(this);
      const rootNodes = outputNodes.concat(paramNodes).concat(attributeExportNodes);
      assemblerController.assembler.set_root_nodes(rootNodes);
      assemblerController.assembler.updateFunction();
      const functionData = assemblerController.assembler.functionData();
      if (!functionData) {
        this.states.error.set("failed to compile ");
        return;
      }
      this.updateFromFunctionData(functionData);
    }
    assemblerController.post_compile();
  }
  updateFromFunctionData(functionData) {
    this._functionData = functionData;
    const { functionBody, variableNames, variablesByName, functionNames, functionsByName, paramConfigs } = this._functionData;
    const wrappedBody = `
		try {
			${functionBody}
		} catch(e) {
			_setErrorFromError(e)
			return 0;
		}`;
    const _setErrorFromError = (e) => {
      this.states.error.set(e.message);
    };
    const variables = [];
    const functions = [];
    for (const variableName of variableNames) {
      const variable = variablesByName[variableName];
      variables.push(variable);
    }
    for (const functionName of functionNames) {
      const _func = functionsByName[functionName];
      functions.push(_func);
    }
    this._paramConfigs = [...paramConfigs];
    const paramConfigNames = paramConfigs.map((pc) => pc.uniformName());
    paramConfigs.forEach((p) => p.applyToNode(this));
    this._functionCreationArgs = [
      ObjectBuilderAssemblerCommon/* ObjectBuilderAssemblerConstant.OBJECT_CONTAINER */.F.OBJECT_CONTAINER,
      "_setErrorFromError",
      ...variableNames,
      ...functionNames,
      ...paramConfigNames,
      wrappedBody
    ];
    this._functionEvalArgs = [
      this._objectContainer,
      _setErrorFromError,
      ...variables,
      ...functions
      // paramConfigs are added dynamically during cook
    ];
    try {
      this._function = new Function(...this._functionCreationArgs);
    } catch (e) {
      console.warn(e);
      this.states.error.set("failed to compile");
    }
  }
  functionEvalArgsWithParamConfigs() {
    const list = [
      ...this._functionEvalArgs
    ];
    for (const paramConfig of this._paramConfigs) {
      const paramName = paramConfig.name();
      const spareParam = this.params.get(paramName);
      if (spareParam && spareParam.value != null) {
        if (Type/* CoreType.isBoolean */.MR.isBoolean(spareParam.value) || Type/* CoreType.isNumberValid */.MR.isNumberValid(spareParam.value) || Type/* CoreType.isColor */.MR.isColor(spareParam.value) || Type/* CoreType.isVector */.MR.isVector(spareParam.value)) {
          list.push(spareParam.value);
        } else {
          console.warn(`spareParam not found but type not yet copied to function args:'${paramName}'`);
        }
      } else {
        console.warn(`spareParam not found:'${paramName}'`);
      }
    }
    return list;
  }
}

// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/nodes/sop/ObjectMerge.ts
var ObjectMerge = __webpack_require__(45658);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/nodes/sop/ObjectProperties.ts
var ObjectProperties = __webpack_require__(52620);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/nodes/sop/ObjectsLayout.ts
var ObjectsLayout = __webpack_require__(67118);
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/operations/sop/OceanPlane.ts



const DEFAULT_OCEAN_PARAMS = {
  pixelRatio: 1,
  clipBias: 0,
  // if clipBias is 0.03 like in BaseReflector, the bottom of the reflection appears cut out
  active: true,
  tblur: false,
  blur: 0,
  verticalBlurMult: 0,
  tblur2: false,
  blur2: 0,
  verticalBlur2Mult: 0
};
const DEFAULT_PARAMS = {
  direction: new three_module.Vector3(0, 1, 0),
  sunDirection: new three_module.Vector3(1, 1, 1),
  sunColor: new three_module.Color(1, 1, 1),
  wavesHeight: 1,
  waterColor: new three_module.Color(7695),
  reflectionColor: new three_module.Color(16777215),
  reflectionFresnel: 1,
  distortionScale: 1,
  timeScale: 1,
  size: 10,
  renderReflection: true,
  normalBias: 1e-3,
  multisamples: 1,
  useFog: false
};

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/modules/core/objects/_BaseReflector.ts






const renderTargetParams = {
  minFilter: three_module.LinearFilter,
  magFilter: three_module.LinearFilter
  // format: RGBAFormat,
  // encoding: LinearEncoding,
};
class BaseReflector extends three_module.Mesh {
  constructor(geometry, _options) {
    super(geometry);
    this.geometry = geometry;
    this._options = _options;
    this.type = "BaseReflector";
    this.reflectorPlane = new three_module.Plane();
    this.normal = new three_module.Vector3();
    this.reflectorWorldPosition = new three_module.Vector3();
    this.cameraWorldPosition = new three_module.Vector3();
    this.rotationMatrix = new three_module.Matrix4();
    this.lookAtPosition = new three_module.Vector3(0, 0, -1);
    this.clipPlane = new three_module.Vector4();
    this.view = new three_module.Vector3();
    this.target = new three_module.Vector3();
    this.q = new three_module.Vector4();
    this.textureMatrix = new three_module.Matrix4();
    this.virtualCamera = new three_module.PerspectiveCamera();
    this.material = this._createMaterial();
    this.onBeforeRender = this._onBeforeRender.bind(this);
    this._mirrorCameraMultipliedByMatrixWorld = true;
    this._onWindowResizeBound = this._onWindowResize.bind(this);
    if (this._options.renderer) {
      this._createRenderTarget(this._options.renderer);
    }
    this._addWindowResizeEvent();
  }
  _createRenderTarget(renderer) {
    const { width, height } = this._getRendererSize(renderer);
    this.renderTarget = Poly/* Poly.renderersController.createRenderTarget */.L.renderersController.createRenderTarget(width, height, renderTargetParams);
    if (this._options.multisamples > 0) {
      this.renderTarget.samples = this._options.multisamples;
    }
    this._assignMaterialRenderTarget();
    this._coreRenderBlur = new CoreRenderBlur(new three_module.Vector2(width, height));
  }
  dispose() {
    var _a, _b;
    this.geometry.dispose();
    (_a = this.renderTarget) == null ? void 0 : _a.dispose();
    (_b = this.material) == null ? void 0 : _b.dispose();
    this.onBeforeRender = () => {
    };
    this._removeWindowResizeEvent();
  }
  _addWindowResizeEvent() {
    window.addEventListener("resize", this._onWindowResizeBound.bind(this), false);
  }
  _removeWindowResizeEvent() {
    window.removeEventListener("resize", this._onWindowResizeBound.bind(this), false);
  }
  _onWindowResize() {
    var _a, _b;
    this.traverseAncestors((object) => {
      if (!object.parent) {
        if (object.uuid != this._options.scene.uuid) {
          this._removeWindowResizeEvent();
        }
      }
    });
    const renderer = this._options.renderer;
    if (renderer) {
      const { width, height } = this._getRendererSize(renderer);
      (_a = this.renderTarget) == null ? void 0 : _a.setSize(width, height);
      (_b = this._coreRenderBlur) == null ? void 0 : _b.setSize(width, height);
    }
  }
  _getRendererSize(renderer) {
    const canvas = renderer.domElement;
    const width = canvas.width * this._options.pixelRatio;
    const height = canvas.height * this._options.pixelRatio;
    return { width, height };
  }
  static rotateGeometry(geometry, direction) {
    (0,Transform/* rotateGeometry */.bP)(geometry, direction, this.REFLECTOR_DEFAULT_UP);
  }
  static compensateGeometryRotation(object, direction) {
    Transform/* CoreTransform.rotateObject */.ZR.rotateObject(object, this.REFLECTOR_DEFAULT_UP, direction);
  }
  _onBeforeRender(renderer, scene, anyCamera) {
    if (!this._options.active) {
      return;
    }
    if (!this.renderTarget) {
      this._createRenderTarget(renderer);
    }
    if (!(this.renderTarget && this._coreRenderBlur)) {
      return;
    }
    const camera = anyCamera;
    this.reflectorWorldPosition.setFromMatrixPosition(this.matrixWorld);
    this.cameraWorldPosition.setFromMatrixPosition(camera.matrixWorld);
    this.rotationMatrix.extractRotation(this.matrixWorld);
    this.normal.set(0, 0, 1);
    this.normal.applyMatrix4(this.rotationMatrix);
    this.view.subVectors(this.reflectorWorldPosition, this.cameraWorldPosition);
    if (this.view.dot(this.normal) > 0)
      return;
    this.view.reflect(this.normal).negate();
    this.view.add(this.reflectorWorldPosition);
    this.rotationMatrix.extractRotation(camera.matrixWorld);
    this.lookAtPosition.set(0, 0, -1);
    this.lookAtPosition.applyMatrix4(this.rotationMatrix);
    this.lookAtPosition.add(this.cameraWorldPosition);
    this.target.subVectors(this.reflectorWorldPosition, this.lookAtPosition);
    this.target.reflect(this.normal).negate();
    this.target.add(this.reflectorWorldPosition);
    this.virtualCamera.position.copy(this.view);
    this.virtualCamera.up.set(0, 1, 0);
    this.virtualCamera.up.applyMatrix4(this.rotationMatrix);
    this.virtualCamera.up.reflect(this.normal);
    this.virtualCamera.lookAt(this.target);
    this.virtualCamera.far = camera.far;
    this.virtualCamera.updateMatrixWorld();
    this.virtualCamera.projectionMatrix.copy(camera.projectionMatrix);
    this.textureMatrix.set(0.5, 0, 0, 0.5, 0, 0.5, 0, 0.5, 0, 0, 0.5, 0.5, 0, 0, 0, 1);
    this.textureMatrix.multiply(this.virtualCamera.projectionMatrix);
    this.textureMatrix.multiply(this.virtualCamera.matrixWorldInverse);
    if (this._mirrorCameraMultipliedByMatrixWorld) {
      this.textureMatrix.multiply(this.matrixWorld);
    }
    this.reflectorPlane.setFromNormalAndCoplanarPoint(this.normal, this.reflectorWorldPosition);
    this.reflectorPlane.applyMatrix4(this.virtualCamera.matrixWorldInverse);
    this.clipPlane.set(
      this.reflectorPlane.normal.x,
      this.reflectorPlane.normal.y,
      this.reflectorPlane.normal.z,
      this.reflectorPlane.constant
    );
    var projectionMatrix = this.virtualCamera.projectionMatrix;
    this.q.x = (Math.sign(this.clipPlane.x) + projectionMatrix.elements[8]) / projectionMatrix.elements[0];
    this.q.y = (Math.sign(this.clipPlane.y) + projectionMatrix.elements[9]) / projectionMatrix.elements[5];
    this.q.z = -1;
    this.q.w = (1 + projectionMatrix.elements[10]) / projectionMatrix.elements[14];
    this.clipPlane.multiplyScalar(2 / this.clipPlane.dot(this.q));
    projectionMatrix.elements[2] = this.clipPlane.x;
    projectionMatrix.elements[6] = this.clipPlane.y;
    projectionMatrix.elements[10] = this.clipPlane.z + 1 - this._options.clipBias;
    projectionMatrix.elements[14] = this.clipPlane.w;
    this.renderTarget.texture.colorSpace = renderer.outputColorSpace;
    this.visible = false;
    var currentRenderTarget = renderer.getRenderTarget();
    var currentXrEnabled = renderer.xr.enabled;
    var currentShadowAutoUpdate = renderer.shadowMap.autoUpdate;
    renderer.xr.enabled = false;
    renderer.shadowMap.autoUpdate = false;
    renderer.setRenderTarget(this.renderTarget);
    renderer.state.buffers.depth.setMask(true);
    if (renderer.autoClear === false)
      renderer.clear();
    renderer.render(scene, this.virtualCamera);
    if ((0,Type/* isBooleanTrue */.bI)(this._options.tblur)) {
      const blurAmount = this._options.blur * this._options.pixelRatio;
      const verticalBlurAmount = blurAmount * this._options.verticalBlurMult;
      this._coreRenderBlur.applyBlur(this.renderTarget, renderer, blurAmount, verticalBlurAmount);
      if ((0,Type/* isBooleanTrue */.bI)(this._options.tblur2)) {
        const blurAmount2 = this._options.blur2 * this._options.pixelRatio;
        const verticalBlurAmount2 = blurAmount2 * this._options.verticalBlur2Mult;
        this._coreRenderBlur.applyBlur(this.renderTarget, renderer, blurAmount2, verticalBlurAmount2);
      }
    }
    renderer.xr.enabled = currentXrEnabled;
    renderer.shadowMap.autoUpdate = currentShadowAutoUpdate;
    renderer.setRenderTarget(currentRenderTarget);
    var viewport = camera.viewport;
    if (viewport !== void 0) {
      renderer.state.viewport(viewport);
    }
    this.visible = true;
  }
}
BaseReflector.REFLECTOR_DEFAULT_UP = new three_module.Vector3(0, 0, 1);

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/modules/core/objects/water/vert.glsl
/* harmony default export */ var water_vert = ("uniform mat4 textureMatrix;\nuniform float time;\n\nvarying vec4 mirrorCoord;\nvarying vec4 worldPosition;\nvarying vec2 geoUV;\n\n#include <common>\n#include <fog_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n\nvoid main() {\n\tmirrorCoord = modelMatrix * vec4( position, 1.0 );\n\tworldPosition = mirrorCoord.xyzw;\n\tmirrorCoord = textureMatrix * mirrorCoord;\n\tvec4 mvPosition =  modelViewMatrix * vec4( position, 1.0 );\n\tgl_Position = projectionMatrix * mvPosition;\n\tgeoUV = uv;\n\n\t#include <beginnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <fog_vertex>\n\t#include <shadowmap_vertex>\n}");
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/modules/core/objects/water/frag.glsl
/* harmony default export */ var water_frag = ("uniform sampler2D mirrorSampler;\nuniform float alpha;\nuniform float time;\nuniform float timeScale;\nuniform float size;\nuniform float distortionScale;\nuniform float normalBias;\n// uniform sampler2D normalSampler;\nuniform vec3 sunColor;\nuniform vec3 sunDirection;\nuniform vec3 eye;\nuniform float wavesHeight;\nuniform vec3 waterColor;\nuniform vec3 reflectionColor;\nuniform float reflectionFresnel;\nuniform vec3 direction;\n\nvarying vec4 mirrorCoord;\nvarying vec4 worldPosition;\nvarying vec2 geoUV;\n\n// https://www.shadertoy.com/view/Xdlczl\n#define DRAG_MULT 0.048\n#define ITERATIONS_NORMAL 48\nvec2 wavedx(vec2 position, vec2 direction, float speed, float frequency, float timeshift) {\n\tfloat x = dot(direction, position) * frequency + timeshift * speed;\n\tfloat wave = exp(sin(x) - 1.0);\n\tfloat dx = wave * cos(x);\n\treturn vec2(wave, -dx);\n}\nfloat getwaves(vec2 position, float currentTime){\n\tfloat iter = 0.0;\n\tfloat phase = 6.0;\n\tfloat speed = 2.0;\n\tfloat weight = 1.0;\n\tfloat w = 0.0;\n\tfloat ws = 0.0;\n\tfor(int i=0;i<ITERATIONS_NORMAL;i++){\n\t\tvec2 p = vec2(sin(iter), cos(iter));\n\t\tvec2 res = wavedx(position, p, speed, phase, currentTime);\n\t\tposition += p * res.y * weight * DRAG_MULT;\n\t\tw += res.x * weight;\n\t\titer += 12.0;\n\t\tws += weight;\n\t\tweight = mix(weight, 0.0, 0.2);\n\t\tphase *= 1.18;\n\t\tspeed *= 1.07;\n\t}\n\treturn (w / ws);\n}\n\nfloat H = 0.0;\nvec3 normal(vec2 pos, float e, float depth, float currentTime){\n\tvec2 ex = vec2(e, 0);\n\tH = getwaves(pos.xy * 0.1, currentTime) * depth;\n\tvec3 a = vec3(pos.x, H, pos.y);\n\treturn normalize(cross(a-vec3(pos.x - e, getwaves(pos.xy * 0.1 - ex.xy * 0.1, currentTime) * depth, pos.y),\n\t\t\t\t\t\ta-vec3(pos.x, getwaves(pos.xy * 0.1 + ex.yx * 0.1, currentTime) * depth, pos.y + e)));\n}\n\n\nvoid sunLight( const vec3 surfaceNormal, const vec3 eyeDirection, float shiny, float spec, float diffuse, inout vec3 diffuseColor, inout vec3 specularColor ) {\n\tvec3 reflection = normalize( reflect( -sunDirection, surfaceNormal ) );\n\tfloat direction = max( 0.0, dot( eyeDirection, reflection ) );\n\tspecularColor += pow( direction, shiny ) * sunColor * spec;\n\tdiffuseColor += max( dot( sunDirection, surfaceNormal ), 0.0 ) * sunColor * diffuse;\n}\n\n\n#include <common>\n#include <packing>\n#include <bsdfs>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <lights_pars_begin>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\n\nvoid main() {\n\n\t#include <logdepthbuf_fragment>\n\tfloat waterDepth = -wavesHeight;\n\tvec3 surfaceNormal = normal(geoUV * size, normalBias /*0.01*/, waterDepth, time * timeScale);\n\n\tvec3 diffuseLight = vec3(0.0);\n\tvec3 specularLight = vec3(0.0);\n\n\tvec3 worldToEye = eye-worldPosition.xyz;\n\tvec3 eyeDirection = normalize( worldToEye );\n\tsunLight( surfaceNormal, eyeDirection, 100.0, 2.0, 0.5, diffuseLight, specularLight );\n\n\tfloat distance = length(worldToEye);\n\n\tvec2 distortion = surfaceNormal.xz * ( 0.001 + 1.0 / distance ) * distortionScale;\n\tvec3 reflectionSample = vec3( texture2D( mirrorSampler, mirrorCoord.xy / mirrorCoord.w + distortion ) );\n\n\tfloat theta = max( dot( eyeDirection, surfaceNormal ), 0.0 );\n\tfloat rf0 = 0.05;\n\tfloat reflectance = rf0 + ( 1.0 - rf0 ) * pow( ( 1.0 - theta ), 2.0 );//rf0 + ( 1.0 - rf0 ) * pow( ( 1.0 - theta ), 5.0 );\n\treflectance = mix(1.0, reflectance, reflectionFresnel);\n\tvec3 scatter = max( 0.0, dot( surfaceNormal, eyeDirection ) ) * waterColor;\n\tvec3 reflection = ( vec3( 0.0 ) + reflectionSample * 0.9 + reflectionSample * specularLight ) * reflectionColor;\n\tvec3 albedo = mix( ( sunColor * diffuseLight * 0.3 + scatter ) * getShadowMask(), reflection, reflectance);\n\tvec3 outgoingLight = albedo;\n\tgl_FragColor = vec4( outgoingLight, 1.0 );\n\n\t#include <tonemapping_fragment>\n\t#include <fog_fragment>\n}");
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/modules/core/objects/Water.ts





class Water extends BaseReflector {
  constructor(geometry, _options) {
    super(geometry, _options);
    this._options = _options;
    this.isWater = true;
    // private _renderReflection = true;
    this._mirrorCameraMultipliedByMatrixWorld = false;
  }
  _createMaterial() {
    const options = this._options;
    const alpha = options.alpha !== void 0 ? options.alpha : 1;
    const timeScale = options.timeScale !== void 0 ? options.timeScale : 1;
    const size = options.size !== void 0 ? options.size : 0;
    const direction = options.direction !== void 0 ? options.direction : new three_module.Vector3(0, 1, 0);
    const sunDirection = options.sunDirection !== void 0 ? options.sunDirection : new three_module.Vector3(0.70707, 0.70707, 0);
    const sunColor = new three_module.Color(options.sunColor !== void 0 ? options.sunColor : 16777215);
    const wavesHeight = options.wavesHeight !== void 0 ? options.wavesHeight : 1;
    const waterColor = new three_module.Color(options.waterColor !== void 0 ? options.waterColor : 8355711);
    const reflectionColor = new three_module.Color(options.reflectionColor !== void 0 ? options.reflectionColor : 16777215);
    const reflectionFresnel = options.reflectionFresnel !== void 0 ? options.reflectionFresnel : 1;
    const distortionScale = options.distortionScale !== void 0 ? options.distortionScale : 20;
    const side = options.side !== void 0 ? options.side : three_module.FrontSide;
    const useFog = options.useFog !== void 0 ? options.useFog : false;
    const normalBias = options.normalBias !== void 0 ? options.normalBias : 1e-3;
    const mirrorShader = {
      uniforms: three_module.UniformsUtils.merge([
        three_module.UniformsLib.fog,
        three_module.UniformsLib.lights,
        {
          mirrorSampler: { value: null },
          alpha: { value: 1 },
          time: { value: 0 },
          // do not assign time uniform here, as the uniforms as cloned shortly after
          timeScale: { value: 1 },
          size: { value: 1 },
          distortionScale: { value: 20 },
          textureMatrix: { value: new three_module.Matrix4() },
          sunColor: { value: new three_module.Color(8355711) },
          sunDirection: { value: new three_module.Vector3(0.70707, 0.70707, 0) },
          direction: { value: new three_module.Vector3().copy(BaseReflector.REFLECTOR_DEFAULT_UP) },
          eye: { value: new three_module.Vector3() },
          wavesHeight: { value: wavesHeight },
          waterColor: { value: new three_module.Color(5592405) },
          reflectionColor: { value: new three_module.Color(16777215) },
          reflectionFresnel: { value: 1 },
          normalBias: { value: normalBias }
        }
      ]),
      vertexShader: water_vert,
      fragmentShader: water_frag
    };
    const material = new three_module.ShaderMaterial({
      fragmentShader: mirrorShader.fragmentShader,
      vertexShader: mirrorShader.vertexShader,
      uniforms: three_module.UniformsUtils.clone(mirrorShader.uniforms),
      lights: true,
      side
      // fog: useFog,
      // transparent: true, // TODO: allow transparency when I have a good alpha model
    });
    material.fog = useFog;
    material.uniforms["time"] = this._options.polyScene.timeController.timeUniform();
    material.uniforms["timeScale"].value = timeScale;
    material.uniforms["size"].value = size;
    material.uniforms["textureMatrix"].value = this.textureMatrix;
    material.uniforms["alpha"].value = alpha;
    material.uniforms["sunColor"].value = sunColor;
    material.uniforms["wavesHeight"].value = wavesHeight;
    material.uniforms["waterColor"].value = waterColor;
    material.uniforms["reflectionColor"].value = reflectionColor;
    material.uniforms["reflectionFresnel"].value = reflectionFresnel;
    material.uniforms["direction"].value = direction;
    material.uniforms["sunDirection"].value = sunDirection;
    material.uniforms["distortionScale"].value = distortionScale;
    material.uniforms["normalBias"].value = normalBias;
    material.uniforms["eye"].value = new three_module.Vector3();
    return material;
  }
  _assignMaterialRenderTarget() {
    if (this.renderTarget) {
      this.material.uniforms["mirrorSampler"].value = this.renderTarget.texture;
    }
  }
  _onBeforeRender(renderer, scene, anyCamera) {
    super._onBeforeRender(renderer, scene, anyCamera);
    if (this.material) {
      this.material.uniforms["eye"].value.setFromMatrixPosition(anyCamera.matrixWorld);
    }
  }
  setReflectionActive(state) {
    this._options.active = state;
    if (state) {
      if (this.renderTarget) {
        this.material.uniforms["mirrorSampler"].value = this.renderTarget.texture;
      }
    } else {
      this.material.uniforms["mirrorSampler"].value = null;
    }
  }
  // override clone(recursive: boolean): this {
  // 	// we clone so that a cloned reflector does not share the same color
  // 	const clonedOptions = {...this._options};
  // 	clonedOptions.sunDirection = this._options.sunDirection?.clone();
  // 	clonedOptions.sunColor = this._options.sunColor?.clone();
  // 	clonedOptions.waterColor = this._options.waterColor?.clone();
  // 	const clonedGeometry = this.geometry.clone();
  // 	const clonedWater = new Water(clonedGeometry, clonedOptions);
  // 	const material: WaterMaterial = clonedWater.material;
  // 	clonedWater.copy(this, recursive);
  // 	// the material and geometry needs to be added back after the copy, as Mesh.copy would override that
  // 	clonedWater.material = material;
  // 	clonedWater.geometry = clonedGeometry;
  // 	// TODO:
  // 	// - size is not passed correctly
  // 	// - make time dependent to update the time uniform attribute
  // 	clonedWater.updateMatrix();
  // 	return clonedWater as this;
  // }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/sop/OceanPlane.ts

var OceanPlane_defProp = Object.defineProperty;
var OceanPlane_defProps = Object.defineProperties;
var OceanPlane_getOwnPropDescs = Object.getOwnPropertyDescriptors;
var OceanPlane_getOwnPropSymbols = Object.getOwnPropertySymbols;
var OceanPlane_hasOwnProp = Object.prototype.hasOwnProperty;
var OceanPlane_propIsEnum = Object.prototype.propertyIsEnumerable;
var OceanPlane_defNormalProp = (obj, key, value) => key in obj ? OceanPlane_defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var OceanPlane_spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (OceanPlane_hasOwnProp.call(b, prop))
      OceanPlane_defNormalProp(a, prop, b[prop]);
  if (OceanPlane_getOwnPropSymbols)
    for (var prop of OceanPlane_getOwnPropSymbols(b)) {
      if (OceanPlane_propIsEnum.call(b, prop))
        OceanPlane_defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var OceanPlane_spreadProps = (a, b) => OceanPlane_defProps(a, OceanPlane_getOwnPropDescs(b));







const OceanPlane_DEFAULT = DEFAULT_PARAMS;
class OceanPlaneSopParamsConfig extends params_ParamsConfig/* NodeParamsConfig */.yI {
  constructor() {
    super(...arguments);
    this.main = params_ParamsConfig/* ParamConfig.FOLDER */.XC.FOLDER();
    /** @param reflection direction */
    this.direction = params_ParamsConfig/* ParamConfig.VECTOR3 */.XC.VECTOR3(OceanPlane_DEFAULT.direction.toArray());
    /** @param sun direction */
    this.sunDirection = params_ParamsConfig/* ParamConfig.VECTOR3 */.XC.VECTOR3(OceanPlane_DEFAULT.sunDirection.toArray());
    /** @param sun color */
    this.sunColor = params_ParamsConfig/* ParamConfig.COLOR */.XC.COLOR(OceanPlane_DEFAULT.sunColor.toArray());
    /** @param water color */
    this.waterColor = params_ParamsConfig/* ParamConfig.COLOR */.XC.COLOR(OceanPlane_DEFAULT.waterColor.toArray());
    /** @param reflection color */
    this.reflectionColor = params_ParamsConfig/* ParamConfig.COLOR */.XC.COLOR(OceanPlane_DEFAULT.reflectionColor.toArray());
    /** @param reflection fresnel */
    this.reflectionFresnel = params_ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(OceanPlane_DEFAULT.reflectionFresnel);
    /** @param waves Height */
    this.wavesHeight = params_ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(OceanPlane_DEFAULT.wavesHeight, {
      range: [0, 10],
      rangeLocked: [false, false]
    });
    /** @param distortion scale */
    this.distortionScale = params_ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(OceanPlane_DEFAULT.distortionScale, {
      range: [0, 1],
      rangeLocked: [true, false]
    });
    /** @param distortion speed */
    this.timeScale = params_ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(OceanPlane_DEFAULT.timeScale, {
      range: [0, 2],
      rangeLocked: [true, false]
    });
    /** @param size */
    this.size = params_ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(OceanPlane_DEFAULT.size, {
      range: [0, 100],
      rangeLocked: [true, false]
    });
    this.advanced = params_ParamsConfig/* ParamConfig.FOLDER */.XC.FOLDER();
    /** @param render reflection */
    this.renderReflection = params_ParamsConfig/* ParamConfig.BOOLEAN */.XC.BOOLEAN(OceanPlane_DEFAULT.renderReflection);
    /** @param normal Bias - adjusts this if the reflections are too grainy */
    this.normalBias = params_ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(OceanPlane_DEFAULT.normalBias, {
      range: [0, 0.1],
      rangeLocked: [false, false]
    });
    /** @param multisamples */
    this.multisamples = params_ParamsConfig/* ParamConfig.INTEGER */.XC.INTEGER(OceanPlane_DEFAULT.multisamples, {
      range: [0, 4],
      rangeLocked: [true, false]
    });
    /** @param reacts to fog */
    this.useFog = params_ParamsConfig/* ParamConfig.BOOLEAN */.XC.BOOLEAN(OceanPlane_DEFAULT.useFog);
  }
}
const OceanPlane_ParamsConfig = new OceanPlaneSopParamsConfig();
class OceanPlaneSopNode extends sop_Base/* TypedSopNode */.x {
  constructor() {
    super(...arguments);
    this.paramsConfig = OceanPlane_ParamsConfig;
  }
  static type() {
    return "oceanPlane";
  }
  initializeNode() {
    this.io.inputs.setCount(1);
  }
  cook(inputCoreGroups) {
    const coreGroup = inputCoreGroups[0];
    const objects = coreGroup.threejsObjectsWithGeo();
    for (const object of objects) {
      Poly/* Poly.onObjectsAddRemoveHooks.assignOnAddHookHandler */.L.onObjectsAddRemoveHooks.assignOnAddHookHandler(object, this);
    }
    this.setCoreGroup(coreGroup);
  }
  updateObjectOnAdd(object, parent) {
    const _geometry = object.geometry;
    if (!_geometry) {
      return;
    }
    const clonedGeometry = _geometry.clone();
    const scene = this.scene();
    const renderer = scene.renderersRegister.lastRegisteredRenderer();
    Water.rotateGeometry(clonedGeometry, this.pv.direction);
    const waterOptions = OceanPlane_spreadProps(OceanPlane_spreadValues({
      polyScene: this.scene(),
      scene: scene.threejsScene(),
      renderer
    }, DEFAULT_OCEAN_PARAMS), {
      direction: this.pv.direction,
      sunDirection: this.pv.sunDirection,
      sunColor: this.pv.sunColor,
      wavesHeight: this.pv.wavesHeight,
      waterColor: this.pv.waterColor,
      reflectionColor: this.pv.reflectionColor,
      reflectionFresnel: this.pv.reflectionFresnel,
      distortionScale: this.pv.distortionScale,
      timeScale: this.pv.timeScale,
      size: this.pv.size,
      // renderReflection: params.renderReflection,
      normalBias: this.pv.normalBias,
      multisamples: this.pv.multisamples,
      useFog: this.pv.useFog
    });
    const water = new Water(clonedGeometry, waterOptions);
    water.matrixAutoUpdate = false;
    object.matrix.decompose(object.position, object.quaternion, object.scale);
    water.position.copy(object.position);
    water.rotation.copy(object.rotation);
    water.scale.copy(object.scale);
    water.updateMatrix();
    Water.compensateGeometryRotation(water, this.pv.direction);
    const material = water.material;
    material.uniforms.direction.value.copy(this.pv.direction);
    material.uniforms.sunDirection.value.copy(this.pv.sunDirection);
    material.uniforms.sunColor.value.copy(this.pv.sunColor);
    material.uniforms.wavesHeight.value = this.pv.wavesHeight;
    material.uniforms.waterColor.value.copy(this.pv.waterColor);
    material.uniforms.reflectionColor.value.copy(this.pv.reflectionColor);
    material.uniforms.reflectionFresnel.value = this.pv.reflectionFresnel;
    material.uniforms.distortionScale.value = this.pv.distortionScale;
    material.uniforms.timeScale.value = this.pv.timeScale;
    material.uniforms.size.value = this.pv.size;
    material.uniforms.normalBias.value = this.pv.normalBias;
    water.setReflectionActive((0,Type/* isBooleanTrue */.bI)(this.pv.renderReflection));
    (0,PolyOnObjectsAddRemoveHooksController/* replaceChild */.rS)(parent, object, water);
  }
}

// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/operations/_Base.ts
var operations_Base = __webpack_require__(55396);
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/sop/OperationsComposer.ts

var OperationsComposer_async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};




class OperationsComposerSopParamConfig extends params_ParamsConfig/* NodeParamsConfig */.yI {
}
const OperationsComposer_ParamsConfig = new OperationsComposerSopParamConfig();
class OperationsComposerSopNode extends sop_Base/* TypedSopNode */.x {
  constructor() {
    super(...arguments);
    this.paramsConfig = OperationsComposer_ParamsConfig;
    this._inputConfigsByOperationContainer = /* @__PURE__ */ new WeakMap();
  }
  static type() {
    return operations_Base/* OPERATIONS_COMPOSER_NODE_TYPE */.C;
  }
  initializeNode() {
    this.io.inputs.initInputsClonedState(InputCloneMode/* InputCloneMode.FROM_NODE */.m.FROM_NODE);
  }
  setOutputOperationContainer(operationContainer) {
    this._outputOperationContainer = operationContainer;
  }
  outputOperationContainer() {
    return this._outputOperationContainer;
  }
  addInputConfig(operation, inputConfig) {
    let existing_map = this._inputConfigsByOperationContainer.get(operation);
    if (!existing_map) {
      existing_map = /* @__PURE__ */ new Map();
      this._inputConfigsByOperationContainer.set(operation, existing_map);
    }
    existing_map.set(inputConfig.operation_input_index, inputConfig.node_input_index);
  }
  addOperationContainerWithPathParamResolveRequired(operationContainer) {
    if (!this._operationContainersRequiringResolve) {
      this._operationContainersRequiringResolve = [];
    }
    this._operationContainersRequiringResolve.push(operationContainer);
  }
  resolveOperationContainersPathParams() {
    if (!this._operationContainersRequiringResolve) {
      return;
    }
    for (const operationContainer of this._operationContainersRequiringResolve) {
      operationContainer.resolvePathParams(this);
    }
  }
  cook(inputCoreGroups) {
    return OperationsComposer_async(this, null, function* () {
      if (this._outputOperationContainer) {
        this._outputOperationContainer.setDirty();
        const coreGroup = yield this._outputOperationContainer.compute(
          inputCoreGroups,
          this._inputConfigsByOperationContainer
        );
        if (coreGroup) {
          this.setCoreGroup(coreGroup);
        }
      }
    });
  }
}

// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/nodes/sop/OrthographicCamera.ts
var sop_OrthographicCamera = __webpack_require__(50905);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/nodes/sop/Palette.ts
var Palette = __webpack_require__(35640);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/nodes/sop/ParticlesSystemGpu.ts + 1 modules
var ParticlesSystemGpu = __webpack_require__(49910);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/operations/sop/ParticlesSystemGpuAttributes.ts
var ParticlesSystemGpuAttributes = __webpack_require__(25296);
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/sop/ParticlesSystemGpuAttributes.ts

var ParticlesSystemGpuAttributes_async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};




const ParticlesSystemGpuAttributes_DEFAULT = ParticlesSystemGpuAttributes/* ParticlesSystemGpuAttributesSopOperation.DEFAULT_PARAMS */.c.DEFAULT_PARAMS;
class ParticlesSystemGpuAttributesSopParamsConfig extends params_ParamsConfig/* NodeParamsConfig */.yI {
  constructor() {
    super(...arguments);
    /** @param group to assign the material to */
    this.group = params_ParamsConfig/* ParamConfig.STRING */.XC.STRING(ParticlesSystemGpuAttributes_DEFAULT.group, {
      objectMask: true
    });
  }
}
const ParticlesSystemGpuAttributes_ParamsConfig = new ParticlesSystemGpuAttributesSopParamsConfig();
class ParticlesSystemGpuAttributesSopNode extends sop_Base/* TypedSopNode */.x {
  constructor() {
    super(...arguments);
    this.paramsConfig = ParticlesSystemGpuAttributes_ParamsConfig;
  }
  static type() {
    return Sop/* SopType.PARTICLES_SYSTEM_GPU_ATTRIBUTES */.aB.PARTICLES_SYSTEM_GPU_ATTRIBUTES;
  }
  initializeNode() {
    this.io.inputs.setCount(1);
    this.io.inputs.initInputsClonedState(ParticlesSystemGpuAttributes/* ParticlesSystemGpuAttributesSopOperation.INPUT_CLONED_STATE */.c.INPUT_CLONED_STATE);
  }
  cook(inputCoreGroups) {
    return ParticlesSystemGpuAttributes_async(this, null, function* () {
      this._operation = this._operation || new ParticlesSystemGpuAttributes/* ParticlesSystemGpuAttributesSopOperation */.c(this._scene, this.states, this);
      const coreGroup = yield this._operation.cook(inputCoreGroups, this.pv);
      this.setCoreGroup(coreGroup);
    });
  }
}

// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/operations/sop/ParticlesSystemGpuMaterial.ts
var ParticlesSystemGpuMaterial = __webpack_require__(46559);
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/sop/ParticlesSystemGpuMaterial.ts

var ParticlesSystemGpuMaterial_async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};





const ParticlesSystemGpuMaterial_DEFAULT = ParticlesSystemGpuMaterial/* ParticlesSystemGpuMaterialSopOperation.DEFAULT_PARAMS */.K.DEFAULT_PARAMS;
class ParticlesSystemGpuMaterialSopParamsConfig extends params_ParamsConfig/* NodeParamsConfig */.yI {
  constructor() {
    super(...arguments);
    /** @param group to assign the material to */
    this.group = params_ParamsConfig/* ParamConfig.STRING */.XC.STRING(ParticlesSystemGpuMaterial_DEFAULT.group, {
      objectMask: true
    });
    /** @param the material node */
    this.material = params_ParamsConfig/* ParamConfig.NODE_PATH */.XC.NODE_PATH("", {
      nodeSelection: {
        context: poly_NodeContext/* NodeContext.MAT */.sy.MAT
      },
      dependentOnFoundNode: false,
      visibleIf: { assignMat: 1 }
    });
  }
}
const ParticlesSystemGpuMaterial_ParamsConfig = new ParticlesSystemGpuMaterialSopParamsConfig();
class ParticlesSystemGpuMaterialSopNode extends sop_Base/* TypedSopNode */.x {
  constructor() {
    super(...arguments);
    this.paramsConfig = ParticlesSystemGpuMaterial_ParamsConfig;
  }
  static type() {
    return Sop/* SopType.PARTICLES_SYSTEM_GPU_MATERIAL */.aB.PARTICLES_SYSTEM_GPU_MATERIAL;
  }
  initializeNode() {
    this.io.inputs.setCount(1);
    this.io.inputs.initInputsClonedState(ParticlesSystemGpuMaterial/* ParticlesSystemGpuMaterialSopOperation.INPUT_CLONED_STATE */.K.INPUT_CLONED_STATE);
  }
  cook(inputCoreGroups) {
    return ParticlesSystemGpuMaterial_async(this, null, function* () {
      this._operation = this._operation || new ParticlesSystemGpuMaterial/* ParticlesSystemGpuMaterialSopOperation */.K(this._scene, this.states, this);
      const coreGroup = yield this._operation.cook(inputCoreGroups, this.pv);
      this.setCoreGroup(coreGroup);
    });
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/operations/sop/Peak.ts





const _normal = new three_module.Vector3();
const Peak_position = new three_module.Vector3();
class PeakSopOperation extends operations_sop_Base/* BaseSopOperation */.U {
  static type() {
    return "peak";
  }
  cook(inputCoreGroups, params) {
    const coreGroup = inputCoreGroups[0];
    const objects = coreGroup.allObjects();
    for (const object of objects) {
      object.traverse((childObject) => {
        const corePoint = (0,CoreObjectFactory/* corePointInstanceFactory */.BI)(childObject);
        const pointsCount = (0,CorePointUtils/* pointsCountFromObject */.En)(childObject);
        for (let i = 0; i < pointsCount; i++) {
          corePoint.setIndex(i);
          corePoint.normal(_normal);
          corePoint.position(Peak_position);
          Peak_position.add(_normal.multiplyScalar(params.amount));
          corePoint.setPosition(Peak_position);
        }
      });
    }
    return coreGroup;
  }
}
PeakSopOperation.DEFAULT_PARAMS = {
  amount: 0
};

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/sop/Peak.ts




const Peak_DEFAULT = PeakSopOperation.DEFAULT_PARAMS;

class PeakSopParamsConfig extends params_ParamsConfig/* NodeParamsConfig */.yI {
  constructor() {
    super(...arguments);
    /** @param amount the points will be moved */
    this.amount = params_ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(Peak_DEFAULT.amount, { range: [-1, 1] });
  }
}
const Peak_ParamsConfig = new PeakSopParamsConfig();
class PeakSopNode extends sop_Base/* TypedSopNode */.x {
  constructor() {
    super(...arguments);
    this.paramsConfig = Peak_ParamsConfig;
  }
  static type() {
    return "peak";
  }
  initializeNode() {
    this.io.inputs.setCount(1);
    this.io.inputs.initInputsClonedState(InputCloneMode/* InputCloneMode.FROM_NODE */.m.FROM_NODE);
  }
  cook(input_contents) {
    this._operation = this._operation || new PeakSopOperation(this.scene(), this.states, this);
    const core_group = this._operation.cook(input_contents, this.pv);
    this.setCoreGroup(core_group);
  }
}

// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/nodes/sop/PerspectiveCamera.ts
var sop_PerspectiveCamera = __webpack_require__(33973);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/nodes/sop/_BaseActor.ts
var _BaseActor = __webpack_require__(29540);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/core/physics/PhysicsDebug.ts
var PhysicsDebug = __webpack_require__(74458);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/core/physics/PhysicsAttribute.ts
var PhysicsAttribute = __webpack_require__(36911);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/core/physics/CorePhysics.ts
var CorePhysics = __webpack_require__(83260);
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/sop/PhysicsDebug.ts

var PhysicsDebug_async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};








class PhysicsDebugSopParamsConfig extends params_ParamsConfig/* NodeParamsConfig */.yI {
}
const PhysicsDebug_ParamsConfig = new PhysicsDebugSopParamsConfig();
class PhysicsDebugSopNode extends _BaseActor/* TypedActorSopNode */.p {
  constructor() {
    super(...arguments);
    this.paramsConfig = PhysicsDebug_ParamsConfig;
  }
  static type() {
    return Sop/* SopType.PHYSICS_DEBUG */.aB.PHYSICS_DEBUG;
  }
  initializeNode() {
    this.io.inputs.setCount(1);
    this.io.inputs.initInputsClonedState(InputCloneMode/* InputCloneMode.FROM_NODE */.m.FROM_NODE);
  }
  cook(inputCoreGroups) {
    return PhysicsDebug_async(this, null, function* () {
      this.compilationController.compileIfRequired();
      yield (0,CorePhysics/* CorePhysics */.a)();
      const coreGroup = inputCoreGroups[0];
      const worldObjectId = coreGroup.allObjects().map((o) => (0,CoreObjectFactory/* coreObjectClassFactory */.Xr)(o).attribValue(o, PhysicsAttribute/* PhysicsIdAttribute.WORLD */.m3.WORLD)).find((id) => id != null);
      if (worldObjectId != null) {
        const debugObject = (0,PhysicsDebug/* physicsCreateDebugObject */.Z)();
        (0,CoreObjectFactory/* coreObjectClassFactory */.Xr)(debugObject).addAttribute(
          debugObject,
          PhysicsAttribute/* PhysicsIdAttribute.DEBUG_WORLD */.m3.DEBUG_WORLD,
          worldObjectId
        );
        debugObject.name = `${this.name()}_Debug`;
        const actorNode = this._findActorNode();
        this.scene().actorsManager.assignActorBuilder(debugObject, actorNode);
        this.setObjects([debugObject]);
      } else {
        this.setObjects([]);
      }
    });
  }
  // public override updateObjectOnAdd(object: Object3D) {
  // 	// if (!this._PhysicsLib) {
  // 	// 	return;
  // 	// }
  // 	const worldNodeId = CoreObject.attribValue(object, PhysicsIdAttribute.WORLD);
  // 	if (worldNodeId != null) {
  // 		if (worldNodeId != this.graphNodeId()) {
  // 			return;
  // 		}
  // 		const worldObject = object;
  // 		createOrFindPhysicsDebug(this, worldObject, this.pv.gravity).then(({world, PhysicsLib}) => {
  // 			initCorePhysicsDebug(PhysicsLib, worldObject, this.scene());
  // 			// once world is create, try and find a sibbling that matches the debug object,
  // 			// then updated it accordingly
  // 			const sibblings = worldObject.parent?.children.filter((sibbling) => sibbling.uuid != worldObject.uuid);
  // 			if (!sibblings) {
  // 				return;
  // 			}
  // 			const debugObject = sibblings.find(
  // 				(sibbling) => CoreObject.attribValue(sibbling, PhysicsIdAttribute.DEBUG) == this.graphNodeId()
  // 			);
  // 			if (debugObject) {
  // 				updatePhysicsDebugObject(debugObject);
  // 			}
  // 			// if (isBooleanTrue(this.pv.debug)) {
  // 			// 	const pair = createOrFindPhysicsDebugObject(this, world);
  // 			// 	updatePhysicsDebugObject(pair);
  // 			// 	objects.push(pair.object);
  // 			// }
  // 			// for (let object of objects) {
  // 			// 	this.scene().actorsManager.assignActorBuilder(object, actorNode);
  // 			// }
  // 		});
  // 		// initCorePhysicsDebug(this._PhysicsLib, object, this.scene());
  // 	}
  // }
  _findActorNode() {
    return this;
  }
  //
  // CHILDREN
  //
  // protected override _childrenControllerContext = NodeContext.JS;
  // override createNode<S extends keyof JsNodeChildrenMap>(
  // 	node_class: S,
  // 	options?: NodeCreateOptions
  // ): JsNodeChildrenMap[S];
  // override createNode<K extends valueof<JsNodeChildrenMap>>(
  // 	node_class: Constructor<K>,
  // 	options?: NodeCreateOptions
  // ): K;
  // override createNode<K extends valueof<JsNodeChildrenMap>>(
  // 	node_class: Constructor<K>,
  // 	options?: NodeCreateOptions
  // ): K {
  // 	return super.createNode(node_class, options) as K;
  // }
  // override children() {
  // 	return super.children() as BaseJsNodeType[];
  // }
  // override nodesByType<K extends keyof JsNodeChildrenMap>(type: K): JsNodeChildrenMap[K][] {
  // 	return super.nodesByType(type) as JsNodeChildrenMap[K][];
  // }
  // override childrenAllowed() {
  // 	return true;
  // }
}

// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/nodes/sop/PhysicsGround.ts
var PhysicsGround = __webpack_require__(14776);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/nodes/sop/PhysicsPlayer.ts
var PhysicsPlayer = __webpack_require__(71011);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/nodes/sop/PhysicsRBDJoints.ts
var PhysicsRBDJoints = __webpack_require__(13070);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/nodes/sop/PhysicsRBDAttributes.ts
var PhysicsRBDAttributes = __webpack_require__(39962);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/nodes/sop/PhysicsWorld.ts
var sop_PhysicsWorld = __webpack_require__(25898);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/nodes/sop/Plane.ts
var sop_Plane = __webpack_require__(30748);
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/operations/sop/PlaneHelper.ts





class PlaneHelperSopOperation extends operations_sop_Base/* BaseSopOperation */.U {
  static type() {
    return "planeHelper";
  }
  cook(input_contents, params) {
    const helper = new three_module.GridHelper(params.size, params.size, params.colorCenterLine, params.colorGrid);
    helper.matrixAutoUpdate = false;
    if (this._node) {
      helper.name = this._node.name();
    }
    return this.createCoreGroupFromObjects([helper]);
  }
}
PlaneHelperSopOperation.DEFAULT_PARAMS = {
  size: 10,
  colorCenterLine: new three_module.Color(0, 0, 1),
  colorGrid: new three_module.Color(1, 1, 1)
};
PlaneHelperSopOperation.INPUT_CLONED_STATE = InputCloneMode/* InputCloneMode.NEVER */.m.NEVER;

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/sop/PlaneHelper.ts




const PlaneHelper_DEFAULT = PlaneHelperSopOperation.DEFAULT_PARAMS;
class PlaneHelperSopParamsConfig extends params_ParamsConfig/* NodeParamsConfig */.yI {
  constructor() {
    super(...arguments);
    /** @param size of the plane */
    this.size = params_ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(PlaneHelper_DEFAULT.size, {
      range: [1, 10],
      rangeLocked: [true, false]
    });
    /** @param colorCenterLine */
    this.colorCenterLine = params_ParamsConfig/* ParamConfig.COLOR */.XC.COLOR(PlaneHelper_DEFAULT.colorCenterLine.toArray());
    /** @param colorGrid */
    this.colorGrid = params_ParamsConfig/* ParamConfig.COLOR */.XC.COLOR(PlaneHelper_DEFAULT.colorGrid.toArray());
  }
}
const PlaneHelper_ParamsConfig = new PlaneHelperSopParamsConfig();
class PlaneHelperSopNode extends sop_Base/* TypedSopNode */.x {
  constructor() {
    super(...arguments);
    this.paramsConfig = PlaneHelper_ParamsConfig;
  }
  static type() {
    return "planeHelper";
  }
  initializeNode() {
    this.io.inputs.setCount(0);
  }
  cook(input_contents) {
    this._operation = this._operation || new PlaneHelperSopOperation(this.scene(), this.states, this);
    const core_group = this._operation.cook(input_contents, this.pv);
    this.setCoreGroup(core_group);
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/js/code/assemblers/pointBuilder/PointBuilderPersistedConfig.ts


class PointBuilderPersistedConfig extends BasePointBuilderPersistedConfig {
  constructor(node) {
    super(node);
    this.node = node;
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/sop/PointBuilder.ts











class PointBuilderSopParamsConfig extends BasePointBuilderSopParamsConfig {
  constructor() {
    super(...arguments);
    /** @param updateNormals */
    this.updateNormals = params_ParamsConfig/* ParamConfig.BOOLEAN */.XC.BOOLEAN(1);
  }
}
const PointBuilder_ParamsConfig = new PointBuilderSopParamsConfig();
class PointBuilderSopNode extends BasePointBuilderSopNode {
  constructor() {
    super(...arguments);
    this.paramsConfig = PointBuilder_ParamsConfig;
    this.persisted_config = new PointBuilderPersistedConfig(this);
    this._pointContainer = {
      position: new three_module.Vector3(),
      normal: new three_module.Vector3(),
      ptnum: -1,
      objnum: -1,
      normalsUpdated: false
    };
  }
  static type() {
    return Sop/* SopType.POINT_BUILDER */.aB.POINT_BUILDER;
  }
  usedAssembler() {
    return _BaseRegister/* AssemblerName.JS_POINT_BUILDER */.Q.JS_POINT_BUILDER;
  }
  _processObject(object, objnum, evaluator) {
    this._pointContainer.objnum = objnum;
    this._pointContainer.normalsUpdated = false;
    const readAttributeOptions = this._checkRequiredReadAttributes(object);
    const writeAttributeOptions = this._checkRequiredWriteAttributes(object);
    const readAttribNames = readAttributeOptions ? readAttributeOptions.attribNames : [];
    const readAttributeByName = readAttributeOptions ? readAttributeOptions.attributeByName : /* @__PURE__ */ new Map();
    const attribTypeByName = readAttributeOptions ? readAttributeOptions.attribTypeByName : /* @__PURE__ */ new Map();
    const writeAttribNames = writeAttributeOptions ? writeAttributeOptions.attribNames : [];
    const writeAttributeByName = writeAttributeOptions ? writeAttributeOptions.attributeByName : /* @__PURE__ */ new Map();
    this._resetRequiredAttributes();
    const pointsCount = (0,CorePointUtils/* pointsCountFromObject */.En)(object);
    const corePointClass = (0,CoreObjectFactory/* corePointClassFactory */.E_)(object);
    const positionAttrib = corePointClass.attribute(object, geometry_Attribute/* Attribute.POSITION */.ah.POSITION);
    const normalAttrib = corePointClass.attribute(object, geometry_Attribute/* Attribute.NORMAL */.ah.NORMAL);
    const hasPosition = positionAttrib != null;
    const hasNormal = normalAttrib != null;
    if (!hasPosition) {
      this._pointContainer.position.set(0, 0, 0);
    }
    if (!hasNormal) {
      this._pointContainer.normal.set(0, 1, 0);
    }
    for (let ptnum = 0; ptnum < pointsCount; ptnum++) {
      this._pointContainer.ptnum = ptnum;
      if (hasPosition) {
        this._pointContainer.position.fromBufferAttribute(positionAttrib, ptnum);
      }
      if (hasNormal) {
        this._pointContainer.normal.fromBufferAttribute(normalAttrib, ptnum);
      }
      this._readRequiredAttributes(ptnum, readAttribNames, readAttributeByName, attribTypeByName);
      evaluator();
      if (hasPosition) {
        positionAttrib.setXYZ(
          ptnum,
          this._pointContainer.position.x,
          this._pointContainer.position.y,
          this._pointContainer.position.z
        );
      }
      if (hasNormal) {
        normalAttrib.setXYZ(
          ptnum,
          this._pointContainer.normal.x,
          this._pointContainer.normal.y,
          this._pointContainer.normal.z
        );
      }
      this._writeRequiredAttributes(ptnum, writeAttribNames, writeAttributeByName);
    }
    if ((0,Type/* isBooleanTrue */.bI)(this.pv.updateNormals) && !this._pointContainer.normalsUpdated) {
      corePointClass.computeNormals(object);
    }
  }
}

// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/nodes/sop/Point.ts
var Point = __webpack_require__(53860);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/nodes/sop/PointLight.ts
var sop_PointLight = __webpack_require__(60208);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/nodes/sop/PolarTransform.ts
var PolarTransform = __webpack_require__(32490);
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/core/geometry/util/Curve.ts




const Curve_points = [];
class CoreGeometryUtilCurve {
  static accumulatedCurvePointIndices(indices) {
    let curve_point_indices = [];
    const accumulated_curve_point_indices = [];
    let last_index_added = null;
    let index;
    for (let i = 0; i < indices.length; i++) {
      if (i % 2 === 1) {
        index = indices[i];
        const previous_index = indices[i - 1];
        if (last_index_added == null || previous_index === last_index_added) {
          if (curve_point_indices.length === 0) {
            curve_point_indices.push(previous_index);
          }
          curve_point_indices.push(index);
          last_index_added = index;
        } else {
          accumulated_curve_point_indices.push(curve_point_indices);
          curve_point_indices = [previous_index, index];
          last_index_added = index;
        }
      }
    }
    accumulated_curve_point_indices.push(curve_point_indices);
    return accumulated_curve_point_indices;
  }
  static create_line_segment_geometry(points, indices, attrib_names, attrib_sizes_by_name) {
    const new_indices = [];
    const new_attribute_values_by_name = {};
    attrib_names.forEach((attrib_name) => {
      new_attribute_values_by_name[attrib_name] = [];
    });
    indices.forEach((index, i) => {
      const point = points[index];
      attrib_names.forEach((attrib_name) => {
        const attrib_value = point.attribValue(attrib_name);
        const attrib_size = attrib_sizes_by_name[attrib_name];
        let attrib_value_f;
        if (attrib_size > 1) {
          attrib_value_f = attrib_value.toArray();
        } else {
          attrib_value_f = [attrib_value];
        }
        attrib_value_f.forEach((v) => {
          new_attribute_values_by_name[attrib_name].push(v);
        });
      });
      if (i > 0) {
        new_indices.push(i - 1);
        new_indices.push(i);
      }
    });
    const geometry = new three_module.BufferGeometry();
    attrib_names.forEach((attrib_name) => {
      const attrib_size = attrib_sizes_by_name[attrib_name];
      const values = new_attribute_values_by_name[attrib_name];
      geometry.setAttribute(attrib_name, new three_module.Float32BufferAttribute(values, attrib_size));
    });
    geometry.setIndex(new_indices);
    return geometry;
  }
  static line_segment_to_geometries(object) {
    var _a;
    const geometries = [];
    const attribNames = (0,CorePointUtils/* pointAttributeNames */.JL)(object);
    (0,CorePointUtils/* pointsFromObject */.u_)(object, Curve_points);
    if (!(0,ObjectContent/* isObject3D */.nK)(object)) {
      return;
    }
    const geometry = object.geometry;
    if (!geometry) {
      return;
    }
    const indices = ((_a = geometry.getIndex()) == null ? void 0 : _a.array) || new Uint32Array(0);
    const accumulated_curve_point_indices = this.accumulatedCurvePointIndices(indices);
    if (accumulated_curve_point_indices.length > 0) {
      const attributeSizesByName = (0,CorePointUtils/* pointAttributeSizes */.Qg)(object);
      accumulated_curve_point_indices.forEach((curvePointIndices, i) => {
        const newGeometry = this.create_line_segment_geometry(
          Curve_points,
          curvePointIndices,
          attribNames,
          attributeSizesByName
        );
        geometries.push(newGeometry);
      });
    }
    return geometries;
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/core/geometry/operation/Skin.ts





const dummyMeshSmallest = new three_module.Mesh();
const dummyMeshLargest = new three_module.Mesh();
const _smallestPoints = [];
const _largestPoints = [];
function segments(geometry) {
  var _a;
  const index = ((_a = geometry.index) == null ? void 0 : _a.array) || [];
  return (0,ArrayUtils/* arrayChunk */.Zq)(index, 2);
}
class CoreGeometryOperationSkin {
  constructor(geometry, geometry1, geometry0) {
    this.geometry = geometry;
    this.geometry1 = geometry1;
    this.geometry0 = geometry0;
  }
  process() {
    const segments0 = segments(this.geometry0);
    const segments1 = segments(this.geometry1);
    if (segments0.length === 0 || segments1.length === 0) {
      return;
    }
    const geometries_by_segments_count = segments0.length < segments1.length ? [this.geometry0, this.geometry1] : [this.geometry1, this.geometry0];
    const smallest_geometry = geometries_by_segments_count[0];
    const largest_geometry = geometries_by_segments_count[1];
    dummyMeshSmallest.geometry = smallest_geometry;
    dummyMeshLargest.geometry = largest_geometry;
    const smallest_segments = segments(smallest_geometry);
    const largest_segments = segments(largest_geometry);
    (0,CorePointUtils/* pointsFromObject */.u_)(dummyMeshSmallest, _smallestPoints);
    (0,CorePointUtils/* pointsFromObject */.u_)(dummyMeshLargest, _largestPoints);
    const smallestGeometryAttribNames = ThreejsPoint/* ThreejsPoint.attributeNames */.B.attributeNames(dummyMeshSmallest);
    const largestGeometryAttribNames = ThreejsPoint/* ThreejsPoint.attributeNames */.B.attributeNames(dummyMeshLargest);
    const smallest_points_count = _smallestPoints.length;
    const all_points = _smallestPoints.concat(_largestPoints);
    const points_indices = [];
    smallest_segments.forEach((segment, i) => {
      const matched_segment = largest_segments[i];
      points_indices.push(segment[0]);
      points_indices.push(segment[1]);
      points_indices.push(matched_segment[0] + smallest_points_count);
      points_indices.push(segment[1]);
      points_indices.push(matched_segment[1] + smallest_points_count);
      points_indices.push(matched_segment[0] + smallest_points_count);
    });
    const attributes_in_common = [];
    (0,ArrayUtils/* arrayIntersection */.tN)(smallestGeometryAttribNames, largestGeometryAttribNames, attributes_in_common);
    attributes_in_common.forEach((attrib_name) => {
      const attrib_size = ThreejsPoint/* ThreejsPoint.attribSize */.B.attribSize(dummyMeshSmallest, attrib_name);
      let attrib_values = all_points.map((point) => point.attribValue(attrib_name));
      let float_values;
      if (attrib_size == 1) {
        float_values = attrib_values;
      } else {
        float_values = attrib_values.map((v) => v.toArray()).flat();
      }
      this.geometry.setAttribute(attrib_name, new three_module.Float32BufferAttribute(float_values, attrib_size));
    });
    this.geometry.setIndex(points_indices);
    this.geometry.computeVertexNormals();
  }
}

// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/core/geometry/modules/three/builders/Merge.ts
var builders_Merge = __webpack_require__(92276);
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/core/geometry/util/addAttributesFromPoint.ts



function addAttributesFromPoint(geometry, point, attributeNames) {
  const pointsCount = geometry.getAttribute("position").count;
  for (const attributeName of attributeNames) {
    addAttributeFromPoint(geometry, point, attributeName, pointsCount);
  }
}
function addAttributeFromPoint(geometry, point, attributeName, pointsCount) {
  const value = point.attribValue(attributeName);
  if (!Type/* CoreType.isString */.MR.isString(value)) {
    const size = point.attribSize(attributeName);
    let values = new Array(pointsCount * size);
    switch (size) {
      case 1: {
        values.fill(value);
        break;
      }
      default: {
        for (let i = 0; i < pointsCount; i++) {
          value.toArray(values, i * size);
        }
      }
    }
    const attribute = new three_module.BufferAttribute(new Float32Array(values), size);
    geometry.setAttribute(attributeName, attribute);
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/operations/sop/Polywire.ts













const ORIGIN = new three_module.Vector3(0, 0, 0);
const UP = new three_module.Vector3(0, 1, 0);
const lookAtMat = new three_module.Matrix4();
const translateMat = new three_module.Matrix4();
const currentPos = new three_module.Vector3();
const prevPos = new three_module.Vector3();
const nextPos = new three_module.Vector3();
const delta = new three_module.Vector3();
const deltaNext = new three_module.Vector3();
const deltaPrev = new three_module.Vector3();
const Polywire_points = [];
class PolywireSopOperation extends operations_sop_Base/* BaseSopOperation */.U {
  static type() {
    return "polywire";
  }
  cook(inputCoreGroups, params) {
    const coreGroup = inputCoreGroups[0];
    const inputObjects = coreGroup.threejsObjects();
    const newObjects = [];
    for (const inputObject of inputObjects) {
      const geometries = [];
      if (inputObject instanceof three_module.LineSegments) {
        this._createTube(inputObject, params, geometries);
      }
      const mergedGeometry = builders_Merge/* CoreGeometryBuilderMerge.merge */.O.merge(geometries);
      if (mergedGeometry) {
        const newObject = this.createObject(mergedGeometry, Constant/* ObjectType.MESH */.LP.MESH);
        copyObject3DProperties(inputObject, newObject);
        newObjects.push(newObject);
      }
    }
    return this.createCoreGroupFromObjects(newObjects);
  }
  _createTube(lineSegment, params, geometries) {
    var _a;
    const geometry = lineSegment.geometry;
    const corePointClass = (0,CoreObjectFactory/* corePointClassFactory */.E_)(lineSegment);
    const attributeNames = corePointClass.attributeNamesMatchingMask(lineSegment, params.attributesToCopy);
    (0,CorePointUtils/* pointsFromObject */.u_)(lineSegment, Polywire_points);
    const indices = (_a = geometry.getIndex()) == null ? void 0 : _a.array;
    if (!indices) {
      return;
    }
    const accumulatedCurvePointIndices = CoreGeometryUtilCurve.accumulatedCurvePointIndices(indices);
    for (let curvePointIndices of accumulatedCurvePointIndices) {
      const currentPoints = curvePointIndices.map((index) => Polywire_points[index]);
      this._createTubeFromPoints(currentPoints, attributeNames, params, geometries);
    }
  }
  _createTubeFromPoints(points, attributeNames, params, geometries) {
    if (points.length <= 1) {
      return;
    }
    const options = {
      radius: params.radius,
      segments: params.segmentsRadial,
      arcAngle: 360,
      connectLastPoint: true
    };
    const circleTemplate = CoreGeometryUtilCircle.create(options);
    const circles = [];
    let i = 0;
    for (let point of points) {
      point.position(currentPos);
      let prevPoint = points[i - 1];
      let nextPoint = points[i + 1];
      if (prevPoint && nextPoint) {
        nextPoint.position(nextPos);
        deltaNext.copy(nextPos).sub(currentPos);
        prevPoint.position(prevPos);
        deltaPrev.copy(prevPos).sub(currentPos).multiplyScalar(-1);
        delta.lerpVectors(deltaNext, deltaPrev, 0.5);
      } else {
        if (nextPoint) {
          nextPoint.position(nextPos);
          delta.copy(nextPos).sub(currentPos);
        } else {
          nextPoint = points[i - 1];
          nextPoint.position(nextPos);
          delta.copy(nextPos).sub(currentPos).multiplyScalar(-1);
        }
      }
      lookAtMat.identity();
      lookAtMat.lookAt(ORIGIN, delta.multiplyScalar(-1), UP);
      translateMat.identity();
      translateMat.makeTranslation(currentPos.x, currentPos.y, currentPos.z);
      const newCircle = circleTemplate.clone();
      newCircle.applyMatrix4(lookAtMat);
      newCircle.applyMatrix4(translateMat);
      const positionIndex = attributeNames.indexOf("position");
      if (positionIndex >= 0) {
        attributeNames.splice(positionIndex, 1);
      }
      addAttributesFromPoint(newCircle, point, attributeNames);
      circles.push(newCircle);
      i++;
    }
    for (let i2 = 0; i2 < circles.length; i2++) {
      if (i2 > 0) {
        const circle = circles[i2];
        const prevCircle = circles[i2 - 1];
        const geometry = this._skin(prevCircle, circle);
        geometries.push(geometry);
      }
    }
    if ((0,Type/* isBooleanTrue */.bI)(params.closed)) {
      const circle = circles[0];
      const prevCircle = circles[circles.length - 1];
      const geometry = this._skin(prevCircle, circle);
      geometries.push(geometry);
    }
  }
  _skin(geometry1, geometry0) {
    const geometry = new three_module.BufferGeometry();
    const operation = new CoreGeometryOperationSkin(geometry, geometry1, geometry0);
    operation.process();
    return geometry;
  }
}
PolywireSopOperation.DEFAULT_PARAMS = {
  radius: 1,
  segmentsRadial: 8,
  closed: true,
  attributesToCopy: "*"
};

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/sop/Polywire.ts






const Polywire_DEFAULT = PolywireSopOperation.DEFAULT_PARAMS;
class PolywireSopParamsConfig extends params_ParamsConfig/* NodeParamsConfig */.yI {
  constructor() {
    super(...arguments);
    /** @param radius */
    this.radius = params_ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(Polywire_DEFAULT.radius);
    /** @param segments count on the circle used */
    this.segmentsRadial = params_ParamsConfig/* ParamConfig.INTEGER */.XC.INTEGER(Polywire_DEFAULT.segmentsRadial, {
      range: [3, 20],
      rangeLocked: [true, false]
    });
    /** @param toggle on for the geometry to close back on itself */
    this.closed = params_ParamsConfig/* ParamConfig.BOOLEAN */.XC.BOOLEAN(Polywire_DEFAULT.closed);
    /** @param attributesToCopy */
    this.attributesToCopy = params_ParamsConfig/* ParamConfig.STRING */.XC.STRING(Polywire_DEFAULT.attributesToCopy);
  }
}
const Polywire_ParamsConfig = new PolywireSopParamsConfig();
class PolywireSopNode extends sop_Base/* TypedSopNode */.x {
  constructor() {
    super(...arguments);
    this.paramsConfig = Polywire_ParamsConfig;
  }
  static type() {
    return Sop/* SopType.POLYWIRE */.aB.POLYWIRE;
  }
  initializeNode() {
    this.io.inputs.setCount(1);
    this.io.inputs.initInputsClonedState(InputCloneMode/* InputCloneMode.NEVER */.m.NEVER);
  }
  cook(inputCoreGroups) {
    this._operation = this._operation || new PolywireSopOperation(this._scene, this.states, this);
    const coreGroup = this._operation.cook(inputCoreGroups, this.pv);
    this.setCoreGroup(coreGroup);
  }
}

// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/nodes/sop/_BaseQuad.ts
var _BaseQuad = __webpack_require__(84008);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/core/geometry/modules/quad/QuadPrimitive.ts + 1 modules
var QuadPrimitive = __webpack_require__(10407);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/core/geometry/entities/primitive/CorePrimitiveUtils.ts
var CorePrimitiveUtils = __webpack_require__(73416);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/core/geometry/modules/quad/utils/QuadUtils.ts + 1 modules
var QuadUtils = __webpack_require__(53260);
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/sop/QuadExtrude.ts










const QuadExtrude_normal = new three_module.Vector3();
const QuadExtrude_tmp = new three_module.Vector3();
const _primitives = [];
const _indices = {
  i0: 0,
  i1: 0,
  i2: 0,
  i3: 0
};
const QuadExtrude_positions = {
  p0: new three_module.Vector3(),
  p1: new three_module.Vector3(),
  p2: new three_module.Vector3(),
  p3: new three_module.Vector3()
};
const _insetPositions = {
  p0: new three_module.Vector3(),
  p1: new three_module.Vector3(),
  p2: new three_module.Vector3(),
  p3: new three_module.Vector3()
};
const _newPositions = [
  new three_module.Vector3(),
  new three_module.Vector3(),
  new three_module.Vector3(),
  new three_module.Vector3()
];
class QuadExtrudeSopParamsConfig extends params_ParamsConfig/* NodeParamsConfig */.yI {
  constructor() {
    super(...arguments);
    /** @param amount */
    this.amount = params_ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(0, {
      range: [-1, 1],
      rangeLocked: [false, false]
    });
    /** @param inset */
    this.inset = params_ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(0, {
      range: [-1, 1],
      rangeLocked: [false, false]
    });
    /** @param output side */
    this.sides = params_ParamsConfig/* ParamConfig.BOOLEAN */.XC.BOOLEAN(1);
  }
}
const QuadExtrude_ParamsConfig = new QuadExtrudeSopParamsConfig();
class QuadExtrudeSopNode extends _BaseQuad/* QuadSopNode */.Y {
  constructor() {
    super(...arguments);
    this.paramsConfig = QuadExtrude_ParamsConfig;
  }
  static type() {
    return Sop/* SopType.QUAD_EXTRUDE */.aB.QUAD_EXTRUDE;
  }
  initializeNode() {
    this.io.inputs.setCount(1);
    this.io.inputs.initInputsClonedState(InputCloneMode/* InputCloneMode.FROM_NODE */.m.FROM_NODE);
  }
  cook(inputCoreGroups) {
    const coreGroup = inputCoreGroups[0];
    const objects = coreGroup.quadObjects();
    if (!objects) {
      this.states.error.set(`no quad objects found`);
      return;
    }
    for (const object of objects) {
      this._extrudeObject(object);
    }
    this.setQuadObjects(objects);
  }
  _extrudeObject(quadObject) {
    (0,CorePrimitiveUtils/* primitivesFromObject */.Lp)(quadObject, _primitives);
    const originalPrimitivesCount = _primitives.length;
    const geometry = quadObject.geometry;
    const sides = this.pv.sides;
    const indices = geometry.index;
    let _newIndicesIndex = indices.length;
    indices.length += _primitives.length * 4 * (sides ? 5 : 1);
    const positionAttribute = geometry.attributes[geometry_Attribute/* Attribute.POSITION */.ah.POSITION];
    let newPointIndex = positionAttribute.array.length / 3;
    let newIndexValue = newPointIndex;
    const pointAttributeNames = Object.keys(geometry.attributes);
    const additionalPointsCount = _primitives.length * 4;
    for (const pointAttributeName of pointAttributeNames) {
      const attribute = geometry.attributes[pointAttributeName];
      const array = attribute.array;
      const additionalPointAttributeItemsCount = additionalPointsCount * attribute.itemSize;
      attribute.count += additionalPointsCount;
      const newValues = [...array];
      newValues.length += additionalPointAttributeItemsCount;
      attribute.array = new Float32Array(newValues);
    }
    const primitiveAttributes = QuadPrimitive/* QuadPrimitive.attributesFromGeometry */.C.attributesFromGeometry(geometry);
    const primitiveAttributeNames = primitiveAttributes ? Object.keys(primitiveAttributes) : null;
    if (primitiveAttributes && primitiveAttributeNames) {
      for (const primitiveAttributeName of primitiveAttributeNames) {
        const primitiveAttribute = primitiveAttributes[primitiveAttributeName];
        primitiveAttribute.array.length += _primitives.length;
      }
    }
    const vertexAttributes = QuadPrimitive/* QuadPrimitive.attributesFromGeometry */.C.attributesFromGeometry(geometry);
    const vertexAttributeNames = vertexAttributes ? Object.keys(vertexAttributes) : null;
    if (vertexAttributes && vertexAttributeNames) {
      for (const vertexAttributeName of vertexAttributeNames) {
        const vertexAttribute = vertexAttributes[vertexAttributeName];
        vertexAttribute.array.length += _primitives.length * 4;
      }
    }
    const positionArray = positionAttribute.array;
    let newPrimitivesCount = 0;
    for (const primitive of _primitives) {
      primitive.normal(QuadExtrude_normal);
      const primitiveIndex = primitive.index();
      (0,QuadUtils/* quadPrimitivePointIndices */.LE)(quadObject, primitiveIndex, _indices);
      (0,QuadUtils/* quadPrimitivePointPositions */.Np)(quadObject, primitiveIndex, QuadExtrude_positions);
      (0,QuadUtils/* quadPointInset */.Tu)(QuadExtrude_positions, this.pv.inset, _insetPositions);
      QuadExtrude_tmp.copy(QuadExtrude_normal).multiplyScalar(this.pv.amount);
      _newPositions[0].copy(_insetPositions.p0).add(QuadExtrude_tmp);
      _newPositions[1].copy(_insetPositions.p1).add(QuadExtrude_tmp);
      _newPositions[2].copy(_insetPositions.p2).add(QuadExtrude_tmp);
      _newPositions[3].copy(_insetPositions.p3).add(QuadExtrude_tmp);
      const _setPrimitiveAttributes = (targetIndex) => {
        if (!(primitiveAttributes && primitiveAttributeNames)) {
          return;
        }
        for (const primitiveAttributeName of primitiveAttributeNames) {
          const primitiveAttribute = primitiveAttributes[primitiveAttributeName];
          const array = primitiveAttribute.array;
          const itemSize = primitiveAttribute.itemSize;
          for (let k = 0; k < itemSize; k++) {
            const srcIndex = primitiveIndex * itemSize + k;
            const destIndex = targetIndex * itemSize + k;
            array[destIndex] = array[srcIndex];
          }
        }
      };
      const currentPrimitiveIndex = _newIndicesIndex;
      indices[_newIndicesIndex] = newIndexValue;
      indices[_newIndicesIndex + 1] = newIndexValue + 1;
      indices[_newIndicesIndex + 2] = newIndexValue + 2;
      indices[_newIndicesIndex + 3] = newIndexValue + 3;
      _setPrimitiveAttributes(originalPrimitivesCount + newPrimitivesCount);
      _newIndicesIndex += 4;
      newPrimitivesCount++;
      if (sides == true) {
        indices[_newIndicesIndex] = _indices.i0;
        indices[_newIndicesIndex + 1] = _indices.i1;
        indices[_newIndicesIndex + 2] = indices[currentPrimitiveIndex + 1];
        indices[_newIndicesIndex + 3] = indices[currentPrimitiveIndex];
        _setPrimitiveAttributes(originalPrimitivesCount + newPrimitivesCount);
        _newIndicesIndex += 4;
        newPrimitivesCount++;
        indices[_newIndicesIndex] = _indices.i1;
        indices[_newIndicesIndex + 1] = _indices.i2;
        indices[_newIndicesIndex + 2] = indices[currentPrimitiveIndex + 2];
        indices[_newIndicesIndex + 3] = indices[currentPrimitiveIndex + 1];
        _setPrimitiveAttributes(originalPrimitivesCount + newPrimitivesCount);
        _newIndicesIndex += 4;
        newPrimitivesCount++;
        indices[_newIndicesIndex] = _indices.i2;
        indices[_newIndicesIndex + 1] = _indices.i3;
        indices[_newIndicesIndex + 2] = indices[currentPrimitiveIndex + 3];
        indices[_newIndicesIndex + 3] = indices[currentPrimitiveIndex + 2];
        _setPrimitiveAttributes(originalPrimitivesCount + newPrimitivesCount);
        _newIndicesIndex += 4;
        newPrimitivesCount++;
        indices[_newIndicesIndex] = _indices.i3;
        indices[_newIndicesIndex + 1] = _indices.i0;
        indices[_newIndicesIndex + 2] = indices[currentPrimitiveIndex];
        indices[_newIndicesIndex + 3] = indices[currentPrimitiveIndex + 3];
        _setPrimitiveAttributes(originalPrimitivesCount + newPrimitivesCount);
        _newIndicesIndex += 4;
        newPrimitivesCount++;
      }
      const _pointIndex = (_i) => {
        switch (_i) {
          case 0:
            return _indices.i0;
          case 1:
            return _indices.i1;
          case 2:
            return _indices.i2;
          case 3:
            return _indices.i3;
        }
        return -1;
      };
      let i = 0;
      for (const newPosition of _newPositions) {
        for (const pointAttributeName of pointAttributeNames) {
          if (pointAttributeName == geometry_Attribute/* Attribute.POSITION */.ah.POSITION) {
            continue;
          }
          const attribute = geometry.attributes[pointAttributeName];
          const array = attribute.array;
          const itemSize = attribute.itemSize;
          for (let k = 0; k < itemSize; k++) {
            const pointIndex = _pointIndex(i);
            const srcIndex = pointIndex * itemSize + k;
            const destIndex = newPointIndex * itemSize + k;
            array[destIndex] = array[srcIndex];
          }
        }
        newPosition.toArray(positionArray, newPointIndex * 3);
        newPointIndex++;
        i++;
      }
      newIndexValue += 4;
    }
  }
}

// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/core/geometry/modules/quad/QuadGeometry.ts
var QuadGeometry = __webpack_require__(32534);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/core/geometry/modules/quad/QuadObject.ts + 1 modules
var QuadObject = __webpack_require__(11714);
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/sop/QuadPlane.ts









const QuadPlane_v3 = new three_module.Vector3();
const _m4R = new three_module.Matrix4();
const _m4T = new three_module.Matrix4();
const QuadPlane_m4 = new three_module.Matrix4();
const _dirOrigin = new three_module.Vector3(0, 1, 0);
class QuadPlaneSopParamsConfig extends params_ParamsConfig/* NodeParamsConfig */.yI {
  constructor() {
    super(...arguments);
    /** @param sizes */
    this.size = params_ParamsConfig/* ParamConfig.VECTOR2 */.XC.VECTOR2([1, 1]);
    /** @param defines if the plane resolution is sets via the number of segments or via the step size */
    this.useSegmentsCount = params_ParamsConfig/* ParamConfig.BOOLEAN */.XC.BOOLEAN(0);
    /** @param step size */
    this.stepSize = params_ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(1, {
      range: [1e-3, 2],
      rangeLocked: [false, false],
      visibleIf: { useSegmentsCount: 0 }
    });
    /** @param segments count */
    this.segments = params_ParamsConfig/* ParamConfig.VECTOR2 */.XC.VECTOR2([1, 1], { visibleIf: { useSegmentsCount: 1 } });
    /** @param axis perpendicular to the plane */
    this.direction = params_ParamsConfig/* ParamConfig.VECTOR3 */.XC.VECTOR3([0, 1, 0]);
    /** @param center of the plane */
    this.center = params_ParamsConfig/* ParamConfig.VECTOR3 */.XC.VECTOR3([0, 0, 0]);
  }
}
const QuadPlane_ParamsConfig = new QuadPlaneSopParamsConfig();
class QuadPlaneSopNode extends _BaseQuad/* QuadSopNode */.Y {
  constructor() {
    super(...arguments);
    this.paramsConfig = QuadPlane_ParamsConfig;
  }
  static type() {
    return Sop/* SopType.QUAD_PLANE */.aB.QUAD_PLANE;
  }
  cook(inputCoreGroups) {
    const geometry = this.pv.useSegmentsCount ? this._createWithSegmentsCount() : this._createWithStepSize();
    const center = this.pv.center;
    (0,Transform/* rotationMatrix */.k8)(_dirOrigin, this.pv.direction, _m4R);
    _m4T.makeTranslation(center.x, center.y, center.z);
    QuadPlane_m4.multiplyMatrices(_m4T, _m4R);
    geometry.applyMatrix(QuadPlane_m4);
    const object = new QuadObject/* QuadObject */.n(geometry);
    object.name = this.name();
    this.setQuadObject(object);
  }
  _createWithStepSize() {
    const { size, stepSize } = this.pv;
    const segmentsX = Math.round(size.x / stepSize);
    const segmentsY = Math.round(size.y / stepSize);
    return this._createQuadPlane(segmentsX, segmentsY);
  }
  _createWithSegmentsCount() {
    const { segments } = this.pv;
    const segmentsX = Math.round(segments.x);
    const segmentsY = Math.round(segments.y);
    return this._createQuadPlane(segmentsX, segmentsY);
  }
  _createQuadPlane(segmentsX, segmentsY) {
    const { size } = this.pv;
    const geometry = new QuadGeometry/* QuadGeometry */.$();
    const quadsCountX = segmentsX;
    const quadsCountY = segmentsY;
    const pointsCountX = quadsCountX + 1;
    const pointsCountY = quadsCountY + 1;
    const quadsCount = quadsCountX * quadsCountY;
    const positionsCount = pointsCountX * pointsCountY;
    const positions = new Array(positionsCount * 3);
    const indices = new Array(4);
    for (let x = 0; x < pointsCountX; x++) {
      for (let y = 0; y < pointsCountY; y++) {
        const i = x * pointsCountY + y;
        QuadPlane_v3.set((x / segmentsX - 0.5) * size.x, 0, (y / segmentsY - 0.5) * size.y);
        QuadPlane_v3.toArray(positions, i * 3);
      }
    }
    for (let i = 0; i < quadsCount; i++) {
      const x = i % quadsCountX;
      const y = Math.floor(i / quadsCountX);
      const i0 = x * pointsCountY + y;
      const i1 = i0 + 1;
      const i2 = i0 + pointsCountY;
      const i3 = i2 + 1;
      const quadIndex = i * 4;
      indices[quadIndex] = i0;
      indices[quadIndex + 1] = i1;
      indices[quadIndex + 2] = i3;
      indices[quadIndex + 3] = i2;
    }
    const position = new three_module.BufferAttribute(new Float32Array(positions), 3);
    geometry.setAttribute(geometry_Attribute/* Attribute.POSITION */.ah.POSITION, position);
    geometry.setIndex(indices);
    return geometry;
  }
}

// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/nodes/sop/QuadSmooth.ts
var QuadSmooth = __webpack_require__(11044);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/nodes/sop/QuadTriangulate.ts
var QuadTriangulate = __webpack_require__(72926);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/nodes/sop/Quadrangulate.ts + 5 modules
var Quadrangulate = __webpack_require__(40880);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/nodes/sop/Ray.ts
var Ray = __webpack_require__(13200);
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/operations/sop/Reflector.ts


const Reflector_DEFAULT_PARAMS = {
  direction: new three_module.Vector3(0, 1, 0),
  directionOffset: 0,
  active: true,
  clipBias: 3e-3,
  color: new three_module.Color(1, 1, 1),
  opacity: 1,
  useVertexColor: false,
  reflectionBlend: 1,
  pixelRatio: 1,
  multisamples: 4,
  tblur: false,
  blur: 1,
  verticalBlurMult: 1,
  tblur2: false,
  blur2: 1,
  verticalBlur2Mult: 1
};

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/modules/core/objects/reflector/vert.glsl
/* harmony default export */ var reflector_vert = ("uniform mat4 textureMatrix;\nvarying vec4 vUv;\nvarying vec3 vertexColor;\nattribute vec3 color;\n\nvoid main() {\n\n\tvUv = textureMatrix * vec4( position, 1.0 );\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\tvertexColor = color;\n}");
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/modules/core/objects/reflector/frag.glsl
/* harmony default export */ var reflector_frag = ("uniform bool useVertexColor;\nuniform vec3 globalColor;\nuniform sampler2D tDiffuse;\nvarying vec4 vUv;\nuniform float opacity;\nuniform float reflectionBlend;\nvarying vec3 vertexColor;\n\n#include <logdepthbuf_pars_fragment>\n\nfloat blendOverlay( float base, float blend ) {\n\n\treturn( base < 0.5 ? ( 2.0 * base * blend ) : ( 1.0 - 2.0 * ( 1.0 - base ) * ( 1.0 - blend ) ) );\n\n}\n\nvec3 blendOverlay( vec3 base, vec3 blend ) {\n\n\treturn vec3( blendOverlay( base.r, blend.r ), blendOverlay( base.g, blend.g ), blendOverlay( base.b, blend.b ) );\n\n}\n// TODO: add fresnel to blend with another material (maybe integrate this with material builders?)\n// TODO: use fresnel to modulate alpha, so that we can see through when viewed at perpendicular angle, but not parallel\nvoid main() {\n\n\t#include <logdepthbuf_fragment>\n\n\tvec3 definedColor = useVertexColor ? vertexColor * globalColor : globalColor;\n\tvec3 base = texture2DProj( tDiffuse, vUv ).rgb * definedColor;\n\t// gl_FragColor = vec4( blendOverlay( base.rgb, color ), opacity );\n\tvec3 finalColor = reflectionBlend * base + (1.-reflectionBlend) * definedColor;\n\tgl_FragColor = vec4( finalColor, opacity );\n\n}");
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/modules/core/objects/Reflector.ts





const ReflectorShader = {
  uniforms: {
    useVertexColor: {
      value: null
    },
    globalColor: {
      value: null
    },
    tDiffuse: {
      value: null
    },
    textureMatrix: {
      value: null
    },
    opacity: {
      value: 0.5
    },
    reflectionBlend: {
      value: 1
    }
  },
  vertexShader: reflector_vert,
  fragmentShader: reflector_frag
};
class Reflector extends BaseReflector {
  constructor(geometry, _options) {
    super(geometry, _options);
    this.geometry = geometry;
    this._options = _options;
  }
  _createMaterial() {
    const material = new three_module.ShaderMaterial({
      uniforms: three_module.UniformsUtils.clone(ReflectorShader.uniforms),
      fragmentShader: ReflectorShader.fragmentShader,
      vertexShader: ReflectorShader.vertexShader
    });
    material.uniforms["useVertexColor"].value = this._options.useVertexColor;
    material.uniforms["globalColor"].value = this._options.color;
    material.uniforms["textureMatrix"].value = this.textureMatrix;
    material.uniforms["opacity"].value = this._options.opacity;
    material.uniforms["reflectionBlend"].value = this._options.reflectionBlend;
    material.transparent = this._options.opacity < 1;
    return material;
  }
  _assignMaterialRenderTarget() {
    if (this.renderTarget) {
      this.material.uniforms["tDiffuse"].value = this.renderTarget.texture;
    }
  }
  // override clone(recursive: boolean): this {
  // 	// we clone so that a cloned reflector does not share the same color
  // 	const clonedOptions = {...this._options};
  // 	clonedOptions.color = this._options.color.clone();
  // 	const clonedGeometry = this.geometry.clone();
  // 	const clonedReflector = new Reflector(clonedGeometry, clonedOptions);
  // 	const {material} = clonedReflector;
  // 	clonedReflector.copy(this, recursive);
  // 	// the material and geometry needs to be added back after the copy, as Mesh.copy would override that
  // 	clonedReflector.material = material;
  // 	clonedReflector.geometry = clonedGeometry;
  // 	clonedReflector.updateMatrix();
  // 	return clonedReflector as this;
  // }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/sop/Reflector.ts










const Reflector_DEFAULT = Reflector_DEFAULT_PARAMS;
const Reflector_v3 = new three_module.Vector3();
class ReflectorSopParamsConfig extends params_ParamsConfig/* NodeParamsConfig */.yI {
  constructor() {
    super(...arguments);
    /** @param direction the objects reflects */
    this.direction = params_ParamsConfig/* ParamConfig.VECTOR3 */.XC.VECTOR3(Reflector_DEFAULT.direction.toArray());
    /** @param direction offset */
    this.directionOffset = params_ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(Reflector_DEFAULT.directionOffset, {
      range: [-1, 1],
      rangeLocked: [false, false]
    });
    /** @param when active is off, the mirror is not rendered */
    this.active = params_ParamsConfig/* ParamConfig.BOOLEAN */.XC.BOOLEAN(Reflector_DEFAULT.active);
    /** @param bias to ensure the mirror does not reflect itself */
    this.clipBias = params_ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(Reflector_DEFAULT.clipBias);
    /** @param color */
    this.color = params_ParamsConfig/* ParamConfig.COLOR */.XC.COLOR(Reflector_DEFAULT.color.toArray());
    /** @param useVertexColor */
    this.useVertexColor = params_ParamsConfig/* ParamConfig.BOOLEAN */.XC.BOOLEAN(Reflector_DEFAULT.useVertexColor);
    /** @param reflectionBlend */
    this.reflectionBlend = params_ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(Reflector_DEFAULT.reflectionBlend);
    /** @param pixelRatio */
    /** @param opacity */
    this.opacity = params_ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(Reflector_DEFAULT.opacity);
    this.pixelRatio = params_ParamsConfig/* ParamConfig.INTEGER */.XC.INTEGER(Reflector_DEFAULT.pixelRatio, {
      range: [1, 4],
      rangeLocked: [true, false]
    });
    /** @param multisamples */
    this.multisamples = params_ParamsConfig/* ParamConfig.INTEGER */.XC.INTEGER(Reflector_DEFAULT.multisamples, {
      range: [0, 4],
      rangeLocked: [true, false]
    });
    /** @param toggle to activate blur */
    this.tblur = params_ParamsConfig/* ParamConfig.BOOLEAN */.XC.BOOLEAN(Reflector_DEFAULT.tblur);
    /** @param blur amount */
    this.blur = params_ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(Reflector_DEFAULT.blur, {
      visibleIf: { tblur: 1 }
    });
    /** @param vertical blur multiplier */
    this.verticalBlurMult = params_ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(Reflector_DEFAULT.verticalBlurMult, {
      visibleIf: { tblur: 1 }
    });
    /** @param toggle to activate a second blur, which can be useful to reduce artefacts */
    this.tblur2 = params_ParamsConfig/* ParamConfig.BOOLEAN */.XC.BOOLEAN(Reflector_DEFAULT.tblur2, {
      visibleIf: { tblur: 1 }
    });
    /** @param blur2 amount */
    this.blur2 = params_ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(Reflector_DEFAULT.blur2, {
      visibleIf: { tblur: 1, tblur2: 1 }
    });
    /** @param vertical blur2 multiplier */
    this.verticalBlur2Mult = params_ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(Reflector_DEFAULT.verticalBlur2Mult, {
      visibleIf: { tblur: 1, tblur2: 1 }
    });
  }
}
const Reflector_ParamsConfig = new ReflectorSopParamsConfig();
class ReflectorSopNode extends sop_Base/* TypedSopNode */.x {
  constructor() {
    super(...arguments);
    this.paramsConfig = Reflector_ParamsConfig;
  }
  static type() {
    return Sop/* SopType.REFLECTOR */.aB.REFLECTOR;
  }
  initializeNode() {
    this.io.inputs.setCount(1);
    this.io.inputs.initInputsClonedState(InputCloneMode/* InputCloneMode.FROM_NODE */.m.FROM_NODE);
  }
  cook(inputCoreGroups) {
    const coreGroup = inputCoreGroups[0];
    const objects = coreGroup.threejsObjectsWithGeo();
    for (const object of objects) {
      Poly/* Poly.onObjectsAddRemoveHooks.assignOnAddHookHandler */.L.onObjectsAddRemoveHooks.assignOnAddHookHandler(object, this);
    }
    this.setCoreGroup(coreGroup);
  }
  updateObjectOnAdd(object, parent) {
    const _geometry = object.geometry;
    if (!_geometry) {
      return;
    }
    const clonedGeometry = _geometry.clone();
    const renderer = this.scene().renderersRegister.lastRegisteredRenderer();
    Reflector_v3.copy(this.pv.direction).normalize().multiplyScalar(this.pv.directionOffset);
    clonedGeometry.translate(-Reflector_v3.x, -Reflector_v3.y, -Reflector_v3.z);
    Reflector.rotateGeometry(clonedGeometry, this.pv.direction);
    const reflector = new Reflector(clonedGeometry, {
      clipBias: this.pv.clipBias,
      renderer,
      scene: this.scene().threejsScene(),
      pixelRatio: this.pv.pixelRatio,
      multisamples: this.pv.multisamples,
      color: this.pv.color,
      opacity: this.pv.opacity,
      useVertexColor: this.pv.useVertexColor,
      reflectionBlend: this.pv.reflectionBlend,
      active: this.pv.active,
      tblur: this.pv.tblur,
      blur: this.pv.blur,
      verticalBlurMult: this.pv.verticalBlurMult,
      tblur2: this.pv.tblur2,
      blur2: this.pv.blur2,
      verticalBlur2Mult: this.pv.verticalBlur2Mult
    });
    reflector.matrixAutoUpdate = false;
    object.matrix.decompose(object.position, object.quaternion, object.scale);
    Reflector_v3.add(object.position);
    reflector.position.copy(Reflector_v3);
    reflector.rotation.copy(object.rotation);
    reflector.scale.copy(object.scale);
    reflector.updateMatrix();
    Reflector.compensateGeometryRotation(reflector, this.pv.direction);
    (0,PolyOnObjectsAddRemoveHooksController/* replaceChild */.rS)(parent, object, reflector);
  }
}

// EXTERNAL MODULE: ../@polygonjs/polygonjs/node_modules/three/examples/jsm/utils/BufferGeometryUtils.js
var BufferGeometryUtils = __webpack_require__(80993);
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/sop/Resample.ts









var METHOD = /* @__PURE__ */ ((METHOD2) => {
  METHOD2["POINTS_COUNT"] = "pointsCount";
  METHOD2["SEGMENT_LENGTH"] = "segmentLength";
  return METHOD2;
})(METHOD || {});
const METHODS = ["pointsCount" /* POINTS_COUNT */, "segmentLength" /* SEGMENT_LENGTH */];






const Resample_points = [];
class ResampleSopParamsConfig extends params_ParamsConfig/* NodeParamsConfig */.yI {
  constructor() {
    super(...arguments);
    /** @param resampling method */
    this.method = params_ParamsConfig/* ParamConfig.INTEGER */.XC.INTEGER(METHODS.indexOf("pointsCount" /* POINTS_COUNT */), {
      menu: {
        entries: METHODS.map((name, i) => {
          return {
            name,
            value: i
          };
        })
      }
    });
    /** @param type of curve this will generate */
    this.curveType = params_ParamsConfig/* ParamConfig.INTEGER */.XC.INTEGER(SPLINE_CURVE_TYPES.indexOf(SplineCurveType.CATMULLROM), {
      range: [0, 2],
      rangeLocked: [true, true],
      menu: {
        entries: SPLINE_CURVE_TYPES.map((name, i) => {
          return {
            name,
            value: i
          };
        })
      }
    });
    /** @param curve tension */
    this.tension = params_ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(0.01, {
      range: [0, 1],
      rangeLocked: [true, true],
      visibleIf: { curveType: SPLINE_CURVE_TYPES.indexOf(SplineCurveType.CATMULLROM) }
    });
    /** @param points count */
    this.pointsCount = params_ParamsConfig/* ParamConfig.INTEGER */.XC.INTEGER(100, {
      visibleIf: { method: METHODS.indexOf("pointsCount" /* POINTS_COUNT */) },
      range: [1, 1e3],
      rangeLocked: [true, false]
    });
    /** @param segments length */
    this.segmentLength = params_ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(1, {
      visibleIf: { method: METHODS.indexOf("segmentLength" /* SEGMENT_LENGTH */) }
    });
  }
}
const Resample_ParamsConfig = new ResampleSopParamsConfig();
class ResampleSopNode extends sop_Base/* TypedSopNode */.x {
  constructor() {
    super(...arguments);
    this.paramsConfig = Resample_ParamsConfig;
  }
  static type() {
    return "resample";
  }
  initializeNode() {
    this.io.inputs.setCount(1);
    this.io.inputs.initInputsClonedState(InputCloneMode/* InputCloneMode.NEVER */.m.NEVER);
  }
  cook(inputCoreGroups) {
    const coreGroup = inputCoreGroups[0];
    const resampledObjects = [];
    if (this.pv.pointsCount >= 2) {
      const coreObjects = coreGroup.threejsCoreObjects();
      for (const coreObject of coreObjects) {
        const object = coreObject.object();
        if (object instanceof three_module.LineSegments) {
          const resampledObject = this._resample(object);
          if (resampledObject) {
            resampledObjects.push(resampledObject);
          }
        }
      }
    }
    this.setObjects(resampledObjects);
  }
  setCurveType(curveType) {
    this.p.curveType.set(SPLINE_CURVE_TYPES.indexOf(curveType));
  }
  _resample(lineSegment) {
    var _a;
    const geometry = lineSegment.geometry;
    (0,CorePointUtils/* pointsFromObject */.u_)(lineSegment, Resample_points);
    const indices = (_a = geometry.getIndex()) == null ? void 0 : _a.array;
    if (!indices) {
      return;
    }
    const accumulated_curve_point_indices = CoreGeometryUtilCurve.accumulatedCurvePointIndices(indices);
    const geometries = [];
    for (let i = 0; i < accumulated_curve_point_indices.length; i++) {
      const curve_point_indices = accumulated_curve_point_indices[i];
      const current_points = curve_point_indices.map((index) => Resample_points[index]);
      const geometry2 = this._create_curve_from_points(current_points);
      if (geometry2) {
        geometries.push(geometry2);
      }
    }
    const mergedGeometry = (0,BufferGeometryUtils/* mergeGeometries */.n4)(geometries);
    const object = this.createObject(mergedGeometry, Constant/* ObjectType.LINE_SEGMENTS */.LP.LINE_SEGMENTS);
    return object;
  }
  _create_curve_from_points(points) {
    if (points.length <= 1) {
      return;
    }
    const old_curve_positions = points.map((point) => point.attribValue(geometry_Attribute/* Attribute.POSITION */.ah.POSITION));
    const closed = false;
    const curveType = SPLINE_CURVE_TYPES[this.pv.curveType];
    const tension = this.pv.tension;
    const curve = new three_module.CatmullRomCurve3(old_curve_positions, closed, curveType, tension);
    const new_curve_points = this._get_points_from_curve(curve);
    let positions = [];
    const indices = [];
    for (let i = 0; i < new_curve_points.length; i++) {
      const point_position = new_curve_points[i];
      const position = point_position.toArray();
      positions.push(position);
      if (i > 0) {
        indices.push(i - 1);
        indices.push(i);
      }
    }
    const geometry = new three_module.BufferGeometry();
    geometry.setAttribute("position", new three_module.Float32BufferAttribute(positions.flat(), 3));
    geometry.setIndex(indices);
    return geometry;
  }
  _get_points_from_curve(curve) {
    const method = METHODS[this.pv.method];
    switch (method) {
      case "pointsCount" /* POINTS_COUNT */:
        return curve.getSpacedPoints(Math.max(2, this.pv.pointsCount));
      case "segmentLength" /* SEGMENT_LENGTH */:
        var length = curve.getLength();
        var pointsCount = this.pv.segmentLength !== 0 ? 1 + length / this.pv.segmentLength : 2;
        pointsCount = Math.max(2, pointsCount);
        return curve.getSpacedPoints(pointsCount);
    }
    Assert/* TypeAssert.unreachable */.f.unreachable(method);
  }
}

// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/nodes/sop/RestAttributes.ts
var RestAttributes = __webpack_require__(94654);
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/operations/sop/Ring.ts





const Ring_DEFAULT_UP = new three_module.Vector3(0, 0, 1);
const _RingSopOperation = class extends operations_sop_Base/* BaseSopOperation */.U {
  // static override readonly INPUT_CLONED_STATE = InputCloneMode.NEVER;
  static type() {
    return "ring";
  }
  cook(inputCoreGroups, params) {
    const object = this._cookWithoutInput(params);
    if (this._node) {
      object.name = this._node.name();
    }
    return this.createCoreGroupFromObjects([object]);
  }
  _cookWithoutInput(params) {
    const geometry = this._createRequiredGeometry(params);
    (0,Transform/* rotateGeometry */.bP)(geometry, Ring_DEFAULT_UP, params.direction);
    geometry.translate(params.center.x, params.center.y, params.center.z);
    const object = this._createRingObject(geometry, params);
    return object;
  }
  // private _cookWithInput(coreGroup: CoreGroup, params: RingSopParams) {
  // 	const bboxPreRotation = coreGroup.boundingBox();
  // 	bboxPreRotation.getCenter(center);
  // 	// create box
  // 	const bbox = coreGroup.boundingBox();
  // 	size.copy(bbox.max).sub(bbox.min);
  // 	center.copy(bbox.max).add(bbox.min).multiplyScalar(0.5);
  // 	const boxGeometry = new BoxGeometry(size.x, size.y, size.z, 1, 1, 1);
  // 	// rotate box
  // 	function _applyInputQuaternion(_q: Quaternion) {
  // 		boxGeometry.applyQuaternion(_q);
  // 		boxGeometry.computeBoundingBox();
  // 	}
  // 	function _setInputRotation() {
  // 		q.setFromUnitVectors(DEFAULT_UP, params.direction);
  // 		_applyInputQuaternion(q);
  // 	}
  // 	// function _resetInputRotation() {
  // 	// 	q.invert();
  // 	// 	_applyInputQuaternion(q);
  // 	// }
  // 	_setInputRotation();
  // 	const bboxPostRotation = boxGeometry.boundingBox!; //coreGroup.boundingBox(true);
  // 	bboxPostRotation.getSize(size);
  // 	// bboxPreRotation.getCenter(center); // debug
  // 	// _resetInputRotation();
  // 	const size2d = new Vector2(size.x, size.y);
  // 	const geometry = this._createRequiredGeometry(size2d, params);
  // 	this._coreTransform.rotateGeometry(geometry, DEFAULT_UP, params.direction);
  // 	geometry.translate(center.x, center.y, center.z);
  // 	const object = this._createRingObject(geometry, params);
  // 	return object;
  // }
  _createRingObject(geometry, params) {
    return operations_sop_Base/* BaseSopOperation.createObject */.U.createObject(geometry, params.asLines ? Constant/* ObjectType.LINE_SEGMENTS */.LP.LINE_SEGMENTS : Constant/* ObjectType.MESH */.LP.MESH);
  }
  _createRequiredGeometry(params) {
    return new three_module.RingGeometry(
      params.innerRadius,
      params.outerRadius,
      params.thetaSegments,
      params.phiSegments,
      params.open ? params.angleStart : 0,
      params.open ? params.angleLength : _RingSopOperation.DEFAULT_PARAMS.angleLength
    );
  }
};
let RingSopOperation = _RingSopOperation;
RingSopOperation.DEFAULT_PARAMS = {
  innerRadius: 0.5,
  outerRadius: 1,
  thetaSegments: 32,
  phiSegments: 2,
  open: false,
  angleStart: 0,
  angleLength: 2 * Math.PI,
  direction: new three_module.Vector3(0, 1, 0),
  center: new three_module.Vector3(0, 0, 0)
};

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/sop/Ring.ts





const Ring_DEFAULT = RingSopOperation.DEFAULT_PARAMS;
const step = 1e-5;
class RingSopParamsConfig extends params_ParamsConfig/* NodeParamsConfig */.yI {
  constructor() {
    super(...arguments);
    /** @param inner radius of the ring */
    this.innerRadius = params_ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(Ring_DEFAULT.innerRadius);
    /** @param outer radius of the ring */
    this.outerRadius = params_ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(Ring_DEFAULT.outerRadius);
    /** @param segments count */
    this.thetaSegments = params_ParamsConfig/* ParamConfig.INTEGER */.XC.INTEGER(Ring_DEFAULT.thetaSegments, {
      range: [0, 128],
      rangeLocked: [true, false]
    });
    /** @param segments count */
    this.phiSegments = params_ParamsConfig/* ParamConfig.INTEGER */.XC.INTEGER(Ring_DEFAULT.phiSegments, {
      range: [0, 4],
      rangeLocked: [true, false]
    });
    /** @param if set to 1, you can then set the phiStart, phi_end, thetaStart and theta_end */
    this.open = params_ParamsConfig/* ParamConfig.BOOLEAN */.XC.BOOLEAN(Ring_DEFAULT.open);
    /** @param start of phi angle */
    this.angleStart = params_ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(Ring_DEFAULT.angleStart, {
      range: [0, Math.PI * 2],
      step,
      visibleIf: { open: true }
    });
    /** @param length of phi opening */
    this.angleLength = params_ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT("$PI*2", {
      range: [0, Math.PI * 2],
      step,
      visibleIf: { open: true }
    });
    /** @param axis perpendicular to the plane */
    this.direction = params_ParamsConfig/* ParamConfig.VECTOR3 */.XC.VECTOR3(Ring_DEFAULT.direction, {
      separatorBefore: true
    });
    /** @param center of the plane */
    this.center = params_ParamsConfig/* ParamConfig.VECTOR3 */.XC.VECTOR3(Ring_DEFAULT.center);
  }
}
const Ring_ParamsConfig = new RingSopParamsConfig();
class RingSopNode extends sop_Base/* TypedSopNode */.x {
  constructor() {
    super(...arguments);
    this.paramsConfig = Ring_ParamsConfig;
  }
  static type() {
    return Sop/* SopType.RING */.aB.RING;
  }
  initializeNode() {
    this.io.inputs.setCount(0);
  }
  cook(inputCoreGroups) {
    this._operation = this._operation || new RingSopOperation(this.scene(), this.states, this);
    const core_group = this._operation.cook(inputCoreGroups, this.pv);
    this.setCoreGroup(core_group);
  }
}

// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/nodes/sop/RoundedBox.ts
var RoundedBox = __webpack_require__(79259);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/nodes/sop/Scatter.ts
var Scatter = __webpack_require__(27881);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/nodes/sop/SDFBuilder.ts + 3 modules
var SDFBuilder = __webpack_require__(84734);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/nodes/sop/SetChildren.ts
var SetChildren = __webpack_require__(35730);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/nodes/sop/SetGeometry.ts
var SetGeometry = __webpack_require__(58420);
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/operations/sop/Shear.ts








var ShearMode = /* @__PURE__ */ ((ShearMode2) => {
  ShearMode2["MATRIX"] = "matrix";
  ShearMode2["AXIS"] = "axis";
  return ShearMode2;
})(ShearMode || {});
const SHEAR_MODES = ["matrix" /* MATRIX */, "axis" /* AXIS */];
var ShearCenterMode = /* @__PURE__ */ ((ShearCenterMode2) => {
  ShearCenterMode2["BBOX_CENTER"] = "bbox center";
  ShearCenterMode2["BBOX_CENTER_OFFSET"] = "bbox center offset";
  ShearCenterMode2["CUSTOM"] = "custom";
  return ShearCenterMode2;
})(ShearCenterMode || {});
const SHEAR_CENTER_MODES = [
  "bbox center" /* BBOX_CENTER */,
  "bbox center offset" /* BBOX_CENTER_OFFSET */,
  "custom" /* CUSTOM */
];
const Shear_points = [];
class ShearSopOperation extends operations_sop_Base/* BaseSopOperation */.U {
  constructor() {
    super(...arguments);
    this._m4 = new three_module.Matrix4();
    this._axisNormalized = new three_module.Vector3();
    this._center = new three_module.Vector3();
    this._pointPos = new three_module.Vector3();
    this._axisPlane = new three_module.Plane();
    this._pointOnPlane = new three_module.Vector3();
    this._delta = new three_module.Vector3();
    this._deltaNormalized = new three_module.Vector3();
    this._offset = new three_module.Vector3();
  }
  static type() {
    return "shear";
  }
  cook(input_contents, params) {
    const objects = input_contents[0].threejsObjects();
    this._applyShear(objects, params);
    return input_contents[0];
  }
  _applyShear(objects, params) {
    const mode = SHEAR_MODES[params.mode];
    switch (mode) {
      case "matrix" /* MATRIX */: {
        return this._applyMatrixShear(objects, params);
      }
      case "axis" /* AXIS */: {
        return this._applyAxisShear(objects, params);
      }
    }
    Assert/* TypeAssert.unreachable */.f.unreachable(mode);
  }
  _applyMatrixShear(objects, params) {
    this._m4.makeShear(params.xy, params.xz, params.yx, params.yz, params.zx, params.zy);
    for (let object of objects) {
      const mesh = object;
      const geometry = mesh.geometry;
      if (geometry) {
        geometry.applyMatrix4(this._m4);
      }
    }
  }
  _applyAxisShear(objects, params) {
    this._axisNormalized.copy(params.axis);
    this._axisNormalized.normalize();
    for (let object of objects) {
      const mesh = object;
      const geometry = mesh.geometry;
      if (geometry) {
        this._getAxisModeCenter(geometry, params);
        this._axisPlane.setFromNormalAndCoplanarPoint(params.planeAxis, this._center);
        (0,CorePointUtils/* pointsFromObject */.u_)(object, Shear_points);
        for (const point of Shear_points) {
          point.position(this._pointPos);
          this._axisPlane.projectPoint(this._pointPos, this._pointOnPlane);
          this._delta.copy(this._pointOnPlane).sub(this._pointPos);
          const distToPlane = this._delta.length();
          this._deltaNormalized.copy(this._delta).normalize();
          this._offset.copy(this._axisNormalized).multiplyScalar(params.axisAmount * distToPlane);
          if (this._delta.dot(params.planeAxis) > 0) {
            this._offset.multiplyScalar(-1);
          }
          this._pointPos.add(this._offset);
          point.setPosition(this._pointPos);
        }
      }
    }
  }
  _getAxisModeCenter(geometry, params) {
    const mode = SHEAR_CENTER_MODES[params.centerMode];
    switch (mode) {
      case "bbox center" /* BBOX_CENTER */: {
        return this._getAxisModeCenterBbox(geometry, params);
      }
      case "bbox center offset" /* BBOX_CENTER_OFFSET */: {
        return this._getAxisModeCenterBboxOffset(geometry, params);
      }
      case "custom" /* CUSTOM */: {
        return this._getAxisModeCenterCustom(params);
      }
    }
    Assert/* TypeAssert.unreachable */.f.unreachable(mode);
  }
  _getAxisModeCenterBbox(geometry, params) {
    geometry.computeBoundingBox();
    const box = geometry.boundingBox;
    if (box) {
      box.getCenter(this._center);
    } else {
      this._center.set(0, 0, 0);
    }
  }
  _getAxisModeCenterBboxOffset(geometry, params) {
    this._getAxisModeCenterBbox(geometry, params);
    this._center.add(params.centerOffset);
  }
  _getAxisModeCenterCustom(params) {
    return this._center.copy(params.center);
  }
}
ShearSopOperation.DEFAULT_PARAMS = {
  mode: SHEAR_MODES.indexOf("axis" /* AXIS */),
  // matrix mode
  xy: 0,
  xz: 0,
  yx: 0,
  yz: 0,
  zx: 0,
  zy: 0,
  // axis mode
  centerMode: SHEAR_CENTER_MODES.indexOf("bbox center" /* BBOX_CENTER */),
  centerOffset: new three_module.Vector3(0, 0, 0),
  center: new three_module.Vector3(0, 0, 0),
  planeAxis: new three_module.Vector3(0, 0, 1),
  axis: new three_module.Vector3(0, 1, 0),
  axisAmount: 0
};
ShearSopOperation.INPUT_CLONED_STATE = InputCloneMode/* InputCloneMode.FROM_NODE */.m.FROM_NODE;

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/sop/Shear.ts





const Shear_DEFAULT = ShearSopOperation.DEFAULT_PARAMS;
class ShearSopParamConfig extends params_ParamsConfig/* NodeParamsConfig */.yI {
  constructor() {
    super(...arguments);
    /** @param mode */
    this.mode = params_ParamsConfig/* ParamConfig.INTEGER */.XC.INTEGER(Shear_DEFAULT.mode, {
      menu: {
        entries: SHEAR_MODES.map((name, value) => {
          return { name, value };
        })
      }
    });
    /** @param matrixMode XY */
    this.xy = params_ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(Shear_DEFAULT.xy, {
      visibleIf: {
        mode: SHEAR_MODES.indexOf(ShearMode.MATRIX)
      }
    });
    /** @param matrixMode XZ */
    this.xz = params_ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(Shear_DEFAULT.xz, {
      visibleIf: {
        mode: SHEAR_MODES.indexOf(ShearMode.MATRIX)
      }
    });
    /** @param matrixMode YX */
    this.yx = params_ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(Shear_DEFAULT.yx, {
      visibleIf: {
        mode: SHEAR_MODES.indexOf(ShearMode.MATRIX)
      }
    });
    /** @param matrixMode YZ */
    this.yz = params_ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(Shear_DEFAULT.yz, {
      visibleIf: {
        mode: SHEAR_MODES.indexOf(ShearMode.MATRIX)
      }
    });
    /** @param matrixMode ZX */
    this.zx = params_ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(Shear_DEFAULT.zx, {
      visibleIf: {
        mode: SHEAR_MODES.indexOf(ShearMode.MATRIX)
      }
    });
    /** @param matrixMode ZY */
    this.zy = params_ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(Shear_DEFAULT.zy, {
      visibleIf: {
        mode: SHEAR_MODES.indexOf(ShearMode.MATRIX)
      }
    });
    /** @param centerMode defines how the center of the shear in axis mode is computed */
    this.centerMode = params_ParamsConfig/* ParamConfig.INTEGER */.XC.INTEGER(Shear_DEFAULT.centerMode, {
      visibleIf: {
        mode: SHEAR_MODES.indexOf(ShearMode.AXIS)
      },
      menu: {
        entries: SHEAR_CENTER_MODES.map((name, value) => {
          return { name, value };
        })
      }
    });
    /** @param centerOffset */
    this.centerOffset = params_ParamsConfig/* ParamConfig.VECTOR3 */.XC.VECTOR3(Shear_DEFAULT.centerOffset.toArray(), {
      visibleIf: {
        mode: SHEAR_MODES.indexOf(ShearMode.AXIS),
        centerMode: SHEAR_CENTER_MODES.indexOf(ShearCenterMode.BBOX_CENTER_OFFSET)
      }
    });
    /** @param center */
    this.center = params_ParamsConfig/* ParamConfig.VECTOR3 */.XC.VECTOR3(Shear_DEFAULT.center.toArray(), {
      visibleIf: {
        mode: SHEAR_MODES.indexOf(ShearMode.AXIS),
        centerMode: SHEAR_CENTER_MODES.indexOf(ShearCenterMode.CUSTOM)
      }
    });
    /** @param PlaneAxis */
    this.planeAxis = params_ParamsConfig/* ParamConfig.VECTOR3 */.XC.VECTOR3(Shear_DEFAULT.planeAxis.toArray(), {
      visibleIf: {
        mode: SHEAR_MODES.indexOf(ShearMode.AXIS)
      }
    });
    /** @param axis */
    this.axis = params_ParamsConfig/* ParamConfig.VECTOR3 */.XC.VECTOR3(Shear_DEFAULT.axis.toArray(), {
      visibleIf: {
        mode: SHEAR_MODES.indexOf(ShearMode.AXIS)
      }
    });
    /** @param axisAmount */
    this.axisAmount = params_ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(Shear_DEFAULT.axisAmount, {
      range: [-1, 1],
      visibleIf: {
        mode: SHEAR_MODES.indexOf(ShearMode.AXIS)
      }
    });
  }
}
const Shear_ParamsConfig = new ShearSopParamConfig();
class ShearSopNode extends sop_Base/* TypedSopNode */.x {
  constructor() {
    super(...arguments);
    this.paramsConfig = Shear_ParamsConfig;
  }
  static type() {
    return Sop/* SopType.SHEAR */.aB.SHEAR;
  }
  initializeNode() {
    this.io.inputs.setCount(1);
    this.io.inputs.initInputsClonedState(ShearSopOperation.INPUT_CLONED_STATE);
  }
  setMode(mode) {
    this.p.mode.set(SHEAR_MODES.indexOf(mode));
  }
  cook(input_contents) {
    this._operation = this._operation || new ShearSopOperation(this.scene(), this.states, this);
    const core_group = this._operation.cook(input_contents, this.pv);
    this.setCoreGroup(core_group);
  }
}

// EXTERNAL MODULE: ../@polygonjs/polygonjs/node_modules/yuka/build/yuka.module.js
var yuka_module = __webpack_require__(59023);
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/sop/ShortestPath.ts










const _v0 = new three_module.Vector3();
const _v1 = new three_module.Vector3();
const EDGES = [
  [0, 1],
  [1, 2],
  [2, 0]
];
function getDist(graph, source, target) {
  const sourceNode = graph.getNode(source);
  const targetNode = graph.getNode(target);
  if (!(sourceNode && targetNode)) {
    return 0;
  }
  sourceNode.position(_v0);
  targetNode.position(_v1);
  return _v0.distanceToSquared(_v1);
}
const heuristicPolicy = {
  calculate: getDist
};
class PositionNode extends yuka_module/* Node */.NB {
  constructor(index, positionArray) {
    super(index);
    this.index = index;
    this.positionArray = positionArray;
  }
  position(target) {
    return target.fromArray(this.positionArray, this.index * 3);
  }
}
class ShortestPathSopParamsConfig extends params_ParamsConfig/* NodeParamsConfig */.yI {
  constructor() {
    super(...arguments);
    /** @param objects to find paths in */
    this.group = params_ParamsConfig/* ParamConfig.STRING */.XC.STRING("", {
      objectMask: true
    });
    /** @param index of start point */
    this.pt0 = params_ParamsConfig/* ParamConfig.INTEGER */.XC.INTEGER(0, {
      range: [0, 100],
      rangeLocked: [true, false]
    });
    /** @param index of end point */
    this.pt1 = params_ParamsConfig/* ParamConfig.INTEGER */.XC.INTEGER(1, {
      range: [0, 100],
      rangeLocked: [true, false]
    });
  }
}
const ShortestPath_ParamsConfig = new ShortestPathSopParamsConfig();
class ShortestPathSopNode extends sop_Base/* TypedSopNode */.x {
  constructor() {
    super(...arguments);
    this.paramsConfig = ShortestPath_ParamsConfig;
  }
  static type() {
    return Sop/* SopType.SHORTEST_PATH */.aB.SHORTEST_PATH;
  }
  initializeNode() {
    this.io.inputs.setCount(1);
    this.io.inputs.initInputsClonedState(InputCloneMode/* InputCloneMode.NEVER */.m.NEVER);
  }
  cook(inputCoreGroups) {
    const inputCoreGroup = inputCoreGroups[0];
    const selectedObjects = Mask/* CoreMask.filterThreejsObjects */.x0.filterThreejsObjects(inputCoreGroup, this.pv);
    const newObjects = [];
    for (const object of selectedObjects) {
      this._createShortestPath(object, newObjects);
    }
    this.setObjects(newObjects);
  }
  _createShortestPath(object, newObjects) {
    const geometry = object.geometry;
    if (!geometry) {
      return;
    }
    const positionAttribute = geometry.getAttribute(geometry_Attribute/* Attribute.POSITION */.ah.POSITION);
    const index = geometry.getIndex();
    if (!(positionAttribute && index)) {
      return;
    }
    const pointsCount = positionAttribute.count;
    const facesCount = index.count / 3;
    const positions = positionAttribute.array;
    const indices = index.array;
    const endPtBySrcPt = /* @__PURE__ */ new Map();
    const graph = new yuka_module/* Graph */.kJ();
    for (let i = 0; i < pointsCount; i++) {
      const node = new PositionNode(i, positions);
      graph.addNode(node);
    }
    for (let i = 0; i < facesCount; i++) {
      for (const edgeIndices of EDGES) {
        const i0 = indices[i * 3 + edgeIndices[0]];
        const i1 = indices[i * 3 + edgeIndices[1]];
        let endPts0 = endPtBySrcPt.get(i0);
        let endPts1 = endPtBySrcPt.get(i1);
        if (!endPts0) {
          endPts0 = /* @__PURE__ */ new Set();
          endPtBySrcPt.set(i0, endPts0);
        }
        if (!endPts1) {
          endPts1 = /* @__PURE__ */ new Set();
          endPtBySrcPt.set(i1, endPts1);
        }
        if (!endPts0.has(i1)) {
          const edge = new yuka_module/* Edge */.kS(i0, i1, 0);
          graph.addEdge(edge);
          endPts0.add(i1);
          endPts1.add(i0);
        }
      }
    }
    const solver = new yuka_module/* AStar */.OZ(graph, this.pv.pt0, this.pv.pt1);
    solver.heuristic = heuristicPolicy;
    solver.search();
    const path = solver.getPath();
    this._buildLine(path, graph, newObjects);
  }
  _buildLine(path, graph, newObjects) {
    const pointsCount = path.length;
    const positions = new Array(pointsCount * 3);
    const indices = new Array(pointsCount);
    for (let i = 0; i < pointsCount; i++) {
      const node = graph.getNode(path[i]);
      node.position(_v0).toArray(positions, i * 3);
      if (i > 0) {
        indices[(i - 1) * 2] = i - 1;
        indices[(i - 1) * 2 + 1] = i;
      }
    }
    const geometry = new three_module.BufferGeometry();
    geometry.setAttribute("position", new three_module.Float32BufferAttribute(positions, 3));
    geometry.setIndex(indices);
    const object = this.createObject(geometry, Constant/* ObjectType.LINE_SEGMENTS */.LP.LINE_SEGMENTS);
    newObjects.push(object);
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/sop/SkeletonHelper.ts






class SkeletonHelperSopParamsConfig extends params_ParamsConfig/* NodeParamsConfig */.yI {
  // no keepInput param for now, as there seems to be a bug
  // where if the input is not kept, the skeleton does not display immediately.
  // It would only display if the input node is set its display flag first
  // keepInput = ParamConfig.BOOLEAN(1);
}
const SkeletonHelper_ParamsConfig = new SkeletonHelperSopParamsConfig();
class SkeletonHelperSopNode extends sop_Base/* TypedSopNode */.x {
  constructor() {
    super(...arguments);
    this.paramsConfig = SkeletonHelper_ParamsConfig;
  }
  static type() {
    return Sop/* SopType.SKELETON_HELPER */.aB.SKELETON_HELPER;
  }
  initializeNode() {
    this.io.inputs.setCount(1);
    this.io.inputs.initInputsClonedState(InputCloneMode/* InputCloneMode.NEVER */.m.NEVER);
  }
  cook(inputCoreGroups) {
    const inputCoreGroup = inputCoreGroups[0];
    const objects = inputCoreGroup.threejsObjects();
    const newObjects = [];
    for (const object of objects) {
      const helper = new three_module.SkeletonHelper(object);
      newObjects.push(object);
      newObjects.push(helper);
    }
    this.setObjects(newObjects);
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/sop/Skin.ts








class SkinSopParamsConfig extends params_ParamsConfig/* NodeParamsConfig */.yI {
}
const Skin_ParamsConfig = new SkinSopParamsConfig();
class SkinSopNode extends sop_Base/* TypedSopNode */.x {
  constructor() {
    super(...arguments);
    this.paramsConfig = Skin_ParamsConfig;
  }
  static type() {
    return Sop/* SopType.SKIN */.aB.SKIN;
  }
  initializeNode() {
    this.io.inputs.setCount(1, 2);
  }
  cook(inputCoreGroups) {
    const inputs = this.io.inputs.inputs();
    const compactInputs = [];
    (0,ArrayUtils/* arrayCompact */.k)(inputs, compactInputs);
    const inputsCount = compactInputs.length;
    switch (inputsCount) {
      case 1:
        return this.process_one_input(inputCoreGroups);
      case 2:
        return this.process_two_inputs(inputCoreGroups);
      default:
        return this.states.error.set("inputs count not valid");
    }
  }
  process_one_input(input_contents) {
    const core_group0 = input_contents[0];
    const line_segments0 = this._getLineSegments(core_group0);
    const geometries = [];
    if (line_segments0) {
      const first_line_segment = line_segments0[0];
      if (first_line_segment) {
        const src_geometries = CoreGeometryUtilCurve.line_segment_to_geometries(first_line_segment);
        if (src_geometries) {
          src_geometries.forEach((src_geometry, i) => {
            if (i > 0) {
              const prev_src_geometry = src_geometries[i - 1];
              const geometry = this._skin(prev_src_geometry, src_geometry);
              geometries.push(geometry);
            }
          });
        }
      }
    }
    this.setGeometries(geometries);
  }
  process_two_inputs(input_contents) {
    const core_group0 = input_contents[0];
    const core_group1 = input_contents[1];
    const line_segments0 = this._getLineSegments(core_group0);
    const line_segments1 = this._getLineSegments(core_group1);
    const line_segments = (0,ArrayUtils/* arraySortBy */.Zg)([line_segments0, line_segments1], (array) => -array.length);
    const smallest_array = line_segments[0];
    const largest_array = line_segments[1];
    const geometries = [];
    smallest_array.forEach((line_segment, i) => {
      const other_line_segment = largest_array[i];
      if (line_segment != null && other_line_segment != null) {
        const geo = line_segment.geometry;
        const other_geo = other_line_segment.geometry;
        const geometry = this._skin(geo, other_geo);
        geometries.push(geometry);
      }
    });
    this.setGeometries(geometries);
  }
  _getLineSegments(core_group) {
    return core_group.threejsObjects().filter((child) => child.isLineSegments);
  }
  _skin(geometry1, geometry0) {
    const geometry = new three_module.BufferGeometry();
    const operation = new CoreGeometryOperationSkin(geometry, geometry1, geometry0);
    operation.process();
    return geometry;
  }
}

// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/nodes/sop/Sort.ts
var Sort = __webpack_require__(98811);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/nodes/sop/Solver.ts + 1 modules
var Solver = __webpack_require__(10778);
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/sop/SolverPreviousFrame.ts




class SolverPreviousFrameSopParamsConfig extends params_ParamsConfig/* NodeParamsConfig */.yI {
}
const SolverPreviousFrame_ParamsConfig = new SolverPreviousFrameSopParamsConfig();
class SolverPreviousFrameSopNode extends sop_Base/* TypedSopNode */.x {
  constructor() {
    super(...arguments);
    this.paramsConfig = SolverPreviousFrame_ParamsConfig;
    this._solverNodeDependencyCreated = false;
  }
  static type() {
    return "solverPreviousFrame";
  }
  cook() {
    const solverNode = this._solverNode();
    if (!solverNode) {
      this.states.error.set(`subnet input has no parent`);
      this.cookController.endCook();
      return;
    }
    this._createSolverNodeDependencyIfRequired();
    const previousFrameCoreGroup = solverNode.previousFrameCoreGroup();
    if (previousFrameCoreGroup) {
      this.setObjects(previousFrameCoreGroup.allObjects());
    } else {
      this.setObjects([]);
    }
  }
  _createSolverNodeDependencyIfRequired() {
    if (this._solverNodeDependencyCreated) {
      return;
    }
    const solverNode = this._solverNode();
    if (!solverNode) {
      return;
    }
    this.addGraphInput(solverNode.iterationStamp());
    this._solverNodeDependencyCreated = true;
  }
  _solverNode() {
    const solverNode = this.parentController.findParent((parent) => parent.type() == poly_NodeContext/* NetworkNodeType.SOLVER */.kX.SOLVER);
    if (!solverNode) {
      this.states.error.set("parent is not a solver node");
      return;
    }
    return solverNode;
  }
}

// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/nodes/sop/Sphere.ts
var Sphere = __webpack_require__(30478);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/nodes/sop/Split.ts
var Split = __webpack_require__(35879);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/nodes/sop/SpotLight.ts
var sop_SpotLight = __webpack_require__(55334);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/node_modules/three-subdivide/src/index.js + 1 modules
var three_subdivide_src = __webpack_require__(93814);
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/operations/sop/Subdivide.ts




class SubdivideSopOperation extends operations_sop_Base/* BaseSopOperation */.U {
  static type() {
    return "subdivide";
  }
  cook(inputCoreGroups, params) {
    const coreGroup = inputCoreGroups[0];
    const objects = coreGroup.threejsObjects();
    for (let object of objects) {
      const geometry = object.geometry;
      if (geometry) {
        const subdividedGeometry = three_subdivide_src/* LoopSubdivision.modify */.r.modify(geometry, params.subdivisions, {});
        object.geometry = params.mergeVertices ? (0,BufferGeometryUtils/* mergeVertices */.$1)(subdividedGeometry) : subdividedGeometry;
      }
    }
    return coreGroup;
  }
}
SubdivideSopOperation.DEFAULT_PARAMS = {
  subdivisions: 1,
  mergeVertices: true
};

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/sop/Subdivide.ts





const Subdivide_DEFAULT = SubdivideSopOperation.DEFAULT_PARAMS;
class SubdivideSopParamsConfig extends params_ParamsConfig/* NodeParamsConfig */.yI {
  constructor() {
    super(...arguments);
    /** @param number of subdivisions */
    this.subdivisions = params_ParamsConfig/* ParamConfig.INTEGER */.XC.INTEGER(Subdivide_DEFAULT.subdivisions, {
      range: [0, 5],
      rangeLocked: [true, false]
    });
    /** @param merge vertices */
    this.mergeVertices = params_ParamsConfig/* ParamConfig.BOOLEAN */.XC.BOOLEAN(Subdivide_DEFAULT.mergeVertices);
  }
}
const Subdivide_ParamsConfig = new SubdivideSopParamsConfig();
class SubdivideSopNode extends sop_Base/* TypedSopNode */.x {
  constructor() {
    super(...arguments);
    this.paramsConfig = Subdivide_ParamsConfig;
  }
  static type() {
    return Sop/* SopType.SUBDIVIDE */.aB.SUBDIVIDE;
  }
  initializeNode() {
    this.io.inputs.setCount(1);
  }
  cook(input_contents) {
    this._operation = this._operation || new SubdivideSopOperation(this.scene(), this.states, this);
    const core_group = this._operation.cook(input_contents, this.pv);
    this.setCoreGroup(core_group);
  }
}

// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/nodes/sop/Subnet.ts
var sop_Subnet = __webpack_require__(61954);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/nodes/sop/SubnetInput.ts
var SubnetInput = __webpack_require__(69046);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/nodes/sop/SubnetOutput.ts
var sop_SubnetOutput = __webpack_require__(12849);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/nodes/sop/Switch.ts
var sop_Switch = __webpack_require__(71390);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/nodes/sop/Tangent.ts
var Tangent = __webpack_require__(69235);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/node_modules/three/examples/jsm/helpers/VertexTangentsHelper.js
var VertexTangentsHelper = __webpack_require__(85540);
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/sop/TangentsHelper.ts









class TangentsHelperSopParamsConfig extends params_ParamsConfig/* NodeParamsConfig */.yI {
  constructor() {
    super(...arguments);
    /** @param group to assign the material to */
    this.group = params_ParamsConfig/* ParamConfig.STRING */.XC.STRING("", {
      objectMask: true
    });
    /** @param keep input */
    this.keepInput = params_ParamsConfig/* ParamConfig.BOOLEAN */.XC.BOOLEAN(1);
    /** @param size of the box */
    this.size = params_ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(1, {
      range: [0, 1],
      rangeLocked: [false, false]
    });
  }
}
const TangentsHelper_ParamsConfig = new TangentsHelperSopParamsConfig();
class TangentsHelperSopNode extends sop_Base/* TypedSopNode */.x {
  constructor() {
    super(...arguments);
    this.paramsConfig = TangentsHelper_ParamsConfig;
  }
  static type() {
    return Sop/* SopType.TANGENTS_HELPER */.aB.TANGENTS_HELPER;
  }
  initializeNode() {
    this.io.outputs.setHasNoOutput();
    this.io.inputs.setCount(1);
    this.io.inputs.initInputsClonedState(InputCloneMode/* InputCloneMode.NEVER */.m.NEVER);
  }
  cook(inputCoreGroups) {
    const inputCoreGroup = inputCoreGroups[0];
    const selectedObjects = Mask/* CoreMask.filterThreejsObjects */.x0.filterThreejsObjects(inputCoreGroup, this.pv).filter(GeometryUtils/* object3DHasGeometry */.I_);
    const newObjects = [];
    for (const object of selectedObjects) {
      const geometry = object.geometry;
      if (geometry) {
        const tangentAttribute = geometry.getAttribute("tangent");
        if (!tangentAttribute) {
          this.states.error.set(`no tangent attribute found on geometry '${object.name}'`);
          return;
        } else {
          const helper = new VertexTangentsHelper/* VertexTangentsHelper */.X(object, this.pv.size);
          if ((0,Type/* isBooleanTrue */.bI)(this.pv.keepInput)) {
            newObjects.push(object);
          }
          newObjects.push(helper);
        }
      }
    }
    this.setObjects(newObjects);
  }
}

// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/nodes/sop/_BaseTet.ts + 9 modules
var _BaseTet = __webpack_require__(49651);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/core/geometry/modules/tet/utils/tetCenter.ts
var tetCenter = __webpack_require__(92671);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/core/geometry/modules/tet/utils/tetInsideMesh.ts
var tetInsideMesh = __webpack_require__(75118);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/core/geometry/modules/tet/utils/findNonDelaunayTets.ts
var findNonDelaunayTets = __webpack_require__(55291);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/core/geometry/modules/tet/utils/tetRemoveUnusedPoints.ts
var tetRemoveUnusedPoints = __webpack_require__(61985);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/core/geometry/modules/tet/utils/tetQuality.ts
var tetQuality = __webpack_require__(45210);
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/sop/TetDelete.ts

var TetDelete_async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};













const _tetCenter = new three_module.Vector3();
const TetDelete_indices = [];
class TetDeleteSopParamsConfig extends params_ParamsConfig/* NodeParamsConfig */.yI {
  constructor() {
    super(...arguments);
    this.byQuality = params_ParamsConfig/* ParamConfig.BOOLEAN */.XC.BOOLEAN(0);
    this.minQuality = params_ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(0.5, {
      range: [0, 1],
      rangeLocked: [true, true],
      visibleIf: { byQuality: 1 }
    });
    this.byIds = params_ParamsConfig/* ParamConfig.BOOLEAN */.XC.BOOLEAN(0, {
      separatorBefore: true
    });
    this.ids = params_ParamsConfig/* ParamConfig.STRING */.XC.STRING("0", {
      visibleIf: { byIds: 1 }
    });
    this.byIndex = params_ParamsConfig/* ParamConfig.BOOLEAN */.XC.BOOLEAN(0, {
      separatorBefore: true
    });
    this.index = params_ParamsConfig/* ParamConfig.INTEGER */.XC.INTEGER(-1, {
      range: [0, 100],
      rangeLocked: [true, false],
      visibleIf: { byIndex: 1 }
    });
    this.byIndexRange = params_ParamsConfig/* ParamConfig.BOOLEAN */.XC.BOOLEAN(0, {
      separatorBefore: true
    });
    this.indexRangeStart = params_ParamsConfig/* ParamConfig.INTEGER */.XC.INTEGER(0, {
      range: [0, 2e3],
      rangeLocked: [true, false],
      visibleIf: { byIndexRange: 1 }
    });
    this.indexRangeEnd = params_ParamsConfig/* ParamConfig.INTEGER */.XC.INTEGER(2e3, {
      range: [0, 2e3],
      rangeLocked: [true, false],
      visibleIf: { byIndexRange: 1 }
    });
    this.byDelaunay = params_ParamsConfig/* ParamConfig.BOOLEAN */.XC.BOOLEAN(0, {
      separatorBefore: true
    });
    this.byBoundingObject = params_ParamsConfig/* ParamConfig.BOOLEAN */.XC.BOOLEAN(0, {
      separatorBefore: true
    });
    this.invert = params_ParamsConfig/* ParamConfig.BOOLEAN */.XC.BOOLEAN(0, {
      separatorBefore: true
    });
  }
}
const TetDelete_ParamsConfig = new TetDeleteSopParamsConfig();
class TetDeleteSopNode extends _BaseTet/* TetSopNode */.k {
  constructor() {
    super(...arguments);
    this.paramsConfig = TetDelete_ParamsConfig;
  }
  static type() {
    return Sop/* SopType.TET_DELETE */.aB.TET_DELETE;
  }
  initializeNode() {
    this.io.inputs.setCount(1, 2);
  }
  cook(inputCoreGroups) {
    return TetDelete_async(this, null, function* () {
      const tetObjects = inputCoreGroups[0].tetObjects();
      if (tetObjects) {
        for (const tetObject of tetObjects) {
          this._deleteTets(tetObject, inputCoreGroups);
        }
        this.setObjects(tetObjects);
      } else {
        this.setObjects([]);
      }
    });
  }
  _deleteTets(tetObject, inputCoreGroups) {
    var _a;
    const selectedIds = [];
    if ((0,Type/* isBooleanTrue */.bI)(this.pv.byQuality)) {
      this._findTetsByQuality(tetObject, selectedIds);
    }
    if ((0,Type/* isBooleanTrue */.bI)(this.pv.byIds)) {
      this._findTetsById(selectedIds);
    }
    if ((0,Type/* isBooleanTrue */.bI)(this.pv.byIndex)) {
      this._findTetsByIndex(tetObject, selectedIds);
    }
    if ((0,Type/* isBooleanTrue */.bI)(this.pv.byIndexRange)) {
      this._findTetsByIndexRange(tetObject, selectedIds);
    }
    if ((0,Type/* isBooleanTrue */.bI)(this.pv.byDelaunay)) {
      this._findTetsByDelaunay(tetObject, selectedIds);
    }
    if ((0,Type/* isBooleanTrue */.bI)(this.pv.byBoundingObject)) {
      const boundingObject = (_a = inputCoreGroups[1]) == null ? void 0 : _a.threejsObjectsWithGeo()[0];
      if (boundingObject) {
        this._findTetsByBoundingObject(tetObject, boundingObject, selectedIds);
      }
    }
    if ((0,Type/* isBooleanTrue */.bI)(this.pv.invert)) {
      const nonSelectedIds = [];
      const selectedIdsSet = new Set(selectedIds);
      tetObject.geometry.tetrahedrons.forEach((_, tetId) => {
        if (!selectedIdsSet.has(tetId)) {
          nonSelectedIds.push(tetId);
        }
      });
      tetObject.geometry.removeTets(nonSelectedIds);
    } else {
      tetObject.geometry.removeTets(selectedIds);
    }
    (0,tetRemoveUnusedPoints/* tetRemoveUnusedPoints */.B)(tetObject.geometry);
  }
  _findTetsByQuality(tetObject, selectedIds) {
    tetObject.geometry.tetrahedrons.forEach((_, tetId) => {
      if ((0,tetQuality/* tetQuality */.K)(tetObject.geometry, tetId) < this.pv.minQuality) {
        selectedIds.push(tetId);
      }
    });
  }
  _findTetsById(selectedIds) {
    (0,core_String/* stringToIndices */.oz)(this.pv.ids, TetDelete_indices);
    (0,ArrayUtils/* arrayPushItems */.L_)(TetDelete_indices, selectedIds);
  }
  _findTetsByIndex(tetObject, selectedIds) {
    const index = this.pv.index;
    if (index == -1) {
      const lastId = tetObject.geometry.lastAddedTetId();
      if (lastId != null) {
        selectedIds.push(lastId);
      }
    } else {
      let i = 0;
      tetObject.geometry.tetrahedrons.forEach((_, tetId) => {
        if (i == index) {
          selectedIds.push(tetId);
        }
        i++;
      });
    }
  }
  _findTetsByIndexRange(tetObject, selectedIds) {
    const min = this.pv.indexRangeStart;
    const max = this.pv.indexRangeEnd;
    let i = 0;
    tetObject.geometry.tetrahedrons.forEach((_, tetId) => {
      if (i >= min && i <= max) {
        selectedIds.push(tetId);
      }
      i++;
    });
  }
  _findTetsByDelaunay(tetObject, selectedIds) {
    const invalidTets = [];
    (0,findNonDelaunayTets/* findNonDelaunayTetsFromMultiplePointsCheck */.D)(tetObject.geometry, invalidTets);
    selectedIds.push(...invalidTets);
  }
  _findTetsByBoundingObject(tetObject, boundingObject, selectedIds) {
    ThreeMeshBVHHelper/* ThreeMeshBVHHelper.assignDefaultBVHIfNone */.h.assignDefaultBVHIfNone(boundingObject);
    const tetGeometry = tetObject.geometry;
    tetGeometry.tetrahedrons.forEach((_, tetId) => {
      (0,tetCenter/* tetCenter */.Ah)(tetGeometry, tetId, _tetCenter);
      const isInside = (0,tetInsideMesh/* isPositionInsideMesh */.q)(_tetCenter, boundingObject, 1e-3);
      if (isInside) {
        selectedIds.push(tetId);
      }
    });
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/core/softBody/SoftBodyAttribute.ts


var SoftBodyAttribute_SoftBodyIdAttribute = /* @__PURE__ */ ((SoftBodyIdAttribute2) => {
  SoftBodyIdAttribute2["SOLVER_NODE"] = "SoftBodyIdAttribute_node";
  SoftBodyIdAttribute2["EMBED_HIGH_RES_NODE"] = "SoftBodyIdAttribute_embedHighResNode";
  SoftBodyIdAttribute2["EPHEMERAL_ID"] = "SoftBodyIdAttribute_ephemeralId";
  return SoftBodyIdAttribute2;
})(SoftBodyAttribute_SoftBodyIdAttribute || {});
var SoftBodyCommonAttribute = /* @__PURE__ */ ((SoftBodyCommonAttribute2) => {
  SoftBodyCommonAttribute2["HIGH_RES_SKINNING_LOOKUP_SPACING"] = "SoftBodyAttribute_highResSkinningLookupSpacing";
  SoftBodyCommonAttribute2["HIGH_RES_SKINNING_LOOKUP_PADDING"] = "SoftBodyAttribute_highResSkinningLookupPadding";
  return SoftBodyCommonAttribute2;
})(SoftBodyCommonAttribute || {});
class CoreSoftBodyBaseAttribute {
  static _setVector3(object, attribName, value) {
    (0,CoreObjectFactory/* coreObjectClassFactory */.Xr)(object).addAttribute(object, attribName, value);
  }
  static _getVector3(object, attribName, target) {
    (0,CoreObjectFactory/* coreObjectClassFactory */.Xr)(object).attribValue(object, attribName, 0, target);
  }
  static _setNumber(object, attribName, value) {
    (0,CoreObjectFactory/* coreObjectClassFactory */.Xr)(object).addAttribute(object, attribName, value);
  }
  static _getNumber(object, attribName, defaultValue) {
    const val = (0,CoreObjectFactory/* coreObjectClassFactory */.Xr)(object).attribValue(object, attribName, 0);
    if (val == null) {
      return defaultValue;
    }
    return val;
  }
}
class CoreSoftBodyAttribute extends CoreSoftBodyBaseAttribute {
  static setTetEmbedHighResNodeId(object, value) {
    this._setNumber(object, "SoftBodyIdAttribute_embedHighResNode" /* EMBED_HIGH_RES_NODE */, value);
  }
  static getTetEmbedHighResNodeId(object) {
    return this._getNumber(object, "SoftBodyIdAttribute_embedHighResNode" /* EMBED_HIGH_RES_NODE */, -1);
  }
  // static setGravity(object: ObjectContent<CoreObjectType>, value: Vector3) {
  // 	this._setVector3(object, SoftBodyCommonAttribute.GRAVITY, value);
  // }
  // static getGravity(object: ObjectContent<CoreObjectType>, value: Vector3) {
  // 	return this._getVector3(object, SoftBodyCommonAttribute.GRAVITY, value);
  // }
  // static setEdgeCompliance(object: ObjectContent<CoreObjectType>, value: number) {
  // 	this._setNumber(object, SoftBodyCommonAttribute.EDGE_COMPLIANCE, value);
  // }
  // static getEdgeCompliance(object: ObjectContent<CoreObjectType>) {
  // 	return this._getNumber(object, SoftBodyCommonAttribute.EDGE_COMPLIANCE, 100);
  // }
  // static setVolumeCompliance(object: ObjectContent<CoreObjectType>, value: number) {
  // 	this._setNumber(object, SoftBodyCommonAttribute.VOLUME_COMPLIANCED, value);
  // }
  // static getVolumeCompliance(object: ObjectContent<CoreObjectType>) {
  // 	return this._getNumber(object, SoftBodyCommonAttribute.VOLUME_COMPLIANCED, 0);
  // }
  static setHighResSkinningLookupSpacing(object, value) {
    this._setNumber(object, "SoftBodyAttribute_highResSkinningLookupSpacing" /* HIGH_RES_SKINNING_LOOKUP_SPACING */, value);
  }
  static getHighResSkinningLookupSpacing(object) {
    return this._getNumber(object, "SoftBodyAttribute_highResSkinningLookupSpacing" /* HIGH_RES_SKINNING_LOOKUP_SPACING */, 100);
  }
  static setHighResSkinningLookupPadding(object, value) {
    this._setNumber(object, "SoftBodyAttribute_highResSkinningLookupPadding" /* HIGH_RES_SKINNING_LOOKUP_PADDING */, value);
  }
  static getHighResSkinningLookupPadding(object) {
    return this._getNumber(object, "SoftBodyAttribute_highResSkinningLookupPadding" /* HIGH_RES_SKINNING_LOOKUP_PADDING */, 100);
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/sop/TetEmbed.ts

var TetEmbed_async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};




class TetEmbedSopParamsConfig extends params_ParamsConfig/* NodeParamsConfig */.yI {
  constructor() {
    super(...arguments);
    /** @param highRes Skinning Lookup Spacing */
    this.spacing = params_ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(0.05, {
      range: [0, 0.5],
      rangeLocked: [true, false]
    });
    /** @param highRes Skinning Lookup Padding */
    this.padding = params_ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(0.05, {
      range: [0, 0.5],
      rangeLocked: [true, false]
    });
  }
}
const TetEmbed_ParamsConfig = new TetEmbedSopParamsConfig();
class TetEmbedSopNode extends _BaseTet/* TetSopNode */.k {
  constructor() {
    super(...arguments);
    this.paramsConfig = TetEmbed_ParamsConfig;
  }
  static type() {
    return Sop/* SopType.TET_EMBED */.aB.TET_EMBED;
  }
  initializeNode() {
    this.io.inputs.setCount(2);
  }
  cook(inputCoreGroups) {
    return TetEmbed_async(this, null, function* () {
      var _a;
      const tetObjects = inputCoreGroups[0].tetObjects();
      const highResNodeId = (_a = this.io.inputs.input(1)) == null ? void 0 : _a.graphNodeId();
      if (highResNodeId == null) {
        this.states.error.set(`no high res node connected`);
        return;
      }
      if (tetObjects) {
        for (const tetObject of tetObjects) {
          CoreSoftBodyAttribute.setTetEmbedHighResNodeId(tetObject, highResNodeId);
          CoreSoftBodyAttribute.setHighResSkinningLookupSpacing(tetObject, this.pv.spacing);
          CoreSoftBodyAttribute.setHighResSkinningLookupPadding(tetObject, this.pv.padding);
        }
        this.setObjects(tetObjects);
      } else {
        this.setObjects([]);
      }
    });
  }
}

// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/core/geometry/modules/tet/utils/TesselationParamsConfig.ts
var tet_utils_TesselationParamsConfig = __webpack_require__(29269);
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/core/softBody/SoftBodyController.ts

class SoftBodyController {
  constructor(scene, options) {
    this.scene = scene;
    this._gravity = [0, -9.8, 0];
    this._node = options.node;
  }
  setSoftBody(softBody) {
    this._softBody = softBody;
  }
  dispose() {
    this._softBody = void 0;
  }
  step(stepsCount, edgeCompliance, volumeCompliance, preciseCollisions) {
    const softBody = this._softBody;
    if (!softBody) {
      return;
    }
    const functions = this._node.function();
    if (!(functions.collider && functions.velocity)) {
      return;
    }
    const args = this._node.functionEvalArgsWithParamConfigs();
    const velFunc = functions.velocity(...args.velocity);
    const sdfFunc = functions.collider(...args.collider);
    const sdfEvaluator = (p) => {
      this._node.setPositionGlobals(p);
      return sdfFunc();
    };
    const delta = this.scene.timeController.delta();
    const sdt = delta / stepsCount;
    for (let step = 0; step < stepsCount; step++) {
      this._node.updateSceneGlobals(step, sdt);
      softBody.preSolve(sdt, this._gravity, velFunc, sdfEvaluator);
      softBody.solve(sdt, edgeCompliance, volumeCompliance, preciseCollisions, sdfEvaluator);
      softBody.postSolve(sdt);
    }
    softBody.updateLowResObject();
    softBody.updateHighResMesh();
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/core/softBody/Common.ts

const VOL_ID_ORDER = [
  [1, 3, 2],
  [0, 2, 3],
  [0, 3, 1],
  [0, 1, 2]
];

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/core/softBody/SoftBodyMath.ts

function vecSetZero(a, anr) {
  anr *= 3;
  a[anr++] = 0;
  a[anr++] = 0;
  a[anr] = 0;
}
function vecScale(a, anr, scale) {
  anr *= 3;
  a[anr++] *= scale;
  a[anr++] *= scale;
  a[anr] *= scale;
}
function vecCopy(a, anr, b, bnr) {
  anr *= 3;
  bnr *= 3;
  a[anr++] = b[bnr++];
  a[anr++] = b[bnr++];
  a[anr] = b[bnr];
}
function vecAdd(a, anr, b, bnr, scale = 1) {
  anr *= 3;
  bnr *= 3;
  a[anr++] += b[bnr++] * scale;
  a[anr++] += b[bnr++] * scale;
  a[anr] += b[bnr] * scale;
}
function vecAddVector3(a, anr, v3) {
  anr *= 3;
  a[anr++] += v3.x;
  a[anr++] += v3.y;
  a[anr] += v3.z;
}
function vecSetDiff(dst, dnr, a, anr, b, bnr, scale = 1) {
  dnr *= 3;
  anr *= 3;
  bnr *= 3;
  dst[dnr++] = (a[anr++] - b[bnr++]) * scale;
  dst[dnr++] = (a[anr++] - b[bnr++]) * scale;
  dst[dnr] = (a[anr] - b[bnr]) * scale;
}
function vecLengthSquared(a, anr) {
  anr *= 3;
  let a0 = a[anr], a1 = a[anr + 1], a2 = a[anr + 2];
  return a0 * a0 + a1 * a1 + a2 * a2;
}
function vecDistSquared(a, anr, b, bnr) {
  anr *= 3;
  bnr *= 3;
  let a0 = a[anr] - b[bnr], a1 = a[anr + 1] - b[bnr + 1], a2 = a[anr + 2] - b[bnr + 2];
  return a0 * a0 + a1 * a1 + a2 * a2;
}
function vecDot(a, anr, b, bnr) {
  anr *= 3;
  bnr *= 3;
  return a[anr] * b[bnr] + a[anr + 1] * b[bnr + 1] + a[anr + 2] * b[bnr + 2];
}
function vecSetCross(a, anr, b, bnr, c, cnr) {
  anr *= 3;
  bnr *= 3;
  cnr *= 3;
  a[anr++] = b[bnr + 1] * c[cnr + 2] - b[bnr + 2] * c[cnr + 1];
  a[anr++] = b[bnr + 2] * c[cnr + 0] - b[bnr + 0] * c[cnr + 2];
  a[anr] = b[bnr + 0] * c[cnr + 1] - b[bnr + 1] * c[cnr + 0];
}
function matGetDeterminant(A) {
  const a11 = A[0], a12 = A[3], a13 = A[6];
  const a21 = A[1], a22 = A[4], a23 = A[7];
  const a31 = A[2], a32 = A[5], a33 = A[8];
  return a11 * a22 * a33 + a12 * a23 * a31 + a13 * a21 * a32 - a13 * a22 * a31 - a12 * a21 * a33 - a11 * a23 * a32;
}
function matSetMult(A, a, anr, b, bnr) {
  bnr *= 3;
  var bx = b[bnr++];
  var by = b[bnr++];
  var bz = b[bnr];
  vecSetZero(a, anr);
  vecAdd(a, anr, A, 0, bx);
  vecAdd(a, anr, A, 1, by);
  vecAdd(a, anr, A, 2, bz);
}
function matSetInverse(A) {
  let det = matGetDeterminant(A);
  if (det == 0) {
    for (let i = 0; i < 9; i++)
      A[
        /*anr +*/
        i
      ] = 0;
    return;
  }
  let invDet = 1 / det;
  let a11 = A[0], a12 = A[3], a13 = A[6];
  let a21 = A[1], a22 = A[4], a23 = A[7];
  let a31 = A[2], a32 = A[5], a33 = A[8];
  A[0] = (a22 * a33 - a23 * a32) * invDet;
  A[3] = -(a12 * a33 - a13 * a32) * invDet;
  A[6] = (a12 * a23 - a13 * a22) * invDet;
  A[1] = -(a21 * a33 - a23 * a31) * invDet;
  A[4] = (a11 * a33 - a13 * a31) * invDet;
  A[7] = -(a11 * a23 - a13 * a21) * invDet;
  A[2] = (a21 * a32 - a22 * a31) * invDet;
  A[5] = -(a11 * a32 - a12 * a31) * invDet;
  A[8] = (a11 * a22 - a12 * a21) * invDet;
}

// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/core/geometry/modules/tet/utils/tetSortPoints.ts
var tetSortPoints = __webpack_require__(50377);
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/core/geometry/modules/tet/utils/tetSoftBodyUtils.ts


function buildTetIds(tetGeometry, newOrderByPoint) {
  const tetIds = new Array(tetGeometry.tetsCount() * 4);
  let pointIndex = 0;
  tetGeometry.tetrahedrons.forEach((tet) => {
    for (let i = 0; i < 4; i++) {
      const id = tet.pointIds[i];
      const index = newOrderByPoint.get(id);
      if (index == null) {
        throw "id not found";
      }
      tetIds[pointIndex] = index;
      pointIndex++;
    }
  });
  return tetIds;
}
const EDGE_INDICES = [
  [0, 1],
  [0, 2],
  [0, 3],
  [1, 2],
  [1, 3],
  [2, 3]
];
const _startIdsSet = /* @__PURE__ */ new Set();
const _startIds = [];
const _endIds = [];
function buildTetEdgeIds(tetGeometry, newOrderByPoint) {
  const edgeEndsByStart = /* @__PURE__ */ new Map();
  let edgesCount = 0;
  _startIdsSet.clear();
  tetGeometry.tetrahedrons.forEach((tet) => {
    for (const edgeIndices of EDGE_INDICES) {
      const id0 = tet.pointIds[edgeIndices[0]];
      const id1 = tet.pointIds[edgeIndices[1]];
      const index0 = newOrderByPoint.get(id0);
      const index1 = newOrderByPoint.get(id1);
      if (index0 == null || index1 == null) {
        throw "id not found";
      }
      const minIndex = Math.min(index0, index1);
      const maxIndex = Math.max(index0, index1);
      let edgeEnds = edgeEndsByStart.get(minIndex);
      if (!edgeEnds) {
        edgeEnds = /* @__PURE__ */ new Set();
        edgeEndsByStart.set(minIndex, edgeEnds);
        _startIdsSet.add(minIndex);
      }
      if (!edgeEnds.has(maxIndex)) {
        edgeEnds.add(maxIndex);
        edgesCount++;
      }
    }
  });
  (0,SetUtils/* setToArray */.T_)(_startIdsSet, _startIds);
  const startIdsSorted = _startIds.sort((a, b) => a - b);
  const edgeIds = new Array(edgesCount * 2);
  let i = 0;
  for (const startId of startIdsSorted) {
    const endIds = edgeEndsByStart.get(startId);
    const endIdsSorted = (0,SetUtils/* setToArray */.T_)(endIds, _endIds).sort((a, b) => a - b);
    for (const endId of endIdsSorted) {
      edgeIds[i] = startId;
      edgeIds[i + 1] = endId;
      i += 2;
    }
  }
  return edgeIds;
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/core/Hash.ts

class Hash {
  constructor(options) {
    const { spacing, maxNumObjects } = options;
    this.spacing = spacing;
    this.tableSize = 2 * maxNumObjects;
    this.cellStart = new Int32Array(this.tableSize + 1);
    this.cellEntries = new Int32Array(maxNumObjects);
    this.queryIds = new Int32Array(maxNumObjects);
    this.querySize = 0;
  }
  hashCoords(xi, yi, zi) {
    var h = xi * 92837111 ^ yi * 689287499 ^ zi * 283923481;
    return Math.abs(h) % this.tableSize;
  }
  intCoord(coord) {
    return Math.floor(coord / this.spacing);
  }
  hashPos(pos, nr) {
    return this.hashCoords(
      this.intCoord(pos[3 * nr]),
      this.intCoord(pos[3 * nr + 1]),
      this.intCoord(pos[3 * nr + 2])
    );
  }
  create(pos) {
    var numObjects = Math.min(pos.length / 3, this.cellEntries.length);
    this.cellStart.fill(0);
    this.cellEntries.fill(0);
    for (var i = 0; i < numObjects; i++) {
      var h = this.hashPos(pos, i);
      this.cellStart[h]++;
    }
    var start = 0;
    for (var i = 0; i < this.tableSize; i++) {
      start += this.cellStart[i];
      this.cellStart[i] = start;
    }
    this.cellStart[this.tableSize] = start;
    for (var i = 0; i < numObjects; i++) {
      var h = this.hashPos(pos, i);
      this.cellStart[h]--;
      this.cellEntries[this.cellStart[h]] = i;
    }
  }
  query(pos, nr, maxDist) {
    var x0 = this.intCoord(pos[3 * nr] - maxDist);
    var y0 = this.intCoord(pos[3 * nr + 1] - maxDist);
    var z0 = this.intCoord(pos[3 * nr + 2] - maxDist);
    var x1 = this.intCoord(pos[3 * nr] + maxDist);
    var y1 = this.intCoord(pos[3 * nr + 1] + maxDist);
    var z1 = this.intCoord(pos[3 * nr + 2] + maxDist);
    this.querySize = 0;
    for (var xi = x0; xi <= x1; xi++) {
      for (var yi = y0; yi <= y1; yi++) {
        for (var zi = z0; zi <= z1; zi++) {
          var h = this.hashCoords(xi, yi, zi);
          var start = this.cellStart[h];
          var end = this.cellStart[h + 1];
          for (var i = start; i < end; i++) {
            this.queryIds[this.querySize] = this.cellEntries[i];
            this.querySize++;
          }
        }
      }
    }
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/core/softBody/SoftBodyConstraint.ts



let nextId = 0;
const _p = [0, 0, 0];
class SoftBodyConstraint {
  constructor(_softBody, pointIndex) {
    this._softBody = _softBody;
    this.pointIndex = pointIndex;
    this.id = nextId++;
    this.invMass = 0;
    this._previousPosition = new three_module.Vector3();
    this._position = new three_module.Vector3();
    this._velocity = new three_module.Vector3();
    if (!this._softBody) {
      return;
    }
    vecCopy(_p, 0, this._softBody.pos, this.pointIndex);
    this._position.fromArray(_p);
    this._previousPosition.copy(this._position);
  }
  dispose() {
    this._softBody = null;
  }
  setPosition(position, lerp, dt) {
    if (!this._softBody) {
      return;
    }
    this._position.lerp(position, lerp);
    this._position.toArray(_p);
    vecCopy(this._softBody.pos, this.pointIndex, _p, 0);
    this._velocity.copy(position).sub(this._previousPosition).divideScalar(dt);
    this._previousPosition.copy(this._position);
  }
  velocity(target) {
    this._velocity.toArray(target);
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/core/softBody/SoftBodyCollider.ts


const SoftBodyCollider_p = new three_module.Vector3();
const _d = new three_module.Vector3();
const _vn = new three_module.Vector3();
const _vn2 = new three_module.Vector3();
const MAX_STEPS = 100;
const SURF_DIST = 0.01;
function softBodyRayMarch(origin, dir, maxDist, distanceFunction) {
  let totalDist = 0;
  SoftBodyCollider_p.copy(origin);
  _vn.copy(dir).normalize();
  SoftBodyCollider_p.add(_vn2.copy(_vn).multiplyScalar(1 * SURF_DIST));
  for (let i = 0; i < MAX_STEPS; i++) {
    const dist = distanceFunction(SoftBodyCollider_p);
    totalDist += dist;
    if (dist < SURF_DIST || totalDist > maxDist) {
      break;
    }
    _d.copy(_vn).multiplyScalar(dist);
    SoftBodyCollider_p.add(_d);
  }
  return totalDist;
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/core/softBody/SoftBody.ts










const SoftBody_pos = new three_module.Vector3(0, 0, 0);
const _vel = new three_module.Vector3(0, 0, 0);
const _velDt = new three_module.Vector3(0, 0, 0);
const ONE_SIXTH = 1 / 6;
const _v3array = [0, 0, 0];
class SoftBody {
  constructor(options) {
    this.options = options;
    this.constraintsById = /* @__PURE__ */ new Map();
    this._constraintVel = [0, 0, 0];
    this._node = options.node;
    const { tetEmbed } = this.options;
    const { tetObject, lowResObject, highResObject } = tetEmbed;
    this.bufferGeometry = lowResObject.geometry;
    this.numParticles = tetObject.geometry.pointsCount();
    this.numTets = tetObject.geometry.tetsCount();
    this.pos = this.bufferGeometry.attributes.position.array;
    this.prevPos = this.bufferGeometry.attributes.position.array.slice();
    this.vel = new Float32Array(3 * this.numParticles);
    const newOrderByPoint = /* @__PURE__ */ new Map();
    (0,tetSortPoints/* tetSortPoints */.e)(tetObject.geometry, newOrderByPoint);
    this.tetIds = buildTetIds(tetObject.geometry, newOrderByPoint);
    this.edgeIds = buildTetEdgeIds(tetObject.geometry, newOrderByPoint);
    this.restVol = new Float32Array(this.numTets);
    this.edgeLengths = new Float32Array(this.edgeIds.length / 2);
    this.invMass = new Float32Array(this.numParticles);
    this.temp = new Float32Array(4 * 3);
    this.grads = new Float32Array(4 * 3);
    this.initPhysics();
    this.highResGeometry = highResObject ? highResObject.geometry : void 0;
    this.highResObjectPosition = this.highResGeometry ? this.highResGeometry.attributes.position.array : new Float32Array([]);
    const visVerts = this.highResObjectPosition;
    this.numVisVerts = visVerts.length / 3;
    this.skinningInfo = new Float32Array(4 * this.numVisVerts);
    if (highResObject) {
      this._computeSkinningInfo(visVerts);
      highResObject.userData[UserData/* ObjectUserData.LOW_RES_SOFT_BODY_MESH */.D.LOW_RES_SOFT_BODY_MESH] = lowResObject;
    }
  }
  _computeSkinningInfo(visVerts) {
    const hash = new Hash({
      spacing: this.options.highResSkinning.lookup.spacing,
      maxNumObjects: this.numVisVerts
    });
    hash.create(visVerts);
    this.skinningInfo.fill(-1);
    const minDist = new Float32Array(this.numVisVerts);
    minDist.fill(Number.MAX_VALUE);
    const border = this.options.highResSkinning.lookup.padding;
    const tetCenter = new Float32Array(3);
    const mat = new Float32Array(9);
    const bary = new Float32Array(4);
    for (let i = 0; i < this.numTets; i++) {
      tetCenter.fill(0);
      for (let j = 0; j < 4; j++)
        vecAdd(tetCenter, 0, this.pos, this.tetIds[4 * i + j], 0.25);
      let rMax = 0;
      for (let j = 0; j < 4; j++) {
        const r2 = vecDistSquared(tetCenter, 0, this.pos, this.tetIds[4 * i + j]);
        rMax = Math.max(rMax, Math.sqrt(r2));
      }
      rMax += border;
      hash.query(tetCenter, 0, rMax);
      if (hash.queryIds.length == 0)
        continue;
      const id0 = this.tetIds[4 * i];
      const id1 = this.tetIds[4 * i + 1];
      const id2 = this.tetIds[4 * i + 2];
      const id3 = this.tetIds[4 * i + 3];
      vecSetDiff(mat, 0, this.pos, id0, this.pos, id3);
      vecSetDiff(mat, 1, this.pos, id1, this.pos, id3);
      vecSetDiff(mat, 2, this.pos, id2, this.pos, id3);
      matSetInverse(mat);
      for (let j = 0; j < hash.queryIds.length; j++) {
        const id = hash.queryIds[j];
        if (minDist[id] <= 0)
          continue;
        if (vecDistSquared(visVerts, id, tetCenter, 0) > rMax * rMax)
          continue;
        vecSetDiff(bary, 0, visVerts, id, this.pos, id3);
        matSetMult(mat, bary, 0, bary, 0);
        bary[3] = 1 - bary[0] - bary[1] - bary[2];
        let dist = 0;
        for (let k = 0; k < 4; k++)
          dist = Math.max(dist, -bary[k]);
        if (dist < minDist[id]) {
          minDist[id] = dist;
          this.skinningInfo[4 * id] = i;
          this.skinningInfo[4 * id + 1] = bary[0];
          this.skinningInfo[4 * id + 2] = bary[1];
          this.skinningInfo[4 * id + 3] = bary[2];
        }
      }
    }
  }
  // updateMeshes() {
  // 	this.updateLowResObject();
  // 	this.updateHighResMesh();
  // }
  updateLowResObject() {
    if (!this.highResGeometry) {
      this.bufferGeometry.computeVertexNormals();
    }
    this.bufferGeometry.attributes.position.needsUpdate = true;
    this.bufferGeometry.computeBoundingSphere();
  }
  updateHighResMesh() {
    if (!this.highResGeometry) {
      return;
    }
    const positions = this.highResObjectPosition;
    let nr = 0;
    for (let i = 0; i < this.numVisVerts; i++) {
      let tetNr = this.skinningInfo[nr++] * 4;
      if (tetNr < 0) {
        nr += 3;
        continue;
      }
      const b0 = this.skinningInfo[nr++];
      const b1 = this.skinningInfo[nr++];
      const b2 = this.skinningInfo[nr++];
      const b3 = 1 - b0 - b1 - b2;
      const id0 = this.tetIds[tetNr++];
      const id1 = this.tetIds[tetNr++];
      const id2 = this.tetIds[tetNr++];
      const id3 = this.tetIds[tetNr++];
      vecSetZero(positions, i);
      vecAdd(positions, i, this.pos, id0, b0);
      vecAdd(positions, i, this.pos, id1, b1);
      vecAdd(positions, i, this.pos, id2, b2);
      vecAdd(positions, i, this.pos, id3, b3);
    }
    this.highResGeometry.computeVertexNormals();
    this.highResGeometry.attributes.position.needsUpdate = true;
    this.highResGeometry.computeBoundingSphere();
  }
  getTetVolume(nr) {
    const id0 = this.tetIds[4 * nr];
    const id1 = this.tetIds[4 * nr + 1];
    const id2 = this.tetIds[4 * nr + 2];
    const id3 = this.tetIds[4 * nr + 3];
    vecSetDiff(this.temp, 0, this.pos, id1, this.pos, id0);
    vecSetDiff(this.temp, 1, this.pos, id2, this.pos, id0);
    vecSetDiff(this.temp, 2, this.pos, id3, this.pos, id0);
    vecSetCross(this.temp, 3, this.temp, 0, this.temp, 1);
    return vecDot(this.temp, 3, this.temp, 2) / 6;
  }
  initPhysics() {
    this.invMass.fill(0);
    this.restVol.fill(0);
    for (let i = 0; i < this.numTets; i++) {
      const vol = this.getTetVolume(i);
      this.restVol[i] = vol;
      const pInvMass = vol > 0 ? 1 / (vol / 4) : 0;
      this.invMass[this.tetIds[4 * i]] += pInvMass;
      this.invMass[this.tetIds[4 * i + 1]] += pInvMass;
      this.invMass[this.tetIds[4 * i + 2]] += pInvMass;
      this.invMass[this.tetIds[4 * i + 3]] += pInvMass;
    }
    for (let i = 0; i < this.edgeLengths.length; i++) {
      const id0 = this.edgeIds[2 * i];
      const id1 = this.edgeIds[2 * i + 1];
      this.edgeLengths[i] = Math.sqrt(vecDistSquared(this.pos, id0, this.pos, id1));
    }
  }
  preSolve(dt, gravity, velFunc, sdfEvaluator) {
    for (let i = 0; i < this.numParticles; i++) {
      if (this.invMass[i] == 0)
        continue;
      SoftBody_pos.fromArray(this.pos, i * 3);
      _vel.fromArray(this.vel, i * 3);
      this._node.setPointGlobals(SoftBody_pos, _vel);
      const computedVel = velFunc();
      computedVel.toArray(this.vel, i * 3);
      _velDt.copy(computedVel).multiplyScalar(dt);
      vecCopy(this.prevPos, i, this.pos, i);
      const stepMagnitude = _velDt.length();
      const distToCollider = softBodyRayMarch(SoftBody_pos, _vel, stepMagnitude, sdfEvaluator);
      if (stepMagnitude > distToCollider) {
        vecAdd(this.pos, i, this.vel, i, dt);
        vecCopy(this.pos, i, this.prevPos, i);
        _vel.normalize().multiplyScalar(distToCollider);
        SoftBody_pos.add(_vel);
        SoftBody_pos.toArray(this.pos, i * 3);
      } else {
        vecAdd(this.pos, i, this.vel, i, dt);
      }
    }
  }
  solve(dt, edgeCompliance, volumeCompliance, preciseCollisions, sdfEvaluator) {
    this.solveEdges(dt, edgeCompliance, preciseCollisions, sdfEvaluator);
    this.solveVolumes(dt, volumeCompliance, preciseCollisions, sdfEvaluator);
  }
  postSolve(dt) {
    for (let i = 0; i < this.numParticles; i++) {
      if (this.invMass[i] == 0)
        continue;
      vecSetDiff(this.vel, i, this.pos, i, this.prevPos, i, 1 / dt);
    }
  }
  solveEdges(dt, compliance, preciseCollisions, sdfEvaluator) {
    const alpha = compliance / dt / dt;
    for (let i = 0; i < this.edgeLengths.length; i++) {
      const id0 = this.edgeIds[2 * i];
      const id1 = this.edgeIds[2 * i + 1];
      const w0 = this.invMass[id0];
      const w1 = this.invMass[id1];
      const w = w0 + w1;
      if (w == 0)
        continue;
      vecSetDiff(this.grads, 0, this.pos, id0, this.pos, id1);
      const len = Math.sqrt(vecLengthSquared(this.grads, 0));
      if (len == 0)
        continue;
      vecScale(this.grads, 0, 1 / len);
      const restLen = this.edgeLengths[i];
      const C = len - restLen;
      const s = -C / (w + alpha);
      if (preciseCollisions) {
        SoftBody_pos.fromArray(this.pos, id0 * 3);
        _vel.fromArray(this.grads, 0).multiplyScalar(s * w0);
        const stepMagnitude0 = _vel.length();
        const distToCollider0 = softBodyRayMarch(SoftBody_pos, _vel, stepMagnitude0, sdfEvaluator);
        if (stepMagnitude0 > distToCollider0) {
          _vel.fromArray(this.grads, 0).multiplyScalar(s * w0).normalize().multiplyScalar(distToCollider0);
          vecAddVector3(this.pos, id0, _vel);
        } else {
          vecAdd(this.pos, id0, this.grads, 0, s * w0);
        }
        SoftBody_pos.fromArray(this.pos, id1 * 3);
        _vel.fromArray(this.grads, 0).multiplyScalar(-s * w1);
        const stepMagnitude1 = _vel.length();
        const distToCollider1 = softBodyRayMarch(SoftBody_pos, _vel, stepMagnitude1, sdfEvaluator);
        if (stepMagnitude1 > distToCollider1) {
          _vel.fromArray(this.grads, 0).multiplyScalar(-s * w1).normalize().multiplyScalar(distToCollider1);
          vecAddVector3(this.pos, id1, _vel);
        } else {
          vecAdd(this.pos, id1, this.grads, 0, -s * w1);
        }
      } else {
        vecAdd(this.pos, id0, this.grads, 0, s * w0);
        vecAdd(this.pos, id1, this.grads, 0, -s * w1);
      }
    }
  }
  solveVolumes(dt, compliance, preciseCollisions, sdfEvaluator) {
    const alpha = compliance / dt / dt;
    for (let i = 0; i < this.numTets; i++) {
      let w = 0;
      for (let j = 0; j < 4; j++) {
        const id0 = this.tetIds[4 * i + VOL_ID_ORDER[j][0]];
        const id1 = this.tetIds[4 * i + VOL_ID_ORDER[j][1]];
        const id2 = this.tetIds[4 * i + VOL_ID_ORDER[j][2]];
        vecSetDiff(this.temp, 0, this.pos, id1, this.pos, id0);
        vecSetDiff(this.temp, 1, this.pos, id2, this.pos, id0);
        vecSetCross(this.grads, j, this.temp, 0, this.temp, 1);
        vecScale(this.grads, j, ONE_SIXTH);
        w += this.invMass[this.tetIds[4 * i + j]] * vecLengthSquared(this.grads, j);
      }
      if (w == 0)
        continue;
      const vol = this.getTetVolume(i);
      const restVol = this.restVol[i];
      const C = vol - restVol;
      const s = -C / (w + alpha);
      for (let j = 0; j < 4; j++) {
        const id = this.tetIds[4 * i + j];
        const magnitude = s * this.invMass[id];
        if (preciseCollisions) {
          SoftBody_pos.fromArray(this.pos, id * 3);
          _vel.fromArray(this.grads, j * 3).multiplyScalar(magnitude);
          const stepMagnitude = _vel.length();
          const distToCollider = softBodyRayMarch(SoftBody_pos, _vel, stepMagnitude, sdfEvaluator);
          if (stepMagnitude > distToCollider) {
            _vel.fromArray(this.grads, j * 3).multiplyScalar(magnitude).normalize().multiplyScalar(distToCollider);
            vecAddVector3(this.pos, id, _vel);
          } else {
            vecAdd(this.pos, id, this.grads, j, magnitude);
          }
        } else {
          vecAdd(this.pos, id, this.grads, j, magnitude);
        }
      }
    }
  }
  translate(offset) {
    offset.toArray(_v3array);
    for (var i = 0; i < this.numParticles; i++) {
      vecAdd(this.pos, i, _v3array, 0);
      vecAdd(this.prevPos, i, _v3array, 0);
    }
  }
  velocityMult(mult) {
    for (var i = 0; i < this.numParticles; i++) {
      vecScale(this.vel, i, mult);
    }
  }
  //
  //
  // constraints
  //
  //
  createConstraint(index) {
    const constraint = new SoftBodyConstraint(this, index);
    this.constraintsById.set(constraint.id, constraint);
    constraint.invMass = this.invMass[index];
    this.invMass[index] = 0;
    return constraint;
  }
  getConstraint(constraintId) {
    return this.constraintsById.get(constraintId);
  }
  deleteConstraint(constraintId) {
    const constraint = this.constraintsById.get(constraintId);
    if (!constraint) {
      return;
    }
    if (constraint.pointIndex >= 0) {
      this.invMass[constraint.pointIndex] = constraint.invMass;
      constraint.velocity(this._constraintVel);
      vecCopy(this.vel, constraint.pointIndex, this._constraintVel, 0);
    }
    this.constraintsById.delete(constraintId);
    constraint.dispose();
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/core/softBody/SoftBodyControllerRegister.ts





const controllers = /* @__PURE__ */ new WeakMap();
const softBodies = /* @__PURE__ */ new WeakMap();
function createOrFindSoftBodyController(scene, node, options) {
  const { tetEmbed, threejsObjectInSceneTree } = options;
  const { highResObject } = tetEmbed;
  if (highResObject) {
    tetEmbed.highResObject = threejsObjectInSceneTree;
    tetEmbed.threejsObjectInSceneTree = threejsObjectInSceneTree;
  } else {
    tetEmbed.lowResObject = threejsObjectInSceneTree;
    tetEmbed.threejsObjectInSceneTree = threejsObjectInSceneTree;
  }
  let controller = controllers.get(threejsObjectInSceneTree);
  if (!controller) {
    controller = new SoftBodyController(scene, {
      node
    });
    controllers.set(threejsObjectInSceneTree, controller);
    const { softBody } = createOrFindSoftBody(node, tetEmbed);
    if (softBody) {
      controller.setSoftBody(softBody);
    } else {
      console.warn("no softbody found");
    }
  }
  return { controller };
}
function createOrFindSoftBody(node, tetEmbed) {
  const { threejsObjectInSceneTree } = tetEmbed;
  if (!threejsObjectInSceneTree) {
    throw "createOrFindSoftBody: threejsObjectInSceneTree is null";
  }
  let softBody = softBodies.get(threejsObjectInSceneTree);
  if (!softBody) {
    const highResSkinningLookupSpacing = CoreSoftBodyAttribute.getHighResSkinningLookupSpacing(tetEmbed.tetObject);
    const highResSkinningLookupPadding = CoreSoftBodyAttribute.getHighResSkinningLookupPadding(tetEmbed.tetObject);
    softBody = new SoftBody({
      node,
      tetEmbed,
      highResSkinning: {
        lookup: {
          spacing: highResSkinningLookupSpacing,
          padding: highResSkinningLookupPadding
        }
      }
    });
    softBodies.set(threejsObjectInSceneTree, softBody);
  }
  return { softBody };
}
function SoftBodyControllerRegister_softBodyControllerNodeIdFromObject(softBodyObject) {
  const nodeId = coreObjectClassFactory(softBodyObject).attribValue(
    softBodyObject,
    SoftBodyIdAttribute.SOLVER_NODE
  );
  return nodeId;
}
function SoftBodyControllerRegister_softBodyControllerFromObject(softBodyObject) {
  return controllers.get(softBodyObject);
}
function softBodyFromObject(softBodyObject) {
  return softBodies.get(softBodyObject);
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/js/code/assemblers/softBody/SoftBodyPersistedConfig.ts

var SoftBodyPersistedConfig_async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};



class SoftBodyPersistedConfig extends BasePersistedConfig/* BasePersistedConfig */.p {
  constructor(node) {
    super(node);
    this.node = node;
  }
  toData() {
    return SoftBodyPersistedConfig_async(this, null, function* () {
      yield this.node.compile();
      const assemblerController = this.node.assemblerController();
      if (!assemblerController) {
        return;
      }
      const functionData = this.node.functionData();
      if (!functionData) {
        return;
      }
      const { functionBody, variableNames, functionNames, paramConfigs } = functionData;
      const data = {
        functionBody,
        variableNames,
        variables: (0,_BaseJsPersistedConfig/* serializedVariablesFromFunctionData */.ve)(functionData),
        functionNames,
        serializedParamConfigs: paramConfigs.map((p) => p.toJSON())
      };
      return data;
    });
  }
  load(data) {
    const assemblerController = this.node.assemblerController();
    if (assemblerController) {
      return;
    }
    const { functionBody, variableNames, functionNames, serializedParamConfigs } = data;
    const functionData = {
      functionBody,
      variableNames,
      variablesByName: (0,_BaseJsPersistedConfig/* variablesByNameFromPersistedConfigData */.pw)(data),
      functionNames,
      functionsByName: (0,_BaseJsPersistedConfig/* functionsByNameFromPersistedConfigData */.Kg)(data, this.node),
      paramConfigs: serializedParamConfigs.map((json) => JsParamConfig/* JsParamConfig.fromJSON */.M.fromJSON(json))
    };
    this.node.updateFromFunctionData(functionData);
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/sop/TetSoftBodySolver.ts

var TetSoftBodySolver_defProp = Object.defineProperty;
var TetSoftBodySolver_defProps = Object.defineProperties;
var TetSoftBodySolver_getOwnPropDescs = Object.getOwnPropertyDescriptors;
var TetSoftBodySolver_getOwnPropSymbols = Object.getOwnPropertySymbols;
var TetSoftBodySolver_hasOwnProp = Object.prototype.hasOwnProperty;
var TetSoftBodySolver_propIsEnum = Object.prototype.propertyIsEnumerable;
var TetSoftBodySolver_defNormalProp = (obj, key, value) => key in obj ? TetSoftBodySolver_defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var TetSoftBodySolver_spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (TetSoftBodySolver_hasOwnProp.call(b, prop))
      TetSoftBodySolver_defNormalProp(a, prop, b[prop]);
  if (TetSoftBodySolver_getOwnPropSymbols)
    for (var prop of TetSoftBodySolver_getOwnPropSymbols(b)) {
      if (TetSoftBodySolver_propIsEnum.call(b, prop))
        TetSoftBodySolver_defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var TetSoftBodySolver_spreadProps = (a, b) => TetSoftBodySolver_defProps(a, TetSoftBodySolver_getOwnPropDescs(b));
var TetSoftBodySolver_async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};















class TetSoftBodySolverSopParamsConfig extends params_ParamsConfig/* NodeParamsConfig */.yI {
}
const TetSoftBodySolver_ParamsConfig = new TetSoftBodySolverSopParamsConfig();
class TetSoftBodySolverSopNode extends _BaseTet/* TetSopNode */.k {
  constructor() {
    super(...arguments);
    this.paramsConfig = TetSoftBodySolver_ParamsConfig;
    this._nextId = 0;
    this._tetEmbedByThreejsObjectEphemeralId = /* @__PURE__ */ new Map();
    this.persisted_config = new SoftBodyPersistedConfig(this);
    this._assemblerController = this._createAssemblerController();
    this._childrenControllerContext = poly_NodeContext/* NodeContext.JS */.sy.JS;
    this._evaluationGlobals = {
      position: new three_module.Vector3(),
      velocity: new three_module.Vector3(),
      time: 0,
      delta: 0
    };
    this._paramConfigs = [];
    this._functionCreationArgs = {
      velocity: [],
      collider: []
    };
    this._functionEvalArgs = {
      velocity: { args: [], argsCountBeforeParams: 0 },
      collider: { args: [], argsCountBeforeParams: 0 }
    };
    this._function = {
      velocity: void 0,
      collider: void 0
    };
    this._functionArgsWithParams = {
      velocity: [],
      collider: []
    };
  }
  static type() {
    return Sop/* SopType.TET_SOFT_BODY_SOLVER */.aB.TET_SOFT_BODY_SOLVER;
  }
  assemblerController() {
    return this._assemblerController;
  }
  usedAssembler() {
    return _BaseRegister/* AssemblerName.JS_SOFT_BODY */.Q.JS_SOFT_BODY;
  }
  _createAssemblerController() {
    return Poly/* Poly.assemblersRegister.assembler */.L.assemblersRegister.assembler(this, this.usedAssembler());
  }
  initializeNode() {
    this.io.inputs.setCount(1);
    this.io.inputs.initInputsClonedState(InputCloneMode/* InputCloneMode.ALWAYS */.m.ALWAYS);
  }
  createNode(node_class, options) {
    return super.createNode(node_class, options);
  }
  children() {
    return super.children();
  }
  nodesByType(type) {
    return super.nodesByType(type);
  }
  childrenAllowed() {
    if (this.assemblerController()) {
      return super.childrenAllowed();
    }
    return false;
  }
  sceneReadonly() {
    return this.assemblerController() == null;
  }
  cook(inputCoreGroups) {
    return TetSoftBodySolver_async(this, null, function* () {
      this.compileIfRequired();
      const inputTetObjects = inputCoreGroups[0].tetObjects();
      if (inputTetObjects) {
        const newThreejsObjects = [];
        for (const tetObject of inputTetObjects) {
          const highResObject = yield this._highResObject(tetObject);
          const threejsObjectsFromTetObject = tetObject.toObject3D(TetSoftBodySolver_spreadProps(TetSoftBodySolver_spreadValues({}, tet_utils_TesselationParamsConfig/* DEFAULT */.TP), {
            displayTetMesh: false,
            displayOuterMesh: true
          }));
          if (threejsObjectsFromTetObject) {
            const lowResObject = (0,Type/* isArray */.kJ)(threejsObjectsFromTetObject) ? threejsObjectsFromTetObject[0] : threejsObjectsFromTetObject;
            const displayedObject = highResObject ? highResObject : lowResObject;
            ThreejsCoreObject/* ThreejsCoreObject.addAttribute */.W.addAttribute(
              displayedObject,
              SoftBodyAttribute_SoftBodyIdAttribute.SOLVER_NODE,
              this.graphNodeId()
            );
            const nextId = this._nextId++;
            ThreejsCoreObject/* ThreejsCoreObject.addAttribute */.W.addAttribute(displayedObject, SoftBodyAttribute_SoftBodyIdAttribute.EPHEMERAL_ID, nextId);
            const tetEmbed = {
              tetObject,
              lowResObject,
              highResObject
            };
            this._tetEmbedByThreejsObjectEphemeralId.set(nextId, tetEmbed);
            Poly/* Poly.onObjectsAddRemoveHooks.assignOnAddHookHandler */.L.onObjectsAddRemoveHooks.assignOnAddHookHandler(displayedObject, this);
            newThreejsObjects.push(displayedObject);
          }
        }
        this.setObjects(newThreejsObjects);
      } else {
        this.states.error.set(`no tet objects found in input`);
        this.setObjects([]);
      }
    });
  }
  _highResObject(tetObject) {
    return TetSoftBodySolver_async(this, null, function* () {
      var _a;
      const highResNodeId = CoreSoftBodyAttribute.getTetEmbedHighResNodeId(tetObject);
      if (highResNodeId == null) {
        return;
      }
      const node = this.scene().graph.nodeFromId(highResNodeId);
      if (!node) {
        return;
      }
      const container = yield node.compute();
      if (!container) {
        return;
      }
      const threejsObjects = (_a = container.coreContent()) == null ? void 0 : _a.threejsObjects();
      if (!threejsObjects) {
        return;
      }
      return threejsObjects[0];
    });
  }
  updateObjectOnAdd(object, parent) {
    const solverNodeId = ThreejsCoreObject/* ThreejsCoreObject.attribValue */.W.attribValue(object, SoftBodyAttribute_SoftBodyIdAttribute.SOLVER_NODE);
    if (solverNodeId != null) {
      if (solverNodeId != this.graphNodeId()) {
        return;
      }
      const ephemeralId = ThreejsCoreObject/* ThreejsCoreObject.attribValue */.W.attribValue(object, SoftBodyAttribute_SoftBodyIdAttribute.EPHEMERAL_ID);
      if (ephemeralId == null) {
        console.error("no ephemeralId found on object", object);
      }
      const tetEmbed = this._tetEmbedByThreejsObjectEphemeralId.get(ephemeralId);
      if (!tetEmbed) {
        console.error("no tetObject found from object", object);
        return;
      }
      createOrFindSoftBodyController(this.scene(), this, {
        tetEmbed,
        threejsObjectInSceneTree: object
      });
    }
  }
  compileIfRequired() {
    var _a;
    if ((_a = this.assemblerController()) == null ? void 0 : _a.compileRequired()) {
      this.compile();
    }
  }
  updateSceneGlobals(stepsCount, dt) {
    this._evaluationGlobals.time = this.scene().time() + stepsCount * dt;
    this._evaluationGlobals.delta = dt;
    this._functionArgsWithParams.velocity[2] = this._evaluationGlobals.time;
    this._functionArgsWithParams.collider[2] = this._evaluationGlobals.time;
    this._functionArgsWithParams.velocity[3] = this._evaluationGlobals.delta;
    this._functionArgsWithParams.collider[3] = this._evaluationGlobals.delta;
  }
  setPositionGlobals(position) {
    this._evaluationGlobals.position.copy(position);
  }
  setPointGlobals(position, velocity) {
    this._evaluationGlobals.position.copy(position);
    this._evaluationGlobals.velocity.copy(velocity);
  }
  function() {
    return this._function;
  }
  functionData() {
    return this._functionData;
  }
  compile() {
    const assemblerController = this.assemblerController();
    if (!assemblerController) {
      return;
    }
    const outputNodes = utils_NodeFinder/* JsNodeFinder.findOutputNodes */.K.findOutputNodes(this);
    if (outputNodes.length == 0) {
      this.states.error.set("one output node is required");
      return;
    }
    if (outputNodes.length > 1) {
      this.states.error.set("only one output node allowed");
      return;
    }
    const outputNode = outputNodes[0];
    if (outputNode) {
      const paramNodes = utils_NodeFinder/* JsNodeFinder.findParamGeneratingNodes */.K.findParamGeneratingNodes(this);
      const rootNodes = outputNodes.concat(paramNodes);
      assemblerController.assembler.set_root_nodes(rootNodes);
      assemblerController.assembler.updateFunction();
      const functionData = assemblerController.assembler.functionData();
      if (!functionData) {
        this.states.error.set("failed to compile ");
        return;
      }
      this.updateFromFunctionData(functionData);
    }
    assemblerController.post_compile();
  }
  updateFromFunctionData(functionData) {
    this._functionData = functionData;
    const { functionBody, variableNames, variablesByName, functionNames, functionsByName, paramConfigs } = this._functionData;
    const _createFunctionArgs = (functionBody2, type) => {
      const wrappedBody = `
			try {
				${functionBody2}
			} catch(e) {
				_setErrorFromError(e)
				return 0;
			}`;
      const _setErrorFromError = (e) => {
        this.states.error.set(e.message);
      };
      const variables = [];
      const functions = [];
      for (const variableName of variableNames) {
        const variable = variablesByName[variableName];
        variables.push(variable);
      }
      for (const functionName of functionNames) {
        const _func = functionsByName[functionName];
        functions.push(_func);
      }
      this._paramConfigs = [...paramConfigs];
      const paramConfigNames = paramConfigs.map((pc) => pc.uniformName());
      paramConfigs.forEach((p) => p.applyToNode(this));
      this._functionCreationArgs[type] = [
        "position",
        "velocity",
        "time",
        "delta",
        "_setErrorFromError",
        ...variableNames,
        ...functionNames,
        ...paramConfigNames,
        wrappedBody
      ];
      this._functionEvalArgs[type].args = [
        this._evaluationGlobals.position,
        this._evaluationGlobals.velocity,
        this._evaluationGlobals.time,
        this._evaluationGlobals.delta,
        _setErrorFromError,
        ...variables,
        ...functions
        // paramConfigs are added dynamically during cook
      ];
      this._functionEvalArgs[type].argsCountBeforeParams = this._functionEvalArgs[type].args.length;
      try {
        this._function[type] = new Function(...this._functionCreationArgs[type]);
      } catch (e) {
        console.warn(e);
        this.states.error.set("failed to compile");
      }
    };
    _createFunctionArgs(functionBody.velocity, "velocity");
    _createFunctionArgs(functionBody.collider, "collider");
  }
  functionEvalArgsWithParamConfigs() {
    const _args = (type) => {
      const argsData = this._functionEvalArgs[type];
      const list = argsData.args;
      let i = argsData.argsCountBeforeParams;
      for (const paramConfig of this._paramConfigs) {
        const paramName = paramConfig.name();
        const spareParam = this.params.get(paramName);
        if (spareParam && spareParam.value != null) {
          if (Type/* CoreType.isBoolean */.MR.isBoolean(spareParam.value) || Type/* CoreType.isNumberValid */.MR.isNumberValid(spareParam.value) || Type/* CoreType.isColor */.MR.isColor(spareParam.value) || Type/* CoreType.isVector */.MR.isVector(spareParam.value)) {
            list[i] = spareParam.value;
            i++;
          } else {
            console.warn(`spareParam not found but type not yet copied to function args:'${paramName}'`);
          }
        } else {
          console.warn(`spareParam not found:'${paramName}'`);
        }
      }
      return list;
    };
    this._functionArgsWithParams.velocity = _args("velocity");
    this._functionArgsWithParams.collider = _args("collider");
    return this._functionArgsWithParams;
  }
}
function TetSoftBodySolver_getSoftBodyControllerNodeFromSolverObject(solverObject, scene) {
  const nodeId = softBodyControllerNodeIdFromObject(solverObject);
  if (nodeId == null) {
    return;
  }
  const graphNode = scene.graph.nodeFromId(nodeId);
  if (!graphNode) {
    return;
  }
  const node = CoreType.isFunction(graphNode.context) ? graphNode : null;
  if (!node) {
    return;
  }
  if (node.context() != NodeContext.SOP) {
    return;
  }
  if (node.type() != SopType.TET_SOFT_BODY_SOLVER) {
    return;
  }
  return node;
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/sop/TetTriangulate.ts

var TetTriangulate_async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};





class TetTriangulateSopParamsConfig extends (0,tet_utils_TesselationParamsConfig/* SOPTetTesselationParamConfig */.YM)(params_ParamsConfig/* NodeParamsConfig */.yI) {
}
const TetTriangulate_ParamsConfig = new TetTriangulateSopParamsConfig();
class TetTriangulateSopNode extends _BaseTet/* TetSopNode */.k {
  constructor() {
    super(...arguments);
    this.paramsConfig = TetTriangulate_ParamsConfig;
  }
  static type() {
    return Sop/* SopType.TET_TRIANGULATE */.aB.TET_TRIANGULATE;
  }
  initializeNode() {
    this.io.inputs.setCount(1);
  }
  cook(inputCoreGroups) {
    return TetTriangulate_async(this, null, function* () {
      const tetObjects = inputCoreGroups[0].tetObjects();
      if (tetObjects) {
        const newObjects = [];
        for (const tetObject of tetObjects) {
          const objects = tetObject.toObject3D(this.pv);
          if (objects) {
            if (Type/* CoreType.isArray */.MR.isArray(objects)) {
              newObjects.push(...objects);
            } else {
              newObjects.push(objects);
            }
          }
        }
        this.setObjects(newObjects);
      } else {
        this.setObjects([]);
      }
    });
  }
}

// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/nodes/sop/Tetrahedralize.ts + 6 modules
var Tetrahedralize = __webpack_require__(78925);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/nodes/sop/Tetrahedron.ts + 1 modules
var Tetrahedron = __webpack_require__(85224);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/nodes/sop/Text.ts + 10 modules
var sop_Text = __webpack_require__(64481);
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/operations/sop/TextureCopy.ts

var TextureCopy_async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};



class TextureCopySopOperation extends operations_sop_Base/* BaseSopOperation */.U {
  static type() {
    return "TextureCopy";
  }
  cook(inputContents, params) {
    return TextureCopy_async(this, null, function* () {
      const coreGroupTarget = inputContents[0];
      const coreGroupSrc = inputContents[1];
      let texture;
      const srcObjects = coreGroupSrc.allObjects();
      for (let object of srcObjects) {
        object.traverse((child) => {
          const mat = child.material;
          if (mat) {
            if (!Type/* CoreType.isArray */.MR.isArray(mat)) {
              if (!texture) {
                texture = mat[params.textureName];
              }
            }
          }
        });
      }
      if (texture) {
        const targetObjects = coreGroupTarget.allObjects();
        for (let object of targetObjects) {
          object.traverse((child) => {
            const mat = child.material;
            if (mat) {
              if (!Type/* CoreType.isArray */.MR.isArray(mat)) {
                mat[params.textureName] = texture;
                const uniforms = mat.uniforms;
                if (uniforms) {
                  const uniform = uniforms[params.textureName];
                  if (uniform) {
                    uniform.value = texture;
                  }
                }
                mat.needsUpdate = true;
              }
            }
          });
        }
      }
      return coreGroupTarget;
    });
  }
}
TextureCopySopOperation.DEFAULT_PARAMS = {
  textureName: "map"
};
TextureCopySopOperation.INPUT_CLONED_STATE = [InputCloneMode/* InputCloneMode.FROM_NODE */.m.FROM_NODE, InputCloneMode/* InputCloneMode.NEVER */.m.NEVER];

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/sop/TextureCopy.ts

var sop_TextureCopy_async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};




const TextureCopy_DEFAULT = TextureCopySopOperation.DEFAULT_PARAMS;
class TextureCopySopParamsConfig extends params_ParamsConfig/* NodeParamsConfig */.yI {
  constructor() {
    super(...arguments);
    this.textureName = params_ParamsConfig/* ParamConfig.STRING */.XC.STRING(TextureCopy_DEFAULT.textureName);
  }
}
const TextureCopy_ParamsConfig = new TextureCopySopParamsConfig();
class TextureCopySopNode extends sop_Base/* TypedSopNode */.x {
  constructor() {
    super(...arguments);
    this.paramsConfig = TextureCopy_ParamsConfig;
  }
  static type() {
    return Sop/* SopType.TEXTURE_COPY */.aB.TEXTURE_COPY;
  }
  initializeNode() {
    this.io.inputs.setCount(2);
    this.io.inputs.initInputsClonedState(TextureCopySopOperation.INPUT_CLONED_STATE);
  }
  cook(input_contents) {
    return sop_TextureCopy_async(this, null, function* () {
      this._operation = this._operation || new TextureCopySopOperation(this.scene(), this.states, this);
      const core_group = yield this._operation.cook(input_contents, this.pv);
      this.setCoreGroup(core_group);
    });
  }
}

// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/core/cop/Filter.ts
var Filter = __webpack_require__(68841);
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/operations/sop/TextureProperties.ts

var sop_TextureProperties_async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};






class TexturePropertiesSopOperation extends operations_sop_Base/* BaseSopOperation */.U {
  static type() {
    return "textureProperties";
  }
  cook(inputCoreGroups, params) {
    return sop_TextureProperties_async(this, null, function* () {
      const coreGroup = inputCoreGroups[0];
      const objects = (0,Mask/* filterThreejsObjects */.zl)(coreGroup, params);
      const promises = objects.map((object) => this._updateObject(object, params));
      yield Promise.all(promises);
      return coreGroup;
    });
  }
  _updateObject(object, params) {
    return sop_TextureProperties_async(this, null, function* () {
      const material = object.material;
      if (!material) {
        return;
      }
      yield this._updateMaterial(material, params);
    });
  }
  _updateMaterial(material, params) {
    return sop_TextureProperties_async(this, null, function* () {
      let texture = material.map;
      if (texture) {
        yield this._updateTexture(texture, params);
      }
    });
  }
  _updateTexture(texture, params) {
    return sop_TextureProperties_async(this, null, function* () {
      this._updateColorSpace(texture, params);
      this._updateMapping(texture, params);
      this._updateWrap(texture, params);
      yield this._updateAnisotropy(texture, params);
      this._updateFilter(texture, params);
    });
  }
  _updateColorSpace(texture, pv) {
    if (!(0,Type/* isBooleanTrue */.bI)(pv.tcolorSpace)) {
      return;
    }
    texture.colorSpace = pv.colorSpace;
    texture.needsUpdate = true;
  }
  _updateMapping(texture, pv) {
    if ((0,Type/* isBooleanTrue */.bI)(pv.tmapping)) {
      texture.mapping = pv.mapping;
    }
  }
  _updateWrap(texture, pv) {
    if ((0,Type/* isBooleanTrue */.bI)(pv.twrap)) {
      texture.wrapS = pv.wrapS;
      texture.wrapT = pv.wrapT;
    }
  }
  _updateAnisotropy(texture, params) {
    return sop_TextureProperties_async(this, null, function* () {
      var _a;
      if (!(0,Type/* isBooleanTrue */.bI)(params.tanisotropy)) {
        return;
      }
      if ((0,Type/* isBooleanTrue */.bI)(params.useRendererMaxAnisotropy)) {
        const renderer = (_a = this._node) == null ? void 0 : _a.scene().renderersRegister.lastRegisteredRenderer();
        if (!renderer) {
          console.warn("no renderer found");
          return;
        }
        texture.anisotropy = renderer.capabilities.getMaxAnisotropy();
      } else {
        texture.anisotropy = params.anisotropy;
      }
    });
  }
  _updateFilter(texture, params) {
    if ((0,Type/* isBooleanTrue */.bI)(params.tminFilter)) {
      texture.minFilter = params.minFilter;
    }
    if ((0,Type/* isBooleanTrue */.bI)(params.tmagFilter)) {
      texture.magFilter = params.magFilter;
    }
  }
}
TexturePropertiesSopOperation.DEFAULT_PARAMS = {
  group: "",
  // anisotropy
  tcolorSpace: false,
  colorSpace: three_module.NoColorSpace,
  // mapping
  tmapping: false,
  mapping: three_module.UVMapping,
  // wrap
  twrap: false,
  wrapS: three_module.RepeatWrapping,
  wrapT: three_module.RepeatWrapping,
  // anisotropy
  tanisotropy: false,
  useRendererMaxAnisotropy: false,
  anisotropy: 2,
  // filters
  tminFilter: false,
  minFilter: Filter/* MIN_FILTER_DEFAULT_VALUE */.FO,
  tmagFilter: false,
  magFilter: Filter/* MAG_FILTER_DEFAULT_VALUE */.mK
};
TexturePropertiesSopOperation.INPUT_CLONED_STATE = InputCloneMode/* InputCloneMode.FROM_NODE */.m.FROM_NODE;

// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/core/cop/ColorSpace.ts
var ColorSpace = __webpack_require__(78847);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/core/cop/Mapping.ts
var Mapping = __webpack_require__(32900);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/core/cop/Wrapping.ts
var Wrapping = __webpack_require__(65933);
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/sop/TextureProperties.ts

var nodes_sop_TextureProperties_async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};








const TextureProperties_DEFAULT = TexturePropertiesSopOperation.DEFAULT_PARAMS;
class TexturePropertiesSopParamsConfig extends params_ParamsConfig/* NodeParamsConfig */.yI {
  constructor() {
    super(...arguments);
    /** @param group to assign the material to */
    this.group = params_ParamsConfig/* ParamConfig.STRING */.XC.STRING(TextureProperties_DEFAULT.group, {
      objectMask: true
    });
    /** @param toggle on to allow updating the texture color space */
    this.tcolorSpace = params_ParamsConfig/* ParamConfig.BOOLEAN */.XC.BOOLEAN(TextureProperties_DEFAULT.tcolorSpace);
    /** @param sets the texture encoding */
    this.colorSpace = params_ParamsConfig/* ParamConfig.STRING */.XC.STRING(TextureProperties_DEFAULT.colorSpace, {
      visibleIf: { tcolorSpace: 1 },
      menuString: {
        entries: ColorSpace/* COLOR_SPACES.map */.HW.map((colorSpace) => ({
          name: ColorSpace/* COLOR_SPACE_NAME_BY_COLOR_SPACE */.ec[colorSpace],
          value: colorSpace
        }))
      }
    });
    /** @param toggle on to allow updating the texture mapping */
    this.tmapping = params_ParamsConfig/* ParamConfig.BOOLEAN */.XC.BOOLEAN(TextureProperties_DEFAULT.tmapping);
    /** @param sets the texture mapping */
    this.mapping = params_ParamsConfig/* ParamConfig.INTEGER */.XC.INTEGER(TextureProperties_DEFAULT.mapping, {
      visibleIf: { tmapping: 1 },
      menu: {
        entries: Mapping/* MAPPINGS.map */.B.map((m) => {
          return {
            name: Object.keys(m)[0],
            value: Object.values(m)[0]
          };
        })
      }
    });
    /** @param toggle on to allow updating the texture wrap */
    this.twrap = params_ParamsConfig/* ParamConfig.BOOLEAN */.XC.BOOLEAN(TextureProperties_DEFAULT.twrap);
    /** @param sets the texture wrapS */
    this.wrapS = params_ParamsConfig/* ParamConfig.INTEGER */.XC.INTEGER(TextureProperties_DEFAULT.wrapS, {
      visibleIf: { twrap: 1 },
      menu: {
        entries: Wrapping/* WRAPPINGS.map */.T.map((m) => {
          return {
            name: Object.keys(m)[0],
            value: Object.values(m)[0]
          };
        })
      }
    });
    /** @param sets the texture wrapT */
    this.wrapT = params_ParamsConfig/* ParamConfig.INTEGER */.XC.INTEGER(TextureProperties_DEFAULT.wrapT, {
      visibleIf: { twrap: 1 },
      menu: {
        entries: Wrapping/* WRAPPINGS.map */.T.map((m) => {
          return {
            name: Object.keys(m)[0],
            value: Object.values(m)[0]
          };
        })
      },
      separatorAfter: true
    });
    // anisotropy
    /** @param toggle on to update the anisotropy */
    this.tanisotropy = params_ParamsConfig/* ParamConfig.BOOLEAN */.XC.BOOLEAN(TextureProperties_DEFAULT.tanisotropy);
    /** @param sets if the anisotropy should be set to the max capabilities of the renderer */
    this.useRendererMaxAnisotropy = params_ParamsConfig/* ParamConfig.BOOLEAN */.XC.BOOLEAN(TextureProperties_DEFAULT.useRendererMaxAnisotropy, {
      visibleIf: { tanisotropy: 1 }
    });
    /** @param anisotropy value */
    this.anisotropy = params_ParamsConfig/* ParamConfig.INTEGER */.XC.INTEGER(TextureProperties_DEFAULT.anisotropy, {
      visibleIf: { tanisotropy: 1, useRendererMaxAnisotropy: 0 },
      range: [0, 32],
      rangeLocked: [true, false]
    });
    // filters
    /** @param toggle on to update min filter */
    this.tminFilter = params_ParamsConfig/* ParamConfig.BOOLEAN */.XC.BOOLEAN(0);
    /** @param min filter value */
    this.minFilter = params_ParamsConfig/* ParamConfig.INTEGER */.XC.INTEGER(TextureProperties_DEFAULT.minFilter, {
      visibleIf: { tminFilter: 1 },
      menu: {
        entries: Filter/* MIN_FILTER_MENU_ENTRIES */.WM
      }
    });
    /** @param toggle on to update mag filter */
    this.tmagFilter = params_ParamsConfig/* ParamConfig.BOOLEAN */.XC.BOOLEAN(0);
    /** @param mag filter value */
    this.magFilter = params_ParamsConfig/* ParamConfig.INTEGER */.XC.INTEGER(TextureProperties_DEFAULT.magFilter, {
      visibleIf: { tmagFilter: 1 },
      menu: {
        entries: Filter/* MAG_FILTER_MENU_ENTRIES */.iM
      }
    });
  }
}
const sop_TextureProperties_ParamsConfig = new TexturePropertiesSopParamsConfig();
class TexturePropertiesSopNode extends sop_Base/* TypedSopNode */.x {
  constructor() {
    super(...arguments);
    this.paramsConfig = sop_TextureProperties_ParamsConfig;
  }
  static type() {
    return Sop/* SopType.TEXTURE_PROPERTIES */.aB.TEXTURE_PROPERTIES;
  }
  initializeNode() {
    this.io.inputs.setCount(1);
    this.io.inputs.initInputsClonedState(TexturePropertiesSopOperation.INPUT_CLONED_STATE);
  }
  cook(inputCoreGroups) {
    return nodes_sop_TextureProperties_async(this, null, function* () {
      this._operation = this._operation || new TexturePropertiesSopOperation(this.scene(), this.states, this);
      const coreGroup = yield this._operation.cook(inputCoreGroups, this.pv);
      this.setCoreGroup(coreGroup);
    });
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/operations/sop/Torus.ts







const Torus_DEFAULT_UP = new three_module.Vector3(0, 0, 1);
const capPositionsCenter0 = new three_module.Vector3();
const capCenter0 = new three_module.Vector3();
const tmpPos0 = new three_module.Vector3();
const tmpPos1 = new three_module.Vector3();
const tmpN = new three_module.Vector3();
const Torus_triangle = new three_module.Triangle();
const Torus_center = new three_module.Vector3();
const position = new three_module.Vector3();
const normal = new three_module.Vector3();
class TorusSopOperation extends operations_sop_Base/* BaseSopOperation */.U {
  static type() {
    return "torus";
  }
  cook(input_contents, params) {
    const arc = (0,Type/* isBooleanTrue */.bI)(params.open) ? params.arc : Math.PI * 2;
    const cap = (0,Type/* isBooleanTrue */.bI)(params.open) ? params.cap : false;
    const radialSegments = Math.floor(params.segmentsRadial);
    const tubularSegments = Math.floor(params.segmentsTube);
    const { radius, radiusTube } = params;
    const indices = [];
    const positions = [];
    const normals = [];
    const uvs = [];
    const capIndices0 = [];
    const capIndices1 = [];
    function setPosition(i, j, position2) {
      const u = i / tubularSegments * arc;
      const v = j / radialSegments * Math.PI * 2;
      position2.x = (radius + radiusTube * Math.cos(v)) * Math.cos(u);
      position2.y = (radius + radiusTube * Math.cos(v)) * Math.sin(u);
      position2.z = radiusTube * Math.sin(v);
      return { u, v };
    }
    for (let j = 0; j <= radialSegments; j++) {
      for (let i = 0; i <= tubularSegments; i++) {
        const { u } = setPosition(i, j, position);
        positions.push(position.x, position.y, position.z);
        Torus_center.x = radius * Math.cos(u);
        Torus_center.y = radius * Math.sin(u);
        normal.subVectors(position, Torus_center).normalize();
        normals.push(normal.x, normal.y, normal.z);
        uvs.push(i / tubularSegments);
        uvs.push(j / radialSegments);
      }
    }
    if (cap) {
      let i = 0;
      for (let j = 0; j <= radialSegments; j++) {
        setPosition(i, j, position);
        positions.push(position.x, position.y, position.z);
        normals.push(-1, -1, -1);
        capIndices0.push(positions.length / 3 - 1);
      }
      i = tubularSegments;
      for (let j = 0; j <= radialSegments; j++) {
        setPosition(i, j, position);
        positions.push(position.x, position.y, position.z);
        normals.push(-1, -1, -1);
        capIndices1.push(positions.length / 3 - 1);
      }
    }
    for (let j = 1; j <= radialSegments; j++) {
      for (let i = 1; i <= tubularSegments; i++) {
        const a = (tubularSegments + 1) * j + i - 1;
        const b = (tubularSegments + 1) * (j - 1) + i - 1;
        const c = (tubularSegments + 1) * (j - 1) + i;
        const d = (tubularSegments + 1) * j + i;
        indices.push(a, b, d);
        indices.push(b, c, d);
      }
    }
    if (cap) {
      this._addCap(capIndices0, positions, normals, indices, false);
      this._addCap(capIndices1, positions, normals, indices, true);
    }
    const geometry = new three_module.BufferGeometry();
    geometry.setIndex(indices);
    geometry.setAttribute(geometry_Attribute/* Attribute.POSITION */.ah.POSITION, new three_module.Float32BufferAttribute(positions, 3));
    geometry.setAttribute(geometry_Attribute/* Attribute.NORMAL */.ah.NORMAL, new three_module.Float32BufferAttribute(normals, 3));
    geometry.setAttribute(geometry_Attribute/* Attribute.UV */.ah.UV, new three_module.Float32BufferAttribute(uvs, 2));
    (0,Transform/* rotateGeometry */.bP)(geometry, Torus_DEFAULT_UP, params.direction);
    geometry.translate(params.center.x, params.center.y, params.center.z);
    return this.createCoreGroupFromGeometry(geometry);
  }
  _addCap(capIndices, positions, normals, indices, invert) {
    const capPointsCount = capIndices.length;
    if (capPointsCount <= 2) {
      return;
    }
    capCenter0.set(0, 0, 0);
    for (let i = 0; i < capPointsCount; i++) {
      capPositionsCenter0.fromArray(positions, capIndices[i] * 3);
      capCenter0.add(capPositionsCenter0);
    }
    capCenter0.divideScalar(capIndices.length);
    positions.push(capCenter0.x, capCenter0.y, capCenter0.z);
    const centerIndex = positions.length / 3 - 1;
    tmpPos0.fromArray(positions, capIndices[0] * 3);
    tmpPos1.fromArray(positions, capIndices[1] * 3);
    Torus_triangle.a.copy(tmpPos0);
    Torus_triangle.b.copy(tmpPos1);
    Torus_triangle.c.copy(capCenter0);
    Torus_triangle.getNormal(tmpN);
    if (invert) {
      tmpN.multiplyScalar(-1);
    }
    normals.push(tmpN.x, tmpN.y, tmpN.z);
    for (let i = 0; i < capIndices.length - 1; i++) {
      const a = centerIndex;
      const b = capIndices[i];
      const c = capIndices[i + 1];
      if (invert) {
        indices.push(c, b, a);
      } else {
        indices.push(a, b, c);
      }
      tmpN.toArray(normals, 3 * b);
    }
  }
}
TorusSopOperation.DEFAULT_PARAMS = {
  radius: 1,
  radiusTube: 0.25,
  segmentsRadial: 20,
  segmentsTube: 50,
  open: false,
  arc: Math.PI * 2,
  cap: true,
  direction: new three_module.Vector3(0, 1, 0),
  center: new three_module.Vector3(0, 0, 0)
};
TorusSopOperation.INPUT_CLONED_STATE = InputCloneMode/* InputCloneMode.FROM_NODE */.m.FROM_NODE;

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/sop/Torus.ts





const Torus_DEFAULT = TorusSopOperation.DEFAULT_PARAMS;
class TorusSopParamsConfig extends params_ParamsConfig/* NodeParamsConfig */.yI {
  constructor() {
    super(...arguments);
    /** @param large radius */
    this.radius = params_ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(Torus_DEFAULT.radius, { range: [0, 1] });
    /** @param radius of the tube */
    this.radiusTube = params_ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(Torus_DEFAULT.radiusTube, { range: [0, 1] });
    /** @param number of segments along the length of the torus */
    this.segmentsRadial = params_ParamsConfig/* ParamConfig.INTEGER */.XC.INTEGER(Torus_DEFAULT.segmentsRadial, {
      range: [2, 50],
      rangeLocked: [true, false]
    });
    /** @param number of segments along the tube */
    this.segmentsTube = params_ParamsConfig/* ParamConfig.INTEGER */.XC.INTEGER(Torus_DEFAULT.segmentsTube, {
      range: [1, 50],
      rangeLocked: [true, false]
    });
    /** @param open */
    this.open = params_ParamsConfig/* ParamConfig.BOOLEAN */.XC.BOOLEAN(Torus_DEFAULT.open);
    /** @param arc */
    this.arc = params_ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT("$PI*2", {
      step: 1e-5,
      range: [0, Math.PI * 2],
      rangeLocked: [true, true],
      visibleIf: { open: 1 }
    });
    /** @param create caps */
    this.cap = params_ParamsConfig/* ParamConfig.BOOLEAN */.XC.BOOLEAN(Torus_DEFAULT.cap, {
      visibleIf: { open: 1 }
    });
    /** @param axis perpendicular to the torus */
    this.direction = params_ParamsConfig/* ParamConfig.VECTOR3 */.XC.VECTOR3(Torus_DEFAULT.direction);
    /** @param center of the torus */
    this.center = params_ParamsConfig/* ParamConfig.VECTOR3 */.XC.VECTOR3(Torus_DEFAULT.center);
  }
}
const Torus_ParamsConfig = new TorusSopParamsConfig();
class TorusSopNode extends sop_Base/* TypedSopNode */.x {
  constructor() {
    super(...arguments);
    this.paramsConfig = Torus_ParamsConfig;
  }
  static type() {
    return Sop/* SopType.TORUS */.aB.TORUS;
  }
  cook(input_contents) {
    this._operation = this._operation || new TorusSopOperation(this.scene(), this.states, this);
    const coreGroup = this._operation.cook(input_contents, this.pv);
    this.setCoreGroup(coreGroup);
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/operations/sop/TorusKnot.ts




class TorusKnotSopOperation extends operations_sop_Base/* BaseSopOperation */.U {
  static type() {
    return "torusKnot";
  }
  cook(input_contents, params) {
    const radius = params.radius;
    const radiusTube = params.radiusTube;
    const segmentsRadial = params.segmentsRadial;
    const segmentsTube = params.segmentsTube;
    const p = params.p;
    const q = params.q;
    const geometry = new three_module.TorusKnotGeometry(radius, radiusTube, segmentsRadial, segmentsTube, p, q);
    geometry.translate(params.center.x, params.center.y, params.center.z);
    return this.createCoreGroupFromGeometry(geometry);
  }
}
TorusKnotSopOperation.DEFAULT_PARAMS = {
  radius: 1,
  radiusTube: 0.25,
  segmentsRadial: 128,
  segmentsTube: 8,
  p: 2,
  q: 3,
  center: new three_module.Vector3(0, 0, 0)
};
TorusKnotSopOperation.INPUT_CLONED_STATE = InputCloneMode/* InputCloneMode.FROM_NODE */.m.FROM_NODE;

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/sop/TorusKnot.ts





const TorusKnot_DEFAULT = TorusKnotSopOperation.DEFAULT_PARAMS;
class TorusKnotSopParamsConfig extends params_ParamsConfig/* NodeParamsConfig */.yI {
  constructor() {
    super(...arguments);
    /** @param large radius */
    this.radius = params_ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(TorusKnot_DEFAULT.radius);
    /** @param radius of the tube */
    this.radiusTube = params_ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(TorusKnot_DEFAULT.radiusTube);
    /** @param number of segments along the length of the torus */
    this.segmentsRadial = params_ParamsConfig/* ParamConfig.INTEGER */.XC.INTEGER(TorusKnot_DEFAULT.segmentsRadial, { range: [1, 128] });
    /** @param number of segments along the tube */
    this.segmentsTube = params_ParamsConfig/* ParamConfig.INTEGER */.XC.INTEGER(TorusKnot_DEFAULT.segmentsTube, { range: [1, 32] });
    /** @param change this to create more interesting shapes. Don't ask me what it is exactly, I don't know! */
    this.p = params_ParamsConfig/* ParamConfig.INTEGER */.XC.INTEGER(TorusKnot_DEFAULT.p, { range: [1, 10] });
    /** @param change this to create more interesting shapes. Don't ask me what it is exactly, I don't know! */
    this.q = params_ParamsConfig/* ParamConfig.INTEGER */.XC.INTEGER(TorusKnot_DEFAULT.q, { range: [1, 10] });
    /** @param center of the torus knot */
    this.center = params_ParamsConfig/* ParamConfig.VECTOR3 */.XC.VECTOR3(TorusKnot_DEFAULT.center);
  }
}
const TorusKnot_ParamsConfig = new TorusKnotSopParamsConfig();
class TorusKnotSopNode extends sop_Base/* TypedSopNode */.x {
  constructor() {
    super(...arguments);
    this.paramsConfig = TorusKnot_ParamsConfig;
  }
  static type() {
    return Sop/* SopType.TORUS_KNOT */.aB.TORUS_KNOT;
  }
  initializeNode() {
  }
  cook(input_contents) {
    this._operation = this._operation || new TorusKnotSopOperation(this.scene(), this.states, this);
    const core_group = this._operation.cook(input_contents, this.pv);
    this.setCoreGroup(core_group);
  }
}

// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/core/computerVision/face/Data.ts
var face_Data = __webpack_require__(64824);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/node_modules/@mediapipe/face_mesh/face_mesh.js
var face_mesh = __webpack_require__(86228);
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/core/computerVision/face/Common.ts

var CoreComputerVisionFaceAttribute = /* @__PURE__ */ ((CoreComputerVisionFaceAttribute2) => {
  CoreComputerVisionFaceAttribute2["SELFIE_MODE"] = "CoreComputerVisionFace-selfieMode";
  CoreComputerVisionFaceAttribute2["MAX_NUM_FACES"] = "CoreComputerVisionFace-maxNumFaces";
  CoreComputerVisionFaceAttribute2["REFINE_LANDMARKS"] = "CoreComputerVisionFace-refineLandmarks";
  CoreComputerVisionFaceAttribute2["MIN_DETECTION_CONFIDENCE"] = "CoreComputerVisionFace-minDetectionConfidence";
  CoreComputerVisionFaceAttribute2["MAX_TRACKING_CONFIDENCE"] = "CoreComputerVisionFace-minTrackingConfidence";
  CoreComputerVisionFaceAttribute2["KEY"] = "CoreComputerVisionFace-key";
  return CoreComputerVisionFaceAttribute2;
})(CoreComputerVisionFaceAttribute || {});

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/core/computerVision/face/CoreComputerVisionFace.ts








const CoreComputerVisionFace_DEFAULT = {
  selfieMode: false,
  maxNumFaces: 1,
  refineLandmarks: false,
  minDetectionConfidence: 0.5,
  minTrackingConfidence: 0.5
};
function CoreComputerVisionFaceParamConfig(Base) {
  return class Mixin extends Base {
    constructor() {
      super(...arguments);
      /** @param selfieMode */
      this.selfieMode = params_ParamsConfig/* ParamConfig.BOOLEAN */.XC.BOOLEAN(CoreComputerVisionFace_DEFAULT.selfieMode);
      /** @param Maximum number of faces to detect */
      this.maxNumFaces = params_ParamsConfig/* ParamConfig.INTEGER */.XC.INTEGER(CoreComputerVisionFace_DEFAULT.maxNumFaces, {
        range: [0, 2],
        rangeLocked: [true, false]
      });
      /** @param Whether to further refine the landmark coordinates around the eyes and lips, and output additional landmarks around the irises by applying the Attention Mesh Model */
      this.refineLandmarks = params_ParamsConfig/* ParamConfig.BOOLEAN */.XC.BOOLEAN(CoreComputerVisionFace_DEFAULT.refineLandmarks);
      /** @param Minimum confidence value ([0.0, 1.0]) from the face detection model for the detection to be considered successful. Default to 0.5. */
      this.minDetectionConfidence = params_ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(CoreComputerVisionFace_DEFAULT.minDetectionConfidence, {
        range: [0, 1],
        rangeLocked: [true, true]
      });
      /** @param Minimum confidence value ([0.0, 1.0]) from the landmark-tracking model for the face landmarks to be considered tracked successfully, or otherwise face detection will be invoked automatically on the next input image. Setting it to a higher value can increase robustness of the solution, at the expense of a higher latency. Ignored if static_image_mode is true, where face detection simply runs on every image. Default to 0.5. */
      this.minTrackingConfidence = params_ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(CoreComputerVisionFace_DEFAULT.minTrackingConfidence, {
        range: [0, 1],
        rangeLocked: [true, true]
      });
    }
  };
}
function locateFile(file) {
  return `https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/${file}`;
}
function attributes(object) {
  const coreObjectClass = (0,CoreObjectFactory/* coreObjectClassFactory */.Xr)(object);
  const selfieMode = coreObjectClass.attribValue(object, CoreComputerVisionFaceAttribute.SELFIE_MODE);
  const maxNumFaces = coreObjectClass.attribValue(object, CoreComputerVisionFaceAttribute.MAX_NUM_FACES);
  const refineLandmarks = coreObjectClass.attribValue(object, CoreComputerVisionFaceAttribute.REFINE_LANDMARKS);
  const minDetectionConfidence = coreObjectClass.attribValue(
    object,
    CoreComputerVisionFaceAttribute.MIN_DETECTION_CONFIDENCE
  );
  const minTrackingConfidence = coreObjectClass.attribValue(
    object,
    CoreComputerVisionFaceAttribute.MAX_TRACKING_CONFIDENCE
  );
  const data = {
    selfieMode: Type/* CoreType.isBoolean */.MR.isBoolean(selfieMode) ? selfieMode : CoreComputerVisionFace_DEFAULT.selfieMode,
    maxNumFaces: Type/* CoreType.isNumber */.MR.isNumber(maxNumFaces) ? maxNumFaces : CoreComputerVisionFace_DEFAULT.maxNumFaces,
    refineLandmarks: Type/* CoreType.isBoolean */.MR.isBoolean(refineLandmarks) ? refineLandmarks : CoreComputerVisionFace_DEFAULT.refineLandmarks,
    minDetectionConfidence: Type/* CoreType.isNumber */.MR.isNumber(minDetectionConfidence) ? minDetectionConfidence : CoreComputerVisionFace_DEFAULT.minDetectionConfidence,
    minTrackingConfidence: Type/* CoreType.isNumber */.MR.isNumber(minTrackingConfidence) ? minTrackingConfidence : CoreComputerVisionFace_DEFAULT.minTrackingConfidence
  };
  return data;
}
function trackerOptions(attributes2) {
  return {
    selfieMode: attributes2.selfieMode,
    maxNumFaces: attributes2.maxNumFaces,
    refineLandmarks: attributes2.refineLandmarks,
    minDetectionConfidence: attributes2.minDetectionConfidence,
    minTrackingConfidence: attributes2.minTrackingConfidence
  };
}
function createKey(object) {
  return JSON.stringify(attributes(object));
}
function createConvertedResult() {
  const pointsCount = face_Data/* DEFAULT_POSITION.length */.Bg.length / 3;
  const multiFaceLandmarks = new Array(pointsCount);
  for (let i = 0; i < pointsCount; i++) {
    multiFaceLandmarks[i] = new three_module.Vector4();
  }
  return {
    multiFaceLandmarks
  };
}
function updateConvertedResult(convertedResult, results, index) {
  results.multiFaceLandmarks;
  const multiFaceLandmarks = results.multiFaceLandmarks[index];
  for (let i = 0; i < multiFaceLandmarks.length; i++) {
    const landmark = multiFaceLandmarks[i];
    convertedResult.multiFaceLandmarks[i].set(
      1 - landmark.x,
      1 - landmark.y,
      landmark.z,
      landmark.visibility != null ? landmark.visibility : 0
    );
  }
}
class TrackerContainer {
  constructor(tracker) {
    this.tracker = tracker;
    this._inProgress = false;
    this.results = [];
    for (let i = 0; i < 3; i++) {
      this.results.push(createConvertedResult());
    }
    tracker.onResults((results) => {
      this._inProgress = false;
      const subResultsCount = results.multiFaceLandmarks.length;
      for (let i = 0; i < subResultsCount; i++) {
        updateConvertedResult(this.results[i], results, i);
      }
    });
  }
  track(source) {
    if (this._inProgress) {
      return;
    }
    this._inProgress = true;
    this.tracker.send({ image: source });
  }
}
class CoreComputerVisionFace {
  static trackerForObject(object) {
    const key = this.trackerKey(object);
    let tracker = this.trackerByKey.get(key);
    if (!tracker) {
      tracker = this._createTracker(trackerOptions(attributes(object)));
      this.trackerByKey.set(key, tracker);
    }
    return tracker;
  }
  static trackMedia(object, source) {
    const tracker = this.trackerForObject(object);
    tracker.track(source);
  }
  static trackerResults(object) {
    return this.trackerForObject(object).results;
  }
  static _createTracker(options) {
    const faceMesh = new face_mesh.FaceMesh({
      locateFile
    });
    faceMesh.setOptions(options);
    return new TrackerContainer(faceMesh);
  }
  static trackerKey(object) {
    const coreObjectClass = (0,CoreObjectFactory/* coreObjectClassFactory */.Xr)(object);
    let key = coreObjectClass.attribValue(object, CoreComputerVisionFaceAttribute.KEY);
    if (!key || !Type/* CoreType.isString */.MR.isString(key)) {
      key = createKey(object);
      coreObjectClass.addAttribute(object, CoreComputerVisionFaceAttribute.KEY, key);
    }
    return key;
  }
  static setAttributes(object, options) {
    const coreObjectClass = (0,CoreObjectFactory/* coreObjectClassFactory */.Xr)(object);
    coreObjectClass.addAttribute(object, CoreComputerVisionFaceAttribute.SELFIE_MODE, options.selfieMode);
    coreObjectClass.addAttribute(object, CoreComputerVisionFaceAttribute.MAX_NUM_FACES, options.maxNumFaces);
    coreObjectClass.addAttribute(object, CoreComputerVisionFaceAttribute.REFINE_LANDMARKS, options.refineLandmarks);
    coreObjectClass.addAttribute(
      object,
      CoreComputerVisionFaceAttribute.MIN_DETECTION_CONFIDENCE,
      options.minDetectionConfidence
    );
    coreObjectClass.addAttribute(
      object,
      CoreComputerVisionFaceAttribute.MAX_TRACKING_CONFIDENCE,
      options.minTrackingConfidence
    );
  }
}
CoreComputerVisionFace.trackerByKey = /* @__PURE__ */ new Map();

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/sop/TrackingLandmarksFace.ts









class TrackingLandmarksFaceSopParamsConfig extends CoreComputerVisionFaceParamConfig(params_ParamsConfig/* NodeParamsConfig */.yI) {
}
const TrackingLandmarksFace_ParamsConfig = new TrackingLandmarksFaceSopParamsConfig();
class TrackingLandmarksFaceSopNode extends sop_Base/* TypedSopNode */.x {
  constructor() {
    super(...arguments);
    this.paramsConfig = TrackingLandmarksFace_ParamsConfig;
    this._uv = new three_module.Vector2();
  }
  static type() {
    return "trackingLandmarksFace";
  }
  cook() {
    const geometry = new three_module.BufferGeometry();
    const positionArray = face_Data/* DEFAULT_POSITION */.Bg;
    geometry.setAttribute(geometry_Attribute/* Attribute.POSITION */.ah.POSITION, new three_module.BufferAttribute(new Float32Array(positionArray), 3));
    const uvs = [];
    const pointsCount = positionArray.length / 3;
    for (let i = 0; i < pointsCount; i++) {
      this._uv.fromArray(positionArray, i * 3);
      this._uv.toArray(uvs, i * 3);
    }
    geometry.setAttribute("uv", new three_module.BufferAttribute(new Float32Array(uvs), 2));
    const indices = [];
    const polyCount = face_mesh.FACEMESH_TESSELATION.length / 3;
    for (let i = 0; i < polyCount; i++) {
      indices.push(face_mesh.FACEMESH_TESSELATION[i * 3 + 0][0]);
      indices.push(face_mesh.FACEMESH_TESSELATION[i * 3 + 1][0]);
      indices.push(face_mesh.FACEMESH_TESSELATION[i * 3 + 2][0]);
    }
    geometry.setIndex(indices);
    geometry.computeVertexNormals();
    const object = this.createObject(geometry, Constant/* ObjectType.MESH */.LP.MESH);
    CoreComputerVisionFace.setAttributes(object, this.pv);
    this.setObject(object);
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/sop/TrackingLandmarksFaceAttributes.ts





class TrackingLandmarksFaceAttributesSopParamsConfig extends CoreComputerVisionFaceParamConfig(params_ParamsConfig/* NodeParamsConfig */.yI) {
}
const TrackingLandmarksFaceAttributes_ParamsConfig = new TrackingLandmarksFaceAttributesSopParamsConfig();
class TrackingLandmarksFaceAttributesSopNode extends sop_Base/* TypedSopNode */.x {
  constructor() {
    super(...arguments);
    this.paramsConfig = TrackingLandmarksFaceAttributes_ParamsConfig;
  }
  static type() {
    return "trackingLandmarksFaceAttributes";
  }
  initializeNode() {
    this.io.inputs.setCount(1);
    this.io.inputs.initInputsClonedState(InputCloneMode/* InputCloneMode.FROM_NODE */.m.FROM_NODE);
  }
  cook(inputCoreGroups) {
    const inputCoreGroup = inputCoreGroups[0];
    const objects = inputCoreGroup.threejsObjects();
    for (const object of objects) {
      CoreComputerVisionFace.setAttributes(object, this.pv);
    }
    this.setCoreGroup(inputCoreGroup);
  }
}

// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/core/computerVision/hand/Data.ts
var hand_Data = __webpack_require__(50302);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/node_modules/@mediapipe/hands/hands.js
var hands_hands = __webpack_require__(71868);
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/core/computerVision/hand/Common.ts

var CoreComputerVisionHandAttribute = /* @__PURE__ */ ((CoreComputerVisionHandAttribute2) => {
  CoreComputerVisionHandAttribute2["SELFIE_MODE"] = "CoreComputerVisionHand-selfieMode";
  CoreComputerVisionHandAttribute2["MAX_NUM_HANDS"] = "CoreComputerVisionHand-maxNumHands";
  CoreComputerVisionHandAttribute2["MODEL_COMPLEXITY"] = "CoreComputerVisionHand-modelComplexity";
  CoreComputerVisionHandAttribute2["MIN_DETECTION_CONFIDENCE"] = "CoreComputerVisionHand-minDetectionConfidence";
  CoreComputerVisionHandAttribute2["MAX_TRACKING_CONFIDENCE"] = "CoreComputerVisionHand-minTrackingConfidence";
  CoreComputerVisionHandAttribute2["KEY"] = "CoreComputerVisionHand-key";
  return CoreComputerVisionHandAttribute2;
})(CoreComputerVisionHandAttribute || {});
var CoreComputerVisionHandIndex = /* @__PURE__ */ ((CoreComputerVisionHandIndex2) => {
  CoreComputerVisionHandIndex2[CoreComputerVisionHandIndex2["WRIST"] = 0] = "WRIST";
  CoreComputerVisionHandIndex2[CoreComputerVisionHandIndex2["THUMB_CMC"] = 1] = "THUMB_CMC";
  CoreComputerVisionHandIndex2[CoreComputerVisionHandIndex2["THUMB_MCP"] = 2] = "THUMB_MCP";
  CoreComputerVisionHandIndex2[CoreComputerVisionHandIndex2["THUMB_IP"] = 3] = "THUMB_IP";
  CoreComputerVisionHandIndex2[CoreComputerVisionHandIndex2["THUMB_TIP"] = 4] = "THUMB_TIP";
  CoreComputerVisionHandIndex2[CoreComputerVisionHandIndex2["INDEX_FINGER_MCP"] = 5] = "INDEX_FINGER_MCP";
  CoreComputerVisionHandIndex2[CoreComputerVisionHandIndex2["INDEX_FINGER_PIP"] = 6] = "INDEX_FINGER_PIP";
  CoreComputerVisionHandIndex2[CoreComputerVisionHandIndex2["INDEX_FINGER_DIP"] = 7] = "INDEX_FINGER_DIP";
  CoreComputerVisionHandIndex2[CoreComputerVisionHandIndex2["INDEX_FINGER_TIP"] = 8] = "INDEX_FINGER_TIP";
  CoreComputerVisionHandIndex2[CoreComputerVisionHandIndex2["MIDDLE_FINGER_MCP"] = 9] = "MIDDLE_FINGER_MCP";
  CoreComputerVisionHandIndex2[CoreComputerVisionHandIndex2["MIDDLE_FINGER_PIP"] = 10] = "MIDDLE_FINGER_PIP";
  CoreComputerVisionHandIndex2[CoreComputerVisionHandIndex2["MIDDLE_FINGER_DIP"] = 11] = "MIDDLE_FINGER_DIP";
  CoreComputerVisionHandIndex2[CoreComputerVisionHandIndex2["MIDDLE_FINGER_TIP"] = 12] = "MIDDLE_FINGER_TIP";
  CoreComputerVisionHandIndex2[CoreComputerVisionHandIndex2["RING_FINGER_MCP"] = 13] = "RING_FINGER_MCP";
  CoreComputerVisionHandIndex2[CoreComputerVisionHandIndex2["RING_FINGER_PIP"] = 14] = "RING_FINGER_PIP";
  CoreComputerVisionHandIndex2[CoreComputerVisionHandIndex2["RING_FINGER_DIP"] = 15] = "RING_FINGER_DIP";
  CoreComputerVisionHandIndex2[CoreComputerVisionHandIndex2["RING_FINGER_TIP"] = 16] = "RING_FINGER_TIP";
  CoreComputerVisionHandIndex2[CoreComputerVisionHandIndex2["PINKY_MCP"] = 17] = "PINKY_MCP";
  CoreComputerVisionHandIndex2[CoreComputerVisionHandIndex2["PINKY_PIP"] = 18] = "PINKY_PIP";
  CoreComputerVisionHandIndex2[CoreComputerVisionHandIndex2["PINKY_DIP"] = 19] = "PINKY_DIP";
  CoreComputerVisionHandIndex2[CoreComputerVisionHandIndex2["PINKY_TIP"] = 20] = "PINKY_TIP";
  return CoreComputerVisionHandIndex2;
})(CoreComputerVisionHandIndex || {});

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/core/computerVision/hand/CoreComputerVisionHand.ts








const CoreComputerVisionHand_DEFAULT = {
  selfieMode: false,
  maxNumHands: 1,
  modelComplexity: true,
  minDetectionConfidence: 0.5,
  minTrackingConfidence: 0.5
};
function CoreComputerVisionHandParamConfig(Base) {
  return class Mixin extends Base {
    constructor() {
      super(...arguments);
      /** @param selfieMode */
      this.selfieMode = params_ParamsConfig/* ParamConfig.BOOLEAN */.XC.BOOLEAN(CoreComputerVisionHand_DEFAULT.selfieMode);
      /** @param Maximum number of hands to detect */
      this.maxNumHands = params_ParamsConfig/* ParamConfig.INTEGER */.XC.INTEGER(CoreComputerVisionHand_DEFAULT.maxNumHands, {
        range: [0, 2],
        rangeLocked: [true, false]
      });
      /** @param Complexity of the hand landmark model: 0 or 1. Landmark accuracy as well as inference latency generally go up with the model complexity */
      this.modelComplexity = params_ParamsConfig/* ParamConfig.BOOLEAN */.XC.BOOLEAN(CoreComputerVisionHand_DEFAULT.modelComplexity);
      /** @param Minimum confidence value ([0.0, 1.0]) from the hand detection model for the detection to be considered successful */
      this.minDetectionConfidence = params_ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(CoreComputerVisionHand_DEFAULT.minDetectionConfidence, {
        range: [0, 1],
        rangeLocked: [true, true]
      });
      /** @param Minimum confidence value ([0.0, 1.0]) from the landmark-tracking model for the hand landmarks to be considered tracked successfully, or otherwise hand detection will be invoked automatically on the next input image. Setting it to a higher value can increase robustness of the solution, at the expense of a higher latency. Ignored if static_image_mode is true, where hand detection simply runs on every image */
      this.minTrackingConfidence = params_ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(CoreComputerVisionHand_DEFAULT.minTrackingConfidence, {
        range: [0, 1],
        rangeLocked: [true, true]
      });
    }
  };
}
function CoreComputerVisionHand_locateFile(file) {
  return `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`;
}
function CoreComputerVisionHand_attributes(object) {
  const coreObjectClass = (0,CoreObjectFactory/* coreObjectClassFactory */.Xr)(object);
  const selfieMode = coreObjectClass.attribValue(object, CoreComputerVisionHandAttribute.SELFIE_MODE);
  const maxNumHands = coreObjectClass.attribValue(object, CoreComputerVisionHandAttribute.MAX_NUM_HANDS);
  const modelComplexity = coreObjectClass.attribValue(object, CoreComputerVisionHandAttribute.MODEL_COMPLEXITY);
  const minDetectionConfidence = coreObjectClass.attribValue(
    object,
    CoreComputerVisionHandAttribute.MIN_DETECTION_CONFIDENCE
  );
  const minTrackingConfidence = coreObjectClass.attribValue(
    object,
    CoreComputerVisionHandAttribute.MAX_TRACKING_CONFIDENCE
  );
  const data = {
    selfieMode: Type/* CoreType.isBoolean */.MR.isBoolean(selfieMode) ? selfieMode : CoreComputerVisionHand_DEFAULT.selfieMode,
    maxNumHands: Type/* CoreType.isNumber */.MR.isNumber(maxNumHands) ? maxNumHands : CoreComputerVisionHand_DEFAULT.maxNumHands,
    modelComplexity: Type/* CoreType.isBoolean */.MR.isBoolean(modelComplexity) ? modelComplexity : CoreComputerVisionHand_DEFAULT.modelComplexity,
    minDetectionConfidence: Type/* CoreType.isNumber */.MR.isNumber(minDetectionConfidence) ? minDetectionConfidence : CoreComputerVisionHand_DEFAULT.minDetectionConfidence,
    minTrackingConfidence: Type/* CoreType.isNumber */.MR.isNumber(minTrackingConfidence) ? minTrackingConfidence : CoreComputerVisionHand_DEFAULT.minTrackingConfidence
  };
  return data;
}
function CoreComputerVisionHand_trackerOptions(attributes2) {
  return {
    selfieMode: attributes2.selfieMode,
    maxNumHands: attributes2.maxNumHands,
    modelComplexity: attributes2.modelComplexity ? 1 : 0,
    minDetectionConfidence: attributes2.minDetectionConfidence,
    minTrackingConfidence: attributes2.minTrackingConfidence
  };
}
function CoreComputerVisionHand_createKey(object) {
  return JSON.stringify(CoreComputerVisionHand_attributes(object));
}
function CoreComputerVisionHand_createConvertedResult() {
  const pointsCount = hand_Data/* DEFAULT_POSITION.length */.Bg.length / 3;
  const multiHandLandmarks = new Array(pointsCount);
  const multiHandWorldLandmarks = new Array(pointsCount);
  for (let i = 0; i < pointsCount; i++) {
    multiHandLandmarks[i] = new three_module.Vector4();
    multiHandWorldLandmarks[i] = new three_module.Vector4();
  }
  return {
    multiHandLandmarks,
    multiHandWorldLandmarks,
    score: 0,
    side: 0
  };
}
function CoreComputerVisionHand_updateConvertedResult(convertedResult, results, index) {
  const multiHandLandmarks = results.multiHandLandmarks[index];
  for (let i = 0; i < multiHandLandmarks.length; i++) {
    const landmark = multiHandLandmarks[i];
    convertedResult.multiHandLandmarks[i].set(
      landmark.x,
      1 - landmark.y,
      landmark.z,
      landmark.visibility != null ? landmark.visibility : 0
    );
  }
  const multiHandWorldLandmarks = results.multiHandWorldLandmarks[index];
  for (let i = 0; i < multiHandWorldLandmarks.length; i++) {
    const landmark = multiHandWorldLandmarks[i];
    convertedResult.multiHandWorldLandmarks[i].set(
      landmark.x,
      landmark.y,
      landmark.z,
      landmark.visibility != null ? landmark.visibility : 0
    );
  }
  const handedness = results.multiHandedness[index];
  convertedResult.score = handedness.score;
  convertedResult.side = handedness.label == "Right" ? 1 : 0;
}
class CoreComputerVisionHand_TrackerContainer {
  constructor(tracker) {
    this.tracker = tracker;
    this._inProgress = false;
    this.results = [];
    for (let i = 0; i < 3; i++) {
      this.results.push(CoreComputerVisionHand_createConvertedResult());
    }
    tracker.onResults((results) => {
      this._inProgress = false;
      const subResultsCount = results.multiHandLandmarks.length;
      for (let i = 0; i < subResultsCount; i++) {
        CoreComputerVisionHand_updateConvertedResult(this.results[i], results, i);
      }
    });
  }
  track(source) {
    if (this._inProgress) {
      return;
    }
    this._inProgress = true;
    this.tracker.send({ image: source });
  }
}
class CoreComputerVisionHand {
  static trackerForObject(object) {
    const key = this.trackerKey(object);
    let tracker = this.trackerByKey.get(key);
    if (!tracker) {
      tracker = this._createTracker(CoreComputerVisionHand_trackerOptions(CoreComputerVisionHand_attributes(object)));
      this.trackerByKey.set(key, tracker);
    }
    return tracker;
  }
  static trackMedia(object, source) {
    const tracker = this.trackerForObject(object);
    tracker.track(source);
  }
  static trackerResults(object) {
    return this.trackerForObject(object).results;
  }
  static _createTracker(options) {
    const hands = new hands_hands.Hands({
      locateFile: CoreComputerVisionHand_locateFile
    });
    hands.setOptions(options);
    return new CoreComputerVisionHand_TrackerContainer(hands);
  }
  static trackerKey(object) {
    const coreObjectClass = (0,CoreObjectFactory/* coreObjectClassFactory */.Xr)(object);
    let key = coreObjectClass.attribValue(object, CoreComputerVisionHandAttribute.KEY);
    if (!key || !Type/* CoreType.isString */.MR.isString(key)) {
      key = CoreComputerVisionHand_createKey(object);
      coreObjectClass.addAttribute(object, CoreComputerVisionHandAttribute.KEY, key);
    }
    return key;
  }
  static setAttributes(object, options) {
    const coreObjectClass = (0,CoreObjectFactory/* coreObjectClassFactory */.Xr)(object);
    coreObjectClass.addAttribute(object, CoreComputerVisionHandAttribute.SELFIE_MODE, options.selfieMode);
    coreObjectClass.addAttribute(object, CoreComputerVisionHandAttribute.MAX_NUM_HANDS, options.maxNumHands);
    coreObjectClass.addAttribute(object, CoreComputerVisionHandAttribute.MODEL_COMPLEXITY, options.modelComplexity);
    coreObjectClass.addAttribute(
      object,
      CoreComputerVisionHandAttribute.MIN_DETECTION_CONFIDENCE,
      options.minDetectionConfidence
    );
    coreObjectClass.addAttribute(
      object,
      CoreComputerVisionHandAttribute.MAX_TRACKING_CONFIDENCE,
      options.minTrackingConfidence
    );
  }
}
CoreComputerVisionHand.trackerByKey = /* @__PURE__ */ new Map();

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/sop/TrackingLandmarksHand.ts









class TrackingLandmarksHandSopParamsConfig extends CoreComputerVisionHandParamConfig(params_ParamsConfig/* NodeParamsConfig */.yI) {
}
const TrackingLandmarksHand_ParamsConfig = new TrackingLandmarksHandSopParamsConfig();
class TrackingLandmarksHandSopNode extends sop_Base/* TypedSopNode */.x {
  constructor() {
    super(...arguments);
    this.paramsConfig = TrackingLandmarksHand_ParamsConfig;
  }
  static type() {
    return "trackingLandmarksHand";
  }
  cook() {
    const geometry = new three_module.BufferGeometry();
    const positionArray = hand_Data/* DEFAULT_POSITION */.Bg;
    geometry.setAttribute(geometry_Attribute/* Attribute.POSITION */.ah.POSITION, new three_module.BufferAttribute(new Float32Array(positionArray), 3));
    const indices = [];
    const linesCount = hands_hands.HAND_CONNECTIONS.length;
    for (let i = 0; i < linesCount; i++) {
      indices.push(hands_hands.HAND_CONNECTIONS[i][0]);
      indices.push(hands_hands.HAND_CONNECTIONS[i][1]);
    }
    geometry.setIndex(indices);
    geometry.computeVertexNormals();
    const object = this.createObject(geometry, Constant/* ObjectType.LINE_SEGMENTS */.LP.LINE_SEGMENTS);
    CoreComputerVisionHand.setAttributes(object, this.pv);
    this.setObject(object);
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/sop/TrackingLandmarksHandAttributes.ts





class TrackingLandmarksHandAttributesSopParamsConfig extends CoreComputerVisionHandParamConfig(params_ParamsConfig/* NodeParamsConfig */.yI) {
}
const TrackingLandmarksHandAttributes_ParamsConfig = new TrackingLandmarksHandAttributesSopParamsConfig();
class TrackingLandmarksHandAttributesSopNode extends sop_Base/* TypedSopNode */.x {
  constructor() {
    super(...arguments);
    this.paramsConfig = TrackingLandmarksHandAttributes_ParamsConfig;
  }
  static type() {
    return "trackingLandmarksHandAttributes";
  }
  initializeNode() {
    this.io.inputs.setCount(1);
    this.io.inputs.initInputsClonedState(InputCloneMode/* InputCloneMode.FROM_NODE */.m.FROM_NODE);
  }
  cook(inputCoreGroups) {
    const inputCoreGroup = inputCoreGroups[0];
    const objects = inputCoreGroup.threejsObjects();
    for (const object of objects) {
      CoreComputerVisionHand.setAttributes(object, this.pv);
    }
    this.setCoreGroup(inputCoreGroup);
  }
}

// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/nodes/sop/Transform.ts
var sop_Transform = __webpack_require__(85114);
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/sop/TransformCopy.ts

var TransformCopy_async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};






class TransformCopySopParamConfig extends params_ParamsConfig/* NodeParamsConfig */.yI {
  constructor() {
    super(...arguments);
    /** @param toggle on if the second input should be used */
    this.useSecondInput = params_ParamsConfig/* ParamConfig.BOOLEAN */.XC.BOOLEAN(1);
    /** @param use a reference object */
    this.reference = params_ParamsConfig/* ParamConfig.NODE_PATH */.XC.NODE_PATH("", {
      nodeSelection: {
        context: poly_NodeContext/* NodeContext.SOP */.sy.SOP
      },
      visibleIf: { useSecondInput: 0 }
    });
  }
}
const TransformCopy_ParamsConfig = new TransformCopySopParamConfig();
class TransformCopySopNode extends sop_Base/* TypedSopNode */.x {
  constructor() {
    super(...arguments);
    this.paramsConfig = TransformCopy_ParamsConfig;
  }
  static type() {
    return Sop/* SopType.TRANSFORM_COPY */.aB.TRANSFORM_COPY;
  }
  initializeNode() {
    this.io.inputs.setCount(1, 2);
    this.io.inputs.initInputsClonedState([InputCloneMode/* InputCloneMode.FROM_NODE */.m.FROM_NODE, InputCloneMode/* InputCloneMode.NEVER */.m.NEVER]);
  }
  cook(input_contents) {
    if ((0,Type/* isBooleanTrue */.bI)(this.pv.useSecondInput) && input_contents[1]) {
      this._copy_from_src_objects(input_contents[0].threejsObjects(), input_contents[1].threejsObjects());
    } else {
      this._copy_from_found_node(input_contents[0].threejsObjects());
    }
  }
  _copy_from_src_objects(target_objects, src_objects) {
    let target_object;
    let src_object;
    for (let i = 0; i < target_objects.length; i++) {
      target_object = target_objects[i];
      src_object = src_objects[i];
      src_object.updateMatrix();
      target_object.matrix.copy(src_object.matrix);
      target_object.matrix.decompose(target_object.position, target_object.quaternion, target_object.scale);
    }
    this.setObjects(target_objects);
  }
  _copy_from_found_node(target_objects) {
    return TransformCopy_async(this, null, function* () {
      const node = this.pv.reference.nodeWithContext(poly_NodeContext/* NodeContext.SOP */.sy.SOP, this.states.error);
      if (node) {
        const container = yield node.compute();
        const core_group = container.coreContent();
        if (core_group) {
          const src_objects = core_group.threejsObjects();
          this._copy_from_src_objects(target_objects, src_objects);
          return;
        }
      }
      this.setObjects(target_objects);
    });
  }
}

// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/nodes/sop/TransformMulti.ts
var TransformMulti = __webpack_require__(32495);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/nodes/sop/TransformReset.ts
var TransformReset = __webpack_require__(94176);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/nodes/sop/Tube.ts
var Tube = __webpack_require__(84960);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/core/libs/Potpack.ts
var Potpack = __webpack_require__(9788);
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/operations/sop/UvLayout.ts





class UvLayoutSopOperation extends operations_sop_Base/* BaseSopOperation */.U {
  static type() {
    return Sop/* SopType.UV_LAYOUT */.aB.UV_LAYOUT;
  }
  cook(inputCoreGroups, params) {
    const coreGroup = inputCoreGroups[0];
    const objects = coreGroup.threejsObjectsWithGeo();
    const meshes = [];
    for (let object of objects) {
      const mesh = object;
      if (mesh.isMesh) {
        meshes.push(mesh);
      }
    }
    this._layoutUVs(meshes, params);
    return coreGroup;
  }
  _layoutUVs(meshes, params) {
    var _a;
    const uv_boxes = [];
    const objIndexByBox = /* @__PURE__ */ new WeakMap();
    const padding = params.padding / params.res;
    let index = 0;
    for (let mesh of meshes) {
      if (!mesh.geometry.hasAttribute(params.uv)) {
        (_a = this.states) == null ? void 0 : _a.error.set(`attribute ${params.uv} not found`);
      }
      const box = { w: 1 + padding * 2, h: 1 + padding * 2 };
      uv_boxes.push(box);
      objIndexByBox.set(box, index);
      index++;
    }
    const dimensions = (0,Potpack/* Potpack */.B)(uv_boxes);
    for (let uv_box of uv_boxes) {
      const uvBoxResult = uv_box;
      const index2 = objIndexByBox.get(uv_box);
      if (index2 != null) {
        const mesh = meshes[index2];
        const uv2 = mesh.geometry.getAttribute(params.uv).clone();
        const array = uv2.array;
        for (let i = 0; i < uv2.array.length; i += uv2.itemSize) {
          array[i] = (uv2.array[i] + uvBoxResult.x + padding) / dimensions.w;
          array[i + 1] = (uv2.array[i + 1] + uvBoxResult.y + padding) / dimensions.h;
        }
        mesh.geometry.setAttribute(params.uv2, uv2);
        mesh.geometry.getAttribute(params.uv2).needsUpdate = true;
      }
    }
  }
}
UvLayoutSopOperation.DEFAULT_PARAMS = {
  res: 1024,
  padding: 3,
  uv: "uv",
  uv2: "uvLightMap"
};
UvLayoutSopOperation.INPUT_CLONED_STATE = InputCloneMode/* InputCloneMode.FROM_NODE */.m.FROM_NODE;

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/sop/UvLayout.ts





const UvLayout_DEFAULT = UvLayoutSopOperation.DEFAULT_PARAMS;
class UvLayoutSopParamConfig extends params_ParamsConfig/* NodeParamsConfig */.yI {
  constructor() {
    super(...arguments);
    /** @param expected map resolution */
    this.res = params_ParamsConfig/* ParamConfig.INTEGER */.XC.INTEGER(UvLayout_DEFAULT.res);
    /** @param padding between uv islands, in pixels */
    this.padding = params_ParamsConfig/* ParamConfig.INTEGER */.XC.INTEGER(UvLayout_DEFAULT.padding);
    /** @param uv attribute to layout */
    this.uv = params_ParamsConfig/* ParamConfig.STRING */.XC.STRING(UvLayout_DEFAULT.uv);
    /** @param new uv attribute that will be set or created */
    this.uv2 = params_ParamsConfig/* ParamConfig.STRING */.XC.STRING(UvLayout_DEFAULT.uv2);
  }
}
const UvLayout_ParamsConfig = new UvLayoutSopParamConfig();
class UvLayoutSopNode extends sop_Base/* TypedSopNode */.x {
  constructor() {
    super(...arguments);
    this.paramsConfig = UvLayout_ParamsConfig;
  }
  static type() {
    return Sop/* SopType.UV_LAYOUT */.aB.UV_LAYOUT;
  }
  initializeNode() {
    this.io.inputs.setCount(1);
    this.io.inputs.initInputsClonedState(UvLayoutSopOperation.INPUT_CLONED_STATE);
  }
  cook(input_contents) {
    this._operation = this._operation || new UvLayoutSopOperation(this.scene(), this.states, this);
    const core_group = this._operation.cook(input_contents, this.pv);
    this.setCoreGroup(core_group);
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/core/CameraController.ts

var EVENT = /* @__PURE__ */ ((EVENT2) => {
  EVENT2["CHANGE"] = "change";
  EVENT2["MOVEEND"] = "moveend";
  return EVENT2;
})(EVENT || {});
class CameraController {
  constructor(_callback) {
    this._callback = _callback;
    this._updateAlways = true;
    this._listenerAdded = false;
    this._listener = this._executeCallback.bind(this);
  }
  removeTarget() {
    this.setTarget(void 0);
  }
  setTarget(target) {
    if (!target) {
      this._removeCameraEvent();
    }
    const old_target = this._target;
    this._target = target;
    if (this._target != null) {
      this._executeCallback();
    }
    if ((this._target != null ? this._target.uuid : void 0) !== (old_target != null ? old_target.uuid : void 0)) {
      this._addCameraEvent();
    }
  }
  setUpdateAlways(newUpdateAlways) {
    this._removeCameraEvent();
    this._updateAlways = newUpdateAlways;
    this._addCameraEvent();
  }
  _currentEventName() {
    if (this._updateAlways) {
      return "change" /* CHANGE */;
    } else {
      return "moveend" /* MOVEEND */;
    }
  }
  _addCameraEvent() {
    if (this._listenerAdded) {
      return;
    }
    if (this._target != null) {
      this._target.addEventListener(this._currentEventName(), this._listener);
      this._listenerAdded = true;
    }
  }
  _removeCameraEvent() {
    if (this._listenerAdded !== true) {
      return;
    }
    if (this._target != null) {
      this._target.removeEventListener(this._currentEventName(), this._listener);
      this._listenerAdded = false;
    }
  }
  _executeCallback() {
    if (this._target != null) {
      this._callback(this._target);
    }
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/sop/UvProject.ts







const UV_NAME = "uv";
const UvProject_position = new three_module.Vector3();
const UvProject_points = [];
class UvProjectSopParamsConfig extends params_ParamsConfig/* NodeParamsConfig */.yI {
  constructor() {
    super(...arguments);
    /** @param camera node to use as projection */
    this.camera = params_ParamsConfig/* ParamConfig.NODE_PATH */.XC.NODE_PATH("", {
      nodeSelection: {
        context: poly_NodeContext/* NodeContext.OBJ */.sy.OBJ,
        types: poly_NodeContext/* CAMERA_TYPES */.o2
      }
    });
  }
  // force_aspect = ParamConfig.BOOLEAN(0)
  // aspect = ParamConfig.FLOAT(1, {
  // 	range: [0, 2],
  // 	visibleIf: {force_aspect: 1},
  // })
}
const UvProject_ParamsConfig = new UvProjectSopParamsConfig();
class UvProjectSopNode extends sop_Base/* TypedSopNode */.x {
  constructor() {
    super(...arguments);
    this.paramsConfig = UvProject_ParamsConfig;
    this._cameraController = new CameraController(this._updateUVsFromCamera.bind(this));
  }
  static type() {
    return "uvProject";
  }
  initializeNode() {
    this.io.inputs.setCount(1);
    this.io.inputs.initInputsClonedState(InputCloneMode/* InputCloneMode.FROM_NODE */.m.FROM_NODE);
  }
  cook(core_groups) {
    this._processed_core_group = core_groups[0];
    const cameraNode = this.pv.camera.nodeWithContext(poly_NodeContext/* NodeContext.OBJ */.sy.OBJ, this.states.error);
    if (cameraNode != null && poly_NodeContext/* CAMERA_TYPES.includes */.o2.includes(cameraNode.type())) {
      this._camera_object = cameraNode.object;
      this._cameraController.setTarget(this._camera_object);
    } else {
      this._camera_object = void 0;
      this._cameraController.removeTarget();
    }
    this.setCoreGroup(this._processed_core_group);
  }
  _updateUVsFromCamera(look_at_target) {
    const parent = this.parent();
    if (this._processed_core_group && parent) {
      this._processed_core_group.points(UvProject_points);
      const obj_world_matrix = parent.object.matrixWorld;
      for (const point of UvProject_points) {
        point.position(UvProject_position);
        const uvw = this._vectorInCameraSpace(UvProject_position, obj_world_matrix);
        if (uvw) {
          const uv = {
            x: 1 - (uvw[0] * 0.5 + 0.5),
            y: uvw[1] * 0.5 + 0.5
          };
          point.setAttribValue(UV_NAME, uv);
        }
      }
    }
  }
  _vectorInCameraSpace(vector, obj_world_matrix) {
    if (this._camera_object) {
      vector.applyMatrix4(obj_world_matrix);
      return vector.project(this._camera_object).toArray();
    }
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/operations/sop/UvTransform.ts





class UvTransformSopOperation extends operations_sop_Base/* BaseSopOperation */.U {
  static type() {
    return Sop/* SopType.UV_TRANSFORM */.aB.UV_TRANSFORM;
  }
  cook(input_contents, params) {
    const objects = input_contents[0].threejsObjectsWithGeo();
    for (let object of objects) {
      const geometry = object.geometry;
      const attrib = geometry.getAttribute(params.attribName);
      const array = attrib.array;
      const ptsCount = array.length / 2;
      for (let i = 0; i < ptsCount; i++) {
        array[i * 2 + 0] = params.t.x + params.pivot.x + params.s.x * (array[i * 2 + 0] - params.pivot.x);
        array[i * 2 + 1] = params.t.y + params.pivot.y + params.s.y * (array[i * 2 + 1] - params.pivot.y);
      }
      attrib.needsUpdate = true;
    }
    return input_contents[0];
  }
}
UvTransformSopOperation.DEFAULT_PARAMS = {
  attribName: "uv",
  t: new three_module.Vector2(0, 0),
  s: new three_module.Vector2(1, 1),
  pivot: new three_module.Vector2(0, 0)
};
UvTransformSopOperation.INPUT_CLONED_STATE = InputCloneMode/* InputCloneMode.FROM_NODE */.m.FROM_NODE;

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/sop/UvTransform.ts





const UvTransform_DEFAULT = UvTransformSopOperation.DEFAULT_PARAMS;
class UvTransformSopParamsConfig extends params_ParamsConfig/* NodeParamsConfig */.yI {
  constructor() {
    super(...arguments);
    /** @param attribName */
    this.attribName = params_ParamsConfig/* ParamConfig.STRING */.XC.STRING(UvTransform_DEFAULT.attribName);
    /** @param translate */
    this.t = params_ParamsConfig/* ParamConfig.VECTOR2 */.XC.VECTOR2(UvTransform_DEFAULT.t.toArray());
    /** @param scale */
    this.s = params_ParamsConfig/* ParamConfig.VECTOR2 */.XC.VECTOR2(UvTransform_DEFAULT.s.toArray());
    /** @param pivot */
    this.pivot = params_ParamsConfig/* ParamConfig.VECTOR2 */.XC.VECTOR2(UvTransform_DEFAULT.pivot.toArray());
  }
}
const UvTransform_ParamsConfig = new UvTransformSopParamsConfig();
class UvTransformSopNode extends sop_Base/* TypedSopNode */.x {
  constructor() {
    super(...arguments);
    this.paramsConfig = UvTransform_ParamsConfig;
  }
  static type() {
    return Sop/* SopType.UV_TRANSFORM */.aB.UV_TRANSFORM;
  }
  initializeNode() {
    this.io.inputs.setCount(1);
    this.io.inputs.initInputsClonedState(UvTransformSopOperation.INPUT_CLONED_STATE);
  }
  cook(input_contents) {
    this._operation = this._operation || new UvTransformSopOperation(this.scene(), this.states, this);
    const core_group = this._operation.cook(input_contents, this.pv);
    this.setCoreGroup(core_group);
  }
}

// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/nodes/sop/UvUnwrap.ts
var UvUnwrap = __webpack_require__(50142);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/core/webXR/webXRAR/CoreWebXRAREstimatedLightController.ts + 1 modules
var CoreWebXRAREstimatedLightController = __webpack_require__(13317);
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/sop/WebXRAREstimatedLight.ts







const ATTRIB_NAME = CoreWebXRAREstimatedLightController/* CoreWebXRAREstimatedLightController.ATTRIB_NAME */.p.ATTRIB_NAME;
class WebXRAREstimatedLightSopParamsConfig extends params_ParamsConfig/* NodeParamsConfig */.yI {
  constructor() {
    super(...arguments);
    /** @param default environment map */
    // defaultEnvironment = ParamConfig.NODE_PATH('', {
    // 	nodeSelection: {
    // 		context: NodeContext.COP,
    // 	},
    // });
    /** @param apply computed environment */
    this.applyEnv = params_ParamsConfig/* ParamConfig.BOOLEAN */.XC.BOOLEAN(1);
    /** @param apply computed light Probe */
    this.applyLightProbe = params_ParamsConfig/* ParamConfig.BOOLEAN */.XC.BOOLEAN(1);
    /** @param apply computed directional Light */
    this.applyDirectionalLight = params_ParamsConfig/* ParamConfig.BOOLEAN */.XC.BOOLEAN(1);
  }
  /** @param directional Light intensity */
  // directionalLightIntensity = ParamConfig.FLOAT(1, {
  // 	range: [0, 1],
  // 	rangeLocked: [true, false],
  // 	visibleIf: {
  // 		applyDirectionalLight: 1,
  // 	},
  // });
}
const WebXRAREstimatedLight_ParamsConfig = new WebXRAREstimatedLightSopParamsConfig();
class WebXRAREstimatedLightSopNode extends sop_Base/* TypedSopNode */.x {
  constructor() {
    super(...arguments);
    this.paramsConfig = WebXRAREstimatedLight_ParamsConfig;
  }
  static type() {
    return Sop/* SopType.WEB_XR_AR_ESTIMATED_LIGHT */.aB.WEB_XR_AR_ESTIMATED_LIGHT;
  }
  initializeNode() {
    this.io.inputs.setCount(0, 1);
  }
  cook(inputCoreGroups) {
    const coreGroup = inputCoreGroups[0];
    const defaultLightsParent = new three_module.Group();
    defaultLightsParent.name = `defaultLightsParent`;
    defaultLightsParent.matrixAutoUpdate = false;
    ThreejsCoreObject/* ThreejsCoreObject.addAttribute */.W.addAttribute(defaultLightsParent, ATTRIB_NAME.IS_DEFAULT_LIGHTS_PARENT, true);
    const objects = coreGroup.threejsObjects();
    for (const object of objects) {
      defaultLightsParent.add(object);
    }
    const group = new three_module.Group();
    group.name = this.path();
    group.matrixAutoUpdate = false;
    group.add(defaultLightsParent);
    ThreejsCoreObject/* ThreejsCoreObject.addAttribute */.W.addAttribute(group, ATTRIB_NAME.IS_ESTIMATED_LIGHT, true);
    ThreejsCoreObject/* ThreejsCoreObject.addAttribute */.W.addAttribute(group, ATTRIB_NAME.APPLY_ENV, this.pv.applyEnv);
    ThreejsCoreObject/* ThreejsCoreObject.addAttribute */.W.addAttribute(group, ATTRIB_NAME.APPLY_LIGHT_PROBE, this.pv.applyLightProbe);
    ThreejsCoreObject/* ThreejsCoreObject.addAttribute */.W.addAttribute(group, ATTRIB_NAME.APPLY_DIR_LIGHT, this.pv.applyDirectionalLight);
    this.setObject(group);
  }
}

// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/core/wfc/WFCTilesCollection.ts
var WFCTilesCollection = __webpack_require__(93683);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/core/wfc/WFCUtils.ts
var WFCUtils = __webpack_require__(45370);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/core/wfc/WFCTileConfig.ts
var WFCTileConfig = __webpack_require__(21833);
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/core/wfc/WFCTileDeform.ts



const WFCTileDeform_cubeLatticeDeformPoints = [
  new three_module.Vector3(),
  new three_module.Vector3(),
  new three_module.Vector3(),
  new three_module.Vector3(),
  new three_module.Vector3(),
  new three_module.Vector3(),
  new three_module.Vector3(),
  new three_module.Vector3()
];
const WFCTileDeform_offset = new three_module.Vector3(0.5, 0.5, 0.5);
function tileCubeLatticeDeform(object, tileCorners, rotation) {
  switch (rotation) {
    case 0: {
      WFCTileDeform_cubeLatticeDeformPoints[0].copy(tileCorners.p0);
      WFCTileDeform_cubeLatticeDeformPoints[1].copy(tileCorners.p1);
      WFCTileDeform_cubeLatticeDeformPoints[2].copy(tileCorners.p2);
      WFCTileDeform_cubeLatticeDeformPoints[3].copy(tileCorners.p3);
      break;
    }
    case 1: {
      WFCTileDeform_cubeLatticeDeformPoints[0].copy(tileCorners.p3);
      WFCTileDeform_cubeLatticeDeformPoints[1].copy(tileCorners.p0);
      WFCTileDeform_cubeLatticeDeformPoints[2].copy(tileCorners.p1);
      WFCTileDeform_cubeLatticeDeformPoints[3].copy(tileCorners.p2);
      break;
    }
    case 2: {
      WFCTileDeform_cubeLatticeDeformPoints[0].copy(tileCorners.p2);
      WFCTileDeform_cubeLatticeDeformPoints[1].copy(tileCorners.p3);
      WFCTileDeform_cubeLatticeDeformPoints[2].copy(tileCorners.p0);
      WFCTileDeform_cubeLatticeDeformPoints[3].copy(tileCorners.p1);
      break;
    }
    case 3: {
      WFCTileDeform_cubeLatticeDeformPoints[0].copy(tileCorners.p1);
      WFCTileDeform_cubeLatticeDeformPoints[1].copy(tileCorners.p2);
      WFCTileDeform_cubeLatticeDeformPoints[2].copy(tileCorners.p3);
      WFCTileDeform_cubeLatticeDeformPoints[3].copy(tileCorners.p0);
      break;
    }
  }
  WFCTileDeform_cubeLatticeDeformPoints[4].copy(WFCTileDeform_cubeLatticeDeformPoints[0]);
  WFCTileDeform_cubeLatticeDeformPoints[5].copy(WFCTileDeform_cubeLatticeDeformPoints[1]);
  WFCTileDeform_cubeLatticeDeformPoints[6].copy(WFCTileDeform_cubeLatticeDeformPoints[2]);
  WFCTileDeform_cubeLatticeDeformPoints[7].copy(WFCTileDeform_cubeLatticeDeformPoints[3]);
  WFCTileDeform_cubeLatticeDeformPoints[4].y += tileCorners.height;
  WFCTileDeform_cubeLatticeDeformPoints[5].y += tileCorners.height;
  WFCTileDeform_cubeLatticeDeformPoints[6].y += tileCorners.height;
  WFCTileDeform_cubeLatticeDeformPoints[7].y += tileCorners.height;
  CubeLatticeDeform_cubeLatticeDeform(object, WFCTileDeform_cubeLatticeDeformPoints, { offset: WFCTileDeform_offset, moveObjectPosition: true });
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/core/wfc/WFCBuilderUtils.ts






const tileCorners = {
  p0: new three_module.Vector3(),
  p1: new three_module.Vector3(),
  p2: new three_module.Vector3(),
  p3: new three_module.Vector3(),
  height: 1
};
function placeObjectOnQuad(options) {
  const tileObject = ThreejsCoreObject/* ThreejsCoreObject.clone */.W.clone(options.object);
  quadNodeCorners(options.quadObject, options.primitiveIndex, tileCorners);
  tileCorners.height = options.height;
  tileObject.traverse((child) => {
    tileCubeLatticeDeform(child, tileCorners, options.rotation);
  });
  return tileObject;
}
const WFCBuilderUtils_indices = {
  i0: 0,
  i1: 0,
  i2: 0,
  i3: 0
};
function quadNodeCorners(quadObject, primitiveIndex, target) {
  const quadGeometry = quadObject.geometry;
  const index = quadGeometry.index;
  const positionAttribute = quadGeometry.attributes[geometry_Attribute/* Attribute.POSITION */.ah.POSITION];
  if (!positionAttribute) {
    return target;
  }
  (0,QuadUtils/* quadPrimitivePointIndexIndices */.e)(primitiveIndex, WFCBuilderUtils_indices);
  const positionArray = positionAttribute.array;
  target.p0.fromArray(positionArray, index[WFCBuilderUtils_indices.i0] * 3);
  target.p1.fromArray(positionArray, index[WFCBuilderUtils_indices.i3] * 3);
  target.p2.fromArray(positionArray, index[WFCBuilderUtils_indices.i2] * 3);
  target.p3.fromArray(positionArray, index[WFCBuilderUtils_indices.i1] * 3);
}

// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/core/wfc/WFCConstant.ts
var WFCConstant = __webpack_require__(59184);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/core/wfc/WFCAttributes.ts
var WFCAttributes = __webpack_require__(3869);
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/core/wfc/WFCBuilder.ts










class WFCBuilder {
  constructor(options) {
    const { node, quadObject, tileAndRuleObjects, tileHeight } = options;
    this._node = node;
    this._quadObject = quadObject;
    this._tileObjects = (0,WFCUtils/* filterTileObjects */.TF)(tileAndRuleObjects);
    this._tileHeight = tileHeight;
    this._tilesCollection = new WFCTilesCollection/* WFCTilesCollection */.E({ tileAndRuleObjects });
    this._primitivesCount = QuadPrimitive/* QuadPrimitive.entitiesCount */.C.entitiesCount(quadObject);
    const hasAttribute = QuadPrimitive/* QuadPrimitive.hasAttribute */.C.hasAttribute(quadObject, WFCAttributes/* WFCQuadAttribute.SOLVED_TILE_CONFIGS */.eM.SOLVED_TILE_CONFIGS);
    if (!hasAttribute) {
      this._node.states.error.set(`attribute not found: ${WFCAttributes/* WFCQuadAttribute.SOLVED_TILE_CONFIGS */.eM.SOLVED_TILE_CONFIGS}`);
      return;
    }
  }
  createObjects() {
    const group = new three_module.Group();
    group.matrixAutoUpdate = false;
    this._createObjects(this._quadObject, group);
    return group;
  }
  update(builderObject, solverObject) {
    builderObject.remove(...builderObject.children);
    this._createObjects(solverObject, builderObject);
  }
  _createObjects(solverObject, parent) {
    const primitiveClass = (0,CoreObjectFactory/* corePrimitiveClassFactory */.um)(solverObject);
    for (let i = 0; i < this._primitivesCount; i++) {
      const solvedTileConfigsString = primitiveClass.attribValue(
        solverObject,
        i,
        WFCAttributes/* WFCQuadAttribute.SOLVED_TILE_CONFIGS */.eM.SOLVED_TILE_CONFIGS
      );
      if (!solvedTileConfigsString) {
        this._node.states.error.set(`attribute empty in primitive: ${i}`);
        return;
      }
      const tileConfigs = (0,WFCTileConfig/* stringToTileConfigs */.Lu)(solvedTileConfigsString);
      this._processTileConfigs(
        this._quadObject,
        i,
        this._tilesCollection,
        this._tileObjects,
        tileConfigs,
        parent
      );
    }
  }
  _processTileConfigs(quadObject, primitiveIndex, tilesCollection, tileObjects, tileConfigs, parent) {
    const count = tileConfigs.length;
    switch (count) {
      case 0: {
        console.warn("no tile configs found");
        return;
      }
      case 1: {
        const object = this._convertTileConfig(
          quadObject,
          primitiveIndex,
          tilesCollection,
          tileObjects,
          tileConfigs[0]
        );
        if (object) {
          parent.add(object);
        }
        return;
      }
      default: {
        const object = this._convertTileConfigs(
          quadObject,
          primitiveIndex,
          tilesCollection,
          tileObjects,
          tileConfigs
        );
        if (object) {
          parent.add(object);
        }
        return;
      }
    }
  }
  _convertTileConfig(quadObject, primitiveIndex, tilesCollection, tileObjects, tileConfig) {
    const tileObject = this._tileObject(tilesCollection, tileConfig, tileObjects);
    if (!tileObject) {
      this._node.states.error.set(`tile object not found for tile id: ${tileConfig.tileId}`);
      return;
    }
    const newObject = placeObjectOnQuad({
      object: tileObject,
      quadObject,
      primitiveIndex,
      rotation: tileConfig.rotation,
      height: this._tileHeight
    });
    const quadId = QuadPrimitive/* QuadPrimitive.attribValue */.C.attribValue(quadObject, primitiveIndex, WFCAttributes/* WFCQuadAttribute.QUAD_ID */.eM.QUAD_ID);
    (0,CoreObjectFactory/* coreObjectClassFactory */.Xr)(newObject).addAttribute(newObject, WFCAttributes/* WFCQuadAttribute.QUAD_ID */.eM.QUAD_ID, quadId);
    return newObject;
  }
  _convertTileConfigs(quadObject, primitiveIndex, tilesCollection, tileObjects, tileConfigs) {
    const objects = [];
    for (const tileConfig of tileConfigs) {
      const object = this._convertTileConfig(
        quadObject,
        primitiveIndex,
        tilesCollection,
        tileObjects,
        tileConfig
      );
      if (object) {
        objects.push(object);
      }
    }
    const objectsCount = objects.length;
    const gridSizeX = Math.ceil(Math.sqrt(objectsCount));
    const gridSizeY = Math.ceil(objectsCount / gridSizeX);
    const group = new three_module.Group();
    for (let x = 0; x < gridSizeX; x++) {
      for (let y = 0; y < gridSizeY; y++) {
        const index = x + y * gridSizeX;
        if (index < objectsCount) {
          const object = objects[index];
          object.position.set(0.5 + x - gridSizeX / 2, 0, 0.5 + y - gridSizeY / 2);
          object.updateMatrix();
          group.add(object);
        }
      }
    }
    const max = Math.max(gridSizeX, gridSizeY);
    group.scale.multiplyScalar(1 / max);
    QuadPrimitive/* QuadPrimitive.position */.C.position(quadObject, primitiveIndex, group.position);
    group.updateMatrix();
    group.matrixAutoUpdate = false;
    return group;
  }
  _tileObject(tilesCollection, tileConfig, tileObjects) {
    return tileConfig.tileId == WFCConstant/* UNRESOLVED_TILE_ID */.h7 ? tilesCollection.unresolvedTile() : tileConfig.tileId == WFCConstant/* ERROR_TILE_ID */.rs ? tilesCollection.errorTile() : tileObjects.find((tileObject) => WFCAttributes/* CoreWFCTileAttribute.getTileId */.d7.getTileId(tileObject) == tileConfig.tileId);
  }
}

// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/core/wfc/WFCRegister.ts
var WFCRegister = __webpack_require__(34263);
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/sop/WFCBuilder.ts







class WFCBuilderSopParamsConfig extends params_ParamsConfig/* NodeParamsConfig */.yI {
  constructor() {
    super(...arguments);
    /** @param tileHeight */
    this.tileHeight = params_ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(1, {
      range: [0, 2],
      rangeLocked: [true, false]
    });
  }
}
const WFCBuilder_ParamsConfig = new WFCBuilderSopParamsConfig();
class WFCBuilderSopNode extends sop_Base/* TypedSopNode */.x {
  constructor() {
    super(...arguments);
    this.paramsConfig = WFCBuilder_ParamsConfig;
  }
  static type() {
    return Sop/* SopType.WFC_BUILDER */.aB.WFC_BUILDER;
  }
  initializeNode() {
    this.io.inputs.setCount(2);
    this.io.inputs.initInputsClonedState(InputCloneMode/* InputCloneMode.NEVER */.m.NEVER);
  }
  cook(inputCoreGroups) {
    const coreGroup0 = inputCoreGroups[0];
    const coreGroup1 = inputCoreGroups[1];
    const quadObjects = coreGroup0.quadObjects();
    if (quadObjects == null || quadObjects.length == 0) {
      this.states.error.set("no quad objects found");
      return;
    }
    const tileAndRuleObjects = coreGroup1.threejsObjects();
    const newObjects = [];
    for (const quadObject of quadObjects) {
      const builder = new WFCBuilder({
        node: this,
        quadObject,
        tileAndRuleObjects,
        tileHeight: this.pv.tileHeight
      });
      const group = builder.createObjects();
      if (group) {
        (0,WFCRegister/* registerWFCBuilder */.PZ)(builder, group);
        newObjects.push(group);
      }
    }
    this.setObjects(newObjects);
  }
}

// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/nodes/sop/WFCDebug.ts
var WFCDebug = __webpack_require__(93055);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/core/wfc/WFCCommon.ts
var WFCCommon = __webpack_require__(86306);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/core/wfc/WFCRule.ts
var WFCRule = __webpack_require__(42320);
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/sop/WFCRuleFromProximity.ts

var WFCRuleFromProximity_async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};








const identityQuaternion = new three_module.Quaternion();
const WFCRuleFromProximity_q = new three_module.Quaternion();
function _angleIncrement(object) {
  if (Math.abs(object.rotation.y) > 0.1) {
    return object.rotation.y / (Math.PI / 2);
  }
  WFCRuleFromProximity_q.setFromRotationMatrix(object.matrix);
  return WFCRuleFromProximity_q.angleTo(identityQuaternion) / (Math.PI / 2);
}
class WFCRuleFromProximitySopParamsConfig extends params_ParamsConfig/* NodeParamsConfig */.yI {
}
const WFCRuleFromProximity_ParamsConfig = new WFCRuleFromProximitySopParamsConfig();
class WFCRuleFromProximitySopNode extends sop_Base/* TypedSopNode */.x {
  constructor() {
    super(...arguments);
    this.paramsConfig = WFCRuleFromProximity_ParamsConfig;
  }
  static type() {
    return Sop/* SopType.WFC_RULE_FROM_PROXIMITY */.aB.WFC_RULE_FROM_PROXIMITY;
  }
  initializeNode() {
    this.io.inputs.setCount(2);
    this.io.inputs.initInputsClonedState([InputCloneMode/* InputCloneMode.NEVER */.m.NEVER]);
  }
  cook(inputCoreGroups) {
    return WFCRuleFromProximity_async(this, null, function* () {
      const coreGroup0 = inputCoreGroups[0];
      const coreGroup1 = inputCoreGroups[1];
      const inputObjects = coreGroup0.threejsObjects();
      const tileObjects = coreGroup1.threejsObjects();
      const outputObjects = [...inputObjects];
      const tileObjectsInGrid = [];
      const _addTileObject = (tileObject) => {
        const x = Math.round(tileObject.position.x);
        const y = Math.round(tileObject.position.y);
        const z = Math.round(tileObject.position.z);
        tileObjectsInGrid[x] = tileObjectsInGrid[x] || [];
        tileObjectsInGrid[x][y] = tileObjectsInGrid[x][y] || [];
        tileObjectsInGrid[x][y][z] = tileObject;
      };
      const _getTileObject = (x, y, z) => {
        x = Math.round(x);
        y = Math.round(y);
        z = Math.round(z);
        const xs = tileObjectsInGrid[x];
        if (!xs) {
          return;
        }
        const yz = tileObjectsInGrid[x][y];
        if (!yz) {
          return;
        }
        return tileObjectsInGrid[x][y][z];
      };
      const _addConnectionIfNeighbourFound = (currentObject, xOffset, yOffset, zOffset) => {
        const x = Math.round(currentObject.position.x);
        const y = Math.round(currentObject.position.y);
        const z = Math.round(currentObject.position.z);
        const neighbour = _getTileObject(x + xOffset, y + yOffset, z + zOffset);
        if (!neighbour) {
          return;
        }
        const id0 = WFCAttributes/* CoreWFCTileAttribute.getTileId */.d7.getTileId(currentObject);
        const id1 = WFCAttributes/* CoreWFCTileAttribute.getTileId */.d7.getTileId(neighbour);
        const currentObjectSideUnrotated = (0,WFCCommon/* tileSideUnrotated */.m5)(xOffset, yOffset, zOffset);
        const currentObjectSide = (0,WFCCommon/* rotatedSide */.Q9)(
          currentObjectSideUnrotated,
          Math.round(_angleIncrement(currentObject))
        );
        const neighbourSideUnrotated = (0,WFCCommon/* neighbourTileSideUnrotated */.TV)(xOffset, yOffset, zOffset);
        const neighbourSide = (0,WFCCommon/* rotatedSide */.Q9)(neighbourSideUnrotated, Math.round(_angleIncrement(neighbour)));
        const ruleObject = (0,WFCRule/* createRuleObject */.B9)({
          id0,
          id1,
          side0: currentObjectSide,
          side1: neighbourSide
        });
        outputObjects.push(ruleObject);
      };
      for (const tileObject of tileObjects) {
        const isTile = WFCAttributes/* CoreWFCTileAttribute.getIsTile */.d7.getIsTile(tileObject);
        if (!isTile) {
          continue;
        }
        _addTileObject(tileObject);
      }
      for (const tileObject of tileObjects) {
        const isTile = WFCAttributes/* CoreWFCTileAttribute.getIsTile */.d7.getIsTile(tileObject);
        if (!isTile) {
          continue;
        }
        _addConnectionIfNeighbourFound(tileObject, -1, 0, 0);
        _addConnectionIfNeighbourFound(tileObject, 1, 0, 0);
        _addConnectionIfNeighbourFound(tileObject, 0, -1, 0);
        _addConnectionIfNeighbourFound(tileObject, 0, 1, 0);
        _addConnectionIfNeighbourFound(tileObject, 0, 0, -1);
        _addConnectionIfNeighbourFound(tileObject, 0, 0, 1);
      }
      this.setObjects(outputObjects);
    });
  }
}

// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/nodes/sop/WFCRuleConnectionFromSideName.ts
var WFCRuleConnectionFromSideName = __webpack_require__(93968);
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/sop/WFCRuleConnectionToGridBorder.ts

var WFCRuleConnectionToGridBorder_async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};









class WFCRuleConnectionToGridBorderSopParamsConfig extends params_ParamsConfig/* NodeParamsConfig */.yI {
  constructor() {
    super(...arguments);
    /** @param src tile id */
    this.tileId = params_ParamsConfig/* ParamConfig.STRING */.XC.STRING("*");
    /** @param side name */
    this.sideName = params_ParamsConfig/* ParamConfig.STRING */.XC.STRING("*");
  }
}
const WFCRuleConnectionToGridBorder_ParamsConfig = new WFCRuleConnectionToGridBorderSopParamsConfig();
class WFCRuleConnectionToGridBorderSopNode extends sop_Base/* TypedSopNode */.x {
  constructor() {
    super(...arguments);
    this.paramsConfig = WFCRuleConnectionToGridBorder_ParamsConfig;
  }
  static type() {
    return Sop/* SopType.WFC_RULE_CONNECTION_TO_GRID_BORDER */.aB.WFC_RULE_CONNECTION_TO_GRID_BORDER;
  }
  initializeNode() {
    this.io.inputs.setCount(1);
    this.io.inputs.initInputsClonedState(InputCloneMode/* InputCloneMode.FROM_NODE */.m.FROM_NODE);
  }
  cook(inputCoreGroups) {
    return WFCRuleConnectionToGridBorder_async(this, null, function* () {
      const coreGroup0 = inputCoreGroups[0];
      const inputObjects = coreGroup0.threejsObjects();
      const { tileId, sideName } = this.pv;
      const tileObjects = inputObjects.filter(
        (tileObject) => (0,core_String/* stringMatchMask */.v$)(WFCAttributes/* CoreWFCTileAttribute.getTileId */.d7.getTileId(tileObject), tileId)
      );
      const outputObjects = [...inputObjects];
      for (const tile of tileObjects) {
        const tileId2 = WFCAttributes/* CoreWFCTileAttribute.getTileId */.d7.getTileId(tile);
        for (const side0 of WFCCommon/* ALL_SIDES */.hw) {
          const sideName0 = WFCAttributes/* CoreWFCTileAttribute.getSideName */.d7.getSideName(tile, side0);
          if (sideName0 && (0,core_String/* stringMatchMask */.v$)(sideName0, sideName)) {
            const ruleObject = (0,WFCRule/* createRuleObject */.B9)({
              id0: tileId2,
              id1: WFCConstant/* GRID_BORDER_ID */.hb,
              side0,
              side1: WFCConstant/* GRID_BORDER_SIDE_NAME */.bT
            });
            outputObjects.push(ruleObject);
          }
        }
      }
      this.setObjects(outputObjects);
    });
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/sop/WFCRuleTileWeight.ts

var WFCRuleTileWeight_async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};






class WFCRuleTileWeightSopParamsConfig extends params_ParamsConfig/* NodeParamsConfig */.yI {
  constructor() {
    super(...arguments);
    /** @param tile id */
    this.tileId = params_ParamsConfig/* ParamConfig.STRING */.XC.STRING("*");
    /** @param weight */
    this.weight = params_ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(1, {
      range: [0, 1],
      rangeLocked: [true, true]
    });
  }
}
const WFCRuleTileWeight_ParamsConfig = new WFCRuleTileWeightSopParamsConfig();
class WFCRuleTileWeightSopNode extends sop_Base/* TypedSopNode */.x {
  constructor() {
    super(...arguments);
    this.paramsConfig = WFCRuleTileWeight_ParamsConfig;
  }
  static type() {
    return Sop/* SopType.WFC_RULE_TILE_WEIGHT */.aB.WFC_RULE_TILE_WEIGHT;
  }
  initializeNode() {
    this.io.inputs.setCount(1);
    this.io.inputs.initInputsClonedState(InputCloneMode/* InputCloneMode.FROM_NODE */.m.FROM_NODE);
  }
  cook(inputCoreGroups) {
    return WFCRuleTileWeight_async(this, null, function* () {
      const coreGroup0 = inputCoreGroups[0];
      const inputObjects = coreGroup0.threejsObjects();
      const { tileId, weight } = this.pv;
      const tileObjects = inputObjects.filter(
        (tileObject) => (0,core_String/* stringMatchMask */.v$)(WFCAttributes/* CoreWFCTileAttribute.getTileId */.d7.getTileId(tileObject), tileId)
      );
      for (const tileObject of tileObjects) {
        WFCAttributes/* CoreWFCTileAttribute.setWeight */.d7.setWeight(tileObject, weight);
      }
      this.setObjects(inputObjects);
    });
  }
}

// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/nodes/sop/WFCSolver.ts + 3 modules
var WFCSolver = __webpack_require__(82140);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/core/wfc/WFCDebugTileObjects.ts
var WFCDebugTileObjects = __webpack_require__(60755);
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/sop/WFCTileEmptyObject.ts

var WFCTileEmptyObject_async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};





class WFCTileEmptyObjectSopParamsConfig extends params_ParamsConfig/* NodeParamsConfig */.yI {
}
const WFCTileEmptyObject_ParamsConfig = new WFCTileEmptyObjectSopParamsConfig();
class WFCTileEmptyObjectSopNode extends sop_Base/* TypedSopNode */.x {
  constructor() {
    super(...arguments);
    this.paramsConfig = WFCTileEmptyObject_ParamsConfig;
  }
  static type() {
    return Sop/* SopType.WFC_TILE_EMPTY_OBJECT */.aB.WFC_TILE_EMPTY_OBJECT;
  }
  initializeNode() {
    this.io.inputs.setCount(0, 1);
    this.io.inputs.initInputsClonedState(InputCloneMode/* InputCloneMode.FROM_NODE */.m.FROM_NODE);
  }
  cook(inputCoreGroups) {
    return WFCTileEmptyObject_async(this, null, function* () {
      const coreGroup0 = inputCoreGroups[0];
      const inputObject = coreGroup0 ? coreGroup0.threejsObjects()[0] : null;
      const tileObject = inputObject != null ? inputObject : (0,WFCDebugTileObjects/* createDefaultEmptyTileObject */.gC)();
      (0,WFCDebugTileObjects/* addEmptyTileObjectAttributes */.xx)(tileObject);
      this.setObjects([tileObject]);
    });
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/sop/WFCTileErrorObject.ts

var WFCTileErrorObject_async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};





class WFCTileErrorObjectSopParamsConfig extends params_ParamsConfig/* NodeParamsConfig */.yI {
}
const WFCTileErrorObject_ParamsConfig = new WFCTileErrorObjectSopParamsConfig();
class WFCTileErrorObjectSopNode extends sop_Base/* TypedSopNode */.x {
  constructor() {
    super(...arguments);
    this.paramsConfig = WFCTileErrorObject_ParamsConfig;
  }
  static type() {
    return Sop/* SopType.WFC_TILE_ERROR_OBJECT */.aB.WFC_TILE_ERROR_OBJECT;
  }
  initializeNode() {
    this.io.inputs.setCount(0, 2);
    this.io.inputs.initInputsClonedState(InputCloneMode/* InputCloneMode.FROM_NODE */.m.FROM_NODE);
  }
  cook(inputCoreGroups) {
    return WFCTileErrorObject_async(this, null, function* () {
      const coreGroup0 = inputCoreGroups[0];
      const coreGroup1 = inputCoreGroups[1];
      const objects = coreGroup0 ? coreGroup0.allObjects() : [];
      const errorTileObject = coreGroup1 ? coreGroup1.threejsObjects()[0] : null;
      const tileObject = errorTileObject != null ? errorTileObject : (0,WFCDebugTileObjects/* createDefaultErrorTileObject */.cQ)();
      (0,WFCDebugTileObjects/* addErrorTileObjectAttributes */.gz)(tileObject);
      objects.push(tileObject);
      this.setObjects(objects);
    });
  }
}

// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/nodes/sop/WFCTileProperties.ts
var WFCTileProperties = __webpack_require__(81852);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/nodes/sop/WFCTileSideName.ts
var WFCTileSideName = __webpack_require__(36524);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/nodes/sop/WFCTileTransform.ts
var WFCTileTransform = __webpack_require__(70713);
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/sop/WFCTileUnresolvedObject.ts

var WFCTileUnresolvedObject_async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};





class WFCTileUnresolvedObjectSopParamsConfig extends params_ParamsConfig/* NodeParamsConfig */.yI {
}
const WFCTileUnresolvedObject_ParamsConfig = new WFCTileUnresolvedObjectSopParamsConfig();
class WFCTileUnresolvedObjectSopNode extends sop_Base/* TypedSopNode */.x {
  constructor() {
    super(...arguments);
    this.paramsConfig = WFCTileUnresolvedObject_ParamsConfig;
  }
  static type() {
    return Sop/* SopType.WFC_TILE_UNRESOLVED_OBJECT */.aB.WFC_TILE_UNRESOLVED_OBJECT;
  }
  initializeNode() {
    this.io.inputs.setCount(0, 2);
    this.io.inputs.initInputsClonedState(InputCloneMode/* InputCloneMode.FROM_NODE */.m.FROM_NODE);
  }
  cook(inputCoreGroups) {
    return WFCTileUnresolvedObject_async(this, null, function* () {
      const coreGroup0 = inputCoreGroups[0];
      const coreGroup1 = inputCoreGroups[1];
      const inputObjects = coreGroup0 ? coreGroup0.allObjects() : [];
      const unresolvedTileObject = coreGroup1 ? coreGroup1.threejsObjects()[0] : null;
      const tileObject = unresolvedTileObject != null ? unresolvedTileObject : (0,WFCDebugTileObjects/* createDefaultUnresolvedTileObject */.Eb)();
      (0,WFCDebugTileObjects/* addUnresolvedTileObjectAttributes */.K6)(tileObject);
      inputObjects.push(tileObject);
      this.setObjects(inputObjects);
    });
  }
}

// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/nodes/sop/_BaseManager.ts
var sop_BaseManager = __webpack_require__(99360);
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/sop/ActorsNetwork.ts







class ActorsNetworkSopNode extends sop_BaseManager/* ParamLessBaseNetworkSopNode */.k {
  constructor() {
    super(...arguments);
    this._childrenControllerContext = poly_NodeContext/* NodeContext.JS */.sy.JS;
    //
    // ASSEMBLERS
    //
    this.persisted_config = new ActorPersistedConfig/* ActorPersistedConfig */.R(this);
    this._assemblerController = this._createAssemblerController();
    //
    // compilation
    //
    this.compilationController = new ActorCompilationController/* ActorCompilationController */.z7(this);
  }
  static type() {
    return poly_NodeContext/* NetworkNodeType.ACTOR */.kX.ACTOR;
  }
  createNode(node_class, options) {
    return super.createNode(node_class, options);
  }
  children() {
    return super.children();
  }
  nodesByType(type) {
    return super.nodesByType(type);
  }
  //
  childrenAllowed() {
    if (this.assemblerController()) {
      return super.childrenAllowed();
    }
    return false;
  }
  sceneReadonly() {
    return this.assemblerController() == null;
  }
  assemblerController() {
    return this._assemblerController;
  }
  usedAssembler() {
    return _BaseRegister/* AssemblerName.JS_ACTOR */.Q.JS_ACTOR;
  }
  _createAssemblerController() {
    return Poly/* Poly.assemblersRegister.assembler */.L.assemblersRegister.assembler(this, this.usedAssembler());
  }
  compile() {
    this.compilationController.compile();
  }
  cook() {
    this.compilationController.compileIfRequired();
    this.cookController.endCook();
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/sop/AnimationsNetwork.ts



class AnimationsNetworkSopNode extends sop_BaseManager/* ParamLessBaseNetworkSopNode */.k {
  constructor() {
    super(...arguments);
    this._childrenControllerContext = poly_NodeContext/* NodeContext.ANIM */.sy.ANIM;
  }
  static type() {
    return poly_NodeContext/* NetworkNodeType.ANIM */.kX.ANIM;
  }
  createNode(node_class, options) {
    return super.createNode(node_class, options);
  }
  children() {
    return super.children();
  }
  nodesByType(type) {
    return super.nodesByType(type);
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/sop/AudioNetwork.ts



class AudioNetworkSopNode extends sop_BaseManager/* ParamLessBaseNetworkSopNode */.k {
  constructor() {
    super(...arguments);
    this._childrenControllerContext = poly_NodeContext/* NodeContext.AUDIO */.sy.AUDIO;
  }
  static type() {
    return poly_NodeContext/* NetworkNodeType.AUDIO */.kX.AUDIO;
  }
  createNode(node_class, options) {
    return super.createNode(node_class, options);
  }
  children() {
    return super.children();
  }
  nodesByType(type) {
    return super.nodesByType(type);
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/sop/CopNetwork.ts



class CopNetworkSopNode extends sop_BaseManager/* ParamLessBaseNetworkSopNode */.k {
  constructor() {
    super(...arguments);
    this._childrenControllerContext = poly_NodeContext/* NodeContext.COP */.sy.COP;
  }
  static type() {
    return poly_NodeContext/* NetworkNodeType.COP */.kX.COP;
  }
  createNode(node_class, options) {
    return super.createNode(node_class, options);
  }
  children() {
    return super.children();
  }
  nodesByType(type) {
    return super.nodesByType(type);
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/sop/EventsNetwork.ts



class EventsNetworkSopNode extends sop_BaseManager/* ParamLessBaseNetworkSopNode */.k {
  constructor() {
    super(...arguments);
    this._childrenControllerContext = poly_NodeContext/* NodeContext.EVENT */.sy.EVENT;
  }
  static type() {
    return poly_NodeContext/* NetworkNodeType.EVENT */.kX.EVENT;
  }
  createNode(node_class, options) {
    return super.createNode(node_class, options);
  }
  children() {
    return super.children();
  }
  nodesByType(type) {
    return super.nodesByType(type);
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/sop/MaterialsNetwork.ts



class MaterialsNetworkSopNode extends sop_BaseManager/* ParamLessBaseNetworkSopNode */.k {
  constructor() {
    super(...arguments);
    this._childrenControllerContext = poly_NodeContext/* NodeContext.MAT */.sy.MAT;
  }
  static type() {
    return poly_NodeContext/* NetworkNodeType.MAT */.kX.MAT;
  }
  createNode(node_class, options) {
    return super.createNode(node_class, options);
  }
  children() {
    return super.children();
  }
  nodesByType(type) {
    return super.nodesByType(type);
  }
}

// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/nodes/sop/PostProcessNetwork.ts
var sop_PostProcessNetwork = __webpack_require__(31578);
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/sop/RenderersNetwork.ts



class RenderersNetworkSopNode extends sop_BaseManager/* ParamLessBaseNetworkSopNode */.k {
  constructor() {
    super(...arguments);
    this._childrenControllerContext = poly_NodeContext/* NodeContext.ROP */.sy.ROP;
  }
  static type() {
    return poly_NodeContext/* NetworkNodeType.ROP */.kX.ROP;
  }
  createNode(node_class, options) {
    return super.createNode(node_class, options);
  }
  children() {
    return super.children();
  }
  nodesByType(type) {
    return super.nodesByType(type);
  }
}

// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/operations/sop/Add.ts
var sop_Add = __webpack_require__(36464);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/operations/sop/AmbientLight.ts
var operations_sop_AmbientLight = __webpack_require__(82040);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/operations/sop/AreaLight.ts
var operations_sop_AreaLight = __webpack_require__(54112);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/operations/sop/AttribAddMult.ts
var sop_AttribAddMult = __webpack_require__(8057);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/operations/sop/AttribCast.ts
var sop_AttribCast = __webpack_require__(96685);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/operations/sop/AttribCopy.ts
var sop_AttribCopy = __webpack_require__(50758);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/operations/sop/AttribCreate.ts + 5 modules
var sop_AttribCreate = __webpack_require__(64051);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/operations/sop/AttribDelete.ts
var sop_AttribDelete = __webpack_require__(41346);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/operations/sop/AttribNormalize.ts
var sop_AttribNormalize = __webpack_require__(89106);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/operations/sop/AttribFromTexture.ts + 1 modules
var sop_AttribFromTexture = __webpack_require__(18224);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/operations/sop/AttribId.ts
var sop_AttribId = __webpack_require__(67905);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/operations/sop/AttribPromote.ts
var sop_AttribPromote = __webpack_require__(25300);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/operations/sop/AttribRename.ts
var sop_AttribRename = __webpack_require__(44207);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/operations/sop/AttribSetAtIndex.ts
var sop_AttribSetAtIndex = __webpack_require__(70297);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/operations/sop/AudioNotes.ts
var sop_AudioNotes = __webpack_require__(9733);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/operations/sop/BboxScatter.ts
var sop_BboxScatter = __webpack_require__(88423);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/operations/sop/Boolean.ts
var operations_sop_Boolean = __webpack_require__(90243);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/operations/sop/Box.ts
var sop_Box = __webpack_require__(32458);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/operations/sop/BoxLines.ts + 1 modules
var sop_BoxLines = __webpack_require__(22520);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/operations/sop/CameraControls.ts
var sop_CameraControls = __webpack_require__(84953);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/operations/sop/CameraFPS.ts
var sop_CameraFPS = __webpack_require__(83532);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/operations/sop/CameraFrameMode.ts
var sop_CameraFrameMode = __webpack_require__(18908);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/operations/sop/CameraPostProcess.ts
var sop_CameraPostProcess = __webpack_require__(25385);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/operations/sop/CameraProject.ts
var sop_CameraProject = __webpack_require__(6490);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/operations/sop/CameraRenderScene.ts
var sop_CameraRenderScene = __webpack_require__(73583);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/operations/sop/CameraViewerCode.ts
var sop_CameraViewerCode = __webpack_require__(19623);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/operations/sop/CameraViewOffset.ts
var sop_CameraViewOffset = __webpack_require__(48863);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/operations/sop/CameraWebXRARMarkerTracking.ts
var sop_CameraWebXRARMarkerTracking = __webpack_require__(98738);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/operations/sop/CameraWebXRAR.ts + 2 modules
var sop_CameraWebXRAR = __webpack_require__(21382);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/operations/sop/CameraWebXRVR.ts + 2 modules
var sop_CameraWebXRVR = __webpack_require__(71175);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/operations/sop/Center.ts
var sop_Center = __webpack_require__(66054);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/operations/sop/CubeCamera.ts
var operations_sop_CubeCamera = __webpack_require__(90872);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/operations/sop/DeleteByName.ts
var sop_DeleteByName = __webpack_require__(80922);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/operations/sop/DirectionalLight.ts
var operations_sop_DirectionalLight = __webpack_require__(13916);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/operations/sop/EmptyObject.ts
var sop_EmptyObject = __webpack_require__(4778);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/operations/sop/FileDRC.ts + 1 modules
var sop_FileDRC = __webpack_require__(20694);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/operations/sop/FileFBX.ts + 4 modules
var sop_FileFBX = __webpack_require__(78819);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/operations/sop/FileGEOJSON.ts + 2 modules
var sop_FileGEOJSON = __webpack_require__(7911);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/operations/sop/FileJSON.ts + 58 modules
var sop_FileJSON = __webpack_require__(1939);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/operations/sop/FileMPD.ts + 2 modules
var sop_FileMPD = __webpack_require__(98854);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/operations/sop/FileOBJ.ts
var sop_FileOBJ = __webpack_require__(64467);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/operations/sop/FilePDB.ts + 2 modules
var sop_FilePDB = __webpack_require__(18350);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/operations/sop/FilePLY.ts + 2 modules
var sop_FilePLY = __webpack_require__(27968);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/operations/sop/FileSTL.ts + 2 modules
var sop_FileSTL = __webpack_require__(59611);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/operations/sop/FileSVG.ts + 1 modules
var sop_FileSVG = __webpack_require__(71858);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/operations/sop/FileVOX.ts + 1 modules
var sop_FileVOX = __webpack_require__(26144);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/operations/sop/HemisphereLight.ts
var operations_sop_HemisphereLight = __webpack_require__(57426);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/operations/sop/Hexagons.ts
var sop_Hexagons = __webpack_require__(42821);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/operations/sop/Hierarchy.ts
var sop_Hierarchy = __webpack_require__(25972);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/operations/sop/Icosahedron.ts + 1 modules
var sop_Icosahedron = __webpack_require__(40930);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/operations/sop/Instance.ts
var sop_Instance = __webpack_require__(51922);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/operations/sop/Jitter.ts
var sop_Jitter = __webpack_require__(28665);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/operations/sop/MapboxCamera.ts
var sop_MapboxCamera = __webpack_require__(76126);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/operations/sop/Material.ts
var operations_sop_Material = __webpack_require__(53382);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/operations/sop/Merge.ts
var operations_sop_Merge = __webpack_require__(34682);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/operations/sop/ObjectProperties.ts
var sop_ObjectProperties = __webpack_require__(38229);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/operations/sop/ObjectsLayout.ts
var sop_ObjectsLayout = __webpack_require__(38681);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/operations/sop/OrthographicCamera.ts
var operations_sop_OrthographicCamera = __webpack_require__(85775);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/operations/sop/Palette.ts
var sop_Palette = __webpack_require__(88356);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/operations/sop/PerspectiveCamera.ts
var operations_sop_PerspectiveCamera = __webpack_require__(41246);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/operations/sop/PolarTransform.ts
var sop_PolarTransform = __webpack_require__(34633);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/operations/sop/PointLight.ts
var operations_sop_PointLight = __webpack_require__(78695);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/operations/sop/Ray.ts
var sop_Ray = __webpack_require__(27613);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/operations/sop/RestAttributes.ts
var sop_RestAttributes = __webpack_require__(77475);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/operations/sop/RoundedBox.ts
var sop_RoundedBox = __webpack_require__(33782);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/operations/sop/Scatter.ts + 1 modules
var sop_Scatter = __webpack_require__(90138);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/operations/sop/SetChildren.ts
var sop_SetChildren = __webpack_require__(2896);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/operations/sop/SetGeometry.ts
var sop_SetGeometry = __webpack_require__(43099);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/operations/sop/Sort.ts
var sop_Sort = __webpack_require__(32234);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/operations/sop/Sphere.ts
var sop_Sphere = __webpack_require__(56431);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/operations/sop/SpotLight.ts
var operations_sop_SpotLight = __webpack_require__(79826);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/operations/sop/Tangent.ts
var sop_Tangent = __webpack_require__(70388);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/operations/sop/Tube.ts
var sop_Tube = __webpack_require__(66115);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/operations/sop/Transform.ts
var operations_sop_Transform = __webpack_require__(68270);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/operations/sop/TransformReset.ts
var sop_TransformReset = __webpack_require__(28821);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/operations/sop/UvUnwrap.ts + 1 modules
var sop_UvUnwrap = __webpack_require__(76057);
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/poly/registers/nodes/Sop.ts






























































































































































































































































































































































































































class SopRegister {
  static run(poly) {
    poly.registerOperation(sop_Add/* AddSopOperation */.F);
    poly.registerOperation(AdjacencySopOperation);
    poly.registerOperation(operations_sop_AmbientLight/* AmbientLightSopOperation */.j);
    poly.registerOperation(operations_sop_AreaLight/* AreaLightSopOperation */.X);
    poly.registerOperation(sop_AttribAddMult/* AttribAddMultSopOperation */.t);
    poly.registerOperation(sop_AttribCast/* AttribCastSopOperation */.Lz);
    poly.registerOperation(sop_AttribCopy/* AttribCopySopOperation */.O);
    poly.registerOperation(sop_AttribCreate/* AttribCreateSopOperation */.k);
    poly.registerOperation(sop_AttribDelete/* AttribDeleteSopOperation */.T);
    poly.registerOperation(sop_AttribNormalize/* AttribNormalizeSopOperation */.Ch);
    poly.registerOperation(sop_AttribFromTexture/* AttribFromTextureSopOperation */.W);
    poly.registerOperation(sop_AttribId/* AttribIdSopOperation */.S);
    poly.registerOperation(sop_AttribPromote/* AttribPromoteSopOperation */.E9);
    poly.registerOperation(sop_AttribRename/* AttribRenameSopOperation */.D);
    poly.registerOperation(sop_AttribSetAtIndex/* AttribSetAtIndexSopOperation */.Y);
    poly.registerOperation(sop_AudioNotes/* AudioNotesSopOperation */.R);
    poly.registerOperation(AxesHelperSopOperation);
    poly.registerOperation(sop_BboxScatter/* BboxScatterSopOperation */.U);
    poly.registerOperation(operations_sop_Boolean/* BooleanSopOperation */.GJ);
    poly.registerOperation(sop_Box/* BoxSopOperation */.v);
    poly.registerOperation(sop_BoxLines/* BoxLinesSopOperation */.Z);
    poly.registerOperation(BVHSopOperation);
    poly.registerOperation(BVHVisualizerSopOperation);
    poly.registerOperation(sop_CameraControls/* CameraControlsSopOperation */.y);
    poly.registerOperation(sop_CameraFPS/* CameraFPSSopOperation */.L);
    poly.registerOperation(sop_CameraFrameMode/* CameraFrameModeSopOperation */.d);
    poly.registerOperation(CameraCSSRenderer/* CameraCSSRendererSopOperation */.G);
    poly.registerOperation(sop_CameraPostProcess/* CameraPostProcessSopOperation */.W);
    poly.registerOperation(sop_CameraProject/* CameraProjectSopOperation */.i);
    poly.registerOperation(CameraRenderer/* CameraRendererSopOperation */.Q);
    poly.registerOperation(sop_CameraRenderScene/* CameraRenderSceneSopOperation */.i);
    poly.registerOperation(sop_CameraViewerCode/* CameraViewerCodeSopOperation */.W);
    poly.registerOperation(sop_CameraViewOffset/* CameraViewOffsetSopOperation */.c);
    poly.registerOperation(sop_CameraWebXRARMarkerTracking/* CameraWebXRARMarkerTrackingSopOperation */.Q);
    poly.registerOperation(sop_CameraWebXRAR/* CameraWebXRARSopOperation */.h);
    poly.registerOperation(sop_CameraWebXRVR/* CameraWebXRVRSopOperation */.c);
    poly.registerOperation(Capsule/* CapsuleSopOperation */.e);
    poly.registerOperation(sop_Center/* CenterSopOperation */.Ng);
    poly.registerOperation(CircleSopOperation);
    poly.registerOperation(ClipSopOperation);
    poly.registerOperation(ConvexHullSopOperation);
    poly.registerOperation(operations_sop_CubeCamera/* CubeCameraSopOperation */.A);
    poly.registerOperation(CurveFromPointsSopOperation);
    poly.registerOperation(CurveGetPointSopOperation);
    poly.registerOperation(DecalSopOperation);
    poly.registerOperation(sop_DeleteByName/* DeleteByNameSopOperation */.M);
    poly.registerOperation(operations_sop_DirectionalLight/* DirectionalLightSopOperation */.n);
    poly.registerOperation(sop_EmptyObject/* EmptyObjectSopOperation */.i);
    poly.registerOperation(File3DSSopOperation);
    poly.registerOperation(sop_FileDRC/* FileDRCSopOperation */.b);
    poly.registerOperation(sop_FileFBX/* FileFBXSopOperation */.Q);
    poly.registerOperation(sop_FileGLTF/* FileGLTFSopOperation */.j);
    poly.registerOperation(sop_FileGEOJSON/* FileGEOJSONSopOperation */.r);
    poly.registerOperation(sop_FileJSON/* FileJSONSopOperation */.k);
    poly.registerOperation(sop_FileMPD/* FileMPDSopOperation */.V);
    poly.registerOperation(sop_FileOBJ/* FileOBJSopOperation */.u);
    poly.registerOperation(sop_FilePDB/* FilePDBSopOperation */.J);
    poly.registerOperation(sop_FilePLY/* FilePLYSopOperation */.U);
    poly.registerOperation(sop_FileSTL/* FileSTLSopOperation */.Y);
    poly.registerOperation(sop_FileSVG/* FileSVGSopOperation */.X);
    poly.registerOperation(sop_FileVOX/* FileVOXSopOperation */.O);
    poly.registerOperation(operations_sop_HemisphereLight/* HemisphereLightSopOperation */.c);
    poly.registerOperation(sop_Hexagons/* HexagonsSopOperation */.b);
    poly.registerOperation(sop_Hierarchy/* HierarchySopOperation */.JW);
    poly.registerOperation(sop_Icosahedron/* IcosahedronSopOperation */.g);
    poly.registerOperation(sop_Instance/* InstanceSopOperation */.m);
    poly.registerOperation(InstancedMeshToMeshSopOperation);
    poly.registerOperation(InstanceUpdateSopOperation);
    poly.registerOperation(sop_Jitter/* JitterSopOperation */.U);
    poly.registerOperation(LatticeSopOperation);
    poly.registerOperation(sop_LightProbe/* LightProbeSopOperation */.v);
    poly.registerOperation(LookAtSopOperation);
    poly.registerOperation(sop_MapboxCamera/* MapboxCameraSopOperation */.V);
    poly.registerOperation(operations_sop_Material/* MaterialSopOperation */.i);
    poly.registerOperation(MaterialPropertiesSopOperation);
    poly.registerOperation(operations_sop_Merge/* MergeSopOperation */.y);
    poly.registerOperation(MetaballSopOperation);
    poly.registerOperation(MirrorSopOperation);
    poly.registerOperation(NullSopOperation);
    poly.registerOperation(sop_ObjectProperties/* ObjectPropertiesSopOperation */.L);
    poly.registerOperation(sop_ObjectsLayout/* ObjectsLayoutSopOperation */.k);
    poly.registerOperation(operations_sop_OrthographicCamera/* OrthographicCameraSopOperation */.a);
    poly.registerOperation(sop_Palette/* PaletteSopOperation */.m);
    poly.registerOperation(ParticlesSystemGpuAttributes/* ParticlesSystemGpuAttributesSopOperation */.c);
    poly.registerOperation(ParticlesSystemGpuMaterial/* ParticlesSystemGpuMaterialSopOperation */.K);
    poly.registerOperation(PeakSopOperation);
    poly.registerOperation(operations_sop_PerspectiveCamera/* PerspectiveCameraSopOperation */.C);
    poly.registerOperation(Plane/* PlaneSopOperation */.j);
    poly.registerOperation(PlaneHelperSopOperation);
    poly.registerOperation(operations_sop_PointLight/* PointLightSopOperation */.X);
    poly.registerOperation(sop_PolarTransform/* PolarTransformSopOperation */.P);
    poly.registerOperation(PolywireSopOperation);
    poly.registerOperation(sop_Ray/* RaySopOperation */.LE);
    poly.registerOperation(sop_RestAttributes/* RestAttributesSopOperation */.d);
    poly.registerOperation(RingSopOperation);
    poly.registerOperation(sop_RoundedBox/* RoundedBoxSopOperation */.f);
    poly.registerOperation(sop_Scatter/* ScatterSopOperation */.r);
    poly.registerOperation(sop_SetChildren/* SetChildrenSopOperation */._);
    poly.registerOperation(sop_SetGeometry/* SetGeometrySopOperation */.HV);
    poly.registerOperation(ShearSopOperation);
    poly.registerOperation(sop_Sort/* SortSopOperation */.ZM);
    poly.registerOperation(sop_Sphere/* SphereSopOperation */.bH);
    poly.registerOperation(operations_sop_SpotLight/* SpotLightSopOperation */.D);
    poly.registerOperation(SubdivideSopOperation);
    poly.registerOperation(sop_Tangent/* TangentSopOperation */.LL);
    poly.registerOperation(TextureCopySopOperation);
    poly.registerOperation(TexturePropertiesSopOperation);
    poly.registerOperation(TorusSopOperation);
    poly.registerOperation(TorusKnotSopOperation);
    poly.registerOperation(operations_sop_Transform/* TransformSopOperation */.d);
    poly.registerOperation(sop_TransformReset/* TransformResetSopOperation */.zd);
    poly.registerOperation(sop_Tube/* TubeSopOperation */.M);
    poly.registerOperation(UvTransformSopOperation);
    poly.registerOperation(sop_UvUnwrap/* UvUnwrapSopOperation */.m2);
    poly.registerNode(Actor/* ActorSopNode */.f, CATEGORY_SOP.MODIFIER);
    poly.registerNode(ActorInstance/* ActorInstanceSopNode */.G, CATEGORY_SOP.MODIFIER);
    poly.registerNode(ActorPoint/* ActorPointSopNode */.i, CATEGORY_SOP.MODIFIER);
    poly.registerNode(Add/* AddSopNode */.d, CATEGORY_SOP.INPUT);
    poly.registerNode(AdjacencySopNode, CATEGORY_SOP.ADVANCED);
    poly.registerNode(sop_AmbientLight/* AmbientLightSopNode */.e, CATEGORY_SOP.LIGHTS);
    poly.registerNode(AnimationCopySopNode, CATEGORY_SOP.ANIMATION);
    poly.registerNode(sop_AreaLight/* AreaLightSopNode */.Y, CATEGORY_SOP.LIGHTS);
    poly.registerNode(AttribAddMult/* AttribAddMultSopNode */.$, CATEGORY_SOP.ATTRIBUTE);
    poly.registerNode(AttribCast/* AttribCastSopNode */.e, CATEGORY_SOP.ATTRIBUTE);
    poly.registerNode(AttribCopy/* AttribCopySopNode */.I, CATEGORY_SOP.ATTRIBUTE);
    poly.registerNode(AttribCreate/* AttribCreateSopNode */.R, CATEGORY_SOP.ATTRIBUTE);
    poly.registerNode(AttribDelete/* AttribDeleteSopNode */.b, CATEGORY_SOP.ATTRIBUTE);
    poly.registerNode(AttribFromTexture/* AttribFromTextureSopNode */.r, CATEGORY_SOP.ATTRIBUTE);
    poly.registerNode(AttribId/* AttribIdSopNode */.n, CATEGORY_SOP.ATTRIBUTE);
    poly.registerNode(AttribNormalize/* AttribNormalizeSopNode */.e, CATEGORY_SOP.ATTRIBUTE);
    poly.registerNode(AttribPromote/* AttribPromoteSopNode */.y, CATEGORY_SOP.ATTRIBUTE);
    poly.registerNode(AttribRemap/* AttribRemapSopNode */.d, CATEGORY_SOP.ATTRIBUTE);
    poly.registerNode(AttribRename/* AttribRenameSopNode */.K, CATEGORY_SOP.ATTRIBUTE);
    poly.registerNode(AttribSetAtIndex/* AttribSetAtIndexSopNode */.X, CATEGORY_SOP.ATTRIBUTE);
    poly.registerNode(AttribTransfer/* AttribTransferSopNode */.D, CATEGORY_SOP.ATTRIBUTE);
    poly.registerNode(AudioNotes/* AudioNotesSopNode */.b, CATEGORY_SOP.AUDIO);
    poly.registerNode(AxesHelperSopNode, CATEGORY_SOP.HELPERS);
    poly.registerNode(BboxScatter/* BboxScatterSopNode */.c, CATEGORY_SOP.MODIFIER);
    poly.registerNode(BlendSopNode, CATEGORY_SOP.MODIFIER);
    poly.registerNode(sop_Boolean/* BooleanSopNode */.z, CATEGORY_SOP.MODIFIER);
    poly.registerNode(Box/* BoxSopNode */.R, CATEGORY_SOP.PRIMITIVES);
    poly.registerNode(BoxLines/* BoxLinesSopNode */.n, CATEGORY_SOP.PRIMITIVES);
    poly.registerNode(BVHSopNode, CATEGORY_SOP.ADVANCED);
    poly.registerNode(BVHVisualizerSopNode, CATEGORY_SOP.ADVANCED);
    poly.registerNode(Cache/* CacheSopNode */.C, CATEGORY_SOP.MISC);
    poly.registerNode(CADBoolean/* CADBooleanSopNode */.$L, CATEGORY_SOP.CAD);
    poly.registerNode(CADBoxSopNode, [CATEGORY_SOP.CAD, CATEGORY_SOP.PRIMITIVES]);
    poly.registerNode(CADCircleSopNode, [CATEGORY_SOP.CAD, CATEGORY_SOP.PRIMITIVES]);
    poly.registerNode(CADCircle2DSopNode, [CATEGORY_SOP.CAD, CATEGORY_SOP.PRIMITIVES_2D]);
    poly.registerNode(CADCircle3PointsSopNode, [CATEGORY_SOP.CAD, CATEGORY_SOP.PRIMITIVES]);
    poly.registerNode(CADConeSopNode, [CATEGORY_SOP.CAD, CATEGORY_SOP.PRIMITIVES]);
    poly.registerNode(CADConvertDimension/* CADConvertDimensionSopNode */.KK, CATEGORY_SOP.CAD);
    poly.registerNode(CADCurve2DToSurfaceSopNode, CATEGORY_SOP.CAD);
    poly.registerNode(CADCurveFromPointsSopNode, CATEGORY_SOP.CAD);
    poly.registerNode(CADCurveFromPoints2DSopNode, CATEGORY_SOP.CAD);
    poly.registerNode(CADCurveTrimSopNode, CATEGORY_SOP.CAD);
    poly.registerNode(CADEllipseSopNode, [CATEGORY_SOP.CAD, CATEGORY_SOP.PRIMITIVES]);
    poly.registerNode(CADEllipse2DSopNode, [CATEGORY_SOP.CAD, CATEGORY_SOP.PRIMITIVES_2D]);
    poly.registerNode(CADExporterSTEP/* CADExporterSTEPSopNode */.s, [CATEGORY_SOP.CAD, CATEGORY_SOP.OUTPUT]);
    poly.registerNode(CADExtrudeSopNode, CATEGORY_SOP.CAD);
    poly.registerNode(CADFileSTEP/* CADFileSTEPSopNode */.M, [CATEGORY_SOP.CAD, CATEGORY_SOP.INPUT]);
    poly.registerNode(CADFillet/* CADFilletSopNode */.G, CATEGORY_SOP.CAD);
    poly.registerNode(CADGroup/* CADGroupSopNode */.F, CATEGORY_SOP.CAD);
    poly.registerNode(CADLoftSopNode, CATEGORY_SOP.CAD);
    poly.registerNode(CADMirror/* CADMirrorSopNode */.C, CATEGORY_SOP.CAD);
    poly.registerNode(CADPipeSopNode, CATEGORY_SOP.CAD);
    poly.registerNode(CADPointSopNode, CATEGORY_SOP.CAD);
    poly.registerNode(CADPoint2DSopNode, [CATEGORY_SOP.CAD, CATEGORY_SOP.PRIMITIVES_2D]);
    poly.registerNode(CADPointsFromCurveSopNode, CATEGORY_SOP.CAD);
    poly.registerNode(CADRectangleSopNode, [CATEGORY_SOP.CAD, CATEGORY_SOP.PRIMITIVES]);
    poly.registerNode(CADRevolutionSopNode, CATEGORY_SOP.CAD);
    poly.registerNode(CADSegmentSopNode, [CATEGORY_SOP.CAD, CATEGORY_SOP.PRIMITIVES]);
    poly.registerNode(CADSphereSopNode, [CATEGORY_SOP.CAD, CATEGORY_SOP.PRIMITIVES]);
    poly.registerNode(CADThickness/* CADThicknessSopNode */.J, CATEGORY_SOP.CAD);
    poly.registerNode(CADTorusSopNode, [CATEGORY_SOP.CAD, CATEGORY_SOP.PRIMITIVES]);
    poly.registerNode(CADTransformSopNode, CATEGORY_SOP.CAD);
    poly.registerNode(CADTransform2DSopNode, CATEGORY_SOP.CAD);
    poly.registerNode(CADTriangulateSopNode, CATEGORY_SOP.CAD);
    poly.registerNode(CADTubeSopNode, [CATEGORY_SOP.CAD, CATEGORY_SOP.PRIMITIVES]);
    poly.registerNode(CADUnpackSopNode, CATEGORY_SOP.CAD);
    poly.registerNode(CADWedgeSopNode, [CATEGORY_SOP.CAD, CATEGORY_SOP.PRIMITIVES]);
    poly.registerNode(CameraControls/* CameraControlsSopNode */.m, CATEGORY_SOP.CAMERA);
    poly.registerNode(CameraFPS/* CameraFPSSopNode */.f, CATEGORY_SOP.CAMERA);
    poly.registerNode(CameraFrameMode/* CameraFrameModeSopNode */.r, CATEGORY_SOP.CAMERA);
    poly.registerNode(CameraCSSRendererSopNode, CATEGORY_SOP.CAMERA);
    poly.registerNode(CameraPlaneSopNode, CATEGORY_SOP.PRIMITIVES);
    poly.registerNode(CameraPostProcess/* CameraPostProcessSopNode */.D, CATEGORY_SOP.CAMERA);
    poly.registerNode(CameraProject/* CameraProjectSopNode */.U, CATEGORY_SOP.MODIFIER);
    poly.registerNode(CameraRendererSopNode, CATEGORY_SOP.CAMERA);
    poly.registerNode(CameraRenderScene/* CameraRenderSceneSopNode */.Z, CATEGORY_SOP.CAMERA);
    poly.registerNode(CameraViewerCode/* CameraViewerCodeSopNode */.H, CATEGORY_SOP.CAMERA);
    poly.registerNode(CameraViewOffset/* CameraViewOffsetSopNode */.G, CATEGORY_SOP.CAMERA);
    poly.registerNode(CameraWebXRARMarkerTracking/* CameraWebXRARMarkerTrackingSopNode */.L, [CATEGORY_SOP.CAMERA, CATEGORY_SOP.WEBXR]);
    poly.registerNode(CameraWebXRAR/* CameraWebXRARSopNode */.c, [CATEGORY_SOP.CAMERA, CATEGORY_SOP.WEBXR]);
    poly.registerNode(CameraWebXRVR/* CameraWebXRVRSopNode */._, [CATEGORY_SOP.CAMERA, CATEGORY_SOP.WEBXR]);
    poly.registerNode(sop_Capsule/* CapsuleSopNode */.o, CATEGORY_SOP.PRIMITIVES);
    poly.registerNode(Center/* CenterSopNode */.t, CATEGORY_SOP.PRIMITIVES);
    poly.registerNode(CircleSopNode, CATEGORY_SOP.PRIMITIVES);
    poly.registerNode(Circle3Points/* Circle3PointsSopNode */.j, CATEGORY_SOP.PRIMITIVES);
    poly.registerNode(ClipSopNode, CATEGORY_SOP.MODIFIER);
    poly.registerNode(ClothPrepareSopNode, CATEGORY_SOP.PHYSICS);
    poly.registerNode(ClothSolverSopNode, CATEGORY_SOP.PHYSICS);
    poly.registerNode(sop_Code/* CodeSopNode */.W, CATEGORY_SOP.ADVANCED);
    poly.registerNode(sop_Color/* ColorSopNode */.k, CATEGORY_SOP.MODIFIER);
    poly.registerNode(Cone/* ConeSopNode */.w, CATEGORY_SOP.PRIMITIVES);
    poly.registerNode(ContactShadowsSopNode, CATEGORY_SOP.RENDER);
    poly.registerNode(ConvexHullSopNode, CATEGORY_SOP.MODIFIER);
    poly.registerNode(Copy/* CopySopNode */.a, CATEGORY_SOP.MODIFIER);
    poly.registerNode(CurveFromPointsSopNode, CATEGORY_SOP.PRIMITIVES);
    poly.registerNode(CurveGetPointSopNode, CATEGORY_SOP.MODIFIER);
    poly.registerNode(CSGArcSopNode, [CATEGORY_SOP.CSG, CATEGORY_SOP.PRIMITIVES_2D]);
    poly.registerNode(CSGBoolean/* CSGBooleanSopNode */.OQ, CATEGORY_SOP.CSG);
    poly.registerNode(CSGBoxSopNode, [CATEGORY_SOP.CSG, CATEGORY_SOP.PRIMITIVES]);
    poly.registerNode(CSGCenterSopNode, CATEGORY_SOP.CSG);
    poly.registerNode(CSGCircleSopNode, [CATEGORY_SOP.CSG, CATEGORY_SOP.PRIMITIVES_2D]);
    poly.registerNode(CSGDodecahedronSopNode, [CATEGORY_SOP.CSG, CATEGORY_SOP.PRIMITIVES]);
    poly.registerNode(CSGEllipseSopNode, [CATEGORY_SOP.CSG, CATEGORY_SOP.PRIMITIVES_2D]);
    poly.registerNode(CSGEllipsoidSopNode, [CATEGORY_SOP.CSG, CATEGORY_SOP.PRIMITIVES]);
    poly.registerNode(CSGExpandSopNode, CATEGORY_SOP.CSG);
    poly.registerNode(CSGExtrudeLinearSopNode, CATEGORY_SOP.CSG);
    poly.registerNode(CSGExtrudeRectangularSopNode, CATEGORY_SOP.CSG);
    poly.registerNode(CSGExtrudeRotateSopNode, CATEGORY_SOP.CSG);
    poly.registerNode(CSGHullSopNode, CATEGORY_SOP.CSG);
    poly.registerNode(CSGLineSopNode, [CATEGORY_SOP.CSG, CATEGORY_SOP.PRIMITIVES_2D]);
    poly.registerNode(CSGMirrorSopNode, CATEGORY_SOP.CSG);
    poly.registerNode(CSGOffsetSopNode, CATEGORY_SOP.CSG);
    poly.registerNode(CSGPolygonSopNode, [CATEGORY_SOP.CSG, CATEGORY_SOP.PRIMITIVES_2D]);
    poly.registerNode(CSGPolyhedronSopNode, [CATEGORY_SOP.CSG, CATEGORY_SOP.PRIMITIVES]);
    poly.registerNode(CSGProjectSopNode, CATEGORY_SOP.CSG);
    poly.registerNode(CSGRectangleSopNode, [CATEGORY_SOP.CSG, CATEGORY_SOP.PRIMITIVES_2D]);
    poly.registerNode(CSGTransformResetSopNode, CATEGORY_SOP.CSG);
    poly.registerNode(CSGSphereSopNode, [CATEGORY_SOP.CSG, CATEGORY_SOP.PRIMITIVES]);
    poly.registerNode(CSGStarSopNode, [CATEGORY_SOP.CSG, CATEGORY_SOP.PRIMITIVES_2D]);
    poly.registerNode(CSGTorusSopNode, [CATEGORY_SOP.CSG, CATEGORY_SOP.PRIMITIVES]);
    poly.registerNode(CSGTransform2DSopNode, CATEGORY_SOP.CSG);
    poly.registerNode(CSGTriangulateSopNode, CATEGORY_SOP.CSG);
    poly.registerNode(CSGTriangleSopNode, [CATEGORY_SOP.CSG, CATEGORY_SOP.PRIMITIVES]);
    poly.registerNode(CSGTubeSopNode, [CATEGORY_SOP.CSG, CATEGORY_SOP.PRIMITIVES]);
    poly.registerNode(CSGTubeEllipticSopNode, [CATEGORY_SOP.CSG, CATEGORY_SOP.PRIMITIVES]);
    poly.registerNode(CSS2DObject/* CSS2DObjectSopNode */.o, CATEGORY_SOP.PRIMITIVES);
    poly.registerNode(CSS3DObjectSopNode, CATEGORY_SOP.PRIMITIVES);
    poly.registerNode(sop_CubeCamera/* CubeCameraSopNode */.L, CATEGORY_SOP.CAMERA);
    poly.registerNode(Data/* DataSopNode */.C, CATEGORY_SOP.INPUT);
    poly.registerNode(DataUrl/* DataUrlSopNode */.i$, CATEGORY_SOP.INPUT);
    poly.registerNode(DecalSopNode, CATEGORY_SOP.MISC);
    poly.registerNode(Decompose/* DecomposeSopNode */.S, CATEGORY_SOP.MISC);
    poly.registerNode(DelaySopNode, CATEGORY_SOP.MISC);
    poly.registerNode(Delete/* DeleteSopNode */.R, CATEGORY_SOP.MODIFIER);
    poly.registerNode(DeleteByName/* DeleteByNameSopNode */._, CATEGORY_SOP.MODIFIER);
    poly.registerNode(sop_DirectionalLight/* DirectionalLightSopNode */.w, CATEGORY_SOP.LIGHTS);
    poly.registerNode(DrawRangeSopNode, CATEGORY_SOP.MODIFIER);
    poly.registerNode(EmptyObject/* EmptyObjectSopNode */.p, CATEGORY_SOP.PRIMITIVES);
    poly.registerNode(EntityBuilder/* EntityBuilderSopNode */.L, CATEGORY_SOP.MODIFIER);
    poly.registerNode(ExporterGLTF/* ExporterGLTFSopNode */.T, CATEGORY_SOP.OUTPUT);
    poly.registerNode(ExporterOBJ/* ExporterOBJSopNode */.S, CATEGORY_SOP.OUTPUT);
    poly.registerNode(ExporterPLY/* ExporterPLYSopNode */.c, CATEGORY_SOP.OUTPUT);
    poly.registerNode(ExporterSTL/* ExporterSTLSopNode */.u, CATEGORY_SOP.OUTPUT);
    poly.registerNode(FaceSopNode, CATEGORY_SOP.MODIFIER);
    poly.registerNode(Facet/* FacetSopNode */.b, CATEGORY_SOP.MODIFIER);
    poly.registerNode(File3DSSopNode, CATEGORY_SOP.INPUT);
    poly.registerNode(FileDRC/* FileDRCSopNode */.c, CATEGORY_SOP.INPUT);
    poly.registerNode(FileFBX/* FileFBXSopNode */.B, CATEGORY_SOP.INPUT);
    poly.registerNode(FileGEOJSON/* FileGEOJSONSopNode */.t, CATEGORY_SOP.INPUT);
    poly.registerNode(FileGLTF/* FileGLTFSopNode */.r, CATEGORY_SOP.INPUT);
    poly.registerNode(FileJSON/* FileJSONSopNode */.G, CATEGORY_SOP.INPUT);
    poly.registerNode(FileMPD/* FileMPDSopNode */.$, CATEGORY_SOP.INPUT);
    poly.registerNode(FileMultiGLTFSopNode, CATEGORY_SOP.INPUT);
    poly.registerNode(FileMultiOBJ/* FileMultiOBJSopNode */.$, CATEGORY_SOP.INPUT);
    poly.registerNode(FileOBJ/* FileOBJSopNode */.U, CATEGORY_SOP.INPUT);
    poly.registerNode(FilePDB/* FilePDBSopNode */.O, CATEGORY_SOP.INPUT);
    poly.registerNode(FilePLY/* FilePLYSopNode */.A, CATEGORY_SOP.INPUT);
    poly.registerNode(FileSTL/* FileSTLSopNode */.g, CATEGORY_SOP.INPUT);
    poly.registerNode(FileSVG/* FileSVGSopNode */.i, CATEGORY_SOP.INPUT);
    poly.registerNode(FileUSDZSopNode, CATEGORY_SOP.INPUT);
    poly.registerNode(FileVOX/* FileVOXSopNode */.M, CATEGORY_SOP.INPUT);
    poly.registerNode(sop_Fuse/* FuseSopNode */.m, CATEGORY_SOP.MODIFIER);
    poly.registerNode(GroundProjectedSkyboxSopNode, CATEGORY_SOP.INPUT);
    poly.registerNode(sop_HemisphereLight/* HemisphereLightSopNode */.A, CATEGORY_SOP.LIGHTS);
    poly.registerNode(HeightMapSopNode, CATEGORY_SOP.MODIFIER);
    poly.registerNode(Hexagons/* HexagonsSopNode */.o, CATEGORY_SOP.PRIMITIVES);
    poly.registerNode(Hierarchy/* HierarchySopNode */.z, CATEGORY_SOP.MISC);
    poly.registerNode(Icosahedron/* IcosahedronSopNode */.K, CATEGORY_SOP.PRIMITIVES);
    poly.registerNode(Instance/* InstanceSopNode */.K, CATEGORY_SOP.INSTANCE);
    poly.registerNode(InstanceBuilderSopNode, CATEGORY_SOP.MODIFIER);
    poly.registerNode(InstancedMeshToMeshSopNode, CATEGORY_SOP.INSTANCE);
    poly.registerNode(InstanceUpdateSopNode, CATEGORY_SOP.INSTANCE);
    poly.registerNode(InstancesCountSopNode, CATEGORY_SOP.INSTANCE);
    poly.registerNode(Jitter/* JitterSopNode */.o, CATEGORY_SOP.MODIFIER);
    poly.registerNode(LatticeSopNode, CATEGORY_SOP.MODIFIER);
    poly.registerNode(Layer/* LayerSopNode */.$3, CATEGORY_SOP.MODIFIER);
    poly.registerNode(LightMixerSopNode, CATEGORY_SOP.LIGHTS);
    poly.registerNode(nodes_sop_LightProbe/* LightProbeSopNode */.h, CATEGORY_SOP.LIGHTS);
    poly.registerNode(Line/* LineSopNode */._, CATEGORY_SOP.PRIMITIVES);
    poly.registerNode(LodSopNode, CATEGORY_SOP.ADVANCED);
    poly.registerNode(LookAtSopNode, CATEGORY_SOP.MODIFIER);
    poly.registerNode(MapboxCamera/* MapboxCameraSopNode */.L, CATEGORY_SOP.MAPS);
    poly.registerNode(MapboxLayer/* MapboxLayerSopNode */.M, CATEGORY_SOP.MAPS);
    poly.registerNode(MapboxPlane/* MapboxPlaneSopNode */.q, CATEGORY_SOP.MAPS);
    poly.registerNode(MapboxTransform/* MapboxTransformSopNode */.k, CATEGORY_SOP.MAPS);
    poly.registerNode(sop_Material/* MaterialSopNode */.z, CATEGORY_SOP.RENDER);
    poly.registerNode(MaterialPropertiesSopNode, CATEGORY_SOP.RENDER);
    poly.registerNode(sop_Merge/* MergeSopNode */.h, CATEGORY_SOP.FLOW);
    poly.registerNode(MetaballSopNode, CATEGORY_SOP.PRIMITIVES);
    poly.registerNode(MirrorSopNode, CATEGORY_SOP.MODIFIER);
    poly.registerNode(sop_Noise/* NoiseSopNode */.r, CATEGORY_SOP.MISC);
    poly.registerNode(Normals/* NormalsSopNode */.H, CATEGORY_SOP.MODIFIER);
    poly.registerNode(NormalsHelperSopNode, CATEGORY_SOP.HELPERS);
    poly.registerNode(NullSopNode, CATEGORY_SOP.FLOW);
    poly.registerNode(ObjectBuilderSopNode, CATEGORY_SOP.MODIFIER);
    poly.registerNode(ObjectMerge/* ObjectMergeSopNode */.h, CATEGORY_SOP.INPUT);
    poly.registerNode(ObjectProperties/* ObjectPropertiesSopNode */.M, CATEGORY_SOP.MODIFIER);
    poly.registerNode(ObjectsLayout/* ObjectsLayoutSopNode */.D, CATEGORY_SOP.MODIFIER);
    poly.registerNode(OceanPlaneSopNode, CATEGORY_SOP.ADVANCED);
    poly.registerNode(OperationsComposerSopNode, CATEGORY_SOP.ADVANCED, { userAllowed: false });
    poly.registerNode(sop_OrthographicCamera/* OrthographicCameraSopNode */.q, CATEGORY_SOP.CAMERA);
    poly.registerNode(Palette/* PaletteSopNode */.u, CATEGORY_SOP.MODIFIER);
    poly.registerNode(ParticlesSystemGpu/* ParticlesSystemGpuSopNode */.J, CATEGORY_SOP.DYNAMICS);
    poly.registerNode(ParticlesSystemGpuAttributesSopNode, CATEGORY_SOP.DYNAMICS);
    poly.registerNode(ParticlesSystemGpuMaterialSopNode, CATEGORY_SOP.DYNAMICS);
    poly.registerNode(PeakSopNode, CATEGORY_SOP.MODIFIER);
    poly.registerNode(sop_PerspectiveCamera/* PerspectiveCameraSopNode */.u, CATEGORY_SOP.CAMERA);
    poly.registerNode(PhysicsDebugSopNode, CATEGORY_SOP.PHYSICS);
    poly.registerNode(PhysicsGround/* PhysicsGroundSopNode */.b, CATEGORY_SOP.PHYSICS);
    poly.registerNode(PhysicsPlayer/* PhysicsPlayerSopNode */.M, CATEGORY_SOP.PHYSICS);
    poly.registerNode(PhysicsRBDJoints/* PhysicsRBDJointsSopNode */.D, CATEGORY_SOP.PHYSICS);
    poly.registerNode(PhysicsRBDAttributes/* PhysicsRBDAttributesSopNode */.M, CATEGORY_SOP.PHYSICS);
    poly.registerNode(sop_PhysicsWorld/* PhysicsWorldSopNode */.B, CATEGORY_SOP.PHYSICS);
    poly.registerNode(sop_Plane/* PlaneSopNode */.C, CATEGORY_SOP.PRIMITIVES);
    poly.registerNode(PlaneHelperSopNode, CATEGORY_SOP.HELPERS);
    poly.registerNode(PolarTransform/* PolarTransformSopNode */.L, CATEGORY_SOP.MODIFIER);
    poly.registerNode(PointBuilderSopNode, CATEGORY_SOP.MODIFIER);
    poly.registerNode(Point/* PointSopNode */.j, CATEGORY_SOP.MODIFIER);
    poly.registerNode(sop_PointLight/* PointLightSopNode */.J, CATEGORY_SOP.LIGHTS);
    poly.registerNode(PolywireSopNode, CATEGORY_SOP.MODIFIER);
    poly.registerNode(QuadExtrudeSopNode, CATEGORY_SOP.QUAD);
    poly.registerNode(QuadPlaneSopNode, CATEGORY_SOP.QUAD);
    poly.registerNode(QuadSmooth/* QuadSmoothSopNode */.ru, CATEGORY_SOP.QUAD);
    poly.registerNode(QuadTriangulate/* QuadTriangulateSopNode */.n, CATEGORY_SOP.QUAD);
    poly.registerNode(Quadrangulate/* QuadrangulateSopNode */.t, CATEGORY_SOP.QUAD);
    poly.registerNode(Ray/* RaySopNode */.U, CATEGORY_SOP.MODIFIER);
    poly.registerNode(ReflectorSopNode, CATEGORY_SOP.RENDER);
    poly.registerNode(ResampleSopNode, CATEGORY_SOP.MODIFIER);
    poly.registerNode(RestAttributes/* RestAttributesSopNode */.q, CATEGORY_SOP.ATTRIBUTE);
    poly.registerNode(RingSopNode, CATEGORY_SOP.PRIMITIVES);
    poly.registerNode(RoundedBox/* RoundedBoxSopNode */._, CATEGORY_SOP.PRIMITIVES);
    poly.registerNode(Scatter/* ScatterSopNode */.v, CATEGORY_SOP.MODIFIER);
    poly.registerNode(SDFBuilder/* SDFBuilderSopNode */.O, CATEGORY_SOP.SDF);
    poly.registerNode(SetChildren/* SetChildrenSopNode */.S, CATEGORY_SOP.MODIFIER);
    poly.registerNode(SetGeometry/* SetGeometrySopNode */.S, CATEGORY_SOP.MODIFIER);
    poly.registerNode(SkeletonHelperSopNode, CATEGORY_SOP.HELPERS);
    poly.registerNode(SkinSopNode, CATEGORY_SOP.MODIFIER);
    poly.registerNode(ShearSopNode, CATEGORY_SOP.MODIFIER);
    poly.registerNode(ShortestPathSopNode, CATEGORY_SOP.MODIFIER);
    poly.registerNode(Solver/* SolverSopNode */.S, CATEGORY_SOP.ADVANCED);
    poly.registerNode(SolverPreviousFrameSopNode, CATEGORY_SOP.ADVANCED);
    poly.registerNode(Sort/* SortSopNode */.i, CATEGORY_SOP.MODIFIER);
    poly.registerNode(Sphere/* SphereSopNode */._, CATEGORY_SOP.PRIMITIVES);
    poly.registerNode(Split/* SplitSopNode */.S, CATEGORY_SOP.MODIFIER);
    poly.registerNode(sop_SpotLight/* SpotLightSopNode */._, CATEGORY_SOP.LIGHTS);
    poly.registerNode(SubdivideSopNode, CATEGORY_SOP.MODIFIER);
    poly.registerNode(sop_Subnet/* SubnetSopNode */.q, CATEGORY_SOP.SUBNET);
    poly.registerNode(
      SubnetInput/* SubnetInputSopNode */.j,
      CATEGORY_SOP.SUBNET
      /*{
      	// TODO: use "except" so that it works inside PolyNodes
      	// only: [`${NodeContext.SOP}/${SubnetSopNode.type()}`, `${NodeContext.SOP}/poly`],
      }*/
    );
    poly.registerNode(
      sop_SubnetOutput/* SubnetOutputSopNode */.c,
      CATEGORY_SOP.SUBNET
      /*{
      	// only: [`${NodeContext.SOP}/${SubnetSopNode.type()}`, `${NodeContext.SOP}/poly`],
      }*/
    );
    poly.registerNode(sop_Switch/* SwitchSopNode */.j, CATEGORY_SOP.FLOW);
    poly.registerNode(Tangent/* TangentSopNode */.k, CATEGORY_SOP.ATTRIBUTE);
    poly.registerNode(TangentsHelperSopNode, CATEGORY_SOP.HELPERS);
    poly.registerNode(TetDeleteSopNode, CATEGORY_SOP.TET);
    poly.registerNode(TetEmbedSopNode, CATEGORY_SOP.TET);
    poly.registerNode(TetSoftBodySolverSopNode, CATEGORY_SOP.TET);
    poly.registerNode(TetTriangulateSopNode, CATEGORY_SOP.TET);
    poly.registerNode(Tetrahedralize/* TetrahedralizeSopNode */.i, CATEGORY_SOP.TET);
    poly.registerNode(Tetrahedron/* TetrahedronSopNode */.b, CATEGORY_SOP.PRIMITIVES);
    poly.registerNode(sop_Text/* TextSopNode */.m, CATEGORY_SOP.PRIMITIVES);
    poly.registerNode(TextureCopySopNode, CATEGORY_SOP.MODIFIER);
    poly.registerNode(TexturePropertiesSopNode, CATEGORY_SOP.MODIFIER);
    poly.registerNode(TrackingLandmarksFaceSopNode, CATEGORY_SOP.COMPUTER_VISION);
    poly.registerNode(TrackingLandmarksFaceAttributesSopNode, CATEGORY_SOP.COMPUTER_VISION);
    poly.registerNode(TrackingLandmarksHandSopNode, CATEGORY_SOP.COMPUTER_VISION);
    poly.registerNode(TrackingLandmarksHandAttributesSopNode, CATEGORY_SOP.COMPUTER_VISION);
    poly.registerNode(TorusSopNode, CATEGORY_SOP.PRIMITIVES);
    poly.registerNode(TorusKnotSopNode, CATEGORY_SOP.PRIMITIVES);
    poly.registerNode(sop_Transform/* TransformSopNode */.J, CATEGORY_SOP.MODIFIER);
    poly.registerNode(TransformCopySopNode, CATEGORY_SOP.MODIFIER);
    poly.registerNode(TransformMulti/* TransformMultiSopNode */.U, CATEGORY_SOP.MODIFIER);
    poly.registerNode(TransformReset/* TransformResetSopNode */.A, CATEGORY_SOP.MODIFIER);
    poly.registerNode(Tube/* TubeSopNode */.a, CATEGORY_SOP.PRIMITIVES);
    poly.registerNode(UvLayoutSopNode, CATEGORY_SOP.MODIFIER);
    poly.registerNode(UvProjectSopNode, CATEGORY_SOP.MODIFIER);
    poly.registerNode(UvTransformSopNode, CATEGORY_SOP.MODIFIER);
    poly.registerNode(UvUnwrap/* UvUnwrapSopNode */.f, CATEGORY_SOP.MODIFIER);
    poly.registerNode(WebXRAREstimatedLightSopNode, CATEGORY_SOP.WEBXR);
    poly.registerNode(WFCBuilderSopNode, CATEGORY_SOP.WFC);
    poly.registerNode(WFCDebug/* WFCDebugSopNode */.B, CATEGORY_SOP.WFC);
    poly.registerNode(WFCRuleFromProximitySopNode, CATEGORY_SOP.WFC);
    poly.registerNode(WFCRuleConnectionFromSideName/* WFCRuleConnectionFromSideNameSopNode */.n, CATEGORY_SOP.WFC);
    poly.registerNode(WFCRuleConnectionToGridBorderSopNode, CATEGORY_SOP.WFC);
    poly.registerNode(WFCRuleTileWeightSopNode, CATEGORY_SOP.WFC);
    poly.registerNode(WFCSolver/* WFCSolverSopNode */.Q, CATEGORY_SOP.WFC);
    poly.registerNode(WFCTileEmptyObjectSopNode, CATEGORY_SOP.WFC);
    poly.registerNode(WFCTileErrorObjectSopNode, CATEGORY_SOP.WFC);
    poly.registerNode(WFCTileProperties/* WFCTilePropertiesSopNode */.V, CATEGORY_SOP.WFC);
    poly.registerNode(WFCTileSideName/* WFCTileSideNameSopNode */.P, CATEGORY_SOP.WFC);
    poly.registerNode(WFCTileTransform/* WFCTileTransformSopNode */.l, CATEGORY_SOP.WFC);
    poly.registerNode(WFCTileUnresolvedObjectSopNode, CATEGORY_SOP.WFC);
    poly.registerNode(ActorsNetworkSopNode, CATEGORY_SOP.NETWORK);
    poly.registerNode(AnimationsNetworkSopNode, CATEGORY_SOP.NETWORK);
    poly.registerNode(AudioNetworkSopNode, CATEGORY_SOP.NETWORK);
    poly.registerNode(CopNetworkSopNode, CATEGORY_SOP.NETWORK);
    poly.registerNode(EventsNetworkSopNode, CATEGORY_SOP.NETWORK);
    poly.registerNode(MaterialsNetworkSopNode, CATEGORY_SOP.NETWORK);
    poly.registerNode(sop_PostProcessNetwork/* PostProcessNetworkSopNode */.z, CATEGORY_SOP.NETWORK);
    poly.registerNode(RenderersNetworkSopNode, CATEGORY_SOP.NETWORK);
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/poly/registers/nodes/All.ts

var All_async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};











class AllNodesRegister {
  static run(poly) {
    return All_async(this, null, function* () {
      AnimRegister.run(poly);
      AudioRegister.run(poly);
      CopRegister.run(poly);
      EventRegister.run(poly);
      GlRegister.run(poly);
      JsRegister.run(poly);
      MatRegister.run(poly);
      ObjRegister.run(poly);
      PostRegister.run(poly);
      RopRegister.run(poly);
      SopRegister.run(poly);
    });
  }
}

// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/core/Walker.ts
var Walker = __webpack_require__(742);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/core/DecomposedPath.ts
var DecomposedPath = __webpack_require__(35636);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/expressions/MethodDependency.ts
var MethodDependency = __webpack_require__(29205);
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/expressions/methods/_Base.ts

var _Base_async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};





class BaseMethod {
  constructor(param) {
    this.param = param;
  }
  node() {
    return this._node = this._node || this.param.node;
  }
  static requiredArguments() {
    console.warn("Expression.Method._Base.required_arguments virtual method call. Please override");
    return [];
  }
  static optionalArguments() {
    return [];
  }
  static minAllowedArgumentsCount() {
    return this.requiredArguments().length;
  }
  static maxAllowedArgumentsCount() {
    return this.minAllowedArgumentsCount() + this.optionalArguments().length;
  }
  static allowedArgumentsCount(count) {
    return count >= this.minAllowedArgumentsCount() && count <= this.maxAllowedArgumentsCount();
  }
  processArguments(args) {
    throw "Expression.Method._Base.process_arguments virtual method call. Please override";
  }
  getReferencedNodeContainer(indexOrPath) {
    return _Base_async(this, null, function* () {
      var _a, _b;
      const referencedNode = this.getReferencedNode(indexOrPath);
      if (referencedNode) {
        let container;
        if (referencedNode.isDirty() || ((_b = (_a = referencedNode.flags) == null ? void 0 : _a.bypass) == null ? void 0 : _b.active())) {
          container = yield referencedNode.compute();
        } else {
          container = referencedNode.containerController.container();
        }
        if (container) {
          const coreContent = container.coreContent();
          if (coreContent != null) {
            return container;
          }
        }
        throw `referenced node invalid: ${referencedNode.path()}`;
      } else {
        throw `invalid input (${indexOrPath})`;
      }
    });
  }
  getReferencedParam(path, decomposedPath) {
    const node = this.node();
    if (node) {
      return Walker/* CoreWalker.findParam */.s$.findParam(node, path, decomposedPath);
    }
    return null;
  }
  findReferencedGraphNode(indexOrPath, decomposedPath) {
    const is_index = Type/* CoreType.isNumber */.MR.isNumber(indexOrPath);
    if (is_index) {
      const index = indexOrPath;
      const node = this.node();
      if (node) {
        const input_graph_node = node.io.inputs.inputGraphNode(index);
        return input_graph_node;
      }
    } else {
      const path = indexOrPath;
      return this.getReferencedNode(path, decomposedPath);
    }
    return null;
  }
  // caching the node by path here prevents having expressions such as points_count(0)
  // evaluate to an error when the input is disconnected
  // private _node_by_path: Map<string | number, BaseNodeType | null | undefined> = new Map();
  getReferencedNode(indexOrPath, decomposedPath) {
    let node = null;
    const current_node = this.node();
    if (Type/* CoreType.isString */.MR.isString(indexOrPath)) {
      if (current_node) {
        const path = indexOrPath;
        node = Walker/* CoreWalker.findNode */.s$.findNode(current_node, path, decomposedPath);
      }
    } else {
      if (current_node) {
        const index = indexOrPath;
        node = current_node.io.inputs.input(index);
      }
    }
    return node || null;
  }
  findDependency(arg) {
    return null;
  }
  createDependencyFromIndexOrPath(args) {
    if (this.param.disposed() == true) {
      return null;
    }
    const { indexOrPath } = args;
    const decomposedPath = new DecomposedPath/* DecomposedPath */.G();
    const node = indexOrPath != null ? this.findReferencedGraphNode(indexOrPath, decomposedPath) : args.node;
    if (node) {
      return this.createDependency(node, args, decomposedPath);
    } else {
      Poly/* Poly.warn */.L.warn(`node not found for path '${indexOrPath}' from param '${this.param.path()}'`);
    }
    return null;
  }
  createDependency(node, pathArgs, decomposedPath) {
    const dependency = MethodDependency/* MethodDependency.create */.c.create(this.param, pathArgs, node, decomposedPath);
    return dependency;
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/expressions/methods/animationNames.ts

var animationNames_async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};

class AnimationNamesExpression extends BaseMethod {
  static requiredArguments() {
    return [
      ["string", "path to node"],
      ["number", "object index (optional)"]
    ];
  }
  findDependency(args) {
    return this.createDependencyFromIndexOrPath(args);
  }
  processArguments(args) {
    return new Promise((resolve, reject) => animationNames_async(this, null, function* () {
      if (args.length == 1 || args.length == 2) {
        const index_or_path = args[0];
        let objectIndex = parseInt(args[1]);
        if (isNaN(objectIndex) || objectIndex == null) {
          objectIndex = 0;
        }
        let container;
        try {
          container = yield this.getReferencedNodeContainer(index_or_path);
        } catch (e) {
          reject(e);
          return;
        }
        if (container) {
          const coreContent = container.coreContent();
          if (coreContent) {
            const object = coreContent.threejsObjects()[objectIndex];
            if (object) {
              const animations = object.animations;
              if (!animations) {
                return [];
              }
              const animationNames = new Array(animations.length);
              let i = 0;
              for (const animation of animations) {
                animationNames[i] = animation.name;
                i++;
              }
              resolve(animationNames);
            }
          } else {
            resolve([]);
          }
        }
      } else {
        resolve([]);
      }
    }));
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/expressions/methods/arg.ts

var arg_async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};

class ArgExpression extends BaseMethod {
  static requiredArguments() {
    return [
      ["string", "arguments list"],
      ["number", "index"]
    ];
  }
  processArguments(args) {
    return arg_async(this, null, function* () {
      if (args.length == 2) {
        const argumentsList = args[0];
        const index = args[1];
        const val = argumentsList.split(" ")[index];
        return val;
      }
      return 0;
    });
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/expressions/methods/argc.ts

var argc_async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};

class ArgcExpression extends BaseMethod {
  static requiredArguments() {
    return [["string", "arguments list"]];
  }
  processArguments(args) {
    return argc_async(this, null, function* () {
      if (args.length == 1) {
        const argumentsList = args[0];
        const val = argumentsList.split(" ").length;
        return val;
      }
      return 0;
    });
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/expressions/methods/bbox.ts

var bbox_async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};


const tmpBox = new three_module.Box3();
const VECTOR_NAMES = ["min", "max", "size", "center"];
const COMPONENT_NAMES = ["x", "y", "z"];
class BboxExpression extends BaseMethod {
  static requiredArguments() {
    return [
      ["string", "path to node"],
      ["string", "vector name, min, max, size or center"],
      ["string", "component_name, x,y or z"]
    ];
  }
  findDependency(args) {
    return this.createDependencyFromIndexOrPath(args);
  }
  processArguments(args) {
    return bbox_async(this, null, function* () {
      if (args.length >= 1) {
        const index_or_path = args[0];
        const vector_name = args[1];
        const component_name = args[2];
        const container = yield this.getReferencedNodeContainer(index_or_path);
        if (container) {
          const value = this._get_value_from_container(container, vector_name, component_name);
          return value;
        }
      }
      return 0;
    });
  }
  _get_value_from_container(container, vector_name, component_name) {
    const coreGroup = container.coreContent();
    if (coreGroup) {
      coreGroup.boundingBox(tmpBox);
    } else {
      tmpBox.makeEmpty();
    }
    if (!vector_name) {
      return tmpBox;
    }
    if (VECTOR_NAMES.indexOf(vector_name) >= 0) {
      let vector = new three_module.Vector3();
      switch (vector_name) {
        case "size":
          tmpBox.getSize(vector);
          break;
        case "center":
          tmpBox.getCenter(vector);
          break;
        default:
          vector = tmpBox[vector_name];
      }
      if (!component_name) {
        return vector;
      }
      if (COMPONENT_NAMES.indexOf(component_name) >= 0) {
        return vector[component_name];
      } else {
        return -1;
      }
    } else {
      return -1;
    }
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/expressions/methods/blob.ts

var blob_async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};

function blobFromUrl(url) {
  return blob_async(this, null, function* () {
    const response = yield fetch(url);
    const blob = yield response.blob();
    const urlCreator = window.URL || window.webkitURL;
    const blobUrl = urlCreator.createObjectURL(blob);
    return blobUrl;
  });
}
class BlobExpression extends BaseMethod {
  static requiredArguments() {
    return [["string", "url"]];
  }
  processArguments(args) {
    return blob_async(this, null, function* () {
      if (args.length >= 1) {
        const url = args[0];
        return yield blobFromUrl(url);
      }
      return "";
    });
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/expressions/methods/cameraName.ts

var cameraName_async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};


class CameraNameExpression extends BaseMethod {
  static requiredArguments() {
    return [
      ["string", "path to node"],
      ["number", "object index"]
    ];
  }
  findDependency(args) {
    return this.createDependencyFromIndexOrPath(args);
  }
  processArguments(args) {
    return cameraName_async(this, null, function* () {
      if (args.length == 2) {
        const index_or_path = args[0];
        let objectIndex = parseInt(args[1]);
        if (isNaN(objectIndex)) {
          objectIndex = 0;
        }
        const container = yield this.getReferencedNodeContainer(index_or_path);
        if (container) {
          const coreContent = container.coreContent();
          if (coreContent) {
            const object = coreContent.threejsObjects().filter((object2) => Poly/* Poly.camerasRegister.objectRegistered */.L.camerasRegister.objectRegistered(object2))[objectIndex];
            if (object) {
              return object.name;
            }
          }
        }
      }
      return "";
    });
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/expressions/methods/cameraNames.ts

var cameraNames_async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};


class CameraNamesExpression extends BaseMethod {
  static requiredArguments() {
    return [["string", "path to node"]];
  }
  findDependency(args) {
    return this.createDependencyFromIndexOrPath(args);
  }
  processArguments(args) {
    return cameraNames_async(this, null, function* () {
      if (args.length == 1) {
        const index_or_path = args[0];
        const container = yield this.getReferencedNodeContainer(index_or_path);
        if (container) {
          const coreContent = container.coreContent();
          if (coreContent) {
            const objects = coreContent.threejsObjects().filter((object) => Poly/* Poly.camerasRegister.objectRegistered */.L.camerasRegister.objectRegistered(object));
            const list = new Array(objects.length);
            let i = 0;
            for (const object of objects) {
              list[i] = object.name;
              i++;
            }
            return list;
          }
        }
      }
      return [];
    });
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/expressions/methods/camerasCount.ts

var camerasCount_async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};


class CamerasCountExpression extends BaseMethod {
  static requiredArguments() {
    return [["string", "path to node"]];
  }
  findDependency(args) {
    return this.createDependencyFromIndexOrPath(args);
  }
  processArguments(args) {
    return camerasCount_async(this, null, function* () {
      if (args.length == 1) {
        const index_or_path = args[0];
        const container = yield this.getReferencedNodeContainer(index_or_path);
        if (container) {
          const coreContent = container.coreContent();
          if (coreContent) {
            const count = coreContent.threejsObjects().filter((object) => Poly/* Poly.camerasRegister.objectRegistered */.L.camerasRegister.objectRegistered(object)).length;
            return count;
          }
        }
      }
      return 0;
    });
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/expressions/methods/centroid.ts

var centroid_async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};


const centroid_tmpBox = new three_module.Box3();
const tmpCenter = new three_module.Vector3();
class CentroidExpression extends BaseMethod {
  static requiredArguments() {
    return [
      ["string", "path to node"],
      ["string", "component_name, x,y or z"]
    ];
  }
  findDependency(args) {
    return this.createDependencyFromIndexOrPath(args);
  }
  processArguments(args) {
    return centroid_async(this, null, function* () {
      if (args.length >= 1) {
        const index_or_path = args[0];
        const component_name = args[1];
        const container = yield this.getReferencedNodeContainer(index_or_path);
        if (container) {
          const coreGroup = container.coreContent();
          if (coreGroup) {
            coreGroup.boundingBox(centroid_tmpBox);
            centroid_tmpBox.getCenter(tmpCenter);
            if (component_name) {
              const value = tmpCenter[component_name];
              if (value != null) {
                return value;
              } else {
                return 0;
              }
            } else {
              return tmpCenter;
            }
          }
        }
      }
      return 0;
    });
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/expressions/methods/ch.ts

var ch_async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};



class ChExpression extends BaseMethod {
  static requiredArguments() {
    return [["string", "path to param"]];
  }
  findDependency(args) {
    const { indexOrPath } = args;
    if (indexOrPath == null) {
      return null;
    }
    if (!Type/* CoreType.isString */.MR.isString(indexOrPath)) {
      return null;
    }
    const decomposedPath = new DecomposedPath/* DecomposedPath */.G();
    const param = this.getReferencedParam(indexOrPath, decomposedPath);
    if (param) {
      this._referencedParam = param;
      return this.createDependency(param, { indexOrPath }, decomposedPath);
    }
    return null;
  }
  processArguments(args) {
    return ch_async(this, null, function* () {
      return new Promise((resolve, reject) => ch_async(this, null, function* () {
        let val = 0;
        if (args.length == 1) {
          const path = args[0];
          const ref = this._referencedParam || this.getReferencedParam(path);
          if (ref) {
            if (ref.isDirty()) {
              yield ref.compute();
            }
            const result = ref.value;
            if (result != null) {
              val = result;
              resolve(val);
            }
          } else {
            reject(0);
          }
        }
      }));
    });
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/expressions/methods/chsop.ts

var chsop_async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};




class ChsopExpression extends BaseMethod {
  static requiredArguments() {
    return [["string", "path to param"]];
  }
  findDependency(args) {
    const { indexOrPath } = args;
    if (indexOrPath == null) {
      return null;
    }
    if (!Type/* CoreType.isString */.MR.isString(indexOrPath)) {
      return null;
    }
    const decomposedPath = new DecomposedPath/* DecomposedPath */.G();
    const param = this.getReferencedParam(indexOrPath, decomposedPath);
    if (param) {
      this._referencedParam = param;
      return this.createDependency(param, { indexOrPath }, decomposedPath);
    }
    return null;
  }
  processArguments(args) {
    return chsop_async(this, null, function* () {
      if (args.length == 1) {
        const path = args[0];
        const param = this._referencedParam || this.getReferencedParam(path);
        if (param) {
          if (param.isDirty()) {
            yield param.compute();
          }
          const paramValue = param.value;
          if (paramValue instanceof Walker/* TypedParamPathParamValue */.ZD || paramValue instanceof Walker/* TypedNodePathParamValue */.jI) {
            const result = paramValue.graphNodePath();
            if (result != null) {
              return result;
            }
          }
        }
      }
      return "";
    });
  }
}

// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/poly/registers/nodes/types/Anim.ts
var Anim = __webpack_require__(28567);
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/expressions/methods/copy.ts





function isCopyNode(node) {
  return node && node.type() == Sop/* SopType.COPY */.aB.COPY && node.type() == Anim/* AnimType.COPY */.R.COPY;
}
class CopyExpression extends BaseMethod {
  static requiredArguments() {
    return [
      ["string", "path to copy"],
      ["integer", "default value"]
    ];
  }
  static optionalArguments() {
    return [["string", "attribute name (optional)"]];
  }
  findDependency(args) {
    if (args.indexOrPath == null) {
      return null;
    }
    const node = this.findReferencedGraphNode(args.indexOrPath);
    if (isCopyNode(node)) {
      const stampNode = node.stampNode();
      return this.createDependency(stampNode, { indexOrPath: args.indexOrPath });
    }
    return null;
  }
  processArguments(args) {
    return new Promise((resolve, reject) => {
      if (args.length >= 1) {
        const path = args[0];
        const defaultValue = args[1] || 0;
        const attributeName = args[2];
        const currentNode = this.node();
        const node = currentNode ? Walker/* CoreWalker.findNode */.s$.findNode(currentNode, path) : null;
        let value;
        if (isCopyNode(node)) {
          value = node.stampValue(attributeName);
        }
        if (value == null) {
          value = defaultValue;
        }
        resolve(value);
      } else {
        resolve(0);
      }
    });
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/expressions/methods/copRes.ts

var copRes_async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};


const COMPONENT_NAME_0 = [0, "0", "x"];
const COMPONENT_NAME_1 = [1, "1", "y"];
class CopResExpression extends BaseMethod {
  constructor() {
    super(...arguments);
    this._resolution = new three_module.Vector2();
  }
  static requiredArguments() {
    return [
      ["string", "path to node"],
      ["string", "component_name: x or y"]
    ];
  }
  findDependency(args) {
    return this.createDependencyFromIndexOrPath(args);
  }
  processArguments(args) {
    return copRes_async(this, null, function* () {
      if (args.length == 1 || args.length == 2) {
        const indexOrPath = args[0];
        const componentName = args[1];
        const container = yield this.getReferencedNodeContainer(indexOrPath);
        if (container) {
          const resolution = container.resolution();
          if (componentName) {
            if (COMPONENT_NAME_0.includes(componentName)) {
              return resolution[0];
            } else {
              if (COMPONENT_NAME_1.includes(componentName)) {
                return resolution[1];
              }
            }
          } else {
            this._resolution.set(resolution[0], resolution[1]);
            return this._resolution;
          }
        }
        this._resolution.set(1, 1);
        return args.length == 1 ? 1 : this._resolution;
      }
      return 1;
    });
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/expressions/methods/isDeviceMobile.ts

var isDeviceMobile_async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};


class isDeviceMobileExpression extends BaseMethod {
  static requiredArguments() {
    return [];
  }
  processArguments(args) {
    return isDeviceMobile_async(this, null, function* () {
      return UserAgent/* CoreUserAgent.isMobile */.Cj.isMobile();
    });
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/expressions/methods/isDeviceTouch.ts

var isDeviceTouch_async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};


class isDeviceTouchExpression extends BaseMethod {
  static requiredArguments() {
    return [];
  }
  processArguments(args) {
    return isDeviceTouch_async(this, null, function* () {
      return UserAgent/* CoreUserAgent.isTouchDevice */.Cj.isTouchDevice();
    });
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/expressions/methods/len.ts

var len_async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};


class LenExpression extends BaseMethod {
  static requiredArguments() {
    return [["array_or_string", "array or string to count elements of"]];
  }
  processArguments(args) {
    return len_async(this, null, function* () {
      if (args.length == 1) {
        const arg = args[0];
        if (Type/* CoreType.isString */.MR.isString(arg) || Type/* CoreType.isArray */.MR.isArray(arg)) {
          return arg.length;
        }
      }
      return 0;
    });
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/expressions/methods/join.ts

var join_async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};


class JoinExpression extends BaseMethod {
  static requiredArguments() {
    return [
      ["array", "array to join the elements of"],
      ["separator", "separator used to join the elements"]
    ];
  }
  processArguments(args) {
    return join_async(this, null, function* () {
      if (args.length == 1 || args.length == 2) {
        const arg = args[0];
        let separator = args[1];
        if (separator == null) {
          separator = " ";
        }
        if (Type/* CoreType.isArray */.MR.isArray(arg)) {
          return arg.join(separator);
        }
      }
      return "";
    });
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/expressions/methods/js.ts

var js_async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};

class JsExpression extends BaseMethod {
  static requiredArguments() {
    return [["string", "javascript expression"]];
  }
  processArguments(args) {
    return js_async(this, null, function* () {
      let val = 0;
      if (args.length == 1) {
        const arg = args[0];
        this._function = this._function || this._create_function(arg);
        if (this._function) {
          try {
            val = this._function(this.param.scene(), this.param.node, this.param);
          } catch (e) {
            console.warn(`expression error`);
            console.warn(e);
          }
        }
      }
      return val;
    });
  }
  _create_function(content) {
    return new Function("scene", "node", "param", `return ${content}`);
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/expressions/methods/object.ts

var object_async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};

class ObjectExpression extends BaseMethod {
  static requiredArguments() {
    return [
      ["string", "path to node"],
      ["string", "attribute name"],
      ["index", "object index"]
    ];
  }
  findDependency(args) {
    return this.createDependencyFromIndexOrPath(args);
  }
  processArguments(args) {
    return new Promise((resolve, reject) => object_async(this, null, function* () {
      if (args.length == 2 || args.length == 3) {
        const indexOrPath = args[0];
        const attribName = args[1];
        const objectIndex = args[2] || 0;
        let container = null;
        try {
          container = yield this.getReferencedNodeContainer(indexOrPath);
        } catch (e) {
          reject(e);
        }
        if (container) {
          const value = this._get_value_from_container(container, attribName, objectIndex);
          resolve(value);
        }
      } else {
        console.warn(`${args.length} given when 2 or 3 expected`);
        resolve(0);
      }
    }));
  }
  _get_value_from_container(container, attrib_name, point_index) {
    const core_group = container.coreContent();
    if (core_group) {
      const coreObject = core_group.allCoreObjects()[point_index];
      if (coreObject) {
        return coreObject.attribValue(attrib_name);
      } else {
        return 0;
      }
    } else {
      return null;
    }
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/expressions/methods/objectsCount.ts

var objectsCount_async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};

class ObjectsCountExpression extends BaseMethod {
  static requiredArguments() {
    return [["string", "path to node"]];
  }
  findDependency(args) {
    return this.createDependencyFromIndexOrPath(args);
  }
  processArguments(args) {
    return objectsCount_async(this, null, function* () {
      if (args.length == 1) {
        const index_or_path = args[0];
        const container = yield this.getReferencedNodeContainer(index_or_path);
        if (container) {
          const coreGroup = container.coreContent();
          if (coreGroup) {
            const objectsCount = coreGroup.allObjects().length;
            return objectsCount;
          }
        }
      }
      return 0;
    });
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/expressions/methods/objectName.ts

var objectName_async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};

class ObjectNameExpression extends BaseMethod {
  static requiredArguments() {
    return [
      ["string", "path to node"],
      ["number", "object index"]
    ];
  }
  findDependency(args) {
    return this.createDependencyFromIndexOrPath(args);
  }
  processArguments(args) {
    return objectName_async(this, null, function* () {
      if (args.length == 2) {
        const index_or_path = args[0];
        let objectIndex = parseInt(args[1]);
        if (isNaN(objectIndex)) {
          objectIndex = 0;
        }
        const container = yield this.getReferencedNodeContainer(index_or_path);
        if (container) {
          const coreContent = container.coreContent();
          if (coreContent) {
            const object = coreContent.allObjects()[objectIndex];
            if (object) {
              return object.name;
            }
          }
        }
      }
      return "";
    });
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/expressions/methods/objectNames.ts

var objectNames_async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};

class ObjectNamesExpression extends BaseMethod {
  static requiredArguments() {
    return [["string", "path to node"]];
  }
  findDependency(args) {
    return this.createDependencyFromIndexOrPath(args);
  }
  processArguments(args) {
    return objectNames_async(this, null, function* () {
      if (args.length == 1) {
        const index_or_path = args[0];
        const container = yield this.getReferencedNodeContainer(index_or_path);
        if (container) {
          const coreContent = container.coreContent();
          if (coreContent) {
            const objects = coreContent.allObjects();
            const list = new Array(objects.length);
            let i = 0;
            for (const object of objects) {
              list[i] = object.name;
              i++;
            }
            return list;
          }
        }
      }
      return [];
    });
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/expressions/methods/opdigits.ts

var opdigits_async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};


class OpdigitsExpression extends BaseMethod {
  static requiredArguments() {
    return [["string", "path to node"]];
  }
  findDependency(args) {
    const { indexOrPath } = args;
    if (indexOrPath == null) {
      return null;
    }
    const graph_node = this.findReferencedGraphNode(indexOrPath);
    if (graph_node) {
      const node = graph_node;
      if (node.nameController) {
        const nameNode = node.nameController.graphNode();
        return this.createDependency(nameNode, { indexOrPath });
      }
    }
    return null;
  }
  processArguments(args) {
    return opdigits_async(this, null, function* () {
      if (args.length == 1) {
        const index_or_path = args[0];
        const node = this.getReferencedNode(index_or_path);
        if (node) {
          const name = node.name();
          return (0,core_String/* stringTailDigits */.KX)(name);
        }
      }
      return 0;
    });
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/expressions/methods/opname.ts

var opname_async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};

class OpnameExpression extends BaseMethod {
  static requiredArguments() {
    return [["string", "path to node"]];
  }
  findDependency(args) {
    const { indexOrPath } = args;
    if (indexOrPath == null) {
      return null;
    }
    const graphNode = this.findReferencedGraphNode(indexOrPath);
    if (graphNode) {
      const node = graphNode;
      if (node.nameController) {
        const nameNode = node.nameController.graphNode();
        return this.createDependency(nameNode, { indexOrPath });
      }
    }
    return null;
  }
  processArguments(args) {
    return opname_async(this, null, function* () {
      if (args.length == 1) {
        const index_or_path = args[0];
        const node = this.getReferencedNode(index_or_path);
        if (node) {
          return node.name();
        }
      }
      return "";
    });
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/expressions/methods/padzero.ts

var padzero_async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};

class PadzeroExpression extends BaseMethod {
  static requiredArguments() {
    return [["string", "number"]];
  }
  processArguments(args) {
    return padzero_async(this, null, function* () {
      const pad = args[0] || 2;
      const srcNumber = args[1] || 0;
      const unpadded = `${srcNumber}`;
      return unpadded.padStart(pad, "0");
    });
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/expressions/methods/playerMode.ts

var playerMode_async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};


class PlayerModeExpression extends BaseMethod {
  static requiredArguments() {
    return [];
  }
  processArguments(args) {
    return playerMode_async(this, null, function* () {
      return Poly/* Poly.playerMode */.L.playerMode();
    });
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/expressions/methods/point.ts

var point_async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};

const EXPECTED_ARGS_COUNT = 3;
const _pointsSrc = [];
class PointExpression extends BaseMethod {
  static requiredArguments() {
    return [
      ["string", "path to node"],
      ["string", "attribute name"],
      ["index", "point index"]
    ];
  }
  findDependency(args) {
    return this.createDependencyFromIndexOrPath(args);
  }
  processArguments(args) {
    return new Promise((resolve, reject) => point_async(this, null, function* () {
      if (args.length == EXPECTED_ARGS_COUNT) {
        const index_or_path = args[0];
        const attrib_name = args[1];
        const point_index = args[2];
        let container = null;
        try {
          container = yield this.getReferencedNodeContainer(index_or_path);
        } catch (e) {
          reject(e);
        }
        if (container) {
          const value = this._get_value_from_container(container, attrib_name, point_index);
          resolve(value);
        }
      } else {
        console.warn(`${args.length} given when expected ${EXPECTED_ARGS_COUNT}`);
        resolve(0);
      }
    }));
  }
  _get_value_from_container(container, attrib_name, point_index) {
    const coreGroup = container.coreContent();
    if (coreGroup) {
      coreGroup.points(_pointsSrc);
      const point = _pointsSrc[point_index];
      if (point) {
        return point.attribValue(attrib_name);
      } else {
        return 0;
      }
    } else {
      return null;
    }
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/expressions/methods/pointsCount.ts

var pointsCount_async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};

class PointsCountExpression extends BaseMethod {
  // npoints(0)
  // npoints('../REF_bbox')
  static requiredArguments() {
    return [["string", "path to node"]];
  }
  findDependency(args) {
    return this.createDependencyFromIndexOrPath(args);
  }
  processArguments(args) {
    return pointsCount_async(this, null, function* () {
      if (args.length == 1) {
        const indexOrPath = args[0];
        const container = yield this.getReferencedNodeContainer(indexOrPath);
        if (container) {
          const coreContent = container.coreContent();
          if (coreContent) {
            return coreContent.pointsCount();
          }
        }
      }
      return 0;
    });
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/expressions/methods/smoothstep.ts

var smoothstep_async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};


class SmoothstepExpression extends BaseMethod {
  static requiredArguments() {
    return [, ["x", "value"], ["min", "range min"], ["max", "range max"]];
  }
  processArguments(args) {
    return smoothstep_async(this, null, function* () {
      if (args.length == 3) {
        const x = args[0];
        const rangeMin = args[1];
        const rangeMax = args[2];
        return three_module.MathUtils.smoothstep(x, rangeMin, rangeMax);
      }
      return 0;
    });
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/expressions/methods/smootherstep.ts

var smootherstep_async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};


class SmootherstepExpression extends BaseMethod {
  static requiredArguments() {
    return [, ["x", "value"], ["min", "range min"], ["max", "range max"]];
  }
  processArguments(args) {
    return smootherstep_async(this, null, function* () {
      if (args.length == 3) {
        const x = args[0];
        const rangeMin = args[1];
        const rangeMax = args[2];
        return three_module.MathUtils.smootherstep(x, rangeMin, rangeMax);
      }
      return 0;
    });
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/expressions/methods/solverIteration.ts

var solverIteration_async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};


function isSolverNode(node) {
  return node && node.type() == poly_NodeContext/* NetworkNodeType.SOLVER */.kX.SOLVER;
}
class SolverIterationExpression extends BaseMethod {
  static requiredArguments() {
    return [];
  }
  static optionalArguments() {
    return [["string", "path to solver node"]];
  }
  _solverNode() {
    const solverNode = this.param.node.parentController.findParent(
      (parent) => parent.type() == poly_NodeContext/* NetworkNodeType.SOLVER */.kX.SOLVER
    );
    return solverNode;
  }
  findDependency(args) {
    const { indexOrPath } = args;
    const node = indexOrPath ? this.findReferencedGraphNode(indexOrPath) : this._solverNode();
    if (isSolverNode(node)) {
      const solverStamp = node.iterationStamp();
      return this.createDependency(solverStamp, { indexOrPath, node });
    }
    return null;
  }
  processArguments(args) {
    return solverIteration_async(this, null, function* () {
      const nodePath = args[0] || "..";
      const foundNode = yield this.getReferencedNode(nodePath);
      if (foundNode && isSolverNode(foundNode)) {
        const foundSolverNode = foundNode;
        const value = foundSolverNode.iterationStamp().iteration();
        return value;
      } else {
        return 0;
      }
    });
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/expressions/methods/strCharsCount.ts

var strCharsCount_async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};


class StrCharsCountExpression extends BaseMethod {
  // str_chars_count('bla') => 3
  static requiredArguments() {
    return [["string", "string to count characters of"]];
  }
  // findDependency(index_or_path: number | string): null {
  // 	return null
  // 	// return this.createDependencyFromIndexOrPath(index_or_path)
  // }
  processArguments(args) {
    return strCharsCount_async(this, null, function* () {
      if (args.length == 1) {
        const string = args[0];
        if (Type/* CoreType.isString */.MR.isString(string)) {
          return string.length;
        }
      }
      return 0;
    });
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/expressions/methods/strConcat.ts

var strConcat_async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};

class StrConcatExpression extends BaseMethod {
  static requiredArguments() {
    return [
      // ['string', 'string to get range from'],
      // ['integer', 'range start'],
      // ['integer', 'range size'],
    ];
  }
  // findDependency(index_or_path: number | string): null {
  // 	return null
  // 	// return this.createDependencyFromIndexOrPath(index_or_path)
  // }
  processArguments(args) {
    return strConcat_async(this, null, function* () {
      let value = "";
      for (let arg of args) {
        if (arg == null) {
          arg = "";
        }
        value += `${arg}`;
      }
      return value;
    });
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/expressions/methods/strIndex.ts

var strIndex_async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};

class StrIndexExpression extends BaseMethod {
  // str_chars_count('bla') => 3
  static requiredArguments() {
    return [
      ["string", "string to get index from"],
      ["string", "char to find index of"]
    ];
  }
  // findDependency(index_or_path: number | string): null {
  // 	return null
  // 	// return this.createDependencyFromIndexOrPath(index_or_path)
  // }
  processArguments(args) {
    return strIndex_async(this, null, function* () {
      if (args.length == 2) {
        const string = args[0];
        const sub_string = args[1];
        return string.indexOf(sub_string);
      }
      return -1;
    });
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/expressions/methods/strSub.ts

var strSub_async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};


function strSub_toString(arg) {
  if (arg == null) {
    return "";
  }
  return Type/* CoreType.isString */.MR.isString(arg) ? arg : `${arg}`;
}
function toInt(arg, defaultVal) {
  if (arg == null) {
    return defaultVal;
  }
  return Type/* CoreType.isNumber */.MR.isNumber(arg) ? arg : parseInt(arg);
}
class StrSubExpression extends BaseMethod {
  // str_chars_count('bla') => 3
  static requiredArguments() {
    return [
      ["string", "string to get range from"],
      ["integer", "range start"],
      ["integer", "range size"]
    ];
  }
  // findDependency(index_or_path: number | string): MethodDependency | null {
  // 	return null;
  // 	// return this.createDependencyFromIndexOrPath(index_or_path)
  // }
  processArguments(args) {
    return strSub_async(this, null, function* () {
      const string = strSub_toString(args[0]);
      const rangeStart = toInt(args[1], 0);
      let rangeSize = toInt(args[2], 1);
      if (string) {
        return string.substring(rangeStart, rangeStart + rangeSize);
      }
      return "";
    });
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/expressions/methods/viewerSize.ts

var viewerSize_async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};


class ViewerSizeExpression extends BaseMethod {
  constructor() {
    super(...arguments);
    this._size = new three_module.Vector2();
  }
  static requiredArguments() {
    return [[]];
  }
  findDependency(indexOrPath) {
    this.param.addGraphInput(this.param.scene().viewersRegister.graphNode());
    return null;
  }
  processArguments(args) {
    return viewerSize_async(this, null, function* () {
      var _a;
      (_a = this.param.scene().viewersRegister.lastRenderedViewer()) == null ? void 0 : _a.size(this._size);
      return this._size;
    });
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/expressions/methods/windowSize.ts

var windowSize_async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};


class WindowSizeExpression extends BaseMethod {
  constructor() {
    super(...arguments);
    this._windowSize = new three_module.Vector2();
  }
  static requiredArguments() {
    return [[]];
  }
  findDependency(indexOrPath) {
    this.param.addGraphInput(this.param.scene().windowController.graphNode());
    return null;
  }
  processArguments(args) {
    return windowSize_async(this, null, function* () {
      this._windowSize.set(window.innerWidth, window.innerHeight);
      return this._windowSize;
    });
  }
}

// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/expressions/methods/Common.ts
var methods_Common = __webpack_require__(39393);
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/poly/registers/expressions/All.ts







































class AllExpressionsRegister {
  static run(poly) {
    poly.expressionsRegister.register(AnimationNamesExpression, methods_Common/* ExpressionType.animationNames */.t.animationNames);
    poly.expressionsRegister.register(ArgExpression, methods_Common/* ExpressionType.arg */.t.arg);
    poly.expressionsRegister.register(ArgcExpression, methods_Common/* ExpressionType.argc */.t.argc);
    poly.expressionsRegister.register(BboxExpression, methods_Common/* ExpressionType.bbox */.t.bbox);
    poly.expressionsRegister.register(BlobExpression, methods_Common/* ExpressionType.blob */.t.blob);
    poly.expressionsRegister.register(CameraNameExpression, methods_Common/* ExpressionType.cameraName */.t.cameraName);
    poly.expressionsRegister.register(CameraNamesExpression, methods_Common/* ExpressionType.cameraNames */.t.cameraNames);
    poly.expressionsRegister.register(CamerasCountExpression, methods_Common/* ExpressionType.camerasCount */.t.camerasCount);
    poly.expressionsRegister.register(CentroidExpression, methods_Common/* ExpressionType.centroid */.t.centroid);
    poly.expressionsRegister.register(ChExpression, methods_Common/* ExpressionType.ch */.t.ch);
    poly.expressionsRegister.register(ChsopExpression, methods_Common/* ExpressionType.chsop */.t.chsop);
    poly.expressionsRegister.register(CopyExpression, methods_Common/* ExpressionType.copy */.t.copy);
    poly.expressionsRegister.register(CopResExpression, methods_Common/* ExpressionType.copRes */.t.copRes);
    poly.expressionsRegister.register(isDeviceMobileExpression, methods_Common/* ExpressionType.isDeviceMobile */.t.isDeviceMobile);
    poly.expressionsRegister.register(isDeviceTouchExpression, methods_Common/* ExpressionType.isDeviceTouch */.t.isDeviceTouch);
    poly.expressionsRegister.register(LenExpression, methods_Common/* ExpressionType.len */.t.len);
    poly.expressionsRegister.register(JoinExpression, methods_Common/* ExpressionType.join */.t.join);
    poly.expressionsRegister.register(JsExpression, methods_Common/* ExpressionType.js */.t.js);
    poly.expressionsRegister.register(ObjectExpression, methods_Common/* ExpressionType.object */.t.object);
    poly.expressionsRegister.register(ObjectsCountExpression, methods_Common/* ExpressionType.objectsCount */.t.objectsCount);
    poly.expressionsRegister.register(ObjectNameExpression, methods_Common/* ExpressionType.objectName */.t.objectName);
    poly.expressionsRegister.register(ObjectNamesExpression, methods_Common/* ExpressionType.objectNames */.t.objectNames);
    poly.expressionsRegister.register(OpdigitsExpression, methods_Common/* ExpressionType.opdigits */.t.opdigits);
    poly.expressionsRegister.register(OpnameExpression, methods_Common/* ExpressionType.opname */.t.opname);
    poly.expressionsRegister.register(PadzeroExpression, methods_Common/* ExpressionType.padzero */.t.padzero);
    poly.expressionsRegister.register(PlayerModeExpression, methods_Common/* ExpressionType.playerMode */.t.playerMode);
    poly.expressionsRegister.register(PointExpression, methods_Common/* ExpressionType.point */.t.point);
    poly.expressionsRegister.register(PointsCountExpression, methods_Common/* ExpressionType.pointsCount */.t.pointsCount);
    poly.expressionsRegister.register(SmoothstepExpression, methods_Common/* ExpressionType.smoothstep */.t.smoothstep);
    poly.expressionsRegister.register(SmootherstepExpression, methods_Common/* ExpressionType.smootherstep */.t.smootherstep);
    poly.expressionsRegister.register(SolverIterationExpression, methods_Common/* ExpressionType.solverIteration */.t.solverIteration);
    poly.expressionsRegister.register(StrCharsCountExpression, methods_Common/* ExpressionType.strCharsCount */.t.strCharsCount);
    poly.expressionsRegister.register(StrConcatExpression, methods_Common/* ExpressionType.strConcat */.t.strConcat);
    poly.expressionsRegister.register(StrIndexExpression, methods_Common/* ExpressionType.strIndex */.t.strIndex);
    poly.expressionsRegister.register(StrSubExpression, methods_Common/* ExpressionType.strSub */.t.strSub);
    poly.expressionsRegister.register(ViewerSizeExpression, methods_Common/* ExpressionType.viewerSize */.t.viewerSize);
    poly.expressionsRegister.register(WindowSizeExpression, methods_Common/* ExpressionType.windowSize */.t.windowSize);
  }
}

// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/core/MapUtils.ts
var MapUtils = __webpack_require__(94158);
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/gl/code/GlAssemblerNodeSpareParamsController.ts




const _tmpStrings = [];
const DEBUG = false;
function _paramMatchesParamConfig(param, paramConfig) {
  if (param.type() != paramConfig.type()) {
    if (DEBUG) {
      console.log(`${param.name()}: type is different to paramConfig's`, param.type(), paramConfig.type());
    }
    return false;
  }
  if (param.name() != paramConfig.name()) {
    if (DEBUG) {
      console.log(`${param.name()}: name is different to paramConfig's`, param.name(), paramConfig.name());
    }
    return false;
  }
  if (!param.isDefaultValueEqual(paramConfig.defaultValue())) {
    if (DEBUG) {
      console.log(
        `${param.name()}: defaultValue is different to paramConfig's`,
        param.defaultValue(),
        paramConfig.defaultValue()
      );
    }
    return false;
  }
  return true;
}
class GlAssemblerNodeSpareParamsController {
  constructor(_controller, _node) {
    this._controller = _controller;
    this._node = _node;
    // private _deletedParamsData: Map<string, ParamJsonExporterData<ParamType>> = new Map();
    // private _createdSpareParamNames: Set<string> = new Set();
    this._raw_input_serialized_by_param_name = /* @__PURE__ */ new Map();
    this._init_value_serialized_by_param_name = /* @__PURE__ */ new Map();
  }
  get assembler() {
    return this._controller.assembler;
  }
  // private _createdSpareParams(){
  // 	return this._node.params.spare;
  // }
  createSpareParameters() {
    const paramsUpdateOptions = {};
    const paramConfigs = this.assembler.param_configs();
    const paramConfigsByName = MapUtils/* MapUtils.groupBy */.pl.groupBy(paramConfigs, (c) => c.name());
    const assembler_param_names = paramConfigs.map((c) => c.name());
    const spare_param_names_to_add = /* @__PURE__ */ new Set();
    (0,ArrayUtils/* arrayToSet */.nu)(assembler_param_names, spare_param_names_to_add);
    const validation_result = this._validateNames(spare_param_names_to_add);
    if (validation_result == false) {
      return;
    }
    const currentSpareParams = this._node.params.spare;
    const spare_param_names_to_remove = /* @__PURE__ */ new Set();
    const currentSpareParamNames = /* @__PURE__ */ new Set();
    (0,ArrayUtils/* arrayToSet */.nu)(
      currentSpareParams.map((p) => p.name()),
      currentSpareParamNames
    );
    (0,SetUtils/* setUnion */.uy)(currentSpareParamNames, spare_param_names_to_add, spare_param_names_to_remove);
    for (const currentSpareParam of currentSpareParams) {
      const paramConfigsWithName = paramConfigsByName.get(currentSpareParam.name());
      if (paramConfigsWithName) {
        const firstParamConfig = paramConfigsWithName[0];
        if (firstParamConfig) {
          if (_paramMatchesParamConfig(currentSpareParam, firstParamConfig)) {
            spare_param_names_to_remove.delete(currentSpareParam.name());
            spare_param_names_to_add.delete(currentSpareParam.name());
          }
        }
      }
    }
    spare_param_names_to_remove.forEach((param_name) => {
      const param = this._node.params.get(param_name);
      if (param && !param.parentParam()) {
        this._raw_input_serialized_by_param_name.set(param.name(), param.rawInputSerialized());
        this._init_value_serialized_by_param_name.set(param.name(), param.defaultValueSerialized());
        paramsUpdateOptions.namesToDelete = paramsUpdateOptions.namesToDelete || [];
        paramsUpdateOptions.namesToDelete.push(param_name);
      }
    });
    for (const paramConfig of paramConfigs) {
      if (spare_param_names_to_add.has(paramConfig.name())) {
        const options = {
          spare: true,
          computeOnDirty: true,
          cook: false,
          // it should update the uniforms only via its callback
          // important for texture nodes
          // that compute after being found by the nodepath param
          dependentOnFoundNode: true
        };
        let init_value = this._init_value_serialized_by_param_name.get(paramConfig.name());
        if (init_value == null) {
          init_value = paramConfig.defaultValue();
        }
        let raw_input = this._raw_input_serialized_by_param_name.get(paramConfig.name());
        if (raw_input == null) {
          raw_input = paramConfig.defaultValue();
        }
        paramsUpdateOptions.toAdd = paramsUpdateOptions.toAdd || [];
        paramsUpdateOptions.toAdd.push({
          name: paramConfig.name(),
          type: paramConfig.type(),
          initValue: init_value,
          rawInput: raw_input,
          options
        });
      }
    }
    this._node.params.updateParams(paramsUpdateOptions);
    for (const paramConfig of paramConfigs) {
      paramConfig.applyToNode(this._node);
    }
  }
  _validateNames(spare_param_names_to_add) {
    const currentParamNames = /* @__PURE__ */ new Set();
    (0,ArrayUtils/* arrayToSet */.nu)(this._node.params.non_spare_names, currentParamNames);
    const spareParamsWithSameNameAsParams = /* @__PURE__ */ new Set();
    (0,SetUtils/* setIntersection */.OV)(spare_param_names_to_add, currentParamNames, spareParamsWithSameNameAsParams);
    if (spareParamsWithSameNameAsParams.size > 0) {
      const error_message = `${this._node.path()} attempts to create spare params called '${(0,SetUtils/* setToArray */.T_)(
        spareParamsWithSameNameAsParams,
        _tmpStrings
      ).join(", ")}' with same name as params`;
      this._node.states.error.set(error_message);
      return false;
    }
    return true;
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/gl/code/Controller.ts




class BaseGlParentNode extends (/* unused pure expression or super */ null && (TypedNode)) {
  createNode(node_class, options) {
    return super.createNode(node_class, options);
  }
  children() {
    return super.children();
  }
  nodesByType(type) {
    return super.nodesByType(type);
  }
}
class AssemblerGlControllerNode extends (/* unused pure expression or super */ null && (BaseGlParentNode)) {
}
class GlAssemblerController {
  constructor(node, assembler_class) {
    this.node = node;
    this._globalsHandler = new Geometry/* GlobalsGeometryHandler */.f();
    this._compile_required = true;
    this._assembler = new assembler_class(this.node);
    this._spareParamsController = new GlAssemblerNodeSpareParamsController(this, this.node);
  }
  setAssemblerGlobalsHandler(globalsHandler) {
    var _a;
    const currentType = (_a = this._globalsHandler) == null ? void 0 : _a.type();
    const newType = globalsHandler == null ? void 0 : globalsHandler.type();
    if (currentType != newType) {
      if (currentType != null) {
        console.warn(
          `set a new globals handler of type ${newType} on a node that already has a globals handler of type ${currentType} (node: ${this.node.path()}))`
        );
      }
      this._globalsHandler = globalsHandler;
      this.setCompilationRequiredAndDirty();
      this._assembler.reset_configs();
    }
  }
  get assembler() {
    return this._assembler;
  }
  globalsHandler() {
    return this._globalsHandler;
  }
  add_output_inputs(output_child) {
    this._assembler.add_output_inputs(output_child);
  }
  add_globals_outputs(globals_node) {
    this._assembler.add_globals_outputs(globals_node);
  }
  allow_attribute_exports() {
    return this._assembler.allow_attribute_exports();
  }
  setCompilationRequired(newState = true) {
    this._compile_required = newState;
  }
  setCompilationRequiredAndDirty(triggerNode) {
    this.setCompilationRequired();
    this.node.setDirty(triggerNode);
  }
  compileRequired() {
    return this._compile_required;
  }
  post_compile() {
    this.createSpareParameters();
    this.setCompilationRequired(false);
  }
  //
  // Create spare params on mat nodes
  //
  createSpareParameters() {
    this._spareParamsController.createSpareParameters();
  }
  addFilterFragmentShaderCallback(callbackName, callback) {
    this.assembler._addFilterFragmentShaderCallback(callbackName, callback);
    this.setCompilationRequired();
  }
  removeFilterFragmentShaderCallback(callbackName) {
    this.assembler._removeFilterFragmentShaderCallback(callbackName);
    this.setCompilationRequired();
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/js/code/globals/_Base.ts

class GlobalsJsBaseController {
  handleGlobalsNode(globalsNode, outputName, linesController) {
  }
  handleGlobalVar(globalsNode, outputName, glType, linesController) {
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/js/code/globals/Common.ts

var GlobalsJsBaseControllerType = /* @__PURE__ */ ((GlobalsJsBaseControllerType2) => {
  GlobalsJsBaseControllerType2["GEOMETRY"] = "geometry";
  return GlobalsJsBaseControllerType2;
})(GlobalsJsBaseControllerType || {});

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/js/code/globals/Geometry.ts



const VARIABLE_CONFIG_DEFAULT_BY_NAME = {
  position: "vec3( position )"
};
class GlobalsJsGeometryHandler extends GlobalsJsBaseController {
  type() {
    return GlobalsJsBaseControllerType.GEOMETRY;
  }
  handleGlobalsNode(globals_node, output_name, linesController) {
    const connection_point = globals_node.io.outputs.namedOutputConnectionPointsByName(output_name);
    if (!connection_point) {
      return;
    }
    const jsType = connection_point.type();
    this.handleGlobalVar(globals_node, output_name, jsType, linesController);
  }
  handleGlobalVar(globals_node, output_name, jsType, linesController) {
  }
  static variable_config_default(variable_name) {
    return VARIABLE_CONFIG_DEFAULT_BY_NAME[variable_name];
  }
  variable_config_default(variable_name) {
    return GlobalsJsGeometryHandler.variable_config_default(variable_name);
  }
  // variable_config_required_definitions(variable_name:string):DefinitionBaseConfig[]{
  // 	return null
  // }
  readAttribute(node, jsType, attribName, linesController) {
    return GlobalsJsGeometryHandler.readAttribute(node, jsType, attribName, linesController);
  }
  static readAttribute(node, jsType, attribName, linesController) {
    return void 0;
  }
  handle_attribute_node(node, jsType, attribName, linesController) {
    return GlobalsJsGeometryHandler.readAttribute(node, jsType, attribName, linesController);
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/js/code/JsAssemblerNodeSpareParamsController.ts





const _currentParamNames = /* @__PURE__ */ new Set();
const _spareParamNamesToAdd = /* @__PURE__ */ new Set();
const _spareParamNamesToRemove = /* @__PURE__ */ new Set();
const _spareParamsWithSameNameAsParams = /* @__PURE__ */ new Set();
const JsAssemblerNodeSpareParamsController_tmp = /* @__PURE__ */ new Set();
const JsAssemblerNodeSpareParamsController_DEBUG = false;
function JsAssemblerNodeSpareParamsController_paramMatchesParamConfig(param, paramConfig) {
  if (param.type() != paramConfig.type()) {
    if (JsAssemblerNodeSpareParamsController_DEBUG) {
      console.log(`${param.name()}: type is different to paramConfig's`, param.type(), paramConfig.type());
    }
    return false;
  }
  if (param.name() != paramConfig.name()) {
    if (JsAssemblerNodeSpareParamsController_DEBUG) {
      console.log(`${param.name()}: name is different to paramConfig's`, param.name(), paramConfig.name());
    }
    return false;
  }
  if (!param.isDefaultValueEqual(paramConfig.defaultValue())) {
    if (JsAssemblerNodeSpareParamsController_DEBUG) {
      console.log(
        `${param.name()}: defaultValue is different to paramConfig's`,
        param.defaultValue(),
        paramConfig.defaultValue()
      );
    }
    return false;
  }
  return true;
}
class JsAssemblerNodeSpareParamsController {
  constructor(_controller, _node) {
    this._controller = _controller;
    this._node = _node;
    // private _deletedParamsData: Map<string, ParamJsonExporterData<ParamType>> = new Map();
    // private _createdSpareParamNames: Set<string> = new Set();
    this._raw_input_serialized_by_param_name = /* @__PURE__ */ new Map();
    this._init_value_serialized_by_param_name = /* @__PURE__ */ new Map();
  }
  get assembler() {
    return this._controller.assembler;
  }
  // private _createdSpareParams(){
  // 	return this._node.params.spare;
  // }
  createSpareParameters() {
    const paramsUpdateOptions = {};
    const paramConfigs = this.assembler.param_configs();
    const paramConfigsByName = MapUtils/* MapUtils.groupBy */.pl.groupBy(paramConfigs, (c) => c.name());
    const assembler_param_names = paramConfigs.map((c) => c.name());
    (0,ArrayUtils/* arrayToSet */.nu)(assembler_param_names, _spareParamNamesToAdd);
    const validation_result = this._validateNames(_spareParamNamesToAdd);
    if (validation_result == false) {
      return;
    }
    const currentSpareParams = this._node.params.spare;
    const currentSpareParamNames = currentSpareParams.map((p) => p.name());
    (0,SetUtils/* setUnion */.uy)((0,ArrayUtils/* arrayToSet */.nu)(currentSpareParamNames, JsAssemblerNodeSpareParamsController_tmp), _spareParamNamesToAdd, _spareParamNamesToRemove);
    for (const currentSpareParam of currentSpareParams) {
      const paramConfigsWithName = paramConfigsByName.get(currentSpareParam.name());
      if (paramConfigsWithName) {
        const firstParamConfig = paramConfigsWithName[0];
        if (firstParamConfig) {
          if (JsAssemblerNodeSpareParamsController_paramMatchesParamConfig(currentSpareParam, firstParamConfig)) {
            _spareParamNamesToRemove.delete(currentSpareParam.name());
            _spareParamNamesToAdd.delete(currentSpareParam.name());
          }
        }
      }
    }
    _spareParamNamesToRemove.forEach((param_name) => {
      const param = this._node.params.get(param_name);
      if (param && !param.parentParam()) {
        this._raw_input_serialized_by_param_name.set(param.name(), param.rawInputSerialized());
        this._init_value_serialized_by_param_name.set(param.name(), param.defaultValueSerialized());
        paramsUpdateOptions.namesToDelete = paramsUpdateOptions.namesToDelete || [];
        paramsUpdateOptions.namesToDelete.push(param_name);
      }
    });
    for (const paramConfig of paramConfigs) {
      if (_spareParamNamesToAdd.has(paramConfig.name())) {
        const type = paramConfig.type();
        const options = this.assembler.spareParamsOptions({ type });
        let init_value = this._init_value_serialized_by_param_name.get(paramConfig.name());
        if (init_value == null) {
          init_value = paramConfig.defaultValue();
        }
        let raw_input = this._raw_input_serialized_by_param_name.get(paramConfig.name());
        if (raw_input == null) {
          raw_input = paramConfig.defaultValue();
        }
        if (type != ParamType/* ParamType.BUTTON */._.BUTTON) {
          paramsUpdateOptions.toAdd = paramsUpdateOptions.toAdd || [];
          paramsUpdateOptions.toAdd.push({
            name: paramConfig.name(),
            type,
            initValue: init_value,
            rawInput: raw_input,
            options
          });
        }
      }
    }
    this._node.params.updateParams(paramsUpdateOptions);
    for (const paramConfig of paramConfigs) {
      paramConfig.applyToNode(this._node);
    }
  }
  _validateNames(spareParamNamesToAdd) {
    (0,ArrayUtils/* arrayToSet */.nu)(this._node.params.non_spare_names, _currentParamNames);
    (0,SetUtils/* setIntersection */.OV)(spareParamNamesToAdd, _currentParamNames, _spareParamsWithSameNameAsParams);
    if (_spareParamsWithSameNameAsParams.size > 0) {
      const error_message = `${this._node.path()} attempts to create spare params called '${(0,SetUtils/* setToArray */.T_)(
        _spareParamsWithSameNameAsParams,
        []
      ).join(", ")}' with same name as params`;
      this._node.states.error.set(error_message);
      return false;
    }
    return true;
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/js/code/Controller.ts




class BaseJsParentNode extends (/* unused pure expression or super */ null && (TypedNode)) {
  createNode(node_class, options) {
    return super.createNode(node_class, options);
  }
  children() {
    return super.children();
  }
  nodesByType(type) {
    return super.nodesByType(type);
  }
}
class AssemblerControllerNode extends (/* unused pure expression or super */ null && (BaseJsParentNode)) {
}
class JsAssemblerController {
  constructor(node, assembler_class) {
    this.node = node;
    this._globalsHandler = new GlobalsJsGeometryHandler();
    this._compileRequired = true;
    this._assembler = new assembler_class(this.node);
    this._spareParamsController = new JsAssemblerNodeSpareParamsController(this, this.node);
  }
  setAssemblerGlobalsHandler(globalsHandler) {
    var _a;
    const currentType = (_a = this._globalsHandler) == null ? void 0 : _a.type();
    const newType = globalsHandler == null ? void 0 : globalsHandler.type();
    if (currentType != newType) {
      this._globalsHandler = globalsHandler;
      this.setCompilationRequiredAndDirty();
      this._assembler.resetConfigs();
    }
  }
  get assembler() {
    return this._assembler;
  }
  globalsHandler() {
    return this._globalsHandler;
  }
  add_output_inputs(output_child) {
    this._assembler.add_output_inputs(output_child);
  }
  add_globals_outputs(globals_node) {
    this._assembler.add_globals_outputs(globals_node);
  }
  allow_attribute_exports() {
    return this._assembler.allow_attribute_exports();
  }
  setCompilationRequired(newState = true) {
    this._compileRequired = newState;
  }
  setCompilationRequiredAndDirty(triggerNode) {
    if (this.node.scene().loadingController.isLoading()) {
      return;
    }
    this.setCompilationRequired();
    if (this._assembler.makeFunctionNodeDirtyOnChange()) {
      this.node.setDirty();
    } else {
      if (this.node.isDirty()) {
      } else {
        this.node.compile();
      }
    }
  }
  compileRequired() {
    return this._compileRequired;
  }
  post_compile() {
    this.createSpareParameters();
    this.setCompilationRequired(false);
  }
  //
  // Create spare params on mat nodes
  //
  createSpareParameters() {
    this._spareParamsController.createSpareParameters();
  }
  // addFilterFragmentShaderCallback(callbackName: string, callback: (s: string) => string) {
  // 	this.assembler._addFilterFragmentShaderCallback(callbackName, callback);
  // 	this.setCompilationRequired();
  // }
  // removeFilterFragmentShaderCallback(callbackName: string) {
  // 	this.assembler._removeFilterFragmentShaderCallback(callbackName);
  // 	this.setCompilationRequired();
  // }
}

// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/nodes/gl/code/assemblers/materials/common/GlobalOutput.ts
var GlobalOutput = __webpack_require__(3631);
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/gl/code/assemblers/materials/_BaseMaterial.ts











const FRAGMENT_GLOBALS_OUTPUT = [
  /*GlobalsOutput.GL_POSITION,*/
  GlobalOutput/* GlobalsOutput.GL_FRAGCOORD */.n.GL_FRAGCOORD,
  GlobalOutput/* GlobalsOutput.GL_POINTCOORD */.n.GL_POINTCOORD
];
const COMPILE_CUSTOM_MATERIALS = true;
class ShaderAssemblerMaterial extends assemblers_Base/* BaseGlShaderAssembler */.X {
  constructor() {
    super(...arguments);
    this._assemblersByCustomName = /* @__PURE__ */ new Map();
    this._filterFragmentShaderCallbacks = /* @__PURE__ */ new Map();
    // private _additionalUniformNames:string[]=[]
    // setAdditionalUniformNames(uniformNames:string[]){
    // 	this._additionalUniformNames = [...uniformNames]
    // }
    this._additionalTextureUniforms = {};
  }
  createMaterial() {
    return new three_module.Material();
  }
  customAssemblerClassByCustomName() {
    return void 0;
  }
  traverseCustomAssemblers(callback) {
    this._assemblersByCustomName.forEach(callback);
  }
  _addCustomMaterials(material) {
    const map = this.customAssemblerClassByCustomName();
    if (map) {
      map.forEach((assemblerClass, customName) => {
        this._addCustomMaterial(material, customName, assemblerClass);
      });
    }
  }
  _addCustomMaterial(material, customName, assemblerClass) {
    material.customMaterials = material.customMaterials || {};
    const matNode = this.currentGlParentNode();
    const matBuilderNode = matNode;
    if (matBuilderNode.customMaterialRequested && matBuilderNode.customMaterialRequested(customName) == false) {
      delete material.customMaterials[customName];
      return;
    }
    let customAssembler = this._assemblersByCustomName.get(customName);
    if (!customAssembler) {
      customAssembler = new assemblerClass(this.currentGlParentNode());
      this._assemblersByCustomName.set(customName, customAssembler);
    }
    const mat = customAssembler.createMaterial();
    mat.name = customName;
    material.customMaterials[customName] = mat;
  }
  compileCustomMaterials(material, parentAssembler) {
    const matNode = this.currentGlParentNode();
    const matBuilderNode = matNode;
    const class_by_custom_name = this.customAssemblerClassByCustomName();
    if (class_by_custom_name) {
      class_by_custom_name.forEach(
        (assemblerClass, customName) => {
          if (matBuilderNode.customMaterialRequested && matBuilderNode.customMaterialRequested(customName) == false) {
            delete material.customMaterials[customName];
            return;
          } else {
            if (!(customName in material.customMaterials)) {
              this._addCustomMaterial(material, customName, assemblerClass);
            }
          }
          if (this._codeBuilder) {
            let assembler = this._assemblersByCustomName.get(customName);
            if (!assembler) {
              assembler = new assemblerClass(this.currentGlParentNode());
              this._assemblersByCustomName.set(customName, assembler);
            }
            assembler._setAdditionalTextureUniforms(this._additionalTextureUniforms);
            assembler.set_root_nodes(this._root_nodes);
            assembler.setGlParentNode(parentAssembler.currentGlParentNode());
            assembler.set_param_configs_owner(this._codeBuilder);
            assembler.set_shader_configs(this.shaderConfigs());
            assembler.set_variable_configs(this.variable_configs());
            const custom_material = material.customMaterials[customName];
            if (custom_material) {
              assembler.setFilterFragmentShaderMethodOwner(this);
              assembler.compileMaterial(custom_material);
              assembler.setFilterFragmentShaderMethodOwner(void 0);
            }
          }
        }
      );
    }
  }
  _resetFilterFragmentShaderCallbacks() {
    this._filterFragmentShaderCallbacks.clear();
  }
  _addFilterFragmentShaderCallback(callbackName, callback) {
    this._filterFragmentShaderCallbacks.set(callbackName, callback);
  }
  _removeFilterFragmentShaderCallback(callbackName) {
    this._filterFragmentShaderCallbacks.delete(callbackName);
  }
  setFilterFragmentShaderMethodOwner(owner) {
    this._filterFragmentShaderMethodOwner = owner;
  }
  filterFragmentShader(fragmentShader) {
    this._filterFragmentShaderCallbacks.forEach((callback, callbackName) => {
      fragmentShader = callback(fragmentShader);
    });
    return fragmentShader;
  }
  processFilterFragmentShader(fragmentShader) {
    if (this._filterFragmentShaderMethodOwner) {
      return this._filterFragmentShaderMethodOwner.filterFragmentShader(fragmentShader);
    } else {
      return this.filterFragmentShader(fragmentShader);
    }
  }
  onBeforeCompileData() {
    return this._onBeforeCompileData;
  }
  clearAdditionalTextureUniforms() {
    this._additionalTextureUniforms = {};
  }
  addAdditionalTextureUniforms(uniformName, uniform) {
    this._additionalTextureUniforms[uniformName] = uniform;
  }
  _setAdditionalTextureUniforms(uniforms) {
    this.clearAdditionalTextureUniforms();
    const uniformNames = Object.keys(uniforms);
    for (const uniformName of uniformNames) {
      this._additionalTextureUniforms[uniformName] = uniforms[uniformName];
    }
  }
  compileMaterial(material, codeBuilderOptions) {
    if (!this.compileAllowed()) {
      return;
    }
    const outputNodes = NodeFinder/* GlNodeFinder.findOutputNodes */.W.findOutputNodes(this.currentGlParentNode());
    if (outputNodes.length == 0) {
      this.currentGlParentNode().states.error.set("one output node is required");
    }
    if (outputNodes.length > 1) {
      this.currentGlParentNode().states.error.set("only one output node allowed");
    }
    const varyingNodes = NodeFinder/* GlNodeFinder.findVaryingNodes */.W.findVaryingNodes(this.currentGlParentNode());
    const rootNodes = outputNodes.concat(varyingNodes);
    this.set_root_nodes(rootNodes);
    this.updateShaders(codeBuilderOptions);
    this.prepareOnBeforeCompileData(material);
    if (COMPILE_CUSTOM_MATERIALS) {
      if (material.customMaterials) {
        this.compileCustomMaterials(material, this);
      }
    }
  }
  prepareOnBeforeCompileData(material) {
    const scene = this.currentGlParentNode().scene();
    const vertexShader = this._shaders_by_name.get(ShaderName/* ShaderName.VERTEX */.k.VERTEX);
    const fragmentShader = this._shaders_by_name.get(ShaderName/* ShaderName.FRAGMENT */.k.FRAGMENT);
    if (vertexShader && fragmentShader) {
      const processedFragmentShader = this.processFilterFragmentShader(fragmentShader);
      this._onBeforeCompileData = {
        vertexShader,
        fragmentShader: processedFragmentShader,
        paramConfigs: this.param_configs(),
        additionalTextureUniforms: this._additionalTextureUniforms,
        timeDependent: this.uniformsTimeDependent(),
        resolutionDependent: this.uniformsResolutionDependent(),
        raymarchingLightsWorldCoordsDependent: this._raymarchingLightsWorldCoordsDependent()
      };
      (0,OnBeforeCompile/* assignOnBeforeCompileDataAndFunction */.VX)(scene, material, this._onBeforeCompileData);
      material.needsUpdate = true;
    }
  }
  updateShaders(codeBuilderOptions) {
    this._shaders_by_name.clear();
    this._lines.clear();
    for (const shaderName of this.shaderNames()) {
      const template = this._template_shader_for_shader_name(shaderName);
      if (template) {
        this._lines.set(shaderName, template.split("\n"));
      }
    }
    if (this._root_nodes.length > 0) {
      this.buildCodeFromNodes(this._root_nodes, codeBuilderOptions);
      this._buildLines();
    }
    for (const shader_name of this.shaderNames()) {
      const lines = this._lines.get(shader_name);
      if (lines) {
        this._shaders_by_name.set(shader_name, lines.join("\n"));
      }
    }
  }
  shadow_assembler_class_by_custom_name() {
    return {};
  }
  add_output_body_line(output_node, shaders_collection_controller, input_name) {
    var _a;
    const input = output_node.io.inputs.named_input(input_name);
    const var_input = output_node.variableForInput(input_name);
    const variable_config = this.variable_config(input_name);
    let new_var = null;
    if (input) {
      new_var = ThreeToGl/* ThreeToGl.vector3 */._.vector3(var_input);
    } else {
      if (variable_config.default_from_attribute()) {
        const connection_point = output_node.io.inputs.namedInputConnectionPointsByName(input_name);
        if (connection_point) {
          const gl_type = connection_point.type();
          const attr_read = (_a = this.globalsHandler()) == null ? void 0 : _a.readAttribute(
            output_node,
            gl_type,
            input_name,
            shaders_collection_controller
          );
          if (attr_read) {
            new_var = attr_read;
          }
        }
      } else {
        const variable_config_default = variable_config.default();
        if (variable_config_default) {
          new_var = variable_config_default;
        }
      }
    }
    if (new_var) {
      const prefix = variable_config.prefix();
      const suffix = variable_config.suffix();
      const if_condition = variable_config.if_condition();
      if (if_condition) {
        shaders_collection_controller.addBodyLines(output_node, [`#if ${if_condition}`]);
      }
      shaders_collection_controller.addBodyLines(output_node, [`${prefix}${new_var}${suffix}`]);
      const postLines = variable_config.postLines();
      if (postLines) {
        shaders_collection_controller.addBodyLines(output_node, postLines);
      }
      if (if_condition) {
        shaders_collection_controller.addBodyLines(output_node, [`#endif`]);
      }
    }
  }
  set_node_lines_output(output_node, shadersCollectionController) {
    var _a;
    const shader_name = shadersCollectionController.currentShaderName();
    const input_names = (_a = this.shader_config(shader_name)) == null ? void 0 : _a.input_names();
    if (input_names) {
      for (const input_name of input_names) {
        if (output_node.io.inputs.has_named_input(input_name)) {
          this.add_output_body_line(output_node, shadersCollectionController, input_name);
        }
      }
    }
  }
  setNodeLinesAttribute(attribute_node, shadersCollectionController) {
    var _a;
    const gl_type = attribute_node.glType();
    const new_var = (_a = this.globalsHandler()) == null ? void 0 : _a.readAttribute(
      attribute_node,
      gl_type,
      attribute_node.attributeName(),
      shadersCollectionController
    );
    const var_name = attribute_node.glVarName(attribute_node.outputName());
    shadersCollectionController.addBodyLines(attribute_node, [`${gl_type} ${var_name} = ${new_var}`]);
  }
  handle_globals_output_name(options) {
    var _a;
    switch (options.output_name) {
      case GlobalOutput/* GlobalsOutput.TIME */.n.TIME:
        this.handleTime(options);
        return;
      case GlobalOutput/* GlobalsOutput.RESOLUTION */.n.RESOLUTION:
        this.handle_resolution(options);
        return;
      case GlobalOutput/* GlobalsOutput.MV_POSITION */.n.MV_POSITION:
        this.handle_mvPosition(options);
        return;
      case GlobalOutput/* GlobalsOutput.GL_POSITION */.n.GL_POSITION:
        this.handle_gl_Position(options);
        return;
      case GlobalOutput/* GlobalsOutput.GL_FRAGCOORD */.n.GL_FRAGCOORD:
        this.handle_gl_FragCoord(options);
        return;
      case GlobalOutput/* GlobalsOutput.GL_POINTCOORD */.n.GL_POINTCOORD:
        this.handle_gl_PointCoord(options);
        return;
      default:
        (_a = this.globalsHandler()) == null ? void 0 : _a.handleGlobalsNode(
          options.globals_node,
          options.output_name,
          options.shaders_collection_controller
        );
    }
  }
  handleTime(options) {
    const definition = new GLDefinition/* UniformGLDefinition */.oA(
      options.globals_node,
      Gl/* GlConnectionPointType.FLOAT */.Dv.FLOAT,
      options.output_name
    );
    if (options.globals_shader_name) {
      MapUtils/* MapUtils.pushOnArrayAtEntry */.pl.pushOnArrayAtEntry(options.definitions_by_shader_name, options.globals_shader_name, definition);
    }
    const body_line = `float ${options.var_name} = ${options.output_name}`;
    for (const dependency of options.dependencies) {
      MapUtils/* MapUtils.pushOnArrayAtEntry */.pl.pushOnArrayAtEntry(options.definitions_by_shader_name, dependency, definition);
      MapUtils/* MapUtils.pushOnArrayAtEntry */.pl.pushOnArrayAtEntry(options.body_lines_by_shader_name, dependency, body_line);
    }
    options.body_lines.push(body_line);
    this.setUniformsTimeDependent();
  }
  handle_resolution(options) {
    options.body_lines.push(`vec2 ${options.var_name} = resolution`);
    const definition = new GLDefinition/* UniformGLDefinition */.oA(
      options.globals_node,
      Gl/* GlConnectionPointType.VEC2 */.Dv.VEC2,
      options.output_name
    );
    if (options.globals_shader_name) {
      MapUtils/* MapUtils.pushOnArrayAtEntry */.pl.pushOnArrayAtEntry(options.definitions_by_shader_name, options.globals_shader_name, definition);
    }
    for (const dependency of options.dependencies) {
      MapUtils/* MapUtils.pushOnArrayAtEntry */.pl.pushOnArrayAtEntry(options.definitions_by_shader_name, dependency, definition);
    }
    this.setUniformsResolutionDependent();
  }
  handle_mvPosition(options) {
    if (options.shader_name == ShaderName/* ShaderName.FRAGMENT */.k.FRAGMENT) {
      const globals_node = options.globals_node;
      const shaders_collection_controller = options.shaders_collection_controller;
      const definition = new GLDefinition/* VaryingGLDefinition */.W9(globals_node, Gl/* GlConnectionPointType.VEC4 */.Dv.VEC4, options.var_name);
      const vertex_body_line = `${options.var_name} = modelViewMatrix * vec4(position, 1.0)`;
      shaders_collection_controller.addDefinitions(globals_node, [definition], ShaderName/* ShaderName.VERTEX */.k.VERTEX);
      shaders_collection_controller.addBodyLines(globals_node, [vertex_body_line], ShaderName/* ShaderName.VERTEX */.k.VERTEX);
      shaders_collection_controller.addDefinitions(globals_node, [definition]);
    }
  }
  handle_gl_Position(options) {
    if (options.shader_name == ShaderName/* ShaderName.FRAGMENT */.k.FRAGMENT) {
      const globals_node = options.globals_node;
      const shaders_collection_controller = options.shaders_collection_controller;
      const definition = new GLDefinition/* VaryingGLDefinition */.W9(globals_node, Gl/* GlConnectionPointType.VEC4 */.Dv.VEC4, options.var_name);
      const vertex_body_line = `${options.var_name} = projectionMatrix * modelViewMatrix * vec4(position, 1.0)`;
      shaders_collection_controller.addDefinitions(globals_node, [definition], ShaderName/* ShaderName.VERTEX */.k.VERTEX);
      shaders_collection_controller.addBodyLines(globals_node, [vertex_body_line], ShaderName/* ShaderName.VERTEX */.k.VERTEX);
      shaders_collection_controller.addDefinitions(globals_node, [definition]);
    }
  }
  handle_gl_FragCoord(options) {
    if (options.shader_name == ShaderName/* ShaderName.FRAGMENT */.k.FRAGMENT) {
      options.body_lines.push(`vec4 ${options.var_name} = gl_FragCoord`);
    }
  }
  handle_gl_PointCoord(options) {
    if (options.shader_name == ShaderName/* ShaderName.FRAGMENT */.k.FRAGMENT) {
      options.body_lines.push(`vec2 ${options.var_name} = gl_PointCoord`);
    } else {
      options.body_lines.push(`vec2 ${options.var_name} = vec2(0.0, 0.0)`);
    }
  }
  set_node_lines_globals(globals_node, shaders_collection_controller) {
    const body_lines = [];
    const shader_name = shaders_collection_controller.currentShaderName();
    const shader_config = this.shader_config(shader_name);
    if (!shader_config) {
      return;
    }
    const dependencies = shader_config.dependencies();
    const definitions_by_shader_name = /* @__PURE__ */ new Map();
    const body_lines_by_shader_name = /* @__PURE__ */ new Map();
    const used_output_names = this.used_output_names_for_shader(globals_node, shader_name);
    for (const output_name of used_output_names) {
      const var_name = globals_node.glVarName(output_name);
      const globals_shader_name = shaders_collection_controller.currentShaderName();
      const options = {
        globals_node,
        shaders_collection_controller,
        output_name,
        globals_shader_name,
        definitions_by_shader_name,
        body_lines,
        var_name,
        shader_name,
        dependencies,
        body_lines_by_shader_name
      };
      this.handle_globals_output_name(options);
    }
    definitions_by_shader_name.forEach((definitions, shader_name2) => {
      shaders_collection_controller.addDefinitions(globals_node, definitions, shader_name2);
    });
    body_lines_by_shader_name.forEach((body_lines2, shader_name2) => {
      shaders_collection_controller.addBodyLines(globals_node, body_lines2, shader_name2);
    });
    shaders_collection_controller.addBodyLines(globals_node, body_lines);
  }
  used_output_names_for_shader(globals_node, shader_name) {
    const used_output_names = globals_node.io.outputs.used_output_names();
    const filtered_names = [];
    for (const name of used_output_names) {
      if (shader_name == ShaderName/* ShaderName.VERTEX */.k.VERTEX) {
        if (!FRAGMENT_GLOBALS_OUTPUT.includes(name)) {
          filtered_names.push(name);
        }
      } else {
        filtered_names.push(name);
      }
    }
    return filtered_names;
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/gl/code/templates/custom/mesh/CustomMeshDistance.frag.glsl
/* harmony default export */ var CustomMeshDistance_frag = ("\n// INSERT DEFINES\n\n#define DISTANCE\n\nuniform vec3 referencePosition;\nuniform float nearDistance;\nuniform float farDistance;\nvarying vec3 vWorldPosition;\n\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <clipping_planes_pars_fragment>\n\nvoid main () {\n\n\t#include <clipping_planes_fragment>\n\n\tvec4 diffuseColor = vec4( 1.0 );\n\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\n\t// INSERT BODY\n\n\t#include <alphatest_fragment>\n\n\tfloat dist = length( vWorldPosition - referencePosition );\n\tdist = ( dist - nearDistance ) / ( farDistance - nearDistance );\n\tdist = saturate( dist ); // clamp to [ 0, 1 ]\n\n\tgl_FragColor = packDepthToRGBA( dist );\n\n}\n");
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/gl/gl/sss/declaration.glsl
/* harmony default export */ var declaration = ("struct SSSModel {\n\tbool isActive;\n\tvec3 color;\n\tfloat thickness;\n\tfloat power;\n\tfloat scale;\n\tfloat distortion;\n\tfloat ambient;\n\tfloat attenuation;\n};\n\nvoid RE_Direct_Scattering(\n\tconst in IncidentLight directLight,\n\tconst in vec3 geometryNormal,\n\tconst in vec3 geometryViewDir,\n\tconst in SSSModel sssModel,\n\tinout ReflectedLight reflectedLight\n\t){\n\tvec3 scatteringHalf = normalize(directLight.direction + (geometryNormal * sssModel.distortion));\n\tfloat scatteringDot = pow(saturate(dot(geometryViewDir, -scatteringHalf)), sssModel.power) * sssModel.scale;\n\tvec3 scatteringIllu = (scatteringDot + sssModel.ambient) * (sssModel.color * (1.0-sssModel.thickness));\n\treflectedLight.directDiffuse += scatteringIllu * sssModel.attenuation * directLight.color;\n}");
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/gl/gl/sss/injected.glsl
/* harmony default export */ var injected = ("if(POLY_SSSModel.isActive){\n\tRE_Direct_Scattering(directLight, geometryNormal, geometryViewDir, POLY_SSSModel, reflectedLight);\n}\n");
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/gl/code/assemblers/materials/common/SSS.ts



const USE_SSS = true;
function includeSSSDeclarations(fragmentShader) {
  if (USE_SSS) {
    fragmentShader = fragmentShader.replace(
      /void main\s?\(\) {/,
      `${declaration}

void main() {`
    );
    fragmentShader = fragmentShader.replace(
      "#include <lights_fragment_begin>",
      `#include <lights_fragment_begin>
${injected}
`
    );
  }
  return fragmentShader;
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/gl/code/assemblers/materials/custom/mesh/CustomMeshDistance.ts








const INSERT_BODY_AFTER_MAP = /* @__PURE__ */ new Map([
  [ShaderName/* ShaderName.VERTEX */.k.VERTEX, "#include <begin_vertex>"],
  [ShaderName/* ShaderName.FRAGMENT */.k.FRAGMENT, "#include <alphamap_fragment>"]
]);
class ShaderAssemblerCustomMeshDistance extends ShaderAssemblerMaterial {
  constructor(_gl_parent_node) {
    super(_gl_parent_node);
    this._gl_parent_node = _gl_parent_node;
    this._addFilterFragmentShaderCallback("MeshStandardBuilderMatNode", includeSSSDeclarations);
  }
  templateShader() {
    const template = three_module.ShaderLib.distanceRGBA;
    return {
      vertexShader: template.vertexShader,
      fragmentShader: [CustomMeshDistance_frag, template.fragmentShader][0],
      uniforms: template.uniforms
    };
  }
  insertDefineAfter(shaderName) {
    return INSERT_DEFINE_AFTER_MAPF_FOR_MESH.get(shaderName);
  }
  insertBodyAfter(shaderName) {
    return INSERT_BODY_AFTER_MAP.get(shaderName);
  }
  createMaterial() {
    return new three_module.MeshDistanceMaterial();
  }
}
class ShaderAssemblerCustomMeshDistanceForRender extends ShaderAssemblerCustomMeshDistance {
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/gl/code/templates/custom/mesh/CustomMeshDepth.frag.glsl
/* harmony default export */ var CustomMeshDepth_frag = ("\n// INSERT DEFINES\n\n\n#if DEPTH_PACKING == 3200\n\n\tuniform float opacity;\n\n#endif\n\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\n\nvarying vec2 vHighPrecisionZW;\n\nvoid main() {\n\n\t#include <clipping_planes_fragment>\n\n\tvec4 diffuseColor = vec4( 1.0 );\n\n\t#if DEPTH_PACKING == 3200\n\n\t\tdiffuseColor.a = opacity;\n\n\t#endif\n\n\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\n\t// INSERT BODY\n\t// the new body lines should be added before the alphatest_fragment\n\t// so that alpha is set before (which is really how it would be set if the alphamap_fragment above was used by the material node parameters)\n\n\t#include <alphatest_fragment>\n\n\t#include <logdepthbuf_fragment>\n\n\n\t// Higher precision equivalent of gl_FragCoord.z. This assumes depthRange has been left to its default values.\n\tfloat fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;\n\n\t#if DEPTH_PACKING == 3200\n\n\t\tgl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), diffuseColor.a );\n\n\t#elif DEPTH_PACKING == 3201\n\n\t\tgl_FragColor = packDepthToRGBA( fragCoordZ );\n\n\t#endif\n\n}\n");
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/gl/code/assemblers/materials/custom/mesh/CustomMeshDepth.ts









const CustomMeshDepth_INSERT_BODY_AFTER_MAP = /* @__PURE__ */ new Map([
  [ShaderName/* ShaderName.VERTEX */.k.VERTEX, "#include <begin_vertex>"],
  [ShaderName/* ShaderName.FRAGMENT */.k.FRAGMENT, "#include <alphamap_fragment>"]
]);
class ShaderAssemblerCustomMeshDepth extends ShaderAssemblerMaterial {
  constructor(_gl_parent_node) {
    super(_gl_parent_node);
    this._gl_parent_node = _gl_parent_node;
    this._addFilterFragmentShaderCallback("MeshStandardBuilderMatNode", includeSSSDeclarations);
  }
  templateShader() {
    const template = three_module.ShaderLib.depth;
    return {
      vertexShader: template.vertexShader,
      fragmentShader: CustomMeshDepth_frag,
      uniforms: template.uniforms
    };
  }
  insertDefineAfter(shaderName) {
    return INSERT_DEFINE_AFTER_MAPF_FOR_MESH.get(shaderName);
  }
  insertBodyAfter(shaderName) {
    return CustomMeshDepth_INSERT_BODY_AFTER_MAP.get(shaderName);
  }
  depthPacking() {
    return three_module.RGBADepthPacking;
  }
  createMaterial() {
    const material = new three_module.MeshDepthMaterial({ depthPacking: this.depthPacking() });
    return material;
  }
}
class ShaderAssemblerCustomMeshDepthForRender extends ShaderAssemblerCustomMeshDepth {
  depthPacking() {
    return three_module.BasicDepthPacking;
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/gl/code/assemblers/materials/custom/mesh/CustomMeshDepthDOF.ts


const ShaderAssemblerCustomMeshDepthDOF = ShaderAssemblerCustomMeshDepthForRender;

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/gl/code/assemblers/materials/_BaseMesh.ts







const ASSEMBLER_MAP = /* @__PURE__ */ new Map([
  // [CustomMaterialName.DISTANCE, ShaderAssemblerCustomMeshDistance],
  // [CustomMaterialName.DEPTH, ShaderAssemblerCustomMeshDepth],
  // [CustomMaterialName.DEPTH_DOF, ShaderAssemblerCustomMeshDepthDOF],
]);
ASSEMBLER_MAP.set(geometry_Material/* CustomMaterialName.DEPTH */.RJ.DEPTH, ShaderAssemblerCustomMeshDepth);
ASSEMBLER_MAP.set(geometry_Material/* CustomMaterialName.DISTANCE */.RJ.DISTANCE, ShaderAssemblerCustomMeshDistance);
ASSEMBLER_MAP.set(geometry_Material/* CustomMaterialName.DEPTH_DOF */.RJ.DEPTH_DOF, ShaderAssemblerCustomMeshDepthDOF);
const INSERT_DEFINE_AFTER_MAPF_FOR_MESH = /* @__PURE__ */ new Map([
  [ShaderName/* ShaderName.VERTEX */.k.VERTEX, "#include <skinning_pars_vertex>"],
  [ShaderName/* ShaderName.FRAGMENT */.k.FRAGMENT, "#include <common>"]
]);
class ShaderAssemblerMesh extends ShaderAssemblerMaterial {
  // TODO: I've noticed a case where instances would not display when those shadow shaders were exported
  // But the objects display fine if those are not assigned
  // so it could be a bug at render time (not sure if my code, threejs or hardware)
  customAssemblerClassByCustomName() {
    return ASSEMBLER_MAP;
  }
  insertDefineAfter(shaderName) {
    return INSERT_DEFINE_AFTER_MAPF_FOR_MESH.get(shaderName);
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/gl/code/assemblers/materials/Basic.ts




class ShaderAssemblerBasic extends ShaderAssemblerMesh {
  templateShader() {
    const template = three_module.ShaderLib.basic;
    return {
      vertexShader: template.vertexShader,
      fragmentShader: template.fragmentShader,
      uniforms: template.uniforms
    };
  }
  createMaterial() {
    const material = new three_module.MeshBasicMaterial();
    this._addCustomMaterials(material);
    return material;
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/gl/code/templates/cloth/Default.glsl
/* harmony default export */ var Default = ("precision highp float;\nprecision highp sampler2D;\n\nuniform vec2 tSize;\nuniform float order;\nuniform sampler2D tOriginal;\nuniform sampler2D tPrevious0;\nuniform sampler2D tPrevious1;\nuniform sampler2D tPosition0;\nuniform sampler2D tPosition1;\nuniform sampler2D tViscositySpring;\nuniform float time;\nuniform float timeDelta;\nuniform float viscosity;\nuniform float spring;\n\n// INSERT DEFINE\n\n// *** ADD COMMON ***\n\nvoid main() {\n\n\tvec2 particleUv = gl_FragCoord.xy / tSize.xy;\n\n\tvec3 original = texture2D( tOriginal, particleUv ).xyz;\n\tvec3 previous = ( texture2D( tPrevious0, particleUv ).xyz + texture2D( tPrevious1, particleUv ).xyz ) / 1024.0;\n\tvec3 position = ( texture2D( tPosition0, particleUv ).xyz + texture2D( tPosition1, particleUv ).xyz ) / 1024.0;\n\tvec3 viscositySpring = texture2D( tViscositySpring, particleUv ).xyz;\n\tfloat viscosityMult = viscosity * viscositySpring.x;\n\tfloat springMult = spring * viscositySpring.y;\n\n\t// INSERT BODY\n\n\tvec3 offset = ( original - position ) * timeDelta * springMult;\n\tvec3 disp = ( position - previous ) * ( 1.0 - viscosityMult ) + position;\n\n\tgl_FragColor = vec4( unpackPosition( disp + offset, order ), 1.0 );\n\n}\n");
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/nodes/utils/shaders/NodeTraverser.ts
var NodeTraverser = __webpack_require__(12689);
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/utils/shaders/GlNodeTraverser.ts



const _nodeIds = [];
class GlNodeTraverser extends NodeTraverser/* TypedNodeTraverser */.v {
  leavesFromNodes(nodes) {
    var _a;
    this._shaderName = ShaderName/* ShaderName.LEAVES_FROM_NODES_SHADER */.k.LEAVES_FROM_NODES_SHADER;
    this._graph_ids_by_shader_name.set(this._shaderName, /* @__PURE__ */ new Map());
    this._leaves_graph_id.set(this._shaderName, /* @__PURE__ */ new Map());
    for (const node of nodes) {
      this._findLeaves(node);
    }
    _nodeIds.length = 0;
    (_a = this._leaves_graph_id.get(this._shaderName)) == null ? void 0 : _a.forEach((value, key) => {
      _nodeIds.push(key);
    });
    const selectedNodes = [];
    this._graph.nodesFromIds(_nodeIds, selectedNodes);
    return selectedNodes;
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/gl/code/assemblers/cloth/ClothAssembler.ts










class ShaderAssemblerCloth extends assemblers_Base/* BaseGlShaderAssembler */.X {
  templateShader() {
    return void 0;
  }
  _template_shader_for_shader_name(shader_name) {
    return Default;
  }
  // async get_shaders(){
  // 	await this.update_shaders()
  // 	return this._shaders_by_name
  // }
  compile() {
    this.setup_shader_names_and_variables();
    this._updateShaders();
  }
  rootNodesByShaderName(shader_name, rootNodes) {
    var _a, _b;
    const list = [];
    for (const node of rootNodes) {
      switch (node.type()) {
        case gl_SubnetOutput/* SubnetOutputGlNode.type */.U.type():
        case Output/* OutputGlNode.type */.H.type(): {
          list.push(node);
          break;
        }
        case Attribute/* AttributeGlNode.type */.W.type(): {
          const attrib_name = node.attributeName();
          const variable = (_a = this._textureAllocationsController) == null ? void 0 : _a.variable(attrib_name);
          if (variable && variable.allocation()) {
            const allocation_shader_name = (_b = variable.allocation()) == null ? void 0 : _b.shaderName();
            if (allocation_shader_name == shader_name) {
              list.push(node);
            }
          }
          break;
        }
      }
    }
    return list;
  }
  // override leaf_nodes_by_shader_name(shader_name: ShaderName): BaseGlNodeType[] {
  // 	const list = [];
  // 	for (let node of this._leaf_nodes) {
  // 		switch (node.type()) {
  // 			case GlobalsGlNode.type(): {
  // 				list.push(node);
  // 				break;
  // 			}
  // 			case AttributeGlNode.type(): {
  // 				const attrib_name: string = (node as AttributeGlNode).attributeName();
  // 				const variable = this._textureAllocationsController?.variable(attrib_name);
  // 				if (variable && variable.allocation()) {
  // 					const allocation_shader_name = variable.allocation()?.shaderName();
  // 					if (allocation_shader_name == shader_name) {
  // 						list.push(node);
  // 					}
  // 				}
  // 				break;
  // 			}
  // 		}
  // 	}
  // 	return list;
  // }
  setup_shader_names_and_variables() {
    var _a;
    const node_traverser_shallow = new GlNodeTraverser(
      this.currentGlParentNode(),
      this.shaderNames(),
      (root_node, shader_name) => {
        return this.inputNamesForShaderName(root_node, shader_name);
      }
    );
    const node_traverser_deep = new GlNodeTraverser(
      this.currentGlParentNode(),
      this.shaderNames(),
      (root_node, shader_name) => {
        return this.inputNamesForShaderName(root_node, shader_name);
      },
      { traverseChildren: true }
    );
    this._leaf_nodes = node_traverser_shallow.leavesFromNodes(this._root_nodes);
    const leafNodesForTextureAllocations = node_traverser_deep.leavesFromNodes(this._root_nodes);
    this._textureAllocationsController = new TextureAllocationsController/* TextureAllocationsController */.T();
    this._textureAllocationsController.allocateConnectionsFromRootNodes(
      this._root_nodes,
      leafNodesForTextureAllocations
    );
    if (this.globalsHandler()) {
      (_a = this.globalsHandler()) == null ? void 0 : _a.set_texture_allocations_controller(
        this._textureAllocationsController
      );
    }
    this._reset_shader_configs();
  }
  _updateShaders() {
    this._shaders_by_name.clear();
    this._lines.clear();
    for (const shader_name of this.shaderNames()) {
      const template = this._template_shader_for_shader_name(shader_name);
      this._lines.set(shader_name, template.split("\n"));
    }
    if (this._root_nodes.length > 0) {
      this._resetCodeBuilder();
      this.buildCodeFromNodes(this._root_nodes);
      this._buildLines();
    }
    for (const shader_name of this.shaderNames()) {
      const lines = this._lines.get(shader_name);
      if (lines) {
        this._shaders_by_name.set(shader_name, lines.join("\n"));
      }
    }
  }
  //
  //
  // CHILDREN NODES PARAMS
  //
  //
  add_output_inputs(output_child) {
    output_child.io.inputs.setNamedInputConnectionPoints([
      new Gl/* GlConnectionPoint */.E("position", Gl/* GlConnectionPointType.VEC3 */.Dv.VEC3)
      // new GlConnectionPoint('velocity', GlConnectionPointType.VEC3),
    ]);
  }
  add_globals_outputs(globals_node) {
    globals_node.io.outputs.setNamedOutputConnectionPoints([
      new Gl/* GlConnectionPoint */.E("position", Gl/* GlConnectionPointType.VEC3 */.Dv.VEC3),
      // new GlConnectionPoint('velocity', GlConnectionPointType.VEC3),
      new Gl/* GlConnectionPoint */.E("time", Gl/* GlConnectionPointType.FLOAT */.Dv.FLOAT),
      new Gl/* GlConnectionPoint */.E("timeDelta", Gl/* GlConnectionPointType.FLOAT */.Dv.FLOAT)
    ]);
  }
  allow_attribute_exports() {
    return false;
  }
  textureAllocationsController() {
    return this._textureAllocationsController = this._textureAllocationsController || new TextureAllocationsController/* TextureAllocationsController */.T();
  }
  //
  //
  // CONFIGS
  //
  //
  create_shader_configs() {
    var _a;
    return ((_a = this._textureAllocationsController) == null ? void 0 : _a.createShaderConfigs()) || [];
  }
  create_variable_configs() {
    return [
      // new VariableConfig('position', {
      // 	default: 'vec3( position )',
      // 	prefix: 'vec3 transformed = '
      // }),
    ];
  }
  shaderNames() {
    return this.textureAllocationsController().shaderNames() || [];
  }
  inputNamesForShaderName(root_node, shader_name) {
    return this.textureAllocationsController().inputNamesForShaderName(root_node, shader_name) || [];
  }
  //
  //
  // TEMPLATE HOOKS
  //
  //
  insertDefineAfter(shader_name) {
    return "// INSERT DEFINE";
  }
  insertBodyAfter(shader_name) {
    return "// INSERT BODY";
  }
  linesToRemove(shader_name) {
    return ["// INSERT DEFINE", "// INSERT BODY"];
  }
  //
  //
  // TEMPLATE CODE REPLACEMENT
  //
  //
  add_export_body_line(exportNode, inputName, input, variableName, linesController) {
    var _a;
    if (input) {
      const var_input = exportNode.variableForInput(inputName);
      const new_var = ThreeToGl/* ThreeToGl.vector3 */._.vector3(var_input);
      if (new_var) {
        const texture_variable = this.textureAllocationsController().variable(variableName);
        const shader_name = linesController.currentShaderName();
        if (texture_variable && ((_a = texture_variable.allocation()) == null ? void 0 : _a.shaderName()) == shader_name) {
          const component = texture_variable.component();
          const line = `${inputName}.${component} = ${new_var}`;
          linesController.addBodyLines(exportNode, [line], shader_name);
        }
      }
    }
  }
  set_node_lines_output(outputNode, linesController) {
    const shaderName = linesController.currentShaderName();
    const inputNames = this.textureAllocationsController().inputNamesForShaderName(outputNode, shaderName);
    if (inputNames) {
      for (let inputName of inputNames) {
        const input = outputNode.io.inputs.named_input(inputName);
        if (input) {
          const variable_name = inputName;
          this.add_export_body_line(outputNode, inputName, input, variable_name, linesController);
        } else {
        }
      }
    }
  }
  setNodeLinesAttribute(attributeNode, linesController) {
    var _a, _b;
    if (attributeNode.isImporting()) {
      const gl_type = attributeNode.glType();
      const attribute_name = attributeNode.attributeName();
      const new_value = (_a = this.globalsHandler()) == null ? void 0 : _a.readAttribute(
        attributeNode,
        gl_type,
        attribute_name,
        linesController
      );
      const var_name = attributeNode.glVarName(attributeNode.outputName());
      const body_line = `${gl_type} ${var_name} = ${new_value}`;
      linesController.addBodyLines(attributeNode, [body_line]);
      const texture_variable = this.textureAllocationsController().variable(attribute_name);
      const shader_name = linesController.currentShaderName();
      if (texture_variable && ((_b = texture_variable.allocation()) == null ? void 0 : _b.shaderName()) == shader_name) {
        const variable = this.textureAllocationsController().variable(attribute_name);
        if (variable) {
          const component = variable.component();
          const body_line2 = `gl_FragColor.${component} = ${var_name}`;
          linesController.addBodyLines(attributeNode, [body_line2]);
        }
      }
    }
    if (attributeNode.isExporting()) {
      const input = attributeNode.connected_input_node();
      if (input) {
        const variable_name = attributeNode.attributeName();
        this.add_export_body_line(
          attributeNode,
          attributeNode.inputName(),
          input,
          variable_name,
          linesController
        );
      }
    }
  }
  set_node_lines_globals(globals_node, linesController) {
    for (let outputName of globals_node.io.outputs.used_output_names()) {
      switch (outputName) {
        case "time": {
          this._handleGlobalsUniform(globals_node, outputName, linesController);
          break;
        }
        case "timeDelta": {
          this._handleGlobalsUniform(globals_node, outputName, linesController);
          break;
        }
        case "position": {
          this._handleGlobalsPosition(globals_node, outputName, linesController);
          break;
        }
        default: {
          this._handleGlobalsPosition(globals_node, outputName, linesController);
          break;
        }
      }
    }
  }
  _handleGlobalsUniform(globalsNode, outputName, linesController) {
    const varName = globalsNode.glVarName(outputName);
    const bodyLine = `float ${varName} = ${outputName}`;
    linesController.addBodyLines(globalsNode, [bodyLine]);
    this.setUniformsTimeDependent();
  }
  _handleGlobalsPosition(globalsNode, outputName, linesController) {
    const output_connection_point = globalsNode.io.outputs.namedOutputConnectionPointsByName(outputName);
    if (output_connection_point) {
      const glType = output_connection_point.type();
      const attribRead = "position";
      if (attribRead) {
        const varName = globalsNode.glVarName(outputName);
        const bodyLine = `${glType} ${varName} = ${attribRead}`;
        linesController.addBodyLines(globalsNode, [bodyLine]);
      }
    }
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/gl/code/assemblers/materials/Lambert.ts




class ShaderAssemblerLambert extends ShaderAssemblerMesh {
  templateShader() {
    const template = three_module.ShaderLib.lambert;
    return {
      vertexShader: template.vertexShader,
      fragmentShader: template.fragmentShader,
      uniforms: template.uniforms
    };
  }
  createMaterial() {
    const material = new three_module.MeshLambertMaterial();
    this._addCustomMaterials(material);
    return material;
  }
}

// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/nodes/gl/code/configs/ShaderConfig.ts
var configs_ShaderConfig = __webpack_require__(23758);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/nodes/gl/code/configs/VariableConfig.ts
var VariableConfig = __webpack_require__(60466);
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/gl/code/templates/custom/line/CustomLineDepth.vert.glsl
/* harmony default export */ var CustomLineDepth_vert = ("\nuniform float scale;\nattribute float lineDistance;\n\nvarying float vLineDistance;\n\n\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\n\n// INSERT DEFINES\n\n\n// vHighPrecisionZW is added to match CustomMeshDepth.frag\n// which is itself taken from threejs\nvarying vec2 vHighPrecisionZW;\n\n\nvoid main() {\n\n\t// INSERT BODY\n\n\n\tvLineDistance = scale * lineDistance;\n\n\t#include <color_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n\n\n\tvHighPrecisionZW = gl_Position.zw;\n}\n");
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/gl/code/assemblers/materials/custom/line/CustomLineDepth.ts






const INSERT_DEFINE_AFTER_MAP = /* @__PURE__ */ new Map([
  [ShaderName/* ShaderName.VERTEX */.k.VERTEX, "// INSERT DEFINES"],
  [ShaderName/* ShaderName.FRAGMENT */.k.FRAGMENT, "// INSERT DEFINES"]
]);
const CustomLineDepth_INSERT_BODY_AFTER_MAP = /* @__PURE__ */ new Map([
  [ShaderName/* ShaderName.VERTEX */.k.VERTEX, "// INSERT BODY"],
  [ShaderName/* ShaderName.FRAGMENT */.k.FRAGMENT, "// INSERT BODY"]
]);
const LINES_TO_REMOVE_MAP = /* @__PURE__ */ new Map([
  [ShaderName/* ShaderName.VERTEX */.k.VERTEX, ["#include <begin_vertex>", "#include <project_vertex>"]],
  [ShaderName/* ShaderName.FRAGMENT */.k.FRAGMENT, []]
]);
class ShaderAssemblerCustomLineDepth extends ShaderAssemblerMaterial {
  // _color_declaration() { return 'vec4 diffuseColor' }
  // _template_shader(){ return ShaderLib.standard }
  templateShader() {
    const template = three_module.ShaderLib.depth;
    const uniforms = three_module.UniformsUtils.clone(template.uniforms);
    return {
      vertexShader: CustomLineDepth_vert,
      fragmentShader: CustomMeshDepth_frag,
      uniforms
    };
  }
  insertDefineAfter(shader_name) {
    return INSERT_DEFINE_AFTER_MAP.get(shader_name);
  }
  insertBodyAfter(shader_name) {
    return CustomLineDepth_INSERT_BODY_AFTER_MAP.get(shader_name);
  }
  linesToRemove(shader_name) {
    return LINES_TO_REMOVE_MAP.get(shader_name);
  }
  depthPacking() {
    return three_module.RGBADepthPacking;
  }
  createMaterial() {
    const template_shader = this.templateShader();
    return new three_module.ShaderMaterial({
      // vertexColors: VertexColors,
      // side: FrontSide,
      // transparent: true,
      // fog: true,
      // lights: true,
      defines: {
        DEPTH_PACKING: this.depthPacking()
      },
      uniforms: three_module.UniformsUtils.clone(template_shader.uniforms),
      vertexShader: template_shader.vertexShader,
      fragmentShader: template_shader.fragmentShader
    });
  }
}
class ShaderAssemblerCustomLineDepthForRender extends ShaderAssemblerCustomLineDepth {
  depthPacking() {
    return three_module.BasicDepthPacking;
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/gl/code/templates/custom/line/CustomLineDistance.vert.glsl
/* harmony default export */ var CustomLineDistance_vert = ("\nuniform float scale;\nattribute float lineDistance;\n\nvarying float vLineDistance;\n\n#define DISTANCE\nvarying vec3 vWorldPosition;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\n\n// INSERT DEFINES\n\n\n// vHighPrecisionZW is added to match CustomMeshDepth.frag\n// which is itself taken from threejs\nvarying vec2 vHighPrecisionZW;\n\n\nvoid main() {\n\n\t// INSERT BODY\n\n\n\tvLineDistance = scale * lineDistance;\n\n\t#include <color_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n\n\n\tvHighPrecisionZW = gl_Position.zw;\n}\n");
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/gl/code/assemblers/materials/custom/line/CustomLineDistance.ts










const CustomLineDistance_INSERT_DEFINE_AFTER_MAP = /* @__PURE__ */ new Map([
  [ShaderName/* ShaderName.VERTEX */.k.VERTEX, "// INSERT DEFINES"],
  [ShaderName/* ShaderName.FRAGMENT */.k.FRAGMENT, "// INSERT DEFINES"]
]);
const CustomLineDistance_INSERT_BODY_AFTER_MAP = /* @__PURE__ */ new Map([
  [ShaderName/* ShaderName.VERTEX */.k.VERTEX, "// INSERT BODY"],
  [ShaderName/* ShaderName.FRAGMENT */.k.FRAGMENT, "// INSERT BODY"]
]);
const CustomLineDistance_LINES_TO_REMOVE_MAP = /* @__PURE__ */ new Map([
  [ShaderName/* ShaderName.VERTEX */.k.VERTEX, ["#include <begin_vertex>", "#include <project_vertex>"]],
  [ShaderName/* ShaderName.FRAGMENT */.k.FRAGMENT, []]
]);
class ShaderAssemblerCustomLineDistance extends ShaderAssemblerMaterial {
  templateShader() {
    const template = three_module.ShaderLib.distanceRGBA;
    const uniforms = three_module.UniformsUtils.clone(template.uniforms);
    return {
      vertexShader: CustomLineDistance_vert,
      fragmentShader: CustomMeshDistance_frag,
      uniforms
    };
  }
  insertDefineAfter(shader_name) {
    return CustomLineDistance_INSERT_DEFINE_AFTER_MAP.get(shader_name);
  }
  insertBodyAfter(shader_name) {
    return CustomLineDistance_INSERT_BODY_AFTER_MAP.get(shader_name);
  }
  linesToRemove(shader_name) {
    return CustomLineDistance_LINES_TO_REMOVE_MAP.get(shader_name);
  }
  createMaterial() {
    const template_shader = this.templateShader();
    return new three_module.ShaderMaterial({
      // vertexColors: VertexColors,
      // side: FrontSide,
      // transparent: true,
      // fog: true,
      // lights: true,
      defines: {
        USE_SIZEATTENUATION: 1,
        DEPTH_PACKING: [three_module.RGBADepthPacking, three_module.BasicDepthPacking][0]
      },
      uniforms: three_module.UniformsUtils.clone(template_shader.uniforms),
      vertexShader: template_shader.vertexShader,
      fragmentShader: template_shader.fragmentShader
    });
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/gl/code/assemblers/materials/custom/line/CustomLineDepthDOF.ts


const ShaderAssemblerCustomLineDepthDOF = ShaderAssemblerCustomLineDepthForRender;

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/gl/code/assemblers/materials/Line.ts














const Line_ASSEMBLER_MAP = /* @__PURE__ */ new Map([]);
Line_ASSEMBLER_MAP.set(geometry_Material/* CustomMaterialName.DISTANCE */.RJ.DISTANCE, ShaderAssemblerCustomLineDistance);
Line_ASSEMBLER_MAP.set(geometry_Material/* CustomMaterialName.DEPTH */.RJ.DEPTH, ShaderAssemblerCustomLineDepth);
Line_ASSEMBLER_MAP.set(geometry_Material/* CustomMaterialName.DEPTH_DOF */.RJ.DEPTH_DOF, ShaderAssemblerCustomLineDepthDOF);
const Line_LINES_TO_REMOVE_MAP = /* @__PURE__ */ new Map([
  [ShaderName/* ShaderName.VERTEX */.k.VERTEX, ["#include <begin_vertex>", "#include <project_vertex>"]],
  [ShaderName/* ShaderName.FRAGMENT */.k.FRAGMENT, []]
]);
class ShaderAssemblerLine extends ShaderAssemblerMaterial {
  // _color_declaration() { return 'diffuseColor' }
  templateShader() {
    const template = three_module.ShaderLib.dashed;
    return {
      vertexShader: template.vertexShader,
      //TemplateVertex,
      fragmentShader: template.fragmentShader,
      //TemplateFragment,
      uniforms: template.uniforms
    };
  }
  createMaterial() {
    const material = new three_module.LineBasicMaterial();
    this._addCustomMaterials(material);
    return material;
  }
  customAssemblerClassByCustomName() {
    return Line_ASSEMBLER_MAP;
  }
  create_shader_configs() {
    return [
      new configs_ShaderConfig/* ShaderConfig */.E(ShaderName/* ShaderName.VERTEX */.k.VERTEX, ["position", "uv", VaryingWrite/* VaryingWriteGlNode.INPUT_NAME */.N.INPUT_NAME], []),
      new configs_ShaderConfig/* ShaderConfig */.E(ShaderName/* ShaderName.FRAGMENT */.k.FRAGMENT, ["color", "alpha"], [ShaderName/* ShaderName.VERTEX */.k.VERTEX])
    ];
  }
  static output_input_connection_points() {
    return [
      new Gl/* GlConnectionPoint */.E("position", Gl/* GlConnectionPointType.VEC3 */.Dv.VEC3),
      new Gl/* GlConnectionPoint */.E("color", Gl/* GlConnectionPointType.VEC3 */.Dv.VEC3),
      new Gl/* GlConnectionPoint */.E("alpha", Gl/* GlConnectionPointType.FLOAT */.Dv.FLOAT),
      new Gl/* GlConnectionPoint */.E("uv", Gl/* GlConnectionPointType.VEC2 */.Dv.VEC2)
    ];
  }
  add_output_inputs(output_child) {
    output_child.io.inputs.setNamedInputConnectionPoints(ShaderAssemblerLine.output_input_connection_points());
  }
  static create_globals_node_output_connections() {
    return [
      new Gl/* GlConnectionPoint */.E("position", Gl/* GlConnectionPointType.VEC3 */.Dv.VEC3),
      // new Connection.Vec3('normal'),
      new Gl/* GlConnectionPoint */.E("color", Gl/* GlConnectionPointType.VEC3 */.Dv.VEC3),
      new Gl/* GlConnectionPoint */.E("uv", Gl/* GlConnectionPointType.VEC2 */.Dv.VEC2),
      new Gl/* GlConnectionPoint */.E("gl_FragCoord", Gl/* GlConnectionPointType.VEC4 */.Dv.VEC4),
      new Gl/* GlConnectionPoint */.E("resolution", Gl/* GlConnectionPointType.VEC2 */.Dv.VEC2),
      // new Connection.Vec2('gl_PointCoord'),
      // new TypedConnectionVec2('uv'),
      new Gl/* GlConnectionPoint */.E("time", Gl/* GlConnectionPointType.FLOAT */.Dv.FLOAT)
    ];
  }
  create_globals_node_output_connections() {
    return ShaderAssemblerLine.create_globals_node_output_connections();
  }
  create_variable_configs() {
    return [
      new VariableConfig/* VariableConfig */.P("position", {
        default: "vec3( position )",
        prefix: "vec3 transformed = ",
        suffix: ";vec4 mvPosition = vec4( transformed, 1.0 ); gl_Position = projectionMatrix * modelViewMatrix * mvPosition;"
      }),
      // new VariableConfig('normal', {
      // 	prefix: 'objectNormal = '
      // }),
      new VariableConfig/* VariableConfig */.P("color", {
        prefix: "diffuseColor.xyz = "
      }),
      new VariableConfig/* VariableConfig */.P("alpha", {
        prefix: "diffuseColor.w = "
      }),
      new VariableConfig/* VariableConfig */.P("uv", {
        // default_from_attribute: true,
        prefix: "vUv = ",
        if: Geometry/* GlobalsGeometryHandler.IF_RULE.uv */.f.IF_RULE.uv
      })
    ];
  }
  linesToRemove(shader_name) {
    return Line_LINES_TO_REMOVE_MAP.get(shader_name);
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/gl/code/templates/particles/Default.glsl
/* harmony default export */ var particles_Default = ("#include <common>\n\n// INSERT DEFINE\n\nvoid main() {\n\n\tvec2 particleUv = (gl_FragCoord.xy / resolution.xy);\n\n\t// INSERT BODY\n\n}");
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/gl/code/assemblers/particles/Particles.ts











class ShaderAssemblerParticles extends assemblers_Base/* BaseGlShaderAssembler */.X {
  templateShader() {
    return void 0;
  }
  _template_shader_for_shader_name(shader_name) {
    return particles_Default;
  }
  // async get_shaders(){
  // 	await this.update_shaders()
  // 	return this._shaders_by_name
  // }
  compile() {
    this.setup_shader_names_and_variables();
    this._updateShaders();
  }
  rootNodesByShaderName(shader_name, rootNodes) {
    var _a, _b;
    const list = [];
    for (const node of rootNodes) {
      switch (node.type()) {
        case gl_SubnetOutput/* SubnetOutputGlNode.type */.U.type():
        case Output/* OutputGlNode.type */.H.type(): {
          list.push(node);
          break;
        }
        case Attribute/* AttributeGlNode.type */.W.type(): {
          const attrib_name = node.attributeName();
          const variable = (_a = this._textureAllocationsController) == null ? void 0 : _a.variable(attrib_name);
          if (variable && variable.allocation()) {
            const allocation_shader_name = (_b = variable.allocation()) == null ? void 0 : _b.shaderName();
            if (allocation_shader_name == shader_name) {
              list.push(node);
            }
          }
          break;
        }
      }
    }
    return list;
  }
  // override leaf_nodes_by_shader_name(shader_name: ShaderName): BaseGlNodeType[] {
  // 	const list = [];
  // 	for (let node of this._leaf_nodes) {
  // 		switch (node.type()) {
  // 			case GlobalsGlNode.type(): {
  // 				list.push(node);
  // 				break;
  // 			}
  // 			case AttributeGlNode.type(): {
  // 				const attrib_name: string = (node as AttributeGlNode).attributeName();
  // 				const variable = this._textureAllocationsController?.variable(attrib_name);
  // 				if (variable && variable.allocation()) {
  // 					const allocation_shader_name = variable.allocation()?.shaderName();
  // 					if (allocation_shader_name == shader_name) {
  // 						list.push(node);
  // 					}
  // 				}
  // 				break;
  // 			}
  // 		}
  // 	}
  // 	return list;
  // }
  setup_shader_names_and_variables() {
    var _a;
    const node_traverser_shallow = new GlNodeTraverser(
      this.currentGlParentNode(),
      this.shaderNames(),
      (root_node, shader_name) => {
        return this.inputNamesForShaderName(root_node, shader_name);
      }
    );
    const node_traverser_deep = new GlNodeTraverser(
      this.currentGlParentNode(),
      this.shaderNames(),
      (root_node, shader_name) => {
        return this.inputNamesForShaderName(root_node, shader_name);
      },
      { traverseChildren: true }
    );
    this._leaf_nodes = node_traverser_shallow.leavesFromNodes(this._root_nodes);
    const leafNodesForTextureAllocations = node_traverser_deep.leavesFromNodes(this._root_nodes);
    this._textureAllocationsController = new TextureAllocationsController/* TextureAllocationsController */.T();
    this._textureAllocationsController.allocateConnectionsFromRootNodes(
      this._root_nodes,
      leafNodesForTextureAllocations
    );
    if (this.globalsHandler()) {
      (_a = this.globalsHandler()) == null ? void 0 : _a.set_texture_allocations_controller(
        this._textureAllocationsController
      );
    }
    this._reset_shader_configs();
  }
  _updateShaders() {
    this._shaders_by_name.clear();
    this._lines.clear();
    for (const shader_name of this.shaderNames()) {
      const template = this._template_shader_for_shader_name(shader_name);
      this._lines.set(shader_name, template.split("\n"));
    }
    if (this._root_nodes.length > 0) {
      this._resetCodeBuilder();
      this.buildCodeFromNodes(this._root_nodes);
      this._buildLines();
    }
    for (const shader_name of this.shaderNames()) {
      const lines = this._lines.get(shader_name);
      if (lines) {
        this._shaders_by_name.set(shader_name, lines.join("\n"));
      }
    }
  }
  //
  //
  // CHILDREN NODES PARAMS
  //
  //
  add_output_inputs(output_child) {
    output_child.io.inputs.setNamedInputConnectionPoints([
      new Gl/* GlConnectionPoint */.E("position", Gl/* GlConnectionPointType.VEC3 */.Dv.VEC3),
      new Gl/* GlConnectionPoint */.E("velocity", Gl/* GlConnectionPointType.VEC3 */.Dv.VEC3)
    ]);
  }
  add_globals_outputs(globals_node) {
    globals_node.io.outputs.setNamedOutputConnectionPoints([
      new Gl/* GlConnectionPoint */.E("position", Gl/* GlConnectionPointType.VEC3 */.Dv.VEC3),
      new Gl/* GlConnectionPoint */.E("velocity", Gl/* GlConnectionPointType.VEC3 */.Dv.VEC3),
      // new TypedNamedConnectionPoint('acceleration', ConnectionPointType.VEC3),
      new Gl/* GlConnectionPoint */.E("time", Gl/* GlConnectionPointType.FLOAT */.Dv.FLOAT)
    ]);
  }
  allow_attribute_exports() {
    return true;
  }
  textureAllocationsController() {
    return this._textureAllocationsController = this._textureAllocationsController || new TextureAllocationsController/* TextureAllocationsController */.T();
  }
  //
  //
  // CONFIGS
  //
  //
  create_shader_configs() {
    var _a;
    return ((_a = this._textureAllocationsController) == null ? void 0 : _a.createShaderConfigs()) || [];
  }
  create_variable_configs() {
    return [
      // new VariableConfig('position', {
      // 	default: 'vec3( position )',
      // 	prefix: 'vec3 transformed = '
      // }),
    ];
  }
  shaderNames() {
    return this.textureAllocationsController().shaderNames() || [];
  }
  inputNamesForShaderName(root_node, shader_name) {
    return this.textureAllocationsController().inputNamesForShaderName(root_node, shader_name) || [];
  }
  //
  //
  // TEMPLATE HOOKS
  //
  //
  insertDefineAfter(shader_name) {
    return "// INSERT DEFINE";
  }
  insertBodyAfter(shader_name) {
    return "// INSERT BODY";
  }
  linesToRemove(shader_name) {
    return ["// INSERT DEFINE", "// INSERT BODY"];
  }
  //
  //
  // TEMPLATE CODE REPLACEMENT
  //
  //
  add_export_body_line(export_node, input_name, input, variable_name, shaders_collection_controller) {
    var _a;
    if (input) {
      const var_input = export_node.variableForInput(input_name);
      const new_var = ThreeToGl/* ThreeToGl.vector3 */._.vector3(var_input);
      if (new_var) {
        const texture_variable = this.textureAllocationsController().variable(variable_name);
        const shader_name = shaders_collection_controller.currentShaderName();
        if (texture_variable && ((_a = texture_variable.allocation()) == null ? void 0 : _a.shaderName()) == shader_name) {
          const component = texture_variable.component();
          const line = `gl_FragColor.${component} = ${new_var}`;
          shaders_collection_controller.addBodyLines(export_node, [line], shader_name);
        }
      }
    }
  }
  set_node_lines_output(output_node, shaders_collection_controller) {
    const shader_name = shaders_collection_controller.currentShaderName();
    const input_names = this.textureAllocationsController().inputNamesForShaderName(output_node, shader_name);
    if (input_names) {
      for (const input_name of input_names) {
        const input = output_node.io.inputs.named_input(input_name);
        if (input) {
          const variable_name = input_name;
          this.add_export_body_line(
            output_node,
            input_name,
            input,
            variable_name,
            shaders_collection_controller
          );
        } else {
        }
      }
    }
  }
  setNodeLinesAttribute(attribute_node, shaders_collection_controller) {
    var _a, _b;
    if (attribute_node.isImporting()) {
      const gl_type = attribute_node.glType();
      const attribute_name = attribute_node.attributeName();
      const new_value = (_a = this.globalsHandler()) == null ? void 0 : _a.readAttribute(
        attribute_node,
        gl_type,
        attribute_name,
        shaders_collection_controller
      );
      const var_name = attribute_node.glVarName(attribute_node.outputName());
      const body_line = `${gl_type} ${var_name} = ${new_value}`;
      shaders_collection_controller.addBodyLines(attribute_node, [body_line]);
      const texture_variable = this.textureAllocationsController().variable(attribute_name);
      const shader_name = shaders_collection_controller.currentShaderName();
      if (texture_variable && ((_b = texture_variable.allocation()) == null ? void 0 : _b.shaderName()) == shader_name) {
        const variable = this.textureAllocationsController().variable(attribute_name);
        if (variable) {
          const component = variable.component();
          const body_line2 = `gl_FragColor.${component} = ${var_name}`;
          shaders_collection_controller.addBodyLines(attribute_node, [body_line2]);
        }
      }
    }
    if (attribute_node.isExporting()) {
      const input = attribute_node.connected_input_node();
      if (input) {
        const variable_name = attribute_node.attributeName();
        this.add_export_body_line(
          attribute_node,
          attribute_node.inputName(),
          input,
          variable_name,
          shaders_collection_controller
        );
      }
    }
  }
  set_node_lines_globals(globals_node, shaders_collection_controller) {
    for (const output_name of globals_node.io.outputs.used_output_names()) {
      switch (output_name) {
        case "time":
          this._handle_globals_time(globals_node, output_name, shaders_collection_controller);
          break;
        default:
          this._handle_globals_default(globals_node, output_name, shaders_collection_controller);
      }
    }
  }
  _handle_globals_time(globals_node, output_name, shaders_collection_controller) {
    const definition = new GLDefinition/* UniformGLDefinition */.oA(globals_node, Gl/* GlConnectionPointType.FLOAT */.Dv.FLOAT, output_name);
    shaders_collection_controller.addDefinitions(globals_node, [definition]);
    const var_name = globals_node.glVarName(output_name);
    const body_line = `float ${var_name} = ${output_name}`;
    shaders_collection_controller.addBodyLines(globals_node, [body_line]);
    this.setUniformsTimeDependent();
  }
  _handle_globals_default(globals_node, output_name, shaders_collection_controller) {
    var _a;
    const output_connection_point = globals_node.io.outputs.namedOutputConnectionPointsByName(output_name);
    if (output_connection_point) {
      const gl_type = output_connection_point.type();
      const attrib_read = (_a = this.globalsHandler()) == null ? void 0 : _a.readAttribute(
        globals_node,
        gl_type,
        output_name,
        shaders_collection_controller
      );
      if (attrib_read) {
        const var_name = globals_node.glVarName(output_name);
        const body_line = `${gl_type} ${var_name} = ${attrib_read}`;
        shaders_collection_controller.addBodyLines(globals_node, [body_line]);
      }
    }
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/gl/code/assemblers/materials/Phong.ts




class ShaderAssemblerPhong extends ShaderAssemblerMesh {
  templateShader() {
    const template = three_module.ShaderLib.phong;
    return {
      vertexShader: template.vertexShader,
      fragmentShader: template.fragmentShader,
      uniforms: template.uniforms
    };
  }
  createMaterial() {
    const material = new three_module.MeshPhongMaterial();
    this._addCustomMaterials(material);
    return material;
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/gl/gl/ShaderLib/ShaderChunk/metalnessmap_fragment.glsl
/* harmony default export */ var metalnessmap_fragment = ("float metalnessFactor = metalness * POLY_metalness;\n\n#ifdef USE_METALNESSMAP\n\n\tvec4 texelMetalness = texture2D( metalnessMap, vUv );\n\n\t// reads channel B, compatible with a combined OcclusionRoughnessMetallic (RGB) texture\n\tmetalnessFactor *= texelMetalness.b;\n\n#endif\n");
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/gl/gl/ShaderLib/ShaderChunk/roughnessmap_fragment.glsl
/* harmony default export */ var roughnessmap_fragment = ("float roughnessFactor = roughness * POLY_roughness;\n\n#ifdef USE_ROUGHNESSMAP\n\n\tvec4 texelRoughness = texture2D( roughnessMap, vUv );\n\n\t// reads channel G, compatible with a combined OcclusionRoughnessMetallic (RGB) texture\n\troughnessFactor *= texelRoughness.g;\n\n#endif\n");
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/gl/gl/sss/init.glsl
/* harmony default export */ var init = ("SSSModel(/*isActive*/false,/*color*/vec3(1.0, 1.0, 1.0), /*thickness*/0.1, /*power*/2.0, /*scale*/16.0, /*distortion*/0.1,/*ambient*/0.4,/*attenuation*/0.8 )");
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/gl/code/assemblers/materials/Standard.ts














const _ShaderAssemblerStandard = class extends ShaderAssemblerMesh {
  constructor(_gl_parent_node) {
    super(_gl_parent_node);
    this._gl_parent_node = _gl_parent_node;
    this._addFilterFragmentShaderCallback(
      "MeshStandardBuilderMatNode",
      _ShaderAssemblerStandard.filterFragmentShader
    );
  }
  isPhysical() {
    return false;
  }
  templateShader() {
    const template = this.isPhysical() ? three_module.ShaderLib.physical : three_module.ShaderLib.standard;
    return {
      vertexShader: template.vertexShader,
      fragmentShader: template.fragmentShader,
      uniforms: template.uniforms
    };
  }
  static filterFragmentShader(fragmentShader) {
    fragmentShader = fragmentShader.replace("#include <metalnessmap_fragment>", metalnessmap_fragment);
    fragmentShader = fragmentShader.replace("#include <roughnessmap_fragment>", roughnessmap_fragment);
    fragmentShader = fragmentShader.replace(
      "vec3 totalEmissiveRadiance = emissive;",
      "vec3 totalEmissiveRadiance = emissive * POLY_emissive;"
    );
    fragmentShader = includeSSSDeclarations(fragmentShader);
    return fragmentShader;
  }
  createMaterial() {
    const material = new three_module.MeshStandardMaterial();
    this._addCustomMaterials(material);
    return material;
  }
  add_output_inputs(output_child) {
    const list = assemblers_Base/* BaseGlShaderAssembler.output_input_connection_points */.X.output_input_connection_points();
    list.push(new Gl/* GlConnectionPoint */.E("metalness", Gl/* GlConnectionPointType.FLOAT */.Dv.FLOAT, 1));
    list.push(new Gl/* GlConnectionPoint */.E("roughness", Gl/* GlConnectionPointType.FLOAT */.Dv.FLOAT, 1));
    list.push(new Gl/* GlConnectionPoint */.E("emissive", Gl/* GlConnectionPointType.VEC3 */.Dv.VEC3, [1, 1, 1]));
    if (_ShaderAssemblerStandard.USE_SSS) {
      list.push(new Gl/* GlConnectionPoint */.E("SSSModel", Gl/* GlConnectionPointType.SSS_MODEL */.Dv.SSS_MODEL, init));
    }
    if (this.isPhysical()) {
      list.push(new Gl/* GlConnectionPoint */.E("transmission", Gl/* GlConnectionPointType.FLOAT */.Dv.FLOAT, 1));
      list.push(new Gl/* GlConnectionPoint */.E("thickness", Gl/* GlConnectionPointType.FLOAT */.Dv.FLOAT, 1));
    }
    output_child.io.inputs.setNamedInputConnectionPoints(list);
  }
  create_shader_configs() {
    const fragmentInputNames = ["color", "alpha", "metalness", "roughness", "emissive", "SSSModel"];
    if (this.isPhysical()) {
      fragmentInputNames.push("transmission");
      fragmentInputNames.push("thickness");
    }
    return [
      new configs_ShaderConfig/* ShaderConfig */.E(ShaderName/* ShaderName.VERTEX */.k.VERTEX, ["position", "normal", "uv", VaryingWrite/* VaryingWriteGlNode.INPUT_NAME */.N.INPUT_NAME], []),
      new configs_ShaderConfig/* ShaderConfig */.E(ShaderName/* ShaderName.FRAGMENT */.k.FRAGMENT, fragmentInputNames, [ShaderName/* ShaderName.VERTEX */.k.VERTEX])
    ];
  }
  create_variable_configs() {
    const list = assemblers_Base/* BaseGlShaderAssembler.create_variable_configs */.X.create_variable_configs();
    list.push(
      new VariableConfig/* VariableConfig */.P("metalness", {
        default: "1.0",
        prefix: "float POLY_metalness = "
      })
    );
    list.push(
      new VariableConfig/* VariableConfig */.P("roughness", {
        default: "1.0",
        prefix: "float POLY_roughness = "
      })
    );
    list.push(
      new VariableConfig/* VariableConfig */.P("emissive", {
        default: "vec3(1.0, 1.0, 1.0)",
        prefix: "vec3 POLY_emissive = "
      })
    );
    if (_ShaderAssemblerStandard.USE_SSS) {
      list.push(
        new VariableConfig/* VariableConfig */.P("SSSModel", {
          default: init,
          prefix: "SSSModel POLY_SSSModel = "
        })
      );
    }
    if (this.isPhysical()) {
      list.push(
        new VariableConfig/* VariableConfig */.P("transmission", {
          default: "1.0",
          prefix: "float POLY_transmission = "
        })
      );
      list.push(
        new VariableConfig/* VariableConfig */.P("thickness", {
          default: "1.0",
          prefix: "float POLY_thickness = "
        })
      );
    }
    return list;
  }
};
let ShaderAssemblerStandard = _ShaderAssemblerStandard;
ShaderAssemblerStandard.USE_SSS = true;

// EXTERNAL MODULE: ../@polygonjs/polygonjs/node_modules/three/src/renderers/shaders/ShaderChunk/transmission_fragment.glsl.js
var transmission_fragment_glsl = __webpack_require__(86594);
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/gl/code/assemblers/materials/Physical.ts




function addPolyTransmission(fragment) {
  const transmission = "material.transmission = transmission;";
  const thickness = "material.thickness = thickness;";
  const lines = fragment.split("\n");
  let cmptr = 0;
  for (let line of lines) {
    if (line.includes(transmission)) {
      line = line.replace(transmission, "material.transmission = transmission * POLY_transmission;");
      lines[cmptr] = line;
    }
    if (line.includes(thickness)) {
      line = line.replace(thickness, "material.thickness = thickness * POLY_thickness;");
      lines[cmptr] = line;
    }
    cmptr++;
  }
  return lines.join("\n");
}
class ShaderAssemblerPhysical extends ShaderAssemblerStandard {
  constructor(_gl_parent_node) {
    super(_gl_parent_node);
    this._gl_parent_node = _gl_parent_node;
    this._addFilterFragmentShaderCallback(
      "MeshPhysicalBuilderMatNode",
      ShaderAssemblerPhysical.filterFragmentShader
    );
  }
  isPhysical() {
    return true;
  }
  static filterFragmentShader(fragmentShader) {
    fragmentShader = fragmentShader.replace(
      "#include <transmission_fragment>",
      addPolyTransmission(transmission_fragment_glsl/* default */.Z)
    );
    return fragmentShader;
  }
  createMaterial() {
    const material = new three_module.MeshPhysicalMaterial();
    this._addCustomMaterials(material);
    return material;
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/gl/code/templates/custom/points/CustomPointsDepth.vert.glsl
/* harmony default export */ var CustomPointsDepth_vert = ("\nuniform float size;\nuniform float scale;\n#include <common>\n#include <clipping_planes_pars_vertex>\nvarying float vViewZDepth;\n\n// INSERT DEFINES\n\n\n// vHighPrecisionZW is added to match CustomMeshDepth.frag\n// which is itself taken from threejs\nvarying vec2 vHighPrecisionZW;\n\nvoid main() {\n\n\t// INSERT BODY\n\n\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\n\tvViewZDepth = - mvPosition.z;\n\t#ifdef USE_SIZEATTENUATION\n\t\tbool isPerspective = ( projectionMatrix[ 2 ][ 3 ] == - 1.0 );\n\t\tif ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );\n\t#endif\n\n\tvHighPrecisionZW = gl_Position.zw;\n\n}\n");
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/gl/code/assemblers/materials/custom/points/CustomPointsDepth.ts










const CustomPointsDepth_INSERT_DEFINE_AFTER_MAP = /* @__PURE__ */ new Map([
  [ShaderName/* ShaderName.VERTEX */.k.VERTEX, "// INSERT DEFINES"],
  [ShaderName/* ShaderName.FRAGMENT */.k.FRAGMENT, "// INSERT DEFINES"]
]);
const CustomPointsDepth_INSERT_BODY_AFTER_MAP = /* @__PURE__ */ new Map([
  [ShaderName/* ShaderName.VERTEX */.k.VERTEX, "// INSERT BODY"],
  [ShaderName/* ShaderName.FRAGMENT */.k.FRAGMENT, "// INSERT BODY"]
]);
class ShaderAssemblerCustomPointsDepth extends ShaderAssemblerMaterial {
  // _color_declaration() { return 'vec4 diffuseColor' }
  // _template_shader(){ return ShaderLib.standard }
  templateShader() {
    const template = three_module.ShaderLib.depth;
    const uniforms = three_module.UniformsUtils.clone(template.uniforms);
    uniforms["size"] = { value: 1 };
    uniforms["scale"] = { value: 1 };
    return {
      vertexShader: CustomPointsDepth_vert,
      fragmentShader: CustomMeshDepth_frag,
      uniforms
    };
  }
  insertDefineAfter(shader_name) {
    return CustomPointsDepth_INSERT_DEFINE_AFTER_MAP.get(shader_name);
  }
  insertBodyAfter(shader_name) {
    return CustomPointsDepth_INSERT_BODY_AFTER_MAP.get(shader_name);
  }
  depthPacking() {
    return three_module.RGBADepthPacking;
  }
  createMaterial() {
    const template_shader = this.templateShader();
    return new three_module.ShaderMaterial({
      // vertexColors: VertexColors,
      // side: FrontSide,
      // transparent: true,
      // fog: true,
      // lights: true,
      defines: {
        USE_SIZEATTENUATION: 1,
        DEPTH_PACKING: this.depthPacking()
      },
      uniforms: three_module.UniformsUtils.clone(template_shader.uniforms),
      vertexShader: template_shader.vertexShader,
      fragmentShader: template_shader.fragmentShader
    });
  }
}
class ShaderAssemblerCustomPointsDepthForRender extends ShaderAssemblerCustomPointsDepth {
  depthPacking() {
    return three_module.BasicDepthPacking;
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/gl/code/assemblers/materials/custom/points/CustomPointsDistance.ts


const ShaderAssemblerCustomPointsDistance = ShaderAssemblerCustomPointsDepthForRender;

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/gl/code/templates/custom/points/CustomPointsDepthDOF.vert.glsl
/* harmony default export */ var CustomPointsDepthDOF_vert = ("\nuniform float size;\nuniform float scale;\n#include <common>\n\nvarying float vViewZDepth;\n\n// INSERT DEFINES\n\n\n\nvoid main() {\n\n\t// INSERT BODY\n\n\n\t#include <project_vertex>\n\n\tvViewZDepth = - mvPosition.z;\n\t#ifdef USE_SIZEATTENUATION\n\t\tbool isPerspective = ( projectionMatrix[ 2 ][ 3 ] == - 1.0 );\n\t\tif ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );\n\t#endif\n\n}\n");
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/gl/code/templates/custom/mesh/CustomMeshDepthDOF.frag.glsl
/* harmony default export */ var CustomMeshDepthDOF_frag = ("\nuniform float mNear;\nuniform float mFar;\n\nvarying float vViewZDepth;\n\n// INSERT DEFINES\n\nvoid main() {\n\n\tfloat color = 1.0 - smoothstep( mNear, mFar, vViewZDepth );\n\tgl_FragColor = vec4( vec3( color ), 1.0 );\n\tvec4 diffuseColor = gl_FragColor;\n\n\t// INSERT BODY\n\n\tgl_FragColor.a = diffuseColor.a;\n}\n");
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/gl/code/assemblers/materials/custom/points/CustomPointsDepthDOF.ts







const CustomPointsDepthDOF_INSERT_DEFINE_AFTER_MAP = /* @__PURE__ */ new Map([[ShaderName/* ShaderName.VERTEX */.k.VERTEX, "// INSERT DEFINES"]]);
const CustomPointsDepthDOF_INSERT_BODY_AFTER_MAP = /* @__PURE__ */ new Map([[ShaderName/* ShaderName.VERTEX */.k.VERTEX, "// INSERT BODY"]]);
class ShaderAssemblerCustomPointsDepthDOF extends ShaderAssemblerMaterial {
  // _color_declaration() { return 'vec4 diffuseColor' }
  // _template_shader(){ return ShaderLib.standard }
  templateShader() {
    return {
      vertexShader: CustomPointsDepthDOF_vert,
      fragmentShader: CustomMeshDepthDOF_frag,
      uniforms: {
        size: { value: 1 },
        scale: { value: 1 },
        mNear: { value: 0 },
        mFar: { value: 10 }
      }
    };
  }
  insertDefineAfter(shader_name) {
    return CustomPointsDepthDOF_INSERT_DEFINE_AFTER_MAP.get(shader_name);
  }
  insertBodyAfter(shader_name) {
    return CustomPointsDepthDOF_INSERT_BODY_AFTER_MAP.get(shader_name);
  }
  createMaterial() {
    const template_shader = this.templateShader();
    return new three_module.ShaderMaterial({
      // defines: {
      // 	DEPTH_PACKING: [RGBADepthPacking, BasicDepthPacking][0]
      // },
      depthTest: true,
      defines: {
        USE_SIZEATTENUATION: 1
      },
      uniforms: three_module.UniformsUtils.clone(template_shader.uniforms),
      vertexShader: template_shader.vertexShader,
      fragmentShader: template_shader.fragmentShader
    });
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/gl/code/assemblers/materials/Points.ts















const Points_LINES_TO_REMOVE_MAP = /* @__PURE__ */ new Map([
  [ShaderName/* ShaderName.VERTEX */.k.VERTEX, ["#include <begin_vertex>", "gl_PointSize = size;"]],
  [ShaderName/* ShaderName.FRAGMENT */.k.FRAGMENT, []]
]);
const CUSTOM_ASSEMBLER_MAP = /* @__PURE__ */ new Map();
CUSTOM_ASSEMBLER_MAP.set(geometry_Material/* CustomMaterialName.DISTANCE */.RJ.DISTANCE, ShaderAssemblerCustomPointsDistance);
CUSTOM_ASSEMBLER_MAP.set(geometry_Material/* CustomMaterialName.DEPTH */.RJ.DEPTH, ShaderAssemblerCustomPointsDepth);
CUSTOM_ASSEMBLER_MAP.set(geometry_Material/* CustomMaterialName.DEPTH_DOF */.RJ.DEPTH_DOF, ShaderAssemblerCustomPointsDepthDOF);
class ShaderAssemblerPoints extends ShaderAssemblerMaterial {
  customAssemblerClassByCustomName() {
    return CUSTOM_ASSEMBLER_MAP;
  }
  templateShader() {
    const template = three_module.ShaderLib.points;
    return {
      vertexShader: template.vertexShader,
      fragmentShader: template.fragmentShader,
      uniforms: template.uniforms
    };
  }
  createMaterial() {
    const material = new three_module.PointsMaterial();
    this._addCustomMaterials(material);
    return material;
  }
  // protected insertBodyAfter(shader_name){
  // 	return {
  // 		vertex: 'gl_PointSize = size;',
  // 		fragment: 'vec4 diffuseColor = vec4( diffuse, opacity );'
  // 	}[shader_name]
  // }
  // those shadow shaders should ideally be overriden
  // to properly take into account point size
  add_output_inputs(output_child) {
    const list = assemblers_Base/* BaseGlShaderAssembler.output_input_connection_points */.X.output_input_connection_points();
    list.push(new Gl/* GlConnectionPoint */.E(GlobalOutput/* GlobalsOutput.GL_POINTSIZE */.n.GL_POINTSIZE, Gl/* GlConnectionPointType.FLOAT */.Dv.FLOAT));
    output_child.io.inputs.setNamedInputConnectionPoints(list);
  }
  create_globals_node_output_connections() {
    return assemblers_Base/* BaseGlShaderAssembler.create_globals_node_output_connections */.X.create_globals_node_output_connections().concat([
      new Gl/* GlConnectionPoint */.E(GlobalOutput/* GlobalsOutput.GL_POINTCOORD */.n.GL_POINTCOORD, Gl/* GlConnectionPointType.VEC2 */.Dv.VEC2)
    ]);
  }
  create_shader_configs() {
    return [
      new configs_ShaderConfig/* ShaderConfig */.E(
        ShaderName/* ShaderName.VERTEX */.k.VERTEX,
        ["position", "normal", "uv", GlobalOutput/* GlobalsOutput.GL_POINTSIZE */.n.GL_POINTSIZE, VaryingWrite/* VaryingWriteGlNode.INPUT_NAME */.N.INPUT_NAME],
        []
      ),
      new configs_ShaderConfig/* ShaderConfig */.E(ShaderName/* ShaderName.FRAGMENT */.k.FRAGMENT, ["color", "alpha"], [ShaderName/* ShaderName.VERTEX */.k.VERTEX])
    ];
  }
  create_variable_configs() {
    return assemblers_Base/* BaseGlShaderAssembler.create_variable_configs */.X.create_variable_configs().concat([
      new VariableConfig/* VariableConfig */.P(GlobalOutput/* GlobalsOutput.GL_POINTSIZE */.n.GL_POINTSIZE, {
        default: "1.0",
        prefix: `${GlobalOutput/* GlobalsOutput.GL_POINTSIZE */.n.GL_POINTSIZE} = `,
        suffix: " * size * 10.0"
        // currently using 10 as 1 seems really small
      })
    ]);
  }
  linesToRemove(shader_name) {
    return Points_LINES_TO_REMOVE_MAP.get(shader_name);
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/gl/code/templates/post/Default.frag.glsl
/* harmony default export */ var Default_frag = ("\n// INSERT DEFINE\n\nuniform sampler2D textureInput1;\n\nvoid mainImage(const in vec4 inputColor, const in vec2 uv, out vec4 outputColor) {\n\n\tvec4 diffuseColor = vec4(0.0,0.0,0.0,1.0);\n\n\n\t// INSERT BODY\n\n\toutputColor = vec4( diffuseColor );\n\n}");
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/gl/code/assemblers/post/Post.ts









class ShaderAssemblerPost extends assemblers_Base/* BaseGlShaderAssembler */.X {
  templateShader() {
    return {
      fragmentShader: Default_frag,
      vertexShader: void 0,
      uniforms: void 0
    };
  }
  fragment_shader() {
    return this._shaders_by_name.get(ShaderName/* ShaderName.FRAGMENT */.k.FRAGMENT);
  }
  uniforms() {
    return this._uniforms;
  }
  updateFragmentShader() {
    this._lines = /* @__PURE__ */ new Map();
    this._shaders_by_name = /* @__PURE__ */ new Map();
    for (const shader_name of this.shaderNames()) {
      if (shader_name == ShaderName/* ShaderName.FRAGMENT */.k.FRAGMENT) {
        const template = this.templateShader().fragmentShader;
        this._lines.set(shader_name, template.split("\n"));
      }
    }
    if (this._root_nodes.length > 0) {
      this.buildCodeFromNodes(this._root_nodes);
      this._buildLines();
    }
    this._uniforms = this._uniforms || {};
    this._gl_parent_node.scene().uniformsController.addUniforms(this._uniforms, {
      paramConfigs: this.param_configs(),
      additionalTextureUniforms: {},
      timeDependent: this.uniformsTimeDependent(),
      resolutionDependent: this.uniformsResolutionDependent(),
      raymarchingLightsWorldCoordsDependent: this._raymarchingLightsWorldCoordsDependent()
    });
    for (const shader_name of this.shaderNames()) {
      const lines = this._lines.get(shader_name);
      if (lines) {
        this._shaders_by_name.set(shader_name, lines.join("\n"));
      }
    }
    BuilderPostNode.handleDependencies(
      this.currentGlParentNode(),
      this.uniformsTimeDependent(),
      this._uniforms
    );
  }
  //
  //
  // CHILDREN NODES PARAMS
  //
  //
  add_output_inputs(output_child) {
    output_child.io.inputs.setNamedInputConnectionPoints([
      new Gl/* GlConnectionPoint */.E("color", Gl/* GlConnectionPointType.VEC3 */.Dv.VEC3),
      new Gl/* GlConnectionPoint */.E("alpha", Gl/* GlConnectionPointType.FLOAT */.Dv.FLOAT)
    ]);
  }
  add_globals_outputs(globals_node) {
    globals_node.io.outputs.setNamedOutputConnectionPoints([
      new Gl/* GlConnectionPoint */.E("input0", Gl/* GlConnectionPointType.VEC4 */.Dv.VEC4),
      new Gl/* GlConnectionPoint */.E("input1", Gl/* GlConnectionPointType.VEC4 */.Dv.VEC4),
      new Gl/* GlConnectionPoint */.E("uv", Gl/* GlConnectionPointType.VEC2 */.Dv.VEC2),
      new Gl/* GlConnectionPoint */.E("gl_FragCoord", Gl/* GlConnectionPointType.VEC4 */.Dv.VEC4),
      new Gl/* GlConnectionPoint */.E("resolution", Gl/* GlConnectionPointType.VEC2 */.Dv.VEC2),
      new Gl/* GlConnectionPoint */.E("time", Gl/* GlConnectionPointType.FLOAT */.Dv.FLOAT)
      // new Connection.Vec2('resolution'),
    ]);
  }
  //
  //
  // CONFIGS
  //
  //
  create_shader_configs() {
    return [new configs_ShaderConfig/* ShaderConfig */.E(ShaderName/* ShaderName.FRAGMENT */.k.FRAGMENT, ["color", "alpha"], [])];
  }
  create_variable_configs() {
    return [
      new VariableConfig/* VariableConfig */.P("color", {
        prefix: "diffuseColor.xyz = "
      }),
      new VariableConfig/* VariableConfig */.P("alpha", {
        prefix: "diffuseColor.a = ",
        default: "1.0"
      })
    ];
  }
  //
  //
  // TEMPLATE HOOKS
  //
  //
  insertDefineAfter(shader_name) {
    return "// INSERT DEFINE";
  }
  insertBodyAfter(shader_name) {
    return "// INSERT BODY";
  }
  linesToRemove(shader_name) {
    return ["// INSERT DEFINE", "// INSERT BODY"];
  }
  _handle_gl_FragCoord(bodyLines, shaderName, var_name) {
    if (shaderName == ShaderName/* ShaderName.FRAGMENT */.k.FRAGMENT) {
      bodyLines.push(`vec4 ${var_name} = gl_FragCoord`);
    }
  }
  _handle_resolution(bodyLines, shaderName, var_name) {
    if (shaderName == ShaderName/* ShaderName.FRAGMENT */.k.FRAGMENT) {
      bodyLines.push(`vec2 ${var_name} = resolution`);
    }
  }
  _handleUV(bodyLines, shaderName, var_name) {
    if (shaderName == ShaderName/* ShaderName.FRAGMENT */.k.FRAGMENT) {
      bodyLines.push(`vec2 ${var_name} = vec2( gl_FragCoord.x / resolution.x, gl_FragCoord.y / resolution.y)`);
    }
  }
  set_node_lines_output(output_node, shaders_collection_controller) {
    const input_names = this.inputNamesForShaderName(
      output_node,
      shaders_collection_controller.currentShaderName()
    );
    if (input_names) {
      for (const input_name of input_names) {
        const input = output_node.io.inputs.named_input(input_name);
        if (input) {
          const gl_var = output_node.variableForInput(input_name);
          let body_line;
          if (input_name == "color") {
            body_line = `diffuseColor.xyz = ${ThreeToGl/* ThreeToGl.any */._.any(gl_var)}`;
          }
          if (input_name == "alpha") {
            body_line = `diffuseColor.a = ${ThreeToGl/* ThreeToGl.any */._.any(gl_var)}`;
          }
          if (body_line) {
            shaders_collection_controller.addBodyLines(output_node, [body_line]);
          }
        }
      }
    }
  }
  set_node_lines_globals(globals_node, shaders_collection_controller) {
    const shader_name = shaders_collection_controller.currentShaderName();
    const shader_config = this.shader_config(shader_name);
    if (!shader_config) {
      return;
    }
    const body_lines = [];
    const definitions = [];
    for (const output_name of globals_node.io.outputs.used_output_names()) {
      const var_name = globals_node.glVarName(output_name);
      switch (output_name) {
        case "input0":
          body_lines.push(`vec4 ${var_name} = inputColor`);
          this.setUniformsTimeDependent();
          break;
        case "input1":
          body_lines.push(`vec4 ${var_name} = texture2D( textureInput1, vUv)`);
          this.setUniformsTimeDependent();
          break;
        case "time":
          body_lines.push(`float ${var_name} = ${output_name}`);
          this.setUniformsTimeDependent();
          break;
        case "uv":
          this._handleUV(body_lines, shader_name, var_name);
          break;
        case "gl_FragCoord":
          this._handle_gl_FragCoord(body_lines, shader_name, var_name);
          break;
        case "resolution":
          this._handle_resolution(body_lines, shader_name, var_name);
          break;
      }
    }
    shaders_collection_controller.addDefinitions(globals_node, definitions, shader_name);
    shaders_collection_controller.addBodyLines(globals_node, body_lines);
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/gl/code/assemblers/materials/_BaseRayMarchingAbstract.ts






const _BaseRayMarchingAbstract_ASSEMBLER_MAP = /* @__PURE__ */ new Map([]);
class BaseShaderAssemblerRayMarchingAbstract extends ShaderAssemblerMaterial {
  customAssemblerClassByCustomName() {
    return _BaseRayMarchingAbstract_ASSEMBLER_MAP;
  }
  set_node_lines_globals(globals_node, shaders_collection_controller) {
    const body_lines = [];
    const shader_name = shaders_collection_controller.currentShaderName();
    const shader_config = this.shader_config(shader_name);
    if (!shader_config) {
      return;
    }
    const dependencies = shader_config.dependencies();
    const definitions_by_shader_name = /* @__PURE__ */ new Map();
    const body_lines_by_shader_name = /* @__PURE__ */ new Map();
    let definition;
    let body_line;
    for (const output_name of globals_node.io.outputs.used_output_names()) {
      const var_name = globals_node.glVarName(output_name);
      const globals_shader_name = shaders_collection_controller.currentShaderName();
      switch (output_name) {
        case "time":
          definition = new GLDefinition/* UniformGLDefinition */.oA(globals_node, Gl/* GlConnectionPointType.FLOAT */.Dv.FLOAT, output_name);
          if (globals_shader_name) {
            MapUtils/* MapUtils.pushOnArrayAtEntry */.pl.pushOnArrayAtEntry(definitions_by_shader_name, globals_shader_name, definition);
          }
          body_line = `float ${var_name} = ${output_name}`;
          for (const dependency of dependencies) {
            MapUtils/* MapUtils.pushOnArrayAtEntry */.pl.pushOnArrayAtEntry(definitions_by_shader_name, dependency, definition);
            MapUtils/* MapUtils.pushOnArrayAtEntry */.pl.pushOnArrayAtEntry(body_lines_by_shader_name, dependency, body_line);
          }
          body_lines.push(body_line);
          this.setUniformsTimeDependent();
          break;
        case "position":
          if (shader_name == ShaderName/* ShaderName.FRAGMENT */.k.FRAGMENT) {
            body_lines.push(`vec3 ${var_name} = p`);
          }
          break;
        case "cameraPosition":
          if (shader_name == ShaderName/* ShaderName.FRAGMENT */.k.FRAGMENT) {
            body_lines.push(`vec3 ${var_name} = cameraPosition`);
          }
          break;
      }
    }
    definitions_by_shader_name.forEach((definitions, shader_name2) => {
      shaders_collection_controller.addDefinitions(globals_node, definitions, shader_name2);
    });
    body_lines_by_shader_name.forEach((body_lines2, shader_name2) => {
      shaders_collection_controller.addBodyLines(globals_node, body_lines2, shader_name2);
    });
    shaders_collection_controller.addBodyLines(globals_node, body_lines);
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/gl/gl/raymarching/vert.glsl
/* harmony default export */ var raymarching_vert = ("precision highp float;\nprecision highp int;\n\nvarying vec3 vPw;\nvarying mat4 vModelMatrix;\nvarying mat4 vInverseModelMatrix;\nvarying mat4 VViewMatrix;\n\n#include <common>\n\n// // for depth material\n// varying vec2 vHighPrecisionZW;\n\nvoid main()\t{\n\n\tvModelMatrix = modelMatrix;\n\tvInverseModelMatrix = inverse(modelMatrix);\n\tVViewMatrix = viewMatrix;\n\tvPw = (modelMatrix * vec4( position, 1.0 )).xyz;\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n\t// vHighPrecisionZW = gl_Position.zw;\n}");
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/gl/gl/raymarching/frag.glsl
/* harmony default export */ var raymarching_frag = ("precision highp float;\nprecision highp int;\n\n// --- applyMaterial constants definition\nuniform int MAX_STEPS;\nuniform float MAX_DIST;\nuniform float SURF_DIST;\nuniform float NORMALS_BIAS;\nuniform float SHADOW_BIAS;\n#define ZERO 0\nuniform float debugMinSteps;\nuniform float debugMaxSteps;\nuniform float debugMinDepth;\nuniform float debugMaxDepth;\n\n#include <common>\n#include <packing>\n#include <lightmap_pars_fragment>\n#include <bsdfs>\n#include <cube_uv_reflection_fragment>\n#include <lights_pars_begin>\n#include <lights_physical_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <fog_pars_fragment>\n\n#if defined( SHADOW_DISTANCE )\n\tuniform float shadowDistanceMin;\n\tuniform float shadowDistanceMax;\n#endif \n#if defined( SHADOW_DEPTH )\n\tuniform float shadowDepthMin;\n\tuniform float shadowDepthMax;\n#endif\n\n// varying vec2 vHighPrecisionZW;\n\nvarying vec3 vPw;\nvarying mat4 vModelMatrix;\nvarying mat4 vInverseModelMatrix;\nvarying mat4 VViewMatrix;\n\n#if NUM_SPOT_LIGHTS > 0\n\tstruct SpotLightRayMarching {\n\t\tfloat penumbra;\n\t\tfloat shadowBiasAngle;\n\t\tfloat shadowBiasDistance;\n\t};\n\tuniform SpotLightRayMarching spotLightsRayMarching[ NUM_SPOT_LIGHTS ];\n\t#if NUM_SPOT_LIGHT_COORDS > 0\n\n\t\tuniform mat4 spotLightMatrix[ NUM_SPOT_LIGHT_COORDS ];\n\n\t#endif\n#endif\n#if NUM_DIR_LIGHTS > 0\n\tstruct DirectionalLightRayMarching {\n\t\tfloat penumbra;\n\t\tfloat shadowBiasAngle;\n\t\tfloat shadowBiasDistance;\n\t};\n\tuniform DirectionalLightRayMarching directionalLightsRayMarching[ NUM_DIR_LIGHTS ];\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];\n\n\t#endif\n#endif\n#if NUM_POINT_LIGHTS > 0\n\tstruct PointLightRayMarching {\n\t\tfloat penumbra;\n\t\tfloat shadowBiasAngle;\n\t\tfloat shadowBiasDistance;\n\t};\n\tuniform PointLightRayMarching pointLightsRayMarching[ NUM_POINT_LIGHTS ];\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\n\t\tuniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];\n\n\t#endif\n#endif\n\n\nstruct SDFContext {\n\tfloat d;\n\tint stepsCount;\n\tint matId;\n\tint matId2;\n\tfloat matBlend;\n};\n\nSDFContext DefaultSDFContext(){\n\treturn SDFContext( 0., 0, 0, 0, 0. );\n}\nint DefaultSDFMaterial(){\n\treturn 0;\n}\n\n// start raymarching builder define code\n\n\nSDFContext GetDist(vec3 p) {\n\tSDFContext sdfContext = SDFContext(0., 0, 0, 0, 0.);\n\n\t// start GetDist builder body code\n\t\n\n\treturn sdfContext;\n}\n\nSDFContext RayMarch(vec3 ro, vec3 rd, float side) {\n\tSDFContext dO = SDFContext(0.,0,0,0,0.);\n\n\t#pragma unroll_loop_start\n\tfor(int i=0; i<MAX_STEPS; i++) {\n\t\tvec3 p = ro + rd*dO.d;\n\t\tSDFContext sdfContext = GetDist(p);\n\t\tdO.d += sdfContext.d * side;\n\t\t#if defined( DEBUG_STEPS_COUNT )\n\t\t\tdO.stepsCount += 1;\n\t\t#endif\n\t\tdO.matId = sdfContext.matId;\n\t\tdO.matId2 = sdfContext.matId2;\n\t\tdO.matBlend = sdfContext.matBlend;\n\t\tif(dO.d>MAX_DIST || abs(sdfContext.d)<SURF_DIST) break;\n\t}\n\t#pragma unroll_loop_end\n\n\treturn dO;\n}\n\nvec3 GetNormal(vec3 p) {\n\tSDFContext sdfContext = GetDist(p);\n\tvec2 e = vec2(NORMALS_BIAS, 0);\n\n\tvec3 n = sdfContext.d - vec3(\n\t\tGetDist(p-e.xyy).d,\n\t\tGetDist(p-e.yxy).d,\n\t\tGetDist(p-e.yyx).d);\n\n\treturn normalize(n);\n}\n// https://iquilezles.org/articles/rmshadows\nfloat calcSoftshadow( in vec3 ro, in vec3 rd, float mint, float maxt, float k, inout SDFContext sdfContext )\n{\n\tfloat res = 1.0;\n\tfloat ph = 1e20;\n\tfor( float t=mint; t<maxt; )\n\t{\n\t\tfloat h = GetDist(ro + rd*t).d;\n\t\t#if defined( DEBUG_STEPS_COUNT )\n\t\t\tsdfContext.stepsCount += 1;\n\t\t#endif\n\t\tif( h<SURF_DIST )\n\t\t\treturn 0.0;\n\t\tfloat y = h*h/(2.0*ph);\n\t\tfloat d = sqrt(h*h-y*y);\n\t\tres = min( res, k*d/max(0.0,t-y) );\n\t\tph = h;\n\t\tt += h;\n\t}\n\treturn res;\n}\n\nvec3 GetLight(vec3 _p, vec3 _n, inout SDFContext sdfContext) {\n\tvec3 dif = vec3(0.,0.,0.);\n\t// GeometricContext geometry;\n\t// geometry.position = _p;\n\t// geometry.normal = _n;\n\t// geometry.viewDir = rayDir;\n\n\t// vec4 mvPosition = vec4( p, 1.0 );\n\t// mvPosition = modelViewMatrix * mvPosition;\n\t// vec3 vViewPosition = - mvPosition.xyz;\n\tvec3 pWorld = ( vModelMatrix * vec4( _p, 1.0 )).xyz;\n\tvec3 nWorld = transformDirection(_n, vModelMatrix);\n\t// geometry.position = (VViewMatrix * vec4( _p, 1.0 )).xyz;\n\tvec3 geometryPosition = (VViewMatrix * vec4(pWorld, 1.0 )).xyz;\n\t// geometry.normal = transformDirection(_n, VViewMatrix);\n\t// geometry.normal = inverseTransformDirection(transformDirection(_n, VViewMatrix), vInverseModelMatrix);\n\tvec3 geometryNormal = transformDirection(nWorld, VViewMatrix);\n\t\n\n\t#if NUM_SPOT_LIGHTS > 0 || NUM_DIR_LIGHTS > 0 || NUM_HEMI_LIGHTS > 0 || NUM_POINT_LIGHTS > 0 || NUM_RECT_AREA_LIGHTS > 0\n\n\t\tIncidentLight directLight;\n\t\tReflectedLight reflectedLight;\n\t\tvec3 lightPos, lightDir, worldLightDir, objectSpaceLightDir, lighDif, directDiffuse;\n\t\tfloat dotNL, lightDistance;\n\t\t#if NUM_SPOT_LIGHTS > 0\n\t\t\tSpotLightRayMarching spotLightRayMarching;\n\t\t\tSpotLight spotLight;\n\t\t\tfloat spotLightSdfShadow;\n\t\t\t#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0\n\t\t\t\tSpotLightShadow spotLightShadow;\n\t\t\t#endif\n\t\t\t#pragma unroll_loop_start\n\t\t\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\t\t\tspotLightRayMarching = spotLightsRayMarching[ i ];\n\t\t\t\tspotLight = spotLights[ i ];\n\t\t\t\tgetSpotLightInfo( spotLight, geometryPosition, directLight );\n\n\t\t\t\t// #if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n\t\t\t\t// \tspotLightShadow = spotLightShadows[ i ];\n\t\t\t\t// \tvec4 spotLightShadowCoord = spotLightMatrix[ i ] * vec4(pWorld+SHADOW_BIAS*nWorld, 1.0);\n\t\t\t\t// \tdirectLight.color *= (directLight.visible && receiveShadow) ? getShadow(\n\t\t\t\t// \t\tspotShadowMap[ i ],\n\t\t\t\t// \t\tspotLightShadow.shadowMapSize,\n\t\t\t\t// \t\tspotLightShadow.shadowBias,\n\t\t\t\t// \t\tspotLightShadow.shadowRadius,\n\t\t\t\t// \t\tspotLightShadowCoord\n\t\t\t\t// \t) : 1.0;\n\t\t\t\t// #endif\n\n\t\t\t\tlightPos = spotLight.position;\n\t\t\t\tlightDir = normalize(lightPos-geometryPosition);\n\t\t\t\tworldLightDir = inverseTransformDirection(lightDir, VViewMatrix);\n\t\t\t\tobjectSpaceLightDir = inverseTransformDirection(worldLightDir, vModelMatrix);\n\t\t\t\tlightDistance = distance(geometryPosition,lightPos);\n\t\t\t\tspotLightSdfShadow =\n\t\t\t\t\tdot( _n, objectSpaceLightDir ) < spotLightRayMarching.shadowBiasAngle\n\t\t\t\t\t? 1.\n\t\t\t\t\t: calcSoftshadow(\n\t\t\t\t\t\t_p,\n\t\t\t\t\t\tobjectSpaceLightDir,\n\t\t\t\t\t\tspotLightRayMarching.shadowBiasDistance,\n\t\t\t\t\t\tdistance(geometryPosition,lightPos),\n\t\t\t\t\t\t1./max(spotLightRayMarching.penumbra*0.2,0.001),\n\t\t\t\t\t\tsdfContext\n\t\t\t\t\t);\n\t\t\t\tdotNL = saturate( dot( geometryNormal, directLight.direction ) );\n\t\t\t\tdirectDiffuse = dotNL * directLight.color * BRDF_Lambert( vec3(1.) );\n\t\t\t\tdif += directDiffuse * spotLightSdfShadow;\n\t\t\t}\n\t\t\t#pragma unroll_loop_end\n\t\t#endif\n\t\t#if NUM_DIR_LIGHTS > 0\n\t\t\tDirectionalLightRayMarching directionalLightRayMarching;\n\t\t\tDirectionalLight directionalLight;\n\t\t\tfloat dirLightSdfShadow;\n\t\t\t#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0\n\t\t\t\tDirectionalLightShadow directionalLightShadow;\n\t\t\t#endif\n\t\t\t#pragma unroll_loop_start\n\t\t\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\t\t\tdirectionalLightRayMarching = directionalLightsRayMarching[ i ];\n\t\t\t\tdirectionalLight = directionalLights[ i ];\n\t\t\t\t\n\t\t\t\tgetDirectionalLightInfo( directionalLight, directLight );\n\n\t\t\t\t// #if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )\n\t\t\t\t// \tdirectionalLightShadow = directionalLightShadows[ i ];\n\t\t\t\t// \tvec4 dirLightShadowCoord = directionalShadowMatrix[ i ] * vec4(pWorld+SHADOW_BIAS*nWorld, 1.0);\n\t\t\t\t// \tdirectLight.color *= (directLight.visible && receiveShadow) ? getShadow(\n\t\t\t\t// \t\tdirectionalShadowMap[ i ],\n\t\t\t\t// \t\tdirectionalLightShadow.shadowMapSize,\n\t\t\t\t// \t\tdirectionalLightShadow.shadowBias,\n\t\t\t\t// \t\tdirectionalLightShadow.shadowRadius,\n\t\t\t\t// \t\tdirLightShadowCoord\n\t\t\t\t// \t) : 1.0;\n\t\t\t\t// #endif\n\n\t\t\t\tlightDir = directionalLight.direction;\n\t\t\t\tworldLightDir = inverseTransformDirection(lightDir, VViewMatrix);\n\t\t\t\tobjectSpaceLightDir = inverseTransformDirection(worldLightDir, vModelMatrix);\n\t\t\t\tdirLightSdfShadow =\n\t\t\t\t\tdot( _n, objectSpaceLightDir ) < directionalLightRayMarching.shadowBiasAngle\n\t\t\t\t\t? 1.\n\t\t\t\t\t:\n\t\t\t\t\tcalcSoftshadow(\n\t\t\t\t\t\t_p,\n\t\t\t\t\t\tobjectSpaceLightDir,\n\t\t\t\t\t\tdirectionalLightRayMarching.shadowBiasDistance,\n\t\t\t\t\t\tMAX_DIST,//distance(geometryPosition,lightPos),\n\t\t\t\t\t\t1./max(directionalLightRayMarching.penumbra*0.2,0.001),\n\t\t\t\t\t\tsdfContext\n\t\t\t\t\t);\n\t\t\t\tdotNL = saturate( dot( geometryNormal, directLight.direction ) );\n\t\t\t\t// lighDif = directLight.color * dotNL * dirLightSdfShadow;\n\t\t\t\tdirectDiffuse = dotNL * directLight.color * BRDF_Lambert( vec3(1.) );\n\t\t\t\tdif += directDiffuse * dirLightSdfShadow;\n\t\t\t}\n\t\t\t#pragma unroll_loop_end\n\t\t#endif\n\n\t\t#if ( NUM_HEMI_LIGHTS > 0 )\n\n\t\t\t#pragma unroll_loop_start\n\t\t\tHemisphereLight hemiLight;\n\t\t\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\t\t\themiLight = hemisphereLights[ i ];\n\t\t\t\tdif += getHemisphereLightIrradiance( hemiLight, geometryNormal ) * BRDF_Lambert( vec3(1.) );\n\n\t\t\t}\n\t\t\t#pragma unroll_loop_end\n\n\t\t#endif\n\n\t\t#if NUM_POINT_LIGHTS > 0\n\t\t\tPointLightRayMarching pointLightRayMarching;\n\t\t\tPointLight pointLight;\n\t\t\tfloat pointLightSdfShadow;\n\t\t\t#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0\n\t\t\t\tPointLightShadow pointLightShadow;\n\t\t\t#endif\n\t\t\t#pragma unroll_loop_start\n\t\t\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\t\t\tpointLightRayMarching = pointLightsRayMarching[ i ];\n\t\t\t\tpointLight = pointLights[ i ];\n\t\t\t\tgetPointLightInfo( pointLight, geometryPosition, directLight );\n\n\n\t\t\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )\n\t\t\t\t\tpointLightShadow = pointLightShadows[ i ];\n\t\t\t\t\tvec4 pointLightShadowCoord = pointShadowMatrix[ i ] * vec4(pWorld+SHADOW_BIAS*nWorld, 1.0);\n\t\t\t\t\tdirectLight.color *= (directLight.visible && receiveShadow) ? getPointShadow(\n\t\t\t\t\t\tpointShadowMap[ i ],\n\t\t\t\t\t\tpointLightShadow.shadowMapSize,\n\t\t\t\t\t\tpointLightShadow.shadowBias,\n\t\t\t\t\t\tpointLightShadow.shadowRadius,\n\t\t\t\t\t\tpointLightShadowCoord,\n\t\t\t\t\t\tpointLightShadow.shadowCameraNear,\n\t\t\t\t\t\tpointLightShadow.shadowCameraFar\n\t\t\t\t\t) : 1.0;\n\t\t\t\t#endif\n\n\t\t\t\tlightPos = pointLight.position;\n\t\t\t\tlightDir = normalize(lightPos-geometryPosition);\n\t\t\t\tworldLightDir = inverseTransformDirection(lightDir, VViewMatrix);\n\t\t\t\tobjectSpaceLightDir = inverseTransformDirection(worldLightDir, vModelMatrix);\n\t\t\t\tpointLightSdfShadow =\n\t\t\t\t\tdot( _n, objectSpaceLightDir ) < pointLightRayMarching.shadowBiasAngle\n\t\t\t\t\t? 1.\n\t\t\t\t\t:\n\t\t\t\t\tcalcSoftshadow(\n\t\t\t\t\t_p,\n\t\t\t\t\tobjectSpaceLightDir,\n\t\t\t\t\tpointLightRayMarching.shadowBiasDistance,\n\t\t\t\t\tdistance(geometryPosition,lightPos),\n\t\t\t\t\t1./max(pointLightRayMarching.penumbra*0.2,0.001),\n\t\t\t\t\tsdfContext\n\t\t\t\t);\n\t\t\t\tdotNL = saturate( dot( geometryNormal, directLight.direction ) );\n\t\t\t\tdirectDiffuse = dotNL * directLight.color * BRDF_Lambert( vec3(1.) );\n\t\t\t\tdif += directDiffuse * pointLightSdfShadow;\n\t\t\t}\n\t\t\t#pragma unroll_loop_end\n\t\t#endif\n\n\t\t#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\n\n\t\t\tRectAreaLight rectAreaLight;\n\t\t\t// AreaLightRayMarching areaLightRayMarching;\n\t\t\tPhysicalMaterial material;\n\t\t\tmaterial.roughness = 1.;\n\t\t\tmaterial.specularColor = vec3(1.);\n\t\t\tmaterial.diffuseColor = vec3(1.);\n\n\t\t\tvec3 geometryViewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( cameraPosition - geometryPosition );\n\t\t\tvec3 geometryClearcoatNormal = geometryNormal;\n\n\t\t\t#pragma unroll_loop_start\n\t\t\tfor ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\n\t\t\t\t// areaLightRayMarching = areaLightsRayMarching[ i ];\n\t\t\t\trectAreaLight = rectAreaLights[ i ];\n\t\t\t\t// rectAreaLight.position = areaLightRayMarching.worldPos;\n\n\t\t\t\tRE_Direct_RectArea( rectAreaLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\n\t\t\t}\n\t\t\t#pragma unroll_loop_end\n\t\t\tdif += reflectedLight.directDiffuse;\n\n\t\t#endif\n\t#endif\n\n\tvec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n\n\t#if defined( USE_LIGHT_PROBES )\n\n\t\tirradiance += getLightProbeIrradiance( lightProbe, geometryNormal );\n\n\t#endif\n\n\tdif += irradiance;\n\n\treturn dif;\n}\n\n\n\n// --- applyMaterial function definition\n\n\n\nvec4 applyShading(vec3 rayOrigin, vec3 rayDir, inout SDFContext sdfContext){\n\tvec3 p = rayOrigin + rayDir * sdfContext.d;\n\tvec3 n = GetNormal(p);\n\t\n\tvec3 col = applyMaterial(p, n, rayDir, sdfContext.matId, sdfContext);\n\tif(sdfContext.matBlend > 0.) {\n\t\t// blend material colors if needed\n\t\tvec3 col2 = applyMaterial(p, n, rayDir, sdfContext.matId2, sdfContext);\n\t\tcol = (1. - sdfContext.matBlend)*col + sdfContext.matBlend*col2;\n\t}\n\t\t\n\t// gamma\n\t//col = pow( col, vec3(0.4545) ); // this gamma leads to a different look than standard materials\n\treturn vec4(col, 1.);\n}\n\nvoid main()\t{\n\n\tvec3 rayDir = normalize(vPw - cameraPosition);\n\trayDir = transformDirection(rayDir, vInverseModelMatrix);\n\tvec3 rayOrigin = (vInverseModelMatrix * vec4( cameraPosition, 1.0 )).xyz;\n\n\tSDFContext sdfContext = RayMarch(rayOrigin, rayDir, 1.);\n\n\t#if defined( DEBUG_DEPTH )\n\t\tfloat normalizedDepth = 1.-(sdfContext.d - debugMinDepth ) / ( debugMaxDepth - debugMinDepth );\n\t\tnormalizedDepth = saturate(normalizedDepth); // clamp to [0,1]\n\t\tgl_FragColor = vec4(normalizedDepth);\n\t\treturn;\n\t#endif\n\t#if defined( SHADOW_DEPTH )\n\t\tfloat normalizedDepth = 1.-(sdfContext.d - debugMinDepth ) / ( debugMaxDepth - debugMinDepth );\n\t\t// float fragCoordZ = sdfContext.d / vHighPrecisionZW[1];\n\t\tfloat compoundedDepth = 0.5 * (normalizedDepth) + 0.5;\n\t\tfloat alpha = sdfContext.d < MAX_DIST ? 0.:1.;\n\t\tgl_FragColor = vec4( vec3(compoundedDepth), alpha );\n\t\t// normalizedDepth = 0.5*normalizedDepth+0.5;\n\t\t// gl_FragColor = packDepthToRGBA( normalizedDepth );\n\t\t// gl_FragColor = vec4(0.);\n\t\treturn;\n\t#endif\n\t#if defined( SHADOW_DISTANCE )\n\t\tfloat normalizedDepth = (sdfContext.d - shadowDistanceMin ) / ( shadowDistanceMax - shadowDistanceMin );\n\t\tnormalizedDepth = saturate(normalizedDepth); // clamp to [0,1]\n\t\tgl_FragColor = packDepthToRGBA( normalizedDepth );\n\t\treturn;\n\t#endif\n\n\tif( sdfContext.d < MAX_DIST ){\n\t\tgl_FragColor = applyShading(rayOrigin, rayDir, sdfContext);\n\t\t#if defined( TONE_MAPPING )\n\t\t\tgl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n\t\t#endif\n\t\tgl_FragColor = linearToOutputTexel( gl_FragColor );\n\n\t\t#ifdef USE_FOG\n\t\t\tfloat vFogDepth = sdfContext.d;\n\t\t\t#ifdef FOG_EXP2\n\t\t\t\tfloat fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );\n\t\t\t#else\n\t\t\t\tfloat fogFactor = smoothstep( fogNear, fogFar, vFogDepth );\n\t\t\t#endif\n\t\t\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n\t\t#endif\n\t\t#include <premultiplied_alpha_fragment>\n\t\t#include <dithering_fragment>\n\t} else {\n\t\tgl_FragColor = vec4(0.);\n\t}\n\n\t#if defined( DEBUG_STEPS_COUNT )\n\t\tfloat normalizedStepsCount = (float(sdfContext.stepsCount) - debugMinSteps ) / ( debugMaxSteps - debugMinSteps );\n\t\tgl_FragColor = vec4(normalizedStepsCount, 1.-normalizedStepsCount, 0., 1.);\n\t\treturn;\n\t#endif\n\t\n}");
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/nodes/gl/gl/raymarching/uniforms.ts
var uniforms = __webpack_require__(855);
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/gl/gl/raymarching/fragApplyMaterial.glsl
/* harmony default export */ var fragApplyMaterial = ("// start applyMaterial builder define code\n\n\n\n// --- applyMaterial SPLIT ---\nvec3 applyMaterialWithoutRefraction(vec3 p, vec3 n, vec3 rayDir, int mat, inout SDFContext sdfContext){\n\n\tvec3 col = vec3(1.);\n\t// --- REFLECTION NOT ALLOWED - START\n\t// --- REFRACTION NOT ALLOWED - START\n\t// start applyMaterial builder body code\n\t\n\t// --- REFLECTION NOT ALLOWED - END\n\t// --- REFRACTION NOT ALLOWED - END\n\treturn col;\n}\n\nvec3 applyMaterialWithoutReflection(vec3 p, vec3 n, vec3 rayDir, int mat, inout SDFContext sdfContext){\n\n\tvec3 col = vec3(1.);\n\t// --- REFLECTION NOT ALLOWED - START\n\t// --- REFRACTION NOT ALLOWED - START\n\t// start applyMaterial builder body code\n\t\n\t// --- REFLECTION NOT ALLOWED - END\n\t// --- REFRACTION NOT ALLOWED - END\n\treturn col;\n}\n#ifdef RAYMARCHED_REFLECTIONS\nvec3 GetReflection(vec3 p, vec3 n, vec3 rayDir, float biasMult, float roughness, int reflectionDepth, inout SDFContext sdfContextMain){\n\tbool hitReflection = true;\n\tvec3 reflectedColor = vec3(0.);\n\t#pragma unroll_loop_start\n\tfor(int i=0; i < reflectionDepth; i++) {\n\t\tif(hitReflection){\n\t\t\trayDir = reflect(rayDir, n);\n\t\t\tp += n*SURF_DIST*biasMult;\n\t\t\tSDFContext sdfContext = RayMarch(p, rayDir, 1.);\n\t\t\t#if defined( DEBUG_STEPS_COUNT )\n\t\t\t\tsdfContextMain.stepsCount += sdfContext.stepsCount;\n\t\t\t#endif\n\t\t\tif( sdfContext.d >= MAX_DIST){\n\t\t\t\thitReflection = false;\n\t\t\t\treflectedColor = envMapSample(rayDir, roughness);\n\t\t\t}\n\t\t\tif(hitReflection){\n\t\t\t\tp += rayDir * sdfContext.d;\n\t\t\t\tn = GetNormal(p);\n\t\t\t\tvec3 matCol = applyMaterialWithoutReflection(p, n, rayDir, sdfContext.matId, sdfContextMain);\n\t\t\t\treflectedColor += matCol;\n\t\t\t}\n\t\t}\n\t}\n\t#pragma unroll_loop_end\n\treturn reflectedColor;\n}\n#endif\n\n#ifdef RAYMARCHED_REFRACTIONS\n// xyz for color, w for distanceInsideMedium\nvec4 GetRefractedData(vec3 p, vec3 n, vec3 rayDir, float ior, float biasMult, float roughness, float refractionMaxDist, int refractionDepth, inout SDFContext sdfContextMain){\n\tbool hitRefraction = true;\n\tbool changeSide = true;\n\t#ifdef RAYMARCHED_REFRACTIONS_START_OUTSIDE_MEDIUM\n\tfloat side = -1.;\n\t#else\n\tfloat side =  1.;\n\t#endif\n\tfloat iorInverted = 1. / ior;\n\tvec3 refractedColor = vec3(0.);\n\tfloat distanceInsideMedium=0.;\n\tfloat totalRefractedDistance=0.;\n\n\t#pragma unroll_loop_start\n\tfor(int i=0; i < refractionDepth; i++) {\n\t\tif(hitRefraction){\n\t\t\tfloat currentIor = side<0. ? iorInverted : ior;\n\t\t\tvec3 rayDirPreRefract = rayDir;\n\t\t\trayDir = refract(rayDir, n, currentIor);\n\t\t\tchangeSide = dot(rayDir, rayDir)!=0.;\n\t\t\tif(changeSide == true) {\n\t\t\t\tp -= n*SURF_DIST*(2.+biasMult);\n\t\t\t} else {\n\t\t\t\tp += n*SURF_DIST*(   biasMult);\n\t\t\t\trayDir = reflect(rayDirPreRefract, n);\n\t\t\t}\n\t\t\tSDFContext sdfContext = RayMarch(p, rayDir, side);\n\t\t\t#if defined( DEBUG_STEPS_COUNT )\n\t\t\t\tsdfContextMain.stepsCount += sdfContext.stepsCount;\n\t\t\t#endif\n\t\t\ttotalRefractedDistance += sdfContext.d;\n\t\t\tif( abs(sdfContext.d) >= MAX_DIST || totalRefractedDistance > refractionMaxDist ){\n\t\t\t\thitRefraction = false;\n\t\t\t\trefractedColor = envMapSample(rayDir, roughness);\n\t\t\t}\n\t\t\tif(hitRefraction){\n\t\t\t\tp += rayDir * sdfContext.d;\n\t\t\t\tn = GetNormal(p) * side;\n\t\t\t\tvec3 matCol = applyMaterialWithoutRefraction(p, n, rayDir, sdfContext.matId, sdfContextMain);\n\t\t\t\trefractedColor = matCol;\n\n\t\t\t\t// same as: side < 0. ? abs(sdfContext.d) : 0.;\n\t\t\t\tdistanceInsideMedium += (side-1.)*-0.5*abs(sdfContext.d);\n\t\t\t\tif( changeSide ){\n\t\t\t\t\tside *= -1.;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t#ifdef RAYMARCHED_REFRACTIONS_SAMPLE_ENV_MAP_ON_LAST\n\t\tif(i == refractionDepth-1){\n\t\t\trefractedColor = envMapSample(rayDir, roughness);\n\t\t}\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n\treturn vec4(refractedColor, distanceInsideMedium);\n}\nfloat refractionTint(float baseValue, float tint, float distanceInsideMedium, float absorption){\n\tfloat tintNegated = baseValue-tint;\n\tfloat t = tintNegated*( distanceInsideMedium*absorption );\n\treturn max(baseValue-t, 0.);\n}\nfloat applyRefractionAbsorption(float refractedDataColor, float baseValue, float tint, float distanceInsideMedium, float absorption){\n\treturn refractedDataColor*refractionTint(baseValue, tint, distanceInsideMedium, absorption);\n}\nvec3 applyRefractionAbsorption(vec3 refractedDataColor, vec3 baseValue, vec3 tint, float distanceInsideMedium, float absorption){\n\treturn vec3(\n\t\trefractedDataColor.r * refractionTint(baseValue.r, tint.r, distanceInsideMedium, absorption),\n\t\trefractedDataColor.g * refractionTint(baseValue.g, tint.g, distanceInsideMedium, absorption),\n\t\trefractedDataColor.b * refractionTint(baseValue.b, tint.b, distanceInsideMedium, absorption)\n\t);\n}\n\n#endif\n\nvec3 applyMaterial(vec3 p, vec3 n, vec3 rayDir, int mat, inout SDFContext sdfContext){\n\n\tvec3 col = vec3(0.);\n\t// start applyMaterial builder body code\n\t\n\treturn col;\n}\n");
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/gl/code/assemblers/materials/RayMarchingApplyMaterial.ts

var RayMarchingApplyMaterial_defProp = Object.defineProperty;
var RayMarchingApplyMaterial_getOwnPropSymbols = Object.getOwnPropertySymbols;
var RayMarchingApplyMaterial_hasOwnProp = Object.prototype.hasOwnProperty;
var RayMarchingApplyMaterial_propIsEnum = Object.prototype.propertyIsEnumerable;
var RayMarchingApplyMaterial_defNormalProp = (obj, key, value) => key in obj ? RayMarchingApplyMaterial_defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var RayMarchingApplyMaterial_spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (RayMarchingApplyMaterial_hasOwnProp.call(b, prop))
      RayMarchingApplyMaterial_defNormalProp(a, prop, b[prop]);
  if (RayMarchingApplyMaterial_getOwnPropSymbols)
    for (var prop of RayMarchingApplyMaterial_getOwnPropSymbols(b)) {
      if (RayMarchingApplyMaterial_propIsEnum.call(b, prop))
        RayMarchingApplyMaterial_defNormalProp(a, prop, b[prop]);
    }
  return a;
};










const RayMarchingApplyMaterial_INSERT_DEFINE_AFTER_MAP = /* @__PURE__ */ new Map([
  // [ShaderName.VERTEX, '#include <common>'],
  [ShaderName/* ShaderName.FRAGMENT */.k.FRAGMENT, "// start applyMaterial builder define code"]
]);
const RayMarchingApplyMaterial_INSERT_BODY_AFTER_MAP = /* @__PURE__ */ new Map([
  // [ShaderName.VERTEX, '// start builder body code'],
  [ShaderName/* ShaderName.FRAGMENT */.k.FRAGMENT, "// start applyMaterial builder body code"]
]);
const RayMarchingApplyMaterial_LINES_TO_REMOVE_MAP = /* @__PURE__ */ new Map([[ShaderName/* ShaderName.FRAGMENT */.k.FRAGMENT, []]]);
const SDF_CONTEXT_INPUT_NAME = Gl/* GlConnectionPointType.SDF_CONTEXT */.Dv.SDF_CONTEXT;
const REFLECTION_NOT_ALLOWED = {
  START: "// --- REFLECTION NOT ALLOWED - START",
  END: "// --- REFLECTION NOT ALLOWED - END"
};
const REFLECTION = {
  START: "// --- REFLECTION - START",
  END: "// --- REFLECTION - END"
};
const REFRACTION_NOT_ALLOWED = {
  START: "// --- REFRACTION NOT ALLOWED - START",
  END: "// --- REFRACTION NOT ALLOWED - END"
};
const REFRACTION = {
  START: "// --- REFRACTION - START",
  END: "// --- REFRACTION - END"
};
class ShaderAssemblerRayMarchingApplyMaterial extends BaseShaderAssemblerRayMarchingAbstract {
  templateShader() {
    return {
      vertexShader: raymarching_vert,
      fragmentShader: fragApplyMaterial,
      uniforms: three_module.UniformsUtils.clone(uniforms/* RAYMARCHING_UNIFORMS */.C)
    };
  }
  createMaterial() {
    const templateShader = this.templateShader();
    const material = new three_module.ShaderMaterial({
      vertexShader: templateShader.vertexShader,
      fragmentShader: templateShader.fragmentShader,
      side: three_module.BackSide,
      transparent: true,
      depthTest: true,
      alphaTest: 0.5,
      lights: true,
      uniforms: RayMarchingApplyMaterial_spreadValues(RayMarchingApplyMaterial_spreadValues({}, three_module.UniformsUtils.clone(three_module.ShaderLib.standard.uniforms)), three_module.UniformsUtils.clone(templateShader.uniforms))
    });
    return material;
  }
  // static add_output_inputs(output_child: OutputGlNode) {
  // 	// adding the color here would require to understand how to have the color affect the light in raymarch_light
  // 	// output_child.params.add_param(ParamType.COLOR, 'color', [1, 1, 1], {hidden: true});
  // 	// output_child.params.add_param(ParamType.VECTOR3, 'position', [0, 0, 0], {hidden: true});
  // 	// output_child.params.add_param(ParamType.FLOAT, 'density', 1, {hidden: true});
  // }
  add_output_inputs(output_child) {
    output_child.io.inputs.setNamedInputConnectionPoints([
      new Gl/* GlConnectionPoint */.E(
        SDF_CONTEXT_INPUT_NAME,
        Gl/* GlConnectionPointType.SDF_CONTEXT */.Dv.SDF_CONTEXT,
        "SDFContext(0.0, 0, 0, 0, 0.)"
      )
    ]);
  }
  static create_globals_node_output_connections() {
    return [
      new Gl/* GlConnectionPoint */.E("position", Gl/* GlConnectionPointType.VEC3 */.Dv.VEC3),
      new Gl/* GlConnectionPoint */.E("time", Gl/* GlConnectionPointType.FLOAT */.Dv.FLOAT),
      new Gl/* GlConnectionPoint */.E("cameraPosition", Gl/* GlConnectionPointType.VEC3 */.Dv.VEC3)
    ];
  }
  create_globals_node_output_connections() {
    return ShaderAssemblerRayMarchingApplyMaterial.create_globals_node_output_connections();
  }
  insertDefineAfter(shaderName) {
    return RayMarchingApplyMaterial_INSERT_DEFINE_AFTER_MAP.get(shaderName);
  }
  insertBodyAfter(shaderName) {
    return RayMarchingApplyMaterial_INSERT_BODY_AFTER_MAP.get(shaderName);
  }
  linesToRemove(shaderName) {
    return RayMarchingApplyMaterial_LINES_TO_REMOVE_MAP.get(shaderName);
  }
  create_shader_configs() {
    return [
      new configs_ShaderConfig/* ShaderConfig */.E(ShaderName/* ShaderName.VERTEX */.k.VERTEX, [], []),
      new configs_ShaderConfig/* ShaderConfig */.E(
        ShaderName/* ShaderName.FRAGMENT */.k.FRAGMENT,
        [
          /*'color', */
          "color",
          /* lighting */
          "diffuse",
          "emissive",
          /* envMap */
          "envMapTint",
          "envMapIntensity",
          "envMapRoughness",
          "envMapFresnel",
          "envMapFresnelPower",
          /* reflection */
          "reflectionTint",
          "reflectionDepth",
          "reflectivity",
          "reflectionBiasMult",
          /* refraction */
          "refractionTint",
          "refractionDepth",
          "ior",
          "iorOffset",
          "transmission",
          "absorption",
          "refractionBiasMult"
        ],
        []
      )
    ];
  }
  static create_variable_configs() {
    return [
      // new VariableConfig('position', {
      // 	// default_from_attribute: true,
      // 	// prefix: 'vec3 transformed = ',
      // }),
      // new VariableConfig('cameraPosition', {
      // 	// default_from_attribute: true,
      // 	// prefix: 'vec3 transformed = ',
      // }),
      // new VariableConfig('color', {
      // 	prefix: 'BUILDER_color.xyz = ',
      // }),
      new VariableConfig/* VariableConfig */.P(SDF_CONTEXT_INPUT_NAME, {
        prefix: "sdfContext = "
      })
    ];
  }
  create_variable_configs() {
    return ShaderAssemblerRayMarchingApplyMaterial.create_variable_configs();
  }
  //
  //
  //
  //
  //
  updateShaders() {
    this._shaders_by_name.clear();
    this._lines.clear();
    for (const shaderName of this.shaderNames()) {
      const template = this._template_shader_for_shader_name(shaderName);
      if (template) {
        this._lines.set(shaderName, template.split("\n"));
      }
    }
    const rootNodes = this.currentGlParentNode().nodesByType(types_Gl/* GlType.SDF_MATERIAL */.P.SDF_MATERIAL);
    if (rootNodes.length > 0) {
      this.buildCodeFromNodes(rootNodes);
      this._buildLines();
    }
    for (const shaderName of this.shaderNames()) {
      const lines = this._lines.get(shaderName);
      if (lines) {
        this._shaders_by_name.set(shaderName, lines.join("\n"));
      }
    }
    this._removeNestedReflection();
    this._removeNestedRefraction();
  }
  _removeNestedReflection() {
    const fragmentShader = this._shaders_by_name.get(ShaderName/* ShaderName.FRAGMENT */.k.FRAGMENT);
    if (!fragmentShader) {
      return;
    }
    const lines = fragmentShader.split("\n");
    const newLines = [];
    let inNotAllowed = false;
    let inAllowed = false;
    for (const line of lines) {
      if (line.includes(REFLECTION_NOT_ALLOWED.START)) {
        inNotAllowed = true;
      }
      if (line.includes(REFLECTION_NOT_ALLOWED.END)) {
        inNotAllowed = false;
      }
      if (line.includes(REFLECTION.START)) {
        inAllowed = true;
      }
      if (line.includes(REFLECTION.END)) {
        inAllowed = false;
      }
      if (!(inNotAllowed && inAllowed) && !line.includes(REFLECTION_NOT_ALLOWED.START) && !line.includes(REFLECTION_NOT_ALLOWED.END) && !line.includes(REFLECTION.START) && !line.includes(REFLECTION.END)) {
        newLines.push(line);
      }
    }
    const newFragmentShader = newLines.join("\n");
    this._shaders_by_name.set(ShaderName/* ShaderName.FRAGMENT */.k.FRAGMENT, newFragmentShader);
  }
  _removeNestedRefraction() {
    const fragmentShader = this._shaders_by_name.get(ShaderName/* ShaderName.FRAGMENT */.k.FRAGMENT);
    if (!fragmentShader) {
      return;
    }
    const lines = fragmentShader.split("\n");
    const newLines = [];
    let inNotAllowed = false;
    let inAllowed = false;
    for (const line of lines) {
      if (line.includes(REFRACTION_NOT_ALLOWED.START)) {
        inNotAllowed = true;
      }
      if (line.includes(REFRACTION_NOT_ALLOWED.END)) {
        inNotAllowed = false;
      }
      if (line.includes(REFRACTION.START)) {
        inAllowed = true;
      }
      if (line.includes(REFRACTION.END)) {
        inAllowed = false;
      }
      if (!(inNotAllowed && inAllowed) && !line.includes(REFRACTION_NOT_ALLOWED.START) && !line.includes(REFRACTION_NOT_ALLOWED.END) && !line.includes(REFRACTION.START) && !line.includes(REFRACTION.END)) {
        newLines.push(line);
      }
    }
    const newFragmentShader = newLines.join("\n");
    this._shaders_by_name.set(ShaderName/* ShaderName.FRAGMENT */.k.FRAGMENT, newFragmentShader);
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/gl/code/assemblers/materials/_BaseRayMarchingRendered.ts

var _BaseRayMarchingRendered_defProp = Object.defineProperty;
var _BaseRayMarchingRendered_getOwnPropSymbols = Object.getOwnPropertySymbols;
var _BaseRayMarchingRendered_hasOwnProp = Object.prototype.hasOwnProperty;
var _BaseRayMarchingRendered_propIsEnum = Object.prototype.propertyIsEnumerable;
var _BaseRayMarchingRendered_defNormalProp = (obj, key, value) => key in obj ? _BaseRayMarchingRendered_defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var _BaseRayMarchingRendered_spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (_BaseRayMarchingRendered_hasOwnProp.call(b, prop))
      _BaseRayMarchingRendered_defNormalProp(a, prop, b[prop]);
  if (_BaseRayMarchingRendered_getOwnPropSymbols)
    for (var prop of _BaseRayMarchingRendered_getOwnPropSymbols(b)) {
      if (_BaseRayMarchingRendered_propIsEnum.call(b, prop))
        _BaseRayMarchingRendered_defNormalProp(a, prop, b[prop]);
    }
  return a;
};











const _BaseRayMarchingRendered_INSERT_BODY_AFTER_MAP = /* @__PURE__ */ new Map([
  // [ShaderName.VERTEX, '// start builder body code'],
  [ShaderName/* ShaderName.FRAGMENT */.k.FRAGMENT, "// start GetDist builder body code"]
]);
const _BaseRayMarchingRendered_INSERT_DEFINE_AFTER_MAP = /* @__PURE__ */ new Map([
  // [ShaderName.VERTEX, '#include <common>'],
  [ShaderName/* ShaderName.FRAGMENT */.k.FRAGMENT, "// start raymarching builder define code"]
]);
const _BaseRayMarchingRendered_LINES_TO_REMOVE_MAP = /* @__PURE__ */ new Map([[ShaderName/* ShaderName.FRAGMENT */.k.FRAGMENT, []]]);
const _BaseRayMarchingRendered_SDF_CONTEXT_INPUT_NAME = Gl/* GlConnectionPointType.SDF_CONTEXT */.Dv.SDF_CONTEXT;
class BaseShaderAssemblerRayMarchingRendered extends BaseShaderAssemblerRayMarchingAbstract {
  constructor(_gl_parent_node) {
    super(_gl_parent_node);
    this._gl_parent_node = _gl_parent_node;
    //
    //
    //
    //
    //
    this._applyMaterialAssembler = new ShaderAssemblerRayMarchingApplyMaterial(this._gl_parent_node);
    this._applyMaterialMaterial = new three_module.ShaderMaterial();
    this._addFilterFragmentShaderCallback(
      "applyMaterialAssembler",
      (fragmentShader) => this.applyMaterialAssemblerFilterFragmentShader(fragmentShader)
    );
  }
  templateShader() {
    return {
      vertexShader: raymarching_vert,
      fragmentShader: raymarching_frag,
      uniforms: three_module.UniformsUtils.clone(uniforms/* RAYMARCHING_UNIFORMS */.C)
    };
  }
  createMaterial() {
    const templateShader = this.templateShader();
    const material = new three_module.ShaderMaterial({
      vertexShader: templateShader.vertexShader,
      fragmentShader: templateShader.fragmentShader,
      side: three_module.BackSide,
      transparent: true,
      depthTest: true,
      alphaTest: 0.5,
      lights: true,
      uniforms: _BaseRayMarchingRendered_spreadValues(_BaseRayMarchingRendered_spreadValues({}, three_module.UniformsUtils.clone(three_module.ShaderLib.standard.uniforms)), three_module.UniformsUtils.clone(templateShader.uniforms))
    });
    this._gl_parent_node.scene().sceneTraverser.addLightsRayMarchingUniform(material.uniforms);
    this._addCustomMaterials(material);
    return material;
  }
  _raymarchingLightsWorldCoordsDependent() {
    return true;
  }
  add_output_inputs(output_child) {
    output_child.io.inputs.setNamedInputConnectionPoints([
      new Gl/* GlConnectionPoint */.E(
        _BaseRayMarchingRendered_SDF_CONTEXT_INPUT_NAME,
        Gl/* GlConnectionPointType.SDF_CONTEXT */.Dv.SDF_CONTEXT,
        "SDFContext(0.0, 0, 0, 0, 0.)"
      )
    ]);
  }
  static create_globals_node_output_connections() {
    return [
      new Gl/* GlConnectionPoint */.E("position", Gl/* GlConnectionPointType.VEC3 */.Dv.VEC3),
      new Gl/* GlConnectionPoint */.E("time", Gl/* GlConnectionPointType.FLOAT */.Dv.FLOAT),
      new Gl/* GlConnectionPoint */.E("cameraPosition", Gl/* GlConnectionPointType.VEC3 */.Dv.VEC3)
    ];
  }
  create_globals_node_output_connections() {
    return BaseShaderAssemblerRayMarchingRendered.create_globals_node_output_connections();
  }
  insertBodyAfter(shaderName) {
    return _BaseRayMarchingRendered_INSERT_BODY_AFTER_MAP.get(shaderName);
  }
  insertDefineAfter(shaderName) {
    return _BaseRayMarchingRendered_INSERT_DEFINE_AFTER_MAP.get(shaderName);
  }
  linesToRemove(shaderName) {
    return _BaseRayMarchingRendered_LINES_TO_REMOVE_MAP.get(shaderName);
  }
  create_shader_configs() {
    return [
      new configs_ShaderConfig/* ShaderConfig */.E(ShaderName/* ShaderName.VERTEX */.k.VERTEX, [], []),
      new configs_ShaderConfig/* ShaderConfig */.E(ShaderName/* ShaderName.FRAGMENT */.k.FRAGMENT, [
        /*'color', */
        _BaseRayMarchingRendered_SDF_CONTEXT_INPUT_NAME
      ], [ShaderName/* ShaderName.VERTEX */.k.VERTEX])
    ];
  }
  static create_variable_configs() {
    return [
      // new VariableConfig('position', {
      // 	// default_from_attribute: true,
      // 	// prefix: 'vec3 transformed = ',
      // }),
      // new VariableConfig('cameraPosition', {
      // 	// default_from_attribute: true,
      // 	// prefix: 'vec3 transformed = ',
      // }),
      // new VariableConfig('color', {
      // 	prefix: 'BUILDER_color.xyz = ',
      // }),
      new VariableConfig/* VariableConfig */.P(_BaseRayMarchingRendered_SDF_CONTEXT_INPUT_NAME, {
        prefix: "sdfContext = "
      })
    ];
  }
  create_variable_configs() {
    return BaseShaderAssemblerRayMarchingRendered.create_variable_configs();
  }
  setGlParentNode(gl_parent_node) {
    super.setGlParentNode(gl_parent_node);
    this._applyMaterialAssembler.setGlParentNode(gl_parent_node);
  }
  compileMaterial(material) {
    this._applyMaterialAssembler.updateShaders();
    this._applyMaterialAssembler.prepareOnBeforeCompileData(this._applyMaterialMaterial);
    this.codeBuilder().nodeTraverser().setBlockedInputNames(types_Gl/* GlType.SDF_CONTEXT */.P.SDF_CONTEXT, ["material"]);
    super.compileMaterial(material, {
      otherFragmentShaderCollectionController: this._applyMaterialAssembler.codeBuilder().shadersCollectionController()
    });
  }
  applyMaterialAssemblerFilterFragmentShader(fragmentShader) {
    var _a;
    const applyMaterial = (_a = this._applyMaterialAssembler.onBeforeCompileData()) == null ? void 0 : _a.fragmentShader;
    if (applyMaterial) {
      const elements = applyMaterial.split("// --- applyMaterial SPLIT ---");
      const applyMaterialFunctionDefinition = elements[1];
      fragmentShader = fragmentShader.replace(
        "// --- applyMaterial function definition",
        applyMaterialFunctionDefinition
      );
    }
    if (this._applyMaterialAssembler.uniformsTimeDependent()) {
      this.setUniformsTimeDependent();
    }
    if (this._applyMaterialAssembler.uniformsResolutionDependent()) {
      this.setUniformsResolutionDependent();
    }
    return fragmentShader;
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/gl/code/assemblers/materials/custom/raymarching/RayMarchingDepth.ts

var RayMarchingDepth_defProp = Object.defineProperty;
var RayMarchingDepth_getOwnPropSymbols = Object.getOwnPropertySymbols;
var RayMarchingDepth_hasOwnProp = Object.prototype.hasOwnProperty;
var RayMarchingDepth_propIsEnum = Object.prototype.propertyIsEnumerable;
var RayMarchingDepth_defNormalProp = (obj, key, value) => key in obj ? RayMarchingDepth_defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var RayMarchingDepth_spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (RayMarchingDepth_hasOwnProp.call(b, prop))
      RayMarchingDepth_defNormalProp(a, prop, b[prop]);
  if (RayMarchingDepth_getOwnPropSymbols)
    for (var prop of RayMarchingDepth_getOwnPropSymbols(b)) {
      if (RayMarchingDepth_propIsEnum.call(b, prop))
        RayMarchingDepth_defNormalProp(a, prop, b[prop]);
    }
  return a;
};





class ShaderAssemblerRayMarchingDepth extends BaseShaderAssemblerRayMarchingRendered {
  templateShader() {
    return {
      vertexShader: raymarching_vert,
      fragmentShader: raymarching_frag,
      uniforms: three_module.UniformsUtils.clone(uniforms/* RAYMARCHING_UNIFORMS */.C)
    };
  }
  // override customAssemblerClassByCustomName() {
  // 	return ASSEMBLER_MAP;
  // }
  createMaterial() {
    const templateShader = this.templateShader();
    const material = new three_module.ShaderMaterial({
      vertexShader: templateShader.vertexShader,
      fragmentShader: templateShader.fragmentShader,
      side: three_module.FrontSide,
      transparent: false,
      // important
      depthWrite: true,
      depthTest: true,
      // stencilWrite: false,
      alphaTest: 0.5,
      lights: false,
      defines: {
        SHADOW_DEPTH: 1,
        DEPTH_PACKING: three_module.BasicDepthPacking
      },
      uniforms: RayMarchingDepth_spreadValues(RayMarchingDepth_spreadValues({}, three_module.UniformsUtils.clone(three_module.ShaderLib.standard.uniforms)), three_module.UniformsUtils.clone(templateShader.uniforms))
    });
    material.depthPacking = three_module.BasicDepthPacking;
    this._gl_parent_node.scene().sceneTraverser.addLightsRayMarchingUniform(material.uniforms);
    this._addCustomMaterials(material);
    return material;
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/gl/code/assemblers/materials/custom/raymarching/RayMarchingDistance.ts

var RayMarchingDistance_defProp = Object.defineProperty;
var RayMarchingDistance_getOwnPropSymbols = Object.getOwnPropertySymbols;
var RayMarchingDistance_hasOwnProp = Object.prototype.hasOwnProperty;
var RayMarchingDistance_propIsEnum = Object.prototype.propertyIsEnumerable;
var RayMarchingDistance_defNormalProp = (obj, key, value) => key in obj ? RayMarchingDistance_defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var RayMarchingDistance_spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (RayMarchingDistance_hasOwnProp.call(b, prop))
      RayMarchingDistance_defNormalProp(a, prop, b[prop]);
  if (RayMarchingDistance_getOwnPropSymbols)
    for (var prop of RayMarchingDistance_getOwnPropSymbols(b)) {
      if (RayMarchingDistance_propIsEnum.call(b, prop))
        RayMarchingDistance_defNormalProp(a, prop, b[prop]);
    }
  return a;
};





class ShaderAssemblerRayMarchingDistance extends BaseShaderAssemblerRayMarchingRendered {
  templateShader() {
    return {
      vertexShader: raymarching_vert,
      fragmentShader: raymarching_frag,
      uniforms: three_module.UniformsUtils.clone(uniforms/* RAYMARCHING_UNIFORMS */.C)
    };
  }
  // override customAssemblerClassByCustomName() {
  // 	return ASSEMBLER_MAP;
  // }
  createMaterial() {
    const templateShader = this.templateShader();
    const material = new three_module.ShaderMaterial({
      vertexShader: templateShader.vertexShader,
      fragmentShader: templateShader.fragmentShader,
      side: three_module.FrontSide,
      transparent: false,
      // important
      depthTest: true,
      alphaTest: 0.5,
      lights: false,
      defines: {
        SHADOW_DISTANCE: 1
      },
      uniforms: RayMarchingDistance_spreadValues(RayMarchingDistance_spreadValues({}, three_module.UniformsUtils.clone(three_module.ShaderLib.standard.uniforms)), three_module.UniformsUtils.clone(templateShader.uniforms))
    });
    this._gl_parent_node.scene().sceneTraverser.addLightsRayMarchingUniform(material.uniforms);
    this._addCustomMaterials(material);
    return material;
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/gl/code/assemblers/materials/RayMarching.ts

var RayMarching_defProp = Object.defineProperty;
var RayMarching_getOwnPropSymbols = Object.getOwnPropertySymbols;
var RayMarching_hasOwnProp = Object.prototype.hasOwnProperty;
var RayMarching_propIsEnum = Object.prototype.propertyIsEnumerable;
var RayMarching_defNormalProp = (obj, key, value) => key in obj ? RayMarching_defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var RayMarching_spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (RayMarching_hasOwnProp.call(b, prop))
      RayMarching_defNormalProp(a, prop, b[prop]);
  if (RayMarching_getOwnPropSymbols)
    for (var prop of RayMarching_getOwnPropSymbols(b)) {
      if (RayMarching_propIsEnum.call(b, prop))
        RayMarching_defNormalProp(a, prop, b[prop]);
    }
  return a;
};








const RayMarching_ASSEMBLER_MAP = /* @__PURE__ */ new Map([]);
RayMarching_ASSEMBLER_MAP.set(geometry_Material/* CustomMaterialName.DEPTH */.RJ.DEPTH, ShaderAssemblerRayMarchingDepth);
RayMarching_ASSEMBLER_MAP.set(geometry_Material/* CustomMaterialName.DISTANCE */.RJ.DISTANCE, ShaderAssemblerRayMarchingDistance);
class ShaderAssemblerRayMarching extends BaseShaderAssemblerRayMarchingRendered {
  templateShader() {
    return {
      vertexShader: raymarching_vert,
      fragmentShader: raymarching_frag,
      uniforms: three_module.UniformsUtils.clone(uniforms/* RAYMARCHING_UNIFORMS */.C)
    };
  }
  customAssemblerClassByCustomName() {
    return RayMarching_ASSEMBLER_MAP;
  }
  createMaterial() {
    const templateShader = this.templateShader();
    const material = new three_module.ShaderMaterial({
      vertexShader: templateShader.vertexShader,
      fragmentShader: templateShader.fragmentShader,
      side: three_module.BackSide,
      transparent: true,
      depthTest: true,
      alphaTest: 0.5,
      lights: true,
      // defines: {
      // 	ENVMAP_TYPE_CUBE_UV: 0,
      // 	CUBEUV_TEXEL_WIDTH: ThreeToGl.float(0.1),
      // 	CUBEUV_TEXEL_HEIGHT: ThreeToGl.float(0.1),
      // 	CUBEUV_MAX_MIP: ThreeToGl.float(0),
      // },
      uniforms: RayMarching_spreadValues(RayMarching_spreadValues({}, three_module.UniformsUtils.clone(three_module.ShaderLib.standard.uniforms)), three_module.UniformsUtils.clone(templateShader.uniforms))
    });
    this._gl_parent_node.scene().sceneTraverser.addLightsRayMarchingUniform(material.uniforms);
    this._addCustomMaterials(material);
    if (material.customMaterials) {
      const materialUniforms = material.uniforms;
      const customMaterials = material.customMaterials;
      const customNames = Object.keys(customMaterials);
      for (const customMaterialName of customNames) {
        const customMaterial = customMaterials[customMaterialName];
        if (customMaterial) {
          const uniforms = customMaterial.uniforms;
          uniforms.shadowDistanceMin = materialUniforms.shadowDistanceMin;
          uniforms.shadowDistanceMax = materialUniforms.shadowDistanceMax;
          uniforms.shadowDepthMin = materialUniforms.shadowDepthMin;
          uniforms.shadowDepthMax = materialUniforms.shadowDepthMax;
        }
      }
    }
    return material;
  }
}

// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/nodes/gl/code/templates/textures/Default.frag.glsl
var textures_Default_frag = __webpack_require__(54816);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/nodes/cop/utils/BuilderUtils.ts
var BuilderUtils = __webpack_require__(43306);
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/gl/code/assemblers/textures/Texture.ts










class ShaderAssemblerTexture extends assemblers_Base/* BaseGlShaderAssembler */.X {
  templateShader() {
    return {
      fragmentShader: textures_Default_frag/* default */.Z,
      vertexShader: void 0,
      uniforms: void 0
    };
  }
  fragment_shader() {
    return this._shaders_by_name.get(ShaderName/* ShaderName.FRAGMENT */.k.FRAGMENT);
  }
  uniforms() {
    return this._uniforms;
  }
  updateFragmentShader() {
    this._lines = /* @__PURE__ */ new Map();
    this._shaders_by_name = /* @__PURE__ */ new Map();
    for (const shader_name of this.shaderNames()) {
      if (shader_name == ShaderName/* ShaderName.FRAGMENT */.k.FRAGMENT) {
        const template = this.templateShader().fragmentShader;
        this._lines.set(shader_name, template.split("\n"));
      }
    }
    if (this._root_nodes.length > 0) {
      this.buildCodeFromNodes(this._root_nodes);
      this._buildLines();
    }
    this._uniforms = this._uniforms || {};
    this._gl_parent_node.scene().uniformsController.addUniforms(this._uniforms, {
      paramConfigs: this.param_configs(),
      additionalTextureUniforms: {},
      timeDependent: this.uniformsTimeDependent(),
      resolutionDependent: this.uniformsResolutionDependent(),
      raymarchingLightsWorldCoordsDependent: this._raymarchingLightsWorldCoordsDependent()
    });
    for (const shader_name of this.shaderNames()) {
      const lines = this._lines.get(shader_name);
      if (lines) {
        this._shaders_by_name.set(shader_name, lines.join("\n"));
      }
    }
    (0,BuilderUtils/* handleCopBuilderDependencies */.U)({
      node: this.currentGlParentNode(),
      timeDependent: this.uniformsTimeDependent(),
      uniforms: this._uniforms
    });
  }
  //
  //
  // CHILDREN NODES PARAMS
  //
  //
  add_output_inputs(output_child) {
    output_child.io.inputs.setNamedInputConnectionPoints([
      new Gl/* GlConnectionPoint */.E("color", Gl/* GlConnectionPointType.VEC3 */.Dv.VEC3),
      new Gl/* GlConnectionPoint */.E("alpha", Gl/* GlConnectionPointType.FLOAT */.Dv.FLOAT)
    ]);
  }
  add_globals_outputs(globals_node) {
    globals_node.io.outputs.setNamedOutputConnectionPoints([
      new Gl/* GlConnectionPoint */.E("uv", Gl/* GlConnectionPointType.VEC2 */.Dv.VEC2),
      new Gl/* GlConnectionPoint */.E("gl_FragCoord", Gl/* GlConnectionPointType.VEC4 */.Dv.VEC4),
      new Gl/* GlConnectionPoint */.E("resolution", Gl/* GlConnectionPointType.VEC2 */.Dv.VEC2),
      new Gl/* GlConnectionPoint */.E("time", Gl/* GlConnectionPointType.FLOAT */.Dv.FLOAT)
      // new Connection.Vec2('resolution'),
    ]);
  }
  //
  //
  // CONFIGS
  //
  //
  create_shader_configs() {
    return [new configs_ShaderConfig/* ShaderConfig */.E(ShaderName/* ShaderName.FRAGMENT */.k.FRAGMENT, ["color", "alpha"], [])];
  }
  create_variable_configs() {
    return [
      new VariableConfig/* VariableConfig */.P("color", {
        prefix: "diffuseColor.xyz = "
      }),
      new VariableConfig/* VariableConfig */.P("alpha", {
        prefix: "diffuseColor.a = ",
        default: "1.0"
      })
    ];
  }
  //
  //
  // TEMPLATE HOOKS
  //
  //
  insertDefineAfter(shader_name) {
    return "// INSERT DEFINE";
  }
  insertBodyAfter(shader_name) {
    return "// INSERT BODY";
  }
  linesToRemove(shader_name) {
    return ["// INSERT DEFINE", "// INSERT BODY"];
  }
  _handle_gl_FragCoord(body_lines, shaderName, var_name) {
    if (shaderName == ShaderName/* ShaderName.FRAGMENT */.k.FRAGMENT) {
      body_lines.push(`vec4 ${var_name} = gl_FragCoord`);
    }
  }
  _handle_resolution(bodyLines, shaderName, var_name) {
    if (shaderName == ShaderName/* ShaderName.FRAGMENT */.k.FRAGMENT) {
      bodyLines.push(`vec2 ${var_name} = resolution`);
    }
  }
  _handleUV(bodyLines, shaderName, var_name) {
    if (shaderName == ShaderName/* ShaderName.FRAGMENT */.k.FRAGMENT) {
      bodyLines.push(
        `vec2 ${var_name} = vec2(gl_FragCoord.x / (resolution.x-1.), gl_FragCoord.y / (resolution.y-1.))`
      );
    }
  }
  set_node_lines_output(output_node, shaders_collection_controller) {
    const input_names = this.inputNamesForShaderName(
      output_node,
      shaders_collection_controller.currentShaderName()
    );
    if (input_names) {
      for (const input_name of input_names) {
        const input = output_node.io.inputs.named_input(input_name);
        if (input) {
          const gl_var = output_node.variableForInput(input_name);
          let body_line;
          if (input_name == "color") {
            body_line = `diffuseColor.xyz = ${ThreeToGl/* ThreeToGl.any */._.any(gl_var)}`;
          }
          if (input_name == "alpha") {
            body_line = `diffuseColor.a = ${ThreeToGl/* ThreeToGl.any */._.any(gl_var)}`;
          }
          if (body_line) {
            shaders_collection_controller.addBodyLines(output_node, [body_line]);
          }
        }
      }
    }
  }
  set_node_lines_globals(globals_node, shaders_collection_controller) {
    const shader_name = shaders_collection_controller.currentShaderName();
    const shader_config = this.shader_config(shader_name);
    if (!shader_config) {
      return;
    }
    const body_lines = [];
    const definitions = [];
    for (const output_name of globals_node.io.outputs.used_output_names()) {
      const var_name = globals_node.glVarName(output_name);
      switch (output_name) {
        case "time":
          definitions.push(new GLDefinition/* UniformGLDefinition */.oA(globals_node, Gl/* GlConnectionPointType.FLOAT */.Dv.FLOAT, output_name));
          body_lines.push(`float ${var_name} = ${output_name}`);
          this.setUniformsTimeDependent();
          break;
        case "uv":
          this._handleUV(body_lines, shader_name, var_name);
          break;
        case "gl_FragCoord":
          this._handle_gl_FragCoord(body_lines, shader_name, var_name);
          break;
        case "resolution":
          this._handle_resolution(body_lines, shader_name, var_name);
          break;
      }
    }
    shaders_collection_controller.addDefinitions(globals_node, definitions, shader_name);
    shaders_collection_controller.addBodyLines(globals_node, body_lines);
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/gl/code/templates/textures/Default2DArray.frag.glsl
/* harmony default export */ var Default2DArray_frag = ("#include <common>\n\nuniform float uLayer;\nuniform vec2 resolution;\n\n// INSERT DEFINE\n\nvoid main() {\n\n\tvec4 diffuseColor = vec4(0.0,0.0,0.0,1.0);\n\n\n\t// INSERT BODY\n\n\tgl_FragColor = vec4( diffuseColor );\n}");
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/gl/code/assemblers/textures/Texture2DArray.ts










class ShaderAssemblerTexture2DArray extends assemblers_Base/* BaseGlShaderAssembler */.X {
  templateShader() {
    return {
      fragmentShader: Default2DArray_frag,
      vertexShader: void 0,
      uniforms: {
        uLayer: { value: 0 }
      }
    };
  }
  fragment_shader() {
    return this._shaders_by_name.get(ShaderName/* ShaderName.FRAGMENT */.k.FRAGMENT);
  }
  uniforms() {
    return this._uniforms;
  }
  updateFragmentShader() {
    this._lines = /* @__PURE__ */ new Map();
    this._shaders_by_name = /* @__PURE__ */ new Map();
    for (const shader_name of this.shaderNames()) {
      if (shader_name == ShaderName/* ShaderName.FRAGMENT */.k.FRAGMENT) {
        const template = this.templateShader().fragmentShader;
        this._lines.set(shader_name, template.split("\n"));
      }
    }
    if (this._root_nodes.length > 0) {
      this.buildCodeFromNodes(this._root_nodes);
      this._buildLines();
    }
    this._uniforms = this._uniforms || { uLayer: { value: 0 } };
    this._gl_parent_node.scene().uniformsController.addUniforms(this._uniforms, {
      paramConfigs: this.param_configs(),
      additionalTextureUniforms: {},
      timeDependent: this.uniformsTimeDependent(),
      resolutionDependent: this.uniformsResolutionDependent(),
      raymarchingLightsWorldCoordsDependent: this._raymarchingLightsWorldCoordsDependent()
    });
    for (const shader_name of this.shaderNames()) {
      const lines = this._lines.get(shader_name);
      if (lines) {
        this._shaders_by_name.set(shader_name, lines.join("\n"));
      }
    }
    (0,BuilderUtils/* handleCopBuilderDependencies */.U)({
      node: this.currentGlParentNode(),
      timeDependent: this.uniformsTimeDependent(),
      uniforms: this._uniforms
    });
  }
  //
  //
  // CHILDREN NODES PARAMS
  //
  //
  add_output_inputs(output_child) {
    output_child.io.inputs.setNamedInputConnectionPoints([
      new Gl/* GlConnectionPoint */.E("color", Gl/* GlConnectionPointType.VEC3 */.Dv.VEC3),
      new Gl/* GlConnectionPoint */.E("alpha", Gl/* GlConnectionPointType.FLOAT */.Dv.FLOAT)
    ]);
  }
  add_globals_outputs(globals_node) {
    globals_node.io.outputs.setNamedOutputConnectionPoints([
      new Gl/* GlConnectionPoint */.E("uv", Gl/* GlConnectionPointType.VEC2 */.Dv.VEC2),
      new Gl/* GlConnectionPoint */.E("layer", Gl/* GlConnectionPointType.FLOAT */.Dv.FLOAT),
      new Gl/* GlConnectionPoint */.E("gl_FragCoord", Gl/* GlConnectionPointType.VEC4 */.Dv.VEC4),
      new Gl/* GlConnectionPoint */.E("resolution", Gl/* GlConnectionPointType.VEC2 */.Dv.VEC2),
      new Gl/* GlConnectionPoint */.E("time", Gl/* GlConnectionPointType.FLOAT */.Dv.FLOAT)
      // new Connection.Vec2('resolution'),
    ]);
  }
  //
  //
  // CONFIGS
  //
  //
  create_shader_configs() {
    return [new configs_ShaderConfig/* ShaderConfig */.E(ShaderName/* ShaderName.FRAGMENT */.k.FRAGMENT, ["color", "alpha"], [])];
  }
  create_variable_configs() {
    return [
      new VariableConfig/* VariableConfig */.P("color", {
        prefix: "diffuseColor.xyz = "
      }),
      new VariableConfig/* VariableConfig */.P("alpha", {
        prefix: "diffuseColor.a = ",
        default: "1.0"
      })
    ];
  }
  //
  //
  // TEMPLATE HOOKS
  //
  //
  insertDefineAfter(shader_name) {
    return "// INSERT DEFINE";
  }
  insertBodyAfter(shader_name) {
    return "// INSERT BODY";
  }
  linesToRemove(shader_name) {
    return ["// INSERT DEFINE", "// INSERT BODY"];
  }
  _handle_gl_FragCoord(body_lines, shaderName, var_name) {
    if (shaderName == ShaderName/* ShaderName.FRAGMENT */.k.FRAGMENT) {
      body_lines.push(`vec4 ${var_name} = gl_FragCoord`);
    }
  }
  _handle_resolution(bodyLines, shaderName, var_name) {
    if (shaderName == ShaderName/* ShaderName.FRAGMENT */.k.FRAGMENT) {
      bodyLines.push(`vec2 ${var_name} = resolution`);
    }
  }
  _handleUVW(bodyLines, shaderName, var_name) {
    if (shaderName == ShaderName/* ShaderName.FRAGMENT */.k.FRAGMENT) {
      bodyLines.push(
        `vec2 ${var_name} = vec2(gl_FragCoord.x / (resolution.x-1.), gl_FragCoord.y / (resolution.y-1.))`
      );
    }
  }
  _handleLayer(bodyLines, shaderName, var_name) {
    if (shaderName == ShaderName/* ShaderName.FRAGMENT */.k.FRAGMENT) {
      bodyLines.push(`float ${var_name} = uLayer`);
    }
  }
  set_node_lines_output(output_node, shaders_collection_controller) {
    const input_names = this.inputNamesForShaderName(
      output_node,
      shaders_collection_controller.currentShaderName()
    );
    if (input_names) {
      for (const input_name of input_names) {
        const input = output_node.io.inputs.named_input(input_name);
        if (input) {
          const gl_var = output_node.variableForInput(input_name);
          let body_line;
          if (input_name == "color") {
            body_line = `diffuseColor.xyz = ${ThreeToGl/* ThreeToGl.any */._.any(gl_var)}`;
          }
          if (input_name == "alpha") {
            body_line = `diffuseColor.a = ${ThreeToGl/* ThreeToGl.any */._.any(gl_var)}`;
          }
          if (body_line) {
            shaders_collection_controller.addBodyLines(output_node, [body_line]);
          }
        }
      }
    }
  }
  set_node_lines_globals(globals_node, shaders_collection_controller) {
    const shader_name = shaders_collection_controller.currentShaderName();
    const shader_config = this.shader_config(shader_name);
    if (!shader_config) {
      return;
    }
    const body_lines = [];
    const definitions = [];
    for (const output_name of globals_node.io.outputs.used_output_names()) {
      const var_name = globals_node.glVarName(output_name);
      switch (output_name) {
        case "time":
          definitions.push(new GLDefinition/* UniformGLDefinition */.oA(globals_node, Gl/* GlConnectionPointType.FLOAT */.Dv.FLOAT, output_name));
          body_lines.push(`float ${var_name} = ${output_name}`);
          this.setUniformsTimeDependent();
          break;
        case "uv":
          this._handleUVW(body_lines, shader_name, var_name);
          break;
        case "layer":
          this._handleLayer(body_lines, shader_name, var_name);
          break;
        case "gl_FragCoord":
          this._handle_gl_FragCoord(body_lines, shader_name, var_name);
          break;
        case "resolution":
          this._handle_resolution(body_lines, shader_name, var_name);
          break;
      }
    }
    shaders_collection_controller.addDefinitions(globals_node, definitions, shader_name);
    shaders_collection_controller.addBodyLines(globals_node, body_lines);
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/gl/code/assemblers/materials/Toon.ts



class ShaderAssemblerToon extends ShaderAssemblerMesh {
  templateShader() {
    const template = three_module.ShaderLib.toon;
    return {
      vertexShader: template.vertexShader,
      fragmentShader: template.fragmentShader,
      uniforms: template.uniforms
    };
  }
  createMaterial() {
    const material = new three_module.MeshToonMaterial();
    this._addCustomMaterials(material);
    return material;
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/gl/code/assemblers/materials/_BaseVolume.ts


const _BaseVolume_ASSEMBLER_MAP = /* @__PURE__ */ new Map([]);
class BaseShaderAssemblerVolume extends ShaderAssemblerMaterial {
  customAssemblerClassByCustomName() {
    return _BaseVolume_ASSEMBLER_MAP;
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/gl/code/assemblers/materials/Volume.ts
















const Volume_INSERT_BODY_AFTER_MAP = /* @__PURE__ */ new Map([
  [ShaderName/* ShaderName.VERTEX */.k.VERTEX, "// start builder body code"],
  [ShaderName/* ShaderName.FRAGMENT */.k.FRAGMENT, "// start builder body code"]
]);
const Volume_LINES_TO_REMOVE_MAP = /* @__PURE__ */ new Map([[ShaderName/* ShaderName.FRAGMENT */.k.FRAGMENT, []]]);
class ShaderAssemblerVolume extends BaseShaderAssemblerVolume {
  templateShader() {
    return {
      vertexShader: vert,
      fragmentShader: frag,
      uniforms: three_module.UniformsUtils.clone(VOLUME_UNIFORMS)
    };
  }
  createMaterial() {
    const template_shader = this.templateShader();
    const material = new three_module.ShaderMaterial({
      vertexShader: template_shader.vertexShader,
      fragmentShader: template_shader.fragmentShader,
      side: three_module.FrontSide,
      transparent: true,
      depthTest: true,
      uniforms: three_module.UniformsUtils.clone(template_shader.uniforms)
    });
    (0,geometry_Material/* addUserDataRenderHook */.HP)(material, VolumeController.renderHook.bind(VolumeController));
    this._addCustomMaterials(material);
    return material;
  }
  // static add_output_inputs(output_child: OutputGlNode) {
  // 	// adding the color here would require to understand how to have the color affect the light in raymarch_light
  // 	// output_child.params.add_param(ParamType.COLOR, 'color', [1, 1, 1], {hidden: true});
  // 	// output_child.params.add_param(ParamType.VECTOR3, 'position', [0, 0, 0], {hidden: true});
  // 	// output_child.params.add_param(ParamType.FLOAT, 'density', 1, {hidden: true});
  // }
  add_output_inputs(output_child) {
    output_child.io.inputs.setNamedInputConnectionPoints([
      new Gl/* GlConnectionPoint */.E("density", Gl/* GlConnectionPointType.FLOAT */.Dv.FLOAT, 1)
    ]);
  }
  static create_globals_node_output_connections() {
    return [
      new Gl/* GlConnectionPoint */.E("position", Gl/* GlConnectionPointType.VEC3 */.Dv.VEC3),
      new Gl/* GlConnectionPoint */.E("pos_normalized", Gl/* GlConnectionPointType.VEC3 */.Dv.VEC3),
      new Gl/* GlConnectionPoint */.E("time", Gl/* GlConnectionPointType.FLOAT */.Dv.FLOAT)
    ];
  }
  create_globals_node_output_connections() {
    return ShaderAssemblerVolume.create_globals_node_output_connections();
  }
  insertBodyAfter(shader_name) {
    return Volume_INSERT_BODY_AFTER_MAP.get(shader_name);
  }
  linesToRemove(shader_name) {
    return Volume_LINES_TO_REMOVE_MAP.get(shader_name);
  }
  create_shader_configs() {
    return [
      new configs_ShaderConfig/* ShaderConfig */.E(ShaderName/* ShaderName.VERTEX */.k.VERTEX, [], []),
      new configs_ShaderConfig/* ShaderConfig */.E(ShaderName/* ShaderName.FRAGMENT */.k.FRAGMENT, [
        /*'color', */
        "density"
      ], [ShaderName/* ShaderName.VERTEX */.k.VERTEX])
    ];
  }
  static create_variable_configs() {
    return [
      new VariableConfig/* VariableConfig */.P("position", {
        // default_from_attribute: true,
        // prefix: 'vec3 transformed = ',
      }),
      // new VariableConfig('color', {
      // 	prefix: 'BUILDER_color.xyz = ',
      // }),
      new VariableConfig/* VariableConfig */.P("density", {
        prefix: "density *= "
      })
    ];
  }
  create_variable_configs() {
    return ShaderAssemblerVolume.create_variable_configs();
  }
  set_node_lines_globals(globals_node, shaders_collection_controller) {
    const body_lines = [];
    const shader_name = shaders_collection_controller.currentShaderName();
    const shader_config = this.shader_config(shader_name);
    if (!shader_config) {
      return;
    }
    const dependencies = shader_config.dependencies();
    const definitions_by_shader_name = /* @__PURE__ */ new Map();
    const body_lines_by_shader_name = /* @__PURE__ */ new Map();
    let definition;
    let body_line;
    for (const output_name of globals_node.io.outputs.used_output_names()) {
      const var_name = globals_node.glVarName(output_name);
      const globals_shader_name = shaders_collection_controller.currentShaderName();
      switch (output_name) {
        case "time":
          definition = new GLDefinition/* UniformGLDefinition */.oA(globals_node, Gl/* GlConnectionPointType.FLOAT */.Dv.FLOAT, output_name);
          if (globals_shader_name) {
            MapUtils/* MapUtils.pushOnArrayAtEntry */.pl.pushOnArrayAtEntry(definitions_by_shader_name, globals_shader_name, definition);
          }
          body_line = `float ${var_name} = ${output_name}`;
          for (const dependency of dependencies) {
            MapUtils/* MapUtils.pushOnArrayAtEntry */.pl.pushOnArrayAtEntry(definitions_by_shader_name, dependency, definition);
            MapUtils/* MapUtils.pushOnArrayAtEntry */.pl.pushOnArrayAtEntry(body_lines_by_shader_name, dependency, body_line);
          }
          body_lines.push(body_line);
          this.setUniformsTimeDependent();
          break;
        case "position":
          if (shader_name == ShaderName/* ShaderName.FRAGMENT */.k.FRAGMENT) {
            body_lines.push(`vec3 ${var_name} = position_for_step`);
          }
          break;
        case "pos_normalized":
          if (shader_name == ShaderName/* ShaderName.FRAGMENT */.k.FRAGMENT) {
            body_lines.push(
              `vec3 ${var_name} = (position_for_step - u_BoundingBoxMax) / (u_BoundingBoxMax - u_BoundingBoxMin)`
            );
          }
          break;
      }
    }
    definitions_by_shader_name.forEach((definitions, shader_name2) => {
      shaders_collection_controller.addDefinitions(globals_node, definitions, shader_name2);
    });
    body_lines_by_shader_name.forEach((body_lines2, shader_name2) => {
      shaders_collection_controller.addBodyLines(globals_node, body_lines2, shader_name2);
    });
    shaders_collection_controller.addBodyLines(globals_node, body_lines);
  }
}

// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/nodes/js/code/assemblers/entityBuilder/EntityBuilderAssemblerCommon.ts
var EntityBuilderAssemblerCommon = __webpack_require__(13082);
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/js/code/assemblers/entityBuilder/_BaseEntityBuilderAssembler.ts








const _BaseEntityBuilderAssembler_TEMPLATE = `
${code_assemblers_Base/* INSERT_DEFINE_AFTER */.Zf}
${code_assemblers_Base/* INSERT_MEMBERS_AFTER */.FD}
${code_assemblers_Base/* INSERT_CONSTRUCTOR_AFTER */.Yx}
const __EVALUATOR_NAME___ = function(){
	${code_assemblers_Base/* INSERT_BODY_AFTER */.xP}
`;
const _BaseEntityBuilderAssembler_CLOSE_CLASS_DEFINITION = `};
return __EVALUATOR_NAME___;`;
class JsAssemblerBaseEntityBuilder extends code_assemblers_Base/* BaseJsShaderAssembler */.SD {
  makeFunctionNodeDirtyOnChange() {
    return true;
  }
  templateShader() {
    return {
      main: _BaseEntityBuilderAssembler_TEMPLATE.replace(/__EVALUATOR_NAME___/g, this._evaluatorName())
    };
  }
  _closeClassDefinition() {
    return _BaseEntityBuilderAssembler_CLOSE_CLASS_DEFINITION.replace(/__EVALUATOR_NAME___/g, this._evaluatorName());
  }
  _evaluatorName() {
    return "BaseEntityBuilderEvaluator";
  }
  spareParamsOptions(options) {
    const _options = {
      spare: true,
      // computeOnDirty: true, // not needed if cook option is not set
      // cook: false, // for SDFBuilder, the node needs to recook
      // important for texture nodes
      // that compute after being found by the nodepath param
      dependentOnFoundNode: true
    };
    return _options;
  }
  defaultObjectVariable() {
    return EntityBuilderAssemblerCommon/* EntityBuilderAssemblerConstant.OBJECT */.k.OBJECT;
  }
  defaultObject3DMaterialVariable() {
    return EntityBuilderAssemblerCommon/* EntityBuilderAssemblerConstant.MATERIAL */.k.MATERIAL;
  }
  defaultPrimitiveGraph() {
    return EntityBuilderAssemblerCommon/* EntityBuilderAssemblerConstant.PRIMITIVE_GRAPH */.k.PRIMITIVE_GRAPH;
  }
  functionData() {
    var _a;
    const _buildFunctionBody = () => {
      const bodyLines = this._shaders_by_name.get(ShaderName/* JsFunctionName.MAIN */.J.MAIN) || _BaseEntityBuilderAssembler_TEMPLATE;
      const functionBodyElements = [
        bodyLines,
        // triggerableFunctionLines.join('\n'),
        // triggerFunctionLines.join('\n'),
        this._closeClassDefinition()
      ];
      const functionBody2 = PrettierController/* PrettierController.formatJs */.u.formatJs(functionBodyElements.join("\n"));
      return functionBody2;
    };
    const functionBody = _buildFunctionBody();
    if (!functionBody) {
      return;
    }
    const variableNames = [];
    const functionNames = [];
    const variablesByName = {};
    const functionsByName = {};
    this.traverseRegisteredVariables((variable, varName) => {
      variableNames.push(varName);
      variablesByName[varName] = variable;
    });
    this.traverseRegisteredFunctions((namedFunction) => {
      functionNames.push(namedFunction.type());
      functionsByName[namedFunction.type()] = namedFunction.func.bind(namedFunction);
    });
    const attribNodes = [];
    (_a = this.currentJsParentNode().childrenController) == null ? void 0 : _a.traverseChildren((child) => {
      if (child.context() == poly_NodeContext/* NodeContext.JS */.sy.JS && child.type() == Js/* JsType.ATTRIBUTE */.K.ATTRIBUTE) {
        attribNodes.push(child);
      }
    });
    const attributesRead = attribNodes.filter((n) => n.isImporting()).map((attribNode) => attribNode.attribData());
    const attributesWrite = attribNodes.filter((n) => n.isExporting()).map((attribNode) => attribNode.attribData());
    const paramConfigs = this.param_configs();
    return {
      functionBody,
      variableNames,
      variablesByName,
      functionNames,
      functionsByName,
      paramConfigs: [...paramConfigs],
      attributesData: {
        read: attributesRead,
        write: attributesWrite
      }
    };
  }
  updateFunction() {
    super.updateFunction();
    this._lines = /* @__PURE__ */ new Map();
    this._shaders_by_name = /* @__PURE__ */ new Map();
    const shaderNames = this.shaderNames();
    if (this._root_nodes.length > 0) {
      this.buildCodeFromNodes(this._root_nodes);
      this._buildLines();
    }
    for (const shaderName of shaderNames) {
      const lines = this._lines.get(shaderName);
      if (lines) {
        this._shaders_by_name.set(shaderName, lines.join("\n"));
      }
    }
  }
  setNodeLinesAttribute(attributeNode, linesController) {
    const shaderName = linesController.currentShaderName();
    const shaderConfig = this.shader_config(shaderName);
    if (!shaderConfig) {
      return;
    }
    const bodyLines = [];
    const attribName = attributeNode.attributeName();
    if (attributeNode.isExporting()) {
      const exportedValue = attributeNode.variableForInput(linesController, js_Attribute/* AttributeJsNodeInput.EXPORT */.Hh.EXPORT);
      const bodyLine = `${EntityBuilderAssemblerCommon/* EntityBuilderAssemblerConstant.ATTRIBUTES_DICT */.k.ATTRIBUTES_DICT}.set('${attribName}', ${exportedValue})`;
      bodyLines.push(bodyLine);
    }
    const usedOutputNames = attributeNode.io.outputs.used_output_names();
    for (const outputName of usedOutputNames) {
      const varName = attributeNode.jsVarName(outputName);
      const bodyLine = `${varName} = ${EntityBuilderAssemblerCommon/* EntityBuilderAssemblerConstant.ATTRIBUTES_DICT */.k.ATTRIBUTES_DICT}.get('${attribName}')`;
      bodyLines.push(bodyLine);
    }
    linesController._addBodyLines(attributeNode, bodyLines);
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/js/code/assemblers/entityBuilder/EntityBuilderAssembler.ts








class JsAssemblerEntityBuilder extends JsAssemblerBaseEntityBuilder {
  _evaluatorName() {
    return "CustomEntityBuilderEvaluator";
  }
  //
  //
  // CHILDREN NODES PARAMS
  //
  //
  add_output_inputs(output_child) {
    output_child.io.inputs.setNamedInputConnectionPoints([
      // new JsConnectionPoint(EntityVariable.POSITION, JsConnectionPointType.VECTOR3),
      // new JsConnectionPoint(EntityVariable.NORMAL, JsConnectionPointType.VECTOR3),
    ]);
  }
  add_globals_outputs(globals_node) {
    globals_node.io.outputs.setNamedOutputConnectionPoints([
      new connections_Js/* JsConnectionPoint */.fp(EntityBuilderAssemblerCommon/* EntityVariable.POSITION */.T.POSITION, connections_Js/* JsConnectionPointType.VECTOR3 */.zF.VECTOR3),
      new connections_Js/* JsConnectionPoint */.fp(EntityBuilderAssemblerCommon/* EntityVariable.NORMAL */.T.NORMAL, connections_Js/* JsConnectionPointType.VECTOR3 */.zF.VECTOR3),
      new connections_Js/* JsConnectionPoint */.fp(EntityBuilderAssemblerCommon/* EntityVariable.INDEX */.T.INDEX, connections_Js/* JsConnectionPointType.INT */.zF.INT),
      new connections_Js/* JsConnectionPoint */.fp(EntityBuilderAssemblerCommon/* EntityVariable.OBJNUM */.T.OBJNUM, connections_Js/* JsConnectionPointType.INT */.zF.INT)
    ]);
  }
  //
  //
  // CONFIGS
  //
  //
  create_shader_configs() {
    return [
      new ShaderConfig/* JsShaderConfig */.s(
        ShaderName/* JsFunctionName.MAIN */.J.MAIN,
        [
          EntityBuilderAssemblerCommon/* EntityVariable.POSITION */.T.POSITION,
          EntityBuilderAssemblerCommon/* EntityVariable.NORMAL */.T.NORMAL,
          // attribute
          js_Attribute/* AttributeJsNodeInput.EXPORT */.Hh.EXPORT
        ],
        []
      )
    ];
  }
  create_variable_configs() {
    return [
      // new VariableConfig(EntityVariable.POSITION, {
      // 	prefix: 'return ',
      // }),
      // new VariableConfig(EntityVariable.NORMAL, {
      // 	prefix: 'return ',
      // }),
    ];
  }
  //
  //
  // NODE LINES
  //
  //
  setNodeLinesOutput(outputNode, linesController) {
  }
  setNodeLinesGlobals(globalsNode, linesController) {
    const shaderName = linesController.currentShaderName();
    const shaderConfig = this.shader_config(shaderName);
    if (!shaderConfig) {
      return;
    }
    const bodyLines = [];
    const usedOutputNames = globalsNode.io.outputs.used_output_names();
    for (const outputName of usedOutputNames) {
      const varName = globalsNode.jsVarName(outputName);
      switch (outputName) {
        case EntityBuilderAssemblerCommon/* EntityVariable.POSITION */.T.POSITION:
        case EntityBuilderAssemblerCommon/* EntityVariable.NORMAL */.T.NORMAL: {
          linesController.addVariable(globalsNode, new three_module.Vector3(), varName);
          bodyLines.push(`${varName}.copy(${EntityBuilderAssemblerCommon/* EntityBuilderAssemblerConstant.ENTITY_CONTAINER */.k.ENTITY_CONTAINER}.${outputName})`);
          break;
        }
        case EntityBuilderAssemblerCommon/* EntityVariable.OBJNUM */.T.OBJNUM:
        case EntityBuilderAssemblerCommon/* EntityVariable.INDEX */.T.INDEX: {
          bodyLines.push(`${varName}= ${EntityBuilderAssemblerCommon/* EntityBuilderAssemblerConstant.ENTITY_CONTAINER */.k.ENTITY_CONTAINER}.${outputName}`);
        }
      }
    }
    linesController._addBodyLines(globalsNode, bodyLines);
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/js/code/assemblers/pointBuilder/_BasePointBuilderAssembler.ts








const _BasePointBuilderAssembler_TEMPLATE = `
${code_assemblers_Base/* INSERT_DEFINE_AFTER */.Zf}
${code_assemblers_Base/* INSERT_MEMBERS_AFTER */.FD}
${code_assemblers_Base/* INSERT_CONSTRUCTOR_AFTER */.Yx}
const __EVALUATOR_NAME___ = function(){
	${code_assemblers_Base/* INSERT_BODY_AFTER */.xP}
`;
const _BasePointBuilderAssembler_CLOSE_CLASS_DEFINITION = `};
return __EVALUATOR_NAME___;`;
class JsAssemblerBasePointBuilder extends code_assemblers_Base/* BaseJsShaderAssembler */.SD {
  makeFunctionNodeDirtyOnChange() {
    return true;
  }
  templateShader() {
    return {
      main: _BasePointBuilderAssembler_TEMPLATE.replace(/__EVALUATOR_NAME___/g, this._evaluatorName())
    };
  }
  _closeClassDefinition() {
    return _BasePointBuilderAssembler_CLOSE_CLASS_DEFINITION.replace(/__EVALUATOR_NAME___/g, this._evaluatorName());
  }
  _evaluatorName() {
    return "BasePointBuilderEvaluator";
  }
  spareParamsOptions(options) {
    const _options = {
      spare: true,
      // computeOnDirty: true, // not needed if cook option is not set
      // cook: false, // for SDFBuilder, the node needs to recook
      // important for texture nodes
      // that compute after being found by the nodepath param
      dependentOnFoundNode: true
    };
    return _options;
  }
  defaultObjectVariable() {
    return PointBuilderAssemblerCommon/* PointBuilderAssemblerConstant.OBJECT_3D */.X.OBJECT_3D;
  }
  defaultObject3DMaterialVariable() {
    return PointBuilderAssemblerCommon/* PointBuilderAssemblerConstant.MATERIAL */.X.MATERIAL;
  }
  defaultPrimitiveGraph() {
    return PointBuilderAssemblerCommon/* PointBuilderAssemblerConstant.PRIMITIVE_GRAPH */.X.PRIMITIVE_GRAPH;
  }
  functionData() {
    var _a;
    const _buildFunctionBody = () => {
      const bodyLines = this._shaders_by_name.get(ShaderName/* JsFunctionName.MAIN */.J.MAIN) || _BasePointBuilderAssembler_TEMPLATE;
      const functionBodyElements = [
        bodyLines,
        // triggerableFunctionLines.join('\n'),
        // triggerFunctionLines.join('\n'),
        this._closeClassDefinition()
      ];
      const functionBody2 = PrettierController/* PrettierController.formatJs */.u.formatJs(functionBodyElements.join("\n"));
      return functionBody2;
    };
    const functionBody = _buildFunctionBody();
    if (!functionBody) {
      return;
    }
    const variableNames = [];
    const functionNames = [];
    const variablesByName = {};
    const functionsByName = {};
    this.traverseRegisteredVariables((variable, varName) => {
      variableNames.push(varName);
      variablesByName[varName] = variable;
    });
    this.traverseRegisteredFunctions((namedFunction) => {
      functionNames.push(namedFunction.type());
      functionsByName[namedFunction.type()] = namedFunction.func.bind(namedFunction);
    });
    const attribNodes = [];
    (_a = this.currentJsParentNode().childrenController) == null ? void 0 : _a.traverseChildren((child) => {
      if (child.context() == poly_NodeContext/* NodeContext.JS */.sy.JS && child.type() == Js/* JsType.ATTRIBUTE */.K.ATTRIBUTE) {
        attribNodes.push(child);
      }
    });
    const attributesRead = attribNodes.filter((n) => n.isImporting()).map((attribNode) => attribNode.attribData());
    const attributesWrite = attribNodes.filter((n) => n.isExporting()).map((attribNode) => attribNode.attribData());
    const paramConfigs = this.param_configs();
    return {
      functionBody,
      variableNames,
      variablesByName,
      functionNames,
      functionsByName,
      paramConfigs: [...paramConfigs],
      attributesData: {
        read: attributesRead,
        write: attributesWrite
      }
    };
  }
  updateFunction() {
    super.updateFunction();
    this._lines = /* @__PURE__ */ new Map();
    this._shaders_by_name = /* @__PURE__ */ new Map();
    const shaderNames = this.shaderNames();
    if (this._root_nodes.length > 0) {
      this.buildCodeFromNodes(this._root_nodes);
      this._buildLines();
    }
    for (const shaderName of shaderNames) {
      const lines = this._lines.get(shaderName);
      if (lines) {
        this._shaders_by_name.set(shaderName, lines.join("\n"));
      }
    }
  }
  setNodeLinesAttribute(attributeNode, linesController) {
    const shaderName = linesController.currentShaderName();
    const shaderConfig = this.shader_config(shaderName);
    if (!shaderConfig) {
      return;
    }
    const bodyLines = [];
    const attribName = attributeNode.attributeName();
    if (attributeNode.isExporting()) {
      const exportedValue = attributeNode.variableForInput(linesController, js_Attribute/* AttributeJsNodeInput.EXPORT */.Hh.EXPORT);
      const bodyLine = `${PointBuilderAssemblerCommon/* PointBuilderAssemblerConstant.ATTRIBUTES_DICT */.X.ATTRIBUTES_DICT}.set('${attribName}', ${exportedValue})`;
      bodyLines.push(bodyLine);
    }
    const usedOutputNames = attributeNode.io.outputs.used_output_names();
    for (const outputName of usedOutputNames) {
      const varName = attributeNode.jsVarName(outputName);
      const bodyLine = `${varName} = ${PointBuilderAssemblerCommon/* PointBuilderAssemblerConstant.ATTRIBUTES_DICT */.X.ATTRIBUTES_DICT}.get('${attribName}')`;
      bodyLines.push(bodyLine);
    }
    linesController._addBodyLines(attributeNode, bodyLines);
  }
}

// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/nodes/js/code/configs/VariableConfig.ts
var configs_VariableConfig = __webpack_require__(40617);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/nodes/js/code/assemblers/instanceBuilder/InstanceBuilderAssemblerCommon.ts
var InstanceBuilderAssemblerCommon = __webpack_require__(28268);
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/js/code/assemblers/instanceBuilder/InstanceBuilderAssembler.ts









class JsAssemblerInstanceBuilder extends JsAssemblerBasePointBuilder {
  _evaluatorName() {
    return "CustomPointBuilderEvaluator";
  }
  //
  //
  // CHILDREN NODES PARAMS
  //
  //
  add_output_inputs(output_child) {
    output_child.io.inputs.setNamedInputConnectionPoints([
      new connections_Js/* JsConnectionPoint */.fp(InstanceBuilderAssemblerCommon/* InstanceVariable.INSTANCE_POSITION */.o.INSTANCE_POSITION, connections_Js/* JsConnectionPointType.VECTOR3 */.zF.VECTOR3),
      new connections_Js/* JsConnectionPoint */.fp(InstanceBuilderAssemblerCommon/* InstanceVariable.INSTANCE_QUATERNION */.o.INSTANCE_QUATERNION, connections_Js/* JsConnectionPointType.QUATERNION */.zF.QUATERNION),
      new connections_Js/* JsConnectionPoint */.fp(InstanceBuilderAssemblerCommon/* InstanceVariable.INSTANCE_SCALE */.o.INSTANCE_SCALE, connections_Js/* JsConnectionPointType.VECTOR3 */.zF.VECTOR3)
    ]);
  }
  add_globals_outputs(globals_node) {
    globals_node.io.outputs.setNamedOutputConnectionPoints([
      new connections_Js/* JsConnectionPoint */.fp(InstanceBuilderAssemblerCommon/* InstanceVariable.INSTANCE_POSITION */.o.INSTANCE_POSITION, connections_Js/* JsConnectionPointType.VECTOR3 */.zF.VECTOR3),
      new connections_Js/* JsConnectionPoint */.fp(InstanceBuilderAssemblerCommon/* InstanceVariable.INSTANCE_QUATERNION */.o.INSTANCE_QUATERNION, connections_Js/* JsConnectionPointType.QUATERNION */.zF.QUATERNION),
      new connections_Js/* JsConnectionPoint */.fp(InstanceBuilderAssemblerCommon/* InstanceVariable.INSTANCE_SCALE */.o.INSTANCE_SCALE, connections_Js/* JsConnectionPointType.VECTOR3 */.zF.VECTOR3),
      new connections_Js/* JsConnectionPoint */.fp(InstanceBuilderAssemblerCommon/* InstanceVariable.PTNUM */.o.PTNUM, connections_Js/* JsConnectionPointType.INT */.zF.INT),
      new connections_Js/* JsConnectionPoint */.fp(InstanceBuilderAssemblerCommon/* InstanceVariable.OBJNUM */.o.OBJNUM, connections_Js/* JsConnectionPointType.INT */.zF.INT)
    ]);
  }
  //
  //
  // CONFIGS
  //
  //
  create_shader_configs() {
    return [
      new ShaderConfig/* JsShaderConfig */.s(
        ShaderName/* JsFunctionName.MAIN */.J.MAIN,
        [
          InstanceBuilderAssemblerCommon/* InstanceVariable.INSTANCE_POSITION */.o.INSTANCE_POSITION,
          InstanceBuilderAssemblerCommon/* InstanceVariable.INSTANCE_QUATERNION */.o.INSTANCE_QUATERNION,
          InstanceBuilderAssemblerCommon/* InstanceVariable.INSTANCE_SCALE */.o.INSTANCE_SCALE,
          // attribute
          js_Attribute/* AttributeJsNodeInput.EXPORT */.Hh.EXPORT
        ],
        []
      )
    ];
  }
  create_variable_configs() {
    return [
      new configs_VariableConfig/* VariableConfig */.P(InstanceBuilderAssemblerCommon/* InstanceVariable.INSTANCE_POSITION */.o.INSTANCE_POSITION, {
        prefix: "return "
      }),
      new configs_VariableConfig/* VariableConfig */.P(InstanceBuilderAssemblerCommon/* InstanceVariable.INSTANCE_QUATERNION */.o.INSTANCE_QUATERNION, {
        prefix: "return "
      }),
      new configs_VariableConfig/* VariableConfig */.P(InstanceBuilderAssemblerCommon/* InstanceVariable.INSTANCE_SCALE */.o.INSTANCE_SCALE, {
        prefix: "return "
      })
    ];
  }
  //
  //
  // NODE LINES
  //
  //
  setNodeLinesOutput(outputNode, linesController) {
    const inputNames = this.inputNamesForShaderName(outputNode, linesController.currentShaderName());
    if (inputNames) {
      for (const inputName of inputNames) {
        const input = outputNode.io.inputs.named_input(inputName);
        if (input) {
          const varName = outputNode.variableForInput(linesController, inputName);
          let bodyLine;
          switch (inputName) {
            case InstanceBuilderAssemblerCommon/* InstanceVariable.INSTANCE_POSITION */.o.INSTANCE_POSITION: {
              bodyLine = `${InstanceBuilderAssemblerCommon/* InstanceBuilderAssemblerConstant.INSTANCE_POSITION */.i.INSTANCE_POSITION}.copy(${varName})`;
              break;
            }
            case InstanceBuilderAssemblerCommon/* InstanceVariable.INSTANCE_QUATERNION */.o.INSTANCE_QUATERNION: {
              bodyLine = `${InstanceBuilderAssemblerCommon/* InstanceBuilderAssemblerConstant.INSTANCE_QUATERNION */.i.INSTANCE_QUATERNION}.copy(${varName})`;
              break;
            }
            case InstanceBuilderAssemblerCommon/* InstanceVariable.INSTANCE_SCALE */.o.INSTANCE_SCALE: {
              bodyLine = `${InstanceBuilderAssemblerCommon/* InstanceBuilderAssemblerConstant.INSTANCE_SCALE */.i.INSTANCE_SCALE}.copy(${varName})`;
              break;
            }
          }
          if (bodyLine) {
            linesController._addBodyLines(outputNode, [bodyLine]);
          }
        }
      }
    }
  }
  setNodeLinesGlobals(globalsNode, linesController) {
    const shaderName = linesController.currentShaderName();
    const shaderConfig = this.shader_config(shaderName);
    if (!shaderConfig) {
      return;
    }
    const bodyLines = [];
    const usedOutputNames = globalsNode.io.outputs.used_output_names();
    for (const outputName of usedOutputNames) {
      const varName = globalsNode.jsVarName(outputName);
      switch (outputName) {
        case InstanceBuilderAssemblerCommon/* InstanceVariable.INSTANCE_POSITION */.o.INSTANCE_POSITION:
        case InstanceBuilderAssemblerCommon/* InstanceVariable.INSTANCE_SCALE */.o.INSTANCE_SCALE: {
          linesController.addVariable(globalsNode, new three_module.Vector3(), varName);
          bodyLines.push(
            `${varName}.copy(${InstanceBuilderAssemblerCommon/* InstanceBuilderAssemblerConstant.POINT_CONTAINER */.i.POINT_CONTAINER}.${outputName})`
          );
          break;
        }
        case InstanceBuilderAssemblerCommon/* InstanceVariable.INSTANCE_QUATERNION */.o.INSTANCE_QUATERNION: {
          linesController.addVariable(globalsNode, new three_module.Quaternion(), varName);
          bodyLines.push(
            `${varName}.copy(${InstanceBuilderAssemblerCommon/* InstanceBuilderAssemblerConstant.POINT_CONTAINER */.i.POINT_CONTAINER}.${outputName})`
          );
          break;
        }
        case InstanceBuilderAssemblerCommon/* InstanceVariable.OBJNUM */.o.OBJNUM:
        case InstanceBuilderAssemblerCommon/* InstanceVariable.PTNUM */.o.PTNUM: {
          bodyLines.push(`${varName}= ${InstanceBuilderAssemblerCommon/* InstanceBuilderAssemblerConstant.POINT_CONTAINER */.i.POINT_CONTAINER}.${outputName}`);
        }
      }
    }
    linesController._addBodyLines(globalsNode, bodyLines);
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/js/code/assemblers/objectBuilder/ObjectBuilderAssembler.ts











const ObjectBuilderAssembler_TEMPLATE = `
${code_assemblers_Base/* INSERT_DEFINE_AFTER */.Zf}
${code_assemblers_Base/* INSERT_MEMBERS_AFTER */.FD}
${code_assemblers_Base/* INSERT_CONSTRUCTOR_AFTER */.Yx}
const CustomObjectBuilderEvaluator = function(){
	${code_assemblers_Base/* INSERT_BODY_AFTER */.xP}
`;
const ObjectBuilderAssembler_CLOSE_CLASS_DEFINITION = `};
return CustomObjectBuilderEvaluator;`;
class JsAssemblerObjectBuilder extends code_assemblers_Base/* BaseJsShaderAssembler */.SD {
  // private _function: Function | undefined;
  // private _uniforms: IUniforms | undefined;
  // private _functionsByName: Map<string, Function> = new Map();
  makeFunctionNodeDirtyOnChange() {
    return true;
  }
  templateShader() {
    return {
      main: ObjectBuilderAssembler_TEMPLATE
    };
  }
  spareParamsOptions(options) {
    const _options = {
      spare: true,
      // computeOnDirty: true, // not needed if cook option is not set
      // cook: false, // for SDFBuilder, the node needs to recook
      // important for texture nodes
      // that compute after being found by the nodepath param
      dependentOnFoundNode: true
    };
    return _options;
  }
  functionData() {
    const _buildFunctionBody = () => {
      const bodyLines = this._shaders_by_name.get(ShaderName/* JsFunctionName.MAIN */.J.MAIN) || ObjectBuilderAssembler_TEMPLATE;
      const functionBodyElements = [
        bodyLines,
        // triggerableFunctionLines.join('\n'),
        // triggerFunctionLines.join('\n'),
        ObjectBuilderAssembler_CLOSE_CLASS_DEFINITION
      ];
      const functionBody2 = PrettierController/* PrettierController.formatJs */.u.formatJs(functionBodyElements.join("\n"));
      return functionBody2;
    };
    const functionBody = _buildFunctionBody();
    if (!functionBody) {
      return;
    }
    const variableNames = [];
    const functionNames = [];
    const variablesByName = {};
    const functionsByName = {};
    this.traverseRegisteredVariables((variable, varName) => {
      variableNames.push(varName);
      variablesByName[varName] = variable;
    });
    this.traverseRegisteredFunctions((namedFunction) => {
      functionNames.push(namedFunction.type());
      functionsByName[namedFunction.type()] = namedFunction.func.bind(namedFunction);
    });
    const paramConfigs = this.param_configs();
    return {
      functionBody,
      variableNames,
      variablesByName,
      functionNames,
      functionsByName,
      paramConfigs: [...paramConfigs]
    };
  }
  // uniforms() {
  // 	return this._uniforms;
  // }
  // evalFunction(position: Vector3) {
  // 	if (this._function) {
  // 		return this._function(position);
  // 	}
  // }
  defaultObjectVariable() {
    return ObjectBuilderAssemblerCommon/* ObjectBuilderAssemblerConstant.OBJECT_3D */.F.OBJECT_3D;
  }
  defaultObject3DMaterialVariable() {
    return ObjectBuilderAssemblerCommon/* ObjectBuilderAssemblerConstant.MATERIAL */.F.MATERIAL;
  }
  defaultPrimitiveGraph() {
    return ObjectBuilderAssemblerCommon/* ObjectBuilderAssemblerConstant.PRIMITIVE_GRAPH */.F.PRIMITIVE_GRAPH;
  }
  updateFunction() {
    super.updateFunction();
    this._lines = /* @__PURE__ */ new Map();
    this._shaders_by_name = /* @__PURE__ */ new Map();
    const shaderNames = this.shaderNames();
    if (this._root_nodes.length > 0) {
      this.buildCodeFromNodes(this._root_nodes);
      this._buildLines();
    }
    for (const shaderName of shaderNames) {
      const lines = this._lines.get(shaderName);
      if (lines) {
        this._shaders_by_name.set(shaderName, lines.join("\n"));
      }
    }
  }
  //
  //
  // CHILDREN NODES PARAMS
  //
  //
  add_output_inputs(outputNode) {
    outputNode.io.inputs.setNamedInputConnectionPoints([
      new connections_Js/* JsConnectionPoint */.fp(ObjectBuilderAssemblerCommon/* ObjectVariable.POSITION */.K.POSITION, connections_Js/* JsConnectionPointType.VECTOR3 */.zF.VECTOR3),
      new connections_Js/* JsConnectionPoint */.fp(ObjectBuilderAssemblerCommon/* ObjectVariable.ROTATION */.K.ROTATION, connections_Js/* JsConnectionPointType.EULER */.zF.EULER),
      new connections_Js/* JsConnectionPoint */.fp(ObjectBuilderAssemblerCommon/* ObjectVariable.QUATERNION */.K.QUATERNION, connections_Js/* JsConnectionPointType.QUATERNION */.zF.QUATERNION),
      new connections_Js/* JsConnectionPoint */.fp(ObjectBuilderAssemblerCommon/* ObjectVariable.SCALE */.K.SCALE, connections_Js/* JsConnectionPointType.VECTOR3 */.zF.VECTOR3),
      new connections_Js/* JsConnectionPoint */.fp(ObjectBuilderAssemblerCommon/* ObjectVariable.MATRIX */.K.MATRIX, connections_Js/* JsConnectionPointType.MATRIX4 */.zF.MATRIX4),
      new connections_Js/* JsConnectionPoint */.fp(ObjectBuilderAssemblerCommon/* ObjectVariable.VISIBLE */.K.VISIBLE, connections_Js/* JsConnectionPointType.BOOLEAN */.zF.BOOLEAN),
      new connections_Js/* JsConnectionPoint */.fp(ObjectBuilderAssemblerCommon/* ObjectVariable.MATRIX_AUTO_UPDATE */.K.MATRIX_AUTO_UPDATE, connections_Js/* JsConnectionPointType.BOOLEAN */.zF.BOOLEAN),
      new connections_Js/* JsConnectionPoint */.fp(ObjectBuilderAssemblerCommon/* ObjectVariable.CAST_SHADOW */.K.CAST_SHADOW, connections_Js/* JsConnectionPointType.BOOLEAN */.zF.BOOLEAN),
      new connections_Js/* JsConnectionPoint */.fp(ObjectBuilderAssemblerCommon/* ObjectVariable.RECEIVE_SHADOW */.K.RECEIVE_SHADOW, connections_Js/* JsConnectionPointType.BOOLEAN */.zF.BOOLEAN),
      new connections_Js/* JsConnectionPoint */.fp(ObjectBuilderAssemblerCommon/* ObjectVariable.FRUSTUM_CULLED */.K.FRUSTUM_CULLED, connections_Js/* JsConnectionPointType.BOOLEAN */.zF.BOOLEAN)
    ]);
  }
  add_globals_outputs(globals_node) {
    globals_node.io.outputs.setNamedOutputConnectionPoints([
      new connections_Js/* JsConnectionPoint */.fp(ObjectBuilderAssemblerCommon/* ObjectVariable.OBJECT_3D */.K.OBJECT_3D, connections_Js/* JsConnectionPointType.OBJECT_3D */.zF.OBJECT_3D),
      new connections_Js/* JsConnectionPoint */.fp(ObjectBuilderAssemblerCommon/* ObjectVariable.POSITION */.K.POSITION, connections_Js/* JsConnectionPointType.VECTOR3 */.zF.VECTOR3),
      new connections_Js/* JsConnectionPoint */.fp(ObjectBuilderAssemblerCommon/* ObjectVariable.ROTATION */.K.ROTATION, connections_Js/* JsConnectionPointType.EULER */.zF.EULER),
      new connections_Js/* JsConnectionPoint */.fp(ObjectBuilderAssemblerCommon/* ObjectVariable.QUATERNION */.K.QUATERNION, connections_Js/* JsConnectionPointType.QUATERNION */.zF.QUATERNION),
      new connections_Js/* JsConnectionPoint */.fp(ObjectBuilderAssemblerCommon/* ObjectVariable.SCALE */.K.SCALE, connections_Js/* JsConnectionPointType.VECTOR3 */.zF.VECTOR3),
      new connections_Js/* JsConnectionPoint */.fp(ObjectBuilderAssemblerCommon/* ObjectVariable.MATRIX */.K.MATRIX, connections_Js/* JsConnectionPointType.MATRIX4 */.zF.MATRIX4),
      new connections_Js/* JsConnectionPoint */.fp(ObjectBuilderAssemblerCommon/* ObjectVariable.VISIBLE */.K.VISIBLE, connections_Js/* JsConnectionPointType.BOOLEAN */.zF.BOOLEAN),
      new connections_Js/* JsConnectionPoint */.fp(ObjectBuilderAssemblerCommon/* ObjectVariable.MATRIX_AUTO_UPDATE */.K.MATRIX_AUTO_UPDATE, connections_Js/* JsConnectionPointType.BOOLEAN */.zF.BOOLEAN),
      new connections_Js/* JsConnectionPoint */.fp(ObjectBuilderAssemblerCommon/* ObjectVariable.CAST_SHADOW */.K.CAST_SHADOW, connections_Js/* JsConnectionPointType.BOOLEAN */.zF.BOOLEAN),
      new connections_Js/* JsConnectionPoint */.fp(ObjectBuilderAssemblerCommon/* ObjectVariable.RECEIVE_SHADOW */.K.RECEIVE_SHADOW, connections_Js/* JsConnectionPointType.BOOLEAN */.zF.BOOLEAN),
      new connections_Js/* JsConnectionPoint */.fp(ObjectBuilderAssemblerCommon/* ObjectVariable.FRUSTUM_CULLED */.K.FRUSTUM_CULLED, connections_Js/* JsConnectionPointType.BOOLEAN */.zF.BOOLEAN),
      new connections_Js/* JsConnectionPoint */.fp(ObjectBuilderAssemblerCommon/* ObjectVariable.OBJ_NUM */.K.OBJ_NUM, connections_Js/* JsConnectionPointType.INT */.zF.INT)
    ]);
  }
  //
  //
  // CONFIGS
  //
  //
  create_shader_configs() {
    return [
      new ShaderConfig/* JsShaderConfig */.s(
        ShaderName/* JsFunctionName.MAIN */.J.MAIN,
        [
          ObjectBuilderAssemblerCommon/* ObjectVariable.POSITION */.K.POSITION,
          ObjectBuilderAssemblerCommon/* ObjectVariable.ROTATION */.K.ROTATION,
          ObjectBuilderAssemblerCommon/* ObjectVariable.QUATERNION */.K.QUATERNION,
          ObjectBuilderAssemblerCommon/* ObjectVariable.SCALE */.K.SCALE,
          ObjectBuilderAssemblerCommon/* ObjectVariable.MATRIX */.K.MATRIX,
          ObjectBuilderAssemblerCommon/* ObjectVariable.VISIBLE */.K.VISIBLE,
          // attribute
          js_Attribute/* AttributeJsNodeInput.EXPORT */.Hh.EXPORT
        ],
        []
      )
    ];
  }
  create_variable_configs() {
    return [
      new configs_VariableConfig/* VariableConfig */.P(ObjectBuilderAssemblerCommon/* ObjectVariable.POSITION */.K.POSITION, {
        prefix: "return "
      })
      // new VariableConfig('alpha', {
      // 	prefix: 'diffuseColor.a = ',
      // 	default: '1.0',
      // }),
    ];
  }
  //
  //
  // TEMPLATE HOOKS
  //
  //
  // protected override insertDefineAfter(shader_name: ShaderName) {
  // 	return '// INSERT DEFINE';
  // }
  // protected override insertBodyAfter(shader_name: ShaderName) {
  // 	return '// INSERT BODY';
  // }
  // protected override linesToRemove(shader_name: ShaderName) {
  // 	return ['// INSERT DEFINE', '// INSERT BODY'];
  // }
  // private _handle_gl_FragCoord(body_lines: string[], shaderName: ShaderName, var_name: string) {
  // 	if (shaderName == ShaderName.FRAGMENT) {
  // 		body_lines.push(`vec4 ${var_name} = gl_FragCoord`);
  // 	}
  // }
  // private _handle_resolution(bodyLines: string[], shaderName: ShaderName, var_name: string) {
  // 	if (shaderName == ShaderName.FRAGMENT) {
  // 		bodyLines.push(`vec2 ${var_name} = resolution`);
  // 	}
  // }
  // private _handleUV(bodyLines: string[], shaderName: ShaderName, var_name: string) {
  // 	if (shaderName == ShaderName.FRAGMENT) {
  // 		bodyLines.push(
  // 			`vec2 ${var_name} = vec2(gl_FragCoord.x / (resolution.x-1.), gl_FragCoord.y / (resolution.y-1.))`
  // 		);
  // 	}
  // }
  setNodeLinesOutput(outputNode, linesController) {
    const inputNames = this.inputNamesForShaderName(outputNode, linesController.currentShaderName());
    const bodyLines = [];
    if (inputNames) {
      for (const inputName of inputNames) {
        const input = outputNode.io.inputs.named_input(inputName);
        if (input) {
          const varName = outputNode.variableForInput(linesController, inputName);
          switch (inputName) {
            case ObjectBuilderAssemblerCommon/* ObjectVariable.POSITION */.K.POSITION:
            case ObjectBuilderAssemblerCommon/* ObjectVariable.ROTATION */.K.ROTATION:
            case ObjectBuilderAssemblerCommon/* ObjectVariable.QUATERNION */.K.QUATERNION:
            case ObjectBuilderAssemblerCommon/* ObjectVariable.SCALE */.K.SCALE: {
              bodyLines.push(`${ObjectBuilderAssemblerCommon/* ObjectBuilderAssemblerConstant.OBJECT_3D */.F.OBJECT_3D}.${inputName}.copy(${varName})`);
              break;
            }
            case ObjectBuilderAssemblerCommon/* ObjectVariable.MATRIX */.K.MATRIX: {
              bodyLines.push(`${ObjectBuilderAssemblerCommon/* ObjectBuilderAssemblerConstant.OBJECT_3D */.F.OBJECT_3D}.${inputName}.copy(${varName})`);
              bodyLines.push(`${ObjectBuilderAssemblerCommon/* ObjectBuilderAssemblerConstant.OBJECT_3D */.F.OBJECT_3D}.${inputName}.decompose(
								${ObjectBuilderAssemblerCommon/* ObjectBuilderAssemblerConstant.OBJECT_3D */.F.OBJECT_3D}.position,
								${ObjectBuilderAssemblerCommon/* ObjectBuilderAssemblerConstant.OBJECT_3D */.F.OBJECT_3D}.quaternion,
								${ObjectBuilderAssemblerCommon/* ObjectBuilderAssemblerConstant.OBJECT_3D */.F.OBJECT_3D}.scale
							)`);
              break;
            }
            case ObjectBuilderAssemblerCommon/* ObjectVariable.VISIBLE */.K.VISIBLE:
            case ObjectBuilderAssemblerCommon/* ObjectVariable.MATRIX_AUTO_UPDATE */.K.MATRIX_AUTO_UPDATE:
            case ObjectBuilderAssemblerCommon/* ObjectVariable.CAST_SHADOW */.K.CAST_SHADOW:
            case ObjectBuilderAssemblerCommon/* ObjectVariable.RECEIVE_SHADOW */.K.RECEIVE_SHADOW:
            case ObjectBuilderAssemblerCommon/* ObjectVariable.FRUSTUM_CULLED */.K.FRUSTUM_CULLED: {
              bodyLines.push(`${ObjectBuilderAssemblerCommon/* ObjectBuilderAssemblerConstant.OBJECT_3D */.F.OBJECT_3D}.${inputName} = ${varName}`);
              break;
            }
          }
        }
      }
    }
    linesController._addBodyLines(outputNode, bodyLines);
  }
  setNodeLinesGlobals(globalsNode, linesController) {
    const shaderName = linesController.currentShaderName();
    const shaderConfig = this.shader_config(shaderName);
    if (!shaderConfig) {
      return;
    }
    const bodyLines = [];
    const usedOutputNames = globalsNode.io.outputs.used_output_names();
    for (const outputName of usedOutputNames) {
      const varName = globalsNode.jsVarName(outputName);
      switch (outputName) {
        case ObjectBuilderAssemblerCommon/* ObjectVariable.OBJECT_3D */.K.OBJECT_3D: {
          bodyLines.push(`${varName} = ${ObjectBuilderAssemblerCommon/* ObjectBuilderAssemblerConstant.OBJECT_3D */.F.OBJECT_3D}`);
          break;
        }
        case ObjectBuilderAssemblerCommon/* ObjectVariable.POSITION */.K.POSITION:
        case ObjectBuilderAssemblerCommon/* ObjectVariable.SCALE */.K.SCALE: {
          linesController.addVariable(globalsNode, new three_module.Vector3(), varName);
          bodyLines.push(`${varName}.copy(${ObjectBuilderAssemblerCommon/* ObjectBuilderAssemblerConstant.OBJECT_3D */.F.OBJECT_3D}.${outputName})`);
          break;
        }
        case ObjectBuilderAssemblerCommon/* ObjectVariable.ROTATION */.K.ROTATION: {
          linesController.addVariable(globalsNode, new three_module.Euler(), varName);
          bodyLines.push(`${varName}.copy(${ObjectBuilderAssemblerCommon/* ObjectBuilderAssemblerConstant.OBJECT_3D */.F.OBJECT_3D}.${outputName})`);
          break;
        }
        case ObjectBuilderAssemblerCommon/* ObjectVariable.QUATERNION */.K.QUATERNION: {
          linesController.addVariable(globalsNode, new three_module.Quaternion(), varName);
          bodyLines.push(`${varName}.copy(${ObjectBuilderAssemblerCommon/* ObjectBuilderAssemblerConstant.OBJECT_3D */.F.OBJECT_3D}.${outputName})`);
          break;
        }
        case ObjectBuilderAssemblerCommon/* ObjectVariable.MATRIX */.K.MATRIX: {
          linesController.addVariable(globalsNode, new three_module.Matrix4(), varName);
          bodyLines.push(`${varName}.copy(${ObjectBuilderAssemblerCommon/* ObjectBuilderAssemblerConstant.OBJECT_3D */.F.OBJECT_3D}.${outputName})`);
          break;
        }
        case ObjectBuilderAssemblerCommon/* ObjectVariable.VISIBLE */.K.VISIBLE:
        case ObjectBuilderAssemblerCommon/* ObjectVariable.MATRIX_AUTO_UPDATE */.K.MATRIX_AUTO_UPDATE:
        case ObjectBuilderAssemblerCommon/* ObjectVariable.CAST_SHADOW */.K.CAST_SHADOW:
        case ObjectBuilderAssemblerCommon/* ObjectVariable.RECEIVE_SHADOW */.K.RECEIVE_SHADOW:
        case ObjectBuilderAssemblerCommon/* ObjectVariable.FRUSTUM_CULLED */.K.FRUSTUM_CULLED: {
          linesController.addVariable(globalsNode, new three_module.Vector3(), varName);
          bodyLines.push(`${varName} = ${ObjectBuilderAssemblerCommon/* ObjectBuilderAssemblerConstant.OBJECT_3D */.F.OBJECT_3D}.${outputName}`);
          break;
        }
        case ObjectBuilderAssemblerCommon/* ObjectVariable.OBJ_NUM */.K.OBJ_NUM: {
          bodyLines.push(`${varName} = ${ObjectBuilderAssemblerCommon/* ObjectBuilderAssemblerConstant.OBJ_NUM */.F.OBJ_NUM}`);
          break;
        }
      }
    }
    linesController._addBodyLines(globalsNode, bodyLines);
  }
  setNodeLinesAttribute(attributeNode, linesController) {
    const shaderName = linesController.currentShaderName();
    const shaderConfig = this.shader_config(shaderName);
    if (!shaderConfig) {
      return;
    }
    const bodyLines = [];
    const attribName = attributeNode.attributeName();
    const dataType = attributeNode.jsType();
    if (attributeNode.isExporting()) {
      const func = Poly/* Poly.namedFunctionsRegister.getFunction */.L.namedFunctionsRegister.getFunction("setObjectAttribute", attributeNode, linesController);
      const exportedValue = attributeNode.variableForInput(linesController, js_Attribute/* AttributeJsNodeInput.EXPORT */.Hh.EXPORT);
      const bodyLine = func.asString(
        ObjectBuilderAssemblerCommon/* ObjectBuilderAssemblerConstant.OBJECT_3D */.F.OBJECT_3D,
        `'${attribName}'`,
        `1`,
        exportedValue,
        `'${dataType}'`
      );
      bodyLines.push(bodyLine);
    }
    const usedOutputNames = attributeNode.io.outputs.used_output_names();
    for (const outputName of usedOutputNames) {
      const varName = attributeNode.jsVarName(outputName);
      const func = Poly/* Poly.namedFunctionsRegister.getFunction */.L.namedFunctionsRegister.getFunction(
        "getObjectAttributeAutoDefault",
        attributeNode,
        linesController
      );
      const bodyLine = `${varName} = ` + func.asString(ObjectBuilderAssemblerCommon/* ObjectBuilderAssemblerConstant.OBJECT_3D */.F.OBJECT_3D, `'${attribName}'`, `'${dataType}'`);
      bodyLines.push(bodyLine);
    }
    linesController._addBodyLines(attributeNode, bodyLines);
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/js/code/assemblers/pointBuilder/PointBuilderAssembler.ts









class JsAssemblerPointBuilder extends JsAssemblerBasePointBuilder {
  _evaluatorName() {
    return "CustomPointBuilderEvaluator";
  }
  //
  //
  // CHILDREN NODES PARAMS
  //
  //
  add_output_inputs(output_child) {
    output_child.io.inputs.setNamedInputConnectionPoints([
      new connections_Js/* JsConnectionPoint */.fp(PointBuilderAssemblerCommon/* PointVariable.POSITION */.U.POSITION, connections_Js/* JsConnectionPointType.VECTOR3 */.zF.VECTOR3),
      new connections_Js/* JsConnectionPoint */.fp(PointBuilderAssemblerCommon/* PointVariable.NORMAL */.U.NORMAL, connections_Js/* JsConnectionPointType.VECTOR3 */.zF.VECTOR3)
    ]);
  }
  add_globals_outputs(globals_node) {
    globals_node.io.outputs.setNamedOutputConnectionPoints([
      new connections_Js/* JsConnectionPoint */.fp(PointBuilderAssemblerCommon/* PointVariable.POSITION */.U.POSITION, connections_Js/* JsConnectionPointType.VECTOR3 */.zF.VECTOR3),
      new connections_Js/* JsConnectionPoint */.fp(PointBuilderAssemblerCommon/* PointVariable.NORMAL */.U.NORMAL, connections_Js/* JsConnectionPointType.VECTOR3 */.zF.VECTOR3),
      new connections_Js/* JsConnectionPoint */.fp(PointBuilderAssemblerCommon/* PointVariable.PTNUM */.U.PTNUM, connections_Js/* JsConnectionPointType.INT */.zF.INT),
      new connections_Js/* JsConnectionPoint */.fp(PointBuilderAssemblerCommon/* PointVariable.OBJNUM */.U.OBJNUM, connections_Js/* JsConnectionPointType.INT */.zF.INT)
    ]);
  }
  //
  //
  // CONFIGS
  //
  //
  create_shader_configs() {
    return [
      new ShaderConfig/* JsShaderConfig */.s(
        ShaderName/* JsFunctionName.MAIN */.J.MAIN,
        [
          PointBuilderAssemblerCommon/* PointVariable.POSITION */.U.POSITION,
          PointBuilderAssemblerCommon/* PointVariable.NORMAL */.U.NORMAL,
          // attribute
          js_Attribute/* AttributeJsNodeInput.EXPORT */.Hh.EXPORT
        ],
        []
      )
    ];
  }
  create_variable_configs() {
    return [
      new configs_VariableConfig/* VariableConfig */.P(PointBuilderAssemblerCommon/* PointVariable.POSITION */.U.POSITION, {
        prefix: "return "
      }),
      new configs_VariableConfig/* VariableConfig */.P(PointBuilderAssemblerCommon/* PointVariable.NORMAL */.U.NORMAL, {
        prefix: "return "
      })
    ];
  }
  //
  //
  // NODE LINES
  //
  //
  setNodeLinesOutput(outputNode, linesController) {
    const inputNames = this.inputNamesForShaderName(outputNode, linesController.currentShaderName());
    const bodyLines = [];
    if (inputNames) {
      for (const inputName of inputNames) {
        const input = outputNode.io.inputs.named_input(inputName);
        if (input) {
          const varName = outputNode.variableForInput(linesController, inputName);
          switch (inputName) {
            case PointBuilderAssemblerCommon/* PointVariable.POSITION */.U.POSITION: {
              bodyLines.push(`${PointBuilderAssemblerCommon/* PointBuilderAssemblerConstant.POSITION */.X.POSITION}.copy(${varName})`);
              break;
            }
            case PointBuilderAssemblerCommon/* PointVariable.NORMAL */.U.NORMAL: {
              bodyLines.push(`${PointBuilderAssemblerCommon/* PointBuilderAssemblerConstant.NORMAL */.X.NORMAL}.copy(${varName})`);
              bodyLines.push(`${PointBuilderAssemblerCommon/* PointBuilderAssemblerConstant.NORMALS_UPDATED */.X.NORMALS_UPDATED} = true`);
              break;
            }
          }
        }
      }
    }
    linesController._addBodyLines(outputNode, bodyLines);
  }
  setNodeLinesGlobals(globalsNode, linesController) {
    const shaderName = linesController.currentShaderName();
    const shaderConfig = this.shader_config(shaderName);
    if (!shaderConfig) {
      return;
    }
    const bodyLines = [];
    const usedOutputNames = globalsNode.io.outputs.used_output_names();
    for (const outputName of usedOutputNames) {
      const varName = globalsNode.jsVarName(outputName);
      switch (outputName) {
        case PointBuilderAssemblerCommon/* PointVariable.POSITION */.U.POSITION:
        case PointBuilderAssemblerCommon/* PointVariable.NORMAL */.U.NORMAL: {
          linesController.addVariable(globalsNode, new three_module.Vector3(), varName);
          bodyLines.push(`${varName}.copy(${PointBuilderAssemblerCommon/* PointBuilderAssemblerConstant.POINT_CONTAINER */.X.POINT_CONTAINER}.${outputName})`);
          break;
        }
        case PointBuilderAssemblerCommon/* PointVariable.OBJNUM */.U.OBJNUM:
        case PointBuilderAssemblerCommon/* PointVariable.PTNUM */.U.PTNUM: {
          bodyLines.push(`${varName}= ${PointBuilderAssemblerCommon/* PointBuilderAssemblerConstant.POINT_CONTAINER */.X.POINT_CONTAINER}.${outputName}`);
        }
      }
    }
    linesController._addBodyLines(globalsNode, bodyLines);
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/js/code/assemblers/sdf/SDF.ts








var SDFVariable = /* @__PURE__ */ ((SDFVariable2) => {
  SDFVariable2["D"] = "d";
  return SDFVariable2;
})(SDFVariable || {});
const SDF_TEMPLATE = `
${code_assemblers_Base/* INSERT_DEFINE_AFTER */.Zf}
${code_assemblers_Base/* INSERT_MEMBERS_AFTER */.FD}

${code_assemblers_Base/* INSERT_BODY_AFTER */.xP}
`;
class JsAssemblerSDF extends code_assemblers_Base/* BaseJsShaderAssembler */.SD {
  // private _function: Function | undefined;
  // private _uniforms: IUniforms | undefined;
  // private _functionsByName: Map<string, Function> = new Map();
  makeFunctionNodeDirtyOnChange() {
    return true;
  }
  defaultObjectVariable() {
    return "null";
  }
  defaultObject3DMaterialVariable() {
    return "null";
  }
  defaultPrimitiveGraph() {
    return "null";
  }
  templateShader() {
    return {
      main: SDF_TEMPLATE
    };
  }
  spareParamsOptions(options) {
    const _options = {
      spare: true,
      // computeOnDirty: true, // not needed if cook option is not set
      // cook: false, // for SDFBuilder, the node needs to recook
      // important for texture nodes
      // that compute after being found by the nodepath param
      dependentOnFoundNode: true
    };
    return _options;
  }
  functionData() {
    const functionBody = this._shaders_by_name.get(ShaderName/* JsFunctionName.MAIN */.J.MAIN);
    if (!functionBody) {
      return;
    }
    const variableNames = [];
    const functionNames = [];
    const variablesByName = {};
    const functionsByName = {};
    this.traverseRegisteredVariables((variable, varName) => {
      variableNames.push(varName);
      variablesByName[varName] = variable;
    });
    this.traverseRegisteredFunctions((namedFunction) => {
      functionNames.push(namedFunction.type());
      functionsByName[namedFunction.type()] = namedFunction.func.bind(namedFunction);
    });
    const paramConfigs = this.param_configs();
    return {
      functionBody,
      variableNames,
      variablesByName,
      functionNames,
      functionsByName,
      paramConfigs: [...paramConfigs]
    };
  }
  // uniforms() {
  // 	return this._uniforms;
  // }
  // evalFunction(position: Vector3) {
  // 	if (this._function) {
  // 		return this._function(position);
  // 	}
  // }
  updateFunction() {
    super.updateFunction();
    this._lines = /* @__PURE__ */ new Map();
    this._shaders_by_name = /* @__PURE__ */ new Map();
    const shaderNames = this.shaderNames();
    if (this._root_nodes.length > 0) {
      this.buildCodeFromNodes(this._root_nodes);
      this._buildLines();
    }
    for (const shaderName of shaderNames) {
      const lines = this._lines.get(shaderName);
      if (lines) {
        this._shaders_by_name.set(shaderName, lines.join("\n"));
      }
    }
  }
  //
  //
  // CHILDREN NODES PARAMS
  //
  //
  add_output_inputs(output_child) {
    output_child.io.inputs.setNamedInputConnectionPoints([
      new connections_Js/* JsConnectionPoint */.fp("d" /* D */, connections_Js/* JsConnectionPointType.FLOAT */.zF.FLOAT)
      // new JsConnectionPoint('alpha', JsConnectionPointType.FLOAT),
    ]);
  }
  add_globals_outputs(globals_node) {
    globals_node.io.outputs.setNamedOutputConnectionPoints([
      new connections_Js/* JsConnectionPoint */.fp("position", connections_Js/* JsConnectionPointType.VECTOR3 */.zF.VECTOR3)
      // new JsConnectionPoint('gl_FragCoord', JsConnectionPointType.VEC4),
      // new JsConnectionPoint('resolution', JsConnectionPointType.VEC2),
      // new JsConnectionPoint('time', JsConnectionPointType.FLOAT),
      // new Connection.Vec2('resolution'),
    ]);
  }
  //
  //
  // CONFIGS
  //
  //
  create_shader_configs() {
    return [new ShaderConfig/* JsShaderConfig */.s(ShaderName/* JsFunctionName.MAIN */.J.MAIN, ["d" /* D */], [])];
  }
  create_variable_configs() {
    return [
      new configs_VariableConfig/* VariableConfig */.P("d" /* D */, {
        prefix: "return "
      })
      // new VariableConfig('alpha', {
      // 	prefix: 'diffuseColor.a = ',
      // 	default: '1.0',
      // }),
    ];
  }
  //
  //
  // TEMPLATE HOOKS
  //
  //
  // protected override insertDefineAfter(shader_name: ShaderName) {
  // 	return '// INSERT DEFINE';
  // }
  // protected override insertBodyAfter(shader_name: ShaderName) {
  // 	return '// INSERT BODY';
  // }
  // protected override linesToRemove(shader_name: ShaderName) {
  // 	return ['// INSERT DEFINE', '// INSERT BODY'];
  // }
  // private _handle_gl_FragCoord(body_lines: string[], shaderName: ShaderName, var_name: string) {
  // 	if (shaderName == ShaderName.FRAGMENT) {
  // 		body_lines.push(`vec4 ${var_name} = gl_FragCoord`);
  // 	}
  // }
  // private _handle_resolution(bodyLines: string[], shaderName: ShaderName, var_name: string) {
  // 	if (shaderName == ShaderName.FRAGMENT) {
  // 		bodyLines.push(`vec2 ${var_name} = resolution`);
  // 	}
  // }
  // private _handleUV(bodyLines: string[], shaderName: ShaderName, var_name: string) {
  // 	if (shaderName == ShaderName.FRAGMENT) {
  // 		bodyLines.push(
  // 			`vec2 ${var_name} = vec2(gl_FragCoord.x / (resolution.x-1.), gl_FragCoord.y / (resolution.y-1.))`
  // 		);
  // 	}
  // }
  setNodeLinesOutput(outputNode, shadersCollectionController) {
    const inputNames = this.inputNamesForShaderName(outputNode, shadersCollectionController.currentShaderName());
    if (inputNames) {
      for (const inputName of inputNames) {
        const input = outputNode.io.inputs.named_input(inputName);
        if (input) {
          const gl_var = outputNode.variableForInput(shadersCollectionController, inputName);
          let bodyLine;
          if (inputName == "d" /* D */) {
            bodyLine = `return ${ThreeToGl/* ThreeToGl.any */._.any(gl_var)}`;
          }
          if (bodyLine) {
            shadersCollectionController._addBodyLines(outputNode, [bodyLine]);
          }
        }
      }
    }
  }
  setNodeLinesGlobals(globalsNode, shadersCollectionController) {
    const shaderName = shadersCollectionController.currentShaderName();
    const shaderConfig = this.shader_config(shaderName);
    if (!shaderConfig) {
      return;
    }
    const bodyLines = [];
    const usedOutputNames = globalsNode.io.outputs.used_output_names();
    for (const outputName of usedOutputNames) {
      const varName = globalsNode.jsVarName(outputName);
      switch (outputName) {
        case "position":
          shadersCollectionController.addVariable(globalsNode, new three_module.Vector3(), varName);
          bodyLines.push(`${varName}.copy(${outputName})`);
          break;
      }
    }
    shadersCollectionController._addBodyLines(globalsNode, bodyLines);
  }
}

// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/nodes/js/code/assemblers/softBody/SoftBodyAssembler.ts
var SoftBodyAssembler = __webpack_require__(80524);
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/poly/registers/assemblers/All.ts




























class AllAssemblersRegister {
  static run(poly) {
    poly.assemblersRegister.register(_BaseRegister/* AssemblerName.GL_MESH_BASIC */.Q.GL_MESH_BASIC, GlAssemblerController, ShaderAssemblerBasic);
    poly.assemblersRegister.register(_BaseRegister/* AssemblerName.GL_CLOTH */.Q.GL_CLOTH, GlAssemblerController, ShaderAssemblerCloth);
    poly.assemblersRegister.register(_BaseRegister/* AssemblerName.GL_MESH_LAMBERT */.Q.GL_MESH_LAMBERT, GlAssemblerController, ShaderAssemblerLambert);
    poly.assemblersRegister.register(_BaseRegister/* AssemblerName.GL_MESH_PHONG */.Q.GL_MESH_PHONG, GlAssemblerController, ShaderAssemblerPhong);
    poly.assemblersRegister.register(_BaseRegister/* AssemblerName.GL_MESH_TOON */.Q.GL_MESH_TOON, GlAssemblerController, ShaderAssemblerToon);
    poly.assemblersRegister.register(
      _BaseRegister/* AssemblerName.GL_MESH_STANDARD */.Q.GL_MESH_STANDARD,
      GlAssemblerController,
      ShaderAssemblerStandard
    );
    poly.assemblersRegister.register(
      _BaseRegister/* AssemblerName.GL_MESH_PHYSICAL */.Q.GL_MESH_PHYSICAL,
      GlAssemblerController,
      ShaderAssemblerPhysical
    );
    poly.assemblersRegister.register(
      _BaseRegister/* AssemblerName.GL_MESH_DEPTH */.Q.GL_MESH_DEPTH,
      GlAssemblerController,
      ShaderAssemblerCustomMeshDepthForRender
    );
    poly.assemblersRegister.register(
      _BaseRegister/* AssemblerName.GL_MESH_DISTANCE */.Q.GL_MESH_DISTANCE,
      GlAssemblerController,
      ShaderAssemblerCustomMeshDistanceForRender
    );
    poly.assemblersRegister.register(_BaseRegister/* AssemblerName.GL_PARTICLES */.Q.GL_PARTICLES, GlAssemblerController, ShaderAssemblerParticles);
    poly.assemblersRegister.register(_BaseRegister/* AssemblerName.GL_POINTS */.Q.GL_POINTS, GlAssemblerController, ShaderAssemblerPoints);
    poly.assemblersRegister.register(_BaseRegister/* AssemblerName.GL_LINE */.Q.GL_LINE, GlAssemblerController, ShaderAssemblerLine);
    poly.assemblersRegister.register(_BaseRegister/* AssemblerName.GL_POST */.Q.GL_POST, GlAssemblerController, ShaderAssemblerPost);
    poly.assemblersRegister.register(
      _BaseRegister/* AssemblerName.GL_RAYMARCHING */.Q.GL_RAYMARCHING,
      GlAssemblerController,
      ShaderAssemblerRayMarching
    );
    poly.assemblersRegister.register(_BaseRegister/* AssemblerName.GL_TEXTURE */.Q.GL_TEXTURE, GlAssemblerController, ShaderAssemblerTexture);
    poly.assemblersRegister.register(
      _BaseRegister/* AssemblerName.GL_TEXTURE_2D_ARRAY */.Q.GL_TEXTURE_2D_ARRAY,
      GlAssemblerController,
      ShaderAssemblerTexture2DArray
    );
    poly.assemblersRegister.register(_BaseRegister/* AssemblerName.GL_VOLUME */.Q.GL_VOLUME, GlAssemblerController, ShaderAssemblerVolume);
    poly.assemblersRegister.register(_BaseRegister/* AssemblerName.JS_ACTOR */.Q.JS_ACTOR, JsAssemblerController, JsAssemblerActor);
    poly.assemblersRegister.register(
      _BaseRegister/* AssemblerName.JS_ENTITY_BUILDER */.Q.JS_ENTITY_BUILDER,
      JsAssemblerController,
      JsAssemblerEntityBuilder
    );
    poly.assemblersRegister.register(
      _BaseRegister/* AssemblerName.JS_INSTANCE_BUILDER */.Q.JS_INSTANCE_BUILDER,
      JsAssemblerController,
      JsAssemblerInstanceBuilder
    );
    poly.assemblersRegister.register(
      _BaseRegister/* AssemblerName.JS_OBJECT_BUILDER */.Q.JS_OBJECT_BUILDER,
      JsAssemblerController,
      JsAssemblerObjectBuilder
    );
    poly.assemblersRegister.register(
      _BaseRegister/* AssemblerName.JS_POINT_BUILDER */.Q.JS_POINT_BUILDER,
      JsAssemblerController,
      JsAssemblerPointBuilder
    );
    poly.assemblersRegister.register(_BaseRegister/* AssemblerName.JS_SDF */.Q.JS_SDF, JsAssemblerController, JsAssemblerSDF);
    poly.assemblersRegister.register(_BaseRegister/* AssemblerName.JS_SOFT_BODY */.Q.JS_SOFT_BODY, JsAssemblerController, SoftBodyAssembler/* JsAssemblerSoftBody */.Y);
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/poly/registers/cameras/All.ts

class AllCamerasRegister {
  static run(poly) {
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/functions/_Audio.ts

var _Audio_async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};





const AUDIO_ATTRIB_NAME_LAST_INSTRUMENT_TYPE = "__lastInstrumentType__";
const AUDIO_ATTRIB_NAME_LAST_NOTE = "__lastNote__";
const listenersByAudioSource = /* @__PURE__ */ new Map();
function onAudioSourceStop(nodePath, listener) {
  let listeners = listenersByAudioSource.get(nodePath);
  if (!listeners) {
    listeners = /* @__PURE__ */ new Set();
    listenersByAudioSource.set(nodePath, listeners);
  }
  listeners.add(listener);
}
function removeAudioSourceStopListener(nodePath, listener) {
  const listeners = listenersByAudioSource.get(nodePath);
  if (!listeners) {
    return;
  }
  listeners.delete(listener);
}
function dispatchAudioSourceStop(nodePath) {
  const listeners = listenersByAudioSource.get(nodePath);
  if (!listeners) {
    return;
  }
  listeners.forEach((listener) => {
    listener();
  });
}
function getAudioSource(scene, nodePath) {
  return _Audio_async(this, null, function* () {
    const audioNode = scene.node(nodePath);
    if (!audioNode) {
      return;
    }
    if (audioNode.context() != poly_NodeContext/* NodeContext.AUDIO */.sy.AUDIO) {
      return;
    }
    const container = yield audioNode.compute();
    const audioBuilder = container.coreContent();
    if (!audioBuilder) {
      return;
    }
    const source = audioBuilder.source();
    if (!source) {
      return;
    }
    if (!(source instanceof Player/* Player */.J)) {
      return;
    }
    return source;
  });
}
class addAudioStopEventListener extends functions_Base/* NamedFunction3 */.Dv {
  static type() {
    return "addAudioStopEventListener";
  }
  func(nodePath, listener, evaluator) {
    onAudioSourceStop(nodePath, listener);
    evaluator.onDispose(() => {
      removeAudioSourceStopListener(nodePath, listener);
    });
  }
}
class playAudioSource extends functions_Base/* ObjectNamedFunction1 */.c_ {
  static type() {
    return "playAudioSource";
  }
  func(object3D, nodePath) {
    getAudioSource(this.scene, nodePath).then((source) => {
      if (!source) {
        return;
      }
      source.start();
      PlayerCallbacksManager/* AudioPlayerCallbacksManager.onStop */.K.onStop(source, () => {
        dispatchAudioSourceStop(nodePath);
      });
    });
  }
}
class pauseAudioSource extends functions_Base/* ObjectNamedFunction1 */.c_ {
  static type() {
    return "pauseAudioSource";
  }
  func(object3D, nodePath) {
    getAudioSource(this.scene, nodePath).then((source) => {
      if (!source) {
        return;
      }
      source.stop();
    });
  }
}
class playInstrumentNote extends functions_Base/* ObjectNamedFunction3 */.uW {
  static type() {
    return "playInstrumentNote";
  }
  func(object3D, nodePath, note, duration) {
    const audioNode = this.scene.node(nodePath);
    if (!audioNode) {
      return;
    }
    if (audioNode.context() != poly_NodeContext/* NodeContext.AUDIO */.sy.AUDIO) {
      return;
    }
    audioNode.compute().then((container) => {
      const audioBuilder = container.coreContent();
      if (!audioBuilder) {
        return;
      }
      const instrument = audioBuilder.instrument();
      if (!instrument) {
        return;
      }
      const lastInstrumentType = instrument.triggerAttackRelease(note, duration);
      const lastNote = note;
      ThreejsCoreObject/* ThreejsCoreObject.addAttribute */.W.addAttribute(object3D, AUDIO_ATTRIB_NAME_LAST_INSTRUMENT_TYPE, lastInstrumentType);
      ThreejsCoreObject/* ThreejsCoreObject.addAttribute */.W.addAttribute(object3D, AUDIO_ATTRIB_NAME_LAST_NOTE, lastNote);
    });
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/functions/_Add.ts


class addNumber extends functions_Base/* NamedFunction */.x9 {
  static type() {
    return "addNumber";
  }
  func(...args) {
    let first = args[0];
    for (let i = 1; i < args.length; i++) {
      first += args[i];
    }
    return first;
  }
}
class addVector extends functions_Base/* NamedFunction */.x9 {
  static type() {
    return "addVector";
  }
  func(...args) {
    const first = args[0];
    for (let i = 1; i < args.length; i++) {
      first.add(args[i]);
    }
    return first;
  }
}
class addVectorNumber extends functions_Base/* NamedFunction2 */.CE {
  static type() {
    return "addVectorNumber";
  }
  func(vector, number) {
    return vector.addScalar(number);
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/functions/_UserInputObject.ts


class addObjectToObjectClickCheck extends functions_Base/* ObjectNamedFunction2 */.YS {
  static type() {
    return "addObjectToObjectClickCheck";
  }
  func(object3D, evaluator, options) {
    const controller = this.scene.actorsManager.rayObjectIntersectionClick;
    controller.addPropertiesForObject(object3D, options);
    evaluator.onDispose(() => {
      controller.removePropertiesForObject(object3D, options);
    });
  }
}
class addObjectToObjectMouseClickCheck extends functions_Base/* ObjectNamedFunction2 */.YS {
  static type() {
    return "addObjectToObjectMouseClickCheck";
  }
  func(object3D, evaluator, options) {
    const controller = this.scene.actorsManager.rayObjectIntersectionMouseClick;
    controller.addPropertiesForObject(object3D, options);
    evaluator.onDispose(() => {
      controller.removePropertiesForObject(object3D, options);
    });
  }
}
class addObjectToObjectContextmenuCheck extends functions_Base/* ObjectNamedFunction2 */.YS {
  static type() {
    return "addObjectToObjectContextmenuCheck";
  }
  func(object3D, evaluator, options) {
    const controller = this.scene.actorsManager.rayObjectIntersectionContextmenu;
    controller.addPropertiesForObject(object3D, options);
    evaluator.onDispose(() => {
      controller.removePropertiesForObject(object3D, options);
    });
  }
}
class addObjectToObjectHoveredCheck extends functions_Base/* ObjectNamedFunction2 */.YS {
  static type() {
    return "addObjectToObjectHoveredCheck";
  }
  func(object3D, evaluator, options) {
    const controller = this.scene.actorsManager.rayObjectIntersectionHover;
    controller.addPropertiesForObject(object3D, options);
    evaluator.onDispose(() => {
      controller.removePropertiesForObject(object3D, options);
    });
  }
}
class addObjectToObjectLongPressCheck extends functions_Base/* ObjectNamedFunction2 */.YS {
  static type() {
    return "addObjectToObjectLongPressCheck";
  }
  func(object3D, evaluator, options) {
    const controller = this.scene.actorsManager.rayObjectIntersectionLongPress;
    controller.addPropertiesForObject(object3D, options);
    evaluator.onDispose(() => {
      controller.removePropertiesForObject(object3D, options);
    });
  }
}
class addObjectToObjectPointerdownCheck extends functions_Base/* ObjectNamedFunction2 */.YS {
  static type() {
    return "addObjectToObjectPointerdownCheck";
  }
  func(object3D, evaluator, options) {
    const controller = this.scene.actorsManager.rayObjectIntersectionPointerdown;
    controller.addPropertiesForObject(object3D, options);
    evaluator.onDispose(() => {
      controller.removePropertiesForObject(object3D, options);
    });
  }
}
class addObjectToObjectPointerupCheck extends functions_Base/* ObjectNamedFunction2 */.YS {
  static type() {
    return "addObjectToObjectPointerupCheck";
  }
  func(object3D, evaluator, options) {
    const controller = this.scene.actorsManager.rayObjectIntersectionPointerup;
    controller.addPropertiesForObject(object3D, options);
    evaluator.onDispose(() => {
      controller.removePropertiesForObject(object3D, options);
    });
  }
}
class addObjectToObjectSwipeCheck extends functions_Base/* ObjectNamedFunction2 */.YS {
  static type() {
    return "addObjectToObjectSwipeCheck";
  }
  func(object3D, evaluator, options) {
    const controller = this.scene.actorsManager.rayObjectIntersectionSwipe;
    controller.addPropertiesForObject(object3D, options);
    evaluator.onDispose(() => {
      controller.removePropertiesForObject(object3D, options);
    });
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/functions/_UserInput.ts


class addObjectToPointerdownCheck extends functions_Base/* ObjectNamedFunction2 */.YS {
  static type() {
    return "addObjectToPointerdownCheck";
  }
  func(object3D, evaluator, options) {
    const controller = this.scene.actorsManager.pointerdown;
    controller.addPropertiesForObject(object3D, options);
    evaluator.onDispose(() => {
      controller.removePropertiesForObject(object3D, options);
    });
  }
}
class addObjectToPointerupCheck extends functions_Base/* ObjectNamedFunction2 */.YS {
  static type() {
    return "addObjectToPointerupCheck";
  }
  func(object3D, evaluator, options) {
    const controller = this.scene.actorsManager.pointerup;
    controller.addPropertiesForObject(object3D, options);
    evaluator.onDispose(() => {
      controller.removePropertiesForObject(object3D, options);
    });
  }
}

// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/core/reactivity/CoreReactivity.ts
var CoreReactivity = __webpack_require__(82156);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/core/VideoEvent.ts
var VideoEvent = __webpack_require__(83220);
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/functions/_Video.ts






function _getVideoNode(scene, nodePath) {
  const node = scene.node(nodePath);
  if (!node) {
    return;
  }
  if (node.context() != poly_NodeContext/* NodeContext.COP */.sy.COP) {
    return;
  }
  if (node.type() != Cop/* CopType.VIDEO */.y.VIDEO) {
    return;
  }
  const videoNode = node;
  return videoNode;
}
class addVideoEventListener extends functions_Base/* NamedFunction3 */.Dv {
  static type() {
    return "addVideoEventListener";
  }
  func(nodePath, listeners, evaluator) {
    const videoNode = _getVideoNode(this.scene, nodePath);
    if (!videoNode) {
      return;
    }
    for (let eventName of VideoEvent/* VIDEO_EVENTS */.NW) {
      const listener = listeners[eventName];
      videoNode.addEventListener(eventName, listener);
    }
    evaluator.onDispose(() => {
      for (let eventName of VideoEvent/* VIDEO_EVENTS */.NW) {
        const listener = listeners[eventName];
        videoNode.removeEventListener(eventName, listener);
      }
    });
  }
}
class getVideoPropertyCurrentTime extends functions_Base/* NamedFunction1 */.TV {
  static type() {
    return "getVideoPropertyCurrentTime";
  }
  func(nodePath) {
    var _a;
    (0,CoreReactivity/* dummyReadRefVal */.Jb)(this.timeController.timeUniform().value);
    return ((_a = _getVideoNode(this.scene, nodePath)) == null ? void 0 : _a.videoCurrentTime()) || 0;
  }
}
class getVideoPropertyDuration extends functions_Base/* NamedFunction1 */.TV {
  static type() {
    return "getVideoPropertyDuration";
  }
  func(nodePath) {
    var _a;
    (0,CoreReactivity/* dummyReadRefVal */.Jb)(this.timeController.timeUniform().value);
    return ((_a = _getVideoNode(this.scene, nodePath)) == null ? void 0 : _a.videoDuration()) || 0;
  }
}
class getVideoPropertyPlaying extends functions_Base/* NamedFunction1 */.TV {
  static type() {
    return "getVideoPropertyPlaying";
  }
  func(nodePath) {
    var _a;
    (0,CoreReactivity/* dummyReadRefVal */.Jb)(this.timeController.timeUniform().value);
    return ((_a = _getVideoNode(this.scene, nodePath)) == null ? void 0 : _a.videoStatePlaying()) || false;
  }
}
class getVideoPropertyMuted extends functions_Base/* NamedFunction1 */.TV {
  static type() {
    return "getVideoPropertyMuted";
  }
  func(nodePath) {
    var _a;
    (0,CoreReactivity/* dummyReadRefVal */.Jb)(this.timeController.timeUniform().value);
    return ((_a = _getVideoNode(this.scene, nodePath)) == null ? void 0 : _a.videoStateMuted()) || false;
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/functions/_Logic.ts


class andArrays extends functions_Base/* NamedFunction1 */.TV {
  static type() {
    return "andArrays";
  }
  func(arrays) {
    for (let array of arrays) {
      for (let element of array) {
        if (!element) {
          return false;
        }
      }
    }
    return true;
  }
}
class andBooleans extends functions_Base/* NamedFunction1 */.TV {
  static type() {
    return "andBooleans";
  }
  func(arrays) {
    for (let element of arrays) {
      if (!element) {
        return false;
      }
    }
    return true;
  }
}
class orArrays extends functions_Base/* NamedFunction1 */.TV {
  static type() {
    return "orArrays";
  }
  func(arrays) {
    for (let array of arrays) {
      for (let element of array) {
        if (element) {
          return true;
        }
      }
    }
    return false;
  }
}
class orBooleans extends functions_Base/* NamedFunction1 */.TV {
  static type() {
    return "orBooleans";
  }
  func(arrays) {
    for (let element of arrays) {
      if (element) {
        return true;
      }
    }
    return false;
  }
}

// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/functions/_AnimationMixer.ts
var _AnimationMixer = __webpack_require__(67120);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/functions/_ArrayUtils.ts
var _ArrayUtils = __webpack_require__(46255);
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/functions/_Array.ts



class arrayLength extends functions_Base/* NamedFunction1 */.TV {
  static type() {
    return "arrayLength";
  }
  func(array) {
    return array.length;
  }
}
class elementsToArrayPrimitive extends functions_Base/* NamedFunction2 */.CE {
  static type() {
    return "elementsToArrayPrimitive";
  }
  func(src, target) {
    (0,_ArrayUtils/* _matchArrayLength */.X9)(src, target, () => src[0]);
    let i = 0;
    for (let srcElement of src) {
      target[i] = srcElement;
      i++;
    }
    return target;
  }
}
class elementsToArrayVector extends functions_Base/* NamedFunction2 */.CE {
  static type() {
    return "elementsToArrayVector";
  }
  func(src, target) {
    (0,_ArrayUtils/* _matchArrayLength */.X9)(src, target, () => src[0].clone());
    let i = 0;
    for (let srcElement of src) {
      target[i].copy(srcElement);
      i++;
    }
    return target;
  }
}
class arrayElementPrimitive extends functions_Base/* NamedFunction2 */.CE {
  static type() {
    return "arrayElementPrimitive";
  }
  func(src, index) {
    const element = src[index];
    return element != null ? element : src[0];
  }
}
class arrayElementVector extends functions_Base/* NamedFunction3 */.Dv {
  static type() {
    return "arrayElementVector";
  }
  func(src, index, target) {
    let element = src[index];
    element != null ? element : src[0];
    if (element) {
      target.copy(element);
    }
    return target;
  }
}
class arrayPopPrimitive extends functions_Base/* NamedFunction1 */.TV {
  static type() {
    return "arrayPopPrimitive";
  }
  func(src) {
    const element = src.pop();
    return element;
  }
}
class arrayPopVector extends functions_Base/* NamedFunction2 */.CE {
  static type() {
    return "arrayPopVector";
  }
  func(src, target) {
    const element = src.pop();
    if (element) {
      target.copy(element);
    }
    return target;
  }
}
class arrayShiftPrimitive extends functions_Base/* NamedFunction1 */.TV {
  static type() {
    return "arrayShiftPrimitive";
  }
  func(src) {
    const element = src.shift();
    return element;
  }
}
class arrayShiftVector extends functions_Base/* NamedFunction2 */.CE {
  static type() {
    return "arrayShiftVector";
  }
  func(src, target) {
    const element = src.shift();
    if (element) {
      target.copy(element);
    }
    return target;
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/functions/_Conversion.ts


class boolToInt extends functions_Base/* NamedFunction1 */.TV {
  static type() {
    return "boolToInt";
  }
  func(b) {
    return b ? 1 : 0;
  }
}
class intToBool extends functions_Base/* NamedFunction1 */.TV {
  static type() {
    return "intToBool";
  }
  func(v) {
    return Boolean(v);
  }
}
class floatToInt extends functions_Base/* NamedFunction1 */.TV {
  static type() {
    return "floatToInt";
  }
  func(v) {
    return Math.round(v);
  }
}
class intToFloat extends functions_Base/* NamedFunction1 */.TV {
  static type() {
    return "intToFloat";
  }
  func(v) {
    return v;
  }
}
class floatToColor extends functions_Base/* NamedFunction4 */.Vm {
  static type() {
    return "floatToColor";
  }
  func(r, g, b, target) {
    target.r = r;
    target.g = g;
    target.b = b;
    return target;
  }
}
class floatToVec2 extends functions_Base/* NamedFunction3 */.Dv {
  static type() {
    return "floatToVec2";
  }
  func(x, y, target) {
    target.x = x;
    target.y = y;
    return target;
  }
}
class floatToVec3 extends functions_Base/* NamedFunction4 */.Vm {
  static type() {
    return "floatToVec3";
  }
  func(x, y, z, target) {
    target.x = x;
    target.y = y;
    target.z = z;
    return target;
  }
}
class floatToVec4 extends functions_Base/* NamedFunction5 */.t9 {
  static type() {
    return "floatToVec4";
  }
  func(x, y, z, w, target) {
    target.x = x;
    target.y = y;
    target.z = z;
    target.w = w;
    return target;
  }
}
class vec2ToVec3 extends functions_Base/* NamedFunction3 */.Dv {
  static type() {
    return "vec2ToVec3";
  }
  func(src, z, target) {
    target.x = src.x;
    target.y = src.y;
    target.z = z;
    return target;
  }
}
class vec3ToVec4 extends functions_Base/* NamedFunction3 */.Dv {
  static type() {
    return "vec3ToVec4";
  }
  func(src, w, target) {
    target.x = src.x;
    target.y = src.y;
    target.z = src.z;
    target.w = w;
    return target;
  }
}
class vec3ToColor extends functions_Base/* NamedFunction2 */.CE {
  static type() {
    return "vec3ToColor";
  }
  func(src, target) {
    target.r = src.x;
    target.g = src.y;
    target.b = src.z;
    return target;
  }
}
class colorToVec3 extends functions_Base/* NamedFunction2 */.CE {
  static type() {
    return "colorToVec3";
  }
  func(src, target) {
    target.x = src.r;
    target.y = src.g;
    target.z = src.b;
    return target;
  }
}
class Vec3ToColor extends (/* unused pure expression or super */ null && (NamedFunction2)) {
  static type() {
    return "vec3ToColor";
  }
  func(src, target) {
    target.r = src.x;
    target.g = src.y;
    target.b = src.z;
    return target;
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/functions/_Box3.ts


class box3Set extends functions_Base/* NamedFunction3 */.Dv {
  static type() {
    return "box3Set";
  }
  func(min, max, target) {
    target.min.copy(min);
    target.max.copy(max);
    return target;
  }
}
class box3SetFromObject extends functions_Base/* ObjectNamedFunction2 */.YS {
  static type() {
    return "box3SetFromObject";
  }
  func(object, precise, target) {
    object.updateMatrix();
    target.setFromObject(object, precise);
    return target;
  }
}
class box3ContainsPoint extends functions_Base/* NamedFunction2 */.CE {
  static type() {
    return "box3ContainsPoint";
  }
  func(box3, point) {
    return box3.containsPoint(point);
  }
}
class box3IntersectsBox3 extends functions_Base/* NamedFunction2 */.CE {
  static type() {
    return "box3IntersectsBox3";
  }
  func(box3a, box3b) {
    return box3a.intersectsBox(box3b);
  }
}
class getBox3Center extends functions_Base/* NamedFunction2 */.CE {
  static type() {
    return "getBox3Center";
  }
  func(box3, target) {
    return box3.getCenter(target);
  }
}
class getBox3Min extends functions_Base/* NamedFunction2 */.CE {
  static type() {
    return "getBox3Min";
  }
  func(box3, target) {
    return target.copy(box3.min);
  }
}
class getBox3Max extends functions_Base/* NamedFunction2 */.CE {
  static type() {
    return "getBox3Max";
  }
  func(box3, target) {
    return target.copy(box3.max);
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/functions/_Curve.ts


class catmullRomCurve3GetPoint extends functions_Base/* NamedFunction3 */.Dv {
  static type() {
    return "catmullRomCurve3GetPoint";
  }
  func(curve, t, target) {
    curve.getPoint(t, target);
    return target;
  }
}

// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/core/keyframes/KeyframeSamples.ts
var KeyframeSamples = __webpack_require__(13824);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/core/keyframes/Channel.ts + 2 modules
var Channel = __webpack_require__(31369);
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/functions/_Keyframes.ts




function _getChannelByIndexOrFirst(data, index) {
  if (data.length > index) {
    return data[index];
  } else {
    return data[0] || (0,KeyframeSamples/* sampleData0 */.y)();
  }
}
class channelFloat extends functions_Base/* NamedFunction1 */.TV {
  static type() {
    return "channelFloat";
  }
  func(data) {
    return new Channel/* Channel */.$(data);
  }
}
class channelVector2 extends functions_Base/* NamedFunction1 */.TV {
  static type() {
    return "channelVector2";
  }
  func(data) {
    return {
      x: new Channel/* Channel */.$(_getChannelByIndexOrFirst(data, 0)),
      y: new Channel/* Channel */.$(_getChannelByIndexOrFirst(data, 1))
    };
  }
}
class channelVector3 extends functions_Base/* NamedFunction1 */.TV {
  static type() {
    return "channelVector3";
  }
  func(data) {
    return {
      x: new Channel/* Channel */.$(_getChannelByIndexOrFirst(data, 0)),
      y: new Channel/* Channel */.$(_getChannelByIndexOrFirst(data, 1)),
      z: new Channel/* Channel */.$(_getChannelByIndexOrFirst(data, 2))
    };
  }
}
class channelVector4 extends functions_Base/* NamedFunction1 */.TV {
  static type() {
    return "channelVector4";
  }
  func(data) {
    return {
      x: new Channel/* Channel */.$(_getChannelByIndexOrFirst(data, 0)),
      y: new Channel/* Channel */.$(_getChannelByIndexOrFirst(data, 1)),
      z: new Channel/* Channel */.$(_getChannelByIndexOrFirst(data, 2)),
      w: new Channel/* Channel */.$(_getChannelByIndexOrFirst(data, 3))
    };
  }
}
class channelValueFloat extends functions_Base/* NamedFunction2 */.CE {
  static type() {
    return "channelValueFloat";
  }
  func(channel, t) {
    return channel.value(t);
  }
}
class channelValueVector2 extends functions_Base/* NamedFunction3 */.Dv {
  static type() {
    return "channelValueVector2";
  }
  func(channel, t, target) {
    target.x = channel.x.value(t);
    target.y = channel.y.value(t);
    return target;
  }
}
class channelValueVector3 extends functions_Base/* NamedFunction3 */.Dv {
  static type() {
    return "channelValueVector3";
  }
  func(channel, t, target) {
    target.x = channel.x.value(t);
    target.y = channel.y.value(t);
    target.z = channel.z.value(t);
    return target;
  }
}
class channelValueVector4 extends functions_Base/* NamedFunction3 */.Dv {
  static type() {
    return "channelValueVector4";
  }
  func(channel, t, target) {
    target.x = channel.x.value(t);
    target.y = channel.y.value(t);
    target.z = channel.z.value(t);
    target.w = channel.w.value(t);
    return target;
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/functions/_Math.ts





class clamp extends functions_Base/* NamedFunction3 */.Dv {
  static type() {
    return "clamp";
  }
  func(value, min, max) {
    return (0,_Module/* clamp */.uZ)(value, min, max);
  }
}
class _Math_complement extends functions_Base/* NamedFunction1 */.TV {
  static type() {
    return "complement";
  }
  func(value) {
    return 1 - value;
  }
}
class _Math_degToRad extends functions_Base/* NamedFunction1 */.TV {
  static type() {
    return "degToRad";
  }
  func(value) {
    return (0,_Module/* degToRad */.Id)(value);
  }
}
class radToDeg extends functions_Base/* NamedFunction1 */.TV {
  static type() {
    return "radToDeg";
  }
  func(value) {
    return (0,_Module/* radToDeg */.ZY)(value);
  }
}
class _Math_fit extends functions_Base/* NamedFunction5 */.t9 {
  static type() {
    return "fit";
  }
  func(value, srcMin, srcMax, destMin, destMax) {
    return (0,_Module/* fit */.Tj)(value, srcMin, srcMax, destMin, destMax);
  }
}
class fitClamp extends functions_Base/* NamedFunction5 */.t9 {
  static type() {
    return "fitClamp";
  }
  func(value, srcMin, srcMax, destMin, destMax) {
    return (0,_Module/* fitClamp */.K5)(value, srcMin, srcMax, destMin, destMax);
  }
}
class mix extends functions_Base/* NamedFunction3 */.Dv {
  static type() {
    return "mix";
  }
  func(value0, value1, blend) {
    return (0,_Module/* mix */.CD)(value0, value1, blend);
  }
}
class mod extends functions_Base/* NamedFunction2 */.CE {
  static type() {
    return "mod";
  }
  func(v1, v2) {
    return (0,_Module/* mod */.wQ)(v1, v2);
  }
}
class multAdd extends functions_Base/* NamedFunction4 */.Vm {
  static type() {
    return "multAdd";
  }
  func(value, preAdd, mult, postAdd) {
    return (value + preAdd) * mult + postAdd;
  }
}
class negate extends functions_Base/* NamedFunction1 */.TV {
  static type() {
    return "negate";
  }
  func(value) {
    if ((0,Type/* isBoolean */.jn)(value)) {
      return !value;
    } else {
      return -value;
    }
  }
}
class rand extends functions_Base/* NamedFunction2 */.CE {
  static type() {
    return "rand";
  }
  func(value0, value1) {
    return (0,_Module/* randFloat */.Qy)(value0, value1);
  }
}
class random extends functions_Base/* NamedFunction0 */.Fp {
  static type() {
    return "random";
  }
  func() {
    (0,CoreReactivity/* dummyReadRefVal */.Jb)(this.timeController.timeUniform().value);
    return Math.random();
  }
}
class smoothstep extends functions_Base/* NamedFunction3 */.Dv {
  static type() {
    return "smoothstep";
  }
  func(value, min, max) {
    return (0,_Module/* smoothstep */.CW)(value, min, max);
  }
}
class smootherstep extends functions_Base/* NamedFunction3 */.Dv {
  static type() {
    return "smootherstep";
  }
  func(value, min, max) {
    return (0,_Module/* smootherstep */.iB)(value, min, max);
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/core/cloth/ClothSolver.ts




function _addParamPrefix(uniformName) {
  return `${uniform/* UNIFORM_PARAM_PREFIX */.l}${uniformName}`;
}
function _addTexturePrefix(uniformName) {
  return `${uniform/* UNIFORM_TEXTURE_PREFIX */.f}${uniformName}`;
}
function ClothSolver_clothSolverStepSimulation(clothObject, stepsCount, constraintInfluence, viscosity, spring, uniformConfig) {
  const controller = clothControllerFromObject(clothObject);
  if (!controller) {
    console.log("no controller for", clothObject.uuid);
    return;
  }
  controller.stepsCount = stepsCount;
  controller.constraintInfluence = constraintInfluence;
  controller.viscosity = viscosity;
  controller.spring = spring;
  controller.update(uniformConfig);
}
function ClothSolver_clothSolverUpdateMaterial(material, uniformConfig, uniformNameConfig) {
  const uniforms = OnBeforeCompile/* MaterialUserDataUniforms.getUniforms */.Hc.getUniforms(material);
  if (!uniforms) {
    return;
  }
  uniforms[_addParamPrefix(uniformNameConfig.tSize)].value = uniformConfig.tSize;
  uniforms[_addTexturePrefix(uniformNameConfig.tPosition0)].value = uniformConfig.tPosition0;
  uniforms[_addTexturePrefix(uniformNameConfig.tPosition1)].value = uniformConfig.tPosition1;
  uniforms[_addTexturePrefix(uniformNameConfig.tNormal)].value = uniformConfig.tNormal;
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/functions/_Cloth.ts






const _Cloth_v3 = new three_module.Vector3();
class clothSolverReset extends functions_Base/* ObjectNamedFunction0 */.jY {
  static type() {
    return "clothSolverReset";
  }
  func(object3D) {
    const clothSolverNode = getClothControllerNodeFromWorldObject(object3D, this.scene);
    if (!clothSolverNode) {
      return;
    }
    clothSolverNode.setDirty();
  }
}
let uniformConfig;
let uniformNameConfig;
class clothSolverStepSimulation extends functions_Base/* ObjectNamedFunction5 */.o$ {
  static type() {
    return "clothSolverStepSimulation";
  }
  func(object3D, stepsCount, constraintInfluence, viscosity, spring, uniformConfigRef) {
    ClothSolver_clothSolverStepSimulation(object3D, stepsCount, constraintInfluence, viscosity, spring, uniformConfigRef);
  }
}
class clothSolverUpdateMaterial extends functions_Base/* NamedFunction9 */.zo {
  static type() {
    return "clothSolverUpdateMaterial";
  }
  func(material, tSizeName, tPosition0Name, tPosition1Name, tNormalName, tSize, tPosition0, tPosition1, tNormal) {
    uniformConfig = uniformConfig || { tSize, tPosition0, tPosition1, tNormal };
    uniformConfig.tSize = tSize;
    uniformConfig.tPosition0 = tPosition0;
    uniformConfig.tPosition1 = tPosition1;
    uniformConfig.tNormal = tNormal;
    uniformNameConfig = uniformNameConfig || {
      tSize: tSizeName,
      tPosition0: tPosition0Name,
      tPosition1: tPosition1Name,
      tNormal: tNormalName
    };
    uniformNameConfig.tSize = tSizeName;
    uniformNameConfig.tPosition0 = tPosition0Name;
    uniformNameConfig.tPosition1 = tPosition1Name;
    uniformNameConfig.tNormal = tNormalName;
    ClothSolver_clothSolverUpdateMaterial(material, uniformConfig, uniformNameConfig);
  }
}
class clothCreateConstraint extends functions_Base/* ObjectNamedFunction1 */.c_ {
  static type() {
    return "clothCreateConstraint";
  }
  func(object3D, index) {
    const controller = clothControllerFromObject(object3D);
    if (controller) {
      controller.createConstraint(index);
    }
  }
}
class clothDeleteConstraint extends functions_Base/* ObjectNamedFunction0 */.jY {
  static type() {
    return "clothDeleteConstraint";
  }
  func(object3D) {
    const controller = clothControllerFromObject(object3D);
    if (controller) {
      controller.deleteConstraint();
    }
  }
}
class clothConstraintSetPosition extends functions_Base/* ObjectNamedFunction2 */.YS {
  static type() {
    return "clothConstraintSetPosition";
  }
  func(object3D, position, lerp) {
    const controller = clothControllerFromObject(object3D);
    if (controller) {
      if (lerp >= 1) {
        controller.setConstraintPosition(position);
      } else {
        controller.constraintPosition(_Cloth_v3);
        _Cloth_v3.lerp(position, lerp);
        controller.setConstraintPosition(position);
      }
    }
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/functions/_Color.ts


function _hsvToRgb(h, s, v, target) {
  const i = Math.floor(h * 6);
  const f = h * 6 - i;
  const p = v * (1 - s);
  const q = v * (1 - f * s);
  const t = v * (1 - (1 - f) * s);
  switch (i % 6) {
    case 0:
      target.r = v, target.g = t, target.b = p;
      break;
    case 1:
      target.r = q, target.g = v, target.b = p;
      break;
    case 2:
      target.r = p, target.g = v, target.b = t;
      break;
    case 3:
      target.r = p, target.g = q, target.b = v;
      break;
    case 4:
      target.r = t, target.g = p, target.b = v;
      break;
    case 5:
      target.r = v, target.g = p, target.b = q;
      break;
  }
}
class colorSetRGB extends functions_Base/* NamedFunction4 */.Vm {
  static type() {
    return "colorSetRGB";
  }
  func(color, r, g, b) {
    color.r = r;
    color.g = g;
    color.b = b;
    return color;
  }
}
class hsvToRgb extends functions_Base/* NamedFunction2 */.CE {
  static type() {
    return "hsvToRgb";
  }
  func(hsv, target) {
    _hsvToRgb(hsv.x, hsv.y, hsv.z, target);
    return target;
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/core/softBody/SoftBodySolver.ts



const bboxCenter = new three_module.Vector3();
const targetPosition = new three_module.Vector3();
const SoftBodySolver_delta = new three_module.Vector3();
function SoftBodySolver_softBodySolverStepSimulation(softBodyObject, stepsCount, edgeCompliance, volumeCompliance, preciseCollisions) {
  const controller = SoftBodyControllerRegister_softBodyControllerFromObject(softBodyObject);
  if (!controller) {
    console.log("no controller for", softBodyObject.uuid, softBodyObject);
    return;
  }
  controller.step(stepsCount, edgeCompliance, volumeCompliance, preciseCollisions);
}
function setSoftBodySolverGravity(softBodyObject, gravity, lerp) {
  const controller = softBodyControllerFromObject(softBodyObject);
  if (!controller) {
    console.log("no controller for", softBodyObject.uuid);
    return;
  }
  console.warn("setGravity not implemented");
}
function SoftBodySolver_softBodySetPosition(softBodyObject, position, lerp) {
  const softBody = softBodyFromObject(softBodyObject);
  if (!softBody) {
    console.log("no softBody for", softBodyObject.uuid);
    return;
  }
  if (!softBodyObject.geometry) {
    return;
  }
  softBodyObject.geometry.computeBoundingBox();
  if (!softBodyObject.geometry.boundingBox) {
    return;
  }
  softBodyObject.geometry.boundingBox.getCenter(bboxCenter);
  targetPosition.copy(bboxCenter).lerp(position, lerp);
  SoftBodySolver_delta.copy(targetPosition).sub(bboxCenter);
  softBody.translate(SoftBodySolver_delta);
}
function SoftBodySolver_softBodyMultiplyVelocity(softBodyObject, mult) {
  const softBody = softBodyFromObject(softBodyObject);
  if (!softBody) {
    console.log("no softBody for", softBodyObject.uuid);
    return;
  }
  softBody.velocityMult(mult);
}
function SoftBodySolver_softBodyConstraintCreate(softBodyObject, index) {
  const softBody = softBodyFromObject(softBodyObject);
  if (!softBody) {
    console.log("no softBody for", softBodyObject.uuid);
    return;
  }
  return softBody.createConstraint(index);
}
function SoftBodySolver_softBodyConstraintSetPosition(softBodyObject, constraintId, pos, lerp, delta2) {
  const softBody = softBodyFromObject(softBodyObject);
  if (!softBody) {
    console.log("no softBody for", softBodyObject.uuid);
    return;
  }
  const constraint = softBody.getConstraint(constraintId);
  if (!constraint) {
    return;
  }
  constraint.setPosition(pos, lerp, delta2);
}
function SoftBodySolver_softBodyConstraintDelete(softBodyObject, constraintId) {
  const softBody = softBodyFromObject(softBodyObject);
  if (!softBody) {
    console.log("no softBody for", softBodyObject.uuid);
    return;
  }
  softBody.deleteConstraint(constraintId);
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/functions/_SoftBody.ts





const _SoftBody_v3 = new three_module.Vector3();
class softBodySolverReset extends (/* unused pure expression or super */ null && (ObjectNamedFunction0)) {
  static type() {
    return "softBodySolverReset";
  }
  func(object3D) {
    const softBodySolverNode = getSoftBodyControllerNodeFromSolverObject(object3D, this.scene);
    if (!softBodySolverNode) {
      return;
    }
    softBodySolverNode.setDirty();
  }
}
class softBodySolverStepSimulation extends functions_Base/* ObjectNamedFunction4 */.eG {
  static type() {
    return "softBodySolverStepSimulation";
  }
  func(object3D, stepsCount, edgeCompliance, volumeCompliance, preciseCollisions) {
    SoftBodySolver_softBodySolverStepSimulation(object3D, stepsCount, edgeCompliance, volumeCompliance, preciseCollisions);
  }
}
class computeVelocity extends functions_Base/* NamedFunction5 */.t9 {
  static type() {
    return "computeVelocity";
  }
  func(velocity, forces, dt, drag, target) {
    _SoftBody_v3.copy(forces).multiplyScalar(dt);
    target.copy(velocity).multiplyScalar(drag).add(_SoftBody_v3);
    return target;
  }
}
class softBodySetPosition extends functions_Base/* ObjectNamedFunction2 */.YS {
  static type() {
    return "softBodySetPosition";
  }
  func(object3D, position, lerp) {
    SoftBodySolver_softBodySetPosition(object3D, position, lerp);
  }
}
class softBodyMultiplyVelocity extends functions_Base/* ObjectNamedFunction1 */.c_ {
  static type() {
    return "softBodyMultiplyVelocity";
  }
  func(object3D, mult) {
    SoftBodySolver_softBodyMultiplyVelocity(object3D, mult);
  }
}
class softBodyConstraintCreate extends functions_Base/* ObjectNamedFunction2 */.YS {
  static type() {
    return "softBodyConstraintCreate";
  }
  func(object3D, index, constraintIdRef) {
    const constraint = SoftBodySolver_softBodyConstraintCreate(object3D, index);
    if (constraint) {
      constraintIdRef.value = constraint.id;
    }
  }
}
class softBodyConstraintSetPosition extends functions_Base/* ObjectNamedFunction3 */.uW {
  static type() {
    return "softBodyConstraintSetPosition";
  }
  func(object3D, constraintId, position, lerp) {
    const delta = this.scene.timeController.delta();
    SoftBodySolver_softBodyConstraintSetPosition(object3D, constraintId, position, lerp, delta);
  }
}
class softBodyConstraintDelete extends functions_Base/* ObjectNamedFunction1 */.c_ {
  static type() {
    return "softBodyConstraintDelete";
  }
  func(object3D, constraintId) {
    SoftBodySolver_softBodyConstraintDelete(object3D, constraintId);
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/functions/_CookNode.ts


class cookNode extends functions_Base/* NamedFunction1 */.TV {
  static type() {
    return "cookNode";
  }
  func(nodePath) {
    const node = this.scene.node(nodePath);
    if (node) {
      node.setDirty();
      node.compute();
    }
  }
}

// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/core/reactivity/ParamReactivity.ts
var ParamReactivity = __webpack_require__(27088);
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/functions/_Param.ts




function dummyReadRefVal(value) {
}
const tmpColor = new three_module.Color();
const _Param_tmpV2 = new three_module.Vector2();
const _Param_tmpV3 = new three_module.Vector3();
const tmpV4 = new three_module.Vector4();
const tmpN2 = [0, 0];
const tmpN3 = [0, 0, 0];
const tmpN4 = [0, 0, 0, 0];
function _getParam(scene, paramPath) {
  dummyReadRefVal(scene.graphNodesController.pathRef(paramPath).value);
  const elements = paramPath.split("/");
  const paramName = elements.pop();
  const nodePath = elements.join("/");
  const node = scene.node(nodePath);
  if (!node) {
    return;
  }
  const param = node.params.get(paramName);
  if (!param) {
    return;
  }
  return param;
}
class getParam extends functions_Base/* NamedFunction1 */.TV {
  static type() {
    return "getParam";
  }
  func(paramPath) {
    return _getParam(this.scene, paramPath);
  }
}
class setParamBoolean extends functions_Base/* NamedFunction2 */.CE {
  static type() {
    return "setParamBoolean";
  }
  func(param, value) {
    if (param) {
      param.set(value);
      (0,ParamReactivity/* touchParamRefFromParam */.W7)(param);
    } else {
      console.warn(`setParamBoolean: no param`);
    }
  }
}
class setParamBooleanToggle extends functions_Base/* NamedFunction1 */.TV {
  static type() {
    return "setParamBooleanToggle";
  }
  func(param) {
    if (param) {
      param.set(!param.value);
      (0,ParamReactivity/* touchParamRefFromParam */.W7)(param);
    } else {
      console.warn(`setParamBooleanToggle: no param`);
    }
  }
}
class setParamColor extends functions_Base/* NamedFunction3 */.Dv {
  static type() {
    return "setParamColor";
  }
  func(param, value, lerp) {
    if (param) {
      if (lerp >= 1) {
        param.set(value);
      } else {
        tmpColor.copy(param.value);
        tmpColor.lerp(value, lerp);
        tmpColor.toArray(tmpN3);
        param.set(tmpN3);
      }
      (0,ParamReactivity/* touchParamRefFromParam */.W7)(param);
    } else {
      console.warn(`setParamColor: no param`);
    }
  }
}
class setParamFloat extends functions_Base/* NamedFunction3 */.Dv {
  static type() {
    return "setParamFloat";
  }
  func(param, value, lerp) {
    if (param) {
      if (lerp >= 1) {
        param.set(value);
      } else {
        param.set(value * lerp + (1 - lerp) * param.value);
      }
      (0,ParamReactivity/* touchParamRefFromParam */.W7)(param);
    } else {
      console.warn(`setParamFloat: no param`);
    }
  }
}
class setParamInteger extends functions_Base/* NamedFunction3 */.Dv {
  static type() {
    return "setParamInteger";
  }
  func(param, value, lerp) {
    if (param) {
      if (lerp >= 1) {
        param.set(value);
      } else {
        param.set(value * lerp + (1 - lerp) * param.value);
      }
      (0,ParamReactivity/* touchParamRefFromParam */.W7)(param);
    } else {
      console.warn(`setParamInteger: no param`);
    }
  }
}
class setParamString extends functions_Base/* NamedFunction2 */.CE {
  static type() {
    return "setParamString";
  }
  func(param, value) {
    if (param) {
      param.set(value);
      (0,ParamReactivity/* touchParamRefFromParam */.W7)(param);
    } else {
      console.warn(`setParamString: no param`);
    }
  }
}
class setParamVector2 extends functions_Base/* NamedFunction3 */.Dv {
  static type() {
    return "setParamVector2";
  }
  func(param, value, lerp) {
    if (param) {
      if (lerp >= 1) {
        param.set(value);
      } else {
        _Param_tmpV2.copy(param.value);
        _Param_tmpV2.lerp(value, lerp);
        _Param_tmpV2.toArray(tmpN2);
        param.set(tmpN2);
      }
      (0,ParamReactivity/* touchParamRefFromParam */.W7)(param);
    } else {
      console.warn(`setParamVector2: no param`);
    }
  }
}
class setParamVector3 extends functions_Base/* NamedFunction3 */.Dv {
  static type() {
    return "setParamVector3";
  }
  func(param, value, lerp) {
    if (param) {
      if (lerp >= 1) {
        param.set(value);
      } else {
        _Param_tmpV3.copy(param.value);
        _Param_tmpV3.lerp(value, lerp);
        _Param_tmpV3.toArray(tmpN3);
        param.set(tmpN3);
      }
      (0,ParamReactivity/* touchParamRefFromParam */.W7)(param);
    } else {
      console.warn(`setParamVector3: no param`);
    }
  }
}
class setParamVector4 extends functions_Base/* NamedFunction3 */.Dv {
  static type() {
    return "setParamVector4";
  }
  func(param, value, lerp) {
    if (param) {
      if (lerp >= 1) {
        param.set(value);
      } else {
        tmpV4.copy(param.value);
        tmpV4.lerp(value, lerp);
        tmpV4.toArray(tmpN4);
        param.set(tmpN4);
      }
      (0,ParamReactivity/* touchParamRefFromParam */.W7)(param);
    } else {
      console.warn(`setParamVector4: no param`);
    }
  }
}
class pressButtonParam extends functions_Base/* NamedFunction1 */.TV {
  static type() {
    return "pressButtonParam";
  }
  func(param) {
    if (param) {
      param.pressButton();
      (0,ParamReactivity/* touchParamRefFromParam */.W7)(param);
    } else {
      console.warn(`pressButtonParam: no param`);
    }
  }
}

// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/core/reactivity/NodeReactivity.ts
var NodeReactivity = __webpack_require__(20824);
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/functions/_Object3D.ts

var _Object3D_async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};





class getGeometryNodeObjects extends functions_Base/* NamedFunction2 */.CE {
  constructor() {
    super(...arguments);
    this.async = true;
  }
  static type() {
    return "getGeometryNodeObjects";
  }
  func(node, objects) {
    return _Object3D_async(this, null, function* () {
      var _a;
      dummyReadRefVal((0,NodeReactivity/* getOrCreateNodeRef */.Dm)(node.path()).value);
      if (node && node.context() == poly_NodeContext/* NodeContext.SOP */.sy.SOP) {
        const geometryNode = node;
        const container = yield geometryNode.compute();
        const nodeObjects = ((_a = container.coreContent()) == null ? void 0 : _a.threejsObjects()) || [];
        objects.length = 0;
        for (let object of nodeObjects) {
          objects.push(object);
        }
      }
    });
  }
}
class createObject extends functions_Base/* ObjectNamedFunction1 */.c_ {
  static type() {
    return "createObject";
  }
  func(parent, child) {
    if (child) {
      (0,PolyOnObjectsAddRemoveHooksController/* addToParent */.Vr)(this.scene, parent, child);
    }
  }
}
class createObjects extends functions_Base/* ObjectNamedFunction1 */.c_ {
  static type() {
    return "createObjects";
  }
  func(parent, children) {
    for (let child of children) {
      if (child) {
        (0,PolyOnObjectsAddRemoveHooksController/* addToParent */.Vr)(this.scene, parent, child);
      }
    }
  }
}
class objectDelete extends functions_Base/* ObjectNamedFunction0 */.jY {
  static type() {
    return "objectDelete";
  }
  func(object3D) {
    (0,PolyOnObjectsAddRemoveHooksController/* removeFromParent */.x)(this.scene, object3D);
  }
}

// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/core/physics/PhysicsJoint.ts
var PhysicsJoint = __webpack_require__(82637);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/core/physics/shapes/RBDCone.ts
var RBDCone = __webpack_require__(73299);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/core/physics/shapes/RBDCylinder.ts
var RBDCylinder = __webpack_require__(33383);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/core/physics/shapes/RBDSphere.ts
var RBDSphere = __webpack_require__(85240);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/core/reactivity/RBDPropertyReactivity.ts
var RBDPropertyReactivity = __webpack_require__(284);
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/functions/_Physics.ts

















class physicsWorldReset extends functions_Base/* ObjectNamedFunction0 */.jY {
  static type() {
    return "physicsWorldReset";
  }
  func(object3D) {
    const physicsWorldNode = (0,sop_PhysicsWorld/* getPhysicsWorldNodeFromWorldObject */.A)(object3D, this.scene);
    if (!physicsWorldNode) {
      return;
    }
    physicsWorldNode.setDirty();
  }
}
class physicsWorldStepSimulation extends functions_Base/* ObjectNamedFunction0 */.jY {
  static type() {
    return "physicsWorldStepSimulation";
  }
  func(object3D) {
    (0,PhysicsWorld/* stepWorld */.xR)(object3D);
  }
}
class physicsDebugUpdate extends functions_Base/* ObjectNamedFunction0 */.jY {
  static type() {
    return "physicsDebugUpdate";
  }
  func(object3D) {
    (0,PhysicsDebug/* updatePhysicsDebugObject */.t)(object3D);
  }
}
class setPhysicsWorldGravity extends functions_Base/* ObjectNamedFunction2 */.YS {
  static type() {
    return "setPhysicsWorldGravity";
  }
  func(object3D, gravity, lerp) {
    (0,PhysicsWorld/* setWorldGravity */.Ri)(object3D, gravity, lerp);
  }
}
class getPhysicsRBD extends functions_Base/* NamedFunction1 */.TV {
  static type() {
    return "getPhysicsRBD";
  }
  func(rbdId) {
    (0,CoreReactivity/* dummyReadRefVal */.Jb)(this.timeController.timeUniform().value);
    return (0,PhysicsRBD/* _getRBDFromId */.zu)(rbdId);
  }
}
class getPhysicsRBDCapsuleRadius extends functions_Base/* ObjectNamedFunction0 */.jY {
  static type() {
    return "getPhysicsRBDCapsuleRadius";
  }
  func(object3D) {
    (0,CoreReactivity/* dummyReadRefVal */.Jb)((0,RBDPropertyReactivity/* getOrCreatePropertyRef */.$I)(this.timeController, object3D, RBDCapsule/* RBDCapsuleProperty.RADIUS */.ND.RADIUS).value);
    return (0,RBDCapsule/* _getPhysicsRBDCapsuleRadius */.QL)(object3D);
  }
}
class getPhysicsRBDCapsuleHeight extends functions_Base/* ObjectNamedFunction0 */.jY {
  static type() {
    return "getPhysicsRBDCapsuleHeight";
  }
  func(object3D) {
    (0,CoreReactivity/* dummyReadRefVal */.Jb)((0,RBDPropertyReactivity/* getOrCreatePropertyRef */.$I)(this.timeController, object3D, RBDCapsule/* RBDCapsuleProperty.HEIGHT */.ND.HEIGHT).value);
    return (0,RBDCapsule/* _getPhysicsRBDCapsuleRadius */.QL)(object3D);
  }
}
class getPhysicsRBDConeHeight extends functions_Base/* ObjectNamedFunction0 */.jY {
  static type() {
    return "getPhysicsRBDConeHeight";
  }
  func(object3D) {
    (0,CoreReactivity/* dummyReadRefVal */.Jb)((0,RBDPropertyReactivity/* getOrCreatePropertyRef */.$I)(this.timeController, object3D, _CommonHeightRadius/* RBDCommonProperty.HEIGHT */.n7.HEIGHT).value);
    return (0,RBDCone/* _getPhysicsRBDConeHeight */.rj)(object3D);
  }
}
class getPhysicsRBDConeRadius extends functions_Base/* ObjectNamedFunction0 */.jY {
  static type() {
    return "getPhysicsRBDConeRadius";
  }
  func(object3D) {
    (0,CoreReactivity/* dummyReadRefVal */.Jb)((0,RBDPropertyReactivity/* getOrCreatePropertyRef */.$I)(this.timeController, object3D, _CommonHeightRadius/* RBDCommonProperty.RADIUS */.n7.RADIUS).value);
    return (0,RBDCone/* _getPhysicsRBDConeRadius */.mI)(object3D);
  }
}
class getPhysicsRBDCuboidSizes extends functions_Base/* ObjectNamedFunction1 */.c_ {
  static type() {
    return "getPhysicsRBDCuboidSizes";
  }
  func(object3D, target) {
    (0,CoreReactivity/* dummyReadRefVal */.Jb)((0,RBDPropertyReactivity/* getOrCreatePropertyRef */.$I)(this.timeController, object3D, RBDCuboid/* RBDCuboidProperty.SIZES */.oF.SIZES).value);
    (0,RBDCuboid/* _getPhysicsRBDCuboidSizes */.zk)(object3D, target);
    return target;
  }
}
class getPhysicsRBDCylinderHeight extends functions_Base/* ObjectNamedFunction0 */.jY {
  static type() {
    return "getPhysicsRBDCylinderHeight";
  }
  func(object3D) {
    (0,CoreReactivity/* dummyReadRefVal */.Jb)((0,RBDPropertyReactivity/* getOrCreatePropertyRef */.$I)(this.timeController, object3D, _CommonHeightRadius/* RBDCommonProperty.HEIGHT */.n7.HEIGHT).value);
    return (0,RBDCylinder/* _getPhysicsRBDCylinderHeight */.bI)(object3D);
  }
}
class getPhysicsRBDCylinderRadius extends functions_Base/* ObjectNamedFunction0 */.jY {
  static type() {
    return "getPhysicsRBDCylinderRadius";
  }
  func(object3D) {
    (0,CoreReactivity/* dummyReadRefVal */.Jb)((0,RBDPropertyReactivity/* getOrCreatePropertyRef */.$I)(this.timeController, object3D, _CommonHeightRadius/* RBDCommonProperty.RADIUS */.n7.RADIUS).value);
    return (0,RBDCylinder/* _getPhysicsRBDCylinderRadius */.KM)(object3D);
  }
}
class getPhysicsRBDSphereRadius extends functions_Base/* ObjectNamedFunction0 */.jY {
  static type() {
    return "getPhysicsRBDSphereRadius";
  }
  func(object3D) {
    (0,CoreReactivity/* dummyReadRefVal */.Jb)((0,RBDPropertyReactivity/* getOrCreatePropertyRef */.$I)(this.timeController, object3D, _CommonHeightRadius/* RBDCommonProperty.RADIUS */.n7.RADIUS).value);
    return (0,RBDSphere/* _getPhysicsRBDSphereRadius */.wd)(object3D);
  }
}
class setPhysicsRBDCapsuleProperty extends functions_Base/* ObjectNamedFunction3 */.uW {
  static type() {
    return "setPhysicsRBDCapsuleProperty";
  }
  func(object3D, scale, lerp, updateMatrix) {
    (0,RBDCapsule/* _setPhysicsRBDCapsuleProperty */.bm)(object3D, scale, lerp, updateMatrix);
  }
}
class setPhysicsRBDConeProperty extends functions_Base/* ObjectNamedFunction4 */.eG {
  static type() {
    return "setPhysicsRBDConeProperty";
  }
  func(object3D, radius, height, lerp, updateMatrix) {
    (0,RBDCone/* _setPhysicsRBDConeProperty */.DH)(object3D, radius, height, lerp, updateMatrix);
  }
}
class setPhysicsRBDCuboidProperty extends functions_Base/* ObjectNamedFunction4 */.eG {
  static type() {
    return "setPhysicsRBDCuboidProperty";
  }
  func(object3D, sizes, size, lerp, updateMatrix) {
    (0,RBDCuboid/* _setPhysicsRBDCuboidProperty */.Sc)(object3D, sizes, size, lerp, updateMatrix);
  }
}
class setPhysicsRBDCylinderProperty extends functions_Base/* ObjectNamedFunction4 */.eG {
  static type() {
    return "setPhysicsRBDCylinderProperty";
  }
  func(object3D, radius, height, lerp, updateMatrix) {
    (0,RBDCylinder/* _setPhysicsRBDCylinderProperty */.dV)(object3D, radius, height, lerp, updateMatrix);
  }
}
class setPhysicsRBDSphereProperty extends functions_Base/* ObjectNamedFunction3 */.uW {
  static type() {
    return "setPhysicsRBDSphereProperty";
  }
  func(object3D, radius, lerp, updateMatrix) {
    (0,RBDSphere/* _setPhysicsRBDSphereProperty */.V0)(object3D, radius, lerp, updateMatrix);
  }
}
class getPhysicsRBDAngularVelocity extends functions_Base/* ObjectNamedFunction1 */.c_ {
  static type() {
    return "getPhysicsRBDAngularVelocity";
  }
  func(object3D, target) {
    const body = (0,PhysicsRBD/* _getRBDFromObject */.fd)(object3D);
    if (body) {
      (0,CoreReactivity/* dummyReadRefVal */.Jb)((0,RBDPropertyReactivity/* getOrCreatePropertyRef */.$I)(this.timeController, object3D, PhysicsRBD/* RBDProperty.ANGULAR_VELOCITY */.mj.ANGULAR_VELOCITY).value);
      const angvel = body.angvel();
      return target.set(angvel.x, angvel.y, angvel.z);
    } else {
      return target.set(0, 0, 0);
    }
  }
}
class getChildrenPhysicsRBDPropertiesAngularVelocity extends functions_Base/* ObjectNamedFunction1 */.c_ {
  static type() {
    return "getChildrenPhysicsRBDPropertiesAngularVelocity";
  }
  func(object3D, values) {
    (0,CoreReactivity/* dummyReadRefVal */.Jb)(this.timeController.timeUniform().value);
    (0,_ArrayUtils/* _matchArrayLength */.X9)(object3D.children, values, () => new three_module.Vector3());
    let i = 0;
    const children = object3D.children;
    for (let child of children) {
      const body = (0,PhysicsRBD/* _getRBDFromObject */.fd)(child);
      if (body) {
        const angvel = body.angvel();
        values[i].set(angvel.x, angvel.y, angvel.z);
      } else {
        values[i].set(0, 0, 0);
      }
      i++;
    }
    return values;
  }
}
class getPhysicsRBDLinearVelocity extends functions_Base/* ObjectNamedFunction1 */.c_ {
  static type() {
    return "getPhysicsRBDLinearVelocity";
  }
  func(object3D, target) {
    const body = (0,PhysicsRBD/* _getRBDFromObject */.fd)(object3D);
    if (body) {
      (0,CoreReactivity/* dummyReadRefVal */.Jb)((0,RBDPropertyReactivity/* getOrCreatePropertyRef */.$I)(this.timeController, object3D, PhysicsRBD/* RBDProperty.LINEAR_VELOCITY */.mj.LINEAR_VELOCITY).value);
      const linvel = body.linvel();
      return target.set(linvel.x, linvel.y, linvel.z);
    } else {
      return target.set(0, 0, 0);
    }
  }
}
class getChildrenPhysicsRBDPropertiesLinearVelocity extends functions_Base/* ObjectNamedFunction1 */.c_ {
  static type() {
    return "getChildrenPhysicsRBDPropertiesLinearVelocity";
  }
  func(object3D, values) {
    (0,CoreReactivity/* dummyReadRefVal */.Jb)(this.timeController.timeUniform().value);
    (0,_ArrayUtils/* _matchArrayLength */.X9)(object3D.children, values, () => new three_module.Vector3());
    let i = 0;
    const children = object3D.children;
    for (let child of children) {
      const body = (0,PhysicsRBD/* _getRBDFromObject */.fd)(child);
      if (body) {
        const linvel = body.linvel();
        values[i].set(linvel.x, linvel.y, linvel.z);
      } else {
        values[i].set(0, 0, 0);
      }
      i++;
    }
    return values;
  }
}
class getPhysicsRBDAngularDamping extends functions_Base/* ObjectNamedFunction0 */.jY {
  static type() {
    return "getPhysicsRBDAngularDamping";
  }
  func(object3D) {
    const body = (0,PhysicsRBD/* _getRBDFromObject */.fd)(object3D);
    if (body) {
      (0,CoreReactivity/* dummyReadRefVal */.Jb)((0,RBDPropertyReactivity/* getOrCreatePropertyRef */.$I)(this.timeController, object3D, PhysicsRBD/* RBDProperty.ANGULAR_DAMPING */.mj.ANGULAR_DAMPING).value);
      return body.angularDamping();
    }
    return 0;
  }
}
class getChildrenPhysicsRBDPropertiesAngularDamping extends functions_Base/* ObjectNamedFunction1 */.c_ {
  static type() {
    return "getChildrenPhysicsRBDPropertiesAngularDamping";
  }
  func(object3D, values) {
    (0,_ArrayUtils/* _matchArrayLength */.X9)(object3D.children, values, () => 0);
    let i = 0;
    const children = object3D.children;
    for (let child of children) {
      const body = (0,PhysicsRBD/* _getRBDFromObject */.fd)(child);
      values[i] = body ? body.angularDamping() : 0;
      i++;
    }
    return values;
  }
}
class getPhysicsRBDLinearDamping extends functions_Base/* ObjectNamedFunction0 */.jY {
  static type() {
    return "getPhysicsRBDLinearDamping";
  }
  func(object3D) {
    const body = (0,PhysicsRBD/* _getRBDFromObject */.fd)(object3D);
    if (body) {
      (0,CoreReactivity/* dummyReadRefVal */.Jb)((0,RBDPropertyReactivity/* getOrCreatePropertyRef */.$I)(this.timeController, object3D, PhysicsRBD/* RBDProperty.LINEAR_DAMPING */.mj.LINEAR_DAMPING).value);
      return body.linearDamping();
    }
    return 0;
  }
}
class getChildrenPhysicsRBDPropertiesLinearDamping extends functions_Base/* ObjectNamedFunction1 */.c_ {
  static type() {
    return "getChildrenPhysicsRBDPropertiesLinearDamping";
  }
  func(object3D, values) {
    (0,_ArrayUtils/* _matchArrayLength */.X9)(object3D.children, values, () => 0);
    let i = 0;
    const children = object3D.children;
    for (let child of children) {
      const body = (0,PhysicsRBD/* _getRBDFromObject */.fd)(child);
      values[i] = body ? body.linearDamping() : 0;
      i++;
    }
    return values;
  }
}
class getPhysicsRBDIsSleeping extends functions_Base/* ObjectNamedFunction0 */.jY {
  static type() {
    return "getPhysicsRBDIsSleeping";
  }
  func(object3D) {
    const body = (0,PhysicsRBD/* _getRBDFromObject */.fd)(object3D);
    if (body) {
      (0,CoreReactivity/* dummyReadRefVal */.Jb)((0,RBDPropertyReactivity/* getOrCreatePropertyRef */.$I)(this.timeController, object3D, PhysicsRBD/* RBDProperty.IS_SLEEPING */.mj.IS_SLEEPING).value);
      return body.isSleeping();
    }
    return false;
  }
}
class getChildrenPhysicsRBDPropertiesIsSleeping extends functions_Base/* ObjectNamedFunction1 */.c_ {
  static type() {
    return "getChildrenPhysicsRBDPropertiesIsSleeping";
  }
  func(object3D, values) {
    (0,_ArrayUtils/* _matchArrayLength */.X9)(object3D.children, values, () => false);
    let i = 0;
    const children = object3D.children;
    for (let child of children) {
      const body = (0,PhysicsRBD/* _getRBDFromObject */.fd)(child);
      values[i] = (body == null ? void 0 : body.isSleeping()) || false;
      i++;
    }
    return values;
  }
}
class getPhysicsRBDIsMoving extends functions_Base/* ObjectNamedFunction0 */.jY {
  static type() {
    return "getPhysicsRBDIsMoving";
  }
  func(object3D) {
    const body = (0,PhysicsRBD/* _getRBDFromObject */.fd)(object3D);
    if (body) {
      (0,CoreReactivity/* dummyReadRefVal */.Jb)((0,RBDPropertyReactivity/* getOrCreatePropertyRef */.$I)(this.timeController, object3D, PhysicsRBD/* RBDProperty.IS_MOVING */.mj.IS_MOVING).value);
      return body.isMoving();
    }
    return false;
  }
}
class getChildrenPhysicsRBDPropertiesIsMoving extends functions_Base/* ObjectNamedFunction1 */.c_ {
  static type() {
    return "getChildrenPhysicsRBDPropertiesIsMoving";
  }
  func(object3D, values) {
    (0,_ArrayUtils/* _matchArrayLength */.X9)(object3D.children, values, () => false);
    let i = 0;
    const children = object3D.children;
    for (let child of children) {
      const body = (0,PhysicsRBD/* _getRBDFromObject */.fd)(child);
      values[i] = (body == null ? void 0 : body.isMoving()) || false;
      i++;
    }
    return values;
  }
}
class setPhysicsRBDPosition extends functions_Base/* ObjectNamedFunction2 */.YS {
  static type() {
    return "setPhysicsRBDPosition";
  }
  func(object3D, position, lerp) {
    (0,PhysicsRBD/* _setPhysicsRBDPosition */.VN)(object3D, position, lerp);
  }
}
class setPhysicsRBDRotation extends functions_Base/* ObjectNamedFunction2 */.YS {
  static type() {
    return "setPhysicsRBDRotation";
  }
  func(object3D, quat, lerp) {
    (0,PhysicsRBD/* _setPhysicsRBDRotation */.zD)(object3D, quat, lerp);
  }
}
class setPhysicsRBDAngularVelocity extends functions_Base/* ObjectNamedFunction2 */.YS {
  static type() {
    return "setPhysicsRBDAngularVelocity";
  }
  func(object3D, velocity, lerp) {
    (0,PhysicsRBD/* _setPhysicsRBDAngularVelocity */.LH)(object3D, velocity, lerp);
  }
}
class setPhysicsRBDLinearVelocity extends functions_Base/* ObjectNamedFunction2 */.YS {
  static type() {
    return "setPhysicsRBDLinearVelocity";
  }
  func(object3D, velocity, lerp) {
    (0,PhysicsRBD/* _setPhysicsRBDLinearVelocity */.D7)(object3D, velocity, lerp);
  }
}
class physicsRBDAddForce extends functions_Base/* ObjectNamedFunction1 */.c_ {
  static type() {
    return "physicsRBDAddForce";
  }
  func(object3D, force) {
    (0,PhysicsRBD/* _physicsRBDAddForce */.BQ)(object3D, force);
  }
}
class physicsRBDAddForceAtPoint extends functions_Base/* ObjectNamedFunction2 */.YS {
  static type() {
    return "physicsRBDAddForceAtPoint";
  }
  func(object3D, force, point) {
    (0,PhysicsRBD/* _physicsRBDAddForceAtPoint */.$I)(object3D, force, point);
  }
}
class physicsRBDAddTorque extends functions_Base/* ObjectNamedFunction1 */.c_ {
  static type() {
    return "physicsRBDAddTorque";
  }
  func(object3D, force) {
    (0,PhysicsRBD/* _physicsRBDAddTorque */.qd)(object3D, force);
  }
}
class physicsRBDApplyTorqueImpulse extends functions_Base/* ObjectNamedFunction1 */.c_ {
  static type() {
    return "physicsRBDApplyTorqueImpulse";
  }
  func(object3D, impulse) {
    (0,PhysicsRBD/* _physicsRBDApplyTorqueImpulse */.Gq)(object3D, impulse);
  }
}
class physicsRBDApplyImpulse extends functions_Base/* ObjectNamedFunction1 */.c_ {
  static type() {
    return "physicsRBDApplyImpulse";
  }
  func(object3D, impulse) {
    (0,PhysicsRBD/* _physicsRBDApplyImpulse */.E6)(object3D, impulse);
  }
}
class physicsRBDApplyImpulseAtPoint extends functions_Base/* ObjectNamedFunction2 */.YS {
  static type() {
    return "physicsRBDApplyImpulseAtPoint";
  }
  func(object3D, impulse, point) {
    (0,PhysicsRBD/* _physicsRBDApplyImpulseAtPoint */.sf)(object3D, impulse, point);
  }
}
class physicsRBDResetAll extends functions_Base/* ObjectNamedFunction1 */.c_ {
  static type() {
    return "physicsRBDResetAll";
  }
  func(object3D, wakeup) {
    (0,PhysicsRBD/* _physicsRBDResetAll */.ej)(object3D, wakeup);
  }
}
class physicsRBDResetForces extends functions_Base/* ObjectNamedFunction1 */.c_ {
  static type() {
    return "physicsRBDResetForces";
  }
  func(object3D, wakeup) {
    (0,PhysicsRBD/* _physicsRBDResetForces */.xF)(object3D, wakeup);
  }
}
class physicsRBDResetTorques extends functions_Base/* ObjectNamedFunction1 */.c_ {
  static type() {
    return "physicsRBDResetTorques";
  }
  func(object3D, wakeup) {
    (0,PhysicsRBD/* _physicsRBDResetTorques */.s3)(object3D, wakeup);
  }
}
class createPhysicsRBD extends functions_Base/* ObjectNamedFunction2 */.YS {
  static type() {
    return "createPhysicsRBD";
  }
  func(worldObject, object, rbdId) {
    const newRBDIds = (0,PhysicsWorld/* physicsCreateRBDFromWorldObject */.kA)(worldObject, object);
    newRBDIds == null ? void 0 : newRBDIds.forEach((id) => {
      rbdId.value = id;
    });
  }
}
class createPhysicsRBDs extends functions_Base/* ObjectNamedFunction2 */.YS {
  static type() {
    return "createPhysicsRBDs";
  }
  func(worldObject, objects, rbdIds) {
    for (let object of objects) {
      const newRBDIds = (0,PhysicsWorld/* physicsCreateRBDFromWorldObject */.kA)(worldObject, object);
      newRBDIds == null ? void 0 : newRBDIds.forEach((id) => {
        rbdIds.value.push(id);
      });
    }
  }
}
class physicsRBDDelete extends functions_Base/* ObjectNamedFunction0 */.jY {
  static type() {
    return "physicsRBDDelete";
  }
  func(object3D) {
    (0,PhysicsRBD/* _physicsRBDDelete */.s6)(this.scene, object3D);
  }
}
class createPhysicsRBDKinematicConstraint extends functions_Base/* ObjectNamedFunction2 */.YS {
  static type() {
    return "createPhysicsRBDKinematicConstraint";
  }
  func(object3D, anchor, rbdIdRef) {
    const rbdId = (0,PhysicsJoint/* _createPhysicsRBDKinematicConstraint */.Hk)(object3D, anchor);
    if (rbdId) {
      rbdIdRef.value = rbdId;
    }
  }
}
class deletePhysicsRBDKinematicConstraint extends functions_Base/* ObjectNamedFunction0 */.jY {
  static type() {
    return "deletePhysicsRBDKinematicConstraint";
  }
  func(object3D) {
    (0,PhysicsJoint/* _deletePhysicsRBDKinematicConstraint */.zI)(this.scene, object3D);
  }
}
class deletePhysicsRBDConstraints extends functions_Base/* ObjectNamedFunction0 */.jY {
  static type() {
    return "deletePhysicsRBDConstraints";
  }
  func(object3D) {
    (0,PhysicsJoint/* _physicsRBDDeleteConstraints */.u5)(object3D);
  }
}

// EXTERNAL MODULE: ../@polygonjs/polygonjs/node_modules/gsap/ScrollTrigger.js + 1 modules
var gsap_ScrollTrigger = __webpack_require__(81169);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/node_modules/gsap/index.js + 2 modules
var gsap = __webpack_require__(409);
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/functions/_Scroll.ts



gsap/* gsap.registerPlugin */.p8.registerPlugin(gsap_ScrollTrigger/* default */.Z);


function _createScrollListener(createOptions, listeners, progressRef) {
  const { useViewport, scroller, displayMarkers, nodePath } = createOptions;
  const _getScroller = () => {
    if (useViewport) {
      console.log("useViewport is true, not finding scroller");
      return;
    }
    const scrollerElement = document.querySelector(scroller);
    if (!scrollerElement) {
      console.log(`no scrollerElement element found with selector '${scroller}'`);
      return;
    }
    return scrollerElement;
  };
  const element = document.querySelector(createOptions.element);
  const options = {
    trigger: element,
    scroller: _getScroller(),
    markers: displayMarkers,
    id: nodePath
  };
  for (let eventName of SCROLL_EVENTS) {
    const listener = listeners[eventName];
    options[eventName] = listener;
  }
  options.onUpdate = (progress) => {
    progressRef.value = progress.progress;
    const listener = listeners[ScrollEvent.onUpdate];
    listener();
  };
  const scrollTrigger = gsap_ScrollTrigger/* default.create */.Z.create(options);
  return scrollTrigger;
}
class createScrollListener extends functions_Base/* NamedFunction4 */.Vm {
  static type() {
    return "createScrollListener";
  }
  func(createOptions, listeners, evaluator, progressRef) {
    const scrollTrigger = _createScrollListener(createOptions, listeners, progressRef);
    evaluator.onDispose(() => {
      scrollTrigger.kill();
    });
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/functions/_VectorCross.ts


class crossVector2 extends functions_Base/* NamedFunction2 */.CE {
  static type() {
    return "crossVector2";
  }
  func(v1, v2) {
    return v1.cross(v2);
  }
}
class crossVector3 extends functions_Base/* NamedFunction3 */.Dv {
  static type() {
    return "crossVector3";
  }
  func(v1, v2, target) {
    return target.copy(v1).cross(v2);
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/functions/_Deform.ts




const _Deform_offset = new three_module.Vector3(0, 0, 0);
const options = {
  offset: _Deform_offset,
  moveObjectPosition: false
};
class cubeLatticeDeform extends functions_Base/* ObjectNamedFunction1 */.c_ {
  static type() {
    return "cubeLatticeDeform";
  }
  func(object3D, points) {
    const geometry = object3D.geometry;
    if (!geometry) {
      return;
    }
    CubeLatticeDeform_cubeLatticeDeform(object3D, points, options);
  }
}

// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/core/render/renderPixel/RenderPixelController.ts + 3 modules
var RenderPixelController = __webpack_require__(72151);
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/functions/_Render.ts



class cursorToUv extends functions_Base/* NamedFunction2 */.CE {
  static type() {
    return "cursorToUv";
  }
  func(cursor, target) {
    (0,RenderPixelController/* coreCursorToUv */.F)(cursor, target);
    return target;
  }
}
class renderPixel extends functions_Base/* ObjectNamedFunction5 */.o$ {
  constructor() {
    super(...arguments);
    this._renderPixelController = new RenderPixelController/* RenderPixelController */.b();
  }
  // Note for this to work on iOS:
  // The materials used for picking should have their transparency OFF.
  // This could potentially be done automatically by traversing the scene first.
  // private _renderTarget: WebGLRenderTarget = new WebGLRenderTarget(1, 1, {
  // 	minFilter: LinearFilter,
  // 	magFilter: NearestFilter,
  // 	format: RGBAFormat,
  // 	type: FloatType,
  // });
  // private _renderScene = new Scene();
  // private _restoreContext: RestoreContext = {
  // 	object: {
  // 		parent: null,
  // 	},
  // 	// scene: {
  // 	// 	overrideMaterial: null,
  // 	// },
  // 	renderer: {
  // 		toneMapping: NoToneMapping,
  // 		outputColorSpace: NoColorSpace,
  // 	},
  // };
  // private _read = new Float32Array(4);
  // private _getDefaultCamera: getDefaultCamera | undefined;
  static type() {
    return "renderPixel";
  }
  func(object3D, material, camera, backgroundColor, uv, target) {
    this._renderPixelController.renderColor(this.scene, object3D, material, camera, backgroundColor, uv, target);
    return target;
  }
  // private _prepare(object3D: Object3D, material: Material | null, backgroundColor: Color, renderer: WebGLRenderer) {
  // 	// save context
  // 	this._restoreContext.renderer.outputColorSpace = renderer.outputColorSpace;
  // 	this._restoreContext.renderer.toneMapping = renderer.toneMapping;
  // 	this._restoreContext.object.parent = object3D.parent;
  // 	// set context
  // 	this._renderScene.background = backgroundColor;
  // 	this._renderScene.overrideMaterial = material || null;
  // 	this._renderScene.attach(object3D);
  // 	renderer.toneMapping = NoToneMapping;
  // 	renderer.outputColorSpace = NoColorSpace;
  // }
  // private _render(uv: Vector2, camera: Camera, renderer: WebGLRenderer, target: Vector4) {
  // 	(camera as any).setViewOffset(
  // 		renderer.domElement.width,
  // 		renderer.domElement.height,
  // 		uv.x * renderer.domElement.width,
  // 		uv.y * renderer.domElement.height,
  // 		1,
  // 		1
  // 	);
  // 	renderer.setRenderTarget(this._renderTarget);
  // 	renderer.clear();
  // 	renderer.render(this._renderScene, camera);
  // 	renderer.setRenderTarget(null);
  // 	(camera as any).clearViewOffset();
  // 	// There are some cases where .readRenderTargetPixels is slow,
  // 	// and this seems to be due to the calls to _gl.getParameters.
  // 	// Here we are bypassing it.
  // 	// Note: this attempt to bypass needs "properties", which is internal to WebGLRenderer.
  // 	// const context = renderer.getContext();
  // 	// const textureFormat = context.RGBA; // RGBAFormat see three/WebGLUtils.js
  // 	// const textureType = context.FLOAT; // FloatType see three/WebGLUtils.js
  // 	// context.readPixels(0, 0, 1, 1, textureFormat, textureType, this._read);
  // 	renderer.readRenderTargetPixels(this._renderTarget, 0, 0, 1, 1, this._read);
  // 	// read buffer into target vector
  // 	target.fromArray(this._read);
  // }
  // private _restore(object3D: Object3D, renderer: WebGLRenderer) {
  // 	renderer.outputColorSpace = this._restoreContext.renderer.outputColorSpace;
  // 	renderer.toneMapping = this._restoreContext.renderer.toneMapping;
  // 	this._restoreContext.object.parent?.attach(object3D);
  // }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/functions/_Debug.ts





const _Debug_options = {
  object3D: new three_module.Object3D(),
  nodePath: "",
  message: "",
  value: 0
};
const _debugDataController = {
  lastProcessedFrameByNodePath: /* @__PURE__ */ new Map(),
  debugContentByFrameByNodePath: (0,reactivity_esm_bundler/* ref */.iH)({})
  // arrayByNodePath: new Map(),
};
function _displayableValue(value) {
  try {
    if ((0,Type/* isBoolean */.jn)(value) || (0,Type/* isString */.HD)(value)) {
      return `${value}`;
    }
    if ((0,Type/* isNumber */.hj)(value)) {
      return `${value.toFixed(6)}`;
    }
    if ((0,Type/* isColor */.D5)(value)) {
      return value.toArray().map((e) => e.toFixed(4)).join(", ");
    }
    if ((0,Type/* isVector */.NR)(value) || (0,Type/* isQuaternion */.Aw)(value)) {
      return value.toArray().map((e) => e.toFixed(4)).join(", ");
    }
    if ((0,Type/* isArray */.kJ)(value)) {
      const firstElement = value[0];
      const firstElementAsString = _displayableValue(firstElement);
      return `[${firstElementAsString},...] (length: ${value.length})`;
    }
    return "value not displayabled, see dev console";
  } catch (err) {
    console.warn("error trying to display value:", value);
    return "";
  }
}
function tableContent(debugLines) {
  const entries = debugLines.map((debugLine, i) => {
    return {
      objectName: debugLine.objectName,
      value: (0,Type/* isVector */.NR)(debugLine.value) || (0,Type/* isColor */.D5)(debugLine.value) ? debugLine.value.toArray() : debugLine.value
    };
  });
  return entries;
}
function logBlue(message) {
  console.log("%c" + message, "color:blue; font-weight:bold;");
}
function _flushDebugNode(nodePath, debugLines) {
  logBlue("------------");
  console.log(`${nodePath}:`);
  console.table(tableContent(debugLines));
  logBlue("------------");
}
function optionsToDebugLines(scene, options2, debugDataController) {
  const { object3D, nodePath, value } = options2;
  const displayableValue = _displayableValue(value);
  const objectName = object3D.name || "no name";
  const currentFrame = scene.frame();
  let currentValue = debugDataController.debugContentByFrameByNodePath.value[nodePath];
  if (!currentValue) {
    currentValue = [];
    debugDataController.debugContentByFrameByNodePath.value[nodePath] = currentValue;
  }
  currentValue.push({
    objectName,
    value,
    displayableValue
  });
  const lastProcessedFrame = debugDataController.lastProcessedFrameByNodePath.get(nodePath) || -1;
  if (!lastProcessedFrame) {
    debugDataController.lastProcessedFrameByNodePath.set(nodePath, lastProcessedFrame);
  }
  if (currentFrame != lastProcessedFrame) {
    _flushDebugNode(nodePath, currentValue);
    if (scene.dispatchController.emitAllowed()) {
      scene.dispatchController.actorEvaluatorDebug({ nodePath, debugLines: currentValue });
    }
    currentValue.length = 0;
    debugDataController.lastProcessedFrameByNodePath.set(nodePath, currentFrame);
  }
  return currentValue;
}
function _optionsToDebugLines(scene, options2) {
  return optionsToDebugLines(scene, options2, _debugDataController);
}
class debug extends functions_Base/* ObjectNamedFunction3 */.uW {
  static type() {
    return "debug";
  }
  func(object3D, nodePath, input, debugOptions) {
    const messageElements = [];
    if (debugOptions.displayFrame) {
      messageElements.push(`${this.scene.frame()}`);
    }
    if (debugOptions.displayTime) {
      messageElements.push(`${this.scene.time()}`);
    }
    if (debugOptions.message) {
      messageElements.push(debugOptions.message);
    }
    if (debugOptions.displayNodePath) {
      messageElements.push(nodePath);
    }
    const message = messageElements.join(" ");
    if (debugOptions.bundleByObject) {
      _Debug_options.object3D = object3D;
      _Debug_options.nodePath = nodePath;
      _Debug_options.message = message;
      _Debug_options.value = input;
      _optionsToDebugLines(this.scene, _Debug_options);
    } else {
      if (debugOptions.displayValue) {
        messageElements.push(input);
      }
      console.log(...messageElements);
    }
    return input;
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/functions/_CameraControlsDeviceOrientation.ts




class DeviceOrientationControlsHandler {
  // private previousMagicWindowYaw: number | undefined;
  constructor(scene) {
    this.scene = scene;
    // private _dummyObject = new Object3D();
    this._lastUpdatedFrame = -1;
  }
  update() {
    const currentFrame = this.scene.frame();
    if (currentFrame == this._lastUpdatedFrame) {
      return;
    }
    this._controls = this._controls || new DeviceOrientationControls();
    if (this._controls.enabled) {
      this._controls.update();
    }
    this._lastUpdatedFrame = currentFrame;
  }
  quaternion(target) {
    this.update();
    if (!this._controls) {
      console.warn("no controls");
      return;
    }
    this._controls.quaternion(target);
  }
  setSmoothAmount(smoothAmount) {
    var _a;
    (_a = this._controls) == null ? void 0 : _a.setSmoothAmount(smoothAmount);
  }
  // from aframe look-controls .updateMagicWindowOrientation()
  // protected _compensate() {
  // magicWindowAbsoluteEuler.setFromQuaternion(this._dummyObject.quaternion, ROTATION_ORDER);
  // if (!this.previousMagicWindowYaw && magicWindowAbsoluteEuler.y !== 0) {
  // 	this.previousMagicWindowYaw = magicWindowAbsoluteEuler.y;
  // }
  // if (this.previousMagicWindowYaw) {
  // 	magicWindowDeltaEuler.x = magicWindowAbsoluteEuler.x;
  // 	magicWindowDeltaEuler.y += magicWindowAbsoluteEuler.y - this.previousMagicWindowYaw;
  // 	magicWindowDeltaEuler.z = magicWindowAbsoluteEuler.z;
  // 	this.previousMagicWindowYaw = magicWindowAbsoluteEuler.y;
  // }
  // }
}
let _handler;
class deviceOrientation extends functions_Base/* NamedFunction2 */.CE {
  static type() {
    return "deviceOrientation";
  }
  func(target, smoothAmount) {
    (0,CoreReactivity/* dummyReadRefVal */.Jb)(this.timeController.timeUniform().value);
    _handler = _handler || new DeviceOrientationControlsHandler(this.scene);
    _handler.setSmoothAmount(smoothAmount);
    _handler.quaternion(target);
    return target;
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/functions/_VectorDistance.ts


class distanceVector2 extends functions_Base/* NamedFunction2 */.CE {
  static type() {
    return "distanceVector2";
  }
  func(v1, v2) {
    return v1.distanceTo(v2);
  }
}
class distanceVector3 extends functions_Base/* NamedFunction2 */.CE {
  static type() {
    return "distanceVector3";
  }
  func(v1, v2) {
    return v1.distanceTo(v2);
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/functions/_Divide.ts


class divideNumber extends functions_Base/* NamedFunction */.x9 {
  static type() {
    return "divideNumber";
  }
  func(...args) {
    let first = args[0];
    for (let i = 1; i < args.length; i++) {
      first /= args[i];
    }
    return first;
  }
}
class divideVectorNumber extends functions_Base/* NamedFunction2 */.CE {
  static type() {
    return "divideVectorNumber";
  }
  func(vector, number) {
    return vector.divideScalar(number);
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/functions/_VectorDot.ts


class dotVector2 extends functions_Base/* NamedFunction2 */.CE {
  static type() {
    return "dotVector2";
  }
  func(v1, v2) {
    return v1.dot(v2);
  }
}
class dotVector3 extends functions_Base/* NamedFunction2 */.CE {
  static type() {
    return "dotVector3";
  }
  func(v1, v2) {
    return v1.dot(v2);
  }
}

// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/core/math/Easing.ts
var math_Easing = __webpack_require__(71971);
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/functions/_Easing.ts



class easeI2 extends functions_Base/* NamedFunction1 */.TV {
  constructor() {
    super(...arguments);
    this.func = math_Easing/* Easing.easeI2 */.oY.easeI2;
  }
  static type() {
    return "easeI2";
  }
}
class easeO2 extends functions_Base/* NamedFunction1 */.TV {
  constructor() {
    super(...arguments);
    this.func = math_Easing/* Easing.easeO2 */.oY.easeO2;
  }
  static type() {
    return "easeO2";
  }
}
class easeIO2 extends functions_Base/* NamedFunction1 */.TV {
  constructor() {
    super(...arguments);
    this.func = math_Easing/* Easing.easeIO2 */.oY.easeIO2;
  }
  static type() {
    return "easeIO2";
  }
}
class easeI3 extends functions_Base/* NamedFunction1 */.TV {
  constructor() {
    super(...arguments);
    this.func = math_Easing/* Easing.easeI3 */.oY.easeI3;
  }
  static type() {
    return "easeI3";
  }
}
class easeO3 extends functions_Base/* NamedFunction1 */.TV {
  constructor() {
    super(...arguments);
    this.func = math_Easing/* Easing.easeO3 */.oY.easeO3;
  }
  static type() {
    return "easeO3";
  }
}
class easeIO3 extends functions_Base/* NamedFunction1 */.TV {
  constructor() {
    super(...arguments);
    this.func = math_Easing/* Easing.easeIO3 */.oY.easeIO3;
  }
  static type() {
    return "easeIO3";
  }
}
class easeI4 extends functions_Base/* NamedFunction1 */.TV {
  constructor() {
    super(...arguments);
    this.func = math_Easing/* Easing.easeI4 */.oY.easeI4;
  }
  static type() {
    return "easeI4";
  }
}
class easeO4 extends functions_Base/* NamedFunction1 */.TV {
  constructor() {
    super(...arguments);
    this.func = math_Easing/* Easing.easeO4 */.oY.easeO4;
  }
  static type() {
    return "easeO4";
  }
}
class easeIO4 extends functions_Base/* NamedFunction1 */.TV {
  constructor() {
    super(...arguments);
    this.func = math_Easing/* Easing.easeIO4 */.oY.easeIO4;
  }
  static type() {
    return "easeIO4";
  }
}
class easeSinI extends functions_Base/* NamedFunction1 */.TV {
  constructor() {
    super(...arguments);
    this.func = math_Easing/* Easing.easeSinI */.oY.easeSinI;
  }
  static type() {
    return "easeSinI";
  }
}
class easeSinO extends functions_Base/* NamedFunction1 */.TV {
  constructor() {
    super(...arguments);
    this.func = math_Easing/* Easing.easeSinO */.oY.easeSinO;
  }
  static type() {
    return "easeSinO";
  }
}
class easeSinIO extends functions_Base/* NamedFunction1 */.TV {
  constructor() {
    super(...arguments);
    this.func = math_Easing/* Easing.easeSinIO */.oY.easeSinIO;
  }
  static type() {
    return "easeSinIO";
  }
}
class easeElasticI extends functions_Base/* NamedFunction1 */.TV {
  constructor() {
    super(...arguments);
    this.func = math_Easing/* Easing.easeElasticI */.oY.easeElasticI;
  }
  static type() {
    return "easeElasticI";
  }
}
class easeElasticO extends functions_Base/* NamedFunction1 */.TV {
  constructor() {
    super(...arguments);
    this.func = math_Easing/* Easing.easeElasticO */.oY.easeElasticO;
  }
  static type() {
    return "easeElasticO";
  }
}
class easeElasticIO extends functions_Base/* NamedFunction1 */.TV {
  constructor() {
    super(...arguments);
    this.func = math_Easing/* Easing.easeElasticIO */.oY.easeElasticIO;
  }
  static type() {
    return "easeElasticIO";
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/functions/_Euler.ts



class eulerSetFromVector3 extends functions_Base/* NamedFunction3 */.Dv {
  static type() {
    return "eulerSetFromVector3";
  }
  func(values, orderIndex, target) {
    const order = typeof orderIndex == "number" ? Transform/* ROTATION_ORDERS */.Is[orderIndex] : orderIndex;
    target.setFromVector3(values);
    target.order = order;
    return target;
  }
}
class eulerSetFromQuaternion extends functions_Base/* NamedFunction2 */.CE {
  static type() {
    return "eulerSetFromQuaternion";
  }
  func(values, target) {
    target.setFromQuaternion(values);
    return target;
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/functions/_Geolocation.ts



const coordinates = (0,reactivity_esm_bundler/* ref */.iH)({ lng: 0, lat: 0 });
function getCurrentPositionHandler(position) {
  const { latitude, longitude } = position.coords;
  coordinates.value.lat = latitude;
  coordinates.value.lng = longitude;
}
class geolocationCurrentPositionRef extends functions_Base/* NamedFunction0 */.Fp {
  static type() {
    return "geolocationCurrentPositionRef";
  }
  func() {
    return coordinates;
  }
}
class geolocationLatitude extends functions_Base/* NamedFunction0 */.Fp {
  static type() {
    return "geolocationLatitude";
  }
  func() {
    return coordinates.value.lat;
  }
}
class geolocationLongitude extends functions_Base/* NamedFunction0 */.Fp {
  static type() {
    return "geolocationLongitude";
  }
  func() {
    return coordinates.value.lng;
  }
}
class geolocationGetCurrentPosition extends functions_Base/* NamedFunction0 */.Fp {
  static type() {
    return "geolocationGetCurrentPosition";
  }
  func() {
    navigator.geolocation.getCurrentPosition(getCurrentPositionHandler);
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/functions/_GetActorNodeParamValue.ts




class getActorNodeParamValue extends functions_Base/* NamedFunction1 */.TV {
  static type() {
    return "getActorNodeParamValue";
  }
  func(paramName) {
    const functionNode = this.functionNode;
    if (!functionNode) {
      return;
    }
    const _ref = (0,ParamReactivity/* getOrCreateParamRef */.Gt)(functionNode, paramName);
    (0,CoreReactivity/* dummyReadRefVal */.Jb)(_ref.value);
    return functionNode.params.get(paramName).value;
  }
}

// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/core/reactivity/ObjectAttributeReactivity.ts
var ObjectAttributeReactivity = __webpack_require__(52707);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/core/reactivity/ObjectAttributeReactivityCreateRef.ts
var ObjectAttributeReactivityCreateRef = __webpack_require__(29864);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/core/reactivity/ObjectHierarchyReactivity.ts
var ObjectHierarchyReactivity = __webpack_require__(84729);
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/functions/_GetChildrenAttributes.ts








class getChildrenAttributes extends functions_Base/* ObjectNamedFunction3 */.uW {
  static type() {
    return "getChildrenAttributes";
  }
  func(object3D, attribName, type, values) {
    dummyReadRefVal((0,ObjectHierarchyReactivity/* getObjectChildrenCountRef */.Y)(object3D).value);
    (0,_ArrayUtils/* _matchArrayLengthWithType */.Ew)(object3D.children, values, type);
    let i = 0;
    const children = object3D.children;
    for (let child of children) {
      const _refs = (0,ObjectAttributeReactivityCreateRef/* getOrCreateObjectAttributeRef */.U)(child, attribName, type);
      const value = ThreejsCoreObject/* ThreejsCoreObject.attribValue */.W.attribValue(child, attribName) || _refs.current.value;
      (0,ObjectAttributeReactivity/* _dummyReadAttributeRefVal */.hA)(_refs.current.value);
      values[i] = value;
      i++;
    }
    return values;
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/functions/_GetChildrenAttributesPrevious.ts






class getChildrenAttributesPrevious extends functions_Base/* ObjectNamedFunction3 */.uW {
  static type() {
    return "getChildrenAttributesPrevious";
  }
  func(object3D, attribName, type, values) {
    dummyReadRefVal((0,ObjectHierarchyReactivity/* getObjectChildrenCountRef */.Y)(object3D).value);
    (0,_ArrayUtils/* _matchArrayLengthWithType */.Ew)(object3D.children, values, type);
    let i = 0;
    const children = object3D.children;
    for (let child of children) {
      const _refs = (0,ObjectAttributeReactivityCreateRef/* getOrCreateObjectAttributeRef */.U)(child, attribName, type);
      values[i] = _refs.previous.value;
      i++;
    }
    return values;
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/functions/_GetChildrenAttributesRef.ts






class getChildrenAttributesRef extends functions_Base/* ObjectNamedFunction3 */.uW {
  static type() {
    return "getChildrenAttributesRef";
  }
  func(object3D, attribName, type, values) {
    dummyReadRefVal((0,ObjectHierarchyReactivity/* getObjectChildrenCountRef */.Y)(object3D).value);
    (0,_ArrayUtils/* _matchArrayLengthWithType */.Ew)(object3D.children, values, type);
    let i = 0;
    const children = object3D.children;
    for (let child of children) {
      const _refs = (0,ObjectAttributeReactivityCreateRef/* getOrCreateObjectAttributeRef */.U)(child, attribName, type);
      values[i] = _refs.current;
      i++;
    }
    return values;
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/functions/_GetObjectProperty.ts







class getObjectProperty extends functions_Base/* ObjectNamedFunction1 */.c_ {
  static type() {
    return "getObjectProperty";
  }
  func(object3D, propertyName) {
    (0,CoreReactivity/* dummyReadRefVal */.Jb)((0,ObjectPropertyReactivity/* getObjectPropertyRef */.lw)(object3D, propertyName).value);
    return object3D[propertyName];
  }
}
class getObjectWorldPosition extends functions_Base/* ObjectNamedFunction1 */.c_ {
  static type() {
    return "getObjectWorldPosition";
  }
  func(object3D, target) {
    (0,CoreReactivity/* dummyReadRefVal */.Jb)(this.timeController.timeUniform().value);
    object3D.getWorldPosition(target);
    return target;
  }
}
class object3DLocalToWorld extends functions_Base/* ObjectNamedFunction2 */.YS {
  static type() {
    return "object3DLocalToWorld";
  }
  func(object3D, position, target) {
    (0,CoreReactivity/* dummyReadRefVal */.Jb)(this.timeController.timeUniform().value);
    target.copy(position);
    object3D.localToWorld(target);
    return target;
  }
}
class object3DWorldToLocal extends functions_Base/* ObjectNamedFunction2 */.YS {
  static type() {
    return "object3DWorldToLocal";
  }
  func(object3D, position, target) {
    (0,CoreReactivity/* dummyReadRefVal */.Jb)(this.timeController.timeUniform().value);
    target.copy(position);
    object3D.worldToLocal(target);
    return target;
  }
}
function _getChildrenPropertiesVector3(propertyName) {
  return function(object3D, targets) {
    (0,CoreReactivity/* dummyReadRefVal */.Jb)((0,ObjectHierarchyReactivity/* getObjectChildrenCountRef */.Y)(object3D).value);
    (0,_ArrayUtils/* _matchArrayLength */.X9)(object3D.children, targets, () => new three_module.Vector3());
    let i = 0;
    const children = object3D.children;
    for (let child of children) {
      (0,CoreReactivity/* dummyReadRefVal */.Jb)((0,ObjectPropertyReactivity/* getObjectPropertyRef */.lw)(child, propertyName).value);
      targets[i].copy(child[propertyName]);
      i++;
    }
    return targets;
  };
}
function _getChildrenPropertiesQuaternion(propertyName) {
  return function(object3D, targets) {
    (0,CoreReactivity/* dummyReadRefVal */.Jb)((0,ObjectHierarchyReactivity/* getObjectChildrenCountRef */.Y)(object3D).value);
    (0,_ArrayUtils/* _matchArrayLength */.X9)(object3D.children, targets, () => new three_module.Quaternion());
    let i = 0;
    const children = object3D.children;
    for (let child of children) {
      (0,CoreReactivity/* dummyReadRefVal */.Jb)((0,ObjectPropertyReactivity/* getObjectPropertyRef */.lw)(child, propertyName).value);
      targets[i].copy(child[propertyName]);
      i++;
    }
    return targets;
  };
}
function _getChildrenPropertiesBoolean(propertyName) {
  return function(object3D, targets) {
    (0,CoreReactivity/* dummyReadRefVal */.Jb)((0,ObjectHierarchyReactivity/* getObjectChildrenCountRef */.Y)(object3D).value);
    (0,_ArrayUtils/* _matchArrayLength */.X9)(object3D.children, targets, () => false);
    let i = 0;
    const children = object3D.children;
    for (let child of children) {
      (0,CoreReactivity/* dummyReadRefVal */.Jb)((0,ObjectPropertyReactivity/* getObjectPropertyRef */.lw)(child, propertyName).value);
      targets[i] = child[propertyName];
      i++;
    }
    return targets;
  };
}
class getChildrenPropertiesPosition extends functions_Base/* ObjectNamedFunction1 */.c_ {
  constructor() {
    super(...arguments);
    this.func = _getChildrenPropertiesVector3("position");
  }
  static type() {
    return "getChildrenPropertiesPosition";
  }
}
class getChildrenPropertiesQuaternion extends functions_Base/* ObjectNamedFunction1 */.c_ {
  constructor() {
    super(...arguments);
    this.func = _getChildrenPropertiesQuaternion("quaternion");
  }
  static type() {
    return "getChildrenPropertiesQuaternion";
  }
}
class getChildrenPropertiesScale extends functions_Base/* ObjectNamedFunction1 */.c_ {
  constructor() {
    super(...arguments);
    this.func = _getChildrenPropertiesVector3("scale");
  }
  static type() {
    return "getChildrenPropertiesScale";
  }
}
class getChildrenPropertiesUp extends functions_Base/* ObjectNamedFunction1 */.c_ {
  constructor() {
    super(...arguments);
    this.func = _getChildrenPropertiesVector3("up");
  }
  static type() {
    return "getChildrenPropertiesUp";
  }
}
class getChildrenPropertiesVisible extends functions_Base/* ObjectNamedFunction1 */.c_ {
  constructor() {
    super(...arguments);
    this.func = _getChildrenPropertiesBoolean("visible");
  }
  static type() {
    return "getChildrenPropertiesVisible";
  }
}
class getChildrenPropertiesMatrixAutoUpdate extends functions_Base/* ObjectNamedFunction1 */.c_ {
  constructor() {
    super(...arguments);
    this.func = _getChildrenPropertiesBoolean("matrixAutoUpdate");
  }
  static type() {
    return "getChildrenPropertiesMatrixAutoUpdate";
  }
}
class getChildrenPropertiesCastShadow extends functions_Base/* ObjectNamedFunction1 */.c_ {
  constructor() {
    super(...arguments);
    this.func = _getChildrenPropertiesBoolean("castShadow");
  }
  static type() {
    return "getChildrenPropertiesCastShadow";
  }
}
class getChildrenPropertiesReceiveShadow extends functions_Base/* ObjectNamedFunction1 */.c_ {
  constructor() {
    super(...arguments);
    this.func = _getChildrenPropertiesBoolean("receiveShadow");
  }
  static type() {
    return "getChildrenPropertiesReceiveShadow";
  }
}
class getChildrenPropertiesFrustumCulled extends functions_Base/* ObjectNamedFunction1 */.c_ {
  constructor() {
    super(...arguments);
    this.func = _getChildrenPropertiesBoolean("frustumCulled");
  }
  static type() {
    return "getChildrenPropertiesFrustumCulled";
  }
}

// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/core/render/renderPixel/CoreGetDefautCamera.ts
var CoreGetDefautCamera = __webpack_require__(27654);
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/functions/_Camera.ts






class setPerspectiveCameraFov extends functions_Base/* ObjectNamedFunction3 */.uW {
  static type() {
    return "setPerspectiveCameraFov";
  }
  func(object3D, fov, lerp, updateProjectionMatrix) {
    if (!(object3D instanceof three_module.PerspectiveCamera)) {
      return;
    }
    const perspectiveCamera = object3D;
    const newFov = lerp * fov + (1 - lerp) * perspectiveCamera.fov;
    perspectiveCamera.fov = newFov;
    if ((0,Type/* isBooleanTrue */.bI)(updateProjectionMatrix)) {
      perspectiveCamera.updateProjectionMatrix();
    }
  }
}
class setPerspectiveCameraNearFar extends functions_Base/* ObjectNamedFunction4 */.eG {
  static type() {
    return "setPerspectiveCameraNearFar";
  }
  func(object3D, near, far, lerp, updateProjectionMatrix) {
    if (!(object3D instanceof three_module.PerspectiveCamera)) {
      return;
    }
    const perspectiveCamera = object3D;
    const newNear = lerp * near + (1 - lerp) * perspectiveCamera.near;
    const newFar = lerp * far + (1 - lerp) * perspectiveCamera.far;
    perspectiveCamera.near = newNear;
    perspectiveCamera.far = newFar;
    if ((0,Type/* isBooleanTrue */.bI)(updateProjectionMatrix)) {
      perspectiveCamera.updateProjectionMatrix();
    }
  }
}
class getDefaultCamera extends functions_Base/* NamedFunction0 */.Fp {
  static type() {
    return "getDefaultCamera";
  }
  func() {
    (0,CoreReactivity/* dummyReadRefVal */.Jb)(this.timeController.timeUniform().value);
    return (0,CoreGetDefautCamera/* coreGetDefaultCamera */.h)(this.scene);
  }
}
class setCameraViewOffset extends functions_Base/* ObjectNamedFunction2 */.YS {
  static type() {
    return "setCameraViewOffset";
  }
  func(object3D, min, max) {
    if (!(object3D instanceof three_module.PerspectiveCamera || object3D instanceof three_module.OrthographicCamera)) {
      return;
    }
    const viewer = this.scene.viewersRegister.lastRenderedViewer();
    if (!viewer) {
      return;
    }
    const camera = object3D;
    const size = viewer.camerasController().size;
    camera.setViewOffset(size.x, size.y, size.x * min.x, size.y * min.y, size.x * max.x, size.y * max.y);
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/functions/_Geometry.ts







const _Geometry_tmpV3 = new three_module.Vector3();
const nextV3 = new three_module.Vector3();
const STRIDE = 3;
class getGeometryPositions extends functions_Base/* ObjectNamedFunction1 */.c_ {
  static type() {
    return "getGeometryPositions";
  }
  func(object3D, target) {
    const geometry = object3D.geometry;
    if (!geometry) {
      return target;
    }
    const positionAttribute = geometry.getAttribute(geometry_Attribute/* Attribute.POSITION */.ah.POSITION);
    if (!positionAttribute) {
      return target;
    }
    const positionArray = positionAttribute.array;
    const pointsCount = positionArray.length / STRIDE;
    (0,_ArrayUtils/* _setArrayLength */.JP)(target, pointsCount, () => new three_module.Vector3());
    for (let i = 0; i < pointsCount; i++) {
      const _v = target[i];
      const i3 = i * STRIDE;
      _v.x = positionArray[i3];
      _v.y = positionArray[i3 + 1];
      _v.z = positionArray[i3 + 2];
    }
    return target;
  }
}
class getGeometryBoundingBox extends functions_Base/* ObjectNamedFunction2 */.YS {
  static type() {
    return "getGeometryBoundingBox";
  }
  func(object3D, forceCompute, target) {
    dummyReadRefVal(this.timeController.timeUniform().value);
    const geometry = object3D.geometry;
    if (!geometry) {
      return target;
    }
    if (!geometry.boundingBox || forceCompute) {
      geometry.computeBoundingBox();
    }
    if (!geometry.boundingBox) {
      return target;
    }
    target.copy(geometry.boundingBox);
    return target;
  }
}
class setGeometryPositions extends functions_Base/* ObjectNamedFunction5 */.o$ {
  static type() {
    return "setGeometryPositions";
  }
  func(object3D, values, lerp, attributeNeedsUpdate, computeNormals, computeTangents) {
    const geometry = object3D.geometry;
    if (!geometry) {
      return;
    }
    if (!values) {
      return;
    }
    const positionAttribute = geometry.getAttribute(geometry_Attribute/* Attribute.POSITION */.ah.POSITION);
    if (!positionAttribute) {
      return;
    }
    const doLerp = lerp < 1;
    const positionArray = positionAttribute.array;
    const geoPointsCount = positionArray.length / STRIDE;
    const valuesCount = values.length;
    const minCount = Math.min(geoPointsCount, valuesCount);
    if (doLerp) {
      for (let i = 0; i < minCount; i++) {
        const value = values[i];
        const j = i * STRIDE;
        nextV3.copy(value);
        _Geometry_tmpV3.fromArray(positionArray, j);
        _Geometry_tmpV3.lerp(nextV3, lerp);
        _Geometry_tmpV3.toArray(positionArray, j);
      }
    } else {
      for (let i = 0; i < minCount; i++) {
        const value = values[i];
        const j = i * STRIDE;
        value.toArray(positionArray, j);
      }
    }
    if ((0,Type/* isBooleanTrue */.bI)(attributeNeedsUpdate)) {
      (0,geometry_Attribute/* markAttributeAsNeedsUpdateForFrame */.X3)(positionAttribute, this.timeController.frame());
    }
    if (positionAttribute != null && (0,Type/* isBooleanTrue */.bI)(computeNormals) && geometry.getAttribute(geometry_Attribute/* Attribute.NORMAL */.ah.NORMAL) != null) {
      geometry.computeVertexNormals();
    }
    if ((0,Type/* isBooleanTrue */.bI)(computeTangents) && positionAttribute != null && geometry.getAttribute(geometry_Attribute/* Attribute.UV */.ah.UV) != null && geometry.getAttribute(geometry_Attribute/* Attribute.NORMAL */.ah.NORMAL) != null && geometry.getIndex() != null) {
      geometry.computeTangents();
    }
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/functions/_GetIntersectionAttribute.ts




const positionA = new three_module.Vector3();
const positionB = new three_module.Vector3();
const positionC = new three_module.Vector3();
const _ca = new three_module.Color();
const _cb = new three_module.Color();
const _cc = new three_module.Color();
const _v2a = new three_module.Vector2();
const _v2b = new three_module.Vector2();
const _v2c = new three_module.Vector2();
const _v3a = new three_module.Vector3();
const _GetIntersectionAttribute_v3b = new three_module.Vector3();
const _v3c = new three_module.Vector3();
const _v4a = new three_module.Vector4();
const _v4b = new three_module.Vector4();
const _v4c = new three_module.Vector4();
const _GetIntersectionAttribute_v3 = new three_module.Vector3();
const _tmpColorA = new three_module.Color();
const _tmpColorB = new three_module.Color();
const _tmpColorC = new three_module.Color();
function triangleGetInterpolatedNumber(point, p1, p2, p3, va, vb, vc) {
  three_module.Triangle.getBarycoord(point, p1, p2, p3, _GetIntersectionAttribute_v3);
  return va * _GetIntersectionAttribute_v3.x + vb * _GetIntersectionAttribute_v3.y + vc * _GetIntersectionAttribute_v3.z;
}
function triangleGetInterpolatedColor(point, p1, p2, p3, va, vb, vc, target) {
  three_module.Triangle.getBarycoord(point, p1, p2, p3, _GetIntersectionAttribute_v3);
  target.r = 0;
  target.g = 0;
  target.b = 0;
  _tmpColorA.copy(va).multiplyScalar(_GetIntersectionAttribute_v3.x);
  _tmpColorB.copy(vb).multiplyScalar(_GetIntersectionAttribute_v3.y);
  _tmpColorC.copy(vc).multiplyScalar(_GetIntersectionAttribute_v3.z);
  target.add(_tmpColorA).add(_tmpColorB).add(_tmpColorC);
  return target;
}
function triangleGetInterpolatedVector2(point, p1, p2, p3, va, vb, vc, target) {
  three_module.Triangle.getBarycoord(point, p1, p2, p3, _GetIntersectionAttribute_v3);
  target.set(0, 0);
  target.addScaledVector(va, _GetIntersectionAttribute_v3.x);
  target.addScaledVector(vb, _GetIntersectionAttribute_v3.y);
  target.addScaledVector(vc, _GetIntersectionAttribute_v3.z);
  return target;
}
function triangleGetInterpolatedVector3(point, p1, p2, p3, va, vb, vc, target) {
  three_module.Triangle.getBarycoord(point, p1, p2, p3, _GetIntersectionAttribute_v3);
  target.set(0, 0, 0);
  target.addScaledVector(va, _GetIntersectionAttribute_v3.x);
  target.addScaledVector(vb, _GetIntersectionAttribute_v3.y);
  target.addScaledVector(vc, _GetIntersectionAttribute_v3.z);
  return target;
}
function triangleGetInterpolatedVector4(point, p1, p2, p3, va, vb, vc, target) {
  three_module.Triangle.getBarycoord(point, p1, p2, p3, _GetIntersectionAttribute_v3);
  target.set(0, 0, 0, 0);
  target.addScaledVector(va, _GetIntersectionAttribute_v3.x);
  target.addScaledVector(vb, _GetIntersectionAttribute_v3.y);
  target.addScaledVector(vc, _GetIntersectionAttribute_v3.z);
  return target;
}
function nearestFaceVertexIndex(intersection, positionAttribute, face) {
  const intersectionPos = intersection.point;
  positionA.fromBufferAttribute(positionAttribute, face.a);
  positionB.fromBufferAttribute(positionAttribute, face.b);
  positionC.fromBufferAttribute(positionAttribute, face.c);
  const distanceA = positionA.distanceTo(intersectionPos);
  const distanceB = positionB.distanceTo(intersectionPos);
  const distanceC = positionC.distanceTo(intersectionPos);
  if (distanceA < distanceB && distanceA < distanceC) {
    return face.a;
  }
  if (distanceB < distanceA && distanceB < distanceC) {
    return face.b;
  }
  return face.c;
}
function nonInterpolatedVertexIndex(intersection) {
  if (!intersection) {
    return;
  }
  const geometry = intersection.object.geometry;
  if (!geometry) {
    return;
  }
  const positionAttribute = geometry.getAttribute("position");
  if (!positionAttribute) {
    return;
  }
  const face = intersection.face;
  if (!face) {
    return;
  }
  return nearestFaceVertexIndex(intersection, positionAttribute, face);
}
class getIntersectionAttributeNumberNearest extends functions_Base/* NamedFunction3 */.Dv {
  static type() {
    return "getIntersectionAttributeNumberNearest";
  }
  func(intersection, attribName, notFoundValue) {
    if (!intersection) {
      return notFoundValue;
    }
    const vertexIndex = nonInterpolatedVertexIndex(intersection);
    if (vertexIndex == null) {
      return notFoundValue;
    }
    const geometry = intersection.object.geometry;
    if (!geometry) {
      return notFoundValue;
    }
    const attribute = geometry.getAttribute(attribName);
    if (!attribute) {
      return notFoundValue;
    }
    const value = attribute.array[vertexIndex];
    return value;
  }
}
class getIntersectionAttributeNumberInterpolated extends functions_Base/* NamedFunction3 */.Dv {
  static type() {
    return "getIntersectionAttributeNumberInterpolated";
  }
  func(intersection, attribName, notFoundValue) {
    if (!intersection) {
      return notFoundValue;
    }
    const face = intersection.face;
    if (!face) {
      return notFoundValue;
    }
    const geometry = intersection.object.geometry;
    if (!geometry) {
      return notFoundValue;
    }
    const vertexIndex = nonInterpolatedVertexIndex(intersection);
    if (vertexIndex == null) {
      return notFoundValue;
    }
    const attribute = geometry.getAttribute(attribName);
    if (!attribute) {
      return notFoundValue;
    }
    const positionAttribute = geometry.getAttribute("position");
    if (!positionAttribute) {
      return notFoundValue;
    }
    const intersectionPos = intersection.point;
    positionA.fromBufferAttribute(positionAttribute, face.a);
    positionB.fromBufferAttribute(positionAttribute, face.b);
    positionC.fromBufferAttribute(positionAttribute, face.c);
    const va = attribute.array[face.a];
    const vb = attribute.array[face.b];
    const vc = attribute.array[face.c];
    return triangleGetInterpolatedNumber(intersectionPos, positionA, positionB, positionC, va, vb, vc);
  }
}
class getIntersectionAttributeColorNearest extends functions_Base/* NamedFunction4 */.Vm {
  static type() {
    return "getIntersectionAttributeColorNearest";
  }
  func(intersection, attribName, notFoundValue, target) {
    if (!intersection) {
      return notFoundValue;
    }
    const vertexIndex = nonInterpolatedVertexIndex(intersection);
    if (vertexIndex == null) {
      return notFoundValue;
    }
    const geometry = intersection.object.geometry;
    if (!geometry) {
      return notFoundValue;
    }
    const attribute = geometry.getAttribute(attribName);
    if (!attribute) {
      return notFoundValue;
    }
    return target.fromBufferAttribute(attribute, vertexIndex);
  }
}
class getIntersectionAttributeColorInterpolated extends functions_Base/* NamedFunction4 */.Vm {
  static type() {
    return "getIntersectionAttributeColorInterpolated";
  }
  func(intersection, attribName, notFoundValue, target) {
    if (!intersection) {
      return notFoundValue;
    }
    const face = intersection.face;
    if (!face) {
      return notFoundValue;
    }
    const geometry = intersection.object.geometry;
    if (!geometry) {
      return notFoundValue;
    }
    const vertexIndex = nonInterpolatedVertexIndex(intersection);
    if (vertexIndex == null) {
      return notFoundValue;
    }
    const attribute = geometry.getAttribute(attribName);
    if (!attribute) {
      return notFoundValue;
    }
    const positionAttribute = geometry.getAttribute("position");
    if (!positionAttribute) {
      return notFoundValue;
    }
    const intersectionPos = intersection.point;
    positionA.fromBufferAttribute(positionAttribute, face.a);
    positionB.fromBufferAttribute(positionAttribute, face.b);
    positionC.fromBufferAttribute(positionAttribute, face.c);
    _ca.fromBufferAttribute(attribute, face.a);
    _cb.fromBufferAttribute(attribute, face.b);
    _cc.fromBufferAttribute(attribute, face.c);
    return triangleGetInterpolatedColor(intersectionPos, positionA, positionB, positionC, _ca, _cb, _cc, target);
  }
}
const notFoundValueStr = "";
class getIntersectionAttributeStringNearest extends functions_Base/* NamedFunction2 */.CE {
  static type() {
    return "getIntersectionAttributeStringNearest";
  }
  func(intersection, attribName) {
    if (!intersection) {
      return notFoundValueStr;
    }
    const vertexIndex = nonInterpolatedVertexIndex(intersection);
    if (vertexIndex == null) {
      return notFoundValueStr;
    }
    const geometry = intersection.object.geometry;
    if (!geometry) {
      return notFoundValueStr;
    }
    const corePointClass = (0,CoreObjectFactory/* corePointClassFactory */.E_)(intersection.object);
    const result = corePointClass.stringAttribValue(intersection.object, vertexIndex, attribName);
    if (result == null) {
      return notFoundValueStr;
    }
    return result;
  }
}
class getIntersectionAttributeVector2Nearest extends functions_Base/* NamedFunction4 */.Vm {
  static type() {
    return "getIntersectionAttributeVector2Nearest";
  }
  func(intersection, attribName, notFoundValue, target) {
    if (!intersection) {
      return notFoundValue;
    }
    const vertexIndex = nonInterpolatedVertexIndex(intersection);
    if (vertexIndex == null) {
      return notFoundValue;
    }
    const geometry = intersection.object.geometry;
    if (!geometry) {
      return notFoundValue;
    }
    const attribute = geometry.getAttribute(attribName);
    if (!attribute) {
      return notFoundValue;
    }
    return target.fromBufferAttribute(attribute, vertexIndex);
  }
}
class getIntersectionAttributeVector2Interpolated extends functions_Base/* NamedFunction4 */.Vm {
  static type() {
    return "getIntersectionAttributeVector2Interpolated";
  }
  func(intersection, attribName, notFoundValue, target) {
    if (!intersection) {
      return notFoundValue;
    }
    const face = intersection.face;
    if (!face) {
      return notFoundValue;
    }
    const geometry = intersection.object.geometry;
    if (!geometry) {
      return notFoundValue;
    }
    const vertexIndex = nonInterpolatedVertexIndex(intersection);
    if (vertexIndex == null) {
      return notFoundValue;
    }
    const attribute = geometry.getAttribute(attribName);
    if (!attribute) {
      return notFoundValue;
    }
    const positionAttribute = geometry.getAttribute("position");
    if (!positionAttribute) {
      return notFoundValue;
    }
    const intersectionPos = intersection.point;
    positionA.fromBufferAttribute(positionAttribute, face.a);
    positionB.fromBufferAttribute(positionAttribute, face.b);
    positionC.fromBufferAttribute(positionAttribute, face.c);
    _v2a.fromBufferAttribute(attribute, face.a);
    _v2b.fromBufferAttribute(attribute, face.b);
    _v2c.fromBufferAttribute(attribute, face.c);
    return triangleGetInterpolatedVector2(
      intersectionPos,
      positionA,
      positionB,
      positionC,
      _v2a,
      _v2b,
      _v2c,
      target
    );
  }
}
class getIntersectionAttributeVector3Nearest extends functions_Base/* NamedFunction4 */.Vm {
  static type() {
    return "getIntersectionAttributeVector3Nearest";
  }
  func(intersection, attribName, notFoundValue, target) {
    if (!intersection) {
      return notFoundValue;
    }
    const vertexIndex = nonInterpolatedVertexIndex(intersection);
    if (vertexIndex == null) {
      return notFoundValue;
    }
    const geometry = intersection.object.geometry;
    if (!geometry) {
      return notFoundValue;
    }
    const attribute = geometry.getAttribute(attribName);
    if (!attribute) {
      return notFoundValue;
    }
    return target.fromBufferAttribute(attribute, vertexIndex);
  }
}
class getIntersectionAttributeVector3Interpolated extends functions_Base/* NamedFunction4 */.Vm {
  static type() {
    return "getIntersectionAttributeVector3Interpolated";
  }
  func(intersection, attribName, notFoundValue, target) {
    if (!intersection) {
      return notFoundValue;
    }
    const face = intersection.face;
    if (!face) {
      return notFoundValue;
    }
    const geometry = intersection.object.geometry;
    if (!geometry) {
      return notFoundValue;
    }
    const vertexIndex = nonInterpolatedVertexIndex(intersection);
    if (vertexIndex == null) {
      return notFoundValue;
    }
    const attribute = geometry.getAttribute(attribName);
    if (!attribute) {
      return notFoundValue;
    }
    const positionAttribute = geometry.getAttribute("position");
    if (!positionAttribute) {
      return notFoundValue;
    }
    const intersectionPos = intersection.point;
    positionA.fromBufferAttribute(positionAttribute, face.a);
    positionB.fromBufferAttribute(positionAttribute, face.b);
    positionC.fromBufferAttribute(positionAttribute, face.c);
    _v3a.fromBufferAttribute(attribute, face.a);
    _GetIntersectionAttribute_v3b.fromBufferAttribute(attribute, face.b);
    _v3c.fromBufferAttribute(attribute, face.c);
    return triangleGetInterpolatedVector3(
      intersectionPos,
      positionA,
      positionB,
      positionC,
      _v3a,
      _GetIntersectionAttribute_v3b,
      _v3c,
      target
    );
  }
}
class getIntersectionAttributeVector4Nearest extends functions_Base/* NamedFunction4 */.Vm {
  static type() {
    return "getIntersectionAttributeVector4Nearest";
  }
  func(intersection, attribName, notFoundValue, target) {
    if (!intersection) {
      return notFoundValue;
    }
    const vertexIndex = nonInterpolatedVertexIndex(intersection);
    if (vertexIndex == null) {
      return notFoundValue;
    }
    const geometry = intersection.object.geometry;
    if (!geometry) {
      return notFoundValue;
    }
    const attribute = geometry.getAttribute(attribName);
    if (!attribute) {
      return notFoundValue;
    }
    return target.fromBufferAttribute(attribute, vertexIndex);
  }
}
class getIntersectionAttributeVector4Interpolated extends functions_Base/* NamedFunction4 */.Vm {
  static type() {
    return "getIntersectionAttributeVector4Interpolated";
  }
  func(intersection, attribName, notFoundValue, target) {
    if (!intersection) {
      return notFoundValue;
    }
    const face = intersection.face;
    if (!face) {
      return notFoundValue;
    }
    const geometry = intersection.object.geometry;
    if (!geometry) {
      return notFoundValue;
    }
    const vertexIndex = nonInterpolatedVertexIndex(intersection);
    if (vertexIndex == null) {
      return notFoundValue;
    }
    const attribute = geometry.getAttribute(attribName);
    if (!attribute) {
      return notFoundValue;
    }
    const positionAttribute = geometry.getAttribute("position");
    if (!positionAttribute) {
      return notFoundValue;
    }
    const intersectionPos = intersection.point;
    positionA.fromBufferAttribute(positionAttribute, face.a);
    positionB.fromBufferAttribute(positionAttribute, face.b);
    positionC.fromBufferAttribute(positionAttribute, face.c);
    _v4a.fromBufferAttribute(attribute, face.a);
    _v4b.fromBufferAttribute(attribute, face.b);
    _v4c.fromBufferAttribute(attribute, face.c);
    return triangleGetInterpolatedVector4(
      intersectionPos,
      positionA,
      positionB,
      positionC,
      _v4a,
      _v4b,
      _v4c,
      target
    );
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/functions/_GetIntersectionProperty.ts


class getIntersectionPropertyDistance extends functions_Base/* NamedFunction1 */.TV {
  static type() {
    return "getIntersectionPropertyDistance";
  }
  func(intersection) {
    return (intersection == null ? void 0 : intersection.distance) || 0;
  }
}
class getIntersectionPropertyFaceIndex extends functions_Base/* NamedFunction1 */.TV {
  static type() {
    return "getIntersectionPropertyFaceIndex";
  }
  func(intersection) {
    return (intersection == null ? void 0 : intersection.faceIndex) || -1;
  }
}
class getIntersectionPropertyObject extends functions_Base/* ObjectNamedFunction1 */.c_ {
  static type() {
    return "getIntersectionPropertyObject";
  }
  func(object3D, intersection) {
    return (intersection == null ? void 0 : intersection.object) || object3D;
  }
}
class getIntersectionPropertyPoint extends functions_Base/* NamedFunction2 */.CE {
  static type() {
    return "getIntersectionPropertyPoint";
  }
  func(intersection, target) {
    return intersection ? target.copy(intersection.point) : target.set(0, 0, 0);
  }
}
class getIntersectionPropertyNormal extends functions_Base/* NamedFunction2 */.CE {
  static type() {
    return "getIntersectionPropertyNormal";
  }
  func(intersection, target) {
    if (!intersection) {
      return target.set(0, 1, 0);
    }
    const face = intersection.face;
    if (face && face.normal) {
      target.copy(face.normal);
    } else {
      target.set(0, 1, 0);
    }
    return target;
  }
}
class getIntersectionPropertyUv extends functions_Base/* NamedFunction2 */.CE {
  static type() {
    return "getIntersectionPropertyUv";
  }
  func(intersection, target) {
    return (intersection == null ? void 0 : intersection.uv) ? target.copy(intersection.uv) : target.set(0, 0);
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/functions/_GetSceneObject.ts






class getTexture extends functions_Base/* NamedFunction1 */.TV {
  static type() {
    return "getTexture";
  }
  func(nodePath) {
    (0,CoreReactivity/* dummyReadRefVal */.Jb)((0,NodeReactivity/* getOrCreateNodeRef */.Dm)(nodePath).value);
    const node = this.scene.node(nodePath);
    if (node && node.context() == poly_NodeContext/* NodeContext.COP */.sy.COP) {
      if (Type/* CoreType.isFunction */.MR.isFunction(node.__textureSync__)) {
        if (node.isDirty()) {
          node.compute();
        }
        return node.__textureSync__();
      }
    }
  }
}
class getMaterial extends functions_Base/* NamedFunction1 */.TV {
  static type() {
    return "getMaterial";
  }
  func(nodePath) {
    (0,CoreReactivity/* dummyReadRefVal */.Jb)((0,NodeReactivity/* getOrCreateNodeRef */.Dm)(nodePath).value);
    const node = this.scene.node(nodePath);
    if (node && node.context() == poly_NodeContext/* NodeContext.MAT */.sy.MAT) {
      if (node && Type/* CoreType.isFunction */.MR.isFunction(node.__materialSync__)) {
        if (node.isDirty()) {
          node.compute();
        }
        return node.__materialSync__();
      }
    }
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/functions/_Node.ts


function _Node_dummyReadRefVal(value) {
}
function _getNode(scene, nodePath) {
  _Node_dummyReadRefVal(scene.graphNodesController.pathRef(nodePath).value);
  const node = scene.node(nodePath);
  if (!node) {
    return;
  }
  return node;
}
class getNode extends functions_Base/* NamedFunction1 */.TV {
  static type() {
    return "getNode";
  }
  func(nodePath) {
    return _getNode(this.scene, nodePath);
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/functions/_GetObject.ts


class getObject extends functions_Base/* ObjectNamedFunction2 */.YS {
  static type() {
    return "getObject";
  }
  func(object3D, getCurrentObject, mask) {
    if (getCurrentObject) {
      return object3D;
    } else {
      return this.scene.findObjectByMask(mask) || object3D;
    }
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/functions/_GetObjectAttribute.ts



class getObjectAttribute extends functions_Base/* ObjectNamedFunction3 */.uW {
  static type() {
    return "getObjectAttribute";
  }
  func(object3D, attribName, type, defaultValue) {
    const _ref = (0,ObjectAttributeReactivityCreateRef/* getOrCreateObjectAttributeRef */.U)(object3D, attribName, type, defaultValue);
    return _ref.current.value;
  }
}
class getObjectAttributeAutoDefault extends functions_Base/* ObjectNamedFunction2 */.YS {
  static type() {
    return "getObjectAttributeAutoDefault";
  }
  func(object3D, attribName, type) {
    const _ref = (0,ObjectAttributeReactivityCreateRef/* getOrCreateObjectAttributeRef */.U)(object3D, attribName, type);
    return _ref.current.value;
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/functions/_GetObjectAttributePrevious.ts



class getObjectAttributePrevious extends functions_Base/* ObjectNamedFunction2 */.YS {
  static type() {
    return "getObjectAttributePrevious";
  }
  func(object3D, attribName, type) {
    const _ref = (0,ObjectAttributeReactivityCreateRef/* getOrCreateObjectAttributeRef */.U)(object3D, attribName, type);
    return _ref.previous.value;
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/functions/_GetObjectAttributeRef.ts



class getObjectAttributeRef extends functions_Base/* ObjectNamedFunction2 */.YS {
  static type() {
    return "getObjectAttributeRef";
  }
  func(object3D, attribName, type) {
    const _ref = (0,ObjectAttributeReactivityCreateRef/* getOrCreateObjectAttributeRef */.U)(object3D, attribName, type);
    return _ref.current;
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/functions/_GetObjectChild.ts




class getObjectChild extends functions_Base/* ObjectNamedFunction1 */.c_ {
  static type() {
    return "getObjectChild";
  }
  func(object3D, index) {
    dummyReadRefVal((0,ObjectHierarchyReactivity/* getObjectChildrenCountRef */.Y)(object3D).value);
    return object3D.children[index] || object3D.children[0] || object3D;
  }
}

// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/core/geometry/Event.ts
var geometry_Event = __webpack_require__(54313);
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/functions/_ObjectDispatchEvent.ts




const _ObjectDispatchEvent_EVENT = { type: "" };
const lastEventByObject = /* @__PURE__ */ new Map();
function getOrCreateRef(object3D) {
  return getObjectRef(object3D) || _createObjectRef(object3D);
}
function getObjectRef(object3D) {
  return lastEventByObject.get(object3D);
}
function _createObjectRef(object3D) {
  let _ref = lastEventByObject.get(object3D);
  if (_ref) {
    return _ref;
  }
  _ref = (0,reactivity_esm_bundler/* ref */.iH)("");
  lastEventByObject.set(object3D, _ref);
  return _ref;
}
function setLastEventName(object3D, eventName) {
  getOrCreateRef(object3D).value = eventName;
}
function onObjectDispatchFunctionNameByEventName(eventName) {
  return `onObjectDispatchEvent_${eventName}`;
}
class objectDispatchEvent extends functions_Base/* ObjectNamedFunction1 */.c_ {
  static type() {
    return "objectDispatchEvent";
  }
  func(object3D, eventName) {
    _ObjectDispatchEvent_EVENT.type = eventName;
    object3D.dispatchEvent(_ObjectDispatchEvent_EVENT);
    setLastEventName(object3D, eventName);
  }
}
class getObjectLastDispatchedEventName extends functions_Base/* ObjectNamedFunction0 */.jY {
  static type() {
    return "getObjectLastDispatchedEventName";
  }
  func(object3D) {
    return getOrCreateRef(object3D).value;
  }
}
function addListeners(evaluator, object3D, eventNames, boundListener) {
  for (let eventName of eventNames) {
    if (boundListener) {
      object3D.addEventListener(eventName, boundListener);
    }
  }
  evaluator.onDispose(() => {
    for (let eventName of eventNames) {
      object3D.removeEventListener(eventName, boundListener);
    }
  });
}
class objectAddEventListeners extends functions_Base/* ObjectNamedFunction3 */.uW {
  static type() {
    return "objectAddEventListeners";
  }
  func(object3D, eventNamesList, evaluator, boundListener) {
    const eventNames = eventNamesList.split(" ");
    addListeners(evaluator, object3D, eventNames, boundListener);
    return getOrCreateRef(object3D).value;
  }
}
class objectAddOnBeforeDeleteEventListener extends functions_Base/* ObjectNamedFunction2 */.YS {
  static type() {
    return "objectAddOnBeforeDeleteEventListener";
  }
  func(object3D, evaluator, boundListener) {
    const eventNames = [geometry_Event/* ObjectEvent.BEFORE_DELETE */.m.BEFORE_DELETE];
    addListeners(evaluator, object3D, eventNames, boundListener);
    return getOrCreateRef(object3D).value;
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/core/reactivity/ObjectUserDataReactivity.ts


const refByObjectUuidByUserDataName = /* @__PURE__ */ new Map();
function getOrCreateUserDataRef(object3D, userDataName) {
  return getObjectUserDataRef(object3D, userDataName) || _createObjectUserDataRef(object3D, userDataName);
}
function getObjectUserDataRef(object3D, userDataName) {
  var _a;
  return (_a = refByObjectUuidByUserDataName.get(object3D.uuid)) == null ? void 0 : _a.get(userDataName);
}
function _createObjectUserDataRef(object3D, userDataName) {
  let mapForObject = refByObjectUuidByUserDataName.get(object3D.uuid);
  if (!mapForObject) {
    mapForObject = /* @__PURE__ */ new Map();
    refByObjectUuidByUserDataName.set(object3D.uuid, mapForObject);
  }
  let refForProperty = mapForObject.get(userDataName);
  if (!refForProperty) {
    refForProperty = (0,reactivity_esm_bundler/* ref */.iH)(0);
    mapForObject.set(userDataName, refForProperty);
  }
  return refForProperty;
}
function _dummyReadUserDataRefVal(value) {
}
function touchObjectUserData(object3D, userDataName) {
  const _ref = getObjectUserDataRef(object3D, userDataName);
  if (!_ref) {
    return;
  }
  incrementRefSafely(_ref);
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/functions/_GetObjectUserData.ts




class getObjectUserData extends functions_Base/* ObjectNamedFunction1 */.c_ {
  static type() {
    return "getObjectUserData";
  }
  func(object3D, userDataName) {
    (0,CoreReactivity/* dummyReadRefVal */.Jb)(getOrCreateUserDataRef(object3D, userDataName).value);
    return object3D.userData[userDataName];
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/functions/_GetParent.ts


class getParent extends functions_Base/* ObjectNamedFunction0 */.jY {
  static type() {
    return "getParent";
  }
  func(object3D) {
    return object3D.parent || object3D;
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/functions/_Plane.ts


class planeSet extends functions_Base/* NamedFunction3 */.Dv {
  static type() {
    return "planeSet";
  }
  func(normal, constant, target) {
    target.normal.copy(normal);
    target.constant = constant;
    return target;
  }
}
class getPlaneNormal extends functions_Base/* NamedFunction2 */.CE {
  static type() {
    return "getPlaneNormal";
  }
  func(plane, target) {
    return target.copy(plane.normal);
  }
}
class getPlaneConstant extends functions_Base/* NamedFunction1 */.TV {
  static type() {
    return "getPlaneConstant";
  }
  func(plane) {
    return plane.constant;
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/functions/_SetPlayerInput.ts



function _createInputData() {
  return {
    forward: (0,reactivity_esm_bundler/* ref */.iH)(false),
    backward: (0,reactivity_esm_bundler/* ref */.iH)(false),
    left: (0,reactivity_esm_bundler/* ref */.iH)(false),
    right: (0,reactivity_esm_bundler/* ref */.iH)(false),
    run: (0,reactivity_esm_bundler/* ref */.iH)(false),
    jump: (0,reactivity_esm_bundler/* ref */.iH)(false)
  };
}
class InputDataHandler {
  constructor() {
    this._playerInputData = _createInputData();
    this._callbackByEventType = {
      keydown: (code) => this._onKeydownCallback(code),
      keyup: (code) => this._onKeyupCallback(code)
    };
    this._onEvent = {
      start: {
        forward: this._onForwardStart.bind(this),
        backward: this._onBackwardStart.bind(this),
        left: this._onLeftStart.bind(this),
        right: this._onRightStart.bind(this),
        jump: this._onJumpStart.bind(this),
        run: this._onRunStart.bind(this)
      },
      end: {
        forward: this._onForwardEnd.bind(this),
        backward: this._onBackwardEnd.bind(this),
        left: this._onLeftEnd.bind(this),
        right: this._onRightEnd.bind(this),
        jump: this._onJumpEnd.bind(this),
        run: this._onRunEnd.bind(this)
      }
    };
    this._eventByArrowKeyOnKeydown = {
      ArrowUp: this._onEvent.start.forward,
      ArrowDown: this._onEvent.start.backward,
      ArrowLeft: this._onEvent.start.left,
      ArrowRight: this._onEvent.start.right
    };
    this._eventByWASNKeyOnKeydown = {
      KeyW: this._onEvent.start.forward,
      KeyS: this._onEvent.start.backward,
      KeyA: this._onEvent.start.left,
      KeyD: this._onEvent.start.right
    };
    this._eventByArrowKeyOnKeyup = {
      ArrowUp: this._onEvent.end.forward,
      ArrowDown: this._onEvent.end.backward,
      ArrowLeft: this._onEvent.end.left,
      ArrowRight: this._onEvent.end.right
    };
    this._eventByWASNKeyOnKeyup = {
      KeyW: this._onEvent.end.forward,
      KeyS: this._onEvent.end.backward,
      KeyA: this._onEvent.end.left,
      KeyD: this._onEvent.end.right
    };
    this._runJumpEventByKeyOnkeydown = {
      ShiftLeft: this._onEvent.start.run,
      ShiftRight: this._onEvent.start.run,
      Space: this._onEvent.start.jump
    };
    this._runJumpEventByKeyOnkeyup = {
      ShiftLeft: this._onEvent.end.run,
      ShiftRight: this._onEvent.end.run,
      Space: this._onEvent.end.jump
    };
  }
  // public useWASDkeys = true;
  // public useArrowkeys = true;
  callback(eventType) {
    return this._callbackByEventType[eventType];
  }
  _onKeydownCallback(keyCode) {
    const jumpRunKeyCallback = this._runJumpEventByKeyOnkeydown[keyCode];
    if (jumpRunKeyCallback) {
      return jumpRunKeyCallback;
    }
    const wasdKeyCallback = this._eventByWASNKeyOnKeydown[keyCode];
    if (wasdKeyCallback) {
      return wasdKeyCallback;
    }
    const arrowKeyCallback = this._eventByArrowKeyOnKeydown[keyCode];
    if (arrowKeyCallback) {
      return arrowKeyCallback;
    }
  }
  _onKeyupCallback(keyCode) {
    const jumpRunKeyCallback = this._runJumpEventByKeyOnkeyup[keyCode];
    if (jumpRunKeyCallback) {
      return jumpRunKeyCallback;
    }
    const wasdKeyCallback = this._eventByWASNKeyOnKeyup[keyCode];
    if (wasdKeyCallback) {
      return wasdKeyCallback;
    }
    const arrowKeyCallback = this._eventByArrowKeyOnKeyup[keyCode];
    if (arrowKeyCallback) {
      return arrowKeyCallback;
    }
  }
  _onForwardStart() {
    this._playerInputData.forward.value = true;
  }
  _onBackwardStart() {
    this._playerInputData.backward.value = true;
  }
  _onLeftStart() {
    this._playerInputData.left.value = true;
  }
  _onRightStart() {
    this._playerInputData.right.value = true;
  }
  _onJumpStart() {
    this._playerInputData.jump.value = true;
  }
  _onRunStart() {
    this._playerInputData.run.value = true;
  }
  _onForwardEnd() {
    this._playerInputData.forward.value = false;
  }
  _onBackwardEnd() {
    this._playerInputData.backward.value = false;
  }
  _onLeftEnd() {
    this._playerInputData.left.value = false;
  }
  _onRightEnd() {
    this._playerInputData.right.value = false;
  }
  _onJumpEnd() {
    this._playerInputData.jump.value = false;
  }
  _onRunEnd() {
    this._playerInputData.run.value = false;
  }
}
const _inputDataByObject3D = /* @__PURE__ */ new WeakMap();
function _findOrCreateHandler(object3D) {
  let inputData = _inputDataByObject3D.get(object3D);
  if (inputData) {
    return inputData;
  }
  inputData = new InputDataHandler();
  _inputDataByObject3D.set(object3D, inputData);
  return inputData;
}
class setPlayerInput extends functions_Base/* ObjectNamedFunction1 */.c_ {
  static type() {
    return "setPlayerInput";
  }
  func(object3D, stopEventsPropagation) {
    const events = this.scene.eventsDispatcher.keyboardEventsController.currentEvents();
    if (events.length == 0) {
      return;
    }
    const handler = _findOrCreateHandler(object3D);
    for (let event of events) {
      if (event.ctrlKey) {
        return;
      }
      const callbackMethod = handler.callback(event.type);
      if (!callbackMethod) {
        return;
      }
      const callback = callbackMethod(event.code);
      if (callback) {
        callback();
        if (stopEventsPropagation == true) {
          event.stopImmediatePropagation();
          event.stopPropagation();
          event.preventDefault();
        }
      }
    }
  }
}
class getPlayerInputDataLeft extends functions_Base/* ObjectNamedFunction0 */.jY {
  static type() {
    return "getPlayerInputDataLeft";
  }
  func(object3D) {
    return _findOrCreateHandler(object3D)._playerInputData.left.value;
  }
}
class getPlayerInputDataRight extends functions_Base/* ObjectNamedFunction0 */.jY {
  static type() {
    return "getPlayerInputDataRight";
  }
  func(object3D) {
    return _findOrCreateHandler(object3D)._playerInputData.right.value;
  }
}
class getPlayerInputDataForward extends functions_Base/* ObjectNamedFunction0 */.jY {
  static type() {
    return "getPlayerInputDataForward";
  }
  func(object3D) {
    return _findOrCreateHandler(object3D)._playerInputData.forward.value;
  }
}
class getPlayerInputDataBackward extends functions_Base/* ObjectNamedFunction0 */.jY {
  static type() {
    return "getPlayerInputDataBackward";
  }
  func(object3D) {
    return _findOrCreateHandler(object3D)._playerInputData.backward.value;
  }
}
class getPlayerInputDataRun extends functions_Base/* ObjectNamedFunction0 */.jY {
  static type() {
    return "getPlayerInputDataRun";
  }
  func(object3D) {
    return _findOrCreateHandler(object3D)._playerInputData.run.value;
  }
}
class getPlayerInputDataJump extends functions_Base/* ObjectNamedFunction0 */.jY {
  static type() {
    return "getPlayerInputDataJump";
  }
  func(object3D) {
    return _findOrCreateHandler(object3D)._playerInputData.jump.value;
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/core/player/PlayerSimple.ts



function capsuleDataFromInput(input) {
  return {
    radius: input.radius,
    segment: new three_module.Line3(new three_module.Vector3(0, 0, 0), new three_module.Vector3(0, -(input.height - 2 * input.radius), 0))
  };
}
const tmpGravity = new three_module.Vector3(0, 0, 0);
const upVector = new three_module.Vector3(0, 1, 0);
const tempVector1 = new three_module.Vector3();
const tempVector2 = new three_module.Vector3();
const tempVector3 = new three_module.Vector3();
const tempVector4 = new three_module.Vector3();
const tempVector5 = new three_module.Vector3();
const PlayerSimple_tmpPos1 = new three_module.Vector3();
const tempBox = new three_module.Box3();
const tempMat = new three_module.Matrix4();
const tempSegment = new three_module.Line3();
class CorePlayer {
  constructor(_object) {
    this._object = _object;
    this._inputData = {
      forward: false,
      backward: false,
      left: false,
      right: false,
      run: false,
      jump: false
    };
    this._computeInputData = {
      collider: void 0,
      speed: 1,
      runAllowed: true,
      runSpeedMult: 2,
      jumpAllowed: true,
      jumpStrength: 1,
      physicsSteps: 5,
      gravity: new three_module.Vector3(0, -9.8, 0),
      capsuleData: capsuleDataFromInput({
        radius: Capsule/* CapsuleSopOperation.DEFAULT_PARAMS.radius */.e.DEFAULT_PARAMS.radius,
        height: Capsule/* CapsuleSopOperation.DEFAULT_PARAMS.height */.e.DEFAULT_PARAMS.height
      })
    };
    this._computedData = {
      velocityFromForces: new three_module.Vector3(0, 0, 0),
      onGround: false,
      velocityFromPositionDelta: new three_module.Vector3(0, 0, 0)
    };
  }
  setComputeInputData(data) {
    this._computeInputData.collider = data.collider;
    this._computeInputData.speed = data.speed;
    this._computeInputData.runSpeedMult = data.runSpeedMult;
    this._computeInputData.jumpStrength = data.jumpStrength;
    this._computeInputData.physicsSteps = data.physicsSteps;
    this._computeInputData.gravity.copy(data.gravity);
    this._computeInputData.speed = data.speed;
    this._computeInputData.capsuleData = capsuleDataFromInput(data.capsuleInput);
  }
  update(delta) {
    const deltaBounded = Math.min(delta, 0.1);
    const physicsSteps = this._computeInputData.physicsSteps;
    const deltaNormalized = deltaBounded / physicsSteps;
    PlayerSimple_tmpPos1.copy(this._object.position);
    for (let i = 0; i < physicsSteps; i++) {
      this._updateStep(deltaNormalized);
    }
    this._computedData.velocityFromPositionDelta.copy(this._object.position).sub(PlayerSimple_tmpPos1).divideScalar(delta);
  }
  _updateStep(delta) {
    const object = this._object;
    const { onGround, velocityFromForces } = this._computedData;
    const { collider, speed, runSpeedMult, gravity, capsuleData } = this._computeInputData;
    const { left, right, backward, forward, run } = this._inputData;
    if (!onGround) {
      tmpGravity.copy(gravity).multiplyScalar(delta);
      velocityFromForces.add(tmpGravity);
    }
    object.position.addScaledVector(velocityFromForces, delta);
    const angle = 0;
    const speedNormalized = speed * delta * (run ? runSpeedMult : 1);
    tempVector2.set(0, 0, 0);
    if (forward) {
      tempVector1.set(0, 0, -1).applyAxisAngle(upVector, angle);
      tempVector2.add(tempVector1);
    }
    if (backward) {
      tempVector1.set(0, 0, 1).applyAxisAngle(upVector, angle);
      tempVector2.add(tempVector1);
    }
    if (left) {
      tempVector1.set(-1, 0, 0).applyAxisAngle(upVector, angle);
      tempVector2.add(tempVector1);
    }
    if (right) {
      tempVector1.set(1, 0, 0).applyAxisAngle(upVector, angle);
      tempVector2.add(tempVector1);
    }
    tempVector2.normalize().multiplyScalar(speedNormalized);
    object.position.add(tempVector2);
    object.updateMatrix();
    object.updateMatrixWorld();
    if (collider) {
      tempBox.makeEmpty();
      tempMat.copy(collider.matrixWorld).invert();
      tempSegment.copy(capsuleData.segment);
      tempSegment.start.applyMatrix4(object.matrixWorld).applyMatrix4(tempMat);
      tempSegment.end.applyMatrix4(object.matrixWorld).applyMatrix4(tempMat);
      tempBox.expandByPoint(tempSegment.start);
      tempBox.expandByPoint(tempSegment.end);
      tempBox.min.addScalar(-capsuleData.radius);
      tempBox.max.addScalar(capsuleData.radius);
      const intersectsBounds = (box, isLeaf, score, depth, nodeIndex) => {
        return box.intersectsBox(tempBox);
      };
      const intersectsTriangle = (tri) => {
        const triPoint = tempVector3;
        const capsulePoint = tempVector4;
        const distance = tri.closestPointToSegment(tempSegment, triPoint, capsulePoint);
        if (distance < capsuleData.radius) {
          const depth = capsuleData.radius - distance;
          const direction = capsulePoint.sub(triPoint).normalize();
          tempSegment.start.addScaledVector(direction, depth);
          tempSegment.end.addScaledVector(direction, depth);
        }
      };
      collider.geometry.boundsTree.shapecast({
        intersectsBounds,
        intersectsTriangle
      });
      const newPosition = tempVector5;
      newPosition.copy(tempSegment.start);
      newPosition.applyMatrix4(collider.matrixWorld);
      const deltaVector = tempVector2;
      deltaVector.subVectors(newPosition, object.position);
      this._computedData.onGround = deltaVector.y > Math.abs(delta * velocityFromForces.y * 0.25);
      const offset = Math.max(0, deltaVector.length() - 1e-5);
      deltaVector.normalize().multiplyScalar(offset);
      object.position.add(deltaVector);
      if (!this._computedData.onGround) {
        deltaVector.normalize();
        velocityFromForces.addScaledVector(deltaVector, -deltaVector.dot(velocityFromForces));
      } else {
        velocityFromForces.set(0, 0, 0);
      }
    }
  }
  setInputData(inputData) {
    this._inputData.left = inputData.left;
    this._inputData.right = inputData.right;
    this._inputData.backward = inputData.backward;
    this._inputData.forward = inputData.forward;
    if (this._computeInputData.runAllowed && inputData.run && this._computedData.onGround) {
      this._inputData.run = true;
    } else {
      this._inputData.run = false;
    }
    if (this._computeInputData.jumpAllowed && inputData.jump && this._computedData.onGround) {
      this._computedData.velocityFromForces.y = this._computeInputData.jumpStrength;
    }
  }
  velocityFromPositionDelta(target) {
    return target.copy(this._computedData.velocityFromPositionDelta);
  }
  onGround() {
    return this._computedData.onGround;
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/functions/_PlayerSimple.ts






function _PlayerSimple_createInputData() {
  return { forward: false, backward: false, left: false, right: false, run: false, jump: false };
}
function _createComputeData() {
  return {
    collider: void 0,
    speed: 2,
    runAllowed: true,
    runSpeedMult: 2,
    jumpAllowed: true,
    jumpStrength: 10,
    physicsSteps: 5,
    gravity: new three_module.Vector3(0, -9.8, 0),
    capsuleInput: {
      radius: Capsule/* CapsuleSopOperation.DEFAULT_PARAMS.radius */.e.DEFAULT_PARAMS.radius,
      height: Capsule/* CapsuleSopOperation.DEFAULT_PARAMS.height */.e.DEFAULT_PARAMS.height
    }
  };
}
const _elementByObject3D = /* @__PURE__ */ new WeakMap();
function _findOrCreateElement(object3D) {
  let element = _elementByObject3D.get(object3D);
  if (element) {
    return element;
  }
  element = {
    player: new CorePlayer(object3D),
    inputData: _PlayerSimple_createInputData(),
    computeData: _createComputeData()
  };
  _elementByObject3D.set(object3D, element);
  return element;
}
class playerSimpleUpdate extends functions_Base/* ObjectNamedFunction1 */.c_ {
  static type() {
    return "playerSimpleUpdate";
  }
  func(object3D, options) {
    const {
      collider,
      speed,
      runAllowed,
      runSpeedMult,
      jumpAllowed,
      jumpStrength,
      physicsSteps,
      gravity,
      capsuleRadius,
      capsuleHeight,
      left,
      right,
      backward,
      forward,
      run,
      jump
    } = options;
    const { player, inputData, computeData } = _findOrCreateElement(object3D);
    if (collider.geometry && collider.geometry.boundsTree) {
      computeData.collider = collider;
    } else {
      computeData.collider = void 0;
    }
    computeData.speed = speed;
    computeData.runAllowed = runAllowed;
    computeData.runSpeedMult = runSpeedMult;
    computeData.jumpAllowed = jumpAllowed;
    computeData.jumpStrength = jumpStrength;
    computeData.physicsSteps = physicsSteps;
    computeData.gravity.copy(gravity);
    computeData.capsuleInput.radius = capsuleRadius;
    computeData.capsuleInput.height = capsuleHeight;
    inputData.left = left;
    inputData.right = right;
    inputData.backward = backward;
    inputData.forward = forward;
    inputData.run = run;
    inputData.jump = jump;
    player.setComputeInputData(computeData);
    player.setInputData(inputData);
    player.update(this.scene.timeController.delta());
  }
}
class getPlayerSimplePropertyOnGround extends functions_Base/* ObjectNamedFunction0 */.jY {
  static type() {
    return "getPlayerSimplePropertyOnGround";
  }
  func(object3D) {
    (0,CoreReactivity/* dummyReadRefVal */.Jb)(this.timeController.timeUniform().value);
    const { player } = _findOrCreateElement(object3D);
    return player.onGround();
  }
}
class getPlayerSimplePropertyVelocity extends functions_Base/* ObjectNamedFunction1 */.c_ {
  static type() {
    return "getPlayerSimplePropertyVelocity";
  }
  func(object3D, target) {
    (0,CoreReactivity/* dummyReadRefVal */.Jb)(this.timeController.timeUniform().value);
    const { player } = _findOrCreateElement(object3D);
    player.velocityFromPositionDelta(target);
    return target;
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/functions/_GetPointProperty.ts





class getPointIndex extends functions_Base/* ObjectNamedFunction0 */.jY {
  static type() {
    return "getPointIndex";
  }
  func(object3D) {
    const ref = getObjectPtnumRef(object3D);
    return ref.value;
  }
}
class setPointIndex extends functions_Base/* ObjectNamedFunction1 */.c_ {
  static type() {
    return "setPointIndex";
  }
  func(object3D, ptnum) {
    const ref = getObjectPtnumRef(object3D);
    ref.value = ptnum;
    return ptnum;
  }
}
class getPointPosition extends functions_Base/* ObjectNamedFunction2 */.YS {
  static type() {
    return "getPointPosition";
  }
  func(object3D, ptnum, target) {
    (0,CoreReactivity/* dummyReadRefVal */.Jb)(this.timeController.timeUniform().value);
    if (!object3D.geometry) {
      target.set(0, 0, 0);
      return target;
    }
    const positionAttribute = object3D.geometry.getAttribute(geometry_Attribute/* Attribute.POSITION */.ah.POSITION);
    target.fromBufferAttribute(positionAttribute, ptnum);
    return target;
  }
}
class getPointAttributeNumber extends functions_Base/* ObjectNamedFunction3 */.uW {
  static type() {
    return "getPointAttributeNumber";
  }
  func(object3D, ptnum, attribName, defaultValue) {
    (0,CoreReactivity/* dummyReadRefVal */.Jb)(this.timeController.timeUniform().value);
    const attribute = object3D.geometry.getAttribute(attribName);
    if (!attribute) {
      return defaultValue;
    }
    return attribute.array[ptnum];
  }
}
class getPointAttributeVector2 extends functions_Base/* ObjectNamedFunction4 */.eG {
  static type() {
    return "getPointAttributeVector2";
  }
  func(object3D, ptnum, attribName, defaultValue, target) {
    (0,CoreReactivity/* dummyReadRefVal */.Jb)(this.timeController.timeUniform().value);
    const attribute = object3D.geometry.getAttribute(attribName);
    if (!attribute) {
      target.copy(defaultValue);
      return target;
    }
    target.fromArray(attribute.array, ptnum * 2);
    return target;
  }
}
class getPointAttributeVector3 extends functions_Base/* ObjectNamedFunction4 */.eG {
  static type() {
    return "getPointAttributeVector3";
  }
  func(object3D, ptnum, attribName, defaultValue, target) {
    (0,CoreReactivity/* dummyReadRefVal */.Jb)(this.timeController.timeUniform().value);
    const attribute = object3D.geometry.getAttribute(attribName);
    if (!attribute) {
      target.copy(defaultValue);
      return target;
    }
    target.fromArray(attribute.array, ptnum * 3);
    return target;
  }
}
class getPointAttributeVector4 extends functions_Base/* ObjectNamedFunction4 */.eG {
  static type() {
    return "getPointAttributeVector4";
  }
  func(object3D, ptnum, attribName, defaultValue, target) {
    (0,CoreReactivity/* dummyReadRefVal */.Jb)(this.timeController.timeUniform().value);
    const attribute = object3D.geometry.getAttribute(attribName);
    if (!attribute) {
      target.copy(defaultValue);
      return target;
    }
    target.fromArray(attribute.array, ptnum * 4);
    return target;
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/functions/_GetInstanceProperty.ts




class getPointInstancePosition extends functions_Base/* ObjectNamedFunction2 */.YS {
  static type() {
    return "getPointInstancePosition";
  }
  func(object3D, ptnum, target) {
    (0,CoreReactivity/* dummyReadRefVal */.Jb)(this.timeController.timeUniform().value);
    if (!object3D.geometry) {
      target.set(0, 0, 0);
      return target;
    }
    const positionAttribute = object3D.geometry.getAttribute(Instancer/* InstanceAttrib.POSITION */.R.POSITION);
    target.fromBufferAttribute(positionAttribute, ptnum);
    return target;
  }
}
class getPointInstanceQuaternion extends functions_Base/* ObjectNamedFunction2 */.YS {
  static type() {
    return "getPointInstanceQuaternion";
  }
  func(object3D, ptnum, target) {
    (0,CoreReactivity/* dummyReadRefVal */.Jb)(this.timeController.timeUniform().value);
    if (!object3D.geometry) {
      target.identity();
      return target;
    }
    const positionAttribute = object3D.geometry.getAttribute(Instancer/* InstanceAttrib.QUATERNION */.R.QUATERNION);
    target.fromBufferAttribute(positionAttribute, ptnum);
    return target;
  }
}
class getPointInstanceScale extends functions_Base/* ObjectNamedFunction2 */.YS {
  static type() {
    return "getPointInstanceScale";
  }
  func(object3D, ptnum, target) {
    (0,CoreReactivity/* dummyReadRefVal */.Jb)(this.timeController.timeUniform().value);
    if (!object3D.geometry) {
      target.set(0, 0, 0);
      return target;
    }
    const positionAttribute = object3D.geometry.getAttribute(Instancer/* InstanceAttrib.SCALE */.R.SCALE);
    target.fromBufferAttribute(positionAttribute, ptnum);
    return target;
  }
}

// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/core/geometry/modules/three/ThreeModule.ts + 2 modules
var ThreeModule = __webpack_require__(76749);
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/functions/_GetPrimitiveAttribute.ts



class getPrimitiveAttribute extends functions_Base/* ObjectNamedFunction4 */.eG {
  static type() {
    return "getPrimitiveAttribute";
  }
  func(object3D, index, attribName, type, defaultValue) {
    const primitiveClass = (0,ThreeModule/* primitiveClassFactoryNonAbstract */.iS)(object3D);
    if (!primitiveClass) {
      return defaultValue;
    }
    const value = primitiveClass.attribValue(
      object3D,
      index,
      attribName
      /*, defaultValue as Vector3*/
    );
    if (value == null) {
      return defaultValue;
    }
    return value;
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/functions/_Ray.ts




const raycaster = new three_module.Raycaster();
const DEFAULT_POS = new three_module.Vector3();
const DEFAULT_INTERSECTION = {
  distance: -1,
  point: DEFAULT_POS,
  object: new three_module.Object3D()
};
const _Ray_tmpV2 = new three_module.Vector2();
class raySet extends functions_Base/* NamedFunction3 */.Dv {
  static type() {
    return "raySet";
  }
  func(origin, direction, target) {
    target.origin.copy(origin);
    target.direction.copy(direction);
    return target;
  }
}
class rayFromCamera extends functions_Base/* ObjectNamedFunction3 */.uW {
  static type() {
    return "rayFromCamera";
  }
  func(object3D, x, y, target) {
    if (object3D == null) {
      this._getDefaultCamera = this._getDefaultCamera || new getDefaultCamera(this.node, this.shadersCollectionController);
      object3D = this._getDefaultCamera.func();
    }
    if (!(object3D instanceof three_module.PerspectiveCamera || object3D instanceof three_module.OrthographicCamera)) {
      return target;
    }
    _Ray_tmpV2.set(x, y);
    raycaster.setFromCamera(_Ray_tmpV2, object3D);
    target.copy(raycaster.ray);
    return target;
  }
}
class getRayOrigin extends functions_Base/* NamedFunction2 */.CE {
  static type() {
    return "getRayOrigin";
  }
  func(ray, target) {
    return target.copy(ray.origin);
  }
}
class getRayDirection extends functions_Base/* NamedFunction2 */.CE {
  static type() {
    return "getRayDirection";
  }
  func(ray, target) {
    return target.copy(ray.direction);
  }
}
class rayIntersectBox3 extends functions_Base/* NamedFunction3 */.Dv {
  static type() {
    return "rayIntersectBox3";
  }
  func(ray, box, target) {
    ray.intersectBox(box, target);
    return target;
  }
}
class rayIntersectsBox3 extends functions_Base/* NamedFunction2 */.CE {
  static type() {
    return "rayIntersectsBox3";
  }
  func(ray, box) {
    return ray.intersectsBox(box);
  }
}
function _defaultIntersection(object3D) {
  DEFAULT_INTERSECTION.object = object3D;
  return DEFAULT_INTERSECTION;
}
class rayIntersectObject3D extends functions_Base/* NamedFunction3 */.Dv {
  static type() {
    return "rayIntersectObject3D";
  }
  func(ray, object3D, recursive) {
    raycaster.ray.copy(ray);
    const intersections = raycaster.intersectObject(object3D, recursive);
    return intersections[0] || _defaultIntersection(object3D);
  }
}
class rayIntersectsObject3D extends functions_Base/* NamedFunction3 */.Dv {
  static type() {
    return "rayIntersectsObject3D";
  }
  func(ray, object3D, recursive) {
    raycaster.ray.copy(ray);
    const intersections = raycaster.intersectObject(object3D, recursive);
    return intersections.length > 0;
  }
}
class rayIntersectPlane extends functions_Base/* NamedFunction3 */.Dv {
  static type() {
    return "rayIntersectPlane";
  }
  func(ray, plane, target) {
    ray.intersectPlane(plane, target);
    return target;
  }
}
class rayIntersectsPlane extends functions_Base/* NamedFunction2 */.CE {
  static type() {
    return "rayIntersectsPlane";
  }
  func(ray, plane) {
    return ray.intersectsPlane(plane);
  }
}
class rayDistanceToPlane extends functions_Base/* NamedFunction2 */.CE {
  static type() {
    return "rayDistanceToPlane";
  }
  func(ray, plane) {
    return ray.distanceToPlane(plane);
  }
}
class rayIntersectSphere extends functions_Base/* NamedFunction3 */.Dv {
  static type() {
    return "rayIntersectSphere";
  }
  func(ray, sphere, target) {
    ray.intersectSphere(sphere, target);
    return target;
  }
}
class rayIntersectsSphere extends functions_Base/* NamedFunction2 */.CE {
  static type() {
    return "rayIntersectsSphere";
  }
  func(ray, sphere) {
    return ray.intersectsSphere(sphere);
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/functions/_GetSibbling.ts



class getSibbling extends functions_Base/* ObjectNamedFunction1 */.c_ {
  static type() {
    return "getSibbling";
  }
  func(object3D, offset) {
    const parent = object3D.parent || object3D;
    const children = parent.children;
    const currentIndex = children.indexOf(object3D);
    if (currentIndex < 0) {
      return object3D;
    }
    const index = (0,_Module/* mod */.wQ)(currentIndex + offset, children.length);
    const sibbling = children[index] || object3D;
    return sibbling;
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/functions/_Sphere.ts


class sphereSet extends functions_Base/* NamedFunction3 */.Dv {
  static type() {
    return "sphereSet";
  }
  func(center, radius, target) {
    target.center.copy(center);
    target.radius = radius;
    return target;
  }
}
class getSphereCenter extends functions_Base/* NamedFunction2 */.CE {
  static type() {
    return "getSphereCenter";
  }
  func(sphere, target) {
    return target.copy(sphere.center);
  }
}
class getSphereRadius extends functions_Base/* NamedFunction1 */.TV {
  static type() {
    return "getSphereRadius";
  }
  func(sphere) {
    return sphere.radius;
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/core/computerVision/Common.ts



function computerVisionValidSource(texture) {
  if (texture instanceof three_module.VideoTexture) {
    if (texture.image instanceof HTMLVideoElement) {
      if (DomUtils/* CoreDomUtils.isHTMLVideoElementLoaded */.O.isHTMLVideoElementLoaded(texture.image) && !DomUtils/* CoreDomUtils.isHTMLVideoPaused */.O.isHTMLVideoPaused(texture.image)) {
        return texture.image;
      }
    }
  } else if (texture instanceof three_module.CanvasTexture) {
    if (texture.source.data instanceof HTMLCanvasElement) {
      return texture.source.data;
    }
  } else if (texture instanceof three_module.Texture) {
    if (texture.image instanceof HTMLImageElement) {
      return texture.image;
    }
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/core/reactivity/TrackingReactivity.ts


const refByObjectUuid = /* @__PURE__ */ new Map();
function getOrCreateTrackedObjectRef(timeController, object3D) {
  return getTrackedObjectRef(timeController, object3D) || createRef(object3D);
}
function createRef(object3D) {
  let _ref = refByObjectUuid.get(object3D.uuid);
  if (!_ref) {
    _ref = (0,reactivity_esm_bundler/* ref */.iH)(0);
    refByObjectUuid.set(object3D.uuid, _ref);
  }
  return _ref;
}
function getTrackedObjectRef(timeController, object3D) {
  return timeController.timeUniform();
}
function touchTrackedObject(object3D) {
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/functions/_TrackingHand.ts








const _TrackingHand_tmpV4 = new three_module.Vector4();
class trackHand extends functions_Base/* ObjectNamedFunction1 */.c_ {
  static type() {
    return "trackHand";
  }
  func(object3D, texture) {
    if (!texture) {
      return;
    }
    const source = computerVisionValidSource(texture);
    if (!source) {
      return;
    }
    CoreComputerVisionHand.trackMedia(object3D, source);
    touchTrackedObject(object3D);
  }
}
class trackHandGetNormalizedLandmarks extends functions_Base/* ObjectNamedFunction2 */.YS {
  static type() {
    return "trackHandGetNormalizedLandmarks";
  }
  func(object3D, handIndex, target) {
    (0,CoreReactivity/* dummyReadRefVal */.Jb)(getOrCreateTrackedObjectRef(this.timeController, object3D).value);
    const results = CoreComputerVisionHand.trackerResults(object3D);
    const vectorArray = results[handIndex].multiHandLandmarks;
    let i = 0;
    for (let src of vectorArray) {
      target[i].copy(src);
      i++;
    }
    return target;
  }
}
class trackHandGetWorldLandmarks extends functions_Base/* ObjectNamedFunction2 */.YS {
  static type() {
    return "trackHandGetWorldLandmarks";
  }
  func(object3D, handIndex, target) {
    (0,CoreReactivity/* dummyReadRefVal */.Jb)(getOrCreateTrackedObjectRef(this.timeController, object3D).value);
    const results = CoreComputerVisionHand.trackerResults(object3D);
    const vectorArray = results[handIndex].multiHandWorldLandmarks;
    let i = 0;
    for (let src of vectorArray) {
      target[i].copy(src);
      i++;
    }
    return target;
  }
}
class getTrackedHandThumbDirection extends functions_Base/* NamedFunction2 */.CE {
  static type() {
    return "getTrackedHandThumbDirection";
  }
  func(values, target) {
    _TrackingHand_tmpV4.copy(values[CoreComputerVisionHandIndex.THUMB_TIP]).sub(values[CoreComputerVisionHandIndex.THUMB_MCP]);
    target.set(_TrackingHand_tmpV4.x, _TrackingHand_tmpV4.y, _TrackingHand_tmpV4.z).normalize();
    return target;
  }
}
class getTrackedHandIndexDirection extends functions_Base/* NamedFunction2 */.CE {
  static type() {
    return "getTrackedHandIndexDirection";
  }
  func(values, target) {
    _TrackingHand_tmpV4.copy(values[CoreComputerVisionHandIndex.INDEX_FINGER_TIP]).sub(values[CoreComputerVisionHandIndex.INDEX_FINGER_DIP]);
    target.set(_TrackingHand_tmpV4.x, _TrackingHand_tmpV4.y, _TrackingHand_tmpV4.z).normalize();
    return target;
  }
}
class getTrackedHandMiddleDirection extends functions_Base/* NamedFunction2 */.CE {
  static type() {
    return "getTrackedHandMiddleDirection";
  }
  func(values, target) {
    _TrackingHand_tmpV4.copy(values[CoreComputerVisionHandIndex.MIDDLE_FINGER_TIP]).sub(values[CoreComputerVisionHandIndex.MIDDLE_FINGER_DIP]);
    target.set(_TrackingHand_tmpV4.x, _TrackingHand_tmpV4.y, _TrackingHand_tmpV4.z).normalize();
    return target;
  }
}
class getTrackedHandRingDirection extends functions_Base/* NamedFunction2 */.CE {
  static type() {
    return "getTrackedHandRingDirection";
  }
  func(values, target) {
    _TrackingHand_tmpV4.copy(values[CoreComputerVisionHandIndex.RING_FINGER_TIP]).sub(values[CoreComputerVisionHandIndex.RING_FINGER_DIP]);
    target.set(_TrackingHand_tmpV4.x, _TrackingHand_tmpV4.y, _TrackingHand_tmpV4.z).normalize();
    return target;
  }
}
class getTrackedHandPinkyDirection extends functions_Base/* NamedFunction2 */.CE {
  static type() {
    return "getTrackedHandPinkyDirection";
  }
  func(values, target) {
    _TrackingHand_tmpV4.copy(values[CoreComputerVisionHandIndex.PINKY_TIP]).sub(values[CoreComputerVisionHandIndex.PINKY_DIP]);
    target.set(_TrackingHand_tmpV4.x, _TrackingHand_tmpV4.y, _TrackingHand_tmpV4.z).normalize();
    return target;
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/core/reactivity/WebXRTrackedMarker.ts


const refByIndex = /* @__PURE__ */ new Map();
function getOrCreateWebXRTrackerRef(index) {
  return getWebXRTrackerRef(index) || createWebXRTrackerRef(index);
}
function getWebXRTrackerRef(index) {
  return refByIndex.get(index);
}
function createWebXRTrackerRef(index) {
  let refForIndex = refByIndex.get(index);
  if (!refForIndex) {
    refForIndex = (0,reactivity_esm_bundler/* ref */.iH)(0);
    refByIndex.set(index, refForIndex);
  }
  return refForIndex;
}
function touchWebXRTrackerRef(index) {
  const _ref = getWebXRTrackerRef(index);
  if (!_ref) {
    return;
  }
  incrementRefSafely(_ref);
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/functions/_WebXR.ts





class getWebXRARHitDetected extends functions_Base/* NamedFunction0 */.Fp {
  static type() {
    return "getWebXRARHitDetected";
  }
  func() {
    (0,CoreReactivity/* dummyReadRefVal */.Jb)(this.timeController.timeUniform().value);
    const arController = this.scene.webXR.activeARController();
    return (arController == null ? void 0 : arController.hitDetected()) || false;
  }
}
class getWebXRARHitMatrix extends functions_Base/* NamedFunction1 */.TV {
  static type() {
    return "getWebXRARHitMatrix";
  }
  func(target) {
    (0,CoreReactivity/* dummyReadRefVal */.Jb)(this.timeController.timeUniform().value);
    const arController = this.scene.webXR.activeARController();
    arController == null ? void 0 : arController.hitMatrix(target);
    return target;
  }
}
class getWebXRARHitPosition extends functions_Base/* NamedFunction1 */.TV {
  static type() {
    return "getWebXRARHitPosition";
  }
  func(target) {
    (0,CoreReactivity/* dummyReadRefVal */.Jb)(this.timeController.timeUniform().value);
    const arController = this.scene.webXR.activeARController();
    arController == null ? void 0 : arController.hitPosition(target);
    return target;
  }
}
class getWebXRARHitQuaternion extends functions_Base/* NamedFunction1 */.TV {
  static type() {
    return "getWebXRARHitQuaternion";
  }
  func(target) {
    (0,CoreReactivity/* dummyReadRefVal */.Jb)(this.timeController.timeUniform().value);
    const arController = this.scene.webXR.activeARController();
    arController == null ? void 0 : arController.hitQuaternion(target);
    return target;
  }
}
class getWebXRControllerObject extends functions_Base/* ObjectNamedFunction1 */.c_ {
  static type() {
    return "getWebXRControllerObject";
  }
  func(object3D, controllerIndex) {
    (0,CoreReactivity/* dummyReadRefVal */.Jb)(this.timeController.timeUniform().value);
    const xrController = this.scene.webXR.activeXRController();
    return (xrController == null ? void 0 : xrController.getController(controllerIndex).controller) || object3D;
  }
}
class getWebXRControllerRay extends functions_Base/* ObjectNamedFunction2 */.YS {
  static type() {
    return "getWebXRControllerRay";
  }
  func(object3D, controllerIndex, target) {
    (0,CoreReactivity/* dummyReadRefVal */.Jb)(this.timeController.timeUniform().value);
    const xrController = this.scene.webXR.activeXRController();
    const ray = xrController == null ? void 0 : xrController.getController(controllerIndex).ray;
    if (ray) {
      target.copy(ray);
    }
    return target;
  }
}
class getWebXRControllerHasAngularVelocity extends functions_Base/* ObjectNamedFunction1 */.c_ {
  static type() {
    return "getWebXRControllerHasAngularVelocity";
  }
  func(object3D, controllerIndex) {
    (0,CoreReactivity/* dummyReadRefVal */.Jb)(this.timeController.timeUniform().value);
    const xrController = this.scene.webXR.activeXRController();
    return (xrController == null ? void 0 : xrController.getController(controllerIndex).controller.hasAngularVelocity) || false;
  }
}
class getWebXRControllerAngularVelocity extends functions_Base/* ObjectNamedFunction2 */.YS {
  static type() {
    return "getWebXRControllerAngularVelocity";
  }
  func(object3D, controllerIndex, target) {
    (0,CoreReactivity/* dummyReadRefVal */.Jb)(this.timeController.timeUniform().value);
    const xrController = this.scene.webXR.activeXRController();
    const angularVelocity = xrController == null ? void 0 : xrController.getController(controllerIndex).controller.angularVelocity;
    if (angularVelocity) {
      target.copy(angularVelocity);
    }
    return target;
  }
}
class getWebXRControllerHasLinearVelocity extends functions_Base/* ObjectNamedFunction1 */.c_ {
  static type() {
    return "getWebXRControllerHasLinearVelocity";
  }
  func(object3D, controllerIndex) {
    (0,CoreReactivity/* dummyReadRefVal */.Jb)(this.timeController.timeUniform().value);
    const xrController = this.scene.webXR.activeXRController();
    return (xrController == null ? void 0 : xrController.getController(controllerIndex).controller.hasLinearVelocity) || false;
  }
}
class getWebXRControllerLinearVelocity extends functions_Base/* ObjectNamedFunction2 */.YS {
  static type() {
    return "getWebXRControllerLinearVelocity";
  }
  func(object3D, controllerIndex, target) {
    (0,CoreReactivity/* dummyReadRefVal */.Jb)(this.timeController.timeUniform().value);
    const xrController = this.scene.webXR.activeXRController();
    const linearVelocity = xrController == null ? void 0 : xrController.getController(controllerIndex).controller.linearVelocity;
    if (linearVelocity) {
      target.copy(linearVelocity);
    }
    return target;
  }
}
class getWebXRTrackedMarkerMatrix extends functions_Base/* NamedFunction1 */.TV {
  static type() {
    return "getWebXRTrackedMarkerMatrix";
  }
  func(target) {
    (0,CoreReactivity/* dummyReadRefVal */.Jb)(this.timeController.timeUniform().value);
    const controller = Poly/* Poly.thirdParty.markerTracking */.L.thirdParty.markerTracking().controller();
    if (controller) {
      (0,CoreReactivity/* dummyReadRefVal */.Jb)(getOrCreateWebXRTrackerRef(0).value);
      controller.trackedMatrix(target);
    } else {
      target.identity();
    }
    return target;
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/functions/_Globals.ts


class GlobalsTimeFunction0 extends functions_Base/* NamedFunction0 */.Fp {
  constructor(node, shadersCollectionController) {
    super(node, shadersCollectionController);
  }
}
class PointerEventsTimeFunction0 extends functions_Base/* NamedFunction0 */.Fp {
  constructor(node, shadersCollectionController) {
    super(node, shadersCollectionController);
    this.pointerEventsController = node.scene().eventsDispatcher.pointerEventsController;
  }
}
class globalsTime extends GlobalsTimeFunction0 {
  static type() {
    return "globalsTime";
  }
  func() {
    return this.timeController.timeUniform().value;
  }
}
class globalsTimeDelta extends GlobalsTimeFunction0 {
  static type() {
    return "globalsTimeDelta";
  }
  func() {
    return this.timeController.timeDeltaUniform().value;
  }
}
class globalsRaycaster extends PointerEventsTimeFunction0 {
  static type() {
    return "globalsRaycaster";
  }
  func() {
    return this.pointerEventsController.raycaster().value;
  }
}
class globalsRayFromCursor extends PointerEventsTimeFunction0 {
  static type() {
    return "globalsRayFromCursor";
  }
  func() {
    return this.pointerEventsController.raycaster().value.ray;
  }
}
class globalsCursor extends PointerEventsTimeFunction0 {
  static type() {
    return "globalsCursor";
  }
  func() {
    return this.pointerEventsController.cursor().value;
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/functions/_Attribute.ts



class importPrimitiveAttributeNumber extends functions_Base/* NamedFunction3 */.Dv {
  static type() {
    return "importPrimitiveAttributeNumber";
  }
  func(object, attribName, index) {
    return (0,CoreObjectFactory/* corePrimitiveClassFactory */.um)(object).attribValue(object, index, attribName);
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/functions/_UserAgent.ts



class isTouchDevice extends functions_Base/* NamedFunction0 */.Fp {
  static type() {
    return "isTouchDevice";
  }
  func() {
    return UserAgent/* CoreUserAgent.isTouchDevice */.Cj.isTouchDevice();
  }
}

// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/functions/_KeyboardEventMatchesConfig.ts
var _KeyboardEventMatchesConfig = __webpack_require__(28505);
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/functions/_VectorLength.ts



class lengthVector extends functions_Base/* NamedFunction1 */.TV {
  static type() {
    return "lengthVector";
  }
  func(src) {
    return src.length();
  }
}
class lengthVectorArray extends functions_Base/* NamedFunction2 */.CE {
  static type() {
    return "lengthVectorArray";
  }
  func(src, target) {
    (0,_ArrayUtils/* _matchArrayLength */.X9)(src, target, () => 0);
    let i = 0;
    for (let v of src) {
      target[i] = v.length();
      i++;
    }
    return target;
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/functions/_Lerp.ts



class lerpNumber extends functions_Base/* NamedFunction3 */.Dv {
  static type() {
    return "lerpNumber";
  }
  func(v1, v2, lerp) {
    return (0,_Module/* mix */.CD)(v1, v2, lerp);
  }
}
class lerpColor extends functions_Base/* NamedFunction4 */.Vm {
  static type() {
    return "lerpColor";
  }
  func(v1, v2, lerp, target) {
    return target.copy(v1).lerp(v2, lerp);
  }
}
class lerpQuaternion extends functions_Base/* NamedFunction4 */.Vm {
  static type() {
    return "lerpQuaternion";
  }
  func(v1, v2, lerp, target) {
    return target.copy(v1).slerp(v2, lerp);
  }
}
class lerpVector2 extends functions_Base/* NamedFunction4 */.Vm {
  static type() {
    return "lerpVector2";
  }
  func(v1, v2, lerp, target) {
    return target.copy(v1).lerp(v2, lerp);
  }
}
class lerpVector3 extends functions_Base/* NamedFunction4 */.Vm {
  static type() {
    return "lerpVector3";
  }
  func(v1, v2, lerp, target) {
    return target.copy(v1).lerp(v2, lerp);
  }
}
class lerpVector4 extends functions_Base/* NamedFunction4 */.Vm {
  static type() {
    return "lerpVector4";
  }
  func(v1, v2, lerp, target) {
    return target.copy(v1).lerp(v2, lerp);
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/functions/_VectorManhattanDistance.ts


class manhattanDistanceVector2 extends functions_Base/* NamedFunction2 */.CE {
  static type() {
    return "manhattanDistanceVector2";
  }
  func(v1, v2) {
    return v1.manhattanDistanceTo(v2);
  }
}
class manhattanDistanceVector3 extends functions_Base/* NamedFunction2 */.CE {
  static type() {
    return "manhattanDistanceVector3";
  }
  func(v1, v2) {
    return v1.manhattanDistanceTo(v2);
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/functions/_Matrix4.ts


class matrix4LookAt extends functions_Base/* NamedFunction4 */.Vm {
  static type() {
    return "matrix4LookAt";
  }
  func(eye, lookAtTarget, up, target) {
    target.lookAt(eye, lookAtTarget, up);
    return target;
  }
}
class matrix4MakeTranslation extends functions_Base/* NamedFunction2 */.CE {
  static type() {
    return "matrix4MakeTranslation";
  }
  func(t, target) {
    target.makeTranslation(t.x, t.y, t.z);
    return target;
  }
}
class matrix4Multiply extends functions_Base/* NamedFunction3 */.Dv {
  static type() {
    return "matrix4Multiply";
  }
  func(m1, m2, target) {
    target.copy(m1).multiply(m2);
    return target;
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/functions/_VectorMaxLength.ts


class maxLengthVector2 extends functions_Base/* NamedFunction3 */.Dv {
  static type() {
    return "maxLengthVector2";
  }
  func(src, maxLength, target) {
    target.copy(src);
    const length = target.length();
    if (length > maxLength) {
      target.normalize().multiplyScalar(maxLength);
    }
    return target;
  }
}
class maxLengthVector3 extends functions_Base/* NamedFunction3 */.Dv {
  static type() {
    return "maxLengthVector3";
  }
  func(src, maxLength, target) {
    target.copy(src);
    const length = target.length();
    if (length > maxLength) {
      target.normalize().multiplyScalar(maxLength);
    }
    return target;
  }
}
class maxLengthVector4 extends functions_Base/* NamedFunction3 */.Dv {
  static type() {
    return "maxLengthVector4";
  }
  func(src, maxLength, target) {
    target.copy(src);
    const length = target.length();
    if (length > maxLength) {
      target.normalize().multiplyScalar(maxLength);
    }
    return target;
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/functions/_Mult.ts


class multNumber extends functions_Base/* NamedFunction */.x9 {
  static type() {
    return "multNumber";
  }
  func(...args) {
    let first = args[0];
    for (let i = 1; i < args.length; i++) {
      first *= args[i];
    }
    return first;
  }
}
class multVector extends functions_Base/* NamedFunction */.x9 {
  static type() {
    return "multVector";
  }
  func(...args) {
    const first = args[0];
    for (let i = 1; i < args.length; i++) {
      first.multiply(args[i]);
    }
    return first;
  }
}
class multVectorNumber extends functions_Base/* NamedFunction2 */.CE {
  static type() {
    return "multVectorNumber";
  }
  func(vector, number) {
    return vector.multiplyScalar(number);
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/functions/_MultScalar.ts



class multScalarColor extends functions_Base/* NamedFunction3 */.Dv {
  static type() {
    return "multScalarColor";
  }
  func(src, scalar, target) {
    return target.copy(src).multiplyScalar(scalar);
  }
}
class multScalarVector2 extends functions_Base/* NamedFunction3 */.Dv {
  static type() {
    return "multScalarVector2";
  }
  func(src, scalar, target) {
    return target.copy(src).multiplyScalar(scalar);
  }
}
class multScalarVector3 extends functions_Base/* NamedFunction3 */.Dv {
  static type() {
    return "multScalarVector3";
  }
  func(src, scalar, target) {
    return target.copy(src).multiplyScalar(scalar);
  }
}
class multScalarVector4 extends functions_Base/* NamedFunction3 */.Dv {
  static type() {
    return "multScalarVector4";
  }
  func(src, scalar, target) {
    return target.copy(src).multiplyScalar(scalar);
  }
}
class multScalarVectorArray extends functions_Base/* NamedFunction3 */.Dv {
  static type() {
    return "multScalarVectorArray";
  }
  func(src, scalar, target) {
    (0,_ArrayUtils/* _matchArrayLength */.X9)(src, target, () => src[0].clone());
    let i = 0;
    for (let v of src) {
      target[i].copy(v).multiplyScalar(scalar);
      i++;
    }
    return target;
  }
}
class multScalarArrayVectorArray extends functions_Base/* NamedFunction3 */.Dv {
  static type() {
    return "multScalarArrayVectorArray";
  }
  func(src, scalar, target) {
    (0,_ArrayUtils/* _matchArrayLength */.X9)(src, target, () => src[0].clone());
    let i = 0;
    for (let v of src) {
      target[i].copy(v).multiplyScalar(scalar[i]);
      i++;
    }
    return target;
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/functions/_NearestPosition.ts


class nearestPosition extends functions_Base/* NamedFunction3 */.Dv {
  static type() {
    return "nearestPosition";
  }
  func(v3, positions, target) {
    target.set(0, 0, 0);
    if (positions) {
      let currentDist = -1;
      let minDist = null;
      let nearestPosition2;
      for (let position of positions) {
        currentDist = position.distanceTo(v3);
        if (minDist == null || currentDist < minDist) {
          nearestPosition2 = position;
          minDist = currentDist;
        }
      }
      if (nearestPosition2 != null) {
        target.copy(nearestPosition2);
      }
    }
    return target;
  }
}

// EXTERNAL MODULE: ../@polygonjs/polygonjs/node_modules/three/examples/jsm/math/ImprovedNoise.js
var ImprovedNoise = __webpack_require__(36259);
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/functions/_NoiseImproved.ts




const _NoiseImproved_v3 = new three_module.Vector3();
const noise = new ImprovedNoise/* ImprovedNoise */.x();
function _fbm3d(x, y, z, octaves, ampMult, freqMult) {
  let value = 0;
  let amplitude = 1;
  for (let i = 0; i < octaves; i++) {
    value += amplitude * noise.noise(x, y, z);
    x *= freqMult;
    y *= freqMult;
    z *= freqMult;
    amplitude *= ampMult;
  }
  return value;
}
class noiseImprovedVector3 extends functions_Base/* NamedFunction7 */.oT {
  static type() {
    return "noiseImprovedVector3";
  }
  func(position, amp, freq, offset, octaves, ampMult, freqMult) {
    _NoiseImproved_v3.copy(position).add(offset).multiply(freq);
    return amp * _fbm3d(_NoiseImproved_v3.x, _NoiseImproved_v3.y, _NoiseImproved_v3.z, octaves, ampMult, freqMult);
  }
}

// EXTERNAL MODULE: ../@polygonjs/polygonjs/node_modules/three/examples/jsm/math/SimplexNoise.js
var SimplexNoise = __webpack_require__(27550);
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/functions/_NoiseSimplex.ts





const _v2 = new three_module.Vector2();
const _NoiseSimplex_v3 = new three_module.Vector3();
const _v4 = new three_module.Vector4();
const _simplexBySeed = /* @__PURE__ */ new Map();
function _getOrCreateSimplex(seed) {
  let simplex = _simplexBySeed.get(seed);
  if (!simplex) {
    const random_generator = {
      random: function() {
        return (0,_Module/* randFloat */.Qy)(seed);
      }
    };
    simplex = new SimplexNoise/* SimplexNoise */.L(random_generator);
    _simplexBySeed.set(seed, simplex);
  }
  return simplex;
}
function _fbm2d(simplex, x, y, octaves, ampMult, freqMult) {
  let value = 0;
  let amplitude = 1;
  for (let i = 0; i < octaves; i++) {
    value += amplitude * simplex.noise(x, y);
    x *= freqMult;
    y *= freqMult;
    amplitude *= ampMult;
  }
  return value;
}
function _NoiseSimplex_fbm3d(simplex, x, y, z, octaves, ampMult, freqMult) {
  let value = 0;
  let amplitude = 1;
  for (let i = 0; i < octaves; i++) {
    value += amplitude * simplex.noise3d(x, y, z);
    x *= freqMult;
    y *= freqMult;
    z *= freqMult;
    amplitude *= ampMult;
  }
  return value;
}
function _fbm4d(simplex, x, y, z, w, octaves, ampMult, freqMult) {
  let value = 0;
  let amplitude = 1;
  for (let i = 0; i < octaves; i++) {
    value += amplitude * simplex.noise4d(x, y, z, w);
    x *= freqMult;
    y *= freqMult;
    z *= freqMult;
    w *= freqMult;
    amplitude *= ampMult;
  }
  return value;
}
class noiseSimplexVector2 extends functions_Base/* NamedFunction8 */.hx {
  static type() {
    return "noiseSimplexVector2";
  }
  func(position, amp, freq, offset, octaves, ampMult, freqMult, seed) {
    const simplex = _getOrCreateSimplex(seed);
    _v2.copy(position).add(offset).multiply(freq);
    return amp * _fbm2d(simplex, _v2.x, _v2.y, octaves, ampMult, freqMult);
  }
}
class noiseSimplexVector3 extends functions_Base/* NamedFunction8 */.hx {
  static type() {
    return "noiseSimplexVector3";
  }
  func(position, amp, freq, offset, octaves, ampMult, freqMult, seed) {
    const simplex = _getOrCreateSimplex(seed);
    _NoiseSimplex_v3.copy(position).add(offset).multiply(freq);
    return amp * _NoiseSimplex_fbm3d(simplex, _NoiseSimplex_v3.x, _NoiseSimplex_v3.y, _NoiseSimplex_v3.z, octaves, ampMult, freqMult);
  }
}
class noiseSimplexVector4 extends functions_Base/* NamedFunction8 */.hx {
  static type() {
    return "noiseSimplexVector4";
  }
  func(position, amp, freq, offset, octaves, ampMult, freqMult, seed) {
    const simplex = _getOrCreateSimplex(seed);
    _v4.copy(position).add(offset).multiply(freq);
    return amp * _fbm4d(simplex, _v4.x, _v4.y, _v4.z, _v4.w, octaves, ampMult, freqMult);
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/functions/_VectorNormalize.ts


class normalizeVector2 extends functions_Base/* NamedFunction2 */.CE {
  static type() {
    return "normalizeVector2";
  }
  func(src, target) {
    return target.copy(src).normalize();
  }
}
class normalizeVector3 extends functions_Base/* NamedFunction2 */.CE {
  static type() {
    return "normalizeVector3";
  }
  func(src, target) {
    return target.copy(src).normalize();
  }
}
class normalizeVector4 extends functions_Base/* NamedFunction2 */.CE {
  static type() {
    return "normalizeVector4";
  }
  func(src, target) {
    return target.copy(src).normalize();
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/functions/_SetObjectProperty.ts



class setObjectCastShadow extends functions_Base/* ObjectNamedFunction1 */.c_ {
  static type() {
    return "setObjectCastShadow";
  }
  func(object3D, castShadow) {
    object3D.castShadow = castShadow;
    (0,ObjectPropertyReactivity/* touchObjectProperty */.Jd)(object3D, ObjectPropertyReactivity/* GetObjectPropertyJsNodeInputName.castShadow */.De.castShadow);
  }
}
class setObjectReceiveShadow extends functions_Base/* ObjectNamedFunction1 */.c_ {
  static type() {
    return "setObjectReceiveShadow";
  }
  func(object3D, receiveShadow) {
    object3D.receiveShadow = receiveShadow;
    (0,ObjectPropertyReactivity/* touchObjectProperty */.Jd)(object3D, ObjectPropertyReactivity/* GetObjectPropertyJsNodeInputName.receiveShadow */.De.receiveShadow);
  }
}
class setObjectFrustumCulled extends functions_Base/* ObjectNamedFunction1 */.c_ {
  static type() {
    return "setObjectFrustumCulled";
  }
  func(object3D, frustumCulled) {
    object3D.frustumCulled = frustumCulled;
    (0,ObjectPropertyReactivity/* touchObjectProperty */.Jd)(object3D, "frustumCulled");
  }
}
class setObjectMatrix extends functions_Base/* ObjectNamedFunction1 */.c_ {
  static type() {
    return "setObjectMatrix";
  }
  func(object3D, matrix) {
    object3D.matrix.copy(matrix);
    object3D.matrix.decompose(object3D.position, object3D.quaternion, object3D.scale);
    (0,ObjectPropertyReactivity/* touchObjectProperty */.Jd)(object3D, ObjectPropertyReactivity/* GetObjectPropertyJsNodeInputName.matrix */.De.matrix);
  }
}
class setObjectMatrixAutoUpdate extends functions_Base/* ObjectNamedFunction1 */.c_ {
  static type() {
    return "setObjectMatrixAutoUpdate";
  }
  func(object3D, matrixAutoUpdate) {
    object3D.matrixAutoUpdate = matrixAutoUpdate;
    (0,ObjectPropertyReactivity/* touchObjectProperty */.Jd)(object3D, ObjectPropertyReactivity/* GetObjectPropertyJsNodeInputName.matrixAutoUpdate */.De.matrixAutoUpdate);
  }
}
class setObjectVisible extends functions_Base/* ObjectNamedFunction1 */.c_ {
  static type() {
    return "setObjectVisible";
  }
  func(object3D, visible) {
    object3D.visible = visible;
    (0,ObjectPropertyReactivity/* touchObjectProperty */.Jd)(object3D, ObjectPropertyReactivity/* GetObjectPropertyJsNodeInputName.visible */.De.visible);
  }
}
class objectUpdateMatrix extends functions_Base/* ObjectNamedFunction0 */.jY {
  static type() {
    return "objectUpdateMatrix";
  }
  func(object3D) {
    object3D.updateMatrix();
    (0,ObjectPropertyReactivity/* touchObjectProperty */.Jd)(object3D, ObjectPropertyReactivity/* GetObjectPropertyJsNodeInputName.matrix */.De.matrix);
  }
}
class objectUpdateWorldMatrix extends functions_Base/* ObjectNamedFunction2 */.YS {
  static type() {
    return "objectUpdateWorldMatrix";
  }
  func(object3D, updateParents, updateChildren) {
    object3D.updateWorldMatrix(updateParents, updateChildren);
    (0,ObjectPropertyReactivity/* touchObjectProperty */.Jd)(object3D, ObjectPropertyReactivity/* GetObjectPropertyJsNodeInputName.matrix */.De.matrix);
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/functions/_Viewer.ts



class setViewer extends functions_Base/* NamedFunction2 */.CE {
  static type() {
    return "setViewer";
  }
  func(className, addClass) {
    const viewer = this.scene.viewersRegister.firstViewer();
    const canvas = viewer == null ? void 0 : viewer.canvas();
    if (!canvas) {
      return;
    }
    if (viewer) {
      if (addClass) {
        canvas.classList.add(className);
      } else {
        canvas.classList.remove(className);
      }
    }
  }
}
class setViewerControls extends functions_Base/* NamedFunction3 */.Dv {
  static type() {
    return "setViewerControls";
  }
  func(active, updateTarget, controlsTarget) {
    const viewer = this.scene.viewersRegister.firstViewer();
    if (!viewer) {
      return;
    }
    const controlsController = viewer.controlsController();
    controlsController.setActive(active);
    if (updateTarget) {
      controlsController.setTarget(controlsTarget);
    }
  }
}
class onViewerControlsEvent extends functions_Base/* NamedFunction2 */.CE {
  static type() {
    return "onViewerControlsEvent";
  }
  func(callbacks, evaluator) {
    const viewer = this.scene.viewersRegister.firstViewer();
    if (!viewer) {
      return;
    }
    for (const eventName of ViewerControlsController/* CAMERA_CONTROLS_EVENTS */.tB) {
      viewer.controlsController().addEventListener(ViewerControlsController/* CameraControlsEvent */.ZI[eventName], callbacks[eventName]);
    }
    evaluator.onDispose(() => {
      for (const eventName of ViewerControlsController/* CAMERA_CONTROLS_EVENTS */.tB) {
        viewer.controlsController().removeEventListener(ViewerControlsController/* CameraControlsEvent */.ZI[eventName], callbacks[eventName]);
      }
    });
  }
}

// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/core/particles/CoreParticles.ts + 2 modules
var CoreParticles = __webpack_require__(37356);
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/functions/_ParticlesSystem.ts



class particlesSystemReset extends functions_Base/* ObjectNamedFunction0 */.jY {
  static type() {
    return "particlesSystemReset";
  }
  func(object3D) {
    (0,CoreParticles/* resetParticles */.H4)(object3D);
  }
}
class particlesSystemStepSimulation extends functions_Base/* ObjectNamedFunction1 */.c_ {
  static type() {
    return "particlesSystemStepSimulation";
  }
  func(object3D, configRef) {
    (0,CoreParticles/* stepParticles */.Qb)(object3D, this.timeController.delta(), configRef);
  }
}

// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/core/animation/PropertyTarget.ts
var PropertyTarget = __webpack_require__(42450);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/core/thirdParty/gsap/gsapFactory.ts
var gsapFactory = __webpack_require__(73436);
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/functions/_Animation.ts

var _Animation_async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};




const EVENT_ANIMATION_STARTED = { type: "onAnimationStarted" };
const EVENT_ANIMATION_COMPLETED = { type: "onAnimationCompleted" };
class playAnimation extends functions_Base/* ObjectNamedFunction1 */.c_ {
  static type() {
    return "playAnimation";
  }
  func(object3D, nodePath) {
    return new Promise((resolve) => _Animation_async(this, null, function* () {
      const node = this.scene.node(nodePath);
      if (!node) {
        return;
      }
      if (node.context() != poly_NodeContext/* NodeContext.ANIM */.sy.ANIM) {
        return;
      }
      const container = yield node.compute();
      if (!container) {
        return;
      }
      const timelineBuilder = container.coreContent();
      if (!timelineBuilder) {
        return;
      }
      const timeline = (0,gsapFactory/* gsapTimeline */.B7)();
      if (!timeline) {
        return;
      }
      const propertyTarget = new PropertyTarget/* AnimPropertyTarget */.F(this.scene, { object: { list: [object3D] } });
      timelineBuilder.populate(timeline, { registerproperties: true, propertyTarget });
      timeline.vars.onStart = () => {
        object3D.dispatchEvent(EVENT_ANIMATION_STARTED);
      };
      timeline.vars.onComplete = () => {
        object3D.dispatchEvent(EVENT_ANIMATION_COMPLETED);
      };
    }));
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/functions/_Poly.ts



class playerMode extends functions_Base/* NamedFunction0 */.Fp {
  static type() {
    return "playerMode";
  }
  func() {
    return Poly/* Poly.playerMode */.L.playerMode();
  }
}

// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/core/physics/player/PhysicsPlayer.ts + 2 modules
var player_PhysicsPlayer = __webpack_require__(23117);
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/functions/_PlayerPhysics.ts



function _PlayerPhysics_createInputData() {
  return { forward: false, backward: false, left: false, right: false, run: false, jump: false };
}
function _PlayerPhysics_createComputeData() {
  return {
    speed: 1,
    runAllowed: false,
    runSpeedMult: 2,
    jumpAllowed: false,
    jumpStrength: 2,
    resetIfBelowThreshold: false,
    resetThreshold: -5
  };
}
const _PlayerPhysics_elementByObject3D = /* @__PURE__ */ new WeakMap();
function _PlayerPhysics_findOrCreateElement(object3D) {
  let element = _PlayerPhysics_elementByObject3D.get(object3D);
  if (element) {
    return element;
  }
  const player = (0,player_PhysicsPlayer/* findPhysicsPlayer */.jh)(object3D);
  if (!player) {
    return;
  }
  element = {
    player,
    inputData: _PlayerPhysics_createInputData(),
    computeData: _PlayerPhysics_createComputeData()
  };
  _PlayerPhysics_elementByObject3D.set(object3D, element);
  return element;
}
class playerPhysicsUpdate extends functions_Base/* ObjectNamedFunction1 */.c_ {
  static type() {
    return "playerPhysicsUpdate";
  }
  func(object3D, options) {
    const {
      speed,
      runAllowed,
      runSpeedMult,
      jumpAllowed,
      jumpStrength,
      resetIfBelowThreshold,
      resetThreshold,
      left,
      right,
      backward,
      forward,
      run,
      jump
    } = options;
    const element = _PlayerPhysics_findOrCreateElement(object3D);
    if (!element) {
      return;
    }
    const { player, inputData, computeData } = element;
    computeData.speed = speed;
    computeData.runAllowed = runAllowed;
    computeData.runSpeedMult = runSpeedMult;
    computeData.jumpAllowed = jumpAllowed;
    computeData.jumpStrength = jumpStrength;
    computeData.resetIfBelowThreshold = resetIfBelowThreshold;
    computeData.resetThreshold = resetThreshold;
    inputData.left = left;
    inputData.right = right;
    inputData.backward = backward;
    inputData.forward = forward;
    inputData.run = run;
    inputData.jump = jump;
    player.update(computeData, inputData, this.scene.timeController.delta());
  }
}

// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/core/PolarTransform.ts
var core_PolarTransform = __webpack_require__(45824);
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/functions/_PolarTransform.ts





const fullMatrix = new three_module.Matrix4();
const params = {
  center: new three_module.Vector3(),
  longitude: 0,
  latitude: 0,
  depth: 0
};
const PROPERTIES = [
  ObjectPropertyReactivity/* GetObjectPropertyJsNodeInputName.position */.De.position,
  ObjectPropertyReactivity/* GetObjectPropertyJsNodeInputName.quaternion */.De.quaternion,
  ObjectPropertyReactivity/* GetObjectPropertyJsNodeInputName.matrix */.De.matrix
];
class setObjectPolarTransform extends functions_Base/* ObjectNamedFunction4 */.eG {
  static type() {
    return "setObjectPolarTransform";
  }
  func(object3D, center, longitude, latitude, depth) {
    params.center.copy(center);
    params.longitude = longitude;
    params.latitude = latitude;
    params.depth = depth;
    core_PolarTransform/* CorePolarTransform.matrix */.i.matrix(params, fullMatrix);
    core_PolarTransform/* CorePolarTransform.applyMatrixToObject */.i.applyMatrixToObject(object3D, fullMatrix);
    (0,ObjectPropertyReactivity/* touchObjectProperties */.rP)(object3D, PROPERTIES);
  }
}
class polarTransform extends functions_Base/* NamedFunction5 */.t9 {
  static type() {
    return "polarTransform";
  }
  func(center, longitude, latitude, depth, target) {
    params.center.copy(center);
    params.longitude = longitude;
    params.latitude = latitude;
    params.depth = depth;
    core_PolarTransform/* CorePolarTransform.matrix */.i.matrix(params, target);
    return target;
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/functions/_PreviousValue.ts


const arrayByLengthByNodePath = /* @__PURE__ */ new Map();
function _getArray(nodePath, arrayLength, createElement) {
  let mapForNodePath = arrayByLengthByNodePath.get(nodePath);
  if (!mapForNodePath) {
    mapForNodePath = /* @__PURE__ */ new Map();
    arrayByLengthByNodePath.set(nodePath, mapForNodePath);
  }
  let array = mapForNodePath.get(arrayLength);
  if (!array) {
    array = new Array(arrayLength);
    for (let i = 0; i < arrayLength; i++) {
      array[i] = createElement();
    }
    mapForNodePath.set(arrayLength, array);
  }
  return array;
}
class previousValuePrimitive extends functions_Base/* NamedFunction3 */.Dv {
  static type() {
    return "previousValuePrimitive";
  }
  func(nodePath, offset, newValue) {
    const arrayLength = offset + 1;
    const array = _getArray(nodePath, arrayLength, () => newValue);
    for (let i = 0; i < arrayLength - 1; i++) {
      array[i] = array[i + 1];
    }
    array[arrayLength - 1] = newValue;
    return array[0];
  }
}
class previousValueColor extends functions_Base/* NamedFunction3 */.Dv {
  static type() {
    return "previousValueColor";
  }
  func(nodePath, offset, newValue) {
    const arrayLength = offset + 1;
    const array = _getArray(nodePath, arrayLength, () => newValue.clone());
    for (let i = 0; i < arrayLength - 1; i++) {
      array[i].copy(array[i + 1]);
    }
    array[arrayLength - 1].copy(newValue);
    return array[0];
  }
}
class previousValueVector2 extends functions_Base/* NamedFunction3 */.Dv {
  static type() {
    return "previousValueVector2";
  }
  func(nodePath, offset, newValue) {
    const arrayLength = offset + 1;
    const array = _getArray(nodePath, arrayLength, () => newValue.clone());
    for (let i = 0; i < arrayLength - 1; i++) {
      array[i].copy(array[i + 1]);
    }
    array[arrayLength - 1].copy(newValue);
    return array[0];
  }
}
class previousValueVector3 extends functions_Base/* NamedFunction3 */.Dv {
  static type() {
    return "previousValueVector3";
  }
  func(nodePath, offset, newValue) {
    const arrayLength = offset + 1;
    const array = _getArray(nodePath, arrayLength, () => newValue.clone());
    for (let i = 0; i < arrayLength - 1; i++) {
      array[i].copy(array[i + 1]);
    }
    array[arrayLength - 1].copy(newValue);
    return array[0];
  }
}
class previousValueVector4 extends functions_Base/* NamedFunction3 */.Dv {
  static type() {
    return "previousValueVector4";
  }
  func(nodePath, offset, newValue) {
    const arrayLength = offset + 1;
    const array = _getArray(nodePath, arrayLength, () => newValue.clone());
    for (let i = 0; i < arrayLength - 1; i++) {
      array[i].copy(array[i + 1]);
    }
    array[arrayLength - 1].copy(newValue);
    return array[0];
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/functions/_Neighbours.ts


class primitiveNeighboursCount extends functions_Base/* NamedFunction3 */.Dv {
  static type() {
    return "primitiveNeighboursCount";
  }
  func(graph, primitiveIndex, sharedEdgeOnly) {
    return graph.neighboursCount(primitiveIndex, sharedEdgeOnly);
  }
}
class primitiveNeighbourIndex extends functions_Base/* NamedFunction4 */.Vm {
  static type() {
    return "primitiveNeighbourIndex";
  }
  func(graph, primitiveIndex, neighbourIndex, sharedEdgeOnly) {
    return graph.neighbourIndex(primitiveIndex, neighbourIndex, sharedEdgeOnly);
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/functions/_Quaternion.ts


class quaternionSetFromEuler extends functions_Base/* NamedFunction2 */.CE {
  static type() {
    return "quaternionSetFromEuler";
  }
  func(euler, target) {
    target.setFromEuler(euler);
    return target;
  }
}
class quaternionSetFromAxisAngle extends functions_Base/* NamedFunction3 */.Dv {
  static type() {
    return "quaternionSetFromAxisAngle";
  }
  func(axis, angle, target) {
    target.setFromAxisAngle(axis, angle);
    return target;
  }
}
class quaternionAngleTo extends functions_Base/* NamedFunction2 */.CE {
  static type() {
    return "quaternionAngleTo";
  }
  func(src, to) {
    return src.angleTo(to);
  }
}
class quaternionSlerp extends functions_Base/* NamedFunction4 */.Vm {
  static type() {
    return "quaternionSlerp";
  }
  func(q1, q2, lerp, target) {
    target.copy(q1).slerp(q2, lerp);
    return target;
  }
}
class rotateWithAxisAngle extends functions_Base/* NamedFunction4 */.Vm {
  static type() {
    return "rotateWithAxisAngle";
  }
  func(vector, axis, angle, target) {
    return target.copy(vector).applyAxisAngle(axis, angle);
  }
}
class rotateWithQuaternion extends functions_Base/* NamedFunction3 */.Dv {
  static type() {
    return "rotateWithQuaternion";
  }
  func(vector, quat, target) {
    return target.copy(vector).applyQuaternion(quat);
  }
}

// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/functions/_VectorUtils.ts
var _VectorUtils = __webpack_require__(15938);
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/functions/_Sizzle.ts




function _sizzleVec2(src, target) {
  target.x = src.y;
  target.y = src.x;
  return target;
}
function _sizzleVec3XY(src, target) {
  target.x = src.x;
  target.y = src.y;
  return target;
}
class sizzleVec3XY extends functions_Base/* NamedFunction2 */.CE {
  constructor() {
    super(...arguments);
    this.func = _sizzleVec3XY;
  }
  static type() {
    return "sizzleVec3XY";
  }
}
function _sizzleVec3XZ(src, target) {
  target.x = src.x;
  target.y = src.z;
  return target;
}
class sizzleVec3XZ extends functions_Base/* NamedFunction2 */.CE {
  constructor() {
    super(...arguments);
    this.func = _sizzleVec3XZ;
  }
  static type() {
    return "sizzleVec3XZ";
  }
}
function _sizzleVec3YZ(src, target) {
  target.x = src.y;
  target.y = src.z;
  return target;
}
class sizzleVec3YZ extends functions_Base/* NamedFunction2 */.CE {
  constructor() {
    super(...arguments);
    this.func = _sizzleVec3YZ;
  }
  static type() {
    return "sizzleVec3YZ";
  }
}
class sizzleVec4XYZ extends functions_Base/* NamedFunction2 */.CE {
  static type() {
    return "sizzleVec4XYZ";
  }
  func(src, target) {
    target.x = src.x;
    target.y = src.y;
    target.z = src.z;
    return target;
  }
}
class sizzleVec4XYZArray extends functions_Base/* NamedFunction2 */.CE {
  static type() {
    return "sizzleVec4XYZArray";
  }
  func(src, target) {
    (0,_ArrayUtils/* _matchArrayLength */.X9)(src, target, () => new three_module.Vector3());
    let i = 0;
    for (let srcElement of src) {
      const targetElement = target[i];
      targetElement.x = srcElement.x;
      targetElement.y = srcElement.y;
      targetElement.z = srcElement.z;
      i++;
    }
    return target;
  }
}
class sizzleVec4WArray extends functions_Base/* NamedFunction2 */.CE {
  static type() {
    return "sizzleVec4WArray";
  }
  func(src, target) {
    (0,_ArrayUtils/* _matchArrayLength */.X9)(src, target, () => 0);
    let i = 0;
    for (let srcElement of src) {
      target[i] = srcElement.w;
      i++;
    }
    return target;
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/functions/_SDFPrimitives2D.ts





const _SDFPrimitives2D_q = new three_module.Vector2();
const _q2 = new three_module.Vector2();
const _b = new three_module.Vector2();
const _w = new three_module.Vector2();
class SDF2DBox extends functions_Base/* NamedFunction3 */.Dv {
  static type() {
    return "SDF2DBox";
  }
  func(p, center, size) {
    p.sub(center);
    (0,_VectorUtils/* absV2 */.Yh)(p, p);
    p.sub(size);
    return (0,_VectorUtils/* vector2MaxScalar */.jb)(p, 0, _q2).length() + Math.min(Math.max(p.x, p.y), 0);
  }
}
class SDF2DCircle extends functions_Base/* NamedFunction3 */.Dv {
  static type() {
    return "SDF2DCircle";
  }
  func(p, center, radius) {
    p.sub(center);
    return p.length() - radius;
  }
}
class SDF2DCross extends functions_Base/* NamedFunction5 */.t9 {
  static type() {
    return "SDF2DCross";
  }
  func(p, center, length, width, radius) {
    p.sub(center);
    (0,_VectorUtils/* absV2 */.Yh)(p, p);
    if (p.y > p.x) {
      _sizzleVec2(p, _q2);
      p.copy(_q2);
    }
    _b.x = length;
    _b.y = width;
    _SDFPrimitives2D_q.copy(p).sub(_b);
    const k = Math.max(_SDFPrimitives2D_q.y, _SDFPrimitives2D_q.x);
    if (k > 0) {
      _w.copy(_SDFPrimitives2D_q);
    } else {
      _w.x = _b.y - p.x;
      _w.y = -k;
    }
    return Math.sign(k) * (0,_VectorUtils/* vector2MaxScalar */.jb)(_w, 0, _w).length() + radius;
  }
}
const SQRT_2_BY_4 = Math.sqrt(2) / 4;
class SDF2DHeart extends functions_Base/* NamedFunction2 */.CE {
  static type() {
    return "SDF2DHeart";
  }
  func(p, center) {
    p.sub(center);
    p.x = Math.abs(p.x);
    if (p.y + p.x > 1) {
      _q2.set(0.25, 0.75);
      return Math.sqrt((0,_VectorUtils/* vector2Dot */.c2)(p.sub(_q2))) - SQRT_2_BY_4;
    }
    _q2.set(0.25, 0.75);
    const a = (0,_VectorUtils/* vector2Dot */.c2)(p.sub(_q2));
    const b = (0,_VectorUtils/* vector2Dot */.c2)(p.subScalar(0.5 * Math.max(p.x + p.y, 0)));
    const c = Math.sqrt(Math.min(a, b));
    const d = Math.sign(p.x - p.y);
    return c * d;
  }
}
class SDF2DRoundedX extends functions_Base/* NamedFunction4 */.Vm {
  static type() {
    return "SDF2DRoundedX";
  }
  func(p, center, w, r) {
    p.sub(center);
    (0,_VectorUtils/* absV2 */.Yh)(p, _SDFPrimitives2D_q);
    const min = Math.min(_SDFPrimitives2D_q.x + _SDFPrimitives2D_q.y, w) * 0.5;
    _SDFPrimitives2D_q.subScalar(min);
    return _SDFPrimitives2D_q.length() - r;
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/functions/_SDFPrimitives.ts




const _SDFPrimitives_q = new three_module.Vector3();
const _SDFPrimitives_v2 = new three_module.Vector2();
const _sHalf = new three_module.Vector3();
function _SDFBox(p, center, sizes, size) {
  _sHalf.copy(sizes).multiplyScalar(size * 0.5);
  (0,_VectorUtils/* absV3 */.$x)(p.sub(center), _SDFPrimitives_q);
  _SDFPrimitives_q.sub(_sHalf);
  const max = Math.min(0, (0,_VectorUtils/* maxV3Components */.Nq)(_SDFPrimitives_q));
  (0,_VectorUtils/* maxV3Component */.$1)(_SDFPrimitives_q, _SDFPrimitives_q, 0);
  const length = _SDFPrimitives_q.length();
  return length + max;
}
class SDFBox extends functions_Base/* NamedFunction4 */.Vm {
  constructor() {
    super(...arguments);
    this.func = _SDFBox;
  }
  static type() {
    return "SDFBox";
  }
}
function _SDFPlane(p, center, normal, offset) {
  _SDFPrimitives_q.copy(normal).normalize();
  return p.sub(center).dot(_SDFPrimitives_q) + offset;
}
class SDFPlane extends functions_Base/* NamedFunction4 */.Vm {
  constructor() {
    super(...arguments);
    this.func = _SDFPlane;
  }
  static type() {
    return "SDFPlane";
  }
}
function _SDFSphere(p, center, s) {
  return p.sub(center).length() - s;
}
class SDFSphere extends functions_Base/* NamedFunction3 */.Dv {
  constructor() {
    super(...arguments);
    this.func = _SDFSphere;
  }
  static type() {
    return "SDFSphere";
  }
}
function _SDFTorus(p, center, radius1, radius2) {
  p.sub(center);
  _SDFPrimitives_v2.x = p.x;
  _SDFPrimitives_v2.y = p.z;
  _SDFPrimitives_q.x = _SDFPrimitives_v2.length() - radius1;
  _SDFPrimitives_q.y = p.y;
  return _SDFPrimitives_q.length() - radius2;
}
class SDFTorus extends functions_Base/* NamedFunction4 */.Vm {
  constructor() {
    super(...arguments);
    this.func = _SDFTorus;
  }
  static type() {
    return "SDFTorus";
  }
}
function _SDFTube(p, center, radius) {
  p.sub(center);
  _SDFPrimitives_q.x = p.x;
  _SDFPrimitives_q.y = p.z;
  return _SDFPrimitives_q.length() - radius;
}
class SDFTube extends functions_Base/* NamedFunction3 */.Dv {
  constructor() {
    super(...arguments);
    this.func = _SDFTube;
  }
  static type() {
    return "SDFTube";
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/functions/_SDFOperations.ts





const _SDFOperations_v3a = new three_module.Vector3();
const _SDFOperations_v3b = new three_module.Vector3();
const _SDFOperations_euler = new three_module.Euler();
const _SDFOperations_quaternion = new three_module.Quaternion();
const _SDFOperations_s = new three_module.Vector3(1, 1, 1);
const _SDFOperations_m4 = new three_module.Matrix4();
const ROTATION_ORDER = "XYZ";
class SDFUnion extends functions_Base/* NamedFunction2 */.CE {
  static type() {
    return "SDFUnion";
  }
  func(d1, d2) {
    return Math.min(d1, d2);
  }
}
class SDFSubtract extends functions_Base/* NamedFunction2 */.CE {
  static type() {
    return "SDFSubtract";
  }
  func(d1, d2) {
    return Math.max(-d1, d2);
  }
}
class SDFIntersect extends functions_Base/* NamedFunction2 */.CE {
  static type() {
    return "SDFIntersect";
  }
  func(d1, d2) {
    return Math.max(d1, d2);
  }
}
class SDFSmoothUnion extends functions_Base/* NamedFunction3 */.Dv {
  static type() {
    return "SDFSmoothUnion";
  }
  func(d1, d2, k) {
    const h = _Module/* CoreMath.clamp */.Gj.clamp(0.5 + 0.5 * (d2 - d1) / k, 0, 1);
    return _Module/* CoreMath.mix */.Gj.mix(d2, d1, h) - k * h * (1 - h);
  }
}
class SDFSmoothSubtract extends functions_Base/* NamedFunction3 */.Dv {
  static type() {
    return "SDFSmoothSubtract";
  }
  func(d1, d2, k) {
    const h = _Module/* CoreMath.clamp */.Gj.clamp(0.5 - 0.5 * (d2 + d1) / k, 0, 1);
    return _Module/* CoreMath.mix */.Gj.mix(d2, -d1, h) + k * h * (1 - h);
  }
}
class SDFSmoothIntersect extends functions_Base/* NamedFunction3 */.Dv {
  static type() {
    return "SDFSmoothIntersect";
  }
  func(d1, d2, k) {
    const h = _Module/* CoreMath.clamp */.Gj.clamp(0.5 - 0.5 * (d2 - d1) / k, 0, 1);
    return _Module/* CoreMath.mix */.Gj.mix(d2, d1, h) + k * h * (1 - h);
  }
}
class SDFElongateFast extends functions_Base/* NamedFunction4 */.Vm {
  static type() {
    return "SDFElongateFast";
  }
  func(p, center, h, target) {
    p.sub(center);
    (0,_VectorUtils/* vector3Clamp */.eM)(p, _SDFOperations_v3b.copy(h).multiplyScalar(-1), h, _SDFOperations_v3a);
    target.copy(p).sub(_SDFOperations_v3a);
    return target;
  }
}
class SDFElongateSlow extends functions_Base/* NamedFunction4 */.Vm {
  static type() {
    return "SDFElongateSlow";
  }
  func(p, center, h, target) {
    p.sub(center);
    (0,_VectorUtils/* absV3 */.$x)(p, target).sub(h);
    (0,_VectorUtils/* maxV3Component */.$1)(target, target, 0);
    return target;
  }
}
class SDFOnion extends functions_Base/* NamedFunction2 */.CE {
  static type() {
    return "SDFOnion";
  }
  func(sdf, thickness) {
    return Math.abs(sdf) - thickness;
  }
}
class SDFTransform extends functions_Base/* NamedFunction4 */.Vm {
  static type() {
    return "SDFTransform";
  }
  func(p, t, r, target) {
    _SDFOperations_euler.set(r.x, r.y, r.z, ROTATION_ORDER);
    _SDFOperations_quaternion.setFromEuler(_SDFOperations_euler);
    _SDFOperations_m4.compose(t, _SDFOperations_quaternion, _SDFOperations_s);
    _SDFOperations_m4.invert();
    target.copy(p).applyMatrix4(_SDFOperations_m4);
    return target;
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/functions/_SDFOperations2D.ts




const _sizzle2 = new three_module.Vector2();
class SDFRevolutionX extends functions_Base/* NamedFunction4 */.Vm {
  static type() {
    return "SDFRevolutionX";
  }
  func(p, center, o, target) {
    p.sub(center);
    _sizzleVec3YZ(p, _sizzle2);
    const l = _sizzle2.length();
    target.x = l - o;
    target.y = p.x;
    return target;
  }
}
class SDFRevolutionY extends functions_Base/* NamedFunction4 */.Vm {
  static type() {
    return "SDFRevolutionY";
  }
  func(p, center, o, target) {
    p.sub(center);
    _sizzleVec3XZ(p, _sizzle2);
    const l = _sizzle2.length();
    target.x = l - o;
    target.y = p.y;
    return target;
  }
}
class SDFRevolutionZ extends functions_Base/* NamedFunction4 */.Vm {
  static type() {
    return "SDFRevolutionZ";
  }
  func(p, center, o, target) {
    p.sub(center);
    _sizzleVec3XY(p, _sizzle2);
    const l = _sizzle2.length();
    target.x = l - o;
    target.y = p.z;
    return target;
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/functions/_CSSObject.ts


class setCSSObjectClass extends functions_Base/* ObjectNamedFunction2 */.YS {
  static type() {
    return "setCSSObjectClass";
  }
  func(CSSObject, className, addRemove) {
    if (addRemove == true) {
      CSSObject.element.classList.add(className);
    } else {
      CSSObject.element.classList.remove(className);
    }
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/functions/_Instance.ts





const _Instance_tmpV2 = new three_module.Vector2();
const _Instance_tmpV3 = new three_module.Vector3();
const _Instance_tmpV4 = new three_module.Vector4();
const tmpQuat = new three_module.Quaternion();
const _Instance_tmpColor = new three_module.Color();
const nextV2 = new three_module.Vector2();
const _Instance_nextV3 = new three_module.Vector3();
const nextV4 = new three_module.Vector4();
const nextColor = new three_module.Color();
const nextQuat = new three_module.Quaternion();
const STRIDE2 = 2;
const STRIDE3 = 3;
const STRIDE4 = 4;
function _setGeometryInstancePositions(frame, geometry, newValues, lerp, attributeNeedsUpdate) {
  const instancePositionAttribute = geometry.getAttribute(Instancer/* InstanceAttrib.POSITION */.R.POSITION);
  if (!instancePositionAttribute) {
    return;
  }
  const doLerp = lerp < 1;
  const instancePositionArray = instancePositionAttribute.array;
  let i = 0;
  for (let value of newValues) {
    if (doLerp) {
      _Instance_nextV3.copy(value);
      _Instance_tmpV3.fromArray(instancePositionArray, i * STRIDE3);
      _Instance_tmpV3.lerp(_Instance_nextV3, lerp);
    } else {
      _Instance_tmpV3.copy(value);
    }
    _Instance_tmpV3.toArray(instancePositionArray, i * STRIDE3);
    i++;
  }
  if (attributeNeedsUpdate) {
    (0,geometry_Attribute/* markAttributeAsNeedsUpdateForFrame */.X3)(instancePositionAttribute, frame);
  }
}
function _setGeometryInstanceQuaternions(frame, geometry, newValues, lerp, attributeNeedsUpdate) {
  const instanceQuaternionAttribute = geometry.getAttribute(Instancer/* InstanceAttrib.QUATERNION */.R.QUATERNION);
  if (!instanceQuaternionAttribute) {
    return;
  }
  const doLerp = lerp < 1;
  const instanceQuaternionArray = instanceQuaternionAttribute.array;
  let i = 0;
  for (let value of newValues) {
    if (doLerp) {
      nextQuat.copy(value);
      tmpQuat.fromArray(instanceQuaternionArray, i * STRIDE4);
      tmpQuat.slerp(nextQuat, lerp);
    } else {
      tmpQuat.copy(value);
    }
    tmpQuat.toArray(instanceQuaternionArray, i * STRIDE4);
    i++;
  }
  if (attributeNeedsUpdate) {
    (0,geometry_Attribute/* markAttributeAsNeedsUpdateForFrame */.X3)(instanceQuaternionAttribute, frame);
  }
}
function _setGeometryInstanceScales(frame, geometry, scaleValues, multValues, lerp, attributeNeedsUpdate) {
  const instanceScaleAttribute = geometry.getAttribute(Instancer/* InstanceAttrib.SCALE */.R.SCALE);
  if (!instanceScaleAttribute) {
    return;
  }
  const doLerp = lerp < 1;
  const instanceScaleArray = instanceScaleAttribute.array;
  let i = 0;
  if (scaleValues && multValues) {
    const minCount = Math.min(scaleValues.length, multValues.length);
    for (let i2 = 0; i2 < minCount; i2++) {
      const scaleValue = scaleValues[i2];
      const multValue = multValues[i2];
      if (doLerp) {
        _Instance_nextV3.copy(scaleValue).multiplyScalar(multValue);
        _Instance_tmpV3.fromArray(instanceScaleArray, i2 * STRIDE3);
        _Instance_tmpV3.lerp(_Instance_nextV3, lerp);
      } else {
        _Instance_tmpV3.copy(scaleValue).multiplyScalar(multValue);
      }
      _Instance_tmpV3.toArray(instanceScaleArray, i2 * STRIDE3);
    }
  } else {
    if (scaleValues) {
      for (let value of scaleValues) {
        if (doLerp) {
          _Instance_nextV3.copy(value);
          _Instance_tmpV3.fromArray(instanceScaleArray, i * STRIDE3);
          _Instance_tmpV3.lerp(_Instance_nextV3, lerp);
        } else {
          _Instance_tmpV3.copy(value);
        }
        _Instance_tmpV3.toArray(instanceScaleArray, i * STRIDE3);
        i++;
      }
    } else if (multValues) {
      for (let value of multValues) {
        if (doLerp) {
          _Instance_nextV3.set(value, value, value);
          _Instance_tmpV3.fromArray(instanceScaleArray, i * STRIDE3);
          _Instance_tmpV3.lerp(_Instance_nextV3, lerp);
        } else {
          _Instance_tmpV3.set(value, value, value);
        }
        _Instance_tmpV3.toArray(instanceScaleArray, i * STRIDE3);
        i++;
      }
    }
  }
  if (attributeNeedsUpdate) {
    (0,geometry_Attribute/* markAttributeAsNeedsUpdateForFrame */.X3)(instanceScaleAttribute, frame);
  }
}
class setGeometryInstancePositions extends functions_Base/* ObjectNamedFunction3 */.uW {
  static type() {
    return "setGeometryInstancePositions";
  }
  func(object3D, newValues, lerp, attributeNeedsUpdate) {
    const geometry = object3D.geometry;
    if (!geometry) {
      return;
    }
    _setGeometryInstancePositions(this.timeController.frame(), geometry, newValues, lerp, attributeNeedsUpdate);
  }
}
class setGeometryInstanceQuaternions extends functions_Base/* ObjectNamedFunction3 */.uW {
  static type() {
    return "setGeometryInstanceQuaternions";
  }
  func(object3D, newValues, lerp, attributeNeedsUpdate) {
    const geometry = object3D.geometry;
    if (!geometry) {
      return;
    }
    _setGeometryInstanceQuaternions(this.timeController.frame(), geometry, newValues, lerp, attributeNeedsUpdate);
  }
}
class setGeometryInstanceScales extends functions_Base/* ObjectNamedFunction4 */.eG {
  static type() {
    return "setGeometryInstanceScales";
  }
  func(object3D, scaleValues, multValues, lerp, attributeNeedsUpdate) {
    const geometry = object3D.geometry;
    if (!geometry) {
      return;
    }
    _setGeometryInstanceScales(
      this.timeController.frame(),
      geometry,
      scaleValues,
      multValues,
      lerp,
      attributeNeedsUpdate
    );
  }
}
class setGeometryInstanceTransforms extends functions_Base/* ObjectNamedFunction6 */.LX {
  static type() {
    return "setGeometryInstanceTransforms";
  }
  func(object3D, positions, quaternions, scaleValues, multValues, lerp, attributeNeedsUpdate) {
    const geometry = object3D.geometry;
    if (!geometry) {
      return;
    }
    _setGeometryInstancePositions(this.timeController.frame(), geometry, positions, lerp, attributeNeedsUpdate);
    _setGeometryInstanceQuaternions(this.timeController.frame(), geometry, quaternions, lerp, attributeNeedsUpdate);
    _setGeometryInstanceScales(
      this.timeController.frame(),
      geometry,
      scaleValues,
      multValues,
      lerp,
      attributeNeedsUpdate
    );
  }
}
class setGeometryInstanceAttributeFloat extends functions_Base/* ObjectNamedFunction4 */.eG {
  static type() {
    return "setGeometryInstanceAttributeFloat";
  }
  func(object3D, attribName, newValues, lerp, attributeNeedsUpdate) {
    const geometry = object3D.geometry;
    if (!geometry) {
      return;
    }
    const instanceAttribute = geometry.getAttribute(attribName);
    if (!instanceAttribute) {
      return;
    }
    const doLerp = lerp < 1;
    const instanceAttributeArray = instanceAttribute.array;
    let i = 0;
    for (let value of newValues) {
      if (doLerp) {
        const currentValue = instanceAttributeArray[i];
        instanceAttributeArray[i] = lerp * value + (1 - lerp) * currentValue;
      } else {
        instanceAttributeArray[i] = value;
      }
      i++;
    }
    if (attributeNeedsUpdate) {
      (0,geometry_Attribute/* markAttributeAsNeedsUpdateForFrame */.X3)(instanceAttribute, this.timeController.frame());
    }
  }
}
class setGeometryInstanceAttributeColor extends functions_Base/* ObjectNamedFunction4 */.eG {
  static type() {
    return "setGeometryInstanceAttributeColor";
  }
  func(object3D, attribName, newValues, lerp, attributeNeedsUpdate) {
    const geometry = object3D.geometry;
    if (!geometry) {
      return;
    }
    const instanceAttribute = geometry.getAttribute(attribName);
    if (!instanceAttribute) {
      return;
    }
    const doLerp = lerp < 1;
    const instanceAttributeArray = instanceAttribute.array;
    let i = 0;
    for (let value of newValues) {
      if (doLerp) {
        nextColor.copy(value);
        _Instance_tmpColor.fromArray(instanceAttributeArray, i * STRIDE3);
        _Instance_tmpColor.lerp(nextColor, lerp);
      } else {
        _Instance_tmpColor.copy(value);
      }
      _Instance_tmpColor.toArray(instanceAttributeArray, i * STRIDE3);
      i++;
    }
    if (attributeNeedsUpdate) {
      (0,geometry_Attribute/* markAttributeAsNeedsUpdateForFrame */.X3)(instanceAttribute, this.timeController.frame());
    }
  }
}
class setGeometryInstanceAttributeQuaternion extends functions_Base/* ObjectNamedFunction4 */.eG {
  static type() {
    return "setGeometryInstanceAttributeQuaternion";
  }
  func(object3D, attribName, newValues, lerp, attributeNeedsUpdate) {
    const geometry = object3D.geometry;
    if (!geometry) {
      return;
    }
    const instanceAttribute = geometry.getAttribute(attribName);
    if (!instanceAttribute) {
      return;
    }
    const doLerp = lerp < 1;
    const instanceAttributeArray = instanceAttribute.array;
    let i = 0;
    for (let value of newValues) {
      if (doLerp) {
        nextQuat.copy(value);
        tmpQuat.fromArray(instanceAttributeArray, i * STRIDE4);
        tmpQuat.slerp(nextQuat, lerp);
      } else {
        tmpQuat.copy(value);
      }
      tmpQuat.toArray(instanceAttributeArray, i * STRIDE4);
      i++;
    }
    if (attributeNeedsUpdate) {
      (0,geometry_Attribute/* markAttributeAsNeedsUpdateForFrame */.X3)(instanceAttribute, this.timeController.frame());
    }
  }
}
class setGeometryInstanceAttributeVector2 extends functions_Base/* ObjectNamedFunction4 */.eG {
  static type() {
    return "setGeometryInstanceAttributeVector2";
  }
  func(object3D, attribName, newValues, lerp, attributeNeedsUpdate) {
    const geometry = object3D.geometry;
    if (!geometry) {
      return;
    }
    const instanceAttribute = geometry.getAttribute(attribName);
    if (!instanceAttribute) {
      return;
    }
    const doLerp = lerp < 1;
    const instanceAttributeArray = instanceAttribute.array;
    let i = 0;
    for (let value of newValues) {
      if (doLerp) {
        nextV2.copy(value);
        _Instance_tmpV2.fromArray(instanceAttributeArray, i * STRIDE2);
        _Instance_tmpV2.lerp(nextV2, lerp);
      } else {
        _Instance_tmpV2.copy(value);
      }
      _Instance_tmpV2.toArray(instanceAttributeArray, i * STRIDE2);
      i++;
    }
    if (attributeNeedsUpdate) {
      (0,geometry_Attribute/* markAttributeAsNeedsUpdateForFrame */.X3)(instanceAttribute, this.timeController.frame());
    }
  }
}
class setGeometryInstanceAttributeVector3 extends functions_Base/* ObjectNamedFunction4 */.eG {
  static type() {
    return "setGeometryInstanceAttributeVector3";
  }
  func(object3D, attribName, newValues, lerp, attributeNeedsUpdate) {
    const geometry = object3D.geometry;
    if (!geometry) {
      return;
    }
    const instanceAttribute = geometry.getAttribute(attribName);
    if (!instanceAttribute) {
      return;
    }
    const doLerp = lerp < 1;
    const instanceAttributeArray = instanceAttribute.array;
    let i = 0;
    for (let value of newValues) {
      if (doLerp) {
        _Instance_nextV3.copy(value);
        _Instance_tmpV3.fromArray(instanceAttributeArray, i * STRIDE3);
        _Instance_tmpV3.lerp(_Instance_nextV3, lerp);
      } else {
        _Instance_tmpV3.copy(value);
      }
      _Instance_tmpV3.toArray(instanceAttributeArray, i * STRIDE3);
      i++;
    }
    if (attributeNeedsUpdate) {
      (0,geometry_Attribute/* markAttributeAsNeedsUpdateForFrame */.X3)(instanceAttribute, this.timeController.frame());
    }
  }
}
class setGeometryInstanceAttributeVector4 extends functions_Base/* ObjectNamedFunction4 */.eG {
  static type() {
    return "setGeometryInstanceAttributeVector4";
  }
  func(object3D, attribName, newValues, lerp, attributeNeedsUpdate) {
    const geometry = object3D.geometry;
    if (!geometry) {
      return;
    }
    const instanceAttribute = geometry.getAttribute(attribName);
    if (!instanceAttribute) {
      return;
    }
    const doLerp = lerp < 1;
    const instanceAttributeArray = instanceAttribute.array;
    let i = 0;
    for (let value of newValues) {
      if (doLerp) {
        nextV4.copy(value);
        _Instance_tmpV4.fromArray(instanceAttributeArray, i * STRIDE4);
        _Instance_tmpV4.lerp(nextV4, lerp);
      } else {
        _Instance_tmpV4.copy(value);
      }
      _Instance_tmpV3.toArray(instanceAttributeArray, i * STRIDE4);
      i++;
    }
    if (attributeNeedsUpdate) {
      (0,geometry_Attribute/* markAttributeAsNeedsUpdateForFrame */.X3)(instanceAttribute, this.timeController.frame());
    }
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/functions/_Material.ts





function _setMaterialColor(material, targetColor, lerp) {
  const color = material.color;
  if (!color) {
    return;
  }
  if (lerp >= 1) {
    color.copy(targetColor);
  } else {
    color.lerp(targetColor, lerp);
  }
}
function _setMaterialEmissiveColor(material, targetColor, lerp) {
  const color = material.emissive;
  if (!color) {
    return;
  }
  if (lerp >= 1) {
    color.copy(targetColor);
  } else {
    color.lerp(targetColor, lerp);
  }
}
function _addParamUniformNamePrefix(uniformName, addPrefix) {
  return addPrefix ? `${uniform/* UNIFORM_PARAM_PREFIX */.l}${uniformName}` : uniformName;
}
function _addTextureUniformNamePrefix(uniformName, addPrefix) {
  return addPrefix ? `${uniform/* UNIFORM_TEXTURE_PREFIX */.f}${uniformName}` : uniformName;
}
class setObjectMaterial extends functions_Base/* ObjectNamedFunction1 */.c_ {
  static type() {
    return "setObjectMaterial";
  }
  func(object3D, material) {
    object3D.material = material;
  }
}
class setObjectMaterialColor extends functions_Base/* ObjectNamedFunction2 */.YS {
  static type() {
    return "setObjectMaterialColor";
  }
  func(object3D, color, lerp) {
    const material = object3D.material;
    if (Type/* CoreType.isArray */.MR.isArray(material)) {
      for (let mat of material) {
        _setMaterialColor(mat, color, lerp);
      }
    } else {
      _setMaterialColor(material, color, lerp);
    }
  }
}
class setMaterialColor extends functions_Base/* NamedFunction3 */.Dv {
  static type() {
    return "setMaterialColor";
  }
  func(material, color, lerp) {
    _setMaterialColor(material, color, lerp);
  }
}
class setMaterialEmissiveColor extends functions_Base/* NamedFunction3 */.Dv {
  static type() {
    return "setMaterialEmissiveColor";
  }
  func(material, color, lerp) {
    _setMaterialEmissiveColor(material, color, lerp);
  }
}
function setMaterialTextureFactory(options) {
  const { type, mapName } = options;
  return class setMaterialTexture extends functions_Base/* NamedFunction2 */.CE {
    static type() {
      return type;
    }
    func(material, texture) {
      material[mapName] = texture;
      material.needsUpdate = true;
    }
  };
}
class setMaterialMap extends setMaterialTextureFactory({ type: "setMaterialMap", mapName: "map" }) {
}
class setMaterialAlphaMap extends setMaterialTextureFactory({
  type: "setMaterialAlphaMap",
  mapName: "alphaMap"
}) {
}
class setMaterialAOMap extends setMaterialTextureFactory({ type: "setMaterialAOMap", mapName: "aoMap" }) {
}
class setMaterialDisplacementMap extends setMaterialTextureFactory({
  type: "setMaterialDisplacementMap",
  mapName: "displacementMap"
}) {
}
class setMaterialEnvMap extends setMaterialTextureFactory({ type: "setMaterialEnvMap", mapName: "envMap" }) {
}
class setMaterialEmissiveMap extends setMaterialTextureFactory({
  type: "setMaterialEmissiveMap",
  mapName: "emissiveMap"
}) {
}
class setMaterialMetalnessMap extends setMaterialTextureFactory({
  type: "setMaterialMetalnessMap",
  mapName: "metalnessMap"
}) {
}
class setMaterialRoughnessMap extends setMaterialTextureFactory({
  type: "setMaterialRoughnessMap",
  mapName: "roughnessMap"
}) {
}
class setMaterialOpacity extends functions_Base/* NamedFunction3 */.Dv {
  static type() {
    return "setMaterialOpacity";
  }
  func(material, opacity, lerp) {
    material.opacity = lerp * opacity + (1 - lerp) * material.opacity;
  }
}
class setMaterialUniformNumber extends functions_Base/* NamedFunction6 */.z {
  static type() {
    return "setMaterialUniformNumber";
  }
  func(material, uniformName, value, lerp, addPrefix, printWarnings) {
    const uniforms = OnBeforeCompile/* MaterialUserDataUniforms.getUniforms */.Hc.getUniforms(material);
    if (!uniforms) {
      if (printWarnings) {
        console.warn(`uniforms not found`, material);
      }
      return;
    }
    uniformName = _addParamUniformNamePrefix(uniformName, addPrefix);
    const uniform = uniforms[uniformName];
    if (!uniform) {
      if (printWarnings) {
        console.warn(`uniform '${uniformName}' not found`, material, uniforms);
      }
      return;
    }
    if (lerp == 1) {
      uniform.value = value;
    } else {
      uniform.value = lerp * value + (1 - lerp) * uniform.value;
    }
  }
}
class setMaterialUniformVectorColor extends functions_Base/* NamedFunction6 */.z {
  static type() {
    return "setMaterialUniformVectorColor";
  }
  func(material, uniformName, value, lerp, addPrefix, printWarnings) {
    const uniforms = OnBeforeCompile/* MaterialUserDataUniforms.getUniforms */.Hc.getUniforms(material);
    if (!uniforms) {
      if (printWarnings) {
        console.warn(`uniforms not found`, material);
      }
      return;
    }
    uniformName = _addParamUniformNamePrefix(uniformName, addPrefix);
    const uniform = uniforms[uniformName];
    if (!uniform) {
      if (printWarnings) {
        console.warn(`uniform '${uniformName}' not found`, material, uniforms);
      }
      return;
    }
    if (lerp >= 1) {
      uniform.value.copy(value);
    } else {
      uniform.value.lerp(value, lerp);
    }
  }
}
class setMaterialUniformTexture extends functions_Base/* NamedFunction5 */.t9 {
  static type() {
    return "setMaterialUniformTexture";
  }
  func(material, uniformName, value, addPrefix, printWarnings) {
    const uniforms = OnBeforeCompile/* MaterialUserDataUniforms.getUniforms */.Hc.getUniforms(material);
    if (!uniforms) {
      if (printWarnings) {
        console.warn(`uniforms not found`, material);
      }
      return;
    }
    uniformName = _addTextureUniformNamePrefix(uniformName, addPrefix);
    const uniform = uniforms[uniformName];
    if (!uniform) {
      if (printWarnings) {
        console.warn(`uniform '${uniformName}' not found`, material, uniforms);
      }
      return;
    }
    uniform.value = value;
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/functions/_SetObjectAttribute.ts







const _SetObjectAttribute_tmpColor = new three_module.Color();
const _SetObjectAttribute_tmpV2 = new three_module.Vector2();
const _SetObjectAttribute_tmpV3 = new three_module.Vector3();
const _SetObjectAttribute_tmpV4 = new three_module.Vector4();
function _lerpAndGetValue(object3D, attribName, lerp, newValue, type) {
  switch (type) {
    case connections_Js/* JsConnectionPointType.BOOLEAN */.zF.BOOLEAN: {
      return newValue;
    }
    case connections_Js/* JsConnectionPointType.COLOR */.zF.COLOR: {
      ThreejsCoreObject/* ThreejsCoreObject.attribValue */.W.attribValue(object3D, attribName, 0, _SetObjectAttribute_tmpColor);
      _SetObjectAttribute_tmpColor.lerp(newValue, lerp);
      return _SetObjectAttribute_tmpColor;
    }
    case connections_Js/* JsConnectionPointType.FLOAT */.zF.FLOAT:
    case connections_Js/* JsConnectionPointType.INT */.zF.INT: {
      let currentValue = ThreejsCoreObject/* ThreejsCoreObject.attribValue */.W.attribValue(object3D, attribName, 0);
      if (currentValue == null) {
        currentValue = 0;
      }
      return (0,_Module/* mix */.CD)(currentValue, newValue, lerp);
    }
    case connections_Js/* JsConnectionPointType.STRING */.zF.STRING: {
      return newValue;
    }
    case connections_Js/* JsConnectionPointType.VECTOR2 */.zF.VECTOR2: {
      ThreejsCoreObject/* ThreejsCoreObject.attribValue */.W.attribValue(object3D, attribName, 0, _SetObjectAttribute_tmpV2);
      _SetObjectAttribute_tmpV2.lerp(newValue, lerp);
      return _SetObjectAttribute_tmpV2;
    }
    case connections_Js/* JsConnectionPointType.VECTOR3 */.zF.VECTOR3: {
      ThreejsCoreObject/* ThreejsCoreObject.attribValue */.W.attribValue(object3D, attribName, 0, _SetObjectAttribute_tmpV3);
      _SetObjectAttribute_tmpV3.lerp(newValue, lerp);
      return _SetObjectAttribute_tmpV3;
    }
    case connections_Js/* JsConnectionPointType.VECTOR4 */.zF.VECTOR4: {
      ThreejsCoreObject/* ThreejsCoreObject.attribValue */.W.attribValue(object3D, attribName, 0, _SetObjectAttribute_tmpV4);
      _SetObjectAttribute_tmpV4.lerp(newValue, lerp);
      return _SetObjectAttribute_tmpV4;
    }
  }
  Assert/* TypeAssert.unreachable */.f.unreachable(type);
}
class setObjectAttribute extends functions_Base/* ObjectNamedFunction4 */.eG {
  static type() {
    return "setObjectAttribute";
  }
  func(object3D, attribName, lerp, newValue, type) {
    if (lerp >= 1) {
      ThreejsCoreObject/* ThreejsCoreObject.setAttribute */.W.setAttribute(object3D, attribName, newValue);
    } else {
      const lerpedValue = _lerpAndGetValue(object3D, attribName, lerp, newValue, type);
      ThreejsCoreObject/* ThreejsCoreObject.setAttribute */.W.setAttribute(object3D, attribName, lerpedValue);
    }
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/functions/_SetObjectLookAt.ts






const _SetObjectLookAt_q1 = new three_module.Quaternion();
const _SetObjectLookAt_q2 = new three_module.Quaternion();
class setObjectLookAt extends functions_Base/* ObjectNamedFunction5 */.o$ {
  static type() {
    return "setObjectLookAt";
  }
  func(object3D, targetPosition, up, lerp, invertDirection, updateMatrix) {
    object3D.up.copy(up);
    if (lerp >= 1) {
      CoreLookAt.applyLookAt(object3D, targetPosition, invertDirection);
    } else {
      _SetObjectLookAt_q1.copy(object3D.quaternion);
      CoreLookAt.applyLookAt(object3D, targetPosition, invertDirection);
      _SetObjectLookAt_q2.copy(object3D.quaternion);
      _SetObjectLookAt_q1.slerp(_SetObjectLookAt_q2, lerp);
      object3D.quaternion.copy(_SetObjectLookAt_q1);
    }
    (0,ObjectPropertyReactivity/* touchObjectProperty */.Jd)(object3D, ObjectPropertyReactivity/* GetObjectPropertyJsNodeInputName.quaternion */.De.quaternion);
    if ((0,Type/* isBooleanTrue */.bI)(updateMatrix)) {
      object3D.updateMatrix();
      (0,ObjectPropertyReactivity/* touchObjectProperty */.Jd)(object3D, ObjectPropertyReactivity/* GetObjectPropertyJsNodeInputName.matrix */.De.matrix);
    }
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/functions/_SetObjectPosition.ts



class setObjectPosition extends functions_Base/* ObjectNamedFunction3 */.uW {
  static type() {
    return "setObjectPosition";
  }
  func(object3D, position, lerp, updateMatrix) {
    if (lerp >= 1) {
      object3D.position.copy(position);
    } else {
      object3D.position.lerp(position, lerp);
    }
    (0,ObjectPropertyReactivity/* touchObjectProperty */.Jd)(object3D, ObjectPropertyReactivity/* GetObjectPropertyJsNodeInputName.position */.De.position);
    if (updateMatrix) {
      object3D.updateMatrix();
      (0,ObjectPropertyReactivity/* touchObjectProperty */.Jd)(object3D, ObjectPropertyReactivity/* GetObjectPropertyJsNodeInputName.matrix */.De.matrix);
    }
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/functions/_SetObjectQuaternion.ts





const _SetObjectQuaternion_q1 = new three_module.Quaternion();
const _SetObjectQuaternion_q2 = new three_module.Quaternion();
class setObjectQuaternion extends functions_Base/* ObjectNamedFunction3 */.uW {
  static type() {
    return "setObjectQuaternion";
  }
  func(object3D, quaternion, lerp, updateMatrix) {
    if (lerp >= 1) {
      object3D.quaternion.copy(quaternion);
    } else {
      _SetObjectQuaternion_q1.copy(object3D.quaternion);
      _SetObjectQuaternion_q2.copy(quaternion);
      _SetObjectQuaternion_q1.slerp(_SetObjectQuaternion_q2, lerp);
      object3D.quaternion.copy(_SetObjectQuaternion_q1);
    }
    (0,ObjectPropertyReactivity/* touchObjectProperty */.Jd)(object3D, ObjectPropertyReactivity/* GetObjectPropertyJsNodeInputName.quaternion */.De.quaternion);
    if ((0,Type/* isBooleanTrue */.bI)(updateMatrix)) {
      object3D.updateMatrix();
      (0,ObjectPropertyReactivity/* touchObjectProperty */.Jd)(object3D, ObjectPropertyReactivity/* GetObjectPropertyJsNodeInputName.matrix */.De.matrix);
    }
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/functions/_SetObjectRotation.ts





const _SetObjectRotation_q1 = new three_module.Quaternion();
const _SetObjectRotation_q2 = new three_module.Quaternion();
class setObjectRotation extends functions_Base/* ObjectNamedFunction3 */.uW {
  static type() {
    return "setObjectRotation";
  }
  func(object3D, euler, lerp, updateMatrix) {
    if (lerp >= 1) {
      object3D.quaternion.setFromEuler(euler, true);
    } else {
      _SetObjectRotation_q1.copy(object3D.quaternion);
      _SetObjectRotation_q2.setFromEuler(euler, true);
      _SetObjectRotation_q1.slerp(_SetObjectRotation_q2, lerp);
      object3D.quaternion.copy(_SetObjectRotation_q1);
    }
    (0,ObjectPropertyReactivity/* touchObjectProperty */.Jd)(object3D, ObjectPropertyReactivity/* GetObjectPropertyJsNodeInputName.quaternion */.De.quaternion);
    if ((0,Type/* isBooleanTrue */.bI)(updateMatrix)) {
      object3D.updateMatrix();
      (0,ObjectPropertyReactivity/* touchObjectProperty */.Jd)(object3D, ObjectPropertyReactivity/* GetObjectPropertyJsNodeInputName.matrix */.De.matrix);
    }
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/functions/_SetObjectScale.ts




const _SetObjectScale_scale = new three_module.Vector3();
class setObjectScale extends functions_Base/* ObjectNamedFunction4 */.eG {
  static type() {
    return "setObjectScale";
  }
  func(object3D, scale, mult, lerp, updateMatrix) {
    if (lerp >= 1) {
      object3D.scale.copy(scale).multiplyScalar(mult);
    } else {
      _SetObjectScale_scale.copy(scale).multiplyScalar(mult);
      object3D.scale.lerp(_SetObjectScale_scale, lerp);
    }
    (0,ObjectPropertyReactivity/* touchObjectProperty */.Jd)(object3D, ObjectPropertyReactivity/* GetObjectPropertyJsNodeInputName.scale */.De.scale);
    if (updateMatrix) {
      object3D.updateMatrix();
      (0,ObjectPropertyReactivity/* touchObjectProperty */.Jd)(object3D, ObjectPropertyReactivity/* GetObjectPropertyJsNodeInputName.matrix */.De.matrix);
    }
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/functions/_SetPoint.ts




const _c = new three_module.Color();
const _SetPoint_q = new three_module.Quaternion();
const _SetPoint_v2 = new three_module.Vector2();
const _SetPoint_v3 = new three_module.Vector3();
const _v3m = new three_module.Vector3();
const _SetPoint_v4 = new three_module.Vector4();
function _setPointAttributeVector3Name(namedFunction, attribName) {
  return function(object3D, ptnum, newValue, lerp) {
    const geometry = object3D.geometry;
    if (!geometry) {
      return;
    }
    const attribute = geometry.getAttribute(attribName);
    if (!attribute) {
      return;
    }
    if (lerp >= 1) {
      newValue.toArray(attribute.array, ptnum * 3);
    } else {
      _SetPoint_v3.fromBufferAttribute(attribute, ptnum);
      _SetPoint_v3.lerp(newValue, lerp);
      _SetPoint_v3.toArray(attribute.array, ptnum * 3);
    }
    (0,geometry_Attribute/* markAttributeAsNeedsUpdateForFrame */.X3)(attribute, namedFunction.timeController.frame());
  };
}
function _setPointAttributeVector3MultName(namedFunction, attribName) {
  return function(object3D, ptnum, newValue, mult, lerp) {
    const geometry = object3D.geometry;
    if (!geometry) {
      return;
    }
    const attribute = geometry.getAttribute(attribName);
    if (!attribute) {
      return;
    }
    _v3m.copy(newValue).multiplyScalar(mult);
    if (lerp >= 1) {
      _v3m.toArray(attribute.array, ptnum * 3);
    } else {
      _SetPoint_v3.fromBufferAttribute(attribute, ptnum);
      _SetPoint_v3.lerp(_v3m, lerp);
      _SetPoint_v3.toArray(attribute.array, ptnum * 3);
    }
    (0,geometry_Attribute/* markAttributeAsNeedsUpdateForFrame */.X3)(attribute, namedFunction.timeController.frame());
  };
}
function _setPointAttributeQuaternionName(namedFunction, attribName) {
  return function(object3D, ptnum, newValue, lerp) {
    const geometry = object3D.geometry;
    if (!geometry) {
      return;
    }
    const attribute = geometry.getAttribute(attribName);
    if (!attribute) {
      return;
    }
    if (lerp >= 1) {
      newValue.toArray(attribute.array, ptnum * 4);
    } else {
      _SetPoint_q.fromBufferAttribute(attribute, ptnum);
      _SetPoint_q.slerp(newValue, lerp);
      _SetPoint_q.toArray(attribute.array, ptnum * 4);
    }
    (0,geometry_Attribute/* markAttributeAsNeedsUpdateForFrame */.X3)(attribute, namedFunction.timeController.frame());
  };
}
function _setPointAttributeNumberForNamedFunction(namedFunction) {
  return function _setPointAttributeNumber(object3D, attribName, ptnum, newValue, lerp) {
    const geometry = object3D.geometry;
    if (!geometry) {
      return;
    }
    const attribute = geometry.getAttribute(attribName);
    if (!attribute) {
      return;
    }
    if (lerp >= 1) {
      attribute.array[ptnum] = newValue;
    } else {
      const oldValue = attribute.array[ptnum];
      attribute.array[ptnum] = oldValue + (newValue - oldValue) * lerp;
    }
    (0,geometry_Attribute/* markAttributeAsNeedsUpdateForFrame */.X3)(attribute, namedFunction.timeController.frame());
  };
}
function _setPointAttributeColorForNamedFunction(namedFunction) {
  return function _setPointAttributeColor(object3D, attribName, ptnum, newValue, lerp) {
    const geometry = object3D.geometry;
    if (!geometry) {
      return;
    }
    const attribute = geometry.getAttribute(attribName);
    if (!attribute) {
      return;
    }
    if (lerp >= 1) {
      newValue.toArray(attribute.array, ptnum * 3);
    } else {
      _c.fromBufferAttribute(attribute, ptnum);
      _c.lerp(newValue, lerp);
      _c.toArray(attribute.array, ptnum * 3);
    }
    (0,geometry_Attribute/* markAttributeAsNeedsUpdateForFrame */.X3)(attribute, namedFunction.timeController.frame());
  };
}
function _setPointAttributeVector2ForNamedFunction(namedFunction) {
  return function _setPointAttributeVector2(object3D, attribName, ptnum, newValue, lerp) {
    const geometry = object3D.geometry;
    if (!geometry) {
      return;
    }
    const attribute = geometry.getAttribute(attribName);
    if (!attribute) {
      return;
    }
    if (lerp >= 1) {
      newValue.toArray(attribute.array, ptnum * 2);
    } else {
      _SetPoint_v2.fromBufferAttribute(attribute, ptnum);
      _SetPoint_v2.lerp(newValue, lerp);
      _SetPoint_v2.toArray(attribute.array, ptnum * 2);
    }
    (0,geometry_Attribute/* markAttributeAsNeedsUpdateForFrame */.X3)(attribute, namedFunction.timeController.frame());
  };
}
function _setPointAttributeVector3ForNamedFunction(namedFunction) {
  return function _setPointAttributeVector3(object3D, attribName, ptnum, newValue, lerp) {
    const geometry = object3D.geometry;
    if (!geometry) {
      return;
    }
    const attribute = geometry.getAttribute(attribName);
    if (!attribute) {
      return;
    }
    if (lerp >= 1) {
      newValue.toArray(attribute.array, ptnum * 3);
    } else {
      _SetPoint_v3.fromBufferAttribute(attribute, ptnum);
      _SetPoint_v3.lerp(newValue, lerp);
      _SetPoint_v3.toArray(attribute.array, ptnum * 3);
    }
    (0,geometry_Attribute/* markAttributeAsNeedsUpdateForFrame */.X3)(attribute, namedFunction.timeController.frame());
  };
}
function _setPointAttributeVector4ForNamedFunction(namedFunction) {
  return function _setPointAttributeVector4(object3D, attribName, ptnum, newValue, lerp) {
    const geometry = object3D.geometry;
    if (!geometry) {
      return;
    }
    const attribute = geometry.getAttribute(attribName);
    if (!attribute) {
      return;
    }
    if (lerp >= 1) {
      newValue.toArray(attribute.array, ptnum * 4);
    } else {
      _SetPoint_v4.fromBufferAttribute(attribute, ptnum);
      _SetPoint_v4.lerp(newValue, lerp);
      _SetPoint_v4.toArray(attribute.array, ptnum * 4);
    }
    (0,geometry_Attribute/* markAttributeAsNeedsUpdateForFrame */.X3)(attribute, namedFunction.timeController.frame());
  };
}
class setPointPosition extends functions_Base/* ObjectNamedFunction3 */.uW {
  constructor() {
    super(...arguments);
    this.func = _setPointAttributeVector3Name(this, geometry_Attribute/* Attribute.POSITION */.ah.POSITION);
  }
  static type() {
    return "setPointPosition";
  }
}
class setPointAttributeNumber extends functions_Base/* ObjectNamedFunction4 */.eG {
  constructor() {
    super(...arguments);
    this.func = _setPointAttributeNumberForNamedFunction(this);
  }
  static type() {
    return "setPointAttributeNumber";
  }
}
class setPointAttributeColor extends functions_Base/* ObjectNamedFunction4 */.eG {
  constructor() {
    super(...arguments);
    this.func = _setPointAttributeColorForNamedFunction(this);
  }
  static type() {
    return "setPointAttributeColor";
  }
}
class setPointAttributeVector2 extends functions_Base/* ObjectNamedFunction4 */.eG {
  constructor() {
    super(...arguments);
    this.func = _setPointAttributeVector2ForNamedFunction(this);
  }
  static type() {
    return "setPointAttributeVector2";
  }
}
class setPointAttributeVector3 extends functions_Base/* ObjectNamedFunction4 */.eG {
  constructor() {
    super(...arguments);
    this.func = _setPointAttributeVector3ForNamedFunction(this);
  }
  static type() {
    return "setPointAttributeVector3";
  }
}
class setPointAttributeVector4 extends functions_Base/* ObjectNamedFunction4 */.eG {
  constructor() {
    super(...arguments);
    this.func = _setPointAttributeVector4ForNamedFunction(this);
  }
  static type() {
    return "setPointAttributeVector4";
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/functions/_SetInstance.ts







const _SetInstance_q = new three_module.Quaternion();
const _SetInstance_q2 = new three_module.Quaternion();
const _SetInstance_v3 = new three_module.Vector3();
class setPointInstanceLookAt extends functions_Base/* ObjectNamedFunction4 */.eG {
  static type() {
    return "setPointInstanceLookAt";
  }
  func(object3D, ptnum, targetPosition, up, lerp) {
    const geometry = object3D.geometry;
    if (!geometry) {
      return;
    }
    const positionAttribute = geometry.getAttribute(Instancer/* InstanceAttrib.POSITION */.R.POSITION);
    const quaternionAttribute = geometry.getAttribute(Instancer/* InstanceAttrib.QUATERNION */.R.QUATERNION);
    if (!(positionAttribute && quaternionAttribute)) {
      return;
    }
    _SetInstance_v3.fromBufferAttribute(positionAttribute, ptnum);
    quatLookAt(_SetInstance_v3, targetPosition, up, _SetInstance_q);
    if (lerp >= 1) {
      _SetInstance_q.toArray(quaternionAttribute.array, ptnum * 4);
    } else {
      if (!quaternionAttribute) {
        return;
      }
      _SetInstance_q2.fromBufferAttribute(quaternionAttribute, ptnum);
      _SetInstance_q2.slerp(_SetInstance_q, lerp);
      _SetInstance_q2.toArray(quaternionAttribute.array, ptnum * 4);
    }
    (0,geometry_Attribute/* markAttributeAsNeedsUpdateForFrame */.X3)(quaternionAttribute, this.timeController.frame());
  }
}
class setPointInstancePosition extends functions_Base/* ObjectNamedFunction3 */.uW {
  constructor() {
    super(...arguments);
    this.func = _setPointAttributeVector3Name(this, Instancer/* InstanceAttrib.POSITION */.R.POSITION);
  }
  static type() {
    return "setPointInstancePosition";
  }
}
class setPointInstanceQuaternion extends functions_Base/* ObjectNamedFunction3 */.uW {
  constructor() {
    super(...arguments);
    this.func = _setPointAttributeQuaternionName(this, Instancer/* InstanceAttrib.QUATERNION */.R.QUATERNION);
  }
  static type() {
    return "setPointInstanceQuaternion";
  }
}
class setPointInstanceScale extends functions_Base/* ObjectNamedFunction4 */.eG {
  constructor() {
    super(...arguments);
    this.func = _setPointAttributeVector3MultName(this, Instancer/* InstanceAttrib.SCALE */.R.SCALE);
  }
  static type() {
    return "setPointInstanceScale";
  }
}

// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/core/lights/SpotLight.ts + 4 modules
var lights_SpotLight = __webpack_require__(38766);
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/functions/_Light.ts



class setSpotLightIntensity extends functions_Base/* ObjectNamedFunction2 */.YS {
  static type() {
    return "setSpotLightIntensity";
  }
  func(object3D, intensity, lerp) {
    if (!(object3D instanceof lights_SpotLight/* SpotLightContainer */.u0)) {
      return;
    }
    const spotLight = object3D.light();
    const newIntensity = lerp * intensity + (1 - lerp) * spotLight.intensity;
    spotLight.intensity = newIntensity;
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/functions/_WFC.ts




class setWFCSoftConstraint extends functions_Base/* ObjectNamedFunction6 */.LX {
  static type() {
    return "setWFCSoftConstraint";
  }
  func(object, floorId, quadId, tileId, rotation, quadSeed, configSeed) {
    const solver = (0,WFCRegister/* getWFCSolver */.uO)(object);
    if (!solver) {
      Poly/* Poly.warn */.L.warn("setWFCSoftConstraint: no solver found");
      return;
    }
    return solver.addSoftContraint({
      object,
      floorId,
      quadId,
      tileId,
      rotation,
      //
      stepsCount: -1,
      quadSeed,
      configSeed
    });
  }
}
class WFCBuild extends functions_Base/* ObjectNamedFunction1 */.c_ {
  static type() {
    return "WFCBuild";
  }
  func(builderObject, solverObject) {
    const builder = (0,WFCRegister/* getWFCBuilder */.lv)(builderObject);
    const solver = (0,WFCRegister/* getWFCSolver */.uO)(solverObject);
    if (!(builder && solver)) {
      if (!solver) {
        Poly/* Poly.warn */.L.warn("WFCBuild: no solver found");
      } else {
        Poly/* Poly.warn */.L.warn("WFCBuild: no builder found");
      }
      return;
    }
    return builder.update(builderObject, solverObject);
  }
}

// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/core/Sleep.ts
var Sleep = __webpack_require__(71820);
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/functions/_Sleep.ts

var _Sleep_async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};


class sleep extends functions_Base/* NamedFunction1 */.TV {
  constructor() {
    super(...arguments);
    this.async = true;
  }
  static type() {
    return "sleep";
  }
  func(delay) {
    return _Sleep_async(this, null, function* () {
      yield Sleep/* CoreSleep.sleep */.D.sleep(delay);
    });
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/functions/_Subtract.ts


class subtractNumber extends functions_Base/* NamedFunction */.x9 {
  static type() {
    return "subtractNumber";
  }
  func(...args) {
    let first = args[0];
    for (let i = 1; i < args.length; i++) {
      first -= args[i];
    }
    return first;
  }
}
class subtractVector extends functions_Base/* NamedFunction */.x9 {
  static type() {
    return "subtractVector";
  }
  func(...args) {
    const first = args[0];
    for (let i = 1; i < args.length; i++) {
      first.sub(args[i]);
    }
    return first;
  }
}
class subtractVectorNumber extends functions_Base/* NamedFunction2 */.CE {
  static type() {
    return "subtractVectorNumber";
  }
  func(vector, number) {
    return vector.subScalar(number);
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/functions/_TrackingFace.ts






class trackFace extends functions_Base/* ObjectNamedFunction1 */.c_ {
  static type() {
    return "trackFace";
  }
  func(object3D, texture) {
    if (!texture) {
      return;
    }
    const source = computerVisionValidSource(texture);
    if (!source) {
      return;
    }
    CoreComputerVisionFace.trackMedia(object3D, source);
    touchTrackedObject(object3D);
  }
}
class trackFaceGetLandmarks extends functions_Base/* ObjectNamedFunction2 */.YS {
  static type() {
    return "trackFaceGetLandmarks";
  }
  func(object3D, faceIndex, target) {
    (0,CoreReactivity/* dummyReadRefVal */.Jb)(getOrCreateTrackedObjectRef(this.timeController, object3D).value);
    const results = CoreComputerVisionFace.trackerResults(object3D);
    const vectorArray = results[faceIndex].multiFaceLandmarks;
    let i = 0;
    for (let src of vectorArray) {
      target[i].copy(src);
      i++;
    }
    return target;
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/functions/_Trigger.ts


class triggerFilter extends functions_Base/* NamedFunction1 */.TV {
  static type() {
    return "triggerFilter";
  }
  func(condition) {
    return condition;
  }
  asString(condition) {
    return `if(${condition}==false) { return }`;
  }
}
class triggerTwoWaySwitch extends functions_Base/* NamedFunction3 */.Dv {
  static type() {
    return "triggerTwoWaySwitch";
  }
  func(condition, _func0, _func1) {
    if (condition) {
      _func0();
    } else {
      _func1();
    }
  }
}
class triggerSwitch extends functions_Base/* NamedFunction2 */.CE {
  static type() {
    return "triggerSwitch";
  }
  func(index, _functions) {
    const _func = _functions[index];
    if (_func) {
      _func();
    }
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/functions/_Vector.ts





class vector3AngleTo extends functions_Base/* NamedFunction2 */.CE {
  static type() {
    return "vector3AngleTo";
  }
  func(v1, v2) {
    return v1.angleTo(v2);
  }
}
class vector3ProjectOnPlane extends functions_Base/* NamedFunction3 */.Dv {
  static type() {
    return "vector3ProjectOnPlane";
  }
  func(src, planeNormal, target) {
    target.copy(src);
    target.projectOnPlane(planeNormal);
    return target;
  }
}
class vector3Project extends functions_Base/* NamedFunction3 */.Dv {
  static type() {
    return "vector3Project";
  }
  func(src, object3D, target) {
    if (object3D == null) {
      this._getDefaultCamera = this._getDefaultCamera || new getDefaultCamera(this.node, this.shadersCollectionController);
      object3D = this._getDefaultCamera.func();
    }
    if (!(object3D instanceof three_module.PerspectiveCamera || object3D instanceof three_module.OrthographicCamera)) {
      return target;
    }
    (0,CoreReactivity/* dummyReadRefVal */.Jb)(this.timeController.timeUniform().value);
    target.copy(src);
    target.project(object3D);
    return target;
  }
}
class vector3Unproject extends functions_Base/* NamedFunction3 */.Dv {
  static type() {
    return "vector3Unproject";
  }
  func(src, object3D, target) {
    if (object3D == null) {
      this._getDefaultCamera = this._getDefaultCamera || new getDefaultCamera(this.node, this.shadersCollectionController);
      object3D = this._getDefaultCamera.func();
    }
    if (!(object3D instanceof three_module.PerspectiveCamera || object3D instanceof three_module.OrthographicCamera)) {
      return target;
    }
    (0,CoreReactivity/* dummyReadRefVal */.Jb)(this.timeController.timeUniform().value);
    target.copy(src);
    target.unproject(object3D);
    return target;
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/poly/registers/functions/All.ts





































































































































































































































































































































































































































































































































class AllNamedFunctionRegister {
  static run(poly) {
    [
      addAudioStopEventListener,
      addNumber,
      addObjectToObjectClickCheck,
      addObjectToObjectContextmenuCheck,
      addObjectToObjectHoveredCheck,
      addObjectToObjectLongPressCheck,
      addObjectToObjectMouseClickCheck,
      addObjectToObjectPointerdownCheck,
      addObjectToObjectPointerupCheck,
      addObjectToObjectSwipeCheck,
      addObjectToPointerdownCheck,
      addObjectToPointerupCheck,
      addVector,
      addVectorNumber,
      addVideoEventListener,
      andArrays,
      andBooleans,
      _AnimationMixer/* animationActionCrossFade */.hB,
      _AnimationMixer/* animationActionFadeIn */.BN,
      _AnimationMixer/* animationActionFadeOut */.Ct,
      _AnimationMixer/* animationActionPlay */.MV,
      _AnimationMixer/* animationActionStop */.dH,
      _AnimationMixer/* animationMixerUpdate */.TG,
      arrayElementPrimitive,
      arrayElementVector,
      arrayLength,
      arrayPopPrimitive,
      arrayPopVector,
      arrayShiftPrimitive,
      arrayShiftVector,
      boolToInt,
      box3ContainsPoint,
      box3IntersectsBox3,
      box3Set,
      box3SetFromObject,
      catmullRomCurve3GetPoint,
      channelFloat,
      channelValueFloat,
      channelValueVector2,
      channelValueVector3,
      channelValueVector4,
      channelVector2,
      channelVector3,
      channelVector4,
      clamp,
      clothConstraintSetPosition,
      clothCreateConstraint,
      clothDeleteConstraint,
      clothSolverReset,
      clothSolverStepSimulation,
      clothSolverUpdateMaterial,
      colorSetRGB,
      colorToVec3,
      _Math_complement,
      computeVelocity,
      cookNode,
      createObject,
      createObjects,
      createPhysicsRBD,
      createPhysicsRBDKinematicConstraint,
      createPhysicsRBDs,
      createScrollListener,
      crossVector2,
      crossVector3,
      cubeLatticeDeform,
      cursorToUv,
      debug,
      _Math_degToRad,
      deletePhysicsRBDConstraints,
      deletePhysicsRBDKinematicConstraint,
      deviceOrientation,
      distanceVector2,
      distanceVector3,
      divideNumber,
      divideVectorNumber,
      dotVector2,
      dotVector3,
      easeElasticI,
      easeElasticIO,
      easeElasticO,
      easeI2,
      easeI3,
      easeI4,
      easeIO2,
      easeIO3,
      easeIO4,
      easeO2,
      easeO3,
      easeO4,
      easeSinI,
      easeSinIO,
      easeSinO,
      elementsToArrayPrimitive,
      elementsToArrayVector,
      eulerSetFromQuaternion,
      eulerSetFromVector3,
      _Math_fit,
      fitClamp,
      floatToColor,
      floatToInt,
      floatToVec2,
      floatToVec3,
      floatToVec4,
      geolocationCurrentPositionRef,
      geolocationGetCurrentPosition,
      geolocationLatitude,
      geolocationLongitude,
      getActorNodeParamValue,
      _AnimationMixer/* getAnimationAction */.Ei,
      _AnimationMixer/* getAnimationMixer */.GR,
      getBox3Center,
      getBox3Max,
      getBox3Min,
      getChildrenAttributes,
      getChildrenAttributesPrevious,
      getChildrenAttributesRef,
      getChildrenPhysicsRBDPropertiesAngularDamping,
      getChildrenPhysicsRBDPropertiesAngularVelocity,
      getChildrenPhysicsRBDPropertiesIsMoving,
      getChildrenPhysicsRBDPropertiesIsSleeping,
      getChildrenPhysicsRBDPropertiesLinearDamping,
      getChildrenPhysicsRBDPropertiesLinearVelocity,
      getChildrenPropertiesCastShadow,
      getChildrenPropertiesFrustumCulled,
      getChildrenPropertiesMatrixAutoUpdate,
      getChildrenPropertiesPosition,
      getChildrenPropertiesQuaternion,
      getChildrenPropertiesReceiveShadow,
      getChildrenPropertiesScale,
      getChildrenPropertiesUp,
      getChildrenPropertiesVisible,
      getDefaultCamera,
      getGeometryBoundingBox,
      getGeometryNodeObjects,
      getGeometryPositions,
      getIntersectionAttributeColorInterpolated,
      getIntersectionAttributeColorNearest,
      getIntersectionAttributeNumberInterpolated,
      getIntersectionAttributeNumberNearest,
      getIntersectionAttributeStringNearest,
      getIntersectionAttributeVector2Interpolated,
      getIntersectionAttributeVector2Nearest,
      getIntersectionAttributeVector3Interpolated,
      getIntersectionAttributeVector3Nearest,
      getIntersectionAttributeVector4Interpolated,
      getIntersectionAttributeVector4Nearest,
      getIntersectionPropertyDistance,
      getIntersectionPropertyFaceIndex,
      getIntersectionPropertyNormal,
      getIntersectionPropertyObject,
      getIntersectionPropertyPoint,
      getIntersectionPropertyUv,
      getMaterial,
      getNode,
      getObject,
      getObjectAttribute,
      getObjectAttributeAutoDefault,
      getObjectAttributePrevious,
      getObjectAttributeRef,
      getObjectChild,
      getObjectLastDispatchedEventName,
      getObjectProperty,
      getObjectUserData,
      getObjectWorldPosition,
      getParam,
      getParent,
      getPhysicsRBD,
      getPhysicsRBDAngularDamping,
      getPhysicsRBDAngularVelocity,
      getPhysicsRBDCapsuleHeight,
      getPhysicsRBDCapsuleRadius,
      getPhysicsRBDConeHeight,
      getPhysicsRBDConeRadius,
      getPhysicsRBDCuboidSizes,
      getPhysicsRBDCylinderHeight,
      getPhysicsRBDCylinderRadius,
      getPhysicsRBDIsMoving,
      getPhysicsRBDIsSleeping,
      getPhysicsRBDLinearDamping,
      getPhysicsRBDLinearVelocity,
      getPhysicsRBDSphereRadius,
      getPlaneConstant,
      getPlaneNormal,
      getPlayerInputDataBackward,
      getPlayerInputDataForward,
      getPlayerInputDataJump,
      getPlayerInputDataLeft,
      getPlayerInputDataRight,
      getPlayerInputDataRun,
      getPlayerSimplePropertyOnGround,
      getPlayerSimplePropertyVelocity,
      getPointAttributeNumber,
      getPointAttributeVector2,
      getPointAttributeVector3,
      getPointAttributeVector4,
      getPointIndex,
      getPointInstancePosition,
      getPointInstanceQuaternion,
      getPointInstanceScale,
      getPointPosition,
      getPrimitiveAttribute,
      getRayDirection,
      getRayOrigin,
      getSibbling,
      getSphereCenter,
      getSphereRadius,
      getTexture,
      getTrackedHandIndexDirection,
      getTrackedHandMiddleDirection,
      getTrackedHandPinkyDirection,
      getTrackedHandRingDirection,
      getTrackedHandThumbDirection,
      getVideoPropertyCurrentTime,
      getVideoPropertyDuration,
      getVideoPropertyMuted,
      getVideoPropertyPlaying,
      getWebXRARHitDetected,
      getWebXRARHitMatrix,
      getWebXRARHitPosition,
      getWebXRARHitQuaternion,
      getWebXRControllerAngularVelocity,
      getWebXRControllerHasAngularVelocity,
      getWebXRControllerHasLinearVelocity,
      getWebXRControllerLinearVelocity,
      getWebXRControllerObject,
      getWebXRControllerRay,
      getWebXRTrackedMarkerMatrix,
      globalsCursor,
      globalsRaycaster,
      globalsRayFromCursor,
      globalsTime,
      globalsTimeDelta,
      hsvToRgb,
      importPrimitiveAttributeNumber,
      intToBool,
      intToFloat,
      isTouchDevice,
      _KeyboardEventMatchesConfig/* keyboardEventMatchesConfig */.k0,
      lengthVector,
      lengthVectorArray,
      lerpColor,
      lerpNumber,
      lerpQuaternion,
      lerpVector2,
      lerpVector3,
      lerpVector4,
      manhattanDistanceVector2,
      manhattanDistanceVector3,
      _MathGeneric/* mathColor_1 */.aH,
      _MathGeneric/* mathColor_2 */.Hk,
      _MathGeneric/* mathColor_3 */.PX,
      _MathGeneric/* mathColor_3vvf */.X$,
      _MathGeneric/* mathColor_4 */.OT,
      _MathGeneric/* mathColor_5 */.oo,
      _MathGeneric/* mathFloat_1 */.Hf,
      _MathGeneric/* mathFloat_2 */._T,
      _MathGeneric/* mathFloat_3 */.rV,
      _MathGeneric/* mathFloat_4 */.Fg,
      _MathGeneric/* mathFloat_5 */.o5,
      _MathGeneric/* mathPrimArray_1 */.ix,
      _MathGeneric/* mathPrimArray_2 */.IU,
      _MathGeneric/* mathPrimArray_3 */.l5,
      _MathGeneric/* mathPrimArray_4 */.kB,
      _MathGeneric/* mathPrimArray_5 */.Hy,
      _MathGeneric/* mathVector2_1 */.I5,
      _MathGeneric/* mathVector2_2 */.LY,
      _MathGeneric/* mathVector2_3 */.qO,
      _MathGeneric/* mathVector2_3vvf */.AR,
      _MathGeneric/* mathVector2_4 */.Td,
      _MathGeneric/* mathVector2_5 */.am,
      _MathGeneric/* mathVector3_1 */.pF,
      _MathGeneric/* mathVector3_2 */.QU,
      _MathGeneric/* mathVector3_3 */.YW,
      _MathGeneric/* mathVector3_3vvf */.T,
      _MathGeneric/* mathVector3_4 */.Mu,
      _MathGeneric/* mathVector3_5 */.IQ,
      _MathGeneric/* mathVector4_1 */.mR,
      _MathGeneric/* mathVector4_2 */.PT,
      _MathGeneric/* mathVector4_3 */.bC,
      _MathGeneric/* mathVector4_3vvf */.$q,
      _MathGeneric/* mathVector4_4 */.fD,
      _MathGeneric/* mathVector4_5 */.FA,
      _MathGeneric/* mathVectorArray_1 */.$O,
      _MathGeneric/* mathVectorArray_2 */.mh,
      _MathGeneric/* mathVectorArray_3 */.e2,
      _MathGeneric/* mathVectorArray_4 */.Lo,
      _MathGeneric/* mathVectorArray_5 */.uD,
      matrix4LookAt,
      matrix4MakeTranslation,
      matrix4Multiply,
      maxLengthVector2,
      maxLengthVector3,
      maxLengthVector4,
      mix,
      mod,
      multAdd,
      multNumber,
      multScalarArrayVectorArray,
      multScalarColor,
      multScalarVector2,
      multScalarVector3,
      multScalarVector4,
      multScalarVectorArray,
      multVector,
      multVectorNumber,
      nearestPosition,
      negate,
      noiseImprovedVector3,
      noiseSimplexVector2,
      noiseSimplexVector3,
      noiseSimplexVector4,
      normalizeVector2,
      normalizeVector3,
      normalizeVector4,
      object3DLocalToWorld,
      object3DWorldToLocal,
      objectAddEventListeners,
      objectAddOnBeforeDeleteEventListener,
      objectDelete,
      objectDispatchEvent,
      objectUpdateMatrix,
      objectUpdateWorldMatrix,
      onPerformanceChange,
      onViewerControlsEvent,
      orArrays,
      orBooleans,
      particlesSystemReset,
      particlesSystemStepSimulation,
      pauseAudioSource,
      physicsDebugUpdate,
      physicsRBDAddForce,
      physicsRBDAddForceAtPoint,
      physicsRBDAddTorque,
      physicsRBDApplyImpulse,
      physicsRBDApplyImpulseAtPoint,
      physicsRBDApplyTorqueImpulse,
      physicsRBDDelete,
      physicsRBDResetAll,
      physicsRBDResetForces,
      physicsRBDResetTorques,
      physicsWorldReset,
      physicsWorldStepSimulation,
      planeSet,
      playAnimation,
      playAudioSource,
      playerMode,
      playerPhysicsUpdate,
      playerSimpleUpdate,
      playInstrumentNote,
      polarTransform,
      pressButtonParam,
      previousValueColor,
      previousValuePrimitive,
      previousValueVector2,
      previousValueVector3,
      previousValueVector4,
      primitiveNeighbourIndex,
      primitiveNeighboursCount,
      quaternionAngleTo,
      quaternionSetFromAxisAngle,
      quaternionSetFromEuler,
      quaternionSlerp,
      radToDeg,
      rand,
      random,
      rayDistanceToPlane,
      rayFromCamera,
      rayIntersectBox3,
      rayIntersectObject3D,
      rayIntersectPlane,
      rayIntersectsBox3,
      rayIntersectsObject3D,
      rayIntersectSphere,
      rayIntersectsPlane,
      rayIntersectsSphere,
      raySet,
      renderPixel,
      rotateWithAxisAngle,
      rotateWithQuaternion,
      SDF2DBox,
      SDF2DCircle,
      SDF2DCross,
      SDF2DHeart,
      SDF2DRoundedX,
      SDFBox,
      SDFElongateFast,
      SDFElongateSlow,
      SDFIntersect,
      SDFOnion,
      SDFPlane,
      SDFRevolutionX,
      SDFRevolutionY,
      SDFRevolutionZ,
      SDFSmoothIntersect,
      SDFSmoothSubtract,
      SDFSmoothUnion,
      SDFSphere,
      SDFSubtract,
      SDFTorus,
      SDFTransform,
      SDFTube,
      SDFUnion,
      setCameraViewOffset,
      setCSSObjectClass,
      setGeometryInstanceAttributeColor,
      setGeometryInstanceAttributeFloat,
      setGeometryInstanceAttributeQuaternion,
      setGeometryInstanceAttributeVector2,
      setGeometryInstanceAttributeVector3,
      setGeometryInstanceAttributeVector4,
      setGeometryInstancePositions,
      setGeometryInstanceQuaternions,
      setGeometryInstanceScales,
      setGeometryInstanceTransforms,
      setGeometryPositions,
      setMaterialAlphaMap,
      setMaterialAOMap,
      setMaterialColor,
      setMaterialDisplacementMap,
      setMaterialEmissiveColor,
      setMaterialEmissiveMap,
      setMaterialEnvMap,
      setMaterialMap,
      setMaterialMetalnessMap,
      setMaterialOpacity,
      setMaterialRoughnessMap,
      setMaterialUniformNumber,
      setMaterialUniformTexture,
      setMaterialUniformVectorColor,
      setObjectAttribute,
      setObjectCastShadow,
      setObjectFrustumCulled,
      setObjectLookAt,
      setObjectMaterial,
      setObjectMaterialColor,
      setObjectMatrix,
      setObjectMatrixAutoUpdate,
      setObjectPolarTransform,
      setObjectPosition,
      setObjectQuaternion,
      setObjectReceiveShadow,
      setObjectRotation,
      setObjectScale,
      setObjectVisible,
      setParamBoolean,
      setParamBooleanToggle,
      setParamColor,
      setParamFloat,
      setParamInteger,
      setParamString,
      setParamVector2,
      setParamVector3,
      setParamVector4,
      setPerspectiveCameraFov,
      setPerspectiveCameraNearFar,
      setPhysicsRBDAngularVelocity,
      setPhysicsRBDCapsuleProperty,
      setPhysicsRBDConeProperty,
      setPhysicsRBDCuboidProperty,
      setPhysicsRBDCylinderProperty,
      setPhysicsRBDLinearVelocity,
      setPhysicsRBDPosition,
      setPhysicsRBDRotation,
      setPhysicsRBDSphereProperty,
      setPhysicsWorldGravity,
      setPlayerInput,
      setPointAttributeColor,
      setPointAttributeNumber,
      setPointAttributeVector2,
      setPointAttributeVector3,
      setPointAttributeVector4,
      setPointIndex,
      setPointInstanceLookAt,
      setPointInstancePosition,
      setPointInstanceQuaternion,
      setPointInstanceScale,
      setPointPosition,
      setSpotLightIntensity,
      setViewer,
      setViewerControls,
      setWFCSoftConstraint,
      sizzleVec3XY,
      sizzleVec3XZ,
      sizzleVec3YZ,
      sizzleVec4WArray,
      sizzleVec4XYZ,
      sizzleVec4XYZArray,
      sleep,
      smootherstep,
      smoothstep,
      softBodyConstraintCreate,
      softBodyConstraintDelete,
      softBodyConstraintSetPosition,
      softBodyMultiplyVelocity,
      softBodySetPosition,
      softBodySolverStepSimulation,
      sphereSet,
      subtractNumber,
      subtractVector,
      subtractVectorNumber,
      trackFace,
      trackFaceGetLandmarks,
      trackHand,
      trackHandGetNormalizedLandmarks,
      trackHandGetWorldLandmarks,
      triggerFilter,
      triggerSwitch,
      triggerTwoWaySwitch,
      vec2ToVec3,
      vec3ToColor,
      vec3ToVec4,
      vector3AngleTo,
      vector3Project,
      vector3ProjectOnPlane,
      vector3Unproject,
      WFCBuild
    ].forEach((f) => poly.registerNamedFunction(f));
  }
}

// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/core/FeaturesController.ts
var FeaturesController = __webpack_require__(51753);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/core/geometry/entities/object/BaseCoreObject.ts + 1 modules
var BaseCoreObject = __webpack_require__(78531);
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/core/geometry/modules/cad/utils/CadMerge.ts





const objectsByType = /* @__PURE__ */ new Map();
function cadMergeCompact(inputObjects) {
  objectsByType.clear();
  for (const inputObject of inputObjects) {
    MapUtils/* MapUtils.pushOnArrayAtEntry */.pl.pushOnArrayAtEntry(objectsByType, inputObject.type, inputObject);
  }
  const oc = CadLoaderSync/* CadLoaderSync.oc */.T.oc();
  const newObjects = [];
  objectsByType.forEach((objects, type) => {
    switch (type) {
      case CadCommon/* CadGeometryType.EDGE */.dT.EDGE: {
        return cadMergeCompactEdges(oc, objects, newObjects);
      }
      case CadCommon/* CadGeometryType.WIRE */.dT.WIRE: {
        return cadMergeCompactWires(oc, objects, newObjects);
      }
      default: {
        for (const object of objects) {
          newObjects.push(object);
        }
      }
    }
  });
  return newObjects;
}
function cadMergeCompactEdges(oc, objects, newObjects) {
  const api = new oc.BRepBuilderAPI_MakeWire_1();
  for (const object of objects) {
    api.Add_1(object.cadGeometry());
  }
  const wire = api.Wire();
  api.delete();
  newObjects.push(new CadObject/* CadObject */.K(wire, CadCommon/* CadGeometryType.WIRE */.dT.WIRE));
  return;
}
function cadMergeCompactWires(oc, objects, newObjects) {
  const api = new oc.BRepBuilderAPI_MakeWire_1();
  for (const object of objects) {
    api.Add_2(object.cadGeometry());
  }
  const wire = api.Wire();
  api.delete();
  newObjects.push(new CadObject/* CadObject */.K(wire, CadCommon/* CadGeometryType.WIRE */.dT.WIRE));
  return;
}

// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/core/geometry/entities/object/BaseCoreObjectUtils.ts
var BaseCoreObjectUtils = __webpack_require__(21592);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/core/geometry/entities/point/CorePoint.ts
var CorePoint = __webpack_require__(60014);
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/core/geometry/modules/cad/CadPoint.ts


class CadPoint extends CorePoint/* CorePoint */.A {
  constructor(object, index) {
    super(object, index);
    this._object = object;
    this._updateGeometry();
  }
  object() {
    return this._object;
  }
  setIndex(index, object) {
    this._index = index;
    if (object) {
      this._object = object;
      this._updateGeometry();
    }
    return this;
  }
  _updateGeometry() {
    const geometry = this._object.geometry;
    if (geometry) {
      this._geometry = geometry;
    }
  }
  geometry() {
    return this._geometry;
  }
  static addAttribute(object, attribName, attribute) {
  }
  static attributes(object) {
    return void 0;
  }
  static entitiesCount(object) {
    return 0;
  }
  position(target) {
    return target;
  }
  normal(target) {
    return target;
  }
  //
  //
  //
  //
  //
  static userDataAttribs(object) {
    return {};
  }
  static setIndexedAttribute(object, attribName, values, indices) {
  }
  static attribValueIndex(object, index, attribName) {
    return -1;
  }
  //
  //
  //
  //
  //
}

// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/core/geometry/entities/vertex/CoreVertex.ts
var CoreVertex = __webpack_require__(74279);
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/core/geometry/modules/cad/CadVertex.ts


class CadVertex_CadVertex extends CoreVertex/* CoreVertex */.k {
  constructor(object, index) {
    super(object, index);
  }
  geometry() {
    return void 0;
  }
  static attributes(object) {
    return;
  }
  static entitiesCount(object) {
    return 0;
  }
  position(target) {
    console.warn("CadVertex.position not implemented");
    return target;
  }
  normal(target) {
    console.warn("CadVertex.normal not implemented");
    return target;
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/core/geometry/modules/cad/CadCoreObject.ts










const _bbox = new three_module.Box3();
const _bboxSize = new three_module.Vector3();
class CadCoreObject extends BaseCoreObject/* BaseCoreObject */.q {
  constructor(_object, index) {
    super(_object, index);
    this._object = _object;
  }
  type() {
    return this._object.type;
  }
  static fromGeometry(geometry, type) {
    const cadObject = new CadObject/* CadObject */.K(geometry, type);
    return new CadCoreObject(cadObject, 0);
  }
  object() {
    return this._object;
  }
  static position(object, target) {
    object.boundingBox(_bbox);
    _bbox.getCenter(target);
  }
  boundingBox(target) {
    this._object.boundingBox(target);
  }
  boundingSphere(target) {
    this.boundingBox(_bbox);
    _bbox.getSize(_bboxSize);
    _bbox.getCenter(target.center);
    const diameter = Math.max(_bboxSize.x, _bboxSize.y, _bboxSize.z);
    target.radius = diameter * 0.5;
  }
  static objectData(object) {
    const data = (0,BaseCoreObjectUtils/* objectData */.Sq)(object);
    data.pointsCount = CadPoint.entitiesCount(object);
    data.verticesCount = CadVertex_CadVertex.entitiesCount(object);
    const primitiveClass = primitiveClassFactoryNonAbstract(object);
    data.primitivesCount = (primitiveClass == null ? void 0 : primitiveClass.entitiesCount(object)) || 0;
    data.primitiveName = (primitiveClass == null ? void 0 : primitiveClass.primitiveName()) || "";
    return data;
  }
  static applyMatrix(object, matrix, transformTargetType, transformSpace, transformMode) {
    object.applyMatrix4(matrix);
  }
  static mergeCompact(options) {
    const { objects, material, mergedObjects, onError } = options;
    try {
      const firstObject = objects[0];
      if (!firstObject) {
        return;
      }
      const newObjects = cadMergeCompact(objects);
      for (const newObject of newObjects) {
        (0,ObjectContent/* objectContentCopyProperties */.Br)(firstObject, newObject);
        if (material) {
          newObject.material = material;
        }
      }
      mergedObjects.push(...newObjects);
    } catch (e) {
      onError(e.message || "unknown error");
    }
  }
}

// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/core/geometry/entities/primitive/CorePrimitive.ts
var CorePrimitive = __webpack_require__(75499);
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/core/geometry/modules/cad/CadPrimitive.ts


class CadPrimitive extends CorePrimitive/* CorePrimitive */.n {
  constructor(object, index) {
    super(object, index);
  }
  static entitiesCount(object) {
    return 0;
  }
  geometry() {
    return this._object.geometry;
  }
  position(target) {
    console.warn("CadPrimitive.position not implemented");
    return target;
  }
  normal(target) {
    console.warn("CadPrimitive.normal not implemented");
    return target;
  }
}

// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/core/geometry/modules/cad/toObject3D/CadCompound.ts
var CadCompound = __webpack_require__(71891);
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/core/geometry/modules/cad/CadPrimitiveCompound.ts



class CadPrimitiveCompound extends CadPrimitive {
  static primitiveName() {
    return "compound";
  }
  static entitiesCount(object) {
    const cadOobject = object;
    return (0,CadCompound/* cadCompoundSubObjectsCount */.G)(cadOobject);
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/core/geometry/modules/cad/CadPrimitiveCompSolid.ts


class CadPrimitiveCompSolid extends CadPrimitive {
  static primitiveName() {
    return "compSolid";
  }
  static entitiesCount(object) {
    return 0;
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/core/geometry/modules/cad/CadPrimitiveEdge.ts


class CadPrimitiveEdge extends CadPrimitive {
  static primitiveName() {
    return "edge";
  }
  static entitiesCount(object) {
    return 0;
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/core/geometry/modules/cad/CadPrimitiveWire.ts


class CadPrimitiveWire extends CadPrimitive {
  static primitiveName() {
    return "wire";
  }
  static entitiesCount(object) {
    return 0;
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/core/geometry/modules/cad/CadPrimitiveFace.ts


class CadPrimitiveFace extends CadPrimitive {
  static primitiveName() {
    return "face";
  }
  static entitiesCount(object) {
    return 0;
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/core/geometry/modules/cad/CadPrimitiveShell.ts


class CadPrimitiveShell extends CadPrimitive {
  static primitiveName() {
    return "shell";
  }
  static entitiesCount(object) {
    return 0;
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/core/geometry/modules/cad/CadPrimitiveSolid.ts




class CadPrimitiveSolid extends CadPrimitive {
  static primitiveName() {
    return "face";
  }
  static entitiesCount(object) {
    const oc = CadLoaderSync/* CadLoaderSync.oc */.T.oc();
    const cadOobject = object;
    let count = 0;
    const shape = cadOobject.geometry;
    (0,CadTraverse/* traverseFaces */.Ob)(oc, shape, (face) => {
      count++;
    });
    return count;
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/core/geometry/modules/cad/CadModule.ts
















const CAD_TESSELATION_PARAMS = {
  linearTolerance: 0,
  angularTolerance: 0,
  curveAbscissa: 0,
  curveTolerance: 0,
  wireframe: false,
  displayMeshes: false,
  displayEdges: false,
  meshesColor: new three_module.Color(),
  edgesColor: new three_module.Color()
};
function updateCADTesselationParams(params) {
  CAD_TESSELATION_PARAMS.linearTolerance = params.CADLinearTolerance;
  CAD_TESSELATION_PARAMS.angularTolerance = params.CADAngularTolerance;
  CAD_TESSELATION_PARAMS.curveAbscissa = params.CADCurveAbscissa;
  CAD_TESSELATION_PARAMS.curveTolerance = params.CADCurveTolerance;
  CAD_TESSELATION_PARAMS.wireframe = params.CADWireframe;
  CAD_TESSELATION_PARAMS.displayMeshes = params.CADDisplayMeshes;
  CAD_TESSELATION_PARAMS.displayEdges = params.CADDisplayEdges;
  CAD_TESSELATION_PARAMS.meshesColor.copy(params.CADMeshesColor);
  CAD_TESSELATION_PARAMS.edgesColor.copy(params.CADEdgesColor);
}
const onAddSpecializedChildren = (displayNode, coreGroup, newObjects, params) => {
  let newObjectsAreDifferent = false;
  const newCadObjects = coreGroup.cadObjects();
  if (newCadObjects && newCadObjects.length != 0) {
    updateCADTesselationParams(params);
    for (const cadObject of newCadObjects) {
      const newObject3D = cadObject.toObject3D(CAD_TESSELATION_PARAMS, displayNode);
      if (newObject3D) {
        newObjectsAreDifferent = true;
        if (Type/* CoreType.isArray */.MR.isArray(newObject3D)) {
          newObjects.push(...newObject3D);
        } else {
          newObjects.push(newObject3D);
        }
      }
    }
  }
  return newObjectsAreDifferent;
};
const primitiveClassFactoryNonAbstract = (object) => {
  if (CadCommon/* CAD_GEOMETRY_TYPES_SET.has */.AF.has(object.type)) {
    const type = object.type;
    switch (type) {
      case CadCommon/* CadGeometryType.POINT_2D */.dT.POINT_2D: {
        return;
      }
      case CadCommon/* CadGeometryType.CURVE_2D */.dT.CURVE_2D: {
        return;
      }
      case CadCommon/* CadGeometryType.VERTEX */.dT.VERTEX: {
        return;
      }
      case CadCommon/* CadGeometryType.EDGE */.dT.EDGE: {
        return CadPrimitiveEdge;
      }
      case CadCommon/* CadGeometryType.WIRE */.dT.WIRE: {
        return CadPrimitiveWire;
      }
      case CadCommon/* CadGeometryType.FACE */.dT.FACE: {
        return CadPrimitiveFace;
      }
      case CadCommon/* CadGeometryType.SHELL */.dT.SHELL: {
        return CadPrimitiveShell;
      }
      case CadCommon/* CadGeometryType.SOLID */.dT.SOLID: {
        return CadPrimitiveSolid;
      }
      case CadCommon/* CadGeometryType.COMPSOLID */.dT.COMPSOLID: {
        return CadPrimitiveCompSolid;
      }
      case CadCommon/* CadGeometryType.COMPOUND */.dT.COMPOUND: {
        return CadPrimitiveCompound;
      }
    }
    Assert/* TypeAssert.unreachable */.f.unreachable(type);
  }
};
function onCadModuleRegister(poly) {
  const pointClassFactory = (object) => {
    if (CadCommon/* CAD_GEOMETRY_TYPES_SET.has */.AF.has(object.type)) {
      return CadPoint;
    }
  };
  const pointInstanceFactory = (object, index = 0) => {
    if (CadCommon/* CAD_GEOMETRY_TYPES_SET.has */.AF.has(object.type)) {
      return new CadPoint(object, index);
    }
  };
  const vertexClassFactory = (object) => {
    if (CadCommon/* CAD_GEOMETRY_TYPES_SET.has */.AF.has(object.type)) {
      return CadVertex_CadVertex;
    }
  };
  const vertexInstanceFactory = (object, index = 0) => {
    if (CadCommon/* CAD_GEOMETRY_TYPES_SET.has */.AF.has(object.type)) {
      return new CadVertex_CadVertex(object, index);
    }
  };
  const primitiveClassFactory = primitiveClassFactoryNonAbstract;
  const primitiveInstanceFactory = (object, index = 0) => {
    if (CadCommon/* CAD_GEOMETRY_TYPES_SET.has */.AF.has(object.type)) {
      const type = object.type;
      switch (type) {
        case CadCommon/* CadGeometryType.POINT_2D */.dT.POINT_2D: {
          return;
        }
        case CadCommon/* CadGeometryType.CURVE_2D */.dT.CURVE_2D: {
          return;
        }
        case CadCommon/* CadGeometryType.VERTEX */.dT.VERTEX: {
          return;
        }
        case CadCommon/* CadGeometryType.EDGE */.dT.EDGE: {
          return new CadPrimitiveEdge(object, index);
        }
        case CadCommon/* CadGeometryType.WIRE */.dT.WIRE: {
          return new CadPrimitiveWire(object, index);
        }
        case CadCommon/* CadGeometryType.FACE */.dT.FACE: {
          return new CadPrimitiveFace(object, index);
        }
        case CadCommon/* CadGeometryType.SHELL */.dT.SHELL: {
          return new CadPrimitiveShell(object, index);
        }
        case CadCommon/* CadGeometryType.SOLID */.dT.SOLID: {
          return new CadPrimitiveSolid(object, index);
        }
        case CadCommon/* CadGeometryType.COMPSOLID */.dT.COMPSOLID: {
          return new CadPrimitiveCompSolid(object, index);
        }
        case CadCommon/* CadGeometryType.COMPOUND */.dT.COMPOUND: {
          return new CadPrimitiveCompound(object, index);
        }
      }
      Assert/* TypeAssert.unreachable */.f.unreachable(type);
    }
  };
  const objectClassFactory = (object) => {
    if (CadCommon/* CAD_GEOMETRY_TYPES_SET.has */.AF.has(object.type)) {
      return CadCoreObject;
    }
  };
  const objectInstanceFactory = (object, index = 0) => {
    if (CadCommon/* CAD_GEOMETRY_TYPES_SET.has */.AF.has(object.type)) {
      return new CadCoreObject(object, index);
    }
  };
  const factoryFunctions = {
    pointClass: pointClassFactory,
    pointInstance: pointInstanceFactory,
    vertexClass: vertexClassFactory,
    vertexInstance: vertexInstanceFactory,
    primitiveClass: primitiveClassFactory,
    primitiveInstance: primitiveInstanceFactory,
    objectClass: objectClassFactory,
    objectInstance: objectInstanceFactory
  };
  (0,CoreObjectFactory/* registerFactoryFunctions */.Sv)(factoryFunctions);
  poly.specializedChildren.registerHook("CAD", onAddSpecializedChildren);
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/poly/registers/modules/entryPoints/CAD.ts



const CADModule = {
  moduleName: modules_Common/* ModuleName.CAD */.r.CAD,
  // module: cadModule,
  onRegister: onCadModuleRegister
};


// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/core/geometry/modules/csg/CsgObject.ts + 4 modules
var CsgObject = __webpack_require__(12243);
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/core/geometry/modules/csg/CsgPoint.ts


class CsgPoint extends CorePoint/* CorePoint */.A {
  constructor(object, index) {
    super(object, index);
    this._object = object;
    this._updateGeometry();
  }
  object() {
    return this._object;
  }
  setIndex(index, object) {
    this._index = index;
    if (object) {
      this._object = object;
      this._updateGeometry();
    }
    return this;
  }
  _updateGeometry() {
    const geometry = this._object.geometry;
    if (geometry) {
      this._geometry = geometry;
    }
  }
  geometry() {
    return this._geometry;
  }
  static addAttribute(object, attribName, attribute) {
  }
  static attributes(object) {
    return void 0;
  }
  static entitiesCount(object) {
    return 0;
  }
  position(target) {
    return target;
  }
  normal(target) {
    return target;
  }
  //
  //
  //
  //
  //
  static userDataAttribs(object) {
    return {};
  }
  static setIndexedAttribute(object, attribName, values, indices) {
  }
  static attribValueIndex(object, index, attribName) {
    return -1;
  }
  //
  //
  //
  //
  //
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/core/geometry/modules/csg/CsgVertex.ts


class CsgVertex extends CoreVertex/* CoreVertex */.k {
  constructor(object, index) {
    super(object, index);
  }
  geometry() {
    return void 0;
  }
  static attributes(object) {
    return;
  }
  static entitiesCount(object) {
    return 0;
  }
  position(target) {
    console.warn("CsgVertex.position not implemented");
    return target;
  }
  normal(target) {
    console.warn("CsgVertex.normal not implemented");
    return target;
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/core/geometry/modules/csg/CsgCoreObject.ts














const { union } = src.booleans;
const CsgCoreObject_bbox = new three_module.Box3();
class CsgCoreObject extends BaseCoreObject/* BaseCoreObject */.q {
  constructor(_object, index) {
    super(_object, index);
    this._object = _object;
  }
  static position(object, target) {
    object.boundingBox(CsgCoreObject_bbox);
    CsgCoreObject_bbox.getCenter(target);
  }
  boundingBox(target) {
    this._object.boundingBox(target);
  }
  boundingSphere(target) {
    this._object.boundingSphere(target);
  }
  static objectData(object) {
    const data = (0,BaseCoreObjectUtils/* objectData */.Sq)(object);
    data.pointsCount = CsgPoint.entitiesCount(object);
    data.verticesCount = CsgVertex.entitiesCount(object);
    const primitiveClass = CsgModule_primitiveClassFactoryNonAbstract(object);
    data.primitivesCount = (primitiveClass == null ? void 0 : primitiveClass.entitiesCount(object)) || 0;
    data.primitiveName = (primitiveClass == null ? void 0 : primitiveClass.primitiveName()) || "";
    return data;
  }
  static applyMatrix(object, matrix, transformTargetType, transformSpace, transformMode) {
    switch (transformTargetType) {
      case Transform/* TransformTargetType.GEOMETRY */.dH.GEOMETRY: {
        return (0,CsgMat4/* csgApplyMatrix4 */.PL)(object.csgGeometry(), matrix);
      }
      case Transform/* TransformTargetType.OBJECT */.dH.OBJECT: {
        return object.applyMatrix4(matrix);
      }
    }
    Assert/* TypeAssert.unreachable */.f.unreachable(transformTargetType);
  }
  static mergeCompact(options) {
    const { objects, material, mergedObjects, onError } = options;
    try {
      const csgObjects = objects;
      const firstObject = csgObjects[0];
      if (!firstObject) {
        return;
      }
      const geometries2 = csgObjects.map((o) => o.csgGeometry());
      const geom2s = [];
      const geom3s = [];
      for (const geometry of geometries2) {
        if ((0,CsgCoreType/* csgIsGeom2 */.IY)(geometry)) {
          geom2s.push(geometry);
        }
        if ((0,CsgCoreType/* csgIsGeom3 */.Mq)(geometry)) {
          geom3s.push(geometry);
        }
      }
      const _merge = (typedGeometries) => {
        if (typedGeometries.length == 0) {
          return;
        }
        typedGeometries.forEach(CsgMat4/* csgApplyTransform */.l6);
        const mergedGeom = union(typedGeometries);
        const newObject = new CsgObject/* CsgObject */.V(mergedGeom);
        (0,ObjectContent/* objectContentCopyProperties */.Br)(firstObject, newObject);
        if (material) {
          newObject.material = material;
        }
        mergedObjects.push(newObject);
      };
      _merge(geom2s);
      _merge(geom3s);
    } catch (e) {
      onError(e.message || "unknown error");
    }
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/core/geometry/modules/csg/CsgPrimitive.ts


class CsgPrimitive extends CorePrimitive/* CorePrimitive */.n {
  constructor(object, index) {
    super(object, index);
    this._geometry = object.geometry;
  }
  // static override entitiesCount<T extends CoreObjectType>(object: ObjectContent<T>) {
  // 	(object as any as CsgObject<CsgGeometryType>).geometry.
  // 	return 0;
  // }
  geometry() {
    return this._object.geometry;
  }
  position(target) {
    console.warn("CsgPrimitive.position not implemented");
    return target;
  }
  normal(target) {
    console.warn("CsgPrimitive.normal not implemented");
    return target;
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/core/geometry/modules/csg/CsgPrimitivePath2.ts


class CsgPrimitivePath2 extends CsgPrimitive {
  constructor(object, index) {
    super(object, index);
  }
  static primitiveName() {
    return "point";
  }
  static entitiesCount(object) {
    const csgOobject = object;
    const geometry = csgOobject.geometry;
    return geometry.points.length;
  }
  // position(target: Vector3): Vector3 {
  // 	console.warn('CsgPrimitivePath2.position not implemented');
  // 	return target;
  // }
  // normal(target: Vector3): Vector3 {
  // 	console.warn('CsgPrimitivePath2.normal not implemented');
  // 	return target;
  // }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/core/geometry/modules/csg/CsgPrimitiveGeom2.ts


class CsgPrimitiveGeom2 extends CsgPrimitive {
  constructor(object, index) {
    super(object, index);
  }
  static primitiveName() {
    return "side";
  }
  static entitiesCount(object) {
    const csgOobject = object;
    const geometry = csgOobject.geometry;
    return geometry.sides.length;
  }
  // position(target: Vector3): Vector3 {
  // 	console.warn('CsgPrimitiveGeom2.position not implemented');
  // 	return target;
  // }
  // normal(target: Vector3): Vector3 {
  // 		console.warn('CsgPrimitiveGeom2.normal not implemented');
  // 	return target;
  // }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/core/geometry/modules/csg/CsgPrimitiveGeom3.ts


class CsgPrimitiveGeom3 extends CsgPrimitive {
  constructor(object, index) {
    super(object, index);
  }
  static primitiveName() {
    return "polygon";
  }
  static entitiesCount(object) {
    const csgOobject = object;
    const geometry = csgOobject.geometry;
    return geometry.polygons.length;
  }
  // position(target: Vector3): Vector3 {
  // 	console.warn('CsgPrimitiveGeom3.position not implemented');
  // 	return target;
  // }
  // normal(target: Vector3): Vector3 {
  // 	console.warn('CsgPrimitiveGeom3.normal not implemented');
  // 	return target;
  // }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/core/geometry/modules/csg/CsgModule.ts












const CSG_TESSELATION_PARAMS = {
  facetAngle: 0,
  wireframe: false,
  meshesColor: new three_module.Color(),
  linesColor: new three_module.Color()
};
function updateCSGTesselationParams(params) {
  CSG_TESSELATION_PARAMS.facetAngle = params.CSGFacetAngle;
  CSG_TESSELATION_PARAMS.wireframe = params.CSGWireframe;
  CSG_TESSELATION_PARAMS.meshesColor.copy(params.CSGMeshesColor);
  CSG_TESSELATION_PARAMS.linesColor.copy(params.CSGLinesColor);
}
const CsgModule_onAddSpecializedChildren = (displayNode, coreGroup, newObjects, params) => {
  let newObjectsAreDifferent = false;
  const newCsgObjects = coreGroup.csgObjects();
  if (newCsgObjects && newCsgObjects.length != 0) {
    updateCSGTesselationParams(params);
    for (const csgObject of newCsgObjects) {
      const newObject3D = csgObject.toObject3D(CSG_TESSELATION_PARAMS);
      if (newObject3D) {
        newObjectsAreDifferent = true;
        if (Type/* CoreType.isArray */.MR.isArray(newObject3D)) {
          newObjects.push(...newObject3D);
        } else {
          newObjects.push(newObject3D);
        }
      }
    }
  }
  return newObjectsAreDifferent;
};
const CsgModule_primitiveClassFactoryNonAbstract = (object) => {
  if (CsgCommon/* CSG_GEOMETRY_TYPES_SET.has */.u.has(object.type)) {
    const type = object.type;
    switch (type) {
      case CsgCommon/* CsgGeometryType.PATH2 */.d.PATH2: {
        return CsgPrimitivePath2;
      }
      case CsgCommon/* CsgGeometryType.GEOM2 */.d.GEOM2: {
        return CsgPrimitiveGeom2;
      }
      case CsgCommon/* CsgGeometryType.GEOM3 */.d.GEOM3: {
        return CsgPrimitiveGeom3;
      }
    }
    Assert/* TypeAssert.unreachable */.f.unreachable(type);
  }
};
function onCsgModuleRegister(poly) {
  const pointClassFactory = (object) => {
    if (CsgCommon/* CSG_GEOMETRY_TYPES_SET.has */.u.has(object.type)) {
      return CsgPoint;
    }
  };
  const pointInstanceFactory = (object, index = 0) => {
    if (CsgCommon/* CSG_GEOMETRY_TYPES_SET.has */.u.has(object.type)) {
      return new CsgPoint(object, index);
    }
  };
  const vertexClassFactory = (object) => {
    if (CsgCommon/* CSG_GEOMETRY_TYPES_SET.has */.u.has(object.type)) {
      return CsgVertex;
    }
  };
  const vertexInstanceFactory = (object, index = 0) => {
    if (CsgCommon/* CSG_GEOMETRY_TYPES_SET.has */.u.has(object.type)) {
      return new CsgVertex(object, index);
    }
  };
  const primitiveClassFactory = CsgModule_primitiveClassFactoryNonAbstract;
  const primitiveInstanceFactory = (object, index = 0) => {
    if (CsgCommon/* CSG_GEOMETRY_TYPES_SET.has */.u.has(object.type)) {
      const type = object.type;
      switch (type) {
        case CsgCommon/* CsgGeometryType.PATH2 */.d.PATH2: {
          return new CsgPrimitivePath2(object, index);
        }
        case CsgCommon/* CsgGeometryType.GEOM2 */.d.GEOM2: {
          return new CsgPrimitiveGeom2(object, index);
        }
        case CsgCommon/* CsgGeometryType.GEOM3 */.d.GEOM3: {
          return new CsgPrimitiveGeom3(object, index);
        }
      }
      Assert/* TypeAssert.unreachable */.f.unreachable(type);
    }
  };
  const objectClassFactory = (object) => {
    if (CsgCommon/* CSG_GEOMETRY_TYPES_SET.has */.u.has(object.type)) {
      return CsgCoreObject;
    }
  };
  const objectInstanceFactory = (object, index = 0) => {
    if (CsgCommon/* CSG_GEOMETRY_TYPES_SET.has */.u.has(object.type)) {
      return new CsgCoreObject(object, index);
    }
  };
  const factoryFunctions = {
    pointClass: pointClassFactory,
    pointInstance: pointInstanceFactory,
    vertexClass: vertexClassFactory,
    vertexInstance: vertexInstanceFactory,
    primitiveClass: primitiveClassFactory,
    primitiveInstance: primitiveInstanceFactory,
    objectClass: objectClassFactory,
    objectInstance: objectInstanceFactory
  };
  (0,CoreObjectFactory/* registerFactoryFunctions */.Sv)(factoryFunctions);
  poly.specializedChildren.registerHook("CSG", CsgModule_onAddSpecializedChildren);
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/poly/registers/modules/entryPoints/CSG.ts



const CSGModule = {
  moduleName: modules_Common/* ModuleName.CSG */.r.CSG,
  // module: cadModule,
  onRegister: onCsgModuleRegister
};


;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/core/thirdParty/gsap/gsapModule.ts



function onGsapModuleRegister(poly) {
  gsapFactory/* GSAP_FACTORY.gsap */.g5.gsap = gsap/* gsap */.p8;
  gsapFactory/* GSAP_FACTORY.timeline */.g5.timeline = (vars) => {
    return gsap/* gsap.timeline */.p8.timeline(vars);
  };
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/poly/registers/modules/entryPoints/GSAP.ts



const GSAPModule = {
  moduleName: modules_Common/* ModuleName.GSAP */.r.GSAP,
  // module: cadModule,
  onRegister: onGsapModuleRegister
};


// EXTERNAL MODULE: ../@polygonjs/polygonjs/node_modules/three-gpu-pathtracer/src/utils/IESLoader.js
var IESLoader = __webpack_require__(89609);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/node_modules/three-gpu-pathtracer/src/objects/PhysicalCamera.js
var PhysicalCamera = __webpack_require__(11921);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/node_modules/three-gpu-pathtracer/src/objects/ShapedAreaLight.js
var ShapedAreaLight = __webpack_require__(95275);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/node_modules/three-gpu-pathtracer/src/objects/PhysicalSpotLight.js
var PhysicalSpotLight = __webpack_require__(69546);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/viewers/PathTracingViewer.ts
var PathTracingViewer = __webpack_require__(11933);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/viewers/Threejs.ts + 1 modules
var Threejs = __webpack_require__(63500);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/core/camera/CoreCameraRendererController.ts
var CoreCameraRendererController = __webpack_require__(9936);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/core/camera/frameMode/CoreCameraPerspectiveFrameMode.ts
var CoreCameraPerspectiveFrameMode = __webpack_require__(57987);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/core/monkeyPatch/SpotLight.ts
var monkeyPatch_SpotLight = __webpack_require__(70900);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/core/CoreSceneObjectsFactory.ts
var CoreSceneObjectsFactory = __webpack_require__(6767);
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/core/lights/spotlight/ies/lm_63_1995.ts

const IES_PROFILE_LM_63_1995 = `IESNA:LM-63-1995
[TEST] 
[MANUFAC] BEGA
[MORE] Copyright LUMCat V 
[LUMCAT] 
[LUMINAIRE] 50988.2K3
[LAMPCAT] LED  11,5W
[LAMP]    1218 lm,14 W
TILT=NONE
1 -1 1.0 37 1 1 2 -0.120 0.000 0.000
1.0 1.0 14
   0.0   2.5   5.0   7.5  10.0  12.5  15.0  17.5  20.0  22.5  25.0  27.5  30.0
  32.5  35.0  37.5  40.0  42.5  45.0  47.5  50.0  52.5  55.0  57.5  60.0  62.5
  65.0  67.5  70.0  72.5  75.0  77.5  80.0  82.5  85.0  87.5  90.0
   0.0
    2225.9    2154.6    1986.3    1758.9    1532.7    1342.4    1182.9    1045.2
     920.2     806.6     705.1     617.7     553.4     514.3     474.4     388.7
     249.2     118.9      46.3      30.3      26.5      24.5      23.0      21.8
      20.6      19.6      18.5      17.0      14.8      12.0       9.0       6.5
       4.3       2.5       1.2       0.4       0.0
`;

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/core/render/PBR/PBR.ts

var PBR_defProp = Object.defineProperty;
var PBR_defProps = Object.defineProperties;
var PBR_getOwnPropDescs = Object.getOwnPropertyDescriptors;
var PBR_getOwnPropSymbols = Object.getOwnPropertySymbols;
var PBR_hasOwnProp = Object.prototype.hasOwnProperty;
var PBR_propIsEnum = Object.prototype.propertyIsEnumerable;
var PBR_defNormalProp = (obj, key, value) => key in obj ? PBR_defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var PBR_spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (PBR_hasOwnProp.call(b, prop))
      PBR_defNormalProp(a, prop, b[prop]);
  if (PBR_getOwnPropSymbols)
    for (var prop of PBR_getOwnPropSymbols(b)) {
      if (PBR_propIsEnum.call(b, prop))
        PBR_defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var PBR_spreadProps = (a, b) => PBR_defProps(a, PBR_getOwnPropDescs(b));











const PHYSICAL_CAMERA_UPDATE = (options) => {
  const { camera, params } = options;
  const { apertureBlades, fStop, focusDistance, apertureRotation, anamorphicRatio } = params;
  camera.apertureBlades = apertureBlades;
  camera.fStop = fStop;
  camera.focusDistance = focusDistance;
  camera.apertureRotation = apertureRotation;
  camera.anamorphicRatio = anamorphicRatio;
};
const PHYSICAL_SPOT_LIGHT_UPDATE = (options) => {
  const { spotLight } = options;
  spotLight.iesTexture = new IESLoader/* IESLoader */.a().parse(IES_PROFILE_LM_63_1995);
};
function onPBRModuleRegister(poly) {
  CoreSceneObjectsFactory/* CoreSceneObjectsFactory.registerGenerator */.b.registerGenerator(CoreSceneObjectsFactory/* GeneratorName.PERSPECTIVE_CAMERA */.D.PERSPECTIVE_CAMERA, (options) => {
    const { fov, aspect, near, far } = options;
    (0,Constant/* registerObjectType */.UX)({
      type: Constant/* ObjectType.PERSPECTIVE_CAMERA */.LP.PERSPECTIVE_CAMERA,
      checkFunc: (o) => {
        if (o.isPerspectiveCamera) {
          return Constant/* ObjectType.PERSPECTIVE_CAMERA */.LP.PERSPECTIVE_CAMERA;
        }
      },
      ctor: three_module.PerspectiveCamera,
      humanName: "PerspectiveCamera"
    });
    (0,Constant/* registerObjectType */.UX)({
      type: Constant/* ObjectType.PHYSICAL_CAMERA */.LP.PHYSICAL_CAMERA,
      checkFunc: (o) => {
        if (o.bokehSize != null) {
          return Constant/* ObjectType.PHYSICAL_CAMERA */.LP.PHYSICAL_CAMERA;
        }
      },
      ctor: PhysicalCamera/* PhysicalCamera */.U,
      humanName: "PhysicalCamera"
    });
    return new PhysicalCamera/* PhysicalCamera */.U(fov, aspect, near, far);
  });
  CoreSceneObjectsFactory/* CoreSceneObjectsFactory.registerGenerator */.b.registerGenerator(CoreSceneObjectsFactory/* GeneratorName.PERSPECTIVE_CAMERA_UPDATE */.D.PERSPECTIVE_CAMERA_UPDATE, PHYSICAL_CAMERA_UPDATE);
  CoreSceneObjectsFactory/* CoreSceneObjectsFactory.registerGenerator */.b.registerGenerator(CoreSceneObjectsFactory/* GeneratorName.AREA_LIGHT */.D.AREA_LIGHT, (options) => {
    const { color, intensity, width, height } = options;
    (0,Constant/* registerObjectType */.UX)({
      type: Constant/* ObjectType.AREA_LIGHT */.LP.AREA_LIGHT,
      checkFunc: (o) => {
        if (o.isCircular) {
          return Constant/* ObjectType.SHAPED_AREA_LIGHT */.LP.SHAPED_AREA_LIGHT;
        }
      },
      ctor: ShapedAreaLight/* ShapedAreaLight */.I,
      humanName: "ShapedAreaLight"
    });
    return new ShapedAreaLight/* ShapedAreaLight */.I(color, intensity, width, height);
  });
  CoreSceneObjectsFactory/* CoreSceneObjectsFactory.registerGenerator */.b.registerGenerator(CoreSceneObjectsFactory/* GeneratorName.SPOT_LIGHT */.D.SPOT_LIGHT, () => {
    (0,Constant/* registerObjectType */.UX)({
      type: Constant/* ObjectType.PHYSICAL_SPOT_LIGHT */.LP.PHYSICAL_SPOT_LIGHT,
      checkFunc: (o) => {
        if (o.iesTexture) {
          return Constant/* ObjectType.PHYSICAL_SPOT_LIGHT */.LP.PHYSICAL_SPOT_LIGHT;
        }
      },
      ctor: PhysicalSpotLight/* PhysicalSpotLight */.J,
      humanName: Constant/* ObjectType.PHYSICAL_SPOT_LIGHT */.LP.PHYSICAL_SPOT_LIGHT
    });
    const physicalSpotLight = new PhysicalSpotLight/* PhysicalSpotLight */.J();
    (0,monkeyPatch_SpotLight/* monkeyPatchSpotLight */.C)(physicalSpotLight);
    return physicalSpotLight;
  });
  CoreSceneObjectsFactory/* CoreSceneObjectsFactory.registerGenerator */.b.registerGenerator(CoreSceneObjectsFactory/* GeneratorName.SPOT_LIGHT_UPDATE */.D.SPOT_LIGHT_UPDATE, PHYSICAL_SPOT_LIGHT_UPDATE);
  poly.registerCamera(
    PhysicalCamera/* PhysicalCamera */.U,
    (options) => {
      const { camera, scene, canvas } = options;
      const rendererNode = canvas ? CoreCameraRendererController/* CoreCameraRendererController.rendererNode */.K.rendererNode({
        camera,
        scene
      }) : void 0;
      if (rendererNode instanceof PathTracingRenderer/* PathTracingRendererRopNode */.A) {
        const viewer = new PathTracingViewer/* PathTracingViewer */.i(PBR_spreadProps(PBR_spreadValues({}, options), {
          updateCameraAspect: (aspect, resolution) => {
            CoreCameraPerspectiveFrameMode/* CoreCameraPerspectiveFrameMode.updateCameraAspect */.p.updateCameraAspect(options.camera, aspect, { resolution });
          }
        }));
        return viewer;
      } else {
        const viewer = new Threejs/* ThreejsViewer */.G(PBR_spreadProps(PBR_spreadValues({}, options), {
          updateCameraAspect: (aspect, resolution) => {
            CoreCameraPerspectiveFrameMode/* CoreCameraPerspectiveFrameMode.updateCameraAspect */.p.updateCameraAspect(options.camera, aspect, { resolution });
          }
        }));
        return viewer;
      }
    }
  );
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/poly/registers/modules/entryPoints/PBR.ts



const PBRModule = {
  moduleName: modules_Common/* ModuleName.PBR */.r.PBR,
  // module: cadModule,
  onRegister: onPBRModuleRegister
};


// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/nodes/utils/poly/PolyNodeController.ts
var PolyNodeController = __webpack_require__(69941);
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/anim/utils/poly/createPolyAnimNode.ts






function createPolyAnimNode(nodeType, definition, polyNodeControllerClass) {
  const ParamsConfig = PolyNodeParamsConfig.ParamsConfig(definition);
  class BasePolyAnimNode extends Subnet/* BaseSubnetAnimNode */.b {
    constructor() {
      super(...arguments);
      this.paramsConfig = ParamsConfig;
      this.polyNodeController = new polyNodeControllerClass(this, definition);
    }
    static type() {
      return nodeType;
    }
    requiredModules() {
      return [modules_Common/* ModuleName.POLY_ANIM */.r.POLY_ANIM];
    }
  }
  return BasePolyAnimNode;
}
function onPolyAnimModuleRegister(poly) {
  PolyNodeController/* PolyNodeController.registerCreatePolyNodeFunctionForContext */.C.registerCreatePolyNodeFunctionForContext(poly_NodeContext/* NodeContext.ANIM */.sy.ANIM, createPolyAnimNode);
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/poly/registers/modules/entryPoints/POLY_ANIM.ts



const POLY_ANIMModule = {
  moduleName: modules_Common/* ModuleName.POLY_ANIM */.r.POLY_ANIM,
  onRegister: onPolyAnimModuleRegister
};


;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/gl/utils/poly/createPolyGlNode.ts







function createPolyGlNode(nodeType, definition, polyNodeControllerClass) {
  class SubnetGlParamsConfig extends (0,gl_Subnet/* TypedSubnetGlParamsConfigMixin */.Qm)(params_ParamsConfig/* NodeParamsConfig */.yI) {
  }
  const ParamsConfig = PolyNodeParamsConfig.ParamsConfig(definition, SubnetGlParamsConfig);
  class BasePolyGlNode extends gl_Subnet/* AbstractTypedSubnetGlNode */.bZ {
    constructor() {
      super(...arguments);
      this.paramsConfig = ParamsConfig;
      this.polyNodeController = new polyNodeControllerClass(this, definition);
    }
    static type() {
      return nodeType;
    }
    requiredModules() {
      return [modules_Common/* ModuleName.POLY_GL */.r.POLY_GL];
    }
    _expectedInputTypes() {
      var _a, _b;
      return ((_b = (_a = definition.inputs) == null ? void 0 : _a.typed) == null ? void 0 : _b.types.map((t) => t.type)) || [];
    }
    _expectedInputName(index) {
      var _a, _b;
      const names = ((_b = (_a = definition.inputs) == null ? void 0 : _a.typed) == null ? void 0 : _b.types.map((t) => t.name)) || [];
      return names[index];
    }
    _expectedOutputTypes() {
      return this._expectedInputTypes();
    }
    _expectedOutputName(index) {
      return this._expectedInputName(index);
    }
  }
  return BasePolyGlNode;
}
function onPolyGlModuleRegister(poly) {
  PolyNodeController/* PolyNodeController.registerCreatePolyNodeFunctionForContext */.C.registerCreatePolyNodeFunctionForContext(poly_NodeContext/* NodeContext.GL */.sy.GL, createPolyGlNode);
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/poly/registers/modules/entryPoints/POLY_GL.ts



const POLY_GLModule = {
  moduleName: modules_Common/* ModuleName.POLY_GL */.r.POLY_GL,
  onRegister: onPolyGlModuleRegister
};


;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/js/utils/poly/createPolyJsNode.ts







function createPolyJsNode(nodeType, definition, polyNodeControllerClass) {
  class SubnetJsParamsConfig extends (0,js_Subnet/* TypedSubnetJsParamsConfigMixin */.Du)(params_ParamsConfig/* NodeParamsConfig */.yI) {
  }
  const ParamsConfig = PolyNodeParamsConfig.ParamsConfig(definition, SubnetJsParamsConfig);
  class BasePolyJsNode extends js_Subnet/* TypedSubnetJsNode */.RY {
    constructor() {
      super(...arguments);
      this.paramsConfig = ParamsConfig;
      this.polyNodeController = new polyNodeControllerClass(this, definition);
    }
    static type() {
      return nodeType;
    }
    requiredModules() {
      return [modules_Common/* ModuleName.POLY_JS */.r.POLY_JS];
    }
    _expectedInputTypes() {
      var _a, _b;
      return ((_b = (_a = definition.inputs) == null ? void 0 : _a.typed) == null ? void 0 : _b.types.map((t) => t.type)) || [];
    }
    _expectedInputName(index) {
      var _a, _b;
      const names = ((_b = (_a = definition.inputs) == null ? void 0 : _a.typed) == null ? void 0 : _b.types.map((t) => t.name)) || [];
      return names[index];
    }
    _expectedOutputTypes() {
      return this._expectedInputTypes();
    }
    _expectedOutputName(index) {
      return this._expectedInputName(index);
    }
  }
  return BasePolyJsNode;
}
function onPolyJsModuleRegister(poly) {
  PolyNodeController/* PolyNodeController.registerCreatePolyNodeFunctionForContext */.C.registerCreatePolyNodeFunctionForContext(poly_NodeContext/* NodeContext.JS */.sy.JS, createPolyJsNode);
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/poly/registers/modules/entryPoints/POLY_JS.ts



const POLY_JSModule = {
  moduleName: modules_Common/* ModuleName.POLY_JS */.r.POLY_JS,
  onRegister: onPolyJsModuleRegister
};


// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/nodes/obj/utils/ObjChildrenDisplayController.ts
var ObjChildrenDisplayController = __webpack_require__(48327);
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/obj/utils/poly/createPolyObjNode.ts











function createPolyObjNode(nodeType, definition, polyNodeControllerClass) {
  const ParamsConfig = PolyNodeParamsConfig.ParamsConfig(definition);
  class BasePolyObjNode extends obj_Base/* TypedObjNode */.Mx {
    constructor() {
      super(...arguments);
      this.paramsConfig = ParamsConfig;
      this.hierarchyController = new HierarchyController/* HierarchyController */.O(this);
      this.flags = new FlagsController/* FlagsControllerD */.ZR(this);
      // display_node and children_display controllers
      this.childrenDisplayController = new ObjChildrenDisplayController/* ObjChildrenDisplayController */.U(this);
      this.displayNodeController = new DisplayNodeController/* DisplayNodeController */.v(
        this,
        this.childrenDisplayController.displayNodeControllerCallbacks()
      );
      //
      this._childrenControllerContext = poly_NodeContext/* NodeContext.SOP */.sy.SOP;
      //
      //
      // POLY
      //
      //
      this.polyNodeController = new polyNodeControllerClass(this, definition);
    }
    static type() {
      return nodeType;
    }
    requiredModules() {
      return [modules_Common/* ModuleName.POLY_OBJ */.r.POLY_OBJ];
    }
    createObject() {
      const group = new three_module.Group();
      group.matrixAutoUpdate = false;
      return group;
    }
    initializeNode() {
      this.hierarchyController.initializeNode();
      this.childrenDisplayController.initializeNode();
    }
    createNode(node_class, options) {
      return super.createNode(node_class, options);
    }
    children() {
      return super.children();
    }
    nodesByType(type) {
      return super.nodesByType(type);
    }
    //
    //
    // COOK
    //
    //
    cook() {
      this.cookController.endCook();
    }
  }
  return BasePolyObjNode;
}
function onPolyOBJModuleRegister(poly) {
  PolyNodeController/* PolyNodeController.registerCreatePolyNodeFunctionForContext */.C.registerCreatePolyNodeFunctionForContext(poly_NodeContext/* NodeContext.OBJ */.sy.OBJ, createPolyObjNode);
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/poly/registers/modules/entryPoints/POLY_OBJ.ts



const POLY_OBJModule = {
  moduleName: modules_Common/* ModuleName.POLY_OBJ */.r.POLY_OBJ,
  onRegister: onPolyOBJModuleRegister
};


// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/nodes/sop/utils/subnet/SopSubnetChildrenDisplayController.ts
var SopSubnetChildrenDisplayController = __webpack_require__(70677);
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/sop/utils/poly/createPolySopNode.ts






function createPolySopNode(nodeType, definition, polyNodeControllerClass) {
  const ParamsConfig = PolyNodeParamsConfig.ParamsConfig(definition);
  class BasePolySopNode extends SopSubnetChildrenDisplayController/* SubnetSopNodeLike */.e {
    constructor() {
      super(...arguments);
      this.paramsConfig = ParamsConfig;
      this.polyNodeController = new polyNodeControllerClass(this, definition);
    }
    static type() {
      return nodeType;
    }
    requiredModules() {
      return [modules_Common/* ModuleName.POLY_SOP */.r.POLY_SOP];
    }
    static displayedInputNames() {
      var _a, _b;
      return ((_b = (_a = definition.inputs) == null ? void 0 : _a.simple) == null ? void 0 : _b.names) || ["input geometries"];
    }
  }
  return BasePolySopNode;
}
function onPolySopModuleRegister(poly) {
  PolyNodeController/* PolyNodeController.registerCreatePolyNodeFunctionForContext */.C.registerCreatePolyNodeFunctionForContext(poly_NodeContext/* NodeContext.SOP */.sy.SOP, createPolySopNode);
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/poly/registers/modules/entryPoints/POLY_SOP.ts



const POLY_SOPModule = {
  moduleName: modules_Common/* ModuleName.POLY_SOP */.r.POLY_SOP,
  onRegister: onPolySopModuleRegister
};


// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/core/geometry/modules/quad/QuadCommon.ts
var QuadCommon = __webpack_require__(45199);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/core/geometry/modules/quad/QuadCoreObject.ts + 1 modules
var QuadCoreObject = __webpack_require__(63291);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/core/geometry/modules/quad/QuadPoint.ts
var QuadPoint = __webpack_require__(6188);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/core/geometry/modules/quad/QuadVertex.ts
var QuadVertex = __webpack_require__(54115);
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/core/geometry/modules/quad/QuadModule.ts











const QUAD_TESSELATION_PARAMS = {
  triangles: true,
  splitQuads: false,
  wireframe: true,
  wireframeColor: new three_module.Color(0, 0, 0),
  center: false,
  innerRadius: false,
  outerRadius: false,
  pointAttributes: "*",
  primitiveAttributes: "*"
};
function updateQUADTesselationParams(params) {
  QUAD_TESSELATION_PARAMS.triangles = params.QUADTriangles;
  QUAD_TESSELATION_PARAMS.splitQuads = params.QUADSplitQuads;
  QUAD_TESSELATION_PARAMS.wireframe = params.QUADWireframe;
  QUAD_TESSELATION_PARAMS.wireframeColor.copy(params.QUADWireframeColor);
  QUAD_TESSELATION_PARAMS.center = params.QUADCenter;
  QUAD_TESSELATION_PARAMS.innerRadius = params.QUADInnerRadius;
  QUAD_TESSELATION_PARAMS.outerRadius = params.QUADOuterRadius;
  QUAD_TESSELATION_PARAMS.pointAttributes = params.QUADPointAttributes;
  QUAD_TESSELATION_PARAMS.primitiveAttributes = params.QUADPrimitiveAttributes;
}
const QuadModule_onAddSpecializedChildren = (displayNode, coreGroup, newObjects, params) => {
  let newObjectsAreDifferent = false;
  const newQuadObjects = coreGroup.quadObjects();
  if (newQuadObjects && newQuadObjects.length != 0) {
    updateQUADTesselationParams(params);
    for (const quadObject of newQuadObjects) {
      const newObject3D = quadObject.toObject3D(QUAD_TESSELATION_PARAMS);
      if (newObject3D) {
        newObjectsAreDifferent = true;
        if ((0,Type/* isArray */.kJ)(newObject3D)) {
          newObjects.push(...newObject3D);
        } else {
          newObjects.push(newObject3D);
        }
      }
    }
  }
  return newObjectsAreDifferent;
};
function onQuadModuleRegister(poly) {
  const pointClassFactory = (object) => {
    if (QuadCommon/* QUAD_OBJECT_TYPES_SET.has */.Ji.has(object.type)) {
      return QuadPoint/* QuadPoint */.M;
    }
  };
  const pointInstanceFactory = (object, index = 0) => {
    if (QuadCommon/* QUAD_OBJECT_TYPES_SET.has */.Ji.has(object.type)) {
      return new QuadPoint/* QuadPoint */.M(object, index);
    }
  };
  const vertexClassFactory = (object) => {
    if (QuadCommon/* QUAD_OBJECT_TYPES_SET.has */.Ji.has(object.type)) {
      return QuadVertex/* QuadVertex */.L;
    }
  };
  const vertexInstanceFactory = (object, index = 0) => {
    if (QuadCommon/* QUAD_OBJECT_TYPES_SET.has */.Ji.has(object.type)) {
      return new QuadVertex/* QuadVertex */.L(object, index);
    }
  };
  const primitiveClassFactory = (object) => {
    if (QuadCommon/* QUAD_OBJECT_TYPES_SET.has */.Ji.has(object.type)) {
      return QuadPrimitive/* QuadPrimitive */.C;
    }
  };
  const primitiveInstanceFactory = (object, index = 0) => {
    if (QuadCommon/* QUAD_OBJECT_TYPES_SET.has */.Ji.has(object.type)) {
      return new QuadPrimitive/* QuadPrimitive */.C(object, index);
    }
  };
  const objectClassFactory = (object) => {
    if (QuadCommon/* QUAD_OBJECT_TYPES_SET.has */.Ji.has(object.type)) {
      return QuadCoreObject/* QuadCoreObject */.J;
    }
  };
  const objectInstanceFactory = (object, index = 0) => {
    if (QuadCommon/* QUAD_OBJECT_TYPES_SET.has */.Ji.has(object.type)) {
      return new QuadCoreObject/* QuadCoreObject */.J(object, index);
    }
  };
  const factoryFunction = {
    pointClass: pointClassFactory,
    pointInstance: pointInstanceFactory,
    vertexClass: vertexClassFactory,
    vertexInstance: vertexInstanceFactory,
    primitiveClass: primitiveClassFactory,
    primitiveInstance: primitiveInstanceFactory,
    objectClass: objectClassFactory,
    objectInstance: objectInstanceFactory
  };
  (0,CoreObjectFactory/* registerFactoryFunctions */.Sv)(factoryFunction);
  poly.specializedChildren.registerHook("QUAD", QuadModule_onAddSpecializedChildren);
  const type = "QuadObject";
  (0,Constant/* registerObjectType */.UX)({
    type,
    checkFunc: (o) => {
      if (QuadCommon/* QUAD_OBJECT_TYPES_SET.has */.Ji.has(o.type)) {
        return Constant/* ObjectType.QUAD */.LP.QUAD;
      }
    },
    ctor: QuadObject/* QuadObject */.n,
    humanName: "QuadObject"
  });
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/poly/registers/modules/entryPoints/QUAD.ts



const QUADModule = {
  moduleName: modules_Common/* ModuleName.QUAD */.r.QUAD,
  // module: cadModule,
  onRegister: onQuadModuleRegister
};


// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/core/geometry/modules/sdf/SDFCommon.ts
var SDFCommon = __webpack_require__(43941);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/core/geometry/modules/sdf/SDFObject.ts + 3 modules
var SDFObject = __webpack_require__(2181);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/core/geometry/modules/sdf/SDFLoaderSync.ts
var SDFLoaderSync = __webpack_require__(36078);
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/core/geometry/modules/sdf/SDFCoreObject.ts





const _box = new three_module.Box3();
class SDFCoreObject extends BaseCoreObject/* BaseCoreObject */.q {
  constructor(_object, index) {
    super(_object, index);
    this._object = _object;
  }
  static position(object, target) {
    object.boundingBox(_box);
    _box.getCenter(target);
  }
  boundingBox(target) {
    this._object.boundingBox(target);
  }
  boundingSphere(target) {
    this._object.boundingSphere(target);
  }
  static applyMatrix(object, matrix, transformTargetType, transformSpace, transformMode) {
    object.applyMatrix4(matrix);
  }
  static mergeCompact(options) {
    const manifold = SDFLoaderSync/* SDFLoaderSync.manifold */.m.manifold();
    const { objects, mergedObjects } = options;
    const sdfObjects = objects;
    let previousGeometry;
    for (const object of sdfObjects) {
      if (previousGeometry) {
        previousGeometry = manifold.union(previousGeometry, object.SDFGeometry());
      } else {
        previousGeometry = object.SDFGeometry();
      }
    }
    if (previousGeometry) {
      mergedObjects.push(new SDFObject/* SDFObject */.D(previousGeometry));
    }
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/core/geometry/modules/sdf/SDFPoint.ts


class SDFPoint extends CorePoint/* CorePoint */.A {
  constructor(object, index) {
    super(object, index);
    this._object = object;
    this._updateGeometry();
  }
  object() {
    return this._object;
  }
  setIndex(index, object) {
    this._index = index;
    if (object) {
      this._object = object;
      this._updateGeometry();
    }
    return this;
  }
  _updateGeometry() {
    const geometry = this._object.geometry;
    if (geometry) {
      this._geometry = geometry;
    }
  }
  geometry() {
    return this._geometry;
  }
  static addAttribute(object, attribName, attribute) {
  }
  static attributes(object) {
    return void 0;
  }
  static entitiesCount(object) {
    return 0;
  }
  position(target) {
    return target;
  }
  normal(target) {
    return target;
  }
  //
  //
  //
  //
  //
  static userDataAttribs(object) {
    return {};
  }
  static setIndexedAttribute(object, attribName, values, indices) {
  }
  static attribValueIndex(object, index, attribName) {
    return -1;
  }
  //
  //
  //
  //
  //
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/core/geometry/modules/sdf/SDFVertex.ts


class SDFVertex extends CoreVertex/* CoreVertex */.k {
  constructor(object, index) {
    super(object, index);
  }
  geometry() {
    return void 0;
  }
  static attributes(object) {
    return;
  }
  static entitiesCount(object) {
    return 0;
  }
  position(target) {
    console.warn("SDFVertex.position not implemented");
    return target;
  }
  normal(target) {
    console.warn("SDFVertex.normal not implemented");
    return target;
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/core/geometry/modules/sdf/SDFPrimitive.ts


class SDFPrimitive extends CorePrimitive/* CorePrimitive */.n {
  // public override _geometry?: QuadGeometryWithPrimitiveAttributes;
  constructor(object, index) {
    super(object, index);
  }
  geometry() {
    return this._object.geometry;
  }
  static entitiesCount(object) {
    return 0;
  }
  position(target) {
    console.warn("SDFPrimitive.position not implemented");
    return target;
  }
  normal(target) {
    console.warn("SDFPrimitive.normal not implemented");
    return target;
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/core/geometry/modules/sdf/SDFModule.ts







function onSDFModuleRegister(poly) {
  const pointClassFactory = (object) => {
    if (SDFCommon/* SDF_OBJECT_TYPES_SET.has */.Vr.has(object.type)) {
      return SDFPoint;
    }
  };
  const pointInstanceFactory = (object, index = 0) => {
    if (SDFCommon/* SDF_OBJECT_TYPES_SET.has */.Vr.has(object.type)) {
      return new SDFPoint(object, index);
    }
  };
  const vertexClassFactory = (object) => {
    if (SDFCommon/* SDF_OBJECT_TYPES_SET.has */.Vr.has(object.type)) {
      return SDFVertex;
    }
  };
  const vertexInstanceFactory = (object, index = 0) => {
    if (SDFCommon/* SDF_OBJECT_TYPES_SET.has */.Vr.has(object.type)) {
      return new SDFVertex(object, index);
    }
  };
  const primitiveClassFactory = (object) => {
    if (SDFCommon/* SDF_OBJECT_TYPES_SET.has */.Vr.has(object.type)) {
      return SDFPrimitive;
    }
  };
  const primitiveInstanceFactory = (object, index = 0) => {
    if (SDFCommon/* SDF_OBJECT_TYPES_SET.has */.Vr.has(object.type)) {
      return new SDFPrimitive(object, index);
    }
  };
  const objectClassFactory = (object) => {
    if (SDFCommon/* SDF_OBJECT_TYPES_SET.has */.Vr.has(object.type)) {
      return SDFCoreObject;
    }
  };
  const objectInstanceFactory = (object, index = 0) => {
    if (SDFCommon/* SDF_OBJECT_TYPES_SET.has */.Vr.has(object.type)) {
      return new SDFCoreObject(object, index);
    }
  };
  const factoryFunctions = {
    pointClass: pointClassFactory,
    pointInstance: pointInstanceFactory,
    vertexClass: vertexClassFactory,
    vertexInstance: vertexInstanceFactory,
    primitiveClass: primitiveClassFactory,
    primitiveInstance: primitiveInstanceFactory,
    objectClass: objectClassFactory,
    objectInstance: objectInstanceFactory
  };
  (0,CoreObjectFactory/* registerFactoryFunctions */.Sv)(factoryFunctions);
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/poly/registers/modules/entryPoints/SDF.ts



const SDFModule = {
  moduleName: modules_Common/* ModuleName.SDF */.r.SDF,
  // module: cadModule,
  onRegister: onSDFModuleRegister
};


;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/core/geometry/modules/tet/TetVertex.ts


class TetVertex extends CoreVertex/* CoreVertex */.k {
  constructor(object, index) {
    super(object, index);
    this._updateGeometry();
  }
  setIndex(index, object) {
    this._index = index;
    if (object) {
      this._object = object;
      this._updateGeometry();
    }
    return this;
  }
  _updateGeometry() {
    const geometry = this._object.geometry;
    if (geometry) {
      this._geometry = geometry;
    }
  }
  geometry() {
    return this._geometry;
  }
  static attributes(object) {
    return;
  }
  static entitiesCount(object) {
    return 0;
  }
  position(target) {
    console.warn("TetVertex.position not implemented");
    return target;
  }
  normal(target) {
    console.warn("TetVertex.normal not implemented");
    return target;
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/core/geometry/modules/tet/TetCoreObject.ts





const TetCoreObject_bbox = new three_module.Box3();
class TetCoreObject extends BaseCoreObject/* BaseCoreObject */.q {
  constructor(_object, index) {
    super(_object, index);
    this._object = _object;
  }
  static position(object, target) {
    object.boundingBox(TetCoreObject_bbox);
    TetCoreObject_bbox.getCenter(target);
  }
  boundingBox(target) {
    this._object.boundingBox(target);
  }
  boundingSphere(target) {
    this._object.boundingSphere(target);
  }
  static objectData(object) {
    const data = (0,BaseCoreObjectUtils/* objectData */.Sq)(object);
    const tetObject = object;
    data.pointsCount = tetObject.geometry.pointsCount();
    data.verticesCount = TetVertex.entitiesCount(object);
    data.primitivesCount = tetObject.geometry.tetsCount();
    data.primitiveName = "tetrahedron";
    return data;
  }
  static applyMatrix(object, matrix, transformTargetType, transformSpace, transformMode) {
    object.applyMatrix4(matrix);
  }
  static mergeCompact(options) {
    console.warn("mergeCompact not implemented");
  }
}

// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/core/geometry/modules/tet/TetCoreType.ts
var TetCoreType = __webpack_require__(25436);
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/core/geometry/modules/tet/TetPoint.ts


class TetPoint extends CorePoint/* CorePoint */.A {
  constructor(object, index) {
    super(object, index);
    this._object = object;
    this._updateGeometry();
  }
  object() {
    return this._object;
  }
  setIndex(index, object) {
    this._index = index;
    if (object) {
      this._object = object;
      this._updateGeometry();
    }
    return this;
  }
  _updateGeometry() {
    const geometry = this._object.geometry;
    if (geometry) {
      this._geometry = geometry;
    }
  }
  geometry() {
    return this._geometry;
  }
  static addAttribute(object, attribName, attribute) {
  }
  static attributes(object) {
    return void 0;
  }
  static entitiesCount(object) {
    return 0;
  }
  position(target) {
    return target;
  }
  normal(target) {
    return target;
  }
  //
  //
  //
  //
  //
  static userDataAttribs(object) {
    return {};
  }
  static setIndexedAttribute(object, attribName, values, indices) {
  }
  static attribValueIndex(object, index, attribName) {
    return -1;
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/core/geometry/modules/tet/builders/TetPrimitiveBuilder.ts




const currentEntities = [];
const tetObjectFromPrimitives = (object, entities) => {
  const tetObject = object;
  const geometry = tetObject.geometry;
  if (!geometry) {
    return void 0;
  }
  const entitiesCount = entities.length;
  const currentEntitiesIndices = (0,CorePrimitiveUtils/* primitivesFromObject */.Lp)(tetObject, currentEntities).map((e) => e.index());
  const newEntitiesIndices = entities.map((e, i2) => e.index());
  const currentEntitiesIndicesSet = new Set(currentEntitiesIndices);
  const newEntitiesIndicesSet = new Set(newEntitiesIndices);
  const toRemoveEntitiesIndicesSet = /* @__PURE__ */ new Set();
  (0,SetUtils/* setXOR */.l2)(currentEntitiesIndicesSet, newEntitiesIndicesSet, toRemoveEntitiesIndicesSet);
  const _tetrahedronsIds = [];
  let i = 0;
  geometry.tetrahedrons.forEach((tetrahedron, id) => {
    if (toRemoveEntitiesIndicesSet.has(i)) {
      _tetrahedronsIds.push(id);
    }
    i++;
  });
  geometry.removeTets(_tetrahedronsIds);
  const primitiveAttributes = TetPrimitive.attributes(object);
  if (primitiveAttributes) {
    const primitiveAttributeNames = Object.keys(primitiveAttributes);
    for (const primitiveAttributeName of primitiveAttributeNames) {
      const primitiveAttribute = primitiveAttributes[primitiveAttributeName];
      const itemSize = primitiveAttribute.itemSize;
      const srcArray = primitiveAttribute.array;
      const newArray = new Array(entitiesCount * itemSize);
      let i2 = 0;
      for (const entity of entities) {
        const index = entity.index();
        for (let k = 0; k < itemSize; k++) {
          newArray[i2 + k] = srcArray[index + k];
        }
        i2++;
      }
      primitiveAttribute.array = newArray;
    }
  }
  return tetObject;
};

// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/core/geometry/entities/utils/Common.ts
var utils_Common = __webpack_require__(84256);
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/core/geometry/modules/tet/TetPrimitive.ts






const TetPrimitive_target = {
  attributeAdded: false,
  values: []
};
class TetPrimitive extends CorePrimitive/* CorePrimitive */.n {
  // public override _geometry?: QuadGeometryWithPrimitiveAttributes;
  constructor(object, index) {
    super(object, index);
  }
  geometry() {
    return this._object.geometry;
  }
  builder() {
    return tetObjectFromPrimitives;
  }
  static entitiesCount(object) {
    return object.tetGeometry().tetsCount();
  }
  static position(tetObject, primitiveIndex, target2) {
    if (!(tetObject && tetObject.geometry)) {
      return target2;
    }
    (0,tetCenter/* tetCenter */.Ah)(tetObject.geometry, primitiveIndex, target2);
    return target2;
  }
  //
  //
  // ATTRIBUTES
  //
  //
  static addAttribute(object, attribName, attribute) {
    const attributes = this.attributes(object);
    if (!attributes) {
      return;
    }
    attributes[attribName] = attribute;
  }
  static addNumericAttribute(object, attribName, size = 1, defaultValue = 0) {
    const verticesCount = this.entitiesCount(object);
    TetPrimitive_target.values = new Array(verticesCount * size);
    (0,utils_Common/* attributeNumericValues */.ex)(object, CorePrimitiveUtils/* primitivesCountFromObject */.KL, size, defaultValue, TetPrimitive_target);
    const attribute = {
      isString: false,
      array: TetPrimitive_target.values,
      itemSize: size
    };
    this.addAttribute(object, attribName, attribute);
  }
  static attributesFromGeometry(geometry) {
    if (!geometry.userData.primAttributes) {
      geometry.userData.primAttributes = {};
    }
    return geometry.userData.primAttributes;
  }
  static attributes(object) {
    const geometry = object.geometry;
    if (!geometry) {
      return;
    }
    return this.attributesFromGeometry(geometry);
  }
  //
  //
  // POSITION AND NORMAL
  //
  //
  position(target2) {
    return this.constructor.position(this._object, this._index, target2);
  }
  normal(target2) {
    target2.set(0, 1, 0);
    return target2;
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/core/geometry/modules/tet/TetModule.ts








const TET_TESSELATION_PARAMS = {
  scale: 1,
  displayOuterMesh: true,
  displayTetMesh: false,
  displayLines: false,
  displaySharedFaces: false,
  displayPoints: false,
  displayCenter: false,
  displaySphere: false
};
function updateTetTesselationParams(params) {
  TET_TESSELATION_PARAMS.scale = params.TetScale;
  TET_TESSELATION_PARAMS.displayOuterMesh = params.TetDisplayOuterMesh;
  TET_TESSELATION_PARAMS.displayTetMesh = params.TetDisplayTetMesh;
  TET_TESSELATION_PARAMS.displayLines = params.TetDisplayLines;
  TET_TESSELATION_PARAMS.displaySharedFaces = params.TetDisplaySharedFaces;
  TET_TESSELATION_PARAMS.displayCenter = params.TetDisplayCenter;
  TET_TESSELATION_PARAMS.displayPoints = params.TetDisplayPoints;
  TET_TESSELATION_PARAMS.displayCenter = params.TetDisplayCenter;
  TET_TESSELATION_PARAMS.displaySphere = params.TetDisplaySphere;
}
const TetModule_onAddSpecializedChildren = (displayNode, coreGroup, newObjects, params) => {
  let newObjectsAreDifferent = false;
  const newTetObjects = coreGroup.tetObjects();
  if (newTetObjects && newTetObjects.length != 0) {
    updateTetTesselationParams(params);
    for (const tetObject of newTetObjects) {
      const newObject3D = tetObject.toObject3D(TET_TESSELATION_PARAMS);
      if (newObject3D) {
        newObjectsAreDifferent = true;
        if (Type/* CoreType.isArray */.MR.isArray(newObject3D)) {
          newObjects.push(...newObject3D);
        } else {
          newObjects.push(newObject3D);
        }
      }
    }
  }
  return newObjectsAreDifferent;
};
function onTetModuleRegister(poly) {
  const pointClassFactory = (object) => {
    if ((0,TetCoreType/* isTetObject */.J)(object)) {
      return TetPoint;
    }
  };
  const pointInstanceFactory = (object, index = 0) => {
    if ((0,TetCoreType/* isTetObject */.J)(object)) {
      return new TetPoint(object, index);
    }
  };
  const vertexClassFactory = (object) => {
    if ((0,TetCoreType/* isTetObject */.J)(object)) {
      return TetVertex;
    }
  };
  const vertexInstanceFactory = (object, index = 0) => {
    if ((0,TetCoreType/* isTetObject */.J)(object)) {
      return new TetVertex(object, index);
    }
  };
  const primitiveClassFactory = (object) => {
    if ((0,TetCoreType/* isTetObject */.J)(object)) {
      return TetPrimitive;
    }
  };
  const primitiveInstanceFactory = (object, index = 0) => {
    if ((0,TetCoreType/* isTetObject */.J)(object)) {
      return new TetPrimitive(object, index);
    }
  };
  const objectClassFactory = (object) => {
    if ((0,TetCoreType/* isTetObject */.J)(object)) {
      return TetCoreObject;
    }
  };
  const objectInstanceFactory = (object, index = 0) => {
    if ((0,TetCoreType/* isTetObject */.J)(object)) {
      return new TetCoreObject(object, index);
    }
  };
  const factoryFunctions = {
    pointClass: pointClassFactory,
    pointInstance: pointInstanceFactory,
    vertexClass: vertexClassFactory,
    vertexInstance: vertexInstanceFactory,
    primitiveClass: primitiveClassFactory,
    primitiveInstance: primitiveInstanceFactory,
    objectClass: objectClassFactory,
    objectInstance: objectInstanceFactory
  };
  (0,CoreObjectFactory/* registerFactoryFunctions */.Sv)(factoryFunctions);
  poly.specializedChildren.registerHook("TET", TetModule_onAddSpecializedChildren);
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/poly/registers/modules/entryPoints/TET.ts



const TETModule = {
  moduleName: modules_Common/* ModuleName.TET */.r.TET,
  // module: cadModule,
  onRegister: onTetModuleRegister
};


;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/poly/registers/modules/All.ts













class AllModulesRegister {
  static run(poly) {
    poly.registerModule(CADModule);
    poly.registerModule(CSGModule);
    poly.registerModule(GSAPModule);
    poly.registerModule(PBRModule);
    poly.registerModule(POLY_ANIMModule);
    poly.registerModule(POLY_GLModule);
    poly.registerModule(POLY_JSModule);
    poly.registerModule(POLY_OBJModule);
    poly.registerModule(POLY_SOPModule);
    poly.registerModule(QUADModule);
    poly.registerModule(SDFModule);
    poly.registerModule(TETModule);
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/poly/registers/All.ts

var registers_All_async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};








class AllRegister {
  static registerAll() {
    return registers_All_async(this, null, function* () {
      if (this._started) {
        return;
      }
      this._started = true;
      AllNodesRegister.run(Poly/* Poly */.L);
      AllCamerasRegister.run(Poly/* Poly */.L);
      AllExpressionsRegister.run(Poly/* Poly */.L);
      AllNamedFunctionRegister.run(Poly/* Poly */.L);
      const noAssemblers = FeaturesController/* CoreFeaturesController.noAssemblers */.A.noAssemblers();
      if (!noAssemblers) {
        AllAssemblersRegister.run(Poly/* Poly */.L);
      }
      AllModulesRegister.run(Poly/* Poly */.L);
    });
  }
}
AllRegister._started = false;


/***/ })

}])
//# sourceMappingURL=_polygonjs_polygonjs_src_engine_poly_registers_All_ts.151f853ff610e0bbb36a.js.map