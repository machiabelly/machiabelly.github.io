(self["webpackChunk"] = self["webpackChunk"] || []).push([["src_editor_components_panels_animation_AnimationCore_vue"],{

/***/ 71350:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

const { createElementVNode: _createElementVNode, openBlock: _openBlock, createElementBlock: _createElementBlock } = __webpack_require__(61043)

module.exports = function render(_ctx, _cache) {
  return (_openBlock(), _createElementBlock("svg", {
    xmlns: "http://www.w3.org/2000/svg",
    fill: "none",
    viewBox: "0 0 24 24",
    "stroke-width": "1.5",
    stroke: "currentColor",
    "aria-hidden": "true"
  }, [
    _createElementVNode("path", {
      "stroke-linecap": "round",
      "stroke-linejoin": "round",
      d: "M19.5 8.25l-7.5 7.5-7.5-7.5"
    })
  ]))
}

/***/ }),

/***/ 98874:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

const { createElementVNode: _createElementVNode, openBlock: _openBlock, createElementBlock: _createElementBlock } = __webpack_require__(61043)

module.exports = function render(_ctx, _cache) {
  return (_openBlock(), _createElementBlock("svg", {
    xmlns: "http://www.w3.org/2000/svg",
    fill: "none",
    viewBox: "0 0 24 24",
    "stroke-width": "1.5",
    stroke: "currentColor",
    "aria-hidden": "true"
  }, [
    _createElementVNode("path", {
      "stroke-linecap": "round",
      "stroke-linejoin": "round",
      d: "M4.5 15.75l7.5-7.5 7.5 7.5"
    })
  ]))
}

/***/ }),

/***/ 11382:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

const { createElementVNode: _createElementVNode, openBlock: _openBlock, createElementBlock: _createElementBlock } = __webpack_require__(61043)

module.exports = function render(_ctx, _cache) {
  return (_openBlock(), _createElementBlock("svg", {
    xmlns: "http://www.w3.org/2000/svg",
    fill: "none",
    viewBox: "0 0 24 24",
    "stroke-width": "1.5",
    stroke: "currentColor",
    "aria-hidden": "true"
  }, [
    _createElementVNode("path", {
      "stroke-linecap": "round",
      "stroke-linejoin": "round",
      d: "M2.036 12.322a1.012 1.012 0 010-.639C3.423 7.51 7.36 4.5 12 4.5c4.638 0 8.573 3.007 9.963 7.178.07.207.07.431 0 .639C20.577 16.49 16.64 19.5 12 19.5c-4.638 0-8.573-3.007-9.963-7.178z"
    }),
    _createElementVNode("path", {
      "stroke-linecap": "round",
      "stroke-linejoin": "round",
      d: "M15 12a3 3 0 11-6 0 3 3 0 016 0z"
    })
  ]))
}

/***/ }),

/***/ 79514:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

const { createElementVNode: _createElementVNode, openBlock: _openBlock, createElementBlock: _createElementBlock } = __webpack_require__(61043)

module.exports = function render(_ctx, _cache) {
  return (_openBlock(), _createElementBlock("svg", {
    xmlns: "http://www.w3.org/2000/svg",
    fill: "none",
    viewBox: "0 0 24 24",
    "stroke-width": "1.5",
    stroke: "currentColor",
    "aria-hidden": "true"
  }, [
    _createElementVNode("path", {
      "stroke-linecap": "round",
      "stroke-linejoin": "round",
      d: "M3.98 8.223A10.477 10.477 0 001.934 12C3.226 16.338 7.244 19.5 12 19.5c.993 0 1.953-.138 2.863-.395M6.228 6.228A10.45 10.45 0 0112 4.5c4.756 0 8.773 3.162 10.065 7.498a10.523 10.523 0 01-4.293 5.774M6.228 6.228L3 3m3.228 3.228l3.65 3.65m7.894 7.894L21 21m-3.228-3.228l-3.65-3.65m0 0a3 3 0 10-4.243-4.243m4.242 4.242L9.88 9.88"
    })
  ]))
}

/***/ }),

/***/ 54949:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

const { createElementVNode: _createElementVNode, openBlock: _openBlock, createElementBlock: _createElementBlock } = __webpack_require__(61043)

module.exports = function render(_ctx, _cache) {
  return (_openBlock(), _createElementBlock("svg", {
    xmlns: "http://www.w3.org/2000/svg",
    fill: "none",
    viewBox: "0 0 24 24",
    "stroke-width": "1.5",
    stroke: "currentColor",
    "aria-hidden": "true"
  }, [
    _createElementVNode("path", {
      "stroke-linecap": "round",
      "stroke-linejoin": "round",
      d: "M19.5 12h-15"
    })
  ]))
}

/***/ }),

/***/ 55269:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

const { createElementVNode: _createElementVNode, openBlock: _openBlock, createElementBlock: _createElementBlock } = __webpack_require__(61043)

module.exports = function render(_ctx, _cache) {
  return (_openBlock(), _createElementBlock("svg", {
    xmlns: "http://www.w3.org/2000/svg",
    fill: "none",
    viewBox: "0 0 24 24",
    "stroke-width": "1.5",
    stroke: "currentColor",
    "aria-hidden": "true"
  }, [
    _createElementVNode("path", {
      "stroke-linecap": "round",
      "stroke-linejoin": "round",
      d: "M12 4.5v15m7.5-7.5h-15"
    })
  ]))
}

/***/ }),

/***/ 80941:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

const { createElementVNode: _createElementVNode, openBlock: _openBlock, createElementBlock: _createElementBlock } = __webpack_require__(61043)

module.exports = function render(_ctx, _cache) {
  return (_openBlock(), _createElementBlock("svg", {
    xmlns: "http://www.w3.org/2000/svg",
    fill: "none",
    viewBox: "0 0 24 24",
    "stroke-width": "1.5",
    stroke: "currentColor",
    "aria-hidden": "true"
  }, [
    _createElementVNode("path", {
      "stroke-linecap": "round",
      "stroke-linejoin": "round",
      d: "M14.74 9l-.346 9m-4.788 0L9.26 9m9.968-3.21c.342.052.682.107 1.022.166m-1.022-.165L18.16 19.673a2.25 2.25 0 01-2.244 2.077H8.084a2.25 2.25 0 01-2.244-2.077L4.772 5.79m14.456 0a48.108 48.108 0 00-3.478-.397m-12 .562c.34-.059.68-.114 1.022-.165m0 0a48.11 48.11 0 013.478-.397m7.5 0v-.916c0-1.18-.91-2.164-2.09-2.201a51.964 51.964 0 00-3.32 0c-1.18.037-2.09 1.022-2.09 2.201v.916m7.5 0a48.667 48.667 0 00-7.5 0"
    })
  ]))
}

/***/ }),

/***/ 31369:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {


// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  "$": function() { return /* binding */ Channel; }
});

// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/core/keyframes/KeyframeCommon.ts
var KeyframeCommon = __webpack_require__(21555);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/node_modules/three/build/three.module.js
var three_module = __webpack_require__(21410);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/core/keyframes/KeyframeTangent.ts
var KeyframeTangent = __webpack_require__(4726);
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/core/keyframes/channel/Cubic.ts



const _v2 = new three_module.Vector2();
const _endPt0 = new three_module.Vector2();
const _endPt1 = new three_module.Vector2();
const curve = new three_module.CubicBezierCurve(new three_module.Vector2(), new three_module.Vector2(), new three_module.Vector2(), new three_module.Vector2());
const setCurveFromKeyframePairCubic = (keyframeStart, keyframeEnd) => {
  (0,KeyframeTangent/* keyframeTangentToEndPoint */.Y2)(keyframeStart, false, _endPt0);
  (0,KeyframeTangent/* keyframeTangentToEndPoint */.Y2)(keyframeEnd, true, _endPt1);
  curve.v0.x = keyframeStart.pos;
  curve.v0.y = keyframeStart.value;
  curve.v1.x = keyframeStart.pos + _endPt0.x;
  curve.v1.y = keyframeStart.value + _endPt0.y;
  curve.v3.x = keyframeEnd.pos;
  curve.v3.y = keyframeEnd.value;
  curve.v2.x = keyframeEnd.pos - _endPt1.x;
  curve.v2.y = keyframeEnd.value - _endPt1.y;
};
function getX(t, curve2) {
  curve2.getPoint(t, _v2);
  return _v2.x;
}
const MAX_ITERATIONS = 500;
const EPSILON = 1e-6;
const range = { min: 0, max: 1 };
function findTForXCubic(expectedX) {
  const curveStartPos = curve.v0.x;
  const curveEndPos = curve.v3.x;
  range.min = curveStartPos;
  range.max = curveEndPos;
  function _normalizePos(_pos) {
    return (_pos - curveStartPos) / (curveEndPos - curveStartPos);
  }
  let currentX = expectedX;
  for (let iteration = 0; iteration < MAX_ITERATIONS; iteration++) {
    const foundX = getX(_normalizePos(currentX), curve);
    const delta = foundX - expectedX;
    if (Math.abs(delta) < EPSILON) {
      return _normalizePos(currentX);
    }
    if (foundX < expectedX) {
      range.min = currentX;
      currentX = (range.max + currentX) / 2;
    } else {
      range.max = currentX;
      currentX = (range.min + currentX) / 2;
    }
  }
  return _normalizePos(currentX);
}
function getValueCubic(pos) {
  const t = findTForXCubic(pos);
  curve.getPoint(t, _v2);
  return _v2.y;
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/core/keyframes/channel/Linear.ts


const Linear_curve = new three_module.LineCurve(new three_module.Vector2(), new three_module.Vector2());
const setCurveFromKeyframePairLinear = (keyframeStart, keyframeEnd) => {
  Linear_curve.v1.x = keyframeStart.pos;
  Linear_curve.v1.y = keyframeStart.value;
  Linear_curve.v2.x = keyframeEnd.pos;
  Linear_curve.v2.y = keyframeEnd.value;
};
function getValueLinear(pos) {
  const curveStartPos = Linear_curve.v1.x;
  const curveEndPos = Linear_curve.v2.x;
  const t = (pos - curveStartPos) / (curveEndPos - curveStartPos);
  const value = t * Linear_curve.v2.y + (1 - t) * Linear_curve.v1.y;
  return value;
}

// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/core/math/_Module.ts
var _Module = __webpack_require__(27462);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/core/MapUtils.ts
var MapUtils = __webpack_require__(94158);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/core/keyframes/KeyframeSerialize.ts
var KeyframeSerialize = __webpack_require__(33382);
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/core/keyframes/Channel.ts







class Channel {
  constructor(data) {
    this.data = data;
    this._valuesByPos = /* @__PURE__ */ new Map();
    this._setCurveCallback = setCurveFromKeyframePairLinear;
    this._getValueCallback = getValueLinear;
    Channel.validate(this.data);
    this.compute();
  }
  static fromJSON(data) {
    return new Channel(data);
  }
  value(t) {
    if (t == Math.floor(t)) {
      const value = this._valuesByPos.get(t);
      if (value != null) {
        return value;
      }
      const keyframes = this.data.keyframes;
      if (keyframes.length == 0) {
        return 0;
      }
      const firstPos = keyframes[0].pos;
      const lastPos = keyframes[keyframes.length - 1].pos;
      if (t < firstPos) {
        return this._valuesByPos.get(firstPos) || 0;
      }
      if (t > lastPos) {
        return this._valuesByPos.get(lastPos) || 0;
      }
    }
    const t0 = Math.floor(t);
    const t1 = Math.ceil(t);
    const v0 = this._valuesByPos.get(t0) || 0;
    const v1 = this._valuesByPos.get(t1) || 0;
    return (0,_Module/* mix */.CD)(v0, v1, t - t0);
  }
  static validate(data) {
    let keyframes = data.keyframes;
    const keyframesByPos = /* @__PURE__ */ new Map();
    for (const keyframe of keyframes) {
      MapUtils/* MapUtils.pushOnArrayAtEntry */.pl.pushOnArrayAtEntry(keyframesByPos, keyframe.pos, keyframe);
    }
    if (keyframes.length != keyframesByPos.size) {
      const expectedSize = keyframesByPos.size;
      const keptKeyframes = new Array(expectedSize);
      let i2 = 0;
      keyframesByPos.forEach((keyframes2, pos) => {
        keptKeyframes[i2] = keyframes2[0];
        i2++;
      });
      keyframes = keptKeyframes;
      data.keyframes.splice(expectedSize, data.keyframes.length - expectedSize);
    }
    const sortedKeyframes = keyframes.sort((k1, k2) => k1.pos - k2.pos).map((k) => {
      const target = (0,KeyframeSerialize/* createKeyframeData */.f7)();
      (0,KeyframeSerialize/* copyKeyframeData */.ik)(k, target);
      return target;
    });
    let i = 0;
    for (const keyframe of sortedKeyframes) {
      (0,KeyframeSerialize/* copyKeyframeData */.ik)(keyframe, data.keyframes[i]);
      i++;
    }
  }
  _setCallbacks() {
    switch (this.data.interpolation) {
      case KeyframeCommon/* ChannelInterpolation.CUBIC */.M.CUBIC: {
        this._setCurveCallback = setCurveFromKeyframePairCubic;
        this._getValueCallback = getValueCubic;
        return;
      }
      case KeyframeCommon/* ChannelInterpolation.LINEAR */.M.LINEAR: {
        this._setCurveCallback = setCurveFromKeyframePairLinear;
        this._getValueCallback = getValueLinear;
        return;
      }
    }
  }
  compute() {
    Channel.validate(this.data);
    const keyframes = this.data.keyframes;
    if (keyframes.length == 0) {
      return;
    }
    this._setCallbacks();
    const firstPos = keyframes[0].pos;
    const lastPos = keyframes[keyframes.length - 1].pos;
    this._valuesByPos.clear();
    if (keyframes.length == 0) {
      return;
    }
    if (keyframes.length == 1) {
      this._valuesByPos.set(keyframes[0].pos, keyframes[0].value);
      return;
    }
    let segmentIndex = 0;
    const keyframePair = { start: keyframes[0], end: keyframes[1] };
    this._setCurveCallback(keyframePair.start, keyframePair.end);
    for (let pos = firstPos; pos <= lastPos; pos++) {
      if (pos > keyframePair.end.pos) {
        segmentIndex++;
        keyframePair.start = keyframePair.end;
        keyframePair.end = keyframes[segmentIndex + 1];
        this._setCurveCallback(keyframePair.start, keyframePair.end);
      }
      const value = this._getValueCallback(pos);
      this._valuesByPos.set(pos, value);
    }
  }
  // private _computeValue(pos: number, curve: CubicBezierCurve): number {
  // 	const t = this._findTForXCallback(pos, curve);
  // 	curve.getPoint(t, _v2);
  // 	console.log(pos, t, _v2.x, _v2.y);
  // 	return _v2.y;
  // }
}


/***/ }),

/***/ 17009:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "M": function() { return /* binding */ CSS2DRenderer; }
/* harmony export */ });
/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(21410);


const _vector = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();
const _viewMatrix = new three__WEBPACK_IMPORTED_MODULE_0__.Matrix4();
const _viewProjectionMatrix = new three__WEBPACK_IMPORTED_MODULE_0__.Matrix4();
const _a = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();
const _b = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();
class CSS2DRenderer {
  constructor(parameters = {}) {
    this._width = 0;
    this._height = 0;
    this._widthHalf = 0;
    this._heightHalf = 0;
    this.dataByObject = /* @__PURE__ */ new WeakMap();
    this.appendedObjects = /* @__PURE__ */ new Set();
    this.objectsToRender = /* @__PURE__ */ new Set();
    this.objectsToRemove = /* @__PURE__ */ new Set();
    const domElement = parameters.element !== void 0 ? parameters.element : document.createElement("div");
    domElement.style.overflow = "hidden";
    this.domElement = domElement;
  }
  getSize() {
    return {
      width: this._width,
      height: this._height
    };
  }
  render(scene, camera) {
    _viewMatrix.copy(camera.matrixWorldInverse);
    _viewProjectionMatrix.multiplyMatrices(camera.projectionMatrix, _viewMatrix);
    this.removeElementsDeletedFromSceneGraph(scene);
    this.renderObject(scene, scene, camera);
    this.zOrder(scene);
  }
  removeElementsDeletedFromSceneGraph(scene) {
    this.objectsToRender.clear();
    scene.traverse((object) => {
      if (object.isCSS2DObject) {
        this.objectsToRender.add(object);
      }
    });
    this.objectsToRemove.clear();
    this.appendedObjects.forEach((appendedObject) => {
      if (!this.objectsToRender.has(appendedObject)) {
        this.objectsToRemove.add(appendedObject);
      }
    });
    this.objectsToRemove.forEach((object) => {
      this.domElement.removeChild(object.element);
      this.appendedObjects.delete(object);
    });
  }
  setSize(width, height) {
    this._width = width;
    this._height = height;
    this._widthHalf = this._width / 2;
    this._heightHalf = this._height / 2;
    this.domElement.style.width = width + "px";
    this.domElement.style.height = height + "px";
  }
  renderObject(object, scene, camera) {
    if (object.isCSS2DObject) {
      _vector.setFromMatrixPosition(object.matrixWorld);
      _vector.applyMatrix4(_viewProjectionMatrix);
      const visible = object.visible === true && _vector.z >= -1 && _vector.z <= 1 && object.layers.test(camera.layers) === true;
      object.element.style.display = visible === true ? "" : "none";
      if (visible === true) {
        object.onBeforeRender(this, scene, camera);
        const element = object.element;
        element.style.transform = "translate(-50%,-50%) translate(" + (_vector.x * this._widthHalf + this._widthHalf) + "px," + (-_vector.y * this._heightHalf + this._heightHalf) + "px)";
        if (element.parentNode !== this.domElement) {
          this.domElement.appendChild(element);
          this.appendedObjects.add(object);
        }
        object.onAfterRender(this, scene, camera);
      }
      let objectData = this.dataByObject.get(object);
      const distanceToCameraSquared = this.getDistanceToSquared(camera, object);
      if (!objectData) {
        objectData = {
          distanceToCameraSquared
        };
        this.dataByObject.set(object, objectData);
      } else {
        objectData.distanceToCameraSquared = distanceToCameraSquared;
      }
    }
    for (const child of object.children) {
      this.renderObject(child, scene, camera);
    }
  }
  getDistanceToSquared(object1, object2) {
    _a.setFromMatrixPosition(object1.matrixWorld);
    _b.setFromMatrixPosition(object2.matrixWorld);
    return _a.distanceToSquared(_b);
  }
  filterAndFlatten(scene) {
    const result = [];
    scene.traverse(function(object) {
      if (object.isCSS2DObject)
        result.push(object);
    });
    return result;
  }
  zOrder(scene) {
    const sorted = this.filterAndFlatten(scene).sort((a, b) => {
      var _a2, _b2;
      if (a.renderOrder !== b.renderOrder) {
        return b.renderOrder - a.renderOrder;
      }
      const distanceA = ((_a2 = this.dataByObject.get(a)) == null ? void 0 : _a2.distanceToCameraSquared) || 0;
      const distanceB = ((_b2 = this.dataByObject.get(b)) == null ? void 0 : _b2.distanceToCameraSquared) || 0;
      return distanceA - distanceB;
    });
    const zMax = sorted.length;
    for (let i = 0, l = sorted.length; i < l; i++) {
      sorted[i].element.style.zIndex = `${zMax - i}`;
    }
  }
}


/***/ }),

/***/ 21168:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "D": function() { return /* binding */ SetupLayoutDataParentComponent; },
/* harmony export */   "H": function() { return /* binding */ SetupLayoutDataCore; }
/* harmony export */ });
/* harmony import */ var vue__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(88917);

var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));

function SetupLayoutDataParentComponent(options) {
  const { animationCore, setupLinkIndex } = options;
  function fromJSON(json) {
    console.log("network fromJSON", json);
    if (animationCore.value) {
      animationCore.value.fromJSON(json);
    }
  }
  function layoutData() {
    if (animationCore.value) {
      return __spreadProps(__spreadValues({}, animationCore.value.layoutData()), {
        linkIndex: setupLinkIndex.linkIndex.value
      });
    } else {
      return {
        linkIndex: setupLinkIndex.linkIndex.value
        //camera: {position: {x: 0, y: 0}, zoom: 1},
        //history: {},
        //paramsDisplayed: false,
      };
    }
  }
  return { fromJSON, layoutData };
}
function SetupLayoutDataCore(options) {
  const { props, setupLinkIndex } = options;
  (0,vue__WEBPACK_IMPORTED_MODULE_0__/* .onBeforeMount */ .wF)(() => {
    fromJSON(props.init_layout_data);
  });
  function fromJSON(json) {
    setupLinkIndex.fromJSON(json);
  }
  function layoutData() {
    return __spreadValues({}, setupLinkIndex.toJSON());
  }
  return { fromJSON, layoutData };
}


/***/ }),

/***/ 42882:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {


// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  "Z": function() { return /* binding */ AnimationCore; }
});

// EXTERNAL MODULE: ../node_modules/@vue/runtime-core/dist/runtime-core.esm-bundler.js
var runtime_core_esm_bundler = __webpack_require__(88917);
// EXTERNAL MODULE: ../node_modules/@vue/runtime-core/node_modules/@vue/shared/dist/shared.esm-bundler.js
var shared_esm_bundler = __webpack_require__(13053);
// EXTERNAL MODULE: ../node_modules/@vue/runtime-dom/dist/runtime-dom.esm-bundler.js + 1 modules
var runtime_dom_esm_bundler = __webpack_require__(90996);
;// CONCATENATED MODULE: ../node_modules/esbuild-loader/dist/index.cjs??clonedRuleSet-2.use[0]!../node_modules/vue-loader/dist/templateLoader.js??ruleSet[1].rules[2]!../node_modules/vue-loader/dist/index.js??ruleSet[1].rules[14].use[0]!../src/editor/components/panels/animation/AnimationCore.vue?vue&type=template&id=2d45f6de&ts=true

const _hoisted_1 = { class: "text-right mb-1 leading-none text-white" };
const _hoisted_2 = ["disabled"];
const _hoisted_3 = ["disabled"];
const _hoisted_4 = /* @__PURE__ */ (0,runtime_core_esm_bundler/* createElementVNode */._)(
  "span",
  { class: "mx-1" },
  null,
  -1
  /* HOISTED */
);
const _hoisted_5 = ["disabled"];
const _hoisted_6 = ["disabled"];
const _hoisted_7 = { key: 2 };
const _hoisted_8 = { key: 3 };
const _hoisted_9 = { class: "grow flex w-full max-w-full" };
const _hoisted_10 = { class: "mb-1" };
const _hoisted_11 = { class: "text-xs disable-select text-text-faded whitespace-nowrap" };
const _hoisted_12 = ["onClick"];
const _hoisted_13 = ["title"];
const _hoisted_14 = {
  key: 0,
  class: "mt-1 disable-select"
};
const _hoisted_15 = ["onClick"];
const _hoisted_16 = { class: "flex-1" };
const _hoisted_17 = { class: "grow flex flex-col" };
const _hoisted_18 = {
  ref: "currentTimeBarElement",
  class: "h-3 bg-neutral-900 cursor-pointer hover:opacity-80"
};
const _hoisted_19 = {
  ref: "canvasElementParent",
  class: "grow max-w-full relative bg-black rounded"
};
const _hoisted_20 = {
  ref: "canvasGPURaycastElement",
  class: "block absolute inset-0"
};
const _hoisted_21 = {
  ref: "canvasElement",
  class: "block absolute inset-0"
};
const _hoisted_22 = {
  ref: "css2DElement",
  class: "block absolute inset-0 pointer-events-none"
};
const _hoisted_23 = { class: "my-1 flex text-xs space-x-4" };
const _hoisted_24 = { class: "flex space-x-1 items-center" };
const _hoisted_25 = ["disabled"];
const _hoisted_26 = { class: "flex space-x-1 items-center" };
const _hoisted_27 = ["disabled"];
const _hoisted_28 = { class: "flex space-x-1 items-center" };
const _hoisted_29 = ["disabled"];
const _hoisted_30 = ["disabled"];
const _hoisted_31 = { class: "flex space-x-1 items-center" };
const _hoisted_32 = ["disabled"];
const _hoisted_33 = ["disabled"];
const _hoisted_34 = /* @__PURE__ */ (0,runtime_core_esm_bundler/* createElementVNode */._)(
  "span",
  { class: "text-xs hidden lg:inline" },
  "interpolation",
  -1
  /* HOISTED */
);
function render(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_PlusIcon = (0,runtime_core_esm_bundler/* resolveComponent */.up)("PlusIcon");
  const _component_TrashIcon = (0,runtime_core_esm_bundler/* resolveComponent */.up)("TrashIcon");
  const _component_MinusIcon = (0,runtime_core_esm_bundler/* resolveComponent */.up)("MinusIcon");
  const _component_ChevronUpIcon = (0,runtime_core_esm_bundler/* resolveComponent */.up)("ChevronUpIcon");
  const _component_EyeSlashIcon = (0,runtime_core_esm_bundler/* resolveComponent */.up)("EyeSlashIcon");
  const _component_EyeIcon = (0,runtime_core_esm_bundler/* resolveComponent */.up)("EyeIcon");
  const _component_MagnifyingGlassIcon = (0,runtime_core_esm_bundler/* resolveComponent */.up)("MagnifyingGlassIcon");
  const _component_XMarkIcon = (0,runtime_core_esm_bundler/* resolveComponent */.up)("XMarkIcon");
  const _component_ChevronDownIcon = (0,runtime_core_esm_bundler/* resolveComponent */.up)("ChevronDownIcon");
  const _component_DropDownMenu = (0,runtime_core_esm_bundler/* resolveComponent */.up)("DropDownMenu");
  return (0,runtime_core_esm_bundler/* openBlock */.wg)(), (0,runtime_core_esm_bundler/* createElementBlock */.iD)(
    "div",
    {
      class: "extra-keyframes-actor-node w-full h-full flex flex-col",
      onMousemove: _cache[18] || (_cache[18] = //@ts-ignore
      (...args) => _ctx.onMousemove && _ctx.onMousemove(...args))
    },
    [
      (0,runtime_core_esm_bundler/* createElementVNode */._)("div", _hoisted_1, [
        (0,runtime_core_esm_bundler/* createElementVNode */._)("button", {
          type: "button",
          class: (0,shared_esm_bundler/* normalizeClass */.C_)([
            "mr-1 inline-flex items-center px-3 py-1 shadow-sm text-xs leading-4 rounded-sm",
            _ctx.addKeyframesButtonActive ? "opacity-100 cursor-pointer bg-green-700 hover:bg-green-600" : "cursor-not-allowed opacity-30"
          ]),
          onClick: _cache[0] || (_cache[0] = //@ts-ignore
          (...args) => _ctx.addKeys && _ctx.addKeys(...args)),
          disabled: !_ctx.addKeyframesButtonActive,
          title: "Add Keyframes ( Alt + Click )"
        }, [
          (0,runtime_core_esm_bundler/* createVNode */.Wm)(_component_PlusIcon, {
            class: "h-4 w-4",
            "aria-hidden": "true"
          })
        ], 10, _hoisted_2),
        (0,runtime_core_esm_bundler/* createElementVNode */._)("button", {
          type: "button",
          class: (0,shared_esm_bundler/* normalizeClass */.C_)([
            "mr-1 inline-flex items-center px-3 py-1 shadow-sm text-xs leading-4 rounded-sm",
            _ctx.keyframeButtonsActive ? "opacity-100 cursor-pointer bg-red-700 hover:bg-red-600" : "cursor-not-allowed opacity-30 bg-black"
          ]),
          onClick: _cache[1] || (_cache[1] = //@ts-ignore
          (...args) => _ctx.deleteSelectedKeyframes && _ctx.deleteSelectedKeyframes(...args)),
          disabled: !_ctx.keyframeButtonsActive,
          title: "Delete Keyframes ( Del )"
        }, [
          (0,runtime_core_esm_bundler/* createVNode */.Wm)(_component_TrashIcon, {
            class: "h-4 w-4",
            "aria-hidden": "true"
          })
        ], 10, _hoisted_3),
        _hoisted_4,
        (0,runtime_core_esm_bundler/* createElementVNode */._)("button", {
          type: "button",
          class: (0,shared_esm_bundler/* normalizeClass */.C_)([
            "mr-1 inline-flex items-center px-3 py-1 shadow-sm text-xs leading-4 rounded-sm",
            _ctx.keyframeButtonsActive ? "opacity-100 cursor-pointer bg-teal-700 hover:bg-teal-600 " : "cursor-not-allowed opacity-30 bg-black"
          ]),
          onClick: _cache[2] || (_cache[2] = //@ts-ignore
          (...args) => _ctx.mergeTangents && _ctx.mergeTangents(...args)),
          disabled: !_ctx.keyframeButtonsActive,
          title: "Merge tangents"
        }, [
          (0,runtime_core_esm_bundler/* createVNode */.Wm)(_component_MinusIcon, {
            class: "-ml-0.5 mr-2 h-4 w-4",
            "aria-hidden": "true"
          }),
          (0,runtime_core_esm_bundler/* createTextVNode */.Uk)(" Merge Tangents ")
        ], 10, _hoisted_5),
        (0,runtime_core_esm_bundler/* createElementVNode */._)("button", {
          type: "button",
          class: (0,shared_esm_bundler/* normalizeClass */.C_)([
            "mr-1 inline-flex items-center px-3 py-1 shadow-sm text-xs leading-4 rounded-sm",
            _ctx.keyframeButtonsActive ? "opacity-100 cursor-pointer bg-teal-700 hover:bg-teal-600" : "cursor-not-allowed opacity-30 bg-black"
          ]),
          onClick: _cache[3] || (_cache[3] = //@ts-ignore
          (...args) => _ctx.splitTangents && _ctx.splitTangents(...args)),
          disabled: !_ctx.keyframeButtonsActive,
          title: "Split tangents"
        }, [
          (0,runtime_core_esm_bundler/* createVNode */.Wm)(_component_ChevronUpIcon, {
            class: "-ml-0.5 mr-2 h-4 w-4",
            "aria-hidden": "true"
          }),
          (0,runtime_core_esm_bundler/* createTextVNode */.Uk)(" Split Tangents ")
        ], 10, _hoisted_6),
        (0,runtime_core_esm_bundler/* createElementVNode */._)("button", {
          type: "button",
          class: "mr-1 inline-flex items-center px-3 py-1 shadow-sm text-xs leading-4 rounded-sm opacity-100 cursor-pointer bg-sky-700 hover:bg-sky-600",
          onClick: _cache[4] || (_cache[4] = //@ts-ignore
          (...args) => _ctx.toggleTangentsDisplay && _ctx.toggleTangentsDisplay(...args)),
          title: "Toggle Tangents"
        }, [
          _ctx.tangentsDisplayed ? ((0,runtime_core_esm_bundler/* openBlock */.wg)(), (0,runtime_core_esm_bundler/* createBlock */.j4)(_component_EyeSlashIcon, {
            key: 0,
            class: "-ml-0.5 mr-2 h-4 w-4",
            "aria-hidden": "true"
          })) : ((0,runtime_core_esm_bundler/* openBlock */.wg)(), (0,runtime_core_esm_bundler/* createBlock */.j4)(_component_EyeIcon, {
            key: 1,
            class: "-ml-0.5 mr-2 h-4 w-4",
            "aria-hidden": "true"
          })),
          _ctx.tangentsDisplayed ? ((0,runtime_core_esm_bundler/* openBlock */.wg)(), (0,runtime_core_esm_bundler/* createElementBlock */.iD)("span", _hoisted_7, "Hide Tangents")) : ((0,runtime_core_esm_bundler/* openBlock */.wg)(), (0,runtime_core_esm_bundler/* createElementBlock */.iD)("span", _hoisted_8, "Show Tangents"))
        ]),
        (0,runtime_core_esm_bundler/* createElementVNode */._)("button", {
          type: "button",
          class: "inline-flex items-center px-3 py-1 shadow-sm text-xs leading-4 rounded-sm bg-sky-600 hover:bg-sky-700 cursor-pointer",
          onClick: _cache[5] || (_cache[5] = //@ts-ignore
          (...args) => _ctx.frameSelection && _ctx.frameSelection(...args)),
          title: "Frame Selected ( F )"
        }, [
          (0,runtime_core_esm_bundler/* createVNode */.Wm)(_component_MagnifyingGlassIcon, {
            class: "-ml-0.5 mr-2 h-4 w-4",
            "aria-hidden": "true"
          }),
          (0,runtime_core_esm_bundler/* createTextVNode */.Uk)(" Frame Selected ")
        ])
      ]),
      (0,runtime_core_esm_bundler/* createElementVNode */._)("div", _hoisted_9, [
        (0,runtime_core_esm_bundler/* createElementVNode */._)("ul", null, [
          ((0,runtime_core_esm_bundler/* openBlock */.wg)(true), (0,runtime_core_esm_bundler/* createElementBlock */.iD)(
            runtime_core_esm_bundler/* Fragment */.HY,
            null,
            (0,runtime_core_esm_bundler/* renderList */.Ko)(_ctx.nodeNames, (nodeName, nodeIndex) => {
              return (0,runtime_core_esm_bundler/* openBlock */.wg)(), (0,runtime_core_esm_bundler/* createElementBlock */.iD)("li", _hoisted_10, [
                (0,runtime_core_esm_bundler/* createElementVNode */._)("div", _hoisted_11, [
                  (0,runtime_core_esm_bundler/* createElementVNode */._)("span", {
                    title: "Pin node",
                    onClick: ($event) => _ctx.toggleNodeCollpasedState(_ctx.nodeIds[nodeIndex])
                  }, [
                    _ctx.collapsedStates[nodeIndex] ? ((0,runtime_core_esm_bundler/* openBlock */.wg)(), (0,runtime_core_esm_bundler/* createBlock */.j4)(_component_PlusIcon, {
                      key: 0,
                      class: "pl-1 inline-block cursor-pointer w-4 h-4 opacity-50 hover:opacity-100"
                    })) : ((0,runtime_core_esm_bundler/* openBlock */.wg)(), (0,runtime_core_esm_bundler/* createBlock */.j4)(_component_MinusIcon, {
                      key: 1,
                      class: "pl-1 inline-block cursor-pointer w-4 h-4 opacity-50 hover:opacity-100"
                    }))
                  ], 8, _hoisted_12),
                  (0,runtime_core_esm_bundler/* createElementVNode */._)("span", {
                    class: "px-1",
                    title: _ctx.nodePaths[nodeIndex]
                  }, (0,shared_esm_bundler/* toDisplayString */.zw)(nodeName), 9, _hoisted_13),
                  (0,runtime_core_esm_bundler/* createVNode */.Wm)(_component_XMarkIcon, {
                    class: (0,shared_esm_bundler/* normalizeClass */.C_)([
                      "inline-block cursor-pointer w-4 h-4 text-gray-500 hover:text-red-500 opacity-50 hover:opacity-100",
                      _ctx.nodeNames.length > 1 ? "ml-1" : "mx-1"
                    ]),
                    onClick: ($event) => _ctx.removeNode(_ctx.nodeIds[nodeIndex])
                  }, null, 8, ["class", "onClick"]),
                  _ctx.nodeNames.length > 1 ? ((0,runtime_core_esm_bundler/* openBlock */.wg)(), (0,runtime_core_esm_bundler/* createBlock */.j4)(_component_ChevronDownIcon, {
                    key: 0,
                    class: (0,shared_esm_bundler/* normalizeClass */.C_)([
                      "inline-block w-4 h-4",
                      nodeIndex < _ctx.nodeNames.length - 1 ? "cursor-pointer hover:opacity-100 opacity-50" : "opacity-0"
                    ]),
                    onClick: ($event) => _ctx.moveNodeIdDown(_ctx.nodeIds[nodeIndex])
                  }, null, 8, ["class", "onClick"])) : (0,runtime_core_esm_bundler/* createCommentVNode */.kq)("v-if", true),
                  _ctx.nodeNames.length > 1 ? ((0,runtime_core_esm_bundler/* openBlock */.wg)(), (0,runtime_core_esm_bundler/* createBlock */.j4)(_component_ChevronUpIcon, {
                    key: 1,
                    class: (0,shared_esm_bundler/* normalizeClass */.C_)([
                      "inline-block w-4 h-4",
                      nodeIndex > 0 ? "cursor-pointer opacity-50 hover:opacity-100" : " opacity-0"
                    ]),
                    onClick: ($event) => _ctx.moveNodeIdUp(_ctx.nodeIds[nodeIndex])
                  }, null, 8, ["class", "onClick"])) : (0,runtime_core_esm_bundler/* createCommentVNode */.kq)("v-if", true)
                ]),
                !_ctx.collapsedStates[nodeIndex] ? ((0,runtime_core_esm_bundler/* openBlock */.wg)(), (0,runtime_core_esm_bundler/* createElementBlock */.iD)("ul", _hoisted_14, [
                  ((0,runtime_core_esm_bundler/* openBlock */.wg)(true), (0,runtime_core_esm_bundler/* createElementBlock */.iD)(
                    runtime_core_esm_bundler/* Fragment */.HY,
                    null,
                    (0,runtime_core_esm_bundler/* renderList */.Ko)(_ctx.channelDataItems[nodeIndex], (channelDataItem) => {
                      return (0,runtime_core_esm_bundler/* openBlock */.wg)(), (0,runtime_core_esm_bundler/* createElementBlock */.iD)("li", {
                        class: (0,shared_esm_bundler/* normalizeClass */.C_)([
                          "flex whitespace-nowrap cursor-pointer hover:text-white px-2 py-1 rounded-l mb-px text-xs",
                          channelDataItem.displayedState ? "text-white bg-black" : "text-text-faded"
                        ]),
                        onClick: ($event) => _ctx.toggleChannelDisplayState(channelDataItem)
                      }, [
                        (0,runtime_core_esm_bundler/* createElementVNode */._)(
                          "span",
                          _hoisted_16,
                          (0,shared_esm_bundler/* toDisplayString */.zw)(channelDataItem.channelName),
                          1
                          /* TEXT */
                        ),
                        (0,runtime_core_esm_bundler/* createElementVNode */._)(
                          "span",
                          {
                            class: (0,shared_esm_bundler/* normalizeClass */.C_)(["flex-0 m-1 rounded-full w-2 h-2 ", channelDataItem.color])
                          },
                          null,
                          2
                          /* CLASS */
                        )
                      ], 10, _hoisted_15);
                    }),
                    256
                    /* UNKEYED_FRAGMENT */
                  ))
                ])) : (0,runtime_core_esm_bundler/* createCommentVNode */.kq)("v-if", true)
              ]);
            }),
            256
            /* UNKEYED_FRAGMENT */
          ))
        ]),
        (0,runtime_core_esm_bundler/* createElementVNode */._)("div", _hoisted_17, [
          (0,runtime_core_esm_bundler/* createElementVNode */._)(
            "div",
            _hoisted_18,
            null,
            512
            /* NEED_PATCH */
          ),
          (0,runtime_core_esm_bundler/* createElementVNode */._)(
            "div",
            _hoisted_19,
            [
              (0,runtime_core_esm_bundler/* createElementVNode */._)(
                "canvas",
                _hoisted_20,
                null,
                512
                /* NEED_PATCH */
              ),
              (0,runtime_core_esm_bundler/* createElementVNode */._)(
                "canvas",
                _hoisted_21,
                null,
                512
                /* NEED_PATCH */
              ),
              (0,runtime_core_esm_bundler/* createElementVNode */._)(
                "div",
                _hoisted_22,
                null,
                512
                /* NEED_PATCH */
              )
            ],
            512
            /* NEED_PATCH */
          ),
          (0,runtime_core_esm_bundler/* createElementVNode */._)("div", _hoisted_23, [
            (0,runtime_core_esm_bundler/* createElementVNode */._)("div", _hoisted_24, [
              (0,runtime_core_esm_bundler/* createElementVNode */._)(
                "label",
                {
                  for: "animation-editor-keyframe-value",
                  class: (0,shared_esm_bundler/* normalizeClass */.C_)([
                    "items-center text-text-faded whitespace-nowrap",
                    _ctx.keyframePosActive ? "" : "opacity-50"
                  ])
                },
                "Time",
                2
                /* CLASS */
              ),
              (0,runtime_core_esm_bundler/* withDirectives */.wy)((0,runtime_core_esm_bundler/* createElementVNode */._)("input", {
                type: "number",
                name: "animation-editor-keyframe-time",
                id: "animation-editor-keyframe-time",
                step: "1",
                class: "inline-block shadow appearance-none border-0 rounded w-full py-1 px-1 bg-black text-gray-100 text-xs leading-none",
                "onUpdate:modelValue": _cache[6] || (_cache[6] = ($event) => _ctx.keyframePos = $event),
                onChange: _cache[7] || (_cache[7] = //@ts-ignore
                (...args) => _ctx.onKeyframePosChange && _ctx.onKeyframePosChange(...args)),
                disabled: !_ctx.keyframePosActive
              }, null, 40, _hoisted_25), [
                [runtime_dom_esm_bundler.vModelText, _ctx.keyframePos]
              ])
            ]),
            (0,runtime_core_esm_bundler/* createElementVNode */._)("div", _hoisted_26, [
              (0,runtime_core_esm_bundler/* createElementVNode */._)(
                "label",
                {
                  for: "animation-editor-keyframe-value",
                  class: (0,shared_esm_bundler/* normalizeClass */.C_)([
                    "items-center text-text-faded whitespace-nowrap",
                    _ctx.keyframeValueActive ? "" : "opacity-50"
                  ])
                },
                "Value",
                2
                /* CLASS */
              ),
              (0,runtime_core_esm_bundler/* withDirectives */.wy)((0,runtime_core_esm_bundler/* createElementVNode */._)("input", {
                type: "number",
                name: "animation-editor-keyframe-value",
                id: "animation-editor-keyframe-value",
                step: "0.001",
                class: "inline-block shadow appearance-none border-0 rounded w-full py-1 px-1 bg-black text-gray-100 text-xs leading-none",
                "onUpdate:modelValue": _cache[8] || (_cache[8] = ($event) => _ctx.keyframeValue = $event),
                onChange: _cache[9] || (_cache[9] = //@ts-ignore
                (...args) => _ctx.onKeyframeValueChange && _ctx.onKeyframeValueChange(...args)),
                disabled: !_ctx.keyframeValueActive
              }, null, 40, _hoisted_27), [
                [runtime_dom_esm_bundler.vModelText, _ctx.keyframeValue]
              ])
            ]),
            (0,runtime_core_esm_bundler/* createElementVNode */._)("div", _hoisted_28, [
              (0,runtime_core_esm_bundler/* createElementVNode */._)(
                "label",
                {
                  for: "animation-editor-keyframe-value",
                  class: (0,shared_esm_bundler/* normalizeClass */.C_)([
                    "items-center text-text-faded whitespace-nowrap",
                    _ctx.keyframeInActive ? "" : "opacity-50"
                  ])
                },
                "Tangent In",
                2
                /* CLASS */
              ),
              (0,runtime_core_esm_bundler/* withDirectives */.wy)((0,runtime_core_esm_bundler/* createElementVNode */._)("input", {
                type: "number",
                name: "animation-editor-keyframe-value",
                id: "animation-editor-keyframe-value",
                step: "0.001",
                class: "inline-block shadow appearance-none border-0 rounded w-full py-1 px-1 bg-black text-gray-100 text-xs leading-none",
                "onUpdate:modelValue": _cache[10] || (_cache[10] = ($event) => _ctx.keyframeInSlope = $event),
                onChange: _cache[11] || (_cache[11] = //@ts-ignore
                (...args) => _ctx.onKeyframeTangentInSlopeChange && _ctx.onKeyframeTangentInSlopeChange(...args)),
                disabled: !_ctx.keyframeInActive
              }, null, 40, _hoisted_29), [
                [runtime_dom_esm_bundler.vModelText, _ctx.keyframeInSlope]
              ]),
              (0,runtime_core_esm_bundler/* withDirectives */.wy)((0,runtime_core_esm_bundler/* createElementVNode */._)("input", {
                type: "number",
                name: "animation-editor-keyframe-value",
                id: "animation-editor-keyframe-value",
                step: "0.001",
                class: "inline-block shadow appearance-none border-0 rounded w-full py-1 px-1 bg-black text-gray-100 text-xs leading-none",
                "onUpdate:modelValue": _cache[12] || (_cache[12] = ($event) => _ctx.keyframeInAccel = $event),
                onChange: _cache[13] || (_cache[13] = //@ts-ignore
                (...args) => _ctx.onKeyframeTangentInAccelChange && _ctx.onKeyframeTangentInAccelChange(...args)),
                disabled: !_ctx.keyframeInActive
              }, null, 40, _hoisted_30), [
                [runtime_dom_esm_bundler.vModelText, _ctx.keyframeInAccel]
              ])
            ]),
            (0,runtime_core_esm_bundler/* createElementVNode */._)("div", _hoisted_31, [
              (0,runtime_core_esm_bundler/* createElementVNode */._)(
                "label",
                {
                  for: "animation-editor-keyframe-value",
                  class: (0,shared_esm_bundler/* normalizeClass */.C_)([
                    "items-center text-text-faded whitespace-nowrap",
                    _ctx.keyframeOutSlope ? "" : "opacity-50"
                  ])
                },
                "Tangent Out",
                2
                /* CLASS */
              ),
              (0,runtime_core_esm_bundler/* withDirectives */.wy)((0,runtime_core_esm_bundler/* createElementVNode */._)("input", {
                type: "number",
                name: "animation-editor-keyframe-value",
                id: "animation-editor-keyframe-value",
                step: "0.001",
                class: "inline-block shadow appearance-none border-0 rounded w-full py-1 px-1 bg-black text-gray-100 text-xs leading-none",
                "onUpdate:modelValue": _cache[14] || (_cache[14] = ($event) => _ctx.keyframeOutSlope = $event),
                onChange: _cache[15] || (_cache[15] = //@ts-ignore
                (...args) => _ctx.onKeyframeTangentOutSlopeChange && _ctx.onKeyframeTangentOutSlopeChange(...args)),
                disabled: !_ctx.keyframeOutActive
              }, null, 40, _hoisted_32), [
                [runtime_dom_esm_bundler.vModelText, _ctx.keyframeOutSlope]
              ]),
              (0,runtime_core_esm_bundler/* withDirectives */.wy)((0,runtime_core_esm_bundler/* createElementVNode */._)("input", {
                type: "number",
                name: "animation-editor-keyframe-value",
                id: "animation-editor-keyframe-value",
                step: "0.001",
                class: "inline-block shadow appearance-none border-0 rounded w-full py-1 px-1 bg-black text-gray-100 text-xs leading-none",
                "onUpdate:modelValue": _cache[16] || (_cache[16] = ($event) => _ctx.keyframeOutAccel = $event),
                onChange: _cache[17] || (_cache[17] = //@ts-ignore
                (...args) => _ctx.onKeyframeTangentOutAccelChange && _ctx.onKeyframeTangentOutAccelChange(...args)),
                disabled: !_ctx.keyframeOutActive
              }, null, 40, _hoisted_33), [
                [runtime_dom_esm_bundler.vModelText, _ctx.keyframeOutAccel]
              ])
            ]),
            (0,runtime_core_esm_bundler/* createElementVNode */._)(
              "div",
              {
                class: (0,shared_esm_bundler/* normalizeClass */.C_)(["flex", _ctx.interpolationDropdownActive ? "" : "cursor-not-allowed opacity-50"])
              },
              [
                (0,runtime_core_esm_bundler/* createVNode */.Wm)(_component_DropDownMenu, {
                  label: _ctx.currentInterpolation,
                  entries: _ctx.interpolationMenuEntries,
                  onSelect: _ctx.onInterpolationsMenuEntrySelect,
                  label_padding: [0, 5]
                }, {
                  default: (0,runtime_core_esm_bundler/* withCtx */.w5)(() => [
                    (0,runtime_core_esm_bundler/* createElementVNode */._)(
                      "div",
                      {
                        class: (0,shared_esm_bundler/* normalizeClass */.C_)([
                          "rounded bg-bg-dark px-2 py-1 inline-flex text-gray-100",
                          _ctx.interpolationDropdownActive ? "" : "cursor-not-allowed"
                        ])
                      },
                      [
                        _hoisted_34,
                        (0,runtime_core_esm_bundler/* createVNode */.Wm)(_component_ChevronDownIcon, { class: "w-4 h-4" })
                      ],
                      2
                      /* CLASS */
                    )
                  ]),
                  _: 1
                  /* STABLE */
                }, 8, ["label", "entries", "onSelect"])
              ],
              2
              /* CLASS */
            )
          ])
        ])
      ])
    ],
    32
    /* HYDRATE_EVENTS */
  );
}

;// CONCATENATED MODULE: ../src/editor/components/panels/animation/AnimationCore.vue?vue&type=template&id=2d45f6de&ts=true

// EXTERNAL MODULE: ../node_modules/@vue/reactivity/dist/reactivity.esm-bundler.js + 1 modules
var reactivity_esm_bundler = __webpack_require__(61334);
// EXTERNAL MODULE: ../src/editor/store/controllers/StoreController.ts + 44 modules
var StoreController = __webpack_require__(72555);
// EXTERNAL MODULE: ../src/editor/store/controllers/editor/KeyframeEditor.ts
var KeyframeEditor = __webpack_require__(70037);
;// CONCATENATED MODULE: ../src/editor/components/panels/animation/mixins/EventKey.ts

var __async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};
function SetupEventKey(options) {
  const { sceneController } = options;
  function onKeypress(event) {
    return false;
  }
  function onKeydown(event) {
    let key_processed = true;
    if (event.ctrlKey || event.metaKey) {
      switch (event.key) {
        case "a":
          selectAllKeys();
          event.preventDefault();
          event.stopPropagation();
          break;
        case "x":
          cut();
          break;
        case "c":
          copy();
          break;
        case "v":
          paste();
          break;
        default:
          key_processed = false;
      }
    } else {
      if (event.shiftKey) {
      } else {
        switch (event.key) {
          case "Delete":
            deleteSelectedKeys();
            break;
          case "f":
            sceneController.frameSelection();
            break;
          default:
            key_processed = false;
        }
      }
    }
    return key_processed;
  }
  function onKeyup(event) {
    return false;
  }
  function deleteSelectedKeys() {
    return __async(this, null, function* () {
      sceneController.events.deleteSelectedKeys();
    });
  }
  function selectAllKeys() {
    sceneController.actions.selection.selectAll();
  }
  function cut() {
    return __async(this, null, function* () {
      sceneController.actions.copyPaste.copy();
      deleteSelectedKeys();
    });
  }
  function copy() {
    sceneController.actions.copyPaste.copy();
  }
  function paste() {
    return __async(this, null, function* () {
      yield sceneController.actions.copyPaste.paste();
    });
  }
  return {
    onKeypress,
    onKeydown,
    onKeyup,
    cut,
    copy,
    paste
  };
}

// EXTERNAL MODULE: ../src/editor/helpers/KeyEventsDispatcher.ts
var KeyEventsDispatcher = __webpack_require__(72359);
;// CONCATENATED MODULE: ../src/editor/components/panels/animation/mixins/EventMouse.ts


function SetupEventMouse(options, setupLinkIndex) {
  const { eventKeyOptions } = options;
  function onMousemove(event) {
    KeyEventsDispatcher/* KeyEventsDispatcher.instance */.s.instance().registerProcessor(eventKeyOptions);
  }
  function onContextMenu(event) {
    return false;
  }
  return {
    onMousemove,
    onContextMenu
  };
}

// EXTERNAL MODULE: ../src/editor/components/panels/common/LinkIndex.ts
var LinkIndex = __webpack_require__(44822);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/node_modules/three/build/three.module.js
var three_module = __webpack_require__(21410);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/core/render/CSSRenderers/CSS2DRenderer.ts
var CSS2DRenderer = __webpack_require__(17009);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/core/keyframes/Channel.ts + 2 modules
var Channel = __webpack_require__(31369);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/nodes/gl/code/assemblers/materials/OnBeforeCompile.ts
var OnBeforeCompile = __webpack_require__(43008);
;// CONCATENATED MODULE: ../src/editor/components/panels/animation/keyframeEditorSceneController/glsl/keyframePositionHandle.vert.glsl
/* harmony default export */ var keyframePositionHandle_vert = ("uniform vec2 frustumSize;\nuniform float heightMult;\nuniform float scale;\nattribute float lineDistance;\nvarying float vLineDistance;\n#include <common>\n\n\n\n// /geo1/MAT/lineBasicBuilder1/globals1\nvarying vec3 v_POLY_globals1_position;\n\n\n\n\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\tvLineDistance = scale * lineDistance;\n\t#include <color_vertex>\n\n\n\n\t// /geo1/MAT/lineBasicBuilder1/globals1\n\tv_POLY_globals1_position = vec3(position);\n\tv_POLY_globals1_position.y *= heightMult * frustumSize.y;\n\t\n\t// /geo1/MAT/lineBasicBuilder1/output1\n\tvec3 transformed = vec3( v_POLY_globals1_position );vec4 mvPosition = vec4( transformed, 1.0 ); gl_Position = projectionMatrix * modelViewMatrix * mvPosition;\n\n\n\n\t#include <morphcolor_vertex>\n// removed:\n//\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n// removed:\n//\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}");
;// CONCATENATED MODULE: ../src/editor/components/panels/animation/keyframeEditorSceneController/glsl/keyframePositionHandle.frag.glsl
/* harmony default export */ var keyframePositionHandle_frag = ("// uniform vec2 frustumSize;\n//\nuniform vec3 diffuse;\nuniform float opacity;\nuniform float dashSize;\nuniform float totalSize;\nvarying float vLineDistance;\n#include <common>\n\n\n\n// /geo1/MAT/lineBasicBuilder1/globals1\n// varying vec3 v_POLY_globals1_position;\n\n\n\n\n#include <color_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tif ( mod( vLineDistance, totalSize ) > dashSize ) {\n\t\tdiscard;\n\t}\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\n\n\n\t// /geo1/MAT/lineBasicBuilder1/vec3ToFloat1\n\t// float v_POLY_vec3ToFloat1_y = v_POLY_globals1_position.y;\n\t// float mult = (abs(v_POLY_vec3ToFloat1_y) > (.06 * frustumSize.y)) ? 0.0 : 1.0;\n\t// diffuseColor.x *= mult;\n\t// diffuseColor.y *= mult;\n\t// diffuseColor.z *= mult;\n\t// diffuseColor.w *= mult;\n\n\n\n\t#include <logdepthbuf_fragment>\n\t#include <color_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}");
;// CONCATENATED MODULE: ../src/editor/components/panels/animation/keyframeEditorSceneController/glsl/keyframeTangentLine.vert.glsl
/* harmony default export */ var keyframeTangentLine_vert = ("uniform vec2 frustumSize;\n//\nuniform float scale;\nattribute float lineDistance;\nvarying float vLineDistance;\n#include <common>\n\nfloat vector2Angle(vec2 v) {\n\treturn atan(v.y, v.x);\n}\n\n// /geo1/MAT/lineBasicBuilder1/globals1\n// varying vec3 v_POLY_globals1_position;\n\n\n\n\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\tvLineDistance = scale * lineDistance;\n\t#include <color_vertex>\n\n\n\n\t// /geo1/MAT/lineBasicBuilder1/globals1\n\tvec3 pC = vec3(position);\n\t// pA.z = 0.;\n\t// float tangentLength = length(pA);\n\t// float frustumRatio = frustumSize.y / frustumSize.x;\n\t// pB.x *= frustumSize.x;\n\t// pB.y *= frustumSize.y;\n\t// float tangentLength2 = length(pB);\n\n\t// pC.z = 0.;\n\tif(abs(position.x)>0.001){\n\t\t// vec3 pA = vec3(position);\n\t\tvec3 pB = vec3(position);\n\n\t\t// float tangentLength = length(pC);\n\t\t// float frustumRatio = frustumSize.y / frustumSize.x;\n\t\t// pB.x /= frustumSize.x;\n\t\t// pB.y /= frustumSize.y;\n\t\t// float tangentLength2 = length(pB);\n\n\t\t// float tangentLength = length(pC);\n\t\t// pC = normalize(pC) * tangentLength*frustumRatio*frustumRatio;\n\t\t// pC.x /= frustumRatio;\n\t\t// pC.y *= tangentLength;\n\t}\n\t// pC.x *= 50.;\n\t// pC.y *= 50.;\n\t// pC.z = position.z;\n\t\n\t// /geo1/MAT/lineBasicBuilder1/output1\n\tvec3 transformed = vec3( pC ); vec4 mvPosition = vec4( transformed, 1.0 ); gl_Position = projectionMatrix * modelViewMatrix * mvPosition;\n\n\n\n\t#include <morphcolor_vertex>\n// removed:\n//\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n// removed:\n//\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}");
;// CONCATENATED MODULE: ../src/editor/components/panels/animation/keyframeEditorSceneController/glsl/keyframeTangentLine.frag.glsl
/* harmony default export */ var keyframeTangentLine_frag = ("// uniform vec2 frustumSize;\n//\nuniform vec3 diffuse;\nuniform float opacity;\nuniform float dashSize;\nuniform float totalSize;\nvarying float vLineDistance;\n#include <common>\n\n\n\n// /geo1/MAT/lineBasicBuilder1/globals1\n// varying vec3 v_POLY_globals1_position;\n\n\n\n\n#include <color_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tif ( mod( vLineDistance, totalSize ) > dashSize ) {\n\t\tdiscard;\n\t}\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\n\n\n\t// /geo1/MAT/lineBasicBuilder1/vec3ToFloat1\n\t// float frustumRatio = frustumSize.x / frustumSize.y;\n\t// float v_POLY_vec3ToFloat1_y = v_POLY_globals1_position.y;\n\t// // float lineLength = len(v_POLY_globals1_position.xy);\n\t// float mult = 1.0;//(abs(v_POLY_vec3ToFloat1_y) > (.06 * frustumRatio)) ? 0.0 : 1.0;\n\t// diffuseColor.x *= mult;\n\t// diffuseColor.y *= mult;\n\t// diffuseColor.z *= mult;\n\t// diffuseColor.w *= mult;\n\n\n\n\t#include <logdepthbuf_fragment>\n\t#include <color_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}");
;// CONCATENATED MODULE: ../src/editor/components/panels/animation/keyframeEditorSceneController/common/Constant.ts







const LINE_WIDTH_RAYCAST_GPU = 16 * window.devicePixelRatio;
const POINT_SIZE_RAYCAST_GPU = 8 * window.devicePixelRatio;
const KEYFRAME_HANDLE_POSITION_HEIGHT_MULT = 0.1;
const FRUSTRUM_SIZE_UNIFORM = { value: new three_module.Vector2() };
const HEIGHT_MULT_UNIFORM = { value: KEYFRAME_HANDLE_POSITION_HEIGHT_MULT };
var ObjectId = /* @__PURE__ */ ((ObjectId2) => {
  ObjectId2[ObjectId2["CURRENT_TIME_LINE"] = 2] = "CURRENT_TIME_LINE";
  return ObjectId2;
})(ObjectId || {});
const OBJECT_IDS = [2 /* CURRENT_TIME_LINE */];
const OBJECT_IDS_SET = new Set(OBJECT_IDS);
const COLOR = {
  base: {
    currentTime: 11184810,
    segmentCurve: 43520,
    keyframeTangent: 11184810,
    keyframeHandlePosition: 39202,
    keyframeHandleValue: 11184640,
    keyframeTangentDot: 8913032
  },
  highlighted: {
    currentTime: 16777215,
    segmentCurve: 65280,
    keyframeTangent: 16777215,
    keyframeHandlePosition: 65365,
    keyframeHandleValue: 16776960,
    keyframeTangentDot: 16711935
  }
};
const segmentCurveMaterial = (color) => {
  return new three_module.LineBasicMaterial({
    color,
    linewidth: 2
  });
};
const currentTimeMaterial = (options) => {
  const { color, forGPUraycast } = options;
  return new three_module.LineBasicMaterial({
    color,
    linewidth: forGPUraycast ? LINE_WIDTH_RAYCAST_GPU : 2
  });
};
const keyframeTangentLineMaterial = (options) => {
  const { color, forGPUraycast } = options;
  const material = new three_module.LineBasicMaterial({
    color,
    linewidth: forGPUraycast ? LINE_WIDTH_RAYCAST_GPU : 2,
    alphaTest: 0.5,
    transparent: true
  });
  const uniforms = three_module.UniformsUtils.clone(three_module.ShaderLib.dashed.uniforms);
  uniforms.frustumSize = FRUSTRUM_SIZE_UNIFORM;
  uniforms.heightMult = HEIGHT_MULT_UNIFORM;
  material.onBeforeCompile = (shader) => {
    shader.vertexShader = keyframeTangentLine_vert;
    shader.fragmentShader = keyframeTangentLine_frag;
    shader.uniforms = uniforms;
  };
  OnBeforeCompile/* MaterialUserDataUniforms.setUniforms */.Hc.setUniforms(material, uniforms);
  return material;
};
const keyframeHandlePositionMaterial = (options) => {
  const { color, forGPUraycast } = options;
  const material = new three_module.LineBasicMaterial({
    color,
    linewidth: forGPUraycast ? LINE_WIDTH_RAYCAST_GPU : 2,
    alphaTest: 0.5,
    transparent: true
  });
  const uniforms = three_module.UniformsUtils.clone(three_module.ShaderLib.dashed.uniforms);
  uniforms.frustumSize = FRUSTRUM_SIZE_UNIFORM;
  uniforms.heightMult = HEIGHT_MULT_UNIFORM;
  material.onBeforeCompile = (shader) => {
    shader.vertexShader = keyframePositionHandle_vert;
    shader.fragmentShader = keyframePositionHandle_frag;
    shader.uniforms = uniforms;
  };
  OnBeforeCompile/* MaterialUserDataUniforms.setUniforms */.Hc.setUniforms(material, uniforms);
  return material;
};
const _keyframeHandleValueMaterial = (color) => {
  return new three_module.PointsMaterial({
    color,
    size: 7,
    sizeAttenuation: false
  });
};
const _keyframeTangentDotMaterial = (color) => {
  return new three_module.PointsMaterial({
    color,
    size: 6,
    sizeAttenuation: false
  });
};
const pointsRaycastGPUMaterial = (color) => {
  return new three_module.PointsMaterial({
    color,
    size: POINT_SIZE_RAYCAST_GPU,
    sizeAttenuation: false
  });
};
const MATERIAL = {
  selectionRectangle: new three_module.LineBasicMaterial({
    color: 56576,
    linewidth: 2
  }),
  bgGrid: {
    lines: new three_module.LineBasicMaterial({
      color: 4473924,
      linewidth: 1
    }),
    axis: new three_module.LineBasicMaterial({
      color: 6710886,
      linewidth: 2
    })
  },
  // segmentCurve: {
  // 	default: segmentCurveMaterial(COLOR.base.segmentCurve),
  // 	highlighted: segmentCurveMaterial(COLOR.highlighted.segmentCurve),
  // },
  currentTime: {
    default: currentTimeMaterial({ color: COLOR.base.currentTime, forGPUraycast: false }),
    highlighted: currentTimeMaterial({ color: COLOR.highlighted.currentTime, forGPUraycast: false }),
    raycasting: currentTimeMaterial({
      color: function() {
        const c = new three_module.Color();
        c.r = 2 /* CURRENT_TIME_LINE */;
        return c;
      }(),
      forGPUraycast: true
    })
  },
  keyframeTangentLine: {
    default: keyframeTangentLineMaterial({ color: COLOR.base.keyframeTangent, forGPUraycast: false }),
    highlighted: keyframeTangentLineMaterial({ color: COLOR.highlighted.keyframeTangent, forGPUraycast: false })
  },
  keyframeHandlePosition: {
    default: keyframeHandlePositionMaterial({ color: COLOR.base.keyframeHandlePosition, forGPUraycast: false }),
    highlighted: keyframeHandlePositionMaterial({
      color: COLOR.highlighted.keyframeHandlePosition,
      forGPUraycast: false
    }),
    selected: keyframeHandlePositionMaterial({ color: 16777215, forGPUraycast: false })
  },
  keyframeHandleValue: {
    default: _keyframeHandleValueMaterial(COLOR.base.keyframeHandleValue),
    highlighted: _keyframeHandleValueMaterial(COLOR.highlighted.keyframeHandleValue)
  },
  keyframeTangentDot: {
    default: _keyframeTangentDotMaterial(COLOR.base.keyframeTangentDot),
    highlighted: _keyframeTangentDotMaterial(COLOR.highlighted.keyframeTangentDot)
  }
};
function _updateMaterialHandleFrustrumSize(frustumSize) {
  FRUSTRUM_SIZE_UNIFORM.value.copy(frustumSize);
}
const Z_POS = {
  // non interactive objects
  planeHelper: -0.2,
  planeHelperAxis: -0.15,
  curve: -0.1,
  // interactive objects
  currentTime: -0.08,
  tangent: 0.05,
  dot: 0.1,
  selectionRectangle: 0.8,
  camera: 1
};

// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/core/ArrayUtils.ts
var ArrayUtils = __webpack_require__(87132);
;// CONCATENATED MODULE: ../src/editor/components/panels/animation/keyframeEditorSceneController/objects/SegmentCurve.ts






const _v2 = new three_module.Vector2();
const POSITION_NAME = "position";
class SegmentCurve {
  constructor(options) {
    const { segmentHandler, nodeId, channelIndex, subChannelIndex, segmentIndex, material } = options;
    this.segmentHandler = segmentHandler;
    const keyframeEditor = StoreController/* StoreController.editor.keyframeEditor */.F.editor.keyframeEditor;
    this.channelData = (0,runtime_core_esm_bundler/* computed */.Fl)(() => {
      const nodeData = keyframeEditor.channelDatasByNodeIds.value[nodeId];
      if (!nodeData) {
        return null;
      }
      const channelData = nodeData[channelIndex];
      if (!channelData) {
        return null;
      }
      return channelData[subChannelIndex] || null;
    });
    this.keyframeStart = (0,runtime_core_esm_bundler/* computed */.Fl)(() => {
      var _a;
      return ((_a = this.channelData.value) == null ? void 0 : _a.keyframes[segmentIndex]) || null;
    });
    this.keyframeEnd = (0,runtime_core_esm_bundler/* computed */.Fl)(() => {
      var _a;
      return ((_a = this.channelData.value) == null ? void 0 : _a.keyframes[segmentIndex + 1]) || null;
    });
    const valuesByPos = (0,runtime_core_esm_bundler/* computed */.Fl)(() => segmentHandler.channelHandler.valuesByPos.value);
    this._geometry = new three_module.BufferGeometry();
    this._object = new three_module.Line(this._geometry, material);
    this._object.matrixAutoUpdate = false;
    (0,runtime_core_esm_bundler/* watch */.YP)(this.keyframeStart, this.update.bind(this), { deep: true });
    (0,runtime_core_esm_bundler/* watch */.YP)(this.keyframeEnd, this.update.bind(this), { deep: true });
    (0,runtime_core_esm_bundler/* watch */.YP)(valuesByPos, this.update.bind(this), { deep: true });
    this.update();
  }
  dispose() {
    this.segmentHandler.group.remove(this._object);
  }
  highlightable() {
    return false;
  }
  update() {
    if (!this.keyframeStart.value || !this.keyframeEnd.value) {
      this.segmentHandler.group.remove(this._object);
      return;
    }
    let positionAttribute = this._geometry.getAttribute(POSITION_NAME);
    const channelHandler = this.segmentHandler.channelHandler;
    const posStart = this.keyframeStart.value.pos;
    const posEnd = this.keyframeEnd.value.pos;
    const pointsCount = Math.abs(posEnd - posStart) + 1;
    const bufferCreateRequired = positionAttribute == null || positionAttribute.count != pointsCount;
    const positions = bufferCreateRequired || positionAttribute == null ? new Float32Array(pointsCount * 3) : (0,ArrayUtils/* typedArrayCopy */.C)(positionAttribute.array, new Float32Array());
    let i = 0;
    for (let t = posStart; t <= posEnd; t++) {
      _v2.x = t;
      _v2.y = channelHandler.valuesByPos.value[t];
      positions[i] = _v2.x;
      positions[i + 1] = _v2.y;
      positions[i + 2] = Z_POS.curve;
      i += 3;
    }
    if (bufferCreateRequired) {
      positionAttribute = new three_module.BufferAttribute(new Float32Array(positions), 3);
      this._geometry.setAttribute(POSITION_NAME, positionAttribute);
    } else {
      if (positionAttribute) {
        positionAttribute.needsUpdate = true;
      }
    }
    this.segmentHandler.group.add(this._object);
  }
}

// EXTERNAL MODULE: ../src/editor/core/Tailwind.ts
var Tailwind = __webpack_require__(33121);
;// CONCATENATED MODULE: ../src/editor/components/panels/animation/keyframeEditorSceneController/elements/SegmentHandler.ts








class SegmentHandler {
  constructor(options) {
    this.options = options;
    //
    this.group = new three_module.Group();
    // private _curveCheck: SegmentCurveCheck;
    this._material = segmentCurveMaterial(new three_module.Color());
    const { channelHandler, nodeId, channelIndex, subChannelIndex, segmentIndex } = options;
    this.channelHandler = channelHandler;
    const keyframeEditor = StoreController/* StoreController.editor.keyframeEditor */.F.editor.keyframeEditor;
    this.dataParamId = (0,runtime_core_esm_bundler/* computed */.Fl)(() => {
      const nodeData = keyframeEditor.channelDataParamIdsByNodeId.value[nodeId];
      return nodeData ? nodeData[channelIndex] : null;
    });
    this.channelData = (0,runtime_core_esm_bundler/* computed */.Fl)(() => {
      const nodeData = keyframeEditor.channelDatasByNodeIds.value[nodeId];
      if (!nodeData) {
        return null;
      }
      const channelData = nodeData[channelIndex];
      if (!channelData) {
        return null;
      }
      return channelData[subChannelIndex] || null;
    });
    this.channelColorName = (0,runtime_core_esm_bundler/* computed */.Fl)(
      () => this.dataParamId.value != null ? keyframeEditor.channelColorByParamId.value[this.dataParamId.value] : null
    );
    channelHandler.group.add(this.group);
    this.group.matrixAutoUpdate = false;
    this.keyframeStart = (0,runtime_core_esm_bundler/* computed */.Fl)(
      () => this.channelData.value ? this.channelData.value.keyframes[segmentIndex] : null
    );
    this.keyframeEnd = (0,runtime_core_esm_bundler/* computed */.Fl)(
      () => this.channelData.value ? this.channelData.value.keyframes[segmentIndex + 1] : null
    );
    this._curve = new SegmentCurve({
      controller: this.options.controller,
      segmentHandler: this,
      nodeId,
      channelIndex,
      subChannelIndex,
      segmentIndex,
      material: this._material
    });
    (0,runtime_core_esm_bundler/* watch */.YP)(this.keyframeStart, this._update.bind(this), { deep: true });
    (0,runtime_core_esm_bundler/* watch */.YP)(this.keyframeEnd, this._update.bind(this), { deep: true });
    (0,runtime_core_esm_bundler/* watch */.YP)(this.channelColorName, this._updateMaterialColor.bind(this));
    this._update();
    this._updateMaterialColor();
  }
  dispose() {
    this.channelHandler.group.remove(this.group);
    this._curve.dispose();
  }
  _update() {
    this._curve.update();
  }
  _updateMaterialColor() {
    if (!this.channelColorName.value) {
      return;
    }
    const value = KeyframeEditor/* COLOR_VALUES_BY_SUBCHANNEL_INDEX */.gr[this.options.subChannelIndex];
    const colorHex = Tailwind/* HEX_BY_TAILWIND_COLOR */.jr[this.channelColorName.value][value];
    this._material.color.setStyle(colorHex, "");
  }
}

;// CONCATENATED MODULE: ../src/editor/components/panels/animation/keyframeEditorSceneController/objects/_Base.ts






let _nextId = Math.max(...OBJECT_IDS) + 1;
class BaseObject {
  constructor(options) {
    this.options = options;
    this.highlighted = (0,reactivity_esm_bundler/* ref */.iH)(false);
    this.uuid = three_module.MathUtils.generateUUID();
    this.selected = (0,runtime_core_esm_bundler/* computed */.Fl)(() => {
      const { nodeId, channelIndex, keyframeIndex } = this.options;
      const nodeSelection = StoreController/* StoreController.editor.keyframeEditor.selection.value */.F.editor.keyframeEditor.selection.value[nodeId];
      if (!nodeSelection) {
        return false;
      }
      const channelSelection = nodeSelection[channelIndex];
      if (!channelSelection) {
        return false;
      }
      const subChannelSelection = channelSelection[this.options.subChannelIndex];
      if (!subChannelSelection) {
        return false;
      }
      return subChannelSelection.includes(keyframeIndex.value);
    });
    this._raycastGPUColor = new three_module.Color();
    (0,runtime_core_esm_bundler/* watch */.YP)(this.highlighted, () => this.updateMaterial());
    (0,runtime_core_esm_bundler/* watch */.YP)(this.selected, () => this.updateMaterial());
    this.id = _nextId++;
    this._raycastGPUColor.r = this.id;
    const keyframeEditor = StoreController/* StoreController.editor.keyframeEditor */.F.editor.keyframeEditor;
    this.subChannelDatas = (0,runtime_core_esm_bundler/* computed */.Fl)(() => {
      const nodeData = keyframeEditor.channelDatasByNodeIds.value[this.options.nodeId];
      if (!nodeData) {
        return null;
      }
      const subChannelDatas = nodeData[this.options.channelIndex];
      if (!subChannelDatas) {
        return null;
      }
      return subChannelDatas;
    });
    this.channelData = (0,runtime_core_esm_bundler/* computed */.Fl)(() => {
      const subChannelData = this.subChannelDatas.value;
      if (!subChannelData) {
        return null;
      }
      return subChannelData[this.options.subChannelIndex] || null;
    });
  }
  object() {
    return this._object;
  }
  register() {
    if (!this._object) {
      throw new Error("no object");
    }
    this.options.controller.objects.register(this);
  }
  dispose() {
    this.options.controller.objects.unregister(this);
  }
  afterUpdate() {
    this._geometry.boundingSphere = null;
    this._geometry.boundingBox = null;
  }
  keyframeData() {
    var _a;
    if (this.channelData.value) {
      return (_a = this.channelData.value) == null ? void 0 : _a.keyframes[this.options.keyframeIndex.value];
    }
  }
  // otherKeyframeDatas(): KeyframeData[] | undefined {
  // 	if (this.channelData.value) {
  // 		return this.channelData.value?.keyframes.filter((k, i) => i != this.options.keyframeIndex.value);
  // 	}
  // }
  // dataParamId(): CoreGraphNodeId | undefined {
  // 	const paramIds = dataParamIdsForNodeId(this.options.nodeId);
  // 	if (paramIds) {
  // 		return paramIds[this.options.channelIndex];
  // 	}
  // }
  onMoveStart(event, start) {
  }
  onMoveProgress(event, delta) {
  }
  onMoveEnd() {
  }
  selectionData() {
    return {
      nodeId: this.options.nodeId,
      channelIndex: this.options.channelIndex,
      subChannelIndex: this.options.subChannelIndex,
      keyframeIndex: this.options.keyframeIndex.value
    };
  }
  prepareForRaycastGPU() {
    this._object.frustumCulled = false;
    this._previousMaterial = this._object.material;
    this._object.material = this.raycastGPUMaterial();
  }
  restoreFromRaycastGPU() {
    this._object.frustumCulled = true;
    if (this._previousMaterial) {
      this._object.material = this._previousMaterial;
    }
  }
  _dataParam() {
    const paramId = (0,KeyframeEditor/* dataParamIdForSelectionData */.p_)(this.selectionData());
    if (!(paramId != null && this.options.channelData.value)) {
      return;
    }
    const param = StoreController/* StoreController.engine.param */.F.engine.param(paramId);
    return param;
  }
}

;// CONCATENATED MODULE: ../src/editor/components/panels/animation/keyframeEditorSceneController/objects/KeyframeHandleValue.ts





class KeyframeHandleValue extends BaseObject {
  constructor(options) {
    super(options);
    this._positions = new Float32Array(3);
    // 3 vertices per point
    this._positionAttribute = new three_module.BufferAttribute(this._positions, 3);
    this.keyframe = (0,runtime_core_esm_bundler/* computed */.Fl)(
      () => this.options.channelData.value ? this.options.channelData.value.keyframes[this.options.keyframeIndex.value] : null
    );
    this._geometry = new three_module.BufferGeometry();
    this._geometry.setAttribute("position", this._positionAttribute);
    this._object = new three_module.Points(this._geometry);
    this._object.matrixAutoUpdate = false;
    this._positions[2] = Z_POS.dot;
    this.updateMaterial();
    const position = (0,runtime_core_esm_bundler/* computed */.Fl)(() => {
      var _a;
      return (_a = this.keyframe.value) == null ? void 0 : _a.pos;
    });
    const value = (0,runtime_core_esm_bundler/* computed */.Fl)(() => {
      var _a;
      return (_a = this.keyframe.value) == null ? void 0 : _a.value;
    });
    (0,runtime_core_esm_bundler/* watch */.YP)(position, this.update.bind(this));
    (0,runtime_core_esm_bundler/* watch */.YP)(value, this.update.bind(this));
    this.update();
    this.register();
  }
  dispose() {
    super.dispose();
    this.options.keyframeHandler.group.remove(this._object);
  }
  highlightable() {
    return true;
  }
  updateMaterial() {
    const material = this.highlighted.value ? MATERIAL.keyframeHandleValue.highlighted : MATERIAL.keyframeHandleValue["default"];
    this._object.material = material;
  }
  update() {
    const keyframe = this.keyframe.value;
    if (!keyframe) {
      this.options.keyframeHandler.group.remove(this._object);
      return;
    }
    this._positions[0] = keyframe.pos;
    this._positions[1] = keyframe.value;
    this._positionAttribute.needsUpdate = true;
    this.afterUpdate();
    this.options.keyframeHandler.group.add(this._object);
  }
  actionController() {
    return this.options.controller.actions.keyframeValue;
  }
  // private _onMoveStartValue: number = 0;
  // onMoveStart(start: Vector2) {
  // 	if (!this.keyframe.value) {
  // 		return;
  // 	}
  // 	this._onMoveStartValue = this.keyframe.value.value;
  // }
  // onMoveProgress(delta: Vector2) {
  // 	if (!this.keyframe.value) {
  // 		return;
  // 	}
  // 	this.keyframe.value.value = this._onMoveStartValue + delta.y;
  // }
  // onMoveEnd() {}
  intersectsBox(box) {
    return false;
  }
  raycastGPUMaterial() {
    return this._raycastGPUMaterial = this._raycastGPUMaterial || pointsRaycastGPUMaterial(this._raycastGPUColor);
  }
}

;// CONCATENATED MODULE: ../src/editor/components/panels/animation/keyframeEditorSceneController/objects/KeyframeHandlePosition.ts





const _v2a = new three_module.Vector2();
const _box2 = new three_module.Box2();
const HEIGHT = 1;
const HALF_HEIGHT = HEIGHT * 0.5;
const POINTS_COUNT = 2;
class KeyframeHandlePosition extends BaseObject {
  constructor(options) {
    super(options);
    this._positions = new Float32Array(POINTS_COUNT * 3);
    // 3 vertices per point
    this._positionAttribute = new three_module.BufferAttribute(this._positions, 3);
    this.keyframe = (0,runtime_core_esm_bundler/* computed */.Fl)(() => {
      return this.options.channelData.value ? this.options.channelData.value.keyframes[this.options.keyframeIndex.value] : null;
    });
    this._geometry = new three_module.BufferGeometry();
    this._geometry.setAttribute("position", this._positionAttribute);
    this._object = new three_module.Line(this._geometry);
    this._object.matrixAutoUpdate = false;
    this.updateMaterial();
    this._positions[0] = 0;
    this._positions[1] = -HALF_HEIGHT;
    this._positions[2] = Z_POS.curve;
    this._positions[3] = 0;
    this._positions[4] = +HALF_HEIGHT;
    this._positions[5] = Z_POS.curve;
    const position = (0,runtime_core_esm_bundler/* computed */.Fl)(() => {
      var _a;
      return (_a = this.keyframe.value) == null ? void 0 : _a.pos;
    });
    const value = (0,runtime_core_esm_bundler/* computed */.Fl)(() => {
      var _a;
      return (_a = this.keyframe.value) == null ? void 0 : _a.value;
    });
    (0,runtime_core_esm_bundler/* watch */.YP)(position, this.update.bind(this));
    (0,runtime_core_esm_bundler/* watch */.YP)(value, this.update.bind(this));
    this.update();
    this.register();
  }
  dispose() {
    super.dispose();
    this.options.keyframeHandler.group.remove(this._object);
  }
  highlightable() {
    return true;
  }
  update() {
    const keyframe = this.keyframe.value;
    if (!keyframe) {
      this.options.keyframeHandler.group.remove(this._object);
      return;
    }
    if (this._object.position.y != keyframe.value) {
      this._object.position.y = keyframe.value;
      this._object.updateMatrix();
    }
    if (this._object.position.x != keyframe.pos) {
      this._object.position.x = keyframe.pos;
      this._object.updateMatrix();
    }
    this.options.keyframeHandler.group.add(this._object);
  }
  updateMaterial() {
    const mats = MATERIAL.keyframeHandlePosition;
    const material = this.selected.value ? mats.selected : this.highlighted.value ? mats.highlighted : mats.default;
    this._object.material = material;
  }
  // private _onMoveStartPos: number = 0;
  // onMoveStart(start: Vector2) {
  // 	if (!this.keyframe.value) {
  // 		return;
  // 	}
  // 	this._onMoveStartPos = this.keyframe.value.pos;
  // 	this.options.keyframeHandler.onMovePositionStart();
  // }
  // onMoveProgress(delta: Vector2) {
  // 	this.options.keyframeHandler.onMovePositionProgress(delta, this._onMoveStartPos);
  // }
  // onMoveEnd() {
  // 	this.options.keyframeHandler.onMovePositionEnd();
  // }
  actionController() {
    return this.options.controller.actions.keyframePosition;
  }
  intersectsBox(box) {
    const { x, y } = this._object.position;
    _v2a.set(x, y);
    if (box.containsPoint(_v2a)) {
      return true;
    }
    const heightMult = KEYFRAME_HANDLE_POSITION_HEIGHT_MULT * FRUSTRUM_SIZE_UNIFORM.value.y;
    _v2a.y += HALF_HEIGHT * heightMult;
    if (box.containsPoint(_v2a)) {
      return true;
    }
    _v2a.y -= HEIGHT * heightMult;
    if (box.containsPoint(_v2a)) {
      return true;
    }
    _box2.min.set(x - 0.1, y - HALF_HEIGHT * heightMult);
    _box2.max.set(x + 0.1, y + HALF_HEIGHT * heightMult);
    return box.intersectsBox(_box2);
  }
  raycastGPUMaterial() {
    return this._raycastGPUMaterial = this._raycastGPUMaterial || keyframeHandlePositionMaterial({ color: this._raycastGPUColor, forGPUraycast: true });
  }
}

// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/core/keyframes/KeyframeCommon.ts
var KeyframeCommon = __webpack_require__(21555);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/core/keyframes/KeyframeTangent.ts
var KeyframeTangent = __webpack_require__(4726);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/core/keyframes/KeyframeSerialize.ts
var KeyframeSerialize = __webpack_require__(33382);
// EXTERNAL MODULE: ../src/editor/history/commands/ParamSet.ts
var ParamSet = __webpack_require__(42362);
// EXTERNAL MODULE: ../src/editor/Editor.ts + 11 modules
var Editor = __webpack_require__(90192);
;// CONCATENATED MODULE: ../src/editor/components/panels/animation/keyframeEditorSceneController/common/Utils.ts


const ORIGIN = new three_module.Vector2(0, 0);
function validatesBox2(box) {
  const minX = Math.min(box.min.x, box.max.x);
  const minY = Math.min(box.min.y, box.max.y);
  const maxX = Math.max(box.min.x, box.max.x);
  const maxY = Math.max(box.min.y, box.max.y);
  box.min.x = minX;
  box.min.y = minY;
  box.max.x = maxX;
  box.max.y = maxY;
}
const ANGLE_MARGIN = 0.01;
const MIN_ANGLE = Math.PI * 1.5 + ANGLE_MARGIN;
const MAX_ANGLE = Math.PI / 2 - ANGLE_MARGIN;
function clampTangentAngle(tangent, isInTangent) {
  let angle = tangent.angle();
  if (angle > Math.PI) {
    if (angle < MIN_ANGLE) {
      const angleExcess = Math.abs(angle) - MIN_ANGLE;
      tangent.rotateAround(ORIGIN, -angleExcess);
    }
  } else {
    if (angle > MAX_ANGLE) {
      const angleExcess = Math.abs(angle) - MAX_ANGLE;
      tangent.rotateAround(ORIGIN, -angleExcess);
    }
  }
}
function channelBounds(options, target) {
  const { channel } = options;
  let { firstPos, lastPos } = options;
  const keyframes = channel.data.keyframes;
  if (firstPos == null) {
    firstPos = keyframes[0].pos;
  }
  if (lastPos == null) {
    lastPos = keyframes[keyframes.length - 1].pos;
  }
  target.min.set(firstPos, -Infinity);
  target.max.set(lastPos, Infinity);
  let minValue = Infinity;
  let maxValue = -Infinity;
  for (let pos = firstPos; pos <= lastPos; pos++) {
    const value = channel.value(pos);
    minValue = Math.min(minValue, value);
    maxValue = Math.max(maxValue, value);
  }
  target.min.y = minValue;
  target.max.y = maxValue;
}

;// CONCATENATED MODULE: ../src/editor/components/panels/animation/keyframeEditorSceneController/objects/KeyframeTangentLine.ts

var KeyframeTangentLine_async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};












const endPt = new three_module.Vector2();
class KeyframeTangentLine extends BaseObject {
  constructor(options, isInTangent) {
    super(options);
    this.isInTangent = isInTangent;
    this._pointsCount = 2;
    this._positions = new Float32Array(this._pointsCount * 3);
    // 3 vertices per point
    this._positionAttribute = new three_module.BufferAttribute(this._positions, 3);
    this._startLength = 0;
    this._keyframePos = new three_module.Vector2();
    this._endPointStart = new three_module.Vector2();
    this._cursorMoveStart = new three_module.Vector2();
    this._cursorMoveProgress = new three_module.Vector2();
    this._endPointMoveProgress = new three_module.Vector2();
    this.keyframe = (0,runtime_core_esm_bundler/* computed */.Fl)(
      () => this.options.channelData.value ? this.options.channelData.value.keyframes[this.options.keyframeIndex.value] : null
    );
    this.displayTangents = (0,runtime_core_esm_bundler/* computed */.Fl)(
      () => {
        var _a;
        return StoreController/* StoreController.editor.keyframeEditor.tangentsDisplayed.value */.F.editor.keyframeEditor.tangentsDisplayed.value && ((_a = this.channelData.value) == null ? void 0 : _a.interpolation) != KeyframeCommon/* ChannelInterpolation.LINEAR */.M.LINEAR;
      }
    );
    this._geometry = new three_module.BufferGeometry();
    this._geometry.setAttribute("position", this._positionAttribute);
    this._object = new three_module.Line(this._geometry);
    this._object.matrixAutoUpdate = false;
    this._positions[0] = 0;
    this._positions[1] = 0;
    this._positions[2] = Z_POS.tangent;
    this._positions[5] = Z_POS.tangent;
    this.updateMaterial();
    this._tangentComputed = (0,runtime_core_esm_bundler/* computed */.Fl)(() => {
      if (this.keyframe.value) {
        return (0,KeyframeTangent/* getTangent */.kQ)(this.keyframe.value, this.isInTangent);
      }
      return null;
    });
    const position = (0,runtime_core_esm_bundler/* computed */.Fl)(() => {
      var _a;
      return (_a = this.keyframe.value) == null ? void 0 : _a.pos;
    });
    const value = (0,runtime_core_esm_bundler/* computed */.Fl)(() => {
      var _a;
      return (_a = this.keyframe.value) == null ? void 0 : _a.value;
    });
    (0,runtime_core_esm_bundler/* watch */.YP)(position, this.update.bind(this));
    (0,runtime_core_esm_bundler/* watch */.YP)(value, this.update.bind(this));
    (0,runtime_core_esm_bundler/* watch */.YP)(this._tangentComputed, this.update.bind(this), { deep: true });
    (0,runtime_core_esm_bundler/* watch */.YP)(this.displayTangents, this._updateVisibility.bind(this));
    this.update();
    this._updateVisibility();
    this.register();
  }
  dispose() {
    super.dispose();
    this.options.keyframeHandler.group.remove(this._object);
  }
  highlightable() {
    return true;
  }
  _updateVisibility() {
    if (this.displayTangents.value) {
      this.options.keyframeHandler.group.add(this._object);
    } else {
      this.options.keyframeHandler.group.remove(this._object);
    }
    this.options.controller.markRenderRequired();
  }
  update() {
    const keyframe = this.keyframe.value;
    if (!keyframe || this._tangentComputed.value == null) {
      this.options.keyframeHandler.group.remove(this._object);
      return;
    }
    if (this._object.position.x != keyframe.pos || this._object.position.y != keyframe.value) {
      this._object.position.x = keyframe.pos;
      this._object.position.y = keyframe.value;
      this._object.updateMatrix();
    }
    const mult = this.isInTangent ? -1 : 1;
    (0,KeyframeTangent/* keyframeTangentToEndPoint */.Y2)(keyframe, this.isInTangent, endPt);
    const newX = endPt.x * mult;
    const newY = endPt.y * mult;
    if (this._positions[3] != newX || this._positions[4] != newY) {
      this._positions[3] = newX;
      this._positions[4] = newY;
      this._positionAttribute.needsUpdate = true;
      this.afterUpdate();
    }
    if (this.displayTangents.value) {
      this.options.keyframeHandler.group.add(this._object);
    }
  }
  updateMaterial() {
    const material = this.highlighted.value ? MATERIAL.keyframeTangentLine.highlighted : MATERIAL.keyframeTangentLine["default"];
    this._object.material = material;
  }
  actionController() {
    return this.options.controller.actions.keyframeTangentAngle;
  }
  // private _tangent: Vector2Like | null = null;
  onMoveStart(event, start) {
    const param = this._dataParam();
    if (!param) {
      return;
    }
    this._paramStartValue = param.value;
    const keyframe = this.keyframe.value;
    if (!keyframe || this._tangentComputed.value == null) {
      this.options.keyframeHandler.group.remove(this._object);
      return;
    }
    (0,KeyframeTangent/* keyframeTangentToEndPoint */.Y2)(keyframe, this.isInTangent, this._endPointStart);
    this._startLength = this._endPointStart.length();
    this._keyframePos.set(keyframe.pos, keyframe.value);
    this._cursorMoveStart.copy(start);
  }
  onMoveProgress(event, delta) {
    const param = this._dataParam();
    if (!(param && this.subChannelDatas.value)) {
      return;
    }
    const keyframe = this.keyframe.value;
    if (!keyframe || this._tangentComputed.value == null) {
      this.options.keyframeHandler.group.remove(this._object);
      return;
    }
    const mult = this.isInTangent ? -1 : 1;
    this._cursorMoveProgress.copy(this._cursorMoveStart).add(delta);
    this._endPointMoveProgress.copy(this._cursorMoveProgress).sub(this._keyframePos).normalize().multiplyScalar(this._startLength * mult);
    clampTangentAngle(this._endPointMoveProgress, this.isInTangent);
    (0,KeyframeTangent/* endPointToKeyframeTangent */.y2)(this._endPointMoveProgress, this.isInTangent, this._tangentComputed.value);
    const newValue = (0,KeyframeSerialize/* channelDataToString */.AS)(this.subChannelDatas.value);
    param.set(newValue);
  }
  onMoveEnd() {
    return KeyframeTangentLine_async(this, null, function* () {
      const param = this._dataParam();
      if (!(param && this.subChannelDatas.value)) {
        return;
      }
      const newValue = (0,KeyframeSerialize/* channelDataToString */.AS)(this.subChannelDatas.value);
      const cmd = new ParamSet/* ParamSetCommand */.O(param, newValue, this._paramStartValue);
      yield Editor/* Editor.instance */.M.instance().pushCommand(cmd);
    });
  }
  intersectsBox(box) {
    return false;
  }
  raycastGPUMaterial() {
    return this._raycastGPUMaterial = this._raycastGPUMaterial || keyframeTangentLineMaterial({ color: this._raycastGPUColor, forGPUraycast: true });
  }
}

;// CONCATENATED MODULE: ../src/editor/components/panels/animation/keyframeEditorSceneController/objects/KeyframeTangentDot.ts

var KeyframeTangentDot_async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};











const KeyframeTangentDot_endPt = new three_module.Vector2();
class KeyframeTangentDot extends BaseObject {
  constructor(options, isInTangent) {
    super(options);
    this.isInTangent = isInTangent;
    this._positions = new Float32Array(3);
    // 3 vertices per point
    this._positionAttribute = new three_module.BufferAttribute(this._positions, 3);
    this._keyframePos = new three_module.Vector2();
    this._endPointStart = new three_module.Vector2();
    this._cursorMoveStart = new three_module.Vector2();
    this._cursorMoveProgress = new three_module.Vector2();
    this._endPointMoveProgress = new three_module.Vector2();
    this.keyframe = (0,runtime_core_esm_bundler/* computed */.Fl)(
      () => this.options.channelData.value ? this.options.channelData.value.keyframes[this.options.keyframeIndex.value] : null
    );
    this.displayTangents = (0,runtime_core_esm_bundler/* computed */.Fl)(
      () => {
        var _a;
        return StoreController/* StoreController.editor.keyframeEditor.tangentsDisplayed.value */.F.editor.keyframeEditor.tangentsDisplayed.value && ((_a = this.channelData.value) == null ? void 0 : _a.interpolation) != KeyframeCommon/* ChannelInterpolation.LINEAR */.M.LINEAR;
      }
    );
    this._geometry = new three_module.BufferGeometry();
    this._geometry.setAttribute("position", this._positionAttribute);
    this._object = new three_module.Points(this._geometry);
    this._object.matrixAutoUpdate = false;
    this._positions[2] = 0.5;
    this._tangentComputed = (0,runtime_core_esm_bundler/* computed */.Fl)(() => {
      if (this.keyframe.value) {
        return (0,KeyframeTangent/* getTangent */.kQ)(this.keyframe.value, this.isInTangent);
      }
      return null;
    });
    this.updateMaterial();
    const position = (0,runtime_core_esm_bundler/* computed */.Fl)(() => {
      var _a;
      return (_a = this.keyframe.value) == null ? void 0 : _a.pos;
    });
    const value = (0,runtime_core_esm_bundler/* computed */.Fl)(() => {
      var _a;
      return (_a = this.keyframe.value) == null ? void 0 : _a.value;
    });
    (0,runtime_core_esm_bundler/* watch */.YP)(position, this.update.bind(this));
    (0,runtime_core_esm_bundler/* watch */.YP)(value, this.update.bind(this));
    (0,runtime_core_esm_bundler/* watch */.YP)(this._tangentComputed, this.update.bind(this), { deep: true });
    (0,runtime_core_esm_bundler/* watch */.YP)(this.displayTangents, this._updateVisibility.bind(this));
    this.update();
    this._updateVisibility();
    this.register();
  }
  dispose() {
    super.dispose();
    this.options.keyframeHandler.group.remove(this._object);
  }
  highlightable() {
    return true;
  }
  _updateVisibility() {
    if (this.displayTangents.value) {
      this.options.keyframeHandler.group.add(this._object);
    } else {
      this.options.keyframeHandler.group.remove(this._object);
    }
  }
  update() {
    const keyframe = this.keyframe.value;
    if (!keyframe || this._tangentComputed.value == null) {
      this.options.keyframeHandler.group.remove(this._object);
      return;
    }
    const mult = this.isInTangent ? -1 : 1;
    (0,KeyframeTangent/* keyframeTangentToEndPoint */.Y2)(keyframe, this.isInTangent, KeyframeTangentDot_endPt);
    this._positions[0] = keyframe.pos + KeyframeTangentDot_endPt.x * mult;
    this._positions[1] = keyframe.value + KeyframeTangentDot_endPt.y * mult;
    this._positionAttribute.needsUpdate = true;
    this.afterUpdate();
    if (this.displayTangents.value) {
      this.options.keyframeHandler.group.add(this._object);
    }
  }
  updateMaterial() {
    const material = this.highlighted.value ? MATERIAL.keyframeTangentDot.highlighted : MATERIAL.keyframeTangentDot["default"];
    this._object.material = material;
  }
  actionController() {
    return this.options.controller.actions.keyframeTangentEnd;
  }
  onMoveStart(event, start) {
    const param = this._dataParam();
    if (!(param && this.options.channelData.value)) {
      return;
    }
    this._paramStartValue = param.value;
    const keyframe = this.keyframe.value;
    if (!keyframe || this._tangentComputed.value == null) {
      return;
    }
    (0,KeyframeTangent/* keyframeTangentToEndPoint */.Y2)(keyframe, this.isInTangent, this._endPointStart);
    this._keyframePos.set(keyframe.pos, keyframe.value);
    this._cursorMoveStart.copy(start);
  }
  onMoveProgress(event, delta) {
    const param = this._dataParam();
    if (!(param && this.subChannelDatas.value)) {
      return;
    }
    const keyframe = this.keyframe.value;
    if (!keyframe || this._tangentComputed.value == null) {
      return;
    }
    const mult = this.isInTangent ? -1 : 1;
    this._cursorMoveProgress.copy(this._cursorMoveStart).add(delta);
    this._endPointMoveProgress.copy(this._cursorMoveProgress).sub(this._keyframePos).multiplyScalar(mult);
    if (event.shiftKey) {
      const newLength = this._endPointMoveProgress.length();
      this._endPointMoveProgress.copy(this._endPointStart).normalize().multiplyScalar(newLength);
    }
    clampTangentAngle(this._endPointMoveProgress, this.isInTangent);
    (0,KeyframeTangent/* endPointToKeyframeTangent */.y2)(this._endPointMoveProgress, this.isInTangent, this._tangentComputed.value);
    const newValue = (0,KeyframeSerialize/* channelDataToString */.AS)(this.subChannelDatas.value);
    param.set(newValue);
  }
  onMoveEnd() {
    return KeyframeTangentDot_async(this, null, function* () {
      const param = this._dataParam();
      if (!(param && this.subChannelDatas.value)) {
        return;
      }
      const newValue = (0,KeyframeSerialize/* channelDataToString */.AS)(this.subChannelDatas.value);
      const cmd = new ParamSet/* ParamSetCommand */.O(param, newValue, this._paramStartValue);
      yield Editor/* Editor.instance */.M.instance().pushCommand(cmd);
    });
  }
  intersectsBox(box) {
    return false;
  }
  raycastGPUMaterial() {
    return this._raycastGPUMaterial = this._raycastGPUMaterial || pointsRaycastGPUMaterial(this._raycastGPUColor);
  }
}

;// CONCATENATED MODULE: ../src/editor/components/panels/animation/keyframeEditorSceneController/elements/KeyframeHandler.ts








class KeyframeHandler {
  constructor(options) {
    this.options = options;
    this.group = new three_module.Group();
    const { controller, channelHandler, nodeId, channelIndex, subChannelIndex, keyframeIndex } = options;
    const keyframeEditor = StoreController/* StoreController.editor.keyframeEditor */.F.editor.keyframeEditor;
    this.keyframeIndex = (0,runtime_core_esm_bundler/* computed */.Fl)(() => keyframeIndex);
    this.channelData = (0,runtime_core_esm_bundler/* computed */.Fl)(() => {
      const nodeData = keyframeEditor.channelDatasByNodeIds.value[nodeId];
      if (!nodeData) {
        return null;
      }
      const channelData = nodeData[channelIndex];
      if (!channelData) {
        return null;
      }
      return channelData[subChannelIndex] || null;
    });
    this.keyframe = (0,runtime_core_esm_bundler/* computed */.Fl)(
      () => this.channelData.value ? this.channelData.value.keyframes[this.keyframeIndex.value] : null
    );
    channelHandler.group.add(this.group);
    this.group.matrixAutoUpdate = false;
    this._valueHandle = new KeyframeHandleValue({
      controller,
      keyframeHandler: this,
      nodeId,
      channelData: this.channelData,
      channelIndex,
      subChannelIndex,
      keyframeIndex: this.keyframeIndex
    });
    this._positionHandle = new KeyframeHandlePosition({
      controller,
      keyframeHandler: this,
      nodeId,
      channelData: this.channelData,
      channelIndex,
      subChannelIndex,
      keyframeIndex: this.keyframeIndex
    });
    this._keyframeTangentLineStart = new KeyframeTangentLine(
      {
        controller,
        keyframeHandler: this,
        nodeId,
        channelData: this.channelData,
        channelIndex,
        subChannelIndex,
        keyframeIndex: this.keyframeIndex
      },
      true
    );
    this._keyframeTangentLineEnd = new KeyframeTangentLine(
      {
        controller,
        keyframeHandler: this,
        nodeId,
        channelData: this.channelData,
        channelIndex,
        subChannelIndex,
        keyframeIndex: this.keyframeIndex
      },
      false
    );
    this._keyframeTangentDotStart = new KeyframeTangentDot(
      {
        controller,
        keyframeHandler: this,
        nodeId,
        channelData: this.channelData,
        channelIndex,
        subChannelIndex,
        keyframeIndex: this.keyframeIndex
      },
      true
    );
    this._keyframeTangentDotEnd = new KeyframeTangentDot(
      {
        controller,
        keyframeHandler: this,
        nodeId,
        channelData: this.channelData,
        channelIndex,
        subChannelIndex,
        keyframeIndex: this.keyframeIndex
      },
      false
    );
    (0,runtime_core_esm_bundler/* watch */.YP)(this.keyframe, this._update.bind(this), { deep: true });
    this._update();
  }
  dispose() {
    this.options.channelHandler.group.remove(this.group);
    this._valueHandle.dispose();
    this._keyframeTangentLineStart.dispose();
    this._keyframeTangentLineEnd.dispose();
    this._keyframeTangentDotStart.dispose();
    this._keyframeTangentDotEnd.dispose();
    this._positionHandle.dispose();
  }
  _update() {
    if (this.keyframe.value == null) {
      this.dispose();
      return;
    }
    this._valueHandle.update();
    this._keyframeTangentLineStart.update();
    this._keyframeTangentLineEnd.update();
    this._keyframeTangentDotStart.update();
    this._keyframeTangentDotEnd.update();
    this._positionHandle.update();
  }
  // onMovePositionStart() {
  // 	this.channelHandler.onKeyframeMovePositionStart(this);
  // }
  // onMovePositionProgress(delta: Vector2, startPos: number) {
  // 	this.channelHandler.onKeyframeMovePositionProgress(this, delta, startPos);
  // }
  // onMovePositionEnd() {
  // 	this.channelHandler.onKeyframeMovePositionEnd(this);
  // }
}

;// CONCATENATED MODULE: ../src/editor/components/panels/animation/keyframeEditorSceneController/elements/ChannelHandler.ts

var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));








const previousTangent = (0,KeyframeTangent/* createKeyframeTangent */.JL)();
const nextTangent = (0,KeyframeTangent/* createKeyframeTangent */.JL)();
const prevValue = new three_module.Vector2();
const nextValue = new three_module.Vector2();
class ChannelHandler {
  constructor(options) {
    this.options = options;
    this.group = new three_module.Group();
    this.segmentHandlers = [];
    this.keyframeHandlers = [];
    this.valuesByPos = (0,reactivity_esm_bundler/* ref */.iH)({});
    const { nodeHandler, nodeId, channelIndex, subChannelIndex } = options;
    const keyframeEditor = StoreController/* StoreController.editor.keyframeEditor */.F.editor.keyframeEditor;
    this.channelData = (0,runtime_core_esm_bundler/* computed */.Fl)(() => {
      const nodeData = keyframeEditor.channelDatasByNodeIds.value[nodeId];
      if (!nodeData) {
        return null;
      }
      const channelData = nodeData[channelIndex];
      if (!channelData) {
        return null;
      }
      return channelData[subChannelIndex] || null;
    });
    this.visible = (0,runtime_core_esm_bundler/* computed */.Fl)(() => {
      const displayedStateForNode = keyframeEditor.channelDisplayedStateBySubChannelIndexByChannelIndexByNodeId.value[nodeId];
      if (!displayedStateForNode) {
        return false;
      }
      const subChannelStates = displayedStateForNode[channelIndex];
      if (subChannelStates == null) {
        return false;
      }
      return subChannelStates[subChannelIndex] || false;
    });
    this._channel = this.channelData.value ? new Channel/* Channel */.$(this.channelData.value) : null;
    nodeHandler.group.add(this.group);
    this.group.matrixAutoUpdate = false;
    const node = StoreController/* StoreController.engine.node */.F.engine.node(nodeId);
    if (!node) {
      throw "bad node";
    }
    (0,runtime_core_esm_bundler/* watch */.YP)(
      this.channelData,
      (newData) => {
        var _a;
        (_a = this._channel) == null ? void 0 : _a.compute();
        this._build(newData);
      },
      { deep: true }
    );
    (0,runtime_core_esm_bundler/* watch */.YP)(this.visible, () => this._updateVisibility());
    this._build(this.channelData.value);
    this._updateVisibility();
  }
  channelIndex() {
    return this.options.channelIndex;
  }
  subChannelIndex() {
    return this.options.subChannelIndex;
  }
  keyframe(index) {
    var _a;
    return (_a = this._channel) == null ? void 0 : _a.data.keyframes[index];
  }
  channelValue(time) {
    if (this._channel) {
      return this._channel.value(time);
    }
  }
  channelTangent(time, target) {
    const v0 = this.channelValue(time - 1) || 0;
    const v1 = this.channelValue(time + 1) || 0;
    prevValue.set(time - 1, v0);
    nextValue.set(time + 1, v1);
    let previousKeyframe;
    let nextKeyframe;
    if (!this.channelData.value) {
      target.slope = 0;
      target.accel = 1;
      return;
    }
    for (const keyframeData of this.channelData.value.keyframes) {
      if (keyframeData.pos < time) {
        previousKeyframe = keyframeData;
      }
      if (keyframeData.pos > time && nextKeyframe == null) {
        nextKeyframe = keyframeData;
      }
    }
    if (previousKeyframe) {
      const t = (0,KeyframeTangent/* getTangent */.kQ)(previousKeyframe, false);
      (0,KeyframeTangent/* copyKeyframeTangent */.ih)(t, previousTangent);
    }
    if (nextKeyframe) {
      const t = (0,KeyframeTangent/* getTangent */.kQ)(nextKeyframe, true);
      (0,KeyframeTangent/* copyKeyframeTangent */.ih)(t, nextTangent);
    }
    if (previousKeyframe && nextKeyframe) {
      const t = (time - previousKeyframe.pos) / (nextKeyframe.pos - previousKeyframe.pos);
      (0,KeyframeTangent/* lerpKeyframeTangents */.mV)(previousTangent, nextTangent, t, target);
      return;
    }
    if (previousKeyframe) {
      target.accel = previousTangent.accel;
      target.slope = 0;
      return;
    }
    if (nextKeyframe) {
      target.accel = nextTangent.accel;
      target.slope = 0;
      return;
    }
    target.accel = 1;
    target.slope = 0;
  }
  dispose() {
    this.options.nodeHandler.group.remove(this.group);
  }
  computeBounds(options, target) {
    if (!this._channel) {
      return;
    }
    channelBounds(__spreadProps(__spreadValues({}, options), { channel: this._channel }), target);
  }
  _updateVisibility() {
    this.group.visible = this.visible.value;
    if (this.visible.value) {
      this.options.nodeHandler.group.add(this.group);
    } else {
      this.options.nodeHandler.group.remove(this.group);
    }
    this.options.controller.markRenderRequired();
  }
  _build(channelData) {
    if (!(channelData && this._channel)) {
      return;
    }
    const keyframes = channelData.keyframes;
    const { controller, nodeId, channelIndex, subChannelIndex } = this.options;
    this.valuesByPos.value = {};
    if (keyframes.length > 0) {
      const firstPos = keyframes[0].pos;
      const lastPos = keyframes[keyframes.length - 1].pos;
      for (let i = firstPos; i <= lastPos; i++) {
        this.valuesByPos.value[i] = this._channel.value(i);
      }
    }
    const keyframesCount = keyframes.length;
    const segmentsCount = keyframesCount - 1;
    if (this.segmentHandlers.length > segmentsCount) {
      const removedSegments = this.segmentHandlers.splice(segmentsCount);
      for (let segment of removedSegments) {
        segment.dispose();
      }
    }
    if (this.keyframeHandlers.length > keyframesCount) {
      const removedKeyframes = this.keyframeHandlers.splice(keyframesCount);
      for (let keyframe of removedKeyframes) {
        keyframe.dispose();
      }
    }
    for (let i = 0; i < segmentsCount; i++) {
      this.segmentHandlers[i] = this.segmentHandlers[i] || new SegmentHandler({
        controller,
        channelHandler: this,
        nodeId,
        channelIndex,
        subChannelIndex,
        segmentIndex: i
      });
    }
    for (let i = 0; i < keyframesCount; i++) {
      let keyframeHandler = this.keyframeHandlers[i];
      if (!keyframeHandler) {
        keyframeHandler = new KeyframeHandler({
          controller,
          channelHandler: this,
          nodeId,
          channelIndex,
          subChannelIndex,
          keyframeIndex: i
        });
        this.keyframeHandlers[i] = keyframeHandler;
      }
    }
  }
}

;// CONCATENATED MODULE: ../src/editor/components/panels/animation/keyframeEditorSceneController/elements/NodeHandler.ts





class NodeHandler {
  constructor(controller, nodeId) {
    this.controller = controller;
    this.nodeId = nodeId;
    this.group = new three_module.Group();
    // public readonly channelNames: ComputedRef<string[] | null>;
    this.channelHandlers = [];
    const keyframecontroller = StoreController/* StoreController.editor.keyframeEditor */.F.editor.keyframeEditor;
    this.channelsData = (0,runtime_core_esm_bundler/* computed */.Fl)(() => keyframecontroller.channelDatasByNodeIds.value[this.nodeId]);
    this.channelDataParamIds = (0,runtime_core_esm_bundler/* computed */.Fl)(
      () => StoreController/* StoreController.editor.keyframeEditor.channelDataParamIdsByNodeId.value */.F.editor.keyframeEditor.channelDataParamIdsByNodeId.value[nodeId]
    );
    (0,runtime_core_esm_bundler/* watch */.YP)(
      this.channelsData,
      () => {
        this._build();
        this.controller.markRenderRequired();
      },
      { deep: true }
    );
    this._build();
  }
  dispose() {
    this.controller.nodesGroup.remove(this.group);
    this.channelHandlers.forEach((list) => list.map((c) => c.dispose()));
  }
  traverseDisplayedChannelHandlers(callback) {
    this.channelHandlers.forEach(
      (list, channelIndex) => list.forEach((c, subChannelIndex) => {
        const isDisplayed = StoreController/* StoreController.editor.keyframeEditor.isChannelDisplayed */.F.editor.keyframeEditor.isChannelDisplayed({
          nodeId: this.nodeId,
          channelIndex,
          subChannelIndex
        });
        if (isDisplayed) {
          callback(c);
        }
      })
    );
  }
  _build() {
    var _a;
    (_a = this.channelsData.value) == null ? void 0 : _a.forEach((channelData, channelIndex) => {
      this.channelHandlers[channelIndex] = this.channelHandlers[channelIndex] || [];
      channelData.forEach((subChannelData, subChannelIndex) => {
        let channelHandler = this.channelHandlers[channelIndex][subChannelIndex];
        if (!channelHandler) {
          channelHandler = new ChannelHandler({
            controller: this.controller,
            nodeHandler: this,
            nodeId: this.nodeId,
            channelIndex,
            subChannelIndex
          });
          this.channelHandlers[channelIndex][subChannelIndex] = channelHandler;
        }
      });
    });
    this.controller.nodesGroup.add(this.group);
  }
}

// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/core/MouseButton.ts
var MouseButton = __webpack_require__(79043);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/core/EventHelper.ts
var EventHelper = __webpack_require__(94633);
// EXTERNAL MODULE: ../src/editor/core/Dom.ts
var Dom = __webpack_require__(16030);
;// CONCATENATED MODULE: ../src/editor/components/panels/animation/keyframeEditorSceneController/controllers/EventsController.ts







const raycaster = new three_module.Raycaster();
const plane = new three_module.Plane(new three_module.Vector3(0, 0, 1), 0);
const CURSOR = {
  // camera: new OrthographicCamera(),
  start: new three_module.Vector2(),
  move: new three_module.Vector2(),
  delta: new three_module.Vector2()
};
const RAYCAST = {
  camera: new three_module.OrthographicCamera(),
  start: new three_module.Vector3(),
  start2D: new three_module.Vector2(),
  move: new three_module.Vector3(),
  delta: new three_module.Vector3(),
  delta2D: new three_module.Vector2()
};
class KeyframeEditorEventsController {
  constructor(options) {
    this.options = options;
    this._onPointermoveProgressBound = this._onPointermoveProgress.bind(this);
    this._onPointerdownBound = this._onPointerdown.bind(this);
    this._onPointerupBound = this._onPointerup.bind(this);
    const { controller, canvasElement, canvasElementParent } = options;
    this.controller = controller;
    const _initIfReady = () => {
      if (canvasElement.value && canvasElementParent.value) {
        this._init(canvasElement.value, canvasElementParent.value);
      }
    };
    (0,runtime_core_esm_bundler/* watch */.YP)(canvasElement, _initIfReady);
    (0,runtime_core_esm_bundler/* watch */.YP)(canvasElementParent, _initIfReady);
  }
  dispose() {
    var _a;
    (_a = this._resizeObserver) == null ? void 0 : _a.disconnect();
  }
  actionInProgress() {
    return this._currentActionController != null;
  }
  _init(canvas, canvasElementParent) {
    this._addEventListeners(canvas);
    this._createResizeObserver(canvasElementParent);
  }
  _addEventListeners(canvas) {
    canvas.addEventListener("wheel", this._onWheelZoom.bind(this));
    canvas.addEventListener("pointerdown", this._onPointerdownBound);
    canvas.addEventListener("contextmenu", (event) => {
      event.preventDefault();
    });
  }
  _onPointerdown(event) {
    const canvas = this.options.canvasElement.value;
    if (!canvas) {
      return;
    }
    Dom/* CoreDom.addDragClasses */.V.addDragClasses();
    this.controller.copyCamera(RAYCAST.camera);
    EventHelper/* EventHelper.normalizedPosition */.z.normalizedPosition(event, canvas, CURSOR.start);
    raycaster.setFromCamera(CURSOR.start, RAYCAST.camera);
    raycaster.ray.intersectPlane(plane, RAYCAST.start);
    RAYCAST.start2D.set(RAYCAST.start.x, RAYCAST.start.y);
    const setCurrentActionController = () => {
      var _a, _b;
      switch (event.button) {
        case MouseButton/* MouseButton.LEFT */.tc.LEFT: {
          if (event.altKey) {
            this.controller.actions.keyframeCreate.createFromEvent(event, RAYCAST.start2D);
            return;
          }
          if (this.controller.currentTime.hovered.value) {
            this._currentActionController = this.controller.actions.currentTime;
            return;
          }
          const hoveredObject = this.controller.raycast.hoveredObject();
          if (hoveredObject) {
            const baseObject = this.controller.objects.baseObject(hoveredObject);
            if (!baseObject) {
              console.warn("no base object found");
              return;
            }
            this._currentActionController = baseObject.actionController();
            if (baseObject.selected.value) {
              const selectedSelectionDatas = StoreController/* StoreController.editor.keyframeEditor.selectedSelectionData.value */.F.editor.keyframeEditor.selectedSelectionData.value;
              (_a = this._currentActionController) == null ? void 0 : _a.setCurrentSelectionDatas(selectedSelectionDatas, baseObject);
            } else {
              (_b = this._currentActionController) == null ? void 0 : _b.setCurrentSelectionDatas(
                [baseObject.selectionData()],
                baseObject
              );
            }
          }
          if (!this._currentActionController) {
            this._currentActionController = this.controller.actions.selection;
          }
          return;
        }
        case MouseButton/* MouseButton.MIDDLE */.tc.MIDDLE: {
          this._currentActionController = this.controller.actions.cameraPan;
          return;
        }
        case MouseButton/* MouseButton.RIGHT */.tc.RIGHT: {
          this._currentActionController = this.controller.actions.cameraZoom;
          return;
        }
      }
    };
    setCurrentActionController();
    if (this._currentActionController) {
      document.addEventListener("pointermove", this._onPointermoveProgressBound);
      document.addEventListener("pointerup", this._onPointerupBound);
      this._currentActionController.onStart(event, RAYCAST.start2D);
    }
  }
  _onPointerup(event) {
    var _a;
    Dom/* CoreDom.removeDragClasses */.V.removeDragClasses();
    (_a = this._currentActionController) == null ? void 0 : _a.onEnd(event);
    this._currentActionController = void 0;
    document.removeEventListener("pointermove", this._onPointermoveProgressBound);
    document.removeEventListener("pointerup", this._onPointerupBound);
  }
  _onPointermoveProgress(event) {
    var _a;
    const canvas = this.options.canvasElement.value;
    if (!canvas) {
      return;
    }
    EventHelper/* EventHelper.normalizedPosition */.z.normalizedPosition(event, canvas, CURSOR.move);
    raycaster.setFromCamera(CURSOR.move, RAYCAST.camera);
    raycaster.ray.intersectPlane(plane, RAYCAST.move);
    RAYCAST.delta.copy(RAYCAST.move).sub(RAYCAST.start);
    RAYCAST.delta2D.set(RAYCAST.delta.x, RAYCAST.delta.y);
    (_a = this._currentActionController) == null ? void 0 : _a.onProgress(event, RAYCAST.delta2D);
  }
  //
  //
  // WHEEL ZOOM
  //
  //
  _onWheelZoom(event) {
    const delta = event.deltaY * 1e-3;
    this.controller.frustumSize.value.multiplyScalar(1 + delta);
  }
  //
  //
  // resize
  //
  //
  _createResizeObserver(canvasElementParent) {
    const resizeObserver = new ResizeObserver((entries) => {
      entries.forEach((entry) => {
        const s = entry.contentBoxSize[0];
        const w = Math.floor(s.inlineSize);
        const h = Math.floor(s.blockSize);
        this.controller.rendererSize.value.set(w, h);
      });
    });
    resizeObserver.observe(canvasElementParent);
    this.onResize();
  }
  onResize() {
    const canvasElementParent = this.options.canvasElementParent.value;
    if (!canvasElementParent) {
      return;
    }
    const rect = canvasElementParent.getBoundingClientRect();
    this.controller.rendererSize.value.set(rect.width, rect.height);
  }
  //
  //
  // Key actions
  //
  //
  deleteSelectedKeys() {
    const controller = this.controller.actions.keyframeDelete;
    const selectedSelectionDatas = StoreController/* StoreController.editor.keyframeEditor.selectedSelectionData.value */.F.editor.keyframeEditor.selectedSelectionData.value;
    controller.setCurrentSelectionDatas(selectedSelectionDatas);
    controller.deleteSelection();
  }
  //
  //
  //
  //
  //
  splitTangents() {
    const controller = this.controller.actions.keyframeTangentSplit;
    const selectedSelectionDatas = StoreController/* StoreController.editor.keyframeEditor.selectedSelectionData.value */.F.editor.keyframeEditor.selectedSelectionData.value;
    controller.setCurrentSelectionDatas(selectedSelectionDatas);
    controller.deleteSelection();
  }
  mergeTangents() {
    const controller = this.controller.actions.keyframeTangentMerge;
    const selectedSelectionDatas = StoreController/* StoreController.editor.keyframeEditor.selectedSelectionData.value */.F.editor.keyframeEditor.selectedSelectionData.value;
    controller.setCurrentSelectionDatas(selectedSelectionDatas);
    controller.deleteSelection();
  }
  setSelectedChannelInterpolation(interpolation) {
    const controller = this.controller.actions.channelInterpolation;
    const selectedSelectionDatas = StoreController/* StoreController.editor.keyframeEditor.selectedSelectionData.value */.F.editor.keyframeEditor.selectedSelectionData.value;
    controller.setCurrentSelectionDatas(selectedSelectionDatas);
    controller.setSelectedChannelsInterpolation(interpolation);
  }
  setSelectedKeyframesPosition(pos) {
    const controller = this.controller.actions.keyframePosition;
    const selectedSelectionDatas = StoreController/* StoreController.editor.keyframeEditor.selectedSelectionData.value */.F.editor.keyframeEditor.selectedSelectionData.value;
    controller.setCurrentSelectionDatas(selectedSelectionDatas);
    controller.setSelectedKeyframesPosition(pos);
  }
  setSelectedKeyframesValue(value) {
    const controller = this.controller.actions.keyframeValue;
    const selectedSelectionDatas = StoreController/* StoreController.editor.keyframeEditor.selectedSelectionData.value */.F.editor.keyframeEditor.selectedSelectionData.value;
    controller.setCurrentSelectionDatas(selectedSelectionDatas);
    controller.setSelectedKeyframesValue(value);
  }
  setSelectedKeyframesValueTangent(options) {
    const controller = this.controller.actions.keyframeTangentSet;
    const selectedSelectionDatas = StoreController/* StoreController.editor.keyframeEditor.selectedSelectionData.value */.F.editor.keyframeEditor.selectedSelectionData.value;
    controller.setCurrentSelectionDatas(selectedSelectionDatas);
    controller.setSelectedTangents(options);
  }
}

;// CONCATENATED MODULE: ../src/editor/components/panels/animation/keyframeEditorSceneController/controllers/KeyframeEditorRaycast.ts





const cursor = new three_module.Vector2();
const cursorGPU = new three_module.Vector2();
const raycastGPUValue = new three_module.Vector4();
class KeyframeEditorRaycast {
  constructor(options) {
    this.options = options;
    this._renderTarget = new three_module.WebGLRenderTarget(1, 1, {
      minFilter: three_module.LinearFilter,
      magFilter: three_module.NearestFilter,
      format: three_module.RGBAFormat,
      type: three_module.FloatType
    });
    this._raycastGPUBuffer = new Float32Array(4);
    this._onPointermoveBound = this._onPointermove.bind(this);
    const { controller, canvasElement } = options;
    this.controller = controller;
    const _initIfReady = () => {
      if (canvasElement.value) {
        this._init(canvasElement.value);
      }
    };
    (0,runtime_core_esm_bundler/* watch */.YP)(canvasElement, _initIfReady);
  }
  dispose() {
    const canvas = this.options.canvasElement.value;
    if (canvas) {
      canvas.removeEventListener("pointermove", this._onPointermoveBound);
    }
  }
  hoveredObject() {
    return this._hoveredObject;
  }
  _init(canvasGPURaycast) {
    this._addEventListeners(canvasGPURaycast);
  }
  _addEventListeners(canvas) {
    canvas.addEventListener("pointermove", this._onPointermoveBound);
  }
  _onPointermove(event) {
    if (this.options.controller.events.actionInProgress()) {
      return;
    }
    const canvas = this.options.canvasElement.value;
    if (!canvas) {
      return;
    }
    const _unhighlightHoveredObject = () => {
      if (this._hoveredObject) {
        const baseObject = this.controller.objects.baseObject(this._hoveredObject);
        if (baseObject) {
          baseObject.highlighted.value = false;
        }
        this._hoveredObject = void 0;
      }
    };
    EventHelper/* EventHelper.normalizedPosition */.z.normalizedPosition(event, canvas, cursor);
    cursorGPU.x = 0.5 * (cursor.x + 1);
    cursorGPU.y = 0.5 * (1 - cursor.y);
    this.controller.renderRaycast(cursorGPU, this._renderTarget, this._raycastGPUBuffer);
    raycastGPUValue.fromArray(this._raycastGPUBuffer);
    const foundId = raycastGPUValue.x;
    if (OBJECT_IDS_SET.has(foundId)) {
      _unhighlightHoveredObject();
      const objectId = foundId;
      switch (objectId) {
        case ObjectId.CURRENT_TIME_LINE: {
          this.controller.currentTime.hovered.value = true;
          break;
        }
      }
    } else {
      this.controller.currentTime.hovered.value = false;
    }
    const foundBaseObject = this.controller.objects.baseObjectFromId(foundId);
    if (!foundBaseObject) {
      const current = this._hoveredObject;
      _unhighlightHoveredObject();
      if (current) {
        this.controller.markRenderRequired();
      }
      return;
    }
    if (this._hoveredObject && foundBaseObject.object() != this._hoveredObject) {
      _unhighlightHoveredObject();
    }
    foundBaseObject.highlighted.value = true;
    this._hoveredObject = foundBaseObject.object();
    this.controller.markRenderRequired();
  }
  // private _updateRaycasterParams() {
  // 	const max = Math.max(
  // 		this.controller.frustumSize.value.x, // this.controller.rendererSize.value.x,
  // 		this.controller.frustumSize.value.y // this.controller.rendererSize.value.y
  // 	);
  // 	const threshold = max * 0.001;
  // 	raycaster.params.Line!.threshold = threshold;
  // 	raycaster.params.Points!.threshold = threshold * POINT_THRESHOLD_MULT;
  // }
}

;// CONCATENATED MODULE: ../src/editor/components/panels/animation/keyframeEditorSceneController/controllers/KeyframeEditorObjectsController.ts

class KeyframeEditorObjectsController {
  constructor(options) {
    this.options = options;
    this._baseObjectByObject3D = /* @__PURE__ */ new Map();
    this._baseObjectById = /* @__PURE__ */ new Map();
  }
  dispose() {
  }
  register(baseObject) {
    this._baseObjectByObject3D.set(baseObject.object(), baseObject);
    this._baseObjectById.set(baseObject.id, baseObject);
  }
  unregister(baseObject) {
    this._baseObjectByObject3D.delete(baseObject.object());
    this._baseObjectById.delete(baseObject.id);
  }
  baseObject(object) {
    return this._baseObjectByObject3D.get(object);
  }
  forEachObject(callback) {
    this._baseObjectByObject3D.forEach(callback);
  }
  baseObjectFromId(id) {
    return this._baseObjectById.get(id);
  }
}

// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/core/geometry/modules/three/builders/Merge.ts
var Merge = __webpack_require__(92276);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/core/render/CSSRenderers/CSS2DObject.ts
var CSS2DObject = __webpack_require__(47130);
;// CONCATENATED MODULE: ../src/editor/components/panels/animation/keyframeEditorSceneController/controllers/BackgroundGridController.ts







function _createRaycaster() {
  const raycaster2 = new three_module.Raycaster();
  return raycaster2;
}
const BackgroundGridController_raycaster = _createRaycaster();
const COORDS = {
  TOP: {
    LEFT: new three_module.Vector2(-1, -1)
  },
  BOTTOM: {
    RIGHT: new three_module.Vector2(1, 1)
  }
};
const viewportBound = new three_module.Box2();
const delta = new three_module.Vector2();
const viewportSize = new three_module.Vector2();
const intervalSize = new three_module.Vector2();
const gridStart = new three_module.Vector2();
const LINES_COUNT = 20;
function _createCSS2DObject() {
  const cssObject = new CSS2DObject/* CSS2DObject */.j();
  cssObject.element.classList.add("animation-editor-css2d-object-axis");
  return cssObject;
}
const CSS_OBJECTS_X = new Array(LINES_COUNT).fill(1).map(_createCSS2DObject);
const CSS_OBJECTS_Y = new Array(LINES_COUNT).fill(1).map(_createCSS2DObject);
function _buildLineSegment(linesCount, material) {
  const horizontalLinesGeometry = () => {
    const pointsCount = linesCount * 2;
    const positions = new Float32Array(pointsCount * 3);
    const indices = new Array(pointsCount);
    for (let i = 0; i < linesCount; i++) {
      const y = i / linesCount;
      const index = i * 2;
      positions[index * 3] = 0;
      positions[index * 3 + 1] = y;
      positions[index * 3 + 2] = 0;
      positions[index * 3 + 3] = 1;
      positions[index * 3 + 4] = y;
      positions[index * 3 + 5] = 0;
      indices[index] = index;
      indices[index + 1] = index + 1;
    }
    const positionAttribute = new three_module.BufferAttribute(positions, 3);
    const geometry2 = new three_module.BufferGeometry();
    geometry2.setAttribute("position", positionAttribute);
    geometry2.setIndex(indices);
    return geometry2;
  };
  const verticalLinesGeometry = () => {
    const pointsCount = linesCount * 2;
    const positions = new Float32Array(pointsCount * 3);
    const indices = new Array(pointsCount);
    for (let i = 0; i < linesCount; i++) {
      const x = i / linesCount;
      const index = i * 2;
      positions[index * 3] = x;
      positions[index * 3 + 1] = 0;
      positions[index * 3 + 2] = 0;
      positions[index * 3 + 3] = x;
      positions[index * 3 + 4] = 1;
      positions[index * 3 + 5] = 0;
      indices[index] = index;
      indices[index + 1] = index + 1;
    }
    const positionAttribute = new three_module.BufferAttribute(positions, 3);
    const geometry2 = new three_module.BufferGeometry();
    geometry2.setAttribute("position", positionAttribute);
    geometry2.setIndex(indices);
    return geometry2;
  };
  const geometries = [horizontalLinesGeometry(), verticalLinesGeometry()];
  const geometry = Merge/* CoreGeometryBuilderMerge.merge */.O.merge(geometries);
  const lineSegments = new three_module.LineSegments(geometry, material);
  return lineSegments;
}
class BackgroundGridController {
  constructor(options) {
    this.options = options;
    this._group = new three_module.Group();
    // private gridHelper: GridHelper;
    this.lines = _buildLineSegment(LINES_COUNT, MATERIAL.bgGrid.lines);
    this.axis1 = _buildLineSegment(1, MATERIAL.bgGrid.axis);
    this.axis2 = _buildLineSegment(1, MATERIAL.bgGrid.axis);
    const { controller } = options;
    this.controller = controller;
    this.controller.scene.add(this._group);
    this.lines.matrixAutoUpdate = false;
    this.lines.position.z = Z_POS.planeHelper;
    this.axis1.matrixAutoUpdate = false;
    this.axis1.position.z = Z_POS.planeHelperAxis;
    this.axis2.matrixAutoUpdate = false;
    this.axis2.position.z = Z_POS.planeHelperAxis;
    this.axis2.rotateZ(Math.PI);
    this._group.add(this.lines);
    this._group.add(this.axis1);
    this._group.add(this.axis2);
    CSS_OBJECTS_X.forEach((cssObject) => this._group.add(cssObject));
    CSS_OBJECTS_Y.forEach((cssObject) => this._group.add(cssObject));
    const frustumSize = this.controller.frustumSize;
    const rendererSize = this.controller.rendererSize;
    const cameraPos = this.controller.cameraPos;
    const toWatchs = [frustumSize, rendererSize, cameraPos];
    for (const toWatch of toWatchs) {
      (0,runtime_core_esm_bundler/* watch */.YP)(
        toWatch,
        () => {
          this.update();
        },
        { deep: true }
      );
    }
  }
  dispose() {
  }
  update() {
    function raycastToVector(vector) {
      vector.x = BackgroundGridController_raycaster.ray.origin.x;
      vector.y = BackgroundGridController_raycaster.ray.origin.y;
    }
    this.controller.setRaycaster(BackgroundGridController_raycaster, COORDS.TOP.LEFT);
    raycastToVector(viewportBound.min);
    this.controller.setRaycaster(BackgroundGridController_raycaster, COORDS.BOTTOM.RIGHT);
    raycastToVector(viewportBound.max);
    validatesBox2(viewportBound);
    delta.copy(viewportBound.max).sub(viewportBound.min);
    viewportBound.getSize(viewportSize);
    intervalSize.x = Math.pow(10, Math.floor(Math.log10(delta.x))) * 1;
    intervalSize.y = Math.pow(10, Math.floor(Math.log10(delta.y))) * 1;
    if (isNaN(intervalSize.x)) {
      intervalSize.x = 1;
    }
    if (isNaN(intervalSize.y)) {
      intervalSize.y = 1;
    }
    intervalSize.x = Math.max(1, intervalSize.x);
    intervalSize.y = Math.max(1, intervalSize.y);
    gridStart.x = Math.floor(viewportBound.min.x / intervalSize.x) * intervalSize.x;
    gridStart.y = Math.floor(viewportBound.min.y / intervalSize.y) * intervalSize.y;
    this.lines.position.x = gridStart.x;
    this.lines.position.y = gridStart.y;
    this.lines.scale.x = intervalSize.x * LINES_COUNT / 2;
    this.lines.scale.y = intervalSize.y * LINES_COUNT / 2;
    this.lines.updateMatrix();
    this.axis1.scale.copy(this.lines.scale);
    this.axis1.updateMatrix();
    this.axis2.scale.copy(this.lines.scale);
    this.axis2.updateMatrix();
    const viewportRatio = viewportSize.x / viewportSize.y;
    for (let i = 0; i < LINES_COUNT; i++) {
      const cssObjectX = CSS_OBJECTS_X[i];
      const cssObjectY = CSS_OBJECTS_Y[i];
      if (cssObjectX) {
        cssObjectX.position.x = this.lines.position.x + i * intervalSize.x;
        cssObjectX.position.y = viewportBound.min.y + 0.05 * viewportSize.y;
        cssObjectX.updateMatrix();
        cssObjectX.element.innerHTML = cssObjectX.position.x.toString();
      }
      if (cssObjectY) {
        cssObjectY.position.x = viewportBound.min.x + 0.05 / viewportRatio * viewportSize.x;
        cssObjectY.position.y = this.lines.position.y + i * intervalSize.y;
        cssObjectY.updateMatrix();
        cssObjectY.element.innerHTML = cssObjectY.position.y.toString();
      }
    }
  }
}

;// CONCATENATED MODULE: ../src/editor/components/panels/animation/keyframeEditorSceneController/controllers/actions/_BaseActionController.ts





class BaseActionController {
  constructor(options) {
    this.options = options;
    this._currentSelectionDatas = (0,reactivity_esm_bundler/* ref */.iH)([]);
    this._keyframeDataForSelectionData = (0,runtime_core_esm_bundler/* computed */.Fl)(() => {
      return this._currentSelectionDatas.value.map(KeyframeEditor/* keyframeDataForSelectionData */.EZ);
    });
    this._otherKeyframeDatasForSelectionData = (0,runtime_core_esm_bundler/* computed */.Fl)(() => {
      return this._currentSelectionDatas.value.map(KeyframeEditor/* otherKeyframeDatasForSelectionData */.vD);
    });
    this._otherKeyframeDatasForSelectionDataNotSelected = (0,runtime_core_esm_bundler/* computed */.Fl)(() => {
      return this._currentSelectionDatas.value.map(KeyframeEditor/* otherKeyframeDatasForSelectionDataNotInSelection */.KS);
    });
    this._dataParamIdForSelectionData = (0,runtime_core_esm_bundler/* computed */.Fl)(() => {
      return this._currentSelectionDatas.value.map(KeyframeEditor/* dataParamIdForSelectionData */.p_);
    });
    this._subChannelDataForSelectionData = (0,runtime_core_esm_bundler/* computed */.Fl)(() => {
      return this._currentSelectionDatas.value.map(KeyframeEditor/* subChannelDataForSelectionData */.Dw);
    });
    this._subChannelDatasForSelectionData = (0,runtime_core_esm_bundler/* computed */.Fl)(() => {
      return this._currentSelectionDatas.value.map(KeyframeEditor/* subChannelDatasForSelectionData */.f);
    });
    this._uniqueParamIds = (0,runtime_core_esm_bundler/* computed */.Fl)(() => {
      const compacted = [];
      const uniqIds = [];
      ArrayUtils/* ArrayUtils.compact */.BB.compact(this._dataParamIdForSelectionData.value, compacted);
      ArrayUtils/* ArrayUtils.uniq */.BB.uniq(compacted, uniqIds);
      return uniqIds;
    });
    this._dataParamValueForUniqueParamIds = (0,runtime_core_esm_bundler/* computed */.Fl)(() => {
      return this._uniqueParamIds.value.map((paramId) => {
        var _a;
        return (_a = StoreController/* StoreController.engine.json_param */.F.engine.json_param(paramId)) == null ? void 0 : _a.value;
      });
    });
    this._subChannelDatasForUniqueParamIds = (0,runtime_core_esm_bundler/* computed */.Fl)(() => {
      const baseSelectionDatas = this._currentSelectionDatas.value;
      let i = 0;
      const _channelDataByParamId = /* @__PURE__ */ new Map();
      for (let _ of baseSelectionDatas) {
        const paramId = this._dataParamIdForSelectionData.value[i];
        const subChannelDatas = this._subChannelDatasForSelectionData.value[i];
        if (paramId != null && subChannelDatas) {
          _channelDataByParamId.set(paramId, subChannelDatas);
        }
        i++;
      }
      return this._uniqueParamIds.value.map((paramId) => _channelDataByParamId.get(paramId));
    });
  }
  dispose() {
  }
  setCurrentSelectionDatas(datas, hoveredObject) {
    this._baseHoveredObject = hoveredObject;
    this._currentSelectionDatas.value.length = 0;
    for (let data of datas) {
      this._currentSelectionDatas.value.push(data);
    }
  }
  onStart(event, start) {
  }
  onProgress(event, delta) {
  }
  onEnd(event) {
  }
}

;// CONCATENATED MODULE: ../src/editor/components/panels/animation/keyframeEditorSceneController/controllers/actions/SelectionController.ts








const SelectionController_raycaster = new three_module.Raycaster();
const SelectionController_plane = new three_module.Plane(new three_module.Vector3(0, 0, 1), 0);
const box = new three_module.Box2();
const SelectionController_CURSOR = {
  // camera: new OrthographicCamera(),
  start: new three_module.Vector2(),
  move: new three_module.Vector2(),
  delta: new three_module.Vector2()
};
const SelectionController_RAYCAST = {
  // camera: new OrthographicCamera(),
  start: new three_module.Vector3(),
  start2D: new three_module.Vector2(),
  move: new three_module.Vector3(),
  move2D: new three_module.Vector2()
  // delta: new Vector3(),
  // delta2D: new Vector2(),
};
function _buildSelectionRectangle() {
  const pointsCount = 4;
  const positions = new Float32Array(pointsCount * 3);
  const indices = [0, 1, 2, 3, 0];
  let i = 0;
  positions[i * 3] = 0;
  positions[i * 3 + 1] = 0;
  positions[i * 3 + 2] = 0;
  i++;
  positions[i * 3] = 1;
  positions[i * 3 + 1] = 0;
  positions[i * 3 + 2] = 0;
  i++;
  positions[i * 3] = 1;
  positions[i * 3 + 1] = 1;
  positions[i * 3 + 2] = 0;
  i++;
  positions[i * 3] = 0;
  positions[i * 3 + 1] = 1;
  positions[i * 3 + 2] = 0;
  const positionAttribute = new three_module.BufferAttribute(positions, 3);
  const geometry = new three_module.BufferGeometry();
  geometry.setAttribute("position", positionAttribute);
  geometry.setIndex(indices);
  const lineSegments = new three_module.Line(geometry, MATERIAL.selectionRectangle);
  return lineSegments;
}
class SelectionController extends BaseActionController {
  constructor(options) {
    super(options);
    // private gridHelper: GridHelper;
    this.selectionRectangle = _buildSelectionRectangle();
    this.selectionData = (0,reactivity_esm_bundler/* ref */.iH)({
      active: false,
      start: new three_module.Vector2(),
      end: new three_module.Vector2()
    });
    const { controller } = options;
    this.controller = controller;
    this.selectionRectangle.matrixAutoUpdate = false;
    this.selectionRectangle.position.z = Z_POS.selectionRectangle;
    this.controller.scene.add(this.selectionRectangle);
    const active = (0,runtime_core_esm_bundler/* computed */.Fl)(() => this.selectionData.value.active);
    (0,runtime_core_esm_bundler/* watch */.YP)(active, (active2) => {
      this._updateRectangleVisibility();
    });
    this._updateRectangleVisibility();
  }
  // private _onPointermoveBound = this._onPointermove.bind(this);
  // private _onPointerupBound = this._onPointerup.bind(this);
  onStart(event) {
    const canvas = this.options.canvasElement.value;
    if (!canvas) {
      return;
    }
    EventHelper/* EventHelper.normalizedPosition */.z.normalizedPosition(event, canvas, SelectionController_CURSOR.start);
    this.controller.setRaycaster(SelectionController_raycaster, SelectionController_CURSOR.start);
    SelectionController_raycaster.ray.intersectPlane(SelectionController_plane, SelectionController_RAYCAST.start);
    SelectionController_RAYCAST.start2D.set(SelectionController_RAYCAST.start.x, SelectionController_RAYCAST.start.y);
    this._setBoxEndFromEvent(event);
  }
  onProgress(event) {
    this.selectionData.value.active = true;
    this._setBoxEndFromEvent(event);
  }
  _setBoxEndFromEvent(event) {
    const canvas = this.options.canvasElement.value;
    if (!canvas) {
      return;
    }
    EventHelper/* EventHelper.normalizedPosition */.z.normalizedPosition(event, canvas, SelectionController_CURSOR.move);
    this.controller.setRaycaster(SelectionController_raycaster, SelectionController_CURSOR.move);
    SelectionController_raycaster.ray.intersectPlane(SelectionController_plane, SelectionController_RAYCAST.move);
    SelectionController_RAYCAST.move2D.set(SelectionController_RAYCAST.move.x, SelectionController_RAYCAST.move.y);
    box.min.copy(SelectionController_RAYCAST.start2D);
    box.max.copy(SelectionController_RAYCAST.move2D);
    validatesBox2(box);
    this.selectionRectangle.position.x = box.min.x;
    this.selectionRectangle.position.y = box.min.y;
    this.selectionRectangle.scale.x = box.max.x - box.min.x;
    this.selectionRectangle.scale.y = box.max.y - box.min.y;
    this.selectionRectangle.updateMatrix();
    this.controller.markRenderRequired();
  }
  onEnd(event) {
    this._selectWithCondition({
      condition: (baseObject) => baseObject.intersectsBox(box),
      addToSelection: event.shiftKey,
      toggleSelection: event.ctrlKey
    });
  }
  clearSelection() {
    StoreController/* StoreController.editor.keyframeEditor.selection.value */.F.editor.keyframeEditor.selection.value = {};
  }
  selectAll() {
    this._selectWithCondition({
      condition: (baseObject) => true,
      addToSelection: false,
      toggleSelection: false
    });
  }
  _selectWithCondition(options) {
    const { condition, addToSelection, toggleSelection } = options;
    const ADD_TO_SELECTION = addToSelection;
    const TOGGLE_SELECTION = toggleSelection;
    this.selectionData.value.active = false;
    const selection = StoreController/* StoreController.editor.keyframeEditor.selection */.F.editor.keyframeEditor.selection;
    if (!(ADD_TO_SELECTION || TOGGLE_SELECTION)) {
      selection.value = {};
    }
    this.controller.objects.forEachObject((baseObject, object3D) => {
      if (condition(baseObject)) {
        const selectionData = baseObject.selectionData();
        let forNodeId = selection.value[selectionData.nodeId];
        if (!forNodeId) {
          forNodeId = [];
          selection.value[selectionData.nodeId] = forNodeId;
        }
        let forChannelIndex = forNodeId[selectionData.channelIndex];
        if (!forChannelIndex) {
          forChannelIndex = [];
          forNodeId[selectionData.channelIndex] = forChannelIndex;
        }
        let forSubChannelIndex = forChannelIndex[selectionData.subChannelIndex];
        if (!forSubChannelIndex) {
          forSubChannelIndex = [];
          forChannelIndex[selectionData.subChannelIndex] = forSubChannelIndex;
        }
        if (!forSubChannelIndex.includes(selectionData.keyframeIndex)) {
          forSubChannelIndex.push(selectionData.keyframeIndex);
        } else if (TOGGLE_SELECTION) {
          const index = forSubChannelIndex.indexOf(selectionData.keyframeIndex);
          forSubChannelIndex.splice(index, 1);
        }
      }
    });
    this.controller.markRenderRequired();
  }
  _updateRectangleVisibility() {
    const active = this.selectionData.value.active;
    this.selectionRectangle.visible = active;
  }
}

;// CONCATENATED MODULE: ../src/editor/components/panels/animation/keyframeEditorSceneController/controllers/actions/CameraPanController.ts




const CameraPanController_raycaster = new three_module.Raycaster();
const CameraPanController_plane = new three_module.Plane(new three_module.Vector3(0, 0, 1), 0);
const PAN = {
  camera: {
    position: {
      start: new three_module.Vector2(),
      end: new three_module.Vector2()
    }
  }
};
const CameraPanController_CURSOR = {
  // camera: new OrthographicCamera(),
  start: new three_module.Vector2(),
  move: new three_module.Vector2(),
  delta: new three_module.Vector2()
};
const CameraPanController_RAYCAST = {
  camera: new three_module.OrthographicCamera(),
  start: new three_module.Vector3(),
  start2D: new three_module.Vector2(),
  move: new three_module.Vector3(),
  delta: new three_module.Vector3(),
  delta2D: new three_module.Vector2()
};
class CameraPanController extends BaseActionController {
  constructor(options) {
    super(options);
  }
  onStart(event) {
    const canvas = this.options.canvasElement.value;
    if (!canvas) {
      return;
    }
    this.options.controller.copyCamera(CameraPanController_RAYCAST.camera);
    EventHelper/* EventHelper.normalizedPosition */.z.normalizedPosition(event, canvas, CameraPanController_CURSOR.start);
    CameraPanController_raycaster.setFromCamera(CameraPanController_CURSOR.start, CameraPanController_RAYCAST.camera);
    CameraPanController_raycaster.ray.intersectPlane(CameraPanController_plane, CameraPanController_RAYCAST.start);
    PAN.camera.position.start.copy(this.options.controller.cameraPos.value);
  }
  onProgress(event) {
    const canvas = this.options.canvasElement.value;
    if (!canvas) {
      return;
    }
    EventHelper/* EventHelper.normalizedPosition */.z.normalizedPosition(event, canvas, CameraPanController_CURSOR.move);
    CameraPanController_raycaster.setFromCamera(CameraPanController_CURSOR.move, CameraPanController_RAYCAST.camera);
    CameraPanController_raycaster.ray.intersectPlane(CameraPanController_plane, CameraPanController_RAYCAST.move);
    CameraPanController_RAYCAST.delta.copy(CameraPanController_RAYCAST.move).sub(CameraPanController_RAYCAST.start);
    CameraPanController_RAYCAST.delta2D.set(CameraPanController_RAYCAST.delta.x, CameraPanController_RAYCAST.delta.y).multiplyScalar(-1);
    PAN.camera.position.end.copy(PAN.camera.position.start).add(CameraPanController_RAYCAST.delta2D);
    this.options.controller.cameraPos.value.copy(PAN.camera.position.end);
  }
  onEnd(event) {
  }
}

// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/core/math/_Module.ts
var _Module = __webpack_require__(27462);
;// CONCATENATED MODULE: ../src/editor/components/panels/animation/keyframeEditorSceneController/controllers/actions/CameraZoomController.ts





const CameraZoomController_raycaster = new three_module.Raycaster();
const CameraZoomController_plane = new three_module.Plane(new three_module.Vector3(0, 0, 1), 0);
const ZOOM = {
  frustumSize: {
    start: new three_module.Vector2(),
    delta: new three_module.Vector2(),
    progress: new three_module.Vector2()
  }
};
const CameraZoomController_CURSOR = {
  // camera: new OrthographicCamera(),
  start: new three_module.Vector2(),
  move: new three_module.Vector2(),
  delta: new three_module.Vector2()
};
const CameraZoomController_RAYCAST = {
  camera: new three_module.OrthographicCamera(),
  start: new three_module.Vector3(),
  start2D: new three_module.Vector2(),
  move: new three_module.Vector3(),
  delta: new three_module.Vector3(),
  delta2D: new three_module.Vector2()
};
var NonUniformZoomAxis = /* @__PURE__ */ ((NonUniformZoomAxis2) => {
  NonUniformZoomAxis2["VERTICAL"] = "vertical";
  NonUniformZoomAxis2["HORIZONTAL"] = "horizontal";
  return NonUniformZoomAxis2;
})(NonUniformZoomAxis || {});
class CameraZoomController extends BaseActionController {
  constructor(options) {
    super(options);
  }
  onStart(event) {
    const canvas = this.options.canvasElement.value;
    if (!canvas) {
      return;
    }
    this.options.controller.copyCamera(CameraZoomController_RAYCAST.camera);
    EventHelper/* EventHelper.normalizedPosition */.z.normalizedPosition(event, canvas, CameraZoomController_CURSOR.start);
    CameraZoomController_raycaster.setFromCamera(CameraZoomController_CURSOR.start, CameraZoomController_RAYCAST.camera);
    CameraZoomController_raycaster.ray.intersectPlane(CameraZoomController_plane, CameraZoomController_RAYCAST.start);
    ZOOM.frustumSize.start.copy(this.options.controller.frustumSize.value);
  }
  onProgress(event) {
    const canvas = this.options.canvasElement.value;
    if (!canvas) {
      return;
    }
    EventHelper/* EventHelper.normalizedPosition */.z.normalizedPosition(event, canvas, CameraZoomController_CURSOR.move);
    CameraZoomController_raycaster.setFromCamera(CameraZoomController_CURSOR.move, CameraZoomController_RAYCAST.camera);
    CameraZoomController_raycaster.ray.intersectPlane(CameraZoomController_plane, CameraZoomController_RAYCAST.move);
    CameraZoomController_RAYCAST.delta.copy(CameraZoomController_RAYCAST.move).sub(CameraZoomController_RAYCAST.start);
    CameraZoomController_CURSOR.delta.copy(CameraZoomController_CURSOR.move).sub(CameraZoomController_CURSOR.start);
    if (event.shiftKey && !this._nonUniformZoomAxis) {
      this._nonUniformZoomAxis = Math.abs(CameraZoomController_CURSOR.delta.x) > Math.abs(CameraZoomController_CURSOR.delta.y) ? "horizontal" /* HORIZONTAL */ : "vertical" /* VERTICAL */;
    }
    const mult = 0.5;
    const MIN = 0.01;
    const MAX = 1e3;
    if (this._nonUniformZoomAxis) {
      let delta = this._nonUniformZoomAxis == "vertical" /* VERTICAL */ ? CameraZoomController_RAYCAST.delta.y : CameraZoomController_RAYCAST.delta.x;
      delta *= mult;
      switch (this._nonUniformZoomAxis) {
        case "vertical" /* VERTICAL */: {
          this.options.controller.frustumSize.value.y = (0,_Module/* clamp */.uZ)(ZOOM.frustumSize.start.y + delta, MIN, MAX);
          return;
        }
        case "horizontal" /* HORIZONTAL */: {
          this.options.controller.frustumSize.value.x = (0,_Module/* clamp */.uZ)(ZOOM.frustumSize.start.x + delta, MIN, MAX);
          return;
        }
      }
    } else {
      CameraZoomController_RAYCAST.delta2D.set(CameraZoomController_RAYCAST.delta.x, CameraZoomController_RAYCAST.delta.y).multiplyScalar(-1);
      ZOOM.frustumSize.progress.copy(ZOOM.frustumSize.start).add(CameraZoomController_RAYCAST.delta2D);
      ZOOM.frustumSize.progress.x = (0,_Module/* clamp */.uZ)(ZOOM.frustumSize.progress.x, MIN, MAX);
      ZOOM.frustumSize.progress.y = (0,_Module/* clamp */.uZ)(ZOOM.frustumSize.progress.y, MIN, MAX);
      this.options.controller.frustumSize.value.copy(ZOOM.frustumSize.progress);
    }
  }
  onEnd(event) {
  }
}

// EXTERNAL MODULE: ../src/editor/history/commands/Multiple.ts
var Multiple = __webpack_require__(71117);
;// CONCATENATED MODULE: ../src/editor/components/panels/animation/keyframeEditorSceneController/controllers/actions/KeyframePositionController.ts

var KeyframePositionController_async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};







class KeyframePositionController extends BaseActionController {
  constructor(options) {
    super(options);
    this._startPosBySelectionData = /* @__PURE__ */ new WeakMap();
  }
  onStart(event, start) {
    this._setProcessData();
  }
  onProgress(event, delta) {
    const baseOffset = Math.round(delta.x);
    this._setNewPos((startPos) => startPos + baseOffset);
  }
  onEnd(event) {
    return KeyframePositionController_async(this, null, function* () {
      yield this._createCommand();
    });
  }
  setSelectedKeyframesPosition(pos) {
    return KeyframePositionController_async(this, null, function* () {
      this._setProcessData();
      this._setNewPos(() => pos);
      yield this._createCommand();
    });
  }
  _setProcessData() {
    const baseSelectionDatas = this._currentSelectionDatas.value;
    const keyframeDatas = this._keyframeDataForSelectionData.value;
    let i = 0;
    for (let selectionData of baseSelectionDatas) {
      const keyframeData = keyframeDatas[i];
      if (keyframeData) {
        this._startPosBySelectionData.set(selectionData, keyframeData.pos);
      }
      i++;
    }
    this._processData = {
      baseSelectionDatas,
      otherKeyframeDatasForSelectionDataNotSelected: this._otherKeyframeDatasForSelectionDataNotSelected.value,
      keyframeDataForSelectionData: this._keyframeDataForSelectionData.value,
      uniqueParamIds: this._uniqueParamIds.value,
      dataParamValueForUniqueParamIds: this._dataParamValueForUniqueParamIds.value,
      subChannelDatasForUniqueParamIds: this._subChannelDatasForUniqueParamIds.value
    };
  }
  _setNewPos(getPos) {
    if (!this._processData) {
      return;
    }
    const newPosBySelectionData = /* @__PURE__ */ new WeakMap();
    const {
      baseSelectionDatas,
      otherKeyframeDatasForSelectionDataNotSelected,
      keyframeDataForSelectionData,
      uniqueParamIds,
      subChannelDatasForUniqueParamIds
    } = this._processData;
    let i = 0;
    for (let selectionData of baseSelectionDatas) {
      const startPos = this._startPosBySelectionData.get(selectionData);
      if (startPos != null) {
        let newPos = getPos(startPos);
        const otherKeyframes = otherKeyframeDatasForSelectionDataNotSelected[i];
        if (otherKeyframes) {
          const existingKeyframeAtPos = otherKeyframes.find((keyframe) => keyframe.pos === newPos);
          const currentKeyframe = keyframeDataForSelectionData[i];
          if (existingKeyframeAtPos && currentKeyframe) {
            const currentPos = currentKeyframe.pos;
            if (newPos < currentPos) {
              newPos -= 1;
            } else {
              newPos += 1;
            }
          }
        }
        newPosBySelectionData.set(selectionData, newPos);
      }
      i++;
    }
    i = 0;
    for (let selectionData of baseSelectionDatas) {
      const newPos = newPosBySelectionData.get(selectionData);
      if (newPos != null) {
        const currentKeyframe = keyframeDataForSelectionData[i];
        if (currentKeyframe) {
          currentKeyframe.pos = newPos;
        }
      }
      i++;
    }
    StoreController/* StoreController.scene.batchUpdates */.F.scene.batchUpdates(() => {
      uniqueParamIds.map((paramId, i2) => {
        const param = StoreController/* StoreController.engine.param */.F.engine.param(paramId);
        if (param) {
          const subChannelDatas = subChannelDatasForUniqueParamIds[i2];
          if (subChannelDatas) {
            const newValue = (0,KeyframeSerialize/* channelDataToString */.AS)(subChannelDatas);
            param.set(newValue);
          }
        }
      });
    });
  }
  _createCommand() {
    return KeyframePositionController_async(this, null, function* () {
      if (!this._processData) {
        return;
      }
      const { uniqueParamIds, dataParamValueForUniqueParamIds, subChannelDatasForUniqueParamIds } = this._processData;
      const multicmd = new Multiple/* MultipleCommand */.Y(StoreController/* StoreController.engine.scene */.F.engine.scene);
      uniqueParamIds.map((paramId, i) => {
        const param = StoreController/* StoreController.engine.param */.F.engine.param(paramId);
        if (param) {
          const subChannelDatas = subChannelDatasForUniqueParamIds[i];
          if (subChannelDatas) {
            subChannelDatas.forEach((d) => Channel/* Channel.validate */.$.validate(d));
            const newValue = (0,KeyframeSerialize/* channelDataToString */.AS)(subChannelDatas);
            const oldValue = dataParamValueForUniqueParamIds[i];
            if (oldValue) {
              const cmd = new ParamSet/* ParamSetCommand */.O(param, newValue, oldValue);
              multicmd.pushCommand(cmd);
            }
          }
        }
      });
      yield Editor/* Editor.instance */.M.instance().pushCommand(multicmd);
    });
  }
}

;// CONCATENATED MODULE: ../src/editor/components/panels/animation/keyframeEditorSceneController/controllers/actions/KeyframeValueController.ts

var KeyframeValueController_async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};






class KeyframeValueController extends BaseActionController {
  constructor(options) {
    super(options);
    this._startValueBySelectionData = /* @__PURE__ */ new WeakMap();
  }
  onStart(event, start) {
    this._setProcessData();
  }
  onProgress(event, delta) {
    const baseOffset = delta.y;
    this._setNewValue((startValue) => startValue + baseOffset);
  }
  onEnd(event) {
    return KeyframeValueController_async(this, null, function* () {
      this._createCommand();
    });
  }
  setSelectedKeyframesValue(value) {
    return KeyframeValueController_async(this, null, function* () {
      this._setProcessData();
      this._setNewValue(() => value);
      yield this._createCommand();
    });
  }
  _setProcessData() {
    const baseSelectionDatas = this._currentSelectionDatas.value;
    const keyframeDatas = this._keyframeDataForSelectionData.value;
    let i = 0;
    for (let selectionData of baseSelectionDatas) {
      const keyframeData = keyframeDatas[i];
      if (keyframeData) {
        this._startValueBySelectionData.set(selectionData, keyframeData.value);
      }
      i++;
    }
    this._processData = {
      baseSelectionDatas,
      // otherKeyframeDatasForSelectionData: this._otherKeyframeDatasForSelectionData.value,
      keyframeDataForSelectionData: this._keyframeDataForSelectionData.value,
      uniqueParamIds: this._uniqueParamIds.value,
      dataParamValueForUniqueParamIds: this._dataParamValueForUniqueParamIds.value,
      subChannelDatasForUniqueParamIds: this._subChannelDatasForUniqueParamIds.value
    };
  }
  _setNewValue(getValue) {
    if (!this._processData) {
      return;
    }
    const newValueBySelectionData = /* @__PURE__ */ new WeakMap();
    const {
      baseSelectionDatas,
      // otherKeyframeDatasForSelectionData,
      keyframeDataForSelectionData,
      uniqueParamIds,
      subChannelDatasForUniqueParamIds
    } = this._processData;
    let i = 0;
    for (let selectionData of baseSelectionDatas) {
      const startValue = this._startValueBySelectionData.get(selectionData);
      if (startValue != null) {
        const newValue = getValue(startValue);
        newValueBySelectionData.set(selectionData, newValue);
      }
      i++;
    }
    i = 0;
    for (let selectionData of baseSelectionDatas) {
      const newValue = newValueBySelectionData.get(selectionData);
      if (newValue != null) {
        const currentKeyframe = keyframeDataForSelectionData[i];
        if (currentKeyframe) {
          currentKeyframe.value = newValue;
        }
      }
      i++;
    }
    StoreController/* StoreController.scene.batchUpdates */.F.scene.batchUpdates(() => {
      uniqueParamIds.map((paramId, i2) => {
        const param = StoreController/* StoreController.engine.param */.F.engine.param(paramId);
        if (param) {
          const subChannelDatas = subChannelDatasForUniqueParamIds[i2];
          if (subChannelDatas) {
            const newValue = (0,KeyframeSerialize/* channelDataToString */.AS)(subChannelDatas);
            param.set(newValue);
          }
        }
      });
    });
  }
  _createCommand() {
    return KeyframeValueController_async(this, null, function* () {
      if (!this._processData) {
        return;
      }
      const { uniqueParamIds, dataParamValueForUniqueParamIds, subChannelDatasForUniqueParamIds } = this._processData;
      const multicmd = new Multiple/* MultipleCommand */.Y(StoreController/* StoreController.engine.scene */.F.engine.scene);
      uniqueParamIds.map((paramId, i) => {
        const param = StoreController/* StoreController.engine.param */.F.engine.param(paramId);
        if (param) {
          const subChannelDatas = subChannelDatasForUniqueParamIds[i];
          if (subChannelDatas) {
            const newValue = (0,KeyframeSerialize/* channelDataToString */.AS)(subChannelDatas);
            const oldValue = dataParamValueForUniqueParamIds[i];
            if (oldValue) {
              const cmd = new ParamSet/* ParamSetCommand */.O(param, newValue, oldValue);
              multicmd.pushCommand(cmd);
            }
          }
        }
      });
      yield Editor/* Editor.instance */.M.instance().pushCommand(multicmd);
    });
  }
}

;// CONCATENATED MODULE: ../src/editor/components/panels/animation/keyframeEditorSceneController/controllers/actions/KeyframeTangentAngleController.ts

var KeyframeTangentAngleController_async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};

class KeyframeTangentAngleController extends BaseActionController {
  constructor(options) {
    super(options);
  }
  onStart(event, start) {
    var _a;
    const canvas = this.options.canvasElement.value;
    if (!canvas) {
      return;
    }
    (_a = this._baseHoveredObject) == null ? void 0 : _a.onMoveStart(event, start);
  }
  onProgress(event, delta) {
    var _a;
    const canvas = this.options.canvasElement.value;
    if (!canvas) {
      return;
    }
    (_a = this._baseHoveredObject) == null ? void 0 : _a.onMoveProgress(event, delta);
  }
  onEnd(event) {
    return KeyframeTangentAngleController_async(this, null, function* () {
      var _a;
      (_a = this._baseHoveredObject) == null ? void 0 : _a.onMoveEnd();
    });
  }
}

;// CONCATENATED MODULE: ../src/editor/components/panels/animation/keyframeEditorSceneController/controllers/actions/KeyframeTangentEndController.ts

var KeyframeTangentEndController_async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};

class KeyframeTangentEndController extends BaseActionController {
  constructor(options) {
    super(options);
  }
  onStart(event, start) {
    var _a;
    const canvas = this.options.canvasElement.value;
    if (!canvas) {
      return;
    }
    (_a = this._baseHoveredObject) == null ? void 0 : _a.onMoveStart(event, start);
  }
  onProgress(event, delta) {
    var _a;
    const canvas = this.options.canvasElement.value;
    if (!canvas) {
      return;
    }
    (_a = this._baseHoveredObject) == null ? void 0 : _a.onMoveProgress(event, delta);
  }
  onEnd(event) {
    return KeyframeTangentEndController_async(this, null, function* () {
      var _a;
      (_a = this._baseHoveredObject) == null ? void 0 : _a.onMoveEnd();
    });
  }
}

// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/core/MapUtils.ts
var MapUtils = __webpack_require__(94158);
;// CONCATENATED MODULE: ../src/editor/components/panels/animation/keyframeEditorSceneController/controllers/actions/KeyframeDeleteController.ts

var KeyframeDeleteController_async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};








class KeyframeDeleteController extends BaseActionController {
  constructor(options) {
    super(options);
  }
  deleteSelection() {
    return KeyframeDeleteController_async(this, null, function* () {
      const selectionDatas = this._currentSelectionDatas.value;
      const dataParamValueForUniqueParamIds = this._dataParamValueForUniqueParamIds.value;
      const uniqueParamIds = this._uniqueParamIds.value;
      const subChannelDatasForUniqueParamIds = this._subChannelDatasForUniqueParamIds.value;
      const selectionDataBySubChannelIndexByChannel = /* @__PURE__ */ new Map();
      selectionDatas.forEach((selectionData) => {
        const subChannelData = (0,KeyframeEditor/* subChannelDataForSelectionData */.Dw)(selectionData);
        if (subChannelData) {
          MapUtils/* MapUtils.pushOnArrayAtEntry */.pl.pushOnArrayAtEntry(selectionDataBySubChannelIndexByChannel, subChannelData, selectionData);
        }
      });
      selectionDataBySubChannelIndexByChannel.forEach((selectionDatasForChannel, channelData) => {
        selectionDatasForChannel.sort((a, b) => {
          return b.keyframeIndex - a.keyframeIndex;
        });
        selectionDatasForChannel.forEach((selectionData) => {
          const keyframeIndex = selectionData.keyframeIndex;
          channelData.keyframes.splice(keyframeIndex, 1);
        });
      });
      const multicmd = new Multiple/* MultipleCommand */.Y(StoreController/* StoreController.engine.scene */.F.engine.scene);
      uniqueParamIds.map((paramId, i) => {
        const param = StoreController/* StoreController.engine.param */.F.engine.param(paramId);
        if (param) {
          const subChannelDatas = subChannelDatasForUniqueParamIds[i];
          if (subChannelDatas) {
            const newValue = (0,KeyframeSerialize/* channelDataToString */.AS)(subChannelDatas);
            const oldValue = dataParamValueForUniqueParamIds[i];
            if (oldValue) {
              const cmd = new ParamSet/* ParamSetCommand */.O(param, newValue, oldValue);
              multicmd.pushCommand(cmd);
            }
          }
        }
      });
      yield Editor/* Editor.instance */.M.instance().pushCommand(multicmd);
      this.options.controller.actions.selection.clearSelection();
    });
  }
}

;// CONCATENATED MODULE: ../src/editor/components/panels/animation/keyframeEditorSceneController/controllers/actions/KeyframeCreateController.ts

var KeyframeCreateController_async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};








const _tangent = (0,KeyframeTangent/* createKeyframeTangent */.JL)();
class KeyframeCreateController extends BaseActionController {
  constructor(options) {
    super(options);
  }
  createFromEvent(event, start) {
    return KeyframeCreateController_async(this, null, function* () {
      const time = Math.round(start.x);
      yield this.createAtTime(time);
    });
  }
  createAtTime(time) {
    return KeyframeCreateController_async(this, null, function* () {
      const keyframeEditor = StoreController/* StoreController.editor.keyframeEditor */.F.editor.keyframeEditor;
      const channelsDisplayedState = keyframeEditor.channelDisplayedStateBySubChannelIndexByChannelIndexByNodeId.value;
      const nodeIds = Object.keys(channelsDisplayedState).map((e) => parseInt(e));
      const channelDataByChannelIndexByNodeId = /* @__PURE__ */ new Map();
      for (const nodeId of nodeIds) {
        const nodeHandler = this.options.controller.nodeHandlersByNodeId.get(nodeId);
        const channelsData = (0,KeyframeEditor/* channelDatasForNodeId */.ps)(nodeId);
        const paramIds = (0,KeyframeEditor/* dataParamIdsForNodeId */.pm)(nodeId);
        if (channelsData && paramIds && nodeHandler) {
          const channelsDataToUpdate = [];
          channelDataByChannelIndexByNodeId.set(nodeId, channelsDataToUpdate);
          const channelsDisplayedStateForNode = channelsDisplayedState[nodeId];
          if (channelsDisplayedStateForNode) {
            channelsDisplayedStateForNode.forEach((channelIndices, channelIndex) => {
              const channelHandlers = nodeHandler.channelHandlers[channelIndex];
              if (channelHandlers) {
                channelHandlers.forEach((channelHandler, subChannelIndex) => {
                  const visibleState = keyframeEditor.isChannelDisplayed({
                    nodeId,
                    channelIndex,
                    subChannelIndex
                  });
                  if (visibleState == true && channelHandler != null) {
                    channelsDataToUpdate[channelIndex] = {
                      channelDatas: channelsData[channelIndex],
                      paramId: paramIds[channelIndex],
                      channelHandlers
                    };
                  }
                });
              }
            });
          }
        }
      }
      channelDataByChannelIndexByNodeId.forEach((channelDataByChannelIndex, nodeId) => {
        channelDataByChannelIndex.forEach((data, channelIndex) => {
          if (data) {
            data.channelDatas.forEach((channelData, subChannelIndex) => {
              const visibleState = keyframeEditor.isChannelDisplayed({ nodeId, channelIndex, subChannelIndex });
              if (visibleState) {
                const channelHandler = data.channelHandlers[subChannelIndex];
                const newKeyframeData = (0,KeyframeSerialize/* createKeyframeData */.f7)();
                newKeyframeData.pos = time;
                newKeyframeData.value = channelHandler.channelValue(time) || 0;
                channelHandler.channelTangent(time, _tangent);
                (0,KeyframeTangent/* copyKeyframeTangent */.ih)(_tangent, newKeyframeData.in);
                let newIndex = 0;
                let keyframeFoundAtTime = false;
                for (const keyframeData of channelData.keyframes) {
                  if (keyframeData.pos < time) {
                    newIndex++;
                  }
                  if (keyframeData.pos == time) {
                    keyframeFoundAtTime = true;
                  }
                }
                if (!keyframeFoundAtTime) {
                  channelData.keyframes.splice(newIndex, 0, newKeyframeData);
                }
              }
            });
          }
        });
      });
      const multicmd = new Multiple/* MultipleCommand */.Y(StoreController/* StoreController.engine.scene */.F.engine.scene);
      channelDataByChannelIndexByNodeId.forEach((channelDataByChannelIndex, nodeId) => {
        for (const data of channelDataByChannelIndex) {
          if (data) {
            const param = StoreController/* StoreController.engine.param */.F.engine.param(data.paramId);
            if (param) {
              const newValue = (0,KeyframeSerialize/* channelDataToString */.AS)(data.channelDatas);
              const oldValue = param.value;
              const cmd = new ParamSet/* ParamSetCommand */.O(param, newValue, oldValue);
              multicmd.pushCommand(cmd);
            }
          }
        }
      });
      yield Editor/* Editor.instance */.M.instance().pushCommand(multicmd);
    });
  }
}

;// CONCATENATED MODULE: ../src/editor/components/panels/animation/keyframeEditorSceneController/controllers/actions/KeyframeTangentSplitController.ts

var KeyframeTangentSplitController_async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};








class KeyframeTangentSplitController extends BaseActionController {
  constructor(options) {
    super(options);
  }
  deleteSelection() {
    return KeyframeTangentSplitController_async(this, null, function* () {
      const selectionDatas = this._currentSelectionDatas.value;
      const dataParamValueForUniqueParamIds = this._dataParamValueForUniqueParamIds.value;
      const uniqueParamIds = this._uniqueParamIds.value;
      const subChannelDatasForUniqueParamIds = this._subChannelDatasForUniqueParamIds.value;
      for (const selectionData of selectionDatas) {
        const keyframeData = (0,KeyframeEditor/* keyframeDataForSelectionData */.EZ)(selectionData);
        if (keyframeData) {
          (0,KeyframeTangent/* keyframeTangentSplit */.Y4)(keyframeData);
        }
      }
      const multicmd = new Multiple/* MultipleCommand */.Y(StoreController/* StoreController.engine.scene */.F.engine.scene);
      uniqueParamIds.map((paramId, i) => {
        const param = StoreController/* StoreController.engine.param */.F.engine.param(paramId);
        if (param) {
          const subChannelDatas = subChannelDatasForUniqueParamIds[i];
          if (subChannelDatas) {
            const newValue = (0,KeyframeSerialize/* channelDataToString */.AS)(subChannelDatas);
            const oldValue = dataParamValueForUniqueParamIds[i];
            if (oldValue) {
              const cmd = new ParamSet/* ParamSetCommand */.O(param, newValue, oldValue);
              multicmd.pushCommand(cmd);
            }
          }
        }
      });
      yield Editor/* Editor.instance */.M.instance().pushCommand(multicmd);
    });
  }
}

;// CONCATENATED MODULE: ../src/editor/components/panels/animation/keyframeEditorSceneController/controllers/actions/KeyframeTangentMergeController.ts

var KeyframeTangentMergeController_async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};








class KeyframeTangentMergeController extends BaseActionController {
  constructor(options) {
    super(options);
  }
  deleteSelection() {
    return KeyframeTangentMergeController_async(this, null, function* () {
      const selectionDatas = this._currentSelectionDatas.value;
      const dataParamValueForUniqueParamIds = this._dataParamValueForUniqueParamIds.value;
      const uniqueParamIds = this._uniqueParamIds.value;
      const subChannelDatasForUniqueParamIds = this._subChannelDatasForUniqueParamIds.value;
      for (const selectionData of selectionDatas) {
        const keyframeData = (0,KeyframeEditor/* keyframeDataForSelectionData */.EZ)(selectionData);
        if (keyframeData) {
          (0,KeyframeTangent/* keyframeTangentMerge */.t4)(keyframeData);
        }
      }
      const multicmd = new Multiple/* MultipleCommand */.Y(StoreController/* StoreController.engine.scene */.F.engine.scene);
      uniqueParamIds.map((paramId, i) => {
        const param = StoreController/* StoreController.engine.param */.F.engine.param(paramId);
        if (param) {
          const subChannelDatas = subChannelDatasForUniqueParamIds[i];
          if (subChannelDatas) {
            const newValue = (0,KeyframeSerialize/* channelDataToString */.AS)(subChannelDatas);
            const oldValue = dataParamValueForUniqueParamIds[i];
            if (oldValue) {
              const cmd = new ParamSet/* ParamSetCommand */.O(param, newValue, oldValue);
              multicmd.pushCommand(cmd);
            }
          }
        }
      });
      yield Editor/* Editor.instance */.M.instance().pushCommand(multicmd);
    });
  }
}

;// CONCATENATED MODULE: ../src/editor/components/panels/animation/keyframeEditorSceneController/controllers/actions/ChannelInterpolationController.ts

var ChannelInterpolationController_async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};








class ChannelInterpolationController extends BaseActionController {
  constructor(options) {
    super(options);
  }
  setSelectedChannelsInterpolation(interpolation) {
    return ChannelInterpolationController_async(this, null, function* () {
      const selectionDatas = this._currentSelectionDatas.value;
      const dataParamValueForUniqueParamIds = this._dataParamValueForUniqueParamIds.value;
      const uniqueParamIds = this._uniqueParamIds.value;
      const subChannelDatasForUniqueParamIds = this._subChannelDatasForUniqueParamIds.value;
      const selectionDataBySubChannelIndexByChannel = /* @__PURE__ */ new Map();
      selectionDatas.forEach((selectionData) => {
        const subChannelData = (0,KeyframeEditor/* subChannelDataForSelectionData */.Dw)(selectionData);
        if (subChannelData) {
          MapUtils/* MapUtils.pushOnArrayAtEntry */.pl.pushOnArrayAtEntry(selectionDataBySubChannelIndexByChannel, subChannelData, selectionData);
        }
      });
      selectionDataBySubChannelIndexByChannel.forEach((selectionDatasForChannel, channelData) => {
        channelData.interpolation = interpolation;
      });
      const multicmd = new Multiple/* MultipleCommand */.Y(StoreController/* StoreController.engine.scene */.F.engine.scene);
      uniqueParamIds.map((paramId, i) => {
        const param = StoreController/* StoreController.engine.param */.F.engine.param(paramId);
        if (param) {
          const subChannelDatas = subChannelDatasForUniqueParamIds[i];
          if (subChannelDatas) {
            const newValue = (0,KeyframeSerialize/* channelDataToString */.AS)(subChannelDatas);
            const oldValue = dataParamValueForUniqueParamIds[i];
            if (oldValue) {
              const cmd = new ParamSet/* ParamSetCommand */.O(param, newValue, oldValue);
              multicmd.pushCommand(cmd);
            }
          }
        }
      });
      yield Editor/* Editor.instance */.M.instance().pushCommand(multicmd);
    });
  }
}

;// CONCATENATED MODULE: ../src/editor/components/panels/animation/keyframeEditorSceneController/controllers/actions/KeyframeTangentSetController.ts

var KeyframeTangentSetController_async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};







class KeyframeTangentSetController extends BaseActionController {
  constructor(options) {
    super(options);
    this._startValueBySelectionData = /* @__PURE__ */ new WeakMap();
  }
  // override onStart(event: PointerEvent, start: Vector2) {
  // 	this._setProcessData();
  // }
  // override onProgress(event: PointerEvent, delta: Vector2) {
  // 	const baseOffset = delta.y;
  // 	this._setNewValue((startValue: number) => startValue + baseOffset);
  // }
  // override async onEnd(event: PointerEvent) {
  // 	this._createCommand();
  // }
  setSelectedTangents(options) {
    return KeyframeTangentSetController_async(this, null, function* () {
      this._setProcessData();
      this._setNewValue(options);
      yield this._createCommand();
    });
  }
  _setProcessData() {
    const baseSelectionDatas = this._currentSelectionDatas.value;
    const keyframeDatas = this._keyframeDataForSelectionData.value;
    let i = 0;
    for (let selectionData of baseSelectionDatas) {
      const keyframeData = keyframeDatas[i];
      if (keyframeData) {
        this._startValueBySelectionData.set(selectionData, keyframeData.value);
      }
      i++;
    }
    this._processData = {
      baseSelectionDatas,
      // otherKeyframeDatasForSelectionData: this._otherKeyframeDatasForSelectionData.value,
      keyframeDataForSelectionData: this._keyframeDataForSelectionData.value,
      uniqueParamIds: this._uniqueParamIds.value,
      dataParamValueForUniqueParamIds: this._dataParamValueForUniqueParamIds.value,
      subChannelDatasForUniqueParamIds: this._subChannelDatasForUniqueParamIds.value
    };
  }
  _setNewValue(options) {
    if (!this._processData) {
      return;
    }
    const {
      baseSelectionDatas,
      // otherKeyframeDatasForSelectionData,
      keyframeDataForSelectionData,
      uniqueParamIds,
      subChannelDatasForUniqueParamIds
    } = this._processData;
    let i = 0;
    for (let _ of baseSelectionDatas) {
      const currentKeyframe = keyframeDataForSelectionData[i];
      if (currentKeyframe) {
        const tangent = (0,KeyframeTangent/* getTangent */.kQ)(currentKeyframe, options.inTangent);
        if (options.slope != null) {
          tangent.slope = options.slope;
        }
        if (options.accel != null) {
          tangent.accel = options.accel;
        }
      }
      i++;
    }
    StoreController/* StoreController.scene.batchUpdates */.F.scene.batchUpdates(() => {
      uniqueParamIds.map((paramId, i2) => {
        const param = StoreController/* StoreController.engine.param */.F.engine.param(paramId);
        if (param) {
          const subChannelDatas = subChannelDatasForUniqueParamIds[i2];
          if (subChannelDatas) {
            const newValue = (0,KeyframeSerialize/* channelDataToString */.AS)(subChannelDatas);
            param.set(newValue);
          }
        }
      });
    });
  }
  _createCommand() {
    return KeyframeTangentSetController_async(this, null, function* () {
      if (!this._processData) {
        return;
      }
      const { uniqueParamIds, dataParamValueForUniqueParamIds, subChannelDatasForUniqueParamIds } = this._processData;
      const multicmd = new Multiple/* MultipleCommand */.Y(StoreController/* StoreController.engine.scene */.F.engine.scene);
      uniqueParamIds.map((paramId, i) => {
        const param = StoreController/* StoreController.engine.param */.F.engine.param(paramId);
        if (param) {
          const subChannelDatas = subChannelDatasForUniqueParamIds[i];
          if (subChannelDatas) {
            const newValue = (0,KeyframeSerialize/* channelDataToString */.AS)(subChannelDatas);
            const oldValue = dataParamValueForUniqueParamIds[i];
            if (oldValue) {
              const cmd = new ParamSet/* ParamSetCommand */.O(param, newValue, oldValue);
              multicmd.pushCommand(cmd);
            }
          }
        }
      });
      yield Editor/* Editor.instance */.M.instance().pushCommand(multicmd);
    });
  }
}

;// CONCATENATED MODULE: ../src/editor/components/panels/animation/keyframeEditorSceneController/controllers/actions/CopyPasteController.ts

var CopyPasteController_async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};









class CopyPasteController extends BaseActionController {
  constructor(options) {
    super(options);
    this._copiedKeyframeDataBySubChannelName = /* @__PURE__ */ new Map();
  }
  copy() {
    this._copiedKeyframeDataBySubChannelName.clear();
    const selection = StoreController/* StoreController.editor.keyframeEditor.selection.value */.F.editor.keyframeEditor.selection.value;
    (0,KeyframeEditor/* traverseSelection */._m)(selection, (selectionData) => {
      const keyframeData = (0,KeyframeEditor/* keyframeDataForSelectionData */.EZ)(selectionData);
      if (keyframeData) {
        const keyframeCopy = (0,KeyframeSerialize/* createKeyframeData */.f7)();
        (0,KeyframeSerialize/* copyKeyframeData */.ik)(keyframeData, keyframeCopy);
        const channelNames = (0,KeyframeEditor/* subChannelNamesForNodeId */.U1)(selectionData.nodeId);
        if (channelNames) {
          const subChannelName = channelNames[selectionData.channelIndex][selectionData.subChannelIndex];
          MapUtils/* MapUtils.pushOnArrayAtEntry */.pl.pushOnArrayAtEntry(this._copiedKeyframeDataBySubChannelName, subChannelName, {
            keyframeData: keyframeCopy,
            selectionData
          });
        }
      }
    });
  }
  paste() {
    return CopyPasteController_async(this, null, function* () {
      const currentTime = this.options.controller.currentTime.currentTime.value;
      const minPos = this._getMinPos();
      const channelDataByChannelIndexByNodeId = /* @__PURE__ */ new Map();
      this._copiedKeyframeDataBySubChannelName.forEach((keyframeDatas, channelName) => {
        const channelData = this._findSubChannelDataByName(channelName);
        if (channelData) {
          keyframeDatas.forEach((keyframeDataAndSelectionData) => {
            const { selectionData } = keyframeDataAndSelectionData;
            const { nodeId, channelIndex } = selectionData;
            let channelsDataToUpdate = channelDataByChannelIndexByNodeId.get(nodeId);
            if (!channelsDataToUpdate) {
              channelsDataToUpdate = [];
              channelDataByChannelIndexByNodeId.set(nodeId, channelsDataToUpdate);
            }
            const channelsData = (0,KeyframeEditor/* channelDatasForNodeId */.ps)(nodeId);
            const paramIds = (0,KeyframeEditor/* dataParamIdsForNodeId */.pm)(nodeId);
            if (channelsData && paramIds) {
              channelsDataToUpdate[channelIndex] = {
                channelDatas: channelsData[channelIndex],
                paramId: paramIds[channelIndex]
              };
            }
          });
        }
      });
      this._copiedKeyframeDataBySubChannelName.forEach((keyframeDatas, channelName) => {
        keyframeDatas.forEach((keyframeDataAndSelectionData) => {
          const { keyframeData, selectionData } = keyframeDataAndSelectionData;
          const { nodeId, channelIndex, subChannelIndex } = selectionData;
          const channelsDataToUpdate = channelDataByChannelIndexByNodeId.get(nodeId);
          if (channelsDataToUpdate) {
            const channelData = channelsDataToUpdate[channelIndex].channelDatas[subChannelIndex];
            if (channelData) {
              const posDelta = keyframeData.pos - minPos;
              const newPos = posDelta + currentTime;
              const keyframeCopy = (0,KeyframeSerialize/* createKeyframeData */.f7)();
              (0,KeyframeSerialize/* copyKeyframeData */.ik)(keyframeData, keyframeCopy);
              keyframeCopy.pos = newPos;
              channelData.keyframes.push(keyframeCopy);
            }
          }
        });
      });
      const multicmd = new Multiple/* MultipleCommand */.Y(StoreController/* StoreController.engine.scene */.F.engine.scene);
      channelDataByChannelIndexByNodeId.forEach((channelDataByChannelIndex, nodeId) => {
        for (const data of channelDataByChannelIndex) {
          if (data) {
            const param = StoreController/* StoreController.engine.param */.F.engine.param(data.paramId);
            if (param) {
              const newValue = (0,KeyframeSerialize/* channelDataToString */.AS)(data.channelDatas);
              const oldValue = param.value;
              const cmd = new ParamSet/* ParamSetCommand */.O(param, newValue, oldValue);
              multicmd.pushCommand(cmd);
            }
          }
        }
      });
      yield Editor/* Editor.instance */.M.instance().pushCommand(multicmd);
    });
  }
  _getMinPos() {
    let minPos = Infinity;
    this._copiedKeyframeDataBySubChannelName.forEach((keyframeDatas) => {
      keyframeDatas.forEach((keyframeDataAndSelectionData) => {
        const { keyframeData } = keyframeDataAndSelectionData;
        if (keyframeData.pos < minPos) {
          minPos = keyframeData.pos;
        }
      });
    });
    return minPos;
  }
  _findSubChannelDataByName(subChannelName) {
    const nodeIds = StoreController/* StoreController.editor.keyframeEditor.nodeIds.value */.F.editor.keyframeEditor.nodeIds.value;
    for (let nodeId of nodeIds) {
      const channelNames = (0,KeyframeEditor/* subChannelNamesForNodeId */.U1)(nodeId);
      if (channelNames) {
        for (let channelIndex = 0; channelIndex < channelNames.length; channelIndex++) {
          const subChannelNames = channelNames[channelIndex];
          for (let subChannelIndex = 0; subChannelIndex < subChannelNames.length; subChannelIndex++) {
            const subChannelNameToCheck = subChannelNames[subChannelIndex];
            if (subChannelNameToCheck == subChannelName) {
              const channelDatas = (0,KeyframeEditor/* channelDatasForNodeId */.ps)(nodeId);
              if (channelDatas) {
                return channelDatas[channelIndex][subChannelIndex];
              }
            }
          }
        }
      }
    }
  }
}

;// CONCATENATED MODULE: ../src/editor/components/panels/animation/keyframeEditorSceneController/controllers/actions/CameraFrameController.ts





const channelsBbox = new three_module.Box2();
const channelsBboxCenter = new three_module.Vector2();
const channelsBboxSize = new three_module.Vector2();
const CameraFrameController_box2 = new three_module.Box2();
class CameraFrameController extends BaseActionController {
  constructor(options) {
    super(options);
  }
  frame() {
    const { controller } = this.options;
    let _channelsBbox;
    const selectedSelectionDatas = StoreController/* StoreController.editor.keyframeEditor.selectedSelectionData.value */.F.editor.keyframeEditor.selectedSelectionData.value;
    if (selectedSelectionDatas.length == 0) {
      const nodeIds = controller.nodeIds.value;
      for (let nodeId of nodeIds) {
        const nodeHandler = controller.nodeHandlersByNodeId.get(nodeId);
        if (nodeHandler) {
          nodeHandler.traverseDisplayedChannelHandlers((channelHandler) => {
            channelHandler.computeBounds({}, CameraFrameController_box2);
            if (_channelsBbox) {
              _channelsBbox.union(CameraFrameController_box2);
            } else {
              _channelsBbox = channelsBbox.copy(CameraFrameController_box2);
            }
          });
        }
      }
    } else {
      const nodeIds = Object.keys(StoreController/* StoreController.editor.keyframeEditor.selection.value */.F.editor.keyframeEditor.selection.value).map((e) => parseInt(e));
      for (let nodeId of nodeIds) {
        const nodeHandler = controller.nodeHandlersByNodeId.get(nodeId);
        if (nodeHandler) {
          nodeHandler.traverseDisplayedChannelHandlers((channelHandler) => {
            const selectionDatasForChannel = selectedSelectionDatas.filter((selectionData) => {
              return selectionData.nodeId == nodeId && selectionData.channelIndex == channelHandler.channelIndex() && selectionData.subChannelIndex == channelHandler.subChannelIndex();
            });
            const selectedKeyframes = [];
            ArrayUtils/* ArrayUtils.compact */.BB.compact(
              selectionDatasForChannel.map((s) => channelHandler.keyframe(s.keyframeIndex)),
              selectedKeyframes
            );
            if (selectedKeyframes.length > 0) {
              const sortedKeyframes = selectedKeyframes.sort((a, b) => a.pos - b.pos);
              const firstPos = sortedKeyframes[0].pos;
              const lastPos = sortedKeyframes[sortedKeyframes.length - 1].pos;
              channelHandler.computeBounds({ firstPos, lastPos }, CameraFrameController_box2);
              if (_channelsBbox) {
                _channelsBbox.union(CameraFrameController_box2);
              } else {
                _channelsBbox = channelsBbox.copy(CameraFrameController_box2);
              }
            }
          });
        }
      }
    }
    if (!_channelsBbox) {
      return;
    }
    _channelsBbox.getCenter(channelsBboxCenter);
    _channelsBbox.getSize(channelsBboxSize);
    channelsBboxSize.x = Math.max(channelsBboxSize.x, 3);
    channelsBboxSize.y = Math.max(channelsBboxSize.y, 0.1);
    const rendererSize = controller.rendererSize.value;
    const ratio = rendererSize.x / rendererSize.y;
    channelsBboxSize.x = channelsBboxSize.x / ratio;
    channelsBboxSize.multiplyScalar(1.2);
    controller.frustumSize.value.set(channelsBboxSize.x, channelsBboxSize.y);
    controller.cameraPos.value.copy(channelsBboxCenter);
    controller.markRenderRequired();
  }
}

;// CONCATENATED MODULE: ../src/editor/components/panels/animation/keyframeEditorSceneController/controllers/actions/CurrentTimeController.ts

var CurrentTimeController_async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};

class CurrentTimeController extends BaseActionController {
  constructor(options) {
    super(options);
    this._startTime = 0;
  }
  onStart(event, start) {
    this._startTime = this.options.controller.currentTime.currentTime.value;
  }
  onProgress(event, delta) {
    const baseOffset = Math.round(delta.x);
    this.options.controller.currentTime.currentTime.value = this._startTime + baseOffset;
  }
  onEnd(event) {
    return CurrentTimeController_async(this, null, function* () {
      this.options.controller.currentTime.hovered.value = false;
    });
  }
}

;// CONCATENATED MODULE: ../src/editor/components/panels/animation/keyframeEditorSceneController/controllers/ActionsController.ts

















class ActionsController {
  constructor(options) {
    this.options = options;
    this.selection = new SelectionController(options);
    this.cameraPan = new CameraPanController(options);
    this.cameraZoom = new CameraZoomController(options);
    this.keyframePosition = new KeyframePositionController(options);
    this.keyframeValue = new KeyframeValueController(options);
    this.keyframeTangentAngle = new KeyframeTangentAngleController(options);
    this.keyframeTangentEnd = new KeyframeTangentEndController(options);
    this.keyframeDelete = new KeyframeDeleteController(options);
    this.keyframeCreate = new KeyframeCreateController(options);
    this.keyframeTangentSplit = new KeyframeTangentSplitController(options);
    this.keyframeTangentMerge = new KeyframeTangentMergeController(options);
    this.channelInterpolation = new ChannelInterpolationController(options);
    this.keyframeTangentSet = new KeyframeTangentSetController(options);
    this.copyPaste = new CopyPasteController(options);
    this.cameraFrame = new CameraFrameController(options);
    this.currentTime = new CurrentTimeController(options);
  }
  dispose() {
    this.selection.dispose();
    this.cameraPan.dispose();
    this.cameraZoom.dispose();
    this.keyframePosition.dispose();
    this.keyframeValue.dispose();
    this.keyframeTangentAngle.dispose();
    this.keyframeTangentEnd.dispose();
    this.keyframeDelete.dispose();
    this.keyframeCreate.dispose();
    this.keyframeTangentSplit.dispose();
    this.keyframeTangentMerge.dispose();
    this.channelInterpolation.dispose();
    this.keyframeTangentSet.dispose();
    this.copyPaste.dispose();
    this.cameraFrame.dispose();
  }
}

;// CONCATENATED MODULE: ../src/editor/components/panels/animation/keyframeEditorSceneController/controllers/CurrentTimeController.ts








function CurrentTimeController_createRaycaster() {
  const raycaster2 = new three_module.Raycaster();
  return raycaster2;
}
const CurrentTimeController_raycaster = CurrentTimeController_createRaycaster();
const CurrentTimeController_COORDS = {
  TOP: {
    LEFT: new three_module.Vector2(-1, -1)
  },
  BOTTOM: {
    RIGHT: new three_module.Vector2(1, 1)
  }
};
const CurrentTimeController_viewportBound = new three_module.Box2();
const CurrentTimeController_cursor = new three_module.Vector2();
function CurrentTimeController_buildLineSegment(linesCount, material) {
  const verticalLinesGeometry = () => {
    const pointsCount = linesCount * 2;
    const positions = new Float32Array(pointsCount * 3);
    const indices = new Array(pointsCount);
    for (let i = 0; i < linesCount; i++) {
      const x = i / linesCount;
      const index = i * 2;
      positions[index * 3] = x;
      positions[index * 3 + 1] = -1;
      positions[index * 3 + 2] = 0;
      positions[index * 3 + 3] = x;
      positions[index * 3 + 4] = 1;
      positions[index * 3 + 5] = 0;
      indices[index] = index;
      indices[index + 1] = index + 1;
    }
    const positionAttribute = new three_module.BufferAttribute(positions, 3);
    const geometry2 = new three_module.BufferGeometry();
    geometry2.setAttribute("position", positionAttribute);
    geometry2.setIndex(indices);
    return geometry2;
  };
  const geometries = [verticalLinesGeometry()];
  const geometry = Merge/* CoreGeometryBuilderMerge.merge */.O.merge(geometries);
  const lineSegments = new three_module.LineSegments(geometry, material);
  lineSegments.frustumCulled = false;
  return lineSegments;
}
class CurrentTimeController_CurrentTimeController {
  constructor(options) {
    this.options = options;
    this.currentTime = (0,reactivity_esm_bundler/* ref */.iH)(1);
    this.hovered = (0,reactivity_esm_bundler/* ref */.iH)(false);
    // private gridHelper: GridHelper;
    this.line = CurrentTimeController_buildLineSegment(1, MATERIAL.currentTime["default"]);
    this._currentTimeBarElement = null;
    this._setTimeFromEventBound = this._setTimeFromEvent.bind(this);
    this._onPointerdownBound = this._onPointerdown.bind(this);
    this._onPointermoveBound = this._onPointermove.bind(this);
    this._onPointerupBound = this._onPointerup.bind(this);
    const { controller } = options;
    this.controller = controller;
    this.controller.scene.add(this.line);
    this.line.matrixAutoUpdate = false;
    this.line.position.z = Z_POS.currentTime;
    this.line.scale.y = 1e5;
    const frustumSize = this.controller.frustumSize;
    const rendererSize = this.controller.rendererSize;
    const cameraPos = this.controller.cameraPos;
    const toWatchs = [frustumSize, rendererSize, cameraPos];
    for (const toWatch of toWatchs) {
      (0,runtime_core_esm_bundler/* watch */.YP)(
        toWatch,
        () => {
          this.updateTimeBounds();
        },
        { deep: true }
      );
    }
    (0,runtime_core_esm_bundler/* watch */.YP)(this.currentTime, () => {
      this.update();
    });
    (0,runtime_core_esm_bundler/* watch */.YP)(this.hovered, () => {
      this._updateMaterial();
    });
    this.update();
  }
  dispose() {
  }
  init(currentTimeBarElement) {
    this._currentTimeBarElement = currentTimeBarElement;
    currentTimeBarElement.addEventListener("pointerdown", this._onPointerdownBound);
    currentTimeBarElement.addEventListener("click", this._setTimeFromEventBound);
  }
  _onPointerdown(event) {
    if (!this._currentTimeBarElement) {
      return;
    }
    Dom/* CoreDom.addDragClasses */.V.addDragClasses();
    document.addEventListener("pointermove", this._onPointermoveBound);
    document.addEventListener("pointerup", this._onPointerupBound);
  }
  _onPointermove(event) {
    if (!this._currentTimeBarElement) {
      return;
    }
    this._setTimeFromEvent(event);
  }
  _onPointerup(event) {
    if (!this._currentTimeBarElement) {
      return;
    }
    Dom/* CoreDom.removeDragClasses */.V.removeDragClasses();
    document.removeEventListener("pointermove", this._onPointermoveBound);
    document.removeEventListener("pointerup", this._onPointerupBound);
  }
  _setTimeFromEvent(event) {
    if (!this._currentTimeBarElement) {
      return;
    }
    EventHelper/* EventHelper.normalizedPosition */.z.normalizedPosition(event, this._currentTimeBarElement, CurrentTimeController_cursor);
    const lerp = (CurrentTimeController_cursor.x + 1) / 2;
    const time = lerp * CurrentTimeController_viewportBound.max.x + (1 - lerp) * CurrentTimeController_viewportBound.min.x;
    this.currentTime.value = Math.round(time);
  }
  updateTimeBounds() {
    function raycastToVector(vector) {
      vector.x = CurrentTimeController_raycaster.ray.origin.x;
      vector.y = CurrentTimeController_raycaster.ray.origin.y;
    }
    this.controller.setRaycaster(CurrentTimeController_raycaster, CurrentTimeController_COORDS.TOP.LEFT);
    raycastToVector(CurrentTimeController_viewportBound.min);
    this.controller.setRaycaster(CurrentTimeController_raycaster, CurrentTimeController_COORDS.BOTTOM.RIGHT);
    raycastToVector(CurrentTimeController_viewportBound.max);
    validatesBox2(CurrentTimeController_viewportBound);
  }
  update() {
    this.line.position.x = this.currentTime.value;
    this.line.updateMatrix();
    this.controller.markRenderRequired();
  }
  _material() {
    return this.hovered.value ? MATERIAL.currentTime.highlighted : MATERIAL.currentTime["default"];
  }
  _updateMaterial() {
    this.line.material = this._material();
    this.controller.markRenderRequired();
  }
  prepareForRaycastGPU() {
    this.line.material = MATERIAL.currentTime.raycasting;
  }
  restoreForRaycastGPU() {
    this._updateMaterial();
  }
}

;// CONCATENATED MODULE: ../src/editor/components/panels/animation/keyframeEditorSceneController/KeyframeEditorSceneController.ts













const ORTHOGRAPHIC_CAMERA_OPTIONS = {
  left: -1,
  right: 1,
  top: 1,
  bottom: -1,
  near: 0.1,
  far: 2
};
class KeyframeEditorSceneController {
  //
  // public readonly data: Ref<ChannelsData>;
  constructor(options) {
    this.options = options;
    this._renderRequired = true;
    //
    this.scene = new three_module.Scene();
    this.nodesGroup = new three_module.Group();
    //
    this.rendererSize = (0,reactivity_esm_bundler/* ref */.iH)(new three_module.Vector2(512, 512));
    this.frustumSize = (0,reactivity_esm_bundler/* ref */.iH)(new three_module.Vector2(20, 20));
    this.cameraPos = (0,reactivity_esm_bundler/* ref */.iH)(new three_module.Vector2(5, 5));
    // public readonly channelHandlersByName: Map<string, ChannelHandler> = new Map();
    this.nodeHandlersByNodeId = /* @__PURE__ */ new Map();
    this._currentNodeIds = [];
    const {
      canvasElement,
      css2DElement,
      canvasGPURaycastElement,
      canvasElementParent,
      currentTimeBarElement,
      nodeIds
    } = options;
    this.events = new KeyframeEditorEventsController({ controller: this, canvasElement, canvasElementParent });
    this.raycast = new KeyframeEditorRaycast({ controller: this, canvasElement });
    this.objects = new KeyframeEditorObjectsController({ controller: this });
    this.backgroundGrid = new BackgroundGridController({ controller: this });
    this.actions = new ActionsController({ controller: this, canvasElement, canvasElementParent });
    this.currentTime = new CurrentTimeController_CurrentTimeController({ controller: this });
    this.scene.matrixAutoUpdate = false;
    this.scene.add(this.nodesGroup);
    this.nodesGroup.matrixAutoUpdate = false;
    this._camera = new three_module.OrthographicCamera(
      ORTHOGRAPHIC_CAMERA_OPTIONS.left,
      ORTHOGRAPHIC_CAMERA_OPTIONS.right,
      ORTHOGRAPHIC_CAMERA_OPTIONS.top,
      ORTHOGRAPHIC_CAMERA_OPTIONS.bottom,
      ORTHOGRAPHIC_CAMERA_OPTIONS.near,
      ORTHOGRAPHIC_CAMERA_OPTIONS.far
    );
    this._camera.position.z = Z_POS.camera;
    const _initIfReady = () => {
      if (canvasElement.value && css2DElement.value && canvasGPURaycastElement.value && currentTimeBarElement.value) {
        this._init({
          canvasVisible: canvasElement.value,
          css2DElement: css2DElement.value,
          canvasGPURaycast: canvasGPURaycastElement.value,
          currentTimeBarElement: currentTimeBarElement.value
        });
      }
    };
    (0,runtime_core_esm_bundler/* watch */.YP)(canvasElement, _initIfReady);
    (0,runtime_core_esm_bundler/* watch */.YP)(css2DElement, _initIfReady);
    (0,runtime_core_esm_bundler/* watch */.YP)(canvasGPURaycastElement, _initIfReady);
    (0,runtime_core_esm_bundler/* watch */.YP)(currentTimeBarElement, _initIfReady);
    this.nodeIds = (0,runtime_core_esm_bundler/* computed */.Fl)(() => nodeIds.value);
    (0,runtime_core_esm_bundler/* watch */.YP)(
      nodeIds,
      (newids) => {
        this._createNodeHandlers(newids);
      },
      { deep: true }
    );
    this._createNodeHandlers(nodeIds.value);
    (0,runtime_core_esm_bundler/* watch */.YP)(this.rendererSize, this._onResize.bind(this), { deep: true });
    (0,runtime_core_esm_bundler/* watch */.YP)(this.frustumSize, this._updateCameraProjectionMatrix.bind(this), { deep: true });
    (0,runtime_core_esm_bundler/* watch */.YP)(this.cameraPos, this._updateCameraPosition.bind(this), { deep: true });
    this._updateCameraPosition();
    this.backgroundGrid.update();
    this.currentTime.updateTimeBounds();
  }
  dispose() {
    var _a, _b;
    (_a = this._rendererVisible) == null ? void 0 : _a.dispose();
    (_b = this._rendererGPURaycast) == null ? void 0 : _b.dispose();
    this.events.dispose();
    this.raycast.dispose();
    this.objects.dispose();
    this.backgroundGrid.dispose();
  }
  frameSelection() {
    this.actions.cameraFrame.frame();
  }
  splitTangents() {
    this.events.splitTangents();
  }
  mergeTangents() {
    this.events.mergeTangents();
  }
  setSelectedChannelInterpolation(interpolation) {
    this.events.setSelectedChannelInterpolation(interpolation);
  }
  setRaycaster(raycaster, cursor) {
    raycaster.setFromCamera(cursor, this._camera);
  }
  renderRaycast(cursorGPU, renderTarget, target) {
    const canvas = this.options.canvasGPURaycastElement.value;
    if (!canvas) {
      return;
    }
    const renderer = this._rendererGPURaycast;
    if (!renderer) {
      return;
    }
    const camera = this._camera;
    camera.setViewOffset(
      renderer.domElement.width,
      renderer.domElement.height,
      cursorGPU.x * renderer.domElement.width,
      cursorGPU.y * renderer.domElement.height,
      1,
      1
    );
    const _prepareScene = () => {
      this.objects.forEachObject((baseObject) => baseObject.prepareForRaycastGPU());
      this.currentTime.prepareForRaycastGPU();
    };
    const _restoreScene = () => {
      this.objects.forEachObject((baseObject) => baseObject.restoreFromRaycastGPU());
      this.currentTime.restoreForRaycastGPU();
    };
    _prepareScene();
    renderer.setRenderTarget(renderTarget);
    renderer.clear();
    renderer.render(this.scene, camera);
    renderer.setRenderTarget(null);
    camera.clearViewOffset();
    _restoreScene();
    renderer.readRenderTargetPixels(renderTarget, 0, 0, 1, 1, target);
  }
  _createNodeHandlers(nodeIds) {
    if (ArrayUtils/* ArrayUtils.isEqual */.BB.isEqual(nodeIds, this._currentNodeIds)) {
      return;
    }
    this._currentNodeIds = [...nodeIds];
    const nodeIdsSet = new Set(nodeIds);
    this.nodeHandlersByNodeId.forEach((nodeHandler, nodeId) => {
      if (!nodeIdsSet.has(nodeId)) {
        nodeHandler.dispose();
        this.nodeHandlersByNodeId.delete(nodeId);
      }
    });
    for (const nodeId of nodeIds) {
      let nodeHandler = this.nodeHandlersByNodeId.get(nodeId);
      if (!nodeHandler) {
        nodeHandler = new NodeHandler(this, nodeId);
        this.nodeHandlersByNodeId.set(nodeId, nodeHandler);
      }
    }
    this.actions.cameraFrame.frame();
  }
  _init(options) {
    const { canvasVisible, canvasGPURaycast, css2DElement, currentTimeBarElement } = options;
    this.currentTime.init(currentTimeBarElement);
    this._rendererVisible = this._rendererVisible || new three_module.WebGLRenderer({
      canvas: canvasVisible,
      antialias: true,
      alpha: false,
      powerPreference: "high-performance",
      preserveDrawingBuffer: false
    });
    this._rendererVisible.setPixelRatio(2);
    this._css2DRenderer = new CSS2DRenderer/* CSS2DRenderer */.M({ element: css2DElement });
    this._rendererGPURaycast = this._rendererGPURaycast || new three_module.WebGLRenderer({
      canvas: canvasGPURaycast,
      antialias: false,
      alpha: false,
      powerPreference: "high-performance",
      preserveDrawingBuffer: false
    });
    this._rendererGPURaycast.toneMapping = three_module.NoToneMapping;
    this._rendererGPURaycast.outputEncoding = three_module.LinearEncoding;
    this._rendererGPURaycast.setPixelRatio(1);
    this._render();
  }
  markRenderRequired() {
    if (this._renderRequired) {
      return;
    }
    this._renderRequired = true;
    requestAnimationFrame(this._render.bind(this));
  }
  _render() {
    var _a, _b;
    if (!this._renderRequired) {
      return;
    }
    this._camera.updateMatrix();
    this._camera.updateProjectionMatrix();
    this.backgroundGrid.update();
    (_a = this._rendererVisible) == null ? void 0 : _a.render(this.scene, this._camera);
    (_b = this._css2DRenderer) == null ? void 0 : _b.render(this.scene, this._camera);
    this._renderRequired = false;
  }
  // private _animate() {
  // 	this._render();
  // 	if (!this._renderRequired) {
  // 		return;
  // 	}
  // 	requestAnimationFrame(this._animate.bind(this));
  // }
  _onResize() {
    if (!(this._rendererVisible && this._css2DRenderer && this._rendererGPURaycast)) {
      return;
    }
    const width = this.rendererSize.value.x;
    const height = this.rendererSize.value.y;
    this._rendererVisible.setSize(width, height);
    this._css2DRenderer.setSize(width, height);
    this._rendererGPURaycast.setSize(width, height);
    this._updateCameraProjectionMatrix();
    this.markRenderRequired();
  }
  _updateCameraProjectionMatrix() {
    const width = this.rendererSize.value.x;
    const height = this.rendererSize.value.y;
    const aspect = width / height;
    this._camera.left = -this.frustumSize.value.x * aspect / 2;
    this._camera.right = this.frustumSize.value.x * aspect / 2;
    this._camera.top = this.frustumSize.value.y / 2;
    this._camera.bottom = -this.frustumSize.value.y / 2;
    this._camera.updateProjectionMatrix();
    _updateMaterialHandleFrustrumSize(this.frustumSize.value);
    this.markRenderRequired();
    this._render();
  }
  _updateCameraPosition() {
    this._camera.position.x = this.cameraPos.value.x;
    this._camera.position.y = this.cameraPos.value.y;
    this._camera.updateMatrix();
    this.markRenderRequired();
  }
  copyCamera(target) {
    target.copy(this._camera);
  }
}

// EXTERNAL MODULE: ../src/editor/components/panels/animation/mixins/LayoutData.ts
var LayoutData = __webpack_require__(21168);
;// CONCATENATED MODULE: ../src/editor/components/panels/animation/mixins/SetupForm.ts





function SetupForm(options) {
  const { sceneController } = options;
  const keyframeEditor = StoreController/* StoreController.editor.keyframeEditor */.F.editor.keyframeEditor;
  const keyframePos = (0,reactivity_esm_bundler/* ref */.iH)(0);
  const keyframeValue = (0,reactivity_esm_bundler/* ref */.iH)(0);
  const keyframeInSlope = (0,reactivity_esm_bundler/* ref */.iH)(0);
  const keyframeInAccel = (0,reactivity_esm_bundler/* ref */.iH)(0);
  const keyframeOutSlope = (0,reactivity_esm_bundler/* ref */.iH)(0);
  const keyframeOutAccel = (0,reactivity_esm_bundler/* ref */.iH)(0);
  const selectionActive = (0,runtime_core_esm_bundler/* computed */.Fl)(() => {
    return keyframeEditor.selectedSelectionData.value.length > 0;
  });
  const firstSelectionData = (0,runtime_core_esm_bundler/* computed */.Fl)(() => {
    return keyframeEditor.selectedSelectionData.value[0];
  });
  const firstSelectedKeyframeData = (0,runtime_core_esm_bundler/* computed */.Fl)(() => {
    if (firstSelectionData.value) {
      const channelData = (0,KeyframeEditor/* subChannelDataForSelectionData */.Dw)(firstSelectionData.value);
      if (channelData) {
        return channelData.keyframes[firstSelectionData.value.keyframeIndex];
      }
    }
  });
  const keyframePosActive = (0,runtime_core_esm_bundler/* computed */.Fl)(() => selectionActive.value);
  const keyframeValueActive = (0,runtime_core_esm_bundler/* computed */.Fl)(() => selectionActive.value);
  const keyframeInActive = (0,runtime_core_esm_bundler/* computed */.Fl)(() => selectionActive.value);
  const keyframeOutActive = (0,runtime_core_esm_bundler/* computed */.Fl)(() => {
    var _a;
    return keyframeInActive.value && ((_a = firstSelectedKeyframeData.value) == null ? void 0 : _a.out) != null;
  });
  const selectedKeyframePos = (0,runtime_core_esm_bundler/* computed */.Fl)(() => {
    var _a;
    return (_a = firstSelectedKeyframeData.value) == null ? void 0 : _a.pos;
  });
  const selectedKeyframeValue = (0,runtime_core_esm_bundler/* computed */.Fl)(() => {
    var _a;
    return (_a = firstSelectedKeyframeData.value) == null ? void 0 : _a.value;
  });
  const selectedKeyframeIn = (0,runtime_core_esm_bundler/* computed */.Fl)(
    () => (firstSelectedKeyframeData == null ? void 0 : firstSelectedKeyframeData.value) ? (0,KeyframeTangent/* getTangent */.kQ)(firstSelectedKeyframeData.value, true) : null
  );
  const selectedKeyframeOut = (0,runtime_core_esm_bundler/* computed */.Fl)(
    () => (firstSelectedKeyframeData == null ? void 0 : firstSelectedKeyframeData.value) ? (0,KeyframeTangent/* getTangent */.kQ)(firstSelectedKeyframeData.value, false) : null
  );
  const selectedKeyframeInSlope = (0,runtime_core_esm_bundler/* computed */.Fl)(() => {
    var _a;
    return (_a = selectedKeyframeIn.value) == null ? void 0 : _a.slope;
  });
  const selectedKeyframeInAccel = (0,runtime_core_esm_bundler/* computed */.Fl)(() => {
    var _a;
    return (_a = selectedKeyframeIn.value) == null ? void 0 : _a.accel;
  });
  const selectedKeyframeOutSlope = (0,runtime_core_esm_bundler/* computed */.Fl)(() => {
    var _a;
    return (_a = selectedKeyframeOut.value) == null ? void 0 : _a.slope;
  });
  const selectedKeyframeOutAccel = (0,runtime_core_esm_bundler/* computed */.Fl)(() => {
    var _a;
    return (_a = selectedKeyframeOut.value) == null ? void 0 : _a.accel;
  });
  (0,runtime_core_esm_bundler/* watch */.YP)(selectedKeyframePos, () => {
    keyframePos.value = selectedKeyframePos.value || 0;
  });
  (0,runtime_core_esm_bundler/* watch */.YP)(selectedKeyframeValue, () => {
    keyframeValue.value = selectedKeyframeValue.value || 0;
  });
  (0,runtime_core_esm_bundler/* watch */.YP)(selectedKeyframeInSlope, () => {
    keyframeInSlope.value = selectedKeyframeInSlope.value || 0;
  });
  (0,runtime_core_esm_bundler/* watch */.YP)(selectedKeyframeInAccel, () => {
    keyframeInAccel.value = selectedKeyframeInAccel.value || 0;
  });
  (0,runtime_core_esm_bundler/* watch */.YP)(selectedKeyframeOutSlope, () => {
    keyframeOutSlope.value = selectedKeyframeOutSlope.value || 0;
  });
  (0,runtime_core_esm_bundler/* watch */.YP)(selectedKeyframeOutAccel, () => {
    keyframeOutAccel.value = selectedKeyframeOutAccel.value || 0;
  });
  function onKeyframePosChange() {
    sceneController.events.setSelectedKeyframesPosition(keyframePos.value);
  }
  function onKeyframeValueChange() {
    sceneController.events.setSelectedKeyframesValue(keyframeValue.value);
  }
  function onKeyframeTangentInSlopeChange() {
    sceneController.events.setSelectedKeyframesValueTangent({ slope: keyframeInSlope.value, inTangent: true });
  }
  function onKeyframeTangentInAccelChange() {
    sceneController.events.setSelectedKeyframesValueTangent({ accel: keyframeInAccel.value, inTangent: true });
  }
  function onKeyframeTangentOutSlopeChange() {
    sceneController.events.setSelectedKeyframesValueTangent({ slope: keyframeOutSlope.value, inTangent: false });
  }
  function onKeyframeTangentOutAccelChange() {
    sceneController.events.setSelectedKeyframesValueTangent({ accel: keyframeOutAccel.value, inTangent: false });
  }
  return {
    selectionActive,
    keyframePos,
    keyframeValue,
    keyframeInSlope,
    keyframeInAccel,
    keyframeOutSlope,
    keyframeOutAccel,
    keyframePosActive,
    keyframeValueActive,
    keyframeInActive,
    keyframeOutActive,
    //
    onKeyframePosChange,
    onKeyframeValueChange,
    onKeyframeTangentInSlopeChange,
    onKeyframeTangentInAccelChange,
    onKeyframeTangentOutSlopeChange,
    onKeyframeTangentOutAccelChange
  };
}

// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/poly/Assert.ts
var Assert = __webpack_require__(68239);
;// CONCATENATED MODULE: ../src/editor/components/panels/animation/mixins/SetupFormInterpolation.ts





function SetupFormInterpolation(options) {
  const { sceneController } = options;
  const keyframeEditor = StoreController/* StoreController.editor.keyframeEditor */.F.editor.keyframeEditor;
  const interpolationDropdownActive = (0,runtime_core_esm_bundler/* computed */.Fl)(() => {
    return keyframeEditor.selectedSelectionData.value.length > 0;
  });
  const currentInterpolation = (0,runtime_core_esm_bundler/* computed */.Fl)(() => "interpolation");
  const interpolationMenuEntries = (0,runtime_core_esm_bundler/* computed */.Fl)(() => {
    const entries = [];
    if (!interpolationDropdownActive.value) {
      return entries;
    }
    entries.push({ id: KeyframeCommon/* ChannelInterpolation.CUBIC */.M.CUBIC });
    entries.push({ id: KeyframeCommon/* ChannelInterpolation.LINEAR */.M.LINEAR });
    return entries;
  });
  function onInterpolationsMenuEntrySelect(entry) {
    switch (entry) {
      case KeyframeCommon/* ChannelInterpolation.CUBIC */.M.CUBIC: {
        sceneController.setSelectedChannelInterpolation(KeyframeCommon/* ChannelInterpolation.CUBIC */.M.CUBIC);
        return;
      }
      case KeyframeCommon/* ChannelInterpolation.LINEAR */.M.LINEAR: {
        sceneController.setSelectedChannelInterpolation(KeyframeCommon/* ChannelInterpolation.LINEAR */.M.LINEAR);
        return;
      }
    }
    Assert/* TypeAssert.unreachable */.f.unreachable(entry);
  }
  return {
    interpolationDropdownActive,
    currentInterpolation,
    interpolationMenuEntries,
    onInterpolationsMenuEntrySelect
  };
}

;// CONCATENATED MODULE: ../src/editor/components/panels/animation/mixins/SetupButtons.ts



function SetupButtons(options) {
  const { sceneController } = options;
  const keyframeEditor = StoreController/* StoreController.editor.keyframeEditor */.F.editor.keyframeEditor;
  const keyframeButtonsActive = (0,runtime_core_esm_bundler/* computed */.Fl)(() => {
    return keyframeEditor.selectedSelectionData.value.length > 0;
  });
  const addKeyframesButtonActive = (0,runtime_core_esm_bundler/* computed */.Fl)(() => true);
  function addKeys() {
    const currentTime = sceneController.currentTime.currentTime.value;
    sceneController.actions.keyframeCreate.createAtTime(currentTime);
  }
  function deleteSelectedKeyframes() {
    sceneController.events.deleteSelectedKeys();
  }
  function splitTangents() {
    sceneController.splitTangents();
  }
  function mergeTangents() {
    sceneController.mergeTangents();
  }
  function frameSelection() {
    sceneController.frameSelection();
  }
  return {
    addKeys,
    deleteSelectedKeyframes,
    addKeyframesButtonActive,
    keyframeButtonsActive,
    splitTangents,
    mergeTangents,
    frameSelection
  };
}

// EXTERNAL MODULE: ../node_modules/@heroicons/vue/24/outline/ChevronUpIcon.js
var ChevronUpIcon = __webpack_require__(98874);
// EXTERNAL MODULE: ../node_modules/@heroicons/vue/24/outline/ChevronRightIcon.js
var ChevronRightIcon = __webpack_require__(13247);
// EXTERNAL MODULE: ../node_modules/@heroicons/vue/24/outline/ChevronDownIcon.js
var ChevronDownIcon = __webpack_require__(71350);
// EXTERNAL MODULE: ../node_modules/@heroicons/vue/24/outline/MinusIcon.js
var MinusIcon = __webpack_require__(54949);
// EXTERNAL MODULE: ../node_modules/@heroicons/vue/24/outline/TrashIcon.js
var TrashIcon = __webpack_require__(80941);
// EXTERNAL MODULE: ../node_modules/@heroicons/vue/24/outline/PlusIcon.js
var PlusIcon = __webpack_require__(55269);
// EXTERNAL MODULE: ../node_modules/@heroicons/vue/24/outline/MagnifyingGlassIcon.js
var MagnifyingGlassIcon = __webpack_require__(46096);
// EXTERNAL MODULE: ../node_modules/@heroicons/vue/24/outline/XMarkIcon.js
var XMarkIcon = __webpack_require__(89077);
// EXTERNAL MODULE: ../node_modules/@heroicons/vue/24/outline/EyeIcon.js
var EyeIcon = __webpack_require__(11382);
// EXTERNAL MODULE: ../node_modules/@heroicons/vue/24/outline/EyeSlashIcon.js
var EyeSlashIcon = __webpack_require__(79514);
;// CONCATENATED MODULE: ../node_modules/esbuild-loader/dist/index.cjs??clonedRuleSet-2.use[0]!../node_modules/vue-loader/dist/index.js??ruleSet[1].rules[14].use[0]!../src/editor/components/panels/animation/AnimationCore.vue?vue&type=script&lang=ts
var AnimationCorevue_type_script_lang_ts_defProp = Object.defineProperty;
var AnimationCorevue_type_script_lang_ts_defProps = Object.defineProperties;
var AnimationCorevue_type_script_lang_ts_getOwnPropDescs = Object.getOwnPropertyDescriptors;
var AnimationCorevue_type_script_lang_ts_getOwnPropSymbols = Object.getOwnPropertySymbols;
var AnimationCorevue_type_script_lang_ts_hasOwnProp = Object.prototype.hasOwnProperty;
var AnimationCorevue_type_script_lang_ts_propIsEnum = Object.prototype.propertyIsEnumerable;
var AnimationCorevue_type_script_lang_ts_defNormalProp = (obj, key, value) => key in obj ? AnimationCorevue_type_script_lang_ts_defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var AnimationCorevue_type_script_lang_ts_spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (AnimationCorevue_type_script_lang_ts_hasOwnProp.call(b, prop))
      AnimationCorevue_type_script_lang_ts_defNormalProp(a, prop, b[prop]);
  if (AnimationCorevue_type_script_lang_ts_getOwnPropSymbols)
    for (var prop of AnimationCorevue_type_script_lang_ts_getOwnPropSymbols(b)) {
      if (AnimationCorevue_type_script_lang_ts_propIsEnum.call(b, prop))
        AnimationCorevue_type_script_lang_ts_defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var AnimationCorevue_type_script_lang_ts_spreadProps = (a, b) => AnimationCorevue_type_script_lang_ts_defProps(a, AnimationCorevue_type_script_lang_ts_getOwnPropDescs(b));












/* harmony default export */ var AnimationCorevue_type_script_lang_ts = ((0,runtime_core_esm_bundler/* defineComponent */.aZ)({
  name: "animation-core",
  components: {
    ChevronUpIcon: ChevronUpIcon,
    ChevronRightIcon: ChevronRightIcon,
    ChevronDownIcon: ChevronDownIcon,
    MinusIcon: MinusIcon,
    TrashIcon: TrashIcon,
    PlusIcon: PlusIcon,
    MagnifyingGlassIcon: MagnifyingGlassIcon,
    XMarkIcon: XMarkIcon,
    EyeIcon: EyeIcon,
    EyeSlashIcon: EyeSlashIcon
  },
  props: {
    nodeIds: {
      type: Array,
      required: true
    },
    panelId: {
      type: String,
      required: true,
      default: null
    },
    init_layout_data: {
      type: Object,
      default() {
        return {};
      }
    }
  },
  setup(props, { emit }) {
    const setupLinkIndex = (0,LinkIndex/* SetupLinkIndex */.US)(props.init_layout_data.linkIndex);
    const canvasElementParent = (0,reactivity_esm_bundler/* ref */.iH)(null);
    const canvasElement = (0,reactivity_esm_bundler/* ref */.iH)(null);
    const css2DElement = (0,reactivity_esm_bundler/* ref */.iH)(null);
    const canvasGPURaycastElement = (0,reactivity_esm_bundler/* ref */.iH)(null);
    const currentTimeBarElement = (0,reactivity_esm_bundler/* ref */.iH)(null);
    const keyframeEditor = StoreController/* StoreController.editor.keyframeEditor */.F.editor.keyframeEditor;
    const nodeIds = (0,runtime_core_esm_bundler/* computed */.Fl)(() => props.nodeIds);
    (0,runtime_core_esm_bundler/* watch */.YP)(
      nodeIds,
      () => {
        for (const nodeId of props.nodeIds) {
          StoreController/* StoreController.engine.updateParams */.F.engine.updateParams(nodeId);
        }
      },
      { deep: true }
    );
    const sceneController = new KeyframeEditorSceneController({
      nodeIds,
      canvasElement,
      css2DElement,
      canvasGPURaycastElement,
      canvasElementParent,
      currentTimeBarElement
      // JSONParamData,
    });
    (0,runtime_core_esm_bundler/* onUnmounted */.Ah)(() => sceneController.dispose());
    const setupEventKey = SetupEventKey({
      sceneController
    });
    const setupEventMouseOptions = {
      eventKeyOptions: AnimationCorevue_type_script_lang_ts_spreadProps(AnimationCorevue_type_script_lang_ts_spreadValues({}, setupEventKey), {
        panelId: props.panelId,
        emit
      }),
      sceneController
    };
    const setupEventMouse = SetupEventMouse(setupEventMouseOptions, setupLinkIndex);
    const setupForm = SetupForm({ sceneController });
    const setupFormInterpolation = SetupFormInterpolation({ sceneController });
    const setupButtons = SetupButtons({ sceneController });
    function _channelColor(colorName, subChannelIndex) {
      const value = KeyframeEditor/* COLOR_VALUES_BY_SUBCHANNEL_INDEX */.gr[subChannelIndex];
      return `bg-${colorName}-${value}`;
    }
    const channelDataItems = (0,runtime_core_esm_bundler/* computed */.Fl)(() => {
      const data = [];
      let nodeIndex = 0;
      for (const nodeId of nodeIds.value) {
        const node = StoreController/* StoreController.engine.node */.F.engine.node(nodeId);
        if (node) {
          data[nodeIndex] = data[nodeIndex] || [];
          const channelsCount = (0,KeyframeEditor/* jsKeyframeChannelsCount */.Z9)(nodeId);
          const dataParams = node.channelDataParams();
          const channelColors = keyframeEditor.channelColorsByNodeId.value[nodeId];
          const channelNames = (0,KeyframeEditor/* subChannelNamesForNodeId */.U1)(nodeId) || [];
          dataParams.forEach((dataParam, channelIndex) => {
            if (channelIndex < channelsCount) {
              const channelColorName = channelColors[channelIndex];
              const subChannelsCount = (0,KeyframeEditor/* jsKeyframeSubChannelsCount */.K_)({ node, channelIndex });
              for (let subChannelIndex = 0; subChannelIndex < subChannelsCount; subChannelIndex++) {
                const color = _channelColor(channelColorName, subChannelIndex);
                const channelName = channelNames[channelIndex][subChannelIndex];
                const displayedState = keyframeEditor.channelDisplayedStateBySubChannelIndexByChannelIndexByNodeId.value[nodeId][channelIndex][subChannelIndex];
                const channelDataItem = {
                  nodeId,
                  nodeIndex,
                  channelIndex,
                  channelName,
                  subChannelIndex,
                  color,
                  displayedState
                };
                data[nodeIndex].push(channelDataItem);
              }
            }
          });
        }
        nodeIndex++;
      }
      return data;
    });
    const channelColorsList = (0,runtime_core_esm_bundler/* computed */.Fl)(() => {
      const data = [];
      for (const nodeId of nodeIds.value) {
        const node = StoreController/* StoreController.engine.node */.F.engine.node(nodeId);
        if (node) {
          const channelColors = keyframeEditor.channelColorsByNodeId.value[nodeId];
          const bgColors = channelColors.map((c) => `bg-${c}-500`);
          data.push(bgColors);
        }
      }
      return data;
    });
    const nodePaths = (0,runtime_core_esm_bundler/* computed */.Fl)(() => {
      const data = [];
      for (const nodeId of nodeIds.value) {
        const node = StoreController/* StoreController.engine.node */.F.engine.node(nodeId);
        if (node) {
          data.push(node.path());
        }
      }
      return data;
    });
    const nodeNames = (0,runtime_core_esm_bundler/* computed */.Fl)(() => {
      const data = [];
      for (const nodeId of nodeIds.value) {
        const node = StoreController/* StoreController.engine.node */.F.engine.node(nodeId);
        if (node) {
          data.push(node.name());
        }
      }
      return data;
    });
    const collapsedStates = (0,runtime_core_esm_bundler/* computed */.Fl)(() => {
      return nodeIds.value.map((nodeId) => keyframeEditor.collapsedNodeIds.value.includes(nodeId));
    });
    const channelDisplayedStateByChannelIndexByNodeId = (0,runtime_core_esm_bundler/* computed */.Fl)(
      () => keyframeEditor.channelDisplayedStateBySubChannelIndexByChannelIndexByNodeId.value
    );
    function toggleNodeCollpasedState(nodeId) {
      keyframeEditor.toggleNodeCollpasedState(nodeId);
    }
    function toggleChannelDisplayState(data) {
      keyframeEditor.toggleChannelDisplayState(AnimationCorevue_type_script_lang_ts_spreadValues({}, data));
    }
    function removeNode(nodeId) {
      keyframeEditor.removeNode(nodeId);
    }
    function moveNodeIdDown(nodeId) {
      keyframeEditor.moveNodeIdDown(nodeId);
    }
    function moveNodeIdUp(nodeId) {
      keyframeEditor.moveNodeIdUp(nodeId);
    }
    function toggleTangentsDisplay() {
      keyframeEditor.tangentsDisplayed.value = !keyframeEditor.tangentsDisplayed.value;
    }
    const tangentsDisplayed = (0,runtime_core_esm_bundler/* computed */.Fl)(() => keyframeEditor.tangentsDisplayed.value);
    return AnimationCorevue_type_script_lang_ts_spreadValues(AnimationCorevue_type_script_lang_ts_spreadValues(AnimationCorevue_type_script_lang_ts_spreadValues(AnimationCorevue_type_script_lang_ts_spreadValues(AnimationCorevue_type_script_lang_ts_spreadValues(AnimationCorevue_type_script_lang_ts_spreadValues({
      canvasElement,
      css2DElement,
      canvasGPURaycastElement,
      canvasElementParent,
      currentTimeBarElement,
      collapsedStates,
      toggleNodeCollpasedState,
      toggleChannelDisplayState,
      moveNodeIdDown,
      moveNodeIdUp,
      removeNode,
      nodeNames,
      nodePaths,
      channelDataItems,
      channelColorsList,
      channelDisplayedStateByChannelIndexByNodeId,
      toggleTangentsDisplay,
      tangentsDisplayed
    }, setupEventMouse), setupEventKey), (0,LayoutData/* SetupLayoutDataCore */.H)({ props, setupLinkIndex })), setupForm), setupFormInterpolation), setupButtons);
  }
}));

;// CONCATENATED MODULE: ../src/editor/components/panels/animation/AnimationCore.vue?vue&type=script&lang=ts
 
// EXTERNAL MODULE: ../node_modules/vue-loader/dist/exportHelper.js
var exportHelper = __webpack_require__(6959);
;// CONCATENATED MODULE: ../src/editor/components/panels/animation/AnimationCore.vue




;


const __exports__ = /*#__PURE__*/(0,exportHelper/* default */.Z)(AnimationCorevue_type_script_lang_ts, [['render',render]])

/* harmony default export */ var AnimationCore = (__exports__);

/***/ })

}])
//# sourceMappingURL=src_editor_components_panels_animation_AnimationCore_vue.0ec410b579cfaa975825.js.map