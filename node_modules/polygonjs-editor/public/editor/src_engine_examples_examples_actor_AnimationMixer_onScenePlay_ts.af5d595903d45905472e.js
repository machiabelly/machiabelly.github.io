(self["webpackChunk"] = self["webpackChunk"] || []).push([["src_engine_examples_examples_actor_AnimationMixer_onScenePlay_ts"],{

/***/ 25075:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "createData": function() { return /* binding */ createData; }
/* harmony export */ });
/* harmony import */ var _polygonjs_polygonjs_src_engine_poly_NodeContext__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(52070);
/* harmony import */ var _polygonjs_polygonjs_src_core_loader_AssetsUtils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(29248);
/* harmony import */ var _polygonjs_polygonjs_src_engine_poly_registers_nodes_types_Sop__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(58986);

var __async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};



function createData(options) {
  const { scene, Editor } = options;
  const root = scene.root();
  const scene_root_nodes = {};
  function create_grid(parentNode) {
    var grid = parentNode.createNode("geo");
    grid.setName("grid");
    const grid_nodes = {};
    function create_planeHelper1(grid2) {
      var planeHelper1 = grid2.createNode("planeHelper");
      planeHelper1.setName("planeHelper1");
      const planeHelper1_nodes = {};
      planeHelper1.uiData.setPosition(0, 0);
      planeHelper1.flags.display.set(true);
      planeHelper1.params.postCreateSpareParams();
      planeHelper1.params.runOnSceneLoadHooks();
      return { node: planeHelper1, children: planeHelper1_nodes };
    }
    grid_nodes["planeHelper1"] = create_planeHelper1(grid);
    if (grid.childrenController) {
      grid.childrenController.selection.set([]);
    }
    grid.uiData.setPosition(-50, -250);
    grid.flags.display.set(true);
    grid.params.postCreateSpareParams();
    grid.params.runOnSceneLoadHooks();
    return { node: grid, children: grid_nodes };
  }
  function create_hemisphereLight1(parentNode) {
    var hemisphereLight1 = parentNode.createNode("hemisphereLight");
    hemisphereLight1.setName("hemisphereLight1");
    const hemisphereLight1_nodes = {};
    hemisphereLight1.uiData.setPosition(150, 100);
    hemisphereLight1.flags.display.set(true);
    hemisphereLight1.params.postCreateSpareParams();
    hemisphereLight1.params.runOnSceneLoadHooks();
    return { node: hemisphereLight1, children: hemisphereLight1_nodes };
  }
  function create_perspectiveCamera1(parentNode) {
    var perspectiveCamera1 = parentNode.createNode("perspectiveCamera");
    perspectiveCamera1.setName("perspectiveCamera1");
    const perspectiveCamera1_nodes = {};
    function create_events1(perspectiveCamera12) {
      var events1 = perspectiveCamera12.createNode("eventsNetwork");
      events1.setName("events1");
      const events1_nodes = {};
      function create_cameraOrbitControls1(events12) {
        var cameraOrbitControls1 = events12.createNode("cameraOrbitControls");
        cameraOrbitControls1.setName("cameraOrbitControls1");
        const cameraOrbitControls1_nodes = {};
        cameraOrbitControls1.uiData.setPosition(150, 50);
        cameraOrbitControls1.p.target.set([-0.8191575541183588, 2.458176293674999, -0.045826244891637544]);
        cameraOrbitControls1.params.postCreateSpareParams();
        cameraOrbitControls1.params.runOnSceneLoadHooks();
        return { node: cameraOrbitControls1, children: cameraOrbitControls1_nodes };
      }
      events1_nodes["cameraOrbitControls1"] = create_cameraOrbitControls1(events1);
      if (events1.childrenController) {
        events1.childrenController.selection.set([]);
      }
      events1.uiData.setPosition(-200, 50);
      events1.params.postCreateSpareParams();
      events1.params.runOnSceneLoadHooks();
      return { node: events1, children: events1_nodes };
    }
    perspectiveCamera1_nodes["events1"] = create_events1(perspectiveCamera1);
    if (perspectiveCamera1.childrenController) {
      perspectiveCamera1.childrenController.selection.set([]);
    }
    perspectiveCamera1.uiData.setPosition(-200, 100);
    perspectiveCamera1.flags.display.set(true);
    perspectiveCamera1.p.t.set([7.606037574850333, 5.003006897245063, 5.236969702574269]);
    perspectiveCamera1.p.r.set([-25.7210811563995, 55.16272324459198, 21.573131321491733]);
    perspectiveCamera1.p.controls.set("./events1/cameraOrbitControls1");
    perspectiveCamera1.params.postCreateSpareParams();
    perspectiveCamera1.params.runOnSceneLoadHooks();
    return { node: perspectiveCamera1, children: perspectiveCamera1_nodes };
  }
  function create_character(parentNode) {
    var character = parentNode.createNode("geo");
    character.setName("character");
    const character_nodes = {};
    function create_actor1(character2) {
      var actor1 = character2.createNode("actor");
      actor1.setName("actor1");
      const actor1_nodes = {};
      function create_animationActionFadeIn1(actor12) {
        var animationActionFadeIn1 = actor12.createNode("animationActionFadeIn");
        animationActionFadeIn1.setName("animationActionFadeIn1");
        const animationActionFadeIn1_nodes = {};
        animationActionFadeIn1.uiData.setComment(
          "This nodes starts the animation from its `AnimationAction` input, which is the one called `Gallop`.\n\nSince its trigger is linked to the [onScenePlayState1](../onScenePlayState1) node, it will start playing the animation as soon as the scene starts."
        );
        animationActionFadeIn1.uiData.setPosition(500, 200);
        animationActionFadeIn1.params.postCreateSpareParams();
        animationActionFadeIn1.params.runOnSceneLoadHooks();
        return { node: animationActionFadeIn1, children: animationActionFadeIn1_nodes };
      }
      function create_animationAction_Gallop_Jump(actor12) {
        var animationAction_Gallop_Jump = actor12.createNode("animationAction");
        animationAction_Gallop_Jump.setName("animationAction_Gallop_Jump");
        const animationAction_Gallop_Jump_nodes = {};
        animationAction_Gallop_Jump.uiData.setComment("This returns the `Gallop` animation");
        animationAction_Gallop_Jump.uiData.setPosition(200, 500);
        animationAction_Gallop_Jump.p.clipName.set("Gallop");
        animationAction_Gallop_Jump.params.postCreateSpareParams();
        animationAction_Gallop_Jump.params.runOnSceneLoadHooks();
        return { node: animationAction_Gallop_Jump, children: animationAction_Gallop_Jump_nodes };
      }
      function create_animationMixer1(actor12) {
        var animationMixer1 = actor12.createNode("animationMixer");
        animationMixer1.setName("animationMixer1");
        const animationMixer1_nodes = {};
        animationMixer1.uiData.setComment(
          "This returns the animationMixer that is handles the animations of the model"
        );
        animationMixer1.uiData.setPosition(-100, 0);
        animationMixer1.params.postCreateSpareParams();
        animationMixer1.params.runOnSceneLoadHooks();
        return { node: animationMixer1, children: animationMixer1_nodes };
      }
      function create_animationMixerUpdate1(actor12) {
        var animationMixerUpdate1 = actor12.createNode("animationMixerUpdate");
        animationMixerUpdate1.setName("animationMixerUpdate1");
        const animationMixerUpdate1_nodes = {};
        animationMixerUpdate1.uiData.setComment(
          "The animation mixer manages the different active clips that are animating the model. Here it updates on every frame, using the onTick node."
        );
        animationMixerUpdate1.uiData.setPosition(350, -200);
        animationMixerUpdate1.params.postCreateSpareParams();
        animationMixerUpdate1.params.runOnSceneLoadHooks();
        return { node: animationMixerUpdate1, children: animationMixerUpdate1_nodes };
      }
      function create_onScenePlayState1(actor12) {
        var onScenePlayState1 = actor12.createNode("onScenePlay");
        onScenePlayState1.setName("onScenePlayState1");
        const onScenePlayState1_nodes = {};
        onScenePlayState1.uiData.setPosition(200, 200);
        onScenePlayState1.params.postCreateSpareParams();
        onScenePlayState1.params.runOnSceneLoadHooks();
        return { node: onScenePlayState1, children: onScenePlayState1_nodes };
      }
      function create_onTick1(actor12) {
        var onTick1 = actor12.createNode("onTick");
        onTick1.setName("onTick1");
        const onTick1_nodes = {};
        onTick1.uiData.setPosition(150, -300);
        onTick1.params.postCreateSpareParams();
        onTick1.params.runOnSceneLoadHooks();
        return { node: onTick1, children: onTick1_nodes };
      }
      actor1_nodes["animationActionFadeIn1"] = create_animationActionFadeIn1(actor1);
      actor1_nodes["animationAction_Gallop_Jump"] = create_animationAction_Gallop_Jump(actor1);
      actor1_nodes["animationMixer1"] = create_animationMixer1(actor1);
      actor1_nodes["animationMixerUpdate1"] = create_animationMixerUpdate1(actor1);
      actor1_nodes["onScenePlayState1"] = create_onScenePlayState1(actor1);
      actor1_nodes["onTick1"] = create_onTick1(actor1);
      actor1_nodes["animationActionFadeIn1"].node.setInput(
        "trigger",
        actor1_nodes["onScenePlayState1"].node,
        "trigger",
        { noExceptionOnInvalidInput: true }
      );
      actor1_nodes["animationActionFadeIn1"].node.setInput(
        "AnimationAction",
        actor1_nodes["animationAction_Gallop_Jump"].node,
        "AnimationAction",
        { noExceptionOnInvalidInput: true }
      );
      actor1_nodes["animationAction_Gallop_Jump"].node.setInput(
        "AnimationMixer",
        actor1_nodes["animationMixer1"].node,
        "AnimationMixer",
        { noExceptionOnInvalidInput: true }
      );
      actor1_nodes["animationMixerUpdate1"].node.setInput("trigger", actor1_nodes["onTick1"].node, "trigger", {
        noExceptionOnInvalidInput: true
      });
      actor1_nodes["animationMixerUpdate1"].node.setInput(
        "AnimationMixer",
        actor1_nodes["animationMixer1"].node,
        "AnimationMixer",
        { noExceptionOnInvalidInput: true }
      );
      if (actor1.childrenController) {
        actor1.childrenController.selection.set([]);
      }
      actor1.uiData.setComment(
        "The animations can be started by the actor node. [Dive inside](.) to see how it is set up."
      );
      actor1.uiData.setPosition(-250, 100);
      actor1.flags.display.set(true);
      actor1.params.postCreateSpareParams();
      actor1.params.runOnSceneLoadHooks();
      return { node: actor1, children: actor1_nodes };
    }
    function create_fileGLTF1(character2) {
      var fileGLTF1 = character2.createNode("fileGLTF");
      fileGLTF1.setName("fileGLTF1");
      const fileGLTF1_nodes = {};
      fileGLTF1.uiData.setComment("This loads an alpaca model, which contains several animations");
      fileGLTF1.uiData.setPosition(-250, -200);
      fileGLTF1.p.url.set(`${_polygonjs_polygonjs_src_core_loader_AssetsUtils__WEBPACK_IMPORTED_MODULE_0__/* .ASSETS_ROOT */ .V}/models/resources/quaternius/animals/Alpaca.gltf`);
      fileGLTF1.p.draco.set(false);
      fileGLTF1.params.postCreateSpareParams();
      fileGLTF1.params.runOnSceneLoadHooks();
      return { node: fileGLTF1, children: fileGLTF1_nodes };
    }
    character_nodes["actor1"] = create_actor1(character);
    character_nodes["fileGLTF1"] = create_fileGLTF1(character);
    character_nodes["actor1"].node.setInput(0, character_nodes["fileGLTF1"].node);
    if (character.childrenController) {
      character.childrenController.selection.set([]);
    }
    character.uiData.setPosition(-50, -150);
    character.flags.display.set(true);
    character.params.postCreateSpareParams();
    character.params.runOnSceneLoadHooks();
    return { node: character, children: character_nodes };
  }
  scene_root_nodes["grid"] = create_grid(root);
  scene_root_nodes["hemisphereLight1"] = create_hemisphereLight1(root);
  scene_root_nodes["perspectiveCamera1"] = create_perspectiveCamera1(root);
  scene_root_nodes["character"] = create_character(root);
  scene.setFrame(0);
  return {
    scene,
    cameraPath: scene_root_nodes["perspectiveCamera1"].node.path(),
    focusedNodes: scene_root_nodes["character"].node.children(),
    autoLayout: false,
    playWhenLoaded: true,
    onAfterLoaded: () => __async(this, null, function* () {
      const fileNodes = scene.nodesByType(_polygonjs_polygonjs_src_engine_poly_registers_nodes_types_Sop__WEBPACK_IMPORTED_MODULE_1__/* .SopTypeFile.FILE_GLTF */ .GF.FILE_GLTF).filter((node) => node.context() == _polygonjs_polygonjs_src_engine_poly_NodeContext__WEBPACK_IMPORTED_MODULE_2__/* .NodeContext.SOP */ .sy.SOP);
      let errored = false;
      for (let fileNode of fileNodes) {
        if (fileNode.states.error.active()) {
          errored = true;
        }
      }
      if (errored) {
        scene.pause();
        yield Editor.instance().requestLibraryInstallationDraco();
        for (let fileNode of fileNodes) {
          fileNode.p.reload.pressButton();
        }
        scene.play();
      }
    })
  };
}


/***/ })

}])
//# sourceMappingURL=src_engine_examples_examples_actor_AnimationMixer_onScenePlay_ts.af5d595903d45905472e.js.map