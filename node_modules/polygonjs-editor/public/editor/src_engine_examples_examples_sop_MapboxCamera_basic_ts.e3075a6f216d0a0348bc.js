(self["webpackChunk"] = self["webpackChunk"] || []).push([["src_engine_examples_examples_sop_MapboxCamera_basic_ts"],{

/***/ 48596:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "createData": function() { return /* binding */ createData; }
/* harmony export */ });

function createData(options) {
  const { scene } = options;
  const root = scene.root();
  const scene_root_nodes = {};
  function create_lights(parentNode) {
    var lights = parentNode.createNode("geo");
    lights.setName("lights");
    const lights_nodes = {};
    function create_areaLight1(lights2) {
      var areaLight1 = lights2.createNode("areaLight");
      areaLight1.setName("areaLight1");
      const areaLight1_nodes = {};
      areaLight1.uiData.setPosition(-100, -650);
      areaLight1.p.intensity.set(2);
      areaLight1.p.width.set(7.8);
      areaLight1.p.height.set(16.5);
      areaLight1.p.showHelper.set(true);
      areaLight1.params.postCreateSpareParams();
      areaLight1.params.runOnSceneLoadHooks();
      return { node: areaLight1, children: areaLight1_nodes };
    }
    function create_hemisphereLight1(lights2) {
      var hemisphereLight1 = lights2.createNode("hemisphereLight");
      hemisphereLight1.setName("hemisphereLight1");
      const hemisphereLight1_nodes = {};
      hemisphereLight1.uiData.setPosition(300, 500);
      hemisphereLight1.p.intensity.set(0.16);
      hemisphereLight1.params.postCreateSpareParams();
      hemisphereLight1.params.runOnSceneLoadHooks();
      return { node: hemisphereLight1, children: hemisphereLight1_nodes };
    }
    function create_hierarchy1(lights2) {
      var hierarchy1 = lights2.createNode("hierarchy");
      hierarchy1.setName("hierarchy1");
      const hierarchy1_nodes = {};
      hierarchy1.uiData.setComment(
        "then, in order to use the same transform technique as the [object](../../geo1), we must add put the light under a parent. We'll then apply the mapboxTransform to this parent."
      );
      hierarchy1.uiData.setPosition(-100, -200);
      hierarchy1.params.postCreateSpareParams();
      hierarchy1.params.runOnSceneLoadHooks();
      return { node: hierarchy1, children: hierarchy1_nodes };
    }
    function create_mapboxTransform1(lights2) {
      var mapboxTransform1 = lights2.createNode("mapboxTransform");
      mapboxTransform1.setName("mapboxTransform1");
      const mapboxTransform1_nodes = {};
      mapboxTransform1.uiData.setComment(
        "And now we use the same mapboxTransform as [the one used on the object](../../geo1/mapboxTransform1)"
      );
      mapboxTransform1.uiData.setPosition(-100, 400);
      mapboxTransform1.p.applyOn.set(1);
      mapboxTransform1.p.longitude.set('ch("../../cameras/mapboxCamera1/longitude")');
      mapboxTransform1.p.latitude.set('ch("../../cameras/mapboxCamera1/latitude")');
      mapboxTransform1.params.postCreateSpareParams();
      mapboxTransform1.params.runOnSceneLoadHooks();
      return { node: mapboxTransform1, children: mapboxTransform1_nodes };
    }
    function create_merge1(lights2) {
      var merge1 = lights2.createNode("merge");
      merge1.setName("merge1");
      const merge1_nodes = {};
      merge1.uiData.setComment(
        "here we simply merge the areaLight with an hemisphereLight, to  add a bit more global lighting"
      );
      merge1.uiData.setPosition(100, 750);
      merge1.flags.display.set(true);
      merge1.params.postCreateSpareParams();
      merge1.params.runOnSceneLoadHooks();
      return { node: merge1, children: merge1_nodes };
    }
    function create_polarTransform1(lights2) {
      var polarTransform1 = lights2.createNode("polarTransform");
      polarTransform1.setName("polarTransform1");
      const polarTransform1_nodes = {};
      polarTransform1.uiData.setComment(
        "the light is first oriented in a normal way, using a polarTransform node"
      );
      polarTransform1.uiData.setPosition(-100, -450);
      polarTransform1.p.center.set([0, 8.9, 0]);
      polarTransform1.p.depth.set(11.7);
      polarTransform1.params.postCreateSpareParams();
      polarTransform1.params.runOnSceneLoadHooks();
      return { node: polarTransform1, children: polarTransform1_nodes };
    }
    function create_transform1(lights2) {
      var transform1 = lights2.createNode("transform");
      transform1.setName("transform1");
      const transform1_nodes = {};
      transform1.uiData.setComment("here we move the light's parent to the desired GPS coordinates");
      transform1.uiData.setPosition(-100, 100);
      transform1.p.applyOn.set(1);
      transform1.p.t.set([-0.08036000000000001, 0, 51.5145]);
      transform1.params.postCreateSpareParams();
      transform1.params.runOnSceneLoadHooks();
      return { node: transform1, children: transform1_nodes };
    }
    lights_nodes["areaLight1"] = create_areaLight1(lights);
    lights_nodes["hemisphereLight1"] = create_hemisphereLight1(lights);
    lights_nodes["hierarchy1"] = create_hierarchy1(lights);
    lights_nodes["mapboxTransform1"] = create_mapboxTransform1(lights);
    lights_nodes["merge1"] = create_merge1(lights);
    lights_nodes["polarTransform1"] = create_polarTransform1(lights);
    lights_nodes["transform1"] = create_transform1(lights);
    lights_nodes["hierarchy1"].node.setInput(0, lights_nodes["polarTransform1"].node);
    lights_nodes["mapboxTransform1"].node.setInput(0, lights_nodes["transform1"].node);
    lights_nodes["merge1"].node.setInput(0, lights_nodes["mapboxTransform1"].node);
    lights_nodes["merge1"].node.setInput(1, lights_nodes["hemisphereLight1"].node);
    lights_nodes["polarTransform1"].node.setInput(0, lights_nodes["areaLight1"].node);
    lights_nodes["transform1"].node.setInput(0, lights_nodes["hierarchy1"].node);
    if (lights.childrenController) {
      lights.childrenController.selection.set([]);
    }
    lights.uiData.setComment(
      "[Dive into this node](.) to see how the lights are setup, although it is recommended to first have a look at [how the object is placed on the map](../geo1)."
    );
    lights.uiData.setPosition(-50, 150);
    lights.flags.display.set(true);
    lights.params.postCreateSpareParams();
    lights.params.runOnSceneLoadHooks();
    return { node: lights, children: lights_nodes };
  }
  function create_cameras(parentNode) {
    var cameras = parentNode.createNode("geo");
    cameras.setName("cameras");
    const cameras_nodes = {};
    function create_cameraControls1(cameras2) {
      var cameraControls1 = cameras2.createNode("cameraControls");
      cameraControls1.setName("cameraControls1");
      const cameraControls1_nodes = {};
      function create_cameraOrbitControls1(cameraControls12) {
        var cameraOrbitControls1 = cameraControls12.createNode("cameraOrbitControls");
        cameraOrbitControls1.setName("cameraOrbitControls1");
        const cameraOrbitControls1_nodes = {};
        cameraOrbitControls1.uiData.setPosition(0, 0);
        cameraOrbitControls1.p.target.set([0, 0.75, 0]);
        cameraOrbitControls1.params.postCreateSpareParams();
        cameraOrbitControls1.params.runOnSceneLoadHooks();
        return { node: cameraOrbitControls1, children: cameraOrbitControls1_nodes };
      }
      cameraControls1_nodes["cameraOrbitControls1"] = create_cameraOrbitControls1(cameraControls1);
      if (cameraControls1.childrenController) {
        cameraControls1.childrenController.selection.set([]);
      }
      cameraControls1.uiData.setPosition(0, 150);
      cameraControls1.p.node.set("cameraOrbitControls1");
      cameraControls1.params.postCreateSpareParams();
      cameraControls1.params.runOnSceneLoadHooks();
      return { node: cameraControls1, children: cameraControls1_nodes };
    }
    function create_mapboxCamera1(cameras2) {
      var mapboxCamera1 = cameras2.createNode("mapboxCamera");
      mapboxCamera1.setName("mapboxCamera1");
      const mapboxCamera1_nodes = {};
      mapboxCamera1.uiData.setComment(
        "This node defines mapbox camera properties, such as its start locations (in longitude and latitude) and zoom range. You can also change the style used for the map.\n\nMake sure to try the presets, visible from the parameters panel."
      );
      mapboxCamera1.uiData.setPosition(300, -50);
      mapboxCamera1.p.longitude.set(-0.08058006477935464);
      mapboxCamera1.p.latitude.set(51.51460202649244);
      mapboxCamera1.p.pitch.set(69.25845617731541);
      mapboxCamera1.p.bearing.set(-54.027610122504825);
      mapboxCamera1.p.zoom.set(18.018690566994973);
      mapboxCamera1.params.postCreateSpareParams();
      mapboxCamera1.params.runOnSceneLoadHooks();
      return { node: mapboxCamera1, children: mapboxCamera1_nodes };
    }
    function create_merge1(cameras2) {
      var merge1 = cameras2.createNode("merge");
      merge1.setName("merge1");
      const merge1_nodes = {};
      merge1.uiData.setPosition(150, 350);
      merge1.flags.display.set(true);
      merge1.params.postCreateSpareParams();
      merge1.params.runOnSceneLoadHooks();
      return { node: merge1, children: merge1_nodes };
    }
    function create_perspectiveCamera1(cameras2) {
      var perspectiveCamera1 = cameras2.createNode("perspectiveCamera");
      perspectiveCamera1.setName("perspectiveCamera1");
      const perspectiveCamera1_nodes = {};
      perspectiveCamera1.uiData.setPosition(0, -50);
      perspectiveCamera1.p.position.set([3.3, 3.3, 3.3]);
      perspectiveCamera1.params.postCreateSpareParams();
      perspectiveCamera1.params.runOnSceneLoadHooks();
      return { node: perspectiveCamera1, children: perspectiveCamera1_nodes };
    }
    cameras_nodes["cameraControls1"] = create_cameraControls1(cameras);
    cameras_nodes["mapboxCamera1"] = create_mapboxCamera1(cameras);
    cameras_nodes["merge1"] = create_merge1(cameras);
    cameras_nodes["perspectiveCamera1"] = create_perspectiveCamera1(cameras);
    cameras_nodes["cameraControls1"].node.setInput(0, cameras_nodes["perspectiveCamera1"].node);
    cameras_nodes["merge1"].node.setInput(0, cameras_nodes["cameraControls1"].node);
    cameras_nodes["merge1"].node.setInput(1, cameras_nodes["mapboxCamera1"].node);
    if (cameras.childrenController) {
      cameras.childrenController.selection.set([]);
    }
    cameras.uiData.setComment("[Dive into this node](.) to see how the camera is setup.");
    cameras.uiData.setPosition(-50, -200);
    cameras.flags.display.set(true);
    cameras.params.postCreateSpareParams();
    cameras.params.runOnSceneLoadHooks();
    return { node: cameras, children: cameras_nodes };
  }
  function create_geo1(parentNode) {
    var geo1 = parentNode.createNode("geo");
    geo1.setName("geo1");
    const geo1_nodes = {};
    function create_MAT(geo12) {
      var MAT = geo12.createNode("materialsNetwork");
      MAT.setName("MAT");
      const MAT_nodes = {};
      function create_meshStandard1(MAT2) {
        var meshStandard1 = MAT2.createNode("meshStandard");
        meshStandard1.setName("meshStandard1");
        const meshStandard1_nodes = {};
        meshStandard1.uiData.setPosition(0, 0);
        meshStandard1.params.postCreateSpareParams();
        meshStandard1.params.runOnSceneLoadHooks();
        return { node: meshStandard1, children: meshStandard1_nodes };
      }
      MAT_nodes["meshStandard1"] = create_meshStandard1(MAT);
      if (MAT.childrenController) {
        MAT.childrenController.selection.set([]);
      }
      MAT.uiData.setPosition(-350, 200);
      MAT.params.postCreateSpareParams();
      MAT.params.runOnSceneLoadHooks();
      return { node: MAT, children: MAT_nodes };
    }
    function create_fileGLTF1(geo12) {
      var fileGLTF1 = geo12.createNode("fileGLTF");
      fileGLTF1.setName("fileGLTF1");
      const fileGLTF1_nodes = {};
      fileGLTF1.uiData.setComment("here we simply import an object");
      fileGLTF1.uiData.setPosition(-100, -300);
      fileGLTF1.p.url.set(
        "https://raw.githubusercontent.com/polygonjs/polygonjs-assets/master/models/resources/threedscans.com/rhino.glb"
      );
      fileGLTF1.params.postCreateSpareParams();
      fileGLTF1.params.runOnSceneLoadHooks();
      return { node: fileGLTF1, children: fileGLTF1_nodes };
    }
    function create_mapboxTransform1(geo12) {
      var mapboxTransform1 = geo12.createNode("mapboxTransform");
      mapboxTransform1.setName("mapboxTransform1");
      const mapboxTransform1_nodes = {};
      mapboxTransform1.uiData.setComment(
        "When adding 3D object to mapbox, it is required to place them within the *mapbox space*, which is a little different than the typical 3D space.\n\nFor this, we then use this mapbox transform node. And we also need to link the *longitude* and *latitude* to the ones of the camera node. In this case, we do using using the [ch expression](/docs/expressions/ch)"
      );
      mapboxTransform1.uiData.setPosition(-100, 450);
      mapboxTransform1.flags.display.set(true);
      mapboxTransform1.p.applyOn.set(1);
      mapboxTransform1.p.longitude.set('ch("../../cameras/mapboxCamera1/longitude")');
      mapboxTransform1.p.latitude.set('ch("../../cameras/mapboxCamera1/latitude")');
      mapboxTransform1.params.postCreateSpareParams();
      mapboxTransform1.params.runOnSceneLoadHooks();
      return { node: mapboxTransform1, children: mapboxTransform1_nodes };
    }
    function create_material1(geo12) {
      var material1 = geo12.createNode("material");
      material1.setName("material1");
      const material1_nodes = {};
      material1.uiData.setComment("this assigns a material");
      material1.uiData.setPosition(-100, 200);
      material1.p.material.set("../MAT/meshStandard1");
      material1.params.postCreateSpareParams();
      material1.params.runOnSceneLoadHooks();
      return { node: material1, children: material1_nodes };
    }
    function create_transform2(geo12) {
      var transform2 = geo12.createNode("transform");
      transform2.setName("transform2");
      const transform2_nodes = {};
      transform2.uiData.setComment(
        "here we are defining the **longitude** and **latitude** of the object, as well as its scale."
      );
      transform2.uiData.setPosition(-100, -50);
      transform2.p.applyOn.set(1);
      transform2.p.t.set([-0.08036000000000001, 0, 51.5145]);
      transform2.p.scale.set(22);
      transform2.params.postCreateSpareParams();
      transform2.params.runOnSceneLoadHooks();
      return { node: transform2, children: transform2_nodes };
    }
    geo1_nodes["MAT"] = create_MAT(geo1);
    geo1_nodes["fileGLTF1"] = create_fileGLTF1(geo1);
    geo1_nodes["mapboxTransform1"] = create_mapboxTransform1(geo1);
    geo1_nodes["material1"] = create_material1(geo1);
    geo1_nodes["transform2"] = create_transform2(geo1);
    geo1_nodes["mapboxTransform1"].node.setInput(0, geo1_nodes["material1"].node);
    geo1_nodes["material1"].node.setInput(0, geo1_nodes["transform2"].node);
    geo1_nodes["transform2"].node.setInput(0, geo1_nodes["fileGLTF1"].node);
    if (geo1.childrenController) {
      geo1.childrenController.selection.set([]);
    }
    geo1.uiData.setComment(
      "[Dive into this node](.) to see how the model is imported and placed in the environment"
    );
    geo1.uiData.setPosition(-50, -50);
    geo1.flags.display.set(true);
    geo1.params.postCreateSpareParams();
    geo1.params.runOnSceneLoadHooks();
    return { node: geo1, children: geo1_nodes };
  }
  scene_root_nodes["lights"] = create_lights(root);
  scene_root_nodes["cameras"] = create_cameras(root);
  scene_root_nodes["geo1"] = create_geo1(root);
  return {
    scene,
    cameraPath: "/cameras/cameras:sopGroup/mapboxCamera1",
    focusedNodes: Object.values(scene_root_nodes["cameras"].children).map((n) => n.node),
    autoLayout: false
  };
}


/***/ })

}])
//# sourceMappingURL=src_engine_examples_examples_sop_MapboxCamera_basic_ts.e3075a6f216d0a0348bc.js.map