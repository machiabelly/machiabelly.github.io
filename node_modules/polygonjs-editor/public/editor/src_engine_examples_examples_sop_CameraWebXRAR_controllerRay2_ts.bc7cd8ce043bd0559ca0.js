(self["webpackChunk"] = self["webpackChunk"] || []).push([["src_engine_examples_examples_sop_CameraWebXRAR_controllerRay2_ts"],{

/***/ 25362:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "createData": function() { return /* binding */ createData; }
/* harmony export */ });
/* harmony import */ var _polygonjs_polygonjs_src_engine_poly_ParamType__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(51254);


function createData(options) {
  const { scene } = options;
  const root = scene.root();
  const scene_root_nodes = {};
  function create_geo1(parentNode) {
    var geo1 = parentNode.createNode("geo");
    geo1.setName("geo1");
    const geo1_nodes = {};
    function create_MAT(geo12) {
      var MAT = geo12.createNode("materialsNetwork");
      MAT.setName("MAT");
      const MAT_nodes = {};
      function create_COP(MAT2) {
        var COP = MAT2.createNode("copNetwork");
        COP.setName("COP");
        const COP_nodes = {};
        function create_envMap1(COP2) {
          var envMap1 = COP2.createNode("envMap");
          envMap1.setName("envMap1");
          const envMap1_nodes = {};
          envMap1.uiData.setPosition(-150, 150);
          envMap1.params.postCreateSpareParams();
          envMap1.params.runOnSceneLoadHooks();
          return { node: envMap1, children: envMap1_nodes };
        }
        function create_imageEXR1(COP2) {
          var imageEXR1 = COP2.createNode("imageEXR");
          imageEXR1.setName("imageEXR1");
          const imageEXR1_nodes = {};
          imageEXR1.uiData.setPosition(-150, 0);
          imageEXR1.p.url.set(
            "https://raw.githubusercontent.com/polygonjs/polygonjs-assets/master/textures/resources/polyhaven.com/envmaps/photo_studio_loft_hall_1k.exr"
          );
          imageEXR1.params.postCreateSpareParams();
          imageEXR1.params.runOnSceneLoadHooks();
          return { node: imageEXR1, children: imageEXR1_nodes };
        }
        COP_nodes["envMap1"] = create_envMap1(COP);
        COP_nodes["imageEXR1"] = create_imageEXR1(COP);
        COP_nodes["envMap1"].node.setInput(0, COP_nodes["imageEXR1"].node);
        if (COP.childrenController) {
          COP.childrenController.selection.set([]);
        }
        COP.uiData.setPosition(0, 250);
        COP.params.postCreateSpareParams();
        COP.params.runOnSceneLoadHooks();
        return { node: COP, children: COP_nodes };
      }
      function create_meshStandard1(MAT2) {
        var meshStandard1 = MAT2.createNode("meshStandard");
        meshStandard1.setName("meshStandard1");
        const meshStandard1_nodes = {};
        meshStandard1.uiData.setPosition(0, -50);
        meshStandard1.p.useEnvMap.set(true);
        meshStandard1.p.envMap.set("../COP/envMap1");
        meshStandard1.p.metalness.set(1);
        meshStandard1.p.roughness.set(0.26);
        meshStandard1.params.postCreateSpareParams();
        meshStandard1.params.runOnSceneLoadHooks();
        return { node: meshStandard1, children: meshStandard1_nodes };
      }
      MAT_nodes["COP"] = create_COP(MAT);
      MAT_nodes["meshStandard1"] = create_meshStandard1(MAT);
      if (MAT.childrenController) {
        MAT.childrenController.selection.set([MAT_nodes["meshStandard1"].node]);
      }
      MAT.uiData.setPosition(-400, 400);
      MAT.params.postCreateSpareParams();
      MAT.params.runOnSceneLoadHooks();
      return { node: MAT, children: MAT_nodes };
    }
    function create_actor1(geo12) {
      var actor1 = geo12.createNode("actor");
      actor1.setName("actor1");
      const actor1_nodes = {};
      function create_constant1(actor12) {
        var constant1 = actor12.createNode("constant");
        constant1.setName("constant1");
        const constant1_nodes = {};
        constant1.uiData.setPosition(150, 100);
        constant1.p.type.set(1);
        constant1.p.color.set([0.3254901960784314, 0.03529411764705882, 0.8627450980392157]);
        constant1.params.postCreateSpareParams();
        constant1.params.runOnSceneLoadHooks();
        return { node: constant1, children: constant1_nodes };
      }
      function create_constant2(actor12) {
        var constant2 = actor12.createNode("constant");
        constant2.setName("constant2");
        const constant2_nodes = {};
        constant2.uiData.setPosition(150, 250);
        constant2.p.type.set(1);
        constant2.p.color.set([0.4588235294117647, 0.4588235294117647, 0.4588235294117647]);
        constant2.params.postCreateSpareParams();
        constant2.params.runOnSceneLoadHooks();
        return { node: constant2, children: constant2_nodes };
      }
      function create_getWebXRControllerProperty1(actor12) {
        var getWebXRControllerProperty1 = actor12.createNode("getWebXRControllerProperty");
        getWebXRControllerProperty1.setName("getWebXRControllerProperty1");
        const getWebXRControllerProperty1_nodes = {};
        getWebXRControllerProperty1.uiData.setComment(
          "This node gives us properties of the webXR controller. It can be used both for VR and AR.\n\nIn this case, we use it to get the ray from the controller. We can then use it to see if it intersects objects and react based on this."
        );
        getWebXRControllerProperty1.uiData.setPosition(-300, -200);
        getWebXRControllerProperty1.params.postCreateSpareParams();
        getWebXRControllerProperty1.params.runOnSceneLoadHooks();
        return { node: getWebXRControllerProperty1, children: getWebXRControllerProperty1_nodes };
      }
      function create_onTick1(actor12) {
        var onTick1 = actor12.createNode("onTick");
        onTick1.setName("onTick1");
        const onTick1_nodes = {};
        onTick1.uiData.setPosition(350, -300);
        onTick1.params.postCreateSpareParams();
        onTick1.params.runOnSceneLoadHooks();
        return { node: onTick1, children: onTick1_nodes };
      }
      function create_rayFromCursor1(actor12) {
        var rayFromCursor1 = actor12.createNode("rayFromCursor");
        rayFromCursor1.setName("rayFromCursor1");
        const rayFromCursor1_nodes = {};
        rayFromCursor1.uiData.setComment(
          "When testing your app on desktop, the [getWebXRControllerProperty1](../getWebXRControllerProperty1) will not do anything. You would then need to replace it with this node to get the ray under the cursor."
        );
        rayFromCursor1.uiData.setPosition(-300, 150);
        rayFromCursor1.params.postCreateSpareParams();
        rayFromCursor1.params.runOnSceneLoadHooks();
        return { node: rayFromCursor1, children: rayFromCursor1_nodes };
      }
      function create_rayIntersectsObject1(actor12) {
        var rayIntersectsObject1 = actor12.createNode("rayIntersectsObject");
        rayIntersectsObject1.setName("rayIntersectsObject1");
        const rayIntersectsObject1_nodes = {};
        rayIntersectsObject1.uiData.setComment(
          "This tells us if the ray from the controller intersects with the current object. Its output is a boolean value that is used in the `twowaySwitch` nodes."
        );
        rayIntersectsObject1.uiData.setPosition(100, -200);
        rayIntersectsObject1.params.postCreateSpareParams();
        rayIntersectsObject1.params.runOnSceneLoadHooks();
        return { node: rayIntersectsObject1, children: rayIntersectsObject1_nodes };
      }
      function create_setMaterialColor1(actor12) {
        var setMaterialColor1 = actor12.createNode("setMaterialColor");
        setMaterialColor1.setName("setMaterialColor1");
        const setMaterialColor1_nodes = {};
        setMaterialColor1.uiData.setComment(
          "This changes the color of the material based on its input, the [twoWaySwitch1](../twoWaySwitch1), which will give it a different color depending if the ray from the controller intersects with the current object or not.\n\nYou can see the `lerp` value is also given via another [twoWaySwitch](../twoWaySwitch2). The lerp value will then be close to 1 when the ray intersects, and lower and it does not. This means that the color will change rapidly when we intersect, and more slowly when we do not."
        );
        setMaterialColor1.uiData.setPosition(750, -150);
        setMaterialColor1.p.lerp.set(0.19);
        setMaterialColor1.params.postCreateSpareParams();
        setMaterialColor1.params.runOnSceneLoadHooks();
        return { node: setMaterialColor1, children: setMaterialColor1_nodes };
      }
      function create_setObjectScale1(actor12) {
        var setObjectScale1 = actor12.createNode("setObjectScale");
        setObjectScale1.setName("setObjectScale1");
        const setObjectScale1_nodes = {};
        setObjectScale1.uiData.setComment(
          "On top of changing the color, we also change the scale of the object, with a similar logic. When the controller ray intersects with the object, the scale will change to a small value, and back to 1 when it not intersection is found."
        );
        setObjectScale1.uiData.setPosition(750, 300);
        setObjectScale1.params.postCreateSpareParams();
        setObjectScale1.params.runOnSceneLoadHooks();
        return { node: setObjectScale1, children: setObjectScale1_nodes };
      }
      function create_twoWaySwitch1(actor12) {
        var twoWaySwitch1 = actor12.createNode("twoWaySwitch");
        twoWaySwitch1.setName("twoWaySwitch1");
        const twoWaySwitch1_nodes = {};
        twoWaySwitch1.uiData.setPosition(400, 0);
        twoWaySwitch1.addParam(_polygonjs_polygonjs_src_engine_poly_ParamType__WEBPACK_IMPORTED_MODULE_0__/* .ParamType.BOOLEAN */ ._.BOOLEAN, "condition", false, { spare: true, editable: false });
        twoWaySwitch1.addParam(_polygonjs_polygonjs_src_engine_poly_ParamType__WEBPACK_IMPORTED_MODULE_0__/* .ParamType.COLOR */ ._.COLOR, "ifTrue", [0, 0, 0], { spare: true, editable: false });
        twoWaySwitch1.addParam(_polygonjs_polygonjs_src_engine_poly_ParamType__WEBPACK_IMPORTED_MODULE_0__/* .ParamType.COLOR */ ._.COLOR, "ifFalse", [0, 0, 0], { spare: true, editable: false });
        twoWaySwitch1.params.postCreateSpareParams();
        twoWaySwitch1.params.runOnSceneLoadHooks();
        return { node: twoWaySwitch1, children: twoWaySwitch1_nodes };
      }
      function create_twoWaySwitch2(actor12) {
        var twoWaySwitch2 = actor12.createNode("twoWaySwitch");
        twoWaySwitch2.setName("twoWaySwitch2");
        const twoWaySwitch2_nodes = {};
        twoWaySwitch2.uiData.setPosition(450, 200);
        twoWaySwitch2.addParam(_polygonjs_polygonjs_src_engine_poly_ParamType__WEBPACK_IMPORTED_MODULE_0__/* .ParamType.BOOLEAN */ ._.BOOLEAN, "condition", false, { spare: true, editable: false });
        twoWaySwitch2.addParam(_polygonjs_polygonjs_src_engine_poly_ParamType__WEBPACK_IMPORTED_MODULE_0__/* .ParamType.FLOAT */ ._.FLOAT, "ifTrue", 0, { spare: true, editable: true });
        twoWaySwitch2.params.get("ifTrue").set(0.98);
        twoWaySwitch2.addParam(_polygonjs_polygonjs_src_engine_poly_ParamType__WEBPACK_IMPORTED_MODULE_0__/* .ParamType.FLOAT */ ._.FLOAT, "ifFalse", 0, { spare: true, editable: true });
        twoWaySwitch2.params.get("ifFalse").set(0.06);
        twoWaySwitch2.params.postCreateSpareParams();
        twoWaySwitch2.params.runOnSceneLoadHooks();
        return { node: twoWaySwitch2, children: twoWaySwitch2_nodes };
      }
      function create_twoWaySwitch3(actor12) {
        var twoWaySwitch3 = actor12.createNode("twoWaySwitch");
        twoWaySwitch3.setName("twoWaySwitch3");
        const twoWaySwitch3_nodes = {};
        twoWaySwitch3.uiData.setPosition(400, 450);
        twoWaySwitch3.addParam(_polygonjs_polygonjs_src_engine_poly_ParamType__WEBPACK_IMPORTED_MODULE_0__/* .ParamType.BOOLEAN */ ._.BOOLEAN, "condition", false, { spare: true, editable: false });
        twoWaySwitch3.addParam(_polygonjs_polygonjs_src_engine_poly_ParamType__WEBPACK_IMPORTED_MODULE_0__/* .ParamType.FLOAT */ ._.FLOAT, "ifTrue", 0, { spare: true, editable: true });
        twoWaySwitch3.params.get("ifTrue").set(0.17);
        twoWaySwitch3.addParam(_polygonjs_polygonjs_src_engine_poly_ParamType__WEBPACK_IMPORTED_MODULE_0__/* .ParamType.FLOAT */ ._.FLOAT, "ifFalse", 0, { spare: true, editable: true });
        twoWaySwitch3.params.get("ifFalse").set(1);
        twoWaySwitch3.params.postCreateSpareParams();
        twoWaySwitch3.params.runOnSceneLoadHooks();
        return { node: twoWaySwitch3, children: twoWaySwitch3_nodes };
      }
      actor1_nodes["constant1"] = create_constant1(actor1);
      actor1_nodes["constant2"] = create_constant2(actor1);
      actor1_nodes["getWebXRControllerProperty1"] = create_getWebXRControllerProperty1(actor1);
      actor1_nodes["onTick1"] = create_onTick1(actor1);
      actor1_nodes["rayFromCursor1"] = create_rayFromCursor1(actor1);
      actor1_nodes["rayIntersectsObject1"] = create_rayIntersectsObject1(actor1);
      actor1_nodes["setMaterialColor1"] = create_setMaterialColor1(actor1);
      actor1_nodes["setObjectScale1"] = create_setObjectScale1(actor1);
      actor1_nodes["twoWaySwitch1"] = create_twoWaySwitch1(actor1);
      actor1_nodes["twoWaySwitch2"] = create_twoWaySwitch2(actor1);
      actor1_nodes["twoWaySwitch3"] = create_twoWaySwitch3(actor1);
      actor1_nodes["rayIntersectsObject1"].node.setInput(
        "Ray",
        actor1_nodes["getWebXRControllerProperty1"].node,
        "Ray"
      );
      actor1_nodes["setMaterialColor1"].node.setInput("trigger", actor1_nodes["onTick1"].node, "trigger");
      actor1_nodes["setMaterialColor1"].node.setInput("color", actor1_nodes["twoWaySwitch1"].node, "val");
      actor1_nodes["setMaterialColor1"].node.setInput("lerp", actor1_nodes["twoWaySwitch2"].node, "val");
      actor1_nodes["setObjectScale1"].node.setInput("trigger", actor1_nodes["onTick1"].node, "trigger");
      actor1_nodes["setObjectScale1"].node.setInput("mult", actor1_nodes["twoWaySwitch3"].node, "val");
      actor1_nodes["setObjectScale1"].node.setInput("lerp", actor1_nodes["twoWaySwitch2"].node, "val");
      actor1_nodes["twoWaySwitch1"].node.setInput(
        "condition",
        actor1_nodes["rayIntersectsObject1"].node,
        "intersects"
      );
      actor1_nodes["twoWaySwitch1"].node.setInput("ifTrue", actor1_nodes["constant1"].node, "val");
      actor1_nodes["twoWaySwitch1"].node.setInput("ifFalse", actor1_nodes["constant2"].node, "val");
      actor1_nodes["twoWaySwitch2"].node.setInput(
        "condition",
        actor1_nodes["rayIntersectsObject1"].node,
        "intersects"
      );
      actor1_nodes["twoWaySwitch3"].node.setInput(
        "condition",
        actor1_nodes["rayIntersectsObject1"].node,
        "intersects"
      );
      if (actor1.childrenController) {
        actor1.childrenController.selection.set([]);
      }
      actor1.uiData.setComment(
        "Inside this node, we add behaviors to each object. [Dive into it](./getWebXRControllerProperty1) to see how it is setup."
      );
      actor1.uiData.setPosition(-100, 1200);
      actor1.flags.display.set(true);
      actor1.params.postCreateSpareParams();
      actor1.params.runOnSceneLoadHooks();
      return { node: actor1, children: actor1_nodes };
    }
    function create_copy1(geo12) {
      var copy1 = geo12.createNode("copy");
      copy1.setName("copy1");
      const copy1_nodes = {};
      copy1.uiData.setComment(
        "the `copy` node copies the 1st input (the `roundedBox`) on each point of the 2nd input (the plane). By adjusting the plane resolution, we can adjust how many boxes this will create. "
      );
      copy1.uiData.setPosition(-100, 100);
      copy1.params.postCreateSpareParams();
      copy1.params.runOnSceneLoadHooks();
      return { node: copy1, children: copy1_nodes };
    }
    function create_material1(geo12) {
      var material1 = geo12.createNode("material");
      material1.setName("material1");
      const material1_nodes = {};
      material1.uiData.setComment(
        "This assigns a shiny material to each box.\n\nNote that `cloneMat` is set to `true`, as we need each box to have a unique material so that we can change their colors individually. "
      );
      material1.uiData.setPosition(-100, 400);
      material1.p.material.set("../MAT/meshStandard1");
      material1.p.cloneMat.set(true);
      material1.params.postCreateSpareParams();
      material1.params.runOnSceneLoadHooks();
      return { node: material1, children: material1_nodes };
    }
    function create_plane1(geo12) {
      var plane1 = geo12.createNode("plane");
      plane1.setName("plane1");
      const plane1_nodes = {};
      plane1.uiData.setPosition(0, -150);
      plane1.p.size.set([1.8, 1.4]);
      plane1.p.stepSize.set(0.2);
      plane1.p.direction.set([0, 0, 1]);
      plane1.params.postCreateSpareParams();
      plane1.params.runOnSceneLoadHooks();
      return { node: plane1, children: plane1_nodes };
    }
    function create_roundedBox1(geo12) {
      var roundedBox1 = geo12.createNode("roundedBox");
      roundedBox1.setName("roundedBox1");
      const roundedBox1_nodes = {};
      roundedBox1.uiData.setPosition(-200, -150);
      roundedBox1.p.size.set(0.2);
      roundedBox1.p.bevel.set(0.03);
      roundedBox1.params.postCreateSpareParams();
      roundedBox1.params.runOnSceneLoadHooks();
      return { node: roundedBox1, children: roundedBox1_nodes };
    }
    function create_transform2(geo12) {
      var transform2 = geo12.createNode("transform");
      transform2.setName("transform2");
      const transform2_nodes = {};
      transform2.uiData.setComment(
        "This moves the boxes down the `-Z` axis, as this is the direction the camera faces when starting an AR session.\n\nNote that following parameters:\n- `applyOn` set to `object`, so we modify the object matrix, and not the geometry points\n- `objectMode` set to `multiply matrix` so we do not override any pre-existing matrix values, such as the one set by the `copy` node."
      );
      transform2.uiData.setPosition(-100, 700);
      transform2.p.applyOn.set(1);
      transform2.p.objectMode.set(1);
      transform2.p.t.set([0, 0, -2.5]);
      transform2.params.postCreateSpareParams();
      transform2.params.runOnSceneLoadHooks();
      return { node: transform2, children: transform2_nodes };
    }
    geo1_nodes["MAT"] = create_MAT(geo1);
    geo1_nodes["actor1"] = create_actor1(geo1);
    geo1_nodes["copy1"] = create_copy1(geo1);
    geo1_nodes["material1"] = create_material1(geo1);
    geo1_nodes["plane1"] = create_plane1(geo1);
    geo1_nodes["roundedBox1"] = create_roundedBox1(geo1);
    geo1_nodes["transform2"] = create_transform2(geo1);
    geo1_nodes["actor1"].node.setInput(0, geo1_nodes["transform2"].node);
    geo1_nodes["copy1"].node.setInput(0, geo1_nodes["roundedBox1"].node);
    geo1_nodes["copy1"].node.setInput(1, geo1_nodes["plane1"].node);
    geo1_nodes["material1"].node.setInput(0, geo1_nodes["copy1"].node);
    geo1_nodes["transform2"].node.setInput(0, geo1_nodes["material1"].node);
    if (geo1.childrenController) {
      geo1.childrenController.selection.set([]);
    }
    geo1.uiData.setPosition(-50, -150);
    geo1.flags.display.set(true);
    geo1.params.postCreateSpareParams();
    geo1.params.runOnSceneLoadHooks();
    return { node: geo1, children: geo1_nodes };
  }
  function create_grid(parentNode) {
    var grid = parentNode.createNode("geo");
    grid.setName("grid");
    const grid_nodes = {};
    function create_planeHelper1(grid2) {
      var planeHelper1 = grid2.createNode("planeHelper");
      planeHelper1.setName("planeHelper1");
      const planeHelper1_nodes = {};
      planeHelper1.uiData.setPosition(0, 0);
      planeHelper1.flags.display.set(true);
      planeHelper1.params.postCreateSpareParams();
      planeHelper1.params.runOnSceneLoadHooks();
      return { node: planeHelper1, children: planeHelper1_nodes };
    }
    grid_nodes["planeHelper1"] = create_planeHelper1(grid);
    if (grid.childrenController) {
      grid.childrenController.selection.set([]);
    }
    grid.uiData.setPosition(-50, -250);
    grid.flags.display.set(false);
    grid.params.postCreateSpareParams();
    grid.params.runOnSceneLoadHooks();
    return { node: grid, children: grid_nodes };
  }
  function create_cameras(parentNode) {
    var cameras = parentNode.createNode("geo");
    cameras.setName("cameras");
    const cameras_nodes = {};
    function create_cameraControls1(cameras2) {
      var cameraControls1 = cameras2.createNode("cameraControls");
      cameraControls1.setName("cameraControls1");
      const cameraControls1_nodes = {};
      function create_cameraOrbitControls1(cameraControls12) {
        var cameraOrbitControls1 = cameraControls12.createNode("cameraOrbitControls");
        cameraOrbitControls1.setName("cameraOrbitControls1");
        const cameraOrbitControls1_nodes = {};
        cameraOrbitControls1.uiData.setPosition(0, 0);
        cameraOrbitControls1.p.target.set([-0.03424406872017879, 0.2757555812056797, -0.10575574355459814]);
        cameraOrbitControls1.params.postCreateSpareParams();
        cameraOrbitControls1.params.runOnSceneLoadHooks();
        return { node: cameraOrbitControls1, children: cameraOrbitControls1_nodes };
      }
      cameraControls1_nodes["cameraOrbitControls1"] = create_cameraOrbitControls1(cameraControls1);
      if (cameraControls1.childrenController) {
        cameraControls1.childrenController.selection.set([cameraControls1_nodes["cameraOrbitControls1"].node]);
      }
      cameraControls1.uiData.setPosition(-350, 250);
      cameraControls1.p.node.set("cameraOrbitControls1");
      cameraControls1.params.postCreateSpareParams();
      cameraControls1.params.runOnSceneLoadHooks();
      return { node: cameraControls1, children: cameraControls1_nodes };
    }
    function create_cameraWebXRAR1(cameras2) {
      var cameraWebXRAR1 = cameras2.createNode("cameraWebXRAR");
      cameraWebXRAR1.setName("cameraWebXRAR1");
      const cameraWebXRAR1_nodes = {};
      cameraWebXRAR1.uiData.setPosition(50, 250);
      cameraWebXRAR1.params.postCreateSpareParams();
      cameraWebXRAR1.params.runOnSceneLoadHooks();
      return { node: cameraWebXRAR1, children: cameraWebXRAR1_nodes };
    }
    function create_merge1(cameras2) {
      var merge1 = cameras2.createNode("merge");
      merge1.setName("merge1");
      const merge1_nodes = {};
      merge1.uiData.setPosition(-150, 450);
      merge1.flags.display.set(true);
      merge1.params.postCreateSpareParams();
      merge1.params.runOnSceneLoadHooks();
      return { node: merge1, children: merge1_nodes };
    }
    function create_perspectiveCamera_AR(cameras2) {
      var perspectiveCamera_AR = cameras2.createNode("perspectiveCamera");
      perspectiveCamera_AR.setName("perspectiveCamera_AR");
      const perspectiveCamera_AR_nodes = {};
      perspectiveCamera_AR.uiData.setPosition(50, 100);
      perspectiveCamera_AR.params.postCreateSpareParams();
      perspectiveCamera_AR.params.runOnSceneLoadHooks();
      return { node: perspectiveCamera_AR, children: perspectiveCamera_AR_nodes };
    }
    function create_perspectiveCamera_DEBUG(cameras2) {
      var perspectiveCamera_DEBUG = cameras2.createNode("perspectiveCamera");
      perspectiveCamera_DEBUG.setName("perspectiveCamera_DEBUG");
      const perspectiveCamera_DEBUG_nodes = {};
      perspectiveCamera_DEBUG.uiData.setPosition(-350, 100);
      perspectiveCamera_DEBUG.p.position.set([0, 1.9000000000000001, 3]);
      perspectiveCamera_DEBUG.params.postCreateSpareParams();
      perspectiveCamera_DEBUG.params.runOnSceneLoadHooks();
      return { node: perspectiveCamera_DEBUG, children: perspectiveCamera_DEBUG_nodes };
    }
    cameras_nodes["cameraControls1"] = create_cameraControls1(cameras);
    cameras_nodes["cameraWebXRAR1"] = create_cameraWebXRAR1(cameras);
    cameras_nodes["merge1"] = create_merge1(cameras);
    cameras_nodes["perspectiveCamera_AR"] = create_perspectiveCamera_AR(cameras);
    cameras_nodes["perspectiveCamera_DEBUG"] = create_perspectiveCamera_DEBUG(cameras);
    cameras_nodes["cameraControls1"].node.setInput(0, cameras_nodes["perspectiveCamera_DEBUG"].node);
    cameras_nodes["cameraWebXRAR1"].node.setInput(0, cameras_nodes["perspectiveCamera_AR"].node);
    cameras_nodes["merge1"].node.setInput(0, cameras_nodes["cameraControls1"].node);
    cameras_nodes["merge1"].node.setInput(1, cameras_nodes["cameraWebXRAR1"].node);
    if (cameras.childrenController) {
      cameras.childrenController.selection.set([]);
    }
    cameras.uiData.setPosition(-50, 50);
    cameras.flags.display.set(true);
    cameras.params.postCreateSpareParams();
    cameras.params.runOnSceneLoadHooks();
    return { node: cameras, children: cameras_nodes };
  }
  function create_lights(parentNode) {
    var lights = parentNode.createNode("geo");
    lights.setName("lights");
    const lights_nodes = {};
    function create_hemisphereLight1(lights2) {
      var hemisphereLight1 = lights2.createNode("hemisphereLight");
      hemisphereLight1.setName("hemisphereLight1");
      const hemisphereLight1_nodes = {};
      hemisphereLight1.uiData.setPosition(0, -100);
      hemisphereLight1.flags.display.set(true);
      hemisphereLight1.params.postCreateSpareParams();
      hemisphereLight1.params.runOnSceneLoadHooks();
      return { node: hemisphereLight1, children: hemisphereLight1_nodes };
    }
    lights_nodes["hemisphereLight1"] = create_hemisphereLight1(lights);
    if (lights.childrenController) {
      lights.childrenController.selection.set([]);
    }
    lights.uiData.setPosition(-50, -50);
    lights.flags.display.set(true);
    lights.params.postCreateSpareParams();
    lights.params.runOnSceneLoadHooks();
    return { node: lights, children: lights_nodes };
  }
  scene_root_nodes["geo1"] = create_geo1(root);
  scene_root_nodes["grid"] = create_grid(root);
  scene_root_nodes["cameras"] = create_cameras(root);
  scene_root_nodes["lights"] = create_lights(root);
  return {
    scene,
    cameraPath: "/cameras/cameras:sopGroup/perspectiveCamera_AR",
    focusedNodes: Object.values(scene_root_nodes["geo1"].children).map((n) => n.node),
    autoLayout: false
  };
}


/***/ })

}])
//# sourceMappingURL=src_engine_examples_examples_sop_CameraWebXRAR_controllerRay2_ts.bc7cd8ce043bd0559ca0.js.map