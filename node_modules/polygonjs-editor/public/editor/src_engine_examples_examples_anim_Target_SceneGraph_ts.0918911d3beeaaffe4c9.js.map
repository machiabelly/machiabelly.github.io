{"version":3,"file":"src_engine_examples_examples_anim_Target_SceneGraph_ts.0918911d3beeaaffe4c9.js","mappings":";;;;;;;;;AAYO,SAAS,yCAAyC,MAAuB;AAE/E,QAAM,qBAAqB,KAAK,WAAW,mBAAmB;AAC9D,qBAAmB,EAAE,EAAE,IAAI,CAAC,GAAG,GAAG,CAAC,CAAC;AAEpC,QAAM,UAAU,mBAAmB,WAAW,eAAe;AAC7D,QAAM,iBAAiB,QAAQ,WAAW,qBAAqB;AAC/D,qBAAmB,EAAE,SAAS,QAAQ,cAAc;AAEpD,SAAO,EAAC,mBAAkB;AAC3B;;;;;;;;;;;;;;ACrBuD;AAEhD,SAAS,WAAW,SAA2C;AACrE,QAAM,EAAC,MAAK,IAAI;AAChB,QAAM,OAAO,MAAM,KAAK;AACxB,QAAM,MAAM,KAAK,WAAW,KAAK;AAEjC,QAAM,aAAa,IAAI,WAAW,YAAY;AAC9C,QAAM,mBAAmB,IAAI,WAAW,kBAAkB;AAC1D,QAAM,QAAQ,IAAI,WAAW,OAAO;AACpC,QAAM,OAAO,IAAI,WAAW,MAAM;AAClC,mBAAiB,SAAS,GAAG,UAAU;AACvC,OAAK,SAAS,GAAG,gBAAgB;AACjC,OAAK,SAAS,GAAG,KAAK;AAEtB,aAAW,EAAE,MAAM,IAAI,CAAC,KAAK,KAAK,GAAG,CAAC;AACtC,QAAM,EAAE,KAAK,IAAI,CAAC,GAAG,CAAC,CAAC;AACvB,mBAAiB,EAAE,MAAM,IAAI,IAAI;AACjC,mBAAiB,EAAE,KAAK,IAAI,YAAY;AACxC,OAAK,MAAM,QAAQ,IAAI,IAAI;AAG3B,QAAM,aAAa,KAAK,WAAW,mBAAmB;AAItD,QAAM,SAAS,WAAW,WAAW,QAAQ;AAC7C,SAAO,EAAE,WAAW,IAAI,aAAa;AACrC,SAAO,EAAE,aAAa,IAAI,CAAC;AAG3B,QAAM,eAAe,WAAW,WAAW,cAAc;AACzD,eAAa,SAAS,GAAG,MAAM;AAC/B,eAAa,EAAE,KAAK,IAAI,YAAY;AAEpC,QAAM,gBAAgB,WAAW,WAAW,eAAe;AAC3D,gBAAc,SAAS,GAAG,YAAY;AACtC,gBAAc,EAAE,KAAK,IAAI,CAAC;AAC1B,gBAAc,EAAE,OAAO,IAAI,MAAM,KAAK,EAAE;AAExC,QAAM,WAAW,WAAW,WAAW,UAAU;AACjD,WAAS,SAAS,GAAG,aAAa;AAClC,WAAS,EAAE,SAAS,IAAI,GAAG;AAG3B,QAAM,YAAY,WAAW,WAAW,WAAW;AACnD,YAAU,SAAS,GAAG,QAAQ;AAC9B,YAAU,EAAE,UAAU,IAAI,CAAC;AAE3B,QAAM,SAAS,WAAW,WAAW,QAAQ;AAC7C,SAAO,SAAS,GAAG,SAAS;AAI5B,QAAM,WAAW,WAAW,WAAW,UAAU;AACjD,WAAS,SAAS,GAAG,MAAM;AAC3B,WAAS,EAAE,OAAO,IAAI,IAAI;AAE1B,QAAM,QAAQ,WAAW,WAAW,MAAM;AAC1C,QAAM,SAAS,GAAG,QAAQ;AAG1B,OAAK,WAAW,iBAAiB;AAEjC,QAAM,EAAC,mBAAkB,IAAI,gGAAwC,CAAC,IAAI;AAO1E,SAAO;AAAA,IACN;AAAA,IACA,YAAY,mBAAmB,KAAK;AAAA,IACpC,cAAc,CAAC,KAAK;AAAA,IACpB,YAAY;AAAA,EACb;AACD","sources":["webpack:///../src/engine/examples/ExampleUtils.ts","webpack:///../src/engine/examples/examples/anim/Target.SceneGraph.ts"],"sourcesContent":["import type {BaseNodeType} from './../../../@polygonjs/polygonjs/src/engine/nodes/_Base';\nimport type {RootManagerNode} from './../../../@polygonjs/polygonjs/src/engine/nodes/manager/Root';\n// import {PolyScene} from './../../../@polygonjs/polygonjs/src/engine/scene/PolyScene';\n// export function initDefaultScene(scene: PolyScene) {\n// \tconst root = scene.root();\n\n// \t// create a box and a sphere\n// \tconst geo = root.createNode('geo');\n\n// \treturn {scene, root, geo};\n// }\n\nexport function addPerspectiveCameraOBJWithOrbitControls(root: RootManagerNode) {\n\t// create a camera\n\tconst perspectiveCamera1 = root.createNode('perspectiveCamera');\n\tperspectiveCamera1.p.t.set([5, 5, 5]);\n\t// add orbitControls\n\tconst events1 = perspectiveCamera1.createNode('eventsNetwork');\n\tconst orbitsControls = events1.createNode('cameraOrbitControls');\n\tperspectiveCamera1.p.controls.setNode(orbitsControls);\n\n\treturn {perspectiveCamera1};\n}\n\ninterface ReturnedNodeData {\n\tnode: BaseNodeType;\n\tchildren: Record<string, ReturnedNodeData>;\n}\nexport type ReturnedNodeDataDict = Record<string, ReturnedNodeData>;\n","import type {ExampleData, DataCallbackOptions} from '../../Common';\nimport {addPerspectiveCameraOBJWithOrbitControls} from '../../ExampleUtils';\n\nexport function createData(options: DataCallbackOptions): ExampleData {\n\tconst {scene} = options;\n\tconst root = scene.root();\n\tconst geo = root.createNode('geo');\n\n\tconst roundedBox = geo.createNode('roundedBox');\n\tconst objectProperties = geo.createNode('objectProperties');\n\tconst plane = geo.createNode('plane');\n\tconst copy = geo.createNode('copy');\n\tobjectProperties.setInput(0, roundedBox);\n\tcopy.setInput(0, objectProperties);\n\tcopy.setInput(1, plane);\n\n\troundedBox.p.sizes.set([0.8, 0.8, 0.8]);\n\tplane.p.size.set([3, 3]);\n\tobjectProperties.p.tname.set(true);\n\tobjectProperties.p.name.set('animTarget');\n\tcopy.flags.display.set(true);\n\n\t// setup the animation\n\tconst animations = root.createNode('animationsNetwork');\n\t// set the target of the animation.\n\t// In this case, we target all objects of the THREE scene graph\n\t// which care called \"anim_target\" (which is how we call them with the objectProperties above)\n\tconst target = animations.createNode('target');\n\ttarget.p.objectMask.set('*animTarget');\n\ttarget.p.updateMatrix.set(1);\n\t// set the name of the property updated by the animation.\n\t// In this case, we will update the Y axis of the rotation\n\tconst propertyName = animations.createNode('propertyName');\n\tpropertyName.setInput(0, target);\n\tpropertyName.p.name.set('rotation.z');\n\t// set the name of the property value we will animate to\n\tconst propertyValue = animations.createNode('propertyValue');\n\tpropertyValue.setInput(0, propertyName);\n\tpropertyValue.p.size.set(1);\n\tpropertyValue.p.value1.set(0.5 * Math.PI);\n\t// sets the duration\n\tconst duration = animations.createNode('duration');\n\tduration.setInput(0, propertyValue);\n\tduration.p.duration.set(0.5);\n\t// sets the operation, in this case we will add to the value\n\t// everytime the animation plays\n\tconst operation = animations.createNode('operation');\n\toperation.setInput(0, duration);\n\toperation.p.operation.set(1);\n\t// add an easing\n\tconst easing = animations.createNode('easing');\n\teasing.setInput(0, operation);\n\t// and sets the position of each animation\n\t// as the default would be that they play one after the other.\n\t// But while we want some delay, we want to adjust it.\n\tconst position = animations.createNode('position');\n\tposition.setInput(0, easing);\n\tposition.p.offset.set(0.02);\n\t// finally we add add a null node, to give us a button to start and pause the animation\n\tconst null1 = animations.createNode('null');\n\tnull1.setInput(0, position);\n\n\t// add a light\n\troot.createNode('hemisphereLight');\n\n\tconst {perspectiveCamera1} = addPerspectiveCameraOBJWithOrbitControls(root);\n\n\t// EXPORT\n\t// const nodes = [null1];\n\t// const htmlNodes = {duration, position, null1};\n\t// const camera = perspectiveCamera1;\n\t// return {scene, camera, nodes, htmlNodes};\n\treturn {\n\t\tscene,\n\t\tcameraPath: perspectiveCamera1.path(),\n\t\tfocusedNodes: [null1],\n\t\tautoLayout: true,\n\t};\n}\n\n// export const animTargetSceneGraph = [\n// \tnew Example({\n// \t\tname: `${ExamplePrefix.BY_NODE}/anim/target/Animate Scene Graph`,\n// \t\tcreateData,\n// \t\trelatedNodes: [TargetAnimNode],\n// \t\tcategories: [ExampleCategory.ANIMATION],\n// \t}),\n// \t// new Example({name: `${ExamplePrefix.BY_CATEGORY}/animation/Scene Graph`, createData}),\n// ];\n"],"names":[],"sourceRoot":""}