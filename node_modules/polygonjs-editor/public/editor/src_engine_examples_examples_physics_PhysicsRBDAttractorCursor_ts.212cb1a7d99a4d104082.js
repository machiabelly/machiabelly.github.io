(self["webpackChunk"] = self["webpackChunk"] || []).push([["src_engine_examples_examples_physics_PhysicsRBDAttractorCursor_ts"],{

/***/ 31446:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "createData": function() { return /* binding */ createData; }
/* harmony export */ });
/* harmony import */ var _polygonjs_polygonjs_src_engine_poly_ParamType__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(51254);
/* harmony import */ var _polygonjs_polygonjs_src_core_event_CoreEventEmitter__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(9913);
/* harmony import */ var _polygonjs_polygonjs_src_core_geometry_Constant__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(91568);




function createData(options) {
  const { scene } = options;
  const root = scene.root();
  const scene_root_nodes = {};
  function create_lights(parentNode) {
    var lights = parentNode.createNode("geo");
    lights.setName("lights");
    const lights_nodes = {};
    function create_hemisphereLight1(lights2) {
      var hemisphereLight1 = lights2.createNode("hemisphereLight");
      hemisphereLight1.setName("hemisphereLight1");
      const hemisphereLight1_nodes = {};
      hemisphereLight1.uiData.setPosition(-450, -100);
      hemisphereLight1.p.intensity.set(0.28);
      hemisphereLight1.params.postCreateSpareParams();
      hemisphereLight1.params.runOnSceneLoadHooks();
      return { node: hemisphereLight1, children: hemisphereLight1_nodes };
    }
    function create_merge1(lights2) {
      var merge1 = lights2.createNode("merge");
      merge1.setName("merge1");
      const merge1_nodes = {};
      merge1.uiData.setPosition(-300, 300);
      merge1.flags.display.set(true);
      merge1.params.postCreateSpareParams();
      merge1.params.runOnSceneLoadHooks();
      return { node: merge1, children: merge1_nodes };
    }
    function create_polarTransform1(lights2) {
      var polarTransform1 = lights2.createNode("polarTransform");
      polarTransform1.setName("polarTransform1");
      const polarTransform1_nodes = {};
      polarTransform1.uiData.setPosition(-200, 100);
      polarTransform1.p.longitude.set(-36);
      polarTransform1.p.latitude.set(43.2);
      polarTransform1.p.depth.set(4.4);
      polarTransform1.params.postCreateSpareParams();
      polarTransform1.params.runOnSceneLoadHooks();
      return { node: polarTransform1, children: polarTransform1_nodes };
    }
    function create_spotLight1(lights2) {
      var spotLight1 = lights2.createNode("spotLight");
      spotLight1.setName("spotLight1");
      const spotLight1_nodes = {};
      spotLight1.uiData.setPosition(-200, -100);
      spotLight1.p.intensity.set(22);
      spotLight1.p.decay.set(2);
      spotLight1.p.castShadow.set(true);
      spotLight1.params.postCreateSpareParams();
      spotLight1.params.runOnSceneLoadHooks();
      return { node: spotLight1, children: spotLight1_nodes };
    }
    lights_nodes["hemisphereLight1"] = create_hemisphereLight1(lights);
    lights_nodes["merge1"] = create_merge1(lights);
    lights_nodes["polarTransform1"] = create_polarTransform1(lights);
    lights_nodes["spotLight1"] = create_spotLight1(lights);
    lights_nodes["merge1"].node.setInput(0, lights_nodes["hemisphereLight1"].node);
    lights_nodes["merge1"].node.setInput(1, lights_nodes["polarTransform1"].node);
    lights_nodes["polarTransform1"].node.setInput(0, lights_nodes["spotLight1"].node);
    if (lights.childrenController) {
      lights.childrenController.selection.set([]);
    }
    lights.uiData.setComment("Inside [this node](.) we create 2 simple lights");
    lights.uiData.setPosition(-50, 0);
    lights.flags.display.set(true);
    lights.params.postCreateSpareParams();
    lights.params.runOnSceneLoadHooks();
    return { node: lights, children: lights_nodes };
  }
  function create_physics(parentNode) {
    var physics = parentNode.createNode("geo");
    physics.setName("physics");
    const physics_nodes = {};
    function create_MAT(physics2) {
      var MAT = physics2.createNode("materialsNetwork");
      MAT.setName("MAT");
      const MAT_nodes = {};
      function create_meshStandardBuilder_MAIN(MAT2) {
        var meshStandardBuilder_MAIN = MAT2.createNode("meshStandardBuilder");
        meshStandardBuilder_MAIN.setName("meshStandardBuilder_MAIN");
        const meshStandardBuilder_MAIN_nodes = {};
        function create_checkers1(meshStandardBuilder_MAIN2) {
          var checkers1 = meshStandardBuilder_MAIN2.createNode("checkers");
          checkers1.setName("checkers1");
          const checkers1_nodes = {};
          checkers1.uiData.setPosition(-50, 0);
          checkers1.params.postCreateSpareParams();
          checkers1.params.runOnSceneLoadHooks();
          return { node: checkers1, children: checkers1_nodes };
        }
        function create_constant1(meshStandardBuilder_MAIN2) {
          var constant1 = meshStandardBuilder_MAIN2.createNode("constant");
          constant1.setName("constant1");
          const constant1_nodes = {};
          constant1.uiData.setPosition(-100, -300);
          constant1.p.type.set(4);
          constant1.p.color.set([0.8862745098039215, 0.13333333333333333, 0.13333333333333333]);
          constant1.p.asColor.set(true);
          constant1.params.postCreateSpareParams();
          constant1.params.runOnSceneLoadHooks();
          return { node: constant1, children: constant1_nodes };
        }
        function create_constant2(meshStandardBuilder_MAIN2) {
          var constant2 = meshStandardBuilder_MAIN2.createNode("constant");
          constant2.setName("constant2");
          const constant2_nodes = {};
          constant2.uiData.setPosition(-100, -200);
          constant2.p.type.set(4);
          constant2.p.color.set([0.6705882352941176, 0.6274509803921569, 0.6392156862745098]);
          constant2.p.asColor.set(true);
          constant2.params.postCreateSpareParams();
          constant2.params.runOnSceneLoadHooks();
          return { node: constant2, children: constant2_nodes };
        }
        function create_floatToVec2_1(meshStandardBuilder_MAIN2) {
          var floatToVec2_1 = meshStandardBuilder_MAIN2.createNode("floatToVec2");
          floatToVec2_1.setName("floatToVec2_1");
          const floatToVec2_1_nodes = {};
          floatToVec2_1.uiData.setPosition(-150, 0);
          floatToVec2_1.params.postCreateSpareParams();
          floatToVec2_1.params.runOnSceneLoadHooks();
          return { node: floatToVec2_1, children: floatToVec2_1_nodes };
        }
        function create_globals1(meshStandardBuilder_MAIN2) {
          var globals1 = meshStandardBuilder_MAIN2.createNode("globals");
          globals1.setName("globals1");
          const globals1_nodes = {};
          globals1.uiData.setPosition(-350, 0);
          globals1.params.postCreateSpareParams();
          globals1.params.runOnSceneLoadHooks();
          return { node: globals1, children: globals1_nodes };
        }
        function create_mix1(meshStandardBuilder_MAIN2) {
          var mix1 = meshStandardBuilder_MAIN2.createNode("mix");
          mix1.setName("mix1");
          const mix1_nodes = {};
          mix1.uiData.setPosition(100, -100);
          mix1.addParam(_polygonjs_polygonjs_src_engine_poly_ParamType__WEBPACK_IMPORTED_MODULE_0__/* .ParamType.VECTOR3 */ ._.VECTOR3, "value0", [0, 0, 0], { spare: true, editable: false });
          mix1.addParam(_polygonjs_polygonjs_src_engine_poly_ParamType__WEBPACK_IMPORTED_MODULE_0__/* .ParamType.VECTOR3 */ ._.VECTOR3, "value1", [0, 0, 0], { spare: true, editable: false });
          mix1.addParam(_polygonjs_polygonjs_src_engine_poly_ParamType__WEBPACK_IMPORTED_MODULE_0__/* .ParamType.FLOAT */ ._.FLOAT, "blend", 0.5, { spare: true, editable: false });
          mix1.params.postCreateSpareParams();
          mix1.params.runOnSceneLoadHooks();
          return { node: mix1, children: mix1_nodes };
        }
        function create_output1(meshStandardBuilder_MAIN2) {
          var output1 = meshStandardBuilder_MAIN2.createNode("output");
          output1.setName("output1");
          const output1_nodes = {};
          output1.uiData.setPosition(250, 0);
          output1.params.postCreateSpareParams();
          output1.params.runOnSceneLoadHooks();
          return { node: output1, children: output1_nodes };
        }
        function create_vec3ToFloat1(meshStandardBuilder_MAIN2) {
          var vec3ToFloat1 = meshStandardBuilder_MAIN2.createNode("vec3ToFloat");
          vec3ToFloat1.setName("vec3ToFloat1");
          const vec3ToFloat1_nodes = {};
          vec3ToFloat1.uiData.setPosition(-250, 0);
          vec3ToFloat1.params.postCreateSpareParams();
          vec3ToFloat1.params.runOnSceneLoadHooks();
          return { node: vec3ToFloat1, children: vec3ToFloat1_nodes };
        }
        meshStandardBuilder_MAIN_nodes["checkers1"] = create_checkers1(meshStandardBuilder_MAIN);
        meshStandardBuilder_MAIN_nodes["constant1"] = create_constant1(meshStandardBuilder_MAIN);
        meshStandardBuilder_MAIN_nodes["constant2"] = create_constant2(meshStandardBuilder_MAIN);
        meshStandardBuilder_MAIN_nodes["floatToVec2_1"] = create_floatToVec2_1(meshStandardBuilder_MAIN);
        meshStandardBuilder_MAIN_nodes["globals1"] = create_globals1(meshStandardBuilder_MAIN);
        meshStandardBuilder_MAIN_nodes["mix1"] = create_mix1(meshStandardBuilder_MAIN);
        meshStandardBuilder_MAIN_nodes["output1"] = create_output1(meshStandardBuilder_MAIN);
        meshStandardBuilder_MAIN_nodes["vec3ToFloat1"] = create_vec3ToFloat1(meshStandardBuilder_MAIN);
        meshStandardBuilder_MAIN_nodes["checkers1"].node.setInput(
          "uv",
          meshStandardBuilder_MAIN_nodes["floatToVec2_1"].node,
          "vec2"
        );
        meshStandardBuilder_MAIN_nodes["floatToVec2_1"].node.setInput(
          "x",
          meshStandardBuilder_MAIN_nodes["vec3ToFloat1"].node,
          "x"
        );
        meshStandardBuilder_MAIN_nodes["floatToVec2_1"].node.setInput(
          "y",
          meshStandardBuilder_MAIN_nodes["vec3ToFloat1"].node,
          "z"
        );
        meshStandardBuilder_MAIN_nodes["mix1"].node.setInput(
          "value0",
          meshStandardBuilder_MAIN_nodes["constant1"].node,
          "val"
        );
        meshStandardBuilder_MAIN_nodes["mix1"].node.setInput(
          "value1",
          meshStandardBuilder_MAIN_nodes["constant2"].node,
          "val"
        );
        meshStandardBuilder_MAIN_nodes["mix1"].node.setInput(
          "blend",
          meshStandardBuilder_MAIN_nodes["checkers1"].node,
          "checker"
        );
        meshStandardBuilder_MAIN_nodes["output1"].node.setInput(
          "color",
          meshStandardBuilder_MAIN_nodes["mix1"].node,
          "mix"
        );
        meshStandardBuilder_MAIN_nodes["vec3ToFloat1"].node.setInput(
          "vec",
          meshStandardBuilder_MAIN_nodes["globals1"].node,
          "position"
        );
        if (meshStandardBuilder_MAIN.childrenController) {
          meshStandardBuilder_MAIN.childrenController.selection.set([
            meshStandardBuilder_MAIN_nodes["constant1"].node
          ]);
        }
        meshStandardBuilder_MAIN.uiData.setPosition(0, 600);
        meshStandardBuilder_MAIN.params.postCreateSpareParams();
        meshStandardBuilder_MAIN.params.runOnSceneLoadHooks();
        return { node: meshStandardBuilder_MAIN, children: meshStandardBuilder_MAIN_nodes };
      }
      function create_meshStandardBuilder_SMALL(MAT2) {
        var meshStandardBuilder_SMALL = MAT2.createNode("meshStandardBuilder");
        meshStandardBuilder_SMALL.setName("meshStandardBuilder_SMALL");
        const meshStandardBuilder_SMALL_nodes = {};
        function create_checkers1(meshStandardBuilder_SMALL2) {
          var checkers1 = meshStandardBuilder_SMALL2.createNode("checkers");
          checkers1.setName("checkers1");
          const checkers1_nodes = {};
          checkers1.uiData.setPosition(-50, 0);
          checkers1.params.postCreateSpareParams();
          checkers1.params.runOnSceneLoadHooks();
          return { node: checkers1, children: checkers1_nodes };
        }
        function create_constant1(meshStandardBuilder_SMALL2) {
          var constant1 = meshStandardBuilder_SMALL2.createNode("constant");
          constant1.setName("constant1");
          const constant1_nodes = {};
          constant1.uiData.setPosition(-100, -300);
          constant1.p.type.set(4);
          constant1.p.color.set([0.25098039215686274, 0.2, 0.8]);
          constant1.p.asColor.set(true);
          constant1.params.postCreateSpareParams();
          constant1.params.runOnSceneLoadHooks();
          return { node: constant1, children: constant1_nodes };
        }
        function create_constant2(meshStandardBuilder_SMALL2) {
          var constant2 = meshStandardBuilder_SMALL2.createNode("constant");
          constant2.setName("constant2");
          const constant2_nodes = {};
          constant2.uiData.setPosition(-100, -200);
          constant2.p.type.set(4);
          constant2.p.color.set([0.6745098039215687, 0.7019607843137254, 0.7254901960784313]);
          constant2.p.asColor.set(true);
          constant2.params.postCreateSpareParams();
          constant2.params.runOnSceneLoadHooks();
          return { node: constant2, children: constant2_nodes };
        }
        function create_floatToVec2_1(meshStandardBuilder_SMALL2) {
          var floatToVec2_1 = meshStandardBuilder_SMALL2.createNode("floatToVec2");
          floatToVec2_1.setName("floatToVec2_1");
          const floatToVec2_1_nodes = {};
          floatToVec2_1.uiData.setPosition(-150, 0);
          floatToVec2_1.params.postCreateSpareParams();
          floatToVec2_1.params.runOnSceneLoadHooks();
          return { node: floatToVec2_1, children: floatToVec2_1_nodes };
        }
        function create_globals1(meshStandardBuilder_SMALL2) {
          var globals1 = meshStandardBuilder_SMALL2.createNode("globals");
          globals1.setName("globals1");
          const globals1_nodes = {};
          globals1.uiData.setPosition(-350, 0);
          globals1.params.postCreateSpareParams();
          globals1.params.runOnSceneLoadHooks();
          return { node: globals1, children: globals1_nodes };
        }
        function create_mix1(meshStandardBuilder_SMALL2) {
          var mix1 = meshStandardBuilder_SMALL2.createNode("mix");
          mix1.setName("mix1");
          const mix1_nodes = {};
          mix1.uiData.setPosition(100, -100);
          mix1.addParam(_polygonjs_polygonjs_src_engine_poly_ParamType__WEBPACK_IMPORTED_MODULE_0__/* .ParamType.VECTOR3 */ ._.VECTOR3, "value0", [0, 0, 0], { spare: true, editable: false });
          mix1.addParam(_polygonjs_polygonjs_src_engine_poly_ParamType__WEBPACK_IMPORTED_MODULE_0__/* .ParamType.VECTOR3 */ ._.VECTOR3, "value1", [0, 0, 0], { spare: true, editable: false });
          mix1.addParam(_polygonjs_polygonjs_src_engine_poly_ParamType__WEBPACK_IMPORTED_MODULE_0__/* .ParamType.FLOAT */ ._.FLOAT, "blend", 0.5, { spare: true, editable: false });
          mix1.params.postCreateSpareParams();
          mix1.params.runOnSceneLoadHooks();
          return { node: mix1, children: mix1_nodes };
        }
        function create_output1(meshStandardBuilder_SMALL2) {
          var output1 = meshStandardBuilder_SMALL2.createNode("output");
          output1.setName("output1");
          const output1_nodes = {};
          output1.uiData.setPosition(250, 0);
          output1.params.postCreateSpareParams();
          output1.params.runOnSceneLoadHooks();
          return { node: output1, children: output1_nodes };
        }
        function create_vec3ToFloat1(meshStandardBuilder_SMALL2) {
          var vec3ToFloat1 = meshStandardBuilder_SMALL2.createNode("vec3ToFloat");
          vec3ToFloat1.setName("vec3ToFloat1");
          const vec3ToFloat1_nodes = {};
          vec3ToFloat1.uiData.setPosition(-250, 0);
          vec3ToFloat1.params.postCreateSpareParams();
          vec3ToFloat1.params.runOnSceneLoadHooks();
          return { node: vec3ToFloat1, children: vec3ToFloat1_nodes };
        }
        meshStandardBuilder_SMALL_nodes["checkers1"] = create_checkers1(meshStandardBuilder_SMALL);
        meshStandardBuilder_SMALL_nodes["constant1"] = create_constant1(meshStandardBuilder_SMALL);
        meshStandardBuilder_SMALL_nodes["constant2"] = create_constant2(meshStandardBuilder_SMALL);
        meshStandardBuilder_SMALL_nodes["floatToVec2_1"] = create_floatToVec2_1(meshStandardBuilder_SMALL);
        meshStandardBuilder_SMALL_nodes["globals1"] = create_globals1(meshStandardBuilder_SMALL);
        meshStandardBuilder_SMALL_nodes["mix1"] = create_mix1(meshStandardBuilder_SMALL);
        meshStandardBuilder_SMALL_nodes["output1"] = create_output1(meshStandardBuilder_SMALL);
        meshStandardBuilder_SMALL_nodes["vec3ToFloat1"] = create_vec3ToFloat1(meshStandardBuilder_SMALL);
        meshStandardBuilder_SMALL_nodes["checkers1"].node.setInput(
          "uv",
          meshStandardBuilder_SMALL_nodes["floatToVec2_1"].node,
          "vec2"
        );
        meshStandardBuilder_SMALL_nodes["floatToVec2_1"].node.setInput(
          "x",
          meshStandardBuilder_SMALL_nodes["vec3ToFloat1"].node,
          "x"
        );
        meshStandardBuilder_SMALL_nodes["floatToVec2_1"].node.setInput(
          "y",
          meshStandardBuilder_SMALL_nodes["vec3ToFloat1"].node,
          "z"
        );
        meshStandardBuilder_SMALL_nodes["mix1"].node.setInput(
          "value0",
          meshStandardBuilder_SMALL_nodes["constant1"].node,
          "val"
        );
        meshStandardBuilder_SMALL_nodes["mix1"].node.setInput(
          "value1",
          meshStandardBuilder_SMALL_nodes["constant2"].node,
          "val"
        );
        meshStandardBuilder_SMALL_nodes["mix1"].node.setInput(
          "blend",
          meshStandardBuilder_SMALL_nodes["checkers1"].node,
          "checker"
        );
        meshStandardBuilder_SMALL_nodes["output1"].node.setInput(
          "color",
          meshStandardBuilder_SMALL_nodes["mix1"].node,
          "mix"
        );
        meshStandardBuilder_SMALL_nodes["vec3ToFloat1"].node.setInput(
          "vec",
          meshStandardBuilder_SMALL_nodes["globals1"].node,
          "position"
        );
        if (meshStandardBuilder_SMALL.childrenController) {
          meshStandardBuilder_SMALL.childrenController.selection.set([
            meshStandardBuilder_SMALL_nodes["constant1"].node
          ]);
        }
        meshStandardBuilder_SMALL.uiData.setPosition(0, 800);
        meshStandardBuilder_SMALL.params.postCreateSpareParams();
        meshStandardBuilder_SMALL.params.runOnSceneLoadHooks();
        return { node: meshStandardBuilder_SMALL, children: meshStandardBuilder_SMALL_nodes };
      }
      MAT_nodes["meshStandardBuilder_MAIN"] = create_meshStandardBuilder_MAIN(MAT);
      MAT_nodes["meshStandardBuilder_SMALL"] = create_meshStandardBuilder_SMALL(MAT);
      if (MAT.childrenController) {
        MAT.childrenController.selection.set([]);
      }
      MAT.uiData.setPosition(-250, 1e3);
      MAT.params.postCreateSpareParams();
      MAT.params.runOnSceneLoadHooks();
      return { node: MAT, children: MAT_nodes };
    }
    function create_actor1(physics2) {
      var actor1 = physics2.createNode("actor");
      actor1.setName("actor1");
      const actor1_nodes = {};
      function create_onTick1(actor12) {
        var onTick1 = actor12.createNode("onTick");
        onTick1.setName("onTick1");
        const onTick1_nodes = {};
        onTick1.uiData.setPosition(100, 0);
        onTick1.params.postCreateSpareParams();
        onTick1.params.runOnSceneLoadHooks();
        return { node: onTick1, children: onTick1_nodes };
      }
      function create_plane1(actor12) {
        var plane1 = actor12.createNode("plane");
        plane1.setName("plane1");
        const plane1_nodes = {};
        plane1.uiData.setPosition(-50, 400);
        plane1.p.normal.set([0, 0, 1]);
        plane1.params.postCreateSpareParams();
        plane1.params.runOnSceneLoadHooks();
        return { node: plane1, children: plane1_nodes };
      }
      function create_rayFromCursor1(actor12) {
        var rayFromCursor1 = actor12.createNode("rayFromCursor");
        rayFromCursor1.setName("rayFromCursor1");
        const rayFromCursor1_nodes = {};
        rayFromCursor1.uiData.setPosition(-50, 250);
        rayFromCursor1.setEventEmitter(_polygonjs_polygonjs_src_core_event_CoreEventEmitter__WEBPACK_IMPORTED_MODULE_1__/* .CoreEventEmitter.DOCUMENT */ .Ok.DOCUMENT);
        rayFromCursor1.params.postCreateSpareParams();
        rayFromCursor1.params.runOnSceneLoadHooks();
        return { node: rayFromCursor1, children: rayFromCursor1_nodes };
      }
      function create_rayIntersectPlane1(actor12) {
        var rayIntersectPlane1 = actor12.createNode("rayIntersectPlane");
        rayIntersectPlane1.setName("rayIntersectPlane1");
        const rayIntersectPlane1_nodes = {};
        rayIntersectPlane1.uiData.setPosition(150, 300);
        rayIntersectPlane1.params.postCreateSpareParams();
        rayIntersectPlane1.params.runOnSceneLoadHooks();
        return { node: rayIntersectPlane1, children: rayIntersectPlane1_nodes };
      }
      function create_setPhysicsRBDPosition1(actor12) {
        var setPhysicsRBDPosition1 = actor12.createNode("setPhysicsRBDPosition");
        setPhysicsRBDPosition1.setName("setPhysicsRBDPosition1");
        const setPhysicsRBDPosition1_nodes = {};
        setPhysicsRBDPosition1.uiData.setComment(
          "the [setPhysicsRBDPosition1](../setPhysicsRBDPosition1) is triggered every frame, and will update the position of the input object.\n\nThe position is calculated by sending [a ray from the cursor](../rayFromCursor1), and [getting the intersection of that ray](../rayIntersectPlane1) with [a plane facing the z axis](../plane1).\nNote that you can click those 3 previous links to see which node does that specific part of the computation"
        );
        setPhysicsRBDPosition1.uiData.setPosition(400, 150);
        setPhysicsRBDPosition1.p.lerp.set(0.12);
        setPhysicsRBDPosition1.params.postCreateSpareParams();
        setPhysicsRBDPosition1.params.runOnSceneLoadHooks();
        return { node: setPhysicsRBDPosition1, children: setPhysicsRBDPosition1_nodes };
      }
      actor1_nodes["onTick1"] = create_onTick1(actor1);
      actor1_nodes["plane1"] = create_plane1(actor1);
      actor1_nodes["rayFromCursor1"] = create_rayFromCursor1(actor1);
      actor1_nodes["rayIntersectPlane1"] = create_rayIntersectPlane1(actor1);
      actor1_nodes["setPhysicsRBDPosition1"] = create_setPhysicsRBDPosition1(actor1);
      actor1_nodes["rayIntersectPlane1"].node.setInput("Ray", actor1_nodes["rayFromCursor1"].node, "Ray");
      actor1_nodes["rayIntersectPlane1"].node.setInput("Plane", actor1_nodes["plane1"].node, "Plane");
      actor1_nodes["setPhysicsRBDPosition1"].node.setInput("trigger", actor1_nodes["onTick1"].node, "trigger");
      actor1_nodes["setPhysicsRBDPosition1"].node.setInput(
        "position",
        actor1_nodes["rayIntersectPlane1"].node,
        "position"
      );
      if (actor1.childrenController) {
        actor1.childrenController.selection.set([actor1_nodes["plane1"].node]);
      }
      actor1.uiData.setComment(
        "Inside this [actor node](.), we add a behavior to the input sphere that will make it follow the cursor."
      );
      actor1.uiData.setPosition(650, 1850);
      actor1.params.postCreateSpareParams();
      actor1.params.runOnSceneLoadHooks();
      return { node: actor1, children: actor1_nodes };
    }
    function create_actor2(physics2) {
      var actor2 = physics2.createNode("actor");
      actor2.setName("actor2");
      const actor2_nodes = {};
      function create_getObjectProperty1(actor22) {
        var getObjectProperty1 = actor22.createNode("getObjectProperty");
        getObjectProperty1.setName("getObjectProperty1");
        const getObjectProperty1_nodes = {};
        getObjectProperty1.uiData.setPosition(-150, 200);
        getObjectProperty1.params.postCreateSpareParams();
        getObjectProperty1.params.runOnSceneLoadHooks();
        return { node: getObjectProperty1, children: getObjectProperty1_nodes };
      }
      function create_multScalar1(actor22) {
        var multScalar1 = actor22.createNode("multScalar");
        multScalar1.setName("multScalar1");
        const multScalar1_nodes = {};
        multScalar1.uiData.setPosition(350, 200);
        multScalar1.addParam(_polygonjs_polygonjs_src_engine_poly_ParamType__WEBPACK_IMPORTED_MODULE_0__/* .ParamType.VECTOR3 */ ._.VECTOR3, "value", [1, 1, 1], { spare: true, editable: false });
        multScalar1.addParam(_polygonjs_polygonjs_src_engine_poly_ParamType__WEBPACK_IMPORTED_MODULE_0__/* .ParamType.FLOAT */ ._.FLOAT, "mult", 1, { spare: true, editable: true });
        multScalar1.params.get("mult").set(0.03);
        multScalar1.params.postCreateSpareParams();
        multScalar1.params.runOnSceneLoadHooks();
        return { node: multScalar1, children: multScalar1_nodes };
      }
      function create_negate2(actor22) {
        var negate2 = actor22.createNode("negate");
        negate2.setName("negate2");
        const negate2_nodes = {};
        negate2.uiData.setPosition(200, 200);
        negate2.addParam(_polygonjs_polygonjs_src_engine_poly_ParamType__WEBPACK_IMPORTED_MODULE_0__/* .ParamType.VECTOR3 */ ._.VECTOR3, "value", [0, 0, 0], { spare: true, editable: false });
        negate2.params.postCreateSpareParams();
        negate2.params.runOnSceneLoadHooks();
        return { node: negate2, children: negate2_nodes };
      }
      function create_normalize2(actor22) {
        var normalize2 = actor22.createNode("normalize");
        normalize2.setName("normalize2");
        const normalize2_nodes = {};
        normalize2.uiData.setPosition(100, 200);
        normalize2.addParam(_polygonjs_polygonjs_src_engine_poly_ParamType__WEBPACK_IMPORTED_MODULE_0__/* .ParamType.VECTOR3 */ ._.VECTOR3, "v", [0, 0, 1], { spare: true, editable: false });
        normalize2.params.postCreateSpareParams();
        normalize2.params.runOnSceneLoadHooks();
        return { node: normalize2, children: normalize2_nodes };
      }
      function create_onTick1(actor22) {
        var onTick1 = actor22.createNode("onTick");
        onTick1.setName("onTick1");
        const onTick1_nodes = {};
        onTick1.uiData.setPosition(250, -50);
        onTick1.params.postCreateSpareParams();
        onTick1.params.runOnSceneLoadHooks();
        return { node: onTick1, children: onTick1_nodes };
      }
      function create_physicsRBDApplyImpulse1(actor22) {
        var physicsRBDApplyImpulse1 = actor22.createNode("physicsRBDApplyImpulse");
        physicsRBDApplyImpulse1.setName("physicsRBDApplyImpulse1");
        const physicsRBDApplyImpulse1_nodes = {};
        physicsRBDApplyImpulse1.uiData.setComment(
          "Those nodes will be executed `for every object` that are input of the actor node.\n\nSince they are triggered by an [onTick](../onTick1) node, they wil also be executed `on every frame`.\n\nWhat happens is basically this:\n\n- the [onTick](../onTick1) triggers nodes on its right.\n\n- The [physicsRBDApplyImpulse1](../physicsRBDApplyImpulse1) receives the trigger and... adds an impulse to the object. And that impulse is defines by its `impulse` input, which takes its current position, normalizes it, , inverts it and multiplies it by a small value. This will then push the object toward the center."
        );
        physicsRBDApplyImpulse1.uiData.setPosition(500, 0);
        physicsRBDApplyImpulse1.params.postCreateSpareParams();
        physicsRBDApplyImpulse1.params.runOnSceneLoadHooks();
        return { node: physicsRBDApplyImpulse1, children: physicsRBDApplyImpulse1_nodes };
      }
      actor2_nodes["getObjectProperty1"] = create_getObjectProperty1(actor2);
      actor2_nodes["multScalar1"] = create_multScalar1(actor2);
      actor2_nodes["negate2"] = create_negate2(actor2);
      actor2_nodes["normalize2"] = create_normalize2(actor2);
      actor2_nodes["onTick1"] = create_onTick1(actor2);
      actor2_nodes["physicsRBDApplyImpulse1"] = create_physicsRBDApplyImpulse1(actor2);
      actor2_nodes["multScalar1"].node.setInput("value", actor2_nodes["negate2"].node, "negate");
      actor2_nodes["negate2"].node.setInput("value", actor2_nodes["normalize2"].node, "val");
      actor2_nodes["normalize2"].node.setInput("v", actor2_nodes["getObjectProperty1"].node, "position");
      actor2_nodes["physicsRBDApplyImpulse1"].node.setInput("trigger", actor2_nodes["onTick1"].node, "trigger");
      actor2_nodes["physicsRBDApplyImpulse1"].node.setInput("impulse", actor2_nodes["multScalar1"].node, "val");
      if (actor2.childrenController) {
        actor2.childrenController.selection.set([]);
      }
      actor2.uiData.setComment(
        "Inside [this node](.) we add a behavior to the rigid bodies. The goal is to add a force that will push them to the center of the scene."
      );
      actor2.uiData.setPosition(50, 1850);
      actor2.params.postCreateSpareParams();
      actor2.params.runOnSceneLoadHooks();
      return { node: actor2, children: actor2_nodes };
    }
    function create_copy2(physics2) {
      var copy2 = physics2.createNode("copy");
      copy2.setName("copy2");
      const copy2_nodes = {};
      copy2.uiData.setComment("Here we copy a sphere on each of the points of the 2nd input");
      copy2.uiData.setPosition(50, 650);
      copy2.params.postCreateSpareParams();
      copy2.params.runOnSceneLoadHooks();
      return { node: copy2, children: copy2_nodes };
    }
    function create_delete2(physics2) {
      var delete2 = physics2.createNode("delete");
      delete2.setName("delete2");
      const delete2_nodes = {};
      delete2.uiData.setPosition(100, 250);
      delete2.setAttribClass(_polygonjs_polygonjs_src_core_geometry_Constant__WEBPACK_IMPORTED_MODULE_2__/* .AttribClass.OBJECT */ .io.OBJECT);
      delete2.p.invert.set(true);
      delete2.p.keepPoints.set(true);
      delete2.params.postCreateSpareParams();
      delete2.params.runOnSceneLoadHooks();
      return { node: delete2, children: delete2_nodes };
    }
    function create_fuse1(physics2) {
      var fuse1 = physics2.createNode("fuse");
      fuse1.setName("fuse1");
      const fuse1_nodes = {};
      fuse1.uiData.setComment(
        "With this node and the 2 above, we place some points on a sphere, so that they are evenly spread out.\n\nThis ensures that rigid bodies will not collide with each other when the sim starts."
      );
      fuse1.uiData.setPosition(100, 400);
      fuse1.p.dist.set(0.47);
      fuse1.params.postCreateSpareParams();
      fuse1.params.runOnSceneLoadHooks();
      return { node: fuse1, children: fuse1_nodes };
    }
    function create_icosahedron1(physics2) {
      var icosahedron1 = physics2.createNode("icosahedron");
      icosahedron1.setName("icosahedron1");
      const icosahedron1_nodes = {};
      icosahedron1.uiData.setPosition(100, 100);
      icosahedron1.p.detail.set(1);
      icosahedron1.params.postCreateSpareParams();
      icosahedron1.params.runOnSceneLoadHooks();
      return { node: icosahedron1, children: icosahedron1_nodes };
    }
    function create_material1(physics2) {
      var material1 = physics2.createNode("material");
      material1.setName("material1");
      const material1_nodes = {};
      material1.uiData.setComment("This assigns a material to the sphere. ");
      material1.uiData.setPosition(50, 900);
      material1.p.material.set("../MAT/meshStandardBuilder_SMALL");
      material1.params.postCreateSpareParams();
      material1.params.runOnSceneLoadHooks();
      return { node: material1, children: material1_nodes };
    }
    function create_material2(physics2) {
      var material2 = physics2.createNode("material");
      material2.setName("material2");
      const material2_nodes = {};
      material2.uiData.setComment(
        "While on the left branch we created multiple sphere, here we created a single one. So the setup is simpler. We only need a sphere node, then a material and a transform to position it."
      );
      material2.uiData.setPosition(650, 900);
      material2.p.material.set("../MAT/meshStandardBuilder_MAIN");
      material2.params.postCreateSpareParams();
      material2.params.runOnSceneLoadHooks();
      return { node: material2, children: material2_nodes };
    }
    function create_merge1(physics2) {
      var merge1 = physics2.createNode("merge");
      merge1.setName("merge1");
      const merge1_nodes = {};
      merge1.uiData.setPosition(550, 2250);
      merge1.params.postCreateSpareParams();
      merge1.params.runOnSceneLoadHooks();
      return { node: merge1, children: merge1_nodes };
    }
    function create_physicsRBDAttributes1(physics2) {
      var physicsRBDAttributes1 = physics2.createNode("physicsRBDAttributes");
      physicsRBDAttributes1.setName("physicsRBDAttributes1");
      const physicsRBDAttributes1_nodes = {};
      physicsRBDAttributes1.uiData.setComment(
        "Here we assign physics attributes on the sphere. Those would basically define:\n\n- if the object is `fixed` (it will not move at all, like the ground for instance), `dynamic` ( fully driven by the simulation), or  `kinematic` (driven by other triggers than the simulation) \n\n- the shape of the collider (in this case a `sphere`)\n\n- properties like `friction` and `restitution`"
      );
      physicsRBDAttributes1.uiData.setPosition(50, 1200);
      physicsRBDAttributes1.p.colliderType.set(1);
      physicsRBDAttributes1.p.radius.set(0.2);
      physicsRBDAttributes1.p.density.set(3.8);
      physicsRBDAttributes1.p.friction.set(0.99);
      physicsRBDAttributes1.p.restitution.set(0);
      physicsRBDAttributes1.p.linearDamping.set(3.5);
      physicsRBDAttributes1.p.angularDamping.set(1.9);
      physicsRBDAttributes1.p.canSleep.set(false);
      physicsRBDAttributes1.params.postCreateSpareParams();
      physicsRBDAttributes1.params.runOnSceneLoadHooks();
      return { node: physicsRBDAttributes1, children: physicsRBDAttributes1_nodes };
    }
    function create_physicsRBDAttributes2(physics2) {
      var physicsRBDAttributes2 = physics2.createNode("physicsRBDAttributes");
      physicsRBDAttributes2.setName("physicsRBDAttributes2");
      const physicsRBDAttributes2_nodes = {};
      physicsRBDAttributes2.uiData.setComment(
        "Just like the [physicsRBDAttributes1](../physicsRBDAttributes1), we add physics attribute to this sphere. The main difference is the `RBDType` is set to `kinematicPositionBased`, as we will move the sphere inside the [actor node](../actor1)."
      );
      physicsRBDAttributes2.uiData.setPosition(650, 1200);
      physicsRBDAttributes2.p.RBDType.set(2);
      physicsRBDAttributes2.p.colliderType.set(1);
      physicsRBDAttributes2.p.radius.set(0.7);
      physicsRBDAttributes2.p.density.set(0.01);
      physicsRBDAttributes2.p.friction.set(0.99);
      physicsRBDAttributes2.p.restitution.set(0);
      physicsRBDAttributes2.params.postCreateSpareParams();
      physicsRBDAttributes2.params.runOnSceneLoadHooks();
      return { node: physicsRBDAttributes2, children: physicsRBDAttributes2_nodes };
    }
    function create_physicsWorld1(physics2) {
      var physicsWorld1 = physics2.createNode("physicsWorld");
      physicsWorld1.setName("physicsWorld1");
      const physicsWorld1_nodes = {};
      function create_onScenePause(physicsWorld12) {
        var onScenePlayState1 = physicsWorld12.createNode("onScenePause");
        onScenePlayState1.setName("onScenePause1");
        const onScenePlayState1_nodes = {};
        onScenePlayState1.uiData.setComment(
          "This triggers resets the simulation when you pauses the scene. It is entirely optional, although it is recommended, as it provides a convenient way to reset the simulation. But this could use any other trigger."
        );
        onScenePlayState1.uiData.setPosition(-100, -200);
        onScenePlayState1.params.postCreateSpareParams();
        onScenePlayState1.params.runOnSceneLoadHooks();
        return { node: onScenePlayState1, children: onScenePlayState1_nodes };
      }
      function create_onTick1(physicsWorld12) {
        var onTick1 = physicsWorld12.createNode("onTick");
        onTick1.setName("onTick1");
        const onTick1_nodes = {};
        onTick1.uiData.setPosition(-100, 100);
        onTick1.params.postCreateSpareParams();
        onTick1.params.runOnSceneLoadHooks();
        return { node: onTick1, children: onTick1_nodes };
      }
      function create_physicsWorldReset1(physicsWorld12) {
        var physicsWorldReset1 = physicsWorld12.createNode("physicsWorldReset");
        physicsWorldReset1.setName("physicsWorldReset1");
        const physicsWorldReset1_nodes = {};
        physicsWorldReset1.uiData.setPosition(200, -200);
        physicsWorldReset1.params.postCreateSpareParams();
        physicsWorldReset1.params.runOnSceneLoadHooks();
        return { node: physicsWorldReset1, children: physicsWorldReset1_nodes };
      }
      function create_physicsWorldStepSimulation1(physicsWorld12) {
        var physicsWorldStepSimulation1 = physicsWorld12.createNode("physicsWorldStepSimulation");
        physicsWorldStepSimulation1.setName("physicsWorldStepSimulation1");
        const physicsWorldStepSimulation1_nodes = {};
        physicsWorldStepSimulation1.uiData.setComment(
          "the [physicsWorldStepSimulation](../physicsWorldStepSimulation1) is the one that performs the computation. It is currently triggered on every frame, via the [onTick](../onTick1) node "
        );
        physicsWorldStepSimulation1.uiData.setPosition(200, 100);
        physicsWorldStepSimulation1.params.postCreateSpareParams();
        physicsWorldStepSimulation1.params.runOnSceneLoadHooks();
        return { node: physicsWorldStepSimulation1, children: physicsWorldStepSimulation1_nodes };
      }
      physicsWorld1_nodes["onScenePause"] = create_onScenePause(physicsWorld1);
      physicsWorld1_nodes["onTick1"] = create_onTick1(physicsWorld1);
      physicsWorld1_nodes["physicsWorldReset1"] = create_physicsWorldReset1(physicsWorld1);
      physicsWorld1_nodes["physicsWorldStepSimulation1"] = create_physicsWorldStepSimulation1(physicsWorld1);
      physicsWorld1_nodes["physicsWorldReset1"].node.setInput(
        "trigger",
        physicsWorld1_nodes["onScenePause"].node
      );
      physicsWorld1_nodes["physicsWorldStepSimulation1"].node.setInput(
        "trigger",
        physicsWorld1_nodes["onTick1"].node,
        "trigger"
      );
      if (physicsWorld1.childrenController) {
        physicsWorld1.childrenController.selection.set([]);
      }
      physicsWorld1.uiData.setComment(
        "The nodes above only add attributes to the objects. In order to actually run the simulation, we need a [physicsWorld](../physicsWorld1) node."
      );
      physicsWorld1.uiData.setPosition(550, 2400);
      physicsWorld1.flags.display.set(true);
      physicsWorld1.p.gravity.set([0, 0, 0]);
      physicsWorld1.params.postCreateSpareParams();
      physicsWorld1.params.runOnSceneLoadHooks();
      return { node: physicsWorld1, children: physicsWorld1_nodes };
    }
    function create_sphere1(physics2) {
      var sphere1 = physics2.createNode("sphere");
      sphere1.setName("sphere1");
      const sphere1_nodes = {};
      sphere1.uiData.setPosition(-150, 500);
      sphere1.p.radius.set(0.2);
      sphere1.params.postCreateSpareParams();
      sphere1.params.runOnSceneLoadHooks();
      return { node: sphere1, children: sphere1_nodes };
    }
    function create_sphere2(physics2) {
      var sphere2 = physics2.createNode("sphere");
      sphere2.setName("sphere2");
      const sphere2_nodes = {};
      sphere2.uiData.setPosition(650, 500);
      sphere2.p.radius.set(0.7);
      sphere2.params.postCreateSpareParams();
      sphere2.params.runOnSceneLoadHooks();
      return { node: sphere2, children: sphere2_nodes };
    }
    function create_subnet_invisible_surrounding_walls(physics2) {
      var subnet_invisible_surrounding_walls = physics2.createNode("subnet");
      subnet_invisible_surrounding_walls.setName("subnet_invisible_surrounding_walls");
      const subnet_invisible_surrounding_walls_nodes = {};
      function create_merge2(subnet_invisible_surrounding_walls2) {
        var merge2 = subnet_invisible_surrounding_walls2.createNode("merge");
        merge2.setName("merge2");
        const merge2_nodes = {};
        merge2.uiData.setPosition(-500, 1550);
        merge2.flags.display.set(true);
        merge2.params.postCreateSpareParams();
        merge2.params.runOnSceneLoadHooks();
        return { node: merge2, children: merge2_nodes };
      }
      function create_merge3(subnet_invisible_surrounding_walls2) {
        var merge3 = subnet_invisible_surrounding_walls2.createNode("merge");
        merge3.setName("merge3");
        const merge3_nodes = {};
        merge3.uiData.setPosition(-200, 1550);
        merge3.params.postCreateSpareParams();
        merge3.params.runOnSceneLoadHooks();
        return { node: merge3, children: merge3_nodes };
      }
      function create_merge4(subnet_invisible_surrounding_walls2) {
        var merge4 = subnet_invisible_surrounding_walls2.createNode("merge");
        merge4.setName("merge4");
        const merge4_nodes = {};
        merge4.uiData.setPosition(-400, 1750);
        merge4.params.postCreateSpareParams();
        merge4.params.runOnSceneLoadHooks();
        return { node: merge4, children: merge4_nodes };
      }
      function create_objectProperties1(subnet_invisible_surrounding_walls2) {
        var objectProperties1 = subnet_invisible_surrounding_walls2.createNode("objectProperties");
        objectProperties1.setName("objectProperties1");
        const objectProperties1_nodes = {};
        objectProperties1.uiData.setPosition(-400, 2e3);
        objectProperties1.p.tvisible.set(true);
        objectProperties1.p.visible.set(false);
        objectProperties1.params.postCreateSpareParams();
        objectProperties1.params.runOnSceneLoadHooks();
        return { node: objectProperties1, children: objectProperties1_nodes };
      }
      function create_physicsGround1(subnet_invisible_surrounding_walls2) {
        var physicsGround1 = subnet_invisible_surrounding_walls2.createNode("physicsGround");
        physicsGround1.setName("physicsGround1");
        const physicsGround1_nodes = {};
        physicsGround1.uiData.setPosition(-600, 1100);
        physicsGround1.p.size.set([33, 33]);
        physicsGround1.p.height.set(-3);
        physicsGround1.params.postCreateSpareParams();
        physicsGround1.params.runOnSceneLoadHooks();
        return { node: physicsGround1, children: physicsGround1_nodes };
      }
      function create_physicsGround2(subnet_invisible_surrounding_walls2) {
        var physicsGround2 = subnet_invisible_surrounding_walls2.createNode("physicsGround");
        physicsGround2.setName("physicsGround2");
        const physicsGround2_nodes = {};
        physicsGround2.uiData.setPosition(-500, 1200);
        physicsGround2.p.size.set([33, 33]);
        physicsGround2.p.height.set(-3);
        physicsGround2.p.direction.set([1, 0, 0]);
        physicsGround2.params.postCreateSpareParams();
        physicsGround2.params.runOnSceneLoadHooks();
        return { node: physicsGround2, children: physicsGround2_nodes };
      }
      function create_physicsGround3(subnet_invisible_surrounding_walls2) {
        var physicsGround3 = subnet_invisible_surrounding_walls2.createNode("physicsGround");
        physicsGround3.setName("physicsGround3");
        const physicsGround3_nodes = {};
        physicsGround3.uiData.setPosition(-400, 1300);
        physicsGround3.p.size.set([33, 33]);
        physicsGround3.p.height.set(-2.8299999999999996);
        physicsGround3.p.direction.set([0, 0, 1]);
        physicsGround3.params.postCreateSpareParams();
        physicsGround3.params.runOnSceneLoadHooks();
        return { node: physicsGround3, children: physicsGround3_nodes };
      }
      function create_physicsGround4(subnet_invisible_surrounding_walls2) {
        var physicsGround4 = subnet_invisible_surrounding_walls2.createNode("physicsGround");
        physicsGround4.setName("physicsGround4");
        const physicsGround4_nodes = {};
        physicsGround4.uiData.setPosition(-250, 1100);
        physicsGround4.p.size.set([33, 33]);
        physicsGround4.p.height.set(-3);
        physicsGround4.p.direction.set([0, -1, 0]);
        physicsGround4.params.postCreateSpareParams();
        physicsGround4.params.runOnSceneLoadHooks();
        return { node: physicsGround4, children: physicsGround4_nodes };
      }
      function create_physicsGround5(subnet_invisible_surrounding_walls2) {
        var physicsGround5 = subnet_invisible_surrounding_walls2.createNode("physicsGround");
        physicsGround5.setName("physicsGround5");
        const physicsGround5_nodes = {};
        physicsGround5.uiData.setPosition(-150, 1200);
        physicsGround5.p.size.set([33, 33]);
        physicsGround5.p.height.set(-3);
        physicsGround5.p.direction.set([-1, 0, 0]);
        physicsGround5.params.postCreateSpareParams();
        physicsGround5.params.runOnSceneLoadHooks();
        return { node: physicsGround5, children: physicsGround5_nodes };
      }
      function create_physicsGround6(subnet_invisible_surrounding_walls2) {
        var physicsGround6 = subnet_invisible_surrounding_walls2.createNode("physicsGround");
        physicsGround6.setName("physicsGround6");
        const physicsGround6_nodes = {};
        physicsGround6.uiData.setPosition(-50, 1300);
        physicsGround6.p.size.set([33, 33]);
        physicsGround6.p.height.set(-2);
        physicsGround6.p.direction.set([0, 0, -1]);
        physicsGround6.params.postCreateSpareParams();
        physicsGround6.params.runOnSceneLoadHooks();
        return { node: physicsGround6, children: physicsGround6_nodes };
      }
      function create_subnetOutput1(subnet_invisible_surrounding_walls2) {
        var subnetOutput1 = subnet_invisible_surrounding_walls2.createNode("subnetOutput");
        subnetOutput1.setName("subnetOutput1");
        const subnetOutput1_nodes = {};
        subnetOutput1.uiData.setPosition(-400, 2200);
        subnetOutput1.params.postCreateSpareParams();
        subnetOutput1.params.runOnSceneLoadHooks();
        return { node: subnetOutput1, children: subnetOutput1_nodes };
      }
      subnet_invisible_surrounding_walls_nodes["merge2"] = create_merge2(subnet_invisible_surrounding_walls);
      subnet_invisible_surrounding_walls_nodes["merge3"] = create_merge3(subnet_invisible_surrounding_walls);
      subnet_invisible_surrounding_walls_nodes["merge4"] = create_merge4(subnet_invisible_surrounding_walls);
      subnet_invisible_surrounding_walls_nodes["objectProperties1"] = create_objectProperties1(
        subnet_invisible_surrounding_walls
      );
      subnet_invisible_surrounding_walls_nodes["physicsGround1"] = create_physicsGround1(
        subnet_invisible_surrounding_walls
      );
      subnet_invisible_surrounding_walls_nodes["physicsGround2"] = create_physicsGround2(
        subnet_invisible_surrounding_walls
      );
      subnet_invisible_surrounding_walls_nodes["physicsGround3"] = create_physicsGround3(
        subnet_invisible_surrounding_walls
      );
      subnet_invisible_surrounding_walls_nodes["physicsGround4"] = create_physicsGround4(
        subnet_invisible_surrounding_walls
      );
      subnet_invisible_surrounding_walls_nodes["physicsGround5"] = create_physicsGround5(
        subnet_invisible_surrounding_walls
      );
      subnet_invisible_surrounding_walls_nodes["physicsGround6"] = create_physicsGround6(
        subnet_invisible_surrounding_walls
      );
      subnet_invisible_surrounding_walls_nodes["subnetOutput1"] = create_subnetOutput1(
        subnet_invisible_surrounding_walls
      );
      subnet_invisible_surrounding_walls_nodes["merge2"].node.setInput(
        0,
        subnet_invisible_surrounding_walls_nodes["physicsGround1"].node
      );
      subnet_invisible_surrounding_walls_nodes["merge2"].node.setInput(
        1,
        subnet_invisible_surrounding_walls_nodes["physicsGround2"].node
      );
      subnet_invisible_surrounding_walls_nodes["merge2"].node.setInput(
        2,
        subnet_invisible_surrounding_walls_nodes["physicsGround3"].node
      );
      subnet_invisible_surrounding_walls_nodes["merge3"].node.setInput(
        0,
        subnet_invisible_surrounding_walls_nodes["physicsGround4"].node
      );
      subnet_invisible_surrounding_walls_nodes["merge3"].node.setInput(
        1,
        subnet_invisible_surrounding_walls_nodes["physicsGround5"].node
      );
      subnet_invisible_surrounding_walls_nodes["merge3"].node.setInput(
        2,
        subnet_invisible_surrounding_walls_nodes["physicsGround6"].node
      );
      subnet_invisible_surrounding_walls_nodes["merge4"].node.setInput(
        0,
        subnet_invisible_surrounding_walls_nodes["merge2"].node
      );
      subnet_invisible_surrounding_walls_nodes["merge4"].node.setInput(
        1,
        subnet_invisible_surrounding_walls_nodes["merge3"].node
      );
      subnet_invisible_surrounding_walls_nodes["objectProperties1"].node.setInput(
        0,
        subnet_invisible_surrounding_walls_nodes["merge4"].node
      );
      subnet_invisible_surrounding_walls_nodes["subnetOutput1"].node.setInput(
        0,
        subnet_invisible_surrounding_walls_nodes["objectProperties1"].node
      );
      if (subnet_invisible_surrounding_walls.childrenController) {
        subnet_invisible_surrounding_walls.childrenController.selection.set([]);
      }
      subnet_invisible_surrounding_walls.uiData.setComment(
        "Inside [this node](.) we create 6 invisible walls around the simulation, just to help contain the spheres in case they wanted to venture off."
      );
      subnet_invisible_surrounding_walls.uiData.setPosition(1150, 1950);
      subnet_invisible_surrounding_walls.params.postCreateSpareParams();
      subnet_invisible_surrounding_walls.params.runOnSceneLoadHooks();
      return { node: subnet_invisible_surrounding_walls, children: subnet_invisible_surrounding_walls_nodes };
    }
    function create_transform1(physics2) {
      var transform1 = physics2.createNode("transform");
      transform1.setName("transform1");
      const transform1_nodes = {};
      transform1.uiData.setPosition(650, 650);
      transform1.p.applyOn.set(1);
      transform1.p.t.set([3.739154109331188, 0, 0]);
      transform1.params.postCreateSpareParams();
      transform1.params.runOnSceneLoadHooks();
      return { node: transform1, children: transform1_nodes };
    }
    physics_nodes["MAT"] = create_MAT(physics);
    physics_nodes["actor1"] = create_actor1(physics);
    physics_nodes["actor2"] = create_actor2(physics);
    physics_nodes["copy2"] = create_copy2(physics);
    physics_nodes["delete2"] = create_delete2(physics);
    physics_nodes["fuse1"] = create_fuse1(physics);
    physics_nodes["icosahedron1"] = create_icosahedron1(physics);
    physics_nodes["material1"] = create_material1(physics);
    physics_nodes["material2"] = create_material2(physics);
    physics_nodes["merge1"] = create_merge1(physics);
    physics_nodes["physicsRBDAttributes1"] = create_physicsRBDAttributes1(physics);
    physics_nodes["physicsRBDAttributes2"] = create_physicsRBDAttributes2(physics);
    physics_nodes["physicsWorld1"] = create_physicsWorld1(physics);
    physics_nodes["sphere1"] = create_sphere1(physics);
    physics_nodes["sphere2"] = create_sphere2(physics);
    physics_nodes["subnet_invisible_surrounding_walls"] = create_subnet_invisible_surrounding_walls(physics);
    physics_nodes["transform1"] = create_transform1(physics);
    physics_nodes["actor1"].node.setInput(0, physics_nodes["physicsRBDAttributes2"].node);
    physics_nodes["actor2"].node.setInput(0, physics_nodes["physicsRBDAttributes1"].node);
    physics_nodes["copy2"].node.setInput(0, physics_nodes["sphere1"].node);
    physics_nodes["copy2"].node.setInput(1, physics_nodes["fuse1"].node);
    physics_nodes["delete2"].node.setInput(0, physics_nodes["icosahedron1"].node);
    physics_nodes["fuse1"].node.setInput(0, physics_nodes["delete2"].node);
    physics_nodes["material1"].node.setInput(0, physics_nodes["copy2"].node);
    physics_nodes["material2"].node.setInput(0, physics_nodes["transform1"].node);
    physics_nodes["merge1"].node.setInput(0, physics_nodes["actor2"].node);
    physics_nodes["merge1"].node.setInput(1, physics_nodes["actor1"].node);
    physics_nodes["merge1"].node.setInput(2, physics_nodes["subnet_invisible_surrounding_walls"].node);
    physics_nodes["physicsRBDAttributes1"].node.setInput(0, physics_nodes["material1"].node);
    physics_nodes["physicsRBDAttributes2"].node.setInput(0, physics_nodes["material2"].node);
    physics_nodes["physicsWorld1"].node.setInput(0, physics_nodes["merge1"].node);
    physics_nodes["transform1"].node.setInput(0, physics_nodes["sphere2"].node);
    if (physics.childrenController) {
      physics.childrenController.selection.set([]);
    }
    physics.uiData.setComment(
      "The main setup of this scene is inside [this node](.). This is where place the objects, assign them attributes to make them react to physics, and also react to the cursor."
    );
    physics.uiData.setPosition(-50, 150);
    physics.flags.display.set(true);
    physics.params.postCreateSpareParams();
    physics.params.runOnSceneLoadHooks();
    return { node: physics, children: physics_nodes };
  }
  function create_cameras(parentNode) {
    var cameras = parentNode.createNode("geo");
    cameras.setName("cameras");
    const cameras_nodes = {};
    function create_cameraControls1(cameras2) {
      var cameraControls1 = cameras2.createNode("cameraControls");
      cameraControls1.setName("cameraControls1");
      const cameraControls1_nodes = {};
      function create_cameraOrbitControls1(cameraControls12) {
        var cameraOrbitControls1 = cameraControls12.createNode("cameraOrbitControls");
        cameraOrbitControls1.setName("cameraOrbitControls1");
        const cameraOrbitControls1_nodes = {};
        cameraOrbitControls1.uiData.setPosition(0, 0);
        cameraOrbitControls1.p.target.set([-3.2424184059817387, -1.6210306056441959, -4.695096947332057]);
        cameraOrbitControls1.params.postCreateSpareParams();
        cameraOrbitControls1.params.runOnSceneLoadHooks();
        return { node: cameraOrbitControls1, children: cameraOrbitControls1_nodes };
      }
      cameraControls1_nodes["cameraOrbitControls1"] = create_cameraOrbitControls1(cameraControls1);
      if (cameraControls1.childrenController) {
        cameraControls1.childrenController.selection.set([]);
      }
      cameraControls1.uiData.setPosition(-50, 100);
      cameraControls1.p.node.set("cameraOrbitControls1");
      cameraControls1.params.postCreateSpareParams();
      cameraControls1.params.runOnSceneLoadHooks();
      return { node: cameraControls1, children: cameraControls1_nodes };
    }
    function create_merge1(cameras2) {
      var merge1 = cameras2.createNode("merge");
      merge1.setName("merge1");
      const merge1_nodes = {};
      merge1.uiData.setPosition(-200, 300);
      merge1.flags.display.set(true);
      merge1.params.postCreateSpareParams();
      merge1.params.runOnSceneLoadHooks();
      return { node: merge1, children: merge1_nodes };
    }
    function create_perspectiveCamera_DEBUG(cameras2) {
      var perspectiveCamera_DEBUG = cameras2.createNode("perspectiveCamera");
      perspectiveCamera_DEBUG.setName("perspectiveCamera_DEBUG");
      const perspectiveCamera_DEBUG_nodes = {};
      perspectiveCamera_DEBUG.uiData.setPosition(-50, -100);
      perspectiveCamera_DEBUG.p.position.set([3.876943030706078, 1.9641684720483148, 3.7559781706499917]);
      perspectiveCamera_DEBUG.p.rotation.set([-22.975240843456817, 37.7927840483117, 14.563959680327253]);
      perspectiveCamera_DEBUG.params.postCreateSpareParams();
      perspectiveCamera_DEBUG.params.runOnSceneLoadHooks();
      return { node: perspectiveCamera_DEBUG, children: perspectiveCamera_DEBUG_nodes };
    }
    function create_perspectiveCamera_MAIN(cameras2) {
      var perspectiveCamera_MAIN = cameras2.createNode("perspectiveCamera");
      perspectiveCamera_MAIN.setName("perspectiveCamera_MAIN");
      const perspectiveCamera_MAIN_nodes = {};
      perspectiveCamera_MAIN.uiData.setComment(
        "This is our main camera. Unlike the debug camera on the right, it doesn't have controls assigned to it. So this camera will be static, but it is fine as the focus of this scene is the physics, which should be fun enough.\n\nBUT... it is still recommended to switch to a camera you can move when building the scene. So use the dropdown above the viewer to switch to the DEBUG camera."
      );
      perspectiveCamera_MAIN.uiData.setPosition(-550, -100);
      perspectiveCamera_MAIN.p.far.set(10);
      perspectiveCamera_MAIN.p.position.set([0, 0.4, 6]);
      perspectiveCamera_MAIN.p.rotation.set([-3.8, 0, 0]);
      perspectiveCamera_MAIN.params.postCreateSpareParams();
      perspectiveCamera_MAIN.params.runOnSceneLoadHooks();
      return { node: perspectiveCamera_MAIN, children: perspectiveCamera_MAIN_nodes };
    }
    cameras_nodes["cameraControls1"] = create_cameraControls1(cameras);
    cameras_nodes["merge1"] = create_merge1(cameras);
    cameras_nodes["perspectiveCamera_DEBUG"] = create_perspectiveCamera_DEBUG(cameras);
    cameras_nodes["perspectiveCamera_MAIN"] = create_perspectiveCamera_MAIN(cameras);
    cameras_nodes["cameraControls1"].node.setInput(0, cameras_nodes["perspectiveCamera_DEBUG"].node);
    cameras_nodes["merge1"].node.setInput(0, cameras_nodes["perspectiveCamera_MAIN"].node);
    cameras_nodes["merge1"].node.setInput(1, cameras_nodes["cameraControls1"].node);
    if (cameras.childrenController) {
      cameras.childrenController.selection.set([cameras_nodes["perspectiveCamera_DEBUG"].node]);
    }
    cameras.uiData.setComment(
      "The cameras are created inside [this node](.). It's a standard setup, but you can always check inside if you are not familiar with cameras."
    );
    cameras.uiData.setPosition(-50, -200);
    cameras.flags.display.set(true);
    cameras.params.postCreateSpareParams();
    cameras.params.runOnSceneLoadHooks();
    return { node: cameras, children: cameras_nodes };
  }
  function create_bgPlane(parentNode) {
    var bgPlane = parentNode.createNode("geo");
    bgPlane.setName("bgPlane");
    const bgPlane_nodes = {};
    function create_MAT(bgPlane2) {
      var MAT = bgPlane2.createNode("materialsNetwork");
      MAT.setName("MAT");
      const MAT_nodes = {};
      function create_meshStandardBuilder1(MAT2) {
        var meshStandardBuilder1 = MAT2.createNode("meshStandardBuilder");
        meshStandardBuilder1.setName("meshStandardBuilder1");
        const meshStandardBuilder1_nodes = {};
        function create_SDFSphere1(meshStandardBuilder12) {
          var SDFSphere1 = meshStandardBuilder12.createNode("SDFSphere");
          SDFSphere1.setName("SDFSphere1");
          const SDFSphere1_nodes = {};
          SDFSphere1.uiData.setPosition(-350, 250);
          SDFSphere1.p.radius.set(0);
          SDFSphere1.params.postCreateSpareParams();
          SDFSphere1.params.runOnSceneLoadHooks();
          return { node: SDFSphere1, children: SDFSphere1_nodes };
        }
        function create_constant1(meshStandardBuilder12) {
          var constant1 = meshStandardBuilder12.createNode("constant");
          constant1.setName("constant1");
          const constant1_nodes = {};
          constant1.uiData.setPosition(-300, -150);
          constant1.p.type.set(4);
          constant1.p.color.set([0.8823529411764706, 0.09803921568627451, 0.09803921568627451]);
          constant1.p.asColor.set(true);
          constant1.params.postCreateSpareParams();
          constant1.params.runOnSceneLoadHooks();
          return { node: constant1, children: constant1_nodes };
        }
        function create_constant2(meshStandardBuilder12) {
          var constant2 = meshStandardBuilder12.createNode("constant");
          constant2.setName("constant2");
          const constant2_nodes = {};
          constant2.uiData.setPosition(-300, 50);
          constant2.p.type.set(4);
          constant2.p.color.set([0.9882352941176471, 0.9882352941176471, 0.9882352941176471]);
          constant2.p.asColor.set(true);
          constant2.params.postCreateSpareParams();
          constant2.params.runOnSceneLoadHooks();
          return { node: constant2, children: constant2_nodes };
        }
        function create_globals2(meshStandardBuilder12) {
          var globals2 = meshStandardBuilder12.createNode("globals");
          globals2.setName("globals2");
          const globals2_nodes = {};
          globals2.uiData.setPosition(-550, 250);
          globals2.params.postCreateSpareParams();
          globals2.params.runOnSceneLoadHooks();
          return { node: globals2, children: globals2_nodes };
        }
        function create_mix1(meshStandardBuilder12) {
          var mix1 = meshStandardBuilder12.createNode("mix");
          mix1.setName("mix1");
          const mix1_nodes = {};
          mix1.uiData.setPosition(-50, 50);
          mix1.addParam(_polygonjs_polygonjs_src_engine_poly_ParamType__WEBPACK_IMPORTED_MODULE_0__/* .ParamType.VECTOR3 */ ._.VECTOR3, "value0", [0, 0, 0], { spare: true, editable: false });
          mix1.addParam(_polygonjs_polygonjs_src_engine_poly_ParamType__WEBPACK_IMPORTED_MODULE_0__/* .ParamType.VECTOR3 */ ._.VECTOR3, "value1", [0, 0, 0], { spare: true, editable: false });
          mix1.addParam(_polygonjs_polygonjs_src_engine_poly_ParamType__WEBPACK_IMPORTED_MODULE_0__/* .ParamType.FLOAT */ ._.FLOAT, "blend", 0.5, { spare: true, editable: false });
          mix1.params.get("blend").set(0.79);
          mix1.params.postCreateSpareParams();
          mix1.params.runOnSceneLoadHooks();
          return { node: mix1, children: mix1_nodes };
        }
        function create_output1(meshStandardBuilder12) {
          var output1 = meshStandardBuilder12.createNode("output");
          output1.setName("output1");
          const output1_nodes = {};
          output1.uiData.setPosition(300, 0);
          output1.params.postCreateSpareParams();
          output1.params.runOnSceneLoadHooks();
          return { node: output1, children: output1_nodes };
        }
        function create_smoothstep1(meshStandardBuilder12) {
          var smoothstep1 = meshStandardBuilder12.createNode("smoothstep");
          smoothstep1.setName("smoothstep1");
          const smoothstep1_nodes = {};
          smoothstep1.uiData.setPosition(-150, 250);
          smoothstep1.addParam(_polygonjs_polygonjs_src_engine_poly_ParamType__WEBPACK_IMPORTED_MODULE_0__/* .ParamType.FLOAT */ ._.FLOAT, "edge0", 0, { spare: true, editable: true });
          smoothstep1.params.get("edge0").set(0.047);
          smoothstep1.addParam(_polygonjs_polygonjs_src_engine_poly_ParamType__WEBPACK_IMPORTED_MODULE_0__/* .ParamType.FLOAT */ ._.FLOAT, "edge1", 1, { spare: true, editable: true });
          smoothstep1.params.get("edge1").set(0.05);
          smoothstep1.addParam(_polygonjs_polygonjs_src_engine_poly_ParamType__WEBPACK_IMPORTED_MODULE_0__/* .ParamType.FLOAT */ ._.FLOAT, "x", 0, { spare: true, editable: false });
          smoothstep1.params.postCreateSpareParams();
          smoothstep1.params.runOnSceneLoadHooks();
          return { node: smoothstep1, children: smoothstep1_nodes };
        }
        meshStandardBuilder1_nodes["SDFSphere1"] = create_SDFSphere1(meshStandardBuilder1);
        meshStandardBuilder1_nodes["constant1"] = create_constant1(meshStandardBuilder1);
        meshStandardBuilder1_nodes["constant2"] = create_constant2(meshStandardBuilder1);
        meshStandardBuilder1_nodes["globals2"] = create_globals2(meshStandardBuilder1);
        meshStandardBuilder1_nodes["mix1"] = create_mix1(meshStandardBuilder1);
        meshStandardBuilder1_nodes["output1"] = create_output1(meshStandardBuilder1);
        meshStandardBuilder1_nodes["smoothstep1"] = create_smoothstep1(meshStandardBuilder1);
        meshStandardBuilder1_nodes["SDFSphere1"].node.setInput(
          "position",
          meshStandardBuilder1_nodes["globals2"].node,
          "position"
        );
        meshStandardBuilder1_nodes["mix1"].node.setInput(
          "value0",
          meshStandardBuilder1_nodes["constant1"].node,
          "val"
        );
        meshStandardBuilder1_nodes["mix1"].node.setInput(
          "value1",
          meshStandardBuilder1_nodes["constant2"].node,
          "val"
        );
        meshStandardBuilder1_nodes["mix1"].node.setInput(
          "blend",
          meshStandardBuilder1_nodes["smoothstep1"].node,
          "val"
        );
        meshStandardBuilder1_nodes["output1"].node.setInput(
          "color",
          meshStandardBuilder1_nodes["mix1"].node,
          "mix"
        );
        meshStandardBuilder1_nodes["smoothstep1"].node.setInput(
          "x",
          meshStandardBuilder1_nodes["SDFSphere1"].node,
          "float"
        );
        if (meshStandardBuilder1.childrenController) {
          meshStandardBuilder1.childrenController.selection.set([]);
        }
        meshStandardBuilder1.uiData.setPosition(0, 50);
        meshStandardBuilder1.params.postCreateSpareParams();
        meshStandardBuilder1.params.runOnSceneLoadHooks();
        return { node: meshStandardBuilder1, children: meshStandardBuilder1_nodes };
      }
      MAT_nodes["meshStandardBuilder1"] = create_meshStandardBuilder1(MAT);
      if (MAT.childrenController) {
        MAT.childrenController.selection.set([]);
      }
      MAT.uiData.setPosition(-200, 200);
      MAT.params.postCreateSpareParams();
      MAT.params.runOnSceneLoadHooks();
      return { node: MAT, children: MAT_nodes };
    }
    function create_material1(bgPlane2) {
      var material1 = bgPlane2.createNode("material");
      material1.setName("material1");
      const material1_nodes = {};
      material1.uiData.setPosition(0, 250);
      material1.flags.display.set(true);
      material1.p.material.set("../MAT/meshStandardBuilder1");
      material1.params.postCreateSpareParams();
      material1.params.runOnSceneLoadHooks();
      return { node: material1, children: material1_nodes };
    }
    function create_plane1(bgPlane2) {
      var plane1 = bgPlane2.createNode("plane");
      plane1.setName("plane1");
      const plane1_nodes = {};
      plane1.uiData.setPosition(0, -50);
      plane1.p.direction.set([0, 0, 1]);
      plane1.params.postCreateSpareParams();
      plane1.params.runOnSceneLoadHooks();
      return { node: plane1, children: plane1_nodes };
    }
    function create_transform1(bgPlane2) {
      var transform1 = bgPlane2.createNode("transform");
      transform1.setName("transform1");
      const transform1_nodes = {};
      transform1.uiData.setPosition(0, 100);
      transform1.p.applyOn.set(1);
      transform1.p.t.set([0, 0, -2.8365996807611484]);
      transform1.p.scale.set(41);
      transform1.params.postCreateSpareParams();
      transform1.params.runOnSceneLoadHooks();
      return { node: transform1, children: transform1_nodes };
    }
    bgPlane_nodes["MAT"] = create_MAT(bgPlane);
    bgPlane_nodes["material1"] = create_material1(bgPlane);
    bgPlane_nodes["plane1"] = create_plane1(bgPlane);
    bgPlane_nodes["transform1"] = create_transform1(bgPlane);
    bgPlane_nodes["material1"].node.setInput(0, bgPlane_nodes["transform1"].node);
    bgPlane_nodes["transform1"].node.setInput(0, bgPlane_nodes["plane1"].node);
    if (bgPlane.childrenController) {
      bgPlane.childrenController.selection.set([]);
    }
    bgPlane.uiData.setComment(
      "This is a simple plane with a procedural texture material giving it a disk. You can [dive inside](.) to see how it is made."
    );
    bgPlane.uiData.setPosition(-50, -400);
    bgPlane.flags.display.set(true);
    bgPlane.params.postCreateSpareParams();
    bgPlane.params.runOnSceneLoadHooks();
    return { node: bgPlane, children: bgPlane_nodes };
  }
  scene_root_nodes["lights"] = create_lights(root);
  scene_root_nodes["physics"] = create_physics(root);
  scene_root_nodes["cameras"] = create_cameras(root);
  scene_root_nodes["bgPlane"] = create_bgPlane(root);
  scene.setFrame(0);
  scene.play();
  return {
    scene,
    cameraPath: "/cameras/cameras:sopGroup/perspectiveCamera_MAIN",
    focusedNodes: [],
    // no node is focused here, so that we don't have the transform gizmo appearing
    autoLayout: false
  };
}


/***/ })

}])
//# sourceMappingURL=src_engine_examples_examples_physics_PhysicsRBDAttractorCursor_ts.212cb1a7d99a4d104082.js.map