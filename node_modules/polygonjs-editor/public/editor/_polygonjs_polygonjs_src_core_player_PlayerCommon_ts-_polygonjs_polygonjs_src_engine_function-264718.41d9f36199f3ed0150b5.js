(self["webpackChunk"] = self["webpackChunk"] || []).push([["_polygonjs_polygonjs_src_core_player_PlayerCommon_ts-_polygonjs_polygonjs_src_engine_function-264718"],{

/***/ 45824:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "i": function() { return /* binding */ CorePolarTransform; }
/* harmony export */ });
/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(21410);


const POLAR_TRANSFORM_AXIS_VERTICAL = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3(0, 1, 0);
const POLAR_TRANSFORM_AXIS_HORIZONTAL = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3(-1, 0, 0);
const centerMatrix = new three__WEBPACK_IMPORTED_MODULE_0__.Matrix4();
const longitudeMatrix = new three__WEBPACK_IMPORTED_MODULE_0__.Matrix4();
const latitudeMatrix = new three__WEBPACK_IMPORTED_MODULE_0__.Matrix4();
const depthMatrix = new three__WEBPACK_IMPORTED_MODULE_0__.Matrix4();
const decomposed = {
  t: new three__WEBPACK_IMPORTED_MODULE_0__.Vector3(),
  q: new three__WEBPACK_IMPORTED_MODULE_0__.Quaternion(),
  s: new three__WEBPACK_IMPORTED_MODULE_0__.Vector3()
};
class CorePolarTransform {
  static matrix(params, target) {
    centerMatrix.identity();
    longitudeMatrix.identity();
    latitudeMatrix.identity();
    depthMatrix.identity();
    centerMatrix.makeTranslation(params.center.x, params.center.y, params.center.z);
    longitudeMatrix.makeRotationAxis(POLAR_TRANSFORM_AXIS_VERTICAL, three__WEBPACK_IMPORTED_MODULE_0__.MathUtils.degToRad(params.longitude));
    latitudeMatrix.makeRotationAxis(POLAR_TRANSFORM_AXIS_HORIZONTAL, three__WEBPACK_IMPORTED_MODULE_0__.MathUtils.degToRad(params.latitude));
    depthMatrix.makeTranslation(0, 0, params.depth);
    target.copy(centerMatrix).multiply(longitudeMatrix).multiply(latitudeMatrix).multiply(depthMatrix);
  }
  static applyMatrixToObject(object, matrix) {
    matrix.decompose(decomposed.t, decomposed.q, decomposed.s);
    object.position.copy(decomposed.t);
    object.quaternion.copy(decomposed.q);
    object.scale.copy(decomposed.s);
    object.updateMatrix();
  }
}


/***/ }),

/***/ 46833:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "$o": function() { return /* binding */ ANIMATION_POSITION_MODES; },
/* harmony export */   "BT": function() { return /* binding */ AnimationPositionRelativeTo; },
/* harmony export */   "gY": function() { return /* binding */ ANIMATION_POSITION_RELATIVE_TOS; },
/* harmony export */   "j1": function() { return /* binding */ AnimationPositionMode; },
/* harmony export */   "wM": function() { return /* binding */ AnimationPosition; }
/* harmony export */ });
/* harmony import */ var _engine_poly_Assert__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(68239);


var AnimationPositionMode = /* @__PURE__ */ ((AnimationPositionMode2) => {
  AnimationPositionMode2["RELATIVE"] = "relative";
  AnimationPositionMode2["ABSOLUTE"] = "absolute";
  return AnimationPositionMode2;
})(AnimationPositionMode || {});
const ANIMATION_POSITION_MODES = ["relative" /* RELATIVE */, "absolute" /* ABSOLUTE */];
var AnimationPositionRelativeTo = /* @__PURE__ */ ((AnimationPositionRelativeTo2) => {
  AnimationPositionRelativeTo2["START"] = "start";
  AnimationPositionRelativeTo2["END"] = "end";
  return AnimationPositionRelativeTo2;
})(AnimationPositionRelativeTo || {});
const ANIMATION_POSITION_RELATIVE_TOS = [
  "start" /* START */,
  "end" /* END */
];
class AnimationPosition {
  constructor() {
    this._mode = "relative" /* RELATIVE */;
    this._relativeTo = "end" /* END */;
    this._offset = 0;
  }
  clone() {
    const new_position = new AnimationPosition();
    new_position.setMode(this._mode);
    new_position.setRelativeTo(this._relativeTo);
    new_position.setOffset(this._offset);
    return new_position;
  }
  setMode(mode) {
    this._mode = mode;
  }
  mode() {
    return this._mode;
  }
  setRelativeTo(relative_to) {
    this._relativeTo = relative_to;
  }
  relativeTo() {
    return this._relativeTo;
  }
  setOffset(offset) {
    this._offset = offset;
  }
  offset() {
    return this._offset;
  }
  toParameter() {
    switch (this._mode) {
      case "relative" /* RELATIVE */:
        return this._relative_position_param();
      case "absolute" /* ABSOLUTE */:
        return this._absolutePositionParam();
    }
    _engine_poly_Assert__WEBPACK_IMPORTED_MODULE_0__/* .TypeAssert.unreachable */ .f.unreachable(this._mode);
  }
  _relative_position_param() {
    switch (this._relativeTo) {
      case "end" /* END */:
        return this._offsetString();
      case "start" /* START */:
        return `<${this._offset}`;
    }
    _engine_poly_Assert__WEBPACK_IMPORTED_MODULE_0__/* .TypeAssert.unreachable */ .f.unreachable(this._relativeTo);
  }
  _absolutePositionParam() {
    return this._offset;
  }
  _offsetString() {
    if (this._offset > 0) {
      return `+=${this._offset}`;
    } else {
      return `-=${Math.abs(this._offset)}`;
    }
  }
}


/***/ }),

/***/ 42450:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "F": function() { return /* binding */ AnimPropertyTarget; }
/* harmony export */ });

class AnimPropertyTarget {
  constructor(_scene, _options) {
    this._scene = _scene;
    this._options = _options;
  }
  clone() {
    return new AnimPropertyTarget(this._scene, this._options);
  }
  objects() {
    const objectData = this._options.object;
    if (!objectData) {
      return;
    }
    if (objectData.list) {
      return objectData.list;
    }
    const mask = objectData.mask;
    if (!mask) {
      return;
    }
    return this._scene.objectsByMask(mask);
  }
  node() {
    if (!this._options.node) {
      return;
    }
    const options = this._options.node;
    return options.relativeTo.node(options.path);
  }
}


/***/ }),

/***/ 71506:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "e": function() { return /* binding */ AudioController; }
/* harmony export */ });
/* unused harmony export AudioControllerClass */
/* harmony import */ var tone_build_esm_core_Global__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(90391);

var __async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};

class AudioControllerClass {
  constructor() {
    this._started = false;
  }
  static instance() {
    return this._instance = this._instance || new AudioControllerClass();
  }
  start() {
    return __async(this, null, function* () {
      if (this._started) {
        return;
      }
      yield (0,tone_build_esm_core_Global__WEBPACK_IMPORTED_MODULE_0__/* .start */ .BL)();
      return;
    });
  }
}
const AudioController = AudioControllerClass.instance();


/***/ }),

/***/ 83315:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "o": function() { return /* binding */ NotesBuilder; }
/* harmony export */ });

class NotesBuilder {
  static list(startOctave, endOctave) {
    let noteIndex = 0;
    const noteHolders = [];
    for (let octave = startOctave; octave <= endOctave; octave++) {
      while (noteIndex < this.ALL_NOTES.length) {
        const currentNote = this.ALL_NOTES[noteIndex];
        const newNote = currentNote + octave;
        noteHolders.push({ note: newNote, octave });
        if (currentNote !== "B" && currentNote !== "E") {
          const blackNote = currentNote + "#" + octave;
          noteHolders.push({ note: blackNote, octave });
        }
        if (octave === endOctave && currentNote === "B")
          break;
        noteIndex++;
      }
      noteIndex = 0;
    }
    return noteHolders;
  }
}
NotesBuilder.ALL_NOTES = ["C", "D", "E", "F", "G", "A", "B"];


/***/ }),

/***/ 45678:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "X6": function() { return /* binding */ CUBE_CAMERA_DEFAULT; },
/* harmony export */   "mv": function() { return /* binding */ registerCubeCamera; }
/* harmony export */ });
/* unused harmony export CubeCameraParamConfigMixin */


const CUBE_CAMERA_DEFAULT = {
  resolution: 1024,
  resolutionRange: [8, 2048]
};
function CubeCameraParamConfigMixin(Base) {
  return class Mixin extends Base {
    constructor() {
      super(...arguments);
      /** @param resolution */
      this.resolution = ParamConfig.FLOAT(CUBE_CAMERA_DEFAULT.resolution, { range: CUBE_CAMERA_DEFAULT.resolutionRange });
    }
  };
}
const registerCubeCamera = (poly) => {
};


/***/ }),

/***/ 52733:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "u": function() { return /* binding */ PrettierController; }
/* harmony export */ });
/* harmony import */ var prettier_standalone__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(59141);
/* harmony import */ var prettier_standalone__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(prettier_standalone__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var prettier_parser_babel__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(26112);
/* harmony import */ var prettier_parser_babel__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(prettier_parser_babel__WEBPACK_IMPORTED_MODULE_1__);



class PrettierController {
  static formatJs(JSContent) {
    try {
      return prettier_standalone__WEBPACK_IMPORTED_MODULE_0___default().format(JSContent, {
        parser: "babel",
        plugins: [(prettier_parser_babel__WEBPACK_IMPORTED_MODULE_1___default())],
        printWidth: 120,
        useTabs: true
      });
    } catch (err) {
      console.log(err);
      return JSContent;
    }
  }
}


/***/ }),

/***/ 89151:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Ct": function() { return /* binding */ PALETTES_BY_NAME; },
/* harmony export */   "JT": function() { return /* binding */ MAX_PALETTE_COLORS_COUNT; },
/* harmony export */   "QK": function() { return /* binding */ SORTED_PALETTE_NAMES; },
/* harmony export */   "i2": function() { return /* binding */ visibleIfColorsCountAtLeast; }
/* harmony export */ });
/* unused harmony export ALL_PALETTES */
/* harmony import */ var chromotome__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(3199);
/* harmony import */ var chromotome__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(chromotome__WEBPACK_IMPORTED_MODULE_0__);


const ALL_PALETTES = (0,chromotome__WEBPACK_IMPORTED_MODULE_0__.getAll)();
const PALETTES_BY_NAME = /* @__PURE__ */ new Map();
const USED_PALETTES = [];
let MAX_PALETTE_COLORS_COUNT = 0;
const minColorsAllowed = 3;
const maxColorsAllowed = 5;
for (const palette of ALL_PALETTES) {
  const colorsCount = palette.colors.length;
  if (colorsCount >= minColorsAllowed && colorsCount <= maxColorsAllowed) {
    PALETTES_BY_NAME.set(palette.name, palette);
    USED_PALETTES.push(palette);
    if (MAX_PALETTE_COLORS_COUNT < colorsCount) {
      MAX_PALETTE_COLORS_COUNT = colorsCount;
    }
  }
}
const SORTED_PALETTE_NAMES = USED_PALETTES.map((p) => p.name).sort();
function visibleIfColorsCountAtLeast(minVal) {
  const options = [];
  for (let i = minVal; i <= MAX_PALETTE_COLORS_COUNT; i++) {
    options.push({ colorsCount: i });
  }
  return options;
}


/***/ }),

/***/ 26078:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "A": function() { return /* binding */ SphereBuilder; }
/* harmony export */ });
/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(21410);


class SphereBuilder {
  static create(parameters) {
    const geometry = new three__WEBPACK_IMPORTED_MODULE_0__.BufferGeometry();
    geometry.type = "SphereBuilder";
    let { radius, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength, asLines, open } = parameters;
    if (phiStart == null) {
      phiStart = 0;
    }
    if (phiLength == null) {
      phiLength = Math.PI * 2;
    }
    if (thetaStart == null) {
      thetaStart = 0;
    }
    if (thetaLength == null) {
      thetaLength = Math.PI;
    }
    if (open == null) {
      open = false;
    }
    widthSegments = Math.max(3, Math.floor(widthSegments));
    heightSegments = Math.max(2, Math.floor(heightSegments));
    const thetaEnd = Math.min(thetaStart + thetaLength, Math.PI);
    let index = 0;
    const grid = [];
    const vertex = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();
    const normal = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();
    const indices = [];
    const vertices = [];
    const normals = [];
    const uvs = [];
    for (let iy = 0; iy <= heightSegments; iy++) {
      const verticesRow = [];
      const v = iy / heightSegments;
      let uOffset = 0;
      if (iy == 0 && thetaStart == 0) {
        uOffset = 0.5 / widthSegments;
      } else if (iy == heightSegments && thetaEnd == Math.PI) {
        uOffset = -0.5 / widthSegments;
      }
      for (let ix = 0; ix <= widthSegments; ix++) {
        const u = ix / widthSegments;
        vertex.x = -radius * Math.cos(phiStart + u * phiLength) * Math.sin(thetaStart + v * thetaLength);
        vertex.y = radius * Math.cos(thetaStart + v * thetaLength);
        vertex.z = radius * Math.sin(phiStart + u * phiLength) * Math.sin(thetaStart + v * thetaLength);
        vertices.push(vertex.x, vertex.y, vertex.z);
        normal.copy(vertex).normalize();
        normals.push(normal.x, normal.y, normal.z);
        uvs.push(u + uOffset, 1 - v);
        verticesRow.push(index++);
      }
      grid.push(verticesRow);
    }
    for (let iy = 0; iy < heightSegments; iy++) {
      for (let ix = 0; ix < widthSegments; ix++) {
        const a = grid[iy][ix + 1];
        const b = grid[iy][ix];
        const c = grid[iy + 1][ix];
        const d = grid[iy + 1][ix + 1];
        if (asLines) {
          if (iy !== 0 || thetaStart > 0)
            indices.push(a, b);
          indices.push(b, c);
          if (open) {
            if (ix < widthSegments - 1) {
              indices.push(c, d);
            }
            if (iy < heightSegments - 1) {
              indices.push(a, d);
            }
          }
        } else {
          if (iy !== 0 || thetaStart > 0)
            indices.push(a, b, d);
          if (iy !== heightSegments - 1 || thetaEnd < Math.PI)
            indices.push(b, c, d);
        }
      }
    }
    if (open) {
      const a = grid[heightSegments][widthSegments - 1];
      const b = grid[heightSegments][widthSegments];
      indices.push(a, b);
      const c = grid[heightSegments - 1][widthSegments];
      const d = grid[heightSegments][widthSegments];
      indices.push(c, d);
    }
    geometry.setIndex(indices);
    geometry.setAttribute("position", new three__WEBPACK_IMPORTED_MODULE_0__.Float32BufferAttribute(vertices, 3));
    geometry.setAttribute("normal", new three__WEBPACK_IMPORTED_MODULE_0__.Float32BufferAttribute(normals, 3));
    geometry.setAttribute("uv", new three__WEBPACK_IMPORTED_MODULE_0__.Float32BufferAttribute(uvs, 2));
    return geometry;
  }
}


/***/ }),

/***/ 21133:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Dh": function() { return /* binding */ cadAxis; },
/* harmony export */   "yK": function() { return /* binding */ cadPlaneXY; }
/* harmony export */ });
/* unused harmony export cadPlaneFromAxis */
/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(21410);
/* harmony import */ var _CadLoaderSync__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(16457);



function cadAxis(axisVector3) {
  const axis = _CadLoaderSync__WEBPACK_IMPORTED_MODULE_0__/* .CadLoaderSync.gp_Ax2 */ .T.gp_Ax2;
  const dir = _CadLoaderSync__WEBPACK_IMPORTED_MODULE_0__/* .CadLoaderSync.gp_Dir */ .T.gp_Dir;
  dir.SetCoord_2(axisVector3.x, axisVector3.y, axisVector3.z);
  axis.SetDirection(dir);
  return axis;
}
const tmpV3 = new three__WEBPACK_IMPORTED_MODULE_1__.Vector3();
function cadPlaneXY() {
  return cadPlaneFromAxis(tmpV3.set(0, 0, 1));
}
function cadPlaneFromAxis(axisVector3) {
  const axis = _CadLoaderSync__WEBPACK_IMPORTED_MODULE_0__/* .CadLoaderSync.gp_Ax1 */ .T.gp_Ax1;
  const dir = _CadLoaderSync__WEBPACK_IMPORTED_MODULE_0__/* .CadLoaderSync.gp_Dir */ .T.gp_Dir;
  dir.SetCoord_2(axisVector3.x, axisVector3.y, axisVector3.z);
  axis.SetDirection(dir);
  const plane = _CadLoaderSync__WEBPACK_IMPORTED_MODULE_0__/* .CadLoaderSync.gp_Pln */ .T.gp_Pln;
  plane.SetAxis(axis);
  return plane;
}


/***/ }),

/***/ 18613:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Nb": function() { return /* binding */ step; },
/* harmony export */   "Qf": function() { return /* binding */ csgMaterialLine; },
/* harmony export */   "kW": function() { return /* binding */ csgMaterialMesh; }
/* harmony export */ });
/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(21410);


const step = 1e-6;
const MESH_MAT = new three__WEBPACK_IMPORTED_MODULE_0__.MeshStandardMaterial({
  color: 16777215,
  // vertexColors: true,
  side: three__WEBPACK_IMPORTED_MODULE_0__.FrontSide,
  metalness: 0,
  roughness: 0.9
});
const LINES_MAT = new three__WEBPACK_IMPORTED_MODULE_0__.LineBasicMaterial({
  color: 16777215,
  linewidth: 1
  // vertexColors: true,
});
function csgMaterialMesh(color, wireframe) {
  const mat = MESH_MAT.clone();
  mat.wireframe = wireframe;
  mat.color = color;
  return mat;
}
function csgMaterialLine(color) {
  const mat = LINES_MAT.clone();
  mat.color = color;
  return mat;
}


/***/ }),

/***/ 12243:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {


// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  "V": function() { return /* binding */ CsgObject; }
});

// EXTERNAL MODULE: ../@polygonjs/polygonjs/node_modules/three/build/three.module.js
var three_module = __webpack_require__(21410);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/core/geometry/modules/csg/CsgCommon.ts
var CsgCommon = __webpack_require__(87831);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/core/geometry/modules/csg/CsgCoreType.ts
var CsgCoreType = __webpack_require__(70083);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/core/geometry/ObjectContent.ts
var ObjectContent = __webpack_require__(91057);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/core/geometry/Constant.ts
var Constant = __webpack_require__(91568);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/operations/sop/_Base.ts
var _Base = __webpack_require__(82612);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/core/geometry/modules/csg/CsgConstant.ts
var CsgConstant = __webpack_require__(18613);
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/core/geometry/modules/csg/toObject3D/CsgPath2ToObject3D.ts





const matrix = new three_module.Matrix4();
const t = new three_module.Vector3();
const q = new three_module.Quaternion();
const s = new three_module.Vector3();
function path2ToObject3D(csg, tesselationParams) {
  const geometry = path2ToBufferGeometry(csg);
  return _Base/* BaseSopOperation.createObject */.U.createObject(
    geometry,
    Constant/* ObjectType.LINE_SEGMENTS */.LP.LINE_SEGMENTS,
    (0,CsgConstant/* csgMaterialLine */.Qf)(tesselationParams.linesColor)
  );
}
function path2ToBufferGeometry(csg) {
  const vertices = [];
  const indices = [];
  const points2D = csg.points;
  let i = 0;
  for (const point of points2D) {
    vertices.push(point[0], 0, point[1]);
    if (i != 0) {
      indices.push(i - 1);
      indices.push(i);
    }
    i++;
  }
  const geo = new three_module.BufferGeometry();
  geo.setAttribute("position", new three_module.BufferAttribute(new Float32Array(vertices), 3));
  geo.setIndex(indices);
  matrix.elements = csg.transforms;
  matrix.decompose(t, q, s);
  t.y = 0;
  matrix.compose(t, q, s);
  geo.applyMatrix4(matrix);
  return geo;
}
function path2Positions(csg) {
  const points = csg.points;
  const vectors = new Array(points.length);
  let i = 0;
  for (const pt of points) {
    const vec = new Vector3();
    vec.x = pt[0];
    vec.y = 0;
    vec.z = pt[1];
    vectors[i] = vec;
    i++;
  }
  return vectors;
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/core/geometry/modules/csg/toObject3D/CsgGeom2ToObject3D.ts





const CsgGeom2ToObject3D_matrix = new three_module.Matrix4();
const CsgGeom2ToObject3D_t = new three_module.Vector3();
const CsgGeom2ToObject3D_q = new three_module.Quaternion();
const CsgGeom2ToObject3D_s = new three_module.Vector3();
function geom2ToObject3D(csg, tesselationParams) {
  const geometry = geom2ToBufferGeometry(csg);
  return _Base/* BaseSopOperation.createObject */.U.createObject(
    geometry,
    Constant/* ObjectType.LINE_SEGMENTS */.LP.LINE_SEGMENTS,
    (0,CsgConstant/* csgMaterialLine */.Qf)(tesselationParams.linesColor)
  );
}
function geom2ToBufferGeometry(csg) {
  const vertices = [];
  const indices = [];
  const sides = csg.sides;
  let i = 0;
  for (const side of sides) {
    const point0 = side[0];
    const point1 = side[1];
    vertices.push(point0[0], 0, point0[1]);
    vertices.push(point1[0], 0, point1[1]);
    indices.push(i * 2);
    indices.push(i * 2 + 1);
    i++;
  }
  const geo = new three_module.BufferGeometry();
  geo.setAttribute("position", new three_module.BufferAttribute(new Float32Array(vertices), 3));
  geo.setIndex(indices);
  CsgGeom2ToObject3D_matrix.elements = csg.transforms;
  CsgGeom2ToObject3D_matrix.decompose(CsgGeom2ToObject3D_t, CsgGeom2ToObject3D_q, CsgGeom2ToObject3D_s);
  CsgGeom2ToObject3D_t.y = 0;
  CsgGeom2ToObject3D_matrix.compose(CsgGeom2ToObject3D_t, CsgGeom2ToObject3D_q, CsgGeom2ToObject3D_s);
  geo.applyMatrix4(CsgGeom2ToObject3D_matrix);
  return geo;
}
function geom2Positions(csg) {
  const sides = csg.sides;
  const vectors = new Array(sides.length);
  let i = 0;
  for (const side of sides) {
    const vec = new Vector3();
    const pt = side[0];
    vec.x = pt[0];
    vec.y = pt[1];
    vec.z = 0;
    vectors[i] = vec;
    i++;
  }
  return vectors;
}

// EXTERNAL MODULE: ../@polygonjs/polygonjs/node_modules/three/examples/jsm/utils/BufferGeometryUtils.js
var BufferGeometryUtils = __webpack_require__(80993);
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/core/geometry/modules/csg/toObject3D/CsgGeom3ToObject3D.ts






function geom3ToObject3D(csg, options) {
  const geometry = geom3ToBufferGeometry(csg, options);
  return _Base/* BaseSopOperation.createObject */.U.createObject(
    geometry,
    Constant/* ObjectType.MESH */.LP.MESH,
    (0,CsgConstant/* csgMaterialMesh */.kW)(options.meshesColor, options.wireframe)
  );
}
function geom3ToBufferGeometry(csg, options) {
  const positions = [];
  const indices = [];
  const polygons = csg.polygons;
  let currentIndex = 0;
  const indexByPosition = /* @__PURE__ */ new Map();
  for (const polygon of polygons) {
    const polygonjsCount = polygon.vertices.length;
    const polygonVertices = polygon.vertices;
    for (const vertex of polygonVertices) {
      const positionAsString = `${vertex[0]},${vertex[1]},${vertex[2]}`;
      let index = indexByPosition.get(positionAsString);
      if (index == null) {
        index = currentIndex;
        indexByPosition.set(positionAsString, index);
        positions.push(vertex[0], vertex[1], vertex[2]);
        currentIndex++;
      }
      vertex.index = index;
    }
    const first = polygonVertices[0].index;
    for (let i = 2; i < polygonjsCount; i++) {
      const second = polygon.vertices[i - 1].index;
      const third = polygon.vertices[i].index;
      indices.push(first, second, third);
    }
  }
  const geo = new three_module.BufferGeometry();
  geo.setAttribute("position", new three_module.BufferAttribute(new Float32Array(positions), 3));
  geo.setIndex(indices);
  if (csg.transforms) {
    const transforms = new three_module.Matrix4();
    transforms.set(...csg.transforms).transpose();
    geo.applyMatrix4(transforms);
  }
  geo.computeVertexNormals();
  return (0,BufferGeometryUtils/* toCreasedNormals */.LZ)(geo, three_module.MathUtils.degToRad(options.facetAngle));
}

// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/core/geometry/modules/csg/math/CsgMat4.ts
var CsgMat4 = __webpack_require__(37862);
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/core/geometry/modules/csg/math/CsgBoundingBox.ts


const _min = new three_module.Vector3();
const _max = new three_module.Vector3();
const _mat4 = new three_module.Matrix4();
function csgBoundingBoxPath2(geometry, target) {
  const points = geometry.points;
  if (points.length != 0) {
    const firstPoint = points[0];
    _min.set(firstPoint[0], 0, firstPoint[1]);
    _max.copy(_min);
  }
  for (const vertex of points) {
    _min.x = Math.min(_min.x, vertex[0]);
    _min.y = Math.min(_min.z, vertex[1]);
    _max.x = Math.max(_max.x, vertex[0]);
    _max.y = Math.max(_max.z, vertex[1]);
  }
  target.min.copy(_min);
  target.max.copy(_max);
  _mat4.elements = geometry.transforms;
  target.applyMatrix4(_mat4);
}
function csgBoundingBoxGeom2(geometry, target) {
  const sides = geometry.sides;
  if (sides.length != 0) {
    const firstSide = sides[0];
    const firstVertex = firstSide[0];
    _min.set(firstVertex[0], 0, firstVertex[1]);
    _max.copy(_min);
  }
  for (const side of sides) {
    for (const vertex of side) {
      _min.x = Math.min(_min.x, vertex[0]);
      _min.y = Math.min(_min.z, vertex[1]);
      _max.x = Math.max(_max.x, vertex[0]);
      _max.y = Math.max(_max.z, vertex[1]);
    }
  }
  target.min.copy(_min);
  target.max.copy(_max);
  _mat4.elements = geometry.transforms;
  target.applyMatrix4(_mat4);
}
function csgBoundingBoxGeom3(geometry, target) {
  const polygons = geometry.polygons;
  if (polygons.length != 0) {
    const firstPolygon = polygons[0];
    const vertices = firstPolygon.vertices;
    if (vertices.length != 0) {
      const firstVertex = vertices[0];
      _min.set(firstVertex[0], firstVertex[1], firstVertex[2]);
      _max.copy(_min);
    }
  }
  for (const polygon of polygons) {
    const vertices = polygon.vertices;
    for (const vertex of vertices) {
      _min.x = Math.min(_min.x, vertex[0]);
      _min.y = Math.min(_min.y, vertex[1]);
      _min.z = Math.min(_min.z, vertex[2]);
      _max.x = Math.max(_max.x, vertex[0]);
      _max.y = Math.max(_max.y, vertex[1]);
      _max.z = Math.max(_max.z, vertex[2]);
    }
  }
  target.min.copy(_min);
  target.max.copy(_max);
  _mat4.elements = geometry.transforms;
  target.applyMatrix4(_mat4);
}

// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/poly/Assert.ts
var Assert = __webpack_require__(68239);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/core/Type.ts
var Type = __webpack_require__(19037);
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/core/geometry/modules/csg/CsgObject.ts












const _box = new three_module.Box3();
const _size = new three_module.Vector3();
class CsgObject {
  constructor(_geometry) {
    this._geometry = _geometry;
    this.visible = true;
    this.userData = {};
    this.name = "";
    this.castShadow = true;
    this.receiveShadow = true;
    this.renderOrder = 0;
    this.frustumCulled = true;
    this.matrixAutoUpdate = false;
    this.children = [];
    this.parent = null;
    this._type = (0,CsgCoreType/* csgGeometryTypeFromGeometry */.HZ)(this._geometry);
    this._validate();
  }
  get geometry() {
    return this._geometry;
  }
  get type() {
    return this._type;
  }
  setGeometry(geometry) {
    this._geometry = geometry;
    this._validate();
  }
  _validate() {
    const type = (0,CsgCoreType/* csgGeometryTypeFromGeometry */.HZ)(this._geometry);
    if (type) {
      this._type = type;
    } else {
      console.error("no type for geometry", this._geometry);
    }
  }
  csgGeometry() {
    return this.geometry;
  }
  dispose() {
  }
  applyMatrix4(matrix) {
    (0,CsgMat4/* matrix4ToMat4 */.WZ)(matrix, this.csgGeometry().transforms);
  }
  add(...object) {
  }
  remove(...object) {
  }
  dispatchEvent(event) {
  }
  traverse(callback) {
    callback(this);
  }
  clone() {
    const geometry = JSON.parse(JSON.stringify(this.csgGeometry()));
    const clone = new CsgObject(geometry);
    (0,ObjectContent/* objectContentCopyProperties */.Br)(this, clone);
    return clone;
  }
  toObject3D(tesselationParams) {
    const object = CsgObject.toObject3D(this, this.type, tesselationParams);
    if (object) {
      if (Type/* CoreType.isArray */.MR.isArray(object)) {
        for (const element of object) {
          (0,ObjectContent/* objectContentCopyProperties */.Br)(this, element);
        }
      } else {
        (0,ObjectContent/* objectContentCopyProperties */.Br)(this, object);
      }
    }
    return object;
  }
  static toObject3D(csgObject, type, tesselationParams) {
    switch (type) {
      case CsgCommon/* CsgGeometryType.PATH2 */.d.PATH2: {
        return path2ToObject3D(csgObject.csgGeometry(), tesselationParams);
      }
      case CsgCommon/* CsgGeometryType.GEOM2 */.d.GEOM2: {
        return geom2ToObject3D(csgObject.csgGeometry(), tesselationParams);
      }
      case CsgCommon/* CsgGeometryType.GEOM3 */.d.GEOM3: {
        return geom3ToObject3D(csgObject.csgGeometry(), tesselationParams);
      }
    }
    Assert/* TypeAssert.unreachable */.f.unreachable(type);
  }
  boundingBox(target) {
    const type = this.type;
    switch (type) {
      case CsgCommon/* CsgGeometryType.PATH2 */.d.PATH2: {
        return csgBoundingBoxPath2(this.csgGeometry(), target);
      }
      case CsgCommon/* CsgGeometryType.GEOM2 */.d.GEOM2: {
        return csgBoundingBoxGeom2(this.csgGeometry(), target);
      }
      case CsgCommon/* CsgGeometryType.GEOM3 */.d.GEOM3: {
        return csgBoundingBoxGeom3(this.csgGeometry(), target);
      }
    }
    Assert/* TypeAssert.unreachable */.f.unreachable(type);
  }
  boundingSphere(target) {
    this.boundingBox(_box);
    _box.getSize(_size);
    _box.getSize(target.center);
    const diameter = Math.max(_size.x, _size.y, _size.z);
    target.radius = diameter * 0.5;
  }
}


/***/ }),

/***/ 37862:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "PL": function() { return /* binding */ csgApplyMatrix4; },
/* harmony export */   "Qm": function() { return /* binding */ geom2ApplyTransforms; },
/* harmony export */   "WZ": function() { return /* binding */ matrix4ToMat4; },
/* harmony export */   "l6": function() { return /* binding */ csgApplyTransform; }
/* harmony export */ });
/* unused harmony exports geom3ApplyTransforms, path2ApplyTransforms */
/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(21410);
/* harmony import */ var _CsgCommon__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(87831);
/* harmony import */ var _CsgCoreType__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(70083);
/* harmony import */ var _jscad_modeling__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(93187);
/* harmony import */ var _jscad_modeling__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_jscad_modeling__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _engine_poly_Assert__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(68239);






const { mat4 } = _jscad_modeling__WEBPACK_IMPORTED_MODULE_0__.maths;
const TMP_MAT4 = new three__WEBPACK_IMPORTED_MODULE_1__.Matrix4();
const TMP_VEC3 = new three__WEBPACK_IMPORTED_MODULE_1__.Vector3();
const isIdentity = (matrix) => matrix[0] === 1 && matrix[1] === 0 && matrix[2] === 0 && matrix[3] === 0 && matrix[4] === 0 && matrix[5] === 1 && matrix[6] === 0 && matrix[7] === 0 && matrix[8] === 0 && matrix[9] === 0 && matrix[10] === 1 && matrix[11] === 0 && matrix[12] === 0 && matrix[13] === 0 && matrix[14] === 0 && matrix[15] === 1;
function geom3ApplyTransforms(geom) {
  if (isIdentity(geom.transforms))
    return;
  TMP_MAT4.elements = geom.transforms;
  const polygons = geom.polygons;
  for (const polygon of polygons) {
    const vertices = polygon.vertices;
    for (const vertex of vertices) {
      transformVec3(vertex, TMP_MAT4);
    }
  }
  mat4.identity(geom.transforms);
}
function path2ApplyTransforms(geom) {
  if (isIdentity(geom.transforms))
    return;
  TMP_MAT4.elements = geom.transforms;
  const points = geom.points;
  for (const point of points) {
    transformVec2(point, TMP_MAT4);
  }
  mat4.identity(geom.transforms);
}
function csgApplyTransform(csg) {
  const type = (0,_CsgCoreType__WEBPACK_IMPORTED_MODULE_2__/* .csgGeometryTypeFromGeometry */ .HZ)(csg);
  switch (type) {
    case _CsgCommon__WEBPACK_IMPORTED_MODULE_3__/* .CsgGeometryType.PATH2 */ .d.PATH2: {
      return path2ApplyTransforms(csg);
    }
    case _CsgCommon__WEBPACK_IMPORTED_MODULE_3__/* .CsgGeometryType.GEOM2 */ .d.GEOM2: {
      return geom2ApplyTransforms(csg);
    }
    case _CsgCommon__WEBPACK_IMPORTED_MODULE_3__/* .CsgGeometryType.GEOM3 */ .d.GEOM3: {
      return geom3ApplyTransforms(csg);
    }
  }
  _engine_poly_Assert__WEBPACK_IMPORTED_MODULE_4__/* .TypeAssert.unreachable */ .f.unreachable(type);
}
function matrix4ToMat4(matrix4, target) {
  const elements = matrix4.elements;
  target[0] = elements[0];
  target[1] = elements[1];
  target[2] = elements[2];
  target[3] = elements[3];
  target[4] = elements[4];
  target[5] = elements[5];
  target[6] = elements[6];
  target[7] = elements[7];
  target[8] = elements[8];
  target[9] = elements[9];
  target[10] = elements[10];
  target[11] = elements[11];
  target[12] = elements[12];
  target[13] = elements[13];
  target[14] = elements[14];
  target[15] = elements[15];
}
function csgApplyMatrix4(csg, matrix4) {
  matrix4ToMat4(matrix4, csg.transforms);
  csgApplyTransform(csg);
}
function transformVec2(vec2, matrix4) {
  TMP_VEC3.x = vec2[0];
  TMP_VEC3.y = 0;
  TMP_VEC3.z = vec2[1];
  TMP_VEC3.applyMatrix4(matrix4);
  vec2[0] = TMP_VEC3.x;
  vec2[1] = TMP_VEC3.z;
}
function transformVec3(vec3, matrix4) {
  TMP_VEC3.x = vec3[0];
  TMP_VEC3.y = vec3[1];
  TMP_VEC3.z = vec3[2];
  TMP_VEC3.applyMatrix4(matrix4);
  vec3[0] = TMP_VEC3.x;
  vec3[1] = TMP_VEC3.y;
  vec3[2] = TMP_VEC3.z;
}
function geom2ApplyTransforms(geom) {
  if (isIdentity(geom.transforms)) {
    return;
  }
  const sides = geom.sides;
  TMP_MAT4.elements = geom.transforms;
  for (const side of sides) {
    transformVec2(side[0], TMP_MAT4);
    transformVec2(side[1], TMP_MAT4);
  }
  mat4.identity(geom.transforms);
}


/***/ }),

/***/ 98429:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Qb": function() { return /* binding */ TET_FACE_POINT_INDICES; },
/* harmony export */   "rP": function() { return /* binding */ TET_VERTICES_V_BASE; }
/* harmony export */ });
/* unused harmony exports TET_FACE_OPPOSITE_POINT_INDICES, TET_VERTICES_BASE, TET_VERTICES0, TET_VERTICES1, TET_VERTICES2, TET_VERTICES3, TET_VERTICES4, TET_VERTICES5, TET_VERTICES6, TET_VERTICES7, TET_VERTICES8, TET_VERTICES9, TET_VERTICES_V0, TET_VERTICES_V1, TET_VERTICES_V2, TET_VERTICES_V3, TET_VERTICES_V4, TET_VERTICES_V5, TET_VERTICES_V6, TET_VERTICES_V7, TET_VERTICES_V8, TET_VERTICES_V9, VERTICES_X, VERTICES_Y */
/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(21410);


const TET_FACE_POINT_INDICES = [
  [2, 1, 0],
  [0, 1, 3],
  [1, 2, 3],
  [2, 0, 3]
];
const TET_FACE_OPPOSITE_POINT_INDICES = (/* unused pure expression or super */ null && ([3, 2, 0, 1]));
const TET_VERTICES_BASE = [
  [1, 1, 1],
  [-1, -1, 1],
  [-1, 1, -1],
  [1, -1, -1]
];
const TET_VERTICES0 = [
  [-1, 0, -1],
  [1, 0, -1],
  [0, 1, 1],
  [0, -1, 1]
];
const TET_VERTICES1 = [
  [0, 0, -1],
  [-1, 1, 1],
  [-1, -1, 1],
  [1, 0, 1]
];
const TET_VERTICES2 = [
  [-1, 0, -1],
  [0, 0, 1],
  [1, -1, -1],
  [1, 1, -1]
];
const TET_VERTICES3 = [
  [0, 1, -1],
  [0, -1, -1],
  [1, 0, 1],
  [-1, 0, 1]
];
const TET_VERTICES4 = [
  [-1, -1, -1],
  [-1, 1, -1],
  [0, 0, 1],
  [1, 0, -1]
];
const TET_VERTICES5 = [
  [-1, 0, 1],
  [0, 0, -1],
  [1, 1, 1],
  [1, -1, 1]
];
const TET_VERTICES6 = [
  [-1, -1, -1],
  [1, -1, -1],
  [0, 1, -1],
  [0, 0, 1]
];
const TET_VERTICES7 = [
  [0, -1, 1],
  [0, 0, -1],
  [-1, 1, 1],
  [1, 1, 1]
];
const TET_VERTICES8 = [
  [0, 0, -1],
  [0, 1, 1],
  [-1, -1, 1],
  [1, -1, 1]
];
const TET_VERTICES9 = [
  [0, 0, 1],
  [0, -1, -1],
  [-1, 1, -1],
  [1, 1, -1]
];
function _toVectors(a) {
  return a.map((v) => new three__WEBPACK_IMPORTED_MODULE_0__.Vector3().fromArray(v));
}
const TET_VERTICES_V_BASE = _toVectors(TET_VERTICES_BASE);
const TET_VERTICES_V0 = _toVectors(TET_VERTICES0);
const TET_VERTICES_V1 = _toVectors(TET_VERTICES1);
const TET_VERTICES_V2 = _toVectors(TET_VERTICES2);
const TET_VERTICES_V3 = _toVectors(TET_VERTICES3);
const TET_VERTICES_V4 = _toVectors(TET_VERTICES4);
const TET_VERTICES_V5 = _toVectors(TET_VERTICES5);
const TET_VERTICES_V6 = _toVectors(TET_VERTICES6);
const TET_VERTICES_V7 = _toVectors(TET_VERTICES7);
const TET_VERTICES_V8 = _toVectors(TET_VERTICES8);
const TET_VERTICES_V9 = _toVectors(TET_VERTICES9);
const VERTICES_X = [
  TET_VERTICES_V0,
  TET_VERTICES_V1,
  TET_VERTICES_V2,
  TET_VERTICES_V3,
  TET_VERTICES_V4,
  TET_VERTICES_V5
];
const VERTICES_Y = [
  TET_VERTICES_V0,
  TET_VERTICES_V6,
  TET_VERTICES_V7,
  TET_VERTICES_V3,
  TET_VERTICES_V8,
  TET_VERTICES_V9
];


/***/ }),

/***/ 55291:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "D": function() { return /* binding */ findNonDelaunayTetsFromMultiplePointsCheck; },
/* harmony export */   "d": function() { return /* binding */ findNonDelaunayTetsFromSinglePointCheck; }
/* harmony export */ });
/* harmony import */ var _tetSphere__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(73134);


const visitedTets = /* @__PURE__ */ new Set();
const stack = [];
function findNonDelaunayTetsFromSinglePointCheck(tetGeometry, startTetId, addedPoint, invalidTets) {
  visitedTets.clear();
  invalidTets.length = 0;
  stack.length = 0;
  stack.push(startTetId);
  while (stack.length > 0) {
    const tetId = stack.pop();
    if (visitedTets.has(tetId)) {
      continue;
    }
    visitedTets.add(tetId);
    const tet = tetGeometry.tetrahedrons.get(tetId);
    if (!tet) {
      throw `findNonDelaunayTetsFromSinglePointCheck: tet not found (${tetId})`;
      continue;
    }
    invalidTets.push(tetId);
    for (const neighbourData of tet.neighbours) {
      if (neighbourData) {
        if (!visitedTets.has(neighbourData.id)) {
          const neighbourTet = tetGeometry.tetrahedrons.get(neighbourData.id);
          if (neighbourTet == null ? void 0 : neighbourTet.disposed) {
            console.error("is disposed");
            throw "is disposed";
          }
          if (neighbourTet && (0,_tetSphere__WEBPACK_IMPORTED_MODULE_0__/* .isPointInTetCircumSphere */ .v)(neighbourTet, addedPoint)) {
            stack.push(neighbourTet.id);
          }
        }
      }
    }
  }
}
const badTetIds = /* @__PURE__ */ new Set();
function findNonDelaunayTetsFromMultiplePointsCheck(tetGeometry, invalidTets) {
  badTetIds.clear();
  tetGeometry.points.forEach((point, pointId) => {
    tetGeometry.tetrahedrons.forEach((tet) => {
      if (!badTetIds.has(tet.id) && !tet.pointIds.includes(pointId)) {
        if ((0,_tetSphere__WEBPACK_IMPORTED_MODULE_0__/* .isPointInTetCircumSphere */ .v)(tet, point.position)) {
          badTetIds.add(tet.id);
        }
      }
    });
  });
  invalidTets.length = 0;
  badTetIds.forEach((tetId) => {
    invalidTets.push(tetId);
  });
}


/***/ }),

/***/ 92671:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Ah": function() { return /* binding */ tetCenter; },
/* harmony export */   "sj": function() { return /* binding */ getCircumCenter; },
/* harmony export */   "tJ": function() { return /* binding */ tetCircumCenter; }
/* harmony export */ });
/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(21410);


function tetCenter(tetGeometry, tetId, target) {
  const points = tetGeometry.points;
  const tet = tetGeometry.tetrahedrons.get(tetId);
  if (!tet) {
    return;
  }
  const id0 = tet.pointIds[0];
  const id1 = tet.pointIds[1];
  const id2 = tet.pointIds[2];
  const id3 = tet.pointIds[3];
  const pt0 = points.get(id0);
  const pt1 = points.get(id1);
  const pt2 = points.get(id2);
  const pt3 = points.get(id3);
  if (!(pt0 && pt1 && pt2 && pt3)) {
    return;
  }
  target.copy(pt0.position).add(pt1.position).add(pt2.position).add(pt3.position).multiplyScalar(0.25);
}
const b = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();
const c = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();
const d = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();
const b2 = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();
const c2 = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();
const d2 = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();
function getCircumCenter(p0, p1, p2, p3, target) {
  b.copy(p1).sub(p0);
  c.copy(p2).sub(p0);
  d.copy(p3).sub(p0);
  const det = 2 * (b.x * (c.y * d.z - c.z * d.y) - b.y * (c.x * d.z - c.z * d.x) + b.z * (c.x * d.y - c.y * d.x));
  if (det == 0) {
    return target.copy(p0);
  } else {
    const dotb = b.dot(b);
    const dotc = c.dot(c);
    const dotd = d.dot(d);
    const cd = c2.copy(c).cross(d);
    const db = d2.copy(d).cross(b);
    const bc = b2.copy(b).cross(c);
    cd.multiplyScalar(dotb).add(db.multiplyScalar(dotc)).add(bc.multiplyScalar(dotd));
    cd.divideScalar(det);
    return target.copy(p0).add(cd);
  }
}
function tetCircumCenter(tetGeometry, tetId, target) {
  const tet = tetGeometry.tetrahedrons.get(tetId);
  if (!tet) {
    return;
  }
  const pt0 = tetGeometry.points.get(tet.pointIds[0]);
  const pt1 = tetGeometry.points.get(tet.pointIds[1]);
  const pt2 = tetGeometry.points.get(tet.pointIds[2]);
  const pt3 = tetGeometry.points.get(tet.pointIds[3]);
  if (!(pt0 && pt1 && pt2 && pt3)) {
    return;
  }
  getCircumCenter(pt0.position, pt1.position, pt2.position, pt3.position, target);
}


/***/ }),

/***/ 75118:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "q": function() { return /* binding */ isPositionInsideMesh; }
/* harmony export */ });
/* unused harmony export DIRS */
/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(21410);
/* harmony import */ var _RaycastHelper__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(71003);



const DIRS = [
  new three__WEBPACK_IMPORTED_MODULE_0__.Vector3(1, 0, 0),
  new three__WEBPACK_IMPORTED_MODULE_0__.Vector3(-1, 0, 0),
  new three__WEBPACK_IMPORTED_MODULE_0__.Vector3(0, 1, 0),
  new three__WEBPACK_IMPORTED_MODULE_0__.Vector3(0, -1, 0),
  new three__WEBPACK_IMPORTED_MODULE_0__.Vector3(0, 0, 1),
  new three__WEBPACK_IMPORTED_MODULE_0__.Vector3(0, 0, -1)
];
const _raycaster = (0,_RaycastHelper__WEBPACK_IMPORTED_MODULE_1__/* .createRaycaster */ .j)();
function isPositionInsideMesh(pos, mesh, minDist) {
  let numIn = 0;
  const bvh = mesh.geometry.boundsTree;
  _raycaster.ray.origin.copy(pos);
  for (const dir of DIRS) {
    _raycaster.ray.direction.copy(dir);
    const hit = bvh.raycastFirst(_raycaster.ray, three__WEBPACK_IMPORTED_MODULE_0__.BackSide);
    if (hit) {
      const { normal, distance } = hit;
      if (normal) {
        normal.applyMatrix4(mesh.matrixWorld);
        if (normal.dot(dir) <= 0) {
          numIn++;
        }
        if (minDist > 0 && distance < minDist) {
          return false;
        }
      }
    }
  }
  return numIn > 4;
}


/***/ }),

/***/ 45210:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "K": function() { return /* binding */ tetQuality; }
/* harmony export */ });
/* unused harmony export tetQualityFromPoints */
/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(21410);


const d0 = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();
const d1 = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();
const d2 = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();
const d3 = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();
const d4 = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();
const d5 = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();
function tetQuality(tetGeometry, tetId) {
  const tet = tetGeometry.tetrahedrons.get(tetId);
  if (!tet) {
    return 0;
  }
  const pt0 = tetGeometry.points.get(tet.pointIds[0]);
  const pt1 = tetGeometry.points.get(tet.pointIds[1]);
  const pt2 = tetGeometry.points.get(tet.pointIds[2]);
  const pt3 = tetGeometry.points.get(tet.pointIds[3]);
  if (!(pt0 && pt1 && pt2 && pt3)) {
    return 0;
  }
  return tetQualityFromPoints(pt0.position, pt1.position, pt2.position, pt3.position);
}
function tetQualityFromPoints(p0, p1, p2, p3) {
  d0.copy(p1).sub(p0);
  d1.copy(p2).sub(p0);
  d2.copy(p3).sub(p0);
  d3.copy(p2).sub(p1);
  d4.copy(p3).sub(p2);
  d5.copy(p1).sub(p3);
  const s0 = d0.length();
  const s1 = d1.length();
  const s2 = d2.length();
  const s3 = d3.length();
  const s4 = d4.length();
  const s5 = d5.length();
  const ms = (s0 * s0 + s1 * s1 + s2 * s2 + s3 * s3 + s4 * s4 + s5 * s5) / 6;
  const rms = Math.sqrt(ms);
  const s = 12 / Math.sqrt(2);
  const vol = d0.dot(d1.cross(d2)) / 6;
  return s * vol / (rms * rms * rms);
}


/***/ }),

/***/ 61985:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "B": function() { return /* binding */ tetRemoveUnusedPoints; }
/* harmony export */ });

function tetRemoveUnusedPoints(tetGeometry) {
  const usedPointIds = /* @__PURE__ */ new Set();
  tetGeometry.tetrahedrons.forEach((tet) => {
    tet.pointIds.forEach((pointId) => {
      usedPointIds.add(pointId);
    });
  });
  tetGeometry.points.forEach((point, pointId) => {
    if (!usedPointIds.has(pointId)) {
      tetGeometry.removePoint(pointId);
    }
  });
  return tetGeometry;
}


/***/ }),

/***/ 50377:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "e": function() { return /* binding */ tetSortPoints; }
/* harmony export */ });

function tetSortPoints(tetGeometry, pointIndexById) {
  pointIndexById.clear();
  let index = 0;
  tetGeometry.points.forEach((point) => {
    if (!pointIndexById.has(point.id)) {
      pointIndexById.set(point.id, index);
      index++;
    }
  });
}


/***/ }),

/***/ 73134:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "v": function() { return /* binding */ isPointInTetCircumSphere; },
/* harmony export */   "y": function() { return /* binding */ circumSphere; }
/* harmony export */ });
/* harmony import */ var _tetCenter__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(92671);


function circumSphere(tetGeometry, id0, id1, id2, id3, target) {
  const p0 = tetGeometry.points.get(id0);
  const p1 = tetGeometry.points.get(id1);
  const p2 = tetGeometry.points.get(id2);
  const p3 = tetGeometry.points.get(id3);
  if (!(p0 && p1 && p2 && p3)) {
    return;
  }
  (0,_tetCenter__WEBPACK_IMPORTED_MODULE_0__/* .getCircumCenter */ .sj)(p0.position, p1.position, p2.position, p3.position, target.center);
  target.radius = target.center.distanceTo(p0.position);
  return;
}
function isPointInTetCircumSphere(tetrahedron, point) {
  return point.distanceTo(tetrahedron.sphere.center) <= tetrahedron.sphere.radius;
}


/***/ }),

/***/ 2700:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Vc": function() { return /* binding */ POPULATE_ADJACENCY_DEFAULT; },
/* harmony export */   "_7": function() { return /* binding */ adjacencyAttribName; },
/* harmony export */   "im": function() { return /* binding */ AttribAdjacency; },
/* harmony export */   "uf": function() { return /* binding */ unpackAdjacency3; },
/* harmony export */   "w3": function() { return /* binding */ populateAdjacency3; }
/* harmony export */ });
/* unused harmony export populateAdjacency2 */
/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(21410);
/* harmony import */ var _SetUtils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(55407);
/* harmony import */ var _modules_three_ThreejsCoreObject__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(2318);
/* harmony import */ var _TextureFromAttribute__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(52598);





const v0 = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();
var AttribAdjacency = /* @__PURE__ */ ((AttribAdjacency2) => {
  AttribAdjacency2["BASE_NAME"] = "adjacency";
  AttribAdjacency2["COUNT"] = "adjacencyCount";
  return AttribAdjacency2;
})(AttribAdjacency || {});
function adjacencyAttribName(baseAttribName, index) {
  return `${baseAttribName}${index}`;
}
function _adjacencyVertices(geometry, vertices) {
  const position = geometry.attributes.position;
  if (!(position instanceof three__WEBPACK_IMPORTED_MODULE_0__.BufferAttribute)) {
    console.warn("position is not a BufferAttribute");
    return;
  }
  for (let i = 0, il = position.count; i < il; i++) {
    v0.fromBufferAttribute(position, i);
    vertices.push(v0.clone());
  }
}
function _adjacencyGroupFaces(geometry, vertices) {
  const index = geometry.index;
  if (!index) {
    console.warn("no index");
    return;
  }
  const verticesCount = vertices.length;
  const indexCount = index.count / 3;
  const faces = Array.from({ length: verticesCount }, () => new Array());
  for (let i = 0, il = indexCount; i < il; i++) {
    const i3 = i * 3;
    const a = index.getX(i3 + 0);
    const b = index.getX(i3 + 1);
    const c = index.getX(i3 + 2);
    const face = { a, b, c };
    faces[a].push(face);
    faces[b].push(face);
    faces[c].push(face);
  }
  return faces;
}
const _indexPairByFirstIndex = /* @__PURE__ */ new Map();
const _endIndices = /* @__PURE__ */ new Set();
function filterAjacency(indexPairs) {
  _indexPairByFirstIndex.clear();
  _endIndices.clear();
  for (const indexPair of indexPairs) {
    _indexPairByFirstIndex.set(indexPair[0], indexPair);
    _endIndices.add(indexPair[1]);
  }
  let startIndex = 0;
  let i = 0;
  for (const indexPair of indexPairs) {
    if (!_endIndices.has(indexPair[0])) {
      startIndex = i;
      break;
    }
    i++;
  }
  const expectedCount = indexPairs.length;
  const rawList = new Array(expectedCount).fill(-1);
  const result = new Array();
  let currentIndexPair = indexPairs[startIndex];
  for (let i2 = 0; i2 < expectedCount; i2++) {
    rawList[i2] = currentIndexPair[0];
    currentIndexPair = _indexPairByFirstIndex.get(currentIndexPair[1]);
    if (!currentIndexPair) {
      break;
    }
  }
  for (let i2 = 0; i2 < expectedCount; i2 += 2) {
    result.push([rawList[i2], rawList[i2 + 1]]);
  }
  return result;
}
const _pointSet = /* @__PURE__ */ new Set();
const _pointArray = [];
function populateAdjacency2(faces, vertices) {
  const adjacency = Array.from({ length: vertices.length }, () => new Array());
  for (let r = 0; r < faces.length; r++) {
    const pointFaces = faces[r];
    if (pointFaces.length == 0) {
      console.warn(`point ${r} has no face`);
    }
    _pointSet.clear();
    for (const pointFace of pointFaces) {
      switch (r) {
        case pointFace.a: {
          _pointSet.add([pointFace.b, pointFace.c]);
          break;
        }
        case pointFace.b: {
          _pointSet.add([pointFace.c, pointFace.a]);
          break;
        }
        case pointFace.c: {
          _pointSet.add([pointFace.a, pointFace.b]);
          break;
        }
      }
    }
    (0,_SetUtils__WEBPACK_IMPORTED_MODULE_1__/* .setToArray */ .T_)(_pointSet, _pointArray);
    adjacency[r] = filterAjacency(_pointArray);
  }
  return adjacency;
}
const POPULATE_ADJACENCY_DEFAULT = {
  adjacencyCountName: "adjacencyCount" /* COUNT */,
  adjacencyBaseName: "adjacency" /* BASE_NAME */
};
function populateAdjacency3(object, params) {
  const { adjacencyCountName, adjacencyBaseName } = params;
  const geometry = object.geometry;
  if (!geometry) {
    return;
  }
  const position = geometry.attributes.position;
  if (!(position instanceof three__WEBPACK_IMPORTED_MODULE_0__.BufferAttribute)) {
    console.warn("position is not a BufferAttribute");
    return;
  }
  const index = geometry.index;
  if (!index) {
    console.warn("no index");
    return;
  }
  const vertices = [];
  _adjacencyVertices(geometry, vertices);
  const faces = _adjacencyGroupFaces(geometry, vertices);
  if (!faces) {
    return;
  }
  const adjacency = populateAdjacency2(faces, vertices);
  let maxAdjacencyCount = -1;
  for (const arr of adjacency) {
    if (arr.length > maxAdjacencyCount) {
      maxAdjacencyCount = arr.length;
    }
  }
  const attribSize = 2;
  const attributesCount = Math.ceil(maxAdjacencyCount);
  _modules_three_ThreejsCoreObject__WEBPACK_IMPORTED_MODULE_2__/* .ThreejsCoreObject.addAttribute */ .W.addAttribute(object, adjacencyCountName, maxAdjacencyCount);
  const pointsCount = position.count;
  const _addAdjacencyAttributes = () => {
    for (let attribIndex = 0; attribIndex < attributesCount; attribIndex++) {
      const attribName = adjacencyAttribName(adjacencyBaseName, attribIndex);
      const values = new Array(pointsCount * attribSize).fill(-1);
      for (let pointIndex = 0; pointIndex < pointsCount; pointIndex++) {
        const pointAdjacency = adjacency[pointIndex][attribIndex];
        if (pointAdjacency) {
          for (let i = 0; i < attribSize; i++) {
            const value = pointAdjacency[i];
            values[pointIndex * attribSize + i] = value != null ? value : -1;
          }
        }
      }
      const valuesArray = new Float32Array(values);
      geometry.setAttribute(attribName, new three__WEBPACK_IMPORTED_MODULE_0__.BufferAttribute(valuesArray, attribSize));
    }
  };
  _addAdjacencyAttributes();
  (0,_TextureFromAttribute__WEBPACK_IMPORTED_MODULE_3__/* .textureFromAttribLookupUv */ .hm)(geometry);
  (0,_TextureFromAttribute__WEBPACK_IMPORTED_MODULE_3__/* .textureFromAttribLookupId */ .kG)(geometry);
}
function unpackAdjacency3(object, params) {
  var _a;
  const { adjacencyCountName, adjacencyBaseName } = params;
  const geometry = object.geometry;
  if (!geometry) {
    return [];
  }
  const indices = (_a = geometry.index) == null ? void 0 : _a.array;
  if (!indices) {
    return [];
  }
  const pointsCount = indices.length;
  const adjacencies = [];
  const adjacencyCount = _modules_three_ThreejsCoreObject__WEBPACK_IMPORTED_MODULE_2__/* .ThreejsCoreObject.attribValue */ .W.attribValue(object, adjacencyCountName, 0);
  for (let i = 0; i < pointsCount; i++) {
    const index = indices[i];
    for (let attribIndex = 0; attribIndex < adjacencyCount; attribIndex++) {
      const attribName = adjacencyAttribName(adjacencyBaseName, attribIndex);
      const attribute = geometry.getAttribute(attribName);
      const array = attribute.array;
      let pointAdjacency = adjacencies[index];
      if (!pointAdjacency) {
        pointAdjacency = [];
        adjacencies[index] = pointAdjacency;
      }
      const i0 = array[index * 2];
      const i1 = array[index * 2 + 1];
      if (!pointAdjacency.includes(i0)) {
        pointAdjacency.push(i0);
      }
      if (!pointAdjacency.includes(i1)) {
        pointAdjacency.push(i1);
      }
    }
  }
  return adjacencies;
}


/***/ }),

/***/ 99450:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "B8": function() { return /* binding */ POINTS_COUNT_MODE; },
/* harmony export */   "Dr": function() { return /* binding */ Circle3Points; },
/* harmony export */   "Zc": function() { return /* binding */ JOIN_MODES; },
/* harmony export */   "_t": function() { return /* binding */ PointsCountMode; },
/* harmony export */   "cW": function() { return /* binding */ JoinMode; }
/* harmony export */ });
/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(21410);
/* harmony import */ var _engine_poly_Assert__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(68239);



var PointsCountMode = /* @__PURE__ */ ((PointsCountMode2) => {
  PointsCountMode2["SEGMENTS_COUNT"] = "segments count";
  PointsCountMode2["SEGMENTS_LENGTH"] = "segments length";
  return PointsCountMode2;
})(PointsCountMode || {});
const POINTS_COUNT_MODE = ["segments count" /* SEGMENTS_COUNT */, "segments length" /* SEGMENTS_LENGTH */];
var JoinMode = /* @__PURE__ */ ((JoinMode2) => {
  JoinMode2["ABC"] = "abc";
  JoinMode2["ACB"] = "acb";
  JoinMode2["AB"] = "ab";
  JoinMode2["BC"] = "bc";
  JoinMode2["AC"] = "ac";
  return JoinMode2;
})(JoinMode || {});
const JOIN_MODES = ["abc" /* ABC */, "acb" /* ACB */, "ab" /* AB */, "ac" /* AC */, "bc" /* BC */];
class Circle3Points {
  constructor(params) {
    this.params = params;
    this.a = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();
    this.b = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();
    this.c = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();
    this.an = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();
    this.bn = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();
    this.cn = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();
    this.ac = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();
    this.ab = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();
    this.ab_x_ac = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();
    this.part0 = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();
    this.part1 = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();
    this.divider = 1;
    this.a_center = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();
    this.center = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();
    this.normal = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();
    this.radius = 1;
    this.x = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();
    this.y = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();
    this.z = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();
    this.angle_ab = 1;
    this.angle_ac = 1;
    this.angle_bc = 1;
    this.angle = 2 * Math.PI;
    this.x_rotated = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();
    this._created_geometries = {};
  }
  created_geometries() {
    return this._created_geometries;
  }
  create(a, b, c) {
    this.a.copy(a);
    this.b.copy(b);
    this.c.copy(c);
    this._compute_axis();
    this._create_arc();
    this._create_center();
  }
  _create_arc() {
    this._compute_angle();
    const points_count = this._points_count();
    const positions = new Array(points_count * 3);
    const indices = new Array(points_count);
    const angle_increment = this.angle / (points_count - 1);
    this.x_rotated.copy(this.x).multiplyScalar(this.radius);
    let i = 0;
    for (i = 0; i < points_count; i++) {
      this.x_rotated.copy(this.x).applyAxisAngle(this.normal, angle_increment * i).multiplyScalar(this.radius).add(this.center);
      this.x_rotated.toArray(positions, i * 3);
      if (i > 0) {
        indices[(i - 1) * 2] = i - 1;
        indices[(i - 1) * 2 + 1] = i;
      }
    }
    if (this.params.full) {
      indices.push(i - 1);
      indices.push(0);
    }
    const geometry = new three__WEBPACK_IMPORTED_MODULE_0__.BufferGeometry();
    geometry.setAttribute("position", new three__WEBPACK_IMPORTED_MODULE_0__.BufferAttribute(new Float32Array(positions), 3));
    geometry.setIndex(indices);
    if (this.params.addIdAttribute || this.params.addIdnAttribute) {
      const ids = new Array(points_count);
      for (let i2 = 0; i2 < ids.length; i2++) {
        ids[i2] = i2;
      }
      if (this.params.addIdAttribute) {
        geometry.setAttribute("id", new three__WEBPACK_IMPORTED_MODULE_0__.BufferAttribute(new Float32Array(ids), 1));
      }
      const idns = ids.map((id) => id / (points_count - 1));
      if (this.params.addIdnAttribute) {
        geometry.setAttribute("idn", new three__WEBPACK_IMPORTED_MODULE_0__.BufferAttribute(new Float32Array(idns), 1));
      }
    }
    this._created_geometries.arc = geometry;
  }
  _create_center() {
    if (!this.params.center) {
      return;
    }
    const geometry = new three__WEBPACK_IMPORTED_MODULE_0__.BufferGeometry();
    const positions = [this.center.x, this.center.y, this.center.z];
    geometry.setAttribute("position", new three__WEBPACK_IMPORTED_MODULE_0__.BufferAttribute(new Float32Array(positions), 3));
    this._created_geometries.center = geometry;
  }
  _compute_axis() {
    this.ac.copy(this.c).sub(this.a);
    this.ab.copy(this.b).sub(this.a);
    this.ab_x_ac.copy(this.ab).cross(this.ac);
    this.divider = 2 * this.ab_x_ac.lengthSq();
    this.part0.copy(this.ab_x_ac).cross(this.ab).multiplyScalar(this.ac.lengthSq());
    this.part1.copy(this.ac).cross(this.ab_x_ac).multiplyScalar(this.ab.lengthSq());
    this.a_center.copy(this.part0).add(this.part1).divideScalar(this.divider);
    this.radius = this.a_center.length();
    this.normal.copy(this.ab_x_ac).normalize();
    this.center.copy(this.a).add(this.a_center);
  }
  _compute_angle() {
    if (!this.params.arc) {
      return;
    }
    if (this.params.full) {
      this.x.copy(this.a).sub(this.center).normalize();
      this.angle = 2 * Math.PI;
    } else {
      this.an.copy(this.a).sub(this.center).normalize();
      this.bn.copy(this.b).sub(this.center).normalize();
      this.cn.copy(this.c).sub(this.center).normalize();
      this._set_x_from_joinMode();
      this.y.copy(this.normal);
      this.z.copy(this.x).cross(this.y).normalize();
      this.angle_ab = this.an.angleTo(this.bn);
      this.angle_ac = this.an.angleTo(this.cn);
      this.angle_bc = this.bn.angleTo(this.cn);
      this._set_angle_from_joinMode();
    }
  }
  _points_count() {
    const mode = this.params.pointsCountMode;
    switch (mode) {
      case "segments count" /* SEGMENTS_COUNT */: {
        return this.params.segmentsCount + 1;
      }
      case "segments length" /* SEGMENTS_LENGTH */: {
        let perimeter = Math.PI * this.radius * this.radius;
        if (!this.params.full) {
          perimeter *= Math.abs(this.angle) / (Math.PI * 2);
        }
        return Math.ceil(perimeter / this.params.segmentsLength);
      }
    }
    _engine_poly_Assert__WEBPACK_IMPORTED_MODULE_1__/* .TypeAssert.unreachable */ .f.unreachable(mode);
  }
  _set_x_from_joinMode() {
    const joinMode = this.params.joinMode;
    this.x.copy(this.a).sub(this.center).normalize();
    switch (joinMode) {
      case "abc" /* ABC */: {
        return this.x.copy(this.an);
      }
      case "acb" /* ACB */: {
        return this.x.copy(this.an);
      }
      case "ab" /* AB */: {
        return this.x.copy(this.an);
      }
      case "ac" /* AC */: {
        return this.x.copy(this.an);
      }
      case "bc" /* BC */: {
        return this.x.copy(this.bn);
      }
    }
    _engine_poly_Assert__WEBPACK_IMPORTED_MODULE_1__/* .TypeAssert.unreachable */ .f.unreachable(joinMode);
  }
  _set_angle_from_joinMode() {
    const joinMode = this.params.joinMode;
    switch (joinMode) {
      case "abc" /* ABC */: {
        this.angle = this.angle_ab + this.angle_bc;
        return;
      }
      case "acb" /* ACB */: {
        this.angle = this.angle_ac + this.angle_bc;
        this.angle *= -1;
        return;
      }
      case "ab" /* AB */: {
        this.angle = this.angle_ab;
        return;
      }
      case "ac" /* AC */: {
        this.angle = this.angle_ac;
        this.angle *= -1;
        return;
      }
      case "bc" /* BC */: {
        this.angle = this.angle_bc;
        return;
      }
    }
    _engine_poly_Assert__WEBPACK_IMPORTED_MODULE_1__/* .TypeAssert.unreachable */ .f.unreachable(joinMode);
  }
}


/***/ }),

/***/ 90651:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "X": function() { return /* binding */ mergeFaces; }
/* harmony export */ });
/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(21410);
/* harmony import */ var _MapUtils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(94158);



const tmpV2 = new three__WEBPACK_IMPORTED_MODULE_0__.Vector2();
const tmpV3 = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();
const tmpV4 = new three__WEBPACK_IMPORTED_MODULE_0__.Vector4();
class Position {
  constructor(positionAttribute, index, tolerance) {
    this.positionAttribute = positionAttribute;
    this.index = index;
    this.originalPosition = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();
    this.snappedPosition = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();
    this.originalPosition.fromBufferAttribute(positionAttribute, this.index);
    roundedPos(positionAttribute, this.index, this.snappedPosition, tolerance);
    this.snappedKey = `${this.snappedPosition.x}:${this.snappedPosition.y}:${this.snappedPosition.z}`;
  }
  addAttribValue(geometry, attribName, targetArray) {
    const attribute = geometry.getAttribute(attribName);
    switch (attribute.itemSize) {
      case 1: {
        const val = attribute.getX(this.index);
        targetArray.push(val);
        break;
      }
      case 2: {
        tmpV2.fromBufferAttribute(attribute, this.index);
        tmpV2.toArray(targetArray, targetArray.length);
        break;
      }
      case 3: {
        tmpV3.fromBufferAttribute(attribute, this.index);
        tmpV3.toArray(targetArray, targetArray.length);
        break;
      }
      case 4: {
        tmpV4.fromBufferAttribute(attribute, this.index);
        tmpV4.toArray(targetArray, targetArray.length);
        break;
      }
    }
  }
}
class Face {
  constructor(a, b, c) {
    this.a = a;
    this.b = b;
    this.c = c;
  }
}
function averagePosition(positions, target) {
  target.set(0, 0, 0);
  positions.forEach((position) => {
    target.add(position.originalPosition);
  });
  target.divideScalar(positions.size);
}
function roundedPos(position, index, target, tolerance) {
  target.fromBufferAttribute(position, index);
  if (tolerance > 0) {
    target.x = Math.round(target.x / tolerance) * tolerance;
    target.y = Math.round(target.y / tolerance) * tolerance;
    target.z = Math.round(target.z / tolerance) * tolerance;
  }
}
function isFaceCollapsed(face) {
  return face.a.snappedKey == face.b.snappedKey || face.a.snappedKey == face.c.snappedKey || face.b.snappedKey == face.c.snappedKey;
}
function mergeFaces(geometry, tolerance) {
  const index = geometry.getIndex();
  if (!index) {
    return;
  }
  const indexArray = index.array;
  const positionAttribute = geometry.getAttribute("position");
  const positionsCount = positionAttribute.count;
  const facesCount = indexArray.length / 3;
  const positions = new Array(positionsCount);
  const faces = new Array(facesCount);
  const pointsBySnappedPos = /* @__PURE__ */ new Map();
  const firstPointBySnappedPos = /* @__PURE__ */ new Map();
  const averagePosBySnappedKey = /* @__PURE__ */ new Map();
  const newIndexBySnappedKey = /* @__PURE__ */ new Map();
  const newPositions = [];
  const newIndices = [];
  const newAttributeValues = {};
  const otherAttributeNames = Object.keys(geometry.attributes).filter((attribName) => attribName != "position");
  for (const otherAttributeName of otherAttributeNames) {
    newAttributeValues[otherAttributeName] = [];
  }
  for (let i = 0; i < positionsCount; i++) {
    const position = new Position(positionAttribute, i, tolerance);
    positions[i] = position;
    _MapUtils__WEBPACK_IMPORTED_MODULE_1__/* .MapUtils.addToSetAtEntry */ .pl.addToSetAtEntry(pointsBySnappedPos, position.snappedKey, position);
    if (!firstPointBySnappedPos.has(position.snappedKey)) {
      firstPointBySnappedPos.set(position.snappedKey, position);
    }
  }
  pointsBySnappedPos.forEach((points, snappedKey) => {
    const averageV3 = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();
    averagePosition(points, averageV3);
    averagePosBySnappedKey.set(snappedKey, averageV3);
  });
  for (let i = 0; i < facesCount; i++) {
    const a = positions[indexArray[i * 3]];
    const b = positions[indexArray[i * 3 + 1]];
    const c = positions[indexArray[i * 3 + 2]];
    const face = new Face(a, b, c);
    faces[i] = face;
  }
  const remainingFaces = faces.filter((face) => !isFaceCollapsed(face));
  for (const face of remainingFaces) {
    const positions2 = [face.a, face.b, face.c];
    for (const position of positions2) {
      let newIndex = newIndexBySnappedKey.get(position.snappedKey);
      const averagePos = averagePosBySnappedKey.get(position.snappedKey);
      if (newIndex == null) {
        newIndex = newPositions.length / 3;
        newIndexBySnappedKey.set(position.snappedKey, newIndex);
        averagePos.toArray(newPositions, newPositions.length);
        const firstPoint = firstPointBySnappedPos.get(position.snappedKey);
        for (const otherAttribName of otherAttributeNames) {
          firstPoint.addAttribValue(geometry, otherAttribName, newAttributeValues[otherAttribName]);
        }
      }
      newIndices.push(newIndex);
    }
  }
  geometry.setAttribute("position", new three__WEBPACK_IMPORTED_MODULE_0__.BufferAttribute(new Float32Array(newPositions), 3));
  for (const attribName of otherAttributeNames) {
    const attribute = geometry.getAttribute(attribName);
    const newValues = newAttributeValues[attribName];
    geometry.setAttribute(attribName, new three__WEBPACK_IMPORTED_MODULE_0__.BufferAttribute(new Float32Array(newValues), attribute.itemSize));
  }
  geometry.setIndex(newIndices);
}


/***/ }),

/***/ 48956:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "K": function() { return /* binding */ jitterOffset; },
/* harmony export */   "x": function() { return /* binding */ jitterPositions; }
/* harmony export */ });
/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(21410);
/* harmony import */ var _math_Module__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(27462);



const _offset = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();
const _p = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();
const _points = [];
function jitterOffset(i, seed, mult, amount, target) {
  target.set(
    2 * ((0,_math_Module__WEBPACK_IMPORTED_MODULE_1__/* .randFloat */ .Qy)(i * 75 + 764 + seed) - 0.5),
    2 * ((0,_math_Module__WEBPACK_IMPORTED_MODULE_1__/* .randFloat */ .Qy)(i * 5678 + 3653 + seed) - 0.5),
    2 * ((0,_math_Module__WEBPACK_IMPORTED_MODULE_1__/* .randFloat */ .Qy)(i * 657 + 48464 + seed) - 0.5)
  );
  target.normalize();
  target.multiply(mult);
  target.multiplyScalar(amount * (0,_math_Module__WEBPACK_IMPORTED_MODULE_1__/* .randFloat */ .Qy)(i * 78 + 54 + seed));
}
function jitterPositions(coreGroup, options) {
  const { amount, mult, seed } = options;
  coreGroup.points(_points);
  let i = 0;
  for (const point of _points) {
    jitterOffset(i, seed, mult, amount, _offset);
    point.position(_p);
    _p.add(_offset);
    point.setPosition(_p);
    i++;
  }
}


/***/ }),

/***/ 39713:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "u": function() { return /* binding */ PolyhedronBufferGeometry; }
/* harmony export */ });
/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(21410);


function azimuth(vector) {
  return Math.atan2(vector.z, -vector.x);
}
function inclination(vector) {
  return Math.atan2(-vector.y, Math.sqrt(vector.x * vector.x + vector.z * vector.z));
}
class PolyhedronBufferGeometry extends three__WEBPACK_IMPORTED_MODULE_0__.BufferGeometry {
  constructor(vertices, indices, radius, detail, points_only) {
    super();
    this.type = "PolyhedronBufferGeometry";
    this.parameters = {
      vertices,
      indices,
      radius,
      detail
    };
    radius = radius || 1;
    detail = detail || 0;
    const vertexBuffer = [];
    const uvBuffer = [];
    const vertices_by_pos = /* @__PURE__ */ new Map();
    subdivide(detail);
    applyRadius(radius);
    generateUVs();
    this.setAttribute("position", new three__WEBPACK_IMPORTED_MODULE_0__.Float32BufferAttribute(vertexBuffer, 3));
    this.setAttribute("uv", new three__WEBPACK_IMPORTED_MODULE_0__.Float32BufferAttribute(uvBuffer, 2));
    if (!points_only) {
      this.setAttribute("normal", new three__WEBPACK_IMPORTED_MODULE_0__.Float32BufferAttribute(vertexBuffer.slice(), 3));
      if (detail === 0) {
        this.computeVertexNormals();
      } else {
        this.normalizeNormals();
      }
    }
    function subdivide(detail2) {
      const a = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();
      const b = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();
      const c = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();
      for (let i = 0; i < indices.length; i += 3) {
        getVertexByIndex(indices[i + 0], a);
        getVertexByIndex(indices[i + 1], b);
        getVertexByIndex(indices[i + 2], c);
        subdivideFace(a, b, c, detail2);
      }
    }
    function subdivideFace(a, b, c, detail2) {
      const cols = detail2 + 1;
      const v = [];
      for (let i = 0; i <= cols; i++) {
        v[i] = [];
        const aj = a.clone().lerp(c, i / cols);
        const bj = b.clone().lerp(c, i / cols);
        const rows = cols - i;
        for (let j = 0; j <= rows; j++) {
          if (j === 0 && i === cols) {
            v[i][j] = aj;
          } else {
            v[i][j] = aj.clone().lerp(bj, j / rows);
          }
        }
      }
      for (let i = 0; i < cols; i++) {
        for (let j = 0; j < 2 * (cols - i) - 1; j++) {
          const k = Math.floor(j / 2);
          if (j % 2 === 0) {
            pushVertex(v[i][k + 1]);
            pushVertex(v[i + 1][k]);
            pushVertex(v[i][k]);
          } else {
            pushVertex(v[i][k + 1]);
            pushVertex(v[i + 1][k + 1]);
            pushVertex(v[i + 1][k]);
          }
        }
      }
    }
    function applyRadius(radius2) {
      const vertex = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();
      for (let i = 0; i < vertexBuffer.length; i += 3) {
        vertex.x = vertexBuffer[i + 0];
        vertex.y = vertexBuffer[i + 1];
        vertex.z = vertexBuffer[i + 2];
        vertex.normalize().multiplyScalar(radius2);
        vertexBuffer[i + 0] = vertex.x;
        vertexBuffer[i + 1] = vertex.y;
        vertexBuffer[i + 2] = vertex.z;
      }
    }
    function generateUVs() {
      const vertex = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();
      for (let i = 0; i < vertexBuffer.length; i += 3) {
        vertex.x = vertexBuffer[i + 0];
        vertex.y = vertexBuffer[i + 1];
        vertex.z = vertexBuffer[i + 2];
        const u = azimuth(vertex) / 2 / Math.PI + 0.5;
        const v = inclination(vertex) / Math.PI + 0.5;
        uvBuffer.push(u, 1 - v);
      }
    }
    function pushVertex(vertex) {
      if (points_only) {
        let mx = vertices_by_pos.get(vertex.x);
        if (mx) {
          const my2 = mx.get(vertex.y);
          if (my2 && my2.has(vertex.z)) {
            return;
          }
        }
        if (!mx) {
          mx = /* @__PURE__ */ new Map();
          vertices_by_pos.set(vertex.x, mx);
        }
        let my = mx.get(vertex.y);
        if (!my) {
          my = /* @__PURE__ */ new Set();
          mx.set(vertex.y, my);
        }
        my.add(vertex.z);
      }
      vertexBuffer.push(vertex.x, vertex.y, vertex.z);
    }
    function getVertexByIndex(index, vertex) {
      const stride = index * 3;
      vertex.x = vertices[stride + 0];
      vertex.y = vertices[stride + 1];
      vertex.z = vertices[stride + 2];
    }
  }
}


/***/ }),

/***/ 9788:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "B": function() { return /* binding */ Potpack; }
/* harmony export */ });
/* harmony import */ var potpack__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(43210);


function Potpack(boxes) {
  return (0,potpack__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .Z)(boxes);
}


/***/ }),

/***/ 23276:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "e": function() { return /* binding */ DEFAULT_AMBIENT_LIGHT_PARAMS; },
/* harmony export */   "j": function() { return /* binding */ AmbientLightParamConfig; }
/* harmony export */ });
/* harmony import */ var _engine_nodes_utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(96949);
/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(21410);



const DEFAULT_AMBIENT_LIGHT_PARAMS = {
  color: new three__WEBPACK_IMPORTED_MODULE_0__.Color(1, 1, 1),
  intensity: 1,
  name: "ambientLight"
};
const DEFAULT = DEFAULT_AMBIENT_LIGHT_PARAMS;
function AmbientLightParamConfig(Base) {
  return class Mixin extends Base {
    constructor() {
      super(...arguments);
      /** @param sky color */
      this.color = _engine_nodes_utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .ParamConfig.COLOR */ .XC.COLOR(DEFAULT.color.toArray(), {
        // conversion: ColorConversion.SRGB_TO_LINEAR,
      });
      /** @param light intensity */
      this.intensity = _engine_nodes_utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .ParamConfig.FLOAT */ .XC.FLOAT(DEFAULT.intensity, {
        range: [0, 2],
        rangeLocked: [true, false]
      });
      /** @param light name */
      this.name = _engine_nodes_utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .ParamConfig.STRING */ .XC.STRING("`$OS`");
    }
  };
}


/***/ }),

/***/ 72862:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Kz": function() { return /* binding */ DEFAULT_AREA_LIGHT_PARAMS; },
/* harmony export */   "fP": function() { return /* binding */ AreaLightParamConfig; },
/* harmony export */   "x1": function() { return /* binding */ CoreRectAreaLightHelper; }
/* harmony export */ });
/* harmony import */ var _engine_nodes_utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(96949);
/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(21410);



const DEFAULT_AREA_LIGHT_PARAMS = {
  color: new three__WEBPACK_IMPORTED_MODULE_0__.Color(1, 1, 1),
  intensity: 1,
  width: 1,
  height: 1,
  showHelper: false,
  name: "areaLight"
};
const DEFAULT = DEFAULT_AREA_LIGHT_PARAMS;
function AreaLightParamConfig(Base) {
  return class Mixin extends Base {
    constructor() {
      super(...arguments);
      this.light = _engine_nodes_utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .ParamConfig.FOLDER */ .XC.FOLDER();
      /** @param light color */
      this.color = _engine_nodes_utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .ParamConfig.COLOR */ .XC.COLOR(DEFAULT.color.toArray(), {
        // conversion: ColorConversion.SRGB_TO_LINEAR,
      });
      /** @param light intensity */
      this.intensity = _engine_nodes_utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .ParamConfig.FLOAT */ .XC.FLOAT(DEFAULT.intensity, {
        range: [0, 10],
        rangeLocked: [true, false]
      });
      /** @param grid width */
      this.width = _engine_nodes_utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .ParamConfig.FLOAT */ .XC.FLOAT(DEFAULT.width, {
        range: [0, 10],
        rangeLocked: [true, false]
      });
      /** @param grid height */
      this.height = _engine_nodes_utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .ParamConfig.FLOAT */ .XC.FLOAT(DEFAULT.height, {
        range: [0, 10],
        rangeLocked: [true, false]
      });
      // helper
      /** @param toggle on to show helper */
      this.showHelper = _engine_nodes_utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .ParamConfig.BOOLEAN */ .XC.BOOLEAN(DEFAULT.showHelper);
      /** @param light name */
      this.name = _engine_nodes_utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .ParamConfig.STRING */ .XC.STRING("`$OS`");
    }
  };
}
function createLineGeo() {
  const geometry = new three__WEBPACK_IMPORTED_MODULE_0__.BufferGeometry();
  const positions = [1, 1, 0, -1, 1, 0, -1, -1, 0, 1, -1, 0, 1, 1, 0].map((i) => i * 0.5);
  geometry.setAttribute("position", new three__WEBPACK_IMPORTED_MODULE_0__.Float32BufferAttribute(positions, 3));
  geometry.computeBoundingSphere();
  return geometry;
}
function createMeshGeo() {
  const positions = [1, 1, 0, -1, 1, 0, -1, -1, 0, 1, 1, 0, -1, -1, 0, 1, -1, 0].map((i) => i * 0.5);
  const geometry = new three__WEBPACK_IMPORTED_MODULE_0__.BufferGeometry();
  geometry.setAttribute("position", new three__WEBPACK_IMPORTED_MODULE_0__.Float32BufferAttribute(positions, 3));
  geometry.computeBoundingSphere();
  return geometry;
}
class CoreRectAreaLightHelper extends three__WEBPACK_IMPORTED_MODULE_0__.Group {
  constructor(light, nodeName) {
    super();
    this.light = light;
    this.nodeName = nodeName;
    this._childMesh = new three__WEBPACK_IMPORTED_MODULE_0__.Mesh(createMeshGeo(), new three__WEBPACK_IMPORTED_MODULE_0__.MeshBasicMaterial({ side: three__WEBPACK_IMPORTED_MODULE_0__.BackSide, fog: false }));
    this._childLine = new three__WEBPACK_IMPORTED_MODULE_0__.Line(createLineGeo(), new three__WEBPACK_IMPORTED_MODULE_0__.LineBasicMaterial());
    this.matrixAutoUpdate = false;
    this._childMesh.matrixAutoUpdate = false;
    this._childLine.matrixAutoUpdate = false;
    this.name = `CoreRectAreaLightHelper_${this.nodeName}`;
    this._childMesh.name = `CoreRectAreaLightHelperChildMesh_${this.nodeName}`;
    this._childLine.name = `CoreRectAreaLightHelperChildLine_${this.nodeName}`;
    this.add(this._childMesh);
    this.add(this._childLine);
  }
  update() {
    this.scale.set(1 * this.light.width, 1 * this.light.height, 1);
    this.updateMatrix();
    this._childLine.material.color.copy(this.light.color).multiplyScalar(this.light.intensity);
    const c = this._childLine.material.color;
    const max = Math.max(c.r, c.g, c.b);
    if (max > 1)
      c.multiplyScalar(1 / max);
    this._childMesh.material.color.copy(this._childLine.material.color);
    this.matrixWorld.extractRotation(this.light.matrixWorld).scale(this.scale).copyPosition(this.light.matrixWorld);
    this._childMesh.matrixWorld.copy(this.matrixWorld);
  }
  copy(source, recursive) {
    super.copy(source, false);
    return this;
  }
  dispose() {
    this._childLine.geometry.dispose();
    this._childLine.material.dispose();
    this._childMesh.geometry.dispose();
    this._childMesh.material.dispose();
  }
  clone(recursive) {
    const cloned = new CoreRectAreaLightHelper(this.light, this.nodeName);
    cloned.updateMatrixWorld();
    cloned.copy(this, false);
    cloned.update();
    return cloned;
  }
}


/***/ }),

/***/ 98821:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "$": function() { return /* binding */ DEFAULT_HEMISPHERE_LIGHT_PARAMS; },
/* harmony export */   "A": function() { return /* binding */ HemisphereLightParamConfig; }
/* harmony export */ });
/* harmony import */ var _engine_nodes_utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(96949);
/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(21410);



const DEFAULT_HEMISPHERE_LIGHT_PARAMS = {
  skyColor: new three__WEBPACK_IMPORTED_MODULE_0__.Color(1, 1, 1),
  groundColor: new three__WEBPACK_IMPORTED_MODULE_0__.Color(0, 0, 0),
  intensity: 1,
  position: new three__WEBPACK_IMPORTED_MODULE_0__.Vector3(0, 1, 0),
  name: "hemisphereLight"
};
const DEFAULT = DEFAULT_HEMISPHERE_LIGHT_PARAMS;
function HemisphereLightParamConfig(Base) {
  return class Mixin extends Base {
    constructor() {
      super(...arguments);
      /** @param sky color */
      this.skyColor = _engine_nodes_utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .ParamConfig.COLOR */ .XC.COLOR(DEFAULT.skyColor.toArray(), {
        // conversion: ColorConversion.SRGB_TO_LINEAR,
      });
      /** @param ground color */
      this.groundColor = _engine_nodes_utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .ParamConfig.COLOR */ .XC.COLOR(DEFAULT.groundColor.toArray(), {
        // conversion: ColorConversion.SRGB_TO_LINEAR,
      });
      /** @param light intensity */
      this.intensity = _engine_nodes_utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .ParamConfig.FLOAT */ .XC.FLOAT(DEFAULT.intensity, {
        range: [0, 2],
        rangeLocked: [true, false]
      });
      /** @param light position */
      this.position = _engine_nodes_utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .ParamConfig.VECTOR3 */ .XC.VECTOR3(DEFAULT.position.toArray());
      /** @param light name */
      this.name = _engine_nodes_utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .ParamConfig.STRING */ .XC.STRING("`$OS`");
    }
  };
}


/***/ }),

/***/ 63771:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "H": function() { return /* binding */ LightProbeParamConfig; },
/* harmony export */   "O": function() { return /* binding */ DEFAULT_LIGHT_PROBE_PARAMS; }
/* harmony export */ });
/* harmony import */ var _engine_nodes_utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(96949);
/* harmony import */ var _Walker__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(742);
/* harmony import */ var _engine_poly_NodeContext__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(52070);
/* harmony import */ var _engine_poly_registers_nodes_types_Cop__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(12764);





const DEFAULT_LIGHT_PROBE_PARAMS = {
  cubeMap: new _Walker__WEBPACK_IMPORTED_MODULE_0__/* .TypedNodePathParamValue */ .jI(""),
  intensity: 1,
  name: "lightProbe"
};
const DEFAULT = DEFAULT_LIGHT_PROBE_PARAMS;
function LightProbeParamConfig(Base) {
  return class Mixin extends Base {
    constructor() {
      super(...arguments);
      /** @param cubeMap */
      this.cubeMap = _engine_nodes_utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .ParamConfig.NODE_PATH */ .XC.NODE_PATH("", {
        nodeSelection: {
          context: _engine_poly_NodeContext__WEBPACK_IMPORTED_MODULE_2__/* .NodeContext.COP */ .sy.COP,
          types: [_engine_poly_registers_nodes_types_Cop__WEBPACK_IMPORTED_MODULE_3__/* .CopType.CUBE_MAP */ .y.CUBE_MAP]
        }
      });
      /** @param light intensity */
      this.intensity = _engine_nodes_utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .ParamConfig.FLOAT */ .XC.FLOAT(DEFAULT.intensity, {
        range: [0, 2],
        rangeLocked: [true, false]
      });
      /** @param light name */
      this.name = _engine_nodes_utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .ParamConfig.STRING */ .XC.STRING("`$OS`");
    }
  };
}


/***/ }),

/***/ 35031:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {


// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  "cg": function() { return /* binding */ CorePointLightHelper; },
  "Uw": function() { return /* binding */ DEFAULT_POINT_LIGHT_PARAMS; },
  "kR": function() { return /* binding */ PointLightParamConfig; }
});

// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/nodes/utils/params/ParamsConfig.ts
var ParamsConfig = __webpack_require__(96949);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/node_modules/three/build/three.module.js
var three_module = __webpack_require__(21410);
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/core/lights/_Base.ts


const LIGHT_HELPER_MAT = new three_module.MeshBasicMaterial({ wireframe: true, fog: false });

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/core/lights/PointLight.ts




const DEFAULT_POINT_LIGHT_PARAMS = {
  color: new three_module.Color(1, 1, 1),
  intensity: 2,
  decay: 2,
  distance: 100,
  name: "pointLight",
  //
  castShadow: false,
  shadowAutoUpdate: true,
  shadowUpdateOnNextRender: false,
  shadowRes: new three_module.Vector2(1024, 1024),
  shadowBias: 1e-4,
  shadowNear: 1,
  shadowFar: 100,
  // debugShadow: false,
  //
  showHelper: false,
  helperSize: 1,
  //
  raymarchingPenumbra: 0,
  // keep as 0 by default since it's more performant
  raymarchingShadowBiasAngle: 0.01,
  raymarchingShadowBiasDistance: 0.1
};
const DEFAULT = DEFAULT_POINT_LIGHT_PARAMS;
function PointLightParamConfig(Base) {
  return class Mixin extends Base {
    constructor() {
      super(...arguments);
      this.light = ParamsConfig/* ParamConfig.FOLDER */.XC.FOLDER();
      /** @param light color */
      this.color = ParamsConfig/* ParamConfig.COLOR */.XC.COLOR(DEFAULT.color.toArray(), {
        // conversion: ColorConversion.SRGB_TO_LINEAR,
      });
      /** @param light intensity */
      this.intensity = ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(DEFAULT.intensity, {
        range: [0, 10],
        rangeLocked: [true, false]
      });
      /** @param light decay */
      this.decay = ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(DEFAULT.decay, {
        range: [0, 10],
        rangeLocked: [true, false]
      });
      /** @param light distance */
      this.distance = ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(DEFAULT.distance, {
        range: [0, 100],
        rangeLocked: [true, false]
      });
      // helper
      /** @param toggle to show helper */
      this.showHelper = ParamsConfig/* ParamConfig.BOOLEAN */.XC.BOOLEAN(DEFAULT.showHelper);
      /** @param helper size */
      this.helperSize = ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(1, { visibleIf: { showHelper: 1 } });
      /** @param light name */
      this.name = ParamsConfig/* ParamConfig.STRING */.XC.STRING("`$OS`");
      // shadows
      this.shadow = ParamsConfig/* ParamConfig.FOLDER */.XC.FOLDER();
      /** @param toggle to cast shadows */
      this.castShadow = ParamsConfig/* ParamConfig.BOOLEAN */.XC.BOOLEAN(DEFAULT.castShadow);
      /** @param toggle off if the shadows do not need to be regenerated */
      this.shadowAutoUpdate = ParamsConfig/* ParamConfig.BOOLEAN */.XC.BOOLEAN(DEFAULT.shadowAutoUpdate, {
        visibleIf: { castShadow: 1 }
      });
      /** @param press button to update the shadows on next render */
      this.shadowUpdateOnNextRender = ParamsConfig/* ParamConfig.BOOLEAN */.XC.BOOLEAN(DEFAULT.shadowUpdateOnNextRender, {
        visibleIf: { castShadow: 1, shadowAutoUpdate: 0 }
      });
      /** @param shadow res */
      this.shadowRes = ParamsConfig/* ParamConfig.VECTOR2 */.XC.VECTOR2(DEFAULT.shadowRes.toArray(), { visibleIf: { castShadow: 1 } });
      /** @param shadow bias */
      this.shadowBias = ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(DEFAULT.shadowBias, {
        visibleIf: { castShadow: 1 },
        range: [-0.01, 0.01],
        rangeLocked: [false, false]
      });
      /** @param shadow camera near */
      this.shadowNear = ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(DEFAULT.shadowNear, { visibleIf: { castShadow: 1 } });
      /** @param shadow camera far */
      this.shadowFar = ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(DEFAULT.shadowFar, { visibleIf: { castShadow: 1 } });
      /** @param display shadow on a plane behind the light */
      // debugShadow = ParamConfig.BOOLEAN(DEFAULT.debugShadow, {
      // 	visibleIf: {castShadow: 1},
      // });
      // raymarching
      this.raymarching = ParamsConfig/* ParamConfig.FOLDER */.XC.FOLDER();
      /** @param this affects the shadows cast inside raymarchingBuilder materials */
      this.raymarchingPenumbra = ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(DEFAULT.raymarchingPenumbra);
      /** @param shadow bias */
      this.raymarchingShadowBiasAngle = ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(DEFAULT.raymarchingShadowBiasAngle, {
        range: [0, 1],
        rangeLocked: [true, false]
      });
      /** @param shadow bias */
      this.raymarchingShadowBiasDistance = ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(DEFAULT.raymarchingShadowBiasDistance, {
        range: [0, 1],
        rangeLocked: [true, false]
      });
    }
  };
}
class CorePointLightHelper {
  constructor() {
    this._material = LIGHT_HELPER_MAT.clone();
    this._matrixScale = new three_module.Vector3(1, 1, 1);
  }
  createObject() {
    return new three_module.Mesh();
  }
  createAndBuildObject(options) {
    const object = this.createObject();
    this.buildHelper(object);
    this.update(object, options);
    return object;
  }
  buildHelper(object) {
    const size = 1;
    object.geometry = new three_module.SphereGeometry(size, 4, 2);
    object.matrixAutoUpdate = false;
    object.material = this._material;
    return object;
  }
  update(object, options) {
    const size = options.helperSize;
    this._matrixScale.set(size, size, size);
    object.matrix.identity();
    object.matrix.scale(this._matrixScale);
    this._material.color.copy(options.light.color);
  }
}


/***/ }),

/***/ 83260:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "a": function() { return /* binding */ CorePhysics; },
/* harmony export */   "o": function() { return /* binding */ CorePhysicsLoaded; }
/* harmony export */ });

var __async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};
let physics;
let _importStarted = false;
let _resolves = [];
function CorePhysics() {
  return __async(this, null, function* () {
    if (physics) {
      return physics;
    }
    return new Promise((resolve) => {
      if (_importStarted) {
        _resolves.push(resolve);
        return;
      }
      _importStarted = true;
      __webpack_require__.e(/* import() */ "vendors-_polygonjs_polygonjs_node_modules_dimforge_rapier3d-compat_rapier_es_js").then(__webpack_require__.bind(__webpack_require__, 95061)).then((RAPIER) => {
        RAPIER.init().then(() => {
          physics = RAPIER;
          resolve(physics);
          if (_resolves.length > 0) {
            for (const _resolve of _resolves) {
              _resolve(physics);
            }
          }
        });
      });
    });
  });
}
function CorePhysicsLoaded() {
  if (physics) {
    return physics;
  }
}


/***/ }),

/***/ 36911:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "$M": function() { return /* binding */ PhysicsRBDType; },
/* harmony export */   "$V": function() { return /* binding */ PhysicsRBDRadiusAttribute; },
/* harmony export */   "D4": function() { return /* binding */ PhysicsRBDCuboidAttribute; },
/* harmony export */   "EX": function() { return /* binding */ PHYSICS_RBD_COLLIDER_TYPES; },
/* harmony export */   "LL": function() { return /* binding */ PHYSICS_RBD_TYPES; },
/* harmony export */   "NV": function() { return /* binding */ PHYSICS_RBD_COLLIDER_TYPE_MENU_ENTRIES; },
/* harmony export */   "OL": function() { return /* binding */ PhysicsRBDHeightAttribute; },
/* harmony export */   "Uk": function() { return /* binding */ physicsAttribNameLive; },
/* harmony export */   "aq": function() { return /* binding */ PHYSICS_RBD_TYPE_MENU_ENTRIES; },
/* harmony export */   "bs": function() { return /* binding */ PhysicsRBDColliderType; },
/* harmony export */   "gy": function() { return /* binding */ CorePhysicsAttribute; },
/* harmony export */   "m3": function() { return /* binding */ PhysicsIdAttribute; }
/* harmony export */ });
/* unused harmony exports PhysicsRBDCylinderAttribute, PhysicsRBDHeightFieldAttribute, PhysicsCommonAttribute */
/* harmony import */ var _geometry_AttributeUtils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(2371);
/* harmony import */ var _geometry_CoreObjectFactory__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(17353);



var PhysicsIdAttribute = /* @__PURE__ */ ((PhysicsIdAttribute2) => {
  PhysicsIdAttribute2["WORLD"] = "PhysicsIdAttribute_worldId";
  PhysicsIdAttribute2["RBD_HANDLE"] = "PhysicsIdAttribute_rbdHandle";
  PhysicsIdAttribute2["DEBUG_WORLD"] = "PhysicsIdAttribute_debugWorldId";
  return PhysicsIdAttribute2;
})(PhysicsIdAttribute || {});
var PhysicsRBDType = /* @__PURE__ */ ((PhysicsRBDType2) => {
  PhysicsRBDType2["FIXED"] = "fixed";
  PhysicsRBDType2["DYNAMIC"] = "dynamic";
  PhysicsRBDType2["KINEMATIC_VEL"] = "kinematicVelocityBased";
  PhysicsRBDType2["KINEMATIC_POS"] = "kinematicPositionBased";
  return PhysicsRBDType2;
})(PhysicsRBDType || {});
const PHYSICS_RBD_TYPES = [
  "fixed" /* FIXED */,
  "dynamic" /* DYNAMIC */,
  "kinematicPositionBased" /* KINEMATIC_POS */,
  "kinematicVelocityBased" /* KINEMATIC_VEL */
];
const PHYSICS_RBD_TYPE_MENU_ENTRIES = PHYSICS_RBD_TYPES.map((name, value) => ({ name, value }));
var PhysicsRBDColliderType = /* @__PURE__ */ ((PhysicsRBDColliderType2) => {
  PhysicsRBDColliderType2["CAPSULE"] = "capsule";
  PhysicsRBDColliderType2["CONE"] = "cone";
  PhysicsRBDColliderType2["CONVEX_HULL"] = "convex hull";
  PhysicsRBDColliderType2["CUBOID"] = "cuboid";
  PhysicsRBDColliderType2["CYLINDER"] = "cylinder";
  PhysicsRBDColliderType2["SPHERE"] = "sphere";
  PhysicsRBDColliderType2["TRIMESH"] = "trimesh";
  PhysicsRBDColliderType2["HEIGHT_FIELD"] = "heightField";
  return PhysicsRBDColliderType2;
})(PhysicsRBDColliderType || {});
const PHYSICS_RBD_COLLIDER_TYPES = [
  "cuboid" /* CUBOID */,
  "sphere" /* SPHERE */,
  "capsule" /* CAPSULE */,
  "cylinder" /* CYLINDER */,
  "cone" /* CONE */,
  "convex hull" /* CONVEX_HULL */,
  // PhysicsRBDColliderType.CONVEX_MESH,
  "trimesh" /* TRIMESH */,
  "heightField" /* HEIGHT_FIELD */
];
const SORTED_ENTRIES = [
  "capsule" /* CAPSULE */,
  "cone" /* CONE */,
  "convex hull" /* CONVEX_HULL */,
  // PhysicsRBDColliderType.CONVEX_MESH,
  "cuboid" /* CUBOID */,
  "cylinder" /* CYLINDER */,
  "sphere" /* SPHERE */,
  "trimesh" /* TRIMESH */,
  "heightField" /* HEIGHT_FIELD */
];
const PHYSICS_RBD_COLLIDER_TYPE_MENU_ENTRIES = SORTED_ENTRIES.map((entry) => {
  return { name: entry, value: PHYSICS_RBD_COLLIDER_TYPES.indexOf(entry) };
});
var PhysicsRBDCuboidAttribute = /* @__PURE__ */ ((PhysicsRBDCuboidAttribute2) => {
  PhysicsRBDCuboidAttribute2["SIZES"] = "sizes";
  PhysicsRBDCuboidAttribute2["SIZE"] = "size";
  return PhysicsRBDCuboidAttribute2;
})(PhysicsRBDCuboidAttribute || {});
var PhysicsRBDRadiusAttribute = /* @__PURE__ */ ((PhysicsRBDRadiusAttribute2) => {
  PhysicsRBDRadiusAttribute2["RADIUS"] = "radius";
  return PhysicsRBDRadiusAttribute2;
})(PhysicsRBDRadiusAttribute || {});
var PhysicsRBDHeightAttribute = /* @__PURE__ */ ((PhysicsRBDHeightAttribute2) => {
  PhysicsRBDHeightAttribute2["HEIGHT"] = "height";
  return PhysicsRBDHeightAttribute2;
})(PhysicsRBDHeightAttribute || {});
var PhysicsRBDCylinderAttribute = /* @__PURE__ */ ((PhysicsRBDCylinderAttribute2) => {
  PhysicsRBDCylinderAttribute2["HEIGHT"] = "height";
  return PhysicsRBDCylinderAttribute2;
})(PhysicsRBDCylinderAttribute || {});
var PhysicsRBDHeightFieldAttribute = /* @__PURE__ */ ((PhysicsRBDHeightFieldAttribute2) => {
  PhysicsRBDHeightFieldAttribute2["HEIGHT_FIELD_ROWS"] = "heightFieldRows";
  PhysicsRBDHeightFieldAttribute2["HEIGHT_FIELD_COLS"] = "heightFieldCols";
  return PhysicsRBDHeightFieldAttribute2;
})(PhysicsRBDHeightFieldAttribute || {});
var PhysicsCommonAttribute = /* @__PURE__ */ ((PhysicsCommonAttribute2) => {
  PhysicsCommonAttribute2["RBD_ID"] = "RBDId";
  PhysicsCommonAttribute2["RBD_TYPE"] = "RBDType";
  PhysicsCommonAttribute2["COLLIDER_TYPE"] = "RBDColliderType";
  PhysicsCommonAttribute2["BORDER_RADIUS"] = "borderRadius";
  PhysicsCommonAttribute2["CAN_SLEEP"] = "RBDCanSleep";
  PhysicsCommonAttribute2["DENSITY"] = "density";
  PhysicsCommonAttribute2["RESTITUTION"] = "restitution";
  PhysicsCommonAttribute2["FRICTION"] = "friction";
  PhysicsCommonAttribute2["LINEAR_DAMPING"] = "linearDamping";
  PhysicsCommonAttribute2["ANGULAR_DAMPING"] = "angularDamping";
  PhysicsCommonAttribute2["LINEAR_VELOCITY"] = "linearVelocity";
  PhysicsCommonAttribute2["ANGULAR_VELOCITY"] = "angularVelocity";
  PhysicsCommonAttribute2["GRAVITY_SCALE"] = "gravityScale";
  PhysicsCommonAttribute2["CHARACTER_CONTROLLER_ID"] = "characterControllerId";
  PhysicsCommonAttribute2["CHARACTER_CONTROLLER_OFFSET"] = "characterControllerOffset";
  PhysicsCommonAttribute2["CHARACTER_CONTROLLER_APPLY_IMPULSES_TO_DYNAMIC"] = "characterControllerApplyImpulsesToDynamic";
  PhysicsCommonAttribute2["CHARACTER_CONTROLLER_SNAP_TO_GROUND_DISTANCE"] = "characterControllerSnapToGroundDistance";
  PhysicsCommonAttribute2["CHARACTER_CONTROLLER_AUTO_STEP_MAX_HEIGHT"] = "characterControllerAutoStepMaxHeight";
  PhysicsCommonAttribute2["CHARACTER_CONTROLLER_AUTO_STEP_MIN_WIDTH"] = "characterControllerAutoStepMinWidth";
  PhysicsCommonAttribute2["CHARACTER_CONTROLLER_AUTO_STEP_ON_DYNAMIC"] = "characterControllerAutoStepOnDynamic";
  PhysicsCommonAttribute2["CHARACTER_CONTROLLER_MAX_SLOPE_CLIMB_ANGLE"] = "characterControllerMaxSlopeClimbAngle";
  PhysicsCommonAttribute2["CHARACTER_CONTROLLER_MIN_SLOPE_CLIMB_ANGLE"] = "characterControllerMinSlopeSlideAngle";
  PhysicsCommonAttribute2["CHARACTER_CONTROLLER_UP"] = "characterControllerUp";
  PhysicsCommonAttribute2["CHARACTER_CONTROLLER_CAMERA_OBJECT_PATH"] = "characterControllerCameraObjectPath";
  return PhysicsCommonAttribute2;
})(PhysicsCommonAttribute || {});
function physicsAttribNameLive(attribute) {
  return `${attribute}-live`;
}
class CorePhysicsAttribute {
  static setRBDHandle(object, value) {
    (0,_geometry_AttributeUtils__WEBPACK_IMPORTED_MODULE_0__/* .setObjectNumber */ .iZ)(object, "PhysicsIdAttribute_rbdHandle" /* RBD_HANDLE */, value);
  }
  static getRBDHandle(object) {
    return (0,_geometry_AttributeUtils__WEBPACK_IMPORTED_MODULE_0__/* .getObjectNumber */ .ME)(object, "PhysicsIdAttribute_rbdHandle" /* RBD_HANDLE */, -1);
  }
  static deleteRBDHandle(object) {
    (0,_geometry_CoreObjectFactory__WEBPACK_IMPORTED_MODULE_1__/* .coreObjectClassFactory */ .Xr)(object).deleteAttribute(object, "PhysicsIdAttribute_rbdHandle" /* RBD_HANDLE */);
  }
  // common
  static setRBDId(object, value) {
    (0,_geometry_AttributeUtils__WEBPACK_IMPORTED_MODULE_0__/* .setObjectString */ .v3)(object, "RBDId" /* RBD_ID */, value);
  }
  static getRBDId(object) {
    return (0,_geometry_AttributeUtils__WEBPACK_IMPORTED_MODULE_0__/* .getObjectString */ .OW)(object, "RBDId" /* RBD_ID */);
  }
  static setRBDType(object, value) {
    (0,_geometry_AttributeUtils__WEBPACK_IMPORTED_MODULE_0__/* .setObjectString */ .v3)(object, "RBDType" /* RBD_TYPE */, value);
  }
  static getRBDType(object) {
    return (0,_geometry_AttributeUtils__WEBPACK_IMPORTED_MODULE_0__/* .getObjectString */ .OW)(object, "RBDType" /* RBD_TYPE */);
  }
  static setColliderType(object, value) {
    (0,_geometry_AttributeUtils__WEBPACK_IMPORTED_MODULE_0__/* .setObjectString */ .v3)(object, "RBDColliderType" /* COLLIDER_TYPE */, value);
  }
  static getColliderType(object) {
    return (0,_geometry_AttributeUtils__WEBPACK_IMPORTED_MODULE_0__/* .getObjectString */ .OW)(object, "RBDColliderType" /* COLLIDER_TYPE */);
  }
  static setCanSleep(object, value) {
    (0,_geometry_AttributeUtils__WEBPACK_IMPORTED_MODULE_0__/* .setObjectBoolean */ .cj)(object, "RBDCanSleep" /* CAN_SLEEP */, value);
  }
  static getCanSleep(object) {
    return (0,_geometry_AttributeUtils__WEBPACK_IMPORTED_MODULE_0__/* .getObjectBoolean */ .is)(object, "RBDCanSleep" /* CAN_SLEEP */, true);
  }
  static setDensity(object, value) {
    (0,_geometry_AttributeUtils__WEBPACK_IMPORTED_MODULE_0__/* .setObjectNumber */ .iZ)(object, "density" /* DENSITY */, value);
  }
  static getDensity(object) {
    return (0,_geometry_AttributeUtils__WEBPACK_IMPORTED_MODULE_0__/* .getObjectNumber */ .ME)(object, "density" /* DENSITY */, 1);
  }
  static setRestitution(object, value) {
    (0,_geometry_AttributeUtils__WEBPACK_IMPORTED_MODULE_0__/* .setObjectNumber */ .iZ)(object, "restitution" /* RESTITUTION */, value);
  }
  static getRestitution(object) {
    return (0,_geometry_AttributeUtils__WEBPACK_IMPORTED_MODULE_0__/* .getObjectNumber */ .ME)(object, "restitution" /* RESTITUTION */, 0.5);
  }
  static setFriction(object, value) {
    (0,_geometry_AttributeUtils__WEBPACK_IMPORTED_MODULE_0__/* .setObjectNumber */ .iZ)(object, "friction" /* FRICTION */, value);
  }
  static getFriction(object) {
    return (0,_geometry_AttributeUtils__WEBPACK_IMPORTED_MODULE_0__/* .getObjectNumber */ .ME)(object, "friction" /* FRICTION */, 0);
  }
  static setLinearDamping(object, value) {
    (0,_geometry_AttributeUtils__WEBPACK_IMPORTED_MODULE_0__/* .setObjectNumber */ .iZ)(object, "linearDamping" /* LINEAR_DAMPING */, value);
  }
  static getLinearDamping(object) {
    return (0,_geometry_AttributeUtils__WEBPACK_IMPORTED_MODULE_0__/* .getObjectNumber */ .ME)(object, "linearDamping" /* LINEAR_DAMPING */, 0);
  }
  static setAngularDamping(object, value) {
    (0,_geometry_AttributeUtils__WEBPACK_IMPORTED_MODULE_0__/* .setObjectNumber */ .iZ)(object, "angularDamping" /* ANGULAR_DAMPING */, value);
  }
  static getAngularDamping(object) {
    return (0,_geometry_AttributeUtils__WEBPACK_IMPORTED_MODULE_0__/* .getObjectNumber */ .ME)(object, "angularDamping" /* ANGULAR_DAMPING */, 0);
  }
  static setLinearVelocity(object, value) {
    (0,_geometry_AttributeUtils__WEBPACK_IMPORTED_MODULE_0__/* .setObjectVector3 */ .OY)(object, "linearVelocity" /* LINEAR_VELOCITY */, value);
  }
  static getLinearVelocity(object, target) {
    return (0,_geometry_AttributeUtils__WEBPACK_IMPORTED_MODULE_0__/* .getObjectVector3 */ .XJ)(object, "linearVelocity" /* LINEAR_VELOCITY */, target);
  }
  static setAngularVelocity(object, value) {
    (0,_geometry_AttributeUtils__WEBPACK_IMPORTED_MODULE_0__/* .setObjectVector3 */ .OY)(object, "angularVelocity" /* ANGULAR_VELOCITY */, value);
  }
  static getAngularVelocity(object, target) {
    return (0,_geometry_AttributeUtils__WEBPACK_IMPORTED_MODULE_0__/* .getObjectVector3 */ .XJ)(object, "angularVelocity" /* ANGULAR_VELOCITY */, target);
  }
  static setGravityScale(object, value) {
    (0,_geometry_AttributeUtils__WEBPACK_IMPORTED_MODULE_0__/* .setObjectNumber */ .iZ)(object, "gravityScale" /* GRAVITY_SCALE */, value);
  }
  static getGravityScale(object) {
    return (0,_geometry_AttributeUtils__WEBPACK_IMPORTED_MODULE_0__/* .getObjectNumber */ .ME)(object, "gravityScale" /* GRAVITY_SCALE */, 0);
  }
  // shapes
  static setBorderRadius(object, value) {
    (0,_geometry_AttributeUtils__WEBPACK_IMPORTED_MODULE_0__/* .setObjectNumber */ .iZ)(object, "borderRadius" /* BORDER_RADIUS */, value);
  }
  static getBorderRadius(object) {
    return (0,_geometry_AttributeUtils__WEBPACK_IMPORTED_MODULE_0__/* .getObjectNumber */ .ME)(object, "borderRadius" /* BORDER_RADIUS */, 0);
  }
  // cuboid
  static setCuboidSizes(object, value) {
    (0,_geometry_AttributeUtils__WEBPACK_IMPORTED_MODULE_0__/* .setObjectVector3 */ .OY)(object, "sizes" /* SIZES */, value);
  }
  static getCuboidSizes(object, value) {
    (0,_geometry_AttributeUtils__WEBPACK_IMPORTED_MODULE_0__/* .getObjectVector3 */ .XJ)(object, "sizes" /* SIZES */, value);
  }
  static setCuboidSize(object, value) {
    (0,_geometry_AttributeUtils__WEBPACK_IMPORTED_MODULE_0__/* .setObjectNumber */ .iZ)(object, "size" /* SIZE */, value);
  }
  static getCuboidSize(object) {
    return (0,_geometry_AttributeUtils__WEBPACK_IMPORTED_MODULE_0__/* .getObjectNumber */ .ME)(object, "size" /* SIZE */, 1);
  }
  // sphere + capsule + cylinder
  static setRadius(object, value) {
    (0,_geometry_AttributeUtils__WEBPACK_IMPORTED_MODULE_0__/* .setObjectNumber */ .iZ)(object, "radius" /* RADIUS */, value);
  }
  static getRadius(object) {
    return (0,_geometry_AttributeUtils__WEBPACK_IMPORTED_MODULE_0__/* .getObjectNumber */ .ME)(object, "radius" /* RADIUS */, 1);
  }
  // capsule + cylinder
  static setHeight(object, value) {
    (0,_geometry_AttributeUtils__WEBPACK_IMPORTED_MODULE_0__/* .setObjectNumber */ .iZ)(object, "height" /* HEIGHT */, value);
  }
  static getHeight(object) {
    return (0,_geometry_AttributeUtils__WEBPACK_IMPORTED_MODULE_0__/* .getObjectNumber */ .ME)(object, "height" /* HEIGHT */, 1);
  }
  // heightfield
  static setHeightFieldRows(object, value) {
    (0,_geometry_AttributeUtils__WEBPACK_IMPORTED_MODULE_0__/* .setObjectNumber */ .iZ)(object, "heightFieldRows" /* HEIGHT_FIELD_ROWS */, value);
  }
  static getHeightFieldRows(object) {
    return (0,_geometry_AttributeUtils__WEBPACK_IMPORTED_MODULE_0__/* .getObjectNumber */ .ME)(object, "heightFieldRows" /* HEIGHT_FIELD_ROWS */, 2);
  }
  static setHeightFieldCols(object, value) {
    (0,_geometry_AttributeUtils__WEBPACK_IMPORTED_MODULE_0__/* .setObjectNumber */ .iZ)(object, "heightFieldCols" /* HEIGHT_FIELD_COLS */, value);
  }
  static getHeightFieldCols(object) {
    return (0,_geometry_AttributeUtils__WEBPACK_IMPORTED_MODULE_0__/* .getObjectNumber */ .ME)(object, "heightFieldCols" /* HEIGHT_FIELD_COLS */, 2);
  }
  // character controller
  static setCharacterControllerId(object, value) {
    (0,_geometry_AttributeUtils__WEBPACK_IMPORTED_MODULE_0__/* .setObjectString */ .v3)(object, "characterControllerId" /* CHARACTER_CONTROLLER_ID */, value);
  }
  static getCharacterControllerId(object) {
    return (0,_geometry_AttributeUtils__WEBPACK_IMPORTED_MODULE_0__/* .getObjectString */ .OW)(object, "characterControllerId" /* CHARACTER_CONTROLLER_ID */);
  }
  static setCharacterControllerOffset(object, value) {
    (0,_geometry_AttributeUtils__WEBPACK_IMPORTED_MODULE_0__/* .setObjectNumber */ .iZ)(object, "characterControllerOffset" /* CHARACTER_CONTROLLER_OFFSET */, value);
  }
  static getCharacterControllerOffset(object) {
    return (0,_geometry_AttributeUtils__WEBPACK_IMPORTED_MODULE_0__/* .getObjectNumber */ .ME)(object, "characterControllerOffset" /* CHARACTER_CONTROLLER_OFFSET */, 0.01);
  }
  static setCharacterControllerUp(object, value) {
    (0,_geometry_AttributeUtils__WEBPACK_IMPORTED_MODULE_0__/* .setObjectVector3 */ .OY)(object, "characterControllerUp" /* CHARACTER_CONTROLLER_UP */, value);
  }
  static getCharacterControllerUp(object, target) {
    return (0,_geometry_AttributeUtils__WEBPACK_IMPORTED_MODULE_0__/* .getObjectVector3 */ .XJ)(object, "characterControllerUp" /* CHARACTER_CONTROLLER_UP */, target);
  }
  static setCharacterControllerMaxSlopeClimbAngle(object, value) {
    (0,_geometry_AttributeUtils__WEBPACK_IMPORTED_MODULE_0__/* .setObjectNumber */ .iZ)(object, "characterControllerMaxSlopeClimbAngle" /* CHARACTER_CONTROLLER_MAX_SLOPE_CLIMB_ANGLE */, value);
  }
  static getCharacterControllerMaxSlopeClimbAngle(object) {
    return (0,_geometry_AttributeUtils__WEBPACK_IMPORTED_MODULE_0__/* .getObjectNumber */ .ME)(object, "characterControllerMaxSlopeClimbAngle" /* CHARACTER_CONTROLLER_MAX_SLOPE_CLIMB_ANGLE */, 0);
  }
  static setCharacterControllerMinSlopeSlideAngle(object, value) {
    (0,_geometry_AttributeUtils__WEBPACK_IMPORTED_MODULE_0__/* .setObjectNumber */ .iZ)(object, "characterControllerMinSlopeSlideAngle" /* CHARACTER_CONTROLLER_MIN_SLOPE_CLIMB_ANGLE */, value);
  }
  static getCharacterControllerMinSlopeSlideAngle(object) {
    return (0,_geometry_AttributeUtils__WEBPACK_IMPORTED_MODULE_0__/* .getObjectNumber */ .ME)(object, "characterControllerMinSlopeSlideAngle" /* CHARACTER_CONTROLLER_MIN_SLOPE_CLIMB_ANGLE */, 0);
  }
  static setCharacterControllerApplyImpulsesToDynamic(object, value) {
    (0,_geometry_AttributeUtils__WEBPACK_IMPORTED_MODULE_0__/* .setObjectBoolean */ .cj)(object, "characterControllerApplyImpulsesToDynamic" /* CHARACTER_CONTROLLER_APPLY_IMPULSES_TO_DYNAMIC */, value);
  }
  static getCharacterControllerApplyImpulsesToDynamic(object) {
    return (0,_geometry_AttributeUtils__WEBPACK_IMPORTED_MODULE_0__/* .getObjectBoolean */ .is)(
      object,
      "characterControllerApplyImpulsesToDynamic" /* CHARACTER_CONTROLLER_APPLY_IMPULSES_TO_DYNAMIC */,
      false
    );
  }
  static setCharacterControllerSnapToGroundDistance(object, value) {
    (0,_geometry_AttributeUtils__WEBPACK_IMPORTED_MODULE_0__/* .setObjectNumber */ .iZ)(object, "characterControllerSnapToGroundDistance" /* CHARACTER_CONTROLLER_SNAP_TO_GROUND_DISTANCE */, value);
  }
  static getCharacterControllerSnapToGroundDistance(object) {
    return (0,_geometry_AttributeUtils__WEBPACK_IMPORTED_MODULE_0__/* .getObjectNumber */ .ME)(
      object,
      "characterControllerSnapToGroundDistance" /* CHARACTER_CONTROLLER_SNAP_TO_GROUND_DISTANCE */,
      0
    );
  }
  // auto step
  static setCharacterControllerAutoStepMaxHeight(object, value) {
    (0,_geometry_AttributeUtils__WEBPACK_IMPORTED_MODULE_0__/* .setObjectNumber */ .iZ)(object, "characterControllerAutoStepMaxHeight" /* CHARACTER_CONTROLLER_AUTO_STEP_MAX_HEIGHT */, value);
  }
  static getCharacterControllerAutoStepMaxHeight(object) {
    return (0,_geometry_AttributeUtils__WEBPACK_IMPORTED_MODULE_0__/* .getObjectNumber */ .ME)(object, "characterControllerAutoStepMaxHeight" /* CHARACTER_CONTROLLER_AUTO_STEP_MAX_HEIGHT */, 0);
  }
  static setCharacterControllerAutoStepMinWidth(object, value) {
    (0,_geometry_AttributeUtils__WEBPACK_IMPORTED_MODULE_0__/* .setObjectNumber */ .iZ)(object, "characterControllerAutoStepMinWidth" /* CHARACTER_CONTROLLER_AUTO_STEP_MIN_WIDTH */, value);
  }
  static getCharacterControllerAutoStepMinWidth(object) {
    return (0,_geometry_AttributeUtils__WEBPACK_IMPORTED_MODULE_0__/* .getObjectNumber */ .ME)(object, "characterControllerAutoStepMinWidth" /* CHARACTER_CONTROLLER_AUTO_STEP_MIN_WIDTH */, 0);
  }
  static setCharacterControllerAutoStepOnDynamic(object, value) {
    (0,_geometry_AttributeUtils__WEBPACK_IMPORTED_MODULE_0__/* .setObjectBoolean */ .cj)(object, "characterControllerAutoStepOnDynamic" /* CHARACTER_CONTROLLER_AUTO_STEP_ON_DYNAMIC */, value);
  }
  static getCharacterControllerAutoStepOnDynamic(object) {
    return (0,_geometry_AttributeUtils__WEBPACK_IMPORTED_MODULE_0__/* .getObjectBoolean */ .is)(
      object,
      "characterControllerAutoStepOnDynamic" /* CHARACTER_CONTROLLER_AUTO_STEP_ON_DYNAMIC */,
      false
    );
  }
  // camera
  static setCharacterControllerCameraPath(object, value) {
    (0,_geometry_AttributeUtils__WEBPACK_IMPORTED_MODULE_0__/* .setObjectString */ .v3)(object, "characterControllerCameraObjectPath" /* CHARACTER_CONTROLLER_CAMERA_OBJECT_PATH */, value);
  }
  static getCharacterControllerCameraPath(object) {
    return (0,_geometry_AttributeUtils__WEBPACK_IMPORTED_MODULE_0__/* .getObjectString */ .OW)(object, "characterControllerCameraObjectPath" /* CHARACTER_CONTROLLER_CAMERA_OBJECT_PATH */);
  }
}


/***/ }),

/***/ 74458:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Z": function() { return /* binding */ physicsCreateDebugObject; },
/* harmony export */   "t": function() { return /* binding */ updatePhysicsDebugObject; }
/* harmony export */ });
/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(21410);
/* harmony import */ var _PhysicsAttribute__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(36911);
/* harmony import */ var _PhysicsWorld__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(3338);
/* harmony import */ var _geometry_CoreObjectFactory__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(17353);





function physicsCreateDebugObject() {
  return new three__WEBPACK_IMPORTED_MODULE_0__.LineSegments(
    new three__WEBPACK_IMPORTED_MODULE_0__.BufferGeometry(),
    new three__WEBPACK_IMPORTED_MODULE_0__.LineBasicMaterial({
      color: 16777215,
      vertexColors: true
    })
  );
}
function updatePhysicsDebugObject(debugObject) {
  const nodeId = (0,_geometry_CoreObjectFactory__WEBPACK_IMPORTED_MODULE_1__/* .coreObjectClassFactory */ .Xr)(debugObject).attribValue(debugObject, _PhysicsAttribute__WEBPACK_IMPORTED_MODULE_2__/* .PhysicsIdAttribute.DEBUG_WORLD */ .m3.DEBUG_WORLD);
  if (nodeId == null) {
    return;
  }
  const world = (0,_PhysicsWorld__WEBPACK_IMPORTED_MODULE_3__/* .physicsWorldFromNodeId */ .kw)(nodeId);
  if (!world) {
    return;
  }
  const buffers = world.debugRender();
  const geometry = debugObject.geometry;
  geometry.setAttribute("position", new three__WEBPACK_IMPORTED_MODULE_0__.BufferAttribute(buffers.vertices, 3));
  geometry.setAttribute("color", new three__WEBPACK_IMPORTED_MODULE_0__.BufferAttribute(buffers.colors, 4));
}


/***/ }),

/***/ 82637:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Hk": function() { return /* binding */ _createPhysicsRBDKinematicConstraint; },
/* harmony export */   "NV": function() { return /* binding */ PHYSICS_JOINT_TYPES; },
/* harmony export */   "Vv": function() { return /* binding */ setJointDataListForWorldObject; },
/* harmony export */   "Zs": function() { return /* binding */ PhysicsJointType; },
/* harmony export */   "ff": function() { return /* binding */ PHYSICS_JOINT_TYPE_MENU_ENTRIES; },
/* harmony export */   "sW": function() { return /* binding */ physicsCreateJoints; },
/* harmony export */   "u5": function() { return /* binding */ _physicsRBDDeleteConstraints; },
/* harmony export */   "wU": function() { return /* binding */ CorePhysicsJoinAttribute; },
/* harmony export */   "zI": function() { return /* binding */ _deletePhysicsRBDKinematicConstraint; }
/* harmony export */ });
/* unused harmony exports PhysicsJointAttribute, physicsCreateJointFromJointData */
/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(21410);
/* harmony import */ var _CorePhysics__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(83260);
/* harmony import */ var _PhysicsWorld__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(3338);
/* harmony import */ var _engine_poly_Assert__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(68239);
/* harmony import */ var _geometry_AttributeUtils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(2371);
/* harmony import */ var _PhysicsAttribute__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(36911);
/* harmony import */ var _PhysicsRBD__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(30864);
/* harmony import */ var _engine_poly_PolyOnObjectsAddRemoveHooksController__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(34053);
/* harmony import */ var _SetUtils__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(55407);












var PhysicsJointType = /* @__PURE__ */ ((PhysicsJointType2) => {
  PhysicsJointType2["FIXED"] = "fixed";
  PhysicsJointType2["SPHERICAL"] = "spherical";
  PhysicsJointType2["REVOLUT"] = "revolute";
  PhysicsJointType2["PRISMATIC"] = "prismatic";
  return PhysicsJointType2;
})(PhysicsJointType || {});
const PHYSICS_JOINT_TYPES = [
  "fixed" /* FIXED */,
  "spherical" /* SPHERICAL */,
  "revolute" /* REVOLUT */,
  "prismatic" /* PRISMATIC */
];
const ALLOWED_JOIN_TYPES = ["fixed" /* FIXED */, "spherical" /* SPHERICAL */];
const PHYSICS_JOINT_TYPE_MENU_ENTRIES = ALLOWED_JOIN_TYPES.map((name, value) => ({ name, value }));
var PhysicsJointAttribute = /* @__PURE__ */ ((PhysicsJointAttribute2) => {
  PhysicsJointAttribute2["JOIN_TYPE"] = "jointType";
  PhysicsJointAttribute2["RBD_ID1"] = "rbdId1";
  PhysicsJointAttribute2["RBD_ID2"] = "rbdId2";
  PhysicsJointAttribute2["ANCHOR1"] = "anchor1";
  PhysicsJointAttribute2["ANCHOR2"] = "anchor2";
  PhysicsJointAttribute2["LIMIT"] = "limit";
  PhysicsJointAttribute2["AXIS"] = "axis";
  PhysicsJointAttribute2["FRAME1"] = "frame1";
  PhysicsJointAttribute2["FRAME2"] = "frame2";
  return PhysicsJointAttribute2;
})(PhysicsJointAttribute || {});
class CorePhysicsJoinAttribute {
  // common
  static setJoinType(object, value) {
    (0,_geometry_AttributeUtils__WEBPACK_IMPORTED_MODULE_0__/* .setObjectString */ .v3)(object, "jointType" /* JOIN_TYPE */, value);
  }
  static getJoinType(object) {
    return (0,_geometry_AttributeUtils__WEBPACK_IMPORTED_MODULE_0__/* .getObjectString */ .OW)(object, "jointType" /* JOIN_TYPE */);
  }
  static setRBDId1(object, value) {
    (0,_geometry_AttributeUtils__WEBPACK_IMPORTED_MODULE_0__/* .setObjectString */ .v3)(object, "rbdId1" /* RBD_ID1 */, value);
  }
  static getRBDId1(object) {
    return (0,_geometry_AttributeUtils__WEBPACK_IMPORTED_MODULE_0__/* .getObjectString */ .OW)(object, "rbdId1" /* RBD_ID1 */);
  }
  static setRBDId2(object, value) {
    (0,_geometry_AttributeUtils__WEBPACK_IMPORTED_MODULE_0__/* .setObjectString */ .v3)(object, "rbdId2" /* RBD_ID2 */, value);
  }
  static getRBDId2(object) {
    return (0,_geometry_AttributeUtils__WEBPACK_IMPORTED_MODULE_0__/* .getObjectString */ .OW)(object, "rbdId2" /* RBD_ID2 */);
  }
  static setAnchor1(object, value) {
    (0,_geometry_AttributeUtils__WEBPACK_IMPORTED_MODULE_0__/* .setObjectVector3 */ .OY)(object, "anchor1" /* ANCHOR1 */, value);
  }
  static getAnchor1(object, value) {
    return (0,_geometry_AttributeUtils__WEBPACK_IMPORTED_MODULE_0__/* .getObjectVector3 */ .XJ)(object, "anchor1" /* ANCHOR1 */, value);
  }
  static setAnchor2(object, value) {
    (0,_geometry_AttributeUtils__WEBPACK_IMPORTED_MODULE_0__/* .setObjectVector3 */ .OY)(object, "anchor2" /* ANCHOR2 */, value);
  }
  static getAnchor2(object, value) {
    return (0,_geometry_AttributeUtils__WEBPACK_IMPORTED_MODULE_0__/* .getObjectVector3 */ .XJ)(object, "anchor2" /* ANCHOR2 */, value);
  }
  static setLimit(object, value) {
    (0,_geometry_AttributeUtils__WEBPACK_IMPORTED_MODULE_0__/* .setObjectVector2 */ .s)(object, "limit" /* LIMIT */, value);
  }
  static getLimit(object, value) {
    return (0,_geometry_AttributeUtils__WEBPACK_IMPORTED_MODULE_0__/* .getObjectVector2 */ .W5)(object, "limit" /* LIMIT */, value);
  }
  static setAxis(object, value) {
    (0,_geometry_AttributeUtils__WEBPACK_IMPORTED_MODULE_0__/* .setObjectVector3 */ .OY)(object, "axis" /* AXIS */, value);
  }
  static getAxis(object, value) {
    return (0,_geometry_AttributeUtils__WEBPACK_IMPORTED_MODULE_0__/* .getObjectVector3 */ .XJ)(object, "axis" /* AXIS */, value);
  }
  static setFrame1(object, value) {
    (0,_geometry_AttributeUtils__WEBPACK_IMPORTED_MODULE_0__/* .setObjectVector4 */ .yI)(object, "frame1" /* FRAME1 */, value);
  }
  static getFrame1(object, value) {
    return (0,_geometry_AttributeUtils__WEBPACK_IMPORTED_MODULE_0__/* .getObjectVector4 */ .hF)(object, "frame1" /* FRAME1 */, value);
  }
  static setFrame2(object, value) {
    (0,_geometry_AttributeUtils__WEBPACK_IMPORTED_MODULE_0__/* .setObjectVector4 */ .yI)(object, "frame2" /* FRAME2 */, value);
  }
  static getFrame2(object, value) {
    return (0,_geometry_AttributeUtils__WEBPACK_IMPORTED_MODULE_0__/* .getObjectVector4 */ .hF)(object, "frame2" /* FRAME2 */, value);
  }
}
const jointDataListByWorldObject = /* @__PURE__ */ new Map();
function setJointDataListForWorldObject(scene, worldObject) {
  const nodeId = (0,_PhysicsWorld__WEBPACK_IMPORTED_MODULE_1__/* .physicsWorldNodeIdFromObject */ .m9)(worldObject);
  if (nodeId == null) {
    return;
  }
  const array = [];
  jointDataListByWorldObject.set(nodeId, array);
  const childrenToRemove = [];
  worldObject.traverse((child) => {
    const jointData = createJointDataFromJoinObject(child);
    if (jointData) {
      childrenToRemove.push(child);
      array.push(jointData);
    }
  });
  for (const child of childrenToRemove) {
    (0,_engine_poly_PolyOnObjectsAddRemoveHooksController__WEBPACK_IMPORTED_MODULE_2__/* .removeFromParent */ .x)(scene, child);
  }
}
function createJointDataFromJoinObject(object) {
  const jointType = CorePhysicsJoinAttribute.getJoinType(object);
  if (!jointType) {
    return;
  }
  const rbdId1 = CorePhysicsJoinAttribute.getRBDId1(object);
  const rbdId2 = CorePhysicsJoinAttribute.getRBDId2(object);
  if (rbdId1 == null || rbdId2 == null) {
    return;
  }
  const anchor12 = new three__WEBPACK_IMPORTED_MODULE_3__.Vector3();
  const anchor22 = new three__WEBPACK_IMPORTED_MODULE_3__.Vector3();
  CorePhysicsJoinAttribute.getAnchor1(object, anchor12);
  CorePhysicsJoinAttribute.getAnchor2(object, anchor22);
  const jointData = {
    jointType,
    rbdId1,
    rbdId2,
    anchor1: anchor12,
    anchor2: anchor22,
    data: {}
  };
  switch (jointType) {
    case "fixed" /* FIXED */: {
      const frame1 = new three__WEBPACK_IMPORTED_MODULE_3__.Vector4();
      const frame2 = new three__WEBPACK_IMPORTED_MODULE_3__.Vector4();
      CorePhysicsJoinAttribute.getFrame1(object, frame1);
      CorePhysicsJoinAttribute.getFrame1(object, frame1);
      jointData.data.fixed = { frame1, frame2 };
      return jointData;
    }
    case "prismatic" /* PRISMATIC */: {
      const axis = new three__WEBPACK_IMPORTED_MODULE_3__.Vector3();
      const limit = new three__WEBPACK_IMPORTED_MODULE_3__.Vector2();
      CorePhysicsJoinAttribute.getAxis(object, axis);
      CorePhysicsJoinAttribute.getLimit(object, limit);
      jointData.data.prismatic = { axis, limit };
      return jointData;
    }
    case "revolute" /* REVOLUT */: {
      const axis = new three__WEBPACK_IMPORTED_MODULE_3__.Vector3();
      const limit = new three__WEBPACK_IMPORTED_MODULE_3__.Vector2();
      CorePhysicsJoinAttribute.getAxis(object, axis);
      CorePhysicsJoinAttribute.getLimit(object, limit);
      jointData.data.revolut = { axis, limit };
      return jointData;
    }
    case "spherical" /* SPHERICAL */: {
      return jointData;
    }
  }
  _engine_poly_Assert__WEBPACK_IMPORTED_MODULE_4__/* .TypeAssert.unreachable */ .f.unreachable(jointType);
}
const wakeUp = true;
function physicsCreateJoints(PhysicsLib2, world, worldObject) {
  const nodeId = (0,_PhysicsWorld__WEBPACK_IMPORTED_MODULE_1__/* .physicsWorldNodeIdFromObject */ .m9)(worldObject);
  if (nodeId == null) {
    return;
  }
  const jointDataList = jointDataListByWorldObject.get(nodeId);
  if (!jointDataList) {
    return;
  }
  for (const jointData of jointDataList) {
    physicsCreateJointFromJointData(PhysicsLib2, world, jointData);
  }
}
function physicsCreateJointFromJointData(PhysicsLib2, world, jointData) {
  const { rbdId1, rbdId2 } = jointData;
  const rbd1 = (0,_PhysicsWorld__WEBPACK_IMPORTED_MODULE_1__/* .getRBDFromId */ .Ik)(rbdId1);
  const rbd2 = (0,_PhysicsWorld__WEBPACK_IMPORTED_MODULE_1__/* .getRBDFromId */ .Ik)(rbdId2);
  if (!(rbd1 && rbd2)) {
    return;
  }
  const joint = _createJoint(world, PhysicsLib2, jointData, rbd1, rbd2);
  return joint;
}
function _createJoint(world, PhysicsLib2, jointData, rbd1, rbd2) {
  const { jointType, anchor1: anchor12, anchor2: anchor22 } = jointData;
  switch (jointType) {
    case "fixed" /* FIXED */: {
      const fixedData = jointData.data.fixed;
      if (!fixedData) {
        return;
      }
      const { frame1, frame2 } = fixedData;
      const params = PhysicsLib2.JointData.fixed(anchor12, frame1, anchor22, frame2);
      const joint = world.createImpulseJoint(params, rbd1, rbd2, wakeUp);
      return joint;
    }
    case "prismatic" /* PRISMATIC */: {
      const prismaticfixedData = jointData.data.prismatic;
      if (!prismaticfixedData) {
        return;
      }
      const { axis, limit } = prismaticfixedData;
      const params = PhysicsLib2.JointData.prismatic(anchor12, anchor22, axis);
      params.limitsEnabled = true;
      params.limits = [limit.x, limit.y];
      const joint = world.createImpulseJoint(params, rbd1, rbd2, wakeUp);
      joint.setLimits(limit.x, limit.y);
      return joint;
    }
    case "revolute" /* REVOLUT */: {
      const revolutfixedData = jointData.data.revolut;
      if (!revolutfixedData) {
        return;
      }
      const { axis, limit } = revolutfixedData;
      const params = PhysicsLib2.JointData.revolute(anchor12, anchor22, axis);
      params.limitsEnabled = true;
      params.limits = [limit.x, limit.y];
      const joint = world.createImpulseJoint(params, rbd1, rbd2, wakeUp);
      joint.setLimits(limit.x, limit.y);
      return joint;
    }
    case "spherical" /* SPHERICAL */: {
      const params = PhysicsLib2.JointData.spherical(anchor12, anchor22);
      const joint = world.createImpulseJoint(params, rbd1, rbd2, wakeUp);
      return joint;
    }
  }
  _engine_poly_Assert__WEBPACK_IMPORTED_MODULE_4__/* .TypeAssert.unreachable */ .f.unreachable(jointType);
}
const anchor1 = new three__WEBPACK_IMPORTED_MODULE_3__.Vector3(0, 0, 0);
const anchor2 = new three__WEBPACK_IMPORTED_MODULE_3__.Vector3(0, 0, 0);
const _createRBDForKinematicConstraint = (options) => {
  const { world, rbdId, anchor } = options;
  const size = 0.01;
  const geometry = new three__WEBPACK_IMPORTED_MODULE_3__.BoxGeometry(size, size, size);
  const object = new three__WEBPACK_IMPORTED_MODULE_3__.Mesh(geometry, new three__WEBPACK_IMPORTED_MODULE_3__.MeshBasicMaterial());
  object.castShadow = false;
  object.receiveShadow = false;
  object.visible = false;
  object.position.copy(anchor);
  object.updateMatrix();
  object.matrixAutoUpdate = false;
  object.worldToLocal(anchor1.copy(anchor));
  const RBD_ID = `kinematicConstraint-${rbdId}-${performance.now()}`;
  _PhysicsAttribute__WEBPACK_IMPORTED_MODULE_5__/* .CorePhysicsAttribute.setDensity */ .gy.setDensity(object, 0);
  _PhysicsAttribute__WEBPACK_IMPORTED_MODULE_5__/* .CorePhysicsAttribute.setRBDType */ .gy.setRBDType(object, _PhysicsAttribute__WEBPACK_IMPORTED_MODULE_5__/* .PhysicsRBDType.KINEMATIC_POS */ .$M.KINEMATIC_POS);
  _PhysicsAttribute__WEBPACK_IMPORTED_MODULE_5__/* .CorePhysicsAttribute.setColliderType */ .gy.setColliderType(object, _PhysicsAttribute__WEBPACK_IMPORTED_MODULE_5__/* .PhysicsRBDColliderType.SPHERE */ .bs.SPHERE);
  _PhysicsAttribute__WEBPACK_IMPORTED_MODULE_5__/* .CorePhysicsAttribute.setRBDId */ .gy.setRBDId(object, RBD_ID);
  _PhysicsAttribute__WEBPACK_IMPORTED_MODULE_5__/* .CorePhysicsAttribute.setRadius */ .gy.setRadius(object, size / 2);
  const newRBDIds = (0,_PhysicsWorld__WEBPACK_IMPORTED_MODULE_1__/* .physicsCreateRBDFromWorld */ .ex)(world, object);
  return { newRBDIds, object, anchor1 };
};
function _createPhysicsRBDKinematicConstraint(rbdObject, anchor) {
  const PhysicsLib2 = (0,_CorePhysics__WEBPACK_IMPORTED_MODULE_6__/* .CorePhysicsLoaded */ .o)();
  if (!PhysicsLib2) {
    return;
  }
  const rbdId1 = _PhysicsAttribute__WEBPACK_IMPORTED_MODULE_5__/* .CorePhysicsAttribute.getRBDId */ .gy.getRBDId(rbdObject);
  if (rbdId1 == null) {
    return;
  }
  const rbd1 = (0,_PhysicsRBD__WEBPACK_IMPORTED_MODULE_7__/* ._getRBDFromObject */ .fd)(rbdObject);
  if (!rbd1) {
    return;
  }
  const world = (0,_PhysicsRBD__WEBPACK_IMPORTED_MODULE_7__/* ._getPhysicsWorldFromRBD */ .Ty)(rbdObject);
  if (!world) {
    return;
  }
  const result = _createRBDForKinematicConstraint({ world, rbdId: rbdId1, anchor });
  const rbdId2 = result.newRBDIds ? (0,_SetUtils__WEBPACK_IMPORTED_MODULE_8__/* .setFirstValue */ .$i)(result.newRBDIds) : void 0;
  if (!rbdId2) {
    return;
  }
  const jointData = {
    jointType: "spherical" /* SPHERICAL */,
    anchor1: result.anchor1,
    anchor2,
    rbdId1,
    rbdId2,
    data: {}
  };
  physicsCreateJointFromJointData(PhysicsLib2, world, jointData);
  return rbdId2;
}
function _deletePhysicsRBDKinematicConstraint(scene, object) {
  (0,_PhysicsRBD__WEBPACK_IMPORTED_MODULE_7__/* ._physicsRBDDelete */ .s6)(scene, object);
}
function _physicsRBDDeleteConstraints(rbdObject) {
  const handle = _PhysicsAttribute__WEBPACK_IMPORTED_MODULE_5__/* .CorePhysicsAttribute.getRBDHandle */ .gy.getRBDHandle(rbdObject);
  if (handle == null) {
    return;
  }
  const body = (0,_PhysicsRBD__WEBPACK_IMPORTED_MODULE_7__/* ._getRBDFromObject */ .fd)(rbdObject);
  if (!body) {
    return;
  }
  const world = (0,_PhysicsRBD__WEBPACK_IMPORTED_MODULE_7__/* ._getPhysicsWorldFromRBD */ .Ty)(rbdObject);
  if (!world) {
    return;
  }
  const wakeUp2 = true;
  const handles = [];
  world.impulseJoints.forEachJointHandleAttachedToRigidBody(handle, (jointHandle) => {
    handles.push(jointHandle);
  });
  for (const jointHandle of handles) {
    const joint = world.getImpulseJoint(jointHandle);
    if (joint) {
      world.removeImpulseJoint(joint, wakeUp2);
    }
  }
}


/***/ }),

/***/ 30864:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {


// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  "mj": function() { return /* binding */ RBDProperty; },
  "Ty": function() { return /* binding */ _getPhysicsWorldFromRBD; },
  "zu": function() { return /* binding */ _getRBDFromId; },
  "fd": function() { return /* binding */ _getRBDFromObject; },
  "lk": function() { return /* binding */ _physicsCreateRBD; },
  "BQ": function() { return /* binding */ _physicsRBDAddForce; },
  "$I": function() { return /* binding */ _physicsRBDAddForceAtPoint; },
  "qd": function() { return /* binding */ _physicsRBDAddTorque; },
  "E6": function() { return /* binding */ _physicsRBDApplyImpulse; },
  "sf": function() { return /* binding */ _physicsRBDApplyImpulseAtPoint; },
  "Gq": function() { return /* binding */ _physicsRBDApplyTorqueImpulse; },
  "s6": function() { return /* binding */ _physicsRBDDelete; },
  "ej": function() { return /* binding */ _physicsRBDResetAll; },
  "xF": function() { return /* binding */ _physicsRBDResetForces; },
  "s3": function() { return /* binding */ _physicsRBDResetTorques; },
  "LH": function() { return /* binding */ _setPhysicsRBDAngularVelocity; },
  "D7": function() { return /* binding */ _setPhysicsRBDLinearVelocity; },
  "VN": function() { return /* binding */ _setPhysicsRBDPosition; },
  "zD": function() { return /* binding */ _setPhysicsRBDRotation; },
  "e7": function() { return /* binding */ physicsUpdateRBD; }
});

// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/poly/Assert.ts
var Assert = __webpack_require__(68239);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/core/physics/PhysicsAttribute.ts
var PhysicsAttribute = __webpack_require__(36911);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/node_modules/three/build/three.module.js
var three_module = __webpack_require__(21410);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/core/physics/CorePhysics.ts
var CorePhysics = __webpack_require__(83260);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/core/physics/shapes/RBDSphere.ts
var RBDSphere = __webpack_require__(85240);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/core/physics/shapes/RBDCuboid.ts
var RBDCuboid = __webpack_require__(18708);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/core/physics/shapes/RBDCapsule.ts
var RBDCapsule = __webpack_require__(22915);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/core/physics/shapes/RBDCone.ts
var RBDCone = __webpack_require__(73299);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/core/physics/shapes/RBDCylinder.ts
var RBDCylinder = __webpack_require__(33383);
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/core/physics/shapes/RBDTrimesh.ts

function createPhysicsTriMesh(PhysicsLib2, object) {
  var _a;
  const geometry = object.geometry;
  if (!geometry) {
    return;
  }
  const position = geometry.getAttribute("position");
  if (!position) {
    return;
  }
  let indexArray = (_a = geometry.getIndex()) == null ? void 0 : _a.array;
  if (!indexArray) {
    const pointsCount = position.array.length / 3;
    indexArray = new Uint32Array(pointsCount);
    for (let i = 0; i < pointsCount; i++) {
      indexArray[i] = i;
    }
  }
  const float32ArrayPosition = new Float32Array(position.array);
  const uint32ArrayIndex = new Uint32Array(indexArray);
  return PhysicsLib2.ColliderDesc.trimesh(float32ArrayPosition, uint32ArrayIndex);
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/core/physics/shapes/ConvexHull.ts

function createPhysicsConvexHull(PhysicsLib2, object) {
  const geometry = object.geometry;
  if (!geometry) {
    return;
  }
  const nonIndexedGeometry = geometry.toNonIndexed();
  const position = nonIndexedGeometry.getAttribute("position");
  if (!position) {
    return;
  }
  const float32Array = new Float32Array(position.array);
  return PhysicsLib2.ColliderDesc.convexHull(float32Array);
}

// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/core/geometry/bvh/ThreeMeshBVHHelper.ts + 2 modules
var ThreeMeshBVHHelper = __webpack_require__(17862);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/core/math/_Module.ts
var _Module = __webpack_require__(27462);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/core/RaycastHelper.ts
var RaycastHelper = __webpack_require__(71003);
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/core/physics/shapes/HeightField.ts






const bboxSize = new three_module.Vector3();
const bboxCenter = new three_module.Vector3();
const scale = new three_module.Vector3();
const raycaster = (0,RaycastHelper/* createRaycaster */.j)();
function createPhysicsHeightField(PhysicsLib2, object) {
  const geometry = object.geometry;
  if (!geometry) {
    return;
  }
  ThreeMeshBVHHelper/* ThreeMeshBVHHelper.assignDefaultBVHIfNone */.h.assignDefaultBVHIfNone(object);
  geometry.computeBoundingBox();
  const boundingBox = geometry.boundingBox;
  if (!boundingBox) {
    return;
  }
  boundingBox.getSize(bboxSize);
  boundingBox.getCenter(bboxCenter);
  const nrows = PhysicsAttribute/* CorePhysicsAttribute.getHeightFieldRows */.gy.getHeightFieldRows(object);
  const ncols = PhysicsAttribute/* CorePhysicsAttribute.getHeightFieldCols */.gy.getHeightFieldCols(object);
  const arraySize = (nrows + 1) * (ncols + 1);
  const array = new Array(arraySize);
  raycaster.ray.direction.set(0, -1, 0);
  raycaster.ray.origin.y = boundingBox.max.y + 1;
  let i = 0;
  const maxMult = 0.99;
  const minMult = 1 - maxMult;
  for (let col = 0; col <= ncols; col++) {
    const coln = _Module/* CoreMath.clamp */.Gj.clamp(col / ncols, minMult, maxMult);
    for (let row = 0; row <= nrows; row++) {
      const rown = _Module/* CoreMath.clamp */.Gj.clamp(row / nrows, minMult, maxMult);
      raycaster.ray.origin.x = boundingBox.min.x + bboxSize.x * coln;
      raycaster.ray.origin.z = boundingBox.min.z + bboxSize.z * rown;
      const intersections = raycaster.intersectObject(object);
      let value = boundingBox.min.y;
      if (intersections) {
        const firstIntersect = intersections[0];
        if (firstIntersect) {
          value = raycaster.ray.origin.y - firstIntersect.distance;
        }
      }
      array[i] = value;
      i++;
    }
  }
  const heights = new Float32Array(array);
  scale.set(bboxSize.x, 1, bboxSize.z);
  const desc = PhysicsLib2.ColliderDesc.heightfield(nrows, ncols, heights, scale);
  desc.setTranslation(bboxCenter.x, 0, bboxCenter.z);
  return desc;
}

// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/core/reactivity/RBDPropertyReactivity.ts
var RBDPropertyReactivity = __webpack_require__(284);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/core/reactivity/ObjectPropertyReactivity.ts
var ObjectPropertyReactivity = __webpack_require__(6098);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/poly/PolyOnObjectsAddRemoveHooksController.ts
var PolyOnObjectsAddRemoveHooksController = __webpack_require__(34053);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/core/physics/PhysicsWorld.ts
var PhysicsWorld = __webpack_require__(3338);
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/core/physics/PhysicsRBD.ts

















var RBDProperty = /* @__PURE__ */ ((RBDProperty2) => {
  RBDProperty2["ANGULAR_VELOCITY"] = "angVel";
  RBDProperty2["LINEAR_VELOCITY"] = "linVel";
  RBDProperty2["POSITION"] = "position";
  RBDProperty2["ROTATION"] = "rotation";
  RBDProperty2["LINEAR_DAMPING"] = "linearDamping";
  RBDProperty2["ANGULAR_DAMPING"] = "angularDamping";
  RBDProperty2["IS_SLEEPING"] = "isSleeping";
  RBDProperty2["IS_MOVING"] = "isMoving";
  return RBDProperty2;
})(RBDProperty || {});
const tmpV3 = new three_module.Vector3();
const currentPos = new three_module.Vector3();
const currentLinearVelocity = new three_module.Vector3();
const currentAngularVelocity = new three_module.Vector3();
const newPos = new three_module.Vector3();
const newLinearVelocity = new three_module.Vector3();
const newAngularVelocity = new three_module.Vector3();
const currentQuaternion = new three_module.Quaternion();
const newQuaternion = new three_module.Quaternion();
const linearVelocity = new three_module.Vector3();
const angularVelocity = new three_module.Vector3();
const physicsRBDByRBDHandle = /* @__PURE__ */ new Map();
const worldByRBD = /* @__PURE__ */ new WeakMap();
function _createRBDFromDescAndId(world, rigidBodyDesc, rbdId) {
  const rigidBody = world.createRigidBody(rigidBodyDesc);
  const handle = rigidBody.handle;
  worldByRBD.set(rigidBody, world);
  physicsRBDByRBDHandle.set(handle, rigidBody);
  return rigidBody;
}
function _createRBDFromDescAndObject(world, rigidBodyDesc, object) {
  const rbdId = PhysicsAttribute/* CorePhysicsAttribute.getRBDId */.gy.getRBDId(object);
  const rigidBody = _createRBDFromDescAndId(world, rigidBodyDesc, rbdId);
  PhysicsAttribute/* CorePhysicsAttribute.setRBDHandle */.gy.setRBDHandle(object, rigidBody.handle);
  return rigidBody;
}
function _createRBDFromAttributes(options) {
  const { PhysicsLib: PhysicsLib2, world, object, rigidBodyById, objectsByRBD, newRBDIds } = options;
  const type = PhysicsAttribute/* CorePhysicsAttribute.getRBDType */.gy.getRBDType(object);
  if (type == null) {
    return;
  }
  const rbdType = PhysicsRBDTypeToRigidBodyType(type);
  if (rbdType == null) {
    return;
  }
  const linearDamping = PhysicsAttribute/* CorePhysicsAttribute.getLinearDamping */.gy.getLinearDamping(object);
  const angularDamping = PhysicsAttribute/* CorePhysicsAttribute.getAngularDamping */.gy.getAngularDamping(object);
  linearVelocity.set(0, 0, 0);
  angularVelocity.set(0, 0, 0);
  PhysicsAttribute/* CorePhysicsAttribute.getLinearVelocity */.gy.getLinearVelocity(object, linearVelocity);
  PhysicsAttribute/* CorePhysicsAttribute.getAngularVelocity */.gy.getAngularVelocity(object, angularVelocity);
  const gravityScale = PhysicsAttribute/* CorePhysicsAttribute.getGravityScale */.gy.getGravityScale(object);
  const canSleep = PhysicsAttribute/* CorePhysicsAttribute.getCanSleep */.gy.getCanSleep(object);
  const rigidBodyDesc = new PhysicsLib2.RigidBodyDesc(rbdType);
  rigidBodyDesc.setTranslation(object.position.x, object.position.y, object.position.z);
  rigidBodyDesc.setRotation(object.quaternion);
  rigidBodyDesc.setLinvel(linearVelocity.x, linearVelocity.y, linearVelocity.z);
  rigidBodyDesc.setAngvel(angularVelocity);
  if (linearDamping != null) {
    rigidBodyDesc.setLinearDamping(linearDamping);
  }
  if (angularDamping != null) {
    rigidBodyDesc.setAngularDamping(angularDamping);
  }
  if (gravityScale != null) {
    rigidBodyDesc.setGravityScale(gravityScale);
  }
  if (canSleep != null) {
    rigidBodyDesc.setCanSleep(canSleep);
  }
  const rigidBody = _createRBDFromDescAndObject(world, rigidBodyDesc, object);
  objectsByRBD.set(rigidBody, object);
  const rbdId = PhysicsAttribute/* CorePhysicsAttribute.getRBDId */.gy.getRBDId(object);
  if (rbdId) {
    rigidBodyById.set(rbdId, rigidBody);
    newRBDIds.add(rbdId);
  }
  return rigidBody;
}
function _createColliderDesc(PhysicsLib2, object) {
  const colliderType = PhysicsAttribute/* CorePhysicsAttribute.getColliderType */.gy.getColliderType(object);
  if (!(colliderType != null)) {
    return;
  }
  const colliderDesc = PhysicsRBDCollider(PhysicsLib2, colliderType, object);
  if (!colliderDesc) {
    console.error("no collider", object);
    return;
  }
  const restitution = PhysicsAttribute/* CorePhysicsAttribute.getRestitution */.gy.getRestitution(object);
  const friction = PhysicsAttribute/* CorePhysicsAttribute.getFriction */.gy.getFriction(object);
  const density = PhysicsAttribute/* CorePhysicsAttribute.getDensity */.gy.getDensity(object);
  if (restitution != null) {
    colliderDesc.setRestitution(restitution);
  }
  if (friction != null) {
    colliderDesc.setFriction(friction);
  }
  if (density != null) {
    colliderDesc.setDensity(density);
  }
  return colliderDesc;
}
function _getRBDFromId(rbdId) {
  const rigidBody = (0,PhysicsWorld/* getRBDFromId */.Ik)(rbdId);
  if (!rigidBody) {
    return;
  }
  return (0,PhysicsWorld/* object3DFromRBD */.T$)(rigidBody);
}
function _getRBDFromObject(object) {
  const handle = PhysicsAttribute/* CorePhysicsAttribute.getRBDHandle */.gy.getRBDHandle(object);
  if (handle == null) {
    return;
  }
  return physicsRBDByRBDHandle.get(handle);
}
function _getPhysicsWorldFromRBD(object) {
  const rbd = _getRBDFromObject(object);
  if (!rbd) {
    return;
  }
  return worldByRBD.get(rbd);
}
function _physicsRBDDelete(scene, object) {
  const handle = PhysicsAttribute/* CorePhysicsAttribute.getRBDHandle */.gy.getRBDHandle(object);
  if (handle == null) {
    return;
  }
  const body = physicsRBDByRBDHandle.get(handle);
  if (!body) {
    return;
  }
  const world = worldByRBD.get(body);
  if (!world) {
    return;
  }
  world.removeRigidBody(body);
  worldByRBD.delete(body);
  physicsRBDByRBDHandle.delete(handle);
  PhysicsAttribute/* CorePhysicsAttribute.deleteRBDHandle */.gy.deleteRBDHandle(object);
  (0,PolyOnObjectsAddRemoveHooksController/* removeFromParent */.x)(scene, object);
}
function _physicsCreateRBD(options) {
  const { PhysicsLib: PhysicsLib2, world, object, rigidBodyById, objectsByRBD, newRBDIds } = options;
  const rigidBody = _createRBDFromAttributes({
    PhysicsLib: PhysicsLib2,
    world,
    object,
    rigidBodyById,
    objectsByRBD,
    newRBDIds
  });
  if (!rigidBody) {
    for (const child of object.children) {
      _physicsCreateRBD({ PhysicsLib: PhysicsLib2, world, rigidBodyById, objectsByRBD, object: child, newRBDIds });
    }
    return;
  }
  let childrenColliderDesc;
  if (object.children.length > 0) {
    object.traverse((child) => {
      if (child != object) {
        const childColliderDesc = _createColliderDesc(PhysicsLib2, child);
        if (childColliderDesc) {
          childrenColliderDesc = childrenColliderDesc || [];
          childrenColliderDesc.push({ object: child, colliderDesc: childColliderDesc });
        }
      }
    });
  }
  const colliderDesc = _createColliderDesc(PhysicsLib2, object);
  if (!(colliderDesc || childrenColliderDesc)) {
    return;
  }
  if (colliderDesc) {
    world.createCollider(colliderDesc, rigidBody);
  }
  if (childrenColliderDesc) {
    for (const childCollider of childrenColliderDesc) {
      const collider = world.createCollider(childCollider.colliderDesc, rigidBody);
      tmpV3.copy(childCollider.object.position);
      childCollider.object.localToWorld(tmpV3);
      object.worldToLocal(tmpV3);
      collider.setTranslationWrtParent(tmpV3);
      collider.setRotationWrtParent(childCollider.object.quaternion);
    }
  }
}
function physicsUpdateRBD(object, rigidBody) {
  const position = rigidBody.translation();
  const rotation = rigidBody.rotation();
  object.position.set(position.x, position.y, position.z);
  object.quaternion.set(rotation.x, rotation.y, rotation.z, rotation.w);
  object.updateMatrix();
  updateRBDRefs(object);
}
const SIM_PROPERTIES = [
  "angVel" /* ANGULAR_VELOCITY */,
  "linVel" /* LINEAR_VELOCITY */,
  "position" /* POSITION */,
  "rotation" /* ROTATION */,
  "isSleeping" /* IS_SLEEPING */,
  "isMoving" /* IS_MOVING */
];
function updateRBDRefs(object) {
  (0,RBDPropertyReactivity/* touchRBDProperties */.lo)(object, SIM_PROPERTIES);
  (0,ObjectPropertyReactivity/* touchObjectProperties */.rP)(object, ObjectPropertyReactivity/* OBJECT_TRANSFORM_PROPERTIES */.bo);
}
function _physicsRBDApplyImpulse(object, impulse) {
  const body = _getRBDFromObject(object);
  if (!body) {
    console.warn("no rbd found");
    return;
  }
  body.applyImpulse(impulse, true);
}
function _physicsRBDApplyImpulseAtPoint(object, impulse, point) {
  const body = _getRBDFromObject(object);
  if (!body) {
    console.warn("no rbd found");
    return;
  }
  body.applyImpulseAtPoint(impulse, point, true);
}
function _physicsRBDApplyTorqueImpulse(object, impulse) {
  const body = _getRBDFromObject(object);
  if (!body) {
    console.warn("no rbd found");
    return;
  }
  body.applyTorqueImpulse(impulse, true);
}
function _physicsRBDAddForce(object, force) {
  const body = _getRBDFromObject(object);
  if (!body) {
    console.warn("no rbd found");
    return;
  }
  body.addForce(force, true);
}
function _physicsRBDAddForceAtPoint(object, force, point) {
  const body = _getRBDFromObject(object);
  if (!body) {
    console.warn("no rbd found");
    return;
  }
  body.addForceAtPoint(force, point, true);
}
function _physicsRBDAddTorque(object, torque) {
  const body = _getRBDFromObject(object);
  if (!body) {
    console.warn("no rbd found");
    return;
  }
  body.addTorque(torque, true);
}
function _physicsRBDResetAll(object, wakeup) {
  const body = _getRBDFromObject(object);
  if (!body) {
    console.warn("no rbd found");
    return;
  }
  body.resetForces(wakeup);
  body.resetTorques(wakeup);
  body.setLinvel({ x: 0, y: 0, z: 0 }, wakeup);
  body.setAngvel({ x: 0, y: 0, z: 0 }, wakeup);
}
function _physicsRBDResetForces(object, wakeup) {
  const body = _getRBDFromObject(object);
  if (!body) {
    console.warn("no rbd found");
    return;
  }
  body.resetForces(wakeup);
}
function _physicsRBDResetTorques(object, wakeup) {
  const body = _getRBDFromObject(object);
  if (!body) {
    console.warn("no rbd found");
    return;
  }
  body.resetTorques(wakeup);
}
function _setPhysicsRBDPosition(object, targetPosition, lerp) {
  const body = _getRBDFromObject(object);
  if (!body) {
    console.warn("no rbd found");
    return;
  }
  const translateFunc = body.isKinematic() ? body.setNextKinematicTranslation.bind(body) : body.setTranslation.bind(body);
  if (lerp < 1) {
    const rbdPosition = body.translation();
    currentPos.set(rbdPosition.x, rbdPosition.y, rbdPosition.z);
    newPos.copy(targetPosition);
    currentPos.lerp(newPos, lerp);
    translateFunc(currentPos, true);
  } else {
    translateFunc(targetPosition, true);
  }
  (0,RBDPropertyReactivity/* touchRBDProperty */.P)(object, "position" /* POSITION */);
}
function _setPhysicsRBDRotation(object, targetQuaternion, lerp) {
  const body = _getRBDFromObject(object);
  if (!body) {
    console.warn("no rbd found");
    return;
  }
  const rotateFunc = body.isKinematic() ? body.setNextKinematicRotation.bind(body) : body.setRotation.bind(body);
  if (lerp < 1) {
    const rbdRotation = body.rotation();
    currentQuaternion.set(rbdRotation.x, rbdRotation.y, rbdRotation.z, rbdRotation.w);
    newQuaternion.copy(currentQuaternion);
    currentQuaternion.slerp(newQuaternion, lerp);
    rotateFunc(currentQuaternion, true);
  } else {
    rotateFunc(targetQuaternion, true);
  }
  (0,RBDPropertyReactivity/* touchRBDProperty */.P)(object, "rotation" /* ROTATION */);
}
function _setPhysicsRBDLinearVelocity(object, targetVelocity, lerp) {
  const body = _getRBDFromObject(object);
  if (!body) {
    console.warn("no rbd found");
    return;
  }
  if (lerp < 1) {
    const rbdLinearVelocity = body.linvel();
    currentLinearVelocity.set(rbdLinearVelocity.x, rbdLinearVelocity.y, rbdLinearVelocity.z);
    newLinearVelocity.copy(targetVelocity);
    currentLinearVelocity.lerp(newPos, lerp);
    body.setLinvel(currentLinearVelocity, true);
  } else {
    body.setLinvel(targetVelocity, true);
  }
  (0,RBDPropertyReactivity/* touchRBDProperty */.P)(object, "linVel" /* LINEAR_VELOCITY */);
}
function _setPhysicsRBDAngularVelocity(object, targetVelocity, lerp) {
  const body = _getRBDFromObject(object);
  if (!body) {
    console.warn("no rbd found");
    return;
  }
  if (lerp < 1) {
    const rbdAngularVelocity = body.angvel();
    currentAngularVelocity.set(rbdAngularVelocity.x, rbdAngularVelocity.y, rbdAngularVelocity.z);
    newAngularVelocity.copy(targetVelocity);
    currentAngularVelocity.lerp(newPos, lerp);
    body.setAngvel(currentAngularVelocity, true);
  } else {
    body.setAngvel(targetVelocity, true);
  }
  (0,RBDPropertyReactivity/* touchRBDProperty */.P)(object, "angVel" /* ANGULAR_VELOCITY */);
}
function PhysicsRBDTypeToRigidBodyType(type) {
  var _a;
  const RigidBodyType2 = (_a = (0,CorePhysics/* CorePhysicsLoaded */.o)()) == null ? void 0 : _a.RigidBodyType;
  if (!RigidBodyType2) {
    return;
  }
  switch (type) {
    case PhysicsAttribute/* PhysicsRBDType.FIXED */.$M.FIXED: {
      return RigidBodyType2.Fixed;
    }
    case PhysicsAttribute/* PhysicsRBDType.DYNAMIC */.$M.DYNAMIC: {
      return RigidBodyType2.Dynamic;
    }
    case PhysicsAttribute/* PhysicsRBDType.KINEMATIC_POS */.$M.KINEMATIC_POS: {
      return RigidBodyType2.KinematicPositionBased;
    }
    case PhysicsAttribute/* PhysicsRBDType.KINEMATIC_VEL */.$M.KINEMATIC_VEL: {
      return RigidBodyType2.KinematicVelocityBased;
    }
  }
  Assert/* TypeAssert.unreachable */.f.unreachable(type);
}
function PhysicsRBDCollider(PhysicsLib2, colliderType, object) {
  switch (colliderType) {
    case PhysicsAttribute/* PhysicsRBDColliderType.CAPSULE */.bs.CAPSULE: {
      return (0,RBDCapsule/* createPhysicsCapsule */.kr)(PhysicsLib2, object);
    }
    case PhysicsAttribute/* PhysicsRBDColliderType.CUBOID */.bs.CUBOID: {
      return (0,RBDCuboid/* createPhysicsCuboid */.ez)(PhysicsLib2, object);
    }
    case PhysicsAttribute/* PhysicsRBDColliderType.CONE */.bs.CONE: {
      return (0,RBDCone/* createPhysicsCone */.g$)(PhysicsLib2, object);
    }
    case PhysicsAttribute/* PhysicsRBDColliderType.CONVEX_HULL */.bs.CONVEX_HULL: {
      return createPhysicsConvexHull(PhysicsLib2, object);
    }
    case PhysicsAttribute/* PhysicsRBDColliderType.TRIMESH */.bs.TRIMESH: {
      return createPhysicsTriMesh(PhysicsLib2, object);
    }
    case PhysicsAttribute/* PhysicsRBDColliderType.CYLINDER */.bs.CYLINDER: {
      return (0,RBDCylinder/* createPhysicsCylinder */.NP)(PhysicsLib2, object);
    }
    case PhysicsAttribute/* PhysicsRBDColliderType.SPHERE */.bs.SPHERE: {
      return (0,RBDSphere/* createPhysicsSphere */.AE)(PhysicsLib2, object);
    }
    case PhysicsAttribute/* PhysicsRBDColliderType.HEIGHT_FIELD */.bs.HEIGHT_FIELD: {
      return createPhysicsHeightField(PhysicsLib2, object);
    }
  }
  Assert/* TypeAssert.unreachable */.f.unreachable(colliderType);
}


/***/ }),

/***/ 3338:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Ik": function() { return /* binding */ getRBDFromId; },
/* harmony export */   "NG": function() { return /* binding */ createOrFindPhysicsWorld; },
/* harmony export */   "Ri": function() { return /* binding */ setWorldGravity; },
/* harmony export */   "T$": function() { return /* binding */ object3DFromRBD; },
/* harmony export */   "bN": function() { return /* binding */ initCorePhysicsWorld; },
/* harmony export */   "ex": function() { return /* binding */ physicsCreateRBDFromWorld; },
/* harmony export */   "kA": function() { return /* binding */ physicsCreateRBDFromWorldObject; },
/* harmony export */   "kw": function() { return /* binding */ physicsWorldFromNodeId; },
/* harmony export */   "m9": function() { return /* binding */ physicsWorldNodeIdFromObject; },
/* harmony export */   "tB": function() { return /* binding */ PHYSICS_GRAVITY_DEFAULT; },
/* harmony export */   "xR": function() { return /* binding */ stepWorld; }
/* harmony export */ });
/* unused harmony export physicsWorldFromObject */
/* harmony import */ var _CorePhysics__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(83260);
/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(21410);
/* harmony import */ var _PhysicsRBD__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(30864);
/* harmony import */ var _PhysicsJoint__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(82637);
/* harmony import */ var _PhysicsAttribute__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(36911);
/* harmony import */ var _player_PhysicsPlayer__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(23117);
/* harmony import */ var _geometry_CoreObjectFactory__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(17353);

var __async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};







const PHYSICS_GRAVITY_DEFAULT = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3(0, -9.81, 0);
const physicsworldByGraphNodeId = /* @__PURE__ */ new Map();
const objectsByRBD = /* @__PURE__ */ new WeakMap();
const rigidBodyById = /* @__PURE__ */ new Map();
function createOrFindPhysicsWorld(node, worldObject, gravity) {
  return __async(this, null, function* () {
    const nodeId = node.graphNodeId();
    const PhysicsLib2 = yield (0,_CorePhysics__WEBPACK_IMPORTED_MODULE_1__/* .CorePhysics */ .a)();
    let world = physicsworldByGraphNodeId.get(nodeId);
    if (!world) {
      world = new PhysicsLib2.World(gravity);
      physicsworldByGraphNodeId.set(nodeId, world);
    }
    return { world, PhysicsLib: PhysicsLib2 };
  });
}
function physicsWorldNodeIdFromObject(worldObject) {
  const nodeId = (0,_geometry_CoreObjectFactory__WEBPACK_IMPORTED_MODULE_2__/* .coreObjectClassFactory */ .Xr)(worldObject).attribValue(worldObject, _PhysicsAttribute__WEBPACK_IMPORTED_MODULE_3__/* .PhysicsIdAttribute.WORLD */ .m3.WORLD);
  return nodeId;
}
function physicsWorldFromObject(worldObject) {
  const nodeId = (0,_geometry_CoreObjectFactory__WEBPACK_IMPORTED_MODULE_2__/* .coreObjectClassFactory */ .Xr)(worldObject).attribValue(worldObject, _PhysicsAttribute__WEBPACK_IMPORTED_MODULE_3__/* .PhysicsIdAttribute.WORLD */ .m3.WORLD);
  if (nodeId == null) {
    return;
  }
  return physicsworldByGraphNodeId.get(nodeId);
}
function physicsWorldFromNodeId(nodeId) {
  return physicsworldByGraphNodeId.get(nodeId);
}
function initCorePhysicsWorld(PhysicsLib2, worldObject, scene) {
  const world = physicsWorldFromObject(worldObject);
  if (!world) {
    console.warn("no physicsWorld found with this object", worldObject);
    return;
  }
  _clearWorld(world);
  const children = [...worldObject.children];
  const newRBDIds = /* @__PURE__ */ new Set();
  for (const child of children) {
    (0,_PhysicsRBD__WEBPACK_IMPORTED_MODULE_4__/* ._physicsCreateRBD */ .lk)({ PhysicsLib: PhysicsLib2, world, rigidBodyById, objectsByRBD, object: child, newRBDIds });
  }
  (0,_PhysicsJoint__WEBPACK_IMPORTED_MODULE_5__/* .physicsCreateJoints */ .sW)(PhysicsLib2, world, worldObject);
  for (const child of children) {
    (0,_player_PhysicsPlayer__WEBPACK_IMPORTED_MODULE_6__/* .createOrFindPhysicsPlayer */ .AP)({ scene, object: child, PhysicsLib: PhysicsLib2, world, worldObject });
  }
}
function object3DFromRBD(rbd) {
  return objectsByRBD.get(rbd);
}
function physicsCreateRBDFromWorldObject(worldObject, object) {
  const world = physicsWorldFromObject(worldObject);
  if (!world) {
    console.warn("no physicsWorld found with this object", worldObject);
    return;
  }
  return physicsCreateRBDFromWorld(world, object);
}
function physicsCreateRBDFromWorld(world, object) {
  const PhysicsLib2 = (0,_CorePhysics__WEBPACK_IMPORTED_MODULE_1__/* .CorePhysicsLoaded */ .o)();
  if (!PhysicsLib2) {
    return;
  }
  const newRBDIds = /* @__PURE__ */ new Set();
  (0,_PhysicsRBD__WEBPACK_IMPORTED_MODULE_4__/* ._physicsCreateRBD */ .lk)({ PhysicsLib: PhysicsLib2, world, rigidBodyById, objectsByRBD, object, newRBDIds });
  return newRBDIds;
}
function getRBDFromId(rbdId) {
  return rigidBodyById.get(rbdId);
}
function _clearWorld(world) {
  const bodies = [];
  const colliders = [];
  const joints = [];
  const multiBodyJoints = [];
  world.bodies.forEach((body) => {
    bodies.push(body);
  });
  world.colliders.forEach((collider) => {
    colliders.push(collider);
  });
  world.impulseJoints.forEach((joint) => {
    joints.push(joint);
  });
  world.multibodyJoints.forEach((multiBodyJoint) => {
    multiBodyJoints.push(multiBodyJoint);
  });
  for (const body of bodies) {
    world.removeRigidBody(body);
  }
  for (const collider of colliders) {
    world.removeCollider(collider, false);
  }
  for (const joint of joints) {
    world.removeImpulseJoint(joint, false);
  }
  for (const joint of multiBodyJoints) {
    world.removeMultibodyJoint(joint, false);
  }
  (0,_player_PhysicsPlayer__WEBPACK_IMPORTED_MODULE_6__/* .clearPhysicsPlayers */ .tz)();
}
function stepWorld(worldObject) {
  const world = physicsWorldFromObject(worldObject);
  if (!world) {
    return;
  }
  world.step();
  world.bodies.forEach((body) => {
    const object = objectsByRBD.get(body);
    if (object) {
      (0,_PhysicsRBD__WEBPACK_IMPORTED_MODULE_4__/* .physicsUpdateRBD */ .e7)(object, body);
    }
  });
}
const currentGravity = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();
const newGravity = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();
function setWorldGravity(worldObject, gravity, lerp) {
  const world = physicsWorldFromObject(worldObject);
  if (!world) {
    return;
  }
  if (lerp < 1) {
    currentGravity.set(world.gravity.x, world.gravity.y, world.gravity.z);
    newGravity.copy(gravity);
    currentGravity.lerp(newGravity, lerp);
  }
  world.gravity.x = gravity.x;
  world.gravity.y = gravity.y;
  world.gravity.z = gravity.z;
}


/***/ }),

/***/ 23117:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {


// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  "nE": function() { return /* binding */ PhysicsPlayerType; },
  "tz": function() { return /* binding */ clearPhysicsPlayers; },
  "AP": function() { return /* binding */ createOrFindPhysicsPlayer; },
  "jh": function() { return /* binding */ findPhysicsPlayer; }
});

// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/core/physics/PhysicsAttribute.ts
var PhysicsAttribute = __webpack_require__(36911);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/core/physics/PhysicsRBD.ts + 3 modules
var PhysicsRBD = __webpack_require__(30864);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/node_modules/three/build/three.module.js
var three_module = __webpack_require__(21410);
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/core/physics/player/CharacterController.ts



const up = new three_module.Vector3();
function createCharacterController(world, object) {
  const offset = PhysicsAttribute/* CorePhysicsAttribute.getCharacterControllerOffset */.gy.getCharacterControllerOffset(object);
  const snapToGroundDistance = PhysicsAttribute/* CorePhysicsAttribute.getCharacterControllerSnapToGroundDistance */.gy.getCharacterControllerSnapToGroundDistance(object);
  const applyImpulsesToDynamic = PhysicsAttribute/* CorePhysicsAttribute.getCharacterControllerApplyImpulsesToDynamic */.gy.getCharacterControllerApplyImpulsesToDynamic(object);
  const autoStepMaxHeight = PhysicsAttribute/* CorePhysicsAttribute.getCharacterControllerAutoStepMaxHeight */.gy.getCharacterControllerAutoStepMaxHeight(object);
  const autoStepMinWidth = PhysicsAttribute/* CorePhysicsAttribute.getCharacterControllerAutoStepMinWidth */.gy.getCharacterControllerAutoStepMinWidth(object);
  const autoStepOnDynamic = PhysicsAttribute/* CorePhysicsAttribute.getCharacterControllerAutoStepOnDynamic */.gy.getCharacterControllerAutoStepOnDynamic(object);
  PhysicsAttribute/* CorePhysicsAttribute.getCharacterControllerUp */.gy.getCharacterControllerUp(object, up);
  const maxSlopeClimbAngle = PhysicsAttribute/* CorePhysicsAttribute.getCharacterControllerMaxSlopeClimbAngle */.gy.getCharacterControllerMaxSlopeClimbAngle(object);
  const minSlopeSlideAngle = PhysicsAttribute/* CorePhysicsAttribute.getCharacterControllerMinSlopeSlideAngle */.gy.getCharacterControllerMinSlopeSlideAngle(object);
  const characterController = world.createCharacterController(offset);
  console.log(offset, characterController);
  console.log({
    offset,
    up,
    applyImpulsesToDynamic,
    snapToGroundDistance,
    autoStepMaxHeight,
    autoStepMinWidth,
    autoStepOnDynamic,
    maxSlopeClimbAngle,
    minSlopeSlideAngle
  });
  characterController.setUp(up);
  characterController.setApplyImpulsesToDynamicBodies(applyImpulsesToDynamic);
  if (snapToGroundDistance) {
    characterController.enableSnapToGround(snapToGroundDistance);
  } else {
    characterController.disableSnapToGround();
  }
  if (autoStepMaxHeight && autoStepMinWidth) {
    characterController.enableAutostep(autoStepMaxHeight, autoStepMinWidth, autoStepOnDynamic);
  } else {
    characterController.disableAutostep();
  }
  characterController.setMaxSlopeClimbAngle(maxSlopeClimbAngle * Math.PI / 180);
  characterController.setMinSlopeSlideAngle(minSlopeSlideAngle * Math.PI / 180);
  return characterController;
}

// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/core/geometry/CorePath.ts
var CorePath = __webpack_require__(60074);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/core/camera/CoreCameraControlsController.ts
var CoreCameraControlsController = __webpack_require__(49988);
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/core/physics/player/CorePlayerPhysics.ts








const torqueLR = new three_module.Vector3();
const torqueFB = new three_module.Vector3();
const CorePlayerPhysics_up = new three_module.Vector3(0, 1, 0);
const DEFAULT_FORWARD_DIR = new three_module.Vector3(0, 0, -1);
const forwardDir = new three_module.Vector3().copy(DEFAULT_FORWARD_DIR);
const currentTarget = new three_module.Vector3();
const delta = new three_module.Vector3();
const newCameraPosition = new three_module.Vector3();
const newTarget = new three_module.Vector3();
const LERP = 0.2;
class CorePlayerPhysics {
  constructor(options) {
    this.options = options;
    // private _inputData: CorePlayerPhysicsInputData = {
    // 	forward: false,
    // 	backward: false,
    // 	left: false,
    // 	right: false,
    // 	run: false,
    // 	jump: false,
    // };
    // private _computeInputData: CorePlayerPhysicsComputeInputData = {
    // 	speed: 1,
    // 	runAllowed: true,
    // 	runSpeedMult: 2,
    // 	jumpAllowed: true,
    // 	jumpStrength: 1,
    // 	resetIfBelowThreshold: true,
    // 	resetThreshold: -5,
    // };
    // private _mass = 1;
    this._userTorques = new three_module.Vector3(0, 0, 0);
    this._userImpulses = new three_module.Vector3(0, 0, 0);
    // private _userForces = new Vector3(0, 0, 0);
    // private _velocity = new Vector3(0, 0, 0);
    this._correctedMovement = new three_module.Vector3(0, 0, 0);
    this.startPosition = new three_module.Vector3();
    this.object = options.object;
    this.PhysicsLib = options.PhysicsLib;
    this.world = options.world;
    this.body = options.body;
    this.collider = options.collider;
    this.startPosition.copy(this.object.position);
    if (options.type == PhysicsPlayerType.CHARACTER_CONTROLLER) {
      this.characterController = createCharacterController(this.world, this.object);
      this.onGround = this.onGroundWithCharacterController;
      this.update = this.updateWithCharacterController;
    } else {
      this.onGround = this.onGroundWithTorque;
      this.update = this.updateWithTorque;
      this.initWithTorque(options.worldObject, options.scene);
    }
  }
  dispose() {
    if (this.characterController) {
      this.world.removeCharacterController(this.characterController);
    }
  }
  // setComputeInputData(data: CorePlayerPhysicsComputeInputData) {
  // 	this._computeInputData.speed = data.speed;
  // 	this._computeInputData.runAllowed = data.runAllowed;
  // 	this._computeInputData.runSpeedMult = data.runSpeedMult;
  // 	this._computeInputData.jumpAllowed = data.jumpAllowed;
  // 	this._computeInputData.jumpStrength = data.jumpStrength;
  // }
  _computeForwardDirAndUpdateCamera() {
    if (!this.cameraAndControls) {
      forwardDir.copy(DEFAULT_FORWARD_DIR);
      return;
    }
    const { camera, controlsNode } = this.cameraAndControls;
    forwardDir.set(0, 0, -1).unproject(camera).sub(camera.position);
    forwardDir.y = 0;
    forwardDir.normalize();
    if (controlsNode.target && controlsNode.setTarget) {
      controlsNode.target(currentTarget);
      delta.copy(this.object.position).sub(currentTarget);
      newCameraPosition.copy(camera.position).add(delta);
      camera.position.lerp(newCameraPosition, LERP);
      newTarget.copy(currentTarget).lerp(this.object.position, LERP);
      controlsNode.setTarget(newTarget);
    }
  }
  /**
   *
   * torque
   *
   */
  initWithTorque(worldObject, scene) {
    const cameraPath = PhysicsAttribute/* CorePhysicsAttribute.getCharacterControllerCameraPath */.gy.getCharacterControllerCameraPath(this.object);
    if (cameraPath == null) {
      return;
    }
    const camera = CorePath/* CorePath.findObjectByMaskInObject */.Oj.findObjectByMaskInObject(`*/${cameraPath}`, worldObject);
    if (!camera) {
      return;
    }
    const controlsNode = CoreCameraControlsController/* CoreCameraControlsController.controlsNode */.a.controlsNode({ camera, scene });
    if (!controlsNode) {
      return;
    }
    this.cameraAndControls = { camera, controlsNode };
  }
  onGroundWithTorque() {
    return Math.abs(this.body.linvel().y) < 0.1;
  }
  // setInputDataWithTorque(inputData: CorePlayerPhysicsInputData) {
  // 	this._computeForwardDirAndUpdateCamera();
  // 	// this._inputData.left = inputData.left;
  // 	// this._inputData.right = inputData.right;
  // 	// this._inputData.backward = inputData.backward;
  // 	// this._inputData.forward = inputData.forward;
  // }
  updateWithTorque(computeInputData, inputData, delta2) {
    this._computeForwardDirAndUpdateCamera();
    this._userTorques.set(0, 0, 0);
    this._userImpulses.set(0, 0, 0);
    const running = computeInputData.runAllowed && inputData.run;
    if (computeInputData.jumpAllowed && inputData.jump && this.onGround()) {
      this._userImpulses.y += computeInputData.jumpStrength * 100;
    }
    const speed = running ? computeInputData.speed * computeInputData.runSpeedMult : computeInputData.speed;
    if (inputData.left && !inputData.right) {
      torqueLR.copy(forwardDir).multiplyScalar(-speed);
      this._userTorques.add(torqueLR);
    } else {
      if (inputData.right && !inputData.left) {
        torqueLR.copy(forwardDir).multiplyScalar(speed);
        this._userTorques.add(torqueLR);
      }
    }
    if (inputData.forward && !inputData.backward) {
      torqueFB.copy(forwardDir).cross(CorePlayerPhysics_up).normalize().multiplyScalar(-speed);
      this._userTorques.add(torqueFB);
    } else {
      if (inputData.backward && !inputData.forward) {
        torqueFB.copy(forwardDir).cross(CorePlayerPhysics_up).normalize().multiplyScalar(speed);
        this._userTorques.add(torqueFB);
      }
    }
    if (computeInputData.resetIfBelowThreshold) {
      if (this.body.translation().y < computeInputData.resetThreshold) {
        (0,PhysicsRBD/* _physicsRBDResetAll */.ej)(this.object, true);
        this.body.setTranslation(this.startPosition, true);
      }
    }
    this.body.applyTorqueImpulse(this._userTorques, true);
    this.body.applyImpulse(this._userImpulses, true);
  }
  /**
   *
   * character controller
   *
   */
  onGroundWithCharacterController() {
    return Math.abs(this._correctedMovement.y) < 0.01;
  }
  setInputDataWithCharacterController(inputData) {
  }
  updateWithCharacterController(computeData, inputData, delta2) {
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/core/physics/player/PhysicsPlayer.ts




const physicsCharacterControllerByIdByObjectUuid = /* @__PURE__ */ new Map();
var PhysicsPlayerType = /* @__PURE__ */ ((PhysicsPlayerType2) => {
  PhysicsPlayerType2["CHARACTER_CONTROLLER"] = "characterController";
  PhysicsPlayerType2["TORQUE"] = "torque";
  return PhysicsPlayerType2;
})(PhysicsPlayerType || {});
function clearPhysicsPlayers() {
  physicsCharacterControllerByIdByObjectUuid.forEach((map, id) => {
    map.forEach((player) => {
      player.dispose();
    });
    map.clear();
  });
  physicsCharacterControllerByIdByObjectUuid.clear();
}
function createOrFindPhysicsPlayer(options) {
  const { scene, object, PhysicsLib: PhysicsLib2, world, worldObject } = options;
  let player = findPhysicsPlayer(object);
  if (!player) {
    const characterControllerId = PhysicsAttribute/* CorePhysicsAttribute.getCharacterControllerId */.gy.getCharacterControllerId(object);
    if (!characterControllerId) {
      return;
    }
    const body = (0,PhysicsRBD/* _getRBDFromObject */.fd)(object);
    if (!body) {
      return;
    }
    const collider = body.collider(0);
    if (!collider) {
      return;
    }
    player = new CorePlayerPhysics({
      scene,
      object,
      PhysicsLib: PhysicsLib2,
      world,
      worldObject,
      body,
      collider,
      type: "torque" /* TORQUE */
    });
    let map = physicsCharacterControllerByIdByObjectUuid.get(characterControllerId);
    if (!map) {
      map = /* @__PURE__ */ new Map();
      physicsCharacterControllerByIdByObjectUuid.set(characterControllerId, map);
    }
    map.set(object.uuid, player);
  }
  return player;
}
function findPhysicsPlayer(object) {
  var _a;
  const characterControllerId = PhysicsAttribute/* CorePhysicsAttribute.getCharacterControllerId */.gy.getCharacterControllerId(object);
  if (!characterControllerId) {
    return;
  }
  return (_a = physicsCharacterControllerByIdByObjectUuid.get(characterControllerId)) == null ? void 0 : _a.get(object.uuid);
}


/***/ }),

/***/ 22915:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ND": function() { return /* binding */ RBDCapsuleProperty; },
/* harmony export */   "QL": function() { return /* binding */ _getPhysicsRBDCapsuleRadius; },
/* harmony export */   "bm": function() { return /* binding */ _setPhysicsRBDCapsuleProperty; },
/* harmony export */   "kr": function() { return /* binding */ createPhysicsCapsule; }
/* harmony export */ });
/* unused harmony exports currentHeight, currentRadius, _getPhysicsRBDCapsuleHeight */
/* harmony import */ var _PhysicsAttribute__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(36911);
/* harmony import */ var _PhysicsRBD__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(30864);
/* harmony import */ var _reactivity_RBDPropertyReactivity__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(284);
/* harmony import */ var _geometry_CoreObjectFactory__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(17353);





var RBDCapsuleProperty = /* @__PURE__ */ ((RBDCapsuleProperty2) => {
  RBDCapsuleProperty2["RADIUS"] = "radius";
  RBDCapsuleProperty2["HEIGHT"] = "height";
  return RBDCapsuleProperty2;
})(RBDCapsuleProperty || {});
const EXPECTED_TYPE = _PhysicsAttribute__WEBPACK_IMPORTED_MODULE_0__/* .PhysicsRBDColliderType.CAPSULE */ .bs.CAPSULE;
function createPhysicsCapsule(PhysicsLib2, object) {
  const halfHeight = _PhysicsAttribute__WEBPACK_IMPORTED_MODULE_0__/* .CorePhysicsAttribute.getHeight */ .gy.getHeight(object) * 0.5 * object.scale.y;
  const radius = _PhysicsAttribute__WEBPACK_IMPORTED_MODULE_0__/* .CorePhysicsAttribute.getRadius */ .gy.getRadius(object) * object.scale.x;
  return PhysicsLib2.ColliderDesc.capsule(halfHeight, radius);
}
const attributeHeightLive = (0,_PhysicsAttribute__WEBPACK_IMPORTED_MODULE_0__/* .physicsAttribNameLive */ .Uk)(_PhysicsAttribute__WEBPACK_IMPORTED_MODULE_0__/* .PhysicsRBDHeightAttribute.HEIGHT */ .OL.HEIGHT);
const attributeRadiusLive = (0,_PhysicsAttribute__WEBPACK_IMPORTED_MODULE_0__/* .physicsAttribNameLive */ .Uk)(_PhysicsAttribute__WEBPACK_IMPORTED_MODULE_0__/* .PhysicsRBDRadiusAttribute.RADIUS */ .$V.RADIUS);
function currentHeight(object, collider) {
  const coreObjectClass = coreObjectClassFactory(object);
  let _currentHeight = coreObjectClass.attribValue(object, attributeHeightLive);
  if (_currentHeight == null) {
    const shape = collider.shape;
    _currentHeight = shape.halfHeight * 2;
    coreObjectClass.setAttribute(object, attributeHeightLive, _currentHeight);
  }
  return _currentHeight;
}
function currentRadius(object, collider) {
  const coreObjectClass = (0,_geometry_CoreObjectFactory__WEBPACK_IMPORTED_MODULE_1__/* .coreObjectClassFactory */ .Xr)(object);
  let _currentRadius = coreObjectClass.attribValue(object, attributeRadiusLive);
  if (_currentRadius == null) {
    const shape = collider.shape;
    _currentRadius = shape.radius;
    coreObjectClass.setAttribute(object, attributeRadiusLive, _currentRadius);
  }
  return _currentRadius;
}
function _getPhysicsRBDCapsuleHeight(object) {
  const body = _getRBDFromObject(object);
  if (!body) {
    console.warn("no rbd found");
    return;
  }
  const colliderType = CorePhysicsAttribute.getColliderType(object);
  if (colliderType == null || colliderType != EXPECTED_TYPE) {
    return;
  }
  const collider = body.collider(0);
  if (!collider) {
    return;
  }
  return currentHeight(object, collider);
}
function _getPhysicsRBDCapsuleRadius(object) {
  const body = (0,_PhysicsRBD__WEBPACK_IMPORTED_MODULE_2__/* ._getRBDFromObject */ .fd)(object);
  if (!body) {
    console.warn("no rbd found");
    return;
  }
  const colliderType = _PhysicsAttribute__WEBPACK_IMPORTED_MODULE_0__/* .CorePhysicsAttribute.getColliderType */ .gy.getColliderType(object);
  if (colliderType == null || colliderType != EXPECTED_TYPE) {
    return;
  }
  const collider = body.collider(0);
  if (!collider) {
    return;
  }
  return currentRadius(object, collider);
}
function _setPhysicsRBDCapsuleProperty(object, targetScale, lerp, updateObjectMatrix) {
  const body = (0,_PhysicsRBD__WEBPACK_IMPORTED_MODULE_2__/* ._getRBDFromObject */ .fd)(object);
  if (!body) {
    console.warn("no rbd found");
    return;
  }
  const colliderType = _PhysicsAttribute__WEBPACK_IMPORTED_MODULE_0__/* .CorePhysicsAttribute.getColliderType */ .gy.getColliderType(object);
  if (colliderType == null || colliderType != EXPECTED_TYPE) {
    return;
  }
  const collidersCount = body.numColliders();
  const originalHeightAttrib = _PhysicsAttribute__WEBPACK_IMPORTED_MODULE_0__/* .CorePhysicsAttribute.getHeight */ .gy.getHeight(object);
  const originalRadiusAttrib = _PhysicsAttribute__WEBPACK_IMPORTED_MODULE_0__/* .CorePhysicsAttribute.getRadius */ .gy.getRadius(object);
  for (let i = 0; i < collidersCount; i++) {
    const collider = body.collider(i);
    if (!collider) {
      return;
    }
    let targetRadius = targetScale;
    if (lerp < 1) {
      targetRadius = lerp * targetRadius + (1 - lerp) * currentRadius(object, collider);
    }
    const radiusRatio = targetRadius / originalRadiusAttrib;
    const targetHeight = 0.5 * radiusRatio * originalHeightAttrib;
    collider.setHalfHeight(targetHeight);
    collider.setRadius(targetRadius);
    const coreObjectClass = (0,_geometry_CoreObjectFactory__WEBPACK_IMPORTED_MODULE_1__/* .coreObjectClassFactory */ .Xr)(object);
    coreObjectClass.setAttribute(object, attributeHeightLive, targetHeight);
    coreObjectClass.setAttribute(object, attributeRadiusLive, targetRadius);
    (0,_reactivity_RBDPropertyReactivity__WEBPACK_IMPORTED_MODULE_3__/* .touchRBDProperty */ .P)(object, "height" /* HEIGHT */);
    (0,_reactivity_RBDPropertyReactivity__WEBPACK_IMPORTED_MODULE_3__/* .touchRBDProperty */ .P)(object, "radius" /* RADIUS */);
    object.scale.set(radiusRatio, radiusRatio, radiusRatio);
    if (updateObjectMatrix) {
      object.updateMatrix();
    }
  }
}


/***/ }),

/***/ 73299:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "DH": function() { return /* binding */ _setPhysicsRBDConeProperty; },
/* harmony export */   "g$": function() { return /* binding */ createPhysicsCone; },
/* harmony export */   "mI": function() { return /* binding */ _getPhysicsRBDConeRadius; },
/* harmony export */   "rj": function() { return /* binding */ _getPhysicsRBDConeHeight; }
/* harmony export */ });
/* harmony import */ var _PhysicsAttribute__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(36911);
/* harmony import */ var _CommonHeightRadius__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(42971);



const EXPECTED_TYPE = _PhysicsAttribute__WEBPACK_IMPORTED_MODULE_0__/* .PhysicsRBDColliderType.CONE */ .bs.CONE;
function createPhysicsCone(PhysicsLib2, object) {
  const halfHeight = _PhysicsAttribute__WEBPACK_IMPORTED_MODULE_0__/* .CorePhysicsAttribute.getHeight */ .gy.getHeight(object) * 0.5 * object.scale.y;
  const radius = _PhysicsAttribute__WEBPACK_IMPORTED_MODULE_0__/* .CorePhysicsAttribute.getRadius */ .gy.getRadius(object) * object.scale.x;
  const borderRadius = _PhysicsAttribute__WEBPACK_IMPORTED_MODULE_0__/* .CorePhysicsAttribute.getBorderRadius */ .gy.getBorderRadius(object);
  if (borderRadius <= 0) {
    return PhysicsLib2.ColliderDesc.cone(halfHeight, radius);
  } else {
    const borderRadius2 = Math.min(borderRadius, Math.min(halfHeight, radius));
    const halfHeight2 = halfHeight - borderRadius2;
    const radius2 = radius - borderRadius2;
    return PhysicsLib2.ColliderDesc.roundCone(halfHeight2, radius2, borderRadius2);
  }
}
function _getPhysicsRBDConeHeight(object) {
  return (0,_CommonHeightRadius__WEBPACK_IMPORTED_MODULE_1__/* .getPhysicsRBDHeight */ .dJ)(EXPECTED_TYPE, object);
}
function _getPhysicsRBDConeRadius(object) {
  return (0,_CommonHeightRadius__WEBPACK_IMPORTED_MODULE_1__/* .getPhysicsRBDRadius */ .fx)(EXPECTED_TYPE, object);
}
function _setPhysicsRBDConeProperty(object, targetRadius, targetHeight, lerp, updateObjectMatrix) {
  (0,_CommonHeightRadius__WEBPACK_IMPORTED_MODULE_1__/* .setPhysicsRBDHeightRadiusProperty */ .Q7)(EXPECTED_TYPE, object, targetRadius, targetHeight, lerp, updateObjectMatrix);
}


/***/ }),

/***/ 18708:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Sc": function() { return /* binding */ _setPhysicsRBDCuboidProperty; },
/* harmony export */   "ez": function() { return /* binding */ createPhysicsCuboid; },
/* harmony export */   "oF": function() { return /* binding */ RBDCuboidProperty; },
/* harmony export */   "zk": function() { return /* binding */ _getPhysicsRBDCuboidSizes; }
/* harmony export */ });
/* unused harmony export currentSizes */
/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(21410);
/* harmony import */ var _PhysicsAttribute__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(36911);
/* harmony import */ var _PhysicsRBD__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(30864);
/* harmony import */ var _reactivity_RBDPropertyReactivity__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(284);
/* harmony import */ var _geometry_CoreObjectFactory__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(17353);






const EXPECTED_TYPE = _PhysicsAttribute__WEBPACK_IMPORTED_MODULE_0__/* .PhysicsRBDColliderType.CUBOID */ .bs.CUBOID;
var RBDCuboidProperty = /* @__PURE__ */ ((RBDCuboidProperty2) => {
  RBDCuboidProperty2["SIZES"] = "sizes";
  return RBDCuboidProperty2;
})(RBDCuboidProperty || {});
const tmp = new three__WEBPACK_IMPORTED_MODULE_1__.Vector3();
let _currentSizes = new three__WEBPACK_IMPORTED_MODULE_1__.Vector3();
let _targetSizes = new three__WEBPACK_IMPORTED_MODULE_1__.Vector3();
let _targetHalfSizes = new three__WEBPACK_IMPORTED_MODULE_1__.Vector3();
let _originalSizes = new three__WEBPACK_IMPORTED_MODULE_1__.Vector3();
const SAFETY_OFFSET = 1e-3;
const attribSizeLiveByObject = /* @__PURE__ */ new WeakMap();
function _getAttribSizeLiveByObject(object3D) {
  let v = attribSizeLiveByObject.get(object3D);
  if (!v) {
    v = new three__WEBPACK_IMPORTED_MODULE_1__.Vector3();
    attribSizeLiveByObject.set(object3D, v);
  }
  return v;
}
function createPhysicsCuboid(PhysicsLib2, object) {
  _PhysicsAttribute__WEBPACK_IMPORTED_MODULE_0__/* .CorePhysicsAttribute.getCuboidSizes */ .gy.getCuboidSizes(object, tmp);
  const size = _PhysicsAttribute__WEBPACK_IMPORTED_MODULE_0__/* .CorePhysicsAttribute.getCuboidSize */ .gy.getCuboidSize(object);
  tmp.multiplyScalar(size * 0.5);
  tmp.multiply(object.scale);
  const borderRadius = _PhysicsAttribute__WEBPACK_IMPORTED_MODULE_0__/* .CorePhysicsAttribute.getBorderRadius */ .gy.getBorderRadius(object);
  if (borderRadius <= 0) {
    return PhysicsLib2.ColliderDesc.cuboid(tmp.x, tmp.y, tmp.z);
  } else {
    const minDim = Math.min(tmp.x, tmp.y, tmp.z);
    const borderRadiusAdjusted = Math.min(borderRadius, minDim - SAFETY_OFFSET);
    tmp.subScalar(borderRadiusAdjusted);
    return PhysicsLib2.ColliderDesc.roundCuboid(tmp.x, tmp.y, tmp.z, borderRadiusAdjusted);
  }
}
const attributeSizesLive = (0,_PhysicsAttribute__WEBPACK_IMPORTED_MODULE_0__/* .physicsAttribNameLive */ .Uk)(_PhysicsAttribute__WEBPACK_IMPORTED_MODULE_0__/* .PhysicsRBDCuboidAttribute.SIZES */ .D4.SIZES);
function currentSizes(object, collider, target) {
  const coreObjectClass = (0,_geometry_CoreObjectFactory__WEBPACK_IMPORTED_MODULE_2__/* .coreObjectClassFactory */ .Xr)(object);
  let result = coreObjectClass.attribValue(object, attributeSizesLive, 0, target);
  if (result == null) {
    const shape = collider.shape;
    const v = shape.halfExtents;
    target.set(v.x, v.y, v.z).multiplyScalar(2);
    coreObjectClass.setAttribute(object, attributeSizesLive, new three__WEBPACK_IMPORTED_MODULE_1__.Vector3().copy(target));
  }
}
function _getPhysicsRBDCuboidSizes(object, target) {
  const body = (0,_PhysicsRBD__WEBPACK_IMPORTED_MODULE_3__/* ._getRBDFromObject */ .fd)(object);
  if (!body) {
    console.warn("no rbd found");
    return;
  }
  const colliderType = _PhysicsAttribute__WEBPACK_IMPORTED_MODULE_0__/* .CorePhysicsAttribute.getColliderType */ .gy.getColliderType(object);
  if (colliderType == null || colliderType != EXPECTED_TYPE) {
    return;
  }
  const collider = body.collider(0);
  if (!collider) {
    return;
  }
  currentSizes(object, collider, target);
}
function _setPhysicsRBDCuboidProperty(object, targetSizes, targetSize, lerp, updateObjectMatrix) {
  const body = (0,_PhysicsRBD__WEBPACK_IMPORTED_MODULE_3__/* ._getRBDFromObject */ .fd)(object);
  if (!body) {
    console.warn("no rbd found");
    return;
  }
  const colliderType = _PhysicsAttribute__WEBPACK_IMPORTED_MODULE_0__/* .CorePhysicsAttribute.getColliderType */ .gy.getColliderType(object);
  if (colliderType == null || colliderType != EXPECTED_TYPE) {
    return;
  }
  const collidersCount = body.numColliders();
  _PhysicsAttribute__WEBPACK_IMPORTED_MODULE_0__/* .CorePhysicsAttribute.getCuboidSizes */ .gy.getCuboidSizes(object, _originalSizes);
  const originalSize = _PhysicsAttribute__WEBPACK_IMPORTED_MODULE_0__/* .CorePhysicsAttribute.getCuboidSize */ .gy.getCuboidSize(object);
  _originalSizes.multiplyScalar(originalSize);
  for (let i = 0; i < collidersCount; i++) {
    const collider = body.collider(i);
    if (!collider) {
      return;
    }
    _targetSizes.copy(targetSizes).multiplyScalar(targetSize);
    if (lerp < 1) {
      currentSizes(object, collider, _currentSizes);
      _targetSizes.lerp(_currentSizes, 1 - lerp);
    }
    const v = _getAttribSizeLiveByObject(object);
    v.copy(_targetSizes);
    const coreObjectClass = (0,_geometry_CoreObjectFactory__WEBPACK_IMPORTED_MODULE_2__/* .coreObjectClassFactory */ .Xr)(object);
    coreObjectClass.setAttribute(object, attributeSizesLive, v);
    (0,_reactivity_RBDPropertyReactivity__WEBPACK_IMPORTED_MODULE_4__/* .touchRBDProperty */ .P)(object, "sizes" /* SIZES */);
    object.scale.copy(_targetSizes).divide(_originalSizes);
    if (updateObjectMatrix) {
      object.updateMatrix();
    }
    _targetHalfSizes.copy(_targetSizes).multiplyScalar(0.5);
    collider.setHalfExtents(_targetHalfSizes);
  }
}


/***/ }),

/***/ 33383:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "KM": function() { return /* binding */ _getPhysicsRBDCylinderRadius; },
/* harmony export */   "NP": function() { return /* binding */ createPhysicsCylinder; },
/* harmony export */   "bI": function() { return /* binding */ _getPhysicsRBDCylinderHeight; },
/* harmony export */   "dV": function() { return /* binding */ _setPhysicsRBDCylinderProperty; }
/* harmony export */ });
/* harmony import */ var _PhysicsAttribute__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(36911);
/* harmony import */ var _CommonHeightRadius__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(42971);



const EXPECTED_TYPE = _PhysicsAttribute__WEBPACK_IMPORTED_MODULE_0__/* .PhysicsRBDColliderType.CYLINDER */ .bs.CYLINDER;
function createPhysicsCylinder(PhysicsLib2, object) {
  const halfHeight = _PhysicsAttribute__WEBPACK_IMPORTED_MODULE_0__/* .CorePhysicsAttribute.getHeight */ .gy.getHeight(object) * 0.5 * object.scale.y;
  const radius = _PhysicsAttribute__WEBPACK_IMPORTED_MODULE_0__/* .CorePhysicsAttribute.getRadius */ .gy.getRadius(object) * object.scale.x;
  const borderRadius = _PhysicsAttribute__WEBPACK_IMPORTED_MODULE_0__/* .CorePhysicsAttribute.getBorderRadius */ .gy.getBorderRadius(object);
  if (borderRadius <= 0) {
    return PhysicsLib2.ColliderDesc.cylinder(halfHeight, radius);
  } else {
    const borderRadius2 = Math.min(borderRadius, Math.min(halfHeight, radius));
    const halfHeight2 = halfHeight - borderRadius2;
    const radius2 = radius - borderRadius2;
    return PhysicsLib2.ColliderDesc.roundCylinder(halfHeight2, radius2, borderRadius2);
  }
  return;
}
function _getPhysicsRBDCylinderHeight(object) {
  return (0,_CommonHeightRadius__WEBPACK_IMPORTED_MODULE_1__/* .getPhysicsRBDHeight */ .dJ)(EXPECTED_TYPE, object);
}
function _getPhysicsRBDCylinderRadius(object) {
  return (0,_CommonHeightRadius__WEBPACK_IMPORTED_MODULE_1__/* .getPhysicsRBDRadius */ .fx)(EXPECTED_TYPE, object);
}
function _setPhysicsRBDCylinderProperty(object, targetRadius, targetHeight, lerp, updateObjectMatrix) {
  (0,_CommonHeightRadius__WEBPACK_IMPORTED_MODULE_1__/* .setPhysicsRBDHeightRadiusProperty */ .Q7)(EXPECTED_TYPE, object, targetRadius, targetHeight, lerp, updateObjectMatrix);
}


/***/ }),

/***/ 85240:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "AE": function() { return /* binding */ createPhysicsSphere; },
/* harmony export */   "V0": function() { return /* binding */ _setPhysicsRBDSphereProperty; },
/* harmony export */   "wd": function() { return /* binding */ _getPhysicsRBDSphereRadius; }
/* harmony export */ });
/* unused harmony export currentRadius */
/* harmony import */ var _PhysicsAttribute__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(36911);
/* harmony import */ var _PhysicsRBD__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(30864);
/* harmony import */ var _CommonHeightRadius__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(42971);
/* harmony import */ var _reactivity_RBDPropertyReactivity__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(284);
/* harmony import */ var _geometry_CoreObjectFactory__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(17353);






const EXPECTED_TYPE = _PhysicsAttribute__WEBPACK_IMPORTED_MODULE_0__/* .PhysicsRBDColliderType.SPHERE */ .bs.SPHERE;
function createPhysicsSphere(PhysicsLib2, object) {
  const radius = _PhysicsAttribute__WEBPACK_IMPORTED_MODULE_0__/* .CorePhysicsAttribute.getRadius */ .gy.getRadius(object) * object.scale.y;
  return PhysicsLib2.ColliderDesc.ball(radius);
}
const attributeRadiusLive = (0,_PhysicsAttribute__WEBPACK_IMPORTED_MODULE_0__/* .physicsAttribNameLive */ .Uk)(_PhysicsAttribute__WEBPACK_IMPORTED_MODULE_0__/* .PhysicsRBDRadiusAttribute.RADIUS */ .$V.RADIUS);
function currentRadius(object, collider) {
  const coreObjectClass = (0,_geometry_CoreObjectFactory__WEBPACK_IMPORTED_MODULE_1__/* .coreObjectClassFactory */ .Xr)(object);
  let _currentRadius = coreObjectClass.attribValue(object, attributeRadiusLive);
  if (_currentRadius == null) {
    const shape = collider.shape;
    _currentRadius = shape.radius;
    coreObjectClass.setAttribute(object, attributeRadiusLive, _currentRadius);
  }
  return _currentRadius;
}
function _getPhysicsRBDSphereRadius(object) {
  return (0,_CommonHeightRadius__WEBPACK_IMPORTED_MODULE_2__/* .getPhysicsRBDRadius */ .fx)(EXPECTED_TYPE, object);
}
function _setPhysicsRBDSphereProperty(object, targetRadius, lerp, updateObjectMatrix) {
  const body = (0,_PhysicsRBD__WEBPACK_IMPORTED_MODULE_3__/* ._getRBDFromObject */ .fd)(object);
  if (!body) {
    console.warn("no rbd found");
    return;
  }
  const colliderType = _PhysicsAttribute__WEBPACK_IMPORTED_MODULE_0__/* .CorePhysicsAttribute.getColliderType */ .gy.getColliderType(object);
  if (colliderType == null || colliderType != EXPECTED_TYPE) {
    return;
  }
  const collidersCount = body.numColliders();
  const originalRadiusAttrib = _PhysicsAttribute__WEBPACK_IMPORTED_MODULE_0__/* .CorePhysicsAttribute.getRadius */ .gy.getRadius(object);
  for (let i = 0; i < collidersCount; i++) {
    const collider = body.collider(i);
    if (!collider) {
      return;
    }
    if (lerp < 1) {
      targetRadius = lerp * targetRadius + (1 - lerp) * currentRadius(object, collider);
    }
    collider.setRadius(targetRadius);
    const coreObjectClass = (0,_geometry_CoreObjectFactory__WEBPACK_IMPORTED_MODULE_1__/* .coreObjectClassFactory */ .Xr)(object);
    coreObjectClass.setAttribute(object, attributeRadiusLive, targetRadius);
    (0,_reactivity_RBDPropertyReactivity__WEBPACK_IMPORTED_MODULE_4__/* .touchRBDProperty */ .P)(object, _CommonHeightRadius__WEBPACK_IMPORTED_MODULE_2__/* .RBDCommonProperty.RADIUS */ .n7.RADIUS);
    const newScale = targetRadius / originalRadiusAttrib;
    object.scale.set(newScale, newScale, newScale);
    if (updateObjectMatrix) {
      object.updateMatrix();
    }
  }
}


/***/ }),

/***/ 42971:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Q7": function() { return /* binding */ setPhysicsRBDHeightRadiusProperty; },
/* harmony export */   "dJ": function() { return /* binding */ getPhysicsRBDHeight; },
/* harmony export */   "fx": function() { return /* binding */ getPhysicsRBDRadius; },
/* harmony export */   "n7": function() { return /* binding */ RBDCommonProperty; }
/* harmony export */ });
/* unused harmony exports currentHeight, currentRadius */
/* harmony import */ var _PhysicsAttribute__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(36911);
/* harmony import */ var _PhysicsRBD__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(30864);
/* harmony import */ var _reactivity_RBDPropertyReactivity__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(284);
/* harmony import */ var _geometry_CoreObjectFactory__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(17353);





var RBDCommonProperty = /* @__PURE__ */ ((RBDCommonProperty2) => {
  RBDCommonProperty2["RADIUS"] = "radius";
  RBDCommonProperty2["HEIGHT"] = "height";
  return RBDCommonProperty2;
})(RBDCommonProperty || {});
const attributeHeightLive = (0,_PhysicsAttribute__WEBPACK_IMPORTED_MODULE_0__/* .physicsAttribNameLive */ .Uk)(_PhysicsAttribute__WEBPACK_IMPORTED_MODULE_0__/* .PhysicsRBDHeightAttribute.HEIGHT */ .OL.HEIGHT);
const attributeRadiusLive = (0,_PhysicsAttribute__WEBPACK_IMPORTED_MODULE_0__/* .physicsAttribNameLive */ .Uk)(_PhysicsAttribute__WEBPACK_IMPORTED_MODULE_0__/* .PhysicsRBDRadiusAttribute.RADIUS */ .$V.RADIUS);
function currentHeight(object, collider) {
  const coreObjectClass = (0,_geometry_CoreObjectFactory__WEBPACK_IMPORTED_MODULE_1__/* .coreObjectClassFactory */ .Xr)(object);
  let _currentHeight = coreObjectClass.attribValue(object, attributeHeightLive);
  if (_currentHeight == null) {
    const shape = collider.shape;
    _currentHeight = shape.halfHeight * 2;
    coreObjectClass.setAttribute(object, attributeHeightLive, _currentHeight);
  }
  return _currentHeight;
}
function currentRadius(object, collider) {
  const coreObjectClass = (0,_geometry_CoreObjectFactory__WEBPACK_IMPORTED_MODULE_1__/* .coreObjectClassFactory */ .Xr)(object);
  let _currentRadius = coreObjectClass.attribValue(object, attributeRadiusLive);
  if (_currentRadius == null) {
    const shape = collider.shape;
    _currentRadius = shape.radius;
    coreObjectClass.setAttribute(object, attributeRadiusLive, _currentRadius);
  }
  return _currentRadius;
}
function getPhysicsRBDHeight(expectedType, object) {
  const body = (0,_PhysicsRBD__WEBPACK_IMPORTED_MODULE_2__/* ._getRBDFromObject */ .fd)(object);
  if (!body) {
    console.warn("no rbd found");
    return;
  }
  const colliderType = _PhysicsAttribute__WEBPACK_IMPORTED_MODULE_0__/* .CorePhysicsAttribute.getColliderType */ .gy.getColliderType(object);
  if (colliderType == null || colliderType != expectedType) {
    return;
  }
  const collider = body.collider(0);
  if (!collider) {
    return;
  }
  return currentHeight(object, collider);
}
function getPhysicsRBDRadius(expectedType, object) {
  const body = (0,_PhysicsRBD__WEBPACK_IMPORTED_MODULE_2__/* ._getRBDFromObject */ .fd)(object);
  if (!body) {
    console.warn("no rbd found");
    return;
  }
  const colliderType = _PhysicsAttribute__WEBPACK_IMPORTED_MODULE_0__/* .CorePhysicsAttribute.getColliderType */ .gy.getColliderType(object);
  if (colliderType == null) {
    console.warn("no colliderType found");
    return;
  }
  if (colliderType != expectedType) {
    console.warn(`colliderType '${colliderType}' not the expected one ('${expectedType}')`);
    return;
  }
  const collider = body.collider(0);
  if (!collider) {
    console.warn("no collider found");
    return;
  }
  return currentRadius(object, collider);
}
function setPhysicsRBDHeightRadiusProperty(expectedType, object, targetRadius, targetHeight, lerp, updateObjectMatrix) {
  const body = (0,_PhysicsRBD__WEBPACK_IMPORTED_MODULE_2__/* ._getRBDFromObject */ .fd)(object);
  if (!body) {
    console.warn("no rbd found");
    return;
  }
  const colliderType = _PhysicsAttribute__WEBPACK_IMPORTED_MODULE_0__/* .CorePhysicsAttribute.getColliderType */ .gy.getColliderType(object);
  if (colliderType == null || colliderType != expectedType) {
    return;
  }
  const collidersCount = body.numColliders();
  const originalHeightAttrib = _PhysicsAttribute__WEBPACK_IMPORTED_MODULE_0__/* .CorePhysicsAttribute.getHeight */ .gy.getHeight(object);
  const originalRadiusAttrib = _PhysicsAttribute__WEBPACK_IMPORTED_MODULE_0__/* .CorePhysicsAttribute.getRadius */ .gy.getRadius(object);
  for (let i = 0; i < collidersCount; i++) {
    const collider = body.collider(i);
    if (!collider) {
      return;
    }
    if (lerp < 1) {
      targetHeight = lerp * targetHeight + (1 - lerp) * currentHeight(object, collider);
      targetRadius = lerp * targetRadius + (1 - lerp) * currentRadius(object, collider);
    }
    collider.setHalfHeight(targetHeight * 0.5);
    collider.setRadius(targetRadius);
    const coreObjectClass = (0,_geometry_CoreObjectFactory__WEBPACK_IMPORTED_MODULE_1__/* .coreObjectClassFactory */ .Xr)(object);
    coreObjectClass.setAttribute(object, attributeHeightLive, targetHeight);
    coreObjectClass.setAttribute(object, attributeRadiusLive, targetRadius);
    (0,_reactivity_RBDPropertyReactivity__WEBPACK_IMPORTED_MODULE_3__/* .touchRBDProperty */ .P)(object, "height" /* HEIGHT */);
    (0,_reactivity_RBDPropertyReactivity__WEBPACK_IMPORTED_MODULE_3__/* .touchRBDProperty */ .P)(object, "radius" /* RADIUS */);
    const scaleXZ = targetRadius / originalRadiusAttrib;
    object.scale.set(scaleXZ, targetHeight / originalHeightAttrib, scaleXZ);
    if (updateObjectMatrix) {
      object.updateMatrix();
    }
  }
}


/***/ }),

/***/ 50260:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "l": function() { return /* binding */ CorePlayer; }
/* harmony export */ });
/* harmony import */ var _engine_operations_sop_Capsule__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(69291);
/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(21410);







const tmpGravity = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3(0, 0, 0);
const upVector = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3(0, 1, 0);
const tempVector1 = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();
const tempVector2 = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();
const tempVector3 = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();
const tempVector4 = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();
const tempVector5 = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();
const tempBox = new three__WEBPACK_IMPORTED_MODULE_0__.Box3();
const tempMat = new three__WEBPACK_IMPORTED_MODULE_0__.Matrix4();
const tempSegment = new three__WEBPACK_IMPORTED_MODULE_0__.Line3();
const startRotationRadians = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();
class CorePlayer {
  constructor(options) {
    this._pressed = {
      forward: false,
      backward: false,
      left: false,
      right: false
    };
    this._onGround = false;
    this._velocity = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();
    this.capsuleInfo = {
      radius: _engine_operations_sop_Capsule__WEBPACK_IMPORTED_MODULE_1__/* .CapsuleSopOperation.DEFAULT_PARAMS.radius */ .e.DEFAULT_PARAMS.radius,
      segment: new three__WEBPACK_IMPORTED_MODULE_0__.Line3(
        new three__WEBPACK_IMPORTED_MODULE_0__.Vector3(0, 0, 0),
        new three__WEBPACK_IMPORTED_MODULE_0__.Vector3(
          0,
          -(_engine_operations_sop_Capsule__WEBPACK_IMPORTED_MODULE_1__/* .CapsuleSopOperation.DEFAULT_PARAMS.height */ .e.DEFAULT_PARAMS.height - 2 * _engine_operations_sop_Capsule__WEBPACK_IMPORTED_MODULE_1__/* .CapsuleSopOperation.DEFAULT_PARAMS.radius */ .e.DEFAULT_PARAMS.radius),
          0
        )
      )
    };
    this.startPosition = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3(0, 5, 0);
    this.startRotation = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3(0, 0, 0);
    this.jumpAllowed = true;
    this.jumpStrength = 10;
    this.runAllowed = true;
    this.runSpeedMult = 2;
    this._running = false;
    this.speed = 10;
    this.physicsSteps = 5;
    this.gravity = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3(0, -30, 0);
    this._azimuthalAngle = 0;
    this._resetYMax = -25;
    this._resetRequiredCallback = () => {
      return this.object.position.y < this._resetYMax;
    };
    this.setOptions(options);
  }
  setOptions(options) {
    this._setObject(options.object);
    this.setCollider(options.collider);
  }
  _setObject(object) {
    this.object = object;
    this.object.matrixAutoUpdate = true;
  }
  setCollider(collider) {
    this.collider = collider;
  }
  setCapsule(capsuleOptions) {
    this.capsuleInfo.radius = capsuleOptions.radius;
    this.capsuleInfo.segment.end.y = -(capsuleOptions.height - 2 * capsuleOptions.radius);
  }
  reset() {
    this.stop();
    this.object.position.copy(this.startPosition);
    startRotationRadians.copy(this.startRotation).multiplyScalar(three__WEBPACK_IMPORTED_MODULE_0__.MathUtils.DEG2RAD);
    this.object.rotation.setFromVector3(startRotationRadians);
    this.object.updateMatrix();
    this.object.updateWorldMatrix(true, true);
    this.object.updateMatrixWorld(true);
  }
  stop() {
    this._pressed.forward = false;
    this._pressed.backward = false;
    this._pressed.left = false;
    this._pressed.right = false;
    this._running = false;
    this._velocity.set(0, 0, 0);
  }
  setResetRequiredCallback(callback) {
    this._resetRequiredCallback = callback;
  }
  setAzimuthalAngle(angle) {
    this._azimuthalAngle = angle;
  }
  update(delta) {
    const deltaBounded = Math.min(delta, 0.1);
    for (let i = 0; i < this.physicsSteps; i++) {
      this._updateStep(deltaBounded / this.physicsSteps);
    }
  }
  _updateStep(delta) {
    if (!this._onGround) {
      tmpGravity.copy(this.gravity).multiplyScalar(delta);
      this._velocity.add(tmpGravity);
    }
    this.object.position.addScaledVector(this._velocity, delta);
    const angle = this._azimuthalAngle;
    const speed = this.speed * delta * (this._running ? this.runSpeedMult : 1);
    tempVector2.set(0, 0, 0);
    if (this._pressed.forward) {
      tempVector1.set(0, 0, -1).applyAxisAngle(upVector, angle);
      tempVector2.add(tempVector1);
    }
    if (this._pressed.backward) {
      tempVector1.set(0, 0, 1).applyAxisAngle(upVector, angle);
      tempVector2.add(tempVector1);
    }
    if (this._pressed.left) {
      tempVector1.set(-1, 0, 0).applyAxisAngle(upVector, angle);
      tempVector2.add(tempVector1);
    }
    if (this._pressed.right) {
      tempVector1.set(1, 0, 0).applyAxisAngle(upVector, angle);
      tempVector2.add(tempVector1);
    }
    tempVector2.normalize().multiplyScalar(speed);
    this.object.position.add(tempVector2);
    this.object.updateMatrixWorld();
    const capsuleInfo = this.capsuleInfo;
    tempBox.makeEmpty();
    tempMat.copy(this.collider.matrixWorld).invert();
    tempSegment.copy(capsuleInfo.segment);
    tempSegment.start.applyMatrix4(this.object.matrixWorld).applyMatrix4(tempMat);
    tempSegment.end.applyMatrix4(this.object.matrixWorld).applyMatrix4(tempMat);
    tempBox.expandByPoint(tempSegment.start);
    tempBox.expandByPoint(tempSegment.end);
    tempBox.min.addScalar(-capsuleInfo.radius);
    tempBox.max.addScalar(capsuleInfo.radius);
    const intersectsBounds = (box, isLeaf, score, depth, nodeIndex) => {
      return box.intersectsBox(tempBox);
    };
    const intersectsTriangle = (tri) => {
      const triPoint = tempVector3;
      const capsulePoint = tempVector4;
      const distance = tri.closestPointToSegment(tempSegment, triPoint, capsulePoint);
      if (distance < capsuleInfo.radius) {
        const depth = capsuleInfo.radius - distance;
        const direction = capsulePoint.sub(triPoint).normalize();
        tempSegment.start.addScaledVector(direction, depth);
        tempSegment.end.addScaledVector(direction, depth);
      }
    };
    this.collider.geometry.boundsTree.shapecast({
      intersectsBounds,
      intersectsTriangle
    });
    const newPosition = tempVector5;
    newPosition.copy(tempSegment.start);
    newPosition.applyMatrix4(this.collider.matrixWorld);
    const deltaVector = tempVector2;
    deltaVector.subVectors(newPosition, this.object.position);
    this._onGround = deltaVector.y > Math.abs(delta * this._velocity.y * 0.25);
    const offset = Math.max(0, deltaVector.length() - 1e-5);
    deltaVector.normalize().multiplyScalar(offset);
    this.object.position.add(deltaVector);
    if (!this._onGround) {
      deltaVector.normalize();
      this._velocity.addScaledVector(deltaVector, -deltaVector.dot(this._velocity));
    } else {
      this._velocity.set(0, 0, 0);
    }
    if (this._resetRequiredCallback()) {
      this.reset();
    }
  }
  setForward(state) {
    this._pressed.forward = state;
  }
  setBackward(state) {
    this._pressed.backward = state;
  }
  setLeft(state) {
    this._pressed.left = state;
  }
  setRight(state) {
    this._pressed.right = state;
  }
  jump() {
    if (this._onGround && this.jumpAllowed) {
      this._velocity.y = this.jumpStrength;
    }
  }
  setRun(state) {
    if (state) {
      if (this._onGround && this.runAllowed) {
        this._running = true;
      }
    } else {
      this._running = false;
    }
  }
  running() {
    return this._running;
  }
}


/***/ }),

/***/ 52729:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Z": function() { return /* binding */ CorePlayerInput; },
/* harmony export */   "o": function() { return /* binding */ CORE_PLAYER_INPUTS; }
/* harmony export */ });

var CorePlayerInput = /* @__PURE__ */ ((CorePlayerInput2) => {
  CorePlayerInput2["LEFT"] = "left";
  CorePlayerInput2["RIGHT"] = "right";
  CorePlayerInput2["BACKWARD"] = "backward";
  CorePlayerInput2["FORWARD"] = "forward";
  CorePlayerInput2["RUN"] = "run";
  CorePlayerInput2["JUMP"] = "jump";
  return CorePlayerInput2;
})(CorePlayerInput || {});
const CORE_PLAYER_INPUTS = [
  "left" /* LEFT */,
  "right" /* RIGHT */,
  "backward" /* BACKWARD */,
  "forward" /* FORWARD */,
  "run" /* RUN */,
  "jump" /* JUMP */
];


/***/ }),

/***/ 45415:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "z": function() { return /* binding */ BLEND_FUNCTION_MENU_OPTIONS; }
/* harmony export */ });
/* harmony import */ var postprocessing__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(43109);


const BLEND_FUNCTION_BY_NAME = [
  { SKIP: postprocessing__WEBPACK_IMPORTED_MODULE_0__/* .BlendFunction.SKIP */ .YQ.SKIP },
  { SET: postprocessing__WEBPACK_IMPORTED_MODULE_0__/* .BlendFunction.SET */ .YQ.SET },
  { ADD: postprocessing__WEBPACK_IMPORTED_MODULE_0__/* .BlendFunction.ADD */ .YQ.ADD },
  { ALPHA: postprocessing__WEBPACK_IMPORTED_MODULE_0__/* .BlendFunction.ALPHA */ .YQ.ALPHA },
  { AVERAGE: postprocessing__WEBPACK_IMPORTED_MODULE_0__/* .BlendFunction.AVERAGE */ .YQ.AVERAGE },
  { COLOR: postprocessing__WEBPACK_IMPORTED_MODULE_0__/* .BlendFunction.COLOR */ .YQ.COLOR },
  { COLOR_BURN: postprocessing__WEBPACK_IMPORTED_MODULE_0__/* .BlendFunction.COLOR_BURN */ .YQ.COLOR_BURN },
  { COLOR_DODGE: postprocessing__WEBPACK_IMPORTED_MODULE_0__/* .BlendFunction.COLOR_DODGE */ .YQ.COLOR_DODGE },
  { DARKEN: postprocessing__WEBPACK_IMPORTED_MODULE_0__/* .BlendFunction.DARKEN */ .YQ.DARKEN },
  { DIFFERENCE: postprocessing__WEBPACK_IMPORTED_MODULE_0__/* .BlendFunction.DIFFERENCE */ .YQ.DIFFERENCE },
  { DIVIDE: postprocessing__WEBPACK_IMPORTED_MODULE_0__/* .BlendFunction.DIVIDE */ .YQ.DIVIDE },
  // {DST: BlendFunction.DST}, // DST and SKIP are the same
  { EXCLUSION: postprocessing__WEBPACK_IMPORTED_MODULE_0__/* .BlendFunction.EXCLUSION */ .YQ.EXCLUSION },
  { HARD_LIGHT: postprocessing__WEBPACK_IMPORTED_MODULE_0__/* .BlendFunction.HARD_LIGHT */ .YQ.HARD_LIGHT },
  { HARD_MIX: postprocessing__WEBPACK_IMPORTED_MODULE_0__/* .BlendFunction.HARD_MIX */ .YQ.HARD_MIX },
  { HUE: postprocessing__WEBPACK_IMPORTED_MODULE_0__/* .BlendFunction.HUE */ .YQ.HUE },
  { INVERT: postprocessing__WEBPACK_IMPORTED_MODULE_0__/* .BlendFunction.INVERT */ .YQ.INVERT },
  { INVERT_RGB: postprocessing__WEBPACK_IMPORTED_MODULE_0__/* .BlendFunction.INVERT_RGB */ .YQ.INVERT_RGB },
  { LIGHTEN: postprocessing__WEBPACK_IMPORTED_MODULE_0__/* .BlendFunction.LIGHTEN */ .YQ.LIGHTEN },
  { LINEAR_BURN: postprocessing__WEBPACK_IMPORTED_MODULE_0__/* .BlendFunction.LINEAR_BURN */ .YQ.LINEAR_BURN },
  { LINEAR_DODGE: postprocessing__WEBPACK_IMPORTED_MODULE_0__/* .BlendFunction.LINEAR_DODGE */ .YQ.LINEAR_DODGE },
  { LINEAR_LIGHT: postprocessing__WEBPACK_IMPORTED_MODULE_0__/* .BlendFunction.LINEAR_LIGHT */ .YQ.LINEAR_LIGHT },
  { LUMINOSITY: postprocessing__WEBPACK_IMPORTED_MODULE_0__/* .BlendFunction.LUMINOSITY */ .YQ.LUMINOSITY },
  { MULTIPLY: postprocessing__WEBPACK_IMPORTED_MODULE_0__/* .BlendFunction.MULTIPLY */ .YQ.MULTIPLY },
  { NEGATION: postprocessing__WEBPACK_IMPORTED_MODULE_0__/* .BlendFunction.NEGATION */ .YQ.NEGATION },
  { NORMAL: postprocessing__WEBPACK_IMPORTED_MODULE_0__/* .BlendFunction.NORMAL */ .YQ.NORMAL },
  { OVERLAY: postprocessing__WEBPACK_IMPORTED_MODULE_0__/* .BlendFunction.OVERLAY */ .YQ.OVERLAY },
  { PIN_LIGHT: postprocessing__WEBPACK_IMPORTED_MODULE_0__/* .BlendFunction.PIN_LIGHT */ .YQ.PIN_LIGHT },
  { SATURATION: postprocessing__WEBPACK_IMPORTED_MODULE_0__/* .BlendFunction.SATURATION */ .YQ.SATURATION },
  { REFLECT: postprocessing__WEBPACK_IMPORTED_MODULE_0__/* .BlendFunction.REFLECT */ .YQ.REFLECT },
  { SCREEN: postprocessing__WEBPACK_IMPORTED_MODULE_0__/* .BlendFunction.SCREEN */ .YQ.SCREEN },
  { SOFT_LIGHT: postprocessing__WEBPACK_IMPORTED_MODULE_0__/* .BlendFunction.SOFT_LIGHT */ .YQ.SOFT_LIGHT },
  // {SRC: BlendFunction.SRC}, SET and SRC are the same
  { SUBTRACT: postprocessing__WEBPACK_IMPORTED_MODULE_0__/* .BlendFunction.SUBTRACT */ .YQ.SUBTRACT },
  { VIVID_LIGHT: postprocessing__WEBPACK_IMPORTED_MODULE_0__/* .BlendFunction.VIVID_LIGHT */ .YQ.VIVID_LIGHT }
];
const BLEND_FUNCTION_MENU_OPTIONS = {
  menu: {
    entries: BLEND_FUNCTION_BY_NAME.map((o, i) => {
      return {
        name: Object.keys(o)[0],
        value: Object.values(o)[0]
      };
    })
  }
};


/***/ }),

/***/ 51417:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "N": function() { return /* binding */ KERNEL_SIZE_MENU_OPTIONS; },
/* harmony export */   "l": function() { return /* binding */ KERNEL_SIZES; }
/* harmony export */ });
/* harmony import */ var postprocessing__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(43109);


const KERNEL_SIZES = [
  postprocessing__WEBPACK_IMPORTED_MODULE_0__/* .KernelSize.VERY_SMALL */ .DD.VERY_SMALL,
  postprocessing__WEBPACK_IMPORTED_MODULE_0__/* .KernelSize.SMALL */ .DD.SMALL,
  postprocessing__WEBPACK_IMPORTED_MODULE_0__/* .KernelSize.MEDIUM */ .DD.MEDIUM,
  postprocessing__WEBPACK_IMPORTED_MODULE_0__/* .KernelSize.LARGE */ .DD.LARGE,
  postprocessing__WEBPACK_IMPORTED_MODULE_0__/* .KernelSize.VERY_LARGE */ .DD.VERY_LARGE,
  postprocessing__WEBPACK_IMPORTED_MODULE_0__/* .KernelSize.HUGE */ .DD.HUGE
];
const KERNAL_NAME_BY_SIZE = {
  [postprocessing__WEBPACK_IMPORTED_MODULE_0__/* .KernelSize.VERY_SMALL */ .DD.VERY_SMALL]: "VERY_SMALL",
  [postprocessing__WEBPACK_IMPORTED_MODULE_0__/* .KernelSize.SMALL */ .DD.SMALL]: "SMALL",
  [postprocessing__WEBPACK_IMPORTED_MODULE_0__/* .KernelSize.MEDIUM */ .DD.MEDIUM]: "MEDIUM",
  [postprocessing__WEBPACK_IMPORTED_MODULE_0__/* .KernelSize.LARGE */ .DD.LARGE]: "LARGE",
  [postprocessing__WEBPACK_IMPORTED_MODULE_0__/* .KernelSize.VERY_LARGE */ .DD.VERY_LARGE]: "VERY_LARGE",
  [postprocessing__WEBPACK_IMPORTED_MODULE_0__/* .KernelSize.HUGE */ .DD.HUGE]: "HUGE"
};
const KERNEL_SIZE_MENU_OPTIONS = {
  menu: {
    entries: KERNEL_SIZES.map((value) => {
      return {
        name: KERNAL_NAME_BY_SIZE[value],
        value
      };
    })
  }
};


/***/ }),

/***/ 6098:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "De": function() { return /* binding */ GetObjectPropertyJsNodeInputName; },
/* harmony export */   "Jd": function() { return /* binding */ touchObjectProperty; },
/* harmony export */   "bo": function() { return /* binding */ OBJECT_TRANSFORM_PROPERTIES; },
/* harmony export */   "lw": function() { return /* binding */ getObjectPropertyRef; },
/* harmony export */   "pz": function() { return /* binding */ OBJECT_VECTOR3_PROPERTIES; },
/* harmony export */   "rP": function() { return /* binding */ touchObjectProperties; },
/* harmony export */   "ue": function() { return /* binding */ OBJECT_BOOLEAN_PROPERTIES; }
/* harmony export */ });
/* harmony import */ var _core_reactivity_CoreReactivity__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(66316);
/* harmony import */ var _core_reactivity_CoreReactivity__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(82156);


var GetObjectPropertyJsNodeInputName = /* @__PURE__ */ ((GetObjectPropertyJsNodeInputName2) => {
  GetObjectPropertyJsNodeInputName2["position"] = "position";
  GetObjectPropertyJsNodeInputName2["rotation"] = "rotation";
  GetObjectPropertyJsNodeInputName2["quaternion"] = "quaternion";
  GetObjectPropertyJsNodeInputName2["scale"] = "scale";
  GetObjectPropertyJsNodeInputName2["matrix"] = "matrix";
  GetObjectPropertyJsNodeInputName2["visible"] = "visible";
  GetObjectPropertyJsNodeInputName2["castShadow"] = "castShadow";
  GetObjectPropertyJsNodeInputName2["receiveShadow"] = "receiveShadow";
  GetObjectPropertyJsNodeInputName2["frustumCulled"] = "frustumCulled";
  GetObjectPropertyJsNodeInputName2["up"] = "up";
  GetObjectPropertyJsNodeInputName2["matrixAutoUpdate"] = "matrixAutoUpdate";
  GetObjectPropertyJsNodeInputName2["material"] = "material";
  return GetObjectPropertyJsNodeInputName2;
})(GetObjectPropertyJsNodeInputName || {});
const OBJECT_VECTOR3_PROPERTIES = [
  "position" /* position */,
  "scale" /* scale */,
  "up" /* up */
];
const OBJECT_BOOLEAN_PROPERTIES = [
  "visible" /* visible */,
  "castShadow" /* castShadow */,
  "receiveShadow" /* receiveShadow */,
  "frustumCulled" /* frustumCulled */,
  "matrixAutoUpdate" /* matrixAutoUpdate */
];
const OBJECT_TRANSFORM_PROPERTIES = [
  "position" /* position */,
  "quaternion" /* quaternion */,
  "scale" /* scale */,
  "matrix" /* matrix */
];
const refByObjectUuidByPropertyName = /* @__PURE__ */ new Map();
function getObjectPropertyRef(object3D, propertyName) {
  let mapForObject = refByObjectUuidByPropertyName.get(object3D.uuid);
  if (!mapForObject) {
    mapForObject = /* @__PURE__ */ new Map();
    refByObjectUuidByPropertyName.set(object3D.uuid, mapForObject);
  }
  let refForProperty = mapForObject.get(propertyName);
  if (!refForProperty) {
    refForProperty = (0,_core_reactivity_CoreReactivity__WEBPACK_IMPORTED_MODULE_0__/* .ref */ .iH)(0);
    mapForObject.set(propertyName, refForProperty);
  }
  return refForProperty;
}
function touchObjectProperties(object3D, propertyNames) {
  const map = refByObjectUuidByPropertyName.get(object3D.uuid);
  if (!map) {
    return;
  }
  for (const propertyName of propertyNames) {
    const _ref = map.get(propertyName);
    if (_ref) {
      (0,_core_reactivity_CoreReactivity__WEBPACK_IMPORTED_MODULE_1__/* .incrementRefSafely */ .jD)(_ref);
    }
  }
}
function touchObjectProperty(object3D, propertyName) {
  const _ref = getObjectPropertyRef(object3D, propertyName);
  (0,_core_reactivity_CoreReactivity__WEBPACK_IMPORTED_MODULE_1__/* .incrementRefSafely */ .jD)(_ref);
}


/***/ }),

/***/ 284:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "$I": function() { return /* binding */ getOrCreatePropertyRef; },
/* harmony export */   "P": function() { return /* binding */ touchRBDProperty; },
/* harmony export */   "lo": function() { return /* binding */ touchRBDProperties; }
/* harmony export */ });
/* harmony import */ var _core_reactivity_CoreReactivity__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(66316);
/* harmony import */ var _core_reactivity_CoreReactivity__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(82156);


const refByRBDObjectUuidByPropertyName = /* @__PURE__ */ new Map();
function getOrCreatePropertyRef(timeController, object3D, propertyName) {
  return getRBDPropertyRef(timeController, object3D, propertyName) || createRBDPropertyRef(object3D, propertyName);
}
function createRBDPropertyRef(object3D, propertyName) {
  let mapForObject = refByRBDObjectUuidByPropertyName.get(object3D.uuid);
  if (!mapForObject) {
    mapForObject = /* @__PURE__ */ new Map();
    refByRBDObjectUuidByPropertyName.set(object3D.uuid, mapForObject);
  }
  let refForProperty = mapForObject.get(propertyName);
  if (!refForProperty) {
    refForProperty = (0,_core_reactivity_CoreReactivity__WEBPACK_IMPORTED_MODULE_0__/* .ref */ .iH)(0);
    mapForObject.set(propertyName, refForProperty);
  }
  return refForProperty;
}
function getRBDPropertyRef(timeController, object3D, propertyName) {
  return timeController.timeUniform();
}
function touchRBDProperties(object3D, propertyNames) {
  const map = refByRBDObjectUuidByPropertyName.get(object3D.uuid);
  if (!map) {
    return;
  }
  for (const propertyName of propertyNames) {
    const _ref = map.get(propertyName);
    if (_ref) {
      (0,_core_reactivity_CoreReactivity__WEBPACK_IMPORTED_MODULE_1__/* .incrementRefSafely */ .jD)(_ref);
    }
  }
}
function touchRBDProperty(object3D, propertyName) {
}


/***/ }),

/***/ 34263:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "PZ": function() { return /* binding */ registerWFCBuilder; },
/* harmony export */   "lv": function() { return /* binding */ getWFCBuilder; },
/* harmony export */   "tH": function() { return /* binding */ registerWFCSolver; },
/* harmony export */   "uO": function() { return /* binding */ getWFCSolver; }
/* harmony export */ });

let _nextId = 0;
const SOLVER_ID_KEY = "__wfcSolverId__";
const BUILDER_ID_KEY = "__wfcBuilderId__";
const WFCSolverById = /* @__PURE__ */ new Map();
const WFCBuilderById = /* @__PURE__ */ new Map();
function registerWFCSolver(solver, object) {
  const id = _nextId++;
  WFCSolverById.set(id, solver);
  object.userData[SOLVER_ID_KEY] = id;
}
function getWFCSolver(object) {
  const id = object.userData[SOLVER_ID_KEY];
  if (id != null) {
    return WFCSolverById.get(id);
  }
}
function registerWFCBuilder(solver, object) {
  const id = _nextId++;
  WFCBuilderById.set(id, solver);
  object.userData[BUILDER_ID_KEY] = id;
}
function getWFCBuilder(object) {
  const id = object.userData[BUILDER_ID_KEY];
  if (id != null) {
    return WFCBuilderById.get(id);
  }
}


/***/ }),

/***/ 67120:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "BN": function() { return /* binding */ animationActionFadeIn; },
/* harmony export */   "Ct": function() { return /* binding */ animationActionFadeOut; },
/* harmony export */   "Ei": function() { return /* binding */ getAnimationAction; },
/* harmony export */   "GR": function() { return /* binding */ getAnimationMixer; },
/* harmony export */   "MV": function() { return /* binding */ animationActionPlay; },
/* harmony export */   "Oq": function() { return /* binding */ findOrCreateAnimationMixer; },
/* harmony export */   "Q5": function() { return /* binding */ animationClipsFromAnimationMixer; },
/* harmony export */   "TG": function() { return /* binding */ animationMixerUpdate; },
/* harmony export */   "dH": function() { return /* binding */ animationActionStop; },
/* harmony export */   "hB": function() { return /* binding */ animationActionCrossFade; }
/* harmony export */ });
/* unused harmony exports existingAnimationActionsFromAnimationMixer, getMostActiveAnimationActionFromMixer */
/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(21410);
/* harmony import */ var _core_ArrayUtils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(87132);
/* harmony import */ var _core_Type__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(19037);
/* harmony import */ var _Base__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(52419);





const _mixerByObject = /* @__PURE__ */ new Map();
const _actionByNameByMixer = /* @__PURE__ */ new Map();
function findOrCreateAnimationMixer(object3D) {
  let animationMixer = _mixerByObject.get(object3D);
  if (!animationMixer) {
    animationMixer = new three__WEBPACK_IMPORTED_MODULE_0__.AnimationMixer(object3D);
    _mixerByObject.set(object3D, animationMixer);
  }
  return animationMixer;
}
function findOrCreateAnimationAction(mixer, clipName, autoPlay) {
  let mixerMap = _actionByNameByMixer.get(mixer);
  if (!mixerMap) {
    mixerMap = /* @__PURE__ */ new Map();
    _actionByNameByMixer.set(mixer, mixerMap);
  }
  let action = mixerMap.get(clipName);
  if (!action) {
    const root = mixer.getRoot();
    const animations = root.animations;
    if (!animations) {
      console.warn("no animations");
      return;
    }
    const animation = animations.find((animation2) => animation2.name == clipName);
    if (!animation) {
      return;
    }
    action = mixer.existingAction(animation) || mixer.clipAction(animation);
    if ((0,_core_Type__WEBPACK_IMPORTED_MODULE_1__/* .isBooleanTrue */ .bI)(autoPlay)) {
      action.play();
    }
    mixerMap.set(clipName, action);
  }
  return action;
}
function animationClipsFromAnimationMixer(animationMixer) {
  const root = animationMixer.getRoot();
  return root.animations;
}
function existingAnimationActionsFromAnimationMixer(animationMixer) {
  const root = animationMixer.getRoot();
  const animations = root.animations;
  if (!animations) {
    console.warn("no animations found", root);
    return [];
  }
  const animationActions = [];
  for (let animation of animations) {
    const existingAnimationAction = animationMixer.existingAction(animation);
    if (existingAnimationAction) {
      animationActions.push(existingAnimationAction);
    }
  }
  return animationActions;
}
function getMostActiveAnimationActionFromMixer(animationMixer, except) {
  const existing = existingAnimationActionsFromAnimationMixer(animationMixer);
  const otherActions = existing.filter((action) => action !== except);
  const actionsSortedByWeight = (0,_core_ArrayUtils__WEBPACK_IMPORTED_MODULE_2__/* .arraySortBy */ .Zg)(otherActions, (action) => -action.getEffectiveWeight());
  const mostActiveAnimationAction = actionsSortedByWeight[0];
  return {
    otherActions,
    mostActiveAnimationAction
  };
}
function _setAnimationActionWeight(action, weight) {
  action.enabled = true;
  action.setEffectiveTimeScale(1);
  action.setEffectiveWeight(weight);
}
function _crossFade(from, to, duration, warp) {
  _setAnimationActionWeight(to, 1);
  to.syncWith(from);
  to.play();
  from.crossFadeTo(to, duration, warp);
}
function _fadeOutOtherActions(animationActionTo, duration, warp, startOnFromActionEnd) {
  const mixer = animationActionTo.getMixer();
  const { otherActions, mostActiveAnimationAction } = getMostActiveAnimationActionFromMixer(mixer, animationActionTo);
  const animationActionFrom = mostActiveAnimationAction;
  const _fadeInCurrentAndFadeOutOtherActions = () => {
    _crossFade(animationActionFrom, animationActionTo, duration, warp);
    for (let action of otherActions) {
      action.fadeOut(duration);
    }
  };
  if (otherActions.length == 0) {
    _fadeInSimple(animationActionTo, duration);
  } else {
    if (startOnFromActionEnd) {
      animationActionTo.stop();
      _fadeInWhenPreviousLoopCompleted(mixer, animationActionFrom, _fadeInCurrentAndFadeOutOtherActions);
    } else {
      _fadeInCurrentAndFadeOutOtherActions();
    }
  }
}
function _fadeInSimple(animationActionTo, duration) {
  _setAnimationActionWeight(animationActionTo, 1);
  animationActionTo.fadeIn(duration);
}
function _fadeInWhenPreviousLoopCompleted(mixer, animationActionFrom, callback) {
  const onLoop = (event) => {
    if (event.action === animationActionFrom) {
      mixer.removeEventListener("loop", onLoop);
      callback();
    }
  };
  mixer.addEventListener("loop", onLoop);
}
function startCrossFade(actionFrom, actionToGet, duration, warp) {
  const actionTo = actionToGet();
  if (!actionTo) {
    return;
  }
  _crossFade(actionFrom, actionTo, duration, warp);
}
class getAnimationMixer extends _Base__WEBPACK_IMPORTED_MODULE_3__/* .ObjectNamedFunction0 */ .jY {
  static type() {
    return "getAnimationMixer";
  }
  func(object3D) {
    const action = findOrCreateAnimationMixer(object3D);
    return action;
  }
}
class animationMixerUpdate extends _Base__WEBPACK_IMPORTED_MODULE_3__/* .ObjectNamedFunction0 */ .jY {
  static type() {
    return "animationMixerUpdate";
  }
  func(object3D) {
    const mixer = _mixerByObject.get(object3D);
    if (!mixer) {
      return;
    }
    const delta = this.scene.timeController.delta();
    const root = mixer.getRoot();
    if (root.traverse) {
      root.traverse((child) => {
        if (!child.matrixAutoUpdate) {
          child.updateMatrix();
        }
      });
    }
    mixer.update(delta);
  }
}
class getAnimationAction extends _Base__WEBPACK_IMPORTED_MODULE_3__/* .NamedFunction3 */ .Dv {
  static type() {
    return "getAnimationAction";
  }
  func(mixer, clipName, autoPlay) {
    const action = findOrCreateAnimationAction(mixer, clipName, autoPlay);
    return action;
  }
}
class animationActionPlay extends _Base__WEBPACK_IMPORTED_MODULE_3__/* .NamedFunction1 */ .TV {
  static type() {
    return "animationActionPlay";
  }
  func(action) {
    if (!action) {
      return;
    }
    action.play();
  }
}
class animationActionStop extends _Base__WEBPACK_IMPORTED_MODULE_3__/* .NamedFunction1 */ .TV {
  static type() {
    return "animationActionStop";
  }
  func(action) {
    if (!action) {
      return;
    }
    action.stop();
  }
}
class animationActionFadeIn extends _Base__WEBPACK_IMPORTED_MODULE_3__/* .NamedFunction5 */ .t9 {
  static type() {
    return "animationActionFadeIn";
  }
  func(action, duration, fadeOutOtherActions, warp, startOnFromActionEnd) {
    if (!action) {
      console.warn(`action '${action}' not found`);
      return;
    }
    if (fadeOutOtherActions) {
      _fadeOutOtherActions(action, duration, warp, startOnFromActionEnd);
    } else {
      _fadeInSimple(action, duration);
    }
  }
}
class animationActionFadeOut extends _Base__WEBPACK_IMPORTED_MODULE_3__/* .NamedFunction2 */ .CE {
  static type() {
    return "animationActionFadeOut";
  }
  func(action, duration) {
    if (!action) {
      return;
    }
    action.fadeOut(duration);
  }
}
class animationActionCrossFade extends _Base__WEBPACK_IMPORTED_MODULE_3__/* .NamedFunction5 */ .t9 {
  static type() {
    return "animationActionCrossFade";
  }
  func(actionFrom, actionToGet, duration, warp, startOnFromActionEnd) {
    if (!actionFrom) {
      return;
    }
    if (startOnFromActionEnd) {
      const mixer = actionFrom.getMixer();
      const onLoop = (event) => {
        if (event.action === actionFrom) {
          mixer.removeEventListener("loop", onLoop);
          startCrossFade(actionFrom, actionToGet, duration, warp);
        }
      };
      mixer.addEventListener("loop", onLoop);
    } else {
      startCrossFade(actionFrom, actionToGet, duration, warp);
    }
  }
}


/***/ }),

/***/ 55681:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "$O": function() { return /* binding */ mathVectorArray_1; },
/* harmony export */   "$q": function() { return /* binding */ mathVector4_3vvf; },
/* harmony export */   "AR": function() { return /* binding */ mathVector2_3vvf; },
/* harmony export */   "Et": function() { return /* binding */ _vectorFunctionName_4; },
/* harmony export */   "FA": function() { return /* binding */ mathVector4_5; },
/* harmony export */   "Fg": function() { return /* binding */ mathFloat_4; },
/* harmony export */   "Hf": function() { return /* binding */ mathFloat_1; },
/* harmony export */   "Hk": function() { return /* binding */ mathColor_2; },
/* harmony export */   "Hy": function() { return /* binding */ mathPrimArray_5; },
/* harmony export */   "I5": function() { return /* binding */ mathVector2_1; },
/* harmony export */   "IQ": function() { return /* binding */ mathVector3_5; },
/* harmony export */   "IU": function() { return /* binding */ mathPrimArray_2; },
/* harmony export */   "LY": function() { return /* binding */ mathVector2_2; },
/* harmony export */   "Lo": function() { return /* binding */ mathVectorArray_4; },
/* harmony export */   "Mu": function() { return /* binding */ mathVector3_4; },
/* harmony export */   "OT": function() { return /* binding */ mathColor_4; },
/* harmony export */   "PT": function() { return /* binding */ mathVector4_2; },
/* harmony export */   "PX": function() { return /* binding */ mathColor_3; },
/* harmony export */   "QU": function() { return /* binding */ mathVector3_2; },
/* harmony export */   "T": function() { return /* binding */ mathVector3_3vvf; },
/* harmony export */   "Td": function() { return /* binding */ mathVector2_4; },
/* harmony export */   "X$": function() { return /* binding */ mathColor_3vvf; },
/* harmony export */   "YW": function() { return /* binding */ mathVector3_3; },
/* harmony export */   "_T": function() { return /* binding */ mathFloat_2; },
/* harmony export */   "aH": function() { return /* binding */ mathColor_1; },
/* harmony export */   "ah": function() { return /* binding */ _vectorFunctionName_3vvf; },
/* harmony export */   "am": function() { return /* binding */ mathVector2_5; },
/* harmony export */   "bC": function() { return /* binding */ mathVector4_3; },
/* harmony export */   "cm": function() { return /* binding */ _vectorFunctionName_5; },
/* harmony export */   "e2": function() { return /* binding */ mathVectorArray_3; },
/* harmony export */   "fD": function() { return /* binding */ mathVector4_4; },
/* harmony export */   "ix": function() { return /* binding */ mathPrimArray_1; },
/* harmony export */   "kB": function() { return /* binding */ mathPrimArray_4; },
/* harmony export */   "l5": function() { return /* binding */ mathPrimArray_3; },
/* harmony export */   "mR": function() { return /* binding */ mathVector4_1; },
/* harmony export */   "mh": function() { return /* binding */ mathVectorArray_2; },
/* harmony export */   "nB": function() { return /* binding */ _vectorFunctionName_2; },
/* harmony export */   "o5": function() { return /* binding */ mathFloat_5; },
/* harmony export */   "oo": function() { return /* binding */ mathColor_5; },
/* harmony export */   "pF": function() { return /* binding */ mathVector3_1; },
/* harmony export */   "qO": function() { return /* binding */ mathVector2_3; },
/* harmony export */   "rV": function() { return /* binding */ mathFloat_3; },
/* harmony export */   "tU": function() { return /* binding */ _vectorFunctionName_3; },
/* harmony export */   "uD": function() { return /* binding */ mathVectorArray_5; },
/* harmony export */   "vr": function() { return /* binding */ _vectorFunctionName_1; }
/* harmony export */ });
/* harmony import */ var _ArrayUtils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(46255);
/* harmony import */ var _Base__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(52419);
/* harmony import */ var _nodes_utils_io_connections_Js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(38857);




class MathNamedFunction2 extends _Base__WEBPACK_IMPORTED_MODULE_0__/* .NamedFunction */ .x9 {
}
class MathNamedFunction3 extends _Base__WEBPACK_IMPORTED_MODULE_0__/* .NamedFunction */ .x9 {
}
class MathNamedFunction4 extends _Base__WEBPACK_IMPORTED_MODULE_0__/* .NamedFunction */ .x9 {
}
class MathNamedFunction5 extends _Base__WEBPACK_IMPORTED_MODULE_0__/* .NamedFunction */ .x9 {
}
class MathNamedFunction6 extends _Base__WEBPACK_IMPORTED_MODULE_0__/* .NamedFunction */ .x9 {
}
class MathNamedFunction7 extends _Base__WEBPACK_IMPORTED_MODULE_0__/* .NamedFunction */ .x9 {
}
class MathNamedFunction8 extends _Base__WEBPACK_IMPORTED_MODULE_0__/* .NamedFunction */ .x9 {
}
const _vectorFunctionName_1 = (inputType) => {
  if (inputType == _nodes_utils_io_connections_Js__WEBPACK_IMPORTED_MODULE_1__/* .JsConnectionPointType.COLOR */ .zF.COLOR) {
    return "mathColor_1";
  }
  if (inputType == _nodes_utils_io_connections_Js__WEBPACK_IMPORTED_MODULE_1__/* .JsConnectionPointType.VECTOR2 */ .zF.VECTOR2) {
    return "mathVector2_1";
  }
  if (inputType == _nodes_utils_io_connections_Js__WEBPACK_IMPORTED_MODULE_1__/* .JsConnectionPointType.VECTOR3 */ .zF.VECTOR3) {
    return "mathVector3_1";
  }
  if (inputType == _nodes_utils_io_connections_Js__WEBPACK_IMPORTED_MODULE_1__/* .JsConnectionPointType.VECTOR4 */ .zF.VECTOR4) {
    return "mathVector4_1";
  }
};
const _vectorFunctionName_2 = (inputType) => {
  if (inputType == _nodes_utils_io_connections_Js__WEBPACK_IMPORTED_MODULE_1__/* .JsConnectionPointType.COLOR */ .zF.COLOR) {
    return "mathColor_2";
  }
  if (inputType == _nodes_utils_io_connections_Js__WEBPACK_IMPORTED_MODULE_1__/* .JsConnectionPointType.VECTOR2 */ .zF.VECTOR2) {
    return "mathVector2_2";
  }
  if (inputType == _nodes_utils_io_connections_Js__WEBPACK_IMPORTED_MODULE_1__/* .JsConnectionPointType.VECTOR3 */ .zF.VECTOR3) {
    return "mathVector3_2";
  }
  if (inputType == _nodes_utils_io_connections_Js__WEBPACK_IMPORTED_MODULE_1__/* .JsConnectionPointType.VECTOR4 */ .zF.VECTOR4) {
    return "mathVector4_2";
  }
};
const _vectorFunctionName_3 = (inputType) => {
  if (inputType == _nodes_utils_io_connections_Js__WEBPACK_IMPORTED_MODULE_1__/* .JsConnectionPointType.COLOR */ .zF.COLOR) {
    return "mathColor_3";
  }
  if (inputType == _nodes_utils_io_connections_Js__WEBPACK_IMPORTED_MODULE_1__/* .JsConnectionPointType.VECTOR2 */ .zF.VECTOR2) {
    return "mathVector2_3";
  }
  if (inputType == _nodes_utils_io_connections_Js__WEBPACK_IMPORTED_MODULE_1__/* .JsConnectionPointType.VECTOR3 */ .zF.VECTOR3) {
    return "mathVector3_3";
  }
  if (inputType == _nodes_utils_io_connections_Js__WEBPACK_IMPORTED_MODULE_1__/* .JsConnectionPointType.VECTOR4 */ .zF.VECTOR4) {
    return "mathVector4_3";
  }
};
const _vectorFunctionName_3vvf = (inputType) => {
  if (inputType == _nodes_utils_io_connections_Js__WEBPACK_IMPORTED_MODULE_1__/* .JsConnectionPointType.COLOR */ .zF.COLOR) {
    return "mathColor_3vvf";
  }
  if (inputType == _nodes_utils_io_connections_Js__WEBPACK_IMPORTED_MODULE_1__/* .JsConnectionPointType.VECTOR2 */ .zF.VECTOR2) {
    return "mathVector2_3vvf";
  }
  if (inputType == _nodes_utils_io_connections_Js__WEBPACK_IMPORTED_MODULE_1__/* .JsConnectionPointType.VECTOR3 */ .zF.VECTOR3) {
    return "mathVector3_3vvf";
  }
  if (inputType == _nodes_utils_io_connections_Js__WEBPACK_IMPORTED_MODULE_1__/* .JsConnectionPointType.VECTOR4 */ .zF.VECTOR4) {
    return "mathVector4_3vvf";
  }
};
const _vectorFunctionName_4 = (inputType) => {
  if (inputType == _nodes_utils_io_connections_Js__WEBPACK_IMPORTED_MODULE_1__/* .JsConnectionPointType.COLOR */ .zF.COLOR) {
    return "mathColor_4";
  }
  if (inputType == _nodes_utils_io_connections_Js__WEBPACK_IMPORTED_MODULE_1__/* .JsConnectionPointType.VECTOR2 */ .zF.VECTOR2) {
    return "mathVector2_4";
  }
  if (inputType == _nodes_utils_io_connections_Js__WEBPACK_IMPORTED_MODULE_1__/* .JsConnectionPointType.VECTOR3 */ .zF.VECTOR3) {
    return "mathVector3_4";
  }
  if (inputType == _nodes_utils_io_connections_Js__WEBPACK_IMPORTED_MODULE_1__/* .JsConnectionPointType.VECTOR4 */ .zF.VECTOR4) {
    return "mathVector4_4";
  }
};
const _vectorFunctionName_5 = (inputType) => {
  if (inputType == _nodes_utils_io_connections_Js__WEBPACK_IMPORTED_MODULE_1__/* .JsConnectionPointType.COLOR */ .zF.COLOR) {
    return "mathColor_5";
  }
  if (inputType == _nodes_utils_io_connections_Js__WEBPACK_IMPORTED_MODULE_1__/* .JsConnectionPointType.VECTOR2 */ .zF.VECTOR2) {
    return "mathVector2_5";
  }
  if (inputType == _nodes_utils_io_connections_Js__WEBPACK_IMPORTED_MODULE_1__/* .JsConnectionPointType.VECTOR3 */ .zF.VECTOR3) {
    return "mathVector3_5";
  }
  if (inputType == _nodes_utils_io_connections_Js__WEBPACK_IMPORTED_MODULE_1__/* .JsConnectionPointType.VECTOR4 */ .zF.VECTOR4) {
    return "mathVector4_5";
  }
};
const COLOR_FUNC_1 = (_func, src, target) => {
  target.r = _func(src.r);
  target.g = _func(src.g);
  target.b = _func(src.b);
  return target;
};
const COLOR_FUNC_2 = (_func, src, arg1, target) => {
  target.r = _func(src.r, arg1.r);
  target.g = _func(src.g, arg1.g);
  target.b = _func(src.b, arg1.b);
  return target;
};
const COLOR_FUNC_3 = (_func, src, arg1, arg2, target) => {
  target.r = _func(src.r, arg1.r, arg2.r);
  target.g = _func(src.g, arg1.g, arg2.g);
  target.b = _func(src.b, arg1.b, arg2.b);
  return target;
};
const COLOR_FUNC_3VVF = (_func, src, arg1, arg2, target) => {
  target.r = _func(src.r, arg1.r, arg2);
  target.g = _func(src.g, arg1.g, arg2);
  target.b = _func(src.b, arg1.b, arg2);
  return target;
};
const COLOR_FUNC_4 = (_func, src, arg1, arg2, arg3, target) => {
  target.r = _func(src.r, arg1.r, arg2.r, arg3.r);
  target.g = _func(src.g, arg1.g, arg2.g, arg3.g);
  target.b = _func(src.b, arg1.b, arg2.b, arg3.b);
  return target;
};
const COLOR_FUNC_5 = (_func, src, arg1, arg2, arg3, arg4, target) => {
  target.r = _func(src.r, arg1.r, arg2.r, arg3.r, arg4.r);
  target.g = _func(src.g, arg1.g, arg2.g, arg3.g, arg4.g);
  target.b = _func(src.b, arg1.b, arg2.b, arg3.b, arg4.b);
  return target;
};
const VECTOR2_FUNC_1 = (_func, src, target) => {
  target.x = _func(src.x);
  target.y = _func(src.y);
  return target;
};
const VECTOR2_FUNC_2 = (_func, src, arg1, target) => {
  target.x = _func(src.x, arg1.x);
  target.y = _func(src.y, arg1.y);
  return target;
};
const VECTOR2_FUNC_3 = (_func, src, arg1, arg2, target) => {
  target.x = _func(src.x, arg1.x, arg2.x);
  target.y = _func(src.y, arg1.y, arg2.y);
  return target;
};
const VECTOR2_FUNC_3VVF = (_func, src, arg1, arg2, target) => {
  target.x = _func(src.x, arg1.x, arg2);
  target.y = _func(src.y, arg1.y, arg2);
  return target;
};
const VECTOR2_FUNC_4 = (_func, src, arg1, arg2, arg3, target) => {
  target.x = _func(src.x, arg1.x, arg2.x, arg3.x);
  target.y = _func(src.y, arg1.y, arg2.y, arg3.y);
  return target;
};
const VECTOR2_FUNC_5 = (_func, src, arg1, arg2, arg3, arg4, target) => {
  target.x = _func(src.x, arg1.x, arg2.x, arg3.x, arg4.x);
  target.y = _func(src.y, arg1.y, arg2.y, arg3.y, arg4.y);
  return target;
};
const VECTOR3_FUNC_1 = (_func, src, target) => {
  target.x = _func(src.x);
  target.y = _func(src.y);
  target.z = _func(src.z);
  return target;
};
const VECTOR3_FUNC_2 = (_func, src, arg1, target) => {
  target.x = _func(src.x, arg1.x);
  target.y = _func(src.y, arg1.y);
  target.z = _func(src.z, arg1.z);
  return target;
};
const VECTOR3_FUNC_3 = (_func, src, arg1, arg2, target) => {
  target.x = _func(src.x, arg1.x, arg2.x);
  target.y = _func(src.y, arg1.y, arg2.y);
  target.z = _func(src.z, arg1.z, arg2.z);
  return target;
};
const VECTOR3_FUNC_3VVF = (_func, src, arg1, arg2, target) => {
  target.x = _func(src.x, arg1.x, arg2);
  target.y = _func(src.y, arg1.y, arg2);
  target.z = _func(src.z, arg1.z, arg2);
  return target;
};
const VECTOR3_FUNC_4 = (_func, src, arg1, arg2, arg3, target) => {
  target.x = _func(src.x, arg1.x, arg2.x, arg3.x);
  target.y = _func(src.y, arg1.y, arg2.y, arg3.y);
  target.z = _func(src.z, arg1.z, arg2.z, arg3.z);
  return target;
};
const VECTOR3_FUNC_5 = (_func, src, arg1, arg2, arg3, arg4, target) => {
  target.x = _func(src.x, arg1.x, arg2.x, arg3.x, arg4.x);
  target.y = _func(src.y, arg1.y, arg2.y, arg3.y, arg4.y);
  target.z = _func(src.z, arg1.z, arg2.z, arg3.z, arg4.z);
  return target;
};
const VECTOR4_FUNC_1 = (_func, src, target) => {
  target.x = _func(src.x);
  target.y = _func(src.y);
  target.z = _func(src.z);
  target.w = _func(src.w);
  return target;
};
const VECTOR4_FUNC_2 = (_func, src, arg1, target) => {
  target.x = _func(src.x, arg1.x);
  target.y = _func(src.y, arg1.y);
  target.z = _func(src.z, arg1.z);
  target.w = _func(src.w, arg1.w);
  return target;
};
const VECTOR4_FUNC_3 = (_func, src, arg1, arg2, target) => {
  target.x = _func(src.x, arg1.x, arg2.x);
  target.y = _func(src.y, arg1.y, arg2.y);
  target.z = _func(src.z, arg1.z, arg2.z);
  target.w = _func(src.w, arg1.w, arg2.w);
  return target;
};
const VECTOR4_FUNC_3VVF = (_func, src, arg1, arg2, target) => {
  target.x = _func(src.x, arg1.x, arg2);
  target.y = _func(src.y, arg1.y, arg2);
  target.z = _func(src.z, arg1.z, arg2);
  target.w = _func(src.w, arg1.w, arg2);
  return target;
};
const VECTOR4_FUNC_4 = (_func, src, arg1, arg2, arg3, target) => {
  target.x = _func(src.x, arg1.x, arg2.x, arg3.x);
  target.y = _func(src.y, arg1.y, arg2.y, arg3.y);
  target.z = _func(src.z, arg1.z, arg2.z, arg3.z);
  target.w = _func(src.w, arg1.w, arg2.w, arg3.w);
  return target;
};
const VECTOR4_FUNC_5 = (_func, src, arg1, arg2, arg3, arg4, target) => {
  target.x = _func(src.x, arg1.x, arg2.x, arg3.x, arg4.x);
  target.y = _func(src.y, arg1.y, arg2.y, arg3.y, arg4.y);
  target.z = _func(src.z, arg1.z, arg2.z, arg3.z, arg4.z);
  target.w = _func(src.w, arg1.w, arg2.w, arg3.w, arg4.w);
  return target;
};
class mathFloat_1 extends MathNamedFunction2 {
  static type() {
    return "mathFloat_1";
  }
  func(_func, value) {
    return _func(value);
  }
}
class mathFloat_2 extends MathNamedFunction3 {
  static type() {
    return "mathFloat_2";
  }
  func(_func, value, arg1) {
    return _func(value, arg1);
  }
}
class mathFloat_3 extends MathNamedFunction4 {
  static type() {
    return "mathFloat_3";
  }
  func(_func, value, arg1, arg2) {
    return _func(value, arg1, arg2);
  }
}
class mathFloat_4 extends MathNamedFunction5 {
  static type() {
    return "mathFloat_4";
  }
  func(_func, value, arg1, arg2, arg3) {
    return _func(value, arg1, arg2, arg3);
  }
}
class mathFloat_5 extends MathNamedFunction6 {
  static type() {
    return "mathFloat_5";
  }
  func(_func, value, arg1, arg2, arg3, arg4) {
    return _func(value, arg1, arg2, arg3, arg4);
  }
}
class mathColor_1 extends MathNamedFunction3 {
  constructor() {
    super(...arguments);
    this.func = COLOR_FUNC_1;
  }
  static type() {
    return "mathColor_1";
  }
}
class mathColor_2 extends MathNamedFunction4 {
  constructor() {
    super(...arguments);
    this.func = COLOR_FUNC_2;
  }
  static type() {
    return "mathColor_2";
  }
}
class mathColor_3 extends MathNamedFunction5 {
  constructor() {
    super(...arguments);
    this.func = COLOR_FUNC_3;
  }
  static type() {
    return "mathColor_3";
  }
}
class mathColor_3vvf extends MathNamedFunction5 {
  constructor() {
    super(...arguments);
    this.func = COLOR_FUNC_3VVF;
  }
  static type() {
    return "mathColor_3vvf";
  }
}
class mathColor_4 extends MathNamedFunction6 {
  constructor() {
    super(...arguments);
    this.func = COLOR_FUNC_4;
  }
  static type() {
    return "mathColor_4";
  }
}
class mathColor_5 extends MathNamedFunction7 {
  constructor() {
    super(...arguments);
    this.func = COLOR_FUNC_5;
  }
  static type() {
    return "mathColor_5";
  }
}
class mathVector2_1 extends MathNamedFunction3 {
  constructor() {
    super(...arguments);
    this.func = VECTOR2_FUNC_1;
  }
  static type() {
    return "mathVector2_1";
  }
}
class mathVector2_2 extends MathNamedFunction4 {
  constructor() {
    super(...arguments);
    this.func = VECTOR2_FUNC_2;
  }
  static type() {
    return "mathVector2_2";
  }
}
class mathVector2_3 extends MathNamedFunction5 {
  constructor() {
    super(...arguments);
    this.func = VECTOR2_FUNC_3;
  }
  static type() {
    return "mathVector2_3";
  }
}
class mathVector2_3vvf extends MathNamedFunction5 {
  constructor() {
    super(...arguments);
    this.func = VECTOR2_FUNC_3VVF;
  }
  static type() {
    return "mathVector2_3vvf";
  }
}
class mathVector2_4 extends MathNamedFunction6 {
  constructor() {
    super(...arguments);
    this.func = VECTOR2_FUNC_4;
  }
  static type() {
    return "mathVector2_4";
  }
}
class mathVector2_5 extends MathNamedFunction7 {
  constructor() {
    super(...arguments);
    this.func = VECTOR2_FUNC_5;
  }
  static type() {
    return "mathVector2_5";
  }
}
class mathVector3_1 extends MathNamedFunction3 {
  constructor() {
    super(...arguments);
    this.func = VECTOR3_FUNC_1;
  }
  static type() {
    return "mathVector3_1";
  }
}
class mathVector3_2 extends MathNamedFunction4 {
  constructor() {
    super(...arguments);
    this.func = VECTOR3_FUNC_2;
  }
  static type() {
    return "mathVector3_2";
  }
}
class mathVector3_3 extends MathNamedFunction5 {
  constructor() {
    super(...arguments);
    this.func = VECTOR3_FUNC_3;
  }
  static type() {
    return "mathVector3_3";
  }
}
class mathVector3_3vvf extends MathNamedFunction5 {
  constructor() {
    super(...arguments);
    this.func = VECTOR3_FUNC_3VVF;
  }
  static type() {
    return "mathVector3_3vvf";
  }
}
class mathVector3_4 extends MathNamedFunction6 {
  constructor() {
    super(...arguments);
    this.func = VECTOR3_FUNC_4;
  }
  static type() {
    return "mathVector3_4";
  }
}
class mathVector3_5 extends MathNamedFunction7 {
  constructor() {
    super(...arguments);
    this.func = VECTOR3_FUNC_5;
  }
  static type() {
    return "mathVector3_5";
  }
}
class mathVector4_1 extends MathNamedFunction3 {
  constructor() {
    super(...arguments);
    this.func = VECTOR4_FUNC_1;
  }
  static type() {
    return "mathVector4_1";
  }
}
class mathVector4_2 extends MathNamedFunction4 {
  constructor() {
    super(...arguments);
    this.func = VECTOR4_FUNC_2;
  }
  static type() {
    return "mathVector4_2";
  }
}
class mathVector4_3 extends MathNamedFunction5 {
  constructor() {
    super(...arguments);
    this.func = VECTOR4_FUNC_3;
  }
  static type() {
    return "mathVector4_3";
  }
}
class mathVector4_3vvf extends MathNamedFunction5 {
  constructor() {
    super(...arguments);
    this.func = VECTOR4_FUNC_3VVF;
  }
  static type() {
    return "mathVector4_3vvf";
  }
}
class mathVector4_4 extends MathNamedFunction6 {
  constructor() {
    super(...arguments);
    this.func = VECTOR4_FUNC_4;
  }
  static type() {
    return "mathVector4_4";
  }
}
class mathVector4_5 extends MathNamedFunction7 {
  constructor() {
    super(...arguments);
    this.func = VECTOR4_FUNC_5;
  }
  static type() {
    return "mathVector4_5";
  }
}
class mathPrimArray_1 extends MathNamedFunction3 {
  static type() {
    return "mathPrimArray_1";
  }
  func(_func, srcElements, targetElements) {
    (0,_ArrayUtils__WEBPACK_IMPORTED_MODULE_2__/* ._matchArrayLength */ .X9)(srcElements, targetElements, () => srcElements[0] || 0);
    let i = 0;
    for (let src of srcElements) {
      targetElements[i] = _func(src);
      i++;
    }
    return targetElements;
  }
}
class mathPrimArray_2 extends MathNamedFunction4 {
  static type() {
    return "mathPrimArray_2";
  }
  func(_func, srcElements, arg1, targetElements) {
    (0,_ArrayUtils__WEBPACK_IMPORTED_MODULE_2__/* ._matchArrayLength */ .X9)(srcElements, targetElements, () => srcElements[0] || 0);
    let i = 0;
    for (let src of srcElements) {
      targetElements[i] = _func(src, arg1);
      i++;
    }
    return targetElements;
  }
}
class mathPrimArray_3 extends MathNamedFunction5 {
  static type() {
    return "mathPrimArray_3";
  }
  func(_func, srcElements, arg1, arg2, targetElements) {
    (0,_ArrayUtils__WEBPACK_IMPORTED_MODULE_2__/* ._matchArrayLength */ .X9)(srcElements, targetElements, () => srcElements[0] || 0);
    let i = 0;
    for (let src of srcElements) {
      targetElements[i] = _func(src, arg1, arg2);
      i++;
    }
    return targetElements;
  }
}
class mathPrimArray_4 extends MathNamedFunction6 {
  static type() {
    return "mathPrimArray_4";
  }
  func(_func, srcElements, arg1, arg2, arg3, targetElements) {
    (0,_ArrayUtils__WEBPACK_IMPORTED_MODULE_2__/* ._matchArrayLength */ .X9)(srcElements, targetElements, () => srcElements[0] || 0);
    let i = 0;
    for (let src of srcElements) {
      targetElements[i] = _func(src, arg1, arg2, arg3);
      i++;
    }
    return targetElements;
  }
}
class mathPrimArray_5 extends MathNamedFunction7 {
  static type() {
    return "mathPrimArray_5";
  }
  func(_func, srcElements, arg1, arg2, arg3, arg4, targetElements) {
    (0,_ArrayUtils__WEBPACK_IMPORTED_MODULE_2__/* ._matchArrayLength */ .X9)(srcElements, targetElements, () => srcElements[0] || 0);
    let i = 0;
    for (let src of srcElements) {
      targetElements[i] = _func(src, arg1, arg2, arg3, arg4);
      i++;
    }
    return targetElements;
  }
}
class mathVectorArray_1 extends MathNamedFunction4 {
  static type() {
    return "mathVectorArray_1";
  }
  func(_func, vectorFunc, srcElements, targetElements) {
    (0,_ArrayUtils__WEBPACK_IMPORTED_MODULE_2__/* ._matchArrayLength */ .X9)(srcElements, targetElements, () => srcElements[0].clone());
    let i = 0;
    for (let src of srcElements) {
      const target = targetElements[i];
      vectorFunc(_func, src, target);
      i++;
    }
    return targetElements;
  }
}
class mathVectorArray_2 extends MathNamedFunction5 {
  static type() {
    return "mathVectorArray_2";
  }
  func(_func, vectorFunc, srcElements, arg1, targetElements) {
    (0,_ArrayUtils__WEBPACK_IMPORTED_MODULE_2__/* ._matchArrayLength */ .X9)(srcElements, targetElements, () => srcElements[0].clone());
    let i = 0;
    for (let src of srcElements) {
      const target = targetElements[i];
      vectorFunc(_func, src, arg1, target);
      i++;
    }
    return targetElements;
  }
}
class mathVectorArray_3 extends MathNamedFunction6 {
  static type() {
    return "mathVectorArray_3";
  }
  func(_func, vectorFunc, srcElements, arg1, arg2, targetElements) {
    (0,_ArrayUtils__WEBPACK_IMPORTED_MODULE_2__/* ._matchArrayLength */ .X9)(srcElements, targetElements, () => srcElements[0].clone());
    let i = 0;
    for (let src of srcElements) {
      const target = targetElements[i];
      vectorFunc(_func, src, arg1, arg2, target);
      i++;
    }
    return targetElements;
  }
}
class mathVectorArray_4 extends MathNamedFunction7 {
  static type() {
    return "mathVectorArray_4";
  }
  func(_func, vectorFunc, srcElements, arg1, arg2, arg3, targetElements) {
    (0,_ArrayUtils__WEBPACK_IMPORTED_MODULE_2__/* ._matchArrayLength */ .X9)(srcElements, targetElements, () => srcElements[0].clone());
    let i = 0;
    for (let src of srcElements) {
      const target = targetElements[i];
      vectorFunc(_func, src, arg1, arg2, arg3, target);
      i++;
    }
    return targetElements;
  }
}
class mathVectorArray_5 extends MathNamedFunction8 {
  static type() {
    return "mathVectorArray_5";
  }
  func(_func, vectorFunc, srcElements, arg1, arg2, arg3, arg4, targetElements) {
    (0,_ArrayUtils__WEBPACK_IMPORTED_MODULE_2__/* ._matchArrayLength */ .X9)(srcElements, targetElements, () => srcElements[0].clone());
    let i = 0;
    for (let src of srcElements) {
      const target = targetElements[i];
      vectorFunc(_func, src, arg1, arg2, arg3, arg4, target);
      i++;
    }
    return targetElements;
  }
}


/***/ }),

/***/ 15938:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "$1": function() { return /* binding */ maxV3Component; },
/* harmony export */   "$x": function() { return /* binding */ absV3; },
/* harmony export */   "HM": function() { return /* binding */ componentsForType; },
/* harmony export */   "Nq": function() { return /* binding */ maxV3Components; },
/* harmony export */   "Yh": function() { return /* binding */ absV2; },
/* harmony export */   "c2": function() { return /* binding */ vector2Dot; },
/* harmony export */   "eM": function() { return /* binding */ vector3Clamp; },
/* harmony export */   "jb": function() { return /* binding */ vector2MaxScalar; }
/* harmony export */ });
/* unused harmony exports _v2Function, _v3Function */
/* harmony import */ var _nodes_utils_io_connections_Js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(38857);
/* harmony import */ var _core_math_Module__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(27462);



const RGB = ["r", "g", "b"];
const XY = ["x", "y"];
const XYZ = ["x", "y", "z"];
const XYZW = ["x", "y", "z", "w"];
const COMPONENT_BY_JS_TYPE = {
  [_nodes_utils_io_connections_Js__WEBPACK_IMPORTED_MODULE_0__/* .JsConnectionPointType.COLOR */ .zF.COLOR]: RGB,
  [_nodes_utils_io_connections_Js__WEBPACK_IMPORTED_MODULE_0__/* .JsConnectionPointType.VECTOR2 */ .zF.VECTOR2]: XY,
  [_nodes_utils_io_connections_Js__WEBPACK_IMPORTED_MODULE_0__/* .JsConnectionPointType.VECTOR3 */ .zF.VECTOR3]: XYZ,
  [_nodes_utils_io_connections_Js__WEBPACK_IMPORTED_MODULE_0__/* .JsConnectionPointType.VECTOR4 */ .zF.VECTOR4]: XYZW
};
function componentsForType(type) {
  return COMPONENT_BY_JS_TYPE[type] || [];
}
function _v2Function(src, target, _func) {
  target.x = _func(src.x);
  target.y = _func(src.y);
  return target;
}
function _v3Function(src, target, _func) {
  target.x = _func(src.x);
  target.y = _func(src.y);
  target.z = _func(src.z);
  return target;
}
function absV2(src, target) {
  return _v2Function(src, target, Math.abs);
}
function absV3(src, target) {
  return _v3Function(src, target, Math.abs);
}
function maxV3Components(src) {
  return Math.max(src.x, Math.max(src.y, src.z));
}
function vector3Clamp(src, min, max, target) {
  target.x = (0,_core_math_Module__WEBPACK_IMPORTED_MODULE_1__/* .clamp */ .uZ)(src.x, min.x, max.x);
  target.y = (0,_core_math_Module__WEBPACK_IMPORTED_MODULE_1__/* .clamp */ .uZ)(src.y, min.y, max.y);
  target.z = (0,_core_math_Module__WEBPACK_IMPORTED_MODULE_1__/* .clamp */ .uZ)(src.z, min.z, max.z);
  return target;
}
function maxV3Component(src, target, value) {
  target.x = Math.max(src.x, value);
  target.y = Math.max(src.y, value);
  target.z = Math.max(src.z, value);
  return target;
}
function vector2MaxScalar(src, scalar, target) {
  target.x = Math.max(src.x, scalar);
  target.y = Math.max(src.y, scalar);
  return target;
}
function vector2Dot(src) {
  return src.dot(src);
}


/***/ }),

/***/ 42711:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "E": function() { return /* binding */ DelayAnimNode; }
/* harmony export */ });
/* harmony import */ var _Base__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(44276);
/* harmony import */ var _core_animation_TimelineBuilder__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(82756);
/* harmony import */ var _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(96949);




class DelayAnimParamsConfig extends _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_0__/* .NodeParamsConfig */ .yI {
  constructor() {
    super(...arguments);
    /** @param delay */
    this.delay = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_0__/* .ParamConfig.FLOAT */ .XC.FLOAT(1);
  }
}
const ParamsConfig = new DelayAnimParamsConfig();
class DelayAnimNode extends _Base__WEBPACK_IMPORTED_MODULE_1__/* .TypedAnimNode */ .D {
  constructor() {
    super(...arguments);
    this.paramsConfig = ParamsConfig;
  }
  static type() {
    return "delay";
  }
  initializeNode() {
    this.io.inputs.setCount(0, 1);
  }
  cook(input_contents) {
    const timeline_builder = input_contents[0] || new _core_animation_TimelineBuilder__WEBPACK_IMPORTED_MODULE_2__/* .TimelineBuilder */ .S();
    timeline_builder.setDelay(this.pv.delay);
    this.setTimelineBuilder(timeline_builder);
  }
}


/***/ }),

/***/ 2430:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "N": function() { return /* binding */ DurationAnimNode; }
/* harmony export */ });
/* harmony import */ var _Base__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(44276);
/* harmony import */ var _core_animation_TimelineBuilder__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(82756);
/* harmony import */ var _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(96949);




class DurationAnimParamsConfig extends _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_0__/* .NodeParamsConfig */ .yI {
  constructor() {
    super(...arguments);
    /** @param duration */
    this.duration = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_0__/* .ParamConfig.FLOAT */ .XC.FLOAT(1, {
      range: [0, 10],
      rangeLocked: [true, false]
    });
  }
}
const ParamsConfig = new DurationAnimParamsConfig();
class DurationAnimNode extends _Base__WEBPACK_IMPORTED_MODULE_1__/* .TypedAnimNode */ .D {
  constructor() {
    super(...arguments);
    this.paramsConfig = ParamsConfig;
  }
  static type() {
    return "duration";
  }
  initializeNode() {
    this.io.inputs.setCount(0, 1);
  }
  cook(input_contents) {
    const timeline_builder = input_contents[0] || new _core_animation_TimelineBuilder__WEBPACK_IMPORTED_MODULE_2__/* .TimelineBuilder */ .S();
    timeline_builder.setDuration(this.pv.duration);
    this.setTimelineBuilder(timeline_builder);
  }
}


/***/ }),

/***/ 39448:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "v": function() { return /* binding */ EasingAnimNode; }
/* harmony export */ });
/* harmony import */ var _Base__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(44276);
/* harmony import */ var _core_animation_TimelineBuilder__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(82756);
/* harmony import */ var _core_animation_Constant__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(88218);
/* harmony import */ var _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(96949);
/* harmony import */ var _poly_registers_nodes_types_Anim__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(28567);






class EasingAnimParamsConfig extends _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_0__/* .NodeParamsConfig */ .yI {
  constructor() {
    super(...arguments);
    /** @param name of easing */
    this.name = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_0__/* .ParamConfig.INTEGER */ .XC.INTEGER(_core_animation_Constant__WEBPACK_IMPORTED_MODULE_1__/* .EASINGS.indexOf */ .Lj.indexOf(_core_animation_Constant__WEBPACK_IMPORTED_MODULE_1__/* .AnimNodeEasing.POWER4 */ .Mx.POWER4), {
      menu: {
        entries: _core_animation_Constant__WEBPACK_IMPORTED_MODULE_1__/* .EASINGS.map */ .Lj.map((name, value) => {
          return { name, value };
        })
      }
    });
    /** @param defines if the easing is 'in', 'out' or 'in-out' */
    this.inOut = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_0__/* .ParamConfig.INTEGER */ .XC.INTEGER(_core_animation_Constant__WEBPACK_IMPORTED_MODULE_1__/* .IN_OUT_MODES.indexOf */ .MP.indexOf(_core_animation_Constant__WEBPACK_IMPORTED_MODULE_1__/* .InOutMode.OUT */ .LL.OUT), {
      menu: {
        entries: _core_animation_Constant__WEBPACK_IMPORTED_MODULE_1__/* .IN_OUT_MODES.map */ .MP.map((name, value) => {
          return { name, value };
        })
      }
    });
  }
}
const ParamsConfig = new EasingAnimParamsConfig();
class EasingAnimNode extends _Base__WEBPACK_IMPORTED_MODULE_2__/* .TypedAnimNode */ .D {
  constructor() {
    super(...arguments);
    this.paramsConfig = ParamsConfig;
  }
  static type() {
    return _poly_registers_nodes_types_Anim__WEBPACK_IMPORTED_MODULE_3__/* .AnimType.EASING */ .R.EASING;
  }
  initializeNode() {
    this.io.inputs.setCount(0, 1);
  }
  setEasing(mode) {
    this.p.name.set(_core_animation_Constant__WEBPACK_IMPORTED_MODULE_1__/* .EASINGS.indexOf */ .Lj.indexOf(mode));
  }
  setInOut(inOut) {
    this.p.inOut.set(_core_animation_Constant__WEBPACK_IMPORTED_MODULE_1__/* .IN_OUT_MODES.indexOf */ .MP.indexOf(inOut));
  }
  static easingFullName(node) {
    const easing = _core_animation_Constant__WEBPACK_IMPORTED_MODULE_1__/* .EASINGS */ .Lj[node.pv.name];
    if (easing == _core_animation_Constant__WEBPACK_IMPORTED_MODULE_1__/* .AnimNodeEasing.NONE */ .Mx.NONE) {
      return easing;
    }
    const in_out = _core_animation_Constant__WEBPACK_IMPORTED_MODULE_1__/* .IN_OUT_MODES */ .MP[node.pv.inOut];
    const easing_full_name = `${easing}.${in_out}`;
    return easing_full_name;
  }
  cook(input_contents) {
    const timeline_builder = input_contents[0] || new _core_animation_TimelineBuilder__WEBPACK_IMPORTED_MODULE_4__/* .TimelineBuilder */ .S();
    const easingFullName = EasingAnimNode.easingFullName(this);
    timeline_builder.setEasing(easingFullName);
    this.setTimelineBuilder(timeline_builder);
  }
}


/***/ }),

/***/ 17830:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "C": function() { return /* binding */ MergeAnimNode; },
/* harmony export */   "U": function() { return /* binding */ EASING_ANIM_MERGE_MODES; }
/* harmony export */ });
/* harmony import */ var _Base__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(44276);
/* harmony import */ var _core_animation_TimelineBuilder__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(82756);
/* harmony import */ var _poly_Assert__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(68239);
/* harmony import */ var _core_animation_Position__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(46833);
/* harmony import */ var _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(96949);
/* harmony import */ var _core_BooleanValue__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(19037);
/* harmony import */ var _poly_NodeEvent__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(25332);








var MergeMode = /* @__PURE__ */ ((MergeMode2) => {
  MergeMode2["ALL_TOGETHER"] = "play all together";
  MergeMode2["ONE_AT_A_TIME"] = "play one at a time";
  return MergeMode2;
})(MergeMode || {});
const EASING_ANIM_MERGE_MODES = ["play all together" /* ALL_TOGETHER */, "play one at a time" /* ONE_AT_A_TIME */];
const DEFAULT_INPUTS_COUNT = 4;
class MergeAnimParamsConfig extends _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_0__/* .NodeParamsConfig */ .yI {
  constructor() {
    super(...arguments);
    /** @param mode (at the same time or one after the other) */
    this.mode = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_0__/* .ParamConfig.INTEGER */ .XC.INTEGER(0, {
      menu: {
        entries: EASING_ANIM_MERGE_MODES.map((name, value) => {
          return { name, value };
        })
      }
    });
    /** @param offset if run one after the other */
    this.offset = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_0__/* .ParamConfig.FLOAT */ .XC.FLOAT(0, {
      range: [-1, 1]
    });
    /** @param override the position */
    this.overridePositions = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_0__/* .ParamConfig.BOOLEAN */ .XC.BOOLEAN(0);
    /** @param number of inputs that this node can merge animations from */
    this.inputsCount = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_0__/* .ParamConfig.INTEGER */ .XC.INTEGER(DEFAULT_INPUTS_COUNT, {
      range: [1, 32],
      rangeLocked: [true, false],
      callback: (node) => {
        MergeAnimNode.PARAM_CALLBACK_setInputsCount(node);
      }
    });
  }
}
const ParamsConfig = new MergeAnimParamsConfig();
class MergeAnimNode extends _Base__WEBPACK_IMPORTED_MODULE_1__/* .TypedAnimNode */ .D {
  constructor() {
    super(...arguments);
    this.paramsConfig = ParamsConfig;
  }
  static type() {
    return "merge";
  }
  initializeNode() {
    this.io.inputs.setCount(0, 4);
    this.params.onParamsCreated("pdateInputsEvaluation", () => {
      this._callbackUpdateInputsCount();
    });
  }
  cook(inputContents) {
    const mergedTimelineBuilder = new _core_animation_TimelineBuilder__WEBPACK_IMPORTED_MODULE_2__/* .TimelineBuilder */ .S();
    let i = 0;
    for (const timelineBuilder of inputContents) {
      if (timelineBuilder) {
        if (i > 0) {
          this._updateTimelineBuilder(timelineBuilder);
        }
        mergedTimelineBuilder.addTimelineBuilder(timelineBuilder);
        i++;
      }
    }
    this.setTimelineBuilder(mergedTimelineBuilder);
  }
  _updateTimelineBuilder(timelineBuilder) {
    const mode = EASING_ANIM_MERGE_MODES[this.pv.mode];
    switch (mode) {
      case "play all together" /* ALL_TOGETHER */:
        return this._setPlayAllTogether(timelineBuilder);
      case "play one at a time" /* ONE_AT_A_TIME */:
        return this._setPlayOneAtATime(timelineBuilder);
    }
    _poly_Assert__WEBPACK_IMPORTED_MODULE_3__/* .TypeAssert.unreachable */ .f.unreachable(mode);
  }
  _setPlayAllTogether(timelineBuilder) {
    let position = timelineBuilder.position();
    if (!position || (0,_core_BooleanValue__WEBPACK_IMPORTED_MODULE_4__/* .isBooleanTrue */ .bI)(this.pv.overridePositions)) {
      position = new _core_animation_Position__WEBPACK_IMPORTED_MODULE_5__/* .AnimationPosition */ .wM();
      position.setMode(_core_animation_Position__WEBPACK_IMPORTED_MODULE_5__/* .AnimationPositionMode.RELATIVE */ .j1.RELATIVE);
      position.setRelativeTo(_core_animation_Position__WEBPACK_IMPORTED_MODULE_5__/* .AnimationPositionRelativeTo.START */ .BT.START);
      position.setOffset(this.pv.offset);
      timelineBuilder.setPosition(position);
    }
  }
  _setPlayOneAtATime(timelineBuilder) {
    let position = timelineBuilder.position();
    if (!position || (0,_core_BooleanValue__WEBPACK_IMPORTED_MODULE_4__/* .isBooleanTrue */ .bI)(this.pv.overridePositions)) {
      position = new _core_animation_Position__WEBPACK_IMPORTED_MODULE_5__/* .AnimationPosition */ .wM();
      position.setMode(_core_animation_Position__WEBPACK_IMPORTED_MODULE_5__/* .AnimationPositionMode.RELATIVE */ .j1.RELATIVE);
      position.setRelativeTo(_core_animation_Position__WEBPACK_IMPORTED_MODULE_5__/* .AnimationPositionRelativeTo.END */ .BT.END);
      position.setOffset(this.pv.offset);
      timelineBuilder.setPosition(position);
    }
  }
  _callbackUpdateInputsCount() {
    this.io.inputs.setCount(1, this.pv.inputsCount);
    this.emit(_poly_NodeEvent__WEBPACK_IMPORTED_MODULE_6__/* .NodeEvent.INPUTS_UPDATED */ .b.INPUTS_UPDATED);
  }
  static PARAM_CALLBACK_setInputsCount(node) {
    node._callbackUpdateInputsCount();
  }
}


/***/ }),

/***/ 42187:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "j": function() { return /* binding */ OperationAnimNode; }
/* harmony export */ });
/* harmony import */ var _Base__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(44276);
/* harmony import */ var _core_animation_TimelineBuilder__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(82756);
/* harmony import */ var _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(96949);
/* harmony import */ var _core_animation_vars_AnimBuilderTypes__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(39470);





class OperationAnimParamsConfig extends _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_0__/* .NodeParamsConfig */ .yI {
  constructor() {
    super(...arguments);
    /** @param sets the operation (set, add or subtract) */
    this.operation = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_0__/* .ParamConfig.INTEGER */ .XC.INTEGER(0, {
      menu: {
        entries: _core_animation_vars_AnimBuilderTypes__WEBPACK_IMPORTED_MODULE_1__/* .OPERATIONS.map */ .s.map((name, value) => {
          return { value, name };
        })
      }
    });
  }
}
const ParamsConfig = new OperationAnimParamsConfig();
class OperationAnimNode extends _Base__WEBPACK_IMPORTED_MODULE_2__/* .TypedAnimNode */ .D {
  constructor() {
    super(...arguments);
    this.paramsConfig = ParamsConfig;
  }
  static type() {
    return "operation";
  }
  initializeNode() {
    this.io.inputs.setCount(0, 1);
  }
  cook(input_contents) {
    const timeline_builder = input_contents[0] || new _core_animation_TimelineBuilder__WEBPACK_IMPORTED_MODULE_3__/* .TimelineBuilder */ .S();
    timeline_builder.setOperation(_core_animation_vars_AnimBuilderTypes__WEBPACK_IMPORTED_MODULE_1__/* .OPERATIONS */ .s[this.pv.operation]);
    this.setTimelineBuilder(timeline_builder);
  }
}


/***/ }),

/***/ 2189:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "y": function() { return /* binding */ PositionAnimNode; }
/* harmony export */ });
/* harmony import */ var _Base__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(44276);
/* harmony import */ var _core_animation_TimelineBuilder__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(82756);
/* harmony import */ var _core_animation_Position__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(46833);
/* harmony import */ var _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(96949);





class PositionAnimParamsConfig extends _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_0__/* .NodeParamsConfig */ .yI {
  constructor() {
    super(...arguments);
    /** @param sets the mode of the position. It can either be relative or absolute */
    this.mode = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_0__/* .ParamConfig.INTEGER */ .XC.INTEGER(0, {
      menu: {
        entries: _core_animation_Position__WEBPACK_IMPORTED_MODULE_1__/* .ANIMATION_POSITION_MODES.map */ .$o.map((name, value) => {
          return { name, value };
        })
      }
    });
    /** @param if sets to relative, sets if it is relative to the start or end */
    this.relativeTo = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_0__/* .ParamConfig.INTEGER */ .XC.INTEGER(0, {
      menu: {
        entries: _core_animation_Position__WEBPACK_IMPORTED_MODULE_1__/* .ANIMATION_POSITION_RELATIVE_TOS.map */ .gY.map((name, value) => {
          return { name, value };
        })
      }
    });
    /** @param offset */
    this.offset = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_0__/* .ParamConfig.FLOAT */ .XC.FLOAT(0);
  }
}
const ParamsConfig = new PositionAnimParamsConfig();
class PositionAnimNode extends _Base__WEBPACK_IMPORTED_MODULE_2__/* .TypedAnimNode */ .D {
  constructor() {
    super(...arguments);
    this.paramsConfig = ParamsConfig;
  }
  static type() {
    return "position";
  }
  initializeNode() {
    this.io.inputs.setCount(0, 1);
  }
  setMode(mode) {
    this.p.mode.set(_core_animation_Position__WEBPACK_IMPORTED_MODULE_1__/* .ANIMATION_POSITION_MODES.indexOf */ .$o.indexOf(mode));
  }
  setRelativeTo(relativeTo) {
    this.p.relativeTo.set(_core_animation_Position__WEBPACK_IMPORTED_MODULE_1__/* .ANIMATION_POSITION_RELATIVE_TOS.indexOf */ .gY.indexOf(relativeTo));
  }
  cook(input_contents) {
    const timeline_builder = input_contents[0] || new _core_animation_TimelineBuilder__WEBPACK_IMPORTED_MODULE_3__/* .TimelineBuilder */ .S();
    const position = new _core_animation_Position__WEBPACK_IMPORTED_MODULE_1__/* .AnimationPosition */ .wM();
    position.setMode(_core_animation_Position__WEBPACK_IMPORTED_MODULE_1__/* .ANIMATION_POSITION_MODES */ .$o[this.pv.mode]);
    position.setRelativeTo(_core_animation_Position__WEBPACK_IMPORTED_MODULE_1__/* .ANIMATION_POSITION_RELATIVE_TOS */ .gY[this.pv.relativeTo]);
    position.setOffset(this.pv.offset);
    timeline_builder.setPosition(position);
    this.setTimelineBuilder(timeline_builder);
  }
}


/***/ }),

/***/ 13769:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "U": function() { return /* binding */ PostProcessNetworkAnimNode; }
/* harmony export */ });
/* harmony import */ var _BaseManager__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(68378);
/* harmony import */ var _poly_NodeContext__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(52070);
/* harmony import */ var _utils_DisplayNodeController__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(35725);
/* harmony import */ var _post_utils_EffectComposerController__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(32241);





class PostProcessNetworkAnimNode extends _BaseManager__WEBPACK_IMPORTED_MODULE_0__/* .BaseNetworkAnimNode */ .M {
  constructor() {
    super(...arguments);
    this.paramsConfig = new _post_utils_EffectComposerController__WEBPACK_IMPORTED_MODULE_1__/* .PostProcessNetworkParamsConfig */ .Ab();
    this.effectsComposerController = new _post_utils_EffectComposerController__WEBPACK_IMPORTED_MODULE_1__/* .EffectComposerController */ .iy(this);
    this.displayNodeController = new _utils_DisplayNodeController__WEBPACK_IMPORTED_MODULE_2__/* .DisplayNodeController */ .v(
      this,
      this.effectsComposerController.displayNodeControllerCallbacks()
    );
    this._childrenControllerContext = _poly_NodeContext__WEBPACK_IMPORTED_MODULE_3__/* .NodeContext.POST */ .sy.POST;
  }
  static type() {
    return _poly_NodeContext__WEBPACK_IMPORTED_MODULE_3__/* .NetworkNodeType.POST */ .kX.POST;
  }
  createNode(node_class, options) {
    return super.createNode(node_class, options);
  }
  children() {
    return super.children();
  }
  nodesByType(type) {
    return super.nodesByType(type);
  }
}


/***/ }),

/***/ 66318:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "K": function() { return /* binding */ PropertyValueAnimNode; }
/* harmony export */ });
/* unused harmony export AnimPropertyValueNodeMode */
/* harmony import */ var _Base__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(44276);
/* harmony import */ var _core_animation_TimelineBuilder__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(82756);
/* harmony import */ var _core_BooleanValue__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(19037);
/* harmony import */ var _poly_Assert__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(68239);
/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(21410);
/* harmony import */ var _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(96949);

var __async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};







var AnimPropertyValueNodeMode = /* @__PURE__ */ ((AnimPropertyValueNodeMode2) => {
  AnimPropertyValueNodeMode2["CUSTOM"] = "custom";
  AnimPropertyValueNodeMode2["FROM_SCENE_GRAPH"] = "from scene graph";
  AnimPropertyValueNodeMode2["FROM_NODE"] = "from node";
  return AnimPropertyValueNodeMode2;
})(AnimPropertyValueNodeMode || {});
const PROPERTY_VALUE_MODES = [
  "custom" /* CUSTOM */,
  "from scene graph" /* FROM_SCENE_GRAPH */,
  "from node" /* FROM_NODE */
];
const PROPERTY_VALUE_MODE_CUSTOM = PROPERTY_VALUE_MODES.indexOf("custom" /* CUSTOM */);
const PROPERTY_VALUE_MODE_FROM_SCENE_GRAPH = PROPERTY_VALUE_MODES.indexOf("from scene graph" /* FROM_SCENE_GRAPH */);
const PROPERTY_VALUE_MODE_FROM_NODE = PROPERTY_VALUE_MODES.indexOf("from node" /* FROM_NODE */);
class PropertyValueAnimParamsConfig extends _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_0__/* .NodeParamsConfig */ .yI {
  constructor() {
    super(...arguments);
    /** @param mode */
    this.mode = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_0__/* .ParamConfig.INTEGER */ .XC.INTEGER(PROPERTY_VALUE_MODE_CUSTOM, {
      menu: {
        entries: PROPERTY_VALUE_MODES.map((name, value) => {
          return { name, value };
        })
      }
    });
    /** @param if set to a Polygonjs node, this is the node path */
    this.nodePath = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_0__/* .ParamConfig.NODE_PATH */ .XC.NODE_PATH("", {
      visibleIf: { mode: PROPERTY_VALUE_MODE_FROM_NODE }
    });
    /** @param if set to a THREE object, this is a mask to find the objects */
    this.objectMask = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_0__/* .ParamConfig.STRING */ .XC.STRING("*geo1", {
      visibleIf: { mode: PROPERTY_VALUE_MODE_FROM_SCENE_GRAPH }
    });
    /** @param print the object matching the objectMask, to help debugging */
    this.printResolve = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_0__/* .ParamConfig.BUTTON */ .XC.BUTTON(null, {
      visibleIf: { mode: PROPERTY_VALUE_MODE_FROM_SCENE_GRAPH },
      callback: (node) => {
        PropertyValueAnimNode.PARAM_CALLBACK_printResolve(node);
      }
    });
    this.overridePropertyName = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_0__/* .ParamConfig.BOOLEAN */ .XC.BOOLEAN(0, {
      visibleIf: [{ mode: PROPERTY_VALUE_MODE_FROM_SCENE_GRAPH }, { mode: PROPERTY_VALUE_MODE_FROM_NODE }]
    });
    this.propertyName = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_0__/* .ParamConfig.STRING */ .XC.STRING("", {
      visibleIf: [
        { overridePropertyName: true, mode: PROPERTY_VALUE_MODE_FROM_SCENE_GRAPH },
        { overridePropertyName: true, mode: PROPERTY_VALUE_MODE_FROM_NODE }
      ]
    });
    /** @param size of the parameter to animate */
    this.size = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_0__/* .ParamConfig.INTEGER */ .XC.INTEGER(3, {
      range: [1, 4],
      rangeLocked: [true, true],
      visibleIf: { mode: PROPERTY_VALUE_MODE_CUSTOM },
      separatorAfter: true
    });
    /** @param value for a float */
    this.value1 = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_0__/* .ParamConfig.FLOAT */ .XC.FLOAT(0, {
      visibleIf: { mode: PROPERTY_VALUE_MODE_CUSTOM, size: 1 }
    });
    /** @param value for a vector2 */
    this.value2 = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_0__/* .ParamConfig.VECTOR2 */ .XC.VECTOR2([0, 0], {
      visibleIf: { mode: PROPERTY_VALUE_MODE_CUSTOM, size: 2 }
    });
    /** @param value for a vector3 */
    this.value3 = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_0__/* .ParamConfig.VECTOR3 */ .XC.VECTOR3([0, 0, 0], {
      visibleIf: { mode: PROPERTY_VALUE_MODE_CUSTOM, size: 3, asColor: false }
    });
    /** @param value for a vector3 as color */
    this.color = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_0__/* .ParamConfig.COLOR */ .XC.COLOR([0, 0, 0], {
      visibleIf: { mode: PROPERTY_VALUE_MODE_CUSTOM, size: 3, asColor: true }
    });
    /** @param value for a vector4 */
    this.value4 = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_0__/* .ParamConfig.VECTOR4 */ .XC.VECTOR4([0, 0, 0, 0], {
      visibleIf: { mode: PROPERTY_VALUE_MODE_CUSTOM, size: 4 }
    });
    /** @param when using vector3, use toggle on it should be a color */
    this.asColor = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_0__/* .ParamConfig.BOOLEAN */ .XC.BOOLEAN(0, {
      visibleIf: { mode: PROPERTY_VALUE_MODE_CUSTOM, size: 3 }
    });
  }
}
const ParamsConfig = new PropertyValueAnimParamsConfig();
class PropertyValueAnimNode extends _Base__WEBPACK_IMPORTED_MODULE_1__/* .TypedAnimNode */ .D {
  constructor() {
    super(...arguments);
    this.paramsConfig = ParamsConfig;
  }
  static type() {
    return "propertyValue";
  }
  initializeNode() {
    this.io.inputs.setCount(0, 1);
  }
  cook(inputContents) {
    return __async(this, null, function* () {
      const timelineBuilder = inputContents[0] || new _core_animation_TimelineBuilder__WEBPACK_IMPORTED_MODULE_2__/* .TimelineBuilder */ .S();
      yield this._prepareTimelineBuilder(timelineBuilder);
      this.setTimelineBuilder(timelineBuilder);
    });
  }
  setMode(targetType) {
    this.p.mode.set(PROPERTY_VALUE_MODES.indexOf(targetType));
  }
  _prepareTimelineBuilder(timelineBuilder) {
    return __async(this, null, function* () {
      const mode = PROPERTY_VALUE_MODES[this.pv.mode];
      switch (mode) {
        case "custom" /* CUSTOM */: {
          return this._prepareTimebuilderCustom(timelineBuilder);
        }
        case "from scene graph" /* FROM_SCENE_GRAPH */: {
          return this._prepareTimebuilderFromSceneGraph(timelineBuilder);
        }
        case "from node" /* FROM_NODE */: {
          return yield this._prepareTimebuilderFromNode(timelineBuilder);
        }
      }
      _poly_Assert__WEBPACK_IMPORTED_MODULE_3__/* .TypeAssert.unreachable */ .f.unreachable(mode);
    });
  }
  _prepareTimebuilderCustom(timelineBuilder) {
    const size = this.pv.size;
    switch (size) {
      case 1: {
        return timelineBuilder.setPropertyValue(this.pv.value1);
      }
      case 2: {
        return timelineBuilder.setPropertyValue(this.pv.value2);
      }
      case 3: {
        if ((0,_core_BooleanValue__WEBPACK_IMPORTED_MODULE_4__/* .isBooleanTrue */ .bI)(this.pv.asColor)) {
          return timelineBuilder.setPropertyValue(this.pv.color);
        } else {
          return timelineBuilder.setPropertyValue(this.pv.value3);
        }
      }
      case 4: {
        return timelineBuilder.setPropertyValue(this.pv.value4);
      }
    }
  }
  _prepareTimebuilderFromSceneGraph(timelineBuilder) {
    const propertyName = (0,_core_BooleanValue__WEBPACK_IMPORTED_MODULE_4__/* .isBooleanTrue */ .bI)(this.pv.overridePropertyName) ? this.pv.propertyName : timelineBuilder.propertyName();
    if (!propertyName) {
      return;
    }
    const foundObject = this._foundObjectFromSceneGraph();
    if (foundObject) {
      const value = foundObject[propertyName];
      if (value) {
        if (_core_BooleanValue__WEBPACK_IMPORTED_MODULE_4__/* .CoreType.isNumber */ .MR.isNumber(value) || _core_BooleanValue__WEBPACK_IMPORTED_MODULE_4__/* .CoreType.isVector */ .MR.isVector(value) || value instanceof three__WEBPACK_IMPORTED_MODULE_5__.Quaternion) {
          timelineBuilder.setPropertyValue(value);
        }
      }
    }
  }
  _prepareTimebuilderFromNode(timelineBuilder) {
    return __async(this, null, function* () {
      const propertyName = (0,_core_BooleanValue__WEBPACK_IMPORTED_MODULE_4__/* .isBooleanTrue */ .bI)(this.pv.overridePropertyName) ? this.pv.propertyName : timelineBuilder.propertyName();
      if (!propertyName) {
        return;
      }
      const node = this.pv.nodePath.node();
      if (!node) {
        return;
      }
      const param = node.params.get(propertyName);
      if (!param) {
        return;
      }
      if (param.isDirty()) {
        yield param.compute();
      }
      const value = param.value;
      if (value) {
        if (_core_BooleanValue__WEBPACK_IMPORTED_MODULE_4__/* .CoreType.isNumber */ .MR.isNumber(value) || _core_BooleanValue__WEBPACK_IMPORTED_MODULE_4__/* .CoreType.isVector */ .MR.isVector(value)) {
          timelineBuilder.setPropertyValue(value);
        }
      }
    });
  }
  static PARAM_CALLBACK_printResolve(node) {
    node.printResolve();
  }
  _foundObjectFromSceneGraph() {
    return this.scene().findObjectByMask(this.pv.objectMask);
  }
  printResolve() {
    const foundObject = this._foundObjectFromSceneGraph();
    console.log(foundObject);
  }
}


/***/ }),

/***/ 34231:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Z": function() { return /* binding */ RepeatAnimNode; }
/* harmony export */ });
/* harmony import */ var _Base__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(44276);
/* harmony import */ var _core_animation_TimelineBuilder__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(82756);
/* harmony import */ var _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(96949);
/* harmony import */ var _core_BooleanValue__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(19037);





class RepeatAnimParamsConfig extends _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_0__/* .NodeParamsConfig */ .yI {
  constructor() {
    super(...arguments);
    /** @param sets if it should repeat indefinitely */
    this.unlimited = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_0__/* .ParamConfig.BOOLEAN */ .XC.BOOLEAN(0);
    /** @param number of times the animation should repeat */
    this.count = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_0__/* .ParamConfig.INTEGER */ .XC.INTEGER(1, {
      range: [0, 10],
      visibleIf: { unlimited: 0 }
    });
    /** @param delay */
    this.delay = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_0__/* .ParamConfig.FLOAT */ .XC.FLOAT(0);
    /** @param sets if the animation should go back and forth at each repeat */
    this.yoyo = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_0__/* .ParamConfig.BOOLEAN */ .XC.BOOLEAN(0);
  }
}
const ParamsConfig = new RepeatAnimParamsConfig();
class RepeatAnimNode extends _Base__WEBPACK_IMPORTED_MODULE_1__/* .TypedAnimNode */ .D {
  constructor() {
    super(...arguments);
    this.paramsConfig = ParamsConfig;
  }
  static type() {
    return "repeat";
  }
  initializeNode() {
    this.io.inputs.setCount(0, 1);
  }
  _repeat_params() {
    return {
      count: (0,_core_BooleanValue__WEBPACK_IMPORTED_MODULE_2__/* .isBooleanTrue */ .bI)(this.pv.unlimited) ? -1 : this.pv.count,
      delay: this.pv.delay,
      yoyo: (0,_core_BooleanValue__WEBPACK_IMPORTED_MODULE_2__/* .isBooleanTrue */ .bI)(this.pv.yoyo)
    };
  }
  cook(input_contents) {
    const timeline_builder = input_contents[0] || new _core_animation_TimelineBuilder__WEBPACK_IMPORTED_MODULE_3__/* .TimelineBuilder */ .S();
    timeline_builder.setRepeatParams(this._repeat_params());
    this.setTimelineBuilder(timeline_builder);
  }
}


/***/ }),

/***/ 31309:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {


// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  "aO": function() { return /* binding */ ANIM_TARGET_TYPES; },
  "vg": function() { return /* binding */ AnimTargetNodeTargetType; },
  "vP": function() { return /* binding */ TargetAnimNode; }
});

// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/nodes/anim/_Base.ts
var _Base = __webpack_require__(44276);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/core/animation/TimelineBuilder.ts + 15 modules
var TimelineBuilder = __webpack_require__(82756);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/nodes/utils/params/ParamsConfig.ts
var ParamsConfig = __webpack_require__(96949);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/poly/Assert.ts
var Assert = __webpack_require__(68239);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/core/animation/PropertyTarget.ts
var PropertyTarget = __webpack_require__(42450);
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/core/animation/UpdateCallback.ts

class AnimationUpdateCallback {
  constructor() {
    this._update_matrix = false;
  }
  clone() {
    const new_update_callback = new AnimationUpdateCallback();
    new_update_callback.setUpdateMatrix(this._update_matrix);
    return new_update_callback;
  }
  setUpdateMatrix(update_matrix) {
    this._update_matrix = update_matrix;
  }
  updateMatrix() {
    return this._update_matrix;
  }
}

// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/core/Type.ts
var Type = __webpack_require__(19037);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/poly/registers/nodes/types/Anim.ts
var Anim = __webpack_require__(28567);
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/anim/Target.ts



var AnimTargetNodeTargetType = /* @__PURE__ */ ((AnimTargetNodeTargetType2) => {
  AnimTargetNodeTargetType2["SCENE_GRAPH"] = "scene graph";
  AnimTargetNodeTargetType2["NODE"] = "node";
  return AnimTargetNodeTargetType2;
})(AnimTargetNodeTargetType || {});
const ANIM_TARGET_TYPES = [
  "scene graph" /* SCENE_GRAPH */,
  "node" /* NODE */
];
const TARGET_TYPE_SCENE_GRAPH = ANIM_TARGET_TYPES.indexOf("scene graph" /* SCENE_GRAPH */);
const TARGET_TYPE_NODE = ANIM_TARGET_TYPES.indexOf("node" /* NODE */);






class TargetAnimParamsConfig extends ParamsConfig/* NodeParamsConfig */.yI {
  constructor() {
    super(...arguments);
    /** @param sets if the target is a Polygonjs node, or a THREE object */
    this.type = ParamsConfig/* ParamConfig.INTEGER */.XC.INTEGER(TARGET_TYPE_SCENE_GRAPH, {
      menu: {
        entries: ANIM_TARGET_TYPES.map((name, value) => {
          return { name, value };
        })
      }
    });
    /** @param if set to a Polygonjs node, this is the node path */
    this.nodePath = ParamsConfig/* ParamConfig.NODE_PATH */.XC.NODE_PATH("", {
      visibleIf: { type: TARGET_TYPE_NODE }
    });
    /** @param if set to a THREE object, this is a mask to find the objects */
    this.objectMask = ParamsConfig/* ParamConfig.STRING */.XC.STRING("/geo*", {
      visibleIf: { type: TARGET_TYPE_SCENE_GRAPH },
      objectMask: true
    });
    /** @param sets if the matrix should be updated as the animation progresses */
    this.updateMatrix = ParamsConfig/* ParamConfig.BOOLEAN */.XC.BOOLEAN(1, {
      visibleIf: { type: TARGET_TYPE_SCENE_GRAPH }
    });
    /** @param prints which objects are targeted by this node, for debugging */
    this.printResolve = ParamsConfig/* ParamConfig.BUTTON */.XC.BUTTON(null, {
      callback: (node, param) => {
        TargetAnimNode.PARAM_CALLBACK_print_resolve(node);
      }
    });
  }
}
const Target_ParamsConfig = new TargetAnimParamsConfig();
class TargetAnimNode extends _Base/* TypedAnimNode */.D {
  constructor() {
    super(...arguments);
    this.paramsConfig = Target_ParamsConfig;
  }
  static type() {
    return Anim/* AnimType.TARGET */.R.TARGET;
  }
  initializeNode() {
    this.io.inputs.setCount(0, 1);
  }
  cook(inputCoreContents) {
    const timelineBuilder = inputCoreContents[0] || new TimelineBuilder/* TimelineBuilder */.S();
    const target = this._create_target(timelineBuilder);
    timelineBuilder.setTarget(target);
    this._set_update_callback(timelineBuilder);
    this.setTimelineBuilder(timelineBuilder);
  }
  setTargetType(targetType) {
    this.p.type.set(ANIM_TARGET_TYPES.indexOf(targetType));
  }
  _create_target(timelineBuilder) {
    const type = ANIM_TARGET_TYPES[this.pv.type];
    switch (type) {
      case "node" /* NODE */: {
        return new PropertyTarget/* AnimPropertyTarget */.F(this.scene(), {
          node: {
            path: this.pv.nodePath.path(),
            relativeTo: this
          }
        });
      }
      case "scene graph" /* SCENE_GRAPH */: {
        return new PropertyTarget/* AnimPropertyTarget */.F(this.scene(), { object: { mask: this.pv.objectMask } });
      }
    }
    Assert/* TypeAssert.unreachable */.f.unreachable(type);
  }
  _set_update_callback(timelineBuilder) {
    const type = ANIM_TARGET_TYPES[this.pv.type];
    let update_callback = timelineBuilder.updateCallback();
    switch (type) {
      case "node" /* NODE */: {
        return;
      }
      case "scene graph" /* SCENE_GRAPH */: {
        if ((0,Type/* isBooleanTrue */.bI)(this.pv.updateMatrix)) {
          update_callback = update_callback || new AnimationUpdateCallback();
          update_callback.setUpdateMatrix(this.pv.updateMatrix);
          timelineBuilder.setUpdateCallback(update_callback);
        }
        return;
      }
    }
    Assert/* TypeAssert.unreachable */.f.unreachable(type);
  }
  static PARAM_CALLBACK_print_resolve(node) {
    node.print_resolve();
  }
  print_resolve() {
    const type = ANIM_TARGET_TYPES[this.pv.type];
    const timeline_builder = new TimelineBuilder/* TimelineBuilder */.S();
    const target = this._create_target(timeline_builder);
    switch (type) {
      case "node" /* NODE */: {
        return console.log(target.node());
      }
      case "scene graph" /* SCENE_GRAPH */: {
        return console.log(target.objects());
      }
    }
  }
}


/***/ }),

/***/ 68378:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "M": function() { return /* binding */ BaseNetworkAnimNode; },
/* harmony export */   "q": function() { return /* binding */ ParamLessBaseNetworkAnimNode; }
/* harmony export */ });
/* harmony import */ var _poly_NodeContext__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(52070);
/* harmony import */ var _Base__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(74386);




class ParamLessNetworkAnimParamsConfig extends (/* unused pure expression or super */ null && (NodeParamsConfig)) {
}
class BaseNetworkAnimNode extends _Base__WEBPACK_IMPORTED_MODULE_0__/* .TypedNode */ .Mv {
  static context() {
    return _poly_NodeContext__WEBPACK_IMPORTED_MODULE_1__/* .NodeContext.ANIM */ .sy.ANIM;
  }
  cook() {
    this.cookController.endCook();
  }
}
class ParamLessBaseNetworkAnimNode extends BaseNetworkAnimNode {
}


/***/ }),

/***/ 62125:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "F": function() { return /* binding */ VolumeAudioNode; }
/* harmony export */ });
/* harmony import */ var _Base__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(46445);
/* harmony import */ var _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(96949);
/* harmony import */ var _utils_EffectsController__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(23725);
/* harmony import */ var tone_build_esm_component_channel_Volume__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(20000);

var __defProp = Object.defineProperty;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};




const VOLUME_DEFAULTS = {
  volume: 0
};
const paramCallback = (node) => {
  VolumeAudioNode.PARAM_CALLBACK_updateEffect(node);
};
class VolumeAudioParamsConfig extends _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .NodeParamsConfig */ .yI {
  constructor() {
    super(...arguments);
    /** @param volume */
    this.volume = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .ParamConfig.FLOAT */ .XC.FLOAT(VOLUME_DEFAULTS.volume, __spreadValues({
      range: [-20, 20],
      rangeLocked: [false, false]
    }, (0,_utils_EffectsController__WEBPACK_IMPORTED_MODULE_2__/* .effectParamsOptions */ .K)(paramCallback)));
  }
}
const ParamsConfig = new VolumeAudioParamsConfig();
class VolumeAudioNode extends _Base__WEBPACK_IMPORTED_MODULE_3__/* .TypedAudioNode */ .K {
  constructor() {
    super(...arguments);
    this.paramsConfig = ParamsConfig;
  }
  static type() {
    return "volume";
  }
  initializeNode() {
    this.io.inputs.setCount(1);
  }
  cook(inputContents) {
    const audioBuilder = inputContents[0];
    const effect = this._effect();
    const inputNode = audioBuilder.audioNode();
    if (inputNode) {
      inputNode.connect(effect);
    }
    audioBuilder.setAudioNode(effect);
    this.setAudioBuilder(audioBuilder);
  }
  _effect() {
    return this.__effect__ = this.__effect__ || this._createEffect();
  }
  _createEffect() {
    return new tone_build_esm_component_channel_Volume__WEBPACK_IMPORTED_MODULE_0__/* .Volume */ .f({
      volume: this.pv.volume
    });
  }
  static PARAM_CALLBACK_updateEffect(node) {
    node._updateEffect();
  }
  _updateEffect() {
    const effect = this._effect();
    effect.volume.linearRampToValueAtTime(this.pv.volume, "+1");
  }
}


/***/ }),

/***/ 23725:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "K": function() { return /* binding */ effectParamsOptions; }
/* harmony export */ });

function effectParamsOptions(callback) {
  return {
    cook: false,
    callback
  };
}


/***/ }),

/***/ 29011:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "G": function() { return /* binding */ BuilderCopNode; }
/* harmony export */ });
/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(21410);
/* harmony import */ var _Base__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(65276);
/* harmony import */ var _gl_code_globals_Geometry__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(21806);
/* harmony import */ var _gl_code_utils_NodeFinder__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(69904);
/* harmony import */ var _poly_NodeContext__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(52070);
/* harmony import */ var _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(96949);
/* harmony import */ var _utils_DataTextureController__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(50050);
/* harmony import */ var _utils_RendererController__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(77643);
/* harmony import */ var _poly_registers_assemblers_BaseRegister__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(33899);
/* harmony import */ var _Poly__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(99934);
/* harmony import */ var _gl_code_assemblers_textures_TexturePersistedConfig__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(21899);
/* harmony import */ var _core_UserAgent__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(66689);
/* harmony import */ var _poly_registers_nodes_types_Cop__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(12764);
/* harmony import */ var _utils_TextureParamsController__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(20400);
/* harmony import */ var _core_Type__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(19037);
/* harmony import */ var _gl_code_templates_textures_Default_frag_glsl__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(54816);
/* harmony import */ var _gl_code_templates_textures_Default_vert_glsl__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(24744);
/* harmony import */ var _utils_BuilderUtils__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(43306);

var __async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};


















const RESOLUTION_DEFAULT = [256, 256];
function BuilderCopParamConfig(Base) {
  return class Mixin extends Base {
    constructor() {
      super(...arguments);
      /** @param texture resolution */
      this.resolution = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_0__/* .ParamConfig.VECTOR2 */ .XC.VECTOR2(RESOLUTION_DEFAULT);
      /** @param use the main camera renderer. This can save memory, but can also lead to colors being affected by the renderer's output color space */
      this.useCameraRenderer = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_0__/* .ParamConfig.BOOLEAN */ .XC.BOOLEAN(1, {
        callback: (node) => {
          BuilderCopNode.PARAM_CALLBACK_render(node);
        }
      });
      /** @param use a data texture instead of a render target, which can be useful when using that texture as and envMap */
      this.useDataTexture = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_0__/* .ParamConfig.BOOLEAN */ .XC.BOOLEAN(0);
      /** @param force Render */
      this.render = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_0__/* .ParamConfig.BUTTON */ .XC.BUTTON(null, {
        callback: (node) => {
          BuilderCopNode.PARAM_CALLBACK_render(node);
        }
      });
    }
  };
}
class BuilderCopParamsConfig extends (0,_utils_TextureParamsController__WEBPACK_IMPORTED_MODULE_1__/* .TextureParamConfig */ .h)(BuilderCopParamConfig(_utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_0__/* .NodeParamsConfig */ .yI)) {
}
const ParamsConfig = new BuilderCopParamsConfig();
class BuilderCopNode extends _Base__WEBPACK_IMPORTED_MODULE_2__/* .TypedCopNode */ .z {
  constructor() {
    super(...arguments);
    this.paramsConfig = ParamsConfig;
    this.persisted_config = new _gl_code_assemblers_textures_TexturePersistedConfig__WEBPACK_IMPORTED_MODULE_3__/* .TexturePersistedConfig */ .n(this);
    this._assemblerController = this._createAssemblerController();
    this._textureMesh = new three__WEBPACK_IMPORTED_MODULE_4__.Mesh(new three__WEBPACK_IMPORTED_MODULE_4__.PlaneGeometry(2, 2));
    this.textureMaterial = new three__WEBPACK_IMPORTED_MODULE_4__.ShaderMaterial({
      uniforms: {},
      vertexShader: _gl_code_templates_textures_Default_vert_glsl__WEBPACK_IMPORTED_MODULE_5__/* ["default"] */ .Z,
      fragmentShader: _gl_code_templates_textures_Default_frag_glsl__WEBPACK_IMPORTED_MODULE_6__/* ["default"] */ .Z
    });
    this._textureScene = new three__WEBPACK_IMPORTED_MODULE_4__.Scene();
    this._textureCamera = new three__WEBPACK_IMPORTED_MODULE_4__.OrthographicCamera();
    this.textureParamsController = new _utils_TextureParamsController__WEBPACK_IMPORTED_MODULE_1__/* .TextureParamsController */ .V(this);
    this._childrenControllerContext = _poly_NodeContext__WEBPACK_IMPORTED_MODULE_7__/* .NodeContext.GL */ .sy.GL;
    this._cook_main_without_inputs_when_dirty_bound = this._cook_main_without_inputs_when_dirty.bind(this);
    //
    //
    // RENDER + RENDER TARGET
    //
    //
    this.boundRenderOnTarget = this.renderOnTargetWithoutUpdatingTextureFromParams.bind(this);
    this._prevTarget = null;
    this._prevOutputColorSpace = three__WEBPACK_IMPORTED_MODULE_4__.NoColorSpace;
    this._prevToneMapping = three__WEBPACK_IMPORTED_MODULE_4__.NoToneMapping;
  }
  static type() {
    return _poly_registers_nodes_types_Cop__WEBPACK_IMPORTED_MODULE_8__/* .CopType.BUILDER */ .y.BUILDER;
  }
  usedAssembler() {
    return _poly_registers_assemblers_BaseRegister__WEBPACK_IMPORTED_MODULE_9__/* .AssemblerName.GL_TEXTURE */ .Q.GL_TEXTURE;
  }
  _createAssemblerController() {
    const assemblerController = _Poly__WEBPACK_IMPORTED_MODULE_10__/* .Poly.assemblersRegister.assembler */ .L.assemblersRegister.assembler(this, this.usedAssembler());
    if (assemblerController) {
      const globalsHandler = new _gl_code_globals_Geometry__WEBPACK_IMPORTED_MODULE_11__/* .GlobalsGeometryHandler */ .f();
      assemblerController.setAssemblerGlobalsHandler(globalsHandler);
      return assemblerController;
    }
  }
  assemblerController() {
    return this._assemblerController;
  }
  initializeNode() {
    this._textureMesh.material = this.textureMaterial;
    this._textureMesh.scale.multiplyScalar(0.25);
    this._textureScene.add(this._textureMesh);
    this._textureCamera.position.z = 1;
    this.addPostDirtyHook("_cook_main_without_inputs_when_dirty", () => {
      setTimeout(this._cook_main_without_inputs_when_dirty_bound, 0);
    });
  }
  createNode(node_class, options) {
    return super.createNode(node_class, options);
  }
  children() {
    return super.children();
  }
  nodesByType(type) {
    return super.nodesByType(type);
  }
  childrenAllowed() {
    if (this.assemblerController()) {
      return super.childrenAllowed();
    }
    return false;
  }
  sceneReadonly() {
    return this.assemblerController() == null;
  }
  _cook_main_without_inputs_when_dirty() {
    return __async(this, null, function* () {
      yield this.cookController.cookMainWithoutInputs();
    });
  }
  // private _reset_if_resolution_changed(trigger?: CoreGraphNode) {
  // 	if (trigger && trigger.graphNodeId() == this.p.resolution.graphNodeId()) {
  // 		this._reset();
  // 	}
  // }
  cook() {
    return __async(this, null, function* () {
      this.compileIfRequired();
      yield this._renderOnTarget(true);
    });
  }
  shaders_by_name() {
    return {
      fragment: this._fragmentShader
    };
  }
  compileIfRequired() {
    var _a;
    if ((_a = this.assemblerController()) == null ? void 0 : _a.compileRequired()) {
      try {
        this.compile();
      } catch (err) {
        const message = err.message || "failed to compile";
        this.states.error.set(message);
      }
    }
  }
  compile() {
    const assemblerController = this.assemblerController();
    if (!assemblerController) {
      return;
    }
    const outputNodes = _gl_code_utils_NodeFinder__WEBPACK_IMPORTED_MODULE_12__/* .GlNodeFinder.findOutputNodes */ .W.findOutputNodes(this);
    if (outputNodes.length == 0) {
      this.states.error.set("one output node is required");
      return;
    }
    if (outputNodes.length > 1) {
      this.states.error.set("only one output node allowed");
      return;
    }
    const outputNode = outputNodes[0];
    if (outputNode) {
      const rootNodes = outputNodes;
      assemblerController.assembler.set_root_nodes(rootNodes);
      assemblerController.assembler.updateFragmentShader();
      const fragmentShader = assemblerController.assembler.fragment_shader();
      const uniforms = assemblerController.assembler.uniforms();
      if (fragmentShader && uniforms) {
        this._fragmentShader = fragmentShader;
        this._uniforms = uniforms;
      }
      (0,_utils_BuilderUtils__WEBPACK_IMPORTED_MODULE_13__/* .handleCopBuilderDependencies */ .U)({
        node: this,
        timeDependent: assemblerController.assembler.uniformsTimeDependent(),
        uniforms: void 0
      });
    }
    if (this._fragmentShader && this._uniforms) {
      this.textureMaterial.fragmentShader = this._fragmentShader;
      this.textureMaterial.uniforms = this._uniforms;
      this.textureMaterial.needsUpdate = true;
      this.textureMaterial.uniforms.resolution = {
        value: this.pv.resolution
      };
    }
    assemblerController.post_compile();
  }
  callbackName() {
    return `cop/builder_${this.graphNodeId()}`;
  }
  // private _uniformCallbackName() {
  // 	return `cop/builder_uniforms_${this.graphNodeId()}`;
  // }
  dispose() {
    var _a, _b;
    super.dispose();
    (_a = this._renderTarget) == null ? void 0 : _a.dispose();
    (_b = this._renderer) == null ? void 0 : _b.dispose();
    this.removeCallbacks();
  }
  removeCallbacks() {
    const scene = this.scene();
    scene.unRegisterOnBeforeTick(this.callbackName());
  }
  renderOnTargetWithoutUpdatingTextureFromParams() {
    return __async(this, null, function* () {
      this._renderOnTarget(false);
    });
  }
  _renderOnTarget(updateTextureFromParams) {
    return __async(this, null, function* () {
      yield this.createRenderTargetIfRequired();
      yield this._createRendererIfRequired();
      if (this.states.error.active()) {
        return;
      }
      if (!this._renderer) {
        console.warn("no renderer");
        return;
      }
      this._saveRendererState(this._renderer);
      this._prepareRenderer(this._renderer);
      this._renderer.render(this._textureScene, this._textureCamera);
      yield this._postRender(updateTextureFromParams);
      this._restoreRendererState(this._renderer);
      _Poly__WEBPACK_IMPORTED_MODULE_10__/* .Poly.onSceneUpdatedHooks.runHooks */ .L.onSceneUpdatedHooks.runHooks();
    });
  }
  _postRender(updateTextureFromParams) {
    return __async(this, null, function* () {
      var _a;
      if ((_a = this._renderTarget) == null ? void 0 : _a.texture) {
        if ((0,_core_Type__WEBPACK_IMPORTED_MODULE_14__/* .isBooleanTrue */ .bI)(this.pv.useDataTexture) && this._renderTarget && this._renderer) {
          this._dataTextureController = this._dataTextureController || new _utils_DataTextureController__WEBPACK_IMPORTED_MODULE_15__/* .DataTextureController */ .y();
          const texture = this._dataTextureController.fromRenderTarget(this._renderer, this._renderTarget);
          if (updateTextureFromParams) {
            yield this.textureParamsController.update(texture);
          }
          this.setTexture(texture);
        } else {
          const texture = this._renderTarget.texture;
          if (updateTextureFromParams) {
          }
          this.setTexture(texture);
        }
      } else {
        this.cookController.endCook();
      }
    });
  }
  _saveRendererState(renderer) {
    this._prevTarget = renderer.getRenderTarget();
    this._prevOutputColorSpace = renderer.outputColorSpace;
    this._prevToneMapping = renderer.toneMapping;
  }
  _prepareRenderer(renderer) {
    if (!this._renderTarget) {
      console.warn("no render target");
      return;
    }
    renderer.setRenderTarget(this._renderTarget);
    renderer.outputColorSpace = three__WEBPACK_IMPORTED_MODULE_4__.NoColorSpace;
    renderer.toneMapping = three__WEBPACK_IMPORTED_MODULE_4__.NoToneMapping;
    renderer.clear();
  }
  _restoreRendererState(renderer) {
    renderer.setRenderTarget(this._prevTarget);
    renderer.outputColorSpace = this._prevOutputColorSpace;
    renderer.toneMapping = this._prevToneMapping;
  }
  _createRendererIfRequired() {
    return __async(this, null, function* () {
      if (this._renderer) {
        return;
      }
      if ((0,_core_Type__WEBPACK_IMPORTED_MODULE_14__/* .isBooleanTrue */ .bI)(this.pv.useCameraRenderer)) {
        this._rendererController = this._rendererController || new _utils_RendererController__WEBPACK_IMPORTED_MODULE_16__/* .CopRendererController */ .G(this);
        const foundRenderer = yield this._rendererController.waitForRenderer();
        if (foundRenderer instanceof three__WEBPACK_IMPORTED_MODULE_4__.WebGLRenderer) {
          this._renderer = foundRenderer;
        } else {
          console.warn("found renderer is not a WebGLRenderer", foundRenderer);
        }
      } else {
        this._renderer = _Poly__WEBPACK_IMPORTED_MODULE_10__/* .Poly.renderersController.linearRenderer */ .L.renderersController.linearRenderer();
      }
    });
  }
  _resetRenderer() {
    this._renderer = void 0;
  }
  renderer() {
    return this._renderer;
  }
  /*
   *
   * RENDER TARGET
   *
   */
  renderTarget() {
    return __async(this, null, function* () {
      return this._renderTarget = this._renderTarget || (yield this._createRenderTarget(this.pv.resolution.x, this.pv.resolution.y));
    });
  }
  createRenderTargetIfRequired() {
    return __async(this, null, function* () {
      var _a;
      if (!this._renderTarget || !this._renderTargetResolutionValid()) {
        this._renderTarget = yield this._createRenderTarget(this.pv.resolution.x, this.pv.resolution.y);
        (_a = this._dataTextureController) == null ? void 0 : _a.reset();
      }
    });
  }
  _renderTargetResolutionValid() {
    if (this._renderTarget) {
      const image = this._renderTarget.texture.image;
      if (image.width != this.pv.resolution.x || image.height != this.pv.resolution.y) {
        return false;
      } else {
        return true;
      }
    } else {
      return false;
    }
  }
  _createRenderTarget(width, height) {
    return __async(this, null, function* () {
      if (this._renderTarget) {
        const image = this._renderTarget.texture.image;
        if (image.width == width && image.height == height) {
          return this._renderTarget;
        }
      }
      const wrapS = three__WEBPACK_IMPORTED_MODULE_4__.ClampToEdgeWrapping;
      const wrapT = three__WEBPACK_IMPORTED_MODULE_4__.ClampToEdgeWrapping;
      const minFilter = three__WEBPACK_IMPORTED_MODULE_4__.LinearFilter;
      const magFilter = three__WEBPACK_IMPORTED_MODULE_4__.NearestFilter;
      const renderTarget = new three__WEBPACK_IMPORTED_MODULE_4__.WebGLRenderTarget(width, height, {
        wrapS,
        wrapT,
        minFilter,
        magFilter,
        format: three__WEBPACK_IMPORTED_MODULE_4__.RGBAFormat,
        type: _core_UserAgent__WEBPACK_IMPORTED_MODULE_17__/* .CoreUserAgent.isiOS */ .Cj.isiOS() ? three__WEBPACK_IMPORTED_MODULE_4__.HalfFloatType : three__WEBPACK_IMPORTED_MODULE_4__.FloatType,
        stencilBuffer: false,
        depthBuffer: false
        // encoding: LinearEncoding,
      });
      _Poly__WEBPACK_IMPORTED_MODULE_10__/* .Poly.warn */ .L.warn(`${this.path()}: created WebGLRenderTarget`, this.path(), width, height);
      return renderTarget;
    });
  }
  /*
   *
   * CALLBACK
   *
   */
  static PARAM_CALLBACK_render(node) {
    node._renderOnTarget(true);
  }
  static PARAM_CALLBACK_resetRenderer(node) {
    node._resetRenderer();
  }
}


/***/ }),

/***/ 47642:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "k": function() { return /* binding */ Builder2DArrayCopNode; }
/* harmony export */ });
/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(21410);
/* harmony import */ var _Base__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(65276);
/* harmony import */ var _gl_code_globals_Geometry__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(21806);
/* harmony import */ var _gl_code_utils_NodeFinder__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(69904);
/* harmony import */ var _poly_NodeContext__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(52070);
/* harmony import */ var _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(96949);
/* harmony import */ var _utils_RendererController__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(77643);
/* harmony import */ var _poly_registers_assemblers_BaseRegister__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(33899);
/* harmony import */ var _Poly__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(99934);
/* harmony import */ var _gl_code_assemblers_textures_TexturePersistedConfig__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(21899);
/* harmony import */ var _poly_registers_nodes_types_Cop__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(12764);
/* harmony import */ var _utils_TextureParamsController__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(20400);
/* harmony import */ var _core_Type__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(19037);
/* harmony import */ var _gl_code_templates_textures_Default_frag_glsl__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(54816);
/* harmony import */ var _gl_code_templates_textures_Default_vert_glsl__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(24744);
/* harmony import */ var _utils_BuilderUtils__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(43306);

var __async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};
















const RESOLUTION_DEFAULT = [128, 128];
function Builder2DArrayCopParamConfig(Base) {
  return class Mixin extends Base {
    constructor() {
      super(...arguments);
      /** @param textures resolution */
      this.resolution = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_0__/* .ParamConfig.VECTOR2 */ .XC.VECTOR2(RESOLUTION_DEFAULT);
      /** @param layers */
      this.layers = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_0__/* .ParamConfig.INTEGER */ .XC.INTEGER(4, {
        range: [2, 32],
        rangeLocked: [true, false]
      });
      /** @param use the main camera renderer. This can save memory, but can also lead to colors being affected by the renderer's output color space */
      this.useCameraRenderer = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_0__/* .ParamConfig.BOOLEAN */ .XC.BOOLEAN(1, {
        callback: (node) => {
          Builder2DArrayCopNode.PARAM_CALLBACK_render(node);
        }
      });
      /** @param use a data texture instead of a render target, which can be useful when using that texture as and envMap */
      // useDataTexture = ParamConfig.BOOLEAN(0);
      /** @param force Render */
      this.render = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_0__/* .ParamConfig.BUTTON */ .XC.BUTTON(null, {
        callback: (node) => {
          Builder2DArrayCopNode.PARAM_CALLBACK_render(node);
        }
      });
    }
  };
}
class Builder2DArrayCopParamsConfig extends (0,_utils_TextureParamsController__WEBPACK_IMPORTED_MODULE_1__/* .TextureParamConfig */ .h)(Builder2DArrayCopParamConfig(_utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_0__/* .NodeParamsConfig */ .yI)) {
}
const ParamsConfig = new Builder2DArrayCopParamsConfig();
class Builder2DArrayCopNode extends _Base__WEBPACK_IMPORTED_MODULE_2__/* .TypedCopNode */ .z {
  constructor() {
    super(...arguments);
    this.paramsConfig = ParamsConfig;
    this.persisted_config = new _gl_code_assemblers_textures_TexturePersistedConfig__WEBPACK_IMPORTED_MODULE_3__/* .TexturePersistedConfig */ .n(this);
    this._assemblerController = this._createAssemblerController();
    this._textureMesh = new three__WEBPACK_IMPORTED_MODULE_4__.Mesh(new three__WEBPACK_IMPORTED_MODULE_4__.PlaneGeometry(2, 2));
    this.textureMaterial = new three__WEBPACK_IMPORTED_MODULE_4__.ShaderMaterial({
      uniforms: {},
      vertexShader: _gl_code_templates_textures_Default_vert_glsl__WEBPACK_IMPORTED_MODULE_5__/* ["default"] */ .Z,
      fragmentShader: _gl_code_templates_textures_Default_frag_glsl__WEBPACK_IMPORTED_MODULE_6__/* ["default"] */ .Z
    });
    this._textureScene = new three__WEBPACK_IMPORTED_MODULE_4__.Scene();
    this._textureCamera = new three__WEBPACK_IMPORTED_MODULE_4__.OrthographicCamera();
    this.textureParamsController = new _utils_TextureParamsController__WEBPACK_IMPORTED_MODULE_1__/* .TextureParamsController */ .V(this);
    this._childrenControllerContext = _poly_NodeContext__WEBPACK_IMPORTED_MODULE_7__/* .NodeContext.GL */ .sy.GL;
    this._cook_main_without_inputs_when_dirty_bound = this._cook_main_without_inputs_when_dirty.bind(this);
    //
    //
    // RENDER + RENDER TARGET
    //
    //
    this.boundRenderOnTarget = this.renderOnTargetWithoutUpdatingTextureFromParams.bind(this);
    this._prevTarget = null;
    this._prevOutputColorSpace = three__WEBPACK_IMPORTED_MODULE_4__.NoColorSpace;
    this._prevToneMapping = three__WEBPACK_IMPORTED_MODULE_4__.NoToneMapping;
  }
  static type() {
    return _poly_registers_nodes_types_Cop__WEBPACK_IMPORTED_MODULE_8__/* .CopType.BUILDER_2D_ARRAY */ .y.BUILDER_2D_ARRAY;
  }
  usedAssembler() {
    return _poly_registers_assemblers_BaseRegister__WEBPACK_IMPORTED_MODULE_9__/* .AssemblerName.GL_TEXTURE_2D_ARRAY */ .Q.GL_TEXTURE_2D_ARRAY;
  }
  _createAssemblerController() {
    const assemblerController = _Poly__WEBPACK_IMPORTED_MODULE_10__/* .Poly.assemblersRegister.assembler */ .L.assemblersRegister.assembler(this, this.usedAssembler());
    if (assemblerController) {
      const globalsHandler = new _gl_code_globals_Geometry__WEBPACK_IMPORTED_MODULE_11__/* .GlobalsGeometryHandler */ .f();
      assemblerController.setAssemblerGlobalsHandler(globalsHandler);
      return assemblerController;
    }
  }
  assemblerController() {
    return this._assemblerController;
  }
  initializeNode() {
    this._textureMesh.material = this.textureMaterial;
    this._textureMesh.scale.multiplyScalar(0.25);
    this._textureScene.add(this._textureMesh);
    this._textureCamera.position.z = 1;
    this.addPostDirtyHook("_cook_main_without_inputs_when_dirty", () => {
      setTimeout(this._cook_main_without_inputs_when_dirty_bound, 0);
    });
  }
  createNode(node_class, options) {
    return super.createNode(node_class, options);
  }
  children() {
    return super.children();
  }
  nodesByType(type) {
    return super.nodesByType(type);
  }
  childrenAllowed() {
    if (this.assemblerController()) {
      return super.childrenAllowed();
    }
    return false;
  }
  sceneReadonly() {
    return this.assemblerController() == null;
  }
  _cook_main_without_inputs_when_dirty() {
    return __async(this, null, function* () {
      yield this.cookController.cookMainWithoutInputs();
    });
  }
  // private _reset_if_resolution_changed(trigger?: CoreGraphNode) {
  // 	if (trigger && trigger.graphNodeId() == this.p.resolution.graphNodeId()) {
  // 		this._reset();
  // 	}
  // }
  cook() {
    return __async(this, null, function* () {
      this.compileIfRequired();
      yield this._renderOnTarget(true);
    });
  }
  shaders_by_name() {
    return {
      fragment: this._fragmentShader
    };
  }
  compileIfRequired() {
    var _a;
    if ((_a = this.assemblerController()) == null ? void 0 : _a.compileRequired()) {
      try {
        this.compile();
      } catch (err) {
        const message = err.message || "failed to compile";
        this.states.error.set(message);
      }
    }
  }
  compile() {
    const assemblerController = this.assemblerController();
    if (!assemblerController) {
      return;
    }
    const outputNodes = _gl_code_utils_NodeFinder__WEBPACK_IMPORTED_MODULE_12__/* .GlNodeFinder.findOutputNodes */ .W.findOutputNodes(this);
    if (outputNodes.length == 0) {
      this.states.error.set("one output node is required");
      return;
    }
    if (outputNodes.length > 1) {
      this.states.error.set("only one output node allowed");
      return;
    }
    const outputNode = outputNodes[0];
    if (outputNode) {
      const rootNodes = outputNodes;
      assemblerController.assembler.set_root_nodes(rootNodes);
      assemblerController.assembler.updateFragmentShader();
      const fragmentShader = assemblerController.assembler.fragment_shader();
      const uniforms = assemblerController.assembler.uniforms();
      if (fragmentShader && uniforms) {
        this._fragmentShader = fragmentShader;
        this._uniforms = uniforms;
      }
      (0,_utils_BuilderUtils__WEBPACK_IMPORTED_MODULE_13__/* .handleCopBuilderDependencies */ .U)({
        node: this,
        timeDependent: assemblerController.assembler.uniformsTimeDependent(),
        uniforms: void 0
      });
    }
    if (this._fragmentShader && this._uniforms) {
      this.textureMaterial.fragmentShader = this._fragmentShader;
      this.textureMaterial.uniforms = this._uniforms;
      this.textureMaterial.needsUpdate = true;
      this.textureMaterial.uniforms.resolution = {
        value: this.pv.resolution
      };
    }
    assemblerController.post_compile();
  }
  callbackName() {
    return `cop/builder3D_${this.graphNodeId()}`;
  }
  // private _uniformCallbackName() {
  // 	return `cop/builder_uniforms_${this.graphNodeId()}`;
  // }
  dispose() {
    var _a, _b;
    super.dispose();
    (_a = this._renderTarget) == null ? void 0 : _a.dispose();
    (_b = this._renderer) == null ? void 0 : _b.dispose();
    this.removeCallbacks();
  }
  removeCallbacks() {
    const scene = this.scene();
    scene.unRegisterOnBeforeTick(this.callbackName());
  }
  renderOnTargetWithoutUpdatingTextureFromParams() {
    return __async(this, null, function* () {
      this._renderOnTarget(false);
    });
  }
  _renderOnTarget(updateTextureFromParams) {
    return __async(this, null, function* () {
      yield this.createRenderTargetIfRequired();
      yield this._createRendererIfRequired();
      if (this.states.error.active()) {
        return;
      }
      if (!this._renderer) {
        console.warn("no renderer");
        return;
      }
      if (!this._uniforms) {
        return;
      }
      this._saveRendererState(this._renderer);
      this._prepareRenderer(this._renderer);
      const layersCount = this.pv.layers;
      for (let i = 0; i < layersCount; i++) {
        this._uniforms.uLayer.value = i;
        this._setRenderLayer(this._renderer, i);
        this._renderer.render(this._textureScene, this._textureCamera);
      }
      yield this._postRender(updateTextureFromParams);
      this._restoreRendererState(this._renderer);
    });
  }
  _postRender(updateTextureFromParams) {
    return __async(this, null, function* () {
      var _a;
      if ((_a = this._renderTarget) == null ? void 0 : _a.texture) {
        const texture = this._renderTarget.texture;
        if (updateTextureFromParams) {
        }
        this.setTexture(texture);
      } else {
        this.cookController.endCook();
      }
    });
  }
  _saveRendererState(renderer) {
    this._prevTarget = renderer.getRenderTarget();
    this._prevOutputColorSpace = renderer.outputColorSpace;
    this._prevToneMapping = renderer.toneMapping;
  }
  _prepareRenderer(renderer) {
    if (!this._renderTarget) {
      console.warn("no render target");
      return;
    }
    renderer.outputColorSpace = three__WEBPACK_IMPORTED_MODULE_4__.NoColorSpace;
    renderer.toneMapping = three__WEBPACK_IMPORTED_MODULE_4__.NoToneMapping;
  }
  _setRenderLayer(renderer, layer) {
    if (!this._renderTarget) {
      console.warn("no render target");
      return;
    }
    renderer.setRenderTarget(this._renderTarget, layer);
    renderer.clear();
  }
  _restoreRendererState(renderer) {
    renderer.setRenderTarget(this._prevTarget);
    renderer.outputColorSpace = this._prevOutputColorSpace;
    renderer.toneMapping = this._prevToneMapping;
  }
  _createRendererIfRequired() {
    return __async(this, null, function* () {
      if (this._renderer) {
        return;
      }
      if ((0,_core_Type__WEBPACK_IMPORTED_MODULE_14__/* .isBooleanTrue */ .bI)(this.pv.useCameraRenderer)) {
        this._rendererController = this._rendererController || new _utils_RendererController__WEBPACK_IMPORTED_MODULE_15__/* .CopRendererController */ .G(this);
        const foundRenderer = yield this._rendererController.waitForRenderer();
        if (foundRenderer instanceof three__WEBPACK_IMPORTED_MODULE_4__.WebGLRenderer) {
          this._renderer = foundRenderer;
        } else {
          console.warn("found renderer is not a WebGLRenderer");
        }
      } else {
        this._renderer = _Poly__WEBPACK_IMPORTED_MODULE_10__/* .Poly.renderersController.linearRenderer */ .L.renderersController.linearRenderer();
      }
    });
  }
  _resetRenderer() {
    this._renderer = void 0;
  }
  renderer() {
    return this._renderer;
  }
  /*
   *
   * RENDER TARGET
   *
   */
  renderTarget() {
    return __async(this, null, function* () {
      return this._renderTarget = this._renderTarget || (yield this._createRenderTarget(this.pv.resolution.x, this.pv.resolution.y, this.pv.layers));
    });
  }
  createRenderTargetIfRequired() {
    return __async(this, null, function* () {
      var _a;
      if (!this._renderTarget || !this._renderTargetResolutionValid()) {
        this._renderTarget = yield this._createRenderTarget(
          this.pv.resolution.x,
          this.pv.resolution.y,
          this.pv.layers
        );
        (_a = this._dataTextureController) == null ? void 0 : _a.reset();
      }
    });
  }
  _renderTargetResolutionValid() {
    if (this._renderTarget) {
      const image = this._renderTarget.texture.image;
      if (image.width != this.pv.resolution.x || image.height != this.pv.resolution.y) {
        return false;
      } else {
        return true;
      }
    } else {
      return false;
    }
  }
  _createRenderTarget(width, height, depth) {
    return __async(this, null, function* () {
      if (this._renderTarget) {
        const image = this._renderTarget.texture.image;
        console.log(image);
        if (image.width == width && image.height == height && image.depth == depth) {
          return this._renderTarget;
        }
      }
      const wrapS = three__WEBPACK_IMPORTED_MODULE_4__.ClampToEdgeWrapping;
      const wrapT = three__WEBPACK_IMPORTED_MODULE_4__.ClampToEdgeWrapping;
      const minFilter = three__WEBPACK_IMPORTED_MODULE_4__.LinearFilter;
      const magFilter = three__WEBPACK_IMPORTED_MODULE_4__.NearestFilter;
      const renderTarget = new three__WEBPACK_IMPORTED_MODULE_4__.WebGLArrayRenderTarget(width, height, depth);
      renderTarget.texture.wrapS = wrapS;
      renderTarget.texture.wrapT = wrapT;
      renderTarget.texture.minFilter = minFilter;
      renderTarget.texture.magFilter = magFilter;
      renderTarget.texture.format = three__WEBPACK_IMPORTED_MODULE_4__.RGBAFormat;
      renderTarget.stencilBuffer = false;
      renderTarget.depthBuffer = false;
      _Poly__WEBPACK_IMPORTED_MODULE_10__/* .Poly.warn */ .L.warn(`${this.path()}: created WebGLArrayRenderTarget`, this.path(), width, height, depth);
      return renderTarget;
    });
  }
  /*
   *
   * CALLBACK
   *
   */
  static PARAM_CALLBACK_render(node) {
    node._renderOnTarget(true);
  }
  static PARAM_CALLBACK_resetRenderer(node) {
    node._resetRenderer();
  }
}


/***/ }),

/***/ 86621:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "y": function() { return /* binding */ ColorCopNode; }
/* harmony export */ });
/* harmony import */ var _Base__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(65276);
/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(21410);
/* harmony import */ var _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(96949);




class ColorCopParamsConfig extends _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_0__/* .NodeParamsConfig */ .yI {
  constructor() {
    super(...arguments);
    /** @param texture resolution */
    this.resolution = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_0__/* .ParamConfig.VECTOR2 */ .XC.VECTOR2([256, 256], {
      callback: (node) => {
        ColorCopNode.PARAM_CALLBACK_reset(node);
      }
    });
    /** @param color to generate */
    this.color = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_0__/* .ParamConfig.COLOR */ .XC.COLOR([1, 1, 1]);
    /** @param alpha */
    this.alpha = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_0__/* .ParamConfig.FLOAT */ .XC.FLOAT(1, {
      range: [0, 1]
    });
  }
}
const ParamsConfig = new ColorCopParamsConfig();
class ColorCopNode extends _Base__WEBPACK_IMPORTED_MODULE_1__/* .TypedCopNode */ .z {
  constructor() {
    super(...arguments);
    this.paramsConfig = ParamsConfig;
  }
  static type() {
    return "color";
  }
  cook() {
    const w = this.pv.resolution.x;
    const h = this.pv.resolution.y;
    this._dataTexture = this._dataTexture || this._createDataTexture(w, h);
    const bufferSize = 4 * h * w;
    const c = this.pv.color.toArray();
    const r = c[0] * 255;
    const g = c[1] * 255;
    const b = c[2] * 255;
    const data = this._dataTexture.image.data;
    for (let i = 0; i < bufferSize; i += 4) {
      data[i + 0] = r;
      data[i + 1] = g;
      data[i + 2] = b;
    }
    this._dataTexture.needsUpdate = true;
    this.setTexture(this._dataTexture);
  }
  _createDataTexture(width, height) {
    const pixel_buffer = this._createPixelBuffer(width, height);
    return new three__WEBPACK_IMPORTED_MODULE_2__.DataTexture(pixel_buffer, width, height);
  }
  _createPixelBuffer(width, height) {
    const size = width * height * 4;
    const buffer = new Uint8Array(size);
    buffer.fill(this.pv.alpha * 255);
    return buffer;
  }
  static PARAM_CALLBACK_reset(node) {
    node._reset();
  }
  _reset() {
    this._dataTexture = void 0;
  }
}


/***/ }),

/***/ 59160:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "F": function() { return /* binding */ CubeCameraCopNode; }
/* harmony export */ });
/* harmony import */ var _Base__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(65276);
/* harmony import */ var _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(96949);
/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(21410);
/* harmony import */ var _poly_registers_nodes_types_Cop__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(12764);
/* harmony import */ var _core_Type__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(19037);
/* harmony import */ var _utils_RendererController__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(77643);

var __async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};






var MapMode = /* @__PURE__ */ ((MapMode2) => {
  MapMode2["REFLECTION"] = "reflection";
  MapMode2["REFRACTION"] = "refraction";
  return MapMode2;
})(MapMode || {});
const MAP_MODES = ["reflection" /* REFLECTION */, "refraction" /* REFRACTION */];
class CubeCameraCopParamsConfig extends _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_0__/* .NodeParamsConfig */ .yI {
  constructor() {
    super(...arguments);
    /** @param cube camera OBJ node */
    this.cameraPath = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_0__/* .ParamConfig.STRING */ .XC.STRING("*cubeCamera*", {
      objectMask: true
    });
    /** @param objects to render */
    // objects = ParamConfig.STRING('/', {
    // 	objectMask: true,
    // });
    /** @param defines if the texture is used for reflection or refraction */
    this.mode = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_0__/* .ParamConfig.INTEGER */ .XC.INTEGER(0, {
      menu: {
        entries: MAP_MODES.map((name, value) => {
          return { name, value };
        })
      }
    });
    /** @param transparent background */
    this.transparentBackground = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_0__/* .ParamConfig.BOOLEAN */ .XC.BOOLEAN(1);
    /** @param bg Color */
    this.backgroundColor = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_0__/* .ParamConfig.COLOR */ .XC.COLOR([0, 0, 0], {
      visibleIf: {
        transparentBackground: 0
      }
    });
    /** @param autoRender */
    this.autoRender = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_0__/* .ParamConfig.BOOLEAN */ .XC.BOOLEAN(1);
    /** @param render button */
    this.render = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_0__/* .ParamConfig.BUTTON */ .XC.BUTTON(null, {
      callback: (node) => {
        CubeCameraCopNode.PARAM_CALLBACK_render(node);
      }
    });
  }
}
const ParamsConfig = new CubeCameraCopParamsConfig();
class CubeCameraCopNode extends _Base__WEBPACK_IMPORTED_MODULE_1__/* .TypedCopNode */ .z {
  constructor() {
    super(...arguments);
    this.paramsConfig = ParamsConfig;
    // private previousParentByObject: WeakMap<Object3D, Object3D | null> = new WeakMap();
    this._renderOnTargetBound = () => this.renderOnTarget(true);
  }
  static type() {
    return _poly_registers_nodes_types_Cop__WEBPACK_IMPORTED_MODULE_2__/* .CopType.CUBE_CAMERA */ .y.CUBE_CAMERA;
  }
  cook() {
    return __async(this, null, function* () {
      if ((0,_core_Type__WEBPACK_IMPORTED_MODULE_3__/* .isBooleanTrue */ .bI)(this.pv.autoRender)) {
        this._addOnBeforeTickCallback();
      } else {
        this._removeOnBeforeTickCallback();
      }
      const texture = yield this.renderOnTarget(false);
      if (texture) {
        const mode = MAP_MODES[this.pv.mode];
        switch (mode) {
          case "reflection" /* REFLECTION */:
            texture.mapping = three__WEBPACK_IMPORTED_MODULE_4__.CubeReflectionMapping;
            break;
          case "refraction" /* REFRACTION */:
            texture.mapping = three__WEBPACK_IMPORTED_MODULE_4__.CubeRefractionMapping;
            break;
        }
      } else {
        this.cookController.endCook();
      }
    });
  }
  //
  //
  // AUTO RENDER
  //
  //
  _addOnBeforeTickCallback() {
    const callbackName = this._onBeforeRenderCallbackName();
    if (this.scene().hasBeforeTickCallback(callbackName)) {
      return;
    }
    this.scene().registerOnBeforeTick(callbackName, this._renderOnTargetBound);
  }
  _removeOnBeforeTickCallback() {
    this.scene().unRegisterOnBeforeTick(this._onBeforeRenderCallbackName());
  }
  _onBeforeRenderCallbackName() {
    return `cop/render_onBeforeTickCallback-${this.graphNodeId()}`;
  }
  dispose() {
    super.dispose();
    this._removeOnBeforeTickCallback();
  }
  //
  //
  // RENDER + RENDER TARGET
  //
  //
  _getCameraSync() {
    return this.scene().objectsController.findObjectByMask(this.pv.cameraPath);
  }
  _getCamera() {
    return __async(this, null, function* () {
      const camera = this._getCameraSync();
      if (camera) {
        return camera;
      }
      return new Promise((resolve) => {
        this.scene().camerasController.onCameraObjectsUpdated(() => __async(this, null, function* () {
          const camera2 = this._getCameraSync();
          if (camera2) {
            resolve(camera2);
          }
        }));
      });
    });
  }
  renderOnTarget(setDirtyIfChangesDetected) {
    return __async(this, null, function* () {
      const camera = yield this._getCamera();
      if (!camera) {
        console.warn(`${this.path()}: no camera found`);
        return;
      }
      this._rendererController = this._rendererController || new _utils_RendererController__WEBPACK_IMPORTED_MODULE_5__/* .CopRendererController */ .G(this);
      const renderer = yield this._rendererController.waitForRenderer();
      if (!renderer) {
        return;
      }
      if (setDirtyIfChangesDetected == true && this._prevCamera != camera || renderer != this._prevRenderer) {
        this.setDirty();
        this._prevCamera = camera;
        this._prevRenderer = renderer;
      }
      const scene = this.scene().threejsScene();
      const prevBackground = scene.background;
      scene.background = this.pv.transparentBackground ? null : this.pv.backgroundColor;
      camera.update(renderer, scene);
      scene.background = prevBackground;
      const texture = camera.renderTarget.texture;
      this.setTexture(texture);
      return texture;
    });
  }
  // private _renderTarget: WebGLRenderTarget | undefined;
  renderTarget() {
    return __async(this, null, function* () {
      const camera = yield this._getCamera();
      return camera == null ? void 0 : camera.renderTarget.texture;
    });
  }
  //
  //
  // CALLBACK
  //
  //
  static PARAM_CALLBACK_render(node) {
    node.renderOnTarget(true);
  }
}


/***/ }),

/***/ 44955:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "r": function() { return /* binding */ GifCopNode; }
/* harmony export */ });
/* unused harmony export GifCopParamConfig */
/* harmony import */ var _poly_ParamEvent__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(98267);
/* harmony import */ var _Base__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(65276);
/* harmony import */ var _core_loader_Texture__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(44435);
/* harmony import */ var _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(96949);
/* harmony import */ var _utils_TextureParamsController__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(20400);
/* harmony import */ var _poly_InputCloneMode__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(56752);
/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(21410);
/* harmony import */ var gifuct_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(72489);
/* harmony import */ var _core_BooleanValue__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(19037);
/* harmony import */ var _core_FileTypeController__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(92971);
/* harmony import */ var _poly_registers_nodes_types_Cop__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(12764);
/* harmony import */ var _core_loader_FileExtensionRegister__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(15060);
/* harmony import */ var _poly_NodeContext__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(52070);

var __async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};













function GifCopParamConfig(Base) {
  return class Mixin extends Base {
    constructor() {
      super(...arguments);
      /** @param url to fetch the gif from */
      this.url = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .ParamConfig.STRING */ .XC.STRING("", {
        fileBrowse: { extensions: _core_loader_FileExtensionRegister__WEBPACK_IMPORTED_MODULE_2__/* .EXTENSIONS_BY_NODE_TYPE_BY_CONTEXT */ .P[_poly_NodeContext__WEBPACK_IMPORTED_MODULE_3__/* .NodeContext.COP */ .sy.COP][_poly_registers_nodes_types_Cop__WEBPACK_IMPORTED_MODULE_4__/* .CopType.GIF */ .y.GIF] }
      });
      /** @param reload the image */
      this.reload = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .ParamConfig.BUTTON */ .XC.BUTTON(null, {
        callback: (node, param) => {
          GifCopNode.PARAM_CALLBACK_reload(node);
        }
      });
      /** @param play the gif */
      this.play = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .ParamConfig.BOOLEAN */ .XC.BOOLEAN(1, {
        cook: false,
        callback: (node) => {
          GifCopNode.PARAM_CALLBACK_gifUpdatePlay(node);
        }
      });
      /** @param set the gif frame */
      this.gifFrame = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .ParamConfig.INTEGER */ .XC.INTEGER(0, {
        cook: false,
        range: [0, 100],
        rangeLocked: [true, false],
        callback: (node) => {
          GifCopNode.PARAM_CALLBACK_gifUpdateFrameIndex(node);
        }
      });
    }
  };
}
class GifCopParamsConfig extends (0,_utils_TextureParamsController__WEBPACK_IMPORTED_MODULE_5__/* .TextureParamConfig */ .h)(GifCopParamConfig(_utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .NodeParamsConfig */ .yI)) {
}
const ParamsConfig = new GifCopParamsConfig();
class GifCopNode extends _Base__WEBPACK_IMPORTED_MODULE_6__/* .TypedCopNode */ .z {
  constructor() {
    super(...arguments);
    this.paramsConfig = ParamsConfig;
    this.textureParamsController = new _utils_TextureParamsController__WEBPACK_IMPORTED_MODULE_5__/* .TextureParamsController */ .V(this);
    this._gifCanvasContext = null;
    this._tmpCanvasContext = null;
    this._parsedFrames = [];
    this._frameDelay = 100;
    this._frameIndex = 0;
  }
  static type() {
    return _poly_registers_nodes_types_Cop__WEBPACK_IMPORTED_MODULE_4__/* .CopType.GIF */ .y.GIF;
  }
  initializeNode() {
    this.io.inputs.setCount(0, 1);
    this.io.inputs.initInputsClonedState(_poly_InputCloneMode__WEBPACK_IMPORTED_MODULE_7__/* .InputCloneMode.NEVER */ .m.NEVER);
  }
  cook(input_contents) {
    return __async(this, null, function* () {
      const url = this.pv.url;
      if (!(0,_core_FileTypeController__WEBPACK_IMPORTED_MODULE_8__/* .isUrlGif */ .hL)(url)) {
        this.states.error.set("url is not an image");
      } else {
        _core_loader_Texture__WEBPACK_IMPORTED_MODULE_9__/* .CoreLoaderTexture.incrementInProgressLoadsCount */ .F.incrementInProgressLoadsCount();
        yield _core_loader_Texture__WEBPACK_IMPORTED_MODULE_9__/* .CoreLoaderTexture.waitForMaxConcurrentLoadsQueueFreed */ .F.waitForMaxConcurrentLoadsQueueFreed();
        const response = yield fetch(url);
        const buffer = yield response.arrayBuffer();
        const gif = yield (0,gifuct_js__WEBPACK_IMPORTED_MODULE_0__/* .parseGIF */ .vq)(buffer);
        const buildImagePatches = true;
        this._parsedFrames = yield (0,gifuct_js__WEBPACK_IMPORTED_MODULE_0__/* .decompressFrames */ .zw)(gif, buildImagePatches);
        const firstFrame = this._parsedFrames[0];
        this._frameDelay = firstFrame.delay;
        this._frameIndex = this.pv.gifFrame - 1;
        this._createCanvas();
        const texture = this._gifCanvasElement ? new three__WEBPACK_IMPORTED_MODULE_10__.CanvasTexture(this._gifCanvasElement) : void 0;
        _core_loader_Texture__WEBPACK_IMPORTED_MODULE_9__/* .CoreLoaderTexture.decrementInProgressLoadsCount */ .F.decrementInProgressLoadsCount(url, texture);
        if (texture) {
          yield this.textureParamsController.update(texture);
          this.setTexture(texture);
        } else {
          this.states.error.set("failed to create canvas");
        }
      }
    });
  }
  _createCanvas() {
    const gifFrame = this._parsedFrames[0];
    this._gifCanvasElement = document.createElement("canvas");
    this._tmpCanvasElement = document.createElement("canvas");
    this._gifCanvasElement.width = gifFrame.dims.width;
    this._gifCanvasElement.height = gifFrame.dims.height;
    this._tmpCanvasElement.width = gifFrame.dims.width;
    this._tmpCanvasElement.height = gifFrame.dims.height;
    this._gifCanvasContext = this._gifCanvasElement.getContext("2d");
    this._tmpCanvasContext = this._tmpCanvasElement.getContext("2d");
    this._drawNextFrame();
  }
  _drawOnCanvas() {
    if (!(this._gifCanvasContext && this._tmpCanvasElement && this._tmpCanvasContext)) {
      return;
    }
    let gifFrame = this._parsedFrames[this._frameIndex];
    if (!gifFrame) {
      console.warn(`no frame at index ${this._frameIndex}, using last frame`);
      gifFrame = this._parsedFrames[this._parsedFrames.length - 1];
    }
    if (gifFrame) {
      const dims = gifFrame.dims;
      if (!this._frameImageData || dims.width != this._frameImageData.width || dims.height != this._frameImageData.height) {
        this._tmpCanvasElement.width = dims.width;
        this._tmpCanvasElement.height = dims.height;
        this._frameImageData = this._tmpCanvasContext.createImageData(dims.width, dims.height);
      }
      this._frameImageData.data.set(gifFrame.patch);
      this._tmpCanvasContext.putImageData(this._frameImageData, 0, 0);
      this._gifCanvasContext.drawImage(this._tmpCanvasElement, dims.left, dims.top);
      const texture = this.containerController.container().texture();
      if (!texture) {
        return;
      }
      texture.needsUpdate = true;
    }
  }
  _drawNextFrame() {
    this._frameIndex++;
    if (this._frameIndex >= this._parsedFrames.length) {
      this._frameIndex = 0;
    }
    this._drawOnCanvas();
    if ((0,_core_BooleanValue__WEBPACK_IMPORTED_MODULE_11__/* .isBooleanTrue */ .bI)(this.pv.play)) {
      setTimeout(() => {
        this._drawNextFrame();
      }, this._frameDelay);
    }
  }
  gifUpdateFrameIndex() {
    this._frameIndex = this.pv.gifFrame;
    this._drawOnCanvas();
  }
  //
  //
  // UTILS
  //
  //
  static PARAM_CALLBACK_reload(node) {
    node.paramCallbackReload();
  }
  paramCallbackReload() {
    this.p.url.setDirty();
    this.p.url.emit(_poly_ParamEvent__WEBPACK_IMPORTED_MODULE_12__/* .ParamEvent.ASSET_RELOAD_REQUEST */ .X.ASSET_RELOAD_REQUEST);
  }
  static PARAM_CALLBACK_gifUpdatePlay(node) {
    node.gifUpdatePlay();
  }
  gifUpdatePlay() {
    if ((0,_core_BooleanValue__WEBPACK_IMPORTED_MODULE_11__/* .isBooleanTrue */ .bI)(this.pv.play)) {
      this._drawNextFrame();
    }
  }
  static PARAM_CALLBACK_gifUpdateFrameIndex(node) {
    node.gifUpdateFrameIndex();
  }
}


/***/ }),

/***/ 5874:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {


// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  "E": function() { return /* binding */ ImageHDRCopNode; }
});

// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/nodes/cop/utils/image/_BaseImage.ts
var _BaseImage = __webpack_require__(11951);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/core/loader/AssetsUtils.ts
var AssetsUtils = __webpack_require__(29248);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/core/loader/texture/_BaseImageLoader.ts + 1 modules
var _BaseImageLoader = __webpack_require__(14315);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/node_modules/three/examples/jsm/loaders/RGBELoader.js
var RGBELoader = __webpack_require__(74658);
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/core/loader/texture/HDR.ts

var __async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};



class HDRTextureLoader extends _BaseImageLoader/* BaseCoreImageLoader */.Q {
  constructor(_url, _node) {
    super(_url, _node);
  }
  _getLoader(options) {
    return __async(this, null, function* () {
      const loader = new RGBELoader/* RGBELoader */.x(this.loadingManager);
      if (options.tdataType) {
        loader.setDataType(options.dataType);
      }
      return loader;
    });
  }
}
HDRTextureLoader.PARAM_ENV_DEFAULT = `${AssetsUtils/* ASSETS_ROOT */.V}/textures/studio_small_09_2k.hdr`;

// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/poly/registers/nodes/types/Cop.ts
var Cop = __webpack_require__(12764);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/core/loader/FileExtensionRegister.ts
var FileExtensionRegister = __webpack_require__(15060);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/poly/NodeContext.ts
var NodeContext = __webpack_require__(52070);
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/cop/ImageHDR.ts






class ImageHDRCopNode extends (0,_BaseImage/* copImageNodeFactoryFactory */.H)({
  type: Cop/* CopTypeImage.IMAGE_HDR */.T.IMAGE_HDR,
  defaultUrl: HDRTextureLoader.PARAM_ENV_DEFAULT,
  extensions: FileExtensionRegister/* EXTENSIONS_BY_NODE_TYPE_BY_CONTEXT */.P[NodeContext/* NodeContext.COP */.sy.COP][Cop/* CopTypeImage.IMAGE_HDR */.T.IMAGE_HDR],
  getLoader: (url, node) => new HDRTextureLoader(url, node)
}) {
}


/***/ }),

/***/ 9772:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "C": function() { return /* binding */ ImageKTX2CopNode; }
/* harmony export */ });
/* harmony import */ var _utils_image_BaseImage__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(11951);
/* harmony import */ var _core_loader_texture_KTX2__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(32801);
/* harmony import */ var _poly_registers_nodes_types_Cop__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(12764);
/* harmony import */ var _core_loader_FileExtensionRegister__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(15060);
/* harmony import */ var _poly_NodeContext__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(52070);






class ImageKTX2CopNode extends (0,_utils_image_BaseImage__WEBPACK_IMPORTED_MODULE_0__/* .copImageNodeFactoryFactory */ .H)({
  type: _poly_registers_nodes_types_Cop__WEBPACK_IMPORTED_MODULE_1__/* .CopTypeImage.IMAGE_KTX2 */ .T.IMAGE_KTX2,
  defaultUrl: _core_loader_texture_KTX2__WEBPACK_IMPORTED_MODULE_2__/* .KTX2TextureLoader.PARAM_ENV_DEFAULT */ .N.PARAM_ENV_DEFAULT,
  extensions: _core_loader_FileExtensionRegister__WEBPACK_IMPORTED_MODULE_3__/* .EXTENSIONS_BY_NODE_TYPE_BY_CONTEXT */ .P[_poly_NodeContext__WEBPACK_IMPORTED_MODULE_4__/* .NodeContext.COP */ .sy.COP][_poly_registers_nodes_types_Cop__WEBPACK_IMPORTED_MODULE_1__/* .CopTypeImage.IMAGE_KTX2 */ .T.IMAGE_KTX2],
  getLoader: (url, node) => new _core_loader_texture_KTX2__WEBPACK_IMPORTED_MODULE_2__/* .KTX2TextureLoader */ .N(url, node)
}) {
}


/***/ }),

/***/ 83704:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {


// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  "e": function() { return /* binding */ LightMapCopNode; }
});

// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/nodes/cop/_Base.ts
var _Base = __webpack_require__(65276);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/nodes/utils/params/ParamsConfig.ts
var ParamsConfig = __webpack_require__(96949);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/node_modules/three/build/three.module.js
var three_module = __webpack_require__(21410);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/core/UserAgent.ts
var UserAgent = __webpack_require__(66689);
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/cop/utils/lightMap/Common.ts



const isAndroidOriOS = UserAgent/* CoreUserAgent.isAndroid */.Cj.isAndroid() || UserAgent/* CoreUserAgent.isiOS */.Cj.isiOS();
const renderTargetType = isAndroidOriOS ? three_module.HalfFloatType : three_module.FloatType;
const renderTargetFormat = three_module.RGBAFormat;
const RENDER_TARGET_DEFAULT_SIZE = 1;

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/cop/utils/lightMap/BlurMaterial.ts


function setBlurMaterial(mat, options) {
  mat.uniforms.previousLightMap.value = options.lightMap.texture;
  mat.uniforms.pixelOffset.value = 1 / options.res;
}
function createBlurMaterial() {
  const blurMaterial = new three_module.MeshBasicMaterial();
  blurMaterial.uniforms = {
    previousLightMap: { value: null },
    pixelOffset: { value: 1 }
    // TODO: make sure this is not important
    // polygonOffset: true,
    // polygonOffsetFactor: -1,
    // polygonOffsetUnits: 3.0,
  };
  blurMaterial.polygonOffset = true;
  blurMaterial.polygonOffsetFactor = -1;
  blurMaterial.polygonOffsetUnits = 3;
  blurMaterial.onBeforeCompile = (shader) => {
    shader.vertexShader = `
#define USE_UV
${shader.vertexShader.slice(0, -2)}
	gl_Position = vec4((uv - 0.5) * 2.0, 1.0, 1.0);
}
`;
    const bodyStart = shader.fragmentShader.indexOf("void main() {");
    shader.fragmentShader = `
#define USE_UV
${shader.fragmentShader.slice(0, bodyStart)}
uniform sampler2D previousLightMap;
uniform float pixelOffset;
${shader.fragmentShader.slice(bodyStart - 1, -2)}
	gl_FragColor.rgb = (
		texture2D(previousLightMap, vUv + vec2( pixelOffset,  0.0        )).rgb +
		texture2D(previousLightMap, vUv + vec2( 0.0        ,  pixelOffset)).rgb +
		texture2D(previousLightMap, vUv + vec2( 0.0        , -pixelOffset)).rgb +
		texture2D(previousLightMap, vUv + vec2(-pixelOffset,  0.0        )).rgb +
		texture2D(previousLightMap, vUv + vec2( pixelOffset,  pixelOffset)).rgb +
		texture2D(previousLightMap, vUv + vec2(-pixelOffset,  pixelOffset)).rgb +
		texture2D(previousLightMap, vUv + vec2( pixelOffset, -pixelOffset)).rgb +
		texture2D(previousLightMap, vUv + vec2(-pixelOffset, -pixelOffset)).rgb
	) / 8.0;
}`;
    shader.uniforms.previousLightMap = blurMaterial.uniforms.previousLightMap;
    shader.uniforms.pixelOffset = blurMaterial.uniforms.pixelOffset;
    blurMaterial.userData.shader = shader;
  };
  return blurMaterial;
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/cop/utils/lightMap/BlurPlane.ts



function createBlurPlane() {
  const mat = createBlurMaterial();
  const plane = new three_module.Mesh(new three_module.PlaneGeometry(1, 1), mat);
  plane.name = "Blurring Plane";
  plane.frustumCulled = false;
  plane.renderOrder = 0;
  mat.depthWrite = false;
  return { plane, mat };
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/cop/utils/lightMap/RenderTargetsCombineMaterial.ts


const UV_LIGHT_MAP_FLIPPED_ATTRIB_NAME = "uvLightmapFlipped";
function setRenderTargetsCombineMaterial(mat, options) {
  mat.uniforms.rt1.value = options.rt1.texture;
  mat.uniforms.rt2.value = options.rt2.texture;
}
function createRenderTargetsCombineMaterial() {
  const mat = new three_module.ShaderMaterial();
  mat.uniforms = {
    rt1: { value: null },
    rt2: { value: null }
  };
  mat.name = "renderTargetsCombineMaterial";
  mat.onBeforeCompile = (shader) => {
    shader.vertexShader = `
varying vec2 vUv;
void main(){
	vUv = uv;
	gl_Position = vec4((uv - 0.5) * 2.0, 1.0, 1.0);
}`;
    shader.fragmentShader = `
uniform sampler2D rt1;
uniform sampler2D rt2;
varying vec2 vUv;
void main(){
	vec3 rt1Value = texture2D(rt1, vUv).rgb;
	vec3 rt2Value = texture2D(rt2, vUv).rgb;
	gl_FragColor.rgb = rt1Value + rt2Value;
}
`;
    shader.uniforms.rt1 = mat.uniforms.rt1;
    shader.uniforms.rt2 = mat.uniforms.rt2;
    mat.userData.shader = shader;
  };
  return mat;
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/cop/utils/lightMap/RenderTargetsCombinePlane.ts



function createRenderTargetsCombinePlane() {
  const mat = createRenderTargetsCombineMaterial();
  const plane = new three_module.Mesh(new three_module.PlaneGeometry(1, 1), mat);
  plane.name = "RenderTargetsCombine Plane";
  plane.frustumCulled = false;
  plane.renderOrder = 0;
  mat.depthWrite = false;
  return { plane, mat };
}

// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/nodes/cop/utils/lightMap/LightMapMaterial.ts
var LightMapMaterial = __webpack_require__(80478);
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/cop/utils/lightMap/LightMapUtils.ts

function invertNormals(object) {
  const geometry = object.geometry;
  if (!geometry) {
    return;
  }
  const normalAttribute = geometry.getAttribute("normal");
  const array = normalAttribute.array;
  const length = array.length;
  for (let i = 0; i < length; i++) {
    array[i] *= -1;
  }
  normalAttribute.needsUpdate = true;
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/cop/utils/lightMap/RenderTargetPair.ts



class RenderTargetPair {
  constructor() {
    this.pingPong = false;
    this.RT1 = new three_module.WebGLRenderTarget(RENDER_TARGET_DEFAULT_SIZE, RENDER_TARGET_DEFAULT_SIZE, {
      type: renderTargetType,
      format: renderTargetFormat
    });
    this.RT2 = new three_module.WebGLRenderTarget(RENDER_TARGET_DEFAULT_SIZE, RENDER_TARGET_DEFAULT_SIZE, {
      type: renderTargetType,
      format: renderTargetFormat
    });
  }
  setSize(x, w) {
    this.RT1.setSize(x, w);
    this.RT2.setSize(x, w);
  }
  toggle() {
    this.pingPong = !this.pingPong;
  }
  previous() {
    return this.pingPong ? this.RT1 : this.RT2;
  }
  current() {
    return this.pingPong ? this.RT2 : this.RT1;
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/cop/utils/LightMapController.ts










class LightMapController {
  constructor(renderer) {
    this.renderer = renderer;
    this.objectTargets = [];
    this.lights = [];
    this._scene = new three_module.Scene();
    this.renderFlippedUvs = false;
    this.nonFlippedRenderTargetPair = new RenderTargetPair();
    this.flippedRenderTargetPair = new RenderTargetPair();
    this.finalRenderTarget = new three_module.WebGLRenderTarget(RENDER_TARGET_DEFAULT_SIZE, RENDER_TARGET_DEFAULT_SIZE, {
      type: renderTargetType,
      format: renderTargetFormat
    });
    this._params = {
      resolution: 1,
      lightRadius: 1,
      totalIterationsCount: 1,
      blur: false,
      blurAmount: 0
    };
    this._objectStateByObject = /* @__PURE__ */ new WeakMap();
    this._previousRenderTarget = null;
    this._lightHierarchyStateByLight = /* @__PURE__ */ new WeakMap();
    this._lightMatrixStateByLight = /* @__PURE__ */ new WeakMap();
    this._t = new three_module.Vector3();
    this._q = new three_module.Quaternion();
    this._s = new three_module.Vector3();
    this.lightMapMaterial = (0,LightMapMaterial/* createLightMapMaterial */.CA)();
    const blurPlaneData = createBlurPlane();
    this.blurPlane = blurPlaneData.plane;
    this.blurMaterial = blurPlaneData.mat;
    const renderTargetsCombinePlaneData = createRenderTargetsCombinePlane();
    this.renderTargetsCombinePlane = renderTargetsCombinePlaneData.plane;
    this.renderTargetsCombineMaterial = renderTargetsCombinePlaneData.mat;
  }
  setSize(w, h) {
    this.nonFlippedRenderTargetPair.setSize(w, h);
    this.flippedRenderTargetPair.setSize(w, h);
    this.finalRenderTarget.setSize(w, h);
  }
  renderTargetPair() {
    return this.renderFlippedUvs ? this.flippedRenderTargetPair : this.nonFlippedRenderTargetPair;
  }
  textureRenderTarget() {
    return this.finalRenderTarget;
  }
  setParams(params) {
    this._params.resolution = params.resolution;
    this._params.lightRadius = params.lightRadius;
    this._params.totalIterationsCount = params.totalIterationsCount;
    this._params.blur = params.blur;
    this._params.blurAmount = params.blurAmount;
    this.setSize(params.resolution, params.resolution);
  }
  setState(objects, lights) {
    this._clearScene();
    this._scene.add(this.blurPlane);
    this._previousRenderTarget = this.renderer.getRenderTarget();
    this._setObjects(objects);
    this._setLights(lights);
  }
  _clearScene() {
    let child;
    while (child = this._scene.children[0]) {
      this._scene.remove(child);
    }
  }
  _setObjects(objects) {
    this.objectTargets = [...objects];
    this._saveObjectsState();
  }
  _setLights(lights) {
    this.lights = lights;
    for (const light of lights) {
      this._saveLightHierarchyState(light);
      this._scene.attach(light);
      this._saveLightMatrixState(light);
    }
  }
  _saveLightHierarchyState(light) {
    this._lightHierarchyStateByLight.set(light, {
      parent: light.parent,
      matrixAutoUpdate: light.matrixAutoUpdate
    });
    light.matrixAutoUpdate = true;
  }
  _saveLightMatrixState(light) {
    light.updateMatrix();
    light.matrix.decompose(this._t, this._q, this._s);
    this._lightMatrixStateByLight.set(light, {
      matrix: light.matrix.clone(),
      position: this._t.clone()
    });
  }
  _saveObjectsState() {
    let i = 0;
    for (const object of this.objectTargets) {
      this._objectStateByObject.set(object, {
        frustumCulled: object.frustumCulled,
        material: object.material,
        parent: object.parent,
        renderOrder: object.renderOrder
      });
      object.material = this.lightMapMaterial;
      object.frustumCulled = false;
      object.renderOrder = 1e3 + i;
      this._scene.attach(object);
      i++;
    }
  }
  _moveLights() {
    const lightRadius = this._params.lightRadius;
    for (const light of this.lights) {
      const state = this._lightMatrixStateByLight.get(light);
      if (state) {
        const position = state.position;
        light.position.x = position.x + lightRadius * (Math.random() - 0.5);
        light.position.y = position.y + lightRadius * (Math.random() - 0.5);
        light.position.z = position.z + lightRadius * (Math.random() - 0.5);
      }
    }
  }
  restoreState() {
    this._restoreObjectsState();
    this._restoreLightsState();
    this.renderer.setRenderTarget(this._previousRenderTarget);
  }
  _invertObjects() {
    for (const object of this.objectTargets) {
      invertNormals(object);
    }
  }
  _restoreObjectsState() {
    for (const object of this.objectTargets) {
      const state = this._objectStateByObject.get(object);
      if (state) {
        object.frustumCulled = state.frustumCulled;
        object.renderOrder = state.renderOrder;
        object.material = state.material;
        const parent = state.parent;
        if (parent) {
          parent.add(object);
        }
      }
    }
  }
  _restoreLightsState() {
    var _a;
    for (const light of this.lights) {
      const stateH = this._lightHierarchyStateByLight.get(light);
      const stateM = this._lightMatrixStateByLight.get(light);
      if (stateH && stateM) {
        light.matrixAutoUpdate = stateH.matrixAutoUpdate;
        light.matrix.copy(stateM.matrix);
        light.matrix.decompose(light.position, light.quaternion, light.scale);
        light.updateMatrix();
        (_a = stateH.parent) == null ? void 0 : _a.attach(light);
      }
    }
  }
  runUpdates(camera) {
    const totalIterationsCount = this._params.totalIterationsCount;
    this.blurMaterial.uniforms.pixelOffset.value = this._params.blurAmount / this._params.resolution;
    this.blurPlane.visible = this._params.blur;
    this.lightMapMaterial.uniforms.lightMapMult.value = 1 / totalIterationsCount;
    this.lightMapMaterial.side = three_module.FrontSide;
    this.lightMapMaterial.shadowSide = null;
    this.renderFlippedUvs = false;
    this._clear(camera);
    for (let i = 0; i < totalIterationsCount; i++) {
      this._moveLights();
      this._update(camera);
    }
    this.renderFlippedUvs = true;
    this._clear(camera);
    this._invertObjects();
    this.lightMapMaterial.side = [three_module.DoubleSide, three_module.BackSide][1];
    this.lightMapMaterial.shadowSide = three_module.BackSide;
    for (let i = 0; i < totalIterationsCount; i++) {
      this._moveLights();
      this._update(camera);
    }
    this._invertObjects();
    this._clearScene();
    this._scene.add(this.renderTargetsCombinePlane);
    setRenderTargetsCombineMaterial(this.renderTargetsCombineMaterial, {
      rt1: this.flippedRenderTargetPair.current(),
      rt2: this.nonFlippedRenderTargetPair.current()
    });
    this.renderer.setRenderTarget(this.finalRenderTarget);
    this.renderer.render(this._scene, camera);
  }
  _clear(camera) {
    this._scene.visible = false;
    this._update(camera);
    this._update(camera);
    this._scene.visible = true;
  }
  _update(camera) {
    const rtPair = this.renderTargetPair();
    const activeMap = rtPair.current();
    const inactiveMap = rtPair.previous();
    this.renderer.setRenderTarget(activeMap);
    (0,LightMapMaterial/* setLightMapMaterial */.ws)(this.lightMapMaterial, {
      lightMap: inactiveMap
      // lightMapMult:1 / totalIterationsCount,
    });
    setBlurMaterial(this.blurMaterial, {
      res: this._params.resolution,
      lightMap: inactiveMap
    });
    rtPair.toggle();
    this.renderer.render(this._scene, camera);
  }
}

// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/core/Type.ts
var Type = __webpack_require__(19037);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/nodes/cop/utils/DataTextureController.ts
var DataTextureController = __webpack_require__(50050);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/nodes/cop/utils/RendererController.ts
var RendererController = __webpack_require__(77643);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/poly/registers/nodes/types/Cop.ts
var Cop = __webpack_require__(12764);
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/cop/LightMap.ts

var __async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};










class LightMapCopParamConfig extends ParamsConfig/* NodeParamsConfig */.yI {
  constructor() {
    super(...arguments);
    /** @param click to update shadow, when mode is manual */
    this.update = ParamsConfig/* ParamConfig.BUTTON */.XC.BUTTON(null, {
      callback: (node) => {
        LightMapCopNode.PARAM_CALLBACK_updateManual(node);
      }
    });
    /** @param defines if the shader is rendered via the same camera used to render the scene */
    this.useCameraRenderer = ParamsConfig/* ParamConfig.BOOLEAN */.XC.BOOLEAN(1);
    // needs to be 1, as it does not work on firefox otherwise
    /** @param shadow resolution */
    this.lightMapRes = ParamsConfig/* ParamConfig.INTEGER */.XC.INTEGER(1024, { range: [1, 2048], rangeLocked: [true, false] });
    /** @param iterations */
    this.iterations = ParamsConfig/* ParamConfig.INTEGER */.XC.INTEGER(512, { range: [1, 2048], rangeLocked: [true, false] });
    /** @param blendWindow */
    // iterationBlend = ParamConfig.FLOAT(DEFAULT_ITERATION_BLEND, {
    // 	range: [0, 1],
    // 	rangeLocked: [true, true],
    // });
    /** @param blurEdges */
    this.blur = ParamsConfig/* ParamConfig.BOOLEAN */.XC.BOOLEAN(1);
    /** @param blurAmount */
    this.blurAmount = ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(1, {
      visibleIf: { blur: 1 },
      range: [0, 1],
      rangeLocked: [true, false]
    });
    /** @param lightPositionVariation */
    this.lightRadius = ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(1, {
      range: [0, 10]
    });
    this.objectsMask = ParamsConfig/* ParamConfig.STRING */.XC.STRING("", { objectMask: true });
    this.lightsMask = ParamsConfig/* ParamConfig.STRING */.XC.STRING("*", { objectMask: true });
  }
}
const LightMap_ParamsConfig = new LightMapCopParamConfig();
class LightMapCopNode extends _Base/* TypedCopNode */.z {
  constructor() {
    super(...arguments);
    this.paramsConfig = LightMap_ParamsConfig;
    this._includedObjects = [];
    this._includedLights = [];
  }
  static type() {
    return Cop/* CopType.LIGHT_MAP */.y.LIGHT_MAP;
  }
  cook() {
    return __async(this, null, function* () {
      yield this._render();
    });
  }
  _createLightMapController() {
    return __async(this, null, function* () {
      const renderer = yield this.scene().renderersRegister.waitForRenderer();
      if (!renderer) {
        console.warn("no renderer found");
        return;
      }
      if (!(renderer instanceof three_module.WebGLRenderer)) {
        this.states.error.set("renderer found is not WebGLRenderer");
        return;
      }
      const lightMapController = new LightMapController(renderer);
      return lightMapController;
    });
  }
  //
  //
  // ACTIVE
  //
  //
  // static PARAM_CALLBACK_update_updateMode(node: LightMapCopNode) {
  // 	// node._updateRenderHook();
  // }
  //
  //
  // UPDATE
  //
  //
  _render() {
    return __async(this, null, function* () {
      this.lightMapController = this.lightMapController || (yield this._createLightMapController());
      if (!this.lightMapController) {
        return;
      }
      const mainCamera = yield this.scene().mainCamera();
      if (!mainCamera) {
        return;
      }
      this._updateObjectsAndLightsList();
      this.lightMapController.setState(this._includedObjects, this._includedLights);
      this.lightMapController.setParams({
        resolution: this.pv.lightMapRes,
        lightRadius: this.pv.lightRadius,
        totalIterationsCount: this.pv.iterations,
        // iterationBlend: this.pv.iterationBlend,
        blur: this.pv.blur,
        blurAmount: this.pv.blurAmount
      });
      this.lightMapController.runUpdates(mainCamera);
      this.lightMapController.restoreState();
      const renderTarget = this.lightMapController.textureRenderTarget();
      if ((0,Type/* isBooleanTrue */.bI)(this.pv.useCameraRenderer)) {
        this.setTexture(renderTarget.texture);
      } else {
        this._dataTextureController = this._dataTextureController || new DataTextureController/* DataTextureController */.y(DataTextureController/* DataTextureControllerBufferType.Float32Array */.A.Float32Array);
        this._rendererController = this._rendererController || new RendererController/* CopRendererController */.G(this);
        const renderer = yield this._rendererController.waitForRenderer();
        if (!(renderer instanceof three_module.WebGLRenderer)) {
          this.states.error.set("renderer found is not WebGLRenderer");
          this.cookController.endCook();
          return;
        }
        const texture = this._dataTextureController.fromRenderTarget(renderer, renderTarget);
        this.setTexture(texture);
      }
    });
  }
  static PARAM_CALLBACK_updateManual(node) {
    node.setDirty();
  }
  //
  //
  // UPDATE OBJECTS LIST
  //
  //
  _updateObjectsAndLightsList() {
    let matchedObjects = [];
    let matchedLights = [];
    this._includedLights = [];
    this._includedObjects = [];
    const lightsByUuid = /* @__PURE__ */ new WeakSet();
    if (this.pv.lightsMask != "") {
      matchedLights = this.scene().objectsByMask(this.pv.lightsMask);
      for (const matchedLight of matchedLights) {
        if (matchedLight instanceof three_module.Light) {
          this._includedLights.push(matchedLight);
          lightsByUuid.add(matchedLight);
        }
      }
    }
    if (this.pv.objectsMask != "") {
      matchedObjects = this.scene().objectsByMask(this.pv.objectsMask);
      for (const matchedObject of matchedObjects) {
        if (!(matchedObject instanceof three_module.Light)) {
          if (!lightsByUuid.has(matchedObject) && matchedObject instanceof three_module.Mesh) {
            this._includedObjects.push(matchedObject);
          }
        }
      }
    }
  }
}


/***/ }),

/***/ 78124:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "u": function() { return /* binding */ PostProcessNetworkCopNode; }
/* harmony export */ });
/* harmony import */ var _BaseManager__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(41069);
/* harmony import */ var _poly_NodeContext__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(52070);
/* harmony import */ var _utils_DisplayNodeController__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(35725);
/* harmony import */ var _post_utils_EffectComposerController__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(32241);





class PostProcessNetworkCopNode extends _BaseManager__WEBPACK_IMPORTED_MODULE_0__/* .BaseNetworkCopNode */ .a {
  constructor() {
    super(...arguments);
    this.paramsConfig = new _post_utils_EffectComposerController__WEBPACK_IMPORTED_MODULE_1__/* .PostProcessNetworkParamsConfig */ .Ab();
    this.effectsComposerController = new _post_utils_EffectComposerController__WEBPACK_IMPORTED_MODULE_1__/* .EffectComposerController */ .iy(this);
    this.displayNodeController = new _utils_DisplayNodeController__WEBPACK_IMPORTED_MODULE_2__/* .DisplayNodeController */ .v(
      this,
      this.effectsComposerController.displayNodeControllerCallbacks()
    );
    this._childrenControllerContext = _poly_NodeContext__WEBPACK_IMPORTED_MODULE_3__/* .NodeContext.POST */ .sy.POST;
  }
  static type() {
    return _poly_NodeContext__WEBPACK_IMPORTED_MODULE_3__/* .NetworkNodeType.POST */ .kX.POST;
  }
  createNode(node_class, options) {
    return super.createNode(node_class, options);
  }
  children() {
    return super.children();
  }
  nodesByType(type) {
    return super.nodesByType(type);
  }
}


/***/ }),

/***/ 45853:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "j": function() { return /* binding */ RenderCopNode; }
/* harmony export */ });
/* unused harmony export RenderCopNodeParamConfig */
/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(21410);
/* harmony import */ var _Base__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(65276);
/* harmony import */ var _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(96949);
/* harmony import */ var _utils_RendererController__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(77643);
/* harmony import */ var _core_BooleanValue__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(19037);
/* harmony import */ var _utils_DataTextureController__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(50050);
/* harmony import */ var _utils_TextureParamsController__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(20400);
/* harmony import */ var _core_UserAgent__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(66689);
/* harmony import */ var _Poly__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(99934);
/* harmony import */ var _core_camera_frameMode_CoreCameraPerspectiveFrameMode__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(57987);
/* harmony import */ var _core_camera_frameMode_CoreCameraOrthographicFrameMode__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(85690);
/* harmony import */ var _poly_registers_nodes_types_Cop__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(12764);

var __async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};












const _v2 = new three__WEBPACK_IMPORTED_MODULE_0__.Vector2();
function RenderCopNodeParamConfig(Base) {
  return class Mixin extends Base {
    constructor() {
      super(...arguments);
      /** @param path to the main camera object that will be used when the scene loads outside of the editor */
      this.cameraPath = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .ParamConfig.STRING */ .XC.STRING("*perspectiveCamera*", {
        objectMask: true
      });
      /** @param transparent background */
      this.transparentBackground = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .ParamConfig.BOOLEAN */ .XC.BOOLEAN(1);
      /** @param bg Color */
      this.backgroundColor = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .ParamConfig.COLOR */ .XC.COLOR([0, 0, 0], {
        visibleIf: {
          transparentBackground: 0
        }
      });
      /** @param use same resolution as renderer */
      this.useRendererRes = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .ParamConfig.BOOLEAN */ .XC.BOOLEAN(1);
      /** @param render resolution */
      this.resolution = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .ParamConfig.VECTOR2 */ .XC.VECTOR2([1024, 1024], {
        visibleIf: {
          useRendererRes: 0
        }
      });
      /** @param use a data texture instead of a render target, which can be useful when using that texture as and envMap */
      this.useDataTexture = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .ParamConfig.BOOLEAN */ .XC.BOOLEAN(0);
      /** @param autoRender */
      this.autoRender = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .ParamConfig.BOOLEAN */ .XC.BOOLEAN(1);
      /** @param render button */
      this.render = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .ParamConfig.BUTTON */ .XC.BUTTON(null, {
        callback: (node) => {
          RenderCopNode.PARAM_CALLBACK_render(node);
        }
      });
    }
  };
}
class RenderCopParamConfig extends (0,_utils_TextureParamsController__WEBPACK_IMPORTED_MODULE_2__/* .TextureParamConfig */ .h)(RenderCopNodeParamConfig(_utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .NodeParamsConfig */ .yI)) {
}
const ParamsConfig = new RenderCopParamConfig();
class RenderCopNode extends _Base__WEBPACK_IMPORTED_MODULE_3__/* .TypedCopNode */ .z {
  constructor() {
    super(...arguments);
    this.paramsConfig = ParamsConfig;
    this.textureParamsController = new _utils_TextureParamsController__WEBPACK_IMPORTED_MODULE_2__/* .TextureParamsController */ .V(this);
    this._renderTargetByRenderer = /* @__PURE__ */ new WeakMap();
    this._renderOnTargetBound = this.renderOnTarget.bind(this);
  }
  static type() {
    return _poly_registers_nodes_types_Cop__WEBPACK_IMPORTED_MODULE_4__/* .CopType.RENDER */ .y.RENDER;
  }
  cook() {
    return __async(this, null, function* () {
      if ((0,_core_BooleanValue__WEBPACK_IMPORTED_MODULE_5__/* .isBooleanTrue */ .bI)(this.pv.autoRender)) {
        this._addOnBeforeTickCallback();
      } else {
        this._removeOnBeforeTickCallback();
      }
      const camera = yield this._getCamera();
      if (camera) {
        yield this.renderOnTarget();
      } else {
        this.cookController.endCook();
      }
    });
  }
  //
  //
  // AUTO RENDER
  //
  //
  _addOnBeforeTickCallback() {
    const callbackName = this._onBeforeRenderCallbackName();
    if (this.scene().hasBeforeTickCallback(callbackName)) {
      return;
    }
    this.scene().registerOnBeforeTick(callbackName, this._renderOnTargetBound);
  }
  _removeOnBeforeTickCallback() {
    this.scene().unRegisterOnBeforeTick(this._onBeforeRenderCallbackName());
  }
  _onBeforeRenderCallbackName() {
    return `cop/render_onBeforeTickCallback-${this.graphNodeId()}`;
  }
  dispose() {
    super.dispose();
    this._removeOnBeforeTickCallback();
  }
  //
  //
  // RENDER + RENDER TARGET
  //
  //
  _getCameraSync() {
    return this.scene().objectsController.findObjectByMask(this.pv.cameraPath);
  }
  _getCamera() {
    return __async(this, null, function* () {
      const camera = this._getCameraSync();
      if (camera) {
        return camera;
      }
      return new Promise((resolve) => {
        const onCameraUpdated = () => __async(this, null, function* () {
          const camera2 = this._getCameraSync();
          this.scene().camerasController.removeOnCameraObjectsUpdated(onCameraUpdated);
          if (camera2) {
            resolve(camera2);
          }
        });
        this.scene().camerasController.onCameraObjectsUpdated(onCameraUpdated);
      });
    });
  }
  renderOnTarget() {
    return __async(this, null, function* () {
      const camera = yield this._getCamera();
      if (!camera) {
        this.states.error.set(`no camera found`);
        return;
      }
      this._rendererController = this._rendererController || new _utils_RendererController__WEBPACK_IMPORTED_MODULE_6__/* .CopRendererController */ .G(this);
      const renderer = yield this._rendererController.waitForRenderer();
      if (!(renderer instanceof three__WEBPACK_IMPORTED_MODULE_0__.WebGLRenderer)) {
        this.states.error.set(`no renderer found`);
        return;
      }
      const renderTarget = yield this.createRenderTargetIfRequired(renderer);
      this._ensureRenderTargetResolutionValid(renderer, renderTarget);
      const viewer = this.scene().viewersRegister.lastRenderedViewer();
      if (!viewer) {
        this.states.error.set(`no viewer found`);
        return;
      }
      const viewerCamera = viewer.camera();
      if (!viewerCamera) {
        this.states.error.set(`no viewer camera found`);
        return;
      }
      this._requestedResolution(renderer, _v2);
      const aspect = _v2.x / _v2.y;
      if (camera instanceof three__WEBPACK_IMPORTED_MODULE_0__.PerspectiveCamera && viewerCamera instanceof three__WEBPACK_IMPORTED_MODULE_0__.PerspectiveCamera) {
        _core_camera_frameMode_CoreCameraPerspectiveFrameMode__WEBPACK_IMPORTED_MODULE_7__/* .CoreCameraPerspectiveFrameMode.updateCameraAspect */ .p.updateCameraAspect(camera, aspect, { cameraWithAttributes: viewerCamera });
      } else {
        if (camera instanceof three__WEBPACK_IMPORTED_MODULE_0__.OrthographicCamera && viewerCamera instanceof three__WEBPACK_IMPORTED_MODULE_0__.OrthographicCamera) {
          _core_camera_frameMode_CoreCameraOrthographicFrameMode__WEBPACK_IMPORTED_MODULE_8__/* .CoreCameraOrthographicFrameMode.updateCameraAspect */ .s.updateCameraAspect(camera, aspect, {
            cameraWithAttributes: viewerCamera
          });
        }
      }
      const scene = this.scene().threejsScene();
      const prevTarget = renderer.getRenderTarget();
      const prevColorSpace = renderer.outputColorSpace;
      const prevBackground = scene.background;
      scene.background = this.pv.transparentBackground ? null : this.pv.backgroundColor;
      renderer.setRenderTarget(renderTarget);
      renderer.outputColorSpace = this.pv.colorSpace;
      renderer.clear();
      renderer.render(scene, camera);
      renderer.setRenderTarget(prevTarget);
      renderer.outputColorSpace = prevColorSpace;
      scene.background = prevBackground;
      if (renderTarget.texture) {
        if ((0,_core_BooleanValue__WEBPACK_IMPORTED_MODULE_5__/* .isBooleanTrue */ .bI)(this.pv.useDataTexture)) {
          this._dataTextureController = this._dataTextureController || new _utils_DataTextureController__WEBPACK_IMPORTED_MODULE_9__/* .DataTextureController */ .y(_utils_DataTextureController__WEBPACK_IMPORTED_MODULE_9__/* .DataTextureControllerBufferType.Float32Array */ .A.Float32Array);
          const dataTexture = this._dataTextureController.fromRenderTarget(renderer, renderTarget);
          yield this.textureParamsController.update(dataTexture);
          this.setTexture(dataTexture);
          return;
        } else {
          this.setTexture(renderTarget.texture);
          yield this.textureParamsController.update(renderTarget.texture);
          return;
        }
      }
    });
  }
  renderTarget(renderer) {
    return __async(this, null, function* () {
      return this._renderTargetByRenderer.get(renderer);
    });
  }
  createRenderTargetIfRequired(renderer) {
    return __async(this, null, function* () {
      let renderTarget = this._renderTargetByRenderer.get(renderer);
      if (!renderTarget) {
        renderTarget = yield this._createRenderTarget(renderer);
        this._renderTargetByRenderer.set(renderer, renderTarget);
      }
      return renderTarget;
    });
  }
  _requestedResolution(renderer, target) {
    if ((0,_core_BooleanValue__WEBPACK_IMPORTED_MODULE_5__/* .isBooleanTrue */ .bI)(this.pv.useRendererRes)) {
      renderer.getSize(target);
    } else {
      target.copy(this.pv.resolution);
    }
  }
  _ensureRenderTargetResolutionValid(renderer, renderTarget) {
    this._requestedResolution(renderer, _v2);
    const image = renderTarget.texture.image;
    if (image.width != _v2.x || image.height != _v2.y) {
      renderTarget.setSize(_v2.x, _v2.y);
    }
  }
  _createRenderTarget(renderer) {
    return __async(this, null, function* () {
      this._requestedResolution(renderer, _v2);
      const wrapS = three__WEBPACK_IMPORTED_MODULE_0__.ClampToEdgeWrapping;
      const wrapT = three__WEBPACK_IMPORTED_MODULE_0__.ClampToEdgeWrapping;
      const minFilter = three__WEBPACK_IMPORTED_MODULE_0__.LinearFilter;
      const magFilter = three__WEBPACK_IMPORTED_MODULE_0__.NearestFilter;
      const renderTarget = new three__WEBPACK_IMPORTED_MODULE_0__.WebGLRenderTarget(_v2.x, _v2.y, {
        wrapS,
        wrapT,
        minFilter,
        magFilter,
        format: three__WEBPACK_IMPORTED_MODULE_0__.RGBAFormat,
        generateMipmaps: true,
        type: _core_UserAgent__WEBPACK_IMPORTED_MODULE_10__/* .CoreUserAgent.isiOS */ .Cj.isiOS() ? three__WEBPACK_IMPORTED_MODULE_0__.HalfFloatType : three__WEBPACK_IMPORTED_MODULE_0__.FloatType,
        samples: renderer.getPixelRatio(),
        stencilBuffer: true,
        depthBuffer: true
      });
      yield this.textureParamsController.update(renderTarget.texture);
      _Poly__WEBPACK_IMPORTED_MODULE_11__/* .Poly.warn */ .L.warn("created render target", this.path(), _v2.x, _v2.y);
      return renderTarget;
    });
  }
  //
  //
  // CALLBACK
  //
  //
  static PARAM_CALLBACK_render(node) {
    node.renderOnTarget();
  }
}


/***/ }),

/***/ 24285:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "g": function() { return /* binding */ SDFFromObjectCopNode; }
/* harmony export */ });
/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(21410);
/* harmony import */ var _core_geometry_bvh_ThreeMeshBVHHelper__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(17862);
/* harmony import */ var _poly_NodeContext__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(52070);
/* harmony import */ var _Base__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(65276);
/* harmony import */ var _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(96949);
/* harmony import */ var _core_loader_geometry_SDF__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(87737);
/* harmony import */ var _poly_registers_nodes_types_Cop__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(12764);

var __async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};








const _bbox = new three__WEBPACK_IMPORTED_MODULE_0__.Box3();
const _rayDir = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();
const _ray = new three__WEBPACK_IMPORTED_MODULE_0__.Ray();
const _bboxSize = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();
const _resolution = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();
const _voxelSizes = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();
const _padding = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();
const objectWorldMat = new three__WEBPACK_IMPORTED_MODULE_0__.Matrix4();
const objectWorldMatInverse = new three__WEBPACK_IMPORTED_MODULE_0__.Matrix4();
const t = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();
const q = new three__WEBPACK_IMPORTED_MODULE_0__.Quaternion();
const s = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();
class SDFFromObjectCopParamsConfig extends _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .NodeParamsConfig */ .yI {
  constructor() {
    super(...arguments);
    /** @param which SOP node to import from */
    this.geometry = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .ParamConfig.NODE_PATH */ .XC.NODE_PATH("", {
      nodeSelection: {
        context: _poly_NodeContext__WEBPACK_IMPORTED_MODULE_2__/* .NodeContext.SOP */ .sy.SOP
      }
    });
    /** @param voxelSize */
    this.voxelSize = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .ParamConfig.FLOAT */ .XC.FLOAT(0.1, {
      range: [1e-5, 1],
      rangeLocked: [true, false]
    });
    /** @param padding */
    this.padding = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .ParamConfig.INTEGER */ .XC.INTEGER(2, {
      range: [0, 5],
      rangeLocked: [true, false]
    });
    /** @param resolution */
    this.resolution = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .ParamConfig.VECTOR3 */ .XC.VECTOR3([-1, -1, -1], {
      cook: false,
      editable: false,
      separatorBefore: true
    });
    /** @param boundMin */
    this.boundMin = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .ParamConfig.VECTOR3 */ .XC.VECTOR3([-1, -1, -1], {
      cook: false,
      editable: false
    });
    /** @param boundMax */
    this.boundMax = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .ParamConfig.VECTOR3 */ .XC.VECTOR3([1, 1, 1], {
      cook: false,
      editable: false
    });
  }
}
const ParamsConfig = new SDFFromObjectCopParamsConfig();
class SDFFromObjectCopNode extends _Base__WEBPACK_IMPORTED_MODULE_3__/* .TypedCopNode */ .z {
  constructor() {
    super(...arguments);
    this.paramsConfig = ParamsConfig;
    this._resolutionUsed = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3(-1, -1, -1);
  }
  static type() {
    return _poly_registers_nodes_types_Cop__WEBPACK_IMPORTED_MODULE_4__/* .CopType.SDF_FROM_OBJECT */ .y.SDF_FROM_OBJECT;
  }
  cook(inputContents) {
    return __async(this, null, function* () {
      const geometryNode = this.pv.geometry.nodeWithContext(_poly_NodeContext__WEBPACK_IMPORTED_MODULE_2__/* .NodeContext.SOP */ .sy.SOP, this.states.error);
      if (!geometryNode) {
        this.states.error.set(`node not found at path '${this.pv.geometry.path()}'`);
        return;
      }
      const container = yield geometryNode.compute();
      const coreGroup = container.coreContent();
      const objects = coreGroup == null ? void 0 : coreGroup.threejsObjects();
      if (!(coreGroup && objects && objects.length)) {
        this.states.error.set(`no objects found`);
        return;
      }
      let objectWithGeo;
      for (const object of objects) {
        if (object.geometry) {
          objectWithGeo = objectWithGeo || object;
        }
      }
      if (!objectWithGeo) {
        for (const object of objects) {
          object.traverse((childObject) => {
            if (childObject.geometry) {
              objectWithGeo = objectWithGeo || childObject;
            }
          });
        }
      }
      if (!objectWithGeo) {
        this.states.error.set(`no object found with a geometry`);
        return;
      }
      const geometry = objectWithGeo.geometry;
      if (!geometry) {
        this.states.error.set(`no geometry found`);
        return;
      }
      let boundsTree = geometry.boundsTree;
      if (!boundsTree) {
        _core_geometry_bvh_ThreeMeshBVHHelper__WEBPACK_IMPORTED_MODULE_5__/* .ThreeMeshBVHHelper.assignDefaultBVHIfNone */ .h.assignDefaultBVHIfNone(objectWithGeo);
        boundsTree = geometry.boundsTree;
      }
      coreGroup.boundingBox(_bbox);
      const _updateResolution = () => {
        _bbox.getSize(_bboxSize);
        _resolution.copy(_bboxSize).divideScalar(this.pv.voxelSize);
        _resolution.x = Math.ceil(_resolution.x * 0.5) * 2;
        _resolution.y = Math.ceil(_resolution.y * 0.5) * 2;
        _resolution.z = Math.ceil(_resolution.z * 0.5) * 2;
        _voxelSizes.copy(_bboxSize).divide(_resolution);
      };
      _updateResolution();
      _padding.copy(_voxelSizes).multiplyScalar(this.pv.padding);
      _bbox.expandByVector(_padding);
      _updateResolution();
      this.scene().batchUpdates(() => {
        this.p.boundMin.set(_bbox.min);
        this.p.boundMax.set(_bbox.max);
        this.p.resolution.set(_resolution);
      });
      const timeStart = performance.now();
      objectWithGeo.updateMatrixWorld(true);
      objectWorldMat.copy(objectWithGeo.matrixWorld);
      objectWorldMatInverse.copy(objectWithGeo.matrixWorld).invert();
      objectWorldMatInverse.decompose(t, q, s);
      this.createTextureTargetIfRequired(_resolution);
      const texture = this._fillTexture(objectWithGeo, {
        resolution: _resolution,
        bbox: _bbox,
        bboxSize: _bboxSize,
        voxelSizes: _voxelSizes
      });
      const totalTime = performance.now() - timeStart;
      console.log("SDF generation time", totalTime);
      if (texture) {
        this.setTexture(texture);
      } else {
        this.cookController.endCook();
      }
    });
  }
  /*
   *
   * FILL TEXTURE
   *
   */
  _fillTexture(object, options) {
    const { resolution, bbox, bboxSize, voxelSizes } = options;
    const boundsTree = object.geometry.boundsTree;
    const texture = this._dataTexture(resolution);
    const data = texture.image.data;
    const pos = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();
    const distanceResult = {
      point: new three__WEBPACK_IMPORTED_MODULE_0__.Vector3(),
      distance: -1,
      faceIndex: -1
    };
    const resx = resolution.x;
    const resy = resolution.y;
    const resz = resolution.z;
    const minx = bbox.min.x + voxelSizes.x * 0.5;
    const miny = bbox.min.y + voxelSizes.y * 0.5;
    const minz = bbox.min.z + voxelSizes.z * 0.5;
    const sizex = bboxSize.x;
    const sizey = bboxSize.y;
    const sizez = bboxSize.z;
    let i = 0;
    for (let z = 0; z < resz; z++) {
      for (let y = 0; y < resy; y++) {
        for (let x = 0; x < resx; x++) {
          pos.x = x / resx * sizex + minx;
          pos.y = y / resy * sizey + miny;
          pos.z = z / resz * sizez + minz;
          boundsTree.closestPointToPoint(pos, distanceResult);
          _rayDir.copy(distanceResult.point).sub(pos);
          _ray.origin.copy(pos);
          const res = boundsTree.raycastFirst(_ray, three__WEBPACK_IMPORTED_MODULE_0__.DoubleSide);
          const inside = res && res.face && res.face.normal.dot(_ray.direction) > 0;
          const d = distanceResult.distance;
          data[i] = inside ? -d : d;
          i++;
        }
      }
    }
    (0,_core_loader_geometry_SDF__WEBPACK_IMPORTED_MODULE_6__/* .addSDFMetadataToContainer */ .j1)(texture, {
      boundMin: bbox.min,
      boundMax: bbox.max,
      resolution
    });
    return texture;
  }
  _dataTexture(resolution) {
    return this.__dataTexture = this.__dataTexture || this._createTexture(resolution);
  }
  createTextureTargetIfRequired(resolution) {
    if (!this.__dataTexture || !this._textureResolutionValid(resolution)) {
      this.__dataTexture = this._createTexture(resolution);
      this._resolutionUsed.copy(resolution);
    }
  }
  _textureResolutionValid(resolution) {
    if (this.__dataTexture) {
      return resolution.equals(this._resolutionUsed);
    } else {
      return false;
    }
  }
  _createTexture(resolution) {
    return (0,_core_loader_geometry_SDF__WEBPACK_IMPORTED_MODULE_6__/* .createSDFTexture */ .uM)(resolution.x, resolution.y, resolution.z);
  }
  /*
   *
   * CALLBACK
   *
   */
  // static PARAM_CALLBACK_render(node: SDFFromObjectCopNode) {
  // 	node.setDirty();
  // }
}


/***/ }),

/***/ 37346:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "C": function() { return /* binding */ WebCamCopNode; }
/* harmony export */ });
/* unused harmony export WebCamCopParamConfig */
/* harmony import */ var _Base__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(65276);
/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(21410);
/* harmony import */ var _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(96949);
/* harmony import */ var _utils_TextureParamsController__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(20400);
/* harmony import */ var _poly_InputCloneMode__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(56752);
/* harmony import */ var _poly_registers_nodes_types_Cop__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(12764);

var __async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};






var WebCamFacingMode = /* @__PURE__ */ ((WebCamFacingMode2) => {
  WebCamFacingMode2["USER"] = "user";
  WebCamFacingMode2["ENVIRONMENT"] = "environment";
  return WebCamFacingMode2;
})(WebCamFacingMode || {});
const WEBCAM_FACING_MODES = ["user" /* USER */, "environment" /* ENVIRONMENT */];
let videoCount = 0;
let streamCount = 0;
let canPlayCount = 0;
function WebCamCopParamConfig(Base) {
  return class Mixin extends Base {
    constructor() {
      super(...arguments);
      /** @param texture resolution */
      this.res = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_0__/* .ParamConfig.VECTOR2 */ .XC.VECTOR2([1024, 1024]);
      /** @param facingMode (on a mobile device, 'user' is the front camera, 'environment' is the back one ) */
      this.facingMode = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_0__/* .ParamConfig.INTEGER */ .XC.INTEGER(WEBCAM_FACING_MODES.indexOf("user" /* USER */), {
        menu: {
          entries: WEBCAM_FACING_MODES.map((name, value) => ({ name, value }))
        }
      });
    }
  };
}
class WebCamCopParamsConfig extends (0,_utils_TextureParamsController__WEBPACK_IMPORTED_MODULE_1__/* .TextureParamConfig */ .h)(WebCamCopParamConfig(_utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_0__/* .NodeParamsConfig */ .yI), {
  tcolorSpace: true,
  colorSpace: three__WEBPACK_IMPORTED_MODULE_2__.SRGBColorSpace
}) {
}
const ParamsConfig = new WebCamCopParamsConfig();
class WebCamCopNode extends _Base__WEBPACK_IMPORTED_MODULE_3__/* .TypedCopNode */ .z {
  constructor() {
    super(...arguments);
    this.paramsConfig = ParamsConfig;
    this.textureParamsController = new _utils_TextureParamsController__WEBPACK_IMPORTED_MODULE_1__/* .TextureParamsController */ .V(this);
  }
  static type() {
    return _poly_registers_nodes_types_Cop__WEBPACK_IMPORTED_MODULE_4__/* .CopType.WEB_CAM */ .y.WEB_CAM;
  }
  HTMLVideoElement() {
    return this._video;
  }
  initializeNode() {
    this.io.inputs.setCount(0, 1);
    this.io.inputs.initInputsClonedState(_poly_InputCloneMode__WEBPACK_IMPORTED_MODULE_5__/* .InputCloneMode.NEVER */ .m.NEVER);
  }
  dispose() {
    super.dispose();
    this._cancelWebcamRequest();
  }
  setFacingMode(facingMode) {
    this.p.facingMode.set(WEBCAM_FACING_MODES.indexOf(facingMode));
  }
  _cancelWebcamRequest() {
    try {
      if (this._stream) {
        this._stream.getTracks().forEach((track) => track.stop());
      }
    } catch (err) {
      console.error(err);
      console.warn(`failed to cancel webcam request`);
    }
  }
  _createHTMLVideoElement(width, height) {
    const element = document.createElement("video");
    element.width = width;
    element.height = height;
    element.autoplay = true;
    element.setAttribute("autoplay", "true");
    element.setAttribute("muted", "true");
    element.setAttribute("playsinline", "true");
    return element;
  }
  cook(inputContents) {
    return __async(this, null, function* () {
      const inputTexture = inputContents[0];
      const result = yield this._streamToTexture(inputTexture, false);
      if (result && result.dimensionsSwapRequired) {
        yield this._streamToTexture(inputTexture, true);
      }
    });
  }
  _streamToTexture(inputTexture, swapDimensions) {
    return __async(this, null, function* () {
      const x = swapDimensions ? this.pv.res.y : this.pv.res.x;
      const y = swapDimensions ? this.pv.res.x : this.pv.res.y;
      const width = x;
      const height = y;
      if (width <= 0 || height <= 0) {
        this.states.error.set(`invalid resolution ${width}x${height}`);
        return;
      }
      const _checkDimensionsValid = () => {
        return width == x && height == y;
      };
      const setErrorFromInvalidDimensions = () => {
        this.states.error.set(`recompute needed ${width}x${height} is not ${x}x${y}`);
      };
      const videoElement = this._createHTMLVideoElement(width, height);
      videoCount++;
      const texture = new three__WEBPACK_IMPORTED_MODULE_2__.VideoTexture(videoElement);
      if (inputTexture) {
        _utils_TextureParamsController__WEBPACK_IMPORTED_MODULE_1__/* .TextureParamsController.copyTextureAttributes */ .V.copyTextureAttributes(texture, inputTexture);
      }
      yield this.textureParamsController.update(texture);
      if (!_checkDimensionsValid()) {
        setErrorFromInvalidDimensions();
        return;
      }
      return new Promise((resolve) => {
        if (navigator && navigator.mediaDevices && navigator.mediaDevices.getUserMedia) {
          const facingMode = WEBCAM_FACING_MODES[this.pv.facingMode];
          const constraints = {
            video: {
              width,
              height,
              aspectRatio: width / height,
              facingMode
            },
            audio: false
          };
          this._cancelWebcamRequest();
          navigator.mediaDevices.getUserMedia(constraints).then((stream) => {
            if (!_checkDimensionsValid()) {
              setErrorFromInvalidDimensions();
              return;
            }
            this._stream = stream;
            streamCount++;
            let _onCanPlayProcessed = false;
            videoElement.oncanplay = () => {
              if (_onCanPlayProcessed) {
                return;
              }
              _onCanPlayProcessed = true;
              canPlayCount++;
              if (!_checkDimensionsValid()) {
                setErrorFromInvalidDimensions();
                return;
              }
              this._video = videoElement;
              const dimensionsMatchWithoutSwap = Math.round(videoElement.videoWidth) == Math.round(width) && Math.round(videoElement.videoHeight) == Math.round(height);
              if (swapDimensions || dimensionsMatchWithoutSwap) {
                this.setTexture(texture);
              } else {
                resolve({ dimensionsSwapRequired: true });
              }
            };
            videoElement.onerror = (err) => {
              this.states.error.set(`webcam video error: ${err}`);
            };
            videoElement.srcObject = stream;
            videoElement.play();
          }).catch((error) => {
            console.log(`error ${width}x${height}`, error, { constraints });
            this.states.error.set("Unable to access the camera/webcam");
          });
        } else {
          const isHttps = window.location.protocol.startsWith("https");
          if (isHttps) {
            this.states.error.set(
              "MediaDevices interface not available. Please check that your connection is secure (using https)"
            );
          } else {
            this.states.error.set("https is required to use the webcam node");
          }
        }
      });
    });
  }
}


/***/ }),

/***/ 41069:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Q": function() { return /* binding */ ParamLessBaseNetworkCopNode; },
/* harmony export */   "a": function() { return /* binding */ BaseNetworkCopNode; }
/* harmony export */ });
/* harmony import */ var _poly_NodeContext__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(52070);
/* harmony import */ var _Base__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(74386);




class ParamLessNetworkCopParamsConfig extends (/* unused pure expression or super */ null && (NodeParamsConfig)) {
}
class BaseNetworkCopNode extends _Base__WEBPACK_IMPORTED_MODULE_0__/* .TypedNode */ .Mv {
  static context() {
    return _poly_NodeContext__WEBPACK_IMPORTED_MODULE_1__/* .NodeContext.COP */ .sy.COP;
  }
  cook() {
    this.cookController.endCook();
  }
}
class ParamLessBaseNetworkCopNode extends BaseNetworkCopNode {
}


/***/ }),

/***/ 43306:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "U": function() { return /* binding */ handleCopBuilderDependencies; }
/* harmony export */ });

function handleCopBuilderDependencies(options) {
  const { node, timeDependent, uniforms } = options;
  const scene = node.scene();
  if (timeDependent) {
    if (uniforms) {
      scene.uniformsController.addTimeUniform(uniforms);
    }
    const callbackName = node.callbackName();
    if (!scene.registeredBeforeTickCallbacks().has(callbackName)) {
      scene.registerOnBeforeTick(callbackName, node.boundRenderOnTarget);
    }
  } else {
    node.removeCallbacks();
  }
}


/***/ }),

/***/ 50050:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "A": function() { return /* binding */ DataTextureControllerBufferType; },
/* harmony export */   "y": function() { return /* binding */ DataTextureController; }
/* harmony export */ });
/* harmony import */ var _core_UserAgent__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(66689);
/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(21410);
/* harmony import */ var _poly_Assert__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(68239);




var DataTextureControllerBufferType = /* @__PURE__ */ ((DataTextureControllerBufferType2) => {
  DataTextureControllerBufferType2["Uint8Array"] = "Uint8Array";
  DataTextureControllerBufferType2["Uint8ClampedArray"] = "Uint8ClampedArray";
  DataTextureControllerBufferType2["Uint16Array"] = "Uint16Array";
  DataTextureControllerBufferType2["Float32Array"] = "Float32Array";
  return DataTextureControllerBufferType2;
})(DataTextureControllerBufferType || {});
class DataTextureController {
  constructor(bufferType) {
    this.bufferType = bufferType || (_core_UserAgent__WEBPACK_IMPORTED_MODULE_0__/* .CoreUserAgent.isiOS */ .Cj.isiOS() ? "Uint16Array" /* Uint16Array */ : "Float32Array" /* Float32Array */);
  }
  fromRenderTarget(renderer, renderTarget) {
    if (!this._dataTexture || !this._sameDimensions(renderTarget.texture)) {
      this._dataTexture = this._createDataTexture(renderTarget.texture);
    }
    this._copyToDataTexture(renderer, renderTarget);
    return this._dataTexture;
  }
  // fromTexture(texture: Texture): DataTexture {
  // 	const src_data = CoreImage.data_from_image(texture.image);
  // 	if (!this._data_texture || !this._same_dimensions(texture)) {
  // 		this._data_texture = this._create_data_texture(texture);
  // 	}
  // 	const length = src_data.width * src_data.height;
  // 	const src_tex_data = src_data.data;
  // 	const dest_ext_data = this._data_texture.image.data;
  // 	const stride = 4;
  // 	const l4 = length * stride;
  // 	for (let i = 0; i < l4; i++) {
  // 		dest_ext_data[i] = src_tex_data[i];
  // 		// dest_ext_data[i + 1] = src_tex_data[i + 1];
  // 		// dest_ext_data[i + 2] = src_tex_data[i + 2];
  // 		// dest_ext_data[i + 3] = src_tex_data[i + 3];
  // 	}
  // 	return this._data_texture;
  // }
  // dataTexture() {
  // 	return this._dataTexture;
  // }
  reset() {
    this._dataTexture = void 0;
  }
  _copyToDataTexture(renderer, renderTarget) {
    const image = renderTarget.texture.image;
    this._dataTexture = this._dataTexture || this._createDataTexture(renderTarget.texture);
    renderer.readRenderTargetPixels(renderTarget, 0, 0, image.width, image.height, this._dataTexture.image.data);
    this._dataTexture.needsUpdate = true;
  }
  _createDataTexture(texture) {
    const image = texture.image;
    const pixelBuffer = this._createPixelBuffer(image.width, image.height);
    const dataTexture = new three__WEBPACK_IMPORTED_MODULE_1__.DataTexture(
      pixelBuffer,
      image.width,
      image.height,
      texture.format,
      texture.type,
      texture.mapping,
      texture.wrapS,
      texture.wrapT,
      texture.magFilter,
      texture.minFilter,
      texture.anisotropy,
      texture.colorSpace
    );
    return dataTexture;
  }
  _createPixelBuffer(width, height) {
    const size = width * height * 4;
    switch (this.bufferType) {
      case "Uint8Array" /* Uint8Array */:
        return new Uint8Array(size);
      case "Uint8ClampedArray" /* Uint8ClampedArray */:
        return new Uint8ClampedArray(size);
      case "Uint16Array" /* Uint16Array */:
        return new Uint16Array(size);
      case "Float32Array" /* Float32Array */:
        return new Float32Array(size);
    }
    _poly_Assert__WEBPACK_IMPORTED_MODULE_2__/* .TypeAssert.unreachable */ .f.unreachable(this.bufferType);
  }
  _sameDimensions(texture) {
    if (this._dataTexture) {
      const sameW = this._dataTexture.image.width == texture.image.width;
      const sameH = this._dataTexture.image.height == texture.image.height;
      return sameW && sameH;
    } else {
      return true;
    }
  }
}


/***/ }),

/***/ 91440:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "N": function() { return /* binding */ AnimationEventNode; }
/* harmony export */ });
/* unused harmony export AnimationEventOutput */
/* harmony import */ var _Base__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(79282);
/* harmony import */ var _utils_io_connections_Event__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(18162);
/* harmony import */ var _poly_NodeContext__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(52070);
/* harmony import */ var _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(96949);
/* harmony import */ var _core_Type__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(19037);
/* harmony import */ var _core_thirdParty_gsap_gsapFactory__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(73436);
/* harmony import */ var _poly_registers_modules_Common__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(26280);

var __async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};







var AnimationEventInput = /* @__PURE__ */ ((AnimationEventInput2) => {
  AnimationEventInput2["START"] = "start";
  AnimationEventInput2["STOP"] = "stop";
  AnimationEventInput2["UPDATE"] = "update";
  return AnimationEventInput2;
})(AnimationEventInput || {});
var AnimationEventOutput = /* @__PURE__ */ ((AnimationEventOutput2) => {
  AnimationEventOutput2["START"] = "start";
  AnimationEventOutput2["COMPLETE"] = "completed";
  return AnimationEventOutput2;
})(AnimationEventOutput || {});
class AnimationEventParamsConfig extends _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_0__/* .NodeParamsConfig */ .yI {
  constructor() {
    super(...arguments);
    /** @parm animation node */
    this.animation = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_0__/* .ParamConfig.NODE_PATH */ .XC.NODE_PATH("", {
      nodeSelection: { context: _poly_NodeContext__WEBPACK_IMPORTED_MODULE_1__/* .NodeContext.ANIM */ .sy.ANIM },
      dependentOnFoundNode: false
    });
    /** @parm presses to play the animation */
    this.play = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_0__/* .ParamConfig.BUTTON */ .XC.BUTTON(null, {
      callback: (node) => {
        AnimationEventNode.PARAM_CALLBACK_play(node);
      }
    });
    /** @parm presses to pause the animation */
    this.pause = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_0__/* .ParamConfig.BUTTON */ .XC.BUTTON(null, {
      callback: (node) => {
        AnimationEventNode.PARAM_CALLBACK_pause(node);
      }
    });
    /** @param stops previous animations still in progress started by this node */
    this.stopsPreviousAnim = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_0__/* .ParamConfig.BOOLEAN */ .XC.BOOLEAN(1);
  }
}
const ParamsConfig = new AnimationEventParamsConfig();
class AnimationEventNode extends _Base__WEBPACK_IMPORTED_MODULE_2__/* .TypedEventNode */ .F {
  constructor() {
    super(...arguments);
    this.paramsConfig = ParamsConfig;
  }
  static type() {
    return "animation";
  }
  requiredModules() {
    return [_poly_registers_modules_Common__WEBPACK_IMPORTED_MODULE_3__/* .ModuleName.GSAP */ .r.GSAP];
  }
  initializeNode() {
    this.io.inputs.setNamedInputConnectionPoints([
      new _utils_io_connections_Event__WEBPACK_IMPORTED_MODULE_4__/* .EventConnectionPoint */ .TG("start" /* START */, _utils_io_connections_Event__WEBPACK_IMPORTED_MODULE_4__/* .EventConnectionPointType.BASE */ .M$.BASE, this._play.bind(this)),
      new _utils_io_connections_Event__WEBPACK_IMPORTED_MODULE_4__/* .EventConnectionPoint */ .TG("stop" /* STOP */, _utils_io_connections_Event__WEBPACK_IMPORTED_MODULE_4__/* .EventConnectionPointType.BASE */ .M$.BASE, this._pause.bind(this))
    ]);
    this.io.outputs.setNamedOutputConnectionPoints([
      new _utils_io_connections_Event__WEBPACK_IMPORTED_MODULE_4__/* .EventConnectionPoint */ .TG("start" /* START */, _utils_io_connections_Event__WEBPACK_IMPORTED_MODULE_4__/* .EventConnectionPointType.BASE */ .M$.BASE),
      new _utils_io_connections_Event__WEBPACK_IMPORTED_MODULE_4__/* .EventConnectionPoint */ .TG("completed" /* COMPLETE */, _utils_io_connections_Event__WEBPACK_IMPORTED_MODULE_4__/* .EventConnectionPointType.BASE */ .M$.BASE)
    ]);
  }
  processEvent(event_context) {
  }
  static PARAM_CALLBACK_play(node) {
    node._play({});
  }
  static PARAM_CALLBACK_pause(node) {
    node._pause();
  }
  _play(event_context) {
    return __async(this, null, function* () {
      const param = this.p.animation;
      if (param.isDirty()) {
        yield param.compute();
      }
      const node = param.value.nodeWithContext(_poly_NodeContext__WEBPACK_IMPORTED_MODULE_1__/* .NodeContext.ANIM */ .sy.ANIM);
      if (!node) {
        return;
      }
      const container = yield node.compute();
      if (!container) {
        return;
      }
      this._timelineBuilder = container.coreContent();
      if (!this._timelineBuilder) {
        return;
      }
      if (this._timeline && (0,_core_Type__WEBPACK_IMPORTED_MODULE_5__/* .isBooleanTrue */ .bI)(this.pv.stopsPreviousAnim)) {
        this._timeline.kill();
      }
      this._timeline = (0,_core_thirdParty_gsap_gsapFactory__WEBPACK_IMPORTED_MODULE_6__/* .gsapTimeline */ .B7)();
      if (!this._timeline) {
        return;
      }
      this._timelineBuilder.populate(this._timeline, { registerproperties: true });
      this._timeline.vars.onStart = () => {
        this._triggerAnimationStarted(event_context);
      };
      this._timeline.vars.onComplete = () => {
        this._triggerAnimationCompleted(event_context);
      };
    });
  }
  _pause() {
    if (this._timeline) {
      this._timeline.pause();
    }
  }
  _triggerAnimationStarted(event_context) {
    this.dispatchEventToOutput("start" /* START */, event_context);
  }
  _triggerAnimationCompleted(event_context) {
    this.dispatchEventToOutput("completed" /* COMPLETE */, event_context);
  }
}


/***/ }),

/***/ 11942:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "G": function() { return /* binding */ BlockEventNode; }
/* harmony export */ });
/* harmony import */ var _Base__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(79282);
/* harmony import */ var _utils_io_connections_Event__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(18162);
/* harmony import */ var _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(96949);
/* harmony import */ var _core_BooleanValue__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(19037);





class BlockParamsConfig extends _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_0__/* .NodeParamsConfig */ .yI {
  constructor() {
    super(...arguments);
    /** @param toggle on to block incoming events */
    this.blocking = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_0__/* .ParamConfig.BOOLEAN */ .XC.BOOLEAN(1);
  }
}
const ParamsConfig = new BlockParamsConfig();
const _BlockEventNode = class extends _Base__WEBPACK_IMPORTED_MODULE_1__/* .TypedEventNode */ .F {
  constructor() {
    super(...arguments);
    this.paramsConfig = ParamsConfig;
  }
  static type() {
    return "block";
  }
  initializeNode() {
    this.io.inputs.setNamedInputConnectionPoints([
      new _utils_io_connections_Event__WEBPACK_IMPORTED_MODULE_2__/* .EventConnectionPoint */ .TG("in", _utils_io_connections_Event__WEBPACK_IMPORTED_MODULE_2__/* .EventConnectionPointType.BASE */ .M$.BASE, this._process_incoming_event.bind(this))
    ]);
    this.io.outputs.setNamedOutputConnectionPoints([
      new _utils_io_connections_Event__WEBPACK_IMPORTED_MODULE_2__/* .EventConnectionPoint */ .TG(_BlockEventNode.OUTPUT, _utils_io_connections_Event__WEBPACK_IMPORTED_MODULE_2__/* .EventConnectionPointType.BASE */ .M$.BASE)
    ]);
  }
  trigger_output(context) {
    this.dispatchEventToOutput(_BlockEventNode.OUTPUT, context);
  }
  _process_incoming_event(context) {
    if (!(0,_core_BooleanValue__WEBPACK_IMPORTED_MODULE_3__/* .isBooleanTrue */ .bI)(this.pv.blocking)) {
      this.trigger_output(context);
    }
  }
};
let BlockEventNode = _BlockEventNode;
BlockEventNode.OUTPUT = "output";


/***/ }),

/***/ 99546:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {


// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  "K": function() { return /* binding */ CameraMapControlsEventNode; }
});

// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/poly/NodeContext.ts
var NodeContext = __webpack_require__(52070);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/nodes/event/CameraOrbitControls.ts
var CameraOrbitControls = __webpack_require__(48141);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/node_modules/three/build/three.module.js
var three_module = __webpack_require__(21410);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/modules/core/controls/OrbitControls.js
var OrbitControls = __webpack_require__(1729);
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/modules/core/controls/MapControls.js




// MapControls performs orbiting, dollying (zooming), and panning.
// Unlike TrackballControls, it maintains the "up" direction object.up (+Y by default).
//
//    Orbit - right mouse, or left mouse + ctrl/meta/shiftKey / touch: two-finger rotate
//    Zoom - middle mouse, or mousewheel / touch: two-finger spread or squish
//    Pan - left mouse, or arrow keys / touch: one-finger move

class MapControls extends OrbitControls/* OrbitControls */.z {
	constructor(object, domElement) {
		super(object, domElement);

		this.screenSpacePanning = false; // pan orthogonal to world-space direction camera.up

		this.mouseButtons = {LEFT: three_module.MOUSE.PAN, MIDDLE: three_module.MOUSE.DOLLY, RIGHT: three_module.MOUSE.ROTATE};

		this.touches = {ONE: three_module.TOUCH.PAN, TWO: three_module.TOUCH.DOLLY_ROTATE};
	}
}



;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/event/CameraMapControls.ts




class CameraMapControlsEventNode extends CameraOrbitControls/* CameraOrbitControlsEventNode */.Oc {
  static type() {
    return NodeContext/* CameraControlsNodeType.MAP */.MN.MAP;
  }
  _createControls(camera, element) {
    return new MapControls(camera, element);
  }
}


/***/ }),

/***/ 39015:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "l": function() { return /* binding */ DragEventNode; }
/* harmony export */ });
/* harmony import */ var _utils_io_connections_Event__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(18162);
/* harmony import */ var _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(96949);
/* harmony import */ var _BaseInput__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(29045);
/* harmony import */ var _core_BooleanValue__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(19037);
/* harmony import */ var _poly_registers_nodes_types_Event__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(39902);
/* harmony import */ var _core_event_CoreEventEmitter__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(9913);
/* harmony import */ var _core_event_DragEventType__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(77429);

var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));







class DragEventParamsConfig extends _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_0__/* .NodeParamsConfig */ .yI {
  constructor() {
    super(...arguments);
    /** @param toggle on to allow any event to be listened to */
    this.active = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_0__/* .ParamConfig.BOOLEAN */ .XC.BOOLEAN(true, {
      callback: (node) => {
        DragEventNode.PARAM_CALLBACK_updateRegister(node);
      },
      separatorAfter: true
    });
    /** @param set which element triggers the event */
    this.element = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_0__/* .ParamConfig.INTEGER */ .XC.INTEGER(_core_event_CoreEventEmitter__WEBPACK_IMPORTED_MODULE_1__/* .EVENT_EMITTERS.indexOf */ .Br.indexOf(_core_event_CoreEventEmitter__WEBPACK_IMPORTED_MODULE_1__/* .CoreEventEmitter.CANVAS */ .Ok.CANVAS), __spreadProps(__spreadValues({}, _core_event_CoreEventEmitter__WEBPACK_IMPORTED_MODULE_1__/* .EVENT_EMITTER_PARAM_MENU_OPTIONS */ .lh), {
      separatorAfter: true
    }));
    /** @param toggle on to listen to dragover events */
    this.dragover = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_0__/* .ParamConfig.BOOLEAN */ .XC.BOOLEAN(1, _BaseInput__WEBPACK_IMPORTED_MODULE_2__/* .EVENT_PARAM_OPTIONS */ .F4);
    /** @param requires ctrlKey */
    this.ctrlKey = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_0__/* .ParamConfig.BOOLEAN */ .XC.BOOLEAN(0, __spreadProps(__spreadValues({}, _BaseInput__WEBPACK_IMPORTED_MODULE_2__/* .EVENT_PARAM_OPTIONS */ .F4), { separatorBefore: true }));
    /** @param requires altKey */
    this.altKey = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_0__/* .ParamConfig.BOOLEAN */ .XC.BOOLEAN(0, _BaseInput__WEBPACK_IMPORTED_MODULE_2__/* .EVENT_PARAM_OPTIONS */ .F4);
    /** @param requires shiftKey */
    this.shiftKey = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_0__/* .ParamConfig.BOOLEAN */ .XC.BOOLEAN(0, _BaseInput__WEBPACK_IMPORTED_MODULE_2__/* .EVENT_PARAM_OPTIONS */ .F4);
    /** @param requires metaKey */
    this.metaKey = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_0__/* .ParamConfig.BOOLEAN */ .XC.BOOLEAN(0, _BaseInput__WEBPACK_IMPORTED_MODULE_2__/* .EVENT_PARAM_OPTIONS */ .F4);
  }
}
const ParamsConfig = new DragEventParamsConfig();
class DragEventNode extends _BaseInput__WEBPACK_IMPORTED_MODULE_2__/* .TypedInputEventNode */ .Y5 {
  constructor() {
    super(...arguments);
    this.paramsConfig = ParamsConfig;
  }
  static type() {
    return _poly_registers_nodes_types_Event__WEBPACK_IMPORTED_MODULE_3__/* .EventInputType.DRAG */ .$.DRAG;
  }
  acceptedEventTypes() {
    return /* @__PURE__ */ new Set([..._core_event_DragEventType__WEBPACK_IMPORTED_MODULE_4__/* .ACCEPTED_DRAG_EVENT_TYPES */ .g]);
  }
  initializeNode() {
    this.io.outputs.setNamedOutputConnectionPoints(
      _core_event_DragEventType__WEBPACK_IMPORTED_MODULE_4__/* .ACCEPTED_DRAG_EVENT_TYPES.map */ .g.map((event_type) => {
        return new _utils_io_connections_Event__WEBPACK_IMPORTED_MODULE_5__/* .EventConnectionPoint */ .TG(event_type, _utils_io_connections_Event__WEBPACK_IMPORTED_MODULE_5__/* .EventConnectionPointType.DRAG */ .M$.DRAG);
      })
    );
  }
  processEvent(eventContext) {
    if (!this.pv.active) {
      return;
    }
    const event = eventContext.event;
    if (!event) {
      return;
    }
    if (event.ctrlKey != (0,_core_BooleanValue__WEBPACK_IMPORTED_MODULE_6__/* .isBooleanTrue */ .bI)(this.pv.ctrlKey)) {
      return;
    }
    if (event.shiftKey != (0,_core_BooleanValue__WEBPACK_IMPORTED_MODULE_6__/* .isBooleanTrue */ .bI)(this.pv.shiftKey)) {
      return;
    }
    if (event.altKey != (0,_core_BooleanValue__WEBPACK_IMPORTED_MODULE_6__/* .isBooleanTrue */ .bI)(this.pv.altKey)) {
      return;
    }
    if (event.metaKey != (0,_core_BooleanValue__WEBPACK_IMPORTED_MODULE_6__/* .isBooleanTrue */ .bI)(this.pv.metaKey)) {
      return;
    }
    this.dispatchEventToOutput(event.type, eventContext);
  }
}


/***/ }),

/***/ 28962:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {


// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  "a": function() { return /* binding */ FirstPersonControlsEventNode; }
});

// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/operations/sop/Capsule.ts + 1 modules
var Capsule = __webpack_require__(69291);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/nodes/event/_BaseCameraControls.ts
var _BaseCameraControls = __webpack_require__(80359);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/nodes/utils/params/ParamsConfig.ts
var ParamsConfig = __webpack_require__(96949);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/nodes/utils/io/connections/Event.ts
var Event = __webpack_require__(18162);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/node_modules/three/build/three.module.js
var three_module = __webpack_require__(21410);
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/core/player/KeyEvents.ts

function stopEvent(e) {
  e.preventDefault();
}
class CorePlayerKeyEvents {
  constructor(player) {
    this.player = player;
    this._bounds = {
      keydown: this._onKeyDown.bind(this),
      keyup: this._onKeyUp.bind(this)
    };
  }
  _onKeyDown(e) {
    if (e.ctrlKey) {
      return;
    }
    switch (e.code) {
      case "ArrowUp":
      case "KeyW":
        this.player.setForward(true);
        stopEvent(e);
        break;
      case "ArrowDown":
      case "KeyS":
        this.player.setBackward(true);
        stopEvent(e);
        break;
      case "ArrowRight":
      case "KeyD":
        this.player.setRight(true);
        stopEvent(e);
        break;
      case "ArrowLeft":
      case "KeyA":
        this.player.setLeft(true);
        stopEvent(e);
        break;
      case "Space":
        this.player.jump();
        stopEvent(e);
        break;
      case "ShiftLeft":
      case "ShiftRight":
        this.player.setRun(true);
        stopEvent(e);
        break;
    }
  }
  _onKeyUp(e) {
    switch (e.code) {
      case "ArrowUp":
      case "KeyW":
        this.player.setForward(false);
        break;
      case "ArrowDown":
      case "KeyS":
        this.player.setBackward(false);
        break;
      case "ArrowRight":
      case "KeyD":
        this.player.setRight(false);
        break;
      case "ArrowLeft":
      case "KeyA":
        this.player.setLeft(false);
        break;
      case "ShiftLeft":
      case "ShiftRight":
        this.player.setRun(false);
        stopEvent(e);
        break;
    }
  }
  addEvents() {
    document.addEventListener("keydown", this._bounds.keydown);
    document.addEventListener("keyup", this._bounds.keyup);
  }
  removeEvents() {
    document.removeEventListener("keydown", this._bounds.keydown);
    document.removeEventListener("keyup", this._bounds.keyup);
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/modules/core/controls/PointerLockControls.ts



const changeEvent = { type: "change" };
const lockEvent = { type: "lock" };
const unlockEvent = { type: "unlock" };
const PI_2 = Math.PI / 2;
const tmpCameraUnproject = new three_module.Vector3();
const spherical = new three_module.Spherical();
const LOCK_ELEMENT_DEFAULT_HTML = `
<div style="
	text-align:center;
	position: absolute;
	top: 50%;
	left: 50%;
	transform: translate(-50%,-50%);
	cursor: pointer;
	padding: 5px 10px;
	background:gray;
	border:white;
	color: white;
	">
	<div style="font-size: 1rem">CLICK TO START</div>
	<div style="font-size: 0.6rem">press ESC to show your cursor</div>
</div>
`;
class PointerLockControls extends three_module.EventDispatcher {
  constructor(camera, domElement, options, player) {
    super();
    this.camera = camera;
    this.domElement = domElement;
    this.options = options;
    this.player = player;
    this.isLocked = false;
    this.minPolarAngle = 0;
    // radians
    this.maxPolarAngle = Math.PI;
    // radians
    this.rotateSpeed = 1;
    this.euler = new three_module.Euler(0, 0, 0, "YXZ");
    this.boundMethods = {
      lock: this.lock.bind(this),
      onMouseMove: this.onMouseMove.bind(this),
      onPointerlockChange: this.onPointerlockChange.bind(this),
      onPointerlockError: this.onPointerlockError.bind(this)
    };
    this._azimuthalAngle = 0;
    this.connect();
    this._showUnlockHTMLElement();
  }
  onMouseMove(event) {
    if (this.isLocked === false)
      return;
    var movementX = event.movementX || event.mozMovementX || event.webkitMovementX || 0;
    var movementY = event.movementY || event.mozMovementY || event.webkitMovementY || 0;
    this.euler.setFromQuaternion(this.camera.quaternion);
    this.euler.y -= movementX * 2e-3 * this.rotateSpeed;
    this.euler.x -= movementY * 2e-3 * this.rotateSpeed;
    this.euler.x = Math.max(PI_2 - this.maxPolarAngle, Math.min(PI_2 - this.minPolarAngle, this.euler.x));
    this.camera.quaternion.setFromEuler(this.euler);
    this._computeAzimuthalAngle();
    this.dispatchEvent(changeEvent);
  }
  _computeAzimuthalAngle() {
    this.camera.updateMatrixWorld();
    tmpCameraUnproject.set(0, 0, 1);
    this.camera.localToWorld(tmpCameraUnproject);
    tmpCameraUnproject.sub(this.camera.position);
    spherical.setFromVector3(tmpCameraUnproject);
    this._azimuthalAngle = spherical.theta;
  }
  onPointerlockChange() {
    var _a, _b;
    if (this.domElement.ownerDocument.pointerLockElement === this.domElement) {
      this.dispatchEvent(lockEvent);
      this.isLocked = true;
      this._removeHTMLElement();
      if (this.player) {
        this._corePlayerKeyEvents = this._corePlayerKeyEvents || new CorePlayerKeyEvents(this.player);
        this._corePlayerKeyEvents.addEvents();
      }
    } else {
      this.dispatchEvent(unlockEvent);
      this.isLocked = false;
      this._showUnlockHTMLElement();
      (_a = this._corePlayerKeyEvents) == null ? void 0 : _a.removeEvents();
      (_b = this.player) == null ? void 0 : _b.stop();
    }
  }
  onPointerlockError() {
    console.error(
      "THREE.PointerLockControls: Unable to use Pointer Lock API (Note that you need to wait for 2 seconds to lock the pointer after having just unlocked it)"
    );
  }
  connect() {
    this.domElement.ownerDocument.addEventListener("mousemove", this.boundMethods.onMouseMove);
    this.domElement.ownerDocument.addEventListener("pointerlockchange", this.boundMethods.onPointerlockChange);
    this.domElement.ownerDocument.addEventListener("pointerlockerror", this.boundMethods.onPointerlockError);
  }
  disconnect() {
    this.domElement.ownerDocument.removeEventListener("mousemove", this.boundMethods.onMouseMove);
    this.domElement.ownerDocument.removeEventListener("pointerlockchange", this.boundMethods.onPointerlockChange);
    this.domElement.ownerDocument.removeEventListener("pointerlockerror", this.boundMethods.onPointerlockError);
  }
  dispose() {
    this.disconnect();
    this._removeHTMLElement();
  }
  getObject() {
    return this.camera;
  }
  lock() {
    this.domElement.requestPointerLock();
  }
  unlock() {
    this.domElement.ownerDocument.exitPointerLock();
  }
  update(delta) {
    if (this.player) {
      this.player.setAzimuthalAngle(this._azimuthalAngle);
      this.player.update(delta);
    }
  }
  _unlockHTMLElementParent() {
    return this.domElement.parentElement;
  }
  _unlockHTMLElement() {
    return this.__unlockHTMLElement = this.__unlockHTMLElement || this._getUnlockHTMLElement();
  }
  _showUnlockHTMLElement() {
    var _a;
    const el = this._unlockHTMLElement();
    if (!el) {
      return;
    }
    (_a = this._unlockHTMLElementParent()) == null ? void 0 : _a.append(el);
  }
  _getUnlockHTMLElement() {
    const element = this.options.lockHTMLElement || this._createUnlockHTMLElement();
    element.addEventListener("pointerdown", this.boundMethods.lock);
    return element;
  }
  _createUnlockHTMLElement() {
    const el = document.createElement("div");
    el.innerHTML = LOCK_ELEMENT_DEFAULT_HTML;
    return el;
  }
  _removeHTMLElement() {
    var _a;
    if (!this.__unlockHTMLElement) {
      return;
    }
    (_a = this._unlockHTMLElementParent()) == null ? void 0 : _a.removeChild(this.__unlockHTMLElement);
    this.__unlockHTMLElement.removeEventListener("pointerdown", this.boundMethods.lock);
    this.__unlockHTMLElement = void 0;
  }
}

// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/poly/NodeContext.ts
var NodeContext = __webpack_require__(52070);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/core/player/Player.ts
var Player = __webpack_require__(50260);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/core/Type.ts
var Type = __webpack_require__(19037);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/nodes/event/collision/CollisionController.ts
var CollisionController = __webpack_require__(54512);
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/event/FirstPersonControls.ts

var __defProp = Object.defineProperty;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};









const EVENT_LOCK = "lock";
const EVENT_CHANGE = "change";
const EVENT_UNLOCK = "unlock";
function updatePlayerParamsCallbackOption() {
  return {
    cook: false,
    callback: (node) => {
      FirstPersonControlsEventNode.PARAM_CALLBACK_updatePlayerParams(node);
    }
  };
}
class FirstPersonEventParamsConfig extends ParamsConfig/* NodeParamsConfig */.yI {
  constructor() {
    super(...arguments);
    this.main = ParamsConfig/* ParamConfig.FOLDER */.XC.FOLDER();
    /** @param collider object */
    this.colliderObject = ParamsConfig/* ParamConfig.NODE_PATH */.XC.NODE_PATH("", {
      nodeSelection: {
        context: NodeContext/* NodeContext.SOP */.sy.SOP
      },
      // if the node is dependent,
      // the FirstPersonControls will be re-created when this node changes
      // which we do not want, as it will act like a hard reset
      // when all we want is to update the collider
      dependentOnFoundNode: false,
      callback: (node) => {
        FirstPersonControlsEventNode.PARAM_CALLBACK_updateCollider(node);
      }
    });
    /** @param click to lock controls */
    this.lock = ParamsConfig/* ParamConfig.BUTTON */.XC.BUTTON(null, {
      callback: (node) => {
        FirstPersonControlsEventNode.PARAM_CALLBACK_lockControls(node);
      }
    });
    /** @param click to unlock controls */
    this.unlock = ParamsConfig/* ParamConfig.BUTTON */.XC.BUTTON(null, {
      callback: (node) => {
        FirstPersonControlsEventNode.PARAM_CALLBACK_unlockControls(node);
      }
    });
    /** @param collision Capsule Radius */
    this.capsuleRadius = ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(Capsule/* CapsuleSopOperation.DEFAULT_PARAMS.radius */.e.DEFAULT_PARAMS.radius, __spreadValues({
      range: [0, 1],
      rangeLocked: [true, false]
    }, updatePlayerParamsCallbackOption()));
    /** @param collision Capsule Height */
    this.capsuleHeight = ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(Capsule/* CapsuleSopOperation.DEFAULT_PARAMS.height */.e.DEFAULT_PARAMS.height, __spreadValues({
      range: [0, 2],
      rangeLocked: [true, false]
    }, updatePlayerParamsCallbackOption()));
    this.physics = ParamsConfig/* ParamConfig.FOLDER */.XC.FOLDER();
    /** @param physics Steps */
    this.physicsSteps = ParamsConfig/* ParamConfig.INTEGER */.XC.INTEGER(5, __spreadValues({
      range: [1, 10],
      rangeLocked: [true, false]
    }, updatePlayerParamsCallbackOption()));
    /** @param gravity */
    this.gravity = ParamsConfig/* ParamConfig.VECTOR3 */.XC.VECTOR3([0, -30, 0], __spreadValues({}, updatePlayerParamsCallbackOption()));
    /** @param translate speed */
    this.translateSpeed = ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(1, __spreadValues({
      range: [0, 10],
      rangeLocked: [true, false]
    }, updatePlayerParamsCallbackOption()));
    /** @param rotate speed */
    this.rotateSpeed = ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(1, {
      range: [0, 10],
      rangeLocked: [true, false]
      // ...updatePlayerParamsCallbackOption(),
    });
    /** @param jump Allowed */
    this.jumpAllowed = ParamsConfig/* ParamConfig.BOOLEAN */.XC.BOOLEAN(true, __spreadValues({}, updatePlayerParamsCallbackOption()));
    /** @param jump Force */
    this.jumpStrength = ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(10, __spreadValues({
      range: [0, 100],
      rangeLocked: [true, false],
      visibleIf: { jumpAllowed: 1 }
    }, updatePlayerParamsCallbackOption()));
    /** @param run Allowed */
    this.runAllowed = ParamsConfig/* ParamConfig.BOOLEAN */.XC.BOOLEAN(true, __spreadValues({}, updatePlayerParamsCallbackOption()));
    /** @param run speed mult */
    this.runSpeedMult = ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(2, __spreadValues({
      range: [0, 10],
      rangeLocked: [true, false],
      visibleIf: { runAllowed: 1 }
    }, updatePlayerParamsCallbackOption()));
    /** @param recompute colliding geo */
    this.updateCollider = ParamsConfig/* ParamConfig.BUTTON */.XC.BUTTON(null, {
      callback: (node) => {
        FirstPersonControlsEventNode.PARAM_CALLBACK_updateCollider(node);
      }
    });
    this.init = ParamsConfig/* ParamConfig.FOLDER */.XC.FOLDER();
    /** @param start Position */
    this.startPosition = ParamsConfig/* ParamConfig.VECTOR3 */.XC.VECTOR3([0, 2, 0], __spreadValues({}, updatePlayerParamsCallbackOption()));
    /** @param start Position */
    this.startRotation = ParamsConfig/* ParamConfig.VECTOR3 */.XC.VECTOR3([0, 0, 0], __spreadValues({}, updatePlayerParamsCallbackOption()));
    /** @param reset */
    this.reset = ParamsConfig/* ParamConfig.BUTTON */.XC.BUTTON(null, {
      callback: (node) => {
        FirstPersonControlsEventNode.PARAM_CALLBACK_resetPlayer(node);
      }
    });
    /** @param min rotation angle */
    this.minPolarAngle = ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(0, {
      range: [0, Math.PI],
      rangeLocked: [true, true]
    });
    /** @param max rotation angle */
    this.maxPolarAngle = ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT("$PI", {
      range: [0, Math.PI],
      rangeLocked: [true, true]
    });
    this.html = ParamsConfig/* ParamConfig.FOLDER */.XC.FOLDER();
    /** @param specify a custom HTML element */
    this.customLockCursorElement = ParamsConfig/* ParamConfig.BOOLEAN */.XC.BOOLEAN(false);
    /** @param jump HTML element selector */
    this.lockCursorElementSelector = ParamsConfig/* ParamConfig.STRING */.XC.STRING("#lock-cursor-element", {
      visibleIf: {
        customLockCursorElement: true
      }
    });
  }
}
const FirstPersonControls_ParamsConfig = new FirstPersonEventParamsConfig();
const _FirstPersonControlsEventNode = class extends _BaseCameraControls/* TypedCameraControlsEventNode */.l {
  constructor() {
    super(...arguments);
    this.paramsConfig = FirstPersonControls_ParamsConfig;
    this._controls_by_element_id = /* @__PURE__ */ new Map();
  }
  static type() {
    return NodeContext/* CameraControlsNodeType.FIRST_PERSON */.MN.FIRST_PERSON;
  }
  endEventName() {
    return "unlock";
  }
  collisionController() {
    return this._collisionController = this._collisionController || new CollisionController/* CollisionController */.n(this);
  }
  initializeNode() {
    this.io.inputs.setNamedInputConnectionPoints([
      new Event/* EventConnectionPoint */.TG(EVENT_LOCK, Event/* EventConnectionPointType.BASE */.M$.BASE, this.lockControls.bind(this)),
      new Event/* EventConnectionPoint */.TG(
        _FirstPersonControlsEventNode.INPUT_UPDATE_COLLIDER,
        Event/* EventConnectionPointType.BASE */.M$.BASE,
        this._updateCollider.bind(this)
      ),
      new Event/* EventConnectionPoint */.TG(
        _FirstPersonControlsEventNode.INPUT_RESET,
        Event/* EventConnectionPointType.BASE */.M$.BASE,
        this._resetPlayer.bind(this)
      )
    ]);
    this.io.outputs.setNamedOutputConnectionPoints([
      new Event/* EventConnectionPoint */.TG(EVENT_LOCK, Event/* EventConnectionPointType.BASE */.M$.BASE),
      new Event/* EventConnectionPoint */.TG(EVENT_CHANGE, Event/* EventConnectionPointType.BASE */.M$.BASE),
      new Event/* EventConnectionPoint */.TG(EVENT_UNLOCK, Event/* EventConnectionPointType.BASE */.M$.BASE)
    ]);
  }
  createControlsInstance(camera, element) {
    return __async(this, null, function* () {
      yield this._initPlayer(camera);
      const _getLockHTMLElement = () => {
        if (!this.pv.customLockCursorElement) {
          return void 0;
        }
        const element2 = document.querySelector(this.pv.lockCursorElementSelector);
        return element2;
      };
      const lockHTMLElement = _getLockHTMLElement();
      const controls = new PointerLockControls(camera, element, { lockHTMLElement }, this._player);
      this._controls_by_element_id.set(element.id, controls);
      this._bind_listeners_to_controls_instance(controls);
      return controls;
    });
  }
  _initPlayer(camera) {
    return __async(this, null, function* () {
      const options = yield this._playerOptions(camera);
      if (!options) {
        return;
      }
      this._player = this._player || new Player/* CorePlayer */.l(options);
      this._player.setOptions(options);
      this._updatePlayerParams();
      this._player.reset();
    });
  }
  _playerOptions(camera) {
    return __async(this, null, function* () {
      const collider = yield this.collisionController().getCollider();
      if (!collider) {
        this.states.error.set("invalid collider");
        return;
      }
      return { object: camera, collider };
    });
  }
  player() {
    return this._player;
  }
  _updatePlayerParams() {
    return __async(this, null, function* () {
      if (!this._player) {
        return;
      }
      this._player.startPosition.copy(this.pv.startPosition);
      this._player.startRotation.copy(this.pv.startRotation);
      this._player.physicsSteps = this.pv.physicsSteps;
      this._player.jumpAllowed = (0,Type/* isBooleanTrue */.bI)(this.pv.jumpAllowed);
      this._player.jumpStrength = this.pv.jumpStrength;
      this._player.runAllowed = (0,Type/* isBooleanTrue */.bI)(this.pv.runAllowed);
      this._player.runSpeedMult = this.pv.runSpeedMult;
      this._player.gravity.copy(this.pv.gravity);
      this._player.speed = this.pv.translateSpeed;
      this._player.setCapsule({
        radius: this.pv.capsuleRadius,
        height: this.pv.capsuleHeight,
        divisions: 5,
        center: Capsule/* CapsuleSopOperation.DEFAULT_PARAMS.center */.e.DEFAULT_PARAMS.center
      });
    });
  }
  _resetPlayer() {
    var _a;
    (_a = this._player) == null ? void 0 : _a.reset();
  }
  _updateCollider() {
    return __async(this, null, function* () {
      yield this.collisionController().updateCollider();
    });
  }
  _bind_listeners_to_controls_instance(controls) {
    controls.addEventListener(EVENT_LOCK, () => {
      this.dispatchEventToOutput(EVENT_LOCK, {});
    });
    controls.addEventListener(EVENT_CHANGE, () => {
      this.dispatchEventToOutput(EVENT_CHANGE, {});
    });
    controls.addEventListener(EVENT_UNLOCK, () => {
      this.dispatchEventToOutput(EVENT_UNLOCK, {});
    });
  }
  updateRequired() {
    return true;
  }
  setupControls(controls) {
    controls.minPolarAngle = this.pv.minPolarAngle;
    controls.maxPolarAngle = this.pv.maxPolarAngle;
    controls.rotateSpeed = this.pv.rotateSpeed;
  }
  disposeControlsForHtmlElementId(htmlElementId) {
    const controls = this._controls_by_element_id.get(htmlElementId);
    if (controls) {
      controls.dispose();
      this._controls_by_element_id.delete(htmlElementId);
    }
  }
  unlockControls() {
    const controls = this._firstControls();
    if (!controls) {
      return;
    }
    controls.unlock();
  }
  //
  //
  // LOCK
  //
  //
  lockControls() {
    const controls = this._firstControls();
    if (!controls) {
      return;
    }
    controls.lock();
  }
  _firstControls() {
    let firstControls;
    this._controls_by_element_id.forEach((controls, id) => {
      firstControls = firstControls || controls;
    });
    return firstControls;
  }
  static PARAM_CALLBACK_lockControls(node) {
    node.lockControls();
  }
  static PARAM_CALLBACK_unlockControls(node) {
    node.unlockControls();
  }
  static PARAM_CALLBACK_updateCollider(node) {
    node._updateCollider();
  }
  static PARAM_CALLBACK_updatePlayerParams(node) {
    node._updatePlayerParams();
  }
  static PARAM_CALLBACK_resetPlayer(node) {
    node._resetPlayer();
  }
};
let FirstPersonControlsEventNode = _FirstPersonControlsEventNode;
FirstPersonControlsEventNode.INPUT_UPDATE_COLLIDER = "updateCollider";
FirstPersonControlsEventNode.INPUT_RESET = "reset";


/***/ }),

/***/ 53687:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "b": function() { return /* binding */ KeyboardEventNode; }
/* harmony export */ });
/* harmony import */ var _utils_io_connections_Event__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(18162);
/* harmony import */ var _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(96949);
/* harmony import */ var _BaseInput__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(29045);
/* harmony import */ var _core_BooleanValue__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(19037);
/* harmony import */ var _core_String__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(40065);
/* harmony import */ var _poly_registers_nodes_types_Event__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(39902);
/* harmony import */ var _core_event_CoreEventEmitter__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(9913);
/* harmony import */ var _core_event_KeyboardEventType__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(21914);

var __defProp = Object.defineProperty;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};








class KeyboardEventParamsConfig extends _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_0__/* .NodeParamsConfig */ .yI {
  constructor() {
    super(...arguments);
    /** @param toggle on to allow any event to be listened to */
    this.active = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_0__/* .ParamConfig.BOOLEAN */ .XC.BOOLEAN(true, {
      callback: (node, param) => {
        KeyboardEventNode.PARAM_CALLBACK_updateRegister(node);
      },
      separatorAfter: true
    });
    /** @param set which element triggers the event */
    this.element = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_0__/* .ParamConfig.INTEGER */ .XC.INTEGER(_core_event_CoreEventEmitter__WEBPACK_IMPORTED_MODULE_1__/* .EVENT_EMITTERS.indexOf */ .Br.indexOf(_core_event_CoreEventEmitter__WEBPACK_IMPORTED_MODULE_1__/* .CoreEventEmitter.CANVAS */ .Ok.CANVAS), __spreadValues({
      menu: {
        entries: _core_event_CoreEventEmitter__WEBPACK_IMPORTED_MODULE_1__/* .EVENT_EMITTERS.map */ .Br.map((name, value) => {
          return { name, value };
        })
      },
      separatorAfter: true
    }, _BaseInput__WEBPACK_IMPORTED_MODULE_2__/* .EVENT_PARAM_OPTIONS */ .F4));
    /** @param toggle on to listen to keydown events */
    this.keydown = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_0__/* .ParamConfig.BOOLEAN */ .XC.BOOLEAN(1, _BaseInput__WEBPACK_IMPORTED_MODULE_2__/* .EVENT_PARAM_OPTIONS */ .F4);
    /** @param toggle on to listen to keypress events */
    this.keypress = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_0__/* .ParamConfig.BOOLEAN */ .XC.BOOLEAN(0, _BaseInput__WEBPACK_IMPORTED_MODULE_2__/* .EVENT_PARAM_OPTIONS */ .F4);
    /** @param toggle on to listen to keyup events */
    this.keyup = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_0__/* .ParamConfig.BOOLEAN */ .XC.BOOLEAN(0, _BaseInput__WEBPACK_IMPORTED_MODULE_2__/* .EVENT_PARAM_OPTIONS */ .F4);
    /** @param space separated list of accepted key codes. If this is empty then any key is accepted. */
    this.keyCodes = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_0__/* .ParamConfig.STRING */ .XC.STRING("Digit1 KeyE ArrowDown", _BaseInput__WEBPACK_IMPORTED_MODULE_2__/* .EVENT_PARAM_OPTIONS */ .F4);
    /** @param requires ctrlKey */
    this.ctrlKey = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_0__/* .ParamConfig.BOOLEAN */ .XC.BOOLEAN(0, _BaseInput__WEBPACK_IMPORTED_MODULE_2__/* .EVENT_PARAM_OPTIONS */ .F4);
    /** @param requires altKey */
    this.altKey = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_0__/* .ParamConfig.BOOLEAN */ .XC.BOOLEAN(0, _BaseInput__WEBPACK_IMPORTED_MODULE_2__/* .EVENT_PARAM_OPTIONS */ .F4);
    /** @param requires shiftKey */
    this.shiftKey = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_0__/* .ParamConfig.BOOLEAN */ .XC.BOOLEAN(0, _BaseInput__WEBPACK_IMPORTED_MODULE_2__/* .EVENT_PARAM_OPTIONS */ .F4);
    /** @param requires metaKey */
    this.metaKey = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_0__/* .ParamConfig.BOOLEAN */ .XC.BOOLEAN(0, _BaseInput__WEBPACK_IMPORTED_MODULE_2__/* .EVENT_PARAM_OPTIONS */ .F4);
  }
}
const ParamsConfig = new KeyboardEventParamsConfig();
class KeyboardEventNode extends _BaseInput__WEBPACK_IMPORTED_MODULE_2__/* .TypedInputEventNode */ .Y5 {
  constructor() {
    super(...arguments);
    this.paramsConfig = ParamsConfig;
  }
  static type() {
    return _poly_registers_nodes_types_Event__WEBPACK_IMPORTED_MODULE_3__/* .EventInputType.KEYBOARD */ .$.KEYBOARD;
  }
  acceptedEventTypes() {
    return /* @__PURE__ */ new Set([..._core_event_KeyboardEventType__WEBPACK_IMPORTED_MODULE_4__/* .ACCEPTED_KEYBOARD_EVENT_TYPES */ .o]);
  }
  initializeNode() {
    this.io.outputs.setNamedOutputConnectionPoints(
      _core_event_KeyboardEventType__WEBPACK_IMPORTED_MODULE_4__/* .ACCEPTED_KEYBOARD_EVENT_TYPES.map */ .o.map((event_type) => {
        return new _utils_io_connections_Event__WEBPACK_IMPORTED_MODULE_5__/* .EventConnectionPoint */ .TG(event_type, _utils_io_connections_Event__WEBPACK_IMPORTED_MODULE_5__/* .EventConnectionPointType.KEYBOARD */ .M$.KEYBOARD);
      })
    );
  }
  setElement(element) {
    this.p.element.set(_core_event_CoreEventEmitter__WEBPACK_IMPORTED_MODULE_1__/* .EVENT_EMITTERS.indexOf */ .Br.indexOf(element));
  }
  processEvent(eventContext) {
    if (!this.pv.active) {
      return;
    }
    const event = eventContext.event;
    if (!event) {
      return;
    }
    if (event.ctrlKey != (0,_core_BooleanValue__WEBPACK_IMPORTED_MODULE_6__/* .isBooleanTrue */ .bI)(this.pv.ctrlKey)) {
      return;
    }
    if (event.shiftKey != (0,_core_BooleanValue__WEBPACK_IMPORTED_MODULE_6__/* .isBooleanTrue */ .bI)(this.pv.shiftKey)) {
      return;
    }
    if (event.altKey != (0,_core_BooleanValue__WEBPACK_IMPORTED_MODULE_6__/* .isBooleanTrue */ .bI)(this.pv.altKey)) {
      return;
    }
    if (event.metaKey != (0,_core_BooleanValue__WEBPACK_IMPORTED_MODULE_6__/* .isBooleanTrue */ .bI)(this.pv.metaKey)) {
      return;
    }
    if (!(0,_core_String__WEBPACK_IMPORTED_MODULE_7__/* .stringMatchMask */ .v$)(event.code, this.pv.keyCodes)) {
      return;
    }
    this.dispatchEventToOutput(event.type, eventContext);
  }
}


/***/ }),

/***/ 89518:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {


// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  "w": function() { return /* binding */ MobileJoystickControlsEventNode; }
});

// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/nodes/event/_BaseCameraControls.ts
var _BaseCameraControls = __webpack_require__(80359);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/nodes/utils/params/ParamsConfig.ts
var ParamsConfig = __webpack_require__(96949);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/nodes/utils/io/connections/Event.ts
var Event = __webpack_require__(18162);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/node_modules/three/build/three.module.js
var three_module = __webpack_require__(21410);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/core/math/_Module.ts
var _Module = __webpack_require__(27462);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/core/DomUtils.ts
var DomUtils = __webpack_require__(1895);
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/modules/three/examples/jsm/math/Capsule.js


class Capsule {

	constructor( start = new three_module.Vector3( 0, 0, 0 ), end = new three_module.Vector3( 0, 1, 0 ), radius = 1 ) {

		this.start = start;
		this.end = end;
		this.radius = radius;

	}

	clone() {

		return new Capsule( this.start.clone(), this.end.clone(), this.radius );

	}

	set( start, end, radius ) {

		this.start.copy( start );
		this.end.copy( end );
		this.radius = radius;

	}

	copy( capsule ) {

		this.start.copy( capsule.start );
		this.end.copy( capsule.end );
		this.radius = capsule.radius;

	}

	getCenter( target ) {

		return target.copy( this.end ).add( this.start ).multiplyScalar( 0.5 );

	}

	translate( v ) {

		this.start.add( v );
		this.end.add( v );

	}

	checkAABBAxis( p1x, p1y, p2x, p2y, minx, maxx, miny, maxy, radius ) {

		return (
			( minx - p1x < radius || minx - p2x < radius ) &&
			( p1x - maxx < radius || p2x - maxx < radius ) &&
			( miny - p1y < radius || miny - p2y < radius ) &&
			( p1y - maxy < radius || p2y - maxy < radius )
		);

	}

	intersectsBox( box ) {

		return (
			this.checkAABBAxis(
				this.start.x, this.start.y, this.end.x, this.end.y,
				box.min.x, box.max.x, box.min.y, box.max.y,
				this.radius ) &&
			this.checkAABBAxis(
				this.start.x, this.start.z, this.end.x, this.end.z,
				box.min.x, box.max.x, box.min.z, box.max.z,
				this.radius ) &&
			this.checkAABBAxis(
				this.start.y, this.start.z, this.end.y, this.end.z,
				box.min.y, box.max.y, box.min.z, box.max.z,
				this.radius )
		);

	}

}



;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/modules/three/examples/jsm/math/Octree.js




const _v1 = new three_module.Vector3();
const _v2 = new three_module.Vector3();
const _point1 = new three_module.Vector3();
const _point2 = new three_module.Vector3();
const _plane = new three_module.Plane();
const _line1 = new three_module.Line3();
const _line2 = new three_module.Line3();
const _sphere = new three_module.Sphere();
const _capsule = new Capsule();

const _temp1 = new three_module.Vector3();
const _temp2 = new three_module.Vector3();
const _temp3 = new three_module.Vector3();
const EPS = 1e-10;

function lineToLineClosestPoints( line1, line2, target1 = null, target2 = null ) {

	const r = _temp1.copy( line1.end ).sub( line1.start );
	const s = _temp2.copy( line2.end ).sub( line2.start );
	const w = _temp3.copy( line2.start ).sub( line1.start );

	const a = r.dot( s ),
		b = r.dot( r ),
		c = s.dot( s ),
		d = s.dot( w ),
		e = r.dot( w );

	let t1, t2;
	const divisor = b * c - a * a;

	if ( Math.abs( divisor ) < EPS ) {

		const d1 = - d / c;
		const d2 = ( a - d ) / c;

		if ( Math.abs( d1 - 0.5 ) < Math.abs( d2 - 0.5 ) ) {

			t1 = 0;
			t2 = d1;

		} else {

			t1 = 1;
			t2 = d2;

		}

	} else {

		t1 = ( d * a + e * c ) / divisor;
		t2 = ( t1 * a - d ) / c;

	}

	t2 = Math.max( 0, Math.min( 1, t2 ) );
	t1 = Math.max( 0, Math.min( 1, t1 ) );

	if ( target1 ) {

		target1.copy( r ).multiplyScalar( t1 ).add( line1.start );

	}

	if ( target2 ) {

		target2.copy( s ).multiplyScalar( t2 ).add( line2.start );

	}

}

class Octree {

	constructor( box ) {

		this.box = box;
		this.bounds = new three_module.Box3();

		this.subTrees = [];
		this.triangles = [];

	}

	addTriangle( triangle ) {

		this.bounds.min.x = Math.min( this.bounds.min.x, triangle.a.x, triangle.b.x, triangle.c.x );
		this.bounds.min.y = Math.min( this.bounds.min.y, triangle.a.y, triangle.b.y, triangle.c.y );
		this.bounds.min.z = Math.min( this.bounds.min.z, triangle.a.z, triangle.b.z, triangle.c.z );
		this.bounds.max.x = Math.max( this.bounds.max.x, triangle.a.x, triangle.b.x, triangle.c.x );
		this.bounds.max.y = Math.max( this.bounds.max.y, triangle.a.y, triangle.b.y, triangle.c.y );
		this.bounds.max.z = Math.max( this.bounds.max.z, triangle.a.z, triangle.b.z, triangle.c.z );

		this.triangles.push( triangle );

		return this;

	}

	calcBox() {

		this.box = this.bounds.clone();

		// offset small amount to account for regular grid
		this.box.min.x -= 0.01;
		this.box.min.y -= 0.01;
		this.box.min.z -= 0.01;

		return this;

	}

	split( level ) {

		if ( ! this.box ) return;

		const subTrees = [];
		const halfsize = _v2.copy( this.box.max ).sub( this.box.min ).multiplyScalar( 0.5 );

		for ( let x = 0; x < 2; x ++ ) {

			for ( let y = 0; y < 2; y ++ ) {

				for ( let z = 0; z < 2; z ++ ) {

					const box = new three_module.Box3();
					const v = _v1.set( x, y, z );

					box.min.copy( this.box.min ).add( v.multiply( halfsize ) );
					box.max.copy( box.min ).add( halfsize );

					subTrees.push( new Octree( box ) );

				}

			}

		}

		let triangle;

		while ( triangle = this.triangles.pop() ) {

			for ( let i = 0; i < subTrees.length; i ++ ) {

				if ( subTrees[ i ].box.intersectsTriangle( triangle ) ) {

					subTrees[ i ].triangles.push( triangle );

				}

			}

		}

		for ( let i = 0; i < subTrees.length; i ++ ) {

			const len = subTrees[ i ].triangles.length;

			if ( len > 8 && level < 16 ) {

				subTrees[ i ].split( level + 1 );

			}

			if ( len !== 0 ) {

				this.subTrees.push( subTrees[ i ] );

			}

		}

		return this;

	}

	build() {

		this.calcBox();
		this.split( 0 );

		return this;

	}

	getRayTriangles( ray, triangles ) {

		for ( let i = 0; i < this.subTrees.length; i ++ ) {

			const subTree = this.subTrees[ i ];
			if ( ! ray.intersectsBox( subTree.box ) ) continue;

			if ( subTree.triangles.length > 0 ) {

				for ( let j = 0; j < subTree.triangles.length; j ++ ) {

					if ( triangles.indexOf( subTree.triangles[ j ] ) === - 1 ) triangles.push( subTree.triangles[ j ] );

				}

			} else {

				subTree.getRayTriangles( ray, triangles );

			}

		}

		return triangles;

	}

	triangleCapsuleIntersect( capsule, triangle ) {

		triangle.getPlane( _plane );

		const d1 = _plane.distanceToPoint( capsule.start ) - capsule.radius;
		const d2 = _plane.distanceToPoint( capsule.end ) - capsule.radius;

		if ( ( d1 > 0 && d2 > 0 ) || ( d1 < - capsule.radius && d2 < - capsule.radius ) ) {

			return false;

		}

		const delta = Math.abs( d1 / ( Math.abs( d1 ) + Math.abs( d2 ) ) );
		const intersectPoint = _v1.copy( capsule.start ).lerp( capsule.end, delta );

		if ( triangle.containsPoint( intersectPoint ) ) {

			return { normal: _plane.normal.clone(), point: intersectPoint.clone(), depth: Math.abs( Math.min( d1, d2 ) ) };

		}

		const r2 = capsule.radius * capsule.radius;

		const line1 = _line1.set( capsule.start, capsule.end );

		const lines = [
			[ triangle.a, triangle.b ],
			[ triangle.b, triangle.c ],
			[ triangle.c, triangle.a ]
		];

		for ( let i = 0; i < lines.length; i ++ ) {

			const line2 = _line2.set( lines[ i ][ 0 ], lines[ i ][ 1 ] );

			lineToLineClosestPoints( line1, line2, _point1, _point2 );

			if ( _point1.distanceToSquared( _point2 ) < r2 ) {

				return {
					normal: _point1.clone().sub( _point2 ).normalize(),
					point: _point2.clone(),
					depth: capsule.radius - _point1.distanceTo( _point2 )
				};

			}

		}

		return false;

	}

	triangleSphereIntersect( sphere, triangle ) {

		triangle.getPlane( _plane );

		if ( ! sphere.intersectsPlane( _plane ) ) return false;

		const depth = Math.abs( _plane.distanceToSphere( sphere ) );
		const r2 = sphere.radius * sphere.radius - depth * depth;

		const plainPoint = _plane.projectPoint( sphere.center, _v1 );

		if ( triangle.containsPoint( sphere.center ) ) {

			return { normal: _plane.normal.clone(), point: plainPoint.clone(), depth: Math.abs( _plane.distanceToSphere( sphere ) ) };

		}

		const lines = [
			[ triangle.a, triangle.b ],
			[ triangle.b, triangle.c ],
			[ triangle.c, triangle.a ]
		];

		for ( let i = 0; i < lines.length; i ++ ) {

			_line1.set( lines[ i ][ 0 ], lines[ i ][ 1 ] );
			_line1.closestPointToPoint( plainPoint, true, _v2 );

			const d = _v2.distanceToSquared( sphere.center );

			if ( d < r2 ) {

				return { normal: sphere.center.clone().sub( _v2 ).normalize(), point: _v2.clone(), depth: sphere.radius - Math.sqrt( d ) };

			}

		}

		return false;

	}

	getSphereTriangles( sphere, triangles ) {

		for ( let i = 0; i < this.subTrees.length; i ++ ) {

			const subTree = this.subTrees[ i ];

			if ( ! sphere.intersectsBox( subTree.box ) ) continue;

			if ( subTree.triangles.length > 0 ) {

				for ( let j = 0; j < subTree.triangles.length; j ++ ) {

					if ( triangles.indexOf( subTree.triangles[ j ] ) === - 1 ) triangles.push( subTree.triangles[ j ] );

				}

			} else {

				subTree.getSphereTriangles( sphere, triangles );

			}

		}

	}

	getCapsuleTriangles( capsule, triangles ) {

		for ( let i = 0; i < this.subTrees.length; i ++ ) {

			const subTree = this.subTrees[ i ];

			if ( ! capsule.intersectsBox( subTree.box ) ) continue;

			if ( subTree.triangles.length > 0 ) {

				for ( let j = 0; j < subTree.triangles.length; j ++ ) {

					if ( triangles.indexOf( subTree.triangles[ j ] ) === - 1 ) triangles.push( subTree.triangles[ j ] );

				}

			} else {

				subTree.getCapsuleTriangles( capsule, triangles );

			}

		}

	}

	sphereIntersect( sphere ) {

		_sphere.copy( sphere );

		const triangles = [];
		let result, hit = false;

		this.getSphereTriangles( sphere, triangles );

		for ( let i = 0; i < triangles.length; i ++ ) {

			if ( result = this.triangleSphereIntersect( _sphere, triangles[ i ] ) ) {

				hit = true;

				_sphere.center.add( result.normal.multiplyScalar( result.depth ) );

			}

		}

		if ( hit ) {

			const collisionVector = _sphere.center.clone().sub( sphere.center );
			const depth = collisionVector.length();

			return { normal: collisionVector.normalize(), depth: depth };

		}

		return false;

	}

	capsuleIntersect( capsule ) {

		_capsule.copy( capsule );

		const triangles = [];
		let result, hit = false;

		this.getCapsuleTriangles( _capsule, triangles );

		for ( let i = 0; i < triangles.length; i ++ ) {

			if ( result = this.triangleCapsuleIntersect( _capsule, triangles[ i ] ) ) {

				hit = true;

				_capsule.translate( result.normal.multiplyScalar( result.depth ) );

			}

		}

		if ( hit ) {

			const collisionVector = _capsule.getCenter( new three_module.Vector3() ).sub( capsule.getCenter( _v1 ) );
			const depth = collisionVector.length();

			return { normal: collisionVector.normalize(), depth: depth };

		}

		return false;

	}

	rayIntersect( ray ) {

		if ( ray.direction.length() === 0 ) return;

		const triangles = [];
		let triangle, position, distance = 1e100;

		this.getRayTriangles( ray, triangles );

		for ( let i = 0; i < triangles.length; i ++ ) {

			const result = ray.intersectTriangle( triangles[ i ].a, triangles[ i ].b, triangles[ i ].c, true, _v1 );

			if ( result ) {

				const newdistance = result.sub( ray.origin ).length();

				if ( distance > newdistance ) {

					position = result.clone().add( ray.origin );
					distance = newdistance;
					triangle = triangles[ i ];

				}

			}

		}

		return distance < 1e100 ? { distance: distance, triangle: triangle, position: position } : false;

	}

	fromGraphNode( group ) {

		group.updateWorldMatrix( true, true );

		group.traverse( ( obj ) => {

			if ( obj.isMesh === true ) {

				let geometry, isTemp = false;

				if ( obj.geometry.index !== null ) {

					isTemp = true;
					geometry = obj.geometry.toNonIndexed();

				} else {

					geometry = obj.geometry;

				}

				const positionAttribute = geometry.getAttribute( 'position' );

				for ( let i = 0; i < positionAttribute.count; i += 3 ) {

					const v1 = new three_module.Vector3().fromBufferAttribute( positionAttribute, i );
					const v2 = new three_module.Vector3().fromBufferAttribute( positionAttribute, i + 1 );
					const v3 = new three_module.Vector3().fromBufferAttribute( positionAttribute, i + 2 );

					v1.applyMatrix4( obj.matrixWorld );
					v2.applyMatrix4( obj.matrixWorld );
					v3.applyMatrix4( obj.matrixWorld );

					this.addTriangle( new three_module.Triangle( v1, v2, v3 ) );

				}

				if ( isTemp ) {

					geometry.dispose();

				}

			}

		} );

		this.build();

		return this;

	}

	clear() {

		this.box = null;
		this.bounds.makeEmpty();

		this.subTrees.length = 0;
		this.triangles.length = 0;

		return this;

	}

}



;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/modules/core/controls/collisions/PlayerCollisionsController.ts




class PlayerCollisionController {
  constructor(_object) {
    this._object = _object;
    this._octree = new Octree();
    this._capsuleHeight = new three_module.Vector3(0, 1, 0);
    this._capsule = new Capsule(new three_module.Vector3(0, 0.35, 0), new three_module.Vector3(0, 1, 0), 0.6);
    this._octree.fromGraphNode(this._object);
  }
  setCapsule(capsule) {
    this._capsule.copy(capsule);
    this._capsuleHeight.copy(capsule.end).sub(capsule.start);
  }
  testPosition(position) {
    this._capsule.end.copy(position);
    this._capsule.start.copy(position).sub(this._capsuleHeight);
    return this._octree.capsuleIntersect(this._capsule);
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/modules/core/controls/BaseCollisionHandler.ts



class BaseCollisionHandler extends three_module.EventDispatcher {
  setCheckCollisions(collisionObject) {
    if (collisionObject) {
      let objectWithGeo;
      collisionObject.traverse((child) => {
        if (!objectWithGeo) {
          const mesh = child;
          if (mesh.geometry) {
            objectWithGeo = mesh;
          }
        }
      });
      if (objectWithGeo) {
        this._playerCollisionController = new PlayerCollisionController(objectWithGeo);
      } else {
        console.error("no geo found in", collisionObject);
      }
    } else {
      this._playerCollisionController = void 0;
    }
  }
  setCollisionCapsule(capsule) {
    var _a;
    (_a = this._playerCollisionController) == null ? void 0 : _a.setCapsule(capsule);
  }
  setJumpParams(params) {
  }
  setGravity(gravity) {
  }
  setPlayerMass(mass) {
  }
}

// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/core/Type.ts
var Type = __webpack_require__(19037);
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/modules/core/controls/MobileJoystickControls.ts






const DEFAULT_PARAMS = {
  rotateSpeed: 1,
  rotationRange: { min: -Math.PI * 0.25, max: Math.PI * 0.25 }
  // translateSpeed: 0.1,
};
const EVENT_CHANGE = { type: "change" };
const tmpCameraUnproject = new three_module.Vector3();
const spherical = new three_module.Spherical();
class MobileJoystickControls extends BaseCollisionHandler {
  constructor(_camera, domElement, options, player) {
    super();
    this._camera = _camera;
    this.domElement = domElement;
    this.options = options;
    this.player = player;
    this.translationData = {
      direction: new three_module.Vector3()
    };
    this.rotationData = {
      direction: { x: 0, y: 0 }
    };
    this._boundMethods = {
      onRotateStart: this._onRotateStart.bind(this),
      onRotateMove: this._onRotateMove.bind(this),
      onRotateEnd: this._onRotateEnd.bind(this),
      onTranslateStart: this._onTranslateStart.bind(this),
      onTranslateMove: this._onTranslateMove.bind(this),
      onTranslateEnd: this._onTranslateEnd.bind(this),
      onJump: this._onJump.bind(this),
      onRunToggle: this._onRunToggle.bind(this)
    };
    this._startCameraRotation = new three_module.Euler();
    // private _velocity = new Vector3();
    // private _element: HTMLElement;
    // private _translationSpeed = 4;
    this._rotationSpeed = DEFAULT_PARAMS.rotateSpeed;
    this._rotationRange = {
      min: DEFAULT_PARAMS.rotationRange.min,
      max: DEFAULT_PARAMS.rotationRange.max
    };
    // private _translationSpeed = DEFAULT_PARAMS.translateSpeed;
    this._azimuthalAngle = 0;
    // setTranslationSpeed(speed: number) {
    // 	this._translationSpeed = speed;
    // }
    //
    //
    // ROTATE
    //
    //
    this.vLeft = new three_module.Vector3();
    this.vRight = new three_module.Vector3();
    this.vTop = new three_module.Vector3();
    this.vBottom = new three_module.Vector3();
    this.angleY = 0;
    this.angleX = 0;
    this._rotationStartPosition = new three_module.Vector2();
    this._rotationMovePosition = new three_module.Vector2();
    this._rotationDelta = new three_module.Vector2();
    //
    //
    // TRANSLATE
    //
    //
    this._startCameraPosition = new three_module.Vector3();
    this._translationStartPosition = new three_module.Vector2();
    this._translationMovePosition = new three_module.Vector2();
    this._translationDelta = new three_module.Vector2();
    this._camera.rotation.order = "ZYX";
    this._translateDomElement = this.options.translateDomElement || this._createTranslateDomElement();
    this._runDomElement = this.options.runDomElement || this._createRunDomElement();
    this._jumpDomElement = this.options.jumpDomElement || this._createJumpDomElement();
    this._translateDomElementRect = this._translateDomElement.getBoundingClientRect();
    this._addElements();
    this._addEvents();
  }
  dispose() {
    this._removeEvents();
    this._removeElements();
    this.updateElements();
  }
  _createTranslateDomElement() {
    const rect = this.domElement.getBoundingClientRect();
    const minDim = Math.min(rect.width, rect.height);
    const size = Math.round(0.4 * minDim);
    const margin = Math.round(0.1 * minDim);
    const element = document.createElement("div");
    element.id = "MobileJoystickControls-translate";
    element.style.width = `${size}px`;
    element.style.height = element.style.width;
    element.style.border = "1px solid black";
    element.style.borderRadius = `${size}px`;
    element.style.position = "absolute";
    element.style.bottom = `${margin}px`;
    element.style.left = `${margin}px`;
    return element;
  }
  _jumpDomElementSize() {
    const rect = this.domElement.getBoundingClientRect();
    const minDim = Math.min(rect.width, rect.height);
    const size = Math.round(0.2 * minDim);
    const margin = Math.round(0.05 * minDim);
    return { size, margin };
  }
  _createJumpDomElement() {
    const { size, margin } = this._jumpDomElementSize();
    const element = document.createElement("div");
    element.id = "MobileJoystickControls-jump";
    element.style.width = `${size}px`;
    const height = Math.floor(size);
    element.style.height = `${height}px`;
    element.style.border = "1px solid black";
    element.style.position = "absolute";
    element.style.bottom = `${2 * margin + parseInt(this._runDomElement.style.height)}px`;
    element.style.right = `${margin}px`;
    element.style.borderRadius = `${height}px`;
    return element;
  }
  _createRunDomElement() {
    const element = document.createElement("div");
    const rect = this.domElement.getBoundingClientRect();
    const minDim = Math.min(rect.width, rect.height);
    const size = Math.round(0.2 * minDim);
    const margin = Math.round(0.05 * minDim);
    element.id = "MobileJoystickControls-run";
    element.style.width = `${size}px`;
    element.style.height = `${Math.floor(size)}px`;
    element.style.border = "1px solid black";
    element.style.position = "absolute";
    element.style.bottom = `${margin}px`;
    element.style.right = `${margin}px`;
    return element;
  }
  _addElements() {
    var _a, _b, _c;
    (_a = this.domElement.parentElement) == null ? void 0 : _a.append(this._translateDomElement);
    (_b = this.domElement.parentElement) == null ? void 0 : _b.append(this._jumpDomElement);
    (_c = this.domElement.parentElement) == null ? void 0 : _c.append(this._runDomElement);
  }
  _removeElements() {
    function _removeElement(element) {
      var _a;
      (_a = element.parentElement) == null ? void 0 : _a.removeChild(element);
    }
    if (!this.options.translateDomElement) {
      _removeElement(this._translateDomElement);
    }
    if (!this.options.runDomElement) {
      _removeElement(this._runDomElement);
    }
    if (!this.options.jumpDomElement) {
      _removeElement(this._jumpDomElement);
    }
  }
  updateElements() {
    if (!this.player) {
      return;
    }
    this._jumpDomElement.style.display = (0,Type/* isBooleanTrue */.bI)(this.player.jumpAllowed) ? "block" : "none";
    this._runDomElement.style.display = (0,Type/* isBooleanTrue */.bI)(this.player.runAllowed) ? "block" : "none";
  }
  _addEvents() {
    DomUtils/* CoreDomUtils.disableContextMenu */.O.disableContextMenu();
    this.domElement.addEventListener("touchstart", this._boundMethods.onRotateStart);
    this.domElement.addEventListener("touchmove", this._boundMethods.onRotateMove);
    this.domElement.addEventListener("touchend", this._boundMethods.onRotateEnd);
    this._translateDomElement.addEventListener("touchstart", this._boundMethods.onTranslateStart);
    this._translateDomElement.addEventListener("touchmove", this._boundMethods.onTranslateMove);
    this._translateDomElement.addEventListener("touchend", this._boundMethods.onTranslateEnd);
    this._jumpDomElement.addEventListener("pointerdown", this._boundMethods.onJump);
    this._runDomElement.addEventListener("pointerdown", this._boundMethods.onRunToggle);
  }
  _removeEvents() {
    DomUtils/* CoreDomUtils.reEstablishContextMenu */.O.reEstablishContextMenu();
    this.domElement.removeEventListener("touchstart", this._boundMethods.onRotateStart);
    this.domElement.removeEventListener("touchmove", this._boundMethods.onRotateMove);
    this.domElement.removeEventListener("touchend", this._boundMethods.onRotateEnd);
    this._translateDomElement.removeEventListener("touchstart", this._boundMethods.onTranslateStart);
    this._translateDomElement.removeEventListener("touchmove", this._boundMethods.onTranslateMove);
    this._translateDomElement.removeEventListener("touchend", this._boundMethods.onTranslateEnd);
    this._jumpDomElement.removeEventListener("pointerdown", this._boundMethods.onJump);
    this._runDomElement.removeEventListener("pointerdown", this._boundMethods.onRunToggle);
  }
  setRotationSpeed(speed) {
    this._rotationSpeed = speed;
  }
  setRotationRange(range) {
    this._rotationRange.min = range.min;
    this._rotationRange.max = range.max;
  }
  _onRotateStart(event) {
    this._startCameraRotation.copy(this._camera.rotation);
    const touch = this._getTouch(event, this.domElement);
    if (!touch) {
      return;
    }
    this._rotationStartPosition.set(touch.clientX, touch.clientY);
    this.vLeft.set(-1, 0, 0.5);
    this.vRight.set(1, 0, 0.5);
    [this.vLeft, this.vRight].forEach((v) => {
      v.unproject(this._camera);
      this._camera.worldToLocal(v);
    });
    this.angleY = this.vLeft.angleTo(this.vRight);
    this.vTop.set(0, 1, 0.5);
    this.vBottom.set(0, -1, 0.5);
    [this.vTop, this.vBottom].forEach((v) => {
      v.unproject(this._camera);
      this._camera.worldToLocal(v);
    });
    this.angleX = this.vTop.angleTo(this.vBottom);
  }
  _onRotateMove(event) {
    const touch = this._getTouch(event, this.domElement);
    if (!touch) {
      return;
    }
    this._rotationMovePosition.set(touch.clientX, touch.clientY);
    this._rotationDelta.copy(this._rotationMovePosition).sub(this._rotationStartPosition);
    this.rotationData.direction.x = this._rotationDelta.x / this.domElement.clientWidth;
    this.rotationData.direction.y = this._rotationDelta.y / this.domElement.clientHeight;
    this._rotateCamera(this.rotationData);
  }
  _onRotateEnd() {
    this.rotationData.direction.x = 0;
    this.rotationData.direction.y = 0;
  }
  _rotateCamera(rotationData) {
    const INVERT_Y = true;
    const INVERT_X = INVERT_Y;
    let angleY = this.angleY * rotationData.direction.x * this._rotationSpeed;
    this._camera.rotation.y = this._startCameraRotation.y + (INVERT_Y ? -angleY : angleY);
    let angleX = this.angleX * rotationData.direction.y * this._rotationSpeed;
    this._camera.rotation.x = _Module/* CoreMath.clamp */.Gj.clamp(
      this._startCameraRotation.x + (INVERT_X ? -angleX : angleX),
      this._rotationRange.min,
      this._rotationRange.max
    );
    this._computeAzimuthalAngle();
    this.dispatchEvent(EVENT_CHANGE);
  }
  _computeAzimuthalAngle() {
    this._camera.updateMatrixWorld();
    tmpCameraUnproject.set(0, 0, 1);
    this._camera.localToWorld(tmpCameraUnproject);
    tmpCameraUnproject.sub(this._camera.position);
    spherical.setFromVector3(tmpCameraUnproject);
    this._azimuthalAngle = spherical.theta;
  }
  _onTranslateStart(event) {
    this._startCameraPosition.copy(this._camera.position);
    const touch = this._getTouch(event, this._translateDomElement);
    if (!touch) {
      return;
    }
    this._translateDomElementRect = this._translateDomElement.getBoundingClientRect();
    const elementCenterX = this._translateDomElementRect.left + this._translateDomElementRect.width * 0.5;
    const elementCenterY = this._translateDomElementRect.top + this._translateDomElementRect.height * 0.5;
    this._translationStartPosition.set(elementCenterX, elementCenterY);
  }
  _onTranslateMove(event) {
    const touch = this._getTouch(event, this._translateDomElement);
    if (!touch) {
      return;
    }
    this._translationMovePosition.set(touch.clientX, touch.clientY);
    this._translationDelta.copy(this._translationMovePosition).sub(this._translationStartPosition);
    this.translationData.direction.x = this._translationDelta.x / this._translateDomElementRect.width * 0.5;
    this.translationData.direction.z = -this._translationDelta.y / this._translateDomElementRect.height * 0.5;
    this._updatePlayerTranslate();
    this.dispatchEvent(EVENT_CHANGE);
  }
  _onTranslateEnd() {
    this.translationData.direction.x = 0;
    this.translationData.direction.z = 0;
    this._updatePlayerTranslate();
  }
  _updatePlayerTranslate() {
    if (!this.player) {
      return;
    }
    const direction = this.translationData.direction;
    this.player.setForward(false);
    this.player.setBackward(false);
    this.player.setLeft(false);
    this.player.setRight(false);
    const absx = Math.abs(direction.x);
    const absz = Math.abs(direction.z);
    const delta = absz - absx;
    function checkZ(player) {
      if (direction.z > 0) {
        player.setForward(true);
      }
      if (direction.z < 0) {
        player.setBackward(true);
      }
    }
    function checkX(player) {
      if (direction.x > 0) {
        player.setRight(true);
      }
      if (direction.x < 0) {
        player.setLeft(true);
      }
    }
    if (delta > 0) {
      checkZ(this.player);
      if (delta < absz * 0.5) {
        checkX(this.player);
      }
    } else {
      checkX(this.player);
      if (delta < absx * 0.5) {
        checkZ(this.player);
      }
    }
  }
  _onJump() {
    var _a;
    (_a = this.player) == null ? void 0 : _a.jump();
  }
  _onRunToggle() {
    if (!this.player) {
      return;
    }
    const runState = this.player.running();
    this.player.setRun(!runState);
    const borderSize = this.player.running() ? 3 : 1;
    this._runDomElement.style.border = `${borderSize}px solid black`;
  }
  update(delta) {
    if (this.player) {
      this.player.setAzimuthalAngle(this._azimuthalAngle);
      this.player.update(delta);
    }
  }
  // private _camTmpPost = new Vector3();
  // private _camWorldDir = new Vector3();
  // private _up = new Vector3(0, 1, 0);
  // private _camSideVector = new Vector3();
  // private _translateCamera(data: TranslationData, deltaTime: number) {
  // 	this._camera.getWorldDirection(this._camWorldDir);
  // 	this._camWorldDir.y = 0;
  // 	this._camWorldDir.normalize();
  // 	this._camSideVector.crossVectors(this._up, this._camWorldDir);
  // 	this._camSideVector.normalize();
  // 	this._camSideVector.multiplyScalar(-data.direction.x);
  // 	this._camWorldDir.multiplyScalar(data.direction.y);
  // 	this._velocity.copy(this._camWorldDir);
  // 	this._velocity.add(this._camSideVector);
  // 	const initialHeight = this._camera.position.y;
  // 	this._camTmpPost.copy(this._camera.position);
  // 	if (this._playerCollisionController) {
  // 		// damping
  // 		const damping = 1; //Math.exp(-3 * deltaTime) - 1;
  // 		this._velocity.addScaledVector(this._velocity, damping);
  // 		const deltaPosition = this._velocity.clone().multiplyScalar(deltaTime);
  // 		this._camTmpPost.add(deltaPosition);
  // 		const result = this._playerCollisionController.testPosition(this._camTmpPost);
  // 		if (result) {
  // 			// playerCollider.translate( result.normal.multiplyScalar( result.depth ) );
  // 			this._camTmpPost.add(result.normal.multiplyScalar(result.depth));
  // 		}
  // 		this._camera.position.copy(this._camTmpPost);
  // 	} else {
  // 		this._camTmpPost.add(this._camSideVector);
  // 		this._camTmpPost.add(this._camWorldDir);
  // 		this._camera.position.copy(this._camTmpPost);
  // 	}
  // 	// ensure that the camera never changes y.
  // 	this._camera.position.y = initialHeight;
  // }
  //
  //
  // UTILS
  //
  //
  _getTouch(event, element) {
    for (let i = 0; i < event.touches.length; i++) {
      const touch = event.touches[i];
      if (touch.target === element) {
        return touch;
      }
    }
  }
}

// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/poly/NodeContext.ts
var NodeContext = __webpack_require__(52070);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/core/player/Player.ts
var Player = __webpack_require__(50260);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/nodes/event/collision/CollisionController.ts
var CollisionController = __webpack_require__(54512);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/operations/sop/Capsule.ts + 1 modules
var sop_Capsule = __webpack_require__(69291);
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/event/MobileJoystickControls.ts

var __defProp = Object.defineProperty;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};









const EVENT_START = "start";
const MobileJoystickControls_EVENT_CHANGE = "change";
const EVENT_END = "end";
function updatePlayerParamsCallbackOption() {
  return {
    cook: false,
    callback: (node) => {
      MobileJoystickControlsEventNode.PARAM_CALLBACK_updatePlayerParams(node);
    }
  };
}
class MobileJoystickEventParamsConfig extends ParamsConfig/* NodeParamsConfig */.yI {
  constructor() {
    super(...arguments);
    this.main = ParamsConfig/* ParamConfig.FOLDER */.XC.FOLDER();
    /** @param collider object */
    this.colliderObject = ParamsConfig/* ParamConfig.NODE_PATH */.XC.NODE_PATH("", {
      nodeSelection: {
        context: NodeContext/* NodeContext.SOP */.sy.SOP
      },
      // if the node is dependent,
      // the MobileJoystickControlsEventNode will be re-created when this node changes
      // which we do not want, as it will act like a hard reset
      // when all we want is to update the collider
      dependentOnFoundNode: false,
      callback: (node) => {
        MobileJoystickControlsEventNode.PARAM_CALLBACK_updateCollider(node);
      }
    });
    /** @param collision Capsule Radius */
    this.capsuleRadius = ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(sop_Capsule/* CapsuleSopOperation.DEFAULT_PARAMS.radius */.e.DEFAULT_PARAMS.radius, __spreadValues({
      range: [0, 1],
      rangeLocked: [true, false]
    }, updatePlayerParamsCallbackOption()));
    /** @param collision Capsule Height */
    this.capsuleHeight = ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(sop_Capsule/* CapsuleSopOperation.DEFAULT_PARAMS.height */.e.DEFAULT_PARAMS.height, __spreadValues({
      range: [0, 2],
      rangeLocked: [true, false]
    }, updatePlayerParamsCallbackOption()));
    this.physics = ParamsConfig/* ParamConfig.FOLDER */.XC.FOLDER();
    /** @param physics Steps */
    this.physicsSteps = ParamsConfig/* ParamConfig.INTEGER */.XC.INTEGER(5, __spreadValues({
      range: [1, 10],
      rangeLocked: [true, false]
    }, updatePlayerParamsCallbackOption()));
    /** @param gravity */
    this.gravity = ParamsConfig/* ParamConfig.VECTOR3 */.XC.VECTOR3([0, -30, 0], __spreadValues({}, updatePlayerParamsCallbackOption()));
    /** @param translation speed */
    this.translateSpeed = ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(1);
    /** @param rotation speed */
    this.rotateSpeed = ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(DEFAULT_PARAMS.rotateSpeed);
    /** @param specify a custom HTML element */
    this.customTranslateElement = ParamsConfig/* ParamConfig.BOOLEAN */.XC.BOOLEAN(false, {
      separatorBefore: true
    });
    /** @param jump HTML element selector */
    this.translateElementSelector = ParamsConfig/* ParamConfig.STRING */.XC.STRING("#translate-element", {
      visibleIf: {
        customTranslateElement: true
      }
    });
    /** @param jump Allowed */
    this.jumpAllowed = ParamsConfig/* ParamConfig.BOOLEAN */.XC.BOOLEAN(true, __spreadValues({
      separatorBefore: true
    }, updatePlayerParamsCallbackOption()));
    /** @param jump Force */
    this.jumpStrength = ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(10, __spreadValues({
      range: [0, 100],
      rangeLocked: [true, false]
    }, updatePlayerParamsCallbackOption()));
    /** @param specify a custom HTML element */
    this.customJumpElement = ParamsConfig/* ParamConfig.BOOLEAN */.XC.BOOLEAN(false, {
      visibleIf: {
        jumpAllowed: true
      }
    });
    /** @param jump HTML element selector */
    this.jumpElementSelector = ParamsConfig/* ParamConfig.STRING */.XC.STRING("#jump-element", {
      visibleIf: {
        jumpAllowed: true,
        customJumpElement: true
      }
    });
    /** @param run Allowed */
    this.runAllowed = ParamsConfig/* ParamConfig.BOOLEAN */.XC.BOOLEAN(true, __spreadValues({
      separatorBefore: true
    }, updatePlayerParamsCallbackOption()));
    /** @param run speed mult */
    this.runSpeedMult = ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(2, __spreadValues({
      range: [0, 10],
      rangeLocked: [true, false]
    }, updatePlayerParamsCallbackOption()));
    /** @param specify a custom HTML element */
    this.customRunElement = ParamsConfig/* ParamConfig.BOOLEAN */.XC.BOOLEAN(false, {
      visibleIf: {
        runAllowed: true
      }
    });
    /** @param jump HTML element selector */
    this.runElementSelector = ParamsConfig/* ParamConfig.STRING */.XC.STRING("#run-element", {
      visibleIf: {
        runAllowed: true,
        customRunElement: true
      }
    });
    /** @param recompute colliding geo */
    this.updateCollider = ParamsConfig/* ParamConfig.BUTTON */.XC.BUTTON(null, {
      separatorBefore: true,
      callback: (node) => {
        MobileJoystickControlsEventNode.PARAM_CALLBACK_updateCollider(node);
      }
    });
    this.init = ParamsConfig/* ParamConfig.FOLDER */.XC.FOLDER();
    /** @param start Position */
    this.startPosition = ParamsConfig/* ParamConfig.VECTOR3 */.XC.VECTOR3([0, 2, 0], __spreadValues({}, updatePlayerParamsCallbackOption()));
    /** @param start Position */
    this.startRotation = ParamsConfig/* ParamConfig.VECTOR3 */.XC.VECTOR3([0, 0, 0], __spreadValues({}, updatePlayerParamsCallbackOption()));
    /** @param reset */
    this.reset = ParamsConfig/* ParamConfig.BUTTON */.XC.BUTTON(null, {
      callback: (node) => {
        MobileJoystickControlsEventNode.PARAM_CALLBACK_resetPlayer(node);
      }
    });
    /** @param min polar angle */
    this.minPolarAngle = ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT("-$PI*0.5", {
      range: [-Math.PI, Math.PI],
      rangeLocked: [true, true]
    });
    /** @param max polar angle */
    this.maxPolarAngle = ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT("$PI*0.5", {
      range: [-Math.PI, Math.PI],
      rangeLocked: [true, true]
    });
  }
}
const MobileJoystickControls_ParamsConfig = new MobileJoystickEventParamsConfig();
const _MobileJoystickControlsEventNode = class extends _BaseCameraControls/* TypedCameraControlsEventNode */.l {
  constructor() {
    super(...arguments);
    this.paramsConfig = MobileJoystickControls_ParamsConfig;
    this._controls_by_element_id = /* @__PURE__ */ new Map();
  }
  static type() {
    return NodeContext/* CameraControlsNodeType.MOBILE_JOYSTICK */.MN.MOBILE_JOYSTICK;
  }
  endEventName() {
    return "end";
  }
  collisionController() {
    return this._collisionController = this._collisionController || new CollisionController/* CollisionController */.n(this);
  }
  initializeNode() {
    this.io.inputs.setNamedInputConnectionPoints([
      new Event/* EventConnectionPoint */.TG(
        _MobileJoystickControlsEventNode.INPUT_UPDATE_COLLIDER,
        Event/* EventConnectionPointType.BASE */.M$.BASE,
        this._updateCollider.bind(this)
      )
    ]);
    this.io.outputs.setNamedOutputConnectionPoints([
      new Event/* EventConnectionPoint */.TG(EVENT_START, Event/* EventConnectionPointType.BASE */.M$.BASE),
      new Event/* EventConnectionPoint */.TG(MobileJoystickControls_EVENT_CHANGE, Event/* EventConnectionPointType.BASE */.M$.BASE),
      new Event/* EventConnectionPoint */.TG(EVENT_END, Event/* EventConnectionPointType.BASE */.M$.BASE)
    ]);
  }
  createControlsInstance(camera, element) {
    return __async(this, null, function* () {
      yield this._initPlayer(camera);
      function _getElement(options2) {
        if (!options2.actionAllowed) {
          return;
        }
        if (!options2.customElement) {
          return;
        }
        return document.querySelector(options2.selector) || void 0;
      }
      const translateDomElement = _getElement({
        actionAllowed: true,
        customElement: this.pv.customTranslateElement,
        selector: this.pv.translateElementSelector
      });
      const runDomElement = _getElement({
        actionAllowed: this.pv.runAllowed,
        customElement: this.pv.customRunElement,
        selector: this.pv.runElementSelector
      });
      const jumpDomElement = _getElement({
        actionAllowed: this.pv.jumpAllowed,
        customElement: this.pv.customJumpElement,
        selector: this.pv.jumpElementSelector
      });
      const options = {
        translateDomElement,
        runDomElement,
        jumpDomElement
      };
      const controls = new MobileJoystickControls(camera, element, options, this._player);
      this._controls_by_element_id.set(element.id, controls);
      this._bind_listeners_to_controls_instance(controls);
      return controls;
    });
  }
  _initPlayer(camera) {
    return __async(this, null, function* () {
      const options = yield this._playerOptions(camera);
      if (!options) {
        return;
      }
      this._player = this._player || new Player/* CorePlayer */.l(options);
      this._player.setOptions(options);
      this._updatePlayerParams();
      this._player.reset();
    });
  }
  _playerOptions(camera) {
    return __async(this, null, function* () {
      const collider = yield this.collisionController().getCollider();
      if (!collider) {
        this.states.error.set("invalid collider");
        return;
      }
      return { object: camera, collider };
    });
  }
  player() {
    return this._player;
  }
  _updatePlayerParams() {
    return __async(this, null, function* () {
      if (!this._player) {
        return;
      }
      this._player.startPosition.copy(this.pv.startPosition);
      this._player.physicsSteps = this.pv.physicsSteps;
      this._player.jumpAllowed = (0,Type/* isBooleanTrue */.bI)(this.pv.jumpAllowed);
      this._player.jumpStrength = this.pv.jumpStrength;
      this._player.runAllowed = (0,Type/* isBooleanTrue */.bI)(this.pv.runAllowed);
      this._player.runSpeedMult = this.pv.runSpeedMult;
      this._player.gravity.copy(this.pv.gravity);
      this._player.speed = this.pv.translateSpeed;
      this._player.setCapsule({
        radius: this.pv.capsuleRadius,
        height: this.pv.capsuleHeight,
        divisions: 5,
        center: sop_Capsule/* CapsuleSopOperation.DEFAULT_PARAMS.center */.e.DEFAULT_PARAMS.center
      });
      this._controls_by_element_id.forEach((controls) => controls.updateElements());
    });
  }
  _resetPlayer() {
    var _a;
    (_a = this._player) == null ? void 0 : _a.reset();
  }
  _updateCollider() {
    return __async(this, null, function* () {
      yield this.collisionController().updateCollider();
    });
  }
  _bind_listeners_to_controls_instance(controls) {
    controls.addEventListener(EVENT_START, () => {
      this.dispatchEventToOutput(EVENT_START, {});
    });
    controls.addEventListener(MobileJoystickControls_EVENT_CHANGE, () => {
      this.dispatchEventToOutput(MobileJoystickControls_EVENT_CHANGE, {});
    });
    controls.addEventListener(EVENT_END, () => {
      this.dispatchEventToOutput(EVENT_END, {});
    });
  }
  updateRequired() {
    return true;
  }
  setupControls(controls) {
    controls.setRotationSpeed(this.pv.rotateSpeed);
    controls.setRotationRange({ min: this.pv.minPolarAngle, max: this.pv.maxPolarAngle });
    controls.updateElements();
  }
  disposeControlsForHtmlElementId(html_element_id) {
    const controls = this._controls_by_element_id.get(html_element_id);
    if (controls) {
      this._controls_by_element_id.delete(html_element_id);
    }
  }
  static PARAM_CALLBACK_updateCollider(node) {
    node._updateCollider();
  }
  static PARAM_CALLBACK_updatePlayerParams(node) {
    node._updatePlayerParams();
  }
  static PARAM_CALLBACK_resetPlayer(node) {
    node._resetPlayer();
  }
};
let MobileJoystickControlsEventNode = _MobileJoystickControlsEventNode;
MobileJoystickControlsEventNode.INPUT_UPDATE_COLLIDER = "updateCollider";


/***/ }),

/***/ 61473:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "F": function() { return /* binding */ MouseEventNode; }
/* harmony export */ });
/* harmony import */ var _utils_io_connections_Event__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(18162);
/* harmony import */ var _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(96949);
/* harmony import */ var _BaseInput__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(29045);
/* harmony import */ var _core_BooleanValue__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(19037);
/* harmony import */ var _poly_registers_nodes_types_Event__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(39902);
/* harmony import */ var _core_event_CoreEventEmitter__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(9913);
/* harmony import */ var _core_event_MouseEventType__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(96370);

var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));







class MouseEventParamsConfig extends _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_0__/* .NodeParamsConfig */ .yI {
  constructor() {
    super(...arguments);
    /** @param toggle on to allow any event to be listened to */
    this.active = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_0__/* .ParamConfig.BOOLEAN */ .XC.BOOLEAN(true, {
      callback: (node) => {
        MouseEventNode.PARAM_CALLBACK_updateRegister(node);
      },
      separatorAfter: true
    });
    /** @param set which element triggers the event */
    this.element = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_0__/* .ParamConfig.INTEGER */ .XC.INTEGER(_core_event_CoreEventEmitter__WEBPACK_IMPORTED_MODULE_1__/* .EVENT_EMITTERS.indexOf */ .Br.indexOf(_core_event_CoreEventEmitter__WEBPACK_IMPORTED_MODULE_1__/* .CoreEventEmitter.CANVAS */ .Ok.CANVAS), __spreadProps(__spreadValues({}, _core_event_CoreEventEmitter__WEBPACK_IMPORTED_MODULE_1__/* .EVENT_EMITTER_PARAM_MENU_OPTIONS */ .lh), {
      separatorAfter: true
    }));
    /** @param toggle on to listen to auxclick events */
    this.auxclick = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_0__/* .ParamConfig.BOOLEAN */ .XC.BOOLEAN(0, _BaseInput__WEBPACK_IMPORTED_MODULE_2__/* .EVENT_PARAM_OPTIONS */ .F4);
    /** @param toggle on to listen to click events */
    this.click = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_0__/* .ParamConfig.BOOLEAN */ .XC.BOOLEAN(0, _BaseInput__WEBPACK_IMPORTED_MODULE_2__/* .EVENT_PARAM_OPTIONS */ .F4);
    /** @param toggle on to listen to contextmenu events */
    this.contextmenu = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_0__/* .ParamConfig.BOOLEAN */ .XC.BOOLEAN(0, _BaseInput__WEBPACK_IMPORTED_MODULE_2__/* .EVENT_PARAM_OPTIONS */ .F4);
    /** @param toggle on to listen to dblclick events */
    this.dblclick = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_0__/* .ParamConfig.BOOLEAN */ .XC.BOOLEAN(0, _BaseInput__WEBPACK_IMPORTED_MODULE_2__/* .EVENT_PARAM_OPTIONS */ .F4);
    /** @param toggle on to listen to mousedown events */
    this.mousedown = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_0__/* .ParamConfig.BOOLEAN */ .XC.BOOLEAN(1, _BaseInput__WEBPACK_IMPORTED_MODULE_2__/* .EVENT_PARAM_OPTIONS */ .F4);
    /** @param toggle on to listen to mouseenter events */
    this.mouseenter = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_0__/* .ParamConfig.BOOLEAN */ .XC.BOOLEAN(0, _BaseInput__WEBPACK_IMPORTED_MODULE_2__/* .EVENT_PARAM_OPTIONS */ .F4);
    /** @param toggle on to listen to mouseleave events */
    this.mouseleave = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_0__/* .ParamConfig.BOOLEAN */ .XC.BOOLEAN(0, _BaseInput__WEBPACK_IMPORTED_MODULE_2__/* .EVENT_PARAM_OPTIONS */ .F4);
    /** @param toggle on to listen to mousemove events */
    this.mousemove = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_0__/* .ParamConfig.BOOLEAN */ .XC.BOOLEAN(1, _BaseInput__WEBPACK_IMPORTED_MODULE_2__/* .EVENT_PARAM_OPTIONS */ .F4);
    /** @param toggle on to listen to mouseover events */
    this.mouseover = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_0__/* .ParamConfig.BOOLEAN */ .XC.BOOLEAN(0, _BaseInput__WEBPACK_IMPORTED_MODULE_2__/* .EVENT_PARAM_OPTIONS */ .F4);
    /** @param toggle on to listen to mouseout events */
    this.mouseout = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_0__/* .ParamConfig.BOOLEAN */ .XC.BOOLEAN(0, _BaseInput__WEBPACK_IMPORTED_MODULE_2__/* .EVENT_PARAM_OPTIONS */ .F4);
    /** @param toggle on to listen to mouseup events */
    this.mouseup = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_0__/* .ParamConfig.BOOLEAN */ .XC.BOOLEAN(1, _BaseInput__WEBPACK_IMPORTED_MODULE_2__/* .EVENT_PARAM_OPTIONS */ .F4);
    /** @param toggle on to listen to pointerlockchange events */
    this.pointerlockchange = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_0__/* .ParamConfig.BOOLEAN */ .XC.BOOLEAN(0, _BaseInput__WEBPACK_IMPORTED_MODULE_2__/* .EVENT_PARAM_OPTIONS */ .F4);
    /** @param toggle on to listen to pointerlockerror events */
    this.pointerlockerror = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_0__/* .ParamConfig.BOOLEAN */ .XC.BOOLEAN(0, _BaseInput__WEBPACK_IMPORTED_MODULE_2__/* .EVENT_PARAM_OPTIONS */ .F4);
    /** @param toggle on to listen to select events */
    this.select = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_0__/* .ParamConfig.BOOLEAN */ .XC.BOOLEAN(0, _BaseInput__WEBPACK_IMPORTED_MODULE_2__/* .EVENT_PARAM_OPTIONS */ .F4);
    /** @param toggle on to listen to wheel events */
    this.wheel = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_0__/* .ParamConfig.BOOLEAN */ .XC.BOOLEAN(0, _BaseInput__WEBPACK_IMPORTED_MODULE_2__/* .EVENT_PARAM_OPTIONS */ .F4);
    /** @param requires ctrlKey */
    this.ctrlKey = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_0__/* .ParamConfig.BOOLEAN */ .XC.BOOLEAN(0, __spreadProps(__spreadValues({}, _BaseInput__WEBPACK_IMPORTED_MODULE_2__/* .EVENT_PARAM_OPTIONS */ .F4), { separatorBefore: true }));
    /** @param requires altKey */
    this.altKey = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_0__/* .ParamConfig.BOOLEAN */ .XC.BOOLEAN(0, _BaseInput__WEBPACK_IMPORTED_MODULE_2__/* .EVENT_PARAM_OPTIONS */ .F4);
    /** @param requires shiftKey */
    this.shiftKey = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_0__/* .ParamConfig.BOOLEAN */ .XC.BOOLEAN(0, _BaseInput__WEBPACK_IMPORTED_MODULE_2__/* .EVENT_PARAM_OPTIONS */ .F4);
    /** @param requires metaKey */
    this.metaKey = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_0__/* .ParamConfig.BOOLEAN */ .XC.BOOLEAN(0, _BaseInput__WEBPACK_IMPORTED_MODULE_2__/* .EVENT_PARAM_OPTIONS */ .F4);
  }
}
const ParamsConfig = new MouseEventParamsConfig();
class MouseEventNode extends _BaseInput__WEBPACK_IMPORTED_MODULE_2__/* .TypedInputEventNode */ .Y5 {
  constructor() {
    super(...arguments);
    this.paramsConfig = ParamsConfig;
  }
  static type() {
    return _poly_registers_nodes_types_Event__WEBPACK_IMPORTED_MODULE_3__/* .EventInputType.MOUSE */ .$.MOUSE;
  }
  acceptedEventTypes() {
    return /* @__PURE__ */ new Set([..._core_event_MouseEventType__WEBPACK_IMPORTED_MODULE_4__/* .ACCEPTED_MOUSE_EVENT_TYPES */ .i]);
  }
  initializeNode() {
    this.io.outputs.setNamedOutputConnectionPoints(
      _core_event_MouseEventType__WEBPACK_IMPORTED_MODULE_4__/* .ACCEPTED_MOUSE_EVENT_TYPES.map */ .i.map((event_type) => {
        return new _utils_io_connections_Event__WEBPACK_IMPORTED_MODULE_5__/* .EventConnectionPoint */ .TG(event_type, _utils_io_connections_Event__WEBPACK_IMPORTED_MODULE_5__/* .EventConnectionPointType.MOUSE */ .M$.MOUSE);
      })
    );
  }
  processEvent(eventContext) {
    if (!this.pv.active) {
      return;
    }
    const event = eventContext.event;
    if (!event) {
      return;
    }
    if (event.ctrlKey != (0,_core_BooleanValue__WEBPACK_IMPORTED_MODULE_6__/* .isBooleanTrue */ .bI)(this.pv.ctrlKey)) {
      return;
    }
    if (event.shiftKey != (0,_core_BooleanValue__WEBPACK_IMPORTED_MODULE_6__/* .isBooleanTrue */ .bI)(this.pv.shiftKey)) {
      return;
    }
    if (event.altKey != (0,_core_BooleanValue__WEBPACK_IMPORTED_MODULE_6__/* .isBooleanTrue */ .bI)(this.pv.altKey)) {
      return;
    }
    if (event.metaKey != (0,_core_BooleanValue__WEBPACK_IMPORTED_MODULE_6__/* .isBooleanTrue */ .bI)(this.pv.metaKey)) {
      return;
    }
    this.dispatchEventToOutput(event.type, eventContext);
  }
}


/***/ }),

/***/ 58036:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "v": function() { return /* binding */ ParamEventNode; }
/* harmony export */ });
/* harmony import */ var _Base__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(79282);
/* harmony import */ var _utils_io_connections_Event__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(18162);
/* harmony import */ var _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(96949);
/* harmony import */ var _core_graph_CoreGraphNode__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(45516);
/* harmony import */ var _params_Ramp__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(22621);

var __async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};





function previousValueParamOptions() {
  return {
    cook: false,
    hidden: true
  };
}
class ParamEventParamsConfig extends _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_0__/* .NodeParamsConfig */ .yI {
  constructor() {
    super(...arguments);
    /** @param set to listen or stop listening to the param */
    this.active = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_0__/* .ParamConfig.BOOLEAN */ .XC.BOOLEAN(true);
    /** @param the parameter to update */
    this.param = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_0__/* .ParamConfig.PARAM_PATH */ .XC.PARAM_PATH("", {
      dependentOnFoundParam: false,
      paramSelection: true,
      computeOnDirty: true
    });
    this.boolean = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_0__/* .ParamConfig.BOOLEAN */ .XC.BOOLEAN(0, previousValueParamOptions());
    this.integer = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_0__/* .ParamConfig.INTEGER */ .XC.INTEGER(0, previousValueParamOptions());
    this.float = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_0__/* .ParamConfig.FLOAT */ .XC.FLOAT(0, previousValueParamOptions());
    this.vector2 = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_0__/* .ParamConfig.VECTOR2 */ .XC.VECTOR2([0, 0], previousValueParamOptions());
    this.vector3 = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_0__/* .ParamConfig.VECTOR3 */ .XC.VECTOR3([0, 0, 0], previousValueParamOptions());
    this.vector4 = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_0__/* .ParamConfig.VECTOR4 */ .XC.VECTOR4([0, 0, 0, 0], previousValueParamOptions());
    this.ramp = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_0__/* .ParamConfig.RAMP */ .XC.RAMP(_params_Ramp__WEBPACK_IMPORTED_MODULE_1__/* .RampParam.DEFAULT_VALUE */ .M.DEFAULT_VALUE, previousValueParamOptions());
    this.string = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_0__/* .ParamConfig.STRING */ .XC.STRING("", previousValueParamOptions());
  }
}
const ParamsConfig = new ParamEventParamsConfig();
const _ParamEventNode = class extends _Base__WEBPACK_IMPORTED_MODULE_2__/* .TypedEventNode */ .F {
  constructor() {
    super(...arguments);
    this.paramsConfig = ParamsConfig;
    this._resolvedParam = null;
    this._previousValueParam = null;
    this._onParamDirtyBound = this._onParamDirty.bind(this);
  }
  static type() {
    return "param";
  }
  initializeNode() {
    this.io.outputs.setNamedOutputConnectionPoints([
      new _utils_io_connections_Event__WEBPACK_IMPORTED_MODULE_3__/* .EventConnectionPoint */ .TG(_ParamEventNode.OUTPUT_NAME, _utils_io_connections_Event__WEBPACK_IMPORTED_MODULE_3__/* .EventConnectionPointType.BASE */ .M$.BASE)
    ]);
  }
  cook() {
    return __async(this, null, function* () {
      yield this._listenToParam();
      this.cookController.endCook();
    });
  }
  dispose() {
    super.dispose();
    this._reset();
  }
  _reset() {
    var _a;
    (_a = this.__paramCoreGraphNode__) == null ? void 0 : _a.graphRemove();
  }
  _listenToParam() {
    return __async(this, null, function* () {
      var _a;
      if (!this.p.param) {
        return;
      }
      if (this._resolvedParam) {
        (_a = this.__paramCoreGraphNode__) == null ? void 0 : _a.removeGraphInput(this._resolvedParam);
        this._previousValueParam = null;
      }
      if (this.p.param.isDirty()) {
        yield this.p.param.compute();
      }
      this._resolvedParam = this.p.param.value.param();
      if (this._resolvedParam) {
        const previousValueParams = [
          this.p.boolean,
          this.p.integer,
          this.p.float,
          this.p.vector2,
          this.p.vector3,
          this.p.vector4,
          this.p.ramp,
          this.p.string
        ];
        for (const p of previousValueParams) {
          if (p.type() == this._resolvedParam.type()) {
            this._previousValueParam = p;
            yield this._resolvedParam.compute();
            this._previousValueParam.copyValue(this._resolvedParam);
          }
        }
        if (!this._previousValueParam) {
          this.states.error.set(
            `param type ${this._resolvedParam.type()} is not supported, availables are: ${previousValueParams.map((p) => p.type()).join(", ")}`
          );
        }
        this.paramGraphNode().addGraphInput(this._resolvedParam);
      }
    });
  }
  paramGraphNode() {
    return this.__paramCoreGraphNode__ = this.__paramCoreGraphNode__ || this._createCoreGraphNode();
  }
  _createCoreGraphNode() {
    const node = new _core_graph_CoreGraphNode__WEBPACK_IMPORTED_MODULE_4__/* .CoreGraphNode */ .Y(this.scene(), "event/Param");
    node.dirtyController.addPostDirtyHook("onParamDirty", this._onParamDirtyBound);
    return node;
  }
  _onParamDirty() {
    return __async(this, null, function* () {
      if (!(this._resolvedParam && this._previousValueParam)) {
        return;
      }
      yield this._resolvedParam.compute();
      const valueChanged = !this._resolvedParam.isValueEqual(this._previousValueParam.value);
      if (valueChanged) {
        this._previousValueParam.copyValue(this._resolvedParam);
        this.dispatchEventToOutput(_ParamEventNode.OUTPUT_NAME, {});
      }
    });
  }
};
let ParamEventNode = _ParamEventNode;
ParamEventNode.OUTPUT_NAME = "valueChanged";


/***/ }),

/***/ 77131:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "B": function() { return /* binding */ PointerEventNode; }
/* harmony export */ });
/* harmony import */ var _utils_io_connections_Event__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(18162);
/* harmony import */ var _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(96949);
/* harmony import */ var _BaseInput__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(29045);
/* harmony import */ var _core_BooleanValue__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(19037);
/* harmony import */ var _poly_registers_nodes_types_Event__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(39902);
/* harmony import */ var _core_event_CoreEventEmitter__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(9913);
/* harmony import */ var _core_event_PointerEventType__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(43843);

var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));







class PointerEventParamsConfig extends _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_0__/* .NodeParamsConfig */ .yI {
  constructor() {
    super(...arguments);
    /** @param toggle on to allow any event to be listened to */
    this.active = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_0__/* .ParamConfig.BOOLEAN */ .XC.BOOLEAN(true, {
      callback: (node) => {
        PointerEventNode.PARAM_CALLBACK_updateRegister(node);
      },
      separatorAfter: true
    });
    /** @param set which element triggers the event */
    this.element = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_0__/* .ParamConfig.INTEGER */ .XC.INTEGER(_core_event_CoreEventEmitter__WEBPACK_IMPORTED_MODULE_1__/* .EVENT_EMITTERS.indexOf */ .Br.indexOf(_core_event_CoreEventEmitter__WEBPACK_IMPORTED_MODULE_1__/* .CoreEventEmitter.CANVAS */ .Ok.CANVAS), {
      menu: {
        entries: _core_event_CoreEventEmitter__WEBPACK_IMPORTED_MODULE_1__/* .EVENT_EMITTERS.map */ .Br.map((name, value) => {
          return { name, value };
        })
      },
      separatorAfter: true
    });
    /** @param toggle on to listen to click events */
    this.pointerdown = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_0__/* .ParamConfig.BOOLEAN */ .XC.BOOLEAN(1, _BaseInput__WEBPACK_IMPORTED_MODULE_2__/* .EVENT_PARAM_OPTIONS */ .F4);
    /** @param toggle on to listen to pointermove events */
    this.pointermove = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_0__/* .ParamConfig.BOOLEAN */ .XC.BOOLEAN(0, _BaseInput__WEBPACK_IMPORTED_MODULE_2__/* .EVENT_PARAM_OPTIONS */ .F4);
    /** @param toggle on to listen to pointerup events */
    this.pointerup = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_0__/* .ParamConfig.BOOLEAN */ .XC.BOOLEAN(0, _BaseInput__WEBPACK_IMPORTED_MODULE_2__/* .EVENT_PARAM_OPTIONS */ .F4);
    /** @param requires ctrlKey */
    this.ctrlKey = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_0__/* .ParamConfig.BOOLEAN */ .XC.BOOLEAN(0, __spreadProps(__spreadValues({}, _BaseInput__WEBPACK_IMPORTED_MODULE_2__/* .EVENT_PARAM_OPTIONS */ .F4), { separatorBefore: true }));
    /** @param requires altKey */
    this.altKey = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_0__/* .ParamConfig.BOOLEAN */ .XC.BOOLEAN(0, _BaseInput__WEBPACK_IMPORTED_MODULE_2__/* .EVENT_PARAM_OPTIONS */ .F4);
    /** @param requires shiftKey */
    this.shiftKey = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_0__/* .ParamConfig.BOOLEAN */ .XC.BOOLEAN(0, _BaseInput__WEBPACK_IMPORTED_MODULE_2__/* .EVENT_PARAM_OPTIONS */ .F4);
    /** @param requires metaKey */
    this.metaKey = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_0__/* .ParamConfig.BOOLEAN */ .XC.BOOLEAN(0, _BaseInput__WEBPACK_IMPORTED_MODULE_2__/* .EVENT_PARAM_OPTIONS */ .F4);
  }
}
const ParamsConfig = new PointerEventParamsConfig();
class PointerEventNode extends _BaseInput__WEBPACK_IMPORTED_MODULE_2__/* .TypedInputEventNode */ .Y5 {
  constructor() {
    super(...arguments);
    this.paramsConfig = ParamsConfig;
  }
  static type() {
    return _poly_registers_nodes_types_Event__WEBPACK_IMPORTED_MODULE_3__/* .EventInputType.POINTER */ .$.POINTER;
  }
  acceptedEventTypes() {
    return /* @__PURE__ */ new Set([..._core_event_PointerEventType__WEBPACK_IMPORTED_MODULE_4__/* .ONLY_POINTER_EVENT_TYPES */ .dC]);
  }
  initializeNode() {
    this.io.outputs.setNamedOutputConnectionPoints(
      _core_event_PointerEventType__WEBPACK_IMPORTED_MODULE_4__/* .ONLY_POINTER_EVENT_TYPES.map */ .dC.map((event_type) => {
        return new _utils_io_connections_Event__WEBPACK_IMPORTED_MODULE_5__/* .EventConnectionPoint */ .TG(event_type, _utils_io_connections_Event__WEBPACK_IMPORTED_MODULE_5__/* .EventConnectionPointType.POINTER */ .M$.POINTER);
      })
    );
  }
  processEvent(eventContext) {
    if (!this.pv.active) {
      return;
    }
    const event = eventContext.event;
    if (!event) {
      return;
    }
    if (event.ctrlKey != (0,_core_BooleanValue__WEBPACK_IMPORTED_MODULE_6__/* .isBooleanTrue */ .bI)(this.pv.ctrlKey)) {
      return;
    }
    if (event.shiftKey != (0,_core_BooleanValue__WEBPACK_IMPORTED_MODULE_6__/* .isBooleanTrue */ .bI)(this.pv.shiftKey)) {
      return;
    }
    if (event.altKey != (0,_core_BooleanValue__WEBPACK_IMPORTED_MODULE_6__/* .isBooleanTrue */ .bI)(this.pv.altKey)) {
      return;
    }
    if (event.metaKey != (0,_core_BooleanValue__WEBPACK_IMPORTED_MODULE_6__/* .isBooleanTrue */ .bI)(this.pv.metaKey)) {
      return;
    }
    this.dispatchEventToOutput(event.type, eventContext);
  }
}


/***/ }),

/***/ 83015:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "p": function() { return /* binding */ PostProcessNetworkEventNode; }
/* harmony export */ });
/* harmony import */ var _BaseManager__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(1814);
/* harmony import */ var _poly_NodeContext__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(52070);
/* harmony import */ var _utils_DisplayNodeController__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(35725);
/* harmony import */ var _post_utils_EffectComposerController__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(32241);





class PostProcessNetworkEventNode extends _BaseManager__WEBPACK_IMPORTED_MODULE_0__/* .BaseNetworkEventNode */ .k {
  constructor() {
    super(...arguments);
    this.paramsConfig = new _post_utils_EffectComposerController__WEBPACK_IMPORTED_MODULE_1__/* .PostProcessNetworkParamsConfig */ .Ab();
    this.effectsComposerController = new _post_utils_EffectComposerController__WEBPACK_IMPORTED_MODULE_1__/* .EffectComposerController */ .iy(this);
    this.displayNodeController = new _utils_DisplayNodeController__WEBPACK_IMPORTED_MODULE_2__/* .DisplayNodeController */ .v(
      this,
      this.effectsComposerController.displayNodeControllerCallbacks()
    );
    this._childrenControllerContext = _poly_NodeContext__WEBPACK_IMPORTED_MODULE_3__/* .NodeContext.POST */ .sy.POST;
  }
  static type() {
    return _poly_NodeContext__WEBPACK_IMPORTED_MODULE_3__/* .NetworkNodeType.POST */ .kX.POST;
  }
  createNode(node_class, options) {
    return super.createNode(node_class, options);
  }
  children() {
    return super.children();
  }
  nodesByType(type) {
    return super.nodesByType(type);
  }
}


/***/ }),

/***/ 84635:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "y": function() { return /* binding */ SceneEventNode; }
/* harmony export */ });
/* unused harmony export ACCEPTED_EVENT_TYPES */
/* harmony import */ var _poly_utils_PolyEventName__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(96667);
/* harmony import */ var _utils_io_connections_Event__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(18162);
/* harmony import */ var _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(96949);
/* harmony import */ var _core_graph_CoreGraphNode__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(45516);
/* harmony import */ var _Base__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(79282);
/* harmony import */ var _core_Type__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(19037);

var __defProp = Object.defineProperty;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};






var SceneNodeInput = /* @__PURE__ */ ((SceneNodeInput2) => {
  SceneNodeInput2["SET_FRAME"] = "setFrame";
  return SceneNodeInput2;
})(SceneNodeInput || {});
var SceneNodeOutput = /* @__PURE__ */ ((SceneNodeOutput2) => {
  SceneNodeOutput2["TICK"] = "tick";
  SceneNodeOutput2["TIME_REACHED"] = "timeReached";
  return SceneNodeOutput2;
})(SceneNodeOutput || {});
const UPDATE_SCENE_EVENT_PARAM_OPTIONS = {
  visibleIf: { active: 1 },
  callback: (node) => {
    SceneEventNode.PARAM_CALLBACK_updateSceneEventsController(node);
  }
};
const UPDATE_TIME_DEPENDENCY_PARAM_OPTIONS = {
  visibleIf: { active: 1 },
  callback: (node) => {
    SceneEventNode.PARAM_CALLBACK_updateTimeDependency(node);
  }
};
var EventName = /* @__PURE__ */ ((EventName2) => {
  EventName2["CREATED"] = "created";
  EventName2["READY"] = "ready";
  EventName2["PLAY"] = "play";
  EventName2["PAUSE"] = "pause";
  return EventName2;
})(EventName || {});
const ACCEPTED_EVENT_TYPES = ["created" /* CREATED */, "ready" /* READY */, "play" /* PLAY */, "pause" /* PAUSE */];
class SceneEventParamsConfig extends _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_0__/* .NodeParamsConfig */ .yI {
  constructor() {
    super(...arguments);
    /** @param toggle on to allow any event to be listened to */
    this.active = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_0__/* .ParamConfig.BOOLEAN */ .XC.BOOLEAN(true, {
      callback: (node, param) => {
        SceneEventNode.PARAM_CALLBACK_updateActiveState(node);
      },
      separatorAfter: true
    });
    /** @param set which element triggers the event */
    this.element = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_0__/* .ParamConfig.INTEGER */ .XC.INTEGER(0, {
      hidden: true
    });
    /** @param toggle on to trigger an event when the scene has been created. This can be useful to initialize other nodes */
    this.created = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_0__/* .ParamConfig.BOOLEAN */ .XC.BOOLEAN(1, UPDATE_SCENE_EVENT_PARAM_OPTIONS);
    /** @param toggle on to trigger an event when every object in the scene has been loaded. This can be useful to initialize other nodes */
    this.ready = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_0__/* .ParamConfig.BOOLEAN */ .XC.BOOLEAN(1, UPDATE_SCENE_EVENT_PARAM_OPTIONS);
    /** @param toggle on to trigger an event when the scene starts playing */
    this.play = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_0__/* .ParamConfig.BOOLEAN */ .XC.BOOLEAN(1, UPDATE_SCENE_EVENT_PARAM_OPTIONS);
    /** @param toggle on to trigger an event when the scene pauses */
    this.pause = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_0__/* .ParamConfig.BOOLEAN */ .XC.BOOLEAN(1, UPDATE_SCENE_EVENT_PARAM_OPTIONS);
    /** @param toggle on to trigger an event on every tick */
    this.tick = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_0__/* .ParamConfig.BOOLEAN */ .XC.BOOLEAN(1, __spreadValues({
      separatorAfter: true
    }, UPDATE_TIME_DEPENDENCY_PARAM_OPTIONS));
    /** @param toggle on to trigger an event on every tick */
    this.treachedTime = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_0__/* .ParamConfig.BOOLEAN */ .XC.BOOLEAN(0, UPDATE_TIME_DEPENDENCY_PARAM_OPTIONS);
    /** @param time to trigger an event */
    this.reachedTime = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_0__/* .ParamConfig.FLOAT */ .XC.FLOAT(10, __spreadValues({
      visibleIf: { treachedTime: 1 },
      range: [0, 100],
      separatorAfter: true
    }, UPDATE_TIME_DEPENDENCY_PARAM_OPTIONS));
    /** @param frame to set */
    this.setFrameValue = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_0__/* .ParamConfig.INTEGER */ .XC.INTEGER(1, {
      range: [0, 100]
    });
    /** @param button to set a specific frame */
    this.setFrame = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_0__/* .ParamConfig.BUTTON */ .XC.BUTTON(null, {
      callback: (node) => {
        SceneEventNode.PARAM_CALLBACK_setFrame(node);
      }
    });
  }
}
const ParamsConfig = new SceneEventParamsConfig();
class SceneEventNode extends _Base__WEBPACK_IMPORTED_MODULE_1__/* .TypedEventNode */ .F {
  constructor() {
    super(...arguments);
    this.paramsConfig = ParamsConfig;
    this._timeReached = false;
  }
  static type() {
    return "scene";
  }
  dispose() {
    var _a;
    (_a = this._graphNode) == null ? void 0 : _a.dispose();
    super.dispose();
  }
  initializeNode() {
    this.io.inputs.setNamedInputConnectionPoints([
      new _utils_io_connections_Event__WEBPACK_IMPORTED_MODULE_2__/* .EventConnectionPoint */ .TG(
        "setFrame" /* SET_FRAME */,
        _utils_io_connections_Event__WEBPACK_IMPORTED_MODULE_2__/* .EventConnectionPointType.BASE */ .M$.BASE,
        this._onSetFrame.bind(this)
      ),
      new _utils_io_connections_Event__WEBPACK_IMPORTED_MODULE_2__/* .EventConnectionPoint */ .TG("play" /* PLAY */, _utils_io_connections_Event__WEBPACK_IMPORTED_MODULE_2__/* .EventConnectionPointType.BASE */ .M$.BASE, this._play.bind(this)),
      new _utils_io_connections_Event__WEBPACK_IMPORTED_MODULE_2__/* .EventConnectionPoint */ .TG("pause" /* PAUSE */, _utils_io_connections_Event__WEBPACK_IMPORTED_MODULE_2__/* .EventConnectionPointType.BASE */ .M$.BASE, this._pause.bind(this))
    ]);
    const outConnectionPoints = ACCEPTED_EVENT_TYPES.map((event_type) => {
      return new _utils_io_connections_Event__WEBPACK_IMPORTED_MODULE_2__/* .EventConnectionPoint */ .TG(event_type, _utils_io_connections_Event__WEBPACK_IMPORTED_MODULE_2__/* .EventConnectionPointType.BASE */ .M$.BASE);
    });
    outConnectionPoints.push(new _utils_io_connections_Event__WEBPACK_IMPORTED_MODULE_2__/* .EventConnectionPoint */ .TG("tick" /* TICK */, _utils_io_connections_Event__WEBPACK_IMPORTED_MODULE_2__/* .EventConnectionPointType.BASE */ .M$.BASE));
    outConnectionPoints.push(new _utils_io_connections_Event__WEBPACK_IMPORTED_MODULE_2__/* .EventConnectionPoint */ .TG("timeReached" /* TIME_REACHED */, _utils_io_connections_Event__WEBPACK_IMPORTED_MODULE_2__/* .EventConnectionPointType.BASE */ .M$.BASE));
    this.io.outputs.setNamedOutputConnectionPoints(outConnectionPoints);
    this.params.onParamsCreated("updateTimeDependency", () => {
      this._updateTimeDependency();
    });
    this._updateSceneEventsController();
    const register = () => {
      this._updateSceneEventsController();
    };
    const unregister = () => {
      const eventsController = this.scene().eventsDispatcher.sceneEventsController;
      eventsController.removeObserverFromAllEventTypes(this);
    };
    this.lifecycle.onAfterAdded(register);
    this.lifecycle.onBeforeDeleted(unregister);
  }
  processEvent(eventContext) {
    if (!this.pv.active) {
      return;
    }
    if (!eventContext.event) {
      return;
    }
    const eventType = eventContext.event.type;
    switch (eventType) {
      case _poly_utils_PolyEventName__WEBPACK_IMPORTED_MODULE_3__/* .PolyEventName.SCENE_CREATED */ .X.SCENE_CREATED: {
        return this.dispatchEventToOutput("created" /* CREATED */, eventContext);
      }
      case _poly_utils_PolyEventName__WEBPACK_IMPORTED_MODULE_3__/* .PolyEventName.SCENE_READY */ .X.SCENE_READY: {
        return this.dispatchEventToOutput("ready" /* READY */, eventContext);
      }
      case _poly_utils_PolyEventName__WEBPACK_IMPORTED_MODULE_3__/* .PolyEventName.SCENE_PLAY */ .X.SCENE_PLAY: {
        return this.dispatchEventToOutput("play" /* PLAY */, eventContext);
      }
      case _poly_utils_PolyEventName__WEBPACK_IMPORTED_MODULE_3__/* .PolyEventName.SCENE_PAUSE */ .X.SCENE_PAUSE: {
        return this.dispatchEventToOutput("pause" /* PAUSE */, eventContext);
      }
    }
    this.dispatchEventToOutput(eventContext.event.type, eventContext);
  }
  _onSetFrame(eventContext) {
    this.scene().setFrame(this.pv.setFrameValue);
  }
  _play(eventContext) {
    this.scene().play();
  }
  _pause(eventContext) {
    this.scene().pause();
  }
  _onTickCheckTimeReached(time, reachedTime) {
    if (time >= this.pv.reachedTime) {
      if (!this._timeReached) {
        this._timeReached = true;
        this.dispatchEventToOutput("timeReached" /* TIME_REACHED */, {});
      }
    } else {
      this._timeReached = false;
    }
  }
  _onTickEvent() {
    this.dispatchEventToOutput("tick" /* TICK */, {});
  }
  _updateTimeDependency() {
    var _a, _b;
    const timeGraphNode = this.scene().timeController.graphNode;
    (_a = this._graphNode) == null ? void 0 : _a.removeGraphInput(timeGraphNode);
    if (!(0,_core_Type__WEBPACK_IMPORTED_MODULE_4__/* .isBooleanTrue */ .bI)(this.pv.active)) {
      return;
    }
    if ((0,_core_Type__WEBPACK_IMPORTED_MODULE_4__/* .isBooleanTrue */ .bI)(this.pv.treachedTime) || (0,_core_Type__WEBPACK_IMPORTED_MODULE_4__/* .isBooleanTrue */ .bI)(this.pv.tick)) {
      this._graphNode = this._graphNode || new _core_graph_CoreGraphNode__WEBPACK_IMPORTED_MODULE_5__/* .CoreGraphNode */ .Y(this.scene(), "sceneNodeTimeGraphNode");
      this._graphNode.addGraphInput(timeGraphNode);
      const options = {
        tick: this.pv.tick,
        treachedTime: this.pv.treachedTime,
        reachedTime: this.pv.reachedTime
      };
      const callback = (_b = this._buildOnTickCallback(options)) == null ? void 0 : _b.bind(this);
      if (callback) {
        const callbackName = "timeUpdate";
        this._graphNode.removePostDirtyHook(callbackName);
        this._graphNode.addPostDirtyHook(callbackName, callback);
      }
    }
  }
  _buildOnTickCallback(options) {
    if ((0,_core_Type__WEBPACK_IMPORTED_MODULE_4__/* .isBooleanTrue */ .bI)(options.treachedTime) && (0,_core_Type__WEBPACK_IMPORTED_MODULE_4__/* .isBooleanTrue */ .bI)(options.tick)) {
      return () => {
        const time = this.scene().time();
        this._onTickEvent();
        this._onTickCheckTimeReached(time, options.reachedTime);
      };
    } else {
      if ((0,_core_Type__WEBPACK_IMPORTED_MODULE_4__/* .isBooleanTrue */ .bI)(options.treachedTime)) {
        return () => {
          const time = this.scene().time();
          this._onTickCheckTimeReached(time, options.reachedTime);
        };
      }
      if ((0,_core_Type__WEBPACK_IMPORTED_MODULE_4__/* .isBooleanTrue */ .bI)(options.tick)) {
        return this._onTickEvent.bind(this);
      }
    }
  }
  static PARAM_CALLBACK_setFrame(node) {
    node._onSetFrame({});
  }
  static PARAM_CALLBACK_updateTimeDependency(node) {
    node._updateTimeDependency();
  }
  static PARAM_CALLBACK_updateSceneEventsController(node) {
    node._updateSceneEventsController();
  }
  static PARAM_CALLBACK_updateActiveState(node) {
    node._updateTimeDependency();
    node._updateSceneEventsController();
  }
  _updateSceneEventsController() {
    const eventsController = this.scene().eventsDispatcher.sceneEventsController;
    eventsController.removeObserverFromAllEventTypes(this);
    if (!this.pv.active) {
      return;
    }
    this._updateTimeDependency();
    if ((0,_core_Type__WEBPACK_IMPORTED_MODULE_4__/* .isBooleanTrue */ .bI)(this.pv.created)) {
      eventsController.addObserver(this, _poly_utils_PolyEventName__WEBPACK_IMPORTED_MODULE_3__/* .PolyEventName.SCENE_CREATED */ .X.SCENE_CREATED);
    }
    if ((0,_core_Type__WEBPACK_IMPORTED_MODULE_4__/* .isBooleanTrue */ .bI)(this.pv.ready)) {
      eventsController.addObserver(this, _poly_utils_PolyEventName__WEBPACK_IMPORTED_MODULE_3__/* .PolyEventName.SCENE_READY */ .X.SCENE_READY);
    }
    if ((0,_core_Type__WEBPACK_IMPORTED_MODULE_4__/* .isBooleanTrue */ .bI)(this.pv.play)) {
      eventsController.addObserver(this, _poly_utils_PolyEventName__WEBPACK_IMPORTED_MODULE_3__/* .PolyEventName.SCENE_PLAY */ .X.SCENE_PLAY);
    }
    if ((0,_core_Type__WEBPACK_IMPORTED_MODULE_4__/* .isBooleanTrue */ .bI)(this.pv.pause)) {
      eventsController.addObserver(this, _poly_utils_PolyEventName__WEBPACK_IMPORTED_MODULE_3__/* .PolyEventName.SCENE_PAUSE */ .X.SCENE_PAUSE);
    }
  }
}


/***/ }),

/***/ 24732:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "n": function() { return /* binding */ ScrollTriggerEventNode; }
/* harmony export */ });
/* harmony import */ var _utils_io_connections_Event__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(18162);
/* harmony import */ var _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(96949);
/* harmony import */ var _Base__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(79282);
/* harmony import */ var _core_Type__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(19037);
/* harmony import */ var gsap_ScrollTrigger__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(81169);
/* harmony import */ var _core_thirdParty_gsap_gsap__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(409);
/* harmony import */ var _poly_registers_modules_Common__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(26280);
/* harmony import */ var _core_thirdParty_gsap_gsapFactory__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(73436);

var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));








_core_thirdParty_gsap_gsap__WEBPACK_IMPORTED_MODULE_0__/* .gsap.registerPlugin */ .p8.registerPlugin(gsap_ScrollTrigger__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .Z);
var ScrollTriggerNodeInput = /* @__PURE__ */ ((ScrollTriggerNodeInput2) => {
  ScrollTriggerNodeInput2["CREATE"] = "create";
  ScrollTriggerNodeInput2["DISPOSE"] = "dispose";
  return ScrollTriggerNodeInput2;
})(ScrollTriggerNodeInput || {});
var ScrollTriggerNodeOutput = /* @__PURE__ */ ((ScrollTriggerNodeOutput2) => {
  ScrollTriggerNodeOutput2["TOGGLE"] = "toggle";
  ScrollTriggerNodeOutput2["ENTER"] = "enter";
  ScrollTriggerNodeOutput2["LEAVE"] = "leave";
  ScrollTriggerNodeOutput2["ENTER_BACK"] = "enterBack";
  ScrollTriggerNodeOutput2["LEAVE_BACK"] = "leaveBack";
  return ScrollTriggerNodeOutput2;
})(ScrollTriggerNodeOutput || {});
const defaultParamOptions = (options) => {
  let visibleIf = options == null ? void 0 : options.visibleIf;
  if (visibleIf) {
    visibleIf.active = 1;
  } else {
    visibleIf = { active: 1 };
  }
  return {
    visibleIf,
    callback: (node) => {
      ScrollTriggerEventNode.PARAM_CALLBACK_updateScrollTrigger(node);
    }
  };
};
const UPDATE_SCROLL_TRIGGER_PARAM_OPTIONS = defaultParamOptions();
class ScrollTriggerParamsConfig extends _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_2__/* .NodeParamsConfig */ .yI {
  constructor() {
    super(...arguments);
    /** @param active */
    this.active = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_2__/* .ParamConfig.BOOLEAN */ .XC.BOOLEAN(true, {
      callback: (node) => {
        ScrollTriggerEventNode.PARAM_CALLBACK_updateScrollTrigger(node);
      }
    });
    /** @param selector of the element the scroll events are detected for */
    this.element = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_2__/* .ParamConfig.STRING */ .XC.STRING("", UPDATE_SCROLL_TRIGGER_PARAM_OPTIONS);
    /** @param use viewport as scroller */
    this.useViewport = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_2__/* .ParamConfig.BOOLEAN */ .XC.BOOLEAN(1, UPDATE_SCROLL_TRIGGER_PARAM_OPTIONS);
    /** @param override the scroller */
    this.scroller = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_2__/* .ParamConfig.STRING */ .XC.STRING("", defaultParamOptions({ visibleIf: { useViewport: 0 } }));
    /** @param add markers for debugging */
    this.markers = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_2__/* .ParamConfig.BOOLEAN */ .XC.BOOLEAN("!playerMode()", __spreadProps(__spreadValues({}, UPDATE_SCROLL_TRIGGER_PARAM_OPTIONS), {
      separatorAfter: true
    }));
    /** @param define if progress should be updated */
    this.tprogress = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_2__/* .ParamConfig.BOOLEAN */ .XC.BOOLEAN(0, UPDATE_SCROLL_TRIGGER_PARAM_OPTIONS);
    /** @param progress */
    this.progress = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_2__/* .ParamConfig.FLOAT */ .XC.FLOAT(0, {
      editable: false,
      visibleIf: { tprogress: 1 }
    });
    /** @param define if the scroll is inside the element */
    this.tinsideElement = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_2__/* .ParamConfig.BOOLEAN */ .XC.BOOLEAN(0, UPDATE_SCROLL_TRIGGER_PARAM_OPTIONS);
    /** @param 1 if the scroll is inside the element */
    this.insideElement = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_2__/* .ParamConfig.BOOLEAN */ .XC.BOOLEAN(0, {
      editable: false,
      visibleIf: { tinsideElement: 1 }
    });
    /** @param sends a trigger when we leaving or entering the element */
    this.onToggle = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_2__/* .ParamConfig.BOOLEAN */ .XC.BOOLEAN(1, __spreadProps(__spreadValues({}, UPDATE_SCROLL_TRIGGER_PARAM_OPTIONS), {
      separatorBefore: true
    }));
    /** @param sends a trigger when entering the element */
    this.onEnter = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_2__/* .ParamConfig.BOOLEAN */ .XC.BOOLEAN(0, UPDATE_SCROLL_TRIGGER_PARAM_OPTIONS);
    /** @param sends a trigger when leaving the element */
    this.onLeave = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_2__/* .ParamConfig.BOOLEAN */ .XC.BOOLEAN(0, UPDATE_SCROLL_TRIGGER_PARAM_OPTIONS);
    /** @param sends a trigger when entering again the element */
    this.onEnterBack = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_2__/* .ParamConfig.BOOLEAN */ .XC.BOOLEAN(0, UPDATE_SCROLL_TRIGGER_PARAM_OPTIONS);
    /** @param sends a trigger when leaving again the element */
    this.onLeaveBack = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_2__/* .ParamConfig.BOOLEAN */ .XC.BOOLEAN(0, UPDATE_SCROLL_TRIGGER_PARAM_OPTIONS);
  }
}
const ParamsConfig = new ScrollTriggerParamsConfig();
class ScrollTriggerEventNode extends _Base__WEBPACK_IMPORTED_MODULE_3__/* .TypedEventNode */ .F {
  constructor() {
    super(...arguments);
    this.paramsConfig = ParamsConfig;
    this.gsap = (0,_core_thirdParty_gsap_gsapFactory__WEBPACK_IMPORTED_MODULE_4__/* .gsapLib */ .hD)();
    // give access to gsap to external scripts
    this.ScrollTrigger = gsap_ScrollTrigger__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .Z;
  }
  // give access to ScrollTrigger to external scripts
  static type() {
    return "scrollTrigger";
  }
  requiredModules() {
    return [_poly_registers_modules_Common__WEBPACK_IMPORTED_MODULE_5__/* .ModuleName.GSAP */ .r.GSAP];
  }
  dispose() {
    this._disposeScrollTrigger();
    super.dispose();
  }
  initializeNode() {
    this.io.inputs.setNamedInputConnectionPoints([
      new _utils_io_connections_Event__WEBPACK_IMPORTED_MODULE_6__/* .EventConnectionPoint */ .TG(
        "create" /* CREATE */,
        _utils_io_connections_Event__WEBPACK_IMPORTED_MODULE_6__/* .EventConnectionPointType.BASE */ .M$.BASE,
        this._onCreateTrigger.bind(this)
      ),
      new _utils_io_connections_Event__WEBPACK_IMPORTED_MODULE_6__/* .EventConnectionPoint */ .TG(
        "dispose" /* DISPOSE */,
        _utils_io_connections_Event__WEBPACK_IMPORTED_MODULE_6__/* .EventConnectionPointType.BASE */ .M$.BASE,
        this._onDisposeTrigger.bind(this)
      )
    ]);
    this.io.outputs.setNamedOutputConnectionPoints([
      new _utils_io_connections_Event__WEBPACK_IMPORTED_MODULE_6__/* .EventConnectionPoint */ .TG("toggle" /* TOGGLE */, _utils_io_connections_Event__WEBPACK_IMPORTED_MODULE_6__/* .EventConnectionPointType.BASE */ .M$.BASE),
      new _utils_io_connections_Event__WEBPACK_IMPORTED_MODULE_6__/* .EventConnectionPoint */ .TG("enter" /* ENTER */, _utils_io_connections_Event__WEBPACK_IMPORTED_MODULE_6__/* .EventConnectionPointType.BASE */ .M$.BASE),
      new _utils_io_connections_Event__WEBPACK_IMPORTED_MODULE_6__/* .EventConnectionPoint */ .TG("leave" /* LEAVE */, _utils_io_connections_Event__WEBPACK_IMPORTED_MODULE_6__/* .EventConnectionPointType.BASE */ .M$.BASE),
      new _utils_io_connections_Event__WEBPACK_IMPORTED_MODULE_6__/* .EventConnectionPoint */ .TG("enterBack" /* ENTER_BACK */, _utils_io_connections_Event__WEBPACK_IMPORTED_MODULE_6__/* .EventConnectionPointType.BASE */ .M$.BASE),
      new _utils_io_connections_Event__WEBPACK_IMPORTED_MODULE_6__/* .EventConnectionPoint */ .TG("leaveBack" /* LEAVE_BACK */, _utils_io_connections_Event__WEBPACK_IMPORTED_MODULE_6__/* .EventConnectionPointType.BASE */ .M$.BASE)
    ]);
  }
  _onCreateTrigger(eventContext) {
    this._disposeScrollTrigger();
    if (!(0,_core_Type__WEBPACK_IMPORTED_MODULE_7__/* .isBooleanTrue */ .bI)(this.pv.active)) {
      return;
    }
    this.states.error.clear();
    const element = this._querySelector(this.pv.element);
    if (!element) {
      return;
    }
    const _getScroller = () => {
      if ((0,_core_Type__WEBPACK_IMPORTED_MODULE_7__/* .isBooleanTrue */ .bI)(this.pv.useViewport)) {
        return;
      }
      const scrollerElement = this._querySelector(this.pv.scroller);
      if (!scrollerElement) {
        return;
      }
      return scrollerElement;
    };
    const options = {
      trigger: element,
      scroller: _getScroller(),
      markers: this.pv.markers,
      id: this.path()
    };
    if ((0,_core_Type__WEBPACK_IMPORTED_MODULE_7__/* .isBooleanTrue */ .bI)(this.pv.tinsideElement) || (0,_core_Type__WEBPACK_IMPORTED_MODULE_7__/* .isBooleanTrue */ .bI)(this.pv.onToggle)) {
      const updateInside = (scrollTrigger) => this.p.insideElement.set(scrollTrigger.isActive);
      const dispatchOnToggle = (scrollTrigger) => this.dispatchEventToOutput("toggle" /* TOGGLE */, {});
      const functions = [];
      if ((0,_core_Type__WEBPACK_IMPORTED_MODULE_7__/* .isBooleanTrue */ .bI)(this.pv.tinsideElement)) {
        functions.push(updateInside);
      }
      if ((0,_core_Type__WEBPACK_IMPORTED_MODULE_7__/* .isBooleanTrue */ .bI)(this.pv.onToggle)) {
        functions.push(dispatchOnToggle);
      }
      options.onToggle = (scrollTrigger) => {
        for (const func of functions) {
          func(scrollTrigger);
        }
      };
    }
    if ((0,_core_Type__WEBPACK_IMPORTED_MODULE_7__/* .isBooleanTrue */ .bI)(this.pv.onEnter)) {
      options.onEnter = () => this.dispatchEventToOutput("enter" /* ENTER */, {});
    }
    if ((0,_core_Type__WEBPACK_IMPORTED_MODULE_7__/* .isBooleanTrue */ .bI)(this.pv.onLeave)) {
      options.onLeave = () => this.dispatchEventToOutput("leave" /* LEAVE */, {});
    }
    if ((0,_core_Type__WEBPACK_IMPORTED_MODULE_7__/* .isBooleanTrue */ .bI)(this.pv.onEnterBack)) {
      options.onEnterBack = () => this.dispatchEventToOutput("enterBack" /* ENTER_BACK */, {});
    }
    if ((0,_core_Type__WEBPACK_IMPORTED_MODULE_7__/* .isBooleanTrue */ .bI)(this.pv.onLeaveBack)) {
      options.onLeaveBack = () => this.dispatchEventToOutput("leaveBack" /* LEAVE_BACK */, {});
    }
    if ((0,_core_Type__WEBPACK_IMPORTED_MODULE_7__/* .isBooleanTrue */ .bI)(this.pv.tprogress)) {
      options.onUpdate = (scrollTrigger) => {
        this.p.progress.set(scrollTrigger.progress);
      };
    }
    this._scrollTrigger = gsap_ScrollTrigger__WEBPACK_IMPORTED_MODULE_1__/* ["default"].create */ .Z.create(options);
  }
  _updateScrollTrigger() {
    if (!this._scrollTrigger) {
      return;
    }
    this._onCreateTrigger({});
  }
  _onDisposeTrigger(eventContext) {
    this._disposeScrollTrigger();
  }
  _disposeScrollTrigger() {
    if (!this._scrollTrigger) {
      return;
    }
    this._scrollTrigger.kill();
  }
  _querySelector(selector) {
    const element = document.querySelector(selector);
    if (!element) {
      this.states.error.set(`element with selector '${selector}' not found`);
      return;
    }
    return element;
  }
  static PARAM_CALLBACK_updateScrollTrigger(node) {
    node._updateScrollTrigger();
  }
}


/***/ }),

/***/ 27436:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "N": function() { return /* binding */ SetParamEventNode; }
/* harmony export */ });
/* unused harmony export SetParamParamType */
/* harmony import */ var _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(96949);
/* harmony import */ var _Base__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(79282);
/* harmony import */ var _poly_Assert__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(68239);
/* harmony import */ var _poly_ParamType__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(51254);
/* harmony import */ var _utils_io_connections_Event__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(18162);
/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(21410);
/* harmony import */ var _core_BooleanValue__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(19037);

var __defProp = Object.defineProperty;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};









var SetParamParamType = /* @__PURE__ */ ((SetParamParamType2) => {
  SetParamParamType2["BOOLEAN"] = "boolean";
  SetParamParamType2["BUTTON"] = "button";
  SetParamParamType2["NUMBER"] = "number";
  SetParamParamType2["VECTOR2"] = "vector2";
  SetParamParamType2["VECTOR3"] = "vector3";
  SetParamParamType2["VECTOR4"] = "vector4";
  SetParamParamType2["STRING"] = "string";
  return SetParamParamType2;
})(SetParamParamType || {});
const SET_PARAM_PARAM_TYPE = [
  "boolean" /* BOOLEAN */,
  "button" /* BUTTON */,
  "number" /* NUMBER */,
  "vector2" /* VECTOR2 */,
  "vector3" /* VECTOR3 */,
  "vector4" /* VECTOR4 */,
  "string" /* STRING */
];
const TYPE_BOOLEAN = SET_PARAM_PARAM_TYPE.indexOf("boolean" /* BOOLEAN */);
const TYPE_NUMBER = SET_PARAM_PARAM_TYPE.indexOf("number" /* NUMBER */);
const TYPE_VECTOR2 = SET_PARAM_PARAM_TYPE.indexOf("vector2" /* VECTOR2 */);
const TYPE_VECTOR3 = SET_PARAM_PARAM_TYPE.indexOf("vector3" /* VECTOR3 */);
const TYPE_VECTOR4 = SET_PARAM_PARAM_TYPE.indexOf("vector4" /* VECTOR4 */);
const TYPE_STRING = SET_PARAM_PARAM_TYPE.indexOf("string" /* STRING */);
function valueParamOptions() {
  return { cook: false };
}
const OUTPUT_NAME = "output";
class SetParamParamsConfig extends _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_0__/* .NodeParamsConfig */ .yI {
  constructor() {
    super(...arguments);
    /** @param the parameter to update */
    this.param = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_0__/* .ParamConfig.PARAM_PATH */ .XC.PARAM_PATH("", {
      dependentOnFoundParam: false,
      paramSelection: true,
      computeOnDirty: true
    });
    // param = ParamConfig.STRING('display');
    /** @param type of the parameter to update */
    this.type = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_0__/* .ParamConfig.INTEGER */ .XC.INTEGER(TYPE_NUMBER, {
      menu: {
        entries: SET_PARAM_PARAM_TYPE.map((name, value) => {
          return { name, value };
        })
      }
    });
    /** @param for a boolean parameter, sets to toggle its value */
    this.toggle = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_0__/* .ParamConfig.BOOLEAN */ .XC.BOOLEAN(0, {
      visibleIf: { type: TYPE_BOOLEAN }
    });
    /** @param if toggle is set to off, this will set the value of the parameter */
    this.boolean = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_0__/* .ParamConfig.BOOLEAN */ .XC.BOOLEAN(0, __spreadValues({
      visibleIf: {
        type: TYPE_BOOLEAN,
        toggle: 0
      }
    }, valueParamOptions()));
    /** @param param value for a float parameter */
    this.number = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_0__/* .ParamConfig.FLOAT */ .XC.FLOAT(0, __spreadValues({
      visibleIf: { type: TYPE_NUMBER }
    }, valueParamOptions()));
    /** @param param value for a vector2 parameter */
    this.vector2 = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_0__/* .ParamConfig.VECTOR2 */ .XC.VECTOR2([0, 0], __spreadValues({
      visibleIf: { type: TYPE_VECTOR2 }
    }, valueParamOptions()));
    /** @param param value for a vector3 parameter */
    this.vector3 = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_0__/* .ParamConfig.VECTOR3 */ .XC.VECTOR3([0, 0, 0], __spreadValues({
      visibleIf: { type: TYPE_VECTOR3 }
    }, valueParamOptions()));
    /** @param param value for a vector4 parameter */
    this.vector4 = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_0__/* .ParamConfig.VECTOR4 */ .XC.VECTOR4([0, 0, 0, 0], __spreadValues({
      visibleIf: { type: TYPE_VECTOR4 }
    }, valueParamOptions()));
    /** @param if on, the value will be incremented by the value, as opposed to be set to the value */
    this.increment = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_0__/* .ParamConfig.BOOLEAN */ .XC.BOOLEAN(0, __spreadValues({
      visibleIf: [{ type: TYPE_NUMBER }, { type: TYPE_VECTOR2 }, { type: TYPE_VECTOR3 }, { type: TYPE_VECTOR4 }]
    }, valueParamOptions()));
    /** @param param value for a string parameter */
    this.string = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_0__/* .ParamConfig.STRING */ .XC.STRING("", __spreadValues({
      visibleIf: { type: TYPE_STRING }
    }, valueParamOptions()));
    /** @param execute button to test the node */
    this.execute = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_0__/* .ParamConfig.BUTTON */ .XC.BUTTON(null, {
      callback: (node) => {
        SetParamEventNode.PARAM_CALLBACK_execute(node);
      }
    });
  }
}
const ParamsConfig = new SetParamParamsConfig();
class SetParamEventNode extends _Base__WEBPACK_IMPORTED_MODULE_1__/* .TypedEventNode */ .F {
  constructor() {
    super(...arguments);
    this.paramsConfig = ParamsConfig;
    this._tmp_vector2 = new three__WEBPACK_IMPORTED_MODULE_2__.Vector2();
    this._tmp_vector3 = new three__WEBPACK_IMPORTED_MODULE_2__.Vector3();
    this._tmp_vector4 = new three__WEBPACK_IMPORTED_MODULE_2__.Vector4();
    this._tmp_array2 = [0, 0];
    this._tmp_array3 = [0, 0, 0];
    this._tmp_array4 = [0, 0, 0, 0];
  }
  static type() {
    return "setParam";
  }
  initializeNode() {
    this.io.inputs.setNamedInputConnectionPoints([
      new _utils_io_connections_Event__WEBPACK_IMPORTED_MODULE_3__/* .EventConnectionPoint */ .TG("trigger", _utils_io_connections_Event__WEBPACK_IMPORTED_MODULE_3__/* .EventConnectionPointType.BASE */ .M$.BASE)
    ]);
    this.io.outputs.setNamedOutputConnectionPoints([
      new _utils_io_connections_Event__WEBPACK_IMPORTED_MODULE_3__/* .EventConnectionPoint */ .TG(OUTPUT_NAME, _utils_io_connections_Event__WEBPACK_IMPORTED_MODULE_3__/* .EventConnectionPointType.BASE */ .M$.BASE)
    ]);
  }
  setParamType(paramType) {
    const index = SET_PARAM_PARAM_TYPE.indexOf(paramType);
    this.p.type.set(index);
  }
  processEvent(event_context) {
    return __async(this, null, function* () {
      if (this.p.param.isDirty()) {
        yield this.p.param.compute();
      }
      const param = this.p.param.value.param();
      if (param) {
        const newValue = yield this._newParamValue(param);
        if (newValue != null) {
          param.set(newValue);
        }
      } else {
        this.states.error.set("target param not found");
      }
      this.dispatchEventToOutput(OUTPUT_NAME, event_context);
    });
  }
  _newParamValue(param) {
    return __async(this, null, function* () {
      const type = SET_PARAM_PARAM_TYPE[this.pv.type];
      switch (type) {
        case "boolean" /* BOOLEAN */: {
          yield this._computeParamsIfDirty([this.p.toggle]);
          if ((0,_core_BooleanValue__WEBPACK_IMPORTED_MODULE_4__/* .isBooleanTrue */ .bI)(this.pv.toggle)) {
            return param.value ? 0 : 1;
          } else {
            return (0,_core_BooleanValue__WEBPACK_IMPORTED_MODULE_4__/* .isBooleanTrue */ .bI)(this.pv.boolean) ? 1 : 0;
          }
        }
        case "button" /* BUTTON */: {
          return param.options.executeCallback();
        }
        case "number" /* NUMBER */: {
          yield this._computeParamsIfDirty([this.p.increment, this.p.number]);
          if ((0,_core_BooleanValue__WEBPACK_IMPORTED_MODULE_4__/* .isBooleanTrue */ .bI)(this.pv.increment)) {
            if (param.type() == _poly_ParamType__WEBPACK_IMPORTED_MODULE_5__/* .ParamType.FLOAT */ ._.FLOAT) {
              return param.value + this.pv.number;
            } else {
              return param.value;
            }
          } else {
            return this.pv.number;
          }
        }
        case "vector2" /* VECTOR2 */: {
          yield this._computeParamsIfDirty([this.p.increment, this.p.vector2]);
          if ((0,_core_BooleanValue__WEBPACK_IMPORTED_MODULE_4__/* .isBooleanTrue */ .bI)(this.pv.increment)) {
            if (param.type() == _poly_ParamType__WEBPACK_IMPORTED_MODULE_5__/* .ParamType.VECTOR2 */ ._.VECTOR2) {
              this._tmp_vector2.copy(param.value);
              this._tmp_vector2.add(this.pv.vector2);
              this._tmp_vector2.toArray(this._tmp_array2);
            } else {
              param.value.toArray(this._tmp_array2);
            }
          } else {
            this.pv.vector2.toArray(this._tmp_array2);
          }
          return this._tmp_array2;
        }
        case "vector3" /* VECTOR3 */: {
          yield this._computeParamsIfDirty([this.p.increment, this.p.vector3]);
          if ((0,_core_BooleanValue__WEBPACK_IMPORTED_MODULE_4__/* .isBooleanTrue */ .bI)(this.pv.increment)) {
            if (param.type() == _poly_ParamType__WEBPACK_IMPORTED_MODULE_5__/* .ParamType.VECTOR3 */ ._.VECTOR3) {
              this._tmp_vector3.copy(param.value);
              this._tmp_vector3.add(this.pv.vector3);
              this._tmp_vector3.toArray(this._tmp_array3);
            } else {
              param.value.toArray(this._tmp_array3);
            }
          } else {
            this.pv.vector3.toArray(this._tmp_array3);
          }
          return this._tmp_array3;
        }
        case "vector4" /* VECTOR4 */: {
          yield this._computeParamsIfDirty([this.p.increment, this.p.vector4]);
          if ((0,_core_BooleanValue__WEBPACK_IMPORTED_MODULE_4__/* .isBooleanTrue */ .bI)(this.pv.increment)) {
            if (param.type() == _poly_ParamType__WEBPACK_IMPORTED_MODULE_5__/* .ParamType.VECTOR4 */ ._.VECTOR4) {
              this._tmp_vector4.copy(param.value);
              this._tmp_vector4.add(this.pv.vector4);
              this._tmp_vector4.toArray(this._tmp_array4);
            } else {
              param.value.toArray(this._tmp_array4);
            }
          } else {
            this.pv.vector4.toArray(this._tmp_array4);
          }
          return this._tmp_array4;
        }
        case "string" /* STRING */: {
          yield this._computeParamsIfDirty([this.p.string]);
          return this.pv.string;
        }
      }
      _poly_Assert__WEBPACK_IMPORTED_MODULE_6__/* .TypeAssert.unreachable */ .f.unreachable(type);
    });
  }
  static PARAM_CALLBACK_execute(node) {
    node.processEvent({});
  }
  _computeParamsIfDirty(params) {
    return __async(this, null, function* () {
      const dirty_params = [];
      for (const param of params) {
        if (param.isDirty()) {
          dirty_params.push(param);
        }
      }
      const promises = [];
      for (const param of dirty_params) {
        promises.push(param.compute());
      }
      return yield Promise.all(promises);
    });
  }
}


/***/ }),

/***/ 94248:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "F": function() { return /* binding */ TouchEventNode; }
/* harmony export */ });
/* harmony import */ var _utils_io_connections_Event__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(18162);
/* harmony import */ var _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(96949);
/* harmony import */ var _BaseInput__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(29045);
/* harmony import */ var _poly_registers_nodes_types_Event__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(39902);
/* harmony import */ var _core_event_CoreEventEmitter__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(9913);
/* harmony import */ var _core_event_TouchEventType__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(88763);

var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));






class TouchEventParamsConfig extends _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_0__/* .NodeParamsConfig */ .yI {
  constructor() {
    super(...arguments);
    /** @param toggle on to allow any event to be listened to */
    this.active = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_0__/* .ParamConfig.BOOLEAN */ .XC.BOOLEAN(true, {
      callback: (node) => {
        TouchEventNode.PARAM_CALLBACK_updateRegister(node);
      },
      separatorAfter: true
    });
    /** @param set which element triggers the event */
    this.element = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_0__/* .ParamConfig.INTEGER */ .XC.INTEGER(_core_event_CoreEventEmitter__WEBPACK_IMPORTED_MODULE_1__/* .EVENT_EMITTERS.indexOf */ .Br.indexOf(_core_event_CoreEventEmitter__WEBPACK_IMPORTED_MODULE_1__/* .CoreEventEmitter.CANVAS */ .Ok.CANVAS), __spreadProps(__spreadValues({}, _core_event_CoreEventEmitter__WEBPACK_IMPORTED_MODULE_1__/* .EVENT_EMITTER_PARAM_MENU_OPTIONS */ .lh), {
      separatorAfter: true
    }));
    /** @param toggle on to listen to touchstart events */
    this.touchstart = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_0__/* .ParamConfig.BOOLEAN */ .XC.BOOLEAN(1, _BaseInput__WEBPACK_IMPORTED_MODULE_2__/* .EVENT_PARAM_OPTIONS */ .F4);
    /** @param toggle on to listen to touchmove events */
    this.touchmove = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_0__/* .ParamConfig.BOOLEAN */ .XC.BOOLEAN(0, _BaseInput__WEBPACK_IMPORTED_MODULE_2__/* .EVENT_PARAM_OPTIONS */ .F4);
    /** @param toggle on to listen to touchend events */
    this.touchend = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_0__/* .ParamConfig.BOOLEAN */ .XC.BOOLEAN(0, _BaseInput__WEBPACK_IMPORTED_MODULE_2__/* .EVENT_PARAM_OPTIONS */ .F4);
  }
}
const ParamsConfig = new TouchEventParamsConfig();
class TouchEventNode extends _BaseInput__WEBPACK_IMPORTED_MODULE_2__/* .TypedInputEventNode */ .Y5 {
  constructor() {
    super(...arguments);
    this.paramsConfig = ParamsConfig;
  }
  static type() {
    return _poly_registers_nodes_types_Event__WEBPACK_IMPORTED_MODULE_3__/* .EventInputType.TOUCH */ .$.TOUCH;
  }
  acceptedEventTypes() {
    return /* @__PURE__ */ new Set([..._core_event_TouchEventType__WEBPACK_IMPORTED_MODULE_4__/* .ACCEPTED_TOUCH_EVENT_TYPES */ .a]);
  }
  initializeNode() {
    this.io.outputs.setNamedOutputConnectionPoints(
      _core_event_TouchEventType__WEBPACK_IMPORTED_MODULE_4__/* .ACCEPTED_TOUCH_EVENT_TYPES.map */ .a.map((event_type) => {
        return new _utils_io_connections_Event__WEBPACK_IMPORTED_MODULE_5__/* .EventConnectionPoint */ .TG(event_type, _utils_io_connections_Event__WEBPACK_IMPORTED_MODULE_5__/* .EventConnectionPointType.DRAG */ .M$.DRAG);
      })
    );
  }
  processEvent(eventContext) {
    if (!this.pv.active) {
      return;
    }
    if (!eventContext.event) {
      return;
    }
    const event = eventContext.event;
    if (!event) {
      return;
    }
    this.dispatchEventToOutput(event.type, eventContext);
  }
}


/***/ }),

/***/ 58558:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "l": function() { return /* binding */ WindowEventNode; }
/* harmony export */ });
/* harmony import */ var _utils_io_connections_Event__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(18162);
/* harmony import */ var _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(96949);
/* harmony import */ var _BaseInput__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(29045);
/* harmony import */ var _poly_registers_nodes_types_Event__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(39902);
/* harmony import */ var _core_event_WindowEventType__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(80104);






class WindowEventParamsConfig extends _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_0__/* .NodeParamsConfig */ .yI {
  constructor() {
    super(...arguments);
    /** @param toggle on to allow any event to be listened to */
    this.active = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_0__/* .ParamConfig.BOOLEAN */ .XC.BOOLEAN(true, {
      callback: (node) => {
        WindowEventNode.PARAM_CALLBACK_updateRegister(node);
      },
      separatorAfter: true
    });
    /** @param set which element triggers the event */
    this.element = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_0__/* .ParamConfig.INTEGER */ .XC.INTEGER(0, {
      hidden: true
    });
    /** @param toggle on to listen to resize events */
    this.resize = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_0__/* .ParamConfig.BOOLEAN */ .XC.BOOLEAN(1, _BaseInput__WEBPACK_IMPORTED_MODULE_1__/* .EVENT_PARAM_OPTIONS */ .F4);
  }
}
const ParamsConfig = new WindowEventParamsConfig();
class WindowEventNode extends _BaseInput__WEBPACK_IMPORTED_MODULE_1__/* .TypedInputEventNode */ .Y5 {
  constructor() {
    super(...arguments);
    this.paramsConfig = ParamsConfig;
  }
  static type() {
    return _poly_registers_nodes_types_Event__WEBPACK_IMPORTED_MODULE_2__/* .EventInputType.WINDOW */ .$.WINDOW;
  }
  acceptedEventTypes() {
    return /* @__PURE__ */ new Set([..._core_event_WindowEventType__WEBPACK_IMPORTED_MODULE_3__/* .ACCEPTED_WINDOW_EVENT_TYPES */ .I]);
  }
  initializeNode() {
    this.io.outputs.setNamedOutputConnectionPoints(
      _core_event_WindowEventType__WEBPACK_IMPORTED_MODULE_3__/* .ACCEPTED_WINDOW_EVENT_TYPES.map */ .I.map((event_type) => {
        return new _utils_io_connections_Event__WEBPACK_IMPORTED_MODULE_4__/* .EventConnectionPoint */ .TG(event_type, _utils_io_connections_Event__WEBPACK_IMPORTED_MODULE_4__/* .EventConnectionPointType.POINTER */ .M$.POINTER);
      })
    );
  }
  processEvent(eventContext) {
    if (!this.pv.active) {
      return;
    }
    const event = eventContext.event;
    if (!event) {
      return;
    }
    this.dispatchEventToOutput(event.type, eventContext);
  }
}


/***/ }),

/***/ 29045:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "F4": function() { return /* binding */ EVENT_PARAM_OPTIONS; },
/* harmony export */   "Y5": function() { return /* binding */ TypedInputEventNode; }
/* harmony export */ });
/* unused harmony export BaseInputEventNodeClass */
/* harmony import */ var _Base__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(79282);
/* harmony import */ var _core_event_CoreEventEmitter__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(9913);

var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));



const EVENT_PARAM_OPTIONS = {
  visibleIf: { active: 1 },
  callback: (node) => {
    BaseInputEventNodeClass.PARAM_CALLBACK_updateRegister(node);
  }
};
class TypedInputEventNode extends _Base__WEBPACK_IMPORTED_MODULE_0__/* .TypedEventNode */ .F {
  constructor() {
    super(...arguments);
    this._activeEventDatas = [];
  }
  initializeBaseNode() {
    super.initializeBaseNode();
    const register = () => {
      this.scene().eventsDispatcher.registerEventNode(this);
    };
    const unregister = () => {
      this.scene().eventsDispatcher.unregisterEventNode(this);
    };
    this.lifecycle.onAfterAdded(register);
    this.lifecycle.onBeforeDeleted(unregister);
    this.params.onParamsCreated("update_register", () => {
      this._updateRegister();
    });
  }
  processEvent(eventContext) {
    if (!this.pv.active) {
      return;
    }
    if (!eventContext.event) {
      return;
    }
    this.dispatchEventToOutput(eventContext.event.type, eventContext);
  }
  static PARAM_CALLBACK_updateRegister(node) {
    node._updateRegister();
  }
  _updateRegister() {
    this._updateActiveEventDatas();
    this.scene().eventsDispatcher.updateViewerEventListeners(this);
  }
  _updateActiveEventDatas() {
    this._activeEventDatas = [];
    if (this.pv.active) {
      const list = this.acceptedEventTypes();
      list.forEach((name) => {
        const param = this.params.get(name);
        if (param && param.value) {
          this._activeEventDatas.push({ type: name, emitter: _core_event_CoreEventEmitter__WEBPACK_IMPORTED_MODULE_1__/* .EVENT_EMITTERS */ .Br[this.pv.element] });
        }
      });
    }
  }
  activeEventDatas() {
    return this._activeEventDatas;
  }
}
class BaseInputEventParamsConfig extends (/* unused pure expression or super */ null && (NodeParamsConfig)) {
  constructor() {
    super(...arguments);
    this.active = ParamConfig.BOOLEAN(true);
    /** @param set which element triggers the event */
    this.element = ParamConfig.INTEGER(0, __spreadProps(__spreadValues({}, EVENT_EMITTER_PARAM_MENU_OPTIONS), {
      separatorAfter: true
    }));
  }
}
class BaseInputEventNodeClass extends TypedInputEventNode {
  acceptedEventTypes() {
    return /* @__PURE__ */ new Set();
  }
}


/***/ }),

/***/ 1814:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "k": function() { return /* binding */ BaseNetworkEventNode; },
/* harmony export */   "t": function() { return /* binding */ ParamLessBaseNetworkEventNode; }
/* harmony export */ });
/* harmony import */ var _poly_NodeContext__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(52070);
/* harmony import */ var _Base__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(74386);




class ParamLessNetworkEventParamsConfig extends (/* unused pure expression or super */ null && (NodeParamsConfig)) {
}
class BaseNetworkEventNode extends _Base__WEBPACK_IMPORTED_MODULE_0__/* .TypedNode */ .Mv {
  static context() {
    return _poly_NodeContext__WEBPACK_IMPORTED_MODULE_1__/* .NodeContext.EVENT */ .sy.EVENT;
  }
  cook() {
    this.cookController.endCook();
  }
}
class ParamLessBaseNetworkEventNode extends BaseNetworkEventNode {
}


/***/ }),

/***/ 54512:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "n": function() { return /* binding */ CollisionController; }
/* harmony export */ });
/* unused harmony export ColliderParamConfig */
/* harmony import */ var _Base__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(79282);
/* harmony import */ var _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(96949);
/* harmony import */ var _poly_NodeContext__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(52070);
/* harmony import */ var _core_graph_CoreGraphNode__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(45516);

var __async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};




function ColliderParamConfig(Base) {
  return class Mixin extends Base {
    constructor() {
      super(...arguments);
      this.colliderObject = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_0__/* .ParamConfig.NODE_PATH */ .XC.NODE_PATH("", {
        nodeSelection: {
          context: _poly_NodeContext__WEBPACK_IMPORTED_MODULE_1__/* .NodeContext.SOP */ .sy.SOP
        },
        // if the node is dependent,
        // the FirstPersonControls will be re-created when this node changes
        // which we do not want, as it will act like a hard reset
        // when all we want is to update the collider
        dependentOnFoundNode: false,
        callback: (node) => {
          ColliderEventNode.PARAM_CALLBACK_updateCollider(node);
        }
      });
    }
  };
}
class ColliderParamsConfig extends ColliderParamConfig(_utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_0__/* .NodeParamsConfig */ .yI) {
}
class ColliderEventNode extends _Base__WEBPACK_IMPORTED_MODULE_2__/* .TypedEventNode */ .F {
  static PARAM_CALLBACK_updateCollider(node) {
  }
}
class CollisionController {
  constructor(node) {
    this.node = node;
  }
  _colliderNodeGraphNode() {
    return this.__colliderNodeGraphNode = this.__colliderNodeGraphNode || new _core_graph_CoreGraphNode__WEBPACK_IMPORTED_MODULE_3__/* .CoreGraphNode */ .Y(this.node.scene(), "colliderGraphNode");
  }
  getCollider() {
    return __async(this, null, function* () {
      var _a;
      const colliderNode = this.node.pv.colliderObject.nodeWithContext(_poly_NodeContext__WEBPACK_IMPORTED_MODULE_1__/* .NodeContext.SOP */ .sy.SOP);
      if (!colliderNode) {
        this.node.states.error.set("collider node not found");
        return;
      }
      if (((_a = this._colliderNode) == null ? void 0 : _a.graphNodeId()) != colliderNode.graphNodeId()) {
        if (this._colliderNode) {
          this._colliderNodeGraphNode().removeGraphInput(this._colliderNode);
        }
        this._colliderNodeGraphNode().addGraphInput(colliderNode);
        this._colliderNodeGraphNode().addPostDirtyHook("onColliderDirty", () => {
          this.updateCollider();
        });
        this._colliderNode = colliderNode;
      }
      const container = yield colliderNode.compute();
      const coreGroup = container.coreContent();
      if (!coreGroup) {
        this.node.states.error.set("invalid collider node");
        return;
      }
      const collider = coreGroup.threejsObjects()[0];
      return collider;
    });
  }
  updateCollider() {
    return __async(this, null, function* () {
      var _a;
      const collider = yield this.getCollider();
      if (!collider) {
        this.node.states.error.set("invalid collider");
        return;
      }
      (_a = this.node.player()) == null ? void 0 : _a.setCollider(collider);
    });
  }
}


/***/ }),

/***/ 90979:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "W": function() { return /* binding */ ColorCorrectGlNode; }
/* harmony export */ });
/* unused harmony export ColorCorrectType */
/* harmony import */ var _Base__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(69444);
/* harmony import */ var _utils_io_connections_Gl__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(63060);
/* harmony import */ var _core_ThreeToGl__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(81556);
/* harmony import */ var _gl_color_glsl__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(18361);
/* harmony import */ var _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(96949);
/* harmony import */ var _utils_GLDefinition__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(95475);





var ColorCorrectType = /* @__PURE__ */ ((ColorCorrectType2) => {
  ColorCorrectType2["LINEAR"] = "Linear";
  ColorCorrectType2["SRGB"] = "sRGB";
  return ColorCorrectType2;
})(ColorCorrectType || {});
const TYPES = ["Linear" /* LINEAR */, "sRGB" /* SRGB */];


class ColorCorrectParamsConfig extends _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_0__/* .NodeParamsConfig */ .yI {
  constructor() {
    super(...arguments);
    this.color = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_0__/* .ParamConfig.VECTOR4 */ .XC.VECTOR4([1, 1, 1, 1]);
    this.from = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_0__/* .ParamConfig.INTEGER */ .XC.INTEGER(TYPES.indexOf("Linear" /* LINEAR */), {
      menu: {
        entries: TYPES.map((type, i) => {
          return { name: type, value: i };
        })
      }
    });
    this.to = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_0__/* .ParamConfig.INTEGER */ .XC.INTEGER(TYPES.indexOf("sRGB" /* SRGB */), {
      menu: {
        entries: TYPES.map((type, i) => {
          return { name: type, value: i };
        })
      }
    });
  }
}
const ParamsConfig = new ColorCorrectParamsConfig();
const _ColorCorrectGlNode = class extends _Base__WEBPACK_IMPORTED_MODULE_1__/* .TypedGlNode */ .hD {
  constructor() {
    super(...arguments);
    this.paramsConfig = ParamsConfig;
  }
  static type() {
    return "colorCorrect";
  }
  initializeNode() {
    this.io.connection_points.spare_params.setInputlessParamNames(["to", "from"]);
    this.io.outputs.setNamedOutputConnectionPoints([
      new _utils_io_connections_Gl__WEBPACK_IMPORTED_MODULE_2__/* .GlConnectionPoint */ .E(_ColorCorrectGlNode.OUTPUT_NAME, _utils_io_connections_Gl__WEBPACK_IMPORTED_MODULE_2__/* .GlConnectionPointType.VEC4 */ .Dv.VEC4)
    ]);
  }
  colorSpaces() {
    return {
      from: TYPES[this.pv.from],
      to: TYPES[this.pv.to]
    };
  }
  setLines(shaders_collection_controller) {
    const { from, to } = this.colorSpaces();
    const out = this.glVarName(_ColorCorrectGlNode.OUTPUT_NAME);
    const arg_in = _core_ThreeToGl__WEBPACK_IMPORTED_MODULE_3__/* .ThreeToGl.any */ ._.any(this.variableForInput(_ColorCorrectGlNode.INPUT_NAME));
    const body_lines = [];
    if (from != to) {
      const method_name = `${from}To${to}`;
      const args = [];
      args.push(arg_in);
      body_lines.push(`vec4 ${out} = ${method_name}(${args.join(", ")})`);
    } else {
      body_lines.push(`vec4 ${out} = ${arg_in}`);
    }
    shaders_collection_controller.addBodyLines(this, body_lines);
    shaders_collection_controller.addDefinitions(this, [new _utils_GLDefinition__WEBPACK_IMPORTED_MODULE_4__/* .FunctionGLDefinition */ .MR(this, _gl_color_glsl__WEBPACK_IMPORTED_MODULE_5__/* ["default"] */ .Z)]);
  }
};
let ColorCorrectGlNode = _ColorCorrectGlNode;
ColorCorrectGlNode.INPUT_NAME = "color";
ColorCorrectGlNode.OUTPUT_NAME = "out";


/***/ }),

/***/ 928:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "_": function() { return /* binding */ CompareGlNode; }
/* harmony export */ });
/* unused harmony export GlCompareTestName */
/* harmony import */ var _Base__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(69444);
/* harmony import */ var _src_core_ThreeToGl__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(81556);
/* harmony import */ var _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(96949);
/* harmony import */ var _utils_io_connections_Gl__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(63060);





var GlCompareTestName = /* @__PURE__ */ ((GlCompareTestName2) => {
  GlCompareTestName2["EQUAL"] = "Equal";
  GlCompareTestName2["LESS_THAN"] = "Less Than";
  GlCompareTestName2["GREATER_THAN"] = "Greater Than";
  GlCompareTestName2["LESS_THAN_OR_EQUAL"] = "Less Than Or Equal";
  GlCompareTestName2["GREATER_THAN_OR_EQUAL"] = "Greater Than Or Equal";
  GlCompareTestName2["NOT_EQUAL"] = "Not Equal";
  return GlCompareTestName2;
})(GlCompareTestName || {});
var GlCompareTestOperation = /* @__PURE__ */ ((GlCompareTestOperation2) => {
  GlCompareTestOperation2["EQUAL"] = "==";
  GlCompareTestOperation2["LESS_THAN"] = "<";
  GlCompareTestOperation2["GREATER_THAN"] = ">";
  GlCompareTestOperation2["LESS_THAN_OR_EQUAL"] = "<=";
  GlCompareTestOperation2["GREATER_THAN_OR_EQUAL"] = ">=";
  GlCompareTestOperation2["NOT_EQUAL"] = "!=";
  return GlCompareTestOperation2;
})(GlCompareTestOperation || {});
const TEST_NAMES = [
  "Equal" /* EQUAL */,
  "Less Than" /* LESS_THAN */,
  "Greater Than" /* GREATER_THAN */,
  "Less Than Or Equal" /* LESS_THAN_OR_EQUAL */,
  "Greater Than Or Equal" /* GREATER_THAN_OR_EQUAL */,
  "Not Equal" /* NOT_EQUAL */
];
const TEST_OPERATIONS_FLOAT = [
  "==" /* EQUAL */,
  "<" /* LESS_THAN */,
  ">" /* GREATER_THAN */,
  "<=" /* LESS_THAN_OR_EQUAL */,
  ">=" /* GREATER_THAN_OR_EQUAL */,
  "!=" /* NOT_EQUAL */
];
const AND_SEPARATOR = " && ";
const COMPONENTS = ["x", "y", "z", "w"];
const OUTPUT_NAME = "val";
class CompareGlParamsConfig extends _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_0__/* .NodeParamsConfig */ .yI {
  constructor() {
    super(...arguments);
    this.test = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_0__/* .ParamConfig.INTEGER */ .XC.INTEGER(1, {
      menu: {
        entries: TEST_NAMES.map((name, i) => {
          const operator = TEST_OPERATIONS_FLOAT[i];
          const label = `${operator.padEnd(2, " ")} (${name})`;
          return { name: label, value: i };
        })
      }
    });
  }
}
const ParamsConfig = new CompareGlParamsConfig();
class CompareGlNode extends _Base__WEBPACK_IMPORTED_MODULE_1__/* .TypedGlNode */ .hD {
  constructor() {
    super(...arguments);
    this.paramsConfig = ParamsConfig;
  }
  static type() {
    return "compare";
  }
  // public readonly gl_connections_controller: GlConnectionsController = new GlConnectionsController(this);
  initializeNode() {
    super.initializeNode();
    this.io.connection_points.spare_params.setInputlessParamNames(["test"]);
    this.io.connection_points.initializeNode();
    this.io.connection_points.set_input_name_function(this._gl_input_name.bind(this));
    this.io.connection_points.set_output_name_function((index) => OUTPUT_NAME);
    this.io.connection_points.set_expected_input_types_function(this._expected_input_type.bind(this));
    this.io.connection_points.set_expected_output_types_function(() => [_utils_io_connections_Gl__WEBPACK_IMPORTED_MODULE_2__/* .GlConnectionPointType.BOOL */ .Dv.BOOL]);
  }
  setTestName(test) {
    this.p.test.set(TEST_NAMES.indexOf(test));
  }
  testName() {
    return TEST_NAMES[this.pv.test];
  }
  operator() {
    return TEST_OPERATIONS_FLOAT[this.pv.test];
  }
  _gl_input_name(index) {
    return ["value0", "value1"][index];
  }
  _expected_input_type() {
    const type = this.io.connection_points.first_input_connection_type() || _utils_io_connections_Gl__WEBPACK_IMPORTED_MODULE_2__/* .GlConnectionPointType.FLOAT */ .Dv.FLOAT;
    return [type, type];
  }
  setLines(shaders_collection_controller) {
    const body_lines = [];
    const value = this.glVarName(OUTPUT_NAME);
    const operator = this.operator();
    const value0 = _src_core_ThreeToGl__WEBPACK_IMPORTED_MODULE_3__/* .ThreeToGl.any */ ._.any(this.variableForInput(this._gl_input_name(0)));
    const value1 = _src_core_ThreeToGl__WEBPACK_IMPORTED_MODULE_3__/* .ThreeToGl.any */ ._.any(this.variableForInput(this._gl_input_name(1)));
    const connectionPoints = this.io.inputs.namedInputConnectionPoints();
    if (!connectionPoints) {
      return;
    }
    const first_connection = connectionPoints[0];
    let components_count = 1;
    if (first_connection) {
      components_count = _utils_io_connections_Gl__WEBPACK_IMPORTED_MODULE_2__/* .GlConnectionPointComponentsCountMap */ .Od[first_connection.type()] || 1;
    }
    if (components_count > 1) {
      let tmp_values = [];
      for (let i = 0; i < components_count; i++) {
        const tmp_value = this.glVarName(`tmp_value_${i}`);
        const component = COMPONENTS[i];
        tmp_values.push(tmp_value);
        body_lines.push(`bool ${tmp_value} = (${value0}.${component} ${operator} ${value1}.${component})`);
      }
      body_lines.push(`bool ${value} = (${tmp_values.join(AND_SEPARATOR)})`);
    } else {
      body_lines.push(`bool ${value} = (${value0} ${operator} ${value1})`);
    }
    shaders_collection_controller.addBodyLines(this, body_lines);
  }
}


/***/ }),

/***/ 49177:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "W": function() { return /* binding */ ComputeNormalsInput; },
/* harmony export */   "z": function() { return /* binding */ ComputeNormalsGlNode; }
/* harmony export */ });
/* harmony import */ var _Subnet__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(89434);
/* harmony import */ var _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(96949);
/* harmony import */ var _core_ThreeToGl__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(81556);
/* harmony import */ var _utils_io_connections_Gl__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(63060);
/* harmony import */ var _core_geometry_operation_Adjacency__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(2700);
/* harmony import */ var _poly_Assert__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(68239);
/* harmony import */ var _gl_geometryAttributes_geometryAttributesLookupUv_glsl__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(94077);
/* harmony import */ var _utils_GLDefinition__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(95475);
/* harmony import */ var _core_geometry_operation_TextureFromAttribute__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(52598);
/* harmony import */ var _poly_registers_nodes_types_Gl__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(93218);











var ComputeNormalsInput = /* @__PURE__ */ ((ComputeNormalsInput2) => {
  ComputeNormalsInput2["P"] = "P";
  ComputeNormalsInput2["N"] = "N";
  ComputeNormalsInput2["TEXTURE_SIZE"] = "textureSize";
  ComputeNormalsInput2["UV"] = "adjacencyUv";
  ComputeNormalsInput2["ID"] = "adjacencyId";
  return ComputeNormalsInput2;
})(ComputeNormalsInput || {});
var ForLoopVar = /* @__PURE__ */ ((ForLoopVar2) => {
  ForLoopVar2["ADJACENCY_ATTRIBUTES_ARRAY"] = "adjacencyAttributesArray";
  ForLoopVar2["FACE_INDEX"] = "faceIndex";
  ForLoopVar2["VERTEX_INDEX"] = "vertexIndex";
  ForLoopVar2["CURRENT_ADJACENT_ID_FOR_FACE"] = "currentAdjacentIdForFace";
  ForLoopVar2["CURRENT_ADJACENT_ID"] = "currentAdjacentId";
  ForLoopVar2["ADJACENT_POS0"] = "adjacentPos0";
  ForLoopVar2["ADJACENT_POS1"] = "adjacentPos1";
  ForLoopVar2["COMPUTED_NORMAL"] = "computedNormal";
  return ForLoopVar2;
})(ForLoopVar || {});
const CONSTANT = {
  START: 0,
  STEP: 1
};
const SUBNET_INPUT_CONNECTIONS_OFFSET = 3;
const CURRENT_POINT_GL_VAR_NAME_SUFFIX = "currentPoint";
var VariablesLookupMode = /* @__PURE__ */ ((VariablesLookupMode2) => {
  VariablesLookupMode2["CURRENT_POINT"] = "currentPoint";
  VariablesLookupMode2["ADJACENT_POINT"] = "adjacentPoint";
  return VariablesLookupMode2;
})(VariablesLookupMode || {});
class ComputeNormalsGlParamsConfig extends (0,_Subnet__WEBPACK_IMPORTED_MODULE_0__/* .TypedSubnetGlParamsConfigMixin */ .Qm)(_utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .NodeParamsConfig */ .yI) {
  constructor() {
    super(...arguments);
    this.adjacencyCount = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .ParamConfig.FLOAT */ .XC.FLOAT(6, {
      range: [0, 8],
      rangeLocked: [true, false]
    });
    this.adjacencyBaseName = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .ParamConfig.STRING */ .XC.STRING(_core_geometry_operation_Adjacency__WEBPACK_IMPORTED_MODULE_2__/* .AttribAdjacency.BASE_NAME */ .im.BASE_NAME);
  }
}
const ParamsConfig = new ComputeNormalsGlParamsConfig();
class ComputeNormalsGlNode extends _Subnet__WEBPACK_IMPORTED_MODULE_0__/* .TypedSubnetGlNode */ .EZ {
  constructor() {
    super(...arguments);
    this.paramsConfig = ParamsConfig;
    //
    //
    // set_lines
    //
    //
    // _varNameSuffix: string | undefined;
    this._variableLookupMode = "currentPoint" /* CURRENT_POINT */;
  }
  static type() {
    return _poly_registers_nodes_types_Gl__WEBPACK_IMPORTED_MODULE_3__/* .GlType.COMPUTE_NORMALS */ .P.COMPUTE_NORMALS;
  }
  _expectedOutputTypes() {
    return [
      _utils_io_connections_Gl__WEBPACK_IMPORTED_MODULE_4__/* .GlConnectionPointType.VEC3 */ .Dv.VEC3,
      _utils_io_connections_Gl__WEBPACK_IMPORTED_MODULE_4__/* .GlConnectionPointType.VEC3 */ .Dv.VEC3,
      _utils_io_connections_Gl__WEBPACK_IMPORTED_MODULE_4__/* .GlConnectionPointType.VEC2 */ .Dv.VEC2,
      ...super._expectedOutputTypes()
    ];
  }
  _expectedInputTypes() {
    return [
      _utils_io_connections_Gl__WEBPACK_IMPORTED_MODULE_4__/* .GlConnectionPointType.VEC3 */ .Dv.VEC3,
      _utils_io_connections_Gl__WEBPACK_IMPORTED_MODULE_4__/* .GlConnectionPointType.VEC3 */ .Dv.VEC3,
      _utils_io_connections_Gl__WEBPACK_IMPORTED_MODULE_4__/* .GlConnectionPointType.VEC2 */ .Dv.VEC2,
      ...super._expectedInputTypes()
    ];
  }
  _expectedOutputName(index) {
    return this._expectedInputName(index);
  }
  _expectedInputName(index) {
    return ["P" /* P */, "N" /* N */, "textureSize" /* TEXTURE_SIZE */][index] || super._expectedInputName(index - 3);
  }
  childExpectedInputConnectionPointTypes() {
    return [
      // GlConnectionPointType.VEC3,
      // GlConnectionPointType.VEC3,
      _utils_io_connections_Gl__WEBPACK_IMPORTED_MODULE_4__/* .GlConnectionPointType.VEC2 */ .Dv.VEC2,
      _utils_io_connections_Gl__WEBPACK_IMPORTED_MODULE_4__/* .GlConnectionPointType.INT */ .Dv.INT,
      ...super._expectedInputTypes()
    ];
  }
  childExpectedInputConnectionPointName(index) {
    return [
      // ComputeNormalsInput.P,
      // ComputeNormalsInput.N,
      "adjacencyUv" /* UV */,
      "adjacencyId" /* ID */
    ][index] || super._expectedInputName(index - 2);
  }
  childExpectedOutputConnectionPointTypes() {
    return [_utils_io_connections_Gl__WEBPACK_IMPORTED_MODULE_4__/* .GlConnectionPointType.VEC3 */ .Dv.VEC3, ...super._expectedInputTypes()];
  }
  childExpectedOutputConnectionPointName(index) {
    switch (index) {
      case 0: {
        return "P" /* P */;
      }
      default: {
        return super._expectedInputName(index - 1);
      }
    }
  }
  _glVarNameBase() {
    const varName = super._glVarNameBase();
    switch (this._variableLookupMode) {
      case "currentPoint" /* CURRENT_POINT */: {
        return `${varName}_${CURRENT_POINT_GL_VAR_NAME_SUFFIX}`;
      }
      case "adjacentPoint" /* ADJACENT_POINT */: {
        return varName;
      }
    }
  }
  _withCurrentPoint(callback) {
    this._variableLookupMode = "currentPoint" /* CURRENT_POINT */;
    const result = callback();
    this._variableLookupMode = "adjacentPoint" /* ADJACENT_POINT */;
    return result;
  }
  _adjacencyLookupId() {
    switch (this._variableLookupMode) {
      case "currentPoint" /* CURRENT_POINT */: {
        return _core_geometry_operation_TextureFromAttribute__WEBPACK_IMPORTED_MODULE_5__/* .AttribLookup.ID */ .M8.ID;
      }
      case "adjacentPoint" /* ADJACENT_POINT */: {
        return this.glVarName("currentAdjacentId" /* CURRENT_ADJACENT_ID */);
      }
    }
    _poly_Assert__WEBPACK_IMPORTED_MODULE_6__/* .TypeAssert.unreachable */ .f.unreachable(this._variableLookupMode);
  }
  _adjacencyLookupUv() {
    switch (this._variableLookupMode) {
      case "currentPoint" /* CURRENT_POINT */: {
        return _core_geometry_operation_TextureFromAttribute__WEBPACK_IMPORTED_MODULE_5__/* .AttribLookup.UV */ .M8.UV;
      }
      case "adjacentPoint" /* ADJACENT_POINT */: {
        const id = this._adjacencyLookupId();
        const textureSize = _core_ThreeToGl__WEBPACK_IMPORTED_MODULE_7__/* .ThreeToGl.vector2 */ ._.vector2(this.variableForInput("textureSize" /* TEXTURE_SIZE */));
        return `geometryAttributesLookupUv(float(${id}), ${textureSize})`;
      }
    }
    _poly_Assert__WEBPACK_IMPORTED_MODULE_6__/* .TypeAssert.unreachable */ .f.unreachable(this._variableLookupMode);
  }
  setLinesBlockStart(linesController) {
    const start = CONSTANT.START;
    const step = CONSTANT.STEP;
    const glType = _utils_io_connections_Gl__WEBPACK_IMPORTED_MODULE_4__/* .GlConnectionPointType.INT */ .Dv.INT;
    const convertMethod = _core_ThreeToGl__WEBPACK_IMPORTED_MODULE_7__/* .ThreeToGl.integer */ ._.integer;
    const startStr = convertMethod(start);
    const stepStr = convertMethod(step);
    const bodyLines = [];
    const varNameAttributesArray = this.glVarName("adjacencyAttributesArray" /* ADJACENCY_ATTRIBUTES_ARRAY */);
    const faceIndexIteratorName = this.glVarName("faceIndex" /* FACE_INDEX */);
    const vertexIndexIteratorName = this.glVarName("vertexIndex" /* VERTEX_INDEX */);
    const varNameCurrentAdjacentIdForFace = this.glVarName("currentAdjacentIdForFace" /* CURRENT_ADJACENT_ID_FOR_FACE */);
    const varNameP = this.glVarName("P" /* P */);
    const varNameN = this.glVarName("N" /* N */);
    const varNamesForInputs = {};
    const traverseInputs = (callback) => {
      const inputTypes = this._expectedInputTypes();
      const inputsCount = inputTypes.length;
      for (let i = 2; i < inputsCount; i++) {
        const inputName = this._expectedInputName(i);
        const inputType = inputTypes[i];
        const varName = this.glVarName(inputName);
        callback(inputType, inputName, varName);
      }
    };
    traverseInputs((inputType, inputName, varName) => {
      varNamesForInputs[inputName] = varName;
    });
    this._withCurrentPoint(() => {
      const linesForCurrentPoint = this.linesBlockContent(linesController);
      if (linesForCurrentPoint) {
        bodyLines.push(`${_utils_io_connections_Gl__WEBPACK_IMPORTED_MODULE_4__/* .GlConnectionPointType.VEC3 */ .Dv.VEC3} ${this.glVarName("P" /* P */)} = ${varNameP};`);
        bodyLines.push(`${_utils_io_connections_Gl__WEBPACK_IMPORTED_MODULE_4__/* .GlConnectionPointType.VEC3 */ .Dv.VEC3} ${this.glVarName("N" /* N */)} = ${varNameN};`);
        bodyLines.push(
          `${_utils_io_connections_Gl__WEBPACK_IMPORTED_MODULE_4__/* .GlConnectionPointType.VEC2 */ .Dv.VEC2} ${this.glVarName("adjacencyUv" /* UV */)} = ${_core_geometry_operation_TextureFromAttribute__WEBPACK_IMPORTED_MODULE_5__/* .AttribLookup.UV */ .M8.UV};`
        );
        bodyLines.push(
          `${_utils_io_connections_Gl__WEBPACK_IMPORTED_MODULE_4__/* .GlConnectionPointType.INT */ .Dv.INT} ${this.glVarName("adjacencyId" /* ID */)} = ${_core_geometry_operation_TextureFromAttribute__WEBPACK_IMPORTED_MODULE_5__/* .AttribLookup.ID */ .M8.ID};`
        );
        traverseInputs((inputType, inputName, varName) => {
          bodyLines.push(`${inputType} ${this.glVarName(inputName)} = ${varNamesForInputs[inputName]};`);
        });
        bodyLines.push(...linesForCurrentPoint);
      }
    });
    const _initAdjacentPos = () => {
      const adjacentPos0 = this.glVarName("adjacentPos0" /* ADJACENT_POS0 */);
      const adjacentPos1 = this.glVarName("adjacentPos1" /* ADJACENT_POS1 */);
      const glType2 = _utils_io_connections_Gl__WEBPACK_IMPORTED_MODULE_4__/* .GlConnectionPointType.VEC3 */ .Dv.VEC3;
      return [`${glType2} ${adjacentPos0}`, `${glType2} ${adjacentPos1}`];
    };
    const _initComputedNormal = () => {
      const computedNormal = this.glVarName("computedNormal" /* COMPUTED_NORMAL */);
      const glType2 = _utils_io_connections_Gl__WEBPACK_IMPORTED_MODULE_4__/* .GlConnectionPointType.VEC3 */ .Dv.VEC3;
      return [`${glType2} ${computedNormal} = vec3(0.)`];
    };
    const _getAdjacencyAttributeArray = () => {
      const adjacencyCount = this.pv.adjacencyCount;
      const adjacencyBaseName = this.pv.adjacencyBaseName;
      const adjacencyAttributeNames = [];
      for (let i = 0; i < adjacencyCount; i++) {
        const attribName = (0,_core_geometry_operation_Adjacency__WEBPACK_IMPORTED_MODULE_2__/* .adjacencyAttribName */ ._7)(adjacencyBaseName, i);
        adjacencyAttributeNames.push(attribName);
      }
      const glType2 = _utils_io_connections_Gl__WEBPACK_IMPORTED_MODULE_4__/* .GlConnectionPointType.VEC2 */ .Dv.VEC2;
      return `${glType2} ${varNameAttributesArray}[${adjacencyCount}] = vec2[${adjacencyCount}](${adjacencyAttributeNames.join(
        ","
      )})`;
    };
    const _forLoopFaces = () => {
      const max = this.pv.adjacencyCount;
      const maxStr = convertMethod(max);
      const bodyLine = `for(${glType} ${faceIndexIteratorName} = ${startStr}; ${faceIndexIteratorName} < ${maxStr}; ${faceIndexIteratorName}+= ${stepStr}){`;
      return bodyLine;
    };
    const _getAdjacencyAttributeForFace = () => {
      const glType2 = _utils_io_connections_Gl__WEBPACK_IMPORTED_MODULE_4__/* .GlConnectionPointType.VEC2 */ .Dv.VEC2;
      return `${glType2} ${varNameCurrentAdjacentIdForFace} = ${varNameAttributesArray}[${faceIndexIteratorName}]`;
    };
    const _forLoopVertices = () => {
      const max = 2;
      const maxStr = convertMethod(max);
      const bodyLine = `for(${glType} ${vertexIndexIteratorName} = ${startStr}; ${vertexIndexIteratorName} < ${maxStr}; ${vertexIndexIteratorName}+= ${stepStr}){`;
      return bodyLine;
    };
    const _getAdjacencyAttribute = () => {
      const glType2 = _utils_io_connections_Gl__WEBPACK_IMPORTED_MODULE_4__/* .GlConnectionPointType.INT */ .Dv.INT;
      const varName = this.glVarName("currentAdjacentId" /* CURRENT_ADJACENT_ID */);
      return `${glType2} ${varName} = ${vertexIndexIteratorName}==0 ? int(${varNameCurrentAdjacentIdForFace}.x) : int(${varNameCurrentAdjacentIdForFace}.y)`;
    };
    const _ifAdjacencyIdValid = () => {
      return `if(${varNameCurrentAdjacentIdForFace}.x > -0.5 && ${varNameCurrentAdjacentIdForFace}.y >= -0.5){`;
    };
    bodyLines.push(..._initAdjacentPos());
    bodyLines.push(..._initComputedNormal());
    bodyLines.push(_getAdjacencyAttributeArray());
    bodyLines.push(_forLoopFaces());
    bodyLines.push(_getAdjacencyAttributeForFace());
    bodyLines.push(_ifAdjacencyIdValid());
    bodyLines.push(_forLoopVertices());
    bodyLines.push(_getAdjacencyAttribute());
    linesController.addBodyLines(this, bodyLines, void 0, _Subnet__WEBPACK_IMPORTED_MODULE_0__/* .ADD_BODY_LINES_OPTIONS */ .zG);
    linesController.addDefinitions(this, [new _utils_GLDefinition__WEBPACK_IMPORTED_MODULE_8__/* .FunctionGLDefinition */ .MR(this, _gl_geometryAttributes_geometryAttributesLookupUv_glsl__WEBPACK_IMPORTED_MODULE_9__/* ["default"] */ .Z)]);
  }
  setLinesBlockEnd(shadersCollectionController) {
    const vertexIndexIteratorName = this.glVarName("vertexIndex" /* VERTEX_INDEX */);
    const adjacentPos0 = this.glVarName("adjacentPos0" /* ADJACENT_POS0 */);
    const adjacentPos1 = this.glVarName("adjacentPos1" /* ADJACENT_POS1 */);
    const currentPos = this.glVarName("P" /* P */);
    const computedNormal = this.glVarName("computedNormal" /* COMPUTED_NORMAL */);
    const varNameP = this._withCurrentPoint(() => this.glVarName("P" /* P */));
    const assignAdjacentPos = `if( ${vertexIndexIteratorName} == 0 ){ ${adjacentPos0}=${currentPos}; } else { ${adjacentPos1}=${currentPos}; }`;
    const closeIf = `}`;
    const closeFacePair = `}`;
    const addFaceNormal = `${computedNormal} += cross( normalize(${adjacentPos0} - ${varNameP}), normalize(${adjacentPos1} - ${varNameP}) );`;
    const closeAdjacencies = `}`;
    const useCurrentP = `${this.glVarName("P" /* P */)} = ${varNameP}`;
    const useComputedN = `${this.glVarName("N" /* N */)} = normalize(${computedNormal})`;
    shadersCollectionController.addBodyLines(this, [
      assignAdjacentPos,
      closeIf,
      closeFacePair,
      addFaceNormal,
      closeAdjacencies,
      useCurrentP,
      useComputedN
    ]);
  }
  setSubnetInputLines(linesController, childNode) {
    const bodyLines = [];
    const assembler = linesController.assembler();
    const _declareAdjacency = () => {
      var _a;
      const adjacencyCount = this.pv.adjacencyCount;
      const adjacencyBaseName = this.pv.adjacencyBaseName;
      for (let i = 0; i < adjacencyCount; i++) {
        const glType = _utils_io_connections_Gl__WEBPACK_IMPORTED_MODULE_4__/* .GlConnectionPointType.VEC2 */ .Dv.VEC2;
        const attribName = (0,_core_geometry_operation_Adjacency__WEBPACK_IMPORTED_MODULE_2__/* .adjacencyAttribName */ ._7)(adjacencyBaseName, i);
        (_a = assembler.globalsHandler()) == null ? void 0 : _a.readAttribute(this, glType, attribName, linesController);
      }
    };
    const _declareUv = () => {
      var _a;
      const glType = _utils_io_connections_Gl__WEBPACK_IMPORTED_MODULE_4__/* .GlConnectionPointType.VEC2 */ .Dv.VEC2;
      const attribName = _core_geometry_operation_TextureFromAttribute__WEBPACK_IMPORTED_MODULE_5__/* .AttribLookup.UV */ .M8.UV;
      (_a = assembler.globalsHandler()) == null ? void 0 : _a.readAttribute(this, glType, attribName, linesController);
    };
    const _declareId = () => {
      var _a;
      const glType = _utils_io_connections_Gl__WEBPACK_IMPORTED_MODULE_4__/* .GlConnectionPointType.INT */ .Dv.INT;
      const attribName = _core_geometry_operation_TextureFromAttribute__WEBPACK_IMPORTED_MODULE_5__/* .AttribLookup.ID */ .M8.ID;
      (_a = assembler.globalsHandler()) == null ? void 0 : _a.readAttribute(this, glType, attribName, linesController);
    };
    _declareAdjacency();
    _declareUv();
    _declareId();
    const _addAdjacencyLookupId = () => {
      const adjacencyLookupId = this._adjacencyLookupId();
      const id = childNode.glVarName("adjacencyId" /* ID */);
      bodyLines.push(`	${_utils_io_connections_Gl__WEBPACK_IMPORTED_MODULE_4__/* .GlConnectionPointType.INT */ .Dv.INT} ${id} = ${adjacencyLookupId}`);
    };
    const _addAdjacencyLookupUv = () => {
      const adjacencyLookupUv = this._adjacencyLookupUv();
      const uv = childNode.glVarName("adjacencyUv" /* UV */);
      bodyLines.push(`	${_utils_io_connections_Gl__WEBPACK_IMPORTED_MODULE_4__/* .GlConnectionPointType.VEC2 */ .Dv.VEC2} ${uv} = ${adjacencyLookupUv}`);
    };
    _addAdjacencyLookupId();
    _addAdjacencyLookupUv();
    const connections = this.io.connections.inputConnections();
    if (connections) {
      for (const connection of connections) {
        if (connection) {
          if (connection.inputIndex() >= SUBNET_INPUT_CONNECTIONS_OFFSET) {
            const connection_point = connection.destConnectionPoint();
            if (connection_point) {
              const in_value = this.glVarName(connection_point.name());
              const gl_type = connection_point.type();
              const out = childNode.glVarName(connection_point.name());
              const body_line = `	${gl_type} ${out} = ${in_value}`;
              bodyLines.push(body_line);
            }
          }
        }
      }
    }
    linesController.addBodyLines(childNode, bodyLines);
  }
  // override subnetOutputLines(childNode: SubnetOutputGlNode) {
  // 	const bodyLines: string[] = super.subnetOutputLines(childNode);
  // 	const varNameP = this._withCurrentPoint(() => this.glVarName(ComputeNormalsInput.P));
  // 	bodyLines.push(`	${this.glVarName(ComputeNormalsInput.P)} = ${varNameP}`);
  // 	return bodyLines;
  // }
}


/***/ }),

/***/ 94962:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "$": function() { return /* binding */ ConstantGlNode; }
/* harmony export */ });
/* harmony import */ var _Base__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(69444);
/* harmony import */ var _core_ThreeToGl__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(81556);
/* harmony import */ var _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(96949);
/* harmony import */ var _core_Type__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(19037);
/* harmony import */ var _utils_io_connections_Gl__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(63060);
/* harmony import */ var _poly_registers_nodes_types_Gl__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(93218);

var __defProp = Object.defineProperty;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};






function typedVisibleOptions(type, otherParamVal = {}) {
  const val = _utils_io_connections_Gl__WEBPACK_IMPORTED_MODULE_0__/* .GL_CONNECTION_POINT_TYPES_FOR_CONSTANT.indexOf */ .oq.indexOf(type);
  return { visibleIf: __spreadValues({ type: val }, otherParamVal) };
}
class ConstantGlParamsConfig extends _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .NodeParamsConfig */ .yI {
  constructor() {
    super(...arguments);
    this.type = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .ParamConfig.INTEGER */ .XC.INTEGER(_utils_io_connections_Gl__WEBPACK_IMPORTED_MODULE_0__/* .GL_CONNECTION_POINT_TYPES_FOR_CONSTANT.indexOf */ .oq.indexOf(_utils_io_connections_Gl__WEBPACK_IMPORTED_MODULE_0__/* .GlConnectionPointType.FLOAT */ .Dv.FLOAT), {
      menu: {
        entries: _utils_io_connections_Gl__WEBPACK_IMPORTED_MODULE_0__/* .GL_CONNECTION_POINT_TYPES_FOR_CONSTANT.map */ .oq.map((name, i) => {
          return { name, value: i };
        })
      }
    });
    this.bool = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .ParamConfig.BOOLEAN */ .XC.BOOLEAN(0, typedVisibleOptions(_utils_io_connections_Gl__WEBPACK_IMPORTED_MODULE_0__/* .GlConnectionPointType.BOOL */ .Dv.BOOL));
    this.int = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .ParamConfig.INTEGER */ .XC.INTEGER(0, typedVisibleOptions(_utils_io_connections_Gl__WEBPACK_IMPORTED_MODULE_0__/* .GlConnectionPointType.INT */ .Dv.INT));
    this.float = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .ParamConfig.FLOAT */ .XC.FLOAT(0, typedVisibleOptions(_utils_io_connections_Gl__WEBPACK_IMPORTED_MODULE_0__/* .GlConnectionPointType.FLOAT */ .Dv.FLOAT));
    this.vec2 = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .ParamConfig.VECTOR2 */ .XC.VECTOR2([0, 0], typedVisibleOptions(_utils_io_connections_Gl__WEBPACK_IMPORTED_MODULE_0__/* .GlConnectionPointType.VEC2 */ .Dv.VEC2));
    this.vec3 = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .ParamConfig.VECTOR3 */ .XC.VECTOR3([0, 0, 0], typedVisibleOptions(_utils_io_connections_Gl__WEBPACK_IMPORTED_MODULE_0__/* .GlConnectionPointType.VEC3 */ .Dv.VEC3, { asColor: false }));
    this.color = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .ParamConfig.COLOR */ .XC.COLOR([0, 0, 0], typedVisibleOptions(_utils_io_connections_Gl__WEBPACK_IMPORTED_MODULE_0__/* .GlConnectionPointType.VEC3 */ .Dv.VEC3, { asColor: true }));
    this.vec4 = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .ParamConfig.VECTOR4 */ .XC.VECTOR4([0, 0, 0, 0], typedVisibleOptions(_utils_io_connections_Gl__WEBPACK_IMPORTED_MODULE_0__/* .GlConnectionPointType.VEC4 */ .Dv.VEC4));
    /** @param when using vec3, use toggle on it should be a color */
    this.asColor = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .ParamConfig.BOOLEAN */ .XC.BOOLEAN(0, typedVisibleOptions(_utils_io_connections_Gl__WEBPACK_IMPORTED_MODULE_0__/* .GlConnectionPointType.VEC3 */ .Dv.VEC3));
  }
}
const ParamsConfig = new ConstantGlParamsConfig();
const _ConstantGlNode = class extends _Base__WEBPACK_IMPORTED_MODULE_2__/* .TypedGlNode */ .hD {
  constructor() {
    super(...arguments);
    this.paramsConfig = ParamsConfig;
  }
  static type() {
    return _poly_registers_nodes_types_Gl__WEBPACK_IMPORTED_MODULE_3__/* .GlType.CONSTANT */ .P.CONSTANT;
  }
  initializeNode() {
    this.io.connection_points.set_output_name_function((index) => _ConstantGlNode.OUTPUT_NAME);
    this.io.connection_points.set_expected_input_types_function(() => []);
    this.io.connection_points.set_expected_output_types_function(() => [this._currentConnectionType()]);
  }
  setLines(shaders_collection_controller) {
    const param = this.currentParam();
    if (!param) {
      console.warn(`no param found for constant node for type '${this.pv.type}'`);
      return;
    }
    const value = this.currentValue();
    if (value == null) {
      console.warn(`no value found for constant node for type '${this.pv.type}'`);
      return;
    }
    const connection_type = this._currentConnectionType();
    const var_value = this._currentVarName();
    const body_line = `${connection_type} ${var_value} = ${value}`;
    shaders_collection_controller.addBodyLines(this, [body_line]);
  }
  _currentConnectionType() {
    if (this.pv.type == null) {
      console.warn("constant gl node type is null", this.path());
    }
    const connectionType = _utils_io_connections_Gl__WEBPACK_IMPORTED_MODULE_0__/* .GL_CONNECTION_POINT_TYPES_FOR_CONSTANT */ .oq[this.pv.type] || _utils_io_connections_Gl__WEBPACK_IMPORTED_MODULE_0__/* .GlConnectionPointType.FLOAT */ .Dv.FLOAT;
    if (connectionType == null) {
      console.warn(`constant gl node type if not valid (${this.pv.type})`, this.path());
    }
    return connectionType;
  }
  currentParam() {
    const type = _utils_io_connections_Gl__WEBPACK_IMPORTED_MODULE_0__/* .GL_CONNECTION_POINT_TYPES_FOR_CONSTANT */ .oq[this.pv.type];
    switch (type) {
      case _utils_io_connections_Gl__WEBPACK_IMPORTED_MODULE_0__/* .GlConnectionPointType.BOOL */ .Dv.BOOL: {
        return this.p.bool;
      }
      case _utils_io_connections_Gl__WEBPACK_IMPORTED_MODULE_0__/* .GlConnectionPointType.INT */ .Dv.INT: {
        return this.p.int;
      }
      case _utils_io_connections_Gl__WEBPACK_IMPORTED_MODULE_0__/* .GlConnectionPointType.FLOAT */ .Dv.FLOAT: {
        return this.p.float;
      }
      case _utils_io_connections_Gl__WEBPACK_IMPORTED_MODULE_0__/* .GlConnectionPointType.VEC2 */ .Dv.VEC2: {
        return this.p.vec2;
      }
      case _utils_io_connections_Gl__WEBPACK_IMPORTED_MODULE_0__/* .GlConnectionPointType.VEC3 */ .Dv.VEC3: {
        if ((0,_core_Type__WEBPACK_IMPORTED_MODULE_4__/* .isBooleanTrue */ .bI)(this.pv.asColor)) {
          return this.p.color;
        } else {
          return this.p.vec3;
        }
      }
      case _utils_io_connections_Gl__WEBPACK_IMPORTED_MODULE_0__/* .GlConnectionPointType.VEC4 */ .Dv.VEC4: {
        return this.p.vec4;
      }
    }
    return this.p.bool;
  }
  _currentVarName() {
    return this.glVarName(_ConstantGlNode.OUTPUT_NAME);
  }
  currentValue() {
    const param = this.currentParam();
    if (param) {
      let value = _core_ThreeToGl__WEBPACK_IMPORTED_MODULE_5__/* .ThreeToGl.any */ ._.any(param.value);
      if (param.name() == this.p.int.name() && _core_Type__WEBPACK_IMPORTED_MODULE_4__/* .CoreType.isNumber */ .MR.isNumber(param.value)) {
        value = _core_ThreeToGl__WEBPACK_IMPORTED_MODULE_5__/* .ThreeToGl.integer */ ._.integer(param.value);
      }
      return value;
    }
  }
  setGlType(type) {
    this.p.type.set(_utils_io_connections_Gl__WEBPACK_IMPORTED_MODULE_0__/* .GL_CONNECTION_POINT_TYPES_FOR_CONSTANT.indexOf */ .oq.indexOf(type));
  }
};
let ConstantGlNode = _ConstantGlNode;
ConstantGlNode.OUTPUT_NAME = "val";


/***/ }),

/***/ 47375:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "H": function() { return /* binding */ SDFRepeatGlNode; }
/* harmony export */ });
/* harmony import */ var _BaseSDF__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(79952);
/* harmony import */ var _src_core_ThreeToGl__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(81556);
/* harmony import */ var _gl_raymarching_sdfRepeat_glsl__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(914);
/* harmony import */ var _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(96949);
/* harmony import */ var _utils_io_connections_Gl__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(63060);
/* harmony import */ var _utils_GLDefinition__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(95475);
/* harmony import */ var _core_Type__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(19037);

var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));







const OUTPUT_NAME = "p";
const clampVisibility = [{ repeatX: 1 }, { repeatY: 1 }, { repeatZ: 1 }];
const clampAxisVisibility = clampVisibility.map((option) => __spreadProps(__spreadValues({}, option), { clamped: 1 }));
const clampAxisBoundVisibilityX = clampAxisVisibility.map((option) => __spreadProps(__spreadValues({}, option), {
  clampedX: 1
}));
const clampAxisBoundVisibilityY = clampAxisVisibility.map((option) => __spreadProps(__spreadValues({}, option), {
  clampedY: 1
}));
const clampAxisBoundVisibilityZ = clampAxisVisibility.map((option) => __spreadProps(__spreadValues({}, option), {
  clampedZ: 1
}));
class SDFRepeatGlParamsConfig extends _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_0__/* .NodeParamsConfig */ .yI {
  constructor() {
    super(...arguments);
    this.position = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_0__/* .ParamConfig.VECTOR3 */ .XC.VECTOR3([0, 0, 0], { hidden: true });
    this.center = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_0__/* .ParamConfig.VECTOR3 */ .XC.VECTOR3([0, 0, 0]);
    this.period = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_0__/* .ParamConfig.VECTOR3 */ .XC.VECTOR3([1, 1, 1]);
    this.repeatX = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_0__/* .ParamConfig.BOOLEAN */ .XC.BOOLEAN(1);
    this.repeatY = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_0__/* .ParamConfig.BOOLEAN */ .XC.BOOLEAN(1);
    this.repeatZ = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_0__/* .ParamConfig.BOOLEAN */ .XC.BOOLEAN(1);
    this.clamped = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_0__/* .ParamConfig.BOOLEAN */ .XC.BOOLEAN(0, { visibleIf: clampVisibility });
    this.clampedX = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_0__/* .ParamConfig.BOOLEAN */ .XC.BOOLEAN(0, { visibleIf: clampAxisVisibility });
    this.boundX = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_0__/* .ParamConfig.VECTOR2 */ .XC.VECTOR2([-1, 1], { visibleIf: clampAxisBoundVisibilityX });
    this.clampedY = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_0__/* .ParamConfig.BOOLEAN */ .XC.BOOLEAN(0, { visibleIf: clampAxisVisibility });
    this.boundY = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_0__/* .ParamConfig.VECTOR2 */ .XC.VECTOR2([-1, 1], { visibleIf: clampAxisBoundVisibilityY });
    this.clampedZ = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_0__/* .ParamConfig.BOOLEAN */ .XC.BOOLEAN(0, { visibleIf: clampAxisVisibility });
    this.boundZ = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_0__/* .ParamConfig.VECTOR2 */ .XC.VECTOR2([-1, 1], { visibleIf: clampAxisBoundVisibilityZ });
  }
}
const ParamsConfig = new SDFRepeatGlParamsConfig();
class SDFRepeatGlNode extends _BaseSDF__WEBPACK_IMPORTED_MODULE_1__/* .BaseSDFGlNode */ .s {
  constructor() {
    super(...arguments);
    this.paramsConfig = ParamsConfig;
  }
  static type() {
    return "SDFRepeat";
  }
  initializeNode() {
    super.initializeNode();
    this.io.connection_points.spare_params.setInputlessParamNames([
      "repeatX",
      "repeatY",
      "repeatZ",
      "clamped",
      "clampedX",
      "clampedY",
      "clampedZ"
    ]);
    this.io.outputs.setNamedOutputConnectionPoints([
      new _utils_io_connections_Gl__WEBPACK_IMPORTED_MODULE_2__/* .GlConnectionPoint */ .E(OUTPUT_NAME, _utils_io_connections_Gl__WEBPACK_IMPORTED_MODULE_2__/* .GlConnectionPointType.VEC3 */ .Dv.VEC3)
    ]);
  }
  setLines(shadersCollectionController) {
    const position = this.position();
    const center = _src_core_ThreeToGl__WEBPACK_IMPORTED_MODULE_3__/* .ThreeToGl.vector3 */ ._.vector3(this.variableForInputParam(this.p.center));
    const period = _src_core_ThreeToGl__WEBPACK_IMPORTED_MODULE_3__/* .ThreeToGl.vector3 */ ._.vector3(this.variableForInputParam(this.p.period));
    const float = this.glVarName(OUTPUT_NAME);
    const functionName = `SDFRepeat${this._functionSuffixUnclamped()}`;
    const bodyLines = [];
    if (this.clamped()) {
      const boundMin = this.glVarName("boundMin");
      const boundMax = this.glVarName("boundMax");
      const boundX = _src_core_ThreeToGl__WEBPACK_IMPORTED_MODULE_3__/* .ThreeToGl.vector3 */ ._.vector3(this.variableForInputParam(this.p.boundX));
      const boundY = _src_core_ThreeToGl__WEBPACK_IMPORTED_MODULE_3__/* .ThreeToGl.vector3 */ ._.vector3(this.variableForInputParam(this.p.boundY));
      const boundZ = _src_core_ThreeToGl__WEBPACK_IMPORTED_MODULE_3__/* .ThreeToGl.vector3 */ ._.vector3(this.variableForInputParam(this.p.boundZ));
      const clampedAxisesCount = this._clampedAxisesCount();
      switch (clampedAxisesCount) {
        case 1: {
          let bounds = boundX;
          if (this.clampedX()) {
            bounds = boundX;
          } else {
            if (this.clampedY()) {
              bounds = boundY;
            } else {
              bounds = boundZ;
            }
          }
          bodyLines.push(`float ${boundMin} = ${bounds}.x`, `float ${boundMax} = ${bounds}.y`);
          break;
        }
        case 2: {
          let bounds1 = boundX;
          let bounds2 = boundY;
          if (this.clampedX()) {
            bounds1 = boundX;
            if (this.clampedY()) {
              bounds2 = boundY;
            } else {
              bounds2 = boundZ;
            }
          } else {
            bounds1 = boundY;
            bounds2 = boundZ;
          }
          bodyLines.push(
            `vec2 ${boundMin} = vec2(${bounds1}.x, ${bounds2}.x)`,
            `vec2 ${boundMax} = vec2(${bounds1}.y, ${bounds2}.y)`
          );
          break;
        }
        case 3: {
          bodyLines.push(
            `vec3 ${boundMin} = vec3(${boundX}.x,${boundY}.x,${boundZ}.x)`,
            `vec3 ${boundMax} = vec3(${boundX}.y,${boundY}.y,${boundZ}.y)`
          );
          break;
        }
      }
      bodyLines.push(
        `vec3 ${float} = ${functionName}(${position} - ${center}, ${period}, ${boundMin}, ${boundMax})`
      );
    } else {
      bodyLines.push(`vec3 ${float} = ${functionName}(${position} - ${center}, ${period})`);
    }
    shadersCollectionController.addBodyLines(this, bodyLines);
    shadersCollectionController.addDefinitions(this, [new _utils_GLDefinition__WEBPACK_IMPORTED_MODULE_4__/* .FunctionGLDefinition */ .MR(this, _gl_raymarching_sdfRepeat_glsl__WEBPACK_IMPORTED_MODULE_5__/* ["default"] */ .Z)]);
  }
  _clampedAxisesCount() {
    let count = 0;
    if (this.clampedX()) {
      count++;
    }
    if (this.clampedY()) {
      count++;
    }
    if (this.clampedZ()) {
      count++;
    }
    return count;
  }
  repeatAll() {
    const x = (0,_core_Type__WEBPACK_IMPORTED_MODULE_6__/* .isBooleanTrue */ .bI)(this.pv.repeatX);
    const y = (0,_core_Type__WEBPACK_IMPORTED_MODULE_6__/* .isBooleanTrue */ .bI)(this.pv.repeatY);
    const z = (0,_core_Type__WEBPACK_IMPORTED_MODULE_6__/* .isBooleanTrue */ .bI)(this.pv.repeatZ);
    return x && y && z || !(x || y || z);
  }
  clamped() {
    const x = (0,_core_Type__WEBPACK_IMPORTED_MODULE_6__/* .isBooleanTrue */ .bI)(this.pv.repeatX);
    const y = (0,_core_Type__WEBPACK_IMPORTED_MODULE_6__/* .isBooleanTrue */ .bI)(this.pv.repeatY);
    const z = (0,_core_Type__WEBPACK_IMPORTED_MODULE_6__/* .isBooleanTrue */ .bI)(this.pv.repeatZ);
    const clamped = (0,_core_Type__WEBPACK_IMPORTED_MODULE_6__/* .isBooleanTrue */ .bI)(this.pv.clamped);
    const clampedX = (0,_core_Type__WEBPACK_IMPORTED_MODULE_6__/* .isBooleanTrue */ .bI)(this.pv.clampedX);
    const clampedY = (0,_core_Type__WEBPACK_IMPORTED_MODULE_6__/* .isBooleanTrue */ .bI)(this.pv.clampedY);
    const clampedZ = (0,_core_Type__WEBPACK_IMPORTED_MODULE_6__/* .isBooleanTrue */ .bI)(this.pv.clampedZ);
    return clamped && (x && clampedX || y && clampedY || z && clampedZ);
  }
  clampedX() {
    const x = (0,_core_Type__WEBPACK_IMPORTED_MODULE_6__/* .isBooleanTrue */ .bI)(this.pv.repeatX);
    const clamped = (0,_core_Type__WEBPACK_IMPORTED_MODULE_6__/* .isBooleanTrue */ .bI)(this.pv.clamped);
    const clampedX = (0,_core_Type__WEBPACK_IMPORTED_MODULE_6__/* .isBooleanTrue */ .bI)(this.pv.clampedX);
    return clamped && x && clampedX;
  }
  clampedY() {
    const y = (0,_core_Type__WEBPACK_IMPORTED_MODULE_6__/* .isBooleanTrue */ .bI)(this.pv.repeatY);
    const clamped = (0,_core_Type__WEBPACK_IMPORTED_MODULE_6__/* .isBooleanTrue */ .bI)(this.pv.clamped);
    const clampedY = (0,_core_Type__WEBPACK_IMPORTED_MODULE_6__/* .isBooleanTrue */ .bI)(this.pv.clampedY);
    return clamped && y && clampedY;
  }
  clampedZ() {
    const z = (0,_core_Type__WEBPACK_IMPORTED_MODULE_6__/* .isBooleanTrue */ .bI)(this.pv.repeatZ);
    const clamped = (0,_core_Type__WEBPACK_IMPORTED_MODULE_6__/* .isBooleanTrue */ .bI)(this.pv.clamped);
    const clampedZ = (0,_core_Type__WEBPACK_IMPORTED_MODULE_6__/* .isBooleanTrue */ .bI)(this.pv.clampedZ);
    return clamped && z && clampedZ;
  }
  clampedAll() {
    return this.clampedX() && this.clampedY() && this.clampedZ();
  }
  _functionSuffixUnclamped() {
    const x = (0,_core_Type__WEBPACK_IMPORTED_MODULE_6__/* .isBooleanTrue */ .bI)(this.pv.repeatX);
    const y = (0,_core_Type__WEBPACK_IMPORTED_MODULE_6__/* .isBooleanTrue */ .bI)(this.pv.repeatY);
    const z = (0,_core_Type__WEBPACK_IMPORTED_MODULE_6__/* .isBooleanTrue */ .bI)(this.pv.repeatZ);
    const repeatAll = this.repeatAll();
    const args = [];
    if (!repeatAll) {
      if (x)
        args.push("X");
      if (y)
        args.push("Y");
      if (z)
        args.push("Z");
    }
    const clampedX = (0,_core_Type__WEBPACK_IMPORTED_MODULE_6__/* .isBooleanTrue */ .bI)(this.pv.clampedX);
    const clampedY = (0,_core_Type__WEBPACK_IMPORTED_MODULE_6__/* .isBooleanTrue */ .bI)(this.pv.clampedY);
    const clampedZ = (0,_core_Type__WEBPACK_IMPORTED_MODULE_6__/* .isBooleanTrue */ .bI)(this.pv.clampedZ);
    if (this.clamped()) {
      args.push("Clamped");
      if (!this.clampedAll()) {
        if ((repeatAll || x) && clampedX)
          args.push("X");
        if ((repeatAll || y) && clampedY)
          args.push("Y");
        if ((repeatAll || z) && clampedZ)
          args.push("Z");
      }
    }
    return args.join("");
  }
}


/***/ }),

/***/ 75910:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "V": function() { return /* binding */ VaryingReadGlNode; }
/* harmony export */ });
/* harmony import */ var _Base__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(69444);
/* harmony import */ var _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(96949);
/* harmony import */ var _utils_io_connections_Gl__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(63060);
/* harmony import */ var _utils_shaders_ShaderName__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(76606);
/* harmony import */ var _utils_GLDefinition__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(95475);
/* harmony import */ var _poly_registers_nodes_types_Gl__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(93218);







const VARYING_NODE_AVAILABLE_GL_TYPES = [
  _utils_io_connections_Gl__WEBPACK_IMPORTED_MODULE_0__/* .GlConnectionPointType.FLOAT */ .Dv.FLOAT,
  _utils_io_connections_Gl__WEBPACK_IMPORTED_MODULE_0__/* .GlConnectionPointType.VEC2 */ .Dv.VEC2,
  _utils_io_connections_Gl__WEBPACK_IMPORTED_MODULE_0__/* .GlConnectionPointType.VEC3 */ .Dv.VEC3,
  _utils_io_connections_Gl__WEBPACK_IMPORTED_MODULE_0__/* .GlConnectionPointType.VEC4 */ .Dv.VEC4
];
class VaryingReadGlParamsConfig extends _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .NodeParamsConfig */ .yI {
  constructor() {
    super(...arguments);
    this.name = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .ParamConfig.STRING */ .XC.STRING("");
    this.type = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .ParamConfig.INTEGER */ .XC.INTEGER(0, {
      menu: {
        entries: VARYING_NODE_AVAILABLE_GL_TYPES.map((name, i) => {
          return { name, value: i };
        })
      }
    });
  }
}
const ParamsConfig = new VaryingReadGlParamsConfig();
const _VaryingReadGlNode = class extends _Base__WEBPACK_IMPORTED_MODULE_2__/* .TypedGlNode */ .hD {
  constructor() {
    super(...arguments);
    this.paramsConfig = ParamsConfig;
  }
  static type() {
    return _poly_registers_nodes_types_Gl__WEBPACK_IMPORTED_MODULE_3__/* .GlType.VARYING_READ */ .P.VARYING_READ;
  }
  initializeNode() {
    this.addPostDirtyHook("_setMatToRecompile", this._setMatToRecompile.bind(this));
    this.io.connection_points.initializeNode();
    this.io.connection_points.set_output_name_function(() => {
      return this.outputName();
    });
    this.io.connection_points.set_expected_input_types_function(() => []);
    this.io.connection_points.set_expected_output_types_function(() => [
      VARYING_NODE_AVAILABLE_GL_TYPES[this.pv.type]
    ]);
  }
  outputName() {
    return _VaryingReadGlNode.OUTPUT_NAME;
  }
  setLines(shaders_collection_controller) {
    if (shaders_collection_controller.currentShaderName() == _utils_shaders_ShaderName__WEBPACK_IMPORTED_MODULE_4__/* .ShaderName.FRAGMENT */ .k.FRAGMENT) {
      const varying_name = this.pv.name;
      const definition = new _utils_GLDefinition__WEBPACK_IMPORTED_MODULE_5__/* .VaryingGLDefinition */ .W9(this, this.glType(), varying_name);
      const out_value = this.glVarName(_VaryingReadGlNode.OUTPUT_NAME);
      const body_line = `${this.glType()} ${out_value} = ${varying_name}`;
      shaders_collection_controller.addDefinitions(this, [definition]);
      shaders_collection_controller.addBodyLines(this, [body_line]);
    }
  }
  attributeName() {
    return this.pv.name.trim();
  }
  glType() {
    const connectionPoints = this.io.outputs.namedOutputConnectionPoints();
    return connectionPoints ? connectionPoints[0].type() : _utils_io_connections_Gl__WEBPACK_IMPORTED_MODULE_0__/* .GlConnectionPointType.FLOAT */ .Dv.FLOAT;
  }
  setGlType(type) {
    this.p.type.set(VARYING_NODE_AVAILABLE_GL_TYPES.indexOf(type));
  }
};
let VaryingReadGlNode = _VaryingReadGlNode;
VaryingReadGlNode.OUTPUT_NAME = "fragment";


/***/ }),

/***/ 21899:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "n": function() { return /* binding */ TexturePersistedConfig; }
/* harmony export */ });
/* harmony import */ var _utils_BasePersistedConfig__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(14802);
/* harmony import */ var _utils_GLParamConfig__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(28491);
/* harmony import */ var _cop_utils_BuilderUtils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(43306);

var __async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};



const FRAGMENT_KEY = "fragment";
class TexturePersistedConfig extends _utils_BasePersistedConfig__WEBPACK_IMPORTED_MODULE_0__/* .BasePersistedConfig */ .p {
  constructor(node) {
    super(node);
    this.node = node;
  }
  toData() {
    return __async(this, null, function* () {
      const assemblerController = this.node.assemblerController();
      if (!assemblerController) {
        return;
      }
      const param_uniform_pairs = [];
      const param_configs = assemblerController.assembler.param_configs();
      for (const param_config of param_configs) {
        param_uniform_pairs.push([param_config.name(), param_config.uniformName()]);
      }
      const data = {
        // fragment_shader: this.node.textureMaterial.fragmentShader,
        uniforms: this.node.textureMaterial.uniforms,
        param_uniform_pairs,
        uniforms_time_dependent: assemblerController.assembler.uniformsTimeDependent(),
        uniforms_resolution_dependent: assemblerController.assembler.uniformsResolutionDependent(),
        shaders: {
          [FRAGMENT_KEY]: this.node.textureMaterial.fragmentShader
        }
      };
      return data;
    });
  }
  load(data) {
    const assemblerController = this.node.assemblerController();
    if (assemblerController) {
      return;
    }
    this.node.textureMaterial.uniforms = data.uniforms;
    const shaders = data.shaders;
    if (shaders && shaders[FRAGMENT_KEY] != null) {
      this.node.textureMaterial.fragmentShader = shaders[FRAGMENT_KEY];
    } else {
      console.warn(`${this.node.path()}: persisted config has no fragment shader`);
    }
    (0,_cop_utils_BuilderUtils__WEBPACK_IMPORTED_MODULE_1__/* .handleCopBuilderDependencies */ .U)({
      node: this.node,
      timeDependent: data.uniforms_time_dependent || false,
      uniforms: data.uniforms
    });
    for (const pair of data.param_uniform_pairs) {
      const param = this.node.params.get(pair[0]);
      const uniform = data.uniforms[pair[1]];
      if (param && uniform) {
        const callback = () => {
          _utils_GLParamConfig__WEBPACK_IMPORTED_MODULE_2__/* .GlParamConfig.callback */ .b.callback(param, uniform);
        };
        param.options.set({
          callback
        });
        callback();
      }
    }
  }
}


/***/ }),

/***/ 67964:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "h": function() { return /* binding */ AnimationActionJsNode; }
/* harmony export */ });
/* harmony import */ var _Base__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(38231);
/* harmony import */ var _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(96949);
/* harmony import */ var _utils_io_connections_Js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(38857);
/* harmony import */ var _Poly__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(99934);





const CONNECTION_OPTIONS = _utils_io_connections_Js__WEBPACK_IMPORTED_MODULE_0__/* .JS_CONNECTION_POINT_IN_NODE_DEF */ .mX;
class AnimationActionJsParamsConfig extends _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .NodeParamsConfig */ .yI {
  constructor() {
    super(...arguments);
    this.clipName = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .ParamConfig.STRING */ .XC.STRING("");
    this.autoPlay = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .ParamConfig.BOOLEAN */ .XC.BOOLEAN(1);
  }
}
const ParamsConfig = new AnimationActionJsParamsConfig();
class AnimationActionJsNode extends _Base__WEBPACK_IMPORTED_MODULE_2__/* .TypedJsNode */ .xZ {
  constructor() {
    super(...arguments);
    this.paramsConfig = ParamsConfig;
  }
  static type() {
    return "animationAction";
  }
  initializeNode() {
    this.io.inputs.setNamedInputConnectionPoints([
      new _utils_io_connections_Js__WEBPACK_IMPORTED_MODULE_0__/* .JsConnectionPoint */ .fp(
        _utils_io_connections_Js__WEBPACK_IMPORTED_MODULE_0__/* .JsConnectionPointType.ANIMATION_MIXER */ .zF.ANIMATION_MIXER,
        _utils_io_connections_Js__WEBPACK_IMPORTED_MODULE_0__/* .JsConnectionPointType.ANIMATION_MIXER */ .zF.ANIMATION_MIXER,
        CONNECTION_OPTIONS
      )
    ]);
    this.io.outputs.setNamedOutputConnectionPoints([
      new _utils_io_connections_Js__WEBPACK_IMPORTED_MODULE_0__/* .JsConnectionPoint */ .fp(_utils_io_connections_Js__WEBPACK_IMPORTED_MODULE_0__/* .JsConnectionPointType.ANIMATION_ACTION */ .zF.ANIMATION_ACTION, _utils_io_connections_Js__WEBPACK_IMPORTED_MODULE_0__/* .JsConnectionPointType.ANIMATION_ACTION */ .zF.ANIMATION_ACTION)
    ]);
  }
  setLines(shadersCollectionController) {
    const mixer = this.variableForInput(shadersCollectionController, _utils_io_connections_Js__WEBPACK_IMPORTED_MODULE_0__/* .JsConnectionPointType.ANIMATION_MIXER */ .zF.ANIMATION_MIXER);
    const clipName = this.variableForInputParam(shadersCollectionController, this.p.clipName);
    const autoPlay = this.variableForInputParam(shadersCollectionController, this.p.autoPlay);
    const varName = this.jsVarName(_utils_io_connections_Js__WEBPACK_IMPORTED_MODULE_0__/* .JsConnectionPointType.ANIMATION_ACTION */ .zF.ANIMATION_ACTION);
    const func = _Poly__WEBPACK_IMPORTED_MODULE_3__/* .Poly.namedFunctionsRegister.getFunction */ .L.namedFunctionsRegister.getFunction("getAnimationAction", this, shadersCollectionController);
    shadersCollectionController.addBodyOrComputed(this, [
      { dataType: _utils_io_connections_Js__WEBPACK_IMPORTED_MODULE_0__/* .JsConnectionPointType.VECTOR3 */ .zF.VECTOR3, varName, value: func.asString(mixer, clipName, autoPlay) }
    ]);
  }
}
AnimationActionJsNode.OUTPUT_NAME = "val";


/***/ }),

/***/ 43284:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "R": function() { return /* binding */ ClothSolverStepSimulationJsNode; },
/* harmony export */   "W": function() { return /* binding */ ClothSolverStepSimulationOutput; }
/* harmony export */ });
/* harmony import */ var _Base__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(38231);
/* harmony import */ var _BaseObject3D__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(75807);
/* harmony import */ var _Poly__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(99934);
/* harmony import */ var _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(96949);
/* harmony import */ var _utils_JsDefinition__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(36343);
/* harmony import */ var _utils_io_connections_Js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(38857);







const CONNECTION_OPTIONS = _utils_io_connections_Js__WEBPACK_IMPORTED_MODULE_0__/* .JS_CONNECTION_POINT_IN_NODE_DEF */ .mX;
var ClothSolverStepSimulationOutput = /* @__PURE__ */ ((ClothSolverStepSimulationOutput2) => {
  ClothSolverStepSimulationOutput2["TEXTURE_SIZE"] = "tSize";
  ClothSolverStepSimulationOutput2["TEXTURE_POSITION0"] = "tPosition0";
  ClothSolverStepSimulationOutput2["TEXTURE_POSITION1"] = "tPosition1";
  ClothSolverStepSimulationOutput2["TEXTURE_NORMAL"] = "tNormal";
  ClothSolverStepSimulationOutput2["TEXTURE_ORIGINAL_RT"] = "tOriginalRT";
  ClothSolverStepSimulationOutput2["TEXTURE_VISCOSITY_SPRING_T"] = "tViscositySpringT";
  ClothSolverStepSimulationOutput2["TEXTURE_PREVIOUS_RT0"] = "tPreviousRT0";
  ClothSolverStepSimulationOutput2["TEXTURE_PREVIOUS_RT1"] = "tPreviousRT1";
  ClothSolverStepSimulationOutput2["TEXTURE_TARGET_RT0"] = "targetRT0";
  ClothSolverStepSimulationOutput2["TEXTURE_TARGET_RT1"] = "targetRT1";
  ClothSolverStepSimulationOutput2["TEXTURE_NORMALS_RT"] = "tNormalsRT";
  ClothSolverStepSimulationOutput2["TEXTURE_POSITION_RT0"] = "tPositionRT0";
  ClothSolverStepSimulationOutput2["TEXTURE_POSITION_RT1"] = "tPositionRT1";
  ClothSolverStepSimulationOutput2["TEXTURE_ADJACENT_RT0"] = "tAdjacentsRT0";
  ClothSolverStepSimulationOutput2["TEXTURE_ADJACENT_RT1"] = "tAdjacentsRT1";
  ClothSolverStepSimulationOutput2["TEXTURE_DISTANCE_RT0"] = "tDistanceRT0";
  ClothSolverStepSimulationOutput2["TEXTURE_DISTANCE_RT1"] = "tDistanceRT1";
  ClothSolverStepSimulationOutput2["MATERIAL_INTEGRATION"] = "integrationMat";
  return ClothSolverStepSimulationOutput2;
})(ClothSolverStepSimulationOutput || {});
class ClothSolverStepSimulationJsParamsConfig extends _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .NodeParamsConfig */ .yI {
  constructor() {
    super(...arguments);
    this.stepsCount = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .ParamConfig.INTEGER */ .XC.INTEGER(40, {
      range: [1, 100],
      rangeLocked: [true, false]
    });
    this.constraintInfluence = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .ParamConfig.FLOAT */ .XC.FLOAT(0.1, {
      range: [0, 2],
      rangeLocked: [true, false]
    });
    this.viscosity = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .ParamConfig.FLOAT */ .XC.FLOAT(0.1, {
      range: [0, 1],
      rangeLocked: [true, false]
    });
    this.spring = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .ParamConfig.FLOAT */ .XC.FLOAT(1, {
      range: [0, 1],
      rangeLocked: [true, false]
    });
  }
}
const ParamsConfig = new ClothSolverStepSimulationJsParamsConfig();
class ClothSolverStepSimulationJsNode extends _Base__WEBPACK_IMPORTED_MODULE_2__/* .TypedJsNode */ .xZ {
  constructor() {
    super(...arguments);
    this.paramsConfig = ParamsConfig;
  }
  static type() {
    return "clothSolverStepSimulation";
  }
  initializeNode() {
    this.io.inputs.setNamedInputConnectionPoints([
      new _utils_io_connections_Js__WEBPACK_IMPORTED_MODULE_0__/* .JsConnectionPoint */ .fp(_Base__WEBPACK_IMPORTED_MODULE_2__/* .TRIGGER_CONNECTION_NAME */ .w6, _utils_io_connections_Js__WEBPACK_IMPORTED_MODULE_0__/* .JsConnectionPointType.TRIGGER */ .zF.TRIGGER, CONNECTION_OPTIONS),
      new _utils_io_connections_Js__WEBPACK_IMPORTED_MODULE_0__/* .JsConnectionPoint */ .fp(_utils_io_connections_Js__WEBPACK_IMPORTED_MODULE_0__/* .JsConnectionPointType.OBJECT_3D */ .zF.OBJECT_3D, _utils_io_connections_Js__WEBPACK_IMPORTED_MODULE_0__/* .JsConnectionPointType.OBJECT_3D */ .zF.OBJECT_3D, CONNECTION_OPTIONS)
    ]);
    this.io.outputs.setNamedOutputConnectionPoints([
      new _utils_io_connections_Js__WEBPACK_IMPORTED_MODULE_0__/* .JsConnectionPoint */ .fp(_Base__WEBPACK_IMPORTED_MODULE_2__/* .TRIGGER_CONNECTION_NAME */ .w6, _utils_io_connections_Js__WEBPACK_IMPORTED_MODULE_0__/* .JsConnectionPointType.TRIGGER */ .zF.TRIGGER),
      new _utils_io_connections_Js__WEBPACK_IMPORTED_MODULE_0__/* .JsConnectionPoint */ .fp(_utils_io_connections_Js__WEBPACK_IMPORTED_MODULE_0__/* .JsConnectionPointType.OBJECT_3D */ .zF.OBJECT_3D, _utils_io_connections_Js__WEBPACK_IMPORTED_MODULE_0__/* .JsConnectionPointType.OBJECT_3D */ .zF.OBJECT_3D),
      new _utils_io_connections_Js__WEBPACK_IMPORTED_MODULE_0__/* .JsConnectionPoint */ .fp("tSize" /* TEXTURE_SIZE */, _utils_io_connections_Js__WEBPACK_IMPORTED_MODULE_0__/* .JsConnectionPointType.VECTOR2 */ .zF.VECTOR2),
      new _utils_io_connections_Js__WEBPACK_IMPORTED_MODULE_0__/* .JsConnectionPoint */ .fp("tPosition0" /* TEXTURE_POSITION0 */, _utils_io_connections_Js__WEBPACK_IMPORTED_MODULE_0__/* .JsConnectionPointType.TEXTURE */ .zF.TEXTURE),
      new _utils_io_connections_Js__WEBPACK_IMPORTED_MODULE_0__/* .JsConnectionPoint */ .fp("tPosition1" /* TEXTURE_POSITION1 */, _utils_io_connections_Js__WEBPACK_IMPORTED_MODULE_0__/* .JsConnectionPointType.TEXTURE */ .zF.TEXTURE),
      new _utils_io_connections_Js__WEBPACK_IMPORTED_MODULE_0__/* .JsConnectionPoint */ .fp("tNormal" /* TEXTURE_NORMAL */, _utils_io_connections_Js__WEBPACK_IMPORTED_MODULE_0__/* .JsConnectionPointType.TEXTURE */ .zF.TEXTURE),
      new _utils_io_connections_Js__WEBPACK_IMPORTED_MODULE_0__/* .JsConnectionPoint */ .fp("integrationMat" /* MATERIAL_INTEGRATION */, _utils_io_connections_Js__WEBPACK_IMPORTED_MODULE_0__/* .JsConnectionPointType.MATERIAL */ .zF.MATERIAL)
      //
      // ...ADDITIONAL_TEXTURE_OUTPUTS.map(
      // 	(outputName) => new JsConnectionPoint(outputName, JsConnectionPointType.TEXTURE)
      // ),
    ]);
  }
  setLines(linesController) {
    this._addRefs(linesController);
    (0,_BaseObject3D__WEBPACK_IMPORTED_MODULE_3__/* .setObject3DOutputLine */ .PV)(this, linesController);
  }
  setTriggerableLines(linesController) {
    const object3D = (0,_BaseObject3D__WEBPACK_IMPORTED_MODULE_3__/* .inputObject3D */ .iv)(this, linesController);
    const stepsCount = this.variableForInputParam(linesController, this.p.stepsCount);
    const constraintInfluence = this.variableForInputParam(linesController, this.p.constraintInfluence);
    const viscosity = this.variableForInputParam(linesController, this.p.viscosity);
    const spring = this.variableForInputParam(linesController, this.p.spring);
    const configRef = this._addRefs(linesController);
    const func = _Poly__WEBPACK_IMPORTED_MODULE_4__/* .Poly.namedFunctionsRegister.getFunction */ .L.namedFunctionsRegister.getFunction("clothSolverStepSimulation", this, linesController);
    const bodyLine = func.asString(
      object3D,
      stepsCount,
      constraintInfluence,
      viscosity,
      spring,
      this._refToString(configRef)
    );
    linesController.addTriggerableLines(this, [bodyLine]);
  }
  _refToString(refs) {
    const keys = Object.keys(refs);
    const data = [];
    for (const key of keys) {
      data.push(`${key}:this.${refs[key]}`);
    }
    return `{${data.join(",")}}`;
  }
  _addRefs(linesController) {
    const tSize = this.jsVarName("tSize" /* TEXTURE_SIZE */);
    const tPosition0 = this.jsVarName("tPosition0" /* TEXTURE_POSITION0 */);
    const tPosition1 = this.jsVarName("tPosition1" /* TEXTURE_POSITION1 */);
    const tNormal = this.jsVarName("tNormal" /* TEXTURE_NORMAL */);
    const tOriginalRT = this.jsVarName("tOriginalRT" /* TEXTURE_ORIGINAL_RT */);
    const tViscositySpringT = this.jsVarName("tViscositySpringT" /* TEXTURE_VISCOSITY_SPRING_T */);
    const tPreviousRT0 = this.jsVarName("tPreviousRT0" /* TEXTURE_PREVIOUS_RT0 */);
    const tPreviousRT1 = this.jsVarName("tPreviousRT1" /* TEXTURE_PREVIOUS_RT1 */);
    const tTargetRT0 = this.jsVarName("targetRT0" /* TEXTURE_TARGET_RT0 */);
    const tTargetRT1 = this.jsVarName("targetRT1" /* TEXTURE_TARGET_RT1 */);
    const tNormalsRT = this.jsVarName("tNormalsRT" /* TEXTURE_NORMALS_RT */);
    const tPositionRT0 = this.jsVarName("tPositionRT0" /* TEXTURE_POSITION_RT0 */);
    const tPositionRT1 = this.jsVarName("tPositionRT1" /* TEXTURE_POSITION_RT1 */);
    const tAdjacentsRT0 = this.jsVarName("tAdjacentsRT0" /* TEXTURE_ADJACENT_RT0 */);
    const tAdjacentsRT1 = this.jsVarName("tAdjacentsRT1" /* TEXTURE_ADJACENT_RT1 */);
    const tDistanceRT0 = this.jsVarName("tDistanceRT0" /* TEXTURE_DISTANCE_RT0 */);
    const tDistanceRT1 = this.jsVarName("tDistanceRT1" /* TEXTURE_DISTANCE_RT1 */);
    const integrationMat = this.jsVarName("integrationMat" /* MATERIAL_INTEGRATION */);
    linesController.addDefinitions(this, [
      new _utils_JsDefinition__WEBPACK_IMPORTED_MODULE_5__/* .ConstantJsDefinition */ .mF(this, linesController, _utils_io_connections_Js__WEBPACK_IMPORTED_MODULE_0__/* .JsConnectionPointType.VECTOR2 */ .zF.VECTOR2, tSize, `null`)
    ]);
    const textures = [
      tPosition0,
      tPosition1,
      tNormal,
      //
      tOriginalRT,
      tViscositySpringT,
      tPreviousRT0,
      tPreviousRT1,
      tTargetRT0,
      tTargetRT1,
      tNormalsRT,
      tPositionRT0,
      tPositionRT1,
      tAdjacentsRT0,
      tAdjacentsRT1,
      tDistanceRT0,
      tDistanceRT1
    ];
    const materials = [integrationMat];
    for (const texture of textures) {
      linesController.addDefinitions(this, [
        new _utils_JsDefinition__WEBPACK_IMPORTED_MODULE_5__/* .ConstantJsDefinition */ .mF(this, linesController, _utils_io_connections_Js__WEBPACK_IMPORTED_MODULE_0__/* .JsConnectionPointType.TEXTURE */ .zF.TEXTURE, texture, `null`)
      ]);
    }
    for (const material of materials) {
      linesController.addDefinitions(this, [
        new _utils_JsDefinition__WEBPACK_IMPORTED_MODULE_5__/* .ConstantJsDefinition */ .mF(this, linesController, _utils_io_connections_Js__WEBPACK_IMPORTED_MODULE_0__/* .JsConnectionPointType.MATERIAL */ .zF.MATERIAL, material, `null`)
      ]);
    }
    const ref = {
      tSize,
      tPosition0,
      tPosition1,
      tNormal,
      tOriginalRT,
      tViscositySpringT,
      tPreviousRT0,
      tPreviousRT1,
      tTargetRT0,
      tTargetRT1,
      tNormalsRT,
      tPositionRT0,
      tPositionRT1,
      tAdjacentsRT0,
      tAdjacentsRT1,
      tDistanceRT0,
      tDistanceRT1,
      integrationMat
    };
    return ref;
  }
}


/***/ }),

/***/ 4561:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "_": function() { return /* binding */ CompareJsNode; }
/* harmony export */ });
/* unused harmony export JsCompareTestName */
/* harmony import */ var _Base__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(38231);
/* harmony import */ var _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(96949);
/* harmony import */ var _utils_io_connections_Js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(38857);
/* harmony import */ var _code_assemblers_BaseJsPersistedConfigUtils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(99463);
/* harmony import */ var _functions_VectorUtils__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(15938);






const ALLOWED_TYPES = [
  _utils_io_connections_Js__WEBPACK_IMPORTED_MODULE_0__/* .JsConnectionPointType.BOOLEAN */ .zF.BOOLEAN,
  _utils_io_connections_Js__WEBPACK_IMPORTED_MODULE_0__/* .JsConnectionPointType.INT */ .zF.INT,
  _utils_io_connections_Js__WEBPACK_IMPORTED_MODULE_0__/* .JsConnectionPointType.COLOR */ .zF.COLOR,
  _utils_io_connections_Js__WEBPACK_IMPORTED_MODULE_0__/* .JsConnectionPointType.FLOAT */ .zF.FLOAT,
  _utils_io_connections_Js__WEBPACK_IMPORTED_MODULE_0__/* .JsConnectionPointType.STRING */ .zF.STRING,
  _utils_io_connections_Js__WEBPACK_IMPORTED_MODULE_0__/* .JsConnectionPointType.VECTOR2 */ .zF.VECTOR2,
  _utils_io_connections_Js__WEBPACK_IMPORTED_MODULE_0__/* .JsConnectionPointType.VECTOR3 */ .zF.VECTOR3,
  _utils_io_connections_Js__WEBPACK_IMPORTED_MODULE_0__/* .JsConnectionPointType.VECTOR4 */ .zF.VECTOR4
];
var JsCompareTestName = /* @__PURE__ */ ((JsCompareTestName2) => {
  JsCompareTestName2["EQUAL"] = "Equal";
  JsCompareTestName2["LESS_THAN"] = "Less Than";
  JsCompareTestName2["GREATER_THAN"] = "Greater Than";
  JsCompareTestName2["LESS_THAN_OR_EQUAL"] = "Less Than Or Equal";
  JsCompareTestName2["GREATER_THAN_OR_EQUAL"] = "Greater Than Or Equal";
  JsCompareTestName2["NOT_EQUAL"] = "Not Equal";
  return JsCompareTestName2;
})(JsCompareTestName || {});
var JsCompareTestOperation = /* @__PURE__ */ ((JsCompareTestOperation2) => {
  JsCompareTestOperation2["EQUAL"] = "==";
  JsCompareTestOperation2["LESS_THAN"] = "<";
  JsCompareTestOperation2["GREATER_THAN"] = ">";
  JsCompareTestOperation2["LESS_THAN_OR_EQUAL"] = "<=";
  JsCompareTestOperation2["GREATER_THAN_OR_EQUAL"] = ">=";
  JsCompareTestOperation2["NOT_EQUAL"] = "!=";
  return JsCompareTestOperation2;
})(JsCompareTestOperation || {});
const TEST_NAMES = [
  "Equal" /* EQUAL */,
  "Less Than" /* LESS_THAN */,
  "Greater Than" /* GREATER_THAN */,
  "Less Than Or Equal" /* LESS_THAN_OR_EQUAL */,
  "Greater Than Or Equal" /* GREATER_THAN_OR_EQUAL */,
  "Not Equal" /* NOT_EQUAL */
];
const TEST_OPERATIONS_FLOAT = [
  "==" /* EQUAL */,
  "<" /* LESS_THAN */,
  ">" /* GREATER_THAN */,
  "<=" /* LESS_THAN_OR_EQUAL */,
  ">=" /* GREATER_THAN_OR_EQUAL */,
  "!=" /* NOT_EQUAL */
];
function singleElementComparison(value0, value1, operation) {
  return `${value0} ${operation} ${value1}`;
}
const OUTPUT_NAME = "val";
var CompareInputName = /* @__PURE__ */ ((CompareInputName2) => {
  CompareInputName2["VALUE0"] = "value0";
  CompareInputName2["VALUE1"] = "value1";
  return CompareInputName2;
})(CompareInputName || {});
class CompareJsParamsConfig extends _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .NodeParamsConfig */ .yI {
  constructor() {
    super(...arguments);
    this.test = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .ParamConfig.INTEGER */ .XC.INTEGER(1, {
      menu: {
        entries: TEST_NAMES.map((name, i) => {
          const operator = TEST_OPERATIONS_FLOAT[i];
          const label = `${operator.padEnd(2, " ")} (${name})`;
          return { name: label, value: i };
        })
      }
    });
  }
}
const ParamsConfig = new CompareJsParamsConfig();
class CompareJsNode extends _Base__WEBPACK_IMPORTED_MODULE_2__/* .TypedJsNode */ .xZ {
  constructor() {
    super(...arguments);
    this.paramsConfig = ParamsConfig;
  }
  static type() {
    return "compare";
  }
  initializeNode() {
    super.initializeNode();
    this.io.connection_points.spare_params.setInputlessParamNames(["test"]);
    this.io.connection_points.initializeNode();
    this.io.connection_points.set_input_name_function(this._expectedInputName.bind(this));
    this.io.connection_points.set_output_name_function(this._expectedOutputName.bind(this));
    this.io.connection_points.set_expected_input_types_function(this._expectedInputTypes.bind(this));
    this.io.connection_points.set_expected_output_types_function(this._expectedOutputTypes.bind(this));
  }
  setTestName(test) {
    this.p.test.set(TEST_NAMES.indexOf(test));
  }
  testName() {
    return TEST_NAMES[this.pv.test];
  }
  operator() {
    return TEST_OPERATIONS_FLOAT[this.pv.test];
  }
  _expectedInputName(index) {
    return ["value0" /* VALUE0 */, "value1" /* VALUE1 */][index];
  }
  _expectedInputTypes() {
    let first_input_type = this.io.connection_points.first_input_connection_type();
    const connectionPoints = this.io.inputs.namedInputConnectionPoints();
    if (first_input_type && connectionPoints) {
      if (!ALLOWED_TYPES.includes(first_input_type)) {
        const first_connection = connectionPoints[0];
        if (first_connection) {
          first_input_type = first_connection.type();
        }
      }
    }
    const type = first_input_type || _utils_io_connections_Js__WEBPACK_IMPORTED_MODULE_0__/* .JsConnectionPointType.FLOAT */ .zF.FLOAT;
    const boundType = _utils_io_connections_Js__WEBPACK_IMPORTED_MODULE_0__/* .JsConnectionPointTypeFromArrayTypeMap */ .RR[type];
    return [type, boundType];
  }
  _expectedOutputTypes() {
    return [_utils_io_connections_Js__WEBPACK_IMPORTED_MODULE_0__/* .JsConnectionPointType.BOOLEAN */ .zF.BOOLEAN];
  }
  _expectedOutputName(index) {
    return OUTPUT_NAME;
  }
  setLines(shadersCollectionController) {
    const varName = this.jsVarName(this._expectedOutputName(0));
    const inputType = this._expectedInputTypes()[0];
    const variable = (0,_code_assemblers_BaseJsPersistedConfigUtils__WEBPACK_IMPORTED_MODULE_3__/* .createVariable */ .Os)(inputType);
    if (variable) {
      shadersCollectionController.addVariable(this, variable);
    }
    const operation = this.operator();
    const value0 = this.variableForInput(shadersCollectionController, "value0" /* VALUE0 */);
    const value1 = this.variableForInput(shadersCollectionController, "value1" /* VALUE1 */);
    const components = (0,_functions_VectorUtils__WEBPACK_IMPORTED_MODULE_4__/* .componentsForType */ .HM)(inputType);
    const mainFunction = components != null && components.length > 0 ? components.map((c) => singleElementComparison(`${value0}.${c}`, `${value1}.${c}`, operation)).join(" && ") : singleElementComparison(value0, value1, operation);
    shadersCollectionController.addBodyOrComputed(this, [{ dataType: inputType, varName, value: mainFunction }]);
  }
}


/***/ }),

/***/ 34253:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "g": function() { return /* binding */ ConstantJsNode; }
/* harmony export */ });
/* harmony import */ var _Base__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(38231);
/* harmony import */ var _core_ThreeToGl__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(81556);
/* harmony import */ var _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(96949);
/* harmony import */ var _core_Type__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(19037);
/* harmony import */ var _utils_io_connections_Js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(38857);
/* harmony import */ var _utils_JsDefinition__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(36343);

var __defProp = Object.defineProperty;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};






function typedVisibleOptions(type, otherParamVal = {}) {
  const val = _utils_io_connections_Js__WEBPACK_IMPORTED_MODULE_0__/* .JS_CONNECTION_TYPES_FOR_CONSTANT.indexOf */ .RO.indexOf(type);
  return { visibleIf: __spreadValues({ type: val }, otherParamVal) };
}
class ConstantJsParamsConfig extends _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .NodeParamsConfig */ .yI {
  constructor() {
    super(...arguments);
    this.type = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .ParamConfig.INTEGER */ .XC.INTEGER(_utils_io_connections_Js__WEBPACK_IMPORTED_MODULE_0__/* .JS_CONNECTION_TYPES_FOR_CONSTANT.indexOf */ .RO.indexOf(_utils_io_connections_Js__WEBPACK_IMPORTED_MODULE_0__/* .JsConnectionPointType.FLOAT */ .zF.FLOAT), {
      menu: {
        entries: _utils_io_connections_Js__WEBPACK_IMPORTED_MODULE_0__/* .JS_CONNECTION_TYPES_FOR_CONSTANT.map */ .RO.map((name, i) => {
          return { name, value: i };
        })
      }
    });
    this.boolean = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .ParamConfig.BOOLEAN */ .XC.BOOLEAN(0, typedVisibleOptions(_utils_io_connections_Js__WEBPACK_IMPORTED_MODULE_0__/* .JsConnectionPointType.BOOLEAN */ .zF.BOOLEAN));
    this.color = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .ParamConfig.COLOR */ .XC.COLOR([0, 0, 0], typedVisibleOptions(_utils_io_connections_Js__WEBPACK_IMPORTED_MODULE_0__/* .JsConnectionPointType.COLOR */ .zF.COLOR));
    this.float = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .ParamConfig.FLOAT */ .XC.FLOAT(0, typedVisibleOptions(_utils_io_connections_Js__WEBPACK_IMPORTED_MODULE_0__/* .JsConnectionPointType.FLOAT */ .zF.FLOAT));
    this.int = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .ParamConfig.INTEGER */ .XC.INTEGER(0, typedVisibleOptions(_utils_io_connections_Js__WEBPACK_IMPORTED_MODULE_0__/* .JsConnectionPointType.INT */ .zF.INT));
    this.string = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .ParamConfig.STRING */ .XC.STRING("", typedVisibleOptions(_utils_io_connections_Js__WEBPACK_IMPORTED_MODULE_0__/* .JsConnectionPointType.STRING */ .zF.STRING));
    this.vector2 = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .ParamConfig.VECTOR2 */ .XC.VECTOR2([0, 0], typedVisibleOptions(_utils_io_connections_Js__WEBPACK_IMPORTED_MODULE_0__/* .JsConnectionPointType.VECTOR2 */ .zF.VECTOR2));
    this.vector3 = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .ParamConfig.VECTOR3 */ .XC.VECTOR3([0, 0, 0], typedVisibleOptions(_utils_io_connections_Js__WEBPACK_IMPORTED_MODULE_0__/* .JsConnectionPointType.VECTOR3 */ .zF.VECTOR3));
    this.vector4 = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .ParamConfig.VECTOR4 */ .XC.VECTOR4([0, 0, 0, 0], typedVisibleOptions(_utils_io_connections_Js__WEBPACK_IMPORTED_MODULE_0__/* .JsConnectionPointType.VECTOR4 */ .zF.VECTOR4));
  }
}
const ParamsConfig = new ConstantJsParamsConfig();
const _ConstantJsNode = class extends _Base__WEBPACK_IMPORTED_MODULE_2__/* .TypedJsNode */ .xZ {
  constructor() {
    super(...arguments);
    this.paramsConfig = ParamsConfig;
  }
  static type() {
    return "constant";
  }
  initializeNode() {
    this.io.connection_points.set_output_name_function((index) => _ConstantJsNode.OUTPUT_NAME);
    this.io.connection_points.set_expected_input_types_function(() => []);
    this.io.connection_points.set_expected_output_types_function(() => [this._currentConnectionType()]);
  }
  setLines(linesController) {
    const param = this.currentParam();
    if (!param) {
      console.warn(`no param found for constant node for type '${this.pv.type}'`);
      return;
    }
    const value = this.currentValue();
    if (value == null) {
      console.warn(`no value found for constant node for type '${this.pv.type}'`);
      return;
    }
    const out = this.jsVarName(_ConstantJsNode.OUTPUT_NAME);
    const varName = this.variableForInputParam(linesController, param);
    linesController.addDefinitions(this, [
      new _utils_JsDefinition__WEBPACK_IMPORTED_MODULE_3__/* .ConstantJsDefinition */ .mF(this, linesController, this._currentConnectionType(), out, varName)
    ]);
  }
  _currentConnectionType() {
    if (this.pv.type == null) {
      console.warn("constant gl node type is null", this.path());
    }
    const connectionType = _utils_io_connections_Js__WEBPACK_IMPORTED_MODULE_0__/* .JS_CONNECTION_TYPES_FOR_CONSTANT */ .RO[this.pv.type] || _utils_io_connections_Js__WEBPACK_IMPORTED_MODULE_0__/* .JsConnectionPointType.FLOAT */ .zF.FLOAT;
    if (connectionType == null) {
      console.warn(`constant gl node type if not valid (${this.pv.type})`, this.path());
    }
    return connectionType;
  }
  currentParam() {
    const type = _utils_io_connections_Js__WEBPACK_IMPORTED_MODULE_0__/* .JS_CONNECTION_TYPES_FOR_CONSTANT */ .RO[this.pv.type];
    switch (type) {
      case _utils_io_connections_Js__WEBPACK_IMPORTED_MODULE_0__/* .JsConnectionPointType.BOOLEAN */ .zF.BOOLEAN: {
        return this.p.boolean;
      }
      case _utils_io_connections_Js__WEBPACK_IMPORTED_MODULE_0__/* .JsConnectionPointType.COLOR */ .zF.COLOR: {
        return this.p.color;
      }
      case _utils_io_connections_Js__WEBPACK_IMPORTED_MODULE_0__/* .JsConnectionPointType.FLOAT */ .zF.FLOAT: {
        return this.p.float;
      }
      case _utils_io_connections_Js__WEBPACK_IMPORTED_MODULE_0__/* .JsConnectionPointType.INT */ .zF.INT: {
        return this.p.int;
      }
      case _utils_io_connections_Js__WEBPACK_IMPORTED_MODULE_0__/* .JsConnectionPointType.STRING */ .zF.STRING: {
        return this.p.string;
      }
      case _utils_io_connections_Js__WEBPACK_IMPORTED_MODULE_0__/* .JsConnectionPointType.VECTOR2 */ .zF.VECTOR2: {
        return this.p.vector2;
      }
      case _utils_io_connections_Js__WEBPACK_IMPORTED_MODULE_0__/* .JsConnectionPointType.VECTOR3 */ .zF.VECTOR3: {
        return this.p.vector3;
      }
      case _utils_io_connections_Js__WEBPACK_IMPORTED_MODULE_0__/* .JsConnectionPointType.VECTOR4 */ .zF.VECTOR4: {
        return this.p.vector4;
      }
    }
    console.warn(`constant with type '${type}' not yet implemented`);
    return this.p.boolean;
  }
  // private _currentVarName(): string {
  // 	return this.jsVarName(ConstantJsNode.OUTPUT_NAME);
  // }
  currentValue() {
    const param = this.currentParam();
    if (param) {
      let value = _core_ThreeToGl__WEBPACK_IMPORTED_MODULE_4__/* .ThreeToGl.any */ ._.any(param.value);
      if (param.name() == this.p.int.name() && _core_Type__WEBPACK_IMPORTED_MODULE_5__/* .CoreType.isNumber */ .MR.isNumber(param.value)) {
        value = _core_ThreeToGl__WEBPACK_IMPORTED_MODULE_4__/* .ThreeToGl.integer */ ._.integer(param.value);
      }
      return value;
    }
  }
  setJsType(type) {
    this.p.type.set(_utils_io_connections_Js__WEBPACK_IMPORTED_MODULE_0__/* .JS_CONNECTION_TYPES_FOR_CONSTANT.indexOf */ .RO.indexOf(type));
  }
};
let ConstantJsNode = _ConstantJsNode;
ConstantJsNode.OUTPUT_NAME = "val";


/***/ }),

/***/ 30645:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "T": function() { return /* binding */ CursorJsNode; }
/* harmony export */ });
/* harmony import */ var _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(96949);
/* harmony import */ var _utils_io_connections_Js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(38857);
/* harmony import */ var _poly_registers_nodes_types_Js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(16718);
/* harmony import */ var _BaseUserInput__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(78433);
/* harmony import */ var _core_event_CoreEventEmitter__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(9913);
/* harmony import */ var _utils_JsDefinition__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(36343);
/* harmony import */ var _Poly__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(99934);
/* harmony import */ var _core_event_PointerEventType__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(43843);

var __defProp = Object.defineProperty;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};








const OUTPUT_NAME = "cursor";
class CursorJsParamsConfig extends _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_0__/* .NodeParamsConfig */ .yI {
  constructor() {
    super(...arguments);
    /** @param set which element triggers the event */
    this.element = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_0__/* .ParamConfig.INTEGER */ .XC.INTEGER(_core_event_CoreEventEmitter__WEBPACK_IMPORTED_MODULE_1__/* .EVENT_EMITTERS.indexOf */ .Br.indexOf(_core_event_CoreEventEmitter__WEBPACK_IMPORTED_MODULE_1__/* .CoreEventEmitter.CANVAS */ .Ok.CANVAS), __spreadValues({}, _core_event_CoreEventEmitter__WEBPACK_IMPORTED_MODULE_1__/* .EVENT_EMITTER_PARAM_MENU_OPTIONS */ .lh));
  }
  /** @param cursor */
  // cursor = ParamConfig.VECTOR2([0, 0]);
}
const ParamsConfig = new CursorJsParamsConfig();
class CursorJsNode extends _BaseUserInput__WEBPACK_IMPORTED_MODULE_2__/* .BaseUserInputJsNode */ .U {
  constructor() {
    super(...arguments);
    this.paramsConfig = ParamsConfig;
  }
  static type() {
    return _poly_registers_nodes_types_Js__WEBPACK_IMPORTED_MODULE_3__/* .JsType.CURSOR */ .K.CURSOR;
  }
  // userInputEventNames() {
  // 	return ['pointermove'];
  // }
  eventData() {
    return {
      type: _core_event_PointerEventType__WEBPACK_IMPORTED_MODULE_4__/* .PointerEventType.pointermove */ .by.pointermove,
      emitter: this.eventEmitter(),
      jsType: _poly_registers_nodes_types_Js__WEBPACK_IMPORTED_MODULE_3__/* .JsType.CURSOR */ .K.CURSOR
    };
  }
  eventEmitter() {
    return _core_event_CoreEventEmitter__WEBPACK_IMPORTED_MODULE_1__/* .EVENT_EMITTERS */ .Br[this.pv.element];
  }
  setEventEmitter(emitter) {
    this.p.element.set(_core_event_CoreEventEmitter__WEBPACK_IMPORTED_MODULE_1__/* .EVENT_EMITTERS.indexOf */ .Br.indexOf(emitter));
  }
  initializeNode() {
    this.io.connection_points.spare_params.setInputlessParamNames(["element"]);
    this.io.outputs.setNamedOutputConnectionPoints([
      new _utils_io_connections_Js__WEBPACK_IMPORTED_MODULE_5__/* .JsConnectionPoint */ .fp(OUTPUT_NAME, _utils_io_connections_Js__WEBPACK_IMPORTED_MODULE_5__/* .JsConnectionPointType.VECTOR2 */ .zF.VECTOR2)
    ]);
  }
  setLines(shadersCollectionController) {
    const out = this.jsVarName(OUTPUT_NAME);
    const _cursor = _Poly__WEBPACK_IMPORTED_MODULE_6__/* .Poly.namedFunctionsRegister.getFunction */ .L.namedFunctionsRegister.getFunction("globalsCursor", this, shadersCollectionController);
    shadersCollectionController.addDefinitions(this, [
      new _utils_JsDefinition__WEBPACK_IMPORTED_MODULE_7__/* .ComputedValueJsDefinition */ .fV(
        this,
        shadersCollectionController,
        _utils_io_connections_Js__WEBPACK_IMPORTED_MODULE_5__/* .JsConnectionPointType.VECTOR2 */ .zF.VECTOR2,
        out,
        _cursor.asString()
      )
    ]);
  }
}


/***/ }),

/***/ 61038:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "H": function() { return /* binding */ EasingJsNode; }
/* harmony export */ });
/* harmony import */ var _utils_io_connections_Js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(38857);
/* harmony import */ var _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(96949);
/* harmony import */ var _Base__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(38231);
/* harmony import */ var _core_math_Easing__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(71971);
/* harmony import */ var _code_assemblers_BaseJsPersistedConfigUtils__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(99463);
/* harmony import */ var _Poly__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(99934);
/* harmony import */ var _functions_MathGeneric__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(55681);








const ALLOWED_INPUTS = [
  _utils_io_connections_Js__WEBPACK_IMPORTED_MODULE_0__/* .JsConnectionPointType.FLOAT */ .zF.FLOAT,
  _utils_io_connections_Js__WEBPACK_IMPORTED_MODULE_0__/* .JsConnectionPointType.VECTOR2 */ .zF.VECTOR2,
  _utils_io_connections_Js__WEBPACK_IMPORTED_MODULE_0__/* .JsConnectionPointType.VECTOR3 */ .zF.VECTOR3,
  _utils_io_connections_Js__WEBPACK_IMPORTED_MODULE_0__/* .JsConnectionPointType.VECTOR4 */ .zF.VECTOR4
];
const INPUT_NAME = "in";
const OUTPUT_NAME = "out";
const defaultEaseType = _core_math_Easing__WEBPACK_IMPORTED_MODULE_1__/* .EASING_NAMES.indexOf */ .RP.indexOf("easeIO3");
class EasingJsParamsConfig extends _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_2__/* .NodeParamsConfig */ .yI {
  constructor() {
    super(...arguments);
    this.type = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_2__/* .ParamConfig.INTEGER */ .XC.INTEGER(defaultEaseType, {
      menu: {
        entries: _core_math_Easing__WEBPACK_IMPORTED_MODULE_1__/* .EASING_NAMES.map */ .RP.map((name, i) => {
          return { name, value: i };
        })
      }
    });
  }
  // input = ParamConfig.FLOAT(0);
}
const ParamsConfig = new EasingJsParamsConfig();
class EasingJsNode extends _Base__WEBPACK_IMPORTED_MODULE_3__/* .TypedJsNode */ .xZ {
  constructor() {
    super(...arguments);
    this.paramsConfig = ParamsConfig;
  }
  static type() {
    return "easing";
  }
  initializeNode() {
    super.initializeNode();
    this.io.connection_points.spare_params.setInputlessParamNames(["type"]);
    this.io.connection_points.set_expected_input_types_function(this._expectedInputTypes.bind(this));
    this.io.connection_points.set_expected_output_types_function(this._expectedOutputTypes.bind(this));
    this.io.connection_points.set_input_name_function(this._expectedInputName.bind(this));
    this.io.connection_points.set_output_name_function(this._expectedOutputName.bind(this));
    this.io.outputs.setNamedOutputConnectionPoints([
      new _utils_io_connections_Js__WEBPACK_IMPORTED_MODULE_0__/* .JsConnectionPoint */ .fp(OUTPUT_NAME, _utils_io_connections_Js__WEBPACK_IMPORTED_MODULE_0__/* .JsConnectionPointType.FLOAT */ .zF.FLOAT)
    ]);
  }
  _expectedInputTypes() {
    const type = this.io.connection_points.first_input_connection_type() || _utils_io_connections_Js__WEBPACK_IMPORTED_MODULE_0__/* .JsConnectionPointType.FLOAT */ .zF.FLOAT;
    if (ALLOWED_INPUTS.includes(type)) {
      return [type];
    } else {
      return [_utils_io_connections_Js__WEBPACK_IMPORTED_MODULE_0__/* .JsConnectionPointType.FLOAT */ .zF.FLOAT];
    }
  }
  _expectedOutputTypes() {
    return [this._expectedInputTypes()[0]];
  }
  _expectedInputName(index) {
    return INPUT_NAME;
  }
  _expectedOutputName(index) {
    return OUTPUT_NAME;
  }
  setLines(shadersCollectionController) {
    const varName = this.jsVarName(this._expectedOutputName(0));
    const inputType = this._expectedInputTypes()[0];
    const variable = (0,_code_assemblers_BaseJsPersistedConfigUtils__WEBPACK_IMPORTED_MODULE_4__/* .createVariable */ .Os)(inputType);
    const tmpVarName = variable ? shadersCollectionController.addVariable(this, variable) : void 0;
    const inputValue = this.variableForInput(shadersCollectionController, INPUT_NAME);
    const functionName = _core_math_Easing__WEBPACK_IMPORTED_MODULE_1__/* .EASING_NAMES */ .RP[this.pv.type];
    const func = _Poly__WEBPACK_IMPORTED_MODULE_5__/* .Poly.namedFunctionsRegister.getFunction */ .L.namedFunctionsRegister.getFunction(functionName, this, shadersCollectionController);
    const isPrimitive = (0,_utils_io_connections_Js__WEBPACK_IMPORTED_MODULE_0__/* .isJsConnectionPointPrimitive */ .wY)(inputType);
    if (isPrimitive) {
      return shadersCollectionController.addBodyOrComputed(this, [
        { dataType: _utils_io_connections_Js__WEBPACK_IMPORTED_MODULE_0__/* .JsConnectionPointType.FLOAT */ .zF.FLOAT, varName, value: func.asString(inputValue) }
      ]);
    }
    const vectorFunctionName = (0,_functions_MathGeneric__WEBPACK_IMPORTED_MODULE_6__/* ._vectorFunctionName_1 */ .vr)(inputType);
    if (vectorFunctionName && tmpVarName) {
      func.asString("");
      const vectorFunc = _Poly__WEBPACK_IMPORTED_MODULE_5__/* .Poly.namedFunctionsRegister.getFunction */ .L.namedFunctionsRegister.getFunction(
        vectorFunctionName,
        this,
        shadersCollectionController
      );
      return shadersCollectionController.addBodyOrComputed(this, [
        {
          dataType: _utils_io_connections_Js__WEBPACK_IMPORTED_MODULE_0__/* .JsConnectionPointType.FLOAT */ .zF.FLOAT,
          varName,
          value: vectorFunc.asString(...[functionName, inputValue, tmpVarName])
        }
      ]);
    }
  }
}


/***/ }),

/***/ 90223:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "s": function() { return /* binding */ GetGeometryNodeObjectsJsNode; }
/* harmony export */ });
/* harmony import */ var _Base__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(38231);
/* harmony import */ var _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(96949);
/* harmony import */ var _utils_io_connections_Js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(38857);
/* harmony import */ var _Poly__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(99934);
/* harmony import */ var _utils_JsDefinition__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(36343);
/* harmony import */ var _BaseObject3D__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(75807);







const CONNECTION_OPTIONS = _utils_io_connections_Js__WEBPACK_IMPORTED_MODULE_0__/* .JS_CONNECTION_POINT_IN_NODE_DEF */ .mX;
class GetGeometryNodeObjectsJsParamsConfig extends _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .NodeParamsConfig */ .yI {
  /** @param geometry node */
  // Node = ParamConfig.NODE_PATH('', {
  // 	nodeSelection: {
  // 		context: NodeContext.SOP,
  // 	},
  // 	dependentOnFoundNode: false,
  // 	computeOnDirty: true,
  // });
}
const ParamsConfig = new GetGeometryNodeObjectsJsParamsConfig();
class GetGeometryNodeObjectsJsNode extends _Base__WEBPACK_IMPORTED_MODULE_2__/* .TypedJsNode */ .xZ {
  constructor() {
    super(...arguments);
    this.paramsConfig = ParamsConfig;
  }
  static type() {
    return "getGeometryNodeObjects";
  }
  initializeNode() {
    this.io.inputs.setNamedInputConnectionPoints([
      new _utils_io_connections_Js__WEBPACK_IMPORTED_MODULE_0__/* .JsConnectionPoint */ .fp(_utils_io_connections_Js__WEBPACK_IMPORTED_MODULE_0__/* .JsConnectionPointType.TRIGGER */ .zF.TRIGGER, _utils_io_connections_Js__WEBPACK_IMPORTED_MODULE_0__/* .JsConnectionPointType.TRIGGER */ .zF.TRIGGER, CONNECTION_OPTIONS),
      new _utils_io_connections_Js__WEBPACK_IMPORTED_MODULE_0__/* .JsConnectionPoint */ .fp(_utils_io_connections_Js__WEBPACK_IMPORTED_MODULE_0__/* .JsConnectionPointType.NODE */ .zF.NODE, _utils_io_connections_Js__WEBPACK_IMPORTED_MODULE_0__/* .JsConnectionPointType.NODE */ .zF.NODE, CONNECTION_OPTIONS)
    ]);
    this.io.outputs.setNamedOutputConnectionPoints([
      new _utils_io_connections_Js__WEBPACK_IMPORTED_MODULE_0__/* .JsConnectionPoint */ .fp(_utils_io_connections_Js__WEBPACK_IMPORTED_MODULE_0__/* .JsConnectionPointType.TRIGGER */ .zF.TRIGGER, _utils_io_connections_Js__WEBPACK_IMPORTED_MODULE_0__/* .JsConnectionPointType.TRIGGER */ .zF.TRIGGER, CONNECTION_OPTIONS),
      new _utils_io_connections_Js__WEBPACK_IMPORTED_MODULE_0__/* .JsConnectionPoint */ .fp(_utils_io_connections_Js__WEBPACK_IMPORTED_MODULE_0__/* .JsConnectionPointType.OBJECT_3D_ARRAY */ .zF.OBJECT_3D_ARRAY, _utils_io_connections_Js__WEBPACK_IMPORTED_MODULE_0__/* .JsConnectionPointType.OBJECT_3D_ARRAY */ .zF.OBJECT_3D_ARRAY)
    ]);
  }
  setLines(linesController) {
    const usedOutputNames = this.io.outputs.used_output_names();
    if (usedOutputNames.includes(_utils_io_connections_Js__WEBPACK_IMPORTED_MODULE_0__/* .JsConnectionPointType.OBJECT_3D_ARRAY */ .zF.OBJECT_3D_ARRAY)) {
      this._addObjectsRef(linesController);
      if (!usedOutputNames.includes(_utils_io_connections_Js__WEBPACK_IMPORTED_MODULE_0__/* .JsConnectionPointType.TRIGGER */ .zF.TRIGGER)) {
        this.setTriggeringLines(linesController, "");
      }
    }
  }
  setTriggerableLines(linesController) {
    const node = (0,_BaseObject3D__WEBPACK_IMPORTED_MODULE_3__/* .inputNode */ .Fs)(this, linesController);
    const outObjects = this._addObjectsRef(linesController);
    const func = _Poly__WEBPACK_IMPORTED_MODULE_4__/* .Poly.namedFunctionsRegister.getFunction */ .L.namedFunctionsRegister.getFunction("getGeometryNodeObjects", this, linesController);
    const bodyLine = func.asString(node, `this.${outObjects}.value`);
    linesController.addTriggerableLines(this, [bodyLine], { async: true });
  }
  _addObjectsRef(linesController) {
    const outObjects = this.jsVarName(_utils_io_connections_Js__WEBPACK_IMPORTED_MODULE_0__/* .JsConnectionPointType.OBJECT_3D_ARRAY */ .zF.OBJECT_3D_ARRAY);
    linesController.addDefinitions(this, [
      // do not use a ref, as it makes the object reactive
      new _utils_JsDefinition__WEBPACK_IMPORTED_MODULE_5__/* .ConstantJsDefinition */ .mF(this, linesController, _utils_io_connections_Js__WEBPACK_IMPORTED_MODULE_0__/* .JsConnectionPointType.OBJECT_3D_ARRAY */ .zF.OBJECT_3D_ARRAY, outObjects, `[]`)
    ]);
    return outObjects;
  }
}


/***/ }),

/***/ 67946:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "X": function() { return /* binding */ GetMaterialJsNode; }
/* harmony export */ });
/* harmony import */ var _Base__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(38231);
/* harmony import */ var _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(96949);
/* harmony import */ var _utils_io_connections_Js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(38857);
/* harmony import */ var _poly_NodeContext__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(52070);
/* harmony import */ var _Poly__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(99934);






class GetMaterialJsParamsConfig extends _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_0__/* .NodeParamsConfig */ .yI {
  constructor() {
    super(...arguments);
    /** @param the material node */
    this.node = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_0__/* .ParamConfig.NODE_PATH */ .XC.NODE_PATH("", {
      nodeSelection: {
        context: _poly_NodeContext__WEBPACK_IMPORTED_MODULE_1__/* .NodeContext.MAT */ .sy.MAT
      },
      dependentOnFoundNode: false,
      computeOnDirty: true
    });
  }
}
const ParamsConfig = new GetMaterialJsParamsConfig();
class GetMaterialJsNode extends _Base__WEBPACK_IMPORTED_MODULE_2__/* .TypedJsNode */ .xZ {
  constructor() {
    super(...arguments);
    this.paramsConfig = ParamsConfig;
  }
  static type() {
    return "getMaterial";
  }
  initializeNode() {
    this.io.outputs.setNamedOutputConnectionPoints([
      new _utils_io_connections_Js__WEBPACK_IMPORTED_MODULE_3__/* .JsConnectionPoint */ .fp(_utils_io_connections_Js__WEBPACK_IMPORTED_MODULE_3__/* .JsConnectionPointType.MATERIAL */ .zF.MATERIAL, _utils_io_connections_Js__WEBPACK_IMPORTED_MODULE_3__/* .JsConnectionPointType.MATERIAL */ .zF.MATERIAL)
    ]);
  }
  setLines(shadersCollectionController) {
    const node = this.pv.node.node();
    if (!(node && node.context() == _poly_NodeContext__WEBPACK_IMPORTED_MODULE_1__/* .NodeContext.MAT */ .sy.MAT)) {
      return;
    }
    const nodePath = `'${node.path()}'`;
    const varName = this.jsVarName(_utils_io_connections_Js__WEBPACK_IMPORTED_MODULE_3__/* .JsConnectionPointType.MATERIAL */ .zF.MATERIAL);
    const func = _Poly__WEBPACK_IMPORTED_MODULE_4__/* .Poly.namedFunctionsRegister.getFunction */ .L.namedFunctionsRegister.getFunction("getMaterial", this, shadersCollectionController);
    shadersCollectionController.addBodyOrComputed(this, [
      {
        dataType: _utils_io_connections_Js__WEBPACK_IMPORTED_MODULE_3__/* .JsConnectionPointType.MATERIAL */ .zF.MATERIAL,
        varName,
        value: func.asString(nodePath)
      }
    ]);
  }
}


/***/ }),

/***/ 44642:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "z": function() { return /* binding */ GetNodeJsNode; }
/* harmony export */ });
/* harmony import */ var _Base__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(38231);
/* harmony import */ var _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(96949);
/* harmony import */ var _utils_io_connections_Js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(38857);
/* harmony import */ var _Poly__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(99934);
/* harmony import */ var _poly_registers_nodes_types_Js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(16718);






const CONNECTION_OPTIONS = _utils_io_connections_Js__WEBPACK_IMPORTED_MODULE_0__/* .JS_CONNECTION_POINT_IN_NODE_DEF */ .mX;
class GetNodeJsParamsConfig extends _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .NodeParamsConfig */ .yI {
  constructor() {
    super(...arguments);
    /** @param parameter to get */
    this.Node = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .ParamConfig.NODE_PATH */ .XC.NODE_PATH("", {
      dependentOnFoundNode: false,
      // nodeSelection: {
      // 	context: NodeContext.SOP,
      // },
      computeOnDirty: false
    });
  }
}
const ParamsConfig = new GetNodeJsParamsConfig();
class GetNodeJsNode extends _Base__WEBPACK_IMPORTED_MODULE_2__/* .TypedJsNode */ .xZ {
  constructor() {
    super(...arguments);
    this.paramsConfig = ParamsConfig;
  }
  static type() {
    return _poly_registers_nodes_types_Js__WEBPACK_IMPORTED_MODULE_3__/* .JsType.GET_NODE */ .K.GET_NODE;
  }
  initializeNode() {
    this.io.outputs.setNamedOutputConnectionPoints([
      new _utils_io_connections_Js__WEBPACK_IMPORTED_MODULE_0__/* .JsConnectionPoint */ .fp(_utils_io_connections_Js__WEBPACK_IMPORTED_MODULE_0__/* .JsConnectionPointType.NODE */ .zF.NODE, _utils_io_connections_Js__WEBPACK_IMPORTED_MODULE_0__/* .JsConnectionPointType.NODE */ .zF.NODE, CONNECTION_OPTIONS)
    ]);
    this.io.connection_points.spare_params.setInputlessParamNames([_utils_io_connections_Js__WEBPACK_IMPORTED_MODULE_0__/* .JsConnectionPointType.NODE */ .zF.NODE]);
  }
  setNodePath(nodePath) {
    this.p.Node.set(nodePath);
  }
  setLines(linesController) {
    const out = this.jsVarName(_utils_io_connections_Js__WEBPACK_IMPORTED_MODULE_0__/* .JsConnectionPointType.NODE */ .zF.NODE);
    const node = this.params.get(_utils_io_connections_Js__WEBPACK_IMPORTED_MODULE_0__/* .JsConnectionPointType.NODE */ .zF.NODE).value.node();
    if (!node) {
      return;
    }
    const func = _Poly__WEBPACK_IMPORTED_MODULE_4__/* .Poly.namedFunctionsRegister.getFunction */ .L.namedFunctionsRegister.getFunction("getNode", this, linesController);
    const bodyLine = func.asString(`'${node.path()}'`);
    linesController.addBodyOrComputed(this, [
      { dataType: _utils_io_connections_Js__WEBPACK_IMPORTED_MODULE_0__/* .JsConnectionPointType.NODE */ .zF.NODE, varName: out, value: bodyLine }
    ]);
  }
}


/***/ }),

/***/ 46208:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "l": function() { return /* binding */ GetObjectJsNode; }
/* harmony export */ });
/* harmony import */ var _Base__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(38231);
/* harmony import */ var _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(96949);
/* harmony import */ var _utils_io_connections_Js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(38857);
/* harmony import */ var _Poly__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(99934);
/* harmony import */ var _BaseObject3D__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(75807);






const CONNECTION_OPTIONS = _utils_io_connections_Js__WEBPACK_IMPORTED_MODULE_0__/* .JS_CONNECTION_POINT_IN_NODE_DEF */ .mX;
class GetObjectJsParamsConfig extends _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .NodeParamsConfig */ .yI {
  constructor() {
    super(...arguments);
    /** @param use current object */
    this.getCurrentObject = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .ParamConfig.BOOLEAN */ .XC.BOOLEAN(1);
    /** @param object mask */
    this.mask = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .ParamConfig.STRING */ .XC.STRING("", {
      visibleIf: {
        getCurrentObject: 0
      },
      objectMask: true
    });
  }
}
const ParamsConfig = new GetObjectJsParamsConfig();
class GetObjectJsNode extends _Base__WEBPACK_IMPORTED_MODULE_2__/* .TypedJsNode */ .xZ {
  constructor() {
    super(...arguments);
    this.paramsConfig = ParamsConfig;
  }
  static type() {
    return "getObject";
  }
  initializeNode() {
    this.io.inputs.setNamedInputConnectionPoints([
      new _utils_io_connections_Js__WEBPACK_IMPORTED_MODULE_0__/* .JsConnectionPoint */ .fp("mask", _utils_io_connections_Js__WEBPACK_IMPORTED_MODULE_0__/* .JsConnectionPointType.STRING */ .zF.STRING, CONNECTION_OPTIONS)
    ]);
    this.io.outputs.setNamedOutputConnectionPoints([
      new _utils_io_connections_Js__WEBPACK_IMPORTED_MODULE_0__/* .JsConnectionPoint */ .fp(_utils_io_connections_Js__WEBPACK_IMPORTED_MODULE_0__/* .JsConnectionPointType.OBJECT_3D */ .zF.OBJECT_3D, _utils_io_connections_Js__WEBPACK_IMPORTED_MODULE_0__/* .JsConnectionPointType.OBJECT_3D */ .zF.OBJECT_3D)
    ]);
  }
  setLines(linesController) {
    const object3D = (0,_BaseObject3D__WEBPACK_IMPORTED_MODULE_3__/* .inputObject3D */ .iv)(this, linesController);
    const getCurrentObject = this.variableForInputParam(linesController, this.p.getCurrentObject);
    const mask = this.variableForInputParam(linesController, this.p.mask);
    const out = this.jsVarName(_utils_io_connections_Js__WEBPACK_IMPORTED_MODULE_0__/* .JsConnectionPointType.OBJECT_3D */ .zF.OBJECT_3D);
    const func = _Poly__WEBPACK_IMPORTED_MODULE_4__/* .Poly.namedFunctionsRegister.getFunction */ .L.namedFunctionsRegister.getFunction("getObject", this, linesController);
    const bodyLine = func.asString(object3D, getCurrentObject, mask);
    linesController.addBodyOrComputed(this, [
      { dataType: _utils_io_connections_Js__WEBPACK_IMPORTED_MODULE_0__/* .JsConnectionPointType.PLANE */ .zF.PLANE, varName: out, value: bodyLine }
    ]);
  }
}


/***/ }),

/***/ 85528:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "H": function() { return /* binding */ GetObjectChildJsNode; }
/* harmony export */ });
/* harmony import */ var _Base__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(38231);
/* harmony import */ var _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(96949);
/* harmony import */ var _utils_io_connections_Js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(38857);
/* harmony import */ var _BaseObject3D__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(75807);
/* harmony import */ var _Poly__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(99934);






const CONNECTION_OPTIONS = _utils_io_connections_Js__WEBPACK_IMPORTED_MODULE_0__/* .JS_CONNECTION_POINT_IN_NODE_DEF */ .mX;
class GetObjectChildJsParamsConfig extends _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .NodeParamsConfig */ .yI {
  constructor() {
    super(...arguments);
    /** @param child index */
    this.index = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .ParamConfig.INTEGER */ .XC.INTEGER(0, {
      range: [0, 9],
      rangeLocked: [true, false]
    });
  }
}
const ParamsConfig = new GetObjectChildJsParamsConfig();
class GetObjectChildJsNode extends _Base__WEBPACK_IMPORTED_MODULE_2__/* .TypedJsNode */ .xZ {
  constructor() {
    super(...arguments);
    this.paramsConfig = ParamsConfig;
  }
  static type() {
    return "getObjectChild";
  }
  initializeNode() {
    this.io.inputs.setNamedInputConnectionPoints([
      new _utils_io_connections_Js__WEBPACK_IMPORTED_MODULE_0__/* .JsConnectionPoint */ .fp(_utils_io_connections_Js__WEBPACK_IMPORTED_MODULE_0__/* .JsConnectionPointType.OBJECT_3D */ .zF.OBJECT_3D, _utils_io_connections_Js__WEBPACK_IMPORTED_MODULE_0__/* .JsConnectionPointType.OBJECT_3D */ .zF.OBJECT_3D, CONNECTION_OPTIONS)
    ]);
    this.io.outputs.setNamedOutputConnectionPoints([
      new _utils_io_connections_Js__WEBPACK_IMPORTED_MODULE_0__/* .JsConnectionPoint */ .fp(_utils_io_connections_Js__WEBPACK_IMPORTED_MODULE_0__/* .JsConnectionPointType.OBJECT_3D */ .zF.OBJECT_3D, _utils_io_connections_Js__WEBPACK_IMPORTED_MODULE_0__/* .JsConnectionPointType.OBJECT_3D */ .zF.OBJECT_3D)
    ]);
  }
  setLines(shadersCollectionController) {
    const object3D = (0,_BaseObject3D__WEBPACK_IMPORTED_MODULE_3__/* .inputObject3D */ .iv)(this, shadersCollectionController);
    const index = this.variableForInputParam(shadersCollectionController, this.p.index);
    const varName = this.jsVarName(_utils_io_connections_Js__WEBPACK_IMPORTED_MODULE_0__/* .JsConnectionPointType.OBJECT_3D */ .zF.OBJECT_3D);
    const func = _Poly__WEBPACK_IMPORTED_MODULE_4__/* .Poly.namedFunctionsRegister.getFunction */ .L.namedFunctionsRegister.getFunction("getObjectChild", this, shadersCollectionController);
    const bodyLine = func.asString(object3D, index);
    shadersCollectionController.addBodyOrComputed(this, [
      { dataType: _utils_io_connections_Js__WEBPACK_IMPORTED_MODULE_0__/* .JsConnectionPointType.PLANE */ .zF.PLANE, varName, value: bodyLine }
    ]);
  }
}


/***/ }),

/***/ 13941:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "V": function() { return /* binding */ GetParamJsNode; }
/* harmony export */ });
/* harmony import */ var _Base__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(38231);
/* harmony import */ var _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(96949);
/* harmony import */ var _utils_io_connections_Js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(38857);
/* harmony import */ var _Poly__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(99934);
/* harmony import */ var _poly_registers_nodes_types_Js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(16718);






const CONNECTION_OPTIONS = _utils_io_connections_Js__WEBPACK_IMPORTED_MODULE_0__/* .JS_CONNECTION_POINT_IN_NODE_DEF */ .mX;
class GetParamJsParamsConfig extends _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .NodeParamsConfig */ .yI {
  constructor() {
    super(...arguments);
    /** @param parameter to get */
    this.Param = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .ParamConfig.PARAM_PATH */ .XC.PARAM_PATH("", {
      dependentOnFoundParam: false,
      paramSelection: true,
      computeOnDirty: false
    });
  }
}
const ParamsConfig = new GetParamJsParamsConfig();
class GetParamJsNode extends _Base__WEBPACK_IMPORTED_MODULE_2__/* .TypedJsNode */ .xZ {
  constructor() {
    super(...arguments);
    this.paramsConfig = ParamsConfig;
  }
  static type() {
    return _poly_registers_nodes_types_Js__WEBPACK_IMPORTED_MODULE_3__/* .JsType.GET_PARAM */ .K.GET_PARAM;
  }
  initializeNode() {
    this.io.outputs.setNamedOutputConnectionPoints([
      new _utils_io_connections_Js__WEBPACK_IMPORTED_MODULE_0__/* .JsConnectionPoint */ .fp(_utils_io_connections_Js__WEBPACK_IMPORTED_MODULE_0__/* .JsConnectionPointType.PARAM */ .zF.PARAM, _utils_io_connections_Js__WEBPACK_IMPORTED_MODULE_0__/* .JsConnectionPointType.PARAM */ .zF.PARAM, CONNECTION_OPTIONS)
    ]);
    this.io.connection_points.spare_params.setInputlessParamNames([_utils_io_connections_Js__WEBPACK_IMPORTED_MODULE_0__/* .JsConnectionPointType.PARAM */ .zF.PARAM]);
  }
  setParamPath(paramPath) {
    this.p.Param.set(paramPath);
  }
  setLines(linesController) {
    const out = this.jsVarName(_utils_io_connections_Js__WEBPACK_IMPORTED_MODULE_0__/* .JsConnectionPointType.PARAM */ .zF.PARAM);
    const param = this.params.get(_utils_io_connections_Js__WEBPACK_IMPORTED_MODULE_0__/* .JsConnectionPointType.PARAM */ .zF.PARAM).value.param();
    if (!param) {
      return;
    }
    const func = _Poly__WEBPACK_IMPORTED_MODULE_4__/* .Poly.namedFunctionsRegister.getFunction */ .L.namedFunctionsRegister.getFunction("getParam", this, linesController);
    const bodyLine = func.asString(`'${param.path()}'`);
    linesController.addBodyOrComputed(this, [
      { dataType: _utils_io_connections_Js__WEBPACK_IMPORTED_MODULE_0__/* .JsConnectionPointType.PARAM */ .zF.PARAM, varName: out, value: bodyLine }
    ]);
  }
}


/***/ }),

/***/ 99860:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "D": function() { return /* binding */ GetTextureJsNode; }
/* harmony export */ });
/* harmony import */ var _Base__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(38231);
/* harmony import */ var _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(96949);
/* harmony import */ var _utils_io_connections_Js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(38857);
/* harmony import */ var _poly_NodeContext__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(52070);
/* harmony import */ var _Poly__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(99934);






class GetTextureJsParamsConfig extends _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_0__/* .NodeParamsConfig */ .yI {
  constructor() {
    super(...arguments);
    /** @param the texture node */
    this.node = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_0__/* .ParamConfig.NODE_PATH */ .XC.NODE_PATH("", {
      nodeSelection: {
        context: _poly_NodeContext__WEBPACK_IMPORTED_MODULE_1__/* .NodeContext.COP */ .sy.COP
      },
      dependentOnFoundNode: false,
      computeOnDirty: true
    });
  }
}
const ParamsConfig = new GetTextureJsParamsConfig();
class GetTextureJsNode extends _Base__WEBPACK_IMPORTED_MODULE_2__/* .TypedJsNode */ .xZ {
  constructor() {
    super(...arguments);
    this.paramsConfig = ParamsConfig;
  }
  static type() {
    return "getTexture";
  }
  initializeNode() {
    this.io.outputs.setNamedOutputConnectionPoints([
      new _utils_io_connections_Js__WEBPACK_IMPORTED_MODULE_3__/* .JsConnectionPoint */ .fp(_utils_io_connections_Js__WEBPACK_IMPORTED_MODULE_3__/* .JsConnectionPointType.TEXTURE */ .zF.TEXTURE, _utils_io_connections_Js__WEBPACK_IMPORTED_MODULE_3__/* .JsConnectionPointType.TEXTURE */ .zF.TEXTURE)
    ]);
  }
  setLines(shadersCollectionController) {
    const node = this.pv.node.node();
    if (!(node && node.context() == _poly_NodeContext__WEBPACK_IMPORTED_MODULE_1__/* .NodeContext.COP */ .sy.COP)) {
      return;
    }
    const nodePath = `'${node.path()}'`;
    const varName = this.jsVarName(_utils_io_connections_Js__WEBPACK_IMPORTED_MODULE_3__/* .JsConnectionPointType.TEXTURE */ .zF.TEXTURE);
    const func = _Poly__WEBPACK_IMPORTED_MODULE_4__/* .Poly.namedFunctionsRegister.getFunction */ .L.namedFunctionsRegister.getFunction("getTexture", this, shadersCollectionController);
    shadersCollectionController.addBodyOrComputed(this, [
      {
        dataType: _utils_io_connections_Js__WEBPACK_IMPORTED_MODULE_3__/* .JsConnectionPointType.TEXTURE */ .zF.TEXTURE,
        varName,
        value: func.asString(nodePath)
      }
    ]);
  }
}


/***/ }),

/***/ 84283:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "S": function() { return /* binding */ GetVideoPropertyJsNode; }
/* harmony export */ });
/* unused harmony export GetVideoPropertyJsNodeOutputName */
/* harmony import */ var _Base__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(38231);
/* harmony import */ var _utils_io_connections_Js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(38857);
/* harmony import */ var _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(96949);
/* harmony import */ var _poly_NodeContext__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(52070);
/* harmony import */ var _poly_registers_nodes_types_Cop__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(12764);
/* harmony import */ var _Poly__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(99934);







const CONNECTION_OPTIONS = _utils_io_connections_Js__WEBPACK_IMPORTED_MODULE_0__/* .JS_CONNECTION_POINT_IN_NODE_DEF */ .mX;
var GetVideoPropertyJsNodeOutputName = /* @__PURE__ */ ((GetVideoPropertyJsNodeOutputName2) => {
  GetVideoPropertyJsNodeOutputName2["currentTime"] = "currentTime";
  GetVideoPropertyJsNodeOutputName2["duration"] = "duration";
  GetVideoPropertyJsNodeOutputName2["playing"] = "playing";
  GetVideoPropertyJsNodeOutputName2["muted"] = "muted";
  return GetVideoPropertyJsNodeOutputName2;
})(GetVideoPropertyJsNodeOutputName || {});
class GetVideoPropertyJsParamsConfig extends _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .NodeParamsConfig */ .yI {
  constructor() {
    super(...arguments);
    this.node = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .ParamConfig.NODE_PATH */ .XC.NODE_PATH("", {
      nodeSelection: {
        context: _poly_NodeContext__WEBPACK_IMPORTED_MODULE_2__/* .NodeContext.COP */ .sy.COP,
        types: [_poly_registers_nodes_types_Cop__WEBPACK_IMPORTED_MODULE_3__/* .CopType.VIDEO */ .y.VIDEO]
      },
      computeOnDirty: true
    });
  }
}
const ParamsConfig = new GetVideoPropertyJsParamsConfig();
class GetVideoPropertyJsNode extends _Base__WEBPACK_IMPORTED_MODULE_4__/* .TypedJsNode */ .xZ {
  constructor() {
    super(...arguments);
    this.paramsConfig = ParamsConfig;
  }
  static type() {
    return "getVideoProperty";
  }
  initializeNode() {
    this.io.inputs.setNamedInputConnectionPoints([
      new _utils_io_connections_Js__WEBPACK_IMPORTED_MODULE_0__/* .JsConnectionPoint */ .fp(_utils_io_connections_Js__WEBPACK_IMPORTED_MODULE_0__/* .JsConnectionPointType.OBJECT_3D */ .zF.OBJECT_3D, _utils_io_connections_Js__WEBPACK_IMPORTED_MODULE_0__/* .JsConnectionPointType.OBJECT_3D */ .zF.OBJECT_3D, CONNECTION_OPTIONS)
    ]);
    this.io.outputs.setNamedOutputConnectionPoints([
      new _utils_io_connections_Js__WEBPACK_IMPORTED_MODULE_0__/* .JsConnectionPoint */ .fp("currentTime" /* currentTime */, _utils_io_connections_Js__WEBPACK_IMPORTED_MODULE_0__/* .JsConnectionPointType.FLOAT */ .zF.FLOAT),
      new _utils_io_connections_Js__WEBPACK_IMPORTED_MODULE_0__/* .JsConnectionPoint */ .fp("duration" /* duration */, _utils_io_connections_Js__WEBPACK_IMPORTED_MODULE_0__/* .JsConnectionPointType.FLOAT */ .zF.FLOAT),
      new _utils_io_connections_Js__WEBPACK_IMPORTED_MODULE_0__/* .JsConnectionPoint */ .fp("playing" /* playing */, _utils_io_connections_Js__WEBPACK_IMPORTED_MODULE_0__/* .JsConnectionPointType.BOOLEAN */ .zF.BOOLEAN),
      new _utils_io_connections_Js__WEBPACK_IMPORTED_MODULE_0__/* .JsConnectionPoint */ .fp("muted" /* muted */, _utils_io_connections_Js__WEBPACK_IMPORTED_MODULE_0__/* .JsConnectionPointType.BOOLEAN */ .zF.BOOLEAN)
    ]);
  }
  setLines(shadersCollectionController) {
    const usedOutputNames = this.io.outputs.used_output_names();
    const node = this.pv.node.node();
    if (!(node && node.context() == _poly_NodeContext__WEBPACK_IMPORTED_MODULE_2__/* .NodeContext.COP */ .sy.COP)) {
      return;
    }
    const nodePath = `'${node.path()}'`;
    const _f = (propertyName, functionName, type) => {
      if (!usedOutputNames.includes(propertyName)) {
        return;
      }
      const func = _Poly__WEBPACK_IMPORTED_MODULE_5__/* .Poly.namedFunctionsRegister.getFunction */ .L.namedFunctionsRegister.getFunction(functionName, this, shadersCollectionController);
      shadersCollectionController.addBodyOrComputed(this, [
        {
          dataType: type,
          varName: this.jsVarName(propertyName),
          value: func.asString(nodePath)
        }
      ]);
    };
    _f("currentTime" /* currentTime */, "getVideoPropertyCurrentTime", _utils_io_connections_Js__WEBPACK_IMPORTED_MODULE_0__/* .JsConnectionPointType.FLOAT */ .zF.FLOAT);
    _f("duration" /* duration */, "getVideoPropertyDuration", _utils_io_connections_Js__WEBPACK_IMPORTED_MODULE_0__/* .JsConnectionPointType.FLOAT */ .zF.FLOAT);
    _f("playing" /* playing */, "getVideoPropertyPlaying", _utils_io_connections_Js__WEBPACK_IMPORTED_MODULE_0__/* .JsConnectionPointType.BOOLEAN */ .zF.BOOLEAN);
    _f("muted" /* muted */, "getVideoPropertyMuted", _utils_io_connections_Js__WEBPACK_IMPORTED_MODULE_0__/* .JsConnectionPointType.BOOLEAN */ .zF.BOOLEAN);
  }
}


/***/ }),

/***/ 19633:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "dQ": function() { return /* binding */ ImportAttributeJsNode; }
/* harmony export */ });
/* unused harmony exports ATTRIBUTE_NODE_AVAILABLE_JS_TYPES, ImportAttributeJsNodeInput, ImportAttributeJsNodeOutput */
/* harmony import */ var _Base__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(38231);
/* harmony import */ var _utils_io_connections_Js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(38857);
/* harmony import */ var _poly_registers_nodes_types_Js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(16718);
/* harmony import */ var _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(96949);
/* harmony import */ var _Poly__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(99934);
/* harmony import */ var _BaseObject3D__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(75807);







const ATTRIBUTE_NODE_AVAILABLE_JS_TYPES = [
  _utils_io_connections_Js__WEBPACK_IMPORTED_MODULE_0__/* .JsConnectionPointType.COLOR */ .zF.COLOR,
  _utils_io_connections_Js__WEBPACK_IMPORTED_MODULE_0__/* .JsConnectionPointType.FLOAT */ .zF.FLOAT,
  _utils_io_connections_Js__WEBPACK_IMPORTED_MODULE_0__/* .JsConnectionPointType.INT */ .zF.INT,
  _utils_io_connections_Js__WEBPACK_IMPORTED_MODULE_0__/* .JsConnectionPointType.VECTOR2 */ .zF.VECTOR2,
  _utils_io_connections_Js__WEBPACK_IMPORTED_MODULE_0__/* .JsConnectionPointType.VECTOR3 */ .zF.VECTOR3,
  _utils_io_connections_Js__WEBPACK_IMPORTED_MODULE_0__/* .JsConnectionPointType.VECTOR4 */ .zF.VECTOR4
];
var ImportAttributeJsNodeInput = /* @__PURE__ */ ((ImportAttributeJsNodeInput2) => {
  ImportAttributeJsNodeInput2["INDEX"] = "index";
  return ImportAttributeJsNodeInput2;
})(ImportAttributeJsNodeInput || {});
var ImportAttributeJsNodeOutput = /* @__PURE__ */ ((ImportAttributeJsNodeOutput2) => {
  ImportAttributeJsNodeOutput2["VAL"] = "val";
  return ImportAttributeJsNodeOutput2;
})(ImportAttributeJsNodeOutput || {});
class ImportAttributeJsParamsConfig extends _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .NodeParamsConfig */ .yI {
  constructor() {
    super(...arguments);
    this.name = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .ParamConfig.STRING */ .XC.STRING("");
    this.type = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .ParamConfig.INTEGER */ .XC.INTEGER(0, {
      menu: {
        entries: ATTRIBUTE_NODE_AVAILABLE_JS_TYPES.map((name, i) => {
          return { name, value: i };
        })
      }
    });
    /** @param entity index */
    this.index = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .ParamConfig.INTEGER */ .XC.INTEGER(0);
  }
}
const ParamsConfig = new ImportAttributeJsParamsConfig();
class ImportAttributeJsNode extends _Base__WEBPACK_IMPORTED_MODULE_2__/* .TypedJsNode */ .xZ {
  constructor() {
    super(...arguments);
    this.paramsConfig = ParamsConfig;
  }
  static type() {
    return _poly_registers_nodes_types_Js__WEBPACK_IMPORTED_MODULE_3__/* .JsType.IMPORT_ATTRIBUTE */ .K.IMPORT_ATTRIBUTE;
  }
  initializeNode() {
    this.io.connection_points.initializeNode();
    this.io.connection_points.set_expected_input_types_function(() => this._expectedInputTypes());
    this.io.connection_points.set_input_name_function((index) => this.inputName());
    this.io.connection_points.set_expected_output_types_function(() => [this._expectedOutputType()]);
  }
  _expectedInputTypes() {
    return [_utils_io_connections_Js__WEBPACK_IMPORTED_MODULE_0__/* .JsConnectionPointType.INT */ .zF.INT];
  }
  _expectedOutputType() {
    return ATTRIBUTE_NODE_AVAILABLE_JS_TYPES[this.pv.type];
  }
  inputName() {
    return "index" /* INDEX */;
  }
  outputName() {
    return "val" /* VAL */;
  }
  attribData() {
    return {
      attribName: this.attributeName(),
      attribType: this.jsType()
    };
  }
  attributeName() {
    return this.pv.name.trim();
  }
  jsType() {
    const connectionPoints = this.io.outputs.namedOutputConnectionPoints();
    if (!connectionPoints) {
      return _utils_io_connections_Js__WEBPACK_IMPORTED_MODULE_0__/* .JsConnectionPointType.FLOAT */ .zF.FLOAT;
    }
    return connectionPoints[0].type();
  }
  setJsType(type) {
    this.p.type.set(ATTRIBUTE_NODE_AVAILABLE_JS_TYPES.indexOf(type));
  }
  setLines(linesController) {
    const primitiveGraph = (0,_BaseObject3D__WEBPACK_IMPORTED_MODULE_4__/* .defaultObject */ .w8)(linesController);
    const index = this.variableForInputParam(linesController, this.p.index);
    const attribName = this.variableForInputParam(linesController, this.p.name);
    const out = this.jsVarName("val" /* VAL */);
    const func = _Poly__WEBPACK_IMPORTED_MODULE_5__/* .Poly.namedFunctionsRegister.getFunction */ .L.namedFunctionsRegister.getFunction("importPrimitiveAttributeNumber", this, linesController);
    const bodyLine = func.asString(primitiveGraph, attribName, index);
    linesController.addBodyOrComputed(this, [{ dataType: _utils_io_connections_Js__WEBPACK_IMPORTED_MODULE_0__/* .JsConnectionPointType.INT */ .zF.INT, varName: out, value: bodyLine }]);
  }
}


/***/ }),

/***/ 36332:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Y": function() { return /* binding */ OnKeydownJsNode; }
/* harmony export */ });
/* harmony import */ var _poly_registers_nodes_types_Js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(16718);
/* harmony import */ var _BaseOnKeyEvent__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(57694);
/* harmony import */ var _core_event_KeyboardEventType__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(21914);




class OnKeydownJsNode extends _BaseOnKeyEvent__WEBPACK_IMPORTED_MODULE_0__/* .BaseOnKeyEventJsNode */ .r {
  static type() {
    return _poly_registers_nodes_types_Js__WEBPACK_IMPORTED_MODULE_1__/* .JsType.ON_KEYDOWN */ .K.ON_KEYDOWN;
  }
  eventData() {
    return {
      type: _core_event_KeyboardEventType__WEBPACK_IMPORTED_MODULE_2__/* .KeyboardEventType.keydown */ .c.keydown,
      emitter: this.eventEmitter(),
      jsType: _poly_registers_nodes_types_Js__WEBPACK_IMPORTED_MODULE_1__/* .JsType.ON_KEYDOWN */ .K.ON_KEYDOWN
    };
  }
}


/***/ }),

/***/ 69600:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "f": function() { return /* binding */ OnKeypressJsNode; }
/* harmony export */ });
/* harmony import */ var _poly_registers_nodes_types_Js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(16718);
/* harmony import */ var _core_event_KeyboardEventType__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(21914);
/* harmony import */ var _BaseOnKeyEvent__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(57694);




class OnKeypressJsNode extends _BaseOnKeyEvent__WEBPACK_IMPORTED_MODULE_0__/* .BaseOnKeyEventJsNode */ .r {
  static type() {
    return _poly_registers_nodes_types_Js__WEBPACK_IMPORTED_MODULE_1__/* .JsType.ON_KEYPRESS */ .K.ON_KEYPRESS;
  }
  eventData() {
    return {
      type: _core_event_KeyboardEventType__WEBPACK_IMPORTED_MODULE_2__/* .KeyboardEventType.keypress */ .c.keypress,
      emitter: this.eventEmitter(),
      jsType: _poly_registers_nodes_types_Js__WEBPACK_IMPORTED_MODULE_1__/* .JsType.ON_KEYPRESS */ .K.ON_KEYPRESS
    };
  }
}


/***/ }),

/***/ 64607:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "y": function() { return /* binding */ OnKeyupJsNode; }
/* harmony export */ });
/* harmony import */ var _poly_registers_nodes_types_Js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(16718);
/* harmony import */ var _core_event_KeyboardEventType__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(21914);
/* harmony import */ var _BaseOnKeyEvent__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(57694);




class OnKeyupJsNode extends _BaseOnKeyEvent__WEBPACK_IMPORTED_MODULE_0__/* .BaseOnKeyEventJsNode */ .r {
  static type() {
    return _poly_registers_nodes_types_Js__WEBPACK_IMPORTED_MODULE_1__/* .JsType.ON_KEYUP */ .K.ON_KEYUP;
  }
  eventData() {
    return {
      type: _core_event_KeyboardEventType__WEBPACK_IMPORTED_MODULE_2__/* .KeyboardEventType.keyup */ .c.keyup,
      emitter: this.eventEmitter(),
      jsType: _poly_registers_nodes_types_Js__WEBPACK_IMPORTED_MODULE_1__/* .JsType.ON_KEYUP */ .K.ON_KEYUP
    };
  }
}


/***/ }),

/***/ 75115:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "U": function() { return /* binding */ OnObjectClickJsNode; }
/* harmony export */ });
/* unused harmony export OnObjectClickJsParamsConfig */
/* harmony import */ var _Base__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(38231);
/* harmony import */ var _utils_io_connections_Js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(38857);
/* harmony import */ var _poly_registers_nodes_types_Js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(16718);
/* harmony import */ var _BaseOnObjectPointerEvent__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(62700);
/* harmony import */ var _core_event_PointerEventType__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(43843);
/* harmony import */ var _BaseObject3D__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(75807);
/* harmony import */ var _Poly__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(99934);
/* harmony import */ var _utils_JsDefinition__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(36343);
/* harmony import */ var _code_assemblers_actor_ActorAssemblerUtils__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(15945);
/* harmony import */ var _scene_utils_actors_rayObjectIntersection_RayObjectIntersectionsClickController__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(45389);











const CONNECTION_OPTIONS = _utils_io_connections_Js__WEBPACK_IMPORTED_MODULE_0__/* .JS_CONNECTION_POINT_IN_NODE_DEF */ .mX;
class OnObjectClickJsParamsConfig extends (0,_BaseOnObjectPointerEvent__WEBPACK_IMPORTED_MODULE_1__/* .PointerEventConfigParamConfig */ .qd)(
  (0,_scene_utils_actors_rayObjectIntersection_RayObjectIntersectionsClickController__WEBPACK_IMPORTED_MODULE_2__/* .ClickParamConfig */ .s)(_BaseOnObjectPointerEvent__WEBPACK_IMPORTED_MODULE_1__/* .CPUOnObjectPointerEventJsParamsConfig */ .hq)
) {
}
const ParamsConfig = new OnObjectClickJsParamsConfig();
class OnObjectClickJsNode extends _BaseOnObjectPointerEvent__WEBPACK_IMPORTED_MODULE_1__/* .ExtendableOnObjectPointerEventJsNode */ .hs {
  constructor() {
    super(...arguments);
    this.paramsConfig = ParamsConfig;
  }
  static type() {
    return _poly_registers_nodes_types_Js__WEBPACK_IMPORTED_MODULE_3__/* .JsType.ON_OBJECT_CLICK */ .K.ON_OBJECT_CLICK;
  }
  isTriggering() {
    return true;
  }
  eventData() {
    return [
      {
        type: _core_event_PointerEventType__WEBPACK_IMPORTED_MODULE_4__/* .PointerEventType.pointerdown */ .by.pointerdown,
        emitter: this.eventEmitter(),
        jsType: _poly_registers_nodes_types_Js__WEBPACK_IMPORTED_MODULE_3__/* .JsType.ON_POINTERDOWN */ .K.ON_POINTERDOWN
      },
      {
        type: _core_event_PointerEventType__WEBPACK_IMPORTED_MODULE_4__/* .PointerEventType.pointerup */ .by.pointerup,
        emitter: this.eventEmitter(),
        jsType: _poly_registers_nodes_types_Js__WEBPACK_IMPORTED_MODULE_3__/* .JsType.ON_OBJECT_POINTERUP */ .K.ON_OBJECT_POINTERUP
      }
    ];
  }
  initializeNode() {
    super.initializeNode();
    this.io.inputs.setNamedInputConnectionPoints([
      new _utils_io_connections_Js__WEBPACK_IMPORTED_MODULE_0__/* .JsConnectionPoint */ .fp(_utils_io_connections_Js__WEBPACK_IMPORTED_MODULE_0__/* .JsConnectionPointType.OBJECT_3D */ .zF.OBJECT_3D, _utils_io_connections_Js__WEBPACK_IMPORTED_MODULE_0__/* .JsConnectionPointType.OBJECT_3D */ .zF.OBJECT_3D, CONNECTION_OPTIONS)
    ]);
    this.io.outputs.setNamedOutputConnectionPoints([
      new _utils_io_connections_Js__WEBPACK_IMPORTED_MODULE_0__/* .JsConnectionPoint */ .fp(_Base__WEBPACK_IMPORTED_MODULE_5__/* .TRIGGER_CONNECTION_NAME */ .w6, _utils_io_connections_Js__WEBPACK_IMPORTED_MODULE_0__/* .JsConnectionPointType.TRIGGER */ .zF.TRIGGER, CONNECTION_OPTIONS),
      new _utils_io_connections_Js__WEBPACK_IMPORTED_MODULE_0__/* .JsConnectionPoint */ .fp(
        _utils_io_connections_Js__WEBPACK_IMPORTED_MODULE_0__/* .JsConnectionPointType.INTERSECTION */ .zF.INTERSECTION,
        _utils_io_connections_Js__WEBPACK_IMPORTED_MODULE_0__/* .JsConnectionPointType.INTERSECTION */ .zF.INTERSECTION,
        CONNECTION_OPTIONS
      )
    ]);
  }
  setLines(linesController) {
    const usedOutputNames = this.io.outputs.used_output_names();
    if (usedOutputNames.includes(_utils_io_connections_Js__WEBPACK_IMPORTED_MODULE_0__/* .JsConnectionPointType.INTERSECTION */ .zF.INTERSECTION)) {
      this._addIntersectionRef(linesController);
    }
  }
  setTriggeringLines(linesController, triggeredMethods) {
    const object3D = (0,_BaseObject3D__WEBPACK_IMPORTED_MODULE_6__/* .inputObject3D */ .iv)(this, linesController);
    const blockObjectsBehind = this.variableForInputParam(linesController, this.p.blockObjectsBehind);
    const skipIfObjectsInFront = this.variableForInputParam(linesController, this.p.skipIfObjectsInFront);
    const traverseChildren = this.variableForInputParam(linesController, this.p.traverseChildren);
    const lineThreshold = this.variableForInputParam(linesController, this.p.lineThreshold);
    const pointsThreshold = this.variableForInputParam(linesController, this.p.pointsThreshold);
    const maxCursorMoveDistance = this.variableForInputParam(linesController, this.p.maxCursorMoveDistance);
    const maxDuration = this.variableForInputParam(linesController, this.p.maxDuration);
    const intersectionRef = this._addIntersectionRef(linesController);
    const func = _Poly__WEBPACK_IMPORTED_MODULE_7__/* .Poly.namedFunctionsRegister.getFunction */ .L.namedFunctionsRegister.getFunction("addObjectToObjectClickCheck", this, linesController);
    const options = {
      priority: {
        blockObjectsBehind,
        skipIfObjectsInFront
      },
      cpu: {
        traverseChildren,
        pointsThreshold,
        lineThreshold,
        intersectionRef: `this.${intersectionRef}`
      },
      click: {
        maxCursorMoveDistance,
        maxDuration,
        callback: `this.${(0,_code_assemblers_actor_ActorAssemblerUtils__WEBPACK_IMPORTED_MODULE_8__/* .nodeMethodName */ .Bp)(this)}.bind(this)`
      },
      config: (0,_BaseOnObjectPointerEvent__WEBPACK_IMPORTED_MODULE_1__/* .pointerButtonConfig */ .AI)(this, linesController)
    };
    const jsonOptions = JSON.stringify(options).replace(/"/g, "");
    const bodyLine = func.asString(object3D, `this`, jsonOptions);
    linesController.addDefinitions(this, [
      new _utils_JsDefinition__WEBPACK_IMPORTED_MODULE_9__/* .InitFunctionJsDefinition */ .TN(this, linesController, _utils_io_connections_Js__WEBPACK_IMPORTED_MODULE_0__/* .JsConnectionPointType.OBJECT_3D */ .zF.OBJECT_3D, this.path(), bodyLine)
    ]);
    linesController.addTriggeringLines(this, [triggeredMethods], { gatherable: true });
  }
  _addIntersectionRef(linesController) {
    const outIntersection = this.jsVarName(_utils_io_connections_Js__WEBPACK_IMPORTED_MODULE_0__/* .JsConnectionPointType.INTERSECTION */ .zF.INTERSECTION);
    linesController.addDefinitions(this, [
      new _utils_JsDefinition__WEBPACK_IMPORTED_MODULE_9__/* .RefJsDefinition */ .Z(this, linesController, _utils_io_connections_Js__WEBPACK_IMPORTED_MODULE_0__/* .JsConnectionPointType.INTERSECTION */ .zF.INTERSECTION, outIntersection, `null`)
    ]);
    return outIntersection;
  }
}


/***/ }),

/***/ 42329:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "$": function() { return /* binding */ OnObjectDispatchEventJsNode; }
/* harmony export */ });
/* harmony import */ var _Base__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(38231);
/* harmony import */ var _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(96949);
/* harmony import */ var _utils_io_connections_Js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(38857);
/* harmony import */ var _poly_registers_nodes_types_Js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(16718);
/* harmony import */ var _BaseObject3D__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(75807);
/* harmony import */ var _Poly__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(99934);
/* harmony import */ var _utils_JsDefinition__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(36343);
/* harmony import */ var _code_assemblers_actor_ActorAssemblerUtils__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(15945);









var OnObjectDispatchEventJsNodeInputName = /* @__PURE__ */ ((OnObjectDispatchEventJsNodeInputName2) => {
  OnObjectDispatchEventJsNodeInputName2["eventName"] = "eventName";
  return OnObjectDispatchEventJsNodeInputName2;
})(OnObjectDispatchEventJsNodeInputName || {});
const CONNECTION_OPTIONS = _utils_io_connections_Js__WEBPACK_IMPORTED_MODULE_0__/* .JS_CONNECTION_POINT_IN_NODE_DEF */ .mX;
class OnObjectDispatchEventJsParamsConfig extends _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .NodeParamsConfig */ .yI {
  constructor() {
    super(...arguments);
    /** @param event names (space separated) */
    this.eventNames = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .ParamConfig.STRING */ .XC.STRING("my-eventA my-eventB");
  }
}
const ParamsConfig = new OnObjectDispatchEventJsParamsConfig();
class OnObjectDispatchEventJsNode extends _Base__WEBPACK_IMPORTED_MODULE_2__/* .TypedJsNode */ .xZ {
  constructor() {
    super(...arguments);
    this.paramsConfig = ParamsConfig;
  }
  static type() {
    return _poly_registers_nodes_types_Js__WEBPACK_IMPORTED_MODULE_3__/* .JsType.ON_OBJECT_DISPATCH_EVENT */ .K.ON_OBJECT_DISPATCH_EVENT;
  }
  isTriggering() {
    return true;
  }
  initializeNode() {
    super.initializeNode();
    this.io.connection_points.spare_params.setInputlessParamNames(["eventNames"]);
    this.io.inputs.setNamedInputConnectionPoints([]);
    this.io.outputs.setNamedOutputConnectionPoints([
      new _utils_io_connections_Js__WEBPACK_IMPORTED_MODULE_0__/* .JsConnectionPoint */ .fp(_Base__WEBPACK_IMPORTED_MODULE_2__/* .TRIGGER_CONNECTION_NAME */ .w6, _utils_io_connections_Js__WEBPACK_IMPORTED_MODULE_0__/* .JsConnectionPointType.TRIGGER */ .zF.TRIGGER, CONNECTION_OPTIONS),
      new _utils_io_connections_Js__WEBPACK_IMPORTED_MODULE_0__/* .JsConnectionPoint */ .fp(
        "eventName" /* eventName */,
        _utils_io_connections_Js__WEBPACK_IMPORTED_MODULE_0__/* .JsConnectionPointType.STRING */ .zF.STRING,
        CONNECTION_OPTIONS
      )
    ]);
  }
  setTriggeringLines(shadersCollectionController, triggeredMethods) {
    const object3D = (0,_BaseObject3D__WEBPACK_IMPORTED_MODULE_4__/* .inputObject3D */ .iv)(this, shadersCollectionController);
    const eventNames = this.variableForInputParam(shadersCollectionController, this.p.eventNames);
    const func = _Poly__WEBPACK_IMPORTED_MODULE_5__/* .Poly.namedFunctionsRegister.getFunction */ .L.namedFunctionsRegister.getFunction(
      "objectAddEventListeners",
      this,
      shadersCollectionController
    );
    const bodyLine = func.asString(object3D, eventNames, `this`, `this.${(0,_code_assemblers_actor_ActorAssemblerUtils__WEBPACK_IMPORTED_MODULE_6__/* .nodeMethodName */ .Bp)(this)}.bind(this)`);
    shadersCollectionController.addDefinitions(this, [
      new _utils_JsDefinition__WEBPACK_IMPORTED_MODULE_7__/* .InitFunctionJsDefinition */ .TN(
        this,
        shadersCollectionController,
        _utils_io_connections_Js__WEBPACK_IMPORTED_MODULE_0__/* .JsConnectionPointType.OBJECT_3D */ .zF.OBJECT_3D,
        this.path(),
        bodyLine
      )
    ]);
    shadersCollectionController.addTriggeringLines(this, [triggeredMethods], { gatherable: false });
  }
}


/***/ }),

/***/ 55149:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Q": function() { return /* binding */ OnObjectPointerdownJsNode; }
/* harmony export */ });
/* unused harmony export OnObjectPointerdownJsParamsConfig */
/* harmony import */ var _Base__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(38231);
/* harmony import */ var _utils_io_connections_Js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(38857);
/* harmony import */ var _poly_registers_nodes_types_Js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(16718);
/* harmony import */ var _BaseOnObjectPointerEvent__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(62700);
/* harmony import */ var _core_event_PointerEventType__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(43843);
/* harmony import */ var _BaseObject3D__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(75807);
/* harmony import */ var _Poly__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(99934);
/* harmony import */ var _utils_JsDefinition__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(36343);
/* harmony import */ var _code_assemblers_actor_ActorAssemblerUtils__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(15945);










const CONNECTION_OPTIONS = _utils_io_connections_Js__WEBPACK_IMPORTED_MODULE_0__/* .JS_CONNECTION_POINT_IN_NODE_DEF */ .mX;
class OnObjectPointerdownJsParamsConfig extends (0,_BaseOnObjectPointerEvent__WEBPACK_IMPORTED_MODULE_1__/* .PointerEventConfigParamConfig */ .qd)(
  _BaseOnObjectPointerEvent__WEBPACK_IMPORTED_MODULE_1__/* .CPUOnObjectPointerEventJsParamsConfig */ .hq
) {
}
const ParamsConfig = new OnObjectPointerdownJsParamsConfig();
class OnObjectPointerdownJsNode extends _BaseOnObjectPointerEvent__WEBPACK_IMPORTED_MODULE_1__/* .ExtendableOnObjectPointerEventJsNode */ .hs {
  constructor() {
    super(...arguments);
    this.paramsConfig = ParamsConfig;
  }
  static type() {
    return _poly_registers_nodes_types_Js__WEBPACK_IMPORTED_MODULE_2__/* .JsType.ON_OBJECT_POINTERDOWN */ .K.ON_OBJECT_POINTERDOWN;
  }
  eventData() {
    return {
      type: _core_event_PointerEventType__WEBPACK_IMPORTED_MODULE_3__/* .PointerEventType.pointerdown */ .by.pointerdown,
      emitter: this.eventEmitter(),
      jsType: _poly_registers_nodes_types_Js__WEBPACK_IMPORTED_MODULE_2__/* .JsType.ON_OBJECT_POINTERDOWN */ .K.ON_OBJECT_POINTERDOWN
    };
  }
  initializeNode() {
    super.initializeNode();
    this.io.outputs.setNamedOutputConnectionPoints([
      new _utils_io_connections_Js__WEBPACK_IMPORTED_MODULE_0__/* .JsConnectionPoint */ .fp(_Base__WEBPACK_IMPORTED_MODULE_4__/* .TRIGGER_CONNECTION_NAME */ .w6, _utils_io_connections_Js__WEBPACK_IMPORTED_MODULE_0__/* .JsConnectionPointType.TRIGGER */ .zF.TRIGGER, CONNECTION_OPTIONS),
      new _utils_io_connections_Js__WEBPACK_IMPORTED_MODULE_0__/* .JsConnectionPoint */ .fp(
        _utils_io_connections_Js__WEBPACK_IMPORTED_MODULE_0__/* .JsConnectionPointType.INTERSECTION */ .zF.INTERSECTION,
        _utils_io_connections_Js__WEBPACK_IMPORTED_MODULE_0__/* .JsConnectionPointType.INTERSECTION */ .zF.INTERSECTION,
        CONNECTION_OPTIONS
      )
    ]);
    this.io.connection_points.spare_params.setInputlessParamNames(["pointsThreshold", "lineThreshold", "element"]);
  }
  setLines(linesController) {
    const usedOutputNames = this.io.outputs.used_output_names();
    if (usedOutputNames.includes(_utils_io_connections_Js__WEBPACK_IMPORTED_MODULE_0__/* .JsConnectionPointType.INTERSECTION */ .zF.INTERSECTION)) {
      this._addIntersectionRef(linesController);
    }
  }
  setTriggeringLines(linesController, triggeredMethods) {
    const object3D = (0,_BaseObject3D__WEBPACK_IMPORTED_MODULE_5__/* .inputObject3D */ .iv)(this, linesController);
    const blockObjectsBehind = this.variableForInputParam(linesController, this.p.blockObjectsBehind);
    const skipIfObjectsInFront = this.variableForInputParam(linesController, this.p.skipIfObjectsInFront);
    const traverseChildren = this.variableForInputParam(linesController, this.p.traverseChildren);
    const lineThreshold = this.variableForInputParam(linesController, this.p.lineThreshold);
    const pointsThreshold = this.variableForInputParam(linesController, this.p.pointsThreshold);
    const intersectionRef = this._addIntersectionRef(linesController);
    const func = _Poly__WEBPACK_IMPORTED_MODULE_6__/* .Poly.namedFunctionsRegister.getFunction */ .L.namedFunctionsRegister.getFunction(
      "addObjectToObjectPointerdownCheck",
      this,
      linesController
    );
    const options = {
      priority: {
        blockObjectsBehind,
        skipIfObjectsInFront
      },
      cpu: {
        traverseChildren,
        pointsThreshold,
        lineThreshold,
        intersectionRef: `this.${intersectionRef}`
      },
      pointerdown: {
        callback: `this.${(0,_code_assemblers_actor_ActorAssemblerUtils__WEBPACK_IMPORTED_MODULE_7__/* .nodeMethodName */ .Bp)(this)}.bind(this)`
      },
      config: (0,_BaseOnObjectPointerEvent__WEBPACK_IMPORTED_MODULE_1__/* .pointerButtonConfig */ .AI)(this, linesController)
    };
    const jsonOptions = JSON.stringify(options).replace(/"/g, "");
    const bodyLine = func.asString(object3D, `this`, jsonOptions);
    linesController.addDefinitions(this, [
      new _utils_JsDefinition__WEBPACK_IMPORTED_MODULE_8__/* .InitFunctionJsDefinition */ .TN(this, linesController, _utils_io_connections_Js__WEBPACK_IMPORTED_MODULE_0__/* .JsConnectionPointType.OBJECT_3D */ .zF.OBJECT_3D, this.path(), bodyLine)
    ]);
    linesController.addTriggeringLines(this, [triggeredMethods], { gatherable: true });
  }
  _addIntersectionRef(linesController) {
    const outIntersection = this.jsVarName(_utils_io_connections_Js__WEBPACK_IMPORTED_MODULE_0__/* .JsConnectionPointType.INTERSECTION */ .zF.INTERSECTION);
    linesController.addDefinitions(this, [
      new _utils_JsDefinition__WEBPACK_IMPORTED_MODULE_8__/* .RefJsDefinition */ .Z(this, linesController, _utils_io_connections_Js__WEBPACK_IMPORTED_MODULE_0__/* .JsConnectionPointType.INTERSECTION */ .zF.INTERSECTION, outIntersection, `null`)
    ]);
    return outIntersection;
  }
}


/***/ }),

/***/ 7164:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "z": function() { return /* binding */ OnObjectPointerupJsNode; }
/* harmony export */ });
/* unused harmony export OnObjectPointerupJsParamsConfig */
/* harmony import */ var _Base__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(38231);
/* harmony import */ var _utils_io_connections_Js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(38857);
/* harmony import */ var _poly_registers_nodes_types_Js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(16718);
/* harmony import */ var _BaseOnObjectPointerEvent__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(62700);
/* harmony import */ var _core_event_PointerEventType__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(43843);
/* harmony import */ var _BaseObject3D__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(75807);
/* harmony import */ var _Poly__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(99934);
/* harmony import */ var _utils_JsDefinition__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(36343);
/* harmony import */ var _code_assemblers_actor_ActorAssemblerUtils__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(15945);
/* harmony import */ var _core_event_TouchEventType__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(88763);
/* harmony import */ var _core_UserAgent__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(66689);












const CONNECTION_OPTIONS = _utils_io_connections_Js__WEBPACK_IMPORTED_MODULE_0__/* .JS_CONNECTION_POINT_IN_NODE_DEF */ .mX;
class OnObjectPointerupJsParamsConfig extends (0,_BaseOnObjectPointerEvent__WEBPACK_IMPORTED_MODULE_1__/* .PointerEventConfigParamConfig */ .qd)(
  _BaseOnObjectPointerEvent__WEBPACK_IMPORTED_MODULE_1__/* .CPUOnObjectPointerEventJsParamsConfig */ .hq
) {
}
const ParamsConfig = new OnObjectPointerupJsParamsConfig();
class OnObjectPointerupJsNode extends _BaseOnObjectPointerEvent__WEBPACK_IMPORTED_MODULE_1__/* .ExtendableOnObjectPointerEventJsNode */ .hs {
  constructor() {
    super(...arguments);
    this.paramsConfig = ParamsConfig;
  }
  static type() {
    return _poly_registers_nodes_types_Js__WEBPACK_IMPORTED_MODULE_2__/* .JsType.ON_OBJECT_POINTERUP */ .K.ON_OBJECT_POINTERUP;
  }
  eventData() {
    if ((0,_core_UserAgent__WEBPACK_IMPORTED_MODULE_3__/* .isTouchDevice */ .b1)()) {
      return {
        type: _core_event_TouchEventType__WEBPACK_IMPORTED_MODULE_4__/* .TouchEventType.touchend */ .R.touchend,
        emitter: this.eventEmitter(),
        jsType: _poly_registers_nodes_types_Js__WEBPACK_IMPORTED_MODULE_2__/* .JsType.ON_OBJECT_POINTERUP */ .K.ON_OBJECT_POINTERUP
      };
    } else {
      return {
        type: _core_event_PointerEventType__WEBPACK_IMPORTED_MODULE_5__/* .PointerEventType.pointerup */ .by.pointerup,
        emitter: this.eventEmitter(),
        jsType: _poly_registers_nodes_types_Js__WEBPACK_IMPORTED_MODULE_2__/* .JsType.ON_OBJECT_POINTERUP */ .K.ON_OBJECT_POINTERUP
      };
    }
  }
  initializeNode() {
    super.initializeNode();
    this.io.outputs.setNamedOutputConnectionPoints([
      new _utils_io_connections_Js__WEBPACK_IMPORTED_MODULE_0__/* .JsConnectionPoint */ .fp(_Base__WEBPACK_IMPORTED_MODULE_6__/* .TRIGGER_CONNECTION_NAME */ .w6, _utils_io_connections_Js__WEBPACK_IMPORTED_MODULE_0__/* .JsConnectionPointType.TRIGGER */ .zF.TRIGGER, CONNECTION_OPTIONS),
      new _utils_io_connections_Js__WEBPACK_IMPORTED_MODULE_0__/* .JsConnectionPoint */ .fp(
        _utils_io_connections_Js__WEBPACK_IMPORTED_MODULE_0__/* .JsConnectionPointType.INTERSECTION */ .zF.INTERSECTION,
        _utils_io_connections_Js__WEBPACK_IMPORTED_MODULE_0__/* .JsConnectionPointType.INTERSECTION */ .zF.INTERSECTION,
        CONNECTION_OPTIONS
      )
    ]);
    this.io.connection_points.spare_params.setInputlessParamNames(["pointsThreshold", "lineThreshold", "element"]);
  }
  setLines(linesController) {
    const usedOutputNames = this.io.outputs.used_output_names();
    if (usedOutputNames.includes(_utils_io_connections_Js__WEBPACK_IMPORTED_MODULE_0__/* .JsConnectionPointType.INTERSECTION */ .zF.INTERSECTION)) {
      this._addIntersectionRef(linesController);
    }
  }
  setTriggeringLines(linesController, triggeredMethods) {
    const object3D = (0,_BaseObject3D__WEBPACK_IMPORTED_MODULE_7__/* .inputObject3D */ .iv)(this, linesController);
    const blockObjectsBehind = this.variableForInputParam(linesController, this.p.blockObjectsBehind);
    const skipIfObjectsInFront = this.variableForInputParam(linesController, this.p.skipIfObjectsInFront);
    const traverseChildren = this.variableForInputParam(linesController, this.p.traverseChildren);
    const lineThreshold = this.variableForInputParam(linesController, this.p.lineThreshold);
    const pointsThreshold = this.variableForInputParam(linesController, this.p.pointsThreshold);
    const intersectionRef = this._addIntersectionRef(linesController);
    const func = _Poly__WEBPACK_IMPORTED_MODULE_8__/* .Poly.namedFunctionsRegister.getFunction */ .L.namedFunctionsRegister.getFunction("addObjectToObjectPointerupCheck", this, linesController);
    const options = {
      priority: {
        blockObjectsBehind,
        skipIfObjectsInFront
      },
      cpu: {
        traverseChildren,
        pointsThreshold,
        lineThreshold,
        intersectionRef: `this.${intersectionRef}`
      },
      pointerup: {
        callback: `this.${(0,_code_assemblers_actor_ActorAssemblerUtils__WEBPACK_IMPORTED_MODULE_9__/* .nodeMethodName */ .Bp)(this)}.bind(this)`
      },
      config: (0,_BaseOnObjectPointerEvent__WEBPACK_IMPORTED_MODULE_1__/* .pointerButtonConfig */ .AI)(this, linesController)
    };
    const jsonOptions = JSON.stringify(options).replace(/"/g, "");
    const bodyLine = func.asString(object3D, `this`, jsonOptions);
    linesController.addDefinitions(this, [
      new _utils_JsDefinition__WEBPACK_IMPORTED_MODULE_10__/* .InitFunctionJsDefinition */ .TN(this, linesController, _utils_io_connections_Js__WEBPACK_IMPORTED_MODULE_0__/* .JsConnectionPointType.OBJECT_3D */ .zF.OBJECT_3D, this.path(), bodyLine)
    ]);
    linesController.addTriggeringLines(this, [triggeredMethods], { gatherable: true });
  }
  _addIntersectionRef(linesController) {
    const outIntersection = this.jsVarName(_utils_io_connections_Js__WEBPACK_IMPORTED_MODULE_0__/* .JsConnectionPointType.INTERSECTION */ .zF.INTERSECTION);
    linesController.addDefinitions(this, [
      new _utils_JsDefinition__WEBPACK_IMPORTED_MODULE_10__/* .RefJsDefinition */ .Z(this, linesController, _utils_io_connections_Js__WEBPACK_IMPORTED_MODULE_0__/* .JsConnectionPointType.INTERSECTION */ .zF.INTERSECTION, outIntersection, `null`)
    ]);
    return outIntersection;
  }
}


/***/ }),

/***/ 52093:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "y": function() { return /* binding */ OnPointerdownJsNode; }
/* harmony export */ });
/* harmony import */ var _Base__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(38231);
/* harmony import */ var _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(96949);
/* harmony import */ var _utils_io_connections_Js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(38857);
/* harmony import */ var _poly_registers_nodes_types_Js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(16718);
/* harmony import */ var _BaseUserInput__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(78433);
/* harmony import */ var _core_event_CoreEventEmitter__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(9913);
/* harmony import */ var _core_event_PointerEventType__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(43843);
/* harmony import */ var _core_event_TouchEventType__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(88763);
/* harmony import */ var _core_UserAgent__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(66689);
/* harmony import */ var _BaseObject3D__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(75807);
/* harmony import */ var _Poly__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(99934);
/* harmony import */ var _utils_JsDefinition__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(36343);
/* harmony import */ var _code_assemblers_actor_ActorAssemblerUtils__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(15945);

var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));













const CONNECTION_OPTIONS = _utils_io_connections_Js__WEBPACK_IMPORTED_MODULE_0__/* .JS_CONNECTION_POINT_IN_NODE_DEF */ .mX;
class OnPointerdownJsParamsConfig extends _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .NodeParamsConfig */ .yI {
  constructor() {
    super(...arguments);
    /** @param set which element triggers the event */
    this.element = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .ParamConfig.INTEGER */ .XC.INTEGER(_core_event_CoreEventEmitter__WEBPACK_IMPORTED_MODULE_2__/* .EVENT_EMITTERS.indexOf */ .Br.indexOf(_core_event_CoreEventEmitter__WEBPACK_IMPORTED_MODULE_2__/* .CoreEventEmitter.CANVAS */ .Ok.CANVAS), __spreadProps(__spreadValues({}, _core_event_CoreEventEmitter__WEBPACK_IMPORTED_MODULE_2__/* .EVENT_EMITTER_PARAM_MENU_OPTIONS */ .lh), {
      separatorAfter: true
    }));
  }
}
const ParamsConfig = new OnPointerdownJsParamsConfig();
class OnPointerdownJsNode extends _BaseUserInput__WEBPACK_IMPORTED_MODULE_3__/* .BaseUserInputJsNode */ .U {
  constructor() {
    super(...arguments);
    this.paramsConfig = ParamsConfig;
  }
  static type() {
    return _poly_registers_nodes_types_Js__WEBPACK_IMPORTED_MODULE_4__/* .JsType.ON_POINTERDOWN */ .K.ON_POINTERDOWN;
  }
  eventData() {
    if ((0,_core_UserAgent__WEBPACK_IMPORTED_MODULE_5__/* .isTouchDevice */ .b1)()) {
      return {
        type: _core_event_TouchEventType__WEBPACK_IMPORTED_MODULE_6__/* .TouchEventType.touchstart */ .R.touchstart,
        emitter: this.eventEmitter(),
        jsType: _poly_registers_nodes_types_Js__WEBPACK_IMPORTED_MODULE_4__/* .JsType.ON_POINTERDOWN */ .K.ON_POINTERDOWN
      };
    } else {
      return {
        type: _core_event_PointerEventType__WEBPACK_IMPORTED_MODULE_7__/* .PointerEventType.pointerdown */ .by.pointerdown,
        emitter: this.eventEmitter(),
        jsType: _poly_registers_nodes_types_Js__WEBPACK_IMPORTED_MODULE_4__/* .JsType.ON_POINTERDOWN */ .K.ON_POINTERDOWN
      };
    }
  }
  eventEmitter() {
    return _core_event_CoreEventEmitter__WEBPACK_IMPORTED_MODULE_2__/* .EVENT_EMITTERS */ .Br[this.pv.element];
  }
  setEventEmitter(emitter) {
    this.p.element.set(_core_event_CoreEventEmitter__WEBPACK_IMPORTED_MODULE_2__/* .EVENT_EMITTERS.indexOf */ .Br.indexOf(emitter));
  }
  initializeNode() {
    super.initializeNode();
    this.io.outputs.setNamedOutputConnectionPoints([
      new _utils_io_connections_Js__WEBPACK_IMPORTED_MODULE_0__/* .JsConnectionPoint */ .fp(_Base__WEBPACK_IMPORTED_MODULE_8__/* .TRIGGER_CONNECTION_NAME */ .w6, _utils_io_connections_Js__WEBPACK_IMPORTED_MODULE_0__/* .JsConnectionPointType.TRIGGER */ .zF.TRIGGER, CONNECTION_OPTIONS)
    ]);
  }
  setTriggeringLines(linesController, triggeredMethods) {
    const object3D = (0,_BaseObject3D__WEBPACK_IMPORTED_MODULE_9__/* .inputObject3D */ .iv)(this, linesController);
    const func = _Poly__WEBPACK_IMPORTED_MODULE_10__/* .Poly.namedFunctionsRegister.getFunction */ .L.namedFunctionsRegister.getFunction("addObjectToPointerdownCheck", this, linesController);
    const options = {
      pointerdown: {
        callback: `this.${(0,_code_assemblers_actor_ActorAssemblerUtils__WEBPACK_IMPORTED_MODULE_11__/* .nodeMethodName */ .Bp)(this)}.bind(this)`
      }
    };
    const jsonOptions = JSON.stringify(options).replace(/"/g, "");
    const bodyLine = func.asString(object3D, `this`, jsonOptions);
    linesController.addDefinitions(this, [
      new _utils_JsDefinition__WEBPACK_IMPORTED_MODULE_12__/* .InitFunctionJsDefinition */ .TN(this, linesController, _utils_io_connections_Js__WEBPACK_IMPORTED_MODULE_0__/* .JsConnectionPointType.OBJECT_3D */ .zF.OBJECT_3D, this.path(), bodyLine)
    ]);
    linesController.addTriggeringLines(this, [triggeredMethods], { gatherable: true });
  }
}


/***/ }),

/***/ 19705:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "b": function() { return /* binding */ OnPointerupJsNode; }
/* harmony export */ });
/* harmony import */ var _Base__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(38231);
/* harmony import */ var _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(96949);
/* harmony import */ var _utils_io_connections_Js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(38857);
/* harmony import */ var _poly_registers_nodes_types_Js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(16718);
/* harmony import */ var _BaseUserInput__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(78433);
/* harmony import */ var _core_event_CoreEventEmitter__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(9913);
/* harmony import */ var _core_event_PointerEventType__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(43843);
/* harmony import */ var _core_event_TouchEventType__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(88763);
/* harmony import */ var _core_UserAgent__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(66689);
/* harmony import */ var _BaseObject3D__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(75807);
/* harmony import */ var _Poly__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(99934);
/* harmony import */ var _utils_JsDefinition__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(36343);
/* harmony import */ var _code_assemblers_actor_ActorAssemblerUtils__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(15945);

var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));













const CONNECTION_OPTIONS = _utils_io_connections_Js__WEBPACK_IMPORTED_MODULE_0__/* .JS_CONNECTION_POINT_IN_NODE_DEF */ .mX;
class OnPointerupJsParamsConfig extends _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .NodeParamsConfig */ .yI {
  constructor() {
    super(...arguments);
    /** @param set which element triggers the event */
    this.element = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .ParamConfig.INTEGER */ .XC.INTEGER(_core_event_CoreEventEmitter__WEBPACK_IMPORTED_MODULE_2__/* .EVENT_EMITTERS.indexOf */ .Br.indexOf(_core_event_CoreEventEmitter__WEBPACK_IMPORTED_MODULE_2__/* .CoreEventEmitter.CANVAS */ .Ok.CANVAS), __spreadProps(__spreadValues({}, _core_event_CoreEventEmitter__WEBPACK_IMPORTED_MODULE_2__/* .EVENT_EMITTER_PARAM_MENU_OPTIONS */ .lh), {
      separatorAfter: true
    }));
  }
}
const ParamsConfig = new OnPointerupJsParamsConfig();
class OnPointerupJsNode extends _BaseUserInput__WEBPACK_IMPORTED_MODULE_3__/* .BaseUserInputJsNode */ .U {
  constructor() {
    super(...arguments);
    this.paramsConfig = ParamsConfig;
  }
  static type() {
    return _poly_registers_nodes_types_Js__WEBPACK_IMPORTED_MODULE_4__/* .JsType.ON_POINTERUP */ .K.ON_POINTERUP;
  }
  isTriggering() {
    return true;
  }
  eventData() {
    if ((0,_core_UserAgent__WEBPACK_IMPORTED_MODULE_5__/* .isTouchDevice */ .b1)()) {
      return {
        type: _core_event_TouchEventType__WEBPACK_IMPORTED_MODULE_6__/* .TouchEventType.touchend */ .R.touchend,
        emitter: this.eventEmitter(),
        jsType: _poly_registers_nodes_types_Js__WEBPACK_IMPORTED_MODULE_4__/* .JsType.ON_POINTERUP */ .K.ON_POINTERUP
      };
    } else {
      return {
        type: _core_event_PointerEventType__WEBPACK_IMPORTED_MODULE_7__/* .PointerEventType.pointerup */ .by.pointerup,
        emitter: this.eventEmitter(),
        jsType: _poly_registers_nodes_types_Js__WEBPACK_IMPORTED_MODULE_4__/* .JsType.ON_POINTERUP */ .K.ON_POINTERUP
      };
    }
  }
  eventEmitter() {
    return _core_event_CoreEventEmitter__WEBPACK_IMPORTED_MODULE_2__/* .EVENT_EMITTERS */ .Br[this.pv.element];
  }
  setEventEmitter(emitter) {
    this.p.element.set(_core_event_CoreEventEmitter__WEBPACK_IMPORTED_MODULE_2__/* .EVENT_EMITTERS.indexOf */ .Br.indexOf(emitter));
  }
  initializeNode() {
    super.initializeNode();
    this.io.outputs.setNamedOutputConnectionPoints([
      new _utils_io_connections_Js__WEBPACK_IMPORTED_MODULE_0__/* .JsConnectionPoint */ .fp(_Base__WEBPACK_IMPORTED_MODULE_8__/* .TRIGGER_CONNECTION_NAME */ .w6, _utils_io_connections_Js__WEBPACK_IMPORTED_MODULE_0__/* .JsConnectionPointType.TRIGGER */ .zF.TRIGGER, CONNECTION_OPTIONS)
    ]);
  }
  setTriggeringLines(linesController, triggeredMethods) {
    const object3D = (0,_BaseObject3D__WEBPACK_IMPORTED_MODULE_9__/* .inputObject3D */ .iv)(this, linesController);
    const func = _Poly__WEBPACK_IMPORTED_MODULE_10__/* .Poly.namedFunctionsRegister.getFunction */ .L.namedFunctionsRegister.getFunction("addObjectToPointerupCheck", this, linesController);
    const options = {
      pointerup: {
        callback: `this.${(0,_code_assemblers_actor_ActorAssemblerUtils__WEBPACK_IMPORTED_MODULE_11__/* .nodeMethodName */ .Bp)(this)}.bind(this)`
      }
    };
    const jsonOptions = JSON.stringify(options).replace(/"/g, "");
    const bodyLine = func.asString(object3D, `this`, jsonOptions);
    linesController.addDefinitions(this, [
      new _utils_JsDefinition__WEBPACK_IMPORTED_MODULE_12__/* .InitFunctionJsDefinition */ .TN(this, linesController, _utils_io_connections_Js__WEBPACK_IMPORTED_MODULE_0__/* .JsConnectionPointType.OBJECT_3D */ .zF.OBJECT_3D, this.path(), bodyLine)
    ]);
    linesController.addTriggeringLines(this, [triggeredMethods], { gatherable: true });
  }
}


/***/ }),

/***/ 12936:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "o": function() { return /* binding */ OnTickJsNode; },
/* harmony export */   "x": function() { return /* binding */ OnTickJsNodeOuput; }
/* harmony export */ });
/* harmony import */ var _Base__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(38231);
/* harmony import */ var _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(96949);
/* harmony import */ var _utils_io_connections_Js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(38857);
/* harmony import */ var _poly_registers_nodes_types_Js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(16718);
/* harmony import */ var _utils_JsDefinition__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(36343);
/* harmony import */ var _Poly__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(99934);







var OnTickJsNodeOuput = /* @__PURE__ */ ((OnTickJsNodeOuput2) => {
  OnTickJsNodeOuput2["TIME"] = "time";
  OnTickJsNodeOuput2["DELTA"] = "delta";
  return OnTickJsNodeOuput2;
})(OnTickJsNodeOuput || {});
class OnTickJsParamsConfig extends _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_0__/* .NodeParamsConfig */ .yI {
}
const ParamsConfig = new OnTickJsParamsConfig();
class OnTickJsNode extends _Base__WEBPACK_IMPORTED_MODULE_1__/* .TypedJsNode */ .xZ {
  constructor() {
    super(...arguments);
    this.paramsConfig = ParamsConfig;
  }
  static type() {
    return _poly_registers_nodes_types_Js__WEBPACK_IMPORTED_MODULE_2__/* .JsType.ON_TICK */ .K.ON_TICK;
  }
  isTriggering() {
    return true;
  }
  initializeNode() {
    this.io.outputs.setNamedOutputConnectionPoints([
      new _utils_io_connections_Js__WEBPACK_IMPORTED_MODULE_3__/* .JsConnectionPoint */ .fp(_Base__WEBPACK_IMPORTED_MODULE_1__/* .TRIGGER_CONNECTION_NAME */ .w6, _utils_io_connections_Js__WEBPACK_IMPORTED_MODULE_3__/* .JsConnectionPointType.TRIGGER */ .zF.TRIGGER),
      new _utils_io_connections_Js__WEBPACK_IMPORTED_MODULE_3__/* .JsConnectionPoint */ .fp("time" /* TIME */, _utils_io_connections_Js__WEBPACK_IMPORTED_MODULE_3__/* .JsConnectionPointType.FLOAT */ .zF.FLOAT),
      new _utils_io_connections_Js__WEBPACK_IMPORTED_MODULE_3__/* .JsConnectionPoint */ .fp("delta" /* DELTA */, _utils_io_connections_Js__WEBPACK_IMPORTED_MODULE_3__/* .JsConnectionPointType.FLOAT */ .zF.FLOAT)
    ]);
  }
  setTriggeringLines(linesController, triggeredMethods) {
    linesController.addTriggeringLines(this, [triggeredMethods], { gatherable: true });
  }
  setLines(linesController) {
    const timeVarName = this.jsVarName("time" /* TIME */);
    const deltaVarName = this.jsVarName("delta" /* DELTA */);
    const _time = _Poly__WEBPACK_IMPORTED_MODULE_4__/* .Poly.namedFunctionsRegister.getFunction */ .L.namedFunctionsRegister.getFunction("globalsTime", this, linesController);
    const _delta = _Poly__WEBPACK_IMPORTED_MODULE_4__/* .Poly.namedFunctionsRegister.getFunction */ .L.namedFunctionsRegister.getFunction("globalsTimeDelta", this, linesController);
    linesController.addDefinitions(this, [
      new _utils_JsDefinition__WEBPACK_IMPORTED_MODULE_5__/* .ComputedValueJsDefinition */ .fV(
        this,
        linesController,
        _utils_io_connections_Js__WEBPACK_IMPORTED_MODULE_3__/* .JsConnectionPointType.FLOAT */ .zF.FLOAT,
        timeVarName,
        _time.asString()
      )
    ]);
    linesController.addDefinitions(this, [
      new _utils_JsDefinition__WEBPACK_IMPORTED_MODULE_5__/* .ComputedValueJsDefinition */ .fV(
        this,
        linesController,
        _utils_io_connections_Js__WEBPACK_IMPORTED_MODULE_3__/* .JsConnectionPointType.FLOAT */ .zF.FLOAT,
        deltaVarName,
        _delta.asString()
      )
    ]);
  }
}


/***/ }),

/***/ 94027:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "$": function() { return /* binding */ OnVideoEventJsNode; }
/* harmony export */ });
/* harmony import */ var _Base__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(38231);
/* harmony import */ var _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(96949);
/* harmony import */ var _utils_io_connections_Js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(38857);
/* harmony import */ var _poly_NodeContext__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(52070);
/* harmony import */ var _poly_registers_nodes_types_Cop__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(12764);
/* harmony import */ var _poly_registers_nodes_types_Js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(16718);
/* harmony import */ var _core_VideoEvent__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(83220);
/* harmony import */ var _code_assemblers_actor_ActorAssemblerUtils__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(15945);
/* harmony import */ var _core_SetUtils__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(55407);
/* harmony import */ var _Poly__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(99934);
/* harmony import */ var _utils_JsDefinition__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(36343);












class OnVideoEventJsParamsConfig extends _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_0__/* .NodeParamsConfig */ .yI {
  constructor() {
    super(...arguments);
    /** @param video node */
    this.node = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_0__/* .ParamConfig.NODE_PATH */ .XC.NODE_PATH("", {
      nodeSelection: {
        context: _poly_NodeContext__WEBPACK_IMPORTED_MODULE_1__/* .NodeContext.COP */ .sy.COP,
        types: [_poly_registers_nodes_types_Cop__WEBPACK_IMPORTED_MODULE_2__/* .CopType.VIDEO */ .y.VIDEO]
      },
      computeOnDirty: true
    });
  }
}
const ParamsConfig = new OnVideoEventJsParamsConfig();
class OnVideoEventJsNode extends _Base__WEBPACK_IMPORTED_MODULE_3__/* .TypedJsNode */ .xZ {
  constructor() {
    super(...arguments);
    this.paramsConfig = ParamsConfig;
  }
  static type() {
    return _poly_registers_nodes_types_Js__WEBPACK_IMPORTED_MODULE_4__/* .JsType.ON_VIDEO_EVENT */ .K.ON_VIDEO_EVENT;
  }
  isTriggering() {
    return true;
  }
  initializeNode() {
    this.io.outputs.setNamedOutputConnectionPoints(
      _core_VideoEvent__WEBPACK_IMPORTED_MODULE_5__/* .VIDEO_EVENTS.map */ .NW.map((triggerName) => new _utils_io_connections_Js__WEBPACK_IMPORTED_MODULE_6__/* .JsConnectionPoint */ .fp(triggerName, _utils_io_connections_Js__WEBPACK_IMPORTED_MODULE_6__/* .JsConnectionPointType.TRIGGER */ .zF.TRIGGER))
    );
  }
  setTriggeringLines(shadersCollectionController, triggeredMethods) {
    const node = this.pv.node.node();
    if (!(node && node.context() == _poly_NodeContext__WEBPACK_IMPORTED_MODULE_1__/* .NodeContext.COP */ .sy.COP)) {
      return;
    }
    const nodePath = `'${node.path()}'`;
    const listeners = {
      [_core_VideoEvent__WEBPACK_IMPORTED_MODULE_5__/* .VideoEvent.PAUSE */ .d.PAUSE]: "",
      [_core_VideoEvent__WEBPACK_IMPORTED_MODULE_5__/* .VideoEvent.PLAY */ .d.PLAY]: "",
      [_core_VideoEvent__WEBPACK_IMPORTED_MODULE_5__/* .VideoEvent.TIME_UPDATE */ .d.TIME_UPDATE]: "",
      [_core_VideoEvent__WEBPACK_IMPORTED_MODULE_5__/* .VideoEvent.VOLUME_CHANGE */ .d.VOLUME_CHANGE]: ""
    };
    _core_VideoEvent__WEBPACK_IMPORTED_MODULE_5__/* .VIDEO_EVENTS.forEach */ .NW.forEach((videoEvent) => {
      const triggeredMethods2 = triggerMethod(this, videoEvent);
      const _nodeMethodName = (0,_code_assemblers_actor_ActorAssemblerUtils__WEBPACK_IMPORTED_MODULE_7__/* .nodeMethodName */ .Bp)(this, videoEvent);
      listeners[videoEvent] = `this.${_nodeMethodName}.bind(this)`;
      const value = triggeredMethods2;
      const dataType = _utils_io_connections_Js__WEBPACK_IMPORTED_MODULE_6__/* .JsConnectionPointType.BOOLEAN */ .zF.BOOLEAN;
      shadersCollectionController.addDefinitions(this, [
        new _utils_JsDefinition__WEBPACK_IMPORTED_MODULE_8__/* .TriggeringJsDefinition */ .id(this, shadersCollectionController, dataType, _nodeMethodName, value, {
          triggeringMethodName: videoEvent,
          gatherable: false,
          nodeMethodName: _nodeMethodName
        })
      ]);
    });
    const func = _Poly__WEBPACK_IMPORTED_MODULE_9__/* .Poly.namedFunctionsRegister.getFunction */ .L.namedFunctionsRegister.getFunction(
      "addVideoEventListener",
      this,
      shadersCollectionController
    );
    const bodyLine = func.asString(nodePath, JSON.stringify(listeners).replace(/\"/g, ""), `this`);
    shadersCollectionController.addDefinitions(this, [
      new _utils_JsDefinition__WEBPACK_IMPORTED_MODULE_8__/* .InitFunctionJsDefinition */ .TN(
        this,
        shadersCollectionController,
        _utils_io_connections_Js__WEBPACK_IMPORTED_MODULE_6__/* .JsConnectionPointType.OBJECT_3D */ .zF.OBJECT_3D,
        this.path(),
        bodyLine
      )
    ]);
  }
}
function triggerMethod(node, outputName) {
  const outputIndex = (0,_code_assemblers_actor_ActorAssemblerUtils__WEBPACK_IMPORTED_MODULE_7__/* .getOutputIndices */ .D0)(node, (c) => c.name() == outputName)[0];
  const triggerableNodes = /* @__PURE__ */ new Set();
  (0,_code_assemblers_actor_ActorAssemblerUtils__WEBPACK_IMPORTED_MODULE_7__/* .getConnectedOutputNodes */ .YZ)({
    node,
    triggerOutputIndices: [outputIndex],
    triggerableNodes,
    recursive: false
  });
  const triggerableMethodNames = (0,_core_SetUtils__WEBPACK_IMPORTED_MODULE_10__/* .setToArray */ .T_)(triggerableNodes, []).map((triggerableNode) => {
    const argIndex = (0,_code_assemblers_actor_ActorAssemblerUtils__WEBPACK_IMPORTED_MODULE_7__/* .triggerInputIndex */ .D6)(node, triggerableNode);
    const m = (0,_code_assemblers_actor_ActorAssemblerUtils__WEBPACK_IMPORTED_MODULE_7__/* .nodeMethodName */ .Bp)(triggerableNode);
    return `this.${m}(${argIndex})`;
  });
  return `${triggerableMethodNames.join(";")}`;
}


/***/ }),

/***/ 27568:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "p": function() { return /* binding */ ParamJsNode; }
/* harmony export */ });
/* harmony import */ var _Base__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(38231);
/* harmony import */ var _utils_io_connections_Js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(38857);
/* harmony import */ var _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(96949);
/* harmony import */ var _utils_code_controllers_ParamConfigsController__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(94717);
/* harmony import */ var _code_utils_JsParamConfig__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(35833);
/* harmony import */ var _Poly__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(99934);







class ParamJsParamsConfig extends _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_0__/* .NodeParamsConfig */ .yI {
  constructor() {
    super(...arguments);
    this.name = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_0__/* .ParamConfig.STRING */ .XC.STRING("");
    this.type = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_0__/* .ParamConfig.INTEGER */ .XC.INTEGER(_utils_io_connections_Js__WEBPACK_IMPORTED_MODULE_1__/* .PARAM_CONVERTIBLE_JS_CONNECTION_POINT_TYPES.indexOf */ .mH.indexOf(_utils_io_connections_Js__WEBPACK_IMPORTED_MODULE_1__/* .JsConnectionPointType.FLOAT */ .zF.FLOAT), {
      menu: {
        entries: _utils_io_connections_Js__WEBPACK_IMPORTED_MODULE_1__/* .PARAM_CONVERTIBLE_JS_CONNECTION_POINT_TYPES.map */ .mH.map((name, i) => {
          return { name, value: i };
        })
      }
    });
  }
}
const ParamsConfig = new ParamJsParamsConfig();
const _ParamJsNode = class extends _Base__WEBPACK_IMPORTED_MODULE_2__/* .TypedJsNode */ .xZ {
  constructor() {
    super(...arguments);
    this.paramsConfig = ParamsConfig;
  }
  static type() {
    return "param";
  }
  initializeNode() {
    this.addPostDirtyHook("_setFunctionNodeToRecompile", this._setFunctionNodeToRecompile.bind(this));
    this.io.connection_points.initializeNode();
    this.io.connection_points.set_output_name_function((index) => _ParamJsNode.OUTPUT_NAME);
    this.io.connection_points.set_expected_input_types_function(() => []);
    this.io.connection_points.set_expected_output_types_function(() => [
      _utils_io_connections_Js__WEBPACK_IMPORTED_MODULE_1__/* .PARAM_CONVERTIBLE_JS_CONNECTION_POINT_TYPES */ .mH[this.pv.type]
    ]);
  }
  setLines(shadersCollectionController) {
    const out = this.jsVarName(_ParamJsNode.OUTPUT_NAME);
    const _func = _Poly__WEBPACK_IMPORTED_MODULE_3__/* .Poly.namedFunctionsRegister.getFunction */ .L.namedFunctionsRegister.getFunction(
      "getActorNodeParamValue",
      this,
      shadersCollectionController
    );
    shadersCollectionController.addBodyOrComputed(this, [
      {
        dataType: _utils_io_connections_Js__WEBPACK_IMPORTED_MODULE_1__/* .PARAM_CONVERTIBLE_JS_CONNECTION_POINT_TYPES */ .mH[this.pv.type],
        varName: out,
        value: _func.asString(`'${this.pv.name}'`)
      }
    ]);
  }
  setParamConfigs() {
    const type = _utils_io_connections_Js__WEBPACK_IMPORTED_MODULE_1__/* .PARAM_CONVERTIBLE_JS_CONNECTION_POINT_TYPES */ .mH[this.pv.type];
    const defaultValue = _utils_io_connections_Js__WEBPACK_IMPORTED_MODULE_1__/* .JsConnectionPointInitValueMap */ .BR[type];
    const paramType = _utils_io_connections_Js__WEBPACK_IMPORTED_MODULE_1__/* .JsConnectionPointTypeToParamTypeMap */ .dK[type];
    this._param_configs_controller = this._param_configs_controller || new _utils_code_controllers_ParamConfigsController__WEBPACK_IMPORTED_MODULE_4__/* .ParamConfigsController */ .e();
    this._param_configs_controller.reset();
    const param_config = new _code_utils_JsParamConfig__WEBPACK_IMPORTED_MODULE_5__/* .JsParamConfig */ .M(paramType, this.pv.name, defaultValue, this.uniformName());
    this._param_configs_controller.push(param_config);
  }
  uniformName() {
    return this.jsVarName(_ParamJsNode.OUTPUT_NAME);
  }
  setJsType(type) {
    const index = _utils_io_connections_Js__WEBPACK_IMPORTED_MODULE_1__/* .PARAM_CONVERTIBLE_JS_CONNECTION_POINT_TYPES.indexOf */ .mH.indexOf(type);
    this.p.type.set(index);
  }
  paramsGenerating() {
    return true;
  }
};
let ParamJsNode = _ParamJsNode;
// protected _allow_inputs_created_from_params: boolean = false;
// static readonly UNIFORM_NAME = 'paramVal';
ParamJsNode.OUTPUT_NAME = "val";


/***/ }),

/***/ 2794:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "s": function() { return /* binding */ PauseAudioSourceJsNode; }
/* harmony export */ });
/* harmony import */ var _Poly__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(99934);
/* harmony import */ var _BaseAudioSource__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(19376);
/* harmony import */ var _BaseObject3D__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(75807);




class PauseAudioSourceJsNode extends _BaseAudioSource__WEBPACK_IMPORTED_MODULE_0__/* .BaseAudioSourceJsNode */ .R {
  static type() {
    return "pauseAudioSource";
  }
  setTriggerableLines(shadersCollectionController) {
    const object3D = (0,_BaseObject3D__WEBPACK_IMPORTED_MODULE_1__/* .inputObject3D */ .iv)(this, shadersCollectionController);
    const node = this.pv.node.node();
    if (!node) {
      return;
    }
    const nodePath = `'${node.path()}'`;
    const func = _Poly__WEBPACK_IMPORTED_MODULE_2__/* .Poly.namedFunctionsRegister.getFunction */ .L.namedFunctionsRegister.getFunction("pauseAudioSource", this, shadersCollectionController);
    const bodyLine = func.asString(object3D, nodePath);
    shadersCollectionController.addTriggerableLines(this, [bodyLine]);
  }
  setTriggeringLines(shadersCollectionController, triggeredMethods) {
    shadersCollectionController.addTriggeringLines(this, [triggeredMethods], { gatherable: false });
  }
}


/***/ }),

/***/ 97179:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "r": function() { return /* binding */ PlayAnimationJsNode; }
/* harmony export */ });
/* unused harmony export AnimationJsOutput */
/* harmony import */ var _Base__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(38231);
/* harmony import */ var _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(96949);
/* harmony import */ var _utils_io_connections_Js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(38857);
/* harmony import */ var _poly_NodeContext__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(52070);
/* harmony import */ var _BaseObject3D__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(75807);
/* harmony import */ var _Poly__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(99934);
/* harmony import */ var _poly_registers_modules_Common__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(26280);








const CONNECTION_OPTIONS = _utils_io_connections_Js__WEBPACK_IMPORTED_MODULE_0__/* .JS_CONNECTION_POINT_IN_NODE_DEF */ .mX;
var AnimationJsOutput = /* @__PURE__ */ ((AnimationJsOutput2) => {
  AnimationJsOutput2["START"] = "start";
  AnimationJsOutput2["COMPLETE"] = "completed";
  return AnimationJsOutput2;
})(AnimationJsOutput || {});
class PlayAnimationJsParamsConfig extends _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .NodeParamsConfig */ .yI {
  constructor() {
    super(...arguments);
    /** @param include children */
    this.node = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .ParamConfig.NODE_PATH */ .XC.NODE_PATH("", {
      nodeSelection: { context: _poly_NodeContext__WEBPACK_IMPORTED_MODULE_2__/* .NodeContext.ANIM */ .sy.ANIM },
      dependentOnFoundNode: false
    });
  }
}
const ParamsConfig = new PlayAnimationJsParamsConfig();
class PlayAnimationJsNode extends _Base__WEBPACK_IMPORTED_MODULE_3__/* .TypedJsNode */ .xZ {
  constructor() {
    super(...arguments);
    this.paramsConfig = ParamsConfig;
  }
  static type() {
    return "playAnimation";
  }
  requiredModules() {
    return [_poly_registers_modules_Common__WEBPACK_IMPORTED_MODULE_4__/* .ModuleName.GSAP */ .r.GSAP];
  }
  initializeNode() {
    this.io.inputs.setNamedInputConnectionPoints([
      new _utils_io_connections_Js__WEBPACK_IMPORTED_MODULE_0__/* .JsConnectionPoint */ .fp(_Base__WEBPACK_IMPORTED_MODULE_3__/* .TRIGGER_CONNECTION_NAME */ .w6, _utils_io_connections_Js__WEBPACK_IMPORTED_MODULE_0__/* .JsConnectionPointType.TRIGGER */ .zF.TRIGGER, CONNECTION_OPTIONS),
      new _utils_io_connections_Js__WEBPACK_IMPORTED_MODULE_0__/* .JsConnectionPoint */ .fp(_utils_io_connections_Js__WEBPACK_IMPORTED_MODULE_0__/* .JsConnectionPointType.OBJECT_3D */ .zF.OBJECT_3D, _utils_io_connections_Js__WEBPACK_IMPORTED_MODULE_0__/* .JsConnectionPointType.OBJECT_3D */ .zF.OBJECT_3D, CONNECTION_OPTIONS)
    ]);
    this.io.outputs.setNamedOutputConnectionPoints([
      new _utils_io_connections_Js__WEBPACK_IMPORTED_MODULE_0__/* .JsConnectionPoint */ .fp("start" /* START */, _utils_io_connections_Js__WEBPACK_IMPORTED_MODULE_0__/* .JsConnectionPointType.TRIGGER */ .zF.TRIGGER),
      new _utils_io_connections_Js__WEBPACK_IMPORTED_MODULE_0__/* .JsConnectionPoint */ .fp("completed" /* COMPLETE */, _utils_io_connections_Js__WEBPACK_IMPORTED_MODULE_0__/* .JsConnectionPointType.TRIGGER */ .zF.TRIGGER)
    ]);
  }
  setTriggerableLines(shadersCollectionController) {
    const object3D = (0,_BaseObject3D__WEBPACK_IMPORTED_MODULE_5__/* .inputObject3D */ .iv)(this, shadersCollectionController);
    const node = this.pv.node.node();
    if (!node) {
      return;
    }
    const nodePath = `'${node.path()}'`;
    const func = _Poly__WEBPACK_IMPORTED_MODULE_6__/* .Poly.namedFunctionsRegister.getFunction */ .L.namedFunctionsRegister.getFunction("playAnimation", this, shadersCollectionController);
    const bodyLine = func.asString(object3D, nodePath);
    shadersCollectionController.addTriggerableLines(this, [bodyLine]);
  }
}


/***/ }),

/***/ 80701:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "J": function() { return /* binding */ PlayAudioSourceJsNode; }
/* harmony export */ });
/* harmony import */ var _Poly__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(99934);
/* harmony import */ var _utils_io_connections_Js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(38857);
/* harmony import */ var _code_assemblers_actor_ActorAssemblerUtils__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(15945);
/* harmony import */ var _utils_JsDefinition__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(36343);
/* harmony import */ var _BaseAudioSource__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(19376);
/* harmony import */ var _BaseObject3D__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(75807);







class PlayAudioSourceJsNode extends _BaseAudioSource__WEBPACK_IMPORTED_MODULE_0__/* .BaseAudioSourceJsNode */ .R {
  static type() {
    return "playAudioSource";
  }
  _targetNodePath() {
    const node = this.pv.node.node();
    if (!node) {
      return;
    }
    const nodePath = `'${node.path()}'`;
    return nodePath;
  }
  setTriggerableLines(shadersCollectionController) {
    const nodePath = this._targetNodePath();
    if (!nodePath) {
      return;
    }
    const _addPlay = () => {
      const object3D = (0,_BaseObject3D__WEBPACK_IMPORTED_MODULE_1__/* .inputObject3D */ .iv)(this, shadersCollectionController);
      const func = _Poly__WEBPACK_IMPORTED_MODULE_2__/* .Poly.namedFunctionsRegister.getFunction */ .L.namedFunctionsRegister.getFunction("playAudioSource", this, shadersCollectionController);
      const bodyLine = func.asString(object3D, nodePath);
      shadersCollectionController.addTriggerableLines(this, [bodyLine], { addTriggeredLines: false });
    };
    const _addOnStop = () => {
      const usedOutputNames = this.io.outputs.used_output_names();
      if (!usedOutputNames.includes(_utils_io_connections_Js__WEBPACK_IMPORTED_MODULE_3__/* .JsConnectionPointType.TRIGGER */ .zF.TRIGGER)) {
        return;
      }
      const func = _Poly__WEBPACK_IMPORTED_MODULE_2__/* .Poly.namedFunctionsRegister.getFunction */ .L.namedFunctionsRegister.getFunction(
        "addAudioStopEventListener",
        this,
        shadersCollectionController
      );
      const onStopMethodName = (0,_code_assemblers_actor_ActorAssemblerUtils__WEBPACK_IMPORTED_MODULE_4__/* .nodeMethodName */ .Bp)(this, "onStop");
      const bodyLine = func.asString(nodePath, `this.${onStopMethodName}.bind(this)`, `this`);
      shadersCollectionController.addDefinitions(this, [
        new _utils_JsDefinition__WEBPACK_IMPORTED_MODULE_5__/* .InitFunctionJsDefinition */ .TN(
          this,
          shadersCollectionController,
          _utils_io_connections_Js__WEBPACK_IMPORTED_MODULE_3__/* .JsConnectionPointType.OBJECT_3D */ .zF.OBJECT_3D,
          this.path(),
          bodyLine
        )
      ]);
      const triggerableLines = (0,_code_assemblers_actor_ActorAssemblerUtils__WEBPACK_IMPORTED_MODULE_4__/* .triggerableMethodCalls */ .Zu)(this);
      const value = triggerableLines;
      const varName = onStopMethodName;
      const dataType = _utils_io_connections_Js__WEBPACK_IMPORTED_MODULE_3__/* .JsConnectionPointType.BOOLEAN */ .zF.BOOLEAN;
      shadersCollectionController.addDefinitions(this, [
        new _utils_JsDefinition__WEBPACK_IMPORTED_MODULE_5__/* .TriggerableJsDefinition */ .rP(this, shadersCollectionController, dataType, varName, value, {
          methodName: onStopMethodName
        })
      ]);
    };
    _addPlay();
    _addOnStop();
  }
}


/***/ }),

/***/ 6365:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "D": function() { return /* binding */ PlayInstrumentNoteJsNode; }
/* harmony export */ });
/* harmony import */ var _Base__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(38231);
/* harmony import */ var _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(96949);
/* harmony import */ var _utils_io_connections_Js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(38857);
/* harmony import */ var _poly_NodeContext__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(52070);
/* harmony import */ var _core_audio_Notes__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(19286);
/* harmony import */ var _BaseObject3D__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(75807);
/* harmony import */ var _Poly__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(99934);








const CONNECTION_OPTIONS = _utils_io_connections_Js__WEBPACK_IMPORTED_MODULE_0__/* .JS_CONNECTION_POINT_IN_NODE_DEF */ .mX;
class PlayInstrumentNoteJsParamsConfig extends _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .NodeParamsConfig */ .yI {
  constructor() {
    super(...arguments);
    /** @param audio node */
    this.node = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .ParamConfig.NODE_PATH */ .XC.NODE_PATH("", {
      nodeSelection: {
        context: _poly_NodeContext__WEBPACK_IMPORTED_MODULE_2__/* .NodeContext.AUDIO */ .sy.AUDIO
      }
      // dependentOnFoundNode: false,
    });
    /** @param note */
    this.note = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .ParamConfig.STRING */ .XC.STRING(_core_audio_Notes__WEBPACK_IMPORTED_MODULE_3__/* .DEFAULT_NOTE */ .Q, {
      menuString: {
        entries: _core_audio_Notes__WEBPACK_IMPORTED_MODULE_3__/* .ALL_NOTES.sort */ .z.sort().map((note) => {
          return { value: note, name: note };
        })
      },
      cook: false
    });
    /** @param duration */
    this.duration = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .ParamConfig.FLOAT */ .XC.FLOAT(0.125, {
      range: [0, 1],
      rangeLocked: [true, false],
      cook: false
    });
  }
}
const ParamsConfig = new PlayInstrumentNoteJsParamsConfig();
class PlayInstrumentNoteJsNode extends _Base__WEBPACK_IMPORTED_MODULE_4__/* .TypedJsNode */ .xZ {
  constructor() {
    super(...arguments);
    this.paramsConfig = ParamsConfig;
  }
  static type() {
    return "playInstrumentNote";
  }
  initializeNode() {
    this.io.inputs.setNamedInputConnectionPoints([
      new _utils_io_connections_Js__WEBPACK_IMPORTED_MODULE_0__/* .JsConnectionPoint */ .fp(_Base__WEBPACK_IMPORTED_MODULE_4__/* .TRIGGER_CONNECTION_NAME */ .w6, _utils_io_connections_Js__WEBPACK_IMPORTED_MODULE_0__/* .JsConnectionPointType.TRIGGER */ .zF.TRIGGER, CONNECTION_OPTIONS),
      new _utils_io_connections_Js__WEBPACK_IMPORTED_MODULE_0__/* .JsConnectionPoint */ .fp(_utils_io_connections_Js__WEBPACK_IMPORTED_MODULE_0__/* .JsConnectionPointType.OBJECT_3D */ .zF.OBJECT_3D, _utils_io_connections_Js__WEBPACK_IMPORTED_MODULE_0__/* .JsConnectionPointType.OBJECT_3D */ .zF.OBJECT_3D, CONNECTION_OPTIONS)
    ]);
  }
  setTriggerableLines(shadersCollectionController) {
    const object3D = (0,_BaseObject3D__WEBPACK_IMPORTED_MODULE_5__/* .inputObject3D */ .iv)(this, shadersCollectionController);
    const note = this.variableForInputParam(shadersCollectionController, this.p.note);
    const duration = this.variableForInputParam(shadersCollectionController, this.p.duration);
    const node = this.pv.node.node();
    if (!node) {
      return;
    }
    const nodePath = `'${node.path()}'`;
    const func = _Poly__WEBPACK_IMPORTED_MODULE_6__/* .Poly.namedFunctionsRegister.getFunction */ .L.namedFunctionsRegister.getFunction("playInstrumentNote", this, shadersCollectionController);
    const bodyLine = func.asString(object3D, nodePath, note, duration);
    shadersCollectionController.addTriggerableLines(this, [bodyLine]);
  }
}


/***/ }),

/***/ 81025:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "C": function() { return /* binding */ RayFromCursorJsNode; }
/* harmony export */ });
/* harmony import */ var _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(96949);
/* harmony import */ var _utils_io_connections_Js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(38857);
/* harmony import */ var _poly_registers_nodes_types_Js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(16718);
/* harmony import */ var _BaseUserInput__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(78433);
/* harmony import */ var _core_event_CoreEventEmitter__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(9913);
/* harmony import */ var _utils_JsDefinition__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(36343);
/* harmony import */ var _Poly__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(99934);
/* harmony import */ var _core_event_PointerEventType__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(43843);

var __defProp = Object.defineProperty;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};








const OUTPUT_NAME = _utils_io_connections_Js__WEBPACK_IMPORTED_MODULE_0__/* .JsConnectionPointType.RAY */ .zF.RAY;
class RayFromCursorJsParamsConfig extends _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .NodeParamsConfig */ .yI {
  constructor() {
    super(...arguments);
    /** @param set which element triggers the event */
    this.element = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .ParamConfig.INTEGER */ .XC.INTEGER(_core_event_CoreEventEmitter__WEBPACK_IMPORTED_MODULE_2__/* .EVENT_EMITTERS.indexOf */ .Br.indexOf(_core_event_CoreEventEmitter__WEBPACK_IMPORTED_MODULE_2__/* .CoreEventEmitter.CANVAS */ .Ok.CANVAS), __spreadValues({}, _core_event_CoreEventEmitter__WEBPACK_IMPORTED_MODULE_2__/* .EVENT_EMITTER_PARAM_MENU_OPTIONS */ .lh));
  }
}
const ParamsConfig = new RayFromCursorJsParamsConfig();
class RayFromCursorJsNode extends _BaseUserInput__WEBPACK_IMPORTED_MODULE_3__/* .BaseUserInputJsNode */ .U {
  constructor() {
    super(...arguments);
    this.paramsConfig = ParamsConfig;
  }
  static type() {
    return _poly_registers_nodes_types_Js__WEBPACK_IMPORTED_MODULE_4__/* .JsType.RAY_FROM_CURSOR */ .K.RAY_FROM_CURSOR;
  }
  // userInputEventNames() {
  // 	return ['pointermove'];
  // }
  eventData() {
    return [
      {
        type: _core_event_PointerEventType__WEBPACK_IMPORTED_MODULE_5__/* .PointerEventType.pointermove */ .by.pointermove,
        emitter: this.eventEmitter(),
        jsType: _poly_registers_nodes_types_Js__WEBPACK_IMPORTED_MODULE_4__/* .JsType.RAY_FROM_CURSOR */ .K.RAY_FROM_CURSOR
      },
      {
        type: _core_event_PointerEventType__WEBPACK_IMPORTED_MODULE_5__/* .PointerEventType.touchmove */ .by.touchmove,
        emitter: this.eventEmitter(),
        jsType: _poly_registers_nodes_types_Js__WEBPACK_IMPORTED_MODULE_4__/* .JsType.RAY_FROM_CURSOR */ .K.RAY_FROM_CURSOR
      }
    ];
  }
  eventEmitter() {
    return _core_event_CoreEventEmitter__WEBPACK_IMPORTED_MODULE_2__/* .EVENT_EMITTERS */ .Br[this.pv.element];
  }
  setEventEmitter(emitter) {
    this.p.element.set(_core_event_CoreEventEmitter__WEBPACK_IMPORTED_MODULE_2__/* .EVENT_EMITTERS.indexOf */ .Br.indexOf(emitter));
  }
  initializeNode() {
    this.io.connection_points.spare_params.setInputlessParamNames(["element"]);
    this.io.outputs.setNamedOutputConnectionPoints([new _utils_io_connections_Js__WEBPACK_IMPORTED_MODULE_0__/* .JsConnectionPoint */ .fp(OUTPUT_NAME, _utils_io_connections_Js__WEBPACK_IMPORTED_MODULE_0__/* .JsConnectionPointType.RAY */ .zF.RAY)]);
  }
  setLines(shadersCollectionController) {
    const out = this.jsVarName(OUTPUT_NAME);
    const _ray = _Poly__WEBPACK_IMPORTED_MODULE_6__/* .Poly.namedFunctionsRegister.getFunction */ .L.namedFunctionsRegister.getFunction("globalsRayFromCursor", this, shadersCollectionController);
    shadersCollectionController.addDefinitions(this, [
      new _utils_JsDefinition__WEBPACK_IMPORTED_MODULE_7__/* .ComputedValueJsDefinition */ .fV(
        this,
        shadersCollectionController,
        _utils_io_connections_Js__WEBPACK_IMPORTED_MODULE_0__/* .JsConnectionPointType.VECTOR2 */ .zF.VECTOR2,
        out,
        _ray.asString()
      )
    ]);
  }
}


/***/ }),

/***/ 8660:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "c": function() { return /* binding */ SetObjectAttributeJsNode; }
/* harmony export */ });
/* unused harmony export SetObjectAttributeInputName */
/* harmony import */ var _Base__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(38231);
/* harmony import */ var _utils_io_connections_Js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(38857);
/* harmony import */ var _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(96949);
/* harmony import */ var _BaseObject3D__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(75807);
/* harmony import */ var _Poly__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(99934);
/* harmony import */ var _poly_registers_nodes_types_Js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(16718);

var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));






var SetObjectAttributeInputName = /* @__PURE__ */ ((SetObjectAttributeInputName2) => {
  SetObjectAttributeInputName2["attribName"] = "attribName";
  SetObjectAttributeInputName2["lerp"] = "lerp";
  SetObjectAttributeInputName2["val"] = "val";
  return SetObjectAttributeInputName2;
})(SetObjectAttributeInputName || {});
const CONNECTION_OPTIONS = _utils_io_connections_Js__WEBPACK_IMPORTED_MODULE_0__/* .JS_CONNECTION_POINT_IN_NODE_DEF */ .mX;
class SetObjectAttributeJsParamsConfig extends _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .NodeParamsConfig */ .yI {
  constructor() {
    super(...arguments);
    /** @param attribute type */
    this.type = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .ParamConfig.INTEGER */ .XC.INTEGER(_utils_io_connections_Js__WEBPACK_IMPORTED_MODULE_0__/* .PARAM_CONVERTIBLE_JS_CONNECTION_POINT_TYPES.indexOf */ .mH.indexOf(_utils_io_connections_Js__WEBPACK_IMPORTED_MODULE_0__/* .JsConnectionPointType.FLOAT */ .zF.FLOAT), {
      menu: {
        entries: _utils_io_connections_Js__WEBPACK_IMPORTED_MODULE_0__/* .PARAM_CONVERTIBLE_JS_CONNECTION_POINT_TYPES.map */ .mH.map((name, i) => {
          return { name, value: i };
        })
      }
    });
  }
}
const ParamsConfig = new SetObjectAttributeJsParamsConfig();
class SetObjectAttributeJsNode extends _Base__WEBPACK_IMPORTED_MODULE_2__/* .TypedJsNode */ .xZ {
  constructor() {
    super(...arguments);
    this.paramsConfig = ParamsConfig;
    this._nextAttribName = "";
  }
  static type() {
    return _poly_registers_nodes_types_Js__WEBPACK_IMPORTED_MODULE_3__/* .JsType.SET_OBJECT_ATTRIBUTE */ .K.SET_OBJECT_ATTRIBUTE;
  }
  initializeNode() {
    this.io.inputs.setNamedInputConnectionPoints([
      new _utils_io_connections_Js__WEBPACK_IMPORTED_MODULE_0__/* .JsConnectionPoint */ .fp(_Base__WEBPACK_IMPORTED_MODULE_2__/* .TRIGGER_CONNECTION_NAME */ .w6, _utils_io_connections_Js__WEBPACK_IMPORTED_MODULE_0__/* .JsConnectionPointType.TRIGGER */ .zF.TRIGGER, CONNECTION_OPTIONS),
      new _utils_io_connections_Js__WEBPACK_IMPORTED_MODULE_0__/* .JsConnectionPoint */ .fp(_utils_io_connections_Js__WEBPACK_IMPORTED_MODULE_0__/* .JsConnectionPointType.OBJECT_3D */ .zF.OBJECT_3D, _utils_io_connections_Js__WEBPACK_IMPORTED_MODULE_0__/* .JsConnectionPointType.OBJECT_3D */ .zF.OBJECT_3D, CONNECTION_OPTIONS),
      new _utils_io_connections_Js__WEBPACK_IMPORTED_MODULE_0__/* .JsConnectionPoint */ .fp(
        "attribName" /* attribName */,
        _utils_io_connections_Js__WEBPACK_IMPORTED_MODULE_0__/* .JsConnectionPointType.STRING */ .zF.STRING,
        CONNECTION_OPTIONS
      ),
      new _utils_io_connections_Js__WEBPACK_IMPORTED_MODULE_0__/* .JsConnectionPoint */ .fp("lerp", _utils_io_connections_Js__WEBPACK_IMPORTED_MODULE_0__/* .JsConnectionPointType.FLOAT */ .zF.FLOAT, __spreadProps(__spreadValues({}, CONNECTION_OPTIONS), {
        init_value: 1
      }))
    ]);
    this.io.connection_points.set_input_name_function(() => "val" /* val */);
    this.io.connection_points.set_expected_input_types_function(() => [this._currentConnectionType()]);
    this.io.connection_points.set_output_name_function(
      (i) => [_Base__WEBPACK_IMPORTED_MODULE_2__/* .TRIGGER_CONNECTION_NAME */ .w6, _utils_io_connections_Js__WEBPACK_IMPORTED_MODULE_0__/* .JsConnectionPointType.OBJECT_3D */ .zF.OBJECT_3D][i]
    );
    this.io.connection_points.set_expected_output_types_function(() => [
      _utils_io_connections_Js__WEBPACK_IMPORTED_MODULE_0__/* .JsConnectionPointType.TRIGGER */ .zF.TRIGGER,
      _utils_io_connections_Js__WEBPACK_IMPORTED_MODULE_0__/* .JsConnectionPointType.OBJECT_3D */ .zF.OBJECT_3D
    ]);
  }
  _currentConnectionType() {
    if (this.pv.type == null) {
      console.warn(`${this.type()} js node type not valid`);
    }
    const connectionType = _utils_io_connections_Js__WEBPACK_IMPORTED_MODULE_0__/* .PARAM_CONVERTIBLE_JS_CONNECTION_POINT_TYPES */ .mH[this.pv.type];
    if (connectionType == null) {
      console.warn(`${this.type()} js node type not valid`);
    }
    return connectionType || _utils_io_connections_Js__WEBPACK_IMPORTED_MODULE_0__/* .JsConnectionPointType.FLOAT */ .zF.FLOAT;
  }
  paramDefaultValue(name) {
    return {
      ["attribName" /* attribName */]: this._nextAttribName,
      ["lerp" /* lerp */]: 1,
      ["val" /* val */]: 0
    }[name];
  }
  setAttribType(type) {
    this.p.type.set(_utils_io_connections_Js__WEBPACK_IMPORTED_MODULE_0__/* .PARAM_CONVERTIBLE_JS_CONNECTION_POINT_TYPES.indexOf */ .mH.indexOf(type));
  }
  setAttribName(attribName) {
    const param = this.params.get("attribName" /* attribName */);
    if (param) {
      param.set(attribName);
    } else {
      this._nextAttribName = attribName;
    }
  }
  setLines(linesController) {
    (0,_BaseObject3D__WEBPACK_IMPORTED_MODULE_4__/* .setObject3DOutputLine */ .PV)(this, linesController);
  }
  setTriggerableLines(shadersCollectionController) {
    const object3D = (0,_BaseObject3D__WEBPACK_IMPORTED_MODULE_4__/* .inputObject3D */ .iv)(this, shadersCollectionController);
    const attribName = this.variableForInput(shadersCollectionController, "attribName" /* attribName */);
    const lerp = this.variableForInput(shadersCollectionController, "lerp" /* lerp */);
    const newValue = this.variableForInput(shadersCollectionController, "val" /* val */);
    const func = _Poly__WEBPACK_IMPORTED_MODULE_5__/* .Poly.namedFunctionsRegister.getFunction */ .L.namedFunctionsRegister.getFunction("setObjectAttribute", this, shadersCollectionController);
    const bodyLine = func.asString(object3D, attribName, lerp, newValue, `'${this._currentConnectionType()}'`);
    shadersCollectionController.addTriggerableLines(this, [bodyLine]);
  }
}


/***/ }),

/***/ 25532:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "c": function() { return /* binding */ SetObjectLookAtJsNode; }
/* harmony export */ });
/* harmony import */ var _Base__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(38231);
/* harmony import */ var _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(96949);
/* harmony import */ var _utils_io_connections_Js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(38857);
/* harmony import */ var _poly_registers_nodes_types_Js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(16718);
/* harmony import */ var _Poly__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(99934);
/* harmony import */ var _BaseObject3D__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(75807);







const CONNECTION_OPTIONS = _utils_io_connections_Js__WEBPACK_IMPORTED_MODULE_0__/* .JS_CONNECTION_POINT_IN_NODE_DEF */ .mX;
class SetObjectLookAtJsParamsConfig extends _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .NodeParamsConfig */ .yI {
  constructor() {
    super(...arguments);
    /** @param targetPosition */
    this.targetPosition = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .ParamConfig.VECTOR3 */ .XC.VECTOR3([0, 0, 0]);
    /** @param up */
    this.up = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .ParamConfig.VECTOR3 */ .XC.VECTOR3([0, 1, 0]);
    /** @param lerp factor */
    this.lerp = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .ParamConfig.FLOAT */ .XC.FLOAT(1);
    /** @param invertDirection */
    this.invertDirection = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .ParamConfig.BOOLEAN */ .XC.BOOLEAN(0);
    /** @param sets if the matrix should be updated as the animation progresses */
    this.updateMatrix = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .ParamConfig.BOOLEAN */ .XC.BOOLEAN(1);
  }
}
const ParamsConfig = new SetObjectLookAtJsParamsConfig();
class SetObjectLookAtJsNode extends _Base__WEBPACK_IMPORTED_MODULE_2__/* .TypedJsNode */ .xZ {
  constructor() {
    super(...arguments);
    this.paramsConfig = ParamsConfig;
  }
  static type() {
    return _poly_registers_nodes_types_Js__WEBPACK_IMPORTED_MODULE_3__/* .JsType.SET_OBJECT_LOOK_AT */ .K.SET_OBJECT_LOOK_AT;
  }
  initializeNode() {
    this.io.inputs.setNamedInputConnectionPoints([
      new _utils_io_connections_Js__WEBPACK_IMPORTED_MODULE_0__/* .JsConnectionPoint */ .fp(_Base__WEBPACK_IMPORTED_MODULE_2__/* .TRIGGER_CONNECTION_NAME */ .w6, _utils_io_connections_Js__WEBPACK_IMPORTED_MODULE_0__/* .JsConnectionPointType.TRIGGER */ .zF.TRIGGER, CONNECTION_OPTIONS),
      new _utils_io_connections_Js__WEBPACK_IMPORTED_MODULE_0__/* .JsConnectionPoint */ .fp(_utils_io_connections_Js__WEBPACK_IMPORTED_MODULE_0__/* .JsConnectionPointType.OBJECT_3D */ .zF.OBJECT_3D, _utils_io_connections_Js__WEBPACK_IMPORTED_MODULE_0__/* .JsConnectionPointType.OBJECT_3D */ .zF.OBJECT_3D, CONNECTION_OPTIONS)
    ]);
    this.io.outputs.setNamedOutputConnectionPoints([
      new _utils_io_connections_Js__WEBPACK_IMPORTED_MODULE_0__/* .JsConnectionPoint */ .fp(_Base__WEBPACK_IMPORTED_MODULE_2__/* .TRIGGER_CONNECTION_NAME */ .w6, _utils_io_connections_Js__WEBPACK_IMPORTED_MODULE_0__/* .JsConnectionPointType.TRIGGER */ .zF.TRIGGER),
      new _utils_io_connections_Js__WEBPACK_IMPORTED_MODULE_0__/* .JsConnectionPoint */ .fp(_utils_io_connections_Js__WEBPACK_IMPORTED_MODULE_0__/* .JsConnectionPointType.OBJECT_3D */ .zF.OBJECT_3D, _utils_io_connections_Js__WEBPACK_IMPORTED_MODULE_0__/* .JsConnectionPointType.OBJECT_3D */ .zF.OBJECT_3D)
    ]);
  }
  setLines(linesController) {
    (0,_BaseObject3D__WEBPACK_IMPORTED_MODULE_4__/* .setObject3DOutputLine */ .PV)(this, linesController);
  }
  setTriggerableLines(linesController) {
    const object3D = (0,_BaseObject3D__WEBPACK_IMPORTED_MODULE_4__/* .inputObject3D */ .iv)(this, linesController);
    const targetPosition = this.variableForInputParam(linesController, this.p.targetPosition);
    const up = this.variableForInputParam(linesController, this.p.up);
    const lerp = this.variableForInputParam(linesController, this.p.lerp);
    const invertDirection = this.variableForInputParam(linesController, this.p.invertDirection);
    const updateMatrix = this.variableForInputParam(linesController, this.p.updateMatrix);
    const func = _Poly__WEBPACK_IMPORTED_MODULE_5__/* .Poly.namedFunctionsRegister.getFunction */ .L.namedFunctionsRegister.getFunction("setObjectLookAt", this, linesController);
    const bodyLine = func.asString(object3D, targetPosition, up, lerp, invertDirection, updateMatrix);
    linesController.addTriggerableLines(this, [bodyLine]);
  }
}


/***/ }),

/***/ 99291:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "M": function() { return /* binding */ SetObjectPolarTransformJsNode; }
/* harmony export */ });
/* harmony import */ var _Base__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(38231);
/* harmony import */ var _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(96949);
/* harmony import */ var _utils_io_connections_Js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(38857);
/* harmony import */ var _BaseObject3D__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(75807);
/* harmony import */ var _Poly__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(99934);






const CONNECTION_OPTIONS = _utils_io_connections_Js__WEBPACK_IMPORTED_MODULE_0__/* .JS_CONNECTION_POINT_IN_NODE_DEF */ .mX;
class SetObjectPolarTransformJsParamsConfig extends _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .NodeParamsConfig */ .yI {
  constructor() {
    super(...arguments);
    /** @param center of the transform */
    this.center = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .ParamConfig.VECTOR3 */ .XC.VECTOR3([0, 0, 0]);
    /** @param moves the objects along the longitude, which is equivalent to a rotation on the y axis */
    this.longitude = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .ParamConfig.FLOAT */ .XC.FLOAT(0, {
      range: [-360, 360]
    });
    /** @param moves the objects along the latitude, which is equivalent to a rotation on the z or x axis */
    this.latitude = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .ParamConfig.FLOAT */ .XC.FLOAT(0, {
      range: [-180, 180]
    });
    /** @param moves the point aways from the center */
    this.depth = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .ParamConfig.FLOAT */ .XC.FLOAT(1, {
      range: [0, 10]
    });
  }
  /** @param lerp factor */
  // lerp = ParamConfig.FLOAT(1);
  /** @param sets if the matrix should be updated as the animation progresses */
  // updateMatrix = ParamConfig.BOOLEAN(1);
}
const ParamsConfig = new SetObjectPolarTransformJsParamsConfig();
class SetObjectPolarTransformJsNode extends _Base__WEBPACK_IMPORTED_MODULE_2__/* .TypedJsNode */ .xZ {
  constructor() {
    super(...arguments);
    this.paramsConfig = ParamsConfig;
  }
  static type() {
    return "setObjectPolarTransform";
  }
  initializeNode() {
    this.io.inputs.setNamedInputConnectionPoints([
      new _utils_io_connections_Js__WEBPACK_IMPORTED_MODULE_0__/* .JsConnectionPoint */ .fp(_Base__WEBPACK_IMPORTED_MODULE_2__/* .TRIGGER_CONNECTION_NAME */ .w6, _utils_io_connections_Js__WEBPACK_IMPORTED_MODULE_0__/* .JsConnectionPointType.TRIGGER */ .zF.TRIGGER, CONNECTION_OPTIONS),
      new _utils_io_connections_Js__WEBPACK_IMPORTED_MODULE_0__/* .JsConnectionPoint */ .fp(_utils_io_connections_Js__WEBPACK_IMPORTED_MODULE_0__/* .JsConnectionPointType.OBJECT_3D */ .zF.OBJECT_3D, _utils_io_connections_Js__WEBPACK_IMPORTED_MODULE_0__/* .JsConnectionPointType.OBJECT_3D */ .zF.OBJECT_3D, CONNECTION_OPTIONS)
    ]);
    this.io.outputs.setNamedOutputConnectionPoints([
      new _utils_io_connections_Js__WEBPACK_IMPORTED_MODULE_0__/* .JsConnectionPoint */ .fp(_Base__WEBPACK_IMPORTED_MODULE_2__/* .TRIGGER_CONNECTION_NAME */ .w6, _utils_io_connections_Js__WEBPACK_IMPORTED_MODULE_0__/* .JsConnectionPointType.TRIGGER */ .zF.TRIGGER),
      new _utils_io_connections_Js__WEBPACK_IMPORTED_MODULE_0__/* .JsConnectionPoint */ .fp(_utils_io_connections_Js__WEBPACK_IMPORTED_MODULE_0__/* .JsConnectionPointType.OBJECT_3D */ .zF.OBJECT_3D, _utils_io_connections_Js__WEBPACK_IMPORTED_MODULE_0__/* .JsConnectionPointType.OBJECT_3D */ .zF.OBJECT_3D, CONNECTION_OPTIONS)
    ]);
  }
  setLines(linesController) {
    (0,_BaseObject3D__WEBPACK_IMPORTED_MODULE_3__/* .setObject3DOutputLine */ .PV)(this, linesController);
  }
  setTriggerableLines(linesController) {
    const object3D = (0,_BaseObject3D__WEBPACK_IMPORTED_MODULE_3__/* .inputObject3D */ .iv)(this, linesController);
    const center = this.variableForInputParam(linesController, this.p.center);
    const longitude = this.variableForInputParam(linesController, this.p.longitude);
    const latitude = this.variableForInputParam(linesController, this.p.latitude);
    const depth = this.variableForInputParam(linesController, this.p.depth);
    const func = _Poly__WEBPACK_IMPORTED_MODULE_4__/* .Poly.namedFunctionsRegister.getFunction */ .L.namedFunctionsRegister.getFunction("setObjectPolarTransform", this, linesController);
    const bodyLine = func.asString(object3D, center, longitude, latitude, depth);
    linesController.addTriggerableLines(this, [bodyLine]);
  }
}


/***/ }),

/***/ 71484:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "S": function() { return /* binding */ SetObjectPositionJsNode; }
/* harmony export */ });
/* harmony import */ var _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(96949);
/* harmony import */ var _poly_registers_nodes_types_Js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(16718);
/* harmony import */ var _Poly__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(99934);
/* harmony import */ var _BaseObject3D__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(75807);
/* harmony import */ var _BaseTriggerAndObject__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(49846);
/* harmony import */ var _utils_io_connections_Js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(38857);







const CONNECTION_OPTIONS = _utils_io_connections_Js__WEBPACK_IMPORTED_MODULE_0__/* .JS_CONNECTION_POINT_IN_NODE_DEF */ .mX;
class SetObjectPositionJsParamsConfig extends _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .NodeParamsConfig */ .yI {
  constructor() {
    super(...arguments);
    /** @param target position */
    this.position = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .ParamConfig.VECTOR3 */ .XC.VECTOR3([0, 0, 0]);
    /** @param lerp factor */
    this.lerp = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .ParamConfig.FLOAT */ .XC.FLOAT(1);
    /** @param sets if the matrix should be updated as the animation progresses */
    this.updateMatrix = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .ParamConfig.BOOLEAN */ .XC.BOOLEAN(1);
  }
}
const ParamsConfig = new SetObjectPositionJsParamsConfig();
class SetObjectPositionJsNode extends _BaseTriggerAndObject__WEBPACK_IMPORTED_MODULE_2__/* .BaseTriggerAndObjectJsNode */ .e {
  constructor() {
    super(...arguments);
    this.paramsConfig = ParamsConfig;
  }
  static type() {
    return _poly_registers_nodes_types_Js__WEBPACK_IMPORTED_MODULE_3__/* .JsType.SET_OBJECT_POSITION */ .K.SET_OBJECT_POSITION;
  }
  _additionalOutputs() {
    return [
      new _utils_io_connections_Js__WEBPACK_IMPORTED_MODULE_0__/* .JsConnectionPoint */ .fp("position", _utils_io_connections_Js__WEBPACK_IMPORTED_MODULE_0__/* .JsConnectionPointType.VECTOR3 */ .zF.VECTOR3, CONNECTION_OPTIONS),
      new _utils_io_connections_Js__WEBPACK_IMPORTED_MODULE_0__/* .JsConnectionPoint */ .fp("lerp", _utils_io_connections_Js__WEBPACK_IMPORTED_MODULE_0__/* .JsConnectionPointType.FLOAT */ .zF.FLOAT, CONNECTION_OPTIONS),
      new _utils_io_connections_Js__WEBPACK_IMPORTED_MODULE_0__/* .JsConnectionPoint */ .fp("updateMatrix", _utils_io_connections_Js__WEBPACK_IMPORTED_MODULE_0__/* .JsConnectionPointType.BOOLEAN */ .zF.BOOLEAN, CONNECTION_OPTIONS)
    ];
  }
  setLines(linesController) {
    super.setLines(linesController);
    (0,_BaseObject3D__WEBPACK_IMPORTED_MODULE_4__/* .vector3OutputFromParam */ .uM)(this, this.p.position, linesController);
    (0,_BaseObject3D__WEBPACK_IMPORTED_MODULE_4__/* .floatOutputFromParam */ .q3)(this, this.p.lerp, linesController);
    (0,_BaseObject3D__WEBPACK_IMPORTED_MODULE_4__/* .booleanOutputFromParam */ .d8)(this, this.p.updateMatrix, linesController);
  }
  setTriggerableLines(linesController) {
    const object3D = (0,_BaseObject3D__WEBPACK_IMPORTED_MODULE_4__/* .inputObject3D */ .iv)(this, linesController);
    const position = this.variableForInputParam(linesController, this.p.position);
    const lerp = this.variableForInputParam(linesController, this.p.lerp);
    const updateMatrix = this.variableForInputParam(linesController, this.p.updateMatrix);
    const func = _Poly__WEBPACK_IMPORTED_MODULE_5__/* .Poly.namedFunctionsRegister.getFunction */ .L.namedFunctionsRegister.getFunction("setObjectPosition", this, linesController);
    const bodyLine = func.asString(object3D, position, lerp, updateMatrix);
    linesController.addTriggerableLines(this, [bodyLine]);
  }
}


/***/ }),

/***/ 53866:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "D": function() { return /* binding */ SetObjectRotationJsNode; }
/* harmony export */ });
/* harmony import */ var _Base__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(38231);
/* harmony import */ var _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(96949);
/* harmony import */ var _utils_io_connections_Js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(38857);
/* harmony import */ var _BaseObject3D__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(75807);
/* harmony import */ var _Poly__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(99934);






const CONNECTION_OPTIONS = _utils_io_connections_Js__WEBPACK_IMPORTED_MODULE_0__/* .JS_CONNECTION_POINT_IN_NODE_DEF */ .mX;
class SetObjectRotationJsParamsConfig extends _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .NodeParamsConfig */ .yI {
  constructor() {
    super(...arguments);
    /** @param lerp factor */
    this.lerp = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .ParamConfig.FLOAT */ .XC.FLOAT(1);
    /** @param sets if the matrix should be updated as the animation progresses */
    this.updateMatrix = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .ParamConfig.BOOLEAN */ .XC.BOOLEAN(1);
  }
}
const ParamsConfig = new SetObjectRotationJsParamsConfig();
class SetObjectRotationJsNode extends _Base__WEBPACK_IMPORTED_MODULE_2__/* .TypedJsNode */ .xZ {
  constructor() {
    super(...arguments);
    this.paramsConfig = ParamsConfig;
  }
  static type() {
    return "setObjectRotation";
  }
  initializeNode() {
    this.io.connection_points.spare_params.setInputlessParamNames(["rotationOrder"]);
    this.io.inputs.setNamedInputConnectionPoints([
      new _utils_io_connections_Js__WEBPACK_IMPORTED_MODULE_0__/* .JsConnectionPoint */ .fp(_Base__WEBPACK_IMPORTED_MODULE_2__/* .TRIGGER_CONNECTION_NAME */ .w6, _utils_io_connections_Js__WEBPACK_IMPORTED_MODULE_0__/* .JsConnectionPointType.TRIGGER */ .zF.TRIGGER, CONNECTION_OPTIONS),
      new _utils_io_connections_Js__WEBPACK_IMPORTED_MODULE_0__/* .JsConnectionPoint */ .fp(_utils_io_connections_Js__WEBPACK_IMPORTED_MODULE_0__/* .JsConnectionPointType.OBJECT_3D */ .zF.OBJECT_3D, _utils_io_connections_Js__WEBPACK_IMPORTED_MODULE_0__/* .JsConnectionPointType.OBJECT_3D */ .zF.OBJECT_3D, CONNECTION_OPTIONS),
      new _utils_io_connections_Js__WEBPACK_IMPORTED_MODULE_0__/* .JsConnectionPoint */ .fp(_utils_io_connections_Js__WEBPACK_IMPORTED_MODULE_0__/* .JsConnectionPointType.EULER */ .zF.EULER, _utils_io_connections_Js__WEBPACK_IMPORTED_MODULE_0__/* .JsConnectionPointType.EULER */ .zF.EULER, CONNECTION_OPTIONS)
    ]);
    this.io.outputs.setNamedOutputConnectionPoints([
      new _utils_io_connections_Js__WEBPACK_IMPORTED_MODULE_0__/* .JsConnectionPoint */ .fp(_Base__WEBPACK_IMPORTED_MODULE_2__/* .TRIGGER_CONNECTION_NAME */ .w6, _utils_io_connections_Js__WEBPACK_IMPORTED_MODULE_0__/* .JsConnectionPointType.TRIGGER */ .zF.TRIGGER),
      new _utils_io_connections_Js__WEBPACK_IMPORTED_MODULE_0__/* .JsConnectionPoint */ .fp(_utils_io_connections_Js__WEBPACK_IMPORTED_MODULE_0__/* .JsConnectionPointType.OBJECT_3D */ .zF.OBJECT_3D, _utils_io_connections_Js__WEBPACK_IMPORTED_MODULE_0__/* .JsConnectionPointType.OBJECT_3D */ .zF.OBJECT_3D, CONNECTION_OPTIONS)
    ]);
  }
  setLines(linesController) {
    (0,_BaseObject3D__WEBPACK_IMPORTED_MODULE_3__/* .setObject3DOutputLine */ .PV)(this, linesController);
  }
  setTriggerableLines(shadersCollectionController) {
    const object3D = (0,_BaseObject3D__WEBPACK_IMPORTED_MODULE_3__/* .inputObject3D */ .iv)(this, shadersCollectionController);
    const euler = this.variableForInput(shadersCollectionController, _utils_io_connections_Js__WEBPACK_IMPORTED_MODULE_0__/* .JsConnectionPointType.EULER */ .zF.EULER);
    const lerp = this.variableForInputParam(shadersCollectionController, this.p.lerp);
    const updateMatrix = this.variableForInputParam(shadersCollectionController, this.p.updateMatrix);
    const func = _Poly__WEBPACK_IMPORTED_MODULE_4__/* .Poly.namedFunctionsRegister.getFunction */ .L.namedFunctionsRegister.getFunction("setObjectRotation", this, shadersCollectionController);
    const bodyLine = func.asString(object3D, euler, lerp, updateMatrix);
    shadersCollectionController.addTriggerableLines(this, [bodyLine]);
  }
}


/***/ }),

/***/ 99669:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "w": function() { return /* binding */ SetObjectScaleJsNode; }
/* harmony export */ });
/* harmony import */ var _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(96949);
/* harmony import */ var _utils_io_connections_Js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(38857);
/* harmony import */ var _Poly__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(99934);
/* harmony import */ var _BaseObject3D__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(75807);
/* harmony import */ var _BaseTriggerAndObject__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(49846);
/* harmony import */ var _poly_registers_nodes_types_Js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(16718);







const CONNECTION_OPTIONS = _utils_io_connections_Js__WEBPACK_IMPORTED_MODULE_0__/* .JS_CONNECTION_POINT_IN_NODE_DEF */ .mX;
class SetObjectScaleJsParamsConfig extends _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .NodeParamsConfig */ .yI {
  constructor() {
    super(...arguments);
    /** @param target scale */
    this.scale = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .ParamConfig.VECTOR3 */ .XC.VECTOR3([1, 1, 1]);
    /** @param target scale */
    this.mult = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .ParamConfig.FLOAT */ .XC.FLOAT(1, {
      range: [0, 2],
      rangeLocked: [false, false]
    });
    /** @param lerp factor */
    this.lerp = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .ParamConfig.FLOAT */ .XC.FLOAT(1);
    /** @param sets if the matrix should be updated as the animation progresses */
    this.updateMatrix = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .ParamConfig.BOOLEAN */ .XC.BOOLEAN(1);
  }
}
const ParamsConfig = new SetObjectScaleJsParamsConfig();
class SetObjectScaleJsNode extends _BaseTriggerAndObject__WEBPACK_IMPORTED_MODULE_2__/* .BaseTriggerAndObjectJsNode */ .e {
  constructor() {
    super(...arguments);
    this.paramsConfig = ParamsConfig;
  }
  static type() {
    return _poly_registers_nodes_types_Js__WEBPACK_IMPORTED_MODULE_3__/* .JsType.SET_OBJECT_SCALE */ .K.SET_OBJECT_SCALE;
  }
  _additionalOutputs() {
    return [
      new _utils_io_connections_Js__WEBPACK_IMPORTED_MODULE_0__/* .JsConnectionPoint */ .fp("scale", _utils_io_connections_Js__WEBPACK_IMPORTED_MODULE_0__/* .JsConnectionPointType.VECTOR3 */ .zF.VECTOR3, CONNECTION_OPTIONS),
      new _utils_io_connections_Js__WEBPACK_IMPORTED_MODULE_0__/* .JsConnectionPoint */ .fp("mult", _utils_io_connections_Js__WEBPACK_IMPORTED_MODULE_0__/* .JsConnectionPointType.FLOAT */ .zF.FLOAT, CONNECTION_OPTIONS),
      new _utils_io_connections_Js__WEBPACK_IMPORTED_MODULE_0__/* .JsConnectionPoint */ .fp("lerp", _utils_io_connections_Js__WEBPACK_IMPORTED_MODULE_0__/* .JsConnectionPointType.FLOAT */ .zF.FLOAT, CONNECTION_OPTIONS),
      new _utils_io_connections_Js__WEBPACK_IMPORTED_MODULE_0__/* .JsConnectionPoint */ .fp("updateMatrix", _utils_io_connections_Js__WEBPACK_IMPORTED_MODULE_0__/* .JsConnectionPointType.BOOLEAN */ .zF.BOOLEAN, CONNECTION_OPTIONS)
    ];
  }
  setLines(linesController) {
    super.setLines(linesController);
    (0,_BaseObject3D__WEBPACK_IMPORTED_MODULE_4__/* .vector3OutputFromParam */ .uM)(this, this.p.scale, linesController);
    (0,_BaseObject3D__WEBPACK_IMPORTED_MODULE_4__/* .floatOutputFromParam */ .q3)(this, this.p.mult, linesController);
    (0,_BaseObject3D__WEBPACK_IMPORTED_MODULE_4__/* .floatOutputFromParam */ .q3)(this, this.p.lerp, linesController);
    (0,_BaseObject3D__WEBPACK_IMPORTED_MODULE_4__/* .booleanOutputFromParam */ .d8)(this, this.p.updateMatrix, linesController);
  }
  setTriggerableLines(linesController) {
    const object3D = (0,_BaseObject3D__WEBPACK_IMPORTED_MODULE_4__/* .inputObject3D */ .iv)(this, linesController);
    const scale = this.variableForInputParam(linesController, this.p.scale);
    const mult = this.variableForInputParam(linesController, this.p.mult);
    const lerp = this.variableForInputParam(linesController, this.p.lerp);
    const updateMatrix = this.variableForInputParam(linesController, this.p.updateMatrix);
    const func = _Poly__WEBPACK_IMPORTED_MODULE_5__/* .Poly.namedFunctionsRegister.getFunction */ .L.namedFunctionsRegister.getFunction("setObjectScale", this, linesController);
    const bodyLine = func.asString(object3D, scale, mult, lerp, updateMatrix);
    linesController.addTriggerableLines(this, [bodyLine]);
  }
}


/***/ }),

/***/ 16130:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "g": function() { return /* binding */ SetParamJsNode; }
/* harmony export */ });
/* unused harmony export SetParamJsNodeInputName */
/* harmony import */ var _Base__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(38231);
/* harmony import */ var _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(96949);
/* harmony import */ var _utils_io_connections_Js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(38857);
/* harmony import */ var _Poly__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(99934);
/* harmony import */ var _poly_Assert__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(68239);
/* harmony import */ var _poly_registers_nodes_types_Js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(16718);
/* harmony import */ var _BaseObject3D__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(75807);

var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));







const CONNECTION_OPTIONS = _utils_io_connections_Js__WEBPACK_IMPORTED_MODULE_0__/* .JS_CONNECTION_POINT_IN_NODE_DEF */ .mX;
var SetParamJsNodeInputName = /* @__PURE__ */ ((SetParamJsNodeInputName2) => {
  SetParamJsNodeInputName2["lerp"] = "lerp";
  SetParamJsNodeInputName2["val"] = "val";
  return SetParamJsNodeInputName2;
})(SetParamJsNodeInputName || {});
class SetParamJsParamsConfig extends _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .NodeParamsConfig */ .yI {
  constructor() {
    super(...arguments);
    /** @param type of the parameter to update */
    this.type = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .ParamConfig.INTEGER */ .XC.INTEGER(_utils_io_connections_Js__WEBPACK_IMPORTED_MODULE_0__/* .PARAM_CONVERTIBLE_JS_CONNECTION_POINT_TYPES.indexOf */ .mH.indexOf(_utils_io_connections_Js__WEBPACK_IMPORTED_MODULE_0__/* .JsConnectionPointType.FLOAT */ .zF.FLOAT), {
      menu: {
        entries: _utils_io_connections_Js__WEBPACK_IMPORTED_MODULE_0__/* .PARAM_CONVERTIBLE_JS_CONNECTION_POINT_TYPES.map */ .mH.map((name, value) => {
          return { name, value };
        })
      }
    });
  }
}
const ParamsConfig = new SetParamJsParamsConfig();
class SetParamJsNode extends _Base__WEBPACK_IMPORTED_MODULE_2__/* .TypedJsNode */ .xZ {
  constructor() {
    super(...arguments);
    this.paramsConfig = ParamsConfig;
  }
  static type() {
    return _poly_registers_nodes_types_Js__WEBPACK_IMPORTED_MODULE_3__/* .JsType.SET_PARAM */ .K.SET_PARAM;
  }
  initializeNode() {
    this.io.inputs.setNamedInputConnectionPoints([
      new _utils_io_connections_Js__WEBPACK_IMPORTED_MODULE_0__/* .JsConnectionPoint */ .fp(_utils_io_connections_Js__WEBPACK_IMPORTED_MODULE_0__/* .JsConnectionPointType.TRIGGER */ .zF.TRIGGER, _utils_io_connections_Js__WEBPACK_IMPORTED_MODULE_0__/* .JsConnectionPointType.TRIGGER */ .zF.TRIGGER, CONNECTION_OPTIONS),
      new _utils_io_connections_Js__WEBPACK_IMPORTED_MODULE_0__/* .JsConnectionPoint */ .fp(_utils_io_connections_Js__WEBPACK_IMPORTED_MODULE_0__/* .JsConnectionPointType.PARAM */ .zF.PARAM, _utils_io_connections_Js__WEBPACK_IMPORTED_MODULE_0__/* .JsConnectionPointType.PARAM */ .zF.PARAM, CONNECTION_OPTIONS),
      new _utils_io_connections_Js__WEBPACK_IMPORTED_MODULE_0__/* .JsConnectionPoint */ .fp(
        "lerp" /* lerp */,
        _utils_io_connections_Js__WEBPACK_IMPORTED_MODULE_0__/* .JsConnectionPointType.FLOAT */ .zF.FLOAT,
        __spreadProps(__spreadValues({}, CONNECTION_OPTIONS), {
          init_value: 1
        })
      )
    ]);
    this.io.connection_points.set_input_name_function(() => "val" /* val */);
    this.io.connection_points.set_expected_input_types_function(() => [this._currentConnectionType()]);
    this.io.connection_points.set_output_name_function(() => _Base__WEBPACK_IMPORTED_MODULE_2__/* .TRIGGER_CONNECTION_NAME */ .w6);
    this.io.connection_points.set_expected_output_types_function(() => [_utils_io_connections_Js__WEBPACK_IMPORTED_MODULE_0__/* .JsConnectionPointType.TRIGGER */ .zF.TRIGGER]);
  }
  _currentConnectionType() {
    if (this.pv.type == null) {
      console.warn(`${this.type()} type not valid`);
    }
    const connectionType = _utils_io_connections_Js__WEBPACK_IMPORTED_MODULE_0__/* .PARAM_CONVERTIBLE_JS_CONNECTION_POINT_TYPES */ .mH[this.pv.type];
    if (connectionType == null) {
      console.warn(`${this.type()} type not valid`);
    }
    return connectionType || _utils_io_connections_Js__WEBPACK_IMPORTED_MODULE_0__/* .JsConnectionPointType.FLOAT */ .zF.FLOAT;
  }
  setParamType(paramType) {
    const index = _utils_io_connections_Js__WEBPACK_IMPORTED_MODULE_0__/* .PARAM_CONVERTIBLE_JS_CONNECTION_POINT_TYPES.indexOf */ .mH.indexOf(paramType);
    if (index < 0) {
      console.warn(
        `only the following types are accepted: ${_utils_io_connections_Js__WEBPACK_IMPORTED_MODULE_0__/* .PARAM_CONVERTIBLE_JS_CONNECTION_POINT_TYPES.join */ .mH.join(", ")}`
      );
      return;
    }
    this.p.type.set(index);
  }
  setParamPath(paramPath) {
    this.params.get(_utils_io_connections_Js__WEBPACK_IMPORTED_MODULE_0__/* .JsConnectionPointType.PARAM */ .zF.PARAM).set(paramPath);
  }
  setParamParam(param) {
    this.params.get(_utils_io_connections_Js__WEBPACK_IMPORTED_MODULE_0__/* .JsConnectionPointType.PARAM */ .zF.PARAM).setParam(param);
  }
  setTriggerableLines(controller) {
    const param = (0,_BaseObject3D__WEBPACK_IMPORTED_MODULE_4__/* .inputParam */ .PQ)(this, controller);
    const paramValue = this.variableForInput(controller, "val" /* val */);
    const lerp = this.variableForInput(controller, "lerp" /* lerp */);
    const bodyLine = this._bodyLine({
      controller,
      param,
      paramValue,
      lerp
    });
    if (!bodyLine) {
      return;
    }
    controller.addTriggerableLines(this, [bodyLine]);
  }
  _bodyLine(options) {
    const type = _utils_io_connections_Js__WEBPACK_IMPORTED_MODULE_0__/* .PARAM_CONVERTIBLE_JS_CONNECTION_POINT_TYPES */ .mH[this.pv.type];
    switch (type) {
      case _utils_io_connections_Js__WEBPACK_IMPORTED_MODULE_0__/* .JsConnectionPointType.BOOLEAN */ .zF.BOOLEAN: {
        return this._setBoolean(options);
      }
      case _utils_io_connections_Js__WEBPACK_IMPORTED_MODULE_0__/* .JsConnectionPointType.COLOR */ .zF.COLOR: {
        return this._setColor(options);
      }
      case _utils_io_connections_Js__WEBPACK_IMPORTED_MODULE_0__/* .JsConnectionPointType.FLOAT */ .zF.FLOAT: {
        return this._setFloat(options);
      }
      case _utils_io_connections_Js__WEBPACK_IMPORTED_MODULE_0__/* .JsConnectionPointType.INT */ .zF.INT: {
        return this._setInt(options);
      }
      case _utils_io_connections_Js__WEBPACK_IMPORTED_MODULE_0__/* .JsConnectionPointType.STRING */ .zF.STRING: {
        return this._setString(options);
      }
      case _utils_io_connections_Js__WEBPACK_IMPORTED_MODULE_0__/* .JsConnectionPointType.VECTOR2 */ .zF.VECTOR2: {
        return this._setVector2(options);
      }
      case _utils_io_connections_Js__WEBPACK_IMPORTED_MODULE_0__/* .JsConnectionPointType.VECTOR3 */ .zF.VECTOR3: {
        return this._setVector3(options);
      }
      case _utils_io_connections_Js__WEBPACK_IMPORTED_MODULE_0__/* .JsConnectionPointType.VECTOR4 */ .zF.VECTOR4: {
        return this._setVector4(options);
      }
    }
    _poly_Assert__WEBPACK_IMPORTED_MODULE_5__/* .TypeAssert.unreachable */ .f.unreachable(type);
  }
  _setBoolean(options) {
    const { controller, param, paramValue } = options;
    const func = _Poly__WEBPACK_IMPORTED_MODULE_6__/* .Poly.namedFunctionsRegister.getFunction */ .L.namedFunctionsRegister.getFunction("setParamBoolean", this, controller);
    return func.asString(param, paramValue);
  }
  _setColor(options) {
    const { controller, param, paramValue, lerp } = options;
    const func = _Poly__WEBPACK_IMPORTED_MODULE_6__/* .Poly.namedFunctionsRegister.getFunction */ .L.namedFunctionsRegister.getFunction("setParamColor", this, controller);
    return func.asString(param, paramValue, lerp);
  }
  _setFloat(options) {
    const { controller, param, paramValue, lerp } = options;
    const func = _Poly__WEBPACK_IMPORTED_MODULE_6__/* .Poly.namedFunctionsRegister.getFunction */ .L.namedFunctionsRegister.getFunction("setParamFloat", this, controller);
    return func.asString(param, paramValue, lerp);
  }
  _setInt(options) {
    const { controller, param, paramValue, lerp } = options;
    const func = _Poly__WEBPACK_IMPORTED_MODULE_6__/* .Poly.namedFunctionsRegister.getFunction */ .L.namedFunctionsRegister.getFunction("setParamInteger", this, controller);
    return func.asString(param, paramValue, lerp);
  }
  _setString(options) {
    const { controller, param, paramValue } = options;
    const func = _Poly__WEBPACK_IMPORTED_MODULE_6__/* .Poly.namedFunctionsRegister.getFunction */ .L.namedFunctionsRegister.getFunction("setParamString", this, controller);
    return func.asString(param, paramValue);
  }
  _setVector2(options) {
    const { controller, param, paramValue, lerp } = options;
    const func = _Poly__WEBPACK_IMPORTED_MODULE_6__/* .Poly.namedFunctionsRegister.getFunction */ .L.namedFunctionsRegister.getFunction("setParamVector2", this, controller);
    return func.asString(param, paramValue, lerp);
  }
  _setVector3(options) {
    const { controller, param, paramValue, lerp } = options;
    const func = _Poly__WEBPACK_IMPORTED_MODULE_6__/* .Poly.namedFunctionsRegister.getFunction */ .L.namedFunctionsRegister.getFunction("setParamVector3", this, controller);
    return func.asString(param, paramValue, lerp);
  }
  _setVector4(options) {
    const { controller, param, paramValue, lerp } = options;
    const func = _Poly__WEBPACK_IMPORTED_MODULE_6__/* .Poly.namedFunctionsRegister.getFunction */ .L.namedFunctionsRegister.getFunction("setParamVector4", this, controller);
    return func.asString(param, paramValue, lerp);
  }
}


/***/ }),

/***/ 19376:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "R": function() { return /* binding */ BaseAudioSourceJsNode; }
/* harmony export */ });
/* harmony import */ var _Base__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(38231);
/* harmony import */ var _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(96949);
/* harmony import */ var _utils_io_connections_Js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(38857);
/* harmony import */ var _poly_NodeContext__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(52070);





const CONNECTION_OPTIONS = _utils_io_connections_Js__WEBPACK_IMPORTED_MODULE_0__/* .JS_CONNECTION_POINT_IN_NODE_DEF */ .mX;
class PauseAudioSourceJsParamsConfig extends _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .NodeParamsConfig */ .yI {
  constructor() {
    super(...arguments);
    /** @param audio node */
    this.node = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .ParamConfig.NODE_PATH */ .XC.NODE_PATH("", {
      nodeSelection: {
        context: _poly_NodeContext__WEBPACK_IMPORTED_MODULE_2__/* .NodeContext.AUDIO */ .sy.AUDIO
      }
      // dependentOnFoundNode: false,
    });
  }
}
const ParamsConfig = new PauseAudioSourceJsParamsConfig();
class BaseAudioSourceJsNode extends _Base__WEBPACK_IMPORTED_MODULE_3__/* .TypedJsNode */ .xZ {
  constructor() {
    super(...arguments);
    this.paramsConfig = ParamsConfig;
  }
  initializeNode() {
    this.io.inputs.setNamedInputConnectionPoints([
      new _utils_io_connections_Js__WEBPACK_IMPORTED_MODULE_0__/* .JsConnectionPoint */ .fp(_Base__WEBPACK_IMPORTED_MODULE_3__/* .TRIGGER_CONNECTION_NAME */ .w6, _utils_io_connections_Js__WEBPACK_IMPORTED_MODULE_0__/* .JsConnectionPointType.TRIGGER */ .zF.TRIGGER, CONNECTION_OPTIONS)
    ]);
    this.io.outputs.setNamedOutputConnectionPoints([
      new _utils_io_connections_Js__WEBPACK_IMPORTED_MODULE_0__/* .JsConnectionPoint */ .fp(_Base__WEBPACK_IMPORTED_MODULE_3__/* .TRIGGER_CONNECTION_NAME */ .w6, _utils_io_connections_Js__WEBPACK_IMPORTED_MODULE_0__/* .JsConnectionPointType.TRIGGER */ .zF.TRIGGER)
    ]);
  }
}


/***/ }),

/***/ 49846:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "c": function() { return /* binding */ ParamlessBaseTriggerAndObjectJsNode; },
/* harmony export */   "e": function() { return /* binding */ BaseTriggerAndObjectJsNode; }
/* harmony export */ });
/* harmony import */ var _Base__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(38231);
/* harmony import */ var _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(96949);
/* harmony import */ var _utils_io_connections_Js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(38857);
/* harmony import */ var _BaseObject3D__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(75807);





const CONNECTION_OPTIONS = _utils_io_connections_Js__WEBPACK_IMPORTED_MODULE_0__/* .JS_CONNECTION_POINT_IN_NODE_DEF */ .mX;
class BaseTriggerAndObjectJsNode extends _Base__WEBPACK_IMPORTED_MODULE_1__/* .TypedJsNode */ .xZ {
  initializeNode() {
    this.io.inputs.setNamedInputConnectionPoints([
      new _utils_io_connections_Js__WEBPACK_IMPORTED_MODULE_0__/* .JsConnectionPoint */ .fp(_Base__WEBPACK_IMPORTED_MODULE_1__/* .TRIGGER_CONNECTION_NAME */ .w6, _utils_io_connections_Js__WEBPACK_IMPORTED_MODULE_0__/* .JsConnectionPointType.TRIGGER */ .zF.TRIGGER, CONNECTION_OPTIONS),
      new _utils_io_connections_Js__WEBPACK_IMPORTED_MODULE_0__/* .JsConnectionPoint */ .fp(_utils_io_connections_Js__WEBPACK_IMPORTED_MODULE_0__/* .JsConnectionPointType.OBJECT_3D */ .zF.OBJECT_3D, _utils_io_connections_Js__WEBPACK_IMPORTED_MODULE_0__/* .JsConnectionPointType.OBJECT_3D */ .zF.OBJECT_3D, CONNECTION_OPTIONS),
      ...this._additionalInputs()
    ]);
    this.io.outputs.setNamedOutputConnectionPoints([
      new _utils_io_connections_Js__WEBPACK_IMPORTED_MODULE_0__/* .JsConnectionPoint */ .fp(_Base__WEBPACK_IMPORTED_MODULE_1__/* .TRIGGER_CONNECTION_NAME */ .w6, _utils_io_connections_Js__WEBPACK_IMPORTED_MODULE_0__/* .JsConnectionPointType.TRIGGER */ .zF.TRIGGER),
      new _utils_io_connections_Js__WEBPACK_IMPORTED_MODULE_0__/* .JsConnectionPoint */ .fp(_utils_io_connections_Js__WEBPACK_IMPORTED_MODULE_0__/* .JsConnectionPointType.OBJECT_3D */ .zF.OBJECT_3D, _utils_io_connections_Js__WEBPACK_IMPORTED_MODULE_0__/* .JsConnectionPointType.OBJECT_3D */ .zF.OBJECT_3D),
      ...this._additionalOutputs()
    ]);
  }
  setLines(linesController) {
    (0,_BaseObject3D__WEBPACK_IMPORTED_MODULE_2__/* .setObject3DOutputLine */ .PV)(this, linesController);
  }
  _additionalInputs() {
    return [];
  }
  _additionalOutputs() {
    return [];
  }
}
class BaseTriggerAndObjectJsParamsConfig extends _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_3__/* .NodeParamsConfig */ .yI {
}
const ParamsConfig = new BaseTriggerAndObjectJsParamsConfig();
class ParamlessBaseTriggerAndObjectJsNode extends BaseTriggerAndObjectJsNode {
  constructor() {
    super(...arguments);
    this.paramsConfig = ParamsConfig;
  }
}


/***/ }),

/***/ 19253:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "FD": function() { return /* binding */ INSERT_MEMBERS_AFTER; },
/* harmony export */   "SD": function() { return /* binding */ BaseJsShaderAssembler; },
/* harmony export */   "Yx": function() { return /* binding */ INSERT_CONSTRUCTOR_AFTER; },
/* harmony export */   "Zf": function() { return /* binding */ INSERT_DEFINE_AFTER; },
/* harmony export */   "xP": function() { return /* binding */ INSERT_BODY_AFTER; }
/* harmony export */ });
/* harmony import */ var _utils_LineType__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(77542);
/* harmony import */ var _configs_VariableConfig__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(40617);
/* harmony import */ var _utils_CodeBuilder__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(87705);
/* harmony import */ var _Base__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(38231);
/* harmony import */ var _configs_ShaderConfig__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(3180);
/* harmony import */ var _utils_shaders_BaseAssembler__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(59832);
/* harmony import */ var _utils_shaders_ShaderName__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(76606);
/* harmony import */ var _utils_shaders_NodeTraverser__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(12689);
/* harmony import */ var _utils_NodeFinder__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(72648);
/* harmony import */ var _poly_registers_nodes_types_Js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(16718);
/* harmony import */ var _poly_registers_nodes_types_Sop__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(58986);












const INSERT_MEMBERS_AFTER = "// insert members";
const INSERT_DEFINE_AFTER = "// insert defines";
const INSERT_CONSTRUCTOR_AFTER = "// insert after constructor";
const INSERT_BODY_AFTER = "// insert body";
const INSERT_MEMBER_AFTER_MAP = /* @__PURE__ */ new Map([
  // [ShaderName.VERTEX, '#include <common>'],
  [_utils_shaders_ShaderName__WEBPACK_IMPORTED_MODULE_0__/* .JsFunctionName.MAIN */ .J.MAIN, INSERT_MEMBERS_AFTER],
  [_utils_shaders_ShaderName__WEBPACK_IMPORTED_MODULE_0__/* .JsFunctionName.VELOCITY */ .J.VELOCITY, INSERT_MEMBERS_AFTER],
  [_utils_shaders_ShaderName__WEBPACK_IMPORTED_MODULE_0__/* .JsFunctionName.COLLIDER */ .J.COLLIDER, INSERT_MEMBERS_AFTER]
]);
const INSERT_DEFINE_AFTER_MAP = /* @__PURE__ */ new Map([
  // [ShaderName.VERTEX, '#include <common>'],
  [_utils_shaders_ShaderName__WEBPACK_IMPORTED_MODULE_0__/* .JsFunctionName.MAIN */ .J.MAIN, INSERT_DEFINE_AFTER],
  [_utils_shaders_ShaderName__WEBPACK_IMPORTED_MODULE_0__/* .JsFunctionName.VELOCITY */ .J.VELOCITY, INSERT_DEFINE_AFTER],
  [_utils_shaders_ShaderName__WEBPACK_IMPORTED_MODULE_0__/* .JsFunctionName.COLLIDER */ .J.COLLIDER, INSERT_DEFINE_AFTER]
]);
const INSERT_CONSTRUCTOR_AFTER_MAP = /* @__PURE__ */ new Map([
  // [ShaderName.VERTEX, '#include <common>'],
  [_utils_shaders_ShaderName__WEBPACK_IMPORTED_MODULE_0__/* .JsFunctionName.MAIN */ .J.MAIN, INSERT_CONSTRUCTOR_AFTER],
  [_utils_shaders_ShaderName__WEBPACK_IMPORTED_MODULE_0__/* .JsFunctionName.VELOCITY */ .J.VELOCITY, INSERT_CONSTRUCTOR_AFTER],
  [_utils_shaders_ShaderName__WEBPACK_IMPORTED_MODULE_0__/* .JsFunctionName.COLLIDER */ .J.COLLIDER, INSERT_CONSTRUCTOR_AFTER]
]);
const INSERT_BODY_AFTER_MAP = /* @__PURE__ */ new Map([
  // [ShaderName.VERTEX, '#include <color_vertex>'],
  [_utils_shaders_ShaderName__WEBPACK_IMPORTED_MODULE_0__/* .JsFunctionName.MAIN */ .J.MAIN, INSERT_BODY_AFTER],
  [_utils_shaders_ShaderName__WEBPACK_IMPORTED_MODULE_0__/* .JsFunctionName.VELOCITY */ .J.VELOCITY, INSERT_BODY_AFTER],
  [_utils_shaders_ShaderName__WEBPACK_IMPORTED_MODULE_0__/* .JsFunctionName.COLLIDER */ .J.COLLIDER, INSERT_BODY_AFTER]
]);
const LINES_TO_REMOVE_MAP = /* @__PURE__ */ new Map([
  // [ShaderName.VERTEX, ['#include <begin_vertex>', '#include <beginnormal_vertex>']],
  [_utils_shaders_ShaderName__WEBPACK_IMPORTED_MODULE_0__/* .JsFunctionName.MAIN */ .J.MAIN, []],
  [_utils_shaders_ShaderName__WEBPACK_IMPORTED_MODULE_0__/* .JsFunctionName.VELOCITY */ .J.VELOCITY, []],
  [_utils_shaders_ShaderName__WEBPACK_IMPORTED_MODULE_0__/* .JsFunctionName.COLLIDER */ .J.COLLIDER, []]
]);
const SPACED_LINES = 3;
const PER_POINT_PARENT_TYPES = /* @__PURE__ */ new Set([_poly_registers_nodes_types_Sop__WEBPACK_IMPORTED_MODULE_1__/* .SopType.ACTOR_INSTANCE */ .aB.ACTOR_INSTANCE, _poly_registers_nodes_types_Sop__WEBPACK_IMPORTED_MODULE_1__/* .SopType.ACTOR_POINT */ .aB.ACTOR_POINT]);
class BaseJsShaderAssembler extends _utils_shaders_BaseAssembler__WEBPACK_IMPORTED_MODULE_2__/* .TypedAssembler */ .I {
  constructor(_jsParentNode) {
    super();
    this._jsParentNode = _jsParentNode;
    this._shaders_by_name = /* @__PURE__ */ new Map();
    this._lines = /* @__PURE__ */ new Map();
    this._root_nodes = [];
    this._leaf_nodes = [];
    this._uniformsTimeDependent = false;
    this._uniformsResolutionDependent = false;
    this._computedVarNames = /* @__PURE__ */ new Set();
    //
    //
    // REGISTERED VARIABLES
    //
    //
    this._registeredVariables = /* @__PURE__ */ new Map();
    this._registeredVariablesCountByNode = /* @__PURE__ */ new Map();
    //
    //
    // REGISTERED FUNCTIONS
    //
    //
    this._registeredFunctions = /* @__PURE__ */ new Map();
  }
  perPoint() {
    return PER_POINT_PARENT_TYPES.has(this._jsParentNode.type());
  }
  setJsParentNode(parentNode) {
    this._overridenJsParentNode = parentNode;
  }
  currentJsParentNode() {
    return this._overridenJsParentNode || this._jsParentNode;
  }
  addComputedVarName(varName) {
    if (!this.computedVariablesAllowed()) {
      return;
    }
    this._computedVarNames.add(varName);
  }
  registeredAsComputed(varName) {
    if (varName.trim().length == 0) {
      console.warn(`attempt to read an empty variable ('${varName}')`);
    }
    return this._computedVarNames.has(varName);
  }
  computedVariablesAllowed() {
    return false;
  }
  memberReference(varName) {
    if (this.computedVariablesAllowed()) {
      return `this.${varName}.value`;
    } else {
      return `this.${varName}`;
    }
  }
  compile() {
  }
  // abstract defaultEntityIndexVariable(): string;
  // private get material() {
  // 	return (this._material = this._material || this._createMaterial());
  // }
  // async get_material(/*master_assembler?: BaseGlShaderAssembler*/) {
  // 	this._material = this._material || this._createMaterial();
  // 	await this._update_material(/*master_assembler*/);
  // 	return this._material;
  // }
  _template_shader_for_shader_name(shaderName) {
    var _a, _b, _c;
    switch (shaderName) {
      case _utils_shaders_ShaderName__WEBPACK_IMPORTED_MODULE_0__/* .JsFunctionName.MAIN */ .J.MAIN:
        return (_a = this.templateShader()) == null ? void 0 : _a.main;
      case _utils_shaders_ShaderName__WEBPACK_IMPORTED_MODULE_0__/* .JsFunctionName.VELOCITY */ .J.VELOCITY:
        return (_b = this.templateShader()) == null ? void 0 : _b.velocity;
      case _utils_shaders_ShaderName__WEBPACK_IMPORTED_MODULE_0__/* .JsFunctionName.COLLIDER */ .J.COLLIDER:
        return (_c = this.templateShader()) == null ? void 0 : _c.collider;
    }
  }
  globalsHandler() {
    var _a;
    return (_a = this.currentJsParentNode().assemblerController()) == null ? void 0 : _a.globalsHandler();
  }
  compileAllowed() {
    var _a;
    return ((_a = this.currentJsParentNode().assemblerController()) == null ? void 0 : _a.globalsHandler()) != null;
  }
  shaders_by_name() {
    return this._shaders_by_name;
  }
  // protected createMaterial(): ShaderMaterial | undefined {
  // 	return undefined;
  // }
  _buildLines() {
    for (const shaderName of this.shaderNames()) {
      const template = this._template_shader_for_shader_name(shaderName);
      if (template) {
        this._replaceTemplate(template, shaderName);
      }
    }
  }
  // protected _build_lines_for_shader_name(shader_name: ShaderName){
  // 	const template = this._template_shader()
  // 	this._replace_template(template[`${shader_name}Shader`], shader_name)
  // }
  set_root_nodes(root_nodes) {
    this._root_nodes = root_nodes;
  }
  templateShader() {
    return void 0;
  }
  _reset() {
    this._resetRegisteredFunctions();
    this._resetRegisteredVariables();
    this._computedVarNames.clear();
  }
  updateFunction() {
    this._reset();
  }
  // protected addUniforms(uniforms: IUniforms) {
  // 	for (let param_config of this.param_configs()) {
  // 		uniforms[param_config.uniformName()] = param_config.uniform();
  // 	}
  // 	if (this.uniformsTimeDependent()) {
  // 		uniforms[UniformName.TIME] = uniforms[UniformName.TIME] || {
  // 			// type: '1f',
  // 			value: this.currentGlParentNode().scene().time(),
  // 		};
  // 	}
  // 	if (this.uniformsResolutionDependent()) {
  // 		uniforms[UniformName.RESOLUTION] = uniforms[UniformName.RESOLUTION] || {
  // 			value: new Vector2(1000, 1000),
  // 		};
  // 	}
  // }
  //
  //
  // ROOT NODES AND SHADER NAMES
  //
  //
  rootNodesByShaderName(shaderName, rootNodes) {
    const list = [];
    for (const node of rootNodes) {
      switch (node.type()) {
        case _poly_registers_nodes_types_Js__WEBPACK_IMPORTED_MODULE_3__/* .JsType.PARAM */ .K.PARAM:
        case _poly_registers_nodes_types_Js__WEBPACK_IMPORTED_MODULE_3__/* .JsType.OUTPUT */ .K.OUTPUT: {
          list.push(node);
          break;
        }
        case _poly_registers_nodes_types_Js__WEBPACK_IMPORTED_MODULE_3__/* .JsType.OUTPUT_AMBIENT_LIGHT */ .K.OUTPUT_AMBIENT_LIGHT:
        case _poly_registers_nodes_types_Js__WEBPACK_IMPORTED_MODULE_3__/* .JsType.OUTPUT_AREA_LIGHT */ .K.OUTPUT_AREA_LIGHT:
        case _poly_registers_nodes_types_Js__WEBPACK_IMPORTED_MODULE_3__/* .JsType.OUTPUT_DIRECTIONAL_LIGHT */ .K.OUTPUT_DIRECTIONAL_LIGHT:
        case _poly_registers_nodes_types_Js__WEBPACK_IMPORTED_MODULE_3__/* .JsType.OUTPUT_HEMISPHERE_LIGHT */ .K.OUTPUT_HEMISPHERE_LIGHT:
        case _poly_registers_nodes_types_Js__WEBPACK_IMPORTED_MODULE_3__/* .JsType.OUTPUT_POINT_LIGHT */ .K.OUTPUT_POINT_LIGHT:
        case _poly_registers_nodes_types_Js__WEBPACK_IMPORTED_MODULE_3__/* .JsType.OUTPUT_SPOT_LIGHT */ .K.OUTPUT_SPOT_LIGHT: {
          list.push(node);
          break;
        }
        case _poly_registers_nodes_types_Js__WEBPACK_IMPORTED_MODULE_3__/* .JsType.ATTRIBUTE */ .K.ATTRIBUTE: {
          list.push(node);
          break;
        }
      }
    }
    return list;
  }
  // leafNodesByShaderName(shaderName: ShaderName): BaseGlNodeType[] {
  // 	const list = [];
  // 	for (let node of this._leaf_nodes) {
  // 		switch (node.type()) {
  // 			case GlobalsGlNode.type(): {
  // 				list.push(node);
  // 				break;
  // 			}
  // 			case AttributeGlNode.type(): {
  // 				break;
  // 			}
  // 		}
  // 	}
  // 	return list;
  // }
  setNodeLinesGlobals(globalsNode, linesController) {
  }
  setNodeLinesOutput(outputNode, linesController) {
  }
  setNodeLinesAttribute(attributeNode, linesController) {
  }
  //
  //
  // CHILDREN NODES PARAMS
  //
  //
  codeBuilder() {
    return this._codeBuilder = this._codeBuilder || this._createCodeBuilder();
  }
  _createCodeBuilder() {
    var _a, _b;
    const computedVariablesAllowed = (_b = (_a = this._jsParentNode.assemblerController()) == null ? void 0 : _a.assembler) == null ? void 0 : _b.computedVariablesAllowed();
    const nodeTraverser = new _utils_shaders_NodeTraverser__WEBPACK_IMPORTED_MODULE_4__/* .TypedNodeTraverser */ .v(
      this.currentJsParentNode(),
      this.shaderNames(),
      (rootNode, shaderName) => {
        return this.inputNamesForShaderName(rootNode, shaderName);
      },
      {
        // we do traverse children if computed(()=>{}) is used.
        // If not, we don't need to traverse children,
        // and the code is handled by the subnet internal code builder
        traverseChildren: computedVariablesAllowed == true ? true : false
      }
    );
    return new _utils_CodeBuilder__WEBPACK_IMPORTED_MODULE_5__/* .JsCodeBuilder */ .b(
      nodeTraverser,
      (shaderName, rootNodes) => {
        return this.rootNodesByShaderName(shaderName, rootNodes);
      },
      this
    );
  }
  buildCodeFromNodes(rootNodes, codeBuilderOptions) {
    const paramNodes = _utils_NodeFinder__WEBPACK_IMPORTED_MODULE_6__/* .JsNodeFinder.findParamGeneratingNodes */ .K.findParamGeneratingNodes(this.currentJsParentNode());
    this.codeBuilder().buildFromNodes(rootNodes, paramNodes, codeBuilderOptions);
  }
  allow_new_param_configs() {
    this.codeBuilder().allow_new_param_configs();
  }
  disallow_new_param_configs() {
    this.codeBuilder().disallow_new_param_configs();
  }
  builder_param_configs() {
    return this.codeBuilder().param_configs();
  }
  builder_lines(shader_name, line_type) {
    return this.codeBuilder().lines(shader_name, line_type);
  }
  all_builder_lines() {
    return this.codeBuilder().all_lines();
  }
  param_configs() {
    const code_builder = this._param_config_owner || this.codeBuilder();
    return code_builder.param_configs();
  }
  set_param_configs_owner(param_config_owner) {
    this._param_config_owner = param_config_owner;
    if (this._param_config_owner) {
      this.codeBuilder().disallow_new_param_configs();
    } else {
      this.codeBuilder().allow_new_param_configs();
    }
  }
  //
  //
  // CHILDREN NODES PARAMS
  //
  //
  static output_input_connection_points() {
    return [
      // new JsConnectionPoint('position', JsConnectionPointType.VEC3),
      // new JsConnectionPoint('normal', JsConnectionPointType.VEC3),
      // new JsConnectionPoint('color', JsConnectionPointType.VEC3),
      // new JsConnectionPoint('alpha', JsConnectionPointType.FLOAT),
      // new JsConnectionPoint('uv', JsConnectionPointType.VEC2),
    ];
  }
  add_output_inputs(output_child) {
    output_child.io.inputs.setNamedInputConnectionPoints(BaseJsShaderAssembler.output_input_connection_points());
  }
  static create_globals_node_output_connections() {
    return [
      // new JsConnectionPoint('position', JsConnectionPointType.VEC3),
      // new JsConnectionPoint('normal', JsConnectionPointType.VEC3),
      // new JsConnectionPoint('color', JsConnectionPointType.VEC3),
      // new JsConnectionPoint('uv', JsConnectionPointType.VEC2),
      // new JsConnectionPoint(GlobalsOutput.MV_POSITION, JsConnectionPointType.VEC4),
      // // Maybe I should not add worldPosition, worldNormal, I just now
      // // as those could add computation overhead when always present in the shader.
      // // But hopefully in the soon future, they will only be added when the code builder
      // // adds lines based on connections, as opposed to the whole node
      // new JsConnectionPoint('worldPosition', JsConnectionPointType.VEC4), // vec4 worldPosition = modelMatrix * vec4( position, 1.0 );
      // new JsConnectionPoint('worldNormal', JsConnectionPointType.VEC3), // vec3 worldNormal = normalize( mat3( modelMatrix[0].xyz, modelMatrix[1].xyz, modelMatrix[2].xyz ) * normal );
      // // new GlConnectionPoint('I', GlConnectionPointType.VEC3), // vec3 I = worldPosition.xyz - cameraPosition;
      // new JsConnectionPoint(GlobalsOutput.GL_POSITION, JsConnectionPointType.VEC4),
      // new JsConnectionPoint(GlobalsOutput.GL_FRAGCOORD, JsConnectionPointType.VEC4),
      // new JsConnectionPoint('cameraPosition', JsConnectionPointType.VEC3),
      // new JsConnectionPoint(GlobalsOutput.RESOLUTION, JsConnectionPointType.VEC2),
      // new JsConnectionPoint(GlobalsOutput.TIME, JsConnectionPointType.FLOAT),
    ];
  }
  create_globals_node_output_connections() {
    return BaseJsShaderAssembler.create_globals_node_output_connections();
  }
  add_globals_outputs(globals_node) {
    globals_node.io.outputs.setNamedOutputConnectionPoints(this.create_globals_node_output_connections());
  }
  allow_attribute_exports() {
    return false;
  }
  //
  //
  // CONFIGS
  //
  //
  resetConfigs() {
    this._reset_shader_configs();
    this._reset_variable_configs();
    this._resetUniformsTimeDependency();
    this._resetUniformsResolutionDependency();
  }
  shaderConfigs() {
    return this._shader_configs = this._shader_configs || this.create_shader_configs();
  }
  set_shader_configs(shader_configs) {
    this._shader_configs = shader_configs;
  }
  shaderNames() {
    var _a;
    return ((_a = this.shaderConfigs()) == null ? void 0 : _a.map((sc) => sc.name())) || [];
  }
  _reset_shader_configs() {
    this._shader_configs = void 0;
  }
  create_shader_configs() {
    return [
      // new ShaderConfig(ShaderName.VERTEX, ['position', 'normal', 'uv', VaryingWriteGlNode.INPUT_NAME], []),
      new _configs_ShaderConfig__WEBPACK_IMPORTED_MODULE_7__/* .JsShaderConfig */ .s(_utils_shaders_ShaderName__WEBPACK_IMPORTED_MODULE_0__/* .JsFunctionName.MAIN */ .J.MAIN, ["color", "alpha"], [])
    ];
  }
  shader_config(name) {
    var _a;
    return (_a = this.shaderConfigs()) == null ? void 0 : _a.filter((sc) => {
      return sc.name() == name;
    })[0];
  }
  variable_configs() {
    return this._variable_configs = this._variable_configs || this.create_variable_configs();
  }
  set_variable_configs(variable_configs) {
    this._variable_configs = variable_configs;
  }
  variable_config(name) {
    return this.variable_configs().filter((vc) => {
      return vc.name() == name;
    })[0];
  }
  static create_variable_configs() {
    return [
      new _configs_VariableConfig__WEBPACK_IMPORTED_MODULE_8__/* .VariableConfig */ .P("d", {
        // default_from_attribute: true,
        // default: this.globalsHandler().variable_config_default('position'),
        // required_definitions: this.globalsHandler().variable_config_required_definitions('position'),
        prefix: "return "
      })
      // new VariableConfig('normal', {
      // 	default_from_attribute: true,
      // 	prefix: 'vec3 objectNormal = ',
      // 	postLines: ['#ifdef USE_TANGENT', '	vec3 objectTangent = vec3( tangent.xyz );', '#endif'],
      // }),
      // new VariableConfig('color', {
      // 	prefix: 'diffuseColor.xyz = ',
      // }),
      // new VariableConfig('alpha', {
      // 	prefix: 'diffuseColor.a = ',
      // }),
      // new VariableConfig('uv', {
      // 	// default_from_attribute: true,
      // 	prefix: 'vUv = ',
      // 	// if: GlobalsGeometryHandler.IF_RULE.uv,
      // }),
    ];
  }
  create_variable_configs() {
    return BaseJsShaderAssembler.create_variable_configs();
  }
  _reset_variable_configs() {
    this._variable_configs = void 0;
    this.variable_configs();
  }
  inputNamesForShaderName(rootNode, shaderName) {
    var _a;
    if (shaderName == _utils_shaders_ShaderName__WEBPACK_IMPORTED_MODULE_0__/* .JsFunctionName.MAIN */ .J.MAIN) {
      return (rootNode.io.inputs.namedInputConnectionPoints() || []).map((c) => c.name());
    } else {
      return ((_a = this.shader_config(shaderName)) == null ? void 0 : _a.input_names()) || [];
    }
  }
  // time dependency
  _resetUniformsTimeDependency() {
    this._uniformsTimeDependent = false;
  }
  setUniformsTimeDependent() {
    this._uniformsTimeDependent = true;
  }
  uniformsTimeDependent() {
    return this._uniformsTimeDependent;
  }
  // resolution dependency
  _resetUniformsResolutionDependency() {
    this._uniformsResolutionDependent = false;
  }
  setUniformsResolutionDependent() {
    this._uniformsResolutionDependent = true;
  }
  uniformsResolutionDependent() {
    return this._uniformsResolutionDependent;
  }
  _raymarchingLightsWorldCoordsDependent() {
    return false;
  }
  //
  //
  // TEMPLATE HOOKS
  //
  //
  insertMemberAfter(shaderName) {
    return INSERT_MEMBER_AFTER_MAP.get(shaderName);
  }
  insertDefineAfter(shaderName) {
    return INSERT_DEFINE_AFTER_MAP.get(shaderName);
  }
  insertConstructorAfter(shaderName) {
    return INSERT_CONSTRUCTOR_AFTER_MAP.get(shaderName);
  }
  insertBodyAfter(shaderName) {
    return INSERT_BODY_AFTER_MAP.get(shaderName);
  }
  // protected insertTriggerAfter(shaderName: ShaderName): string | undefined {
  // 	return INSERT_TRIGGER_AFTER_MAP.get(shaderName);
  // }
  // protected insertTriggerableAfter(shaderName: ShaderName): string | undefined {
  // 	return INSERT_TRIGGERABLE_AFTER_MAP.get(shaderName);
  // }
  linesToRemove(shaderName) {
    return LINES_TO_REMOVE_MAP.get(shaderName);
  }
  //
  //
  // TEMPLATE CODE REPLACEMENT
  //
  //
  _replaceTemplate(template, shaderName) {
    const memberLines = this.builder_lines(shaderName, _utils_LineType__WEBPACK_IMPORTED_MODULE_9__/* .LineType.MEMBER */ .S.MEMBER);
    const constructorLines = this.builder_lines(shaderName, _utils_LineType__WEBPACK_IMPORTED_MODULE_9__/* .LineType.CONSTRUCTOR */ .S.CONSTRUCTOR);
    const defineLines = this.builder_lines(shaderName, _utils_LineType__WEBPACK_IMPORTED_MODULE_9__/* .LineType.DEFINE */ .S.DEFINE);
    const body = this.builder_lines(shaderName, _utils_LineType__WEBPACK_IMPORTED_MODULE_9__/* .LineType.BODY */ .S.BODY);
    let templateLines = template.split("\n");
    const newLines = [
      // `#define FPS ${ThreeToGl.float(scene.time_controller.fps)}`,
      // `#define TIME_INCREMENT (1.0/${ThreeToGl.float(scene.time_controller.fps)})`,
      // `#define FRAME_RANGE_START ${ThreeToGl.float(scene.time_controller.frame_range[0])}`,
      // `#define FRAME_RANGE_END ${ThreeToGl.float(scene.time_controller.frame_range[1])}`,
    ];
    const lineBeforeMember = this.insertMemberAfter(shaderName);
    const lineBeforeDefine = this.insertDefineAfter(shaderName);
    const lineBeforeConstructor = this.insertConstructorAfter(shaderName);
    const lineBeforeBody = this.insertBodyAfter(shaderName);
    const linesToRemove = this.linesToRemove(shaderName);
    let lineBeforeMemberFound = false;
    let lineBeforeDefineFound = false;
    let lineBeforeConstructorFound = false;
    let lineBeforeBodyFoundOnPreviousLine = false;
    let lineBeforeBodyFound = false;
    for (const templateLine of templateLines) {
      if (lineBeforeMemberFound == true) {
        if (memberLines) {
          this._insertLines(newLines, memberLines);
        }
        lineBeforeMemberFound = false;
      }
      if (lineBeforeDefineFound == true) {
        if (defineLines) {
          this._insertLines(newLines, defineLines);
        }
        lineBeforeDefineFound = false;
      }
      if (lineBeforeConstructorFound == true) {
        if (constructorLines) {
          this._insertLines(newLines, constructorLines);
        }
        lineBeforeConstructorFound = false;
      }
      if (lineBeforeBodyFoundOnPreviousLine == true) {
        if (body) {
          this._insertLines(newLines, body);
        }
        lineBeforeBodyFoundOnPreviousLine = false;
      }
      let line_remove_required = false;
      if (linesToRemove) {
        for (const line_to_remove of linesToRemove) {
          if (templateLine.indexOf(line_to_remove) >= 0) {
            line_remove_required = true;
          }
        }
      }
      if (!line_remove_required) {
        newLines.push(templateLine);
      } else {
        newLines.push("// removed:");
        newLines.push(`//${templateLine}`);
      }
      if (lineBeforeDefine && templateLine.indexOf(lineBeforeDefine) >= 0) {
        lineBeforeDefineFound = true;
      }
      if (lineBeforeConstructor && templateLine.indexOf(lineBeforeConstructor) >= 0) {
        lineBeforeConstructorFound = true;
      }
      if (lineBeforeMember && templateLine.indexOf(lineBeforeMember) >= 0) {
        lineBeforeMemberFound = true;
      }
      if (lineBeforeBody && templateLine.indexOf(lineBeforeBody) >= 0) {
        lineBeforeBodyFoundOnPreviousLine = true;
        lineBeforeBodyFound = true;
      }
    }
    if (lineBeforeBody) {
      if (!lineBeforeBodyFound) {
        console.warn(`line '${lineBeforeBody}' was not found in shader '${shaderName}'`, template, this);
      } else {
      }
    }
    this._lines.set(shaderName, newLines);
  }
  _insertLines(newLines, linesToAdd) {
    if (linesToAdd.length == 0) {
      return;
    }
    for (let i = 0; i < SPACED_LINES; i++) {
      newLines.push("");
    }
    for (const lineToAdd of linesToAdd) {
      newLines.push(lineToAdd);
    }
    for (let i = 0; i < SPACED_LINES; i++) {
      newLines.push("");
    }
  }
  addVariable(node, variable, varName) {
    const count = this._registeredVariablesCountByNode.get(node) || 0;
    this._registeredVariablesCountByNode.set(node, count + 1);
    const varFullName = varName ? varName : "VAR_" + _Base__WEBPACK_IMPORTED_MODULE_10__/* .TypedJsNode.inputVarName */ .xZ.inputVarName(node, count == 0 ? "" : `_${count}`);
    this._registeredVariables.set(varFullName, variable);
    return varFullName;
  }
  traverseRegisteredVariables(callback) {
    this._registeredVariables.forEach(callback);
  }
  _resetRegisteredVariables() {
    this._registeredVariables.clear();
    this._registeredVariablesCountByNode.clear();
  }
  addFunction(node, namedFunction) {
    const existingFunctionName = this._registeredFunctions.get(namedFunction.type());
    if (existingFunctionName) {
      return;
    }
    this._registeredFunctions.set(namedFunction.type(), namedFunction);
  }
  traverseRegisteredFunctions(callback) {
    this._registeredFunctions.forEach(callback);
  }
  _resetRegisteredFunctions() {
    this._registeredFunctions.clear();
  }
}


/***/ }),

/***/ 13320:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "R": function() { return /* binding */ ActorPersistedConfig; }
/* harmony export */ });
/* harmony import */ var _utils_BasePersistedConfig__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(14802);
/* harmony import */ var _utils_JsParamConfig__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(35833);
/* harmony import */ var _BaseJsPersistedConfig__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(35446);

var __async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};



class ActorPersistedConfig extends _utils_BasePersistedConfig__WEBPACK_IMPORTED_MODULE_0__/* .BasePersistedConfig */ .p {
  constructor(node) {
    super(node);
    this.node = node;
  }
  toData() {
    return __async(this, null, function* () {
      yield this.node.compilationController.compileIfRequired();
      const assemblerController = this.node.assemblerController();
      if (!assemblerController) {
        return;
      }
      const functionData = this.node.compilationController.functionData();
      if (!functionData) {
        return;
      }
      const { functionBody, variableNames, functionNames, paramConfigs, eventDatas } = functionData;
      const data = {
        functionBody,
        variableNames,
        variables: (0,_BaseJsPersistedConfig__WEBPACK_IMPORTED_MODULE_1__/* .serializedVariablesFromFunctionData */ .ve)(functionData),
        functionNames,
        serializedParamConfigs: paramConfigs.map((p) => p.toJSON()),
        eventDatas
      };
      return data;
    });
  }
  load(data) {
    const assemblerController = this.node.assemblerController();
    if (assemblerController) {
      return;
    }
    const { functionBody, variableNames, functionNames, serializedParamConfigs, eventDatas } = data;
    const functionData = {
      functionBody,
      variableNames,
      variablesByName: (0,_BaseJsPersistedConfig__WEBPACK_IMPORTED_MODULE_1__/* .variablesByNameFromPersistedConfigData */ .pw)(data),
      functionNames,
      functionsByName: (0,_BaseJsPersistedConfig__WEBPACK_IMPORTED_MODULE_1__/* .functionsByNameFromPersistedConfigData */ .Kg)(data, this.node),
      paramConfigs: serializedParamConfigs.map((json) => _utils_JsParamConfig__WEBPACK_IMPORTED_MODULE_2__/* .JsParamConfig.fromJSON */ .M.fromJSON(json)),
      eventDatas
    };
    this.node.compilationController.updateFromFunctionData(functionData);
  }
}


/***/ }),

/***/ 13082:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "T": function() { return /* binding */ EntityVariable; },
/* harmony export */   "k": function() { return /* binding */ EntityBuilderAssemblerConstant; }
/* harmony export */ });

var EntityBuilderAssemblerConstant = /* @__PURE__ */ ((EntityBuilderAssemblerConstant2) => {
  EntityBuilderAssemblerConstant2["OBJECT"] = "entityContainer.object";
  EntityBuilderAssemblerConstant2["ENTITY_CONTAINER"] = "entityContainer";
  EntityBuilderAssemblerConstant2["POSITION"] = "entityContainer.position";
  EntityBuilderAssemblerConstant2["NORMAL"] = "entityContainer.normal";
  EntityBuilderAssemblerConstant2["INDEX"] = "entityContainer.index";
  EntityBuilderAssemblerConstant2["OBJNUM"] = "entityContainer.objnum";
  EntityBuilderAssemblerConstant2["NORMALS_UPDATED"] = "entityContainer.normalsUpdated";
  EntityBuilderAssemblerConstant2["PRIMITIVE_GRAPH"] = "entityContainer.primitiveGraph";
  EntityBuilderAssemblerConstant2["ATTRIBUTES_DICT"] = "attributesDict";
  EntityBuilderAssemblerConstant2["MATERIAL"] = "null";
  return EntityBuilderAssemblerConstant2;
})(EntityBuilderAssemblerConstant || {});
var EntityVariable = /* @__PURE__ */ ((EntityVariable2) => {
  EntityVariable2["POSITION"] = "position";
  EntityVariable2["NORMAL"] = "normal";
  EntityVariable2["INDEX"] = "index";
  EntityVariable2["OBJNUM"] = "objnum";
  return EntityVariable2;
})(EntityVariable || {});


/***/ }),

/***/ 28268:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "i": function() { return /* binding */ InstanceBuilderAssemblerConstant; },
/* harmony export */   "o": function() { return /* binding */ InstanceVariable; }
/* harmony export */ });

var InstanceBuilderAssemblerConstant = /* @__PURE__ */ ((InstanceBuilderAssemblerConstant2) => {
  InstanceBuilderAssemblerConstant2["POINT_CONTAINER"] = "pointContainer";
  InstanceBuilderAssemblerConstant2["INSTANCE_POSITION"] = "pointContainer.instancePosition";
  InstanceBuilderAssemblerConstant2["INSTANCE_QUATERNION"] = "pointContainer.instanceQuaternion";
  InstanceBuilderAssemblerConstant2["INSTANCE_SCALE"] = "pointContainer.instanceScale";
  InstanceBuilderAssemblerConstant2["PTNUM"] = "pointContainer.ptnum";
  InstanceBuilderAssemblerConstant2["OBJNUM"] = "pointContainer.objnum";
  InstanceBuilderAssemblerConstant2["ATTRIBUTES_DICT"] = "attributesDict";
  InstanceBuilderAssemblerConstant2["OBJECT_3D"] = "null";
  InstanceBuilderAssemblerConstant2["MATERIAL"] = "null";
  return InstanceBuilderAssemblerConstant2;
})(InstanceBuilderAssemblerConstant || {});
var InstanceVariable = /* @__PURE__ */ ((InstanceVariable2) => {
  InstanceVariable2["INSTANCE_POSITION"] = "instancePosition";
  InstanceVariable2["INSTANCE_QUATERNION"] = "instanceQuaternion";
  InstanceVariable2["INSTANCE_SCALE"] = "instanceScale";
  InstanceVariable2["PTNUM"] = "ptnum";
  InstanceVariable2["OBJNUM"] = "objnum";
  return InstanceVariable2;
})(InstanceVariable || {});


/***/ }),

/***/ 20924:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "F": function() { return /* binding */ ObjectBuilderAssemblerConstant; },
/* harmony export */   "K": function() { return /* binding */ ObjectVariable; }
/* harmony export */ });

var ObjectBuilderAssemblerConstant = /* @__PURE__ */ ((ObjectBuilderAssemblerConstant2) => {
  ObjectBuilderAssemblerConstant2["OBJECT_CONTAINER"] = "objectContainer";
  ObjectBuilderAssemblerConstant2["OBJECT_3D"] = "objectContainer.Object3D";
  ObjectBuilderAssemblerConstant2["OBJ_NUM"] = "objectContainer.objnum";
  ObjectBuilderAssemblerConstant2["MATERIAL"] = "objectContainer.Object3D.material";
  ObjectBuilderAssemblerConstant2["PTNUM"] = "null";
  ObjectBuilderAssemblerConstant2["PRIMITIVE_GRAPH"] = "null";
  return ObjectBuilderAssemblerConstant2;
})(ObjectBuilderAssemblerConstant || {});
var ObjectVariable = /* @__PURE__ */ ((ObjectVariable2) => {
  ObjectVariable2["OBJECT_3D"] = "Object3D";
  ObjectVariable2["POSITION"] = "position";
  ObjectVariable2["ROTATION"] = "rotation";
  ObjectVariable2["QUATERNION"] = "quaternion";
  ObjectVariable2["SCALE"] = "scale";
  ObjectVariable2["MATRIX"] = "matrix";
  ObjectVariable2["VISIBLE"] = "visible";
  ObjectVariable2["MATRIX_AUTO_UPDATE"] = "matrixAutoUpdate";
  ObjectVariable2["CAST_SHADOW"] = "castShadow";
  ObjectVariable2["RECEIVE_SHADOW"] = "receiveShadow";
  ObjectVariable2["FRUSTUM_CULLED"] = "frustumCulled";
  ObjectVariable2["OBJ_NUM"] = "objnum";
  return ObjectVariable2;
})(ObjectVariable || {});


/***/ }),

/***/ 38934:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "U": function() { return /* binding */ PointVariable; },
/* harmony export */   "X": function() { return /* binding */ PointBuilderAssemblerConstant; }
/* harmony export */ });

var PointBuilderAssemblerConstant = /* @__PURE__ */ ((PointBuilderAssemblerConstant2) => {
  PointBuilderAssemblerConstant2["POINT_CONTAINER"] = "pointContainer";
  PointBuilderAssemblerConstant2["POSITION"] = "pointContainer.position";
  PointBuilderAssemblerConstant2["NORMAL"] = "pointContainer.normal";
  PointBuilderAssemblerConstant2["PTNUM"] = "pointContainer.ptnum";
  PointBuilderAssemblerConstant2["OBJNUM"] = "pointContainer.objnum";
  PointBuilderAssemblerConstant2["NORMALS_UPDATED"] = "pointContainer.normalsUpdated";
  PointBuilderAssemblerConstant2["ATTRIBUTES_DICT"] = "attributesDict";
  PointBuilderAssemblerConstant2["OBJECT_3D"] = "null";
  PointBuilderAssemblerConstant2["MATERIAL"] = "null";
  PointBuilderAssemblerConstant2["PRIMITIVE_GRAPH"] = "null";
  return PointBuilderAssemblerConstant2;
})(PointBuilderAssemblerConstant || {});
var PointVariable = /* @__PURE__ */ ((PointVariable2) => {
  PointVariable2["POSITION"] = "position";
  PointVariable2["NORMAL"] = "normal";
  PointVariable2["PTNUM"] = "ptnum";
  PointVariable2["OBJNUM"] = "objnum";
  return PointVariable2;
})(PointVariable || {});


/***/ }),

/***/ 80524:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Y": function() { return /* binding */ JsAssemblerSoftBody; },
/* harmony export */   "h": function() { return /* binding */ SoftBodyVariable; }
/* harmony export */ });
/* harmony import */ var _Base__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(19253);
/* harmony import */ var _core_ThreeToGl__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(81556);
/* harmony import */ var _configs_ShaderConfig__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(3180);
/* harmony import */ var _configs_VariableConfig__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(40617);
/* harmony import */ var _utils_shaders_ShaderName__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(76606);
/* harmony import */ var _utils_io_connections_Js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(38857);
/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(21410);
/* harmony import */ var _core_code_PrettierController__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(52733);









var SoftBodyVariable = /* @__PURE__ */ ((SoftBodyVariable2) => {
  SoftBodyVariable2["P"] = "position";
  SoftBodyVariable2["V"] = "velocity";
  SoftBodyVariable2["COLLISION_SDF"] = "collisionSDF";
  SoftBodyVariable2["TIME"] = "time";
  SoftBodyVariable2["DELTA"] = "delta";
  return SoftBodyVariable2;
})(SoftBodyVariable || {});
const TEMPLATE_VELOCITY = `
${_Base__WEBPACK_IMPORTED_MODULE_0__/* .INSERT_DEFINE_AFTER */ .Zf}
${_Base__WEBPACK_IMPORTED_MODULE_0__/* .INSERT_MEMBERS_AFTER */ .FD}
${_Base__WEBPACK_IMPORTED_MODULE_0__/* .INSERT_CONSTRUCTOR_AFTER */ .Yx}
const SoftBodyVelocity = function(){
	${_Base__WEBPACK_IMPORTED_MODULE_0__/* .INSERT_BODY_AFTER */ .xP}
`;
const CLOSE_CLASS_DEFINITION_VELOCITY = `};
return SoftBodyVelocity;`;
const TEMPLATE_COLLIDER = `
${_Base__WEBPACK_IMPORTED_MODULE_0__/* .INSERT_DEFINE_AFTER */ .Zf}
${_Base__WEBPACK_IMPORTED_MODULE_0__/* .INSERT_MEMBERS_AFTER */ .FD}
${_Base__WEBPACK_IMPORTED_MODULE_0__/* .INSERT_CONSTRUCTOR_AFTER */ .Yx}
const SoftBodyCollider = function(){
	${_Base__WEBPACK_IMPORTED_MODULE_0__/* .INSERT_BODY_AFTER */ .xP}
`;
const CLOSE_CLASS_DEFINITION_COLLIDER = `};
return SoftBodyCollider;`;
class JsAssemblerSoftBody extends _Base__WEBPACK_IMPORTED_MODULE_0__/* .BaseJsShaderAssembler */ .SD {
  makeFunctionNodeDirtyOnChange() {
    return true;
  }
  defaultObjectVariable() {
    return "null";
  }
  defaultObject3DMaterialVariable() {
    return "null";
  }
  defaultPrimitiveGraph() {
    return "null";
  }
  templateShader() {
    return {
      velocity: TEMPLATE_VELOCITY,
      collider: TEMPLATE_COLLIDER
    };
  }
  spareParamsOptions(options) {
    const _options = {
      spare: true,
      // computeOnDirty: true, // not needed if cook option is not set
      cook: false,
      // for Softbody, the node must not recook
      // important for texture nodes
      // that compute after being found by the nodepath param
      dependentOnFoundNode: true
    };
    return _options;
  }
  functionData() {
    const _buildFunctionBody = (functionName, closeDef) => {
      const bodyLines = this._shaders_by_name.get(functionName) || TEMPLATE_VELOCITY;
      const functionBodyElements = [
        bodyLines,
        // triggerableFunctionLines.join('\n'),
        // triggerFunctionLines.join('\n'),
        closeDef
      ];
      const functionBody = _core_code_PrettierController__WEBPACK_IMPORTED_MODULE_1__/* .PrettierController.formatJs */ .u.formatJs(functionBodyElements.join("\n"));
      return functionBody;
    };
    const functionBodyVelocity = _buildFunctionBody(_utils_shaders_ShaderName__WEBPACK_IMPORTED_MODULE_2__/* .JsFunctionName.VELOCITY */ .J.VELOCITY, CLOSE_CLASS_DEFINITION_VELOCITY);
    const functionBodyCollider = _buildFunctionBody(_utils_shaders_ShaderName__WEBPACK_IMPORTED_MODULE_2__/* .JsFunctionName.COLLIDER */ .J.COLLIDER, CLOSE_CLASS_DEFINITION_COLLIDER);
    if (!(functionBodyVelocity && functionBodyCollider)) {
      return;
    }
    const variableNames = [];
    const functionNames = [];
    const variablesByName = {};
    const functionsByName = {};
    this.traverseRegisteredVariables((variable, varName) => {
      variableNames.push(varName);
      variablesByName[varName] = variable;
    });
    this.traverseRegisteredFunctions((namedFunction) => {
      functionNames.push(namedFunction.type());
      functionsByName[namedFunction.type()] = namedFunction.func.bind(namedFunction);
    });
    const paramConfigs = this.param_configs();
    return {
      functionBody: {
        velocity: functionBodyVelocity,
        collider: functionBodyCollider
      },
      variableNames,
      variablesByName,
      functionNames,
      functionsByName,
      paramConfigs: [...paramConfigs]
    };
  }
  updateFunction() {
    super.updateFunction();
    this._lines = /* @__PURE__ */ new Map();
    this._shaders_by_name = /* @__PURE__ */ new Map();
    const shaderNames = this.shaderNames();
    if (this._root_nodes.length > 0) {
      this.buildCodeFromNodes(this._root_nodes);
      this._buildLines();
    }
    for (const shaderName of shaderNames) {
      const lines = this._lines.get(shaderName);
      if (lines) {
        this._shaders_by_name.set(shaderName, lines.join("\n"));
      }
    }
  }
  //
  //
  // CHILDREN NODES PARAMS
  //
  //
  add_output_inputs(output_child) {
    output_child.io.inputs.setNamedInputConnectionPoints([
      new _utils_io_connections_Js__WEBPACK_IMPORTED_MODULE_3__/* .JsConnectionPoint */ .fp("velocity" /* V */, _utils_io_connections_Js__WEBPACK_IMPORTED_MODULE_3__/* .JsConnectionPointType.VECTOR3 */ .zF.VECTOR3),
      new _utils_io_connections_Js__WEBPACK_IMPORTED_MODULE_3__/* .JsConnectionPoint */ .fp("collisionSDF" /* COLLISION_SDF */, _utils_io_connections_Js__WEBPACK_IMPORTED_MODULE_3__/* .JsConnectionPointType.FLOAT */ .zF.FLOAT)
    ]);
  }
  add_globals_outputs(globals_node) {
    globals_node.io.outputs.setNamedOutputConnectionPoints([
      new _utils_io_connections_Js__WEBPACK_IMPORTED_MODULE_3__/* .JsConnectionPoint */ .fp("position" /* P */, _utils_io_connections_Js__WEBPACK_IMPORTED_MODULE_3__/* .JsConnectionPointType.VECTOR3 */ .zF.VECTOR3),
      new _utils_io_connections_Js__WEBPACK_IMPORTED_MODULE_3__/* .JsConnectionPoint */ .fp("velocity" /* V */, _utils_io_connections_Js__WEBPACK_IMPORTED_MODULE_3__/* .JsConnectionPointType.VECTOR3 */ .zF.VECTOR3),
      new _utils_io_connections_Js__WEBPACK_IMPORTED_MODULE_3__/* .JsConnectionPoint */ .fp("time" /* TIME */, _utils_io_connections_Js__WEBPACK_IMPORTED_MODULE_3__/* .JsConnectionPointType.FLOAT */ .zF.FLOAT),
      new _utils_io_connections_Js__WEBPACK_IMPORTED_MODULE_3__/* .JsConnectionPoint */ .fp("delta" /* DELTA */, _utils_io_connections_Js__WEBPACK_IMPORTED_MODULE_3__/* .JsConnectionPointType.FLOAT */ .zF.FLOAT)
    ]);
  }
  //
  //
  // CONFIGS
  //
  //
  create_shader_configs() {
    return [
      new _configs_ShaderConfig__WEBPACK_IMPORTED_MODULE_4__/* .JsShaderConfig */ .s(_utils_shaders_ShaderName__WEBPACK_IMPORTED_MODULE_2__/* .JsFunctionName.VELOCITY */ .J.VELOCITY, ["velocity" /* V */], []),
      new _configs_ShaderConfig__WEBPACK_IMPORTED_MODULE_4__/* .JsShaderConfig */ .s(_utils_shaders_ShaderName__WEBPACK_IMPORTED_MODULE_2__/* .JsFunctionName.COLLIDER */ .J.COLLIDER, ["collisionSDF" /* COLLISION_SDF */], [])
    ];
  }
  create_variable_configs() {
    return [
      new _configs_VariableConfig__WEBPACK_IMPORTED_MODULE_5__/* .VariableConfig */ .P("velocity" /* V */, {
        prefix: "return "
      }),
      new _configs_VariableConfig__WEBPACK_IMPORTED_MODULE_5__/* .VariableConfig */ .P("collisionSDF" /* COLLISION_SDF */, {
        prefix: "return "
      })
    ];
  }
  setNodeLinesOutput(outputNode, linesController) {
    const inputNames = this.inputNamesForShaderName(
      outputNode,
      linesController.currentShaderName()
    );
    if (inputNames) {
      for (const inputName of inputNames) {
        const input = outputNode.io.inputs.named_input(inputName);
        const glVar = outputNode.variableForInput(linesController, inputName);
        switch (inputName) {
          case "velocity" /* V */: {
            const _defaultVar = () => {
              const tmpVarName = linesController.addVariable(outputNode, new three__WEBPACK_IMPORTED_MODULE_6__.Vector3(0, 0.1, 0));
              return `return ${tmpVarName}`;
            };
            const bodyLine = input ? `return ${_core_ThreeToGl__WEBPACK_IMPORTED_MODULE_7__/* .ThreeToGl.any */ ._.any(glVar)}` : _defaultVar();
            linesController._addBodyLines(outputNode, [bodyLine]);
            break;
          }
          case "collisionSDF" /* COLLISION_SDF */: {
            const bodyLine = input ? `return ${_core_ThreeToGl__WEBPACK_IMPORTED_MODULE_7__/* .ThreeToGl.any */ ._.any(glVar)}` : `return 100`;
            linesController._addBodyLines(outputNode, [bodyLine]);
            break;
          }
        }
      }
    }
  }
  setNodeLinesGlobals(globalsNode, shadersCollectionController) {
    const shaderName = shadersCollectionController.currentShaderName();
    const shaderConfig = this.shader_config(shaderName);
    if (!shaderConfig) {
      return;
    }
    const bodyLines = [];
    const usedOutputNames = globalsNode.io.outputs.used_output_names();
    for (const outputName of usedOutputNames) {
      const varName = globalsNode.jsVarName(outputName);
      switch (outputName) {
        case "position": {
          shadersCollectionController.addVariable(globalsNode, new three__WEBPACK_IMPORTED_MODULE_6__.Vector3(), varName);
          bodyLines.push(`${varName}.copy(${outputName})`);
          break;
        }
        case "velocity" /* V */: {
          shadersCollectionController.addVariable(globalsNode, new three__WEBPACK_IMPORTED_MODULE_6__.Vector3(), varName);
          bodyLines.push(`${varName}.copy(${outputName})`);
          break;
        }
        case "time" /* TIME */: {
          bodyLines.push(`const ${varName} = ${"time" /* TIME */}`);
          break;
        }
        case "delta" /* DELTA */: {
          bodyLines.push(`const ${varName} = ${"delta" /* DELTA */}`);
          break;
        }
      }
    }
    shadersCollectionController._addBodyLines(globalsNode, bodyLines);
  }
}


/***/ }),

/***/ 3180:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "s": function() { return /* binding */ JsShaderConfig; }
/* harmony export */ });

class JsShaderConfig {
  constructor(_name, _input_names, _dependencies) {
    this._name = _name;
    this._input_names = _input_names;
    this._dependencies = _dependencies;
  }
  name() {
    return this._name;
  }
  input_names() {
    return this._input_names;
  }
  dependencies() {
    return this._dependencies;
  }
}


/***/ }),

/***/ 40617:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "P": function() { return /* binding */ VariableConfig; }
/* harmony export */ });

class VariableConfig {
  constructor(_name, _options = {}) {
    this._name = _name;
    this._options = _options;
  }
  name() {
    return this._name;
  }
  default_from_attribute() {
    return this._options["default_from_attribute"] || false;
  }
  default() {
    return this._options["default"];
  }
  if_condition() {
    return this._options["if"];
  }
  // required_definitions(){
  // 	return this._options['required_definitions']
  // }
  prefix() {
    return this._options["prefix"] || "";
  }
  suffix() {
    return this._options["suffix"] || "";
  }
  postLines() {
    return this._options.postLines;
  }
}


/***/ }),

/***/ 80388:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Z": function() { return /* binding */ MeshPhysicalBuilderMatNode; }
/* harmony export */ });
/* harmony import */ var _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(96949);
/* harmony import */ var _utils_UniformsTransparencyController__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(70573);
/* harmony import */ var _utils_AdvancedCommonController__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(90476);
/* harmony import */ var _utils_TextureMapController__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(87732);
/* harmony import */ var _utils_TextureAlphaMapController__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(71607);
/* harmony import */ var _utils_TextureBumpMapController__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(89328);
/* harmony import */ var _utils_TextureEmissiveMapController__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(69228);
/* harmony import */ var _utils_TextureEnvMapController__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(5481);
/* harmony import */ var _utils_TextureAOMapController__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(94135);
/* harmony import */ var _utils_TextureNormalMapController__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(19767);
/* harmony import */ var _utils_TextureMetalnessRoughnessMapController__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(94440);
/* harmony import */ var _utils_TextureLightMapController__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(28985);
/* harmony import */ var _utils_MeshPhysicalController__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(23746);
/* harmony import */ var _utils_TextureDisplacementMapController__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(70967);
/* harmony import */ var _BaseBuilder__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(88303);
/* harmony import */ var _poly_registers_assemblers_BaseRegister__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(33899);
/* harmony import */ var _Poly__WEBPACK_IMPORTED_MODULE_24__ = __webpack_require__(99934);
/* harmony import */ var _utils_UniformsFogController__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(9161);
/* harmony import */ var _utils_WireframeShaderMaterialController__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(91419);
/* harmony import */ var _utils_DefaultFolder__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(99233);
/* harmony import */ var _utils_TexturesFolder__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(45231);
/* harmony import */ var _utils_AdvancedFolder__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(73777);
/* harmony import */ var _utils_PCSSController__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(8745);
/* harmony import */ var _utils_customMaterials_CustomMaterialMesh__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(92874);
/* harmony import */ var _poly_registers_nodes_types_Mat__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(41545);

var __async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};

























function AdvancedMeshPhysicalParamConfig(Base) {
  return class Mixin extends (0,_utils_PCSSController__WEBPACK_IMPORTED_MODULE_0__/* .PCSSParamConfig */ .y)(
    (0,_utils_UniformsFogController__WEBPACK_IMPORTED_MODULE_1__/* .FogParamConfig */ .N)((0,_utils_WireframeShaderMaterialController__WEBPACK_IMPORTED_MODULE_2__/* .WireframeShaderMaterialParamsConfig */ .j)((0,_utils_AdvancedCommonController__WEBPACK_IMPORTED_MODULE_3__/* .AdvancedCommonParamConfig */ .E)((0,_BaseBuilder__WEBPACK_IMPORTED_MODULE_4__/* .BaseBuilderParamConfig */ .I)(Base))))
  ) {
  };
}
class MeshPhysicalBuilderMatParamsConfig extends (0,_utils_customMaterials_CustomMaterialMesh__WEBPACK_IMPORTED_MODULE_5__/* .CustomMaterialMeshParamConfig */ .B)(
  AdvancedMeshPhysicalParamConfig(
    /* advanced */
    (0,_utils_AdvancedFolder__WEBPACK_IMPORTED_MODULE_6__/* .AdvancedFolderParamConfig */ .A)(
      (0,_utils_MeshPhysicalController__WEBPACK_IMPORTED_MODULE_7__/* .MeshPhysicalParamConfig */ .Vs)(
        (0,_utils_TextureMetalnessRoughnessMapController__WEBPACK_IMPORTED_MODULE_8__/* .MetalnessRoughnessMapParamConfig */ .EO)(
          (0,_utils_TextureNormalMapController__WEBPACK_IMPORTED_MODULE_9__/* .NormalMapParamConfig */ .$)(
            (0,_utils_TextureLightMapController__WEBPACK_IMPORTED_MODULE_10__/* .LightMapParamConfig */ .T)(
              (0,_utils_TextureEnvMapController__WEBPACK_IMPORTED_MODULE_11__/* .EnvMapParamConfig */ .s7)(
                (0,_utils_TextureEmissiveMapController__WEBPACK_IMPORTED_MODULE_12__/* .EmissiveMapParamConfig */ .f)(
                  (0,_utils_TextureDisplacementMapController__WEBPACK_IMPORTED_MODULE_13__/* .DisplacementMapParamConfig */ .n)(
                    (0,_utils_TextureBumpMapController__WEBPACK_IMPORTED_MODULE_14__/* .BumpMapParamConfig */ .w)(
                      (0,_utils_TextureAOMapController__WEBPACK_IMPORTED_MODULE_15__/* .AOMapParamConfig */ .T)(
                        (0,_utils_TextureAlphaMapController__WEBPACK_IMPORTED_MODULE_16__/* .AlphaMapParamConfig */ .T)(
                          (0,_utils_TextureMapController__WEBPACK_IMPORTED_MODULE_17__/* .MapParamConfig */ .D)(
                            /* textures */
                            (0,_utils_TexturesFolder__WEBPACK_IMPORTED_MODULE_18__/* .TexturesFolderParamConfig */ .o)(
                              (0,_utils_UniformsTransparencyController__WEBPACK_IMPORTED_MODULE_19__/* .UniformsTransparencyParamConfig */ .F)(
                                (0,_utils_DefaultFolder__WEBPACK_IMPORTED_MODULE_20__/* .DefaultFolderParamConfig */ .b)(_utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_21__/* .NodeParamsConfig */ .yI)
                              )
                            )
                          )
                        )
                      )
                    )
                  )
                )
              )
            )
          )
        )
      )
    )
  )
) {
}
const ParamsConfig = new MeshPhysicalBuilderMatParamsConfig();
class MeshPhysicalBuilderMatNode extends _BaseBuilder__WEBPACK_IMPORTED_MODULE_4__/* .TypedBuilderMatNode */ .T {
  constructor() {
    super(...arguments);
    this.paramsConfig = ParamsConfig;
    this.controllers = {
      advancedCommon: new _utils_AdvancedCommonController__WEBPACK_IMPORTED_MODULE_3__/* .AdvancedCommonController */ .h(this),
      alphaMap: new _utils_TextureAlphaMapController__WEBPACK_IMPORTED_MODULE_16__/* .TextureAlphaMapController */ .s(this),
      aoMap: new _utils_TextureAOMapController__WEBPACK_IMPORTED_MODULE_15__/* .TextureAOMapController */ .Z(this),
      bumpMap: new _utils_TextureBumpMapController__WEBPACK_IMPORTED_MODULE_14__/* .TextureBumpMapController */ .T(this),
      displacementMap: new _utils_TextureDisplacementMapController__WEBPACK_IMPORTED_MODULE_13__/* .TextureDisplacementMapController */ .u(this),
      emissiveMap: new _utils_TextureEmissiveMapController__WEBPACK_IMPORTED_MODULE_12__/* .TextureEmissiveMapController */ .z(this),
      envMap: new _utils_TextureEnvMapController__WEBPACK_IMPORTED_MODULE_11__/* .TextureEnvMapController */ .nz(this),
      uniformFog: new _utils_UniformsFogController__WEBPACK_IMPORTED_MODULE_1__/* .UniformFogController */ .z(this),
      lightMap: new _utils_TextureLightMapController__WEBPACK_IMPORTED_MODULE_10__/* .TextureLightMapController */ .$(this),
      map: new _utils_TextureMapController__WEBPACK_IMPORTED_MODULE_17__/* .TextureMapController */ .g(this),
      metalnessRoughnessMap: new _utils_TextureMetalnessRoughnessMapController__WEBPACK_IMPORTED_MODULE_8__/* .TextureMetalnessRoughnessMapController */ .Ae(this),
      normalMap: new _utils_TextureNormalMapController__WEBPACK_IMPORTED_MODULE_9__/* .TextureNormalMapController */ .w(this),
      physical: new _utils_MeshPhysicalController__WEBPACK_IMPORTED_MODULE_7__/* .MeshPhysicalController */ .y(this),
      PCSS: new _utils_PCSSController__WEBPACK_IMPORTED_MODULE_0__/* .PCSSController */ .P(this),
      uniformTransparency: new _utils_UniformsTransparencyController__WEBPACK_IMPORTED_MODULE_19__/* .UniformsTransparencyController */ .N(this),
      wireframeShader: new _utils_WireframeShaderMaterialController__WEBPACK_IMPORTED_MODULE_2__/* .WireframeShaderMaterialController */ .w(this)
    };
    this.controllersList = Object.values(this.controllers);
  }
  static type() {
    return _poly_registers_nodes_types_Mat__WEBPACK_IMPORTED_MODULE_22__/* .MatType.MESH_PHYSICAL_BUILDER */ .M.MESH_PHYSICAL_BUILDER;
  }
  usedAssembler() {
    return _poly_registers_assemblers_BaseRegister__WEBPACK_IMPORTED_MODULE_23__/* .AssemblerName.GL_MESH_PHYSICAL */ .Q.GL_MESH_PHYSICAL;
  }
  _createAssemblerController() {
    return _Poly__WEBPACK_IMPORTED_MODULE_24__/* .Poly.assemblersRegister.assembler */ .L.assemblersRegister.assembler(this, this.usedAssembler());
  }
  customMaterialRequested(customName) {
    return (0,_utils_customMaterials_CustomMaterialMesh__WEBPACK_IMPORTED_MODULE_5__/* .materialMeshAssemblerCustomMaterialRequested */ .F)(this, customName);
  }
  createMaterial() {
    const material = super.createMaterial();
    material.isMeshStandardMaterial = true;
    material.isMeshPhysicalMaterial = true;
    return material;
  }
  cook() {
    return __async(this, null, function* () {
      this._material = this._material || this.createMaterial();
      yield Promise.all(this.controllersPromises(this._material));
      this.compileIfRequired(this._material);
      this.setMaterial(this._material);
    });
  }
}


/***/ }),

/***/ 53950:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "k": function() { return /* binding */ MeshStandardBuilderMatNode; }
/* harmony export */ });
/* harmony import */ var _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(96949);
/* harmony import */ var _utils_UniformsTransparencyController__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(70573);
/* harmony import */ var _utils_AdvancedCommonController__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(90476);
/* harmony import */ var _utils_TextureMapController__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(87732);
/* harmony import */ var _utils_TextureAlphaMapController__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(71607);
/* harmony import */ var _utils_TextureBumpMapController__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(89328);
/* harmony import */ var _utils_TextureEmissiveMapController__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(69228);
/* harmony import */ var _utils_TextureEnvMapController__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(5481);
/* harmony import */ var _utils_TextureAOMapController__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(94135);
/* harmony import */ var _utils_TextureNormalMapController__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(19767);
/* harmony import */ var _utils_TextureMetalnessRoughnessMapController__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(94440);
/* harmony import */ var _utils_TextureLightMapController__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(28985);
/* harmony import */ var _utils_TextureDisplacementMapController__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(70967);
/* harmony import */ var _BaseBuilder__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(88303);
/* harmony import */ var _poly_registers_assemblers_BaseRegister__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(33899);
/* harmony import */ var _Poly__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(99934);
/* harmony import */ var _utils_UniformsFogController__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(9161);
/* harmony import */ var _utils_WireframeShaderMaterialController__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(91419);
/* harmony import */ var _utils_DefaultFolder__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(99233);
/* harmony import */ var _utils_TexturesFolder__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(45231);
/* harmony import */ var _utils_AdvancedFolder__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(73777);
/* harmony import */ var _utils_PCSSController__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(8745);
/* harmony import */ var _utils_customMaterials_CustomMaterialMesh__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(92874);
/* harmony import */ var _poly_registers_nodes_types_Mat__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(41545);

var __async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};
























class MeshStandardBuilderMatParamsConfig extends (0,_utils_customMaterials_CustomMaterialMesh__WEBPACK_IMPORTED_MODULE_0__/* .CustomMaterialMeshParamConfig */ .B)(
  (0,_utils_PCSSController__WEBPACK_IMPORTED_MODULE_1__/* .PCSSParamConfig */ .y)(
    (0,_utils_UniformsFogController__WEBPACK_IMPORTED_MODULE_2__/* .FogParamConfig */ .N)(
      (0,_utils_WireframeShaderMaterialController__WEBPACK_IMPORTED_MODULE_3__/* .WireframeShaderMaterialParamsConfig */ .j)(
        (0,_utils_AdvancedCommonController__WEBPACK_IMPORTED_MODULE_4__/* .AdvancedCommonParamConfig */ .E)(
          (0,_BaseBuilder__WEBPACK_IMPORTED_MODULE_5__/* .BaseBuilderParamConfig */ .I)(
            /* advanced */
            (0,_utils_AdvancedFolder__WEBPACK_IMPORTED_MODULE_6__/* .AdvancedFolderParamConfig */ .A)(
              (0,_utils_TextureMetalnessRoughnessMapController__WEBPACK_IMPORTED_MODULE_7__/* .MetalnessRoughnessMapParamConfig */ .EO)(
                (0,_utils_TextureNormalMapController__WEBPACK_IMPORTED_MODULE_8__/* .NormalMapParamConfig */ .$)(
                  (0,_utils_TextureLightMapController__WEBPACK_IMPORTED_MODULE_9__/* .LightMapParamConfig */ .T)(
                    (0,_utils_TextureEnvMapController__WEBPACK_IMPORTED_MODULE_10__/* .EnvMapParamConfig */ .s7)(
                      (0,_utils_TextureEmissiveMapController__WEBPACK_IMPORTED_MODULE_11__/* .EmissiveMapParamConfig */ .f)(
                        (0,_utils_TextureDisplacementMapController__WEBPACK_IMPORTED_MODULE_12__/* .DisplacementMapParamConfig */ .n)(
                          (0,_utils_TextureBumpMapController__WEBPACK_IMPORTED_MODULE_13__/* .BumpMapParamConfig */ .w)(
                            (0,_utils_TextureAOMapController__WEBPACK_IMPORTED_MODULE_14__/* .AOMapParamConfig */ .T)(
                              (0,_utils_TextureAlphaMapController__WEBPACK_IMPORTED_MODULE_15__/* .AlphaMapParamConfig */ .T)(
                                (0,_utils_TextureMapController__WEBPACK_IMPORTED_MODULE_16__/* .MapParamConfig */ .D)(
                                  /* textures */
                                  (0,_utils_TexturesFolder__WEBPACK_IMPORTED_MODULE_17__/* .TexturesFolderParamConfig */ .o)(
                                    (0,_utils_UniformsTransparencyController__WEBPACK_IMPORTED_MODULE_18__/* .UniformsTransparencyParamConfig */ .F)(
                                      (0,_utils_DefaultFolder__WEBPACK_IMPORTED_MODULE_19__/* .DefaultFolderParamConfig */ .b)(_utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_20__/* .NodeParamsConfig */ .yI)
                                    )
                                  )
                                )
                              )
                            )
                          )
                        )
                      )
                    )
                  )
                )
              )
            )
          )
        )
      )
    )
  )
) {
}
const ParamsConfig = new MeshStandardBuilderMatParamsConfig();
class MeshStandardBuilderMatNode extends _BaseBuilder__WEBPACK_IMPORTED_MODULE_5__/* .TypedBuilderMatNode */ .T {
  constructor() {
    super(...arguments);
    this.paramsConfig = ParamsConfig;
    this.controllers = {
      advancedCommon: new _utils_AdvancedCommonController__WEBPACK_IMPORTED_MODULE_4__/* .AdvancedCommonController */ .h(this),
      alphaMap: new _utils_TextureAlphaMapController__WEBPACK_IMPORTED_MODULE_15__/* .TextureAlphaMapController */ .s(this),
      aoMap: new _utils_TextureAOMapController__WEBPACK_IMPORTED_MODULE_14__/* .TextureAOMapController */ .Z(this),
      bumpMap: new _utils_TextureBumpMapController__WEBPACK_IMPORTED_MODULE_13__/* .TextureBumpMapController */ .T(this),
      displacementMap: new _utils_TextureDisplacementMapController__WEBPACK_IMPORTED_MODULE_12__/* .TextureDisplacementMapController */ .u(this),
      emissiveMap: new _utils_TextureEmissiveMapController__WEBPACK_IMPORTED_MODULE_11__/* .TextureEmissiveMapController */ .z(this),
      envMap: new _utils_TextureEnvMapController__WEBPACK_IMPORTED_MODULE_10__/* .TextureEnvMapController */ .nz(this),
      lightMap: new _utils_TextureLightMapController__WEBPACK_IMPORTED_MODULE_9__/* .TextureLightMapController */ .$(this),
      map: new _utils_TextureMapController__WEBPACK_IMPORTED_MODULE_16__/* .TextureMapController */ .g(this),
      metalnessRoughnessMap: new _utils_TextureMetalnessRoughnessMapController__WEBPACK_IMPORTED_MODULE_7__/* .TextureMetalnessRoughnessMapController */ .Ae(this),
      normalMap: new _utils_TextureNormalMapController__WEBPACK_IMPORTED_MODULE_8__/* .TextureNormalMapController */ .w(this),
      PCSS: new _utils_PCSSController__WEBPACK_IMPORTED_MODULE_1__/* .PCSSController */ .P(this),
      uniformFog: new _utils_UniformsFogController__WEBPACK_IMPORTED_MODULE_2__/* .UniformFogController */ .z(this),
      uniformTransparency: new _utils_UniformsTransparencyController__WEBPACK_IMPORTED_MODULE_18__/* .UniformsTransparencyController */ .N(this),
      wireframeShader: new _utils_WireframeShaderMaterialController__WEBPACK_IMPORTED_MODULE_3__/* .WireframeShaderMaterialController */ .w(this)
    };
    this.controllersList = Object.values(this.controllers);
  }
  static type() {
    return _poly_registers_nodes_types_Mat__WEBPACK_IMPORTED_MODULE_21__/* .MatType.MESH_STANDARD_BUILDER */ .M.MESH_STANDARD_BUILDER;
  }
  usedAssembler() {
    return _poly_registers_assemblers_BaseRegister__WEBPACK_IMPORTED_MODULE_22__/* .AssemblerName.GL_MESH_STANDARD */ .Q.GL_MESH_STANDARD;
  }
  _createAssemblerController() {
    return _Poly__WEBPACK_IMPORTED_MODULE_23__/* .Poly.assemblersRegister.assembler */ .L.assemblersRegister.assembler(this, this.usedAssembler());
  }
  customMaterialRequested(customName) {
    return (0,_utils_customMaterials_CustomMaterialMesh__WEBPACK_IMPORTED_MODULE_0__/* .materialMeshAssemblerCustomMaterialRequested */ .F)(this, customName);
  }
  cook() {
    return __async(this, null, function* () {
      this._material = this._material || this.createMaterial();
      yield Promise.all(this.controllersPromises(this._material));
      this.compileIfRequired(this._material);
      this.setMaterial(this._material);
    });
  }
}


/***/ }),

/***/ 1487:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "e": function() { return /* binding */ PostProcessNetworkMatNode; }
/* harmony export */ });
/* harmony import */ var _BaseManager__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(26642);
/* harmony import */ var _poly_NodeContext__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(52070);
/* harmony import */ var _utils_DisplayNodeController__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(35725);
/* harmony import */ var _post_utils_EffectComposerController__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(32241);





class PostProcessNetworkMatNode extends _BaseManager__WEBPACK_IMPORTED_MODULE_0__/* .BaseNetworkMatNode */ .X {
  constructor() {
    super(...arguments);
    this.paramsConfig = new _post_utils_EffectComposerController__WEBPACK_IMPORTED_MODULE_1__/* .PostProcessNetworkParamsConfig */ .Ab();
    this.effectsComposerController = new _post_utils_EffectComposerController__WEBPACK_IMPORTED_MODULE_1__/* .EffectComposerController */ .iy(this);
    this.displayNodeController = new _utils_DisplayNodeController__WEBPACK_IMPORTED_MODULE_2__/* .DisplayNodeController */ .v(
      this,
      this.effectsComposerController.displayNodeControllerCallbacks()
    );
    this._childrenControllerContext = _poly_NodeContext__WEBPACK_IMPORTED_MODULE_3__/* .NodeContext.POST */ .sy.POST;
  }
  static type() {
    return _poly_NodeContext__WEBPACK_IMPORTED_MODULE_3__/* .NetworkNodeType.POST */ .kX.POST;
  }
  createNode(node_class, options) {
    return super.createNode(node_class, options);
  }
  children() {
    return super.children();
  }
  nodesByType(type) {
    return super.nodesByType(type);
  }
}


/***/ }),

/***/ 26642:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "X": function() { return /* binding */ BaseNetworkMatNode; },
/* harmony export */   "t": function() { return /* binding */ ParamLessBaseNetworkMatNode; }
/* harmony export */ });
/* harmony import */ var _poly_NodeContext__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(52070);
/* harmony import */ var _Base__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(74386);




class ParamLessNetworkMatParamsConfig extends (/* unused pure expression or super */ null && (NodeParamsConfig)) {
}
class BaseNetworkMatNode extends _Base__WEBPACK_IMPORTED_MODULE_0__/* .TypedNode */ .Mv {
  static context() {
    return _poly_NodeContext__WEBPACK_IMPORTED_MODULE_1__/* .NodeContext.MAT */ .sy.MAT;
  }
  cook() {
    this.cookController.endCook();
  }
}
class ParamLessBaseNetworkMatNode extends BaseNetworkMatNode {
}


/***/ }),

/***/ 8745:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {


// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  "P": function() { return /* binding */ PCSSController; },
  "y": function() { return /* binding */ PCSSParamConfig; }
});

// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/nodes/mat/utils/_BaseController.ts
var _BaseController = __webpack_require__(4418);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/nodes/utils/params/ParamsConfig.ts
var ParamsConfig = __webpack_require__(96949);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/core/Type.ts
var Type = __webpack_require__(19037);
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/mat/utils/shadows/pcss/glsl/PCSS.glsl
/* harmony default export */ var PCSS = ("#define LIGHT_WORLD_SIZE 0.005\n// #define LIGHT_FRUSTUM_WIDTH 1.0\n// #define PCSS_FILTER_SIZE 1.0\n#define LIGHT_SIZE_UV (PCSS_FILTER_SIZE * LIGHT_WORLD_SIZE)\n#define NEAR_PLANE 9.5\n\n#define NUM_SAMPLES 17\n#define NUM_RINGS 11\n#define BLOCKER_SEARCH_NUM_SAMPLES NUM_SAMPLES\n\nvec2 poissonDisk[NUM_SAMPLES];\n\nvoid initPoissonSamples( const in vec2 randomSeed ) {\n\tfloat ANGLE_STEP = PI2 * float( NUM_RINGS ) / float( NUM_SAMPLES );\n\tfloat INV_NUM_SAMPLES = 1.0 / float( NUM_SAMPLES );\n\n\t// jsfiddle that shows sample pattern: https://jsfiddle.net/a16ff1p7/\n\tfloat angle = rand( randomSeed ) * PI2;\n\tfloat radius = INV_NUM_SAMPLES;\n\tfloat radiusStep = radius;\n\n\tfor( int i = 0; i < NUM_SAMPLES; i ++ ) {\n\t\tpoissonDisk[i] = vec2( cos( angle ), sin( angle ) ) * pow( radius, 0.75 );\n\t\tradius += radiusStep;\n\t\tangle += ANGLE_STEP;\n\t}\n}\n\nfloat penumbraSize( const in float zReceiver, const in float zBlocker ) { // Parallel plane estimation\n\treturn (zReceiver - zBlocker) / zBlocker;\n}\n\nfloat findBlocker( sampler2D shadowMap, const in vec2 uv, const in float zReceiver ) {\n\t// This uses similar triangles to compute what\n\t// area of the shadow map we should search\n\tfloat searchRadius = LIGHT_SIZE_UV * ( zReceiver - NEAR_PLANE ) / zReceiver;\n\tfloat blockerDepthSum = 0.0;\n\tint numBlockers = 0;\n\n\tfor( int i = 0; i < BLOCKER_SEARCH_NUM_SAMPLES; i++ ) {\n\t\tfloat shadowMapDepth = unpackRGBAToDepth(texture2D(shadowMap, uv + poissonDisk[i] * searchRadius));\n\t\tif ( shadowMapDepth < zReceiver ) {\n\t\t\tblockerDepthSum += shadowMapDepth;\n\t\t\tnumBlockers ++;\n\t\t}\n\t}\n\n\tif( numBlockers == 0 ) return -1.0;\n\n\treturn blockerDepthSum / float( numBlockers );\n}\n\nfloat PCF_Filter(sampler2D shadowMap, vec2 uv, float zReceiver, float filterRadius ) {\n\tfloat sum = 0.0;\n\tfloat depth;\n\t#pragma unroll_loop_start\n\tfor( int i = 0; i < 17; i ++ ) {\n\t\tdepth = unpackRGBAToDepth( texture2D( shadowMap, uv + poissonDisk[ i ] * filterRadius ) );\n\t\tif( zReceiver <= depth ) sum += 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#pragma unroll_loop_start\n\tfor( int i = 0; i < 17; i ++ ) {\n\t\tdepth = unpackRGBAToDepth( texture2D( shadowMap, uv + -poissonDisk[ i ].yx * filterRadius ) );\n\t\tif( zReceiver <= depth ) sum += 1.0;\n\t}\n\t#pragma unroll_loop_end\n\treturn sum / ( 2.0 * float( 17 ) );\n}\n\nfloat PCSS ( sampler2D shadowMap, vec4 coords ) {\n\tvec2 uv = coords.xy;\n\tfloat zReceiver = coords.z; // Assumed to be eye-space z in this code\n\n\tinitPoissonSamples( uv );\n\t// STEP 1: blocker search\n\tfloat avgBlockerDepth = findBlocker( shadowMap, uv, zReceiver );\n\n\t//There are no occluders so early out (this saves filtering)\n\tif( avgBlockerDepth == -1.0 ) return 1.0;\n\n\t// STEP 2: penumbra size\n\tfloat penumbraRatio = penumbraSize( zReceiver, avgBlockerDepth );\n\tfloat filterRadius = penumbraRatio * LIGHT_SIZE_UV * NEAR_PLANE / zReceiver;\n\n\t// STEP 3: filtering\n\t//return avgBlockerDepth;\n\treturn PCF_Filter( shadowMap, uv, zReceiver, filterRadius );\n}");
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/mat/utils/shadows/pcss/glsl/PCSSGetShadow.glsl
/* harmony default export */ var PCSSGetShadow = ("return PCSS( shadowMap, shadowCoord );");
// EXTERNAL MODULE: ../@polygonjs/polygonjs/node_modules/three/src/renderers/shaders/ShaderChunk/shadowmap_pars_fragment.glsl.js
var shadowmap_pars_fragment_glsl = __webpack_require__(45660);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/core/ThreeToGl.ts
var ThreeToGl = __webpack_require__(81556);
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/mat/utils/PCSSController.ts

var __async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};








function PCSSParamConfig(Base) {
  return class Mixin extends Base {
    constructor() {
      super(...arguments);
      /** @param if on, the material will blur shadows cast on this object. Note that you should adjust the near parameter of the light shadow to get the result visible */
      this.shadowPCSS = ParamsConfig/* ParamConfig.BOOLEAN */.XC.BOOLEAN(0, {
        callback: (node) => {
          PCSSController.PARAM_CALLBACK_setRecompileRequired(node);
        },
        separatorBefore: true
      });
      /** @param shadowPCSSFilterSize PCSS Shadow filter size */
      this.shadowPCSSFilterSize = ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(1, {
        visibleIf: { shadowPCSS: 1 },
        range: [0, 10],
        rangeLocked: [true, false]
      });
    }
  };
}
class PCSSParamsConfig extends PCSSParamConfig(ParamsConfig/* NodeParamsConfig */.yI) {
}
function isValidMaterial(material) {
  if (!material) {
    return false;
  }
  return true;
}
class PCSSMapMatNode extends (/* unused pure expression or super */ null && (TypedMatNode)) {
  material() {
    return __async(this, null, function* () {
      const container = yield this.compute();
      return container.material();
    });
  }
}
class PCSSController extends _BaseController/* BaseController */.x {
  constructor(node) {
    super(node);
    this.node = node;
  }
  static filterFragmentShader(node, fragmentShader) {
    const PCSSWithDefines = `
#define PCSS_FILTER_SIZE ${ThreeToGl/* ThreeToGl.float */._.float(node.pv.shadowPCSSFilterSize)}
${PCSS}
`;
    let shadowParsFragmentModified = shadowmap_pars_fragment_glsl/* default */.Z;
    shadowParsFragmentModified = shadowParsFragmentModified.replace(
      "#ifdef USE_SHADOWMAP",
      `#ifdef USE_SHADOWMAP
${PCSSWithDefines}
				`
    );
    shadowParsFragmentModified = shadowParsFragmentModified.replace(
      "#if defined( SHADOWMAP_TYPE_PCF )",
      `
				${PCSSGetShadow}
				#if defined( SHADOWMAP_TYPE_PCF )`
    );
    fragmentShader = fragmentShader.replace("#include <shadowmap_pars_fragment>", shadowParsFragmentModified);
    return fragmentShader;
  }
  static update(node) {
    return __async(this, null, function* () {
      const material = yield node.material();
      if (!isValidMaterial(material)) {
        return;
      }
      node.controllers.PCSS.updateMaterial(material);
    });
  }
  update() {
    return __async(this, null, function* () {
      PCSSController.update(this.node);
    });
  }
  updateMaterial(material) {
    var _a, _b;
    const matNode = this.node;
    if (!matNode.assemblerController) {
      return;
    }
    const callbackName = "PCSS";
    if ((0,Type/* isBooleanTrue */.bI)(this.node.pv.shadowPCSS)) {
      (_a = matNode.assemblerController()) == null ? void 0 : _a.addFilterFragmentShaderCallback(
        callbackName,
        (fragmentShader) => PCSSController.filterFragmentShader(this.node, fragmentShader)
      );
    } else {
      (_b = matNode.assemblerController()) == null ? void 0 : _b.removeFilterFragmentShaderCallback(callbackName);
    }
  }
  // static async update(node: PCSSMapMatNode) {
  // 	node.controllers.PCSS.update();
  // }
  static PARAM_CALLBACK_setRecompileRequired(node) {
    node.controllers.PCSS.update();
  }
}


/***/ }),

/***/ 92874:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "B": function() { return /* binding */ CustomMaterialMeshParamConfig; },
/* harmony export */   "F": function() { return /* binding */ materialMeshAssemblerCustomMaterialRequested; }
/* harmony export */ });
/* harmony import */ var _poly_Assert__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(68239);
/* harmony import */ var _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(96949);
/* harmony import */ var _core_geometry_Material__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(62026);
/* harmony import */ var _BaseBuilder__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(88303);
/* harmony import */ var _core_Type__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(19037);
/* harmony import */ var _CustomMaterialBase__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(11803);

var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));








function CustomMaterialMeshParamConfig(Base) {
  return class Mixin extends Base {
    constructor() {
      super(...arguments);
      /** @param toggle on to choose which customMaterials will be generated */
      this.overrideCustomMaterials = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_0__/* .ParamConfig.BOOLEAN */ .XC.BOOLEAN(0, __spreadProps(__spreadValues({}, _CustomMaterialBase__WEBPACK_IMPORTED_MODULE_1__/* .CUSTOM_MAT_PARAM_OPTIONS */ .z), {
        separatorBefore: true,
        separatorAfter: true
      }));
      /** @param distance material used for shadows from points lights */
      this.createCustomMatDistance = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_0__/* .ParamConfig.BOOLEAN */ .XC.BOOLEAN(1, __spreadValues({
        visibleIf: { overrideCustomMaterials: 1 }
      }, _CustomMaterialBase__WEBPACK_IMPORTED_MODULE_1__/* .CUSTOM_MAT_PARAM_OPTIONS */ .z));
      /** @param depth material used for shadows from spot lights and directional lights */
      this.createCustomMatDepth = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_0__/* .ParamConfig.BOOLEAN */ .XC.BOOLEAN(1, __spreadValues({
        visibleIf: { overrideCustomMaterials: 1 }
      }, _CustomMaterialBase__WEBPACK_IMPORTED_MODULE_1__/* .CUSTOM_MAT_PARAM_OPTIONS */ .z));
      /** @param depth DOF */
      this.createCustomMatDepthDOF = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_0__/* .ParamConfig.BOOLEAN */ .XC.BOOLEAN(1, __spreadProps(__spreadValues({
        visibleIf: { overrideCustomMaterials: 1 }
      }, _CustomMaterialBase__WEBPACK_IMPORTED_MODULE_1__/* .CUSTOM_MAT_PARAM_OPTIONS */ .z), {
        separatorAfter: true
      }));
    }
  };
}
class CustomMaterialMeshParamsConfig extends CustomMaterialMeshParamConfig((0,_BaseBuilder__WEBPACK_IMPORTED_MODULE_2__/* .BaseBuilderParamConfig */ .I)(_utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_0__/* .NodeParamsConfig */ .yI)) {
}
class CustomMaterialMatNode extends (/* unused pure expression or super */ null && (TypedMatNode)) {
}
function materialMeshAssemblerCustomMaterialRequested(node, customName) {
  const param = node.p.overrideCustomMaterials;
  if (!param) {
    console.warn(`param overrideCustomMaterials not found on ${node.path()}, creating all customMaterials`);
    return true;
  }
  if (!(0,_core_Type__WEBPACK_IMPORTED_MODULE_3__/* .isBooleanTrue */ .bI)(node.pv.overrideCustomMaterials)) {
    return true;
  }
  switch (customName) {
    case _core_geometry_Material__WEBPACK_IMPORTED_MODULE_4__/* .CustomMaterialName.DISTANCE */ .RJ.DISTANCE: {
      return (0,_core_Type__WEBPACK_IMPORTED_MODULE_3__/* .isBooleanTrue */ .bI)(node.pv.createCustomMatDistance);
    }
    case _core_geometry_Material__WEBPACK_IMPORTED_MODULE_4__/* .CustomMaterialName.DEPTH */ .RJ.DEPTH: {
      return (0,_core_Type__WEBPACK_IMPORTED_MODULE_3__/* .isBooleanTrue */ .bI)(node.pv.createCustomMatDepth);
    }
    case _core_geometry_Material__WEBPACK_IMPORTED_MODULE_4__/* .CustomMaterialName.DEPTH_DOF */ .RJ.DEPTH_DOF: {
      return (0,_core_Type__WEBPACK_IMPORTED_MODULE_3__/* .isBooleanTrue */ .bI)(node.pv.createCustomMatDepthDOF);
    }
  }
  _poly_Assert__WEBPACK_IMPORTED_MODULE_5__/* .TypeAssert.unreachable */ .f.unreachable(customName);
}


/***/ }),

/***/ 83409:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "D": function() { return /* binding */ AmbientLightObjNode; }
/* harmony export */ });
/* harmony import */ var _BaseLight__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(88336);
/* harmony import */ var _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(96949);
/* harmony import */ var _core_lights_AmbientLight__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(23276);
/* harmony import */ var _operations_sop_AmbientLight__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(82040);





class AmbientLightObjParamsConfig extends (0,_core_lights_AmbientLight__WEBPACK_IMPORTED_MODULE_0__/* .AmbientLightParamConfig */ .j)(_utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .NodeParamsConfig */ .yI) {
}
const ParamsConfig = new AmbientLightObjParamsConfig();
class AmbientLightObjNode extends _BaseLight__WEBPACK_IMPORTED_MODULE_2__/* .TypedLightObjNode */ .i {
  constructor() {
    super(...arguments);
    this.paramsConfig = ParamsConfig;
  }
  static type() {
    return "ambientLight";
  }
  initializeNode() {
    this.io.inputs.setCount(0, 1);
  }
  _operation() {
    return this.__operation__ = this.__operation__ || new _operations_sop_AmbientLight__WEBPACK_IMPORTED_MODULE_3__/* .AmbientLightSopOperation */ .j(this._scene, this.states, this);
  }
  createLight() {
    return this._operation().createLight();
  }
  updateLightParams() {
    this._operation().updateLightParams(this.light, this.pv);
  }
}


/***/ }),

/***/ 31787:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "$": function() { return /* binding */ AreaLightObjNode; }
/* harmony export */ });
/* harmony import */ var _BaseLightTransformed__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(78914);
/* harmony import */ var _utils_TransformController__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(87498);
/* harmony import */ var _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(96949);
/* harmony import */ var _core_lights_AreaLight__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(72862);
/* harmony import */ var _operations_sop_AreaLight__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(54112);
/* harmony import */ var _core_Type__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(19037);
/* harmony import */ var _poly_registers_nodes_types_Light__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(18244);








class AreaLightObjParamsConfig extends (0,_core_lights_AreaLight__WEBPACK_IMPORTED_MODULE_0__/* .AreaLightParamConfig */ .fP)((0,_utils_TransformController__WEBPACK_IMPORTED_MODULE_1__/* .TransformedParamConfig */ .s7)(_utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_2__/* .NodeParamsConfig */ .yI)) {
}
const ParamsConfig = new AreaLightObjParamsConfig();
class AreaLightObjNode extends _BaseLightTransformed__WEBPACK_IMPORTED_MODULE_3__/* .BaseLightTransformedObjNode */ .W {
  constructor() {
    super(...arguments);
    this.paramsConfig = ParamsConfig;
  }
  static type() {
    return _poly_registers_nodes_types_Light__WEBPACK_IMPORTED_MODULE_4__/* .LightType.AREA */ .v.AREA;
  }
  _operation() {
    return this.__operation__ = this.__operation__ || new _operations_sop_AreaLight__WEBPACK_IMPORTED_MODULE_5__/* .AreaLightSopOperation */ .X(this._scene, this.states, this);
  }
  createLight() {
    return this._operation().createLight();
  }
  updateLightParams() {
    this._operation().updateLightParams(this.light, this.pv);
    if ((0,_core_Type__WEBPACK_IMPORTED_MODULE_6__/* .isBooleanTrue */ .bI)(this.pv.showHelper)) {
      this._helper = this._helper || new _core_lights_AreaLight__WEBPACK_IMPORTED_MODULE_0__/* .CoreRectAreaLightHelper */ .x1(this.light, this.name());
      this.light.add(this._helper);
      this._helper.update();
    } else {
      if (this._helper) {
        this.light.remove(this._helper);
      }
    }
  }
}


/***/ }),

/***/ 88012:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {


// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  "C": function() { return /* binding */ AudioListenerObjNode; }
});

// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/nodes/obj/_Base.ts
var _Base = __webpack_require__(48803);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/nodes/obj/utils/TransformController.ts
var TransformController = __webpack_require__(87498);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/nodes/utils/FlagsController.ts + 4 modules
var FlagsController = __webpack_require__(162);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/nodes/utils/params/ParamsConfig.ts
var ParamsConfig = __webpack_require__(96949);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/nodes/obj/utils/HierarchyController.ts
var HierarchyController = __webpack_require__(70848);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/poly/registers/nodes/types/Obj.ts
var Obj = __webpack_require__(71501);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/core/Type.ts
var Type = __webpack_require__(19037);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/node_modules/three/build/three.module.js
var three_module = __webpack_require__(21410);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/node_modules/tone/build/esm/core/context/Listener.js
var Listener = __webpack_require__(35033);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/node_modules/tone/build/esm/core/context/Gain.js
var Gain = __webpack_require__(79990);
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/core/audio/AudioListener.ts

var __async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};






const _position = new three_module.Vector3();
const _quaternion = new three_module.Quaternion();
const _scale = new three_module.Vector3();
const _orientation = new three_module.Vector3();
class CoreAudioListener extends three_module.Object3D {
  constructor() {
    super();
    this.timeDelta = 0;
    this._clock = new three_module.Clock();
    this.listenerTransformAutoUpdate = true;
    const listener = new Listener/* Listener */.Y();
    this.context = listener.context.rawContext;
    this.gain = new Gain/* Gain */.S();
    this.gain.connect(this.context.destination);
  }
  addInput(positionalAudioNode) {
    return __async(this, null, function* () {
      positionalAudioNode.connect(this.gain);
    });
  }
  dispose() {
    this.setMasterVolume(0);
    this.gain.disconnect();
  }
  // removeFilter() {
  // 	if (this.filter !== null) {
  // 		this.gain.disconnect(this.filter);
  // 		this.filter.disconnect(this.context.destination);
  // 		this.gain.connect(this.context.destination);
  // 		this.filter = null;
  // 	}
  // 	return this;
  // }
  // getFilter() {
  // 	return this.filter;
  // }
  // setFilter(value) {
  // 	if (this.filter !== null) {
  // 		this.gain.disconnect(this.filter);
  // 		this.filter.disconnect(this.context.destination);
  // 	} else {
  // 		this.gain.disconnect(this.context.destination);
  // 	}
  // 	this.filter = value;
  // 	this.gain.connect(this.filter);
  // 	this.filter.connect(this.context.destination);
  // 	return this;
  // }
  // getMasterVolume() {
  // 	return this.gain.gain.value;
  // }
  setMasterVolume(value) {
    this.gain.gain.setTargetAtTime(value, this.context.currentTime, 0.01);
    return this;
  }
  masterVolume() {
    return this.gain.gain.value;
  }
  updateMatrixWorld(force) {
    super.updateMatrixWorld(force);
    if (!this.listenerTransformAutoUpdate) {
      return;
    }
    const listener = this.context.listener;
    const up = this.up;
    this.timeDelta = this._clock.getDelta();
    this.matrixWorld.decompose(_position, _quaternion, _scale);
    _orientation.set(0, 0, -1).applyQuaternion(_quaternion);
    if (listener.positionX) {
      const endTime = this.context.currentTime + this.timeDelta;
      listener.positionX.linearRampToValueAtTime(_position.x, endTime);
      listener.positionY.linearRampToValueAtTime(_position.y, endTime);
      listener.positionZ.linearRampToValueAtTime(_position.z, endTime);
      listener.forwardX.linearRampToValueAtTime(_orientation.x, endTime);
      listener.forwardY.linearRampToValueAtTime(_orientation.y, endTime);
      listener.forwardZ.linearRampToValueAtTime(_orientation.z, endTime);
      listener.upX.linearRampToValueAtTime(up.x, endTime);
      listener.upY.linearRampToValueAtTime(up.y, endTime);
      listener.upZ.linearRampToValueAtTime(up.z, endTime);
    } else {
      listener.setPosition(_position.x, _position.y, _position.z);
      listener.setOrientation(_orientation.x, _orientation.y, _orientation.z, up.x, up.y, up.z);
    }
  }
}

// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/core/audio/AudioController.ts
var AudioController = __webpack_require__(71506);
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/obj/AudioListener.ts

var AudioListener_async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};









class AudioListenerParamConfig extends (0,TransformController/* TransformedParamConfig */.s7)(ParamsConfig/* NodeParamsConfig */.yI) {
  constructor() {
    super(...arguments);
    this.audio = ParamsConfig/* ParamConfig.FOLDER */.XC.FOLDER();
    /** @param soundOn */
    this.soundOn = ParamsConfig/* ParamConfig.BOOLEAN */.XC.BOOLEAN(1, {
      cook: false,
      callback: (node) => {
        AudioListenerObjNode.PARAM_CALLBACK_update(node);
      }
    });
    /** @param volume */
    this.masterVolume = ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(1, {
      range: [0, 1],
      rangeLocked: [true, false]
    });
    /** @param ensures the transform of the audio listener is updated on very frame */
    this.listenerTransformAutoUpdate = ParamsConfig/* ParamConfig.BOOLEAN */.XC.BOOLEAN(1);
  }
}
const AudioListener_ParamsConfig = new AudioListenerParamConfig();
const _AudioListenerObjNode = class extends _Base/* TypedObjNode */.Mx {
  constructor() {
    super(...arguments);
    this.paramsConfig = AudioListener_ParamsConfig;
    this.hierarchyController = new HierarchyController/* HierarchyController */.O(this);
    this.transformController = new TransformController/* TransformController */.hJ(this);
    this.flags = new FlagsController/* FlagsControllerD */.ZR(this);
    this._boundEvents = {
      pointerdown: this._onpointerdown.bind(this),
      keypress: this._onkeypress.bind(this)
    };
  }
  static type() {
    return Obj/* ObjType.AUDIO_LISTENER */.B.AUDIO_LISTENER;
  }
  createObject() {
    const object = new CoreAudioListener();
    object.matrixAutoUpdate = false;
    return object;
  }
  initializeNode() {
    this.hierarchyController.initializeNode();
    this.transformController.initializeNode();
    this.lifecycle.onAfterAdded(() => {
      this._setPositionalAudioNodesDirty();
      this.addAudioActivationEvents();
      this.root().audioController.update();
    });
  }
  dispose() {
    super.dispose();
    this.object.dispose();
    this._setPositionalAudioNodesDirty();
    this.root().audioController.update();
  }
  toggleSound() {
    this.p.soundOn.set(!(0,Type/* isBooleanTrue */.bI)(this.pv.soundOn));
  }
  _setPositionalAudioNodesDirty() {
    this.root().nodesByType("positionalAudio").forEach((n) => n.setDirty());
  }
  cook() {
    this.transformController.update();
    this._validateUniq();
    this._updateListenerAndViewers();
    this.cookController.endCook();
  }
  _validateUniq() {
    const existingListeners = this.root().audioController.audioListeners();
    if (existingListeners.length > 1) {
      this.states.error.set("only 1 audioListener can exist in a scene");
    }
  }
  _updateAudioListener() {
    const volume = (0,Type/* isBooleanTrue */.bI)(this.pv.soundOn) ? this.pv.masterVolume : 0;
    this.object.setMasterVolume(volume);
    this.object.listenerTransformAutoUpdate = (0,Type/* isBooleanTrue */.bI)(this.pv.listenerTransformAutoUpdate);
  }
  _updateViewers() {
    this.root().audioController.update();
  }
  _updateListenerAndViewers() {
    this._updateAudioListener();
    this._updateViewers();
  }
  static PARAM_CALLBACK_update(node) {
    node._updateListenerAndViewers();
  }
  _onpointerdown(event) {
    return AudioListener_async(this, null, function* () {
      yield this.activateSound();
    });
  }
  _onkeypress(event) {
    return AudioListener_async(this, null, function* () {
      yield this.activateSound();
    });
  }
  static soundActivated() {
    return this._audioActivated;
  }
  soundActivated() {
    return _AudioListenerObjNode.soundActivated();
  }
  activateSound() {
    return AudioListener_async(this, null, function* () {
      if (!this.soundActivated()) {
        yield AudioController/* AudioController.start */.e.start();
        _AudioListenerObjNode._audioActivated = true;
      }
      this._removeAudioActivationEvents();
    });
  }
  addAudioActivationEvents() {
    if (this.soundActivated()) {
      return;
    }
    if (_AudioListenerObjNode._eventsAdded) {
      return;
    }
    _AudioListenerObjNode._eventsAdded = true;
    document.body.addEventListener("pointerdown", this._boundEvents.pointerdown);
    document.body.addEventListener("keypress", this._boundEvents.keypress);
  }
  _removeAudioActivationEvents() {
    document.body.removeEventListener("pointerdown", this._boundEvents.pointerdown);
    document.body.removeEventListener("keypress", this._boundEvents.keypress);
  }
};
let AudioListenerObjNode = _AudioListenerObjNode;
/*

	EVENTS TO ACTIVATE SOUND

	*/
AudioListenerObjNode._eventsAdded = false;
AudioListenerObjNode._audioActivated = false;


/***/ }),

/***/ 64303:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "g": function() { return /* binding */ DirectionalLightObjNode; }
/* harmony export */ });
/* harmony import */ var _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(96949);
/* harmony import */ var _BaseLightTransformed__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(78914);
/* harmony import */ var _utils_TransformController__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(87498);
/* harmony import */ var _poly_registers_nodes_types_Light__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(18244);
/* harmony import */ var _core_lights_DirectionalLight__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(12948);
/* harmony import */ var _operations_sop_DirectionalLight__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(13916);







class DirectionalLightObjParamsConfig extends (0,_core_lights_DirectionalLight__WEBPACK_IMPORTED_MODULE_0__/* .DirectionalLightParamConfig */ .Tr)((0,_utils_TransformController__WEBPACK_IMPORTED_MODULE_1__/* .TransformedParamConfig */ .s7)(_utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_2__/* .NodeParamsConfig */ .yI)) {
}
const ParamsConfig = new DirectionalLightObjParamsConfig();
class DirectionalLightObjNode extends _BaseLightTransformed__WEBPACK_IMPORTED_MODULE_3__/* .BaseLightTransformedObjNode */ .W {
  constructor() {
    super(...arguments);
    this.paramsConfig = ParamsConfig;
  }
  static type() {
    return _poly_registers_nodes_types_Light__WEBPACK_IMPORTED_MODULE_4__/* .LightType.DIRECTIONAL */ .v.DIRECTIONAL;
  }
  _operation() {
    return this.__operation__ = this.__operation__ || new _operations_sop_DirectionalLight__WEBPACK_IMPORTED_MODULE_5__/* .DirectionalLightSopOperation */ .n(this._scene, this.states, this);
  }
  createLight() {
    return this._operation().createLight({ showHelper: this.pv.showHelper });
  }
  updateLightParams() {
    this._operation().updateLightParams(this.light, this.pv);
  }
  updateShadowParams() {
    this.light.showHelper = this.pv.showHelper;
    this._operation().updateShadowParams(this.light, this.pv);
  }
}


/***/ }),

/***/ 98971:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "f": function() { return /* binding */ HemisphereLightObjNode; }
/* harmony export */ });
/* harmony import */ var _BaseLight__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(88336);
/* harmony import */ var _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(96949);
/* harmony import */ var _poly_registers_nodes_types_Light__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(18244);
/* harmony import */ var _core_lights_HemisphereLight__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(98821);
/* harmony import */ var _operations_sop_HemisphereLight__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(57426);






class HemisphereLightObjParamsConfig extends (0,_core_lights_HemisphereLight__WEBPACK_IMPORTED_MODULE_0__/* .HemisphereLightParamConfig */ .A)(_utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .NodeParamsConfig */ .yI) {
}
const ParamsConfig = new HemisphereLightObjParamsConfig();
class HemisphereLightObjNode extends _BaseLight__WEBPACK_IMPORTED_MODULE_2__/* .TypedLightObjNode */ .i {
  constructor() {
    super(...arguments);
    this.paramsConfig = ParamsConfig;
  }
  static type() {
    return _poly_registers_nodes_types_Light__WEBPACK_IMPORTED_MODULE_3__/* .LightType.HEMISPHERE */ .v.HEMISPHERE;
  }
  _operation() {
    return this.__operation__ = this.__operation__ || new _operations_sop_HemisphereLight__WEBPACK_IMPORTED_MODULE_4__/* .HemisphereLightSopOperation */ .c(this._scene, this.states, this);
  }
  createLight() {
    return this._operation().createLight();
  }
  updateLightParams() {
    this._operation().updateLightParams(this.light, this.pv);
  }
}


/***/ }),

/***/ 56701:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {


// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  "b": function() { return /* binding */ PointLightObjNode; }
});

// EXTERNAL MODULE: ../@polygonjs/polygonjs/node_modules/three/build/three.module.js
var three_module = __webpack_require__(21410);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/nodes/utils/params/ParamsConfig.ts
var ParamsConfig = __webpack_require__(96949);
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/obj/utils/helpers/_BaseLightHelper.ts





function BaseLightHelperParamConfig(Base) {
  return class Mixin extends Base {
    constructor() {
      super(...arguments);
      this.showHelper = ParamsConfig/* ParamConfig.BOOLEAN */.XC.BOOLEAN(0);
    }
  };
}
class BaseLightHelperParamsConfig extends BaseLightHelperParamConfig(ParamsConfig/* NodeParamsConfig */.yI) {
}
class BaseLightHelperObjNode extends (/* unused pure expression or super */ null && (TypedObjNode)) {
  constructor() {
    super(...arguments);
    this.flags = new FlagsControllerD(this);
  }
}
class BaseLightHelper {
  constructor(node, _name) {
    this.node = node;
    this._name = _name;
    this._object = this.createObject();
    this._material = new three_module.MeshBasicMaterial({ wireframe: true, fog: false });
  }
  build() {
    this._object.matrixAutoUpdate = false;
    this._object.name = this._name;
    this.buildHelper();
  }
  get object() {
    return this._object;
  }
}

// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/core/lights/PointLight.ts + 1 modules
var PointLight = __webpack_require__(35031);
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/obj/utils/helpers/PointLightHelper.ts




class PointLightHelper extends BaseLightHelper {
  constructor() {
    super(...arguments);
    this._coreHelper = new PointLight/* CorePointLightHelper */.cg();
  }
  createObject() {
    return new three_module.Mesh();
  }
  buildHelper() {
    this._coreHelper.buildHelper(this._object);
  }
  update() {
    this._coreHelper.update(this._object, { helperSize: this.node.pv.helperSize, light: this.node.light });
  }
}

// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/nodes/obj/_BaseLightTransformed.ts
var _BaseLightTransformed = __webpack_require__(78914);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/nodes/obj/utils/TransformController.ts
var TransformController = __webpack_require__(87498);
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/obj/utils/HelperController.ts

class HelperController {
  constructor(node, _helperConstructor, _name) {
    this.node = node;
    this._helperConstructor = _helperConstructor;
    this._name = _name;
  }
  initializeNode() {
    this.node.flags.display.onUpdate(() => {
      this.update();
    });
  }
  visible() {
    return this.node.flags.display.active() && this.node.pv.showHelper;
  }
  _createHelper() {
    const helper = new this._helperConstructor(this.node, this._name);
    helper.build();
    return helper;
  }
  update() {
    if (this.visible()) {
      if (!this._helper) {
        this._helper = this._createHelper();
      }
      if (this._helper) {
        this.node.light.add(this._helper.object);
        this._helper.update();
      }
    } else {
      if (this._helper) {
        this.node.light.remove(this._helper.object);
      }
    }
  }
}

// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/poly/registers/nodes/types/Light.ts
var Light = __webpack_require__(18244);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/operations/sop/PointLight.ts
var sop_PointLight = __webpack_require__(78695);
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/obj/PointLight.ts









class PointLightObjParamsConfig extends (0,PointLight/* PointLightParamConfig */.kR)((0,TransformController/* TransformedParamConfig */.s7)(ParamsConfig/* NodeParamsConfig */.yI)) {
}
const PointLight_ParamsConfig = new PointLightObjParamsConfig();
class PointLightObjNode extends _BaseLightTransformed/* BaseLightTransformedObjNode */.W {
  constructor() {
    super(...arguments);
    this.paramsConfig = PointLight_ParamsConfig;
    this._helperController = new HelperController(
      this,
      PointLightHelper,
      "PointLightHelper"
    );
  }
  static type() {
    return Light/* LightType.POINT */.v.POINT;
  }
  initializeNode() {
    this._helperController.initializeNode();
  }
  _operation() {
    return this.__operation__ = this.__operation__ || new sop_PointLight/* PointLightSopOperation */.X(this._scene, this.states, this);
  }
  createLight() {
    return this._operation().createLight();
  }
  updateLightParams() {
    this._operation().updateLightParams(this.light, this.pv);
    this._helperController.update();
  }
  updateShadowParams() {
    this._operation().updateShadowParams(this.light, this.pv);
  }
}


/***/ }),

/***/ 31518:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "h": function() { return /* binding */ PostProcessNetworkObjNode; }
/* harmony export */ });
/* harmony import */ var _BaseManager__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(40918);
/* harmony import */ var _poly_NodeContext__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(52070);
/* harmony import */ var _utils_DisplayNodeController__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(35725);
/* harmony import */ var _post_utils_EffectComposerController__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(32241);





class PostProcessNetworkObjNode extends _BaseManager__WEBPACK_IMPORTED_MODULE_0__/* .BaseManagerObjNode */ .Y {
  constructor() {
    super(...arguments);
    this.paramsConfig = new _post_utils_EffectComposerController__WEBPACK_IMPORTED_MODULE_1__/* .PostProcessNetworkParamsConfig */ .Ab();
    this.effectsComposerController = new _post_utils_EffectComposerController__WEBPACK_IMPORTED_MODULE_1__/* .EffectComposerController */ .iy(this);
    this.displayNodeController = new _utils_DisplayNodeController__WEBPACK_IMPORTED_MODULE_2__/* .DisplayNodeController */ .v(
      this,
      this.effectsComposerController.displayNodeControllerCallbacks()
    );
    this._childrenControllerContext = _poly_NodeContext__WEBPACK_IMPORTED_MODULE_3__/* .NodeContext.POST */ .sy.POST;
  }
  static type() {
    return _poly_NodeContext__WEBPACK_IMPORTED_MODULE_3__/* .NetworkNodeType.POST */ .kX.POST;
  }
  createNode(node_class, options) {
    return super.createNode(node_class, options);
  }
  children() {
    return super.children();
  }
  nodesByType(type) {
    return super.nodesByType(type);
  }
}


/***/ }),

/***/ 92211:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "H": function() { return /* binding */ SceneObjNode; }
/* harmony export */ });
/* harmony import */ var _Base__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(48803);
/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(21410);
/* harmony import */ var _utils_HierarchyController__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(70848);
/* harmony import */ var _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(96949);
/* harmony import */ var _manager_utils_Scene_AutoUpdate__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(91205);
/* harmony import */ var _manager_utils_Scene_Background__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(1934);
/* harmony import */ var _manager_utils_Scene_Env__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(70620);
/* harmony import */ var _manager_utils_Scene_Fog__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(30898);
/* harmony import */ var _manager_utils_Scene_MaterialOverride__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(46165);
/* harmony import */ var _poly_registers_nodes_types_Obj__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(71501);

var __async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};










class SceneObjParamConfig extends (0,_manager_utils_Scene_MaterialOverride__WEBPACK_IMPORTED_MODULE_0__/* .SceneMaterialOverrideParamConfig */ .T)(
  (0,_manager_utils_Scene_Fog__WEBPACK_IMPORTED_MODULE_1__/* .SceneFogParamConfig */ .gc)((0,_manager_utils_Scene_Env__WEBPACK_IMPORTED_MODULE_2__/* .SceneEnvParamConfig */ .D)((0,_manager_utils_Scene_Background__WEBPACK_IMPORTED_MODULE_3__/* .SceneBackgroundParamConfig */ .O3)((0,_manager_utils_Scene_AutoUpdate__WEBPACK_IMPORTED_MODULE_4__/* .SceneAutoUpdateParamConfig */ .Z)(_utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_5__/* .NodeParamsConfig */ .yI))))
) {
}
const ParamsConfig = new SceneObjParamConfig();
class SceneObjNode extends _Base__WEBPACK_IMPORTED_MODULE_6__/* .TypedObjNode */ .Mx {
  constructor() {
    super(...arguments);
    this.paramsConfig = ParamsConfig;
    this.hierarchyController = new _utils_HierarchyController__WEBPACK_IMPORTED_MODULE_7__/* .HierarchyController */ .O(this);
    this._cook_main_without_inputs_when_dirty_bound = this._cook_main_without_inputs_when_dirty.bind(this);
    this.sceneAutoUpdateController = new _manager_utils_Scene_AutoUpdate__WEBPACK_IMPORTED_MODULE_4__/* .SceneAutoUpdateController */ .D(this);
    this.sceneBackgroundController = new _manager_utils_Scene_Background__WEBPACK_IMPORTED_MODULE_3__/* .SceneBackgroundController */ .Tt(this);
    this.sceneEnvController = new _manager_utils_Scene_Env__WEBPACK_IMPORTED_MODULE_2__/* .SceneEnvController */ .v(this);
    this.sceneFogController = new _manager_utils_Scene_Fog__WEBPACK_IMPORTED_MODULE_1__/* .SceneFogController */ .SJ(this);
    this.sceneMaterialOverrideController = new _manager_utils_Scene_MaterialOverride__WEBPACK_IMPORTED_MODULE_0__/* .SceneMaterialOverrideController */ .M(
      this
    );
  }
  static type() {
    return _poly_registers_nodes_types_Obj__WEBPACK_IMPORTED_MODULE_8__/* .ObjType.SCENE */ .B.SCENE;
  }
  createObject() {
    const scene = new three__WEBPACK_IMPORTED_MODULE_9__.Scene();
    scene.matrixAutoUpdate = false;
    return scene;
  }
  initializeNode() {
    this.hierarchyController.initializeNode();
    this.dirtyController.addPostDirtyHook(
      "cookMainWithoutInputsOnDirty",
      this._cook_main_without_inputs_when_dirty_bound
    );
  }
  _cook_main_without_inputs_when_dirty() {
    return __async(this, null, function* () {
      yield this.cookController.cookMainWithoutInputs();
    });
  }
  cook() {
    this.sceneAutoUpdateController.update();
    this.sceneBackgroundController.update();
    this.sceneEnvController.update();
    this.sceneFogController.update();
    this.sceneMaterialOverrideController.update();
    this.cookController.endCook();
  }
}


/***/ }),

/***/ 78166:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "c": function() { return /* binding */ SpotLightObjNode; }
/* harmony export */ });
/* harmony import */ var _BaseLightTransformed__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(78914);
/* harmony import */ var _utils_TransformController__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(87498);
/* harmony import */ var _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(96949);
/* harmony import */ var _poly_registers_nodes_types_Light__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(18244);
/* harmony import */ var _core_lights_SpotLight__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(38766);
/* harmony import */ var _operations_sop_SpotLight__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(79826);

var __async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};






class SpotLightObjParamsConfig extends (0,_core_lights_SpotLight__WEBPACK_IMPORTED_MODULE_0__/* .SpotLightParamConfig */ .vr)((0,_utils_TransformController__WEBPACK_IMPORTED_MODULE_1__/* .TransformedParamConfig */ .s7)(_utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_2__/* .NodeParamsConfig */ .yI)) {
}
const ParamsConfig = new SpotLightObjParamsConfig();
class SpotLightObjNode extends _BaseLightTransformed__WEBPACK_IMPORTED_MODULE_3__/* .BaseLightTransformedObjNode */ .W {
  constructor() {
    super(...arguments);
    this.paramsConfig = ParamsConfig;
  }
  static type() {
    return _poly_registers_nodes_types_Light__WEBPACK_IMPORTED_MODULE_4__/* .LightType.SPOT */ .v.SPOT;
  }
  _operation() {
    return this.__operation__ = this.__operation__ || new _operations_sop_SpotLight__WEBPACK_IMPORTED_MODULE_5__/* .SpotLightSopOperation */ .D(this._scene, this.states, this);
  }
  createLight() {
    return this._operation().createLight(this.pv);
  }
  updateLightParams() {
    return __async(this, null, function* () {
      yield this._operation().updateLightParams(this.light, this.pv);
    });
  }
  updateShadowParams() {
    this.light.updateParams(this.pv);
    this.light.updateHelper();
    this.light.updateVolumetric();
    this._operation().updateShadowParams(this.light, this.pv);
  }
}


/***/ }),

/***/ 88336:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "i": function() { return /* binding */ TypedLightObjNode; }
/* harmony export */ });
/* harmony import */ var _Base__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(48803);
/* harmony import */ var _utils_FlagsController__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(162);
/* harmony import */ var _core_Type__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(19037);

var __async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};



class TypedLightObjNode extends _Base__WEBPACK_IMPORTED_MODULE_0__/* .TypedObjNode */ .Mx {
  constructor() {
    super(...arguments);
    this.flags = new _utils_FlagsController__WEBPACK_IMPORTED_MODULE_1__/* .FlagsControllerD */ .ZR(this);
    this.renderOrder = _Base__WEBPACK_IMPORTED_MODULE_0__/* .ObjNodeRenderOrder.LIGHT */ .FE.LIGHT;
    this._usedInScene = true;
    // TODO: I may be able to swap those methods to param callbacks for most params
    this._cook_main_without_inputs_when_dirty_bound = this._cook_main_without_inputs_when_dirty.bind(this);
  }
  get light() {
    return this._light;
  }
  initializeBaseNode() {
    super.initializeBaseNode();
    this._light = this.createLight();
    this.object.add(this._light);
    this.flags.display.onUpdate(() => {
      this._updateLightAttachment();
    });
    this.dirtyController.addPostDirtyHook(
      "_cook_main_without_inputs_when_dirty",
      this._cook_main_without_inputs_when_dirty_bound
    );
  }
  _cook_main_without_inputs_when_dirty() {
    return __async(this, null, function* () {
      yield this.cookController.cookMainWithoutInputs();
    });
  }
  set_object_name() {
    super.set_object_name();
    if (this._light) {
      this._light.name = `${this.path()}:light`;
    }
  }
  _updateLightAttachment() {
    if (this.flags.display.active()) {
      this.object.add(this.light);
      this._cook_main_without_inputs_when_dirty();
    } else {
      this.object.remove(this.light);
    }
  }
  cook() {
    return __async(this, null, function* () {
      this.updateShadowParams();
      const result = this.updateLightParams();
      if ((0,_core_Type__WEBPACK_IMPORTED_MODULE_2__/* .isPromise */ .tI)(result)) {
        yield result;
      }
      this.cookController.endCook();
    });
  }
  updateLightParams() {
  }
  updateShadowParams() {
  }
}


/***/ }),

/***/ 78914:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "W": function() { return /* binding */ BaseLightTransformedObjNode; }
/* harmony export */ });
/* harmony import */ var _BaseLight__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(88336);
/* harmony import */ var _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(96949);
/* harmony import */ var _utils_TransformController__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(87498);
/* harmony import */ var _utils_FlagsController__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(162);
/* harmony import */ var _utils_HierarchyController__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(70848);
/* harmony import */ var _core_Type__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(19037);

var __async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};






class TransformedObjParamConfig extends (0,_utils_TransformController__WEBPACK_IMPORTED_MODULE_0__/* .TransformedParamConfig */ .s7)(_utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .NodeParamsConfig */ .yI) {
}
class BaseLightTransformedObjNode extends _BaseLight__WEBPACK_IMPORTED_MODULE_2__/* .TypedLightObjNode */ .i {
  constructor() {
    super(...arguments);
    this.flags = new _utils_FlagsController__WEBPACK_IMPORTED_MODULE_3__/* .FlagsControllerD */ .ZR(this);
    this.hierarchyController = new _utils_HierarchyController__WEBPACK_IMPORTED_MODULE_4__/* .HierarchyController */ .O(this);
    this.transformController = new _utils_TransformController__WEBPACK_IMPORTED_MODULE_0__/* .TransformController */ .hJ(this);
  }
  initializeBaseNode() {
    super.initializeBaseNode();
    this.hierarchyController.initializeNode();
    this.transformController.initializeNode();
  }
  cook() {
    return __async(this, null, function* () {
      this.transformController.update();
      this.updateShadowParams();
      const result = this.updateLightParams();
      if ((0,_core_Type__WEBPACK_IMPORTED_MODULE_5__/* .isPromise */ .tI)(result)) {
        yield result;
      }
      this.cookController.endCook();
    });
  }
}


/***/ }),

/***/ 40918:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "C": function() { return /* binding */ ParamLessBaseManagerObjNode; },
/* harmony export */   "Y": function() { return /* binding */ BaseManagerObjNode; }
/* harmony export */ });
/* harmony import */ var _Base__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(48803);
/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(21410);




class BaseManagerObjNode extends _Base__WEBPACK_IMPORTED_MODULE_0__/* .TypedObjNode */ .Mx {
  constructor() {
    super(...arguments);
    this._attachableToHierarchy = false;
  }
  createObject() {
    const group = new three__WEBPACK_IMPORTED_MODULE_1__.Group();
    group.matrixAutoUpdate = false;
    return group;
  }
  cook() {
    this.cookController.endCook();
  }
}
class ParamLessObjParamsConfig extends (/* unused pure expression or super */ null && (NodeParamsConfig)) {
}
class ParamLessBaseManagerObjNode extends BaseManagerObjNode {
}


/***/ }),

/***/ 90278:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "H": function() { return /* binding */ BloomPostNode; }
/* harmony export */ });
/* harmony import */ var _utils_SelectionController__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(89275);
/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(21410);
/* harmony import */ var _Base__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(30538);
/* harmony import */ var _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(96949);
/* harmony import */ var postprocessing__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(43109);
/* harmony import */ var _core_post_KernelSize__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(51417);
/* harmony import */ var _core_post_BlendFunction__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(45415);
/* harmony import */ var _core_Type__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(19037);

var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));








class BloomPostParamsConfig extends _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_0__/* .NodeParamsConfig */ .yI {
  constructor() {
    super(...arguments);
    /** @param defines if this node applies a bloom to the whole scene or just a selection. Note that for now, it is necessary to reload your scene when toggling this parameter */
    this.useObjectMask = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_0__/* .ParamConfig.BOOLEAN */ .XC.BOOLEAN(0, __spreadValues({}, _Base__WEBPACK_IMPORTED_MODULE_1__/* .PostParamOptions */ ._3));
    /** @param object mask of the objects that will be used for the bloom */
    this.objectsMask = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_0__/* .ParamConfig.STRING */ .XC.STRING("*bloomed*", __spreadProps(__spreadValues({}, _Base__WEBPACK_IMPORTED_MODULE_1__/* .PostParamOptions */ ._3), {
      objectMask: true,
      visibleIf: { useObjectMask: 1 }
    }));
    /** @param updates the cached objects found by objectMask  */
    this.refreshObjects = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_0__/* .ParamConfig.BUTTON */ .XC.BUTTON(null, __spreadProps(__spreadValues({}, _Base__WEBPACK_IMPORTED_MODULE_1__/* .PostParamOptions */ ._3), {
      visibleIf: { useObjectMask: 1 }
    }));
    /** @param effect strength */
    this.strength = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_0__/* .ParamConfig.FLOAT */ .XC.FLOAT(1.5, __spreadValues({
      range: [0, 3],
      rangeLocked: [true, false]
    }, _Base__WEBPACK_IMPORTED_MODULE_1__/* .PostParamOptions */ ._3));
    /** @param effect threshold */
    this.threshold = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_0__/* .ParamConfig.FLOAT */ .XC.FLOAT(1, __spreadValues({}, _Base__WEBPACK_IMPORTED_MODULE_1__/* .PostParamOptions */ ._3));
    /** @param effect scale */
    this.scale = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_0__/* .ParamConfig.FLOAT */ .XC.FLOAT(1, __spreadValues({
      range: [0, 3],
      rangeLocked: [true, false]
    }, _Base__WEBPACK_IMPORTED_MODULE_1__/* .PostParamOptions */ ._3));
    /** @param effect radius */
    // radius = ParamConfig.FLOAT(1, {
    // 	...PostParamOptions,
    // });
    /** @param kernel size */
    this.kernelSize = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_0__/* .ParamConfig.INTEGER */ .XC.INTEGER(postprocessing__WEBPACK_IMPORTED_MODULE_2__/* .KernelSize.LARGE */ .DD.LARGE, __spreadValues(__spreadValues({}, _Base__WEBPACK_IMPORTED_MODULE_1__/* .PostParamOptions */ ._3), _core_post_KernelSize__WEBPACK_IMPORTED_MODULE_3__/* .KERNEL_SIZE_MENU_OPTIONS */ .N));
    /** @param effect luminance Smoothing */
    this.luminanceSmoothing = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_0__/* .ParamConfig.FLOAT */ .XC.FLOAT(0.1, __spreadValues({}, _Base__WEBPACK_IMPORTED_MODULE_1__/* .PostParamOptions */ ._3));
    /** @param resolutionScale */
    this.resolutionScale = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_0__/* .ParamConfig.FLOAT */ .XC.FLOAT(0.5, __spreadValues({}, _Base__WEBPACK_IMPORTED_MODULE_1__/* .PostParamOptions */ ._3));
    /** @param opacity */
    this.opacity = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_0__/* .ParamConfig.FLOAT */ .XC.FLOAT(1, __spreadValues({
      range: [0, 1],
      rangeLocked: [true, false]
    }, _Base__WEBPACK_IMPORTED_MODULE_1__/* .PostParamOptions */ ._3));
    /** @param render mode */
    this.blendFunction = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_0__/* .ParamConfig.INTEGER */ .XC.INTEGER(postprocessing__WEBPACK_IMPORTED_MODULE_2__/* .BlendFunction.SCREEN */ .YQ.SCREEN, __spreadValues(__spreadValues({}, _Base__WEBPACK_IMPORTED_MODULE_1__/* .PostParamOptions */ ._3), _core_post_BlendFunction__WEBPACK_IMPORTED_MODULE_4__/* .BLEND_FUNCTION_MENU_OPTIONS */ .z));
  }
  /** @param bloom only */
  // bloomOnly = ParamConfig.BOOLEAN(0, {
  // 	...PostParamOptions,
  // });
}
const ParamsConfig = new BloomPostParamsConfig();
class BloomPostNode extends _Base__WEBPACK_IMPORTED_MODULE_1__/* .TypedPostNode */ .mN {
  constructor() {
    super(...arguments);
    this.paramsConfig = ParamsConfig;
    this._rendererSize = new three__WEBPACK_IMPORTED_MODULE_5__.Vector2();
  }
  static type() {
    return "bloom";
  }
  createPass(context) {
    context.renderer.getSize(this._rendererSize);
    const bloomEffectOptions = {
      blendFunction: postprocessing__WEBPACK_IMPORTED_MODULE_2__/* .BlendFunction.SCREEN */ .YQ.SCREEN,
      kernelSize: _core_post_KernelSize__WEBPACK_IMPORTED_MODULE_3__/* .KERNEL_SIZES */ .l[this.pv.kernelSize],
      luminanceThreshold: this.pv.threshold,
      luminanceSmoothing: this.pv.luminanceSmoothing,
      resolutionScale: this.pv.resolutionScale
      // height: 480,
    };
    const bloomEffect = (0,_core_Type__WEBPACK_IMPORTED_MODULE_6__/* .isBooleanTrue */ .bI)(this.pv.useObjectMask) ? new postprocessing__WEBPACK_IMPORTED_MODULE_2__/* .SelectiveBloomEffect */ .V$(context.scene, context.camera, bloomEffectOptions) : new postprocessing__WEBPACK_IMPORTED_MODULE_2__/* .BloomEffect */ .rk(bloomEffectOptions);
    const pass = new postprocessing__WEBPACK_IMPORTED_MODULE_2__/* .EffectPass */ .H5(context.camera, bloomEffect);
    this.updatePass(pass);
    return pass;
  }
  updatePass(pass) {
    const effect = pass.effects[0];
    effect.blendMode.opacity.value = this.pv.opacity;
    effect.blendMode.blendFunction = this.pv.blendFunction;
    effect.intensity = this.pv.strength;
    effect.luminanceMaterial.threshold = this.pv.threshold;
    effect.luminanceMaterial.smoothing = this.pv.luminanceSmoothing;
    effect.blurPass.blurMaterial.kernelSize = _core_post_KernelSize__WEBPACK_IMPORTED_MODULE_3__/* .KERNEL_SIZES */ .l[this.pv.kernelSize];
    effect.blurPass.resolution.scale = this.pv.resolutionScale;
    effect.blurPass.scale = this.pv.scale;
    this._setSelectedObjects(effect);
  }
  _selectionController() {
    return this.__selectionController = this.__selectionController || new _utils_SelectionController__WEBPACK_IMPORTED_MODULE_7__/* .SelectionController */ .x();
  }
  _setSelectedObjects(effect) {
    if (effect instanceof postprocessing__WEBPACK_IMPORTED_MODULE_2__/* .SelectiveBloomEffect */ .V$ && (0,_core_Type__WEBPACK_IMPORTED_MODULE_6__/* .isBooleanTrue */ .bI)(this.pv.useObjectMask)) {
      this._selectionController().updateSelection(this.scene(), this.pv.objectsMask, effect.selection);
    }
  }
}


/***/ }),

/***/ 41365:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "F": function() { return /* binding */ OutlinePostNode; }
/* harmony export */ });
/* harmony import */ var _utils_SelectionController__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(89275);
/* harmony import */ var _core_post_BlendFunction__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(45415);
/* harmony import */ var _Base__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(30538);
/* harmony import */ var _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(96949);
/* harmony import */ var postprocessing__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(43109);
/* harmony import */ var _core_post_KernelSize__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(51417);

var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));






class OutlinePostParamsConfig extends _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_0__/* .NodeParamsConfig */ .yI {
  constructor() {
    super(...arguments);
    /** @param object mask of the objects that will have an outline */
    this.objectsMask = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_0__/* .ParamConfig.STRING */ .XC.STRING("*outlined*", __spreadProps(__spreadValues({}, _Base__WEBPACK_IMPORTED_MODULE_1__/* .PostParamOptions */ ._3), {
      objectMask: true
    }));
    /** @param updates the cached objects found by objectMask  */
    this.refreshObjects = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_0__/* .ParamConfig.BUTTON */ .XC.BUTTON(null, __spreadValues({}, _Base__WEBPACK_IMPORTED_MODULE_1__/* .PostParamOptions */ ._3));
    /** @param edgeStrenth */
    this.edgeStrength = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_0__/* .ParamConfig.FLOAT */ .XC.FLOAT(3, __spreadValues({
      range: [0, 10],
      rangeLocked: [true, false]
    }, _Base__WEBPACK_IMPORTED_MODULE_1__/* .PostParamOptions */ ._3));
    /** @param blur */
    this.blur = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_0__/* .ParamConfig.BOOLEAN */ .XC.BOOLEAN(0, __spreadValues({}, _Base__WEBPACK_IMPORTED_MODULE_1__/* .PostParamOptions */ ._3));
    this.kernelSize = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_0__/* .ParamConfig.INTEGER */ .XC.INTEGER(postprocessing__WEBPACK_IMPORTED_MODULE_2__/* .KernelSize.VERY_SMALL */ .DD.VERY_SMALL, __spreadProps(__spreadValues(__spreadValues({}, _Base__WEBPACK_IMPORTED_MODULE_1__/* .PostParamOptions */ ._3), _core_post_KernelSize__WEBPACK_IMPORTED_MODULE_3__/* .KERNEL_SIZE_MENU_OPTIONS */ .N), {
      visibleIf: { blur: 1 }
    }));
    /** @param defines if the edges pulsate */
    this.pulseSpeed = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_0__/* .ParamConfig.FLOAT */ .XC.FLOAT(0, __spreadValues({
      range: [0, 5],
      rangeLocked: [true, false]
    }, _Base__WEBPACK_IMPORTED_MODULE_1__/* .PostParamOptions */ ._3));
    /** @param visibleEdgeColor */
    this.visibleEdgeColor = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_0__/* .ParamConfig.COLOR */ .XC.COLOR([1, 1, 1], __spreadValues({}, _Base__WEBPACK_IMPORTED_MODULE_1__/* .PostParamOptions */ ._3));
    /** @param shows outline for hidden parts of objects */
    this.xRay = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_0__/* .ParamConfig.BOOLEAN */ .XC.BOOLEAN(1, __spreadValues({}, _Base__WEBPACK_IMPORTED_MODULE_1__/* .PostParamOptions */ ._3));
    /** @param hiddenEdgeColor */
    this.hiddenEdgeColor = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_0__/* .ParamConfig.COLOR */ .XC.COLOR([0.2, 0.1, 0.4], __spreadProps(__spreadValues({}, _Base__WEBPACK_IMPORTED_MODULE_1__/* .PostParamOptions */ ._3), {
      visibleIf: { xRay: 1 }
    }));
    /** @param opacity */
    this.opacity = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_0__/* .ParamConfig.FLOAT */ .XC.FLOAT(1, __spreadValues({
      range: [0, 1],
      rangeLocked: [true, false]
    }, _Base__WEBPACK_IMPORTED_MODULE_1__/* .PostParamOptions */ ._3));
    /** @param render mode */
    this.blendFunction = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_0__/* .ParamConfig.INTEGER */ .XC.INTEGER(postprocessing__WEBPACK_IMPORTED_MODULE_2__/* .BlendFunction.SCREEN */ .YQ.SCREEN, __spreadValues(__spreadValues({}, _Base__WEBPACK_IMPORTED_MODULE_1__/* .PostParamOptions */ ._3), _core_post_BlendFunction__WEBPACK_IMPORTED_MODULE_4__/* .BLEND_FUNCTION_MENU_OPTIONS */ .z));
  }
}
const ParamsConfig = new OutlinePostParamsConfig();
class OutlinePostNode extends _Base__WEBPACK_IMPORTED_MODULE_1__/* .TypedPostNode */ .mN {
  constructor() {
    super(...arguments);
    this.paramsConfig = ParamsConfig;
    this._selectionController = new _utils_SelectionController__WEBPACK_IMPORTED_MODULE_5__/* .SelectionController */ .x();
  }
  static type() {
    return "outline";
  }
  // private _rendererSize = new Vector2();
  createPass(context) {
    const effect = new postprocessing__WEBPACK_IMPORTED_MODULE_2__/* .OutlineEffect */ .Mn(context.scene, context.camera, {
      blendFunction: postprocessing__WEBPACK_IMPORTED_MODULE_2__/* .BlendFunction.SCREEN */ .YQ.SCREEN,
      patternScale: 40,
      visibleEdgeColor: 16777215,
      hiddenEdgeColor: 2230538,
      height: 480,
      blur: false,
      xRay: true
    });
    effect.selection.add(context.scene.children[0]);
    const pass = new postprocessing__WEBPACK_IMPORTED_MODULE_2__/* .EffectPass */ .H5(context.camera, effect);
    this.updatePass(pass);
    return pass;
  }
  updatePass(pass) {
    const effect = pass.effects[0];
    effect.blendMode.opacity.value = this.pv.opacity;
    effect.blendMode.blendFunction = this.pv.blendFunction;
    effect.edgeStrength = this.pv.edgeStrength;
    effect.blur = this.pv.blur;
    effect.kernelSize = this.pv.kernelSize;
    effect.xRay = this.pv.xRay;
    effect.pulseSpeed = this.pv.pulseSpeed;
    effect.visibleEdgeColor = this.pv.visibleEdgeColor;
    effect.hiddenEdgeColor = this.pv.hiddenEdgeColor;
    this._setSelectedObjects(effect);
  }
  _setSelectedObjects(effect) {
    this._selectionController.updateSelection(this.scene(), this.pv.objectsMask, effect.selection);
  }
}


/***/ }),

/***/ 11427:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "v": function() { return /* binding */ PostProcessNetworkPostNode; }
/* harmony export */ });
/* harmony import */ var _BaseManager__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(37316);
/* harmony import */ var _poly_NodeContext__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(52070);
/* harmony import */ var _utils_DisplayNodeController__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(35725);
/* harmony import */ var _utils_EffectComposerController__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(32241);





class PostProcessNetworkPostNode extends _BaseManager__WEBPACK_IMPORTED_MODULE_0__/* .BaseNetworkPostNode */ .E {
  constructor() {
    super(...arguments);
    this.paramsConfig = new _utils_EffectComposerController__WEBPACK_IMPORTED_MODULE_1__/* .PostProcessNetworkParamsConfig */ .Ab();
    this.effectsComposerController = new _utils_EffectComposerController__WEBPACK_IMPORTED_MODULE_1__/* .EffectComposerController */ .iy(this);
    this.displayNodeController = new _utils_DisplayNodeController__WEBPACK_IMPORTED_MODULE_2__/* .DisplayNodeController */ .v(
      this,
      this.effectsComposerController.displayNodeControllerCallbacks()
    );
    this._childrenControllerContext = _poly_NodeContext__WEBPACK_IMPORTED_MODULE_3__/* .NodeContext.POST */ .sy.POST;
  }
  static type() {
    return _poly_NodeContext__WEBPACK_IMPORTED_MODULE_3__/* .NetworkNodeType.POST */ .kX.POST;
  }
  createNode(node_class, options) {
    return super.createNode(node_class, options);
  }
  children() {
    return super.children();
  }
  nodesByType(type) {
    return super.nodesByType(type);
  }
}


/***/ }),

/***/ 10538:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "k": function() { return /* binding */ RenderPostNode; }
/* harmony export */ });
/* harmony import */ var _Base__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(30538);
/* harmony import */ var postprocessing__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(43109);
/* harmony import */ var _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(96949);
/* harmony import */ var _poly_NodeContext__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(52070);
/* harmony import */ var _obj_Scene__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(92211);
/* harmony import */ var _core_BooleanValue__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(19037);

var __defProp = Object.defineProperty;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};






class RenderPassWithContext extends (/* unused pure expression or super */ null && (RenderPass)) {
  constructor(scene, camera) {
    super(scene, camera);
    this.scene = scene;
    this.camera = camera;
    this.context = { scene, camera };
  }
}
class RenderPostParamsConfig extends _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_0__/* .NodeParamsConfig */ .yI {
  constructor() {
    super(...arguments);
    /** @param overrideScene */
    this.overrideScene = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_0__/* .ParamConfig.BOOLEAN */ .XC.BOOLEAN(0, _Base__WEBPACK_IMPORTED_MODULE_1__/* .PostParamOptions */ ._3);
    /** @param scene */
    this.scene = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_0__/* .ParamConfig.NODE_PATH */ .XC.NODE_PATH("", __spreadValues({
      visibleIf: { overrideScene: 1 },
      nodeSelection: {
        context: _poly_NodeContext__WEBPACK_IMPORTED_MODULE_2__/* .NodeContext.OBJ */ .sy.OBJ,
        types: [_obj_Scene__WEBPACK_IMPORTED_MODULE_3__/* .SceneObjNode.type */ .H.type()]
      }
    }, _Base__WEBPACK_IMPORTED_MODULE_1__/* .PostParamOptions */ ._3));
    /** @param overrideCamera */
    this.overrideCamera = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_0__/* .ParamConfig.BOOLEAN */ .XC.BOOLEAN(0, _Base__WEBPACK_IMPORTED_MODULE_1__/* .PostParamOptions */ ._3);
    /** @param camera */
    this.camera = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_0__/* .ParamConfig.STRING */ .XC.STRING("", __spreadValues({
      visibleIf: { overrideCamera: 1 },
      // nodeSelection: {
      // 	context: NodeContext.OBJ,
      // 	types: CAMERA_TYPES,
      // },
      // cook: false,
      // separatorBefore: true,
      objectMask: true
    }, _Base__WEBPACK_IMPORTED_MODULE_1__/* .PostParamOptions */ ._3));
  }
  // clear_color = ParamConfig.COLOR([0, 0, 0]);
  // clear_alpha = ParamConfig.FLOAT(0);
  // clear_depth = ParamConfig.BOOLEAN(0);
}
const ParamsConfig = new RenderPostParamsConfig();
class RenderPostNode extends _Base__WEBPACK_IMPORTED_MODULE_1__/* .TypedPostNode */ .mN {
  constructor() {
    super(...arguments);
    this.paramsConfig = ParamsConfig;
  }
  static type() {
    return "render";
  }
  createPass(context) {
    const pass = new postprocessing__WEBPACK_IMPORTED_MODULE_4__/* .RenderPass */ .CD(context.scene, context.camera);
    pass.context = {
      camera: context.camera,
      scene: context.scene
    };
    this.updatePass(pass);
    return pass;
  }
  updatePass(pass) {
    this._updateCamera(pass);
    this._updateScene(pass);
  }
  _updateCamera(pass) {
    return __async(this, null, function* () {
      if ((0,_core_BooleanValue__WEBPACK_IMPORTED_MODULE_5__/* .isBooleanTrue */ .bI)(this.pv.overrideCamera)) {
        if (this.p.camera.isDirty()) {
          yield this.p.camera.compute();
        }
        const path = this.pv.camera;
        const object = this.scene().objectsController.findObjectByMask(path);
        if (object) {
          pass.camera = object;
        }
      } else {
        pass.camera = pass.context.camera;
      }
    });
  }
  _updateScene(pass) {
    return __async(this, null, function* () {
      if ((0,_core_BooleanValue__WEBPACK_IMPORTED_MODULE_5__/* .isBooleanTrue */ .bI)(this.pv.overrideScene)) {
        if (this.p.scene.isDirty()) {
          yield this.p.scene.compute();
        }
        const objNode = this.pv.scene.nodeWithContext(_poly_NodeContext__WEBPACK_IMPORTED_MODULE_2__/* .NodeContext.OBJ */ .sy.OBJ);
        if (objNode) {
          if (objNode.type() == _obj_Scene__WEBPACK_IMPORTED_MODULE_3__/* .SceneObjNode.type */ .H.type()) {
            const scene = objNode.object;
            pass.scene = scene;
          }
        }
      } else {
        pass.scene = pass.context.scene;
      }
    });
  }
}


/***/ }),

/***/ 39072:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "G": function() { return /* binding */ ToneMappingPostNode; }
/* harmony export */ });
/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(21410);
/* harmony import */ var _Base__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(30538);
/* harmony import */ var _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(96949);
/* harmony import */ var postprocessing__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(43109);

var __defProp = Object.defineProperty;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};




var ToneMappingModeStr = /* @__PURE__ */ ((ToneMappingModeStr2) => {
  ToneMappingModeStr2["REINHARD"] = "REINHARD";
  ToneMappingModeStr2["REINHARD2"] = "REINHARD2";
  ToneMappingModeStr2["REINHARD2_ADAPTIVE"] = "REINHARD2_ADAPTIVE";
  ToneMappingModeStr2["OPTIMIZED_CINEON"] = "OPTIMIZED_CINEON";
  ToneMappingModeStr2["ACES_FILMIC"] = "ACES_FILMIC";
  ToneMappingModeStr2["UNCHARTED2"] = "UNCHARTED2";
  return ToneMappingModeStr2;
})(ToneMappingModeStr || {});
const TONE_MAPPING_MODES = [
  "REINHARD" /* REINHARD */,
  "REINHARD2" /* REINHARD2 */,
  "REINHARD2_ADAPTIVE" /* REINHARD2_ADAPTIVE */,
  "OPTIMIZED_CINEON" /* OPTIMIZED_CINEON */,
  "ACES_FILMIC" /* ACES_FILMIC */,
  "UNCHARTED2" /* UNCHARTED2 */
];
const REMAPPED_TONE_MAPPING = {
  ["REINHARD" /* REINHARD */]: postprocessing__WEBPACK_IMPORTED_MODULE_0__/* .ToneMappingMode.REINHARD */ .hm.REINHARD,
  ["REINHARD2" /* REINHARD2 */]: postprocessing__WEBPACK_IMPORTED_MODULE_0__/* .ToneMappingMode.REINHARD2 */ .hm.REINHARD2,
  ["REINHARD2_ADAPTIVE" /* REINHARD2_ADAPTIVE */]: postprocessing__WEBPACK_IMPORTED_MODULE_0__/* .ToneMappingMode.REINHARD2_ADAPTIVE */ .hm.REINHARD2_ADAPTIVE,
  ["OPTIMIZED_CINEON" /* OPTIMIZED_CINEON */]: postprocessing__WEBPACK_IMPORTED_MODULE_0__/* .ToneMappingMode.OPTIMIZED_CINEON */ .hm.OPTIMIZED_CINEON,
  ["ACES_FILMIC" /* ACES_FILMIC */]: postprocessing__WEBPACK_IMPORTED_MODULE_0__/* .ToneMappingMode.ACES_FILMIC */ .hm.ACES_FILMIC,
  ["UNCHARTED2" /* UNCHARTED2 */]: postprocessing__WEBPACK_IMPORTED_MODULE_0__/* .ToneMappingMode.UNCHARTED2 */ .hm.UNCHARTED2
};
class ToneMappingPostParamsConfig extends _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .NodeParamsConfig */ .yI {
  constructor() {
    super(...arguments);
    /** @param mode */
    this.mode = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .ParamConfig.INTEGER */ .XC.INTEGER(TONE_MAPPING_MODES.indexOf("ACES_FILMIC" /* ACES_FILMIC */), __spreadValues({
      menu: {
        entries: TONE_MAPPING_MODES.map((name, value) => ({ name, value }))
      }
    }, _Base__WEBPACK_IMPORTED_MODULE_2__/* .PostParamOptions */ ._3));
    /** @param adaptive */
    this.adaptive = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .ParamConfig.BOOLEAN */ .XC.BOOLEAN(0, __spreadValues({}, _Base__WEBPACK_IMPORTED_MODULE_2__/* .PostParamOptions */ ._3));
  }
}
const ParamsConfig = new ToneMappingPostParamsConfig();
class ToneMappingPostNode extends _Base__WEBPACK_IMPORTED_MODULE_2__/* .TypedPostNode */ .mN {
  constructor() {
    super(...arguments);
    this.paramsConfig = ParamsConfig;
    this._rendererSize = new three__WEBPACK_IMPORTED_MODULE_3__.Vector2();
  }
  static type() {
    return "toneMapping";
  }
  createPass(context) {
    context.renderer.getSize(this._rendererSize);
    const toneMappingEffectOptions = {
      mode: this.toneMapping()
    };
    const bloomEffect = new postprocessing__WEBPACK_IMPORTED_MODULE_0__/* .ToneMappingEffect */ .M4(toneMappingEffectOptions);
    const pass = new postprocessing__WEBPACK_IMPORTED_MODULE_0__/* .EffectPass */ .H5(context.camera, bloomEffect);
    this.updatePass(pass);
    return pass;
  }
  updatePass(pass) {
    const effect = pass.effects[0];
    effect.mode = this.toneMapping();
  }
  toneMapping() {
    return REMAPPED_TONE_MAPPING[TONE_MAPPING_MODES[this.pv.mode]];
  }
}


/***/ }),

/***/ 12614:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {


// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  "E": function() { return /* binding */ UpdateScenePostNode; }
});

// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/nodes/post/_Base.ts
var _Base = __webpack_require__(30538);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/nodes/utils/params/ParamsConfig.ts
var ParamsConfig = __webpack_require__(96949);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/core/Type.ts
var Type = __webpack_require__(19037);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/node_modules/three/build/three.module.js
var three_module = __webpack_require__(21410);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/node_modules/postprocessing/build/index.js
var build = __webpack_require__(43109);
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/post/utils/effects/UpdateScenePass.ts



class UpdateScenePass extends build/* CopyPass */.KM {
  // public objectsMask: string;
  // public invertMask: boolean;
  // public setMatteMaterial: boolean;
  // public setVisible: boolean;
  // public visible: boolean;
  constructor(options) {
    super();
    this.reset = options.reset;
    this.node = options.node;
    this.nodeToReset = options.nodeToReset;
  }
  // private _onRenderBound = this._onRender.bind(this)
  // private _onRender(){
  // }
  render(renderer, inputBuffer, outputBuffer, deltaTime, stencilTest) {
    if ((0,Type/* isBooleanTrue */.bI)(this.reset)) {
      if (this.nodeToReset) {
        this.nodeToReset.resetChanges();
      } else {
        console.warn("reset is true, but no passToReset is given");
      }
    } else {
      this.node.applyChanges();
    }
    super.render(renderer, inputBuffer, outputBuffer, deltaTime, stencilTest);
  }
  // override update(renderer: WebGLRenderer, inputBuffer: WebGLRenderTarget, deltaTime: number) {
  // 	if (isBooleanTrue(this.reset)) {
  // 		if (this.nodeToReset) {
  // 			this.nodeToReset.resetChanges();
  // 		} else {
  // 			console.warn('reset is true, but no passToReset is given');
  // 		}
  // 	} else {
  // 		this.node.applyChanges();
  // 	}
  // 	// console.warn(deltaTime, this);
  // 	super.update(renderer, inputBuffer, deltaTime);
  // }
  // private _updateObjectBound = this._updateObject.bind(this);
  // private _updateObject(obj: Object3D) {
  // 	this._objectsList.push(obj);
  // 	if (isBooleanTrue(this.setMatteMaterial)) {
  // 		const mesh = obj as Mesh;
  // 		if (mesh.material) {
  // 			this._materialByMesh.set(mesh, mesh.material);
  // 			mesh.material = MATTE_MATERIAL;
  // 		}
  // 	}
  // 	if (isBooleanTrue(this.setVisible)) {
  // 		if (obj.visible != this.visible) {
  // 			this._visibleByObject.set(obj, obj.visible);
  // 			obj.visible = this.visible;
  // 			console.log(obj, obj.visible);
  // 		}
  // 	}
  // }
}

// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/poly/registers/nodes/types/Post.ts
var Post = __webpack_require__(4138);
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/post/UpdateScene.ts

var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));






const MATTE_MATERIAL = new three_module.MeshBasicMaterial({ color: new three_module.Color(0, 0, 0) });
class UpdateScenePostParamsConfig extends ParamsConfig/* NodeParamsConfig */.yI {
  constructor() {
    super(...arguments);
    /** @param reset */
    this.reset = ParamsConfig/* ParamConfig.BOOLEAN */.XC.BOOLEAN(0, __spreadValues({}, _Base/* PostParamOptions */._3));
    /** @param objects Mask */
    this.objectsMask = ParamsConfig/* ParamConfig.STRING */.XC.STRING("*", __spreadProps(__spreadValues({}, _Base/* PostParamOptions */._3), {
      visibleIf: { reset: 0 },
      objectMask: true
    }));
    /** @param invertMask */
    this.invertMask = ParamsConfig/* ParamConfig.BOOLEAN */.XC.BOOLEAN(0, __spreadProps(__spreadValues({}, _Base/* PostParamOptions */._3), {
      visibleIf: { reset: 0 }
    }));
    /** @param prints which objects are targeted by this node, for debugging */
    // printFoundObjectsFromMask = ParamConfig.BUTTON(null, {
    // 	visibleIf: {reset: 0},
    // 	callback: (node: BaseNodeType) => {
    // 		UpdateScenePostNode.PARAM_CALLBACK_printResolve(node as UpdateScenePostNode);
    // 	},
    // });
    /** @param update selected objects material to a matte one */
    this.setMatteMaterial = ParamsConfig/* ParamConfig.BOOLEAN */.XC.BOOLEAN(1, __spreadProps(__spreadValues({}, _Base/* PostParamOptions */._3), {
      visibleIf: { reset: 0 },
      separatorBefore: true
    }));
    /** @param set visible state  */
    this.setVisible = ParamsConfig/* ParamConfig.BOOLEAN */.XC.BOOLEAN(0, __spreadProps(__spreadValues({}, _Base/* PostParamOptions */._3), {
      visibleIf: { reset: 0 },
      separatorBefore: true
    }));
    /** @param set visible state  */
    this.visible = ParamsConfig/* ParamConfig.BOOLEAN */.XC.BOOLEAN(0, __spreadProps(__spreadValues({}, _Base/* PostParamOptions */._3), {
      visibleIf: { reset: 0, setVisible: 1 }
    }));
    /** @param reset */
    this.resetChanges = ParamsConfig/* ParamConfig.BUTTON */.XC.BUTTON(null, {
      visibleIf: { reset: 0 },
      callback: (node) => {
        UpdateScenePostNode.PARAM_CALLBACK_resetChanges(node);
      },
      separatorBefore: true
    });
  }
  /** @param material */
  // material = ParamConfig.NODE_PATH('', {
  // 	...PostParamOptions,
  // 	visibleIf: {overrideMaterial: 1},
  // 	nodeSelection: {
  // 		context: NodeContext.MAT,
  // 	},
  // 	callback: (node: BaseNodeType) => {
  // 		UpdateScenePostNode.PARAM_CALLBACK_updatePassesMaterial(node as UpdateScenePostNode);
  // 	},
  // });
}
const UpdateScene_ParamsConfig = new UpdateScenePostParamsConfig();
class UpdateScenePostNode extends _Base/* TypedPostNode */.mN {
  constructor() {
    super(...arguments);
    this.paramsConfig = UpdateScene_ParamsConfig;
    // private _resetMat() {
    // 	this._passesByEffectsComposer.forEach((passOrPasses) => {
    // 		const passes = CoreType.isArray(passOrPasses) ? passOrPasses : [passOrPasses];
    // 		for (let pass of passes) {
    // 			const effect = _effectFromPass(pass);
    // 			if (effect) {
    // 				effect.resetChanges();
    // 			}
    // 		}
    // 	});
    // }
    // static PARAM_CALLBACK_updatePassesMaterial(node: UpdateScenePostNode) {
    // 	node._updatePassesMaterial();
    // }
    // private _updatePassesMaterial() {
    // 	const matNode = this.pv.material.nodeWithContext(NodeContext.MAT);
    // 	if (!matNode) {
    // 		this._passes_by_requester_id.forEach((pass) => {
    // 			pass.material = undefined;
    // 		});
    // 	} else {
    // 		const mat = matNode.material;
    // 		this._passes_by_requester_id.forEach((pass) => {
    // 			pass.material = mat;
    // 		});
    // 	}
    // }
    this._objectsList = [];
    this._materialByMesh = /* @__PURE__ */ new Map();
    // private _parentByObject: Map<Object3D, Object3D | null> = new Map();
    this._visibleByObject = /* @__PURE__ */ new Map();
    this._updateObjectBound = this._updateObject.bind(this);
  }
  static type() {
    return Post/* PostType.UPDATE_SCENE */.h.UPDATE_SCENE;
  }
  initializeNode() {
    super.initializeNode();
    this.io.inputs.setCount(0, 2);
  }
  createPass(context) {
    const pass = new UpdateScenePass({
      // scene: this.scene(),
      node: this,
      reset: (0,Type/* isBooleanTrue */.bI)(this.pv.reset),
      nodeToReset: this._nodeToReset(context)
      // objectsMask: this.pv.objectsMask,
      // invertMask: isBooleanTrue(this.pv.invertMask),
      // setMatteMaterial: isBooleanTrue(this.pv.setMatteMaterial),
      // setVisible: isBooleanTrue(this.pv.setVisible),
      // visible: isBooleanTrue(this.pv.visible),
    });
    this.updatePass(pass);
    return pass;
  }
  updatePass(pass) {
  }
  _nodeToReset(context) {
    const input2 = this.io.inputs.input(1);
    if (!input2) {
      return;
    }
    if (input2 instanceof UpdateScenePostNode) {
      return input2;
    }
  }
  // static PARAM_CALLBACK_printResolve(node: UpdateScenePostNode) {
  // 	node._printResolve();
  // }
  // private _printResolve() {
  // 	let firstPass: EffectPass | undefined;
  // 	this._passesByEffectsComposer.forEach((passOrPasses) => {
  // 		const passes = CoreType.isArray(passOrPasses) ? passOrPasses : [passOrPasses];
  // 		firstPass = firstPass || passes[0];
  // 	});
  // 	if (firstPass) {
  // 		const effect = _effectFromPass(firstPass);
  // 		if (effect) {
  // 			console.log(hhis.objectsList());
  // 		}
  // 	} else {
  // 		console.error(`no pass generated by this node, maybe it has not rendered yet?`);
  // 	}
  // }
  static PARAM_CALLBACK_resetChanges(node) {
    node.resetChanges();
  }
  objectsList() {
    return this._objectsList;
  }
  applyChanges() {
    const changeNeeded = (0,Type/* isBooleanTrue */.bI)(this.pv.setMatteMaterial) || (0,Type/* isBooleanTrue */.bI)(this.pv.setVisible);
    if (changeNeeded) {
      this._objectsList.length = 0;
      const mask = this.pv.objectsMask;
      this._scene.objectsController.traverseObjectsWithMask(
        mask,
        this._updateObjectBound,
        void 0,
        this.pv.invertMask
      );
    }
  }
  resetChanges() {
    this._materialByMesh.forEach((mat, mesh) => {
      mesh.material = mat;
    });
    this._materialByMesh.clear();
    this._visibleByObject.forEach((visible, obj) => {
      obj.visible = visible;
    });
    this._visibleByObject.clear();
  }
  _updateObject(obj) {
    this._objectsList.push(obj);
    if ((0,Type/* isBooleanTrue */.bI)(this.pv.setMatteMaterial)) {
      const mesh = obj;
      if (mesh.material) {
        this._materialByMesh.set(mesh, mesh.material);
        mesh.material = MATTE_MATERIAL;
      }
    }
    if ((0,Type/* isBooleanTrue */.bI)(this.pv.setVisible)) {
      const visible = this.pv.visible;
      if (obj.visible != visible) {
        this._visibleByObject.set(obj, obj.visible);
        obj.visible = visible;
      }
    }
  }
}


/***/ }),

/***/ 37316:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "A": function() { return /* binding */ ParamLessBaseNetworkPostNode; },
/* harmony export */   "E": function() { return /* binding */ BaseNetworkPostNode; }
/* harmony export */ });
/* harmony import */ var _poly_NodeContext__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(52070);
/* harmony import */ var _Base__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(74386);




class ParamLessNetworkPostParamsConfig extends (/* unused pure expression or super */ null && (NodeParamsConfig)) {
}
class BaseNetworkPostNode extends _Base__WEBPACK_IMPORTED_MODULE_0__/* .TypedNode */ .Mv {
  static context() {
    return _poly_NodeContext__WEBPACK_IMPORTED_MODULE_1__/* .NodeContext.POST */ .sy.POST;
  }
  cook() {
    this.cookController.endCook();
  }
}
class ParamLessBaseNetworkPostNode extends BaseNetworkPostNode {
}


/***/ }),

/***/ 89275:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "x": function() { return /* binding */ SelectionController; }
/* harmony export */ });

class SelectionController {
  constructor() {
    this._map = /* @__PURE__ */ new Map();
    this._resolvedObjects = [];
  }
  updateSelection(scene, objectsMask, selection) {
    const foundObjects = scene.objectsByMask(objectsMask);
    this._map.clear();
    for (const object of foundObjects) {
      this._map.set(object.uuid, object);
    }
    const isAncestorNotInList = (object) => {
      let isAncestorInList = false;
      object.traverseAncestors((ancestor) => {
        if (this._map.has(ancestor.uuid)) {
          isAncestorInList = true;
        }
      });
      return !isAncestorInList;
    };
    this._resolvedObjects = foundObjects.filter(isAncestorNotInList);
    selection.clear();
    for (const object of this._resolvedObjects) {
      selection.add(object);
    }
  }
}


/***/ }),

/***/ 88013:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "f": function() { return /* binding */ PostProcessNetworkRopNode; }
/* harmony export */ });
/* harmony import */ var _BaseManager__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(57469);
/* harmony import */ var _poly_NodeContext__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(52070);
/* harmony import */ var _utils_DisplayNodeController__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(35725);
/* harmony import */ var _post_utils_EffectComposerController__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(32241);





class PostProcessNetworkRopNode extends _BaseManager__WEBPACK_IMPORTED_MODULE_0__/* .BaseNetworkRopNode */ .v {
  constructor() {
    super(...arguments);
    this.paramsConfig = new _post_utils_EffectComposerController__WEBPACK_IMPORTED_MODULE_1__/* .PostProcessNetworkParamsConfig */ .Ab();
    this.effectsComposerController = new _post_utils_EffectComposerController__WEBPACK_IMPORTED_MODULE_1__/* .EffectComposerController */ .iy(this);
    this.displayNodeController = new _utils_DisplayNodeController__WEBPACK_IMPORTED_MODULE_2__/* .DisplayNodeController */ .v(
      this,
      this.effectsComposerController.displayNodeControllerCallbacks()
    );
    this._childrenControllerContext = _poly_NodeContext__WEBPACK_IMPORTED_MODULE_3__/* .NodeContext.POST */ .sy.POST;
  }
  static type() {
    return _poly_NodeContext__WEBPACK_IMPORTED_MODULE_3__/* .NetworkNodeType.POST */ .kX.POST;
  }
  createNode(node_class, options) {
    return super.createNode(node_class, options);
  }
  children() {
    return super.children();
  }
  nodesByType(type) {
    return super.nodesByType(type);
  }
}


/***/ }),

/***/ 57469:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "$": function() { return /* binding */ ParamLessBaseNetworkRopNode; },
/* harmony export */   "v": function() { return /* binding */ BaseNetworkRopNode; }
/* harmony export */ });
/* harmony import */ var _poly_NodeContext__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(52070);
/* harmony import */ var _Base__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(74386);




class ParamLessNetworkRopParamsConfig extends (/* unused pure expression or super */ null && (NodeParamsConfig)) {
}
class BaseNetworkRopNode extends _Base__WEBPACK_IMPORTED_MODULE_0__/* .TypedNode */ .Mv {
  static context() {
    return _poly_NodeContext__WEBPACK_IMPORTED_MODULE_1__/* .NodeContext.ROP */ .sy.ROP;
  }
  cook() {
    this.cookController.endCook();
  }
}
class ParamLessBaseNetworkRopNode extends BaseNetworkRopNode {
}


/***/ }),

/***/ 98517:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "f": function() { return /* binding */ ActorSopNode; }
/* harmony export */ });
/* harmony import */ var _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(96949);
/* harmony import */ var _poly_NodeContext__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(52070);
/* harmony import */ var _core_geometry_Mask__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(58290);
/* harmony import */ var _poly_registers_nodes_types_Sop__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(58986);
/* harmony import */ var _BaseActor__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(29540);
/* harmony import */ var _core_Type__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(19037);
/* harmony import */ var _poly_InputCloneMode__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(56752);

var __async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};







class ActorSopParamsConfig extends _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_0__/* .NodeParamsConfig */ .yI {
  constructor() {
    super(...arguments);
    /** @param select which objects this applies the actor behavior to */
    this.group = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_0__/* .ParamConfig.STRING */ .XC.STRING("", {
      objectMask: true
    });
    /** @param build actor from child nodes */
    this.useThisNode = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_0__/* .ParamConfig.BOOLEAN */ .XC.BOOLEAN(1, {
      separatorAfter: true
    });
    /** @param actor node */
    this.node = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_0__/* .ParamConfig.NODE_PATH */ .XC.NODE_PATH("", {
      visibleIf: { useThisNode: 0 },
      nodeSelection: {
        types: [_poly_NodeContext__WEBPACK_IMPORTED_MODULE_1__/* .NetworkNodeType.ACTOR */ .kX.ACTOR]
      },
      dependentOnFoundNode: false,
      separatorAfter: true
    });
  }
}
const ParamsConfig = new ActorSopParamsConfig();
class ActorSopNode extends _BaseActor__WEBPACK_IMPORTED_MODULE_2__/* .TypedActorSopNode */ .p {
  constructor() {
    super(...arguments);
    this.paramsConfig = ParamsConfig;
  }
  static type() {
    return _poly_registers_nodes_types_Sop__WEBPACK_IMPORTED_MODULE_3__/* .SopType.ACTOR */ .aB.ACTOR;
  }
  initializeNode() {
    this.io.inputs.setCount(1);
    this.io.inputs.initInputsClonedState(_poly_InputCloneMode__WEBPACK_IMPORTED_MODULE_4__/* .InputCloneMode.FROM_NODE */ .m.FROM_NODE);
  }
  cook(inputCoreGroups) {
    return __async(this, null, function* () {
      this.compilationController.compileIfRequired();
      const coreGroup = inputCoreGroups[0];
      const objects = (0,_core_geometry_Mask__WEBPACK_IMPORTED_MODULE_5__/* .filterObjectsWithGroup */ .hJ)(coreGroup, this.pv);
      const actorNode = yield this._findActorNode();
      if (actorNode) {
        for (const object of objects) {
          this.scene().actorsManager.assignActorBuilder(object, actorNode);
        }
      }
      this.setCoreGroup(coreGroup);
    });
  }
  _findActorNode() {
    return __async(this, null, function* () {
      if ((0,_core_Type__WEBPACK_IMPORTED_MODULE_6__/* .isBooleanTrue */ .bI)(this.pv.useThisNode)) {
        return this;
      } else {
        const node = this.pv.node.node();
        if (node) {
          yield node.compute();
        }
        return node;
      }
    });
  }
}


/***/ }),

/***/ 83655:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "G": function() { return /* binding */ ActorInstanceSopNode; }
/* harmony export */ });
/* harmony import */ var _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(96949);
/* harmony import */ var _poly_NodeContext__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(52070);
/* harmony import */ var _core_geometry_Mask__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(58290);
/* harmony import */ var _poly_registers_nodes_types_Sop__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(58986);
/* harmony import */ var _BaseActor__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(29540);
/* harmony import */ var _core_Type__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(19037);
/* harmony import */ var _poly_InputCloneMode__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(56752);

var __async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};







class ActorInstanceSopParamsConfig extends _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_0__/* .NodeParamsConfig */ .yI {
  constructor() {
    super(...arguments);
    /** @param select which objects this applies the actor behavior to */
    this.group = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_0__/* .ParamConfig.STRING */ .XC.STRING("", {
      objectMask: true
    });
    /** @param build actor from child nodes */
    this.useThisNode = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_0__/* .ParamConfig.BOOLEAN */ .XC.BOOLEAN(1, {
      separatorAfter: true
    });
    /** @param actor node */
    this.node = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_0__/* .ParamConfig.NODE_PATH */ .XC.NODE_PATH("", {
      visibleIf: { useThisNode: 0 },
      nodeSelection: {
        types: [_poly_NodeContext__WEBPACK_IMPORTED_MODULE_1__/* .NetworkNodeType.ACTOR */ .kX.ACTOR]
      },
      dependentOnFoundNode: false,
      separatorAfter: true
    });
  }
}
const ParamsConfig = new ActorInstanceSopParamsConfig();
class ActorInstanceSopNode extends _BaseActor__WEBPACK_IMPORTED_MODULE_2__/* .TypedActorSopNode */ .p {
  constructor() {
    super(...arguments);
    this.paramsConfig = ParamsConfig;
  }
  static type() {
    return _poly_registers_nodes_types_Sop__WEBPACK_IMPORTED_MODULE_3__/* .SopType.ACTOR_INSTANCE */ .aB.ACTOR_INSTANCE;
  }
  initializeNode() {
    this.io.inputs.setCount(1);
    this.io.inputs.initInputsClonedState(_poly_InputCloneMode__WEBPACK_IMPORTED_MODULE_4__/* .InputCloneMode.FROM_NODE */ .m.FROM_NODE);
  }
  cook(inputCoreGroups) {
    return __async(this, null, function* () {
      this.compilationController.compileIfRequired();
      const coreGroup = inputCoreGroups[0];
      const objects = (0,_core_geometry_Mask__WEBPACK_IMPORTED_MODULE_5__/* .filterObjectsWithGroup */ .hJ)(coreGroup, this.pv);
      const actorNode = yield this._findActorNode();
      if (actorNode) {
        for (const object of objects) {
          this.scene().actorsManager.assignActorBuilder(object, actorNode);
        }
      }
      this.setCoreGroup(coreGroup);
    });
  }
  _findActorNode() {
    return __async(this, null, function* () {
      if ((0,_core_Type__WEBPACK_IMPORTED_MODULE_6__/* .isBooleanTrue */ .bI)(this.pv.useThisNode)) {
        return this;
      } else {
        const node = this.pv.node.node();
        if (node) {
          yield node.compute();
        }
        return node;
      }
    });
  }
}


/***/ }),

/***/ 36138:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "i": function() { return /* binding */ ActorPointSopNode; }
/* harmony export */ });
/* harmony import */ var _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(96949);
/* harmony import */ var _poly_NodeContext__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(52070);
/* harmony import */ var _core_geometry_Mask__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(58290);
/* harmony import */ var _poly_registers_nodes_types_Sop__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(58986);
/* harmony import */ var _BaseActor__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(29540);
/* harmony import */ var _core_Type__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(19037);
/* harmony import */ var _poly_InputCloneMode__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(56752);

var __async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};







class ActorPointSopParamsConfig extends _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_0__/* .NodeParamsConfig */ .yI {
  constructor() {
    super(...arguments);
    /** @param select which objects this applies the actor behavior to */
    this.group = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_0__/* .ParamConfig.STRING */ .XC.STRING("", {
      objectMask: true
    });
    /** @param build actor from child nodes */
    this.useThisNode = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_0__/* .ParamConfig.BOOLEAN */ .XC.BOOLEAN(1, {
      separatorAfter: true
    });
    /** @param actor node */
    this.node = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_0__/* .ParamConfig.NODE_PATH */ .XC.NODE_PATH("", {
      visibleIf: { useThisNode: 0 },
      nodeSelection: {
        types: [_poly_NodeContext__WEBPACK_IMPORTED_MODULE_1__/* .NetworkNodeType.ACTOR */ .kX.ACTOR]
      },
      dependentOnFoundNode: false,
      separatorAfter: true
    });
  }
}
const ParamsConfig = new ActorPointSopParamsConfig();
class ActorPointSopNode extends _BaseActor__WEBPACK_IMPORTED_MODULE_2__/* .TypedActorSopNode */ .p {
  constructor() {
    super(...arguments);
    this.paramsConfig = ParamsConfig;
  }
  static type() {
    return _poly_registers_nodes_types_Sop__WEBPACK_IMPORTED_MODULE_3__/* .SopType.ACTOR_POINT */ .aB.ACTOR_POINT;
  }
  initializeNode() {
    this.io.inputs.setCount(1);
    this.io.inputs.initInputsClonedState(_poly_InputCloneMode__WEBPACK_IMPORTED_MODULE_4__/* .InputCloneMode.FROM_NODE */ .m.FROM_NODE);
  }
  cook(inputCoreGroups) {
    return __async(this, null, function* () {
      this.compilationController.compileIfRequired();
      const coreGroup = inputCoreGroups[0];
      const objects = (0,_core_geometry_Mask__WEBPACK_IMPORTED_MODULE_5__/* .filterObjectsWithGroup */ .hJ)(coreGroup, this.pv);
      const actorNode = yield this._findActorNode();
      if (actorNode) {
        for (const object of objects) {
          this.scene().actorsManager.assignActorBuilder(object, actorNode);
        }
      }
      this.setCoreGroup(coreGroup);
    });
  }
  _findActorNode() {
    return __async(this, null, function* () {
      if ((0,_core_Type__WEBPACK_IMPORTED_MODULE_6__/* .isBooleanTrue */ .bI)(this.pv.useThisNode)) {
        return this;
      } else {
        const node = this.pv.node.node();
        if (node) {
          yield node.compute();
        }
        return node;
      }
    });
  }
}


/***/ }),

/***/ 48950:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "d": function() { return /* binding */ AddSopNode; }
/* harmony export */ });
/* harmony import */ var _Base__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(55839);
/* harmony import */ var _operations_sop_Add__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(36464);
/* harmony import */ var _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(96949);
/* harmony import */ var _poly_registers_nodes_types_Sop__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(58986);





const DEFAULT = _operations_sop_Add__WEBPACK_IMPORTED_MODULE_0__/* .AddSopOperation.DEFAULT_PARAMS */ .F.DEFAULT_PARAMS;
class AddSopParamsConfig extends _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .NodeParamsConfig */ .yI {
  constructor() {
    super(...arguments);
    /** @param toggle to create points */
    this.createPoint = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .ParamConfig.BOOLEAN */ .XC.BOOLEAN(DEFAULT.createPoint);
    /** @param define the number of points to create */
    this.pointsCount = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .ParamConfig.INTEGER */ .XC.INTEGER(DEFAULT.pointsCount, {
      range: [1, 100],
      rangeLocked: [true, false],
      visibleIf: { createPoint: true }
    });
    /** @param the position of the created points */
    this.position = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .ParamConfig.VECTOR3 */ .XC.VECTOR3(DEFAULT.position, { visibleIf: { createPoint: true } });
    /** @param toggle on to connect the points from the input geometry */
    this.connectInputPoints = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .ParamConfig.BOOLEAN */ .XC.BOOLEAN(DEFAULT.connectInputPoints);
    /** @param check if the last point is connected */
    this.connectToLastPoint = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .ParamConfig.BOOLEAN */ .XC.BOOLEAN(DEFAULT.connectToLastPoint);
  }
}
const ParamsConfig = new AddSopParamsConfig();
class AddSopNode extends _Base__WEBPACK_IMPORTED_MODULE_2__/* .TypedSopNode */ .x {
  constructor() {
    super(...arguments);
    this.paramsConfig = ParamsConfig;
  }
  static type() {
    return _poly_registers_nodes_types_Sop__WEBPACK_IMPORTED_MODULE_3__/* .SopType.ADD */ .aB.ADD;
  }
  initializeNode() {
    this.io.inputs.setCount(0, 1);
  }
  cook(input_contents) {
    this._operation = this._operation || new _operations_sop_Add__WEBPACK_IMPORTED_MODULE_0__/* .AddSopOperation */ .F(this.scene(), this.states, this);
    const core_group = this._operation.cook(input_contents, this.pv);
    this.setCoreGroup(core_group);
  }
}


/***/ }),

/***/ 87322:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "e": function() { return /* binding */ AmbientLightSopNode; }
/* harmony export */ });
/* harmony import */ var _Base__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(55839);
/* harmony import */ var _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(96949);
/* harmony import */ var _core_lights_AmbientLight__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(23276);
/* harmony import */ var _operations_sop_AmbientLight__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(82040);





class AmbientLightSopParamsConfig extends (0,_core_lights_AmbientLight__WEBPACK_IMPORTED_MODULE_0__/* .AmbientLightParamConfig */ .j)(_utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .NodeParamsConfig */ .yI) {
}
const ParamsConfig = new AmbientLightSopParamsConfig();
class AmbientLightSopNode extends _Base__WEBPACK_IMPORTED_MODULE_2__/* .TypedSopNode */ .x {
  constructor() {
    super(...arguments);
    this.paramsConfig = ParamsConfig;
  }
  static type() {
    return "ambientLight";
  }
  initializeNode() {
    this.io.inputs.setCount(0);
  }
  cook(input_contents) {
    this._operation = this._operation || new _operations_sop_AmbientLight__WEBPACK_IMPORTED_MODULE_3__/* .AmbientLightSopOperation */ .j(this._scene, this.states, this);
    const core_group = this._operation.cook(input_contents, this.pv);
    this.setCoreGroup(core_group);
  }
}


/***/ }),

/***/ 4455:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Y": function() { return /* binding */ AreaLightSopNode; }
/* harmony export */ });
/* harmony import */ var _Base__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(55839);
/* harmony import */ var _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(96949);
/* harmony import */ var _core_lights_AreaLight__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(72862);
/* harmony import */ var _operations_sop_AreaLight__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(54112);
/* harmony import */ var _poly_registers_nodes_types_Light__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(18244);






class AreaLightSopParamsConfig extends (0,_core_lights_AreaLight__WEBPACK_IMPORTED_MODULE_0__/* .AreaLightParamConfig */ .fP)(_utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .NodeParamsConfig */ .yI) {
}
const ParamsConfig = new AreaLightSopParamsConfig();
class AreaLightSopNode extends _Base__WEBPACK_IMPORTED_MODULE_2__/* .TypedSopNode */ .x {
  constructor() {
    super(...arguments);
    this.paramsConfig = ParamsConfig;
  }
  static type() {
    return _poly_registers_nodes_types_Light__WEBPACK_IMPORTED_MODULE_3__/* .LightType.AREA */ .v.AREA;
  }
  initializeNode() {
    this.io.inputs.setCount(0);
  }
  cook(input_contents) {
    this._operation = this._operation || new _operations_sop_AreaLight__WEBPACK_IMPORTED_MODULE_4__/* .AreaLightSopOperation */ .X(this._scene, this.states, this);
    const core_group = this._operation.cook(input_contents, this.pv);
    this.setCoreGroup(core_group);
  }
}


/***/ }),

/***/ 92417:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "$": function() { return /* binding */ AttribAddMultSopNode; }
/* harmony export */ });
/* harmony import */ var _Base__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(55839);
/* harmony import */ var _operations_sop_AttribAddMult__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(8057);
/* harmony import */ var _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(96949);
/* harmony import */ var _poly_registers_nodes_types_Sop__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(58986);





const DEFAULT = _operations_sop_AttribAddMult__WEBPACK_IMPORTED_MODULE_0__/* .AttribAddMultSopOperation.DEFAULT_PARAMS */ .t.DEFAULT_PARAMS;
class AttribAddMultSopParamsConfig extends _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .NodeParamsConfig */ .yI {
  constructor() {
    super(...arguments);
    /** @param attribute name */
    this.name = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .ParamConfig.STRING */ .XC.STRING(DEFAULT.name);
    /** @param value to add before the multiplication */
    this.preAdd = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .ParamConfig.FLOAT */ .XC.FLOAT(DEFAULT.preAdd, { range: [-1, 1] });
    /** @param value to multiply */
    this.mult = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .ParamConfig.FLOAT */ .XC.FLOAT(DEFAULT.mult, { range: [-1, 1] });
    /** @param value to add after the multiplication */
    this.postAdd = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .ParamConfig.FLOAT */ .XC.FLOAT(DEFAULT.postAdd, { range: [-1, 1] });
  }
}
const ParamsConfig = new AttribAddMultSopParamsConfig();
class AttribAddMultSopNode extends _Base__WEBPACK_IMPORTED_MODULE_2__/* .TypedSopNode */ .x {
  constructor() {
    super(...arguments);
    this.paramsConfig = ParamsConfig;
  }
  static type() {
    return _poly_registers_nodes_types_Sop__WEBPACK_IMPORTED_MODULE_3__/* .SopType.ATTRIB_ADD_MULT */ .aB.ATTRIB_ADD_MULT;
  }
  initializeNode() {
    this.io.inputs.setCount(1);
    this.io.inputs.initInputsClonedState(_operations_sop_AttribAddMult__WEBPACK_IMPORTED_MODULE_0__/* .AttribAddMultSopOperation.INPUT_CLONED_STATE */ .t.INPUT_CLONED_STATE);
  }
  cook(input_contents) {
    this._operation = this._operation || new _operations_sop_AttribAddMult__WEBPACK_IMPORTED_MODULE_0__/* .AttribAddMultSopOperation */ .t(this.scene(), this.states, this);
    const core_group = this._operation.cook(input_contents, this.pv);
    this.setCoreGroup(core_group);
  }
}


/***/ }),

/***/ 17490:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "e": function() { return /* binding */ AttribCastSopNode; }
/* harmony export */ });
/* harmony import */ var _Base__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(55839);
/* harmony import */ var _operations_sop_AttribCast__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(96685);
/* harmony import */ var _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(96949);




const DEFAULT = _operations_sop_AttribCast__WEBPACK_IMPORTED_MODULE_0__/* .AttribCastSopOperation.DEFAULT_PARAMS */ .Lz.DEFAULT_PARAMS;
class IndexCastSopParamsConfig extends _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .NodeParamsConfig */ .yI {
  constructor() {
    super(...arguments);
    /** @param toggle on to cast attributes */
    this.castAttributes = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .ParamConfig.BOOLEAN */ .XC.BOOLEAN(DEFAULT.castAttributes);
    /** @param attrib mask */
    this.mask = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .ParamConfig.STRING */ .XC.STRING(DEFAULT.mask, {
      visibleIf: { castAttributes: 1 }
    });
    /** @param toggle on to cast index */
    this.castIndex = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .ParamConfig.BOOLEAN */ .XC.BOOLEAN(DEFAULT.castIndex);
    /** @param type of attribute to cast to */
    this.type = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .ParamConfig.INTEGER */ .XC.INTEGER(DEFAULT.type, {
      menu: {
        entries: _operations_sop_AttribCast__WEBPACK_IMPORTED_MODULE_0__/* .ATTRIB_TYPES.map */ .Vw.map((name, value) => {
          return {
            name,
            value
          };
        })
      }
    });
  }
}
const ParamsConfig = new IndexCastSopParamsConfig();
class AttribCastSopNode extends _Base__WEBPACK_IMPORTED_MODULE_2__/* .TypedSopNode */ .x {
  constructor() {
    super(...arguments);
    this.paramsConfig = ParamsConfig;
  }
  static type() {
    return "attribCast";
  }
  initializeNode() {
    this.io.inputs.setCount(1);
    this.io.inputs.initInputsClonedState(_operations_sop_AttribCast__WEBPACK_IMPORTED_MODULE_0__/* .AttribCastSopOperation.INPUT_CLONED_STATE */ .Lz.INPUT_CLONED_STATE);
  }
  cook(input_contents) {
    this._operation = this._operation || new _operations_sop_AttribCast__WEBPACK_IMPORTED_MODULE_0__/* .AttribCastSopOperation */ .Lz(this.scene(), this.states, this);
    const core_group = this._operation.cook(input_contents, this.pv);
    this.setCoreGroup(core_group);
  }
}


/***/ }),

/***/ 8415:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "I": function() { return /* binding */ AttribCopySopNode; }
/* harmony export */ });
/* harmony import */ var _Base__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(55839);
/* harmony import */ var _operations_sop_AttribCopy__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(50758);
/* harmony import */ var _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(96949);
/* harmony import */ var _poly_registers_nodes_types_Sop__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(58986);
/* harmony import */ var _core_geometry_Constant__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(91568);






const DEFAULT = _operations_sop_AttribCopy__WEBPACK_IMPORTED_MODULE_0__/* .AttribCopySopOperation.DEFAULT_PARAMS */ .O.DEFAULT_PARAMS;
class AttribCopySopParamsConfig extends _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .NodeParamsConfig */ .yI {
  constructor() {
    super(...arguments);
    /** @param the attribute class (geometry or object) */
    this.class = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .ParamConfig.INTEGER */ .XC.INTEGER(DEFAULT.class, {
      menu: {
        entries: _core_geometry_Constant__WEBPACK_IMPORTED_MODULE_2__/* .AttribClassMenuEntries */ .yp
      }
    });
    /** @param name of the attribute to copy */
    this.name = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .ParamConfig.STRING */ .XC.STRING(DEFAULT.name);
    /** @param toggle if you want to copy to another name */
    this.tnewName = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .ParamConfig.BOOLEAN */ .XC.BOOLEAN(DEFAULT.tnewName);
    /** @param the new name of the attribute */
    this.newName = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .ParamConfig.STRING */ .XC.STRING(DEFAULT.newName, { visibleIf: { tnewName: 1 } });
    /** @param this defines which component the copy starts from. If you want to copy the whole attribute, leave it at 0. If you want to copy only the y component, set it to 1. If you want to copy the z component, set it to 2. Note that this only makes sense if you copy from an attribute that has enough components to copy from. So setting it to 2 (for z) to copy from a vector2 attribute will raise an error. */
    this.srcOffset = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .ParamConfig.INTEGER */ .XC.INTEGER(DEFAULT.srcOffset, {
      range: [0, 3],
      rangeLocked: [true, true],
      visibleIf: { class: _core_geometry_Constant__WEBPACK_IMPORTED_MODULE_2__/* .ATTRIBUTE_CLASSES.indexOf */ .oT.indexOf(_core_geometry_Constant__WEBPACK_IMPORTED_MODULE_2__/* .AttribClass.POINT */ .io.POINT) }
    });
    /** @param this defines which component the attribute is copied to */
    this.destOffset = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .ParamConfig.INTEGER */ .XC.INTEGER(DEFAULT.destOffset, {
      range: [0, 3],
      rangeLocked: [true, true],
      visibleIf: { class: _core_geometry_Constant__WEBPACK_IMPORTED_MODULE_2__/* .ATTRIBUTE_CLASSES.indexOf */ .oT.indexOf(_core_geometry_Constant__WEBPACK_IMPORTED_MODULE_2__/* .AttribClass.POINT */ .io.POINT) }
    });
  }
}
const ParamsConfig = new AttribCopySopParamsConfig();
class AttribCopySopNode extends _Base__WEBPACK_IMPORTED_MODULE_3__/* .TypedSopNode */ .x {
  constructor() {
    super(...arguments);
    this.paramsConfig = ParamsConfig;
  }
  static type() {
    return _poly_registers_nodes_types_Sop__WEBPACK_IMPORTED_MODULE_4__/* .SopType.ATTRIB_COPY */ .aB.ATTRIB_COPY;
  }
  initializeNode() {
    this.io.inputs.setCount(1, 2);
    this.io.inputs.initInputsClonedState(_operations_sop_AttribCopy__WEBPACK_IMPORTED_MODULE_0__/* .AttribCopySopOperation.INPUT_CLONED_STATE */ .O.INPUT_CLONED_STATE);
  }
  cook(input_contents) {
    this._operation = this._operation || new _operations_sop_AttribCopy__WEBPACK_IMPORTED_MODULE_0__/* .AttribCopySopOperation */ .O(this.scene(), this.states, this);
    const core_group = this._operation.cook(input_contents, this.pv);
    this.setCoreGroup(core_group);
  }
  setAttribClass(attribClass) {
    this.p.class.set(_core_geometry_Constant__WEBPACK_IMPORTED_MODULE_2__/* .ATTRIBUTE_CLASSES.indexOf */ .oT.indexOf(attribClass));
  }
  attribClass() {
    return _core_geometry_Constant__WEBPACK_IMPORTED_MODULE_2__/* .ATTRIBUTE_CLASSES */ .oT[this.pv.class];
  }
}


/***/ }),

/***/ 56090:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "b": function() { return /* binding */ AttribDeleteSopNode; }
/* harmony export */ });
/* harmony import */ var _Base__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(55839);
/* harmony import */ var _core_geometry_Constant__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(91568);
/* harmony import */ var _poly_InputCloneMode__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(56752);
/* harmony import */ var _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(96949);
/* harmony import */ var _poly_registers_nodes_types_Sop__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(58986);
/* harmony import */ var _operations_sop_AttribDelete__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(41346);







const DEFAULT = _operations_sop_AttribDelete__WEBPACK_IMPORTED_MODULE_0__/* .AttribDeleteSopOperation.DEFAULT_PARAMS */ .T.DEFAULT_PARAMS;
class AttribDeleteSopParamsConfig extends _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .NodeParamsConfig */ .yI {
  constructor() {
    super(...arguments);
    /** @param the group this applies to */
    this.group = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .ParamConfig.STRING */ .XC.STRING(DEFAULT.group);
    /** @param attribute class (geometry or object) */
    this.class = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .ParamConfig.INTEGER */ .XC.INTEGER(DEFAULT.class, {
      menu: {
        entries: _core_geometry_Constant__WEBPACK_IMPORTED_MODULE_2__/* .AttribClassMenuEntries */ .yp
      }
    });
    /** @param attribute name to delete */
    this.name = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .ParamConfig.STRING */ .XC.STRING(DEFAULT.name);
  }
}
const ParamsConfig = new AttribDeleteSopParamsConfig();
class AttribDeleteSopNode extends _Base__WEBPACK_IMPORTED_MODULE_3__/* .TypedSopNode */ .x {
  constructor() {
    super(...arguments);
    this.paramsConfig = ParamsConfig;
  }
  static type() {
    return _poly_registers_nodes_types_Sop__WEBPACK_IMPORTED_MODULE_4__/* .SopType.ATTRIB_DELETE */ .aB.ATTRIB_DELETE;
  }
  initializeNode() {
    this.io.inputs.setCount(1);
    this.io.inputs.initInputsClonedState(_poly_InputCloneMode__WEBPACK_IMPORTED_MODULE_5__/* .InputCloneMode.FROM_NODE */ .m.FROM_NODE);
  }
  setAttribClass(attribClass) {
    this.p.class.set(_core_geometry_Constant__WEBPACK_IMPORTED_MODULE_2__/* .ATTRIBUTE_CLASSES.indexOf */ .oT.indexOf(attribClass));
  }
  attribClass() {
    return _core_geometry_Constant__WEBPACK_IMPORTED_MODULE_2__/* .ATTRIBUTE_CLASSES */ .oT[this.pv.class];
  }
  cook(inputCoreGroups) {
    this._operation = this._operation || new _operations_sop_AttribDelete__WEBPACK_IMPORTED_MODULE_0__/* .AttribDeleteSopOperation */ .T(this._scene, this.states, this);
    const coreGroup = this._operation.cook(inputCoreGroups, this.pv);
    this.setCoreGroup(coreGroup);
  }
}


/***/ }),

/***/ 66330:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "r": function() { return /* binding */ AttribFromTextureSopNode; }
/* harmony export */ });
/* harmony import */ var _Base__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(55839);
/* harmony import */ var _poly_NodeContext__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(52070);
/* harmony import */ var _poly_InputCloneMode__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(56752);
/* harmony import */ var _operations_sop_AttribFromTexture__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(18224);
/* harmony import */ var _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(96949);

var __async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};





const DEFAULT = _operations_sop_AttribFromTexture__WEBPACK_IMPORTED_MODULE_0__/* .AttribFromTextureSopOperation.DEFAULT_PARAMS */ .W.DEFAULT_PARAMS;
class AttribFromTextureSopParamsConfig extends _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .NodeParamsConfig */ .yI {
  constructor() {
    super(...arguments);
    /** @param texture node */
    this.texture = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .ParamConfig.NODE_PATH */ .XC.NODE_PATH("", {
      nodeSelection: { context: _poly_NodeContext__WEBPACK_IMPORTED_MODULE_2__/* .NodeContext.COP */ .sy.COP }
    });
    /** @param uv attribute */
    this.uvAttrib = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .ParamConfig.STRING */ .XC.STRING(DEFAULT.uvAttrib);
    /** @param attribute to set the value to */
    this.attrib = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .ParamConfig.STRING */ .XC.STRING(DEFAULT.attrib);
    /** @param target attribute size */
    this.attribSize = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .ParamConfig.INTEGER */ .XC.INTEGER(DEFAULT.attribSize, {
      range: [1, 3],
      rangeLocked: [true, true]
    });
    /** @param value to add to the attribute */
    this.add = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .ParamConfig.FLOAT */ .XC.FLOAT(DEFAULT.add);
    /** @param value to multiply the attribute with */
    this.mult = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .ParamConfig.FLOAT */ .XC.FLOAT(DEFAULT.mult);
  }
}
const ParamsConfig = new AttribFromTextureSopParamsConfig();
class AttribFromTextureSopNode extends _Base__WEBPACK_IMPORTED_MODULE_3__/* .TypedSopNode */ .x {
  constructor() {
    super(...arguments);
    this.paramsConfig = ParamsConfig;
  }
  static type() {
    return "attribFromTexture";
  }
  initializeNode() {
    this.io.inputs.setCount(1);
    this.io.inputs.initInputsClonedState(_poly_InputCloneMode__WEBPACK_IMPORTED_MODULE_4__/* .InputCloneMode.FROM_NODE */ .m.FROM_NODE);
  }
  cook(input_contents) {
    return __async(this, null, function* () {
      this._operation = this._operation || new _operations_sop_AttribFromTexture__WEBPACK_IMPORTED_MODULE_0__/* .AttribFromTextureSopOperation */ .W(this.scene(), this.states, this);
      const core_group = yield this._operation.cook(input_contents, this.pv);
      this.setCoreGroup(core_group);
    });
  }
}


/***/ }),

/***/ 92635:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "n": function() { return /* binding */ AttribIdSopNode; }
/* harmony export */ });
/* harmony import */ var _core_geometry_Constant__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(91568);
/* harmony import */ var _Base__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(55839);
/* harmony import */ var _poly_InputCloneMode__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(56752);
/* harmony import */ var _operations_sop_AttribId__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(67905);
/* harmony import */ var _poly_registers_nodes_types_Sop__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(58986);
/* harmony import */ var _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(96949);








const DEFAULT = _operations_sop_AttribId__WEBPACK_IMPORTED_MODULE_0__/* .AttribIdSopOperation.DEFAULT_PARAMS */ .S.DEFAULT_PARAMS;
class AttribIdSopParamsConfig extends _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .NodeParamsConfig */ .yI {
  constructor() {
    super(...arguments);
    /** @param the attribute class (geometry or object) */
    this.class = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .ParamConfig.INTEGER */ .XC.INTEGER(DEFAULT.class, {
      menu: {
        entries: _core_geometry_Constant__WEBPACK_IMPORTED_MODULE_2__/* .AttribClassMenuEntriesWithoutCoreGroup */ .oh
      }
    });
    /** @param sets to true to create the id attribute */
    this.id = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .ParamConfig.BOOLEAN */ .XC.BOOLEAN(DEFAULT.id);
    /** @param name of id attribute */
    this.idName = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .ParamConfig.STRING */ .XC.STRING(DEFAULT.idName, {
      visibleIf: { id: 1 }
    });
    /** @param sets to true to create the id attribute */
    this.idn = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .ParamConfig.BOOLEAN */ .XC.BOOLEAN(DEFAULT.idn);
    /** @param name of the position attribute */
    /** @param name of idn attribute */
    this.idnName = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .ParamConfig.STRING */ .XC.STRING(DEFAULT.idnName, {
      visibleIf: { idn: 1 }
    });
  }
}
const ParamsConfig = new AttribIdSopParamsConfig();
class AttribIdSopNode extends _Base__WEBPACK_IMPORTED_MODULE_3__/* .TypedSopNode */ .x {
  constructor() {
    super(...arguments);
    this.paramsConfig = ParamsConfig;
  }
  static type() {
    return _poly_registers_nodes_types_Sop__WEBPACK_IMPORTED_MODULE_4__/* .SopType.ATTRIB_ID */ .aB.ATTRIB_ID;
  }
  initializeNode() {
    this.io.inputs.setCount(1);
    this.io.inputs.initInputsClonedState([_poly_InputCloneMode__WEBPACK_IMPORTED_MODULE_5__/* .InputCloneMode.FROM_NODE */ .m.FROM_NODE]);
  }
  cook(inputCoreGroups) {
    this._operation = this._operation || new _operations_sop_AttribId__WEBPACK_IMPORTED_MODULE_0__/* .AttribIdSopOperation */ .S(this.scene(), this.states, this);
    const coreGroup = this._operation.cook(inputCoreGroups, this.pv);
    this.setCoreGroup(coreGroup);
  }
  //
  //
  // API UTILS
  //
  //
  setAttribClass(attribClass) {
    if (_core_geometry_Constant__WEBPACK_IMPORTED_MODULE_2__/* .ATTRIBUTE_CLASSES_WITHOUT_CORE_GROUP.includes */ .fc.includes(attribClass)) {
      this.p.class.set(_core_geometry_Constant__WEBPACK_IMPORTED_MODULE_2__/* .ATTRIBUTE_CLASSES_WITHOUT_CORE_GROUP.indexOf */ .fc.indexOf(attribClass));
    } else {
      console.warn(`${attribClass} is not possible on this node`);
    }
  }
  attribClass() {
    return _core_geometry_Constant__WEBPACK_IMPORTED_MODULE_2__/* .ATTRIBUTE_CLASSES_WITHOUT_CORE_GROUP */ .fc[this.pv.class];
  }
}


/***/ }),

/***/ 94692:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "e": function() { return /* binding */ AttribNormalizeSopNode; }
/* harmony export */ });
/* harmony import */ var _Base__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(55839);
/* harmony import */ var _operations_sop_AttribNormalize__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(89106);
/* harmony import */ var _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(96949);




const DEFAULT = _operations_sop_AttribNormalize__WEBPACK_IMPORTED_MODULE_0__/* .AttribNormalizeSopOperation.DEFAULT_PARAMS */ .Ch.DEFAULT_PARAMS;
class AttribNormalizeSopParamsConfig extends _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .NodeParamsConfig */ .yI {
  constructor() {
    super(...arguments);
    /** @param defines if the value should be normalized between 0 and 1, or for vectors if the length should be 1 */
    this.mode = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .ParamConfig.INTEGER */ .XC.INTEGER(DEFAULT.mode, {
      menu: {
        entries: _operations_sop_AttribNormalize__WEBPACK_IMPORTED_MODULE_0__/* .NORMALIZE_MODES.map */ .Oj.map((name, value) => {
          return { name, value };
        })
      }
    });
    /** @param attribute to normalize */
    this.name = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .ParamConfig.STRING */ .XC.STRING(DEFAULT.name);
    /** @param toggle to change the name of the attribute */
    this.changeName = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .ParamConfig.BOOLEAN */ .XC.BOOLEAN(DEFAULT.changeName);
    /** @param new attribute name */
    this.newName = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .ParamConfig.STRING */ .XC.STRING(DEFAULT.newName, { visibleIf: { changeName: 1 } });
  }
}
const ParamsConfig = new AttribNormalizeSopParamsConfig();
class AttribNormalizeSopNode extends _Base__WEBPACK_IMPORTED_MODULE_2__/* .TypedSopNode */ .x {
  constructor() {
    super(...arguments);
    this.paramsConfig = ParamsConfig;
  }
  static type() {
    return "attribNormalize";
  }
  initializeNode() {
    this.io.inputs.setCount(1);
    this.io.inputs.initInputsClonedState(_operations_sop_AttribNormalize__WEBPACK_IMPORTED_MODULE_0__/* .AttribNormalizeSopOperation.INPUT_CLONED_STATE */ .Ch.INPUT_CLONED_STATE);
  }
  set_mode(mode) {
    this.p.mode.set(_operations_sop_AttribNormalize__WEBPACK_IMPORTED_MODULE_0__/* .NORMALIZE_MODES.indexOf */ .Oj.indexOf(mode));
  }
  cook(input_contents) {
    this._operation = this._operation || new _operations_sop_AttribNormalize__WEBPACK_IMPORTED_MODULE_0__/* .AttribNormalizeSopOperation */ .Ch(this.scene(), this.states, this);
    const core_group = this._operation.cook(input_contents, this.pv);
    this.setCoreGroup(core_group);
  }
}


/***/ }),

/***/ 34692:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "d": function() { return /* binding */ AttribRemapSopNode; }
/* harmony export */ });
/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(21410);
/* harmony import */ var _Base__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(55839);
/* harmony import */ var _core_geometry_Constant__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(91568);
/* harmony import */ var _poly_Assert__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(68239);
/* harmony import */ var _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(96949);
/* harmony import */ var _core_BooleanValue__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(19037);
/* harmony import */ var _core_geometry_entities_point_CorePointUtils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(50253);
/* harmony import */ var _core_geometry_CoreObjectFactory__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(17353);











const _points = [];
class AttribRemapSopParamsConfig extends _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_0__/* .NodeParamsConfig */ .yI {
  constructor() {
    super(...arguments);
    /** @param name of the attribute to remap */
    this.name = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_0__/* .ParamConfig.STRING */ .XC.STRING();
    /** @param ramp used to remap */
    this.ramp = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_0__/* .ParamConfig.RAMP */ .XC.RAMP();
    /** @param toggle if you want to create a new attribute */
    this.changeName = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_0__/* .ParamConfig.BOOLEAN */ .XC.BOOLEAN(0);
    /** @param new attribute name */
    this.newName = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_0__/* .ParamConfig.STRING */ .XC.STRING("", { visibleIf: { changeName: 1 } });
  }
}
const ParamsConfig = new AttribRemapSopParamsConfig();
class AttribRemapSopNode extends _Base__WEBPACK_IMPORTED_MODULE_1__/* .TypedSopNode */ .x {
  constructor() {
    super(...arguments);
    this.paramsConfig = ParamsConfig;
  }
  static type() {
    return "attribRemap";
  }
  initializeNode() {
    this.io.inputs.setCount(1);
  }
  cook(inputCoreGroups) {
    const coreGroup = inputCoreGroups[0];
    const objects = coreGroup.allObjects();
    for (const object of objects) {
      this._remapAttribute(object);
    }
    this.setCoreGroup(coreGroup);
  }
  _remapAttribute(object) {
    (0,_core_geometry_entities_point_CorePointUtils__WEBPACK_IMPORTED_MODULE_2__/* .pointsFromObject */ .u_)(object, _points);
    if (_points.length === 0) {
      return;
    }
    if (this.pv.name === "") {
      return;
    }
    const corePointClass = (0,_core_geometry_CoreObjectFactory__WEBPACK_IMPORTED_MODULE_3__/* .corePointClassFactory */ .E_)(object);
    const attribSize = corePointClass.attribSize(object, this.pv.name);
    const values = _points.map((point) => point.attribValue(this.pv.name));
    const remapedValues = new Array(_points.length);
    this._get_remaped_values(attribSize, values, remapedValues);
    let targetName = this.pv.name;
    if ((0,_core_BooleanValue__WEBPACK_IMPORTED_MODULE_4__/* .isBooleanTrue */ .bI)(this.pv.changeName)) {
      targetName = this.pv.newName;
      if (!corePointClass.hasAttribute(object, targetName)) {
        corePointClass.addNumericAttribute(object, targetName, attribSize, 0);
      }
    }
    let i = 0;
    for (const normalized_value of remapedValues) {
      _points[i].setAttribValue(targetName, normalized_value);
      i++;
    }
  }
  _get_remaped_values(attrib_size, values, remaped_values) {
    switch (attrib_size) {
      case _core_geometry_Constant__WEBPACK_IMPORTED_MODULE_5__/* .AttribSize.FLOAT */ .NS.FLOAT:
        return this._getNormalizedFloat(values, remaped_values);
      case _core_geometry_Constant__WEBPACK_IMPORTED_MODULE_5__/* .AttribSize.VECTOR2 */ .NS.VECTOR2:
        return this._getNormalizedVector2(values, remaped_values);
      case _core_geometry_Constant__WEBPACK_IMPORTED_MODULE_5__/* .AttribSize.VECTOR3 */ .NS.VECTOR3:
        return this._getNormalizedVector3(values, remaped_values);
      case _core_geometry_Constant__WEBPACK_IMPORTED_MODULE_5__/* .AttribSize.VECTOR4 */ .NS.VECTOR4:
        return this._getNormalizedVector4(values, remaped_values);
    }
    _poly_Assert__WEBPACK_IMPORTED_MODULE_6__/* .TypeAssert.unreachable */ .f.unreachable(attrib_size);
  }
  _getNormalizedFloat(values, remaped_values) {
    const valuesf = values;
    const ramp_param = this.p.ramp;
    for (let i = 0; i < valuesf.length; i++) {
      const value = valuesf[i];
      const remaped_value = ramp_param.valueAtPosition(value);
      remaped_values[i] = remaped_value;
    }
  }
  _getNormalizedVector2(values, remaped_values) {
    const valuesv = values;
    const ramp_param = this.p.ramp;
    for (let i = 0; i < valuesv.length; i++) {
      const value = valuesv[i];
      const remaped_value = new three__WEBPACK_IMPORTED_MODULE_7__.Vector2(ramp_param.valueAtPosition(value.x), ramp_param.valueAtPosition(value.y));
      remaped_values[i] = remaped_value;
    }
  }
  _getNormalizedVector3(values, remaped_values) {
    const valuesv = values;
    const ramp_param = this.p.ramp;
    for (let i = 0; i < valuesv.length; i++) {
      const value = valuesv[i];
      const remaped_value = new three__WEBPACK_IMPORTED_MODULE_7__.Vector3(
        ramp_param.valueAtPosition(value.x),
        ramp_param.valueAtPosition(value.y),
        ramp_param.valueAtPosition(value.z)
      );
      remaped_values[i] = remaped_value;
    }
  }
  _getNormalizedVector4(values, remaped_values) {
    const valuesv = values;
    const ramp_param = this.p.ramp;
    for (let i = 0; i < valuesv.length; i++) {
      const value = valuesv[i];
      const remaped_value = new three__WEBPACK_IMPORTED_MODULE_7__.Vector4(
        ramp_param.valueAtPosition(value.x),
        ramp_param.valueAtPosition(value.y),
        ramp_param.valueAtPosition(value.z),
        ramp_param.valueAtPosition(value.w)
      );
      remaped_values[i] = remaped_value;
    }
  }
}


/***/ }),

/***/ 33523:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "K": function() { return /* binding */ AttribRenameSopNode; }
/* harmony export */ });
/* harmony import */ var _Base__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(55839);
/* harmony import */ var _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(96949);
/* harmony import */ var _core_geometry_Constant__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(91568);
/* harmony import */ var _operations_sop_AttribRename__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(44207);





const DEFAULT = _operations_sop_AttribRename__WEBPACK_IMPORTED_MODULE_0__/* .AttribRenameSopOperation.DEFAULT_PARAMS */ .D.DEFAULT_PARAMS;
class AttribRenameSopParamsConfig extends _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .NodeParamsConfig */ .yI {
  constructor() {
    super(...arguments);
    /** @param the group this applies to */
    this.group = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .ParamConfig.STRING */ .XC.STRING(DEFAULT.group);
    /** @param class of the attribute to rename (object or geometry) */
    this.class = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .ParamConfig.INTEGER */ .XC.INTEGER(DEFAULT.class, {
      menu: {
        entries: _core_geometry_Constant__WEBPACK_IMPORTED_MODULE_2__/* .AttribClassMenuEntries */ .yp
      }
    });
    /** @param old attribute name */
    this.oldName = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .ParamConfig.STRING */ .XC.STRING(DEFAULT.oldName);
    /** @param new attribute name */
    this.newName = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .ParamConfig.STRING */ .XC.STRING(DEFAULT.newName);
  }
}
const ParamsConfig = new AttribRenameSopParamsConfig();
class AttribRenameSopNode extends _Base__WEBPACK_IMPORTED_MODULE_3__/* .TypedSopNode */ .x {
  constructor() {
    super(...arguments);
    this.paramsConfig = ParamsConfig;
  }
  static type() {
    return "attribRename";
  }
  initializeNode() {
    this.io.inputs.setCount(1);
    this.io.inputs.initInputsClonedState(_operations_sop_AttribRename__WEBPACK_IMPORTED_MODULE_0__/* .AttribRenameSopOperation.INPUT_CLONED_STATE */ .D.INPUT_CLONED_STATE);
  }
  setAttribClass(attribClass) {
    this.p.class.set(_core_geometry_Constant__WEBPACK_IMPORTED_MODULE_2__/* .ATTRIBUTE_CLASSES.indexOf */ .oT.indexOf(attribClass));
  }
  attribClass() {
    return _core_geometry_Constant__WEBPACK_IMPORTED_MODULE_2__/* .ATTRIBUTE_CLASSES */ .oT[this.pv.class];
  }
  cook(inputCoreGroups) {
    this._operation = this._operation || new _operations_sop_AttribRename__WEBPACK_IMPORTED_MODULE_0__/* .AttribRenameSopOperation */ .D(this._scene, this.states, this);
    const coreGroup = this._operation.cook(inputCoreGroups, this.pv);
    this.setCoreGroup(coreGroup);
  }
}


/***/ }),

/***/ 99861:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "X": function() { return /* binding */ AttribSetAtIndexSopNode; }
/* harmony export */ });
/* harmony import */ var _Base__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(55839);
/* harmony import */ var _core_geometry_Constant__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(91568);
/* harmony import */ var _core_geometry_Attribute__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(32558);
/* harmony import */ var _poly_Assert__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(68239);
/* harmony import */ var _operations_sop_AttribSetAtIndex__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(70297);
/* harmony import */ var _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(96949);
/* harmony import */ var _core_geometry_CoreObjectFactory__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(17353);
/* harmony import */ var _core_geometry_entities_point_CorePointUtils__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(50253);









const DEFAULT = _operations_sop_AttribSetAtIndex__WEBPACK_IMPORTED_MODULE_0__/* .AttribSetAtIndexSopOperation.DEFAULT_PARAMS */ .Y.DEFAULT_PARAMS;
const _allPoints = [];
class AttribSetAtIndexSopParamsConfig extends _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .NodeParamsConfig */ .yI {
  constructor() {
    super(...arguments);
    /** @param the point or object index this applies to */
    this.index = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .ParamConfig.INTEGER */ .XC.INTEGER(DEFAULT.index, {
      range: [0, 100],
      rangeLocked: [true, false]
    });
    /** @param the attribute class (geometry or object) */
    this.class = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .ParamConfig.INTEGER */ .XC.INTEGER(DEFAULT.class, {
      menu: {
        entries: _core_geometry_Constant__WEBPACK_IMPORTED_MODULE_2__/* .AttribClassMenuEntries */ .yp
      }
    });
    /** @param the attribute type (numeric or string) */
    this.type = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .ParamConfig.INTEGER */ .XC.INTEGER(DEFAULT.type, {
      menu: {
        entries: _core_geometry_Constant__WEBPACK_IMPORTED_MODULE_2__/* .AttribTypeMenuEntries */ .mb
      }
    });
    /** @param the attribute name */
    this.name = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .ParamConfig.STRING */ .XC.STRING(DEFAULT.name);
    /** @param the attribute size (1 for float, 2 for vector2, 3 for vector3, 4 for vector4) */
    this.size = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .ParamConfig.INTEGER */ .XC.INTEGER(DEFAULT.size, {
      range: [1, 4],
      rangeLocked: [true, true],
      visibleIf: { type: _core_geometry_Constant__WEBPACK_IMPORTED_MODULE_2__/* .ATTRIBUTE_TYPES.indexOf */ .Xu.indexOf(_core_geometry_Constant__WEBPACK_IMPORTED_MODULE_2__/* .AttribType.NUMERIC */ .rp.NUMERIC) }
    });
    /** @param the value for a float attribute */
    this.value1 = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .ParamConfig.FLOAT */ .XC.FLOAT(DEFAULT.value1, {
      visibleIf: { type: _core_geometry_Constant__WEBPACK_IMPORTED_MODULE_2__/* .ATTRIBUTE_TYPES.indexOf */ .Xu.indexOf(_core_geometry_Constant__WEBPACK_IMPORTED_MODULE_2__/* .AttribType.NUMERIC */ .rp.NUMERIC), size: 1 }
    });
    /** @param the value for a vector2 */
    this.value2 = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .ParamConfig.VECTOR2 */ .XC.VECTOR2(DEFAULT.value2, {
      visibleIf: { type: _core_geometry_Constant__WEBPACK_IMPORTED_MODULE_2__/* .ATTRIBUTE_TYPES.indexOf */ .Xu.indexOf(_core_geometry_Constant__WEBPACK_IMPORTED_MODULE_2__/* .AttribType.NUMERIC */ .rp.NUMERIC), size: 2 }
    });
    /** @param the value for a vector3 */
    this.value3 = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .ParamConfig.VECTOR3 */ .XC.VECTOR3(DEFAULT.value3, {
      visibleIf: { type: _core_geometry_Constant__WEBPACK_IMPORTED_MODULE_2__/* .ATTRIBUTE_TYPES.indexOf */ .Xu.indexOf(_core_geometry_Constant__WEBPACK_IMPORTED_MODULE_2__/* .AttribType.NUMERIC */ .rp.NUMERIC), size: 3 }
    });
    /** @param the value for a vector4 */
    this.value4 = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .ParamConfig.VECTOR4 */ .XC.VECTOR4(DEFAULT.value4, {
      visibleIf: { type: _core_geometry_Constant__WEBPACK_IMPORTED_MODULE_2__/* .ATTRIBUTE_TYPES.indexOf */ .Xu.indexOf(_core_geometry_Constant__WEBPACK_IMPORTED_MODULE_2__/* .AttribType.NUMERIC */ .rp.NUMERIC), size: 4 }
    });
    /** @param the value for a string attribute */
    this.string = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .ParamConfig.STRING */ .XC.STRING(DEFAULT.string, {
      visibleIf: { type: _core_geometry_Constant__WEBPACK_IMPORTED_MODULE_2__/* .ATTRIBUTE_TYPES.indexOf */ .Xu.indexOf(_core_geometry_Constant__WEBPACK_IMPORTED_MODULE_2__/* .AttribType.STRING */ .rp.STRING) }
    });
  }
}
const ParamsConfig = new AttribSetAtIndexSopParamsConfig();
class AttribSetAtIndexSopNode extends _Base__WEBPACK_IMPORTED_MODULE_3__/* .TypedSopNode */ .x {
  constructor() {
    super(...arguments);
    this.paramsConfig = ParamsConfig;
  }
  static type() {
    return "attribSetAtIndex";
  }
  initializeNode() {
    this.io.inputs.setCount(1);
    this.io.inputs.initInputsClonedState(_operations_sop_AttribSetAtIndex__WEBPACK_IMPORTED_MODULE_0__/* .AttribSetAtIndexSopOperation.INPUT_CLONED_STATE */ .Y.INPUT_CLONED_STATE);
  }
  cook(inputCoreGroups) {
    const attribName = this.pv.name;
    if (this._isUsingExpression()) {
      if (attribName && attribName.trim() != "") {
        this._addAttribute(_core_geometry_Constant__WEBPACK_IMPORTED_MODULE_2__/* .ATTRIBUTE_CLASSES */ .oT[this.pv.class], inputCoreGroups[0]);
      } else {
        this.states.error.set("attribute name is not valid");
      }
    } else {
      this._operation = this._operation || new _operations_sop_AttribSetAtIndex__WEBPACK_IMPORTED_MODULE_0__/* .AttribSetAtIndexSopOperation */ .Y(this.scene(), this.states, this);
      const coreGroup = this._operation.cook(inputCoreGroups, this.pv);
      this.setCoreGroup(coreGroup);
    }
  }
  _addAttribute(attribClass, coreGroup) {
    const attribType = _core_geometry_Constant__WEBPACK_IMPORTED_MODULE_2__/* .ATTRIBUTE_TYPES */ .Xu[this.pv.type];
    switch (attribClass) {
      case _core_geometry_Constant__WEBPACK_IMPORTED_MODULE_2__/* .AttribClass.POINT */ .io.POINT:
        this._addPointAttribute(attribType, coreGroup);
        return this.setCoreGroup(coreGroup);
      case _core_geometry_Constant__WEBPACK_IMPORTED_MODULE_2__/* .AttribClass.VERTEX */ .io.VERTEX:
        this.states.error.set("vertex attributes are not supported");
        return this.setCoreGroup(coreGroup);
      case _core_geometry_Constant__WEBPACK_IMPORTED_MODULE_2__/* .AttribClass.PRIMITIVE */ .io.PRIMITIVE:
        this.states.error.set("primitive attributes are not supported");
        return this.setCoreGroup(coreGroup);
      case _core_geometry_Constant__WEBPACK_IMPORTED_MODULE_2__/* .AttribClass.OBJECT */ .io.OBJECT:
        this._addObjectAttribute(attribType, coreGroup);
        return this.setCoreGroup(coreGroup);
      case _core_geometry_Constant__WEBPACK_IMPORTED_MODULE_2__/* .AttribClass.CORE_GROUP */ .io.CORE_GROUP:
        this._addCoreGroupAttribute(attribType, coreGroup);
        return this.setCoreGroup(coreGroup);
    }
    _poly_Assert__WEBPACK_IMPORTED_MODULE_4__/* .TypeAssert.unreachable */ .f.unreachable(attribClass);
  }
  _addPointAttribute(attribType, coreGroup) {
    const objects = coreGroup.allObjects();
    switch (attribType) {
      case _core_geometry_Constant__WEBPACK_IMPORTED_MODULE_2__/* .AttribType.NUMERIC */ .rp.NUMERIC: {
        for (const object of objects) {
          this._addNumericAttributeToPoints(object);
        }
        return;
      }
      case _core_geometry_Constant__WEBPACK_IMPORTED_MODULE_2__/* .AttribType.STRING */ .rp.STRING: {
        for (const object of objects) {
          this._addStringAttributeToPoints(object);
        }
        return;
      }
    }
    _poly_Assert__WEBPACK_IMPORTED_MODULE_4__/* .TypeAssert.unreachable */ .f.unreachable(attribType);
  }
  _addObjectAttribute(attribType, coreGroup) {
    const allCoreObjects = coreGroup.allCoreObjects();
    const attribName = this.pv.name;
    const defaultValue = _operations_sop_AttribSetAtIndex__WEBPACK_IMPORTED_MODULE_0__/* .AttribSetAtIndexSopOperation.defaultAttribValue */ .Y.defaultAttribValue(this.pv);
    if (defaultValue != null) {
      for (const coreObject2 of allCoreObjects) {
        if (!coreObject2.hasAttribute(attribName)) {
          coreObject2.setAttribValue(attribName, defaultValue);
        }
      }
    }
    const coreObject = allCoreObjects[this.pv.index];
    if (!coreObject) {
      return;
    }
    switch (attribType) {
      case _core_geometry_Constant__WEBPACK_IMPORTED_MODULE_2__/* .AttribType.NUMERIC */ .rp.NUMERIC:
        this._addNumericAttributeToObject(coreObject);
        return;
      case _core_geometry_Constant__WEBPACK_IMPORTED_MODULE_2__/* .AttribType.STRING */ .rp.STRING:
        this._addStringAttributeToObject(coreObject);
        return;
    }
    _poly_Assert__WEBPACK_IMPORTED_MODULE_4__/* .TypeAssert.unreachable */ .f.unreachable(attribType);
  }
  _addCoreGroupAttribute(attribType, coreGroup) {
    switch (attribType) {
      case _core_geometry_Constant__WEBPACK_IMPORTED_MODULE_2__/* .AttribType.NUMERIC */ .rp.NUMERIC:
        this._addNumericAttributeToCoreGroup(coreGroup);
        return;
      case _core_geometry_Constant__WEBPACK_IMPORTED_MODULE_2__/* .AttribType.STRING */ .rp.STRING:
        this._addStringAttributeToCoreGroup(coreGroup);
        return;
    }
    _poly_Assert__WEBPACK_IMPORTED_MODULE_4__/* .TypeAssert.unreachable */ .f.unreachable(attribType);
  }
  _addNumericAttributeToPoints(object) {
    const corePointClass = (0,_core_geometry_CoreObjectFactory__WEBPACK_IMPORTED_MODULE_5__/* .corePointClassFactory */ .E_)(object);
    const attribName = _core_geometry_Attribute__WEBPACK_IMPORTED_MODULE_6__/* .CoreAttribute.remapName */ .n0.remapName(this.pv.name);
    if (!corePointClass.hasAttribute(object, attribName)) {
      corePointClass.addNumericAttribute(object, attribName, this.pv.size, 0);
    }
    const attrib = corePointClass.attribute(object, attribName);
    const array = attrib.array;
    const { index, size } = this.pv;
    switch (size) {
      case 1: {
        if (index < array.length) {
          array[index] = this.pv.value1;
          attrib.needsUpdate = true;
        }
        break;
      }
      case 2: {
        const i2 = index * 2;
        if (i2 < array.length) {
          this.pv.value2.toArray(array, i2);
          attrib.needsUpdate = true;
        }
        break;
      }
      case 3: {
        const i3 = index * 3;
        if (i3 < array.length) {
          this.pv.value3.toArray(array, i3);
          attrib.needsUpdate = true;
        }
        break;
      }
      case 4: {
        const i4 = index * 4;
        if (i4 < array.length) {
          this.pv.value4.toArray(array, i4);
          attrib.needsUpdate = true;
        }
        break;
      }
    }
  }
  _addNumericAttributeToObject(coreObject) {
    const param = [this.p.value1, this.p.value2, this.p.value3, this.p.value4][this.pv.size - 1];
    const attribName = this.pv.name;
    coreObject.setAttribValue(attribName, param.value);
  }
  _addNumericAttributeToCoreGroup(coreGroup) {
    const param = [this.p.value1, this.p.value2, this.p.value3, this.p.value4][this.pv.size - 1];
    const attribName = this.pv.name;
    coreGroup.setAttribValue(attribName, param.value);
  }
  _addStringAttributeToPoints(object) {
    const corePointClass = (0,_core_geometry_CoreObjectFactory__WEBPACK_IMPORTED_MODULE_5__/* .corePointClassFactory */ .E_)(object);
    const attribName = this.pv.name;
    if (!corePointClass.hasAttribute(object, attribName)) {
      const tmpIndexData = _core_geometry_Attribute__WEBPACK_IMPORTED_MODULE_6__/* .CoreAttribute.arrayToIndexedArrays */ .n0.arrayToIndexedArrays([""]);
      corePointClass.setIndexedAttribute(object, attribName, tmpIndexData["values"], tmpIndexData["indices"]);
    }
    (0,_core_geometry_entities_point_CorePointUtils__WEBPACK_IMPORTED_MODULE_7__/* .pointsFromObject */ .u_)(object, _allPoints);
    const param = this.p.string;
    const stringValues = new Array(_allPoints.length);
    for (const point of _allPoints) {
      let currentValue = point.stringAttribValue(attribName);
      if (currentValue == null) {
        currentValue = "";
      }
      stringValues[point.index()] = currentValue;
    }
    const indexPoint = _allPoints[this.pv.index];
    if (indexPoint) {
      stringValues[indexPoint.index()] = param.value;
    }
    const indexData = _core_geometry_Attribute__WEBPACK_IMPORTED_MODULE_6__/* .CoreAttribute.arrayToIndexedArrays */ .n0.arrayToIndexedArrays(stringValues);
    corePointClass.setIndexedAttribute(object, attribName, indexData["values"], indexData["indices"]);
  }
  _addStringAttributeToObject(coreObject) {
    const param = this.p.string;
    const attribName = this.pv.name;
    coreObject.setAttribValue(attribName, param.value);
  }
  _addStringAttributeToCoreGroup(coreGroup) {
    const param = this.p.string;
    const attribName = this.pv.name;
    coreGroup.setAttribValue(attribName, param.value);
  }
  //
  //
  // CHECK IF EXPRESSION IS BEING USED, TO ALLOW EASY SWITCH TO OPERATION
  //
  //
  _isUsingExpression() {
    const attribType = _core_geometry_Constant__WEBPACK_IMPORTED_MODULE_2__/* .ATTRIBUTE_TYPES */ .Xu[this.pv.type];
    switch (attribType) {
      case _core_geometry_Constant__WEBPACK_IMPORTED_MODULE_2__/* .AttribType.NUMERIC */ .rp.NUMERIC:
        const param = [this.p.value1, this.p.value2, this.p.value3, this.p.value4][this.pv.size - 1];
        return param.hasExpression();
      case _core_geometry_Constant__WEBPACK_IMPORTED_MODULE_2__/* .AttribType.STRING */ .rp.STRING:
        return this.p.string.hasExpression();
    }
  }
  //
  //
  // API UTILS
  //
  //
  setAttribClass(attribClass) {
    this.p.class.set(_core_geometry_Constant__WEBPACK_IMPORTED_MODULE_2__/* .ATTRIBUTE_CLASSES.indexOf */ .oT.indexOf(attribClass));
  }
  attribClass() {
    return _core_geometry_Constant__WEBPACK_IMPORTED_MODULE_2__/* .ATTRIBUTE_CLASSES */ .oT[this.pv.class];
  }
  setAttribType(type) {
    this.p.type.set(_core_geometry_Constant__WEBPACK_IMPORTED_MODULE_2__/* .ATTRIBUTE_TYPES.indexOf */ .Xu.indexOf(type));
  }
  attribType() {
    return _core_geometry_Constant__WEBPACK_IMPORTED_MODULE_2__/* .ATTRIBUTE_TYPES */ .Xu[this.pv.type];
  }
}


/***/ }),

/***/ 6479:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {


// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  "D": function() { return /* binding */ AttribTransferSopNode; }
});

// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/nodes/sop/_Base.ts
var _Base = __webpack_require__(55839);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/node_modules/three/build/three.module.js
var three_module = __webpack_require__(21410);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/core/ArrayUtils.ts
var ArrayUtils = __webpack_require__(87132);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/core/Type.ts
var Type = __webpack_require__(19037);
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/core/math/Interpolate.ts




const _positionSrc = new three_module.Vector3();
const _positionDest = new three_module.Vector3();
class CoreInterpolate {
  static perform(point_dest, points_src, attrib_name, distance_threshold, blend_with) {
    switch (points_src.length) {
      case 0:
        return point_dest.attribValue(attrib_name);
      case 1:
        return this._interpolate_with_1_point(
          point_dest,
          points_src[0],
          attrib_name,
          distance_threshold,
          blend_with
        );
      default:
        return this._interpolate_with_multiple_points(
          point_dest,
          points_src,
          attrib_name,
          distance_threshold,
          blend_with
        );
    }
  }
  static _interpolate_with_1_point(point_dest, point_src, attrib_name, distance_threshold, blend_with) {
    point_dest.position(_positionDest);
    point_src.position(_positionSrc);
    const distance = _positionDest.distanceTo(_positionSrc);
    const value_src = point_src.attribValue(attrib_name);
    if (Type/* CoreType.isNumber */.MR.isNumber(value_src)) {
      return this._weighted_value_from_distance(
        point_dest,
        value_src,
        attrib_name,
        distance,
        distance_threshold,
        blend_with
      );
    } else {
      console.warn("value is not a number", value_src);
      return 0;
    }
  }
  static _weight_from_distance(distance, distance_threshold, blend_with) {
    return (distance - distance_threshold) / blend_with;
  }
  static _weighted_value_from_distance(point_dest, value_src, attrib_name, distance, distance_threshold, blend_with) {
    if (distance <= distance_threshold) {
      return value_src;
    } else {
      const value_dest = point_dest.attribValue(attrib_name);
      if (Type/* CoreType.isNumber */.MR.isNumber(value_dest)) {
        const blend = this._weight_from_distance(distance, distance_threshold, blend_with);
        return blend * value_dest + (1 - blend) * value_src;
      } else {
        console.warn("value is not a number", value_dest);
        return 0;
      }
    }
  }
  static _interpolate_with_multiple_points(point_dest, points_src, attrib_name, distance_threshold, blend_with) {
    const weighted_values_src = points_src.map((point_src) => {
      return this._interpolate_with_1_point(point_dest, point_src, attrib_name, distance_threshold, blend_with);
    });
    return (0,ArrayUtils/* arrayMax */.uH)(weighted_values_src) || 0;
  }
  // https://math.stackexchange.com/questions/1336386/weighted-average-distance-between-3-or-more-positions
  static weights(current_position, other_positions) {
    switch (other_positions.length) {
      case 1:
        return 1;
      case 2:
        return this._weights_from_2(current_position, other_positions);
      default:
        other_positions = other_positions.slice(0, 3);
        return this._weights_from_3(current_position, other_positions);
    }
  }
  static _weights_from_2(current_position, other_positions) {
    const dist_to_positions = other_positions.map((other_position) => current_position.distanceTo(other_position));
    const distance_total = (0,ArrayUtils/* arraySum */.dD)(dist_to_positions);
    return [dist_to_positions[1] / distance_total, dist_to_positions[0] / distance_total];
  }
  static _weights_from_3(current_position, other_positions) {
    const dist_to_positions = other_positions.map((other_position) => current_position.distanceTo(other_position));
    const distance_total = (0,ArrayUtils/* arraySum */.dD)([
      dist_to_positions[0] * dist_to_positions[1],
      dist_to_positions[0] * dist_to_positions[2],
      dist_to_positions[1] * dist_to_positions[2]
    ]);
    return [
      dist_to_positions[1] * dist_to_positions[2] / distance_total,
      dist_to_positions[0] * dist_to_positions[2] / distance_total,
      dist_to_positions[0] * dist_to_positions[1] / distance_total
    ];
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/core/math/octree/Node.ts


const _position = new three_module.Vector3();
class OctreeNode {
  constructor(_bbox, _level = 0) {
    this._bbox = _bbox;
    this._level = _level;
    this._leavesByOctant = {};
    this._pointsByOctantId = {};
    this._leaves = [];
    this._boundingBoxesByOctant = {};
    this._boundingBoxesByOctantPrepared = false;
    this._center = this._bbox.max.clone().add(this._bbox.min).multiplyScalar(0.5);
  }
  level() {
    return this._level;
  }
  traverse(callback) {
    callback(this);
    const octants = Object.values(this._leavesByOctant);
    octants.forEach((node) => {
      node.traverse(callback);
    });
  }
  intersectsSphere(sphere) {
    if (this._bbox) {
      return this._bbox.intersectsSphere(sphere);
    }
    return false;
  }
  pointsInSphere(sphere, accumulatedPoints) {
    if (this._leaves.length == 0) {
      const foundPoints = Object.values(this._pointsByOctantId).flat();
      const selectedPoints = foundPoints.filter((point) => sphere.containsPoint(point.position(_position)));
      selectedPoints.forEach((point) => {
        accumulatedPoints.push(point);
      });
    } else {
      const leaves_intersecting_with_sphere = this._leaves.filter((leaf) => leaf.intersectsSphere(sphere));
      leaves_intersecting_with_sphere.forEach((leaf) => leaf.pointsInSphere(sphere, accumulatedPoints));
    }
  }
  boundingBox() {
    return this._bbox;
  }
  setPoints(points) {
    this._pointsByOctantId = {};
    for (const point of points) {
      this.addPoint(point);
    }
    const octantIds = Object.keys(this._pointsByOctantId);
    if (octantIds.length > 1) {
      for (const octantId of octantIds) {
        this.createLeaf(octantId);
      }
    }
  }
  createLeaf(octantId) {
    const box = this._leafBbox(octantId);
    const leaf = new OctreeNode(box, this._level + 1);
    this._leavesByOctant[octantId] = leaf;
    this._leaves.push(leaf);
    leaf.setPoints(this._pointsByOctantId[octantId]);
  }
  addPoint(point) {
    const octantId = this._octantId(point.position(_position));
    if (this._pointsByOctantId[octantId] == null) {
      this._pointsByOctantId[octantId] = [];
    }
    this._pointsByOctantId[octantId].push(point);
  }
  _octantId(position) {
    const x_pos = position.x > this._center.x ? 1 : 0;
    const y_pos = position.y > this._center.y ? 1 : 0;
    const z_pos = position.z > this._center.z ? 1 : 0;
    return `${x_pos}${y_pos}${z_pos}`;
  }
  _leafBbox(octantId) {
    if (!this._boundingBoxesByOctantPrepared) {
      this._prepareLeavesBboxes();
      this._boundingBoxesByOctantPrepared = true;
    }
    return this._boundingBoxesByOctant[octantId];
  }
  _bboxCenter(x_pos, y_pos, z_pos, target) {
    target.copy(this._bbox.min);
    if (x_pos == 1) {
      target.x = this._bbox.max.x;
    }
    if (y_pos == 1) {
      target.y = this._bbox.max.y;
    }
    if (z_pos == 1) {
      target.z = this._bbox.max.z;
    }
    target.add(this._center).multiplyScalar(0.5);
  }
  _prepareLeavesBboxes() {
    const bboxCenters = [
      new three_module.Vector3(),
      new three_module.Vector3(),
      new three_module.Vector3(),
      new three_module.Vector3(),
      new three_module.Vector3(),
      new three_module.Vector3(),
      new three_module.Vector3(),
      new three_module.Vector3()
    ];
    this._bboxCenter(0, 0, 0, bboxCenters[0]);
    this._bboxCenter(0, 0, 1, bboxCenters[1]);
    this._bboxCenter(0, 1, 0, bboxCenters[2]);
    this._bboxCenter(0, 1, 1, bboxCenters[3]);
    this._bboxCenter(1, 0, 0, bboxCenters[4]);
    this._bboxCenter(1, 0, 1, bboxCenters[5]);
    this._bboxCenter(1, 1, 0, bboxCenters[6]);
    this._bboxCenter(1, 1, 1, bboxCenters[7]);
    const bboxSizeQuarter = this._bbox.max.clone().sub(this._bbox.min).multiplyScalar(0.25);
    for (const bboxCenter of bboxCenters) {
      const octantId = this._octantId(bboxCenter);
      const bbox = new three_module.Box3(bboxCenter.clone().sub(bboxSizeQuarter), bboxCenter.clone().add(bboxSizeQuarter));
      this._boundingBoxesByOctant[octantId] = bbox;
    }
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/core/math/octree/Octree.ts




const Octree_position = new three_module.Vector3();
class CoreOctree {
  constructor(bbox) {
    this._root = new OctreeNode(bbox);
  }
  setPoints(points) {
    this._root.setPoints(points);
  }
  traverse(callback) {
    this._root.traverse(callback);
  }
  // TODO: I am tempted to stop going through the leaves if
  // the ones currently seen already have the required number of points.
  // but that probably doesn't work as those points may end up being further
  // than the ones from the following leaf
  findPoints(position, distance, maxPointsCount, target) {
    const sphere = new three_module.Sphere(position, distance);
    if (this._root.intersectsSphere(sphere)) {
      this._root.pointsInSphere(sphere, target);
    }
    if (maxPointsCount == null) {
      return;
    } else {
      if (target.length > maxPointsCount) {
        target = (0,ArrayUtils/* arraySortBy */.Zg)(target, (point) => {
          return point.position(Octree_position).distanceTo(position);
        });
        target = target.slice(0, maxPointsCount);
      }
    }
  }
}

// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/Poly.ts + 21 modules
var Poly = __webpack_require__(99934);
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/core/Iterator.ts

var __async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};

class CoreIterator {
  constructor(options = {}) {
    this._array_index = 0;
    // count
    this._count = 0;
    this._current_count_index = 0;
    this._resolve = null;
    this._max_time_per_chunk = options.max_time_per_chunk || 10;
    this._check_every_interations = options.check_every_interations || 100;
  }
  startWithCount(count, iteratee_method) {
    return __async(this, null, function* () {
      this._count = count;
      this._current_count_index = 0;
      this._iteratee_method_count = iteratee_method;
      this._bound_next_with_count = this.nextWithCount.bind(this);
      if (this._resolve) {
        throw "an iterator cannot be started twice";
      }
      return new Promise((resolve, reject) => {
        this._resolve = resolve;
        this.nextWithCount();
      });
    });
  }
  nextWithCount() {
    const performance = Poly/* Poly.performance.performanceManager */.L.performance.performanceManager();
    const start_time = performance.now();
    if (this._iteratee_method_count && this._bound_next_with_count) {
      while (this._current_count_index < this._count) {
        this._iteratee_method_count(this._current_count_index);
        this._current_count_index++;
        if (this._current_count_index % this._check_every_interations == 0) {
          if (performance.now() - start_time > this._max_time_per_chunk) {
            setTimeout(this._bound_next_with_count, 1);
            break;
          }
        }
      }
    }
    if (this._current_count_index >= this._count) {
      if (this._resolve) {
        this._resolve();
      }
    }
  }
  //
  //
  // ARRAY
  //
  //
  startWithArray(array, iteratee_method) {
    return __async(this, null, function* () {
      this._array = array;
      this._array_index = 0;
      this._iteratee_method_array = iteratee_method;
      this._bound_next_with_array = this.nextWithArray.bind(this);
      if (this._resolve) {
        throw "an iterator cannot be started twice";
      }
      return new Promise((resolve, reject) => {
        this._resolve = resolve;
        this.nextWithArray();
      });
    });
  }
  nextWithArray() {
    const performance = Poly/* Poly.performance.performanceManager */.L.performance.performanceManager();
    const start_time = performance.now();
    if (this._iteratee_method_array && this._bound_next_with_array && this._array) {
      while (this._current_array_element = this._array[this._array_index]) {
        this._iteratee_method_array(this._current_array_element, this._array_index);
        this._array_index++;
        if (this._array_index % this._check_every_interations == 0) {
          if (performance.now() - start_time > this._max_time_per_chunk) {
            setTimeout(this._bound_next_with_array, 1);
            break;
          }
        }
      }
    }
    if (this._current_array_element === void 0) {
      if (this._resolve) {
        this._resolve();
      }
    }
  }
}

// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/nodes/utils/params/ParamsConfig.ts
var ParamsConfig = __webpack_require__(96949);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/poly/InputCloneMode.ts
var InputCloneMode = __webpack_require__(56752);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/poly/registers/nodes/types/Sop.ts
var Sop = __webpack_require__(58986);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/core/geometry/CoreObjectFactory.ts
var CoreObjectFactory = __webpack_require__(17353);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/core/geometry/entities/point/CorePointUtils.ts
var CorePointUtils = __webpack_require__(50253);
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/sop/AttribTransfer.ts

var AttribTransfer_async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};










const _tmpBox = new three_module.Box3();
const AttribTransfer_position = new three_module.Vector3();
const _nearestPoints = [];
const _pointsSrc = [];
class AttribTransferSopParamsConfig extends ParamsConfig/* NodeParamsConfig */.yI {
  constructor() {
    super(...arguments);
    /** @param source group to transfer from (right input, or input 1) */
    this.srcGroup = ParamsConfig/* ParamConfig.STRING */.XC.STRING();
    /** @param dest group to transfer to (left input, or input 0) */
    this.destGroup = ParamsConfig/* ParamConfig.STRING */.XC.STRING();
    /** @param name of the attribute to transfer */
    this.name = ParamsConfig/* ParamConfig.STRING */.XC.STRING();
    /** @param max number of samples to use */
    this.maxSamplesCount = ParamsConfig/* ParamConfig.INTEGER */.XC.INTEGER(1, {
      range: [1, 10],
      rangeLocked: [true, false]
    });
    /** @param max distance to search points to transfer from */
    this.distanceThreshold = ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(1);
    /** @param blend width */
    this.blendWidth = ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(0);
  }
}
const AttribTransfer_ParamsConfig = new AttribTransferSopParamsConfig();
class AttribTransferSopNode extends _Base/* TypedSopNode */.x {
  constructor() {
    super(...arguments);
    this.paramsConfig = AttribTransfer_ParamsConfig;
  }
  static type() {
    return Sop/* SopType.ATTRIB_TRANSFER */.aB.ATTRIB_TRANSFER;
  }
  initializeNode() {
    this.io.inputs.setCount(2);
    this.io.inputs.initInputsClonedState([InputCloneMode/* InputCloneMode.FROM_NODE */.m.FROM_NODE, InputCloneMode/* InputCloneMode.NEVER */.m.NEVER]);
  }
  cook(inputCoreGroups) {
    return AttribTransfer_async(this, null, function* () {
      const coreGroupDest = inputCoreGroups[0];
      const coreGroupSrc = inputCoreGroups[1];
      coreGroupSrc.pointsFromGroup(this.pv.srcGroup, _pointsSrc);
      coreGroupSrc.boundingBox(_tmpBox);
      const octree = new CoreOctree(_tmpBox);
      octree.setPoints(_pointsSrc);
      const destObjects = coreGroupDest.allObjects();
      const srcObjects = coreGroupSrc.allObjects();
      let i = 0;
      for (const destObject of destObjects) {
        const srcObject = srcObjects[i];
        const corePointClass = (0,CoreObjectFactory/* corePointClassFactory */.E_)(destObject);
        const attributeNames = corePointClass.attributeNamesMatchingMask(srcObject, this.pv.name);
        this._addAttributeIfRequired(destObject, srcObject, attributeNames);
        yield this._transferAttributes(destObject, octree, attributeNames);
        i++;
      }
      this.setCoreGroup(coreGroupDest);
    });
  }
  _transferAttributes(object, octree, attribNames) {
    return AttribTransfer_async(this, null, function* () {
      const callback = (destPoint) => {
        this._transferAttributesForPoint(destPoint, octree, attribNames);
      };
      const destPoints = [];
      (0,CorePointUtils/* pointsFromObjectFromGroup */.WS)(object, this.pv.destGroup, destPoints);
      const _iterator = new CoreIterator();
      yield _iterator.startWithArray(destPoints, callback);
    });
  }
  _addAttributeIfRequired(destObject, srcObject, attribNames) {
    for (const attribName of attribNames) {
      const corePointClass = (0,CoreObjectFactory/* corePointClassFactory */.E_)(destObject);
      const hasAttrib = corePointClass.hasAttribute(destObject, attribName);
      if (!hasAttrib) {
        const attribSize = corePointClass.attribSize(srcObject, attribName);
        corePointClass.addNumericAttribute(destObject, attribName, attribSize, 0);
      }
    }
  }
  _transferAttributesForPoint(destPoint, octree, attribNames) {
    const totalDist = this.pv.distanceThreshold + this.pv.blendWidth;
    destPoint.position(AttribTransfer_position);
    octree.findPoints(AttribTransfer_position, totalDist, this.pv.maxSamplesCount, _nearestPoints);
    for (const attribName of attribNames) {
      this._interpolatePoints(destPoint, _nearestPoints, attribName);
    }
  }
  _interpolatePoints(pointDest, srcPoints, attribName) {
    const newValue = CoreInterpolate.perform(
      pointDest,
      srcPoints,
      attribName,
      this.pv.distanceThreshold,
      this.pv.blendWidth
    );
    if (newValue != null) {
      pointDest.setAttribValue(attribName, newValue);
    }
  }
}


/***/ }),

/***/ 97619:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "b": function() { return /* binding */ AudioNotesSopNode; }
/* harmony export */ });
/* harmony import */ var _Base__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(55839);
/* harmony import */ var _core_geometry_Constant__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(91568);
/* harmony import */ var _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(96949);
/* harmony import */ var _operations_sop_AudioNotes__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(9733);
/* harmony import */ var _poly_registers_nodes_types_Sop__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(58986);






const DEFAULT = _operations_sop_AudioNotes__WEBPACK_IMPORTED_MODULE_0__/* .AudioNotesSopOperation.DEFAULT_PARAMS */ .R.DEFAULT_PARAMS;
class AudioNotesSopParamsConfig extends _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .NodeParamsConfig */ .yI {
  constructor() {
    super(...arguments);
    /** @param the attribute class (geometry or object) */
    this.class = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .ParamConfig.INTEGER */ .XC.INTEGER(DEFAULT.class, {
      menu: {
        entries: _core_geometry_Constant__WEBPACK_IMPORTED_MODULE_2__/* .AttribClassMenuEntries */ .yp
      }
    });
    /** @param attribute name */
    this.name = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .ParamConfig.STRING */ .XC.STRING(DEFAULT.name);
    /** @param adds an octave attribute */
    this.toctave = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .ParamConfig.BOOLEAN */ .XC.BOOLEAN(0);
    /** @param octave attribute name */
    this.octaveName = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .ParamConfig.STRING */ .XC.STRING(DEFAULT.octaveName, {
      visibleIf: { toctave: 1 }
    });
    /** @param octave to start iterating the notes from */
    this.startOctave = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .ParamConfig.INTEGER */ .XC.INTEGER(DEFAULT.startOctave, { range: [1, 8], rangeLocked: [true, true] });
    /** @param last octave up to which the nodes will be added */
    this.endOctave = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .ParamConfig.INTEGER */ .XC.INTEGER(DEFAULT.endOctave, { range: [1, 8], rangeLocked: [true, true] });
    /** @param behavior if there are more objects than notes within the selected octave range */
    this.outOfRangeBehavior = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .ParamConfig.INTEGER */ .XC.INTEGER(DEFAULT.outOfRangeBehavior, {
      menu: {
        entries: _operations_sop_AudioNotes__WEBPACK_IMPORTED_MODULE_0__/* .OUT_OF_RANGE_BEHAVIOR.map */ .d.map((name, i) => {
          return { value: i, name };
        })
      }
    });
  }
}
const ParamsConfig = new AudioNotesSopParamsConfig();
class AudioNotesSopNode extends _Base__WEBPACK_IMPORTED_MODULE_3__/* .TypedSopNode */ .x {
  constructor() {
    super(...arguments);
    this.paramsConfig = ParamsConfig;
  }
  static type() {
    return _poly_registers_nodes_types_Sop__WEBPACK_IMPORTED_MODULE_4__/* .SopType.AUDIO_NOTES */ .aB.AUDIO_NOTES;
  }
  initializeNode() {
    this.io.inputs.setCount(1);
    this.io.inputs.initInputsClonedState(_operations_sop_AudioNotes__WEBPACK_IMPORTED_MODULE_0__/* .AudioNotesSopOperation.INPUT_CLONED_STATE */ .R.INPUT_CLONED_STATE);
  }
  cook(input_contents) {
    this._operation = this._operation || new _operations_sop_AudioNotes__WEBPACK_IMPORTED_MODULE_0__/* .AudioNotesSopOperation */ .R(this.scene(), this.states, this);
    const core_group = this._operation.cook(input_contents, this.pv);
    this.setCoreGroup(core_group);
  }
  //
  //
  // API UTILS
  //
  //
  setAttribClass(attribClass) {
    this.p.class.set(_core_geometry_Constant__WEBPACK_IMPORTED_MODULE_2__/* .ATTRIBUTE_CLASSES.indexOf */ .oT.indexOf(attribClass));
  }
  attribClass() {
    return _core_geometry_Constant__WEBPACK_IMPORTED_MODULE_2__/* .ATTRIBUTE_CLASSES */ .oT[this.pv.class];
  }
}


/***/ }),

/***/ 80444:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "c": function() { return /* binding */ BboxScatterSopNode; }
/* harmony export */ });
/* harmony import */ var _Base__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(55839);
/* harmony import */ var _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(96949);
/* harmony import */ var _poly_InputCloneMode__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(56752);
/* harmony import */ var _operations_sop_BboxScatter__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(88423);
/* harmony import */ var _poly_registers_nodes_types_Sop__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(58986);






class BboxScatterSopParamsConfig extends _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_0__/* .NodeParamsConfig */ .yI {
  constructor() {
    super(...arguments);
    /** @param the smaller the step size, the more points this will create */
    this.stepSize = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_0__/* .ParamConfig.FLOAT */ .XC.FLOAT(0.1);
  }
}
const ParamsConfig = new BboxScatterSopParamsConfig();
class BboxScatterSopNode extends _Base__WEBPACK_IMPORTED_MODULE_1__/* .TypedSopNode */ .x {
  constructor() {
    super(...arguments);
    this.paramsConfig = ParamsConfig;
  }
  static type() {
    return _poly_registers_nodes_types_Sop__WEBPACK_IMPORTED_MODULE_2__/* .SopType.BBOX_SCATTER */ .aB.BBOX_SCATTER;
  }
  initializeNode() {
    this.io.inputs.setCount(1);
    this.io.inputs.initInputsClonedState(_poly_InputCloneMode__WEBPACK_IMPORTED_MODULE_3__/* .InputCloneMode.NEVER */ .m.NEVER);
  }
  cook(input_contents) {
    this._operation = this._operation || new _operations_sop_BboxScatter__WEBPACK_IMPORTED_MODULE_4__/* .BboxScatterSopOperation */ .U(this._scene, this.states, this);
    const core_group = this._operation.cook(input_contents, this.pv);
    this.setCoreGroup(core_group);
  }
}


/***/ }),

/***/ 85976:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "z": function() { return /* binding */ BooleanSopNode; }
/* harmony export */ });
/* harmony import */ var _Base__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(55839);
/* harmony import */ var _operations_sop_Boolean__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(90243);
/* harmony import */ var _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(96949);




const DEFAULT = _operations_sop_Boolean__WEBPACK_IMPORTED_MODULE_0__/* .BooleanSopOperation.DEFAULT_PARAMS */ .GJ.DEFAULT_PARAMS;
class BooleanSopParamsConfig extends _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .NodeParamsConfig */ .yI {
  constructor() {
    super(...arguments);
    /** @param url to load the geometry from */
    this.operation = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .ParamConfig.INTEGER */ .XC.INTEGER(DEFAULT.operation, {
      menu: {
        entries: _operations_sop_Boolean__WEBPACK_IMPORTED_MODULE_0__/* .BOOLEAN_OPERATIONS.map */ .x8.map((name, value) => {
          return { name, value };
        })
      },
      separatorAfter: true
    });
    /** @param preserves the color attribute of both input */
    this.keepVertexColor = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .ParamConfig.BOOLEAN */ .XC.BOOLEAN(DEFAULT.keepVertexColor);
    /** @param add any additional attribute to be preserved */
    this.additionalAttributes = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .ParamConfig.STRING */ .XC.STRING(DEFAULT.additionalAttributes, {
      separatorAfter: true
    });
    /** @param defines if only the material from the first input is used, or if the ones from both inputs should be used */
    this.keepMaterials = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .ParamConfig.BOOLEAN */ .XC.BOOLEAN(DEFAULT.keepMaterials);
    /** @param if one of the input has multiple material for a single object, and you'd like to preserve those, toggle this on */
    this.useInputGroups = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .ParamConfig.BOOLEAN */ .XC.BOOLEAN(DEFAULT.useInputGroups);
    /** @param intersectionEdgesOnly */
    this.intersectionEdgesOnly = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .ParamConfig.BOOLEAN */ .XC.BOOLEAN(DEFAULT.intersectionEdgesOnly);
  }
}
const ParamsConfig = new BooleanSopParamsConfig();
class BooleanSopNode extends _Base__WEBPACK_IMPORTED_MODULE_2__/* .TypedSopNode */ .x {
  constructor() {
    super(...arguments);
    this.paramsConfig = ParamsConfig;
  }
  static type() {
    return "boolean";
  }
  initializeNode() {
    this.io.inputs.setCount(2);
    this.io.inputs.initInputsClonedState(_operations_sop_Boolean__WEBPACK_IMPORTED_MODULE_0__/* .BooleanSopOperation.INPUT_CLONED_STATE */ .GJ.INPUT_CLONED_STATE);
  }
  setOperation(operation) {
    this.p.operation.set(_operations_sop_Boolean__WEBPACK_IMPORTED_MODULE_0__/* .BOOLEAN_OPERATIONS.indexOf */ .x8.indexOf(operation));
  }
  cook(inputCoreGroups) {
    this._operation = this._operation || new _operations_sop_Boolean__WEBPACK_IMPORTED_MODULE_0__/* .BooleanSopOperation */ .GJ(this.scene(), this.states, this);
    const coreGroup = this._operation.cook(inputCoreGroups, this.pv);
    this.setCoreGroup(coreGroup);
  }
}


/***/ }),

/***/ 3934:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "R": function() { return /* binding */ BoxSopNode; }
/* harmony export */ });
/* harmony import */ var _Base__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(55839);
/* harmony import */ var _operations_sop_Box__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(32458);
/* harmony import */ var _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(96949);
/* harmony import */ var _poly_registers_nodes_types_Sop__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(58986);





const DEFAULT = _operations_sop_Box__WEBPACK_IMPORTED_MODULE_0__/* .BoxSopOperation.DEFAULT_PARAMS */ .v.DEFAULT_PARAMS;
class BoxSopParamsConfig extends _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .NodeParamsConfig */ .yI {
  constructor() {
    super(...arguments);
    /** @param size of the box */
    this.size = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .ParamConfig.FLOAT */ .XC.FLOAT(DEFAULT.size, {
      range: [0, 2],
      rangeLocked: [true, false]
    });
    /** @param sizes on each axis */
    this.sizes = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .ParamConfig.VECTOR3 */ .XC.VECTOR3(DEFAULT.sizes);
    /** @param number of segments on each axis */
    this.divisions = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .ParamConfig.VECTOR3 */ .XC.VECTOR3(DEFAULT.divisions);
    /** @param center of the geometry */
    this.center = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .ParamConfig.VECTOR3 */ .XC.VECTOR3(DEFAULT.center);
  }
}
const ParamsConfig = new BoxSopParamsConfig();
class BoxSopNode extends _Base__WEBPACK_IMPORTED_MODULE_2__/* .TypedSopNode */ .x {
  constructor() {
    super(...arguments);
    this.paramsConfig = ParamsConfig;
  }
  static type() {
    return _poly_registers_nodes_types_Sop__WEBPACK_IMPORTED_MODULE_3__/* .SopType.BOX */ .aB.BOX;
  }
  initializeNode() {
    this.io.inputs.setCount(0, 1);
    this.io.inputs.initInputsClonedState(_operations_sop_Box__WEBPACK_IMPORTED_MODULE_0__/* .BoxSopOperation.INPUT_CLONED_STATE */ .v.INPUT_CLONED_STATE);
  }
  cook(inputCoreGroups) {
    this._operation = this._operation || new _operations_sop_Box__WEBPACK_IMPORTED_MODULE_0__/* .BoxSopOperation */ .v(this._scene, this.states, this);
    const coreGroup = this._operation.cook(inputCoreGroups, this.pv);
    this.setCoreGroup(coreGroup);
  }
}


/***/ }),

/***/ 95456:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "n": function() { return /* binding */ BoxLinesSopNode; }
/* harmony export */ });
/* harmony import */ var _Base__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(55839);
/* harmony import */ var _operations_sop_BoxLines__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(22520);
/* harmony import */ var _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(96949);
/* harmony import */ var _poly_registers_nodes_types_Sop__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(58986);





const DEFAULT = _operations_sop_BoxLines__WEBPACK_IMPORTED_MODULE_0__/* .BoxLinesSopOperation.DEFAULT_PARAMS */ .Z.DEFAULT_PARAMS;
class BoxLinesSopParamsConfig extends _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .NodeParamsConfig */ .yI {
  constructor() {
    super(...arguments);
    /** @param size of the box */
    this.size = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .ParamConfig.FLOAT */ .XC.FLOAT(DEFAULT.size, {
      range: [0, 2],
      rangeLocked: [true, false]
    });
    /** @param sizes on each axis */
    this.sizes = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .ParamConfig.VECTOR3 */ .XC.VECTOR3(DEFAULT.sizes);
    /** @param divisions on each axis */
    this.divisions = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .ParamConfig.VECTOR3 */ .XC.VECTOR3(DEFAULT.divisions);
    /** @param center of the geometry */
    this.center = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .ParamConfig.VECTOR3 */ .XC.VECTOR3(DEFAULT.center);
  }
}
const ParamsConfig = new BoxLinesSopParamsConfig();
class BoxLinesSopNode extends _Base__WEBPACK_IMPORTED_MODULE_2__/* .TypedSopNode */ .x {
  constructor() {
    super(...arguments);
    this.paramsConfig = ParamsConfig;
  }
  static type() {
    return _poly_registers_nodes_types_Sop__WEBPACK_IMPORTED_MODULE_3__/* .SopType.BOX_LINES */ .aB.BOX_LINES;
  }
  initializeNode() {
    this.io.inputs.setCount(0, 1);
    this.io.inputs.initInputsClonedState(_operations_sop_BoxLines__WEBPACK_IMPORTED_MODULE_0__/* .BoxLinesSopOperation.INPUT_CLONED_STATE */ .Z.INPUT_CLONED_STATE);
  }
  cook(inputCoreGroups) {
    this._operation = this._operation || new _operations_sop_BoxLines__WEBPACK_IMPORTED_MODULE_0__/* .BoxLinesSopOperation */ .Z(this._scene, this.states, this);
    const coreGroup = this._operation.cook(inputCoreGroups, this.pv);
    this.setCoreGroup(coreGroup);
  }
}


/***/ }),

/***/ 54389:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "$L": function() { return /* binding */ CADBooleanSopNode; }
/* harmony export */ });
/* unused harmony exports BooleanCadOperationType, BOOLEAN_CAD_OPERATION_TYPES */
/* harmony import */ var _BaseCAD__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(85315);
/* harmony import */ var _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(96949);
/* harmony import */ var _core_geometry_modules_cad_CadCommon__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(39244);
/* harmony import */ var _core_geometry_modules_cad_CadObject__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(48376);
/* harmony import */ var _poly_Assert__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(68239);
/* harmony import */ var _poly_registers_nodes_types_Sop__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(58986);
/* harmony import */ var _core_geometry_modules_cad_CadLoaderSync__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(16457);








var BooleanMode = /* @__PURE__ */ ((BooleanMode2) => {
  BooleanMode2["ALL_IN_SEQUENCE"] = "process all in sequence";
  BooleanMode2["ONE_TO_ONE"] = "one to one";
  BooleanMode2["ONE_TO_MANY"] = "one to many";
  return BooleanMode2;
})(BooleanMode || {});
const BOOLEAN_MODES = ["process all in sequence" /* ALL_IN_SEQUENCE */, "one to one" /* ONE_TO_ONE */, "one to many" /* ONE_TO_MANY */];
var BooleanCadOperationType = /* @__PURE__ */ ((BooleanCadOperationType2) => {
  BooleanCadOperationType2["INTERSECT"] = "intersect";
  BooleanCadOperationType2["SECTION"] = "section";
  BooleanCadOperationType2["SUBTRACT"] = "subtract";
  BooleanCadOperationType2["UNION"] = "union";
  return BooleanCadOperationType2;
})(BooleanCadOperationType || {});
const BOOLEAN_CAD_OPERATION_TYPES = [
  "intersect" /* INTERSECT */,
  "subtract" /* SUBTRACT */,
  "union" /* UNION */,
  "section" /* SECTION */
];
class CADBooleanSopParamsConfig extends _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_0__/* .NodeParamsConfig */ .yI {
  constructor() {
    super(...arguments);
    /** @param operation */
    this.operation = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_0__/* .ParamConfig.INTEGER */ .XC.INTEGER(BOOLEAN_CAD_OPERATION_TYPES.indexOf("intersect" /* INTERSECT */), {
      menu: { entries: BOOLEAN_CAD_OPERATION_TYPES.map((name, value) => ({ name, value })) }
    });
    /** @param mode */
    this.mode = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_0__/* .ParamConfig.INTEGER */ .XC.INTEGER(BOOLEAN_MODES.indexOf("one to many" /* ONE_TO_MANY */), {
      menu: {
        entries: BOOLEAN_MODES.map((name, value) => ({ name, value }))
      }
    });
  }
}
const ParamsConfig = new CADBooleanSopParamsConfig();
class CADBooleanSopNode extends _BaseCAD__WEBPACK_IMPORTED_MODULE_1__/* .CADSopNode */ .M {
  constructor() {
    super(...arguments);
    this.paramsConfig = ParamsConfig;
  }
  static type() {
    return _poly_registers_nodes_types_Sop__WEBPACK_IMPORTED_MODULE_2__/* .SopType.CAD_BOOLEAN */ .aB.CAD_BOOLEAN;
  }
  initializeNode() {
    this.io.inputs.setCount(1, 2);
  }
  setOperation(operation) {
    this.p.operation.set(BOOLEAN_CAD_OPERATION_TYPES.indexOf(operation));
  }
  cook(inputCoreGroups) {
    const oc = _core_geometry_modules_cad_CadLoaderSync__WEBPACK_IMPORTED_MODULE_3__/* .CadLoaderSync.oc */ .T.oc();
    const operation = BOOLEAN_CAD_OPERATION_TYPES[this.pv.operation];
    const mode = BOOLEAN_MODES[this.pv.mode];
    switch (mode) {
      case "process all in sequence" /* ALL_IN_SEQUENCE */: {
        return this._createBooleansAllInSequence(oc, operation, inputCoreGroups);
      }
      case "one to one" /* ONE_TO_ONE */: {
        return this._createBooleansOneToOne(oc, operation, inputCoreGroups);
      }
      case "one to many" /* ONE_TO_MANY */: {
        return this._createBooleansOneToMany(oc, operation, inputCoreGroups);
      }
    }
    _poly_Assert__WEBPACK_IMPORTED_MODULE_4__/* .TypeAssert.unreachable */ .f.unreachable(mode);
  }
  _createBooleansAllInSequence(oc, operation, inputCoreGroups) {
    const newObjects = [];
    const inputCoreGroup0 = inputCoreGroups[0];
    const inputCoreGroup1 = inputCoreGroups[1];
    let shapeObjects0 = inputCoreGroup0.cadObjectsWithShape();
    if (shapeObjects0) {
      if (inputCoreGroup1) {
        const shapeObjects1 = inputCoreGroup1.cadObjectsWithShape();
        if (shapeObjects1) {
          shapeObjects0 = shapeObjects0.concat(shapeObjects1);
        }
      }
      _createBooleansAllInSequence(oc, operation, shapeObjects0, newObjects);
    }
    this.setCADObjects(newObjects);
  }
  _createBooleansOneToOne(oc, operation, inputCoreGroups) {
    const newObjects = [];
    const inputCoreGroup0 = inputCoreGroups[0];
    const inputCoreGroup1 = inputCoreGroups[1];
    if (!inputCoreGroup1) {
      this.states.error.set("input 1 required for this mode");
      return;
    }
    const shapeObjects0 = inputCoreGroup0.cadObjectsWithShape();
    const shapeObjects1 = inputCoreGroup1.cadObjectsWithShape();
    if (shapeObjects0 && shapeObjects1) {
      _createBooleansOneToOne(oc, operation, shapeObjects0, shapeObjects1, newObjects);
    }
    this.setCADObjects(newObjects);
  }
  _createBooleansOneToMany(oc, operation, inputCoreGroups) {
    const newObjects = [];
    const inputCoreGroup0 = inputCoreGroups[0];
    const inputCoreGroup1 = inputCoreGroups[1];
    if (!inputCoreGroup1) {
      this.states.error.set("input 1 required for this mode");
      return;
    }
    const shapeObjects0 = inputCoreGroup0.cadObjectsWithShape();
    const shapeObjects1 = inputCoreGroup1.cadObjectsWithShape();
    if (shapeObjects0 && shapeObjects1) {
      _createBooleansOneToMany(oc, operation, shapeObjects0, shapeObjects1, newObjects);
    }
    this.setCADObjects(newObjects);
  }
  // override async cook(inputCoreGroups: CadCoreGroup[]) {
  // 	const oc = await CadLoader.core();
  // 	const coreGroup0 = inputCoreGroups[0];
  // 	const coreGroup1 = inputCoreGroups[1];
  // 	const object0 = coreGroup0.objects()[0];
  // 	const object1 = coreGroup1.objects()[0];
  // 	const operation = BOOLEAN_CAD_OPERATION_TYPES[this.pv.operation];
  // 	const apiClass = {
  // 		[BooleanCadOperationType.INTERSECT]: oc.BRepAlgoAPI_Common_3,
  // 		[BooleanCadOperationType.SUBTRACT]: oc.BRepAlgoAPI_Cut_3,
  // 		[BooleanCadOperationType.UNION]: oc.BRepAlgoAPI_Fuse_3,
  // 		[BooleanCadOperationType.SECTION]: oc.BRepAlgoAPI_Section_3,
  // 	}[operation];
  // 	if (object0 && object1 && CoreCadType.isShape(object0) && CoreCadType.isShape(object1)) {
  // 		const cut = new apiClass(object0.object(), object1.object(), new oc.Message_ProgressRange_1());
  // 		cut.Build(new oc.Message_ProgressRange_1());
  // 		const shape = cut.Shape();
  // 		this.setShell(shape);
  // 	} else {
  // 		this.setCadObjects([object0]);
  // 	}
  // }
}
function _createBooleansAllInSequence(oc, operation, shapeObjects, newObjects) {
  let previousShape;
  for (const shapeObject of shapeObjects) {
    if (previousShape) {
      const newShape = _booleanOperation(oc, operation, previousShape, shapeObject.cadGeometry());
      previousShape = newShape;
    } else {
      previousShape = shapeObject.cadGeometry();
    }
  }
  if (previousShape) {
    const type = (0,_core_geometry_modules_cad_CadCommon__WEBPACK_IMPORTED_MODULE_5__/* .cadGeometryTypeFromShape */ .dJ)(oc, previousShape);
    if (type) {
      newObjects.push(new _core_geometry_modules_cad_CadObject__WEBPACK_IMPORTED_MODULE_6__/* .CadObject */ .K(previousShape, type));
    } else {
      console.log("no type", previousShape);
    }
  }
}
function _createBooleansOneToOne(oc, operation, shapeObjects0, shapeObjects1, newObjects) {
  const minVerticesCount = Math.min(shapeObjects0.length, shapeObjects1.length);
  for (let i = 0; i < minVerticesCount; i++) {
    const shape0 = shapeObjects0[i].cadGeometry();
    const shape1 = shapeObjects1[i].cadGeometry();
    const newShape = _booleanOperation(oc, operation, shape0, shape1);
    const type = (0,_core_geometry_modules_cad_CadCommon__WEBPACK_IMPORTED_MODULE_5__/* .cadGeometryTypeFromShape */ .dJ)(oc, newShape);
    if (type) {
      newObjects.push(new _core_geometry_modules_cad_CadObject__WEBPACK_IMPORTED_MODULE_6__/* .CadObject */ .K(newShape, type));
    } else {
      console.log("no type", newShape);
    }
  }
}
function _createBooleansOneToMany(oc, operation, shapeObjects0, shapeObjects1, newObjects) {
  for (const shapeObject0 of shapeObjects0) {
    let previousBooleanShapeResult = shapeObject0.cadGeometry();
    for (const shapeObject1 of shapeObjects1) {
      previousBooleanShapeResult = _booleanOperation(
        oc,
        operation,
        previousBooleanShapeResult,
        shapeObject1.cadGeometry()
      );
    }
    if (previousBooleanShapeResult) {
      const type = (0,_core_geometry_modules_cad_CadCommon__WEBPACK_IMPORTED_MODULE_5__/* .cadGeometryTypeFromShape */ .dJ)(oc, previousBooleanShapeResult);
      if (type) {
        newObjects.push(new _core_geometry_modules_cad_CadObject__WEBPACK_IMPORTED_MODULE_6__/* .CadObject */ .K(previousBooleanShapeResult, type));
      } else {
        console.log("no type", previousBooleanShapeResult);
      }
    }
  }
}
function _booleanOperation(oc, operation, shape0, shape1) {
  switch (operation) {
    case "intersect" /* INTERSECT */: {
      return _booleanOperationIntersect(oc, shape0, shape1);
    }
    case "subtract" /* SUBTRACT */: {
      return _booleanOperationSubtract(oc, shape0, shape1);
    }
    case "union" /* UNION */: {
      return _booleanOperationUnion(oc, shape0, shape1);
    }
    case "section" /* SECTION */: {
      return _booleanOperationSection(oc, shape0, shape1);
    }
  }
  _poly_Assert__WEBPACK_IMPORTED_MODULE_4__/* .TypeAssert.unreachable */ .f.unreachable(operation);
}
function _booleanOperationIntersect(oc, shape0, shape1) {
  const operation = new oc.BRepAlgoAPI_Common_3(shape0, shape1, _core_geometry_modules_cad_CadLoaderSync__WEBPACK_IMPORTED_MODULE_3__/* .CadLoaderSync.Message_ProgressRange */ .T.Message_ProgressRange);
  operation.Build(_core_geometry_modules_cad_CadLoaderSync__WEBPACK_IMPORTED_MODULE_3__/* .CadLoaderSync.Message_ProgressRange */ .T.Message_ProgressRange);
  const shape = operation.Shape();
  operation.delete();
  return shape;
}
function _booleanOperationSubtract(oc, shape0, shape1) {
  const operation = new oc.BRepAlgoAPI_Cut_3(shape0, shape1, _core_geometry_modules_cad_CadLoaderSync__WEBPACK_IMPORTED_MODULE_3__/* .CadLoaderSync.Message_ProgressRange */ .T.Message_ProgressRange);
  operation.Build(_core_geometry_modules_cad_CadLoaderSync__WEBPACK_IMPORTED_MODULE_3__/* .CadLoaderSync.Message_ProgressRange */ .T.Message_ProgressRange);
  const shape = operation.Shape();
  operation.delete();
  return shape;
}
function _booleanOperationUnion(oc, shape0, shape1) {
  const operation = new oc.BRepAlgoAPI_Fuse_3(shape0, shape1, _core_geometry_modules_cad_CadLoaderSync__WEBPACK_IMPORTED_MODULE_3__/* .CadLoaderSync.Message_ProgressRange */ .T.Message_ProgressRange);
  operation.Build(_core_geometry_modules_cad_CadLoaderSync__WEBPACK_IMPORTED_MODULE_3__/* .CadLoaderSync.Message_ProgressRange */ .T.Message_ProgressRange);
  const shape = operation.Shape();
  operation.delete();
  return shape;
}
function _booleanOperationSection(oc, shape0, shape1) {
  const operation = new oc.BRepAlgoAPI_Section_3(shape0, shape1, true);
  const shape = operation.Shape();
  operation.delete();
  return shape;
}


/***/ }),

/***/ 13567:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "KK": function() { return /* binding */ CADConvertDimensionSopNode; }
/* harmony export */ });
/* unused harmony exports ConversionMode, CONVERSION_MODES */
/* harmony import */ var _BaseCAD__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(85315);
/* harmony import */ var _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(96949);
/* harmony import */ var _core_geometry_modules_cad_CadCoreType__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(76514);
/* harmony import */ var _core_geometry_modules_cad_CadMath__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(21133);
/* harmony import */ var _core_geometry_modules_cad_CadCommon__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(39244);
/* harmony import */ var _core_geometry_modules_cad_toObject3D_CadVertex__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(83255);
/* harmony import */ var _core_geometry_modules_cad_toObject3D_CadEdge__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(57860);
/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(21410);
/* harmony import */ var _poly_registers_nodes_types_Sop__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(58986);
/* harmony import */ var _core_geometry_modules_cad_CadObject__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(48376);
/* harmony import */ var _core_geometry_modules_cad_CadLoaderSync__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(16457);












var ConversionMode = /* @__PURE__ */ ((ConversionMode2) => {
  ConversionMode2["TO_2D"] = "to 2D";
  ConversionMode2["TO_3D"] = "to 3D";
  return ConversionMode2;
})(ConversionMode || {});
const CONVERSION_MODES = ["to 2D" /* TO_2D */, "to 3D" /* TO_3D */];
class CADConvertDimensionSopParamsConfig extends _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_0__/* .NodeParamsConfig */ .yI {
  constructor() {
    super(...arguments);
    /** @param mode */
    this.mode = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_0__/* .ParamConfig.INTEGER */ .XC.INTEGER(CONVERSION_MODES.indexOf("to 3D" /* TO_3D */), {
      menu: {
        entries: CONVERSION_MODES.map((name, value) => ({ name, value }))
      }
    });
  }
  /** @param axis */
  // axis = ParamConfig.VECTOR3([0, 0, 1]);
}
const ParamsConfig = new CADConvertDimensionSopParamsConfig();
class CADConvertDimensionSopNode extends _BaseCAD__WEBPACK_IMPORTED_MODULE_1__/* .CADSopNode */ .M {
  constructor() {
    super(...arguments);
    this.paramsConfig = ParamsConfig;
  }
  static type() {
    return _poly_registers_nodes_types_Sop__WEBPACK_IMPORTED_MODULE_2__/* .SopType.CAD_CONVERT_DIMENSION */ .aB.CAD_CONVERT_DIMENSION;
  }
  initializeNode() {
    this.io.inputs.setCount(1);
  }
  setMode(mode) {
    this.p.mode.set(CONVERSION_MODES.indexOf(mode));
  }
  cook(inputCoreGroups) {
    const oc = _core_geometry_modules_cad_CadLoaderSync__WEBPACK_IMPORTED_MODULE_3__/* .CadLoaderSync.oc */ .T.oc();
    const mode = CONVERSION_MODES[this.pv.mode];
    const plane = (0,_core_geometry_modules_cad_CadMath__WEBPACK_IMPORTED_MODULE_4__/* .cadPlaneXY */ .yK)();
    const newObjects = [];
    const inputObjects = inputCoreGroups[0].cadObjects();
    if (inputObjects) {
      switch (mode) {
        case "to 2D" /* TO_2D */: {
          for (const inputObject of inputObjects) {
            const type = inputObject.type;
            switch (type) {
              case _core_geometry_modules_cad_CadCommon__WEBPACK_IMPORTED_MODULE_5__/* .CadGeometryType.VERTEX */ .dT.VERTEX: {
                if (_core_geometry_modules_cad_CadCoreType__WEBPACK_IMPORTED_MODULE_6__/* .CoreCadType.isVertex */ .c.isVertex(inputObject)) {
                  convertVertexToPoint2D(oc, inputObject.cadGeometry(), plane, newObjects);
                }
                break;
              }
              case _core_geometry_modules_cad_CadCommon__WEBPACK_IMPORTED_MODULE_5__/* .CadGeometryType.EDGE */ .dT.EDGE: {
                if (_core_geometry_modules_cad_CadCoreType__WEBPACK_IMPORTED_MODULE_6__/* .CoreCadType.isEdge */ .c.isEdge(inputObject)) {
                  convertEdgeToCurve2D(oc, inputObject.cadGeometry(), plane, newObjects);
                }
                break;
              }
              default:
                newObjects.push(inputObject);
            }
          }
          break;
        }
        case "to 3D" /* TO_3D */: {
          for (const inputObject of inputObjects) {
            const type = inputObject.type;
            switch (type) {
              case _core_geometry_modules_cad_CadCommon__WEBPACK_IMPORTED_MODULE_5__/* .CadGeometryType.POINT_2D */ .dT.POINT_2D: {
                if (_core_geometry_modules_cad_CadCoreType__WEBPACK_IMPORTED_MODULE_6__/* .CoreCadType.isPoint2d */ .c.isPoint2d(inputObject)) {
                  convertPoint2DToVertex(oc, inputObject.cadGeometry(), plane, newObjects);
                }
                break;
              }
              case _core_geometry_modules_cad_CadCommon__WEBPACK_IMPORTED_MODULE_5__/* .CadGeometryType.CURVE_2D */ .dT.CURVE_2D: {
                if (_core_geometry_modules_cad_CadCoreType__WEBPACK_IMPORTED_MODULE_6__/* .CoreCadType.isGeom2dCurve */ .c.isGeom2dCurve(inputObject)) {
                  convertCurve2DToEdge(oc, inputObject.cadGeometry(), plane, newObjects);
                }
                break;
              }
              default:
                newObjects.push(inputObject);
            }
          }
          break;
        }
      }
    }
    this.setCADObjects(newObjects);
  }
}
const tmpV3 = new three__WEBPACK_IMPORTED_MODULE_7__.Vector3();
function convertVertexToPoint2D(oc, vertex, plane, newObjects) {
  const point = oc.BRep_Tool.Pnt(vertex);
  const pnt2D = new oc.gp_Pnt2d_3(point.X(), point.Y());
  newObjects.push(new _core_geometry_modules_cad_CadObject__WEBPACK_IMPORTED_MODULE_8__/* .CadObject */ .K(pnt2D, _core_geometry_modules_cad_CadCommon__WEBPACK_IMPORTED_MODULE_5__/* .CadGeometryType.POINT_2D */ .dT.POINT_2D));
}
function convertEdgeToCurve2D(oc, edge, plane, newObjects) {
  const handle3D = (0,_core_geometry_modules_cad_toObject3D_CadEdge__WEBPACK_IMPORTED_MODULE_9__/* .curveDataFromEdge */ .Bc)(oc, edge).curveHandle;
  const curve3D = handle3D.get();
  if (!curve3D) {
    return;
  }
  const handle2D = oc.GeomAPI.To2d(handle3D, (0,_core_geometry_modules_cad_CadMath__WEBPACK_IMPORTED_MODULE_4__/* .cadPlaneXY */ .yK)());
  const curve2D = handle2D.get();
  if (!curve2D) {
    return;
  }
  newObjects.push(new _core_geometry_modules_cad_CadObject__WEBPACK_IMPORTED_MODULE_8__/* .CadObject */ .K(curve2D, _core_geometry_modules_cad_CadCommon__WEBPACK_IMPORTED_MODULE_5__/* .CadGeometryType.CURVE_2D */ .dT.CURVE_2D));
}
function convertPoint2DToVertex(oc, point2D, plane, newObjects) {
  tmpV3.set(point2D.X(), point2D.Y(), 0);
  const vertex = (0,_core_geometry_modules_cad_toObject3D_CadVertex__WEBPACK_IMPORTED_MODULE_10__/* .cadVertexCreate */ .SW)(oc, tmpV3);
  newObjects.push(new _core_geometry_modules_cad_CadObject__WEBPACK_IMPORTED_MODULE_8__/* .CadObject */ .K(vertex, _core_geometry_modules_cad_CadCommon__WEBPACK_IMPORTED_MODULE_5__/* .CadGeometryType.VERTEX */ .dT.VERTEX));
}
function convertCurve2DToEdge(oc, curve2D, plane, newObjects) {
  const handle2D = new oc.Handle_Geom2d_Curve_2(curve2D);
  const handle3D = oc.GeomAPI.To3d(handle2D, (0,_core_geometry_modules_cad_CadMath__WEBPACK_IMPORTED_MODULE_4__/* .cadPlaneXY */ .yK)());
  const curve3D = handle3D.get();
  if (!curve3D) {
    return;
  }
  const edge = (0,_core_geometry_modules_cad_toObject3D_CadEdge__WEBPACK_IMPORTED_MODULE_9__/* .cadEdgeCreate */ .Ll)(oc, curve3D);
  handle2D.delete();
  newObjects.push(new _core_geometry_modules_cad_CadObject__WEBPACK_IMPORTED_MODULE_8__/* .CadObject */ .K(edge, _core_geometry_modules_cad_CadCommon__WEBPACK_IMPORTED_MODULE_5__/* .CadGeometryType.EDGE */ .dT.EDGE));
}


/***/ }),

/***/ 49121:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "G": function() { return /* binding */ CADFilletSopNode; }
/* harmony export */ });
/* harmony import */ var _BaseCAD__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(85315);
/* harmony import */ var _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(96949);
/* harmony import */ var _core_geometry_modules_cad_CadConstant__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(30416);
/* harmony import */ var _core_geometry_modules_cad_CadCoreType__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(76514);
/* harmony import */ var _core_geometry_modules_cad_CadTraverse__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(35546);
/* harmony import */ var _core_geometry_modules_cad_CadCommon__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(39244);
/* harmony import */ var _poly_Assert__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(68239);
/* harmony import */ var _poly_registers_nodes_types_Sop__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(58986);
/* harmony import */ var _core_geometry_modules_cad_CadObject__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(48376);
/* harmony import */ var _core_geometry_modules_cad_CadLoaderSync__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(16457);
/* harmony import */ var _core_geometry_EntityGroupCollection__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(98557);
/* harmony import */ var _core_geometry_modules_cad_CadEntityGroupCollection__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(23917);













var FilletMode = /* @__PURE__ */ ((FilletMode2) => {
  FilletMode2["ROUND"] = "round";
  FilletMode2["STRAIGHT"] = "straight";
  return FilletMode2;
})(FilletMode || {});
const FILLET_MODES = ["straight" /* STRAIGHT */, "round" /* ROUND */];
class CADFilletSopParamsConfig extends _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_0__/* .NodeParamsConfig */ .yI {
  constructor() {
    super(...arguments);
    /** @param edges group */
    this.group = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_0__/* .ParamConfig.STRING */ .XC.STRING("");
    /** @param mode */
    this.mode = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_0__/* .ParamConfig.INTEGER */ .XC.INTEGER(FILLET_MODES.indexOf("round" /* ROUND */), {
      menu: {
        entries: FILLET_MODES.map((name, value) => ({ name, value }))
      }
    });
    /** @param radius */
    this.radius = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_0__/* .ParamConfig.FLOAT */ .XC.FLOAT(0.1, {
      range: [0, 1],
      rangeLocked: [true, false],
      step: _core_geometry_modules_cad_CadConstant__WEBPACK_IMPORTED_MODULE_1__/* .step */ .Nb
    });
  }
}
const ParamsConfig = new CADFilletSopParamsConfig();
class CADFilletSopNode extends _BaseCAD__WEBPACK_IMPORTED_MODULE_2__/* .CADSopNode */ .M {
  constructor() {
    super(...arguments);
    this.paramsConfig = ParamsConfig;
  }
  static type() {
    return _poly_registers_nodes_types_Sop__WEBPACK_IMPORTED_MODULE_3__/* .SopType.CAD_FILLET */ .aB.CAD_FILLET;
  }
  initializeNode() {
    this.io.inputs.setCount(1);
  }
  cook(inputCoreGroups) {
    const oc = _core_geometry_modules_cad_CadLoaderSync__WEBPACK_IMPORTED_MODULE_4__/* .CadLoaderSync.oc */ .T.oc();
    const inputCoreGroup = inputCoreGroups[0];
    const mode = FILLET_MODES[this.pv.mode];
    const newObjects = [];
    const inputObjects = inputCoreGroup.cadObjects();
    if (inputObjects) {
      const groupName = this.pv.group;
      for (const object of inputObjects) {
        if (_core_geometry_modules_cad_CadCoreType__WEBPACK_IMPORTED_MODULE_5__/* .CoreCadType.isShape */ .c.isShape(object)) {
          const shape = object.cadGeometry();
          const api = _getApi(oc, mode, shape);
          const radius = this.pv.radius;
          let edgesCount = 0;
          _core_geometry_modules_cad_CadEntityGroupCollection__WEBPACK_IMPORTED_MODULE_6__/* .CadEntityGroupCollection.traverseEntitiesInGroup */ .b.traverseEntitiesInGroup({
            groupName,
            groupType: _core_geometry_EntityGroupCollection__WEBPACK_IMPORTED_MODULE_7__/* .EntityGroupType.EDGE */ .he.EDGE,
            object,
            shape,
            traverseFunction: _core_geometry_modules_cad_CadTraverse__WEBPACK_IMPORTED_MODULE_8__/* .traverseEdges */ .y9,
            onEntityTraversed: (edge, i) => {
              api.Add_2(radius, edge);
              edgesCount++;
            }
          });
          if (edgesCount > 0) {
            const newShape = api.Shape();
            api.delete();
            const type = (0,_core_geometry_modules_cad_CadCommon__WEBPACK_IMPORTED_MODULE_9__/* .cadGeometryTypeFromShape */ .dJ)(oc, newShape);
            if (type) {
              newObjects.push(new _core_geometry_modules_cad_CadObject__WEBPACK_IMPORTED_MODULE_10__/* .CadObject */ .K(newShape, type));
            } else {
              console.log("no type", newShape);
            }
          } else {
            newObjects.push(object);
          }
        }
      }
    }
    this.setCADObjects(newObjects);
  }
}
function _getApi(oc, mode, shape) {
  switch (mode) {
    case "round" /* ROUND */: {
      return new oc.BRepFilletAPI_MakeFillet(shape, oc.ChFi3d_FilletShape.ChFi3d_Rational);
    }
    case "straight" /* STRAIGHT */: {
      return new oc.BRepFilletAPI_MakeChamfer(shape);
    }
  }
  _poly_Assert__WEBPACK_IMPORTED_MODULE_11__/* .TypeAssert.unreachable */ .f.unreachable(mode);
}


/***/ }),

/***/ 3195:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {


// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  "F": function() { return /* binding */ CADGroupSopNode; }
});

// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/nodes/sop/_BaseCAD.ts
var _BaseCAD = __webpack_require__(85315);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/nodes/utils/params/ParamsConfig.ts
var ParamsConfig = __webpack_require__(96949);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/poly/registers/nodes/types/Sop.ts
var Sop = __webpack_require__(58986);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/core/geometry/modules/cad/CadLoader.ts + 1 modules
var CadLoader = __webpack_require__(3781);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/poly/InputCloneMode.ts
var InputCloneMode = __webpack_require__(56752);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/core/geometry/modules/cad/CadTraverse.ts
var CadTraverse = __webpack_require__(35546);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/core/geometry/modules/cad/CadCoreType.ts
var CadCoreType = __webpack_require__(76514);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/core/Type.ts
var Type = __webpack_require__(19037);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/nodes/sop/utils/group/GroupCommon.ts
var GroupCommon = __webpack_require__(11446);
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/sop/utils/group/GroupByExpressionHelper.ts

var __async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};


class GroupByExpressionHelper {
  constructor(node) {
    this.node = node;
  }
  evalForEntities(allEntities, selectionStates) {
    return __async(this, null, function* () {
      const param = this.node.p.expression;
      if (param.hasExpression() && param.expressionController && param.expressionController.entitiesDependent()) {
        yield this._evalEntityDependentExpression(allEntities, selectionStates, param.expressionController);
      } else {
        this._evalExpressionsWithoutEntityDependentExpression(allEntities, selectionStates);
      }
    });
  }
  _evalEntityDependentExpression(allEntities, selectionStates, expressionController) {
    return __async(this, null, function* () {
      yield expressionController.computeExpressionForEntities(allEntities, (entity, value) => {
        (0,GroupCommon/* updateSelectionState */.Z)(selectionStates, entity, value);
      });
    });
  }
  _evalExpressionsWithoutEntityDependentExpression(allEntities, selectionStates) {
    const value = (0,Type/* isBooleanTrue */.bI)(this.node.pv.expression);
    for (const entity of allEntities) {
      (0,GroupCommon/* updateSelectionState */.Z)(selectionStates, entity, value);
    }
  }
}

// EXTERNAL MODULE: ../@polygonjs/polygonjs/node_modules/three/build/three.module.js
var three_module = __webpack_require__(21410);
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/sop/utils/group/GroupByBoundingBoxHelper.ts



const bbox = new three_module.Box3();
const bboxHalfSize = new three_module.Vector3();
const entityPosition = new three_module.Vector3();
class GroupByBoundingBoxHelper {
  constructor(node) {
    this.node = node;
  }
  evalForEntities(allEntities, selectionStates) {
    bboxHalfSize.copy(this.node.pv.boundingBoxSize).multiplyScalar(0.5);
    bbox.min.copy(this.node.pv.boundingBoxCenter).sub(bboxHalfSize);
    bbox.max.copy(this.node.pv.boundingBoxCenter).add(bboxHalfSize);
    for (const entity of allEntities) {
      entity.position(entityPosition);
      (0,GroupCommon/* updateSelectionState */.Z)(selectionStates, entity, bbox.containsPoint(entityPosition));
    }
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/sop/utils/group/GroupByBoundingObjectHelper.ts



const GroupByBoundingObjectHelper_bbox = new three_module.Box3();
const tmpPosition = new three_module.Vector3();
class GroupByBoundingObjectHelper {
  evalForEntities(allEntities, selectionStates, boundingCoreGroup) {
    boundingCoreGroup.boundingBox(GroupByBoundingObjectHelper_bbox);
    for (const entity of allEntities) {
      entity.position(tmpPosition);
      (0,GroupCommon/* updateSelectionState */.Z)(selectionStates, entity, GroupByBoundingObjectHelper_bbox.containsPoint(tmpPosition));
    }
  }
}

// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/core/geometry/CoreEntity.ts
var CoreEntity = __webpack_require__(4988);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/core/geometry/Attribute.ts
var Attribute = __webpack_require__(32558);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/core/geometry/modules/cad/CadLoaderSync.ts
var CadLoaderSync = __webpack_require__(16457);
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/core/geometry/modules/cad/CadCoreEdge.ts






class CadCoreEdge extends CoreEntity/* CoreEntity */.U {
  constructor(_shape, _edge, _index) {
    super(_shape, _index);
    this._shape = _shape;
    this._edge = _edge;
  }
  edge() {
    return this._edge;
  }
  geometry() {
    return this._shape;
  }
  builder() {
    return void 0;
  }
  setAttribValue(attribName, attribValue) {
  }
  attribValue(attribName, target) {
    if (attribName === Attribute/* Attribute.POINT_INDEX */.ah.POINT_INDEX) {
      return this._index;
    } else {
      const remapedName = Attribute/* CoreAttribute.remapName */.n0.remapName(attribName);
      if (remapedName == Attribute/* Attribute.POSITION */.ah.POSITION && target instanceof three_module.Vector3) {
        this.position(target);
      }
      return this._index;
    }
  }
  stringAttribValue(attribName) {
    return "";
  }
  position(target) {
    const oc = CadLoaderSync/* CadLoaderSync.oc */.T.oc();
    let verticesCount = 0;
    target.set(0, 0, 0);
    (0,CadTraverse/* traverseVertices */.Fw)(oc, this._edge, (vertex, i) => {
      const point = oc.BRep_Tool.Pnt(vertex);
      target.x += point.X();
      target.y += point.Y();
      target.z += point.Z();
      verticesCount++;
    });
    target.divideScalar(verticesCount);
    return target;
  }
  //
  //
  // RELATED ENTITIES
  //
  //
  relatedEntities(attribClass) {
    return [];
  }
}

// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/core/geometry/EntityGroupCollection.ts
var EntityGroupCollection = __webpack_require__(98557);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/core/geometry/CoreObjectFactory.ts
var CoreObjectFactory = __webpack_require__(17353);
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/core/geometry/modules/cad/CadCoreFace.ts






class CadCoreFace extends CoreEntity/* CoreEntity */.U {
  constructor(_shape, _face, _index) {
    super(_shape, _index);
    this._shape = _shape;
    this._face = _face;
  }
  face() {
    return this._face;
  }
  geometry() {
    return this._shape;
  }
  builder() {
    return void 0;
  }
  setAttribValue(attribName, attribValue) {
  }
  attribValue(attribName, target) {
    if (attribName === Attribute/* Attribute.POINT_INDEX */.ah.POINT_INDEX) {
      return this._index;
    } else {
      const remapedName = Attribute/* CoreAttribute.remapName */.n0.remapName(attribName);
      if (remapedName == Attribute/* Attribute.POSITION */.ah.POSITION && target instanceof three_module.Vector3) {
        this.position(target);
      }
      return this._index;
    }
  }
  stringAttribValue(attribName) {
    return "";
  }
  position(target) {
    const oc = CadLoaderSync/* CadLoaderSync.oc */.T.oc();
    let verticesCount = 0;
    target.set(0, 0, 0);
    (0,CadTraverse/* traverseVertices */.Fw)(oc, this._face, (vertex, i) => {
      const point = oc.BRep_Tool.Pnt(vertex);
      target.x += point.X();
      target.y += point.Y();
      target.z += point.Z();
      verticesCount++;
    });
    target.divideScalar(verticesCount);
    return target;
  }
  //
  //
  // RELATED ENTITIES
  //
  //
  relatedEntities(attribClass) {
    return [];
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/sop/CADGroup.ts

var CADGroup_async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};
















const GROUP_TYPES = [EntityGroupCollection/* EntityGroupType.EDGE */.he.EDGE, EntityGroupCollection/* EntityGroupType.FACE */.he.FACE];
class CADGroupSopParamsConfig extends ParamsConfig/* NodeParamsConfig */.yI {
  constructor() {
    super(...arguments);
    /** @param group name */
    this.name = ParamsConfig/* ParamConfig.STRING */.XC.STRING("");
    /** @param group type */
    this.type = ParamsConfig/* ParamConfig.INTEGER */.XC.INTEGER(GROUP_TYPES.indexOf(EntityGroupCollection/* EntityGroupType.EDGE */.he.EDGE), {
      menu: {
        entries: GROUP_TYPES.map((name, value) => ({ name, value }))
      }
    });
    /** @param mode */
    this.operation = ParamsConfig/* ParamConfig.INTEGER */.XC.INTEGER(EntityGroupCollection/* GROUP_OPERATIONS.indexOf */.$W.indexOf(EntityGroupCollection/* GroupOperation.SET */.gW.SET), {
      menu: {
        entries: EntityGroupCollection/* GROUP_OPERATIONS.map */.$W.map((name, value) => ({ name, value }))
      }
    });
    // byExpression
    /** @param deletes objects by an expression */
    this.byExpression = ParamsConfig/* ParamConfig.BOOLEAN */.XC.BOOLEAN(0, {
      separatorBefore: true
    });
    /** @param sets the expression to select what should be deleted */
    this.expression = ParamsConfig/* ParamConfig.BOOLEAN */.XC.BOOLEAN("@ptnum==0", {
      visibleIf: { byExpression: true },
      expression: { forEntities: true }
    });
    // byBbox
    /** @param deletes objects that are inside a bounding box */
    this.byBoundingBox = ParamsConfig/* ParamConfig.BOOLEAN */.XC.BOOLEAN(0, {
      separatorBefore: true
    });
    /** @param the bounding box size */
    this.boundingBoxSize = ParamsConfig/* ParamConfig.VECTOR3 */.XC.VECTOR3([1, 1, 1], {
      visibleIf: {
        byBoundingBox: true
      }
    });
    /** @param the bounding box center */
    this.boundingBoxCenter = ParamsConfig/* ParamConfig.VECTOR3 */.XC.VECTOR3([0, 0, 0], {
      visibleIf: {
        byBoundingBox: true
      }
    });
    // byBoundingObject
    /** @param deletes objects that are inside an object. This uses the object from the 2nd input */
    this.byBoundingObject = ParamsConfig/* ParamConfig.BOOLEAN */.XC.BOOLEAN(0, {
      separatorBefore: true
    });
    /** @param invert */
    this.invert = ParamsConfig/* ParamConfig.BOOLEAN */.XC.BOOLEAN(0, {
      separatorBefore: true
    });
  }
}
const CADGroup_ParamsConfig = new CADGroupSopParamsConfig();
class CADGroupSopNode extends _BaseCAD/* CADSopNode */.M {
  constructor() {
    super(...arguments);
    this.paramsConfig = CADGroup_ParamsConfig;
    // public readonly entitySelectionHelper = new EntitySelectionHelper(this);
    this.byExpressionHelper = new GroupByExpressionHelper(this);
    this.byBoundingBoxHelper = new GroupByBoundingBoxHelper(this);
    this.byBoundingObjectHelper = new GroupByBoundingObjectHelper();
    this.selectedStates = /* @__PURE__ */ new Map();
  }
  static type() {
    return Sop/* SopType.CAD_GROUP */.aB.CAD_GROUP;
  }
  initializeNode() {
    this.io.inputs.setCount(1, 2);
    this.io.inputs.initInputsClonedState(InputCloneMode/* InputCloneMode.FROM_NODE */.m.FROM_NODE);
  }
  setGroupType(groupType) {
    this.p.type.set(GROUP_TYPES.indexOf(groupType));
  }
  groupType() {
    return GROUP_TYPES[this.pv.type];
  }
  groupName() {
    return this.pv.name;
  }
  cook(inputCoreGroups) {
    return CADGroup_async(this, null, function* () {
      const oc = yield CadLoader/* CadLoader.core */.i.core(this);
      const coreGroup0 = inputCoreGroups[0];
      const coreGroup1 = inputCoreGroups[1];
      const inputObjects = coreGroup0.cadObjects();
      if (inputObjects) {
        for (const inputObject of inputObjects) {
          if (CadCoreType/* CoreCadType.isShape */.c.isShape(inputObject)) {
            yield this._evalEdges(oc, inputObject, coreGroup1);
          }
        }
        this.setCADObjects(inputObjects);
      } else {
        this.setCADObjects([]);
      }
    });
  }
  _evalEdges(oc, inputObject, boundingCoreGroup) {
    return CADGroup_async(this, null, function* () {
      const entities = [];
      const shape = inputObject.cadGeometry();
      const type = this.groupType();
      switch (type) {
        case EntityGroupCollection/* EntityGroupType.EDGE */.he.EDGE: {
          (0,CadTraverse/* traverseEdges */.y9)(oc, shape, (edge, index) => {
            entities.push(new CadCoreEdge(shape, edge, index));
          });
          break;
        }
        case EntityGroupCollection/* EntityGroupType.FACE */.he.FACE: {
          (0,CadTraverse/* traverseFaces */.Ob)(oc, shape, (face, index) => {
            entities.push(new CadCoreFace(shape, face, index));
          });
          break;
        }
      }
      this.selectedStates.clear();
      const { byExpression, byBoundingBox, byBoundingObject } = this.pv;
      if (byExpression || byBoundingBox || byBoundingObject) {
        if ((0,Type/* isBooleanTrue */.bI)(byExpression)) {
          yield this.byExpressionHelper.evalForEntities(entities, this.selectedStates);
        }
        if ((0,Type/* isBooleanTrue */.bI)(byBoundingBox)) {
          yield this.byBoundingBoxHelper.evalForEntities(entities, this.selectedStates);
        }
        if ((0,Type/* isBooleanTrue */.bI)(byBoundingObject)) {
          yield this.byBoundingObjectHelper.evalForEntities(entities, this.selectedStates, boundingCoreGroup);
        }
      } else {
        for (const entity of entities) {
          (0,GroupCommon/* updateSelectionState */.Z)(this.selectedStates, entity, false);
        }
      }
      const coreObject = (0,CoreObjectFactory/* coreObjectInstanceFactory */.$Z)(inputObject);
      const groupCollection = coreObject.groupCollection();
      const options = {
        type,
        groupName: this.groupName(),
        operation: EntityGroupCollection/* GROUP_OPERATIONS */.$W[this.pv.operation],
        invert: this.pv.invert
      };
      groupCollection.updateGroup(options, this.selectedStates);
    });
  }
}


/***/ }),

/***/ 9345:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "C": function() { return /* binding */ CADMirrorSopNode; }
/* harmony export */ });
/* harmony import */ var _BaseCAD__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(85315);
/* harmony import */ var _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(96949);
/* harmony import */ var _core_geometry_modules_cad_CadCommon__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(39244);
/* harmony import */ var _core_geometry_modules_cad_CadCoreType__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(76514);
/* harmony import */ var _poly_registers_nodes_types_Sop__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(58986);
/* harmony import */ var _core_geometry_modules_cad_CadLoaderSync__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(16457);
/* harmony import */ var _core_geometry_modules_cad_CadObject__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(48376);








class CADMirrorSopParamsConfig extends _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_0__/* .NodeParamsConfig */ .yI {
  constructor() {
    super(...arguments);
    /** @param origin */
    // origin = ParamConfig.VECTOR3([0, 0, 0]);
    /** @param axis */
    this.axis = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_0__/* .ParamConfig.VECTOR3 */ .XC.VECTOR3([0, 1, 0]);
  }
}
const ParamsConfig = new CADMirrorSopParamsConfig();
class CADMirrorSopNode extends _BaseCAD__WEBPACK_IMPORTED_MODULE_1__/* .CADSopNode */ .M {
  constructor() {
    super(...arguments);
    this.paramsConfig = ParamsConfig;
  }
  static type() {
    return _poly_registers_nodes_types_Sop__WEBPACK_IMPORTED_MODULE_2__/* .SopType.CAD_MIRROR */ .aB.CAD_MIRROR;
  }
  initializeNode() {
    this.io.inputs.setCount(1);
  }
  cook(inputCoreGroups) {
    const oc = _core_geometry_modules_cad_CadLoaderSync__WEBPACK_IMPORTED_MODULE_3__/* .CadLoaderSync.oc */ .T.oc();
    const inputCoreGroup = inputCoreGroups[0];
    const axis = _core_geometry_modules_cad_CadLoaderSync__WEBPACK_IMPORTED_MODULE_3__/* .CadLoaderSync.gp_Ax1 */ .T.gp_Ax1;
    const dir = _core_geometry_modules_cad_CadLoaderSync__WEBPACK_IMPORTED_MODULE_3__/* .CadLoaderSync.gp_Dir */ .T.gp_Dir;
    dir.SetCoord_2(this.pv.axis.x, this.pv.axis.y, this.pv.axis.z);
    axis.SetDirection(dir);
    const transform = _core_geometry_modules_cad_CadLoaderSync__WEBPACK_IMPORTED_MODULE_3__/* .CadLoaderSync.gp_Trsf */ .T.gp_Trsf;
    transform.SetMirror_2(axis);
    const newObjects = [];
    const inputObjects = inputCoreGroup.cadObjects();
    if (inputObjects) {
      for (const object of inputObjects) {
        if (_core_geometry_modules_cad_CadCoreType__WEBPACK_IMPORTED_MODULE_4__/* .CoreCadType.isShape */ .c.isShape(object)) {
          const shape = object.cadGeometry();
          const transformApi = new oc.BRepBuilderAPI_Transform_2(shape, transform, false);
          const mirroredShape = transformApi.Shape();
          transformApi.delete();
          const type = (0,_core_geometry_modules_cad_CadCommon__WEBPACK_IMPORTED_MODULE_5__/* .cadGeometryTypeFromShape */ .dJ)(oc, mirroredShape);
          if (type) {
            newObjects.push(new _core_geometry_modules_cad_CadObject__WEBPACK_IMPORTED_MODULE_6__/* .CadObject */ .K(mirroredShape, type));
          }
        }
      }
    }
    this.setCADObjects(newObjects);
  }
}


/***/ }),

/***/ 793:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "J": function() { return /* binding */ CADThicknessSopNode; }
/* harmony export */ });
/* harmony import */ var _BaseCAD__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(85315);
/* harmony import */ var _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(96949);
/* harmony import */ var _core_geometry_modules_cad_CadConstant__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(30416);
/* harmony import */ var _core_geometry_modules_cad_CadCoreType__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(76514);
/* harmony import */ var _core_geometry_modules_cad_CadCommon__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(39244);
/* harmony import */ var _core_geometry_modules_cad_CadTraverse__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(35546);
/* harmony import */ var _poly_registers_nodes_types_Sop__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(58986);
/* harmony import */ var _core_geometry_modules_cad_CadObject__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(48376);
/* harmony import */ var _core_geometry_modules_cad_CadLoaderSync__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(16457);
/* harmony import */ var _core_geometry_EntityGroupCollection__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(98557);
/* harmony import */ var _core_geometry_modules_cad_CadEntityGroupCollection__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(23917);












class CADThicknessSopParamsConfig extends _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_0__/* .NodeParamsConfig */ .yI {
  constructor() {
    super(...arguments);
    /** @param faces group */
    this.facesGroupToDelete = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_0__/* .ParamConfig.STRING */ .XC.STRING("");
    /** @param offset */
    this.offset = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_0__/* .ParamConfig.FLOAT */ .XC.FLOAT(-0.1, {
      range: [-1, 1],
      rangeLocked: [true, false],
      step: _core_geometry_modules_cad_CadConstant__WEBPACK_IMPORTED_MODULE_1__/* .step */ .Nb
    });
  }
}
const ParamsConfig = new CADThicknessSopParamsConfig();
class CADThicknessSopNode extends _BaseCAD__WEBPACK_IMPORTED_MODULE_2__/* .CADSopNode */ .M {
  constructor() {
    super(...arguments);
    this.paramsConfig = ParamsConfig;
  }
  static type() {
    return _poly_registers_nodes_types_Sop__WEBPACK_IMPORTED_MODULE_3__/* .SopType.CAD_THICKNESS */ .aB.CAD_THICKNESS;
  }
  initializeNode() {
    this.io.inputs.setCount(1);
  }
  cook(inputCoreGroups) {
    const oc = _core_geometry_modules_cad_CadLoaderSync__WEBPACK_IMPORTED_MODULE_4__/* .CadLoaderSync.oc */ .T.oc();
    const inputCoreGroup = inputCoreGroups[0];
    const newObjects = [];
    const inputObjects = inputCoreGroup.cadObjects();
    if (inputObjects) {
      for (const inputObject of inputObjects) {
        if (_core_geometry_modules_cad_CadCoreType__WEBPACK_IMPORTED_MODULE_5__/* .CoreCadType.isShape */ .c.isShape(inputObject)) {
          const newShape = this._makeSolidByJoin(oc, inputObject);
          if (newShape) {
            const type = (0,_core_geometry_modules_cad_CadCommon__WEBPACK_IMPORTED_MODULE_6__/* .cadGeometryTypeFromShape */ .dJ)(oc, newShape);
            if (type) {
              newObjects.push(new _core_geometry_modules_cad_CadObject__WEBPACK_IMPORTED_MODULE_7__/* .CadObject */ .K(newShape, type));
            } else {
              console.log("no type", newShape);
            }
          }
        } else {
          newObjects.push(inputObject);
        }
      }
    }
    this.setCADObjects(newObjects);
  }
  // private _makeSolid(oc: OpenCascadeInstance, shape: TopoDS_Shape, axis: Line3) {
  // 	return this.pv.removeFaces ? this._makeSolidByJoin(oc, shape, axis) : this._makeSolidBySimple(oc, shape);
  // }
  // private _makeSolidBySimple(oc: OpenCascadeInstance, shape: TopoDS_Shape) {
  // 	return withCadException(oc, () => {
  // 		const api = new oc.BRepOffsetAPI_MakeThickSolid();
  // 		api.MakeThickSolidBySimple(shape, this.pv.offset);
  // 		if(api.IsDone())
  // 		return api.Shape();
  // 	});
  // }
  _makeSolidByJoin(oc, object) {
    const faces = new oc.TopTools_ListOfShape_1();
    const shape = object.cadGeometry();
    _core_geometry_modules_cad_CadEntityGroupCollection__WEBPACK_IMPORTED_MODULE_8__/* .CadEntityGroupCollection.traverseEntitiesInGroup */ .b.traverseEntitiesInGroup({
      groupName: this.pv.facesGroupToDelete,
      groupType: _core_geometry_EntityGroupCollection__WEBPACK_IMPORTED_MODULE_9__/* .EntityGroupType.FACE */ .he.FACE,
      object,
      shape,
      traverseFunction: _core_geometry_modules_cad_CadTraverse__WEBPACK_IMPORTED_MODULE_10__/* .traverseFaces */ .Ob,
      onEntityTraversed: (face, i) => {
        faces.Append_1(face);
      }
    });
    const api = new oc.BRepOffsetAPI_MakeThickSolid();
    api.MakeThickSolidByJoin(
      shape,
      faces,
      this.pv.offset,
      1e-3,
      oc.BRepOffset_Mode.BRepOffset_Skin,
      false,
      false,
      oc.GeomAbs_JoinType.GeomAbs_Arc,
      false,
      _core_geometry_modules_cad_CadLoaderSync__WEBPACK_IMPORTED_MODULE_4__/* .CadLoaderSync.Message_ProgressRange */ .T.Message_ProgressRange
    );
    const newShape = api.Shape();
    api.delete();
    faces.delete();
    return newShape;
  }
  // private _getFacesToRemove(
  // 	oc: OpenCascadeInstance,
  // 	object: CadObject<CadGeometryType>,
  // 	shape: TopoDS_Shape,
  // 	faces: TopTools_ListOfShape
  // ) {
  // 	// const groupName = this.pv.facesGroupToDelete;
  // 	// if (groupName.trim() == '') {
  // 	// 	// no group
  // 	// 	traverseFaces(oc, shape, (face) => {
  // 	// 		faces.Append_1(face);
  // 	// 	});
  // 	// } else {
  // 	// 	const indices = CoreString.indices(groupName);
  // 	// 	if (indices.length != 0) {
  // 	// 		// group by indices
  // 	// 		const indicesSet = SetUtils.fromArray(indices);
  // 	// 		traverseFaces(oc, shape, (face, i) => {
  // 	// 			if (indicesSet.has(i)) {
  // 	// 				faces.Append_1(face);
  // 	// 			}
  // 	// 		});
  // 	// 	} else {
  // 	// 		// group by name
  // 	// 		const coreFaces: CadCoreFace[] = [];
  // 	// 		traverseFaces(oc, shape, (face, i) => {
  // 	// 			coreFaces.push(new CadCoreFace(shape, face, i));
  // 	// 		});
  // 	// 		const coreObject = coreObjectInstanceFactory(object);
  // 	// 		const groupCollection = coreObject.groupCollection();
  // 	// 		const selectedCoreFaces = groupCollection.entities(EntityGroupType.FACE, groupName, coreFaces);
  // 	// 		for (let selectedCoreFace of selectedCoreFaces) {
  // 	// 			faces.Append_1(selectedCoreFace.face());
  // 	// 		}
  // 	// 	}
  // 	// }
  // 	// facesByDist.clear();
  // 	// faceDists.clear();
  // 	// traverseFaces(oc, shape, (face) => {
  // 	// 	// const surface = oc.BRep_Tool.Surface_2(face);
  // 	// 	const surfaceProperties = CadLoaderSync.GProp_GProps;
  // 	// 	oc.BRepGProp.SurfaceProperties_1(face, surfaceProperties, false, false);
  // 	// 	const centerOfMass = surfaceProperties.CentreOfMass();
  // 	// 	faceCenter.set(centerOfMass.X(), centerOfMass.Y(), centerOfMass.Z());
  // 	// 	axis.closestPointToPoint(faceCenter, false, projected);
  // 	// 	const position = projected.dot(axis.end);
  // 	// 	// const currentFace = new oc.TopExp_Explorer_2(
  // 	// 	// 	face,
  // 	// 	// 	oc.TopAbs_ShapeEnum.TopAbs_FACE as any,
  // 	// 	// 	oc.TopAbs_ShapeEnum.TopAbs_SHAPE as any
  // 	// 	// ).Current();
  // 	// 	MapUtils.addToSetAtEntry(facesByDist, position, face);
  // 	// 	faceDists.add(position);
  // 	// });
  // 	// const dists = SetUtils.toArray(faceDists);
  // 	// const sortedDists = dists.sort((a, b) => (a > b ? 1 : -1));
  // 	// const facesToRemove: TopoDS_Face[] = [];
  // 	// for (let dist of sortedDists) {
  // 	// 	const faces = facesByDist.get(dist);
  // 	// 	if (faces) {
  // 	// 		for (let face of faces) {
  // 	// 			facesToRemove.push(face);
  // 	// 			if (facesToRemove.length >= this.pv.facesCount) {
  // 	// 				return facesToRemove;
  // 	// 			}
  // 	// 		}
  // 	// 	}
  // 	// }
  // 	// return facesToRemove;
  // }
}


/***/ }),

/***/ 37946:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "OQ": function() { return /* binding */ CSGBooleanSopNode; }
/* harmony export */ });
/* unused harmony exports BooleanCsgOperationType, BOOLEAN_CSG_OPERATION_TYPES */
/* harmony import */ var _BaseCSG__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(72290);
/* harmony import */ var _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(96949);
/* harmony import */ var _core_geometry_modules_csg_CsgCoreType__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(70083);
/* harmony import */ var _poly_registers_nodes_types_Sop__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(58986);
/* harmony import */ var _core_geometry_modules_csg_math_CsgMat4__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(37862);
/* harmony import */ var _jscad_modeling__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(93187);
/* harmony import */ var _jscad_modeling__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_jscad_modeling__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _core_geometry_modules_csg_CsgObject__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(12243);








const { intersect, union, subtract } = _jscad_modeling__WEBPACK_IMPORTED_MODULE_0__.booleans;
var BooleanCsgOperationType = /* @__PURE__ */ ((BooleanCsgOperationType2) => {
  BooleanCsgOperationType2["INTERSECT"] = "intersect";
  BooleanCsgOperationType2["SUBTRACT"] = "subtract";
  BooleanCsgOperationType2["UNION"] = "union";
  return BooleanCsgOperationType2;
})(BooleanCsgOperationType || {});
const BOOLEAN_CSG_OPERATION_TYPES = [
  "intersect" /* INTERSECT */,
  "subtract" /* SUBTRACT */,
  "union" /* UNION */
];
class CSGBooleanSopParamsConfig extends _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .NodeParamsConfig */ .yI {
  constructor() {
    super(...arguments);
    /** @param operation */
    this.operation = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .ParamConfig.INTEGER */ .XC.INTEGER(BOOLEAN_CSG_OPERATION_TYPES.indexOf("intersect" /* INTERSECT */), {
      menu: { entries: BOOLEAN_CSG_OPERATION_TYPES.map((name, value) => ({ name, value })) }
    });
  }
}
const ParamsConfig = new CSGBooleanSopParamsConfig();
class CSGBooleanSopNode extends _BaseCSG__WEBPACK_IMPORTED_MODULE_2__/* .CSGSopNode */ .O {
  constructor() {
    super(...arguments);
    this.paramsConfig = ParamsConfig;
  }
  static type() {
    return _poly_registers_nodes_types_Sop__WEBPACK_IMPORTED_MODULE_3__/* .SopType.CSG_BOOLEAN */ .aB.CSG_BOOLEAN;
  }
  initializeNode() {
    this.io.inputs.setCount(2);
  }
  setOperation(operation) {
    this.p.operation.set(BOOLEAN_CSG_OPERATION_TYPES.indexOf(operation));
  }
  cook(inputCoreGroups) {
    const objects = [];
    const objects0 = inputCoreGroups[0].csgObjects();
    const objects1 = inputCoreGroups[1].csgObjects();
    if (objects0 && objects1) {
      const count = Math.min(objects0.length, objects1.length);
      for (let i = 0; i < count; i++) {
        const object0 = objects0[i];
        const object1 = objects1[i];
        const result = this._applyOperation(object0.csgGeometry(), object1.csgGeometry());
        if (result) {
          objects.push(new _core_geometry_modules_csg_CsgObject__WEBPACK_IMPORTED_MODULE_4__/* .CsgObject */ .V(result));
        }
      }
    }
    this.setCSGObjects(objects);
  }
  _applyOperation(object0, object1) {
    const method = this._method();
    const bothAreGeom3 = (0,_core_geometry_modules_csg_CsgCoreType__WEBPACK_IMPORTED_MODULE_5__/* .csgIsGeom3 */ .Mq)(object0) && (0,_core_geometry_modules_csg_CsgCoreType__WEBPACK_IMPORTED_MODULE_5__/* .csgIsGeom3 */ .Mq)(object1);
    if (bothAreGeom3) {
      return method(object0, object1);
    }
    const bothAreGeom2 = (0,_core_geometry_modules_csg_CsgCoreType__WEBPACK_IMPORTED_MODULE_5__/* .csgIsGeom2 */ .IY)(object0) && (0,_core_geometry_modules_csg_CsgCoreType__WEBPACK_IMPORTED_MODULE_5__/* .csgIsGeom2 */ .IY)(object1);
    if (bothAreGeom2) {
      (0,_core_geometry_modules_csg_math_CsgMat4__WEBPACK_IMPORTED_MODULE_6__/* .csgApplyTransform */ .l6)(object0);
      (0,_core_geometry_modules_csg_math_CsgMat4__WEBPACK_IMPORTED_MODULE_6__/* .csgApplyTransform */ .l6)(object1);
      return method(object0, object1);
    }
  }
  _method() {
    const operation = BOOLEAN_CSG_OPERATION_TYPES[this.pv.operation];
    switch (operation) {
      case "intersect" /* INTERSECT */:
        return intersect;
      case "subtract" /* SUBTRACT */:
        return subtract;
      case "union" /* UNION */:
        return union;
    }
  }
}


/***/ }),

/***/ 92550:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "m": function() { return /* binding */ CameraControlsSopNode; }
/* harmony export */ });
/* harmony import */ var _Base__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(55839);
/* harmony import */ var _operations_sop_CameraControls__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(84953);
/* harmony import */ var _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(96949);
/* harmony import */ var _poly_NodeContext__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(52070);





class CameraControlsSopParamsConfig extends _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_0__/* .HierarchyParamConfigAll */ .Nc {
  constructor() {
    super(...arguments);
    /** @param renderer */
    this.node = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_0__/* .ParamConfig.NODE_PATH */ .XC.NODE_PATH("", {
      nodeSelection: {
        context: _poly_NodeContext__WEBPACK_IMPORTED_MODULE_1__/* .NodeContext.EVENT */ .sy.EVENT
      },
      dependentOnFoundNode: true
    });
  }
}
const ParamsConfig = new CameraControlsSopParamsConfig();
class CameraControlsSopNode extends _Base__WEBPACK_IMPORTED_MODULE_2__/* .TypedSopNode */ .x {
  constructor() {
    super(...arguments);
    this.paramsConfig = ParamsConfig;
    /*
    children
    */
    this._childrenControllerContext = _poly_NodeContext__WEBPACK_IMPORTED_MODULE_1__/* .NodeContext.EVENT */ .sy.EVENT;
  }
  static type() {
    return _poly_NodeContext__WEBPACK_IMPORTED_MODULE_1__/* .CameraSopNodeType.CONTROLS */ .$4.CONTROLS;
  }
  initializeNode() {
    this.io.inputs.setCount(1);
    this.io.inputs.initInputsClonedState(_operations_sop_CameraControls__WEBPACK_IMPORTED_MODULE_3__/* .CameraControlsSopOperation.INPUT_CLONED_STATE */ .y.INPUT_CLONED_STATE);
  }
  cook(inputCoreGroups) {
    this._operation = this._operation || new _operations_sop_CameraControls__WEBPACK_IMPORTED_MODULE_3__/* .CameraControlsSopOperation */ .y(this._scene, this.states, this);
    const coreGroup = this._operation.cook(inputCoreGroups, this.pv);
    this.setCoreGroup(coreGroup);
  }
  createNode(node_class, options) {
    return super.createNode(node_class, options);
  }
  children() {
    return super.children();
  }
  nodesByType(type) {
    return super.nodesByType(type);
  }
}


/***/ }),

/***/ 7999:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "f": function() { return /* binding */ CameraFPSSopNode; }
/* harmony export */ });
/* harmony import */ var _Base__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(55839);
/* harmony import */ var _operations_sop_CameraFPS__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(83532);
/* harmony import */ var _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(96949);
/* harmony import */ var _poly_NodeContext__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(52070);
/* harmony import */ var _core_camera_CoreCameraFPS__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(82524);






class CameraFPSSopParamsConfig extends (0,_core_camera_CoreCameraFPS__WEBPACK_IMPORTED_MODULE_0__/* .CoreCameraFPSParamConfig */ .mb)(_utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .HierarchyParamConfigAll */ .Nc) {
}
const ParamsConfig = new CameraFPSSopParamsConfig();
class CameraFPSSopNode extends _Base__WEBPACK_IMPORTED_MODULE_2__/* .TypedSopNode */ .x {
  constructor() {
    super(...arguments);
    this.paramsConfig = ParamsConfig;
  }
  static type() {
    return _poly_NodeContext__WEBPACK_IMPORTED_MODULE_3__/* .CameraSopNodeType.FPS */ .$4.FPS;
  }
  initializeNode() {
    this.io.inputs.setCount(1);
    this.io.inputs.initInputsClonedState(_operations_sop_CameraFPS__WEBPACK_IMPORTED_MODULE_4__/* .CameraFPSSopOperation.INPUT_CLONED_STATE */ .L.INPUT_CLONED_STATE);
  }
  cook(inputCoreGroups) {
    this._operation = this._operation || new _operations_sop_CameraFPS__WEBPACK_IMPORTED_MODULE_4__/* .CameraFPSSopOperation */ .L(this._scene, this.states, this);
    const coreGroup = this._operation.cook(inputCoreGroups, this.pv);
    this.setCoreGroup(coreGroup);
  }
}


/***/ }),

/***/ 15303:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "r": function() { return /* binding */ CameraFrameModeSopNode; }
/* harmony export */ });
/* harmony import */ var _Base__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(55839);
/* harmony import */ var _operations_sop_CameraFrameMode__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(18908);
/* harmony import */ var _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(96949);
/* harmony import */ var _poly_NodeContext__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(52070);
/* harmony import */ var _core_camera_CoreCameraFrameMode__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(67689);






class CameraFrameModeSopParamsConfig extends (0,_core_camera_CoreCameraFrameMode__WEBPACK_IMPORTED_MODULE_0__/* .CoreCameraFrameParamConfig */ .hN)(_utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .HierarchyParamConfigAll */ .Nc) {
}
const ParamsConfig = new CameraFrameModeSopParamsConfig();
class CameraFrameModeSopNode extends _Base__WEBPACK_IMPORTED_MODULE_2__/* .TypedSopNode */ .x {
  constructor() {
    super(...arguments);
    this.paramsConfig = ParamsConfig;
  }
  static type() {
    return _poly_NodeContext__WEBPACK_IMPORTED_MODULE_3__/* .CameraSopNodeType.FRAME_MODE */ .$4.FRAME_MODE;
  }
  initializeNode() {
    this.io.inputs.setCount(1);
    this.io.inputs.initInputsClonedState(_operations_sop_CameraFrameMode__WEBPACK_IMPORTED_MODULE_4__/* .CameraFrameModeSopOperation.INPUT_CLONED_STATE */ .d.INPUT_CLONED_STATE);
  }
  cook(inputCoreGroups) {
    this._operation = this._operation || new _operations_sop_CameraFrameMode__WEBPACK_IMPORTED_MODULE_4__/* .CameraFrameModeSopOperation */ .d(this._scene, this.states, this);
    const coreGroup = this._operation.cook(inputCoreGroups, this.pv);
    this.setCoreGroup(coreGroup);
  }
}


/***/ }),

/***/ 31708:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "D": function() { return /* binding */ CameraPostProcessSopNode; }
/* harmony export */ });
/* unused harmony export CameraPostProcessParamsMixin */
/* harmony import */ var _Base__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(55839);
/* harmony import */ var _operations_sop_CameraPostProcess__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(25385);
/* harmony import */ var _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(96949);
/* harmony import */ var _poly_NodeContext__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(52070);
/* harmony import */ var _post_utils_EffectComposerController__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(32241);
/* harmony import */ var _utils_DisplayNodeController__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(35725);







const DEFAULT = _operations_sop_CameraPostProcess__WEBPACK_IMPORTED_MODULE_0__/* .CameraPostProcessSopOperation.DEFAULT_PARAMS */ .W.DEFAULT_PARAMS;
function CameraPostProcessParamsMixin(Base) {
  return class Mixin extends Base {
    constructor() {
      super(...arguments);
      /** @param set to true to define the post process nodes from a different node than this one */
      this.useOtherNode = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .ParamConfig.BOOLEAN */ .XC.BOOLEAN(DEFAULT.useOtherNode);
      /** @param other parent node containing the post process nodes that will make up the passes used */
      this.node = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .ParamConfig.NODE_PATH */ .XC.NODE_PATH("", {
        visibleIf: { useOtherNode: 1 },
        nodeSelection: {
          types: [_poly_NodeContext__WEBPACK_IMPORTED_MODULE_2__/* .NetworkNodeType.POST */ .kX.POST, _poly_NodeContext__WEBPACK_IMPORTED_MODULE_2__/* .CameraSopNodeType.POST_PROCESS */ .$4.POST_PROCESS]
        },
        dependentOnFoundNode: true,
        separatorAfter: true
      });
    }
  };
}
class CameraPostProcessSopParamsConfig extends (0,_post_utils_EffectComposerController__WEBPACK_IMPORTED_MODULE_3__/* .PostProcessNetworkParamsConfigMixin */ .l_)(
  CameraPostProcessParamsMixin(_utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .HierarchyParamConfigAll */ .Nc)
) {
}
const ParamsConfig = new CameraPostProcessSopParamsConfig();
class CameraPostProcessSopNode extends _Base__WEBPACK_IMPORTED_MODULE_4__/* .TypedSopNode */ .x {
  constructor() {
    super(...arguments);
    this.paramsConfig = ParamsConfig;
    /*
    children
    */
    this.effectsComposerController = new _post_utils_EffectComposerController__WEBPACK_IMPORTED_MODULE_3__/* .EffectComposerController */ .iy(this);
    this.displayNodeController = new _utils_DisplayNodeController__WEBPACK_IMPORTED_MODULE_5__/* .DisplayNodeController */ .v(
      this,
      this.effectsComposerController.displayNodeControllerCallbacks()
    );
    this._childrenControllerContext = _poly_NodeContext__WEBPACK_IMPORTED_MODULE_2__/* .NodeContext.POST */ .sy.POST;
  }
  static type() {
    return _poly_NodeContext__WEBPACK_IMPORTED_MODULE_2__/* .CameraSopNodeType.POST_PROCESS */ .$4.POST_PROCESS;
  }
  initializeNode() {
    this.io.inputs.setCount(1);
    this.io.inputs.initInputsClonedState(_operations_sop_CameraPostProcess__WEBPACK_IMPORTED_MODULE_0__/* .CameraPostProcessSopOperation.INPUT_CLONED_STATE */ .W.INPUT_CLONED_STATE);
  }
  cook(inputCoreGroups) {
    this._operation = this._operation || new _operations_sop_CameraPostProcess__WEBPACK_IMPORTED_MODULE_0__/* .CameraPostProcessSopOperation */ .W(this._scene, this.states, this);
    const coreGroup = this._operation.cook(inputCoreGroups, this.pv);
    this.setCoreGroup(coreGroup);
  }
  setTextureType(textureType) {
    this.p.tTextureType.set(1);
    this.p.textureType.set(textureType);
  }
  createNode(node_class, options) {
    return super.createNode(node_class, options);
  }
  children() {
    return super.children();
  }
  nodesByType(type) {
    return super.nodesByType(type);
  }
}


/***/ }),

/***/ 84732:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "U": function() { return /* binding */ CameraProjectSopNode; }
/* harmony export */ });
/* harmony import */ var _Base__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(55839);
/* harmony import */ var _operations_sop_CameraProject__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(6490);
/* harmony import */ var _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(96949);
/* harmony import */ var _poly_registers_nodes_types_Sop__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(58986);





const DEFAULT = _operations_sop_CameraProject__WEBPACK_IMPORTED_MODULE_0__/* .CameraProjectSopOperation.DEFAULT_PARAMS */ .i.DEFAULT_PARAMS;
class CameraProjectSopParamsConfig extends _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .NodeParamsConfig */ .yI {
  constructor() {
    super(...arguments);
    /** @param unproject */
    this.project = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .ParamConfig.BOOLEAN */ .XC.BOOLEAN(DEFAULT.project);
  }
}
const ParamsConfig = new CameraProjectSopParamsConfig();
class CameraProjectSopNode extends _Base__WEBPACK_IMPORTED_MODULE_2__/* .TypedSopNode */ .x {
  constructor() {
    super(...arguments);
    this.paramsConfig = ParamsConfig;
  }
  static type() {
    return _poly_registers_nodes_types_Sop__WEBPACK_IMPORTED_MODULE_3__/* .SopType.CAMERA_PROJECT */ .aB.CAMERA_PROJECT;
  }
  initializeNode() {
    this.io.inputs.setCount(2);
    this.io.inputs.initInputsClonedState(_operations_sop_CameraProject__WEBPACK_IMPORTED_MODULE_0__/* .CameraProjectSopOperation.INPUT_CLONED_STATE */ .i.INPUT_CLONED_STATE);
  }
  cook(input_contents) {
    this._operation = this._operation || new _operations_sop_CameraProject__WEBPACK_IMPORTED_MODULE_0__/* .CameraProjectSopOperation */ .i(this._scene, this.states, this);
    const coreGroup = this._operation.cook(input_contents, this.pv);
    this.setCoreGroup(coreGroup);
  }
}


/***/ }),

/***/ 8341:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Z": function() { return /* binding */ CameraRenderSceneSopNode; }
/* harmony export */ });
/* harmony import */ var _Base__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(55839);
/* harmony import */ var _operations_sop_CameraRenderScene__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(73583);
/* harmony import */ var _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(96949);
/* harmony import */ var _poly_NodeContext__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(52070);
/* harmony import */ var _poly_registers_nodes_types_Obj__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(71501);






class CameraRenderSceneSopParamsConfig extends _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_0__/* .HierarchyParamConfigAll */ .Nc {
  constructor() {
    super(...arguments);
    /** @param renderer */
    this.node = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_0__/* .ParamConfig.NODE_PATH */ .XC.NODE_PATH("", {
      nodeSelection: {
        context: _poly_NodeContext__WEBPACK_IMPORTED_MODULE_1__/* .NodeContext.OBJ */ .sy.OBJ,
        types: [_poly_registers_nodes_types_Obj__WEBPACK_IMPORTED_MODULE_2__/* .ObjType.SCENE */ .B.SCENE]
      },
      dependentOnFoundNode: true
    });
  }
}
const ParamsConfig = new CameraRenderSceneSopParamsConfig();
class CameraRenderSceneSopNode extends _Base__WEBPACK_IMPORTED_MODULE_3__/* .TypedSopNode */ .x {
  constructor() {
    super(...arguments);
    this.paramsConfig = ParamsConfig;
  }
  static type() {
    return _poly_NodeContext__WEBPACK_IMPORTED_MODULE_1__/* .CameraSopNodeType.RENDER_SCENE */ .$4.RENDER_SCENE;
  }
  initializeNode() {
    this.io.inputs.setCount(1);
    this.io.inputs.initInputsClonedState(_operations_sop_CameraRenderScene__WEBPACK_IMPORTED_MODULE_4__/* .CameraRenderSceneSopOperation.INPUT_CLONED_STATE */ .i.INPUT_CLONED_STATE);
  }
  cook(inputCoreGroups) {
    this._operation = this._operation || new _operations_sop_CameraRenderScene__WEBPACK_IMPORTED_MODULE_4__/* .CameraRenderSceneSopOperation */ .i(this._scene, this.states, this);
    const core_group = this._operation.cook(inputCoreGroups, this.pv);
    this.setCoreGroup(core_group);
  }
}


/***/ }),

/***/ 61065:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "G": function() { return /* binding */ CameraViewOffsetSopNode; }
/* harmony export */ });
/* harmony import */ var _Base__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(55839);
/* harmony import */ var _operations_sop_CameraViewOffset__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(48863);
/* harmony import */ var _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(96949);
/* harmony import */ var _poly_NodeContext__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(52070);
/* harmony import */ var _core_camera_CoreCameraViewOffset__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(19682);






class CameraViewOffsetSopParamsConfig extends (0,_core_camera_CoreCameraViewOffset__WEBPACK_IMPORTED_MODULE_0__/* .CoreCameraViewOffsetParamConfig */ .p)(_utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .HierarchyParamConfigAll */ .Nc) {
}
const ParamsConfig = new CameraViewOffsetSopParamsConfig();
class CameraViewOffsetSopNode extends _Base__WEBPACK_IMPORTED_MODULE_2__/* .TypedSopNode */ .x {
  constructor() {
    super(...arguments);
    this.paramsConfig = ParamsConfig;
  }
  static type() {
    return _poly_NodeContext__WEBPACK_IMPORTED_MODULE_3__/* .CameraSopNodeType.VIEW_OFFSET */ .$4.VIEW_OFFSET;
  }
  initializeNode() {
    this.io.inputs.setCount(1);
    this.io.inputs.initInputsClonedState(_operations_sop_CameraViewOffset__WEBPACK_IMPORTED_MODULE_4__/* .CameraViewOffsetSopOperation.INPUT_CLONED_STATE */ .c.INPUT_CLONED_STATE);
  }
  cook(inputCoreGroups) {
    this._operation = this._operation || new _operations_sop_CameraViewOffset__WEBPACK_IMPORTED_MODULE_4__/* .CameraViewOffsetSopOperation */ .c(this._scene, this.states, this);
    const coreGroup = this._operation.cook(inputCoreGroups, this.pv);
    this.setCoreGroup(coreGroup);
  }
}


/***/ }),

/***/ 22952:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {


// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  "c": function() { return /* binding */ CameraWebXRARSopNode; }
});

// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/nodes/sop/_Base.ts
var _Base = __webpack_require__(55839);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/operations/sop/CameraWebXRAR.ts + 2 modules
var CameraWebXRAR = __webpack_require__(21382);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/nodes/utils/params/ParamsConfig.ts
var ParamsConfig = __webpack_require__(96949);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/poly/NodeContext.ts
var NodeContext = __webpack_require__(52070);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/core/webXR/Common.ts
var Common = __webpack_require__(25226);
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/core/camera/webXR/CoreCameraWebXRAR.ts




const DEFAULT = CameraWebXRAR/* CameraWebXRARSopOperation.DEFAULT_PARAMS */.h.DEFAULT_PARAMS;
function CoreCameraWebXRARParamConfig(Base) {
  return class Mixin extends Base {
    constructor() {
      super(...arguments);
      /** @param loads AR session with 'hit-test' feature */
      this.hitTest = ParamsConfig/* ParamConfig.INTEGER */.XC.INTEGER(DEFAULT.hitTest, Common/* WEBXR_FEATURE_PARAM_OPTIONS */.Tk);
      /** @param loads AR session with 'light-estimation' feature */
      this.lightEstimation = ParamsConfig/* ParamConfig.INTEGER */.XC.INTEGER(DEFAULT.lightEstimation, Common/* WEBXR_FEATURE_PARAM_OPTIONS */.Tk);
      /** @param loads AR session with 'camera-access' feature */
      this.cameraAccess = ParamsConfig/* ParamConfig.INTEGER */.XC.INTEGER(DEFAULT.cameraAccess, Common/* WEBXR_FEATURE_PARAM_OPTIONS */.Tk);
      /** @param overrides referenceSpaceType */
      this.overrideReferenceSpaceType = ParamsConfig/* ParamConfig.BOOLEAN */.XC.BOOLEAN(0);
      /** @param set referenceSpaceType ( see doc: https://immersive-web.github.io/webxr/#xrreferencespace-interface ) */
      this.referenceSpaceType = ParamsConfig/* ParamConfig.INTEGER */.XC.INTEGER(
        Common/* WEBXR_REFERENCE_SPACE_TYPES.indexOf */.BK.indexOf(Common/* DEFAULT_WEBXR_REFERENCE_SPACE_TYPE */.WI),
        {
          menu: {
            entries: Common/* WEBXR_REFERENCE_SPACE_TYPES.map */.BK.map((name, value) => ({ name, value }))
          },
          visibleIf: {
            overrideReferenceSpaceType: 1
          }
        }
      );
    }
  };
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/sop/CameraWebXRAR.ts






class CameraWebXRARSopParamsConfig extends CoreCameraWebXRARParamConfig(ParamsConfig/* HierarchyParamConfigAll */.Nc) {
}
const CameraWebXRAR_ParamsConfig = new CameraWebXRARSopParamsConfig();
class CameraWebXRARSopNode extends _Base/* TypedSopNode */.x {
  constructor() {
    super(...arguments);
    this.paramsConfig = CameraWebXRAR_ParamsConfig;
  }
  static type() {
    return NodeContext/* CameraSopNodeType.WEBXR_AR */.$4.WEBXR_AR;
  }
  initializeNode() {
    this.io.inputs.setCount(1);
    this.io.inputs.initInputsClonedState(CameraWebXRAR/* CameraWebXRARSopOperation.INPUT_CLONED_STATE */.h.INPUT_CLONED_STATE);
  }
  cook(inputCoreGroups) {
    this._operation = this._operation || new CameraWebXRAR/* CameraWebXRARSopOperation */.h(this._scene, this.states, this);
    const coreGroup = this._operation.cook(inputCoreGroups, this.pv);
    this.setCoreGroup(coreGroup);
  }
}


/***/ }),

/***/ 18735:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {


// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  "_": function() { return /* binding */ CameraWebXRVRSopNode; }
});

// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/nodes/sop/_Base.ts
var _Base = __webpack_require__(55839);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/operations/sop/CameraWebXRVR.ts + 2 modules
var CameraWebXRVR = __webpack_require__(71175);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/nodes/utils/params/ParamsConfig.ts
var ParamsConfig = __webpack_require__(96949);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/poly/NodeContext.ts
var NodeContext = __webpack_require__(52070);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/core/webXR/Common.ts
var Common = __webpack_require__(25226);
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/core/camera/webXR/CoreCameraWebXRVR.ts




const DEFAULT = CameraWebXRVR/* CameraWebXRVRSopOperation.DEFAULT_PARAMS */.c.DEFAULT_PARAMS;
function CoreCameraWebXRVRParamConfig(Base) {
  return class Mixin extends Base {
    constructor() {
      super(...arguments);
      /** @param loads AR session with 'local-floor' feature */
      this.localFloor = ParamsConfig/* ParamConfig.INTEGER */.XC.INTEGER(DEFAULT.localFloor, Common/* WEBXR_FEATURE_PARAM_OPTIONS */.Tk);
      /** @param loads AR session with 'bounded-floor' feature */
      this.boundedFloor = ParamsConfig/* ParamConfig.INTEGER */.XC.INTEGER(DEFAULT.boundedFloor, Common/* WEBXR_FEATURE_PARAM_OPTIONS */.Tk);
      /** @param loads AR session with 'hand-tracking' feature */
      this.handTracking = ParamsConfig/* ParamConfig.INTEGER */.XC.INTEGER(DEFAULT.handTracking, Common/* WEBXR_FEATURE_PARAM_OPTIONS */.Tk);
      /** @param loads AR session with 'layers' feature */
      this.layers = ParamsConfig/* ParamConfig.INTEGER */.XC.INTEGER(DEFAULT.layers, Common/* WEBXR_FEATURE_PARAM_OPTIONS */.Tk);
      /** @param overrides referenceSpaceType */
      this.overrideReferenceSpaceType = ParamsConfig/* ParamConfig.BOOLEAN */.XC.BOOLEAN(0);
      /** @param set referenceSpaceType ( see doc: https://immersive-web.github.io/webxr/#xrreferencespace-interface ) */
      this.referenceSpaceType = ParamsConfig/* ParamConfig.INTEGER */.XC.INTEGER(
        Common/* WEBXR_REFERENCE_SPACE_TYPES.indexOf */.BK.indexOf(Common/* DEFAULT_WEBXR_REFERENCE_SPACE_TYPE */.WI),
        {
          menu: {
            entries: Common/* WEBXR_REFERENCE_SPACE_TYPES.map */.BK.map((name, value) => ({ name, value }))
          },
          visibleIf: {
            overrideReferenceSpaceType: 1
          }
        }
      );
    }
  };
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/sop/CameraWebXRVR.ts






class CameraWebXRVRSopParamsConfig extends CoreCameraWebXRVRParamConfig(ParamsConfig/* HierarchyParamConfigAll */.Nc) {
}
const CameraWebXRVR_ParamsConfig = new CameraWebXRVRSopParamsConfig();
class CameraWebXRVRSopNode extends _Base/* TypedSopNode */.x {
  constructor() {
    super(...arguments);
    this.paramsConfig = CameraWebXRVR_ParamsConfig;
  }
  static type() {
    return NodeContext/* CameraSopNodeType.WEBXR_VR */.$4.WEBXR_VR;
  }
  initializeNode() {
    this.io.inputs.setCount(1);
    this.io.inputs.initInputsClonedState(CameraWebXRVR/* CameraWebXRVRSopOperation.INPUT_CLONED_STATE */.c.INPUT_CLONED_STATE);
  }
  cook(inputCoreGroups) {
    this._operation = this._operation || new CameraWebXRVR/* CameraWebXRVRSopOperation */.c(this._scene, this.states, this);
    const coreGroup = this._operation.cook(inputCoreGroups, this.pv);
    this.setCoreGroup(coreGroup);
  }
}


/***/ }),

/***/ 61763:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "t": function() { return /* binding */ CenterSopNode; }
/* harmony export */ });
/* harmony import */ var _Base__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(55839);
/* harmony import */ var _operations_sop_Center__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(66054);
/* harmony import */ var _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(96949);




const DEFAULT = _operations_sop_Center__WEBPACK_IMPORTED_MODULE_0__/* .CenterSopOperation.DEFAULT_PARAMS */ .Ng.DEFAULT_PARAMS;
class CenterSopParamsConfig extends _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .NodeParamsConfig */ .yI {
  constructor() {
    super(...arguments);
    this.mode = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .ParamConfig.INTEGER */ .XC.INTEGER(DEFAULT.mode, {
      menu: {
        entries: _operations_sop_Center__WEBPACK_IMPORTED_MODULE_0__/* .CENTER_MODES.map */ .Hx.map((name, value) => ({ name, value }))
      }
    });
  }
}
const ParamsConfig = new CenterSopParamsConfig();
class CenterSopNode extends _Base__WEBPACK_IMPORTED_MODULE_2__/* .TypedSopNode */ .x {
  constructor() {
    super(...arguments);
    this.paramsConfig = ParamsConfig;
  }
  static type() {
    return "center";
  }
  initializeNode() {
    this.io.inputs.setCount(1);
    this.io.inputs.initInputsClonedState(_operations_sop_Center__WEBPACK_IMPORTED_MODULE_0__/* .CenterSopOperation.INPUT_CLONED_STATE */ .Ng.INPUT_CLONED_STATE);
  }
  cook(input_contents) {
    this._operation = this._operation || new _operations_sop_Center__WEBPACK_IMPORTED_MODULE_0__/* .CenterSopOperation */ .Ng(this.scene(), this.states, this);
    const core_group = this._operation.cook(input_contents, this.pv);
    this.setCoreGroup(core_group);
  }
  setMode(mode) {
    this.p.mode.set(_operations_sop_Center__WEBPACK_IMPORTED_MODULE_0__/* .CENTER_MODES.indexOf */ .Hx.indexOf(mode));
  }
}


/***/ }),

/***/ 57568:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "j": function() { return /* binding */ Circle3PointsSopNode; }
/* harmony export */ });
/* harmony import */ var _Base__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(55839);
/* harmony import */ var _poly_InputCloneMode__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(56752);
/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(21410);
/* harmony import */ var _core_geometry_Constant__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(91568);
/* harmony import */ var _core_geometry_operation_Circle3Points__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(99450);
/* harmony import */ var _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(96949);
/* harmony import */ var _core_BooleanValue__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(19037);
/* harmony import */ var _poly_registers_nodes_types_Sop__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(58986);









const _points = [];
class Circle3PointsSopParamsConfig extends _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_0__/* .NodeParamsConfig */ .yI {
  constructor() {
    super(...arguments);
    /** @param toggle on to create the arc */
    this.arc = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_0__/* .ParamConfig.BOOLEAN */ .XC.BOOLEAN(1);
    /** @param sets the mode how the points count is computed */
    this.pointsCountMode = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_0__/* .ParamConfig.INTEGER */ .XC.INTEGER(_core_geometry_operation_Circle3Points__WEBPACK_IMPORTED_MODULE_1__/* .POINTS_COUNT_MODE.indexOf */ .B8.indexOf(_core_geometry_operation_Circle3Points__WEBPACK_IMPORTED_MODULE_1__/* .PointsCountMode.SEGMENTS_COUNT */ ._t.SEGMENTS_COUNT), {
      visibleIf: { arc: 1 },
      menu: {
        entries: _core_geometry_operation_Circle3Points__WEBPACK_IMPORTED_MODULE_1__/* .POINTS_COUNT_MODE.map */ .B8.map((name, value) => {
          return { value, name };
        })
      }
    });
    /** @param length of each segment */
    this.segmentsLength = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_0__/* .ParamConfig.FLOAT */ .XC.FLOAT(0.1, {
      visibleIf: { arc: 1, pointsCountMode: _core_geometry_operation_Circle3Points__WEBPACK_IMPORTED_MODULE_1__/* .POINTS_COUNT_MODE.indexOf */ .B8.indexOf(_core_geometry_operation_Circle3Points__WEBPACK_IMPORTED_MODULE_1__/* .PointsCountMode.SEGMENTS_LENGTH */ ._t.SEGMENTS_LENGTH) },
      range: [0, 1],
      rangeLocked: [true, false]
    });
    /** @param count of the number of segments */
    this.segmentsCount = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_0__/* .ParamConfig.INTEGER */ .XC.INTEGER(100, {
      visibleIf: { arc: 1, pointsCountMode: _core_geometry_operation_Circle3Points__WEBPACK_IMPORTED_MODULE_1__/* .POINTS_COUNT_MODE.indexOf */ .B8.indexOf(_core_geometry_operation_Circle3Points__WEBPACK_IMPORTED_MODULE_1__/* .PointsCountMode.SEGMENTS_COUNT */ ._t.SEGMENTS_COUNT) },
      range: [1, 100],
      rangeLocked: [true, false]
    });
    /** @param toggle on to create a full circle */
    this.full = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_0__/* .ParamConfig.BOOLEAN */ .XC.BOOLEAN(1, {
      visibleIf: { arc: 1 }
    });
    /** @param TBD */
    this.joinMode = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_0__/* .ParamConfig.INTEGER */ .XC.INTEGER(_core_geometry_operation_Circle3Points__WEBPACK_IMPORTED_MODULE_1__/* .JOIN_MODES.indexOf */ .Zc.indexOf(_core_geometry_operation_Circle3Points__WEBPACK_IMPORTED_MODULE_1__/* .JoinMode.ABC */ .cW.ABC), {
      visibleIf: { arc: 1, full: 0 },
      menu: {
        entries: _core_geometry_operation_Circle3Points__WEBPACK_IMPORTED_MODULE_1__/* .JOIN_MODES.map */ .Zc.map((name, value) => {
          return { value, name };
        })
      }
    });
    /** @param add an id attribute for the generated points */
    this.addIdAttribute = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_0__/* .ParamConfig.BOOLEAN */ .XC.BOOLEAN(1);
    /** @param add an idn attribute (same as id attribute, but normalized between 0 and 1) */
    this.addIdnAttribute = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_0__/* .ParamConfig.BOOLEAN */ .XC.BOOLEAN(1);
    /** @param toggle on to create a point in the center */
    this.center = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_0__/* .ParamConfig.BOOLEAN */ .XC.BOOLEAN(0);
  }
}
const ParamsConfig = new Circle3PointsSopParamsConfig();
class Circle3PointsSopNode extends _Base__WEBPACK_IMPORTED_MODULE_2__/* .TypedSopNode */ .x {
  constructor() {
    super(...arguments);
    this.paramsConfig = ParamsConfig;
    this.a = new three__WEBPACK_IMPORTED_MODULE_3__.Vector3();
    this.b = new three__WEBPACK_IMPORTED_MODULE_3__.Vector3();
    this.c = new three__WEBPACK_IMPORTED_MODULE_3__.Vector3();
  }
  static type() {
    return _poly_registers_nodes_types_Sop__WEBPACK_IMPORTED_MODULE_4__/* .SopType.CIRCLE_3_POINTS */ .aB.CIRCLE_3_POINTS;
  }
  initializeNode() {
    this.io.inputs.setCount(1);
    this.io.inputs.initInputsClonedState([_poly_InputCloneMode__WEBPACK_IMPORTED_MODULE_5__/* .InputCloneMode.NEVER */ .m.NEVER]);
  }
  setPointsCountMode(mode) {
    this.p.pointsCountMode.set(_core_geometry_operation_Circle3Points__WEBPACK_IMPORTED_MODULE_1__/* .POINTS_COUNT_MODE.indexOf */ .B8.indexOf(mode));
  }
  pointsCountMode() {
    return _core_geometry_operation_Circle3Points__WEBPACK_IMPORTED_MODULE_1__/* .POINTS_COUNT_MODE */ .B8[this.pv.pointsCountMode];
  }
  cook(inputCoreGroups) {
    const coreGroup = inputCoreGroups[0];
    coreGroup.points(_points);
    if (_points.length < 3) {
      this.states.error.set(`only ${_points.length} points found, when 3 are required`);
    } else {
      this._createCircle(_points);
    }
  }
  _createCircle(points) {
    const circle3points = new _core_geometry_operation_Circle3Points__WEBPACK_IMPORTED_MODULE_1__/* .Circle3Points */ .Dr({
      arc: (0,_core_BooleanValue__WEBPACK_IMPORTED_MODULE_6__/* .isBooleanTrue */ .bI)(this.pv.arc),
      center: (0,_core_BooleanValue__WEBPACK_IMPORTED_MODULE_6__/* .isBooleanTrue */ .bI)(this.pv.center),
      pointsCountMode: _core_geometry_operation_Circle3Points__WEBPACK_IMPORTED_MODULE_1__/* .POINTS_COUNT_MODE */ .B8[this.pv.pointsCountMode],
      segmentsLength: this.pv.segmentsLength,
      segmentsCount: this.pv.segmentsCount,
      full: (0,_core_BooleanValue__WEBPACK_IMPORTED_MODULE_6__/* .isBooleanTrue */ .bI)(this.pv.full),
      joinMode: _core_geometry_operation_Circle3Points__WEBPACK_IMPORTED_MODULE_1__/* .JOIN_MODES */ .Zc[this.pv.joinMode],
      addIdAttribute: (0,_core_BooleanValue__WEBPACK_IMPORTED_MODULE_6__/* .isBooleanTrue */ .bI)(this.pv.addIdAttribute),
      addIdnAttribute: (0,_core_BooleanValue__WEBPACK_IMPORTED_MODULE_6__/* .isBooleanTrue */ .bI)(this.pv.addIdnAttribute)
    });
    points[0].position(this.a);
    points[1].position(this.b);
    points[2].position(this.c);
    circle3points.create(this.a, this.b, this.c);
    const objects = [];
    const created_geometries = circle3points.created_geometries();
    if (created_geometries.arc) {
      objects.push(this.createObject(created_geometries.arc, _core_geometry_Constant__WEBPACK_IMPORTED_MODULE_7__/* .ObjectType.LINE_SEGMENTS */ .LP.LINE_SEGMENTS));
    }
    if (created_geometries.center) {
      objects.push(this.createObject(created_geometries.center, _core_geometry_Constant__WEBPACK_IMPORTED_MODULE_7__/* .ObjectType.POINTS */ .LP.POINTS));
    }
    let i = 0;
    for (const object of objects) {
      object.name = `${this.name()}-${i}`;
      i++;
    }
    this.setObjects(objects);
  }
}


/***/ }),

/***/ 52330:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "w": function() { return /* binding */ ConeSopNode; }
/* harmony export */ });
/* harmony import */ var _core_geometry_Constant__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(91568);
/* harmony import */ var _Base__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(55839);
/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(21410);
/* harmony import */ var _core_Transform__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(87883);
/* harmony import */ var _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(96949);
/* harmony import */ var _core_BooleanValue__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(19037);
/* harmony import */ var _operations_sop_Base__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(82612);
/* harmony import */ var _poly_registers_nodes_types_Sop__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(58986);










const DEFAULT_UP = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3(0, 1, 0);
class ConeSopParamsConfig extends _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .NodeParamsConfig */ .yI {
  constructor() {
    super(...arguments);
    /** @param cone radius */
    this.radius = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .ParamConfig.FLOAT */ .XC.FLOAT(1, { range: [0, 1] });
    /** @param cone height */
    this.height = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .ParamConfig.FLOAT */ .XC.FLOAT(1, { range: [0, 1] });
    /** @param radial segments count */
    this.segmentsRadial = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .ParamConfig.INTEGER */ .XC.INTEGER(12, { range: [3, 20], rangeLocked: [true, false] });
    /** @param height segments count */
    this.segmentsHeight = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .ParamConfig.INTEGER */ .XC.INTEGER(1, { range: [1, 20], rangeLocked: [true, false] });
    /** @param adds a cap */
    this.cap = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .ParamConfig.BOOLEAN */ .XC.BOOLEAN(1);
    /** @param theta start */
    this.thetaStart = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .ParamConfig.FLOAT */ .XC.FLOAT(1, { range: [0, Math.PI * 2] });
    /** @param start length */
    this.thetaLength = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .ParamConfig.FLOAT */ .XC.FLOAT("2*$PI", { range: [0, Math.PI * 2] });
    /** @param center */
    this.center = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .ParamConfig.VECTOR3 */ .XC.VECTOR3([0, 0, 0]);
    /** @param direction */
    this.direction = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .ParamConfig.VECTOR3 */ .XC.VECTOR3([0, 1, 0]);
  }
  // should point up to match RBD expectation
}
const ParamsConfig = new ConeSopParamsConfig();
class ConeSopNode extends _Base__WEBPACK_IMPORTED_MODULE_2__/* .TypedSopNode */ .x {
  constructor() {
    super(...arguments);
    this.paramsConfig = ParamsConfig;
  }
  static type() {
    return _poly_registers_nodes_types_Sop__WEBPACK_IMPORTED_MODULE_3__/* .SopType.CONE */ .aB.CONE;
  }
  cook() {
    const geometry = new three__WEBPACK_IMPORTED_MODULE_0__.ConeGeometry(
      this.pv.radius,
      this.pv.height,
      this.pv.segmentsRadial,
      this.pv.segmentsHeight,
      !(0,_core_BooleanValue__WEBPACK_IMPORTED_MODULE_4__/* .isBooleanTrue */ .bI)(this.pv.cap),
      this.pv.thetaStart,
      this.pv.thetaLength
    );
    (0,_core_Transform__WEBPACK_IMPORTED_MODULE_5__/* .rotateGeometry */ .bP)(geometry, DEFAULT_UP, this.pv.direction);
    geometry.translate(this.pv.center.x, this.pv.center.y, this.pv.center.z);
    const object = _operations_sop_Base__WEBPACK_IMPORTED_MODULE_6__/* .BaseSopOperation.createObject */ .U.createObject(geometry, _core_geometry_Constant__WEBPACK_IMPORTED_MODULE_7__/* .ObjectType.MESH */ .LP.MESH);
    object.name = this.name();
    this.setObject(object);
  }
}


/***/ }),

/***/ 37554:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {


// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  "a": function() { return /* binding */ CopySopNode; }
});

// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/core/TransformSpace.ts
var TransformSpace = __webpack_require__(30537);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/poly/registers/nodes/types/Sop.ts
var Sop = __webpack_require__(58986);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/nodes/sop/_Base.ts
var _Base = __webpack_require__(55839);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/core/geometry/entities/object/BaseCoreObject.ts + 1 modules
var BaseCoreObject = __webpack_require__(78531);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/core/geometry/Instancer.ts
var Instancer = __webpack_require__(23786);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/core/graph/CoreGraphNode.ts + 1 modules
var CoreGraphNode = __webpack_require__(45516);
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/utils/BaseCopyStamp.ts


class BaseCopyStamp extends CoreGraphNode/* CoreGraphNode */.Y {
  constructor(scene) {
    super(scene, "CopyStamp");
  }
  reset() {
    this.setGlobalIndex(0);
  }
  setGlobalIndex(index) {
    const oldIndex = this._globalIndex;
    this._globalIndex = index;
    if (oldIndex != this._globalIndex) {
      this.setDirty();
      this.removeDirtyState();
    }
  }
  value(attribName) {
    return this._globalIndex;
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/sop/utils/CopyStamp.ts


class SopCopyStamp extends BaseCopyStamp {
  reset() {
    super.reset();
    this.setPoint(void 0);
  }
  setPoint(point) {
    const oldPoint = this._point;
    this._point = point;
    if (oldPoint != this._point) {
      this.setDirty();
      this.removeDirtyState();
    }
  }
  value(attribName) {
    if (this._point) {
      if (attribName) {
        return this._point.attribValue(attribName);
      } else {
        return this._point.index();
      }
    } else {
      if (attribName == null || attribName == "i") {
        return this._globalIndex;
      }
    }
  }
}

// EXTERNAL MODULE: ../@polygonjs/polygonjs/node_modules/three/build/three.module.js
var three_module = __webpack_require__(21410);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/nodes/utils/params/ParamsConfig.ts
var ParamsConfig = __webpack_require__(96949);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/poly/InputCloneMode.ts
var InputCloneMode = __webpack_require__(56752);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/core/Type.ts
var Type = __webpack_require__(19037);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/core/geometry/Mask.ts
var Mask = __webpack_require__(58290);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/core/Transform.ts
var Transform = __webpack_require__(87883);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/core/geometry/CoreObjectFactory.ts
var CoreObjectFactory = __webpack_require__(17353);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/core/geometry/entities/point/CorePointUtils.ts
var CorePointUtils = __webpack_require__(50253);
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/sop/Copy.ts

var __async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};















class CopySopParamsConfig extends ParamsConfig/* NodeParamsConfig */.yI {
  constructor() {
    super(...arguments);
    /** @param select which objects are copied */
    this.srcGroup = ParamsConfig/* ParamConfig.STRING */.XC.STRING("", {
      objectMask: true
    });
    /** @param select which objects the src objects are copied onto */
    this.templateGroup = ParamsConfig/* ParamConfig.STRING */.XC.STRING("", {
      objectMask: {
        inputIndex: 1
      }
    });
    /** @param copies count, used when the second input is not given */
    this.count = ParamsConfig/* ParamConfig.INTEGER */.XC.INTEGER(1, {
      range: [1, 20],
      rangeLocked: [true, false]
    });
    /** @param translate each copy */
    this.t = ParamsConfig/* ParamConfig.VECTOR3 */.XC.VECTOR3([0, 0, 0]);
    /** @param rotate each copy */
    this.r = ParamsConfig/* ParamConfig.VECTOR3 */.XC.VECTOR3([0, 0, 0]);
    /** @param scale each copy */
    this.s = ParamsConfig/* ParamConfig.VECTOR3 */.XC.VECTOR3([1, 1, 1]);
    /** @param scale multiplier for each copy */
    this.scale = ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(1);
    /** @param transforms every input object each on a single input point */
    this.transformOnly = ParamsConfig/* ParamConfig.BOOLEAN */.XC.BOOLEAN(0);
    /** @param defines if the objects or the geometries are transformed */
    this.transformMode = ParamsConfig/* ParamConfig.INTEGER */.XC.INTEGER(Transform/* TRANSFORM_TARGET_TYPES.indexOf */.Pr.indexOf(Transform/* TransformTargetType.OBJECT */.dH.OBJECT), {
      menu: {
        entries: Transform/* TRANSFORM_TARGET_TYPES.map */.Pr.map((name, value) => ({ name, value }))
      }
    });
    /** @param defines how the objects are transformed */
    this.objectTransformSpace = ParamsConfig/* ParamConfig.INTEGER */.XC.INTEGER(0, {
      visibleIf: { transformMode: Transform/* TRANSFORM_TARGET_TYPES.indexOf */.Pr.indexOf(Transform/* TransformTargetType.OBJECT */.dH.OBJECT) },
      menu: {
        entries: TransformSpace/* OBJECT_TRANSFORM_SPACE_MENU_ENTRIES */.ce
      }
    });
    /** @param toggles on to copy attributes from the input points to the created objects. Note that the vertex attributes from the points become object attributes */
    this.copyAttributes = ParamsConfig/* ParamConfig.BOOLEAN */.XC.BOOLEAN(0);
    /** @param names of attributes to copy */
    this.attributesToCopy = ParamsConfig/* ParamConfig.STRING */.XC.STRING("", {
      visibleIf: { copyAttributes: true }
    });
    /** @param toggle on to use the `copy` expression, which allows to change how the left input is evaluated for each point */
    this.useCopyExpr = ParamsConfig/* ParamConfig.BOOLEAN */.XC.BOOLEAN(1);
  }
}
const Copy_ParamsConfig = new CopySopParamsConfig();
class CopySopNode extends _Base/* TypedSopNode */.x {
  constructor() {
    super(...arguments);
    this.paramsConfig = Copy_ParamsConfig;
    this._attribNamesToCopy = [];
    this._objects = [];
    this._instancer = new Instancer/* CoreInstancer */.t();
    this._instanceMatrix = new three_module.Matrix4();
    //
    //
    // ACCUMULATE TRANSFORM
    //
    //
    this._coreTransform = new Transform/* CoreTransform */.ZR();
    this._transformAccumulatedMatrix = new three_module.Matrix4();
    this._transformMatrix = new three_module.Matrix4();
  }
  static type() {
    return Sop/* SopType.COPY */.aB.COPY;
  }
  initializeNode() {
    this.io.inputs.setCount(1, 2);
    this.io.inputs.initInputsClonedState([InputCloneMode/* InputCloneMode.FROM_NODE */.m.FROM_NODE, InputCloneMode/* InputCloneMode.NEVER */.m.NEVER]);
  }
  setTransformMode(transformMode) {
    this.p.transformMode.set(Transform/* TRANSFORM_TARGET_TYPES.indexOf */.Pr.indexOf(transformMode));
  }
  setObjectTransformSpace(transformSpace) {
    this.p.objectTransformSpace.set(TransformSpace/* OBJECT_TRANSFORM_SPACES.indexOf */.LD.indexOf(transformSpace));
  }
  cook(inputCoreGroups) {
    return __async(this, null, function* () {
      if (!(0,Type/* isBooleanTrue */.bI)(this.pv.useCopyExpr)) {
        this.stampNode().reset();
      }
      const coreGroup0 = inputCoreGroups[0];
      if (!this.io.inputs.hasInput(1)) {
        yield this.cookWithoutTemplate(coreGroup0);
        return;
      }
      const coreGroup1 = inputCoreGroups[1];
      if (!coreGroup1) {
        this.states.error.set("second input invalid");
        return;
      }
      yield this.cookWithTemplate(coreGroup0, coreGroup1);
      this.stampNode().reset();
    });
  }
  cookWithTemplate(instanceCoreGroup, templateCoreGroup) {
    return __async(this, null, function* () {
      this._objects = [];
      const templateCoreObjects = (0,Mask/* filterThreejsCoreObjectsFromCoreGroup */.eV)(templateCoreGroup, {
        group: this.pv.templateGroup
      });
      const templatePoints = [];
      (0,CorePointUtils/* pointsFromCoreObjects */.t4)(templateCoreObjects, templatePoints);
      this._instancer.setCoreGroup(templateCoreGroup);
      this._attribNamesToCopy = templateCoreGroup.pointAttribNamesMatchingMask(this.pv.attributesToCopy);
      yield this._copyMovedObjectsOnTemplatePoints(instanceCoreGroup, templatePoints);
      this.setObjects(this._objects);
    });
  }
  // https://stackoverflow.com/questions/24586110/resolve-promises-one-after-another-i-e-in-sequence
  _copyMovedObjectsOnTemplatePoints(instanceCoreGroup, templatePoints) {
    return __async(this, null, function* () {
      this._initAccumulatedTransform();
      for (let pointIndex = 0; pointIndex < templatePoints.length; pointIndex++) {
        yield this._copyMovedObjectOnTemplatePoint(instanceCoreGroup, templatePoints, pointIndex);
        this._accumulateTransform();
      }
    });
  }
  _copyMovedObjectOnTemplatePoint(instanceCoreGroup, templatePoints, point_index) {
    return __async(this, null, function* () {
      this._instancer.matrixFromPoint(templatePoints[point_index], this._instanceMatrix);
      const templatePoint = templatePoints[point_index];
      if ((0,Type/* isBooleanTrue */.bI)(this.pv.useCopyExpr)) {
        this.stampNode().setPoint(templatePoint);
      }
      const movedObjects = yield this._getMovedObjectsForTemplatePoint(instanceCoreGroup, point_index);
      for (const movedObject of movedObjects) {
        if ((0,Type/* isBooleanTrue */.bI)(this.pv.copyAttributes)) {
          this._copyAttributesGromTemplate(movedObject, templatePoint);
        }
        if ((0,Type/* isBooleanTrue */.bI)(this.pv.transformOnly)) {
          movedObject.applyMatrix4(this._instanceMatrix);
        } else {
          this._applyMatrixToObject(movedObject, this._instanceMatrix);
        }
        this._applyAccumulatedTransform(movedObject);
        this._objects.push(movedObject);
      }
    });
  }
  _getMovedObjectsForTemplatePoint(instanceCoreGroup, pointIndex) {
    return __async(this, null, function* () {
      const stampedInstanceCoreGroup = yield this._stampInstanceGroupIfRequired(instanceCoreGroup);
      if (stampedInstanceCoreGroup) {
        const getObjectsForTransformOnly = () => {
          const objects = (0,Mask/* filterObjectsWithGroup */.hJ)(stampedInstanceCoreGroup, { group: this.pv.srcGroup });
          const object = objects[pointIndex];
          if (object) {
            return [(0,CoreObjectFactory/* coreObjectClassFactory */.Xr)(object).clone(object)];
          } else {
            return [];
          }
        };
        const movedObjects = (0,Type/* isBooleanTrue */.bI)(this.pv.transformOnly) ? (
          // TODO: why is doing a transform slower than cloning the input??
          getObjectsForTransformOnly()
        ) : (0,Mask/* filterObjectsWithGroup */.hJ)(stampedInstanceCoreGroup.clone(), { group: this.pv.srcGroup });
        return movedObjects;
      } else {
        return [];
      }
    });
  }
  _stampInstanceGroupIfRequired(instanceCoreGroup) {
    return __async(this, null, function* () {
      const container0 = yield this.containerController.requestInputContainer(0);
      if (container0) {
        const coreGroup0 = container0.coreContent();
        if (coreGroup0) {
          return coreGroup0;
        } else {
          return;
        }
      } else {
        this.states.error.set(`input failed for index ${this.stampValue()}`);
        return;
      }
    });
  }
  _copyMovedObjectsForEachInstance(instanceCoreGroup) {
    return __async(this, null, function* () {
      this._initAccumulatedTransform();
      for (let i = 0; i < this.pv.count; i++) {
        yield this._copyMovedObjectsForInstance(instanceCoreGroup, i);
        this._accumulateTransform();
      }
    });
  }
  _copyMovedObjectsForInstance(instanceCoreGroup, i) {
    return __async(this, null, function* () {
      if ((0,Type/* isBooleanTrue */.bI)(this.pv.useCopyExpr)) {
        this.stampNode().setGlobalIndex(i);
      }
      const stamptedInstanceCoreGroup = yield this._stampInstanceGroupIfRequired(instanceCoreGroup);
      if (stamptedInstanceCoreGroup) {
        const srcCoreObjects = (0,Mask/* filterCoreObjectsFromCoreGroup */.bK)(stamptedInstanceCoreGroup, {
          group: this.pv.srcGroup
        });
        for (const coreObject of srcCoreObjects) {
          const clonedObject = coreObject.clone().object();
          if (clonedObject) {
            this._applyAccumulatedTransform(clonedObject);
            this._objects.push(clonedObject);
          }
        }
      }
    });
  }
  // TODO: what if I combine both param_count and stamping?!
  cookWithoutTemplate(instanceCoreGroup) {
    return __async(this, null, function* () {
      this._objects = [];
      yield this._copyMovedObjectsForEachInstance(instanceCoreGroup);
      this.setObjects(this._objects);
    });
  }
  _copyAttributesGromTemplate(object, templatePoint) {
    this._attribNamesToCopy.forEach((attribName, i) => {
      const attribValue = templatePoint.attribValue(attribName);
      BaseCoreObject/* BaseCoreObject.addAttribute */.q.addAttribute(object, attribName, attribValue);
    });
  }
  //
  //
  // STAMP
  //
  //
  stampValue(attribName) {
    return this.stampNode().value(attribName);
  }
  stampNode() {
    return this._stampNode = this._stampNode || this._createStampNode();
  }
  _createStampNode() {
    const stampNode = new SopCopyStamp(this.scene());
    stampNode.setForbiddenTriggerNodes(this);
    return stampNode;
  }
  dispose() {
    super.dispose();
    if (this._stampNode) {
      this._stampNode.dispose();
    }
  }
  _initAccumulatedTransform() {
    const pv = this.pv;
    this._transformMatrix = this._coreTransform.matrix(pv.t, pv.r, pv.s, pv.scale, Transform/* RotationOrder.XYZ */.tM.XYZ);
    this._transformAccumulatedMatrix.identity();
  }
  _accumulateTransform() {
    this._transformAccumulatedMatrix.multiply(this._transformMatrix);
  }
  _applyMatrixToObject(object, matrix) {
    (0,CoreObjectFactory/* coreObjectClassFactory */.Xr)(object).applyMatrix(
      object,
      matrix,
      Transform/* TRANSFORM_TARGET_TYPES */.Pr[this.pv.transformMode],
      TransformSpace/* OBJECT_TRANSFORM_SPACES */.LD[this.pv.objectTransformSpace],
      TransformSpace/* ObjectTransformMode.MULT */.XT.MULT
    );
  }
  _applyAccumulatedTransform(object) {
    this._applyMatrixToObject(object, this._transformAccumulatedMatrix);
  }
  //
  //
  // MATRIX OPERATIONS
  //
  //
  // private _applyMatrixToObjectOrGeometry(object: ObjectContent<CoreObjectType>, matrix: Matrix4) {
  // 	const transformMode = TRANSFORM_MODES[this.pv.transformMode];
  // 	switch (transformMode) {
  // 		case TransformMode.OBJECT: {
  // 			this._applyMatrixToObject(object, matrix);
  // 			return;
  // 		}
  // 		case TransformMode.GEOMETRY: {
  // 			const geometry = (object as Object3DWithGeometry).geometry;
  // 			if (geometry) {
  // 				geometry.applyMatrix4(matrix);
  // 			}
  // 			return;
  // 		}
  // 	}
  // 	TypeAssert.unreachable(transformMode);
  // }
  // private _object_position = new Vector3();
  // private _applyMatrixToObject(object: ObjectContent<CoreObjectType>, matrix: Matrix4) {
  // 	applyTransformWithSpaceToObject(object, matrix, OBJECT_TRANSFORM_SPACES[this.pv.objectTransformSpace]);
  // }
}


/***/ }),

/***/ 71716:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "L": function() { return /* binding */ CubeCameraSopNode; }
/* harmony export */ });
/* harmony import */ var _Base__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(55839);
/* harmony import */ var _operations_sop_CubeCamera__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(90872);
/* harmony import */ var _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(96949);
/* harmony import */ var _poly_NodeContext__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(52070);
/* harmony import */ var _core_camera_CoreCubeCamera__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(45678);






const DEFAULT = _operations_sop_CubeCamera__WEBPACK_IMPORTED_MODULE_0__/* .CubeCameraSopOperation.DEFAULT_PARAMS */ .A.DEFAULT_PARAMS;
class CubeCameraSopParamsConfig extends _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .NodeParamsConfig */ .yI {
  constructor() {
    super(...arguments);
    /** @param camera near */
    this.near = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .ParamConfig.FLOAT */ .XC.FLOAT(DEFAULT.near, {
      range: [0, 100],
      rangeLocked: [true, false]
    });
    /** @param camera far */
    this.far = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .ParamConfig.FLOAT */ .XC.FLOAT(DEFAULT.far, {
      range: [0, 100],
      rangeLocked: [true, false]
    });
    /** @param resolution */
    this.resolution = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .ParamConfig.FLOAT */ .XC.FLOAT(_core_camera_CoreCubeCamera__WEBPACK_IMPORTED_MODULE_2__/* .CUBE_CAMERA_DEFAULT.resolution */ .X6.resolution, { range: _core_camera_CoreCubeCamera__WEBPACK_IMPORTED_MODULE_2__/* .CUBE_CAMERA_DEFAULT.resolutionRange */ .X6.resolutionRange });
    /** @param camera position */
    this.position = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .ParamConfig.VECTOR3 */ .XC.VECTOR3(DEFAULT.position);
    /** @param camera rotation */
    this.rotation = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .ParamConfig.VECTOR3 */ .XC.VECTOR3(DEFAULT.rotation);
    /** @param show helper */
    this.showHelper = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .ParamConfig.BOOLEAN */ .XC.BOOLEAN(DEFAULT.showHelper);
    /** @param matrixAutoUpdate */
    this.matrixAutoUpdate = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .ParamConfig.BOOLEAN */ .XC.BOOLEAN(DEFAULT.matrixAutoUpdate);
    /** @param camera name */
    this.name = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .ParamConfig.STRING */ .XC.STRING("`$OS`");
  }
}
const ParamsConfig = new CubeCameraSopParamsConfig();
class CubeCameraSopNode extends _Base__WEBPACK_IMPORTED_MODULE_3__/* .TypedSopNode */ .x {
  constructor() {
    super(...arguments);
    this.paramsConfig = ParamsConfig;
  }
  static type() {
    return _poly_NodeContext__WEBPACK_IMPORTED_MODULE_4__/* .CameraNodeType.CUBE */ .hY.CUBE;
  }
  initializeNode() {
    this.io.inputs.setCount(0);
  }
  cook(inputCoreGroups) {
    this._operation = this._operation || new _operations_sop_CubeCamera__WEBPACK_IMPORTED_MODULE_0__/* .CubeCameraSopOperation */ .A(this._scene, this.states, this);
    const coreGroup = this._operation.cook(inputCoreGroups, this.pv);
    this.setCoreGroup(coreGroup);
  }
}
CubeCameraSopNode.onRegister = _core_camera_CoreCubeCamera__WEBPACK_IMPORTED_MODULE_2__/* .registerCubeCamera */ .mv;


/***/ }),

/***/ 14063:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "_": function() { return /* binding */ DeleteByNameSopNode; }
/* harmony export */ });
/* harmony import */ var _Base__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(55839);
/* harmony import */ var _operations_sop_DeleteByName__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(80922);
/* harmony import */ var _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(96949);
/* harmony import */ var _poly_registers_nodes_types_Sop__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(58986);





const DEFAULT = _operations_sop_DeleteByName__WEBPACK_IMPORTED_MODULE_0__/* .DeleteByNameSopOperation.DEFAULT_PARAMS */ .M.DEFAULT_PARAMS;
class DeleteByNameSopParamConfig extends _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .NodeParamsConfig */ .yI {
  constructor() {
    super(...arguments);
    /** @param group to assign the material to */
    this.group = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .ParamConfig.STRING */ .XC.STRING(DEFAULT.group, {
      objectMask: true
    });
    /** @param invert */
    this.invert = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .ParamConfig.BOOLEAN */ .XC.BOOLEAN(DEFAULT.invert);
  }
}
const ParamsConfig = new DeleteByNameSopParamConfig();
class DeleteByNameSopNode extends _Base__WEBPACK_IMPORTED_MODULE_2__/* .TypedSopNode */ .x {
  constructor() {
    super(...arguments);
    this.paramsConfig = ParamsConfig;
  }
  static type() {
    return _poly_registers_nodes_types_Sop__WEBPACK_IMPORTED_MODULE_3__/* .SopType.DELETE_BY_NAME */ .aB.DELETE_BY_NAME;
  }
  initializeNode() {
    this.io.inputs.setCount(1);
    this.io.inputs.initInputsClonedState(_operations_sop_DeleteByName__WEBPACK_IMPORTED_MODULE_0__/* .DeleteByNameSopOperation.INPUT_CLONED_STATE */ .M.INPUT_CLONED_STATE);
  }
  cook(inputCoreGroups) {
    this._operation = this._operation || new _operations_sop_DeleteByName__WEBPACK_IMPORTED_MODULE_0__/* .DeleteByNameSopOperation */ .M(this.scene(), this.states, this);
    const coreGroup = this._operation.cook(inputCoreGroups, this.pv);
    this.setCoreGroup(coreGroup);
  }
}


/***/ }),

/***/ 57649:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "p": function() { return /* binding */ EmptyObjectSopNode; }
/* harmony export */ });
/* harmony import */ var _Base__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(55839);
/* harmony import */ var _operations_sop_EmptyObject__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(4778);
/* harmony import */ var _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(96949);
/* harmony import */ var _core_geometry_Constant__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(91568);





const OBJECT_TYPES = [
  _core_geometry_Constant__WEBPACK_IMPORTED_MODULE_0__/* .ObjectType.OBJECT3D */ .LP.OBJECT3D,
  _core_geometry_Constant__WEBPACK_IMPORTED_MODULE_0__/* .ObjectType.GROUP */ .LP.GROUP,
  _core_geometry_Constant__WEBPACK_IMPORTED_MODULE_0__/* .ObjectType.MESH */ .LP.MESH,
  _core_geometry_Constant__WEBPACK_IMPORTED_MODULE_0__/* .ObjectType.POINTS */ .LP.POINTS,
  _core_geometry_Constant__WEBPACK_IMPORTED_MODULE_0__/* .ObjectType.LINE_SEGMENTS */ .LP.LINE_SEGMENTS
];
class EmptyObjectSopParamsConfig extends _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .NodeParamsConfig */ .yI {
  constructor() {
    super(...arguments);
    this.type = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .ParamConfig.STRING */ .XC.STRING(_core_geometry_Constant__WEBPACK_IMPORTED_MODULE_0__/* .ObjectType.GROUP */ .LP.GROUP, {
      menuString: {
        entries: OBJECT_TYPES.map((name, value) => ({ name, value: name }))
      }
    });
  }
}
const ParamsConfig = new EmptyObjectSopParamsConfig();
class EmptyObjectSopNode extends _Base__WEBPACK_IMPORTED_MODULE_2__/* .TypedSopNode */ .x {
  constructor() {
    super(...arguments);
    this.paramsConfig = ParamsConfig;
  }
  static type() {
    return "emptyObject";
  }
  initializeNode() {
    this.io.inputs.setCount(0);
  }
  cook(input_contents) {
    this._operation = this._operation || new _operations_sop_EmptyObject__WEBPACK_IMPORTED_MODULE_3__/* .EmptyObjectSopOperation */ .i(this._scene, this.states, this);
    const type = this.pv.type;
    const coreGroup = this._operation.cook(input_contents, { type });
    this.setCoreGroup(coreGroup);
  }
  setObjectType(objectType) {
    this.p.type.set(objectType);
  }
  objectType() {
    const included = OBJECT_TYPES.includes(this.pv.type);
    return included ? this.pv.type : void 0;
  }
}


/***/ }),

/***/ 57966:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {


// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  "L": function() { return /* binding */ EntityBuilderSopNode; }
});

// EXTERNAL MODULE: ../@polygonjs/polygonjs/node_modules/three/build/three.module.js
var three_module = __webpack_require__(21410);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/poly/registers/nodes/types/Sop.ts
var Sop = __webpack_require__(58986);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/nodes/utils/BasePersistedConfig.ts
var BasePersistedConfig = __webpack_require__(14802);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/nodes/js/code/utils/JsParamConfig.ts
var JsParamConfig = __webpack_require__(35833);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/nodes/js/code/assemblers/_BaseJsPersistedConfig.ts
var _BaseJsPersistedConfig = __webpack_require__(35446);
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/js/code/assemblers/entityBuilder/_BaseEntityBuilderPersistedConfig.ts

var __async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};



class BaseEntityBuilderPersistedConfig extends BasePersistedConfig/* BasePersistedConfig */.p {
  constructor(node) {
    super(node);
    this.node = node;
  }
  toData() {
    return __async(this, null, function* () {
      yield this.node.compile();
      const assemblerController = this.node.assemblerController();
      if (!assemblerController) {
        return;
      }
      const functionData = this.node.functionData();
      if (!functionData) {
        return;
      }
      const { functionBody, variableNames, functionNames, paramConfigs, attributesData } = functionData;
      const data = {
        functionBody,
        variableNames,
        variables: (0,_BaseJsPersistedConfig/* serializedVariablesFromFunctionData */.ve)(functionData),
        functionNames,
        serializedParamConfigs: paramConfigs.map((p) => p.toJSON()),
        attributesData
      };
      return data;
    });
  }
  load(data) {
    const assemblerController = this.node.assemblerController();
    if (assemblerController) {
      return;
    }
    const { functionBody, variableNames, functionNames, serializedParamConfigs, attributesData } = data;
    const functionData = {
      functionBody,
      variableNames,
      variablesByName: (0,_BaseJsPersistedConfig/* variablesByNameFromPersistedConfigData */.pw)(data),
      functionNames,
      functionsByName: (0,_BaseJsPersistedConfig/* functionsByNameFromPersistedConfigData */.Kg)(data, this.node),
      paramConfigs: serializedParamConfigs.map((json) => JsParamConfig/* JsParamConfig.fromJSON */.M.fromJSON(json)),
      attributesData
    };
    this.node.updateFromFunctionData(functionData);
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/js/code/assemblers/entityBuilder/EntityBuilderPersistedConfig.ts


class EntityBuilderPersistedConfig extends BaseEntityBuilderPersistedConfig {
  constructor(node) {
    super(node);
    this.node = node;
  }
}

// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/poly/registers/assemblers/_BaseRegister.ts
var _BaseRegister = __webpack_require__(33899);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/nodes/sop/_Base.ts
var _Base = __webpack_require__(55839);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/poly/InputCloneMode.ts
var InputCloneMode = __webpack_require__(56752);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/nodes/utils/params/ParamsConfig.ts
var ParamsConfig = __webpack_require__(96949);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/nodes/js/code/assemblers/entityBuilder/EntityBuilderAssemblerCommon.ts
var EntityBuilderAssemblerCommon = __webpack_require__(13082);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/Poly.ts + 21 modules
var Poly = __webpack_require__(99934);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/poly/NodeContext.ts
var NodeContext = __webpack_require__(52070);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/nodes/js/code/assemblers/_BaseJsPersistedConfigUtils.ts
var _BaseJsPersistedConfigUtils = __webpack_require__(99463);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/nodes/js/code/utils/NodeFinder.ts
var NodeFinder = __webpack_require__(72648);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/core/Type.ts
var Type = __webpack_require__(19037);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/nodes/utils/io/connections/Js.ts
var Js = __webpack_require__(38857);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/core/geometry/entities/primitive/CorePrimitiveUtils.ts
var CorePrimitiveUtils = __webpack_require__(73416);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/core/geometry/CoreObjectFactory.ts
var CoreObjectFactory = __webpack_require__(17353);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/core/geometry/Mask.ts
var Mask = __webpack_require__(58290);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/core/geometry/Constant.ts
var Constant = __webpack_require__(91568);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/core/geometry/entities/point/CorePointUtils.ts
var CorePointUtils = __webpack_require__(50253);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/core/geometry/entities/vertex/CoreVertexUtils.ts
var CoreVertexUtils = __webpack_require__(99341);
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/sop/_BaseEntityBuilder.ts

var _BaseEntityBuilder_async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};


















const AVAILABLE_ENTITIES = [Constant/* AttribClass.POINT */.io.POINT, Constant/* AttribClass.VERTEX */.io.VERTEX, Constant/* AttribClass.PRIMITIVE */.io.PRIMITIVE];
class BaseEntityBuilderSopParamsConfig extends ParamsConfig/* NodeParamsConfig */.yI {
  constructor() {
    super(...arguments);
    /** @param group to assign the material to */
    this.group = ParamsConfig/* ParamConfig.STRING */.XC.STRING("", {
      objectMask: true
    });
    this.entity = ParamsConfig/* ParamConfig.INTEGER */.XC.INTEGER(AVAILABLE_ENTITIES.indexOf(Constant/* AttribClass.POINT */.io.POINT), {
      menu: {
        entries: AVAILABLE_ENTITIES.map((entity, i) => {
          return { name: entity, value: i };
        })
      }
    });
  }
}
class BaseEntityBuilderSopNode extends _Base/* TypedSopNode */.x {
  constructor() {
    super(...arguments);
    this._assemblerController = this._createAssemblerController();
    this._childrenControllerContext = NodeContext/* NodeContext.JS */.sy.JS;
    this._paramConfigs = [];
    this._functionCreationArgs = [];
    this._functionEvalArgs = [];
    this._attributesDict = /* @__PURE__ */ new Map();
  }
  assemblerController() {
    return this._assemblerController;
  }
  usedAssembler() {
    return _BaseRegister/* AssemblerName.JS_ENTITY_BUILDER */.Q.JS_ENTITY_BUILDER;
  }
  _createAssemblerController() {
    return Poly/* Poly.assemblersRegister.assembler */.L.assemblersRegister.assembler(this, this.usedAssembler());
  }
  createNode(node_class, options) {
    return super.createNode(node_class, options);
  }
  children() {
    return super.children();
  }
  nodesByType(type) {
    return super.nodesByType(type);
  }
  childrenAllowed() {
    if (this.assemblerController()) {
      return super.childrenAllowed();
    }
    return false;
  }
  sceneReadonly() {
    return this.assemblerController() == null;
  }
  initializeNode() {
    this.io.inputs.setCount(1);
    this.io.inputs.initInputsClonedState(InputCloneMode/* InputCloneMode.FROM_NODE */.m.FROM_NODE);
  }
  cook(inputCoreGroups) {
    return _BaseEntityBuilder_async(this, null, function* () {
      const coreGroup = inputCoreGroups[0];
      this.compileIfRequired();
      const _func = this._function;
      if (_func) {
        const args = this.functionEvalArgsWithParamConfigs();
        const evaluator = _func(...args);
        const objects = (0,Mask/* filterObjectsFromCoreGroup */.sH)(coreGroup, this.pv);
        let objnum = 0;
        for (const object of objects) {
          this._processObject(object, objnum, evaluator);
          objnum++;
        }
        this.setObjects(objects);
      } else {
        this.setObjects([]);
      }
    });
  }
  _resetRequiredAttributes() {
    this._attributesDict.clear();
  }
  _checkRequiredReadAttributes(object) {
    var _a;
    const entitiesCount = this.entitiesCount(object);
    if (entitiesCount == 0) {
      return;
    }
    const entityClass = this.entityClass(object);
    const readAttributesData = (_a = this._functionData) == null ? void 0 : _a.attributesData.read;
    if (!readAttributesData) {
      return;
    }
    for (const attribData of readAttributesData) {
      const attribute = entityClass.attribute(object, attribData.attribName);
      if (!attribute) {
        const message = `attribute ${attribData.attribName} is missing`;
        this.states.error.set(message);
        throw message;
        return;
      } else {
        const expectedAttribSize = Js/* JsConnectionPointComponentsCountMap */.N5[attribData.attribType];
        if (attribute.itemSize != expectedAttribSize) {
          this.states.error.set("attribute size mismatch");
        }
      }
    }
    const attribNames = [];
    const attributeByName = /* @__PURE__ */ new Map();
    const attribTypeByName = /* @__PURE__ */ new Map();
    for (const attribData of readAttributesData) {
      const attribName = attribData.attribName;
      const attribute = entityClass.attribute(object, attribName);
      if (attribute) {
        attribNames.push(attribName);
        attributeByName.set(attribName, attribute);
        attribTypeByName.set(attribName, attribData.attribType);
      }
    }
    return { attribNames, attributeByName, attribTypeByName };
  }
  _checkRequiredWriteAttributes(object) {
    var _a;
    const writeAttributesData = (_a = this._functionData) == null ? void 0 : _a.attributesData.write;
    if (!writeAttributesData) {
      return;
    }
    const entityClass = this.entityClass(object);
    for (const attribData of writeAttributesData) {
      let attribute = entityClass.attribute(object, attribData.attribName);
      const expectedAttribSize = Js/* JsConnectionPointComponentsCountMap */.N5[attribData.attribType];
      if (!attribute) {
        const pointsCount = entityClass.entitiesCount(object);
        const newArray = new Array(pointsCount * expectedAttribSize).fill(0);
        attribute = this._createAttribute(object, attribData.attribName, newArray, expectedAttribSize);
      }
      if (attribute.itemSize != expectedAttribSize) {
        this.states.error.set("attribute size mismatch");
      }
    }
    const attribNames = [];
    const attributeByName = /* @__PURE__ */ new Map();
    const attribTypeByName = /* @__PURE__ */ new Map();
    for (const attribData of writeAttributesData) {
      const attribName = attribData.attribName;
      const attribute = entityClass.attribute(object, attribName);
      if (attribute) {
        attribNames.push(attribName);
        attributeByName.set(attribName, attribute);
        attribTypeByName.set(attribName, attribData.attribType);
      }
    }
    return { attribNames, attributeByName, attribTypeByName };
  }
  _readRequiredAttributes(index, attribNames, attributeByName, attribTypeByName) {
    for (const attribName of attribNames) {
      const attribute = attributeByName.get(attribName);
      const attribType = attribTypeByName.get(attribName);
      const variable = (0,_BaseJsPersistedConfigUtils/* createVariable */.Os)(attribType);
      if (!variable) {
        const attribValue = attribute.array[index * attribute.itemSize];
        this._attributesDict.set(attribName, attribValue);
      } else if ((0,Type/* isVector */.NR)(variable) || (0,Type/* isColor */.D5)(variable)) {
        variable.fromBufferAttribute(attribute, index);
        this._attributesDict.set(attribName, variable);
      }
    }
  }
  _writeRequiredAttributes(index, attribNames, attributeByName) {
    for (const attribName of attribNames) {
      const attribute = attributeByName.get(attribName);
      const variable = this._attributesDict.get(attribName);
      if ((0,Type/* isVector */.NR)(variable) || (0,Type/* isColor */.D5)(variable)) {
        variable.toArray(attribute.array, index * attribute.itemSize);
      } else {
        if ((0,Type/* isNumber */.hj)(variable)) {
          attribute.array[index] = variable;
        }
      }
    }
  }
  compileIfRequired() {
    var _a;
    if ((_a = this.assemblerController()) == null ? void 0 : _a.compileRequired()) {
      this.compile();
    }
  }
  functionData() {
    return this._functionData;
  }
  compile() {
    const assemblerController = this.assemblerController();
    if (!assemblerController) {
      return;
    }
    const outputNodes = NodeFinder/* JsNodeFinder.findOutputNodes */.K.findOutputNodes(this);
    if (outputNodes.length > 1) {
      this.states.error.set("only one output node allowed");
      return;
    }
    const paramNodes = NodeFinder/* JsNodeFinder.findParamGeneratingNodes */.K.findParamGeneratingNodes(this);
    const attributeExportNodes = NodeFinder/* JsNodeFinder.findAttributeExportNodes */.K.findAttributeExportNodes(this);
    const rootNodes = outputNodes.concat(paramNodes).concat(attributeExportNodes);
    if (rootNodes.length == 0) {
      this.states.error.set("at least one output, param or attribute node is required");
      return;
    }
    assemblerController.assembler.set_root_nodes(rootNodes);
    assemblerController.assembler.updateFunction();
    const functionData = assemblerController.assembler.functionData();
    if (!functionData) {
      this.states.error.set("failed to compile ");
      return;
    }
    this.updateFromFunctionData(functionData);
    assemblerController.post_compile();
  }
  updateFromFunctionData(functionData) {
    this._functionData = functionData;
    const { functionBody, variableNames, variablesByName, functionNames, functionsByName, paramConfigs } = this._functionData;
    const wrappedBody = `
		try {
			${functionBody}
		} catch(e) {
			_setErrorFromError(e)
			return 0;
		}`;
    const _setErrorFromError = (e) => {
      this.states.error.set(e.message);
    };
    const variables = [];
    const functions = [];
    for (const variableName of variableNames) {
      const variable = variablesByName[variableName];
      variables.push(variable);
    }
    for (const functionName of functionNames) {
      const _func = functionsByName[functionName];
      functions.push(_func);
    }
    this._paramConfigs = [...paramConfigs];
    const paramConfigNames = paramConfigs.map((pc) => pc.uniformName());
    paramConfigs.forEach((p) => p.applyToNode(this));
    this._functionCreationArgs = [
      EntityBuilderAssemblerCommon/* EntityBuilderAssemblerConstant.ENTITY_CONTAINER */.k.ENTITY_CONTAINER,
      "_setErrorFromError",
      ...variableNames,
      ...functionNames,
      EntityBuilderAssemblerCommon/* EntityBuilderAssemblerConstant.ATTRIBUTES_DICT */.k.ATTRIBUTES_DICT,
      ...paramConfigNames,
      wrappedBody
    ];
    this._functionEvalArgs = [
      this._entityContainer,
      _setErrorFromError,
      ...variables,
      ...functions,
      this._attributesDict
      // paramConfigs are added dynamically during cook
    ];
    try {
      this._function = new Function(...this._functionCreationArgs);
    } catch (e) {
      console.warn(e);
      this.states.error.set("failed to compile");
    }
  }
  functionEvalArgsWithParamConfigs() {
    const list = [
      ...this._functionEvalArgs
    ];
    for (const paramConfig of this._paramConfigs) {
      const paramName = paramConfig.name();
      const spareParam = this.params.get(paramName);
      if (spareParam && spareParam.value != null) {
        if (Type/* CoreType.isBoolean */.MR.isBoolean(spareParam.value) || Type/* CoreType.isNumberValid */.MR.isNumberValid(spareParam.value) || Type/* CoreType.isColor */.MR.isColor(spareParam.value) || Type/* CoreType.isVector */.MR.isVector(spareParam.value)) {
          list.push(spareParam.value);
        } else {
          console.warn(`spareParam not found but type not yet copied to function args:'${paramName}'`);
        }
      } else {
        console.warn(`spareParam not found:'${paramName}'`);
      }
    }
    return list;
  }
  setEntity(attribClass) {
    this.p.entity.set(AVAILABLE_ENTITIES.indexOf(attribClass));
  }
  entity() {
    return AVAILABLE_ENTITIES[this.pv.entity];
  }
  entitiesCount(object) {
    const entity = this.entity();
    switch (entity) {
      case Constant/* AttribClass.POINT */.io.POINT: {
        return (0,CorePointUtils/* pointsCountFromObject */.En)(object);
      }
      case Constant/* AttribClass.VERTEX */.io.VERTEX: {
        return (0,CoreVertexUtils/* verticesCountFromObject */.D1)(object);
      }
      case Constant/* AttribClass.PRIMITIVE */.io.PRIMITIVE: {
        return (0,CorePrimitiveUtils/* primitivesCountFromObject */.KL)(object);
      }
    }
  }
  entityClass(object) {
    const entity = this.entity();
    switch (entity) {
      case Constant/* AttribClass.POINT */.io.POINT: {
        return (0,CoreObjectFactory/* corePointClassFactory */.E_)(object);
      }
      case Constant/* AttribClass.VERTEX */.io.VERTEX: {
        return (0,CoreObjectFactory/* coreVertexClassFactory */.PF)(object);
      }
      case Constant/* AttribClass.PRIMITIVE */.io.PRIMITIVE: {
        return (0,CoreObjectFactory/* corePrimitiveClassFactory */.um)(object);
      }
    }
  }
  _createAttribute(object, attribName, values, attribSize) {
    const entity = this.entity();
    switch (entity) {
      case Constant/* AttribClass.POINT */.io.POINT: {
        const attribute = new three_module.BufferAttribute(new Float32Array(values), attribSize);
        (0,CoreObjectFactory/* corePointClassFactory */.E_)(object).addAttribute(object, attribName, attribute);
        return attribute;
      }
      case Constant/* AttribClass.VERTEX */.io.VERTEX: {
        const attribute = {
          isString: false,
          itemSize: attribSize,
          array: values
        };
        (0,CoreObjectFactory/* coreVertexClassFactory */.PF)(object).addAttribute(object, attribName, attribute);
        return attribute;
      }
      case Constant/* AttribClass.PRIMITIVE */.io.PRIMITIVE: {
        const attribute = {
          isString: false,
          itemSize: attribSize,
          array: values
        };
        (0,CoreObjectFactory/* corePrimitiveClassFactory */.um)(object).addAttribute(object, attribName, attribute);
        return attribute;
      }
    }
  }
}

// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/core/geometry/Attribute.ts
var Attribute = __webpack_require__(32558);
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/sop/EntityBuilder.ts











const _tmpObject = new three_module.Object3D();
class EntityBuilderSopParamsConfig extends BaseEntityBuilderSopParamsConfig {
  constructor() {
    super(...arguments);
    /** @param updateNormals */
    this.updateNormals = ParamsConfig/* ParamConfig.BOOLEAN */.XC.BOOLEAN(1, {
      visibleIf: {
        entity: AVAILABLE_ENTITIES.indexOf(Constant/* AttribClass.POINT */.io.POINT)
      }
    });
  }
}
const EntityBuilder_ParamsConfig = new EntityBuilderSopParamsConfig();
class EntityBuilderSopNode extends BaseEntityBuilderSopNode {
  constructor() {
    super(...arguments);
    this.paramsConfig = EntityBuilder_ParamsConfig;
    this.persisted_config = new EntityBuilderPersistedConfig(this);
    this._entityContainer = {
      object: _tmpObject,
      position: new three_module.Vector3(),
      normal: new three_module.Vector3(),
      index: -1,
      objnum: -1,
      normalsUpdated: false
    };
  }
  static type() {
    return Sop/* SopType.ENTITY_BUILDER */.aB.ENTITY_BUILDER;
  }
  usedAssembler() {
    return _BaseRegister/* AssemblerName.JS_ENTITY_BUILDER */.Q.JS_ENTITY_BUILDER;
  }
  _processObject(object, objnum, evaluator) {
    this._entityContainer.object = object;
    this._entityContainer.objnum = objnum;
    this._entityContainer.normalsUpdated = false;
    if (this.entity() == Constant/* AttribClass.PRIMITIVE */.io.PRIMITIVE) {
      this._entityContainer.primitiveGraph = (0,CoreObjectFactory/* corePrimitiveClassFactory */.um)(object).graph(object);
    } else {
      this._entityContainer.primitiveGraph = void 0;
    }
    const readAttributeOptions = this._checkRequiredReadAttributes(object);
    const writeAttributeOptions = this._checkRequiredWriteAttributes(object);
    const readAttribNames = readAttributeOptions ? readAttributeOptions.attribNames : [];
    const readAttributeByName = readAttributeOptions ? readAttributeOptions.attributeByName : /* @__PURE__ */ new Map();
    const attribTypeByName = readAttributeOptions ? readAttributeOptions.attribTypeByName : /* @__PURE__ */ new Map();
    const writeAttribNames = writeAttributeOptions ? writeAttributeOptions.attribNames : [];
    const writeAttributeByName = writeAttributeOptions ? writeAttributeOptions.attributeByName : /* @__PURE__ */ new Map();
    this._resetRequiredAttributes();
    const entitiesCount = this.entitiesCount(object);
    const entityClass = this.entityClass(object);
    const positionAttrib = entityClass.attribute(object, Attribute/* Attribute.POSITION */.ah.POSITION);
    const normalAttrib = entityClass.attribute(object, Attribute/* Attribute.NORMAL */.ah.NORMAL);
    const hasPosition = positionAttrib != null;
    const hasNormal = normalAttrib != null;
    if (!hasPosition) {
      this._entityContainer.position.set(0, 0, 0);
    }
    if (!hasNormal) {
      this._entityContainer.normal.set(0, 1, 0);
    }
    for (let index = 0; index < entitiesCount; index++) {
      this._entityContainer.index = index;
      if (hasPosition) {
        entityClass.attribValue(object, index, Attribute/* Attribute.POSITION */.ah.POSITION, this._entityContainer.position);
      }
      if (hasNormal) {
        entityClass.attribValue(object, index, Attribute/* Attribute.NORMAL */.ah.NORMAL, this._entityContainer.normal);
      }
      this._readRequiredAttributes(index, readAttribNames, readAttributeByName, attribTypeByName);
      evaluator();
      this._writeRequiredAttributes(index, writeAttribNames, writeAttributeByName);
    }
    if ((0,Type/* isBooleanTrue */.bI)(this.pv.updateNormals) && !this._entityContainer.normalsUpdated) {
      (0,CoreObjectFactory/* corePointClassFactory */.E_)(object).computeNormals(object);
    }
  }
}


/***/ }),

/***/ 12071:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "b": function() { return /* binding */ FacetSopNode; }
/* harmony export */ });
/* harmony import */ var _Base__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(55839);
/* harmony import */ var _poly_InputCloneMode__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(56752);
/* harmony import */ var _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(96949);
/* harmony import */ var three_examples_jsm_utils_BufferGeometryUtils__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(80993);
/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(21410);
/* harmony import */ var _core_geometry_Mask__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(58290);
/* harmony import */ var _core_geometry_GeometryUtils__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(31170);
/* harmony import */ var _poly_registers_nodes_types_Sop__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(58986);
/* harmony import */ var _core_geometry_util_IndexBuilder__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(44321);
/* harmony import */ var _core_geometry_CoreObjectFactory__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(17353);











const { degToRad } = three__WEBPACK_IMPORTED_MODULE_0__.MathUtils;
class FacetSopParamsConfig extends _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .NodeParamsConfig */ .yI {
  constructor() {
    super(...arguments);
    /** @param group to assign the material to */
    this.group = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .ParamConfig.STRING */ .XC.STRING("", {
      objectMask: true
    });
    /** @param angle threshold to separate vertices */
    this.angle = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .ParamConfig.FLOAT */ .XC.FLOAT(20, {
      range: [0, 90],
      rangeLocked: [true, false]
    });
  }
}
const ParamsConfig = new FacetSopParamsConfig();
class FacetSopNode extends _Base__WEBPACK_IMPORTED_MODULE_2__/* .TypedSopNode */ .x {
  constructor() {
    super(...arguments);
    this.paramsConfig = ParamsConfig;
  }
  static type() {
    return _poly_registers_nodes_types_Sop__WEBPACK_IMPORTED_MODULE_3__/* .SopType.FACET */ .aB.FACET;
  }
  initializeNode() {
    this.io.inputs.setCount(1);
    this.io.inputs.initInputsClonedState(_poly_InputCloneMode__WEBPACK_IMPORTED_MODULE_4__/* .InputCloneMode.FROM_NODE */ .m.FROM_NODE);
  }
  cook(inputCoreGroups) {
    const inputCoreGroup = inputCoreGroups[0];
    const selectedObjects = _core_geometry_Mask__WEBPACK_IMPORTED_MODULE_5__/* .CoreMask.filterThreejsObjects */ .x0.filterThreejsObjects(inputCoreGroup, this.pv).filter(_core_geometry_GeometryUtils__WEBPACK_IMPORTED_MODULE_6__/* .object3DHasGeometry */ .I_);
    const rad = degToRad(this.pv.angle);
    for (const object of selectedObjects) {
      const primitiveAttributes = (0,_core_geometry_CoreObjectFactory__WEBPACK_IMPORTED_MODULE_7__/* .corePrimitiveClassFactory */ .um)(object).attributes(object);
      object.geometry = (0,three_examples_jsm_utils_BufferGeometryUtils__WEBPACK_IMPORTED_MODULE_8__/* .toCreasedNormals */ .LZ)(object.geometry, rad);
      _core_geometry_util_IndexBuilder__WEBPACK_IMPORTED_MODULE_9__/* .CoreGeometryIndexBuilder.createIndexIfNone */ .f.createIndexIfNone(object.geometry);
      if (primitiveAttributes) {
        const primitiveAttributeNames = Object.keys(primitiveAttributes);
        for (const attribName of primitiveAttributeNames) {
          const attrib = primitiveAttributes[attribName];
          (0,_core_geometry_CoreObjectFactory__WEBPACK_IMPORTED_MODULE_7__/* .corePrimitiveClassFactory */ .um)(object).addAttribute(object, attribName, attrib);
        }
      }
    }
    this.setCoreGroup(inputCoreGroup);
  }
}


/***/ }),

/***/ 61999:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "$": function() { return /* binding */ FileMultiOBJSopNode; }
/* harmony export */ });
/* harmony import */ var _utils_file_BaseSopFileMulti__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(51992);
/* harmony import */ var _poly_registers_nodes_types_Sop__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(58986);
/* harmony import */ var _core_loader_geometry_OBJ__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(39569);
/* harmony import */ var _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(96949);
/* harmony import */ var _core_loader_AssetsUtils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(29248);
/* harmony import */ var _core_loader_FileExtensionRegister__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(15060);
/* harmony import */ var _poly_NodeContext__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(52070);








class FileMultiOBJParamsConfig extends _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_0__/* .NodeParamsConfig */ .yI {
  constructor() {
    super(...arguments);
    /** @param url to load the geometry from */
    this.url = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_0__/* .ParamConfig.STRING */ .XC.STRING(`${_core_loader_AssetsUtils__WEBPACK_IMPORTED_MODULE_1__/* .ASSETS_ROOT */ .V}/models/\`@name\`.obj`, {
      fileBrowse: { extensions: _core_loader_FileExtensionRegister__WEBPACK_IMPORTED_MODULE_2__/* .EXTENSIONS_BY_NODE_TYPE_BY_CONTEXT */ .P[_poly_NodeContext__WEBPACK_IMPORTED_MODULE_3__/* .NodeContext.SOP */ .sy.SOP][_poly_registers_nodes_types_Sop__WEBPACK_IMPORTED_MODULE_4__/* .SopTypeFileMulti.FILE_OBJ */ .dk.FILE_OBJ] },
      expression: { forEntities: true }
    });
    /** @param sets the matrixAutoUpdate attribute for the objects loaded */
    this.matrixAutoUpdate = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_0__/* .ParamConfig.BOOLEAN */ .XC.BOOLEAN(false);
    /** @param reload the geometry */
    this.reload = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_0__/* .ParamConfig.BUTTON */ .XC.BUTTON(null, {
      callback: (node) => {
        _utils_file_BaseSopFileMulti__WEBPACK_IMPORTED_MODULE_5__/* .BaseFileMultiSopNode.PARAM_CALLBACK_reload */ .AE.PARAM_CALLBACK_reload(node);
      }
    });
  }
}
const ParamsConfig = new FileMultiOBJParamsConfig();
class FileMultiOBJSopNode extends _utils_file_BaseSopFileMulti__WEBPACK_IMPORTED_MODULE_5__/* .BaseFileMultiSopNode */ .AE {
  constructor() {
    super(...arguments);
    this.paramsConfig = ParamsConfig;
  }
  static type() {
    return _poly_registers_nodes_types_Sop__WEBPACK_IMPORTED_MODULE_4__/* .SopTypeFileMulti.FILE_OBJ */ .dk.FILE_OBJ;
  }
  _createLoader(url) {
    return new _core_loader_geometry_OBJ__WEBPACK_IMPORTED_MODULE_6__/* .OBJLoaderHandler */ .M(url, this);
  }
}


/***/ }),

/***/ 47617:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "M": function() { return /* binding */ FileVOXSopNode; }
/* harmony export */ });
/* harmony import */ var _operations_sop_FileVOX__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(26144);
/* harmony import */ var _utils_file_BaseSopFile__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(84179);
/* harmony import */ var _poly_registers_nodes_types_Sop__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(58986);
/* harmony import */ var _core_loader_FileExtensionRegister__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(15060);
/* harmony import */ var _poly_NodeContext__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(52070);






class FileVOXSopNode extends (0,_utils_file_BaseSopFile__WEBPACK_IMPORTED_MODULE_0__/* .fileSopNodeFactory */ .pd)({
  type: _poly_registers_nodes_types_Sop__WEBPACK_IMPORTED_MODULE_1__/* .SopTypeFile.FILE_VOX */ .GF.FILE_VOX,
  operation: _operations_sop_FileVOX__WEBPACK_IMPORTED_MODULE_2__/* .FileVOXSopOperation */ .O,
  extensions: _core_loader_FileExtensionRegister__WEBPACK_IMPORTED_MODULE_3__/* .EXTENSIONS_BY_NODE_TYPE_BY_CONTEXT */ .P[_poly_NodeContext__WEBPACK_IMPORTED_MODULE_4__/* .NodeContext.SOP */ .sy.SOP][_poly_registers_nodes_types_Sop__WEBPACK_IMPORTED_MODULE_1__/* .SopTypeFile.FILE_VOX */ .GF.FILE_VOX]
}) {
}


/***/ }),

/***/ 19210:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "m": function() { return /* binding */ FuseSopNode; }
/* harmony export */ });
/* harmony import */ var _Base__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(55839);
/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(21410);
/* harmony import */ var _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(96949);
/* harmony import */ var _poly_InputCloneMode__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(56752);
/* harmony import */ var _core_MapUtils__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(94158);
/* harmony import */ var _core_geometry_Constant__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(91568);
/* harmony import */ var _core_ArrayUtils__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(87132);
/* harmony import */ var _core_geometry_operation_Fuse__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(90651);
/* harmony import */ var _core_geometry_Mask__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(58290);
/* harmony import */ var _poly_registers_nodes_types_Sop__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(58986);











const roundedPosition = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();
const vector2 = new three__WEBPACK_IMPORTED_MODULE_0__.Vector2();
const vector3 = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();
const vector4 = new three__WEBPACK_IMPORTED_MODULE_0__.Vector4();
function clearAttributes(geometry) {
  const attributeNames = Object.keys(geometry.attributes);
  for (const attributeName of attributeNames) {
    const attribute = geometry.getAttribute(attributeName);
    if (attribute instanceof three__WEBPACK_IMPORTED_MODULE_0__.BufferAttribute) {
      const newAttribValues = [];
      geometry.setAttribute(
        attributeName,
        new three__WEBPACK_IMPORTED_MODULE_0__.BufferAttribute(new Float32Array(newAttribValues), attribute.itemSize)
      );
    }
  }
}
class FuseSopParamsConfig extends _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .NodeParamsConfig */ .yI {
  constructor() {
    super(...arguments);
    /** @param group to assign the material to */
    this.group = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .ParamConfig.STRING */ .XC.STRING("", {
      objectMask: true
    });
    /** @param distance threshold */
    this.dist = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .ParamConfig.FLOAT */ .XC.FLOAT(1e-3, {
      range: [0, 1],
      rangeLocked: [true, false],
      step: 1e-3
    });
    /** @param recompute normals */
    this.computeNormals = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .ParamConfig.BOOLEAN */ .XC.BOOLEAN(1);
  }
}
const ParamsConfig = new FuseSopParamsConfig();
class FuseSopNode extends _Base__WEBPACK_IMPORTED_MODULE_2__/* .TypedSopNode */ .x {
  constructor() {
    super(...arguments);
    this.paramsConfig = ParamsConfig;
  }
  static type() {
    return _poly_registers_nodes_types_Sop__WEBPACK_IMPORTED_MODULE_3__/* .SopType.FUSE */ .aB.FUSE;
  }
  initializeNode() {
    this.io.inputs.setCount(1);
    this.io.inputs.initInputsClonedState(_poly_InputCloneMode__WEBPACK_IMPORTED_MODULE_4__/* .InputCloneMode.FROM_NODE */ .m.FROM_NODE);
  }
  cook(inputCoreGroups) {
    const inputCoreGroup = inputCoreGroups[0];
    const selectedObjects = _core_geometry_Mask__WEBPACK_IMPORTED_MODULE_5__/* .CoreMask.filterThreejsObjects */ .x0.filterThreejsObjects(inputCoreGroup, this.pv);
    for (const object of selectedObjects) {
      this._filterObject(object);
    }
    this.setCoreGroup(inputCoreGroup);
  }
  _filterObject(object) {
    const objectType = (0,_core_geometry_Constant__WEBPACK_IMPORTED_MODULE_6__/* .objectTypeFromObject */ .c9)(object);
    switch (objectType) {
      case _core_geometry_Constant__WEBPACK_IMPORTED_MODULE_6__/* .ObjectType.MESH */ .LP.MESH: {
        return this._filterMesh(object);
      }
      case _core_geometry_Constant__WEBPACK_IMPORTED_MODULE_6__/* .ObjectType.LINE_SEGMENTS */ .LP.LINE_SEGMENTS: {
        this._fuseGeometry(object.geometry);
        return this._filterLineSegments(object);
      }
      case _core_geometry_Constant__WEBPACK_IMPORTED_MODULE_6__/* .ObjectType.POINTS */ .LP.POINTS: {
        this._fuseGeometry(object.geometry);
        return this._filterPoints(object);
      }
    }
  }
  _filterMesh(object) {
    const geometry = object.geometry;
    const index = geometry.getIndex();
    if (!index) {
      return;
    }
    (0,_core_geometry_operation_Fuse__WEBPACK_IMPORTED_MODULE_7__/* .mergeFaces */ .X)(geometry, this.pv.dist);
  }
  _filterLineSegments(object) {
    const geometry = object.geometry;
    const index = geometry.getIndex();
    if (!index) {
      return;
    }
    const newIndices = [];
    const indexArray = index.array;
    const segmentsCount = indexArray.length / 2;
    for (let i = 0; i < segmentsCount; i++) {
      vector2.fromArray(indexArray, i * 2);
      const a = vector2.x;
      const b = vector2.y;
      const segmentSnapped = a == b;
      if (!segmentSnapped) {
        vector2.toArray(newIndices, newIndices.length);
      }
    }
    geometry.setIndex(newIndices);
    if (newIndices.length == 0) {
      clearAttributes(geometry);
    }
  }
  _filterPoints(object) {
    const geometry = object.geometry;
    const index = geometry.getIndex();
    if (!index) {
      return;
    }
    const indexArray = [...index.array];
    const newIndices = [];
    (0,_core_ArrayUtils__WEBPACK_IMPORTED_MODULE_8__/* .arrayUniq */ .tt)(indexArray, newIndices);
    newIndices.sort((a, b) => a - b);
    geometry.setIndex(newIndices);
    if (newIndices.length == 0) {
      clearAttributes(geometry);
    }
  }
  _fuseGeometry(geometry) {
    const index = geometry.getIndex();
    if (!index) {
      return;
    }
    const indexArray = index.array;
    const precision = this.pv.dist;
    const position = geometry.getAttribute("position");
    const pointsCount = position.array.length / 3;
    function roundedPos(index2, target) {
      target.fromBufferAttribute(position, index2);
      if (precision > 0) {
        target.x = Math.round(target.x / precision) * precision;
        target.y = Math.round(target.y / precision) * precision;
        target.z = Math.round(target.z / precision) * precision;
      }
    }
    const indicesByPosKey = /* @__PURE__ */ new Map();
    const posKeyByIndex = /* @__PURE__ */ new Map();
    for (let index2 = 0; index2 < pointsCount; index2++) {
      roundedPos(index2, roundedPosition);
      const posKey = `${roundedPosition.x},${roundedPosition.y},${roundedPosition.z}`;
      _core_MapUtils__WEBPACK_IMPORTED_MODULE_9__/* .MapUtils.pushOnArrayAtEntry */ .pl.pushOnArrayAtEntry(indicesByPosKey, posKey, index2);
      posKeyByIndex.set(index2, posKey);
    }
    indicesByPosKey.forEach((indices, posKey) => {
      indices.sort((a, b) => a - b);
    });
    const newIndicesAfterGapsCreated = /* @__PURE__ */ new Map();
    let nextAvailableIndex = 0;
    for (let index2 = 0; index2 < pointsCount; index2++) {
      const posKey = posKeyByIndex.get(index2);
      const indices = indicesByPosKey.get(posKey);
      if (indices.length <= 1 || indices[0] == index2) {
        newIndicesAfterGapsCreated.set(index2, nextAvailableIndex);
        nextAvailableIndex++;
      }
    }
    const newIndexByOldIndex = /* @__PURE__ */ new Map();
    indicesByPosKey.forEach((indices, posKey) => {
      const firstIndex = indices[0];
      for (let i = 1; i < indices.length; i++) {
        const index2 = indices[i];
        newIndexByOldIndex.set(index2, firstIndex);
      }
    });
    const newIndices = [];
    const newIndexByOldIndexAfterAssignment = /* @__PURE__ */ new Map();
    for (let i = 0; i < indexArray.length; i++) {
      const index2 = indexArray[i];
      const targetIndex = newIndexByOldIndex.get(index2);
      const targetOffset = targetIndex != null ? newIndicesAfterGapsCreated.get(targetIndex) : newIndicesAfterGapsCreated.get(index2);
      let newIndex = index2;
      if (targetOffset != null) {
        newIndex = targetOffset;
      } else {
        if (targetIndex != null) {
          newIndex = targetIndex;
        }
      }
      newIndices.push(newIndex);
      newIndexByOldIndexAfterAssignment.set(index2, newIndex);
    }
    const attributeNames = Object.keys(geometry.attributes);
    for (const attributeName of attributeNames) {
      const attribute = geometry.getAttribute(attributeName);
      if (attribute instanceof three__WEBPACK_IMPORTED_MODULE_0__.BufferAttribute) {
        let getVector2 = function() {
          if (itemSize == 2) {
            return vector2;
          }
          if (itemSize == 3) {
            return vector3;
          }
          if (itemSize == 4) {
            return vector4;
          }
        };
        var getVector = getVector2;
        const itemSize = attribute.itemSize;
        const newAttribValues = [];
        const vector = getVector2();
        for (let i = 0; i < pointsCount; i++) {
          let index2 = newIndexByOldIndexAfterAssignment.get(i);
          if (index2 == null) {
            index2 = i;
          }
          if (vector) {
            vector.fromBufferAttribute(attribute, i);
            vector.toArray(newAttribValues, index2 * itemSize);
          } else {
            const currentVal = attribute.array[i];
            newAttribValues[index2] = currentVal;
          }
        }
        geometry.setAttribute(attributeName, new three__WEBPACK_IMPORTED_MODULE_0__.BufferAttribute(new Float32Array(newAttribValues), itemSize));
      }
    }
    geometry.setIndex(newIndices);
  }
}


/***/ }),

/***/ 83545:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "A": function() { return /* binding */ HemisphereLightSopNode; }
/* harmony export */ });
/* harmony import */ var _Base__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(55839);
/* harmony import */ var _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(96949);
/* harmony import */ var _core_lights_HemisphereLight__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(98821);
/* harmony import */ var _operations_sop_HemisphereLight__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(57426);





class HemisphereLightSopParamsConfig extends (0,_core_lights_HemisphereLight__WEBPACK_IMPORTED_MODULE_0__/* .HemisphereLightParamConfig */ .A)(_utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .NodeParamsConfig */ .yI) {
}
const ParamsConfig = new HemisphereLightSopParamsConfig();
class HemisphereLightSopNode extends _Base__WEBPACK_IMPORTED_MODULE_2__/* .TypedSopNode */ .x {
  constructor() {
    super(...arguments);
    this.paramsConfig = ParamsConfig;
  }
  static type() {
    return "hemisphereLight";
  }
  initializeNode() {
    this.io.inputs.setCount(0);
  }
  cook(inputCoreGroups) {
    this._operation = this._operation || new _operations_sop_HemisphereLight__WEBPACK_IMPORTED_MODULE_3__/* .HemisphereLightSopOperation */ .c(this._scene, this.states, this);
    const coreGroup = this._operation.cook(inputCoreGroups, this.pv);
    this.setCoreGroup(coreGroup);
  }
}


/***/ }),

/***/ 10288:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "o": function() { return /* binding */ HexagonsSopNode; }
/* harmony export */ });
/* harmony import */ var _Base__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(55839);
/* harmony import */ var _operations_sop_Hexagons__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(42821);
/* harmony import */ var _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(96949);




const DEFAULT = _operations_sop_Hexagons__WEBPACK_IMPORTED_MODULE_0__/* .HexagonsSopOperation.DEFAULT_PARAMS */ .b.DEFAULT_PARAMS;
class HexagonsSopParamsConfig extends _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .NodeParamsConfig */ .yI {
  constructor() {
    super(...arguments);
    /** @param plane size */
    this.size = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .ParamConfig.VECTOR2 */ .XC.VECTOR2(DEFAULT.size);
    /** @param hexagons size */
    this.hexagonRadius = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .ParamConfig.FLOAT */ .XC.FLOAT(DEFAULT.hexagonRadius, {
      range: [1e-3, 1],
      rangeLocked: [false, false]
    });
    /** @param axis perpendicular to the plane */
    this.direction = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .ParamConfig.VECTOR3 */ .XC.VECTOR3(DEFAULT.direction);
    /** @param do not create polygons, only points */
    this.pointsOnly = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .ParamConfig.BOOLEAN */ .XC.BOOLEAN(DEFAULT.pointsOnly);
  }
  // no need to have centers, as all points are centers anyway
  //this.add_param( ParamType.TOGGLE, 'centers_only', 0, {visibleIf: {pointsOnly: 1}})
}
const ParamsConfig = new HexagonsSopParamsConfig();
class HexagonsSopNode extends _Base__WEBPACK_IMPORTED_MODULE_2__/* .TypedSopNode */ .x {
  constructor() {
    super(...arguments);
    this.paramsConfig = ParamsConfig;
  }
  static type() {
    return "hexagons";
  }
  initializeNode() {
    this.io.inputs.setCount(0, 1);
    this.io.inputs.initInputsClonedState(_operations_sop_Hexagons__WEBPACK_IMPORTED_MODULE_0__/* .HexagonsSopOperation.INPUT_CLONED_STATE */ .b.INPUT_CLONED_STATE);
  }
  cook(input_contents) {
    this._operation = this._operation || new _operations_sop_Hexagons__WEBPACK_IMPORTED_MODULE_0__/* .HexagonsSopOperation */ .b(this.scene(), this.states, this);
    const core_group = this._operation.cook(input_contents, this.pv);
    this.setCoreGroup(core_group);
  }
}


/***/ }),

/***/ 79463:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "z": function() { return /* binding */ HierarchySopNode; }
/* harmony export */ });
/* unused harmony export MODES_WITH_LEVEL */
/* harmony import */ var _Base__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(55839);
/* harmony import */ var _operations_sop_Hierarchy__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(25972);
/* harmony import */ var _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(96949);
/* harmony import */ var _poly_registers_nodes_types_Sop__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(58986);



const MODES_WITH_LEVEL = [_operations_sop_Hierarchy__WEBPACK_IMPORTED_MODULE_0__/* .HierarchyMode.ADD_PARENT */ .P1.ADD_PARENT, _operations_sop_Hierarchy__WEBPACK_IMPORTED_MODULE_0__/* .HierarchyMode.REMOVE_PARENT */ .P1.REMOVE_PARENT];


const DEFAULT = _operations_sop_Hierarchy__WEBPACK_IMPORTED_MODULE_0__/* .HierarchySopOperation.DEFAULT_PARAMS */ .JW.DEFAULT_PARAMS;
class HierarchySopParamsConfig extends _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .NodeParamsConfig */ .yI {
  constructor() {
    super(...arguments);
    /** @param defines if parent objects will be added or removed */
    this.mode = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .ParamConfig.INTEGER */ .XC.INTEGER(DEFAULT.mode, {
      menu: {
        entries: _operations_sop_Hierarchy__WEBPACK_IMPORTED_MODULE_0__/* .HIERARCHY_MODES.map */ .kO.map((m, i) => {
          return { name: m, value: i };
        })
      }
    });
    /** @param defines how many parent objects will be added or removed */
    this.levels = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .ParamConfig.INTEGER */ .XC.INTEGER(DEFAULT.levels, {
      range: [0, 5],
      visibleIf: [
        { mode: _operations_sop_Hierarchy__WEBPACK_IMPORTED_MODULE_0__/* .HIERARCHY_MODES.indexOf */ .kO.indexOf(_operations_sop_Hierarchy__WEBPACK_IMPORTED_MODULE_0__/* .HierarchyMode.ADD_PARENT */ .P1.ADD_PARENT) },
        { mode: _operations_sop_Hierarchy__WEBPACK_IMPORTED_MODULE_0__/* .HIERARCHY_MODES.indexOf */ .kO.indexOf(_operations_sop_Hierarchy__WEBPACK_IMPORTED_MODULE_0__/* .HierarchyMode.REMOVE_PARENT */ .P1.REMOVE_PARENT) }
      ]
    });
    /** @param when the mode is set to add_child, the mask defines which parent the children are added to. If the mask is an empty string, the children will be added to the objects at the top of the hierarchy. Also, the children are taken from the second input. */
    this.objectMask = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .ParamConfig.STRING */ .XC.STRING("", {
      visibleIf: { mode: _operations_sop_Hierarchy__WEBPACK_IMPORTED_MODULE_0__/* .HIERARCHY_MODES.indexOf */ .kO.indexOf(_operations_sop_Hierarchy__WEBPACK_IMPORTED_MODULE_0__/* .HierarchyMode.ADD_CHILD */ .P1.ADD_CHILD) },
      objectMask: true
    });
    /** @param defines how the children are added to the parents */
    this.addChildMode = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .ParamConfig.INTEGER */ .XC.INTEGER(DEFAULT.addChildMode, {
      visibleIf: { mode: _operations_sop_Hierarchy__WEBPACK_IMPORTED_MODULE_0__/* .HIERARCHY_MODES.indexOf */ .kO.indexOf(_operations_sop_Hierarchy__WEBPACK_IMPORTED_MODULE_0__/* .HierarchyMode.ADD_CHILD */ .P1.ADD_CHILD) },
      menu: {
        entries: _operations_sop_Hierarchy__WEBPACK_IMPORTED_MODULE_0__/* .ADD_CHILD_MODES.map */ .Bw.map((m, i) => {
          return { name: m, value: i };
        })
      }
    });
  }
}
const ParamsConfig = new HierarchySopParamsConfig();
class HierarchySopNode extends _Base__WEBPACK_IMPORTED_MODULE_2__/* .TypedSopNode */ .x {
  constructor() {
    super(...arguments);
    this.paramsConfig = ParamsConfig;
  }
  static type() {
    return _poly_registers_nodes_types_Sop__WEBPACK_IMPORTED_MODULE_3__/* .SopType.HIERARCHY */ .aB.HIERARCHY;
  }
  initializeNode() {
    this.io.inputs.setCount(1, 2);
    this.io.inputs.initInputsClonedState(_operations_sop_Hierarchy__WEBPACK_IMPORTED_MODULE_0__/* .HierarchySopOperation.INPUT_CLONED_STATE */ .JW.INPUT_CLONED_STATE);
  }
  cook(inputCoreGroups) {
    this._operation = this._operation || new _operations_sop_Hierarchy__WEBPACK_IMPORTED_MODULE_0__/* .HierarchySopOperation */ .JW(this._scene, this.states, this);
    const coreGroup = this._operation.cook(inputCoreGroups, this.pv);
    this.setCoreGroup(coreGroup);
  }
  setMode(mode) {
    this.p.mode.set(_operations_sop_Hierarchy__WEBPACK_IMPORTED_MODULE_0__/* .HIERARCHY_MODES.indexOf */ .kO.indexOf(mode));
  }
  setAddChildMode(mode) {
    this.p.addChildMode.set(_operations_sop_Hierarchy__WEBPACK_IMPORTED_MODULE_0__/* .ADD_CHILD_MODES.indexOf */ .Bw.indexOf(mode));
  }
}


/***/ }),

/***/ 82263:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "K": function() { return /* binding */ IcosahedronSopNode; }
/* harmony export */ });
/* harmony import */ var _Base__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(55839);
/* harmony import */ var _operations_sop_Icosahedron__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(40930);
/* harmony import */ var _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(96949);
/* harmony import */ var _poly_registers_nodes_types_Sop__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(58986);





const DEFAULT = _operations_sop_Icosahedron__WEBPACK_IMPORTED_MODULE_0__/* .IcosahedronSopOperation.DEFAULT_PARAMS */ .g.DEFAULT_PARAMS;
class IcosahedronSopParamsConfig extends _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .NodeParamsConfig */ .yI {
  constructor() {
    super(...arguments);
    /** @param radius of the icosahedron */
    this.radius = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .ParamConfig.FLOAT */ .XC.FLOAT(DEFAULT.radius);
    /** @param resolution of the icosahedron */
    this.detail = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .ParamConfig.INTEGER */ .XC.INTEGER(DEFAULT.detail, {
      range: [0, 32],
      rangeLocked: [true, false]
    });
    /** @param do not create polygons, only points. */
    this.pointsOnly = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .ParamConfig.BOOLEAN */ .XC.BOOLEAN(DEFAULT.pointsOnly);
    /** @param center of the icosahedron */
    this.center = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .ParamConfig.VECTOR3 */ .XC.VECTOR3(DEFAULT.center);
  }
}
const ParamsConfig = new IcosahedronSopParamsConfig();
class IcosahedronSopNode extends _Base__WEBPACK_IMPORTED_MODULE_2__/* .TypedSopNode */ .x {
  constructor() {
    super(...arguments);
    this.paramsConfig = ParamsConfig;
  }
  static type() {
    return _poly_registers_nodes_types_Sop__WEBPACK_IMPORTED_MODULE_3__/* .SopType.ICOSAHEDRON */ .aB.ICOSAHEDRON;
  }
  cook() {
    this._operation = this._operation || new _operations_sop_Icosahedron__WEBPACK_IMPORTED_MODULE_0__/* .IcosahedronSopOperation */ .g(this._scene, this.states, this);
    const core_group = this._operation.cook([], this.pv);
    this.setCoreGroup(core_group);
  }
}


/***/ }),

/***/ 15432:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "K": function() { return /* binding */ InstanceSopNode; }
/* harmony export */ });
/* harmony import */ var _Base__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(55839);
/* harmony import */ var _poly_NodeContext__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(52070);
/* harmony import */ var _operations_sop_Instance__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(51922);
/* harmony import */ var _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(96949);
/* harmony import */ var _poly_registers_nodes_types_Sop__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(58986);

var __async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};





const DEFAULT = _operations_sop_Instance__WEBPACK_IMPORTED_MODULE_0__/* .InstanceSopOperation.DEFAULT_PARAMS */ .m.DEFAULT_PARAMS;
class InstanceSopParamsConfig extends _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .NodeParamsConfig */ .yI {
  constructor() {
    super(...arguments);
    /** @param attributes to copy to the instance */
    this.attributesToCopy = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .ParamConfig.STRING */ .XC.STRING(DEFAULT.attributesToCopy);
    /** @param toggles on to apply a material. This is useful in most cases, but there may be situations where the material would be apply later, such as when you are feeding this node to a particles system */
    this.applyMaterial = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .ParamConfig.BOOLEAN */ .XC.BOOLEAN(DEFAULT.applyMaterial);
    /** @param material to apply */
    this.material = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .ParamConfig.NODE_PATH */ .XC.NODE_PATH("", {
      visibleIf: { applyMaterial: 1 },
      nodeSelection: {
        context: _poly_NodeContext__WEBPACK_IMPORTED_MODULE_2__/* .NodeContext.MAT */ .sy.MAT
      },
      dependentOnFoundNode: false
    });
  }
}
const ParamsConfig = new InstanceSopParamsConfig();
class InstanceSopNode extends _Base__WEBPACK_IMPORTED_MODULE_3__/* .TypedSopNode */ .x {
  constructor() {
    super(...arguments);
    this.paramsConfig = ParamsConfig;
  }
  static type() {
    return _poly_registers_nodes_types_Sop__WEBPACK_IMPORTED_MODULE_4__/* .SopType.INSTANCE */ .aB.INSTANCE;
  }
  initializeNode() {
    super.initializeNode();
    this.io.inputs.setCount(2);
    this.io.inputs.initInputsClonedState(_operations_sop_Instance__WEBPACK_IMPORTED_MODULE_0__/* .InstanceSopOperation.INPUT_CLONED_STATE */ .m.INPUT_CLONED_STATE);
  }
  cook(inputCoreGroups) {
    return __async(this, null, function* () {
      this._operation = this._operation || new _operations_sop_Instance__WEBPACK_IMPORTED_MODULE_0__/* .InstanceSopOperation */ .m(this.scene(), this.states, this);
      const coreGroup = yield this._operation.cook(inputCoreGroups, this.pv);
      this.setCoreGroup(coreGroup);
    });
  }
}


/***/ }),

/***/ 28310:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "o": function() { return /* binding */ JitterSopNode; }
/* harmony export */ });
/* harmony import */ var _Base__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(55839);
/* harmony import */ var _operations_sop_Jitter__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(28665);
/* harmony import */ var _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(96949);
/* harmony import */ var _poly_registers_nodes_types_Sop__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(58986);





const DEFAULT = _operations_sop_Jitter__WEBPACK_IMPORTED_MODULE_0__/* .JitterSopOperation.DEFAULT_PARAMS */ .U.DEFAULT_PARAMS;
class JitterSopParamsConfig extends _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .NodeParamsConfig */ .yI {
  constructor() {
    super(...arguments);
    /** @param amount of jitter */
    this.amount = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .ParamConfig.FLOAT */ .XC.FLOAT(DEFAULT.amount);
    /** @param mult of each axis */
    this.mult = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .ParamConfig.VECTOR3 */ .XC.VECTOR3(DEFAULT.mult);
    /** @param seed used to set the direction each point is moved to */
    this.seed = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .ParamConfig.INTEGER */ .XC.INTEGER(DEFAULT.seed, { range: [0, 100] });
  }
}
const ParamsConfig = new JitterSopParamsConfig();
class JitterSopNode extends _Base__WEBPACK_IMPORTED_MODULE_2__/* .TypedSopNode */ .x {
  constructor() {
    super(...arguments);
    this.paramsConfig = ParamsConfig;
  }
  static type() {
    return _poly_registers_nodes_types_Sop__WEBPACK_IMPORTED_MODULE_3__/* .SopType.JITTER */ .aB.JITTER;
  }
  initializeNode() {
    this.io.inputs.setCount(1);
    this.io.inputs.initInputsClonedState(_operations_sop_Jitter__WEBPACK_IMPORTED_MODULE_0__/* .JitterSopOperation.INPUT_CLONED_STATE */ .U.INPUT_CLONED_STATE);
  }
  cook(input_contents) {
    this._operation = this._operation || new _operations_sop_Jitter__WEBPACK_IMPORTED_MODULE_0__/* .JitterSopOperation */ .U(this.scene(), this.states, this);
    const core_group = this._operation.cook(input_contents, this.pv);
    this.setCoreGroup(core_group);
  }
}


/***/ }),

/***/ 11655:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "$3": function() { return /* binding */ LayerSopNode; },
/* harmony export */   "ls": function() { return /* binding */ UPDATE_MODES; }
/* harmony export */ });
/* unused harmony export LayerUpdateMode */
/* harmony import */ var _Base__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(55839);
/* harmony import */ var _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(96949);
/* harmony import */ var _poly_InputCloneMode__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(56752);
/* harmony import */ var _poly_registers_nodes_types_Sop__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(58986);
/* harmony import */ var _core_geometry_Mask__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(58290);

var __defProp = Object.defineProperty;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};





var LayerUpdateMode = /* @__PURE__ */ ((LayerUpdateMode2) => {
  LayerUpdateMode2["SET"] = "set";
  LayerUpdateMode2["ADD"] = "add";
  LayerUpdateMode2["REMOVE"] = "remove";
  return LayerUpdateMode2;
})(LayerUpdateMode || {});
const UPDATE_MODES = ["set" /* SET */, "add" /* ADD */, "remove" /* REMOVE */];
const UPDATE_MODE_ENTRIES = UPDATE_MODES.map((name, value) => {
  return { name, value };
});
function visibleOption(options) {
  const computedOptions = [];
  for (let i = 1; i <= 4; i++) {
    if (i >= options.layersCount) {
      computedOptions.push({ layersCount: i });
    }
  }
  return {
    visibleIf: computedOptions
  };
}
class LayerSopParamsConfig extends _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_0__/* .NodeParamsConfig */ .yI {
  constructor() {
    super(...arguments);
    /** @param group to assign the material to */
    this.group = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_0__/* .ParamConfig.STRING */ .XC.STRING("*", {
      objectMask: true
    });
    this.layersCount = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_0__/* .ParamConfig.INTEGER */ .XC.INTEGER(1, {
      range: [1, 4],
      rangeLocked: [true, true],
      separatorAfter: true
    });
    /** @param updateMode */
    this.updateMode0 = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_0__/* .ParamConfig.INTEGER */ .XC.INTEGER(UPDATE_MODES.indexOf("add" /* ADD */), __spreadValues({
      menu: {
        entries: UPDATE_MODE_ENTRIES
      }
    }, visibleOption({ layersCount: 1 })));
    /** @param layer */
    this.layer0 = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_0__/* .ParamConfig.INTEGER */ .XC.INTEGER(0, __spreadValues({
      range: [0, 31],
      rangeLocked: [true, true]
    }, visibleOption({ layersCount: 1 })));
    /** @param updateMode */
    this.updateMode1 = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_0__/* .ParamConfig.INTEGER */ .XC.INTEGER(UPDATE_MODES.indexOf("add" /* ADD */), __spreadValues({
      menu: {
        entries: UPDATE_MODE_ENTRIES
      }
    }, visibleOption({ layersCount: 2 })));
    /** @param layer */
    this.layer1 = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_0__/* .ParamConfig.INTEGER */ .XC.INTEGER(0, __spreadValues({
      range: [0, 31],
      rangeLocked: [true, true]
    }, visibleOption({ layersCount: 2 })));
    /** @param updateMode */
    this.updateMode2 = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_0__/* .ParamConfig.INTEGER */ .XC.INTEGER(UPDATE_MODES.indexOf("add" /* ADD */), __spreadValues({
      menu: {
        entries: UPDATE_MODE_ENTRIES
      }
    }, visibleOption({ layersCount: 3 })));
    /** @param layer */
    this.layer2 = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_0__/* .ParamConfig.INTEGER */ .XC.INTEGER(0, __spreadValues({
      range: [0, 31],
      rangeLocked: [true, true]
    }, visibleOption({ layersCount: 3 })));
    /** @param updateMode */
    this.updateMode3 = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_0__/* .ParamConfig.INTEGER */ .XC.INTEGER(UPDATE_MODES.indexOf("add" /* ADD */), __spreadValues({
      menu: {
        entries: UPDATE_MODE_ENTRIES
      }
    }, visibleOption({ layersCount: 4 })));
    /** @param layer */
    this.layer3 = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_0__/* .ParamConfig.INTEGER */ .XC.INTEGER(0, __spreadValues({
      range: [0, 31],
      rangeLocked: [true, true]
    }, visibleOption({ layersCount: 4 })));
  }
}
const ParamsConfig = new LayerSopParamsConfig();
class LayerSopNode extends _Base__WEBPACK_IMPORTED_MODULE_1__/* .TypedSopNode */ .x {
  constructor() {
    super(...arguments);
    this.paramsConfig = ParamsConfig;
  }
  static type() {
    return _poly_registers_nodes_types_Sop__WEBPACK_IMPORTED_MODULE_2__/* .SopType.LAYER */ .aB.LAYER;
  }
  initializeNode() {
    this.io.inputs.setCount(1);
    this.io.inputs.initInputsClonedState(_poly_InputCloneMode__WEBPACK_IMPORTED_MODULE_3__/* .InputCloneMode.FROM_NODE */ .m.FROM_NODE);
  }
  cook(inputCoreGroups) {
    const coreGroup = inputCoreGroups[0];
    const objects = (0,_core_geometry_Mask__WEBPACK_IMPORTED_MODULE_4__/* .filterThreejsObjectsWithGroup */ .pb)(coreGroup, this.pv);
    for (const object of objects) {
      this._updateLayers(object);
    }
    this.setCoreGroup(coreGroup);
  }
  _updateLayers(object) {
    this._updateLayer(0, object, UPDATE_MODES[this.pv.updateMode0], this.pv.layer0);
    this._updateLayer(1, object, UPDATE_MODES[this.pv.updateMode1], this.pv.layer1);
    this._updateLayer(2, object, UPDATE_MODES[this.pv.updateMode2], this.pv.layer2);
    this._updateLayer(3, object, UPDATE_MODES[this.pv.updateMode3], this.pv.layer3);
  }
  _updateLayer(index, object, updateMode, layer) {
    if (index > this.pv.layersCount - 1) {
      return;
    }
    switch (updateMode) {
      case "set" /* SET */: {
        object.layers.set(layer);
        return;
      }
      case "add" /* ADD */: {
        object.layers.enable(layer);
        return;
      }
      case "remove" /* REMOVE */: {
        object.layers.disable(layer);
        return;
      }
    }
  }
  //
  // helper methods
  //
  setMode(index, mode) {
    const param = [this.p.updateMode0, this.p.updateMode1, this.p.updateMode2, this.p.updateMode3];
    param[index].set(UPDATE_MODES.indexOf(mode));
  }
  setLayer(index, layer) {
    const param = [this.p.layer0, this.p.layer1, this.p.layer2, this.p.layer3];
    param[index].set(layer);
  }
}


/***/ }),

/***/ 2885:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "h": function() { return /* binding */ LightProbeSopNode; }
/* harmony export */ });
/* harmony import */ var _Base__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(55839);
/* harmony import */ var _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(96949);
/* harmony import */ var _core_lights_LightProbe__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(63771);
/* harmony import */ var _operations_sop_LightProbe__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(32409);

var __async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};




class LightProbeSopParamsConfig extends (0,_core_lights_LightProbe__WEBPACK_IMPORTED_MODULE_0__/* .LightProbeParamConfig */ .H)(_utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .NodeParamsConfig */ .yI) {
}
const ParamsConfig = new LightProbeSopParamsConfig();
class LightProbeSopNode extends _Base__WEBPACK_IMPORTED_MODULE_2__/* .TypedSopNode */ .x {
  constructor() {
    super(...arguments);
    this.paramsConfig = ParamsConfig;
  }
  static type() {
    return "lightProbe";
  }
  initializeNode() {
    this.io.inputs.setCount(0);
  }
  cook(inputCoreGroups) {
    return __async(this, null, function* () {
      this._operation = this._operation || new _operations_sop_LightProbe__WEBPACK_IMPORTED_MODULE_3__/* .LightProbeSopOperation */ .v(this._scene, this.states, this);
      const coreGroup = yield this._operation.cook(inputCoreGroups, this.pv);
      this.setCoreGroup(coreGroup);
    });
  }
}


/***/ }),

/***/ 87330:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "_": function() { return /* binding */ LineSopNode; }
/* harmony export */ });
/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(21410);
/* harmony import */ var _Base__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(55839);
/* harmony import */ var _core_geometry_Constant__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(91568);
/* harmony import */ var _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(96949);






class LineSopParamsConfig extends _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_0__/* .NodeParamsConfig */ .yI {
  constructor() {
    super(...arguments);
    /** @param length of the line */
    this.length = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_0__/* .ParamConfig.FLOAT */ .XC.FLOAT(1, { range: [0, 10] });
    /** @param number of points */
    this.pointsCount = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_0__/* .ParamConfig.INTEGER */ .XC.INTEGER(2, {
      range: [2, 100],
      rangeLocked: [true, false]
    });
    /** @param start position of the line */
    this.origin = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_0__/* .ParamConfig.VECTOR3 */ .XC.VECTOR3([0, 0, 0]);
    /** @param direction of the line */
    this.direction = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_0__/* .ParamConfig.VECTOR3 */ .XC.VECTOR3([0, 1, 0]);
  }
}
const ParamsConfig = new LineSopParamsConfig();
class LineSopNode extends _Base__WEBPACK_IMPORTED_MODULE_1__/* .TypedSopNode */ .x {
  constructor() {
    super(...arguments);
    this.paramsConfig = ParamsConfig;
    this._lastPt = new three__WEBPACK_IMPORTED_MODULE_2__.Vector3();
    this._current = new three__WEBPACK_IMPORTED_MODULE_2__.Vector3();
  }
  static type() {
    return "line";
  }
  initializeNode() {
  }
  cook() {
    const pointsCount = Math.max(2, this.pv.pointsCount);
    const positions = new Array(pointsCount * 3);
    const indices = new Array(pointsCount);
    this._lastPt.copy(this.pv.direction).normalize().multiplyScalar(this.pv.length);
    for (let i = 0; i < pointsCount; i++) {
      const i_n = i / (pointsCount - 1);
      this._current.copy(this._lastPt).multiplyScalar(i_n);
      this._current.add(this.pv.origin);
      this._current.toArray(positions, i * 3);
      if (i > 0) {
        indices[(i - 1) * 2] = i - 1;
        indices[(i - 1) * 2 + 1] = i;
      }
    }
    const geometry = new three__WEBPACK_IMPORTED_MODULE_2__.BufferGeometry();
    geometry.setAttribute("position", new three__WEBPACK_IMPORTED_MODULE_2__.Float32BufferAttribute(positions, 3));
    geometry.setIndex(indices);
    this.setGeometry(geometry, _core_geometry_Constant__WEBPACK_IMPORTED_MODULE_3__/* .ObjectType.LINE_SEGMENTS */ .LP.LINE_SEGMENTS);
  }
}


/***/ }),

/***/ 74874:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "z": function() { return /* binding */ MaterialSopNode; }
/* harmony export */ });
/* harmony import */ var _Base__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(55839);
/* harmony import */ var _poly_NodeContext__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(52070);
/* harmony import */ var _operations_sop_Material__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(53382);
/* harmony import */ var _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(96949);
/* harmony import */ var _poly_registers_nodes_types_Sop__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(58986);

var __async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};





const DEFAULT = _operations_sop_Material__WEBPACK_IMPORTED_MODULE_0__/* .MaterialSopOperation.DEFAULT_PARAMS */ .i.DEFAULT_PARAMS;
class MaterialSopParamsConfig extends _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .NodeParamsConfig */ .yI {
  constructor() {
    super(...arguments);
    /** @param group to assign the material to */
    this.group = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .ParamConfig.STRING */ .XC.STRING(DEFAULT.group, {
      objectMask: true
    });
    /** @param toggle on to assign the new material */
    this.assignMat = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .ParamConfig.BOOLEAN */ .XC.BOOLEAN(DEFAULT.assignMat);
    /** @param the material node */
    this.material = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .ParamConfig.NODE_PATH */ .XC.NODE_PATH("", {
      nodeSelection: {
        context: _poly_NodeContext__WEBPACK_IMPORTED_MODULE_2__/* .NodeContext.MAT */ .sy.MAT
      },
      dependentOnFoundNode: false,
      visibleIf: { assignMat: 1 }
    });
    // cloneMat is mostly useful when swapping tex for multiple objects which have different textures
    // but can also be used when requiring a unique material per object, when using a copy SOP
    /** @param Cloning the material would prevent the material node to have any effect on the processed geometries. But it would allow to have multiple materials, if this was used with a Copy SOP for instance */
    this.cloneMat = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .ParamConfig.BOOLEAN */ .XC.BOOLEAN(DEFAULT.cloneMat, {
      visibleIf: { assignMat: 1 },
      separatorBefore: true
    });
    /** @param while cloning the material, you may only want to change basic properties (such as depthWrite or transparent), but you would want to still use the same custom uniforms created by GL/param nodes */
    this.shareCustomUniforms = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .ParamConfig.BOOLEAN */ .XC.BOOLEAN(DEFAULT.shareCustomUniforms, { visibleIf: { assignMat: 1, cloneMat: 1 } });
    /** @param swap one texture with another */
    this.swapCurrentTex = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .ParamConfig.BOOLEAN */ .XC.BOOLEAN(DEFAULT.swapCurrentTex);
    /** @param texture to swap */
    this.texSrc0 = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .ParamConfig.STRING */ .XC.STRING(DEFAULT.texSrc0, { visibleIf: { swapCurrentTex: 1 } });
    /** @param texture to swap */
    this.texDest0 = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .ParamConfig.STRING */ .XC.STRING(DEFAULT.texDest0, { visibleIf: { swapCurrentTex: 1 } });
  }
}
const ParamsConfig = new MaterialSopParamsConfig();
class MaterialSopNode extends _Base__WEBPACK_IMPORTED_MODULE_3__/* .TypedSopNode */ .x {
  constructor() {
    super(...arguments);
    this.paramsConfig = ParamsConfig;
  }
  static type() {
    return _poly_registers_nodes_types_Sop__WEBPACK_IMPORTED_MODULE_4__/* .SopType.MATERIAL */ .aB.MATERIAL;
  }
  initializeNode() {
    this.io.inputs.setCount(1);
    this.io.inputs.initInputsClonedState(_operations_sop_Material__WEBPACK_IMPORTED_MODULE_0__/* .MaterialSopOperation.INPUT_CLONED_STATE */ .i.INPUT_CLONED_STATE);
  }
  cook(inputCoreGroups) {
    return __async(this, null, function* () {
      this._operation = this._operation || new _operations_sop_Material__WEBPACK_IMPORTED_MODULE_0__/* .MaterialSopOperation */ .i(this._scene, this.states, this);
      const coreGroup = yield this._operation.cook(inputCoreGroups, this.pv);
      this.setCoreGroup(coreGroup);
    });
  }
}


/***/ }),

/***/ 72613:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "r": function() { return /* binding */ NoiseSopNode; }
/* harmony export */ });
/* unused harmony export NoiseOperation */
/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(21410);
/* harmony import */ var _Base__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(55839);
/* harmony import */ var _core_geometry_Attribute__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(32558);
/* harmony import */ var _core_math_Module__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(27462);
/* harmony import */ var _poly_InputCloneMode__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(56752);
/* harmony import */ var _poly_Assert__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(68239);
/* harmony import */ var three_examples_jsm_math_SimplexNoise__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(27550);
/* harmony import */ var _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(96949);
/* harmony import */ var _core_Type__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(19037);
/* harmony import */ var _core_geometry_Constant__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(91568);
/* harmony import */ var _poly_registers_nodes_types_Sop__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(58986);













var NoiseOperation = /* @__PURE__ */ ((NoiseOperation2) => {
  NoiseOperation2["ADD"] = "add";
  NoiseOperation2["SET"] = "set";
  NoiseOperation2["MULT"] = "mult";
  NoiseOperation2["SUBTRACT"] = "subtract";
  NoiseOperation2["DIVIDE"] = "divide";
  return NoiseOperation2;
})(NoiseOperation || {});
const OPERATIONS = [
  "add" /* ADD */,
  "set" /* SET */,
  "mult" /* MULT */,
  "subtract" /* SUBTRACT */,
  "divide" /* DIVIDE */
];
const position = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();
const normal = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();
const _destPoints = [];
const _restPos = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();
const _restValue2 = new three__WEBPACK_IMPORTED_MODULE_0__.Vector2();
const _restValue4 = new three__WEBPACK_IMPORTED_MODULE_0__.Vector4();
const _noiseValueV = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();
let _currentAttribValueF = 0;
const _currentAttribValueV2 = new three__WEBPACK_IMPORTED_MODULE_0__.Vector2();
const _currentAttribValueV3 = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();
const _currentAttribValueV4 = new three__WEBPACK_IMPORTED_MODULE_0__.Vector4();
class NoiseSopParamsConfig extends _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .NodeParamsConfig */ .yI {
  constructor() {
    super(...arguments);
    /** @param noise amplitude */
    this.amplitude = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .ParamConfig.FLOAT */ .XC.FLOAT(1);
    /** @param toggle on to multiply the amplitude by a vertex attribute */
    this.tamplitudeAttrib = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .ParamConfig.BOOLEAN */ .XC.BOOLEAN(0);
    /** @param which vertex attribute to use */
    this.amplitudeAttrib = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .ParamConfig.STRING */ .XC.STRING("amp", { visibleIf: { tamplitudeAttrib: true } });
    /** @param noise frequency */
    this.freq = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .ParamConfig.VECTOR3 */ .XC.VECTOR3([1, 1, 1]);
    /** @param noise offset */
    this.offset = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .ParamConfig.VECTOR3 */ .XC.VECTOR3([0, 0, 0]);
    /** @param noise octaves */
    this.octaves = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .ParamConfig.INTEGER */ .XC.INTEGER(3, {
      range: [1, 8],
      rangeLocked: [true, false]
    });
    /** @param amplitude attenuation for higher octaves */
    this.ampAttenuation = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .ParamConfig.FLOAT */ .XC.FLOAT(0.5, { range: [0, 1] });
    /** @param frequency increase for higher octaves */
    this.freqIncrease = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .ParamConfig.FLOAT */ .XC.FLOAT(2, { range: [0, 10] });
    /** @param noise seed */
    this.seed = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .ParamConfig.INTEGER */ .XC.INTEGER(0, {
      range: [0, 100],
      separatorAfter: true
    });
    /** @param toggle on to have the noise be multiplied by the normal */
    this.useNormals = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .ParamConfig.BOOLEAN */ .XC.BOOLEAN(0);
    /** @param set which attribute will be affected by the noise */
    this.attribName = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .ParamConfig.STRING */ .XC.STRING("position");
    /** @param toggle on to use rest attributes. This can be useful when the noise is animated and this node does not clone the input geometry. Without using rest attributes, the noise would be based on an already modified position, and would therefore accumulate on itself after each cook. This may be what you are after, but for a more conventional result, using a rest attribute will ensure that the noise remains stable. Note that the rest attribute can be created by a RestAttributes node */
    this.useRestAttributes = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .ParamConfig.BOOLEAN */ .XC.BOOLEAN(0);
    /** @param name of rest position */
    this.restP = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .ParamConfig.STRING */ .XC.STRING("restP", { visibleIf: { useRestAttributes: true } });
    /** @param name of rest normal */
    this.restN = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .ParamConfig.STRING */ .XC.STRING("restN", { visibleIf: { useRestAttributes: true } });
    /** @param operation done when applying the noise (add, set, mult, subtract, divide) */
    this.operation = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .ParamConfig.INTEGER */ .XC.INTEGER(OPERATIONS.indexOf("add" /* ADD */), {
      menu: {
        entries: OPERATIONS.map((operation) => {
          return {
            name: operation,
            value: OPERATIONS.indexOf(operation)
          };
        })
      }
    });
    /** @param toggle on to recompute normals if the position has been updated */
    this.computeNormals = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .ParamConfig.BOOLEAN */ .XC.BOOLEAN(1);
  }
}
const ParamsConfig = new NoiseSopParamsConfig();
class NoiseSopNode extends _Base__WEBPACK_IMPORTED_MODULE_2__/* .TypedSopNode */ .x {
  constructor() {
    super(...arguments);
    this.paramsConfig = ParamsConfig;
    this._simplexBySeed = /* @__PURE__ */ new Map();
  }
  static type() {
    return _poly_registers_nodes_types_Sop__WEBPACK_IMPORTED_MODULE_3__/* .SopType.NOISE */ .aB.NOISE;
  }
  initializeNode() {
    this.io.inputs.setCount(1);
    this.io.inputs.initInputsClonedState([_poly_InputCloneMode__WEBPACK_IMPORTED_MODULE_4__/* .InputCloneMode.FROM_NODE */ .m.FROM_NODE]);
  }
  setOperation(operation) {
    this.p.operation.set(OPERATIONS.indexOf(operation));
  }
  cook(inputCoreGroups) {
    const coreGroup = inputCoreGroups[0];
    coreGroup.points(_destPoints);
    const destAttribName = this.pv.attribName;
    if (!coreGroup.hasPointAttrib(destAttribName)) {
      this.states.error.set(`attribute ${destAttribName} not found`);
      this.cookController.endCook();
      return;
    }
    const attribType = coreGroup.pointAttribType(destAttribName);
    if (attribType != _core_geometry_Constant__WEBPACK_IMPORTED_MODULE_5__/* .AttribType.NUMERIC */ .rp.NUMERIC) {
      this.states.error.set(`attribute ${destAttribName} is not a numeric attribute`);
      this.cookController.endCook();
      return;
    }
    const targetAttribSize = coreGroup.pointAttribSize(this.pv.attribName);
    const firstPt = _destPoints[0];
    if (!firstPt) {
      this.setCoreGroup(coreGroup);
      return;
    }
    const currentAttribValue = firstPt.attribValue(destAttribName);
    if (_core_Type__WEBPACK_IMPORTED_MODULE_6__/* .CoreType.isString */ .MR.isString(currentAttribValue)) {
      this.states.error.set("cannot add noise to a string attribute");
      return;
    }
    const fbmParams = {
      octaves: this.pv.octaves,
      ampAttenuation: this.pv.ampAttenuation,
      freqIncrease: this.pv.freqIncrease
    };
    try {
      switch (targetAttribSize) {
        case 1: {
          this._cookForFloat(_destPoints, fbmParams);
          break;
        }
        case 2: {
          this._cookForV2(_destPoints, fbmParams);
          break;
        }
        case 3: {
          this._cookForV3(_destPoints, fbmParams);
          break;
        }
        case 4: {
          this._cookForV4(_destPoints, fbmParams);
          break;
        }
      }
    } catch (err) {
      console.error("sop/noise error", err);
      this.states.error.set(`cook failed for (${this.path()}). make sure the required attributes are present`);
    }
    if (!this.io.inputs.cloneRequired(0)) {
      for (const geometry of coreGroup.geometries()) {
        geometry.getAttribute(destAttribName).needsUpdate = true;
      }
    }
    if ((0,_core_Type__WEBPACK_IMPORTED_MODULE_6__/* .isBooleanTrue */ .bI)(this.pv.computeNormals)) {
      const objects = coreGroup.threejsObjectsWithGeo();
      for (const object of objects) {
        object.geometry.computeVertexNormals();
      }
    }
    this.setCoreGroup(coreGroup);
  }
  _cookForFloat(destPoints, fbmParams) {
    const simplex = this._getSimplex();
    const useRestAttributes = (0,_core_Type__WEBPACK_IMPORTED_MODULE_6__/* .isBooleanTrue */ .bI)(this.pv.useRestAttributes);
    const useNormals = (0,_core_Type__WEBPACK_IMPORTED_MODULE_6__/* .isBooleanTrue */ .bI)(this.pv.useNormals);
    const tamplitudeAttrib = (0,_core_Type__WEBPACK_IMPORTED_MODULE_6__/* .isBooleanTrue */ .bI)(this.pv.tamplitudeAttrib);
    const baseAmplitude = this.pv.amplitude;
    const operation = OPERATIONS[this.pv.operation];
    const attribName = this.pv.attribName;
    for (const destPoint of destPoints) {
      if (useRestAttributes) {
        destPoint.attribValueVector3(this.pv.restP, position);
        if (useNormals) {
          destPoint.attribValueVector3(this.pv.restN, normal);
        }
        _currentAttribValueF = position.x;
      } else {
        destPoint.position(position);
        if (useNormals) {
          destPoint.attribValueVector3(_core_geometry_Attribute__WEBPACK_IMPORTED_MODULE_7__/* .Attribute.NORMAL */ .ah.NORMAL, normal);
        }
        _currentAttribValueF = destPoint.attribValueNumber(attribName);
      }
      const amplitude = tamplitudeAttrib ? this._amplitudeFromAttrib(destPoint, baseAmplitude) : baseAmplitude;
      const noiseResult = this._noiseValue(useNormals, simplex, amplitude, fbmParams, position, normal);
      const noiseValue = noiseResult.x;
      const newAttribValueF = NoiseSopNode._newAttribValueFromFloat(operation, _currentAttribValueF, noiseValue);
      destPoint.setAttribValueFromNumber(attribName, newAttribValueF);
    }
  }
  _cookForV2(destPoints, fbmParams) {
    const simplex = this._getSimplex();
    const useRestAttributes = (0,_core_Type__WEBPACK_IMPORTED_MODULE_6__/* .isBooleanTrue */ .bI)(this.pv.useRestAttributes);
    const useNormals = (0,_core_Type__WEBPACK_IMPORTED_MODULE_6__/* .isBooleanTrue */ .bI)(this.pv.useNormals);
    const tamplitudeAttrib = (0,_core_Type__WEBPACK_IMPORTED_MODULE_6__/* .isBooleanTrue */ .bI)(this.pv.tamplitudeAttrib);
    const baseAmplitude = this.pv.amplitude;
    const operation = OPERATIONS[this.pv.operation];
    const attribName = this.pv.attribName;
    for (const destPoint of destPoints) {
      if (useRestAttributes) {
        destPoint.attribValueVector3(this.pv.restP, position);
        if (useNormals) {
          destPoint.attribValueVector3(this.pv.restN, normal);
        }
        _currentAttribValueV2.set(position.x, position.y);
      } else {
        destPoint.position(position);
        if (useNormals) {
          destPoint.attribValueVector3(_core_geometry_Attribute__WEBPACK_IMPORTED_MODULE_7__/* .Attribute.NORMAL */ .ah.NORMAL, normal);
        }
        destPoint.attribValueVector2(attribName, _currentAttribValueV2);
      }
      const amplitude = tamplitudeAttrib ? this._amplitudeFromAttrib(destPoint, baseAmplitude) : baseAmplitude;
      const noiseResult = this._noiseValue(useNormals, simplex, amplitude, fbmParams, position, normal);
      _restValue2.set(noiseResult.x, noiseResult.y);
      const noiseValue = _restValue2;
      const newAttribValueV = NoiseSopNode._newAttribValueFromVector2(
        operation,
        _currentAttribValueV2,
        noiseValue
      );
      destPoint.setAttribValueFromVector2(attribName, newAttribValueV);
    }
  }
  _cookForV3(destPoints, fbmParams) {
    const simplex = this._getSimplex();
    const useRestAttributes = (0,_core_Type__WEBPACK_IMPORTED_MODULE_6__/* .isBooleanTrue */ .bI)(this.pv.useRestAttributes);
    const useNormals = (0,_core_Type__WEBPACK_IMPORTED_MODULE_6__/* .isBooleanTrue */ .bI)(this.pv.useNormals);
    const tamplitudeAttrib = (0,_core_Type__WEBPACK_IMPORTED_MODULE_6__/* .isBooleanTrue */ .bI)(this.pv.tamplitudeAttrib);
    const baseAmplitude = this.pv.amplitude;
    const operation = OPERATIONS[this.pv.operation];
    const attribName = this.pv.attribName;
    for (const destPoint of destPoints) {
      if (useRestAttributes) {
        destPoint.attribValueVector3(this.pv.restP, position);
        if (useNormals) {
          destPoint.attribValueVector3(this.pv.restN, normal);
        }
        _currentAttribValueV3.copy(position);
      } else {
        destPoint.position(position);
        if (useNormals) {
          destPoint.attribValueVector3(_core_geometry_Attribute__WEBPACK_IMPORTED_MODULE_7__/* .Attribute.NORMAL */ .ah.NORMAL, normal);
        }
        destPoint.attribValueVector3(attribName, _currentAttribValueV3);
      }
      const amplitude = tamplitudeAttrib ? this._amplitudeFromAttrib(destPoint, baseAmplitude) : baseAmplitude;
      const noiseResult = this._noiseValue(useNormals, simplex, amplitude, fbmParams, position, normal);
      const noiseValue = noiseResult;
      const newAttribValueV = NoiseSopNode._newAttribValueFromVector3(
        operation,
        _currentAttribValueV3,
        noiseValue
      );
      destPoint.setAttribValueFromVector3(attribName, newAttribValueV);
    }
  }
  _cookForV4(destPoints, fbmParams) {
    const simplex = this._getSimplex();
    const useRestAttributes = (0,_core_Type__WEBPACK_IMPORTED_MODULE_6__/* .isBooleanTrue */ .bI)(this.pv.useRestAttributes);
    const useNormals = (0,_core_Type__WEBPACK_IMPORTED_MODULE_6__/* .isBooleanTrue */ .bI)(this.pv.useNormals);
    const tamplitudeAttrib = (0,_core_Type__WEBPACK_IMPORTED_MODULE_6__/* .isBooleanTrue */ .bI)(this.pv.tamplitudeAttrib);
    const baseAmplitude = this.pv.amplitude;
    const operation = OPERATIONS[this.pv.operation];
    const attribName = this.pv.attribName;
    for (const destPoint of destPoints) {
      if (useRestAttributes) {
        destPoint.attribValueVector3(this.pv.restP, position);
        if (useNormals) {
          destPoint.attribValueVector3(this.pv.restN, normal);
        }
        _currentAttribValueV4.set(position.x, position.y, position.z, 0);
      } else {
        destPoint.position(position);
        if (useNormals) {
          destPoint.attribValueVector3(_core_geometry_Attribute__WEBPACK_IMPORTED_MODULE_7__/* .Attribute.NORMAL */ .ah.NORMAL, normal);
        }
        destPoint.attribValueVector4(attribName, _currentAttribValueV4);
      }
      const amplitude = tamplitudeAttrib ? this._amplitudeFromAttrib(destPoint, baseAmplitude) : baseAmplitude;
      const noiseResult = this._noiseValue(useNormals, simplex, amplitude, fbmParams, position, normal);
      _restValue4.set(noiseResult.x, noiseResult.y, noiseResult.z, 0);
      const noiseValue = _restValue4;
      const newAttribValueV = NoiseSopNode._newAttribValueFromVector4(
        operation,
        _currentAttribValueV4,
        noiseValue
      );
      destPoint.setAttribValueFromVector4(attribName, newAttribValueV);
    }
  }
  _noiseValue(useNormals, simplex, amplitude, fmbParams, position2, normal2) {
    _restPos.copy(position2).add(this.pv.offset).multiply(this.pv.freq);
    if (useNormals && normal2) {
      const noise = amplitude * this._fbm(simplex, fmbParams, _restPos.x, _restPos.y, _restPos.z);
      _noiseValueV.copy(normal2);
      return _noiseValueV.multiplyScalar(noise);
    } else {
      _noiseValueV.set(
        amplitude * this._fbm(simplex, fmbParams, _restPos.x + 545, _restPos.y + 125454, _restPos.z + 2142),
        amplitude * this._fbm(simplex, fmbParams, _restPos.x - 425, _restPos.y - 25746, _restPos.z + 95242),
        amplitude * this._fbm(simplex, fmbParams, _restPos.x + 765132, _restPos.y + 21, _restPos.z - 9245)
      );
      return _noiseValueV;
    }
  }
  static _newAttribValueFromFloat(operation, current_attrib_value, noise_value) {
    switch (operation) {
      case "add" /* ADD */:
        return current_attrib_value + noise_value;
      case "set" /* SET */:
        return noise_value;
      case "mult" /* MULT */:
        return current_attrib_value * noise_value;
      case "divide" /* DIVIDE */:
        return current_attrib_value / noise_value;
      case "subtract" /* SUBTRACT */:
        return current_attrib_value - noise_value;
    }
    _poly_Assert__WEBPACK_IMPORTED_MODULE_8__/* .TypeAssert.unreachable */ .f.unreachable(operation);
  }
  static _newAttribValueFromVector2(operation, current_attrib_value, noise_value) {
    switch (operation) {
      case "add" /* ADD */:
        return current_attrib_value.add(noise_value);
      case "set" /* SET */:
        return noise_value;
      case "mult" /* MULT */:
        return current_attrib_value.multiply(noise_value);
      case "divide" /* DIVIDE */:
        return current_attrib_value.divide(noise_value);
      case "subtract" /* SUBTRACT */:
        return current_attrib_value.sub(noise_value);
    }
    _poly_Assert__WEBPACK_IMPORTED_MODULE_8__/* .TypeAssert.unreachable */ .f.unreachable(operation);
  }
  static _newAttribValueFromVector3(operation, current_attrib_value, noise_value) {
    switch (operation) {
      case "add" /* ADD */:
        return current_attrib_value.add(noise_value);
      case "set" /* SET */:
        return noise_value;
      case "mult" /* MULT */:
        return current_attrib_value.multiply(noise_value);
      case "divide" /* DIVIDE */:
        return current_attrib_value.divide(noise_value);
      case "subtract" /* SUBTRACT */:
        return current_attrib_value.sub(noise_value);
    }
    _poly_Assert__WEBPACK_IMPORTED_MODULE_8__/* .TypeAssert.unreachable */ .f.unreachable(operation);
  }
  static _newAttribValueFromVector4(operation, current_attrib_value, noise_value) {
    switch (operation) {
      case "add" /* ADD */:
        return current_attrib_value.add(noise_value);
      case "set" /* SET */:
        return noise_value;
      case "mult" /* MULT */:
        return current_attrib_value.multiplyScalar(noise_value.x);
      case "divide" /* DIVIDE */:
        return current_attrib_value.divideScalar(noise_value.x);
      case "subtract" /* SUBTRACT */:
        return current_attrib_value.sub(noise_value);
    }
    _poly_Assert__WEBPACK_IMPORTED_MODULE_8__/* .TypeAssert.unreachable */ .f.unreachable(operation);
  }
  _amplitudeFromAttrib(point, base_amplitude) {
    const attrib_value = point.attribValue(this.pv.amplitudeAttrib);
    if (_core_Type__WEBPACK_IMPORTED_MODULE_6__/* .CoreType.isNumber */ .MR.isNumber(attrib_value)) {
      return attrib_value * base_amplitude;
    } else {
      if (attrib_value instanceof three__WEBPACK_IMPORTED_MODULE_0__.Vector2 || attrib_value instanceof three__WEBPACK_IMPORTED_MODULE_0__.Vector3 || attrib_value instanceof three__WEBPACK_IMPORTED_MODULE_0__.Vector4) {
        return attrib_value.x * base_amplitude;
      }
    }
    return 1;
  }
  _fbm(simplex, params, x, y, z) {
    let value = 0;
    let amplitude = 1;
    for (let i = 0; i < params.octaves; i++) {
      value += amplitude * simplex.noise3d(x, y, z);
      x *= params.freqIncrease;
      y *= params.freqIncrease;
      z *= params.freqIncrease;
      amplitude *= params.ampAttenuation;
    }
    return value;
  }
  _getSimplex() {
    const simplex = this._simplexBySeed.get(this.pv.seed);
    if (simplex) {
      return simplex;
    } else {
      const simplex2 = this._createSimplex();
      this._simplexBySeed.set(this.pv.seed, simplex2);
      return simplex2;
    }
  }
  _createSimplex() {
    const seed = this.pv.seed;
    const random_generator = {
      random: function() {
        return _core_math_Module__WEBPACK_IMPORTED_MODULE_9__/* .CoreMath.randFloat */ .Gj.randFloat(seed);
      }
    };
    const simplex = new three_examples_jsm_math_SimplexNoise__WEBPACK_IMPORTED_MODULE_10__/* .SimplexNoise */ .L(random_generator);
    this._simplexBySeed.delete(seed);
    return simplex;
  }
}


/***/ }),

/***/ 45658:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "h": function() { return /* binding */ ObjectMergeSopNode; }
/* harmony export */ });
/* harmony import */ var _Base__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(55839);
/* harmony import */ var _poly_NodeContext__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(52070);
/* harmony import */ var _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(96949);

var __async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};



class ObjectMergeSopParamsConfig extends _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_0__/* .NodeParamsConfig */ .yI {
  constructor() {
    super(...arguments);
    /** @param which SOP node to import from */
    this.geometry = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_0__/* .ParamConfig.NODE_PATH */ .XC.NODE_PATH("", {
      nodeSelection: {
        context: _poly_NodeContext__WEBPACK_IMPORTED_MODULE_1__/* .NodeContext.SOP */ .sy.SOP
      }
    });
  }
}
const ParamsConfig = new ObjectMergeSopParamsConfig();
class ObjectMergeSopNode extends _Base__WEBPACK_IMPORTED_MODULE_2__/* .TypedSopNode */ .x {
  constructor() {
    super(...arguments);
    this.paramsConfig = ParamsConfig;
  }
  static type() {
    return "objectMerge";
  }
  cook(input_containers) {
    return __async(this, null, function* () {
      const geometryNode = this.pv.geometry.nodeWithContext(_poly_NodeContext__WEBPACK_IMPORTED_MODULE_1__/* .NodeContext.SOP */ .sy.SOP, this.states.error);
      if (!geometryNode) {
        this.states.error.set(`node not found at path '${this.pv.geometry}'`);
        return;
      }
      const container = yield geometryNode.compute();
      this.importInput(geometryNode, container);
    });
  }
  importInput(geometry_node, container) {
    let core_group;
    if ((core_group = container.coreContentCloned()) != null) {
      this.setCoreGroup(core_group);
    } else {
      this.states.error.set("invalid target");
    }
  }
}


/***/ }),

/***/ 52620:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "M": function() { return /* binding */ ObjectPropertiesSopNode; }
/* harmony export */ });
/* harmony import */ var _Base__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(55839);
/* harmony import */ var _operations_sop_ObjectProperties__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(38229);
/* harmony import */ var _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(96949);
/* harmony import */ var _core_Type__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(19037);
/* harmony import */ var _core_geometry_Mask__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(58290);
/* harmony import */ var _poly_registers_nodes_types_Sop__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(58986);

var __async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};






const DEFAULT = _operations_sop_ObjectProperties__WEBPACK_IMPORTED_MODULE_0__/* .ObjectPropertiesSopOperation.DEFAULT_PARAMS */ .L.DEFAULT_PARAMS;
class ObjectPropertiesSopParamsConfig extends _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .NodeParamsConfig */ .yI {
  constructor() {
    super(...arguments);
    /** @param group to assign the material to */
    this.group = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .ParamConfig.STRING */ .XC.STRING(DEFAULT.group, {
      objectMask: true
    });
    /** @param toggle on to set a new name */
    this.tname = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .ParamConfig.BOOLEAN */ .XC.BOOLEAN(DEFAULT.tname);
    /** @param new name */
    this.name = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .ParamConfig.STRING */ .XC.STRING(DEFAULT.name, {
      visibleIf: { tname: true },
      separatorAfter: true,
      expression: { forEntities: true }
    });
    /** @param toggle on to set a new render order */
    this.trenderOrder = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .ParamConfig.BOOLEAN */ .XC.BOOLEAN(DEFAULT.trenderOrder);
    /** @param render order */
    this.renderOrder = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .ParamConfig.INTEGER */ .XC.INTEGER(DEFAULT.renderOrder, {
      visibleIf: { trenderOrder: true },
      range: [0, 10],
      rangeLocked: [false, false],
      separatorAfter: true,
      expression: { forEntities: true }
    });
    /** @param toggle on to allow to set frustrumCulled */
    this.tfrustumCulled = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .ParamConfig.BOOLEAN */ .XC.BOOLEAN(DEFAULT.tfrustumCulled);
    /** @param sets frustrumCulled */
    this.frustumCulled = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .ParamConfig.BOOLEAN */ .XC.BOOLEAN(DEFAULT.frustumCulled, {
      visibleIf: { tfrustumCulled: true },
      separatorAfter: true,
      expression: { forEntities: true }
    });
    /** @param toggle on to allow to set matrixAutoUpdate */
    this.tmatrixAutoUpdate = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .ParamConfig.BOOLEAN */ .XC.BOOLEAN(DEFAULT.tmatrixAutoUpdate);
    /** @param sets matrixAutoUpdate */
    this.matrixAutoUpdate = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .ParamConfig.BOOLEAN */ .XC.BOOLEAN(DEFAULT.matrixAutoUpdate, {
      visibleIf: { tmatrixAutoUpdate: true },
      separatorAfter: true,
      expression: { forEntities: true }
    });
    /** @param toggle on to allow to set visible */
    this.tvisible = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .ParamConfig.BOOLEAN */ .XC.BOOLEAN(DEFAULT.tvisible);
    /** @param sets visible */
    this.visible = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .ParamConfig.BOOLEAN */ .XC.BOOLEAN(DEFAULT.visible, {
      visibleIf: { tvisible: true },
      separatorAfter: true,
      expression: { forEntities: true }
    });
    /** @param toggle on to allow to set castShadow */
    this.tcastShadow = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .ParamConfig.BOOLEAN */ .XC.BOOLEAN(DEFAULT.tcastShadow);
    /** @param sets castShadow */
    this.castShadow = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .ParamConfig.BOOLEAN */ .XC.BOOLEAN(DEFAULT.castShadow, {
      visibleIf: { tcastShadow: true },
      separatorAfter: true,
      expression: { forEntities: true }
    });
    /** @param toggle on to allow to set receiveShadow */
    this.treceiveShadow = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .ParamConfig.BOOLEAN */ .XC.BOOLEAN(DEFAULT.treceiveShadow);
    /** @param sets receiveShadow */
    this.receiveShadow = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .ParamConfig.BOOLEAN */ .XC.BOOLEAN(DEFAULT.receiveShadow, {
      visibleIf: { treceiveShadow: true },
      expression: { forEntities: true }
    });
  }
}
const ParamsConfig = new ObjectPropertiesSopParamsConfig();
class ObjectPropertiesSopNode extends _Base__WEBPACK_IMPORTED_MODULE_2__/* .TypedSopNode */ .x {
  constructor() {
    super(...arguments);
    this.paramsConfig = ParamsConfig;
  }
  static type() {
    return _poly_registers_nodes_types_Sop__WEBPACK_IMPORTED_MODULE_3__/* .SopType.OBJECT_PROPERTIES */ .aB.OBJECT_PROPERTIES;
  }
  initializeNode() {
    this.io.inputs.setCount(1);
    this.io.inputs.initInputsClonedState(_operations_sop_ObjectProperties__WEBPACK_IMPORTED_MODULE_0__/* .ObjectPropertiesSopOperation.INPUT_CLONED_STATE */ .L.INPUT_CLONED_STATE);
  }
  cook(inputCoreGroups) {
    return __async(this, null, function* () {
      this._operation = this._operation || new _operations_sop_ObjectProperties__WEBPACK_IMPORTED_MODULE_0__/* .ObjectPropertiesSopOperation */ .L(this.scene(), this.states, this);
      const paramWithExpression = this.params.all.find((param) => param.hasExpression());
      if (paramWithExpression) {
        const coreGroup = inputCoreGroups[0];
        yield this._cookWithExpressions(coreGroup);
        this.setCoreGroup(coreGroup);
      } else {
        const coreGroup = this._operation.cook(inputCoreGroups, this.pv);
        this.setCoreGroup(coreGroup);
      }
    });
  }
  _cookWithExpressions(coreGroup) {
    return __async(this, null, function* () {
      const selectedCoreObjects = (0,_core_geometry_Mask__WEBPACK_IMPORTED_MODULE_4__/* .filterCoreObjectsFromCoreGroup */ .bK)(coreGroup, this.pv);
      yield this._cookWithExpressionsForCoreObjects(selectedCoreObjects);
    });
  }
  _cookWithExpressionsForCoreObjects(entities) {
    return __async(this, null, function* () {
      const p = this.p;
      function applyStringParam(booleanParam, valueParam, property) {
        return __async(this, null, function* () {
          if ((0,_core_Type__WEBPACK_IMPORTED_MODULE_5__/* .isBooleanTrue */ .bI)(booleanParam.value)) {
            if (valueParam.expressionController && valueParam.expressionController.entitiesDependent()) {
              yield valueParam.expressionController.computeExpressionForObjects(
                entities,
                (entity, value) => {
                  entity.object()[property] = value;
                }
              );
            } else {
              for (const entity of entities) {
                const object = entity.object();
                if (object) {
                  object[property] = valueParam.value;
                }
              }
            }
          }
        });
      }
      function applyNumberParam(booleanParam, valueParam, property) {
        return __async(this, null, function* () {
          if ((0,_core_Type__WEBPACK_IMPORTED_MODULE_5__/* .isBooleanTrue */ .bI)(booleanParam.value)) {
            if (valueParam.expressionController && valueParam.expressionController.entitiesDependent()) {
              yield valueParam.expressionController.computeExpressionForObjects(
                entities,
                (entity, value) => {
                  entity.object()[property] = value;
                }
              );
            } else {
              for (const entity of entities) {
                const object = entity.object();
                if (object) {
                  object[property] = valueParam.value;
                }
              }
            }
          }
        });
      }
      function applyBooleanParam(booleanParam, valueParam, property) {
        return __async(this, null, function* () {
          if ((0,_core_Type__WEBPACK_IMPORTED_MODULE_5__/* .isBooleanTrue */ .bI)(booleanParam.value)) {
            if (valueParam.expressionController && valueParam.expressionController.entitiesDependent()) {
              yield valueParam.expressionController.computeExpressionForObjects(
                entities,
                (entity, value) => {
                  entity.object()[property] = value;
                }
              );
            } else {
              for (const entity of entities) {
                const object = entity.object();
                if (object) {
                  object[property] = valueParam.value;
                }
              }
            }
          }
        });
      }
      yield Promise.all([
        applyStringParam(p.tname, p.name, "name"),
        applyNumberParam(p.trenderOrder, p.renderOrder, "renderOrder"),
        applyBooleanParam(p.tfrustumCulled, p.frustumCulled, "frustumCulled"),
        applyBooleanParam(p.tmatrixAutoUpdate, p.matrixAutoUpdate, "matrixAutoUpdate"),
        applyBooleanParam(p.tvisible, p.visible, "visible"),
        applyBooleanParam(p.tcastShadow, p.castShadow, "castShadow"),
        applyBooleanParam(p.treceiveShadow, p.receiveShadow, "receiveShadow")
      ]);
    });
  }
}


/***/ }),

/***/ 67118:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "D": function() { return /* binding */ ObjectsLayoutSopNode; }
/* harmony export */ });
/* harmony import */ var _Base__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(55839);
/* harmony import */ var _operations_sop_ObjectsLayout__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(38681);
/* harmony import */ var _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(96949);
/* harmony import */ var _poly_registers_nodes_types_Sop__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(58986);





const DEFAULT = _operations_sop_ObjectsLayout__WEBPACK_IMPORTED_MODULE_0__/* .ObjectsLayoutSopOperation.DEFAULT_PARAMS */ .k.DEFAULT_PARAMS;
class ObjectsLayoutSopParamConfig extends _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .NodeParamsConfig */ .yI {
  constructor() {
    super(...arguments);
    /** @param layout width */
    this.maxLayoutWidth = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .ParamConfig.FLOAT */ .XC.FLOAT(DEFAULT.maxLayoutWidth, { range: [0, 10] });
    /** @param row height */
    this.rowHeight = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .ParamConfig.FLOAT */ .XC.FLOAT(DEFAULT.rowHeight, { range: [0, 10] });
    /** @param padding between objects */
    this.padding = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .ParamConfig.VECTOR2 */ .XC.VECTOR2(DEFAULT.padding.toArray());
    /** @param addAttribs */
    this.addAttribs = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .ParamConfig.BOOLEAN */ .XC.BOOLEAN(DEFAULT.addAttribs);
    /** @param add row index attribute */
    this.addRowAttrib = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .ParamConfig.BOOLEAN */ .XC.BOOLEAN(DEFAULT.addRowAttrib, {
      visibleIf: { addAttribs: 1 }
    });
    /** @param add rowWidthInner attribute */
    this.addRowWidthInner = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .ParamConfig.BOOLEAN */ .XC.BOOLEAN(DEFAULT.addRowWidthInner, {
      visibleIf: { addAttribs: 1 }
    });
    /** @param add rowWidthOuter attribute */
    this.addRowWidthOuter = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .ParamConfig.BOOLEAN */ .XC.BOOLEAN(DEFAULT.addRowWidthOuter, {
      visibleIf: { addAttribs: 1 }
    });
  }
}
const ParamsConfig = new ObjectsLayoutSopParamConfig();
class ObjectsLayoutSopNode extends _Base__WEBPACK_IMPORTED_MODULE_2__/* .TypedSopNode */ .x {
  constructor() {
    super(...arguments);
    this.paramsConfig = ParamsConfig;
  }
  static type() {
    return _poly_registers_nodes_types_Sop__WEBPACK_IMPORTED_MODULE_3__/* .SopType.OBJECTS_LAYOUT */ .aB.OBJECTS_LAYOUT;
  }
  initializeNode() {
    this.io.inputs.setCount(1);
    this.io.inputs.initInputsClonedState(_operations_sop_ObjectsLayout__WEBPACK_IMPORTED_MODULE_0__/* .ObjectsLayoutSopOperation.INPUT_CLONED_STATE */ .k.INPUT_CLONED_STATE);
  }
  cook(inputCoreGroups) {
    this._operation = this._operation || new _operations_sop_ObjectsLayout__WEBPACK_IMPORTED_MODULE_0__/* .ObjectsLayoutSopOperation */ .k(this.scene(), this.states, this);
    const coreGroup = this._operation.cook(inputCoreGroups, this.pv);
    this.setCoreGroup(coreGroup);
  }
}


/***/ }),

/***/ 50905:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "q": function() { return /* binding */ OrthographicCameraSopNode; }
/* harmony export */ });
/* harmony import */ var _Base__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(55839);
/* harmony import */ var _operations_sop_OrthographicCamera__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(85775);
/* harmony import */ var _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(96949);
/* harmony import */ var _poly_NodeContext__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(52070);
/* harmony import */ var _core_camera_CoreOrthographicCamera__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(13431);
/* harmony import */ var _utils_camera_updateCameraTransformParams__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(36993);







const DEFAULT = _operations_sop_OrthographicCamera__WEBPACK_IMPORTED_MODULE_0__/* .OrthographicCameraSopOperation.DEFAULT_PARAMS */ .a.DEFAULT_PARAMS;
class OrthographicCameraSopParamsConfig extends _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .NodeParamsConfig */ .yI {
  constructor() {
    super(...arguments);
    /** @param camera view size */
    this.size = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .ParamConfig.FLOAT */ .XC.FLOAT(DEFAULT.size, {
      range: [1e-3, 2],
      rangeLocked: [true, false]
    });
    /** @param camera near */
    this.near = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .ParamConfig.FLOAT */ .XC.FLOAT(DEFAULT.near, {
      range: [0, 100],
      rangeLocked: [true, false]
    });
    /** @param camera far */
    this.far = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .ParamConfig.FLOAT */ .XC.FLOAT(DEFAULT.far, {
      range: [0, 100],
      rangeLocked: [true, false]
    });
    /** @param camera position */
    this.position = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .ParamConfig.VECTOR3 */ .XC.VECTOR3(DEFAULT.position);
    /** @param camera rotation */
    this.rotation = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .ParamConfig.VECTOR3 */ .XC.VECTOR3(DEFAULT.rotation);
    /** @param show helper */
    this.showHelper = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .ParamConfig.BOOLEAN */ .XC.BOOLEAN(DEFAULT.showHelper);
    /** @param matrixAutoUpdate */
    this.matrixAutoUpdate = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .ParamConfig.BOOLEAN */ .XC.BOOLEAN(DEFAULT.matrixAutoUpdate);
    /** @param camera name */
    this.name = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .ParamConfig.STRING */ .XC.STRING("`$OS`");
    /** @param set main camera */
    this.updateTransformFromCamera = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .ParamConfig.BUTTON */ .XC.BUTTON(null, {
      callback: (node) => {
        (0,_utils_camera_updateCameraTransformParams__WEBPACK_IMPORTED_MODULE_2__/* .updateCameraTransformParams */ .w)(node);
      }
    });
  }
}
const ParamsConfig = new OrthographicCameraSopParamsConfig();
class OrthographicCameraSopNode extends _Base__WEBPACK_IMPORTED_MODULE_3__/* .TypedSopNode */ .x {
  constructor() {
    super(...arguments);
    this.paramsConfig = ParamsConfig;
  }
  static type() {
    return _poly_NodeContext__WEBPACK_IMPORTED_MODULE_4__/* .CameraNodeType.ORTHOGRAPHIC */ .hY.ORTHOGRAPHIC;
  }
  initializeNode() {
    this.io.inputs.setCount(0);
  }
  cook(inputCoreGroups) {
    this._operation = this._operation || new _operations_sop_OrthographicCamera__WEBPACK_IMPORTED_MODULE_0__/* .OrthographicCameraSopOperation */ .a(this._scene, this.states, this);
    const coreGroup = this._operation.cook(inputCoreGroups, this.pv);
    this.setCoreGroup(coreGroup);
  }
}
OrthographicCameraSopNode.onRegister = _core_camera_CoreOrthographicCamera__WEBPACK_IMPORTED_MODULE_5__/* .registerOrthographicCamera */ .v7;


/***/ }),

/***/ 35640:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "u": function() { return /* binding */ PaletteSopNode; }
/* harmony export */ });
/* harmony import */ var _Base__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(55839);
/* harmony import */ var _operations_sop_Palette__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(88356);
/* harmony import */ var _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(96949);
/* harmony import */ var _core_color_chromotomeWrapper__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(89151);
/* harmony import */ var _utils_color_PaletteController__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(32842);
/* harmony import */ var _core_geometry_Constant__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(91568);
/* harmony import */ var _poly_registers_nodes_types_Sop__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(58986);

var __defProp = Object.defineProperty;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};







const DEFAULT = _operations_sop_Palette__WEBPACK_IMPORTED_MODULE_0__/* .PaletteSopOperation.DEFAULT_PARAMS */ .m.DEFAULT_PARAMS;
class PaletteSopParamsConfig extends _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .NodeParamsConfig */ .yI {
  constructor() {
    super(...arguments);
    /** @param the attribute class (geometry or object) */
    this.class = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .ParamConfig.INTEGER */ .XC.INTEGER(DEFAULT.class, {
      menu: {
        entries: _core_geometry_Constant__WEBPACK_IMPORTED_MODULE_2__/* .AttribClassMenuEntriesWithoutCoreGroup */ .oh
      }
    });
    /** @param name of the palette */
    this.paletteName = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .ParamConfig.STRING */ .XC.STRING(DEFAULT.paletteName, __spreadValues({
      menuString: {
        entries: _core_color_chromotomeWrapper__WEBPACK_IMPORTED_MODULE_3__/* .SORTED_PALETTE_NAMES.map */ .QK.map((name, value) => {
          return { name, value: name };
        })
      }
    }, (0,_utils_color_PaletteController__WEBPACK_IMPORTED_MODULE_4__/* .paletteControllerCallbackOptions */ .Sk)(_utils_color_PaletteController__WEBPACK_IMPORTED_MODULE_4__/* .PaletteController.PARAM_CALLBACK_updateColors */ .qT.PARAM_CALLBACK_updateColors)));
    /** @param click to set the node to the next palette */
    this.pickNext = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .ParamConfig.BUTTON */ .XC.BUTTON(null, (0,_utils_color_PaletteController__WEBPACK_IMPORTED_MODULE_4__/* .paletteControllerCallbackOptions */ .Sk)(_utils_color_PaletteController__WEBPACK_IMPORTED_MODULE_4__/* .PaletteController.PARAM_CALLBACK_pickNext */ .qT.PARAM_CALLBACK_pickNext));
    /** @param click to set the node to the previous palette */
    this.pickPrevious = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .ParamConfig.BUTTON */ .XC.BUTTON(
      null,
      (0,_utils_color_PaletteController__WEBPACK_IMPORTED_MODULE_4__/* .paletteControllerCallbackOptions */ .Sk)(_utils_color_PaletteController__WEBPACK_IMPORTED_MODULE_4__/* .PaletteController.PARAM_CALLBACK_pickPrevious */ .qT.PARAM_CALLBACK_pickPrevious)
    );
    /** @param click to set the node to a random palette */
    this.pickRandom = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .ParamConfig.BUTTON */ .XC.BUTTON(
      null,
      (0,_utils_color_PaletteController__WEBPACK_IMPORTED_MODULE_4__/* .paletteControllerCallbackOptions */ .Sk)(_utils_color_PaletteController__WEBPACK_IMPORTED_MODULE_4__/* .PaletteController.PARAM_CALLBACK_pickRandom */ .qT.PARAM_CALLBACK_pickRandom)
    );
    this.colorsCount = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .ParamConfig.INTEGER */ .XC.INTEGER(DEFAULT.colorsCount, {
      hidden: true,
      range: [0, _core_color_chromotomeWrapper__WEBPACK_IMPORTED_MODULE_3__/* .MAX_PALETTE_COLORS_COUNT */ .JT],
      separatorAfter: true
    });
    /** @param palette color 1 */
    this.color1 = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .ParamConfig.COLOR */ .XC.COLOR(DEFAULT.color1.toArray(), {
      visibleIf: (0,_core_color_chromotomeWrapper__WEBPACK_IMPORTED_MODULE_3__/* .visibleIfColorsCountAtLeast */ .i2)(1)
      // conversion: ColorConversion.SRGB_TO_LINEAR,
    });
    /** @param palette color 2 */
    this.color2 = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .ParamConfig.COLOR */ .XC.COLOR(DEFAULT.color2.toArray(), {
      visibleIf: (0,_core_color_chromotomeWrapper__WEBPACK_IMPORTED_MODULE_3__/* .visibleIfColorsCountAtLeast */ .i2)(2)
      // conversion: ColorConversion.SRGB_TO_LINEAR,
    });
    /** @param palette color 3 */
    this.color3 = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .ParamConfig.COLOR */ .XC.COLOR(DEFAULT.color3.toArray(), {
      visibleIf: (0,_core_color_chromotomeWrapper__WEBPACK_IMPORTED_MODULE_3__/* .visibleIfColorsCountAtLeast */ .i2)(3)
      // conversion: ColorConversion.SRGB_TO_LINEAR,
    });
    /** @param palette color 4 */
    this.color4 = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .ParamConfig.COLOR */ .XC.COLOR(DEFAULT.color4.toArray(), {
      visibleIf: (0,_core_color_chromotomeWrapper__WEBPACK_IMPORTED_MODULE_3__/* .visibleIfColorsCountAtLeast */ .i2)(4)
      // conversion: ColorConversion.SRGB_TO_LINEAR,
    });
    /** @param palette color 5 */
    this.color5 = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .ParamConfig.COLOR */ .XC.COLOR(DEFAULT.color5.toArray(), {
      visibleIf: (0,_core_color_chromotomeWrapper__WEBPACK_IMPORTED_MODULE_3__/* .visibleIfColorsCountAtLeast */ .i2)(5)
      // conversion: ColorConversion.SRGB_TO_LINEAR,
    });
  }
}
const ParamsConfig = new PaletteSopParamsConfig();
class PaletteSopNode extends _Base__WEBPACK_IMPORTED_MODULE_5__/* .TypedSopNode */ .x {
  constructor() {
    super(...arguments);
    this.paramsConfig = ParamsConfig;
    this.paletteController = new _utils_color_PaletteController__WEBPACK_IMPORTED_MODULE_4__/* .PaletteController */ .qT(
      this
    );
  }
  static type() {
    return _poly_registers_nodes_types_Sop__WEBPACK_IMPORTED_MODULE_6__/* .SopType.PALETTE */ .aB.PALETTE;
  }
  initializeNode() {
    this.io.inputs.setCount(1);
    this.io.inputs.initInputsClonedState(_operations_sop_Palette__WEBPACK_IMPORTED_MODULE_0__/* .PaletteSopOperation.INPUT_CLONED_STATE */ .m.INPUT_CLONED_STATE);
    this.params.onParamsCreated("palette_init", () => {
      _utils_color_PaletteController__WEBPACK_IMPORTED_MODULE_4__/* .PaletteController.PARAM_CALLBACK_updateColors */ .qT.PARAM_CALLBACK_updateColors(this);
    });
  }
  cook(input_contents) {
    this._operation = this._operation || new _operations_sop_Palette__WEBPACK_IMPORTED_MODULE_0__/* .PaletteSopOperation */ .m(this._scene, this.states, this);
    const core_group = this._operation.cook(input_contents, this.pv);
    this.setCoreGroup(core_group);
  }
  //
  //
  // API UTILS
  //
  //
  setAttribClass(attribClass) {
    this.p.class.set(_core_geometry_Constant__WEBPACK_IMPORTED_MODULE_2__/* .ATTRIBUTE_CLASSES_WITHOUT_CORE_GROUP.indexOf */ .fc.indexOf(attribClass));
  }
  attribClass() {
    return _core_geometry_Constant__WEBPACK_IMPORTED_MODULE_2__/* .ATTRIBUTE_CLASSES_WITHOUT_CORE_GROUP */ .fc[this.pv.class];
  }
}


/***/ }),

/***/ 33973:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "u": function() { return /* binding */ PerspectiveCameraSopNode; }
/* harmony export */ });
/* harmony import */ var _Base__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(55839);
/* harmony import */ var _operations_sop_PerspectiveCamera__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(41246);
/* harmony import */ var _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(96949);
/* harmony import */ var _poly_NodeContext__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(52070);
/* harmony import */ var _core_camera_CorePerspectiveCamera__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(68144);
/* harmony import */ var _utils_camera_updateCameraTransformParams__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(36993);







const DEFAULT = _operations_sop_PerspectiveCamera__WEBPACK_IMPORTED_MODULE_0__/* .PerspectiveCameraSopOperation.DEFAULT_PARAMS */ .C.DEFAULT_PARAMS;
class PerspectiveCameraSopParamsConfig extends _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .NodeParamsConfig */ .yI {
  constructor() {
    super(...arguments);
    this.default = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .ParamConfig.FOLDER */ .XC.FOLDER();
    /** @param camera fov */
    this.fov = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .ParamConfig.FLOAT */ .XC.FLOAT(DEFAULT.fov, {
      range: _core_camera_CorePerspectiveCamera__WEBPACK_IMPORTED_MODULE_2__/* .PERSPECTIVE_CAMERA_DEFAULT.fovRange */ .dR.fovRange,
      rangeLocked: [true, false]
    });
    /** @param camera near */
    this.near = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .ParamConfig.FLOAT */ .XC.FLOAT(DEFAULT.near, {
      range: [0, 100],
      rangeLocked: [true, false]
    });
    /** @param camera far */
    this.far = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .ParamConfig.FLOAT */ .XC.FLOAT(DEFAULT.far, {
      range: [0, 100],
      rangeLocked: [true, false]
    });
    /** @param camera position */
    this.position = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .ParamConfig.VECTOR3 */ .XC.VECTOR3(DEFAULT.position);
    /** @param camera rotation */
    this.rotation = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .ParamConfig.VECTOR3 */ .XC.VECTOR3(DEFAULT.rotation);
    /** @param show helper */
    this.showHelper = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .ParamConfig.BOOLEAN */ .XC.BOOLEAN(DEFAULT.showHelper);
    /** @param matrixAutoUpdate */
    this.matrixAutoUpdate = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .ParamConfig.BOOLEAN */ .XC.BOOLEAN(DEFAULT.matrixAutoUpdate);
    /** @param camera name */
    this.name = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .ParamConfig.STRING */ .XC.STRING("`$OS`");
    /** @param set main camera */
    this.updateTransformFromCamera = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .ParamConfig.BUTTON */ .XC.BUTTON(null, {
      callback: (node) => {
        (0,_utils_camera_updateCameraTransformParams__WEBPACK_IMPORTED_MODULE_3__/* .updateCameraTransformParams */ .w)(node);
      }
    });
    this.PBR = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .ParamConfig.FOLDER */ .XC.FOLDER();
    /** @param apertureBlades */
    this.apertureBlades = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .ParamConfig.INTEGER */ .XC.INTEGER(6, {
      range: [0, 10],
      rangeLocked: [true, false]
    });
    /** @param apertureBlades */
    this.fStop = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .ParamConfig.FLOAT */ .XC.FLOAT(0.5, {
      range: [0.02, 20],
      rangeLocked: [true, false]
    });
    /** @param focusDistance */
    this.focusDistance = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .ParamConfig.FLOAT */ .XC.FLOAT(10, {
      range: [0, 100],
      rangeLocked: [true, false]
    });
    /** @param apertureRotation */
    this.apertureRotation = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .ParamConfig.FLOAT */ .XC.FLOAT(0, {
      range: [0, 12.5],
      rangeLocked: [true, false]
    });
    /** @param anamorphicRatio */
    this.anamorphicRatio = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .ParamConfig.FLOAT */ .XC.FLOAT(1, {
      range: [0.1, 10],
      rangeLocked: [true, false]
    });
  }
}
const ParamsConfig = new PerspectiveCameraSopParamsConfig();
class PerspectiveCameraSopNode extends _Base__WEBPACK_IMPORTED_MODULE_4__/* .TypedSopNode */ .x {
  constructor() {
    super(...arguments);
    this.paramsConfig = ParamsConfig;
  }
  static type() {
    return _poly_NodeContext__WEBPACK_IMPORTED_MODULE_5__/* .CameraNodeType.PERSPECTIVE */ .hY.PERSPECTIVE;
  }
  initializeNode() {
    this.io.inputs.setCount(0);
  }
  cook(inputCoreGroups) {
    this._operation = this._operation || new _operations_sop_PerspectiveCamera__WEBPACK_IMPORTED_MODULE_0__/* .PerspectiveCameraSopOperation */ .C(this._scene, this.states, this);
    const coreGroup = this._operation.cook(inputCoreGroups, this.pv);
    this.setCoreGroup(coreGroup);
  }
}
PerspectiveCameraSopNode.onRegister = _core_camera_CorePerspectiveCamera__WEBPACK_IMPORTED_MODULE_2__/* .registerPerspectiveCamera */ .cI;


/***/ }),

/***/ 14776:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "b": function() { return /* binding */ PhysicsGroundSopNode; }
/* harmony export */ });
/* harmony import */ var _core_Transform__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(87883);
/* harmony import */ var _core_geometry_Constant__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(91568);
/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(21410);
/* harmony import */ var _core_physics_PhysicsAttribute__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(36911);
/* harmony import */ var _Base__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(55839);
/* harmony import */ var _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(96949);
/* harmony import */ var _operations_sop_Base__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(82612);
/* harmony import */ var _poly_registers_nodes_types_Sop__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(58986);









const DEFAULT_UP = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3(0, 1, 0);
const tmp = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3(0, 0, 0);
class PhysicsGroundSopParamsConfig extends _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .NodeParamsConfig */ .yI {
  constructor() {
    super(...arguments);
    /** @param size */
    this.size = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .ParamConfig.VECTOR2 */ .XC.VECTOR2([10, 10]);
    /** @param center */
    this.center = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .ParamConfig.VECTOR2 */ .XC.VECTOR2([0, 0]);
    /** @param height */
    this.height = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .ParamConfig.FLOAT */ .XC.FLOAT(0, {
      range: [-1, 1],
      rangeLocked: [false, false]
    });
    /** @param direction */
    this.direction = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .ParamConfig.VECTOR3 */ .XC.VECTOR3([0, 1, 0]);
    /** @param thickness */
    this.thickness = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .ParamConfig.FLOAT */ .XC.FLOAT(1, {
      range: [0, 1],
      rangeLocked: [true, false]
    });
    /** @param friction */
    this.friction = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .ParamConfig.FLOAT */ .XC.FLOAT(0.5, {
      separatorBefore: true,
      range: [0, 1],
      rangeLocked: [true, false]
    });
    /** @param restitution */
    this.restitution = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .ParamConfig.FLOAT */ .XC.FLOAT(0.5, {
      range: [0, 1],
      rangeLocked: [true, false]
    });
  }
}
const ParamsConfig = new PhysicsGroundSopParamsConfig();
class PhysicsGroundSopNode extends _Base__WEBPACK_IMPORTED_MODULE_2__/* .TypedSopNode */ .x {
  constructor() {
    super(...arguments);
    this.paramsConfig = ParamsConfig;
  }
  static type() {
    return _poly_registers_nodes_types_Sop__WEBPACK_IMPORTED_MODULE_3__/* .SopType.PHYSICS_GROUND */ .aB.PHYSICS_GROUND;
  }
  initializeNode() {
    this.io.inputs.setCount(0);
  }
  cook() {
    const thickness = this.pv.thickness;
    const object = _operations_sop_Base__WEBPACK_IMPORTED_MODULE_4__/* .BaseSopOperation.createObject */ .U.createObject(
      new three__WEBPACK_IMPORTED_MODULE_0__.BoxGeometry(this.pv.size.x, thickness, this.pv.size.y),
      _core_geometry_Constant__WEBPACK_IMPORTED_MODULE_5__/* .ObjectType.MESH */ .LP.MESH
    );
    _core_Transform__WEBPACK_IMPORTED_MODULE_6__/* .CoreTransform.rotateObject */ .ZR.rotateObject(object, DEFAULT_UP, this.pv.direction);
    tmp.copy(this.pv.direction).normalize().multiplyScalar(-0.5 * this.pv.thickness + this.pv.height);
    object.position.copy(tmp);
    object.translateX(this.pv.center.x);
    object.translateZ(this.pv.center.y);
    object.updateMatrix();
    object.name = this.name();
    _core_physics_PhysicsAttribute__WEBPACK_IMPORTED_MODULE_7__/* .CorePhysicsAttribute.setRBDType */ .gy.setRBDType(object, _core_physics_PhysicsAttribute__WEBPACK_IMPORTED_MODULE_7__/* .PhysicsRBDType.FIXED */ .$M.FIXED);
    _core_physics_PhysicsAttribute__WEBPACK_IMPORTED_MODULE_7__/* .CorePhysicsAttribute.setColliderType */ .gy.setColliderType(object, _core_physics_PhysicsAttribute__WEBPACK_IMPORTED_MODULE_7__/* .PhysicsRBDColliderType.CUBOID */ .bs.CUBOID);
    _core_physics_PhysicsAttribute__WEBPACK_IMPORTED_MODULE_7__/* .CorePhysicsAttribute.setDensity */ .gy.setDensity(object, 0);
    _core_physics_PhysicsAttribute__WEBPACK_IMPORTED_MODULE_7__/* .CorePhysicsAttribute.setFriction */ .gy.setFriction(object, this.pv.friction);
    _core_physics_PhysicsAttribute__WEBPACK_IMPORTED_MODULE_7__/* .CorePhysicsAttribute.setRestitution */ .gy.setRestitution(object, this.pv.restitution);
    _core_physics_PhysicsAttribute__WEBPACK_IMPORTED_MODULE_7__/* .CorePhysicsAttribute.setCuboidSizes */ .gy.setCuboidSizes(object, new three__WEBPACK_IMPORTED_MODULE_0__.Vector3(this.pv.size.x, this.pv.thickness, this.pv.size.y));
    _core_physics_PhysicsAttribute__WEBPACK_IMPORTED_MODULE_7__/* .CorePhysicsAttribute.setCuboidSize */ .gy.setCuboidSize(object, 1);
    this.setObject(object);
  }
}


/***/ }),

/***/ 71011:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "M": function() { return /* binding */ PhysicsPlayerSopNode; }
/* harmony export */ });
/* harmony import */ var _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(96949);
/* harmony import */ var _poly_InputCloneMode__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(56752);
/* harmony import */ var _poly_registers_nodes_types_Sop__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(58986);
/* harmony import */ var _core_physics_PhysicsAttribute__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(36911);
/* harmony import */ var _core_physics_player_PhysicsPlayer__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(23117);
/* harmony import */ var _core_geometry_builders_SphereBuilder__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(26078);
/* harmony import */ var _core_geometry_Constant__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(91568);
/* harmony import */ var _core_geometry_CorePath__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(60074);
/* harmony import */ var _operations_sop_Base__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(82612);
/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(21410);
/* harmony import */ var _BaseActor__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(29540);












const DEFAULT = {
  radius: 0.5,
  density: 5,
  //1000,
  friction: 1,
  //0.5,
  restitution: 0.5,
  linearDamping: 0.4,
  //0,
  angularDamping: 10,
  linearVelocity: new three__WEBPACK_IMPORTED_MODULE_0__.Vector3(0, 0, 0),
  angularVelocity: new three__WEBPACK_IMPORTED_MODULE_0__.Vector3(0, 0, 0),
  gravityScale: 1
};
const type = _core_physics_player_PhysicsPlayer__WEBPACK_IMPORTED_MODULE_1__/* .PhysicsPlayerType.TORQUE */ .nE.TORQUE;
class PhysicsPlayerSopParamsConfig extends _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_2__/* .NodeParamsConfig */ .yI {
  constructor() {
    super(...arguments);
    this.main = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_2__/* .ParamConfig.FOLDER */ .XC.FOLDER();
    /** @param radius */
    this.radius = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_2__/* .ParamConfig.FLOAT */ .XC.FLOAT(0.5, {
      range: [0, 2],
      rangeLocked: [true, false]
    });
    /** @param density */
    this.density = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_2__/* .ParamConfig.FLOAT */ .XC.FLOAT(DEFAULT.density, {
      range: [0, 100],
      rangeLocked: [true, false],
      separatorBefore: true
    });
    /** @param friction */
    this.friction = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_2__/* .ParamConfig.FLOAT */ .XC.FLOAT(DEFAULT.friction, {
      range: [0, 1],
      rangeLocked: [true, false]
    });
    /** @param restitution */
    this.restitution = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_2__/* .ParamConfig.FLOAT */ .XC.FLOAT(DEFAULT.restitution, {
      range: [0, 2],
      rangeLocked: [true, false]
    });
    /** @param linear damping (affects velocity) */
    this.linearDamping = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_2__/* .ParamConfig.FLOAT */ .XC.FLOAT(DEFAULT.linearDamping, {
      range: [0, 10],
      rangeLocked: [true, false]
    });
    /** @param angular damping (affects rotations) */
    this.angularDamping = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_2__/* .ParamConfig.FLOAT */ .XC.FLOAT(DEFAULT.angularDamping, {
      range: [0, 10],
      rangeLocked: [true, false]
    });
    /** @param linear velocity */
    this.linearVelocity = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_2__/* .ParamConfig.VECTOR3 */ .XC.VECTOR3(DEFAULT.linearVelocity);
    /** @param angular velocity */
    this.angularVelocity = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_2__/* .ParamConfig.VECTOR3 */ .XC.VECTOR3(DEFAULT.angularVelocity);
    /** @param gravity Scale */
    this.gravityScale = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_2__/* .ParamConfig.FLOAT */ .XC.FLOAT(DEFAULT.gravityScale, {
      range: [-10, 10],
      rangeLocked: [false, false]
    });
    this.details = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_2__/* .ParamConfig.FOLDER */ .XC.FOLDER();
    /** @param id */
    this.id = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_2__/* .ParamConfig.STRING */ .XC.STRING("`$OS`");
  }
  /** @param collision offset */
  // offset = ParamConfig.FLOAT(0.02, {
  // 	range: [0, 0.1],
  // 	rangeLocked: [true, false],
  // });
  // /** @param apply impulses */
  // applyImpulses = ParamConfig.BOOLEAN(1);
  // /** @param distance below which the player will be snapped to the ground */
  // snapToGroundDistance = ParamConfig.FLOAT(0.5, {
  // 	range: [0, 1],
  // 	rangeLocked: [true, false],
  // });
  // /** @param auto step */
  // autoStep = ParamConfig.BOOLEAN(1, {
  // 	separatorBefore: true,
  // });
  // /** @param auto step max height */
  // autoStepMaxHeight = ParamConfig.FLOAT(0.5, {
  // 	range: [0, 1],
  // 	rangeLocked: [true, false],
  // 	visibleIf: {autoStep: 1},
  // });
  // /** @param auto step max height */
  // autoStepMinWidth = ParamConfig.FLOAT(0.5, {
  // 	range: [0, 1],
  // 	rangeLocked: [true, false],
  // 	visibleIf: {autoStep: 1},
  // });
  // /** @param auto step on dynamic objects */
  // autoStepOnDynamic = ParamConfig.BOOLEAN(1, {
  // 	visibleIf: {autoStep: 1},
  // });
  // /** @param Dont allow climbing slopes larger than this angle */
  // maxSlopeClimbAngle = ParamConfig.FLOAT(45, {
  // 	separatorBefore: true,
  // 	range: [0, 90],
  // 	rangeLocked: [true, true],
  // });
  // /** @param Automatically slide down on slopes smaller than this angle */
  // minSlopeSlideAngle = ParamConfig.FLOAT(30, {
  // 	range: [0, 90],
  // 	rangeLocked: [true, true],
  // });
  // /** @param up vector used in slope angle calculations */
  // up = ParamConfig.VECTOR3([0, 1, 0]);
}
const ParamsConfig = new PhysicsPlayerSopParamsConfig();
class PhysicsPlayerSopNode extends _BaseActor__WEBPACK_IMPORTED_MODULE_3__/* .TypedActorSopNode */ .p {
  constructor() {
    super(...arguments);
    this.paramsConfig = ParamsConfig;
  }
  static type() {
    return _poly_registers_nodes_types_Sop__WEBPACK_IMPORTED_MODULE_4__/* .SopType.PHYSICS_PLAYER */ .aB.PHYSICS_PLAYER;
  }
  initializeNode() {
    this.io.inputs.setCount(0, 2);
    this.io.inputs.initInputsClonedState(_poly_InputCloneMode__WEBPACK_IMPORTED_MODULE_5__/* .InputCloneMode.FROM_NODE */ .m.FROM_NODE);
  }
  cook(inputCoreGroups) {
    this.compilationController.compileIfRequired();
    const coreGroup0 = inputCoreGroups[0];
    const coreGroup1 = inputCoreGroups[1];
    const inputObjects = coreGroup0 ? coreGroup0.threejsObjects() : this._createDefaultInputObjects();
    const playerObject = inputObjects[0];
    this._updatePlayerObject(playerObject);
    const objects = [playerObject];
    if (coreGroup1) {
      const cameraObject = coreGroup1.threejsObjects()[0];
      if (cameraObject) {
        objects.push(cameraObject);
        const cameraPath = _core_geometry_CorePath__WEBPACK_IMPORTED_MODULE_6__/* .CorePath.objectPath */ .Oj.objectPath(cameraObject);
        _core_physics_PhysicsAttribute__WEBPACK_IMPORTED_MODULE_7__/* .CorePhysicsAttribute.setCharacterControllerCameraPath */ .gy.setCharacterControllerCameraPath(playerObject, cameraPath);
      }
    }
    this.setObjects(objects);
  }
  _updatePlayerObject(object) {
    const actorNode = this._findActorNode();
    this.scene().actorsManager.assignActorBuilder(object, actorNode);
    _core_physics_PhysicsAttribute__WEBPACK_IMPORTED_MODULE_7__/* .CorePhysicsAttribute.setRBDType */ .gy.setRBDType(
      object,
      type == _core_physics_player_PhysicsPlayer__WEBPACK_IMPORTED_MODULE_1__/* .PhysicsPlayerType.TORQUE */ .nE.TORQUE ? _core_physics_PhysicsAttribute__WEBPACK_IMPORTED_MODULE_7__/* .PhysicsRBDType.DYNAMIC */ .$M.DYNAMIC : _core_physics_PhysicsAttribute__WEBPACK_IMPORTED_MODULE_7__/* .PhysicsRBDType.KINEMATIC_POS */ .$M.KINEMATIC_POS
    );
    _core_physics_PhysicsAttribute__WEBPACK_IMPORTED_MODULE_7__/* .CorePhysicsAttribute.setColliderType */ .gy.setColliderType(object, _core_physics_PhysicsAttribute__WEBPACK_IMPORTED_MODULE_7__/* .PhysicsRBDColliderType.SPHERE */ .bs.SPHERE);
    _core_physics_PhysicsAttribute__WEBPACK_IMPORTED_MODULE_7__/* .CorePhysicsAttribute.setRadius */ .gy.setRadius(object, this.pv.radius);
    const rbdId = this.pv.id;
    object.name = rbdId;
    _core_physics_PhysicsAttribute__WEBPACK_IMPORTED_MODULE_7__/* .CorePhysicsAttribute.setRBDId */ .gy.setRBDId(object, rbdId);
    _core_physics_PhysicsAttribute__WEBPACK_IMPORTED_MODULE_7__/* .CorePhysicsAttribute.setCharacterControllerId */ .gy.setCharacterControllerId(object, rbdId);
    _core_physics_PhysicsAttribute__WEBPACK_IMPORTED_MODULE_7__/* .CorePhysicsAttribute.setDensity */ .gy.setDensity(object, this.pv.density);
    _core_physics_PhysicsAttribute__WEBPACK_IMPORTED_MODULE_7__/* .CorePhysicsAttribute.setFriction */ .gy.setFriction(object, this.pv.friction);
    _core_physics_PhysicsAttribute__WEBPACK_IMPORTED_MODULE_7__/* .CorePhysicsAttribute.setRestitution */ .gy.setRestitution(object, this.pv.restitution);
    _core_physics_PhysicsAttribute__WEBPACK_IMPORTED_MODULE_7__/* .CorePhysicsAttribute.setLinearDamping */ .gy.setLinearDamping(object, this.pv.linearDamping);
    _core_physics_PhysicsAttribute__WEBPACK_IMPORTED_MODULE_7__/* .CorePhysicsAttribute.setAngularDamping */ .gy.setAngularDamping(object, this.pv.angularDamping);
    _core_physics_PhysicsAttribute__WEBPACK_IMPORTED_MODULE_7__/* .CorePhysicsAttribute.setLinearVelocity */ .gy.setLinearVelocity(object, this.pv.linearVelocity);
    _core_physics_PhysicsAttribute__WEBPACK_IMPORTED_MODULE_7__/* .CorePhysicsAttribute.setAngularVelocity */ .gy.setAngularVelocity(object, this.pv.angularVelocity);
    _core_physics_PhysicsAttribute__WEBPACK_IMPORTED_MODULE_7__/* .CorePhysicsAttribute.setGravityScale */ .gy.setGravityScale(object, this.pv.gravityScale);
  }
  _createDefaultInputObjects() {
    const geometry = _core_geometry_builders_SphereBuilder__WEBPACK_IMPORTED_MODULE_8__/* .SphereBuilder.create */ .A.create({
      radius: this.pv.radius,
      widthSegments: 30,
      heightSegments: 30,
      asLines: false,
      open: false
    });
    const object = _operations_sop_Base__WEBPACK_IMPORTED_MODULE_9__/* .BaseSopOperation.createObject */ .U.createObject(geometry, _core_geometry_Constant__WEBPACK_IMPORTED_MODULE_10__/* .ObjectType.MESH */ .LP.MESH);
    return [object];
  }
  _findActorNode() {
    return this;
  }
}


/***/ }),

/***/ 39962:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "M": function() { return /* binding */ PhysicsRBDAttributesSopNode; },
/* harmony export */   "V": function() { return /* binding */ BORDER_RADIUS_AVAILABLE; }
/* harmony export */ });
/* harmony import */ var _poly_Assert__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(68239);
/* harmony import */ var _core_physics_PhysicsAttribute__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(36911);
/* harmony import */ var _Base__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(55839);
/* harmony import */ var _operations_sop_PhysicsRBDAttributes__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(4811);
/* harmony import */ var _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(96949);
/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(21410);
/* harmony import */ var _core_Type__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(19037);
/* harmony import */ var _poly_registers_nodes_types_Sop__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(58986);

var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
var __async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};








const tmpBox = new three__WEBPACK_IMPORTED_MODULE_0__.Box3();
const tmpSphere = new three__WEBPACK_IMPORTED_MODULE_0__.Sphere();
const DEFAULT = _operations_sop_PhysicsRBDAttributes__WEBPACK_IMPORTED_MODULE_1__/* .PhysicsRBDAttributesSopOperation.DEFAULT_PARAMS */ .fM.DEFAULT_PARAMS;
const VECTOR3_COMPONENT_NAMES = ["x", "y", "z"];
const tmpV3 = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();
const SIZE_METHOD_CUSTOM = { sizeMethod: _operations_sop_PhysicsRBDAttributes__WEBPACK_IMPORTED_MODULE_1__/* .SIZE_COMPUTATION_METHODS.indexOf */ ._K.indexOf(_operations_sop_PhysicsRBDAttributes__WEBPACK_IMPORTED_MODULE_1__/* .SizeComputationMethod.MANUAL */ .qc.MANUAL) };
const VISIBLE_OPTIONS = {
  CAPSULE: __spreadProps(__spreadValues({}, SIZE_METHOD_CUSTOM), {
    colliderType: _core_physics_PhysicsAttribute__WEBPACK_IMPORTED_MODULE_2__/* .PHYSICS_RBD_COLLIDER_TYPES.indexOf */ .EX.indexOf(_core_physics_PhysicsAttribute__WEBPACK_IMPORTED_MODULE_2__/* .PhysicsRBDColliderType.CAPSULE */ .bs.CAPSULE)
  }),
  CONE: __spreadProps(__spreadValues({}, SIZE_METHOD_CUSTOM), {
    colliderType: _core_physics_PhysicsAttribute__WEBPACK_IMPORTED_MODULE_2__/* .PHYSICS_RBD_COLLIDER_TYPES.indexOf */ .EX.indexOf(_core_physics_PhysicsAttribute__WEBPACK_IMPORTED_MODULE_2__/* .PhysicsRBDColliderType.CONE */ .bs.CONE)
  }),
  CUBOID: __spreadProps(__spreadValues({}, SIZE_METHOD_CUSTOM), {
    colliderType: _core_physics_PhysicsAttribute__WEBPACK_IMPORTED_MODULE_2__/* .PHYSICS_RBD_COLLIDER_TYPES.indexOf */ .EX.indexOf(_core_physics_PhysicsAttribute__WEBPACK_IMPORTED_MODULE_2__/* .PhysicsRBDColliderType.CUBOID */ .bs.CUBOID)
  }),
  CYLINDER: __spreadProps(__spreadValues({}, SIZE_METHOD_CUSTOM), {
    colliderType: _core_physics_PhysicsAttribute__WEBPACK_IMPORTED_MODULE_2__/* .PHYSICS_RBD_COLLIDER_TYPES.indexOf */ .EX.indexOf(_core_physics_PhysicsAttribute__WEBPACK_IMPORTED_MODULE_2__/* .PhysicsRBDColliderType.CYLINDER */ .bs.CYLINDER)
  }),
  SPHERE: __spreadProps(__spreadValues({}, SIZE_METHOD_CUSTOM), {
    colliderType: _core_physics_PhysicsAttribute__WEBPACK_IMPORTED_MODULE_2__/* .PHYSICS_RBD_COLLIDER_TYPES.indexOf */ .EX.indexOf(_core_physics_PhysicsAttribute__WEBPACK_IMPORTED_MODULE_2__/* .PhysicsRBDColliderType.SPHERE */ .bs.SPHERE)
  }),
  HEIGHT_FIELD: {
    colliderType: _core_physics_PhysicsAttribute__WEBPACK_IMPORTED_MODULE_2__/* .PHYSICS_RBD_COLLIDER_TYPES.indexOf */ .EX.indexOf(_core_physics_PhysicsAttribute__WEBPACK_IMPORTED_MODULE_2__/* .PhysicsRBDColliderType.HEIGHT_FIELD */ .bs.HEIGHT_FIELD)
  }
};
const SIZE_METHOD_AVAILABLE = [
  _core_physics_PhysicsAttribute__WEBPACK_IMPORTED_MODULE_2__/* .PhysicsRBDColliderType.CAPSULE */ .bs.CAPSULE,
  _core_physics_PhysicsAttribute__WEBPACK_IMPORTED_MODULE_2__/* .PhysicsRBDColliderType.CONE */ .bs.CONE,
  _core_physics_PhysicsAttribute__WEBPACK_IMPORTED_MODULE_2__/* .PhysicsRBDColliderType.CUBOID */ .bs.CUBOID,
  _core_physics_PhysicsAttribute__WEBPACK_IMPORTED_MODULE_2__/* .PhysicsRBDColliderType.CYLINDER */ .bs.CYLINDER,
  _core_physics_PhysicsAttribute__WEBPACK_IMPORTED_MODULE_2__/* .PhysicsRBDColliderType.SPHERE */ .bs.SPHERE
];
const BORDER_RADIUS_AVAILABLE = [
  _core_physics_PhysicsAttribute__WEBPACK_IMPORTED_MODULE_2__/* .PhysicsRBDColliderType.CONE */ .bs.CONE,
  _core_physics_PhysicsAttribute__WEBPACK_IMPORTED_MODULE_2__/* .PhysicsRBDColliderType.CUBOID */ .bs.CUBOID,
  _core_physics_PhysicsAttribute__WEBPACK_IMPORTED_MODULE_2__/* .PhysicsRBDColliderType.CYLINDER */ .bs.CYLINDER
];
class PhysicsRBDAttributesSopParamsConfig extends _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_3__/* .NodeParamsConfig */ .yI {
  constructor() {
    super(...arguments);
    this.main = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_3__/* .ParamConfig.FOLDER */ .XC.FOLDER();
    /** @param Rigid body type */
    this.RBDType = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_3__/* .ParamConfig.INTEGER */ .XC.INTEGER(DEFAULT.RBDType, {
      menu: {
        entries: _core_physics_PhysicsAttribute__WEBPACK_IMPORTED_MODULE_2__/* .PHYSICS_RBD_TYPE_MENU_ENTRIES */ .aq
      }
    });
    /** @param collider type */
    this.colliderType = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_3__/* .ParamConfig.INTEGER */ .XC.INTEGER(DEFAULT.colliderType, {
      menu: {
        entries: _core_physics_PhysicsAttribute__WEBPACK_IMPORTED_MODULE_2__/* .PHYSICS_RBD_COLLIDER_TYPE_MENU_ENTRIES */ .NV
      }
    });
    /** @param Rigid body type */
    this.sizeMethod = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_3__/* .ParamConfig.INTEGER */ .XC.INTEGER(DEFAULT.sizeMethod, {
      visibleIf: SIZE_METHOD_AVAILABLE.map((colliderType) => ({
        colliderType: _core_physics_PhysicsAttribute__WEBPACK_IMPORTED_MODULE_2__/* .PHYSICS_RBD_COLLIDER_TYPES.indexOf */ .EX.indexOf(colliderType)
      })),
      menu: {
        entries: _operations_sop_PhysicsRBDAttributes__WEBPACK_IMPORTED_MODULE_1__/* .SIZE_COMPUTATION_METHOD_MENU_ENTRIES */ .TO
      }
    });
    /** @param border radius */
    this.borderRadius = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_3__/* .ParamConfig.FLOAT */ .XC.FLOAT(DEFAULT.borderRadius, {
      visibleIf: BORDER_RADIUS_AVAILABLE.map((colliderType) => ({
        colliderType: _core_physics_PhysicsAttribute__WEBPACK_IMPORTED_MODULE_2__/* .PHYSICS_RBD_COLLIDER_TYPES.indexOf */ .EX.indexOf(colliderType)
      })),
      expression: { forEntities: true }
    });
    /** @param sizes */
    this.sizes = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_3__/* .ParamConfig.VECTOR3 */ .XC.VECTOR3(DEFAULT.sizes.toArray(), {
      visibleIf: VISIBLE_OPTIONS.CUBOID,
      expression: { forEntities: true }
    });
    /** @param sizes */
    this.size = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_3__/* .ParamConfig.FLOAT */ .XC.FLOAT(DEFAULT.size, {
      visibleIf: VISIBLE_OPTIONS.CUBOID,
      expression: { forEntities: true }
    });
    /** @param radius */
    this.radius = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_3__/* .ParamConfig.FLOAT */ .XC.FLOAT(DEFAULT.radius, {
      range: [0, 1],
      rangeLocked: [true, false],
      visibleIf: [VISIBLE_OPTIONS.CAPSULE, VISIBLE_OPTIONS.CONE, VISIBLE_OPTIONS.CYLINDER, VISIBLE_OPTIONS.SPHERE],
      expression: { forEntities: true }
    });
    /** @param half height */
    this.height = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_3__/* .ParamConfig.FLOAT */ .XC.FLOAT(DEFAULT.height, {
      range: [0, 1],
      rangeLocked: [true, false],
      visibleIf: [VISIBLE_OPTIONS.CAPSULE, VISIBLE_OPTIONS.CONE, VISIBLE_OPTIONS.CYLINDER],
      expression: { forEntities: true }
    });
    /** @param heightField rows */
    this.rows = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_3__/* .ParamConfig.INTEGER */ .XC.INTEGER(DEFAULT.rows, {
      range: [1, 100],
      rangeLocked: [true, false],
      visibleIf: VISIBLE_OPTIONS.HEIGHT_FIELD,
      expression: { forEntities: true }
    });
    /** @param heightField cols */
    this.cols = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_3__/* .ParamConfig.INTEGER */ .XC.INTEGER(DEFAULT.cols, {
      range: [1, 100],
      rangeLocked: [true, false],
      visibleIf: VISIBLE_OPTIONS.HEIGHT_FIELD,
      expression: { forEntities: true }
    });
    /** @param density */
    this.density = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_3__/* .ParamConfig.FLOAT */ .XC.FLOAT(DEFAULT.density, {
      range: [0, 10],
      rangeLocked: [true, false],
      expression: { forEntities: true },
      separatorBefore: true
    });
    /** @param friction */
    this.friction = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_3__/* .ParamConfig.FLOAT */ .XC.FLOAT(DEFAULT.friction, {
      range: [0, 1],
      rangeLocked: [true, false],
      expression: { forEntities: true }
    });
    /** @param restitution */
    this.restitution = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_3__/* .ParamConfig.FLOAT */ .XC.FLOAT(DEFAULT.restitution, {
      range: [0, 2],
      rangeLocked: [true, false],
      expression: { forEntities: true }
    });
    /** @param linear damping (affects velocity) */
    this.linearDamping = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_3__/* .ParamConfig.FLOAT */ .XC.FLOAT(DEFAULT.linearDamping, {
      range: [0, 10],
      rangeLocked: [true, false],
      expression: { forEntities: true }
    });
    /** @param angular damping (affects rotations) */
    this.angularDamping = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_3__/* .ParamConfig.FLOAT */ .XC.FLOAT(DEFAULT.angularDamping, {
      range: [0, 10],
      rangeLocked: [true, false],
      expression: { forEntities: true }
    });
    /** @param linear velocity */
    this.linearVelocity = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_3__/* .ParamConfig.VECTOR3 */ .XC.VECTOR3(DEFAULT.linearVelocity, {
      expression: { forEntities: true }
    });
    /** @param angular velocity */
    this.angularVelocity = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_3__/* .ParamConfig.VECTOR3 */ .XC.VECTOR3(DEFAULT.angularVelocity, {
      expression: { forEntities: true }
    });
    /** @param gravity Scale */
    this.gravityScale = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_3__/* .ParamConfig.FLOAT */ .XC.FLOAT(DEFAULT.gravityScale, {
      range: [-10, 10],
      rangeLocked: [false, false],
      expression: { forEntities: true }
    });
    /** @param can sleep */
    this.canSleep = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_3__/* .ParamConfig.BOOLEAN */ .XC.BOOLEAN(DEFAULT.canSleep, {
      expression: { forEntities: true }
    });
    this.details = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_3__/* .ParamConfig.FOLDER */ .XC.FOLDER();
    /** @param add id */
    this.addId = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_3__/* .ParamConfig.BOOLEAN */ .XC.BOOLEAN(1);
    /** @param id */
    this.id = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_3__/* .ParamConfig.STRING */ .XC.STRING("`$OS`-`@objnum`", {
      visibleIf: { addId: true },
      expression: { forEntities: true }
    });
  }
}
const ParamsConfig = new PhysicsRBDAttributesSopParamsConfig();
class PhysicsRBDAttributesSopNode extends _Base__WEBPACK_IMPORTED_MODULE_4__/* .TypedSopNode */ .x {
  constructor() {
    super(...arguments);
    this.paramsConfig = ParamsConfig;
  }
  static type() {
    return _poly_registers_nodes_types_Sop__WEBPACK_IMPORTED_MODULE_5__/* .SopType.PHYSICS_RBD_ATTRIBUTES */ .aB.PHYSICS_RBD_ATTRIBUTES;
  }
  initializeNode() {
    this.io.inputs.setCount(0, 1);
    this.io.inputs.initInputsClonedState(_operations_sop_PhysicsRBDAttributes__WEBPACK_IMPORTED_MODULE_1__/* .PhysicsRBDAttributesSopOperation.INPUT_CLONED_STATE */ .fM.INPUT_CLONED_STATE);
  }
  setRBDType(RBDtype) {
    this.p.RBDType.set(_core_physics_PhysicsAttribute__WEBPACK_IMPORTED_MODULE_2__/* .PHYSICS_RBD_TYPES.indexOf */ .LL.indexOf(RBDtype));
  }
  RBDType() {
    return _core_physics_PhysicsAttribute__WEBPACK_IMPORTED_MODULE_2__/* .PHYSICS_RBD_TYPES */ .LL[this.pv.RBDType];
  }
  setColliderType(colliderType) {
    this.p.colliderType.set(_core_physics_PhysicsAttribute__WEBPACK_IMPORTED_MODULE_2__/* .PHYSICS_RBD_COLLIDER_TYPES.indexOf */ .EX.indexOf(colliderType));
  }
  colliderType() {
    return _core_physics_PhysicsAttribute__WEBPACK_IMPORTED_MODULE_2__/* .PHYSICS_RBD_COLLIDER_TYPES */ .EX[this.pv.colliderType];
  }
  setSizeMethod(sizeMethod) {
    this.p.sizeMethod.set(_operations_sop_PhysicsRBDAttributes__WEBPACK_IMPORTED_MODULE_1__/* .SIZE_COMPUTATION_METHODS.indexOf */ ._K.indexOf(sizeMethod));
  }
  sizeMethod() {
    return _operations_sop_PhysicsRBDAttributes__WEBPACK_IMPORTED_MODULE_1__/* .SIZE_COMPUTATION_METHODS */ ._K[this.pv.sizeMethod];
  }
  cook(inputCoreGroups) {
    return __async(this, null, function* () {
      const coreGroup = inputCoreGroups[0];
      const RBDType = this.RBDType();
      const colliderType = this.colliderType();
      const sizeMethod = this.sizeMethod();
      const coreObjects = coreGroup.allCoreObjects();
      for (const coreObject of coreObjects) {
        _core_physics_PhysicsAttribute__WEBPACK_IMPORTED_MODULE_2__/* .CorePhysicsAttribute.setRBDType */ .gy.setRBDType(coreObject.object(), RBDType);
        _core_physics_PhysicsAttribute__WEBPACK_IMPORTED_MODULE_2__/* .CorePhysicsAttribute.setColliderType */ .gy.setColliderType(coreObject.object(), colliderType);
      }
      const promises = [];
      this._applyColliderType(colliderType, sizeMethod, coreObjects, promises);
      if (BORDER_RADIUS_AVAILABLE.includes(colliderType)) {
        promises.push(
          this._computeNumberParam(
            this.p.borderRadius,
            coreObjects,
            _core_physics_PhysicsAttribute__WEBPACK_IMPORTED_MODULE_2__/* .CorePhysicsAttribute.setBorderRadius.bind */ .gy.setBorderRadius.bind(_core_physics_PhysicsAttribute__WEBPACK_IMPORTED_MODULE_2__/* .CorePhysicsAttribute */ .gy)
          )
        );
      }
      promises.push(
        this._computeNumberParam(
          this.p.density,
          coreObjects,
          _core_physics_PhysicsAttribute__WEBPACK_IMPORTED_MODULE_2__/* .CorePhysicsAttribute.setDensity.bind */ .gy.setDensity.bind(_core_physics_PhysicsAttribute__WEBPACK_IMPORTED_MODULE_2__/* .CorePhysicsAttribute */ .gy)
        )
      );
      promises.push(
        this._computeNumberParam(
          this.p.friction,
          coreObjects,
          _core_physics_PhysicsAttribute__WEBPACK_IMPORTED_MODULE_2__/* .CorePhysicsAttribute.setFriction.bind */ .gy.setFriction.bind(_core_physics_PhysicsAttribute__WEBPACK_IMPORTED_MODULE_2__/* .CorePhysicsAttribute */ .gy)
        )
      );
      promises.push(
        this._computeNumberParam(
          this.p.linearDamping,
          coreObjects,
          _core_physics_PhysicsAttribute__WEBPACK_IMPORTED_MODULE_2__/* .CorePhysicsAttribute.setLinearDamping.bind */ .gy.setLinearDamping.bind(_core_physics_PhysicsAttribute__WEBPACK_IMPORTED_MODULE_2__/* .CorePhysicsAttribute */ .gy)
        )
      );
      promises.push(
        this._computeNumberParam(
          this.p.angularDamping,
          coreObjects,
          _core_physics_PhysicsAttribute__WEBPACK_IMPORTED_MODULE_2__/* .CorePhysicsAttribute.setAngularDamping.bind */ .gy.setAngularDamping.bind(_core_physics_PhysicsAttribute__WEBPACK_IMPORTED_MODULE_2__/* .CorePhysicsAttribute */ .gy)
        )
      );
      promises.push(
        this._computeVector3Param(
          this.p.linearVelocity,
          coreObjects,
          _core_physics_PhysicsAttribute__WEBPACK_IMPORTED_MODULE_2__/* .CorePhysicsAttribute.setLinearVelocity.bind */ .gy.setLinearVelocity.bind(_core_physics_PhysicsAttribute__WEBPACK_IMPORTED_MODULE_2__/* .CorePhysicsAttribute */ .gy)
        )
      );
      promises.push(
        this._computeVector3Param(
          this.p.angularVelocity,
          coreObjects,
          _core_physics_PhysicsAttribute__WEBPACK_IMPORTED_MODULE_2__/* .CorePhysicsAttribute.setAngularVelocity.bind */ .gy.setAngularVelocity.bind(_core_physics_PhysicsAttribute__WEBPACK_IMPORTED_MODULE_2__/* .CorePhysicsAttribute */ .gy)
        )
      );
      promises.push(
        this._computeNumberParam(
          this.p.gravityScale,
          coreObjects,
          _core_physics_PhysicsAttribute__WEBPACK_IMPORTED_MODULE_2__/* .CorePhysicsAttribute.setGravityScale.bind */ .gy.setGravityScale.bind(_core_physics_PhysicsAttribute__WEBPACK_IMPORTED_MODULE_2__/* .CorePhysicsAttribute */ .gy)
        )
      );
      promises.push(
        this._computeNumberParam(
          this.p.restitution,
          coreObjects,
          _core_physics_PhysicsAttribute__WEBPACK_IMPORTED_MODULE_2__/* .CorePhysicsAttribute.setRestitution.bind */ .gy.setRestitution.bind(_core_physics_PhysicsAttribute__WEBPACK_IMPORTED_MODULE_2__/* .CorePhysicsAttribute */ .gy)
        )
      );
      promises.push(
        this._computeBooleanParam(
          this.p.canSleep,
          coreObjects,
          _core_physics_PhysicsAttribute__WEBPACK_IMPORTED_MODULE_2__/* .CorePhysicsAttribute.setCanSleep.bind */ .gy.setCanSleep.bind(_core_physics_PhysicsAttribute__WEBPACK_IMPORTED_MODULE_2__/* .CorePhysicsAttribute */ .gy)
        )
      );
      if ((0,_core_Type__WEBPACK_IMPORTED_MODULE_6__/* .isBooleanTrue */ .bI)(this.pv.addId)) {
        promises.push(
          this._computeStringParam(
            this.p.id,
            coreObjects,
            _core_physics_PhysicsAttribute__WEBPACK_IMPORTED_MODULE_2__/* .CorePhysicsAttribute.setRBDId.bind */ .gy.setRBDId.bind(_core_physics_PhysicsAttribute__WEBPACK_IMPORTED_MODULE_2__/* .CorePhysicsAttribute */ .gy)
          )
        );
      }
      yield Promise.all(promises);
      this.setCoreGroup(coreGroup);
    });
  }
  _applyColliderType(colliderType, sizeMethod, coreObjects, promises) {
    switch (colliderType) {
      case _core_physics_PhysicsAttribute__WEBPACK_IMPORTED_MODULE_2__/* .PhysicsRBDColliderType.CUBOID */ .bs.CUBOID: {
        switch (sizeMethod) {
          case _operations_sop_PhysicsRBDAttributes__WEBPACK_IMPORTED_MODULE_1__/* .SizeComputationMethod.AUTO */ .qc.AUTO: {
            for (const coreObject of coreObjects) {
              coreObject.geometryBoundingBox(tmpBox);
              tmpBox.getSize(tmpV3);
              _core_physics_PhysicsAttribute__WEBPACK_IMPORTED_MODULE_2__/* .CorePhysicsAttribute.setCuboidSizes */ .gy.setCuboidSizes(coreObject.object(), tmpV3);
              _core_physics_PhysicsAttribute__WEBPACK_IMPORTED_MODULE_2__/* .CorePhysicsAttribute.setCuboidSize */ .gy.setCuboidSize(coreObject.object(), 1);
            }
            return;
          }
          case _operations_sop_PhysicsRBDAttributes__WEBPACK_IMPORTED_MODULE_1__/* .SizeComputationMethod.MANUAL */ .qc.MANUAL: {
            promises.push(
              this._computeVector3Param(
                this.p.sizes,
                coreObjects,
                _core_physics_PhysicsAttribute__WEBPACK_IMPORTED_MODULE_2__/* .CorePhysicsAttribute.setCuboidSizes.bind */ .gy.setCuboidSizes.bind(_core_physics_PhysicsAttribute__WEBPACK_IMPORTED_MODULE_2__/* .CorePhysicsAttribute */ .gy)
              )
            );
            promises.push(
              this._computeNumberParam(
                this.p.size,
                coreObjects,
                _core_physics_PhysicsAttribute__WEBPACK_IMPORTED_MODULE_2__/* .CorePhysicsAttribute.setCuboidSize.bind */ .gy.setCuboidSize.bind(_core_physics_PhysicsAttribute__WEBPACK_IMPORTED_MODULE_2__/* .CorePhysicsAttribute */ .gy)
              )
            );
            return;
          }
        }
        return;
      }
      case _core_physics_PhysicsAttribute__WEBPACK_IMPORTED_MODULE_2__/* .PhysicsRBDColliderType.SPHERE */ .bs.SPHERE: {
        switch (sizeMethod) {
          case _operations_sop_PhysicsRBDAttributes__WEBPACK_IMPORTED_MODULE_1__/* .SizeComputationMethod.AUTO */ .qc.AUTO: {
            for (const coreObject of coreObjects) {
              coreObject.geometryBoundingSphere(tmpSphere);
              const radius = tmpSphere.radius;
              _core_physics_PhysicsAttribute__WEBPACK_IMPORTED_MODULE_2__/* .CorePhysicsAttribute.setRadius */ .gy.setRadius(coreObject.object(), radius);
            }
            return;
          }
          case _operations_sop_PhysicsRBDAttributes__WEBPACK_IMPORTED_MODULE_1__/* .SizeComputationMethod.MANUAL */ .qc.MANUAL: {
            promises.push(
              this._computeNumberParam(
                this.p.radius,
                coreObjects,
                _core_physics_PhysicsAttribute__WEBPACK_IMPORTED_MODULE_2__/* .CorePhysicsAttribute.setRadius.bind */ .gy.setRadius.bind(_core_physics_PhysicsAttribute__WEBPACK_IMPORTED_MODULE_2__/* .CorePhysicsAttribute */ .gy)
              )
            );
            return;
          }
        }
        return;
      }
      case _core_physics_PhysicsAttribute__WEBPACK_IMPORTED_MODULE_2__/* .PhysicsRBDColliderType.CAPSULE */ .bs.CAPSULE: {
        switch (sizeMethod) {
          case _operations_sop_PhysicsRBDAttributes__WEBPACK_IMPORTED_MODULE_1__/* .SizeComputationMethod.AUTO */ .qc.AUTO: {
            for (const coreObject of coreObjects) {
              coreObject.geometryBoundingBox(tmpBox);
              tmpBox.getSize(tmpV3);
              const radius = 0.5 * tmpV3.x;
              const height = tmpV3.y - 2 * radius;
              _core_physics_PhysicsAttribute__WEBPACK_IMPORTED_MODULE_2__/* .CorePhysicsAttribute.setHeight */ .gy.setHeight(coreObject.object(), height);
              _core_physics_PhysicsAttribute__WEBPACK_IMPORTED_MODULE_2__/* .CorePhysicsAttribute.setRadius */ .gy.setRadius(coreObject.object(), radius);
            }
            return;
          }
          case _operations_sop_PhysicsRBDAttributes__WEBPACK_IMPORTED_MODULE_1__/* .SizeComputationMethod.MANUAL */ .qc.MANUAL: {
            promises.push(
              this._computeNumberParam(
                this.p.height,
                coreObjects,
                _core_physics_PhysicsAttribute__WEBPACK_IMPORTED_MODULE_2__/* .CorePhysicsAttribute.setHeight.bind */ .gy.setHeight.bind(_core_physics_PhysicsAttribute__WEBPACK_IMPORTED_MODULE_2__/* .CorePhysicsAttribute */ .gy)
              )
            );
            promises.push(
              this._computeNumberParam(
                this.p.radius,
                coreObjects,
                _core_physics_PhysicsAttribute__WEBPACK_IMPORTED_MODULE_2__/* .CorePhysicsAttribute.setRadius.bind */ .gy.setRadius.bind(_core_physics_PhysicsAttribute__WEBPACK_IMPORTED_MODULE_2__/* .CorePhysicsAttribute */ .gy)
              )
            );
            return;
          }
        }
        return;
      }
      case _core_physics_PhysicsAttribute__WEBPACK_IMPORTED_MODULE_2__/* .PhysicsRBDColliderType.CONE */ .bs.CONE:
      case _core_physics_PhysicsAttribute__WEBPACK_IMPORTED_MODULE_2__/* .PhysicsRBDColliderType.CYLINDER */ .bs.CYLINDER: {
        switch (sizeMethod) {
          case _operations_sop_PhysicsRBDAttributes__WEBPACK_IMPORTED_MODULE_1__/* .SizeComputationMethod.AUTO */ .qc.AUTO: {
            for (const coreObject of coreObjects) {
              coreObject.geometryBoundingBox(tmpBox);
              tmpBox.getSize(tmpV3);
              _core_physics_PhysicsAttribute__WEBPACK_IMPORTED_MODULE_2__/* .CorePhysicsAttribute.setHeight */ .gy.setHeight(coreObject.object(), tmpV3.y);
              _core_physics_PhysicsAttribute__WEBPACK_IMPORTED_MODULE_2__/* .CorePhysicsAttribute.setRadius */ .gy.setRadius(coreObject.object(), 0.5 * tmpV3.x);
            }
            return;
          }
          case _operations_sop_PhysicsRBDAttributes__WEBPACK_IMPORTED_MODULE_1__/* .SizeComputationMethod.MANUAL */ .qc.MANUAL: {
            promises.push(
              this._computeNumberParam(
                this.p.height,
                coreObjects,
                _core_physics_PhysicsAttribute__WEBPACK_IMPORTED_MODULE_2__/* .CorePhysicsAttribute.setHeight.bind */ .gy.setHeight.bind(_core_physics_PhysicsAttribute__WEBPACK_IMPORTED_MODULE_2__/* .CorePhysicsAttribute */ .gy)
              )
            );
            promises.push(
              this._computeNumberParam(
                this.p.radius,
                coreObjects,
                _core_physics_PhysicsAttribute__WEBPACK_IMPORTED_MODULE_2__/* .CorePhysicsAttribute.setRadius.bind */ .gy.setRadius.bind(_core_physics_PhysicsAttribute__WEBPACK_IMPORTED_MODULE_2__/* .CorePhysicsAttribute */ .gy)
              )
            );
            return;
          }
        }
        return;
      }
      case _core_physics_PhysicsAttribute__WEBPACK_IMPORTED_MODULE_2__/* .PhysicsRBDColliderType.HEIGHT_FIELD */ .bs.HEIGHT_FIELD: {
        promises.push(
          this._computeNumberParam(
            this.p.rows,
            coreObjects,
            _core_physics_PhysicsAttribute__WEBPACK_IMPORTED_MODULE_2__/* .CorePhysicsAttribute.setHeightFieldRows.bind */ .gy.setHeightFieldRows.bind(_core_physics_PhysicsAttribute__WEBPACK_IMPORTED_MODULE_2__/* .CorePhysicsAttribute */ .gy)
          )
        );
        promises.push(
          this._computeNumberParam(
            this.p.cols,
            coreObjects,
            _core_physics_PhysicsAttribute__WEBPACK_IMPORTED_MODULE_2__/* .CorePhysicsAttribute.setHeightFieldCols.bind */ .gy.setHeightFieldCols.bind(_core_physics_PhysicsAttribute__WEBPACK_IMPORTED_MODULE_2__/* .CorePhysicsAttribute */ .gy)
          )
        );
        return;
      }
      case _core_physics_PhysicsAttribute__WEBPACK_IMPORTED_MODULE_2__/* .PhysicsRBDColliderType.CONVEX_HULL */ .bs.CONVEX_HULL:
      case _core_physics_PhysicsAttribute__WEBPACK_IMPORTED_MODULE_2__/* .PhysicsRBDColliderType.TRIMESH */ .bs.TRIMESH: {
        return;
      }
    }
    _poly_Assert__WEBPACK_IMPORTED_MODULE_7__/* .TypeAssert.unreachable */ .f.unreachable(colliderType);
  }
  _computeStringParam(param, coreObjects, applyMethod) {
    return __async(this, null, function* () {
      if (param.expressionController && param.expressionController.entitiesDependent()) {
        yield param.expressionController.computeExpressionForObjects(coreObjects, (coreObject, value) => {
          applyMethod(coreObject.object(), value);
        });
      } else {
        for (const coreObject of coreObjects) {
          applyMethod(coreObject.object(), param.value);
        }
      }
    });
  }
  _computeVector3Param(vectorParam, coreObjects, applyMethod) {
    return __async(this, null, function* () {
      const components = vectorParam.components;
      const valuesByCoreObjectIndex = /* @__PURE__ */ new Map();
      for (const coreObject of coreObjects) {
        valuesByCoreObjectIndex.set(coreObject.index(), new three__WEBPACK_IMPORTED_MODULE_0__.Vector3());
      }
      for (let componentIndex = 0; componentIndex < components.length; componentIndex++) {
        const component_param = components[componentIndex];
        const component_name = VECTOR3_COMPONENT_NAMES[componentIndex];
        if (component_param.hasExpression() && component_param.expressionController && component_param.expressionController.entitiesDependent()) {
          yield component_param.expressionController.computeExpressionForObjects(
            coreObjects,
            (coreObject, value) => {
              const vector = valuesByCoreObjectIndex.get(coreObject.index());
              if (vector) {
                vector[component_name] = value;
              }
            }
          );
        } else {
          for (const coreObject of coreObjects) {
            const vector = valuesByCoreObjectIndex.get(coreObject.index());
            if (vector) {
              vector[component_name] = component_param.value;
            }
          }
        }
      }
      for (let i = 0; i < coreObjects.length; i++) {
        const coreObject = coreObjects[i];
        const value = valuesByCoreObjectIndex.get(coreObject.index());
        if (value != null) {
          applyMethod(coreObject.object(), value);
        }
      }
    });
  }
  _computeNumberParam(param, coreObjects, applyMethod) {
    return __async(this, null, function* () {
      if (param.expressionController && param.expressionController.entitiesDependent()) {
        yield param.expressionController.computeExpressionForObjects(coreObjects, (coreObject, value) => {
          applyMethod(coreObject.object(), value);
        });
      } else {
        for (const coreObject of coreObjects) {
          applyMethod(coreObject.object(), param.value);
        }
      }
    });
  }
  _computeBooleanParam(param, coreObjects, applyMethod) {
    return __async(this, null, function* () {
      if (param.expressionController && param.expressionController.entitiesDependent()) {
        yield param.expressionController.computeExpressionForObjects(coreObjects, (coreObject, value) => {
          applyMethod(coreObject.object(), value);
        });
      } else {
        for (const coreObject of coreObjects) {
          applyMethod(coreObject.object(), param.value);
        }
      }
    });
  }
}


/***/ }),

/***/ 13070:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "D": function() { return /* binding */ PhysicsRBDJointsSopNode; }
/* harmony export */ });
/* harmony import */ var _core_physics_PhysicsJoint__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(82637);
/* harmony import */ var _core_physics_PhysicsAttribute__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(36911);
/* harmony import */ var _Base__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(55839);
/* harmony import */ var _core_MapUtils__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(94158);
/* harmony import */ var _core_Type__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(19037);
/* harmony import */ var _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(96949);
/* harmony import */ var _poly_InputCloneMode__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(56752);
/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(21410);
/* harmony import */ var _core_geometry_Mask__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(58290);
/* harmony import */ var _poly_registers_nodes_types_Sop__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(58986);











const center = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();
const tmpV3_1 = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();
const tmpV3_2 = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();
const tmpQuat = new three__WEBPACK_IMPORTED_MODULE_0__.Quaternion();
const frame1 = new three__WEBPACK_IMPORTED_MODULE_0__.Vector4();
const frame2 = new three__WEBPACK_IMPORTED_MODULE_0__.Vector4();
const axis = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();
const bbox = new three__WEBPACK_IMPORTED_MODULE_0__.Box3();
const _mat = new three__WEBPACK_IMPORTED_MODULE_0__.Matrix4();
function quaternionToVector4(quaternion, target) {
  target.x = quaternion.x;
  target.y = quaternion.y;
  target.z = quaternion.z;
  target.w = quaternion.w;
}
const checkedPair = /* @__PURE__ */ new Map();
const jointsCountByKey = /* @__PURE__ */ new Map();
class PhysicsRBDJointsSopParamsConfig extends _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .NodeParamsConfig */ .yI {
  constructor() {
    super(...arguments);
    /** @param group to assign the material to */
    this.group = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .ParamConfig.STRING */ .XC.STRING("", {
      objectMask: true
    });
    /** @param maxDistance */
    this.maxDistance = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .ParamConfig.FLOAT */ .XC.FLOAT(1, {
      range: [0, 10]
    });
    /** @param max number of joints per object */
    this.maxJointsCount = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .ParamConfig.INTEGER */ .XC.INTEGER(2, {
      range: [0, 10]
    });
    /** @param joint type */
    this.jointType = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .ParamConfig.INTEGER */ .XC.INTEGER(_core_physics_PhysicsJoint__WEBPACK_IMPORTED_MODULE_2__/* .PHYSICS_JOINT_TYPES.indexOf */ .NV.indexOf(_core_physics_PhysicsJoint__WEBPACK_IMPORTED_MODULE_2__/* .PhysicsJointType.SPHERICAL */ .Zs.SPHERICAL), {
      menu: {
        entries: _core_physics_PhysicsJoint__WEBPACK_IMPORTED_MODULE_2__/* .PHYSICS_JOINT_TYPE_MENU_ENTRIES */ .ff
      }
    });
    /** @param limit */
    this.limit = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .ParamConfig.VECTOR2 */ .XC.VECTOR2([-1, 1], {
      separatorBefore: true,
      visibleIf: [
        {
          jointType: _core_physics_PhysicsJoint__WEBPACK_IMPORTED_MODULE_2__/* .PHYSICS_JOINT_TYPES.indexOf */ .NV.indexOf(_core_physics_PhysicsJoint__WEBPACK_IMPORTED_MODULE_2__/* .PhysicsJointType.REVOLUT */ .Zs.REVOLUT)
        },
        {
          jointType: _core_physics_PhysicsJoint__WEBPACK_IMPORTED_MODULE_2__/* .PHYSICS_JOINT_TYPES.indexOf */ .NV.indexOf(_core_physics_PhysicsJoint__WEBPACK_IMPORTED_MODULE_2__/* .PhysicsJointType.PRISMATIC */ .Zs.PRISMATIC)
        }
      ]
    });
    /** @param up */
    this.up = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .ParamConfig.VECTOR3 */ .XC.VECTOR3([0, 1, 0], {
      visibleIf: [
        {
          jointType: _core_physics_PhysicsJoint__WEBPACK_IMPORTED_MODULE_2__/* .PHYSICS_JOINT_TYPES.indexOf */ .NV.indexOf(_core_physics_PhysicsJoint__WEBPACK_IMPORTED_MODULE_2__/* .PhysicsJointType.REVOLUT */ .Zs.REVOLUT)
        }
      ]
    });
    /** @param center */
    this.center = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .ParamConfig.FLOAT */ .XC.FLOAT(0.5, {
      separatorBefore: true,
      visibleIf: [
        {
          jointType: _core_physics_PhysicsJoint__WEBPACK_IMPORTED_MODULE_2__/* .PHYSICS_JOINT_TYPES.indexOf */ .NV.indexOf(_core_physics_PhysicsJoint__WEBPACK_IMPORTED_MODULE_2__/* .PhysicsJointType.SPHERICAL */ .Zs.SPHERICAL)
        },
        {
          jointType: _core_physics_PhysicsJoint__WEBPACK_IMPORTED_MODULE_2__/* .PHYSICS_JOINT_TYPES.indexOf */ .NV.indexOf(_core_physics_PhysicsJoint__WEBPACK_IMPORTED_MODULE_2__/* .PhysicsJointType.REVOLUT */ .Zs.REVOLUT)
        }
      ]
    });
    /** @param anchors at objects center */
    this.anchorsAtCenter = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .ParamConfig.BOOLEAN */ .XC.BOOLEAN(1, {});
    /** @param anchor position 1 */
    this.anchorsPos1 = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .ParamConfig.VECTOR3 */ .XC.VECTOR3([0.5, 0.5, 0.5], {
      visibleIf: { anchorsAtCenter: 0 }
    });
    /** @param anchor position 2 */
    this.anchorsPos2 = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .ParamConfig.VECTOR3 */ .XC.VECTOR3([0.5, 0.5, 0.5], {
      visibleIf: { anchorsAtCenter: 0 }
    });
    /** @param do not output input RBDs with joints */
    this.ouputsJointsOnly = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .ParamConfig.BOOLEAN */ .XC.BOOLEAN(0, {
      separatorBefore: true
    });
  }
}
const ParamsConfig = new PhysicsRBDJointsSopParamsConfig();
class PhysicsRBDJointsSopNode extends _Base__WEBPACK_IMPORTED_MODULE_3__/* .TypedSopNode */ .x {
  constructor() {
    super(...arguments);
    this.paramsConfig = ParamsConfig;
  }
  static type() {
    return _poly_registers_nodes_types_Sop__WEBPACK_IMPORTED_MODULE_4__/* .SopType.PHYSICS_RBD_JOINTS */ .aB.PHYSICS_RBD_JOINTS;
  }
  initializeNode() {
    this.io.inputs.setCount(1);
    this.io.inputs.initInputsClonedState(_poly_InputCloneMode__WEBPACK_IMPORTED_MODULE_5__/* .InputCloneMode.FROM_NODE */ .m.FROM_NODE);
  }
  setJointType(RBDtype) {
    this.p.jointType.set(_core_physics_PhysicsJoint__WEBPACK_IMPORTED_MODULE_2__/* .PHYSICS_JOINT_TYPES.indexOf */ .NV.indexOf(RBDtype));
  }
  jointType() {
    return _core_physics_PhysicsJoint__WEBPACK_IMPORTED_MODULE_2__/* .PHYSICS_JOINT_TYPES */ .NV[this.pv.jointType];
  }
  cook(inputCoreGroups) {
    const coreGroup = inputCoreGroups[0];
    const inputObjects = coreGroup.allObjects();
    const selectedObjects = _core_geometry_Mask__WEBPACK_IMPORTED_MODULE_6__/* .CoreMask.filterThreejsObjects */ .x0.filterThreejsObjects(coreGroup, this.pv);
    const candidateObjects = selectedObjects.filter((object) => _core_physics_PhysicsAttribute__WEBPACK_IMPORTED_MODULE_7__/* .CorePhysicsAttribute.getRBDId */ .gy.getRBDId(object) != null);
    const joinObjects = [];
    const maxDistance = this.pv.maxDistance;
    const maxJointsCount = this.pv.maxJointsCount;
    checkedPair.clear();
    jointsCountByKey.clear();
    let maxJointsCountReached = false;
    let maxJointsCountReached1 = false;
    let maxJointsCountReached2 = false;
    let jointsCount1;
    let jointsCount2;
    let jointIndex = 0;
    let existingSet;
    for (let i1 = 0; i1 < candidateObjects.length; i1++) {
      const object1 = candidateObjects[i1];
      for (let i2 = 0; i2 < candidateObjects.length; i2++) {
        const object2 = candidateObjects[i2];
        if (i1 != i2) {
          jointsCount1 = jointsCountByKey.get(i1);
          jointsCount2 = jointsCountByKey.get(i2);
          maxJointsCountReached1 = jointsCount1 != null && jointsCount1 >= maxJointsCount;
          maxJointsCountReached2 = jointsCount2 != null && jointsCount2 >= maxJointsCount;
          maxJointsCountReached = maxJointsCountReached1 || maxJointsCountReached2;
          if (!maxJointsCountReached) {
            if (object1.position.distanceTo(object2.position) < maxDistance) {
              let key = i1 < i2 ? i1 : i2;
              let idInSet = i1 < i2 ? i2 : i1;
              existingSet = checkedPair.get(key);
              if (existingSet == null || !existingSet.has(idInSet)) {
                _core_MapUtils__WEBPACK_IMPORTED_MODULE_8__/* .MapUtils.addToSetAtEntry */ .pl.addToSetAtEntry(checkedPair, key, idInSet);
                const jointObject = this._createJoint(object1, object2);
                jointObject.name = `${this.name()}_${jointIndex}`;
                jointIndex++;
                joinObjects.push(jointObject);
                _core_MapUtils__WEBPACK_IMPORTED_MODULE_8__/* .MapUtils.incrementAtEntry */ .pl.incrementAtEntry(jointsCountByKey, i1, 0);
                _core_MapUtils__WEBPACK_IMPORTED_MODULE_8__/* .MapUtils.incrementAtEntry */ .pl.incrementAtEntry(jointsCountByKey, i2, 0);
              }
            }
          }
        }
      }
    }
    const allObjects = (0,_core_Type__WEBPACK_IMPORTED_MODULE_9__/* .isBooleanTrue */ .bI)(this.pv.ouputsJointsOnly) ? joinObjects : [...inputObjects, ...joinObjects];
    this.setObjects(allObjects);
  }
  _createJoint(object1, object2) {
    const group = new three__WEBPACK_IMPORTED_MODULE_0__.Group();
    group.matrixAutoUpdate = false;
    _core_physics_PhysicsJoint__WEBPACK_IMPORTED_MODULE_2__/* .CorePhysicsJoinAttribute.setRBDId1 */ .wU.setRBDId1(group, _core_physics_PhysicsAttribute__WEBPACK_IMPORTED_MODULE_7__/* .CorePhysicsAttribute.getRBDId */ .gy.getRBDId(object1));
    _core_physics_PhysicsJoint__WEBPACK_IMPORTED_MODULE_2__/* .CorePhysicsJoinAttribute.setRBDId2 */ .wU.setRBDId2(group, _core_physics_PhysicsAttribute__WEBPACK_IMPORTED_MODULE_7__/* .CorePhysicsAttribute.getRBDId */ .gy.getRBDId(object2));
    const getAnchorPos = (object, paramValue, target) => {
      object.updateMatrix();
      if ((0,_core_Type__WEBPACK_IMPORTED_MODULE_9__/* .isBooleanTrue */ .bI)(this.pv.anchorsAtCenter)) {
        target.set(0, 0, 0);
        target.applyMatrix4(object.matrix);
      } else {
        _mat.copy(object.matrix);
        object.matrix.identity();
        bbox.setFromObject(object);
        target.x = paramValue.x * bbox.max.x + (1 - paramValue.x) * bbox.min.x;
        target.y = paramValue.y * bbox.max.y + (1 - paramValue.y) * bbox.min.y;
        target.z = paramValue.z * bbox.max.z + (1 - paramValue.z) * bbox.min.z;
        object.matrix.copy(_mat);
        target.applyMatrix4(object.matrix);
      }
    };
    getAnchorPos(object1, this.pv.anchorsPos1, tmpV3_1);
    getAnchorPos(object2, this.pv.anchorsPos2, tmpV3_2);
    center.copy(tmpV3_1).lerp(tmpV3_2, this.pv.center);
    axis.copy(tmpV3_2).sub(tmpV3_1).normalize();
    const makeLocal = (object, target) => {
      _mat.copy(object.matrix).invert();
      target.copy(center);
      target.applyMatrix4(_mat);
    };
    makeLocal(object1, tmpV3_1);
    makeLocal(object2, tmpV3_2);
    _core_physics_PhysicsJoint__WEBPACK_IMPORTED_MODULE_2__/* .CorePhysicsJoinAttribute.setAnchor1 */ .wU.setAnchor1(group, tmpV3_1);
    _core_physics_PhysicsJoint__WEBPACK_IMPORTED_MODULE_2__/* .CorePhysicsJoinAttribute.setAnchor2 */ .wU.setAnchor2(group, tmpV3_2);
    const jointType = this.jointType();
    _core_physics_PhysicsJoint__WEBPACK_IMPORTED_MODULE_2__/* .CorePhysicsJoinAttribute.setJoinType */ .wU.setJoinType(group, jointType);
    switch (jointType) {
      case _core_physics_PhysicsJoint__WEBPACK_IMPORTED_MODULE_2__/* .PhysicsJointType.FIXED */ .Zs.FIXED: {
        tmpQuat.copy(object1.quaternion);
        tmpQuat.slerp(object2.quaternion, 0.5);
        tmpQuat.invert();
        quaternionToVector4(tmpQuat, frame1);
        tmpQuat.copy(object2.quaternion);
        tmpQuat.slerp(object1.quaternion, 0.5);
        tmpQuat.invert();
        quaternionToVector4(tmpQuat, frame2);
        _core_physics_PhysicsJoint__WEBPACK_IMPORTED_MODULE_2__/* .CorePhysicsJoinAttribute.setFrame1 */ .wU.setFrame1(group, frame1);
        _core_physics_PhysicsJoint__WEBPACK_IMPORTED_MODULE_2__/* .CorePhysicsJoinAttribute.setFrame2 */ .wU.setFrame2(group, frame2);
        break;
      }
      case _core_physics_PhysicsJoint__WEBPACK_IMPORTED_MODULE_2__/* .PhysicsJointType.PRISMATIC */ .Zs.PRISMATIC: {
        _core_physics_PhysicsJoint__WEBPACK_IMPORTED_MODULE_2__/* .CorePhysicsJoinAttribute.setLimit */ .wU.setLimit(group, this.pv.limit);
        _core_physics_PhysicsJoint__WEBPACK_IMPORTED_MODULE_2__/* .CorePhysicsJoinAttribute.setAxis */ .wU.setAxis(group, axis);
        break;
      }
      case _core_physics_PhysicsJoint__WEBPACK_IMPORTED_MODULE_2__/* .PhysicsJointType.REVOLUT */ .Zs.REVOLUT: {
        _core_physics_PhysicsJoint__WEBPACK_IMPORTED_MODULE_2__/* .CorePhysicsJoinAttribute.setLimit */ .wU.setLimit(group, this.pv.limit);
        axis.cross(this.pv.up).normalize();
        _core_physics_PhysicsJoint__WEBPACK_IMPORTED_MODULE_2__/* .CorePhysicsJoinAttribute.setAxis */ .wU.setAxis(group, axis);
        break;
      }
    }
    return group;
  }
}


/***/ }),

/***/ 25898:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "A": function() { return /* binding */ getPhysicsWorldNodeFromWorldObject; },
/* harmony export */   "B": function() { return /* binding */ PhysicsWorldSopNode; }
/* harmony export */ });
/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(21410);
/* harmony import */ var _core_physics_PhysicsWorld__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(3338);
/* harmony import */ var _BaseActor__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(29540);
/* harmony import */ var _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(96949);
/* harmony import */ var _poly_NodeContext__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(52070);
/* harmony import */ var _poly_InputCloneMode__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(56752);
/* harmony import */ var _core_physics_PhysicsDebug__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(74458);
/* harmony import */ var _poly_registers_nodes_types_Sop__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(58986);
/* harmony import */ var _core_Type__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(19037);
/* harmony import */ var _Poly__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(99934);
/* harmony import */ var _core_geometry_modules_three_ThreejsCoreObject__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(2318);
/* harmony import */ var _core_physics_PhysicsAttribute__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(36911);
/* harmony import */ var _core_physics_CorePhysics__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(83260);
/* harmony import */ var _core_physics_PhysicsJoint__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(82637);

var __async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};















class PhysicsWorldSopParamsConfig extends _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_0__/* .NodeParamsConfig */ .yI {
  constructor() {
    super(...arguments);
    /** @param gravity */
    this.gravity = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_0__/* .ParamConfig.VECTOR3 */ .XC.VECTOR3(_core_physics_PhysicsWorld__WEBPACK_IMPORTED_MODULE_1__/* .PHYSICS_GRAVITY_DEFAULT */ .tB);
  }
  /** @param display debug information */
  // debug = ParamConfig.BOOLEAN(0);
  /** @param actor node */
  // node = ParamConfig.NODE_PATH('', {
  // 	visibleIf: {useThisNode: 0},
  // 	// nodeSelection: {
  // 	// 	// context: NodeContext.ACTOR,
  // 	// },
  // 	dependentOnFoundNode: false,
  // });
}
const ParamsConfig = new PhysicsWorldSopParamsConfig();
class PhysicsWorldSopNode extends _BaseActor__WEBPACK_IMPORTED_MODULE_2__/* .TypedActorSopNode */ .p {
  constructor() {
    super(...arguments);
    this.paramsConfig = ParamsConfig;
  }
  static type() {
    return _poly_registers_nodes_types_Sop__WEBPACK_IMPORTED_MODULE_3__/* .SopType.PHYSICS_WORLD */ .aB.PHYSICS_WORLD;
  }
  initializeNode() {
    this.io.inputs.setCount(1);
    this.io.inputs.initInputsClonedState(_poly_InputCloneMode__WEBPACK_IMPORTED_MODULE_4__/* .InputCloneMode.ALWAYS */ .m.ALWAYS);
  }
  cook(inputCoreGroups) {
    return __async(this, null, function* () {
      this.compilationController.compileIfRequired();
      yield (0,_core_physics_CorePhysics__WEBPACK_IMPORTED_MODULE_5__/* .CorePhysics */ .a)();
      const coreGroup = inputCoreGroups[0];
      const worldObject = new three__WEBPACK_IMPORTED_MODULE_6__.Group();
      worldObject.name = this.name();
      worldObject.matrixAutoUpdate = false;
      _Poly__WEBPACK_IMPORTED_MODULE_7__/* .Poly.onObjectsAddRemoveHooks.assignOnAddHookHandler */ .L.onObjectsAddRemoveHooks.assignOnAddHookHandler(worldObject, this);
      _core_geometry_modules_three_ThreejsCoreObject__WEBPACK_IMPORTED_MODULE_8__/* .ThreejsCoreObject.addAttribute */ .W.addAttribute(worldObject, _core_physics_PhysicsAttribute__WEBPACK_IMPORTED_MODULE_9__/* .PhysicsIdAttribute.WORLD */ .m3.WORLD, this.graphNodeId());
      const inputObjects = coreGroup.threejsObjects();
      for (const inputObject of inputObjects) {
        worldObject.add(inputObject);
      }
      (0,_core_physics_PhysicsJoint__WEBPACK_IMPORTED_MODULE_10__/* .setJointDataListForWorldObject */ .Vv)(this.scene(), worldObject);
      const actorNode = this._findActorNode();
      this.scene().actorsManager.assignActorBuilder(worldObject, actorNode);
      this.setObject(worldObject);
    });
  }
  updateObjectOnAdd(object) {
    const worldNodeId = _core_geometry_modules_three_ThreejsCoreObject__WEBPACK_IMPORTED_MODULE_8__/* .ThreejsCoreObject.attribValue */ .W.attribValue(object, _core_physics_PhysicsAttribute__WEBPACK_IMPORTED_MODULE_9__/* .PhysicsIdAttribute.WORLD */ .m3.WORLD);
    if (worldNodeId != null) {
      if (worldNodeId != this.graphNodeId()) {
        return;
      }
      const worldObject = object;
      (0,_core_physics_PhysicsWorld__WEBPACK_IMPORTED_MODULE_1__/* .createOrFindPhysicsWorld */ .NG)(this, worldObject, this.pv.gravity).then(({ world, PhysicsLib }) => {
        var _a;
        (0,_core_physics_PhysicsWorld__WEBPACK_IMPORTED_MODULE_1__/* .initCorePhysicsWorld */ .bN)(PhysicsLib, worldObject, this.scene());
        const sibblings = (_a = worldObject.parent) == null ? void 0 : _a.children.filter((sibbling) => sibbling.uuid != worldObject.uuid);
        if (!sibblings) {
          return;
        }
        const debugObject = sibblings.find(
          (sibbling) => _core_geometry_modules_three_ThreejsCoreObject__WEBPACK_IMPORTED_MODULE_8__/* .ThreejsCoreObject.attribValue */ .W.attribValue(sibbling, _core_physics_PhysicsAttribute__WEBPACK_IMPORTED_MODULE_9__/* .PhysicsIdAttribute.DEBUG_WORLD */ .m3.DEBUG_WORLD) == worldNodeId
          //this.graphNodeId()
        );
        if (debugObject) {
          (0,_core_physics_PhysicsDebug__WEBPACK_IMPORTED_MODULE_11__/* .updatePhysicsDebugObject */ .t)(debugObject);
        }
      });
    }
  }
  _findActorNode() {
    return this;
  }
  //
  // CHILDREN
  //
  // protected override _childrenControllerContext = NodeContext.JS;
  // override createNode<S extends keyof JsNodeChildrenMap>(
  // 	node_class: S,
  // 	options?: NodeCreateOptions
  // ): JsNodeChildrenMap[S];
  // override createNode<K extends valueof<JsNodeChildrenMap>>(
  // 	node_class: Constructor<K>,
  // 	options?: NodeCreateOptions
  // ): K;
  // override createNode<K extends valueof<JsNodeChildrenMap>>(
  // 	node_class: Constructor<K>,
  // 	options?: NodeCreateOptions
  // ): K {
  // 	return super.createNode(node_class, options) as K;
  // }
  // override children() {
  // 	return super.children() as BaseJsNodeType[];
  // }
  // override nodesByType<K extends keyof JsNodeChildrenMap>(type: K): JsNodeChildrenMap[K][] {
  // 	return super.nodesByType(type) as JsNodeChildrenMap[K][];
  // }
  // override childrenAllowed() {
  // 	return true;
  // }
}
function getPhysicsWorldNodeFromWorldObject(worldObject, scene) {
  const nodeId = (0,_core_physics_PhysicsWorld__WEBPACK_IMPORTED_MODULE_1__/* .physicsWorldNodeIdFromObject */ .m9)(worldObject);
  if (nodeId == null) {
    return;
  }
  const graphNode = scene.graph.nodeFromId(nodeId);
  if (!graphNode) {
    return;
  }
  const node = _core_Type__WEBPACK_IMPORTED_MODULE_12__/* .CoreType.isFunction */ .MR.isFunction(graphNode.context) ? graphNode : null;
  if (!node) {
    return;
  }
  if (node.context() != _poly_NodeContext__WEBPACK_IMPORTED_MODULE_13__/* .NodeContext.SOP */ .sy.SOP) {
    return;
  }
  if (node.type() != _poly_registers_nodes_types_Sop__WEBPACK_IMPORTED_MODULE_3__/* .SopType.PHYSICS_WORLD */ .aB.PHYSICS_WORLD) {
    return;
  }
  return node;
}


/***/ }),

/***/ 30748:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "C": function() { return /* binding */ PlaneSopNode; }
/* harmony export */ });
/* harmony import */ var _Base__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(55839);
/* harmony import */ var _operations_sop_Plane__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(81927);
/* harmony import */ var _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(96949);
/* harmony import */ var _poly_registers_nodes_types_Sop__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(58986);





const DEFAULT = _operations_sop_Plane__WEBPACK_IMPORTED_MODULE_0__/* .PlaneSopOperation.DEFAULT_PARAMS */ .j.DEFAULT_PARAMS;
class PlaneSopParamsConfig extends _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .NodeParamsConfig */ .yI {
  constructor() {
    super(...arguments);
    /** @param size of the plane */
    this.size = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .ParamConfig.VECTOR2 */ .XC.VECTOR2(DEFAULT.size);
    /** @param defines if the plane resolution is sets via the number of segments or via the step size */
    this.useSegmentsCount = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .ParamConfig.BOOLEAN */ .XC.BOOLEAN(DEFAULT.useSegmentsCount);
    /** @param step size */
    this.stepSize = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .ParamConfig.FLOAT */ .XC.FLOAT(DEFAULT.stepSize, {
      range: [1e-3, 2],
      rangeLocked: [false, false],
      visibleIf: { useSegmentsCount: 0 }
    });
    /** @param segments count */
    this.segments = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .ParamConfig.VECTOR2 */ .XC.VECTOR2(DEFAULT.segments, { visibleIf: { useSegmentsCount: 1 } });
    /** @param axis perpendicular to the plane */
    this.direction = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .ParamConfig.VECTOR3 */ .XC.VECTOR3(DEFAULT.direction);
    /** @param center of the plane */
    this.center = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .ParamConfig.VECTOR3 */ .XC.VECTOR3(DEFAULT.center);
    /** @param create lines instead of polygons */
    this.asLines = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .ParamConfig.BOOLEAN */ .XC.BOOLEAN(DEFAULT.asLines);
  }
}
const ParamsConfig = new PlaneSopParamsConfig();
class PlaneSopNode extends _Base__WEBPACK_IMPORTED_MODULE_2__/* .TypedSopNode */ .x {
  constructor() {
    super(...arguments);
    this.paramsConfig = ParamsConfig;
  }
  static type() {
    return _poly_registers_nodes_types_Sop__WEBPACK_IMPORTED_MODULE_3__/* .SopType.PLANE */ .aB.PLANE;
  }
  initializeNode() {
    this.io.inputs.setCount(0, 1);
    this.io.inputs.initInputsClonedState(_operations_sop_Plane__WEBPACK_IMPORTED_MODULE_0__/* .PlaneSopOperation.INPUT_CLONED_STATE */ .j.INPUT_CLONED_STATE);
  }
  cook(input_contents) {
    this._operation = this._operation || new _operations_sop_Plane__WEBPACK_IMPORTED_MODULE_0__/* .PlaneSopOperation */ .j(this.scene(), this.states, this);
    const core_group = this._operation.cook(input_contents, this.pv);
    this.setCoreGroup(core_group);
  }
}


/***/ }),

/***/ 60208:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "J": function() { return /* binding */ PointLightSopNode; }
/* harmony export */ });
/* harmony import */ var _Base__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(55839);
/* harmony import */ var _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(96949);
/* harmony import */ var _core_lights_PointLight__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(35031);
/* harmony import */ var _operations_sop_PointLight__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(78695);
/* harmony import */ var _poly_registers_nodes_types_Light__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(18244);






class PointLightSopParamsConfig extends (0,_core_lights_PointLight__WEBPACK_IMPORTED_MODULE_0__/* .PointLightParamConfig */ .kR)(_utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .NodeParamsConfig */ .yI) {
}
const ParamsConfig = new PointLightSopParamsConfig();
class PointLightSopNode extends _Base__WEBPACK_IMPORTED_MODULE_2__/* .TypedSopNode */ .x {
  constructor() {
    super(...arguments);
    this.paramsConfig = ParamsConfig;
  }
  static type() {
    return _poly_registers_nodes_types_Light__WEBPACK_IMPORTED_MODULE_3__/* .LightType.POINT */ .v.POINT;
  }
  initializeNode() {
    this.io.inputs.setCount(0);
  }
  cook(input_contents) {
    this._operation = this._operation || new _operations_sop_PointLight__WEBPACK_IMPORTED_MODULE_4__/* .PointLightSopOperation */ .X(this._scene, this.states, this);
    const core_group = this._operation.cook(input_contents, this.pv);
    this.setCoreGroup(core_group);
  }
}


/***/ }),

/***/ 32490:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "L": function() { return /* binding */ PolarTransformSopNode; }
/* harmony export */ });
/* harmony import */ var _Base__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(55839);
/* harmony import */ var _operations_sop_PolarTransform__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(34633);
/* harmony import */ var _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(96949);
/* harmony import */ var _core_Transform__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(87883);
/* harmony import */ var _poly_registers_nodes_types_Sop__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(58986);






const DEFAULT = _operations_sop_PolarTransform__WEBPACK_IMPORTED_MODULE_0__/* .PolarTransformSopOperation.DEFAULT_PARAMS */ .P.DEFAULT_PARAMS;
class PolarTransformSopParamConfig extends _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .NodeParamsConfig */ .yI {
  constructor() {
    super(...arguments);
    /** @param sets if this node should transform objects or geometries */
    this.applyOn = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .ParamConfig.INTEGER */ .XC.INTEGER(DEFAULT.applyOn, {
      menu: {
        entries: _core_Transform__WEBPACK_IMPORTED_MODULE_2__/* .TRANSFORM_TARGET_TYPES.map */ .Pr.map((target_type, i) => {
          return { name: target_type, value: i };
        })
      }
    });
    /** @param center of the transform */
    this.center = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .ParamConfig.VECTOR3 */ .XC.VECTOR3(DEFAULT.center.toArray());
    /** @param moves the objects along the longitude, which is equivalent to a rotation on the y axis */
    this.longitude = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .ParamConfig.FLOAT */ .XC.FLOAT(DEFAULT.longitude, {
      range: [-360, 360]
    });
    /** @param moves the objects along the latitude, which is equivalent to a rotation on the z or x axis */
    this.latitude = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .ParamConfig.FLOAT */ .XC.FLOAT(DEFAULT.latitude, {
      range: [-180, 180]
    });
    /** @param moves the point aways from the center */
    this.depth = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .ParamConfig.FLOAT */ .XC.FLOAT(DEFAULT.depth, {
      range: [0, 10]
    });
  }
}
const ParamsConfig = new PolarTransformSopParamConfig();
class PolarTransformSopNode extends _Base__WEBPACK_IMPORTED_MODULE_3__/* .TypedSopNode */ .x {
  constructor() {
    super(...arguments);
    this.paramsConfig = ParamsConfig;
  }
  static type() {
    return _poly_registers_nodes_types_Sop__WEBPACK_IMPORTED_MODULE_4__/* .SopType.POLAR_TRANSFORM */ .aB.POLAR_TRANSFORM;
  }
  initializeNode() {
    this.io.inputs.setCount(1);
    this.io.inputs.initInputsClonedState(_operations_sop_PolarTransform__WEBPACK_IMPORTED_MODULE_0__/* .PolarTransformSopOperation.INPUT_CLONED_STATE */ .P.INPUT_CLONED_STATE);
  }
  cook(input_contents) {
    this._operation = this._operation || new _operations_sop_PolarTransform__WEBPACK_IMPORTED_MODULE_0__/* .PolarTransformSopOperation */ .P(this.scene(), this.states, this);
    const core_group = this._operation.cook(input_contents, this.pv);
    this.setCoreGroup(core_group);
  }
  setApplyOn(mode) {
    this.p.applyOn.set(_core_Transform__WEBPACK_IMPORTED_MODULE_2__/* .TRANSFORM_TARGET_TYPES.indexOf */ .Pr.indexOf(mode));
  }
}


/***/ }),

/***/ 11044:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ru": function() { return /* binding */ QuadSmoothSopNode; }
/* harmony export */ });
/* unused harmony exports QuadSmoothMode, QUAD_SMOOTH_MODES */
/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(21410);
/* harmony import */ var _BaseQuad__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(84008);
/* harmony import */ var _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(96949);
/* harmony import */ var _poly_registers_nodes_types_Sop__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(58986);
/* harmony import */ var _core_geometry_Attribute__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(32558);
/* harmony import */ var _core_SetUtils__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(55407);
/* harmony import */ var _poly_InputCloneMode__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(56752);
/* harmony import */ var _poly_Assert__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(68239);
/* harmony import */ var _core_ArrayUtils__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(87132);










const _current = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();
const _neighbourAverage = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();
const _neighbour = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();
const _p0 = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();
const _p1 = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();
const _p2 = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();
const _p3 = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();
const _delta0 = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();
const _delta1 = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();
const _delta2 = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();
const _delta3 = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();
const _currentDelta0 = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();
const _currentDelta1 = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();
const _currentDelta2 = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();
const _currentDelta3 = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();
const _center = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();
const _triangle = new three__WEBPACK_IMPORTED_MODULE_0__.Triangle();
const _triangleNormal = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();
const _q = new three__WEBPACK_IMPORTED_MODULE_0__.Quaternion();
const _average = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();
var QuadSmoothMode = /* @__PURE__ */ ((QuadSmoothMode2) => {
  QuadSmoothMode2["SQUARIFY"] = "squarify";
  QuadSmoothMode2["AVERAGE"] = "average";
  return QuadSmoothMode2;
})(QuadSmoothMode || {});
const QUAD_SMOOTH_MODES = ["average" /* AVERAGE */, "squarify" /* SQUARIFY */];
class QuadSmoothSopParamsConfig extends _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .NodeParamsConfig */ .yI {
  constructor() {
    super(...arguments);
    /** @param mode */
    this.mode = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .ParamConfig.INTEGER */ .XC.INTEGER(QUAD_SMOOTH_MODES.indexOf("squarify" /* SQUARIFY */), {
      menu: {
        entries: QUAD_SMOOTH_MODES.map((name, value) => {
          return { name, value };
        })
      }
    });
    /** @param iterations */
    this.iterations = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .ParamConfig.INTEGER */ .XC.INTEGER(50, {
      range: [0, 100],
      rangeLocked: [true, false]
    });
    /** @param strength */
    this.strength = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .ParamConfig.FLOAT */ .XC.FLOAT(1, {
      range: [0, 1],
      rangeLocked: [true, true]
    });
  }
}
const ParamsConfig = new QuadSmoothSopParamsConfig();
class QuadSmoothSopNode extends _BaseQuad__WEBPACK_IMPORTED_MODULE_2__/* .QuadSopNode */ .Y {
  constructor() {
    super(...arguments);
    this.paramsConfig = ParamsConfig;
  }
  static type() {
    return _poly_registers_nodes_types_Sop__WEBPACK_IMPORTED_MODULE_3__/* .SopType.QUAD_SMOOTH */ .aB.QUAD_SMOOTH;
  }
  initializeNode() {
    this.io.inputs.setCount(1);
    this.io.inputs.initInputsClonedState(_poly_InputCloneMode__WEBPACK_IMPORTED_MODULE_4__/* .InputCloneMode.FROM_NODE */ .m.FROM_NODE);
  }
  cook(inputCoreGroups) {
    const coreGroup = inputCoreGroups[0];
    const quadObjects = coreGroup.quadObjects();
    if (quadObjects) {
      for (const object of quadObjects) {
        this._smoothQuadGeometry(object.geometry);
      }
    }
    this.setCoreGroup(coreGroup);
  }
  setMode(method) {
    this.p.mode.set(QUAD_SMOOTH_MODES.indexOf(method));
  }
  mode() {
    return QUAD_SMOOTH_MODES[this.pv.mode];
  }
  _smoothQuadGeometry(geometry) {
    const mode = this.mode();
    switch (mode) {
      case "average" /* AVERAGE */:
        return this._smoothQuadGeometryWithAverage(geometry);
      case "squarify" /* SQUARIFY */:
        return this._smoothQuadGeometryWithSquarify(geometry);
    }
    _poly_Assert__WEBPACK_IMPORTED_MODULE_5__/* .TypeAssert.unreachable */ .f.unreachable(mode);
  }
  _smoothQuadGeometryWithAverage(geometry) {
    const position = geometry.attributes[_core_geometry_Attribute__WEBPACK_IMPORTED_MODULE_6__/* .Attribute.POSITION */ .ah.POSITION];
    if (!position) {
      return;
    }
    const tmpPositionArray0 = (0,_core_ArrayUtils__WEBPACK_IMPORTED_MODULE_7__/* .typedArrayCopy */ .C)(position.array, new Float32Array(position.array.length));
    const tmpPositionArray1 = (0,_core_ArrayUtils__WEBPACK_IMPORTED_MODULE_7__/* .typedArrayCopy */ .C)(tmpPositionArray0, new Float32Array(position.array.length));
    const index = geometry.index;
    const quadsCount = geometry.quadsCount();
    const adjacentIdByIndexWithSets = /* @__PURE__ */ new Map();
    const quadCountByEdge = /* @__PURE__ */ new Map();
    const _addQuadCount = (quadIndex, i0, i1) => {
      let quadCountByEdgeEntry = quadCountByEdge.get(i0);
      if (!quadCountByEdgeEntry) {
        quadCountByEdgeEntry = /* @__PURE__ */ new Map();
        quadCountByEdge.set(i0, quadCountByEdgeEntry);
      }
      let quadIndices = quadCountByEdgeEntry.get(i1);
      if (!quadIndices) {
        quadIndices = /* @__PURE__ */ new Set();
      }
      quadIndices.add(quadIndex);
      quadCountByEdgeEntry.set(i1, quadIndices);
    };
    const _addAdjacency = (quadIndex, current, adjacent) => {
      let adjacentIds = adjacentIdByIndexWithSets.get(current);
      if (!adjacentIds) {
        adjacentIds = /* @__PURE__ */ new Set();
        adjacentIdByIndexWithSets.set(current, adjacentIds);
      }
      adjacentIds.add(adjacent);
      _addQuadCount(quadIndex, current, adjacent);
      _addQuadCount(quadIndex, adjacent, current);
    };
    for (let i = 0; i < quadsCount; i++) {
      const i4 = i * 4;
      const i0 = index[i4 + 0];
      const i1 = index[i4 + 1];
      const i2 = index[i4 + 2];
      const i3 = index[i4 + 3];
      _addAdjacency(i, i0, i3);
      _addAdjacency(i, i0, i1);
      _addAdjacency(i, i1, i0);
      _addAdjacency(i, i1, i2);
      _addAdjacency(i, i2, i1);
      _addAdjacency(i, i2, i3);
      _addAdjacency(i, i3, i2);
      _addAdjacency(i, i3, i0);
    }
    const adjacentIdByIndex = /* @__PURE__ */ new Map();
    adjacentIdByIndexWithSets.forEach((adjacentIds, index2) => {
      adjacentIdByIndex.set(index2, (0,_core_SetUtils__WEBPACK_IMPORTED_MODULE_8__/* .setToArray */ .T_)(adjacentIds, []));
    });
    adjacentIdByIndexWithSets.clear();
    const pointsOnUnsharedEdges = /* @__PURE__ */ new Set();
    adjacentIdByIndex.forEach((_, index2) => {
      const quadCountByEdgeEntry = quadCountByEdge.get(index2);
      if (!quadCountByEdgeEntry) {
        return;
      }
      quadCountByEdgeEntry.forEach((quadIndices, key1) => {
        if (quadIndices.size == 1) {
          pointsOnUnsharedEdges.add(index2);
        }
      });
    });
    const iterations = this.pv.iterations;
    const strength = this.pv.strength;
    const lerp = 1 - strength;
    let previousPositionArray = tmpPositionArray0;
    let nextPositionArray = tmpPositionArray1;
    for (let i = 0; i < iterations; i++) {
      adjacentIdByIndex.forEach((adjacentIds, index2) => {
        if (pointsOnUnsharedEdges.has(index2)) {
          return;
        }
        _current.fromArray(previousPositionArray, index2 * 3);
        _neighbourAverage.set(0, 0, 0);
        for (const adjacentId of adjacentIds) {
          _neighbour.fromArray(previousPositionArray, adjacentId * 3);
          _neighbourAverage.add(_neighbour);
        }
        _neighbourAverage.divideScalar(adjacentIds.length);
        _neighbourAverage.lerp(_current, lerp);
        _neighbourAverage.toArray(nextPositionArray, index2 * 3);
      });
      const tmp = nextPositionArray;
      nextPositionArray = previousPositionArray;
      previousPositionArray = tmp;
    }
    position.array = previousPositionArray;
  }
  _smoothQuadGeometryWithSquarify(geometry) {
    const position = geometry.attributes[_core_geometry_Attribute__WEBPACK_IMPORTED_MODULE_6__/* .Attribute.POSITION */ .ah.POSITION];
    if (!position) {
      return;
    }
    const iterations = this.pv.iterations;
    const strength = this.pv.strength;
    const positionArray = position.array;
    const pointsCount = positionArray.length / 3;
    const deltas = new Array(positionArray.length).fill(0);
    const deltasCount = new Array(pointsCount).fill(0);
    const index = geometry.index;
    const indicesCount = index.length;
    let previousPositionArray = positionArray;
    let nextPositionArray = positionArray;
    for (let i = 0; i < iterations; i++) {
      deltas.fill(0);
      for (let q = 0; q < indicesCount; q += 4) {
        const i0 = index[q + 0];
        const i1 = index[q + 1];
        const i2 = index[q + 2];
        const i3 = index[q + 3];
        const i0_3 = i0 * 3;
        const i1_3 = i1 * 3;
        const i2_3 = i2 * 3;
        const i3_3 = i3 * 3;
        _p0.fromArray(previousPositionArray, i0_3);
        _p1.fromArray(previousPositionArray, i1_3);
        _p2.fromArray(previousPositionArray, i2_3);
        _p3.fromArray(previousPositionArray, i3_3);
        _delta0.copy(_p0);
        _delta1.copy(_p1);
        _delta2.copy(_p2);
        _delta3.copy(_p3);
        _triangle.a.copy(_p0);
        _triangle.b.copy(_p1);
        _triangle.c.copy(_p2);
        _triangle.getNormal(_triangleNormal);
        _center.copy(_p0).add(_p1).add(_p2).add(_p3).multiplyScalar(0.25);
        _p0.sub(_center);
        _p1.sub(_center);
        _p2.sub(_center);
        _p3.sub(_center);
        _q.setFromAxisAngle(_triangleNormal, -Math.PI * 0.5);
        _p1.applyQuaternion(_q);
        _q.setFromAxisAngle(_triangleNormal, -Math.PI * 1);
        _p2.applyQuaternion(_q);
        _q.setFromAxisAngle(_triangleNormal, -Math.PI * 1.5);
        _p3.applyQuaternion(_q);
        _average.copy(_p0).add(_p1).add(_p2).add(_p3).multiplyScalar(0.25);
        _p0.lerp(_average, strength);
        _p1.lerp(_average, strength);
        _p2.lerp(_average, strength);
        _p3.lerp(_average, strength);
        _q.setFromAxisAngle(_triangleNormal, +Math.PI * 0.5);
        _p1.applyQuaternion(_q);
        _q.setFromAxisAngle(_triangleNormal, +Math.PI * 1);
        _p2.applyQuaternion(_q);
        _q.setFromAxisAngle(_triangleNormal, +Math.PI * 1.5);
        _p3.applyQuaternion(_q);
        _p0.add(_center);
        _p1.add(_center);
        _p2.add(_center);
        _p3.add(_center);
        _delta0.sub(_p0).multiplyScalar(-1);
        _delta1.sub(_p1).multiplyScalar(-1);
        _delta2.sub(_p2).multiplyScalar(-1);
        _delta3.sub(_p3).multiplyScalar(-1);
        _currentDelta0.fromArray(deltas, i0_3);
        _currentDelta1.fromArray(deltas, i1_3);
        _currentDelta2.fromArray(deltas, i2_3);
        _currentDelta3.fromArray(deltas, i3_3);
        _delta0.add(_currentDelta0).toArray(deltas, i0_3);
        _delta1.add(_currentDelta1).toArray(deltas, i1_3);
        _delta2.add(_currentDelta2).toArray(deltas, i2_3);
        _delta3.add(_currentDelta3).toArray(deltas, i3_3);
        deltasCount[i0]++;
        deltasCount[i1]++;
        deltasCount[i2]++;
        deltasCount[i3]++;
      }
      for (let i2 = 0; i2 < pointsCount; i2++) {
        const deltaCount = deltasCount[i2];
        if (deltaCount > 0) {
          _current.fromArray(previousPositionArray, i2 * 3);
          _currentDelta0.fromArray(deltas, i2 * 3).divideScalar(deltaCount);
          _current.add(_currentDelta0);
          _current.toArray(nextPositionArray, i2 * 3);
        }
      }
    }
    position.array = previousPositionArray;
  }
}


/***/ }),

/***/ 72926:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "n": function() { return /* binding */ QuadTriangulateSopNode; }
/* harmony export */ });
/* harmony import */ var _BaseQuad__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(84008);
/* harmony import */ var _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(96949);
/* harmony import */ var _core_Type__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(19037);
/* harmony import */ var _poly_registers_nodes_types_Sop__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(58986);
/* harmony import */ var _core_geometry_modules_quad_utils_TesselationParamsConfig__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(86554);
/* harmony import */ var _poly_InputCloneMode__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(56752);

var __async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};






class QuadTriangulateSopParamsConfig extends (0,_core_geometry_modules_quad_utils_TesselationParamsConfig__WEBPACK_IMPORTED_MODULE_0__/* .SOPQUADTesselationParamConfig */ .cA)(_utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .NodeParamsConfig */ .yI) {
}
const ParamsConfig = new QuadTriangulateSopParamsConfig();
class QuadTriangulateSopNode extends _BaseQuad__WEBPACK_IMPORTED_MODULE_2__/* .QuadSopNode */ .Y {
  constructor() {
    super(...arguments);
    this.paramsConfig = ParamsConfig;
  }
  static type() {
    return _poly_registers_nodes_types_Sop__WEBPACK_IMPORTED_MODULE_3__/* .SopType.QUAD_TRIANGULATE */ .aB.QUAD_TRIANGULATE;
  }
  initializeNode() {
    this.io.inputs.setCount(1);
    this.io.inputs.initInputsClonedState(_poly_InputCloneMode__WEBPACK_IMPORTED_MODULE_4__/* .InputCloneMode.NEVER */ .m.NEVER);
  }
  cook(inputCoreGroups) {
    return __async(this, null, function* () {
      const quadObjects = inputCoreGroups[0].quadObjects();
      if (quadObjects) {
        const newObjects = [];
        for (const quadObject of quadObjects) {
          const objects = quadObject.toObject3D(this.pv);
          if (objects) {
            if (_core_Type__WEBPACK_IMPORTED_MODULE_5__/* .CoreType.isArray */ .MR.isArray(objects)) {
              newObjects.push(...objects);
            } else {
              newObjects.push(objects);
            }
          }
        }
        this.setObjects(newObjects);
      } else {
        this.setObjects([]);
      }
    });
  }
}


/***/ }),

/***/ 40880:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {


// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  "t": function() { return /* binding */ QuadrangulateSopNode; }
});

// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/nodes/sop/_BaseQuad.ts
var _BaseQuad = __webpack_require__(84008);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/nodes/utils/params/ParamsConfig.ts
var ParamsConfig = __webpack_require__(96949);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/poly/registers/nodes/types/Sop.ts
var Sop = __webpack_require__(58986);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/core/geometry/modules/quad/QuadGeometry.ts
var QuadGeometry = __webpack_require__(32534);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/node_modules/three/build/three.module.js
var three_module = __webpack_require__(21410);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/core/geometry/Attribute.ts
var Attribute = __webpack_require__(32558);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/poly/InputCloneMode.ts
var InputCloneMode = __webpack_require__(56752);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/core/geometry/modules/quad/QuadObject.ts + 1 modules
var QuadObject = __webpack_require__(11714);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/core/ArrayUtils.ts
var ArrayUtils = __webpack_require__(87132);
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/core/geometry/modules/three/graph/triangle/TriangleEdge.ts

class TriangleEdge {
  constructor(id, pointIdPair) {
    this.id = id;
    this.pointIdPair = pointIdPair;
    this.triangleIds = [];
  }
  addTriangle(triangleId) {
    this.triangleIds.push(triangleId);
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/core/geometry/modules/three/graph/triangle/TriangleNode.ts

class TriangleNode {
  constructor(id, triangle) {
    this.id = id;
    this.triangle = triangle;
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/core/geometry/modules/three/graph/triangle/TriangleGraphCommon.ts

const EDGES = [
  [0, 1],
  [1, 2],
  [2, 0]
];
function sortPointIdPair(ids) {
  if (ids.id0 > ids.id1) {
    const temp = ids.id0;
    ids.id0 = ids.id1;
    ids.id1 = temp;
  }
  return ids;
}
function edgeId(ids) {
  sortPointIdPair(ids);
  return `${ids.id0}-${ids.id1}`;
}
function triangleEdge(triangle, edgeIndex) {
  const edgeIndices = EDGES[edgeIndex];
  return {
    id0: triangle[edgeIndices[0]],
    id1: triangle[edgeIndices[1]]
  };
}

// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/core/SetUtils.ts
var SetUtils = __webpack_require__(55407);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/core/geometry/entities/primitive/PrimitiveGraph.ts
var PrimitiveGraph = __webpack_require__(64317);
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/core/geometry/modules/three/graph/triangle/TriangleGraph.ts






class TriangleGraph extends PrimitiveGraph/* PrimitiveGraph */.S {
  constructor() {
    super(...arguments);
    this._nextTriangleId = -1;
    this._trianglesById = /* @__PURE__ */ new Map();
    this._edgesByTriangleId = /* @__PURE__ */ new Map();
    this._edgesById = /* @__PURE__ */ new Map();
    this._edgeIds = /* @__PURE__ */ new Set();
  }
  addTriangle(triangle) {
    this._nextTriangleId++;
    const triangleId = this._nextTriangleId;
    const triangleNode = new TriangleNode(triangleId, triangle);
    this._trianglesById.set(triangleId, triangleNode);
    const edges = [];
    for (let i = 0; i < 3; i++) {
      const pointIdPair = triangleEdge(triangle, i);
      const _edgeId = edgeId(pointIdPair);
      let edge = this._edgesById.get(_edgeId);
      if (!edge) {
        edge = new TriangleEdge(_edgeId, pointIdPair);
        this._edgesById.set(_edgeId, edge);
      }
      edge.addTriangle(triangleId);
      edges.push(edge);
      this._edgeIds.add(_edgeId);
    }
    this._edgesByTriangleId.set(triangleId, edges);
    return triangleNode;
  }
  removeTriangle(triangleId) {
    const triangleNode = this._trianglesById.get(triangleId);
    if (!triangleNode) {
      return;
    }
    this._trianglesById.delete(triangleId);
    const edges = this._edgesByTriangleId.get(triangleId);
    if (!edges) {
      return;
    }
    for (const edge of edges) {
      const index = edge.triangleIds.indexOf(triangleId);
      if (index >= 0) {
        edge.triangleIds.splice(index, 1);
      }
      if (edge.triangleIds.length == 0) {
        this._edgesById.delete(edge.id);
        this._edgeIds.delete(edge.id);
      }
    }
    this._edgesByTriangleId.delete(triangleId);
  }
  traverseTriangles(callback) {
    this._trianglesById.forEach((triangle) => {
      callback(triangle);
    });
  }
  edgesByTriangleId(id) {
    return this._edgesByTriangleId.get(id);
  }
  // firstNeighbourId(triangleId: number): number | undefined {
  // 	const edges = this._edgesByTriangleId.get(triangleId);
  // 	if (!edges) {
  // 		return;
  // 	}
  // 	for (const edge of edges) {
  // 		for (const _triangleId of edge.triangleIds) {
  // 			if (_triangleId != triangleId) {
  // 				return _triangleId;
  // 			}
  // 		}
  // 	}
  // }
  triangle(triangleId) {
    return this._trianglesById.get(triangleId);
  }
  edgeIds(target) {
    return (0,SetUtils/* setToArray */.T_)(this._edgeIds, target);
  }
  edge(edgeId2) {
    return this._edgesById.get(edgeId2);
  }
  neighbourIndex(primitiveIndex, neighbourIndex, withSharedEdge) {
    console.warn("not implemented");
    return 0;
  }
  neighboursCount(primitiveIndex, withSharedEdge) {
    console.warn("not implemented");
    return 0;
  }
}

// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/core/geometry/ObjectContent.ts
var ObjectContent = __webpack_require__(91057);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/core/math/_Module.ts
var _Module = __webpack_require__(27462);
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/core/geometry/modules/three/graph/triangle/TriangleGraphUtils.ts




const _triangleIds = /* @__PURE__ */ new Set();
const _edgeIds0 = /* @__PURE__ */ new Set();
const _edgeIds1 = /* @__PURE__ */ new Set();
const _edgeIds2 = /* @__PURE__ */ new Set();
const _edgeIds3 = /* @__PURE__ */ new Set();
const _edgeIds10 = /* @__PURE__ */ new Set();
const _notVisited = /* @__PURE__ */ new Set();
const _edgeIdsArray = [];
function triangleGraphExpandEdges(graph, startEdgeIds, target, excluded) {
  _triangleIds.clear();
  target.clear();
  startEdgeIds.forEach((edgeId) => {
    const edge = graph.edge(edgeId);
    if (edge) {
      const edgeTriangleIds = edge.triangleIds;
      for (const triangleId of edgeTriangleIds) {
        _triangleIds.add(triangleId);
      }
    }
  });
  _triangleIds.forEach((triangleId) => {
    const triangleEdges = graph.edgesByTriangleId(triangleId);
    if (triangleEdges) {
      for (const edge of triangleEdges) {
        if (!startEdgeIds.has(edge.id) && (excluded == null || !excluded.has(edge.id))) {
          target.add(edge.id);
        }
      }
    }
  });
}
function triangleGraphFindExpandedEdge(graph, startEdgeId, seed, step, irregularAmount, visited) {
  _edgeIds0.clear();
  _edgeIds0.add(startEdgeId);
  triangleGraphExpandEdges(graph, _edgeIds0, _edgeIds1);
  triangleGraphExpandEdges(graph, _edgeIds1, _edgeIds2, _edgeIds0);
  const _sampleFromEdges2 = () => {
    (0,SetUtils/* setDifference */.TV)(_edgeIds2, visited, _notVisited);
    (0,SetUtils/* setToArray */.T_)(_notVisited, _edgeIdsArray);
    return (0,ArrayUtils/* sample */.UP)(_edgeIdsArray, seed);
  };
  const _sampleFromEdges3 = () => {
    (0,SetUtils/* setUnion */.uy)(_edgeIds0, _edgeIds1, _edgeIds10);
    triangleGraphExpandEdges(graph, _edgeIds2, _edgeIds3, _edgeIds10);
    (0,SetUtils/* setDifference */.TV)(_edgeIds3, visited, _notVisited);
    (0,SetUtils/* setToArray */.T_)(_notVisited, _edgeIdsArray);
    return (0,ArrayUtils/* sample */.UP)(_edgeIdsArray, seed);
  };
  const foundEdgeId = (0,_Module/* randFloat */.Qy)(seed + step) > irregularAmount ? _sampleFromEdges2() : _sampleFromEdges3();
  return foundEdgeId;
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/sop/Quadrangulate.ts













const _v3 = new three_module.Vector3();
const _p0 = new three_module.Vector3();
const _p1 = new three_module.Vector3();
const _p2 = new three_module.Vector3();
const _p3 = new three_module.Vector3();
class QuadrangulateSopParamsConfig extends ParamsConfig/* NodeParamsConfig */.yI {
  constructor() {
    super(...arguments);
    /** @param quadsCount */
    // quadsCount = ParamConfig.INTEGER(1, {
    // 	range: [0, 1000],
    // 	rangeLocked: [true, false],
    // });
    /** @param regular */
    this.regular = ParamsConfig/* ParamConfig.BOOLEAN */.XC.BOOLEAN(1);
    /** @param test */
    this.granular = ParamsConfig/* ParamConfig.BOOLEAN */.XC.BOOLEAN(0, {
      visibleIf: {
        regular: 0
      }
    });
    /** @param irregularAmount */
    this.irregularAmount = ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(1, {
      range: [0, 1],
      rangeLocked: [true, true],
      visibleIf: {
        granular: 1,
        regular: 0
      }
    });
    /** @param subdivide */
    this.subdivide = ParamsConfig/* ParamConfig.BOOLEAN */.XC.BOOLEAN(1, {
      visibleIf: {
        regular: 0
      }
    });
    /** @param seed */
    this.seed = ParamsConfig/* ParamConfig.INTEGER */.XC.INTEGER(0, {
      range: [-100, 100],
      rangeLocked: [false, false],
      visibleIf: {
        regular: 0
      }
    });
  }
}
const Quadrangulate_ParamsConfig = new QuadrangulateSopParamsConfig();
class QuadrangulateSopNode extends _BaseQuad/* QuadSopNode */.Y {
  constructor() {
    super(...arguments);
    this.paramsConfig = Quadrangulate_ParamsConfig;
  }
  static type() {
    return Sop/* SopType.QUADRANGULATE */.aB.QUADRANGULATE;
  }
  initializeNode() {
    this.io.inputs.setCount(1);
    this.io.inputs.initInputsClonedState(InputCloneMode/* InputCloneMode.NEVER */.m.NEVER);
  }
  cook(inputCoreGroups) {
    const coreGroup = inputCoreGroups[0];
    const threejsObjects = coreGroup.threejsObjects();
    const newQuadObjects = [];
    for (const object of threejsObjects) {
      const geometry = object.geometry;
      if (geometry) {
        const newQuadObject = this._processGeometry(geometry);
        if (newQuadObject) {
          (0,ObjectContent/* objectContentCopyProperties */.Br)(object, newQuadObject);
          newQuadObject.geometry.applyMatrix(object.matrix);
          newQuadObjects.push(newQuadObject);
        }
      }
    }
    this.setQuadObjects(newQuadObjects);
  }
  _processGeometry(geometry) {
    const index = geometry.getIndex();
    if (!index) {
      return;
    }
    const polygonsCount = index.array.length / 3;
    if (polygonsCount < 2) {
      return;
    }
    const positionAttribute = geometry.getAttribute(Attribute/* Attribute.POSITION */.ah.POSITION);
    if (!positionAttribute) {
      return;
    }
    const { regular, granular, irregularAmount, subdivide, seed } = this.pv;
    const quadGeometry = new QuadGeometry/* QuadGeometry */.$();
    const newPositionArray = [...positionAttribute.clone().array];
    const quadIndices = [];
    const graph = new TriangleGraph();
    for (let i2 = 0; i2 < polygonsCount; i2++) {
      _v3.fromArray(index.array, i2 * 3);
      graph.addTriangle(_v3.toArray());
    }
    const edgeIds = [];
    graph.edgeIds(edgeIds);
    edgeIds.sort();
    const edgeCenterIndexByEdgeIndices = /* @__PURE__ */ new Map();
    const _findOrCreateEdgeCenterIndex = (i0, i1) => {
      const key0 = i0 < i1 ? i0 : i1;
      const key1 = i0 < i1 ? i1 : i0;
      let edgeCenterIndexByEdgeIndex = edgeCenterIndexByEdgeIndices.get(key0);
      if (!edgeCenterIndexByEdgeIndex) {
        edgeCenterIndexByEdgeIndex = /* @__PURE__ */ new Map();
        edgeCenterIndexByEdgeIndices.set(key0, edgeCenterIndexByEdgeIndex);
      }
      let edgeCenterIndex = edgeCenterIndexByEdgeIndex.get(key1);
      if (edgeCenterIndex == null) {
        _p0.fromArray(newPositionArray, i0 * 3);
        _p1.fromArray(newPositionArray, i1 * 3);
        _v3.copy(_p0).add(_p1).multiplyScalar(0.5);
        edgeCenterIndex = newPositionArray.length / 3;
        _v3.toArray(newPositionArray, newPositionArray.length);
        edgeCenterIndexByEdgeIndex.set(key1, edgeCenterIndex);
      }
      return edgeCenterIndex;
    };
    const _completeQuadObject = () => {
      if (regular == false && subdivide) {
        graph.traverseTriangles((triangle) => {
          const i0 = triangle.triangle[0];
          const i1 = triangle.triangle[1];
          const i2 = triangle.triangle[2];
          _p0.fromArray(newPositionArray, i0 * 3);
          _p1.fromArray(newPositionArray, i1 * 3);
          _p2.fromArray(newPositionArray, i2 * 3);
          _v3.copy(_p0).add(_p1).add(_p2).divideScalar(3);
          const iCenter = newPositionArray.length / 3;
          _v3.toArray(newPositionArray, newPositionArray.length);
          const i01 = _findOrCreateEdgeCenterIndex(i0, i1);
          const i12 = _findOrCreateEdgeCenterIndex(i1, i2);
          const i20 = _findOrCreateEdgeCenterIndex(i2, i0);
          quadIndices.push(i0, i01, iCenter, i20);
          quadIndices.push(i1, i12, iCenter, i01);
          quadIndices.push(i2, i20, iCenter, i12);
        });
      }
      const position = new three_module.BufferAttribute(new Float32Array(newPositionArray), 3);
      quadGeometry.setAttribute(Attribute/* Attribute.POSITION */.ah.POSITION, position);
      quadGeometry.setIndex(quadIndices);
      const quadObject = new QuadObject/* QuadObject */.n(quadGeometry);
      return quadObject;
    };
    const _nextEdgeIdWithRegularMethod = () => {
      return edgeIds.pop();
    };
    let _preparedNextEdgeId;
    const visitedEdgeIds = /* @__PURE__ */ new Set();
    const _prepareNextEdgeId = (startEdgeId, step) => {
      const foundEdgeId = triangleGraphFindExpandedEdge(
        graph,
        startEdgeId,
        seed,
        step,
        irregularAmount,
        visitedEdgeIds
      );
      _preparedNextEdgeId = foundEdgeId;
    };
    const _nextEdgeIdWithIrregularMethod = (i2) => {
      const _randomSample = () => {
        return (0,ArrayUtils/* sample */.UP)(edgeIds, seed + i2);
      };
      const _sampleFromIrregularity = () => {
        if (_preparedNextEdgeId != null) {
          return _preparedNextEdgeId;
        }
        return _randomSample();
      };
      const edgeId = granular == true ? _sampleFromIrregularity() : _randomSample();
      if (edgeId != null) {
        const index2 = edgeIds.indexOf(edgeId);
        if (index2 < 0) {
          console.log("bad edge found", edgeId, [...edgeIds].sort().join(", "));
          throw "internal error";
        }
        edgeIds.splice(index2, 1);
      }
      return edgeId;
    };
    let i = 0;
    while (edgeIds.length > 0) {
      i++;
      const edgeId = regular ? _nextEdgeIdWithRegularMethod() : _nextEdgeIdWithIrregularMethod(i);
      if (edgeId == null) {
        return _completeQuadObject();
      }
      visitedEdgeIds.add(edgeId);
      const _prepareNextEdgeIdIfTest = () => {
        if (granular == true && regular == false) {
          _prepareNextEdgeId(edgeId, i);
        }
      };
      const edge = graph.edge(edgeId);
      if (!edge) {
        _prepareNextEdgeIdIfTest();
        continue;
      }
      const triangleIds = edge.triangleIds;
      const triangle0 = graph.triangle(triangleIds[0]);
      const triangle1 = graph.triangle(triangleIds[1]);
      if (!triangle0 || !triangle1) {
        _prepareNextEdgeIdIfTest();
        continue;
      }
      _prepareNextEdgeIdIfTest();
      graph.removeTriangle(triangle0.id);
      graph.removeTriangle(triangle1.id);
      const i0 = triangle0.triangle.find(
        (index2) => index2 != edge.pointIdPair.id0 && index2 != edge.pointIdPair.id1
      );
      const i2 = triangle1.triangle.find(
        (index2) => index2 != edge.pointIdPair.id0 && index2 != edge.pointIdPair.id1
      );
      const triangle0UnsharedIndexIndex = triangle0.triangle.indexOf(i0);
      const triangle1UnsharedIndexIndex = triangle1.triangle.indexOf(i2);
      const i1 = triangle0.triangle[(triangle0UnsharedIndexIndex + 1) % 3];
      const i3 = triangle1.triangle[(triangle1UnsharedIndexIndex + 1) % 3];
      if (regular == true || subdivide == false) {
        quadIndices.push(i0, i1, i2, i3);
      } else {
        _p0.fromArray(newPositionArray, i0 * 3);
        _p1.fromArray(newPositionArray, i1 * 3);
        _p2.fromArray(newPositionArray, i2 * 3);
        _p3.fromArray(newPositionArray, i3 * 3);
        _v3.copy(_p0).add(_p1).add(_p2).add(_p3).multiplyScalar(0.25);
        const iCenter = newPositionArray.length / 3;
        _v3.toArray(newPositionArray, newPositionArray.length);
        const i01 = _findOrCreateEdgeCenterIndex(i0, i1);
        const i12 = _findOrCreateEdgeCenterIndex(i1, i2);
        const i23 = _findOrCreateEdgeCenterIndex(i2, i3);
        const i30 = _findOrCreateEdgeCenterIndex(i3, i0);
        quadIndices.push(i0, i01, iCenter, i30);
        quadIndices.push(i1, i12, iCenter, i01);
        quadIndices.push(i2, i23, iCenter, i12);
        quadIndices.push(i3, i30, iCenter, i23);
      }
    }
    return _completeQuadObject();
  }
}


/***/ }),

/***/ 13200:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "U": function() { return /* binding */ RaySopNode; }
/* harmony export */ });
/* harmony import */ var _Base__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(55839);
/* harmony import */ var _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(96949);
/* harmony import */ var _operations_sop_Ray__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(27613);
/* harmony import */ var _poly_registers_nodes_types_Sop__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(58986);





const DEFAULT = _operations_sop_Ray__WEBPACK_IMPORTED_MODULE_0__/* .RaySopOperation.DEFAULT_PARAMS */ .LE.DEFAULT_PARAMS;
class RaySopParamsConfig extends _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .NodeParamsConfig */ .yI {
  constructor() {
    super(...arguments);
    /** @param method used to ray points onto the collision geometry */
    this.mode = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .ParamConfig.INTEGER */ .XC.INTEGER(DEFAULT.mode, {
      menu: {
        entries: _operations_sop_Ray__WEBPACK_IMPORTED_MODULE_0__/* .RAY_SOP_MODES.map */ .i5.map((name, value) => ({ name, value }))
      }
    });
    /** @param toggle on to use the normals as the ray direction */
    this.useNormals = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .ParamConfig.BOOLEAN */ .XC.BOOLEAN(DEFAULT.useNormals);
    /** @param if the normals are not used as the ray direction, this define the direction used */
    this.direction = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .ParamConfig.VECTOR3 */ .XC.VECTOR3(DEFAULT.direction.toArray(), {
      visibleIf: { useNormals: 0 }
    });
    /** @param moves the points or leaves them in place */
    this.transformPoints = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .ParamConfig.BOOLEAN */ .XC.BOOLEAN(DEFAULT.transformPoints);
    /** @param copies the normals from the right geometry to the left one */
    this.transferFaceNormals = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .ParamConfig.BOOLEAN */ .XC.BOOLEAN(DEFAULT.transferFaceNormals);
    /** @param adds an attribute with the distance to the hit position on the target geometry */
    this.addDistAttribute = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .ParamConfig.BOOLEAN */ .XC.BOOLEAN(DEFAULT.addDistAttribute);
  }
}
const ParamsConfig = new RaySopParamsConfig();
class RaySopNode extends _Base__WEBPACK_IMPORTED_MODULE_2__/* .TypedSopNode */ .x {
  constructor() {
    super(...arguments);
    this.paramsConfig = ParamsConfig;
  }
  static type() {
    return _poly_registers_nodes_types_Sop__WEBPACK_IMPORTED_MODULE_3__/* .SopType.RAY */ .aB.RAY;
  }
  initializeNode() {
    this.io.inputs.setCount(2);
    this.io.inputs.initInputsClonedState(_operations_sop_Ray__WEBPACK_IMPORTED_MODULE_0__/* .RaySopOperation.INPUT_CLONED_STATE */ .LE.INPUT_CLONED_STATE);
  }
  cook(inputCoreGroups) {
    this._operation = this._operation || new _operations_sop_Ray__WEBPACK_IMPORTED_MODULE_0__/* .RaySopOperation */ .LE(this._scene, this.states, this);
    const coreGroup = this._operation.cook(inputCoreGroups, this.pv);
    this.setCoreGroup(coreGroup);
  }
  setMode(mode) {
    this.p.mode.set(_operations_sop_Ray__WEBPACK_IMPORTED_MODULE_0__/* .RAY_SOP_MODES.indexOf */ .i5.indexOf(mode));
  }
}


/***/ }),

/***/ 94654:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "q": function() { return /* binding */ RestAttributesSopNode; }
/* harmony export */ });
/* harmony import */ var _Base__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(55839);
/* harmony import */ var _poly_InputCloneMode__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(56752);
/* harmony import */ var _operations_sop_RestAttributes__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(77475);
/* harmony import */ var _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(96949);





const DEFAULT = _operations_sop_RestAttributes__WEBPACK_IMPORTED_MODULE_0__/* .RestAttributesSopOperation.DEFAULT_PARAMS */ .d.DEFAULT_PARAMS;
class RestAttributesSopParamsConfig extends _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .NodeParamsConfig */ .yI {
  constructor() {
    super(...arguments);
    /** @param toggle on to create a rest position */
    this.tposition = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .ParamConfig.BOOLEAN */ .XC.BOOLEAN(DEFAULT.tposition);
    /** @param name of the position attribute */
    this.position = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .ParamConfig.STRING */ .XC.STRING(DEFAULT.position, { visibleIf: { tposition: true } });
    /** @param name of the rest position attribute, on which the position will be copied on */
    this.restP = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .ParamConfig.STRING */ .XC.STRING(DEFAULT.restP, { visibleIf: { tposition: true } });
    /** @param toggle on to create a rest normal */
    this.tnormal = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .ParamConfig.BOOLEAN */ .XC.BOOLEAN(DEFAULT.tnormal);
    /** @param name of the normal attribute */
    this.normal = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .ParamConfig.STRING */ .XC.STRING(DEFAULT.normal, { visibleIf: { tnormal: true } });
    /** @param name of the rest normal attribute, on which the normal will be copied on */
    this.restN = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .ParamConfig.STRING */ .XC.STRING(DEFAULT.restN, { visibleIf: { tnormal: true } });
  }
}
const ParamsConfig = new RestAttributesSopParamsConfig();
class RestAttributesSopNode extends _Base__WEBPACK_IMPORTED_MODULE_2__/* .TypedSopNode */ .x {
  constructor() {
    super(...arguments);
    this.paramsConfig = ParamsConfig;
  }
  static type() {
    return "restAttributes";
  }
  initializeNode() {
    this.io.inputs.setCount(1);
    this.io.inputs.initInputsClonedState([_poly_InputCloneMode__WEBPACK_IMPORTED_MODULE_3__/* .InputCloneMode.FROM_NODE */ .m.FROM_NODE]);
  }
  cook(input_contents) {
    this._operation = this._operation || new _operations_sop_RestAttributes__WEBPACK_IMPORTED_MODULE_0__/* .RestAttributesSopOperation */ .d(this.scene(), this.states, this);
    const core_group = this._operation.cook(input_contents, this.pv);
    this.setCoreGroup(core_group);
  }
}


/***/ }),

/***/ 35730:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "S": function() { return /* binding */ SetChildrenSopNode; }
/* harmony export */ });
/* harmony import */ var _Base__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(55839);
/* harmony import */ var _operations_sop_SetChildren__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(2896);
/* harmony import */ var _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(96949);
/* harmony import */ var _poly_registers_nodes_types_Sop__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(58986);





const DEFAULT = _operations_sop_SetChildren__WEBPACK_IMPORTED_MODULE_0__/* .SetChildrenSopOperation.DEFAULT_PARAMS */ ._.DEFAULT_PARAMS;
class SetChildrenSopParamsConfig extends _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .NodeParamsConfig */ .yI {
  constructor() {
    super(...arguments);
    this.clearExistingChildren = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .ParamConfig.BOOLEAN */ .XC.BOOLEAN(DEFAULT.clearExistingChildren);
  }
}
const ParamsConfig = new SetChildrenSopParamsConfig();
class SetChildrenSopNode extends _Base__WEBPACK_IMPORTED_MODULE_2__/* .TypedSopNode */ .x {
  constructor() {
    super(...arguments);
    this.paramsConfig = ParamsConfig;
  }
  static type() {
    return _poly_registers_nodes_types_Sop__WEBPACK_IMPORTED_MODULE_3__/* .SopType.SET_CHILDREN */ .aB.SET_CHILDREN;
  }
  initializeNode() {
    this.io.inputs.setCount(2);
    this.io.inputs.initInputsClonedState(_operations_sop_SetChildren__WEBPACK_IMPORTED_MODULE_0__/* .SetChildrenSopOperation.INPUT_CLONED_STATE */ ._.INPUT_CLONED_STATE);
  }
  cook(inputCoreGroups) {
    this._operation = this._operation || new _operations_sop_SetChildren__WEBPACK_IMPORTED_MODULE_0__/* .SetChildrenSopOperation */ ._(this._scene, this.states, this);
    const core_group = this._operation.cook(inputCoreGroups, this.pv);
    this.setCoreGroup(core_group);
  }
}


/***/ }),

/***/ 58420:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "S": function() { return /* binding */ SetGeometrySopNode; }
/* harmony export */ });
/* harmony import */ var _Base__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(55839);
/* harmony import */ var _operations_sop_SetGeometry__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(43099);
/* harmony import */ var _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(96949);
/* harmony import */ var _poly_registers_nodes_types_Sop__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(58986);





const DEFAULT = _operations_sop_SetGeometry__WEBPACK_IMPORTED_MODULE_0__/* .SetGeometrySopOperation.DEFAULT_PARAMS */ .HV.DEFAULT_PARAMS;
class SetGeometrySopParamsConfig extends _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .NodeParamsConfig */ .yI {
  constructor() {
    super(...arguments);
    this.mode = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .ParamConfig.INTEGER */ .XC.INTEGER(DEFAULT.mode, {
      menu: {
        entries: _operations_sop_SetGeometry__WEBPACK_IMPORTED_MODULE_0__/* .SET_GEOMETRY_MODES.map */ .xj.map((name, value) => ({ name, value }))
      }
    });
  }
}
const ParamsConfig = new SetGeometrySopParamsConfig();
class SetGeometrySopNode extends _Base__WEBPACK_IMPORTED_MODULE_2__/* .TypedSopNode */ .x {
  constructor() {
    super(...arguments);
    this.paramsConfig = ParamsConfig;
  }
  static type() {
    return _poly_registers_nodes_types_Sop__WEBPACK_IMPORTED_MODULE_3__/* .SopType.SET_GEOMETRY */ .aB.SET_GEOMETRY;
  }
  initializeNode() {
    this.io.inputs.setCount(2);
    this.io.inputs.initInputsClonedState(_operations_sop_SetGeometry__WEBPACK_IMPORTED_MODULE_0__/* .SetGeometrySopOperation.INPUT_CLONED_STATE */ .HV.INPUT_CLONED_STATE);
  }
  setMode(mode) {
    this.p.mode.set(_operations_sop_SetGeometry__WEBPACK_IMPORTED_MODULE_0__/* .SET_GEOMETRY_MODES.indexOf */ .xj.indexOf(mode));
  }
  cook(inputCoreGroups) {
    this._operation = this._operation || new _operations_sop_SetGeometry__WEBPACK_IMPORTED_MODULE_0__/* .SetGeometrySopOperation */ .HV(this.scene(), this.states, this);
    const coreGroup = this._operation.cook(inputCoreGroups, this.pv);
    this.setCoreGroup(coreGroup);
  }
}


/***/ }),

/***/ 10778:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {


// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  "S": function() { return /* binding */ SolverSopNode; }
});

// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/core/graph/CoreGraphNode.ts + 1 modules
var CoreGraphNode = __webpack_require__(45516);
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/sop/utils/SolverIterationStamp.ts


class SolverIterationStamp extends CoreGraphNode/* CoreGraphNode */.Y {
  constructor(scene) {
    super(scene, "SolverIterationStamp");
    this._iteration = 0;
  }
  reset() {
    this._iteration = 0;
  }
  setIteration(iteration) {
    if (iteration != this._iteration) {
      this._iteration = iteration;
      this.setDirty();
      this.removeDirtyState();
    }
  }
  iteration() {
    return this._iteration;
  }
}

// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/poly/NodeContext.ts
var NodeContext = __webpack_require__(52070);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/nodes/sop/utils/subnet/SopSubnetChildrenDisplayController.ts
var SopSubnetChildrenDisplayController = __webpack_require__(70677);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/poly/InputCloneMode.ts
var InputCloneMode = __webpack_require__(56752);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/nodes/utils/params/ParamsConfig.ts
var ParamsConfig = __webpack_require__(96949);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/nodes/utils/DisplayNodeController.ts
var DisplayNodeController = __webpack_require__(35725);
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/sop/Solver.ts

var __async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};






class SolverSopParamsConfig extends ParamsConfig/* NodeParamsConfig */.yI {
  constructor() {
    super(...arguments);
    /** @param number of times the nodes inside this node will process the input */
    this.iterations = ParamsConfig/* ParamConfig.INTEGER */.XC.INTEGER(2, {
      range: [0, 5],
      rangeLocked: [true, false]
    });
    /** @param Currently, when the child nodes are updated, the solver node does not know that it should recook. Clicking this button forces it to recompute */
    this.reload = ParamsConfig/* ParamConfig.BUTTON */.XC.BUTTON(null, {
      callback: (node) => {
        SolverSopNode.PARAM_CALLBACK_reload(node);
      }
    });
  }
}
const Solver_ParamsConfig = new SolverSopParamsConfig();
class SolverSopNode extends SopSubnetChildrenDisplayController/* SubnetSopNodeLike */.e {
  constructor() {
    super(...arguments);
    this.paramsConfig = Solver_ParamsConfig;
    this.childrenDisplayController = new SopSubnetChildrenDisplayController/* SopSubnetChildrenDisplayController */.J(this, { dependsOnDisplayNode: false });
    this.displayNodeController = new DisplayNodeController/* DisplayNodeController */.v(
      this,
      {
        onDisplayNodeRemove: () => {
        },
        onDisplayNodeSet: () => {
        },
        onDisplayNodeUpdate: () => {
        }
      },
      { dependsOnDisplayNode: false }
    );
  }
  static type() {
    return NodeContext/* NetworkNodeType.SOLVER */.kX.SOLVER;
  }
  initializeNode() {
    this.io.inputs.setCount(0, 4);
    this.io.inputs.initInputsClonedState(InputCloneMode/* InputCloneMode.NEVER */.m.NEVER);
  }
  iterationStamp() {
    return this._iterationStamp = this._iterationStamp || this._createStampNode();
  }
  _createStampNode() {
    const stampNode = new SolverIterationStamp(this.scene());
    stampNode.setForbiddenTriggerNodes(this);
    return stampNode;
  }
  previousFrameCoreGroup() {
    return this._previousFrameCoreGroup;
  }
  cook(inputCoreGroups) {
    return __async(this, null, function* () {
      this._reset();
      if (this.pv.iterations == 0) {
        this.setCoreGroup(inputCoreGroups[0]);
        return;
      }
      yield this._computeSolverMultipleTimes(this.pv.iterations);
    });
  }
  _reset() {
    this._previousFrameCoreGroup = void 0;
    if (this.iterationStamp().iteration() == 0) {
      this.iterationStamp().setIteration(-1);
    }
  }
  _computeSolverMultipleTimes(iterationsCount) {
    return __async(this, null, function* () {
      for (let i = 0; i < iterationsCount; i++) {
        this.iterationStamp().setIteration(i);
        yield this.computeSolver(i == iterationsCount - 1);
      }
    });
  }
  computeSolver(isLastIteration) {
    return __async(this, null, function* () {
      const childOutputNode = this.childrenDisplayController.outputNode();
      let coreContent;
      if (childOutputNode) {
        const container = yield childOutputNode.compute();
        coreContent = container.coreContent();
        if (coreContent) {
          this._previousFrameCoreGroup = coreContent;
        } else {
          if (childOutputNode.states.error.active()) {
            this.states.error.set(childOutputNode.states.error.message());
          } else {
            this._previousFrameCoreGroup = void 0;
          }
        }
      } else {
        this.states.error.set("no output node found inside subnet");
      }
      if (isLastIteration) {
        if (coreContent) {
          this.setCoreGroup(coreContent);
        } else {
          this.setObjects([]);
        }
      }
    });
  }
  static PARAM_CALLBACK_reload(node) {
    node.param_callback_reload();
  }
  param_callback_reload() {
    this.p.iterations.setDirty();
  }
}


/***/ }),

/***/ 98811:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "i": function() { return /* binding */ SortSopNode; }
/* harmony export */ });
/* harmony import */ var _Base__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(55839);
/* harmony import */ var _poly_InputCloneMode__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(56752);
/* harmony import */ var _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(96949);
/* harmony import */ var _operations_sop_Sort__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(32234);
/* harmony import */ var _poly_registers_nodes_types_Sop__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(58986);






const DEFAULT = _operations_sop_Sort__WEBPACK_IMPORTED_MODULE_0__/* .SortSopOperation.DEFAULT_PARAMS */ .ZM.DEFAULT_PARAMS;
class SortSopParamsConfig extends _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .NodeParamsConfig */ .yI {
  constructor() {
    super(...arguments);
    /** @param defines if this node will sort points or objects */
    this.targetType = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .ParamConfig.INTEGER */ .XC.INTEGER(DEFAULT.targetType, {
      menu: {
        entries: _operations_sop_Sort__WEBPACK_IMPORTED_MODULE_0__/* .SORT_TARGET_TYPES.map */ .Xp.map((name, value) => ({ name, value }))
      }
    });
    /** @param criteria used to sort */
    this.mode = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .ParamConfig.INTEGER */ .XC.INTEGER(DEFAULT.mode, {
      menu: {
        entries: _operations_sop_Sort__WEBPACK_IMPORTED_MODULE_0__/* .SORT_MODES.map */ .iU.map((name, value) => ({ name, value }))
      }
    });
    /** @param seed used by the random mode */
    this.seed = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .ParamConfig.INTEGER */ .XC.INTEGER(DEFAULT.seed, {
      range: [0, 100],
      rangeLocked: [false, false],
      visibleIf: { mode: _operations_sop_Sort__WEBPACK_IMPORTED_MODULE_0__/* .SORT_MODES.indexOf */ .iU.indexOf(_operations_sop_Sort__WEBPACK_IMPORTED_MODULE_0__/* .SortMode.RANDOM */ .h8.RANDOM) }
    });
    /** @param axis along which points will be sorted */
    this.axis = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .ParamConfig.INTEGER */ .XC.INTEGER(DEFAULT.axis, {
      menu: {
        entries: _operations_sop_Sort__WEBPACK_IMPORTED_MODULE_0__/* .AXISES.map */ .QY.map((name, value) => {
          return { name, value };
        })
      },
      visibleIf: { mode: _operations_sop_Sort__WEBPACK_IMPORTED_MODULE_0__/* .SORT_MODES.indexOf */ .iU.indexOf(_operations_sop_Sort__WEBPACK_IMPORTED_MODULE_0__/* .SortMode.AXIS */ .h8.AXIS) }
    });
    /** @param attribute */
    this.attribute = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .ParamConfig.STRING */ .XC.STRING(DEFAULT.attribute, {
      visibleIf: { mode: _operations_sop_Sort__WEBPACK_IMPORTED_MODULE_0__/* .SORT_MODES.indexOf */ .iU.indexOf(_operations_sop_Sort__WEBPACK_IMPORTED_MODULE_0__/* .SortMode.ATTRIBUTE */ .h8.ATTRIBUTE) }
    });
    /** @param invert the sort */
    this.invert = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .ParamConfig.BOOLEAN */ .XC.BOOLEAN(DEFAULT.invert);
  }
}
const ParamsConfig = new SortSopParamsConfig();
class SortSopNode extends _Base__WEBPACK_IMPORTED_MODULE_2__/* .TypedSopNode */ .x {
  constructor() {
    super(...arguments);
    this.paramsConfig = ParamsConfig;
  }
  static type() {
    return _poly_registers_nodes_types_Sop__WEBPACK_IMPORTED_MODULE_3__/* .SopType.SORT */ .aB.SORT;
  }
  initializeNode() {
    this.io.inputs.setCount(1);
    this.io.inputs.initInputsClonedState([_poly_InputCloneMode__WEBPACK_IMPORTED_MODULE_4__/* .InputCloneMode.FROM_NODE */ .m.FROM_NODE]);
  }
  cook(inputCoreGroups) {
    this._operation = this._operation || new _operations_sop_Sort__WEBPACK_IMPORTED_MODULE_0__/* .SortSopOperation */ .ZM(this._scene, this.states, this);
    const coreGroup = this._operation.cook(inputCoreGroups, this.pv);
    this.setCoreGroup(coreGroup);
  }
  setAttribClass(attribClass) {
    if (_operations_sop_Sort__WEBPACK_IMPORTED_MODULE_0__/* .SORT_TARGET_TYPES.includes */ .Xp.includes(attribClass)) {
      this.p.targetType.set(_operations_sop_Sort__WEBPACK_IMPORTED_MODULE_0__/* .SORT_TARGET_TYPES.indexOf */ .Xp.indexOf(attribClass));
    } else {
      console.warn(`${attribClass} is not possible on this node`);
    }
  }
  attribClass() {
    return _operations_sop_Sort__WEBPACK_IMPORTED_MODULE_0__/* .SORT_TARGET_TYPES */ .Xp[this.pv.targetType];
  }
  setSortMode(mode) {
    this.p.mode.set(_operations_sop_Sort__WEBPACK_IMPORTED_MODULE_0__/* .SORT_MODES.indexOf */ .iU.indexOf(mode));
  }
  setTargetType(targetType) {
    this.p.targetType.set(_operations_sop_Sort__WEBPACK_IMPORTED_MODULE_0__/* .SORT_TARGET_TYPES.indexOf */ .Xp.indexOf(targetType));
  }
}


/***/ }),

/***/ 30478:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "_": function() { return /* binding */ SphereSopNode; }
/* harmony export */ });
/* harmony import */ var _Base__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(55839);
/* harmony import */ var _operations_sop_Sphere__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(56431);
/* harmony import */ var _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(96949);
/* harmony import */ var _poly_registers_nodes_types_Sop__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(58986);





const DEFAULT = _operations_sop_Sphere__WEBPACK_IMPORTED_MODULE_0__/* .SphereSopOperation.DEFAULT_PARAMS */ .bH.DEFAULT_PARAMS;
const step = 1e-5;
class SphereSopParamsConfig extends _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .NodeParamsConfig */ .yI {
  constructor() {
    super(...arguments);
    /** @param type of sphere (default sphere or isocahedron) */
    this.type = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .ParamConfig.INTEGER */ .XC.INTEGER(DEFAULT.type, {
      menu: {
        entries: _operations_sop_Sphere__WEBPACK_IMPORTED_MODULE_0__/* .SPHERE_TYPES.map */ .k0.map((name) => {
          return { name, value: _operations_sop_Sphere__WEBPACK_IMPORTED_MODULE_0__/* .SPHERE_TYPE */ .Sj[name] };
        })
      }
    });
    /** @param radius of the sphere when the type is default */
    this.radius = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .ParamConfig.FLOAT */ .XC.FLOAT(DEFAULT.radius, {
      range: [0, 2],
      rangeLocked: [true, false]
    });
    /** @param resolution - number of segments in x and y */
    this.resolution = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .ParamConfig.VECTOR2 */ .XC.VECTOR2(DEFAULT.resolution, { visibleIf: { type: _operations_sop_Sphere__WEBPACK_IMPORTED_MODULE_0__/* .SPHERE_TYPE["default"] */ .Sj["default"] } });
    /** @param if set to 1, you can then set the phiStart, phi_end, thetaStart and theta_end */
    this.open = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .ParamConfig.BOOLEAN */ .XC.BOOLEAN(DEFAULT.open, { visibleIf: { type: _operations_sop_Sphere__WEBPACK_IMPORTED_MODULE_0__/* .SPHERE_TYPE["default"] */ .Sj["default"] } });
    /** @param start of phi angle */
    this.phiStart = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .ParamConfig.FLOAT */ .XC.FLOAT(DEFAULT.phiStart, {
      range: [0, Math.PI * 2],
      visibleIf: { type: _operations_sop_Sphere__WEBPACK_IMPORTED_MODULE_0__/* .SPHERE_TYPE["default"] */ .Sj["default"], open: true },
      step
    });
    /** @param length of phi opening */
    this.phiLength = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .ParamConfig.FLOAT */ .XC.FLOAT("$PI*2", {
      range: [0, Math.PI * 2],
      visibleIf: { type: _operations_sop_Sphere__WEBPACK_IMPORTED_MODULE_0__/* .SPHERE_TYPE["default"] */ .Sj["default"], open: true },
      step
    });
    /** @param start of theta angle */
    this.thetaStart = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .ParamConfig.FLOAT */ .XC.FLOAT(DEFAULT.thetaStart, {
      range: [0, Math.PI],
      visibleIf: { type: _operations_sop_Sphere__WEBPACK_IMPORTED_MODULE_0__/* .SPHERE_TYPE["default"] */ .Sj["default"], open: true },
      step
    });
    /** @param length of theta opening */
    this.thetaLength = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .ParamConfig.FLOAT */ .XC.FLOAT("$PI", {
      range: [0, Math.PI],
      visibleIf: { type: _operations_sop_Sphere__WEBPACK_IMPORTED_MODULE_0__/* .SPHERE_TYPE["default"] */ .Sj["default"], open: true },
      step
    });
    /** @param resolution of the sphere when the type is isocahedron */
    this.detail = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .ParamConfig.INTEGER */ .XC.INTEGER(DEFAULT.detail, {
      range: [0, 5],
      rangeLocked: [true, false],
      visibleIf: { type: _operations_sop_Sphere__WEBPACK_IMPORTED_MODULE_0__/* .SPHERE_TYPE.isocahedron */ .Sj.isocahedron }
    });
    /** @param center of the sphere */
    this.center = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .ParamConfig.VECTOR3 */ .XC.VECTOR3(DEFAULT.center);
    /** @param create lines instead of polygons */
    this.asLines = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .ParamConfig.BOOLEAN */ .XC.BOOLEAN(DEFAULT.asLines);
  }
}
const ParamsConfig = new SphereSopParamsConfig();
class SphereSopNode extends _Base__WEBPACK_IMPORTED_MODULE_2__/* .TypedSopNode */ .x {
  constructor() {
    super(...arguments);
    this.paramsConfig = ParamsConfig;
  }
  static type() {
    return _poly_registers_nodes_types_Sop__WEBPACK_IMPORTED_MODULE_3__/* .SopType.SPHERE */ .aB.SPHERE;
  }
  initializeNode() {
    this.io.inputs.setCount(0, 1);
    this.io.inputs.initInputsClonedState(_operations_sop_Sphere__WEBPACK_IMPORTED_MODULE_0__/* .SphereSopOperation.INPUT_CLONED_STATE */ .bH.INPUT_CLONED_STATE);
  }
  cook(input_contents) {
    this._operation = this._operation || new _operations_sop_Sphere__WEBPACK_IMPORTED_MODULE_0__/* .SphereSopOperation */ .bH(this.scene(), this.states, this);
    const core_group = this._operation.cook(input_contents, this.pv);
    this.setCoreGroup(core_group);
  }
}


/***/ }),

/***/ 35879:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "S": function() { return /* binding */ SplitSopNode; }
/* harmony export */ });
/* harmony import */ var _Base__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(55839);
/* harmony import */ var _core_geometry_Constant__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(91568);
/* harmony import */ var _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(96949);
/* harmony import */ var _core_geometry_modules_three_ThreejsCoreObject__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(2318);
/* harmony import */ var _core_MapUtils__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(94158);
/* harmony import */ var _core_geometry_modules_three_builders_geometryBuilder__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(97816);
/* harmony import */ var _poly_registers_nodes_types_Sop__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(58986);
/* harmony import */ var _core_geometry_entities_point_CorePointUtils__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(50253);









const _points = [];
class SplitSopParamsConfig extends _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_0__/* .NodeParamsConfig */ .yI {
  constructor() {
    super(...arguments);
    /** @param type of attribute to use */
    this.attribType = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_0__/* .ParamConfig.INTEGER */ .XC.INTEGER(_core_geometry_Constant__WEBPACK_IMPORTED_MODULE_1__/* .ATTRIBUTE_TYPES.indexOf */ .Xu.indexOf(_core_geometry_Constant__WEBPACK_IMPORTED_MODULE_1__/* .AttribType.NUMERIC */ .rp.NUMERIC), {
      menu: {
        entries: _core_geometry_Constant__WEBPACK_IMPORTED_MODULE_1__/* .AttribTypeMenuEntries */ .mb
      }
    });
    /** @param name of the attribute */
    this.attribName = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_0__/* .ParamConfig.STRING */ .XC.STRING("");
  }
}
const ParamsConfig = new SplitSopParamsConfig();
class SplitSopNode extends _Base__WEBPACK_IMPORTED_MODULE_2__/* .TypedSopNode */ .x {
  constructor() {
    super(...arguments);
    this.paramsConfig = ParamsConfig;
    this._newObjects = [];
  }
  static type() {
    return _poly_registers_nodes_types_Sop__WEBPACK_IMPORTED_MODULE_3__/* .SopType.SPLIT */ .aB.SPLIT;
  }
  initializeNode() {
    this.io.inputs.setCount(1);
  }
  cook(input_contents) {
    const core_group = input_contents[0];
    this._newObjects.length = 0;
    if (this.pv.attribName != "") {
      this._split_core_group(core_group);
    }
    this.setObjects(this._newObjects);
  }
  _split_core_group(core_group) {
    const core_objects = core_group.threejsCoreObjects();
    for (let core_object of core_objects) {
      this._split_core_object(core_object);
    }
  }
  _split_core_object(coreObject) {
    const object = coreObject.object();
    let attribName = this.pv.attribName;
    const pointsByValue = /* @__PURE__ */ new Map();
    (0,_core_geometry_entities_point_CorePointUtils__WEBPACK_IMPORTED_MODULE_4__/* .pointsFromObject */ .u_)(object, _points);
    const firstPoint = _points[0];
    if (firstPoint) {
      const attribSize = firstPoint.attribSize(attribName);
      if (!(attribSize == _core_geometry_Constant__WEBPACK_IMPORTED_MODULE_1__/* .AttribSize.FLOAT */ .NS.FLOAT || firstPoint.isAttribIndexed(attribName))) {
        this.states.error.set(`attrib '${attribName}' must be a float or a string`);
        return;
      }
      let val;
      if (firstPoint.isAttribIndexed(attribName)) {
        for (const point of _points) {
          val = point.indexedAttribValue(attribName);
          _core_MapUtils__WEBPACK_IMPORTED_MODULE_5__/* .MapUtils.pushOnArrayAtEntry */ .pl.pushOnArrayAtEntry(pointsByValue, val, point);
        }
      } else {
        for (const point of _points) {
          val = point.attribValue(attribName);
          _core_MapUtils__WEBPACK_IMPORTED_MODULE_5__/* .MapUtils.pushOnArrayAtEntry */ .pl.pushOnArrayAtEntry(pointsByValue, val, point);
        }
      }
    }
    const objectType = (0,_core_geometry_Constant__WEBPACK_IMPORTED_MODULE_1__/* .objectTypeFromObject */ .c9)(object);
    if (objectType) {
      pointsByValue.forEach((points, value) => {
        const builder = (0,_core_geometry_modules_three_builders_geometryBuilder__WEBPACK_IMPORTED_MODULE_6__/* .geometryBuilder */ ._)(objectType);
        if (builder) {
          const newGeometry = builder.fromPoints(object, points);
          if (newGeometry) {
            const object2 = this.createObject(newGeometry, objectType);
            if (object2) {
              _core_geometry_modules_three_ThreejsCoreObject__WEBPACK_IMPORTED_MODULE_7__/* .ThreejsCoreObject.addAttribute */ .W.addAttribute(object2, attribName, value);
              this._newObjects.push(object2);
            }
          }
        }
      });
    }
  }
}


/***/ }),

/***/ 69046:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "j": function() { return /* binding */ SubnetInputSopNode; }
/* harmony export */ });
/* harmony import */ var _Base__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(55839);
/* harmony import */ var _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(96949);
/* harmony import */ var _poly_NodeContext__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(52070);

var __async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};



class SubnetInputSopParamsConfig extends _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_0__/* .NodeParamsConfig */ .yI {
  constructor() {
    super(...arguments);
    /** @param sets which input of the parent subnet node is used */
    this.input = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_0__/* .ParamConfig.INTEGER */ .XC.INTEGER(0, {
      range: [0, 3],
      rangeLocked: [true, true],
      callback: (node) => {
        SubnetInputSopNode.PARAM_CALLBACK_reset(node);
      }
    });
  }
}
const ParamsConfig = new SubnetInputSopParamsConfig();
class SubnetInputSopNode extends _Base__WEBPACK_IMPORTED_MODULE_1__/* .TypedSopNode */ .x {
  constructor() {
    super(...arguments);
    this.paramsConfig = ParamsConfig;
  }
  static type() {
    return _poly_NodeContext__WEBPACK_IMPORTED_MODULE_2__/* .NetworkChildNodeType.INPUT */ .G$.INPUT;
  }
  initializeNode() {
    this.io.inputs.setCount(0);
    this.lifecycle.onAfterAdded(() => {
      this._setParentInputDependency();
    });
  }
  cook() {
    return __async(this, null, function* () {
      const inputIndex = this.pv.input;
      const parent = this.parent();
      if (!parent) {
        this.states.error.set(`subnet input has no parent`);
        return this.cookController.endCook();
      }
      if (!parent.io.inputs.hasInput(inputIndex)) {
        this.states.error.set(`parent has no input ${inputIndex}`);
        return this.cookController.endCook();
      }
      const container = yield parent.containerController.requestInputContainer(inputIndex);
      if (!container) {
        this.states.error.set(`input invalid ${inputIndex}`);
        return this.cookController.endCook();
      }
      const coreGroup = container.coreContent();
      if (!coreGroup) {
        this.states.error.set(`input invalid ${inputIndex}`);
        return this.cookController.endCook();
      }
      this.setCoreGroup(coreGroup);
    });
  }
  static PARAM_CALLBACK_reset(node) {
    node._setParentInputDependency();
  }
  _setParentInputDependency() {
    if (this._currentParentInputGraphNode) {
      this.removeGraphInput(this._currentParentInputGraphNode);
    }
    const parent = this.parent();
    if (parent) {
      this._currentParentInputGraphNode = parent.io.inputs.inputGraphNode(this.pv.input);
      this.addGraphInput(this._currentParentInputGraphNode);
    }
  }
}


/***/ }),

/***/ 69235:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "k": function() { return /* binding */ TangentSopNode; }
/* harmony export */ });
/* harmony import */ var _Base__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(55839);
/* harmony import */ var _operations_sop_Tangent__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(70388);
/* harmony import */ var _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(96949);
/* harmony import */ var _poly_registers_nodes_types_Sop__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(58986);





const DEFAULT = _operations_sop_Tangent__WEBPACK_IMPORTED_MODULE_0__/* .TangentSopOperation.DEFAULT_PARAMS */ .LL.DEFAULT_PARAMS;
class TangentSopParamsConfig extends _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .NodeParamsConfig */ .yI {
  constructor() {
    super(...arguments);
    /** @param select which objects this applies the actor behavior to */
    this.group = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .ParamConfig.STRING */ .XC.STRING(DEFAULT.group, {
      objectMask: true
    });
    /** @param mode */
    this.mode = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .ParamConfig.INTEGER */ .XC.INTEGER(DEFAULT.mode, {
      menu: {
        entries: _operations_sop_Tangent__WEBPACK_IMPORTED_MODULE_0__/* .TANGENT_MODES.map */ .t3.map((name, value) => ({ name, value }))
      }
    });
    /** @param closed */
    this.closed = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .ParamConfig.BOOLEAN */ .XC.BOOLEAN(DEFAULT.closed, {
      visibleIf: { mode: _operations_sop_Tangent__WEBPACK_IMPORTED_MODULE_0__/* .TANGENT_MODES.indexOf */ .t3.indexOf(_operations_sop_Tangent__WEBPACK_IMPORTED_MODULE_0__/* .TangentMode.CURVE */ .cG.CURVE) }
    });
    /** @param tangent attribute name */
    this.tangentName = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .ParamConfig.STRING */ .XC.STRING(DEFAULT.tangentName, {
      visibleIf: { mode: _operations_sop_Tangent__WEBPACK_IMPORTED_MODULE_0__/* .TANGENT_MODES.indexOf */ .t3.indexOf(_operations_sop_Tangent__WEBPACK_IMPORTED_MODULE_0__/* .TangentMode.CURVE */ .cG.CURVE) }
    });
  }
}
const ParamsConfig = new TangentSopParamsConfig();
class TangentSopNode extends _Base__WEBPACK_IMPORTED_MODULE_2__/* .TypedSopNode */ .x {
  constructor() {
    super(...arguments);
    this.paramsConfig = ParamsConfig;
  }
  static type() {
    return _poly_registers_nodes_types_Sop__WEBPACK_IMPORTED_MODULE_3__/* .SopType.TANGENT */ .aB.TANGENT;
  }
  initializeNode() {
    this.io.inputs.setCount(0, 1);
    this.io.inputs.initInputsClonedState(_operations_sop_Tangent__WEBPACK_IMPORTED_MODULE_0__/* .TangentSopOperation.INPUT_CLONED_STATE */ .LL.INPUT_CLONED_STATE);
  }
  cook(inputCoreGroups) {
    this._operation = this._operation || new _operations_sop_Tangent__WEBPACK_IMPORTED_MODULE_0__/* .TangentSopOperation */ .LL(this._scene, this.states, this);
    const coreGroup = this._operation.cook(inputCoreGroups, this.pv);
    this.setCoreGroup(coreGroup);
  }
  setMode(mode) {
    this.p.mode.set(_operations_sop_Tangent__WEBPACK_IMPORTED_MODULE_0__/* .TANGENT_MODES.indexOf */ .t3.indexOf(mode));
  }
}


/***/ }),

/***/ 78925:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {


// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  "i": function() { return /* binding */ TetrahedralizeSopNode; }
});

// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/nodes/sop/_BaseTet.ts + 9 modules
var _BaseTet = __webpack_require__(49651);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/nodes/utils/params/ParamsConfig.ts
var ParamsConfig = __webpack_require__(96949);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/poly/registers/nodes/types/Sop.ts
var Sop = __webpack_require__(58986);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/node_modules/three/build/three.module.js
var three_module = __webpack_require__(21410);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/core/MapUtils.ts
var MapUtils = __webpack_require__(94158);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/core/geometry/modules/tet/TetCommon.ts
var TetCommon = __webpack_require__(98429);
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/core/geometry/modules/tet/utils/sortedIndices.ts

function sortedNumber3(index0, index1, index2, target) {
  if (index0 < index1) {
    if (index1 < index2) {
      target[0] = index0;
      target[1] = index1;
      target[2] = index2;
    } else {
      if (index0 < index2) {
        target[0] = index0;
        target[1] = index2;
        target[2] = index1;
      } else {
        target[0] = index2;
        target[1] = index0;
        target[2] = index1;
      }
    }
  } else {
    if (index0 < index2) {
      target[0] = index1;
      target[1] = index0;
      target[2] = index2;
    } else {
      if (index1 < index2) {
        target[0] = index1;
        target[1] = index2;
        target[2] = index0;
      } else {
        target[0] = index2;
        target[1] = index1;
        target[2] = index0;
      }
    }
  }
}
function sortedIndices(tetrahedron, facePointIndices, target) {
  const index0 = tetrahedron.pointIds[facePointIndices[0]];
  const index1 = tetrahedron.pointIds[facePointIndices[1]];
  const index2 = tetrahedron.pointIds[facePointIndices[2]];
  sortedNumber3(index0, index1, index2, target);
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/core/geometry/modules/tet/utils/tetNeighboursHelper.ts



const _sortedIndices = [0, 0, 0];
const _sortedIndicesNeighbour = [0, 0, 0];
function updateTetNeighboursFromNewTet(tetGeometry, tet) {
  for (let id0 = 0; id0 < 4; id0++) {
    const sharedPoint = tet.pointIds[id0];
    const tetsSharingPoint = tetGeometry.tetrahedronsByPointId.get(sharedPoint);
    let faceIndex = 0;
    for (const facePointIndices of TetCommon/* TET_FACE_POINT_INDICES */.Qb) {
      if (!tetsSharingPoint) {
        continue;
      }
      sortedNumber3(
        tet.pointIds[facePointIndices[0]],
        tet.pointIds[facePointIndices[1]],
        tet.pointIds[facePointIndices[2]],
        _sortedIndices
      );
      const [pt0, pt1, pt2] = _sortedIndices;
      tetsSharingPoint.forEach((tetId) => {
        if (tetId == tet.id) {
          return;
        }
        const tetSharingPoint = tetGeometry.tetrahedrons.get(tetId);
        if (!tetSharingPoint) {
          return;
        }
        let faceIndexNeighbour = 0;
        for (const facePointIndicesNeighbour of TetCommon/* TET_FACE_POINT_INDICES */.Qb) {
          sortedNumber3(
            tetSharingPoint.pointIds[facePointIndicesNeighbour[0]],
            tetSharingPoint.pointIds[facePointIndicesNeighbour[1]],
            tetSharingPoint.pointIds[facePointIndicesNeighbour[2]],
            _sortedIndicesNeighbour
          );
          const [ptN0, ptN1, ptN2] = _sortedIndicesNeighbour;
          if (pt0 == ptN0 && pt1 == ptN1 && pt2 == ptN2) {
            tet.neighbours[faceIndex] = { id: tetSharingPoint.id, faceIndex: faceIndexNeighbour };
            tetSharingPoint.neighbours[faceIndexNeighbour] = { id: tet.id, faceIndex };
          }
          faceIndexNeighbour++;
        }
      });
      faceIndex++;
    }
  }
}
function tetNeighbour(tetGeometry, tetId, faceIndex) {
  var _a;
  const tetrahedron = tetGeometry.tetrahedrons.get(tetId);
  if (!tetrahedron) {
    return;
  }
  return (_a = tetrahedron.neighbours[faceIndex]) == null ? void 0 : _a.id;
}

// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/core/geometry/modules/tet/utils/tetSphere.ts
var tetSphere = __webpack_require__(73134);
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/core/geometry/modules/tet/utils/tetTriangle.ts


function tetFaceTriangle(tetGeometry, tetId, faceIndex, target) {
  const tetrahedron = tetGeometry.tetrahedrons.get(tetId);
  if (!tetrahedron) {
    return;
  }
  const facePointIndices = TetCommon/* TET_FACE_POINT_INDICES */.Qb[faceIndex];
  const id0 = tetrahedron.pointIds[facePointIndices[0]];
  const id1 = tetrahedron.pointIds[facePointIndices[1]];
  const id2 = tetrahedron.pointIds[facePointIndices[2]];
  const pt0 = tetGeometry.points.get(id0);
  const pt1 = tetGeometry.points.get(id1);
  const pt2 = tetGeometry.points.get(id2);
  if (!(pt0 && pt1 && pt2)) {
    return;
  }
  target.a.copy(pt0.position);
  target.b.copy(pt1.position);
  target.c.copy(pt2.position);
}

// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/core/logger/Console.ts + 1 modules
var Console = __webpack_require__(69396);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/core/ObjectUtils.ts + 101 modules
var ObjectUtils = __webpack_require__(55237);
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/core/geometry/modules/tet/TetGeometry.ts









const _triangle = new three_module.Triangle();
const _triangleNormal = new three_module.Vector3();
const _newPointDelta = new three_module.Vector3();
class TetGeometry {
  constructor() {
    this.tetrahedrons = /* @__PURE__ */ new Map();
    this.points = /* @__PURE__ */ new Map();
    this.tetrahedronsByPointId = /* @__PURE__ */ new Map();
    this._nextPointId = -1;
    this._nextTetId = -1;
    this._pointsCount = 0;
    this._tetsCount = 0;
    this._lastAddedTetId = null;
    this.userData = {};
  }
  addPoint(x, y, z) {
    this._nextPointId++;
    const id = this._nextPointId;
    const point = {
      id,
      position: new three_module.Vector3(x, y, z)
    };
    this._pointsCount++;
    this.points.set(point.id, point);
    return id;
  }
  removePoint(pointId) {
    this.points.delete(pointId);
    this.tetrahedronsByPointId.delete(pointId);
    this._pointsCount--;
  }
  pointsCount() {
    return this._pointsCount;
  }
  tetsCount() {
    return this._tetsCount;
  }
  firstTetId() {
    return (0,MapUtils/* mapFirstKey */.Rz)(this.tetrahedrons);
  }
  lastAddedTetId() {
    return this._lastAddedTetId;
  }
  addTetrahedron(p0, p1, p2, p3) {
    if (p0 == p1 || p0 == p2 || p0 == p3 || p1 == p2 || p1 == p3 || p2 == p3) {
      console.warn("tetrahedron has duplicate points", p0, p1, p2, p3);
      return;
    }
    this._nextTetId++;
    const id = this._nextTetId;
    const _circumSphere = { center: new three_module.Vector3(), radius: 0 };
    (0,tetSphere/* circumSphere */.y)(this, p0, p1, p2, p3, _circumSphere);
    const tetrahedron = {
      id,
      pointIds: [p0, p1, p2, p3],
      neighbours: [null, null, null, null],
      sphere: _circumSphere,
      disposed: false
    };
    this.tetrahedrons.set(tetrahedron.id, tetrahedron);
    this._tetsCount++;
    this._lastAddedTetId = tetrahedron.id;
    for (const p of tetrahedron.pointIds) {
      let tetrahedrons = this.tetrahedronsByPointId.get(p);
      if (!tetrahedrons) {
        tetrahedrons = /* @__PURE__ */ new Set();
        this.tetrahedronsByPointId.set(p, tetrahedrons);
      }
      tetrahedrons.add(tetrahedron.id);
    }
    updateTetNeighboursFromNewTet(this, tetrahedron);
    return id;
  }
  removeTets(tetIds, sharedFacesNeighbourData, newPointPosition) {
    if (sharedFacesNeighbourData && newPointPosition) {
      sharedFacesNeighbourData.clear();
      for (const tetId of tetIds) {
        const tetrahedron = this.tetrahedrons.get(tetId);
        if (!tetrahedron) {
          continue;
        }
        let faceIndex = 0;
        for (const neighbourData of tetrahedron.neighbours) {
          if (neighbourData == null || !tetIds.includes(neighbourData.id)) {
            let faceAvailableOnSideOfNewPoint = true;
            if (neighbourData && neighbourData.id != null) {
              tetFaceTriangle(this, neighbourData.id, neighbourData.faceIndex, _triangle);
              _triangle.getNormal(_triangleNormal);
              _newPointDelta.copy(_triangle.a).sub(newPointPosition);
              if (_triangleNormal.dot(_newPointDelta) > 0) {
                faceAvailableOnSideOfNewPoint = false;
              }
            }
            if (faceAvailableOnSideOfNewPoint) {
              const pointIndices = TetCommon/* TET_FACE_POINT_INDICES */.Qb[faceIndex];
              sharedFacesNeighbourData.add({
                // faceIndex,
                pointIds: [
                  tetrahedron.pointIds[pointIndices[0]],
                  tetrahedron.pointIds[pointIndices[1]],
                  tetrahedron.pointIds[pointIndices[2]]
                ]
              });
            }
          }
          faceIndex++;
        }
      }
    }
    for (const tetId of tetIds) {
      const tetrahedron = this.tetrahedrons.get(tetId);
      if (!tetrahedron) {
        (0,Console/* logRedBg */.is)(`tet not found:${tetId} (${tetIds})`);
        throw `removeTets: tet not found ${tetId}`;
        continue;
      }
      for (const pointId of tetrahedron.pointIds) {
        const tetrahedrons = this.tetrahedronsByPointId.get(pointId);
        if (tetrahedrons) {
          tetrahedrons.delete(tetrahedron.id);
        }
      }
      for (const neighbourData of tetrahedron.neighbours) {
        if (neighbourData != null) {
          const neighbourTet = this.tetrahedrons.get(neighbourData.id);
          if (neighbourTet) {
            const neighbourFaceIndex = neighbourData.faceIndex;
            neighbourTet.neighbours[neighbourFaceIndex] = null;
          }
        }
      }
      tetrahedron.disposed = true;
      this.tetrahedrons.delete(tetId);
      this._tetsCount--;
    }
  }
  clone() {
    const clonedGeometry = new TetGeometry();
    this.points.forEach((point, id) => {
      clonedGeometry.points.set(id, {
        id: point.id,
        position: point.position.clone()
      });
    });
    this.tetrahedrons.forEach((tetrahedron, id) => {
      clonedGeometry.tetrahedrons.set(id, {
        id: tetrahedron.id,
        pointIds: tetrahedron.pointIds.map((id2) => id2),
        neighbours: tetrahedron.neighbours.map((d) => {
          if (!d) {
            return null;
          }
          const tetNeighbourData = {
            id: d.id,
            faceIndex: d.faceIndex
          };
          return tetNeighbourData;
        }),
        sphere: {
          center: tetrahedron.sphere.center.clone(),
          radius: tetrahedron.sphere.radius
        },
        disposed: tetrahedron.disposed
      });
    });
    this.tetrahedronsByPointId.forEach((tetrahedrons, id) => {
      clonedGeometry.tetrahedronsByPointId.set(id, new Set(tetrahedrons));
    });
    clonedGeometry._nextPointId = this._nextPointId;
    clonedGeometry._nextTetId = this._nextTetId;
    clonedGeometry._pointsCount = this._pointsCount;
    clonedGeometry._tetsCount = this._tetsCount;
    clonedGeometry._lastAddedTetId = this._lastAddedTetId;
    clonedGeometry.userData = (0,ObjectUtils/* objectCloneDeep */.qI)(this.userData);
    return clonedGeometry;
  }
  applyMatrix4(matrix) {
    this.points.forEach((point) => {
      point.position.applyMatrix4(matrix);
    });
    this.tetrahedrons.forEach((tetrahedron) => {
      (0,tetSphere/* circumSphere */.y)(
        this,
        tetrahedron.pointIds[0],
        tetrahedron.pointIds[1],
        tetrahedron.pointIds[2],
        tetrahedron.pointIds[3],
        tetrahedron.sphere
      );
    });
  }
  boundingBox(target) {
    this.points.forEach((point) => {
      target.expandByPoint(point.position);
    });
  }
  boundingSphere(target) {
    this.points.forEach((point) => {
      target.expandByPoint(point.position);
    });
  }
}

// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/core/geometry/modules/tet/utils/tetCenter.ts
var tetCenter = __webpack_require__(92671);
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/core/geometry/modules/tet/utils/findTetContainingPosition.ts





const _ray = new three_module.Ray();
const findTetContainingPosition_triangle = new three_module.Triangle();
const _intersectionTarget = new three_module.Vector3();
function findNextFaceIndex(tetGeometry, tetIndex, ray, intersectionTarget) {
  for (let faceIndex = 0; faceIndex < 4; faceIndex++) {
    tetFaceTriangle(tetGeometry, tetIndex, faceIndex, findTetContainingPosition_triangle);
    const intersection = ray.intersectTriangle(findTetContainingPosition_triangle.c, findTetContainingPosition_triangle.b, findTetContainingPosition_triangle.a, false, intersectionTarget);
    if (intersection != null) {
      if (intersection.distanceTo(ray.origin) <= ray.direction.length()) {
        return faceIndex;
      }
    }
  }
  return null;
}
function selectRandomUnvisitedTet(tetGeometry, visitedTets) {
  let selectedTetId = null;
  tetGeometry.tetrahedrons.forEach((tet, tetId) => {
    if (!visitedTets.has(tetId)) {
      selectedTetId = tetId;
    }
  });
  return selectedTetId;
}
const _stack = /* @__PURE__ */ new Set();
function findTetContainingPosition(tetGeometry, position, rayOrigin, tetIdOrigin) {
  _stack.clear();
  let foundTetId = tetIdOrigin;
  _stack.add(foundTetId);
  let i = 0;
  _ray.origin.copy(rayOrigin);
  _ray.direction.copy(position).sub(_ray.origin);
  const maxIterations = tetGeometry.tetsCount();
  while (i < maxIterations) {
    const nextFaceIndex = findNextFaceIndex(tetGeometry, foundTetId, _ray, _intersectionTarget);
    if (nextFaceIndex == null) {
      break;
    }
    const nextTetId = tetNeighbour(tetGeometry, foundTetId, nextFaceIndex);
    if (nextTetId == null) {
      const selectedTetId = selectRandomUnvisitedTet(tetGeometry, _stack);
      if (selectedTetId != null) {
        foundTetId = selectedTetId;
      }
    } else {
      foundTetId = nextTetId;
    }
    _stack.add(foundTetId);
    (0,tetCenter/* tetCenter */.Ah)(tetGeometry, foundTetId, _ray.origin);
    _ray.direction.copy(position).sub(_ray.origin);
    i++;
  }
  return foundTetId;
}

// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/core/geometry/modules/tet/utils/findNonDelaunayTets.ts
var findNonDelaunayTets = __webpack_require__(55291);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/core/geometry/modules/tet/utils/tetInsideMesh.ts
var tetInsideMesh = __webpack_require__(75118);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/core/SetUtils.ts
var SetUtils = __webpack_require__(55407);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/core/geometry/modules/tet/utils/tetRemoveUnusedPoints.ts
var tetRemoveUnusedPoints = __webpack_require__(61985);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/core/geometry/operation/Jitter.ts
var Jitter = __webpack_require__(48956);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/core/geometry/modules/tet/utils/tetQuality.ts
var tetQuality = __webpack_require__(45210);
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/core/geometry/modules/tet/utils/tetrahedralize.ts













const _v = new three_module.Vector3();
const _jitterOffset = new three_module.Vector3();
const _bboxSize = new three_module.Vector3();
const tetrahedralize_triangle = new three_module.Triangle();
const _faceNormal = new three_module.Vector3();
const _newPtDelta = new three_module.Vector3();
const _containingTetSearchRayOrigin = new three_module.Vector3();
const sharedFacesNeighbourData = /* @__PURE__ */ new Set();
const invalidTets = [];
const jitterMult = new three_module.Vector3(1, 1, 1);
function addPoint(tetGeometry, newPointPosition, searchStartPosition, tetIdOrigin, stage) {
  const tetId = findTetContainingPosition(tetGeometry, newPointPosition, searchStartPosition, tetIdOrigin);
  if (tetId == null) {
    return;
  }
  (0,findNonDelaunayTets/* findNonDelaunayTetsFromSinglePointCheck */.d)(tetGeometry, tetId, newPointPosition, invalidTets);
  tetGeometry.removeTets(invalidTets, sharedFacesNeighbourData, newPointPosition);
  _stage++;
  if (stage != null && _stage > stage) {
    return tetGeometry;
  }
  const pointId = tetGeometry.addPoint(newPointPosition.x, newPointPosition.y, newPointPosition.z);
  sharedFacesNeighbourData.forEach((sharedFacesNeighbourData2) => {
    _stage++;
    if (stage != null && _stage > stage) {
      return tetGeometry;
    }
    const id0 = sharedFacesNeighbourData2.pointIds[0];
    const id1 = sharedFacesNeighbourData2.pointIds[1];
    const id2 = sharedFacesNeighbourData2.pointIds[2];
    const pt0 = tetGeometry.points.get(id0);
    const pt1 = tetGeometry.points.get(id1);
    const pt2 = tetGeometry.points.get(id2);
    if (pt0 && pt1 && pt2) {
      tetrahedralize_triangle.a.copy(pt0.position);
      tetrahedralize_triangle.b.copy(pt1.position);
      tetrahedralize_triangle.c.copy(pt2.position);
      tetrahedralize_triangle.getNormal(_faceNormal);
      _newPtDelta.copy(newPointPosition).sub(tetrahedralize_triangle.a);
      const dot = _newPtDelta.dot(_faceNormal);
      if (dot > 0) {
        tetGeometry.addTetrahedron(id0, id1, id2, pointId);
      } else {
        tetGeometry.addTetrahedron(pointId, id0, id1, id2);
      }
    }
  });
  if (stage != null && _stage > stage) {
    return tetGeometry;
  }
}
const _outsideTestPos = new three_module.Vector3();
const _tetIds = [];
function finalize(options) {
  const { tetGeometry, mesh, deleteOutsideTets, minQuality } = options;
  const idsToDelete = /* @__PURE__ */ new Set();
  if (minQuality > 0) {
    tetGeometry.tetrahedrons.forEach((tet, tetId) => {
      if ((0,tetQuality/* tetQuality */.K)(tetGeometry, tetId) < minQuality) {
        idsToDelete.add(tetId);
      }
    });
  }
  if (deleteOutsideTets) {
    tetGeometry.tetrahedrons.forEach((tet, tetId) => {
      (0,tetCenter/* tetCenter */.Ah)(tetGeometry, tetId, _outsideTestPos);
      const isInside = (0,tetInsideMesh/* isPositionInsideMesh */.q)(_outsideTestPos, mesh, 1e-3);
      if (!isInside) {
        idsToDelete.add(tetId);
      }
    });
  }
  (0,SetUtils/* setToArray */.T_)(idsToDelete, _tetIds);
  tetGeometry.removeTets(_tetIds);
  return (0,tetRemoveUnusedPoints/* tetRemoveUnusedPoints */.B)(tetGeometry);
}
function prepareInputPoints(options) {
  const { mesh, innerPointsResolution, jitterAmount } = options;
  const { geometry } = mesh;
  const inputPoints = [];
  const geoPositionAttribute = geometry.attributes.position;
  const pointsCount = geoPositionAttribute.count;
  for (let i2 = 0; i2 < pointsCount; i2++) {
    const newPos = new three_module.Vector3();
    newPos.fromBufferAttribute(geoPositionAttribute, i2);
    inputPoints.push(newPos);
  }
  geometry.computeBoundingBox();
  if (!geometry.boundingBox) {
    return inputPoints;
  }
  const { min } = geometry.boundingBox;
  geometry.boundingBox.getSize(_bboxSize);
  const minDim = Math.min(_bboxSize.x, _bboxSize.y, _bboxSize.z);
  const minStep = minDim / innerPointsResolution;
  let i = 0;
  for (let xi = 0; xi < innerPointsResolution; xi++) {
    for (let yi = 0; yi < innerPointsResolution; yi++) {
      for (let zi = 0; zi < innerPointsResolution; zi++) {
        (0,Jitter/* jitterOffset */.K)(i, 11, jitterMult, jitterAmount, _jitterOffset);
        _v.set(xi, yi, zi).divideScalar(innerPointsResolution).multiply(_bboxSize).add(min).add(_jitterOffset);
        if ((0,tetInsideMesh/* isPositionInsideMesh */.q)(_v, mesh, minStep)) {
          inputPoints.push(_v.clone());
        }
        i++;
      }
    }
  }
  return inputPoints;
}
function getNearestPoint(inputPoints, inputPoint) {
  let nearestPoint;
  let nearestDistance = Infinity;
  inputPoints.forEach((point) => {
    const distance = point.distanceTo(inputPoint);
    if (distance < nearestDistance) {
      nearestDistance = distance;
      nearestPoint = point;
    }
  });
  return nearestPoint;
}
let _stage = 0;
function tetrahedralize(options) {
  var _a;
  _stage = 0;
  const { mesh, stage, deleteOutsideTets, minQuality } = options;
  const { geometry } = mesh;
  const tetGeometry = new TetGeometry();
  geometry.computeBoundingSphere();
  const radius = ((_a = geometry.boundingSphere) == null ? void 0 : _a.radius) || 1;
  const s = 5 * radius;
  _v.copy(TetCommon/* TET_VERTICES_V_BASE.0 */.rP[0]).multiplyScalar(s);
  const id0 = tetGeometry.addPoint(_v.x, _v.y, _v.z);
  _v.copy(TetCommon/* TET_VERTICES_V_BASE.1 */.rP[1]).multiplyScalar(s);
  const id1 = tetGeometry.addPoint(_v.x, _v.y, _v.z);
  _v.copy(TetCommon/* TET_VERTICES_V_BASE.2 */.rP[2]).multiplyScalar(s);
  const id2 = tetGeometry.addPoint(_v.x, _v.y, _v.z);
  _v.copy(TetCommon/* TET_VERTICES_V_BASE.3 */.rP[3]).multiplyScalar(s);
  const id3 = tetGeometry.addPoint(_v.x, _v.y, _v.z);
  const firstTetId = tetGeometry.addTetrahedron(id0, id1, id2, id3);
  if (firstTetId == null) {
    return tetGeometry;
  }
  _stage++;
  if (stage != null && _stage > stage) {
    return finalize({ tetGeometry, mesh, deleteOutsideTets, minQuality });
  }
  const inputPoints = new Set(prepareInputPoints(options));
  (0,tetCenter/* tetCenter */.Ah)(tetGeometry, firstTetId, _containingTetSearchRayOrigin);
  let tetIdOrigin = firstTetId;
  let inputPoint = (0,SetUtils/* setFirstValue */.$i)(inputPoints);
  while (inputPoint != null) {
    addPoint(tetGeometry, inputPoint, _containingTetSearchRayOrigin, tetIdOrigin, stage);
    const lastAddedTetId = tetGeometry.lastAddedTetId();
    if (lastAddedTetId != null) {
      (0,tetCenter/* tetCenter */.Ah)(tetGeometry, lastAddedTetId, _containingTetSearchRayOrigin);
      tetIdOrigin = lastAddedTetId;
    }
    _stage++;
    if (stage != null && _stage > stage) {
      return finalize({ tetGeometry, mesh, deleteOutsideTets, minQuality });
    }
    inputPoints.delete(inputPoint);
    inputPoint = getNearestPoint(inputPoints, inputPoint);
  }
  return finalize({ tetGeometry, mesh, deleteOutsideTets, minQuality });
}

// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/core/geometry/bvh/ThreeMeshBVHHelper.ts + 2 modules
var ThreeMeshBVHHelper = __webpack_require__(17862);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/core/geometry/operation/Fuse.ts
var Fuse = __webpack_require__(90651);
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/sop/Tetrahedralize.ts









const Tetrahedralize_jitterMult = new three_module.Vector3(1, 1, 1);
class TetrahedralizeSopParamsConfig extends ParamsConfig/* NodeParamsConfig */.yI {
  constructor() {
    super(...arguments);
    this.fuseDist = ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(1e-3);
    this.jitter = ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(1e-3);
    this.innerPointsResolution = ParamsConfig/* ParamConfig.INTEGER */.XC.INTEGER(5, {
      range: [0, 10]
    });
    this.minQuality = ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(0.25, {
      range: [0, 1],
      rangeLocked: [true, true]
    });
    this.stepByStep = ParamsConfig/* ParamConfig.BOOLEAN */.XC.BOOLEAN(0, {
      separatorBefore: true
    });
    this.step = ParamsConfig/* ParamConfig.INTEGER */.XC.INTEGER(-1, {
      range: [-1, 5e3],
      rangeLocked: [true, false],
      visibleIf: { stepByStep: 1 }
    });
    this.deleteOutsideTets = ParamsConfig/* ParamConfig.BOOLEAN */.XC.BOOLEAN(1, {
      visibleIf: { stepByStep: 1 }
    });
  }
}
const Tetrahedralize_ParamsConfig = new TetrahedralizeSopParamsConfig();
class TetrahedralizeSopNode extends _BaseTet/* TetSopNode */.k {
  constructor() {
    super(...arguments);
    this.paramsConfig = Tetrahedralize_ParamsConfig;
  }
  static type() {
    return Sop/* SopType.TETRAHEDRALIZE */.aB.TETRAHEDRALIZE;
  }
  initializeNode() {
    this.io.inputs.setCount(1);
  }
  cook(inputCoreGroups) {
    const coreGroup = inputCoreGroups[0];
    const inputMeshes = coreGroup.threejsObjectsWithGeo();
    for (const inputMesh of inputMeshes) {
      (0,Fuse/* mergeFaces */.X)(inputMesh.geometry, this.pv.fuseDist);
    }
    (0,Jitter/* jitterPositions */.x)(coreGroup, {
      amount: this.pv.jitter,
      mult: Tetrahedralize_jitterMult,
      seed: 0
    });
    const tetGeometries = [];
    for (const inputMesh of inputMeshes) {
      ThreeMeshBVHHelper/* ThreeMeshBVHHelper.assignDefaultBVHIfNone */.h.assignDefaultBVHIfNone(inputMesh);
      const tetGeometry = tetrahedralize({
        mesh: inputMesh,
        jitterAmount: this.pv.jitter,
        innerPointsResolution: this.pv.innerPointsResolution,
        minQuality: this.pv.minQuality,
        stage: this.pv.stepByStep ? this.pv.step >= 0 ? this.pv.step : null : null,
        deleteOutsideTets: this.pv.stepByStep ? this.pv.deleteOutsideTets : true
      });
      tetGeometries.push(tetGeometry);
    }
    this.setTetGeometries(tetGeometries);
  }
}


/***/ }),

/***/ 85224:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {


// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  "b": function() { return /* binding */ TetrahedronSopNode; }
});

// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/nodes/sop/_Base.ts
var _Base = __webpack_require__(55839);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/core/geometry/operation/Polyhedron.ts
var Polyhedron = __webpack_require__(39713);
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/core/geometry/operation/Tetrahedron.ts


class TetrahedronBufferGeometry extends Polyhedron/* PolyhedronBufferGeometry */.u {
  //{radius: number, detail:number}
  constructor(radius, detail, points_only) {
    const vertices = [1, 1, 1, -1, -1, 1, -1, 1, -1, 1, -1, -1];
    const indices = [2, 1, 0, 0, 3, 2, 1, 3, 0, 2, 3, 1];
    super(vertices, indices, radius, detail, points_only);
    this.type = "TetrahedronBufferGeometry";
    this.parameters = {
      radius,
      detail
    };
  }
}

// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/nodes/utils/params/ParamsConfig.ts
var ParamsConfig = __webpack_require__(96949);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/core/geometry/Constant.ts
var Constant = __webpack_require__(91568);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/poly/registers/nodes/types/Sop.ts
var Sop = __webpack_require__(58986);
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/sop/Tetrahedron.ts






class TetrahedronSopParamsConfig extends ParamsConfig/* NodeParamsConfig */.yI {
  constructor() {
    super(...arguments);
    /** @param radius of the tetrahedron */
    this.radius = ParamsConfig/* ParamConfig.FLOAT */.XC.FLOAT(1);
    /** @param resolution of the tetrahedron */
    this.detail = ParamsConfig/* ParamConfig.INTEGER */.XC.INTEGER(0, {
      range: [0, 10],
      rangeLocked: [true, false]
    });
    /** @param sets to create only points */
    this.pointsOnly = ParamsConfig/* ParamConfig.BOOLEAN */.XC.BOOLEAN(0);
    /** @param center of the tetrahedron */
    this.center = ParamsConfig/* ParamConfig.VECTOR3 */.XC.VECTOR3([0, 0, 0]);
  }
}
const Tetrahedron_ParamsConfig = new TetrahedronSopParamsConfig();
class TetrahedronSopNode extends _Base/* TypedSopNode */.x {
  constructor() {
    super(...arguments);
    this.paramsConfig = Tetrahedron_ParamsConfig;
  }
  static type() {
    return Sop/* SopType.TETRAHEDRON */.aB.TETRAHEDRON;
  }
  cook() {
    const pointsOnly = this.pv.pointsOnly;
    const geometry = new TetrahedronBufferGeometry(this.pv.radius, this.pv.detail, pointsOnly);
    geometry.translate(this.pv.center.x, this.pv.center.y, this.pv.center.z);
    if (pointsOnly) {
      const object = this.createObject(geometry, Constant/* ObjectType.POINTS */.LP.POINTS);
      this.setObject(object);
    } else {
      geometry.computeVertexNormals();
      this.setGeometry(geometry);
    }
  }
}


/***/ }),

/***/ 32495:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "U": function() { return /* binding */ TransformMultiSopNode; }
/* harmony export */ });
/* harmony import */ var _Base__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(55839);
/* harmony import */ var _core_Transform__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(87883);
/* harmony import */ var _poly_InputCloneMode__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(56752);
/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(21410);
/* harmony import */ var _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(96949);
/* harmony import */ var _poly_Assert__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(68239);
/* harmony import */ var _core_geometry_Attribute__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(32558);
/* harmony import */ var _poly_registers_nodes_types_Sop__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(58986);

var __defProp = Object.defineProperty;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};




const max_transform_count = 6;
const ROT_ORDER_DEFAULT = _core_Transform__WEBPACK_IMPORTED_MODULE_0__/* .ROTATION_ORDERS.indexOf */ .Is.indexOf(_core_Transform__WEBPACK_IMPORTED_MODULE_0__/* .RotationOrder.XYZ */ .tM.XYZ);
const ROT_ORDER_MENU_ENTRIES = {
  menu: {
    entries: _core_Transform__WEBPACK_IMPORTED_MODULE_0__/* .ROTATION_ORDERS.map */ .Is.map((order, v) => {
      return { name: order, value: v };
    })
  }
};
function visible_for_count(count) {
  const list = [];
  for (let i = count + 1; i <= max_transform_count; i++) {
    list.push({
      count: i
    });
  }
  return {
    visibleIf: list
  };
}




class TransformMultiSopParamConfig extends _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .NodeParamsConfig */ .yI {
  constructor() {
    super(...arguments);
    /** @param defines if this applies to objects or geometries */
    this.applyOn = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .ParamConfig.INTEGER */ .XC.INTEGER(_core_Transform__WEBPACK_IMPORTED_MODULE_0__/* .TRANSFORM_TARGET_TYPES.indexOf */ .Pr.indexOf(_core_Transform__WEBPACK_IMPORTED_MODULE_0__/* .TransformTargetType.GEOMETRY */ .dH.GEOMETRY), {
      menu: {
        entries: _core_Transform__WEBPACK_IMPORTED_MODULE_0__/* .TRANSFORM_TARGET_TYPES.map */ .Pr.map((target_type, i) => {
          return { name: target_type, value: i };
        })
      }
    });
    /** @param number of transformations this can apply */
    this.count = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .ParamConfig.INTEGER */ .XC.INTEGER(2, {
      range: [0, max_transform_count],
      rangeLocked: [true, true]
    });
    // 0
    /** @param transform 0 rotation order */
    this.rotationOrder0 = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .ParamConfig.INTEGER */ .XC.INTEGER(ROT_ORDER_DEFAULT, __spreadValues(__spreadValues({
      separatorBefore: true
    }, ROT_ORDER_MENU_ENTRIES), visible_for_count(0)));
    /** @param rotation 0 */
    this.r0 = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .ParamConfig.VECTOR3 */ .XC.VECTOR3([0, 0, 0], __spreadValues({}, visible_for_count(0)));
    // 1
    /** @param transform 1 rotation order */
    this.rotationOrder1 = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .ParamConfig.INTEGER */ .XC.INTEGER(ROT_ORDER_DEFAULT, __spreadValues(__spreadValues({
      separatorBefore: true
    }, ROT_ORDER_MENU_ENTRIES), visible_for_count(1)));
    /** @param rotation 1 */
    this.r1 = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .ParamConfig.VECTOR3 */ .XC.VECTOR3([0, 0, 0], __spreadValues({}, visible_for_count(1)));
    // 2
    /** @param transform 2 rotation order */
    this.rotationOrder2 = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .ParamConfig.INTEGER */ .XC.INTEGER(ROT_ORDER_DEFAULT, __spreadValues(__spreadValues({
      separatorBefore: true
    }, ROT_ORDER_MENU_ENTRIES), visible_for_count(2)));
    /** @param rotation 2 */
    this.r2 = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .ParamConfig.VECTOR3 */ .XC.VECTOR3([0, 0, 0], __spreadValues({}, visible_for_count(2)));
    // 3
    /** @param transform 3 rotation order */
    this.rotationOrder3 = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .ParamConfig.INTEGER */ .XC.INTEGER(ROT_ORDER_DEFAULT, __spreadValues(__spreadValues({
      separatorBefore: true
    }, ROT_ORDER_MENU_ENTRIES), visible_for_count(3)));
    /** @param rotation 3 */
    this.r3 = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .ParamConfig.VECTOR3 */ .XC.VECTOR3([0, 0, 0], __spreadValues({}, visible_for_count(3)));
    // 4
    /** @param transform 4 rotation order */
    this.rotationOrder4 = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .ParamConfig.INTEGER */ .XC.INTEGER(ROT_ORDER_DEFAULT, __spreadValues(__spreadValues({
      separatorBefore: true
    }, ROT_ORDER_MENU_ENTRIES), visible_for_count(4)));
    /** @param rotation 4 */
    this.r4 = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .ParamConfig.VECTOR3 */ .XC.VECTOR3([0, 0, 0], __spreadValues({}, visible_for_count(4)));
    // 5
    /** @param transform 5 rotation order */
    this.rotationOrder5 = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .ParamConfig.INTEGER */ .XC.INTEGER(ROT_ORDER_DEFAULT, __spreadValues(__spreadValues({
      separatorBefore: true
    }, ROT_ORDER_MENU_ENTRIES), visible_for_count(5)));
    /** @param rotation 5 */
    this.r5 = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .ParamConfig.VECTOR3 */ .XC.VECTOR3([0, 0, 0], __spreadValues({}, visible_for_count(5)));
  }
}
const ParamsConfig = new TransformMultiSopParamConfig();
class TransformMultiSopNode extends _Base__WEBPACK_IMPORTED_MODULE_2__/* .TypedSopNode */ .x {
  constructor() {
    super(...arguments);
    this.paramsConfig = ParamsConfig;
    this._core_transform = new _core_Transform__WEBPACK_IMPORTED_MODULE_0__/* .CoreTransform */ .ZR();
    this._t = new three__WEBPACK_IMPORTED_MODULE_3__.Vector3(0, 0, 0);
    this._s = new three__WEBPACK_IMPORTED_MODULE_3__.Vector3(1, 1, 1);
    this._scale = 1;
  }
  static type() {
    return _poly_registers_nodes_types_Sop__WEBPACK_IMPORTED_MODULE_4__/* .SopType.TRANSFORM_MULTI */ .aB.TRANSFORM_MULTI;
  }
  initializeNode() {
    this.io.inputs.setCount(1, 2);
    this.io.inputs.initInputsClonedState([_poly_InputCloneMode__WEBPACK_IMPORTED_MODULE_5__/* .InputCloneMode.FROM_NODE */ .m.FROM_NODE, _poly_InputCloneMode__WEBPACK_IMPORTED_MODULE_5__/* .InputCloneMode.NEVER */ .m.NEVER]);
  }
  _createRotAndIndexPairs() {
    return [
      [this.p.r0, this.p.rotationOrder0],
      [this.p.r1, this.p.rotationOrder1],
      [this.p.r2, this.p.rotationOrder2],
      [this.p.r3, this.p.rotationOrder3],
      [this.p.r4, this.p.rotationOrder4],
      [this.p.r5, this.p.rotationOrder5]
    ];
  }
  _rotAndIndexPairs() {
    return this.__rotAndIndexPairs = this.__rotAndIndexPairs || this._createRotAndIndexPairs();
  }
  cook(input_contents) {
    const objects = input_contents[0].threejsObjectsWithGeo();
    const src_object = input_contents[1] ? input_contents[1].threejsObjectsWithGeo()[0] : void 0;
    this._apply_transforms(objects, src_object);
    this.setObjects(objects);
  }
  _apply_transforms(objects, src_object) {
    const mode = _core_Transform__WEBPACK_IMPORTED_MODULE_0__/* .TRANSFORM_TARGET_TYPES */ .Pr[this.pv.applyOn];
    switch (mode) {
      case _core_Transform__WEBPACK_IMPORTED_MODULE_0__/* .TransformTargetType.GEOMETRY */ .dH.GEOMETRY: {
        return this._apply_matrix_to_geometries(objects, src_object);
      }
      case _core_Transform__WEBPACK_IMPORTED_MODULE_0__/* .TransformTargetType.OBJECT */ .dH.OBJECT: {
        return this._apply_matrix_to_objects(objects, src_object);
      }
    }
    _poly_Assert__WEBPACK_IMPORTED_MODULE_6__/* .TypeAssert.unreachable */ .f.unreachable(mode);
  }
  _apply_matrix_to_geometries(objects, src_object) {
    if (src_object) {
      const src_geometry = src_object.geometry;
      if (src_geometry) {
        const attributes_to_copy = [_core_geometry_Attribute__WEBPACK_IMPORTED_MODULE_7__/* .Attribute.POSITION */ .ah.POSITION, _core_geometry_Attribute__WEBPACK_IMPORTED_MODULE_7__/* .Attribute.NORMAL */ .ah.NORMAL, _core_geometry_Attribute__WEBPACK_IMPORTED_MODULE_7__/* .Attribute.TANGENT */ .ah.TANGENT];
        for (const attrib_name of attributes_to_copy) {
          const src = src_geometry.attributes[attrib_name];
          for (const object of objects) {
            const geometry = object.geometry;
            const dest = geometry.attributes[attrib_name];
            if (src && dest) {
              _core_geometry_Attribute__WEBPACK_IMPORTED_MODULE_7__/* .CoreAttribute.copy */ .n0.copy(src, dest);
            }
          }
        }
      }
    }
    let pair;
    for (let i = 0; i < this.pv.count; i++) {
      pair = this._rotAndIndexPairs()[i];
      const matrix = this._matrix(pair[0].value, pair[1].value);
      for (const object of objects) {
        object.geometry.applyMatrix4(matrix);
      }
    }
  }
  _apply_matrix_to_objects(objects, src_object) {
    if (src_object) {
      for (const object of objects) {
        object.matrix.copy(src_object.matrix);
        object.matrix.decompose(object.position, object.quaternion, object.scale);
      }
    }
    let pair;
    for (let i = 0; i < this.pv.count; i++) {
      pair = this._rotAndIndexPairs()[i];
      const matrix = this._matrix(pair[0].value, pair[1].value);
      for (const object of objects) {
        object.applyMatrix4(matrix);
      }
    }
  }
  _matrix(r, rot_order_index) {
    return this._core_transform.matrix(this._t, r, this._s, this._scale, _core_Transform__WEBPACK_IMPORTED_MODULE_0__/* .ROTATION_ORDERS */ .Is[rot_order_index]);
  }
}


/***/ }),

/***/ 94176:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "A": function() { return /* binding */ TransformResetSopNode; }
/* harmony export */ });
/* harmony import */ var _Base__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(55839);
/* harmony import */ var _operations_sop_TransformReset__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(28821);
/* harmony import */ var _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(96949);
/* harmony import */ var _poly_registers_nodes_types_Sop__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(58986);





const DEFAULT = _operations_sop_TransformReset__WEBPACK_IMPORTED_MODULE_0__/* .TransformResetSopOperation.DEFAULT_PARAMS */ .zd.DEFAULT_PARAMS;
class TransformResetSopParamConfig extends _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .NodeParamsConfig */ .yI {
  constructor() {
    super(...arguments);
    /** @param mode to reset the geometry and object */
    this.mode = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .ParamConfig.INTEGER */ .XC.INTEGER(DEFAULT.mode, {
      menu: {
        entries: _operations_sop_TransformReset__WEBPACK_IMPORTED_MODULE_0__/* .TRANSFORM_RESET_MODES.map */ .aT.map((target_type, i) => {
          return { name: target_type, value: i };
        })
      }
    });
  }
}
const ParamsConfig = new TransformResetSopParamConfig();
class TransformResetSopNode extends _Base__WEBPACK_IMPORTED_MODULE_2__/* .TypedSopNode */ .x {
  constructor() {
    super(...arguments);
    this.paramsConfig = ParamsConfig;
  }
  static type() {
    return _poly_registers_nodes_types_Sop__WEBPACK_IMPORTED_MODULE_3__/* .SopType.TRANSFORM_RESET */ .aB.TRANSFORM_RESET;
  }
  initializeNode() {
    this.io.inputs.setCount(1, 2);
    this.io.inputs.initInputsClonedState(_operations_sop_TransformReset__WEBPACK_IMPORTED_MODULE_0__/* .TransformResetSopOperation.INPUT_CLONED_STATE */ .zd.INPUT_CLONED_STATE);
  }
  setMode(mode) {
    this.p.mode.set(_operations_sop_TransformReset__WEBPACK_IMPORTED_MODULE_0__/* .TRANSFORM_RESET_MODES.indexOf */ .aT.indexOf(mode));
  }
  cook(inputCoreGroups) {
    this._operation = this._operation || new _operations_sop_TransformReset__WEBPACK_IMPORTED_MODULE_0__/* .TransformResetSopOperation */ .zd(this.scene(), this.states, this);
    const coreGroup = this._operation.cook(inputCoreGroups, this.pv);
    this.setCoreGroup(coreGroup);
  }
}


/***/ }),

/***/ 84960:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "a": function() { return /* binding */ TubeSopNode; }
/* harmony export */ });
/* harmony import */ var _Base__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(55839);
/* harmony import */ var _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(96949);
/* harmony import */ var _operations_sop_Tube__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(66115);
/* harmony import */ var _poly_registers_nodes_types_Sop__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(58986);





const DEFAULT = _operations_sop_Tube__WEBPACK_IMPORTED_MODULE_0__/* .TubeSopOperation.DEFAULT_PARAMS */ .M.DEFAULT_PARAMS;
const step = 1e-5;
class TubeSopParamsConfig extends _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .NodeParamsConfig */ .yI {
  constructor() {
    super(...arguments);
    /** @param if true, the tube is set with a single radius. If false, it uses a top and bottom radius */
    this.singleRadius = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .ParamConfig.BOOLEAN */ .XC.BOOLEAN(DEFAULT.singleRadius);
    /** @param  radius */
    this.radius = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .ParamConfig.FLOAT */ .XC.FLOAT(DEFAULT.radius, {
      range: [0, 2],
      visibleIf: { singleRadius: 1 }
    });
    /** @param top radius */
    this.radiusTop = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .ParamConfig.FLOAT */ .XC.FLOAT(DEFAULT.radiusTop, {
      range: [0, 2],
      visibleIf: { singleRadius: 0 }
    });
    /** @param bottom radius */
    this.radiusBottom = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .ParamConfig.FLOAT */ .XC.FLOAT(DEFAULT.radiusBottom, {
      range: [0, 2],
      visibleIf: { singleRadius: 0 }
    });
    /** @param tube height */
    this.height = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .ParamConfig.FLOAT */ .XC.FLOAT(DEFAULT.height, { range: [0, 1] });
    /** @param number of segments in the radial direction */
    this.segmentsRadial = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .ParamConfig.INTEGER */ .XC.INTEGER(DEFAULT.segmentsRadial, { range: [3, 50], rangeLocked: [true, false] });
    /** @param number of segments in the height direction */
    this.segmentsHeight = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .ParamConfig.INTEGER */ .XC.INTEGER(DEFAULT.segmentsHeight, { range: [1, 20], rangeLocked: [true, false] });
    /** @param adds caps */
    this.cap = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .ParamConfig.BOOLEAN */ .XC.BOOLEAN(1);
    /** @param center of the tube */
    this.center = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .ParamConfig.VECTOR3 */ .XC.VECTOR3([0, 0, 0]);
    /** @param direction of the tube */
    this.direction = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .ParamConfig.VECTOR3 */ .XC.VECTOR3([0, 0, 1]);
    /** @param if set to 1, you can then set the phiStart, phi_end, thetaStart and theta_end */
    this.open = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .ParamConfig.BOOLEAN */ .XC.BOOLEAN(DEFAULT.open);
    /** @param start of theta angle */
    this.thetaStart = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .ParamConfig.FLOAT */ .XC.FLOAT(DEFAULT.thetaStart, {
      visibleIf: { open: 1 },
      range: [0, Math.PI * 2],
      step
    });
    /** @param length of theta opening */
    this.thetaLength = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .ParamConfig.FLOAT */ .XC.FLOAT("$PI*2", {
      visibleIf: { open: 1 },
      range: [0, Math.PI * 2],
      step
    });
  }
}
const ParamsConfig = new TubeSopParamsConfig();
class TubeSopNode extends _Base__WEBPACK_IMPORTED_MODULE_2__/* .TypedSopNode */ .x {
  constructor() {
    super(...arguments);
    this.paramsConfig = ParamsConfig;
  }
  static type() {
    return _poly_registers_nodes_types_Sop__WEBPACK_IMPORTED_MODULE_3__/* .SopType.TUBE */ .aB.TUBE;
  }
  cook(input_contents) {
    this._operation = this._operation || new _operations_sop_Tube__WEBPACK_IMPORTED_MODULE_0__/* .TubeSopOperation */ .M(this._scene, this.states, this);
    const core_group = this._operation.cook(input_contents, this.pv);
    this.setCoreGroup(core_group);
  }
}


/***/ }),

/***/ 50142:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "f": function() { return /* binding */ UvUnwrapSopNode; }
/* harmony export */ });
/* harmony import */ var _Base__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(55839);
/* harmony import */ var _operations_sop_UvUnwrap__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(76057);
/* harmony import */ var _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(96949);
/* harmony import */ var _poly_registers_nodes_types_Sop__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(58986);

var __async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};




const DEFAULT = _operations_sop_UvUnwrap__WEBPACK_IMPORTED_MODULE_0__/* .UvUnwrapSopOperation.DEFAULT_PARAMS */ .m2.DEFAULT_PARAMS;
class UvUnwrapSopParamConfig extends _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .NodeParamsConfig */ .yI {
  constructor() {
    super(...arguments);
    /** @param method */
    this.method = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .ParamConfig.INTEGER */ .XC.INTEGER(DEFAULT.method, {
      menu: {
        entries: _operations_sop_UvUnwrap__WEBPACK_IMPORTED_MODULE_0__/* .UV_UNWRAP_METHODS.map */ .qp.map((name, value) => ({ name, value }))
      }
    });
    /** @param attribute to unwrap */
    this.uv = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .ParamConfig.STRING */ .XC.STRING(DEFAULT.uv);
    /** @param target texture resolution */
    this.resolution = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .ParamConfig.INTEGER */ .XC.INTEGER(DEFAULT.resolution, {
      range: [16, 4096],
      rangeLocked: [true, false],
      visibleIf: {
        method: _operations_sop_UvUnwrap__WEBPACK_IMPORTED_MODULE_0__/* .UV_UNWRAP_METHODS.indexOf */ .qp.indexOf(_operations_sop_UvUnwrap__WEBPACK_IMPORTED_MODULE_0__/* .UvUnwrapMethod.XATLAS */ .KG.XATLAS)
      }
    });
    /** @param padding */
    this.padding = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .ParamConfig.INTEGER */ .XC.INTEGER(DEFAULT.padding, {
      range: [0, 10],
      rangeLocked: [true, false],
      visibleIf: {
        method: _operations_sop_UvUnwrap__WEBPACK_IMPORTED_MODULE_0__/* .UV_UNWRAP_METHODS.indexOf */ .qp.indexOf(_operations_sop_UvUnwrap__WEBPACK_IMPORTED_MODULE_0__/* .UvUnwrapMethod.XATLAS */ .KG.XATLAS)
      }
    });
  }
}
const ParamsConfig = new UvUnwrapSopParamConfig();
class UvUnwrapSopNode extends _Base__WEBPACK_IMPORTED_MODULE_2__/* .TypedSopNode */ .x {
  constructor() {
    super(...arguments);
    this.paramsConfig = ParamsConfig;
  }
  static type() {
    return _poly_registers_nodes_types_Sop__WEBPACK_IMPORTED_MODULE_3__/* .SopType.UV_UNWRAP */ .aB.UV_UNWRAP;
  }
  initializeNode() {
    this.io.inputs.setCount(1);
    this.io.inputs.initInputsClonedState(_operations_sop_UvUnwrap__WEBPACK_IMPORTED_MODULE_0__/* .UvUnwrapSopOperation.INPUT_CLONED_STATE */ .m2.INPUT_CLONED_STATE);
  }
  cook(inputCoreGroups) {
    return __async(this, null, function* () {
      this._operation = this._operation || new _operations_sop_UvUnwrap__WEBPACK_IMPORTED_MODULE_0__/* .UvUnwrapSopOperation */ .m2(this.scene(), this.states, this);
      const coreGroup = yield this._operation.cook(inputCoreGroups, this.pv);
      this.setCoreGroup(coreGroup);
    });
  }
  setMethod(method) {
    this.p.method.set(_operations_sop_UvUnwrap__WEBPACK_IMPORTED_MODULE_0__/* .UV_UNWRAP_METHODS.indexOf */ .qp.indexOf(method));
  }
}


/***/ }),

/***/ 82140:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {


// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  "Q": function() { return /* binding */ WFCSolverSopNode; }
});

// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/nodes/sop/_Base.ts
var _Base = __webpack_require__(55839);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/nodes/utils/params/ParamsConfig.ts
var ParamsConfig = __webpack_require__(96949);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/poly/registers/nodes/types/Sop.ts
var Sop = __webpack_require__(58986);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/poly/InputCloneMode.ts
var InputCloneMode = __webpack_require__(56752);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/core/wfc/WFCTilesCollection.ts
var WFCTilesCollection = __webpack_require__(93683);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/core/wfc/WFCCommon.ts
var WFCCommon = __webpack_require__(86306);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/core/wfc/WFCConstant.ts
var WFCConstant = __webpack_require__(59184);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/core/wfc/WFCTileConfig.ts
var WFCTileConfig = __webpack_require__(21833);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/core/wfc/WFCAttributes.ts
var WFCAttributes = __webpack_require__(3869);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/core/geometry/Attribute.ts
var Attribute = __webpack_require__(32558);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/core/MapUtils.ts
var MapUtils = __webpack_require__(94158);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/core/ArrayUtils.ts
var ArrayUtils = __webpack_require__(87132);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/core/SetUtils.ts
var SetUtils = __webpack_require__(55407);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/core/geometry/modules/quad/graph/QuadGraphCommon.ts
var QuadGraphCommon = __webpack_require__(44264);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/core/math/_Module.ts
var _Module = __webpack_require__(27462);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/node_modules/three/build/three.module.js
var three_module = __webpack_require__(21410);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/core/geometry/modules/quad/graph/QuadGraph.ts + 2 modules
var QuadGraph = __webpack_require__(49197);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/core/geometry/modules/quad/QuadPrimitive.ts + 1 modules
var QuadPrimitive = __webpack_require__(10407);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/core/wfc/WFCUtils.ts
var WFCUtils = __webpack_require__(45370);
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/core/wfc/WFCFloorGraph.ts






const _v4 = new three_module.Vector4();
const DEFAULT_TILE_ID = "";
class WFCFloorGraph {
  //
  constructor(quadObject, floorIndex) {
    this.quadObject = quadObject;
    this.floorIndex = floorIndex;
    this._quadGraph = new QuadGraph/* QuadGraph */.X();
    this._quadNodeByQuadId = /* @__PURE__ */ new Map();
    this._allowedTileConfigsByQuadId = /* @__PURE__ */ new Map();
  }
  setupQuadNode(index, allTileConfigs) {
    const indices = this.quadObject.geometry.index;
    _v4.fromArray(indices, index * 4);
    const quadNode = this._quadGraph.addQuad(index, _v4.toArray());
    const { quadTileConfigs } = this.resetQuadNode(quadNode, allTileConfigs);
    return { quadNode, quadTileConfigs };
  }
  resetQuadNode(quadNode, allTileConfigs) {
    const index = quadNode.id;
    const _quadId = (0,WFCUtils/* quadId */.EZ)(this.quadObject, index);
    if (_quadId == null) {
      throw new Error(`attribute ${WFCAttributes/* WFCQuadAttribute.QUAD_ID */.eM.QUAD_ID} not found`);
    }
    const tileId = QuadPrimitive/* QuadPrimitive.hasAttribute */.C.hasAttribute(this.quadObject, WFCAttributes/* WFCQuadAttribute.TILE_ID */.eM.TILE_ID) ? QuadPrimitive/* QuadPrimitive.attribValue */.C.attribValue(this.quadObject, index, WFCAttributes/* WFCQuadAttribute.TILE_ID */.eM.TILE_ID) || DEFAULT_TILE_ID : DEFAULT_TILE_ID;
    const tileIds = tileId.trim().length > 0 ? tileId.split(" ") : [];
    const tileIdsSet = new Set(tileIds);
    const quadTileConfigs = tileIds.length > 0 ? allTileConfigs.filter((c) => tileIdsSet.has(c.tileId)) : [...allTileConfigs];
    this._allowedTileConfigsByQuadId.set(index, quadTileConfigs);
    this._quadNodeByQuadId.set(_quadId, quadNode);
    return { quadTileConfigs };
  }
  quadNodeFromId(quadId2) {
    return this._quadNodeByQuadId.get(quadId2);
  }
  quadNodeFromOtherQuadNode(otherGraphQuadNode) {
    const _quadId = (0,WFCUtils/* quadId */.EZ)(this.quadObject, otherGraphQuadNode.id);
    return this._quadNodeByQuadId.get(_quadId);
  }
  allowedTileConfigsForQuadNode(quadNode) {
    return this._allowedTileConfigsByQuadId.get(quadNode.id);
  }
  setAllowedTileConfigsForQuadNode(quadNode, tileConfigs) {
    this._allowedTileConfigsByQuadId.set(quadNode.id, tileConfigs);
  }
  neighbourData(quadId2, sideIndex, target) {
    this._quadGraph.neighbourData(quadId2, sideIndex, target);
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/core/wfc/WFCTileConfigSampler.ts



class WFCTileConfigSampler {
  constructor() {
    this._cumulativeWeights = [];
    this._totalWeight = 0;
    this._tileConfigs = [];
  }
  setItemsAndWeights(tileConfigs, weights) {
    if (tileConfigs.length !== weights.length) {
      throw new Error("there must be as many weights as tileConfigs");
    }
    this._cumulativeWeights.length = 0;
    this._totalWeight = 0;
    for (const weight of weights) {
      this._totalWeight += weight;
      this._cumulativeWeights.push(this._totalWeight);
    }
    (0,ArrayUtils/* arrayCopy */.gc)(tileConfigs, this._tileConfigs);
  }
  sample(seed) {
    const randomWeight = (0,_Module/* randFloat */.Qy)(seed) * this._totalWeight;
    let index = 0;
    while (randomWeight >= this._cumulativeWeights[index]) {
      index++;
    }
    return this._tileConfigs[index];
  }
}

// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/core/geometry/CoreObjectFactory.ts
var CoreObjectFactory = __webpack_require__(17353);
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/core/wfc/WFCSolver.ts

















const _neighbourData = {
  quadNode: null,
  neighbourIndex: null
};
const _configStats = {
  solid: 0,
  empty: 0
};
const _entropiesSet = /* @__PURE__ */ new Set();
const _sortedEntropies = [];
const _tileConfigSampler = new WFCTileConfigSampler();
class WFCSolver {
  //
  constructor(options) {
    this._resolvedQuadsCount = 0;
    this._stepsCount = 0;
    this._quadPositionArrays = [];
    this._lowestEntropy = Number.POSITIVE_INFINITY;
    this._quadNodeByEntropy = /* @__PURE__ */ new Map();
    this._floorGraphs = [];
    this._quadIndicesByFloorIndex = /* @__PURE__ */ new Map();
    this._floorGraphIndexByQuadNode = /* @__PURE__ */ new Map();
    this._samplingWithWeightRequired = false;
    this._allTileConfigs = [];
    const { quadObject } = options;
    this._maxResolvedQuadsCount = options.maxResolvedQuadsCount;
    this._tilesCollection = new WFCTilesCollection/* WFCTilesCollection */.E(options);
    const tiles = this._tilesCollection.tiles();
    for (const tile of tiles) {
      const tileId = WFCAttributes/* CoreWFCTileAttribute.getTileId */.d7.getTileId(tile);
      if (tileId == WFCConstant/* EMPTY_TILE_ID */.Qs) {
        this._allTileConfigs.push({ tileId, rotation: 0 });
      } else {
        this._allTileConfigs.push({ tileId, rotation: 0 });
        this._allTileConfigs.push({ tileId, rotation: 1 });
        this._allTileConfigs.push({ tileId, rotation: 2 });
        this._allTileConfigs.push({ tileId, rotation: 3 });
      }
    }
    const weights = [];
    (0,ArrayUtils/* arrayUniq */.tt)(
      tiles.map((tile) => WFCAttributes/* CoreWFCTileAttribute.getWeight */.d7.getWeight(tile)),
      weights
    );
    if (weights.length > 1) {
      this._samplingWithWeightRequired = true;
    }
    const primitivesCount = QuadPrimitive/* QuadPrimitive.entitiesCount */.C.entitiesCount(quadObject);
    for (let i = 0; i < primitivesCount; i++) {
      const floorIndex = (0,WFCUtils/* quadPrimitiveFloorIndex */.Lz)(quadObject, i);
      (0,MapUtils/* addToSetAtEntry */.D)(this._quadIndicesByFloorIndex, floorIndex, i);
    }
    const solvedTileConfigs = new Array(primitivesCount).fill("");
    const solvedTileIdsAttribute = {
      isString: true,
      array: solvedTileConfigs,
      itemSize: 1
    };
    QuadPrimitive/* QuadPrimitive.addAttribute */.C.addAttribute(quadObject, WFCAttributes/* WFCQuadAttribute.SOLVED_TILE_CONFIGS */.eM.SOLVED_TILE_CONFIGS, solvedTileIdsAttribute);
    this._quadIndicesByFloorIndex.forEach((quadIndices, floorIndex) => {
      this._quadPositionArrays[floorIndex] = quadObject.geometry.attributes[Attribute/* Attribute.POSITION */.ah.POSITION].array;
      const floorGraph = new WFCFloorGraph(quadObject, floorIndex);
      this._floorGraphs.push(floorGraph);
      for (const quadIndex of quadIndices) {
        this._setupQuadNode(floorGraph, quadIndex, this._allTileConfigs);
      }
    });
    this._solvedTileConfigs = this._setSolvedTileConfigs(quadObject);
  }
  _setSolvedTileConfigs(object) {
    const primitiveAttributes = (0,CoreObjectFactory/* corePrimitiveClassFactory */.um)(object).attributes(object);
    if (!primitiveAttributes) {
      console.error("no primitive attributes found", object);
      return [];
    }
    const solvedTileConfigAttribute = primitiveAttributes[WFCAttributes/* WFCQuadAttribute.SOLVED_TILE_CONFIGS */.eM.SOLVED_TILE_CONFIGS];
    if (!solvedTileConfigAttribute) {
      console.error(`primitive attribute ${WFCAttributes/* WFCQuadAttribute.SOLVED_TILE_CONFIGS */.eM.SOLVED_TILE_CONFIGS} not found`);
      return [];
    }
    return this._solvedTileConfigs = solvedTileConfigAttribute.array;
  }
  // objects(): Object3D[] {
  // 	return this._objects;
  // }
  _setupQuadNode(floorGraph, quadIndex, allTileConfigs) {
    if (!(0,WFCUtils/* isQuadNodeSolveAllowed */.bS)(floorGraph.quadObject, quadIndex)) {
      return;
    }
    const { quadNode, quadTileConfigs } = floorGraph.setupQuadNode(quadIndex, allTileConfigs);
    this._floorGraphIndexByQuadNode.set(quadNode, floorGraph.floorIndex);
    this._initQuadNodeEntropyCache(quadNode, quadTileConfigs);
  }
  _resetQuadNode(quadNode) {
    const floorGraph = this._floorGraph(quadNode);
    const { quadTileConfigs } = floorGraph.resetQuadNode(quadNode, this._allTileConfigs);
    this._initQuadNodeEntropyCache(quadNode, quadTileConfigs);
  }
  _initQuadNodeEntropyCache(quadNode, quadTileConfigs) {
    const entropy = quadTileConfigs.length;
    (0,MapUtils/* pushOnArrayAtEntry */.gs)(this._quadNodeByEntropy, entropy, quadNode);
    if (entropy < this._lowestEntropy) {
      this._lowestEntropy = entropy;
    }
  }
  //
  //
  //
  //
  //
  process(options, comparableQuadNodes) {
    const { stepsCount, quadSeed, configSeed } = options;
    if (stepsCount < 0) {
      let result = this.step(quadSeed, configSeed, comparableQuadNodes);
      while (result != false) {
        result = this.step(quadSeed, configSeed, comparableQuadNodes);
      }
    } else {
      for (let i = 0; i < stepsCount; i++) {
        const result = this.step(quadSeed, configSeed, comparableQuadNodes);
        if (result == false) {
          break;
        }
      }
    }
    this._commitConfigsAttributes();
  }
  step(quadSeed, configSeed, comparableQuadNodes) {
    this._stepsCount++;
    const quadNode = this._quadNodeWithLowestEntropy(quadSeed + this._stepsCount);
    if (!quadNode) {
      return false;
    }
    const floorGraph = this._floorGraph(quadNode);
    const allowedConfigs = floorGraph.allowedTileConfigsForQuadNode(quadNode);
    if (!(allowedConfigs && allowedConfigs.length > 0)) {
      return;
    }
    const updatedEntropy = this._reduceEntropyWithCache(quadNode, allowedConfigs, comparableQuadNodes);
    if (!(allowedConfigs && allowedConfigs.length > 0)) {
      (0,MapUtils/* popFromArrayAtEntry */.yW)(this._quadNodeByEntropy, updatedEntropy, quadNode);
      this._placeErrorTileObject(quadNode);
      return;
    }
    (0,WFCCommon/* configTilesStats */.JJ)(allowedConfigs, _configStats);
    const config = _configStats.solid == 0 ? allowedConfigs[0] : this._selectConfig(allowedConfigs, configSeed + this._stepsCount);
    floorGraph.setAllowedTileConfigsForQuadNode(quadNode, [config]);
    this._approveConfigForQuad(quadNode, config);
    this._updateNeighboursEntropy(quadNode);
  }
  addSoftContraint(options) {
    const { object, floorId, quadId, tileId, rotation } = options;
    this._setSolvedTileConfigs(object);
    const floorGraph = this._floorGraphs[floorId];
    const quadNode = floorGraph.quadNodeFromId(quadId);
    if (!quadNode) {
      return;
    }
    const config = {
      tileId,
      rotation
    };
    floorGraph.setAllowedTileConfigsForQuadNode(quadNode, [config]);
    this._approveConfigForQuad(quadNode, config);
    const resetQuadNodeIds = /* @__PURE__ */ new Set([quadNode]);
    this._resetAndUpdateNeighboursEntropy(quadNode, resetQuadNodeIds);
    this.process(options, resetQuadNodeIds);
  }
  //
  //
  //
  //
  //
  _solveReachMaxCount() {
    return this._maxResolvedQuadsCount >= 0 && this._resolvedQuadsCount >= this._maxResolvedQuadsCount;
  }
  _selectConfig(allowedConfigs, seed) {
    if (this._samplingWithWeightRequired) {
      _tileConfigSampler.setItemsAndWeights(
        allowedConfigs,
        allowedConfigs.map(
          (config) => WFCAttributes/* CoreWFCTileAttribute.getWeight */.d7.getWeight(this._tilesCollection.tile(config.tileId))
        )
      );
      return _tileConfigSampler.sample(seed);
    } else {
      return (0,ArrayUtils/* sample */.UP)((0,WFCCommon/* solidTilesStats */.Ve)(allowedConfigs), seed);
    }
  }
  _commitConfigsAttributes() {
    this._quadNodeByEntropy.forEach((quadNodes, entropy) => {
      for (const quadNode of quadNodes) {
        const floorGraph = this._floorGraph(quadNode);
        const allowedConfigs = floorGraph.allowedTileConfigsForQuadNode(quadNode);
        if (allowedConfigs) {
          this._commitConfigsAttributeToQuadPrimitive(quadNode, allowedConfigs);
        }
      }
    });
  }
  _placeErrorTileObject(quadNode) {
    this._commitConfigAttributeToQuadPrimitive(quadNode, WFCTileConfig/* ERRORED_TILE_CONFIG */.HM);
    this._resolvedQuadsCount++;
  }
  _approveConfigForQuad(quadNode, config) {
    this._commitConfigAttributeToQuadPrimitive(quadNode, config);
    this._resolvedQuadsCount++;
  }
  _commitConfigsAttributeToQuadPrimitive(quadNode, tileConfigs) {
    this._solvedTileConfigs[quadNode.id] = (0,WFCTileConfig/* tileConfigsToString */.QQ)(tileConfigs);
  }
  _commitConfigAttributeToQuadPrimitive(quadNode, tileConfig) {
    this._solvedTileConfigs[quadNode.id] = (0,WFCTileConfig/* tileConfigToString */._0)(tileConfig);
  }
  _updateNeighboursEntropy(startQuadNode) {
    const stack = [startQuadNode];
    while (stack.length > 0 && !this._solveReachMaxCount()) {
      const currentQuad = stack.pop();
      const floorIndex = this._floorGraphIndexByQuadNode.get(currentQuad);
      const floorGraph = this._floorGraphs[floorIndex];
      for (let i = 0; i < 4; i++) {
        floorGraph.neighbourData(currentQuad.id, i, _neighbourData);
        if (_neighbourData.quadNode && floorGraph.allowedTileConfigsForQuadNode(_neighbourData.quadNode).length > 1) {
          this._updateQuadEntropy(_neighbourData.quadNode, stack);
        }
      }
      const floorGraphAbove = this._floorGraphs[floorIndex + 1];
      if (floorGraphAbove) {
        const aboveQuad = floorGraphAbove.quadNodeFromOtherQuadNode(currentQuad);
        if (aboveQuad) {
          if (floorGraphAbove.allowedTileConfigsForQuadNode(aboveQuad).length > 1) {
            this._updateQuadEntropy(aboveQuad, stack);
          }
        }
      }
      const floorGraphBelow = this._floorGraphs[floorIndex - 1];
      if (floorGraphBelow) {
        const belowQuad = floorGraphBelow.quadNodeFromOtherQuadNode(currentQuad);
        if (belowQuad) {
          if (floorGraphBelow.allowedTileConfigsForQuadNode(belowQuad).length > 1) {
            this._updateQuadEntropy(belowQuad, stack);
          }
        }
      }
    }
  }
  _resetAndUpdateNeighboursEntropy(startQuadNode, resetQuadNodeIds) {
    const stack = [startQuadNode];
    while (stack.length > 0 && !this._solveReachMaxCount()) {
      const currentQuad = stack.pop();
      const floorIndex = this._floorGraphIndexByQuadNode.get(currentQuad);
      const floorGraph = this._floorGraphs[floorIndex];
      for (let i = 0; i < 4; i++) {
        floorGraph.neighbourData(currentQuad.id, i, _neighbourData);
        if (_neighbourData.quadNode) {
          this._resetQuadNodeEntropyIfNotReset(_neighbourData.quadNode, resetQuadNodeIds);
          if (floorGraph.allowedTileConfigsForQuadNode(_neighbourData.quadNode).length > 1) {
            this._updateQuadEntropy(_neighbourData.quadNode, stack, resetQuadNodeIds);
          }
        }
      }
      const floorGraphAbove = this._floorGraphs[floorIndex + 1];
      if (floorGraphAbove) {
        const aboveQuad = floorGraphAbove.quadNodeFromOtherQuadNode(currentQuad);
        if (aboveQuad) {
          this._resetQuadNodeEntropyIfNotReset(aboveQuad, resetQuadNodeIds);
          if (floorGraphAbove.allowedTileConfigsForQuadNode(aboveQuad).length > 1) {
            this._updateQuadEntropy(aboveQuad, stack, resetQuadNodeIds);
          }
        }
      }
      const floorGraphBelow = this._floorGraphs[floorIndex - 1];
      if (floorGraphBelow) {
        const belowQuad = floorGraphBelow.quadNodeFromOtherQuadNode(currentQuad);
        if (belowQuad) {
          this._resetQuadNodeEntropyIfNotReset(belowQuad, resetQuadNodeIds);
          if (floorGraphBelow.allowedTileConfigsForQuadNode(belowQuad).length > 1) {
            this._updateQuadEntropy(belowQuad, stack, resetQuadNodeIds);
          }
        }
      }
    }
  }
  _updateQuadEntropy(quadNode, stack, comparableQuadNodes) {
    if (this._solveReachMaxCount()) {
      return;
    }
    const floorGraph = this._floorGraph(quadNode);
    const allowedTileConfigs = floorGraph.allowedTileConfigsForQuadNode(quadNode);
    const updatedEntropy = this._reduceEntropyWithCache(quadNode, allowedTileConfigs, comparableQuadNodes);
    if (updatedEntropy === void 0) {
      return;
    }
    stack.push(quadNode);
    switch (updatedEntropy) {
      case 0: {
        (0,MapUtils/* popFromArrayAtEntry */.yW)(this._quadNodeByEntropy, updatedEntropy, quadNode);
        this._placeErrorTileObject(quadNode);
        return;
      }
      case 1: {
        (0,MapUtils/* popFromArrayAtEntry */.yW)(this._quadNodeByEntropy, updatedEntropy, quadNode);
        const config = allowedTileConfigs[0];
        this._approveConfigForQuad(quadNode, config);
        return;
      }
      default: {
      }
    }
  }
  _reduceEntropyWithCache(quadNode, allowedTileConfigs, comparableQuadNodes) {
    const previousEntropy = allowedTileConfigs.length;
    this._reduceEntropy(quadNode, allowedTileConfigs, comparableQuadNodes);
    const updatedEntropy = allowedTileConfigs.length;
    return this._setQuadNodeEntropyCache(quadNode, updatedEntropy, previousEntropy);
  }
  _setQuadNodeEntropyCache(quadNode, updatedEntropy, previousEntropy) {
    if (updatedEntropy == previousEntropy) {
      return;
    }
    (0,MapUtils/* popFromArrayAtEntry */.yW)(this._quadNodeByEntropy, previousEntropy, quadNode);
    (0,MapUtils/* pushOnArrayAtEntry */.gs)(this._quadNodeByEntropy, updatedEntropy, quadNode);
    if (updatedEntropy <= this._lowestEntropy) {
      this._lowestEntropy = updatedEntropy;
    }
    return updatedEntropy;
  }
  _resetQuadNodeEntropyIfNotReset(quadNode, resetQuadNodeIds) {
    if (resetQuadNodeIds.has(quadNode)) {
      return;
    }
    this._resetQuadNode(quadNode);
    resetQuadNodeIds.add(quadNode);
  }
  _reduceEntropy(quadNode, allowedTileConfigs, comparableQuadNodes) {
    let i = 0;
    while (i < allowedTileConfigs.length) {
      const allowed = this._checkConfigAgainstNeighbours(quadNode, allowedTileConfigs[i], comparableQuadNodes);
      if (allowed) {
        i++;
      } else {
        allowedTileConfigs.splice(i, 1);
      }
    }
    if (allowedTileConfigs.length > 1) {
      (0,WFCCommon/* configTilesStats */.JJ)(allowedTileConfigs, _configStats);
      switch (_configStats.solid) {
        case 0: {
          allowedTileConfigs.splice(1, allowedTileConfigs.length - 1);
          return;
        }
        case 1: {
          const _getIndex = () => {
            let index2 = 0;
            for (const tileConfig of allowedTileConfigs) {
              if (tileConfig.tileId != WFCConstant/* EMPTY_TILE_ID */.Qs) {
                return index2;
              }
              index2++;
            }
            return index2;
          };
          const index = _getIndex();
          allowedTileConfigs.splice(index + 1, allowedTileConfigs.length).splice(index - 1, index);
        }
      }
    }
  }
  _checkConfigAgainstNeighbours(quadNode, tileConfig, comparableQuadNodes) {
    if (!this._isConfigAllowedWithNeighbour(quadNode, tileConfig, 0, comparableQuadNodes)) {
      return false;
    }
    if (!this._isConfigAllowedWithNeighbour(quadNode, tileConfig, 1, comparableQuadNodes)) {
      return false;
    }
    if (!this._isConfigAllowedWithNeighbour(quadNode, tileConfig, 2, comparableQuadNodes)) {
      return false;
    }
    if (!this._isConfigAllowedWithNeighbour(quadNode, tileConfig, 3, comparableQuadNodes)) {
      return false;
    }
    if (!this._isConfigAllowedWithVerticalNeighbour(quadNode, tileConfig, -1, comparableQuadNodes)) {
      return false;
    }
    if (!this._isConfigAllowedWithVerticalNeighbour(quadNode, tileConfig, 1, comparableQuadNodes)) {
      return false;
    }
    return true;
  }
  _isConfigAllowedWithNeighbour(quadNode, tileConfig, neighbourIndex, comparableQuadNodes) {
    const presentedSide0 = QuadGraphCommon/* CCW_HALF_EDGE_SIDES */.jj[(0,_Module/* mod */.wQ)(neighbourIndex - tileConfig.rotation, 4)];
    const floorGraph = this._floorGraph(quadNode);
    floorGraph.neighbourData(quadNode.id, neighbourIndex, _neighbourData);
    if (!_neighbourData.quadNode || _neighbourData.neighbourIndex == null) {
      const isAllowed = this._tilesCollection.allowedTileConfig(
        tileConfig.tileId,
        presentedSide0,
        WFCConstant/* GRID_BORDER_ID */.hb,
        WFCConstant/* GRID_BORDER_SIDE_NAME */.bT
      );
      return isAllowed;
    }
    if (comparableQuadNodes) {
      if (!comparableQuadNodes.has(_neighbourData.quadNode)) {
        return true;
      }
    }
    const neighbourConfigs = floorGraph.allowedTileConfigsForQuadNode(_neighbourData.quadNode);
    if (neighbourConfigs.length == 0) {
      return true;
    }
    for (const neighbourConfig of neighbourConfigs) {
      const presentedSide1 = QuadGraphCommon/* CCW_HALF_EDGE_SIDES */.jj[(0,_Module/* mod */.wQ)(_neighbourData.neighbourIndex - neighbourConfig.rotation, 4)];
      const isAllowed = this._tilesCollection.allowedTileConfig(
        tileConfig.tileId,
        presentedSide0,
        neighbourConfig.tileId,
        presentedSide1
      );
      if (isAllowed) {
        return true;
      }
    }
    return false;
  }
  _isConfigAllowedWithVerticalNeighbour(quadNode, tileConfig, floorOffset, comparableQuadNodes) {
    const floorIndex = this._floorGraphIndexByQuadNode.get(quadNode);
    const presentedSide0 = floorOffset > 0 ? "t" : "b";
    const presentedSide1 = floorOffset > 0 ? "b" : "t";
    const neighbourFloorIndex = floorIndex + floorOffset;
    const neighbourFloorGraph = this._floorGraphs[neighbourFloorIndex];
    if (!neighbourFloorGraph) {
      const isAllowed = this._tilesCollection.allowedTileConfig(
        tileConfig.tileId,
        presentedSide0,
        WFCConstant/* GRID_BORDER_ID */.hb,
        WFCConstant/* GRID_BORDER_SIDE_NAME */.bT
      );
      return isAllowed;
    }
    const neighbourQuadNode = neighbourFloorGraph.quadNodeFromOtherQuadNode(quadNode);
    if (!neighbourQuadNode) {
      const isAllowed = this._tilesCollection.allowedTileConfig(
        tileConfig.tileId,
        presentedSide0,
        WFCConstant/* GRID_BORDER_ID */.hb,
        WFCConstant/* GRID_BORDER_SIDE_NAME */.bT
      );
      return isAllowed;
    }
    if (comparableQuadNodes) {
      if (!comparableQuadNodes.has(neighbourQuadNode)) {
        return true;
      }
    }
    const neighbourConfigs = neighbourFloorGraph.allowedTileConfigsForQuadNode(neighbourQuadNode);
    if (neighbourConfigs.length == 0) {
      return true;
    }
    for (const neighbourConfig of neighbourConfigs) {
      const isAllowed = this._tilesCollection.allowedTileConfig(
        tileConfig.tileId,
        presentedSide0,
        neighbourConfig.tileId,
        presentedSide1
      );
      if (isAllowed) {
        const isAllowedIfNeighbourEmptyOrSharesRotation = neighbourConfig.tileId == WFCConstant/* EMPTY_TILE_ID */.Qs || tileConfig.tileId == WFCConstant/* EMPTY_TILE_ID */.Qs || neighbourConfig.tileId == WFCConstant/* GRID_BORDER_ID */.hb || tileConfig.tileId == WFCConstant/* GRID_BORDER_ID */.hb || neighbourConfig.rotation == tileConfig.rotation;
        if (isAllowedIfNeighbourEmptyOrSharesRotation) {
          return true;
        }
      }
    }
    return false;
  }
  _quadNodeWithLowestEntropy(seed) {
    if (this._solveReachMaxCount()) {
      return;
    }
    let quadNodes = this._quadNodeByEntropy.get(this._lowestEntropy);
    while (quadNodes == null || quadNodes.length == 0) {
      this._quadNodeByEntropy.delete(this._lowestEntropy);
      _entropiesSet.clear();
      this._quadNodeByEntropy.forEach((quadNodes2, entropy) => {
        _entropiesSet.add(entropy);
      });
      (0,SetUtils/* setToArray */.T_)(_entropiesSet, _sortedEntropies);
      const sortedEntropies = _sortedEntropies.sort((a, b) => a - b);
      if (sortedEntropies.length == 0) {
        return;
      }
      this._lowestEntropy = sortedEntropies[0];
      quadNodes = this._quadNodeByEntropy.get(this._lowestEntropy);
    }
    if (!quadNodes) {
      return;
    }
    const quadNode = (0,ArrayUtils/* spliceSample */.CT)(quadNodes, seed);
    if (!quadNode) {
      return;
    }
    return quadNode;
  }
  _floorGraph(quadNode) {
    const floorIndex = this._floorGraphIndexByQuadNode.get(quadNode);
    return this._floorGraphs[floorIndex];
  }
}

// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/core/wfc/WFCRegister.ts
var WFCRegister = __webpack_require__(34263);
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/sop/WFCSolver.ts








class WFCSolverSopParamsConfig extends ParamsConfig/* NodeParamsConfig */.yI {
  constructor() {
    super(...arguments);
    /** @param iterations */
    this.stepsCount = ParamsConfig/* ParamConfig.INTEGER */.XC.INTEGER(-1, {
      range: [-1, 1e3],
      rangeLocked: [true, false]
    });
    /** @param max resolved quads */
    this.maxCount = ParamsConfig/* ParamConfig.INTEGER */.XC.INTEGER(-1, {
      range: [-1, 1e3],
      rangeLocked: [true, false],
      separatorAfter: true
    });
    /** @param quadSeed */
    this.quadSeed = ParamsConfig/* ParamConfig.INTEGER */.XC.INTEGER(0, {
      range: [-100, 100],
      rangeLocked: [false, false]
    });
    /** @param configSeed */
    this.configSeed = ParamsConfig/* ParamConfig.INTEGER */.XC.INTEGER(0, {
      range: [-100, 100],
      rangeLocked: [false, false]
    });
  }
}
const WFCSolver_ParamsConfig = new WFCSolverSopParamsConfig();
class WFCSolverSopNode extends _Base/* TypedSopNode */.x {
  constructor() {
    super(...arguments);
    this.paramsConfig = WFCSolver_ParamsConfig;
  }
  static type() {
    return Sop/* SopType.WFC_SOLVER */.aB.WFC_SOLVER;
  }
  initializeNode() {
    this.io.inputs.setCount(2);
    this.io.inputs.initInputsClonedState([InputCloneMode/* InputCloneMode.FROM_NODE */.m.FROM_NODE, InputCloneMode/* InputCloneMode.NEVER */.m.NEVER]);
  }
  cook(inputCoreGroups) {
    const coreGroup0 = inputCoreGroups[0];
    const coreGroup1 = inputCoreGroups[1];
    const quadObjects = coreGroup0.quadObjects();
    if (!quadObjects || quadObjects.length == 0) {
      this.states.error.set("no quad objects found");
      return;
    }
    const tileAndRuleObjects = coreGroup1.threejsObjects();
    const tileObjects = (0,WFCUtils/* filterTileObjects */.TF)(tileAndRuleObjects);
    const ruleObjects = (0,WFCUtils/* filterRuleObjects */.N7)(tileAndRuleObjects);
    if (tileObjects.length == 0) {
      this.states.error.set("no tile objects found");
      return;
    }
    if (ruleObjects.length == 0) {
      this.states.error.set("no rule objects found");
      return;
    }
    const { maxCount } = this.pv;
    for (const quadObject of quadObjects) {
      const solver = new WFCSolver({
        tileAndRuleObjects,
        quadObject,
        maxResolvedQuadsCount: maxCount
      });
      (0,WFCRegister/* registerWFCSolver */.tH)(solver, quadObject);
      solver.process(this.pv);
    }
    this.setObjects(quadObjects);
  }
  // public override updateObjectOnAdd(object: Object3D) {
  // 	console.log('updateObjectOnAdd', object);
  // 	console.log(getWFCsolver(object));
  // }
}


/***/ }),

/***/ 36524:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "P": function() { return /* binding */ WFCTileSideNameSopNode; }
/* harmony export */ });
/* harmony import */ var _Base__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(55839);
/* harmony import */ var _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(96949);
/* harmony import */ var _poly_registers_nodes_types_Sop__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(58986);
/* harmony import */ var _poly_InputCloneMode__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(56752);
/* harmony import */ var _core_wfc_WFCAttributes__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(3869);
/* harmony import */ var _core_geometry_Mask__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(58290);
/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(21410);
/* harmony import */ var _core_geometry_modules_three_builders_Merge__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(92276);
/* harmony import */ var _core_geometry_Constant__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(91568);
/* harmony import */ var _operations_sop_Base__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(82612);
/* harmony import */ var _core_Transform__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(87883);
/* harmony import */ var _core_geometry_Attribute__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(32558);

var __async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};












const DEFAULT_UP = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3(0, 1, 0);
const SOUTH_DIR = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3(-1, 0, 0);
const NORTH_DIR = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3(1, 0, 0);
const WEST_DIR = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3(0, 0, -1);
const EAST_DIR = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3(0, 0, 1);
const BOTTOM_DIR = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3(0, -1, 0);
const TOP_DIR = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3(0, 1, 0);
const _tmp = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();
class WFCTileSideNameSopParamsConfig extends _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .NodeParamsConfig */ .yI {
  constructor() {
    super(...arguments);
    /** @param group to assign the material to */
    this.group = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .ParamConfig.STRING */ .XC.STRING("", {
      objectMask: true
    });
    this.sameNameForSelectedSides = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .ParamConfig.BOOLEAN */ .XC.BOOLEAN(1);
    /** @param south side */
    this.south = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .ParamConfig.BOOLEAN */ .XC.BOOLEAN(0);
    this.southName = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .ParamConfig.STRING */ .XC.STRING("", {
      visibleIf: { sameNameForSelectedSides: 0, south: 1 }
    });
    /** @param north side */
    this.north = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .ParamConfig.BOOLEAN */ .XC.BOOLEAN(0);
    this.northName = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .ParamConfig.STRING */ .XC.STRING("", {
      visibleIf: { sameNameForSelectedSides: 0, north: 1 }
    });
    /** @param west side */
    this.west = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .ParamConfig.BOOLEAN */ .XC.BOOLEAN(0);
    this.westName = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .ParamConfig.STRING */ .XC.STRING("", {
      visibleIf: { sameNameForSelectedSides: 0, west: 1 }
    });
    /** @param east side */
    this.east = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .ParamConfig.BOOLEAN */ .XC.BOOLEAN(0);
    this.eastName = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .ParamConfig.STRING */ .XC.STRING("", {
      visibleIf: { sameNameForSelectedSides: 0, east: 1 }
    });
    /** @param bottom side */
    this.bottom = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .ParamConfig.BOOLEAN */ .XC.BOOLEAN(0);
    this.bottomName = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .ParamConfig.STRING */ .XC.STRING("", {
      visibleIf: { sameNameForSelectedSides: 0, bottom: 1 }
    });
    /** @param top side */
    this.top = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .ParamConfig.BOOLEAN */ .XC.BOOLEAN(0);
    this.topName = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .ParamConfig.STRING */ .XC.STRING("", {
      visibleIf: { sameNameForSelectedSides: 0, top: 1 }
    });
    /** @param allowedRotationY */
    this.sideName = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .ParamConfig.STRING */ .XC.STRING("", {
      visibleIf: { sameNameForSelectedSides: 1 }
    });
    /** @param highlight */
    this.highlight = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .ParamConfig.BOOLEAN */ .XC.BOOLEAN(false);
  }
}
const ParamsConfig = new WFCTileSideNameSopParamsConfig();
class WFCTileSideNameSopNode extends _Base__WEBPACK_IMPORTED_MODULE_2__/* .TypedSopNode */ .x {
  constructor() {
    super(...arguments);
    this.paramsConfig = ParamsConfig;
  }
  static type() {
    return _poly_registers_nodes_types_Sop__WEBPACK_IMPORTED_MODULE_3__/* .SopType.WFC_TILE_SIDE_NAME */ .aB.WFC_TILE_SIDE_NAME;
  }
  initializeNode() {
    this.io.inputs.setCount(1);
    this.io.inputs.initInputsClonedState(_poly_InputCloneMode__WEBPACK_IMPORTED_MODULE_4__/* .InputCloneMode.FROM_NODE */ .m.FROM_NODE);
  }
  cook(inputCoreGroups) {
    return __async(this, null, function* () {
      const coreGroup = inputCoreGroups[0];
      const objects = (0,_core_geometry_Mask__WEBPACK_IMPORTED_MODULE_5__/* .filterObjectsFromCoreGroup */ .sH)(coreGroup, this.pv);
      const { sameNameForSelectedSides, south, north, west, east, bottom, top } = this.pv;
      if (sameNameForSelectedSides == true) {
        const sideName = this.pv.sideName;
        for (const object of objects) {
          if (south) {
            _core_wfc_WFCAttributes__WEBPACK_IMPORTED_MODULE_6__/* .CoreWFCTileAttribute.setSideName */ .d7.setSideName(object, "s", sideName);
          }
          if (north) {
            _core_wfc_WFCAttributes__WEBPACK_IMPORTED_MODULE_6__/* .CoreWFCTileAttribute.setSideName */ .d7.setSideName(object, "n", sideName);
          }
          if (west) {
            _core_wfc_WFCAttributes__WEBPACK_IMPORTED_MODULE_6__/* .CoreWFCTileAttribute.setSideName */ .d7.setSideName(object, "w", sideName);
          }
          if (east) {
            _core_wfc_WFCAttributes__WEBPACK_IMPORTED_MODULE_6__/* .CoreWFCTileAttribute.setSideName */ .d7.setSideName(object, "e", sideName);
          }
          if (bottom) {
            _core_wfc_WFCAttributes__WEBPACK_IMPORTED_MODULE_6__/* .CoreWFCTileAttribute.setSideName */ .d7.setSideName(object, "b", sideName);
          }
          if (top) {
            _core_wfc_WFCAttributes__WEBPACK_IMPORTED_MODULE_6__/* .CoreWFCTileAttribute.setSideName */ .d7.setSideName(object, "t", sideName);
          }
        }
      } else {
        for (const object of objects) {
          if (south) {
            _core_wfc_WFCAttributes__WEBPACK_IMPORTED_MODULE_6__/* .CoreWFCTileAttribute.setSideName */ .d7.setSideName(object, "s", this.pv.southName);
          }
          if (north) {
            _core_wfc_WFCAttributes__WEBPACK_IMPORTED_MODULE_6__/* .CoreWFCTileAttribute.setSideName */ .d7.setSideName(object, "n", this.pv.northName);
          }
          if (west) {
            _core_wfc_WFCAttributes__WEBPACK_IMPORTED_MODULE_6__/* .CoreWFCTileAttribute.setSideName */ .d7.setSideName(object, "w", this.pv.westName);
          }
          if (east) {
            _core_wfc_WFCAttributes__WEBPACK_IMPORTED_MODULE_6__/* .CoreWFCTileAttribute.setSideName */ .d7.setSideName(object, "e", this.pv.eastName);
          }
          if (bottom) {
            _core_wfc_WFCAttributes__WEBPACK_IMPORTED_MODULE_6__/* .CoreWFCTileAttribute.setSideName */ .d7.setSideName(object, "b", this.pv.bottomName);
          }
          if (top) {
            _core_wfc_WFCAttributes__WEBPACK_IMPORTED_MODULE_6__/* .CoreWFCTileAttribute.setSideName */ .d7.setSideName(object, "t", this.pv.topName);
          }
        }
      }
      if (this.pv.highlight) {
        const geometries = [];
        if (south) {
          geometries.push(this._createHighlightPlane(SOUTH_DIR));
        }
        if (north) {
          geometries.push(this._createHighlightPlane(NORTH_DIR));
        }
        if (west) {
          geometries.push(this._createHighlightPlane(WEST_DIR));
        }
        if (east) {
          geometries.push(this._createHighlightPlane(EAST_DIR));
        }
        if (bottom) {
          geometries.push(this._createHighlightPlane(BOTTOM_DIR));
        }
        if (top) {
          geometries.push(this._createHighlightPlane(TOP_DIR));
        }
        const mergedGeometry = _core_geometry_modules_three_builders_Merge__WEBPACK_IMPORTED_MODULE_7__/* .CoreGeometryBuilderMerge.merge */ .O.merge(geometries);
        if (mergedGeometry) {
          const mergedObject = _operations_sop_Base__WEBPACK_IMPORTED_MODULE_8__/* .BaseSopOperation.createObject */ .U.createObject(mergedGeometry, _core_geometry_Constant__WEBPACK_IMPORTED_MODULE_9__/* .ObjectType.LINE_SEGMENTS */ .LP.LINE_SEGMENTS);
          objects.push(mergedObject);
        }
      }
      this.setObjects(objects);
    });
  }
  _createHighlightPlane(dir) {
    const geometry = new three__WEBPACK_IMPORTED_MODULE_0__.BufferGeometry();
    const positions = [];
    positions.push(-0.45, 0, -0.45);
    positions.push(0.45, 0, -0.45);
    positions.push(0.45, 0, 0.45);
    positions.push(-0.45, 0, 0.45);
    const indices = [];
    indices.push(0, 1, 1, 2, 2, 3, 3, 0);
    geometry.setAttribute(_core_geometry_Attribute__WEBPACK_IMPORTED_MODULE_10__/* .Attribute.POSITION */ .ah.POSITION, new three__WEBPACK_IMPORTED_MODULE_0__.Float32BufferAttribute(positions, 3));
    geometry.setIndex(indices);
    (0,_core_Transform__WEBPACK_IMPORTED_MODULE_11__/* .rotateGeometry */ .bP)(geometry, DEFAULT_UP, dir);
    _tmp.copy(dir).multiplyScalar(0.55);
    geometry.translate(_tmp.x, _tmp.y, _tmp.z);
    return geometry;
  }
}


/***/ }),

/***/ 70713:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "l": function() { return /* binding */ WFCTileTransformSopNode; }
/* harmony export */ });
/* harmony import */ var _Base__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(55839);
/* harmony import */ var _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(96949);
/* harmony import */ var _poly_registers_nodes_types_Sop__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(58986);
/* harmony import */ var _poly_InputCloneMode__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(56752);
/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(21410);

var __async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};





const _m4 = new three__WEBPACK_IMPORTED_MODULE_0__.Matrix4();
const _t = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();
const _q = new three__WEBPACK_IMPORTED_MODULE_0__.Quaternion();
const _s = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3(1, 1, 1);
const UP = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3(0, 1, 0);
class WFCTileTransformSopParamsConfig extends _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .NodeParamsConfig */ .yI {
  constructor() {
    super(...arguments);
    /** @param south / north  */
    this.sn = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .ParamConfig.INTEGER */ .XC.INTEGER(0, {
      range: [-2, 2],
      rangeLocked: [true, true]
    });
    /** @param west / east */
    this.we = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .ParamConfig.INTEGER */ .XC.INTEGER(0, {
      range: [-2, 2],
      rangeLocked: [true, true]
    });
    /** @param bottom / top */
    this.bt = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .ParamConfig.INTEGER */ .XC.INTEGER(0, {
      range: [-2, 2],
      rangeLocked: [true, true]
    });
    /** @param y rotation */
    this.ry = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .ParamConfig.INTEGER */ .XC.INTEGER(0, {
      range: [0, 3],
      rangeLocked: [true, true]
    });
  }
}
const ParamsConfig = new WFCTileTransformSopParamsConfig();
class WFCTileTransformSopNode extends _Base__WEBPACK_IMPORTED_MODULE_2__/* .TypedSopNode */ .x {
  constructor() {
    super(...arguments);
    this.paramsConfig = ParamsConfig;
  }
  static type() {
    return _poly_registers_nodes_types_Sop__WEBPACK_IMPORTED_MODULE_3__/* .SopType.WFC_TILE_TRANSFORM */ .aB.WFC_TILE_TRANSFORM;
  }
  initializeNode() {
    this.io.inputs.setCount(1);
    this.io.inputs.initInputsClonedState(_poly_InputCloneMode__WEBPACK_IMPORTED_MODULE_4__/* .InputCloneMode.FROM_NODE */ .m.FROM_NODE);
  }
  cook(inputCoreGroups) {
    return __async(this, null, function* () {
      const coreGroup = inputCoreGroups[0];
      const objects = coreGroup.allObjects();
      _t.set(this.pv.sn, this.pv.bt, this.pv.we);
      _q.setFromAxisAngle(UP, Math.PI * this.pv.ry * 0.5);
      _m4.compose(_t, _q, _s);
      for (const object of objects) {
        object.applyMatrix4(_m4);
      }
      this.setCoreGroup(coreGroup);
    });
  }
}


/***/ }),

/***/ 29540:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "p": function() { return /* binding */ TypedActorSopNode; }
/* harmony export */ });
/* harmony import */ var _Base__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(55839);
/* harmony import */ var _poly_NodeContext__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(52070);
/* harmony import */ var _poly_registers_assemblers_BaseRegister__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(33899);
/* harmony import */ var _Poly__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(99934);
/* harmony import */ var _js_code_assemblers_actor_ActorPersistedConfig__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(13320);
/* harmony import */ var _core_actor_ActorCompilationController__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(36642);







class TypedActorSopNode extends _Base__WEBPACK_IMPORTED_MODULE_0__/* .TypedSopNode */ .x {
  constructor() {
    super(...arguments);
    //
    // CHILDREN
    //
    this._childrenControllerContext = _poly_NodeContext__WEBPACK_IMPORTED_MODULE_1__/* .NodeContext.JS */ .sy.JS;
    //
    // ASSEMBLERS
    //
    this.persisted_config = new _js_code_assemblers_actor_ActorPersistedConfig__WEBPACK_IMPORTED_MODULE_2__/* .ActorPersistedConfig */ .R(this);
    this._assemblerController = this._createAssemblerController();
    //
    // compilation
    //
    this.compilationController = new _core_actor_ActorCompilationController__WEBPACK_IMPORTED_MODULE_3__/* .ActorCompilationController */ .z7(this);
  }
  createNode(node_class, options) {
    return super.createNode(node_class, options);
  }
  children() {
    return super.children();
  }
  nodesByType(type) {
    return super.nodesByType(type);
  }
  childrenAllowed() {
    if (this.assemblerController()) {
      return super.childrenAllowed();
    }
    return false;
  }
  sceneReadonly() {
    return this.assemblerController() == null;
  }
  assemblerController() {
    return this._assemblerController;
  }
  usedAssembler() {
    return _poly_registers_assemblers_BaseRegister__WEBPACK_IMPORTED_MODULE_4__/* .AssemblerName.JS_ACTOR */ .Q.JS_ACTOR;
  }
  _createAssemblerController() {
    return _Poly__WEBPACK_IMPORTED_MODULE_5__/* .Poly.assemblersRegister.assembler */ .L.assemblersRegister.assembler(this, this.usedAssembler());
  }
  compile() {
    this.compilationController.compile();
  }
  functionData() {
    return this.compilationController.functionData();
  }
  //
  // clean
  //
  updateObjectOnRemove(object, parent) {
    this.compilationController.evaluatorGenerator().disposeEvaluator(object);
  }
}


/***/ }),

/***/ 72290:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "O": function() { return /* binding */ CSGSopNode; }
/* harmony export */ });
/* unused harmony export BaseCSGSopNodeClass */
/* harmony import */ var _Base__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(55839);
/* harmony import */ var _core_geometry_modules_csg_CsgObject__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(12243);
/* harmony import */ var _core_geometry_Group__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(20999);
/* harmony import */ var _core_geometry_ObjectContent__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(91057);
/* harmony import */ var _poly_registers_modules_Common__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(26280);






class CSGSopNode extends _Base__WEBPACK_IMPORTED_MODULE_0__/* .TypedSopNode */ .x {
  dataType() {
    return _core_geometry_ObjectContent__WEBPACK_IMPORTED_MODULE_1__/* .CoreObjectType.CSG */ .JB.CSG;
  }
  requiredModules() {
    return [_poly_registers_modules_Common__WEBPACK_IMPORTED_MODULE_2__/* .ModuleName.CSG */ .r.CSG];
  }
  setCSGGeometry(geometry) {
    const objects = [new _core_geometry_modules_csg_CsgObject__WEBPACK_IMPORTED_MODULE_3__/* .CsgObject */ .V(geometry)];
    this._setContainerCsgObjects(objects);
  }
  setCSGGeometries(geometries) {
    const objects = geometries.map((g) => new _core_geometry_modules_csg_CsgObject__WEBPACK_IMPORTED_MODULE_3__/* .CsgObject */ .V(g));
    this._setContainerCsgObjects(objects);
  }
  setCSGObjects(csgObjects) {
    this._setContainerCsgObjects(csgObjects);
  }
  setCSGObject(csgObject) {
    this._setContainerCsgObjects([csgObject]);
  }
  _setContainerCsgObjects(objects) {
    const coreGroup = this.containerController.container().coreContent() || new _core_geometry_Group__WEBPACK_IMPORTED_MODULE_4__/* .CoreGroup */ .Q();
    coreGroup.setAllObjects(objects);
    this._setContainer(coreGroup);
  }
}
class BaseCSGSopNodeClass extends (/* unused pure expression or super */ null && (CSGSopNode)) {
}


/***/ }),

/***/ 84008:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Y": function() { return /* binding */ QuadSopNode; }
/* harmony export */ });
/* unused harmony export BaseCSGSopNodeClass */
/* harmony import */ var _Base__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(55839);
/* harmony import */ var _core_geometry_modules_quad_QuadObject__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(11714);
/* harmony import */ var _core_geometry_Group__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(20999);
/* harmony import */ var _core_geometry_ObjectContent__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(91057);
/* harmony import */ var _poly_registers_modules_Common__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(26280);






class QuadSopNode extends _Base__WEBPACK_IMPORTED_MODULE_0__/* .TypedSopNode */ .x {
  dataType() {
    return _core_geometry_ObjectContent__WEBPACK_IMPORTED_MODULE_1__/* .CoreObjectType.QUAD */ .JB.QUAD;
  }
  requiredModules() {
    return [_poly_registers_modules_Common__WEBPACK_IMPORTED_MODULE_2__/* .ModuleName.QUAD */ .r.QUAD];
  }
  setQuadGeometry(geometry) {
    const objects = [new _core_geometry_modules_quad_QuadObject__WEBPACK_IMPORTED_MODULE_3__/* .QuadObject */ .n(geometry)];
    this._setContainerQuadObjects(objects);
  }
  setQuadGeometries(geometries) {
    const objects = geometries.map((g) => new _core_geometry_modules_quad_QuadObject__WEBPACK_IMPORTED_MODULE_3__/* .QuadObject */ .n(g));
    this._setContainerQuadObjects(objects);
  }
  setQuadObjects(quadObjects) {
    this._setContainerQuadObjects(quadObjects);
  }
  setQuadObject(quadObject) {
    this._setContainerQuadObjects([quadObject]);
  }
  _setContainerQuadObjects(objects) {
    const coreGroup = this.containerController.container().coreContent() || new _core_geometry_Group__WEBPACK_IMPORTED_MODULE_4__/* .CoreGroup */ .Q();
    coreGroup.setAllObjects(objects);
    this._setContainer(coreGroup);
  }
}
class BaseCSGSopNodeClass extends (/* unused pure expression or super */ null && (QuadSopNode)) {
}


/***/ }),

/***/ 49651:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {


// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  "k": function() { return /* binding */ TetSopNode; }
});

// UNUSED EXPORTS: BaseTetSopNodeClass

// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/nodes/sop/_Base.ts
var _Base = __webpack_require__(55839);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/core/geometry/ObjectContent.ts
var ObjectContent = __webpack_require__(91057);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/core/Type.ts
var Type = __webpack_require__(19037);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/node_modules/three/build/three.module.js
var three_module = __webpack_require__(21410);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/operations/sop/_Base.ts
var sop_Base = __webpack_require__(82612);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/core/geometry/Constant.ts
var Constant = __webpack_require__(91568);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/core/geometry/modules/tet/TetCommon.ts
var TetCommon = __webpack_require__(98429);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/core/geometry/modules/tet/utils/tetSortPoints.ts
var tetSortPoints = __webpack_require__(50377);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/core/geometry/Attribute.ts
var Attribute = __webpack_require__(32558);
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/core/geometry/modules/tet/toObject3D/tetToOuterMesh.ts







const _p = new three_module.Vector3();
function tetToOuterMesh(tetGeometry, tesselationParams) {
  const { points, tetrahedrons } = tetGeometry;
  const newGeometry = new three_module.BufferGeometry();
  const pointIndexById = /* @__PURE__ */ new Map();
  (0,tetSortPoints/* tetSortPoints */.e)(tetGeometry, pointIndexById);
  let facesCount = 0;
  tetrahedrons.forEach((tet) => {
    for (const neighbourData of tet.neighbours) {
      if (neighbourData == null) {
        facesCount++;
      }
    }
  });
  const positions = new Array(tetGeometry.pointsCount() * 3);
  const ids = new Array(tetGeometry.pointsCount() * 1);
  const indices = new Array(facesCount * 3);
  let indicesCount = 0;
  points.forEach((point) => {
    _p.copy(point.position);
    const pointIndex = pointIndexById.get(point.id);
    if (pointIndex == null) {
      throw "pointIndex is null";
    }
    _p.toArray(positions, pointIndex * 3);
    ids[pointIndex] = pointIndex;
  });
  tetrahedrons.forEach((tet) => {
    let faceIndex = 0;
    for (const neighbourData of tet.neighbours) {
      if (neighbourData == null) {
        const faceIndices = TetCommon/* TET_FACE_POINT_INDICES */.Qb[faceIndex];
        const id0 = tet.pointIds[faceIndices[0]];
        const id1 = tet.pointIds[faceIndices[1]];
        const id2 = tet.pointIds[faceIndices[2]];
        const index0 = pointIndexById.get(id0);
        const index1 = pointIndexById.get(id1);
        const index2 = pointIndexById.get(id2);
        if (index0 == null || index1 == null || index2 == null) {
          throw "index is null";
        }
        indices[indicesCount] = index0;
        indices[indicesCount + 1] = index1;
        indices[indicesCount + 2] = index2;
        indicesCount += 3;
      }
      faceIndex++;
    }
  });
  newGeometry.setAttribute(Attribute/* Attribute.POSITION */.ah.POSITION, new three_module.Float32BufferAttribute(positions, 3));
  newGeometry.setAttribute(Attribute/* Attribute.ID */.ah.ID, new three_module.Float32BufferAttribute(ids, 1));
  newGeometry.setIndex(indices);
  newGeometry.computeVertexNormals();
  return sop_Base/* BaseSopOperation.createObject */.U.createObject(newGeometry, Constant/* ObjectType.MESH */.LP.MESH);
}

// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/core/geometry/modules/tet/utils/tetCenter.ts
var tetCenter = __webpack_require__(92671);
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/core/geometry/modules/tet/toObject3D/tetToTetMesh.ts






const _center = new three_module.Vector3();
const tetToTetMesh_p = new three_module.Vector3();
function tetToTetMesh(tetGeometry, tesselationParams) {
  const { scale } = tesselationParams;
  const { points, tetrahedrons } = tetGeometry;
  const newGeometry = new three_module.BufferGeometry();
  const positions = new Array(tetGeometry.tetsCount() * 4 * 3);
  const indices = new Array(tetGeometry.tetsCount() * 4 * 3);
  let positionsCount = 0;
  let indicesCount = 0;
  tetrahedrons.forEach((tet) => {
    (0,tetCenter/* tetCenter */.Ah)(tetGeometry, tet.id, _center);
    for (const face of TetCommon/* TET_FACE_POINT_INDICES */.Qb) {
      for (const facePointIndex of face) {
        const pointId = tet.pointIds[facePointIndex];
        const point = points.get(pointId);
        if (point) {
          tetToTetMesh_p.copy(point.position).sub(_center).multiplyScalar(scale).add(_center);
          tetToTetMesh_p.toArray(positions, positionsCount);
          positionsCount += 3;
        }
      }
      indices[indicesCount] = indicesCount;
      indices[indicesCount + 1] = indicesCount + 1;
      indices[indicesCount + 2] = indicesCount + 2;
      indicesCount += 3;
    }
  });
  newGeometry.setAttribute("position", new three_module.Float32BufferAttribute(positions, 3));
  newGeometry.setIndex(indices);
  newGeometry.computeVertexNormals();
  return sop_Base/* BaseSopOperation.createObject */.U.createObject(newGeometry, Constant/* ObjectType.MESH */.LP.MESH);
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/core/geometry/modules/tet/TetMaterial.ts


const MESH_MAT = new three_module.MeshStandardMaterial({
  color: 16777215,
  vertexColors: true,
  side: three_module.FrontSide,
  metalness: 0,
  roughness: 0.9
});
const LINES_MAT = new three_module.LineBasicMaterial({
  color: 16777215,
  linewidth: 1,
  vertexColors: true
});
const POINTS_MAT = new three_module.PointsMaterial({
  color: 16777215,
  size: 0.1,
  vertexColors: true
});
function tetMaterialMesh() {
  return MESH_MAT;
}
function tetMaterialLine() {
  return LINES_MAT;
}
function tetMaterialPoint() {
  return POINTS_MAT;
}

// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/core/math/_Module.ts
var _Module = __webpack_require__(27462);
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/core/geometry/modules/tet/toObject3D/tetToLines.ts







const tetToLines_center = new three_module.Vector3();
const tetToLines_p = new three_module.Vector3();
const _color = new three_module.Color();
function tetToLines(tetGeometry, tesselationParams) {
  const { scale } = tesselationParams;
  const { points, tetrahedrons } = tetGeometry;
  const lastAddedTetId = tetGeometry.lastAddedTetId();
  const newGeometry = new three_module.BufferGeometry();
  const positions = new Array(tetGeometry.tetsCount() * 4 * 3);
  const colors = new Array(tetGeometry.tetsCount() * 4 * 3);
  const indices = new Array(tetGeometry.tetsCount() * 6 * 2);
  let positionsCount = 0;
  let indicesCount = 0;
  let indexCount = 0;
  tetrahedrons.forEach((tet) => {
    (0,tetCenter/* tetCenter */.Ah)(tetGeometry, tet.id, tetToLines_center);
    const h = (0,_Module/* rand */.TN)(tet.id);
    _color.setHSL(h, lastAddedTetId == tet.id ? 0.1 : 1, lastAddedTetId == tet.id ? 1 : 0.5);
    indices[indicesCount] = indexCount;
    indices[indicesCount + 1] = indexCount + 1;
    indices[indicesCount + 2] = indexCount;
    indices[indicesCount + 3] = indexCount + 2;
    indices[indicesCount + 4] = indexCount;
    indices[indicesCount + 5] = indexCount + 3;
    indices[indicesCount + 6] = indexCount + 1;
    indices[indicesCount + 7] = indexCount + 2;
    indices[indicesCount + 8] = indexCount + 1;
    indices[indicesCount + 9] = indexCount + 3;
    indices[indicesCount + 10] = indexCount + 2;
    indices[indicesCount + 11] = indexCount + 3;
    for (let i = 0; i < 4; i++) {
      const pointId = tet.pointIds[i];
      const point = points.get(pointId);
      if (point) {
        tetToLines_p.copy(point.position).sub(tetToLines_center).multiplyScalar(scale).add(tetToLines_center);
        tetToLines_p.toArray(positions, positionsCount);
        _color.toArray(colors, positionsCount);
        positionsCount += 3;
      }
    }
    indicesCount += 12;
    indexCount += 4;
  });
  newGeometry.setAttribute("position", new three_module.Float32BufferAttribute(positions, 3));
  newGeometry.setAttribute("color", new three_module.Float32BufferAttribute(colors, 3));
  newGeometry.setIndex(indices);
  return sop_Base/* BaseSopOperation.createObject */.U.createObject(newGeometry, Constant/* ObjectType.LINE_SEGMENTS */.LP.LINE_SEGMENTS, tetMaterialLine());
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/core/geometry/modules/tet/toObject3D/tetToSharedFacesToLine.ts





const _center0 = new three_module.Vector3();
const _center1 = new three_module.Vector3();
const idPairs = /* @__PURE__ */ new Map();
function tetSharedFacesToLines(tetGeometry, tesselationParams) {
  idPairs.clear();
  let facesCount = 0;
  tetGeometry.tetrahedrons.forEach((tet) => {
    for (let i = 0; i < 4; i++) {
      const neighbour = tet.neighbours[i];
      if (neighbour != null) {
        const neighbourId = neighbour.id;
        const neighbourTet = tetGeometry.tetrahedrons.get(neighbourId);
        if (neighbourTet) {
          const key = tet.id < neighbourId ? tet.id : neighbourId;
          const value = tet.id < neighbourId ? neighbourId : tet.id;
          let set = idPairs.get(key);
          if (!set) {
            set = /* @__PURE__ */ new Set();
            idPairs.set(key, set);
          }
          if (!set.has(value)) {
            facesCount++;
          }
          set.add(value);
        }
      }
    }
  });
  const newGeometry = new three_module.BufferGeometry();
  const positions = new Array(facesCount * 2 * 3);
  const indices = new Array(facesCount * 1 * 2);
  let positionsCount = 0;
  let indicesCount = 0;
  let indexCount = 0;
  idPairs.forEach((neighbourIds, tetId) => {
    neighbourIds.forEach((neighbourId) => {
      (0,tetCenter/* tetCenter */.Ah)(tetGeometry, tetId, _center0);
      (0,tetCenter/* tetCenter */.Ah)(tetGeometry, neighbourId, _center1);
      indices[indicesCount] = indexCount;
      indices[indicesCount + 1] = indexCount + 1;
      _center0.toArray(positions, positionsCount);
      positionsCount += 3;
      _center1.toArray(positions, positionsCount);
      positionsCount += 3;
      indicesCount += 2;
      indexCount += 2;
    });
  });
  newGeometry.setAttribute("position", new three_module.Float32BufferAttribute(positions, 3));
  newGeometry.setIndex(indices);
  return sop_Base/* BaseSopOperation.createObject */.U.createObject(newGeometry, Constant/* ObjectType.LINE_SEGMENTS */.LP.LINE_SEGMENTS);
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/core/geometry/modules/tet/toObject3D/tetToPoints.ts






function tetToPoints(tetGeometry, tesselationParams) {
  const { points } = tetGeometry;
  const newGeometry = new three_module.BufferGeometry();
  const pointIndexById = /* @__PURE__ */ new Map();
  (0,tetSortPoints/* tetSortPoints */.e)(tetGeometry, pointIndexById);
  const positions = new Array(tetGeometry.pointsCount() * 1 * 3);
  const ids = new Array(tetGeometry.pointsCount() * 1);
  const indices = new Array(tetGeometry.pointsCount() * 1);
  points.forEach((point) => {
    const pointIndex = pointIndexById.get(point.id);
    if (pointIndex == null) {
      throw "pointIndex is null";
    }
    point.position.toArray(positions, pointIndex * 3);
    ids[pointIndex] = pointIndex;
    indices[pointIndex] = pointIndex;
  });
  newGeometry.setAttribute(Attribute/* Attribute.POSITION */.ah.POSITION, new three_module.Float32BufferAttribute(positions, 3));
  newGeometry.setAttribute(Attribute/* Attribute.ID */.ah.ID, new three_module.Float32BufferAttribute(ids, 1));
  newGeometry.setIndex(indices);
  return sop_Base/* BaseSopOperation.createObject */.U.createObject(newGeometry, Constant/* ObjectType.POINTS */.LP.POINTS);
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/core/geometry/modules/tet/toObject3D/tetToCenter.ts





const tetToCenter_center = new three_module.Vector3();
const tetToCenter_p = new three_module.Vector3();
function tetToCenter(tetGeometry, tesselationParams) {
  const { tetrahedrons } = tetGeometry;
  const newGeometry = new three_module.BufferGeometry();
  const positions = new Array(tetGeometry.tetsCount() * 1 * 3);
  const indices = new Array(tetGeometry.tetsCount() * 1);
  let positionsCount = 0;
  let indicesCount = 0;
  let indexCount = 0;
  tetrahedrons.forEach((tet) => {
    (0,tetCenter/* tetCircumCenter */.tJ)(tetGeometry, tet.id, tetToCenter_center);
    indices[indicesCount] = indexCount;
    tetToCenter_p.copy(tetToCenter_center);
    tetToCenter_p.toArray(positions, positionsCount);
    positionsCount += 3;
    indicesCount += 1;
    indexCount += 1;
  });
  newGeometry.setAttribute("position", new three_module.Float32BufferAttribute(positions, 3));
  newGeometry.setIndex(indices);
  return sop_Base/* BaseSopOperation.createObject */.U.createObject(newGeometry, Constant/* ObjectType.POINTS */.LP.POINTS);
}

// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/core/geometry/builders/SphereBuilder.ts
var SphereBuilder = __webpack_require__(26078);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/core/geometry/modules/three/builders/Merge.ts
var Merge = __webpack_require__(92276);
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/core/geometry/modules/tet/toObject3D/tetToSphere.ts





function tetToSphere(tetGeometry, tesselationParams) {
  const { tetrahedrons } = tetGeometry;
  const geometries = [];
  tetrahedrons.forEach((tet) => {
    const { radius, center } = tet.sphere;
    const geometry = SphereBuilder/* SphereBuilder.create */.A.create({
      radius,
      widthSegments: 32,
      heightSegments: 32,
      asLines: true,
      open: false
    });
    geometry.translate(center.x, center.y, center.z);
    geometries.push(geometry);
  });
  const mergedGeometry = Merge/* CoreGeometryBuilderMerge.merge */.O.merge(geometries);
  if (mergedGeometry) {
    return sop_Base/* BaseSopOperation.createObject */.U.createObject(mergedGeometry, Constant/* ObjectType.LINE_SEGMENTS */.LP.LINE_SEGMENTS);
  }
}

;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/core/geometry/modules/tet/TetObject.ts










class TetObject {
  constructor(_geometry) {
    this._geometry = _geometry;
    this.visible = true;
    this.parent = null;
    this.children = [];
    this.userData = {};
    this.name = "";
    this.castShadow = true;
    this.receiveShadow = true;
    this.renderOrder = 0;
    this.frustumCulled = true;
    this.matrixAutoUpdate = false;
  }
  get geometry() {
    return this._geometry;
  }
  get type() {
    return ObjectContent/* CoreObjectType.TET */.JB.TET;
  }
  setGeometry(geometry) {
    this._geometry = geometry;
  }
  tetGeometry() {
    return this.geometry;
  }
  dispose() {
  }
  applyMatrix4(matrix) {
    this.geometry.applyMatrix4(matrix);
  }
  add(...object) {
  }
  remove(...object) {
  }
  dispatchEvent(event) {
  }
  traverse(callback) {
    callback(this);
  }
  clone() {
    const geometry = this._geometry.clone();
    const clone = new TetObject(geometry);
    (0,ObjectContent/* objectContentCopyProperties */.Br)(this, clone);
    return clone;
  }
  toObject3D(tesselationParams) {
    const object = TetObject.toObject3D(this, tesselationParams);
    if (object) {
      if (Type/* CoreType.isArray */.MR.isArray(object)) {
        for (const element of object) {
          (0,ObjectContent/* objectContentCopyProperties */.Br)(this, element);
        }
      } else {
        (0,ObjectContent/* objectContentCopyProperties */.Br)(this, object);
      }
    }
    return object;
  }
  static toObject3D(tetObject, tesselationParams) {
    const objects = [];
    if (tesselationParams.displayOuterMesh) {
      objects.push(tetToOuterMesh(tetObject.tetGeometry(), tesselationParams));
    }
    if (tesselationParams.displayTetMesh) {
      objects.push(tetToTetMesh(tetObject.tetGeometry(), tesselationParams));
    }
    if (tesselationParams.displayLines) {
      objects.push(tetToLines(tetObject.tetGeometry(), tesselationParams));
    }
    if (tesselationParams.displaySharedFaces) {
      objects.push(tetSharedFacesToLines(tetObject.tetGeometry(), tesselationParams));
    }
    if (tesselationParams.displayPoints) {
      objects.push(tetToPoints(tetObject.tetGeometry(), tesselationParams));
    }
    if (tesselationParams.displayCenter) {
      objects.push(tetToCenter(tetObject.tetGeometry(), tesselationParams));
    }
    if (tesselationParams.displaySphere) {
      const spheres = tetToSphere(tetObject.tetGeometry(), tesselationParams);
      if (spheres) {
        objects.push(spheres);
      }
    }
    return objects;
  }
  boundingBox(target) {
    this.geometry.boundingBox(target);
  }
  boundingSphere(target) {
    this.geometry.boundingSphere(target);
  }
}

// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/core/geometry/Group.ts + 1 modules
var Group = __webpack_require__(20999);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/poly/registers/modules/Common.ts
var Common = __webpack_require__(26280);
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/nodes/sop/_BaseTet.ts






class TetSopNode extends _Base/* TypedSopNode */.x {
  dataType() {
    return ObjectContent/* CoreObjectType.TET */.JB.TET;
  }
  requiredModules() {
    return [Common/* ModuleName.TET */.r.TET];
  }
  setTetGeometry(geometry) {
    const objects = [new TetObject(geometry)];
    this._setContainerTetObjects(objects);
  }
  setTetGeometries(geometries) {
    const objects = geometries.map((g) => new TetObject(g));
    this._setContainerTetObjects(objects);
  }
  setTetObjects(tetObjects) {
    this._setContainerTetObjects(tetObjects);
  }
  setTetObject(tetObject) {
    this._setContainerTetObjects([tetObject]);
  }
  _setContainerTetObjects(objects) {
    const coreGroup = this.containerController.container().coreContent() || new Group/* CoreGroup */.Q();
    coreGroup.setAllObjects(objects);
    this._setContainer(coreGroup);
  }
}
class BaseTetSopNodeClass extends (/* unused pure expression or super */ null && (TetSopNode)) {
}


/***/ }),

/***/ 36993:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "w": function() { return /* binding */ updateCameraTransformParams; }
/* harmony export */ });
/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(21410);

var __async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};

const eulerArray = [0, 0, 0];
function updateCameraTransformParams(node) {
  return __async(this, null, function* () {
    const cameraName = node.p.name.value;
    const mask = `*/${cameraName}`;
    const object = node.scene().objectsController.findObjectByMask(mask);
    if (!object) {
      return;
    }
    node.p.position.set(object.position.toArray());
    object.rotation.toArray(eulerArray);
    eulerArray.forEach((e, i) => eulerArray[i] = three__WEBPACK_IMPORTED_MODULE_0__.MathUtils.radToDeg(e));
    node.p.rotation.set(eulerArray);
  });
}


/***/ }),

/***/ 51992:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "AE": function() { return /* binding */ BaseFileMultiSopNode; }
/* harmony export */ });
/* unused harmony exports BaseFileMultiSopNodeFactoryResult, BaseFileMultiParamsConfig */
/* harmony import */ var _poly_ParamEvent__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(98267);
/* harmony import */ var _Base__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(55839);
/* harmony import */ var _poly_InputCloneMode__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(56752);
/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(21410);
/* harmony import */ var _core_geometry_Instancer__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(23786);
/* harmony import */ var _Poly__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(99934);

var __async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};








const _points = [];
class BaseFileMultiParamsConfigResult extends (/* unused pure expression or super */ null && (NodeParamsConfig)) {
  constructor() {
    super(...arguments);
    this.url = ParamConfig.STRING("");
    this.matrixAutoUpdate = ParamConfig.BOOLEAN(0);
    this.reload = ParamConfig.BUTTON(null);
  }
}
class BaseFileMultiSopNodeFactoryResult extends (/* unused pure expression or super */ null && (TypedSopNode)) {
}
class BaseFileMultiParamsConfig extends (/* unused pure expression or super */ null && (NodeParamsConfig)) {
  constructor() {
    super(...arguments);
    /** @param url to load the geometry from */
    this.url = ParamConfig.STRING("", {
      fileBrowse: { extensions: [] },
      expression: { forEntities: true }
    });
    /** @param sets the matrixAutoUpdate attribute for the objects loaded */
    this.matrixAutoUpdate = ParamConfig.BOOLEAN(false);
    /** @param reload the geometry */
    this.reload = ParamConfig.BUTTON(null, {
      callback: (node) => {
        BaseFileMultiSopNode.PARAM_CALLBACK_reload(
          node
        );
      }
    });
  }
}
class BaseFileMultiSopNode extends _Base__WEBPACK_IMPORTED_MODULE_0__/* .TypedSopNode */ .x {
  constructor() {
    super(...arguments);
    this._instancer = new _core_geometry_Instancer__WEBPACK_IMPORTED_MODULE_1__/* .CoreInstancer */ .t();
    this._instanceMatrix = new three__WEBPACK_IMPORTED_MODULE_2__.Matrix4();
  }
  dispose() {
    super.dispose();
    _Poly__WEBPACK_IMPORTED_MODULE_3__/* .Poly.blobs.clearBlobsForNode */ .L.blobs.clearBlobsForNode(this);
  }
  initializeNode() {
    this.io.inputs.setCount(1);
    this.io.inputs.initInputsClonedState(_poly_InputCloneMode__WEBPACK_IMPORTED_MODULE_4__/* .InputCloneMode.NEVER */ .m.NEVER);
  }
  cook(inputCoreGroups) {
    return __async(this, null, function* () {
      const inputCoreGroup = inputCoreGroups[0];
      inputCoreGroup.points(_points);
      const urls = [];
      const urlByIndex = /* @__PURE__ */ new Map();
      const loadedResultByUrl = /* @__PURE__ */ new Map();
      const urlUsageCount = /* @__PURE__ */ new Map();
      const param = this.p.url;
      if (param.hasExpression() && param.expressionController) {
        const uniqueUrls = /* @__PURE__ */ new Set();
        const _applyUrlToPoint = (point, url) => {
          const index = point.index();
          if (urlByIndex.has(index)) {
            this.states.error.set(`input points have duplicate indices. Make sure to merge inputs together.`);
          } else {
            urlByIndex.set(index, url);
            uniqueUrls.add(url);
            BaseFileMultiSopNode._incrementUrlUsageCount(url, urlUsageCount);
          }
        };
        if (param.expressionController.entitiesDependent()) {
          yield param.expressionController.computeExpressionForPoints(_points, _applyUrlToPoint);
        } else {
          for (const point of _points) {
            _applyUrlToPoint(point, param.value);
          }
        }
        uniqueUrls.forEach((url) => {
          urls.push(url);
        });
      } else {
        const url = this.pv.url;
        urls.push(url);
        BaseFileMultiSopNode._incrementUrlUsageCount(url, urlUsageCount);
      }
      const loadedObjects = [];
      const promises = urls.map((url) => this._loadFromUrlPromises(url, loadedResultByUrl));
      yield Promise.all(promises);
      this._instancer.setCoreGroup(inputCoreGroup);
      for (const point of _points) {
        const index = point.index();
        const url = urlByIndex.get(index) || this.pv.url;
        this._instancer.matrixFromPoint(point, this._instanceMatrix);
        const usageCount = urlUsageCount.get(url) || 1;
        let parent = loadedResultByUrl.get(url);
        if (parent) {
          if (usageCount > 1) {
            parent = parent.clone();
          }
          parent.applyMatrix4(this._instanceMatrix);
          loadedObjects.push(parent);
        }
      }
      this.setObjects(loadedObjects);
    });
  }
  static _incrementUrlUsageCount(url, map) {
    const currentUsage = map.get(url);
    if (currentUsage != null) {
      map.set(url, currentUsage + 1);
    } else {
      map.set(url, 1);
    }
  }
  _loadFromUrlPromises(url, loadedResultByUrl) {
    return __async(this, null, function* () {
      const objects = yield this._loadObject(url);
      if (objects) {
        const parent = new three__WEBPACK_IMPORTED_MODULE_2__.Group();
        parent.matrixAutoUpdate = false;
        parent.name = url;
        for (const object of objects) {
          parent.add(object);
        }
        loadedResultByUrl.set(url, parent);
      }
    });
  }
  _loadObject(url) {
    const loader = this._createLoader(url);
    return this._loadWithLoader(loader);
  }
  _loadWithLoader(loader) {
    return loader.load({ node: this });
  }
  static PARAM_CALLBACK_reload(node) {
    node._paramCallbackReload();
  }
  _paramCallbackReload() {
    this.p.url.setDirty();
    this.p.url.emit(_poly_ParamEvent__WEBPACK_IMPORTED_MODULE_5__/* .ParamEvent.ASSET_RELOAD_REQUEST */ .X.ASSET_RELOAD_REQUEST);
  }
}


/***/ }),

/***/ 32842:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Sk": function() { return /* binding */ paletteControllerCallbackOptions; },
/* harmony export */   "qT": function() { return /* binding */ PaletteController; }
/* harmony export */ });
/* unused harmony export PaletteAbstractNode */
/* harmony import */ var _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(96949);
/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(21410);
/* harmony import */ var _core_color_chromotomeWrapper__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(89151);





const paletteControllerCallbackOptions = (method) => {
  return {
    callback: (node) => {
      method(node);
    }
  };
};
class PaletteController {
  constructor(node) {
    this.node = node;
  }
  static PARAM_CALLBACK_pickNext(node) {
    node.paletteController.PARAM_CALLBACK_pickNext();
  }
  static PARAM_CALLBACK_pickPrevious(node) {
    node.paletteController.PARAM_CALLBACK_pickPrevious();
  }
  static PARAM_CALLBACK_pickRandom(node) {
    node.paletteController.PARAM_CALLBACK_pickRandom();
  }
  static PARAM_CALLBACK_updateColors(node) {
    node.paletteController.PARAM_CALLBACK_updateColors();
  }
  PARAM_CALLBACK_pickNext() {
    const currentIndex = _core_color_chromotomeWrapper__WEBPACK_IMPORTED_MODULE_0__/* .SORTED_PALETTE_NAMES.indexOf */ .QK.indexOf(this.node.pv.paletteName);
    const nextIndex = currentIndex < _core_color_chromotomeWrapper__WEBPACK_IMPORTED_MODULE_0__/* .SORTED_PALETTE_NAMES.length */ .QK.length - 1 ? currentIndex + 1 : 0;
    this._batchUpdatesWithPalette(nextIndex);
  }
  PARAM_CALLBACK_pickPrevious() {
    const currentIndex = _core_color_chromotomeWrapper__WEBPACK_IMPORTED_MODULE_0__/* .SORTED_PALETTE_NAMES.indexOf */ .QK.indexOf(this.node.pv.paletteName);
    const previousIndex = currentIndex == 0 ? _core_color_chromotomeWrapper__WEBPACK_IMPORTED_MODULE_0__/* .SORTED_PALETTE_NAMES.length */ .QK.length - 1 : currentIndex - 1;
    this._batchUpdatesWithPalette(previousIndex);
  }
  PARAM_CALLBACK_pickRandom() {
    const randomIndex = Math.floor(Math.random() * _core_color_chromotomeWrapper__WEBPACK_IMPORTED_MODULE_0__/* .SORTED_PALETTE_NAMES.length */ .QK.length);
    this._batchUpdatesWithPalette(randomIndex);
  }
  _batchUpdatesWithPalette(paletteIndex) {
    const paletteName = _core_color_chromotomeWrapper__WEBPACK_IMPORTED_MODULE_0__/* .SORTED_PALETTE_NAMES */ .QK[paletteIndex];
    this.node.scene().batchUpdates(() => {
      this.node.p.paletteName.set(paletteName);
      this._updateColors();
    });
  }
  PARAM_CALLBACK_updateColors() {
    this.node.scene().batchUpdates(() => {
      this._updateColors();
    });
  }
  _updateColors() {
    const node = this.node;
    const name = node.pv.paletteName;
    const palette = _core_color_chromotomeWrapper__WEBPACK_IMPORTED_MODULE_0__/* .PALETTES_BY_NAME.get */ .Ct.get(name);
    const colorParams = [node.p.color1, node.p.color2, node.p.color3, node.p.color4, node.p.color5];
    node.p.colorsCount.set(palette.colors.length);
    for (let i = 0; i < palette.colors.length; i++) {
      const color = palette.colors[i];
      const param = colorParams[i];
      if (color && param) {
        _tmp_color.set(color);
        _tmp_color.toArray(_tmp_color_array);
        param.set(_tmp_color_array);
      }
    }
    node.p.colorsCount.set(palette.colors.length);
  }
}
class PaletteAbstractNodeParamsConfig extends _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .NodeParamsConfig */ .yI {
  constructor() {
    super(...arguments);
    /** @param name of the palette */
    this.paletteName = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .ParamConfig.STRING */ .XC.STRING(
      "",
      paletteControllerCallbackOptions(PaletteController.PARAM_CALLBACK_updateColors)
    );
    /** @param click to set the node to the next palette */
    this.pickNext = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .ParamConfig.BUTTON */ .XC.BUTTON(null, paletteControllerCallbackOptions(PaletteController.PARAM_CALLBACK_pickNext));
    /** @param click to set the node to the previous palette */
    this.pickPrevious = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .ParamConfig.BUTTON */ .XC.BUTTON(
      null,
      paletteControllerCallbackOptions(PaletteController.PARAM_CALLBACK_pickPrevious)
    );
    /** @param click to set the node to a random palette */
    this.pickRandom = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .ParamConfig.BUTTON */ .XC.BUTTON(
      null,
      paletteControllerCallbackOptions(PaletteController.PARAM_CALLBACK_pickRandom)
    );
    this.colorsCount = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .ParamConfig.INTEGER */ .XC.INTEGER(0, {
      hidden: true,
      range: [0, _core_color_chromotomeWrapper__WEBPACK_IMPORTED_MODULE_0__/* .MAX_PALETTE_COLORS_COUNT */ .JT],
      separatorAfter: true
    });
    /** @param palette color 1 */
    this.color1 = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .ParamConfig.COLOR */ .XC.COLOR([0, 0, 0], {
      visibleIf: (0,_core_color_chromotomeWrapper__WEBPACK_IMPORTED_MODULE_0__/* .visibleIfColorsCountAtLeast */ .i2)(1)
      // conversion: ColorConversion.SRGB_TO_LINEAR,
    });
    /** @param palette color 2 */
    this.color2 = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .ParamConfig.COLOR */ .XC.COLOR([0, 0, 0], {
      visibleIf: (0,_core_color_chromotomeWrapper__WEBPACK_IMPORTED_MODULE_0__/* .visibleIfColorsCountAtLeast */ .i2)(2)
      // conversion: ColorConversion.SRGB_TO_LINEAR,
    });
    /** @param palette color 3 */
    this.color3 = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .ParamConfig.COLOR */ .XC.COLOR([0, 0, 0], {
      visibleIf: (0,_core_color_chromotomeWrapper__WEBPACK_IMPORTED_MODULE_0__/* .visibleIfColorsCountAtLeast */ .i2)(3)
      // conversion: ColorConversion.SRGB_TO_LINEAR,
    });
    /** @param palette color 4 */
    this.color4 = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .ParamConfig.COLOR */ .XC.COLOR([0, 0, 0], {
      visibleIf: (0,_core_color_chromotomeWrapper__WEBPACK_IMPORTED_MODULE_0__/* .visibleIfColorsCountAtLeast */ .i2)(4)
      // conversion: ColorConversion.SRGB_TO_LINEAR,
    });
    /** @param palette color 5 */
    this.color5 = _utils_params_ParamsConfig__WEBPACK_IMPORTED_MODULE_1__/* .ParamConfig.COLOR */ .XC.COLOR([0, 0, 0], {
      visibleIf: (0,_core_color_chromotomeWrapper__WEBPACK_IMPORTED_MODULE_0__/* .visibleIfColorsCountAtLeast */ .i2)(5)
      // conversion: ColorConversion.SRGB_TO_LINEAR,
    });
  }
}
const ParamsConfig = new PaletteAbstractNodeParamsConfig();
class PaletteAbstractNode extends (/* unused pure expression or super */ null && (TypedNode)) {
  constructor() {
    super(...arguments);
    this.paramsConfig = ParamsConfig;
    //  static type() {
    // 	 return 'palette';
    //  }
    //  initializeNode() {
    // 	 this.params.onParamsCreated('palette_init', () => {
    // 		PaletteController.paramCallbackUpdateColors(this);
    // 	 });
    //  }
    this.paletteController = new PaletteController(this);
  }
  // static PARAM_CALLBACK_pickNext(node: PaletteAbstractNode<any>) {
  // 	node.paletteController.PARAM_CALLBACK_pickNext();
  // }
  // static PARAM_CALLBACK_pickPrevious(node: PaletteAbstractNode<any>) {
  // 	node.paletteController.PARAM_CALLBACK_pickPrevious();
  // }
  // static PARAM_CALLBACK_pickRandom(node: PaletteAbstractNode<any>) {
  // 	node.paletteController.PARAM_CALLBACK_pickRandom();
  // }
  // static PARAM_CALLBACK_updateColors(node: PaletteAbstractNode<any>) {
  // 	node.paletteController.PARAM_CALLBACK_updateColors();
  // }
}
const _tmp_color = new three__WEBPACK_IMPORTED_MODULE_2__.Color();
const _tmp_color_array = [1, 1, 1];


/***/ }),

/***/ 36464:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "F": function() { return /* binding */ AddSopOperation; }
/* harmony export */ });
/* harmony import */ var _Base__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(82612);
/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(21410);
/* harmony import */ var _core_geometry_Constant__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(91568);
/* harmony import */ var _core_BooleanValue__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(19037);





const _position = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();
const _points = [];
class AddSopOperation extends _Base__WEBPACK_IMPORTED_MODULE_1__/* .BaseSopOperation */ .U {
  static type() {
    return "add";
  }
  cook(input_contents, params) {
    const objects = [];
    this._createPoint(objects, params);
    this._createPolygon(input_contents[0], objects, params);
    if (this._node) {
      let i = 0;
      for (let object of objects) {
        object.name = `${this._node.name()}-${i}`;
        i++;
      }
    }
    return this.createCoreGroupFromObjects(objects);
  }
  _createPoint(objects, params) {
    if (!(0,_core_BooleanValue__WEBPACK_IMPORTED_MODULE_2__/* .isBooleanTrue */ .bI)(params.createPoint)) {
      return;
    }
    const geometry = new three__WEBPACK_IMPORTED_MODULE_0__.BufferGeometry();
    const positions = [];
    for (let i = 0; i < params.pointsCount; i++) {
      params.position.toArray(positions, i * 3);
    }
    geometry.setAttribute("position", new three__WEBPACK_IMPORTED_MODULE_0__.BufferAttribute(new Float32Array(positions), 3));
    const object = this.createObject(geometry, _core_geometry_Constant__WEBPACK_IMPORTED_MODULE_3__/* .ObjectType.POINTS */ .LP.POINTS);
    if (objects) {
      objects.push(object);
    }
  }
  _createPolygon(coreGroup, objects, params) {
    if (!(0,_core_BooleanValue__WEBPACK_IMPORTED_MODULE_2__/* .isBooleanTrue */ .bI)(params.connectInputPoints)) {
      return;
    }
    coreGroup.points(_points);
    if (_points.length > 0) {
      this._create_polygon_open(coreGroup, objects, params);
    }
  }
  // private _create_polygon_closed(core_group: CoreGroup, objects: Object3D[]) {
  // 	const points = core_group.points();
  // 	const geometry = CoreGeometryUtilShape.geometryFromPoints(points.map((p) => p.position()));
  // 	const object = this.createObject(geometry, ObjectType.MESH);
  // 	objects.push(object);
  // }
  _create_polygon_open(coreGroup, objects, params) {
    coreGroup.points(_points);
    let positions = [];
    const indices = [];
    let point;
    const pointsCount = _points.length;
    for (let i = 0; i < pointsCount; i++) {
      point = _points[i];
      point.position(_position).toArray(positions, i * 3);
      if (i > 0) {
        indices.push(i - 1);
        indices.push(i);
      }
    }
    if (pointsCount > 2 && params.connectToLastPoint) {
      _points[0].position(_position).toArray(positions, positions.length);
      const last_index = indices[indices.length - 1];
      indices.push(last_index);
      indices.push(0);
    }
    const geometry = new three__WEBPACK_IMPORTED_MODULE_0__.BufferGeometry();
    geometry.setAttribute("position", new three__WEBPACK_IMPORTED_MODULE_0__.Float32BufferAttribute(positions, 3));
    geometry.setIndex(indices);
    const object = this.createObject(geometry, _core_geometry_Constant__WEBPACK_IMPORTED_MODULE_3__/* .ObjectType.LINE_SEGMENTS */ .LP.LINE_SEGMENTS);
    objects.push(object);
  }
}
AddSopOperation.DEFAULT_PARAMS = {
  createPoint: true,
  pointsCount: 1,
  position: new three__WEBPACK_IMPORTED_MODULE_0__.Vector3(0, 0, 0),
  connectInputPoints: false,
  connectToLastPoint: false
};


/***/ }),

/***/ 82040:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "j": function() { return /* binding */ AmbientLightSopOperation; }
/* harmony export */ });
/* harmony import */ var _Base__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(82612);
/* harmony import */ var _engine_poly_InputCloneMode__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(56752);
/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(21410);
/* harmony import */ var _core_lights_AmbientLight__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(23276);
/* harmony import */ var _core_geometry_Constant__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(91568);






class AmbientLightSopOperation extends _Base__WEBPACK_IMPORTED_MODULE_0__/* .BaseSopOperation */ .U {
  static type() {
    return "ambientLight";
  }
  cook(_, params) {
    const light = this.createLight();
    light.name = params.name;
    this.updateLightParams(light, params);
    return this.createCoreGroupFromObjects([light]);
  }
  createLight() {
    var _a;
    (0,_core_geometry_Constant__WEBPACK_IMPORTED_MODULE_1__/* .registerObjectType */ .UX)({
      type: _core_geometry_Constant__WEBPACK_IMPORTED_MODULE_1__/* .ObjectType.AMBIENT_LIGHT */ .LP.AMBIENT_LIGHT,
      checkFunc: (o) => {
        if (o.isAmbientLight) {
          return _core_geometry_Constant__WEBPACK_IMPORTED_MODULE_1__/* .ObjectType.AMBIENT_LIGHT */ .LP.AMBIENT_LIGHT;
        }
      },
      ctor: three__WEBPACK_IMPORTED_MODULE_2__.AmbientLight,
      humanName: "AmbientLight"
    });
    const light = new three__WEBPACK_IMPORTED_MODULE_2__.AmbientLight();
    light.matrixAutoUpdate = false;
    light.name = `AmbientLight_${((_a = this._node) == null ? void 0 : _a.name()) || ""}`;
    return light;
  }
  updateLightParams(light, params) {
    light.color.copy(params.color);
    light.intensity = params.intensity;
  }
}
AmbientLightSopOperation.DEFAULT_PARAMS = _core_lights_AmbientLight__WEBPACK_IMPORTED_MODULE_3__/* .DEFAULT_AMBIENT_LIGHT_PARAMS */ .e;
AmbientLightSopOperation.INPUT_CLONED_STATE = _engine_poly_InputCloneMode__WEBPACK_IMPORTED_MODULE_4__/* .InputCloneMode.NEVER */ .m.NEVER;


/***/ }),

/***/ 54112:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "X": function() { return /* binding */ AreaLightSopOperation; }
/* harmony export */ });
/* harmony import */ var _Base__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(82612);
/* harmony import */ var _engine_poly_InputCloneMode__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(56752);
/* harmony import */ var three_examples_jsm_lights_RectAreaLightUniformsLib__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(71395);
/* harmony import */ var _core_BooleanValue__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(19037);
/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(21410);
/* harmony import */ var _core_lights_AreaLight__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(72862);
/* harmony import */ var _core_CoreSceneObjectsFactory__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(6767);








class AreaLightSopOperation extends _Base__WEBPACK_IMPORTED_MODULE_0__/* .BaseSopOperation */ .U {
  static type() {
    return "areaLight";
  }
  cook(inputCoreGroups, params) {
    const light = this.createLight();
    light.name = params.name;
    this.updateLightParams(light, params);
    if ((0,_core_BooleanValue__WEBPACK_IMPORTED_MODULE_1__/* .isBooleanTrue */ .bI)(params.showHelper)) {
      const group = new three__WEBPACK_IMPORTED_MODULE_2__.Group();
      group.matrixAutoUpdate = false;
      group.add(light);
      const helper = this._createHelper(light);
      if (helper) {
        group.add(helper);
      }
      group.name = `AreaLightGroup_${light.name}`;
      return this.createCoreGroupFromObjects([group]);
    } else {
      return this.createCoreGroupFromObjects([light]);
    }
  }
  createLight() {
    var _a;
    const light = _core_CoreSceneObjectsFactory__WEBPACK_IMPORTED_MODULE_3__/* .CoreSceneObjectsFactory.generator */ .b.generator(_core_CoreSceneObjectsFactory__WEBPACK_IMPORTED_MODULE_3__/* .GeneratorName.AREA_LIGHT */ .D.AREA_LIGHT)({
      color: 16777215,
      intensity: 1,
      width: 1,
      height: 1
    });
    light.matrixAutoUpdate = false;
    const nodeName = (_a = this._node) == null ? void 0 : _a.name();
    if (nodeName) {
      light.name = `AreaLight_${nodeName}`;
    }
    if (!three_examples_jsm_lights_RectAreaLightUniformsLib__WEBPACK_IMPORTED_MODULE_4__/* .RectAreaLightUniformsLib.initialized */ .a.initialized) {
      three_examples_jsm_lights_RectAreaLightUniformsLib__WEBPACK_IMPORTED_MODULE_4__/* .RectAreaLightUniformsLib.init */ .a.init();
      three_examples_jsm_lights_RectAreaLightUniformsLib__WEBPACK_IMPORTED_MODULE_4__/* .RectAreaLightUniformsLib.initialized */ .a.initialized = true;
    }
    return light;
  }
  updateLightParams(light, params) {
    light.color = params.color;
    light.intensity = params.intensity;
    light.width = params.width;
    light.height = params.height;
  }
  _createHelper(light) {
    var _a;
    const nodeName = (_a = this._node) == null ? void 0 : _a.name();
    if (nodeName) {
      const helper = new _core_lights_AreaLight__WEBPACK_IMPORTED_MODULE_5__/* .CoreRectAreaLightHelper */ .x1(light, nodeName);
      helper.update();
      return helper;
    }
  }
}
AreaLightSopOperation.DEFAULT_PARAMS = _core_lights_AreaLight__WEBPACK_IMPORTED_MODULE_5__/* .DEFAULT_AREA_LIGHT_PARAMS */ .Kz;
AreaLightSopOperation.INPUT_CLONED_STATE = _engine_poly_InputCloneMode__WEBPACK_IMPORTED_MODULE_6__/* .InputCloneMode.NEVER */ .m.NEVER;


/***/ }),

/***/ 8057:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "t": function() { return /* binding */ AttribAddMultSopOperation; }
/* harmony export */ });
/* harmony import */ var _Base__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(82612);
/* harmony import */ var _engine_poly_InputCloneMode__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(56752);



class AttribAddMultSopOperation extends _Base__WEBPACK_IMPORTED_MODULE_0__/* .BaseSopOperation */ .U {
  static type() {
    return "attribAddMult";
  }
  cook(inputCoreGroups, params) {
    const coreGroup = inputCoreGroups[0];
    const attribNames = coreGroup.pointAttribNamesMatchingMask(params.name);
    for (let attribName of attribNames) {
      const geometries = coreGroup.geometries();
      for (let geometry of geometries) {
        this._updateAttrib(attribName, geometry, params);
      }
    }
    return coreGroup;
  }
  _updateAttrib(attribName, geometry, params) {
    const attribute = geometry.getAttribute(attribName);
    if (attribute) {
      const values = attribute.array;
      const preAdd = params.preAdd;
      const mult = params.mult;
      const postAdd = params.postAdd;
      for (let i = 0; i < values.length; i++) {
        const value = values[i];
        values[i] = (value + preAdd) * mult + postAdd;
      }
      attribute.needsUpdate = true;
    }
  }
}
AttribAddMultSopOperation.DEFAULT_PARAMS = {
  name: "",
  preAdd: 0,
  mult: 1,
  postAdd: 0
};
AttribAddMultSopOperation.INPUT_CLONED_STATE = _engine_poly_InputCloneMode__WEBPACK_IMPORTED_MODULE_1__/* .InputCloneMode.FROM_NODE */ .m.FROM_NODE;


/***/ }),

/***/ 96685:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Lz": function() { return /* binding */ AttribCastSopOperation; },
/* harmony export */   "Vw": function() { return /* binding */ ATTRIB_TYPES; }
/* harmony export */ });
/* unused harmony export AttribType */
/* harmony import */ var _Base__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(82612);
/* harmony import */ var _engine_poly_InputCloneMode__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(56752);
/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(21410);
/* harmony import */ var _core_BooleanValue__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(19037);
/* harmony import */ var _core_geometry_CoreObjectFactory__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(17353);






var AttribType = /* @__PURE__ */ ((AttribType2) => {
  AttribType2["Float64BufferAttribute"] = "Float64BufferAttribute";
  AttribType2["Float32BufferAttribute"] = "Float32BufferAttribute";
  AttribType2["Float16BufferAttribute"] = "Float16BufferAttribute";
  AttribType2["Uint32BufferAttribute"] = "Uint32BufferAttribute";
  AttribType2["Int32BufferAttribute"] = "Int32BufferAttribute";
  AttribType2["Uint16BufferAttribute"] = "Uint16BufferAttribute";
  AttribType2["Int16BufferAttribute"] = "Int16BufferAttribute";
  AttribType2["Uint8ClampedBufferAttribute"] = "Uint8ClampedBufferAttribute";
  AttribType2["Uint8BufferAttribute"] = "Uint8BufferAttribute";
  AttribType2["Int8BufferAttribute"] = "Int8BufferAttribute";
  return AttribType2;
})(AttribType || {});
const ATTRIB_TYPES = [
  "Float64BufferAttribute" /* Float64BufferAttribute */,
  "Float32BufferAttribute" /* Float32BufferAttribute */,
  "Float16BufferAttribute" /* Float16BufferAttribute */,
  "Uint32BufferAttribute" /* Uint32BufferAttribute */,
  "Int32BufferAttribute" /* Int32BufferAttribute */,
  "Uint16BufferAttribute" /* Uint16BufferAttribute */,
  "Int16BufferAttribute" /* Int16BufferAttribute */,
  "Uint8ClampedBufferAttribute" /* Uint8ClampedBufferAttribute */,
  "Uint8BufferAttribute" /* Uint8BufferAttribute */,
  "Int8BufferAttribute" /* Int8BufferAttribute */
];
const ATTRIB_CLASS_BY_TYPE = {
  ["Float64BufferAttribute" /* Float64BufferAttribute */]: three__WEBPACK_IMPORTED_MODULE_0__.Float64BufferAttribute,
  ["Float32BufferAttribute" /* Float32BufferAttribute */]: three__WEBPACK_IMPORTED_MODULE_0__.Float32BufferAttribute,
  ["Float16BufferAttribute" /* Float16BufferAttribute */]: three__WEBPACK_IMPORTED_MODULE_0__.Float16BufferAttribute,
  ["Uint32BufferAttribute" /* Uint32BufferAttribute */]: three__WEBPACK_IMPORTED_MODULE_0__.Uint32BufferAttribute,
  ["Int32BufferAttribute" /* Int32BufferAttribute */]: three__WEBPACK_IMPORTED_MODULE_0__.Int32BufferAttribute,
  ["Uint16BufferAttribute" /* Uint16BufferAttribute */]: three__WEBPACK_IMPORTED_MODULE_0__.Uint16BufferAttribute,
  ["Int16BufferAttribute" /* Int16BufferAttribute */]: three__WEBPACK_IMPORTED_MODULE_0__.Int16BufferAttribute,
  ["Uint8ClampedBufferAttribute" /* Uint8ClampedBufferAttribute */]: three__WEBPACK_IMPORTED_MODULE_0__.Uint8ClampedBufferAttribute,
  ["Uint8BufferAttribute" /* Uint8BufferAttribute */]: three__WEBPACK_IMPORTED_MODULE_0__.Uint8BufferAttribute,
  ["Int8BufferAttribute" /* Int8BufferAttribute */]: three__WEBPACK_IMPORTED_MODULE_0__.Int8BufferAttribute
};
const ARRAY_CLASS_BY_TYPE = {
  ["Float64BufferAttribute" /* Float64BufferAttribute */]: Float64Array,
  ["Float32BufferAttribute" /* Float32BufferAttribute */]: Float32Array,
  ["Float16BufferAttribute" /* Float16BufferAttribute */]: Uint16Array,
  ["Uint32BufferAttribute" /* Uint32BufferAttribute */]: Uint32Array,
  ["Int32BufferAttribute" /* Int32BufferAttribute */]: Int32Array,
  ["Uint16BufferAttribute" /* Uint16BufferAttribute */]: Uint16Array,
  ["Int16BufferAttribute" /* Int16BufferAttribute */]: Int16Array,
  ["Uint8ClampedBufferAttribute" /* Uint8ClampedBufferAttribute */]: Uint8Array,
  ["Uint8BufferAttribute" /* Uint8BufferAttribute */]: Uint8Array,
  ["Int8BufferAttribute" /* Int8BufferAttribute */]: Int8Array
};
class AttribCastSopOperation extends _Base__WEBPACK_IMPORTED_MODULE_1__/* .BaseSopOperation */ .U {
  static type() {
    return "attribCast";
  }
  cook(inputCoreGroups, params) {
    const coreGroup = inputCoreGroups[0];
    const objects = coreGroup.allObjects();
    for (let object of objects) {
      this._castPointAttributes(object, params);
    }
    return coreGroup;
  }
  _castPointAttributes(object, params) {
    const type = ATTRIB_TYPES[params.type];
    const attribClass = ATTRIB_CLASS_BY_TYPE[type];
    const arrayClass = ARRAY_CLASS_BY_TYPE[type];
    const corePointClass = (0,_core_geometry_CoreObjectFactory__WEBPACK_IMPORTED_MODULE_2__/* .corePointClassFactory */ .E_)(object);
    if ((0,_core_BooleanValue__WEBPACK_IMPORTED_MODULE_3__/* .isBooleanTrue */ .bI)(params.castAttributes)) {
      const attribNames = corePointClass.attributeNamesMatchingMask(object, params.mask);
      for (let attribName of attribNames) {
        const attrib = corePointClass.attribute(object, attribName);
        const array = attrib.array;
        const count = attrib.count;
        const itemSize = attrib.itemSize;
        const newArray = new arrayClass(count * itemSize);
        for (let i = 0; i < array.length; i++) {
          newArray[i] = array[i];
        }
        const newAttribute = new attribClass(newArray, itemSize);
        corePointClass.addAttribute(object, attribName, newAttribute);
      }
    }
    if (params.castIndex) {
      const coreVertexClass = (0,_core_geometry_CoreObjectFactory__WEBPACK_IMPORTED_MODULE_2__/* .coreVertexClassFactory */ .PF)(object);
      const index = coreVertexClass.indexAttribute(object);
      if (index) {
        const array = index.array;
        const count = index.count;
        const itemSize = 1;
        const newArray = new arrayClass(count * itemSize);
        for (let i = 0; i < array.length; i++) {
          newArray[i] = array[i];
        }
        const newAttr = new attribClass(newArray, itemSize);
        coreVertexClass.setIndexAttribute(object, newAttr);
      }
    }
  }
}
AttribCastSopOperation.DEFAULT_PARAMS = {
  castAttributes: true,
  mask: "*",
  castIndex: false,
  type: ATTRIB_TYPES.indexOf("Float32BufferAttribute" /* Float32BufferAttribute */)
};
AttribCastSopOperation.INPUT_CLONED_STATE = _engine_poly_InputCloneMode__WEBPACK_IMPORTED_MODULE_4__/* .InputCloneMode.FROM_NODE */ .m.FROM_NODE;


/***/ }),

/***/ 50758:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "O": function() { return /* binding */ AttribCopySopOperation; }
/* harmony export */ });
/* harmony import */ var _Base__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(82612);
/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(21410);
/* harmony import */ var _engine_poly_InputCloneMode__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(56752);
/* harmony import */ var _core_BooleanValue__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(19037);
/* harmony import */ var _core_String__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(40065);
/* harmony import */ var _core_geometry_Constant__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(91568);
/* harmony import */ var _engine_poly_Assert__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(68239);
/* harmony import */ var _core_geometry_CoreObjectFactory__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(17353);









const _newNames = [];
const _attribNames = [];
class AttribCopySopOperation extends _Base__WEBPACK_IMPORTED_MODULE_0__/* .BaseSopOperation */ .U {
  static type() {
    return "attribCopy";
  }
  cook(inputCoreGroups, params) {
    var _a;
    const coreGroupDest = inputCoreGroups[0];
    const coreGroupSrc = inputCoreGroups[1] || coreGroupDest;
    const attribClass = _core_geometry_Constant__WEBPACK_IMPORTED_MODULE_1__/* .ATTRIBUTE_CLASSES */ .oT[params.class];
    (0,_core_String__WEBPACK_IMPORTED_MODULE_2__/* .stringToAttribNames */ .Fz)(params.newName, _newNames);
    if (attribClass == _core_geometry_Constant__WEBPACK_IMPORTED_MODULE_1__/* .AttribClass.POINT */ .io.POINT) {
      const srcAttribNames = coreGroupSrc.pointAttribNamesMatchingMask(params.name);
      for (let i = 0; i < srcAttribNames.length; i++) {
        const srcAttribName = srcAttribNames[i];
        let destAttribName = (0,_core_BooleanValue__WEBPACK_IMPORTED_MODULE_3__/* .isBooleanTrue */ .bI)(params.tnewName) ? _newNames[i] : srcAttribName;
        if (!destAttribName) {
          (_a = this.states) == null ? void 0 : _a.error.set(`no matching new attribute name of ${srcAttribName}`);
          return coreGroupDest;
        }
        this._copyAttributeBetweenCoreGroups(attribClass, {
          attribName: {
            src: srcAttribName,
            dest: destAttribName
          },
          params,
          coreGroup: { src: coreGroupSrc, dest: coreGroupDest }
        });
      }
    } else {
      (0,_core_String__WEBPACK_IMPORTED_MODULE_2__/* .stringToAttribNames */ .Fz)(params.name, _attribNames);
      for (let i = 0; i < _attribNames.length; i++) {
        const destAttribName = (0,_core_BooleanValue__WEBPACK_IMPORTED_MODULE_3__/* .isBooleanTrue */ .bI)(params.tnewName) ? _newNames[i] : _attribNames[i];
        this._copyAttributeBetweenCoreGroups(attribClass, {
          attribName: {
            src: _attribNames[i],
            dest: destAttribName
          },
          params,
          coreGroup: { src: coreGroupSrc, dest: coreGroupDest }
        });
      }
    }
    return coreGroupDest;
  }
  _copyAttributeBetweenCoreGroups(attribClass, copyArgs) {
    var _a, _b;
    switch (attribClass) {
      case _core_geometry_Constant__WEBPACK_IMPORTED_MODULE_1__/* .AttribClass.POINT */ .io.POINT:
        this._copyAttributesBetweenGeometries(copyArgs);
        return;
      case _core_geometry_Constant__WEBPACK_IMPORTED_MODULE_1__/* .AttribClass.VERTEX */ .io.VERTEX:
        (_a = this.states) == null ? void 0 : _a.error.set("vertex attributes are not supported yet");
        return;
      case _core_geometry_Constant__WEBPACK_IMPORTED_MODULE_1__/* .AttribClass.PRIMITIVE */ .io.PRIMITIVE:
        (_b = this.states) == null ? void 0 : _b.error.set("primitive attributes are not supported yet");
        return;
      case _core_geometry_Constant__WEBPACK_IMPORTED_MODULE_1__/* .AttribClass.OBJECT */ .io.OBJECT:
        this._copyAttributesBetweenObjects(copyArgs);
        return;
      case _core_geometry_Constant__WEBPACK_IMPORTED_MODULE_1__/* .AttribClass.CORE_GROUP */ .io.CORE_GROUP:
        this._copyAttributesBetweenCoreGroups(copyArgs);
        return;
    }
    _engine_poly_Assert__WEBPACK_IMPORTED_MODULE_4__/* .TypeAssert.unreachable */ .f.unreachable(attribClass);
  }
  _copyAttributesBetweenGeometries(copyArgs) {
    var _a;
    const { coreGroup, attribName, params } = copyArgs;
    const srcObjects = coreGroup.src.threejsObjectsWithGeo();
    const destObjects = coreGroup.dest.threejsObjectsWithGeo();
    if (destObjects.length > srcObjects.length) {
      (_a = this.states) == null ? void 0 : _a.error.set("second input does not have enough objects to copy attributes from");
    } else {
      for (let i = 0; i < destObjects.length; i++) {
        const destGeometry = destObjects[i].geometry;
        const srcGeometry = srcObjects[i].geometry;
        this._copyPointAttributesBetweenGeometries({
          geo: { src: srcGeometry, dest: destGeometry },
          attribName,
          params
        });
      }
    }
  }
  _copyAttributesBetweenObjects(copyArgs) {
    var _a;
    const { coreGroup, attribName } = copyArgs;
    const srcObjects = coreGroup.src.allObjects();
    const destObjects = coreGroup.dest.allObjects();
    if (destObjects.length > srcObjects.length) {
      (_a = this.states) == null ? void 0 : _a.error.set("second input does not have enough objects to copy attributes from");
    } else {
      for (let i = 0; i < destObjects.length; i++) {
        const destObject = destObjects[i];
        const srcObject = srcObjects[i];
        const srcAttribValue = (0,_core_geometry_CoreObjectFactory__WEBPACK_IMPORTED_MODULE_5__/* .coreObjectClassFactory */ .Xr)(srcObject).attribValue(srcObject, attribName.src);
        if (srcAttribValue != null) {
          (0,_core_geometry_CoreObjectFactory__WEBPACK_IMPORTED_MODULE_5__/* .coreObjectClassFactory */ .Xr)(destObject).setAttribute(destObject, attribName.dest, srcAttribValue);
        }
      }
    }
  }
  _copyAttributesBetweenCoreGroups(copyArgs) {
    const { coreGroup, attribName } = copyArgs;
    const srcCoreGroup = coreGroup.src;
    const destCoreGroup = coreGroup.dest;
    const srcAttribValue = srcCoreGroup.attribValue(attribName.src);
    if (srcAttribValue != null) {
      destCoreGroup.setAttribValue(attribName.dest, srcAttribValue);
    }
  }
  _copyPointAttributesBetweenGeometries(copyArgs) {
    var _a, _b;
    const { geo, attribName, params } = copyArgs;
    const srcAttrib = geo.src.getAttribute(attribName.src);
    if (srcAttrib) {
      const size = srcAttrib.itemSize;
      const destAttrib = geo.dest.getAttribute(attribName.dest);
      const srcPointsCount = srcAttrib.array.length / srcAttrib.itemSize;
      if (destAttrib) {
        const destPointsCount = destAttrib.array.length / destAttrib.itemSize;
        if (destPointsCount > srcPointsCount) {
          (_a = this.states) == null ? void 0 : _a.error.set(`not enough points in second input`);
        } else {
          this._fillDestArray(destAttrib, srcAttrib, params);
          destAttrib.needsUpdate = true;
        }
      } else {
        const src_array = srcAttrib.array;
        const destPointsCount = geo.dest.getAttribute("position").array.length / 3;
        const dest_array = src_array.slice(0, destPointsCount * size);
        geo.dest.setAttribute(attribName.dest, new three__WEBPACK_IMPORTED_MODULE_6__.Float32BufferAttribute(dest_array, size));
      }
    } else {
      (_b = this.states) == null ? void 0 : _b.error.set(`attribute '${attribName}' does not exist on second input`);
    }
  }
  _fillDestArray(dest_attribute, src_attribute, params) {
    const dest_array = dest_attribute.array;
    const src_array = src_attribute.array;
    const dest_array_size = dest_array.length;
    const dest_item_size = dest_attribute.itemSize;
    const src_item_size = src_attribute.itemSize;
    const srcOffset = params.srcOffset;
    const destOffset = params.destOffset;
    if (dest_attribute.itemSize == src_attribute.itemSize) {
      dest_attribute.copyArray(src_attribute.array);
      for (let i = 0; i < dest_array_size; i++) {
        dest_array[i] = src_array[i];
      }
    } else {
      const pointsCount = dest_array.length / dest_item_size;
      if (dest_item_size < src_item_size) {
        for (let i = 0; i < pointsCount; i++) {
          for (let j = 0; j < dest_item_size; j++) {
            dest_array[i * dest_item_size + j + destOffset] = src_array[i * src_item_size + j + srcOffset];
          }
        }
      } else {
        for (let i = 0; i < pointsCount; i++) {
          for (let j = 0; j < src_item_size; j++) {
            dest_array[i * dest_item_size + j + destOffset] = src_array[i * src_item_size + j + srcOffset];
          }
        }
      }
    }
  }
}
AttribCopySopOperation.DEFAULT_PARAMS = {
  class: _core_geometry_Constant__WEBPACK_IMPORTED_MODULE_1__/* .ATTRIBUTE_CLASSES.indexOf */ .oT.indexOf(_core_geometry_Constant__WEBPACK_IMPORTED_MODULE_1__/* .AttribClass.POINT */ .io.POINT),
  name: "",
  tnewName: false,
  newName: "",
  srcOffset: 0,
  destOffset: 0
};
AttribCopySopOperation.INPUT_CLONED_STATE = [_engine_poly_InputCloneMode__WEBPACK_IMPORTED_MODULE_7__/* .InputCloneMode.FROM_NODE */ .m.FROM_NODE, _engine_poly_InputCloneMode__WEBPACK_IMPORTED_MODULE_7__/* .InputCloneMode.NEVER */ .m.NEVER];


/***/ }),

/***/ 41346:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "T": function() { return /* binding */ AttribDeleteSopOperation; }
/* harmony export */ });
/* harmony import */ var _Base__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(82612);
/* harmony import */ var _engine_poly_InputCloneMode__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(56752);
/* harmony import */ var _core_geometry_Constant__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(91568);
/* harmony import */ var _core_geometry_CoreObjectFactory__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(17353);
/* harmony import */ var _core_geometry_Mask__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(58290);






class AttribDeleteSopOperation extends _Base__WEBPACK_IMPORTED_MODULE_0__/* .BaseSopOperation */ .U {
  static type() {
    return "attribDelete";
  }
  cook(inputCoreGroups, params) {
    const coreGroup = inputCoreGroups[0];
    const objects = (0,_core_geometry_Mask__WEBPACK_IMPORTED_MODULE_1__/* .filterObjectsFromCoreGroup */ .sH)(coreGroup, params);
    const attribClass = _core_geometry_Constant__WEBPACK_IMPORTED_MODULE_2__/* .ATTRIBUTE_CLASSES */ .oT[params.class];
    const factory = _core_geometry_CoreObjectFactory__WEBPACK_IMPORTED_MODULE_3__/* .ENTITY_CLASS_FACTORY */ .Vd[attribClass];
    if (factory) {
      for (const object of objects) {
        const entityClass = factory(object);
        const attribNames = entityClass.attributeNamesMatchingMask(object, params.name);
        for (const attribName of attribNames) {
          entityClass.deleteAttribute(object, attribName);
        }
      }
    } else {
      const attribNames = coreGroup.attributeNamesMatchingMask(params.name);
      for (const attribName of attribNames) {
        coreGroup.deleteAttribute(attribName);
      }
    }
    return coreGroup;
  }
}
AttribDeleteSopOperation.DEFAULT_PARAMS = {
  group: "",
  class: _core_geometry_Constant__WEBPACK_IMPORTED_MODULE_2__/* .ATTRIBUTE_CLASSES.indexOf */ .oT.indexOf(_core_geometry_Constant__WEBPACK_IMPORTED_MODULE_2__/* .AttribClass.POINT */ .io.POINT),
  name: ""
};
AttribDeleteSopOperation.INPUT_CLONED_STATE = _engine_poly_InputCloneMode__WEBPACK_IMPORTED_MODULE_4__/* .InputCloneMode.FROM_NODE */ .m.FROM_NODE;


/***/ }),

/***/ 18224:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {


// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  "W": function() { return /* binding */ AttribFromTextureSopOperation; }
});

// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/operations/sop/_Base.ts
var _Base = __webpack_require__(82612);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/core/Walker.ts
var Walker = __webpack_require__(742);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/poly/NodeContext.ts
var NodeContext = __webpack_require__(52070);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/node_modules/three/build/three.module.js
var three_module = __webpack_require__(21410);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/core/Image.ts
var Image = __webpack_require__(33450);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/core/geometry/Attribute.ts
var Attribute = __webpack_require__(32558);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/core/math/_Module.ts
var _Module = __webpack_require__(27462);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/core/geometry/CoreObjectFactory.ts
var CoreObjectFactory = __webpack_require__(17353);
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/core/geometry/operation/AttribFromTexture.ts






class AttribFromTexture {
  // currently assumes we read the red channel and create a 1-dimension (float) attribute
  setAttribute(params) {
    const { object, texture, uvAttribName, targetAttribName, targetAttribSize, add, mult } = params;
    const corePointClass = (0,CoreObjectFactory/* corePointClassFactory */.E_)(object);
    if (targetAttribSize < 1 || targetAttribSize > 4) {
      return;
    }
    const texture_data = this._dataFromTexture(texture);
    if (!texture_data) {
      return;
    }
    const { data, resx, resy } = texture_data;
    const texture_component_size = data.length / (resx * resy);
    const uv_attrib = corePointClass.attribute(object, uvAttribName);
    if (!uv_attrib) {
      return;
    }
    const uvs = uv_attrib.array;
    const points_count = uvs.length / 2;
    const values = new Array(points_count * targetAttribSize);
    let uv_stride, uvx, uvy, x, y, i, j, val, c;
    for (i = 0; i < points_count; i++) {
      uv_stride = i * 2;
      uvx = (0,_Module/* clamp */.uZ)(uvs[uv_stride], 0, 1);
      uvy = (0,_Module/* clamp */.uZ)(uvs[uv_stride + 1], 0, 1);
      x = Math.floor((resx - 1) * uvx);
      y = Math.floor((resy - 1) * (1 - uvy));
      j = y * resx + x;
      for (c = 0; c < targetAttribSize; c++) {
        val = data[texture_component_size * j + c];
        values[i * targetAttribSize + c] = mult * val + add;
      }
    }
    const attribName = Attribute/* CoreAttribute.remapName */.n0.remapName(targetAttribName);
    const array = new Float32Array(values);
    corePointClass.addAttribute(object, attribName, new three_module.BufferAttribute(array, targetAttribSize));
  }
  _dataFromTexture(texture) {
    if (texture.image) {
      if (texture.image.data) {
        return this._dataFromDataTexture(texture);
      }
      return this._dataFromDefaultTexture(texture);
    }
  }
  _dataFromDefaultTexture(texture) {
    const resx = texture.image.width;
    const resy = texture.image.height;
    const image_data = Image/* CoreImage.data_from_image */.p.data_from_image(texture.image);
    const data = image_data.data;
    return {
      data,
      resx,
      resy
    };
  }
  _dataFromDataTexture(texture) {
    const data = texture.image.data;
    const resx = texture.image.width;
    const resy = texture.image.height;
    return {
      data,
      resx,
      resy
    };
  }
}

// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/poly/InputCloneMode.ts
var InputCloneMode = __webpack_require__(56752);
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/operations/sop/AttribFromTexture.ts

var __async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};






class AttribFromTextureSopOperation extends _Base/* BaseSopOperation */.U {
  static type() {
    return "attribFromTexture";
  }
  cook(inputCoreGroups, params) {
    return __async(this, null, function* () {
      var _a;
      const coreGroup = inputCoreGroups[0];
      const textureNode = params.texture.nodeWithContext(NodeContext/* NodeContext.COP */.sy.COP, (_a = this.states) == null ? void 0 : _a.error);
      if (!textureNode) {
        return coreGroup;
      }
      const container = yield textureNode.compute();
      const texture = container.texture();
      const objects = coreGroup.allObjects();
      for (const object of objects) {
        this._setPositionFromDataTexture(object, texture, params);
      }
      return coreGroup;
    });
  }
  _setPositionFromDataTexture(object, texture, params) {
    var _a;
    const corePointClass = (0,CoreObjectFactory/* corePointClassFactory */.E_)(object);
    const uvAttrib = corePointClass.attribute(object, params.uvAttrib);
    if (uvAttrib == null) {
      (_a = this.states) == null ? void 0 : _a.error.set(`param '${params.uvAttrib} not found'`);
      return;
    }
    const operation = new AttribFromTexture();
    operation.setAttribute({
      object,
      texture,
      uvAttribName: params.uvAttrib,
      targetAttribName: params.attrib,
      targetAttribSize: params.attribSize,
      add: params.add,
      mult: params.mult
    });
  }
}
AttribFromTextureSopOperation.DEFAULT_PARAMS = {
  texture: new Walker/* TypedNodePathParamValue */.jI(Walker/* NODE_PATH_DEFAULT.NODE.EMPTY */.qX.NODE.EMPTY),
  uvAttrib: "uv",
  attrib: "pscale",
  attribSize: 1,
  add: 0,
  mult: 1
};
AttribFromTextureSopOperation.INPUT_CLONED_STATE = InputCloneMode/* InputCloneMode.FROM_NODE */.m.FROM_NODE;


/***/ }),

/***/ 67905:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "S": function() { return /* binding */ AttribIdSopOperation; }
/* harmony export */ });
/* harmony import */ var _poly_Assert__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(68239);
/* harmony import */ var _core_geometry_Constant__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(91568);
/* harmony import */ var _Base__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(82612);
/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(21410);
/* harmony import */ var _core_Type__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(19037);
/* harmony import */ var _core_geometry_CoreObjectFactory__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(17353);
/* harmony import */ var _core_geometry_entities_primitive_CorePrimitiveUtils__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(73416);
/* harmony import */ var _core_geometry_entities_point_CorePointUtils__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(50253);
/* harmony import */ var _core_geometry_entities_vertex_CoreVertexUtils__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(99341);

var __async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};









const _points = [];
const _vertices = [];
const _primitives = [];
class AttribIdSopOperation extends _Base__WEBPACK_IMPORTED_MODULE_0__/* .BaseSopOperation */ .U {
  static type() {
    return "attribId";
  }
  cook(inputCoreGroups, params) {
    const coreGroup = inputCoreGroups[0];
    const attribClass = _core_geometry_Constant__WEBPACK_IMPORTED_MODULE_1__/* .ATTRIBUTE_CLASSES_WITHOUT_CORE_GROUP */ .fc[params.class];
    this._addAttribute(attribClass, coreGroup, params);
    return coreGroup;
  }
  _addAttribute(attribClass, coreGroup, params) {
    return __async(this, null, function* () {
      const objects = coreGroup.allObjects();
      switch (attribClass) {
        case _core_geometry_Constant__WEBPACK_IMPORTED_MODULE_1__/* .AttribClass.POINT */ .io.POINT:
          return this._addPointAttributesToObjects(objects, params);
        case _core_geometry_Constant__WEBPACK_IMPORTED_MODULE_1__/* .AttribClass.VERTEX */ .io.VERTEX: {
          this._addVertexAttributesToObjects(objects, params);
          return;
        }
        case _core_geometry_Constant__WEBPACK_IMPORTED_MODULE_1__/* .AttribClass.PRIMITIVE */ .io.PRIMITIVE: {
          this._addPrimitiveAttributesToObjects(objects, params);
          return;
        }
        case _core_geometry_Constant__WEBPACK_IMPORTED_MODULE_1__/* .AttribClass.OBJECT */ .io.OBJECT:
          return this._addAttributesToEntities(coreGroup.allCoreObjects(), params);
        case _core_geometry_Constant__WEBPACK_IMPORTED_MODULE_1__/* .AttribClass.CORE_GROUP */ .io.CORE_GROUP:
          return;
      }
      _poly_Assert__WEBPACK_IMPORTED_MODULE_2__/* .TypeAssert.unreachable */ .f.unreachable(attribClass);
    });
  }
  // private _addObjectAttributes(coreObjects: BaseCoreObject<CoreObjectType>[], params: AttribIdSopParams) {
  // 	const objectsCount = coreObjects.length;
  // 	if (objectsCount > 1) {
  // 		let i = 0;
  // 		for (const coreObject of coreObjects) {
  // 			if (isBooleanTrue(params.id)) {
  // 				coreObject.addAttribute(params.idName, i);
  // 			}
  // 			if (isBooleanTrue(params.idn)) {
  // 				coreObject.addAttribute(params.idnName, i / (objectsCount - 1));
  // 			}
  // 			i++;
  // 		}
  // 	} else {
  // 		coreObjects[0].addAttribute(params.idName, 0);
  // 		coreObjects[0].addAttribute(params.idnName, 0);
  // 	}
  // }
  _addPointAttributesToObjects(objects, params) {
    for (const object of objects) {
      this._addPointAttributesToObject(object, params);
    }
  }
  _addVertexAttributesToObjects(objects, params) {
    for (const object of objects) {
      this._addVertexAttributes(object, params);
    }
  }
  _addPrimitiveAttributesToObjects(objects, params) {
    for (const object of objects) {
      this._addPrimitiveAttributes(object, params);
    }
  }
  _addPointAttributesToObject(object, params) {
    const pointClass = (0,_core_geometry_CoreObjectFactory__WEBPACK_IMPORTED_MODULE_3__/* .corePointClassFactory */ .E_)(object);
    (0,_core_geometry_entities_point_CorePointUtils__WEBPACK_IMPORTED_MODULE_4__/* .pointsFromObject */ .u_)(object, _points);
    const entitiesCount = _points.length;
    if ((0,_core_Type__WEBPACK_IMPORTED_MODULE_5__/* .isBooleanTrue */ .bI)(params.id)) {
      const idValues = new Array(entitiesCount);
      for (let i = 0; i < entitiesCount; i++) {
        idValues[i] = i;
      }
      const idArray = new Float32Array(idValues);
      const attrib = new three__WEBPACK_IMPORTED_MODULE_6__.BufferAttribute(idArray, 1);
      pointClass.addAttribute(object, params.idName, attrib);
    }
    if ((0,_core_Type__WEBPACK_IMPORTED_MODULE_5__/* .isBooleanTrue */ .bI)(params.idn)) {
      const idnValues = new Array(entitiesCount);
      const pointsCountMinus1 = entitiesCount - 1;
      if (pointsCountMinus1 == 0) {
        for (let i = 0; i < entitiesCount; i++) {
          idnValues[i] = 0;
        }
      } else {
        for (let i = 0; i < entitiesCount; i++) {
          idnValues[i] = i / (entitiesCount - 1);
        }
      }
      const idnArray = new Float32Array(idnValues);
      const attrib = new three__WEBPACK_IMPORTED_MODULE_6__.BufferAttribute(idnArray, 1);
      pointClass.addAttribute(object, params.idnName, attrib);
    }
  }
  _addVertexAttributes(object, params) {
    const vertexClass = (0,_core_geometry_CoreObjectFactory__WEBPACK_IMPORTED_MODULE_3__/* .coreVertexClassFactory */ .PF)(object);
    (0,_core_geometry_entities_vertex_CoreVertexUtils__WEBPACK_IMPORTED_MODULE_7__/* .verticesFromObject */ .ir)(object, _vertices);
    if ((0,_core_Type__WEBPACK_IMPORTED_MODULE_5__/* .isBooleanTrue */ .bI)(params.id)) {
      const attribute = {
        isString: false,
        array: new Array(_vertices.length),
        itemSize: 1
      };
      vertexClass.addAttribute(object, params.idName, attribute);
    }
    if ((0,_core_Type__WEBPACK_IMPORTED_MODULE_5__/* .isBooleanTrue */ .bI)(params.idn)) {
      const attribute = {
        isString: false,
        array: new Array(_vertices.length),
        itemSize: 1
      };
      vertexClass.addAttribute(object, params.idnName, attribute);
    }
    this._addAttributesToEntities(_vertices, params);
  }
  _addPrimitiveAttributes(object, params) {
    const primitiveClass = (0,_core_geometry_CoreObjectFactory__WEBPACK_IMPORTED_MODULE_3__/* .corePrimitiveClassFactory */ .um)(object);
    (0,_core_geometry_entities_primitive_CorePrimitiveUtils__WEBPACK_IMPORTED_MODULE_8__/* .primitivesFromObject */ .Lp)(object, _primitives);
    if ((0,_core_Type__WEBPACK_IMPORTED_MODULE_5__/* .isBooleanTrue */ .bI)(params.id)) {
      const attribute = {
        isString: false,
        array: new Array(_primitives.length),
        itemSize: 1
      };
      primitiveClass.addAttribute(object, params.idName, attribute);
    }
    if ((0,_core_Type__WEBPACK_IMPORTED_MODULE_5__/* .isBooleanTrue */ .bI)(params.idn)) {
      const attribute = {
        isString: false,
        array: new Array(_primitives.length),
        itemSize: 1
      };
      primitiveClass.addAttribute(object, params.idnName, attribute);
    }
    this._addAttributesToEntities(_primitives, params);
  }
  _addAttributesToEntities(entities, params) {
    const entitiesCount = entities.length;
    if ((0,_core_Type__WEBPACK_IMPORTED_MODULE_5__/* .isBooleanTrue */ .bI)(params.id)) {
      let i = 0;
      for (const entity of entities) {
        entity.setAttribValue(params.idName, i);
        i++;
      }
    }
    if ((0,_core_Type__WEBPACK_IMPORTED_MODULE_5__/* .isBooleanTrue */ .bI)(params.idn)) {
      const pointsCountMinus1 = entitiesCount - 1;
      if (pointsCountMinus1 == 0) {
        let i = 0;
        for (const entity of entities) {
          entity.setAttribValue(params.idnName, 0);
          i++;
        }
      } else {
        let i = 0;
        for (const entity of entities) {
          entity.setAttribValue(params.idnName, i / (entitiesCount - 1));
          i++;
        }
      }
    }
  }
}
AttribIdSopOperation.DEFAULT_PARAMS = {
  class: _core_geometry_Constant__WEBPACK_IMPORTED_MODULE_1__/* .ATTRIBUTE_CLASSES_WITHOUT_CORE_GROUP.indexOf */ .fc.indexOf(_core_geometry_Constant__WEBPACK_IMPORTED_MODULE_1__/* .AttribClass.POINT */ .io.POINT),
  id: true,
  idName: "id",
  idn: true,
  idnName: "idn"
};


/***/ }),

/***/ 89106:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Ch": function() { return /* binding */ AttribNormalizeSopOperation; },
/* harmony export */   "Oj": function() { return /* binding */ NORMALIZE_MODES; }
/* harmony export */ });
/* unused harmony export NormalizeMode */
/* harmony import */ var _Base__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(82612);
/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(21410);
/* harmony import */ var _engine_poly_InputCloneMode__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(56752);
/* harmony import */ var _core_String__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(40065);
/* harmony import */ var _core_BooleanValue__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(19037);






var NormalizeMode = /* @__PURE__ */ ((NormalizeMode2) => {
  NormalizeMode2["MIN_MAX_TO_01"] = "min/max to 0/1";
  NormalizeMode2["VECTOR_TO_LENGTH_1"] = "vectors to length 1";
  return NormalizeMode2;
})(NormalizeMode || {});
const NORMALIZE_MODES = ["min/max to 0/1" /* MIN_MAX_TO_01 */, "vectors to length 1" /* VECTOR_TO_LENGTH_1 */];
const _attribNames = [];
class AttribNormalizeSopOperation extends _Base__WEBPACK_IMPORTED_MODULE_0__/* .BaseSopOperation */ .U {
  constructor() {
    super(...arguments);
    this.min3 = new three__WEBPACK_IMPORTED_MODULE_1__.Vector3();
    this.max3 = new three__WEBPACK_IMPORTED_MODULE_1__.Vector3();
    this._vec = new three__WEBPACK_IMPORTED_MODULE_1__.Vector3();
  }
  static type() {
    return "attribNormalize";
  }
  cook(input_contents, params) {
    const core_group = input_contents[0];
    const objects = input_contents[0].threejsObjectsWithGeo();
    (0,_core_String__WEBPACK_IMPORTED_MODULE_2__/* .stringToAttribNames */ .Fz)(params.name, _attribNames);
    for (const object of objects) {
      const geometry = object.geometry;
      for (const attribName of _attribNames) {
        const srcAttrib = geometry.getAttribute(attribName);
        if (srcAttrib) {
          let destAttrib = srcAttrib;
          if ((0,_core_BooleanValue__WEBPACK_IMPORTED_MODULE_3__/* .isBooleanTrue */ .bI)(params.changeName) && params.newName != "") {
            destAttrib = geometry.getAttribute(params.newName);
            if (destAttrib) {
              destAttrib.needsUpdate = true;
            }
            destAttrib = destAttrib || srcAttrib.clone();
          }
          this._normalize_attribute(srcAttrib, destAttrib, params);
        }
      }
    }
    return core_group;
  }
  _normalize_attribute(src_attrib, dest_attrib, params) {
    const mode = NORMALIZE_MODES[params.mode];
    switch (mode) {
      case "min/max to 0/1" /* MIN_MAX_TO_01 */:
        return this._normalize_from_min_max_to_01(src_attrib, dest_attrib);
      case "vectors to length 1" /* VECTOR_TO_LENGTH_1 */:
        return this._normalize_vectors(src_attrib, dest_attrib);
    }
  }
  _normalize_from_min_max_to_01(src_attrib, dest_attrib) {
    const attrib_size = src_attrib.itemSize;
    const src_array = src_attrib.array;
    const dest_array = dest_attrib.array;
    switch (attrib_size) {
      case 1: {
        const minf = Math.min(...src_array);
        const maxf = Math.max(...src_array);
        for (let i = 0; i < dest_array.length; i++) {
          dest_array[i] = (src_array[i] - minf) / (maxf - minf);
        }
        return;
      }
      case 3: {
        const points_count = src_array.length / attrib_size;
        const xs = new Array(points_count);
        const ys = new Array(points_count);
        const zs = new Array(points_count);
        let j = 0;
        for (let i = 0; i < points_count; i++) {
          j = i * attrib_size;
          xs[i] = src_array[j + 0];
          ys[i] = src_array[j + 1];
          zs[i] = src_array[j + 2];
        }
        this.min3.set(Math.min(...xs), Math.min(...ys), Math.min(...zs));
        this.max3.set(Math.max(...xs), Math.max(...ys), Math.max(...zs));
        for (let i = 0; i < points_count; i++) {
          j = i * attrib_size;
          dest_array[j + 0] = (xs[i] - this.min3.x) / (this.max3.x - this.min3.x);
          dest_array[j + 1] = (ys[i] - this.min3.y) / (this.max3.y - this.min3.y);
          dest_array[j + 2] = (zs[i] - this.min3.z) / (this.max3.z - this.min3.z);
        }
        return;
      }
    }
  }
  _normalize_vectors(src_attrib, dest_attrib) {
    const src_array = src_attrib.array;
    const dest_array = dest_attrib.array;
    const elements_count = src_array.length;
    if (src_attrib.itemSize == 3) {
      for (let i = 0; i < elements_count; i += 3) {
        this._vec.fromArray(src_array, i);
        this._vec.normalize();
        this._vec.toArray(dest_array, i);
      }
    }
  }
}
AttribNormalizeSopOperation.DEFAULT_PARAMS = {
  mode: 0,
  name: "position",
  changeName: false,
  newName: ""
};
AttribNormalizeSopOperation.INPUT_CLONED_STATE = _engine_poly_InputCloneMode__WEBPACK_IMPORTED_MODULE_4__/* .InputCloneMode.FROM_NODE */ .m.FROM_NODE;


/***/ }),

/***/ 44207:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "D": function() { return /* binding */ AttribRenameSopOperation; }
/* harmony export */ });
/* harmony import */ var _Base__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(82612);
/* harmony import */ var _engine_poly_InputCloneMode__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(56752);
/* harmony import */ var _core_geometry_Constant__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(91568);
/* harmony import */ var _core_geometry_CoreObjectFactory__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(17353);
/* harmony import */ var _core_geometry_Mask__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(58290);






const SPLIT_REGEX = /[ ,]+/g;
class AttribRenameSopOperation extends _Base__WEBPACK_IMPORTED_MODULE_0__/* .BaseSopOperation */ .U {
  static type() {
    return "attribRename";
  }
  cook(inputCoreGroups, params) {
    const coreGroup = inputCoreGroups[0];
    const objects = (0,_core_geometry_Mask__WEBPACK_IMPORTED_MODULE_1__/* .filterObjectsFromCoreGroup */ .sH)(coreGroup, params);
    const attribClass = _core_geometry_Constant__WEBPACK_IMPORTED_MODULE_2__/* .ATTRIBUTE_CLASSES */ .oT[params.class];
    const factory = _core_geometry_CoreObjectFactory__WEBPACK_IMPORTED_MODULE_3__/* .ENTITY_CLASS_FACTORY */ .Vd[attribClass];
    const newAttribNames = params.newName.split(SPLIT_REGEX);
    if (factory) {
      for (const object of objects) {
        const entityClass = factory(object);
        const oldAttribNames = entityClass.attributeNamesMatchingMask(object, params.oldName);
        const minCount = Math.min(oldAttribNames.length, newAttribNames.length);
        for (let i = 0; i < minCount; i++) {
          entityClass.renameAttribute(object, oldAttribNames[i], newAttribNames[i]);
        }
      }
    } else {
      const oldAttribNames = coreGroup.attributeNamesMatchingMask(params.oldName);
      const minCount = Math.min(oldAttribNames.length, newAttribNames.length);
      for (let i = 0; i < minCount; i++) {
        coreGroup.renameAttribute(oldAttribNames[i], newAttribNames[i]);
      }
    }
    return coreGroup;
  }
}
AttribRenameSopOperation.DEFAULT_PARAMS = {
  group: "",
  class: _core_geometry_Constant__WEBPACK_IMPORTED_MODULE_2__/* .ATTRIBUTE_CLASSES.indexOf */ .oT.indexOf(_core_geometry_Constant__WEBPACK_IMPORTED_MODULE_2__/* .AttribClass.POINT */ .io.POINT),
  oldName: "",
  newName: ""
};
AttribRenameSopOperation.INPUT_CLONED_STATE = _engine_poly_InputCloneMode__WEBPACK_IMPORTED_MODULE_4__/* .InputCloneMode.FROM_NODE */ .m.FROM_NODE;


/***/ }),

/***/ 70297:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Y": function() { return /* binding */ AttribSetAtIndexSopOperation; }
/* harmony export */ });
/* harmony import */ var _Base__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(82612);
/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(21410);
/* harmony import */ var _core_geometry_Constant__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(91568);
/* harmony import */ var _engine_poly_InputCloneMode__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(56752);
/* harmony import */ var _engine_poly_Assert__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(68239);
/* harmony import */ var _core_geometry_Attribute__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(32558);
/* harmony import */ var _core_geometry_CoreObjectFactory__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(17353);
/* harmony import */ var _core_geometry_entities_point_CorePointUtils__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(50253);









const _points = [];
const _AttribSetAtIndexSopOperation = class extends _Base__WEBPACK_IMPORTED_MODULE_0__/* .BaseSopOperation */ .U {
  static type() {
    return "attribSetAtIndex";
  }
  cook(inputCoreGroups, params) {
    var _a;
    const coreGroup = inputCoreGroups[0];
    const attribName = params.name;
    if (attribName && attribName.trim() != "") {
      this._addAttribute(_core_geometry_Constant__WEBPACK_IMPORTED_MODULE_1__/* .ATTRIBUTE_CLASSES */ .oT[params.class], coreGroup, params);
    } else {
      (_a = this.states) == null ? void 0 : _a.error.set("attribute name is not valid");
    }
    return coreGroup;
  }
  _addAttribute(attribClass, coreGroup, params) {
    var _a, _b;
    const attribType = _core_geometry_Constant__WEBPACK_IMPORTED_MODULE_1__/* .ATTRIBUTE_TYPES */ .Xu[params.type];
    switch (attribClass) {
      case _core_geometry_Constant__WEBPACK_IMPORTED_MODULE_1__/* .AttribClass.POINT */ .io.POINT:
        this._addPointAttribute(attribType, coreGroup, params);
        return;
      case _core_geometry_Constant__WEBPACK_IMPORTED_MODULE_1__/* .AttribClass.VERTEX */ .io.VERTEX:
        (_a = this.states) == null ? void 0 : _a.error.set("vertex not supported yet");
        return;
      case _core_geometry_Constant__WEBPACK_IMPORTED_MODULE_1__/* .AttribClass.PRIMITIVE */ .io.PRIMITIVE:
        (_b = this.states) == null ? void 0 : _b.error.set("primitive not supported yet");
        return;
      case _core_geometry_Constant__WEBPACK_IMPORTED_MODULE_1__/* .AttribClass.OBJECT */ .io.OBJECT:
        this._addObjectAttribute(attribType, coreGroup, params);
        return;
      case _core_geometry_Constant__WEBPACK_IMPORTED_MODULE_1__/* .AttribClass.CORE_GROUP */ .io.CORE_GROUP:
        this._addCoreGroupAttribute(attribType, coreGroup, params);
        return;
    }
    _engine_poly_Assert__WEBPACK_IMPORTED_MODULE_2__/* .TypeAssert.unreachable */ .f.unreachable(attribClass);
  }
  _addPointAttribute(attribType, coreGroup, params) {
    const objects = coreGroup.allObjects();
    switch (attribType) {
      case _core_geometry_Constant__WEBPACK_IMPORTED_MODULE_1__/* .AttribType.NUMERIC */ .rp.NUMERIC: {
        for (let object of objects) {
          this._addNumericAttributeToPoints(object, params);
        }
        return;
      }
      case _core_geometry_Constant__WEBPACK_IMPORTED_MODULE_1__/* .AttribType.STRING */ .rp.STRING: {
        for (let object of objects) {
          this._addStringAttributeToPoints(object, params);
        }
        return;
      }
    }
    _engine_poly_Assert__WEBPACK_IMPORTED_MODULE_2__/* .TypeAssert.unreachable */ .f.unreachable(attribType);
  }
  _addObjectAttribute(attribType, coreGroup, params) {
    const allCoreObjects = coreGroup.allCoreObjects();
    const attribName = params.name;
    const defaultValue = _AttribSetAtIndexSopOperation.defaultAttribValue(params);
    if (defaultValue != null) {
      for (let coreObject2 of allCoreObjects) {
        if (!coreObject2.hasAttribute(attribName)) {
          coreObject2.setAttribValue(attribName, defaultValue);
        }
      }
    }
    const coreObject = allCoreObjects[params.index];
    if (!coreObject) {
      return;
    }
    switch (attribType) {
      case _core_geometry_Constant__WEBPACK_IMPORTED_MODULE_1__/* .AttribType.NUMERIC */ .rp.NUMERIC:
        this._addNumericAttributeToObject(coreObject, params);
        return;
      case _core_geometry_Constant__WEBPACK_IMPORTED_MODULE_1__/* .AttribType.STRING */ .rp.STRING:
        this._addStringAttributeToObject(coreObject, params);
        return;
    }
    _engine_poly_Assert__WEBPACK_IMPORTED_MODULE_2__/* .TypeAssert.unreachable */ .f.unreachable(attribType);
  }
  _addCoreGroupAttribute(attribType, coreGroup, params) {
    switch (attribType) {
      case _core_geometry_Constant__WEBPACK_IMPORTED_MODULE_1__/* .AttribType.NUMERIC */ .rp.NUMERIC:
        this._addNumericAttributeToCoreGroup(coreGroup, params);
        return;
      case _core_geometry_Constant__WEBPACK_IMPORTED_MODULE_1__/* .AttribType.STRING */ .rp.STRING:
        this._addStringAttributeToCoreGroup(coreGroup, params);
        return;
    }
    _engine_poly_Assert__WEBPACK_IMPORTED_MODULE_2__/* .TypeAssert.unreachable */ .f.unreachable(attribType);
  }
  _addNumericAttributeToPoints(object, params) {
    const corePointClass = (0,_core_geometry_CoreObjectFactory__WEBPACK_IMPORTED_MODULE_3__/* .corePointClassFactory */ .E_)(object);
    const attribName = _core_geometry_Attribute__WEBPACK_IMPORTED_MODULE_4__/* .CoreAttribute.remapName */ .n0.remapName(params.name);
    if (!corePointClass.hasAttribute(object, attribName)) {
      corePointClass.addNumericAttribute(object, attribName, params.size, 0);
    }
    const attrib = corePointClass.attribute(object, attribName);
    const array = attrib.array;
    const { index, size } = params;
    switch (size) {
      case 1: {
        if (index < array.length) {
          array[index] = params.value1;
          attrib.needsUpdate = true;
        }
        break;
      }
      case 2: {
        const i2 = index * 2;
        if (i2 < array.length) {
          params.value2.toArray(array, i2);
          attrib.needsUpdate = true;
        }
        break;
      }
      case 3: {
        const i3 = index * 3;
        if (i3 < array.length) {
          params.value3.toArray(array, i3);
          attrib.needsUpdate = true;
        }
        break;
      }
      case 4: {
        const i4 = index * 4;
        if (i4 < array.length) {
          params.value4.toArray(array, i4);
          attrib.needsUpdate = true;
        }
        break;
      }
    }
  }
  _addNumericAttributeToObject(coreObject, params) {
    const value = [params.value1, params.value2, params.value3, params.value4][params.size - 1];
    const attribName = params.name;
    coreObject.setAttribValue(attribName, value);
  }
  _addNumericAttributeToCoreGroup(coreGroup, params) {
    const value = [params.value1, params.value2, params.value3, params.value4][params.size - 1];
    const attribName = params.name;
    coreGroup.setAttribValue(attribName, value);
  }
  _addStringAttributeToPoints(object, params) {
    const corePointClass = (0,_core_geometry_CoreObjectFactory__WEBPACK_IMPORTED_MODULE_3__/* .corePointClassFactory */ .E_)(object);
    const attribName = params.name;
    if (!corePointClass.hasAttribute(object, attribName)) {
      const tmpIndexData = _core_geometry_Attribute__WEBPACK_IMPORTED_MODULE_4__/* .CoreAttribute.arrayToIndexedArrays */ .n0.arrayToIndexedArrays([""]);
      corePointClass.setIndexedAttribute(object, attribName, tmpIndexData["values"], tmpIndexData["indices"]);
    }
    const value = params.string;
    (0,_core_geometry_entities_point_CorePointUtils__WEBPACK_IMPORTED_MODULE_5__/* .pointsFromObject */ .u_)(object, _points);
    const indexPoint = _points[params.index];
    let stringValues = new Array(_points.length);
    stringValues = stringValues.length != _points.length ? new Array(_points.length) : stringValues;
    for (const point of _points) {
      let currentValue = point.stringAttribValue(attribName);
      if (currentValue == null) {
        currentValue = "";
      }
      stringValues[point.index()] = currentValue;
    }
    if (indexPoint) {
      stringValues[indexPoint.index()] = value;
    }
    const indexData = _core_geometry_Attribute__WEBPACK_IMPORTED_MODULE_4__/* .CoreAttribute.arrayToIndexedArrays */ .n0.arrayToIndexedArrays(stringValues);
    corePointClass.setIndexedAttribute(object, attribName, indexData["values"], indexData["indices"]);
  }
  _addStringAttributeToObject(coreObject, params) {
    const value = params.string;
    coreObject.setAttribValue(params.name, value);
  }
  _addStringAttributeToCoreGroup(coreGroup, params) {
    const value = params.string;
    coreGroup.setAttribValue(params.name, value);
  }
  //
  //
  // INTERNAL UTILS
  //
  //
  static _attribType(params) {
    return _core_geometry_Constant__WEBPACK_IMPORTED_MODULE_1__/* .ATTRIBUTE_TYPES */ .Xu[params.type];
  }
  static defaultAttribValue(params) {
    const attribType = this._attribType(params);
    switch (attribType) {
      case _core_geometry_Constant__WEBPACK_IMPORTED_MODULE_1__/* .AttribType.NUMERIC */ .rp.NUMERIC: {
        return this._defaultNumericValue(params);
      }
      case _core_geometry_Constant__WEBPACK_IMPORTED_MODULE_1__/* .AttribType.STRING */ .rp.STRING: {
        return this._defaultStringValue();
      }
    }
    _engine_poly_Assert__WEBPACK_IMPORTED_MODULE_2__/* .TypeAssert.unreachable */ .f.unreachable(attribType);
  }
  static _defaultStringValue() {
    return "";
  }
  static _defaultNumericValue(params) {
    const size = params.size;
    switch (size) {
      case 1:
        return 0;
      case 2:
        return new three__WEBPACK_IMPORTED_MODULE_6__.Vector2(0, 0);
      case 3:
        return new three__WEBPACK_IMPORTED_MODULE_6__.Vector3(0, 0, 0);
      case 4:
        return new three__WEBPACK_IMPORTED_MODULE_6__.Vector4(0, 0, 0, 0);
    }
  }
};
let AttribSetAtIndexSopOperation = _AttribSetAtIndexSopOperation;
AttribSetAtIndexSopOperation.DEFAULT_PARAMS = {
  index: 0,
  class: _core_geometry_Constant__WEBPACK_IMPORTED_MODULE_1__/* .ATTRIBUTE_CLASSES.indexOf */ .oT.indexOf(_core_geometry_Constant__WEBPACK_IMPORTED_MODULE_1__/* .AttribClass.POINT */ .io.POINT),
  type: _core_geometry_Constant__WEBPACK_IMPORTED_MODULE_1__/* .ATTRIBUTE_TYPES.indexOf */ .Xu.indexOf(_core_geometry_Constant__WEBPACK_IMPORTED_MODULE_1__/* .AttribType.NUMERIC */ .rp.NUMERIC),
  name: "new_attrib",
  size: 1,
  value1: 0,
  value2: new three__WEBPACK_IMPORTED_MODULE_6__.Vector2(0, 0),
  value3: new three__WEBPACK_IMPORTED_MODULE_6__.Vector3(0, 0, 0),
  value4: new three__WEBPACK_IMPORTED_MODULE_6__.Vector4(0, 0, 0, 0),
  string: ""
};
AttribSetAtIndexSopOperation.INPUT_CLONED_STATE = _engine_poly_InputCloneMode__WEBPACK_IMPORTED_MODULE_7__/* .InputCloneMode.FROM_NODE */ .m.FROM_NODE;


/***/ }),

/***/ 9733:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "R": function() { return /* binding */ AudioNotesSopOperation; },
/* harmony export */   "d": function() { return /* binding */ OUT_OF_RANGE_BEHAVIOR; }
/* harmony export */ });
/* harmony import */ var _Base__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(82612);
/* harmony import */ var _poly_InputCloneMode__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(56752);
/* harmony import */ var _core_geometry_Constant__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(91568);
/* harmony import */ var _poly_Assert__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(68239);
/* harmony import */ var _core_audio_NotesBuilder__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(83315);
/* harmony import */ var _core_geometry_Attribute__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(32558);
/* harmony import */ var _core_Type__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(19037);
/* harmony import */ var _core_geometry_entities_point_CorePointUtils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(50253);
/* harmony import */ var _core_geometry_CoreObjectFactory__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(17353);

var __async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};









var OutOfRangeBehavior = /* @__PURE__ */ ((OutOfRangeBehavior2) => {
  OutOfRangeBehavior2["RESTART"] = "restart";
  OutOfRangeBehavior2["BOUNCE"] = "bounce";
  return OutOfRangeBehavior2;
})(OutOfRangeBehavior || {});
const OUT_OF_RANGE_BEHAVIOR = ["restart" /* RESTART */, "bounce" /* BOUNCE */];
const _points = [];
class AudioNotesSopOperation extends _Base__WEBPACK_IMPORTED_MODULE_0__/* .BaseSopOperation */ .U {
  static type() {
    return "AudioNotes";
  }
  cook(inputCoreGroups, params) {
    const inputCoreGroup = inputCoreGroups[0];
    const attribClass = _core_geometry_Constant__WEBPACK_IMPORTED_MODULE_1__/* .ATTRIBUTE_CLASSES */ .oT[params.class];
    this._addAttribute(attribClass, inputCoreGroup, params);
    return inputCoreGroup;
  }
  _addAttribute(attribClass, coreGroup, params) {
    return __async(this, null, function* () {
      var _a, _b;
      switch (attribClass) {
        case _core_geometry_Constant__WEBPACK_IMPORTED_MODULE_1__/* .AttribClass.POINT */ .io.POINT:
          return this._addPointAttribute(coreGroup, params);
        case _core_geometry_Constant__WEBPACK_IMPORTED_MODULE_1__/* .AttribClass.VERTEX */ .io.VERTEX: {
          (_a = this.states) == null ? void 0 : _a.error.set("vertex not supported yet");
          return;
        }
        case _core_geometry_Constant__WEBPACK_IMPORTED_MODULE_1__/* .AttribClass.PRIMITIVE */ .io.PRIMITIVE: {
          (_b = this.states) == null ? void 0 : _b.error.set("primitive not supported yet");
          return;
        }
        case _core_geometry_Constant__WEBPACK_IMPORTED_MODULE_1__/* .AttribClass.OBJECT */ .io.OBJECT:
          return this._addObjectAttribute(coreGroup, params);
        case _core_geometry_Constant__WEBPACK_IMPORTED_MODULE_1__/* .AttribClass.CORE_GROUP */ .io.CORE_GROUP:
          return this._addCoreGroupAttribute(coreGroup, params);
      }
      _poly_Assert__WEBPACK_IMPORTED_MODULE_2__/* .TypeAssert.unreachable */ .f.unreachable(attribClass);
    });
  }
  _addPointAttribute(coreGroup, params) {
    const objects = coreGroup.allObjects();
    for (let object of objects) {
      (0,_core_geometry_entities_point_CorePointUtils__WEBPACK_IMPORTED_MODULE_3__/* .pointsFromObject */ .u_)(object, _points);
      const corePointClass = (0,_core_geometry_CoreObjectFactory__WEBPACK_IMPORTED_MODULE_4__/* .corePointClassFactory */ .E_)(object);
      const values = this._values(_points, params);
      const notesIndexData = _core_geometry_Attribute__WEBPACK_IMPORTED_MODULE_5__/* .CoreAttribute.arrayToIndexedArrays */ .n0.arrayToIndexedArrays(values.map((v) => v.note));
      corePointClass.setIndexedAttribute(object, params.name, notesIndexData.values, notesIndexData.indices);
      if ((0,_core_Type__WEBPACK_IMPORTED_MODULE_6__/* .isBooleanTrue */ .bI)(params.toctave)) {
        const octavesArray = values.map((v) => v.octave);
        if (!corePointClass.hasAttribute(object, params.octaveName)) {
          corePointClass.addNumericAttribute(object, params.octaveName, 1, 1);
        }
        let i = 0;
        for (let corePoint of _points) {
          corePoint.setAttribValue(params.octaveName, octavesArray[i]);
          i++;
        }
      }
    }
  }
  _addObjectAttribute(coreGroup, params) {
    const coreObjects = coreGroup.allCoreObjects();
    const values = this._values(coreObjects, params);
    for (let i = 0; i < coreObjects.length; i++) {
      const coreObject = coreObjects[i];
      coreObject.addAttribute(params.name, values[i].note);
      if ((0,_core_Type__WEBPACK_IMPORTED_MODULE_6__/* .isBooleanTrue */ .bI)(params.toctave)) {
        coreObject.addAttribute(params.octaveName, values[i].octave);
      }
    }
  }
  _addCoreGroupAttribute(coreGroup, params) {
    const values = this._values([coreGroup], params);
    coreGroup.addAttribute(params.name, values[0].note);
    if ((0,_core_Type__WEBPACK_IMPORTED_MODULE_6__/* .isBooleanTrue */ .bI)(params.toctave)) {
      coreGroup.addAttribute(params.octaveName, values[0].octave);
    }
  }
  _values(entities, params) {
    let increment = 1;
    let i = 0;
    const behavior = OUT_OF_RANGE_BEHAVIOR[params.outOfRangeBehavior];
    const noteHolders = _core_audio_NotesBuilder__WEBPACK_IMPORTED_MODULE_7__/* .NotesBuilder.list */ .o.list(params.startOctave, params.endOctave);
    const values = [];
    for (let k = 0; k < entities.length; k++) {
      if (i >= noteHolders.length) {
        switch (behavior) {
          case "bounce" /* BOUNCE */: {
            increment = -1;
            i = noteHolders.length - 2;
            break;
          }
          case "restart" /* RESTART */: {
            i = 0;
            break;
          }
        }
      }
      if (behavior == "bounce" /* BOUNCE */) {
        if (i == 0 && increment < 0) {
          increment = 1;
          i = 1;
        }
      }
      const note = noteHolders[i];
      values.push(note);
      i += increment;
    }
    return values;
  }
}
AudioNotesSopOperation.DEFAULT_PARAMS = {
  class: _core_geometry_Constant__WEBPACK_IMPORTED_MODULE_1__/* .ATTRIBUTE_CLASSES.indexOf */ .oT.indexOf(_core_geometry_Constant__WEBPACK_IMPORTED_MODULE_1__/* .AttribClass.OBJECT */ .io.OBJECT),
  name: "note",
  toctave: false,
  octaveName: "octave",
  startOctave: 2,
  endOctave: 4,
  outOfRangeBehavior: OUT_OF_RANGE_BEHAVIOR.indexOf("bounce" /* BOUNCE */)
};
AudioNotesSopOperation.INPUT_CLONED_STATE = _poly_InputCloneMode__WEBPACK_IMPORTED_MODULE_8__/* .InputCloneMode.FROM_NODE */ .m.FROM_NODE;


/***/ }),

/***/ 88423:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "U": function() { return /* binding */ BboxScatterSopOperation; }
/* harmony export */ });
/* harmony import */ var _Base__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(82612);
/* harmony import */ var _engine_poly_InputCloneMode__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(56752);
/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(21410);
/* harmony import */ var _core_geometry_Constant__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(91568);





const tmpBox = new three__WEBPACK_IMPORTED_MODULE_0__.Box3();
class BboxScatterSopOperation extends _Base__WEBPACK_IMPORTED_MODULE_1__/* .BaseSopOperation */ .U {
  static type() {
    return "bboxScatter";
  }
  cook(inputCoreGroups, params) {
    const inputCoreGroup = inputCoreGroups[0];
    const stepSize = params.stepSize;
    inputCoreGroup.boundingBox(tmpBox);
    const min = tmpBox.min;
    const max = tmpBox.max;
    const positions = [];
    for (let x = min.x; x <= max.x; x += stepSize) {
      for (let y = min.y; y <= max.y; y += stepSize) {
        for (let z = min.z; z <= max.z; z += stepSize) {
          positions.push(x);
          positions.push(y);
          positions.push(z);
        }
      }
    }
    const geometry = new three__WEBPACK_IMPORTED_MODULE_0__.BufferGeometry();
    geometry.setAttribute("position", new three__WEBPACK_IMPORTED_MODULE_0__.BufferAttribute(new Float32Array(positions), 3));
    const object = _Base__WEBPACK_IMPORTED_MODULE_1__/* .BaseSopOperation.createObject */ .U.createObject(geometry, _core_geometry_Constant__WEBPACK_IMPORTED_MODULE_2__/* .ObjectType.POINTS */ .LP.POINTS);
    if (this._node) {
      object.name = this._node.name();
    }
    return this.createCoreGroupFromObjects([object]);
  }
}
BboxScatterSopOperation.DEFAULT_PARAMS = {
  stepSize: 1
};
BboxScatterSopOperation.INPUT_CLONED_STATE = _engine_poly_InputCloneMode__WEBPACK_IMPORTED_MODULE_3__/* .InputCloneMode.NEVER */ .m.NEVER;


/***/ }),

/***/ 90243:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "GJ": function() { return /* binding */ BooleanSopOperation; },
/* harmony export */   "x8": function() { return /* binding */ BOOLEAN_OPERATIONS; }
/* harmony export */ });
/* unused harmony export BooleanOperation */
/* harmony import */ var _core_String__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(40065);
/* harmony import */ var _Base__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(82612);
/* harmony import */ var _poly_InputCloneMode__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(56752);
/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(21410);
/* harmony import */ var _core_thirdParty_three_bvh_csg__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(60444);
/* harmony import */ var _core_thirdParty_three_bvh_csg__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(27087);
/* harmony import */ var _core_thirdParty_three_bvh_csg__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(32188);
/* harmony import */ var _core_geometry_Constant__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(91568);
/* harmony import */ var _core_geometry_modules_three_builders_Merge__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(92276);
/* harmony import */ var _core_ArrayUtils__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(87132);









var BooleanOperation = /* @__PURE__ */ ((BooleanOperation2) => {
  BooleanOperation2["INTERSECT"] = "intersect";
  BooleanOperation2["SUBTRACT"] = "subtract";
  BooleanOperation2["ADD"] = "add";
  BooleanOperation2["DIFFERENCE"] = "difference";
  return BooleanOperation2;
})(BooleanOperation || {});
const BOOLEAN_OPERATIONS = [
  "intersect" /* INTERSECT */,
  "subtract" /* SUBTRACT */,
  "add" /* ADD */,
  "difference" /* DIFFERENCE */
];
const evaluationIdByBooleanOperation = {
  ["intersect" /* INTERSECT */]: _core_thirdParty_three_bvh_csg__WEBPACK_IMPORTED_MODULE_0__/* .INTERSECTION */ .TP,
  ["subtract" /* SUBTRACT */]: _core_thirdParty_three_bvh_csg__WEBPACK_IMPORTED_MODULE_0__/* .SUBTRACTION */ .vC,
  ["add" /* ADD */]: _core_thirdParty_three_bvh_csg__WEBPACK_IMPORTED_MODULE_0__/* .ADDITION */ .UC,
  ["difference" /* DIFFERENCE */]: _core_thirdParty_three_bvh_csg__WEBPACK_IMPORTED_MODULE_0__/* .DIFFERENCE */ .tD
};
const _attribNames = [];
class BooleanSopOperation extends _Base__WEBPACK_IMPORTED_MODULE_1__/* .BaseSopOperation */ .U {
  static type() {
    return "boolean";
  }
  cook(inputCoreGroups, params) {
    var _a;
    const meshA = inputCoreGroups[0].threejsObjectsWithGeo()[0];
    const meshB = inputCoreGroups[1].threejsObjectsWithGeo()[0];
    if (!(meshA && meshA.geometry && meshB && meshB.geometry)) {
      (_a = this.states) == null ? void 0 : _a.error.set("input objects need to have mesh geometries at the top level");
      return this.createCoreGroupFromObjects([]);
    }
    const csgEvaluator = new _core_thirdParty_three_bvh_csg__WEBPACK_IMPORTED_MODULE_2__/* .Evaluator */ .v();
    const brush1 = new _core_thirdParty_three_bvh_csg__WEBPACK_IMPORTED_MODULE_3__/* .Brush */ .B(meshA.geometry, params.keepMaterials ? meshA.material : void 0);
    const brush2 = new _core_thirdParty_three_bvh_csg__WEBPACK_IMPORTED_MODULE_3__/* .Brush */ .B(meshB.geometry, params.keepMaterials ? meshB.material : void 0);
    const operation = BOOLEAN_OPERATIONS[params.operation];
    const operationId = evaluationIdByBooleanOperation[operation];
    const attributes = ["position", "normal"];
    if (params.keepVertexColor) {
      attributes.push("color");
    }
    if (params.additionalAttributes.trim() != "") {
      (0,_core_String__WEBPACK_IMPORTED_MODULE_4__/* .stringToAttribNames */ .Fz)(params.additionalAttributes, _attribNames);
      (0,_core_ArrayUtils__WEBPACK_IMPORTED_MODULE_5__/* .arrayPushItems */ .L_)(_attribNames, attributes);
    }
    csgEvaluator.attributes = attributes;
    csgEvaluator.useGroups = params.keepMaterials || params.useInputGroups;
    csgEvaluator.debug.enabled = params.intersectionEdgesOnly;
    const output = csgEvaluator.evaluate(brush1, brush2, operationId);
    if (params.intersectionEdgesOnly) {
      const lines = csgEvaluator.debug.intersectionEdges;
      if (lines.length > 0) {
        const linesGeometry = _createLinesObject(lines);
        if (linesGeometry) {
          const object = _Base__WEBPACK_IMPORTED_MODULE_1__/* .BaseSopOperation.createObject */ .U.createObject(linesGeometry, _core_geometry_Constant__WEBPACK_IMPORTED_MODULE_6__/* .ObjectType.LINE_SEGMENTS */ .LP.LINE_SEGMENTS);
          return this.createCoreGroupFromObjects([object]);
        }
      }
    } else {
      output.disposeCacheData();
      _Base__WEBPACK_IMPORTED_MODULE_1__/* .BaseSopOperation.createIndexIfNone */ .U.createIndexIfNone(output.geometry);
      if (!params.keepMaterials) {
        output.material = meshA.material;
      }
      return this.createCoreGroupFromObjects([output]);
    }
    return this.createCoreGroupFromObjects([]);
  }
}
BooleanSopOperation.DEFAULT_PARAMS = {
  operation: BOOLEAN_OPERATIONS.indexOf("intersect" /* INTERSECT */),
  keepVertexColor: false,
  additionalAttributes: "",
  keepMaterials: true,
  useInputGroups: false,
  intersectionEdgesOnly: false
};
BooleanSopOperation.INPUT_CLONED_STATE = [_poly_InputCloneMode__WEBPACK_IMPORTED_MODULE_7__/* .InputCloneMode.FROM_NODE */ .m.FROM_NODE, _poly_InputCloneMode__WEBPACK_IMPORTED_MODULE_7__/* .InputCloneMode.NEVER */ .m.NEVER];
function _createLinesObject(lines) {
  const geometries = lines.map(_createLineGeometry);
  return _core_geometry_modules_three_builders_Merge__WEBPACK_IMPORTED_MODULE_8__/* .CoreGeometryBuilderMerge.merge */ .O.merge(geometries);
}
function _createLineGeometry(line) {
  const pointsCount = 2;
  const positions = new Array(pointsCount * 3);
  const indices = new Array(pointsCount);
  const i = 0;
  line.start.toArray(positions, i * 3);
  line.end.toArray(positions, (i + 1) * 3);
  indices[0] = 0;
  indices[1] = 1;
  const geometry = new three__WEBPACK_IMPORTED_MODULE_9__.BufferGeometry();
  geometry.setAttribute("position", new three__WEBPACK_IMPORTED_MODULE_9__.Float32BufferAttribute(positions, 3));
  geometry.setIndex(indices);
  return geometry;
}


/***/ }),

/***/ 32458:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "v": function() { return /* binding */ BoxSopOperation; }
/* harmony export */ });
/* harmony import */ var _core_geometry_Constant__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(91568);
/* harmony import */ var _Base__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(82612);
/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(21410);
/* harmony import */ var _core_Transform__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(87883);
/* harmony import */ var _engine_poly_InputCloneMode__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(56752);






const tmpBox = new three__WEBPACK_IMPORTED_MODULE_0__.Box3();
const tmpSize = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();
const tmpCenter = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();
function _roundDivision(division) {
  return Math.max(1, Math.floor(division));
}
class BoxSopOperation extends _Base__WEBPACK_IMPORTED_MODULE_1__/* .BaseSopOperation */ .U {
  constructor() {
    super(...arguments);
    this._coreTransform = new _core_Transform__WEBPACK_IMPORTED_MODULE_2__/* .CoreTransform */ .ZR();
  }
  static type() {
    return "box";
  }
  cook(inputCoreGroups, params) {
    const inputCoreGroup = inputCoreGroups[0];
    const geometry = inputCoreGroup ? this._cookWithInput(inputCoreGroup, params) : this._cookWithoutInput(params);
    const object = _Base__WEBPACK_IMPORTED_MODULE_1__/* .BaseSopOperation.createObject */ .U.createObject(geometry, _core_geometry_Constant__WEBPACK_IMPORTED_MODULE_3__/* .ObjectType.MESH */ .LP.MESH);
    if (this._node) {
      object.name = this._node.name();
    }
    return this.createCoreGroupFromObjects([object]);
  }
  _cookWithoutInput(params) {
    const { divisions, size, sizes } = params;
    const geometry = new three__WEBPACK_IMPORTED_MODULE_0__.BoxGeometry(
      size * sizes.x,
      size * sizes.y,
      size * sizes.z,
      _roundDivision(divisions.x),
      _roundDivision(divisions.y),
      _roundDivision(divisions.z)
    );
    geometry.translate(params.center.x, params.center.y, params.center.z);
    geometry.computeVertexNormals();
    return geometry;
  }
  _cookWithInput(coreGroup, params) {
    coreGroup.boundingBox(tmpBox);
    tmpBox.getSize(tmpSize);
    tmpBox.getCenter(tmpCenter);
    const divisions = params.divisions;
    const geometry = new three__WEBPACK_IMPORTED_MODULE_0__.BoxGeometry(
      tmpSize.x,
      tmpSize.y,
      tmpSize.z,
      _roundDivision(divisions.x),
      _roundDivision(divisions.y),
      _roundDivision(divisions.z)
    );
    const matrix = this._coreTransform.translationMatrix(tmpCenter);
    geometry.applyMatrix4(matrix);
    return geometry;
  }
}
BoxSopOperation.DEFAULT_PARAMS = {
  sizes: new three__WEBPACK_IMPORTED_MODULE_0__.Vector3(1, 1, 1),
  size: 1,
  divisions: new three__WEBPACK_IMPORTED_MODULE_0__.Vector3(1, 1, 1),
  center: new three__WEBPACK_IMPORTED_MODULE_0__.Vector3(0, 0, 0)
};
BoxSopOperation.INPUT_CLONED_STATE = _engine_poly_InputCloneMode__WEBPACK_IMPORTED_MODULE_4__/* .InputCloneMode.NEVER */ .m.NEVER;


/***/ }),

/***/ 6490:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "i": function() { return /* binding */ CameraProjectSopOperation; }
/* harmony export */ });
/* harmony import */ var _Base__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(82612);
/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(21410);
/* harmony import */ var _poly_InputCloneMode__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(56752);
/* harmony import */ var _core_Type__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(19037);





const _points = [];
class CameraProjectSopOperation extends _Base__WEBPACK_IMPORTED_MODULE_0__/* .BaseSopOperation */ .U {
  constructor() {
    super(...arguments);
    this._pointPosition = new three__WEBPACK_IMPORTED_MODULE_1__.Vector3();
  }
  static type() {
    return "cameraProject";
  }
  cook(inputCoreGroups, params) {
    var _a;
    const inputCoreGroup = inputCoreGroups[0];
    const cameraCoreGroup = inputCoreGroups[1];
    let cameraObject;
    const cameraCoreGroupObjects = cameraCoreGroup.threejsObjects();
    for (let cameraCoreGroupObject of cameraCoreGroupObjects) {
      cameraCoreGroupObject.traverse((childObject) => {
        if (!cameraObject) {
          if (childObject.isCamera) {
            cameraObject = childObject;
          }
        }
      });
    }
    if (!cameraObject) {
      (_a = this.states) == null ? void 0 : _a.error.set(`camera not found.`);
      return inputCoreGroup;
    }
    cameraObject.updateMatrix();
    if (cameraObject.isPerspectiveCamera || cameraObject.isOrthographicCamera) {
      cameraObject.updateProjectionMatrix();
    }
    inputCoreGroup.points(_points);
    const project = (0,_core_Type__WEBPACK_IMPORTED_MODULE_2__/* .isBooleanTrue */ .bI)(params.project);
    for (const point of _points) {
      point.position(this._pointPosition);
      if (project) {
        this._pointPosition.project(cameraObject);
      } else {
        this._pointPosition.unproject(cameraObject);
      }
      point.setPosition(this._pointPosition);
    }
    return inputCoreGroup;
  }
}
CameraProjectSopOperation.DEFAULT_PARAMS = {
  project: true
};
CameraProjectSopOperation.INPUT_CLONED_STATE = _poly_InputCloneMode__WEBPACK_IMPORTED_MODULE_3__/* .InputCloneMode.FROM_NODE */ .m.FROM_NODE;


/***/ }),

/***/ 48863:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "c": function() { return /* binding */ CameraViewOffsetSopOperation; }
/* harmony export */ });
/* harmony import */ var _Base__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(82612);
/* harmony import */ var _engine_poly_InputCloneMode__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(56752);
/* harmony import */ var _core_geometry_modules_three_ThreejsCoreObject__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(2318);
/* harmony import */ var _core_camera_CoreCamera__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(54924);
/* harmony import */ var _poly_NodeContext__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(52070);
/* harmony import */ var _core_geometry_Mask__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(58290);
/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(21410);








const _CameraViewOffsetSopOperation = class extends _Base__WEBPACK_IMPORTED_MODULE_0__/* .BaseSopOperation */ .U {
  static type() {
    return _poly_NodeContext__WEBPACK_IMPORTED_MODULE_1__/* .CameraSopNodeType.VIEW_OFFSET */ .$4.VIEW_OFFSET;
  }
  cook(inputCoreGroups, params) {
    const coreGroup = inputCoreGroups[0];
    const objects = _core_geometry_Mask__WEBPACK_IMPORTED_MODULE_2__/* .CoreMask.filterObjects */ .x0.filterObjects(coreGroup, {
      group: params.group
    });
    if (this._node) {
      _CameraViewOffsetSopOperation.updateObject({ objects, params });
    }
    return coreGroup;
  }
  static updateObject(options) {
    const { objects, params } = options;
    for (let object of objects) {
      _core_geometry_modules_three_ThreejsCoreObject__WEBPACK_IMPORTED_MODULE_3__/* .ThreejsCoreObject.addAttribute */ .W.addAttribute(object, _core_camera_CoreCamera__WEBPACK_IMPORTED_MODULE_4__/* .CameraAttribute.VIEW_OFFSET_MIN */ .vd.VIEW_OFFSET_MIN, params.min);
      _core_geometry_modules_three_ThreejsCoreObject__WEBPACK_IMPORTED_MODULE_3__/* .ThreejsCoreObject.addAttribute */ .W.addAttribute(object, _core_camera_CoreCamera__WEBPACK_IMPORTED_MODULE_4__/* .CameraAttribute.VIEW_OFFSET_MAX */ .vd.VIEW_OFFSET_MAX, params.max);
    }
  }
};
let CameraViewOffsetSopOperation = _CameraViewOffsetSopOperation;
CameraViewOffsetSopOperation.DEFAULT_PARAMS = {
  group: "",
  min: new three__WEBPACK_IMPORTED_MODULE_5__.Vector2(0, 0),
  max: new three__WEBPACK_IMPORTED_MODULE_5__.Vector2(1, 1)
};
CameraViewOffsetSopOperation.INPUT_CLONED_STATE = _engine_poly_InputCloneMode__WEBPACK_IMPORTED_MODULE_6__/* .InputCloneMode.FROM_NODE */ .m.FROM_NODE;


/***/ }),

/***/ 66054:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Hx": function() { return /* binding */ CENTER_MODES; },
/* harmony export */   "Ng": function() { return /* binding */ CenterSopOperation; }
/* harmony export */ });
/* unused harmony export CenterMode */
/* harmony import */ var _Base__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(82612);
/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(21410);
/* harmony import */ var _core_geometry_Constant__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(91568);
/* harmony import */ var _engine_poly_InputCloneMode__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(56752);
/* harmony import */ var _core_geometry_Attribute__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(32558);
/* harmony import */ var _poly_Assert__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(68239);







const _geoCenter = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();
var CenterMode = /* @__PURE__ */ ((CenterMode2) => {
  CenterMode2["OBJECT_ORIGIN"] = "object origin";
  CenterMode2["GEOMETRY_CENTER"] = "geometry center";
  return CenterMode2;
})(CenterMode || {});
const CENTER_MODES = ["object origin" /* OBJECT_ORIGIN */, "geometry center" /* GEOMETRY_CENTER */];
class CenterSopOperation extends _Base__WEBPACK_IMPORTED_MODULE_1__/* .BaseSopOperation */ .U {
  static type() {
    return "center";
  }
  cook(inputCoreGroups, params) {
    const coreGroup = inputCoreGroups[0];
    const srcObjects = coreGroup.threejsObjectsWithGeo();
    const mode = CENTER_MODES[params.mode];
    const positions = new Array(srcObjects.length * 3);
    positions.fill(0);
    for (let i = 0; i < srcObjects.length; i++) {
      const srcObject = srcObjects[i];
      this._applyCenter(mode, srcObject, positions, i);
    }
    const geometry = new three__WEBPACK_IMPORTED_MODULE_0__.BufferGeometry();
    geometry.setAttribute(_core_geometry_Attribute__WEBPACK_IMPORTED_MODULE_2__/* .Attribute.POSITION */ .ah.POSITION, new three__WEBPACK_IMPORTED_MODULE_0__.BufferAttribute(new Float32Array(positions), 3));
    const object = this.createObject(geometry, _core_geometry_Constant__WEBPACK_IMPORTED_MODULE_3__/* .ObjectType.POINTS */ .LP.POINTS);
    if (this._node) {
      object.name = this._node.name();
    }
    return this.createCoreGroupFromObjects([object]);
  }
  _applyCenter(mode, object, positions, i) {
    var _a;
    object.updateMatrixWorld();
    switch (mode) {
      case "object origin" /* OBJECT_ORIGIN */: {
        object.getWorldPosition(_geoCenter);
        _geoCenter.toArray(positions, i * 3);
        return;
      }
      case "geometry center" /* GEOMETRY_CENTER */: {
        const srcGeometry = object.geometry;
        srcGeometry.computeBoundingBox();
        if (srcGeometry.boundingBox) {
          (_a = srcGeometry.boundingBox) == null ? void 0 : _a.getCenter(_geoCenter);
          _geoCenter.applyMatrix4(object.matrixWorld);
          _geoCenter.toArray(positions, i * 3);
        }
        return;
      }
    }
    _poly_Assert__WEBPACK_IMPORTED_MODULE_4__/* .TypeAssert.unreachable */ .f.unreachable(mode);
  }
}
CenterSopOperation.DEFAULT_PARAMS = {
  mode: CENTER_MODES.indexOf("object origin" /* OBJECT_ORIGIN */)
};
CenterSopOperation.INPUT_CLONED_STATE = _engine_poly_InputCloneMode__WEBPACK_IMPORTED_MODULE_5__/* .InputCloneMode.FROM_NODE */ .m.FROM_NODE;


/***/ }),

/***/ 90872:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "A": function() { return /* binding */ CubeCameraSopOperation; }
/* harmony export */ });
/* unused harmony export CubeCameraExtended */
/* harmony import */ var _Base__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(82612);
/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(21410);
/* harmony import */ var _engine_poly_InputCloneMode__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(56752);
/* harmony import */ var _poly_NodeContext__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(52070);
/* harmony import */ var _core_camera_CoreCamera__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(54924);
/* harmony import */ var _core_camera_CoreCubeCamera__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(45678);
/* harmony import */ var _core_Type__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(19037);
/* harmony import */ var _core_helpers_CameraHelper__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(15745);
/* harmony import */ var _core_geometry_modules_three_ThreejsCoreObject__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(2318);
/* harmony import */ var _core_geometry_Constant__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(91568);











class CubeCameraExtended extends three__WEBPACK_IMPORTED_MODULE_0__.CubeCamera {
  copy(source, recursive) {
    const clonedCubeCamera = super.copy(source, recursive);
    let child;
    while (child = clonedCubeCamera.children[0]) {
      clonedCubeCamera.remove(child);
    }
    for (let srcChild of source.children) {
      clonedCubeCamera.add(srcChild.clone());
    }
    clonedCubeCamera.renderTarget = source.renderTarget;
    return clonedCubeCamera;
  }
}
const _CubeCameraSopOperation = class extends _Base__WEBPACK_IMPORTED_MODULE_1__/* .BaseSopOperation */ .U {
  static type() {
    return _poly_NodeContext__WEBPACK_IMPORTED_MODULE_2__/* .CameraNodeType.CUBE */ .hY.CUBE;
  }
  cook(inputCoreGroups, params) {
    const camera = _CubeCameraSopOperation.createCamera(params, this._node);
    camera.name = params.name || _poly_NodeContext__WEBPACK_IMPORTED_MODULE_2__/* .CameraNodeType.CUBE */ .hY.CUBE;
    camera.position.copy(params.position);
    camera.rotation.set(
      three__WEBPACK_IMPORTED_MODULE_0__.MathUtils.degToRad(params.rotation.x),
      three__WEBPACK_IMPORTED_MODULE_0__.MathUtils.degToRad(params.rotation.y),
      three__WEBPACK_IMPORTED_MODULE_0__.MathUtils.degToRad(params.rotation.z)
    );
    _CubeCameraSopOperation.updateCamera(camera, params);
    const objects = [camera];
    return this.createCoreGroupFromObjects(objects);
  }
  static updateCamera(camera, params) {
    camera.updateWorldMatrix(false, true);
    const childCameras = camera.children.filter(
      (c) => c.isPerspectiveCamera
    );
    let i = 0;
    for (const childCamera of childCameras) {
      childCamera.name = `${camera.name}-perspectiveCamera-${i}`;
      childCamera.updateProjectionMatrix();
      i++;
    }
    camera.matrixAutoUpdate = params.matrixAutoUpdate;
    _CubeCameraSopOperation.setCameraAttributes(camera, params);
    if ((0,_core_Type__WEBPACK_IMPORTED_MODULE_3__/* .isBooleanTrue */ .bI)(params.showHelper)) {
      this._addHelper(childCameras);
    } else {
      this._removeHelper(childCameras);
    }
  }
  static _addHelper(childCameras) {
    for (const childCamera of childCameras) {
      const helper = new _core_helpers_CameraHelper__WEBPACK_IMPORTED_MODULE_4__/* .CameraHelper */ .R(childCamera);
      helper.update();
      childCamera.add(helper);
    }
  }
  static _removeHelper(childCameras) {
    for (const childCamera of childCameras) {
      const helpers = childCamera.children.filter((c) => c instanceof _core_helpers_CameraHelper__WEBPACK_IMPORTED_MODULE_4__/* .CameraHelper */ .R);
      for (const helper of helpers) {
        childCamera.remove(helper);
      }
    }
  }
  static createCamera(params, nodeGenerator) {
    const cubeRenderTarget = new three__WEBPACK_IMPORTED_MODULE_0__.WebGLCubeRenderTarget(params.resolution);
    (0,_core_geometry_Constant__WEBPACK_IMPORTED_MODULE_5__/* .registerObjectType */ .UX)({
      type: _core_geometry_Constant__WEBPACK_IMPORTED_MODULE_5__/* .ObjectType.CUBE_CAMERA */ .LP.CUBE_CAMERA,
      checkFunc: (o) => {
        if (o.renderTarget) {
          return _core_geometry_Constant__WEBPACK_IMPORTED_MODULE_5__/* .ObjectType.CUBE_CAMERA */ .LP.CUBE_CAMERA;
        }
      },
      ctor: CubeCameraExtended,
      humanName: _core_geometry_Constant__WEBPACK_IMPORTED_MODULE_5__/* .ObjectType.CUBE_CAMERA */ .LP.CUBE_CAMERA
    });
    const camera = new CubeCameraExtended(params.near, params.far, cubeRenderTarget);
    if (nodeGenerator) {
      _core_geometry_modules_three_ThreejsCoreObject__WEBPACK_IMPORTED_MODULE_6__/* .ThreejsCoreObject.addAttribute */ .W.addAttribute(camera, _core_camera_CoreCamera__WEBPACK_IMPORTED_MODULE_7__/* .CameraAttribute.NODE_ID */ .vd.NODE_ID, nodeGenerator.graphNodeId());
    }
    return camera;
  }
  static setCameraAttributes(camera, options) {
  }
};
let CubeCameraSopOperation = _CubeCameraSopOperation;
CubeCameraSopOperation.DEFAULT_PARAMS = {
  near: _core_camera_CoreCamera__WEBPACK_IMPORTED_MODULE_7__/* .CORE_CAMERA_DEFAULT.near */ .se.near,
  far: _core_camera_CoreCamera__WEBPACK_IMPORTED_MODULE_7__/* .CORE_CAMERA_DEFAULT.far */ .se.far,
  resolution: _core_camera_CoreCubeCamera__WEBPACK_IMPORTED_MODULE_8__/* .CUBE_CAMERA_DEFAULT.resolution */ .X6.resolution,
  position: new three__WEBPACK_IMPORTED_MODULE_0__.Vector3(0, 0, 0),
  rotation: new three__WEBPACK_IMPORTED_MODULE_0__.Vector3(0, 0, 0),
  showHelper: false,
  matrixAutoUpdate: true,
  name: _poly_NodeContext__WEBPACK_IMPORTED_MODULE_2__/* .CameraNodeType.CUBE */ .hY.CUBE
};
CubeCameraSopOperation.INPUT_CLONED_STATE = _engine_poly_InputCloneMode__WEBPACK_IMPORTED_MODULE_9__/* .InputCloneMode.NEVER */ .m.NEVER;
CubeCameraSopOperation.onRegister = _core_camera_CoreCubeCamera__WEBPACK_IMPORTED_MODULE_8__/* .registerCubeCamera */ .mv;


/***/ }),

/***/ 80922:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "M": function() { return /* binding */ DeleteByNameSopOperation; }
/* harmony export */ });
/* harmony import */ var _Base__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(82612);
/* harmony import */ var _engine_poly_InputCloneMode__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(56752);
/* harmony import */ var _core_geometry_Mask__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(58290);
/* harmony import */ var _poly_registers_nodes_types_Sop__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(58986);





class DeleteByNameSopOperation extends _Base__WEBPACK_IMPORTED_MODULE_0__/* .BaseSopOperation */ .U {
  static type() {
    return _poly_registers_nodes_types_Sop__WEBPACK_IMPORTED_MODULE_1__/* .SopType.DELETE_BY_NAME */ .aB.DELETE_BY_NAME;
  }
  cook(inputCoreGroups, params) {
    const coreGroup = inputCoreGroups[0];
    const coreObjects = coreGroup.allCoreObjects();
    const newObjects = [];
    const masks = params.group.split(" ");
    for (const coreObject of coreObjects) {
      let _toDelete = false;
      for (const mask of masks) {
        const _inGroup = (0,_core_geometry_Mask__WEBPACK_IMPORTED_MODULE_2__/* .isInGroup */ .lX)(mask, coreObject);
        if (_inGroup && !params.invert || !_inGroup && params.invert) {
          _toDelete = true;
        }
      }
      if (!_toDelete) {
        const object = coreObject.object();
        if (object) {
          newObjects.push(object);
        }
      }
    }
    return this.createCoreGroupFromObjects(newObjects);
  }
}
DeleteByNameSopOperation.DEFAULT_PARAMS = {
  group: "",
  invert: false
};
DeleteByNameSopOperation.INPUT_CLONED_STATE = _engine_poly_InputCloneMode__WEBPACK_IMPORTED_MODULE_3__/* .InputCloneMode.FROM_NODE */ .m.FROM_NODE;


/***/ }),

/***/ 4778:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "i": function() { return /* binding */ EmptyObjectSopOperation; }
/* harmony export */ });
/* harmony import */ var _Base__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(82612);
/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(21410);
/* harmony import */ var _core_geometry_Constant__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(91568);




class EmptyObjectSopOperation extends _Base__WEBPACK_IMPORTED_MODULE_0__/* .BaseSopOperation */ .U {
  static type() {
    return "emptyObject";
  }
  cook(inputCoreGroups, params) {
    const object = this._createObjectFromType(params);
    const objects = [];
    if (object) {
      const material = _core_geometry_Constant__WEBPACK_IMPORTED_MODULE_1__/* .DEFAULT_MATERIALS */ .ee[params.type];
      if (material) {
        object.material = material;
      }
      _Base__WEBPACK_IMPORTED_MODULE_0__/* .BaseSopOperation.applyObjectDefault */ .U.applyObjectDefault(object);
      objects.push(object);
    }
    return this.createCoreGroupFromObjects(objects);
  }
  _createObjectFromType(params) {
    switch (params.type) {
      case _core_geometry_Constant__WEBPACK_IMPORTED_MODULE_1__/* .ObjectType.GROUP */ .LP.GROUP: {
        return new three__WEBPACK_IMPORTED_MODULE_2__.Group();
      }
      case _core_geometry_Constant__WEBPACK_IMPORTED_MODULE_1__/* .ObjectType.LINE_SEGMENTS */ .LP.LINE_SEGMENTS: {
        return new three__WEBPACK_IMPORTED_MODULE_2__.LineSegments();
      }
      case _core_geometry_Constant__WEBPACK_IMPORTED_MODULE_1__/* .ObjectType.MESH */ .LP.MESH: {
        return new three__WEBPACK_IMPORTED_MODULE_2__.Mesh();
      }
      case _core_geometry_Constant__WEBPACK_IMPORTED_MODULE_1__/* .ObjectType.OBJECT3D */ .LP.OBJECT3D: {
        return new three__WEBPACK_IMPORTED_MODULE_2__.Object3D();
      }
      case _core_geometry_Constant__WEBPACK_IMPORTED_MODULE_1__/* .ObjectType.POINTS */ .LP.POINTS: {
        return new three__WEBPACK_IMPORTED_MODULE_2__.Points();
      }
    }
  }
}


/***/ }),

/***/ 26144:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {


// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  "O": function() { return /* binding */ FileVOXSopOperation; }
});

// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/core/loader/AssetsUtils.ts
var AssetsUtils = __webpack_require__(29248);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/node_modules/three/build/three.module.js
var three_module = __webpack_require__(21410);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/node_modules/three/examples/jsm/loaders/VOXLoader.js
var VOXLoader = __webpack_require__(6149);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/core/loader/geometry/_BaseLoaderHandler.ts + 1 modules
var _BaseLoaderHandler = __webpack_require__(53976);
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/core/loader/geometry/VOX.ts

var __async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};



class VOXLoaderHandler extends _BaseLoaderHandler/* BaseObject3DLoaderHandler */.Mr {
  _getLoader() {
    return __async(this, null, function* () {
      return this._loader = this._loader || new VOXLoader/* VOXLoader */.iL(this.loadingManager);
    });
  }
  _onLoadSuccess(chunks) {
    const meshes = [];
    for (const chunk of chunks) {
      const voxMesh = new VOXLoader/* VOXMesh */.Ll(chunk);
      const mesh = new three_module.Mesh(voxMesh.geometry, voxMesh.material);
      meshes.push(mesh);
    }
    return meshes;
  }
}

// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/core/UrlHelper.ts
var UrlHelper = __webpack_require__(51529);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/poly/registers/nodes/types/Sop.ts
var Sop = __webpack_require__(58986);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/operations/sop/utils/File/_BaseFileOperation.ts
var _BaseFileOperation = __webpack_require__(22012);
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/operations/sop/FileVOX.ts






class FileVOXSopOperation extends _BaseFileOperation/* BaseFileSopOperation */.Z {
  static type() {
    return Sop/* SopTypeFile.FILE_VOX */.GF.FILE_VOX;
  }
  _createGeoLoaderHandler(params) {
    return new VOXLoaderHandler(params.url, this._node);
  }
}
FileVOXSopOperation.DEFAULT_PARAMS = {
  url: (0,UrlHelper/* sanitizeUrl */.N)(`${AssetsUtils/* ASSETS_ROOT */.V}/models/vox/monu10.vox`),
  matrixAutoUpdate: false
};


/***/ }),

/***/ 57426:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "c": function() { return /* binding */ HemisphereLightSopOperation; }
/* harmony export */ });
/* harmony import */ var _Base__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(82612);
/* harmony import */ var _engine_poly_InputCloneMode__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(56752);
/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(21410);
/* harmony import */ var _core_lights_HemisphereLight__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(98821);
/* harmony import */ var _core_geometry_Constant__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(91568);






class HemisphereLightSopOperation extends _Base__WEBPACK_IMPORTED_MODULE_0__/* .BaseSopOperation */ .U {
  static type() {
    return "hemisphereLight";
  }
  cook(inputCoreGroups, params) {
    const light = this.createLight();
    light.name = params.name;
    this.updateLightParams(light, params);
    return this.createCoreGroupFromObjects([light]);
  }
  createLight() {
    var _a;
    (0,_core_geometry_Constant__WEBPACK_IMPORTED_MODULE_1__/* .registerObjectType */ .UX)({
      type: _core_geometry_Constant__WEBPACK_IMPORTED_MODULE_1__/* .ObjectType.HEMISPHERE_LIGHT */ .LP.HEMISPHERE_LIGHT,
      checkFunc: (o) => {
        if (o.isHemisphereLight) {
          return _core_geometry_Constant__WEBPACK_IMPORTED_MODULE_1__/* .ObjectType.HEMISPHERE_LIGHT */ .LP.HEMISPHERE_LIGHT;
        }
      },
      ctor: three__WEBPACK_IMPORTED_MODULE_2__.HemisphereLight,
      humanName: "HemisphereLight"
    });
    const light = new three__WEBPACK_IMPORTED_MODULE_2__.HemisphereLight();
    light.name = `HemisphereLight_${((_a = this._node) == null ? void 0 : _a.name()) || ""}`;
    light.matrixAutoUpdate = false;
    light.updateMatrix();
    light.color.copy(_core_lights_HemisphereLight__WEBPACK_IMPORTED_MODULE_3__/* .DEFAULT_HEMISPHERE_LIGHT_PARAMS.skyColor */ .$.skyColor);
    light.groundColor.copy(_core_lights_HemisphereLight__WEBPACK_IMPORTED_MODULE_3__/* .DEFAULT_HEMISPHERE_LIGHT_PARAMS.groundColor */ .$.groundColor);
    return light;
  }
  updateLightParams(light, params) {
    light.color.copy(params.skyColor);
    light.groundColor.copy(params.groundColor);
    light.intensity = params.intensity;
    light.position.copy(params.position);
    light.updateMatrix();
  }
}
HemisphereLightSopOperation.DEFAULT_PARAMS = _core_lights_HemisphereLight__WEBPACK_IMPORTED_MODULE_3__/* .DEFAULT_HEMISPHERE_LIGHT_PARAMS */ .$;
HemisphereLightSopOperation.INPUT_CLONED_STATE = _engine_poly_InputCloneMode__WEBPACK_IMPORTED_MODULE_4__/* .InputCloneMode.NEVER */ .m.NEVER;


/***/ }),

/***/ 42821:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "b": function() { return /* binding */ HexagonsSopOperation; }
/* harmony export */ });
/* harmony import */ var _core_geometry_operation_Hexagon__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(4792);
/* harmony import */ var _Base__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(82612);
/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(21410);
/* harmony import */ var _core_Transform__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(87883);
/* harmony import */ var _poly_InputCloneMode__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(56752);
/* harmony import */ var _core_BooleanValue__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(19037);
/* harmony import */ var _core_geometry_Constant__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(91568);








const tmpBox = new three__WEBPACK_IMPORTED_MODULE_0__.Box3();
const tmpBoxPreRotation = new three__WEBPACK_IMPORTED_MODULE_0__.Box3();
const tmpSize = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();
const tmpCenter = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();
const DEFAULT_UP = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3(0, 0, 1);
const q = new three__WEBPACK_IMPORTED_MODULE_0__.Quaternion();
class HexagonsSopOperation extends _Base__WEBPACK_IMPORTED_MODULE_1__/* .BaseSopOperation */ .U {
  static type() {
    return "hexagons";
  }
  cook(inputCoreGroups, params) {
    const coreGroup = inputCoreGroups[0];
    if (coreGroup) {
      return this._cookWithInput(coreGroup, params);
    } else {
      return this._cookWithoutInput(params);
    }
  }
  _cookWithoutInput(params) {
    if (params.hexagonRadius > 0) {
      const geometry = this._createHexagons(params.size, params);
      (0,_core_Transform__WEBPACK_IMPORTED_MODULE_2__/* .rotateGeometry */ .bP)(geometry, DEFAULT_UP, params.direction);
      return this.createCoreGroupFromObjects([this._createHexagonsObjects(geometry, params)]);
    } else {
      return this.createCoreGroupFromObjects([]);
    }
  }
  _cookWithInput(coreGroup, params) {
    coreGroup.boundingBox(tmpBoxPreRotation);
    tmpBoxPreRotation.getCenter(tmpCenter);
    coreGroup.boundingBox(tmpBox);
    tmpBox.getSize(tmpSize);
    tmpBox.getCenter(tmpCenter);
    const boxGeometry = new three__WEBPACK_IMPORTED_MODULE_0__.BoxGeometry(tmpSize.x, tmpSize.y, tmpSize.z, 1, 1, 1);
    function _applyInputQuaternion(_q) {
      boxGeometry.applyQuaternion(_q);
      boxGeometry.computeBoundingBox();
    }
    function _setInputRotation() {
      q.setFromUnitVectors(DEFAULT_UP, params.direction);
      _applyInputQuaternion(q);
    }
    _setInputRotation();
    const bboxPostRotation = boxGeometry.boundingBox;
    bboxPostRotation.getSize(tmpSize);
    const size2d = new three__WEBPACK_IMPORTED_MODULE_0__.Vector2(tmpSize.x, tmpSize.y);
    const geometry = this._createHexagons(size2d, params);
    (0,_core_Transform__WEBPACK_IMPORTED_MODULE_2__/* .rotateGeometry */ .bP)(geometry, DEFAULT_UP, params.direction);
    geometry.translate(tmpCenter.x, tmpCenter.y, tmpCenter.z);
    const object = this._createHexagonsObjects(geometry, params);
    return this.createCoreGroupFromObjects([object]);
  }
  _createHexagonsObjects(geometry, params) {
    if ((0,_core_BooleanValue__WEBPACK_IMPORTED_MODULE_3__/* .isBooleanTrue */ .bI)(params.pointsOnly)) {
      return this.createObject(geometry, _core_geometry_Constant__WEBPACK_IMPORTED_MODULE_4__/* .ObjectType.POINTS */ .LP.POINTS);
    } else {
      return this.createObject(geometry, _core_geometry_Constant__WEBPACK_IMPORTED_MODULE_4__/* .ObjectType.MESH */ .LP.MESH);
    }
  }
  _createHexagons(size, params) {
    const operation = new _core_geometry_operation_Hexagon__WEBPACK_IMPORTED_MODULE_5__/* .CoreGeometryOperationHexagon */ .L(size, params.hexagonRadius, params.pointsOnly);
    const geometry = operation.process();
    return geometry;
  }
}
HexagonsSopOperation.DEFAULT_PARAMS = {
  size: new three__WEBPACK_IMPORTED_MODULE_0__.Vector2(1, 1),
  hexagonRadius: 0.1,
  direction: new three__WEBPACK_IMPORTED_MODULE_0__.Vector3(0, 1, 0),
  pointsOnly: false
};
HexagonsSopOperation.INPUT_CLONED_STATE = _poly_InputCloneMode__WEBPACK_IMPORTED_MODULE_6__/* .InputCloneMode.NEVER */ .m.NEVER;


/***/ }),

/***/ 25972:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Bw": function() { return /* binding */ ADD_CHILD_MODES; },
/* harmony export */   "JW": function() { return /* binding */ HierarchySopOperation; },
/* harmony export */   "P1": function() { return /* binding */ HierarchyMode; },
/* harmony export */   "kO": function() { return /* binding */ HIERARCHY_MODES; }
/* harmony export */ });
/* unused harmony export AddChildMode */
/* harmony import */ var _Base__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(82612);
/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(21410);
/* harmony import */ var _engine_poly_InputCloneMode__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(56752);
/* harmony import */ var _engine_poly_Assert__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(68239);
/* harmony import */ var _core_geometry_CorePath__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(60074);






var HierarchyMode = /* @__PURE__ */ ((HierarchyMode2) => {
  HierarchyMode2["ADD_PARENT"] = "add parent";
  HierarchyMode2["REMOVE_PARENT"] = "remove parent";
  HierarchyMode2["ADD_CHILD"] = "add child";
  return HierarchyMode2;
})(HierarchyMode || {});
const HIERARCHY_MODES = [
  "add parent" /* ADD_PARENT */,
  "remove parent" /* REMOVE_PARENT */,
  "add child" /* ADD_CHILD */
];
var AddChildMode = /* @__PURE__ */ ((AddChildMode2) => {
  AddChildMode2["ONE_CHILD_PER_PARENT"] = "one child per parent";
  AddChildMode2["ALL_CHILDREN_UNDER_FIRST_PARENT"] = "all children under first parent";
  AddChildMode2["ALL_CHILDREN_UNDER_ALL_PARENTS"] = "all children under all parents";
  return AddChildMode2;
})(AddChildMode || {});
const ADD_CHILD_MODES = [
  "one child per parent" /* ONE_CHILD_PER_PARENT */,
  "all children under first parent" /* ALL_CHILDREN_UNDER_FIRST_PARENT */,
  "all children under all parents" /* ALL_CHILDREN_UNDER_ALL_PARENTS */
];
class HierarchySopOperation extends _Base__WEBPACK_IMPORTED_MODULE_0__/* .BaseSopOperation */ .U {
  static type() {
    return "hierarchy";
  }
  cook(inputCoreGroups, params) {
    const coreGroup = inputCoreGroups[0];
    const mode = HIERARCHY_MODES[params.mode];
    switch (mode) {
      case "add parent" /* ADD_PARENT */: {
        const objects = addParentToCoreGroup(coreGroup, inputCoreGroups[1], params);
        return this.createCoreGroupFromObjects(objects);
      }
      case "remove parent" /* REMOVE_PARENT */: {
        const objects = _removeParentFromCoreGroup(coreGroup, params);
        return this.createCoreGroupFromObjects(objects);
      }
      case "add child" /* ADD_CHILD */: {
        const objects = _addChildrenToCoreGroup(coreGroup, inputCoreGroups[1], params, this, this.states);
        return this.createCoreGroupFromObjects(objects);
      }
    }
    _engine_poly_Assert__WEBPACK_IMPORTED_MODULE_1__/* .TypeAssert.unreachable */ .f.unreachable(mode);
  }
}
HierarchySopOperation.DEFAULT_PARAMS = {
  mode: HIERARCHY_MODES.indexOf("add parent" /* ADD_PARENT */),
  levels: 1,
  objectMask: "",
  addChildMode: ADD_CHILD_MODES.indexOf("all children under first parent" /* ALL_CHILDREN_UNDER_FIRST_PARENT */)
};
HierarchySopOperation.INPUT_CLONED_STATE = _engine_poly_InputCloneMode__WEBPACK_IMPORTED_MODULE_2__/* .InputCloneMode.FROM_NODE */ .m.FROM_NODE;
function addParentToCoreGroup(coreGroup, parentCoreGroup, params) {
  function _addParentToObject(objects) {
    function _createNewParent() {
      const newParent2 = new three__WEBPACK_IMPORTED_MODULE_3__.Group();
      newParent2.matrixAutoUpdate = false;
      return newParent2;
    }
    let newParent;
    if (parentCoreGroup) {
      newParent = parentCoreGroup == null ? void 0 : parentCoreGroup.threejsObjects()[0];
    }
    newParent = newParent || _createNewParent();
    for (let object of objects) {
      newParent.add(object);
    }
    if (params.levels > 1) {
      let _addNewParent2 = function(object, params2) {
        const newParent2 = _createNewParent();
        newParent2.add(object);
        return newParent2;
      };
      var _addNewParent = _addNewParent2;
      for (let i = 1; i < params.levels; i++) {
        newParent = _addNewParent2(newParent, params);
      }
    }
    return newParent;
  }
  if (params.levels == 0) {
    return coreGroup.threejsObjects();
  } else {
    const newObject = _addParentToObject(coreGroup.threejsObjects());
    return [newObject];
  }
}
function _removeParentFromCoreGroup(coreGroup, params) {
  function _removeParentFromObject(object, params2) {
    function _getChildrenFromObjects(objects) {
      let object2;
      const children = [];
      while (object2 = objects.pop()) {
        if (object2.children) {
          for (let child of object2.children) {
            children.push(child);
          }
        }
      }
      return children;
    }
    let current_children = object.children;
    for (let i = 0; i < params2.levels - 1; i++) {
      current_children = _getChildrenFromObjects(current_children);
    }
    return current_children;
  }
  if (params.levels == 0) {
    return coreGroup.threejsObjects();
  } else {
    const newObjects = [];
    const threejsObjects = coreGroup.threejsObjects();
    for (let object of threejsObjects) {
      const newChildren = _removeParentFromObject(object, params);
      for (let newChild of newChildren) {
        newObjects.push(newChild);
      }
    }
    return newObjects;
  }
}
function _addChildrenToCoreGroup(coreGroup, childCoreGroup, params, operation, states) {
  const objects = coreGroup.threejsObjects();
  if (!childCoreGroup) {
    states == null ? void 0 : states.error.set("input 1 is invalid");
    return [];
  }
  function _findObjectsByMaskFromObjects(mask, objects2) {
    const list = [];
    for (let object of objects2) {
      _core_geometry_CorePath__WEBPACK_IMPORTED_MODULE_4__/* .CorePath.objectsByMaskInObject */ .Oj.objectsByMaskInObject(mask, object, list);
    }
    return list;
  }
  function _getParentObjects() {
    const mask = params.objectMask.trim();
    const maskValid = mask != "";
    const parentObjects2 = maskValid ? _findObjectsByMaskFromObjects(mask, objects) : objects;
    return parentObjects2;
  }
  const parentObjects = _getParentObjects();
  const childObjects = childCoreGroup.threejsObjects();
  function _addOneChildPerParent() {
    for (let i = 0; i < parentObjects.length; i++) {
      const parentObject = parentObjects[i];
      const childObject = childObjects[i] || childObjects[0];
      if (!childObject) {
        states == null ? void 0 : states.error.set("no objects found in input 1");
        return [];
      }
      parentObject.add(childObject);
    }
    return objects;
  }
  function _addAllChildrenUnderFirstParent() {
    const parentObject = parentObjects[0];
    for (let childObject of childObjects) {
      parentObject.add(childObject);
    }
    return objects;
  }
  function _addAllChildrenUnderAllParents() {
    for (let parentObject of parentObjects) {
      for (let childObject of childObjects) {
        parentObject.add(childObject.clone());
      }
    }
    return objects;
  }
  const addChildMode = ADD_CHILD_MODES[params.addChildMode];
  switch (addChildMode) {
    case "one child per parent" /* ONE_CHILD_PER_PARENT */: {
      return _addOneChildPerParent();
    }
    case "all children under first parent" /* ALL_CHILDREN_UNDER_FIRST_PARENT */: {
      return _addAllChildrenUnderFirstParent();
    }
    case "all children under all parents" /* ALL_CHILDREN_UNDER_ALL_PARENTS */: {
      return _addAllChildrenUnderAllParents();
    }
  }
  _engine_poly_Assert__WEBPACK_IMPORTED_MODULE_1__/* .TypeAssert.unreachable */ .f.unreachable(addChildMode);
}


/***/ }),

/***/ 40930:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {


// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  "g": function() { return /* binding */ IcosahedronSopOperation; }
});

// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/operations/sop/_Base.ts
var _Base = __webpack_require__(82612);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/node_modules/three/build/three.module.js
var three_module = __webpack_require__(21410);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/core/geometry/operation/Polyhedron.ts
var Polyhedron = __webpack_require__(39713);
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/core/geometry/operation/Icosahedron.ts


class IcosahedronBufferGeometry extends Polyhedron/* PolyhedronBufferGeometry */.u {
  //{radius: number, detail:number}
  constructor(radius, detail, points_only) {
    const t = (1 + Math.sqrt(5)) / 2;
    const vertices = [
      -1,
      t,
      0,
      1,
      t,
      0,
      -1,
      -t,
      0,
      1,
      -t,
      0,
      0,
      -1,
      t,
      0,
      1,
      t,
      0,
      -1,
      -t,
      0,
      1,
      -t,
      t,
      0,
      -1,
      t,
      0,
      1,
      -t,
      0,
      -1,
      -t,
      0,
      1
    ];
    const indices = [
      0,
      11,
      5,
      0,
      5,
      1,
      0,
      1,
      7,
      0,
      7,
      10,
      0,
      10,
      11,
      1,
      5,
      9,
      5,
      11,
      4,
      11,
      10,
      2,
      10,
      7,
      6,
      7,
      1,
      8,
      3,
      9,
      4,
      3,
      4,
      2,
      3,
      2,
      6,
      3,
      6,
      8,
      3,
      8,
      9,
      4,
      9,
      5,
      2,
      4,
      11,
      6,
      2,
      10,
      8,
      6,
      7,
      9,
      8,
      1
    ];
    super(vertices, indices, radius, detail, points_only);
    this.type = "IcosahedronBufferGeometry";
    this.parameters = {
      radius,
      detail
    };
  }
}

// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/core/geometry/Constant.ts
var Constant = __webpack_require__(91568);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/core/Type.ts
var Type = __webpack_require__(19037);
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/operations/sop/Icosahedron.ts






class IcosahedronSopOperation extends _Base/* BaseSopOperation */.U {
  static type() {
    return "icosahedron";
  }
  cook(input_contents, params) {
    const object = this._createIcosahedronObject(params);
    if (this._node) {
      object.name = this._node.name();
    }
    return this.createCoreGroupFromObjects([object]);
  }
  _createIcosahedronObject(params) {
    const pointsOnly = (0,Type/* isBooleanTrue */.bI)(params.pointsOnly);
    const geometry = new IcosahedronBufferGeometry(params.radius, params.detail, pointsOnly);
    geometry.translate(params.center.x, params.center.y, params.center.z);
    if (pointsOnly) {
      const object = this.createObject(geometry, Constant/* ObjectType.POINTS */.LP.POINTS);
      return object;
    } else {
      geometry.computeVertexNormals();
      return this.createObject(geometry, Constant/* ObjectType.MESH */.LP.MESH);
    }
  }
}
IcosahedronSopOperation.DEFAULT_PARAMS = {
  radius: 1,
  detail: 0,
  pointsOnly: false,
  center: new three_module.Vector3(0, 0, 0)
};


/***/ }),

/***/ 51922:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "m": function() { return /* binding */ InstanceSopOperation; }
/* harmony export */ });
/* harmony import */ var _Base__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(82612);
/* harmony import */ var _core_Walker__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(742);
/* harmony import */ var _engine_nodes_gl_code_globals_Geometry__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(21806);
/* harmony import */ var _core_geometry_Constant__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(91568);
/* harmony import */ var _core_geometry_Material__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(62026);
/* harmony import */ var _engine_poly_NodeContext__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(52070);
/* harmony import */ var _core_geometry_Instancer__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(23786);
/* harmony import */ var _engine_poly_InputCloneMode__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(56752);
/* harmony import */ var _core_BooleanValue__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(19037);
/* harmony import */ var _poly_registers_nodes_types_Sop__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(58986);

var __async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};










class InstanceSopOperation extends _Base__WEBPACK_IMPORTED_MODULE_0__/* .BaseSopOperation */ .U {
  static type() {
    return _poly_registers_nodes_types_Sop__WEBPACK_IMPORTED_MODULE_1__/* .SopType.INSTANCE */ .aB.INSTANCE;
  }
  cook(inputCoreGroups, params) {
    return __async(this, null, function* () {
      const coreGroupToInstance = inputCoreGroups[0];
      this._geometry = void 0;
      const objectToInstance = coreGroupToInstance.threejsObjectsWithGeo()[0];
      if (objectToInstance) {
        const geometryToInstance = objectToInstance.geometry;
        if (geometryToInstance) {
          const coreGroup = inputCoreGroups[1];
          this._createInstance(geometryToInstance, coreGroup, params);
        }
      }
      if (this._geometry) {
        const type = (0,_core_geometry_Constant__WEBPACK_IMPORTED_MODULE_2__/* .objectTypeFromObject */ .c9)(objectToInstance);
        if (type) {
          const object = this.createObject(this._geometry, type);
          if (object) {
            if ((0,_core_BooleanValue__WEBPACK_IMPORTED_MODULE_3__/* .isBooleanTrue */ .bI)(params.applyMaterial)) {
              const material = yield this._getMaterial(params);
              if (material) {
                yield this._applyMaterial(object, material);
              }
            }
            return this.createCoreGroupFromObjects([object]);
          }
        }
      }
      return this.createCoreGroupFromObjects([]);
    });
  }
  _getMaterial(params) {
    return __async(this, null, function* () {
      var _a;
      if ((0,_core_BooleanValue__WEBPACK_IMPORTED_MODULE_3__/* .isBooleanTrue */ .bI)(params.applyMaterial)) {
        const materialNode = params.material.nodeWithContext(_engine_poly_NodeContext__WEBPACK_IMPORTED_MODULE_4__/* .NodeContext.MAT */ .sy.MAT, (_a = this.states) == null ? void 0 : _a.error);
        if (materialNode) {
          this._globalsHandler = this._globalsHandler || new _engine_nodes_gl_code_globals_Geometry__WEBPACK_IMPORTED_MODULE_5__/* .GlobalsGeometryHandler */ .f();
          const matBuilderNode = materialNode;
          const matNodeAssemblerController = matBuilderNode.assemblerController();
          if (matNodeAssemblerController) {
            matNodeAssemblerController.setAssemblerGlobalsHandler(this._globalsHandler);
          }
          const container = yield materialNode.compute();
          const material = container.material();
          return material;
        }
      }
    });
  }
  _applyMaterial(object, material) {
    return __async(this, null, function* () {
      object.material = material;
      (0,_core_geometry_Material__WEBPACK_IMPORTED_MODULE_6__/* .applyCustomMaterials */ .D4)(object, material);
    });
  }
  _createInstance(geometryToInstance, templateCoreGroup, params) {
    this._geometry = _core_geometry_Instancer__WEBPACK_IMPORTED_MODULE_7__/* .CoreInstancer.createInstanceBufferGeometry */ .t.createInstanceBufferGeometry(
      geometryToInstance,
      templateCoreGroup,
      params.attributesToCopy
    );
  }
}
InstanceSopOperation.DEFAULT_PARAMS = {
  attributesToCopy: "instance*",
  applyMaterial: true,
  material: new _core_Walker__WEBPACK_IMPORTED_MODULE_8__/* .TypedNodePathParamValue */ .jI("")
};
InstanceSopOperation.INPUT_CLONED_STATE = [_engine_poly_InputCloneMode__WEBPACK_IMPORTED_MODULE_9__/* .InputCloneMode.NEVER */ .m.NEVER, _engine_poly_InputCloneMode__WEBPACK_IMPORTED_MODULE_9__/* .InputCloneMode.NEVER */ .m.NEVER];


/***/ }),

/***/ 28665:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "U": function() { return /* binding */ JitterSopOperation; }
/* harmony export */ });
/* harmony import */ var _Base__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(82612);
/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(21410);
/* harmony import */ var _engine_poly_InputCloneMode__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(56752);
/* harmony import */ var _core_geometry_operation_Jitter__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(48956);





class JitterSopOperation extends _Base__WEBPACK_IMPORTED_MODULE_0__/* .BaseSopOperation */ .U {
  static type() {
    return "jitter";
  }
  cook(inputCoreGroups, params) {
    const coreGroup = inputCoreGroups[0];
    (0,_core_geometry_operation_Jitter__WEBPACK_IMPORTED_MODULE_1__/* .jitterPositions */ .x)(coreGroup, params);
    return coreGroup;
  }
}
JitterSopOperation.DEFAULT_PARAMS = {
  amount: 1,
  mult: new three__WEBPACK_IMPORTED_MODULE_2__.Vector3(1, 1, 1),
  seed: 1
};
JitterSopOperation.INPUT_CLONED_STATE = _engine_poly_InputCloneMode__WEBPACK_IMPORTED_MODULE_3__/* .InputCloneMode.FROM_NODE */ .m.FROM_NODE;


/***/ }),

/***/ 32409:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "v": function() { return /* binding */ LightProbeSopOperation; }
/* harmony export */ });
/* harmony import */ var _Base__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(82612);
/* harmony import */ var _engine_poly_InputCloneMode__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(56752);
/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(21410);
/* harmony import */ var _core_lights_LightProbe__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(63771);
/* harmony import */ var _poly_NodeContext__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(52070);
/* harmony import */ var three_examples_jsm_lights_LightProbeGenerator__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(97758);
/* harmony import */ var _core_geometry_Constant__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(91568);

var __async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};







class LightProbeSopOperation extends _Base__WEBPACK_IMPORTED_MODULE_0__/* .BaseSopOperation */ .U {
  static type() {
    return "lightProbe";
  }
  cook(inputCoreGroups, params) {
    return __async(this, null, function* () {
      const light = this.createLight();
      light.name = params.name;
      yield this.updateLightParams(light, params);
      return this.createCoreGroupFromObjects([light]);
    });
  }
  createLight() {
    var _a;
    (0,_core_geometry_Constant__WEBPACK_IMPORTED_MODULE_1__/* .registerObjectType */ .UX)({
      type: _core_geometry_Constant__WEBPACK_IMPORTED_MODULE_1__/* .ObjectType.LIGHT_PROBE */ .LP.LIGHT_PROBE,
      checkFunc: (o) => {
        if (o.isLightProbe) {
          return _core_geometry_Constant__WEBPACK_IMPORTED_MODULE_1__/* .ObjectType.LIGHT_PROBE */ .LP.LIGHT_PROBE;
        }
      },
      ctor: three__WEBPACK_IMPORTED_MODULE_2__.LightProbe,
      humanName: "LightProbe"
    });
    const light = new three__WEBPACK_IMPORTED_MODULE_2__.LightProbe();
    light.name = `LightProbe_${((_a = this._node) == null ? void 0 : _a.name()) || ""}`;
    light.matrixAutoUpdate = false;
    light.updateMatrix();
    return light;
  }
  updateLightParams(light, params) {
    return __async(this, null, function* () {
      var _a, _b, _c, _d;
      const copNode = params.cubeMap.nodeWithContext(_poly_NodeContext__WEBPACK_IMPORTED_MODULE_3__/* .NodeContext.COP */ .sy.COP, (_a = this.states) == null ? void 0 : _a.error);
      if (copNode) {
        const container = yield copNode.compute();
        if (container) {
          const texture = container.texture();
          if (texture instanceof three__WEBPACK_IMPORTED_MODULE_2__.CubeTexture) {
            const lightProbe = three_examples_jsm_lights_LightProbeGenerator__WEBPACK_IMPORTED_MODULE_4__/* .LightProbeGenerator.fromCubeTexture */ .F.fromCubeTexture(texture);
            light.copy(lightProbe);
            light.sh.scale(params.intensity);
          } else {
            (_b = this.states) == null ? void 0 : _b.error.set(`texture node is not a cubeMap`);
          }
        } else {
          (_c = this.states) == null ? void 0 : _c.error.set(`texture node invalid`);
        }
      } else {
        (_d = this.states) == null ? void 0 : _d.error.set(`no texture node found`);
      }
    });
  }
}
LightProbeSopOperation.DEFAULT_PARAMS = _core_lights_LightProbe__WEBPACK_IMPORTED_MODULE_5__/* .DEFAULT_LIGHT_PROBE_PARAMS */ .O;
LightProbeSopOperation.INPUT_CLONED_STATE = _engine_poly_InputCloneMode__WEBPACK_IMPORTED_MODULE_6__/* .InputCloneMode.NEVER */ .m.NEVER;


/***/ }),

/***/ 53382:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "i": function() { return /* binding */ MaterialSopOperation; }
/* harmony export */ });
/* harmony import */ var _Base__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(82612);
/* harmony import */ var _core_Walker__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(742);
/* harmony import */ var _engine_poly_NodeContext__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(52070);
/* harmony import */ var _core_geometry_Material__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(62026);
/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(21410);
/* harmony import */ var _engine_nodes_gl_code_globals_Geometry__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(21806);
/* harmony import */ var _engine_poly_InputCloneMode__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(56752);
/* harmony import */ var _core_BooleanValue__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(19037);
/* harmony import */ var _core_geometry_Mask__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(58290);

var __async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};









let _nextId = 0;
class MaterialSopOperation extends _Base__WEBPACK_IMPORTED_MODULE_0__/* .BaseSopOperation */ .U {
  constructor() {
    super(...arguments);
    this._materialSopOperationId = _nextId++;
    this._globalsHandler = new _engine_nodes_gl_code_globals_Geometry__WEBPACK_IMPORTED_MODULE_1__/* .GlobalsGeometryHandler */ .f();
    this._onMaterialUpdateBound = this._onMaterialUpdate.bind(this);
    this._oldMatByOldNewId = /* @__PURE__ */ new Map();
    this._materialByUuid = /* @__PURE__ */ new Map();
  }
  static type() {
    return "material";
  }
  cook(inputCoreGroups, params) {
    return __async(this, null, function* () {
      const coreGroup = inputCoreGroups[0];
      this._oldMatByOldNewId.clear();
      yield this._applyMaterials(coreGroup, params);
      this._swapTextures(coreGroup, params);
      return coreGroup;
    });
  }
  _getMaterial(params) {
    return __async(this, null, function* () {
      var _a, _b, _c, _d;
      const materialNode = params.material.nodeWithContext(_engine_poly_NodeContext__WEBPACK_IMPORTED_MODULE_2__/* .NodeContext.MAT */ .sy.MAT, (_a = this.states) == null ? void 0 : _a.error);
      if (materialNode) {
        this._watchMaterialNode(materialNode);
        const material = yield materialNode.material();
        const baseBuilderMatNode = materialNode;
        if (baseBuilderMatNode.assemblerController) {
          (_b = baseBuilderMatNode.assemblerController()) == null ? void 0 : _b.setAssemblerGlobalsHandler(this._globalsHandler);
        }
        if (!material) {
          (_c = this.states) == null ? void 0 : _c.error.set(`material invalid. (error: '${materialNode.states.error.message()}')`);
        }
        return material;
      } else {
        (_d = this.states) == null ? void 0 : _d.error.set(`no material node found`);
      }
    });
  }
  _watchMaterialNode(materialNode) {
    if (this._watchedMaterialNode == materialNode) {
      return;
    }
    const hookName = this._watchHookName();
    materialNode.addPostDirtyHook(hookName, this._onMaterialUpdateBound);
    materialNode.cookController.registerOnCookEnd(hookName, this._onMaterialUpdateBound);
    if (this._watchedMaterialNode) {
      this._watchedMaterialNode.removePostDirtyHook(hookName);
      this._watchedMaterialNode.cookController.deregisterOnCookEnd(hookName);
    }
    this._watchedMaterialNode = materialNode;
  }
  _onMaterialUpdate() {
    return __async(this, null, function* () {
      if (!this._watchedMaterialNode) {
        return;
      }
      const container = yield this._watchedMaterialNode.compute();
      const material = container.material();
      if (material != this._watchedMaterialNodeMaterial) {
        this._watchedMaterialNodeMaterial = material;
        if (this._node) {
          this._node.p.material.setDirty();
        }
      }
    });
  }
  _watchHookName() {
    return `MaterialSopOperationId-${this._materialSopOperationId}`;
  }
  _applyMaterials(coreGroup, params) {
    return __async(this, null, function* () {
      if (!(0,_core_BooleanValue__WEBPACK_IMPORTED_MODULE_3__/* .isBooleanTrue */ .bI)(params.assignMat)) {
        return;
      }
      const material = yield this._getMaterial(params);
      if (!material) {
        return;
      }
      const selectedObjects = _core_geometry_Mask__WEBPACK_IMPORTED_MODULE_4__/* .CoreMask.filterThreejsObjects */ .x0.filterThreejsObjects(coreGroup, params);
      for (let selectedObject of selectedObjects) {
        this._applyMaterial(selectedObject, material, params);
      }
      return coreGroup;
    });
  }
  _swapTextures(coreGroup, params) {
    if (!(0,_core_BooleanValue__WEBPACK_IMPORTED_MODULE_3__/* .isBooleanTrue */ .bI)(params.swapCurrentTex)) {
      return;
    }
    this._materialByUuid.clear();
    const objects = _core_geometry_Mask__WEBPACK_IMPORTED_MODULE_4__/* .CoreMask.filterObjects */ .x0.filterObjects(coreGroup, params, coreGroup.allCoreObjects());
    for (let object of objects) {
      const mat = object.material;
      this._materialByUuid.set(mat.uuid, mat);
    }
    this._materialByUuid.forEach((mat, mat_uuid) => {
      this._swapTexture(mat, params);
    });
  }
  _applyMaterial(object, srcMaterial, params) {
    const usedMaterial = (0,_core_BooleanValue__WEBPACK_IMPORTED_MODULE_3__/* .isBooleanTrue */ .bI)(params.cloneMat) ? (0,_core_geometry_Material__WEBPACK_IMPORTED_MODULE_5__/* .cloneMaterial */ .eJ)(this.scene(), srcMaterial, {
      shareCustomUniforms: params.shareCustomUniforms,
      addCustomMaterials: true
    }) : srcMaterial;
    if (srcMaterial instanceof three__WEBPACK_IMPORTED_MODULE_6__.ShaderMaterial && usedMaterial instanceof three__WEBPACK_IMPORTED_MODULE_6__.ShaderMaterial) {
      for (let uniform_name in srcMaterial.uniforms) {
        usedMaterial.uniforms[uniform_name] = srcMaterial.uniforms[uniform_name];
      }
    }
    if (object.isGroup) {
      return;
    }
    const object_with_material = object;
    this._oldMatByOldNewId.set(usedMaterial.uuid, object_with_material.material);
    object_with_material.material = usedMaterial;
    (0,_core_geometry_Material__WEBPACK_IMPORTED_MODULE_5__/* .applyRenderHook */ .pC)(object, usedMaterial);
    (0,_core_geometry_Material__WEBPACK_IMPORTED_MODULE_5__/* .applyCustomMaterials */ .D4)(object, usedMaterial);
  }
  _swapTexture(target_mat, params) {
    if (params.texSrc0 == "" || params.texDest0 == "") {
      return;
    }
    let src_mat = this._oldMatByOldNewId.get(target_mat.uuid);
    src_mat = src_mat || target_mat;
    const src_tex = src_mat[params.texSrc0];
    if (src_tex) {
      target_mat[params.texDest0] = src_tex;
      const uniforms = target_mat.uniforms;
      if (uniforms) {
        const uniforms_map = uniforms[params.texDest0];
        if (uniforms_map) {
          uniforms[params.texDest0] = { value: src_tex };
        }
      }
    }
  }
}
MaterialSopOperation.DEFAULT_PARAMS = {
  group: "",
  assignMat: true,
  material: new _core_Walker__WEBPACK_IMPORTED_MODULE_7__/* .TypedNodePathParamValue */ .jI(""),
  cloneMat: false,
  shareCustomUniforms: true,
  swapCurrentTex: false,
  texSrc0: "emissiveMap",
  texDest0: "map"
};
MaterialSopOperation.INPUT_CLONED_STATE = _engine_poly_InputCloneMode__WEBPACK_IMPORTED_MODULE_8__/* .InputCloneMode.FROM_NODE */ .m.FROM_NODE;


/***/ }),

/***/ 38229:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "L": function() { return /* binding */ ObjectPropertiesSopOperation; }
/* harmony export */ });
/* harmony import */ var _Base__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(82612);
/* harmony import */ var _engine_poly_InputCloneMode__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(56752);
/* harmony import */ var _core_BooleanValue__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(19037);
/* harmony import */ var _core_geometry_Mask__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(58290);





class ObjectPropertiesSopOperation extends _Base__WEBPACK_IMPORTED_MODULE_0__/* .BaseSopOperation */ .U {
  static type() {
    return "objectProperties";
  }
  cook(inputCoreGroups, params) {
    const coreGroup = inputCoreGroups[0];
    const selectedObjects = _core_geometry_Mask__WEBPACK_IMPORTED_MODULE_1__/* .CoreMask.filterObjects */ .x0.filterObjects(coreGroup, params);
    for (let object of selectedObjects) {
      this._updateObject(object, params);
    }
    return coreGroup;
  }
  _updateObject(object, params) {
    if ((0,_core_BooleanValue__WEBPACK_IMPORTED_MODULE_2__/* .isBooleanTrue */ .bI)(params.tname)) {
      object.name = params.name;
    }
    if ((0,_core_BooleanValue__WEBPACK_IMPORTED_MODULE_2__/* .isBooleanTrue */ .bI)(params.trenderOrder)) {
      object.renderOrder = params.renderOrder;
    }
    if ((0,_core_BooleanValue__WEBPACK_IMPORTED_MODULE_2__/* .isBooleanTrue */ .bI)(params.tfrustumCulled)) {
      object.frustumCulled = params.frustumCulled;
    }
    if ((0,_core_BooleanValue__WEBPACK_IMPORTED_MODULE_2__/* .isBooleanTrue */ .bI)(params.tmatrixAutoUpdate)) {
      object.matrixAutoUpdate = params.matrixAutoUpdate;
    }
    if ((0,_core_BooleanValue__WEBPACK_IMPORTED_MODULE_2__/* .isBooleanTrue */ .bI)(params.tvisible)) {
      object.visible = params.visible;
    }
    if ((0,_core_BooleanValue__WEBPACK_IMPORTED_MODULE_2__/* .isBooleanTrue */ .bI)(params.tcastShadow)) {
      object.castShadow = params.castShadow;
    }
    if ((0,_core_BooleanValue__WEBPACK_IMPORTED_MODULE_2__/* .isBooleanTrue */ .bI)(params.treceiveShadow)) {
      object.receiveShadow = params.receiveShadow;
    }
  }
}
ObjectPropertiesSopOperation.DEFAULT_PARAMS = {
  group: "",
  // name
  tname: false,
  name: "",
  // renderOrder
  trenderOrder: false,
  renderOrder: 0,
  // frustrumCulled
  tfrustumCulled: false,
  frustumCulled: true,
  // matrixAutoUpdate
  tmatrixAutoUpdate: false,
  matrixAutoUpdate: false,
  // visible
  tvisible: false,
  visible: true,
  // castShadow
  tcastShadow: false,
  castShadow: true,
  // receiveShadow
  treceiveShadow: false,
  receiveShadow: true
};
ObjectPropertiesSopOperation.INPUT_CLONED_STATE = _engine_poly_InputCloneMode__WEBPACK_IMPORTED_MODULE_3__/* .InputCloneMode.FROM_NODE */ .m.FROM_NODE;


/***/ }),

/***/ 38681:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "k": function() { return /* binding */ ObjectsLayoutSopOperation; }
/* harmony export */ });
/* harmony import */ var _core_MapUtils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(94158);
/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(21410);
/* harmony import */ var _Base__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(82612);
/* harmony import */ var _engine_poly_InputCloneMode__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(56752);
/* harmony import */ var _core_Type__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(19037);
/* harmony import */ var _core_geometry_CoreObjectFactory__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(17353);







const currentPos = new three__WEBPACK_IMPORTED_MODULE_0__.Vector2(0, 0);
const maxPos = new three__WEBPACK_IMPORTED_MODULE_0__.Vector2(0, 0);
const box = new three__WEBPACK_IMPORTED_MODULE_0__.Box3();
const boxSize = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3(0, 0);
const objectsByRow = /* @__PURE__ */ new Map();
class ObjectsLayoutSopOperation extends _Base__WEBPACK_IMPORTED_MODULE_1__/* .BaseSopOperation */ .U {
  static type() {
    return "objectsLayout";
  }
  cook(inputCoreGroups, params) {
    const objects = inputCoreGroups[0].threejsObjects();
    currentPos.set(0, 0);
    maxPos.set(0, 0);
    objectsByRow.clear();
    let rowIndex = 0;
    const addRowWidth = (0,_core_Type__WEBPACK_IMPORTED_MODULE_2__/* .isBooleanTrue */ .bI)(params.addRowWidthInner) || (0,_core_Type__WEBPACK_IMPORTED_MODULE_2__/* .isBooleanTrue */ .bI)(params.addRowWidthOuter);
    for (let object of objects) {
      object.updateMatrix();
      box.setFromObject(object);
      box.getSize(boxSize);
      const scaleFactor = params.rowHeight / boxSize.y;
      object.scale.multiplyScalar(scaleFactor);
      object.updateMatrix();
      box.setFromObject(object);
      box.getSize(boxSize);
      boxSize.x += params.padding.x;
      boxSize.y += params.padding.y;
      currentPos.x += boxSize.x;
      if (currentPos.x > params.maxLayoutWidth) {
        currentPos.x = boxSize.x;
        currentPos.y -= boxSize.y;
        rowIndex++;
      }
      object.position.x = currentPos.x - boxSize.x * 0.5;
      object.position.y = currentPos.y - boxSize.y * 0.5;
      if ((0,_core_Type__WEBPACK_IMPORTED_MODULE_2__/* .isBooleanTrue */ .bI)(params.addAttribs)) {
        if (addRowWidth) {
          _core_MapUtils__WEBPACK_IMPORTED_MODULE_3__/* .MapUtils.pushOnArrayAtEntry */ .pl.pushOnArrayAtEntry(objectsByRow, rowIndex, object);
        }
        if ((0,_core_Type__WEBPACK_IMPORTED_MODULE_2__/* .isBooleanTrue */ .bI)(params.addRowAttrib)) {
          (0,_core_geometry_CoreObjectFactory__WEBPACK_IMPORTED_MODULE_4__/* .coreObjectClassFactory */ .Xr)(object).addAttribute(object, "row", rowIndex);
        }
      }
      maxPos.x = Math.max(maxPos.x, object.position.x + boxSize.x * 0.5);
      maxPos.y = Math.min(maxPos.y, object.position.y - boxSize.y * 0.5);
    }
    for (let object of objects) {
      object.position.x -= maxPos.x * 0.5;
      object.position.y -= maxPos.y * 0.5;
      object.updateMatrix();
    }
    if ((0,_core_Type__WEBPACK_IMPORTED_MODULE_2__/* .isBooleanTrue */ .bI)(params.addAttribs)) {
      if (addRowWidth) {
        objectsByRow.forEach((objects2, _) => {
          if ((0,_core_Type__WEBPACK_IMPORTED_MODULE_2__/* .isBooleanTrue */ .bI)(params.addRowWidthInner)) {
            const xs = objects2.map((o) => o.position.x);
            const minX = Math.min(...xs);
            const maxX = Math.max(...xs);
            const width = maxX - minX;
            for (let object of objects2) {
              (0,_core_geometry_CoreObjectFactory__WEBPACK_IMPORTED_MODULE_4__/* .coreObjectClassFactory */ .Xr)(object).addAttribute(object, "rowWidthInner", width);
            }
          }
          if ((0,_core_Type__WEBPACK_IMPORTED_MODULE_2__/* .isBooleanTrue */ .bI)(params.addRowWidthOuter)) {
            const minX = Math.min(
              ...objects2.map((o) => {
                box.setFromObject(o);
                box.getSize(boxSize);
                return o.position.x - boxSize.x * 0.5;
              })
            );
            const maxX = Math.max(
              ...objects2.map((o) => {
                box.setFromObject(o);
                box.getSize(boxSize);
                return o.position.x + boxSize.x * 0.5;
              })
            );
            const width = maxX - minX;
            for (let object of objects2) {
              (0,_core_geometry_CoreObjectFactory__WEBPACK_IMPORTED_MODULE_4__/* .coreObjectClassFactory */ .Xr)(object).addAttribute(object, "rowWidthOuter", width);
            }
          }
        });
      }
    }
    return this.createCoreGroupFromObjects(objects);
  }
}
ObjectsLayoutSopOperation.DEFAULT_PARAMS = {
  maxLayoutWidth: 10,
  rowHeight: 1,
  padding: new three__WEBPACK_IMPORTED_MODULE_0__.Vector2(0, 0),
  addAttribs: false,
  addRowAttrib: false,
  addRowWidthInner: false,
  addRowWidthOuter: false
};
ObjectsLayoutSopOperation.INPUT_CLONED_STATE = _engine_poly_InputCloneMode__WEBPACK_IMPORTED_MODULE_5__/* .InputCloneMode.FROM_NODE */ .m.FROM_NODE;


/***/ }),

/***/ 88356:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "m": function() { return /* binding */ PaletteSopOperation; }
/* harmony export */ });
/* harmony import */ var _Base__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(82612);
/* harmony import */ var _poly_InputCloneMode__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(56752);
/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(21410);
/* harmony import */ var _core_color_chromotomeWrapper__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(89151);
/* harmony import */ var _core_geometry_Constant__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(91568);
/* harmony import */ var _poly_Assert__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(68239);
/* harmony import */ var _core_geometry_CoreObjectFactory__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(17353);

var __async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};







class PaletteSopOperation extends _Base__WEBPACK_IMPORTED_MODULE_0__/* .BaseSopOperation */ .U {
  static type() {
    return "palette";
  }
  cook(inputCoreGroups, params) {
    const coreGroup = inputCoreGroups[0];
    const colors = [params.color1, params.color2, params.color3, params.color4, params.color5];
    this._addAttribute(_core_geometry_Constant__WEBPACK_IMPORTED_MODULE_1__/* .ATTRIBUTE_CLASSES */ .oT[params.class], coreGroup, params, colors);
    return coreGroup;
  }
  _addAttribute(attribClass, coreGroup, params, colors) {
    return __async(this, null, function* () {
      var _a, _b;
      switch (attribClass) {
        case _core_geometry_Constant__WEBPACK_IMPORTED_MODULE_1__/* .AttribClass.POINT */ .io.POINT:
          return yield this._setVertexColor(coreGroup, params, colors);
        case _core_geometry_Constant__WEBPACK_IMPORTED_MODULE_1__/* .AttribClass.VERTEX */ .io.VERTEX:
          (_a = this.states) == null ? void 0 : _a.error.set("vertex not supported yet");
          return;
        case _core_geometry_Constant__WEBPACK_IMPORTED_MODULE_1__/* .AttribClass.PRIMITIVE */ .io.PRIMITIVE:
          (_b = this.states) == null ? void 0 : _b.error.set("primitive not supported yet");
          return;
        case _core_geometry_Constant__WEBPACK_IMPORTED_MODULE_1__/* .AttribClass.OBJECT */ .io.OBJECT:
          return yield this._setObjectColor(coreGroup, params, colors);
        case _core_geometry_Constant__WEBPACK_IMPORTED_MODULE_1__/* .AttribClass.CORE_GROUP */ .io.CORE_GROUP:
          return;
      }
      _poly_Assert__WEBPACK_IMPORTED_MODULE_2__/* .TypeAssert.unreachable */ .f.unreachable(attribClass);
    });
  }
  _setObjectColor(coreGroup, params, colors) {
    const objects = coreGroup.allObjects();
    let i = 0;
    for (let object of objects) {
      const color = colors[i % params.colorsCount];
      (0,_core_geometry_CoreObjectFactory__WEBPACK_IMPORTED_MODULE_3__/* .coreObjectClassFactory */ .Xr)(object).addAttribute(object, "color", color.clone());
      i++;
    }
    return coreGroup;
  }
  _setVertexColor(coreGroup, params, colors) {
    const objects = coreGroup.threejsObjectsWithGeo();
    for (let object of objects) {
      this._setVertexColorToObject(object, params, colors);
    }
  }
  _setVertexColorToObject(object, params, colors) {
    if (params.colorsCount <= 0) {
      return;
    }
    const corePointClass = (0,_core_geometry_CoreObjectFactory__WEBPACK_IMPORTED_MODULE_3__/* .corePointClassFactory */ .E_)(object);
    const geometry = object.geometry;
    if (!geometry) {
      return;
    }
    let colorAttrib = geometry.getAttribute("color");
    if (!colorAttrib) {
      corePointClass.addNumericAttribute(object, "color", 3, [0, 0, 0]);
      colorAttrib = geometry.getAttribute("color");
    }
    if (!colorAttrib) {
      return;
    }
    const array = colorAttrib.array;
    let ptIndex = 0;
    for (let i = 0; i < array.length; i += 3) {
      const color = colors[ptIndex % params.colorsCount];
      color.toArray(array, i);
      ptIndex++;
    }
  }
}
PaletteSopOperation.DEFAULT_PARAMS = {
  class: _core_geometry_Constant__WEBPACK_IMPORTED_MODULE_1__/* .ATTRIBUTE_CLASSES.indexOf */ .oT.indexOf(_core_geometry_Constant__WEBPACK_IMPORTED_MODULE_1__/* .AttribClass.POINT */ .io.POINT),
  paletteName: _core_color_chromotomeWrapper__WEBPACK_IMPORTED_MODULE_4__/* .SORTED_PALETTE_NAMES[0] */ .QK[0],
  colorsCount: 0,
  color1: new three__WEBPACK_IMPORTED_MODULE_5__.Color(1, 1, 1),
  color2: new three__WEBPACK_IMPORTED_MODULE_5__.Color(1, 1, 1),
  color3: new three__WEBPACK_IMPORTED_MODULE_5__.Color(1, 1, 1),
  color4: new three__WEBPACK_IMPORTED_MODULE_5__.Color(1, 1, 1),
  color5: new three__WEBPACK_IMPORTED_MODULE_5__.Color(1, 1, 1)
};
PaletteSopOperation.INPUT_CLONED_STATE = _poly_InputCloneMode__WEBPACK_IMPORTED_MODULE_6__/* .InputCloneMode.FROM_NODE */ .m.FROM_NODE;


/***/ }),

/***/ 4811:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "TO": function() { return /* binding */ SIZE_COMPUTATION_METHOD_MENU_ENTRIES; },
/* harmony export */   "_K": function() { return /* binding */ SIZE_COMPUTATION_METHODS; },
/* harmony export */   "fM": function() { return /* binding */ PhysicsRBDAttributesSopOperation; },
/* harmony export */   "qc": function() { return /* binding */ SizeComputationMethod; }
/* harmony export */ });
/* harmony import */ var _core_physics_PhysicsAttribute__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(36911);
/* harmony import */ var _Base__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(82612);
/* harmony import */ var _engine_poly_InputCloneMode__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(56752);
/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(21410);






var SizeComputationMethod = /* @__PURE__ */ ((SizeComputationMethod2) => {
  SizeComputationMethod2["AUTO"] = "auto";
  SizeComputationMethod2["MANUAL"] = "manual";
  return SizeComputationMethod2;
})(SizeComputationMethod || {});
const SIZE_COMPUTATION_METHODS = [
  "auto" /* AUTO */,
  "manual" /* MANUAL */
];
const SIZE_COMPUTATION_METHOD_MENU_ENTRIES = SIZE_COMPUTATION_METHODS.map((name, value) => ({ name, value }));
class PhysicsRBDAttributesSopOperation extends _Base__WEBPACK_IMPORTED_MODULE_0__/* .BaseSopOperation */ .U {
  static type() {
    return "physicsRBDAttributes";
  }
  // override cook(inputCoreGroups: CoreGroup[], params: PhysicsRBDAttributesSopParams) {
  // 	const inputCoreGroup = inputCoreGroups[0];
  // 	const objects = inputCoreGroup.objects();
  // 	for (let object of objects) {
  // 		const colliderType = PHYSICS_RBD_COLLIDER_TYPES[params.colliderType];
  // 		CorePhysicsAttribute.setRBDType(object, PHYSICS_RBD_TYPES[params.RBDType]);
  // 		CorePhysicsAttribute.setColliderType(object, colliderType);
  // 		CorePhysicsAttribute.setDensity(object, params.density);
  // 		CorePhysicsAttribute.setRestitution(object, params.restitution);
  // 		CorePhysicsAttribute.setLinearDamping(object, params.linearDamping);
  // 		CorePhysicsAttribute.setAngularDamping(object, params.angularDamping);
  // 		CorePhysicsAttribute.setCanSleep(object, params.canSleep);
  // 		if (isBooleanTrue(params.taddId)) {
  // 			CorePhysicsAttribute.setRBDId(object, params.id);
  // 		}
  // 		switch (colliderType) {
  // 			case PhysicsRBDColliderType.CUBOID: {
  // 				CorePhysicsAttribute.setCuboidSize(object, params.size);
  // 				break;
  // 			}
  // 			case PhysicsRBDColliderType.SPHERE: {
  // 				CorePhysicsAttribute.setRadius(object, params.radius);
  // 				break;
  // 			}
  // 			case PhysicsRBDColliderType.CAPSULE: {
  // 				CorePhysicsAttribute.setHeight(object, params.height);
  // 				CorePhysicsAttribute.setRadius(object, params.radius);
  // 				break;
  // 			}
  // 		}
  // 	}
  // 	return inputCoreGroup;
  // }
}
PhysicsRBDAttributesSopOperation.DEFAULT_PARAMS = {
  RBDType: _core_physics_PhysicsAttribute__WEBPACK_IMPORTED_MODULE_1__/* .PHYSICS_RBD_TYPES.indexOf */ .LL.indexOf(_core_physics_PhysicsAttribute__WEBPACK_IMPORTED_MODULE_1__/* .PhysicsRBDType.DYNAMIC */ .$M.DYNAMIC),
  colliderType: _core_physics_PhysicsAttribute__WEBPACK_IMPORTED_MODULE_1__/* .PHYSICS_RBD_COLLIDER_TYPES.indexOf */ .EX.indexOf(_core_physics_PhysicsAttribute__WEBPACK_IMPORTED_MODULE_1__/* .PhysicsRBDColliderType.CUBOID */ .bs.CUBOID),
  taddId: true,
  id: "",
  sizeMethod: SIZE_COMPUTATION_METHODS.indexOf("auto" /* AUTO */),
  borderRadius: 0.1,
  // cuboid
  sizes: new three__WEBPACK_IMPORTED_MODULE_2__.Vector3(1, 1, 1),
  size: 1,
  // sphere
  radius: 1,
  // capsule
  height: 0.5,
  // heightField
  rows: 20,
  cols: 20,
  // common
  density: 1,
  friction: 0.5,
  restitution: 0.5,
  linearDamping: 0,
  angularDamping: 0,
  linearVelocity: new three__WEBPACK_IMPORTED_MODULE_2__.Vector3(0, 0, 0),
  angularVelocity: new three__WEBPACK_IMPORTED_MODULE_2__.Vector3(0, 0, 0),
  gravityScale: 1,
  canSleep: true
};
PhysicsRBDAttributesSopOperation.INPUT_CLONED_STATE = _engine_poly_InputCloneMode__WEBPACK_IMPORTED_MODULE_3__/* .InputCloneMode.FROM_NODE */ .m.FROM_NODE;


/***/ }),

/***/ 81927:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "j": function() { return /* binding */ PlaneSopOperation; },
/* harmony export */   "t": function() { return /* binding */ DEFAULT_PARAMS; }
/* harmony export */ });
/* harmony import */ var _Base__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(82612);
/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(21410);
/* harmony import */ var _core_Transform__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(87883);
/* harmony import */ var _engine_poly_InputCloneMode__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(56752);
/* harmony import */ var _core_BooleanValue__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(19037);
/* harmony import */ var _core_geometry_Constant__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(91568);







const tmpBox = new three__WEBPACK_IMPORTED_MODULE_0__.Box3();
const tmpBoxPreRotation = new three__WEBPACK_IMPORTED_MODULE_0__.Box3();
const tmpSize = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();
const tmpCenter = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();
const DEFAULT_UP = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3(0, 0, 1);
const q = new three__WEBPACK_IMPORTED_MODULE_0__.Quaternion();
const DEFAULT_PARAMS = {
  size: new three__WEBPACK_IMPORTED_MODULE_0__.Vector2(1, 1),
  useSegmentsCount: false,
  stepSize: 1,
  segments: new three__WEBPACK_IMPORTED_MODULE_0__.Vector2(1, 1),
  direction: new three__WEBPACK_IMPORTED_MODULE_0__.Vector3(0, 1, 0),
  center: new three__WEBPACK_IMPORTED_MODULE_0__.Vector3(0, 0, 0),
  asLines: false
};
const _segmentsCount = new three__WEBPACK_IMPORTED_MODULE_0__.Vector2(1, 1);
class PlaneSopOperation extends _Base__WEBPACK_IMPORTED_MODULE_1__/* .BaseSopOperation */ .U {
  constructor() {
    super(...arguments);
    this._coreTransform = new _core_Transform__WEBPACK_IMPORTED_MODULE_2__/* .CoreTransform */ .ZR();
  }
  static type() {
    return "plane";
  }
  cook(inputCoreGroups, params) {
    const coreGroup = inputCoreGroups[0];
    if (coreGroup) {
      return this._cookWithInput(coreGroup, params);
    } else {
      return this._cookWithoutInput(params);
    }
  }
  _cookWithoutInput(params) {
    const geometry = this._createPlane(params.size, params);
    (0,_core_Transform__WEBPACK_IMPORTED_MODULE_2__/* .rotateGeometry */ .bP)(geometry, DEFAULT_UP, params.direction);
    const matrix = this._coreTransform.translationMatrix(params.center);
    geometry.applyMatrix4(matrix);
    const object = this._createPlaneObject(geometry, params);
    return this.createCoreGroupFromObjects([object]);
  }
  _cookWithInput(coreGroup, params) {
    coreGroup.boundingBox(tmpBoxPreRotation);
    tmpBoxPreRotation.getCenter(tmpCenter);
    coreGroup.boundingBox(tmpBox);
    tmpBox.getSize(tmpSize);
    tmpBox.getCenter(tmpCenter);
    const boxGeometry = new three__WEBPACK_IMPORTED_MODULE_0__.BoxGeometry(tmpSize.x, tmpSize.y, tmpSize.z, 1, 1, 1);
    function _applyInputQuaternion(_q) {
      boxGeometry.applyQuaternion(_q);
      boxGeometry.computeBoundingBox();
    }
    function _setInputRotation() {
      q.setFromUnitVectors(DEFAULT_UP, params.direction);
      _applyInputQuaternion(q);
    }
    _setInputRotation();
    const bboxPostRotation = boxGeometry.boundingBox;
    bboxPostRotation.getSize(tmpSize);
    const size2d = new three__WEBPACK_IMPORTED_MODULE_0__.Vector2(tmpSize.x, tmpSize.y);
    const geometry = this._createPlane(size2d, params);
    (0,_core_Transform__WEBPACK_IMPORTED_MODULE_2__/* .rotateGeometry */ .bP)(geometry, DEFAULT_UP, params.direction);
    geometry.translate(tmpCenter.x, tmpCenter.y, tmpCenter.z);
    const object = this._createPlaneObject(geometry, params);
    return this.createCoreGroupFromObjects([object]);
  }
  _createPlaneObject(geometry, params) {
    return _Base__WEBPACK_IMPORTED_MODULE_1__/* .BaseSopOperation.createObject */ .U.createObject(geometry, params.asLines ? _core_geometry_Constant__WEBPACK_IMPORTED_MODULE_3__/* .ObjectType.LINE_SEGMENTS */ .LP.LINE_SEGMENTS : _core_geometry_Constant__WEBPACK_IMPORTED_MODULE_3__/* .ObjectType.MESH */ .LP.MESH);
  }
  _createPlane(size, params) {
    size = size.clone();
    if ((0,_core_BooleanValue__WEBPACK_IMPORTED_MODULE_4__/* .isBooleanTrue */ .bI)(params.useSegmentsCount)) {
      _segmentsCount.x = Math.floor(params.segments.x);
      _segmentsCount.y = Math.floor(params.segments.y);
    } else {
      if (params.stepSize > 0) {
        size.x = Math.max(size.x, params.stepSize);
        size.y = Math.max(size.y, params.stepSize);
        _segmentsCount.x = Math.floor(size.x / params.stepSize);
        _segmentsCount.y = Math.floor(size.y / params.stepSize);
        size.x = _segmentsCount.x * params.stepSize;
        size.y = _segmentsCount.y * params.stepSize;
      }
    }
    const geometry = new three__WEBPACK_IMPORTED_MODULE_0__.PlaneGeometry(size.x, size.y, _segmentsCount.x, _segmentsCount.y);
    if ((0,_core_BooleanValue__WEBPACK_IMPORTED_MODULE_4__/* .isBooleanTrue */ .bI)(params.asLines)) {
      const gridX = Math.floor(_segmentsCount.x);
      const gridY = Math.floor(_segmentsCount.y);
      const gridX1 = gridX + 1;
      const indices = [];
      for (let iy = 0; iy < gridY; iy++) {
        for (let ix = 0; ix < gridX; ix++) {
          const a = ix + gridX1 * iy;
          const b = ix + gridX1 * (iy + 1);
          const d = ix + 1 + gridX1 * iy;
          indices.push(a, b);
          indices.push(a, d);
          const lastX = ix == gridX - 1;
          const lastY = iy == gridY - 1;
          if (lastX || lastY) {
            const c = ix + 1 + gridX1 * (iy + 1);
            if (lastX) {
              indices.push(d, c);
            }
            if (lastY) {
              indices.push(b, c);
            }
          }
        }
      }
      geometry.setIndex(indices);
    }
    return geometry;
  }
}
PlaneSopOperation.DEFAULT_PARAMS = DEFAULT_PARAMS;
PlaneSopOperation.INPUT_CLONED_STATE = _engine_poly_InputCloneMode__WEBPACK_IMPORTED_MODULE_5__/* .InputCloneMode.NEVER */ .m.NEVER;


/***/ }),

/***/ 78695:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "X": function() { return /* binding */ PointLightSopOperation; }
/* harmony export */ });
/* harmony import */ var _core_lights_Common__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(30654);
/* harmony import */ var _Base__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(82612);
/* harmony import */ var _engine_poly_InputCloneMode__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(56752);
/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(21410);
/* harmony import */ var _core_BooleanValue__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(19037);
/* harmony import */ var _core_lights_PointLight__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(35031);
/* harmony import */ var _core_geometry_Constant__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(91568);








class PointLightSopOperation extends _Base__WEBPACK_IMPORTED_MODULE_0__/* .BaseSopOperation */ .U {
  static type() {
    return "pointLight";
  }
  cook(input_contents, params) {
    const light = this.createLight();
    light.name = params.name;
    this.updateLightParams(light, params);
    this.updateShadowParams(light, params);
    if ((0,_core_BooleanValue__WEBPACK_IMPORTED_MODULE_1__/* .isBooleanTrue */ .bI)(params.showHelper)) {
      const group = new three__WEBPACK_IMPORTED_MODULE_2__.Group();
      group.name = `PointLightGroup_${light.name}`;
      group.add(light);
      const helper = this._createHelper(light, params);
      if (helper) {
        group.add(helper);
        helper.name = `PointLightHelper_${light.name}`;
      }
      return this.createCoreGroupFromObjects([group]);
    } else {
      return this.createCoreGroupFromObjects([light]);
    }
  }
  _createHelper(light, params) {
    this._helper = this._helper || new _core_lights_PointLight__WEBPACK_IMPORTED_MODULE_3__/* .CorePointLightHelper */ .cg();
    return this._helper.createAndBuildObject({ helperSize: params.helperSize, light });
  }
  createLight() {
    var _a;
    (0,_core_geometry_Constant__WEBPACK_IMPORTED_MODULE_4__/* .registerObjectType */ .UX)({
      type: _core_geometry_Constant__WEBPACK_IMPORTED_MODULE_4__/* .ObjectType.POINT_LIGHT */ .LP.POINT_LIGHT,
      checkFunc: (obj) => {
        if (obj.isPointLight) {
          return _core_geometry_Constant__WEBPACK_IMPORTED_MODULE_4__/* .ObjectType.POINT_LIGHT */ .LP.POINT_LIGHT;
        }
      },
      ctor: three__WEBPACK_IMPORTED_MODULE_2__.PointLight,
      humanName: "PointLight"
    });
    const light = new three__WEBPACK_IMPORTED_MODULE_2__.PointLight();
    const nodeName = (_a = this._node) == null ? void 0 : _a.name();
    if (nodeName) {
      light.name = `PointLight_${nodeName}`;
    }
    light.matrixAutoUpdate = false;
    light.castShadow = true;
    light.shadow.bias = -1e-3;
    light.shadow.mapSize.x = 1024;
    light.shadow.mapSize.y = 1024;
    light.shadow.camera.near = 0.1;
    return light;
  }
  updateLightParams(light, params) {
    light.color = params.color;
    light.intensity = params.intensity;
    light.decay = params.decay;
    light.distance = params.distance;
    light.userData[_core_lights_Common__WEBPACK_IMPORTED_MODULE_5__/* .LightUserDataRaymarching.PENUMBRA */ .W.PENUMBRA] = params.raymarchingPenumbra;
    light.userData[_core_lights_Common__WEBPACK_IMPORTED_MODULE_5__/* .LightUserDataRaymarching.SHADOW_BIAS_ANGLE */ .W.SHADOW_BIAS_ANGLE] = params.raymarchingShadowBiasAngle;
    light.userData[_core_lights_Common__WEBPACK_IMPORTED_MODULE_5__/* .LightUserDataRaymarching.SHADOW_BIAS_DISTANCE */ .W.SHADOW_BIAS_DISTANCE] = params.raymarchingShadowBiasDistance;
  }
  updateShadowParams(light, params) {
    light.castShadow = (0,_core_BooleanValue__WEBPACK_IMPORTED_MODULE_1__/* .isBooleanTrue */ .bI)(params.castShadow);
    light.shadow.autoUpdate = (0,_core_BooleanValue__WEBPACK_IMPORTED_MODULE_1__/* .isBooleanTrue */ .bI)(params.shadowAutoUpdate);
    light.shadow.needsUpdate = light.shadow.autoUpdate || (0,_core_BooleanValue__WEBPACK_IMPORTED_MODULE_1__/* .isBooleanTrue */ .bI)(params.shadowUpdateOnNextRender);
    light.shadow.mapSize.copy(params.shadowRes);
    light.shadow.camera.near = params.shadowNear;
    light.shadow.camera.far = params.shadowFar;
    light.shadow.bias = params.shadowBias;
    light.shadow.camera.updateProjectionMatrix();
  }
  // private __debugShadowMesh: Mesh<PlaneGeometry, MeshBasicMaterial> | undefined;
  // private _debugShadowMesh(light: PointLight) {
  // 	return (this.__debugShadowMesh = this.__debugShadowMesh || this._createDebugShadowMesh(light));
  // }
  // private _createDebugShadowMesh(light: PointLight) {
  // 	const material = new MeshBasicMaterial({
  // 		color: new Color(1, 1, 1),
  // 		map: light.shadow.map.texture,
  // 		side: DoubleSide,
  // 	});
  // 	const mesh = new Mesh(new PlaneGeometry(5, 5, 2, 2), material);
  // 	mesh.position.z = 1;
  // 	mesh.castShadow = false;
  // 	mesh.receiveShadow = false;
  // 	return mesh;
  // }
}
PointLightSopOperation.DEFAULT_PARAMS = _core_lights_PointLight__WEBPACK_IMPORTED_MODULE_3__/* .DEFAULT_POINT_LIGHT_PARAMS */ .Uw;
PointLightSopOperation.INPUT_CLONED_STATE = _engine_poly_InputCloneMode__WEBPACK_IMPORTED_MODULE_6__/* .InputCloneMode.NEVER */ .m.NEVER;


/***/ }),

/***/ 34633:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "P": function() { return /* binding */ PolarTransformSopOperation; }
/* harmony export */ });
/* harmony import */ var _Base__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(82612);
/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(21410);
/* harmony import */ var _engine_poly_Assert__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(68239);
/* harmony import */ var _core_Transform__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(87883);
/* harmony import */ var _engine_poly_InputCloneMode__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(56752);
/* harmony import */ var _core_PolarTransform__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(45824);







class PolarTransformSopOperation extends _Base__WEBPACK_IMPORTED_MODULE_0__/* .BaseSopOperation */ .U {
  constructor() {
    super(...arguments);
    this._fullMatrix = new three__WEBPACK_IMPORTED_MODULE_1__.Matrix4();
  }
  static type() {
    return "polarTransform";
  }
  cook(inputCoreGroups, params) {
    const objects = inputCoreGroups[0].threejsObjects();
    _core_PolarTransform__WEBPACK_IMPORTED_MODULE_2__/* .CorePolarTransform.matrix */ .i.matrix(params, this._fullMatrix);
    this._applyTransform(objects, params, this._fullMatrix);
    return inputCoreGroups[0];
  }
  _applyTransform(objects, params, matrix) {
    const mode = _core_Transform__WEBPACK_IMPORTED_MODULE_3__/* .TRANSFORM_TARGET_TYPES */ .Pr[params.applyOn];
    switch (mode) {
      case _core_Transform__WEBPACK_IMPORTED_MODULE_3__/* .TransformTargetType.GEOMETRY */ .dH.GEOMETRY: {
        return this._applyMatrixToGeometries(objects, matrix);
      }
      case _core_Transform__WEBPACK_IMPORTED_MODULE_3__/* .TransformTargetType.OBJECT */ .dH.OBJECT: {
        return this._applyMatrixToObjects(objects, matrix);
      }
    }
    _engine_poly_Assert__WEBPACK_IMPORTED_MODULE_4__/* .TypeAssert.unreachable */ .f.unreachable(mode);
  }
  _applyMatrixToGeometries(objects, matrix) {
    for (let object of objects) {
      const geometry = object.geometry;
      if (geometry) {
        geometry.applyMatrix4(matrix);
      }
    }
  }
  _applyMatrixToObjects(objects, matrix) {
    for (let object of objects) {
      _core_PolarTransform__WEBPACK_IMPORTED_MODULE_2__/* .CorePolarTransform.applyMatrixToObject */ .i.applyMatrixToObject(object, matrix);
    }
  }
}
PolarTransformSopOperation.DEFAULT_PARAMS = {
  applyOn: _core_Transform__WEBPACK_IMPORTED_MODULE_3__/* .TRANSFORM_TARGET_TYPES.indexOf */ .Pr.indexOf(_core_Transform__WEBPACK_IMPORTED_MODULE_3__/* .TransformTargetType.OBJECT */ .dH.OBJECT),
  center: new three__WEBPACK_IMPORTED_MODULE_1__.Vector3(0, 0, 0),
  longitude: 0,
  latitude: 0,
  depth: 1
};
PolarTransformSopOperation.INPUT_CLONED_STATE = _engine_poly_InputCloneMode__WEBPACK_IMPORTED_MODULE_5__/* .InputCloneMode.FROM_NODE */ .m.FROM_NODE;


/***/ }),

/***/ 27613:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "LE": function() { return /* binding */ RaySopOperation; },
/* harmony export */   "i5": function() { return /* binding */ RAY_SOP_MODES; }
/* harmony export */ });
/* unused harmony export RaySopMode */
/* harmony import */ var _Base__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(82612);
/* harmony import */ var _engine_poly_InputCloneMode__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(56752);
/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(21410);
/* harmony import */ var _core_BooleanValue__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(19037);
/* harmony import */ var _core_render_MatDoubleSideTmpSetter__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(35851);
/* harmony import */ var _poly_Assert__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(68239);
/* harmony import */ var _core_geometry_bvh_ThreeMeshBVHHelper__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(17862);
/* harmony import */ var _core_RaycastHelper__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(71003);
/* harmony import */ var _core_geometry_CoreObjectFactory__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(17353);










var RaySopMode = /* @__PURE__ */ ((RaySopMode2) => {
  RaySopMode2["PROJECT_RAY"] = "project rays";
  RaySopMode2["MIN_DIST"] = "minimum distance";
  return RaySopMode2;
})(RaySopMode || {});
const RAY_SOP_MODES = ["project rays" /* PROJECT_RAY */, "minimum distance" /* MIN_DIST */];
const DIST_ATTRIB_NAME = "dist";
const objectWorldMat = new three__WEBPACK_IMPORTED_MODULE_0__.Matrix4();
const objectWorldMatInverse = new three__WEBPACK_IMPORTED_MODULE_0__.Matrix4();
const _points = [];
class RaySopOperation extends _Base__WEBPACK_IMPORTED_MODULE_1__/* .BaseSopOperation */ .U {
  constructor() {
    super(...arguments);
    this._matDoubleSideTmpSetter = new _core_render_MatDoubleSideTmpSetter__WEBPACK_IMPORTED_MODULE_2__/* .MatDoubleSideTmpSetter */ ._();
    this._raycaster = (0,_core_RaycastHelper__WEBPACK_IMPORTED_MODULE_3__/* .createRaycaster */ .j)();
    this._pointPos = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();
    this._pointNormal = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();
    this._hitPointInfo = {
      point: new three__WEBPACK_IMPORTED_MODULE_0__.Vector3(),
      distance: -1,
      faceIndex: -1
    };
    this._triangle = new three__WEBPACK_IMPORTED_MODULE_0__.Triangle();
    this._faceNormal = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();
  }
  static type() {
    return "ray";
  }
  cook(inputCoreGroups, params) {
    const coreGroupToRay = inputCoreGroups[0];
    const coreGroupToRayOnto = inputCoreGroups[1];
    const coreGroup = this._ray(coreGroupToRay, coreGroupToRayOnto, params);
    return coreGroup;
  }
  _ray(coreGroup, coreGroupCollision, params) {
    const mode = RAY_SOP_MODES[params.mode];
    switch (mode) {
      case "project rays" /* PROJECT_RAY */: {
        return this._computeWithProjectRay(coreGroup, coreGroupCollision, params);
      }
      case "minimum distance" /* MIN_DIST */: {
        return this._computeWithMinDist(coreGroup, coreGroupCollision, params);
      }
    }
    _poly_Assert__WEBPACK_IMPORTED_MODULE_4__/* .TypeAssert.unreachable */ .f.unreachable(mode);
  }
  _computeWithProjectRay(coreGroup, coreGroupCollision, params) {
    this._matDoubleSideTmpSetter.setCoreGroupMaterialDoubleSided(coreGroupCollision);
    if ((0,_core_BooleanValue__WEBPACK_IMPORTED_MODULE_5__/* .isBooleanTrue */ .bI)(params.addDistAttribute)) {
      if (!coreGroup.hasPointAttrib(DIST_ATTRIB_NAME)) {
        const allObjects = coreGroup.allObjects();
        for (const object of allObjects) {
          const corePointClass = (0,_core_geometry_CoreObjectFactory__WEBPACK_IMPORTED_MODULE_6__/* .corePointClassFactory */ .E_)(object);
          corePointClass.addNumericAttribute(object, DIST_ATTRIB_NAME, 1, -1);
        }
      }
    }
    let direction, firstIntersect;
    coreGroup.points(_points);
    for (const point of _points) {
      point.position(this._pointPos);
      direction = params.direction;
      if ((0,_core_BooleanValue__WEBPACK_IMPORTED_MODULE_5__/* .isBooleanTrue */ .bI)(params.useNormals)) {
        point.normal(this._pointNormal);
        direction = this._pointNormal;
      }
      this._raycaster.set(this._pointPos, direction);
      firstIntersect = this._raycaster.intersectObjects(coreGroupCollision.threejsObjects(), true)[0];
      if (firstIntersect) {
        if ((0,_core_BooleanValue__WEBPACK_IMPORTED_MODULE_5__/* .isBooleanTrue */ .bI)(params.transformPoints)) {
          point.setPosition(firstIntersect.point);
        }
        if ((0,_core_BooleanValue__WEBPACK_IMPORTED_MODULE_5__/* .isBooleanTrue */ .bI)(params.addDistAttribute)) {
          const dist = this._pointPos.distanceTo(firstIntersect.point);
          point.setAttribValue(DIST_ATTRIB_NAME, dist);
        }
        if ((0,_core_BooleanValue__WEBPACK_IMPORTED_MODULE_5__/* .isBooleanTrue */ .bI)(params.transferFaceNormals) && firstIntersect.face) {
          point.setNormal(firstIntersect.face.normal);
        }
      }
    }
    this._matDoubleSideTmpSetter.restoreMaterialSideProperty(coreGroupCollision);
    return coreGroup;
  }
  _computeWithMinDist(coreGroup, coreGroupCollision, params) {
    var _a, _b;
    const coreGroupCollisionObject = coreGroupCollision.threejsObjectsWithGeo()[0];
    const collisionGeometry = coreGroupCollisionObject.geometry;
    const indexArray = (_a = collisionGeometry.getIndex()) == null ? void 0 : _a.array;
    if (!indexArray) {
      (_b = this.states) == null ? void 0 : _b.error.set("the collision geo requires an index");
      return coreGroup;
    }
    let bvh = collisionGeometry.boundsTree;
    if (!bvh) {
      _core_geometry_bvh_ThreeMeshBVHHelper__WEBPACK_IMPORTED_MODULE_7__/* .ThreeMeshBVHHelper.assignDefaultBVHIfNone */ .h.assignDefaultBVHIfNone(coreGroupCollisionObject);
      bvh = collisionGeometry.boundsTree;
    }
    coreGroupCollisionObject.updateMatrixWorld(true);
    objectWorldMat.copy(coreGroupCollisionObject.matrixWorld);
    objectWorldMatInverse.copy(objectWorldMat).invert();
    const position = collisionGeometry.getAttribute("position");
    coreGroup.points(_points);
    for (const point of _points) {
      point.position(this._pointPos);
      this._pointPos.applyMatrix4(objectWorldMatInverse);
      bvh.closestPointToPoint(this._pointPos, this._hitPointInfo);
      if ((0,_core_BooleanValue__WEBPACK_IMPORTED_MODULE_5__/* .isBooleanTrue */ .bI)(params.transformPoints)) {
        this._hitPointInfo.point.applyMatrix4(objectWorldMat);
        point.setPosition(this._hitPointInfo.point);
      }
      if ((0,_core_BooleanValue__WEBPACK_IMPORTED_MODULE_5__/* .isBooleanTrue */ .bI)(params.addDistAttribute)) {
        point.setAttribValue(DIST_ATTRIB_NAME, this._hitPointInfo.distance);
      }
      if ((0,_core_BooleanValue__WEBPACK_IMPORTED_MODULE_5__/* .isBooleanTrue */ .bI)(params.transferFaceNormals)) {
        this._triangle.setFromAttributeAndIndices(
          position,
          indexArray[3 * this._hitPointInfo.faceIndex],
          indexArray[3 * this._hitPointInfo.faceIndex + 1],
          indexArray[3 * this._hitPointInfo.faceIndex + 2]
        );
        this._triangle.getNormal(this._faceNormal);
        point.setNormal(this._faceNormal);
      }
    }
    return coreGroup;
  }
}
RaySopOperation.DEFAULT_PARAMS = {
  mode: RAY_SOP_MODES.indexOf("project rays" /* PROJECT_RAY */),
  useNormals: true,
  direction: new three__WEBPACK_IMPORTED_MODULE_0__.Vector3(0, -1, 0),
  transformPoints: true,
  transferFaceNormals: true,
  addDistAttribute: false
};
RaySopOperation.INPUT_CLONED_STATE = [_engine_poly_InputCloneMode__WEBPACK_IMPORTED_MODULE_8__/* .InputCloneMode.FROM_NODE */ .m.FROM_NODE, _engine_poly_InputCloneMode__WEBPACK_IMPORTED_MODULE_8__/* .InputCloneMode.NEVER */ .m.NEVER];


/***/ }),

/***/ 77475:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "d": function() { return /* binding */ RestAttributesSopOperation; }
/* harmony export */ });
/* harmony import */ var _Base__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(82612);
/* harmony import */ var _core_BooleanValue__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(19037);



class RestAttributesSopOperation extends _Base__WEBPACK_IMPORTED_MODULE_0__/* .BaseSopOperation */ .U {
  static type() {
    return "restAttributes";
  }
  cook(input_contents, params) {
    const core_group = input_contents[0];
    const objects = core_group.threejsObjectsWithGeo();
    if ((0,_core_BooleanValue__WEBPACK_IMPORTED_MODULE_1__/* .isBooleanTrue */ .bI)(params.tposition)) {
      this._create_rest_attribute(objects, params.position, params.restP);
    }
    if ((0,_core_BooleanValue__WEBPACK_IMPORTED_MODULE_1__/* .isBooleanTrue */ .bI)(params.tnormal)) {
      this._create_rest_attribute(objects, params.normal, params.restN);
    }
    return this.createCoreGroupFromObjects(objects);
  }
  _create_rest_attribute(objects, attrib_name, rest_attrib_name) {
    for (let object of objects) {
      const geometry = object.geometry;
      if (geometry) {
        const src_attrib = geometry.getAttribute(attrib_name);
        if (src_attrib) {
          geometry.setAttribute(rest_attrib_name, src_attrib.clone());
        }
      }
    }
  }
}
RestAttributesSopOperation.DEFAULT_PARAMS = {
  tposition: true,
  position: "position",
  restP: "restP",
  tnormal: true,
  normal: "normal",
  restN: "restN"
};


/***/ }),

/***/ 2896:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "_": function() { return /* binding */ SetChildrenSopOperation; }
/* harmony export */ });
/* harmony import */ var _Base__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(82612);
/* harmony import */ var _engine_poly_InputCloneMode__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(56752);
/* harmony import */ var _core_Type__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(19037);




class SetChildrenSopOperation extends _Base__WEBPACK_IMPORTED_MODULE_0__/* .BaseSopOperation */ .U {
  static type() {
    return "setChildren";
  }
  cook(inputCoreGroups, params) {
    var _a;
    const parentCoreGroup = inputCoreGroups[0];
    const childrenCoreGroup = inputCoreGroups[1];
    if (!childrenCoreGroup) {
      (_a = this.states) == null ? void 0 : _a.error.set("input 1 is invalid");
      return this.createCoreGroupFromObjects([]);
    }
    const parentObjects = parentCoreGroup.threejsObjects();
    const childrenObjects = childrenCoreGroup.threejsObjects();
    let i = 0;
    if ((0,_core_Type__WEBPACK_IMPORTED_MODULE_1__/* .isBooleanTrue */ .bI)(params.clearExistingChildren)) {
      for (const parentObject of parentObjects) {
        let child;
        while (child = parentObject.children[0]) {
          parentObject.remove(child);
        }
      }
    }
    for (const childObject of childrenObjects) {
      const parentObject = parentObjects[i] || parentObjects[parentObjects.length - 1];
      if (childObject) {
        parentObject.add(childObject);
      }
      i++;
    }
    return this.createCoreGroupFromObjects(parentObjects);
  }
}
SetChildrenSopOperation.DEFAULT_PARAMS = {
  clearExistingChildren: true
};
SetChildrenSopOperation.INPUT_CLONED_STATE = [_engine_poly_InputCloneMode__WEBPACK_IMPORTED_MODULE_2__/* .InputCloneMode.FROM_NODE */ .m.FROM_NODE, _engine_poly_InputCloneMode__WEBPACK_IMPORTED_MODULE_2__/* .InputCloneMode.FROM_NODE */ .m.FROM_NODE];


/***/ }),

/***/ 43099:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "HV": function() { return /* binding */ SetGeometrySopOperation; },
/* harmony export */   "xj": function() { return /* binding */ SET_GEOMETRY_MODES; }
/* harmony export */ });
/* unused harmony export SetGeometryMode */
/* harmony import */ var _poly_Assert__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(68239);
/* harmony import */ var _Base__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(82612);
/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(21410);
/* harmony import */ var _engine_poly_InputCloneMode__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(56752);





var SetGeometryMode = /* @__PURE__ */ ((SetGeometryMode2) => {
  SetGeometryMode2["ONE_GEO_PER_OBJECT"] = "One Geometry Per Object";
  SetGeometryMode2["FIRST_GEO_TO_EACH_OBJECT"] = "First Geometry To Each Object";
  return SetGeometryMode2;
})(SetGeometryMode || {});
const SET_GEOMETRY_MODES = [
  "One Geometry Per Object" /* ONE_GEO_PER_OBJECT */,
  "First Geometry To Each Object" /* FIRST_GEO_TO_EACH_OBJECT */
];
const _SetGeometrySopOperation = class extends _Base__WEBPACK_IMPORTED_MODULE_0__/* .BaseSopOperation */ .U {
  static type() {
    return "setGeometry";
  }
  cook(inputCoreGroups, params) {
    const coreGroupDest = inputCoreGroups[0];
    const coreGroupSrc = inputCoreGroups[1];
    this._applyMode(coreGroupDest, coreGroupSrc, params);
    return coreGroupDest;
  }
  _applyMode(coreGroupDest, coreGroupSrc, params) {
    const mode = SET_GEOMETRY_MODES[params.mode];
    switch (mode) {
      case "One Geometry Per Object" /* ONE_GEO_PER_OBJECT */: {
        return this._oneGeoPerObject(coreGroupDest, coreGroupSrc);
      }
      case "First Geometry To Each Object" /* FIRST_GEO_TO_EACH_OBJECT */: {
        return this._firstGeoToEachObject(coreGroupDest, coreGroupSrc);
      }
    }
    _poly_Assert__WEBPACK_IMPORTED_MODULE_1__/* .TypeAssert.unreachable */ .f.unreachable(mode);
  }
  _oneGeoPerObject(coreGroupDest, coreGroupSrc) {
    const destObjects = coreGroupDest.threejsObjects();
    const srcObjects = coreGroupSrc.threejsObjects();
    for (let i = 0; i < destObjects.length; i++) {
      const destObject = destObjects[i];
      const srcObject = srcObjects[i];
      if (destObject) {
        destObject.geometry = srcObject ? srcObject.geometry : _SetGeometrySopOperation._emptyGeometry();
      }
    }
  }
  _firstGeoToEachObject(coreGroupDest, coreGroupSrc) {
    const destObjects = coreGroupDest.threejsObjects();
    const srcObjects = coreGroupSrc.threejsObjects();
    let firstGeometry;
    for (let srcObject of srcObjects) {
      if (srcObject.geometry) {
        firstGeometry = srcObject.geometry;
      }
    }
    for (let i = 0; i < destObjects.length; i++) {
      const destObject = destObjects[i];
      if (destObject) {
        destObject.geometry = firstGeometry || _SetGeometrySopOperation._emptyGeometry();
      }
    }
  }
  static _emptyGeometry() {
    return this.__emptyGeometry = this.__emptyGeometry || new three__WEBPACK_IMPORTED_MODULE_2__.BufferGeometry();
  }
};
let SetGeometrySopOperation = _SetGeometrySopOperation;
SetGeometrySopOperation.DEFAULT_PARAMS = {
  mode: SET_GEOMETRY_MODES.indexOf("One Geometry Per Object" /* ONE_GEO_PER_OBJECT */)
};
SetGeometrySopOperation.INPUT_CLONED_STATE = [_engine_poly_InputCloneMode__WEBPACK_IMPORTED_MODULE_3__/* .InputCloneMode.FROM_NODE */ .m.FROM_NODE, _engine_poly_InputCloneMode__WEBPACK_IMPORTED_MODULE_3__/* .InputCloneMode.NEVER */ .m.NEVER];


/***/ }),

/***/ 32234:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "QY": function() { return /* binding */ AXISES; },
/* harmony export */   "Xp": function() { return /* binding */ SORT_TARGET_TYPES; },
/* harmony export */   "ZM": function() { return /* binding */ SortSopOperation; },
/* harmony export */   "h8": function() { return /* binding */ SortMode; },
/* harmony export */   "iU": function() { return /* binding */ SORT_MODES; }
/* harmony export */ });
/* unused harmony export Axis */
/* harmony import */ var _core_math_Module__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(27462);
/* harmony import */ var _poly_Assert__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(68239);
/* harmony import */ var _core_geometry_Constant__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(91568);
/* harmony import */ var _Base__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(82612);
/* harmony import */ var _engine_poly_InputCloneMode__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(56752);
/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(21410);
/* harmony import */ var _core_MapUtils__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(94158);
/* harmony import */ var _core_Type__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(19037);
/* harmony import */ var _core_SetUtils__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(55407);
/* harmony import */ var _core_geometry_entities_point_CorePointUtils__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(50253);
/* harmony import */ var _core_geometry_CoreObjectFactory__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(17353);













const tmpPos = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();
var SortMode = /* @__PURE__ */ ((SortMode2) => {
  SortMode2["RANDOM"] = "random";
  SortMode2["AXIS"] = "axis";
  SortMode2["ATTRIBUTE"] = "attribute";
  return SortMode2;
})(SortMode || {});
const SORT_MODES = ["axis" /* AXIS */, "random" /* RANDOM */, "attribute" /* ATTRIBUTE */];
const SORT_TARGET_TYPES = [_core_geometry_Constant__WEBPACK_IMPORTED_MODULE_1__/* .AttribClass.POINT */ .io.POINT, _core_geometry_Constant__WEBPACK_IMPORTED_MODULE_1__/* .AttribClass.OBJECT */ .io.OBJECT];
var Axis = /* @__PURE__ */ ((Axis2) => {
  Axis2["X"] = "x";
  Axis2["Y"] = "y";
  Axis2["Z"] = "z";
  return Axis2;
})(Axis || {});
const AXISES = ["x" /* X */, "y" /* Y */, "z" /* Z */];
const _points = [];
class SortSopOperation extends _Base__WEBPACK_IMPORTED_MODULE_2__/* .BaseSopOperation */ .U {
  constructor() {
    super(...arguments);
    this._pointPos = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();
    this._positions = [];
    this._indicesByPos = /* @__PURE__ */ new Map();
    this._indexDest = /* @__PURE__ */ new Map();
    this._debugActive = false;
  }
  static type() {
    return "sort";
  }
  cook(inputCoreGroups, params) {
    const coreGroup = inputCoreGroups[0];
    this._sort(coreGroup, params);
    return coreGroup;
  }
  _sort(coreGroup, params) {
    const targetType = SORT_TARGET_TYPES[params.targetType];
    switch (targetType) {
      case _core_geometry_Constant__WEBPACK_IMPORTED_MODULE_1__/* .AttribClass.POINT */ .io.POINT:
        return this._sortPoints(coreGroup, params);
      case _core_geometry_Constant__WEBPACK_IMPORTED_MODULE_1__/* .AttribClass.OBJECT */ .io.OBJECT:
        return this._sortObjects(coreGroup, params);
    }
  }
  _sortObjects(coreGroup, params) {
    const sortMode = SORT_MODES[params.mode];
    switch (sortMode) {
      case "axis" /* AXIS */:
        return this._sortObjectsByAxis(coreGroup, params);
      case "random" /* RANDOM */:
        return this._sortObjectsByRandom(coreGroup, params);
      case "attribute" /* ATTRIBUTE */:
        return this._sortObjectsByAttribute(coreGroup, params);
    }
    _poly_Assert__WEBPACK_IMPORTED_MODULE_3__/* .TypeAssert.unreachable */ .f.unreachable(sortMode);
  }
  _sortObjectsByAxis(coreGroup, params) {
    const coreObjects = coreGroup.allCoreObjects();
    const objectsByPos = /* @__PURE__ */ new Map();
    const positions = /* @__PURE__ */ new Set();
    const axis = AXISES[params.axis];
    let axisValue = 0;
    for (let coreObject of coreObjects) {
      coreObject.position(tmpPos);
      switch (axis) {
        case "x" /* X */: {
          axisValue = tmpPos.x;
          break;
        }
        case "y" /* Y */: {
          axisValue = tmpPos.y;
          break;
        }
        case "z" /* Z */: {
          axisValue = tmpPos.z;
          break;
        }
      }
      positions.add(axisValue);
      _core_MapUtils__WEBPACK_IMPORTED_MODULE_4__/* .MapUtils.pushOnArrayAtEntry */ .pl.pushOnArrayAtEntry(objectsByPos, axisValue, coreObject);
    }
    let sortedPositions = (0,_core_SetUtils__WEBPACK_IMPORTED_MODULE_5__/* .setToArray */ .T_)(positions, []).sort((a, b) => a - b);
    if ((0,_core_Type__WEBPACK_IMPORTED_MODULE_6__/* .isBooleanTrue */ .bI)(params.invert)) {
      sortedPositions.reverse();
    }
    const sortedObjects = [];
    for (let position of sortedPositions) {
      const coreObjectsForPosition = objectsByPos.get(position);
      if (coreObjectsForPosition) {
        for (let coreObjectForPosition of coreObjectsForPosition) {
          const object = coreObjectForPosition.object();
          if (object) {
            sortedObjects.push(object);
          }
        }
      }
    }
    coreGroup.setAllObjects(sortedObjects);
  }
  _sortObjectsByRandom(coreGroup, params) {
    const coreObjects = coreGroup.allCoreObjects();
    const objectsByPos = /* @__PURE__ */ new Map();
    const positions = [];
    let sortValue = 0;
    let i = 0;
    for (let coreObject of coreObjects) {
      sortValue = _core_math_Module__WEBPACK_IMPORTED_MODULE_7__/* .CoreMath.randFloat */ .Gj.randFloat(params.seed, i);
      positions[i] = sortValue;
      _core_MapUtils__WEBPACK_IMPORTED_MODULE_4__/* .MapUtils.pushOnArrayAtEntry */ .pl.pushOnArrayAtEntry(objectsByPos, sortValue, coreObject);
      i++;
    }
    let sortedPositions = positions.sort((a, b) => a - b);
    if (params.invert) {
      sortedPositions.reverse();
    }
    const sortedObjects = [];
    for (let position of sortedPositions) {
      const coreObjectsForPosition = objectsByPos.get(position);
      if (coreObjectsForPosition) {
        for (let coreObjectForPosition of coreObjectsForPosition) {
          const object = coreObjectForPosition.object();
          if (object) {
            sortedObjects.push(object);
          }
        }
      }
    }
    coreGroup.setAllObjects(sortedObjects);
  }
  _sortObjectsByAttribute(coreGroup, params) {
    const coreObjects = coreGroup.allCoreObjects();
    const objectsByAttribValue = /* @__PURE__ */ new Map();
    const attribValues = [];
    let i = 0;
    for (let coreObject of coreObjects) {
      const attribValue = coreObject.attribValue(params.attribute);
      const sortValue = (0,_core_Type__WEBPACK_IMPORTED_MODULE_6__/* .isNumber */ .hj)(attribValue) ? attribValue : 0;
      attribValues[i] = sortValue;
      _core_MapUtils__WEBPACK_IMPORTED_MODULE_4__/* .MapUtils.pushOnArrayAtEntry */ .pl.pushOnArrayAtEntry(objectsByAttribValue, sortValue, coreObject);
      i++;
    }
    let sortedValues = attribValues.sort((a, b) => a - b);
    if (params.invert) {
      sortedValues.reverse();
    }
    const sortedObjects = [];
    for (let sortedValue of sortedValues) {
      const coreObjectsForPosition = objectsByAttribValue.get(sortedValue);
      if (coreObjectsForPosition) {
        for (let coreObjectForPosition of coreObjectsForPosition) {
          const object = coreObjectForPosition.object();
          if (object) {
            sortedObjects.push(object);
          }
        }
      }
    }
    coreGroup.setAllObjects(sortedObjects);
  }
  _sortPoints(coreGroup, params) {
    const sortMode = SORT_MODES[params.mode];
    switch (sortMode) {
      case "axis" /* AXIS */:
        return this._sortPointsByAxis(coreGroup, params);
      case "random" /* RANDOM */:
        return this._sortPointsByRandom(coreGroup, params);
      case "attribute" /* ATTRIBUTE */:
        return this._sortPointsByAttribute(coreGroup, params);
    }
    _poly_Assert__WEBPACK_IMPORTED_MODULE_3__/* .TypeAssert.unreachable */ .f.unreachable(sortMode);
  }
  _sortPointsByAxis(coreGroup, params) {
    const objects = coreGroup.threejsObjectsWithGeo();
    for (let object of objects) {
      this._sortPointsForObject(object, params);
    }
  }
  _sortPointsByRandom(coreGroup, params) {
    var _a;
    (_a = this.states) == null ? void 0 : _a.error.set("sorting points in random mode is not yet implemented");
  }
  _sortPointsByAttribute(coreGroup, params) {
    var _a;
    (_a = this.states) == null ? void 0 : _a.error.set("sorting points by attribute is not yet implemented");
  }
  _debug(a) {
    if (!this._debugActive) {
      return;
    }
  }
  _sortPointsForObject(object, params) {
    (0,_core_geometry_entities_point_CorePointUtils__WEBPACK_IMPORTED_MODULE_8__/* .pointsFromObject */ .u_)(object, _points);
    const oldIndexAttribute = object.geometry.getIndex();
    if (!oldIndexAttribute) {
      console.warn("geometry cannot be sorted since it has no index");
      return;
    }
    const oldIndices = oldIndexAttribute.array;
    this._positions = new Array(_points.length);
    this._indicesByPos.clear();
    this._indexDest.clear();
    const axis = AXISES[params.axis];
    let axisValue = 0;
    let i = 0;
    for (let point of _points) {
      point.position(this._pointPos);
      switch (axis) {
        case "x" /* X */: {
          axisValue = this._pointPos.x;
          break;
        }
        case "y" /* Y */: {
          axisValue = this._pointPos.y;
          break;
        }
        case "z" /* Z */: {
          axisValue = this._pointPos.z;
          break;
        }
      }
      this._positions[i] = axisValue;
      _core_MapUtils__WEBPACK_IMPORTED_MODULE_4__/* .MapUtils.pushOnArrayAtEntry */ .pl.pushOnArrayAtEntry(this._indicesByPos, axisValue, point.index());
      i++;
    }
    let sortedPositions = this._positions.sort((a, b) => a - b);
    if (params.invert) {
      sortedPositions.reverse();
    }
    const newIndices = new Array(_points.length);
    i = 0;
    for (let position of sortedPositions) {
      const indices = this._indicesByPos.get(position);
      if (indices) {
        this._indicesByPos.delete(position);
        for (let index of indices) {
          newIndices[i] = index;
          this._indexDest.set(index, i);
          i++;
        }
      }
    }
    const newIndexAttrib = new Array(oldIndices.length);
    for (let i2 = 0; i2 < oldIndices.length; i2++) {
      const oldIndex = oldIndices[i2];
      const newI = this._indexDest.get(oldIndex);
      newIndexAttrib[i2] = newI;
    }
    object.geometry.setIndex(newIndexAttrib);
    const corePointClass = (0,_core_geometry_CoreObjectFactory__WEBPACK_IMPORTED_MODULE_9__/* .corePointClassFactory */ .E_)(object);
    const attributeNames = corePointClass.attributeNames(object);
    for (let attributeName of attributeNames) {
      if (attributeName == "id") {
        this._debugActive = true;
      }
      const attribute = object.geometry.getAttribute(attributeName);
      this._updateAttribute(attribute, newIndices);
      this._debugActive = false;
    }
  }
  _updateAttribute(attribute, newIndices) {
    const clonedAttribute = attribute.clone();
    const srcArray = attribute.array;
    const clonedArray = clonedAttribute.array;
    const itemSize = clonedAttribute.itemSize;
    this._debug(newIndices);
    for (let newIndex of newIndices) {
      const oldIndex = this._indexDest.get(newIndex);
      this._debug(`${newIndex} -> ${oldIndex}`);
      if (oldIndex != null) {
        for (let i = 0; i < itemSize; i++) {
          clonedArray[oldIndex * itemSize + i] = srcArray[newIndex * itemSize + i];
        }
      } else {
        console.warn("no old index found");
      }
    }
    attribute.array = clonedArray;
    attribute.needsUpdate = true;
  }
}
SortSopOperation.DEFAULT_PARAMS = {
  mode: SORT_MODES.indexOf("axis" /* AXIS */),
  targetType: SORT_TARGET_TYPES.indexOf(_core_geometry_Constant__WEBPACK_IMPORTED_MODULE_1__/* .AttribClass.POINT */ .io.POINT),
  seed: 0,
  axis: AXISES.indexOf("x" /* X */),
  attribute: "",
  invert: false
};
SortSopOperation.INPUT_CLONED_STATE = _engine_poly_InputCloneMode__WEBPACK_IMPORTED_MODULE_10__/* .InputCloneMode.FROM_NODE */ .m.FROM_NODE;


/***/ }),

/***/ 56431:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Sj": function() { return /* binding */ SPHERE_TYPE; },
/* harmony export */   "bH": function() { return /* binding */ SphereSopOperation; },
/* harmony export */   "k0": function() { return /* binding */ SPHERE_TYPES; }
/* harmony export */ });
/* harmony import */ var _Base__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(82612);
/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(21410);
/* harmony import */ var _engine_poly_InputCloneMode__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(56752);
/* harmony import */ var _core_BooleanValue__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(19037);
/* harmony import */ var _core_geometry_Constant__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(91568);
/* harmony import */ var _core_geometry_builders_SphereBuilder__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(26078);







const tmpBox = new three__WEBPACK_IMPORTED_MODULE_0__.Box3();
const tmpSize = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();
const tmpCenter = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();
var SphereType = /* @__PURE__ */ ((SphereType2) => {
  SphereType2["DEFAULT"] = "default";
  SphereType2["ISOCAHEDRON"] = "isocahedron";
  return SphereType2;
})(SphereType || {});
const SPHERE_TYPE = {
  default: 0,
  isocahedron: 1
};
const SPHERE_TYPES = ["default" /* DEFAULT */, "isocahedron" /* ISOCAHEDRON */];
class SphereSopOperation extends _Base__WEBPACK_IMPORTED_MODULE_1__/* .BaseSopOperation */ .U {
  static type() {
    return "sphere";
  }
  cook(inputCoreGroups, params) {
    const coreGroup = inputCoreGroups[0];
    const object = coreGroup ? this._cookWithInput(coreGroup, params) : this._cookWithoutInput(params);
    if (this._node) {
      object.name = this._node.name();
    }
    return this.createCoreGroupFromObjects([object]);
  }
  _cookWithoutInput(params) {
    const geometry = this._createRequiredGeometry(params);
    geometry.translate(params.center.x, params.center.y, params.center.z);
    const object = this._createSphereObject(geometry, params);
    return object;
  }
  _cookWithInput(coreGroup, params) {
    coreGroup.boundingBox(tmpBox);
    tmpBox.getSize(tmpSize);
    tmpBox.getCenter(tmpCenter);
    const geometry = this._createRequiredGeometry(params);
    geometry.scale(tmpSize.x, tmpSize.y, tmpSize.z);
    geometry.translate(params.center.x, params.center.y, params.center.z);
    geometry.translate(tmpCenter.x, tmpCenter.y, tmpCenter.z);
    const object = this._createSphereObject(geometry, params);
    return object;
  }
  _createSphereObject(geometry, params) {
    return _Base__WEBPACK_IMPORTED_MODULE_1__/* .BaseSopOperation.createObject */ .U.createObject(geometry, params.asLines ? _core_geometry_Constant__WEBPACK_IMPORTED_MODULE_2__/* .ObjectType.LINE_SEGMENTS */ .LP.LINE_SEGMENTS : _core_geometry_Constant__WEBPACK_IMPORTED_MODULE_2__/* .ObjectType.MESH */ .LP.MESH);
  }
  _createRequiredGeometry(params) {
    if (params.type == SPHERE_TYPE.default) {
      return this._createDefaultSphere(params);
    } else {
      return this._createDefaultIsocahedron(params);
    }
  }
  _createDefaultSphere(params) {
    const geometry = (0,_core_BooleanValue__WEBPACK_IMPORTED_MODULE_3__/* .isBooleanTrue */ .bI)(params.open) ? _core_geometry_builders_SphereBuilder__WEBPACK_IMPORTED_MODULE_4__/* .SphereBuilder.create */ .A.create({
      radius: params.radius,
      widthSegments: params.resolution.x,
      heightSegments: params.resolution.y,
      phiStart: params.phiStart,
      phiLength: params.phiLength,
      thetaStart: params.thetaStart,
      thetaLength: params.thetaLength,
      asLines: params.asLines,
      open: true
    }) : _core_geometry_builders_SphereBuilder__WEBPACK_IMPORTED_MODULE_4__/* .SphereBuilder.create */ .A.create({
      radius: params.radius,
      widthSegments: params.resolution.x,
      heightSegments: params.resolution.y,
      asLines: params.asLines,
      open: false
    });
    return geometry;
  }
  _createDefaultIsocahedron(params) {
    return new three__WEBPACK_IMPORTED_MODULE_0__.IcosahedronGeometry(params.radius, params.detail);
  }
}
SphereSopOperation.DEFAULT_PARAMS = {
  type: SPHERE_TYPE.default,
  radius: 1,
  resolution: new three__WEBPACK_IMPORTED_MODULE_0__.Vector2(30, 30),
  open: false,
  phiStart: 0,
  phiLength: Math.PI * 2,
  thetaStart: 0,
  thetaLength: Math.PI,
  detail: 1,
  center: new three__WEBPACK_IMPORTED_MODULE_0__.Vector3(0, 0, 0),
  asLines: false
};
SphereSopOperation.INPUT_CLONED_STATE = _engine_poly_InputCloneMode__WEBPACK_IMPORTED_MODULE_5__/* .InputCloneMode.NEVER */ .m.NEVER;


/***/ }),

/***/ 70388:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "LL": function() { return /* binding */ TangentSopOperation; },
/* harmony export */   "cG": function() { return /* binding */ TangentMode; },
/* harmony export */   "t3": function() { return /* binding */ TANGENT_MODES; }
/* harmony export */ });
/* harmony import */ var _Base__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(82612);
/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(21410);
/* harmony import */ var _poly_InputCloneMode__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(56752);
/* harmony import */ var _poly_registers_nodes_types_Sop__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(58986);
/* harmony import */ var _core_geometry_Attribute__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(32558);
/* harmony import */ var _core_geometry_Mask__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(58290);








var TangentMode = /* @__PURE__ */ ((TangentMode2) => {
  TangentMode2["MESH"] = "Normal Maps";
  TangentMode2["CURVE"] = "Curve";
  return TangentMode2;
})(TangentMode || {});
const TANGENT_MODES = ["Normal Maps" /* MESH */, "Curve" /* CURVE */];
const tangent = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();
const currentPosition = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();
const nextPosition = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();
const STRIDE = 3;
class TangentSopOperation extends _Base__WEBPACK_IMPORTED_MODULE_1__/* .BaseSopOperation */ .U {
  static type() {
    return _poly_registers_nodes_types_Sop__WEBPACK_IMPORTED_MODULE_2__/* .SopType.TANGENT */ .aB.TANGENT;
  }
  cook(inputCoreGroups, params) {
    const inputCoreGroup = inputCoreGroups[0];
    const objects = (0,_core_geometry_Mask__WEBPACK_IMPORTED_MODULE_3__/* .filterThreejsObjectsWithGroup */ .pb)(inputCoreGroup, params);
    return this._process(objects, params);
  }
  _process(objects, params) {
    const mode = TANGENT_MODES[params.mode];
    switch (mode) {
      case "Normal Maps" /* MESH */:
        return this._processForMesh(objects, params);
      case "Curve" /* CURVE */:
        return this._processForCurve(objects, params);
    }
  }
  _processForMesh(objects, params) {
    for (const object of objects) {
      const geometry = object.geometry;
      if (geometry) {
        geometry.computeTangents();
      }
    }
    return this.createCoreGroupFromObjects(objects);
  }
  _processForCurve(objects, params) {
    const newObjects = [];
    for (const object of objects) {
      const objectWithTangent = this._createTangentForCurve(object, params);
      if (objectWithTangent) {
        newObjects.push(objectWithTangent);
      }
    }
    return this.createCoreGroupFromObjects(newObjects);
  }
  _createTangentForCurve(object, params) {
    const { closed } = params;
    const tangentName = _core_geometry_Attribute__WEBPACK_IMPORTED_MODULE_4__/* .CoreAttribute.remapName */ .n0.remapName(params.tangentName);
    const geometry = object.geometry;
    if (!geometry) {
      return;
    }
    const positionAttribute = geometry.getAttribute(_core_geometry_Attribute__WEBPACK_IMPORTED_MODULE_4__/* .Attribute.POSITION */ .ah.POSITION);
    if (!positionAttribute) {
      return;
    }
    const positionArray = positionAttribute.array;
    const pointsCount = positionArray.length / STRIDE;
    let tangentAttribute = geometry.getAttribute(tangentName);
    if (!tangentAttribute) {
      const values = new Array(pointsCount * STRIDE).fill(1);
      geometry.setAttribute(tangentName, new three__WEBPACK_IMPORTED_MODULE_0__.Float32BufferAttribute(values, STRIDE));
      tangentAttribute = geometry.getAttribute(tangentName);
    }
    const tangentArray = tangentAttribute.array;
    for (let i = 0; i < pointsCount - 1; i++) {
      currentPosition.fromArray(positionArray, i * STRIDE);
      nextPosition.fromArray(positionArray, (i + 1) * STRIDE);
      tangent.copy(nextPosition).sub(currentPosition).normalize();
      tangent.toArray(tangentArray, i * STRIDE);
    }
    const lastIndex = pointsCount - 1;
    currentPosition.fromArray(positionArray, lastIndex * STRIDE);
    if (closed) {
      nextPosition.fromArray(positionArray, 0);
      tangent.copy(nextPosition).sub(currentPosition).normalize();
    } else {
      nextPosition.fromArray(positionArray, (lastIndex - 1) * STRIDE);
      tangent.copy(currentPosition).sub(nextPosition).normalize();
    }
    tangent.toArray(tangentArray, lastIndex * STRIDE);
    return object;
  }
}
TangentSopOperation.DEFAULT_PARAMS = {
  group: "*",
  mode: TANGENT_MODES.indexOf("Normal Maps" /* MESH */),
  closed: false,
  tangentName: "tangent"
};
TangentSopOperation.INPUT_CLONED_STATE = _poly_InputCloneMode__WEBPACK_IMPORTED_MODULE_5__/* .InputCloneMode.FROM_NODE */ .m.FROM_NODE;


/***/ }),

/***/ 66115:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "M": function() { return /* binding */ TubeSopOperation; }
/* harmony export */ });
/* harmony import */ var _Base__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(82612);
/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(21410);
/* harmony import */ var _core_Transform__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(87883);
/* harmony import */ var _engine_poly_InputCloneMode__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(56752);
/* harmony import */ var _core_Type__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(19037);






const DEFAULT_UP = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3(0, 1, 0);
class TubeSopOperation extends _Base__WEBPACK_IMPORTED_MODULE_1__/* .BaseSopOperation */ .U {
  static type() {
    return "tube";
  }
  cook(inputCoreGroups, params) {
    const radiusTop = params.singleRadius ? params.radius : params.radiusTop;
    const radiusBottom = params.singleRadius ? params.radius : params.radiusBottom;
    const geometry = (0,_core_Type__WEBPACK_IMPORTED_MODULE_2__/* .isBooleanTrue */ .bI)(params.open) ? new three__WEBPACK_IMPORTED_MODULE_0__.CylinderGeometry(
      radiusTop,
      radiusBottom,
      params.height,
      params.segmentsRadial,
      params.segmentsHeight,
      !(0,_core_Type__WEBPACK_IMPORTED_MODULE_2__/* .isBooleanTrue */ .bI)(params.cap),
      params.thetaStart,
      params.thetaLength
    ) : new three__WEBPACK_IMPORTED_MODULE_0__.CylinderGeometry(
      radiusTop,
      radiusBottom,
      params.height,
      params.segmentsRadial,
      params.segmentsHeight,
      !(0,_core_Type__WEBPACK_IMPORTED_MODULE_2__/* .isBooleanTrue */ .bI)(params.cap)
    );
    (0,_core_Transform__WEBPACK_IMPORTED_MODULE_3__/* .rotateGeometry */ .bP)(geometry, DEFAULT_UP, params.direction);
    geometry.translate(params.center.x, params.center.y, params.center.z);
    return this.createCoreGroupFromGeometry(geometry);
  }
}
TubeSopOperation.DEFAULT_PARAMS = {
  singleRadius: true,
  radius: 1,
  radiusTop: 1,
  radiusBottom: 1,
  height: 1,
  segmentsRadial: 12,
  segmentsHeight: 1,
  cap: true,
  center: new three__WEBPACK_IMPORTED_MODULE_0__.Vector3(0, 0, 0),
  direction: new three__WEBPACK_IMPORTED_MODULE_0__.Vector3(0, 0, 1),
  open: false,
  thetaStart: 0,
  thetaLength: Math.PI
};
TubeSopOperation.INPUT_CLONED_STATE = _engine_poly_InputCloneMode__WEBPACK_IMPORTED_MODULE_4__/* .InputCloneMode.NEVER */ .m.NEVER;


/***/ }),

/***/ 76057:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {


// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  "qp": function() { return /* binding */ UV_UNWRAP_METHODS; },
  "KG": function() { return /* binding */ UvUnwrapMethod; },
  "m2": function() { return /* binding */ UvUnwrapSopOperation; }
});

// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/operations/sop/_Base.ts
var _Base = __webpack_require__(82612);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/poly/InputCloneMode.ts
var InputCloneMode = __webpack_require__(56752);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/poly/registers/nodes/types/Sop.ts
var Sop = __webpack_require__(58986);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/node_modules/three/build/three.module.js
var three_module = __webpack_require__(21410);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/core/loader/common.ts
var common = __webpack_require__(18053);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/Poly.ts + 21 modules
var Poly = __webpack_require__(99934);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/core/loader/_Base.ts
var loader_Base = __webpack_require__(9683);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/core/UrlHelper.ts
var UrlHelper = __webpack_require__(51529);
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/core/loader/geometry/XAtlas.ts

var __async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};




class XAtlasLoaderHandler extends loader_Base/* CoreBaseLoader */.Su {
  // private static _module: XAtlasContainer | undefined;
  // private static _wasmUrl: string | undefined;
  // public static async xatlas(node: BaseNodeType) {
  // 	if (!this._module) {
  // 		await this._loadWasm({}, node);
  // 		// const wasmurl = new URL('./UvUnwrap/xatlas-web.wasm', import.meta.url);
  // 		// const wasmurl = new URL('../../../../node_modules/xatlas-web/dist/xatlas-web.wasm', import.meta.url);
  // 		// const wasmurl = new URL('xatlas-web/dist/xatlas-web.wasm', import.meta.url);
  // 		this._module = XAtlas({
  // 			locateFile: (path: string) => {
  // 				if (path.endsWith('.wasm')) {
  // 					return this._wasmUrl;
  // 				}
  // 				return path;
  // 			},
  // 		});
  // 	}
  // 	return this._module ? this._module.ready : undefined;
  // }
  static loadWasm(node) {
    return __async(this, null, function* () {
      const root = Poly/* Poly.libs.root */.L.libs.root();
      const XATLASPath = Poly/* Poly.libs.XATLASPath */.L.libs.XATLASPath();
      if (root || XATLASPath) {
        const decoderPath = (0,UrlHelper/* sanitizeUrl */.N)(`${root || ""}${XATLASPath || ""}/`);
        const fileNames = ["xatlas.wasm", "xatlas.js"];
        const fullUrls = fileNames.map((fileName) => {
          return {
            fullUrl: `${decoderPath}${fileName}`
          };
        });
        yield this._loadMultipleUrlsGlobal({
          files: fullUrls,
          node,
          error: `failed to load xatlas libraries. Make sure to install them use the uvUnwrap (${common/* LIBRARY_INSTALL_HINT */.u})`
        });
        const _addOrigin = (url) => {
          if (!url.startsWith("http")) {
            return `${window.location.origin}/${url}`;
          }
          return url;
        };
        return {
          wasm: _addOrigin((0,loader_Base/* modifyUrl */.d3)(fullUrls[0].fullUrl)),
          js: _addOrigin((0,loader_Base/* modifyUrl */.d3)(fullUrls[1].fullUrl))
        };
      }
    });
  }
}

// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/poly/Assert.ts
var Assert = __webpack_require__(68239);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/core/libs/Potpack.ts
var Potpack = __webpack_require__(9788);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/src/engine/nodes/cop/utils/lightMap/LightMapMaterial.ts
var LightMapMaterial = __webpack_require__(80478);
// EXTERNAL MODULE: ../@polygonjs/polygonjs/node_modules/xatlas-three/public/build/index.js
var build = __webpack_require__(12265);
;// CONCATENATED MODULE: ../@polygonjs/polygonjs/src/engine/operations/sop/UvUnwrap.ts

var UvUnwrap_async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};










var UvUnwrapMethod = /* @__PURE__ */ ((UvUnwrapMethod2) => {
  UvUnwrapMethod2["POTPACK"] = "potpack";
  UvUnwrapMethod2["XATLAS"] = "xatlas";
  return UvUnwrapMethod2;
})(UvUnwrapMethod || {});
const UV_UNWRAP_METHODS = [
  "xatlas" /* XATLAS */,
  // UvUnwrapMethod.XATLAS_2,
  "potpack" /* POTPACK */
];
const v1 = new three_module.Vector3();
const v2 = new three_module.Vector3();
const v3 = new three_module.Vector3();
const vMid = new three_module.Vector3();
const vEnd = new three_module.Vector3();
const line = new three_module.Line3();
class UvUnwrapSopOperation extends _Base/* BaseSopOperation */.U {
  static type() {
    return Sop/* SopType.UV_UNWRAP */.aB.UV_UNWRAP;
  }
  cook(inputCoreGroups, params) {
    return UvUnwrap_async(this, null, function* () {
      const method = UV_UNWRAP_METHODS[params.method];
      switch (method) {
        case "xatlas" /* XATLAS */: {
          return yield this._unwrapMeshUVsWithXAtlas2(inputCoreGroups, params);
        }
        case "potpack" /* POTPACK */: {
          return this._unwrapMeshUVsWithPotpack(inputCoreGroups, params);
        }
      }
      Assert/* TypeAssert.unreachable */.f.unreachable(method);
    });
  }
  _unwrapMeshUVsWithXAtlas2(inputCoreGroups, params) {
    return UvUnwrap_async(this, null, function* () {
      var _a, _b;
      const coreGroup = inputCoreGroups[0];
      const unwrapper = new build/* UVUnwrapper */.Q({ BufferAttribute: three_module.BufferAttribute });
      unwrapper.chartOptions = {
        fixWinding: false,
        maxBoundaryLength: 0,
        maxChartArea: 0,
        maxCost: 2,
        maxIterations: 1,
        normalDeviationWeight: 2,
        normalSeamWeight: 4,
        roundnessWeight: 0.009999999776482582,
        straightnessWeight: 6,
        textureSeamWeight: 0.5,
        useInputMeshUvs: false
      };
      unwrapper.packOptions = {
        bilinear: true,
        blockAlign: true,
        bruteForce: false,
        createImage: false,
        maxChartSize: 0,
        padding: params.padding,
        resolution: params.resolution,
        rotateCharts: true,
        rotateChartsToAxis: true,
        texelsPerUnit: 0
      };
      if (!this._node) {
        (_a = this.states) == null ? void 0 : _a.error.set("no node");
        return coreGroup;
      }
      const xatlasData = yield XAtlasLoaderHandler.loadWasm(this._node);
      if (!xatlasData) {
        (_b = this.states) == null ? void 0 : _b.error.set(`failed to load xatlas. Make sure this is installed. ${common/* LIBRARY_INSTALL_HINT */.u}`);
        return coreGroup;
      }
      yield unwrapper.loadLibrary(
        (mode, progress) => {
        },
        xatlasData.wasm,
        //'https://cdn.jsdelivr.net/npm/xatlasjs@0.1.0/dist/xatlas.wasm',
        xatlasData.js
        //'https://cdn.jsdelivr.net/npm/xatlasjs@0.1.0/dist/xatlas.js'
      );
      const objects = coreGroup.threejsObjectsWithGeo();
      for (let object of objects) {
        const mesh = object;
        if (mesh.isMesh) {
          yield unwrapper.packAtlas([mesh.geometry], params.uv);
        }
      }
      return coreGroup;
    });
  }
  // private async _unwrapMeshUVsWithXAtlas(inputCoreGroups: CoreGroup[], params: UvUnwrapSopParams) {
  // 	const coreGroup = inputCoreGroups[0];
  // 	if (!this._node) {
  // 		return coreGroup;
  // 	}
  // 	const xatlas = await XAtlasLoaderHandler.xatlas(this._node);
  // 	if (!xatlas) {
  // 		this.states?.error.set(`failed to load xatlas. Make sure this is installed. ${LIBRARY_INSTALL_HINT}`);
  // 		return coreGroup;
  // 	}
  // 	const objects = coreGroup.threejsObjectsWithGeo();
  // 	for (let object of objects) {
  // 		const mesh = object as Mesh;
  // 		if (mesh.isMesh) {
  // 			this._unwrapMeshUVsWithAtlas(xatlas, mesh, params);
  // 		}
  // 	}
  // 	return coreGroup;
  // }
  // private _unwrapMeshUVsWithAtlas(xatlas: XAtlasManager, mesh: Mesh, params: UvUnwrapSopParams) {
  // 	const geometry = mesh.geometry;
  // 	if (!geometry.index) {
  // 		return;
  // 	}
  // 	const originalVertexCount = geometry.attributes.position.count;
  // 	const originalIndexCount = geometry.index.count;
  // 	try {
  // 		xatlas.createAtlas();
  // 	} catch (err) {
  // 		this._node?.states.error.set('failed to create atlas');
  // 		return;
  // 	}
  // 	const meshInfo = xatlas.createMesh(originalVertexCount, originalIndexCount, true, true);
  // 	const index = geometry.getIndex();
  // 	const positionAttrib = geometry.getAttribute(Attribute.POSITION);
  // 	const normalAttrib = geometry.getAttribute(Attribute.NORMAL);
  // 	const uvAttrib = geometry.getAttribute(Attribute.UV);
  // 	if (!(index && positionAttrib && normalAttrib && uvAttrib)) {
  // 		this.states?.error.set(`the geometry needs to have an index, position, normal and uv attributes`);
  // 		return;
  // 	}
  // 	xatlas.HEAPU16.set(geometry.index.array, meshInfo.indexOffset / Uint16Array.BYTES_PER_ELEMENT);
  // 	xatlas.HEAPF32.set(
  // 		(geometry.attributes.position as BufferAttribute).array,
  // 		meshInfo.positionOffset / Float32Array.BYTES_PER_ELEMENT
  // 	);
  // 	xatlas.HEAPF32.set(
  // 		(geometry.attributes.normal as BufferAttribute).array,
  // 		meshInfo.normalOffset / Float32Array.BYTES_PER_ELEMENT
  // 	);
  // 	xatlas.HEAPF32.set(
  // 		(geometry.attributes.uv as BufferAttribute).array,
  // 		meshInfo.uvOffset / Float32Array.BYTES_PER_ELEMENT
  // 	);
  // 	const statusCode = xatlas.addMesh();
  // 	if (statusCode !== AddMeshStatus.Success) {
  // 		throw new Error(`UVUnwrapper: Error adding mesh. Status code ${statusCode}`);
  // 	}
  // 	// const chartOptions: ChartOptions = {
  // 	// 	fixWinding: true,
  // 	// 	maxBoundaryLength: 0,
  // 	// 	maxChartArea: 0,
  // 	// 	maxCost: 2,
  // 	// 	maxIterations: 1,
  // 	// 	normalDeviationWeight: 2,
  // 	// 	normalSeamWeight: 4,
  // 	// 	roundnessWeight: 0.009999999776482582,
  // 	// 	straightnessWeight: 6,
  // 	// 	textureSeamWeight: 0.5,
  // 	// 	useInputMeshUvs: false,
  // 	// };
  // 	// const packOptions: PackOptions = {
  // 	// 	bilinear: true,
  // 	// 	blockAlign: false,
  // 	// 	bruteForce: false,
  // 	// 	createImage: false,
  // 	// 	maxChartSize: 0,
  // 	// 	padding: 0,
  // 	// 	resolution: 0,
  // 	// 	rotateCharts: true,
  // 	// 	rotateChartsToAxis: true,
  // 	// 	texelsPerUnit: 0,
  // 	// };
  // 	// console.log({chartOptions, packOptions});
  // 	try {
  // 		xatlas.generateAtlas();
  // 	} catch (err) {
  // 		this._node?.states.error.set('failed to generate atlas');
  // 		console.log(err);
  // 		return;
  // 	}
  // 	const meshData = xatlas.getMeshData(meshInfo.meshId);
  // 	const oldPositionArray = (geometry.attributes.position as BufferAttribute).array;
  // 	const oldNormalArray = (geometry.attributes.normal as BufferAttribute).array;
  // 	const oldUvArray = (geometry.attributes.uv as BufferAttribute).array;
  // 	const newPositionArray = new Float32Array(meshData.newVertexCount * 3);
  // 	const newNormalArray = new Float32Array(meshData.newVertexCount * 3);
  // 	const newUvArray = new Float32Array(meshData.newVertexCount * 2);
  // 	const newUv2Array = new Float32Array(xatlas.HEAPF32.buffer, meshData.uvOffset, meshData.newVertexCount * 2);
  // 	const newIndexArray = new Uint32Array(xatlas.HEAPU32.buffer, meshData.indexOffset, meshData.newIndexCount);
  // 	const originalIndexArray = new Uint32Array(
  // 		xatlas.HEAPU32.buffer,
  // 		meshData.originalIndexOffset,
  // 		meshData.newVertexCount
  // 	);
  // 	for (let i = 0; i < meshData.newVertexCount; i++) {
  // 		const originalIndex = originalIndexArray[i];
  // 		// P
  // 		newPositionArray[i * 3] = oldPositionArray[originalIndex * 3];
  // 		newPositionArray[i * 3 + 1] = oldPositionArray[originalIndex * 3 + 1];
  // 		newPositionArray[i * 3 + 2] = oldPositionArray[originalIndex * 3 + 2];
  // 		// N
  // 		newNormalArray[i * 3] = oldNormalArray[originalIndex * 3];
  // 		newNormalArray[i * 3 + 1] = oldNormalArray[originalIndex * 3 + 1];
  // 		newNormalArray[i * 3 + 2] = oldNormalArray[originalIndex * 3 + 2];
  // 		// uv
  // 		newUvArray[i * 2] = oldUvArray[originalIndex * 2];
  // 		newUvArray[i * 2 + 1] = oldUvArray[originalIndex * 2 + 1];
  // 	}
  // 	// check inverted uvs (which face toward -z when set onto P)
  // 	// const pointsCount = newPositionArray.length / 3;
  // 	// const polyCount = newIndexArray.length / 3;
  // 	// const maxI = polyCount * 3;
  // 	// const uvLightmapFlipped: number[] = new Array(newPositionArray.length / 3).fill(-1);
  // 	// for (let i = 0; i < maxI; i += 3) {
  // 	// 	const i0 = newIndexArray[i];
  // 	// 	const i1 = newIndexArray[i + 1];
  // 	// 	const i2 = newIndexArray[i + 2];
  // 	// 	_uvTriangle.a.set(newUv2Array[i0 * 2], newUv2Array[i0 * 2 + 1], 0);
  // 	// 	_uvTriangle.b.set(newUv2Array[i1 * 2], newUv2Array[i1 * 2 + 1], 0);
  // 	// 	_uvTriangle.c.set(newUv2Array[i2 * 2], newUv2Array[i2 * 2 + 1], 0);
  // 	// 	_uvTriangle.getNormal(_uvTriangleN);
  // 	// 	const flipped = _uvTriangleN.z < 0 ? 1 : 0;
  // 	// 	// if (flipped) {
  // 	// 	// 	// newIndexArray[i] = i2;
  // 	// 	// 	// newIndexArray[i + 2] = i0;
  // 	// 	// 	// newUv2Array[i0 * 2] = _uvTriangle.c.x;
  // 	// 	// 	// newUv2Array[i0 * 2 + 1] = _uvTriangle.c.y;
  // 	// 	// 	// newUv2Array[i2 * 2] = _uvTriangle.a.x;
  // 	// 	// 	// newUv2Array[i2 * 2 + 1] = _uvTriangle.a.y;
  // 	// 	// }
  // 	// 	uvLightmapFlipped[i0] = flipped;
  // 	// 	uvLightmapFlipped[i1] = flipped;
  // 	// 	uvLightmapFlipped[i2] = flipped;
  // 	// 	// if (_uvTriangleN.z < 0) {
  // 	// 	// 	newNormalArray[i] *= -1;
  // 	// 	// 	newNormalArray[i + 1] *= -1;
  // 	// 	// 	newNormalArray[i + 2] *= -1;
  // 	// 	// }
  // 	// }
  // 	// for (let i = 0; i < pointsCount; i++) {
  // 	// 	const flipped = uvFlip[i];
  // 	// 	console.log(i, flipped);
  // 	// 	newNormalArray[i * 3] *= flipped;
  // 	// 	newNormalArray[i * 3 + 1] *= flipped;
  // 	// 	newNormalArray[i * 3 + 2] *= flipped;
  // 	// }
  // 	// create geo
  // 	const newGeometry = new BufferGeometry();
  // 	newGeometry.setAttribute('position', new Float32BufferAttribute(newPositionArray, 3));
  // 	newGeometry.setAttribute('normal', new Float32BufferAttribute(newNormalArray, 3));
  // 	if (params.uv != Attribute.UV) {
  // 		newGeometry.setAttribute('uv', new Float32BufferAttribute(newUvArray, 2));
  // 	}
  // 	newGeometry.setAttribute(params.uv, new Float32BufferAttribute(newUv2Array, 2));
  // 	// newGeometry.setAttribute(UV_LIGHT_MAP_FLIPPED_ATTRIB_NAME, new Float32BufferAttribute(uvLightmapFlipped, 1));
  // 	newGeometry.setIndex(new Uint32BufferAttribute(newIndexArray, 1));
  // 	mesh.geometry = newGeometry;
  // 	xatlas.destroyAtlas();
  // }
  _unwrapMeshUVsWithPotpack(inputCoreGroups, params) {
    const coreGroup = inputCoreGroups[0];
    const objects = coreGroup.threejsObjectsWithGeo();
    for (let object of objects) {
      const mesh = object;
      if (mesh.isMesh) {
        this._unwrapUVsWithPotpack(mesh, params);
      }
    }
    return coreGroup;
  }
  // TODO: at the moment each polygon will fix a single box
  // when ideally this should find when 2 triangles form a quad or square
  // and could then fit in the box
  _unwrapUVsWithPotpack(mesh, params) {
    var _a, _b, _c;
    const geometry = mesh.geometry;
    const indexArray = (_a = geometry.getIndex()) == null ? void 0 : _a.array;
    if (!indexArray) {
      return;
    }
    const positionArray = (_b = geometry.attributes.position) == null ? void 0 : _b.array;
    if (!positionArray) {
      return;
    }
    const uvArray = (_c = geometry.attributes["uv"]) == null ? void 0 : _c.array;
    if (!uvArray) {
      return;
    }
    const polyCount = indexArray.length / 3;
    const boxes = new Array(polyCount);
    for (let i = 0; i < polyCount; i++) {
      v1.fromArray(positionArray, 3 * indexArray[3 * i + 0]);
      v2.fromArray(positionArray, 3 * indexArray[3 * i + 1]);
      v3.fromArray(positionArray, 3 * indexArray[3 * i + 2]);
      let w = v1.distanceTo(v2);
      vMid.copy(v1).add(v2).multiplyScalar(0.5);
      line.start.copy(v3);
      line.end.copy(v3).add(v2).sub(v1);
      line.closestPointToPoint(vMid, false, vEnd);
      let h = vMid.distanceTo(vEnd);
      if (h < w) {
        const tmp = h;
        h = w;
        w = tmp;
      }
      boxes[i] = { w, h };
    }
    const result = (0,Potpack/* Potpack */.B)(boxes);
    const newUvValues = new Array(uvArray.length);
    for (let i = 0; i < polyCount; i++) {
      const box = boxes[i];
      const x = box.x / result.w;
      const y = box.y / result.h;
      const w = box.w / result.w;
      const h = box.h / result.h;
      const index0 = 2 * indexArray[i * 3 + 0];
      const index1 = 2 * indexArray[i * 3 + 1];
      const index2 = 2 * indexArray[i * 3 + 2];
      newUvValues[index0] = x;
      newUvValues[index0 + 1] = y;
      newUvValues[index1] = x + w;
      newUvValues[index1 + 1] = y;
      newUvValues[index2] = x;
      newUvValues[index2 + 1] = y + h;
    }
    geometry.setAttribute(params.uv, new three_module.Float32BufferAttribute(newUvValues, 2));
  }
}
UvUnwrapSopOperation.DEFAULT_PARAMS = {
  method: UV_UNWRAP_METHODS.indexOf("xatlas" /* XATLAS */),
  uv: LightMapMaterial/* DEFAULT_UV_LIGHT_MAP_ATTRIB_NAME */.hb,
  resolution: 2048,
  padding: 4
};
UvUnwrapSopOperation.INPUT_CLONED_STATE = InputCloneMode/* InputCloneMode.FROM_NODE */.m.FROM_NODE;


/***/ }),

/***/ 54816:
/***/ (function(__unused_webpack_module, __webpack_exports__) {

/* harmony default export */ __webpack_exports__["Z"] = ("#include <common>\n\nuniform vec2 resolution;\n\n// INSERT DEFINE\n\nvoid main() {\n\n\tvec4 diffuseColor = vec4(0.0,0.0,0.0,1.0);\n\n\n\t// INSERT BODY\n\n\tgl_FragColor = vec4( diffuseColor );\n}");

/***/ }),

/***/ 24744:
/***/ (function(__unused_webpack_module, __webpack_exports__) {

/* harmony default export */ __webpack_exports__["Z"] = ("void main()\t{\n\tgl_Position = vec4( position, 1.0 );\n}");

/***/ }),

/***/ 18361:
/***/ (function(__unused_webpack_module, __webpack_exports__) {

/* harmony default export */ __webpack_exports__["Z"] = ("// from https://github.com/williammalo/hsluv-glsl\n/*\nHSLUV-GLSL v4.2\nHSLUV is a human-friendly alternative to HSL. ( http://www.hsluv.org )\nGLSL port by William Malo ( https://github.com/williammalo )\nPut this code in your fragment shader.\n*/\n\nvec3 hsluv_intersectLineLine(vec3 line1x, vec3 line1y, vec3 line2x, vec3 line2y) {\n\treturn (line1y - line2y) / (line2x - line1x);\n}\n\nvec3 hsluv_distanceFromPole(vec3 pointx,vec3 pointy) {\n\treturn sqrt(pointx*pointx + pointy*pointy);\n}\n\nvec3 hsluv_lengthOfRayUntilIntersect(float theta, vec3 x, vec3 y) {\n\tvec3 len = y / (sin(theta) - x * cos(theta));\n\tif (len.r < 0.0) {len.r=1000.0;}\n\tif (len.g < 0.0) {len.g=1000.0;}\n\tif (len.b < 0.0) {len.b=1000.0;}\n\treturn len;\n}\n\nfloat hsluv_maxSafeChromaForL(float L){\n\tmat3 m2 = mat3(\n\t\t 3.2409699419045214  ,-0.96924363628087983 , 0.055630079696993609,\n\t\t-1.5373831775700935  , 1.8759675015077207  ,-0.20397695888897657 ,\n\t\t-0.49861076029300328 , 0.041555057407175613, 1.0569715142428786  \n\t);\n\tfloat sub0 = L + 16.0;\n\tfloat sub1 = sub0 * sub0 * sub0 * .000000641;\n\tfloat sub2 = sub1 > 0.0088564516790356308 ? sub1 : L / 903.2962962962963;\n\n\tvec3 top1   = (284517.0 * m2[0] - 94839.0  * m2[2]) * sub2;\n\tvec3 bottom = (632260.0 * m2[2] - 126452.0 * m2[1]) * sub2;\n\tvec3 top2   = (838422.0 * m2[2] + 769860.0 * m2[1] + 731718.0 * m2[0]) * L * sub2;\n\n\tvec3 bounds0x = top1 / bottom;\n\tvec3 bounds0y = top2 / bottom;\n\n\tvec3 bounds1x =              top1 / (bottom+126452.0);\n\tvec3 bounds1y = (top2-769860.0*L) / (bottom+126452.0);\n\n\tvec3 xs0 = hsluv_intersectLineLine(bounds0x, bounds0y, -1.0/bounds0x, vec3(0.0) );\n\tvec3 xs1 = hsluv_intersectLineLine(bounds1x, bounds1y, -1.0/bounds1x, vec3(0.0) );\n\n\tvec3 lengths0 = hsluv_distanceFromPole( xs0, bounds0y + xs0 * bounds0x );\n\tvec3 lengths1 = hsluv_distanceFromPole( xs1, bounds1y + xs1 * bounds1x );\n\n\treturn  min(lengths0.r,\n\t\t\tmin(lengths1.r,\n\t\t\tmin(lengths0.g,\n\t\t\tmin(lengths1.g,\n\t\t\tmin(lengths0.b,\n\t\t\t\tlengths1.b)))));\n}\n\nfloat hsluv_maxChromaForLH(float L, float H) {\n\n\tfloat hrad = radians(H);\n\n\tmat3 m2 = mat3(\n\t\t 3.2409699419045214  ,-0.96924363628087983 , 0.055630079696993609,\n\t\t-1.5373831775700935  , 1.8759675015077207  ,-0.20397695888897657 ,\n\t\t-0.49861076029300328 , 0.041555057407175613, 1.0569715142428786  \n\t);\n\tfloat sub1 = pow(L + 16.0, 3.0) / 1560896.0;\n\tfloat sub2 = sub1 > 0.0088564516790356308 ? sub1 : L / 903.2962962962963;\n\n\tvec3 top1   = (284517.0 * m2[0] - 94839.0  * m2[2]) * sub2;\n\tvec3 bottom = (632260.0 * m2[2] - 126452.0 * m2[1]) * sub2;\n\tvec3 top2   = (838422.0 * m2[2] + 769860.0 * m2[1] + 731718.0 * m2[0]) * L * sub2;\n\n\tvec3 bound0x = top1 / bottom;\n\tvec3 bound0y = top2 / bottom;\n\n\tvec3 bound1x =              top1 / (bottom+126452.0);\n\tvec3 bound1y = (top2-769860.0*L) / (bottom+126452.0);\n\n\tvec3 lengths0 = hsluv_lengthOfRayUntilIntersect(hrad, bound0x, bound0y );\n\tvec3 lengths1 = hsluv_lengthOfRayUntilIntersect(hrad, bound1x, bound1y );\n\n\treturn  min(lengths0.r,\n\t\t\tmin(lengths1.r,\n\t\t\tmin(lengths0.g,\n\t\t\tmin(lengths1.g,\n\t\t\tmin(lengths0.b,\n\t\t\t\tlengths1.b)))));\n}\n\nfloat hsluv_fromLinear(float c) {\n\treturn c <= 0.0031308 ? 12.92 * c : 1.055 * pow(c, 1.0 / 2.4) - 0.055;\n}\nvec3 hsluv_fromLinear(vec3 c) {\n\treturn vec3( hsluv_fromLinear(c.r), hsluv_fromLinear(c.g), hsluv_fromLinear(c.b) );\n}\n\nfloat hsluv_toLinear(float c) {\n\treturn c > 0.04045 ? pow((c + 0.055) / (1.0 + 0.055), 2.4) : c / 12.92;\n}\n\nvec3 hsluv_toLinear(vec3 c) {\n\treturn vec3( hsluv_toLinear(c.r), hsluv_toLinear(c.g), hsluv_toLinear(c.b) );\n}\n\nfloat hsluv_yToL(float Y){\n\treturn Y <= 0.0088564516790356308 ? Y * 903.2962962962963 : 116.0 * pow(Y, 1.0 / 3.0) - 16.0;\n}\n\nfloat hsluv_lToY(float L) {\n\treturn L <= 8.0 ? L / 903.2962962962963 : pow((L + 16.0) / 116.0, 3.0);\n}\n\nvec3 xyzToRgb(vec3 tuple) {\n\tconst mat3 m = mat3( \n\t\t3.2409699419045214  ,-1.5373831775700935 ,-0.49861076029300328 ,\n\t\t-0.96924363628087983 , 1.8759675015077207 , 0.041555057407175613,\n\t\t0.055630079696993609,-0.20397695888897657, 1.0569715142428786  );\n\t\n\treturn hsluv_fromLinear(tuple*m);\n}\n\nvec3 rgbToXyz(vec3 tuple) {\n\tconst mat3 m = mat3(\n\t\t0.41239079926595948 , 0.35758433938387796, 0.18048078840183429 ,\n\t\t0.21263900587151036 , 0.71516867876775593, 0.072192315360733715,\n\t\t0.019330818715591851, 0.11919477979462599, 0.95053215224966058 \n\t);\n\treturn hsluv_toLinear(tuple) * m;\n}\n\nvec3 xyzToLuv(vec3 tuple){\n\tfloat X = tuple.x;\n\tfloat Y = tuple.y;\n\tfloat Z = tuple.z;\n\n\tfloat L = hsluv_yToL(Y);\n\t\n\tfloat div = 1./dot(tuple,vec3(1,15,3)); \n\n\treturn vec3(\n\t\t1.,\n\t\t(52. * (X*div) - 2.57179),\n\t\t(117.* (Y*div) - 6.08816)\n\t) * L;\n}\n\n\nvec3 luvToXyz(vec3 tuple) {\n\tfloat L = tuple.x;\n\n\tfloat U = tuple.y / (13.0 * L) + 0.19783000664283681;\n\tfloat V = tuple.z / (13.0 * L) + 0.468319994938791;\n\n\tfloat Y = hsluv_lToY(L);\n\tfloat X = 2.25 * U * Y / V;\n\tfloat Z = (3./V - 5.)*Y - (X/3.);\n\n\treturn vec3(X, Y, Z);\n}\n\nvec3 luvToLch(vec3 tuple) {\n\tfloat L = tuple.x;\n\tfloat U = tuple.y;\n\tfloat V = tuple.z;\n\n\tfloat C = length(tuple.yz);\n\tfloat H = degrees(atan(V,U));\n\tif (H < 0.0) {\n\t\tH = 360.0 + H;\n\t}\n\t\n\treturn vec3(L, C, H);\n}\n\nvec3 lchToLuv(vec3 tuple) {\n\tfloat hrad = radians(tuple.b);\n\treturn vec3(\n\t\ttuple.r,\n\t\tcos(hrad) * tuple.g,\n\t\tsin(hrad) * tuple.g\n\t);\n}\n\nvec3 hsluvToLch(vec3 tuple) {\n\ttuple.g *= hsluv_maxChromaForLH(tuple.b, tuple.r) * .01;\n\treturn tuple.bgr;\n}\n\nvec3 lchToHsluv(vec3 tuple) {\n\ttuple.g /= hsluv_maxChromaForLH(tuple.r, tuple.b) * .01;\n\treturn tuple.bgr;\n}\n\nvec3 hpluvToLch(vec3 tuple) {\n\ttuple.g *= hsluv_maxSafeChromaForL(tuple.b) * .01;\n\treturn tuple.bgr;\n}\n\nvec3 lchToHpluv(vec3 tuple) {\n\ttuple.g /= hsluv_maxSafeChromaForL(tuple.r) * .01;\n\treturn tuple.bgr;\n}\n\nvec3 lchToRgb(vec3 tuple) {\n\treturn xyzToRgb(luvToXyz(lchToLuv(tuple)));\n}\n\nvec3 rgbToLch(vec3 tuple) {\n\treturn luvToLch(xyzToLuv(rgbToXyz(tuple)));\n}\n\nvec3 hsluvToRgb(vec3 tuple) {\n\treturn lchToRgb(hsluvToLch(tuple));\n}\n\nvec3 rgbToHsluv(vec3 tuple) {\n\treturn lchToHsluv(rgbToLch(tuple));\n}\n\nvec3 hpluvToRgb(vec3 tuple) {\n\treturn lchToRgb(hpluvToLch(tuple));\n}\n\nvec3 rgbToHpluv(vec3 tuple) {\n\treturn lchToHpluv(rgbToLch(tuple));\n}\n\nvec3 luvToRgb(vec3 tuple){\n\treturn xyzToRgb(luvToXyz(tuple));\n}\n\n// allow vec4's\nvec4   xyzToRgb(vec4 c) {return vec4(   xyzToRgb( vec3(c.x,c.y,c.z) ), c.a);}\nvec4   rgbToXyz(vec4 c) {return vec4(   rgbToXyz( vec3(c.x,c.y,c.z) ), c.a);}\nvec4   xyzToLuv(vec4 c) {return vec4(   xyzToLuv( vec3(c.x,c.y,c.z) ), c.a);}\nvec4   luvToXyz(vec4 c) {return vec4(   luvToXyz( vec3(c.x,c.y,c.z) ), c.a);}\nvec4   luvToLch(vec4 c) {return vec4(   luvToLch( vec3(c.x,c.y,c.z) ), c.a);}\nvec4   lchToLuv(vec4 c) {return vec4(   lchToLuv( vec3(c.x,c.y,c.z) ), c.a);}\nvec4 hsluvToLch(vec4 c) {return vec4( hsluvToLch( vec3(c.x,c.y,c.z) ), c.a);}\nvec4 lchToHsluv(vec4 c) {return vec4( lchToHsluv( vec3(c.x,c.y,c.z) ), c.a);}\nvec4 hpluvToLch(vec4 c) {return vec4( hpluvToLch( vec3(c.x,c.y,c.z) ), c.a);}\nvec4 lchToHpluv(vec4 c) {return vec4( lchToHpluv( vec3(c.x,c.y,c.z) ), c.a);}\nvec4   lchToRgb(vec4 c) {return vec4(   lchToRgb( vec3(c.x,c.y,c.z) ), c.a);}\nvec4   rgbToLch(vec4 c) {return vec4(   rgbToLch( vec3(c.x,c.y,c.z) ), c.a);}\nvec4 hsluvToRgb(vec4 c) {return vec4( hsluvToRgb( vec3(c.x,c.y,c.z) ), c.a);}\nvec4 rgbToHsluv(vec4 c) {return vec4( rgbToHsluv( vec3(c.x,c.y,c.z) ), c.a);}\nvec4 hpluvToRgb(vec4 c) {return vec4( hpluvToRgb( vec3(c.x,c.y,c.z) ), c.a);}\nvec4 rgbToHpluv(vec4 c) {return vec4( rgbToHpluv( vec3(c.x,c.y,c.z) ), c.a);}\nvec4   luvToRgb(vec4 c) {return vec4(   luvToRgb( vec3(c.x,c.y,c.z) ), c.a);}\n// allow 3 floats\nvec3   xyzToRgb(float x, float y, float z) {return   xyzToRgb( vec3(x,y,z) );}\nvec3   rgbToXyz(float x, float y, float z) {return   rgbToXyz( vec3(x,y,z) );}\nvec3   xyzToLuv(float x, float y, float z) {return   xyzToLuv( vec3(x,y,z) );}\nvec3   luvToXyz(float x, float y, float z) {return   luvToXyz( vec3(x,y,z) );}\nvec3   luvToLch(float x, float y, float z) {return   luvToLch( vec3(x,y,z) );}\nvec3   lchToLuv(float x, float y, float z) {return   lchToLuv( vec3(x,y,z) );}\nvec3 hsluvToLch(float x, float y, float z) {return hsluvToLch( vec3(x,y,z) );}\nvec3 lchToHsluv(float x, float y, float z) {return lchToHsluv( vec3(x,y,z) );}\nvec3 hpluvToLch(float x, float y, float z) {return hpluvToLch( vec3(x,y,z) );}\nvec3 lchToHpluv(float x, float y, float z) {return lchToHpluv( vec3(x,y,z) );}\nvec3   lchToRgb(float x, float y, float z) {return   lchToRgb( vec3(x,y,z) );}\nvec3   rgbToLch(float x, float y, float z) {return   rgbToLch( vec3(x,y,z) );}\nvec3 hsluvToRgb(float x, float y, float z) {return hsluvToRgb( vec3(x,y,z) );}\nvec3 rgbToHsluv(float x, float y, float z) {return rgbToHsluv( vec3(x,y,z) );}\nvec3 hpluvToRgb(float x, float y, float z) {return hpluvToRgb( vec3(x,y,z) );}\nvec3 rgbToHpluv(float x, float y, float z) {return rgbToHpluv( vec3(x,y,z) );}\nvec3   luvToRgb(float x, float y, float z) {return   luvToRgb( vec3(x,y,z) );}\n// allow 4 floats\nvec4   xyzToRgb(float x, float y, float z, float a) {return   xyzToRgb( vec4(x,y,z,a) );}\nvec4   rgbToXyz(float x, float y, float z, float a) {return   rgbToXyz( vec4(x,y,z,a) );}\nvec4   xyzToLuv(float x, float y, float z, float a) {return   xyzToLuv( vec4(x,y,z,a) );}\nvec4   luvToXyz(float x, float y, float z, float a) {return   luvToXyz( vec4(x,y,z,a) );}\nvec4   luvToLch(float x, float y, float z, float a) {return   luvToLch( vec4(x,y,z,a) );}\nvec4   lchToLuv(float x, float y, float z, float a) {return   lchToLuv( vec4(x,y,z,a) );}\nvec4 hsluvToLch(float x, float y, float z, float a) {return hsluvToLch( vec4(x,y,z,a) );}\nvec4 lchToHsluv(float x, float y, float z, float a) {return lchToHsluv( vec4(x,y,z,a) );}\nvec4 hpluvToLch(float x, float y, float z, float a) {return hpluvToLch( vec4(x,y,z,a) );}\nvec4 lchToHpluv(float x, float y, float z, float a) {return lchToHpluv( vec4(x,y,z,a) );}\nvec4   lchToRgb(float x, float y, float z, float a) {return   lchToRgb( vec4(x,y,z,a) );}\nvec4   rgbToLch(float x, float y, float z, float a) {return   rgbToLch( vec4(x,y,z,a) );}\nvec4 hsluvToRgb(float x, float y, float z, float a) {return hsluvToRgb( vec4(x,y,z,a) );}\nvec4 rgbToHslul(float x, float y, float z, float a) {return rgbToHsluv( vec4(x,y,z,a) );}\nvec4 hpluvToRgb(float x, float y, float z, float a) {return hpluvToRgb( vec4(x,y,z,a) );}\nvec4 rgbToHpluv(float x, float y, float z, float a) {return rgbToHpluv( vec4(x,y,z,a) );}\nvec4   luvToRgb(float x, float y, float z, float a) {return   luvToRgb( vec4(x,y,z,a) );}\n\n/*\nEND HSLUV-GLSL\n*/\n\n\n// from https://gist.github.com/mattatz/44f081cac87e2f7c8980\n// converted to glsl by gui@polygonjs.com\n// and made function names consistent with the ones above\n/*\n * Conversion between RGB and LAB colorspace.\n * Import from flowabs glsl program : https://code.google.com/p/flowabs/source/browse/glsl/?r=f36cbdcf7790a28d90f09e2cf89ec9a64911f138\n */\n\n\n\nvec3 xyzToLab( vec3 c ) {\n\tvec3 n = c / vec3(95.047, 100, 108.883);\n\tvec3 v;\n\tv.x = ( n.x > 0.008856 ) ? pow( n.x, 1.0 / 3.0 ) : ( 7.787 * n.x ) + ( 16.0 / 116.0 );\n\tv.y = ( n.y > 0.008856 ) ? pow( n.y, 1.0 / 3.0 ) : ( 7.787 * n.y ) + ( 16.0 / 116.0 );\n\tv.z = ( n.z > 0.008856 ) ? pow( n.z, 1.0 / 3.0 ) : ( 7.787 * n.z ) + ( 16.0 / 116.0 );\n\treturn vec3(( 116.0 * v.y ) - 16.0, 500.0 * ( v.x - v.y ), 200.0 * ( v.y - v.z ));\n}\n\nvec3 rgbToLab( vec3 c ) {\n\tvec3 lab = xyzToLab( rgbToXyz( c ) );\n\treturn vec3( lab.x / 100.0, 0.5 + 0.5 * ( lab.y / 127.0 ), 0.5 + 0.5 * ( lab.z / 127.0 ));\n}\n\nvec3 labToXyz( vec3 c ) {\n\tfloat fy = ( c.x + 16.0 ) / 116.0;\n\tfloat fx = c.y / 500.0 + fy;\n\tfloat fz = fy - c.z / 200.0;\n\treturn vec3(\n\t\t 95.047 * (( fx > 0.206897 ) ? fx * fx * fx : ( fx - 16.0 / 116.0 ) / 7.787),\n\t\t100.000 * (( fy > 0.206897 ) ? fy * fy * fy : ( fy - 16.0 / 116.0 ) / 7.787),\n\t\t108.883 * (( fz > 0.206897 ) ? fz * fz * fz : ( fz - 16.0 / 116.0 ) / 7.787)\n\t);\n}\n\n\n\nvec3 labToRgb( vec3 c ) {\n\treturn xyzToRgb( labToXyz( vec3(100.0 * c.x, 2.0 * 127.0 * (c.y - 0.5), 2.0 * 127.0 * (c.z - 0.5)) ) );\n}\n\n// adapted from\n// THREEjs math/Color.js\nfloat sRGBToLinear( float c ) {\n\treturn ( c < 0.04045 ) ? c * 0.0773993808 : pow( c * 0.9478672986 + 0.0521327014, 2.4 );\n}\nvec3 sRGBToLinear( vec3 c ) {\n\treturn vec3( sRGBToLinear(c.r), sRGBToLinear(c.g), sRGBToLinear(c.b) );\n}\nvec4 sRGBToLinear( vec4 c ) {\n\treturn vec4( sRGBToLinear(c.r), sRGBToLinear(c.g), sRGBToLinear(c.b), c.a );\n}");

/***/ }),

/***/ 94077:
/***/ (function(__unused_webpack_module, __webpack_exports__) {

/* harmony default export */ __webpack_exports__["Z"] = ("// get vec2 tex coordinate from index\nvec2 geometryAttributesLookupUv( float id, vec2 textureSize ) { \n\tfloat idRounded = round( id );\n\n\tvec2 coords = vec2(\n\t\tmod( ( idRounded ), textureSize.x ),\n\t\tfloor( ( idRounded ) / textureSize.x )\n\t) + 0.5;\n\n\n\treturn coords / textureSize;\n\n}\n");

/***/ }),

/***/ 914:
/***/ (function(__unused_webpack_module, __webpack_exports__) {

/* harmony default export */ __webpack_exports__["Z"] = ("\n/*\nSDF Repeat in cartesian coordinates\n*/\nfloat SDFRepeat( in float p, in float c )\n{\n\treturn mod(p+0.5*c,c)-0.5*c;\n}\nfloat SDFRepeatClamped( in float p, in float c, in float boundMin, in float boundMax )\n{\n\treturn p-c*clamp(round(p/c),boundMin,boundMax);\n}\nvec3 SDFRepeat( in vec3 p, in vec3 c )\n{\n\treturn mod(p+0.5*c,c)-0.5*c;\n}\nvec3 SDFRepeatClamped( in vec3 p, in vec3 c, in vec3 boundMin, in vec3 boundMax )\n{\n\treturn p-c*clamp(round(p/c),boundMin,boundMax);\n}\nvec3 SDFRepeatClampedX( in vec3 p, in vec3 c, in float boundMin, in float boundMax )\n{\n\treturn vec3(\n\t\tSDFRepeatClamped(p.x, c.x, boundMin, boundMax),\n\t\tSDFRepeat(p.y, c.y),\n\t\tSDFRepeat(p.z, c.z)\n\t);\n}\nvec3 SDFRepeatClampedY( in vec3 p, in vec3 c, in float boundMin, in float boundMax )\n{\n\treturn vec3(\n\t\tSDFRepeat(p.x, c.x),\n\t\tSDFRepeatClamped(p.y, c.y, boundMin, boundMax),\n\t\tSDFRepeat(p.z, c.z)\n\t);\n}\nvec3 SDFRepeatClampedZ( in vec3 p, in vec3 c, in float boundMin, in float boundMax )\n{\n\treturn vec3(\n\t\tSDFRepeat(p.x, c.x),\n\t\tSDFRepeat(p.y, c.y),\n\t\tSDFRepeatClamped(p.z, c.z, boundMin, boundMax)\n\t);\n}\nvec3 SDFRepeatClampedXY( in vec3 p, in vec3 c, in vec2 boundMin, in vec2 boundMax )\n{\n\treturn vec3(\n\t\tSDFRepeatClamped(p.x, c.x, boundMin.x, boundMax.x),\n\t\tSDFRepeatClamped(p.y, c.y, boundMin.y, boundMax.y),\n\t\tSDFRepeat(p.z, c.z)\n\t);\n}\nvec3 SDFRepeatClampedXZ( in vec3 p, in vec3 c, in vec2 boundMin, in vec2 boundMax )\n{\n\treturn vec3(\n\t\tSDFRepeatClamped(p.x, c.x, boundMin.x, boundMax.x),\n\t\tSDFRepeat(p.y, c.y),\n\t\tSDFRepeatClamped(p.z, c.z, boundMin.y, boundMax.y)\n\t);\n}\nvec3 SDFRepeatClampedYZ( in vec3 p, in vec3 c, in vec2 boundMin, in vec2 boundMax )\n{\n\treturn vec3(\n\t\tSDFRepeat(p.x, c.x),\n\t\tSDFRepeatClamped(p.y, c.y, boundMin.x, boundMax.x),\n\t\tSDFRepeatClamped(p.z, c.z, boundMin.y, boundMax.y)\n\t);\n}\nvec3 SDFRepeatX( in vec3 p, in vec3 c ){\n\treturn vec3(\n\t\tSDFRepeat(p.x, c.x),\n\t\tp.yz\n\t);\n}\nvec3 SDFRepeatXClampedX( in vec3 p, in vec3 c, in float boundMin, in float boundMax ){\n\treturn vec3(\n\t\tSDFRepeatClamped(p.x, c.x, boundMin, boundMax),\n\t\tp.yz\n\t);\n}\nvec3 SDFRepeatY( in vec3 p, in vec3 c ){\n\treturn vec3(\n\t\tp.x,\n\t\tSDFRepeat(p.y, c.y),\n\t\tp.z\n\t);\n}\nvec3 SDFRepeatYClampedY( in vec3 p, in vec3 c, in float boundMin, in float boundMax ){\n\treturn vec3(\n\t\tp.x,\n\t\tSDFRepeatClamped(p.y, c.y, boundMin, boundMax),\n\t\tp.z\n\t);\n}\nvec3 SDFRepeatZ( in vec3 p, in vec3 c ){\n\treturn vec3(\n\t\tp.xy,\n\t\tSDFRepeat(p.z, c.z)\n\t);\n}\nvec3 SDFRepeatZClampedZ( in vec3 p, in vec3 c, in float boundMin, in float boundMax ){\n\treturn vec3(\n\t\tp.xy,\n\t\tSDFRepeatClamped(p.z, c.z, boundMin, boundMax)\n\t);\n}\nvec3 SDFRepeatXY( in vec3 p, in vec3 c ){\n\treturn vec3(\n\t\tSDFRepeat(p.x, c.x),\n\t\tSDFRepeat(p.y, c.y),\n\t\tp.z\n\t);\n}\nvec3 SDFRepeatXYClampedX( in vec3 p, in vec3 c, in float boundMin, in float boundMax ){\n\treturn vec3(\n\t\tSDFRepeatClamped(p.x, c.x, boundMin, boundMax),\n\t\tSDFRepeat(p.y, c.y),\n\t\tp.z\n\t);\n}\nvec3 SDFRepeatXYClampedY( in vec3 p, in vec3 c, in float boundMin, in float boundMax ){\n\treturn vec3(\n\t\tSDFRepeat(p.x, c.x),\n\t\tSDFRepeatClamped(p.y, c.y, boundMin, boundMax),\n\t\tp.z\n\t);\n}\nvec3 SDFRepeatXYClampedXY( in vec3 p, in vec3 c, in vec2 boundMin, in vec2 boundMax ){\n\treturn vec3(\n\t\tSDFRepeatClamped(p.x, c.x, boundMin.x, boundMax.x),\n\t\tSDFRepeatClamped(p.y, c.y, boundMin.y, boundMax.y),\n\t\tp.z\n\t);\n}\nvec3 SDFRepeatXZ( in vec3 p, in vec3 c ){\n\treturn vec3(\n\t\tSDFRepeat(p.x, c.x),\n\t\tp.y,\n\t\tSDFRepeat(p.z, c.z)\n\t);\n}\nvec3 SDFRepeatXZClampedX( in vec3 p, in vec3 c, in float boundMin, in float boundMax ){\n\treturn vec3(\n\t\tSDFRepeatClamped(p.x, c.x, boundMin, boundMax),\n\t\tp.y,\n\t\tSDFRepeat(p.z, c.z)\n\t);\n}\nvec3 SDFRepeatXZClampedZ( in vec3 p, in vec3 c, in float boundMin, in float boundMax ){\n\treturn vec3(\n\t\tSDFRepeat(p.x, c.x),\n\t\tp.y,\n\t\tSDFRepeatClamped(p.z, c.z, boundMin, boundMax)\n\t);\n}\nvec3 SDFRepeatXZClampedXZ( in vec3 p, in vec3 c, in vec2 boundMin, in vec2 boundMax ){\n\treturn vec3(\n\t\tSDFRepeatClamped(p.x, c.x, boundMin.x, boundMax.x),\n\t\tp.y,\n\t\tSDFRepeatClamped(p.z, c.z, boundMin.y, boundMax.y)\n\t);\n}\nvec3 SDFRepeatYZ( in vec3 p, in vec3 c ){\n\treturn vec3(\n\t\tp.x,\n\t\tSDFRepeat(p.y, c.y),\n\t\tSDFRepeat(p.z, c.z)\n\t);\n}\nvec3 SDFRepeatYZClampedY( in vec3 p, in vec3 c, in float boundMin, in float boundMax ){\n\treturn vec3(\n\t\tp.x,\n\t\tSDFRepeatClamped(p.y, c.y, boundMin, boundMax),\n\t\tSDFRepeat(p.z, c.z)\n\t);\n}\nvec3 SDFRepeatYZClampedZ( in vec3 p, in vec3 c, in float boundMin, in float boundMax ){\n\treturn vec3(\n\t\tp.x,\n\t\tSDFRepeat(p.y, c.y),\n\t\tSDFRepeatClamped(p.z, c.z, boundMin, boundMax)\n\t);\n}\nvec3 SDFRepeatYZClampedYZ( in vec3 p, in vec3 c, in vec2 boundMin, in vec2 boundMax ){\n\treturn vec3(\n\t\tp.x,\n\t\tSDFRepeatClamped(p.y, c.y, boundMin.x, boundMax.x),\n\t\tSDFRepeatClamped(p.z, c.z, boundMin.y, boundMax.y)\n\t);\n}\n");

/***/ })

}])
//# sourceMappingURL=_polygonjs_polygonjs_src_core_player_PlayerCommon_ts-_polygonjs_polygonjs_src_engine_function-264718.41d9f36199f3ed0150b5.js.map