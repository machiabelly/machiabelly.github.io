declare namespace geometries {
	namespace path2 {
		type Path2 = any;
	}
	namespace geom2 {
		type Geom2 = any;
	}
	namespace geom3 {
		type Geom3 = any;
	}
}
declare type Ref<T extends any> = {value: T};
declare type WatchStopHandle<T> = (a:Ref<T>, callback:()=>void)=>void;
declare type Expression = any;
declare type CallExpression = any;
declare type BinaryExpression = any;
declare type LogicalExpression = any;
declare type MemberExpression = any;
declare type ConditionalExpression = any;
declare type Compound = any;
declare type UnaryExpression = any;
declare type Identifier = any;
declare type Literal = any;
declare type Disposable = any;
declare class EffectComposer {}
declare class Pass {}
declare class CopyPass extends Pass {}
declare class EffectPass extends Pass {}
declare class KawaseBlurPass extends Pass {}
declare class LuminancePass extends Pass {}
declare class NormalPass extends Pass {}
declare class RenderPass extends Pass {}
declare type MeshBVH = any;
declare type EnvelopeOptions = any;
declare type ToneAudioNode = any;
declare type ToneAudioNodeOptions = any;
declare type Instrument<T> = T;
declare type Player = any;
declare type OmniOscillatorSynthOptions = any;
declare type UserMedia = any;
//
declare type XRHandJoint = any;
declare type XRReferenceSpaceType = any;
declare type XRReferenceSpace = any;
declare type XRWebGLLayer = any;
declare type XRProjectionLayer = any;
declare type XRWebGLBinding = any;
declare type XRFrame = any;
declare type XRSession = any;
declare type XRFrameRequestCallback = any;
declare type XRPlane = any;
declare type XRSessionInit = any;

//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//

declare enum MOUSE {
	LEFT = 0,
	MIDDLE = 1,
	RIGHT = 2,
	ROTATE = 0,
	DOLLY = 1,
	PAN = 2
}
declare enum TOUCH {
	ROTATE = 0,
	PAN = 1,
	DOLLY_PAN = 2,
	DOLLY_ROTATE = 3
}
declare const CullFaceNone: 0;
declare const CullFaceBack: 1;
declare const CullFaceFront: 2;
declare const CullFaceFrontBack: 3;
type CullFace = typeof CullFaceNone | typeof CullFaceBack | typeof CullFaceFront | typeof CullFaceFrontBack;
declare const BasicShadowMap: 0;
declare const PCFShadowMap: 1;
declare const PCFSoftShadowMap: 2;
declare const VSMShadowMap: 3;
type ShadowMapType = typeof BasicShadowMap | typeof PCFShadowMap | typeof PCFSoftShadowMap | typeof VSMShadowMap;
declare const FrontSide: 0;
declare const BackSide: 1;
declare const DoubleSide: 2;
declare const TwoPassDoubleSide: 2;
/**
 * Defines which side of faces will be rendered - front, back or both.
 * Default is {@link FrontSide}.
 */
type Side = typeof FrontSide | typeof BackSide | typeof DoubleSide | typeof TwoPassDoubleSide;
declare const NoBlending: 0;
declare const NormalBlending: 1;
declare const AdditiveBlending: 2;
declare const SubtractiveBlending: 3;
declare const MultiplyBlending: 4;
declare const CustomBlending: 5;
type Blending = typeof NoBlending | typeof NormalBlending | typeof AdditiveBlending | typeof SubtractiveBlending | typeof MultiplyBlending | typeof CustomBlending;
declare const AddEquation: 100;
declare const SubtractEquation: 101;
declare const ReverseSubtractEquation: 102;
declare const MinEquation: 103;
declare const MaxEquation: 104;
type BlendingEquation = typeof AddEquation | typeof SubtractEquation | typeof ReverseSubtractEquation | typeof MinEquation | typeof MaxEquation;
declare const ZeroFactor: 200;
declare const OneFactor: 201;
declare const SrcColorFactor: 202;
declare const OneMinusSrcColorFactor: 203;
declare const SrcAlphaFactor: 204;
declare const OneMinusSrcAlphaFactor: 205;
declare const DstAlphaFactor: 206;
declare const OneMinusDstAlphaFactor: 207;
declare const DstColorFactor: 208;
declare const OneMinusDstColorFactor: 209;
type BlendingDstFactor = typeof ZeroFactor | typeof OneFactor | typeof SrcColorFactor | typeof OneMinusSrcColorFactor | typeof SrcAlphaFactor | typeof OneMinusSrcAlphaFactor | typeof DstAlphaFactor | typeof OneMinusDstAlphaFactor | typeof DstColorFactor | typeof OneMinusDstColorFactor;
declare const SrcAlphaSaturateFactor: 210;
type BlendingSrcFactor = typeof SrcAlphaSaturateFactor;
declare const NeverDepth: 0;
declare const AlwaysDepth: 1;
declare const LessDepth: 2;
declare const LessEqualDepth: 3;
declare const EqualDepth: 4;
declare const GreaterEqualDepth: 5;
declare const GreaterDepth: 6;
declare const NotEqualDepth: 7;
type DepthModes = typeof NeverDepth | typeof AlwaysDepth | typeof LessDepth | typeof LessEqualDepth | typeof EqualDepth | typeof GreaterEqualDepth | typeof GreaterDepth | typeof NotEqualDepth;
declare const MultiplyOperation: 0;
declare const MixOperation: 1;
declare const AddOperation: 2;
type Combine = typeof MultiplyOperation | typeof MixOperation | typeof AddOperation;
declare const NoToneMapping: 0;
declare const LinearToneMapping: 1;
declare const ReinhardToneMapping: 2;
declare const CineonToneMapping: 3;
declare const ACESFilmicToneMapping: 4;
declare const CustomToneMapping: 5;
type ToneMapping = typeof NoToneMapping | typeof LinearToneMapping | typeof ReinhardToneMapping | typeof CineonToneMapping | typeof ACESFilmicToneMapping | typeof CustomToneMapping;
declare const UVMapping: 300;
declare const CubeReflectionMapping: 301;
declare const CubeRefractionMapping: 302;
declare const CubeUVReflectionMapping: 306;
declare const EquirectangularReflectionMapping: 303;
declare const EquirectangularRefractionMapping: 304;
/**
 * Texture Mapping Modes for non-cube Textures
 * @remarks {@link UVMapping} is the _default_ value and behaver for Texture Mapping.
 * @see {@link https://threejs.org/docs/index.html#api/en/constants/Textures | Texture Constants}
 */
type Mapping = typeof UVMapping | typeof EquirectangularReflectionMapping | typeof EquirectangularRefractionMapping;
/**
 * Texture Mapping Modes for cube Textures
 * @remarks {@link CubeReflectionMapping} is the _default_ value and behaver for Cube Texture Mapping.
 * @see {@link https://threejs.org/docs/index.html#api/en/constants/Textures | Texture Constants}
 */
type CubeTextureMapping = typeof CubeReflectionMapping | typeof CubeRefractionMapping | typeof CubeUVReflectionMapping;
/**
 * Texture Mapping Modes for any type of Textures
 * @see {@link Mapping} and {@link CubeTextureMapping}
 * @see {@link https://threejs.org/docs/index.html#api/en/constants/Textures | Texture Constants}
 */
type AnyMapping = Mapping | CubeTextureMapping;
declare const RepeatWrapping: 1000;
declare const ClampToEdgeWrapping: 1001;
declare const MirroredRepeatWrapping: 1002;
/**
 * Texture Wrapping Modes
 * @remarks {@link ClampToEdgeWrapping} is the _default_ value and behaver for Wrapping Mapping.
 * @see {@link https://threejs.org/docs/index.html#api/en/constants/Textures | Texture Constants}
 */
type Wrapping = typeof RepeatWrapping | typeof ClampToEdgeWrapping | typeof MirroredRepeatWrapping;
declare const NearestFilter: 1003;
declare const NearestMipmapNearestFilter: 1004;
declare const NearestMipMapNearestFilter: 1004;
declare const NearestMipmapLinearFilter: 1005;
declare const NearestMipMapLinearFilter: 1005;
declare const LinearFilter: 1006;
declare const LinearMipmapNearestFilter: 1007;
declare const LinearMipMapNearestFilter: 1007;
declare const LinearMipmapLinearFilter: 1008;
declare const LinearMipMapLinearFilter: 1008;
/**
 * Texture Magnification Filter Modes.
 * For use with a texture's {@link Texture.magFilter | magFilter} property,
 * these define the texture magnification function to be used when the pixel being textured maps to an area less than or equal to one texture element (texel).
 * @see {@link https://threejs.org/docs/index.html#api/en/constants/Textures | Texture Constants}
 * @see {@link https://sbcode.net/threejs/mipmaps/ | Texture Mipmaps (non-official)}
 */
type MagnificationTextureFilter = typeof NearestFilter | typeof LinearFilter;
/**
 * Texture Minification Filter Modes.
 * For use with a texture's {@link Texture.minFilter | minFilter} property,
 * these define the texture minifying function that is used whenever the pixel being textured maps to an area greater than one texture element (texel).
 * @see {@link https://threejs.org/docs/index.html#api/en/constants/Textures | Texture Constants}
 * @see {@link https://sbcode.net/threejs/mipmaps/ | Texture Mipmaps (non-official)}
 */
type MinificationTextureFilter = typeof NearestFilter | typeof NearestMipmapNearestFilter | typeof NearestMipMapNearestFilter | typeof NearestMipmapLinearFilter | typeof NearestMipMapLinearFilter | typeof LinearFilter | typeof LinearMipmapNearestFilter | typeof LinearMipMapNearestFilter | typeof LinearMipmapLinearFilter | typeof LinearMipMapLinearFilter;
declare const UnsignedByteType: 1009;
declare const ByteType: 1010;
declare const ShortType: 1011;
declare const UnsignedShortType: 1012;
declare const IntType: 1013;
declare const UnsignedIntType: 1014;
declare const FloatType: 1015;
declare const HalfFloatType: 1016;
declare const UnsignedShort4444Type: 1017;
declare const UnsignedShort5551Type: 1018;
declare const UnsignedInt248Type: 1020;
/**
 * Texture Types.
 * @remarks Must correspond to the correct {@link PixelFormat | format}.
 * @see {@link Texture.type}
 * @see {@link https://threejs.org/docs/index.html#api/en/constants/Textures | Texture Constants}
 */
type TextureDataType = typeof UnsignedByteType | typeof ByteType | typeof ShortType | typeof UnsignedShortType | typeof IntType | typeof UnsignedIntType | typeof FloatType | typeof HalfFloatType | typeof UnsignedShort4444Type | typeof UnsignedShort5551Type | typeof UnsignedInt248Type;
declare const AlphaFormat: 1021;
declare const RGBAFormat: 1023;
declare const LuminanceFormat: 1024;
declare const LuminanceAlphaFormat: 1025;
declare const DepthFormat: 1026;
declare const DepthStencilFormat: 1027;
declare const RedFormat: 1028;
declare const RedIntegerFormat: 1029;
declare const RGFormat: 1030;
declare const RGIntegerFormat: 1031;
declare const RGBAIntegerFormat: 1033;
declare const _SRGBAFormat = 1035;
/**
 * Texture Pixel Formats Modes. Compatible only with {@link WebGLRenderingContext | WebGL 1 Rendering Context}.
 * @remarks Note that the texture must have the correct {@link Texture.type} set, as described in  {@link TextureDataType}.
 * @see {@link WebGLRenderingContext.texImage2D} for details.
 * @see {@link WebGL2PixelFormat} and {@link PixelFormat}
 * @see {@link https://threejs.org/docs/index.html#api/en/constants/Textures | Texture Constants}
 */
type WebGL1PixelFormat = typeof AlphaFormat | typeof LuminanceFormat | typeof LuminanceAlphaFormat | typeof DepthFormat | typeof DepthStencilFormat | typeof RedFormat | typeof RedIntegerFormat | typeof RGFormat | typeof _SRGBAFormat;
/**
 * Texture Pixel Formats Modes. Compatible only with {@link WebGL2RenderingContext | WebGL 2 Rendering Context}.
 * @remarks Note that the texture must have the correct {@link Texture.type} set, as described in  {@link TextureDataType}.
 * @see {@link WebGLRenderingContext.texImage2D} for details.
 * @see {@link WebGL2PixelFormat} and {@link PixelFormat}
 * @see {@link https://threejs.org/docs/index.html#api/en/constants/Textures | Texture Constants}
 */
type WebGL2PixelFormat = typeof AlphaFormat | typeof RGBAFormat | typeof LuminanceFormat | typeof LuminanceAlphaFormat | typeof DepthFormat | typeof DepthStencilFormat | typeof RedFormat | typeof RedIntegerFormat | typeof RGFormat | typeof RGIntegerFormat | typeof RGBAIntegerFormat | typeof _SRGBAFormat;
/**
 * All Texture Pixel Formats Modes.
 * @remarks Note that the texture must have the correct {@link Texture.type} set, as described in  {@link TextureDataType}.
 * @see {@link WebGLRenderingContext.texImage2D} for details.
 * @see {@link WebGL1PixelFormat} and {@link WebGL2PixelFormat}
 * @see {@link https://threejs.org/docs/index.html#api/en/constants/Textures | Texture Constants}
 */
type PixelFormat = WebGL1PixelFormat | WebGL2PixelFormat;
/**
 * All Texture Pixel Formats Modes for {@link DeepTexture}.
 * @see {@link WebGLRenderingContext.texImage2D} for details.
 * @see {@link https://threejs.org/docs/index.html#api/en/constants/Textures | Texture Constants}
 */
type DeepTexturePixelFormat = typeof DepthFormat | typeof DepthStencilFormat;
declare const RGB_S3TC_DXT1_Format: 33776;
declare const RGBA_S3TC_DXT1_Format: 33777;
declare const RGBA_S3TC_DXT3_Format: 33778;
declare const RGBA_S3TC_DXT5_Format: 33779;
declare const RGB_PVRTC_4BPPV1_Format: 35840;
declare const RGB_PVRTC_2BPPV1_Format: 35841;
declare const RGBA_PVRTC_4BPPV1_Format: 35842;
declare const RGBA_PVRTC_2BPPV1_Format: 35843;
declare const RGB_ETC1_Format: 36196;
declare const RGB_ETC2_Format: 37492;
declare const RGBA_ETC2_EAC_Format: 37496;
declare const RGBA_ASTC_4x4_Format: 37808;
declare const RGBA_ASTC_5x4_Format: 37809;
declare const RGBA_ASTC_5x5_Format: 37810;
declare const RGBA_ASTC_6x5_Format: 37811;
declare const RGBA_ASTC_6x6_Format: 37812;
declare const RGBA_ASTC_8x5_Format: 37813;
declare const RGBA_ASTC_8x6_Format: 37814;
declare const RGBA_ASTC_8x8_Format: 37815;
declare const RGBA_ASTC_10x5_Format: 37816;
declare const RGBA_ASTC_10x6_Format: 37817;
declare const RGBA_ASTC_10x8_Format: 37818;
declare const RGBA_ASTC_10x10_Format: 37819;
declare const RGBA_ASTC_12x10_Format: 37820;
declare const RGBA_ASTC_12x12_Format: 37821;
declare const RGBA_BPTC_Format: 36492;
declare const RED_RGTC1_Format: 36283;
declare const SIGNED_RED_RGTC1_Format: 36284;
declare const RED_GREEN_RGTC2_Format: 36285;
declare const SIGNED_RED_GREEN_RGTC2_Format: 36286;
/**
 * For use with a {@link CompressedTexture}'s {@link THREE.CompressedTexture.format | .format} property.
 * @remarks Compressed Require support for correct WebGL extension.
 */
type CompressedPixelFormat = typeof RGB_S3TC_DXT1_Format | typeof RGBA_S3TC_DXT1_Format | typeof RGBA_S3TC_DXT3_Format | typeof RGBA_S3TC_DXT5_Format | typeof RGB_PVRTC_4BPPV1_Format | typeof RGB_PVRTC_2BPPV1_Format | typeof RGBA_PVRTC_4BPPV1_Format | typeof RGBA_PVRTC_2BPPV1_Format | typeof RGB_ETC1_Format | typeof RGB_ETC2_Format | typeof RGBA_ETC2_EAC_Format | typeof RGBA_ASTC_4x4_Format | typeof RGBA_ASTC_5x4_Format | typeof RGBA_ASTC_5x5_Format | typeof RGBA_ASTC_6x5_Format | typeof RGBA_ASTC_6x6_Format | typeof RGBA_ASTC_8x5_Format | typeof RGBA_ASTC_8x6_Format | typeof RGBA_ASTC_8x8_Format | typeof RGBA_ASTC_10x5_Format | typeof RGBA_ASTC_10x6_Format | typeof RGBA_ASTC_10x8_Format | typeof RGBA_ASTC_10x10_Format | typeof RGBA_ASTC_12x10_Format | typeof RGBA_ASTC_12x12_Format | typeof RGBA_BPTC_Format | typeof RED_RGTC1_Format | typeof SIGNED_RED_RGTC1_Format | typeof RED_GREEN_RGTC2_Format | typeof SIGNED_RED_GREEN_RGTC2_Format;
///////////////////////////////////////////////////////////////////////////////
/**
 * All Possible Texture Pixel Formats Modes. For any Type or SubType of Textures.
 * @remarks Note that the texture must have the correct {@link Texture.type} set, as described in {@link TextureDataType}.
 * @see {@link WebGLRenderingContext.texImage2D} for details.
 * @see {@link PixelFormat} and {@link DeepTexturePixelFormat} and {@link CompressedPixelFormat}
 * @see {@link https://threejs.org/docs/index.html#api/en/constants/Textures | Texture Constants}
 */
type AnyPixelFormat = PixelFormat | DeepTexturePixelFormat | CompressedPixelFormat;
declare const LoopOnce: 2200;
declare const LoopRepeat: 2201;
declare const LoopPingPong: 2202;
type AnimationActionLoopStyles = typeof LoopOnce | typeof LoopRepeat | typeof LoopPingPong;
declare const InterpolateDiscrete: 2300;
declare const InterpolateLinear: 2301;
declare const InterpolateSmooth: 2302;
type InterpolationModes = typeof InterpolateDiscrete | typeof InterpolateLinear | typeof InterpolateSmooth;
declare const NormalAnimationBlendMode: 2500;
declare const AdditiveAnimationBlendMode: 2501;
type AnimationBlendMode = typeof NormalAnimationBlendMode | typeof AdditiveAnimationBlendMode;
declare const LinearEncoding: 3000;
declare const sRGBEncoding: 3001;
/**
 * Texture Encodings.
 * @see {@link https://threejs.org/docs/index.html#api/en/constants/Textures | Texture Constants}
 * @deprecated Use {@link ColorSpace} in three.js r152+.
 */
type TextureEncoding = typeof LinearEncoding | typeof sRGBEncoding;
declare const BasicDepthPacking: 3200;
declare const RGBADepthPacking: 3201;
type DepthPackingStrategies = typeof BasicDepthPacking | typeof RGBADepthPacking;
declare const TangentSpaceNormalMap: 0;
declare const ObjectSpaceNormalMap: 1;
type NormalMapTypes = typeof TangentSpaceNormalMap | typeof ObjectSpaceNormalMap;
declare const NoColorSpace: "";
declare const SRGBColorSpace: "srgb";
declare const LinearSRGBColorSpace: "srgb-linear";
declare const DisplayP3ColorSpace = "display-p3";
type ColorSpace = typeof NoColorSpace | typeof SRGBColorSpace | typeof LinearSRGBColorSpace | typeof DisplayP3ColorSpace;
declare const ZeroStencilOp: 0;
declare const KeepStencilOp: 7680;
declare const ReplaceStencilOp: 7681;
declare const IncrementStencilOp: 7682;
declare const DecrementStencilOp: 7283;
declare const IncrementWrapStencilOp: 34055;
declare const DecrementWrapStencilOp: 34056;
declare const InvertStencilOp: 5386;
type StencilOp = typeof ZeroStencilOp | typeof KeepStencilOp | typeof ReplaceStencilOp | typeof IncrementStencilOp | typeof DecrementStencilOp | typeof IncrementWrapStencilOp | typeof DecrementWrapStencilOp | typeof InvertStencilOp;
declare const NeverStencilFunc: 512;
declare const LessStencilFunc: 513;
declare const EqualStencilFunc: 514;
declare const LessEqualStencilFunc: 515;
declare const GreaterStencilFunc: 516;
declare const NotEqualStencilFunc: 517;
declare const GreaterEqualStencilFunc: 518;
declare const AlwaysStencilFunc: 519;
type StencilFunc = typeof NeverStencilFunc | typeof LessStencilFunc | typeof EqualStencilFunc | typeof LessEqualStencilFunc | typeof GreaterStencilFunc | typeof NotEqualStencilFunc | typeof GreaterEqualStencilFunc | typeof AlwaysStencilFunc;
declare const StaticDrawUsage: 35044;
declare const DynamicDrawUsage: 35048;
declare const StreamDrawUsage: 35040;
declare const StaticReadUsage: 35045;
declare const DynamicReadUsage: 35049;
declare const StreamReadUsage: 35041;
declare const StaticCopyUsage: 35046;
declare const DynamicCopyUsage: 35050;
declare const StreamCopyUsage: 35042;
type Usage = typeof StaticDrawUsage | typeof DynamicDrawUsage | typeof StreamDrawUsage | typeof StaticReadUsage | typeof DynamicReadUsage | typeof StreamReadUsage | typeof StaticCopyUsage | typeof DynamicCopyUsage | typeof StreamCopyUsage;
declare const GLSL1: "100";
declare const GLSL3: "300 es";
type GLSLVersion = typeof GLSL1 | typeof GLSL3;
///////////////////////////////////////////////////////////////////////////////
// Texture - Internal Pixel Formats
/**
 * For use with a texture's {@link Texture.internalFormat} property, these define how elements of a {@link THREE.Texture}, or texels, are stored on the GPU.
 * - `R8` stores the red component on 8 bits.
 * - `R8_SNORM` stores the red component on 8 bits. The component is stored as normalized.
 * - `R8I` stores the red component on 8 bits. The component is stored as an integer.
 * - `R8UI` stores the red component on 8 bits. The component is stored as an unsigned integer.
 * - `R16I` stores the red component on 16 bits. The component is stored as an integer.
 * - `R16UI` stores the red component on 16 bits. The component is stored as an unsigned integer.
 * - `R16F` stores the red component on 16 bits. The component is stored as floating point.
 * - `R32I` stores the red component on 32 bits. The component is stored as an integer.
 * - `R32UI` stores the red component on 32 bits. The component is stored as an unsigned integer.
 * - `R32F` stores the red component on 32 bits. The component is stored as floating point.
 * - `RG8` stores the red and green components on 8 bits each.
 * - `RG8_SNORM` stores the red and green components on 8 bits each. Every component is stored as normalized.
 * - `RG8I` stores the red and green components on 8 bits each. Every component is stored as an integer.
 * - `RG8UI` stores the red and green components on 8 bits each. Every component is stored as an unsigned integer.
 * - `RG16I` stores the red and green components on 16 bits each. Every component is stored as an integer.
 * - `RG16UI` stores the red and green components on 16 bits each. Every component is stored as an unsigned integer.
 * - `RG16F` stores the red and green components on 16 bits each. Every component is stored as floating point.
 * - `RG32I` stores the red and green components on 32 bits each. Every component is stored as an integer.
 * - `RG32UI` stores the red and green components on 32 bits. Every component is stored as an unsigned integer.
 * - `RG32F` stores the red and green components on 32 bits. Every component is stored as floating point.
 * - `RGB8` stores the red, green, and blue components on 8 bits each. RGB8_SNORM` stores the red, green, and blue components on 8 bits each. Every component is stored as normalized.
 * - `RGB8I` stores the red, green, and blue components on 8 bits each. Every component is stored as an integer.
 * - `RGB8UI` stores the red, green, and blue components on 8 bits each. Every component is stored as an unsigned integer.
 * - `RGB16I` stores the red, green, and blue components on 16 bits each. Every component is stored as an integer.
 * - `RGB16UI` stores the red, green, and blue components on 16 bits each. Every component is stored as an unsigned integer.
 * - `RGB16F` stores the red, green, and blue components on 16 bits each. Every component is stored as floating point
 * - `RGB32I` stores the red, green, and blue components on 32 bits each. Every component is stored as an integer.
 * - `RGB32UI` stores the red, green, and blue components on 32 bits each. Every component is stored as an unsigned integer.
 * - `RGB32F` stores the red, green, and blue components on 32 bits each. Every component is stored as floating point
 * - `R11F_G11F_B10F` stores the red, green, and blue components respectively on 11 bits, 11 bits, and 10bits. Every component is stored as floating point.
 * - `RGB565` stores the red, green, and blue components respectively on 5 bits, 6 bits, and 5 bits.
 * - `RGB9_E5` stores the red, green, and blue components on 9 bits each.
 * - `RGBA8` stores the red, green, blue, and alpha components on 8 bits each.
 * - `RGBA8_SNORM` stores the red, green, blue, and alpha components on 8 bits. Every component is stored as normalized.
 * - `RGBA8I` stores the red, green, blue, and alpha components on 8 bits each. Every component is stored as an integer.
 * - `RGBA8UI` stores the red, green, blue, and alpha components on 8 bits. Every component is stored as an unsigned integer.
 * - `RGBA16I` stores the red, green, blue, and alpha components on 16 bits. Every component is stored as an integer.
 * - `RGBA16UI` stores the red, green, blue, and alpha components on 16 bits. Every component is stored as an unsigned integer.
 * - `RGBA16F` stores the red, green, blue, and alpha components on 16 bits. Every component is stored as floating point.
 * - `RGBA32I` stores the red, green, blue, and alpha components on 32 bits. Every component is stored as an integer.
 * - `RGBA32UI` stores the red, green, blue, and alpha components on 32 bits. Every component is stored as an unsigned integer.
 * - `RGBA32F` stores the red, green, blue, and alpha components on 32 bits. Every component is stored as floating point.
 * - `RGB5_A1` stores the red, green, blue, and alpha components respectively on 5 bits, 5 bits, 5 bits, and 1 bit.
 * - `RGB10_A2` stores the red, green, blue, and alpha components respectively on 10 bits, 10 bits, 10 bits and 2 bits.
 * - `RGB10_A2UI` stores the red, green, blue, and alpha components respectively on 10 bits, 10 bits, 10 bits and 2 bits. Every component is stored as an unsigned integer.
 * - `SRGB8` stores the red, green, and blue components on 8 bits each.
 * - `SRGB8_ALPHA8` stores the red, green, blue, and alpha components on 8 bits each.
 * - `DEPTH_COMPONENT16` stores the depth component on 16bits.
 * - `DEPTH_COMPONENT24` stores the depth component on 24bits.
 * - `DEPTH_COMPONENT32F` stores the depth component on 32bits. The component is stored as floating point.
 * - `DEPTH24_STENCIL8` stores the depth, and stencil components respectively on 24 bits and 8 bits. The stencil component is stored as an unsigned integer.
 * - `DEPTH32F_STENCIL8` stores the depth, and stencil components respectively on 32 bits and 8 bits. The depth component is stored as floating point, and the stencil component as an unsigned integer.
 * @remark Note that the texture must have the correct {@link Texture.type} set, as well as the correct {@link THREE.Texture.format}.
 * @see {@link WebGLRenderingContext.texImage2D} and {@link WebGLRenderingContext.texImage3D} for more details regarding the possible combination
 * of {@link Texture.format}, {@link THREE.Texture.internalFormat}, and {@link THREE.Texture.type}.
 * @see {@link https://registry.khronos.org/webgl/specs/latest/2.0/ | WebGL2 Specification} and
 * {@link https://registry.khronos.org/OpenGL/specs/es/3.0/es_spec_3.0.pdf | OpenGL ES 3.0 Specification} For more in-depth information regarding internal formats.
 */
type PixelFormatGPU = "ALPHA" | "RGB" | "RGBA" | "LUMINANCE" | "LUMINANCE_ALPHA" | "RED_INTEGER" | "R8" | "R8_SNORM" | "R8I" | "R8UI" | "R16I" | "R16UI" | "R16F" | "R32I" | "R32UI" | "R32F" | "RG8" | "RG8_SNORM" | "RG8I" | "RG8UI" | "RG16I" | "RG16UI" | "RG16F" | "RG32I" | "RG32UI" | "RG32F" | "RGB565" | "RGB8" | "RGB8_SNORM" | "RGB8I" | "RGB8UI" | "RGB16I" | "RGB16UI" | "RGB16F" | "RGB32I" | "RGB32UI" | "RGB32F" | "RGB9_E5" | "SRGB8" | "R11F_G11F_B10F" | "RGBA4" | "RGBA8" | "RGBA8_SNORM" | "RGBA8I" | "RGBA8UI" | "RGBA16I" | "RGBA16UI" | "RGBA16F" | "RGBA32I" | "RGBA32UI" | "RGBA32F" | "RGB5_A1" | "RGB10_A2" | "RGB10_A2UI" | "SRGB8_ALPHA8" | "SRGB8" | "DEPTH_COMPONENT16" | "DEPTH_COMPONENT24" | "DEPTH_COMPONENT32F" | "DEPTH24_STENCIL8" | "DEPTH32F_STENCIL8";
declare abstract class Interpolant {
	constructor(parameterPositions: any, sampleValues: any, sampleSize: number, resultBuffer?: any);
	parameterPositions: any;
	sampleValues: any;
	valueSize: number;
	resultBuffer: any;
	evaluate(time: number): any;
}
declare class DiscreteInterpolant extends Interpolant {
	constructor(parameterPositions: any, samplesValues: any, sampleSize: number, resultBuffer?: any);
	interpolate_(i1: number, t0: number, t: number, t1: number): any;
}
declare class LinearInterpolant extends Interpolant {
	constructor(parameterPositions: any, samplesValues: any, sampleSize: number, resultBuffer?: any);
	interpolate_(i1: number, t0: number, t: number, t1: number): any;
}
declare class CubicInterpolant extends Interpolant {
	constructor(parameterPositions: any, samplesValues: any, sampleSize: number, resultBuffer?: any);
	interpolate_(i1: number, t0: number, t: number, t1: number): any;
}
declare class KeyframeTrack {
	/**
	 * @param name
	 * @param times
	 * @param values
	 * @param [interpolation=InterpolateLinear]
	 */
	constructor(name: string, times: ArrayLike<number>, values: ArrayLike<any>, interpolation?: InterpolationModes);
	name: string;
	times: Float32Array;
	values: Float32Array;
	ValueTypeName: string;
	TimeBufferType: Float32Array;
	ValueBufferType: Float32Array;
	/**
	 * @default InterpolateLinear
	 */
	DefaultInterpolation: InterpolationModes;
	InterpolantFactoryMethodDiscrete(result: any): DiscreteInterpolant;
	InterpolantFactoryMethodLinear(result: any): LinearInterpolant;
	InterpolantFactoryMethodSmooth(result: any): CubicInterpolant;
	setInterpolation(interpolation: InterpolationModes): KeyframeTrack;
	getInterpolation(): InterpolationModes;
	createInterpolant(): Interpolant;
	getValueSize(): number;
	shift(timeOffset: number): KeyframeTrack;
	scale(timeScale: number): KeyframeTrack;
	trim(startTime: number, endTime: number): KeyframeTrack;
	validate(): boolean;
	optimize(): KeyframeTrack;
	clone(): this;
	static toJSON(track: KeyframeTrack): any;
}
type Matrix3Tuple = [
	number,
	number,
	number,
	number,
	number,
	number,
	number,
	number,
	number
];
/**
 * ( interface Matrix<T> )
 */
interface Matrix {
	/**
	 * Array with matrix values.
	 */
	elements: number[];
	/**
	 * identity():T;
	 */
	identity(): Matrix;
	/**
	 * copy(m:T):T;
	 */
	copy(m: this): this;
	/**
	 * multiplyScalar(s:number):T;
	 */
	multiplyScalar(s: number): Matrix;
	determinant(): number;
	/**
	 * transpose():T;
	 */
	transpose(): Matrix;
	/**
	 * invert():T;
	 */
	invert(): Matrix;
	/**
	 * clone():T;
	 */
	clone(): Matrix;
}
declare class Matrix3 implements Matrix {
	/**
	 * Creates an identity matrix.
	 */
	constructor();
	/**
	 * Array with matrix values.
	 * @default [1, 0, 0, 0, 1, 0, 0, 0, 1]
	 */
	elements: number[];
	set(n11: number, n12: number, n13: number, n21: number, n22: number, n23: number, n31: number, n32: number, n33: number): Matrix3;
	identity(): Matrix3;
	clone(): this;
	copy(m: Matrix3): this;
	extractBasis(xAxis: Vector3, yAxis: Vector3, zAxis: Vector3): Matrix3;
	setFromMatrix4(m: Matrix4): Matrix3;
	multiplyScalar(s: number): Matrix3;
	determinant(): number;
	/**
	 * Inverts this matrix in place.
	 */
	invert(): Matrix3;
	/**
	 * Transposes this matrix in place.
	 */
	transpose(): Matrix3;
	getNormalMatrix(matrix4: Matrix4): Matrix3;
	/**
	 * Transposes this matrix into the supplied array r, and returns itself.
	 */
	transposeIntoArray(r: number[]): Matrix3;
	setUvTransform(tx: number, ty: number, sx: number, sy: number, rotation: number, cx: number, cy: number): Matrix3;
	scale(sx: number, sy: number): Matrix3;
	/**
	 * Sets this matrix as a 2D translation transform:
	 *
	 * ```
	 * 1, 0, x,
	 * 0, 1, y,
	 * 0, 0, 1
	 * ```
	 *
	 * @param x the amount to translate in the X axis.
	 * @param y the amount to translate in the Y axis.
	 */
	makeTranslation(x: number, y: number): this;
	makeTranslation(x: number, y: number): Matrix3;
	/**
	 * Sets this matrix as a 2D rotational transformation by theta radians. The resulting matrix will be:
	 *
	 * ```
	 * cos(θ) -sin(θ) 0
	 * sin(θ) cos(θ)  0
	 * 0      0       1
	 * ```
	 *
	 * @param theta Rotation angle in radians. Positive values rotate counterclockwise.
	 */
	makeRotation(theta: number): this;
	makeRotation(theta: number): Matrix3;
	/**
	 * Sets this matrix as a 2D scale transform:
	 *
	 * ```
	 * x, 0, 0,
	 * 0, y, 0,
	 * 0, 0, 1
	 * ```
	 *
	 * @param x the amount to scale in the X axis.
	 * @param y the amount to scale in the Y axis.
	 */
	makeScale(x: number, y: number): this;
	makeScale(x: number, y: number): Matrix3;
	rotate(theta: number): Matrix3;
	translate(tx: number, ty: number): Matrix3;
	equals(matrix: Matrix3): boolean;
	/**
	 * Sets the values of this matrix from the provided array or array-like.
	 * @param array the source array or array-like.
	 * @param offset (optional) offset into the array-like. Default is 0.
	 */
	fromArray(array: number[] | ArrayLike<number>, offset?: number): Matrix3;
	/**
	 * Returns an array with the values of this matrix, or copies them into the provided array.
	 * @param array (optional) array to store the matrix to. If this is not provided, a new array will be created.
	 * @param offset (optional) optional offset into the array.
	 * @return The created or provided array.
	 */
	toArray(array?: number[], offset?: number): number[];
	toArray(array?: Matrix3Tuple, offset?: 0): Matrix3Tuple;
	/**
	 * Copies he values of this matrix into the provided array-like.
	 * @param array array-like to store the matrix to.
	 * @param offset (optional) optional offset into the array-like.
	 * @return The provided array-like.
	 */
	toArray(array?: ArrayLike<number>, offset?: number): ArrayLike<number>;
	/**
	 * Multiplies this matrix by m.
	 */
	multiply(m: Matrix3): Matrix3;
	premultiply(m: Matrix3): Matrix3;
	/**
	 * Sets this matrix to a x b.
	 */
	multiplyMatrices(a: Matrix3, b: Matrix3): Matrix3;
	/**
	 * @deprecated Use {@link Vector3.applyMatrix3 vector.applyMatrix3( matrix )} instead.
	 */
	multiplyVector3(vector: Vector3): any;
	/**
	 * @deprecated This method has been removed completely.
	 */
	multiplyVector3Array(a: any): any;
	/**
	 * @deprecated Use {@link Matrix3#invert .invert()} instead.
	 */
	getInverse(matrix: Matrix4, throwOnDegenerate?: boolean): Matrix3;
	getInverse(matrix: Matrix): Matrix;
	/**
	 * @deprecated Use {@link Matrix3#toArray .toArray()} instead.
	 */
	flattenToArrayOffset(array: number[], offset: number): number[];
}
declare class BufferAttribute {
	/**
	 * This creates a new {@link GLBufferAttribute | GLBufferAttribute} object.
	 * @param array Must be a `TypedArray`. Used to instantiate the buffer.
	 * This array should have `itemSize * numVertices` elements, where numVertices is the number of vertices in the associated {@link BufferGeometry | BufferGeometry}.
	 * @param itemSize the number of values of the {@link array} that should be associated with a particular vertex.
	 * For instance, if this attribute is storing a 3-component vector (such as a _position_, _normal_, or _color_),
	 * then itemSize should be `3`.
	 * @param normalized Applies to integer data only.
	 * Indicates how the underlying data in the buffer maps to the values in the GLSL code.
	 * For instance, if {@link array} is an instance of `UInt16Array`, and  {@link normalized} is true,
	 * the values `0` - `+65535` in the array data will be mapped to `0.0f` - `+1.0f` in the GLSL attribute.
	 * An `Int16Array` (signed) would map from `-32768` - `+32767` to `-1.0f` - `+1.0f`.
	 * If normalized is false, the values will be converted to floats unmodified,
	 * i.e. `32767` becomes `32767.0f`.
	 * Default `false`.
	 * @throws `TypeError` When the {@link array} is not a `TypedArray`;
	 */
	constructor(array: ArrayLike<number>, itemSize: number, normalized?: boolean); // array parameter should be `TypedArray`.
	/**
	 * Optional name for this attribute instance.
	 * @defaultValue ''
	 */
	name: string;
	/**
	 * The {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray | TypedArray} holding data stored in the buffer.
	 * @returns `TypedArray`
	 */
	array: ArrayLike<number>;
	/**
	 * The length of vectors that are being stored in the {@link BufferAttribute.array | array}.
	 * @remarks Expects a `Integer`
	 */
	itemSize: number;
	/**
	 * Defines the intended usage pattern of the data store for optimization purposes.
	 * Corresponds to the {@link BufferAttribute.usage | usage} parameter of
	 * {@link https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/bufferData | WebGLRenderingContext.bufferData}.
	 * @remarks
	 * After the initial use of a buffer, its usage cannot be changed. Instead, instantiate a new one and set the desired usage before the next render.
	 * @see {@link https://threejs.org/docs/index.html#api/en/constants/BufferAttributeUsage | Buffer Attribute Usage Constants} for all possible values.
	 * @see {@link BufferAttribute.setUsage | setUsage}
	 * @defaultValue {@link StaticDrawUsage | THREE.StaticDrawUsage}.
	 */
	usage: Usage;
	/**
	 * This can be used to only update some components of stored vectors (for example, just the component related to color).
	 * @defaultValue `{ offset: number = 0; count: number = -1 }`
	 */
	updateRange: {
		/**
		 * Position at which to start update.
		 * @defaultValue `0`
		 */
		offset: number;
		/** @defaultValue `-1`, which means don't use update ranges. */
		count: number;
	};
	/**
	 * A version number, incremented every time the {@link BufferAttribute.needsUpdate | needsUpdate} property is set to true.
	 * @remarks Expects a `Integer`
	 * @defaultValue `0`
	 */
	version: number;
	/**
	 * Indicates how the underlying data in the buffer maps to the values in the GLSL shader code.
	 * @see `constructor` above for details.
	 * @defaultValue `false`
	 */
	normalized: boolean;
	/**
	 * Stores the {@link BufferAttribute.array | array}'s length divided by the {@link BufferAttribute.itemSize | itemSize}.
	 * @remarks If the buffer is storing a 3-component vector (such as a position, normal, or color), then this will count the number of such vectors stored.
	 * @remarks Expects a `Integer`
	 */
	count: number;
	/**
	 * Flag to indicate that this attribute has changed and should be re-sent to the GPU.
	 * Set this to true when you modify the value of the array.
	 * @remarks Setting this to true also increments the {@link BufferAttribute.version | version}.
	 * @remarks _set-only property_.
	 */
	set needsUpdate(value: boolean);
	/**
	 * Read-only flag to check if a given object is of type {@link BufferAttribute}.
	 * @remarks This is a _constant_ value
	 * @defaultValue `true`
	 */
	readonly isBufferAttribute: true;
	/**
	 * A callback function that is executed after the Renderer has transferred the attribute array data to the GPU.
	 */
	onUploadCallback: () => void;
	/**
	 * Sets the value of the {@link onUploadCallback} property.
	 * @see Example: {@link https://threejs.org/examples/#webgl_buffergeometry | WebGL / BufferGeometry} this is used to free memory after the buffer has been transferred to the GPU.
	 * @see {@link onUploadCallback}
	 * @param callback function that is executed after the Renderer has transferred the attribute array data to the GPU.
	 */
	onUpload(callback: () => void): this;
	/**
	 * Set {@link BufferAttribute.usage | usage}
	 * @remarks
	 * After the initial use of a buffer, its usage cannot be changed. Instead, instantiate a new one and set the desired usage before the next render.
	 * @see {@link https://threejs.org/docs/index.html#api/en/constants/BufferAttributeUsage | Buffer Attribute Usage Constants} for all possible values.
	 * @see {@link BufferAttribute.usage | usage}
	 * @param value Corresponds to the {@link BufferAttribute.usage | usage} parameter of
	 * {@link https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/bufferData | WebGLRenderingContext.bufferData}.
	 */
	setUsage(usage: Usage): this;
	/**
	 * @returns a copy of this {@link BufferAttribute}.
	 */
	clone(): BufferAttribute;
	/**
	 * Copies another {@link BufferAttribute} to this {@link BufferAttribute}.
	 * @param bufferAttribute
	 */
	copy(source: BufferAttribute): this;
	/**
	 * Copy a vector from bufferAttribute[index2] to {@link BufferAttribute.array | array}[index1].
	 * @param index1
	 * @param bufferAttribute
	 * @param index2
	 */
	copyAt(index1: number, attribute: BufferAttribute, index2: number): this;
	/**
	 * Copy the array given here (which can be a normal array or `TypedArray`) into {@link BufferAttribute.array | array}.
	 * @see {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray/set | TypedArray.set} for notes on requirements if copying a `TypedArray`.
	 */
	copyArray(array: ArrayLike<number>): this;
	/**
	 * Applies matrix {@link Matrix3 | m} to every Vector3 element of this {@link BufferAttribute}.
	 * @param m
	 */
	applyMatrix3(m: Matrix3): this;
	/**
	 * Applies matrix {@link Matrix4 | m} to every Vector3 element of this {@link BufferAttribute}.
	 * @param m
	 */
	applyMatrix4(m: Matrix4): this;
	/**
	 * Applies normal matrix {@link Matrix3 | m} to every Vector3 element of this {@link BufferAttribute}.
	 * @param m
	 */
	applyNormalMatrix(m: Matrix3): this;
	/**
	 * Applies matrix {@link Matrix4 | m} to every Vector3 element of this {@link BufferAttribute}, interpreting the elements as a direction vectors.
	 * @param m
	 */
	transformDirection(m: Matrix4): this;
	/**
	 * Calls {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray/set | TypedArray.set}( {@link value}, {@link offset} )
	 * on the {@link BufferAttribute.array | array}.
	 * @param value {@link Array | Array} or `TypedArray` from which to copy values.
	 * @param offset index of the {@link BufferAttribute.array | array} at which to start copying. Expects a `Integer`. Default `0`.
	 * @throws `RangeError` When {@link offset} is negative or is too large.
	 */
	set(value: ArrayLike<number> | ArrayBufferView, offset?: number): this;
	/**
	 * Returns the x component of the vector at the given index.
	 * @param index Expects a `Integer`
	 */
	getX(index: number): number;
	/**
	 * Sets the x component of the vector at the given index.
	 * @param index Expects a `Integer`
	 * @param x
	 */
	setX(index: number, x: number): this;
	/**
	 * Returns the y component of the vector at the given index.
	 * @param index Expects a `Integer`
	 */
	getY(index: number): number;
	/**
	 * Sets the y component of the vector at the given index.
	 * @param index Expects a `Integer`
	 * @param y
	 */
	setY(index: number, y: number): this;
	/**
	 * Returns the z component of the vector at the given index.
	 * @param index Expects a `Integer`
	 */
	getZ(index: number): number;
	/**
	 * Sets the z component of the vector at the given index.
	 * @param index Expects a `Integer`
	 * @param z
	 */
	setZ(index: number, z: number): this;
	/**
	 * Returns the w component of the vector at the given index.
	 * @param index Expects a `Integer`
	 */
	getW(index: number): number;
	/**
	 * Sets the w component of the vector at the given index.
	 * @param index Expects a `Integer`
	 * @param w
	 */
	setW(index: number, z: number): this;
	/**
	 * Sets the x and y components of the vector at the given index.
	 * @param index Expects a `Integer`
	 * @param x
	 * @param y
	 */
	setXY(index: number, x: number, y: number): this;
	/**
	 * Sets the x, y and z components of the vector at the given index.
	 * @param index Expects a `Integer`
	 * @param x
	 * @param y
	 * @param z
	 */
	setXYZ(index: number, x: number, y: number, z: number): this;
	/**
	 * Sets the x, y, z and w components of the vector at the given index.
	 * @param index Expects a `Integer`
	 * @param x
	 * @param y
	 * @param z
	 * @param w
	 */
	setXYZW(index: number, x: number, y: number, z: number, w: number): this;
	/**
	 * Convert this object to three.js to the `data.attributes` part of {@link https://github.com/mrdoob/three.js/wiki/JSON-Geometry-format-4 | JSON Geometry format v4},
	 */
	toJSON(): {
		itemSize: number;
		type: string;
		array: number[];
		normalized: boolean;
	};
}
declare class InterleavedBuffer {
	/**
	 * Create a new instance of {@link InterleavedBuffer}
	 * @param array A {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray | TypedArray} with a shared buffer. Stores the geometry data.
	 * @param stride The number of typed-array elements per vertex. Expects a `Integer`
	 */
	constructor(array: ArrayLike<number>, stride: number);
	/**
	 * A {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray | TypedArray} with a shared buffer. Stores the geometry data.
	 */
	array: ArrayLike<number>;
	/**
	 * The number of {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray | TypedArray} elements per vertex.
	 * @remarks Expects a `Integer`
	 */
	stride: number;
	/**
	 * Defines the intended usage pattern of the data store for optimization purposes.
	 * Corresponds to the {@link BufferAttribute.usage | usage} parameter of
	 * {@link https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/bufferData | WebGLRenderingContext.bufferData}.
	 * @remarks
	 * After the initial use of a buffer, its usage cannot be changed. Instead, instantiate a new one and set the desired usage before the next render.
	 * @see {@link https://threejs.org/docs/index.html#api/en/constants/BufferAttributeUsage | Buffer Attribute Usage Constants} for all possible values.
	 * @see {@link BufferAttribute.setUsage | setUsage}
	 * @defaultValue {@link StaticDrawUsage | THREE.StaticDrawUsage}.
	 */
	usage: Usage;
	/**
	 * Object containing offset and count.
	 * @defaultValue `{ offset: number = 0; count: number = -1 }`
	 */
	updateRange: {
		/** @defaultValue `0` */
		offset: number;
		/** @defaultValue `-1` */
		count: number;
	};
	/**
	 * A version number, incremented every time the {@link BufferAttribute.needsUpdate | needsUpdate} property is set to true.
	 * @remarks Expects a `Integer`
	 * @defaultValue `0`
	 */
	version: number;
	/**
	 * Gives the total number of elements in the array.
	 * @remarks Expects a `Integer`
	 * @defaultValue 0
	 */
	count: number;
	/**
	 * Flag to indicate that this attribute has changed and should be re-sent to the GPU.
	 * Set this to true when you modify the value of the array.
	 * @remarks Setting this to true also increments the {@link BufferAttribute.version | version}.
	 * @remarks _set-only property_.
	 */
	set needsUpdate(value: boolean);
	/**
	 * {@link http://en.wikipedia.org/wiki/Universally_unique_identifier | UUID} of this object instance.
	 * @remarks This gets automatically assigned and shouldn't be edited.
	 */
	uuid: string;
	/**
	 * Calls {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray/set | TypedArray.set}( {@link value}, {@link offset} )
	 * on the {@link BufferAttribute.array | array}.
	 * @param value The source `TypedArray`.
	 * @param offset index of the {@link BufferAttribute.array | array} at which to start copying. Expects a `Integer`. Default `0`.
	 * @throws `RangeError` When {@link offset} is negative or is too large.
	 */
	set(value: ArrayLike<number>, offset: number): this;
	/**
	 * Set {@link BufferAttribute.usage | usage}
	 * @remarks
	 * After the initial use of a buffer, its usage cannot be changed. Instead, instantiate a new one and set the desired usage before the next render.
	 * @see {@link https://threejs.org/docs/index.html#api/en/constants/BufferAttributeUsage | Buffer Attribute Usage Constants} for all possible values.
	 * @see {@link BufferAttribute.usage | usage}
	 * @param value Corresponds to the {@link BufferAttribute.usage | usage} parameter of
	 * {@link https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/bufferData | WebGLRenderingContext.bufferData}.
	 */
	setUsage(value: Usage): this;
	/**
	 * Copies another {@link InterleavedBuffer} to this {@link InterleavedBuffer} instance.
	 * @param source
	 */
	copy(source: InterleavedBuffer): this;
	/**
	 * Copies data from {@link attribute}[{@link index2}] to {@link InterleavedBuffer.array | array}[{@link index1}].
	 * @param index1 Expects a `Integer`
	 * @param attribute
	 * @param index2 Expects a `Integer`
	 */
	copyAt(index1: number, attribute: InterleavedBufferAttribute, index2: number): this;
	/**
	 * Creates a clone of this {@link InterleavedBuffer}.
	 * @param data This object holds shared array buffers required for properly cloning geometries with interleaved attributes.
	 */
	clone(data: {}): InterleavedBuffer;
	/**
	 * Serializes this {@link InterleavedBuffer}.
	 * Converting to {@link https://github.com/mrdoob/three.js/wiki/JSON-Geometry-format-4 | JSON Geometry format v4},
	 * @param data This object holds shared array buffers required for properly serializing geometries with interleaved attributes.
	 */
	toJSON(data: {}): {
		uuid: string;
		buffer: string;
		type: string;
		stride: number;
	};
}
declare class InterleavedBufferAttribute {
	/**
	 * Create a new instance of {@link InterleavedBufferAttribute | InterleavedBufferAttribute}.
	 * @param interleavedBuffer
	 * @param itemSize
	 * @param offset
	 * @param normalized Default `false`.
	 */
	constructor(interleavedBuffer: InterleavedBuffer, itemSize: number, offset: number, normalized?: boolean);
	/**
	 * Optional name for this attribute instance.
	 * @defaultValue `''`
	 */
	name: string;
	/**
	 * The {@link InterleavedBuffer | InterleavedBuffer} instance passed in the constructor.
	 */
	data: InterleavedBuffer;
	/**
	 * How many values make up each item.
	 * @remarks Expects a `Integer`
	 */
	itemSize: number;
	/**
	 * The offset in the underlying array buffer where an item starts.
	 * @remarks Expects a `Integer`
	 */
	offset: number;
	/**
	 * @defaultValue `false`
	 */
	normalized: boolean;
	/**
	 * The value of {@link data | .data}.{@link InterleavedBuffer.count | count}.
	 * If the buffer is storing a 3-component item (such as a _position, normal, or color_), then this will count the number of such items stored.
	 * @remarks _get-only property_.
	 * @remarks Expects a `Integer`
	 */
	get count(): number;
	/**
	 * The value of {@link InterleavedBufferAttribute.data | data}.{@link InterleavedBuffer.array | array}.
	 * @remarks _get-only property_.
	 */
	get array(): ArrayLike<number>;
	/**
	 * Flag to indicate that the {@link data | .data} ({@link InterleavedBuffer}) attribute has changed and should be re-sent to the GPU.
	 * @remarks Setting this to have the same result of setting true also increments the {@link InterleavedBuffer.needsUpdate | InterleavedBuffer.needsUpdate} of {@link data | .data}.
	 * @remarks Setting this to true also increments the {@link InterleavedBuffer.version | InterleavedBuffer.version}.
	 * @remarks _set-only property_.
	 */
	set needsUpdate(value: boolean);
	/**
	 * Read-only flag to check if a given object is of type {@link InterleavedBufferAttribute}.
	 * @remarks This is a _constant_ value
	 * @defaultValue `true`
	 */
	readonly isInterleavedBufferAttribute: true;
	/**
	 * Applies matrix {@link Matrix4 | m} to every Vector3 element of this InterleavedBufferAttribute.
	 * @param m
	 */
	applyMatrix4(m: Matrix4): this;
	/**
	 * Applies normal matrix {@link Matrix3 | m} to every Vector3 element of this InterleavedBufferAttribute.
	 * @param m
	 */
	applyNormalMatrix(matrix: Matrix): this;
	/**
	 * Applies matrix {@link Matrix4 | m} to every Vector3 element of this InterleavedBufferAttribute, interpreting the elements as a direction vectors.
	 * @param m
	 */
	transformDirection(matrix: Matrix): this;
	/**
	 * Returns the x component of the item at the given index.
	 * @param index Expects a `Integer`
	 */
	getX(index: number): number;
	/**
	 * Sets the x component of the item at the given index.
	 * @param index Expects a `Integer`
	 * @param x Expects a `Float`
	 */
	setX(index: number, x: number): this;
	/**
	 * Returns the y component of the item at the given index.
	 * @param index Expects a `Integer`
	 */
	getY(index: number): number;
	/**
	 * Sets the y component of the item at the given index.
	 * @param index Expects a `Integer`
	 * @param y Expects a `Float`
	 */
	setY(index: number, y: number): this;
	/**
	 * Returns the z component of the item at the given index.
	 * @param index Expects a `Integer`
	 */
	getZ(index: number): number;
	/**
	 * Sets the z component of the item at the given index.
	 * @param index Expects a `Integer`
	 * @param z Expects a `Float`
	 */
	setZ(index: number, z: number): this;
	/**
	 * Returns the w component of the item at the given index.
	 * @param index Expects a `Integer`
	 */
	getW(index: number): number;
	/**
	 * Sets the w component of the item at the given index.
	 * @param index Expects a `Integer`
	 * @param w Expects a `Float`
	 */
	setW(index: number, z: number): this;
	/**
	 * Sets the x and y components of the item at the given index.
	 * @param index Expects a `Integer`
	 * @param x Expects a `Float`
	 * @param y Expects a `Float`
	 */
	setXY(index: number, x: number, y: number): this;
	/**
	 * Sets the x, y and z components of the item at the given index.
	 * @param index Expects a `Integer`
	 * @param x Expects a `Float`
	 * @param y Expects a `Float`
	 * @param z Expects a `Float`
	 */
	setXYZ(index: number, x: number, y: number, z: number): this;
	/**
	 * Sets the x, y, z and w components of the item at the given index.
	 * @param index Expects a `Integer`
	 * @param x Expects a `Float`
	 * @param y Expects a `Float`
	 * @param z Expects a `Float`
	 * @param w Expects a `Float`
	 */
	setXYZW(index: number, x: number, y: number, z: number, w: number): this;
	/**
	 * Creates a clone of this {@link InterleavedBufferAttribute}.
	 * @param data This object holds shared array buffers required for properly cloning geometries with interleaved attributes.
	 */
	clone(data?: {}): BufferAttribute;
	/**
	 * Serializes this {@link InterleavedBufferAttribute}.
	 * Converting to {@link https://github.com/mrdoob/three.js/wiki/JSON-Geometry-format-4 | JSON Geometry format v4},
	 * @param data This object holds shared array buffers required for properly serializing geometries with interleaved attributes.
	 */
	toJSON(data?: {}): {
		isInterleavedBufferAttribute: true;
		itemSize: number;
		data: string;
		offset: number;
		normalized: boolean;
	};
}
declare class Quaternion {
	/**
	 * @param x x coordinate
	 * @param y y coordinate
	 * @param z z coordinate
	 * @param w w coordinate
	 */
	constructor(x?: number, y?: number, z?: number, w?: number);
	/**
	 * @default 0
	 */
	x: number;
	/**
	 * @default 0
	 */
	y: number;
	/**
	 * @default 0
	 */
	z: number;
	/**
	 * @default 1
	 */
	w: number;
	readonly isQuaternion: true;
	/**
	 * Sets values of this quaternion.
	 */
	set(x: number, y: number, z: number, w: number): Quaternion;
	/**
	 * Clones this quaternion.
	 */
	clone(): this;
	/**
	 * Copies values of q to this quaternion.
	 */
	copy(q: Quaternion): this;
	/**
	 * Sets this quaternion from rotation specified by Euler angles.
	 */
	setFromEuler(euler: Euler, update?: boolean): Quaternion;
	/**
	 * Sets this quaternion from rotation specified by axis and angle.
	 * Adapted from http://www.euclideanspace.com/maths/geometry/rotations/conversions/angleToQuaternion/index.htm.
	 * Axis have to be normalized, angle is in radians.
	 */
	setFromAxisAngle(axis: Vector3, angle: number): Quaternion;
	/**
	 * Sets this quaternion from rotation component of m. Adapted from http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToQuaternion/index.htm.
	 */
	setFromRotationMatrix(m: Matrix4): Quaternion;
	setFromUnitVectors(vFrom: Vector3, vTo: Vector3): Quaternion;
	angleTo(q: Quaternion): number;
	rotateTowards(q: Quaternion, step: number): Quaternion;
	identity(): Quaternion;
	/**
	 * Inverts this quaternion.
	 */
	invert(): Quaternion;
	conjugate(): Quaternion;
	dot(v: Quaternion): number;
	lengthSq(): number;
	/**
	 * Computes length of this quaternion.
	 */
	length(): number;
	/**
	 * Normalizes this quaternion.
	 */
	normalize(): Quaternion;
	/**
	 * Multiplies this quaternion by b.
	 */
	multiply(q: Quaternion): Quaternion;
	premultiply(q: Quaternion): Quaternion;
	/**
	 * Sets this quaternion to a x b
	 * Adapted from http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/code/index.htm.
	 */
	multiplyQuaternions(a: Quaternion, b: Quaternion): Quaternion;
	slerp(qb: Quaternion, t: number): Quaternion;
	slerpQuaternions(qa: Quaternion, qb: Quaternion, t: number): Quaternion;
	equals(v: Quaternion): boolean;
	/**
	 * Sets this quaternion's x, y, z and w value from the provided array or array-like.
	 * @param array the source array or array-like.
	 * @param offset (optional) offset into the array. Default is 0.
	 */
	fromArray(array: number[] | ArrayLike<number>, offset?: number): this;
	/**
	 * Returns an array [x, y, z, w], or copies x, y, z and w into the provided array.
	 * @param array (optional) array to store the quaternion to. If this is not provided, a new array will be created.
	 * @param offset (optional) optional offset into the array.
	 * @return The created or provided array.
	 */
	toArray(array?: number[], offset?: number): number[];
	/**
	 * Copies x, y, z and w into the provided array-like.
	 * @param array array-like to store the quaternion to.
	 * @param offset (optional) optional offset into the array.
	 * @return The provided array-like.
	 */
	toArray(array: ArrayLike<number>, offset?: number): ArrayLike<number>;
	/**
	 * This method defines the serialization result of Quaternion.
	 * @return The numerical elements of this quaternion in an array of format [x, y, z, w].
	 */
	toJSON(): [
		number,
		number,
		number,
		number
	];
	/**
	 * Sets x, y, z, w properties of this quaternion from the attribute.
	 * @param attribute the source attribute.
	 * @param index index in the attribute.
	 */
	fromBufferAttribute(attribute: BufferAttribute | InterleavedBufferAttribute, index: number): Quaternion;
	_onChange(callback: () => void): Quaternion;
	_onChangeCallback: () => void;
	static slerpFlat(dst: number[], dstOffset: number, src0: number[], srcOffset: number, src1: number[], stcOffset1: number, t: number): void;
	static multiplyQuaternionsFlat(dst: number[], dstOffset: number, src0: number[], srcOffset: number, src1: number[], stcOffset1: number): number[];
	/**
	 * @deprecated Use qm.slerpQuaternions( qa, qb, t ) instead..
	 */
	static slerp(qa: Quaternion, qb: Quaternion, qm: Quaternion, t: number): number;
	/**
	 * @deprecated Use {@link Vector#applyQuaternion vector.applyQuaternion( quaternion )} instead.
	 */
	multiplyVector3(v: any): any;
	random(): Quaternion;
	[Symbol.iterator](): Generator<number, void>;
}
type Matrix4Tuple = [
	number,
	number,
	number,
	number,
	number,
	number,
	number,
	number,
	number,
	number,
	number,
	number,
	number,
	number,
	number,
	number
];
declare class Matrix4 implements Matrix {
	constructor();
	/**
	 * Array with matrix values.
	 * @default [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]
	 */
	elements: number[];
	/**
	 * Sets all fields of this matrix.
	 */
	set(n11: number, n12: number, n13: number, n14: number, n21: number, n22: number, n23: number, n24: number, n31: number, n32: number, n33: number, n34: number, n41: number, n42: number, n43: number, n44: number): Matrix4;
	/**
	 * Resets this matrix to identity.
	 */
	identity(): Matrix4;
	clone(): Matrix4;
	copy(m: Matrix4): this;
	copyPosition(m: Matrix4): Matrix4;
	extractBasis(xAxis: Vector3, yAxis: Vector3, zAxis: Vector3): Matrix4;
	makeBasis(xAxis: Vector3, yAxis: Vector3, zAxis: Vector3): Matrix4;
	/**
	 * Copies the rotation component of the supplied matrix m into this matrix rotation component.
	 */
	extractRotation(m: Matrix4): Matrix4;
	makeRotationFromEuler(euler: Euler): Matrix4;
	makeRotationFromQuaternion(q: Quaternion): Matrix4;
	/**
	 * Constructs a rotation matrix, looking from eye towards center with defined up vector.
	 */
	lookAt(eye: Vector3, target: Vector3, up: Vector3): Matrix4;
	/**
	 * Multiplies this matrix by m.
	 */
	multiply(m: Matrix4): Matrix4;
	premultiply(m: Matrix4): Matrix4;
	/**
	 * Sets this matrix to a x b.
	 */
	multiplyMatrices(a: Matrix4, b: Matrix4): Matrix4;
	/**
	 * Sets this matrix to a x b and stores the result into the flat array r.
	 * r can be either a regular Array or a TypedArray.
	 *
	 * @deprecated This method has been removed completely.
	 */
	multiplyToArray(a: Matrix4, b: Matrix4, r: number[]): Matrix4;
	/**
	 * Multiplies this matrix by s.
	 */
	multiplyScalar(s: number): Matrix4;
	/**
	 * Computes determinant of this matrix.
	 * Based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm
	 */
	determinant(): number;
	/**
	 * Transposes this matrix.
	 */
	transpose(): Matrix4;
	/**
	 * Sets the position component for this matrix from vector v.
	 */
	setPosition(v: Vector3 | number, y?: number, z?: number): Matrix4;
	/**
	 * Inverts this matrix.
	 */
	invert(): Matrix4;
	/**
	 * Multiplies the columns of this matrix by vector v.
	 */
	scale(v: Vector3): Matrix4;
	getMaxScaleOnAxis(): number;
	/**
	 * Sets this matrix as translation transform.
	 */
	makeTranslation(x: number, y: number, z: number): Matrix4;
	/**
	 * Sets this matrix as rotation transform around x axis by theta radians.
	 *
	 * @param theta Rotation angle in radians.
	 */
	makeRotationX(theta: number): Matrix4;
	/**
	 * Sets this matrix as rotation transform around y axis by theta radians.
	 *
	 * @param theta Rotation angle in radians.
	 */
	makeRotationY(theta: number): Matrix4;
	/**
	 * Sets this matrix as rotation transform around z axis by theta radians.
	 *
	 * @param theta Rotation angle in radians.
	 */
	makeRotationZ(theta: number): Matrix4;
	/**
	 * Sets this matrix as rotation transform around axis by angle radians.
	 * Based on http://www.gamedev.net/reference/articles/article1199.asp.
	 *
	 * @param axis Rotation axis.
	 * @param theta Rotation angle in radians.
	 */
	makeRotationAxis(axis: Vector3, angle: number): Matrix4;
	/**
	 * Sets this matrix as scale transform.
	 */
	makeScale(x: number, y: number, z: number): Matrix4;
	/**
	 * Sets this matrix as shear transform.
	 */
	makeShear(xy: number, xz: number, yx: number, yz: number, zx: number, zy: number): Matrix4;
	/**
	 * Sets this matrix to the transformation composed of translation, rotation and scale.
	 */
	compose(translation: Vector3, rotation: Quaternion, scale: Vector3): Matrix4;
	/**
	 * Decomposes this matrix into it's position, quaternion and scale components.
	 */
	decompose(translation: Vector3, rotation: Quaternion, scale: Vector3): Matrix4;
	/**
	 * Creates a frustum matrix.
	 */
	makePerspective(left: number, right: number, bottom: number, top: number, near: number, far: number): Matrix4;
	/**
	 * Creates a perspective projection matrix.
	 */
	makePerspective(fov: number, aspect: number, near: number, far: number): Matrix4;
	/**
	 * Creates an orthographic projection matrix.
	 */
	makeOrthographic(left: number, right: number, top: number, bottom: number, near: number, far: number): Matrix4;
	equals(matrix: Matrix4): boolean;
	/**
	 * Sets the values of this matrix from the provided array or array-like.
	 * @param array the source array or array-like.
	 * @param offset (optional) offset into the array-like. Default is 0.
	 */
	fromArray(array: number[] | ArrayLike<number>, offset?: number): Matrix4;
	/**
	 * Returns an array with the values of this matrix, or copies them into the provided array.
	 * @param array (optional) array to store the matrix to. If this is not provided, a new array will be created.
	 * @param offset (optional) optional offset into the array.
	 * @return The created or provided array.
	 */
	toArray(array?: number[], offset?: number): number[];
	toArray(array?: Matrix4Tuple, offset?: 0): Matrix4Tuple;
	/**
	 * Copies he values of this matrix into the provided array-like.
	 * @param array array-like to store the matrix to.
	 * @param offset (optional) optional offset into the array-like.
	 * @return The provided array-like.
	 */
	toArray(array?: ArrayLike<number>, offset?: number): ArrayLike<number>;
	/**
	 * Set the upper 3x3 elements of this matrix to the values of the Matrix3 m.
	 */
	setFromMatrix3(m: Matrix3): Matrix4;
	/**
	 * @deprecated Use {@link Matrix4#copyPosition .copyPosition()} instead.
	 */
	extractPosition(m: Matrix4): Matrix4;
	/**
	 * @deprecated Use {@link Matrix4#makeRotationFromQuaternion .makeRotationFromQuaternion()} instead.
	 */
	setRotationFromQuaternion(q: Quaternion): Matrix4;
	/**
	 * @deprecated Use {@link Vector3#applyMatrix4 vector.applyMatrix4( matrix )} instead.
	 */
	multiplyVector3(v: any): any;
	/**
	 * @deprecated Use {@link Vector4#applyMatrix4 vector.applyMatrix4( matrix )} instead.
	 */
	multiplyVector4(v: any): any;
	/**
	 * @deprecated This method has been removed completely.
	 */
	multiplyVector3Array(array: number[]): number[];
	/**
	 * @deprecated Use {@link Vector3#transformDirection Vector3.transformDirection( matrix )} instead.
	 */
	rotateAxis(v: any): void;
	/**
	 * @deprecated Use {@link Vector3#applyMatrix4 vector.applyMatrix4( matrix )} instead.
	 */
	crossVector(v: any): void;
	/**
	 * @deprecated Use {@link Matrix4#toArray .toArray()} instead.
	 */
	flattenToArrayOffset(array: number[], offset: number): number[];
	/**
	 * @deprecated Use {@link Matrix4#invert .invert()} instead.
	 */
	getInverse(matrix: Matrix): Matrix;
}
type EulerOrder = "XYZ" | "YXZ" | "ZXY" | "ZYX" | "YZX" | "XZY";
declare class Euler {
	constructor(x?: number, y?: number, z?: number, order?: EulerOrder);
	/**
	 * @default 0
	 */
	x: number;
	/**
	 * @default 0
	 */
	y: number;
	/**
	 * @default 0
	 */
	z: number;
	/**
	 * @default Euler.DEFAULT_ORDER
	 */
	order: EulerOrder;
	readonly isEuler: true;
	_onChangeCallback: () => void;
	set(x: number, y: number, z: number, order?: EulerOrder): Euler;
	clone(): this;
	copy(euler: Euler): this;
	setFromRotationMatrix(m: Matrix4, order?: EulerOrder, update?: boolean): Euler;
	setFromQuaternion(q: Quaternion, order?: EulerOrder, update?: boolean): Euler;
	setFromVector3(v: Vector3, order?: EulerOrder): Euler;
	reorder(newOrder: EulerOrder): Euler;
	equals(euler: Euler): boolean;
	fromArray(xyzo: [
		number,
		number,
		number,
		EulerOrder?,
		...any[]
	]): Euler;
	toArray(array?: Array<number | string | undefined>, offset?: number): Array<number | string | undefined>;
	_onChange(callback: () => void): this;
	static DEFAULT_ORDER: "XYZ";
	[Symbol.iterator](): Generator<string | number, void>;
}
declare class Layers {
	/**
	 * Create a new Layers object, with membership initially set to layer 0.
	 */
	constructor();
	/**
	 * A bit mask storing which of the 32 layers this layers object is currently a member of.
	 * @defaultValue `1 | 0`
	 * @remarks Expects a `Integer`
	 */
	mask: number;
	/**
	 * Set membership to `layer`, and remove membership all other layers.
	 * @param layer An integer from 0 to 31.
	 */
	set(layer: number): void;
	/**
	 * Add membership of this `layer`.
	 * @param layer An integer from 0 to 31.
	 */
	enable(layer: number): void;
	/**
	 * Add membership to all layers.
	 */
	enableAll(): void;
	/**
	 * Toggle membership of `layer`.
	 * @param layer An integer from 0 to 31.
	 */
	toggle(layer: number): void;
	/**
	 * Remove membership of this `layer`.
	 * @param layer An integer from 0 to 31.
	 */
	disable(layer: number): void;
	/**
	 * Remove membership from all layers.
	 */
	disableAll(): void;
	/**
	 * Returns true if this and the passed `layers` object have at least one layer in common.
	 * @param layers A Layers object
	 */
	test(layers: Layers): boolean;
	/**
	 * Returns true if the given layer is enabled.
	 * @param layer An integer from 0 to 31.
	 */
	isEnabled(layer: number): boolean;
}
declare const _colorKeywords: {
	aliceblue: 15792383;
	antiquewhite: 16444375;
	aqua: 65535;
	aquamarine: 8388564;
	azure: 15794175;
	beige: 16119260;
	bisque: 16770244;
	black: 0;
	blanchedalmond: 16772045;
	blue: 255;
	blueviolet: 9055202;
	brown: 10824234;
	burlywood: 14596231;
	cadetblue: 6266528;
	chartreuse: 8388352;
	chocolate: 13789470;
	coral: 16744272;
	cornflowerblue: 6591981;
	cornsilk: 16775388;
	crimson: 14423100;
	cyan: 65535;
	darkblue: 139;
	darkcyan: 35723;
	darkgoldenrod: 12092939;
	darkgray: 11119017;
	darkgreen: 25600;
	darkgrey: 11119017;
	darkkhaki: 12433259;
	darkmagenta: 9109643;
	darkolivegreen: 5597999;
	darkorange: 16747520;
	darkorchid: 10040012;
	darkred: 9109504;
	darksalmon: 15308410;
	darkseagreen: 9419919;
	darkslateblue: 4734347;
	darkslategray: 3100495;
	darkslategrey: 3100495;
	darkturquoise: 52945;
	darkviolet: 9699539;
	deeppink: 16716947;
	deepskyblue: 49151;
	dimgray: 6908265;
	dimgrey: 6908265;
	dodgerblue: 2003199;
	firebrick: 11674146;
	floralwhite: 16775920;
	forestgreen: 2263842;
	fuchsia: 16711935;
	gainsboro: 14474460;
	ghostwhite: 16316671;
	gold: 16766720;
	goldenrod: 14329120;
	gray: 8421504;
	green: 32768;
	greenyellow: 11403055;
	grey: 8421504;
	honeydew: 15794160;
	hotpink: 16738740;
	indianred: 13458524;
	indigo: 4915330;
	ivory: 16777200;
	khaki: 15787660;
	lavender: 15132410;
	lavenderblush: 16773365;
	lawngreen: 8190976;
	lemonchiffon: 16775885;
	lightblue: 11393254;
	lightcoral: 15761536;
	lightcyan: 14745599;
	lightgoldenrodyellow: 16448210;
	lightgray: 13882323;
	lightgreen: 9498256;
	lightgrey: 13882323;
	lightpink: 16758465;
	lightsalmon: 16752762;
	lightseagreen: 2142890;
	lightskyblue: 8900346;
	lightslategray: 7833753;
	lightslategrey: 7833753;
	lightsteelblue: 11584734;
	lightyellow: 16777184;
	lime: 65280;
	limegreen: 3329330;
	linen: 16445670;
	magenta: 16711935;
	maroon: 8388608;
	mediumaquamarine: 6737322;
	mediumblue: 205;
	mediumorchid: 12211667;
	mediumpurple: 9662683;
	mediumseagreen: 3978097;
	mediumslateblue: 8087790;
	mediumspringgreen: 64154;
	mediumturquoise: 4772300;
	mediumvioletred: 13047173;
	midnightblue: 1644912;
	mintcream: 16121850;
	mistyrose: 16770273;
	moccasin: 16770229;
	navajowhite: 16768685;
	navy: 128;
	oldlace: 16643558;
	olive: 8421376;
	olivedrab: 7048739;
	orange: 16753920;
	orangered: 16729344;
	orchid: 14315734;
	palegoldenrod: 15657130;
	palegreen: 10025880;
	paleturquoise: 11529966;
	palevioletred: 14381203;
	papayawhip: 16773077;
	peachpuff: 16767673;
	peru: 13468991;
	pink: 16761035;
	plum: 14524637;
	powderblue: 11591910;
	purple: 8388736;
	rebeccapurple: 6697881;
	red: 16711680;
	rosybrown: 12357519;
	royalblue: 4286945;
	saddlebrown: 9127187;
	salmon: 16416882;
	sandybrown: 16032864;
	seagreen: 3050327;
	seashell: 16774638;
	sienna: 10506797;
	silver: 12632256;
	skyblue: 8900331;
	slateblue: 6970061;
	slategray: 7372944;
	slategrey: 7372944;
	snow: 16775930;
	springgreen: 65407;
	steelblue: 4620980;
	tan: 13808780;
	teal: 32896;
	thistle: 14204888;
	tomato: 16737095;
	turquoise: 4251856;
	violet: 15631086;
	wheat: 16113331;
	white: 16777215;
	whitesmoke: 16119285;
	yellow: 16776960;
	yellowgreen: 10145074;
};
type ColorRepresentation = Color | string | number;
interface HSL {
	h: number;
	s: number;
	l: number;
}
interface RGB {
	r: number;
	g: number;
	b: number;
}
declare class Color {
	constructor(color?: ColorRepresentation);
	constructor(r: number, g: number, b: number);
	readonly isColor: true;
	/**
	 * Red channel value between 0 and 1. Default is 1.
	 * @default 1
	 */
	r: number;
	/**
	 * Green channel value between 0 and 1. Default is 1.
	 * @default 1
	 */
	g: number;
	/**
	 * Blue channel value between 0 and 1. Default is 1.
	 * @default 1
	 */
	b: number;
	set(color: ColorRepresentation): Color;
	/**
	 * Sets this color's {@link r}, {@link g} and {@link b} components from the x, y, and z components of the specified
	 * {@link Vector3 | vector}.
	 */
	setFromVector3(vector: Vector3): this;
	setScalar(scalar: number): Color;
	setHex(hex: number, colorSpace?: ColorSpace): Color;
	/**
	 * Sets this color from RGB values.
	 * @param r Red channel value between 0 and 1.
	 * @param g Green channel value between 0 and 1.
	 * @param b Blue channel value between 0 and 1.
	 */
	setRGB(r: number, g: number, b: number, colorSpace?: ColorSpace): Color;
	/**
	 * Sets this color from HSL values.
	 * Based on MochiKit implementation by Bob Ippolito.
	 *
	 * @param h Hue channel value between 0 and 1.
	 * @param s Saturation value channel between 0 and 1.
	 * @param l Value channel value between 0 and 1.
	 */
	setHSL(h: number, s: number, l: number, colorSpace?: ColorSpace): Color;
	/**
	 * Sets this color from a CSS context style string.
	 * @param contextStyle Color in CSS context style format.
	 */
	setStyle(style: string, colorSpace?: ColorSpace): Color;
	/**
	 * Sets this color from a color name.
	 * Faster than {@link Color#setStyle .setStyle()} method if you don't need the other CSS-style formats.
	 * @param style Color name in X11 format.
	 */
	setColorName(style: string, colorSpace?: ColorSpace): Color;
	/**
	 * Clones this color.
	 */
	clone(): this;
	/**
	 * Copies given color.
	 * @param color Color to copy.
	 */
	copy(color: Color): this;
	/**
	 * Copies given color making conversion from sRGB to linear space.
	 * @param color Color to copy.
	 */
	copySRGBToLinear(color: Color): Color;
	/**
	 * Copies given color making conversion from linear to sRGB space.
	 * @param color Color to copy.
	 */
	copyLinearToSRGB(color: Color): Color;
	/**
	 * Converts this color from sRGB to linear space.
	 */
	convertSRGBToLinear(): Color;
	/**
	 * Converts this color from linear to sRGB space.
	 */
	convertLinearToSRGB(): Color;
	/**
	 * Returns the hexadecimal value of this color.
	 */
	getHex(colorSpace?: ColorSpace): number;
	/**
	 * Returns the string formated hexadecimal value of this color.
	 */
	getHexString(colorSpace?: ColorSpace): string;
	getHSL(target: HSL, colorSpace?: ColorSpace): HSL;
	getRGB(target: RGB, colorSpace?: ColorSpace): RGB;
	/**
	 * Returns the value of this color in CSS context style.
	 * Example: rgb(r, g, b)
	 */
	getStyle(colorSpace?: ColorSpace): string;
	offsetHSL(h: number, s: number, l: number): this;
	add(color: Color): this;
	addColors(color1: Color, color2: Color): this;
	addScalar(s: number): this;
	/**
	 * Applies the transform {@link Matrix3 | m} to this color's RGB components.
	 */
	applyMatrix3(m: Matrix3): this;
	sub(color: Color): this;
	multiply(color: Color): this;
	multiplyScalar(s: number): this;
	lerp(color: Color, alpha: number): this;
	lerpColors(color1: Color, color2: Color, alpha: number): this;
	lerpHSL(color: Color, alpha: number): this;
	equals(color: Color): boolean;
	/**
	 * Sets this color's red, green and blue value from the provided array or array-like.
	 * @param array the source array or array-like.
	 * @param offset (optional) offset into the array-like. Default is 0.
	 */
	fromArray(array: number[] | ArrayLike<number>, offset?: number): this;
	/**
	 * Returns an array [red, green, blue], or copies red, green and blue into the provided array.
	 * @param array (optional) array to store the color to. If this is not provided, a new array will be created.
	 * @param offset (optional) optional offset into the array.
	 * @return The created or provided array.
	 */
	toArray(array?: number[], offset?: number): number[];
	/**
	 * Copies red, green and blue into the provided array-like.
	 * @param array array-like to store the color to.
	 * @param offset (optional) optional offset into the array-like.
	 * @return The provided array-like.
	 */
	toArray(xyz: ArrayLike<number>, offset?: number): ArrayLike<number>;
	/**
	 * This method defines the serialization result of Color.
	 * @return The color as a hexadecimal value.
	 */
	toJSON(): number;
	fromBufferAttribute(attribute: BufferAttribute | InterleavedBufferAttribute, index: number): this;
	[Symbol.iterator](): Generator<number, void>;
	/**
	 * List of X11 color names.
	 */
	static NAMES: typeof _colorKeywords;
}
interface FogBase {
	/**
	 * Optional name of the `Fog` object
	 * @remarks _(doesn't need to be unique)_.
	 * @defaultValue `""`
	 */
	name: string;
	/**
	 * Fog color.
	 * @remarks If set to black, far away objects will be rendered black.
	 */
	color: Color;
	/**
	 * Returns a new Fog instance with the same parameters as this one.
	 */
	clone(): FogBase;
	/**
	 * Return Fog data in JSON format.
	 */
	toJSON(): any;
}
declare class Fog implements FogBase {
	/**
	 * The color parameter is passed to the {@link Color | Color} constructor to set the color property
	 * @remarks
	 * Color can be a hexadecimal integer or a CSS-style string.
	 * @param color
	 * @param near Expects a `Float`
	 * @param far Expects a `Float`
	 */
	constructor(color: ColorRepresentation, near?: number, far?: number);
	/**
	 * Read-only flag to check if a given object is of type {@link Fog}.
	 * @remarks This is a _constant_ value
	 * @defaultValue `true`
	 */
	readonly isFog: true;
	/**
	 * Optional name of the object
	 * @remarks _(doesn't need to be unique)_.
	 * @defaultValue `""`
	 */
	name: string;
	/**
	 * Fog color.
	 * @remarks If set to black, far away objects will be rendered black.
	 */
	color: Color;
	/**
	 * The minimum distance to start applying fog.
	 * @remarks Objects that are less than **near** units from the active camera won't be affected by fog.
	 * @defaultValue `1`
	 * @remarks Expects a `Float`
	 */
	near: number;
	/**
	 * The maximum distance at which fog stops being calculated and applied.
	 * @remarks Objects that are more than **far** units away from the active camera won't be affected by fog.
	 * @defaultValue `1000`
	 * @remarks Expects a `Float`
	 */
	far: number;
	/**
	 * Returns a new {@link Fog} instance with the same parameters as this one.
	 */
	clone(): Fog;
	/**
	 * Return {@link Fog} data in JSON format.
	 */
	toJSON(): any;
}
type Vector2Tuple = [
	number,
	number
];
/**
 * ( interface Vector<T> )
 *
 * Abstract interface of {@link https://github.com/mrdoob/three.js/blob/master/src/math/Vector2.js|Vector2},
 * {@link https://github.com/mrdoob/three.js/blob/master/src/math/Vector3.js|Vector3}
 * and {@link https://github.com/mrdoob/three.js/blob/master/src/math/Vector4.js|Vector4}.
 *
 * Currently the members of Vector is NOT type safe because it accepts different typed vectors.
 *
 * Those definitions will be changed when TypeScript innovates Generics to be type safe.
 *
 * @example
 * const v:Vector = new THREE.Vector3();
 * v.addVectors(new Vector2(0, 1), new THREE.Vector2(2, 3)); // invalid but compiled successfully
 */
interface Vector {
	setComponent(index: number, value: number): this;
	getComponent(index: number): number;
	set(...args: number[]): this;
	setScalar(scalar: number): this;
	/**
	 * copy(v:T):T;
	 */
	copy(v: Vector): this;
	/**
	 * NOTE: The second argument is deprecated.
	 *
	 * add(v:T):T;
	 */
	add(v: Vector): this;
	/**
	 * addVectors(a:T, b:T):T;
	 */
	addVectors(a: Vector, b: Vector): this;
	addScaledVector(vector: Vector, scale: number): this;
	/**
	 * Adds the scalar value s to this vector's values.
	 */
	addScalar(scalar: number): this;
	/**
	 * sub(v:T):T;
	 */
	sub(v: Vector): this;
	/**
	 * subVectors(a:T, b:T):T;
	 */
	subVectors(a: Vector, b: Vector): this;
	/**
	 * multiplyScalar(s:number):T;
	 */
	multiplyScalar(s: number): this;
	/**
	 * divideScalar(s:number):T;
	 */
	divideScalar(s: number): this;
	/**
	 * negate():T;
	 */
	negate(): this;
	/**
	 * dot(v:T):T;
	 */
	dot(v: Vector): number;
	/**
	 * lengthSq():number;
	 */
	lengthSq(): number;
	/**
	 * length():number;
	 */
	length(): number;
	/**
	 * normalize():T;
	 */
	normalize(): this;
	/**
	 * NOTE: Vector4 doesn't have the property.
	 *
	 * distanceTo(v:T):number;
	 */
	distanceTo?(v: Vector): number;
	/**
	 * NOTE: Vector4 doesn't have the property.
	 *
	 * distanceToSquared(v:T):number;
	 */
	distanceToSquared?(v: Vector): number;
	/**
	 * setLength(l:number):T;
	 */
	setLength(l: number): this;
	/**
	 * lerp(v:T, alpha:number):T;
	 */
	lerp(v: Vector, alpha: number): this;
	/**
	 * equals(v:T):boolean;
	 */
	equals(v: Vector): boolean;
	/**
	 * clone():T;
	 */
	clone(): Vector;
}
declare class Vector2 implements Vector {
	constructor(x?: number, y?: number);
	/**
	 * @default 0
	 */
	x: number;
	/**
	 * @default 0
	 */
	y: number;
	width: number;
	height: number;
	readonly isVector2: true;
	/**
	 * Sets value of this vector.
	 */
	set(x: number, y: number): this;
	/**
	 * Sets the x and y values of this vector both equal to scalar.
	 */
	setScalar(scalar: number): this;
	/**
	 * Sets X component of this vector.
	 */
	setX(x: number): this;
	/**
	 * Sets Y component of this vector.
	 */
	setY(y: number): this;
	/**
	 * Sets a component of this vector.
	 */
	setComponent(index: number, value: number): this;
	/**
	 * Gets a component of this vector.
	 */
	getComponent(index: number): number;
	/**
	 * Returns a new Vector2 instance with the same `x` and `y` values.
	 */
	clone(): this;
	/**
	 * Copies value of v to this vector.
	 */
	copy(v: Vector2): this;
	/**
	 * Adds v to this vector.
	 */
	add(v: Vector2, w?: Vector2): this;
	/**
	 * Adds the scalar value s to this vector's x and y values.
	 */
	addScalar(s: number): this;
	/**
	 * Sets this vector to a + b.
	 */
	addVectors(a: Vector2, b: Vector2): this;
	/**
	 * Adds the multiple of v and s to this vector.
	 */
	addScaledVector(v: Vector2, s: number): this;
	/**
	 * Subtracts v from this vector.
	 */
	sub(v: Vector2): this;
	/**
	 * Subtracts s from this vector's x and y components.
	 */
	subScalar(s: number): this;
	/**
	 * Sets this vector to a - b.
	 */
	subVectors(a: Vector2, b: Vector2): this;
	/**
	 * Multiplies this vector by v.
	 */
	multiply(v: Vector2): this;
	/**
	 * Multiplies this vector by scalar s.
	 */
	multiplyScalar(scalar: number): this;
	/**
	 * Divides this vector by v.
	 */
	divide(v: Vector2): this;
	/**
	 * Divides this vector by scalar s.
	 * Set vector to ( 0, 0 ) if s == 0.
	 */
	divideScalar(s: number): this;
	/**
	 * Multiplies this vector (with an implicit 1 as the 3rd component) by m.
	 */
	applyMatrix3(m: Matrix3): this;
	/**
	 * If this vector's x or y value is greater than v's x or y value, replace that value with the corresponding min value.
	 */
	min(v: Vector2): this;
	/**
	 * If this vector's x or y value is less than v's x or y value, replace that value with the corresponding max value.
	 */
	max(v: Vector2): this;
	/**
	 * If this vector's x or y value is greater than the max vector's x or y value, it is replaced by the corresponding value.
	 * If this vector's x or y value is less than the min vector's x or y value, it is replaced by the corresponding value.
	 * @param min the minimum x and y values.
	 * @param max the maximum x and y values in the desired range.
	 */
	clamp(min: Vector2, max: Vector2): this;
	/**
	 * If this vector's x or y values are greater than the max value, they are replaced by the max value.
	 * If this vector's x or y values are less than the min value, they are replaced by the min value.
	 * @param min the minimum value the components will be clamped to.
	 * @param max the maximum value the components will be clamped to.
	 */
	clampScalar(min: number, max: number): this;
	/**
	 * If this vector's length is greater than the max value, it is replaced by the max value.
	 * If this vector's length is less than the min value, it is replaced by the min value.
	 * @param min the minimum value the length will be clamped to.
	 * @param max the maximum value the length will be clamped to.
	 */
	clampLength(min: number, max: number): this;
	/**
	 * The components of the vector are rounded down to the nearest integer value.
	 */
	floor(): this;
	/**
	 * The x and y components of the vector are rounded up to the nearest integer value.
	 */
	ceil(): this;
	/**
	 * The components of the vector are rounded to the nearest integer value.
	 */
	round(): this;
	/**
	 * The components of the vector are rounded towards zero (up if negative, down if positive) to an integer value.
	 */
	roundToZero(): this;
	/**
	 * Inverts this vector.
	 */
	negate(): this;
	/**
	 * Computes dot product of this vector and v.
	 */
	dot(v: Vector2): number;
	/**
	 * Computes cross product of this vector and v.
	 */
	cross(v: Vector2): number;
	/**
	 * Computes squared length of this vector.
	 */
	lengthSq(): number;
	/**
	 * Computes length of this vector.
	 */
	length(): number;
	/**
	 * @deprecated Use {@link Vector2#manhattanLength .manhattanLength()} instead.
	 */
	lengthManhattan(): number;
	/**
	 * Computes the Manhattan length of this vector.
	 *
	 * see {@link http://en.wikipedia.org/wiki/Taxicab_geometry|Wikipedia: Taxicab Geometry}
	 */
	manhattanLength(): number;
	/**
	 * Normalizes this vector.
	 */
	normalize(): this;
	/**
	 * computes the angle in radians with respect to the positive x-axis
	 */
	angle(): number;
	/**
	 * Returns the angle between this vector and vector {@link Vector2 | v} in radians.
	 */
	angleTo(v: Vector2): number;
	/**
	 * Computes distance of this vector to v.
	 */
	distanceTo(v: Vector2): number;
	/**
	 * Computes squared distance of this vector to v.
	 */
	distanceToSquared(v: Vector2): number;
	/**
	 * @deprecated Use {@link Vector2#manhattanDistanceTo .manhattanDistanceTo()} instead.
	 */
	distanceToManhattan(v: Vector2): number;
	/**
	 * Computes the Manhattan length (distance) from this vector to the given vector v
	 *
	 * see {@link http://en.wikipedia.org/wiki/Taxicab_geometry|Wikipedia: Taxicab Geometry}
	 */
	manhattanDistanceTo(v: Vector2): number;
	/**
	 * Normalizes this vector and multiplies it by l.
	 */
	setLength(length: number): this;
	/**
	 * Linearly interpolates between this vector and v, where alpha is the distance along the line - alpha = 0 will be this vector, and alpha = 1 will be v.
	 * @param v vector to interpolate towards.
	 * @param alpha interpolation factor in the closed interval [0, 1].
	 */
	lerp(v: Vector2, alpha: number): this;
	/**
	 * Sets this vector to be the vector linearly interpolated between v1 and v2 where alpha is the distance along the line connecting the two vectors - alpha = 0 will be v1, and alpha = 1 will be v2.
	 * @param v1 the starting vector.
	 * @param v2 vector to interpolate towards.
	 * @param alpha interpolation factor in the closed interval [0, 1].
	 */
	lerpVectors(v1: Vector2, v2: Vector2, alpha: number): this;
	/**
	 * Checks for strict equality of this vector and v.
	 */
	equals(v: Vector2): boolean;
	/**
	 * Sets this vector's x and y value from the provided array or array-like.
	 * @param array the source array or array-like.
	 * @param offset (optional) offset into the array. Default is 0.
	 */
	fromArray(array: number[] | ArrayLike<number>, offset?: number): this;
	/**
	 * Returns an array [x, y], or copies x and y into the provided array.
	 * @param array (optional) array to store the vector to. If this is not provided, a new array will be created.
	 * @param offset (optional) optional offset into the array.
	 * @return The created or provided array.
	 */
	toArray(array?: number[], offset?: number): number[];
	toArray(array?: Vector2Tuple, offset?: 0): Vector2Tuple;
	/**
	 * Copies x and y into the provided array-like.
	 * @param array array-like to store the vector to.
	 * @param offset (optional) optional offset into the array.
	 * @return The provided array-like.
	 */
	toArray(array: ArrayLike<number>, offset?: number): ArrayLike<number>;
	/**
	 * Sets this vector's x and y values from the attribute.
	 * @param attribute the source attribute.
	 * @param index index in the attribute.
	 */
	fromBufferAttribute(attribute: BufferAttribute, index: number): this;
	/**
	 * Rotates the vector around center by angle radians.
	 * @param center the point around which to rotate.
	 * @param angle the angle to rotate, in radians.
	 */
	rotateAround(center: Vector2, angle: number): this;
	/**
	 * Sets this vector's x and y from Math.random
	 */
	random(): this;
}
type Vector4Tuple = [
	number,
	number,
	number,
	number
];
declare class Vector4 implements Vector {
	constructor(x?: number, y?: number, z?: number, w?: number);
	/**
	 * @default 0
	 */
	x: number;
	/**
	 * @default 0
	 */
	y: number;
	/**
	 * @default 0
	 */
	z: number;
	/**
	 * @default 0
	 */
	w: number;
	width: number;
	height: number;
	readonly isVector4: true;
	/**
	 * Sets value of this vector.
	 */
	set(x: number, y: number, z: number, w: number): this;
	/**
	 * Sets all values of this vector.
	 */
	setScalar(scalar: number): this;
	/**
	 * Sets X component of this vector.
	 */
	setX(x: number): this;
	/**
	 * Sets Y component of this vector.
	 */
	setY(y: number): this;
	/**
	 * Sets Z component of this vector.
	 */
	setZ(z: number): this;
	/**
	 * Sets w component of this vector.
	 */
	setW(w: number): this;
	setComponent(index: number, value: number): this;
	getComponent(index: number): number;
	/**
	 * Clones this vector.
	 */
	clone(): this;
	/**
	 * Copies value of v to this vector.
	 */
	copy(v: Vector4): this;
	/**
	 * Adds v to this vector.
	 */
	add(v: Vector4): this;
	addScalar(scalar: number): this;
	/**
	 * Sets this vector to a + b.
	 */
	addVectors(a: Vector4, b: Vector4): this;
	addScaledVector(v: Vector4, s: number): this;
	/**
	 * Subtracts v from this vector.
	 */
	sub(v: Vector4): this;
	subScalar(s: number): this;
	/**
	 * Sets this vector to a - b.
	 */
	subVectors(a: Vector4, b: Vector4): this;
	multiply(v: Vector4): this;
	/**
	 * Multiplies this vector by scalar s.
	 */
	multiplyScalar(s: number): this;
	applyMatrix4(m: Matrix4): this;
	/**
	 * Divides this vector by scalar s.
	 * Set vector to ( 0, 0, 0 ) if s == 0.
	 */
	divideScalar(s: number): this;
	/**
	 * http://www.euclideanspace.com/maths/geometry/rotations/conversions/quaternionToAngle/index.htm
	 * @param q is assumed to be normalized
	 */
	setAxisAngleFromQuaternion(q: Quaternion): this;
	/**
	 * http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToAngle/index.htm
	 * @param m assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)
	 */
	setAxisAngleFromRotationMatrix(m: Matrix4): this;
	min(v: Vector4): this;
	max(v: Vector4): this;
	clamp(min: Vector4, max: Vector4): this;
	clampScalar(min: number, max: number): this;
	floor(): this;
	ceil(): this;
	round(): this;
	roundToZero(): this;
	/**
	 * Inverts this vector.
	 */
	negate(): this;
	/**
	 * Computes dot product of this vector and v.
	 */
	dot(v: Vector4): number;
	/**
	 * Computes squared length of this vector.
	 */
	lengthSq(): number;
	/**
	 * Computes length of this vector.
	 */
	length(): number;
	/**
	 * Computes the Manhattan length of this vector.
	 *
	 * see {@link http://en.wikipedia.org/wiki/Taxicab_geometry|Wikipedia: Taxicab Geometry}
	 */
	manhattanLength(): number;
	/**
	 * Normalizes this vector.
	 */
	normalize(): this;
	/**
	 * Normalizes this vector and multiplies it by l.
	 */
	setLength(length: number): this;
	/**
	 * Linearly interpolate between this vector and v with alpha factor.
	 */
	lerp(v: Vector4, alpha: number): this;
	lerpVectors(v1: Vector4, v2: Vector4, alpha: number): this;
	/**
	 * Checks for strict equality of this vector and v.
	 */
	equals(v: Vector4): boolean;
	/**
	 * Sets this vector's x, y, z and w value from the provided array or array-like.
	 * @param array the source array or array-like.
	 * @param offset (optional) offset into the array. Default is 0.
	 */
	fromArray(array: number[] | ArrayLike<number>, offset?: number): this;
	/**
	 * Returns an array [x, y, z, w], or copies x, y, z and w into the provided array.
	 * @param array (optional) array to store the vector to. If this is not provided, a new array will be created.
	 * @param offset (optional) optional offset into the array.
	 * @return The created or provided array.
	 */
	toArray(array?: number[], offset?: number): number[];
	toArray(array?: Vector4Tuple, offset?: 0): Vector4Tuple;
	/**
	 * Copies x, y, z and w into the provided array-like.
	 * @param array array-like to store the vector to.
	 * @param offset (optional) optional offset into the array-like.
	 * @return The provided array-like.
	 */
	toArray(array: ArrayLike<number>, offset?: number): ArrayLike<number>;
	fromBufferAttribute(attribute: BufferAttribute, index: number): this;
	/**
	 * Sets this vector's x, y, z and w from Math.random
	 */
	random(): this;
}
declare class Triangle {
	constructor(a?: Vector3, b?: Vector3, c?: Vector3);
	/**
	 * @default new Vector3()
	 */
	a: Vector3;
	/**
	 * @default new Vector3()
	 */
	b: Vector3;
	/**
	 * @default new Vector3()
	 */
	c: Vector3;
	set(a: Vector3, b: Vector3, c: Vector3): Triangle;
	setFromPointsAndIndices(points: Vector3[], i0: number, i1: number, i2: number): this;
	setFromAttributeAndIndices(attribute: BufferAttribute | InterleavedBufferAttribute, i0: number, i1: number, i2: number): this;
	clone(): this;
	copy(triangle: Triangle): this;
	getArea(): number;
	getMidpoint(target: Vector3): Vector3;
	getNormal(target: Vector3): Vector3;
	getPlane(target: Plane): Plane;
	getBarycoord(point: Vector3, target: Vector3): Vector3;
	/**
	 * @deprecated Triangle.getUV() has been renamed to Triangle.getInterpolation().
	 */
	getUV(point: Vector3, uv1: Vector2, uv2: Vector2, uv3: Vector2, target: Vector2): Vector2;
	getInterpolation(point: Vector3, v1: Vector2, v2: Vector2, v3: Vector2, target: Vector2): Vector2;
	getInterpolation(point: Vector3, v1: Vector3, v2: Vector3, v3: Vector3, target: Vector3): Vector3;
	getInterpolation(point: Vector3, v1: Vector4, v2: Vector4, v3: Vector4, target: Vector4): Vector4;
	containsPoint(point: Vector3): boolean;
	intersectsBox(box: Box3): boolean;
	isFrontFacing(direction: Vector3): boolean;
	closestPointToPoint(point: Vector3, target: Vector3): Vector3;
	equals(triangle: Triangle): boolean;
	static getNormal(a: Vector3, b: Vector3, c: Vector3, target: Vector3): Vector3;
	static getBarycoord(point: Vector3, a: Vector3, b: Vector3, c: Vector3, target: Vector3): Vector3;
	static containsPoint(point: Vector3, a: Vector3, b: Vector3, c: Vector3): boolean;
	/**
	 * @deprecated Triangle.getUV() has been renamed to THREE.Triangle.getInterpolation().
	 */
	static getUV(point: Vector3, p1: Vector3, p2: Vector3, p3: Vector3, uv1: Vector2, uv2: Vector2, uv3: Vector2, target: Vector2): Vector2;
	static getInterpolation(point: Vector3, p1: Vector3, p2: Vector3, p3: Vector3, v1: Vector2, v2: Vector2, v3: Vector2, target: Vector2): Vector2;
	static getInterpolation(point: Vector3, p1: Vector3, p2: Vector3, p3: Vector3, v1: Vector3, v2: Vector3, v3: Vector3, target: Vector3): Vector3;
	static getInterpolation(point: Vector3, p1: Vector3, p2: Vector3, p3: Vector3, v1: Vector4, v2: Vector4, v3: Vector4, target: Vector4): Vector4;
	static isFrontFacing(a: Vector3, b: Vector3, c: Vector3, direction: Vector3): boolean;
}
declare class Box3 {
	constructor(min?: Vector3, max?: Vector3);
	/**
	 * @default new Vector3( + Infinity, + Infinity, + Infinity )
	 */
	min: Vector3;
	/**
	 * @default new Vector3( - Infinity, - Infinity, - Infinity )
	 */
	max: Vector3;
	readonly isBox3: true;
	set(min: Vector3, max: Vector3): this;
	setFromArray(array: ArrayLike<number>): this;
	setFromBufferAttribute(bufferAttribute: BufferAttribute): this;
	setFromPoints(points: Vector3[]): this;
	setFromCenterAndSize(center: Vector3, size: Vector3): this;
	setFromObject(object: Object3D, precise?: boolean): this;
	clone(): this;
	copy(box: Box3): this;
	makeEmpty(): this;
	isEmpty(): boolean;
	getCenter(target: Vector3): Vector3;
	getSize(target: Vector3): Vector3;
	expandByPoint(point: Vector3): this;
	expandByVector(vector: Vector3): this;
	expandByScalar(scalar: number): this;
	expandByObject(object: Object3D, precise?: boolean): this;
	containsPoint(point: Vector3): boolean;
	containsBox(box: Box3): boolean;
	getParameter(point: Vector3, target: Vector3): Vector3;
	intersectsBox(box: Box3): boolean;
	intersectsSphere(sphere: Sphere): boolean;
	intersectsPlane(plane: Plane): boolean;
	intersectsTriangle(triangle: Triangle): boolean;
	clampPoint(point: Vector3, target: Vector3): Vector3;
	distanceToPoint(point: Vector3): number;
	getBoundingSphere(target: Sphere): Sphere;
	intersect(box: Box3): this;
	union(box: Box3): this;
	applyMatrix4(matrix: Matrix4): this;
	translate(offset: Vector3): this;
	equals(box: Box3): boolean;
	/**
	 * @deprecated Use {@link Box3#isEmpty .isEmpty()} instead.
	 */
	empty(): any;
	/**
	 * @deprecated Use {@link Box3#intersectsBox .intersectsBox()} instead.
	 */
	isIntersectionBox(b: any): any;
	/**
	 * @deprecated Use {@link Box3#intersectsSphere .intersectsSphere()} instead.
	 */
	isIntersectionSphere(s: any): any;
}
declare class Sphere {
	constructor(center?: Vector3, radius?: number);
	/**
	 * @default new Vector3()
	 */
	center: Vector3;
	/**
	 * @default 1
	 */
	radius: number;
	set(center: Vector3, radius: number): Sphere;
	setFromPoints(points: Vector3[], optionalCenter?: Vector3): Sphere;
	clone(): this;
	copy(sphere: Sphere): this;
	expandByPoint(point: Vector3): this;
	isEmpty(): boolean;
	makeEmpty(): this;
	containsPoint(point: Vector3): boolean;
	distanceToPoint(point: Vector3): number;
	intersectsSphere(sphere: Sphere): boolean;
	intersectsBox(box: Box3): boolean;
	intersectsPlane(plane: Plane): boolean;
	clampPoint(point: Vector3, target: Vector3): Vector3;
	getBoundingBox(target: Box3): Box3;
	applyMatrix4(matrix: Matrix4): Sphere;
	translate(offset: Vector3): Sphere;
	equals(sphere: Sphere): boolean;
	union(sphere: Sphere): this;
	/**
	 * @deprecated Use {@link Sphere#isEmpty .isEmpty()} instead.
	 */
	empty(): any;
}
declare class Line3 {
	constructor(start?: Vector3, end?: Vector3);
	/**
	 * @default new Vector3()
	 */
	start: Vector3;
	/**
	 * @default new Vector3()
	 */
	end: Vector3;
	set(start?: Vector3, end?: Vector3): Line3;
	clone(): this;
	copy(line: Line3): this;
	getCenter(target: Vector3): Vector3;
	delta(target: Vector3): Vector3;
	distanceSq(): number;
	distance(): number;
	at(t: number, target: Vector3): Vector3;
	closestPointToPointParameter(point: Vector3, clampToLine?: boolean): number;
	closestPointToPoint(point: Vector3, clampToLine: boolean, target: Vector3): Vector3;
	applyMatrix4(matrix: Matrix4): Line3;
	equals(line: Line3): boolean;
}
declare class Plane {
	constructor(normal?: Vector3, constant?: number);
	/**
	 * @default new Vector3( 1, 0, 0 )
	 */
	normal: Vector3;
	/**
	 * @default 0
	 */
	constant: number;
	readonly isPlane: true;
	set(normal: Vector3, constant: number): Plane;
	setComponents(x: number, y: number, z: number, w: number): Plane;
	setFromNormalAndCoplanarPoint(normal: Vector3, point: Vector3): Plane;
	setFromCoplanarPoints(a: Vector3, b: Vector3, c: Vector3): Plane;
	clone(): this;
	copy(plane: Plane): this;
	normalize(): Plane;
	negate(): Plane;
	distanceToPoint(point: Vector3): number;
	distanceToSphere(sphere: Sphere): number;
	projectPoint(point: Vector3, target: Vector3): Vector3;
	intersectLine(line: Line3, target: Vector3): Vector3 | null;
	intersectsLine(line: Line3): boolean;
	intersectsBox(box: Box3): boolean;
	intersectsSphere(sphere: Sphere): boolean;
	coplanarPoint(target: Vector3): Vector3;
	applyMatrix4(matrix: Matrix4, optionalNormalMatrix?: Matrix3): Plane;
	translate(offset: Vector3): Plane;
	equals(plane: Plane): boolean;
	/**
	 * @deprecated Use {@link Plane#intersectsLine .intersectsLine()} instead.
	 */
	isIntersectionLine(l: any): any;
}
interface BaseEvent {
	type: string;
}
/**
 * Event object.
 */
interface Event extends BaseEvent {
	// @ts-ignore
	target?: any;
	[attachment: string]: any;
}
// @ts-ignore
type EventListener<E, T, U> = (event: E & {
	type: T;
} & {
	target: U;
}) => void;
declare class EventDispatcher<E extends BaseEvent = Event> {
	/**
	 * Creates {@link EventDispatcher | EventDispatcher} object.
	 */
	constructor();
	/**
	 * Adds a listener to an event type.
	 * @param type The type of event to listen to.
	 * @param listener The function that gets called when the event is fired.
	 */
	 // @ts-ignore
	addEventListener<T extends E["type"]>(type: T, listener: EventListener<E, T, this>): void;
	/**
	 * Checks if listener is added to an event type.
	 * @param type The type of event to listen to.
	 * @param listener The function that gets called when the event is fired.
	 */
	 // @ts-ignore
	hasEventListener<T extends E["type"]>(type: T, listener: EventListener<E, T, this>): boolean;
	/**
	 * Removes a listener from an event type.
	 * @param type The type of the listener that gets removed.
	 * @param listener The listener function that gets removed.
	 */
	 // @ts-ignore
	removeEventListener<T extends E["type"]>(type: T, listener: EventListener<E, T, this>): void;
	/**
	 * Fire an event type.
	 * @param event The event that gets fired.
	 */
	dispatchEvent(event: E): void;
}
// tslint:disable-next-line:interface-name
interface IUniform<TValue = any> {
	value: TValue;
}
interface Shader {
	uniforms: {
		[uniform: string]: IUniform;
	};
	vertexShader: string;
	fragmentShader: string;
}
interface MaterialParameters {
	alphaTest?: number | undefined;
	alphaToCoverage?: boolean | undefined;
	blendDst?: BlendingDstFactor | undefined;
	blendDstAlpha?: number | undefined;
	blendEquation?: BlendingEquation | undefined;
	blendEquationAlpha?: number | undefined;
	blending?: Blending | undefined;
	blendSrc?: BlendingSrcFactor | BlendingDstFactor | undefined;
	blendSrcAlpha?: number | undefined;
	clipIntersection?: boolean | undefined;
	clippingPlanes?: Plane[] | undefined;
	clipShadows?: boolean | undefined;
	colorWrite?: boolean | undefined;
	defines?: any;
	depthFunc?: DepthModes | undefined;
	depthTest?: boolean | undefined;
	depthWrite?: boolean | undefined;
	name?: string | undefined;
	opacity?: number | undefined;
	polygonOffset?: boolean | undefined;
	polygonOffsetFactor?: number | undefined;
	polygonOffsetUnits?: number | undefined;
	precision?: "highp" | "mediump" | "lowp" | null | undefined;
	premultipliedAlpha?: boolean | undefined;
	forceSinglePass?: boolean | undefined;
	dithering?: boolean | undefined;
	side?: Side | undefined;
	shadowSide?: Side | undefined;
	toneMapped?: boolean | undefined;
	transparent?: boolean | undefined;
	vertexColors?: boolean | undefined;
	visible?: boolean | undefined;
	format?: PixelFormat | undefined;
	stencilWrite?: boolean | undefined;
	stencilFunc?: StencilFunc | undefined;
	stencilRef?: number | undefined;
	stencilWriteMask?: number | undefined;
	stencilFuncMask?: number | undefined;
	stencilFail?: StencilOp | undefined;
	stencilZFail?: StencilOp | undefined;
	stencilZPass?: StencilOp | undefined;
	userData?: any;
}
declare class Material extends EventDispatcher {
	constructor();
	/**
	 * Sets the alpha value to be used when running an alpha test. Default is 0.
	 * @default 0
	 */
	alphaTest: number;
	/**
	 * Enables alpha to coverage. Can only be used with MSAA-enabled rendering contexts.
	 * @default false
	 */
	alphaToCoverage: boolean;
	/**
	 * Blending destination. It's one of the blending mode constants defined in Three.js. Default is {@link OneMinusSrcAlphaFactor}.
	 * @default OneMinusSrcAlphaFactor
	 */
	blendDst: BlendingDstFactor;
	/**
	 * The tranparency of the .blendDst. Default is null.
	 * @default null
	 */
	blendDstAlpha: number | null;
	/**
	 * Blending equation to use when applying blending. It's one of the constants defined in Three.js. Default is {@link AddEquation}.
	 * @default AddEquation
	 */
	blendEquation: BlendingEquation;
	/**
	 * The tranparency of the .blendEquation. Default is null.
	 * @default null
	 */
	blendEquationAlpha: number | null;
	/**
	 * Which blending to use when displaying objects with this material. Default is {@link NormalBlending}.
	 * @default NormalBlending
	 */
	blending: Blending;
	/**
	 * Blending source. It's one of the blending mode constants defined in Three.js. Default is {@link SrcAlphaFactor}.
	 * @default SrcAlphaFactor
	 */
	blendSrc: BlendingSrcFactor | BlendingDstFactor;
	/**
	 * The tranparency of the .blendSrc. Default is null.
	 * @default null
	 */
	blendSrcAlpha: number | null;
	/**
	 * Changes the behavior of clipping planes so that only their intersection is clipped, rather than their union. Default is false.
	 * @default false
	 */
	clipIntersection: boolean;
	/**
	 * User-defined clipping planes specified as Plane objects in world space.
	 * These planes apply to the objects this material is attached to.
	 * Points in space whose signed distance to the plane is negative are clipped (not rendered).
	 * See the WebGL / clipping /intersection example. Default is null.
	 * @default null
	 */
	clippingPlanes: any;
	/**
	 * Defines whether to clip shadows according to the clipping planes specified on this material. Default is false.
	 * @default false
	 */
	clipShadows: boolean;
	/**
	 * Whether to render the material's color. This can be used in conjunction with a mesh's .renderOrder property to create invisible objects that occlude other objects. Default is true.
	 * @default true
	 */
	colorWrite: boolean;
	/**
	 * Custom defines to be injected into the shader. These are passed in form of an object literal, with key/value pairs. { MY_CUSTOM_DEFINE: '' , PI2: Math.PI * 2 }.
	 * The pairs are defined in both vertex and fragment shaders. Default is undefined.
	 * @default undefined
	 */
	defines: undefined | {
		[key: string]: any;
	};
	/**
	 * Which depth function to use. Default is {@link LessEqualDepth}. See the depth mode constants for all possible values.
	 * @default LessEqualDepth
	 */
	depthFunc: DepthModes;
	/**
	 * Whether to have depth test enabled when rendering this material. Default is true.
	 * @default true
	 */
	depthTest: boolean;
	/**
	 * Whether rendering this material has any effect on the depth buffer. Default is true.
	 * When drawing 2D overlays it can be useful to disable the depth writing in order to layer several things together without creating z-index artifacts.
	 * @default true
	 */
	depthWrite: boolean;
	/**
	 * Unique number of this material instance.
	 */
	id: number;
	/**
	 * Whether rendering this material has any effect on the stencil buffer. Default is *false*.
	 * @default false
	 */
	stencilWrite: boolean;
	/**
	 * The stencil comparison function to use. Default is {@link AlwaysStencilFunc}. See stencil operation constants for all possible values.
	 * @default AlwaysStencilFunc
	 */
	stencilFunc: StencilFunc;
	/**
	 * The value to use when performing stencil comparisons or stencil operations. Default is *0*.
	 * @default 0
	 */
	stencilRef: number;
	/**
	 * The bit mask to use when writing to the stencil buffer. Default is *0xFF*.
	 * @default 0xff
	 */
	stencilWriteMask: number;
	/**
	 * The bit mask to use when comparing against the stencil buffer. Default is *0xFF*.
	 * @default 0xff
	 */
	stencilFuncMask: number;
	/**
	 * Which stencil operation to perform when the comparison function returns false. Default is {@link KeepStencilOp}. See the stencil operation constants for all possible values.
	 * @default KeepStencilOp
	 */
	stencilFail: StencilOp;
	/**
	 * Which stencil operation to perform when the comparison function returns true but the depth test fails.
	 * Default is {@link KeepStencilOp}.
	 * See the stencil operation constants for all possible values.
	 * @default KeepStencilOp
	 */
	stencilZFail: StencilOp;
	/**
	 * Which stencil operation to perform when the comparison function returns true and the depth test passes.
	 * Default is {@link KeepStencilOp}.
	 * See the stencil operation constants for all possible values.
	 * @default KeepStencilOp
	 */
	stencilZPass: StencilOp;
	/**
	 * Used to check whether this or derived classes are materials. Default is true.
	 * You should not change this, as it used internally for optimisation.
	 */
	readonly isMaterial: true;
	/**
	 * Material name. Default is an empty string.
	 * @default ''
	 */
	name: string;
	/**
	 * Specifies that the material needs to be updated, WebGL wise. Set it to true if you made changes that need to be reflected in WebGL.
	 * This property is automatically set to true when instancing a new material.
	 * @default false
	 */
	needsUpdate: boolean;
	/**
	 * Opacity. Default is 1.
	 * @default 1
	 */
	opacity: number;
	/**
	 * Whether to use polygon offset. Default is false. This corresponds to the POLYGON_OFFSET_FILL WebGL feature.
	 * @default false
	 */
	polygonOffset: boolean;
	/**
	 * Sets the polygon offset factor. Default is 0.
	 * @default 0
	 */
	polygonOffsetFactor: number;
	/**
	 * Sets the polygon offset units. Default is 0.
	 * @default 0
	 */
	polygonOffsetUnits: number;
	/**
	 * Override the renderer's default precision for this material. Can be "highp", "mediump" or "lowp". Defaults is null.
	 * @default null
	 */
	precision: "highp" | "mediump" | "lowp" | null;
	/**
	 * Whether to premultiply the alpha (transparency) value. See WebGL / Materials / Transparency for an example of the difference. Default is false.
	 * @default false
	 */
	premultipliedAlpha: boolean;
	/**
	 * @default false
	 */
	forceSinglePass: boolean;
	/**
	 * Whether to apply dithering to the color to remove the appearance of banding. Default is false.
	 * @default false
	 */
	dithering: boolean;
	/**
	 * Defines which of the face sides will be rendered - front, back or both.
	 * Default is {@link FrontSide}. Other options are {@link THREE.BackSide} and {@link THREE.DoubleSide}.
	 *
	 * @default {@link FrontSide}
	 */
	side: Side;
	/**
	 * Defines which of the face sides will cast shadows. Default is *null*.
	 * If *null*, the value is opposite that of side, above.
	 * @default null
	 */
	shadowSide: Side | null;
	/**
	 * Defines whether this material is tone mapped according to the renderer's toneMapping setting.
	 * Default is true.
	 * @default true
	 */
	toneMapped: boolean;
	/**
	 * Defines whether this material is transparent. This has an effect on rendering as transparent objects need special treatment and are rendered after non-transparent objects.
	 * When set to true, the extent to which the material is transparent is controlled by setting it's .opacity property.
	 * Default is false.
	 * @default false
	 */
	transparent: boolean;
	/**
	 * Value is the string 'Material'. This shouldn't be changed, and can be used to find all objects of this type in a scene.
	 * @default 'Material'
	 */
	type: string;
	/**
	 * UUID of this material instance. This gets automatically assigned, so this shouldn't be edited.
	 */
	uuid: string;
	/**
	 * Defines whether vertex coloring is used. Default is false.
	 * @default false
	 */
	vertexColors: boolean;
	/**
	 * Defines whether this material is visible. Default is true.
	 * @default true
	 */
	visible: boolean;
	/**
	 * An object that can be used to store custom data about the Material. It should not hold references to functions as these will not be cloned.
	 * @default {}
	 */
	userData: any;
	/**
	 * This starts at 0 and counts how many times .needsUpdate is set to true.
	 * @default 0
	 */
	version: number;
	/**
	 * Return a new material with the same parameters as this material.
	 */
	clone(): this;
	/**
	 * Copy the parameters from the passed material into this material.
	 * @param material
	 */
	copy(material: Material): this;
	/**
	 * This disposes the material. Textures of a material don't get disposed. These needs to be disposed by {@link Texture}.
	 */
	dispose(): void;
	/**
	 * An optional callback that is executed immediately before the shader program is compiled.
	 * This function is called with the shader source code as a parameter.
	 * Useful for the modification of built-in materials.
	 * @param shader Source code of the shader
	 * @param renderer WebGLRenderer Context that is initializing the material
	 */
	onBeforeCompile(shader: Shader, renderer: WebGLRenderer): void;
	/**
	 * In case onBeforeCompile is used, this callback can be used to identify values of settings used in onBeforeCompile, so three.js can reuse a cached shader or recompile the shader as needed.
	 */
	customProgramCacheKey(): string;
	/**
	 * Sets the properties based on the values.
	 * @param values A container with parameters.
	 */
	setValues(values: MaterialParameters): void;
	/**
	 * Convert the material to three.js JSON format.
	 * @param meta Object containing metadata such as textures or images for the material.
	 */
	toJSON(meta?: any): any;
}
declare class Source {
	/**
	 * Create a new instance of {@link Source}
	 * @param data The data definition of a texture. Default `null`
	 */
	constructor(data: any);
	/**
	 * Flag to check if a given object is of type {@link Source}.
	 * @remarks This is a _constant_ value
	 * @defaultValue `true`
	 */
	readonly isSource: true;
	/**
	 * The actual data of a texture.
	 * @remarks The type of this property depends on the texture that uses this instance.
	 */
	data: any;
	/**
	 * Set this to `true` to trigger a data upload to the GPU next time the {@link Source} is used.
	 */
	set needsUpdate(value: boolean);
	/**
	 * {@link http://en.wikipedia.org/wiki/Universally_unique_identifier | UUID} of this object instance.
	 * @remarks This gets automatically assigned and shouldn't be edited.
	 */
	uuid: string;
	/**
	 * This starts at `0` and counts how many times {@link needsUpdate | .needsUpdate} is set to `true`.
	 * @remarks Expects a `Integer`
	 * @defaultValue `0`
	 */
	version: number;
	/**
	 * Convert the data {@link Source} to three.js {@link https://github.com/mrdoob/three.js/wiki/JSON-Object-Scene-format-4 | JSON Object/Scene format}.
	 * @param meta Optional object containing metadata.
	 */
	toJSON(meta?: string | {}): {};
}
/** Shim for OffscreenCanvas. */
// tslint:disable-next-line:no-empty-interface
interface OffscreenCanvas extends EventTarget {
}
declare class Texture extends EventDispatcher {
	/**
	 * This creates a new {@link Texture | Texture} object.
	 * @param image See {@link Texture.image | .image}. Default {@link Texture.DEFAULT_IMAGE}
	 * @param mapping See {@link Texture.mapping | .mapping}. Default {@link Texture.DEFAULT_MAPPING}
	 * @param wrapS See {@link Texture.wrapS | .wrapS}. Default {@link ClampToEdgeWrapping}
	 * @param wrapT See {@link Texture.wrapT | .wrapT}. Default {@link ClampToEdgeWrapping}
	 * @param magFilter See {@link Texture.magFilter | .magFilter}. Default {@link LinearFilter}
	 * @param minFilter  See {@link Texture.minFilter | .minFilter}. Default {@link LinearMipmapLinearFilter}
	 * @param format See {@link Texture.format | .format}. Default {@link RGBAFormat}
	 * @param type See {@link Texture.type | .type}. Default {@link UnsignedByteType}
	 * @param anisotropy See {@link Texture.anisotropy | .anisotropy}. Default {@link Texture.DEFAULT_ANISOTROPY}
	 * @param colorSpace See {@link Texture.colorSpace | .colorSpace}. Default {@link NoColorSpace}
	 */
	constructor(image?: TexImageSource | OffscreenCanvas, mapping?: Mapping, wrapS?: Wrapping, wrapT?: Wrapping, magFilter?: MagnificationTextureFilter, minFilter?: MinificationTextureFilter, format?: PixelFormat, type?: TextureDataType, anisotropy?: number, colorSpace?: ColorSpace);
	/**
	 * @deprecated
	 */
	constructor(image: TexImageSource | OffscreenCanvas, mapping: Mapping, wrapS: Wrapping, wrapT: Wrapping, magFilter: MagnificationTextureFilter, minFilter: MinificationTextureFilter, format: PixelFormat, type: TextureDataType, anisotropy: number, encoding: TextureEncoding);
	/**
	 * Read-only flag to check if a given object is of type {@link Texture}.
	 * @remarks This is a _constant_ value
	 * @defaultValue `true`
	 */
	readonly isTexture: true;
	/**
	 * Unique number for this {@link Texture} instance.
	 * @remarks Note that ids are assigned in chronological order: 1, 2, 3, ..., incrementing by one for each new object.
	 * @remarks Expects a `Integer`
	 */
	readonly id: number;
	/**
	 * {@link http://en.wikipedia.org/wiki/Universally_unique_identifier | UUID} of this object instance.
	 * @remarks This gets automatically assigned and shouldn't be edited.
	 */
	uuid: string;
	/**
	 * Optional name of the object
	 * @remarks _(doesn't need to be unique)_.
	 * @defaultValue `""`
	 */
	name: string;
	/**
	 * The data definition of a texture. A reference to the data source can be shared across textures.
	 * This is often useful in context of spritesheets where multiple textures render the same data
	 * but with different {@link Texture} transformations.
	 */
	source: Source;
	/**
	 * An image object, typically created using the {@link TextureLoader.load | TextureLoader.load()} method.
	 * @remarks This can be any image (e.g., PNG, JPG, GIF, DDS) or video (e.g., MP4, OGG/OGV) type supported by three.js.
	 * @remarks To use video as a {@link Texture} you need to have a playing HTML5 video element as a source
	 * for your {@link Texture} image and continuously update this {@link Texture}
	 * as long as video is playing - the {@link VideoTexture | VideoTexture} class handles this automatically.
	 */
	get image(): any;
	set image(data: any);
	/**
	 * Array of user-specified mipmaps
	 * @defaultValue `[]`
	 */
	mipmaps: any[]; // ImageData[] for 2D textures and CubeTexture[] for cube textures;
	/**
	 * How the image is applied to the object.
	 * @remarks All {@link Texture} types except {@link CubeTexture} expect the _values_ be {@link THREE.Mapping}
	 * @remarks {@link CubeTexture} expect the _values_ be {@link CubeTextureMapping}
	 * @see {@link https://threejs.org/docs/index.html#api/en/constants/Textures | Texture Constants}
	 * @defaultValue _value of_ {@link Texture.DEFAULT_MAPPING}
	 */
	mapping: AnyMapping;
	/**
	 * Lets you select the uv attribute to map the texture to. `0` for `uv`, `1` for `uv1`, `2` for `uv2` and `3` for
	 * `uv3`.
	 */
	channel: number;
	/**
	 * This defines how the {@link Texture} is wrapped *horizontally* and corresponds to **U** in UV mapping.
	 * @remarks for **WEBGL1** - tiling of images in textures only functions if image dimensions are powers of two
	 * (2, 4, 8, 16, 32, 64, 128, 256, 512, 1024, 2048, ...) in terms of pixels.
	 * Individual dimensions need not be equal, but each must be a power of two. This is a limitation of WebGL1, not three.js.
	 * **WEBGL2** does not have this limitation.
	 * @see {@link https://threejs.org/docs/index.html#api/en/constants/Textures | Texture Constants}
	 * @see {@link wrapT}
	 * @see {@link repeat}
	 * @defaultValue {@link ClampToEdgeWrapping}
	 */
	wrapS: Wrapping;
	/**
	 * This defines how the {@link Texture} is wrapped *vertically* and corresponds to **V** in UV mapping.
	 * @remarks for **WEBGL1** - tiling of images in textures only functions if image dimensions are powers of two
	 * (2, 4, 8, 16, 32, 64, 128, 256, 512, 1024, 2048, ...) in terms of pixels.
	 * Individual dimensions need not be equal, but each must be a power of two. This is a limitation of WebGL1, not three.js.
	 * **WEBGL2** does not have this limitation.
	 * @see {@link https://threejs.org/docs/index.html#api/en/constants/Textures | Texture Constants}
	 * @see {@link wrapS}
	 * @see {@link repeat}
	 * @defaultValue {@link ClampToEdgeWrapping}
	 */
	wrapT: Wrapping;
	/**
	 * How the {@link Texture} is sampled when a texel covers more than one pixel.
	 * @see {@link https://threejs.org/docs/index.html#api/en/constants/Textures | Texture Constants}
	 * @see {@link minFilter}
	 * @see {@link MagnificationTextureFilter}
	 * @defaultValue {@link LinearFilter}
	 */
	magFilter: MagnificationTextureFilter;
	/**
	 * How the {@link Texture} is sampled when a texel covers less than one pixel.
	 * @see {@link https://threejs.org/docs/index.html#api/en/constants/Textures | Texture Constants}
	 * @see {@link magFilter}
	 * @see {@link MinificationTextureFilter}
	 * @defaultValue {@link LinearMipmapLinearFilter}
	 */
	minFilter: MinificationTextureFilter;
	/**
	 * The number of samples taken along the axis through the pixel that has the highest density of texels.
	 * @remarks A higher value gives a less blurry result than a basic mipmap, at the cost of more {@link Texture} samples being used.
	 * @remarks Use {@link WebGLCapabilities.getMaxAnisotropy() | renderer.capabilities.getMaxAnisotropy()} to find the maximum valid anisotropy value for the GPU;
	 * @remarks This value is usually a power of 2.
	 * @default _value of_ {@link Texture.DEFAULT_ANISOTROPY}. That is normally `1`.
	 */
	anisotropy: number;
	/**
	 * These define how elements of a 2D texture, or texels, are read by shaders.
	 * @remarks All {@link Texture} types except {@link DeepTexture} and {@link THREE.CompressedPixelFormat} expect the _values_ be {@link THREE.PixelFormat}
	 * @remarks {@link DeepTexture} expect the _values_ be {@link CubeTextureMapping}
	 * @remarks {@link CompressedPixelFormat} expect the _values_ be {@link CubeTextureMapping}
	 * @see {@link https://threejs.org/docs/index.html#api/en/constants/Textures | Texture Constants}
	 * @see {@link PixelFormat}
	 * @defaultValue {@link RGBAFormat}.
	 */
	format: AnyPixelFormat;
	/**
	 * This must correspond to the {@link Texture.format | .format}.
	 * @remarks {@link UnsignedByteType}, is the type most used by Texture formats.
	 * @see {@link https://threejs.org/docs/index.html#api/en/constants/Textures | Texture Constants}
	 * @see {@link TextureDataType}
	 * @defaultValue {@link UnsignedByteType}
	 */
	type: TextureDataType;
	/**
	 * The GPU Pixel Format allows the developer to specify how the data is going to be stored on the GPU.
	 * @remarks Compatible only with {@link WebGL2RenderingContext | WebGL 2 Rendering Context}.
	 * @see {@link https://threejs.org/docs/index.html#api/en/constants/Textures | Texture Constants}
	 * @defaultValue The default value is obtained using a combination of {@link Texture.format | .format} and {@link Texture.type | .type}.
	 */
	internalFormat: PixelFormatGPU | null;
	/**
	 * The uv-transform matrix for the texture.
	 * @remarks
	 * When {@link Texture.matrixAutoUpdate | .matrixAutoUpdate} property is `true`.
	 * Will be updated by the renderer from the properties:
	 *  - {@link Texture.offset | .offset}
	 *  - {@link Texture.repeat | .repeat}
	 *  - {@link Texture.rotation | .rotation}
	 *  - {@link Texture.center | .center}
	 * @remarks
	 * When {@link Texture.matrixAutoUpdate | .matrixAutoUpdate} property is `false`.
	 * This matrix may be set manually.
	 * @see {@link matrixAutoUpdate | .matrixAutoUpdate}
	 * @defaultValue `new Matrix3()`
	 */
	matrix: Matrix3;
	/**
	 * Whether is to update the texture's uv-transform {@link matrix | .matrix}.
	 * @remarks Set this to `false` if you are specifying the uv-transform {@link matrix} directly.
	 * @see {@link matrix | .matrix}
	 * @defaultValue `true`
	 */
	matrixAutoUpdate: boolean;
	/**
	 * How much a single repetition of the texture is offset from the beginning, in each direction **U** and **V**.
	 * @remarks Typical range is `0.0` to `1.0`.
	 * @defaultValue `new Vector2(0, 0)`
	 */
	offset: Vector2;
	/**
	 * How many times the texture is repeated across the surface, in each direction **U** and **V**.
	 * @remarks
	 * If repeat is set greater than `1` in either direction, the corresponding *Wrap* parameter should
	 * also be set to {@link RepeatWrapping} or {@link THREE.MirroredRepeatWrapping} to achieve the desired tiling effect.
	 * @see {@link wrapS}
	 * @see {@link wrapT}
	 * @defaultValue `new Vector2( 1, 1 )`
	 */
	repeat: Vector2;
	/**
	 * The point around which rotation occurs.
	 * @remarks A value of `(0.5, 0.5)` corresponds to the center of the texture.
	 * @defaultValue `new Vector2( 0, 0 )`, _lower left._
	 */
	center: Vector2;
	/**
	 * How much the texture is rotated around the center point, in radians.
	 * @remarks Positive values are counter-clockwise.
	 * @defaultValue `0`
	 */
	rotation: number;
	/**
	 * Whether to generate mipmaps, _(if possible)_ for a texture.
	 * @remarks Set this to false if you are creating mipmaps manually.
	 * @defaultValue true
	 */
	generateMipmaps: boolean;
	/**
	 * If set to `true`, the alpha channel, if present, is multiplied into the color channels when the texture is uploaded to the GPU.
	 * @remarks
	 * Note that this property has no effect for {@link https://developer.mozilla.org/en-US/docs/Web/API/ImageBitmap | ImageBitmap}.
	 * You need to configure on bitmap creation instead. See {@link ImageBitmapLoader | ImageBitmapLoader}.
	 * @see {@link ImageBitmapLoader | ImageBitmapLoader}.
	 * @defaultValue `false`
	 */
	premultiplyAlpha: boolean;
	/**
	 * If set to `true`, the texture is flipped along the vertical axis when uploaded to the GPU.
	 * @remarks
	 * Note that this property has no effect for {@link https://developer.mozilla.org/en-US/docs/Web/API/ImageBitmap | ImageBitmap}.
	 * You need to configure on bitmap creation instead. See {@link ImageBitmapLoader | ImageBitmapLoader}.
	 * @see {@link ImageBitmapLoader | ImageBitmapLoader}.
	 * @defaultValue `true`
	 */
	flipY: boolean;
	/**
	 * Specifies the alignment requirements for the start of each pixel row in memory.
	 * @remarks
	 * The allowable values are:
	 *  - `1` (byte-alignment)
	 *  - `2` (rows aligned to even-numbered bytes)
	 *  - `4` (word-alignment)
	 *  - `8` (rows start on double-word boundaries).
	 * @see {@link http://www.khronos.org/opengles/sdk/docs/man/xhtml/glPixelStorei.xml | glPixelStorei} for more information.
	 * @defaultValue `4`
	 */
	unpackAlignment: number; // TODO Fix typing to only allow the expected values.
	/**
	 * The {@link Textures | {@link Texture} constants} page for details of other formats.
	 * @remarks
	 * Values of {@link encoding} !== {@link LinearEncoding} are only supported on _map_, _envMap_ and _emissiveMap_.
	 * @remarks
	 * Note that if this value is changed on a texture after the material has been used, it is necessary to trigger a {@link Material.needsUpdate} for this value to be realized in the shader.
	 * @see {@link https://threejs.org/docs/index.html#api/en/constants/Textures | Texture Constants}
	 * @see {@link TextureDataType}
	 * @defaultValue {@link LinearEncoding}
	 * @deprecated Use {@link Texture.colorSpace .colorSpace} in three.js r152+.
	 */
	encoding: TextureEncoding;
	/**
	 * The {@link Textures | {@link Texture} constants} page for details of other color spaces.
	 * @remarks
	 * Textures containing color data should be annotated with {@link SRGBColorSpace SRGBColorSpace} or
	 * {@link LinearSRGBColorSpace LinearSRGBColorSpace}.
	 * @see {@link https://threejs.org/docs/index.html#api/en/constants/Textures | Texture Constants}
	 * @see {@link TextureDataType}
	 * @defaultValue {@link NoColorSpace}
	 */
	colorSpace: ColorSpace;
	/**
	 * Indicates whether a texture belongs to a render target or not
	 * @defaultValue `false`
	 */
	isRenderTargetTexture: boolean;
	/**
	 * Indicates whether this texture should be processed by {@link PMREMGenerator} or not.
	 * @remarks Only relevant for render target textures.
	 * @defaultValue `false`
	 */
	needsPMREMUpdate: boolean;
	/**
	 * An object that can be used to store custom data about the texture.
	 * @remarks It should not hold references to functions as these will not be cloned.
	 * @defaultValue `{}`
	 */
	userData: any;
	/**
	 * This starts at `0` and counts how many times {@link needsUpdate | .needsUpdate} is set to `true`.
	 * @remarks Expects a `Integer`
	 * @defaultValue `0`
	 */
	version: number;
	/**
	 * Set this to `true` to trigger an update next time the texture is used. Particularly important for setting the wrap mode.
	 */
	set needsUpdate(value: boolean);
	/**
	 * The Global default value for {@link anisotropy | .anisotropy}.
	 * @defaultValue `1`.
	 */
	static DEFAULT_ANISOTROPY: number;
	/**
	 * The Global default value for {@link Texture.image | .image}.
	 * @defaultValue `null`.
	 */
	static DEFAULT_IMAGE: any;
	/**
	 * The Global default value for {@link mapping | .mapping}.
	 * @defaultValue {@link UVMapping}
	 */
	static DEFAULT_MAPPING: Mapping;
	/**
	 * A callback function, called when the texture is updated _(e.g., when needsUpdate has been set to true and then the texture is used)_.
	 */
	onUpdate: () => void;
	/**
	 * Transform the **UV** based on the value of this texture's
	 * {@link offset | .offset},
	 * {@link repeat | .repeat},
	 * {@link wrapS | .wrapS},
	 * {@link wrapT | .wrapT} and
	 * {@link flipY | .flipY} properties.
	 * @param uv
	 */
	transformUv(uv: Vector2): Vector2;
	/**
	 * Update the texture's **UV-transform** {@link matrix | .matrix} from the texture properties
	 * {@link offset | .offset},
	 * {@link repeat | .repeat},
	 * {@link rotation | .rotation} and
	 * {@link center | .center}.
	 */
	updateMatrix(): void;
	/**
	 * Make copy of the texture
	 * @remarks Note this is not a **"deep copy"**, the image is shared
	 * @remarks
	 * Besides, cloning a texture does not automatically mark it for a texture upload
	 * You have to set {@link needsUpdate | .needsUpdate} to `true` as soon as it's image property (the data source) is fully loaded or ready.
	 */
	clone(): this;
	copy(source: Texture): this;
	/**
	 * Convert the texture to three.js {@link https://github.com/mrdoob/three.js/wiki/JSON-Object-Scene-format-4 | JSON Object/Scene format}.
	 * @param meta Optional object containing metadata.
	 */
	toJSON(meta?: string | {}): {};
	/**
	 * Frees the GPU-related resources allocated by this instance
	 * @remarks Call this method whenever this instance is no longer used in your app.
	 */
	dispose(): void;
}
declare class Scene extends Object3D {
	/**
	 * Create a new {@link Scene} object.
	 */
	constructor();
	/**
	 * Read-only flag to check if a given object is of type {@link Scene}.
	 * @remarks This is a _constant_ value
	 * @defaultValue `true`
	 */
	readonly isScene: true;
	/**
	 * @defaultValue `Scene`
	 */
	type: "Scene";
	/**
	 * A {@link Fog | fog} instance defining the type of fog that affects everything rendered in the scene.
	 * @defaultValue `null`
	 */
	fog: FogBase | null;
	/**
	 * Sets the blurriness of the background. Only influences environment maps assigned to {@link Scene.background | Scene.background}.
	 * @defaultValue `0`
	 * @remarks Expects a `Float` between `0` and `1`.
	 */
	backgroundBlurriness: number;
	/**
	 * Attenuates the color of the background. Only applies to background textures.
	 * @defaultValue `1`
	 * @remarks Expects a `Float`
	 */
	backgroundIntensity: number;
	/**
	 * Forces everything in the {@link Scene} to be rendered with the defined material.
	 * @defaultValue `null`
	 */
	overrideMaterial: Material | null;
	/**
	 * Defines the background of the scene.
	 * @remarks Valid inputs are:
	 *  - A {@link Color | Color} for defining a uniform colored background.
	 *  - A {@link Texture | Texture} for defining a (flat) textured background.
	 *  - Texture cubes ({@link CubeTexture | CubeTexture}) or equirectangular textures for defining a skybox.</li>
	 * @defaultValue `null`
	 */
	background: Color | Texture | CubeTexture | null;
	/**
	 * Sets the environment map for all physical materials in the scene.
	 * However, it's not possible to overwrite an existing texture assigned to {@link MeshStandardMaterial.envMap | MeshStandardMaterial.envMap}.
	 * @defaultValue `null`
	 */
	environment: Texture | null;
	/**
	 * Convert the {@link Scene} to three.js {@link https://github.com/mrdoob/three.js/wiki/JSON-Object-Scene-format-4 | JSON Object/Scene format}.
	 * @param meta Object containing metadata such as textures or images for the scene.
	 */
	toJSON(meta?: any): any;
}
interface WebGLCapabilitiesParameters {
	precision?: string | undefined;
	logarithmicDepthBuffer?: boolean | undefined;
}
declare class WebGLCapabilities {
	constructor(gl: WebGLRenderingContext, extensions: any, parameters: WebGLCapabilitiesParameters);
	readonly isWebGL2: boolean;
	precision: string;
	logarithmicDepthBuffer: boolean;
	maxTextures: number;
	maxVertexTextures: number;
	maxTextureSize: number;
	maxCubemapSize: number;
	maxAttributes: number;
	maxVertexUniforms: number;
	maxVaryings: number;
	maxFragmentUniforms: number;
	vertexTextures: boolean;
	floatFragmentTextures: boolean;
	floatVertexTextures: boolean;
	maxSamples: number;
	getMaxAnisotropy(): number;
	getMaxPrecision(precision: string): string;
}
declare class WebGLExtensions {
	constructor(gl: WebGLRenderingContext);
	has(name: string): boolean;
	init(capabilities: WebGLCapabilities): void;
	get(name: string): any;
}
declare class WebGLColorBuffer {
	constructor();
	setMask(colorMask: boolean): void;
	setLocked(lock: boolean): void;
	setClear(r: number, g: number, b: number, a: number, premultipliedAlpha: boolean): void;
	reset(): void;
}
declare class WebGLDepthBuffer {
	constructor();
	setTest(depthTest: boolean): void;
	setMask(depthMask: boolean): void;
	setFunc(depthFunc: DepthModes): void;
	setLocked(lock: boolean): void;
	setClear(depth: number): void;
	reset(): void;
}
declare class WebGLStencilBuffer {
	constructor();
	setTest(stencilTest: boolean): void;
	setMask(stencilMask: number): void;
	setFunc(stencilFunc: number, stencilRef: number, stencilMask: number): void;
	setOp(stencilFail: number, stencilZFail: number, stencilZPass: number): void;
	setLocked(lock: boolean): void;
	setClear(stencil: number): void;
	reset(): void;
}
declare class WebGLState {
	constructor(gl: WebGLRenderingContext, extensions: WebGLExtensions, capabilities: WebGLCapabilities);
	buffers: {
		color: WebGLColorBuffer;
		depth: WebGLDepthBuffer;
		stencil: WebGLStencilBuffer;
	};
	initAttributes(): void;
	enableAttribute(attribute: number): void;
	enableAttributeAndDivisor(attribute: number, meshPerAttribute: number): void;
	disableUnusedAttributes(): void;
	vertexAttribPointer(index: number, size: number, type: number, normalized: boolean, stride: number, offset: number): void;
	enable(id: number): void;
	disable(id: number): void;
	bindFramebuffer(target: number, framebuffer: WebGLFramebuffer | null): void;
	bindXRFramebuffer(framebuffer: WebGLFramebuffer | null): void;
	useProgram(program: any): boolean;
	setBlending(blending: Blending, blendEquation?: BlendingEquation, blendSrc?: BlendingSrcFactor, blendDst?: BlendingDstFactor, blendEquationAlpha?: BlendingEquation, blendSrcAlpha?: BlendingSrcFactor, blendDstAlpha?: BlendingDstFactor, premultiplyAlpha?: boolean): void;
	setMaterial(material: Material, frontFaceCW: boolean): void;
	setFlipSided(flipSided: boolean): void;
	setCullFace(cullFace: CullFace): void;
	setLineWidth(width: number): void;
	setPolygonOffset(polygonoffset: boolean, factor?: number, units?: number): void;
	setScissorTest(scissorTest: boolean): void;
	activeTexture(webglSlot: number): void;
	bindTexture(webglType: number, webglTexture: any): void;
	unbindTexture(): void;
	// Same interface as https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/compressedTexImage2D
	compressedTexImage2D(target: number, level: number, internalformat: number, width: number, height: number, border: number, data: ArrayBufferView): void;
	// Same interface as https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/texImage2D
	texImage2D(target: number, level: number, internalformat: number, width: number, height: number, border: number, format: number, type: number, pixels: ArrayBufferView | null): void;
	texImage2D(target: number, level: number, internalformat: number, format: number, type: number, source: any): void;
	texImage3D(target: number, level: number, internalformat: number, width: number, height: number, depth: number, border: number, format: number, type: number, pixels: any): void;
	scissor(scissor: Vector4): void;
	viewport(viewport: Vector4): void;
	reset(): void;
}
declare class WebGLProperties {
	constructor();
	get(object: any): any;
	remove(object: any): void;
	update(object: any, key: any, value: any): any;
	dispose(): void;
}
declare class WebGLUtils {
	constructor(gl: WebGLRenderingContext | WebGL2RenderingContext, extensions: any, capabilities: any);
	convert(p: PixelFormat | CompressedPixelFormat | TextureDataType, encoding?: TextureEncoding | null): number | null;
}
declare class WebGLTextures {
	constructor(gl: WebGLRenderingContext, extensions: WebGLExtensions, state: WebGLState, properties: WebGLProperties, capabilities: WebGLCapabilities, utils: WebGLUtils, info: WebGLInfo);
	allocateTextureUnit(): void;
	resetTextureUnits(): void;
	setTexture2D(texture: any, slot: number): void;
	setTexture2DArray(texture: any, slot: number): void;
	setTexture3D(texture: any, slot: number): void;
	setTextureCube(texture: any, slot: number): void;
	setupRenderTarget(renderTarget: any): void;
	updateRenderTargetMipmap(renderTarget: any): void;
	updateMultisampleRenderTarget(renderTarget: any): void;
	safeSetTexture2D(texture: any, slot: number): void;
	safeSetTextureCube(texture: any, slot: number): void;
}
declare class WebGLUniforms {
	constructor(gl: WebGLRenderingContext, program: WebGLProgram);
	setValue(gl: WebGLRenderingContext, name: string, value: any, textures: WebGLTextures): void;
	setOptional(gl: WebGLRenderingContext, object: any, name: string): void;
	static upload(gl: WebGLRenderingContext, seq: any, values: any[], textures: WebGLTextures): void;
	static seqWithValue(seq: any, values: any[]): any[];
}
// @ts-ignore
declare class WebGLProgram {
	constructor(renderer: WebGLRenderer, cacheKey: string, parameters: object);
	name: string;
	id: number;
	cacheKey: string; // unique identifier for this program, used for looking up compiled programs from cache.
	/**
	 * @default 1
	 */
	usedTimes: number;
	program: any;
	vertexShader: WebGLShader;
	fragmentShader: WebGLShader;
	/**
	 * @deprecated Use {@link WebGLProgram#getUniforms getUniforms()} instead.
	 */
	uniforms: any;
	/**
	 * @deprecated Use {@link WebGLProgram#getAttributes getAttributes()} instead.
	 */
	attributes: any;
	getUniforms(): WebGLUniforms;
	getAttributes(): any;
	destroy(): void;
}
declare class WebGLInfo {
	constructor(gl: WebGLRenderingContext);
	/**
	 * @default true
	 */
	autoReset: boolean;
	/**
	 * @default { geometries: 0, textures: 0 }
	 */
	memory: {
		geometries: number;
		textures: number;
	};
	/**
	 * @default null
	 */
	programs: WebGLProgram[] | null;
	/**
	 * @default { frame: 0, calls: 0, triangles: 0, points: 0, lines: 0 }
	 */
	render: {
		calls: number;
		frame: number;
		lines: number;
		points: number;
		triangles: number;
	};
	update(count: number, mode: number, instanceCount: number): void;
	reset(): void;
}
declare class WebGLObjects {
	constructor(gl: WebGLRenderingContext, geometries: any, attributes: any, info: any);
	update(object: any): any;
	dispose(): void;
}
declare class DepthTexture extends Texture {
	/**
	 * Create a new instance of {@link DepthTexture}
	 * @param width Width of the texture.
	 * @param height Height of the texture.
	 * @param type See {@link Texture.type | .type}. Default {@link UnsignedByteType} or {@link THREE.UnsignedInt248Type}
	 * @param mapping See {@link Texture.mapping | .mapping}. Default {@link Texture.DEFAULT_MAPPING}
	 * @param wrapS See {@link Texture.wrapS | .wrapS}. Default {@link ClampToEdgeWrapping}
	 * @param wrapT See {@link Texture.wrapT | .wrapT}. Default {@link ClampToEdgeWrapping}
	 * @param magFilter See {@link Texture.magFilter | .magFilter}. Default {@link NearestFilter}
	 * @param minFilter  See {@link Texture.minFilter | .minFilter}. Default {@link NearestFilter}
	 * @param anisotropy See {@link Texture.anisotropy | .anisotropy}. Default {@link Texture.DEFAULT_ANISOTROPY}
	 * @param format See {@link DepthTexture.format | .format}. Default {@link DepthFormat}
	 */
	constructor(width: number, height: number, type?: TextureDataType, mapping?: Mapping, wrapS?: Wrapping, wrapT?: Wrapping, magFilter?: MagnificationTextureFilter, minFilter?: MinificationTextureFilter, anisotropy?: number, format?: DeepTexturePixelFormat);
	/**
	 * Read-only flag to check if a given object is of type {@link DepthTexture}.
	 * @remarks This is a _constant_ value
	 * @defaultValue `true`
	 */
	readonly isDepthTexture: true;
	/**
	 * Overridden with a record type holding width and height.
	 * @override
	 */
	get image(): {
		width: number;
		height: number;
	};
	set image(value: {
		width: number;
		height: number;
	});
	/**
	 * @override
	 * @defaultValue `false`
	 */
	flipY: boolean;
	/**
	 * @override
	 * @defaultValue {@link NearestFilter}
	 */
	magFilter: MagnificationTextureFilter;
	/**
	 * @override
	 * @defaultValue {@link NearestFilter}
	 */
	minFilter: MinificationTextureFilter;
	/**
	 * @override Depth textures do not use mipmaps.
	 * @defaultValue `false`
	 */
	generateMipmaps: boolean;
	/**
	 * @override
	 * @see {@link Texture.format | Texture.format}
	 * @defaultValue {@link DepthFormat}.
	 */
	format: DeepTexturePixelFormat;
	/**
	 * @override
	 * @defaultValue {@link UnsignedByteType} when {@link format | .format} === {@link THREE.DepthFormat}
	 * @defaultValue {@link UnsignedInt248Type} when {@link format | .format} === {@link THREE.DepthStencilFormat}
	 */
	type: TextureDataType;
}
interface WebGLRenderTargetOptions {
	wrapS?: Wrapping | undefined;
	wrapT?: Wrapping | undefined;
	magFilter?: MagnificationTextureFilter | undefined;
	minFilter?: MinificationTextureFilter | undefined;
	format?: number | undefined; // RGBAFormat;
	type?: TextureDataType | undefined; // UnsignedByteType;
	anisotropy?: number | undefined; // 1;
	depthBuffer?: boolean | undefined; // true;
	stencilBuffer?: boolean | undefined; // false;
	generateMipmaps?: boolean | undefined; // true;
	depthTexture?: DepthTexture | undefined;
	/** @deprecated Use 'colorSpace' in three.js r152+. */
	encoding?: TextureEncoding | undefined;
	colorSpace?: ColorSpace | undefined;
	/**
	 * Defines the count of MSAA samples. Can only be used with WebGL 2. Default is **0**.
	 * @default 0
	 */
	samples?: number;
}
declare class WebGLRenderTarget extends EventDispatcher {
	constructor(width?: number, height?: number, options?: WebGLRenderTargetOptions);
	width: number;
	height: number;
	depth: number;
	scissor: Vector4;
	/**
	 * @default false
	 */
	scissorTest: boolean;
	viewport: Vector4;
	texture: Texture;
	/**
	 * @default true
	 */
	depthBuffer: boolean;
	/**
	 * @default true
	 */
	stencilBuffer: boolean;
	/**
	 * @default null
	 */
	depthTexture: DepthTexture;
	/**
	 * Defines the count of MSAA samples. Can only be used with WebGL 2. Default is **0**.
	 * @default 0
	 */
	samples: number;
	readonly isWebGLRenderTarget: true;
	/**
	 * @deprecated Use {@link Texture#wrapS texture.wrapS} instead.
	 */
	wrapS: any;
	/**
	 * @deprecated Use {@link Texture#wrapT texture.wrapT} instead.
	 */
	wrapT: any;
	/**
	 * @deprecated Use {@link Texture#magFilter texture.magFilter} instead.
	 */
	magFilter: any;
	/**
	 * @deprecated Use {@link Texture#minFilter texture.minFilter} instead.
	 */
	minFilter: any;
	/**
	 * @deprecated Use {@link Texture#anisotropy texture.anisotropy} instead.
	 */
	anisotropy: any;
	/**
	 * @deprecated Use {@link Texture#offset texture.offset} instead.
	 */
	offset: any;
	/**
	 * @deprecated Use {@link Texture#repeat texture.repeat} instead.
	 */
	repeat: any;
	/**
	 * @deprecated Use {@link Texture#format texture.format} instead.
	 */
	format: any;
	/**
	 * @deprecated Use {@link Texture#type texture.type} instead.
	 */
	type: any;
	/**
	 * @deprecated Use {@link Texture#generateMipmaps texture.generateMipmaps} instead.
	 */
	generateMipmaps: any;
	setSize(width: number, height: number, depth?: number): void;
	clone(): this;
	copy(source: WebGLRenderTarget): this;
	dispose(): void;
}
declare class LightShadow<TCamera extends Camera = Camera> {
	/**
	 * Create a new instance of {@link LightShadow}
	 * @param camera The light's view of the world.
	 */
	constructor(camera: TCamera);
	/**
	 * The light's view of the world.
	 * @remark This is used to generate a depth map of the scene; objects behind other objects from the light's perspective will be in shadow.
	 */
	camera: TCamera;
	/**
	 * Shadow map bias, how much to add or subtract from the normalized depth when deciding whether a surface is in shadow.
	 * @remark The Very tiny adjustments here (in the order of 0.0001) may help reduce artifacts in shadows.
	 * @remarks Expects a `Float`
	 * @defaultValue `0`
	 */
	bias: number;
	/**
	 * Defines how much the position used to query the shadow map is offset along the object normal.
	 * @remark The Increasing this value can be used to reduce shadow acne especially in large scenes where light shines onto geometry at a shallow angle.
	 * @remark The cost is that shadows may appear distorted.
	 * @remarks Expects a `Float`
	 * @defaultValue `0`
	 */
	normalBias: number;
	/**
	 * Setting this to values greater than 1 will blur the edges of the shadow.toi
	 * @remark High values will cause unwanted banding effects in the shadows - a greater {@link LightShadow.mapSize | mapSize
	 *  will allow for a higher value to be used here before these effects become visible.
	 * @remark If {@link WebGLRenderer.shadowMap.type | WebGLRenderer.shadowMap.type} is set to {@link Renderer | PCFSoftShadowMap},
	 * radius has no effect and it is recommended to increase softness by decreasing {@link LightShadow.mapSize | mapSize} instead.
	 * @remark Note that this has no effect if the {@link WebGLRenderer.shadowMap | WebGLRenderer.shadowMap}.{@link THREE.WebGLShadowMap.type | type}
	 * is set to {@link BasicShadowMap | BasicShadowMap}.
	 * @remarks Expects a `Float`
	 * @defaultValue `1`
	 */
	radius: number;
	/**
	 * The amount of samples to use when blurring a VSM shadow map.
	 * @remarks Expects a `Integer`
	 * @defaultValue `8`
	 */
	blurSamples: number;
	/**
	 * A {@link Vector2 | Vector2} defining the width and height of the shadow map.
	 * @remarks Higher values give better quality shadows at the cost of computation time.
	 * @remarks Values must be powers of 2, up to the {@link WebGLRenderer.capabilities | WebGLRenderer.capabilities}.maxTextureSize for a given device,
	 * although the width and height don't have to be the same (so, for example, (512, 1024) is valid).
	 * @defaultValue `new Vector2(512, 512)`
	 */
	mapSize: Vector2;
	/**
	 * The depth map generated using the internal camera; a location beyond a pixel's depth is in shadow. Computed internally during rendering.
	 * @defaultValue null
	 */
	map: WebGLRenderTarget | null;
	/**
	 * The distribution map generated using the internal camera; an occlusion is calculated based on the distribution of depths. Computed internally during rendering.
	 * @defaultValue null
	 */
	mapPass: WebGLRenderTarget | null;
	/**
	 * Model to shadow camera space, to compute location and depth in shadow map.
	 * Stored in a {@link Matrix4 | Matrix4}.
	 * @remarks This is computed internally during rendering.
	 * @defaultValue new Matrix4()
	 */
	matrix: Matrix4;
	/**
	 * Enables automatic updates of the light's shadow. If you do not require dynamic lighting / shadows, you may set this to `false`.
	 * @defaultValue `true`
	 */
	autoUpdate: boolean;
	/**
	 * When set to `true`, shadow maps will be updated in the next `render` call.
	 * If you have set {@link autoUpdate} to `false`, you will need to set this property to `true` and then make a render call to update the light's shadow.
	 * @defaultValue `false`
	 */
	needsUpdate: boolean;
	/**
	 * Used internally by the renderer to get the number of viewports that need to be rendered for this shadow.
	 */
	getViewportCount(): number;
	/**
	 * Copies value of all the properties from the {@link {@link LightShadow} | source} to this Light.
	 * @param source
	 */
	copy(source: LightShadow): this;
	/**
	 * Creates a new {@link LightShadow} with the same properties as this one.
	 */
	clone(recursive?: boolean): this;
	/**
	 * Serialize this LightShadow.
	 */
	toJSON(): {};
	/**
	 * Gets the shadow cameras frustum
	 * @remarks
	 * Used internally by the renderer to cull objects.
	 */
	getFrustum(): Frustum;
	/**
	 * Update the matrices for the camera and shadow, used internally by the renderer.
	 * @param light The light for which the shadow is being rendered.
	 */
	updateMatrices(light: Light): void;
	getViewport(viewportIndex: number): Vector4;
	/**
	 * Used internally by the renderer to extend the shadow map to contain all viewports
	 */
	getFrameExtents(): Vector2;
	/**
	 * Frees the GPU-related resources allocated by this instance
	 * @remarks
	 * Call this method whenever this instance is no longer used in your app.
	 */
	dispose(): void;
}
declare abstract class Light<TShadowSupport extends LightShadow | undefined = LightShadow | undefined> extends Object3D {
	/**
	 * Creates a new {@link Light}
	 * @remarks
	 * **Note** that this is not intended to be called directly (use one of derived classes instead).
	 * @param color Hexadecimal color of the light. Default `0xffffff` _(white)_.
	 * @param intensity Numeric value of the light's strength/intensity. Expects a `Float`. Default `1`.
	 */
	constructor(color?: ColorRepresentation, intensity?: number);
	/**
	 * Read-only flag to check if a given object is of type {@link HemisphereLight}.
	 * @remarks This is a _constant_ value
	 * @defaultValue `true`
	 */
	readonly isLight: true;
	/**
	 * A Read-only _string_ to check if `this` object type.
	 * @remarks Sub-classes will update this value.
	 * @defaultValue `Light`
	 */
	override readonly type: string | "Light";
	/**
	 * Color of the light. \
	 * @defaultValue `new Color(0xffffff)` _(white)_.
	 */
	color: Color;
	/**
	 * The light's intensity, or strength.
	 * In {@link WebGLRenderer.physicallyCorrectLights | physically correct} mode, the units of intensity depend on the type of light.
	 * @remarks Expects a `Float`
	 * @defaultValue `1`
	 */
	intensity: number;
	/**
	 * A {@link LightShadow | LightShadow} used to calculate shadows for this light.
	 * @remarks Available only on Light's that support shadows.
	 */
	shadow: TShadowSupport;
	/**
	 * Copies value of all the properties from the {@link Light | source} to this instance.
	 * @param source
	 * @param recursive
	 */
	copy(source: this, recursive?: boolean): this;
	/**
	 * Frees the GPU-related resources allocated by this instance
	 * @remarks
	 * Call this method whenever this instance is no longer used in your app.
	 */
	dispose(): void;
}
declare class WebGLShadowMap {
	constructor(_renderer: WebGLRenderer, _objects: WebGLObjects, _capabilities: WebGLCapabilities);
	/**
	 * @default false
	 */
	enabled: boolean;
	/**
	 * @default true
	 */
	autoUpdate: boolean;
	/**
	 * @default false
	 */
	needsUpdate: boolean;
	/**
	 * @default PCFShadowMap
	 */
	type: ShadowMapType;
	render(shadowsArray: Light[], scene: Scene, camera: Camera): void;
	/**
	 * @deprecated Use {@link Material#shadowSide} instead.
	 */
	cullFace: any;
}
declare class Group extends Object3D {
	/**
	 * Creates a new {@link Bone}.
	 */
	constructor();
	/**
	 * Read-only flag to check if a given object is of type {@link Group}.
	 * @remarks This is a _constant_ value
	 * @defaultValue `true`
	 */
	readonly isGroup: true;
	/**
	 * @override
	 * @defaultValue `Group`
	 */
	override readonly type: string | "Group";
}
declare class GLBufferAttribute {
	/**
	 * This creates a new GLBufferAttribute object.
	 * @param buffer Must be a {@link https://developer.mozilla.org/en-US/docs/Web/API/WebGLBuffer | WebGLBuffer}. See {@link GLBufferAttribute.buffer | .buffer}
	 * @param type One of {@link https://developer.mozilla.org/en-US/docs/Web/API/WebGL_API/Constants#Data_types | WebGL Data Types}. See {@link GLBufferAttribute.type | .type}
	 * @param itemSize How many values make up each item (vertex). See {@link GLBufferAttribute.itemSize | .itemSize}
	 * @param elementSize `1`, `2` or `4`. The corresponding size (in bytes) for the given {@link type} param. See {@link GLBufferAttribute.elementSize | .elementSize}
	 * @param count The expected number of vertices in VBO. See {@link GLBufferAttribute.count | .count}
	 */
	constructor(buffer: WebGLBuffer, type: GLenum, itemSize: number, elementSize: 1 | 2 | 4, count: number);
	/**
	 * Read-only flag to check if a given object is of type {@link GLBufferAttribute}.
	 * @remarks This is a _constant_ value
	 * @defaultValue `true`
	 */
	readonly isGLBufferAttribute: true;
	/**
	 * Optional name for this attribute instance.
	 * @defaultValue `""`
	 */
	name: string;
	/**
	 * The current {@link https://developer.mozilla.org/en-US/docs/Web/API/WebGLBuffer | WebGLBuffer} instance.
	 */
	buffer: WebGLBuffer;
	/**
	 * A {@link https://developer.mozilla.org/en-US/docs/Web/API/WebGL_API/Constants#Data_types | WebGL Data Type} describing the underlying VBO contents.
	 *
	 * #### WebGL Data Type (`GLenum`)
	 * - gl.BYTE: 0x1400
	 * - gl.UNSIGNED_BYTE: 0x1401
	 * - gl.SHORT: 0x1402
	 * - gl.UNSIGNED_SHORT: 0x1403
	 * - gl.INT: 0x1404
	 * - gl.UNSIGNED_INT: 0x1405
	 * - gl.FLOAT: 0x1406
	 * @remarks Set this property together with {@link elementSize | .elementSize}. The recommended way is using the {@link setType | .setType()} method.
	 * @remarks Expects a `DataType` `GLenum` _possible values:_ `0x1400` `0x1401` `0x1402` `0x1403` `0x1404` `0x1405` `0x1406`
	 */
	type: GLenum;
	/**
	 * How many values make up each item (vertex).
	 * @remarks The number of values of the array that should be associated with a particular vertex.
	 * For instance, if this attribute is storing a 3-component vector (such as a position, normal, or color), then itemSize should be 3.
	 * @remarks Expects a `Integer`
	 */
	itemSize: number;
	/**
	 * Stores the corresponding size in bytes for the current {@link type | .type} property value.
	 *
	 * The corresponding size (_in bytes_) for the given "type" param.
	 * #### WebGL Data Type (`GLenum`)
	 * - gl.BYTE: 1
	 * - gl.UNSIGNED_BYTE: 1
	 * - gl.SHORT: 2
	 * - gl.UNSIGNED_SHORT: 2
	 * - gl.INT: 4
	 * - gl.UNSIGNED_INT: 4
	 * - gl.FLOAT: 4
	 * @remarks Set this property together with {@link type | .type}. The recommended way is using the {@link setType | .setType} method.
	 * @see `constructor`` for a list of known type sizes.
	 * @remarks Expects a `1`, `2` or `4`
	 */
	elementSize: 1 | 2 | 4;
	/**
	 * The expected number of vertices in VBO.
	 * @remarks Expects a `Integer`
	 */
	count: number;
	/**
	 * A version number, incremented every time the needsUpdate property is set to true.
	 * @remarks Expects a `Integer`
	 */
	version: number;
	/**
	 * Setting this to true increments {@link version | .version}.
	 * @remarks _set-only property_.
	 */
	set needsUpdate(value: boolean);
	/**
	 * Sets the {@link buffer | .buffer} property.
	 */
	setBuffer(buffer: WebGLBuffer): this;
	/**
	 * Sets the both {@link GLBufferAttribute.type | type} and {@link GLBufferAttribute.elementSize | elementSize} properties.
	 */
	setType(type: GLenum, elementSize: 1 | 2 | 4): this;
	/**
	 * Sets the {@link GLBufferAttribute.itemSize | itemSize} property.
	 */
	setItemSize(itemSize: number): this;
	/**
	 * Sets the {@link GLBufferAttribute.count | count} property.
	 */
	setCount(count: number): this;
}
type NormalBufferAttributes = Record<string, BufferAttribute | InterleavedBufferAttribute>;
type NormalOrGLBufferAttributes = Record<string, BufferAttribute | InterleavedBufferAttribute | GLBufferAttribute>;
// @ts-ignore
declare class BufferGeometry<Attributes extends NormalOrGLBufferAttributes = NormalBufferAttributes> extends EventDispatcher {
	/**
	 * This creates a new {@link BufferGeometry | BufferGeometry} object.
	 */
	constructor();
	/**
	 * Unique number for this {@link BufferGeometry | BufferGeometry} instance.
	 * @remarks Expects a `Integer`
	 */
	id: number;
	/**
	 * {@link http://en.wikipedia.org/wiki/Universally_unique_identifier | UUID} of this object instance.
	 * @remarks This gets automatically assigned and shouldn't be edited.
	 */
	uuid: string;
	/**
	 * Optional name for this {@link BufferGeometry | BufferGeometry} instance.
	 * @defaultValue `''`
	 */
	name: string;
	/**
	 * A Read-only _string_ to check if `this` object type.
	 * @remarks Sub-classes will update this value.
	 * @defaultValue `BufferGeometry`
	 */
	readonly type: string | "BufferGeometry";
	/**
	 * Allows for vertices to be re-used across multiple triangles; this is called using "indexed triangles".
	 * Each triangle is associated with the indices of three vertices. This attribute therefore stores the index of each vertex for each triangular face.
	 * If this attribute is not set, the {@link WebGLRenderer | renderer}  assumes that each three contiguous positions represent a single triangle.
	 * @defaultValue `null`
	 */
	index: BufferAttribute | null;
	/**
	 * This hashmap has as id the name of the attribute to be set and as value the {@link BufferAttribute | buffer} to set it to. Rather than accessing this property directly,
	 * use {@link setAttribute | .setAttribute} and {@link getAttribute | .getAttribute} to access attributes of this geometry.
	 * @defaultValue `{}`
	 */
	attributes: Attributes;
	/**
	 * Hashmap of {@link BufferAttribute | BufferAttributes} holding details of the geometry's morph targets.
	 * @remarks
	 * Once the geometry has been rendered, the morph attribute data cannot be changed.
	 * You will have to call {@link dispose | .dispose}(), and create a new instance of {@link BufferGeometry | BufferGeometry}.
	 * @defaultValue `{}`
	 */
	morphAttributes: {
		[name: string]: Array<BufferAttribute | InterleavedBufferAttribute>; // TODO Replace for 'Record<>'
	};
	/**
	 * Used to control the morph target behavior; when set to true, the morph target data is treated as relative offsets, rather than as absolute positions/normals.
	 * @defaultValue `false`
	 */
	morphTargetsRelative: boolean;
	/**
	 * Split the geometry into groups, each of which will be rendered in a separate WebGL draw call. This allows an array of materials to be used with the geometry.
	 * @remarks Every vertex and index must belong to exactly one group — groups must not share vertices or indices, and must not leave vertices or indices unused.
	 * @remarks Use {@link addGroup | .addGroup} to add groups, rather than modifying this array directly.
	 * @defaultValue `[]`
	 */
	groups: Array<{
		/**
		 * Specifies the first element in this draw call – the first vertex for non-indexed geometry, otherwise the first triangle index.
		 * @remarks Expects a `Integer`
		 */
		start: number;
		/**
		 * Specifies how many vertices (or indices) are included.
		 * @remarks Expects a `Integer`
		 */
		count: number;
		/**
		 * Specifies the material array index to use.
		 * @remarks Expects a `Integer`
		 */
		materialIndex?: number | undefined;
	}>;
	/**
	 * Bounding box for the {@link BufferGeometry | BufferGeometry}, which can be calculated with {@link computeBoundingBox | .computeBoundingBox()}.
	 * @remarks Bounding boxes aren't computed by default. They need to be explicitly computed, otherwise they are `null`.
	 * @defaultValue `null`
	 */
	boundingBox: Box3 | null;
	/**
	 * Bounding sphere for the {@link BufferGeometry | BufferGeometry}, which can be calculated with {@link computeBoundingSphere | .computeBoundingSphere()}.
	 * @remarks bounding spheres aren't computed by default. They need to be explicitly computed, otherwise they are `null`.
	 * @defaultValue `null`
	 */
	boundingSphere: Sphere | null;
	/**
	 * Determines the part of the geometry to render. This should not be set directly, instead use {@link setDrawRange | .setDrawRange(...)}.
	 * @remarks For non-indexed {@link BufferGeometry | BufferGeometry}, count is the number of vertices to render.
	 * @remarks For indexed {@link BufferGeometry | BufferGeometry}, count is the number of indices to render.
	 * @defaultValue `{ start: 0, count: Infinity }`
	 */
	drawRange: {
		start: number;
		count: number;
	};
	/**
	 * An object that can be used to store custom data about the BufferGeometry. It should not hold references to functions as these will not be cloned.
	 * @defaultValue `{}`
	 */
	userData: {
		[key: string]: any;
	};
	/**
	 * Read-only flag to check if a given object is of type {@link BufferGeometry}.
	 * @remarks This is a _constant_ value
	 * @defaultValue `true`
	 */
	readonly isBufferGeometry: true;
	/**
	 * Return the {@link index | .index} buffer.
	 */
	getIndex(): BufferAttribute | null;
	/**
	 * Set the {@link BufferGeometry.index | .index} buffer.
	 * @param index
	 */
	setIndex(index: BufferAttribute | number[] | null): this;
	/**
	 * Sets an {@link attributes | attribute} to this geometry with the specified name.
	 * @remarks
	 * Use this rather than the attributes property, because an internal hashmap of {@link attributes | .attributes} is maintained to speed up iterating over attributes.
	 * @param name
	 * @param attribute
	 */
	setAttribute<K extends keyof Attributes>(name: K, attribute: Attributes[K]): this;
	/**
	 * Returns the {@link attributes | attribute} with the specified name.
	 * @param name
	 */
	getAttribute<K extends keyof Attributes>(name: K): Attributes[K];
	/**
	 * Deletes the  {@link attributes | attribute} with the specified name.
	 * @param name
	 */
	deleteAttribute(name: keyof Attributes): this;
	/**
	 * Returns true if the {@link attributes | attribute} with the specified name exists.
	 * @param name
	 */
	hasAttribute(name: keyof Attributes): boolean;
	/**
	 * Adds a group to this geometry
	 * @see the {@link BufferGeometry.groups | groups} property for details.
	 * @param start
	 * @param count
	 * @param materialIndex
	 */
	addGroup(start: number, count: number, materialIndex?: number): void;
	/**
	 * Clears all groups.
	 */
	clearGroups(): void;
	/**
	 * Set the {@link drawRange | .drawRange} property
	 * @remarks For non-indexed BufferGeometry, count is the number of vertices to render
	 * @remarks For indexed BufferGeometry, count is the number of indices to render.
	 * @param start
	 * @param count is the number of vertices or indices to render. Expects a `Integer`
	 */
	setDrawRange(start: number, count: number): void;
	/**
	 * Applies the matrix transform to the geometry.
	 * @param matrix
	 */
	applyMatrix4(matrix: Matrix4): this;
	/**
	 * Applies the rotation represented by the quaternion to the geometry.
	 * @param quaternion
	 */
	applyQuaternion(quaternion: Quaternion): this;
	/**
	 * Rotate the geometry about the X axis. This is typically done as a one time operation, and not during a loop.
	 * @remarks Use {@link Object3D.rotation | Object3D.rotation} for typical real-time mesh rotation.
	 * @param angle radians. Expects a `Float`
	 */
	rotateX(angle: number): this;
	/**
	 * Rotate the geometry about the Y axis.
	 * @remarks This is typically done as a one time operation, and not during a loop.
	 * @remarks Use {@link Object3D.rotation | Object3D.rotation} for typical real-time mesh rotation.
	 * @param angle radians. Expects a `Float`
	 */
	rotateY(angle: number): this;
	/**
	 * Rotate the geometry about the Z axis.
	 * @remarks This is typically done as a one time operation, and not during a loop.
	 * @remarks Use {@link Object3D.rotation | Object3D.rotation} for typical real-time mesh rotation.
	 * @param angle radians. Expects a `Float`
	 */
	rotateZ(angle: number): this;
	/**
	 * Translate the geometry.
	 * @remarks This is typically done as a one time operation, and not during a loop.
	 * @remarks Use {@link Object3D.position | Object3D.position} for typical real-time mesh rotation.
	 * @param x Expects a `Float`
	 * @param y Expects a `Float`
	 * @param z Expects a `Float`
	 */
	translate(x: number, y: number, z: number): this;
	/**
	 * Scale the geometry data.
	 * @remarks This is typically done as a one time operation, and not during a loop.
	 * @remarks Use {@link Object3D.scale | Object3D.scale} for typical real-time mesh scaling.
	 * @param x Expects a `Float`
	 * @param y Expects a `Float`
	 * @param z Expects a `Float`
	 */
	scale(x: number, y: number, z: number): this;
	/**
	 * Rotates the geometry to face a point in space.
	 * @remarks This is typically done as a one time operation, and not during a loop.
	 * @remarks Use {@link Object3D.lookAt | Object3D.lookAt} for typical real-time mesh usage.
	 * @param vector A world vector to look at.
	 */
	lookAt(vector: Vector3): this;
	/**
	 * Center the geometry based on the bounding box.
	 */
	center(): this;
	/**
	 * Sets the attributes for this BufferGeometry from an array of points.
	 * @param points
	 */
	setFromPoints(points: Vector3[] | Vector2[]): this;
	/**
	 * Computes bounding box of the geometry, updating {@link boundingBox | .boundingBox} attribute.
	 * @remarks Bounding boxes aren't computed by default. They need to be explicitly computed, otherwise they are `null`.
	 */
	computeBoundingBox(): void;
	/**
	 * Computes bounding sphere of the geometry, updating {@link boundingSphere | .boundingSphere} attribute.
	 * @remarks bounding spheres aren't computed by default. They need to be explicitly computed, otherwise they are `null`.
	 */
	computeBoundingSphere(): void;
	/**
	 * Calculates and adds a tangent attribute to this geometry.
	 * The computation is only supported for indexed geometries and if position, normal, and uv attributes are defined
	 * @remarks
	 * When using a tangent space normal map, prefer the MikkTSpace algorithm provided by
	 * {@link BufferGeometryUtils.computeMikkTSpaceTangents} instead.
	 */
	computeTangents(): void;
	/**
	 * Computes vertex normals for the given vertex data. For indexed geometries, the method sets each vertex normal to
	 * be the average of the face normals of the faces that share that vertex. For non-indexed geometries, vertices are
	 * not shared, and the method sets each vertex normal to be the same as the face normal.
	 */
	computeVertexNormals(): void;
	/**
	 * Every normal vector in a geometry will have a magnitude of 1
	 * @remarks This will correct lighting on the geometry surfaces.
	 */
	normalizeNormals(): void;
	/**
	 * Return a non-index version of an indexed BufferGeometry.
	 */
	toNonIndexed(): BufferGeometry;
	/**
	 * Convert the buffer geometry to three.js {@link https://github.com/mrdoob/three.js/wiki/JSON-Object-Scene-format-4 | JSON Object/Scene format}.
	 */
	toJSON(): {};
	/**
	 * Creates a clone of this BufferGeometry
	 */
	clone(): this;
	/**
	 * Copies another BufferGeometry to this BufferGeometry.
	 * @param source
	 */
	copy(source: BufferGeometry): this;
	/**
	 * Frees the GPU-related resources allocated by this instance.
	 * @remarks Call this method whenever this instance is no longer used in your app.
	 */
	dispose(): void;
}
interface RenderItem {
	id: number;
	object: Object3D;
	geometry: BufferGeometry | null;
	material: Material;
	program: WebGLProgram;
	groupOrder: number;
	renderOrder: number;
	z: number;
	group: Group | null;
}
declare class WebGLRenderList {
	constructor(properties: WebGLProperties);
	/**
	 * @default []
	 */
	opaque: RenderItem[];
	/**
	 * @default []
	 */
	transparent: RenderItem[];
	/**
	 * @default []
	 */
	transmissive: RenderItem[];
	init(): void;
	push(object: Object3D, geometry: BufferGeometry | null, material: Material, groupOrder: number, z: number, group: Group | null): void;
	unshift(object: Object3D, geometry: BufferGeometry | null, material: Material, groupOrder: number, z: number, group: Group | null): void;
	sort(opaqueSort: (a: any, b: any) => number, transparentSort: (a: any, b: any) => number): void;
	finish(): void;
}
declare class WebGLRenderLists {
	constructor(properties: WebGLProperties);
	dispose(): void;
	get(scene: Scene, renderCallDepth: number): WebGLRenderList;
}
declare class WebGLMultipleRenderTargets extends EventDispatcher {
	texture: Texture[];
	readonly isWebGLMultipleRenderTargets = true;
	/**
	 * @param width The width of the render target.
	 * @param height The height of the render target.
	 * @param count The number of render targets.
	 * @param options object that holds texture parameters for an auto-generated target texture and depthBuffer/stencilBuffer booleans.
	 * For an explanation of the texture parameters see {@link Texture}.
	 */
	constructor(width?: number, height?: number, count?: number, options?: WebGLRenderTargetOptions);
	setSize(width: number, height: number, depth?: number): this;
	copy(source: WebGLMultipleRenderTargets): this;
	clone(): this;
	dispose(): void;
	// This is an available method, however it will break the code see https://github.com/mrdoob/three.js/issues/21930
	setTexture(texture: Texture): void;
}
declare class PerspectiveCamera extends Camera {
	/**
	 * Creates a new {@link PerspectiveCamera}.
	 * @remarks Together these define the camera's {@link https://en.wikipedia.org/wiki/Viewing_frustum | viewing frustum}.
	 * @param fov Camera frustum vertical field of view. Default `50`.
	 * @param aspect Camera frustum aspect ratio. Default `1`.
	 * @param near Camera frustum near plane. Default `0.1`.
	 * @param far Camera frustum far plane. Default `2000`.
	 */
	constructor(fov?: number, aspect?: number, near?: number, far?: number);
	/**
	 * Read-only flag to check if a given object is of type {@link Camera}.
	 * @remarks This is a _constant_ value
	 * @defaultValue `true`
	 */
	readonly isPerspectiveCamera: true;
	/**
	 * @override
	 * @defaultValue `PerspectiveCamera`
	 */
	override readonly type: string | "PerspectiveCamera";
	/**
	 * Gets or sets the zoom factor of the camera.
	 * @defaultValue `1`
	 */
	zoom: number;
	/**
	 * Camera frustum vertical field of view, from bottom to top of view, in degrees.
	 * @remarks Expects a `Float`
	 * @defaultValue `50`
	 */
	fov: number;
	/**
	 * Camera frustum aspect ratio, usually the canvas width / canvas height.
	 * @remarks Expects a `Float`
	 * @defaultValue `1`, _(square canvas)_.
	 */
	aspect: number;
	/**
	 * Camera frustum near plane.
	 * @remarks The valid range is greater than `0` and less than the current value of the {@link far | .far} plane.
	 * @remarks Note that, unlike for the {@link OrthographicCamera | OrthographicCamera}, `0` is **not** a valid value for a {@link PerspectiveCamera |PerspectiveCamera's}. near plane.
	 * @defaultValue `0.1`
	 * @remarks Expects a `Float`
	 */
	near: number;
	/**
	 * Camera frustum far plane.
	 * @remarks Must be greater than the current value of {@link near | .near} plane.
	 * @remarks Expects a `Float`
	 * @defaultValue `2000`
	 */
	far: number;
	/**
	 * Object distance used for stereoscopy and depth-of-field effects.
	 * @remarks This parameter does not influence the projection matrix unless a {@link StereoCamera | StereoCamera} is being used.
	 * @remarks Expects a `Float`
	 * @defaultValue `10`
	 */
	focus: number;
	/**
	 * Frustum window specification or null.
	 * This is set using the {@link setViewOffset | .setViewOffset} method and cleared using {@link clearViewOffset | .clearViewOffset}.
	 * @defaultValue `null`
	 */
	view: null | {
		enabled: boolean;
		fullWidth: number;
		fullHeight: number;
		offsetX: number;
		offsetY: number;
		width: number;
		height: number;
	};
	/**
	 * Film size used for the larger axis.
	 * This parameter does not influence the projection matrix unless {@link filmOffset | .filmOffset} is set to a nonzero value.
	 * @remarks Expects a `Float`
	 * @defaultValue `35`, _millimeters_.
	 */
	filmGauge: number;
	/**
	 * Horizontal off-center offset in the same unit as {@link filmGauge | .filmGauge}.
	 * @remarks Expects a `Float`
	 * @defaultValue `0`
	 */
	filmOffset: number;
	/**
	 * Returns the focal length of the current {@link .fov | fov} in respect to {@link filmGauge | .filmGauge}.
	 */
	getFocalLength(): number;
	/**
	 * Sets the FOV by focal length in respect to the current {@link filmGauge | .filmGauge}.
	 * @remarks By default, the focal length is specified for a `35mm` (full frame) camera.
	 * @param focalLength Expects a `Float`
	 */
	setFocalLength(focalLength: number): void;
	/**
	 * Returns the current vertical field of view angle in degrees considering {@link zoom | .zoom}.
	 */
	getEffectiveFOV(): number;
	/**
	 * Returns the width of the image on the film
	 * @remarks
	 * If {@link aspect | .aspect}. is greater than or equal to one (landscape format), the result equals {@link filmGauge | .filmGauge}.
	 */
	getFilmWidth(): number;
	/**
	 * Returns the height of the image on the film
	 * @remarks
	 * If {@link aspect | .aspect}. is less than or equal to one (portrait format), the result equals {@link filmGauge | .filmGauge}.
	 */
	getFilmHeight(): number;
	/**
	 * Sets an offset in a larger frustum.
	 * @remarks
	 * This is useful for multi-window or multi-monitor/multi-machine setups.
	 *
	 * For example, if you have 3x2 monitors and each monitor is _1920x1080_ and
	 * the monitors are in grid like this
	 * ```
	 * ┌───┬───┬───┐
	 * │ A │ B │ C │
	 * ├───┼───┼───┤
	 * │ D │ E │ F │
	 * └───┴───┴───┘
	 * ```
	 * then for each monitor you would call it like this
	 * ```typescript
	 *   const w = 1920;
	 *   const h = 1080;
	 *   const fullWidth = w * 3;
	 *   const fullHeight = h * 2;
	 *
	 *   // Monitor - A
	 *   camera.setViewOffset( fullWidth, fullHeight, w * 0, h * 0, w, h );
	 *   // Monitor - B
	 *   camera.setViewOffset( fullWidth, fullHeight, w * 1, h * 0, w, h );
	 *   // Monitor - C
	 *   camera.setViewOffset( fullWidth, fullHeight, w * 2, h * 0, w, h );
	 *   // Monitor - D
	 *   camera.setViewOffset( fullWidth, fullHeight, w * 0, h * 1, w, h );
	 *   // Monitor - E
	 *   camera.setViewOffset( fullWidth, fullHeight, w * 1, h * 1, w, h );
	 *   // Monitor - F
	 *   camera.setViewOffset( fullWidth, fullHeight, w * 2, h * 1, w, h );
	 * ```
	 * Note there is no reason monitors have to be the same size or in a grid.
	 * @param fullWidth Full width of multiview setup Expects a `Float`.
	 * @param fullHeight Full height of multiview setup Expects a `Float`.
	 * @param x Horizontal offset of subcamera Expects a `Float`.
	 * @param y Vertical offset of subcamera Expects a `Float`.
	 * @param width Width of subcamera Expects a `Float`.
	 * @param height Height of subcamera Expects a `Float`.
	 */
	setViewOffset(fullWidth: number, fullHeight: number, x: number, y: number, width: number, height: number): void;
	/**
	 * Removes any offset set by the {@link setViewOffset | .setViewOffset} method.
	 */
	clearViewOffset(): void;
	/**
	 * Updates the camera projection matrix
	 * @remarks Must be called after any change of parameters.
	 */
	updateProjectionMatrix(): void;
	/**
	 * @deprecated Use {@link PerspectiveCamera.setFocalLength | .setFocalLength()} and {@link PerspectiveCamera.filmGauge | .filmGauge} instead.
	 */
	setLens(focalLength: number, frameHeight?: number): void;
}
declare class ArrayCamera extends PerspectiveCamera {
	/**
	 * An array of cameras.
	 * @param array. Default `[]`.
	 */
	constructor(cameras?: PerspectiveCamera[]);
	/**
	 * Read-only flag to check if a given object is of type {@link ArrayCamera}.
	 * @remarks This is a _constant_ value
	 * @defaultValue `true`
	 */
	readonly isArrayCamera: true;
	/**
	 * An array of cameras.
	 * @defaultValue `[]`
	 */
	cameras: PerspectiveCamera[];
}
declare class XRJointSpace extends Group {
	readonly jointRadius: number | undefined;
}
type XRHandJoints = Record<XRHandJoint, XRJointSpace>;
interface XRHandInputState {
	pinching: boolean;
}
declare class XRHandSpace extends Group {
	readonly joints: Partial<XRHandJoints>;
	readonly inputState: XRHandInputState;
}
declare class XRTargetRaySpace extends Group {
	hasLinearVelocity: boolean;
	readonly linearVelocity: Vector3;
	hasAngularVelocity: boolean;
	readonly angularVelocity: Vector3;
}
declare class XRGripSpace extends Group {
	hasLinearVelocity: boolean;
	readonly linearVelocity: Vector3;
	hasAngularVelocity: boolean;
	readonly angularVelocity: Vector3;
}
type WebXRCamera = PerspectiveCamera & {
	viewport: Vector4;
};
type WebXRArrayCamera = Omit<ArrayCamera, "cameras"> & {
	cameras: [
		WebXRCamera,
		WebXRCamera
	];
};
declare class WebXRManager extends EventDispatcher {
	constructor(renderer: any, gl: WebGLRenderingContext);
	/**
	 * @default false
	 */
	enabled: boolean;
	/**
	 * @default false
	 */
	isPresenting: boolean;
	/**
	 * @default true
	 */
	cameraAutoUpdate: boolean;
	getController(index: number): XRTargetRaySpace;
	getControllerGrip(index: number): XRGripSpace;
	getHand(index: number): XRHandSpace;
	setFramebufferScaleFactor(value: number): void;
	setReferenceSpaceType(value: XRReferenceSpaceType): void;
	getReferenceSpace(): XRReferenceSpace | null;
	setReferenceSpace(value: XRReferenceSpace): void;
	getBaseLayer(): XRWebGLLayer | XRProjectionLayer;
	getBinding(): XRWebGLBinding;
	getFrame(): XRFrame;
	getSession(): XRSession | null;
	setSession(value: XRSession | null): Promise<void>;
	getCamera(): WebXRArrayCamera;
	updateCamera(camera: PerspectiveCamera): void;
	setAnimationLoop(callback: XRFrameRequestCallback | null): void;
	getFoveation(): number | undefined;
	setFoveation(value: number): void;
	/**
	 * Returns the set of planes detected by WebXR's plane detection API.
	 */
	getPlanes(): Set<XRPlane>;
	dispose(): void;
}
interface TextureImageData {
	readonly data: Uint8ClampedArray;
	readonly height: number;
	readonly width: number;
}
interface Texture3DImageData extends TextureImageData {
	readonly depth: number;
}
declare class Data3DTexture extends Texture {
	/**
	 * Create a new instance of {@link Data3DTexture}
	 * @param data {@link https://developer.mozilla.org/en-US/docs/Web/API/ArrayBufferView | ArrayBufferView} of the texture. Default `null`.
	 * @param width Width of the texture. Default `1`.
	 * @param height Height of the texture. Default `1`.
	 * @param depth Depth of the texture. Default `1`.
	 */
	constructor(data?: BufferSource | null, width?: number, height?: number, depth?: number);
	/**
	 * Read-only flag to check if a given object is of type {@link Data3DTexture}.
	 * @remarks This is a _constant_ value
	 * @defaultValue `true`
	 */
	readonly isData3DTexture: true;
	/**
	 * Overridden with a record type holding data, width and height and depth.
	 * @override
	 */
	get image(): Texture3DImageData;
	set image(data: Texture3DImageData);
	/**
	 * @override
	 * @defaultValue {@link NearestFilter}
	 */
	magFilter: MagnificationTextureFilter;
	/**
	 * @override
	 * @defaultValue {@link NearestFilter}
	 */
	minFilter: MinificationTextureFilter;
	/**
	 * @override
	 * @defaultValue {@link ClampToEdgeWrapping}
	 */
	wrapR: Wrapping;
	/**
	 * @override
	 * @defaultValue `false`
	 */
	flipY: boolean;
	/**
	 * @override
	 * @defaultValue `false`
	 */
	generateMipmaps: boolean;
	/**
	 * @override
	 * @defaultValue `1`
	 */
	unpackAlignment: number;
}
declare class DataArrayTexture extends Texture {
	/**
	 * This creates a new {@link DataArrayTexture | DataArrayTexture} object.
	 * @remarks The interpretation of the data depends on {@link format} and {@link type}.
	 * @remarks If the {@link type} is {@link UnsignedByteType}, a {@link Uint8Array} will be useful for addressing the texel data
	 * @remarks If the {@link format} is {@link RGBAFormat}, data needs four values for one texel; Red, Green, Blue and Alpha (typically the opacity).
	 * @remarks For the packed {@link type | types}, {@link UnsignedShort4444Type} and {@link THREE.UnsignedShort5551Type}
	 * all color components of one texel can be addressed as bitfields within an integer element of a {@link Uint16Array}.
	 * @remarks In order to use the {@link type | types} {@link FloatType} and {@link THREE.HalfFloatType},
	 * the WebGL implementation must support the respective extensions _OES_texture_float_ and _OES_texture_half_float_
	 * @remarks In order to use {@link LinearFilter} for component-wise, bilinear interpolation of the texels based on these types,
	 * the WebGL extensions _OES_texture_float_linear_ or _OES_texture_half_float_linear_ must also be present.
	 * @param data {@link https://developer.mozilla.org/en-US/docs/Web/API/ArrayBufferView | ArrayBufferView} of the texture. Default `null`.
	 * @param width Width of the texture. Default `1`.
	 * @param height Height of the texture. Default `1`.
	 * @param depth Depth of the texture. Default `1`.
	 */
	constructor(data?: BufferSource, width?: number, height?: number, depth?: number);
	/**
	 * Read-only flag to check if a given object is of type {@link DataArrayTexture}.
	 * @remarks This is a _constant_ value
	 * @defaultValue `true`
	 */
	readonly isDataArrayTexture: true;
	/**
	 * Overridden with a record type holding data, width and height and depth.
	 * @override
	 */
	get image(): Texture3DImageData;
	set image(data: Texture3DImageData);
	/**
	 * @override
	 * @defaultValue {@link NearestFilter}
	 */
	magFilter: MagnificationTextureFilter;
	/**
	 * @override
	 * @defaultValue {@link NearestFilter}
	 */
	minFilter: MinificationTextureFilter;
	/**
	 * @override
	 * @defaultValue  {@link ClampToEdgeWrapping}
	 */
	wrapR: boolean;
	/**
	 * @override
	 * @defaultValue `false`
	 */
	flipY: boolean;
	/**
	 * @override
	 * @defaultValue `false`
	 */
	generateMipmaps: boolean;
	/**
	 * @override
	 * @defaultValue `1`
	 */
	unpackAlignment: number;
}
interface Renderer {
	domElement: HTMLCanvasElement;
	render(scene: Object3D, camera: Camera): void;
	setSize(width: number, height: number, updateStyle?: boolean): void;
}
interface WebGLRendererParameters {
	/**
	 * A Canvas where the renderer draws its output.
	 */
	canvas?: HTMLCanvasElement | OffscreenCanvas | undefined;
	/**
	 * A WebGL Rendering Context.
	 * (https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext)
	 * Default is null
	 */
	context?: WebGLRenderingContext | undefined;
	/**
	 * shader precision. Can be "highp", "mediump" or "lowp".
	 */
	precision?: string | undefined;
	/**
	 * default is false.
	 */
	alpha?: boolean | undefined;
	/**
	 * default is true.
	 */
	premultipliedAlpha?: boolean | undefined;
	/**
	 * default is false.
	 */
	antialias?: boolean | undefined;
	/**
	 * default is true.
	 */
	stencil?: boolean | undefined;
	/**
	 * default is false.
	 */
	preserveDrawingBuffer?: boolean | undefined;
	/**
	 * Can be "high-performance", "low-power" or "default"
	 */
	powerPreference?: string | undefined;
	/**
	 * default is true.
	 */
	depth?: boolean | undefined;
	/**
	 * default is false.
	 */
	logarithmicDepthBuffer?: boolean | undefined;
	/**
	 * default is false.
	 */
	failIfMajorPerformanceCaveat?: boolean | undefined;
}
interface WebGLDebug {
	/**
	 * Enables error checking and reporting when shader programs are being compiled.
	 */
	checkShaderErrors: boolean;
	/**
	 * A callback function that can be used for custom error reporting. The callback receives the WebGL context, an
	 * instance of WebGLProgram as well two instances of WebGLShader representing the vertex and fragment shader.
	 * Assigning a custom function disables the default error reporting.
	 * @default `null`
	 */
	onShaderError: ((gl: WebGLRenderingContext, program: WebGLProgram, glVertexShader: WebGLShader, glFragmentShader: WebGLShader) => void) | null;
}
declare class WebGLRenderer implements Renderer {
	/**
	 * parameters is an optional object with properties defining the renderer's behaviour.
	 * The constructor also accepts no parameters at all.
	 * In all cases, it will assume sane defaults when parameters are missing.
	 */
	constructor(parameters?: WebGLRendererParameters);
	/**
	 * A Canvas where the renderer draws its output.
	 * This is automatically created by the renderer in the constructor (if not provided already); you just need to add it to your page.
	 * @default document.createElementNS( 'http://www.w3.org/1999/xhtml', 'canvas' )
	 */
	domElement: HTMLCanvasElement;
	/**
	 * Defines whether the renderer should automatically clear its output before rendering.
	 * @default true
	 */
	autoClear: boolean;
	/**
	 * If autoClear is true, defines whether the renderer should clear the color buffer. Default is true.
	 * @default true
	 */
	autoClearColor: boolean;
	/**
	 * If autoClear is true, defines whether the renderer should clear the depth buffer. Default is true.
	 * @default true
	 */
	autoClearDepth: boolean;
	/**
	 * If autoClear is true, defines whether the renderer should clear the stencil buffer. Default is true.
	 * @default true
	 */
	autoClearStencil: boolean;
	/**
	 * Debug configurations.
	 * @default { checkShaderErrors: true }
	 */
	debug: WebGLDebug;
	/**
	 * Defines whether the renderer should sort objects. Default is true.
	 * @default true
	 */
	sortObjects: boolean;
	/**
	 * @default []
	 */
	clippingPlanes: any[];
	/**
	 * @default false
	 */
	localClippingEnabled: boolean;
	extensions: WebGLExtensions;
	/**
	 * Default is LinearEncoding.
	 * @default LinearEncoding
	 * @deprecated Use {@link WebGLRenderer.outputColorSpace .outputColorSpace} in three.js r152+.
	 */
	outputEncoding: TextureEncoding;
	/**
	 * Color space used for output to HTMLCanvasElement. Supported values are
	 * {@link SRGBColorSpace} and {@link LinearSRGBColorSpace}.
	 * @default SRGBColorSpace.
	 */
	outputColorSpace: ColorSpace;
	/**
	 * @default true
	 */
	useLegacyLights: boolean;
	/**
	 * @default NoToneMapping
	 */
	toneMapping: ToneMapping;
	/**
	 * @default 1
	 */
	toneMappingExposure: number;
	info: WebGLInfo;
	shadowMap: WebGLShadowMap;
	pixelRatio: number;
	capabilities: WebGLCapabilities;
	properties: WebGLProperties;
	renderLists: WebGLRenderLists;
	state: WebGLState;
	xr: WebXRManager;
	/**
	 * Return the WebGL context.
	 */
	getContext(): WebGLRenderingContext | WebGL2RenderingContext;
	getContextAttributes(): any;
	forceContextLoss(): void;
	forceContextRestore(): void;
	/**
	 * @deprecated Use {@link WebGLCapabilities#getMaxAnisotropy .capabilities.getMaxAnisotropy()} instead.
	 */
	getMaxAnisotropy(): number;
	/**
	 * @deprecated Use {@link WebGLCapabilities#precision .capabilities.precision} instead.
	 */
	getPrecision(): string;
	getPixelRatio(): number;
	setPixelRatio(value: number): void;
	getDrawingBufferSize(target: Vector2): Vector2;
	setDrawingBufferSize(width: number, height: number, pixelRatio: number): void;
	getSize(target: Vector2): Vector2;
	/**
	 * Resizes the output canvas to (width, height), and also sets the viewport to fit that size, starting in (0, 0).
	 */
	setSize(width: number, height: number, updateStyle?: boolean): void;
	getCurrentViewport(target: Vector4): Vector4;
	/**
	 * Copies the viewport into target.
	 */
	getViewport(target: Vector4): Vector4;
	/**
	 * Sets the viewport to render from (x, y) to (x + width, y + height).
	 * (x, y) is the lower-left corner of the region.
	 */
	setViewport(x: Vector4 | number, y?: number, width?: number, height?: number): void;
	/**
	 * Copies the scissor area into target.
	 */
	getScissor(target: Vector4): Vector4;
	/**
	 * Sets the scissor area from (x, y) to (x + width, y + height).
	 */
	setScissor(x: Vector4 | number, y?: number, width?: number, height?: number): void;
	/**
	 * Returns true if scissor test is enabled; returns false otherwise.
	 */
	getScissorTest(): boolean;
	/**
	 * Enable the scissor test. When this is enabled, only the pixels within the defined scissor area will be affected by further renderer actions.
	 */
	setScissorTest(enable: boolean): void;
	/**
	 * Sets the custom opaque sort function for the WebGLRenderLists. Pass null to use the default painterSortStable function.
	 */
	setOpaqueSort(method: (a: any, b: any) => number): void;
	/**
	 * Sets the custom transparent sort function for the WebGLRenderLists. Pass null to use the default reversePainterSortStable function.
	 */
	setTransparentSort(method: (a: any, b: any) => number): void;
	/**
	 * Returns a Color instance with the current clear color.
	 */
	getClearColor(target: Color): Color;
	/**
	 * Sets the clear color, using color for the color and alpha for the opacity.
	 */
	setClearColor(color: ColorRepresentation, alpha?: number): void;
	/**
	 * Returns a float with the current clear alpha. Ranges from 0 to 1.
	 */
	getClearAlpha(): number;
	setClearAlpha(alpha: number): void;
	/**
	 * Tells the renderer to clear its color, depth or stencil drawing buffer(s).
	 * Arguments default to true
	 */
	clear(color?: boolean, depth?: boolean, stencil?: boolean): void;
	clearColor(): void;
	clearDepth(): void;
	clearStencil(): void;
	clearTarget(renderTarget: WebGLRenderTarget, color: boolean, depth: boolean, stencil: boolean): void;
	/**
	 * @deprecated Use {@link WebGLState#reset .state.reset()} instead.
	 */
	resetGLState(): void;
	dispose(): void;
	renderBufferDirect(camera: Camera, scene: Scene, geometry: BufferGeometry, material: Material, object: Object3D, geometryGroup: any): void;
	/**
	 * A build in function that can be used instead of requestAnimationFrame. For WebXR projects this function must be used.
	 * @param callback The function will be called every available frame. If `null` is passed it will stop any already ongoing animation.
	 */
	setAnimationLoop(callback: XRFrameRequestCallback | null): void;
	/**
	 * @deprecated Use {@link WebGLRenderer#setAnimationLoop .setAnimationLoop()} instead.
	 */
	animate(callback: () => void): void;
	/**
	 * Compiles all materials in the scene with the camera. This is useful to precompile shaders before the first rendering.
	 */
	compile(scene: Object3D, camera: Camera): void;
	/**
	 * Render a scene or an object using a camera.
	 * The render is done to a previously specified {@link WebGLRenderTarget#renderTarget .renderTarget} set by calling
	 * {@link WebGLRenderer#setRenderTarget .setRenderTarget} or to the canvas as usual.
	 *
	 * By default render buffers are cleared before rendering but you can prevent this by setting the property
	 * {@link WebGLRenderer#autoClear autoClear} to false. If you want to prevent only certain buffers being cleared
	 * you can set either the {@link WebGLRenderer#autoClearColor autoClearColor},
	 * {@link WebGLRenderer#autoClearStencil autoClearStencil} or {@link WebGLRenderer#autoClearDepth autoClearDepth}
	 * properties to false. To forcibly clear one ore more buffers call {@link WebGLRenderer#clear .clear}.
	 */
	render(scene: Object3D, camera: Camera): void;
	/**
	 * Returns the current active cube face.
	 */
	getActiveCubeFace(): number;
	/**
	 * Returns the current active mipmap level.
	 */
	getActiveMipmapLevel(): number;
	/**
	 * Returns the current render target. If no render target is set, null is returned.
	 */
	getRenderTarget(): WebGLRenderTarget | null;
	/**
	 * @deprecated Use {@link WebGLRenderer#getRenderTarget .getRenderTarget()} instead.
	 */
	getCurrentRenderTarget(): WebGLRenderTarget | null;
	/**
	 * Sets the active render target.
	 *
	 * @param renderTarget The {@link WebGLRenderTarget renderTarget} that needs to be activated. When `null` is given, the canvas is set as the active render target instead.
	 * @param activeCubeFace Specifies the active cube side (PX 0, NX 1, PY 2, NY 3, PZ 4, NZ 5) of {@link WebGLCubeRenderTarget}.
	 * @param activeMipmapLevel Specifies the active mipmap level.
	 */
	setRenderTarget(renderTarget: WebGLRenderTarget | WebGLMultipleRenderTargets | null, activeCubeFace?: number, activeMipmapLevel?: number): void;
	readRenderTargetPixels(renderTarget: WebGLRenderTarget | WebGLMultipleRenderTargets, x: number, y: number, width: number, height: number, buffer: any, activeCubeFaceIndex?: number): void;
	/**
	 * Copies a region of the currently bound framebuffer into the selected mipmap level of the selected texture.
	 * This region is defined by the size of the destination texture's mip level, offset by the input position.
	 *
	 * @param position Specifies the pixel offset from which to copy out of the framebuffer.
	 * @param texture Specifies the destination texture.
	 * @param level Specifies the destination mipmap level of the texture.
	 */
	copyFramebufferToTexture(position: Vector2, texture: Texture, level?: number): void;
	/**
	 * Copies srcTexture to the specified level of dstTexture, offset by the input position.
	 *
	 * @param position Specifies the pixel offset into the dstTexture where the copy will occur.
	 * @param srcTexture Specifies the source texture.
	 * @param dstTexture Specifies the destination texture.
	 * @param level Specifies the destination mipmap level of the texture.
	 */
	copyTextureToTexture(position: Vector2, srcTexture: Texture, dstTexture: Texture, level?: number): void;
	/**
	 * Copies the pixels of a texture in the bounds sourceBox in the desination texture starting from the given position.
	 * @param sourceBox Specifies the bounds
	 * @param position Specifies the pixel offset into the dstTexture where the copy will occur.
	 * @param srcTexture Specifies the source texture.
	 * @param dstTexture Specifies the destination texture.
	 * @param level Specifies the destination mipmap level of the texture.
	 */
	copyTextureToTexture3D(sourceBox: Box3, position: Vector3, srcTexture: Texture, dstTexture: Data3DTexture | DataArrayTexture, level?: number): void;
	/**
	 * Initializes the given texture. Can be used to preload a texture rather than waiting until first render (which can cause noticeable lags due to decode and GPU upload overhead).
	 *
	 * @param texture The texture to Initialize.
	 */
	initTexture(texture: Texture): void;
	/**
	 * Can be used to reset the internal WebGL state.
	 */
	resetState(): void;
	/**
	 * @deprecated Use {@link WebGLRenderer#xr .xr} instead.
	 */
	vr: boolean;
	/**
	 * @deprecated Use {@link WebGLShadowMap#enabled .shadowMap.enabled} instead.
	 */
	shadowMapEnabled: boolean;
	/**
	 * @deprecated Use {@link WebGLShadowMap#type .shadowMap.type} instead.
	 */
	shadowMapType: ShadowMapType;
	/**
	 * @deprecated Use {@link WebGLShadowMap#cullFace .shadowMap.cullFace} instead.
	 */
	shadowMapCullFace: CullFace;
	/**
	 * @deprecated Use {@link WebGLExtensions#get .extensions.get( 'OES_texture_float' )} instead.
	 */
	supportsFloatTextures(): any;
	/**
	 * @deprecated Use {@link WebGLExtensions#get .extensions.get( 'OES_texture_half_float' )} instead.
	 */
	supportsHalfFloatTextures(): any;
	/**
	 * @deprecated Use {@link WebGLExtensions#get .extensions.get( 'OES_standard_derivatives' )} instead.
	 */
	supportsStandardDerivatives(): any;
	/**
	 * @deprecated Use {@link WebGLExtensions#get .extensions.get( 'WEBGL_compressed_texture_s3tc' )} instead.
	 */
	supportsCompressedTextureS3TC(): any;
	/**
	 * @deprecated Use {@link WebGLExtensions#get .extensions.get( 'WEBGL_compressed_texture_pvrtc' )} instead.
	 */
	supportsCompressedTexturePVRTC(): any;
	/**
	 * @deprecated Use {@link WebGLExtensions#get .extensions.get( 'EXT_blend_minmax' )} instead.
	 */
	supportsBlendMinMax(): any;
	/**
	 * @deprecated Use {@link WebGLCapabilities#vertexTextures .capabilities.vertexTextures} instead.
	 */
	supportsVertexTextures(): any;
	/**
	 * @deprecated Use {@link WebGLExtensions#get .extensions.get( 'ANGLE_instanced_arrays' )} instead.
	 */
	supportsInstancedArrays(): any;
	/**
	 * @deprecated Use {@link WebGLRenderer#setScissorTest .setScissorTest()} instead.
	 */
	enableScissorTest(boolean: any): any;
}
declare class Ray {
	constructor(origin?: Vector3, direction?: Vector3);
	/**
	 * @default new Vector3()
	 */
	origin: Vector3;
	/**
	 * @default new Vector3( 0, 0, - 1 )
	 */
	direction: Vector3;
	set(origin: Vector3, direction: Vector3): Ray;
	clone(): this;
	copy(ray: Ray): this;
	at(t: number, target: Vector3): Vector3;
	lookAt(v: Vector3): Ray;
	recast(t: number): Ray;
	closestPointToPoint(point: Vector3, target: Vector3): Vector3;
	distanceToPoint(point: Vector3): number;
	distanceSqToPoint(point: Vector3): number;
	distanceSqToSegment(v0: Vector3, v1: Vector3, optionalPointOnRay?: Vector3, optionalPointOnSegment?: Vector3): number;
	intersectSphere(sphere: Sphere, target: Vector3): Vector3 | null;
	intersectsSphere(sphere: Sphere): boolean;
	distanceToPlane(plane: Plane): number;
	intersectPlane(plane: Plane, target: Vector3): Vector3 | null;
	intersectsPlane(plane: Plane): boolean;
	intersectBox(box: Box3, target: Vector3): Vector3 | null;
	intersectsBox(box: Box3): boolean;
	intersectTriangle(a: Vector3, b: Vector3, c: Vector3, backfaceCulling: boolean, target: Vector3): Vector3 | null;
	applyMatrix4(matrix4: Matrix4): Ray;
	equals(ray: Ray): boolean;
	/**
	 * @deprecated Use {@link Ray#intersectsBox .intersectsBox()} instead.
	 */
	isIntersectionBox(b: any): any;
	/**
	 * @deprecated Use {@link Ray#intersectsPlane .intersectsPlane()} instead.
	 */
	isIntersectionPlane(p: any): any;
	/**
	 * @deprecated Use {@link Ray#intersectsSphere .intersectsSphere()} instead.
	 */
	isIntersectionSphere(s: any): any;
}
interface Face {
	a: number;
	b: number;
	c: number;
	normal: Vector3;
	materialIndex: number;
}
interface Intersection<TIntersected extends Object3D = Object3D> {
	/** Distance between the origin of the ray and the intersection */
	distance: number;
	distanceToRay?: number | undefined;
	/** Point of intersection, in world coordinates */
	point: Vector3;
	index?: number | undefined;
	/** Intersected face */
	face?: Face | null | undefined;
	/** Index of the intersected face */
	faceIndex?: number | undefined;
	/** The intersected object */
	object: TIntersected;
	uv?: Vector2 | undefined;
	uv1?: Vector2 | undefined;
	normal?: Vector3;
	/** The index number of the instance where the ray intersects the {@link InstancedMesh | InstancedMesh } */
	instanceId?: number | undefined;
}
interface RaycasterParameters {
	Mesh?: any;
	Line?: {
		threshold: number;
	} | undefined;
	Line2?: {
		threshold: number;
	} | undefined;
	LOD?: any;
	Points?: {
		threshold: number;
	} | undefined;
	Sprite?: any;
}
// @ts-ignore
declare class Raycaster {
	/**
	 * This creates a new {@link Raycaster} object.
	 * @param origin The origin vector where the ray casts from. Default `new Vector3()`
	 * @param direction The direction vector that gives direction to the ray. Should be normalized. Default `new Vector3(0, 0, -1)`
	 * @param near All results returned are further away than near. Near can't be negative. Expects a `Float`. Default `0`
	 * @param far All results returned are closer than far. Far can't be lower than near. Expects a `Float`. Default `Infinity`
	 */
	constructor(origin?: Vector3, direction?: Vector3, near?: number, far?: number);
	/**
	 * The {@link RaycasterRay | Ray} used for the raycasting.
	 */
	ray: Ray;
	/**
	 * The near factor of the raycaster. This value indicates which objects can be discarded based on the distance.
	 * This value shouldn't be negative and should be smaller than the far property.
	 * @remarks Expects a `Float`
	 * @defaultValue `0`
	 */
	near: number;
	/**
	 * The far factor of the raycaster. This value indicates which objects can be discarded based on the distance.
	 * This value shouldn't be negative and should be larger than the near property.
	 * @remarks Expects a `Float`
	 * @defaultValue `Infinity`
	 */
	far: number;
	/**
	 * The camera to use when raycasting against view-dependent objects such as billboarded objects like {@link Sprites | Sprites}.
	 * This field can be set manually or is set when calling  {@link setFromCamera}.
	 * @defaultValue `null`
	 */
	camera: Camera;
	/**
	 * Used by {@link Raycaster} to selectively ignore 3D objects when performing intersection tests.
	 * The following code example ensures that only 3D objects on layer `1` will be honored by the instance of Raycaster.
	 * ```
	 * raycaster.layers.set( 1 );
	 * object.layers.enable( 1 );
	 * ```
	 * @defaultValue `new Layers()` - See {@link THREE.Layers | Layers}.
	 */
	layers: Layers;
	/**
	 * An data object where threshold is the precision of the {@link Raycaster} when intersecting objects, in world units.
	 * @defaultValue `{ Mesh: {}, Line: { threshold: 1 }, LOD: {}, Points: { threshold: 1 }, Sprite: {} }`
	 */
	params: RaycasterParameters;
	/**
	 * Updates the ray with a new origin and direction
	 * @remarks
	 * Please note that this method only copies the values from the arguments.
	 * @param origin The origin vector where the ray casts from.
	 * @param direction The normalized direction vector that gives direction to the ray.
	 */
	set(origin: Vector3, direction: Vector3): void;
	/**
	 * Updates the ray with a new origin and direction.
	 * @param coords 2D coordinates of the mouse, in normalized device coordinates (NDC)---X and Y components should be between -1 and 1.
	 * @param camera camera from which the ray should originate
	 */
	setFromCamera(coords: Vector2, camera: Camera): void;
	/**
	 * Checks all intersection between the ray and the object with or without the descendants
	 * @remarks Intersections are returned sorted by distance, closest first
	 * @remarks {@link Raycaster} delegates to the {@link Object3D.raycast | raycast} method of the passed object, when evaluating whether the ray intersects the object or not
	 * This allows {@link Mesh | meshes} to respond differently to ray casting than {@link THREE.Line | lines} and {@link THREE.Points | pointclouds}.
	 * **Note** that for meshes, faces must be pointed towards the origin of the {@link Raycaster.ray | ray} in order to be detected;
	 * intersections of the ray passing through the back of a face will not be detected
	 * To raycast against both faces of an object, you'll want to set the {@link Mesh.material | material}'s {@link Material.side | side} property to `DoubleSide`.
	 * @see {@link intersectObjects | .intersectObjects()}.
	 * @param object The object to check for intersection with the ray.
	 * @param recursive If true, it also checks all descendants. Otherwise it only checks intersection with the object. Default `true`
	 * @param optionalTarget Target to set the result. Otherwise a new {@link Array | Array} is instantiated.
	 * If set, you must clear this array prior to each call (i.e., array.length = 0;). Default `[]`
	 * @returns An array of intersections is returned.
	 */
	intersectObject<TIntersected extends Object3D>(object: Object3D, recursive?: boolean, optionalTarget?: Array<Intersection<TIntersected>>): Array<Intersection<TIntersected>>;
	/**
	 * Checks all intersection between the ray and the objects with or without the descendants
	 * @remarks Intersections are returned sorted by distance, closest first
	 * @remarks Intersections are of the same form as those returned by {@link intersectObject | .intersectObject()}.
	 * @remarks {@link Raycaster} delegates to the {@link Object3D.raycast | raycast} method of the passed object, when evaluating whether the ray intersects the object or not
	 * This allows {@link Mesh | meshes} to respond differently to ray casting than {@link THREE.Line | lines} and {@link THREE.Points | pointclouds}.
	 * **Note** that for meshes, faces must be pointed towards the origin of the {@link Raycaster.ray | ray} in order to be detected;
	 * intersections of the ray passing through the back of a face will not be detected
	 * To raycast against both faces of an object, you'll want to set the {@link Mesh.material | material}'s {@link Material.side | side} property to `DoubleSide`.
	 * @see {@link intersectObject | .intersectObject()}.
	 * @param objects The objects to check for intersection with the ray.
	 * @param recursive If true, it also checks all descendants of the objects. Otherwise it only checks intersection with the objects. Default `true`
	 * @param optionalTarget Target to set the result. Otherwise a new {@link Array | Array} is instantiated.
	 * If set, you must clear this array prior to each call (i.e., array.length = 0;). Default `[]`
	 * @returns An array of intersections is returned.
	 */
	intersectObjects<TIntersected extends Object3D>(objects: Object3D[], recursive?: boolean, optionalTarget?: Array<Intersection<TIntersected>>): Array<Intersection<TIntersected>>;
}
declare class Object3D<E extends BaseEvent = Event> extends EventDispatcher<E> {
	/**
	 * This creates a new {@link Object3D} object.
	 */
	constructor();
	/**
	 * Flag to check if a given object is of type {@link Object3D}.
	 * @remarks This is a _constant_ value
	 * @defaultValue `true`
	 */
	readonly isObject3D: true;
	/**
	 * Unique number for this {@link Object3D} instance.
	 * @remarks Note that ids are assigned in chronological order: 1, 2, 3, ..., incrementing by one for each new object.
	 * @remarks Expects a `Integer`
	 */
	readonly id: number;
	/**
	 * {@link http://en.wikipedia.org/wiki/Universally_unique_identifier | UUID} of this object instance.
	 * @remarks This gets automatically assigned and shouldn't be edited.
	 */
	uuid: string;
	/**
	 * Optional name of the object
	 * @remarks _(doesn't need to be unique)_.
	 * @defaultValue `""`
	 */
	name: string;
	/**
	 * A Read-only _string_ to check `this` object type.
	 * @remarks This can be used to find a specific type of Object3D in a scene.
	 * @remarks Sub-classes will update this value.
	 * @defaultValue `Object3D`
	 */
	readonly type: string | "Object3D";
	/**
	 * Object's parent in the {@link https://en.wikipedia.org/wiki/Scene_graph | scene graph}.
	 * @remarks An object can have at most one parent.
	 * @defaultValue `null`
	 */
	parent: Object3D | null;
	/**
	 * Array with object's children.
	 * @see {@link Object3DGroup | Group} for info on manually grouping objects.
	 * @defaultValue `[]`
	 */
	children: Object3D[];
	/**
	 * This is used by the {@link lookAt | lookAt} method, for example, to determine the orientation of the result.
	 * @defaultValue {@link DEFAULT_UP | Object3D.DEFAULT_UP} - that is `(0, 1, 0)`.
	 */
	up: Vector3;
	/**
	 * Object's local position.
	 * @defaultValue `new Vector3()` - that is `(0, 0, 0)`.
	 */
	readonly position: Vector3;
	/**
	 * Object's local rotation ({@link https://en.wikipedia.org/wiki/Euler_angles | Euler angles}), in radians.
	 * @defaultValue `new Euler()` - that is `(0, 0, 0, Euler.DEFAULT_ORDER)`.
	 */
	readonly rotation: Euler;
	/**
	 * Object's local rotation as a {@link Quaternion | Quaternion}.
	 * @defaultValue `new Quaternion()` - that is `(0,  0, 0, 1)`.
	 */
	readonly quaternion: Quaternion;
	/**
	 * The object's local scale.
	 * @defaultValue `new Vector3( 1, 1, 1 )`
	 */
	readonly scale: Vector3;
	/**
	 * @defaultValue `new Matrix4()`
	 */
	readonly modelViewMatrix: Matrix4;
	/**
	 * @defaultValue `new Matrix3()`
	 */
	readonly normalMatrix: Matrix3;
	/**
	 * The local transform matrix.
	 * @defaultValue `new Matrix4()`
	 */
	matrix: Matrix4;
	/**
	 * The global transform of the object.
	 * @remarks If the {@link Object3D} has no parent, then it's identical to the local transform {@link Object3D.matrix | .matrix}.
	 * @defaultValue `new Matrix4()`
	 */
	matrixWorld: Matrix4;
	/**
	 * When this is set, it calculates the matrix of position, (rotation or quaternion) and
	 * scale every frame and also recalculates the matrixWorld property.
	 * @defaultValue {@link DEFAULT_MATRIX_AUTO_UPDATE} - that is `(true)`.
	 */
	matrixAutoUpdate: boolean;
	/**
	 * If set, then the renderer checks every frame if the object and its children need matrix updates.
	 * When it isn't, then you have to maintain all matrices in the object and its children yourself.
	 * @defaultValue {@link DEFAULT_MATRIX_WORLD_AUTO_UPDATE} - that is `(true)`.
	 */
	matrixWorldAutoUpdate: boolean;
	/**
	 * When this is set, it calculates the matrixWorld in that frame and resets this property to false.
	 * @defaultValue `false`
	 */
	matrixWorldNeedsUpdate: boolean;
	/**
	 * The layer membership of the object.
	 * @remarks The object is only visible if it has at least one layer in common with the {@link Object3DCamera | Camera} in use.
	 * @remarks This property can also be used to filter out unwanted objects in ray-intersection tests when using {@link Raycaster | Raycaster}.
	 * @defaultValue `new Layers()`
	 */
	layers: Layers;
	/**
	 * Object gets rendered if `true`.
	 * @defaultValue `true`
	 */
	visible: boolean;
	/**
	 * Whether the object gets rendered into shadow map.
	 * @defaultValue `false`
	 */
	castShadow: boolean;
	/**
	 * Whether the material receives shadows.
	 * @defaultValue `false`
	 */
	receiveShadow: boolean;
	/**
	 * When this is set, it checks every frame if the object is in the frustum of the camera before rendering the object.
	 * If set to `false` the object gets rendered every frame even if it is not in the frustum of the camera.
	 * @defaultValue `true`
	 */
	frustumCulled: boolean;
	/**
	 * This value allows the default rendering order of {@link https://en.wikipedia.org/wiki/Scene_graph | scene graph}
	 * objects to be overridden although opaque and transparent objects remain sorted independently.
	 * @remarks When this property is set for an instance of {@link Group | Group}, all descendants objects will be sorted and rendered together.
	 * @remarks Sorting is from lowest to highest renderOrder.
	 * @defaultValue `0`
	 */
	renderOrder: number;
	/**
	 * Array with object's animation clips.
	 * @defaultValue `[]`
	 */
	animations: AnimationClip[];
	/**
	 * An object that can be used to store custom data about the {@link Object3D}.
	 * @remarks It should not hold references to _functions_ as these **will not** be cloned.
	 * @default `{}`
	 */
	userData: {
		[key: string]: any;
	}; // TODO Replace this to a Record?
	/**
	 * Custom depth material to be used when rendering to the depth map.
	 * @remarks Can only be used in context of meshes.
	 * @remarks When shadow-casting with a {@link DirectionalLight | DirectionalLight} or {@link THREE.SpotLight | SpotLight},
	 * if you are modifying vertex positions in the vertex shader you must specify a customDepthMaterial for proper shadows.
	 * @defaultValue `undefined`
	 */
	customDepthMaterial?: Material | undefined;
	/**
	 * Same as {@link customDepthMaterial}, but used with {@link Object3DPointLight | PointLight}.
	 * @defaultValue `undefined`
	 */
	customDistanceMaterial?: Material | undefined;
	/**
	 * An optional callback that is executed immediately before a 3D object is rendered.
	 * @remarks This function is called with the following parameters: renderer, scene, camera, geometry, material, group.
	 * @remarks Please notice that this callback is only executed for `renderable` 3D objects.
	 * Meaning 3D objects which define their visual appearance with geometries and materials like
	 * instances of {@link Object3DMesh | Mesh}, {@link THREE.Object3DLine | Line}, {@link THREE.Object3DPoints | Points} or {@link THREE.Object3DSprite | Sprite}.
	 * Instances of {@link Object3DObject3D | Object3D}, {@link THREE.Object3DGroup | Group} or {@link THREE.Object3DBone | Bone}
	 * are not renderable and thus this callback is not executed for such objects.
	 * @defaultValue `() => {}`
	 */
	onBeforeRender: (renderer: WebGLRenderer, scene: Scene, camera: Camera, geometry: BufferGeometry, material: Material, group: Group) => void;
	/**
	 * An optional callback that is executed immediately after a 3D object is rendered.
	 * @remarks This function is called with the following parameters: renderer, scene, camera, geometry, material, group.
	 * @remarks Please notice that this callback is only executed for `renderable` 3D objects.
	 * Meaning 3D objects which define their visual appearance with geometries and materials like
	 * instances of {@link Object3DMesh | Mesh}, {@link THREE.Object3DLine | Line}, {@link THREE.Object3DPoints | Points} or {@link THREE.Object3DSprite | Sprite}.
	 * Instances of {@link Object3DObject3D | Object3D}, {@link THREE.Object3DGroup | Group} or {@link THREE.Object3DBone | Bone}
	 * are not renderable and thus this callback is not executed for such objects.
	 * @defaultValue `() => {}`
	 */
	onAfterRender: (renderer: WebGLRenderer, scene: Scene, camera: Camera, geometry: BufferGeometry, material: Material, group: Group) => void;
	/**
	 * The default {@link up} direction for objects, also used as the default position for {@link DirectionalLight | DirectionalLight},
	 * {@link HemisphereLight | HemisphereLight} and {@link THREE.Spotlight | Spotlight} (which creates lights shining from the top down).
	 * @defaultValue `new Vector3( 0, 1, 0)`
	 */
	static DEFAULT_UP: Vector3;
	/**
	 * The default setting for {@link matrixAutoUpdate} for newly created Object3Ds.
	 * @defaultValue `true`
	 */
	static DEFAULT_MATRIX_AUTO_UPDATE: boolean;
	/**
	 * The default setting for {@link matrixWorldAutoUpdate} for newly created Object3Ds.
	 * @defaultValue `true`
	 */
	static DEFAULT_MATRIX_WORLD_AUTO_UPDATE: boolean;
	/**
	 * Applies the matrix transform to the object and updates the object's position, rotation and scale.
	 * @param matrix
	 */
	applyMatrix4(matrix: Matrix4): void;
	/**
	 * Applies the rotation represented by the quaternion to the object.
	 * @param quaternion
	 */
	applyQuaternion(quaternion: Quaternion): this;
	/**
	 * Calls {@link Quaternion.setFromAxisAngle | setFromAxisAngle}({@link axis}, {@link angle}) on the {@link quaternion | .quaternion}.
	 * @param axis A normalized vector in object space.
	 * @param angle Angle in radians. Expects a `Float`
	 */
	setRotationFromAxisAngle(axis: Vector3, angle: number): void;
	/**
	 * Calls {@link Quaternion.setFromEuler | setFromEuler}({@link euler}) on the {@link quaternion | .quaternion}.
	 * @param euler Euler angle specifying rotation amount.
	 */
	setRotationFromEuler(euler: Euler): void;
	/**
	 * Calls {@link Quaternion.setFromRotationMatrix | setFromRotationMatrix}({@link m}) on the {@link quaternion | .quaternion}.
	 * @remarks Note that this assumes that the upper 3x3 of m is a pure rotation matrix (i.e, unscaled).
	 * @param m Rotate the quaternion by the rotation component of the matrix.
	 */
	setRotationFromMatrix(m: Matrix4): void;
	/**
	 * Copy the given {@link Quaternion | Quaternion} into {@link quaternion | .quaternion}.
	 * @param q Normalized Quaternion.
	 */
	setRotationFromQuaternion(q: Quaternion): void;
	/**
	 * Rotate an object along an axis in object space.
	 * @remarks The axis is assumed to be normalized.
	 * @param axis A normalized vector in object space.
	 * @param angle The angle in radians. Expects a `Float`
	 */
	rotateOnAxis(axis: Vector3, angle: number): this;
	/**
	 * Rotate an object along an axis in world space.
	 * @remarks The axis is assumed to be normalized
	 * @remarks Method Assumes no rotated parent.
	 * @param axis A normalized vector in world space.
	 * @param angle The angle in radians. Expects a `Float`
	 */
	rotateOnWorldAxis(axis: Vector3, angle: number): this;
	/**
	 * Rotates the object around _x_ axis in local space.
	 * @param rad The angle to rotate in radians. Expects a `Float`
	 */
	rotateX(angle: number): this;
	/**
	 * Rotates the object around _y_ axis in local space.
	 * @param rad The angle to rotate in radians. Expects a `Float`
	 */
	rotateY(angle: number): this;
	/**
	 * Rotates the object around _z_ axis in local space.
	 * @param rad The angle to rotate in radians. Expects a `Float`
	 */
	rotateZ(angle: number): this;
	/**
	 * Translate an object by distance along an axis in object space
	 * @remarks The axis is assumed to be normalized.
	 * @param axis A normalized vector in object space.
	 * @param distance The distance to translate. Expects a `Float`
	 */
	translateOnAxis(axis: Vector3, distance: number): this;
	/**
	 * Translates object along x axis in object space by {@link distance} units.
	 * @param distance Expects a `Float`
	 */
	translateX(distance: number): this;
	/**
	 * Translates object along _y_ axis in object space by {@link distance} units.
	 * @param distance Expects a `Float`
	 */
	translateY(distance: number): this;
	/**
	 * Translates object along _z_ axis in object space by {@link distance} units.
	 * @param distance Expects a `Float`
	 */
	translateZ(distance: number): this;
	/**
	 * Converts the vector from this object's local space to world space.
	 * @param vector A vector representing a position in this object's local space.
	 */
	localToWorld(vector: Vector3): Vector3;
	/**
	 * Converts the vector from world space to this object's local space.
	 * @param vector A vector representing a position in world space.
	 */
	worldToLocal(vector: Vector3): Vector3;
	/**
	 * Rotates the object to face a point in world space.
	 * @remarks This method does not support objects having non-uniformly-scaled parent(s).
	 * @param vector A vector representing a position in world space to look at.
	 */
	lookAt(vector: Vector3): void;
	/**
	 * Rotates the object to face a point in world space.
	 * @remarks This method does not support objects having non-uniformly-scaled parent(s).
	 * @param x Expects a `Float`
	 * @param y Expects a `Float`
	 * @param z Expects a `Float`
	 */
	lookAt(x: number, y: number, z: number): void;
	/**
	 * Adds another {@link Object3D} as child of this {@link Object3D}.
	 * @remarks An arbitrary number of objects may be added
	 * @remarks Any current parent on an {@link object} passed in here will be removed, since an {@link Object3D} can have at most one parent.
	 * @see {@link attach}
	 * @see {@link Group | Group} for info on manually grouping objects.
	 * @param object
	 */
	add(...object: Object3D[]): this;
	/**
	 * Removes a {@link Object3D} as child of this {@link Object3D}.
	 * @remarks An arbitrary number of objects may be removed.
	 * @see {@link Group | Group} for info on manually grouping objects.
	 * @param object
	 */
	remove(...object: Object3D[]): this;
	/**
	 * Removes this object from its current parent.
	 */
	removeFromParent(): this;
	/**
	 * Removes all child objects.
	 */
	clear(): this;
	/**
	 * Adds a {@link Object3D} as a child of this, while maintaining the object's world transform.
	 * @remarks Note: This method does not support scene graphs having non-uniformly-scaled nodes(s).
	 * @see {@link add}
	 * @param object
	 */
	attach(object: Object3D): this;
	/**
	 * Searches through an object and its children, starting with the object itself, and returns the first with a matching id.
	 * @remarks Note that ids are assigned in chronological order: 1, 2, 3, ..., incrementing by one for each new object.
	 * @see {@link id}
	 * @param id Unique number of the object instance. Expects a `Integer`
	 */
	getObjectById(id: number): Object3D | undefined;
	/**
	 * Searches through an object and its children, starting with the object itself, and returns the first with a matching name.
	 * @remarks Note that for most objects the name is an empty string by default
	 * @remarks You will have to set it manually to make use of this method.
	 * @param name String to match to the children's Object3D.name property.
	 */
	getObjectByName(name: string): Object3D | undefined;
	/**
	 * Searches through an object and its children, starting with the object itself,
	 * and returns the first with a property that matches the value given.
	 *
	 * @param name - the property name to search for.
	 * @param value - value of the given property.
	 */
	getObjectByProperty(name: string, value: any): Object3D | undefined;
	/**
	 * Searches through an object and its children, starting with the object itself,
	 * and returns the first with a property that matches the value given.
	 * @param name The property name to search for.
	 * @param value Value of the given property.
	 */
	getObjectsByProperty(name: string, value: any): Object3D[];
	/**
	 * Returns a vector representing the position of the object in world space.
	 * @param target The result will be copied into this Vector3.
	 */
	getWorldPosition(target: Vector3): Vector3;
	/**
	 * Returns a quaternion representing the rotation of the object in world space.
	 * @param target The result will be copied into this Quaternion.
	 */
	getWorldQuaternion(target: Quaternion): Quaternion;
	/**
	 * Returns a vector of the scaling factors applied to the object for each axis in world space.
	 * @param target The result will be copied into this Vector3.
	 */
	getWorldScale(target: Vector3): Vector3;
	/**
	 * Returns a vector representing the direction of object's positive z-axis in world space.
	 * @param target The result will be copied into this Vector3.
	 */
	getWorldDirection(target: Vector3): Vector3;
	/**
	 * Abstract (empty) method to get intersections between a casted ray and this object
	 * @remarks Subclasses such as {@link Mesh | Mesh}, {@link THREE.Line | Line}, and {@link THREE.Points | Points} implement this method in order to use raycasting.
	 * @see {@link Raycaster | Raycaster}
	 * @param raycaster
	 * @param intersects
	 * @defaultValue `() => {}`
	 */
	raycast(raycaster: Raycaster, intersects: Intersection[]): void;
	/**
	 * Executes the callback on this object and all descendants.
	 * @remarks Note: Modifying the scene graph inside the callback is discouraged.
	 * @param callback A function with as first argument an {@link Object3D} object.
	 */
	traverse(callback: (object: Object3D) => any): void;
	/**
	 * Like traverse, but the callback will only be executed for visible objects
	 * @remarks Descendants of invisible objects are not traversed.
	 * @remarks Note: Modifying the scene graph inside the callback is discouraged.
	 * @param callback A function with as first argument an {@link Object3D} object.
	 */
	traverseVisible(callback: (object: Object3D) => any): void;
	/**
	 * Executes the callback on all ancestors.
	 * @remarks Note: Modifying the scene graph inside the callback is discouraged.
	 * @param callback A function with as first argument an {@link Object3D} object.
	 */
	traverseAncestors(callback: (object: Object3D) => any): void;
	/**
	 * Updates local transform.
	 */
	updateMatrix(): void;
	/**
	 * Updates the global transform of the object.
	 * And will update the object descendants if {@link matrixWorldNeedsUpdate | .matrixWorldNeedsUpdate} is set to true or if the {@link force} parameter is set to `true`.
	 * @param force A boolean that can be used to bypass {@link matrixWorldAutoUpdate | .matrixWorldAutoUpdate}, to recalculate the world matrix of the object and descendants on the current frame.
	 * Useful if you cannot wait for the renderer to update it on the next frame, assuming {@link matrixWorldAutoUpdate | .matrixWorldAutoUpdate} set to `true`.
	 */
	updateMatrixWorld(force?: boolean): void;
	/**
	 * Updates the global transform of the object.
	 * @param updateParents Recursively updates global transform of ancestors.
	 * @param updateChildren Recursively updates global transform of descendants.
	 */
	updateWorldMatrix(updateParents: boolean, updateChildren: boolean): void;
	/**
	 * Convert the object to three.js {@link https://github.com/mrdoob/three.js/wiki/JSON-Object-Scene-format-4 | JSON Object/Scene format}.
	 * @param meta Object containing metadata such as materials, textures or images for the object.
	 */
	toJSON(meta?: {
		geometries: any;
		materials: any;
		textures: any;
		images: any;
	}): any;
	/**
	 * Returns a clone of `this` object and optionally all descendants.
	 * @param recursive If true, descendants of the object are also cloned. Default `true`
	 */
	clone(recursive?: boolean): this;
	/**
	 * Copy the given object into this object
	 * @remarks Note: event listeners and user-defined callbacks ({@link onAfterRender | .onAfterRender} and {@link onBeforeRender | .onBeforeRender}) are not copied.
	 * @param source
	 * @param recursive If true, descendants of the object are also copied. Default `true`
	 */
	copy(source: this, recursive?: boolean): this;
}
declare abstract class Camera extends Object3D {
	/**
	 * @remarks
	 * Note that this class is not intended to be called directly; you probably want a
	 * {@link PerspectiveCamera | PerspectiveCamera} or
	 * {@link OrthographicCamera | OrthographicCamera} instead.
	 */
	constructor();
	/**
	 * Read-only flag to check if a given object is of type {@link Camera}.
	 * @remarks This is a _constant_ value
	 * @defaultValue `true`
	 */
	readonly isCamera: true;
	/**
	 * @override
	 * @defaultValue `Camera`
	 */
	override readonly type: string | "Camera";
	/**
	 * @override
	 * The {@link Layers | layers} that the {@link Camera} is a member of.
	 * @remarks Objects must share at least one layer with the {@link Camera} to be n when the camera's viewpoint is rendered.
	 * @defaultValue `new Layers()`
	 */
	override layers: Layers;
	/**
	 * This is the inverse of matrixWorld.
	 * @remarks MatrixWorld contains the Matrix which has the world transform of the {@link Camera} .
	 * @defaultValue {@link Matrix4 | `new THREE.Matrix4()`}
	 */
	matrixWorldInverse: Matrix4;
	/**
	 * This is the matrix which contains the projection.
	 * @defaultValue {@link Matrix4 | `new THREE.Matrix4()`}
	 */
	projectionMatrix: Matrix4;
	/**
	 * This is the inverse of projectionMatrix.
	 * @defaultValue {@link Matrix4 | `new THREE.Matrix4()`}
	 */
	projectionMatrixInverse: Matrix4;
	/**
	 * Returns a {@link Vector3 | Vector3} representing the world space direction in which the {@link Camera} is looking.
	 * @remarks Note: A {@link Camera} looks down its local, negative z-axis.
	 * @param target The result will be copied into this Vector3.
	 */
	getWorldDirection(target: Vector3): Vector3;
}
declare class Spherical {
	constructor(radius?: number, phi?: number, theta?: number);
	/**
	 * @default 1
	 */
	radius: number;
	/**
	 * @default 0
	 */
	phi: number;
	/**
	 * @default 0
	 */
	theta: number;
	set(radius: number, phi: number, theta: number): this;
	clone(): this;
	copy(other: Spherical): this;
	makeSafe(): this;
	setFromVector3(v: Vector3): this;
	setFromCartesianCoords(x: number, y: number, z: number): this;
}
declare class Cylindrical {
	constructor(radius?: number, theta?: number, y?: number);
	/**
	 * @default 1
	 */
	radius: number;
	/**
	 * @default 0
	 */
	theta: number;
	/**
	 * @default 0
	 */
	y: number;
	clone(): this;
	copy(other: Cylindrical): this;
	set(radius: number, theta: number, y: number): this;
	setFromVector3(vec3: Vector3): this;
	setFromCartesianCoords(x: number, y: number, z: number): this;
}
type Vector3Tuple = [
	number,
	number,
	number
];
declare class Vector3 implements Vector {
	constructor(x?: number, y?: number, z?: number);
	/**
	 * @default 0
	 */
	x: number;
	/**
	 * @default 0
	 */
	y: number;
	/**
	 * @default 0
	 */
	z: number;
	readonly isVector3: true;
	/**
	 * Sets value of this vector.
	 */
	set(x: number, y: number, z: number): this;
	/**
	 * Sets all values of this vector.
	 */
	setScalar(scalar: number): this;
	/**
	 * Sets x value of this vector.
	 */
	setX(x: number): Vector3;
	/**
	 * Sets y value of this vector.
	 */
	setY(y: number): Vector3;
	/**
	 * Sets z value of this vector.
	 */
	setZ(z: number): Vector3;
	setComponent(index: number, value: number): this;
	/**
	 * Sets this vector's {@link x}, {@link y} and {@link z} components from the r, g, and b components of the specified
	 * {@link Color | color}.
	 */
	setFromColor(color: Color): this;
	getComponent(index: number): number;
	/**
	 * Clones this vector.
	 */
	clone(): this;
	/**
	 * Copies value of v to this vector.
	 */
	copy(v: Vector3): this;
	/**
	 * Adds v to this vector.
	 */
	add(v: Vector3): this;
	addScalar(s: number): this;
	addScaledVector(v: Vector3, s: number): this;
	/**
	 * Sets this vector to a + b.
	 */
	addVectors(a: Vector3, b: Vector3): this;
	/**
	 * Subtracts v from this vector.
	 */
	sub(a: Vector3): this;
	subScalar(s: number): this;
	/**
	 * Sets this vector to a - b.
	 */
	subVectors(a: Vector3, b: Vector3): this;
	multiply(v: Vector3): this;
	/**
	 * Multiplies this vector by scalar s.
	 */
	multiplyScalar(s: number): this;
	multiplyVectors(a: Vector3, b: Vector3): this;
	applyEuler(euler: Euler): this;
	applyAxisAngle(axis: Vector3, angle: number): this;
	applyMatrix3(m: Matrix3): this;
	applyNormalMatrix(m: Matrix3): this;
	applyMatrix4(m: Matrix4): this;
	applyQuaternion(q: Quaternion): this;
	project(camera: Camera): this;
	unproject(camera: Camera): this;
	transformDirection(m: Matrix4): this;
	divide(v: Vector3): this;
	/**
	 * Divides this vector by scalar s.
	 * Set vector to ( 0, 0, 0 ) if s == 0.
	 */
	divideScalar(s: number): this;
	min(v: Vector3): this;
	max(v: Vector3): this;
	clamp(min: Vector3, max: Vector3): this;
	clampScalar(min: number, max: number): this;
	clampLength(min: number, max: number): this;
	floor(): this;
	ceil(): this;
	round(): this;
	roundToZero(): this;
	/**
	 * Inverts this vector.
	 */
	negate(): this;
	/**
	 * Computes dot product of this vector and v.
	 */
	dot(v: Vector3): number;
	/**
	 * Computes squared length of this vector.
	 */
	lengthSq(): number;
	/**
	 * Computes length of this vector.
	 */
	length(): number;
	/**
	 * Computes Manhattan length of this vector.
	 * http://en.wikipedia.org/wiki/Taxicab_geometry
	 *
	 * @deprecated Use {@link Vector3#manhattanLength .manhattanLength()} instead.
	 */
	lengthManhattan(): number;
	/**
	 * Computes the Manhattan length of this vector.
	 *
	 * see {@link http://en.wikipedia.org/wiki/Taxicab_geometry|Wikipedia: Taxicab Geometry}
	 */
	manhattanLength(): number;
	/**
	 * Computes the Manhattan length (distance) from this vector to the given vector v
	 *
	 * see {@link http://en.wikipedia.org/wiki/Taxicab_geometry|Wikipedia: Taxicab Geometry}
	 */
	manhattanDistanceTo(v: Vector3): number;
	/**
	 * Normalizes this vector.
	 */
	normalize(): this;
	/**
	 * Normalizes this vector and multiplies it by l.
	 */
	setLength(l: number): this;
	lerp(v: Vector3, alpha: number): this;
	lerpVectors(v1: Vector3, v2: Vector3, alpha: number): this;
	/**
	 * Sets this vector to cross product of itself and v.
	 */
	cross(a: Vector3): this;
	/**
	 * Sets this vector to cross product of a and b.
	 */
	crossVectors(a: Vector3, b: Vector3): this;
	projectOnVector(v: Vector3): this;
	projectOnPlane(planeNormal: Vector3): this;
	reflect(vector: Vector3): this;
	angleTo(v: Vector3): number;
	/**
	 * Computes distance of this vector to v.
	 */
	distanceTo(v: Vector3): number;
	/**
	 * Computes squared distance of this vector to v.
	 */
	distanceToSquared(v: Vector3): number;
	/**
	 * @deprecated Use {@link Vector3#manhattanDistanceTo .manhattanDistanceTo()} instead.
	 */
	distanceToManhattan(v: Vector3): number;
	setFromSpherical(s: Spherical): this;
	setFromSphericalCoords(r: number, phi: number, theta: number): this;
	setFromCylindrical(s: Cylindrical): this;
	setFromCylindricalCoords(radius: number, theta: number, y: number): this;
	setFromMatrixPosition(m: Matrix4): this;
	setFromMatrixScale(m: Matrix4): this;
	setFromMatrixColumn(matrix: Matrix4, index: number): this;
	setFromMatrix3Column(matrix: Matrix3, index: number): this;
	/**
	 * Sets this vector's {@link x}, {@link y} and {@link z} components from the x, y, and z components of the specified {@link Euler Euler Angle}.
	 */
	setFromEuler(e: Euler): this;
	/**
	 * Checks for strict equality of this vector and v.
	 */
	equals(v: Vector3): boolean;
	/**
	 * Sets this vector's x, y and z value from the provided array or array-like.
	 * @param array the source array or array-like.
	 * @param offset (optional) offset into the array. Default is 0.
	 */
	fromArray(array: number[] | ArrayLike<number>, offset?: number): this;
	/**
	 * Returns an array [x, y, z], or copies x, y and z into the provided array.
	 * @param array (optional) array to store the vector to. If this is not provided, a new array will be created.
	 * @param offset (optional) optional offset into the array.
	 * @return The created or provided array.
	 */
	toArray(array?: number[], offset?: number): number[];
	toArray(array?: Vector3Tuple, offset?: 0): Vector3Tuple;
	/**
	 * Copies x, y and z into the provided array-like.
	 * @param array array-like to store the vector to.
	 * @param offset (optional) optional offset into the array-like.
	 * @return The provided array-like.
	 */
	toArray(array: ArrayLike<number>, offset?: number): ArrayLike<number>;
	fromBufferAttribute(attribute: BufferAttribute | InterleavedBufferAttribute, index: number): this;
	/**
	 * Sets this vector's x, y and z from Math.random
	 */
	random(): this;
	randomDirection(): this;
}
declare class Bone extends Object3D {
	/**
	 * Creates a new {@link Bone}.
	 */
	constructor();
	/**
	 * Read-only flag to check if a given object is of type {@link Bone}.
	 * @remarks This is a _constant_ value
	 * @defaultValue `true`
	 */
	readonly isBone: true;
	/**
	 * @override
	 * @defaultValue `Bone`
	 */
	override readonly type: string | "Bone";
}
interface MorphTarget {
	name: string;
	vertices: Vector3[];
}
declare class AnimationClip {
	constructor(name?: string, duration?: number, tracks?: KeyframeTrack[], blendMode?: AnimationBlendMode);
	name: string;
	tracks: KeyframeTrack[];
	/**
	 * @default NormalAnimationBlendMode
	 */
	blendMode: AnimationBlendMode;
	/**
	 * @default -1
	 */
	duration: number;
	uuid: string;
	results: any[];
	resetDuration(): AnimationClip;
	trim(): AnimationClip;
	validate(): boolean;
	optimize(): AnimationClip;
	clone(): this;
	toJSON(clip: AnimationClip): any;
	static CreateFromMorphTargetSequence(name: string, morphTargetSequence: MorphTarget[], fps: number, noLoop: boolean): AnimationClip;
	static findByName(clipArray: AnimationClip[], name: string): AnimationClip;
	static CreateClipsFromMorphTargetSequences(morphTargets: MorphTarget[], fps: number, noLoop: boolean): AnimationClip[];
	static parse(json: any): AnimationClip;
	static parseAnimation(animation: any, bones: Bone[]): AnimationClip;
	static toJSON(clip: AnimationClip): any;
}
declare class AnimationObjectGroup {
	constructor(...args: any[]);
	uuid: string;
	stats: {
		bindingsPerObject: number;
		objects: {
			total: number;
			inUse: number;
		};
	};
	readonly isAnimationObjectGroup: true;
	add(...args: any[]): void;
	remove(...args: any[]): void;
	uncache(...args: any[]): void;
}
declare class AnimationAction {
	constructor(mixer: AnimationMixer, clip: AnimationClip, localRoot?: Object3D, blendMode?: AnimationBlendMode);
	blendMode: AnimationBlendMode;
	/**
	 * @default LoopRepeat
	 */
	loop: AnimationActionLoopStyles;
	/**
	 * @default 0
	 */
	time: number;
	/**
	 * @default 1
	 */
	timeScale: number;
	/**
	 * @default 1
	 */
	weight: number;
	/**
	 * @default Infinity
	 */
	repetitions: number;
	/**
	 * @default false
	 */
	paused: boolean;
	/**
	 * @default true
	 */
	enabled: boolean;
	/**
	 * @default false
	 */
	clampWhenFinished: boolean;
	/**
	 * @default true
	 */
	zeroSlopeAtStart: boolean;
	/**
	 * @default true
	 */
	zeroSlopeAtEnd: boolean;
	play(): AnimationAction;
	stop(): AnimationAction;
	reset(): AnimationAction;
	isRunning(): boolean;
	isScheduled(): boolean;
	startAt(time: number): AnimationAction;
	setLoop(mode: AnimationActionLoopStyles, repetitions: number): AnimationAction;
	setEffectiveWeight(weight: number): AnimationAction;
	getEffectiveWeight(): number;
	fadeIn(duration: number): AnimationAction;
	fadeOut(duration: number): AnimationAction;
	crossFadeFrom(fadeOutAction: AnimationAction, duration: number, warp: boolean): AnimationAction;
	crossFadeTo(fadeInAction: AnimationAction, duration: number, warp: boolean): AnimationAction;
	stopFading(): AnimationAction;
	setEffectiveTimeScale(timeScale: number): AnimationAction;
	getEffectiveTimeScale(): number;
	setDuration(duration: number): AnimationAction;
	syncWith(action: AnimationAction): AnimationAction;
	halt(duration: number): AnimationAction;
	warp(statTimeScale: number, endTimeScale: number, duration: number): AnimationAction;
	stopWarping(): AnimationAction;
	getMixer(): AnimationMixer;
	getClip(): AnimationClip;
	getRoot(): Object3D;
}
declare class AnimationMixer extends EventDispatcher {
	constructor(root: Object3D | AnimationObjectGroup);
	/**
	 * @default 0
	 */
	time: number;
	/**
	 * @default 1.0
	 */
	timeScale: number;
	clipAction(clip: AnimationClip, root?: Object3D | AnimationObjectGroup, blendMode?: AnimationBlendMode): AnimationAction;
	existingAction(clip: AnimationClip, root?: Object3D | AnimationObjectGroup): AnimationAction | null;
	stopAllAction(): AnimationMixer;
	update(deltaTime: number): AnimationMixer;
	setTime(timeInSeconds: number): AnimationMixer;
	getRoot(): Object3D | AnimationObjectGroup;
	uncacheClip(clip: AnimationClip): void;
	uncacheRoot(root: Object3D | AnimationObjectGroup): void;
	uncacheAction(clip: AnimationClip, root?: Object3D | AnimationObjectGroup): void;
}
declare class OrthographicCamera extends Camera {
	/**
	 * Creates a new {@link OrthographicCamera}.
	 * @remarks Together these define the camera's {@link https://en.wikipedia.org/wiki/Viewing_frustum | viewing frustum}.
	 * @param left Camera frustum left plane. Default `-1`.
	 * @param right Camera frustum right plane. Default `1`.
	 * @param top Camera frustum top plane. Default `1`.
	 * @param bottom Camera frustum bottom plane. Default `-1`.
	 * @param near Camera frustum near plane. Default `0.1`.
	 * @param far Camera frustum far plane. Default `2000`.
	 */
	constructor(left?: number, right?: number, top?: number, bottom?: number, near?: number, far?: number);
	/**
	 * Read-only flag to check if a given object is of type {@link OrthographicCamera}.
	 * @remarks This is a _constant_ value
	 * @defaultValue `true`
	 */
	readonly isOrthographicCamera: true;
	/**
	 * @override
	 * @defaultValue `OrthographicCamera`
	 */
	override readonly type: string | "OrthographicCamera";
	/**
	 * Gets or sets the zoom factor of the camera.
	 * @defaultValue `1`
	 */
	zoom: number;
	/**
	 * Set by {@link setViewOffset | .setViewOffset()}.
	 * @defaultValue `null`
	 */
	view: null | {
		enabled: boolean;
		fullWidth: number;
		fullHeight: number;
		offsetX: number;
		offsetY: number;
		width: number;
		height: number;
	};
	/**
	 * Camera frustum left plane.
	 * @remarks Expects a `Float`
	 * @defaultValue `-1`
	 */
	left: number;
	/**
	 * Camera frustum right plane.
	 * @remarks Expects a `Float`
	 * @defaultValue `1`
	 */
	right: number;
	/**
	 * Camera frustum top plane.
	 * @remarks Expects a `Float`
	 * @defaultValue `1`
	 */
	top: number;
	/**
	 * Camera frustum bottom plane.
	 * @remarks Expects a `Float`.
	 * @defaultValue `-1`
	 */
	bottom: number;
	/**
	 * Camera frustum near plane.`.
	 * @remarks The valid range is between `0` and the current value of the {@link far | .far} plane.
	 * @remarks Note that, unlike for the {@link PerspectiveCamera | PerspectiveCamera}, `0` is a valid value for an {@link THREE.OrthographicCamera | OrthographicCamera's} near plane.
	 * @remarks Expects a `Float`
	 * @defaultValue `0.1`
	 */
	near: number;
	/**
	 * Camera frustum far plane.
	 * @remarks Must be greater than the current value of {@link near | .near} plane.
	 * @remarks Expects a `Float`
	 * @defaultValue `2000`
	 */
	far: number;
	/**
	 * Updates the camera projection matrix
	 * @remarks Must be called after any change of parameters.
	 */
	updateProjectionMatrix(): void;
	/**
	 * Sets an offset in a larger {@link https://en.wikipedia.org/wiki/Viewing_frustum | viewing frustum}
	 * @remarks
	 * This is useful for multi-window or multi-monitor/multi-machine setups
	 * For an example on how to use it see {@link PerspectiveCamera.setViewOffset | PerspectiveCamera}.
	 * @see {@link PerspectiveCamera.setViewOffset | PerspectiveCamera}.
	 * @param fullWidth Full width of multiview setup Expects a `Float`.
	 * @param fullHeight Full height of multiview setup Expects a `Float`.
	 * @param x Horizontal offset of subcamera Expects a `Float`.
	 * @param y Vertical offset of subcamera Expects a `Float`.
	 * @param width Width of subcamera Expects a `Float`.
	 * @param height Height of subcamera Expects a `Float`.
	 */
	setViewOffset(fullWidth: number, fullHeight: number, offsetX: number, offsetY: number, width: number, height: number): void;
	/**
	 * Removes any offset set by the {@link setViewOffset | .setViewOffset} method.
	 */
	clearViewOffset(): void;
}
declare class CubeTexture extends Texture {
	/**
	 * This creates a new {@link CubeTexture | CubeTexture} object.
	 * @param images
	 * @param mapping See {@link CubeTexture.mapping | .mapping}. Default {@link CubeReflectionMapping}
	 * @param wrapS See {@link Texture.wrapS | .wrapS}. Default {@link ClampToEdgeWrapping}
	 * @param wrapT See {@link Texture.wrapT | .wrapT}. Default {@link ClampToEdgeWrapping}
	 * @param magFilter See {@link Texture.magFilter | .magFilter}. Default {@link LinearFilter}
	 * @param minFilter  See {@link Texture.minFilter | .minFilter}. Default {@link LinearMipmapLinearFilter}
	 * @param format See {@link Texture.format | .format}. Default {@link RGBAFormat}
	 * @param type See {@link Texture.type | .type}. Default {@link UnsignedByteType}
	 * @param anisotropy See {@link Texture.anisotropy | .anisotropy}. Default {@link Texture.DEFAULT_ANISOTROPY}
	 * @param colorSpace See {@link Texture.colorSpace | .colorSpace}. Default {@link NoColorSpace}
	 */
	constructor(images?: any[], // HTMLImageElement or HTMLCanvasElement
	mapping?: CubeTextureMapping, wrapS?: Wrapping, wrapT?: Wrapping, magFilter?: MagnificationTextureFilter, minFilter?: MinificationTextureFilter, format?: PixelFormat, type?: TextureDataType, anisotropy?: number, colorSpace?: ColorSpace);
	/**
	 * Read-only flag to check if a given object is of type {@link CubeTexture}.
	 * @remarks This is a _constant_ value
	 * @defaultValue `true`
	 */
	readonly isCubeTexture: true;
	/**
	 * An image object, typically created using the {@link CubeTextureLoader.load | CubeTextureLoader.load()} method.
	 * @see {@link Texture.image}
	 */
	get image(): any;
	set image(data: any);
	/**
	 * An image object, typically created using the {@link CubeTextureLoader.load | CubeTextureLoader.load()} method.
	 * @see {@link Texture.image}
	 */
	get images(): any;
	set images(data: any);
	/**
	 * @inheritDoc
	 * @defaultValue {@link CubeReflectionMapping}
	 */
	mapping: CubeTextureMapping;
	/**
	 * @inheritDoc
	 * @defaultValue `false`
	 */
	flipY: boolean;
}
declare class WebGLCubeRenderTarget extends WebGLRenderTarget {
	constructor(size?: number, options?: WebGLRenderTargetOptions);
	texture: CubeTexture;
	fromEquirectangularTexture(renderer: WebGLRenderer, texture: Texture): this;
	clear(renderer: WebGLRenderer, color: boolean, depth: boolean, stencil: boolean): void;
}
declare class CubeCamera extends Object3D {
	/**
	 * Constructs a {@link CubeCamera} that contains 6 {@link PerspectiveCamera | PerspectiveCameras} that render to a {@link WebGLCubeRenderTarget | WebGLCubeRenderTarget}.
	 * @param near The near clipping distance.
	 * @param far The far clipping distance.
	 * @param renderTarget The destination cube render target.
	 */
	constructor(near: number, far: number, renderTarget: WebGLCubeRenderTarget);
	/**
	 * @override
	 * @defaultValue `CubeCamera`
	 */
	override readonly type: string | "CubeCamera";
	/**
	 * The destination cube render target.
	 */
	renderTarget: WebGLCubeRenderTarget;
	/**
	 * Call this to update the {@link CubeCamera.renderTarget | renderTarget}.
	 * @param renderer The current WebGL renderer
	 * @param scene The current scene
	 */
	update(renderer: WebGLRenderer, scene: Scene): void;
}
declare class Uniform<T = any> {
	/**
	 * Create a new instance of {@link Uniform | Uniform}
	 * @param value An object containing the value to set up the uniform. It's type must be one of the Uniform Types described above.
	 */
	constructor(value: T);
	/**
	 * Current value of the uniform.
	 */
	value: T;
	/**
	 * Returns a clone of this uniform.
	 * @remarks
	 * If the uniform's {@link value} property is an {@link Object | Object} with a `clone()` method, this is used,
	 * otherwise the value is copied by assignment Array values are **shared** between cloned {@link UniformUniform | Uniform}s.
	 */
	clone(): Uniform<T>;
}
declare abstract class Curve<T extends Vector> {
	protected constructor();
	/**
	 * A Read-only _string_ to check if `this` object type.
	 * @remarks Sub-classes will update this value.
	 * @defaultValue `Curve`
	 */
	readonly type: string | "Curve";
	/**
	 * This value determines the amount of divisions when calculating the cumulative segment lengths of a {@link Curve}
	 * via {@link .getLengths}.
	 * To ensure precision when using methods like {@link .getSpacedPoints}, it is recommended to increase {@link .arcLengthDivisions} if the {@link Curve} is very large.
	 * @defaultValue `200`
	 * @remarks Expects a `Integer`
	 */
	arcLengthDivisions: number;
	/**
	 * Returns a vector for a given position on the curve.
	 * @param t A position on the curve. Must be in the range `[ 0, 1 ]`. Expects a `Float`
	 * @param optionalTarget If specified, the result will be copied into this Vector, otherwise a new Vector will be created. Default `new T`.
	 */
	getPoint(t: number, optionalTarget?: T): T;
	/**
	 * Returns a vector for a given position on the {@link Curve} according to the arc length.
	 * @param u A position on the {@link Curve} according to the arc length. Must be in the range `[ 0, 1 ]`. Expects a `Float`
	 * @param optionalTarget If specified, the result will be copied into this Vector, otherwise a new Vector will be created. Default `new T`.
	 */
	getPointAt(u: number, optionalTarget?: T): T;
	/**
	 * Returns a set of divisions `+1` points using {@link .getPoint | getPoint(t)}.
	 * @param divisions Number of pieces to divide the {@link Curve} into. Expects a `Integer`. Default `5`
	 */
	getPoints(divisions?: number): T[];
	/**
	 * Returns a set of divisions `+1` equi-spaced points using {@link .getPointAt | getPointAt(u)}.
	 * @param divisions Number of pieces to divide the {@link Curve} into. Expects a `Integer`. Default `5`
	 */
	getSpacedPoints(divisions?: number): T[];
	/**
	 * Get total {@link Curve} arc length.
	 */
	getLength(): number;
	/**
	 * Get list of cumulative segment lengths.
	 * @param divisions Expects a `Integer`
	 */
	getLengths(divisions?: number): number[];
	/**
	 * Update the cumlative segment distance cache
	 * @remarks
	 * The method must be called every time {@link Curve} parameters are changed
	 * If an updated {@link Curve} is part of a composed {@link Curve} like {@link CurvePath | CurvePath},
	 * {@link .updateArcLengths}() must be called on the composed curve, too.
	 */
	updateArcLengths(): void;
	/**
	 * Given u in the range `[ 0, 1 ]`,
	 * @remarks
	 * `u` and `t` can then be used to give you points which are equidistant from the ends of the curve, using {@link .getPoint}.
	 * @param u Expects a `Float`
	 * @param distance Expects a `Float`
	 * @returns `t` also in the range `[ 0, 1 ]`. Expects a `Float`.
	 */
	getUtoTmapping(u: number, distance: number): number;
	/**
	 * Returns a unit vector tangent at t
	 * @remarks
	 * If the derived {@link Curve} does not implement its tangent derivation, two points a small delta apart will be used to find its gradient which seems to give a reasonable approximation.
	 * @param t A position on the curve. Must be in the range `[ 0, 1 ]`. Expects a `Float`
	 * @param optionalTarget If specified, the result will be copied into this Vector, otherwise a new Vector will be created.
	 */
	getTangent(t: number, optionalTarget?: T): T;
	/**
	 * Returns tangent at a point which is equidistant to the ends of the {@link Curve} from the point given in {@link .getTangent}.
	 * @param u A position on the {@link Curve} according to the arc length. Must be in the range `[ 0, 1 ]`. Expects a `Float`
	 * @param optionalTarget If specified, the result will be copied into this Vector, otherwise a new Vector will be created.
	 */
	getTangentAt(u: number, optionalTarget?: T): T;
	/**
	 * Generates the Frenet Frames
	 * @remarks
	 * Requires a {@link Curve} definition in 3D space
	 * Used in geometries like {@link TubeGeometry | TubeGeometry} or {@link THREE.ExtrudeGeometry | ExtrudeGeometry}.
	 * @param segments Expects a `Integer`
	 * @param closed
	 */
	computeFrenetFrames(segments: number, closed?: boolean): {
		tangents: Vector3[];
		normals: Vector3[];
		binormals: Vector3[];
	};
	/**
	 * Creates a clone of this instance.
	 */
	clone(): this;
	/**
	 * Copies another {@link Curve} object to this instance.
	 * @param source
	 */
	copy(source: Curve<T>): this;
	/**
	 * Returns a JSON object representation of this instance.
	 */
	toJSON(): {};
	/**
	 * Copies the data from the given JSON object to this instance.
	 * @param json
	 */
	fromJSON(json: {}): this;
}
type CurveType = "centripetal" | "chordal" | "catmullrom";
declare class CatmullRomCurve3 extends Curve<Vector3> {
	/**
	 * This constructor creates a new {@link CatmullRomCurve3}.
	 * @param points An array of {@link Vector3 | Vector3} points
	 * @param closed Whether the curve is closed. Default `false`
	 * @param curveType Type of the curve. Default `centripetal`
	 * @param tension Tension of the curve. Expects a `Float`. Default `0.5`
	 */
	constructor(points?: Vector3[], closed?: boolean, curveType?: CurveType, tension?: number);
	/**
	 * Read-only flag to check if a given object is of type {@link CatmullRomCurve3}.
	 * @remarks This is a _constant_ value
	 * @defaultValue `true`
	 */
	readonly isCatmullRomCurve3 = true;
	/**
	 * A Read-only _string_ to check if `this` object type.
	 * @remarks Sub-classes will update this value.
	 * @defaultValue `CatmullRomCurve3`
	 */
	override readonly type: string | "CatmullRomCurve3";
	/**
	 * The curve will loop back onto itself when this is true.
	 * @defaultValue `false`
	 */
	closed: boolean;
	/**
	 * The array of {@link Vector3 | Vector3} points that define the curve.
	 * @remarks It needs at least two entries.
	 * @defaultValue `[]`
	 */
	points: Vector3[];
	/**
	 * Possible values are `centripetal`, `chordal` and `catmullrom`.
	 * @defaultValue `centripetal`
	 */
	curveType: CurveType;
	/**
	 * When {@link .curveType} is `catmullrom`, defines catmullrom's tension.
	 * @remarks Expects a `Float`
	 */
	tension: number;
}
declare class Line<TGeometry extends BufferGeometry = BufferGeometry, TMaterial extends Material | Material[] = Material | Material[]> extends Object3D {
	/**
	 * Create a new instance of {@link Line}
	 * @param geometry Vertices representing the {@link Line} segment(s). Default {@link BufferGeometry | `new THREE.BufferGeometry()`}.
	 * @param material Material for the line. Default {@link LineBasicMaterial | `new THREE.LineBasicMaterial()`}.
	 */
	constructor(geometry?: TGeometry, material?: TMaterial);
	/**
	 * Read-only flag to check if a given object is of type {@link Line}.
	 * @remarks This is a _constant_ value
	 * @defaultValue `true`
	 */
	readonly isLine: true;
	/**
	 * @override
	 * @defaultValue `Line`
	 */
	override readonly type: string | "Line";
	/**
	 * Vertices representing the {@link Line} segment(s).
	 */
	geometry: TGeometry;
	/**
	 * Material for the line.
	 */
	material: TMaterial;
	/**
	 * An array of weights typically from `0-1` that specify how much of the morph is applied.
	 * @defaultValue `undefined`, but reset to a blank array by {@link updateMorphTargets | .updateMorphTargets()}.
	 */
	morphTargetInfluences?: number[] | undefined;
	/**
	 * A dictionary of morphTargets based on the `morphTarget.name` property.
	 * @defaultValue `undefined`, but reset to a blank array by {@link updateMorphTargets | .updateMorphTargets()}.
	 */
	morphTargetDictionary?: {
		[key: string]: number;
	} | undefined;
	/**
	 * Computes an array of distance values which are necessary for {@link LineDashedMaterial | LineDashedMaterial}
	 * @remarks
	 * For each vertex in the geometry, the method calculates the cumulative length from the current point to the very beginning of the line.
	 */
	computeLineDistances(): this;
	/**
	 * Updates the morphTargets to have no influence on the object
	 * @remarks
	 * Resets the {@link morphTargetInfluences | .morphTargetInfluences} and {@link morphTargetDictionary | .morphTargetDictionary} properties.
	 */
	updateMorphTargets(): void;
}
declare class LineSegments<TGeometry extends BufferGeometry = BufferGeometry, TMaterial extends Material | Material[] = Material | Material[]> extends Line<TGeometry, TMaterial> {
	/**
	 * Create a new instance of {@link LineSegments}
	 * @param geometry Pair(s) of vertices representing each line segment(s). Default {@link BufferGeometry | `new THREE.BufferGeometry()`}.
	 * @param material Material for the line. Default {@link LineBasicMaterial | `new THREE.LineBasicMaterial()`}.
	 */
	constructor(geometry?: TGeometry, material?: TMaterial);
	/**
	 * Read-only flag to check if a given object is of type {@link LineSegments}.
	 * @remarks This is a _constant_ value
	 * @defaultValue `true`
	 */
	readonly isLineSegments: true;
	/**
	 * A Read-only _string_ to check if `this` object type.
	 * @remarks Sub-classes will update this value.
	 * @override
	 * @defaultValue `LineSegments`
	 */
	override readonly type: string | "LineSegments";
}
declare class PointLightShadow extends LightShadow<PerspectiveCamera> {
	/**
	 * Read-only flag to check if a given object is of type {@link PointLightShadow}.
	 * @remarks This is a _constant_ value
	 * @defaultValue `true`
	 */
	readonly isPointLightShadow = true;
	/**
	 * Update the matrices for the camera and shadow, used internally by the renderer.
	 * @param light The light for which the shadow is being rendered.
	 */
	override updateMatrices(light: Light, viewportIndex?: number): void;
}
declare class PointLight extends Light<PointLightShadow> {
	/**
	 * Creates a new PointLight.
	 * @param color Hexadecimal color of the light. Default is 0xffffff (white). Expects a `Integer`
	 * @param intensity Numeric value of the light's strength/intensity. Expects a `Float`. Default `1`
	 * @param distance Maximum range of the light. Default is 0 (no limit).
	 * @param decay The amount the light dims along the distance of the light. Expects a `Float`. Default `2`
	 */
	constructor(color?: ColorRepresentation, intensity?: number, distance?: number, decay?: number);
	/**
	 * @default 'PointLight'
	 */
	type: string;
	/**
	 * The light's intensity.
	 *
	 * When **{@link WebGLRenderer.physicallyCorrectLights | physically correct} mode** — intensity is the luminous intensity of the light measured in candela (cd).
	 * @remarks Changing the intensity will also change the light's power.
	 * @remarks Expects a `Float`
	 * @defaultValue `1`
	 */
	intensity: number;
	/**
	 * When **Default mode** — When distance is zero, light does not attenuate. When distance is non-zero,
	 * light will attenuate linearly from maximum intensity at the light's position down to zero at this distance from the light.
	 *
	 * When **{@link WebGLRenderer.physicallyCorrectLights | Physically correct} rendering mode** — When distance is zero,
	 * light will attenuate according to inverse-square law to infinite distance.
	 * When distance is non-zero, light will attenuate according to inverse-square law until near the distance cutoff,
	 * where it will then attenuate quickly and smoothly to 0. Inherently, cutoffs are not physically correct.
	 *
	 * @defaultValue `0.0`
	 * @remarks Expects a `Float`
	 */
	distance: number;
	/**
	 * If set to `true` light will cast dynamic shadows.
	 * **Warning**: This is expensive and requires tweaking to get shadows looking right.
	 * @see {@link PointLightShadow | PointLightShadow} for details.
	 * @defaultValue `false`
	 */
	castShadow: boolean;
	/**
	 * The amount the light dims along the distance of the light.
	 * In **{@link WebGLRenderer.physicallyCorrectLights | physically correct} rendering mode** — the default value **should not** be changed.
	 * @remarks Expects a `Float`
	 * @defaultValue `2`
	 */
	decay: number;
	/**
	 * A {@link PointLightShadow | PointLightShadow} used to calculate shadows for this light.
	 * The lightShadow's {@link LightShadow.camera | camera} is set to
	 * a {@link PerspectiveCamera | PerspectiveCamera} with {@link PerspectiveCamera.fov | fov} of 90,
	 * {@link PerspectiveCamera.aspect | aspect} of 1,
	 * {@link PerspectiveCamera.near | near} clipping plane at 0.5
	 * and {@link PerspectiveCamera.far | far} clipping plane at 500.
	 * @defaultValue new PointLightShadow()
	 */
	shadow: PointLightShadow;
	/**
	 * The light's power.
	 * When **{@link WebGLRenderer.physicallyCorrectLights | physically correct} rendering mode** — power is the luminous power of the light measured in lumens (lm).
	 * @remarks Changing the power will also change the light's intensity.
	 * @remarks Expects a `Float`
	 */
	power: number;
}
declare class HemisphereLight extends Light<undefined> {
	/**
	 * Creates a new {@link HemisphereLight}.
	 * @param skyColor Hexadecimal color of the sky. Expects a `Integer`. Default `0xffffff` _(white)_.
	 * @param groundColor Hexadecimal color of the ground. Expects a `Integer`. Default `0xffffff` _(white)_.
	 * @param intensity Numeric value of the light's strength/intensity. Expects a `Float`. Default `1`.
	 */
	constructor(skyColor?: ColorRepresentation, groundColor?: ColorRepresentation, intensity?: number);
	/**
	 * Read-only flag to check if a given object is of type {@link HemisphereLight}.
	 * @remarks This is a _constant_ value
	 * @defaultValue `true`
	 */
	readonly isHemisphereLight: true;
	/**
	 * A Read-only _string_ to check if `this` object type.
	 * @remarks Sub-classes will update this value.
	 * @defaultValue `HemisphereLight`
	 */
	override readonly type: string | "HemisphereLight";
	/**
	 * This is set equal to {@link Object3D.DEFAULT_UP}, so that the light shines from the top down.
	 * @defaultValue {@link Object3D.DEFAULT_UP} _(0, 1, 0)_
	 */
	override readonly position: Vector3;
	/**
	 * The light's sky color, as passed in the constructor.
	 * @defaultValue `new Color()` set to white _(0xffffff)_.
	 */
	override color: Color;
	/**
	 * The light's ground color, as passed in the constructor.
	 * @defaultValue `new Color()` set to white _(0xffffff)_.
	 */
	groundColor: Color;
}
/**
 * parameters is an object with one or more properties defining the material's appearance.
 */
interface MeshBasicMaterialParameters extends MaterialParameters {
	color?: ColorRepresentation | undefined;
	opacity?: number | undefined;
	map?: Texture | null | undefined;
	lightMap?: Texture | null;
	lightMapIntensity?: number | undefined;
	aoMap?: Texture | null | undefined;
	aoMapIntensity?: number | undefined;
	specularMap?: Texture | null | undefined;
	alphaMap?: Texture | null | undefined;
	fog?: boolean | undefined;
	envMap?: Texture | null | undefined;
	combine?: Combine | undefined;
	reflectivity?: number | undefined;
	refractionRatio?: number | undefined;
	wireframe?: boolean | undefined;
	wireframeLinewidth?: number | undefined;
	wireframeLinecap?: string | undefined;
	wireframeLinejoin?: string | undefined;
}
declare class MeshBasicMaterial extends Material {
	constructor(parameters?: MeshBasicMaterialParameters);
	/**
	 * @default 'MeshBasicMaterial'
	 */
	type: string;
	/**
	 * @default new Color( 0xffffff )
	 */
	color: Color;
	/**
	 * @default null
	 */
	map: Texture | null;
	/**
	 * @default null
	 */
	lightMap: Texture | null;
	/**
	 * @default 1
	 */
	lightMapIntensity: number;
	/**
	 * @default null
	 */
	aoMap: Texture | null;
	/**
	 * @default 1
	 */
	aoMapIntensity: number;
	/**
	 * @default null
	 */
	specularMap: Texture | null;
	/**
	 * @default null
	 */
	alphaMap: Texture | null;
	/**
	 * @default null
	 */
	envMap: Texture | null;
	/**
	 * @default MultiplyOperation
	 */
	combine: Combine;
	/**
	 * @default 1
	 */
	reflectivity: number;
	/**
	 * @default 0.98
	 */
	refractionRatio: number;
	/**
	 * @default false
	 */
	wireframe: boolean;
	/**
	 * @default 1
	 */
	wireframeLinewidth: number;
	/**
	 * @default 'round'
	 */
	wireframeLinecap: string;
	/**
	 * @default 'round'
	 */
	wireframeLinejoin: string;
	/**
	 * Whether the material is affected by fog. Default is true.
	 * @default fog
	 */
	fog: boolean;
	setValues(parameters: MeshBasicMaterialParameters): void;
}
declare class DirectionalLightShadow extends LightShadow<OrthographicCamera> {
	/**
	 * Create a new instance of {@link DirectionalLightShadow}
	 */
	constructor();
	/**
	 * Read-only flag to check if a given object is of type {@link DirectionalLightShadow}.
	 * @remarks This is a _constant_ value
	 * @defaultValue `true`
	 */
	readonly isDirectionalLightShadow: true;
	/**
	 * The light's view of the world.
	 * @remarks This is used to generate a depth map of the scene; objects behind other objects from the light's perspective will be in shadow.
	 * @defaultValue is an {@link OrthographicCamera | OrthographicCamera} with
	 * {@link OrthographicCamera.left | left} and {@link OrthographicCamera.bottom | bottom} set to -5,
	 * {@link OrthographicCamera.right | right} and {@link OrthographicCamera.top | top} set to 5,
	 * the {@link OrthographicCamera.near | near} clipping plane at 0.5 and
	 * the {@link OrthographicCamera.far | far} clipping plane at 500.
	 */
	camera: OrthographicCamera;
}
declare class DirectionalLight extends Light<DirectionalLightShadow> {
	/**
	 * Creates a new {@link DirectionalLight}.
	 * @param color Hexadecimal color of the light. Default `0xffffff` _(white)_.
	 * @param intensity Numeric value of the light's strength/intensity. Expects a `Float`. Default `1`
	 */
	constructor(color?: ColorRepresentation, intensity?: number);
	/**
	 * Read-only flag to check if a given object is of type {@link DirectionalLight}.
	 * @remarks This is a _constant_ value
	 * @defaultValue `true`
	 */
	readonly isDirectionalLight: true;
	/**
	 * A Read-only _string_ to check if `this` object type.
	 * @remarks Sub-classes will update this value.
	 * @defaultValue `DirectionalLight`
	 */
	override readonly type: string | "DirectionalLight";
	/**
	 * Whether the object gets rendered into shadow map.
	 * @remarks
	 * If set to `true` light will cast dynamic shadows.
	 * **Warning**: This is expensive and requires tweaking to get shadows looking right.
	 * @see {@link DirectionalLightShadow | DirectionalLightShadow} for details.
	 * @defaultValue `false`
	 */
	override castShadow: boolean;
	/**
	 * This is set equal to {@link Object3D.DEFAULT_UP}, so that the light shines from the top down.
	 * @defaultValue {@link Object3D.DEFAULT_UP} _(0, 1, 0)_
	 */
	override position: Vector3;
	/**
	 * A {@link DirectionalLightShadow | DirectionalLightShadow} used to calculate shadows for this light.
	 * @defaultValue `new DirectionalLightShadow()`
	 */
	shadow: DirectionalLightShadow;
	/**
	 * The {@link DirectionalLight} points from its {@link DirectionalLight.position | position} to target.position.
	 * @remarks **Note**: For the target's position to be changed to anything other than the default,
	 * it must be added to the {@link Scene | scene} using
	 * ```typescript
	 * Scene.add( light.target );
	 * ```
	 * This is so that the target's {@link Object3D.matrixWorld | matrixWorld} gets automatically updated each frame.
	 *
	 * It is also possible to set the target to be another object in the scene (anything with a {@link Object3D.position | position} property),
	 * like so:
	 * ```typescript
	 * const targetObject = new Object3D();
	 * scene.add(targetObject);
	 * light.target = targetObject;
	 * ```
	 * The {@link DirectionalLight} will now track the target object.
	 * @defaultValue `new Object3D()` at _(0, 0, 0)_
	 */
	target: Object3D;
	/**
	 * Frees the GPU-related resources allocated by this instance
	 * @remarks
	 * Call this method whenever this instance is no longer used in your app.
	 */
	dispose(): void;
}
declare class Mesh<TGeometry extends BufferGeometry = BufferGeometry, TMaterial extends Material | Material[] = Material | Material[]> extends Object3D {
	/**
	 * Create a new instance of {@link Mesh}
	 * @param geometry An instance of {@link BufferGeometry | BufferGeometry}. Default {@link THREE.BufferGeometry | `new THREE.BufferGeometry()`}.
	 * @param material A single or an array of {@link Material | Material}. Default {@link THREE.MeshBasicMaterial | `new THREE.MeshBasicMaterial()`}.
	 */
	constructor(geometry?: TGeometry, material?: TMaterial);
	/**
	 * Read-only flag to check if a given object is of type {@link Mesh}.
	 * @remarks This is a _constant_ value
	 * @defaultValue `true`
	 */
	readonly isMesh: true;
	/**
	 * @override
	 * @defaultValue `Mesh`
	 */
	override readonly type: string | "Mesh";
	/**
	 * An instance of {@link BufferGeometry | BufferGeometry} (or derived classes), defining the object's structure.
	 * @defaultValue {@link BufferGeometry | `new THREE.BufferGeometry()`}.
	 */
	geometry: TGeometry;
	/**
	 * An instance of material derived from the {@link Material | Material} base class or an array of materials, defining the object's appearance.
	 * @defaultValue {@link MeshBasicMaterial | `new THREE.MeshBasicMaterial()`}.
	 */
	material: TMaterial;
	/**
	 * An array of weights typically from `0-1` that specify how much of the morph is applied.
	 * @defaultValue `undefined`, _but reset to a blank array by {@link updateMorphTargets | .updateMorphTargets()}._
	 */
	morphTargetInfluences?: number[] | undefined;
	/**
	 * A dictionary of morphTargets based on the `morphTarget.name` property.
	 * @defaultValue `undefined`, _but rebuilt by {@link updateMorphTargets | .updateMorphTargets()}._
	 *
	 */
	morphTargetDictionary?: {
		[key: string]: number;
	} | undefined;
	/**
	 * Updates the morphTargets to have no influence on the object
	 * @remarks Resets the {@link morphTargetInfluences} and {@link morphTargetDictionary} properties.
	 */
	updateMorphTargets(): void;
	/**
	 * Get the local-space position of the vertex at the given index,
	 * taking into account the current animation state of both morph targets and skinning.
	 * @param index Expects a `Integer`
	 * @param target
	 */
	getVertexPosition(index: number, target: Vector3): Vector3;
}
declare class SpotLightShadow extends LightShadow<PerspectiveCamera> {
	/**
	 * Read-only flag to check if a given object is of type {@link SpotLightShadow}.
	 * @remarks This is a _constant_ value
	 * @defaultValue `true`
	 */
	readonly isSpotLightShadow: true;
	/**
	 * The light's view of the world.
	 * @remarks This is used to generate a depth map of the scene; objects behind other objects from the light's perspective will be in shadow.
	 * @remarks
	 * The {@link PerspectiveCamera.fov | fov} will track the {@link THREE.SpotLight.angle | angle} property
	 * of the owning {@link SpotLight | SpotLight} via the {@link SpotLightShadow.update | update} method.
	 * Similarly, the {@link PerspectiveCamera.aspect | aspect} property will track the aspect of the {@link LightShadow.mapSize | mapSize}.
	 * If the {@link SpotLight.distance | distance} property of the light is set, the {@link PerspectiveCamera.far | far} clipping plane will track that, otherwise it defaults to `500`.
	 * @defaultValue is a {@link PerspectiveCamera | PerspectiveCamera} with {@link THREE.PerspectiveCamera.near | near} clipping plane at `0.5`.
	 */
	camera: PerspectiveCamera;
	/**
	 * Used to focus the shadow camera.
	 * @remarks The camera's field of view is set as a percentage of the spotlight's field-of-view. Range is `[0, 1]`. 0`.
	 * @defaultValue `1`
	 */
	focus: number;
}
declare class SpotLight extends Light<SpotLightShadow> {
	/**
	 * Creates a new SpotLight.
	 * @param color Hexadecimal color of the light. Default `0xffffff` _(white)_.
	 * @param intensity Numeric value of the light's strength/intensity. Expects a `Float`. Default `1`.
	 * @param distance Maximum range of the light. Default is 0 (no limit). Expects a `Float`.
	 * @param angle Maximum angle of light dispersion from its direction whose upper bound is Math.PI/2.
	 * @param penumbra Percent of the {@link SpotLight} cone that is attenuated due to penumbra. Takes values between zero and 1. Expects a `Float`. Default `0`.
	 * @param decay The amount the light dims along the distance of the light. Expects a `Float`. Default `2`.
	 */
	constructor(color?: ColorRepresentation, intensity?: number, distance?: number, angle?: number, penumbra?: number, decay?: number);
	/**
	 * Read-only flag to check if a given object is of type {@link SpotLight}.
	 * @remarks This is a _constant_ value
	 * @defaultValue `true`
	 */
	readonly isSpotLight: true;
	/**
	 * A Read-only _string_ to check if `this` object type.
	 * @remarks Sub-classes will update this value.
	 * @defaultValue `SpotLight`
	 */
	override readonly type: string | "SpotLight";
	/**
	 * This is set equal to {@link Object3D.DEFAULT_UP | Object3D.DEFAULT_UP} (0, 1, 0), so that the light shines from the top down.
	 * @defaultValue `{@link Object3D.DEFAULT_UP}`
	 */
	position: Vector3;
	/**
	 * The {@link SpotLight} points from its {@link SpotLight.position | position} to target.position.
	 * @remarks
	 * **Note**: For the target's position to be changed to anything other than the default,
	 * it must be added to the {@link Scene | scene} using
	 *
	 * ```typescript
	 * scene.add( light.target );
	 * ```
	 *
	 * This is so that the target's {@link Object3D.matrixWorld | matrixWorld} gets automatically updated each frame.
	 * It is also possible to set the target to be another object in the scene (anything with a {@link Object3D.position | position} property), like so:
	 * ```typescript
	 * const targetObject = new Object3D();
	 * scene.add(targetObject);
	 * light.target = targetObject;
	 * ```
	 * The {@link SpotLight} will now track the target object.
	 * @defaultValue `new Object3D()` _The default position of the target is *(0, 0, 0)*._
	 */
	target: Object3D;
	/**
	 * If set to `true` light will cast dynamic shadows.
	 * @remarks  **Warning**: This is expensive and requires tweaking to get shadows looking right. the {@link SpotLightShadow | SpotLightShadow} for details.
	 * @defaultValue `false`
	 */
	override castShadow: boolean;
	/**
	 * The light's intensity.
	 * @remarks Changing the intensity will also change the light's power.
	 * When **{@link WebGLRenderer.physicallyCorrectLights | Physically correct} rendering mode** — intensity is the luminous intensity of the light measured in candela (cd).
	 * @remarks Expects a `Float`
	 * @defaultValue `1`
	 */
	intensity: number;
	/**
	 * When **Default mode** — When distance is zero, light does not attenuate. When distance is non-zero,
	 * light will attenuate linearly from maximum intensity at the light's position down to zero at this distance from the light.
	 *
	 * When **{@link WebGLRenderer.physicallyCorrectLights | Physically correct} rendering mode** — When distance is zero,
	 * light will attenuate according to inverse-square law to infinite distance.
	 * When distance is non-zero, light will attenuate according to inverse-square law until near the distance cutoff,
	 * where it will then attenuate quickly and smoothly to `0`. Inherently, cutoffs are not physically correct.
	 * @remarks Expects a `Float`
	 * @defaultValue `0.0`
	 */
	distance: number;
	/**
	 * Maximum extent of the spotlight, in radians, from its direction.
	 * @remarks Should be no more than `Math.PI/2`.
	 * @remarks Expects a `Float`
	 * @defaultValue `Math.PI / 3`
	 */
	angle: number;
	/**
	 * The amount the light dims along the distance of the light.
	 * In **{@link WebGLRenderer.physicallyCorrectLights | physically correct} rendering mode** — the default value should not be changed.
	 * @remarks Expects a `Float`
	 * @defaultValue `2`
	 */
	decay: number;
	/**
	 * A {@link SpotLightShadow | SpotLightShadow} used to calculate shadows for this light.
	 * @defaultValue `new SpotLightShadow()`
	 */
	shadow: SpotLightShadow;
	/**
	 * The light's power.
	 * @remarks Changing the power will also change the light's intensity.
	 * In **{@link WebGLRenderer.physicallyCorrectLights | physically correct} rendering mode** —  power is the luminous power of the light measured in lumens (lm).
	 * @remarks Expects a `Float`
	 */
	power: number;
	/**
	 * Percent of the {@link SpotLight} cone that is attenuated due to penumbra.
	 * @remarks Takes values between zero and 1.
	 * @remarks Expects a `Float`
	 * @defaultValue `0.0`
	 */
	penumbra: number;
	/**
	 * A {@link Texture | Texture} used to modulate the color of the light.
	 * The spot light color is mixed with the _RGB_ value of this texture, with a ratio corresponding to its alpha value.
	 * The cookie-like masking effect is reproduced using pixel values (0, 0, 0, 1-cookie_value).
	 * @remarks **Warning**: {@link SpotLight.map} is disabled if {@link SpotLight.castShadow} is `false`.
	 */
	map: Texture | null;
}
declare class RectAreaLight extends Light<undefined> {
	/**
	 * Creates a new {@link RectAreaLight}.
	 * @param color Hexadecimal color of the light. Default `0xffffff` _(white)_.
	 * @param intensity The light's intensity, or brightness. Expects a `Float`. Default `1`
	 * @param width Width of the light. Expects a `Float`. Default `10`
	 * @param height Height of the light. Expects a `Float`. Default `10`
	 */
	constructor(color?: ColorRepresentation, intensity?: number, width?: number, height?: number);
	/**
	 * Read-only flag to check if a given object is of type {@link RectAreaLight}.
	 * @remarks This is a _constant_ value
	 * @defaultValue `true`
	 */
	readonly isRectAreaLight: true;
	/**
	 * A Read-only _string_ to check if `this` object type.
	 * @remarks Sub-classes will update this value.
	 * @defaultValue `RectAreaLight`
	 */
	override readonly type: string | "RectAreaLight";
	/**
	 * The width of the light.
	 * @remarks Expects a `Float`
	 * @defaultValue `10`
	 */
	width: number;
	/**
	 * The height of the light.
	 * @remarks Expects a `Float`
	 * @defaultValue `10`
	 */
	height: number;
	/**
	 * The light's intensity.
	 * @remarks Changing the intensity will also change the light's power.
	 * In **{@link WebGLRenderer.physicallyCorrectLights | physically correct} rendering mode** — intensity is the luminance (brightness) of the light measured in nits (cd/m^2).
	 * @remarks Expects a `Float`
	 * @defaultValue `1`
	 */
	intensity: number;
	/**
	 * The light's power.
	 * @remarks Changing the power will also change the light's intensity.
	 * In **{@link WebGLRenderer.physicallyCorrectLights | physically correct} rendering mode** — power is the luminous power of the light measured in lumens (lm).
	 * @remarks Expects a `Float`
	 */
	power: number;
}
declare class AmbientLight extends Light<undefined> {
	/**
	 * Creates a new {@link AmbientLight}.
	 * @param color Numeric value of the RGB component of the color. Default `0xffffff`
	 * @param intensity Numeric value of the light's strength/intensity. Expects a `Float`. Default `1`
	 */
	constructor(color?: ColorRepresentation, intensity?: number);
	/**
	 * Read-only flag to check if a given object is of type {@link AmbientLight}.
	 * @remarks This is a _constant_ value
	 * @defaultValue `true`
	 */
	readonly isAmbientLight: true;
	/**
	 * A Read-only _string_ to check if `this` object type.
	 * @remarks Sub-classes will update this value.
	 * @defaultValue `AmbientLight`
	 */
	override readonly type: string | "AmbientLight";
}
declare class SphericalHarmonics3 {
	constructor();
	/**
	 * @default [new Vector3(), new THREE.Vector3(), new THREE.Vector3(), new THREE.Vector3(),
	 * new Vector3(), new THREE.Vector3(), new THREE.Vector3(), new THREE.Vector3(), new THREE.Vector3()]
	 */
	coefficients: Vector3[];
	readonly isSphericalHarmonics3: true;
	set(coefficients: Vector3[]): SphericalHarmonics3;
	zero(): SphericalHarmonics3;
	add(sh: SphericalHarmonics3): SphericalHarmonics3;
	addScaledSH(sh: SphericalHarmonics3, s: number): SphericalHarmonics3;
	scale(s: number): SphericalHarmonics3;
	lerp(sh: SphericalHarmonics3, alpha: number): SphericalHarmonics3;
	equals(sh: SphericalHarmonics3): boolean;
	copy(sh: SphericalHarmonics3): SphericalHarmonics3;
	clone(): this;
	/**
	 * Sets the values of this spherical harmonics from the provided array or array-like.
	 * @param array the source array or array-like.
	 * @param offset (optional) offset into the array. Default is 0.
	 */
	fromArray(array: number[] | ArrayLike<number>, offset?: number): this;
	/**
	 * Returns an array with the values of this spherical harmonics, or copies them into the provided array.
	 * @param array (optional) array to store the spherical harmonics to. If this is not provided, a new array will be created.
	 * @param offset (optional) optional offset into the array.
	 * @return The created or provided array.
	 */
	toArray(array?: number[], offset?: number): number[];
	/**
	 * Returns an array with the values of this spherical harmonics, or copies them into the provided array-like.
	 * @param array array-like to store the spherical harmonics to.
	 * @param offset (optional) optional offset into the array-like.
	 * @return The provided array-like.
	 */
	toArray(array: ArrayLike<number>, offset?: number): ArrayLike<number>;
	getAt(normal: Vector3, target: Vector3): Vector3;
	getIrradianceAt(normal: Vector3, target: Vector3): Vector3;
	static getBasisAt(normal: Vector3, shBasis: number[]): void;
}
declare class LightProbe extends Light {
	/**
	 * Creates a new LightProbe.
	 * @param sh An instance of {@link SphericalHarmonics3 | SphericalHarmonics3}. Default `new THREE.SphericalHarmonics3()``.
	 * @param intensity Numeric value of the light probe's intensity. Expects a `Float`. Default `1`.
	 */
	constructor(sh?: SphericalHarmonics3, intensity?: number);
	/**
	 * Read-only flag to check if a given object is of type {@link DirectionalLight}.
	 * @remarks This is a _constant_ value
	 * @defaultValue `true`
	 */
	readonly isLightProbe: true;
	/**
	 * A light probe uses spherical harmonics to encode lighting information.
	 * @defaultValue `new SphericalHarmonics3()`
	 */
	sh: SphericalHarmonics3;
	/** @internal */
	fromJSON(json: {}): LightProbe;
}
declare class Loader {
	constructor(manager?: LoadingManager);
	/**
	 * @default 'anonymous'
	 */
	crossOrigin: string;
	/**
	 * @default false
	 */
	withCredentials: boolean;
	/**
	 * @default ''
	 */
	path: string;
	/**
	 * @default ''
	 */
	resourcePath: string;
	manager: LoadingManager;
	/**
	 * @default {}
	 */
	requestHeader: {
		[header: string]: string;
	};
	/*
	load(): void;
	loadAsync(): Promise<unknown>;
	parse(): void;
	*/
	setCrossOrigin(crossOrigin: string): this;
	setWithCredentials(value: boolean): this;
	setPath(path: string): this;
	setResourcePath(resourcePath: string): this;
	setRequestHeader(requestHeader: {
		[header: string]: string;
	}): this;
}
declare class LoadingManager {
	constructor(onLoad?: () => void, onProgress?: (url: string, loaded: number, total: number) => void, onError?: (url: string) => void);
	/**
	 * Will be called when loading of an item starts.
	 * @param url The url of the item that started loading.
	 * @param loaded The number of items already loaded so far.
	 * @param total The total amount of items to be loaded.
	 */
	onStart?: ((url: string, loaded: number, total: number) => void) | undefined;
	/**
	 * Will be called when all items finish loading.
	 * The default is a function with empty body.
	 */
	onLoad: () => void;
	/**
	 * Will be called for each loaded item.
	 * The default is a function with empty body.
	 * @param url The url of the item just loaded.
	 * @param loaded The number of items already loaded so far.
	 * @param total The total amount of items to be loaded.
	 */
	onProgress: (url: string, loaded: number, total: number) => void;
	/**
	 * Will be called when item loading fails.
	 * The default is a function with empty body.
	 * @param url The url of the item that errored.
	 */
	onError: (url: string) => void;
	/**
	 * If provided, the callback will be passed each resource URL before a request is sent.
	 * The callback may return the original URL, or a new URL to override loading behavior.
	 * This behavior can be used to load assets from .ZIP files, drag-and-drop APIs, and Data URIs.
	 * @param callback URL modifier callback. Called with url argument, and must return resolvedURL.
	 */
	setURLModifier(callback?: (url: string) => string): this;
	/**
	 * Given a URL, uses the URL modifier callback (if any) and returns a resolved URL.
	 * If no URL modifier is set, returns the original URL.
	 * @param url the url to load
	 */
	resolveURL(url: string): string;
	itemStart(url: string): void;
	itemEnd(url: string): void;
	itemError(url: string): void;
	// handlers
	addHandler(regex: RegExp, loader: Loader): this;
	removeHandler(regex: RegExp): this;
	getHandler(file: string): Loader | null;
}
declare class CompressedTexture extends Texture {
	/**
	 * This creates a new {@link CompressedTexture | CompressedTexture} object.
	 * @param mipmaps The mipmaps array should contain objects with data, width and height.
	 * The mipmaps should be of the correct {@link format} and {@link type}. See {@link mipmaps}.
	 * @param width The width of the biggest mipmap.
	 * @param height The height of the biggest mipmap.
	 * @param format The format used in the mipmaps. See {@link CompressedPixelFormat}.
	 * @param type See {@link Texture.type | .type}. Default {@link UnsignedByteType}
	 * @param mapping See {@link Texture.mapping | .mapping}. Default {@link Texture.DEFAULT_MAPPING}
	 * @param wrapS See {@link Texture.wrapS | .wrapS}. Default {@link ClampToEdgeWrapping}
	 * @param wrapT See {@link Texture.wrapT | .wrapT}. Default {@link ClampToEdgeWrapping}
	 * @param magFilter See {@link Texture.magFilter | .magFilter}. Default {@link LinearFilter}
	 * @param minFilter  See {@link Texture.minFilter | .minFilter}. Default {@link LinearMipmapLinearFilter}
	 * @param anisotropy See {@link Texture.anisotropy | .anisotropy}. Default {@link Texture.DEFAULT_ANISOTROPY}
	 * @param colorSpace See {@link Texture.colorSpace .colorSpace}. Default {@link NoColorSpace}
	 */
	constructor(mipmaps: ImageData[], width: number, height: number, format: CompressedPixelFormat, type?: TextureDataType, mapping?: Mapping, wrapS?: Wrapping, wrapT?: Wrapping, magFilter?: MagnificationTextureFilter, minFilter?: MinificationTextureFilter, anisotropy?: number, colorSpace?: ColorSpace);
	/**
	 * Read-only flag to check if a given object is of type {@link CompressedTexture}.
	 * @remarks This is a _constant_ value
	 * @defaultValue `true`
	 */
	readonly isCompressedTexture: true;
	/**
	 * Overridden with a object containing width and height.
	 * @override
	 */
	get image(): {
		width: number;
		height: number;
	};
	set image(value: {
		width: number;
		height: number;
	});
	/**
	 *  The mipmaps array should contain objects with data, width and height. The mipmaps should be of the correct {@link format} and {@link type}.
	 */
	mipmaps: ImageData[];
	/**
	 * @override
	 * @see {@link https://threejs.org/docs/index.html#api/en/constants/Textures | Texture Constants}
	 * @see {@link CompressedPixelFormat}
	 */
	format: CompressedPixelFormat;
	/**
	 * @override No flipping for cube textures. (also flipping doesn't work for compressed textures)
	 * @defaultValue `false`
	 */
	flipY: boolean;
	/**
	 * @override Can't generate mipmaps for compressed textures. mips must be embedded in DDS files
	 * @defaultValue `false`
	 */
	generateMipmaps: boolean;
}
declare class CompressedTextureLoader extends Loader {
	constructor(manager?: LoadingManager);
	load(url: string, onLoad: (texture: CompressedTexture) => void, onProgress?: (event: ProgressEvent) => void, onError?: (event: ErrorEvent) => void): CompressedTexture;
	loadAsync(url: string, onProgress?: (event: ProgressEvent) => void): Promise<CompressedTexture>;
}
declare class DataTexture extends Texture {
	/**
	 * @param data {@link https://developer.mozilla.org/en-US/docs/Web/API/ArrayBufferView | ArrayBufferView} of the texture. Default `null`.
	 * @param width Width of the texture. Default `1`.
	 * @param height Height of the texture. Default `1`.
	 * @param format See {@link Texture.format | .format}. Default {@link RGBAFormat}
	 * @param type See {@link Texture.type | .type}. Default {@link UnsignedByteType}
	 * @param mapping See {@link Texture.mapping | .mapping}. Default {@link Texture.DEFAULT_MAPPING}
	 * @param wrapS See {@link Texture.wrapS | .wrapS}. Default {@link ClampToEdgeWrapping}
	 * @param wrapT See {@link Texture.wrapT | .wrapT}. Default {@link ClampToEdgeWrapping}
	 * @param magFilter See {@link Texture.magFilter | .magFilter}. Default {@link NearestFilter}
	 * @param minFilter  See {@link Texture.minFilter | .minFilter}. Default {@link NearestFilter}
	 * @param anisotropy See {@link Texture.anisotropy | .anisotropy}. Default {@link Texture.DEFAULT_ANISOTROPY}
	 * @param colorSpace See {@link Texture.colorSpace | .colorSpace}. Default {@link NoColorSpace}
	 */
	constructor(data?: BufferSource | null, width?: number, height?: number, format?: PixelFormat, type?: TextureDataType, mapping?: Mapping, wrapS?: Wrapping, wrapT?: Wrapping, magFilter?: MagnificationTextureFilter, minFilter?: MinificationTextureFilter, anisotropy?: number, colorSpace?: ColorSpace);
	/**
	 * Read-only flag to check if a given object is of type {@link DataTexture}.
	 * @remarks This is a _constant_ value
	 * @defaultValue `true`
	 */
	readonly isDataTexture: true;
	/**
	 * Overridden with a record type holding data, width and height and depth.
	 * @override
	 */
	get image(): TextureImageData;
	set image(value: TextureImageData);
	/**
	 * @override
	 * @defaultValue {@link NearestFilter}
	 */
	magFilter: MagnificationTextureFilter;
	/**
	 * @override
	 * @defaultValue {@link NearestFilter}
	 */
	minFilter: MinificationTextureFilter;
	/**
	 * @override
	 * @defaultValue `false`
	 */
	flipY: boolean;
	/**
	 * @override
	 * @defaultValue `false`
	 */
	generateMipmaps: boolean;
	/**
	 * @override
	 * @defaultValue `1`
	 */
	unpackAlignment: number;
}
declare class TextureLoader extends Loader {
	constructor(manager?: LoadingManager);
	load(url: string, onLoad?: (texture: Texture) => void, onProgress?: (event: ProgressEvent) => void, onError?: (event: ErrorEvent) => void): Texture;
	loadAsync(url: string, onProgress?: (event: ProgressEvent) => void): Promise<Texture>;
}
declare class ImageBitmapLoader extends Loader {
	constructor(manager?: LoadingManager);
	/**
	 * @default { premultiplyAlpha: 'none' }
	 */
	options: undefined | object;
	readonly isImageBitmapLoader: true;
	setOptions(options: object): ImageBitmapLoader;
	load(url: string, onLoad?: (response: ImageBitmap) => void, onProgress?: (request: ProgressEvent) => void, onError?: (event: ErrorEvent) => void): any;
	loadAsync(url: string, onProgress?: (event: ProgressEvent) => void): Promise<ImageBitmap>;
}
declare class FileLoader extends Loader {
	constructor(manager?: LoadingManager);
	mimeType: undefined | MimeType;
	responseType: undefined | string;
	load(url: string, onLoad?: (response: string | ArrayBuffer) => void, onProgress?: (request: ProgressEvent) => void, onError?: (event: ErrorEvent) => void): any;
	loadAsync(url: string, onProgress?: (event: ProgressEvent) => void): Promise<string | ArrayBuffer>;
	setMimeType(mimeType: MimeType): FileLoader;
	setResponseType(responseType: string): FileLoader;
}
interface ShadowMaterialParameters extends MaterialParameters {
	color?: ColorRepresentation | undefined;
	fog?: boolean | undefined;
}
declare class ShadowMaterial extends Material {
	constructor(parameters?: ShadowMaterialParameters);
	/**
	 * @default 'ShadowMaterial'
	 */
	type: string;
	/**
	 * @default new Color( 0x000000 )
	 */
	color: Color;
	/**
	 * @default true
	 */
	transparent: boolean;
	/**
	 * Whether the material is affected by fog. Default is true.
	 * @default fog
	 */
	fog: boolean;
}
interface SpriteMaterialParameters extends MaterialParameters {
	color?: ColorRepresentation | undefined;
	map?: Texture | null | undefined;
	alphaMap?: Texture | null | undefined;
	rotation?: number | undefined;
	sizeAttenuation?: boolean | undefined;
	fog?: boolean | undefined;
}
declare class SpriteMaterial extends Material {
	constructor(parameters?: SpriteMaterialParameters);
	/**
	 * @default 'SpriteMaterial'
	 */
	type: string;
	/**
	 * @default new Color( 0xffffff )
	 */
	color: Color;
	/**
	 * @default null
	 */
	map: Texture | null;
	/**
	 * @default null
	 */
	alphaMap: Texture | null;
	/**
	 * @default 0
	 */
	rotation: number;
	/**
	 * @default true
	 */
	sizeAttenuation: boolean;
	/**
	 * @default true
	 */
	transparent: boolean;
	/**
	 * Whether the material is affected by fog. Default is true.
	 * @default fog
	 */
	fog: boolean;
	readonly isSpriteMaterial: true;
	setValues(parameters: SpriteMaterialParameters): void;
	copy(source: SpriteMaterial): this;
}
interface ShaderMaterialParameters extends MaterialParameters {
	uniforms?: {
		[uniform: string]: IUniform;
	} | undefined;
	vertexShader?: string | undefined;
	fragmentShader?: string | undefined;
	linewidth?: number | undefined;
	wireframe?: boolean | undefined;
	wireframeLinewidth?: number | undefined;
	lights?: boolean | undefined;
	clipping?: boolean | undefined;
	fog?: boolean | undefined;
	extensions?: {
		derivatives?: boolean | undefined;
		fragDepth?: boolean | undefined;
		drawBuffers?: boolean | undefined;
		shaderTextureLOD?: boolean | undefined;
	} | undefined;
	glslVersion?: GLSLVersion | undefined;
}
declare class ShaderMaterial extends Material {
	constructor(parameters?: ShaderMaterialParameters);
	/**
	 * @default 'ShaderMaterial'
	 */
	type: string;
	/**
	 * @default {}
	 */
	defines: {
		[key: string]: any;
	};
	/**
	 * @default {}
	 */
	uniforms: {
		[uniform: string]: IUniform;
	};
	vertexShader: string;
	fragmentShader: string;
	/**
	 * @default 1
	 */
	linewidth: number;
	/**
	 * @default false
	 */
	wireframe: boolean;
	/**
	 * @default 1
	 */
	wireframeLinewidth: number;
	/**
	 * @default false
	 */
	fog: boolean;
	/**
	 * @default false
	 */
	lights: boolean;
	/**
	 * @default false
	 */
	clipping: boolean;
	/**
	 * @deprecated Use {@link ShaderMaterial#extensions.derivatives extensions.derivatives} instead.
	 */
	derivatives: any;
	/**
	 * @default { derivatives: false, fragDepth: false, drawBuffers: false, shaderTextureLOD: false }
	 */
	extensions: {
		derivatives: boolean;
		fragDepth: boolean;
		drawBuffers: boolean;
		shaderTextureLOD: boolean;
	};
	/**
	 * @default { 'color': [ 1, 1, 1 ], 'uv': [ 0, 0 ], 'uv1': [ 0, 0 ] }
	 */
	defaultAttributeValues: any;
	/**
	 * @default undefined
	 */
	index0AttributeName: string | undefined;
	/**
	 * @default false
	 */
	uniformsNeedUpdate: boolean;
	/**
	 * @default null
	 */
	glslVersion: GLSLVersion | null;
	isShaderMaterial: boolean;
	setValues(parameters: ShaderMaterialParameters): void;
	toJSON(meta: any): any;
}
declare class RawShaderMaterial extends ShaderMaterial {
	constructor(parameters?: ShaderMaterialParameters);
}
interface PointsMaterialParameters extends MaterialParameters {
	color?: ColorRepresentation | undefined;
	map?: Texture | null | undefined;
	alphaMap?: Texture | null | undefined;
	size?: number | undefined;
	sizeAttenuation?: boolean | undefined;
	fog?: boolean | undefined;
}
declare class PointsMaterial extends Material {
	constructor(parameters?: PointsMaterialParameters);
	/**
	 * @default 'PointsMaterial'
	 */
	type: string;
	/**
	 * @default new Color( 0xffffff )
	 */
	color: Color;
	/**
	 * @default null
	 */
	map: Texture | null;
	/**
	 * @default null
	 */
	alphaMap: Texture | null;
	/**
	 * @default 1
	 */
	size: number;
	/**
	 * @default true
	 */
	sizeAttenuation: boolean;
	/**
	 * Whether the material is affected by fog. Default is true.
	 * @default fog
	 */
	fog: boolean;
	setValues(parameters: PointsMaterialParameters): void;
}
interface MeshStandardMaterialParameters extends MaterialParameters {
	color?: ColorRepresentation | undefined;
	roughness?: number | undefined;
	metalness?: number | undefined;
	map?: Texture | null | undefined;
	lightMap?: Texture | null | undefined;
	lightMapIntensity?: number | undefined;
	aoMap?: Texture | null | undefined;
	aoMapIntensity?: number | undefined;
	emissive?: ColorRepresentation | undefined;
	emissiveIntensity?: number | undefined;
	emissiveMap?: Texture | null | undefined;
	bumpMap?: Texture | null | undefined;
	bumpScale?: number | undefined;
	normalMap?: Texture | null | undefined;
	normalMapType?: NormalMapTypes | undefined;
	normalScale?: Vector2 | undefined;
	displacementMap?: Texture | null | undefined;
	displacementScale?: number | undefined;
	displacementBias?: number | undefined;
	roughnessMap?: Texture | null | undefined;
	metalnessMap?: Texture | null | undefined;
	alphaMap?: Texture | null | undefined;
	envMap?: Texture | null | undefined;
	envMapIntensity?: number | undefined;
	wireframe?: boolean | undefined;
	wireframeLinewidth?: number | undefined;
	fog?: boolean | undefined;
	flatShading?: boolean | undefined;
}
declare class MeshStandardMaterial extends Material {
	constructor(parameters?: MeshStandardMaterialParameters);
	/**
	 * @default 'MeshStandardMaterial'
	 */
	type: string;
	/**
	 * @default { 'STANDARD': '' }
	 */
	defines: {
		[key: string]: any;
	};
	/**
	 * @default new Color( 0xffffff )
	 */
	color: Color;
	/**
	 * @default 1
	 */
	roughness: number;
	/**
	 * @default 0
	 */
	metalness: number;
	/**
	 * @default null
	 */
	map: Texture | null;
	/**
	 * @default null
	 */
	lightMap: Texture | null;
	/**
	 * @default 1
	 */
	lightMapIntensity: number;
	/**
	 * @default null
	 */
	aoMap: Texture | null;
	/**
	 * @default 1
	 */
	aoMapIntensity: number;
	/**
	 * @default new Color( 0x000000 )
	 */
	emissive: Color;
	/**
	 * @default 1
	 */
	emissiveIntensity: number;
	/**
	 * @default null
	 */
	emissiveMap: Texture | null;
	/**
	 * @default null
	 */
	bumpMap: Texture | null;
	/**
	 * @default 1
	 */
	bumpScale: number;
	/**
	 * @default null
	 */
	normalMap: Texture | null;
	/**
	 * @default TangentSpaceNormalMap
	 */
	normalMapType: NormalMapTypes;
	/**
	 * @default new Vector2( 1, 1 )
	 */
	normalScale: Vector2;
	/**
	 * @default null
	 */
	displacementMap: Texture | null;
	/**
	 * @default 1
	 */
	displacementScale: number;
	/**
	 * @default 0
	 */
	displacementBias: number;
	/**
	 * @default null
	 */
	roughnessMap: Texture | null;
	/**
	 * @default null
	 */
	metalnessMap: Texture | null;
	/**
	 * @default null
	 */
	alphaMap: Texture | null;
	/**
	 * @default null
	 */
	envMap: Texture | null;
	/**
	 * @default 1
	 */
	envMapIntensity: number;
	/**
	 * @default false
	 */
	wireframe: boolean;
	/**
	 * @default 1
	 */
	wireframeLinewidth: number;
	/**
	 * @default 'round'
	 */
	wireframeLinecap: string;
	/**
	 * @default 'round'
	 */
	wireframeLinejoin: string;
	/**
	 * Define whether the material is rendered with flat shading. Default is false.
	 * @default false
	 */
	flatShading: boolean;
	/**
	 * Whether the material is affected by fog. Default is true.
	 * @default fog
	 */
	fog: boolean;
	isMeshStandardMaterial: boolean;
	setValues(parameters: MeshStandardMaterialParameters): void;
}
interface MeshPhysicalMaterialParameters extends MeshStandardMaterialParameters {
	clearcoat?: number | undefined;
	clearcoatMap?: Texture | null | undefined;
	clearcoatRoughness?: number | undefined;
	clearcoatRoughnessMap?: Texture | null | undefined;
	clearcoatNormalScale?: Vector2 | undefined;
	clearcoatNormalMap?: Texture | null | undefined;
	reflectivity?: number | undefined;
	ior?: number | undefined;
	sheen?: number | undefined;
	sheenColor?: Color | undefined;
	sheenColorMap?: Texture | null | undefined;
	sheenRoughness?: number | undefined;
	sheenRoughnessMap?: Texture | null | undefined;
	transmission?: number | undefined;
	transmissionMap?: Texture | null | undefined;
	thickness?: number | undefined;
	thicknessMap?: Texture | null | undefined;
	attenuationDistance?: number | undefined;
	attenuationColor?: Color | undefined;
	specularIntensity?: number | undefined;
	specularColor?: Color | undefined;
	specularIntensityMap?: Texture | null | undefined;
	specularColorMap?: Texture | null | undefined;
	iridescenceMap?: Texture | null | undefined;
	iridescenceIOR?: number | undefined;
	iridescence?: number | undefined;
	iridescenceThicknessRange?: [
		number,
		number
	] | undefined;
	iridescenceThicknessMap?: Texture | null | undefined;
}
declare class MeshPhysicalMaterial extends MeshStandardMaterial {
	constructor(parameters?: MeshPhysicalMaterialParameters);
	/**
	 * @default 'MeshPhysicalMaterial'
	 */
	type: string;
	/**
	 * @default { 'STANDARD': '', 'PHYSICAL': '' }
	 */
	defines: {
		[key: string]: any;
	};
	/**
	 * @default 0
	 */
	clearcoat: number;
	/**
	 * @default null
	 */
	clearcoatMap: Texture | null;
	/**
	 * @default 0
	 */
	clearcoatRoughness: number;
	/**
	 * @default null
	 */
	clearcoatRoughnessMap: Texture | null;
	/**
	 * @default new Vector2( 1, 1 )
	 */
	clearcoatNormalScale: Vector2;
	/**
	 * @default null
	 */
	clearcoatNormalMap: Texture | null;
	/**
	 * @default 0.5
	 */
	reflectivity: number;
	/**
	 * @default 1.5
	 */
	ior: number;
	/**
	 * @default 0.0
	 */
	sheen: number;
	/**
	 * @default Color( 0x000000 )
	 */
	sheenColor: Color;
	/**
	 * @default null
	 */
	sheenColorMap: Texture | null;
	/**
	 * @default 1.0
	 */
	sheenRoughness: number;
	/**
	 * @default null
	 */
	sheenRoughnessMap: Texture | null;
	/**
	 * @default 0
	 */
	transmission: number;
	/**
	 * @default null
	 */
	transmissionMap: Texture | null;
	/**
	 * @default 0.01
	 */
	thickness: number;
	/**
	 * @default null
	 */
	thicknessMap: Texture | null;
	/**
	 * @default 0.0
	 */
	attenuationDistance: number;
	/**
	 * @default Color( 1, 1, 1 )
	 */
	attenuationColor: Color;
	/**
	 * @default 1.0
	 */
	specularIntensity: number;
	/**
	 * @default Color(1, 1, 1)
	 */
	specularColor: Color;
	/**
	 * @default null
	 */
	specularIntensityMap: Texture | null;
	/**
	 * @default null
	 */
	specularColorMap: Texture | null;
	/**
	 * @default null
	 */
	iridescenceMap: Texture | null;
	/**
	 * @default 1.3
	 */
	iridescenceIOR: number;
	/**
	 * @default 0
	 */
	iridescence: number;
	/**
	 * @default [100, 400]
	 */
	iridescenceThicknessRange: [
		number,
		number
	];
	/**
	 * @default null
	 */
	iridescenceThicknessMap: Texture | null;
}
interface MeshPhongMaterialParameters extends MaterialParameters {
	/** geometry color in hexadecimal. Default is 0xffffff. */
	color?: ColorRepresentation | undefined;
	specular?: ColorRepresentation | undefined;
	shininess?: number | undefined;
	opacity?: number | undefined;
	map?: Texture | null | undefined;
	lightMap?: Texture | null | undefined;
	lightMapIntensity?: number | undefined;
	aoMap?: Texture | null | undefined;
	aoMapIntensity?: number | undefined;
	emissive?: ColorRepresentation | undefined;
	emissiveIntensity?: number | undefined;
	emissiveMap?: Texture | null | undefined;
	bumpMap?: Texture | null | undefined;
	bumpScale?: number | undefined;
	normalMap?: Texture | null | undefined;
	normalMapType?: NormalMapTypes | undefined;
	normalScale?: Vector2 | undefined;
	displacementMap?: Texture | null | undefined;
	displacementScale?: number | undefined;
	displacementBias?: number | undefined;
	specularMap?: Texture | null | undefined;
	alphaMap?: Texture | null | undefined;
	envMap?: Texture | null | undefined;
	combine?: Combine | undefined;
	reflectivity?: number | undefined;
	refractionRatio?: number | undefined;
	wireframe?: boolean | undefined;
	wireframeLinewidth?: number | undefined;
	wireframeLinecap?: string | undefined;
	wireframeLinejoin?: string | undefined;
	fog?: boolean | undefined;
	flatShading?: boolean | undefined;
}
declare class MeshPhongMaterial extends Material {
	constructor(parameters?: MeshPhongMaterialParameters);
	/**
	 * @default 'MeshNormalMaterial'
	 */
	type: string;
	/**
	 * @default new Color( 0xffffff )
	 */
	color: Color;
	/**
	 * @default new Color( 0x111111 )
	 */
	specular: Color;
	/**
	 * @default 30
	 */
	shininess: number;
	/**
	 * @default null
	 */
	map: Texture | null;
	/**
	 * @default null
	 */
	lightMap: Texture | null;
	/**
	 * @default null
	 */
	lightMapIntensity: number;
	/**
	 * @default null
	 */
	aoMap: Texture | null;
	/**
	 * @default null
	 */
	aoMapIntensity: number;
	/**
	 * @default new Color( 0x000000 )
	 */
	emissive: Color;
	/**
	 * @default 1
	 */
	emissiveIntensity: number;
	/**
	 * @default null
	 */
	emissiveMap: Texture | null;
	/**
	 * @default null
	 */
	bumpMap: Texture | null;
	/**
	 * @default 1
	 */
	bumpScale: number;
	/**
	 * @default null
	 */
	normalMap: Texture | null;
	/**
	 * @default TangentSpaceNormalMap
	 */
	normalMapType: NormalMapTypes;
	/**
	 * @default new Vector2( 1, 1 )
	 */
	normalScale: Vector2;
	/**
	 * @default null
	 */
	displacementMap: Texture | null;
	/**
	 * @default 1
	 */
	displacementScale: number;
	/**
	 * @default 0
	 */
	displacementBias: number;
	/**
	 * @default null
	 */
	specularMap: Texture | null;
	/**
	 * @default null
	 */
	alphaMap: Texture | null;
	/**
	 * @default null
	 */
	envMap: Texture | null;
	/**
	 * @default MultiplyOperation
	 */
	combine: Combine;
	/**
	 * @default 1
	 */
	reflectivity: number;
	/**
	 * @default 0.98
	 */
	refractionRatio: number;
	/**
	 * @default false
	 */
	wireframe: boolean;
	/**
	 * @default 1
	 */
	wireframeLinewidth: number;
	/**
	 * @default 'round'
	 */
	wireframeLinecap: string;
	/**
	 * @default 'round'
	 */
	wireframeLinejoin: string;
	/**
	 * Define whether the material is rendered with flat shading. Default is false.
	 * @default false
	 */
	flatShading: boolean;
	/**
	 * @deprecated Use {@link MeshStandardMaterial MeshStandardMaterial} instead.
	 */
	metal: boolean;
	/**
	 * Whether the material is affected by fog. Default is true.
	 * @default fog
	 */
	fog: boolean;
	setValues(parameters: MeshPhongMaterialParameters): void;
}
interface MeshToonMaterialParameters extends MaterialParameters {
	/** geometry color in hexadecimal. Default is 0xffffff. */
	color?: ColorRepresentation | undefined;
	opacity?: number | undefined;
	gradientMap?: Texture | null | undefined;
	map?: Texture | null | undefined;
	lightMap?: Texture | null | undefined;
	lightMapIntensity?: number | undefined;
	aoMap?: Texture | null | undefined;
	aoMapIntensity?: number | undefined;
	emissive?: ColorRepresentation | undefined;
	emissiveIntensity?: number | undefined;
	emissiveMap?: Texture | null | undefined;
	bumpMap?: Texture | null | undefined;
	bumpScale?: number | undefined;
	normalMap?: Texture | null | undefined;
	normalMapType?: NormalMapTypes | undefined;
	normalScale?: Vector2 | undefined;
	displacementMap?: Texture | null | undefined;
	displacementScale?: number | undefined;
	displacementBias?: number | undefined;
	alphaMap?: Texture | null | undefined;
	wireframe?: boolean | undefined;
	wireframeLinewidth?: number | undefined;
	wireframeLinecap?: string | undefined;
	wireframeLinejoin?: string | undefined;
	fog?: boolean | undefined;
}
declare class MeshToonMaterial extends Material {
	constructor(parameters?: MeshToonMaterialParameters);
	/**
	 * @default 'MeshToonMaterial'
	 */
	type: string;
	/**
	 * @default { 'TOON': '' }
	 */
	defines: {
		[key: string]: any;
	};
	/**
	 * @default new Color( 0xffffff )
	 */
	color: Color;
	/**
	 * @default null
	 */
	gradientMap: Texture | null;
	/**
	 * @default null
	 */
	map: Texture | null;
	/**
	 * @default null
	 */
	lightMap: Texture | null;
	/**
	 * @default 1
	 */
	lightMapIntensity: number;
	/**
	 * @default null
	 */
	aoMap: Texture | null;
	/**
	 * @default 1
	 */
	aoMapIntensity: number;
	/**
	 * @default new Color( 0x000000 )
	 */
	emissive: Color;
	/**
	 * @default 1
	 */
	emissiveIntensity: number;
	/**
	 * @default null
	 */
	emissiveMap: Texture | null;
	/**
	 * @default null
	 */
	bumpMap: Texture | null;
	/**
	 * @default 1
	 */
	bumpScale: number;
	/**
	 * @default null
	 */
	normalMap: Texture | null;
	/**
	 * @default TangentSpaceNormalMap
	 */
	normalMapType: NormalMapTypes;
	/**
	 * @default new Vector2( 1, 1 )
	 */
	normalScale: Vector2;
	/**
	 * @default null
	 */
	displacementMap: Texture | null;
	/**
	 * @default 1
	 */
	displacementScale: number;
	/**
	 * @default 0
	 */
	displacementBias: number;
	/**
	 * @default null
	 */
	alphaMap: Texture | null;
	/**
	 * @default false
	 */
	wireframe: boolean;
	/**
	 * @default 1
	 */
	wireframeLinewidth: number;
	/**
	 * @default 'round'
	 */
	wireframeLinecap: string;
	/**
	 * @default 'round'
	 */
	wireframeLinejoin: string;
	/**
	 * Whether the material is affected by fog. Default is true.
	 * @default fog
	 */
	fog: boolean;
	setValues(parameters: MeshToonMaterialParameters): void;
}
interface MeshNormalMaterialParameters extends MaterialParameters {
	bumpMap?: Texture | null | undefined;
	bumpScale?: number | undefined;
	normalMap?: Texture | null | undefined;
	normalMapType?: NormalMapTypes | undefined;
	normalScale?: Vector2 | undefined;
	displacementMap?: Texture | null | undefined;
	displacementScale?: number | undefined;
	displacementBias?: number | undefined;
	wireframe?: boolean | undefined;
	wireframeLinewidth?: number | undefined;
	flatShading?: boolean | undefined;
}
declare class MeshNormalMaterial extends Material {
	constructor(parameters?: MeshNormalMaterialParameters);
	/**
	 * @default 'MeshNormalMaterial'
	 */
	type: string;
	/**
	 * @default null
	 */
	bumpMap: Texture | null;
	/**
	 * @default 1
	 */
	bumpScale: number;
	/**
	 * @default null
	 */
	normalMap: Texture | null;
	/**
	 * @default TangentSpaceNormalMap
	 */
	normalMapType: NormalMapTypes;
	/**
	 * @default new Vector2( 1, 1 )
	 */
	normalScale: Vector2;
	/**
	 * @default null
	 */
	displacementMap: Texture | null;
	/**
	 * @default 1
	 */
	displacementScale: number;
	/**
	 * @default 0
	 */
	displacementBias: number;
	/**
	 * @default false
	 */
	wireframe: boolean;
	/**
	 * @default 1
	 */
	wireframeLinewidth: number;
	/**
	 * Define whether the material is rendered with flat shading. Default is false.
	 * @default false
	 */
	flatShading: boolean;
	setValues(parameters: MeshNormalMaterialParameters): void;
}
interface MeshLambertMaterialParameters extends MaterialParameters {
	bumpMap?: Texture | undefined;
	bumpScale?: number | undefined;
	color?: ColorRepresentation | undefined;
	displacementMap?: Texture | undefined;
	displacementScale?: number | undefined;
	displacementBias?: number | undefined;
	emissive?: ColorRepresentation | undefined;
	emissiveIntensity?: number | undefined;
	emissiveMap?: Texture | null | undefined;
	flatShading?: boolean | undefined;
	map?: Texture | null | undefined;
	lightMap?: Texture | null | undefined;
	lightMapIntensity?: number | undefined;
	normalMap?: Texture | undefined;
	normalScale?: Vector2 | undefined;
	aoMap?: Texture | null | undefined;
	aoMapIntensity?: number | undefined;
	specularMap?: Texture | null | undefined;
	alphaMap?: Texture | null | undefined;
	envMap?: Texture | null | undefined;
	combine?: Combine | undefined;
	reflectivity?: number | undefined;
	refractionRatio?: number | undefined;
	wireframe?: boolean | undefined;
	wireframeLinewidth?: number | undefined;
	wireframeLinecap?: string | undefined;
	wireframeLinejoin?: string | undefined;
	fog?: boolean | undefined;
}
declare class MeshLambertMaterial extends Material {
	constructor(parameters?: MeshLambertMaterialParameters);
	/**
	 * @default 'MeshLambertMaterial'
	 */
	type: string;
	/**
	 * @default new Color( 0xffffff )
	 */
	color: Color;
	/**
	 * @default null
	 */
	bumpMap: Texture | null;
	/**
	 * @default 1
	 */
	bumpScale: number;
	/**
	 * @default null
	 */
	displacementMap: Texture | null;
	/**
	 * @default 1
	 */
	displacementScale: number;
	/**
	 * @default 0
	 */
	displacementBias: number;
	/**
	 * @default new Color( 0x000000 )
	 */
	emissive: Color;
	/**
	 * @default 1
	 */
	emissiveIntensity: number;
	/**
	 * @default null
	 */
	emissiveMap: Texture | null;
	/**
	 * @default false
	 */
	flatShading: boolean;
	/**
	 * @default null
	 */
	map: Texture | null;
	/**
	 * @default null
	 */
	lightMap: Texture | null;
	/**
	 * @default 1
	 */
	lightMapIntensity: number;
	/**
	 * @default null
	 */
	normalMap: Texture | null;
	normalMapType: NormalMapTypes;
	/**
	 * @default new Vector2( 1, 1 )
	 */
	normalScale: Vector2;
	/**
	 * @default null
	 */
	aoMap: Texture | null;
	/**
	 * @default 1
	 */
	aoMapIntensity: number;
	/**
	 * @default null
	 */
	specularMap: Texture | null;
	/**
	 * @default null
	 */
	alphaMap: Texture | null;
	/**
	 * @default null
	 */
	envMap: Texture | null;
	/**
	 * @default MultiplyOperation
	 */
	combine: Combine;
	/**
	 * @default 1
	 */
	reflectivity: number;
	/**
	 * @default 0.98
	 */
	refractionRatio: number;
	/**
	 * @default false
	 */
	wireframe: boolean;
	/**
	 * @default 1
	 */
	wireframeLinewidth: number;
	/**
	 * @default 'round'
	 */
	wireframeLinecap: string;
	/**
	 * @default 'round'
	 */
	wireframeLinejoin: string;
	/**
	 * Whether the material is affected by fog. Default is true.
	 * @default fog
	 */
	fog: boolean;
	setValues(parameters: MeshLambertMaterialParameters): void;
}
interface MeshDepthMaterialParameters extends MaterialParameters {
	map?: Texture | null | undefined;
	alphaMap?: Texture | null | undefined;
	depthPacking?: DepthPackingStrategies | undefined;
	displacementMap?: Texture | null | undefined;
	displacementScale?: number | undefined;
	displacementBias?: number | undefined;
	wireframe?: boolean | undefined;
	wireframeLinewidth?: number | undefined;
}
declare class MeshDepthMaterial extends Material {
	constructor(parameters?: MeshDepthMaterialParameters);
	/**
	 * @default 'MeshDepthMaterial'
	 */
	type: string;
	/**
	 * @default null
	 */
	map: Texture | null;
	/**
	 * @default null
	 */
	alphaMap: Texture | null;
	/**
	 * @default BasicDepthPacking
	 */
	depthPacking: DepthPackingStrategies;
	/**
	 * @default null
	 */
	displacementMap: Texture | null;
	/**
	 * @default 1
	 */
	displacementScale: number;
	/**
	 * @default 0
	 */
	displacementBias: number;
	/**
	 * @default false
	 */
	wireframe: boolean;
	/**
	 * @default 1
	 */
	wireframeLinewidth: number;
	/**
	 * @default false
	 */
	fog: boolean;
	setValues(parameters: MeshDepthMaterialParameters): void;
}
interface MeshDistanceMaterialParameters extends MaterialParameters {
	map?: Texture | null | undefined;
	alphaMap?: Texture | null | undefined;
	displacementMap?: Texture | null | undefined;
	displacementScale?: number | undefined;
	displacementBias?: number | undefined;
	farDistance?: number | undefined;
	nearDistance?: number | undefined;
	referencePosition?: Vector3 | undefined;
}
declare class MeshDistanceMaterial extends Material {
	constructor(parameters?: MeshDistanceMaterialParameters);
	/**
	 * @default 'MeshDistanceMaterial'
	 */
	type: string;
	/**
	 * @default null
	 */
	map: Texture | null;
	/**
	 * @default null
	 */
	alphaMap: Texture | null;
	/**
	 * @default null
	 */
	displacementMap: Texture | null;
	/**
	 * @default 1
	 */
	displacementScale: number;
	/**
	 * @default 0
	 */
	displacementBias: number;
	/**
	 * @default false
	 */
	fog: boolean;
	setValues(parameters: MeshDistanceMaterialParameters): void;
}
interface MeshMatcapMaterialParameters extends MaterialParameters {
	color?: ColorRepresentation | undefined;
	matcap?: Texture | null | undefined;
	map?: Texture | null | undefined;
	bumpMap?: Texture | null | undefined;
	bumpScale?: number | undefined;
	normalMap?: Texture | null | undefined;
	normalMapType?: NormalMapTypes | undefined;
	normalScale?: Vector2 | undefined;
	displacementMap?: Texture | null | undefined;
	displacementScale?: number | undefined;
	displacementBias?: number | undefined;
	alphaMap?: Texture | null | undefined;
	fog?: boolean | undefined;
	flatShading?: boolean | undefined;
}
declare class MeshMatcapMaterial extends Material {
	constructor(parameters?: MeshMatcapMaterialParameters);
	/**
	 * @default 'MeshMatcapMaterial'
	 */
	type: string;
	/**
	 * @default { 'MATCAP': '' }
	 */
	defines: {
		[key: string]: any;
	};
	/**
	 * @default new Color( 0xffffff )
	 */
	color: Color;
	/**
	 * @default null
	 */
	matcap: Texture | null;
	/**
	 * @default null
	 */
	map: Texture | null;
	/**
	 * @default null
	 */
	bumpMap: Texture | null;
	/**
	 * @default 1
	 */
	bumpScale: number;
	/**
	 * @default null
	 */
	normalMap: Texture | null;
	/**
	 * @default TangentSpaceNormalMap
	 */
	normalMapType: NormalMapTypes;
	/**
	 * @default new Vector2( 1, 1 )
	 */
	normalScale: Vector2;
	/**
	 * @default null
	 */
	displacementMap: Texture | null;
	/**
	 * @default 1
	 */
	displacementScale: number;
	/**
	 * @default 0
	 */
	displacementBias: number;
	/**
	 * @default null
	 */
	alphaMap: Texture | null;
	/**
	 * Define whether the material is rendered with flat shading. Default is false.
	 * @default false
	 */
	flatShading: boolean;
	/**
	 * Whether the material is affected by fog. Default is true.
	 * @default fog
	 */
	fog: boolean;
	setValues(parameters: MeshMatcapMaterialParameters): void;
}
interface LineBasicMaterialParameters extends MaterialParameters {
	color?: ColorRepresentation | undefined;
	fog?: boolean | undefined;
	linewidth?: number | undefined;
	linecap?: string | undefined;
	linejoin?: string | undefined;
}
declare class LineBasicMaterial extends Material {
	constructor(parameters?: LineBasicMaterialParameters);
	/**
	 * @default 'LineBasicMaterial'
	 */
	type: string;
	/**
	 * @default 0xffffff
	 */
	color: Color;
	/**
	 * Whether the material is affected by fog. Default is true.
	 * @default true
	 */
	fog: boolean;
	/**
	 * @default 1
	 */
	linewidth: number;
	/**
	 * @default 'round'
	 */
	linecap: string;
	/**
	 * @default 'round'
	 */
	linejoin: string;
	/**
	 * Sets the color of the lines using data from a {@link Texture}.
	 */
	map: Texture | null;
	setValues(parameters: LineBasicMaterialParameters): void;
}
declare class Sprite extends Object3D {
	/**
	 * Creates a new Sprite.
	 * @param material An instance of {@link SpriteMaterial | SpriteMaterial}. Default {@link THREE.SpriteMaterial | `new SpriteMaterial()`}, _with white color_.
	 */
	constructor(material?: SpriteMaterial);
	/**
	 * Read-only flag to check if a given object is of type {@link Sprite}.
	 * @remarks This is a _constant_ value
	 * @defaultValue `true`
	 */
	readonly isSprite: true;
	/**
	 * @override
	 * @defaultValue `Sprite`
	 */
	override readonly type: string | "Sprite";
	/**
	 * Whether the object gets rendered into shadow map.
	 * No effect in {@link Sprite}.
	 * @ignore
	 * @hidden
	 * @defaultValue `false`
	 */
	override castShadow: false;
	geometry: BufferGeometry;
	/**
	 * An instance of {@link SpriteMaterial | SpriteMaterial}, defining the object's appearance.
	 * @defaultValue {@link SpriteMaterial | `new SpriteMaterial()`}, _with white color_.
	 */
	material: SpriteMaterial;
	/**
	 * The sprite's anchor point, and the point around which the {@link Sprite} rotates.
	 * A value of (0.5, 0.5) corresponds to the midpoint of the sprite.
	 * A value of (0, 0) corresponds to the lower left corner of the sprite.
	 * @defaultValue {@link Vector2 | `new Vector2(0.5, 0.5)`}.
	 */
	center: Vector2;
}
declare class Frustum {
	constructor(p0?: Plane, p1?: Plane, p2?: Plane, p3?: Plane, p4?: Plane, p5?: Plane);
	/**
	 * Array of 6 vectors.
	 */
	planes: Plane[];
	set(p0: Plane, p1: Plane, p2: Plane, p3: Plane, p4: Plane, p5: Plane): Frustum;
	clone(): this;
	copy(frustum: Frustum): this;
	setFromProjectionMatrix(m: Matrix4): this;
	intersectsObject(object: Object3D): boolean;
	intersectsSprite(sprite: Sprite): boolean;
	intersectsSphere(sphere: Sphere): boolean;
	intersectsBox(box: Box3): boolean;
	containsPoint(point: Vector3): boolean;
}
declare function smoothstep(x: number, min: number, max: number): number;
declare function smootherstep(x: number, min: number, max: number): number;
declare function degToRad(degrees: number): number;
// @ts-ignore
declare function radToDeg(radians: number): number;
declare class LOD extends Object3D {
	/**
	 * Creates a new {@link LOD}.
	 */
	constructor();
	/**
	 * Read-only flag to check if a given object is of type {@link LOD}.
	 * @remarks This is a _constant_ value
	 * @defaultValue `true`
	 */
	readonly isLOD: true;
	/**
	 * @override
	 * @defaultValue `LOD`
	 */
	override readonly type: string | "LOD";
	/**
	 * An array of level objects
	 */
	levels: Array<{
		/** The Object3D to display at this level. */
		object: Object3D;
		/** The distance at which to display this level of detail. Expects a `Float`. */
		distance: number;
		/** Threshold used to avoid flickering at LOD boundaries, as a fraction of distance. Expects a `Float`. */
		hysteresis: number;
	}>;
	/**
	 * Whether the {@link LOD} object is updated automatically by the renderer per frame or not.
	 * If set to `false`, you have to call {@link update | .update()} in the render loop by yourself.
	 * @defaultValue `true`
	 */
	autoUpdate: boolean;
	/**
	 * Adds a mesh that will display at a certain distance and greater. Typically the further away the distance, the lower the detail on the mesh.
	 *
	 * @param object The Object3D to display at this level.
	 * @param distance The distance at which to display this level of detail. Expects a `Float`. Default `0.0`.
	 * @param hysteresis Threshold used to avoid flickering at LOD boundaries, as a fraction of distance. Expects a `Float`. Default `0.0`.
	 */
	addLevel(object: Object3D, distance?: number, hysteresis?: number): this;
	/**
	 * Get the currently active {@link LOD} level
	 * @remarks
	 * As index of the levels array.
	 */
	getCurrentLevel(): number;
	/**
	 * Get a reference to the first {@link Object3D | Object3D} (mesh) that is greater than {@link distance}.
	 * @param distance Expects a `Float`
	 */
	getObjectForDistance(distance: number): Object3D | null;
	/**
	 * Set the visibility of each {@link levels | level}'s {@link Object3D | object} based on distance from the {@link THREE.Camera | camera}.
	 * @param camera
	 */
	update(camera: Camera): void;
}
declare class Skeleton {
	/**
	 * Creates a new Skeleton.
	 * @param bones The array of {@link Bone | bones}. Default `[]`.
	 * @param boneInverses An array of {@link Matrix4 | Matrix4s}. Default `[]`.
	 */
	constructor(bones?: Bone[], boneInverses?: Matrix4[]);
	/**
	 * {@link http://en.wikipedia.org/wiki/Universally_unique_identifier | UUID} of this object instance.
	 * @remarks This gets automatically assigned and shouldn't be edited.
	 */
	uuid: string;
	/**
	 * The array of {@link Bone | Bones}.
	 * @remarks Note this is a copy of the original array, not a reference, so you can modify the original array without effecting this one.
	 */
	bones: Bone[];
	/**
	 * An array of {@link Matrix4 | Matrix4s} that represent the inverse of the {@link Matrix4 | matrixWorld} of the individual bones.
	 */
	boneInverses: Matrix4[];
	/**
	 * The array buffer holding the bone data when using a vertex texture.
	 */
	boneMatrices: Float32Array;
	/**
	 * The {@link DataTexture | DataTexture} holding the bone data when using a vertex texture.
	 */
	boneTexture: null | DataTexture;
	/**
	 * The size of the {@link boneTexture | .boneTexture}.
	 * @remarks Expects a `Integer`
	 */
	boneTextureSize: number;
	frame: number;
	init(): void;
	/**
	 * Generates the {@link boneInverses} array if not provided in the constructor.
	 */
	calculateInverses(): void;
	/**
	 * Computes an instance of {@link DataTexture | DataTexture} in order to pass the bone data more efficiently to the shader
	 * @remarks
	 * The texture is assigned to {@link boneTexture}.
	 */
	computeBoneTexture(): this;
	/**
	 * Returns the skeleton to the base pose.
	 */
	pose(): void;
	/**
	 * Updates the {@link boneMatrices} and {@link boneTexture} after changing the bones
	 * @remarks
	 * This is called automatically by the {@link WebGLRenderer | WebGLRenderer} if the {@link Skeleton} is used with a {@link THREE.SkinnedMesh | SkinnedMesh}.
	 */
	update(): void;
	/**
	 * Returns a clone of this {@link Skeleton} object.
	 */
	clone(): Skeleton;
	/**
	 * Searches through the skeleton's bone array and returns the first with a matching name.
	 * @param name String to match to the Bone's {@link Bone.name | .name} property.
	 */
	getBoneByName(name: string): undefined | Bone;
	/**
	 * Frees the GPU-related resources allocated by this instance
	 * @remarks
	 * Call this method whenever this instance is no longer used in your app.
	 */
	dispose(): void;
	toJSON(): unknown;
	fromJSON(json: unknown, bones: Record<string, Bone>): void;
}
declare class SkinnedMesh<TGeometry extends BufferGeometry = BufferGeometry, TMaterial extends Material | Material[] = Material | Material[]> extends Mesh<TGeometry, TMaterial> {
	/**
	 * Create a new instance of {@link SkinnedMesh}
	 * @param geometry An instance of {@link BufferGeometry | BufferGeometry}. Default {@link THREE.BufferGeometry | `new THREE.BufferGeometry()`}.
	 * @param material A single or an array of {@link Material | Material}. Default {@link THREE.MeshBasicMaterial | `new THREE.MeshBasicMaterial()`}.
	 */
	constructor(geometry?: TGeometry, material?: TMaterial, useVertexTexture?: boolean);
	/**
	 * Read-only flag to check if a given object is of type {@link SkinnedMesh}.
	 * @remarks This is a _constant_ value
	 * @defaultValue `true`
	 */
	readonly isSkinnedMesh: true;
	/**
	 * @override
	 * @defaultValue `SkinnedMesh`
	 */
	override readonly type: string | "SkinnedMesh";
	/**
	 * Either `attached` or `detached`.
	 *  - `attached` uses the {@link SkinnedMesh.matrixWorld | SkinnedMesh.matrixWorld} property for the base transform matrix of the bones.
	 *  - `detached` uses the {@link SkinnedMesh.bindMatrix | SkinnedMesh.bindMatrix}.
	 * @defaultValue `attached`.
	 */
	bindMode: "attached" | "detached";
	/**
	 * The base matrix that is used for the bound bone transforms.
	 */
	bindMatrix: Matrix4;
	/**
	 * The base matrix that is used for resetting the bound bone transforms.
	 */
	bindMatrixInverse: Matrix4;
	/**
	 * The bounding box of the SkinnedMesh. Can be calculated with {@link computeBoundingBox | .computeBoundingBox()}.
	 * @default `null`
	 */
	boundingBox: Box3;
	/**
	 * The bounding box of the SkinnedMesh. Can be calculated with {@link computeBoundingSphere | .computeBoundingSphere()}.
	 * @default `null`
	 */
	boundingSphere: Sphere;
	/**
	 * {@link Skeleton | Skeleton} representing the bone hierarchy of the skinned mesh.
	 */
	skeleton: Skeleton;
	/**
	 * Bind a skeleton to the skinned mesh
	 * @remarks
	 * The bindMatrix gets saved to .bindMatrix property and the .bindMatrixInverse gets calculated.
	 * @param skeleton {@link Skeleton | Skeleton} created from a {@link Bone | Bones} tree.
	 * @param bindMatrix {@link Matrix4 | Matrix4} that represents the base transform of the skeleton.
	 */
	bind(skeleton: Skeleton, bindMatrix?: Matrix4): void;
	/**
	 * Computes the bounding box, updating {@link boundingBox | .boundingBox} attribute.
	 * @remarks
	 * Bounding boxes aren't computed by default. They need to be explicitly computed, otherwise they are `null`. If an
	 * instance of SkinnedMesh is animated, this method should be called per frame to compute a correct bounding box.
	 */
	computeBoundingBox(): void;
	/**
	 * Computes the bounding sphere, updating {@link boundingSphere | .boundingSphere} attribute.
	 * @remarks
	 * Bounding spheres aren't computed by default. They need to be explicitly computed, otherwise they are `null`. If
	 * an instance of SkinnedMesh is animated, this method should be called per frame to compute a correct bounding
	 * sphere.
	 */
	computeBoundingSphere(): void;
	/**
	 * This method sets the skinned mesh in the rest pose (resets the pose).
	 */
	pose(): void;
	/**
	 * Normalizes the skin weights.
	 */
	normalizeSkinWeights(): void;
	/**
	 * Applies the bone transform associated with the given index to the given position vector
	 * @remarks Returns the updated vector.
	 * @param index Expects a `Integer`
	 * @param vector
	 */
	applyBoneTransform(index: number, vector: Vector3): Vector3;
	/**
	 * @deprecated {@link SkinnedMesh}: {@link boneTransform | .boneTransform()} was renamed to {@link applyBoneTransform | .applyBoneTransform()} in **r151**.
	 */
	boneTransform(index: number, target: Vector3): Vector3;
}
declare class Points<TGeometry extends BufferGeometry<NormalOrGLBufferAttributes> = BufferGeometry, TMaterial extends Material | Material[] = Material | Material[]> extends Object3D {
	/**
	 * Create a new instance of {@link Points}
	 * @param geometry An instance of {@link BufferGeometry | BufferGeometry}. Default {@link THREE.BufferGeometry | `new THREE.BufferGeometry()`}.
	 * @param material A single or an array of {@link Material | Material}. Default {@link THREE.PointsMaterial | `new THREE.PointsMaterial()`}.
	 */
	constructor(geometry?: TGeometry, material?: TMaterial);
	/**
	 * Read-only flag to check if a given object is of type {@link Points}.
	 * @remarks This is a _constant_ value
	 * @defaultValue `true`
	 */
	readonly isPoints: true;
	/**
	 * @override
	 * @defaultValue `Points`
	 */
	override readonly type: string | "Points";
	/**
	 * An array of weights typically from `0-1` that specify how much of the morph is applied.
	 * @defaultValue `undefined`, _but reset to a blank array by {@link updateMorphTargets | .updateMorphTargets()}._
	 */
	morphTargetInfluences?: number[] | undefined;
	/**
	 * A dictionary of morphTargets based on the `morphTarget.name` property.
	 * @defaultValue `undefined`, _but rebuilt by {@link updateMorphTargets | .updateMorphTargets()}._
	 *
	 */
	morphTargetDictionary?: {
		[key: string]: number;
	} | undefined;
	/**
	 * An instance of {@link BufferGeometry | BufferGeometry} (or derived classes), defining the object's structure.
	 * @remarks each vertex designates the position of a particle in the system.
	 */
	geometry: TGeometry;
	/**
	 * An instance of {@link Material | Material}, defining the object's appearance.
	 * @defaultValue {@link PointsMaterial | `new THREE.PointsMaterial()`}, _with randomised colour_.
	 */
	material: TMaterial;
	/**
	 * Updates the morphTargets to have no influence on the object
	 * @remarks Resets the {@link morphTargetInfluences} and {@link morphTargetDictionary} properties.
	 */
	updateMorphTargets(): void;
}
declare class WebGLArrayRenderTarget extends WebGLRenderTarget {
	/**
	 * Creates a new WebGLArrayRenderTarget.
	 *
	 * @param width the width of the render target, in pixels.
	 * @param height the height of the render target, in pixels.
	 * @param depth the depth/layer count of the render target.
	 */
	constructor(width?: number, height?: number, depth?: number);
	/**
	 * The depth of the render target.
	 */
	depth: number;
	/**
	 * The texture property is overwritten with an instance of {@link DataArrayTexture}.
	 */
	texture: DataArrayTexture;
	readonly isWebGLArrayRenderTarget: true;
}
declare class FogExp2 implements FogBase {
	/**
	 * The color parameter is passed to the {@link Color | Color} constructor to set the color property
	 * @remarks Color can be a hexadecimal integer or a CSS-style string.
	 * @param color
	 * @param density Expects a `Float`
	 */
	constructor(color: ColorRepresentation, density?: number);
	/**
	 * Read-only flag to check if a given object is of type {@link FogExp2}.
	 * @remarks This is a _constant_ value
	 * @defaultValue `true`
	 */
	readonly isFogExp2: true;
	/**
	 * Optional name of the object
	 * @remarks _(doesn't need to be unique)_.
	 * @defaultValue `""`
	 */
	name: string;
	/**
	 * Fog color.
	 * @remarks If set to black, far away objects will be rendered black.
	 */
	color: Color;
	/**
	 * Defines how fast the fog will grow dense.
	 * @defaultValue `0.00025`
	 * @remarks Expects a `Float`
	 */
	density: number;
	/**
	 * Returns a new {@link FogExp2} instance with the same parameters as this one.
	 */
	clone(): FogExp2;
	/**
	 * Return {@link FogExp2} data in JSON format.
	 */
	toJSON(): any;
}
declare class ActorManualTriggersController {
	protected actorsManager: ActorsManager;
	private _scene;
	constructor(actorsManager: ActorsManager);
	runTriggerFromFunctionNode(node: ActorBuilderNode, methodName: string): void;
}
declare enum JsType {
	ANIMATION_MIXER = "animationMixer",
	ANIMATION_MIXER_UPDATE = "animationMixerUpdate",
	ATTRIBUTE = "attribute",
	CODE = "code",
	CURSOR = "cursor",
	GEOLOCATION_CURRENT_POSITION = "geolocationCurrentPosition",
	GET_INSTANCE_ATTRIBUTE = "getInstanceAttribute",
	GET_INSTANCE_PROPERTY = "getInstanceProperty",
	GET_OBJECT_ATTRIBUTE = "getObjectAttribute",
	GET_OBJECT_PROPERTY = "getObjectProperty",
	GET_OBJECT_USER_DATA = "getObjectUserData",
	GET_NODE = "getNode",
	GET_PARAM = "getParam",
	GET_POINT_ATTRIBUTE = "getPointAttribute",
	GET_POINT_PROPERTY = "getPointProperty",
	GLOBALS = "globals",
	GLOBALS_AMBIENT_LIGHT = "globalsAmbientLight",
	GLOBALS_AREA_LIGHT = "globalsAreaLight",
	GLOBALS_DIRECTIONAL_LIGHT = "globalsDirectionalLight",
	GLOBALS_HEMISPHERE_LIGHT = "globalsHemisphereLight",
	GLOBALS_POINT_LIGHT = "globalsPointLight",
	GLOBALS_SPOT_LIGHT = "globalsSpotLight",
	KEYFRAMES = "keyframes",
	ON_CHILD_ATTRIBUTE_UPDATE = "onChildAttributeUpdate",
	ON_KEY = "onKey",
	ON_KEYDOWN = "onKeydown",
	ON_KEYPRESS = "onKeypress",
	ON_KEYUP = "onKeyup",
	ON_MAPBOX_CAMERA_MOVE = "onMapboxCameraMove",
	ON_MAPBOX_CAMERA_MOVE_START = "onMapboxCameraMoveStart",
	ON_MAPBOX_CAMERA_MOVE_END = "onMapboxCameraMoveEnd",
	ON_OBJECT_ATTRIBUTE_UPDATE = "onObjectAttributeUpdate",
	ON_OBJECT_BEFORE_DELETE = "onObjectBeforeDelete",
	ON_OBJECT_CLICK = "onObjectClick",
	ON_OBJECT_DISPATCH_EVENT = "onObjectDispatchEvent",
	ON_OBJECT_HOVER = "onObjectHover",
	ON_OBJECT_POINTERDOWN = "onObjectPointerdown",
	ON_OBJECT_POINTERUP = "onObjectPointerup",
	ON_OBJECT_SWIPEDOWN = "onObjectSwipedown",
	ON_OBJECT_SWIPELEFT = "onObjectSwipeleft",
	ON_OBJECT_SWIPERIGHT = "onObjectSwiperight",
	ON_OBJECT_SWIPEUP = "onObjectSwipeup",
	ON_POINTERDOWN = "onPointerdown",
	ON_POINTERUP = "onPointerup",
	ON_SCENE_PAUSE = "onScenePause",
	ON_SCENE_PLAY = "onScenePlay",
	ON_SCENE_RESET = "onSceneReset",
	ON_SCROLL = "onScroll",
	ON_MANUAL_TRIGGER = "onManualTrigger",
	ON_TICK = "onTick",
	ON_PERFORMANCE_CHANGE = "onPerformanceChange",
	ON_VIDEO_EVENT = "onVideoEvent",
	ON_WEBXR_CONTROLLER_EVENT = "onWebXRControllerEvent",
	OUTPUT = "output",
	OUTPUT_AMBIENT_LIGHT = "outputAmbientLight",
	OUTPUT_AREA_LIGHT = "outputAreaLight",
	OUTPUT_DIRECTIONAL_LIGHT = "outputDirectionalLight",
	OUTPUT_HEMISPHERE_LIGHT = "outputHemisphereLight",
	OUTPUT_POINT_LIGHT = "outputPointLight",
	OUTPUT_SPOT_LIGHT = "outputSpotLight",
	PARAM = "param",
	RAY_FROM_CURSOR = "rayFromCursor",
	RAY_FROM_CAMERA = "rayFromCamera",
	SDF_2D_BOX = "SDF2DBox",
	SDF_2D_CIRCLE = "SDF2DCircle",
	SDF_2D_CROSS = "SDF2DCross",
	SDF_2D_HEART = "SDF2DHeart",
	SDF_2D_ROUNDED_X = "SDF2DRoundedX",
	SDF_BOX = "SDFBox",
	SDF_ELONGATE = "SDFElongate",
	SDF_ONION = "SDFOnion",
	SDF_PLANE = "SDFPlane",
	SDF_REVOLUTION = "SDFRevolution",
	SDF_SPHERE = "SDFSphere",
	SDF_TORUS = "SDFTorus",
	SDF_TRANSFORM = "SDFTransform",
	SDF_TUBE = "SDFTube",
	SET_INSTANCE_ATTRIBUTE = "setInstanceAttribute",
	SET_INSTANCE_LOOK_AT = "setInstanceLookAt",
	SET_INSTANCE_POSITION = "setInstancePosition",
	SET_INSTANCE_QUATERNION = "setInstanceQuaternion",
	SET_INSTANCE_SCALE = "setInstanceScale",
	SET_OBJECT_ATTRIBUTE = "setObjectAttribute",
	SET_OBJECT_LOOK_AT = "setObjectLookAt",
	SET_OBJECT_POSITION = "setObjectPosition",
	SET_OBJECT_QUATERNION = "setObjectQuaternion",
	SET_OBJECT_ROTATION = "setObjectRotation",
	SET_OBJECT_SCALE = "setObjectSCALE",
	SET_PARAM = "setParam",
	SET_PHYSICS_RBD_POSITION = "setPhysicsRBDPosition",
	SET_PLAYER_INPUT = "setPlayerInput",
	SET_POINT_ATTRIBUTE = "setPointAttribute",
	SET_POINT_POSITION = "setPointPosition",
	SET_SOFT_BODY_CONSTRAINT_POSITION = "setSoftBodyConstraintPosition",
	SET_SOFT_BODY_POSITION = "setSoftBodyPosition",
	SET_SOFT_BODY_VELOCITY = "setSoftBodyVelocity"
}
declare enum CoreEventEmitter {
	CANVAS = "canvas",
	DOCUMENT = "document"
}
declare enum PointerEventType {
	click = "click",
	pointerdown = "pointerdown",
	pointermove = "pointermove",
	pointerup = "pointerup",
	touchstart = "touchstart",
	touchmove = "touchmove",
	touchend = "touchend"
}
declare enum KeyboardEventType {
	keydown = "keydown",
	keypress = "keypress",
	keyup = "keyup"
}
declare enum WindowEventType {
	resize = "resize"
}
declare enum DragEventType {
	dragover = "dragover"
}
declare enum MouseEventType {
	auxclick = "auxclick",
	click = "click",
	contextmenu = "contextmenu",
	dblclick = "dblclick",
	mousedown = "mousedown",
	mouseenter = "mouseenter",
	mouseleave = "mouseleave",
	mousemove = "mousemove",
	mouseover = "mouseover",
	mouseout = "mouseout",
	mouseup = "mouseup",
	pointerlockchange = "pointerlockchange",
	pointerlockerror = "pointerlockerror",
	select = "select",
	wheel = "wheel"
}
declare enum TouchEventType {
	touchstart = "touchstart",
	touchmove = "touchmove",
	touchend = "touchend"
}
type EventType = PointerEventType | MouseEventType | KeyboardEventType | WindowEventType | DragEventType | KeyboardEventType | TouchEventType;
interface EventData {
	type: EventType;
	emitter: CoreEventEmitter;
}
type CoreGraphNodeId = number;
declare class CoreGraph {
	private _nextId;
	private _scene;
	private _successors;
	private _predecessors;
	private _nodesById;
	private _forbiddenTriggerNodeIds;
	private _selfDirtyForbidden;
	private _nodesCount;
	private _debugging;
	private _addedNodesDuringDebugging;
	startDebugging(): void;
	stopDebugging(): void;
	printDebug(): void;
	setScene(scene: PolyScene): void;
	scene(): PolyScene | undefined;
	nextId(): CoreGraphNodeId;
	nodesFromIds(ids: number[], target: CoreGraphNode[]): void;
	nodeFromId(id: number): CoreGraphNode | undefined;
	hasNode(node: CoreGraphNode): boolean;
	addNode(node: CoreGraphNode): void;
	removeNode(node: CoreGraphNode): void;
	nodesCount(): number;
	connect(src: CoreGraphNode, dest: CoreGraphNode, checkCycle?: boolean): boolean;
	disconnect(src: CoreGraphNode, dest: CoreGraphNode): void;
	disconnectPredecessors(node: CoreGraphNode): void;
	disconnectSuccessors(node: CoreGraphNode): void;
	predecessorIds(id: CoreGraphNodeId): CoreGraphNodeId[] | undefined;
	predecessors(node: CoreGraphNode): CoreGraphNode[] | undefined;
	successorIds(id: CoreGraphNodeId): CoreGraphNodeId[] | undefined;
	successors(node: CoreGraphNode): CoreGraphNode[] | undefined;
	private _boundPredecessorIds;
	private _boundSuccessorIds;
	allPredecessorIds(node: CoreGraphNode, target: CoreGraphNodeId[]): void;
	allSuccessorIds(node: CoreGraphNode, target: CoreGraphNodeId[]): void;
	allPredecessors(node: CoreGraphNode, target: CoreGraphNode[]): void;
	allSuccessors(node: CoreGraphNode, target: CoreGraphNode[]): void;
	private _createConnection;
	private _removeConnection;
	setForbiddenTriggerNodes(src: CoreGraphNode, dest: CoreGraphNode | CoreGraphNode[]): void;
	clearForbiddenTriggerNodes(src: CoreGraphNode): void;
	setSelfDirtyForbidden(node: CoreGraphNode, state: boolean): void;
	selfDirtyForbidden(node: CoreGraphNode): boolean;
}
type PostDirtyHook = (caller?: CoreGraphNode) => void;
declare class DirtyController {
	private node;
	private _dirtyCount;
	private _dirty;
	private _dirtyTimestamp;
	private _cooker;
	private _postDirtyHooks;
	private _postDirtyHookNames;
	constructor(node: CoreGraphNode);
	dispose(): void;
	isDirty(): boolean;
	dirtyTimestamp(): number | undefined;
	dirtyCount(): number;
	hasPostDirtyHooks(): boolean;
	addPostDirtyHook(name: string, method: PostDirtyHook): void;
	removePostDirtyHook(name: string): void;
	hasHook(name: string): boolean;
	removeDirtyState(): void;
	setDirty(originalTriggerGraphNode?: CoreGraphNode | null, propagate?: boolean): void;
	runPostDirtyHooks(originalTriggerGraphNode?: CoreGraphNode): void;
	setSuccessorsDirty(originalTriggerGraphNode?: CoreGraphNode): void;
}
declare class CoreGraphNode {
	protected _scene: PolyScene;
	protected _name: string;
	private _graph;
	private _graphNodeId;
	private _dirtyController;
	private _allPredecessors;
	private _allSuccessors;
	private _allPredecessorsDirty;
	private _allSuccessorsDirty;
	constructor(_scene: PolyScene, _name: string);
	private _disposed;
	dispose(): void;
	disposed(): boolean;
	/**
	 * returns the name
	 *
	 */
	name(): string;
	setName(name: string): void;
	/**
	 * returns the scene
	 *
	 */
	scene(): PolyScene;
	/**
	 * returns the id, which is unique for the scene
	 *
	 */
	graphNodeId(): CoreGraphNodeId;
	get dirtyController(): DirtyController;
	/**
	 * makes the graphNode dirty, which in turns makes its dependencies dirty
	 *
	 */
	setDirty(trigger?: CoreGraphNode | null): void;
	/**
	 * makes dependencies dirty
	 *
	 */
	setSuccessorsDirty(trigger?: CoreGraphNode): void;
	/**
	 * removes the dirty state
	 *
	 */
	removeDirtyState(): void;
	isDirty(): boolean;
	/**
	 * adds a callback that gets run when the graphNode is dirty
	 *
	 */
	addPostDirtyHook(name: string, callback: PostDirtyHook): void;
	removePostDirtyHook(name: string): void;
	graphRemove(): void;
	addGraphInput(src: CoreGraphNode, checkCycle?: boolean): boolean;
	removeGraphInput(src: CoreGraphNode): void;
	graphDisconnectPredecessors(): void;
	graphDisconnectSuccessors(): void;
	graphPredecessorIds(): Readonly<CoreGraphNodeId[]> | undefined;
	graphPredecessors(): Readonly<CoreGraphNode[]> | undefined;
	graphSuccessorIds(): Readonly<CoreGraphNodeId[]> | undefined;
	graphSuccessors(): Readonly<CoreGraphNode[]> | undefined;
	private _clearAllPredecessors;
	private _clearAllSuccessors;
	graphAllPredecessors(): Readonly<CoreGraphNode[]>;
	graphAllSuccessors(): Readonly<CoreGraphNode[]>;
	hasPredecessor(node: CoreGraphNode): boolean;
	clearCachesWithPredecessorsAndSuccessors(): void;
	setForbiddenTriggerNodes(nodes: CoreGraphNode | CoreGraphNode[]): void;
	clearForbiddenTriggerNodes(): void;
	setSelfDirtyForbidden(state: boolean): void;
	selfDirtyForbidden(): boolean;
}
interface NodeUIDataJson {
	x: number;
	y: number;
	comment?: string;
}
declare class UIData {
	private node;
	private _position;
	protected _width: number;
	private _color;
	private _layoutVertical;
	private _comment;
	private _json;
	constructor(node: BaseNodeType, x?: number, y?: number);
	dispose(): void;
	setComment(comment: string | undefined): void;
	comment(): string | undefined;
	setColor(color: Color): void;
	color(): Color;
	setLayoutHorizontal(): void;
	isLayoutVertical(): boolean;
	copy(ui_data: UIData): void;
	position(): Vector2;
	setPosition(newPosition: Vector2 | number, y?: number): this;
	translate(offset: Vector2, snap?: boolean): this;
	toJSON(): NodeUIDataJson;
}
type FlagHookCallback = () => void;
declare class BaseFlag {
	protected node: BaseNodeType;
	protected _state: boolean;
	protected _hooks: FlagHookCallback[] | null;
	constructor(node: BaseNodeType);
	onUpdate(hook: FlagHookCallback): void;
	protected _onUpdate(): void;
	set(newState: boolean): void;
	active(): boolean;
	toggle(): void;
	private runHooks;
}
declare class BypassFlag extends BaseFlag {
	protected _state: boolean;
	protected _onUpdate(): void;
}
declare class DisplayFlag extends BaseFlag {
	protected _onUpdate(): void;
}
declare class OptimizeFlag extends BaseFlag {
	protected _state: boolean;
	protected _onUpdate(): void;
}
declare class FlagsController {
	readonly node: BaseNodeType;
	readonly bypass: DisplayFlag | undefined;
	readonly display: BypassFlag | undefined;
	readonly optimize: OptimizeFlag | undefined;
	constructor(node: BaseNodeType);
	hasDisplay(): boolean;
	hasBypass(): boolean;
	hasOptimize(): boolean;
}
declare const FlagsControllerD_base: {
	new (...args: any[]): {
		readonly node: BaseNodeType;
		display: DisplayFlag;
		hasDisplay(): boolean;
	};
} & typeof FlagsController;
declare class FlagsControllerD extends FlagsControllerD_base {
}
declare const FlagsControllerB_base: {
	new (...args: any[]): {
		readonly node: BaseNodeType;
		readonly bypass: BypassFlag;
		hasBypass(): boolean;
	};
} & typeof FlagsController;
declare class FlagsControllerB extends FlagsControllerB_base {
}
declare const FlagsControllerDB_base: {
	new (...args: any[]): {
		readonly node: BaseNodeType;
		readonly bypass: BypassFlag;
		hasBypass(): boolean;
	};
} & {
	new (...args: any[]): {
		readonly node: BaseNodeType;
		display: DisplayFlag;
		hasDisplay(): boolean;
	};
} & typeof FlagsController;
declare class FlagsControllerDB extends FlagsControllerDB_base {
}
declare const FlagsControllerBO_base: {
	new (...args: any[]): {
		readonly node: BaseNodeType;
		readonly optimize: OptimizeFlag;
		hasOptimize(): boolean;
	};
} & {
	new (...args: any[]): {
		readonly node: BaseNodeType;
		readonly bypass: BypassFlag;
		hasBypass(): boolean;
	};
} & typeof FlagsController;
declare class FlagsControllerBO extends FlagsControllerBO_base {
}
declare const FlagsControllerDBO_base: {
	new (...args: any[]): {
		readonly node: BaseNodeType;
		readonly optimize: OptimizeFlag;
		hasOptimize(): boolean;
	};
} & {
	new (...args: any[]): {
		readonly node: BaseNodeType;
		readonly bypass: BypassFlag;
		hasBypass(): boolean;
	};
} & {
	new (...args: any[]): {
		readonly node: BaseNodeType;
		display: DisplayFlag;
		hasDisplay(): boolean;
	};
} & typeof FlagsController;
declare class FlagsControllerDBO extends FlagsControllerDBO_base {
}
declare enum ParamType {
	BOOLEAN = "boolean",
	BUTTON = "button",
	COLOR = "color",
	FLOAT = "float",
	FOLDER = "folder",
	INTEGER = "integer",
	PARAM_PATH = "param_path",
	NODE_PATH = "node_path",
	RAMP = "ramp",
	STRING = "string",
	VECTOR2 = "vector2",
	VECTOR3 = "vector3",
	VECTOR4 = "vector4"
}
interface Vector2Like {
	x: number;
	y: number;
}
interface Vector3Like {
	x: number;
	y: number;
	z: number;
}
interface Vector4Like {
	x: number;
	y: number;
	z: number;
	w: number;
}
interface ColorLike {
	r: number;
	g: number;
	b: number;
}
type Tuple1<T> = [
	T
];
type Tuple2<T> = [
	T,
	T
];
type Tuple3<T> = [
	T,
	T,
	T
];
type Tuple4<T> = [
	T,
	T,
	T,
	T
];
type Tuple5<T> = [
	T,
	T,
	T,
	T,
	T
];
type Tuple6<T> = [
	T,
	T,
	T,
	T,
	T,
	T
];
type Tuple7<T> = [
	T,
	T,
	T,
	T,
	T,
	T,
	T
];
type Tuple8<T> = [
	T,
	T,
	T,
	T,
	T,
	T,
	T,
	T
];
type Tuple9<T> = [
	T,
	T,
	T,
	T,
	T,
	T,
	T,
	T,
	T
];
type Tuple16<T> = [
	T,
	T,
	T,
	T,
	T,
	T,
	T,
	T,
	T,
	T,
	T,
	T,
	T,
	T,
	T,
	T
];
type StringOrNumber = string | number;
type Boolean2 = Tuple2<boolean>;
type Number2 = Tuple2<number>;
type Number3 = Tuple3<number>;
type Number4 = Tuple4<number>;
type Number16 = Tuple16<number>;
type StringOrNumber2 = Tuple2<StringOrNumber>;
type StringOrNumber3 = Tuple3<StringOrNumber>;
type StringOrNumber4 = Tuple4<StringOrNumber>;
type NumericAttribValueAsArray = Number2 | Number3 | Number4;
type NumericAttribValueAsVectorLike = Vector2Like | Vector3Like | Vector4Like | ColorLike;
type NumericAttribValue = number | NumericAttribValueAsVectorLike | NumericAttribValueAsArray;
type AttribValue = string | NumericAttribValue | boolean;
type Constructor<T = {}> = new (...args: any[]) => T;
interface PolyDictionary<T> {
	[Key: string]: T;
}
type valueof<T> = T[keyof T];
// @ts-ignore
type CadGeometry = gp_Pnt2d | Geom2d_Curve | TopoDS_Vertex | TopoDS_Edge | TopoDS_Wire | TopoDS_Shape;
declare enum CadGeometryType {
	POINT_2D = "CADPoint2D",
	CURVE_2D = "CADCurve2D",
	VERTEX = "CADVertex",
	EDGE = "CADEdge",
	WIRE = "CADWire",
	FACE = "CADFace",
	SHELL = "CADShell",
	SOLID = "CADSolid",
	COMPSOLID = "CADCompsolid",
	COMPOUND = "CADCompound"
}
type CadGeometryTypeShape = CadGeometryType.VERTEX | CadGeometryType.EDGE | CadGeometryType.WIRE | CadGeometryType.FACE | CadGeometryType.SHELL | CadGeometryType.SOLID | CadGeometryType.COMPSOLID | CadGeometryType.COMPOUND;
interface CadTypeMap {
// @ts-ignore
	[CadGeometryType.POINT_2D]: gp_Pnt2d;
// @ts-ignore
	[CadGeometryType.CURVE_2D]: Geom2d_Curve;
// @ts-ignore
	[CadGeometryType.VERTEX]: TopoDS_Vertex;
// @ts-ignore
	[CadGeometryType.EDGE]: TopoDS_Edge;
// @ts-ignore
	[CadGeometryType.WIRE]: TopoDS_Wire;
// @ts-ignore
	[CadGeometryType.FACE]: TopoDS_Face;
// @ts-ignore
	[CadGeometryType.SHELL]: TopoDS_Shell;
// @ts-ignore
	[CadGeometryType.SOLID]: TopoDS_Solid;
// @ts-ignore
	[CadGeometryType.COMPSOLID]: TopoDS_CompSolid;
// @ts-ignore
	[CadGeometryType.COMPOUND]: TopoDS_Compound;
}
interface CachedCADTesselationParams {
	linearTolerance: number;
	angularTolerance: number;
	curveAbscissa: number;
	curveTolerance: number;
}
interface CachedCADOBJTesselationParams {
	CADLinearTolerance: number;
	CADAngularTolerance: number;
	CADCurveAbscissa: number;
	CADCurveTolerance: number;
}
interface CADTesselationParams extends CachedCADTesselationParams {
	wireframe: boolean;
	displayMeshes: boolean;
	displayEdges: boolean;
	meshesColor: Color;
	edgesColor: Color;
}
interface CADOBJTesselationParams extends CachedCADOBJTesselationParams {
	CADWireframe: boolean;
	CADDisplayMeshes: boolean;
	CADDisplayEdges: boolean;
	CADMeshesColor: Color;
	CADEdgesColor: Color;
}
type CsgGeometry = geometries.path2.Path2 | geometries.geom2.Geom2 | geometries.geom3.Geom3;
declare enum CsgGeometryType {
	PATH2 = "CSGPath2",
	GEOM2 = "CSGGeom2",
	GEOM3 = "CSGGeom3"
}
interface CsgTypeMap {
	[CsgGeometryType.PATH2]: geometries.path2.Path2;
	[CsgGeometryType.GEOM2]: geometries.geom2.Geom2;
	[CsgGeometryType.GEOM3]: geometries.geom3.Geom3;
}
interface CSGTesselationParams {
	facetAngle: number;
	wireframe: boolean;
	meshesColor: Color;
	linesColor: Color;
}
interface CSGOBJTesselationParams {
	CSGFacetAngle: number;
	CSGWireframe: boolean;
	CSGMeshesColor: Color;
	CSGLinesColor: Color;
}
declare class QuadGeometry {
	attributes: Record<string, BufferAttribute>;
	index: number[];
	userData: {
		[key: string]: any;
	};
	setAttribute(attribName: string, attribute: BufferAttribute): void;
	setIndex(indices: number[]): void;
	quadsCount(): number;
	applyMatrix(matrix: Matrix4): QuadGeometry;
	clone(): QuadGeometry;
	boundingBox(target: Box3): void;
}
// @ts-ignore
type SDFGeometry = Manifold;
interface TetNeighbourData {
	id: number;
	faceIndex: number;
}
type TetPointIds = Number4;
type TetNeighbourDataOrNull = TetNeighbourData | null;
type TetNeighbourDatas = [
	TetNeighbourDataOrNull,
	TetNeighbourDataOrNull,
	TetNeighbourDataOrNull,
	TetNeighbourDataOrNull
];
interface TetNeighbourDataWithSource {
	pointIds: Number3;
}
interface TetrahedronPoint {
	id: number;
	position: Vector3;
}
interface TetrahedronSphere {
	center: Vector3;
	radius: number;
}
interface Tetrahedron {
	id: number;
	pointIds: TetPointIds;
	neighbours: TetNeighbourDatas;
	sphere: TetrahedronSphere;
	disposed: boolean;
}
interface TetTesselationParams {
	scale: number;
	displayOuterMesh: boolean;
	displayTetMesh: boolean;
	displayLines: boolean;
	displaySharedFaces: boolean;
	displayPoints: boolean;
	displayCenter: boolean;
	displaySphere: boolean;
}
interface TetOBJTesselationParams {
	TetScale: number;
	TetDisplayOuterMesh: boolean;
	TetDisplayTetMesh: boolean;
	TetDisplayLines: boolean;
	TetDisplaySharedFaces: boolean;
	TetDisplayPoints: boolean;
	TetDisplayCenter: boolean;
	TetDisplaySphere: boolean;
}
declare class TetGeometry {
	readonly tetrahedrons: Map<number, Tetrahedron>;
	readonly points: Map<number, TetrahedronPoint>;
	readonly tetrahedronsByPointId: Map<number, Set<number>>;
	private _nextPointId;
	private _nextTetId;
	private _pointsCount;
	private _tetsCount;
	private _lastAddedTetId;
	addPoint(x: number, y: number, z: number): number;
	removePoint(pointId: number): void;
	pointsCount(): number;
	tetsCount(): number;
	firstTetId(): number | undefined;
	lastAddedTetId(): number | null;
	addTetrahedron(p0: number, p1: number, p2: number, p3: number): number | undefined;
	removeTets(tetIds: number[], sharedFacesNeighbourData?: Set<TetNeighbourDataWithSource>, newPointPosition?: Vector3): void;
	clone(): this;
	applyMatrix4(matrix: Matrix4): void;
	boundingBox(target: Box3): void;
	boundingSphere(target: Sphere): void;
}
declare enum CoreObjectType {
	THREEJS = "Object3D",
	CAD = "CADObject",
	CSG = "CSGObject",
	QUAD = "QUADObject",
	SDF = "SDFObject",
	TET = "TetObject"
}
interface ObjectGeometryMap {
	[CoreObjectType.THREEJS]: BufferGeometry;
	[CoreObjectType.CAD]: CadGeometry;
	[CoreObjectType.CSG]: CsgGeometry;
	[CoreObjectType.QUAD]: QuadGeometry;
	[CoreObjectType.SDF]: SDFGeometry;
	[CoreObjectType.TET]: TetGeometry;
}
interface ObjectContent<T extends CoreObjectType> {
	type: string;
	geometry?: ObjectGeometryMap[T];
	userData: {
		[key: string]: any;
	};
	name: string;
	visible: boolean;
	castShadow: boolean;
	receiveShadow: boolean;
	renderOrder: number;
	frustumCulled: boolean;
	matrixAutoUpdate: boolean;
	material?: Material | Material[];
	children: ObjectContent<T>[];
	parent: ObjectContent<T> | null;
	clone: () => ObjectContent<T>;
	dispose?: () => void;
	traverse(callback: (object: ObjectContent<T>) => any): void;
	applyMatrix4(matrix: Matrix4): void;
	add: (...object: any[]) => void;
	remove: (...object: any[]) => void;
	dispatchEvent: (event: {
		type: string;
	}) => void;
}
interface MergeCompactOptions {
	objects: ObjectContent<CoreObjectType>[];
	mergedObjects: ObjectContent<CoreObjectType>[];
	material?: Material;
	objectType: string;
	onError: (message: string) => void;
}
type ObjectBuilder<T extends CoreObjectType> = (object: ObjectContent<T>, entities: CoreEntity[]) => ObjectContent<T> | undefined;
declare abstract class CoreEntity {
	protected _index: number;
	constructor(content?: any, index?: number);
	index(): number;
	setIndex(index: number): this;
	abstract geometry(): any;
	abstract builder<T extends CoreObjectType>(): ObjectBuilder<T> | undefined;
	abstract setAttribValue(attribName: string, attribValue: NumericAttribValue | string): void;
	abstract attribValue(attribName: string, target?: Vector2 | Vector3 | Vector4): AttribValue | undefined;
	abstract stringAttribValue(attribName: string): string | null;
	abstract position(target: Vector3): Vector3;
	abstract relatedEntities(attribClass: AttribClass, coreGroup: CoreGroup, target: CoreEntity[]): void;
}
type CoreEntitySelectionState = Map<CoreEntity, boolean>;
declare enum GroupOperation {
	SET = "replace existing",
	UNION = "add to existing",
	SUBTRACT = "subtract from existing",
	INTERSECT = "intersect with existing"
}
interface GroupData {
	name: string;
	entitiesCount: number;
}
type GroupsDataForType = GroupData[];
type GroupCollectionData = Record<string, GroupsDataForType>;
declare enum EntityGroupType {
	POINT = "point",
	OBJECT = "object",
	EDGE = "edge",
	FACE = "face"
}
interface UpdateGroupOptions {
	type: EntityGroupType;
	groupName: string;
	operation: GroupOperation;
	invert: boolean;
}
type GroupsDictionary = Record<string, Record<string, number[]>>;
declare class EntityGroupCollection {
	private _object;
	constructor(_object: ObjectContent<CoreObjectType>);
	attributesDictionary(): GroupsDictionary;
	static attributesDictionary<T extends CoreObjectType>(object: ObjectContent<T>): GroupsDictionary;
	private static _createAttributesDictionaryIfNone;
	findOrCreateGroup(type: EntityGroupType, groupName: string): number[];
	deleteGroup(type: EntityGroupType, groupName: string): void;
	static data<T extends CoreObjectType>(object: ObjectContent<T>): GroupCollectionData;
	indicesSet(type: EntityGroupType, groupName: string, target: Set<number>): void;
	private selectedIndices;
	updateGroup(options: UpdateGroupOptions, selectionStates: CoreEntitySelectionState): void;
}
declare enum ObjectType {
	AMBIENT_LIGHT = "AmbientLight",
	AREA_LIGHT = "AreaLight",
	CUBE_CAMERA = "CubeCamera",
	DIRECTIONAL_LIGHT = "DirectionalLight",
	GROUP = "Group",
	HEMISPHERE_LIGHT = "HemisphereLight",
	LIGHT_PROBE = "LightProbe",
	LINE_SEGMENTS = "LineSegments",
	LOD = "LOD",
	MESH = "Mesh",
	OBJECT3D = "Object3D",
	ORTHOGRAPHIC_CAMERA = "OrthographicCamera",
	PERSPECTIVE_CAMERA = "PerspectiveCamera",
	POINT_LIGHT = "PointLight",
	POINTS = "Points",
	SCENE = "Scene",
	SPOT_LIGHT = "SpotLight"
}
interface ObjectByObjectType {
	[ObjectType.AMBIENT_LIGHT]: AmbientLight;
	[ObjectType.AREA_LIGHT]: RectAreaLight;
	[ObjectType.CUBE_CAMERA]: CubeCamera;
	[ObjectType.DIRECTIONAL_LIGHT]: DirectionalLight;
	[ObjectType.GROUP]: Group;
	[ObjectType.HEMISPHERE_LIGHT]: HemisphereLight;
	[ObjectType.LIGHT_PROBE]: LightProbe;
	[ObjectType.LINE_SEGMENTS]: LineSegments;
	[ObjectType.LOD]: LOD;
	[ObjectType.MESH]: Mesh;
	[ObjectType.OBJECT3D]: Object3D;
	[ObjectType.POINT_LIGHT]: PointLight;
	[ObjectType.POINTS]: Points;
	[ObjectType.ORTHOGRAPHIC_CAMERA]: OrthographicCamera;
	[ObjectType.PERSPECTIVE_CAMERA]: PerspectiveCamera;
	[ObjectType.SCENE]: Scene;
	[ObjectType.SPOT_LIGHT]: SpotLight;
}
interface ObjectData {
	type: ObjectType;
	name: string | null;
	childrenCount: number;
	groupData: GroupCollectionData;
	verticesCount: number;
	pointsCount: number;
	primitivesCount: number;
	primitiveName: string;
}
declare enum AttribClass {
	POINT = "point",
	VERTEX = "vertex",
	PRIMITIVE = "primitive",
	OBJECT = "object",
	CORE_GROUP = "coreGroup"
}
declare enum AttribType {
	NUMERIC = "numeric",
	STRING = "string"
}
declare enum AttribSize {
	FLOAT = 1,
	VECTOR2 = 2,
	VECTOR3 = 3,
	VECTOR4 = 4
}
type GroupString = string;
type PointAttributesDict = Record<string, BufferAttribute | InterleavedBufferAttribute>;
declare class CoreAttributeData {
	private _size;
	private _type;
	constructor(_size: number, _type: AttribType);
	size(): number;
	type(): AttribType;
	static from_value(attrib_value: any): CoreAttributeData;
}
interface TypedVertexAttribute<T extends number | string> {
	isString: boolean;
	array: T[];
	itemSize: number;
}
interface BaseVertexAttribute extends TypedVertexAttribute<number | string> {
}
type VertexAttributesDict = Record<string, BaseVertexAttribute>;
interface TypedPrimitiveAttribute<T extends number | string> {
	isString: boolean;
	array: T[];
	itemSize: number;
}
interface BasePrimitiveAttribute extends TypedPrimitiveAttribute<number | string> {
}
type PrimitiveAttributesDict = Record<string, BasePrimitiveAttribute>;
declare enum TransformTargetType {
	OBJECT = "object",
	GEOMETRY = "geometry"
}
interface SetParamsFromMatrixOptions {
	scale?: boolean;
}
declare enum ObjectTransformSpace {
	PARENT = "parent",
	LOCAL = "local"
}
declare enum ObjectTransformMode {
	SET = "set matrix",
	MULT = "multiply matrix"
}
// @ts-ignore
type AttributeDictionary = PolyDictionary<AttribValue>;
interface RampPointJson {
	position: number;
	value: number;
}
interface RampValueJson {
	points: RampPointJson[];
	interpolation: RampInterpolation;
}
declare class RampPoint {
	private _position;
	private _value;
	constructor(_position?: number, _value?: number);
	toJSON(): RampPointJson;
	position(): number;
	value(): number;
	copy(point: RampPoint): void;
	clone(): RampPoint;
	isEqual(other_point: RampPoint): boolean;
	isEqualJSON(json: RampPointJson): boolean;
	fromJSON(json: RampPointJson): void;
	static areEqualJSON(json1: RampPointJson, json2: RampPointJson): boolean;
	static fromJSON(json: RampPointJson): RampPoint;
}
declare enum RampInterpolation {
	CUBIC = "cubic"
}
declare class RampValue {
	private _interpolation;
	private _points;
	private _uuid;
	constructor(_interpolation?: RampInterpolation, _points?: RampPoint[]);
	uuid(): string;
	interpolation(): RampInterpolation;
	points(): RampPoint[];
	static createInterpolantFromValues(positions: Float32Array, values: Float32Array): CubicInterpolant;
	createInterpolant(): CubicInterpolant;
	static createInterpolant(rampValue: RampValue): CubicInterpolant;
	static fromJSON(json: RampValueJson): RampValue;
	toJSON(): RampValueJson;
	clone(): RampValue;
	copy(ramp: RampValue): void;
	isEqual(other_ramp_value: RampValue): boolean;
	isEqualJSON(json: RampValueJson): boolean;
	static are_json_equal(json1: RampValueJson, json2: RampValueJson): boolean;
	fromJSON(json: RampValueJson): void;
}
type ParamInitValuesTypeMapGeneric = {
	[key in ParamType]: any;
};
interface ParamInitValuesTypeMap extends ParamInitValuesTypeMapGeneric {
	[ParamType.BOOLEAN]: number | boolean | string;
	[ParamType.BUTTON]: null;
	[ParamType.COLOR]: StringOrNumber3 | Color;
	[ParamType.FLOAT]: StringOrNumber;
	[ParamType.FOLDER]: null;
	[ParamType.INTEGER]: StringOrNumber;
	[ParamType.PARAM_PATH]: string;
	[ParamType.NODE_PATH]: string;
	[ParamType.RAMP]: RampValue | RampValueJson;
	[ParamType.STRING]: string;
	[ParamType.VECTOR2]: StringOrNumber2 | Vector2;
	[ParamType.VECTOR3]: StringOrNumber3 | Vector3;
	[ParamType.VECTOR4]: StringOrNumber4 | Vector4;
}
interface BaseConnectionPointData {
	name: string;
	type: string;
	isArray?: boolean;
}
declare abstract class BaseConnectionPoint {
	protected _name: string;
	protected _type: string;
	protected _init_value?: any;
	protected _json: BaseConnectionPointData | undefined;
	protected _inNodeDefinition: boolean;
	constructor(_name: string, _type: string, _init_value?: any);
	get init_value(): any;
	name(): string;
	type(): string;
	are_types_matched(src_type: string, dest_type: string): boolean;
	inNodeDefinition(): boolean;
	abstract get param_type(): ParamType | null;
	toJSON(): BaseConnectionPointData;
	protected _createJSON(): BaseConnectionPointData;
}
declare enum JsConnectionPointType {
	ANIMATION_MIXER = "AnimationMixer",
	ANIMATION_ACTION = "AnimationAction",
	BOOLEAN = "boolean",
	BOOLEAN_ARRAY = "boolean[]",
	BOX3 = "Box3",
	CAMERA = "Camera",
	CATMULL_ROM_CURVE3 = "CatmullRomCurve3",
	COLOR = "Color",
	COLOR_ARRAY = "Color[]",
	EULER = "Euler",
	EULER_ARRAY = "Euler[]",
	FLOAT = "float",
	FLOAT_ARRAY = "float[]",
	INT = "int",
	INT_ARRAY = "int[]",
	INTERSECTION = "Intersection",
	INTERSECTION_ARRAY = "Intersection[]",
	MATERIAL = "Material",
	MATRIX4 = "Matrix4",
	MATRIX4_ARRAY = "Matrix4[]",
	NODE = "Node",
	OBJECT_3D = "Object3D",
	OBJECT_3D_ARRAY = "Object3D[]",
	PARAM = "Param",
	PLANE = "Plane",
	QUATERNION = "Quaternion",
	QUATERNION_ARRAY = "Quaternion[]",
	RAY = "Ray",
	SPHERE = "Sphere",
	STRING = "string",
	STRING_ARRAY = "string[]",
	TEXTURE = "Texture",
	TEXTURE_ARRAY = "Texture[]",
	TRIGGER = "trigger",
	VECTOR2 = "Vector2",
	VECTOR2_ARRAY = "Vector2[]",
	VECTOR3 = "Vector3",
	VECTOR3_ARRAY = "Vector3[]",
	VECTOR4 = "Vector4",
	VECTOR4_ARRAY = "Vector4[]"
}
type PrimitiveArrayElement = boolean | number | string;
type VectorArrayElement = Color | Euler | Matrix4 | Quaternion | Vector2 | Vector3 | Vector4;
type ArrayableConnectionPointType = JsConnectionPointType.BOOLEAN | JsConnectionPointType.COLOR | JsConnectionPointType.FLOAT | JsConnectionPointType.INT | JsConnectionPointType.INTERSECTION | JsConnectionPointType.MATRIX4 | JsConnectionPointType.QUATERNION | JsConnectionPointType.STRING | JsConnectionPointType.TEXTURE | JsConnectionPointType.VECTOR2 | JsConnectionPointType.VECTOR3 | JsConnectionPointType.VECTOR4;
type JsConnectionPointTypeArray = JsConnectionPointType.BOOLEAN_ARRAY | JsConnectionPointType.COLOR_ARRAY | JsConnectionPointType.FLOAT_ARRAY | JsConnectionPointType.INT_ARRAY | JsConnectionPointType.INTERSECTION_ARRAY | JsConnectionPointType.MATRIX4_ARRAY | JsConnectionPointType.OBJECT_3D_ARRAY | JsConnectionPointType.QUATERNION_ARRAY | JsConnectionPointType.STRING_ARRAY | JsConnectionPointType.TEXTURE_ARRAY | JsConnectionPointType.VECTOR2_ARRAY | JsConnectionPointType.VECTOR3_ARRAY | JsConnectionPointType.VECTOR4_ARRAY;
type ParamConvertibleJsType = JsConnectionPointType.BOOLEAN | JsConnectionPointType.COLOR | JsConnectionPointType.FLOAT | JsConnectionPointType.INT | JsConnectionPointType.STRING | JsConnectionPointType.VECTOR2 | JsConnectionPointType.VECTOR3 | JsConnectionPointType.VECTOR4;
type PointAttributeJsType = JsConnectionPointType.COLOR | JsConnectionPointType.FLOAT | JsConnectionPointType.INT | JsConnectionPointType.VECTOR2 | JsConnectionPointType.VECTOR3 | JsConnectionPointType.VECTOR4;
type JsDataType = PrimitiveArrayElement | Array<PrimitiveArrayElement> | VectorArrayElement | Array<VectorArrayElement> | AnimationMixer | AnimationAction | Box3 | Camera | CatmullRomCurve3 | Euler | Euler[] | Intersection | Array<Intersection> | Material | Object3D | Array<Object3D> | Ray | Sphere | Texture | Array<Texture> | BaseNodeType | BaseParamType | null;
type JSConnectionPointTypeToDataTypeMapGeneric = {
	[key in JsConnectionPointType]: JsDataType;
};
// @ts-ignore
interface JsIConnectionPointTypeToDataTypeMap extends JSConnectionPointTypeToDataTypeMapGeneric {
	[JsConnectionPointType.ANIMATION_MIXER]: AnimationMixer;
	[JsConnectionPointType.ANIMATION_ACTION]: AnimationAction;
	[JsConnectionPointType.BOOLEAN]: boolean;
	[JsConnectionPointType.BOOLEAN_ARRAY]: boolean[];
	[JsConnectionPointType.BOX3]: Box3;
	[JsConnectionPointType.CAMERA]: Camera;
	[JsConnectionPointType.CATMULL_ROM_CURVE3]: CatmullRomCurve3;
	[JsConnectionPointType.COLOR]: Color;
	[JsConnectionPointType.COLOR_ARRAY]: Color[];
	[JsConnectionPointType.EULER]: Euler;
	[JsConnectionPointType.EULER_ARRAY]: Euler[];
	[JsConnectionPointType.FLOAT]: number;
	[JsConnectionPointType.FLOAT_ARRAY]: number[];
	[JsConnectionPointType.INT]: number;
	[JsConnectionPointType.INT_ARRAY]: number[];
	[JsConnectionPointType.INTERSECTION]: Intersection;
	[JsConnectionPointType.INTERSECTION_ARRAY]: Intersection[];
	[JsConnectionPointType.MATERIAL]: Material;
	[JsConnectionPointType.MATRIX4]: Matrix4;
	[JsConnectionPointType.MATRIX4_ARRAY]: Matrix4[];
	[JsConnectionPointType.NODE]: BaseNodeType;
	[JsConnectionPointType.OBJECT_3D]: Object3D;
	[JsConnectionPointType.OBJECT_3D_ARRAY]: Object3D[];
	[JsConnectionPointType.PARAM]: BaseParamType;
	[JsConnectionPointType.PLANE]: Plane;
	[JsConnectionPointType.QUATERNION]: Quaternion;
	[JsConnectionPointType.QUATERNION_ARRAY]: Quaternion[];
	[JsConnectionPointType.RAY]: Ray;
	[JsConnectionPointType.SPHERE]: Sphere;
	[JsConnectionPointType.STRING]: string;
	[JsConnectionPointType.STRING_ARRAY]: string[];
	[JsConnectionPointType.TEXTURE]: Texture;
	[JsConnectionPointType.TEXTURE_ARRAY]: Texture[];
	[JsConnectionPointType.TRIGGER]: null;
	[JsConnectionPointType.VECTOR2]: Vector2;
	[JsConnectionPointType.VECTOR2_ARRAY]: Vector2[];
	[JsConnectionPointType.VECTOR3]: Vector3;
	[JsConnectionPointType.VECTOR3_ARRAY]: Vector3[];
	[JsConnectionPointType.VECTOR4]: Vector4;
	[JsConnectionPointType.VECTOR4_ARRAY]: Vector4[];
}
type JSConnectionPointTypeToParamTypeMapGeneric = {
	[key in JsConnectionPointType]: ParamType | undefined;
};
interface JsIConnectionPointTypeToParamTypeMap extends JSConnectionPointTypeToParamTypeMapGeneric {
	[JsConnectionPointType.ANIMATION_MIXER]: ParamType.BUTTON;
	[JsConnectionPointType.ANIMATION_ACTION]: ParamType.BUTTON;
	[JsConnectionPointType.BOOLEAN]: ParamType.BOOLEAN;
	[JsConnectionPointType.BOOLEAN_ARRAY]: ParamType.BUTTON;
	[JsConnectionPointType.BOX3]: ParamType.BUTTON;
	[JsConnectionPointType.CAMERA]: ParamType.BUTTON;
	[JsConnectionPointType.CATMULL_ROM_CURVE3]: ParamType.BUTTON;
	[JsConnectionPointType.COLOR]: ParamType.COLOR;
	[JsConnectionPointType.COLOR_ARRAY]: ParamType.BUTTON;
	[JsConnectionPointType.EULER]: ParamType.BUTTON;
	[JsConnectionPointType.EULER_ARRAY]: ParamType.BUTTON;
	[JsConnectionPointType.FLOAT]: ParamType.FLOAT;
	[JsConnectionPointType.FLOAT_ARRAY]: ParamType.BUTTON;
	[JsConnectionPointType.INT]: ParamType.INTEGER;
	[JsConnectionPointType.INT_ARRAY]: ParamType.BUTTON;
	[JsConnectionPointType.INTERSECTION]: ParamType.BUTTON;
	[JsConnectionPointType.INTERSECTION_ARRAY]: ParamType.BUTTON;
	[JsConnectionPointType.MATERIAL]: ParamType.BUTTON;
	[JsConnectionPointType.MATRIX4]: ParamType.BUTTON;
	[JsConnectionPointType.MATRIX4_ARRAY]: ParamType.BUTTON;
	[JsConnectionPointType.NODE]: ParamType.NODE_PATH;
	[JsConnectionPointType.OBJECT_3D]: ParamType.BUTTON;
	[JsConnectionPointType.OBJECT_3D_ARRAY]: ParamType.BUTTON;
	[JsConnectionPointType.PARAM]: ParamType.PARAM_PATH;
	[JsConnectionPointType.PLANE]: ParamType.BUTTON;
	[JsConnectionPointType.QUATERNION]: ParamType.BUTTON;
	[JsConnectionPointType.QUATERNION_ARRAY]: ParamType.BUTTON;
	[JsConnectionPointType.RAY]: ParamType.BUTTON;
	[JsConnectionPointType.SPHERE]: ParamType.BUTTON;
	[JsConnectionPointType.STRING]: ParamType.STRING;
	[JsConnectionPointType.STRING_ARRAY]: ParamType.BUTTON;
	[JsConnectionPointType.TEXTURE]: ParamType.BUTTON;
	[JsConnectionPointType.TEXTURE_ARRAY]: ParamType.BUTTON;
	[JsConnectionPointType.TRIGGER]: ParamType.BUTTON;
	[JsConnectionPointType.VECTOR2]: ParamType.VECTOR2;
	[JsConnectionPointType.VECTOR2_ARRAY]: ParamType.BUTTON;
	[JsConnectionPointType.VECTOR3]: ParamType.VECTOR3;
	[JsConnectionPointType.VECTOR3_ARRAY]: ParamType.BUTTON;
	[JsConnectionPointType.VECTOR4]: ParamType.VECTOR4;
	[JsConnectionPointType.VECTOR4_ARRAY]: ParamType.BUTTON;
}
type ConnectionPointInitValueMapGeneric = {
	[key in JsConnectionPointType]: ParamInitValuesTypeMap[JsIConnectionPointTypeToParamTypeMap[key]];
};
interface JsConnectionPointData<T extends JsConnectionPointType> {
	name: string;
	type: T;
	isArray?: boolean;
}
interface JsConnectionPointOptions<T extends JsConnectionPointType> {
	inNodeDefinition?: boolean;
	init_value?: ConnectionPointInitValueMapGeneric[T];
}
declare class JsConnectionPoint<T extends JsConnectionPointType> extends BaseConnectionPoint {
	protected _type: T;
	protected _options?: JsConnectionPointOptions<T> | undefined;
	protected _json: JsConnectionPointData<T> | undefined;
	protected _init_value?: ConnectionPointInitValueMapGeneric[T];
	protected _isArray: boolean;
	constructor(_name: string, _type: T, _options?: JsConnectionPointOptions<T> | undefined);
	type(): T;
	are_types_matched(src_type: string, dest_type: string): boolean;
	get param_type(): JsIConnectionPointTypeToParamTypeMap[T];
	get init_value(): ConnectionPointInitValueMapGeneric[T] | undefined;
	toJSON(): JsConnectionPointData<T>;
	protected _createJSON(): JsConnectionPointData<T>;
}
type BaseJsConnectionPoint = JsConnectionPoint<JsConnectionPointType>;
interface AttribRefs<T extends ParamConvertibleJsType> {
	current: Ref<JsIConnectionPointTypeToDataTypeMap[T]>;
	previous: Ref<JsIConnectionPointTypeToDataTypeMap[T]>;
}
type ObjectXD = ObjectContent<CoreObjectType>;
type OnAttribChange<T extends ParamConvertibleJsType> = (newValue: JsIConnectionPointTypeToDataTypeMap[T], oldValue: JsIConnectionPointTypeToDataTypeMap[T]) => void;
declare abstract class BaseCoreObject<T extends CoreObjectType> extends CoreEntity {
	protected _object: ObjectContent<T>;
	constructor(object: ObjectContent<T>, index: number);
	dispose(): void;
	object(): ObjectContent<T>;
	geometry(): ObjectGeometryMap[T] | null;
	builder<T extends CoreObjectType>(): ObjectBuilder<T> | undefined;
	static attributeRef<OT extends CoreObjectType, T extends ParamConvertibleJsType>(object: ObjectContent<OT>, attribName: string, type: T, defaultValue: JsIConnectionPointTypeToDataTypeMap[T]): AttribRefs<T>;
	attributeRef<T extends ParamConvertibleJsType>(attribName: string, type: T, defaultValue: JsIConnectionPointTypeToDataTypeMap[T]): AttribRefs<T> | undefined;
	static onAttribChange<OT extends CoreObjectType, T extends ParamConvertibleJsType>(object: ObjectContent<OT>, attribName: string, type: T, defaultValue: JsIConnectionPointTypeToDataTypeMap[T], callback: OnAttribChange<T>): import("@vue-reactivity/watch").WatchStopHandle;
	onAttribChange<T extends ParamConvertibleJsType>(attribName: string, type: T, defaultValue: JsIConnectionPointTypeToDataTypeMap[T], callback: OnAttribChange<T>): import("@vue-reactivity/watch").WatchStopHandle | undefined;
	static setAttribute<T extends CoreObjectType>(object: ObjectContent<T>, attribName: string, value: AttribValue): void;
	static addAttribute<T extends CoreObjectType>(object: ObjectContent<T>, attribName: string, value: AttribValue): void;
	static addNumericAttribute<T extends CoreObjectType>(object: ObjectContent<T>, attribName: string, size?: AttribSize, defaultValue?: NumericAttribValue): void;
	addAttribute(name: string, value: AttribValue): void;
	addNumericAttrib(name: string, value: NumericAttribValue): void;
	setAttribValue(name: string, value: AttribValue): void;
	protected static _attributesDictionary<T extends CoreObjectType>(object: ObjectContent<T>): AttributeDictionary;
	static attributesDictionaryEntry<T extends CoreObjectType>(object: ObjectContent<T>, attribName: string, defaultValue?: AttribValue): AttribValue;
	private static _createAttributesDictionaryIfNone;
	private _attributesDictionary;
	static attributes<T extends CoreObjectType>(object: ObjectContent<T>): AttributeDictionary | undefined;
	attributes(): AttributeDictionary | undefined;
	attributeNames(): string[];
	static attribNames<T extends CoreObjectType>(object: ObjectContent<T>): string[];
	attribNames(): string[];
	static hasAttribute<T extends CoreObjectType>(object: ObjectContent<T>, attribName: string): boolean;
	hasAttribute(attribName: string): boolean;
	static attributeNames<T extends CoreObjectType>(object: ObjectContent<T>): string[];
	static attributeNamesMatchingMask<T extends CoreObjectType>(object: ObjectContent<T>, masksString: GroupString): string[];
	renameAttribute(oldName: string, newName: string): void;
	static renameAttribute<T extends CoreObjectType>(object: ObjectContent<T>, oldName: string, newName: string): void;
	deleteAttribute(name: string): void;
	static deleteAttribute<T extends CoreObjectType>(object: ObjectContent<T>, attribName: string): void;
	static position(object: ObjectContent<CoreObjectType>, target: Vector3): void;
	position(target: Vector3): Vector3;
	static boundingBox(object: ObjectContent<CoreObjectType>, target: Box3): void;
	boundingBox(target: Box3): void;
	static geometryBoundingBox(object: ObjectContent<CoreObjectType>, target: Box3): void;
	geometryBoundingBox(target: Box3): void;
	static boundingSphere(object: ObjectContent<CoreObjectType>, target: Sphere): void;
	boundingSphere(target: Sphere): void;
	static geometryBoundingSphere(object: ObjectContent<CoreObjectType>, target: Sphere): void;
	geometryBoundingSphere(target: Sphere): void;
	static attribValue<T extends CoreObjectType>(object: ObjectContent<T>, attribName: string, index?: number, target?: Color | Vector2 | Vector3 | Vector4): AttribValue | undefined;
	static stringAttribValue<T extends CoreObjectType>(object: ObjectContent<T>, attribName: string, index?: number): string | null;
	attribValue(attribName: string, target?: Vector2 | Vector3 | Vector4): AttribValue | undefined;
	stringAttribValue(name: string): string | null;
	name(): string;
	humanType(): string;
	attribTypes(): PolyDictionary<AttribType>;
	static attribType<T extends CoreObjectType>(object: ObjectContent<T>, attribName: string): AttribType;
	attribType(attribName: string): AttribType;
	attribSizes(): PolyDictionary<AttribSize>;
	static attribSize<T extends CoreObjectType>(object: ObjectContent<T>, attribName: string): AttribSize | null;
	attribSize(attribName: string): AttribSize | null;
	static objectData<T extends CoreObjectType>(object: ObjectContent<T>): ObjectData;
	clone(): BaseCoreObject<T>;
	static clone<T extends CoreObjectType>(srcObject: ObjectContent<T>): ObjectContent<T>;
	static applyMatrix(object: ObjectContent<CoreObjectType>, matrix: Matrix4, transformTargetType: TransformTargetType, transformSpace: ObjectTransformSpace, transformMode: ObjectTransformMode): void;
	static mergeCompact(options: MergeCompactOptions): void;
	groupCollection(): EntityGroupCollection;
	relatedPrimitives(): CorePrimitive<CoreObjectType>[];
	relatedVertices(): CoreVertex<CoreObjectType>[];
	relatedPoints(): TypedCorePoint<CoreObjectType>[];
	relatedEntities(attribClass: AttribClass, coreGroup: CoreGroup, target: CoreEntity[]): void;
}
declare abstract class CorePrimitive<T extends CoreObjectType> extends CoreEntity {
	protected _object?: ObjectContent<T>;
	constructor(object?: ObjectContent<T>, index?: number);
	object(): ObjectContent<T> | undefined;
	builder<T extends CoreObjectType>(): ObjectBuilder<T> | undefined;
	static primitivesCount<T extends CoreObjectType>(object: ObjectContent<T>): number;
	static addAttribute<T extends CoreObjectType>(object: ObjectContent<T>, attribName: string, attribute: BasePrimitiveAttribute): void;
	static addNumericAttribute<T extends CoreObjectType>(object: ObjectContent<T>, attribName: string, size?: AttribSize, defaultValue?: NumericAttribValue): void;
	static attributes<T extends CoreObjectType>(object?: ObjectContent<T>): PrimitiveAttributesDict | undefined;
	attributes(): PrimitiveAttributesDict | undefined;
	static attribute<T extends CoreObjectType>(object: ObjectContent<T>, attribName: string): BasePrimitiveAttribute | undefined;
	attribute(attribName: string): BasePrimitiveAttribute | undefined;
	static renameAttribute<T extends CoreObjectType>(object: ObjectContent<T>, oldName: string, newName: string): void;
	static deleteAttribute<T extends CoreObjectType>(object: ObjectContent<T>, attribName: string): void;
	static attribSize<T extends CoreObjectType>(object: ObjectContent<T>, attribName: string): number;
	attribSize(attribName: string): number;
	static hasAttribute<T extends CoreObjectType>(object: ObjectContent<T>, attribName: string): boolean;
	hasAttribute(attribName: string): boolean;
	static attributeNames<T extends CoreObjectType>(object?: ObjectContent<T>): string[];
	static attributeNamesMatchingMask<T extends CoreObjectType>(object: ObjectContent<T>, masksString: GroupString): string[];
	static attribValue<T extends CoreObjectType>(object: ObjectContent<T>, index: number, attribName: string, target?: Vector2 | Vector3 | Vector4): AttribValue;
	attribValue(attribName: string, target?: Vector2 | Vector3 | Vector4): AttribValue;
	attribValueNumber(attribName: string): string | number;
	attribValueVector2(attribName: string, target: Vector2): Vector2 | undefined;
	attribValueVector3(attribName: string, target: Vector3): Vector3 | undefined;
	attribValueVector4(attribName: string, target: Vector4): Vector4 | undefined;
	static attribType<T extends CoreObjectType>(object: ObjectContent<T> | undefined, attribName: string): AttribType;
	attribType(attribName: string): AttribType;
	static stringAttribValue<T extends CoreObjectType>(object: ObjectContent<T>, index: number, attribName: string): AttribValue;
	stringAttribValue(attribName: string): string;
	setPosition(newPosition: Vector3): void;
	setNormal(newNormal: Vector3): void;
	static computeVertexNormalsIfAttributeVersionChanged<T extends CoreObjectType>(object: ObjectContent<T>): void;
	setAttribValue(attribName: string, value: NumericAttribValue | string): void;
	setAttribValueFromNumber(attribName: string, value: number): void;
	setAttribValueFromVector2(attribName: string, value: Vector2): void;
	setAttribValueFromVector3(attribName: string, value: Vector3): void;
	setAttribValueFromVector4(attribName: string, value: Vector4): void;
	relatedObjects(): BaseCoreObject<CoreObjectType>[];
	relatedVertices(): CoreVertex<CoreObjectType>[];
	relatedPoints(): TypedCorePoint<CoreObjectType>[];
	relatedEntities(attribClass: AttribClass, coreGroup: CoreGroup, target: CoreEntity[]): void;
}
declare abstract class CoreVertex<T extends CoreObjectType> extends CoreEntity {
	protected _object?: ObjectContent<T>;
	constructor(object?: ObjectContent<T>, index?: number);
	object(): ObjectContent<T> | undefined;
	builder<T extends CoreObjectType>(): ObjectBuilder<T> | undefined;
	static addAttribute<T extends CoreObjectType>(object: ObjectContent<T>, attribName: string, attribute: BaseVertexAttribute): void;
	static addNumericAttribute<T extends CoreObjectType>(object: ObjectContent<T>, attribName: string, size?: AttribSize, defaultValue?: NumericAttribValue): void;
	static verticesCount<T extends CoreObjectType>(object: ObjectContent<T>): number;
	static attributes<T extends CoreObjectType>(object?: ObjectContent<T>): VertexAttributesDict | undefined;
	attributes(): VertexAttributesDict | undefined;
	static attribute<T extends CoreObjectType>(object: ObjectContent<T>, attribName: string): BaseVertexAttribute | undefined;
	attribute(attribName: string): BaseVertexAttribute | undefined;
	static indexAttribute<T extends CoreObjectType>(object: ObjectContent<T>): BufferAttribute | undefined | null;
	static setIndexAttribute<T extends CoreObjectType>(object: ObjectContent<T>, index: BufferAttribute | number[]): BufferAttribute | undefined;
	static renameAttribute<T extends CoreObjectType>(object: ObjectContent<T>, oldName: string, newName: string): void;
	static deleteAttribute<T extends CoreObjectType>(object: ObjectContent<T>, attribName: string): void;
	static attribSize<T extends CoreObjectType>(object: ObjectContent<T>, attribName: string): number;
	attribSize(attribName: string): number;
	static hasAttribute<T extends CoreObjectType>(object: ObjectContent<T>, attribName: string): boolean;
	hasAttribute(attribName: string): boolean;
	static attributeNames<T extends CoreObjectType>(object?: ObjectContent<T>): string[];
	static attributeNamesMatchingMask<T extends CoreObjectType>(object: ObjectContent<T>, masksString: GroupString): string[];
	static attribValue<T extends CoreObjectType>(object: ObjectContent<T>, index: number, attribName: string, target?: Vector2 | Vector3 | Vector4): AttribValue;
	attribValue(attribName: string, target?: Vector2 | Vector3 | Vector4): AttribValue;
	attribValueNumber(attribName: string): string | number;
	attribValueVector2(attribName: string, target: Vector2): Vector2 | undefined;
	attribValueVector3(attribName: string, target: Vector3): Vector3 | undefined;
	attribValueVector4(attribName: string, target: Vector4): Vector4 | undefined;
	static attribType<T extends CoreObjectType>(object: ObjectContent<T> | undefined, attribName: string): AttribType;
	attribType(attribName: string): AttribType;
	static stringAttribValue<T extends CoreObjectType>(object: ObjectContent<T>, index: number, attribName: string): AttribValue;
	stringAttribValue(attribName: string): string;
	position(target: Vector3): Vector3;
	setPosition(newPosition: Vector3): void;
	normal(target: Vector3): Vector3;
	setNormal(newNormal: Vector3): void;
	setAttribValue(attribName: string, value: NumericAttribValue | string): void;
	setAttribValueFromNumber(attribName: string, value: number): void;
	setAttribValueFromVector2(attribName: string, value: Vector2): void;
	setAttribValueFromVector3(attribName: string, value: Vector3): void;
	setAttribValueFromVector4(attribName: string, value: Vector4): void;
	relatedObjects(): BaseCoreObject<CoreObjectType>[];
	relatedPrimitives<T extends CoreObjectType>(): CorePrimitive<T>[];
	relatedPoints<T extends CoreObjectType>(): TypedCorePoint<T>[];
	relatedEntities(attribClass: AttribClass, coreGroup: CoreGroup, target: CoreEntity[]): void;
}
declare abstract class TypedCorePoint<T extends CoreObjectType> extends CoreEntity {
	protected _object?: ObjectContent<T>;
	constructor(object?: ObjectContent<T>, index?: number);
	object(): ObjectContent<T> | undefined;
	builder<T extends CoreObjectType>(): ObjectBuilder<T> | undefined;
	static addAttribute<T extends CoreObjectType>(object: ObjectContent<T>, attribName: string, attribute: BufferAttribute): void;
	static pointsCount<T extends CoreObjectType>(object: ObjectContent<T>): number;
	static attributes<T extends CoreObjectType>(object?: ObjectContent<T>): PointAttributesDict | undefined;
	attributes(): PointAttributesDict | undefined;
	static attribute<T extends CoreObjectType>(object: ObjectContent<T>, attribName: string): BufferAttribute | InterleavedBufferAttribute | undefined;
	attribute(attribName: string): BufferAttribute | InterleavedBufferAttribute | undefined;
	static attribSize<T extends CoreObjectType>(object: ObjectContent<T>, attribName: string): number;
	attribSize(attribName: string): number;
	static hasAttribute<T extends CoreObjectType>(object: ObjectContent<T>, attribName: string): boolean;
	hasAttribute(attribName: string): boolean;
	static userDataAttribs<T extends CoreObjectType>(object?: ObjectContent<T>): Record<string, string[]>;
	userDataAttribs(): Record<string, string[]>;
	static userDataAttrib<T extends CoreObjectType>(object: ObjectContent<T> | undefined, attribName: string): string[] | undefined;
	userDataAttrib(name: string): string[];
	static attributeNames<T extends CoreObjectType>(object?: ObjectContent<T>): string[];
	static attributeNamesMatchingMask<T extends CoreObjectType>(object: ObjectContent<T>, masksString: GroupString): string[];
	static indexedAttributeNames<T extends CoreObjectType>(object?: ObjectContent<T>): string[];
	indexedAttributeNames(): string[];
	static isAttribIndexed<T extends CoreObjectType>(object: ObjectContent<T> | undefined, attribName: string): boolean;
	isAttribIndexed(name: string): boolean;
	static setIndexedAttributeValues<T extends CoreObjectType>(object: ObjectContent<T> | undefined, attribName: string, values: string[]): void;
	setIndexedAttributeValues(attribName: string, values: string[]): void;
	static setIndexedAttribute<T extends CoreObjectType>(object: ObjectContent<T> | undefined, attribName: string, values: string[], indices: number[]): void;
	setIndexedAttribute(attribName: string, values: string[], indices: number[]): void;
	static indexedAttribValue<T extends CoreObjectType>(object: ObjectContent<T> | undefined, index: number, attribName: string): string | null;
	indexedAttribValue(attribName: string): string | null;
	static stringAttribValue<T extends CoreObjectType>(object: ObjectContent<T>, index: number, attribName: string): string | null;
	stringAttribValue(attribName: string): string | null;
	static attribValueIndex<T extends CoreObjectType>(object: ObjectContent<T> | undefined, index: number, attribName: string): number;
	attribValueIndex(attribName: string): number;
	static attribType<T extends CoreObjectType>(object: ObjectContent<T> | undefined, attribName: string): AttribType;
	attribType(attribName: string): AttribType;
	isStringAttribute(attribName: string): boolean;
	setAttribIndex(attribName: string, newValueIndex: number): number | undefined;
	static renameAttribute<T extends CoreObjectType>(object: ObjectContent<T>, oldName: string, newName: string): void;
	static deleteAttribute<T extends CoreObjectType>(object: ObjectContent<T>, attribName: string): void;
	static attribValue<T extends CoreObjectType>(object: ObjectContent<T>, index: number, attribName: string, target?: Vector2 | Vector3 | Vector4): AttribValue;
	attribValue(attribName: string, target?: Vector2 | Vector3 | Vector4): AttribValue;
	attribValueNumber(attribName: string): number;
	attribValueVector2(attribName: string, target: Vector2): Vector2 | undefined;
	attribValueVector3(attribName: string, target: Vector3): Vector3 | undefined;
	attribValueVector4(attribName: string, target: Vector4): Vector4 | undefined;
	position(target: Vector3): Vector3;
	setPosition(newPosition: Vector3): void;
	normal(target: Vector3): Vector3;
	setNormal(newNormal: Vector3): void;
	static computeNormals<T extends CoreObjectType>(object: ObjectContent<T>): void;
	setAttribValue(attribName: string, value: NumericAttribValue | string): void;
	setAttribValueFromNumber(attribName: string, value: number): void;
	setAttribValueFromVector2(attribName: string, value: Vector2): void;
	setAttribValueFromVector3(attribName: string, value: Vector3): void;
	setAttribValueFromVector4(attribName: string, value: Vector4): void;
	static addAttributeFromAttribData<T extends CoreObjectType>(object: ObjectContent<T>, attribName: string, attribData: CoreAttributeData): void;
	static addNumericAttribute<T extends CoreObjectType>(object: ObjectContent<T>, attribName: string, size?: AttribSize, defaultValue?: NumericAttribValue): void;
	static markAttribAsNeedsUpdate<T extends CoreObjectType>(object: ObjectContent<T>, attribName: string): void;
	relatedVertices<T extends CoreObjectType>(): CoreVertex<T>[];
	relatedPrimitives<T extends CoreObjectType>(): CorePrimitive<T>[];
	relatedEntities(attribClass: AttribClass, coreGroup: CoreGroup, target: CoreEntity[]): void;
}
type CorePoint = TypedCorePoint<CoreObjectType>;
declare class TypedSopNode<K extends NodeParamsConfig> extends TypedNode<NodeContext.SOP, K> {
	static context(): NodeContext;
	readonly flags: FlagsControllerDBO;
	dataType(): string;
	initializeBaseNode(): void;
	setCoreGroup(coreGroup: CoreGroup): void;
	setObject(object: ObjectContent<CoreObjectType>): void;
	setObjects(objects: ObjectContent<CoreObjectType>[]): void;
	setGeometry(geometry: BufferGeometry, type?: ObjectType): void;
	setGeometries(geometries: BufferGeometry[], type?: ObjectType): void;
	protected _setContainerObjects(objects: ObjectContent<CoreObjectType>[]): void;
	static createObject<OT extends ObjectType>(geometry: BufferGeometry, type: OT, material?: Material): ObjectByObjectType[OT];
	createObject<OT extends ObjectType>(geometry: BufferGeometry, type: OT, material?: Material): ObjectByObjectType[OT];
	static createIndexIfNone(geometry: BufferGeometry): void;
	protected _createIndexIfNone(geometry: BufferGeometry): void;
}
type BaseSopNodeType = TypedSopNode<NodeParamsConfig>;
declare class CadObject<T extends CadGeometryType> implements ObjectContent<CoreObjectType.CAD> {
	private _geometry;
	private _type;
	visible: boolean;
	get geometry(): CadGeometry;
	get type(): T;
	userData: {};
	name: string;
	castShadow: boolean;
	receiveShadow: boolean;
	renderOrder: number;
	frustumCulled: boolean;
	matrixAutoUpdate: boolean;
	material: Material | undefined;
	children: ObjectContent<CoreObjectType.CAD>[];
	parent: ObjectContent<CoreObjectType.CAD> | null;
	constructor(_geometry: CadTypeMap[T], _type: T);
	setGeometry<TE extends CadGeometryType>(geometry: CadTypeMap[TE], type: TE): void;
	private _validate;
	cadGeometry(): CadTypeMap[T];
	dispose(): void;
	applyMatrix4(matrix: Matrix4): void;
	add(...object: ObjectContent<CoreObjectType>[]): void;
	remove(...object: ObjectContent<CoreObjectType>[]): void;
	dispatchEvent(event: {
		type: string;
	}): void;
	traverse(callback: (object: CadObject<T>) => any): void;
	clone(): CadObject<T>;
	toObject3D(tesselationParams: CADTesselationParams, displayNode: BaseSopNodeType): Object3D | Object3D[] | undefined;
	static toObject3D<T extends CadGeometryType>(cadObject: CadObject<T>, type: T, tesselationParams: CADTesselationParams, displayNode: BaseSopNodeType): Object3D | Object3D[] | undefined;
	boundingBox(target: Box3): void;
}
declare class CsgObject<T extends CsgGeometryType> implements ObjectContent<CoreObjectType.CSG> {
	private _geometry;
	visible: boolean;
	get geometry(): CsgGeometry;
	get type(): T;
	userData: {};
	name: string;
	castShadow: boolean;
	receiveShadow: boolean;
	renderOrder: number;
	frustumCulled: boolean;
	matrixAutoUpdate: boolean;
	material: Material | undefined;
	children: ObjectContent<CoreObjectType.CSG>[];
	parent: ObjectContent<CoreObjectType.CSG> | null;
	private _type;
	constructor(_geometry: CsgTypeMap[T]);
	setGeometry<TE extends CsgGeometryType>(geometry: CsgTypeMap[TE]): void;
	private _validate;
	csgGeometry(): CsgTypeMap[T];
	dispose(): void;
	applyMatrix4(matrix: Matrix4): void;
	add(...object: ObjectContent<CoreObjectType>[]): void;
	remove(...object: ObjectContent<CoreObjectType>[]): void;
	dispatchEvent(event: {
		type: string;
	}): void;
	traverse(callback: (object: CsgObject<T>) => any): void;
	clone(): CsgObject<T>;
	toObject3D(tesselationParams: CSGTesselationParams): Object3D | Object3D[] | undefined;
	static toObject3D<T extends CsgGeometryType>(csgObject: CsgObject<T>, type: T, tesselationParams: CSGTesselationParams): Object3D | Object3D[] | undefined;
	boundingBox(target: Box3): void;
	boundingSphere(target: Sphere): void;
}
declare enum QUADObjectType {
	DEFAULT = "Quad"
}
interface QUADTesselationParams {
	triangles: boolean;
	wireframe: boolean;
}
interface QUADOBJTesselationParams {
	QUADTriangles: boolean;
	QUADWireframe: boolean;
}
declare class QuadObject implements ObjectContent<CoreObjectType.QUAD> {
	private _geometry;
	visible: boolean;
	get geometry(): QuadGeometry;
	get type(): QUADObjectType;
	userData: {};
	name: string;
	castShadow: boolean;
	receiveShadow: boolean;
	renderOrder: number;
	frustumCulled: boolean;
	matrixAutoUpdate: boolean;
	material: Material | undefined;
	children: ObjectContent<CoreObjectType.QUAD>[];
	parent: ObjectContent<CoreObjectType.QUAD> | null;
	private _type;
	constructor(_geometry: QuadGeometry);
	SDFGeometry(): QuadGeometry;
	dispose(): void;
	applyMatrix4(matrix: Matrix4): void;
	add(...object: ObjectContent<CoreObjectType>[]): void;
	remove(...object: ObjectContent<CoreObjectType>[]): void;
	dispatchEvent(event: {
		type: string;
	}): void;
	traverse(callback: (object: QuadObject) => any): void;
	clone(): QuadObject;
	toObject3D(tesselationParams: QUADTesselationParams): Object3D | Object3D[] | undefined;
	boundingBox(target: Box3): void;
	boundingSphere(target: Sphere): void;
}
declare class TetObject implements ObjectContent<CoreObjectType.TET> {
	private _geometry;
	visible: boolean;
	get geometry(): TetGeometry;
	get type(): CoreObjectType;
	parent: null;
	children: never[];
	userData: {};
	name: string;
	castShadow: boolean;
	receiveShadow: boolean;
	renderOrder: number;
	frustumCulled: boolean;
	matrixAutoUpdate: boolean;
	material: Material | undefined;
	constructor(_geometry: TetGeometry);
	setGeometry(geometry: TetGeometry): void;
	tetGeometry(): TetGeometry;
	dispose(): void;
	applyMatrix4(matrix: Matrix4): void;
	add(...object: ObjectContent<CoreObjectType>[]): void;
	remove(...object: ObjectContent<CoreObjectType>[]): void;
	dispatchEvent(event: {
		type: string;
	}): void;
	traverse(callback: (object: TetObject) => any): void;
	clone(): TetObject;
	toObject3D(tesselationParams: TetTesselationParams): Object3D | Object3D[] | undefined;
	static toObject3D(tetObject: TetObject, tesselationParams: TetTesselationParams): Object3D | Object3D[] | undefined;
	boundingBox(target: Box3): void;
	boundingSphere(target: Sphere): void;
}
declare class ThreejsCoreObject extends BaseCoreObject<CoreObjectType.THREEJS> {
	protected _object: Object3D;
	constructor(_object: Object3D, index: number);
	humanType(): string;
	object(): Object3D<Event>;
	geometry(): BufferGeometry | null;
	static objectData(object: Object3D): ObjectData;
	static position(object: Object3D, target: Vector3): void;
	static boundingBox(object: Object3D, target: Box3): void;
	static geometryBoundingBox(object: Object3D, target: Box3): void;
	static boundingSphere(object: Object3D, target: Sphere): void;
	static geometryBoundingSphere(object: Object3D, target: Sphere): void;
	static clone(srcObject: Object3D): Object3D<Event>;
	static parallelTraverse(a: Object3D, b: Object3D, callback: (a: Object3D, b: Object3D) => void): void;
	static applyMatrix(object: Object3D, matrix: Matrix4, transformTargetType: TransformTargetType, transformSpace: ObjectTransformSpace, transformMode: ObjectTransformMode): void;
	static mergeCompact(options: MergeCompactOptions): void;
	relatedPrimitives(): CorePrimitive<CoreObjectType>[];
}
// @ts-ignore
type AttributeDictionary = PolyDictionary<AttribValue>;
interface Object3DWithGeometry extends Object3D {
	geometry: BufferGeometry;
}
declare class CoreGroup extends CoreEntity {
	private _timestamp;
	private _allObjects;
	constructor();
	dispose(): void;
	geometry(): null;
	builder<T extends CoreObjectType>(): ObjectBuilder<T> | undefined;
	timestamp(): number | undefined;
	touch(): void;
	resetBoundingBox(): void;
	clone(): CoreGroup;
	setAllObjects(objects: ObjectContent<CoreObjectType>[]): void;
	allObjects(): ObjectContent<CoreObjectType>[];
	allCoreObjects(): BaseCoreObject<CoreObjectType>[];
	cadObjects(): CadObject<CadGeometryType>[] | undefined;
	cadObjectsWithShape(): CadObject<CadGeometryTypeShape>[] | undefined;
	cadCoreObjects(): BaseCoreObject<CoreObjectType.CAD>[] | undefined;
	csgObjects(): CsgObject<CsgGeometryType>[] | undefined;
	csgCoreObjects(): BaseCoreObject<CoreObjectType.CSG>[] | undefined;
	quadObjects(): QuadObject[] | undefined;
	quadCoreObjects(): BaseCoreObject<CoreObjectType.QUAD>[] | undefined;
	threejsOrQuadObjects(): Array<Object3D | QuadObject>;
	threejsOrQuadCoreObjects(): BaseCoreObject<CoreObjectType.QUAD>[];
	tetObjects(): TetObject[] | undefined;
	tetCoreObjects(): BaseCoreObject<CoreObjectType>[] | undefined;
	threejsObjects(): Object3D[];
	threejsObjectsWithGeo(): Object3DWithGeometry[];
	threejsCoreObjects(): ThreejsCoreObject[];
	geometries(): BufferGeometry[];
	points(): TypedCorePoint<CoreObjectType>[];
	pointsCount(): number;
	totalPointsCount(): number;
	pointsFromGroup(group: GroupString): TypedCorePoint<CoreObjectType>[];
	pointAttribNames(): string[];
	hasPointAttrib(attribName: string): boolean;
	pointAttribType(attribName: string): AttribType;
	pointAttribNamesMatchingMask(masksString: GroupString): string[];
	pointAttribSizes(): Record<string, number>;
	pointAttribSize(attribName: string): number;
	static _fromObjects(objects: Object3D[]): CoreGroup;
	objectAttribTypesByName(): PolyDictionary<AttribType[]>;
	objectAttribNames(): string[];
	objectAttribNamesMatchingMask(masksString: GroupString): string[];
	objectAttribSizesByName(): PolyDictionary<AttribSize[]>;
	renameAttribute(oldName: string, newName: string): void;
	attribNamesMatchingMask(masksString: GroupString): string[];
	hasAttribute(attribName: string): boolean;
	private _attributes;
	addAttribute(attribName: string, attribValue: AttribValue): void;
	addNumericAttribute(attribName: string, size?: AttribSize, defaultValue?: NumericAttribValue): 0 | Vector3 | Vector2 | Vector4 | undefined;
	deleteAttribute(name: string): void;
	attribValue(attribName: string): AttribValue;
	attribNames(): string[];
	attribType(name: string): AttribType;
	attribSizes(): PolyDictionary<AttribSize>;
	attribSize(name: string): AttribSize | null;
	attributes(): AttributeDictionary;
	private _createAttributesDictionaryIfNone;
	setAttribValue(attribName: string, attribValue: AttribValue | string): void;
	stringAttribValue(attribName: string): string | null;
	position(target: Vector3): Vector3;
	attributeNames(): string[];
	attributeNamesMatchingMask(masksString: GroupString): string[];
	relatedObjects(): BaseCoreObject<CoreObjectType>[];
	relatedPrimitives(): CorePrimitive<CoreObjectType>[];
	relatedVertices(): CoreVertex<CoreObjectType>[];
	relatedPoints(): TypedCorePoint<CoreObjectType>[];
	relatedEntities(attribClass: AttribClass, coreGroup: CoreGroup, target: CoreEntity[]): void;
	objectsData(): ObjectData[];
	boundingBox(target: Box3): void;
	static geometryFromObject(object: Object3D): BufferGeometry | null;
}
declare class ParsedTree {
	private _param;
	private _node;
	private _errorMessage;
	constructor(_param: BaseParamType);
	node(): Expression | undefined;
	errorMessage(): string | undefined;
	parseExpression(string: string): void;
	parseExpressionForStringParam(string: string): void;
	private reset;
}
declare abstract class BaseTraverser {
	param: BaseParamType;
	private _errorMessage;
	constructor(param: BaseParamType);
	protected clearError(): void;
	protected setError(message: string): void;
	protected _set_error_from_error_bound: (error: Error | string) => void;
	private _set_error_from_error;
	isErrored(): boolean;
	errorMessage(): string | undefined;
	reset(): void;
	traverse_node(node: Expression): string | undefined;
	protected traverse_BinaryExpression(node: BinaryExpression): string;
	protected traverse_MemberExpression(node: MemberExpression): string;
	protected traverse_ConditionalExpression(node: ConditionalExpression): string;
	protected traverse_Compound(node: Compound): string;
	protected traverse_Literal(node: Literal): string;
	protected abstract traverse_Identifier(node: Identifier): string | undefined;
	protected abstract traverse_CallExpression(node: CallExpression): string | undefined;
	protected abstract traverse_UnaryExpression(node: UnaryExpression): string;
}
type NodeOrParam = BaseNodeType | BaseParamType;
interface PathElement {
	path: string;
	node: NodeOrParam;
}
interface NamedNode {
	name: string;
	node: NodeOrParam;
}
declare class DecomposedPath {
	private _index;
	private _pathElements;
	private _namedNodes;
	private _graphNodeIds;
	private _nodeElementByGraphNodeId;
	private _absolutePath;
	constructor();
	reset(): void;
	addNamedNode(namedNode: NamedNode): void;
	addPathElement(pathElement: PathElement): void;
	namedGraphNodes(): (NamedNode | null)[];
	namedNodes(target: BaseNodeType[]): BaseNodeType[];
	updateFromNameChange(node: NodeOrParam): void;
	toPath(): string;
	toAbsolutePath(): string;
}
type GsapCoreTimeline = gsap.core.Timeline;
declare abstract class TypedNumericParam<T extends ParamType> extends TypedParam<T> {
	isNumeric(): boolean;
	isDefault(): boolean;
	protected _prefilterInvalidRawInput(raw_input: any): ParamInitValuesTypeMap[T];
	protected processRawInput(): void;
	protected processComputation(): Promise<void>;
	private _updateValue;
}
declare class NodeBaseState<NC extends NodeContext> {
	protected node: TypedNode<NC, any>;
	constructor(node: TypedNode<NC, any>);
}
declare class NodeErrorState<NC extends NodeContext> extends NodeBaseState<NC> {
	private _message;
	set(message: string | undefined): void;
	message(): string | undefined;
	clear(): void;
	active(): boolean;
	protected onUpdate(): void;
}
declare class ParamErrorState {
	private param;
	private _message;
	constructor(param: BaseParamType);
	set(message: string | undefined): void;
	message(): string | undefined;
	clear(): void;
	active(): boolean;
}
declare class BooleanParam extends TypedNumericParam<ParamType.BOOLEAN> {
	static type(): ParamType;
	defaultValueSerialized(): string | boolean;
	rawInputSerialized(): string | number | boolean;
	valueSerialized(): boolean;
	protected _copyValue(param: BooleanParam): void;
	static areRawInputEqual(raw_input1: ParamInitValuesTypeMap[ParamType.BOOLEAN], raw_input2: ParamInitValuesTypeMap[ParamType.BOOLEAN]): boolean;
	static areValuesEqual(val1: ParamValuesTypeMap[ParamType.BOOLEAN], val2: ParamValuesTypeMap[ParamType.BOOLEAN]): boolean;
	convert(raw_val: ParamInitValuesTypeMap[ParamType.BOOLEAN]): boolean | null;
}
declare class ButtonParam extends TypedParam<ParamType.BUTTON> {
	static type(): ParamType;
	defaultValueSerialized(): null;
	rawInputSerialized(): null;
	valueSerialized(): null;
	protected _copyValue(param: ButtonParam): void;
	static areRawInputEqual(raw_input1: ParamInitValuesTypeMap[ParamType.BUTTON], raw_input2: ParamInitValuesTypeMap[ParamType.BUTTON]): boolean;
	static areValuesEqual(val1: ParamValuesTypeMap[ParamType.BUTTON], val2: ParamValuesTypeMap[ParamType.BUTTON]): boolean;
	pressButton(): Promise<void>;
}
declare class FolderParam extends TypedParam<ParamType.FOLDER> {
	static type(): ParamType;
	defaultValueSerialized(): null;
	rawInputSerialized(): null;
	valueSerialized(): null;
	protected _copyValue(param: FolderParam): void;
	static areRawInputEqual(raw_input1: ParamInitValuesTypeMap[ParamType.FOLDER], raw_input2: ParamInitValuesTypeMap[ParamType.FOLDER]): boolean;
	static areValuesEqual(val1: ParamValuesTypeMap[ParamType.FOLDER], val2: ParamValuesTypeMap[ParamType.FOLDER]): boolean;
}
declare class IntegerParam extends TypedNumericParam<ParamType.INTEGER> {
	static type(): ParamType;
	defaultValueSerialized(): StringOrNumber;
	rawInputSerialized(): StringOrNumber;
	valueSerialized(): number;
	protected _copyValue(param: IntegerParam): void;
	protected _prefilterInvalidRawInput(raw_input: any): ParamInitValuesTypeMap[ParamType.INTEGER];
	static areRawInputEqual(raw_input1: ParamInitValuesTypeMap[ParamType.INTEGER], raw_input2: ParamInitValuesTypeMap[ParamType.INTEGER]): boolean;
	static areValuesEqual(val1: ParamValuesTypeMap[ParamType.INTEGER], val2: ParamValuesTypeMap[ParamType.INTEGER]): boolean;
	static convert(raw_val: ParamInitValuesTypeMap[ParamType.INTEGER]): number | null;
	convert(raw_val: ParamInitValuesTypeMap[ParamType.INTEGER]): number | null;
}
declare abstract class TypedStringParam<T extends ParamType.STRING | ParamType.NODE_PATH | ParamType.PARAM_PATH> extends TypedParam<T> {
	protected abstract _assignValue(value: ParamValuesTypeMap[T] | string): void;
	expressionParsedAsString(): boolean;
	protected processRawInput(): void;
	protected abstract processRawInputWithoutExpression(): void;
	protected processComputation(): Promise<void>;
}
declare abstract class TypedPathParam<T extends ParamType.NODE_PATH | ParamType.PARAM_PATH> extends TypedStringParam<T> {
	readonly decomposedPath: DecomposedPath;
	dispose(): void;
	abstract notifyPathRebuildRequired(node: BaseNodeType | BaseParamType): void;
	abstract notifyTargetParamOwnerParamsUpdated(node: BaseNodeType | BaseParamType): void;
	protected abstract _findTarget(): void;
	protected _handleReferences(node: BaseNodeType | BaseParamType | null, path: string): void;
	protected processComputation(): Promise<void>;
	protected processRawInputWithoutExpression(): void;
	protected _setValuePathAndFindTarget(path: string, setDirty: boolean): void;
}
declare class ParamPathParam extends TypedPathParam<ParamType.PARAM_PATH> {
	static type(): ParamType;
	protected _initializeParam(): void;
	defaultValueSerialized(): string;
	rawInputSerialized(): string;
	valueSerialized(): string;
	protected _copyValue(param: ParamPathParam): void;
	static areRawInputEqual(raw_input1: ParamInitValuesTypeMap[ParamType.PARAM_PATH], raw_input2: ParamInitValuesTypeMap[ParamType.PARAM_PATH]): boolean;
	static areValuesEqual(val1: ParamValuesTypeMap[ParamType.PARAM_PATH], val2: ParamValuesTypeMap[ParamType.PARAM_PATH]): boolean;
	isDefault(): boolean;
	setParam(param: BaseParamType): void;
	protected _assignValue(value: ParamValuesTypeMap[ParamType.PARAM_PATH] | string): void;
	convert(rawVal: any): ParamValuesTypeMap[ParamType.PARAM_PATH] | null;
	protected _findTarget(): void;
	private _assignFoundParam;
	notifyPathRebuildRequired(param: BaseParamType): void;
	notifyTargetParamOwnerParamsUpdated(node: BaseNodeType): void;
	private _onResolvedParamDisposeBound;
	private _onResolvedParamDispose;
}
interface SetNodeOptions {
	relative: boolean;
}
declare class NodePathParam extends TypedPathParam<ParamType.NODE_PATH> {
	static type(): ParamType;
	protected _initializeParam(): void;
	defaultValueSerialized(): string;
	rawInputSerialized(): string;
	valueSerialized(): string;
	protected _copyValue(param: NodePathParam): void;
	static areRawInputEqual(raw_input1: ParamInitValuesTypeMap[ParamType.NODE_PATH], raw_input2: ParamInitValuesTypeMap[ParamType.NODE_PATH]): boolean;
	static areValuesEqual(val1: ParamValuesTypeMap[ParamType.NODE_PATH], val2: ParamValuesTypeMap[ParamType.NODE_PATH]): boolean;
	isDefault(): boolean;
	setNode(node: BaseNodeType, options?: SetNodeOptions): void;
	protected _assignValue(value: ParamValuesTypeMap[ParamType.NODE_PATH] | string): void;
	convert(rawVal: any): ParamValuesTypeMap[ParamType.NODE_PATH] | null;
	protected _findTarget(): void;
	private _assignFoundNode;
	private _expectedContext;
	private _isNodeExpectedContext;
	private _expectedNodeTypes;
	private _isNodeExpectedType;
	notifyPathRebuildRequired(node: BaseNodeType): void;
	notifyTargetParamOwnerParamsUpdated(node: BaseNodeType): void;
}
declare class RampParam extends TypedParam<ParamType.RAMP> {
	static type(): ParamType;
	private _rampInterpolant;
	private _textureData;
	private _rampTexture;
	static DEFAULT_VALUE: RampValue;
	static DEFAULT_VALUE_JSON: RampValueJson;
	defaultValueSerialized(): RampValueJson;
	protected _cloneRawInput(raw_input: ParamInitValuesTypeMap[ParamType.RAMP]): RampValueJson | RampValue;
	rawInputSerialized(): RampValueJson;
	valueSerialized(): RampValueJson;
	protected _copyValue(param: RampParam): void;
	static areRawInputEqual(raw_input1: ParamInitValuesTypeMap[ParamType.RAMP], raw_input2: ParamInitValuesTypeMap[ParamType.RAMP]): boolean;
	static areValuesEqual(val1: ParamValuesTypeMap[ParamType.RAMP], val2: ParamValuesTypeMap[ParamType.RAMP]): boolean;
	isDefault(): boolean;
	protected processRawInput(): void;
	hasExpression(): boolean;
	private _resetRampInterpolant;
	rampTexture(): DataTexture;
	private _updateRampTexture;
	private _updateRampTextureData;
	interpolant(): CubicInterpolant;
	private _createInterpolant;
	valueAtPosition(position: number): number;
}
declare class StringParam extends TypedStringParam<ParamType.STRING> {
	static type(): ParamType;
	defaultValueSerialized(): string;
	protected _cloneRawInput(raw_input: ParamInitValuesTypeMap[ParamType.STRING]): string;
	rawInputSerialized(): string;
	valueSerialized(): string;
	protected _copyValue(param: StringParam): void;
	static areRawInputEqual(raw_input1: ParamInitValuesTypeMap[ParamType.STRING], raw_input2: ParamInitValuesTypeMap[ParamType.STRING]): boolean;
	static areValuesEqual(val1: ParamValuesTypeMap[ParamType.STRING], val2: ParamValuesTypeMap[ParamType.STRING]): boolean;
	isDefault(): boolean;
	convert(rawVal: any): string;
	rawInput(): string;
	protected _assignValue(value: string): void;
	protected processRawInputWithoutExpression(): Promise<void>;
}
declare class Vector2Param extends TypedMultipleParam<ParamType.VECTOR2> {
	protected _value: Vector2;
	x: FloatParam;
	y: FloatParam;
	static type(): ParamType;
	componentNames(): Readonly<string[]>;
	defaultValueSerialized(): StringOrNumber2;
	_prefilterInvalidRawInput(rawInput: any): StringOrNumber2 | Vector2;
	valueSerialized(): Number2;
	private _copied_value;
	protected _copyValue(param: Vector2Param): void;
	protected _cloneRawInput(raw_input: ParamInitValuesTypeMap[ParamType.VECTOR2]): StringOrNumber2 | Vector2;
	static areRawInputEqual(raw_input1: ParamInitValuesTypeMap[ParamType.VECTOR2], raw_input2: ParamInitValuesTypeMap[ParamType.VECTOR2]): boolean;
	static areValuesEqual(val1: ParamValuesTypeMap[ParamType.VECTOR2], val2: ParamValuesTypeMap[ParamType.VECTOR2]): boolean;
	initComponents(): void;
	setValueFromComponents(): void;
}
declare class Vector3Param extends TypedMultipleParam<ParamType.VECTOR3> {
	protected _value: Vector3;
	x: FloatParam;
	y: FloatParam;
	z: FloatParam;
	static type(): ParamType;
	componentNames(): Readonly<string[]>;
	defaultValueSerialized(): StringOrNumber3;
	_prefilterInvalidRawInput(rawInput: any): StringOrNumber3 | Vector3;
	valueSerialized(): Number3;
	private _copied_value;
	protected _copyValue(param: Vector3Param): void;
	protected _cloneRawInput(raw_input: ParamInitValuesTypeMap[ParamType.VECTOR3]): StringOrNumber3 | Vector3;
	static areRawInputEqual(raw_input1: ParamInitValuesTypeMap[ParamType.VECTOR3], raw_input2: ParamInitValuesTypeMap[ParamType.VECTOR3]): boolean;
	static areValuesEqual(val1: ParamValuesTypeMap[ParamType.VECTOR3], val2: ParamValuesTypeMap[ParamType.VECTOR3]): boolean;
	initComponents(): void;
	setValueFromComponents(): void;
}
declare class Vector4Param extends TypedMultipleParam<ParamType.VECTOR4> {
	protected _value: Vector4;
	x: FloatParam;
	y: FloatParam;
	z: FloatParam;
	w: FloatParam;
	static type(): ParamType;
	componentNames(): Readonly<string[]>;
	defaultValueSerialized(): StringOrNumber4;
	_prefilterInvalidRawInput(rawInput: any): StringOrNumber4 | Vector4;
	valueSerialized(): Number4;
	private _copied_value;
	protected _copyValue(param: Vector4Param): void;
	protected _cloneRawInput(rawInput: ParamInitValuesTypeMap[ParamType.VECTOR4]): StringOrNumber4 | Vector4;
	static areRawInputEqual(rawInput1: ParamInitValuesTypeMap[ParamType.VECTOR4], rawInput2: ParamInitValuesTypeMap[ParamType.VECTOR4]): boolean;
	static areValuesEqual(val1: ParamValuesTypeMap[ParamType.VECTOR4], val2: ParamValuesTypeMap[ParamType.VECTOR4]): boolean;
	initComponents(): void;
	setValueFromComponents(): void;
}
type ParamConstructorMapType = {
	[key in ParamType]: TypedParam<ParamType>;
};
interface ParamConstructorMap extends ParamConstructorMapType {
	[ParamType.BOOLEAN]: BooleanParam;
	[ParamType.BUTTON]: ButtonParam;
	[ParamType.COLOR]: ColorParam;
	[ParamType.FLOAT]: FloatParam;
	[ParamType.FOLDER]: FolderParam;
	[ParamType.INTEGER]: IntegerParam;
	[ParamType.PARAM_PATH]: ParamPathParam;
	[ParamType.NODE_PATH]: NodePathParam;
	[ParamType.RAMP]: RampParam;
	[ParamType.STRING]: StringParam;
	[ParamType.VECTOR2]: Vector2Param;
	[ParamType.VECTOR3]: Vector3Param;
	[ParamType.VECTOR4]: Vector4Param;
}
declare abstract class GraphNodePathParamValue<T extends CoreGraphNode> {
	protected _path: string;
	protected _graphNode: T | null;
	constructor(_path?: string);
	graphNode(): T | null;
	private _setGraphNode;
	abstract graphNodePath(): string | undefined;
	path(): string;
	setPath(path: string): void;
	clone(): this;
}
declare class TypedNodePathParamValue extends GraphNodePathParamValue<BaseNodeType> {
	setNode(node: BaseNodeType | null): void;
	node(): BaseNodeType | null;
	graphNodePath(): string | undefined;
	resolve(nodeStart: BaseNodeType, decomposedPath?: DecomposedPath): void;
	nodeWithContext<N extends NodeContext, K extends NodeContext>(context: N, errorState?: NodeErrorState<K>): BaseNodeByContextMap[N] | undefined;
}
declare class TypedParamPathParamValue extends GraphNodePathParamValue<BaseParamType> {
	setParam(param: BaseParamType | null): void;
	param(): BaseParamType | null;
	graphNodePath(): string | undefined;
	resolve(nodeStart: BaseNodeType, decomposedPath?: DecomposedPath): void;
	paramWithType<T extends ParamType>(paramType: T, error_state?: ParamErrorState): ParamConstructorMap[T] | undefined;
}
type ParamValuesTypeMapGeneric = {
	[key in ParamType]: any;
};
interface ParamValuesTypeMap extends ParamValuesTypeMapGeneric {
	[ParamType.BOOLEAN]: boolean;
	[ParamType.BUTTON]: null;
	[ParamType.COLOR]: Color;
	[ParamType.FLOAT]: number;
	[ParamType.FOLDER]: null;
	[ParamType.INTEGER]: number;
	[ParamType.PARAM_PATH]: TypedParamPathParamValue;
	[ParamType.NODE_PATH]: TypedNodePathParamValue;
	[ParamType.RAMP]: RampValue;
	[ParamType.STRING]: string;
	[ParamType.VECTOR2]: Vector2;
	[ParamType.VECTOR3]: Vector3;
	[ParamType.VECTOR4]: Vector4;
}
declare class FloatParam extends TypedNumericParam<ParamType.FLOAT> {
	static type(): ParamType;
	defaultValueSerialized(): StringOrNumber;
	rawInputSerialized(): StringOrNumber;
	valueSerialized(): number;
	protected _copyValue(param: FloatParam): void;
	protected _prefilterInvalidRawInput(raw_input: any): ParamInitValuesTypeMap[ParamType.INTEGER];
	static areRawInputEqual(raw_input1: ParamInitValuesTypeMap[ParamType.FLOAT], raw_input2: ParamInitValuesTypeMap[ParamType.FLOAT]): boolean;
	static areValuesEqual(val1: ParamValuesTypeMap[ParamType.FLOAT], val2: ParamValuesTypeMap[ParamType.FLOAT]): boolean;
	static convert(raw_val: ParamInitValuesTypeMap[ParamType.FLOAT]): number | null;
	convert(raw_val: ParamInitValuesTypeMap[ParamType.FLOAT]): number | null;
}
interface ParamInitValueSerializedTypeMap {
	[ParamType.BOOLEAN]: ParamInitValuesTypeMap[ParamType.BOOLEAN];
	[ParamType.BUTTON]: ParamInitValuesTypeMap[ParamType.BUTTON];
	[ParamType.COLOR]: StringOrNumber3;
	[ParamType.FLOAT]: ParamInitValuesTypeMap[ParamType.FLOAT];
	[ParamType.FOLDER]: ParamInitValuesTypeMap[ParamType.FOLDER];
	[ParamType.INTEGER]: ParamInitValuesTypeMap[ParamType.INTEGER];
	[ParamType.NODE_PATH]: ParamInitValuesTypeMap[ParamType.NODE_PATH];
	[ParamType.PARAM_PATH]: ParamInitValuesTypeMap[ParamType.PARAM_PATH];
	[ParamType.RAMP]: RampValueJson;
	[ParamType.STRING]: ParamInitValuesTypeMap[ParamType.STRING];
	[ParamType.VECTOR2]: StringOrNumber2;
	[ParamType.VECTOR3]: StringOrNumber3;
	[ParamType.VECTOR4]: StringOrNumber4;
}
declare abstract class TypedMultipleParam<T extends ParamType> extends TypedParam<T> {
	private _components_contructor;
	protected _components: FloatParam[];
	private _componentsCount;
	get components(): FloatParam[];
	isNumeric(): boolean;
	isDefault(): boolean;
	rawInput(): ParamInitValueSerializedTypeMap[T];
	rawInputSerialized(): ParamInitValueSerializedTypeMap[T];
	protected _copyValue(param: TypedMultipleParam<T>): void;
	initComponents(): void;
	protected processComputation(): Promise<void>;
	abstract setValueFromComponents(): void;
	hasExpression(): boolean;
	private computeComponents;
	protected _prefilterInvalidRawInput(raw_input: any): ParamInitValuesTypeMap[T];
	protected processRawInput(): void;
}
declare enum ColorConversion {
	NONE = "no conversion",
	SRGB_TO_LINEAR = "sRGB -> linear",
	LINEAR_TO_SRGB = "linear -> sRGB"
}
declare class ColorParam extends TypedMultipleParam<ParamType.COLOR> {
	protected _value: Color;
	private _valuePreConversion;
	private _valueSerializedDirty;
	private _valueSerialized;
	private _valuePreConversionSerialized;
	r: FloatParam;
	g: FloatParam;
	b: FloatParam;
	static type(): ParamType;
	componentNames(): Readonly<string[]>;
	defaultValueSerialized(): StringOrNumber3;
	_prefilterInvalidRawInput(rawInput: any): StringOrNumber3 | Color;
	valueSerialized(): Number3;
	valuePreConversionSerialized(): Number3;
	private _copiedValue;
	protected _copyValue(param: ColorParam): void;
	protected _cloneRawInput(raw_input: ParamInitValuesTypeMap[ParamType.COLOR]): StringOrNumber3 | Color;
	static areRawInputEqual(raw_input1: ParamInitValuesTypeMap[ParamType.COLOR], raw_input2: ParamInitValuesTypeMap[ParamType.COLOR]): boolean;
	static areValuesEqual(val1: ParamValuesTypeMap[ParamType.COLOR], val2: ParamValuesTypeMap[ParamType.COLOR]): boolean;
	initComponents(): void;
	postOptionsInitialize(): void;
	private _updateValueSerializedIfRequired;
	valuePreConversion(): Color;
	setConversion(conversion: ColorConversion): Promise<void>;
	setValueFromComponents(): void;
	private _applyColorConversion;
}
declare namespace gsap.core {
	// Added to TypeScript 3.5
	type Omit<T, K extends keyof any> = Pick<T, Exclude<keyof T, K>>;
	class Animation {
		static readonly version: string;
		data: any;
		readonly parent: Timeline | null;
		readonly scrollTrigger?: ScrollTrigger;
		constructor(vars?: object, time?: number);
		/**
		 * Sets the delay before the start of the animation.
		 *
		 * ```js
		 * anim.delay(1);
		 * ```
		 *
		 * @param {number} value
		 * @returns {Animation} The animation
		 * @memberof Animation
		 * @link https://greensock.com/docs/v3/GSAP/Tween/delay()
		 */
		delay(value: number): this;
		/**
		 * Gets the delay before the start of the animation.
		 *
		 * ```js
		 * anim.delay();
		 * ```
		 *
		 * @returns {number} The delay value
		 * @memberof Animation
		 * @link https://greensock.com/docs/v3/GSAP/Tween/delay()
		 */
		delay(): number;
		/**
		 * Sets the duration of the animation.
		 *
		 * ```js
		 * anim.duration(1);
		 * ```
		 *
		 * @param {number} value
		 * @returns {Animation} The animation
		 * @memberof Animation
		 * @link https://greensock.com/docs/v3/GSAP/Tween/duration()
		 */
		duration(value: number): this;
		/**
		 * Gets the duration of the animation.
		 *
		 * ```js
		 * anim.duration();
		 * ```
		 *
		 * @returns {number} The duration
		 * @memberof Animation
		 * @link https://greensock.com/docs/v3/GSAP/Tween/duration()
		 */
		duration(): number;
		/**
		 * Returns the time at which the animation will finish according to the parent timeline's local time.
		 *
		 * ```js
		 * anim.endTime() // the time, e.g. something like 17.854
		 * ```
		 *
		 * @returns {number} The end time
		 * @memberof Animation
		 * @link https://greensock.com/docs/v3/GSAP/Tween/endTime()
		 */
		endTime(includeRepeats?: boolean): number;
		/**
		 * Sets a callback of the animation.
		 *
		 * ```js
		 * anim.eventCallback("onComplete", myCompleteCallback);
		 * ```
		 *
		 * @param {CallbackType} type
		 * @param {Callback | null} callback
		 * @param {any[]} [params]
		 * @param {object} [scope]
		 * @returns {Animation} The animation
		 * @memberof Animation
		 * @link https://greensock.com/docs/v3/GSAP/Tween/eventCallback()
		 */
		eventCallback(type: CallbackType, callback: Callback | null, params?: any[], scope?: object): this;
		/**
		 * Gets the requested callback function of the animation.
		 *
		 * ```js
		 * anim.eventCallback("onComplete"); // function or undefined
		 * ```
		 *
		 * @param {CallbackType} type
		 * @returns {Callback} The callback
		 * @memberof Animation
		 * @link https://greensock.com/docs/v3/GSAP/Tween/eventCallback()
		 */
		eventCallback(type: CallbackType): Callback;
		/**
		 * Forces new starting & ending values based on the current state.
		 *
		 * ```js
		 * anim.invalidate();
		 * ```
		 *
		 * @returns {Animation} The animation
		 * @memberof Animation
		 * @link https://greensock.com/docs/v3/GSAP/Tween/invalidate()
		 */
		invalidate(): this;
		/**
		 * Returns true or false based on the active state of the animation.
		 * Being active means that the virtual playhead is actively moving across this instance's time span and it is not paused, nor are any of its ancestor timelines.
		 *
		 * ```js
		 * anim.isActive();
		 * ```
		 *
		 * @returns {boolean} The active state
		 * @memberof Animation
		 * @link https://greensock.com/docs/v3/GSAP/Tween/isActive()
		 */
		isActive(): boolean;
		/**
		 * Sets the current iteration of the animation.
		 *
		 * ```js
		 * anim.iteration(1); // set the state back to the start in this case
		 * ```
		 *
		 * @param {number} value
		 * @param {boolean} [suppressEvents]
		 * @returns {Animation} The tween
		 * @memberof Animation
		 * @link https://greensock.com/docs/v3/GSAP/Tween/iteration()
		 */
		iteration(value: number, suppressEvents?: boolean): this;
		/**
		 * Gets the current iteration of the animation.
		 *
		 * ```js
		 * anim.iteration();  // getter
		 * ```
		 *
		 * @returns {number} The iteration
		 * @memberof Animation
		 * @link https://greensock.com/docs/v3/GSAP/Tween/iteration()
		 */
		iteration(): number;
		/**
		 * Kills the animation entirely.
		 * To kill means to immediately stop the animation, remove it from its parent timeline, and release it for garbage collection.
		 *
		 * ```js
		 * anim.kill();
		 * ```
		 *
		 * @returns {Animation} The animation
		 * @memberof Animation
		 * @link https://greensock.com/docs/v3/GSAP/Tween/kill()
		 */
		kill(): this;
		/**
		 * Pauses the animation, optionally at the given time.
		 *
		 * ```js
		 * anim.pause();    // pause immediately
		 * anim.pause(1.5); // pause but seek to this time in the animation
		 * ```
		 *
		 * @param {number} [atTime]
		 * @param {boolean} [suppressEvents]
		 * @returns {Animation} The animation
		 * @memberof Animation
		 * @link https://greensock.com/docs/v3/GSAP/Tween/pause()
		 */
		pause(atTime?: number | string, suppressEvents?: boolean): this;
		/**
		 * Sets the paused state of the animation.
		 *
		 * ```js
		 * anim.paused(true); // pause immediately
		 * ```
		 *
		 * @param {boolean} value
		 * @returns {Animation} The animation
		 * @memberof Animation
		 * @link https://greensock.com/docs/v3/GSAP/Tween/paused()
		 */
		paused(value: boolean): this;
		/**
		 * Gets the paused state of the animation.
		 *
		 * ```js
		 * anim.paused(); // returns true or false
		 * ```
		 *
		 * @returns {boolean} The paused state
		 * @memberof Animation
		 * @link https://greensock.com/docs/v3/GSAP/Tween/paused()
		 */
		paused(): boolean;
		/**
		 * Plays the animation, optionally from the given start time.
		 *
		 * ```js
		 * anim.play(true); // play from current point
		 * anim.play(1.5);  // play from the 1.5 second mark
		 * ```
		 *
		 * @param {number} [from]
		 * @param {boolean} [suppressEvents]
		 * @returns {Animation} The animation
		 * @memberof Animation
		 * @link https://greensock.com/docs/v3/GSAP/Tween/play()
		 */
		play(from?: number | string | null, suppressEvents?: boolean): this;
		/**
		 * Sets the progress of the animation (between 0 and 1).
		 *
		 * ```js
		 * anim.progress(0.5); // go to the half way point
		 * ```
		 *
		 * @param {number} value
		 * @param {boolean} [suppressEvents]
		 * @returns {Animation} The animation
		 * @memberof Animation
		 * @link https://greensock.com/docs/v3/GSAP/Tween/progress()
		 */
		progress(value: number, suppressEvents?: boolean): this;
		/**
		 * Gets the progress of the animation.
		 *
		 * ```js
		 * anim.progress(); // returns the progress like 0.5
		 * ```
		 *
		 * @returns {number} The progress
		 * @memberof Animation
		 * @link https://greensock.com/docs/v3/GSAP/Tween/progress()
		 */
		progress(): number;
		rawTime(wrapRepeats?: boolean): number;
		/**
		 * Forces things to render at a certain time WITHOUT adjusting the animation's position in its parent timeline
		 *
		 * ```js
		 * anim.render(1);
		 * ```
		 *
		 * @param {number} totalTime
		 * @param {boolean} [suppressEvents]
		 * @param {boolean} [force]
		 * @returns {Animation} The animation
		 * @memberof Animation
		 */
		render(totalTime: number, suppressEvents?: boolean, force?: boolean): this;
		/**
		 * Sets the number of repeats of the animation.
		 *
		 * ```js
		 * anim.repeat(1); // sets repeat to 1 for a total iteration count of 2
		 * ```
		 *
		 * @param {number} [value]
		 * @returns {Animation} The animation
		 * @memberof Animation
		 */
		repeat(value: number): this;
		/**
		 * Gets the number of repeats of the animation.
		 *
		 * ```js
		 * anim.repeat();
		 * ```
		 *
		 * @returns {number} The repeat value
		 * @memberof Animation
		 */
		repeat(): number;
		/**
		 * Sets the repeat delay (time between iterations) of the animation.
		 *
		 * ```js
		 * anim.repeatDelay(1);
		 * ```
		 *
		 * @param {number} [value]
		 * @returns {Animation} The animation
		 * @memberof Animation
		 */
		repeatDelay(value: number): this;
		/**
		 * Gets the repeat delay (time between iterations) of the animation.
		 *
		 * ```js
		 * anim.repeatDelay();
		 * ```
		 *
		 * @returns {number} The repeatDelay value
		 * @memberof Animation
		 */
		repeatDelay(): number;
		/**
		 * Begins playing the animation forward from the beginning, optionally including the starting delay.
		 *
		 * ```js
		 * anim.restart();     // repeats the animation NOT including the starting delay
		 * anim.restart(true); // repeats the animation including the starting delay
		 * ```
		 *
		 * @param {number} [includeDelay]
		 * @param {boolean} [suppressEvents]
		 * @returns {Animation} The animation
		 * @memberof Animation
		 * @link https://greensock.com/docs/v3/GSAP/Tween/restart()
		 */
		restart(includeDelay?: boolean, suppressEvents?: boolean): this;
		/**
		 * Continues a paused animation in the direction it was headed (forwards or reverse), optionally from the given time.
		 *
		 * ```js
		 * anim.resume();  // continues the animation
		 * anim.resume(1); // continues the animation from the 1 second mark
		 * ```
		 *
		 * @param {number} [from]
		 * @param {boolean} [suppressEvents]
		 * @returns {Animation} The animation
		 * @memberof Animation
		 * @link https://greensock.com/docs/v3/GSAP/Tween/resume()
		 */
		resume(from?: number | string, suppressEvents?: boolean): this;
		/**
		 * Plays an animation in the reverse direction, optionally from the given time.
		 *
		 * ```js
		 * anim.reverse();  // plays the animation in reverse
		 * anim.reverse(1); // plays the animation in reverse from the 1 second mark
		 * ```
		 *
		 * @param {number} [from]
		 * @param {boolean} [suppressEvents]
		 * @returns {Animation} The animation
		 * @memberof Animation
		 * @link https://greensock.com/docs/v3/GSAP/Tween/reverse()
		 */
		reverse(from?: number | string, suppressEvents?: boolean): this;
		/**
		 * Sets the reversed state of the animation.
		 *
		 * ```js
		 * anim.reversed(true); // plays the animation in reverse
		 * ```
		 *
		 * @param {boolean} value
		 * @returns {Animation} The animation
		 * @memberof Animation
		 * @link https://greensock.com/docs/v3/GSAP/Tween/reversed()
		 */
		reversed(value: boolean): this;
		/**
		 * Gets the reversed state of the animation.
		 *
		 * ```js
		 * anim.reversed(); // true or false
		 * ```
		 *
		 * @returns {boolean} The reversed state
		 * @memberof Animation
		 * @link https://greensock.com/docs/v3/GSAP/Tween/reversed()
		 */
		reversed(): boolean;
		/**
		 * Reverts the animation, returning the targets to their pre-animation state including the removal of inline styles added by the animation.
		 *
		 * ```js
		 * anim.revert();
		 * ```
		 *
		 * @param {object} [config]
		 * @returns {Animation} The animation
		 * @memberof Animation
		 * @link https://greensock.com/docs/v3/GSAP/Tween/revert()
		 */
		revert(config?: object): this;
		/**
		 * Sets the start time of the animation in reference to its parent timeline (not including any delay).
		 *
		 * ```js
		 * anim.startTime(1); // plays the animation at the 1 second mark of the parent timeline
		 * ```
		 *
		 * @param {number} value
		 * @returns {Animation} The animation
		 * @memberof Animation
		 * @link https://greensock.com/docs/v3/GSAP/Tween/startTime()
		 */
		startTime(value: number): this;
		/**
		 * Gets the start time of the animation in reference to its parent timeline (not including any delay).
		 *
		 * ```js
		 * anim.startTime(); // the current start time, something like 1.0
		 * ```
		 *
		 * @returns {Animation} The animation
		 * @memberof Animation
		 * @link https://greensock.com/docs/v3/GSAP/Tween/startTime()
		 */
		startTime(): number;
		/**
		 * Sets the current time of the given animation using a time or a label.
		 *
		 * ```js
		 * anim.seek(1); // moves the playhead to the 1 second mark
		 * ```
		 *
		 * @param {number| string} time
		 * @param {boolean} [suppressEvents]
		 * @returns {Animation} The animation
		 * @memberof Animation
		 */
		seek(time: number | string, suppressEvents?: boolean): this;
		/**
		 * Returns a promise for the given animation.
		 *
		 * ```js
		 * anim.then(yourFunction).then(...);
		 * ```
		 *
		 * @param {Function} [onFulfilled]
		 * @returns {Promise} A promise for the completion of the animation
		 * @memberof Animation
		 * @link https://greensock.com/docs/v3/GSAP/Tween/then()
		 */
		then(onFulfilled?: (result: Omit<this, "then">) => any): Promise<this>;
		/**
		 * Sets the current time of the given animation.
		 *
		 * ```js
		 * anim.time(1); // moves the playhead to the 1 second mark
		 * ```
		 *
		 * @param {number} value
		 * @param {boolean} [suppressEvents]
		 * @returns {Animation} The animation
		 * @memberof Animation
		 * @link https://greensock.com/docs/v3/GSAP/Tween/time()
		 */
		time(value: number, suppressEvents?: boolean): this;
		/**
		 * Gets the current time of the given animation.
		 *
		 * ```js
		 * anim.time(); // the current time, e.g. something like 1.0
		 * ```
		 *
		 * @returns {number} The current time
		 * @memberof Animation
		 * @link https://greensock.com/docs/v3/GSAP/Tween/time()
		 */
		time(): number;
		/**
		 * Sets the time scale of the given animation.
		 *
		 * ```js
		 * anim.timeScale(2.0); // makes the animation go at twice the normal speed
		 * ```
		 *
		 * @param {number} value
		 * @returns {Animation} The animation
		 * @memberof Animation
		 * @link https://greensock.com/docs/v3/GSAP/Tween/timeScale()
		 */
		timeScale(value: number): this;
		/**
		 * Gets the time scale of the given animation.
		 *
		 * ```js
		 * anim.timeScale(); // the
		 * ```
		 *
		 * @returns {Animation} The animation
		 * @memberof Animation
		 * @link https://greensock.com/docs/v3/GSAP/Tween/timeScale()
		 */
		timeScale(): number;
		/**
		 * Sets the total duration (including repeats) of the given animation by time scaling the animation.
		 *
		 * ```js
		 * anim.totalDuration(8);
		 * ```
		 *
		 * @param {number} value
		 * @returns {Animation} The animation
		 * @memberof Animation
		 * @link https://greensock.com/docs/v3/GSAP/Tween/totalDuration()
		 */
		totalDuration(value: number): this;
		/**
		 * Gets the total duration (including repeats) of the given animation.
		 *
		 * ```js
		 * anim.totalDuration(); // the total duration, e.g. something like 5.7
		 * ```
		 *
		 * @returns {number} The total duration
		 * @memberof Animation
		 * @link https://greensock.com/docs/v3/GSAP/Tween/totalDuration()
		 */
		totalDuration(): number;
		/**
		 * Sets the total progress (including repeats) of the given animation.
		 *
		 * ```js
		 * anim.totalProgress(0.5); // move the playhead to half way through the animation (including repeats)
		 * ```
		 *
		 * @param {number} value
		 * @param {boolean} suppressEvents
		 * @returns {Animation} The animation
		 * @memberof Animation
		 * @link https://greensock.com/docs/v3/GSAP/Tween/totalProgress()
		 */
		totalProgress(value: number, suppressEvents?: boolean): this;
		/**
		 * Gets the total progress (including repeats) of the given animation.
		 *
		 * ```js
		 * anim.totalProgress(); // the total progress, e.g. something like 0.5
		 * ```
		 *
		 * @returns {number} The total progress
		 * @memberof Animation
		 * @link https://greensock.com/docs/v3/GSAP/Tween/totalProgress()
		 */
		totalProgress(): number;
		/**
		 * Sets the total time (meaning where the playhead is, including repeats) of the given animation.
		 *
		 * ```js
		 * anim.totalTime(5.7); // move the playhead to the 5.7 mark of the animation (including repeats)
		 * ```
		 *
		 * @param {number} value
		 * @param {boolean} [suppressEvents]
		 * @returns {Animation} The animation
		 * @memberof Animation
		 * @link https://greensock.com/docs/v3/GSAP/Tween/totalTime()
		 */
		totalTime(value: number, suppressEvents?: boolean): this;
		/**
		 * Gets the total time (meaning where the playhead is, including repeats) of the given animation.
		 *
		 * ```js
		 * anim.totalTime(); // the total time, e.g. something like 5.7
		 * ```
		 *
		 * @returns {number} The total time
		 * @memberof Animation
		 * @link https://greensock.com/docs/v3/GSAP/Tween/totalTime()
		 */
		totalTime(): number;
		/**
		 * Sets the yoyo value of the given animation.
		 * Setting yoyo to true means that each time the animation repeats it should switch its direction (forwards or reverse).
		 *
		 * ```js
		 * anim.yoyo(true);
		 * ```
		 *
		 * @param {boolean} value
		 * @returns {Animation} The animation
		 * @memberof Animation
		 * @link https://greensock.com/docs/v3/GSAP/Tween/yoyo()
		 */
		yoyo(value: boolean): this;
		/**
		 * Gets the yoyo value of the given animation.
		 * If yoyo is true that means that each time the animation repeats it should switch its direction (forwards or reverse).
		 *
		 * ```js
		 * anim.yoyo(); // true or false
		 * ```
		 *
		 * @returns {boolean} The yoyo value
		 * @memberof Animation
		 * @link https://greensock.com/docs/v3/GSAP/Tween/yoyo()
		 */
		yoyo(): boolean;
	}
}
declare namespace gsap {
	// GSAP specific
	interface CSSProperties {
		[key: string]: any;
		alpha: TweenValue;
		autoAlpha: TweenValue;
		rotate: TweenValue;
		rotateX: TweenValue;
		rotateY: TweenValue;
		rotateZ: TweenValue;
		rotation: TweenValue;
		rotationX: TweenValue;
		rotationY: TweenValue;
		rotationZ: TweenValue;
		scale: TweenValue;
		scaleX: TweenValue;
		scaleY: TweenValue;
		skew: TweenValue;
		skewX: TweenValue;
		skewY: TweenValue;
		smoothOrigin: BooleanValue;
		svgOrigin: TweenValue;
		translateX: TweenValue;
		translateY: TweenValue;
		translateZ: TweenValue;
		x: TweenValue;
		xPercent: TweenValue;
		y: TweenValue;
		yPercent: TweenValue;
		z: TweenValue;
	}
	interface CSSProperties {
		alignContent: TweenValue;
		alignItems: TweenValue;
		alignSelf: TweenValue;
		alignmentBaseline: TweenValue;
		animation: TweenValue;
		animationDelay: TweenValue;
		animationDirection: TweenValue;
		animationDuration: TweenValue;
		animationFillMode: TweenValue;
		animationIterationCount: TweenValue;
		animationName: TweenValue;
		animationPlayState: TweenValue;
		animationTimingFunction: TweenValue;
		backfaceVisibility: TweenValue;
		background: TweenValue;
		backgroundAttachment: TweenValue;
		backgroundClip: TweenValue;
		backgroundColor: TweenValue;
		backgroundImage: TweenValue;
		backgroundOrigin: TweenValue;
		backgroundPosition: TweenValue;
		backgroundPositionX: TweenValue;
		backgroundPositionY: TweenValue;
		backgroundRepeat: TweenValue;
		backgroundSize: TweenValue;
		baselineShift: TweenValue;
		border: TweenValue;
		borderBottom: TweenValue;
		borderBottomColor: TweenValue;
		borderBottomLeftRadius: TweenValue;
		borderBottomRightRadius: TweenValue;
		borderBottomStyle: TweenValue;
		borderBottomWidth: TweenValue;
		borderCollapse: TweenValue;
		borderColor: TweenValue;
		borderImage: TweenValue;
		borderImageOutset: TweenValue;
		borderImageRepeat: TweenValue;
		borderImageSlice: TweenValue;
		borderImageSource: TweenValue;
		borderImageWidth: TweenValue;
		borderLeft: TweenValue;
		borderLeftColor: TweenValue;
		borderLeftStyle: TweenValue;
		borderLeftWidth: TweenValue;
		borderRadius: TweenValue;
		borderRight: TweenValue;
		borderRightColor: TweenValue;
		borderRightStyle: TweenValue;
		borderRightWidth: TweenValue;
		borderSpacing: TweenValue;
		borderStyle: TweenValue;
		borderTop: TweenValue;
		borderTopColor: TweenValue;
		borderTopLeftRadius: TweenValue;
		borderTopRightRadius: TweenValue;
		borderTopStyle: TweenValue;
		borderTopWidth: TweenValue;
		borderWidth: TweenValue;
		bottom: TweenValue;
		boxShadow: TweenValue;
		boxSizing: TweenValue;
		breakAfter: TweenValue;
		breakBefore: TweenValue;
		breakInside: TweenValue;
		captionSide: TweenValue;
		caretColor: TweenValue;
		clear: TweenValue;
		clip: TweenValue;
		clipPath: TweenValue;
		clipRule: TweenValue;
		color: TweenValue;
		colorInterpolationFilters: TweenValue;
		columnCount: TweenValue;
		columnFill: TweenValue;
		columnGap: TweenValue;
		columnRule: TweenValue;
		columnRuleColor: TweenValue;
		columnRuleStyle: TweenValue;
		columnRuleWidth: TweenValue;
		columnSpan: TweenValue;
		columnWidth: TweenValue;
		columns: TweenValue;
		content: TweenValue;
		counterIncrement: TweenValue;
		counterReset: TweenValue;
		cssFloat: TweenValue;
		cssText: TweenValue;
		cursor: TweenValue;
		direction: TweenValue;
		display: TweenValue;
		dominantBaseline: TweenValue;
		emptyCells: TweenValue;
		enableBackground: TweenValue;
		fill: TweenValue;
		fillOpacity: TweenValue;
		fillRule: TweenValue;
		filter: TweenValue;
		flex: TweenValue;
		flexBasis: TweenValue;
		flexDirection: TweenValue;
		flexFlow: TweenValue;
		flexGrow: TweenValue;
		flexShrink: TweenValue;
		flexWrap: TweenValue;
		floodColor: TweenValue;
		floodOpacity: TweenValue;
		font: TweenValue;
		fontFamily: TweenValue;
		fontFeatureSettings: TweenValue;
		fontKerning: TweenValue;
		fontSize: TweenValue;
		fontSizeAdjust: TweenValue;
		fontStretch: TweenValue;
		fontStyle: TweenValue;
		fontSynthesis: TweenValue;
		fontVariant: TweenValue;
		fontVariantCaps: TweenValue;
		fontVariantEastAsian: TweenValue;
		fontVariantLigatures: TweenValue;
		fontVariantNumeric: TweenValue;
		fontVariantPosition: TweenValue;
		fontWeight: TweenValue;
		gap: TweenValue;
		glyphOrientationHorizontal: TweenValue;
		glyphOrientationVertical: TweenValue;
		grid: TweenValue;
		gridArea: TweenValue;
		gridAutoColumns: TweenValue;
		gridAutoFlow: TweenValue;
		gridAutoRows: TweenValue;
		gridColumn: TweenValue;
		gridColumnEnd: TweenValue;
		gridColumnGap: TweenValue;
		gridColumnStart: TweenValue;
		gridGap: TweenValue;
		gridRow: TweenValue;
		gridRowEnd: TweenValue;
		gridRowGap: TweenValue;
		gridRowStart: TweenValue;
		gridTemplate: TweenValue;
		gridTemplateAreas: TweenValue;
		gridTemplateColumns: TweenValue;
		gridTemplateRows: TweenValue;
		height: TweenValue;
		hyphens: TweenValue;
		imageOrientation: TweenValue;
		imageRendering: TweenValue;
		imeMode: TweenValue;
		justifyContent: TweenValue;
		justifyItems: TweenValue;
		justifySelf: TweenValue;
		kerning: TweenValue;
		layoutGrid: TweenValue;
		layoutGridChar: TweenValue;
		layoutGridLine: TweenValue;
		layoutGridMode: TweenValue;
		layoutGridType: TweenValue;
		left: TweenValue;
		letterSpacing: TweenValue;
		lightingColor: TweenValue;
		lineBreak: TweenValue;
		lineHeight: TweenValue;
		listStyle: TweenValue;
		listStyleImage: TweenValue;
		listStylePosition: TweenValue;
		listStyleType: TweenValue;
		margin: TweenValue;
		marginBottom: TweenValue;
		marginLeft: TweenValue;
		marginRight: TweenValue;
		marginTop: TweenValue;
		marker: TweenValue;
		markerEnd: TweenValue;
		markerMid: TweenValue;
		markerStart: TweenValue;
		mask: TweenValue;
		maskComposite: TweenValue;
		maskImage: TweenValue;
		maskPosition: TweenValue;
		maskRepeat: TweenValue;
		maskSize: TweenValue;
		maskType: TweenValue;
		maxHeight: TweenValue;
		maxWidth: TweenValue;
		minHeight: TweenValue;
		minWidth: TweenValue;
		msContentZoomChaining: TweenValue;
		msContentZoomLimit: TweenValue;
		msContentZoomLimitMax: any;
		msContentZoomLimitMin: any;
		msContentZoomSnap: TweenValue;
		msContentZoomSnapPoints: TweenValue;
		msContentZoomSnapType: TweenValue;
		msContentZooming: TweenValue;
		msFlowFrom: TweenValue;
		msFlowInto: TweenValue;
		msFontFeatureSettings: TweenValue;
		msGridColumn: any;
		msGridColumnAlign: TweenValue;
		msGridColumnSpan: any;
		msGridColumns: TweenValue;
		msGridRow: any;
		msGridRowAlign: TweenValue;
		msGridRowSpan: any;
		msGridRows: TweenValue;
		msHighContrastAdjust: TweenValue;
		msHyphenateLimitChars: TweenValue;
		msHyphenateLimitLines: any;
		msHyphenateLimitZone: any;
		msHyphens: TweenValue;
		msImeAlign: TweenValue;
		msOverflowStyle: TweenValue;
		msScrollChaining: TweenValue;
		msScrollLimit: TweenValue;
		msScrollLimitXMax: any;
		msScrollLimitXMin: any;
		msScrollLimitYMax: any;
		msScrollLimitYMin: any;
		msScrollRails: TweenValue;
		msScrollSnapPointsX: TweenValue;
		msScrollSnapPointsY: TweenValue;
		msScrollSnapType: TweenValue;
		msScrollSnapX: TweenValue;
		msScrollSnapY: TweenValue;
		msScrollTranslation: TweenValue;
		msTextCombineHorizontal: TweenValue;
		msTextSizeAdjust: any;
		msTouchAction: TweenValue;
		msTouchSelect: TweenValue;
		msUserSelect: TweenValue;
		msWrapFlow: TweenValue;
		msWrapMargin: any;
		msWrapThrough: TweenValue;
		objectFit: TweenValue;
		objectPosition: TweenValue;
		opacity: TweenValue;
		order: TweenValue;
		orphans: TweenValue;
		outline: TweenValue;
		outlineColor: TweenValue;
		outlineOffset: TweenValue;
		outlineStyle: TweenValue;
		outlineWidth: TweenValue;
		overflow: TweenValue;
		overflowAnchor: TweenValue;
		overflowWrap: TweenValue;
		overflowX: TweenValue;
		overflowY: TweenValue;
		padding: TweenValue;
		paddingBottom: TweenValue;
		paddingLeft: TweenValue;
		paddingRight: TweenValue;
		paddingTop: TweenValue;
		pageBreakAfter: TweenValue;
		pageBreakBefore: TweenValue;
		pageBreakInside: TweenValue;
		penAction: TweenValue;
		perspective: TweenValue;
		perspectiveOrigin: TweenValue;
		placeContent: TweenValue;
		placeItems: TweenValue;
		placeSelf: TweenValue;
		pointerEvents: TweenValue;
		position: TweenValue;
		quotes: TweenValue;
		resize: TweenValue;
		right: TweenValue;
		rotate: TweenValue;
		rowGap: TweenValue;
		rubyAlign: TweenValue;
		rubyOverhang: TweenValue;
		rubyPosition: TweenValue;
		scale: TweenValue;
		scrollBehavior: TweenValue;
		stopColor: TweenValue;
		stopOpacity: TweenValue;
		stroke: TweenValue;
		strokeDasharray: TweenValue;
		strokeDashoffset: TweenValue;
		strokeLinecap: TweenValue;
		strokeLinejoin: TweenValue;
		strokeMiterlimit: TweenValue;
		strokeOpacity: TweenValue;
		strokeWidth: TweenValue;
		tabSize: TweenValue;
		tableLayout: TweenValue;
		textAlign: TweenValue;
		textAlignLast: TweenValue;
		textAnchor: TweenValue;
		textCombineUpright: TweenValue;
		textDecoration: TweenValue;
		textDecorationColor: TweenValue;
		textDecorationLine: TweenValue;
		textDecorationStyle: TweenValue;
		textEmphasis: TweenValue;
		textEmphasisColor: TweenValue;
		textEmphasisPosition: TweenValue;
		textEmphasisStyle: TweenValue;
		textIndent: TweenValue;
		textJustify: TweenValue;
		textKashida: TweenValue;
		textKashidaSpace: TweenValue;
		textOrientation: TweenValue;
		textOverflow: TweenValue;
		textShadow: TweenValue;
		textTransform: TweenValue;
		textUnderlinePosition: TweenValue;
		top: TweenValue;
		touchAction: TweenValue;
		transform: TweenValue;
		transformBox: TweenValue;
		transformOrigin: TweenValue;
		transformStyle: TweenValue;
		transition: TweenValue;
		transitionDelay: TweenValue;
		transitionDuration: TweenValue;
		transitionProperty: TweenValue;
		transitionTimingFunction: TweenValue;
		translate: TweenValue;
		unicodeBidi: TweenValue;
		userSelect: TweenValue;
		verticalAlign: TweenValue;
		visibility: TweenValue;
		/** @deprecated */
		webkitAlignContent: TweenValue;
		/** @deprecated */
		webkitAlignItems: TweenValue;
		/** @deprecated */
		webkitAlignSelf: TweenValue;
		/** @deprecated */
		webkitAnimation: TweenValue;
		/** @deprecated */
		webkitAnimationDelay: TweenValue;
		/** @deprecated */
		webkitAnimationDirection: TweenValue;
		/** @deprecated */
		webkitAnimationDuration: TweenValue;
		/** @deprecated */
		webkitAnimationFillMode: TweenValue;
		/** @deprecated */
		webkitAnimationIterationCount: TweenValue;
		/** @deprecated */
		webkitAnimationName: TweenValue;
		/** @deprecated */
		webkitAnimationPlayState: TweenValue;
		/** @deprecated */
		webkitAnimationTimingFunction: TweenValue;
		/** @deprecated */
		webkitAppearance: TweenValue;
		/** @deprecated */
		webkitBackfaceVisibility: TweenValue;
		/** @deprecated */
		webkitBackgroundClip: TweenValue;
		/** @deprecated */
		webkitBackgroundOrigin: TweenValue;
		/** @deprecated */
		webkitBackgroundSize: TweenValue;
		/** @deprecated */
		webkitBorderBottomLeftRadius: TweenValue;
		/** @deprecated */
		webkitBorderBottomRightRadius: TweenValue;
		webkitBorderImage: TweenValue;
		/** @deprecated */
		webkitBorderRadius: TweenValue;
		/** @deprecated */
		webkitBorderTopLeftRadius: TweenValue;
		/** @deprecated */
		webkitBorderTopRightRadius: TweenValue;
		/** @deprecated */
		webkitBoxAlign: TweenValue;
		webkitBoxDirection: TweenValue;
		/** @deprecated */
		webkitBoxFlex: TweenValue;
		/** @deprecated */
		webkitBoxOrdinalGroup: TweenValue;
		webkitBoxOrient: TweenValue;
		/** @deprecated */
		webkitBoxPack: TweenValue;
		/** @deprecated */
		webkitBoxShadow: TweenValue;
		/** @deprecated */
		webkitBoxSizing: TweenValue;
		webkitColumnBreakAfter: TweenValue;
		webkitColumnBreakBefore: TweenValue;
		webkitColumnBreakInside: TweenValue;
		webkitColumnCount: any;
		webkitColumnGap: any;
		webkitColumnRule: TweenValue;
		webkitColumnRuleColor: any;
		webkitColumnRuleStyle: TweenValue;
		webkitColumnRuleWidth: any;
		webkitColumnSpan: TweenValue;
		webkitColumnWidth: any;
		webkitColumns: TweenValue;
		/** @deprecated */
		webkitFilter: TweenValue;
		/** @deprecated */
		webkitFlex: TweenValue;
		/** @deprecated */
		webkitFlexBasis: TweenValue;
		/** @deprecated */
		webkitFlexDirection: TweenValue;
		/** @deprecated */
		webkitFlexFlow: TweenValue;
		/** @deprecated */
		webkitFlexGrow: TweenValue;
		/** @deprecated */
		webkitFlexShrink: TweenValue;
		/** @deprecated */
		webkitFlexWrap: TweenValue;
		/** @deprecated */
		webkitJustifyContent: TweenValue;
		webkitLineClamp: TweenValue;
		/** @deprecated */
		webkitMask: TweenValue;
		/** @deprecated */
		webkitMaskBoxImage: TweenValue;
		/** @deprecated */
		webkitMaskBoxImageOutset: TweenValue;
		/** @deprecated */
		webkitMaskBoxImageRepeat: TweenValue;
		/** @deprecated */
		webkitMaskBoxImageSlice: TweenValue;
		/** @deprecated */
		webkitMaskBoxImageSource: TweenValue;
		/** @deprecated */
		webkitMaskBoxImageWidth: TweenValue;
		/** @deprecated */
		webkitMaskClip: TweenValue;
		/** @deprecated */
		webkitMaskComposite: TweenValue;
		/** @deprecated */
		webkitMaskImage: TweenValue;
		/** @deprecated */
		webkitMaskOrigin: TweenValue;
		/** @deprecated */
		webkitMaskPosition: TweenValue;
		/** @deprecated */
		webkitMaskRepeat: TweenValue;
		/** @deprecated */
		webkitMaskSize: TweenValue;
		/** @deprecated */
		webkitOrder: TweenValue;
		/** @deprecated */
		webkitPerspective: TweenValue;
		/** @deprecated */
		webkitPerspectiveOrigin: TweenValue;
		webkitTapHighlightColor: TweenValue;
		/** @deprecated */
		webkitTextFillColor: TweenValue;
		/** @deprecated */
		webkitTextSizeAdjust: TweenValue;
		/** @deprecated */
		webkitTextStroke: TweenValue;
		/** @deprecated */
		webkitTextStrokeColor: TweenValue;
		/** @deprecated */
		webkitTextStrokeWidth: TweenValue;
		/** @deprecated */
		webkitTransform: TweenValue;
		/** @deprecated */
		webkitTransformOrigin: TweenValue;
		/** @deprecated */
		webkitTransformStyle: TweenValue;
		/** @deprecated */
		webkitTransition: TweenValue;
		/** @deprecated */
		webkitTransitionDelay: TweenValue;
		/** @deprecated */
		webkitTransitionDuration: TweenValue;
		/** @deprecated */
		webkitTransitionProperty: TweenValue;
		/** @deprecated */
		webkitTransitionTimingFunction: TweenValue;
		webkitUserModify: TweenValue;
		webkitUserSelect: TweenValue;
		webkitWritingMode: TweenValue;
		whiteSpace: TweenValue;
		widows: TweenValue;
		width: TweenValue;
		willChange: TweenValue;
		wordBreak: TweenValue;
		wordSpacing: TweenValue;
		wordWrap: TweenValue;
		writingMode: TweenValue;
		zIndex: TweenValue;
		zoom: TweenValue;
	}
	interface CSSVars extends Partial<CSSProperties> {
	}
	interface TweenVars extends CSSVars {
		css?: CSSVars;
	}
	// TODO: Add types
	interface GSCache {
		[key: string]: any;
	}
}
declare namespace gsap.plugins {
	interface CSSPlugin extends Plugin {
	}
	interface CSSPluginClass extends CSSPlugin {
		new (): PluginScope & CSSPlugin;
		prototype: PluginScope & CSSPlugin;
	}
	const css: CSSPluginClass;
}
interface Element {
	_gsap: gsap.GSCache;
}
declare namespace gsap {
	interface TweenVars {
		cssRule?: object; // TODO make more specific
	}
}
declare namespace gsap.plugins {
	interface CSSRulePlugin extends Plugin {
		/**
		 * Gets the style sheet object associated with a particular selector.
		 *
		 * ```js
		 * var rule = CSSRulePlugin.getRule(".myClass::before");
		 * // Then do what you want with it, such as:
		 * gsap.to(rule, { duration: 3, cssRule: { color: "#0000FF" } });
		 * ```
		 *
		 * @param {string} selector
		 * @returns {CSSRule} The CSSRule
		 * @memberof CSSRulePlugin
		 * @link https://greensock.com/docs/v3/Plugins/CSSRulePlugin
		 */
		getRule(selector: string): CSSRule;
	}
	interface CSSRulePluginClass extends CSSRulePlugin {
		new (): PluginScope & CSSRulePlugin;
		prototype: PluginScope & CSSRulePlugin;
	}
	const cssRule: CSSRulePluginClass;
}
declare class Draggable {
	static version: string;
	static zIndex: number;
	readonly autoScroll: number;
	readonly deltaX: number;
	readonly deltaY: number;
	readonly endRotation: number;
	readonly endX: number;
	readonly endY: number;
	readonly isDragging: boolean;
	readonly isPressed: boolean;
	readonly isThrowing: boolean;
	readonly lockAxis: boolean;
	readonly maxRotation: number;
	readonly maxX: number;
	readonly maxY: number;
	readonly minX: number;
	readonly minY: number;
	readonly minRotation: number;
	readonly pointerEvent: TouchEvent | PointerEvent;
	readonly pointerX: number;
	readonly pointerY: number;
	readonly rotation: number;
	readonly scrollProxy: any; // TODO: Create interface
	readonly startX: number;
	readonly startY: number;
	readonly target: HTMLElement | SVGElement;
	readonly tween: gsap.core.Tween;
	readonly vars: Draggable.Vars;
	readonly x: number;
	readonly y: number;
	constructor(target: gsap.DOMTarget, vars?: Draggable.Vars);
	/**
	 * A more flexible way to create Draggable instances than the constructor.
	 *
	 * ```js
	 * Draggable.create(".myClass", {type: "x,y"});
	 * ```
	 *
	 * @param {gsap.DOMTarget} target
	 * @param {Draggable.Vars} [vars]
	 * @returns {Draggable[]} Array of Draggables
	 * @memberof Draggable
	 * @link https://greensock.com/docs/v3/Plugins/Draggable/static.create()
	 */
	static create(target: gsap.DOMTarget, vars?: Draggable.Vars): Draggable[];
	/**
	 * Get the Draggable instance that's associated with a particular DOM element.
	 *
	 * ```js
	 * var draggable = Draggable.get("#myId");
	 * ```
	 *
	 * @param {gsap.DOMTarget} target
	 * @returns {Draggable} The Draggable
	 * @memberof Draggable
	 * @link https://greensock.com/docs/v3/Plugins/Draggable/static.get()
	 */
	static get(target: gsap.DOMTarget): Draggable;
	/**
	 * Test whether or not the target element overlaps with a particular element or the mouse position, optionally including a threshold.
	 *
	 * ```js
	 * Draggable.hitTest(element1, element2, 20)
	 * ```
	 *
	 * @param {Draggable.TestObject} testObject1
	 * @param {Draggable.TestObject} testObject2
	 * @param {number | string} [threshold]
	 * @returns {boolean} If the hit threshhold is met or not
	 * @memberof Draggable
	 * @link https://greensock.com/docs/v3/Plugins/Draggable/static.hitTest()
	 */
	static hitTest(testObject1: Draggable.TestObject, testObject2: Draggable.TestObject, threshold?: number | string): boolean;
	/**
	 * Returns the time (in seconds) that has elapsed since the last drag ended.
	 *
	 * ```js
	 * Draggable.timeSinceDrag();
	 * ```
	 *
	 * @returns {number} The time since the last drag ended
	 * @memberof Draggable
	 * @link https://greensock.com/docs/v3/Plugins/Draggable/static.timeSinceDrag()
	 */
	static timeSinceDrag(): number;
	/**
	 * Registers a function that should be called each time a particular type of event occurs.
	 *
	 * ```js
	 * draggable.addEventListener("press", myPressFunction);
	 * ```
	 *
	 * @param {Draggable.CallbackType} type
	 * @param {gsap.Callback} callback
	 * @memberof Draggable
	 * @link https://greensock.com/docs/v3/Plugins/Draggable/addEventListener()
	 */
	addEventListener(type: Draggable.CallbackType, callback: gsap.Callback): void;
	/**
	 * Registers a function that should be called each time a particular type of event occurs.
	 *
	 * ```js
	 * draggable.applyBounds("#dragContainer");
	 * draggable.applyBounds({top: 100, left: 0, width: 1000, height: 800});
	 * draggable.applyBounds({minX: 10, maxX: 300, minY: 50, maxY: 500});
	 * draggable.applyBounds({minRotation: 0, maxRotation: 270});
	 * ```
	 *
	 * @param {gsap.DOMTarget | Draggable.BoundsMinMax | Draggable.BoundsRectangle | Draggable.BoundsRotation} bounds
	 * @memberof Draggable
	 * @link https://greensock.com/docs/v3/Plugins/Draggable/applyBounds()
	 */
	applyBounds(bounds: gsap.DOMTarget | Draggable.BoundsMinMax | Draggable.BoundsRectangle | Draggable.BoundsRotation): void;
	/**
	 * Disables the Draggable instance so that it cannot be dragged anymore.
	 *
	 * ```js
	 * draggable.disable();
	 * ```
	 *
	 * @param {string | object} [type]
	 * @returns {Draggable} The Draggable instance
	 * @memberof Draggable
	 * @link https://greensock.com/docs/v3/Plugins/Draggable/disable()
	 */
	disable(type?: string | object): this;
	dispatchEvent(type: Draggable.CallbackType): boolean;
	/**
	 * Enables the Draggable instance so that it can be dragged.
	 *
	 * ```js
	 * draggable.enable();
	 * ```
	 *
	 * @param {string | object} [type]
	 * @returns {Draggable} The Draggable instance
	 * @memberof Draggable
	 * @link https://greensock.com/docs/v3/Plugins/Draggable/enable()
	 */
	enable(type?: string | object): this;
	/**
	 * Sets the enabled state of the Draggable.
	 *
	 * ```js
	 * draggable.enabled(true);
	 * ```
	 *
	 * @param {boolean} value
	 * @returns {Draggable} The Draggable
	 * @memberof Draggable
	 * @link https://greensock.com/docs/v3/Plugins/Draggable/enabled()
	 */
	enabled(value: boolean): this;
	/**
	 * Gets the enabled state of the Draggable.
	 *
	 * ```js
	 * draggable.enabled();
	 * ```
	 *
	 * @returns {boolean} The enabled state
	 * @memberof Draggable
	 * @link https://greensock.com/docs/v3/Plugins/Draggable/enabled()
	 */
	enabled(): boolean;
	/**
	 * Force the Draggable to immediately stop interactively dragging.
	 * You must pass it the original mouse or touch event that initiated the stop.
	 *
	 * ```js
	 * draggable.endDrag(e);
	 * ```
	 *
	 * @param {Event} event
	 * @memberof Draggable
	 * @link https://greensock.com/docs/v3/Plugins/Draggable/endDrag()
	 */
	endDrag(event: Event): void;
	/**
	 * Returns the direction, velocity, or proximity to another object.
	 *
	 * ```js
	 * draggable.getDirection("start");
	 * draggable.getDirection("velocity");
	 * draggable.getDirection(refElem);
	 * ```
	 *
	 * @param {"start" | "velocity" | gsap.DOMTarget} from
	 * @returns {Draggable.Direction} The direction
	 * @memberof Draggable
	 * @link https://greensock.com/docs/v3/Plugins/Draggable/getDirection()
	 */
	getDirection(from: "start" | "velocity" | gsap.DOMTarget): Draggable.Direction;
	/**
	 * Test whether or not the target element overlaps with a particular element or the mouse position, optionally including a threshold.
	 *
	 * ```js
	 * draggable.hitTest(otherElem, 20);
	 * ```
	 *
	 * @param {Draggable.TestObject} testObject
	 * @param {number | string} [threshold]
	 * @returns {boolean} If the hit threshhold is met or not
	 * @memberof Draggable
	 * @link https://greensock.com/docs/v3/Plugins/Draggable/static.hitTest()
	 */
	hitTest(testObject: Draggable.TestObject, threshold?: number | string): boolean;
	/**
	 * Disables the Draggable instance and frees it for garbage collection
	 * so that it cannot be dragged anymore.
	 *
	 * ```js
	 * draggable.kill();
	 * ```
	 *
	 * @returns {Draggable} The Draggable instance
	 * @memberof Draggable
	 * @link https://greensock.com/docs/v3/Plugins/Draggable/kill()
	 */
	kill(): this;
	removeEventListener(type: Draggable.CallbackType, callback: gsap.Callback): void;
	/**
	 * Force the Draggable to start interactively dragging.
	 * You must pass it the original mouse or touch event that initiated the start.
	 *
	 * ```js
	 * draggable.startDrag(e);
	 * ```
	 *
	 * @param {Event} event
	 * @param {boolean} align
	 * @memberof Draggable
	 * @link https://greensock.com/docs/v3/Plugins/Draggable/startDrag()
	 */
	startDrag(event: Event, align?: boolean): void;
	/**
	 * Returns the time (in seconds) that has elapsed since the last drag ended.
	 *
	 * ```js
	 * draggable.timeSinceDrag();
	 * ```
	 *
	 * @returns {number} The time since the last drag ended
	 * @memberof Draggable
	 * @link https://greensock.com/docs/v3/Plugins/Draggable/static.timeSinceDrag()
	 */
	timeSinceDrag(): number;
	/**
	 * Updates the Draggable's x/y properties to reflect the target element's current position.
	 *
	 * ```js
	 * Draggable.update();
	 * ```
	 *
	 * @param {boolean} [applyBounds]
	 * @param {boolean} [sticky]
	 * @returns {Draggable} The Draggable instance
	 * @memberof Draggable
	 * @link https://greensock.com/docs/v3/Plugins/Draggable/update()
	 */
	update(applyBounds?: boolean, sticky?: boolean): this;
}
declare namespace Draggable {
	type CallbackType = "click" | "drag" | "dragend" | "dragstart" | "move" | "press" | "release" | "throwcomplete" | "throwupdate";
	type Direction = "down" | "left" | "left-down" | "left-up" | "up" | "right" | "right-down" | "right-up";
	type DraggableType = "left" | "left,top" | "rotation" | "scroll" | "scrollLeft" | "scrollTop" | "top" | "top,left" | "x" | "x,y" | "y" | "y,x";
	type SnapValue = number[] | ((value: number) => number);
	type TestObject = gsap.DOMTarget | Event | Rectangle;
	interface BoundsMinMax {
		minX?: number;
		minY?: number;
		maxX?: number;
		maxY?: number;
	}
	interface BoundsRectangle {
		height?: number;
		left?: number;
		top?: number;
		width?: number;
	}
	interface BoundsRotation {
		minRotation?: number;
		maxRotation?: number;
	}
	interface Rectangle {
		bottom: number;
		left: number;
		right: number;
		top: number;
	}
	interface SnapObject {
		left?: SnapValue;
		points?: gsap.Point2D[] | ((point: gsap.Point2D) => gsap.Point2D);
		radius?: number;
		rotation?: SnapValue;
		top?: SnapValue;
		x?: SnapValue;
		y?: SnapValue;
	}
	interface Vars {
		[key: string]: any;
		activeCursor?: string;
		allowContextMenu?: boolean;
		allowEventDefault?: boolean;
		allowNativeTouchScrolling?: boolean;
		autoScroll?: number;
		bounds?: gsap.DOMTarget | BoundsMinMax | BoundsRectangle | BoundsRotation;
		callbackScope?: object;
		clickableTest?: (this: Draggable, element: HTMLElement | SVGElement) => void;
		cursor?: string;
		dragClickables?: boolean;
		dragResistance?: number;
		edgeResistance?: number;
		force3D?: "auto" | boolean;
		inertia?: boolean | gsap.InertiaVars;
		liveSnap?: boolean | SnapValue | SnapObject;
		lockAxis?: boolean;
		maxDuration?: number;
		minDuration?: number;
		minimumMovement?: number;
		onClick?: gsap.Callback;
		onClickParams?: any[];
		onDrag?: gsap.Callback;
		onDragParams?: any[];
		onDragStart?: gsap.Callback;
		onDragStartParams?: any[];
		onDragEnd?: gsap.Callback;
		onDragEndParams?: any[];
		onLockAxis?: (this: Draggable, event: Event) => void;
		onMove?: gsap.Callback;
		onMoveParams?: any[];
		onPress?: gsap.Callback;
		onPressParams?: any[];
		onPressInit?: gsap.Callback;
		onPressInitParams?: any[];
		onRelease?: gsap.Callback;
		onReleaseParams?: any[];
		onThrowComplete?: gsap.Callback;
		onThrowCompleteParams?: any[];
		onThrowUpdate?: gsap.Callback;
		onThrowUpdateParams?: any[];
		overshootTolerance?: number;
		resistance?: number;
		snap?: SnapValue | SnapObject;
		throwProps?: boolean | gsap.InertiaVars;
		throwResistance?: number;
		trigger?: gsap.DOMTarget;
		type?: DraggableType;
		zIndexBoost?: boolean;
	}
}
declare namespace gsap {
	type DrawSVGTarget = string | SVGPrimitive | SVGPathElement;
	interface TweenVars {
		drawSVG?: number | BooleanValue | DrawSVGTarget;
	}
}
declare namespace gsap.plugins {
	interface DrawSVGPlugin extends Plugin {
		/**
		 * Get the length of an SVG element's stroke.
		 *
		 * ```js
		 * DrawSVGPlugin.getLength(element);
		 * ```
		 *
		 * @param {DrawSVGTarget} element
		 * @returns {number} The stroke length
		 * @memberof DrawSVGPlugin
		 * @link https://greensock.com/docs/v3/Plugins/DrawSVGPlugin/static.getLength()
		 */
		getLength(element: DrawSVGTarget): number;
		/**
		 * Get the current position of the DrawSVG in array form.
		 *
		 * ```js
		 * DrawSVGPlugin.getPosition(element);
		 * ```
		 *
		 * @param {DrawSVGTarget} element
		 * @returns {number[]} The position array
		 * @memberof DrawSVGPlugin
		 * @link https://greensock.com/docs/v3/Plugins/DrawSVGPlugin/static.getPosition()
		 */
		getPosition(element: DrawSVGTarget): number[];
	}
	interface DrawSVGPluginClass extends DrawSVGPlugin {
		new (): PluginScope & DrawSVGPlugin;
		prototype: PluginScope & DrawSVGPlugin;
	}
	const drawSVG: DrawSVGPluginClass;
}
declare namespace gsap {
	interface EaseFunction {
		(progress: number): number;
	}
	interface Ease {
		easeIn: EaseFunction;
		easeOut: EaseFunction;
		easeInOut: EaseFunction;
	}
	interface BackConfig extends EaseFunction {
		config(overshoot: number): EaseFunction;
	}
	interface Back {
		easeIn: BackConfig;
		easeOut: BackConfig;
		easeInOut: BackConfig;
	}
	interface EasePack {
		SlowMo: gsap.SlowMo;
		ExpoScaleEase: gsap.ExpoScaleEase;
		RoughEase: gsap.RoughEase;
	}
	interface ElasticConfig extends EaseFunction {
		config(amplitude: number, period?: number): EaseFunction;
	}
	interface Elastic {
		easeIn: ElasticConfig;
		easeOut: ElasticConfig;
		easeInOut: ElasticConfig;
	}
	interface ExpoScaleEase {
		config(startingScale: number, endingScale: number, ease?: string | EaseFunction): EaseFunction;
	}
	interface Linear extends Ease {
		easeNone: EaseFunction;
	}
	interface RoughEaseVars {
		clamp?: boolean;
		points?: number;
		randomize?: boolean;
		strength?: number;
		taper?: "in" | "out" | "both" | "none";
		template?: string | EaseFunction;
	}
	interface RoughEaseEase extends EaseFunction {
		config: RoughEaseConfig;
	}
	interface RoughEaseConfig extends EaseFunction {
		(config?: RoughEaseVars): EaseFunction;
	}
	interface RoughEase extends EaseFunction {
		config: RoughEaseConfig;
		ease: RoughEaseEase;
	}
	interface SlowMoEase extends EaseFunction {
		config: SlowMoConfig;
	}
	interface SlowMoConfig extends EaseFunction {
		(linearRatio: number, power?: number, yoyoMode?: boolean): EaseFunction;
	}
	interface SlowMo extends EaseFunction {
		config: SlowMoConfig;
		ease: SlowMoEase;
	}
	interface SteppedEase {
		config(steps: number): EaseFunction;
	}
}
declare namespace EaselPlugin {
	interface Vars {
		[key: string]: any;
	}
}
declare namespace gsap {
	interface TweenVars {
		easel?: EaselPlugin.Vars;
	}
}
declare namespace gsap.plugins {
	interface EaselPlugin extends Plugin {
	}
	interface EaselPluginClass extends EaselPlugin {
		new (): PluginScope & EaselPlugin;
		prototype: PluginScope & EaselPlugin;
	}
	const easel: EaselPluginClass;
}
declare const EaselPlugin: gsap.plugins.EaselPlugin;
declare class Flip {
	static readonly version: string;
	/**
	 * Gets the FlipBatch associated with the provided id ("default" by default); if one hasn't be created/registered yet, a new one is returned and registered.
	 *
	 * ```js
	 * let batch = Flip.batch("id");
	 * ```
	 *
	 * @static
	 * @param {string} [id]
	 * @returns {FlipBatch} the FlipBatch (if one isn't registered, a new one is created/registered and returned)
	 * @memberof Flip
	 * @link https://greensock.com/docs/v3/Plugins/Flip/static.batch()
	 */
	static batch(id?: string): FlipBatch;
	/**
	 * Gets the matrix to convert points from one element's local coordinates into a
	 * different element's local coordinate system.
	 *
	 * ```js
	 * Flip.convertCoordinates(fromElement, toElement);
	 * ```
	 *
	 * @static
	 * @param {Element} fromElement
	 * @param {Element} toElement
	 * @returns {gsap.plugins.Matrix2D} A matrix to convert from one element's coordinate system to another's
	 * @memberof Flip
	 */
	static convertCoordinates(fromElement: Element, toElement: Element): gsap.plugins.Matrix2D;
	/**
	 * Converts a point from one element's local coordinates into a
	 * different element's local coordinate system.
	 *
	 * ```js
	 * Flip.convertCoordinates(fromElement, toElement, point);
	 * ```
	 *
	 * @static
	 * @param {Element} fromElement
	 * @param {Element} toElement
	 * @param {gsap.Point2D} point
	 * @returns {gsap.Point2D} A point to convert from one element's coordinate system to another's
	 * @memberof Flip
	 */
	static convertCoordinates(fromElement: Element, toElement: Element, point: gsap.Point2D): gsap.Point2D;
	/**
	 * Changes the x/y/rotation/skewX transforms (and width/height or scaleX/scaleY) to fit one element exactly into the the position/size/rotation of another element.
	 *
	 * ```js
	 * Flip.fit("#el1", "#el2", {
	 *   scale: true,
	 *   absolute: true,
	 *   duration: 1,
	 *   ease: "power2"
	 * });
	 * ```
	 *
	 * @static
	 * @param {gsap.DOMTarget} fromElement
	 * @param {(gsap.DOMTarget | Flip.FlipState)} toElement
	 * @param {Flip.FitVars} [vars]
	 * @returns {(gsap.core.Tween | object | null)}
	 * @memberof Flip
	 */
	static fit(fromElement: gsap.DOMTarget, toElement: gsap.DOMTarget | Flip.FlipState, vars?: Flip.FitVars): gsap.core.Tween | object | null;
	/**
	 * Animates the targets from the provided state to their current state (position/size).
	 *
	 * ```js
	 * Flip.from(state, {
	 *   duration: 1,
	 *   ease: "power1.inOut",
	 *   stagger: 0.1,
	 *   onComplete: () => console.log("done")
	 * });
	 * ```
	 *
	 * @static
	 * @param {Flip.FlipState} state
	 * @param {Flip.FromToVars} [vars]
	 * @returns {gsap.core.Timeline} Flip timeline
	 * @memberof Flip
	 * @link https://greensock.com/docs/v3/Plugins/Flip/static.from()
	 */
	static from(state: Flip.FlipState, vars?: Flip.FromToVars): gsap.core.Timeline;
	/**
	 * Captures information about the current state of the targets so that they can be flipped later.
	 *
	 * ```js
	 * let state = Flip.getState(".my-class, .another-class", {props: "backgroundColor,color", simple: true});
	 * ```
	 *
	 * @static
	 * @param {gsap.DOMTarget} targets
	 * @param {(Flip.FlipStateVars | string)} [vars]
	 * @returns {Flip.FlipState} The resulting state object
	 * @memberof Flip
	 * @link https://greensock.com/docs/v3/Plugins/Flip/static.getState()
	 */
	static getState(targets: gsap.DOMTarget, vars?: Flip.FlipStateVars | string): Flip.FlipState;
	/**
	 * Gets the timeline for the most recently-created flip animation associated with the provided element
	 *
	 * ```js
	 * let tl = Flip.getByTarget("#elementID");
	 * ```
	 *
	 * @static
	 * @param {Element | string} target
	 * @returns {core.Timeline | null} The timeline for the most recently-created flip animation associated with the provided element
	 * @memberof Flip
	 */
	static getByTarget(target: Element | string): gsap.core.Timeline | null;
	/**
	 * Determines whether or not a particular element is actively flipping (has an active flip animation)
	 *
	 * ```js
	 * if (!Flip.isFlipping("#elementID")) {
	 *   // do stuff
	 * }
	 * ```
	 *
	 * @static
	 * @param {gsap.DOMTarget} target
	 * @returns {boolean} whether or not the target element is actively flipping
	 * @memberof Flip
	 * @link https://greensock.com/docs/v3/Plugins/Flip/static.isFlipping()
	 */
	static isFlipping(target: gsap.DOMTarget): boolean;
	/**
	 * Immediately kills any Flip animations that are running on the target(s) provided, completing them as well (unless "complete" parameter is explicitly false).
	 *
	 * ```js
	 * Flip.killFlipsOf(".box");
	 * ```
	 *
	 * @static
	 * @param {gsap.DOMTarget} targets
	 * @param {boolean} complete
	 * @memberof Flip
	 * @link https://greensock.com/docs/v3/Plugins/Flip/static.killFlipsOf()
	 */
	static killFlipsOf(targets: gsap.DOMTarget, complete?: boolean): void;
	/**
	 * Sets all of the provided target elements to position: absolute while retaining their current positioning.
	 *
	 * ```js
	 * Flip.makeAbsolute(".my-class");
	 * ```
	 *
	 * @static
	 * @param {Element | string | null | ArrayLike<Element | string>} targets
	 * @returns {Element[]} An Array containing the Elements that were affected
	 * @memberof Flip
	 * @link https://greensock.com/docs/v3/Plugins/Flip/static.makeAbsolute()
	 */
	static makeAbsolute(targets: gsap.DOMTarget | Flip.FlipState[]): Element[];
	/**
	 * Animates the targets from the current state to the provided state.
	 *
	 * ```js
	 * Flip.to(state, {
	 *   duration: 1,
	 *   ease: "power1.inOut",
	 *   stagger: 0.1,
	 *   onComplete: () => console.log("done")
	 * });
	 * ```
	 *
	 * @static
	 * @param {Flip.FlipState} state
	 * @param {Flip.FromToVars} [vars]
	 * @returns {gsap.core.Timeline} Flip timeline
	 * @memberof Flip
	 * @link https://greensock.com/docs/v3/Plugins/Flip/static.to()
	 */
	static to(state: Flip.FlipState, vars?: Flip.FromToVars): gsap.core.Timeline;
	/**
	 * Registers Flip with gsap
	 *
	 * @static
	 * @param {typeof gsap} core
	 * @memberof Flip
	 */
	static register(core: typeof gsap): void;
}
declare namespace Flip {
	type OverrideProps<M, N> = {
		[P in keyof M]: P extends keyof N ? N[P] : M[P];
	};
	type EnterOrLeaveCallback = (elements: Element[]) => any;
	type SpinFunction = (index: number, element: Element, targets: Element[]) => number;
	type LoadStateFunction = (load: Function) => any;
	type BatchActionFunction = (self: FlipBatchAction) => any;
	interface TweenVarOverrides {
		scale?: boolean;
	}
	interface AnimationVars extends OverrideProps<gsap.TweenVars, TweenVarOverrides> {
		absolute?: boolean | gsap.DOMTarget;
		simple?: boolean;
		props?: string;
	}
	interface FlipStateVars {
		simple?: boolean;
		props?: string;
	}
	interface StateCompare {
		changed: Element[];
		unchanged: Element[];
		enter: Element[];
		leave: Element[];
	}
	interface FromToVars extends AnimationVars {
		absoluteOnLeave?: boolean;
		prune?: boolean;
		fade?: boolean;
		nested?: boolean;
		onEnter?: EnterOrLeaveCallback;
		onLeave?: EnterOrLeaveCallback;
		spin?: number | boolean | SpinFunction;
		targets?: gsap.DOMTarget;
		toggleClass?: string;
		zIndex?: number;
	}
	interface FitReturnVars {
		width?: number;
		height?: number;
		rotation: number;
		scaleX?: number;
		scaleY?: number;
		skewX: number;
		x: number;
		y: number;
		[key: string]: any;
	}
	interface FitVars extends AnimationVars {
		fitChild?: gsap.DOMTarget;
		getVars?: boolean;
	}
	interface BatchActionConfig {
		getState?: BatchActionFunction;
		loadState?: LoadStateFunction;
		setState?: BatchActionFunction;
		animate?: BatchActionFunction;
		onEnter?: EnterOrLeaveCallback;
		onLeave?: EnterOrLeaveCallback;
		onStart?: BatchActionFunction;
		onComplete?: BatchActionFunction;
		once?: boolean;
	}
	class ElementState {
		readonly bounds: DOMRect;
		readonly cache: object;
		readonly display: string;
		readonly element: Element;
		readonly getProp: Function;
		readonly height: number;
		readonly id: string;
		readonly isVisible: boolean;
		readonly matrix: gsap.plugins.Matrix2D;
		readonly opacity: number;
		readonly parent: Element | null;
		readonly position: string;
		readonly rotation: number;
		readonly scaleX: number;
		readonly scaleY: number;
		readonly simple: boolean;
		readonly skewX: number;
		readonly width: number;
		readonly x: number;
		readonly y: number;
		isDifferent(elState: ElementState): boolean;
	}
	class FlipState {
		readonly alt: object;
		readonly elementStates: ElementState[];
		readonly idLookup: object;
		readonly props: string | null;
		readonly simple: boolean;
		readonly targets: Element[];
		add(state: FlipState): FlipState;
		clear(): FlipState;
		compare(state: FlipState): StateCompare;
		update(soft?: boolean): FlipState;
		fit(state: FlipState, scale?: boolean, nested?: boolean): this;
		recordInlineStyles(): void;
		interrupt(soft?: boolean): void;
		getProperty(element: string | Element, property: string): any;
		getElementState(element: Element): ElementState;
		makeAbsolute(): Element[];
	}
}
declare class FlipBatchAction {
	readonly batch: FlipBatch;
	readonly state: any;
	readonly states: Flip.FlipState[];
	readonly timeline: gsap.core.Timeline;
	readonly targets: any;
	readonly vars: Flip.BatchActionConfig;
	/**
	 * Searches the state objects that were captured inside the action's getState() on its most recent call, and returns the first one it finds that matches the provided data-flip-id value.
	 *
	 * ```js
	 * let state = action.getStateById("box1");
	 * ```
	 * @param {string} id
	 * @memberof FlipBatchAction
	 */
	getStateById(id: string): Flip.FlipState | null;
	/**
	 * Kills the batch action, removing it from its batch.
	 *
	 * @memberof FlipBatchAction
	 */
	kill(): FlipBatchAction;
}
declare class FlipBatch {
	readonly actions: FlipBatchAction[];
	readonly state: Flip.FlipState;
	readonly timeline: gsap.core.Timeline;
	readonly id: string;
	data: any;
	/**
	 * Adds a Flip action to the batch so that MULTIPLE Flips can be combined and run each of their steps together (getState(), loadState(), setState(), animate())
	 *
	 * ```js
	 * batch.add({
	 *     getState: self => Flip.getState(targets),
	 *     loadState: done => done(),
	 *     setState: self => app.classList.toggle("active"),
	 *     animate: self => {
	 *       Flip.from(self.state, {ease: "power1.inOut"});
	 *     },
	 *     onStart: startCallback,
	 *     onComplete: completeCallback,
	 *     onEnter: elements => console.log("entering", elements),
	 *     onLeave: elements => console.log("leaving", elements),
	 *     once: true
	 * });
	 * ```
	 *
	 * @param {BatchActionConfig | Function} config
	 * @returns {FlipBatchAction} A FlipBatchAction
	 * @memberof FlipBatch
	 */
	add(config: Flip.BatchActionConfig | Function): FlipBatchAction;
	/**
	 * Flushes the batch.state (merged) object and removes all actions (unless stateOnly parameter is true)
	 *
	 * ```js
	 * batch.clear(true);
	 * ```
	 *
	 * @param {boolean} stateOnly
	 * @returns {FlipBatch} self
	 * @memberof FlipBatch
	 */
	clear(stateOnly?: boolean): FlipBatch;
	/**
	 * Calls getState() on all actions in this batch (any that are defined at least), optionally merging the results into batch.state
	 *
	 * ```js
	 * batch.getState(true);
	 * ```
	 *
	 * @param {boolean} merge (false by default)
	 * @returns {FlipBatch} self
	 * @memberof FlipBatch
	 */
	getState(merge?: boolean): FlipBatch;
	/**
	 * Searches the state objects that were captured inside ANY of this batch actions' most recent getState() call, and returns the first one it finds that matches the provided data-flip-id value.
	 *
	 * ```js
	 * let state = batch.getStateById("box1");
	 * ```
	 * @param {string} id
	 * @memberof FlipBatch
	 */
	getStateById(id: string): Flip.FlipState | null;
	/**
	 * Kills the batch, unregistering it internally and making it available for garbage collection. Also clears all actions and flushes the batch.state (merged) object.
	 *
	 * @memberof FlipBatch
	 */
	kill(): FlipBatchAction;
	/**
	 * Removes a particular action from the batch.
	 *
	 * ```js
	 * batch.remove(action);
	 * ```
	 *
	 * @param {FlipBatchAction} action
	 * @returns {FlipBatch} self
	 * @memberof FlipBatch
	 */
	remove(action: FlipBatchAction): FlipBatch;
	/**
	 * Executes all actions in the batch in the proper order: getState() (unless skipGetState is true), loadState(), setState(), and animate()
	 *
	 * ```js
	 * batch.run(true);
	 * ```
	 *
	 * @param {boolean} skipGetState
	 * @param {boolean} merge
	 * @returns {FlipBatch} self
	 * @memberof FlipBatch
	 */
	run(skipGetState?: boolean, merge?: boolean): FlipBatch;
}
declare namespace gsap {
	/**
	 * @deprecated since 3.7.0
	 * @see Flip.ElementState
	 */
	type ElementState = any;
	/**
	 * @deprecated since 3.7.0
	 * @see Flip.EnterOrLeaveCallback
	 */
	type EnterOrLeaveCallback = Flip.EnterOrLeaveCallback;
	/**
	 * @deprecated since 3.7.0
	 * @see Flip.FitVars
	 */
	type FitVars = Flip.FitVars;
	/**
	 * @deprecated since 3.7.0
	 * @see Flip.FitReturnVars
	 */
	type FitReturnVars = Flip.FitReturnVars;
	/**
	 * @deprecated since 3.7.0
	 * @see Flip
	 */
	type Flip = any;
	/**
	 * @deprecated since 3.7.0
	 * @see Flip.FlipState
	 */
	type FlipState = any;
	/**
	 * @deprecated since 3.7.0
	 * @see Flip.FlipStateVars
	 */
	type FlipStateVars = Flip.FlipStateVars;
	/**
	 * @deprecated since 3.7.0
	 * @see Flip.FromToVars
	 */
	type FlipToFromVars = Flip.FromToVars;
	/**
	 * @deprecated since 3.7.0
	 * @see Flip.SpinFunction
	 */
	type SpinFunction = Flip.SpinFunction;
}
declare class GSDevTools {
	constructor(target: gsap.DOMTarget, vars?: GSDevTools.Vars);
	/**
	 * Create a GSDevTools instance.
	 *
	 * ```js
	 * GSDevTools.create({animation: tl});
	 * ```
	 *
	 * @param {GSDevTools.Vars} vars
	 * @returns {GSDevTools} The GSDevTools instance
	 * @memberof GSDevTools
	 * @link https://greensock.com/docs/v3/Plugins/GSDevTools/static.create()
	 */
	static create(vars?: GSDevTools.Vars): GSDevTools;
	/**
	 * Returns the GSDevTools instance associated with the provided id.
	 *
	 * ```js
	 * GSDevTools.getById("my-id");
	 * ```
	 *
	 * @param {string} id
	 * @returns {GSDevTools} The GSDevTools instance
	 * @memberof GSDevTools
	 * @link https://greensock.com/docs/v3/Plugins/GSDevTools/static.getById()
	 */
	static getById(id: string): GSDevTools | null;
	/**
	 * Kills a GSDevTools instance
	 *
	 * ```js
	 * tool.kill();
	 * ```
	 *
	 * @memberof GSDevTools
	 * @link https://greensock.com/docs/v3/Plugins/GSDevTools/kill()
	 */
	kill(): void;
}
declare namespace GSDevTools {
	interface Vars {
		[key: string]: any;
		animation?: string | gsap.core.Animation;
		container?: string | Element;
		css?: object | string;
		globalSync?: boolean;
		hideGlobalTimeline?: boolean;
		id?: string;
		inTime?: number | string;
		keyboard?: boolean;
		loop?: boolean;
		minimal?: boolean;
		outTime?: number | string;
		paused?: boolean;
		persist?: boolean;
		timeScale?: number;
		visibility?: string;
	}
}
declare namespace gsap {
	type PluginInit = (this: PluginScope, target: object, endValue: any, tween: core.Tween, index: number, targets: object[]) => void;
	type PluginRender = (this: PropTween, progress: number, data: PluginScope) => void;
	type PluginKill = (this: PluginScope) => void;
	interface PluginAliases {
		[key: string]: string;
	}
	// TODO: Incomplete
	interface PropTween {
		_next: PropTween;
		_prev: PropTween;
		d: PluginScope;
		r: PluginRender;
		t: object;
		modifier(...args: any[]): any; // TODO: Add signature
	}
	interface PluginScope {
		[key: string]: any;
		_props: string[];
		_pt: PropTween;
		add(...args: any[]): PropTween; // TODO: Add signature
		name: string;
		init: PluginInit;
		kill: PluginKill;
		render: PluginRender;
	}
	interface PluginStatic {
		[key: string]: any;
		targetTest(...args: any[]): any; // TODO: Add signature
		get(target: object, prop: string): any; // TODO: Add signature
		getSetter(...args: any[]): any; // TODO: Add signature
		aliases: PluginAliases;
		register(core: typeof gsap): void;
	}
	interface Plugin extends Partial<PluginStatic> {
		name: string;
		init: PluginInit;
		kill?: PluginKill;
		render?: PluginRender;
	}
	interface AttrVars {
		[key: string]: ArrayValue | TweenValue;
	}
	interface ModifiersVars {
		[key: string]: (value: any, target: any) => any;
	}
	interface SnapVars {
		[key: string]: number | number[] | {
			values: number[];
			radius?: number;
		};
	}
	interface TweenVars {
		attr?: AttrVars;
		modifiers?: ModifiersVars;
		snap?: string | SnapVars;
	}
}
declare namespace gsap.plugins {
	interface AttrPlugin extends Plugin {
	}
	interface ModifiersPlugin extends Plugin {
	}
	interface SnapPlugin extends Plugin {
	}
	interface AttrPluginClass extends AttrPlugin {
		new (): PluginScope & AttrPlugin;
		prototype: PluginScope & AttrPlugin;
	}
	interface ModifiersPluginClass extends ModifiersPlugin {
		new (): PluginScope & ModifiersPlugin;
		prototype: PluginScope & ModifiersPlugin;
	}
	interface SnapPluginClass extends SnapPlugin {
		new (): PluginScope & SnapPlugin;
		prototype: PluginScope & SnapPlugin;
	}
	const attr: AttrPluginClass;
	const modifiers: ModifiersPluginClass;
	const snap: SnapPluginClass;
	// Data types shared between plugins
	type RawPath = number[][];
	type Matrix2D = {
		a: number;
		b: number;
		c: number;
		d: number;
		e: number;
		f: number;
	};
}
declare namespace gsap.utils {
	interface DistributeConfig {
		amount?: number;
		axis?: "x" | "y";
		base?: number;
		each?: number;
		ease?: string | EaseFunction;
		from?: "start" | "center" | "end" | "edges" | "random" | number | [
			number,
			number
		];
		grid?: "auto" | [
			number,
			number
		];
	}
	interface SnapNumberConfig {
		increment?: number;
		values?: number[];
		radius: number;
	}
	interface SnapPoint2DConfig {
		values: Point2D[];
		radius: number;
	}
	interface SelectorFunc {
		<K extends keyof HTMLElementTagNameMap>(selectorText: string): Array<HTMLElementTagNameMap[K]>;
		<K extends keyof SVGElementTagNameMap>(selectorText: string): Array<SVGElementTagNameMap[K]>;
		<E extends Element = Element>(selectorText: string): Array<E>;
	}
	/**
	 * Prefixes the provided CSS property if necessary. Returns null if the property isn't supported at all.
	 *
	 * ```js
	 * // The following may return "filter", "WebkitFilter", or "MozFilter" depending on the browser
	 * let filterProperty = gsap.utils.checkPrefix("filter");
	 * ```
	 *
	 * @param {string} property
	 * @returns {string | null} The appropriately prefixed property
	 * @memberof gsap.utils
	 */
	function checkPrefix(property: string): string;
	/**
	 * Clamps a number between a given minimum and maximum.
	 *
	 * ```js
	 * gsap.utils.clamp(0, 100, 105); // returns 100
	 *
	 * const clamper = gsap.utils.clamp(0, 100); // no value = reusable function
	 * console.log(clamper(105)); // returns 100
	 * ```
	 *
	 * @param {number} minimum
	 * @param {number} maximum
	 * @param {number} [valueToClamp]
	 * @returns {number | Function} The clamped number or function to clamp to given range
	 * @memberof gsap.utils
	 */
	function clamp(minimum: number, maximum: number, valueToClamp: number): number;
	function clamp(minimum: number, maximum: number): (valueToClamp: number) => number;
	/**
	 * Returns a function to distribute an array of values based on the inputs that you give it.
	 *
	 * ```js
	 * gsap.utils.distribute({
	 *   base: 50,
	 *   amount: 100,
	 *   from: "center",
	 *   grid: "auto",
	 *   axis: "y",
	 *   ease: "power1.inOut"
	 * });
	 * ```
	 *
	 * @param {DistributeConfig} config
	 * @returns {FunctionBasedValue<number>} The clamped number or function to clamp to given range
	 * @memberof gsap.utils
	 */
	function distribute(config: DistributeConfig): FunctionBasedValue<number>;
	/**
	 * Returns unit of a given string where the number comes first, then the unit.
	 *
	 * ```js
	 * gsap.utils.getUnit("50%"); // "%"
	 * ```
	 *
	 * @param {string} value
	 * @returns {string} The unit
	 * @memberof gsap.utils
	 */
	function getUnit(value: string): string;
	/**
	 * Linearly interpolates between any two values of a similar type.
	 *
	 * ```js
	 * gsap.utils.interpolate(0, 500, 0.5); // 250
	 *
	 * const interp = gsap.utils.interpolate(0, 100); // no value = reusable function
	 * console.log( interp(0.5) ); // 50
	 * ```
	 *
	 * @param {T} startValue
	 * @param {T} endValue
	 * @returns {T | Function<number>} The interpolated value or interpolate function
	 * @memberof gsap.utils
	 */
	function interpolate<T>(startValue: T, endValue: T, progress: number): T;
	function interpolate<T>(startValue: T, endValue: T): (progress: number) => T;
	/**
	 * Linearly interpolates between any two values of a similar type.
	 *
	 * ```js
	 * gsap.utils.interpolate([100, 50, 500], 0.5); // 50
	 *
	 * c interp = gsap.utils.interpolate([100, 50, 500]); // no value = reusable function
	 * console.log( interp(0.5) ); // 50
	 * ```
	 *
	 * @param {T[]} array
	 * @param {number} progress
	 * @returns {T | Function} The interpolated value or interpolate function
	 * @memberof gsap.utils
	 */
	function interpolate<T>(array: T[], progress: number): T;
	function interpolate<T>(array: T[]): (progress: number) => T;
	/**
	 * Maps a number's relative placement within one range to the equivalent position in another range.
	 *
	 * ```js
	 * gsap.utils.mapRange(-10, 10, 100, 200, 0); // 150
	 *
	 * const mapper = gsap.utils.mapRange(0, 100, 0, 250); // no value = reusable function
	 * console.log( mapper(50) ); // 250
	 * ```
	 *
	 * @param {number} inMin
	 * @param {number} inMax
	 * @param {number} outMin
	 * @param {number} outMax
	 * @param {number} [value]
	 * @returns {number | Function} The mapped value or map function
	 * @memberof gsap.utils
	 */
	function mapRange(inMin: number, inMax: number, outMin: number, outMax: number, value: number): number;
	function mapRange(inMin: number, inMax: number, outMin: number, outMax: number): (value: number) => number;
	/**
	 * Maps a value within a provided range to the corresponding position in the range between 0 and 1.
	 *
	 * ```js
	 * gsap.utils.normalize(-10, 10, 0); // 0.5
	 *
	 * const clamper = gsap.utils.normalize(0, 100); // no value = reusable function
	 * console.log( clamper(50) ); // 0.5
	 * ```
	 *
	 * @param {number} inMin
	 * @param {number} inMax
	 * @param {number} [value]
	 * @returns {number | Function} The normalized value or normalizer function
	 * @memberof gsap.utils
	 */
	function normalize(inMin: number, inMax: number, value: number): number;
	function normalize(inMin: number, inMax: number): (value: number) => number;
	/**
	 * Strings together multiple function calls, passing the result from one to the next.
	 * You can pass in as many function references as you'd like!
	 *
	 * ```js
	 * const transfrom = gsap.utils.pipe(func1, func2, func3); // reusable function
	 * const output = transform(input);
	 * ```
	 *
	 * @memberof gsap.utils
	 */
	function pipe<A extends Array<unknown>, B>(ab: (...a: A) => B): (...a: A) => B;
	function pipe<A extends Array<unknown>, B, C>(ab: (...a: A) => B, bc: (b: B) => C): (...a: A) => C;
	function pipe<A extends Array<unknown>, B, C, D>(ab: (...a: A) => B, bc: (b: B) => C, cd: (c: C) => D): (...a: A) => D;
	function pipe<A extends Array<unknown>, B, C, D, E>(ab: (...a: A) => B, bc: (b: B) => C, cd: (c: C) => D, de: (d: D) => E): (...a: A) => E;
	function pipe<A extends Array<unknown>, B, C, D, E, F>(ab: (...a: A) => B, bc: (b: B) => C, cd: (c: C) => D, de: (d: D) => E, ef: (e: E) => F): (...a: A) => F;
	function pipe<A extends Array<unknown>, B, C, D, E, F, G>(ab: (...a: A) => B, bc: (b: B) => C, cd: (c: C) => D, de: (d: D) => E, ef: (e: E) => F, fg: (f: F) => G): (...a: A) => G;
	function pipe<A extends Array<unknown>, B, C, D, E, F, G, H>(ab: (...a: A) => B, bc: (b: B) => C, cd: (c: C) => D, de: (d: D) => E, ef: (e: E) => F, fg: (f: F) => G, gh: (g: G) => H): (...a: A) => H;
	function pipe<A extends Array<unknown>, B, C, D, E, F, G, H, I>(ab: (...a: A) => B, bc: (b: B) => C, cd: (c: C) => D, de: (d: D) => E, ef: (e: E) => F, fg: (f: F) => G, gh: (g: G) => H, hi: (h: H) => I): (...a: A) => I;
	function pipe<A extends Array<unknown>, B, C, D, E, F, G, H, I, J>(ab: (...a: A) => B, bc: (b: B) => C, cd: (c: C) => D, de: (d: D) => E, ef: (e: E) => F, fg: (f: F) => G, gh: (g: G) => H, hi: (h: H) => I, ij: (i: I) => J): (...a: A) => J;
	/**
	 * Get a random number within a range, optionally rounding to an increment you provide.
	 *
	 * ```js
	 * gsap.utils.random(-100, 100);
	 * gsap.utils.random(0, 500, 5); // snapped to the nearest value of 5
	 *
	 * const random = gsap.utils.random(-200, 500, 10, true); // reusable function
	 * console.log( random() );
	 * ```
	 *
	 * @param {number} minValue
	 * @param {number} maxValue
	 * @param {number} [snapIncrement]
	 * @param {boolean} [returnFunction]
	 * @returns {number | Function} The random number or random number generator function
	 * @memberof gsap.utils
	 */
	function random(minValue: number, maxValue: number, snapIncrement?: number): number;
	function random<T extends boolean>(minValue: number, maxValue: number, returnFunction?: T): T extends true ? () => number : number;
	function random<T extends boolean>(minValue: number, maxValue: number, snapIncrement: number, returnFunction?: T): T extends true ? () => number : number;
	/**
	 * Get a random random element in an array.
	 *
	 * ```js
	 * gsap.utils.random(["red", "blue", "green"]); //"red", "blue", or "green"
	 *
	 * const random = gsap.utils.random([0, 100, 200], true);
	 * console.log( random() ); // 0, 100, or 200 (randomly selected)
	 * ```
	 *
	 * @param {T[]} array
	 * @param {boolean} [returnFunction]
	 * @returns {number | Function} The random number or random number generator function
	 * @memberof gsap.utils
	 */
	function random<T>(array: T[]): T;
	function random<T, U extends boolean>(array: T[], returnFunction?: U): U extends true ? () => T : T;
	/**
	 * Returns a selector function that is scoped to a particular Element.
	 *
	 * ```js
	 * const q = gsap.utils.selector("#id");
	 * const q = gsap.utils.selector(myElement);
	 * gsap.to(q(".class"), {x: 100});
	 * ```
	 *
	 * @param {Element | object | string} scope
	 * @returns {SelectorFunc} A selector function
	 * @memberof gsap.utils
	 */
	function selector(scope: Element | object | string | null): SelectorFunc;
	/**
	 * Takes an array and randomly shuffles it, returning the same (but shuffled) array.
	 *
	 * ```js
	 * gsap.utils.shuffle(array);
	 * ```
	 *
	 * @param {T[]} array
	 * @returns {T[]} The same shuffled array
	 * @memberof gsap.utils
	 */
	function shuffle<T>(array: T[]): T[];
	/**
	 * Snaps a value to the nearest increment of the number provided.
	 * Or snaps to a value in the given array.
	 * Or snaps to a value within the given radius (if an object is provided).
	 * Or returns a function that does the above (if the second value is not provided).
	 *
	 * ```js
	 * gsap.utils.snap(10, 23.5); // 20
	 * gsap.utils.snap([100, 50, 500], 65); // 50
	 * gsap.utils.snap({values:[0, 100, 300], radius:20}, 30.5); // 30.5
	 * gsap.utils.snap({increment:500, radius:150}, 310); // 310
	 *
	 * const snap = gsap.utils.snap(5); // no value = reusable function
	 * console.log( snap(0.5) ); // 0
	 * ```
	 *
	 * @param {SnapNumberConfig} snapConfig
	 * @param {number} [valueToSnap]
	 * @returns {number | Function} The snapped number or snap function
	 * @memberof gsap.utils
	 */
	function snap(snapConfig: number | number[] | SnapNumberConfig, valueToSnap: number): number;
	function snap(snapConfig: number | number[] | SnapNumberConfig): (valueToSnap: number) => number;
	/**
	 * Snaps a value if within the given radius of a points (objects with "x" and "y" properties).
	 * Or returns a function that does the above (if the second value is not provided).
	 *
	 * ```js
	 *
	 * gsap.utils.snap({values:[0, 100, 300], radius:20}, 85); // 100
	 *
	 * const snap = gsap.utils.snap({values:[{x:0, y:0}, {x:10, y:10}, {x:20, y:20}], radius:5}); // no value = reusable function
	 * console.log( snap({x:8, y:8}) ); // {x:10, y:10}
	 * ```
	 *
	 * @param {SnapPoint2DConfig} snapConfig
	 * @param {number} [valueToSnap]
	 * @returns {Point2D | Function} The snapped number or snap function
	 * @memberof gsap.utils
	 */
	function snap(snapConfig: SnapPoint2DConfig, valueToSnap: Point2D): Point2D;
	function snap(snapConfig: SnapPoint2DConfig): (valueToSnap: Point2D) => Point2D;
	/**
	 * Converts a string-based color value into an array consisting of RGB(A) or HSL values.
	 *
	 * ```js
	 * gsap.utils.splitColor("red"); // [255, 0, 0]
	 * gsap.utils.splitColor("rgba(204, 153, 51, 0.5)"); // [204, 153, 51, 0.5]
	 *
	 * gsap.utils.splitColor("#6fb936", true); // [94, 55, 47] - HSL value
	 * ```
	 *
	 * @param {string} color
	 * @param {boolean} [hsl]
	 * @returns {[number, number, number] | [number, number, number, number]} The converted color array
	 * @memberof gsap.utils
	 */
	function splitColor(color: string, hsl?: boolean): [
		number,
		number,
		number
	] | [
		number,
		number,
		number,
		number
	];
	/**
	 * Converts almost anything into a flat Array.
	 *
	 * ```js
	 * const targets = gsap.utils.toArray(".class");
	 * const targets = gsap.utils.toArray(myElement);
	 * const targets = gsap.utils.toArray($(".class"));
	 * const targets = gsap.utils.toArray([".class1", ".class2"]);
	 * ```
	 *
	 * @param {string | object | Element | null} value
	 * @param {object} [scope]
	 * @param {boolean} [leaveStrings]
	 * @returns {T[]} The converted Array
	 * @memberof gsap.utils
	 */
	function toArray<T>(value: string | object | Element | null, scope?: object | null, leaveStrings?: boolean): T[];
	/**
	 * Ensures that a specific unit gets applied.
	 *
	 * ```js
	 * const clamp = gsap.utils.unitize( gsap.utils.clamp(0, 100), "px");
	 * clamp(132); // "100px"
	 *
	 * gsap.to(".class", {
	 *   x: 1000,
	 *   modifiers: {
	 *     x: gsap.utils.unitize( gsap.utils.wrap(0, window.innerWidth), "px")
	 *   }
	 * });
	 * ```
	 *
	 * @param {Function} fn
	 * @param {string} [unit]
	 * @returns {string} The value with unit added
	 * @memberof gsap.utils
	 */
	function unitize<T extends Array<unknown>>(fn: (...args: T) => unknown, unit?: string): (...args: T) => string;
	/**
	 * Returns the next number in a range after the given index, jumping to the start after the end has been reached.
	 *
	 * ```js
	 * let color = gsap.utils.wrap(["red", "green", "yellow"], 5); // "yellow"
	 *
	 * let wrapper = gsap.utils.wrap(["red", "green", "yellow"]); // no value = reusable function
	 * let color = wrapper(5) // "yellow"
	 * ```
	 *
	 * @param {number} value1
	 * @param {number} value2
	 * @param {number} [index]
	 * @returns {string} The wrapped value or wrap function
	 * @memberof gsap.utils
	 */
	function wrap(value1: number, value2: number, index: number): number;
	function wrap(value1: number, value2: number): (index: number) => number;
	/**
	 * Returns the next item in an array after the given index, jumping to the start after the end has been reached.
	 *
	 * ```js
	 * let color = gsap.utils.wrap(["red", "green", "yellow"], 5); // "yellow"
	 *
	 * let wrapper = gsap.utils.wrap(["red", "green", "yellow"]); // no value = reusable function
	 * let color = wrapper(5) // "yellow"
	 * ```
	 *
	 * @param {T[]} values
	 * @param {number} [index]
	 * @returns {string} The wrapper value or wrap function
	 * @memberof gsap.utils
	 */
	function wrap<T>(values: T[], index: number): T;
	function wrap<T>(values: T[]): (index: number) => T;
	/**
	 * Returns the next number in a range after the given index, wrapping backwards towards the start after the end has been reached.
	 *
	 * ```js
	 * let color = gsap.utils.wrap(["red", "green", "yellow"], 5); // "yellow"
	 *
	 * let wrapper = gsap.utils.wrap(["red", "green", "yellow"]); // no value = reusable function
	 * let color = wrapper(5) // "yellow"
	 * ```
	 *
	 * @param {number} value1
	 * @param {number} value2
	 * @param {number} [index]
	 * @returns {string} The wrapped value or wrap function
	 * @memberof gsap.utils
	 */
	function wrapYoyo(value1: number, value2: number, index: number): number;
	function wrapYoyo(value1: number, value2: number): (index: number) => number;
	/**
	 * Returns the next item in an array after the given index, wrapping backwards towards the start after the end has been reached.
	 *
	 * ```js
	 * let color = gsap.utils.wrap(["red", "green", "yellow"], 5); // "yellow"
	 *
	 * let wrapper = gsap.utils.wrap(["red", "green", "yellow"]); // no value = reusable function
	 * let color = wrapper(5) // "yellow"
	 * ```
	 *
	 * @param {T[]} values
	 * @param {number} [index]
	 * @returns {string} The wrapper value or wrap function
	 * @memberof gsap.utils
	 */
	function wrapYoyo<T>(values: T[], index: number): T;
	function wrapYoyo<T>(values: T[]): (index: number) => T;
}
declare namespace gsap {
	type InertiaEndFunction<T> = (value: T) => T;
	interface InertiaDuration {
		min?: number;
		max?: number;
		overshoot?: number;
	}
	interface InertiaLinkedProps {
		[key: string]: number;
	}
	interface InertiaObject {
		min?: number;
		max?: number;
		end?: number | number[] | InertiaEndFunction<any>;
		// end?: number | number[] | InertiaEndFunction<number> | InertiaEndFunction<InertiaLinkedProps>; 
		velocity?: number | "auto";
	}
	type InertiaVars = {
		duration?: number | InertiaDuration;
		linkedProps?: string;
		resistance?: number;
	} & {
		[key: string]: TweenValue | InertiaObject;
	};
	interface TweenVars {
		inertia?: InertiaVars;
	}
}
declare namespace gsap.plugins {
	interface InertiaPlugin extends Plugin, VelocityTrackerStatic {
		// TODO add missing methods
		// TODO improve docs on site as well
		/**
		 * Returns the current velocity of the given property and target object (only works if you started tracking the property using the InertiaPlugin.track() method).
		 *
		 * ```js
		 * InertiaPlugin.getVelocity(obj, "x,y");
		 * ```
		 *
		 * @param {Element} target
		 * @param {string} props
		 * @returns {number} The current velocity
		 * @memberof InertiaPlugin
		 * @link https://greensock.com/docs/v3/Plugins/InertiaPlugin/static.getVelocity()
		 */
		getVelocity(target: Element, props: string): number;
	}
	interface InertiaPluginClass extends InertiaPlugin {
		new (): PluginScope & InertiaPlugin;
		prototype: PluginScope & InertiaPlugin;
	}
	const inertia: InertiaPluginClass;
}
declare namespace gsap {
	interface TweenVars {
		morphSVG?: SVGPathValue | gsap.plugins.MorphSVGVars;
	}
}
declare namespace gsap.plugins {
	interface MorphSVGPlugin extends Plugin {
		defaultRender?: Function;
		defaultType?: String;
		defaultUpdateTarget?: Boolean;
		/**
		 * Converts SVG shapes into <path>s.
		 *
		 * ```js
		 * MorphSVGPlugin.convertToPath("circle");
		 * ```
		 *
		 * @param {DOMTarget} shape
		 * @param {boolean} [swap]
		 * @returns {SVGPathElement[]} The converted paths
		 * @memberof MorphSVGPlugin
		 * @link https://greensock.com/docs/v3/Plugins/MorphSVGPlugin/static.convertToPath()
		 */
		convertToPath(shape: string | SVGPrimitive | (string | SVGPrimitive)[], swap?: boolean): SVGPathElement[];
		/**
		 * Returns a RawPath associated with whatever is passed in (path data string, selector text, <path> element, or a RawPath)
		 *
		 * ```js
		 * MorphSVGPlugin.getRawPath("#my-path");
		 * ```
		 *
		 * @param {SVGPathValue} path
		 * @returns {array} The RawPath
		 * @memberof MorphSVGPlugin
		 * @link https://greensock.com/docs/v3/Plugins/MorphSVGPlugin/static.getRawPath()
		 */
		getRawPath(path: SVGPathValue): string[];
		/**
		 * Accepts two strings representing SVG path data and matches the number of points between them, returning an Array with the edited path data strings [shape1, shape2].
		 *
		 * ```js
		 * MorphSVGPlugin.normalizeStrings(shape1, shape2, {map: "complexity"});
		 * ```
		 *
		 * @param {string} shape1
		 * @param {string} shape2
		 * @param {NormalizeVars} config
		 * @returns {string[]} An Array containing the converted string data with matching numbers of points, like [shape1, shape2]
		 * @memberof MorphSVGPlugin
		 * @link https://greensock.com/docs/v3/Plugins/MorphSVGPlugin/static.normalizeStrings()
		 */
		normalizeStrings(shape1: string, shape2: string, config?: NormalizeVars): string[];
		/**
		 * Converts a RawPath into a string of path data.
		 *
		 * ```js
		 * MorphSVGPlugin.rawPathToString(myRawPath);
		 * ```
		 *
		 * @param {RawPath} rawPath
		 * @returns {string} The converted path data
		 * @memberof MorphSVGPlugin
		 * @link https://greensock.com/docs/v3/Plugins/MorphSVGPlugin/static.rawPathToString()
		 */
		rawPathToString(rawPath: RawPath): string;
		/**
		 * Converts a string of path data into a RawPath.
		 *
		 * ```js
		 * MorphSVGPlugin.stringToRawPath("M0,0 C100,20 300,50 400,0...");
		 * ```
		 *
		 * @param {string} data
		 * @returns {RawPath} The converted RawPath
		 * @memberof MorphSVGPlugin
		 * @link https://greensock.com/docs/v3/Plugins/MorphSVGPlugin/static.stringToRawPath()
		 */
		stringToRawPath(data: string): RawPath;
	}
	interface NormalizeVars {
		shapeIndex?: number | "auto" | number[];
		map?: "complexity" | "position" | "size";
	}
	interface MorphSVGPluginClass extends MorphSVGPlugin {
		new (): PluginScope & MorphSVGPlugin;
		prototype: PluginScope & MorphSVGPlugin;
	}
	interface MorphSVGVars {
		shape: SVGPathValue;
		type?: "rotational" | "linear";
		origin?: string;
		shapeIndex?: number | "auto" | number[];
		precompile?: "log" | string[];
		map?: "size" | "position" | "complexity";
		render?: Function;
		updateTarget?: boolean;
	}
	const morphSVG: MorphSVGPluginClass;
}
declare namespace gsap {
	interface PathObject {
		[propName: string]: number;
	}
	interface TweenVars {
		motionPath?: SVGPathValue | TweenValue | Point2D[] | PathObject[] | MotionPath.Vars;
	}
}
declare namespace gsap.plugins {
	interface ArrayToRawPathObject {
		curviness?: number;
		relative?: boolean;
		type?: string;
		x?: string;
		y?: string;
	}
	interface getRelativePositionObject extends gsap.Point2D {
		angle: number;
	}
	interface MotionPathPlugin extends Plugin {
		/**
		 * Takes an array of coordinates and plots a curve through them.
		 *
		 * ```js
		 * MotionPathPlugin.arrayToRawPath(anchors, {curviness:0.5})
		 * ```
		 *
		 * @param {Point2D[]} values
		 * @param {ArrayToRawPathObject} vars
		 * @returns {RawPath} The converted rawPath
		 * @memberof MotionPathPlugin
		 * @link https://greensock.com/docs/v3/Plugins/MotionPathPlugin/static.arrayToRawPath()
		 */
		arrayToRawPath(values: Point2D[], vars?: ArrayToRawPathObject): RawPath;
		/**
		 * Measures the path and caches the values on the RawPath itself for fast and accurate subsequent processing.
		 *
		 * ```js
		 * MotionPathPlugin.cacheRawPathMeasurements(rawPath);
		 * ```
		 *
		 * @param {RawPath} rawPath
		 * @param {number} resolution
		 * @returns {RawPath} the RawPath that was passed in
		 * @memberof MotionPathPlugin
		 */
		cacheRawPathMeasurements(rawPath: RawPath, resolution?: number): RawPath;
		/**
		 * Gets the matrix to convert points from one element's local coordinates into a
		 * different element's local coordinate system.
		 *
		 * ```js
		 * MotionPathPlugin.convertCoordinates(fromElement, toElement);
		 * ```
		 *
		 * @param {Element} fromElement
		 * @param {Element} toElement
		 * @returns {Matrix2D} A matrix to convert from one element's coordinate system to another's
		 * @memberof MotionPathPlugin
		 * @link https://greensock.com/docs/v3/Plugins/MotionPathPlugin/static.convertCoordinates()
		 */
		convertCoordinates(fromElement: Element, toElement: Element): Matrix2D;
		/**
		 * Converts a point from one element's local coordinates into a
		 * different element's local coordinate system.
		 *
		 * ```js
		 * MotionPathPlugin.convertCoordinates(fromElement, toElement, point);
		 * ```
		 *
		 * @param {Element} fromElement
		 * @param {Element} toElement
		 * @param {Point2D} point
		 * @returns {Point2D} the converted point
		 * @memberof MotionPathPlugin
		 * @link https://greensock.com/docs/v3/Plugins/MotionPathPlugin/static.convertCoordinates()
		 */
		convertCoordinates(fromElement: Element, toElement: Element, point: Point2D): Point2D;
		/**
		 * Converts SVG shapes into <path>s.
		 *
		 * ```js
		 * MotionPathPlugin.convertToPath("circle");
		 * ```
		 *
		 * @param {DOMTarget} shape
		 * @param {boolean} [swap]
		 * @returns {SVGPathElement[]} The converted paths
		 * @memberof MotionPathPlugin
		 * @link https://greensock.com/docs/v3/Plugins/MotionPathPlugin/static.convertToPath()
		 */
		convertToPath(shape: SVGPathTarget, swap?: boolean): SVGPathElement[];
		/**
		 * Gets the matrix to convert points from one element's local coordinates into a
		 * different element's local coordinate system.
		 *
		 * ```js
		 * MotionPathPlugin.getAlignMatrix(fromElement, toElement);
		 * ```
		 *
		 * @param {Element} fromElement
		 * @param {Element} toElement
		 * @param {number[] | Point2D} [fromOrigin]
		 * @param {number[] | Point2D | "auto"} [toOrigin]
		 * @returns {Matrix2D} A matrix to convert from one element's coordinate system to another's
		 * @memberof MotionPathPlugin
		 * @link https://greensock.com/docs/v3/Plugins/MotionPathPlugin/static.getAlignMatrix()
		 */
		getAlignMatrix(fromElement: Element, toElement: Element, fromOrigin?: number[] | Point2D, toOrigin?: number[] | Point2D | "auto"): Matrix2D;
		/**
		 * Gets the Matrix2D that would be used to convert the element's local coordinate
		 * space into the global coordinate space.
		 *
		 * ```js
		 * MotionPathPlugin.getGlobalMatrix(element);
		 * ```
		 *
		 * @param {Element} element
		 * @param {Boolean} [inverse]
		 * @param {Boolean} [adjustGOffset]
		 * @returns {Matrix2D} A matrix to convert from one element's coordinate system to another's
		 * @memberof MotionPathPlugin
		 * @link https://greensock.com/docs/v3/Plugins/MotionPathPlugin/static.getGlobalMatrix()
		 */
		getGlobalMatrix(element: Element, inverse?: boolean, adjustGOffset?: boolean): Matrix2D;
		/**
		 * Calculates the x/y position (and optionally the angle) corresponding to a
		 * particular progress value along the RawPath.
		 *
		 * ```js
		 * MotionPathPlugin.getPositionOnPath(rawPath, 0.5);
		 * ```
		 *
		 * @param {RawPath} rawPath
		 * @param {Number} progress
		 * @param {Boolean} [includeAngle]
		 * @returns {Matrix2D} A matrix to convert from one element's coordinate system to another's
		 * @memberof MotionPathPlugin
		 * @link https://greensock.com/docs/v3/Plugins/MotionPathPlugin/static.getPositionOnPath()
		 */
		getPositionOnPath(rawPath: RawPath, progress: number, includeAngle?: boolean): Point2D | getRelativePositionObject;
		/**
		 * Gets the RawPath for the provided element or raw SVG <path> data.
		 *
		 * ```js
		 * MotionPathPlugin.getRawPath(element);
		 * ```
		 *
		 * @param {DOMTarget} value
		 * @returns {RawPath} The rawPath
		 * @memberof MotionPathPlugin
		 * @link https://greensock.com/docs/v3/Plugins/MotionPathPlugin/static.getRawPath()
		 */
		getRawPath(value: SVGPathValue): RawPath;
		/**
		 * Gets the x and y distances between two elements regardless of nested transforms.
		 *
		 * ```js
		 * MotionPathPlugin.getRelativePosition(dot, inner, [0.5, 0.5], [0.5, 0.5]);
		 * ```
		 *
		 * @param {Element} fromElement
		 * @param {Element} toElement
		 * @param {number[] | Point2D[]} [fromOrigin]
		 * @param {number[] | Point2D[] | "auto"} [toOrigin]
		 * @returns {Point2D} The x and y between the references given
		 * @memberof MotionPathPlugin
		 * @link https://greensock.com/docs/v3/Plugins/MotionPathPlugin/static.getRelativePosition()
		 */
		getRelativePosition(fromElement: Element, toElement: Element, fromOrigin?: number[] | Point2D, toOrigin?: number[] | Point2D | "auto"): Point2D;
		/**
		 * Gets the x and y distances between two elements regardless of nested transforms.
		 *
		 * ```js
		 * MotionPathPlugin.pointsToSegment([0,0, 10,10, ...], 0.5);
		 * ```
		 *
		 * @param {number[]} points
		 * @param {number} [curviness]
		 * @returns {number[]} Cubic Bezier data in alternating x, y, x, y format
		 * @memberof MotionPathPlugin
		 * @link https://greensock.com/docs/v3/Plugins/MotionPathPlugin/static.pointsToSegment()
		 */
		pointsToSegment(points: number[], curviness?: number): number[];
		/**
		 * Converts a RawPath to a path string.
		 *
		 * ```js
		 * MotionPathPlugin.rawPathToString(rawPath);
		 * ```
		 *
		 * @param {RawPath} rawPath
		 * @returns {string} The converted path
		 * @memberof MotionPathPlugin
		 * @link https://greensock.com/docs/v3/Plugins/MotionPathPlugin/static.rawPathToString()
		 */
		rawPathToString(rawPath: RawPath): string;
		/**
		 * Slices a RawPath into a smaller RawPath.
		 *
		 * ```js
		 * MotionPathPlugin.sliceRawPath(rawPath, 0, 3);
		 * ```
		 *
		 * @param {RawPath} rawPath
		 * @param {number} start
		 * @param {number} end
		 * @returns {RawPath} The sliced RawPath
		 * @memberof MotionPathPlugin
		 * @link https://greensock.com/docs/v3/Plugins/MotionPathPlugin/static.sliceRawPath()
		 */
		sliceRawPath(rawPath: RawPath, start: number, end: number): RawPath;
		/**
		 * Converts a string of path data into a rawPath.
		 *
		 * ```js
		 * MotionPathPlugin.stringToRawPath("M0,0 C100,20 300,50 400,0...");
		 * ```
		 *
		 * @param {string} data
		 * @returns {RawPath} The converted RawPath
		 * @memberof MotionPathPlugin
		 * @link https://greensock.com/docs/v3/Plugins/MotionPathPlugin/static.stringToRawPath()
		 */
		stringToRawPath(data: string): RawPath;
	}
	interface MotionPathPluginClass extends MotionPathPlugin {
		new (): PluginScope & MotionPathPlugin;
		prototype: PluginScope & MotionPathPlugin;
	}
	const motionPath: MotionPathPluginClass;
}
declare namespace MotionPath {
	interface Vars {
		align?: string | Element;
		alignOrigin?: number[];
		autoRotate?: boolean | number;
		curviness?: number;
		end?: number;
		offsetX?: number;
		offsetY?: number;
		path?: gsap.SVGPathValue | gsap.TweenValue | gsap.Point2D[] | gsap.PathObject[];
		relative?: boolean;
		resolution?: number;
		start?: number;
		type?: string;
		useRadians?: boolean;
		fromCurrent?: boolean;
	}
}
declare class MotionPathHelper {
	constructor(target: gsap.DOMTarget, vars?: MotionPathHelper.Vars);
	/**
	 * Kills the MotionPathHelper instance, removing the editing elements from the DOM.
	 *
	 * ```js
	 * myHelper.kill();
	 * ```
	 *
	 * @memberof MotionPathHelper
	 * @link https://greensock.com/docs/v3/Plugins/MotionPathHelper/kill()
	 */
	kill(): void;
	/**
	 * Create a MotionPathHelper instance.
	 *
	 * ```js
	 * MotionPathHelper.create(".myClass");
	 * ```
	 *
	 * @param {gsap.DOMTarget} target
	 * @param {MotionPathHelper.Vars} [vars]
	 * @returns {MotionPathHelper} The MotionPathHelper instance
	 * @memberof MotionPathHelper
	 * @link https://greensock.com/docs/v3/Plugins/MotionPathHelper
	 */
	static create(target: gsap.DOMTarget, vars?: MotionPathHelper.Vars): MotionPathHelper;
	/**
	 * Makes an SVG <path> editable in the browser.
	 *
	 * ```js
	 * MotionPathHelper.editPath(".myClass", {
	 *     onPress: () => console.log("press"),
	 *     onRelease: () => console.log("release"),
	 *     onUpdate: () => console.log("update")
	 * });
	 * ```
	 *
	 * @param {gsap.DOMTarget} target
	 * @param {MotionPathHelper.EditPathVars} [vars]
	 * @returns {object} A PathEditor instance
	 * @memberof MotionPathHelper
	 * @link https://greensock.com/docs/v3/Plugins/MotionPathHelper/static.editPath()
	 */
	static editPath(target: gsap.DOMTarget, vars?: MotionPathHelper.EditPathVars): MotionPathHelper;
}
declare namespace MotionPathHelper {
	interface Vars {
		[key: string]: any;
		ease?: string | gsap.EaseFunction;
		end?: number;
		duration?: number;
		path?: gsap.DOMTarget;
		pathColor?: gsap.TweenValue;
		pathWidth?: number;
		pathOpacity?: number;
		selected?: boolean;
		start?: number;
	}
	interface EditPathVars {
		[key: string]: any;
		anchorSnap?: Function;
		callbackScope?: object;
		draggable?: boolean;
		handleSize?: number;
		handleSnap?: Function;
		onDeleteAnchor?: Function;
		onPress?: Function;
		onRelease?: Function;
		onUpdate?: Function;
		selected?: boolean;
	}
}
declare class Observer {
	static readonly isTouch: number;
	static readonly eventTypes: string[];
	static readonly version: string;
	readonly deltaX: number;
	readonly deltaY: number;
	readonly event: Event;
	readonly isDragging: boolean;
	readonly isEnabled: boolean;
	readonly isPressed: boolean;
	readonly startX?: number;
	readonly startY?: number;
	readonly target: Element;
	readonly vars: Observer.ObserverVars;
	readonly velocityX: number;
	readonly velocityY: number;
	readonly x?: number;
	readonly y?: number;
	readonly axis?: string | null;
	/**
	 * Creates a new Observer
	 *
	 * ```js
	 * Observer.create({
	 *   target: "#id",
	 *   onUp: () => console.log("up"),
	 *   onDown: () => console.log("down"),
	 *   onPress: () => console.log("press")
	 * });
	 * ```
	 *
	 * @static
	 * @param {Observer.ObserverVars} vars
	 * @returns {Observer} The Observer
	 * @memberof Observer
	 * @link https://greensock.com/docs/v3/Plugins/Observer/static.create()
	 */
	static create(vars: Observer.ObserverVars): Observer;
	/**
	 * Gets all Observers (that haven't been killed)
	 *
	 * ```js
	 * Observer.getAll().forEach(o => o.kill());
	 * ```
	 *
	 * @static
	 * @returns {Observer[]} An Array of Observers
	 * @memberof Observer
	 * @link https://greensock.com/docs/v3/Plugins/Observer/static.getAll()
	 */
	static getAll(): Observer[];
	/**
	 * Gets the observer with the id provided.
	 *
	 * ```js
	 * let o = Observer.getById("my-id");
	 * ```
	 *
	 * @static
	 * @param {string} id
	 * @returns {Observer | undefined} The Observer with the supplied id (if one exists)
	 * @memberof Observer
	 * @link https://greensock.com/docs/v3/Plugins/Observer/static.getAll()
	 */
	static getById(id: string): Observer | undefined;
	/**
	 * Disables a Observer instance.
	 *
	 * ```js
	 * observer.disable();
	 * ```
	 */
	disable(): void;
	/**
	 * Re-enables a disabled Observer instance.
	 *
	 * ```js
	 * observer.enable();
	 * ```
	 */
	enable(): this;
	/**
	 * Kills a Observer instance (same as disabling, but typically permanent).
	 *
	 * ```js
	 * observer.kill();
	 * ```
	 */
	kill(): void;
	/**
	 * Gets the horizontal scroll position of the target (typically scrollLeft).
	 *
	 * ```js
	 * observer.scrollX();
	 * ```
	 *
	 * @returns {number} The horizontal scroll position of the target
	 */
	scrollX(): number;
	/**
	 * Sets the horizontal scroll position of the target (typically scrollTop).
	 *
	 * ```js
	 * observer.scrollX(100);
	 * ```
	 *
	 * @param {number} position
	 */
	scrollX(position: number): void;
	/**
	 * Gets the vertical scroll position of the target (typically scrollTop).
	 *
	 * ```js
	 * observer.scrollY();
	 * ```
	 *
	 * @returns {number} The vertical scroll position of the target
	 */
	scrollY(): number;
	/**
	 * Sets the vertical scroll position of the target (typically scrollTop).
	 *
	 * ```js
	 * observer.scrollY(100);
	 * ```
	 *
	 * @param {number} position
	 */
	scrollY(position: number): void;
}
declare namespace Observer {
	type ObserverCallback = (self: Observer) => any;
	type IgnoreCheckCallback = (event: Event, isTouchOrPointer: boolean) => boolean;
	interface ObserverVars {
		allowClicks?: boolean;
		capture?: boolean;
		debounce?: boolean;
		dragMinimum?: number;
		event?: Event;
		id?: string;
		ignore?: gsap.DOMTarget;
		ignoreCheck?: IgnoreCheckCallback;
		lineHeight?: number;
		lockAxis?: boolean;
		onLockAxis?: ObserverCallback;
		onDown?: ObserverCallback;
		onUp?: ObserverCallback;
		onLeft?: ObserverCallback;
		onRight?: ObserverCallback;
		onDisable?: ObserverCallback;
		onDrag?: ObserverCallback;
		onDragStart?: ObserverCallback;
		onDragEnd?: ObserverCallback;
		onEnable?: ObserverCallback;
		onHover?: ObserverCallback;
		onHoverEnd?: ObserverCallback;
		onToggleY?: ObserverCallback;
		onToggleX?: ObserverCallback;
		onChangeX?: ObserverCallback;
		onChangeY?: ObserverCallback;
		onChange?: ObserverCallback;
		onClick?: ObserverCallback;
		onPress?: ObserverCallback;
		onRelease?: ObserverCallback;
		onMove?: ObserverCallback;
		onWheel?: ObserverCallback;
		onStop?: ObserverCallback;
		onStopDelay?: number;
		preventDefault?: boolean;
		target?: gsap.DOMTarget | Window | Document;
		tolerance?: number;
		type?: string;
		wheelSpeed?: number;
	}
}
declare namespace Physics2DPlugin {
	interface Vars {
		acceleration?: gsap.TweenValue;
		accelerationAngle?: gsap.TweenValue;
		angle?: gsap.TweenValue;
		friction?: gsap.TweenValue;
		gravity?: gsap.TweenValue;
		velocity?: gsap.TweenValue;
		xProp?: string;
		yProp?: string;
	}
}
declare namespace gsap {
	interface TweenVars {
		physics2D?: Physics2DPlugin.Vars;
	}
}
declare namespace gsap.plugins {
	interface Physics2DPlugin extends Plugin {
	}
	interface Physics2DPluginClass extends Physics2DPlugin {
		new (): PluginScope & Physics2DPlugin;
		prototype: PluginScope & Physics2DPlugin;
	}
	const physics2D: Physics2DPluginClass;
}
declare const Physics2DPlugin: gsap.plugins.Physics2DPlugin;
declare namespace PhysicsPropsPlugin {
	interface Vars {
		[key: string]: Values;
	}
	interface Values {
		acceleration?: gsap.TweenValue;
		friction?: gsap.TweenValue;
		velocity?: gsap.TweenValue;
	}
}
declare namespace gsap {
	interface TweenVars {
		physicsProps?: PhysicsPropsPlugin.Vars;
	}
}
declare namespace gsap.plugins {
	interface PhysicsPropsPlugin extends Plugin {
	}
	interface PhysicsPropsPluginClass extends PhysicsPropsPlugin {
		new (): PluginScope & PhysicsPropsPlugin;
		prototype: PluginScope & PhysicsPropsPlugin;
	}
	const physicsProps: PhysicsPropsPluginClass;
}
declare const PhysicsPropsPlugin: gsap.plugins.PhysicsPropsPlugin;
declare namespace PixiPlugin {
	interface PixiMatrix {
		a: number;
		b: number;
		c: number;
		d: number;
		tx: number;
		ty: number;
		array?: number[];
	}
	interface Vars {
		[key: string]: any;
		alpha?: number | string;
		anchor?: number;
		anchorX?: number | string;
		anchorY?: number | string;
		angle?: number | string;
		autoAlpha?: number;
		blur?: number;
		blurX?: number;
		blurY?: number;
		blurPadding?: number;
		brightness?: number;
		colorize?: string | number;
		colorizeAmount?: number;
		colorMatrixFilter?: object; // TODO
		combineCMF?: boolean;
		contrast?: number;
		fillColor?: string | number;
		height?: number | string;
		hue?: number;
		lineColor?: string | number;
		matrix?: PixiMatrix;
		pivot?: number;
		pivotX?: number | string;
		pivotY?: number | string;
		position?: number | string;
		positionX?: number | string;
		positionY?: number | string;
		resolution?: number;
		rotation?: number | string;
		saturation?: number;
		scale?: number | string;
		scaleX?: number | string;
		scaleY?: number | string;
		skew?: number | string;
		skewX?: number | string;
		skewY?: number | string;
		tilePosition?: number;
		tilePositionX?: number | string;
		tilePositionY?: number | string;
		tileScale?: number;
		tileScaleX?: number | string;
		tileScaleY?: number | string;
		tileX?: number | string;
		tileY?: number | string;
		tint?: string | number;
		width?: number | string;
		x?: number | string;
		y?: number | string;
		zIndex?: number | string;
	}
}
declare namespace gsap {
	interface TweenVars {
		pixi?: PixiPlugin.Vars;
	}
}
declare namespace gsap.plugins {
	interface PixiPlugin extends Plugin {
		/**
		 * Registers the main PIXI library object with the PixiPlugin so that it can find the
		 * necessary classes/objects. You only need to register it once.
		 *
		 * ```js
		 * PixiPlugin.registerPIXI(PIXI);
		 * ```
		 *
		 * @param {object} pixi
		 * @memberof PixiPlugin
		 * @link https://greensock.com/docs/v3/Plugins/PixiPlugin/static.registerPIXI()
		 */
		registerPIXI(pixi: object): void;
	}
	interface PixiPluginClass extends PixiPlugin {
		new (): PluginScope & PixiPlugin;
		prototype: PluginScope & PixiPlugin;
	}
	const pixi: PixiPluginClass;
}
declare const PixiPlugin: gsap.plugins.PixiPlugin;
declare namespace ScrambleTextPlugin {
	interface Vars {
		text: string;
		chars?: string;
		speed?: number;
		delimiter?: string;
		tweenLength?: boolean;
		newClass?: string;
		oldClass?: string;
		revealDelay?: number;
		rightToLeft?: boolean;
	}
}
declare namespace gsap {
	interface TweenVars {
		scrambleText?: string | ScrambleTextPlugin.Vars;
	}
}
declare namespace gsap.plugins {
	interface ScrambleTextPlugin extends Plugin {
	}
	interface ScrambleTextPluginClass extends ScrambleTextPlugin {
		new (): PluginScope & ScrambleTextPlugin;
		prototype: PluginScope & ScrambleTextPlugin;
	}
	const scrambleText: ScrambleTextPluginClass;
}
declare const ScrambleTextPlugin: gsap.plugins.ScrambleTextPlugin;
declare namespace ScrollToPlugin {
	interface Vars {
		x?: number | string | Element;
		y?: number | string | Element;
		offsetX?: number;
		offsetY?: number;
		autoKill?: boolean;
		onAutoKill?: Function;
	}
}
declare namespace gsap {
	interface TweenVars {
		scrollTo?: number | string | Element | Function | ScrollToPlugin.Vars;
	}
}
declare namespace gsap.plugins {
	interface ScrollToPlugin extends Plugin {
	}
	interface ScrollToPluginClass extends ScrollToPlugin {
		new (): PluginScope & ScrollToPlugin;
		prototype: PluginScope & ScrollToPlugin;
	}
	const scrollTo: ScrollToPluginClass;
}
declare const ScrollToPlugin: gsap.plugins.ScrollToPlugin;
declare namespace gsap {
	interface AnimationVars {
		scrollTrigger?: gsap.DOMTarget | ScrollTrigger.Vars;
	}
}
declare class ScrollTrigger {
	static readonly version: string;
	static readonly isTouch: number;
	readonly animation?: gsap.core.Animation | undefined;
	readonly callbackAnimation?: gsap.core.Animation | undefined;
	readonly direction: number;
	readonly end: number;
	readonly isActive: boolean;
	readonly pin?: Element;
	readonly progress: number;
	readonly scroller: Element | Window;
	readonly start: number;
	readonly trigger?: Element;
	readonly vars: ScrollTrigger.Vars;
	/**
	 * Creates an instance of ScrollTrigger.
	 * @param {ScrollTrigger.StaticVars} vars
	 * @param {gsap.core.Animation} [animation]
	 * @memberof ScrollTrigger
	 */
	constructor(vars: ScrollTrigger.StaticVars, animation?: gsap.core.Animation);
	/**
	 * Attach a new event listener to a ScrollTrigger event.
	 *
	 * ```js
	 * ScrollTrigger.addEventListener("scrollStart", myFunc);
	 * ```
	 *
	 * @static
	 * @param {"scrollStart" | "scrollEnd" | "refreshInit" | "refresh"} event
	 * @param {gsap.Callback} callback
	 * @memberof ScrollTrigger
	 * @link https://greensock.com/docs/v3/Plugins/ScrollTrigger/static.addEventListener()
	 */
	static addEventListener(event: "scrollStart" | "scrollEnd" | "refreshInit" | "refresh" | "matchMedia", callback: gsap.Callback): void;
	/**
	 * Creates a coordinated group of ScrollTriggers (one for each target element) that batch their callbacks within a certain interval
	 *
	 * ```js
	 * ScrollTrigger.batch(".class", {
	 *   interval: 0.1,
	 *   batchMax: 3,
	 *   onEnter: (elements, triggers) => gsap.to(elements, {opacity: 1, stagger: 0.15, overwrite: true}),
	 *   onLeave: (elements, triggers) => gsap.set(elements, {opacity: 0, overwrite: true}),
	 *   onEnterBack: (elements, triggers) => gsap.to(elements, {opacity: 1, stagger: 0.15, overwrite: true}),
	 *   onLeaveBack: (elements, triggers) => gsap.set(elements, {opacity: 0, overwrite: true})
	 * });
	 * ```
	 *
	 * @static
	 * @param {gsap.DOMTarget} targets
	 * @param {ScrollTrigger.BatchVars} vars
	 * @returns {ScrollTriggerInstance[]} An Array of the resulting ScrollTrigger instances
	 * @memberof ScrollTrigger
	 * @link https://greensock.com/docs/v3/Plugins/ScrollTrigger/static.batch()
	 */
	static batch(targets: gsap.DOMTarget, vars: ScrollTrigger.BatchVars): ScrollTrigger[];
	/**
	 * Un-registers .matchMedia() break points (or just one).
	 *
	 * ```js
	 * ScrollTrigger.clearMatchMedia();
	 * ```
	 *
	 * @static
	 * @param {string} [name]
	 * @memberof ScrollTrigger
	 * @link https://greensock.com/docs/v3/Plugins/ScrollTrigger/static.clearMatchMedia()
	 */
	static clearMatchMedia(name?: string): void;
	/**
	 * Clears any recorded scroll position data.
	 *
	 * ```js
	 * ScrollTrigger.clearScrollMemory();
	 * ```
	 *
	 * @static
	 * @memberof ScrollTrigger
	 * @link https://greensock.com/docs/v3/Plugins/ScrollTrigger/static.clearScrollMemory()
	 */
	static clearScrollMemory(): void;
	/**
	 * Configure ScrollTrigger
	 *
	 * ```js
	 * ScrollTrigger.config({
	 *   limitCallbacks: true,
	 *   autoRefreshEvents: "resize,load,visibilitychange,DOMContentLoaded"
	 * });
	 * ```
	 *
	 * @static
	 * @param {ScrollTrigger.ConfigVars} vars
	 * @memberof ScrollTrigger
	 * @link https://greensock.com/docs/v3/Plugins/ScrollTrigger/static.config()
	 */
	static config(vars: ScrollTrigger.ConfigVars): void;
	/**
	 * Create scroll triggers that aren't directly connected to a tween or timeline.
	 *
	 * ```js
	 * ScrollTrigger.create({
	 *   trigger: "#id",
	 *   start: "top top",
	 *   end: "bottom 50%+=100px"
	 * });
	 * ```
	 *
	 * @static
	 * @param {ScrollTrigger.StaticVars} vars
	 * @returns {ScrollTrigger} The ScrollTrigger
	 * @memberof ScrollTrigger
	 * @link https://greensock.com/docs/v3/Plugins/ScrollTrigger/static.create()
	 */
	static create(vars: ScrollTrigger.StaticVars): ScrollTrigger;
	/**
	 * Set the default values that apply to every ScrollTrigger upon creation.
	 *
	 * ```js
	 * ScrollTrigger.defaults({
	 *   toggleActions: "restart pause resume none",
	 *   markers: {startColor: "white", endColor: "white", fontSize: "18px", indent: 10}
	 * });
	 * ```
	 *
	 * @static
	 * @param {ScrollTrigger.StaticVars} vars
	 * @returns {ScrollTrigger.StaticVars} The config object
	 * @memberof ScrollTrigger
	 * @link https://greensock.com/docs/v3/Plugins/ScrollTrigger/static.defaults()
	 */
	static defaults(vars: ScrollTrigger.StaticVars): ScrollTrigger.StaticVars;
	/**
	 * Returns all ScrollTriggers that exist.
	 *
	 * ```js
	 * ScrollTrigger.getAll("myID");
	 * ```
	 *
	 * @static
	 * @returns {ScrollTrigger[]} The ScrollTrigger
	 * @memberof ScrollTrigger
	 * @link https://greensock.com/docs/v3/Plugins/ScrollTrigger/static.getAll()
	 */
	static getAll(): ScrollTrigger[];
	/**
	 * Disables ALL ScrollTrigger functionality.
	 *
	 * ```js
	 * ScrollTrigger.disable();
	 * ```
	 * @static
	 * @param {boolean} reset
	 * @param {boolean} kill
	 * @memberof ScrollTrigger
	 * @link https://greensock.com/docs/v3/Plugins/ScrollTrigger/static.disable()
	 */
	static disable(reset?: boolean, kill?: boolean): void;
	/**
	 * Enables all ScrollTrigger functionality again after ScrollTrigger.disable() was called.
	 *
	 * ```js
	 * ScrollTrigger.enable();
	 * ```
	 * @static
	 * @memberof ScrollTrigger
	 * @link https://greensock.com/docs/v3/Plugins/ScrollTrigger/static.enable()
	 */
	static enable(): void;
	/**
	 * Returns the ScrollTrigger that was assigned the corresponding id.
	 *
	 * ```js
	 * ScrollTrigger.getById("myID");
	 * ```
	 *
	 * @static
	 * @param {string} id
	 * @returns {ScrollTriggerInstance} The ScrollTrigger
	 * @memberof ScrollTrigger
	 * @link https://greensock.com/docs/v3/Plugins/ScrollTrigger/static.getById()
	 */
	static getById(id: string): ScrollTrigger | undefined;
	/**
	 * Returns a function to control the scroll position of a particular element
	 *
	 * ```js
	 * let setScroll = ScrollTrigger.getScrollFunc(window);
	 * setScroll(250);
	 * ```
	 *
	 * @static
	 * @param {(gsap.DOMTarget | Window)} element
	 * @param {boolean} [horizontal]
	 * @returns {ScrollTrigger.ScrollFunc}
	 * @memberof ScrollTrigger
	 */
	static getScrollFunc(element: gsap.DOMTarget | Window, horizontal?: boolean): ScrollTrigger.ScrollFunc;
	/**
	 * Checks if the element is in the viewport.
	 *
	 * ```js
	 * if (ScrollTrigger.isInViewport(element, 0.2)) {...};
	 * ```
	 *
	 * @static
	 * @param {Element | string} element
	 * @param {number} [ratio]
	 * @param {boolean} [horizontal]
	 * @returns {boolean} Boolean
	 * @memberof ScrollTrigger
	 * @link https://greensock.com/docs/v3/Plugins/ScrollTrigger/static.isInViewport()
	 */
	static isInViewport(element: Element | string, ratio?: number, horizontal?: boolean): boolean;
	/**
	 * Find out if a ScrollTrigger-related scroller is currently scrolling.
	 *
	 * ```js
	 * ScrollTrigger.isScrolling();
	 * ```
	 *
	 * @static
	 * @returns {boolean} Whether or not any scroller is scrolling
	 * @memberof ScrollTrigger
	 * @link https://greensock.com/docs/v3/Plugins/ScrollTrigger/static.isScrolling()
	 */
	static isScrolling(): boolean;
	/**
	 * Kills all ScrollTriggers (except the main ScrollSmoother one, if it exists)
	 *
	 * ```js
	 * ScrollTrigger.killAll();
	 * ```
	 *
	 * @static
	 * @param {boolean} [allowListeners]
	 * @memberof ScrollTrigger
	 * @link https://greensock.com/docs/v3/Plugins/ScrollTrigger/static.killAll()
	 */
	static killAll(allowListeners?: boolean): void;
	/**
	 * Set up ScrollTriggers that only apply to certain viewport sizes using media queries. Deprecated in favor of gsap.matchMedia() in version 3.11.0+
	 *
	 * ```js
	 * ScrollTrigger.matchMedia({
	 *   "(min-width: 800px)": function() { },
	 *   "(max-width: 799px)": function() { },
	 *   "all": function() { }
	 * });
	 * ```
	 * @deprecated
	 * @static
	 * @param {ScrollTrigger.MatchMediaObject} vars
	 * @memberof ScrollTrigger
	 * @link https://greensock.com/docs/v3/Plugins/ScrollTrigger/static.matchMedia()
	 */
	static matchMedia(vars: ScrollTrigger.MatchMediaObject): void;
	/**
	 * Get the maximum scroll value for any given element.
	 *
	 * ```js
	 * ScrollTrigger.maxScroll(window);
	 * ```
	 *
	 * @static
	 * @param {(HTMLElement | Window)} target
	 * @param {boolean} [horizontal]
	 * @returns {number} The max distance the element can scroll
	 * @memberof ScrollTrigger
	 * @link https://greensock.com/docs/v3/Plugins/ScrollTrigger/static.maxScroll()
	 */
	static maxScroll(target: HTMLElement | Window, horizontal?: boolean): number;
	/**
	 * Forces scrolling to be done on the JavaScript thread, ensuring it is synchronized and the address bar doesn't show/hide on [most] mobile devices.
	 *
	 * ```js
	 * ScrollTrigger.normalizeScroll(true);
	 * ```
	 * @static
	 * @param {boolean | ScrollTrigger.NormalizeVars | Observer} enable
	 * @returns {Observer | undefined} a new Observer instance (if true) or undefined (if false)
	 * @memberof ScrollTrigger
	 * @link https://greensock.com/docs/v3/Plugins/ScrollTrigger/static.normalizeScroll()
	 */
	static normalizeScroll(enable?: boolean | ScrollTrigger.NormalizeVars | Observer): Observer | undefined;
	/**
	 * Returns the Observer instance that is currently normalizing scroll behavior (if one exists).
	 *
	 * ```js
	 * let normalizer = ScrollTrigger.normalizeScroll();
	 * ```
	 * @static
	 * @returns {Observer | undefined} the Observer instance normalizing scroll (if one exists) or undefined (if false)
	 * @memberof ScrollTrigger
	 * @link https://greensock.com/docs/v3/Plugins/ScrollTrigger/static.normalizeScroll()
	 */
	static normalizeScroll(): Observer | undefined;
	/**
	 * Creates an Observer that senses "scroll-like" behavior like a mouse wheel spin, finger swipe on a touch device, scrollbar drag or even a press/drag of the pointer.
	 *
	 * ```js
	 * ScrollTrigger.observe({
	 *     target: ".box",
	 *     onUp: self => console.log("up", self.deltaY),
	 *     onDown: self => console.log("down", self.deltaY)
	 * });
	 * ```
	 * @static
	 * @param {Observer.ObserverVars} vars
	 * @returns {Observer} a new Observer instance
	 * @memberof ScrollTrigger
	 * @link https://greensock.com/docs/v3/Plugins/ScrollTrigger/static.observe()
	 */
	static observe(vars: Observer.ObserverVars): Observer;
	/**
	 * Returns the position of the Element in the viewport as a normalized value (0-1) where 0 is top/left and 1 is bottom/right.
	 *
	 * ```js
	 * if (ScrollTrigger.positionInViewport(element, "top")) {...};
	 * ```
	 *
	 * @static
	 * @param {Element | string} element
	 * @param {number} [referencePoint] - a number in pixels from top, percent like "20%" from top or keyword like "top"/"center"/"bottom"
	 * @param {boolean} [horizontal]
	 * @returns {number} normalized value (0-1) where 0 is top/left and 1 is bottom/right
	 * @memberof ScrollTrigger
	 * @link https://greensock.com/docs/v3/Plugins/ScrollTrigger/static.positionInViewport()
	 */
	static positionInViewport(element: Element | string, referencePoint?: string | number, horizontal?: boolean): number;
	/**
	 * Recalculates the positioning of all of the ScrollTriggers on the page.
	 *
	 * ```js
	 * ScrollTrigger.refresh();
	 * ```
	 *
	 * @static
	 * @param {boolean} [safe]
	 * @memberof ScrollTrigger
	 * @link https://greensock.com/docs/v3/Plugins/ScrollTrigger/static.refresh()
	 */
	static refresh(safe?: boolean): void;
	/**
	 * Registers ScrollTrigger with gsap
	 *
	 * @static
	 * @param {typeof gsap} core
	 * @memberof ScrollTrigger
	 */
	static register(core: typeof gsap): void;
	/**
	 * Removes an event listener for a ScrollTrigger event.
	 *
	 * ```js
	 * ScrollTrigger.removeEventListener("scrollStart", myFunc);
	 * ```
	 *
	 * @static
	 * @param {"scrollStart" | "scrollEnd" | "refreshInit" | "refresh" | "matchMedia"} event
	 * @param {gsap.Callback} callback
	 * @memberof ScrollTrigger
	 * @link https://greensock.com/docs/v3/Plugins/ScrollTrigger/static.removeEventListener()
	 */
	static removeEventListener(event: "scrollStart" | "scrollEnd" | "refreshInit" | "refresh" | "matchMedia", callback: gsap.Callback): void;
	/**
	 * Records the current inline CSS styles for the given element(s) so they can be reverted later.
	 *
	 * ```js
	 * ScrollTrigger.saveStyles(".panel, #logo");
	 * ```
	 *
	 * @static
	 * @param {gsap.DOMTarget} targets
	 * @memberof ScrollTrigger
	 * @link https://greensock.com/docs/v3/Plugins/ScrollTrigger/static.targets()
	 */
	static saveStyles(targets: gsap.DOMTarget): void;
	/**
	 * Sets up proxy methods for a particular scroller so that you can do advanced effects like integrate with a 3rd party smooth scrolling library.
	 *
	 * ```js
	 * ScrollTrigger.scrollerProxy(".container", {
	 *   scrollTop(value) {
	 *     return arguments.length ? locoScroll.scrollTo(value, 0, 0) : locoScroll.scroll.instance.scroll.y;
	 *   },
	 *   getBoundingClientRect() {
	 *     return {top: 0, left: 0, width: window.innerWidth, height: window.innerHeight};
	 *   },
	 *   pinType: document.querySelector(".container").style.transform ? "transform" : "fixed"
	 * });
	 * ```
	 *
	 * @static
	 * @param {gsap.DOMTarget} scroller
	 * @param {ScrollTrigger.ScrollerProxyVars} vars
	 * @memberof ScrollTrigger
	 * @link https://greensock.com/docs/v3/Plugins/ScrollTrigger/static.scrollerProxy()
	 */
	static scrollerProxy(scroller: gsap.DOMTarget, vars?: ScrollTrigger.ScrollerProxyVars): void;
	/**
	 * Returns a function that will snap in a given direction where 1 is positive and -1 is negative. It will accept an increment or Array of numbers
	 *
	 * ```js
	 * let snap = ScrollTrigger.snapDirectional(5);
	 * snap(2, 1); // 5
	 * snap(8, -1); // 5
	 * snap(51, 1) // 55
	 * ```
	 *
	 * @static
	 * @param {number | number[]} incrementOrArray
	 * @memberof ScrollTrigger
	 * @link https://greensock.com/docs/v3/Plugins/ScrollTrigger/static.snapDirectional()
	 */
	static snapDirectional(incrementOrArray: number | number[]): ScrollTrigger.SnapDirectionalFunc;
	/**
	 * Sorts the internal Array of ScrollTriggers by "refreshPriority" first, then by their "start" positions (or by a custom function you provide).
	 *
	 * ```js
	 * ScrollTrigger.sort();
	 * ```
	 *
	 * @static
	 * @param {Function} [func]
	 * @memberof ScrollTrigger
	 * @link https://greensock.com/docs/v3/Plugins/ScrollTrigger/static.sort()
	 */
	static sort(func?: Function): ScrollTrigger[];
	/**
	 * Checks where the scrollbar is and updates all ScrollTrigger instances' progress and direction values accordingly, controls the animation (if necessary) and fires the appropriate callbacks.
	 *
	 * ```js
	 * ScrollTrigger.update();
	 * ```
	 *
	 * @memberof ScrollTrigger
	 * @link https://greensock.com/docs/v3/Plugins/ScrollTrigger/static.update()
	 */
	static update(): void;
	/**
	 * Stops all of the ScrollTrigger's callbacks and removes any added markup and padding caused by pinning.
	 *
	 * ```js
	 * scrollTrigger.disable();
	 * scrollTrigger.disable(true);
	 * ```
	 *
	 * @param {boolean} [revert]
	 * @param {boolean} [allowAnimation]
	 * @memberof ScrollTrigger
	 * @link https://greensock.com/docs/v3/Plugins/ScrollTrigger/disable()
	 */
	disable(revert?: boolean, allowAnimation?: boolean): void;
	/**
	 * Re-enables a disabled ScrollTrigger instance.
	 *
	 * ```js
	 * scrollTrigger.enable();
	 * ```
	 * @param {boolean} [reset]
	 * @param {boolean} [refresh]
	 * @memberof ScrollTrigger
	 * @link https://greensock.com/docs/v3/Plugins/ScrollTrigger/enable()
	 */
	enable(reset?: boolean, refresh?: boolean): void;
	/**
	 * Forces any associated animation (including the callbackAnimation) to its natural end state immediately which is progress(1) if
	 * direction is 1 (forward) and progress(0) if direction is -1 (backward).
	 *
	 * ```js
	 * preventOverlaps: self => self.getTrailing().forEach(t => t.endAnimation());
	 * ```
	 *
	 * @memberof ScrollTrigger
	 * @link https://greensock.com/docs/v3/Plugins/ScrollTrigger/endAnimation()
	 */
	endAnimation(): void;
	/**
	 * Gets the scrub tween associated with the ScrollTrigger instance (if scrub was defined), or getTween(true) will get the snap tween (assuming snap was defined).
	 *
	 * ```js
	 * let scrub = scrollTrigger.getTween();
	 * scrub.progress(1); // immediately finish the scrub
	 * ```
	 *
	 * @param {boolean} [snap]
	 * @memberof ScrollTrigger
	 * @link https://greensock.com/docs/v3/Plugins/ScrollTrigger/getTween()
	 */
	getTween(snap?: boolean): gsap.core.Tween;
	/**
	 * Returns an Array of all ScrollTriggers that precede this one in the updating order according to the current scroll direction.
	 *
	 * ```js
	 * preventOverlaps: self => self.getTrailing().forEach(t => t.endAnimation());
	 * ```
	 *
	 * @param {string | boolean} [name] optional preventOverlaps name to filter
	 * @memberof ScrollTrigger
	 * @link https://greensock.com/docs/v3/Plugins/ScrollTrigger/getTrailing()
	 */
	getTrailing(name?: string | boolean | null): ScrollTrigger[];
	/**
	 * Gets the current velocity of the element's scroll on which the ScrollTrigger is attached to (in pixels per second).
	 *
	 * ```js
	 * scrollTrigger.getVelocity();
	 * ```
	 *
	 * @memberof ScrollTrigger
	 * @link https://greensock.com/docs/v3/Plugins/ScrollTrigger/getVelocity()
	 */
	getVelocity(): number;
	/**
	 * Removes all added markup, stops all callbacks, and frees it for GC.
	 *
	 * ```js
	 * scrollTrigger.kill();
	 * ```
	 *
	 * @param {boolean} [reset]
	 * @param {boolean} [allowAnimation]
	 * @memberof ScrollTrigger
	 * @link https://greensock.com/docs/v3/Plugins/ScrollTrigger/kill()
	 */
	kill(reset?: boolean, allowAnimation?: boolean): void;
	/**
	 * Converts a timeline's label to the associated scroll position (in px)
	 *
	 * ```js
	 * scrollTrigger.labelToScroll("label-1");
	 * ```
	 *
	 * @param {string} label
	 * @returns {number} The associated scroll position
	 * @memberof ScrollTrigger
	 * @link https://greensock.com/docs/v3/Plugins/ScrollTrigger/labelToScroll()
	 */
	labelToScroll(label: string): number;
	/**
	 * Gets the ScrollTrigger instance that's immediately after this one in the refresh order (if any)
	 *
	 * ```js
	 * scrollTrigger.next();
	 * ```
	 *
	 * @memberof ScrollTrigger
	 * @returns {ScrollTrigger | undefined} The next ScrollTrigger (if one exists)
	 * @link https://greensock.com/docs/v3/Plugins/ScrollTrigger/next()
	 */
	next(): ScrollTrigger | undefined;
	/**
	 * Gets the ScrollTrigger instance that's immediately before this one in the refresh order (if any)
	 *
	 * ```js
	 * scrollTrigger.previous();
	 * ```
	 *
	 * @memberof ScrollTrigger
	 * @link https://greensock.com/docs/v3/Plugins/ScrollTrigger/previous()
	 */
	previous(): ScrollTrigger | undefined;
	/**
	 * Forces the ScrollTrigger instance to re-calculate its start and end values (the scroll positions where it'll be activated).
	 *
	 * ```js
	 * scrollTrigger.refresh();
	 * ```
	 *
	 * @memberof ScrollTrigger
	 * @link https://greensock.com/docs/v3/Plugins/ScrollTrigger/refresh()
	 */
	refresh(): void;
	/**
	 * Gets the scroll position of the ScrollTrigger's scroller.
	 *
	 * ```js
	 * scrollTrigger.scroll();
	 * ```
	 *
	 * @returns {number} The scroll position of the scroller
	 * @memberof ScrollTrigger
	 * @link https://greensock.com/docs/v3/Plugins/ScrollTrigger/scroll()
	 */
	scroll(): number;
	/**
	 * Sets the scroll position of the ScrollTrigger's scroller.
	 *
	 * ```js
	 * scrollTrigger.scroll(100);
	 * ```
	 *
	 * @param {number} position
	 * @memberof ScrollTrigger
	 * @link https://greensock.com/docs/v3/Plugins/ScrollTrigger/scroll()
	 */
	scroll(position: number): void;
	/**
	 * Animates the scroll position of the ScrollTrigger's scroller.
	 *
	 * ```js
	 * scrollTrigger.tweenTo(100);
	 * ```
	 *
	 * @param {number} position
	 * @returns {gsap.core.Tween} Tween
	 * @memberof ScrollTrigger
	 */
	tweenTo(position: number): gsap.core.Tween;
	update(reset?: boolean, recordVelocity?: boolean, forceFake?: boolean): void;
}
declare namespace ScrollTrigger {
	interface RectObj {
		top: number;
		left: number;
		width: number;
		height: number;
	}
	interface MatchMediaObject {
		[key: string]: Function;
	}
	type Callback = (self: ScrollTrigger) => any;
	type BatchCallback = (targets: Element[], triggers: ScrollTrigger[]) => any;
	type NumFunc = () => number;
	type SnapFunc = (value: number) => number;
	type SnapDirectionalFunc = (value: number, direction?: number, threshold?: number) => number;
	type GetterSetterNumFunc = (value?: number) => number | void;
	type GetterRectFunc = () => RectObj;
	type StartEndFunc = (self: ScrollTrigger) => string | number;
	type ScrollFunc = (position: number) => void;
	interface MarkersVars {
		endColor?: string;
		fontSize?: string;
		fontWeight?: string;
		indent?: number;
		startColor?: string;
	}
	interface ToggleClassVars {
		className: string;
		targets?: gsap.DOMTarget;
	}
	interface SnapVars {
		delay?: number;
		duration?: number | RangeObject;
		inertia?: boolean;
		ease?: string | gsap.EaseFunction;
		snapTo?: number | number[] | "labels" | "labelsDirectional" | SnapFunc;
		directional?: boolean;
		onInterrupt?: Callback;
		onStart?: Callback;
		onComplete?: Callback;
	}
	interface RangeObject {
		min?: number;
		max?: number;
	}
	interface Vars {
		anticipatePin?: number;
		containerAnimation?: gsap.core.Animation;
		end?: string | number | StartEndFunc;
		endTrigger?: gsap.DOMTarget;
		fastScrollEnd?: boolean | number;
		horizontal?: boolean;
		id?: string;
		immediateRender?: boolean;
		invalidateOnRefresh?: boolean;
		markers?: boolean | MarkersVars;
		once?: boolean;
		onEnter?: Callback;
		onEnterBack?: Callback;
		onKill?: Callback;
		onLeave?: Callback;
		onLeaveBack?: Callback;
		onRefresh?: Callback;
		onRefreshInit?: Callback;
		onSnapComplete?: Callback;
		onScrubComplete?: Callback;
		onUpdate?: Callback;
		onToggle?: Callback;
		pin?: boolean | gsap.DOMTarget;
		pinnedContainer?: gsap.DOMTarget;
		pinReparent?: boolean;
		pinSpacing?: boolean | string;
		pinSpacer?: gsap.DOMTarget;
		pinType?: "fixed" | "transform";
		preventOverlaps?: boolean | string | Callback;
		refreshPriority?: number;
		scroller?: gsap.DOMTarget | Window;
		scrub?: boolean | number;
		snap?: number | number[] | "labels" | "labelsDirectional" | SnapFunc | SnapVars;
		start?: string | number | StartEndFunc;
		toggleActions?: string;
		toggleClass?: string | ToggleClassVars;
		trigger?: gsap.DOMTarget;
	}
	interface StaticVars extends Vars {
		animation?: gsap.core.Animation;
	}
	interface BatchVars {
		interval?: number;
		batchMax?: number | NumFunc;
		anticipatePin?: number;
		end?: string | number | StartEndFunc;
		fastScrollEnd?: boolean | number;
		horizontal?: boolean;
		once?: boolean;
		onEnter?: BatchCallback;
		onEnterBack?: BatchCallback;
		onLeave?: BatchCallback;
		onLeaveBack?: BatchCallback;
		onRefresh?: BatchCallback;
		onRefreshInit?: Callback;
		onUpdate?: BatchCallback;
		onToggle?: BatchCallback;
		pin?: boolean | gsap.DOMTarget;
		pinReparent?: boolean;
		pinSpacing?: boolean | string;
		pinSpacer?: gsap.DOMTarget;
		pinType?: "fixed" | "transform";
		preventOverlaps?: boolean | string | Callback;
		scroller?: gsap.DOMTarget | Window;
		start?: string | number | StartEndFunc;
		toggleClass?: string | ToggleClassVars;
	}
	interface ConfigVars {
		limitCallbacks?: boolean;
		syncInterval?: number;
		autoRefreshEvents?: string;
		ignoreMobileResize?: boolean;
	}
	interface ScrollerProxyVars {
		scrollTop?: GetterSetterNumFunc;
		scrollLeft?: GetterSetterNumFunc;
		scrollWidth?: GetterSetterNumFunc;
		scrollHeight?: GetterSetterNumFunc;
		fixedMarkers?: boolean;
		getBoundingClientRect?: GetterRectFunc;
		pinType?: "fixed" | "transform";
		content?: gsap.DOMTarget;
	}
	interface NormalizeVars extends Observer.ObserverVars {
		momentum?: number | Function;
		content?: gsap.DOMTarget;
		allowNestedScroll?: boolean;
	}
}
declare namespace gsap.plugins {
	/**
	 * @deprecated since 3.7.0
	 * @see ScrollTrigger.ScrollerProxyVars
	 */
	type ScrollerProxyVars = ScrollTrigger.ScrollerProxyVars;
	/**
	 * @deprecated since 3.7.0
	 * @see ScrollTrigger
	 */
	type ScrollTrigger = any;
	/**
	 * @deprecated since 3.7.0
	 * @see ScrollTrigger.BatchVars
	 */
	type ScrollTriggerBatchVars = ScrollTrigger.BatchVars;
	/**
	 * @deprecated since 3.7.0
	 * @see ScrollTrigger.ConfigVars
	 */
	type ScrollTriggerConfigVars = ScrollTrigger.ConfigVars;
	/**
	 * @deprecated since 3.7.0
	 * @see ScrollTrigger
	 */
	class ScrollTriggerInstance extends ScrollTrigger {
	}
	/**
	 * @deprecated since 3.7.0
	 * @see ScrollTrigger.Vars
	 */
	type ScrollTriggerInstanceVars = ScrollTrigger.Vars;
	/**
	 * @deprecated since 3.7.0
	 * @see ScrollTrigger
	 */
	class ScrollTriggerStatic extends ScrollTrigger {
	}
	/**
	 * @deprecated since 3.7.0
	 * @see ScrollTrigger.StaticVars
	 */
	type ScrollTriggerStaticVars = ScrollTrigger.StaticVars;
	/**
	 * @deprecated since 3.7.0
	 * @see ScrollTrigger.SnapVars;
	 */
	type SnapVars = ScrollTrigger.SnapVars;
	/**
	 * @deprecated since 3.7.0
	 * @see ScrollTrigger.ToggleClassVars
	 */
	type ToggleClassVars = ScrollTrigger.ToggleClassVars;
}
declare class ScrollSmoother {
	static readonly version: string;
	readonly scrollTrigger: ScrollTrigger;
	readonly progress: number;
	readonly normalizer?: Observer;
	/**
	 * Creates an instance of ScrollSmoother.
	 * @param {ScrollSmoother.Vars} vars
	 * @memberof ScrollSmoother
	 */
	constructor(vars: ScrollSmoother.Vars);
	/**
	 * Create a ScrollSmoother instance to smooth the scrolling of the page (only one can exist at any time)
	 *
	 * ```js
	 * ScrollSmoother.create({
	 *   content: "#smooth-content",
	 *   wrapper: "#smooth-wrapper",
	 *   smooth: 1.5,
	 *   effects: true
	 * });
	 * ```
	 *
	 * @static
	 * @param {ScrollSmoother.Vars} vars
	 * @returns {ScrollSmoother} The ScrollSmoother
	 * @memberof ScrollSmoother
	 * @link https://greensock.com/docs/v3/Plugins/ScrollSmoother/static.create()
	 */
	static create(vars: ScrollSmoother.Vars): ScrollSmoother;
	/**
	 * Returns the ScrollSmoother instance (if one has been created). Only one is allowed at any given time.
	 *
	 * ```js
	 * let smoother = ScrollSmoother.get();
	 * ```
	 *
	 * @static
	 * @returns {ScrollSmoother} The ScrollSmoother
	 * @memberof ScrollSmoother
	 * @link https://greensock.com/docs/v3/Plugins/ScrollSmoother/static.get()
	 */
	static get(): ScrollSmoother | undefined;
	/**
	 * Refreshes all ScrollTriggers (same as ScrollTrigger.refresh())
	 *
	 * ```js
	 * ScrollSmoother.refresh();
	 * ```
	 *
	 * @param {boolean} safe
	 * @memberof ScrollSmoother
	 * @link https://greensock.com/docs/v3/Plugins/ScrollSmoother/static.refresh()
	 */
	static refresh(safe?: boolean): void;
	/**
	 * Sets the content element (the element that moves up and down when scrolling)
	 *
	 * ```js
	 * smoother.content("#content");
	 * ```
	 *
	 * @param {gsap.DOMTarget} element
	 * @returns {ScrollSmoother} The ScrollSmoother instance (to make chaining easier)
	 * @memberof ScrollSmoother
	 * @link https://greensock.com/docs/v3/Plugins/ScrollSmoother/content()
	 */
	content(element: gsap.DOMTarget): this;
	/**
	 * Gets the content element (the element that moves up and down when scrolling)
	 *
	 * ```js
	 * let el = smoother.content();
	 * ```
	 *
	 * @returns {HTMLElement} The content Element
	 * @memberof ScrollSmoother
	 * @link https://greensock.com/docs/v3/Plugins/ScrollSmoother/content()
	 */
	content(): HTMLElement;
	/**
	 * Applies "speed" and/or "lag" effects to the supplied targets (instead of using HTML attributes like data-speed and data-lag)
	 *
	 * ```js
	 * scroller.effects(".box", {
	 *    speed: (i, el) => 0.5 + i * 0.1,
	 *    lag: 0.5
	 * });
	 * ```
	 *
	 * @param {gsap.DOMTarget} targets
	 * @param {ScrollSmoother.EffectsVars} vars
	 * @returns {ScrollTrigger[]} An Array of ScrollTrigger instances that were created to handle the effects
	 * @memberof ScrollSmoother
	 * @link https://greensock.com/docs/v3/Plugins/ScrollSmoother/effects()
	 */
	effects(targets: gsap.DOMTarget, vars?: ScrollSmoother.EffectsVars | null): ScrollTrigger[];
	/**
	 * Gets the ScrollTrigger instances that are managing the effects (like "speed" and/or "lag")
	 *
	 * ```js
	 * let effectTriggers = scroller.effects();
	 * ```
	 *
	 * @returns {ScrollTrigger[]} An Array of ScrollTrigger instances that were created to handle the effects
	 * @memberof ScrollSmoother
	 * @link https://greensock.com/docs/v3/Plugins/ScrollSmoother/effects()
	 */
	effects(): ScrollTrigger[];
	/**
	 * Returns the velocity of the vertical scrolling in pixels per second
	 *
	 * ```js
	 * let velocity = smoother.getVelocity()
	 * ```
	 *
	 * @returns {number} The velocity of the vertical scrolling (in pixels per second)
	 * @memberof ScrollSmoother
	 * @link https://greensock.com/docs/v3/Plugins/ScrollSmoother/getVelocity()
	 */
	getVelocity(): number;
	/**
	 * Kills the ScrollSmoother instance, reverting the inline CSS of the content and wrapper, removing listeners, etc. This is permanent but you can ScrollSmoother.create() a new one.
	 *
	 * ```js
	 * scrollSmoother.kill();
	 * ```
	 *
	 * @memberof ScrollSmoother
	 * @link https://greensock.com/docs/v3/Plugins/ScrollSmoother/kill()
	 */
	kill(): void;
	/**
	 * Gets the numeric offset (scroll position) associated with a particular element.
	 *
	 * ```js
	 * let offset = smoother.offset("#id", "center center");
	 * ```
	 *
	 * @param {gsap.DOMTarget} target
	 * @param {string} position - like "top center" or "50% bottom-=50px"
	 * @returns {number} The numeric offset (scroll position)
	 * @memberof ScrollSmoother
	 * @link https://greensock.com/docs/v3/Plugins/ScrollSmoother/offset()
	 */
	offset(target: gsap.DOMTarget, position?: string): number;
	/**
	 * Sets the paused state - if true, nothing will scroll (except via .scrollTop() or .scrollTo() on this instance). Serves as a getter and setter function
	 *
	 * ```js
	 * smoother.paused(true);
	 * ```
	 *
	 * @param {boolean} value
	 * @returns {ScrollSmoother} The ScrollSmoother instance (for easier chaining)
	 * @memberof ScrollSmoother
	 * @link https://greensock.com/docs/v3/Plugins/ScrollSmoother/paused()
	 */
	paused(value: boolean): this;
	/**
	 * Gets the paused state. Serves as a getter and setter function.
	 *
	 * ```js
	 * if (!smoother.paused()) {
	 *     ...
	 * }
	 * ```
	 *
	 * @returns {boolean} The paused state (true or false)
	 * @memberof ScrollSmoother
	 * @link https://greensock.com/docs/v3/Plugins/ScrollSmoother/paused()
	 */
	paused(): boolean;
	/**
	 * Refreshes only the main page's smoothing ScrollTrigger
	 *
	 * ```js
	 * smoother.refresh();
	 * ```
	 *
	 * @param {boolean} soft
	 * @param {boolean} force
	 * @memberof ScrollSmoother
	 * @link https://greensock.com/docs/v3/Plugins/ScrollSmoother/refresh()
	 */
	refresh(soft?: boolean, force?: boolean): void;
	/**
	 * Scrolls to a particular position or target immediately or in a smooth manner.
	 *
	 * ```js
	 * smoother.scrollTo("#id", true, "center center");
	 * ```
	 *
	 * @param {gsap.DOMTarget | number} target
	 * @param {boolean} smooth
	 * @param {string} position
	 * @returns {void}
	 * @memberof ScrollSmoother
	 * @link https://greensock.com/docs/v3/Plugins/ScrollSmoother/scrollTo()
	 */
	scrollTo(target: gsap.DOMTarget | number, smooth?: boolean, position?: string): void;
	/**
	 * Immediately scrolls to a particular numeric scroll position
	 *
	 * ```js
	 * smoother.scrollTop(500);
	 * ```
	 *
	 * @param {number} position
	 * @returns {ScrollSmoother} Returns the instance itself for easier chaining
	 * @memberof ScrollSmoother
	 * @link https://greensock.com/docs/v3/Plugins/ScrollSmoother/scrollTop()
	 */
	scrollTop(position: number): this;
	/**
	 * Gets the scroll position (numeric offset)
	 *
	 * ```js
	 * let offset = smoother.scrollTop();
	 * ```
	 *
	 * @returns {number} the numeric offset
	 * @memberof ScrollSmoother
	 * @link https://greensock.com/docs/v3/Plugins/ScrollSmoother/scrollTop()
	 */
	scrollTop(): number;
	//
	// /**
	//  * Sets up ScrollTriggers to handle hiding elements (sections) when they're sufficiently outside the viewport in order to improve performance in some situations.
	//  *
	//  * ```js
	//  * smoother.sections("[data-section]");
	//  * ```
	//  *
	//  * @param {gsap.DOMTarget} targets
	//  * @param {ScrollSmoother.SectionVars} vars
	//  * @returns {ScrollTrigger[]} An Array of ScrollTrigger instances that were created to handle the sections
	//  * @memberof ScrollSmoother
	//  * @link https://greensock.com/docs/v3/Plugins/ScrollSmoother/sections()
	//  */
	// sections(targets: gsap.DOMTarget, vars?: ScrollSmoother.SectionVars | null): ScrollTrigger[];
	//
	// /**
	//  * Gets the ScrollTrigger instances that are managing the sections
	//  *
	//  * ```js
	//  * let sectionTriggers = smoother.sections();
	//  * ```
	//  *
	//  * @returns {ScrollTrigger[]} An Array of ScrollTrigger instances that were created to handle the sections
	//  * @memberof ScrollSmoother
	//  * @link https://greensock.com/docs/v3/Plugins/ScrollSmoother/sections()
	//  */
	// sections(): ScrollTrigger[];
	/**
	 * Sets the number of seconds it takes to catch up to the scroll position (smoothing).
	 *
	 * ```js
	 * smoother.smooth(1.5);
	 * ```
	 *
	 * @param {number} value
	 * @memberof ScrollSmoother
	 * @link https://greensock.com/docs/v3/Plugins/ScrollSmoother/smooth()
	 */
	smooth(value: number): void;
	/**
	 * Gets the number of seconds it takes to catch up to the scroll position (smoothing).
	 *
	 * ```js
	 * let duration = smoother.smooth();
	 * ```
	 *
	 * @returns {number} The amount of smoothing applied (in seconds)
	 * @memberof ScrollSmoother
	 * @link https://greensock.com/docs/v3/Plugins/ScrollSmoother/smooth()
	 */
	smooth(): number;
	/**
	 * Sets the wrapper element which serves as the viewport (scrolls the content)
	 *
	 * ```js
	 * smoother.wrapper("#wrapper");
	 * ```
	 *
	 * @param {gsap.DOMTarget} element
	 * @returns {ScrollSmoother} The ScrollSmoother instance (to make chaining easier)
	 * @memberof ScrollSmoother
	 * @link https://greensock.com/docs/v3/Plugins/ScrollSmoother/wrapper()
	 */
	wrapper(element: gsap.DOMTarget): this;
	/**
	 * Gets the wrapper element which serves as the viewport (scrolls the content)
	 *
	 * ```js
	 * let el = smoother.wrapper();
	 * ```
	 *
	 * @returns {HTMLElement} The wrapper Element
	 * @memberof ScrollSmoother
	 * @link https://greensock.com/docs/v3/Plugins/ScrollSmoother/wrapper()
	 */
	wrapper(): HTMLElement;
}
declare namespace ScrollSmoother {
	type Callback = (self: ScrollSmoother) => any;
	type EventCallback = (self: ScrollSmoother, event: Event) => any;
	type EffectFunc = (index: number, element: Element) => number | string;
	interface EffectsVars {
		speed?: number | string | EffectFunc;
		lag?: number | EffectFunc;
		effectsPadding?: number | string | EffectFunc;
	}
	//
	// interface SectionVars {
	//   add?: boolean;
	// }
	interface Vars {
		autoResize?: boolean;
		content?: gsap.DOMTarget;
		ease?: string | Function;
		effects?: boolean | gsap.DOMTarget;
		effectsPrefix?: string;
		effectsPadding?: number;
		ignoreMobileResize?: boolean;
		normalizeScroll?: boolean | ScrollTrigger.NormalizeVars;
		onFocusIn?: EventCallback;
		onUpdate?: Callback;
		onStop?: Callback;
		//   sections?: boolean | gsap.DOMTarget;
		smooth?: boolean | number;
		smoothTouch?: boolean | number;
		speed?: number;
		wrapper?: gsap.DOMTarget;
	}
}
declare class SplitText {
	readonly chars: Element[];
	readonly lines: Element[];
	readonly words: Element[];
	readonly selector: string | Function;
	constructor(target: gsap.DOMTarget, vars?: SplitText.Vars);
	/**
	 * Reverts the innerHTML to the original content.
	 *
	 * ```js
	 * split.revert();
	 * ```
	 *
	 * @memberof SplitText
	 * @link https://greensock.com/docs/v3/Plugins/SplitText/revert()
	 */
	revert(): void;
	/**
	 * Re-splits a SplitText according to the vars provided. It will automatically call revert() first if necessary. Useful if you want to change the way the text is split after the SplitText instance is created.
	 *
	 * ```js
	 * split.split({type: "lines,chars"});
	 * ```
	 *
	 * @param {SplitText.Vars} vars
	 * @returns {SplitText} The SplitText object created
	 * @memberof SplitText
	 * @link https://greensock.com/docs/v3/Plugins/SplitText/split()
	 */
	split(vars: SplitText.Vars): SplitText;
}
declare namespace SplitText {
	interface Vars {
		[key: string]: any;
		type?: string;
		charsClass?: string;
		wordsClass?: string;
		linesClass?: string;
		position?: string;
		lineThreshold?: number;
		reduceWhiteSpace?: boolean;
		specialChars?: string[] | Function;
		wordDelimiter?: string;
	}
}
declare namespace TextPlugin {
	interface Vars {
		value: string;
		type?: string;
		rtl?: boolean;
		speed?: number;
		delimiter?: string;
		padSpace?: boolean;
		newClass?: string;
		oldClass?: string;
		preserveSpaces?: boolean;
	}
}
declare namespace gsap {
	interface TweenVars {
		text?: string | TextPlugin.Vars;
	}
}
declare namespace gsap.plugins {
	interface TextPlugin extends Plugin {
	}
	interface TextPluginClass extends TextPlugin {
		new (): PluginScope & TextPlugin;
		prototype: PluginScope & TextPlugin;
	}
	const text: TextPluginClass;
}
declare const TextPlugin: gsap.plugins.TextPlugin;
declare namespace gsap.core {
	type TimelineChild = string | Animation | Callback | Array<string | Animation | Callback>;
	interface Labels {
		[key: string]: number;
	}
	class Timeline extends Animation {
		autoRemoveChildren: boolean;
		labels: Labels;
		smoothChildTiming: boolean;
		vars: TimelineVars;
		[key: string]: any; // for gsap.registerEffect({... extendTimeline: true})
		constructor(vars?: TimelineVars, time?: number);
		static updateRoot(time: number): void;
		/**
		 * Adds a label, tween, timeline, or an array of those values to the timeline, optionally at the specified time.
		 *
		 * ```js
		 * tl.add("myLabel");  // add a label at the end of the timeline
		 * tl.add(myTween, 1); // add a tween at the 1 second mark
		 * tl.add(myTimeline, "-=1"); // add a timeline 1 second before the end of the timeline
		 * tl.add(["myLabel", myTween, myTimeline], "<"); // add a label, tween, and timeline at the start of the previous tween
		 * ```
		 *
		 * @param {TimelineChild} child
		 * @param {Position} [position]
		 * @returns {Timeline} The timeline
		 * @memberof Timeline
		 * @link https://greensock.com/docs/v3/GSAP/Timeline/add()
		 */
		add(child: TimelineChild, position?: Position): this;
		/**
		 * Adds a label to the timeline, optionally at the specified time.
		 *
		 * ```js
		 * tl.addLabel("myLabel", 1); // add a label at the 1 second mark
		 * ```
		 *
		 * @param {string} label
		 * @param {Position} [position]
		 * @returns {Timeline} The timeline
		 * @memberof Timeline
		 * @link https://greensock.com/docs/v3/GSAP/Timeline/addLabel()
		 */
		addLabel(label: string, position?: Position): this;
		/**
		 * Adds a pause to the timeline, optionally at the specified time.
		 *
		 * ```js
		 * tl.addPause(); // add a pause at the end of the timeline
		 * tl.addPause(1, myCallback); // add a pause at the 1 second mark with a callback
		 * ```
		 *
		 * @param {Position} [position]
		 * @param {Callback} [callback]
		 * @param {any[]} [params]
		 * @returns {Timeline} The timeline
		 * @memberof Timeline
		 * @link https://greensock.com/docs/v3/GSAP/Timeline/addPause()
		 */
		addPause(position?: Position, callback?: Callback, params?: any[]): this;
		/**
		 * Call a function, optionally at the specified time.
		 *
		 * ```js
		 * tl.call(myCallback); // add a function call at the end of the timeline
		 * tl.call(myCallback, ["param"], 1); // add a function call at the 1 second mark with a parameter passed in
		 * ```
		 *
		 * @param {Callback} callback
		 * @param {any[]} [params]
		 * @param {Position} [position]
		 * @returns {Timeline} The timeline
		 * @memberof Timeline
		 * @link https://greensock.com/docs/v3/GSAP/Timeline/call()
		 */
		call(callback: Callback, params?: any[], position?: Position): this;
		/**
		 * Empties the timeline of all tweens, timelines, callbacks, and optionally labels.
		 *
		 * ```js
		 * tl.clear();     // empty the timeline not including labels
		 * tl.clear(true); // empy the timeline including labels
		 * ```
		 *
		 * @param {boolean} labels
		 * @returns {Timeline} The timeline
		 * @memberof Timeline
		 * @link https://greensock.com/docs/v3/GSAP/Timeline/clear()
		 */
		clear(labels?: boolean): this;
		/**
		 * Makes the timeline's progress jump to the provided label.
		 *
		 * ```js
		 * tl.currentLabel("myLabel");
		 * ```
		 *
		 * @param {string} value
		 * @returns {Timeline} The timeline
		 * @memberof Timeline
		 * @link https://greensock.com/docs/v3/GSAP/Timeline/currentLabel()
		 */
		currentLabel(value: string): this;
		/**
		 * Gets the closest label that is at or before the current time.
		 *
		 * ```js
		 * tl.currentLabel();
		 * ```
		 *
		 * @returns {string} The nearest label
		 * @memberof Timeline
		 * @link https://greensock.com/docs/v3/GSAP/Timeline/currentLabel()
		 */
		currentLabel(): string;
		/**
		 * Creates a tween coming FROM the given values.
		 *
		 * ```js
		 * tl.from(".class", { x: 100 }, "+=1"); // adds the tween one second after the end of the timeline
		 * ```
		 *
		 * @param {TweenTarget} targets
		 * @param {TweenVars} vars
		 * @param {Position} [position]
		 * @returns {Timeline} The timeline
		 * @memberof Timeline
		 * @link https://greensock.com/docs/v3/GSAP/Timeline/from()
		 */
		from(targets: TweenTarget, vars: TweenVars, position?: Position): this;
		/**
		 * **Deprecated method signature.** Use the `duration` property instead.
		 *
		 * ```js
		 * tl.from(".class", 1, { x: 100 }, "+=1"); // adds the tween one second after the end of the timeline
		 * ```
		 *
		 * @deprecated since version 3.0.0
		 * @param {TweenTarget} targets
		 * @param {number} duration - The duration parameter is deprecated. Use the `duration` property instead.
		 * @param {TweenVars} vars
		 * @param {Position} [position]
		 * @returns {Timeline} The timeline
		 * @memberof Timeline
		 * @link https://greensock.com/docs/v3/GSAP/Timeline/from()
		 */
		from(targets: TweenTarget, duration: number, vars: TweenVars, position?: Position): this;
		/**
		 * Creates a tween coming FROM the first set of values going TO the second set of values.
		 *
		 * ```js
		 * tl.fromTo(".class", {x: 0}, { x: 100 }, "+=1"); // adds the tween one second after the end of the timeline
		 * ```
		 *
		 * @param {TweenTarget} targets
		 * @param {TweenVars} fromVars
		 * @param {TweenVars} toVars
		 * @param {Position} [position]
		 * @returns {Timeline} The timeline
		 * @memberof Timeline
		 * @link https://greensock.com/docs/v3/GSAP/Timeline/fromTo()
		 */
		fromTo(targets: TweenTarget, fromVars: TweenVars, toVars: TweenVars, position?: Position): this;
		/**
		 * **Deprecated method signature.** Use the `duration` property instead.
		 *
		 * ```js
		 * tl.fromTo(".class", 1, {x: 0}, { x: 100 }, "+=1"); // adds the tween one second after the end of the timeline
		 * ```
		 *
		 * @deprecated since version 3.0.0
		 * @param {TweenTarget} targets
		 * @param {number} duration - The duration parameter is deprecated. Use the `duration` property instead.
		 * @param {TweenVars} fromVars
		 * @param {TweenVars} toVars
		 * @param {Position} [position]
		 * @returns {Timeline} The timeline
		 * @memberof Timeline
		 * @link https://greensock.com/docs/v3/GSAP/Timeline/fromTo()
		 */
		fromTo(targets: TweenTarget, duration: number, fromVars: TweenVars, toVars: TweenVars, position?: Position): this;
		/**
		 * Returns the tween or timeline associated with the provided ID.
		 *
		 * ```js
		 * tl.getById("myTween");
		 * ```
		 *
		 * @param {string} id
		 * @returns {Tween | Timeline}
		 * @memberof Timeline
		 * @link https://greensock.com/docs/v3/GSAP/Timeline/getById()
		 */
		getById(id: string): Tween | Timeline;
		/**
		 * Returns an array containing all the tweens and/or timelines nested in this timeline.
		 *
		 * ```js
		 * tl.getChildren();
		 * tl.getChildren(true, true, true, 0.5);
		 * ```
		 *
		 * @param {boolean} [nested]
		 * @param {boolean} [tweens]
		 * @param {boolean} [timelines]
		 * @param {number} [ignoreBeforeTime]
		 * @returns {(Tween | Timeline)[]} Array of tweens and timelines
		 * @memberof Timeline
		 * @link https://greensock.com/docs/v3/GSAP/Timeline/getChildren()
		 */
		getChildren(nested?: boolean, tweens?: boolean, timelines?: boolean, ignoreBeforeTime?: number): (Tween | Timeline)[];
		/**
		 * Returns the tweens of a particular object that are inside this timeline.
		 *
		 * ```js
		 * tl.getTweensOf(".myClass");
		 * tl.getTweensOf(myElem, true);
		 * ```
		 *
		 * @param {TweenTarget} targets
		 * @param {boolean} [onlyActive]
		 * @returns {Tween[]} Array of tweens
		 * @memberof Timeline
		 * @link https://greensock.com/docs/v3/GSAP/Timeline/getTweensOf()
		 */
		getTweensOf(targets: TweenTarget, onlyActive?: boolean): Tween[];
		/**
		 * Returns the next label in the timeline, optionally from the provided time.
		 *
		 * ```js
		 * tl.nextLabel();
		 * tl.nextLabel(2);
		 * ```
		 *
		 * @param {number} [time]
		 * @returns {string} The next label
		 * @memberof Timeline
		 * @link https://greensock.com/docs/v3/GSAP/Timeline/nextLabel()
		 */
		nextLabel(time?: number): string;
		/**
		 * Returns the previous label in the timeline, optionally from the provided time.
		 *
		 * ```js
		 * tl.previousLabel();
		 * tl.previousLabel(2);
		 * ```
		 *
		 * @param {number} [time]
		 * @returns {string} The previous label
		 * @memberof Timeline
		 * @link https://greensock.com/docs/v3/GSAP/Timeline/previousLabel()
		 */
		previousLabel(time?: number): string;
		/**
		 * Returns the most recently added child tween, timeline, or callback regardless of its position in the timeline.
		 *
		 * ```js
		 * tl.recent();
		 * ```
		 *
		 * @returns {Tween | Timeline | Function} The most recent tween, timeline, or callback
		 * @memberof Timeline
		 * @link https://greensock.com/docs/v3/GSAP/Timeline/recent()
		 */
		recent(): Tween | Timeline | Function;
		/**
		 * Removes a tween, timeline, callback, label, or array of those values from the timeline.
		 *
		 * ```js
		 * tl.remove(myTween);
		 * tl.remove([myTween, mySubTimeline, "myLabel"]);
		 * ```
		 *
		 * @param {TimelineChild} value
		 * @returns {Timeline} The timeline
		 * @memberof Timeline
		 * @link https://greensock.com/docs/v3/GSAP/Timeline/remove()
		 */
		remove(value: TimelineChild): this;
		/**
		 * Removes a label from the timeline and returns the time of that label.
		 *
		 * ```js
		 * tl.removeLabel("myLabel"); // returns the label time like 1.0
		 * ```
		 *
		 * @param {string} label
		 * @returns {number} The time of the removed label
		 * @memberof Timeline
		 * @link https://greensock.com/docs/v3/GSAP/Timeline/removeLabel()
		 */
		removeLabel(label: string): number;
		/**
		 * Removes pauses that were added to a timeline via its .addPause() method.
		 *
		 * ```js
		 * tl.removePause(1); // returns the pause at time 1
		 * ```
		 *
		 * @param {Position} position
		 * @returns {Timeline} The timeline
		 * @memberof Timeline
		 * @link https://greensock.com/docs/v3/GSAP/Timeline/removePause()
		 */
		removePause(position: Position): this;
		/**
		 * Sets properties of the target(s) to the properties specified at the time of the set call.
		 *
		 * ```js
		 * tl.set(".class", {x: 100, y: 50, opacity: 0}, 1);
		 * ```
		 *
		 * @param {TweenTarget} targets
		 * @param {TweenVars} vars
		 * @param {Position} [position]
		 * @returns {Timeline} The timeline
		 * @memberof Timeline
		 * @link https://greensock.com/docs/v3/GSAP/Timeline/set()
		 */
		set(targets: TweenTarget, vars: TweenVars, position?: Position): this;
		/**
		 * Shifts the startTime of the timeline's children by a certain amount and optionally adjusts labels too.
		 *
		 * ```js
		 * tl.shiftChildren(1); // shift the child tweens, timelines, and callbacks by 1 second
		 * ```
		 *
		 * @param {number} amount
		 * @param {boolean} [adjustLabels]
		 * @param {number} [ignoreBeforeTime]
		 * @returns {Timeline} The timeline
		 * @memberof Timeline
		 * @link https://greensock.com/docs/v3/GSAP/Timeline/shiftChildren()
		 */
		shiftChildren(amount: number, adjustLabels?: boolean, ignoreBeforeTime?: number): this;
		/**
		 * **Deprecated method.** Use the `.from()` method instead.
		 *
		 * @deprecated since version 3.0.0
		 * @param {TweenTarget} targets
		 * @param {TweenVars} vars
		 * @param {Position} position
		 * @returns {Timeline} The timeline
		 * @memberof Timeline
		 * @link https://greensock.com/docs/v3/GSAP/Timeline/from()
		 */
		staggerFrom(targets: TweenTarget, vars: TweenVars, position?: Position): this;
		/**
		 * **Deprecated method.** Use the `.from()` method instead.
		 *
		 * @deprecated since version 3.0.0
		 * @param {TweenTarget} targets
		 * @param {number} duration - The duration parameter is deprecated. Use the `duration` property instead.
		 * @param {Timeline} vars
		 * @param {Position} position
		 * @returns {Timeline} The timeline
		 * @memberof Timeline
		 * @link https://greensock.com/docs/v3/GSAP/Timeline/from()
		 */
		staggerFrom(targets: TweenTarget, duration: number, vars: TweenVars, position?: Position): this;
		/**
		* **Deprecated method.** Use the `.fromTo()` method instead.
		*
		* @deprecated since version 3.0.0
		* @param {TweenTarget} targets
		* @param {TweenVars} vars
		* @param {Position} position
		* @returns {Timeline} The timeline
		* @memberof Timeline
		* @link https://greensock.com/docs/v3/GSAP/Timeline/fromTo()
		*/
		staggerFromTo(targets: TweenTarget, fromVars: TweenVars, toVars: TweenVars, position?: Position): this;
		/**
		 * **Deprecated method.** Use the `.fromTo()` method instead.
		 *
		 * @deprecated since version 3.0.0
		 * @param {TweenTarget} targets
		 * @param {number} duration - The duration parameter is deprecated. Use the `duration` property instead.
		 * @param {Timeline} vars
		 * @param {Position} position
		 * @returns {Timeline} The timeline
		 * @memberof Timeline
		 * @link https://greensock.com/docs/v3/GSAP/Timeline/fromTo()
		 */
		staggerFromTo(targets: TweenTarget, duration: number, fromVars: TweenVars, toVars: TweenVars, position?: Position): this;
		/**
		 * **Deprecated method.** Use the `.to()` method instead.
		 *
		 * @deprecated since version 3.0.0
		 * @param {TweenTarget} targets
		 * @param {TweenVars} vars
		 * @param {Position} position
		 * @returns {Timeline} The timeline
		 * @memberof Timeline
		 * @link https://greensock.com/docs/v3/GSAP/Timeline/to()
		 */
		staggerTo(targets: TweenTarget, vars: TweenVars, position?: Position): this;
		/**
		 * **Deprecated method.** Use the `.to()` method instead.
		 *
		 * @deprecated since version 3.0.0
		 * @param {TweenTarget} targets
		 * @param {number} duration - The duration parameter is deprecated. Use the `duration` property instead.
		 * @param {Timeline} vars
		 * @param {Position} position
		 * @returns {Timeline} The timeline
		 * @memberof Timeline
		 * @link https://greensock.com/docs/v3/GSAP/Timeline/to()
		 */
		staggerTo(targets: TweenTarget, duration: number, vars: TweenVars, position?: Position): this;
		/**
		 * Creates a tween going TO the given values.
		 *
		 * ```js
		 * tl.to(".class", {x: 100}, 1);
		 * ```
		 *
		 * @param {TweenTarget} targets
		 * @param {TweenVars} vars
		 * @param {Position} position
		 * @returns {Timeline} The timeline
		 * @memberof Timeline
		 * @link https://greensock.com/docs/v3/GSAP/Timeline/to()
		 */
		to(targets: TweenTarget, vars: TweenVars, position?: Position): this;
		/**
		 * **Deprecated method signature.** Use the `duration` property instead.
		 *
		 * ```js
		 * tl.to(".class", 1, {x: 100}, 1);
		 * ```
		 * @deprecated since version 3.0.0
		 * @param {TweenTarget} targets
		 * @param {number} duration - The duration parameter is deprecated. Use the `duration` property instead.
		 * @param {Timeline} vars
		 * @param {Position} position
		 * @returns {Timeline} The timeline
		 * @memberof Timeline
		 * @link https://greensock.com/docs/v3/GSAP/Timeline/to()
		 */
		to(targets: TweenTarget, duration: number, vars: TweenVars, position?: Position): this;
		/**
		 * Tween linearly from a particular time or label to another time or label and then stops.
		 *
		 * ```js
		 * tl.tweenFromTo("myLabel", 5}); // tween from myLabel to the 5 second mark
		 * ```
		 *
		 * @param {Position} fromPosition
		 * @param {Position} toPosition
		 * @param {TweenVars} [vars]
		 * @returns {Tween} The tweenFromTo tween
		 * @memberof Timeline
		 * @link https://greensock.com/docs/v3/GSAP/Timeline/tweenFromTo()
		 */
		tweenFromTo(fromPosition: Position, toPosition: Position, vars?: TweenVars): Tween;
		/**
		 * Tween linearly to a particular time and then stops.
		 *
		 * ```js
		 * tl.tweenTo("myLabel"}); // tween to myLabel
		 * ```
		 *
		 * @param {Position} position
		 * @param {TweenVars} [vars]
		 * @returns {Tween} The tweenTo tween
		 * @memberof Timeline
		 * @link https://greensock.com/docs/v3/GSAP/Timeline/tweenTo()
		 */
		tweenTo(position: Position, vars?: TweenVars): Tween;
	}
}
declare namespace gsap.core {
	class Tween extends Animation {
		data: any;
		vars: TweenVars;
		ratio: number;
		constructor(targets: TweenTarget, vars: TweenVars, time?: number);
		constructor(targets: TweenTarget, duration: number, vars: TweenVars);
		/**
		 * **Deprecated method.** Use `gsap.to()` instead.
		 *
		 * @deprecated since 3.0.0
		 * @static
		 * @param {TweenTarget} targets
		 * @param {number} duration
		 * @param {TweenVars} vars
		 * @returns {Tween} Tween instance
		 * @memberof Tween
		 * @link https://greensock.com/docs/v3/GSAP/gsap.to()
		 */
		static to(targets: TweenTarget, duration: number, vars: TweenVars): Tween;
		/**
		 * **Deprecated method.** Use `gsap.to()` instead.
		 *
		 * @deprecated since 3.0.0
		 * @static
		 * @param {TweenTarget} targets
		 * @param {TweenVars} vars
		 * @returns {Tween}  Tween instance
		 * @memberof Tween
		 * @link https://greensock.com/docs/v3/GSAP/gsap.to()
		 */
		static to(targets: TweenTarget, vars: TweenVars): Tween;
		/**
		 * **Deprecated method.** Use `gsap.from()` instead.
		 *
		 * @deprecated since 3.0.0
		 * @static
		 * @param {TweenTarget} targets
		 * @param {number} duration
		 * @param {TweenVars} vars
		 * @returns {Tween} Tween instance
		 * @memberof Tween
		 * @link https://greensock.com/docs/v3/GSAP/gsap.from()
		 */
		static from(targets: TweenTarget, duration: number, vars: TweenVars): Tween;
		/**
		 * **Deprecated method.** Use `gsap.from()` instead.
		 *
		 * @deprecated since 3.0.0
		 * @static
		 * @param {TweenTarget} targets
		 * @param {TweenVars} vars
		 * @returns {Tween} Tween instance
		 * @memberof Tween
		 * @link https://greensock.com/docs/v3/GSAP/gsap.from()
		 */
		static from(targets: TweenTarget, vars: TweenVars): Tween;
		/**
		 * **Deprecated method.** Use `gsap.fromTo()` instead.
		 *
		 * @deprecated since 3.0.0
		 * @static
		 * @param {TweenTarget} targets
		 * @param {number} duration
		 * @param {TweenVars} fromVars
		 * @param {TweenVars} toVars
		 * @returns {Tween} Tween instance
		 * @memberof Tween
		 * @link https://greensock.com/docs/v3/GSAP/gsap.fromTo()
		 */
		static fromTo(targets: TweenTarget, duration: number, fromVars: TweenVars, toVars: TweenVars): Tween;
		/**
		 * **Deprecated method.** Use `gsap.fromTo()` instead.
		 *
		 * @deprecated since 3.0.0
		 * @static
		 * @param {TweenTarget} targets
		 * @param {TweenVars} fromVars
		 * @param {TweenVars} toVars
		 * @returns {Tween} Tween instance
		 * @memberof Tween
		 * @link https://greensock.com/docs/v3/GSAP/gsap.fromTo()
		 */
		static fromTo(targets: TweenTarget, fromVars: TweenVars, toVars: TweenVars): Tween;
		/**
		 * **Deprecated method.** Use `gsap.set()` instead.
		 *
		 * @deprecated since 3.0.0
		 * @static
		 * @param {TweenTarget} targets
		 * @param {TweenVars} vars
		 * @returns {Tween} Tween instance
		 * @memberof Tween
		 * @link https://greensock.com/docs/v3/GSAP/gsap.set()
		 */
		static set(targets: TweenTarget, vars: TweenVars): Tween;
		/**
		 * **Deprecated method.** Use `gsap.from()` instead.
		 *
		 * @deprecated since 3.0.0
		 * @static
		 * @param {TweenTarget} targets
		 * @param {number} duration
		 * @param {TweenVars} vars
		 * @returns {Tween} Tween instance
		 * @memberof Tween
		 * @link https://greensock.com/docs/v3/GSAP/gsap.from()
		 */
		static staggerFrom(targets: TweenTarget, duration: number, vars: TweenVars): Tween;
		/**
		 * **Deprecated method.** Use `gsap.from()` instead.
		 *
		 * @deprecated since 3.0.0
		 * @static
		 * @param {TweenTarget} targets
		 * @param {TweenVars} vars
		 * @returns {Tween} Tween instance
		 * @memberof Tween
		 * @link https://greensock.com/docs/v3/GSAP/gsap.from()
		 */
		static staggerFrom(targets: TweenTarget, vars: TweenVars): Tween;
		/**
		 * **Deprecated method.** Use `gsap.fromTo()` instead.
		 *
		 * @deprecated since 3.0.0
		 * @static
		 * @param {TweenTarget} targets
		 * @param {number} duration
		 * @param {TweenVars} vars
		 * @returns {Tween} Tween instance
		 * @memberof Tween
		 * @link https://greensock.com/docs/v3/GSAP/gsap.fromTo()
		 */
		static staggerFromTo(targets: TweenTarget, duration: number, fromVars: TweenVars, toVars: TweenVars): Tween;
		/**
		 * **Deprecated method.** Use `gsap.fromTo()` instead.
		 *
		 * @deprecated since 3.0.0
		 * @static
		 * @param {TweenTarget} targets
		 * @param {TweenVars} vars
		 * @returns {Tween} Tween instance
		 * @memberof Tween
		 * @link https://greensock.com/docs/v3/GSAP/gsap.fromTo()
		 */
		static staggerFromTo(targets: TweenTarget, fromVars: TweenVars, toVars: TweenVars): Tween;
		/**
		 * **Deprecated method.** Use `gsap.to()` instead.
		 *
		 * @deprecated since 3.0.0
		 * @static
		 * @param {TweenTarget} targets
		 * @param {number} duration
		 * @param {TweenVars} vars
		 * @returns {Tween} Tween instance
		 * @memberof Tween
		 * @link https://greensock.com/docs/v3/GSAP/gsap.to()
		 */
		static staggerTo(targets: TweenTarget, duration: number, vars: TweenVars): Tween;
		/**
		 * **Deprecated method.** Use `gsap.to()` instead.
		 *
		 * @deprecated since 3.0.0
		 * @static
		 * @param {TweenTarget} targets
		 * @param {TweenVars} vars
		 * @returns {Tween} Tween instance
		 * @memberof Tween
		 * @link https://greensock.com/docs/v3/GSAP/gsap.to()
		 */
		static staggerTo(targets: TweenTarget, vars: TweenVars): Tween;
		/**
		 * Kills the parts of the tween specified.
		 * To kill means to immediately stop the tween, remove it from its parent timeline, and release it for garbage collection.
		 *
		 * ```js
		 * // kills the entire tween
		 * tween.kill();
		 *
		 * // kill all parts of the tween related to the target "myObject" (if the tween has multiple targets, the others will not be affected):
		 * tween.kill(myObject);
		 *
		 * // kill only the "x" and "y" properties of the tween (all targets):
		 * tween.kill(null, "x,y");
		 *
		 * // kill only the "x" and "y" properties of tween of the target "myObject":
		 * tween.kill(myObject, "x,y");
		 *
		 * // kill only the "opacity" properties of the tween of the targets "myObject1" and "myObject2":
		 * tween.kill([myObject1, myObject2], "opacity");
		 * ```
		 *
		 * @returns {Tween} The tween
		 * @memberof Tween
		 * @link https://greensock.com/docs/v3/GSAP/Tween/kill()
		 */
		kill(target?: object, propertiesList?: string): this;
		/**
		 * Redirects a property [that's already being animated by the tween] to a new value and restarts the tween in a performant way.
		 * A more common technique is to use gsap.quickTo() which uses resetTo() under the hood.
		 *
		 * ```js
		 * tween.resetTo("x", 200);
		 * ```
		 *
		 * @param {string} property
		 * @param {number} value
		 * @param {number} start
		 * @param {boolean} startIsRelative
		 * @returns {Tween} The tween
		 * @memberof Tween
		 * @link https://greensock.com/docs/v3/GSAP/Tween/resetTo()
		 */
		resetTo(property: string, value: number, start?: number, startIsRelative?: boolean): this;
		/**
		 * Returns an array of all of the tween's targets.
		 *
		 * ```js
		 * tween.targets();
		 * ```
		 *
		 * @returns {T[]} The array of targets
		 * @memberof Tween
		 * @link https://greensock.com/docs/v3/GSAP/Tween/targets()
		 */
		targets<T>(): T[];
	}
}
declare namespace gsap {
	type VelocityType = "num" | "deg" | "rad";
	interface VelocityMap {
		[key: string]: number;
	}
	interface VelocityTrackerInstance {
		readonly target: object;
		add(property: string, type?: VelocityType): void;
		kill(shallow?: boolean): void;
		remove(property: string): void;
		getAll(): VelocityMap;
		get(property: string): number;
	}
	interface VelocityTrackerStatic {
		getByTarget(target: TweenTarget): VelocityTrackerInstance;
		getVelocity(target: TweenTarget, property: string): number;
		isTracking(target: TweenTarget, property?: string): boolean;
		track(target: TweenTarget, properties: string, type?: VelocityType): VelocityTrackerInstance[];
		untrack(target: TweenTarget, properties?: string): void;
	}
	interface VelocityTracker extends VelocityTrackerStatic {
		new (target: TweenTarget, properties?: string, type?: VelocityType, next?: VelocityTrackerInstance): VelocityTrackerInstance;
		prototype: VelocityTrackerInstance;
		register(core: typeof gsap): void;
	}
}
declare namespace gsap {
	type RegisterablePlugins = Ease | EasePack | ExpoScaleEase | Plugin | RoughEase | SteppedEase | VelocityTracker | typeof core.Animation | typeof core.Tween | typeof core.Timeline | typeof Draggable | typeof GSDevTools | typeof MotionPathHelper | typeof SplitText | typeof Flip | typeof ScrollTrigger | typeof Observer | typeof ScrollSmoother;
	// querySelector returns type Element | null
	type DOMTarget = Element | string | null | Window | ArrayLike<Element | string | Window | null>;
	type TweenTarget = string | object | null;
	type Callback = (...args: any[]) => void | null;
	type ContextFunc = (context: Context) => Function | any | void;
	type CallbackType = "onComplete" | "onInterrupt" | "onRepeat" | "onReverseComplete" | "onStart" | "onUpdate";
	type TickerCallback = (time: number, deltaTime: number, frame: number, elapsed: number) => void | null;
	type Point2D = {
		x: number;
		y: number;
	};
	type Position = number | string;
	type FunctionBasedValue<T> = (index: number, target: any, targets: any[]) => T;
	type ArrayValue = any[] | FunctionBasedValue<any[]>;
	type BooleanValue = boolean | FunctionBasedValue<boolean>;
	type NumberValue = number | FunctionBasedValue<number>;
	type StringValue = string | FunctionBasedValue<string>;
	type ElementValue = Element | FunctionBasedValue<Element>;
	type TweenValue = NumberValue | StringValue;
	type QuickToFunc = {
		(value: number, start?: number, startIsRelative?: boolean): core.Tween;
		tween: core.Tween;
	};
	type SVGPathValue = string | SVGPathElement;
	type SVGPathTarget = SVGPathValue | ArrayLike<SVGPathValue>;
	type SVGPrimitive = SVGCircleElement | SVGRectElement | SVGEllipseElement | SVGPolygonElement | SVGPolylineElement | SVGLineElement;
	interface Conditions {
		[key: string]: boolean;
	}
	interface Context {
		[key: string]: Function | any;
		selector?: Function;
		isReverted: boolean;
		conditions?: Conditions;
		queries?: object;
		add(methodName: string, func: Function, scope?: Element | string | object): Function;
		add(func: Function, scope?: Element | string | object): void;
		ignore(func: Function): void;
		kill(revert?: boolean): void;
		revert(config?: object): void;
		clear(): void;
	}
	interface MatchMedia {
		contexts: Context[];
		add(conditions: string | object, func: ContextFunc, scope?: Element | string | object): MatchMedia;
		revert(config?: object): void;
		kill(revert?: boolean): void;
	}
	interface AnimationVars extends CallbackVars {
		[key: string]: any;
		data?: any;
		id?: string | number;
		inherit?: boolean;
		paused?: boolean;
		repeat?: number;
		repeatDelay?: number;
		repeatRefresh?: boolean;
		reversed?: boolean;
		yoyo?: boolean;
	}
	interface CallbackVars {
		callbackScope?: object;
		onComplete?: Callback;
		onCompleteParams?: any[];
		onRepeat?: Callback;
		onRepeatParams?: any[];
		onReverseComplete?: Callback;
		onReverseCompleteParams?: any[];
		onStart?: Callback;
		onStartParams?: any[];
		onUpdate?: Callback;
		onUpdateParams?: any[];
	}
	interface EaseMap {
		[key: string]: EaseFunction;
	}
	interface EffectsMap {
		[key: string]: any;
	}
	interface GSAPConfig {
		autoKillThreshold?: number;
		autoSleep?: number;
		force3D?: "auto" | boolean;
		nullTargetWarn?: boolean;
		resistance?: number;
		stringFilter?: Callback; // TODO: Find out signature
		unitFactors?: {
			time?: number;
			totalTime?: number;
		};
		units?: GSAPUnits;
	}
	type GSAPUnits = {
		bottom?: string;
		fontSize?: string;
		height?: string;
		left?: string;
		lineHeight?: string;
		margin?: string;
		padding?: string;
		perspective?: string;
		right?: string;
		rotation?: string;
		rotationX?: string;
		rotationY?: string;
		skewX?: string;
		skewY?: string;
		top?: string;
		width?: string;
		x?: string;
		y?: string;
		z?: string;
	} & {
		[key: string]: string;
	};
	interface StaggerVars extends CallbackVars, utils.DistributeConfig {
		repeat?: number;
		repeatDelay?: number;
		yoyo?: boolean;
		yoyoEase?: boolean | string | EaseFunction;
	}
	interface Ticker {
		add(callback: TickerCallback, once?: boolean, prioritize?: boolean): Callback;
		fps(fps: number): void;
		frame: number;
		lagSmoothing(threshold: number | boolean, adjustedLag?: number): void;
		remove(callback: Callback): void;
		sleep(): void;
		tick(): void;
		time: number;
		deltaRatio(fps?: number): number;
		wake(): void;
	}
	interface TimelineVars extends AnimationVars {
		autoRemoveChildren?: boolean;
		defaults?: TweenVars;
		delay?: number;
		smoothChildTiming?: boolean;
	}
	interface TweenVars extends AnimationVars {
		delay?: TweenValue;
		duration?: TweenValue;
		ease?: string | EaseFunction;
		endArray?: any[];
		immediateRender?: boolean;
		lazy?: boolean;
		keyframes?: TweenVars[] | object;
		onInterrupt?: Callback;
		onInterruptParams?: any[];
		overwrite?: "auto" | boolean;
		runBackwards?: boolean;
		stagger?: NumberValue | StaggerVars;
		startAt?: TweenVars;
		yoyoEase?: boolean | string | EaseFunction;
	}
	const effects: EffectsMap;
	const globalTimeline: core.Timeline;
	const ticker: Ticker;
	const version: string;
	/**
	 * Gets or sets GSAP's global configuration settings.
	 *
	 * Options: autoSleep, force3D, nullTargetWarn, and units
	 *
	 * ```js
	 * gsap.config({force3D: false});
	 * ```
	 *
	 * @param {GSAPConfig} [config]
	 * @returns {GSAPConfig} Configuration object
	 * @memberof gsap
	 * @link https://greensock.com/docs/v3/GSAP/gsap.config()
	 */
	function config(config?: GSAPConfig): GSAPConfig;
	/**
	 * Creates a Context object for recording/reverting any GSAP animations and/or ScrollTriggers that are in the provided function
	 *
	 * ```js
	 * let ctx = gsap.context((self) => {
	 *     gsap.to(".box", {x: 100});
	 * }, myElement);
	 *
	 * // then later
	 * ctx.revert();
	 * ```
	 *
	 * @param {ContextFunc} [func]
	 * @param {Element | string | object} [scope]
	 * @returns {Context} Context object
	 * @memberof gsap
	 * @link https://greensock.com/docs/v3/GSAP/gsap.context()
	 */
	function context(func?: ContextFunc, scope?: Element | string | object): Context;
	/**
	 * Gets or sets GSAP's global defaults. These will be inherited by every tween.
	 *
	 * ```js
	 * gsap.defaults({ease: "none", duration: 1});
	 * ```
	 *
	 * @param {TweenVars} [defaults]
	 * @returns {TweenVars} Defaults object
	 * @memberof gsap
	 * @link https://greensock.com/docs/v3/GSAP/gsap.defaults()
	 */
	function defaults(defaults?: TweenVars): TweenVars;
	/**
	 * Delays the call of a function by the specified amount.
	 *
	 * ```js
	 * let delayTween = gsap.delayedCall(1, myFunc);
	 * ```
	 *
	 * @param {number} delay
	 * @param {Function} callback
	 * @param {any[]} [params]
	 * @returns {Tween} Tween instance
	 * @memberof gsap
	 * @link https://greensock.com/docs/v3/GSAP/gsap.delayedCall()
	 */
	function delayedCall(delay: number, callback: Function, params?: any[]): core.Tween;
	/**
	 * Transfers all tweens, timelines, and (optionally) delayed calls from the root timeline into a new timeline.
	 *
	 * ```js
	 * let exportedTL = gsap.exportRoot();
	 * ```
	 *
	 * @param {TimelineVars} [vars]
	 * @param {boolean} [includeDelayedCalls]
	 * @returns {Timeline} Timeline instance
	 * @memberof gsap
	 * @link https://greensock.com/docs/v3/GSAP/gsap.exportRoot()
	 */
	function exportRoot(vars?: TimelineVars, includeDelayedCalls?: boolean): core.Timeline;
	/**
	 * Creates a tween coming FROM the given values.
	 *
	 * ```js
	 * gsap.from(".class", {x: 100});
	 * ```
	 *
	 * @param {TweenTarget} targets
	 * @param {TweenVars} vars
	 * @returns {Tween} Tween instance
	 * @memberof gsap
	 * @link https://greensock.com/docs/v3/GSAP/gsap.from()
	 */
	function from(targets: TweenTarget, vars: TweenVars): core.Tween;
	/**
	 * **Deprecated method signature.** Use the `duration` property instead.
	 *
	 * ```js
	 * gsap.from(".class", 1, {x: 100});
	 * ```
	 * @deprecated since 3.0.0
	 * @param {TweenTarget} targets
	 * @param {number} duration - The duration parameter is deprecated. Use the `duration` property instead.
	 * @param {TweenVars} vars
	 * @returns {Tween} Tween instance
	 * @memberof gsap
	 * @link https://greensock.com/docs/v3/GSAP/gsap.from()
	 */
	function from(targets: TweenTarget, duration: number, vars: TweenVars): core.Tween;
	/**
	* Creates a tween coming FROM the first set of values going TO the second set of values.
	*
	* ```js
	* gsap.fromTo(".class", {x: 0}, {x: 100});
	* ```
	*
	* @param {TweenTarget} targets
	* @param {TweenVars} fromVars
	* @param {TweenVars} toVars
	* @returns {Tween} Tween instance
	* @memberof gsap
	* @link https://greensock.com/docs/v3/GSAP/gsap.fromTo()
	*/
	function fromTo(targets: TweenTarget, fromVars: TweenVars, toVars: TweenVars): core.Tween;
	/**
	 * **Deprecated method signature.** Use the `duration` property instead.
	 *
	 * ```js
	 * gsap.fromTo(".class", 1, {x: 0}, {x: 100});
	 * ```
	 * @deprecated since version 3.0.0
	 * @param {TweenTarget} targets
	 * @param {number} duration - The duration parameter is deprecated. Use the `duration` property instead.
	 * @param {TweenVars} fromVars
	 * @param {TweenVars} toVars
	 * @returns {Tween} Tween instance
	 * @link https://greensock.com/docs/v3/GSAP/gsap.fromTo()
	 */
	function fromTo(targets: TweenTarget, duration: number, fromVars: TweenVars, toVars: TweenVars): core.Tween;
	/**
	 * Gets the tween or timeline with the specified ID if it exists.
	 *
	 * ```js
	 * gsap.to(obj, {id: "myTween", x: 100});
	 *
	 * // later
	 * let tween = gsap.getById("myTween");
	 * ```
	 *
	 * @param {string | number} id
	 * @returns {Tween} Tween instance
	 * @memberof gsap
	 * @link https://greensock.com/docs/v3/GSAP/gsap.getById()
	 */
	function getById<T extends core.Animation>(id: string | number): T;
	/**
	 * Gets the specified property of the target (or first of the targets) if it exists.
	 *
	 * ```js
	 * gsap.getProperty(element, "x");
	 * ```
	 *
	 * @param {TweenTarget} target
	 * @param {string} property
	 * @param {string} [unit]
	 * @returns {string | number} Value
	 * @memberof gsap
	 * @link https://greensock.com/docs/v3/GSAP/gsap.getProperty()
	 */
	function getProperty(target: TweenTarget, property: string, unit?: string): string | number;
	function getProperty(target: TweenTarget): (property: string, unit?: string) => string | number;
	/**
	 * Gets all of the tweens whose targets include the specified target or group of targets.
	 *
	 * ```js
	 * gsap.getTweensOf(element);
	 * ```
	 *
	 * @param {TweenTarget} targets
	 * @param {boolean} [onlyActive]
	 * @returns {Tween} Tween instance
	 * @memberof gsap
	 * @link https://greensock.com/docs/v3/GSAP/gsap.getTweensOf()
	 */
	function getTweensOf(targets: TweenTarget, onlyActive?: boolean): core.Tween[];
	/**
	 * Used to add all the GSAP globals to a particular tween object.
	 *
	 * ```js
	 * gsap.install(myTween);
	 * ```
	 *
	 * @param {object} targets
	 * @returns {gsap} The gsap object
	 * @memberof gsap
	 */
	function install(targets: object): typeof gsap;
	/**
	 * Reports whether or not a particular object is actively animating.
	 *
	 * ```js
	 * gsap.isTweening("#id");
	 * ```
	 *
	 * @param {TweenTarget} targets
	 * @returns {boolean} Status
	 * @memberof gsap
	 * @link https://greensock.com/docs/v3/GSAP/gsap.isTweening()
	 */
	function isTweening(targets: TweenTarget): boolean;
	/**
	 * Kills all the tweens (or specific tweening properties) of a particular object or the delayedCalls to a particular function.
	 *
	 * ```js
	 * gsap.killTweensOf(".myClass");
	 * gsap.killTweensOf(myObject, "opacity,x");
	 * ```
	 *
	 * @param {TweenTarget} targets
	 * @param {object | string} [properties]
	 * @param {boolean} [onlyActive]
	 * @returns {void} Void
	 * @memberof gsap
	 * @link https://greensock.com/docs/v3/GSAP/gsap.killTweensOf()
	 */
	function killTweensOf(targets: TweenTarget, properties?: object | string, onlyActive?: boolean): void;
	/**
	 * Creates a MatchMedia object for adding functions that run when a media query matches
	 *
	 * ```js
	 * let mm = gsap.matchMedia(myElement);
	 * mm.add("(max-width: 500px)", (context) => {
	 *     gsap.to(".box", {x: 100});
	 * });
	 * ```
	 *
	 * @param {Element | string | object} [scope]
	 * @returns {MatchMedia} MatchMedia object
	 * @memberof gsap
	 * @link https://greensock.com/docs/v3/GSAP/gsap.matchMedia()
	 */
	function matchMedia(scope?: Element | string | object): MatchMedia;
	/**
	 * Immediately reverts all active/matching MatchMedia objects and then runs any that currently match.
	 *
	 * ```js
	 * gsap.matchMediaRefresh();
	 * ```
	 *
	 * @memberof gsap
	 * @link https://greensock.com/docs/v3/GSAP/gsap.matchMediaRefresh()
	 */
	function matchMediaRefresh(): void;
	/**
	 * Returns the corresponding easing function for the given easing string.
	 *
	 * ```js
	 * let ease = gsap.parseEase("power1");
	 * ```
	 *
	 * @param {string | EaseFunction} ease
	 * @returns {EaseFunction} Ease function
	 * @memberof gsap
	 * @link https://greensock.com/docs/v3/GSAP/gsap.parseEase()
	 */
	function parseEase(ease: string | EaseFunction): EaseFunction;
	function parseEase(): EaseMap;
	/**
	 * Returns a function that acts as a simpler alternative of gsap.set() that is more performant but less versatile.
	 *
	 * ```js
	 * let setX = gsap.quickSetter("#id", "x", "px");
	 *
	 * // later
	 * setX(100);
	 * ```
	 *
	 * @param {TweenTarget} targets
	 * @param {string} property
	 * @param {string} [unit]
	 * @returns {Function} Setter function
	 * @memberof gsap
	 * @link https://greensock.com/docs/v3/GSAP/gsap.quickSetter()
	 */
	function quickSetter(targets: TweenTarget, property: string, unit?: string): Function;
	/**
	 * Returns a reusable function that performantly redirects a specific property to a new value, restarting the animation each time you feed in a new number.
	 *
	 * ```js
	 * let xTo = gsap.quickTo("#id", "x", {duration: 0.8, ease: "power3"});
	 *
	 * // later
	 * xTo(100);
	 * ```
	 *
	 * @param {TweenTarget} target
	 * @param {string} property
	 * @param {TweenVars} vars
	 * @returns {QuickToFunc} Setter function
	 * @memberof gsap
	 * @link https://greensock.com/docs/v3/GSAP/gsap.quickTo()
	 */
	function quickTo(target: TweenTarget, property: string, vars?: TweenVars): QuickToFunc;
	/**
	 * Register custom easing functions with GSAP, giving it a name so it can be referenced in any tweens.
	 *
	 * ```js
	 * gsap.registerEase("myEaseName", function(progress) {
	 *   return progress; //linear
	 * });
	 * ```
	 *
	 * @param {string} name
	 * @param {EaseFunction} ease
	 * @memberof gsap
	 * @link https://greensock.com/docs/v3/GSAP/gsap.registerEase()
	 */
	function registerEase(name: string, ease: EaseFunction): void;
	// TODO: Create interface for effect
	/**
	 * Registers custom effects (named tweens) for reuse with optional arguments.
	 *
	 * ```js
	 * // register the effect with GSAP:
	 * gsap.registerEffect({
	 *   name: "fade",
	 *   effect: (targets, config) => {
	 *     return gsap.to(targets, {duration: config.duration, opacity: 0});
	 *   },
	 *   defaults: {duration: 2}, //defaults get applied to any "config" object passed to the effect
	 *   extendTimeline: true, //now you can call the effect directly on any GSAP timeline to have the result immediately inserted in the position you define (default is sequenced at the end)
	 * });
	 *
	 * // now we can use it like this:
	 * gsap.effects.fade(".box");
	 * // or
	 * tl.fade(".box", {duration: 3})
	 * ```
	 *
	 * @param {object} effect
	 * @memberof gsap
	 * @link https://greensock.com/docs/v3/GSAP/gsap.registerEffect()
	 */
	function registerEffect(effect: object): void;
	/**
	 * Installs the specified GSAP plugins, provided they have been loaded already.
	 *
	 * ```js
	 * gsap.registerPlugin(MorphSVPlugin, MotionPathPlugin);
	 * ```
	 *
	 * @param {RegisterablePlugins[]} args
	 * @memberof gsap
	 * @link https://greensock.com/docs/v3/GSAP/gsap.registerPlugin()
	 */
	function registerPlugin(...args: object[]): void;
	/**
	 * Immediately sets properties of the target(s) to the properties specified.
	 *
	 * ```js
	 * gsap.set(".class", {x: 100, y: 50, opacity: 0});
	 * ```
	 *
	 * @param {TweenTarget} targets
	 * @param {TweenVars} vars
	 * @returns {Tween} Tween instance
	 * @memberof gsap
	 * @link https://greensock.com/docs/v3/GSAP/gsap.set()
	 */
	function set(targets: TweenTarget, vars: TweenVars): core.Tween;
	/**
	 * Creates a new timeline, used to compose sequences of tweens.
	 *
	 * @param {TimelineVars} [vars]
	 * @returns {Timeline} Timeline instance
	 * @memberof gsap
	 * @link https://greensock.com/docs/v3/GSAP/gsap.timeline()
	 */
	function timeline(vars?: TimelineVars): core.Timeline;
	/**
	 * Creates a tween going TO the given values.
	 *
	 * ```js
	 * gsap.to(".class", {x: 100});
	 * ```
	 *
	 * @param {TweenTarget} targets
	 * @param {TweenVars} vars
	 * @returns {Tween} Tween instance
	 * @memberof gsap
	 * @link https://greensock.com/docs/v3/GSAP/gsap.to()
	 */
	function to(targets: TweenTarget, vars: TweenVars): core.Tween;
	/**
	 * **Deprecated method signature.** Use the `duration` property instead.
	 *
	 * ```js
	 * gsap.to(".class", 1, {x: 100});
	 * ```
	 * @deprecated since version 3.0.0
	 * @param {TweenTarget} targets
	 * @param {number} duration - The duration parameter is deprecated. Use the `duration` property instead.
	 * @param {TweenVars} vars
	 * @returns {Tween} Tween instance
	 * @memberof gsap
	 * @link https://greensock.com/docs/v3/GSAP/gsap.to()
	 */
	function to(targets: TweenTarget, duration: number, vars: TweenVars): core.Tween;
	/**
	 * Manually update the root (global) timeline. Make sure to unhook GSAP's default ticker.
	 *
	 * ```js
	 * // unhooks the GSAP ticker
	 * gsap.ticker.remove(gsap.updateRoot);
	 *
	 * // sets the root time to 20 seconds manually
	 * gsap.updateRoot(20);
	 * ```
	 *
	 * @param {number} number
	 * @returns {void} Void
	 * @memberof gsap
	 * @link https://greensock.com/docs/v3/GSAP/gsap.updateRoot()
	 */
	function updateRoot(time: number): void;
}
interface PropertyTargetOptions {
	node?: {
		path: string;
		relativeTo: BaseNodeType;
	};
	object?: {
		list?: Object3D[];
		mask?: string;
	};
}
declare class AnimPropertyTarget {
	private _scene;
	private _options;
	constructor(_scene: PolyScene, _options: PropertyTargetOptions);
	clone(): AnimPropertyTarget;
	objects(): Object3D<Event>[] | ObjectContent<CoreObjectType>[] | undefined;
	node(): BaseNodeType | null | undefined;
}
interface RegisterOptions {
	registerproperties?: boolean;
	propertyTarget?: AnimPropertyTarget;
}
interface AddToTimelineOptions extends RegisterOptions {
	timelineBuilder: TimelineBuilder;
	timeline: GsapCoreTimeline;
	target: AnimPropertyTarget;
}
declare enum Operation {
	SET = "set",
	ADD = "add",
	SUBTRACT = "subtract"
}
interface AnimationRepeatParams {
	count: number;
	delay: number;
	yoyo: boolean;
}
type AnimPropertyTargetValue = number | Vector2 | Vector3 | Color | Vector4 | Quaternion;
declare class TimelineBuilderProperty {
	private _propertyName;
	private _targetValue;
	constructor();
	setName(name: string): void;
	setTargetValue(value: AnimPropertyTargetValue): void;
	name(): string | undefined;
	targetValue(): AnimPropertyTargetValue | undefined;
	private _debug;
	setDebug(debug: boolean): void;
	private _printDebug;
	clone(): TimelineBuilderProperty;
	addToTimeline(options: AddToTimelineOptions): void;
	private _populateWithObjects;
	private _populateVarsForObjectProperty;
	private _sceneGraphProps;
	private _populateWithNode;
	private _populateVarsForParam;
}
declare enum AnimationPositionMode {
	RELATIVE = "relative",
	ABSOLUTE = "absolute"
}
declare enum AnimationPositionRelativeTo {
	START = "start",
	END = "end"
}
declare class AnimationPosition {
	private _mode;
	private _relativeTo;
	private _offset;
	clone(): AnimationPosition;
	setMode(mode: AnimationPositionMode): void;
	mode(): AnimationPositionMode;
	setRelativeTo(relative_to: AnimationPositionRelativeTo): void;
	relativeTo(): AnimationPositionRelativeTo;
	setOffset(offset: number): void;
	offset(): number;
	toParameter(): string | number;
	private _relative_position_param;
	private _absolutePositionParam;
	private _offsetString;
}
declare class AnimationUpdateCallback {
	private _update_matrix;
	clone(): AnimationUpdateCallback;
	setUpdateMatrix(update_matrix: boolean): void;
	updateMatrix(): boolean;
}
declare class TimelineBuilder {
	private _timelineBuilders;
	private _parent;
	private _target;
	private _duration;
	private _keyframes;
	private _easing;
	private _operation;
	private _repeatParams;
	private _delay;
	private _position;
	private _property;
	private _updateCallback;
	private _stoppable;
	private _debug;
	setDebug(debug: boolean): void;
	private _printDebug;
	addTimelineBuilder(timeline_builder: TimelineBuilder): void;
	timelineBuilders(): TimelineBuilder[];
	setParent(parent: TimelineBuilder): void;
	parent(): TimelineBuilder | undefined;
	setTarget(target: AnimPropertyTarget): void;
	target(): AnimPropertyTarget | undefined;
	setDuration(duration: number): void;
	duration(): number;
	setKeyframes(keyframes: RampValue): void;
	keyframes(): RampValue | undefined;
	setEasing(easing: string): void;
	easing(): string | undefined;
	setOperation(operation: Operation): void;
	operation(): Operation;
	setRepeatParams(repeat_params: AnimationRepeatParams): void;
	repeatParams(): AnimationRepeatParams | undefined;
	setDelay(delay: number): void;
	delay(): number;
	setPosition(position: AnimationPosition | undefined): void;
	position(): AnimationPosition | undefined;
	setStoppable(state: boolean): void;
	stoppable(): boolean;
	setUpdateCallback(update_callback: AnimationUpdateCallback): void;
	updateCallback(): AnimationUpdateCallback | undefined;
	clone(): TimelineBuilder;
	setPropertyName(name: string): void;
	property(): TimelineBuilderProperty;
	propertyName(): string | undefined;
	setPropertyValue(value: AnimPropertyTargetValue): void;
	propertyValue(): AnimPropertyTargetValue | undefined;
	populate(timeline: GsapCoreTimeline, options: RegisterOptions): void;
}
// @ts-ignore
type SourceType = Source<any> | UserMedia;
type InstrumentType = Instrument<any>;
type EnvelopeParamsType = Partial<Omit<EnvelopeOptions, keyof ToneAudioNodeOptions>>;
type OscillatorParamsType = Partial<OmniOscillatorSynthOptions>;
declare class AudioBuilder {
	private _source;
	private _instrument;
	private _audioNode;
	private _oscillatorParams;
	private _envelopeParams;
	setAudioNode(inputNode: ToneAudioNode | undefined): void;
	audioNode(): ToneAudioNode<import("tone/build/esm/core/context/ToneWithContext").ToneWithContextOptions> | undefined;
	setSource(source: SourceType | undefined): void;
	source(): SourceType | undefined;
	setInstrument(instrument: InstrumentType | undefined): void;
	instrument(): InstrumentType | undefined;
	setOscillatorParams(params: OscillatorParamsType | undefined): void;
	oscillatorParams(): OscillatorParamsType | undefined;
	setEnvelopeParams(params: EnvelopeParamsType | undefined): void;
	envelopeParams(): Partial<Omit<EnvelopeOptions, "context">> | undefined;
	clone(): AudioBuilder;
}
interface ContainableMap {
	[NodeContext.ANIM]: TimelineBuilder;
	[NodeContext.AUDIO]: AudioBuilder;
	[NodeContext.COP]: Texture;
	[NodeContext.EVENT]: string;
	[NodeContext.GL]: string;
	[NodeContext.JS]: string;
	[NodeContext.MANAGER]: boolean;
	[NodeContext.MAT]: Material;
	[NodeContext.OBJ]: Object3D;
	[NodeContext.ROP]: any;
	[NodeContext.POST]: number;
	[NodeContext.SOP]: CoreGroup;
}
declare abstract class TypedContainer<NC extends NodeContext> {
	protected _node: TypedNode<NC, any>;
	protected _content: ContainableMap[NC];
	constructor(_node: TypedNode<NC, any>);
	set_node(node: TypedNode<NC, any>): void;
	node(): TypedNode<NC, any>;
	set_content(content: ContainableMap[NC]): void;
	has_content(): boolean;
	content(): ContainableMap[NC];
	protected _post_set_content(): void;
	coreContent(): ContainableMap[NC] | undefined;
	coreContentCloned(): ContainableMap[NC] | undefined;
	infos(): any;
}
declare class BaseContainer extends TypedContainer<any> {
}
interface BaseMethodFindDependencyArgs {
	indexOrPath: string | number | undefined;
	node?: BaseNodeType;
}
declare class BaseMethod {
	readonly param: BaseParamType;
	constructor(param: BaseParamType);
	private _node;
	protected node(): BaseNodeType | undefined;
	static requiredArguments(): any[];
	static optionalArguments(): any[];
	static minAllowedArgumentsCount(): number;
	static maxAllowedArgumentsCount(): number;
	static allowedArgumentsCount(count: number): boolean;
	processArguments(args: any): Promise<any>;
	getReferencedNodeContainer(indexOrPath: number | string): Promise<BaseContainer>;
	getReferencedParam(path: string, decomposedPath?: DecomposedPath): BaseParamType | null;
	findReferencedGraphNode(indexOrPath: number | string, decomposedPath?: DecomposedPath): CoreGraphNode | null;
	getReferencedNode(indexOrPath: string | number, decomposedPath?: DecomposedPath): BaseNodeType | null;
	findDependency(arg: BaseMethodFindDependencyArgs): MethodDependency | null;
	protected createDependencyFromIndexOrPath(args: BaseMethodFindDependencyArgs): MethodDependency | null;
	protected createDependency(node: CoreGraphNode, pathArgs: BaseMethodFindDependencyArgs, decomposedPath?: DecomposedPath): MethodDependency | null;
}
declare class MethodDependency extends CoreGraphNode {
	param: BaseParamType;
	pathArgs: BaseMethodFindDependencyArgs;
	decomposedPath?: DecomposedPath | undefined;
	jsep_node: Expression | undefined;
	resolved_graph_node: CoreGraphNode | undefined;
	unresolved_path: string | undefined;
	private _updateFromNameChangeBound;
	constructor(param: BaseParamType, pathArgs: BaseMethodFindDependencyArgs, decomposedPath?: DecomposedPath | undefined);
	private _updateFromNameChange;
	reset(): void;
	listen_for_name_changes(): void;
	set_jsep_node(jsep_node: Expression): void;
	set_resolved_graph_node(node: CoreGraphNode): void;
	set_unresolved_path(path: string): void;
	static create(param: BaseParamType, pathArgs: BaseMethodFindDependencyArgs, node: CoreGraphNode, decomposedPath?: DecomposedPath): MethodDependency;
}
declare class FunctionGenerator extends BaseTraverser {
	param: BaseParamType;
	private _entitiesDependent;
	private function;
	private _attribute_requirements_controller;
	private function_main_string;
	private methods;
	private method_index;
	methodDependencies: MethodDependency[];
	immutableDependencies: CoreGraphNode[];
	constructor(param: BaseParamType);
	entitiesDependent(): boolean;
	parseTree(parsedTree: ParsedTree): void;
	reset(): void;
	private _functionBody;
	evalAllowed(): boolean;
	evalFunction(): any;
	protected traverse_CallExpression(node: CallExpression): string | undefined;
	protected traverse_BinaryExpression(node: BinaryExpression): string;
	protected traverse_UnaryExpression(node: UnaryExpression): string;
	protected traverse_Identifier(node: Identifier): string | undefined;
	protected traverse_Identifier_F(): string;
	protected traverse_Identifier_T(): string;
	protected traverse_Identifier_OS(): string;
	protected traverse_Identifier_CH(): string;
	protected traverse_Identifier_CEX(): string;
	protected traverse_Identifier_CEY(): string;
	protected traverse_Identifier_CEZ(): string;
	private _method_centroid;
	private _createMethodAndDependencies;
}
declare class DependenciesController {
	param: BaseParamType;
	private _errorMessage;
	private _cyclicGraphDetected;
	private methodDependencies;
	constructor(param: BaseParamType);
	protected setError(message: string): void;
	errorMessage(): string | undefined;
	reset(): void;
	update(functionGenerator: FunctionGenerator): void;
	private _connectImmutableDependencies;
	private _handleMethodDependencies;
	private _handleMethodDependency;
	private _listenForNameChanges;
}
declare class ExpressionManager {
	param: BaseParamType;
	private _parseStarted;
	private _functionGenerator;
	private _expressionStringGenerator;
	dependenciesController: DependenciesController;
	private parsedTree;
	constructor(param: BaseParamType);
	generatedFunctionEntitiesDependent(): boolean;
	parseExpression(expression: string): void;
	computeFunction(): Promise<any>;
	reset(): void;
	isErrored(): boolean;
	errorMessage(): string | undefined;
	private _computeAllowed;
	updateFromMethodDependencyNameChange(): void;
}
type EntityCallback<T extends ParamType> = (entity: CoreEntity, value: ParamValuesTypeMap[T] | any) => void;
type PointEntityCallback<T extends ParamType> = (entity: CorePoint, value: ParamValuesTypeMap[T] | any) => void;
type ObjectEntityCallback<T extends ParamType> = (entity: BaseCoreObject<CoreObjectType>, value: ParamValuesTypeMap[T] | any) => void;
type CoreGroupEntityCallback<T extends ParamType> = (entity: CoreGroup, value: ParamValuesTypeMap[T] | any) => void;
declare class ExpressionController<T extends ParamType> {
	protected param: BaseParamType;
	protected _expression: string | undefined;
	protected _entities: CoreEntity[] | undefined;
	protected _entityCallback: EntityCallback<T> | undefined;
	protected _manager: ExpressionManager | undefined;
	protected _methodDependenciesByGraphNodeId: Map<CoreGraphNodeId, MethodDependency> | undefined;
	constructor(param: BaseParamType);
	dispose(): void;
	private _resetMethodDependencies;
	registerMethodDependency(methodDependency: MethodDependency): void;
	active(): boolean;
	expression(): string | undefined;
	isErrored(): boolean;
	errorMessage(): string | null | undefined;
	entitiesDependent(): boolean;
	setExpression(expression: string | undefined, setDirty?: boolean): void;
	updateFromMethodDependencyNameChange(): void;
	computeExpression(): Promise<any> | undefined;
	computeExpressionForEntities(entities: CoreEntity[], callback: EntityCallback<T>): Promise<void>;
	computeExpressionForPoints(entities: CorePoint[], callback: PointEntityCallback<T>): Promise<void>;
	computeExpressionForVertices(entities: CoreVertex<CoreObjectType>[], callback: PointEntityCallback<T>): Promise<void>;
	computeExpressionForPrimitives(entities: CorePrimitive<CoreObjectType>[], callback: PointEntityCallback<T>): Promise<void>;
	computeExpressionForObjects<OT extends CoreObjectType>(entities: BaseCoreObject<OT>[], callback: ObjectEntityCallback<T>): Promise<void>;
	computeExpressionForCoreGroup(entity: CoreGroup, callback: CoreGroupEntityCallback<T>): Promise<void>;
	entities(): CoreEntity[] | undefined;
	entityCallback(): EntityCallback<T> | undefined;
	private _setEntities;
	private _resetEntities;
}
declare enum ParamEvent {
	VISIBLE_UPDATED = "param_visible_updated",
	EDITABLE_UPDATED = "param_editable_updated",
	RAW_INPUT_UPDATED = "raw_input_updated",
	VALUE_UPDATED = "param_value_updated",
	EXPRESSION_UPDATED = "param_expression_update",
	ERROR_UPDATED = "param_error_updated",
	DELETED = "param_deleted",
	ASSET_RELOAD_REQUEST = "param_asset_reload_request"
}
declare class EmitController {
	protected param: BaseParamType;
	_blockedEmit: boolean;
	_blockedParentEmit: boolean;
	_countByEventName: Map<string, number>;
	constructor(param: BaseParamType);
	emitAllowed(): boolean;
	blockEmit(): boolean;
	unblockEmit(): boolean;
	blockParentEmit(): boolean;
	unblockParentEmit(): boolean;
	incrementCount(eventName: ParamEvent): void;
	eventsCount(eventName: ParamEvent): number;
	emit(event: ParamEvent): void;
}
interface ParamValueSerializedTypeMap {
	[ParamType.BOOLEAN]: boolean;
	[ParamType.BUTTON]: ParamInitValuesTypeMap[ParamType.BUTTON];
	[ParamType.COLOR]: Number3;
	[ParamType.FLOAT]: number;
	[ParamType.FOLDER]: null;
	[ParamType.INTEGER]: number;
	[ParamType.NODE_PATH]: ParamInitValuesTypeMap[ParamType.NODE_PATH];
	[ParamType.PARAM_PATH]: ParamInitValuesTypeMap[ParamType.PARAM_PATH];
	[ParamType.RAMP]: RampValueJson;
	[ParamType.STRING]: ParamInitValuesTypeMap[ParamType.STRING];
	[ParamType.VECTOR2]: Number2;
	[ParamType.VECTOR3]: Number3;
	[ParamType.VECTOR4]: Number4;
}
interface ParamValuePreConversionSerializedTypeMap {
	[ParamType.BOOLEAN]: undefined;
	[ParamType.BUTTON]: undefined;
	[ParamType.COLOR]: Number3;
	[ParamType.FLOAT]: undefined;
	[ParamType.FOLDER]: undefined;
	[ParamType.INTEGER]: undefined;
	[ParamType.NODE_PATH]: undefined;
	[ParamType.PARAM_PATH]: undefined;
	[ParamType.RAMP]: undefined;
	[ParamType.STRING]: undefined;
	[ParamType.VECTOR2]: undefined;
	[ParamType.VECTOR3]: undefined;
	[ParamType.VECTOR4]: undefined;
}
interface ParamSerializerData<T extends ParamType> {
	name: string;
	type: T;
	raw_input: ParamInitValueSerializedTypeMap[T];
	value: ParamValueSerializedTypeMap[T];
	value_pre_conversion: ParamValuePreConversionSerializedTypeMap[T];
	expression?: string;
	graph_node_id: CoreGraphNodeId;
	error_message?: string;
	is_visible: boolean;
	editable: boolean;
	folder_name?: string;
	components?: Readonly<CoreGraphNodeId[]>;
}
declare class CoreParamSerializer<T extends ParamType> {
	readonly param: TypedParam<T>;
	constructor(param: TypedParam<T>);
	toJSON(): ParamSerializerData<T>;
	rawInput(): ParamInitValueSerializedTypeMap[T];
	value(): ParamValueSerializedTypeMap[T];
	value_pre_conversion(): ParamValuePreConversionSerializedTypeMap[T];
	expression(): string | undefined;
	error_message(): string | undefined;
	is_visible(): boolean;
	editable(): boolean;
}
declare class ParamTimeDependentState {
	protected param: BaseParamType;
	constructor(param: BaseParamType);
	active(): boolean;
}
declare class ParamStatesController {
	protected param: BaseParamType;
	timeDependent: ParamTimeDependentState;
	error: ParamErrorState;
	constructor(param: BaseParamType);
}
type ComputeCallback = (value: void) => void;
// @ts-ignore
type OnDisposeCallback = () => void;
// @ts-ignore
interface ParamOptions<T extends ParamType> {
	serializerClass?: typeof CoreParamSerializer<T>;
}
declare abstract class TypedParam<T extends ParamType> extends CoreGraphNode {
	protected _default_value: ParamInitValuesTypeMap[T];
	protected _raw_input: ParamInitValuesTypeMap[T];
	protected _value: ParamValuesTypeMap[T];
	protected _node: BaseNodeType | undefined;
	protected _parent_param: TypedMultipleParam<any> | undefined;
	protected _components: FloatParam[] | undefined;
	protected _computeResolves: ComputeCallback[] | undefined;
	private _options;
	get options(): OptionsController;
	private _emitController;
	get emitController(): EmitController;
	protected _expression_controller: ExpressionController<T> | undefined;
	get expressionController(): ExpressionController<T> | undefined;
	expressionParsedAsString(): boolean;
	protected _serializer: CoreParamSerializer<T> | undefined;
	get serializer(): CoreParamSerializer<T> | undefined;
	private _states;
	get states(): ParamStatesController;
	constructor(scene: PolyScene, node: BaseNodeType, options: ParamOptions<T>);
	dispose(): void;
	protected _initializeParam(): void;
	postOptionsInitialize(): void;
	static type(): ParamType;
	type(): T;
	isNumeric(): boolean;
	setName(name: string): void;
	get value(): ParamValuesTypeMap[T];
	abstract defaultValueSerialized(): ParamInitValueSerializedTypeMap[T];
	abstract rawInputSerialized(): ParamInitValueSerializedTypeMap[T];
	abstract valueSerialized(): ParamValueSerializedTypeMap[T];
	copyValue(param: BaseParamType): void;
	protected _copyValue(param: TypedParam<T>): void;
	valuePreConversionSerialized(): ParamValuePreConversionSerializedTypeMap[T];
	convert(rawVal: any): ParamValuesTypeMap[T] | null;
	static areRawInputEqual(val1: any, val2: any): boolean;
	isRawInputEqual(other_raw_input: ParamInitValuesTypeMap[T]): any;
	isDefaultValueEqual(other_default_value: ParamInitValuesTypeMap[T]): any;
	static areValuesEqual(val1: any, val2: any): boolean;
	isValueEqual(other_val: ParamValuesTypeMap[T]): any;
	protected _cloneRawInput(raw_input: ParamInitValuesTypeMap[T]): ParamInitValuesTypeMap[T];
	set(raw_input: ParamInitValuesTypeMap[T]): void;
	protected _prefilterInvalidRawInput(raw_input: any): ParamInitValuesTypeMap[T];
	defaultValue(): ParamInitValuesTypeMap[T];
	isDefault(): boolean;
	rawInput(): ParamInitValuesTypeMap[T];
	protected processRawInput(): void;
	private _isComputing;
	isComputing(): boolean;
	compute(): Promise<void>;
	protected processComputation(): Promise<void>;
	setInitValue(init_value: ParamInitValuesTypeMap[T]): void;
	_setupNodeDependencies(node: BaseNodeType | null): void;
	get node(): BaseNodeType;
	parent(): BaseNodeType;
	set_parent_param(param: TypedMultipleParam<any>): void;
	parentParam(): TypedMultipleParam<any> | undefined;
	has_parent_param(): boolean;
	path(): string;
	pathRelativeTo(node: BaseNodeType): string;
	emit(eventName: ParamEvent): void;
	get components(): FloatParam[] | undefined;
	componentNames(): Readonly<string[]>;
	isMultiple(): boolean;
	initComponents(): void;
	hasExpression(): boolean;
	toJSON(): ParamSerializerData<T> | undefined;
	private _onDisposeCallbacks;
	onDispose(callback: OnDisposeCallback): void;
	deregisterOnDispose(callback: OnDisposeCallback): void;
	private _runOnDisposeCallbacks;
}
type BaseParamType = TypedParam<ParamType>;
interface GenericParamOptionsMenuEntry<T> {
	name: string;
	value: T;
}
type StringParamOptionsMenuEntry = GenericParamOptionsMenuEntry<string>;
type NumericParamOptionsMenuEntry = GenericParamOptionsMenuEntry<number>;
interface MenuNumericParamOptions {
	menu?: {
		entries: NumericParamOptionsMenuEntry[];
	};
}
interface MenuStringParamOptions {
	menuString?: {
		entries: StringParamOptionsMenuEntry[];
	};
}
declare enum StringParamLanguage {
	CSS = "css",
	GLSL = "glsl",
	HTML = "html",
	TYPESCRIPT = "typescript",
	JSON = "json"
}
type VisibleIfParamOptions = PolyDictionary<number | boolean | string>;
interface BaseParamOptions {
	cook?: boolean;
	spare?: boolean;
	hidden?: boolean;
	field?: boolean;
	visibleIf?: VisibleIfParamOptions | VisibleIfParamOptions[];
	separatorBefore?: boolean;
	separatorAfter?: boolean;
	joinToPreviousParam?: boolean;
	editable?: boolean;
}
interface ExpressionParamOptions {
	expression?: {
		forEntities?: boolean;
	};
}
interface NumberParamOptions extends BaseParamOptions {
	range?: Number2;
	rangeLocked?: Boolean2;
	step?: number;
}
interface FileParamOptions {
	fileBrowse?: {
		extensions: string[];
	};
}
interface ComputeOnDirtyParamOptions {
	computeOnDirty?: boolean;
}
interface CallbackParamOptions {
	callback?: (node: BaseNodeType, param: BaseParamType) => any;
	callbackString?: string;
}
interface LabelParamOptions {
	label?: string;
}
interface LabelVisibilityParamOptions {
	hideLabel?: boolean;
}
interface ColorConversionOptions {
	conversion?: ColorConversion;
}
interface BooleanParamOptions extends BaseParamOptions, ComputeOnDirtyParamOptions, MenuNumericParamOptions, ExpressionParamOptions, CallbackParamOptions, LabelParamOptions {
}
interface ButtonParamOptions extends BaseParamOptions, CallbackParamOptions, LabelParamOptions {
}
interface ColorParamOptions extends BaseParamOptions, LabelParamOptions, ColorConversionOptions, ExpressionParamOptions, CallbackParamOptions, ComputeOnDirtyParamOptions {
}
interface FloatParamOptions extends NumberParamOptions, MenuNumericParamOptions, ComputeOnDirtyParamOptions, ExpressionParamOptions, CallbackParamOptions {
}
interface FolderParamOptions extends BaseParamOptions {
	level?: number;
}
interface ObjectMask {
	inputIndex?: number;
	fromInputOnly?: boolean;
}
type ObjectMaskOptions = ObjectMask | boolean;
interface IntegerParamOptions extends NumberParamOptions, MenuNumericParamOptions, ComputeOnDirtyParamOptions, ExpressionParamOptions, CallbackParamOptions {
}
interface NodePathParamOptions extends BaseParamOptions, FileParamOptions, ComputeOnDirtyParamOptions, CallbackParamOptions {
	nodeSelection?: {
		context?: NodeContext;
		types?: Readonly<string[]>;
	};
	dependentOnFoundNode?: boolean;
}
interface ParamPathParamOptions extends BaseParamOptions, FileParamOptions, ComputeOnDirtyParamOptions, CallbackParamOptions {
	dependentOnFoundParam?: boolean;
	paramSelection?: ParamType | boolean;
}
interface RampParamOptions extends BaseParamOptions, LabelVisibilityParamOptions {
}
interface StringParamOptions extends BaseParamOptions, MenuStringParamOptions, FileParamOptions, CallbackParamOptions, ExpressionParamOptions, LabelVisibilityParamOptions {
	multiline?: boolean;
	language?: StringParamLanguage;
	objectMask?: ObjectMaskOptions;
}
interface VectorParamOptions extends BaseParamOptions, LabelParamOptions, ExpressionParamOptions, CallbackParamOptions, ComputeOnDirtyParamOptions {
}
interface Vector2ParamOptions extends VectorParamOptions {
}
interface Vector3ParamOptions extends VectorParamOptions {
}
interface QuaternionOptions {
	asQuaternion?: boolean;
}
interface Vector4ParamOptions extends VectorParamOptions, QuaternionOptions {
}
// @ts-ignore
interface ParamOptions extends NumberParamOptions, ColorConversionOptions, ComputeOnDirtyParamOptions, FolderParamOptions, ExpressionParamOptions, ButtonParamOptions, FileParamOptions, MenuNumericParamOptions, StringParamOptions, NodePathParamOptions, ParamPathParamOptions, LabelVisibilityParamOptions, QuaternionOptions {
	texture?: {
		env?: boolean;
	};
}
declare class OptionsController {
	private _param;
	private _programaticVisibleState;
	private _options;
	private _default_options;
	constructor(_param: BaseParamType);
	dispose(): void;
// @ts-ignore
	set(options: ParamOptions): void;
	copy(options_controller: OptionsController): void;
// @ts-ignore
	setOption<K extends keyof ParamOptions>(optionName: K, value: ParamOptions[K]): void;
	private _validateOption;
	private postSetOptions;
	param(): BaseParamType;
	node(): BaseNodeType;
// @ts-ignore
	default(): ParamOptions;
// @ts-ignore
	current(): ParamOptions;
	hasOptionsOverridden(): boolean;
// @ts-ignore
	overriddenOptions(): ParamOptions;
// @ts-ignore
	overriddenOptionNames(): Array<keyof ParamOptions>;
	computeOnDirty(): boolean;
	private _computeOnDirtyCallbackAdded;
	private _handleComputeOnDirty;
	private _computeParam;
	hasCallback(): boolean;
	private _callbackAllowed;
	allowCallback(): void;
	executeCallback(): Promise<void>;
	private getCallback;
	private createCallbackFromString;
	colorConversion(): ColorConversion;
	makesNodeDirtyWhenDirty(): boolean;
	fileBrowseOption(): {
		extensions: string[];
	} | undefined;
	fileBrowseAllowed(): boolean;
	fileBrowseExtensions(): string[] | null;
	separatorBefore(): boolean | undefined;
	separatorAfter(): boolean | undefined;
	joinToPreviousParam(): boolean | undefined;
	setEditableState(state: boolean): void;
	editable(): boolean;
	isExpressionForEntities(): boolean;
	level(): number;
	hasMenu(): boolean;
	private menuOptions;
	private menuStringOptions;
	menuEntries(): Array<NumericParamOptionsMenuEntry | StringParamOptionsMenuEntry>;
	ensureValueInMenuEntries(value: number): number;
	isMultiline(): boolean;
	language(): StringParamLanguage | undefined;
	isCode(): boolean;
	nodeSelectionOptions(): {
		context?: NodeContext | undefined;
		types?: readonly string[] | undefined;
	} | undefined;
	nodeSelectionContext(): NodeContext | undefined;
	nodeSelectionTypes(): readonly string[] | undefined;
	displayObjectMaskSelection(): boolean;
	objectMaskInputIndex(): number;
	objectMaskFromInputOnly(): boolean;
	dependentOnFoundNode(): boolean | undefined;
	dependentOnFoundParam(): boolean | undefined;
	isSelectingParam(): boolean;
	range(): Number2;
	step(): number | undefined;
	asQuaternion(): boolean;
	rangeLocked(): Boolean2;
	ensureInRange(value: number): number;
	isSpare(): boolean;
	textureOptions(): {
		env?: boolean | undefined;
	} | undefined;
	textureAsEnv(): boolean;
	isHidden(): boolean;
	isVisible(): boolean;
	setVisibleState(state: boolean): void;
	label(): string | undefined;
	isLabelHidden(): boolean;
	isFieldHidden(): boolean;
	uiDataDependsOnOtherParams(): boolean;
	visibilityPredecessors(): BaseParamType[];
	private _updateVisibilityAndRemoveDirtyBound;
	private _visibility_graph_node;
	private _ui_data_dependency_set;
	setUiDataDependency(): void;
	private updateVisibilityAndRemoveDirty;
	updateVisibility(): Promise<void>;
}
type ParamOptionsByTypeMapGeneric = {
	[key in ParamType]: object;
};
interface ParamOptionsByTypeMap extends ParamOptionsByTypeMapGeneric {
	[ParamType.BOOLEAN]: BooleanParamOptions;
	[ParamType.BUTTON]: ButtonParamOptions;
	[ParamType.COLOR]: ColorParamOptions;
	[ParamType.FLOAT]: FloatParamOptions;
	[ParamType.FOLDER]: FolderParamOptions;
	[ParamType.INTEGER]: IntegerParamOptions;
	[ParamType.NODE_PATH]: NodePathParamOptions;
	[ParamType.PARAM_PATH]: ParamPathParamOptions;
	[ParamType.RAMP]: RampParamOptions;
	[ParamType.STRING]: StringParamOptions;
	[ParamType.VECTOR2]: Vector2ParamOptions;
	[ParamType.VECTOR3]: Vector3ParamOptions;
	[ParamType.VECTOR4]: Vector4ParamOptions;
}
declare class ParamTemplate<T extends ParamType> {
	type: T;
	init_value: ParamInitValuesTypeMap[T];
// @ts-ignore
	options?: ParamOptions | undefined;
	readonly value_type: ParamValuesTypeMap[T];
	readonly param_class: ParamConstructorMap[T];
// @ts-ignore
	constructor(type: T, init_value: ParamInitValuesTypeMap[T], options?: ParamOptions | undefined);
}
declare class ParamConfig {
	static BUTTON(init_value: ParamInitValuesTypeMap[ParamType.BUTTON], options?: ParamOptionsByTypeMap[ParamType.BUTTON]): ParamTemplate<ParamType.BUTTON>;
	static BOOLEAN(init_value: ParamInitValuesTypeMap[ParamType.BOOLEAN], options?: ParamOptionsByTypeMap[ParamType.BOOLEAN]): ParamTemplate<ParamType.BOOLEAN>;
	static COLOR(init_value: ParamInitValuesTypeMap[ParamType.COLOR], options?: ParamOptionsByTypeMap[ParamType.COLOR]): ParamTemplate<ParamType.COLOR>;
	static FLOAT(init_value: ParamInitValuesTypeMap[ParamType.FLOAT], options?: ParamOptionsByTypeMap[ParamType.FLOAT]): ParamTemplate<ParamType.FLOAT>;
	static FOLDER(init_value?: ParamInitValuesTypeMap[ParamType.FOLDER], options?: ParamOptionsByTypeMap[ParamType.FOLDER]): ParamTemplate<ParamType.FOLDER>;
	static INTEGER(init_value: ParamInitValuesTypeMap[ParamType.INTEGER], options?: ParamOptionsByTypeMap[ParamType.INTEGER]): ParamTemplate<ParamType.INTEGER>;
	static RAMP(init_value?: ParamInitValuesTypeMap[ParamType.RAMP], options?: ParamOptionsByTypeMap[ParamType.RAMP]): ParamTemplate<ParamType.RAMP>;
	static STRING(init_value?: ParamInitValuesTypeMap[ParamType.STRING], options?: ParamOptionsByTypeMap[ParamType.STRING]): ParamTemplate<ParamType.STRING>;
	static VECTOR2(init_value: ParamInitValuesTypeMap[ParamType.VECTOR2], options?: ParamOptionsByTypeMap[ParamType.VECTOR2]): ParamTemplate<ParamType.VECTOR2>;
	static VECTOR3(init_value: ParamInitValuesTypeMap[ParamType.VECTOR3], options?: ParamOptionsByTypeMap[ParamType.VECTOR3]): ParamTemplate<ParamType.VECTOR3>;
	static VECTOR4(init_value: ParamInitValuesTypeMap[ParamType.VECTOR4], options?: ParamOptionsByTypeMap[ParamType.VECTOR4]): ParamTemplate<ParamType.VECTOR4>;
	static NODE_PATH(init_value: "", // forces at empty value at init, instead of ParamInitValuesTypeMap[ParamType.NODE_PATH],
	options?: ParamOptionsByTypeMap[ParamType.NODE_PATH]): ParamTemplate<ParamType.NODE_PATH>;
	static PARAM_PATH(init_value: "", // forces at empty value at init, instead of ParamInitValuesTypeMap[ParamType.PARAM_PATH],
	options?: ParamOptionsByTypeMap[ParamType.PARAM_PATH]): ParamTemplate<ParamType.PARAM_PATH>;
}
declare class NodeParamsConfig {
}
declare class HierarchyParamConfigAll extends NodeParamsConfig {
	/** @param group to apply this node to */
	group: ParamTemplate<ParamType.STRING>;
}
declare enum ModuleName {
	CAD = "CAD",
	CSG = "CSG",
	GSAP = "GSAP",
	PBR = "PBR",
	POLY_ANIM = "POLY_ANIM",
	POLY_GL = "POLY_GL",
	POLY_OBJ = "POLY_OBJ",
	POLY_SOP = "POLY_SOP",
	QUAD = "QUAD",
	SDF = "SDF",
	TET = "TET"
}
declare class TypedAnimNode<K extends NodeParamsConfig> extends TypedNode<NodeContext.ANIM, K> {
	readonly flags: FlagsControllerB;
	static context(): NodeContext;
	requiredModules(): ModuleName[];
	initializeBaseNode(): void;
	protected setTimelineBuilder(timeline_builder: TimelineBuilder): void;
}
type BaseAnimNodeType = TypedAnimNode<NodeParamsConfig>;
declare class TypedAudioNode<K extends NodeParamsConfig> extends TypedNode<NodeContext.AUDIO, K> {
	readonly flags: FlagsControllerB;
	static context(): NodeContext;
	initializeBaseNode(): void;
	protected setAudioBuilder(audioBuilder: AudioBuilder): void;
}
type BaseAudioNodeType = TypedAudioNode<NodeParamsConfig>;
declare class TypedCopNode<K extends NodeParamsConfig> extends TypedNode<NodeContext.COP, K> {
	readonly flags: FlagsControllerBO;
	static context(): NodeContext;
	initializeBaseNode(): void;
	private ___textureSync;
	__textureSync__(): Texture | undefined;
	setTexture(texture: Texture): void;
	protected _clearTexture(): void;
}
type BaseCopNodeType = TypedCopNode<any>;
declare abstract class TypedInputEventNode<K extends BaseInputEventParamsConfig> extends TypedEventNode<K> {
	initializeBaseNode(): void;
	processEvent(eventContext: EventContext<Event>): void;
	static PARAM_CALLBACK_updateRegister(node: BaseInputEventNodeType): void;
	private _updateRegister;
	private _activeEventDatas;
	private _updateActiveEventDatas;
	protected abstract acceptedEventTypes(): Set<EventType>;
	activeEventDatas(): EventData[];
}
declare class BaseInputEventParamsConfig extends NodeParamsConfig {
	active: ParamTemplate<ParamType.BOOLEAN>;
	/** @param set which element triggers the event */
	element: ParamTemplate<ParamType.INTEGER>;
}
type BaseInputEventNodeType = TypedInputEventNode<BaseInputEventParamsConfig>;
declare enum PolyEventName {
	POLY_PROGRESS = "POLYProgress",
	SCENE_CREATED = "POLYSceneCreated",
	SCENE_READY = "POLYSceneReady",
	SCENE_PLAY = "POLYScenePlay",
	SCENE_PAUSE = "POLYScenePause",
	VIEWER_MOUNTED = "POLYViewerMounted",
	VIEWER_READY = "POLYViewerReady"
}
declare class PolySceneEvent extends Event {
	constructor(type: PolyEventName);
	get type(): PolyEventName;
}
declare class SceneEventsController {
	dispatch<T extends PolyEventName>(eventContext: EventContext<PolySceneEvent>): void;
	private _observersByEventType;
	removeObserverFromAllEventTypes(eventNode: BaseEventNodeType): void;
	addObserver(eventNode: BaseEventNodeType, eventType: PolyEventName): void;
}
declare enum EventInputType {
	DRAG = "drag",
	KEYBOARD = "keyboard",
	MOUSE = "mouse",
	POINTER = "pointer",
	TOUCH = "touch",
	WINDOW = "window"
}
declare class PointerEventParamsConfig extends NodeParamsConfig {
	/** @param toggle on to allow any event to be listened to */
	active: ParamTemplate<ParamType.BOOLEAN>;
	/** @param set which element triggers the event */
	element: ParamTemplate<ParamType.INTEGER>;
	/** @param toggle on to listen to click events */
	pointerdown: ParamTemplate<ParamType.BOOLEAN>;
	/** @param toggle on to listen to pointermove events */
	pointermove: ParamTemplate<ParamType.BOOLEAN>;
	/** @param toggle on to listen to pointerup events */
	pointerup: ParamTemplate<ParamType.BOOLEAN>;
	/** @param requires ctrlKey */
	ctrlKey: ParamTemplate<ParamType.BOOLEAN>;
	/** @param requires altKey */
	altKey: ParamTemplate<ParamType.BOOLEAN>;
	/** @param requires shiftKey */
	shiftKey: ParamTemplate<ParamType.BOOLEAN>;
	/** @param requires metaKey */
	metaKey: ParamTemplate<ParamType.BOOLEAN>;
}
declare class PointerEventNode extends TypedInputEventNode<PointerEventParamsConfig> {
	paramsConfig: PointerEventParamsConfig;
	static type(): EventInputType;
	protected acceptedEventTypes(): Set<PointerEventType>;
	initializeNode(): void;
	processEvent(eventContext: EventContext<MouseEvent>): void;
}
declare class DragEventsController extends BaseSceneEventsController<MouseEvent, PointerEventNode> {
	protected _requireCanvasEventListeners: boolean;
	type(): string;
	acceptedEventTypes(): Set<DragEventType>;
}
declare class KeyboardEventParamsConfig extends NodeParamsConfig {
	/** @param toggle on to allow any event to be listened to */
	active: ParamTemplate<ParamType.BOOLEAN>;
	/** @param set which element triggers the event */
	element: ParamTemplate<ParamType.INTEGER>;
	/** @param toggle on to listen to keydown events */
	keydown: ParamTemplate<ParamType.BOOLEAN>;
	/** @param toggle on to listen to keypress events */
	keypress: ParamTemplate<ParamType.BOOLEAN>;
	/** @param toggle on to listen to keyup events */
	keyup: ParamTemplate<ParamType.BOOLEAN>;
	/** @param space separated list of accepted key codes. If this is empty then any key is accepted. */
	keyCodes: ParamTemplate<ParamType.STRING>;
	/** @param requires ctrlKey */
	ctrlKey: ParamTemplate<ParamType.BOOLEAN>;
	/** @param requires altKey */
	altKey: ParamTemplate<ParamType.BOOLEAN>;
	/** @param requires shiftKey */
	shiftKey: ParamTemplate<ParamType.BOOLEAN>;
	/** @param requires metaKey */
	metaKey: ParamTemplate<ParamType.BOOLEAN>;
}
declare class KeyboardEventNode extends TypedInputEventNode<KeyboardEventParamsConfig> {
	paramsConfig: KeyboardEventParamsConfig;
	static type(): EventInputType;
	protected acceptedEventTypes(): Set<KeyboardEventType>;
	initializeNode(): void;
	setElement(element: CoreEventEmitter): void;
	processEvent(eventContext: EventContext<KeyboardEvent>): void;
}
declare class KeyboardEventsController extends BaseSceneEventsController<KeyboardEvent, KeyboardEventNode> {
	private timeController;
	private keyboardEventsController;
	constructor(dispatcher: SceneEventsDispatcher);
	protected _requireCanvasEventListeners: boolean;
	type(): string;
	acceptedEventTypes(): Set<string>;
	private _currentEvents;
	private _lastProcessedFrame;
	currentEvents(): KeyboardEvent[];
	processEvent(eventContext: EventContext<KeyboardEvent>): void;
}
declare class MouseEventParamsConfig extends NodeParamsConfig {
	/** @param toggle on to allow any event to be listened to */
	active: ParamTemplate<ParamType.BOOLEAN>;
	/** @param set which element triggers the event */
	element: ParamTemplate<ParamType.INTEGER>;
	/** @param toggle on to listen to auxclick events */
	auxclick: ParamTemplate<ParamType.BOOLEAN>;
	/** @param toggle on to listen to click events */
	click: ParamTemplate<ParamType.BOOLEAN>;
	/** @param toggle on to listen to contextmenu events */
	contextmenu: ParamTemplate<ParamType.BOOLEAN>;
	/** @param toggle on to listen to dblclick events */
	dblclick: ParamTemplate<ParamType.BOOLEAN>;
	/** @param toggle on to listen to mousedown events */
	mousedown: ParamTemplate<ParamType.BOOLEAN>;
	/** @param toggle on to listen to mouseenter events */
	mouseenter: ParamTemplate<ParamType.BOOLEAN>;
	/** @param toggle on to listen to mouseleave events */
	mouseleave: ParamTemplate<ParamType.BOOLEAN>;
	/** @param toggle on to listen to mousemove events */
	mousemove: ParamTemplate<ParamType.BOOLEAN>;
	/** @param toggle on to listen to mouseover events */
	mouseover: ParamTemplate<ParamType.BOOLEAN>;
	/** @param toggle on to listen to mouseout events */
	mouseout: ParamTemplate<ParamType.BOOLEAN>;
	/** @param toggle on to listen to mouseup events */
	mouseup: ParamTemplate<ParamType.BOOLEAN>;
	/** @param toggle on to listen to pointerlockchange events */
	pointerlockchange: ParamTemplate<ParamType.BOOLEAN>;
	/** @param toggle on to listen to pointerlockerror events */
	pointerlockerror: ParamTemplate<ParamType.BOOLEAN>;
	/** @param toggle on to listen to select events */
	select: ParamTemplate<ParamType.BOOLEAN>;
	/** @param toggle on to listen to wheel events */
	wheel: ParamTemplate<ParamType.BOOLEAN>;
	/** @param requires ctrlKey */
	ctrlKey: ParamTemplate<ParamType.BOOLEAN>;
	/** @param requires altKey */
	altKey: ParamTemplate<ParamType.BOOLEAN>;
	/** @param requires shiftKey */
	shiftKey: ParamTemplate<ParamType.BOOLEAN>;
	/** @param requires metaKey */
	metaKey: ParamTemplate<ParamType.BOOLEAN>;
}
declare class MouseEventNode extends TypedInputEventNode<MouseEventParamsConfig> {
	paramsConfig: MouseEventParamsConfig;
	static type(): EventInputType;
	protected acceptedEventTypes(): Set<MouseEventType>;
	initializeNode(): void;
	processEvent(eventContext: EventContext<MouseEvent>): void;
}
declare class MouseEventsController extends BaseSceneEventsController<MouseEvent, MouseEventNode> {
	protected _requireCanvasEventListeners: boolean;
	type(): string;
	acceptedEventTypes(): Set<MouseEventType>;
}
interface RaycasterUpdateOptions {
	pointsThreshold: number;
	lineThreshold: number;
}
declare class PointerEventsController extends BaseSceneEventsController<MouseEvent | TouchEvent, PointerEventNode> {
	private pointerEventsController;
	constructor(dispatcher: SceneEventsDispatcher);
	protected _requireCanvasEventListeners: boolean;
	private _cursorHelper;
	protected _cursor0: import("@vue/reactivity").Ref<{
		x: number;
		y: number;
		width: number;
		height: number;
		readonly isVector2: true;
		set: (x: number, y: number) => Vector2;
		setScalar: (scalar: number) => Vector2;
		setX: (x: number) => Vector2;
		setY: (y: number) => Vector2;
		setComponent: (index: number, value: number) => Vector2;
		getComponent: (index: number) => number;
		clone: () => Vector2;
		copy: (v: Vector2) => Vector2;
		add: (v: Vector2, w?: Vector2 | undefined) => Vector2;
		addScalar: (s: number) => Vector2;
		addVectors: (a: Vector2, b: Vector2) => Vector2;
		addScaledVector: (v: Vector2, s: number) => Vector2;
		sub: (v: Vector2) => Vector2;
		subScalar: (s: number) => Vector2;
		subVectors: (a: Vector2, b: Vector2) => Vector2;
		multiply: (v: Vector2) => Vector2;
		multiplyScalar: (scalar: number) => Vector2;
		divide: (v: Vector2) => Vector2;
		divideScalar: (s: number) => Vector2;
		applyMatrix3: (m: Matrix3) => Vector2;
		min: (v: Vector2) => Vector2;
		max: (v: Vector2) => Vector2;
		clamp: (min: Vector2, max: Vector2) => Vector2;
		clampScalar: (min: number, max: number) => Vector2;
		clampLength: (min: number, max: number) => Vector2;
		floor: () => Vector2;
		ceil: () => Vector2;
		round: () => Vector2;
		roundToZero: () => Vector2;
		negate: () => Vector2;
		dot: (v: Vector2) => number;
		cross: (v: Vector2) => number;
		lengthSq: () => number;
		length: () => number;
		lengthManhattan: () => number;
		manhattanLength: () => number;
		normalize: () => Vector2;
		angle: () => number;
		angleTo: (v: Vector2) => number;
		distanceTo: (v: Vector2) => number;
		distanceToSquared: (v: Vector2) => number;
		distanceToManhattan: (v: Vector2) => number;
		manhattanDistanceTo: (v: Vector2) => number;
		setLength: (length: number) => Vector2;
		lerp: (v: Vector2, alpha: number) => Vector2;
		lerpVectors: (v1: Vector2, v2: Vector2, alpha: number) => Vector2;
		equals: (v: Vector2) => boolean;
		fromArray: (array: number[] | ArrayLike<number>, offset?: number | undefined) => Vector2;
		toArray: {
			(array?: number[] | undefined, offset?: number | undefined): number[];
			(array?: Vector2Tuple | undefined, offset?: 0 | undefined): Vector2Tuple;
			(array: ArrayLike<number>, offset?: number | undefined): ArrayLike<number>;
		};
		fromBufferAttribute: (attribute: BufferAttribute, index: number) => Vector2;
		rotateAround: (center: Vector2, angle: number) => Vector2;
		random: () => Vector2;
	}>;
	private _raycaster0;
	type(): string;
	acceptedEventTypes(): Set<PointerEventType>;
	setRaycaster(raycaster: Raycaster): void;
	processEvent(eventContext: EventContext<MouseEvent | TouchEvent>): void;
	raycaster(): import("@vue/reactivity").Ref<{
		ray: {
			origin: {
				x: number;
				y: number;
				z: number;
				readonly isVector3: true;
				set: (x: number, y: number, z: number) => Vector3;
				setScalar: (scalar: number) => Vector3;
				setX: (x: number) => Vector3;
				setY: (y: number) => Vector3;
				setZ: (z: number) => Vector3;
				setComponent: (index: number, value: number) => Vector3;
				setFromColor: (color: Color) => Vector3;
				getComponent: (index: number) => number;
				clone: () => Vector3;
				copy: (v: Vector3) => Vector3;
				add: (v: Vector3) => Vector3;
				addScalar: (s: number) => Vector3;
				addScaledVector: (v: Vector3, s: number) => Vector3;
				addVectors: (a: Vector3, b: Vector3) => Vector3;
				sub: (a: Vector3) => Vector3;
				subScalar: (s: number) => Vector3;
				subVectors: (a: Vector3, b: Vector3) => Vector3;
				multiply: (v: Vector3) => Vector3;
				multiplyScalar: (s: number) => Vector3;
				multiplyVectors: (a: Vector3, b: Vector3) => Vector3;
				applyEuler: (euler: Euler) => Vector3;
				applyAxisAngle: (axis: Vector3, angle: number) => Vector3;
				applyMatrix3: (m: Matrix3) => Vector3;
				applyNormalMatrix: (m: Matrix3) => Vector3;
				applyMatrix4: (m: Matrix4) => Vector3;
				applyQuaternion: (q: Quaternion) => Vector3;
				project: (camera: Camera) => Vector3;
				unproject: (camera: Camera) => Vector3;
				transformDirection: (m: Matrix4) => Vector3;
				divide: (v: Vector3) => Vector3;
				divideScalar: (s: number) => Vector3;
				min: (v: Vector3) => Vector3;
				max: (v: Vector3) => Vector3;
				clamp: (min: Vector3, max: Vector3) => Vector3;
				clampScalar: (min: number, max: number) => Vector3;
				clampLength: (min: number, max: number) => Vector3;
				floor: () => Vector3;
				ceil: () => Vector3;
				round: () => Vector3;
				roundToZero: () => Vector3;
				negate: () => Vector3;
				dot: (v: Vector3) => number;
				lengthSq: () => number;
				length: () => number;
				lengthManhattan: () => number;
				manhattanLength: () => number;
				manhattanDistanceTo: (v: Vector3) => number;
				normalize: () => Vector3;
				setLength: (l: number) => Vector3;
				lerp: (v: Vector3, alpha: number) => Vector3;
				lerpVectors: (v1: Vector3, v2: Vector3, alpha: number) => Vector3;
				cross: (a: Vector3) => Vector3;
				crossVectors: (a: Vector3, b: Vector3) => Vector3;
				projectOnVector: (v: Vector3) => Vector3;
				projectOnPlane: (planeNormal: Vector3) => Vector3;
				reflect: (vector: Vector3) => Vector3;
				angleTo: (v: Vector3) => number;
				distanceTo: (v: Vector3) => number;
				distanceToSquared: (v: Vector3) => number;
				distanceToManhattan: (v: Vector3) => number;
				setFromSpherical: (s: Spherical) => Vector3;
				setFromSphericalCoords: (r: number, phi: number, theta: number) => Vector3;
				setFromCylindrical: (s: Cylindrical) => Vector3;
				setFromCylindricalCoords: (radius: number, theta: number, y: number) => Vector3;
				setFromMatrixPosition: (m: Matrix4) => Vector3;
				setFromMatrixScale: (m: Matrix4) => Vector3;
				setFromMatrixColumn: (matrix: Matrix4, index: number) => Vector3;
				setFromMatrix3Column: (matrix: Matrix3, index: number) => Vector3;
				setFromEuler: (e: Euler) => Vector3;
				equals: (v: Vector3) => boolean;
				fromArray: (array: number[] | ArrayLike<number>, offset?: number | undefined) => Vector3;
				toArray: {
					(array?: number[] | undefined, offset?: number | undefined): number[];
					(array?: Vector3Tuple | undefined, offset?: 0 | undefined): Vector3Tuple;
					(array: ArrayLike<number>, offset?: number | undefined): ArrayLike<number>;
				};
				fromBufferAttribute: (attribute: BufferAttribute | InterleavedBufferAttribute, index: number) => Vector3;
				random: () => Vector3;
				randomDirection: () => Vector3;
			};
			direction: {
				x: number;
				y: number;
				z: number;
				readonly isVector3: true;
				set: (x: number, y: number, z: number) => Vector3;
				setScalar: (scalar: number) => Vector3;
				setX: (x: number) => Vector3;
				setY: (y: number) => Vector3;
				setZ: (z: number) => Vector3;
				setComponent: (index: number, value: number) => Vector3;
				setFromColor: (color: Color) => Vector3;
				getComponent: (index: number) => number;
				clone: () => Vector3;
				copy: (v: Vector3) => Vector3;
				add: (v: Vector3) => Vector3;
				addScalar: (s: number) => Vector3;
				addScaledVector: (v: Vector3, s: number) => Vector3;
				addVectors: (a: Vector3, b: Vector3) => Vector3;
				sub: (a: Vector3) => Vector3;
				subScalar: (s: number) => Vector3;
				subVectors: (a: Vector3, b: Vector3) => Vector3;
				multiply: (v: Vector3) => Vector3;
				multiplyScalar: (s: number) => Vector3;
				multiplyVectors: (a: Vector3, b: Vector3) => Vector3;
				applyEuler: (euler: Euler) => Vector3;
				applyAxisAngle: (axis: Vector3, angle: number) => Vector3;
				applyMatrix3: (m: Matrix3) => Vector3;
				applyNormalMatrix: (m: Matrix3) => Vector3;
				applyMatrix4: (m: Matrix4) => Vector3;
				applyQuaternion: (q: Quaternion) => Vector3;
				project: (camera: Camera) => Vector3;
				unproject: (camera: Camera) => Vector3;
				transformDirection: (m: Matrix4) => Vector3;
				divide: (v: Vector3) => Vector3;
				divideScalar: (s: number) => Vector3;
				min: (v: Vector3) => Vector3;
				max: (v: Vector3) => Vector3;
				clamp: (min: Vector3, max: Vector3) => Vector3;
				clampScalar: (min: number, max: number) => Vector3;
				clampLength: (min: number, max: number) => Vector3;
				floor: () => Vector3;
				ceil: () => Vector3;
				round: () => Vector3;
				roundToZero: () => Vector3;
				negate: () => Vector3;
				dot: (v: Vector3) => number;
				lengthSq: () => number;
				length: () => number;
				lengthManhattan: () => number;
				manhattanLength: () => number;
				manhattanDistanceTo: (v: Vector3) => number;
				normalize: () => Vector3;
				setLength: (l: number) => Vector3;
				lerp: (v: Vector3, alpha: number) => Vector3;
				lerpVectors: (v1: Vector3, v2: Vector3, alpha: number) => Vector3;
				cross: (a: Vector3) => Vector3;
				crossVectors: (a: Vector3, b: Vector3) => Vector3;
				projectOnVector: (v: Vector3) => Vector3;
				projectOnPlane: (planeNormal: Vector3) => Vector3;
				reflect: (vector: Vector3) => Vector3;
				angleTo: (v: Vector3) => number;
				distanceTo: (v: Vector3) => number;
				distanceToSquared: (v: Vector3) => number;
				distanceToManhattan: (v: Vector3) => number;
				setFromSpherical: (s: Spherical) => Vector3;
				setFromSphericalCoords: (r: number, phi: number, theta: number) => Vector3;
				setFromCylindrical: (s: Cylindrical) => Vector3;
				setFromCylindricalCoords: (radius: number, theta: number, y: number) => Vector3;
				setFromMatrixPosition: (m: Matrix4) => Vector3;
				setFromMatrixScale: (m: Matrix4) => Vector3;
				setFromMatrixColumn: (matrix: Matrix4, index: number) => Vector3;
				setFromMatrix3Column: (matrix: Matrix3, index: number) => Vector3;
				setFromEuler: (e: Euler) => Vector3;
				equals: (v: Vector3) => boolean;
				fromArray: (array: number[] | ArrayLike<number>, offset?: number | undefined) => Vector3;
				toArray: {
					(array?: number[] | undefined, offset?: number | undefined): number[];
					(array?: Vector3Tuple | undefined, offset?: 0 | undefined): Vector3Tuple;
					(array: ArrayLike<number>, offset?: number | undefined): ArrayLike<number>;
				};
				fromBufferAttribute: (attribute: BufferAttribute | InterleavedBufferAttribute, index: number) => Vector3;
				random: () => Vector3;
				randomDirection: () => Vector3;
			};
			set: (origin: Vector3, direction: Vector3) => Ray;
			clone: () => Ray;
			copy: (ray: Ray) => Ray;
			at: (t: number, target: Vector3) => Vector3;
			lookAt: (v: Vector3) => Ray;
			recast: (t: number) => Ray;
			closestPointToPoint: (point: Vector3, target: Vector3) => Vector3;
			distanceToPoint: (point: Vector3) => number;
			distanceSqToPoint: (point: Vector3) => number;
			distanceSqToSegment: (v0: Vector3, v1: Vector3, optionalPointOnRay?: Vector3 | undefined, optionalPointOnSegment?: Vector3 | undefined) => number;
			intersectSphere: (sphere: Sphere, target: Vector3) => Vector3 | null;
			intersectsSphere: (sphere: Sphere) => boolean;
			distanceToPlane: (plane: Plane) => number;
			intersectPlane: (plane: Plane, target: Vector3) => Vector3 | null;
			intersectsPlane: (plane: Plane) => boolean;
			intersectBox: (box: Box3, target: Vector3) => Vector3 | null;
			intersectsBox: (box: Box3) => boolean;
			intersectTriangle: (a: Vector3, b: Vector3, c: Vector3, backfaceCulling: boolean, target: Vector3) => Vector3 | null;
			applyMatrix4: (matrix4: Matrix4) => Ray;
			equals: (ray: Ray) => boolean;
			isIntersectionBox: (b: any) => any;
			isIntersectionPlane: (p: any) => any;
			isIntersectionSphere: (s: any) => any;
		};
		near: number;
		far: number;
		camera: {
			readonly isCamera: true;
			readonly type: string;
			layers: {
				mask: number;
				set: (layer: number) => void;
				enable: (layer: number) => void;
				enableAll: () => void;
				toggle: (layer: number) => void;
				disable: (layer: number) => void;
				disableAll: () => void;
				test: (layers: Layers) => boolean;
				isEnabled: (layer: number) => boolean;
			};
			matrixWorldInverse: {
				elements: number[];
				set: (n11: number, n12: number, n13: number, n14: number, n21: number, n22: number, n23: number, n24: number, n31: number, n32: number, n33: number, n34: number, n41: number, n42: number, n43: number, n44: number) => Matrix4;
				identity: () => Matrix4;
				clone: () => Matrix4;
				copy: (m: Matrix4) => Matrix4;
				copyPosition: (m: Matrix4) => Matrix4;
				extractBasis: (xAxis: Vector3, yAxis: Vector3, zAxis: Vector3) => Matrix4;
				makeBasis: (xAxis: Vector3, yAxis: Vector3, zAxis: Vector3) => Matrix4;
				extractRotation: (m: Matrix4) => Matrix4;
				makeRotationFromEuler: (euler: Euler) => Matrix4;
				makeRotationFromQuaternion: (q: Quaternion) => Matrix4;
				lookAt: (eye: Vector3, target: Vector3, up: Vector3) => Matrix4;
				multiply: (m: Matrix4) => Matrix4;
				premultiply: (m: Matrix4) => Matrix4;
				multiplyMatrices: (a: Matrix4, b: Matrix4) => Matrix4;
				multiplyToArray: (a: Matrix4, b: Matrix4, r: number[]) => Matrix4;
				multiplyScalar: (s: number) => Matrix4;
				determinant: () => number;
				transpose: () => Matrix4;
				setPosition: (v: number | Vector3, y?: number | undefined, z?: number | undefined) => Matrix4;
				invert: () => Matrix4;
				scale: (v: Vector3) => Matrix4;
				getMaxScaleOnAxis: () => number;
				makeTranslation: (x: number, y: number, z: number) => Matrix4;
				makeRotationX: (theta: number) => Matrix4;
				makeRotationY: (theta: number) => Matrix4;
				makeRotationZ: (theta: number) => Matrix4;
				makeRotationAxis: (axis: Vector3, angle: number) => Matrix4;
				makeScale: (x: number, y: number, z: number) => Matrix4;
				makeShear: (xy: number, xz: number, yx: number, yz: number, zx: number, zy: number) => Matrix4;
				compose: (translation: Vector3, rotation: Quaternion, scale: Vector3) => Matrix4;
				decompose: (translation: Vector3, rotation: Quaternion, scale: Vector3) => Matrix4;
				makePerspective: {
					(left: number, right: number, bottom: number, top: number, near: number, far: number): Matrix4;
					(fov: number, aspect: number, near: number, far: number): Matrix4;
				};
				makeOrthographic: (left: number, right: number, top: number, bottom: number, near: number, far: number) => Matrix4;
				equals: (matrix: Matrix4) => boolean;
				fromArray: (array: number[] | ArrayLike<number>, offset?: number | undefined) => Matrix4;
				toArray: {
					(array?: number[] | undefined, offset?: number | undefined): number[];
					(array?: Matrix4Tuple | undefined, offset?: 0 | undefined): Matrix4Tuple;
					(array?: ArrayLike<number> | undefined, offset?: number | undefined): ArrayLike<number>;
				};
				setFromMatrix3: (m: Matrix3) => Matrix4;
				extractPosition: (m: Matrix4) => Matrix4;
				setRotationFromQuaternion: (q: Quaternion) => Matrix4;
				multiplyVector3: (v: any) => any;
				multiplyVector4: (v: any) => any;
				multiplyVector3Array: (array: number[]) => number[];
				rotateAxis: (v: any) => void;
				crossVector: (v: any) => void;
				flattenToArrayOffset: (array: number[], offset: number) => number[];
				getInverse: (matrix: Matrix) => Matrix;
			};
			projectionMatrix: {
				elements: number[];
				set: (n11: number, n12: number, n13: number, n14: number, n21: number, n22: number, n23: number, n24: number, n31: number, n32: number, n33: number, n34: number, n41: number, n42: number, n43: number, n44: number) => Matrix4;
				identity: () => Matrix4;
				clone: () => Matrix4;
				copy: (m: Matrix4) => Matrix4;
				copyPosition: (m: Matrix4) => Matrix4;
				extractBasis: (xAxis: Vector3, yAxis: Vector3, zAxis: Vector3) => Matrix4;
				makeBasis: (xAxis: Vector3, yAxis: Vector3, zAxis: Vector3) => Matrix4;
				extractRotation: (m: Matrix4) => Matrix4;
				makeRotationFromEuler: (euler: Euler) => Matrix4;
				makeRotationFromQuaternion: (q: Quaternion) => Matrix4;
				lookAt: (eye: Vector3, target: Vector3, up: Vector3) => Matrix4;
				multiply: (m: Matrix4) => Matrix4;
				premultiply: (m: Matrix4) => Matrix4;
				multiplyMatrices: (a: Matrix4, b: Matrix4) => Matrix4;
				multiplyToArray: (a: Matrix4, b: Matrix4, r: number[]) => Matrix4;
				multiplyScalar: (s: number) => Matrix4;
				determinant: () => number;
				transpose: () => Matrix4;
				setPosition: (v: number | Vector3, y?: number | undefined, z?: number | undefined) => Matrix4;
				invert: () => Matrix4;
				scale: (v: Vector3) => Matrix4;
				getMaxScaleOnAxis: () => number;
				makeTranslation: (x: number, y: number, z: number) => Matrix4;
				makeRotationX: (theta: number) => Matrix4;
				makeRotationY: (theta: number) => Matrix4;
				makeRotationZ: (theta: number) => Matrix4;
				makeRotationAxis: (axis: Vector3, angle: number) => Matrix4;
				makeScale: (x: number, y: number, z: number) => Matrix4;
				makeShear: (xy: number, xz: number, yx: number, yz: number, zx: number, zy: number) => Matrix4;
				compose: (translation: Vector3, rotation: Quaternion, scale: Vector3) => Matrix4;
				decompose: (translation: Vector3, rotation: Quaternion, scale: Vector3) => Matrix4;
				makePerspective: {
					(left: number, right: number, bottom: number, top: number, near: number, far: number): Matrix4;
					(fov: number, aspect: number, near: number, far: number): Matrix4;
				};
				makeOrthographic: (left: number, right: number, top: number, bottom: number, near: number, far: number) => Matrix4;
				equals: (matrix: Matrix4) => boolean;
				fromArray: (array: number[] | ArrayLike<number>, offset?: number | undefined) => Matrix4;
				toArray: {
					(array?: number[] | undefined, offset?: number | undefined): number[];
					(array?: Matrix4Tuple | undefined, offset?: 0 | undefined): Matrix4Tuple;
					(array?: ArrayLike<number> | undefined, offset?: number | undefined): ArrayLike<number>;
				};
				setFromMatrix3: (m: Matrix3) => Matrix4;
				extractPosition: (m: Matrix4) => Matrix4;
				setRotationFromQuaternion: (q: Quaternion) => Matrix4;
				multiplyVector3: (v: any) => any;
				multiplyVector4: (v: any) => any;
				multiplyVector3Array: (array: number[]) => number[];
				rotateAxis: (v: any) => void;
				crossVector: (v: any) => void;
				flattenToArrayOffset: (array: number[], offset: number) => number[];
				getInverse: (matrix: Matrix) => Matrix;
			};
			projectionMatrixInverse: {
				elements: number[];
				set: (n11: number, n12: number, n13: number, n14: number, n21: number, n22: number, n23: number, n24: number, n31: number, n32: number, n33: number, n34: number, n41: number, n42: number, n43: number, n44: number) => Matrix4;
				identity: () => Matrix4;
				clone: () => Matrix4;
				copy: (m: Matrix4) => Matrix4;
				copyPosition: (m: Matrix4) => Matrix4;
				extractBasis: (xAxis: Vector3, yAxis: Vector3, zAxis: Vector3) => Matrix4;
				makeBasis: (xAxis: Vector3, yAxis: Vector3, zAxis: Vector3) => Matrix4;
				extractRotation: (m: Matrix4) => Matrix4;
				makeRotationFromEuler: (euler: Euler) => Matrix4;
				makeRotationFromQuaternion: (q: Quaternion) => Matrix4;
				lookAt: (eye: Vector3, target: Vector3, up: Vector3) => Matrix4;
				multiply: (m: Matrix4) => Matrix4;
				premultiply: (m: Matrix4) => Matrix4;
				multiplyMatrices: (a: Matrix4, b: Matrix4) => Matrix4;
				multiplyToArray: (a: Matrix4, b: Matrix4, r: number[]) => Matrix4;
				multiplyScalar: (s: number) => Matrix4;
				determinant: () => number;
				transpose: () => Matrix4;
				setPosition: (v: number | Vector3, y?: number | undefined, z?: number | undefined) => Matrix4;
				invert: () => Matrix4;
				scale: (v: Vector3) => Matrix4;
				getMaxScaleOnAxis: () => number;
				makeTranslation: (x: number, y: number, z: number) => Matrix4;
				makeRotationX: (theta: number) => Matrix4;
				makeRotationY: (theta: number) => Matrix4;
				makeRotationZ: (theta: number) => Matrix4;
				makeRotationAxis: (axis: Vector3, angle: number) => Matrix4;
				makeScale: (x: number, y: number, z: number) => Matrix4;
				makeShear: (xy: number, xz: number, yx: number, yz: number, zx: number, zy: number) => Matrix4;
				compose: (translation: Vector3, rotation: Quaternion, scale: Vector3) => Matrix4;
				decompose: (translation: Vector3, rotation: Quaternion, scale: Vector3) => Matrix4;
				makePerspective: {
					(left: number, right: number, bottom: number, top: number, near: number, far: number): Matrix4;
					(fov: number, aspect: number, near: number, far: number): Matrix4;
				};
				makeOrthographic: (left: number, right: number, top: number, bottom: number, near: number, far: number) => Matrix4;
				equals: (matrix: Matrix4) => boolean;
				fromArray: (array: number[] | ArrayLike<number>, offset?: number | undefined) => Matrix4;
				toArray: {
					(array?: number[] | undefined, offset?: number | undefined): number[];
					(array?: Matrix4Tuple | undefined, offset?: 0 | undefined): Matrix4Tuple;
					(array?: ArrayLike<number> | undefined, offset?: number | undefined): ArrayLike<number>;
				};
				setFromMatrix3: (m: Matrix3) => Matrix4;
				extractPosition: (m: Matrix4) => Matrix4;
				setRotationFromQuaternion: (q: Quaternion) => Matrix4;
				multiplyVector3: (v: any) => any;
				multiplyVector4: (v: any) => any;
				multiplyVector3Array: (array: number[]) => number[];
				rotateAxis: (v: any) => void;
				crossVector: (v: any) => void;
				flattenToArrayOffset: (array: number[], offset: number) => number[];
				getInverse: (matrix: Matrix) => Matrix;
			};
			getWorldDirection: (target: Vector3) => Vector3;
			readonly isObject3D: true;
			readonly id: number;
			uuid: string;
			name: string;
			parent: {
				readonly isObject3D: true;
				readonly id: number;
				uuid: string;
				name: string;
				readonly type: string;
				parent: any | null;
				children: any[];
				up: {
					x: number;
					y: number;
					z: number;
					readonly isVector3: true;
					set: (x: number, y: number, z: number) => Vector3;
					setScalar: (scalar: number) => Vector3;
					setX: (x: number) => Vector3;
					setY: (y: number) => Vector3;
					setZ: (z: number) => Vector3;
					setComponent: (index: number, value: number) => Vector3;
					setFromColor: (color: Color) => Vector3;
					getComponent: (index: number) => number;
					clone: () => Vector3;
					copy: (v: Vector3) => Vector3;
					add: (v: Vector3) => Vector3;
					addScalar: (s: number) => Vector3;
					addScaledVector: (v: Vector3, s: number) => Vector3;
					addVectors: (a: Vector3, b: Vector3) => Vector3;
					sub: (a: Vector3) => Vector3;
					subScalar: (s: number) => Vector3;
					subVectors: (a: Vector3, b: Vector3) => Vector3;
					multiply: (v: Vector3) => Vector3;
					multiplyScalar: (s: number) => Vector3;
					multiplyVectors: (a: Vector3, b: Vector3) => Vector3;
					applyEuler: (euler: Euler) => Vector3;
					applyAxisAngle: (axis: Vector3, angle: number) => Vector3;
					applyMatrix3: (m: Matrix3) => Vector3;
					applyNormalMatrix: (m: Matrix3) => Vector3;
					applyMatrix4: (m: Matrix4) => Vector3;
					applyQuaternion: (q: Quaternion) => Vector3;
					project: (camera: Camera) => Vector3;
					unproject: (camera: Camera) => Vector3;
					transformDirection: (m: Matrix4) => Vector3;
					divide: (v: Vector3) => Vector3;
					divideScalar: (s: number) => Vector3;
					min: (v: Vector3) => Vector3;
					max: (v: Vector3) => Vector3;
					clamp: (min: Vector3, max: Vector3) => Vector3;
					clampScalar: (min: number, max: number) => Vector3;
					clampLength: (min: number, max: number) => Vector3;
					floor: () => Vector3;
					ceil: () => Vector3;
					round: () => Vector3;
					roundToZero: () => Vector3;
					negate: () => Vector3;
					dot: (v: Vector3) => number;
					lengthSq: () => number;
					length: () => number;
					lengthManhattan: () => number;
					manhattanLength: () => number;
					manhattanDistanceTo: (v: Vector3) => number;
					normalize: () => Vector3;
					setLength: (l: number) => Vector3;
					lerp: (v: Vector3, alpha: number) => Vector3;
					lerpVectors: (v1: Vector3, v2: Vector3, alpha: number) => Vector3;
					cross: (a: Vector3) => Vector3;
					crossVectors: (a: Vector3, b: Vector3) => Vector3;
					projectOnVector: (v: Vector3) => Vector3;
					projectOnPlane: (planeNormal: Vector3) => Vector3;
					reflect: (vector: Vector3) => Vector3;
					angleTo: (v: Vector3) => number;
					distanceTo: (v: Vector3) => number;
					distanceToSquared: (v: Vector3) => number;
					distanceToManhattan: (v: Vector3) => number;
					setFromSpherical: (s: Spherical) => Vector3;
					setFromSphericalCoords: (r: number, phi: number, theta: number) => Vector3;
					setFromCylindrical: (s: Cylindrical) => Vector3;
					setFromCylindricalCoords: (radius: number, theta: number, y: number) => Vector3;
					setFromMatrixPosition: (m: Matrix4) => Vector3;
					setFromMatrixScale: (m: Matrix4) => Vector3;
					setFromMatrixColumn: (matrix: Matrix4, index: number) => Vector3;
					setFromMatrix3Column: (matrix: Matrix3, index: number) => Vector3;
					setFromEuler: (e: Euler) => Vector3;
					equals: (v: Vector3) => boolean;
					fromArray: (array: number[] | ArrayLike<number>, offset?: number | undefined) => Vector3;
					toArray: {
						(array?: number[] | undefined, offset?: number | undefined): number[];
						(array?: Vector3Tuple | undefined, offset?: 0 | undefined): Vector3Tuple;
						(array: ArrayLike<number>, offset?: number | undefined): ArrayLike<number>;
					};
					fromBufferAttribute: (attribute: BufferAttribute | InterleavedBufferAttribute, index: number) => Vector3;
					random: () => Vector3;
					randomDirection: () => Vector3;
				};
				readonly position: {
					x: number;
					y: number;
					z: number;
					readonly isVector3: true;
					set: (x: number, y: number, z: number) => Vector3;
					setScalar: (scalar: number) => Vector3;
					setX: (x: number) => Vector3;
					setY: (y: number) => Vector3;
					setZ: (z: number) => Vector3;
					setComponent: (index: number, value: number) => Vector3;
					setFromColor: (color: Color) => Vector3;
					getComponent: (index: number) => number;
					clone: () => Vector3;
					copy: (v: Vector3) => Vector3;
					add: (v: Vector3) => Vector3;
					addScalar: (s: number) => Vector3;
					addScaledVector: (v: Vector3, s: number) => Vector3;
					addVectors: (a: Vector3, b: Vector3) => Vector3;
					sub: (a: Vector3) => Vector3;
					subScalar: (s: number) => Vector3;
					subVectors: (a: Vector3, b: Vector3) => Vector3;
					multiply: (v: Vector3) => Vector3;
					multiplyScalar: (s: number) => Vector3;
					multiplyVectors: (a: Vector3, b: Vector3) => Vector3;
					applyEuler: (euler: Euler) => Vector3;
					applyAxisAngle: (axis: Vector3, angle: number) => Vector3;
					applyMatrix3: (m: Matrix3) => Vector3;
					applyNormalMatrix: (m: Matrix3) => Vector3;
					applyMatrix4: (m: Matrix4) => Vector3;
					applyQuaternion: (q: Quaternion) => Vector3;
					project: (camera: Camera) => Vector3;
					unproject: (camera: Camera) => Vector3;
					transformDirection: (m: Matrix4) => Vector3;
					divide: (v: Vector3) => Vector3;
					divideScalar: (s: number) => Vector3;
					min: (v: Vector3) => Vector3;
					max: (v: Vector3) => Vector3;
					clamp: (min: Vector3, max: Vector3) => Vector3;
					clampScalar: (min: number, max: number) => Vector3;
					clampLength: (min: number, max: number) => Vector3;
					floor: () => Vector3;
					ceil: () => Vector3;
					round: () => Vector3;
					roundToZero: () => Vector3;
					negate: () => Vector3;
					dot: (v: Vector3) => number;
					lengthSq: () => number;
					length: () => number;
					lengthManhattan: () => number;
					manhattanLength: () => number;
					manhattanDistanceTo: (v: Vector3) => number;
					normalize: () => Vector3;
					setLength: (l: number) => Vector3;
					lerp: (v: Vector3, alpha: number) => Vector3;
					lerpVectors: (v1: Vector3, v2: Vector3, alpha: number) => Vector3;
					cross: (a: Vector3) => Vector3;
					crossVectors: (a: Vector3, b: Vector3) => Vector3;
					projectOnVector: (v: Vector3) => Vector3;
					projectOnPlane: (planeNormal: Vector3) => Vector3;
					reflect: (vector: Vector3) => Vector3;
					angleTo: (v: Vector3) => number;
					distanceTo: (v: Vector3) => number;
					distanceToSquared: (v: Vector3) => number;
					distanceToManhattan: (v: Vector3) => number;
					setFromSpherical: (s: Spherical) => Vector3;
					setFromSphericalCoords: (r: number, phi: number, theta: number) => Vector3;
					setFromCylindrical: (s: Cylindrical) => Vector3;
					setFromCylindricalCoords: (radius: number, theta: number, y: number) => Vector3;
					setFromMatrixPosition: (m: Matrix4) => Vector3;
					setFromMatrixScale: (m: Matrix4) => Vector3;
					setFromMatrixColumn: (matrix: Matrix4, index: number) => Vector3;
					setFromMatrix3Column: (matrix: Matrix3, index: number) => Vector3;
					setFromEuler: (e: Euler) => Vector3;
					equals: (v: Vector3) => boolean;
					fromArray: (array: number[] | ArrayLike<number>, offset?: number | undefined) => Vector3;
					toArray: {
						(array?: number[] | undefined, offset?: number | undefined): number[];
						(array?: Vector3Tuple | undefined, offset?: 0 | undefined): Vector3Tuple;
						(array: ArrayLike<number>, offset?: number | undefined): ArrayLike<number>;
					};
					fromBufferAttribute: (attribute: BufferAttribute | InterleavedBufferAttribute, index: number) => Vector3;
					random: () => Vector3;
					randomDirection: () => Vector3;
				};
				readonly rotation: {
					x: number;
					y: number;
					z: number;
					order: EulerOrder;
					readonly isEuler: true;
					_onChangeCallback: () => void;
					set: (x: number, y: number, z: number, order?: EulerOrder | undefined) => Euler;
					clone: () => Euler;
					copy: (euler: Euler) => Euler;
					setFromRotationMatrix: (m: Matrix4, order?: EulerOrder | undefined, update?: boolean | undefined) => Euler;
					setFromQuaternion: (q: Quaternion, order?: EulerOrder | undefined, update?: boolean | undefined) => Euler;
					setFromVector3: (v: Vector3, order?: EulerOrder | undefined) => Euler;
					reorder: (newOrder: EulerOrder) => Euler;
					equals: (euler: Euler) => boolean;
					fromArray: (xyzo: [
						number,
						number,
						number,
						(EulerOrder | undefined)?,
						...any[]
					]) => Euler;
					toArray: (array?: (string | number | undefined)[] | undefined, offset?: number | undefined) => (string | number | undefined)[];
					_onChange: (callback: () => void) => Euler;
					[Symbol.iterator]: () => Generator<string | number, void, unknown>;
				};
				readonly quaternion: {
					x: number;
					y: number;
					z: number;
					w: number;
					readonly isQuaternion: true;
					set: (x: number, y: number, z: number, w: number) => Quaternion;
					clone: () => Quaternion;
					copy: (q: Quaternion) => Quaternion;
					setFromEuler: (euler: Euler, update?: boolean | undefined) => Quaternion;
					setFromAxisAngle: (axis: Vector3, angle: number) => Quaternion;
					setFromRotationMatrix: (m: Matrix4) => Quaternion;
					setFromUnitVectors: (vFrom: Vector3, vTo: Vector3) => Quaternion;
					angleTo: (q: Quaternion) => number;
					rotateTowards: (q: Quaternion, step: number) => Quaternion;
					identity: () => Quaternion;
					invert: () => Quaternion;
					conjugate: () => Quaternion;
					dot: (v: Quaternion) => number;
					lengthSq: () => number;
					length: () => number;
					normalize: () => Quaternion;
					multiply: (q: Quaternion) => Quaternion;
					premultiply: (q: Quaternion) => Quaternion;
					multiplyQuaternions: (a: Quaternion, b: Quaternion) => Quaternion;
					slerp: (qb: Quaternion, t: number) => Quaternion;
					slerpQuaternions: (qa: Quaternion, qb: Quaternion, t: number) => Quaternion;
					equals: (v: Quaternion) => boolean;
					fromArray: (array: number[] | ArrayLike<number>, offset?: number | undefined) => Quaternion;
					toArray: {
						(array?: number[] | undefined, offset?: number | undefined): number[];
						(array: ArrayLike<number>, offset?: number | undefined): ArrayLike<number>;
					};
					toJSON: () => [
						number,
						number,
						number,
						number
					];
					fromBufferAttribute: (attribute: BufferAttribute | InterleavedBufferAttribute, index: number) => Quaternion;
					_onChange: (callback: () => void) => Quaternion;
					_onChangeCallback: () => void;
					multiplyVector3: (v: any) => any;
					random: () => Quaternion;
					[Symbol.iterator]: () => Generator<number, void, unknown>;
				};
				readonly scale: {
					x: number;
					y: number;
					z: number;
					readonly isVector3: true;
					set: (x: number, y: number, z: number) => Vector3;
					setScalar: (scalar: number) => Vector3;
					setX: (x: number) => Vector3;
					setY: (y: number) => Vector3;
					setZ: (z: number) => Vector3;
					setComponent: (index: number, value: number) => Vector3;
					setFromColor: (color: Color) => Vector3;
					getComponent: (index: number) => number;
					clone: () => Vector3;
					copy: (v: Vector3) => Vector3;
					add: (v: Vector3) => Vector3;
					addScalar: (s: number) => Vector3;
					addScaledVector: (v: Vector3, s: number) => Vector3;
					addVectors: (a: Vector3, b: Vector3) => Vector3;
					sub: (a: Vector3) => Vector3;
					subScalar: (s: number) => Vector3;
					subVectors: (a: Vector3, b: Vector3) => Vector3;
					multiply: (v: Vector3) => Vector3;
					multiplyScalar: (s: number) => Vector3;
					multiplyVectors: (a: Vector3, b: Vector3) => Vector3;
					applyEuler: (euler: Euler) => Vector3;
					applyAxisAngle: (axis: Vector3, angle: number) => Vector3;
					applyMatrix3: (m: Matrix3) => Vector3;
					applyNormalMatrix: (m: Matrix3) => Vector3;
					applyMatrix4: (m: Matrix4) => Vector3;
					applyQuaternion: (q: Quaternion) => Vector3;
					project: (camera: Camera) => Vector3;
					unproject: (camera: Camera) => Vector3;
					transformDirection: (m: Matrix4) => Vector3;
					divide: (v: Vector3) => Vector3;
					divideScalar: (s: number) => Vector3;
					min: (v: Vector3) => Vector3;
					max: (v: Vector3) => Vector3;
					clamp: (min: Vector3, max: Vector3) => Vector3;
					clampScalar: (min: number, max: number) => Vector3;
					clampLength: (min: number, max: number) => Vector3;
					floor: () => Vector3;
					ceil: () => Vector3;
					round: () => Vector3;
					roundToZero: () => Vector3;
					negate: () => Vector3;
					dot: (v: Vector3) => number;
					lengthSq: () => number;
					length: () => number;
					lengthManhattan: () => number;
					manhattanLength: () => number;
					manhattanDistanceTo: (v: Vector3) => number;
					normalize: () => Vector3;
					setLength: (l: number) => Vector3;
					lerp: (v: Vector3, alpha: number) => Vector3;
					lerpVectors: (v1: Vector3, v2: Vector3, alpha: number) => Vector3;
					cross: (a: Vector3) => Vector3;
					crossVectors: (a: Vector3, b: Vector3) => Vector3;
					projectOnVector: (v: Vector3) => Vector3;
					projectOnPlane: (planeNormal: Vector3) => Vector3;
					reflect: (vector: Vector3) => Vector3;
					angleTo: (v: Vector3) => number;
					distanceTo: (v: Vector3) => number;
					distanceToSquared: (v: Vector3) => number;
					distanceToManhattan: (v: Vector3) => number;
					setFromSpherical: (s: Spherical) => Vector3;
					setFromSphericalCoords: (r: number, phi: number, theta: number) => Vector3;
					setFromCylindrical: (s: Cylindrical) => Vector3;
					setFromCylindricalCoords: (radius: number, theta: number, y: number) => Vector3;
					setFromMatrixPosition: (m: Matrix4) => Vector3;
					setFromMatrixScale: (m: Matrix4) => Vector3;
					setFromMatrixColumn: (matrix: Matrix4, index: number) => Vector3;
					setFromMatrix3Column: (matrix: Matrix3, index: number) => Vector3;
					setFromEuler: (e: Euler) => Vector3;
					equals: (v: Vector3) => boolean;
					fromArray: (array: number[] | ArrayLike<number>, offset?: number | undefined) => Vector3;
					toArray: {
						(array?: number[] | undefined, offset?: number | undefined): number[];
						(array?: Vector3Tuple | undefined, offset?: 0 | undefined): Vector3Tuple;
						(array: ArrayLike<number>, offset?: number | undefined): ArrayLike<number>;
					};
					fromBufferAttribute: (attribute: BufferAttribute | InterleavedBufferAttribute, index: number) => Vector3;
					random: () => Vector3;
					randomDirection: () => Vector3;
				};
				readonly modelViewMatrix: {
					elements: number[];
					set: (n11: number, n12: number, n13: number, n14: number, n21: number, n22: number, n23: number, n24: number, n31: number, n32: number, n33: number, n34: number, n41: number, n42: number, n43: number, n44: number) => Matrix4;
					identity: () => Matrix4;
					clone: () => Matrix4;
					copy: (m: Matrix4) => Matrix4;
					copyPosition: (m: Matrix4) => Matrix4;
					extractBasis: (xAxis: Vector3, yAxis: Vector3, zAxis: Vector3) => Matrix4;
					makeBasis: (xAxis: Vector3, yAxis: Vector3, zAxis: Vector3) => Matrix4;
					extractRotation: (m: Matrix4) => Matrix4;
					makeRotationFromEuler: (euler: Euler) => Matrix4;
					makeRotationFromQuaternion: (q: Quaternion) => Matrix4;
					lookAt: (eye: Vector3, target: Vector3, up: Vector3) => Matrix4;
					multiply: (m: Matrix4) => Matrix4;
					premultiply: (m: Matrix4) => Matrix4;
					multiplyMatrices: (a: Matrix4, b: Matrix4) => Matrix4;
					multiplyToArray: (a: Matrix4, b: Matrix4, r: number[]) => Matrix4;
					multiplyScalar: (s: number) => Matrix4;
					determinant: () => number;
					transpose: () => Matrix4;
					setPosition: (v: number | Vector3, y?: number | undefined, z?: number | undefined) => Matrix4;
					invert: () => Matrix4;
					scale: (v: Vector3) => Matrix4;
					getMaxScaleOnAxis: () => number;
					makeTranslation: (x: number, y: number, z: number) => Matrix4;
					makeRotationX: (theta: number) => Matrix4;
					makeRotationY: (theta: number) => Matrix4;
					makeRotationZ: (theta: number) => Matrix4;
					makeRotationAxis: (axis: Vector3, angle: number) => Matrix4;
					makeScale: (x: number, y: number, z: number) => Matrix4;
					makeShear: (xy: number, xz: number, yx: number, yz: number, zx: number, zy: number) => Matrix4;
					compose: (translation: Vector3, rotation: Quaternion, scale: Vector3) => Matrix4;
					decompose: (translation: Vector3, rotation: Quaternion, scale: Vector3) => Matrix4;
					makePerspective: {
						(left: number, right: number, bottom: number, top: number, near: number, far: number): Matrix4;
						(fov: number, aspect: number, near: number, far: number): Matrix4;
					};
					makeOrthographic: (left: number, right: number, top: number, bottom: number, near: number, far: number) => Matrix4;
					equals: (matrix: Matrix4) => boolean;
					fromArray: (array: number[] | ArrayLike<number>, offset?: number | undefined) => Matrix4;
					toArray: {
						(array?: number[] | undefined, offset?: number | undefined): number[];
						(array?: Matrix4Tuple | undefined, offset?: 0 | undefined): Matrix4Tuple;
						(array?: ArrayLike<number> | undefined, offset?: number | undefined): ArrayLike<number>;
					};
					setFromMatrix3: (m: Matrix3) => Matrix4;
					extractPosition: (m: Matrix4) => Matrix4;
					setRotationFromQuaternion: (q: Quaternion) => Matrix4;
					multiplyVector3: (v: any) => any;
					multiplyVector4: (v: any) => any;
					multiplyVector3Array: (array: number[]) => number[];
					rotateAxis: (v: any) => void;
					crossVector: (v: any) => void;
					flattenToArrayOffset: (array: number[], offset: number) => number[];
					getInverse: (matrix: Matrix) => Matrix;
				};
				readonly normalMatrix: {
					elements: number[];
					set: (n11: number, n12: number, n13: number, n21: number, n22: number, n23: number, n31: number, n32: number, n33: number) => Matrix3;
					identity: () => Matrix3;
					clone: () => Matrix3;
					copy: (m: Matrix3) => Matrix3;
					extractBasis: (xAxis: Vector3, yAxis: Vector3, zAxis: Vector3) => Matrix3;
					setFromMatrix4: (m: Matrix4) => Matrix3;
					multiplyScalar: (s: number) => Matrix3;
					determinant: () => number;
					invert: () => Matrix3;
					transpose: () => Matrix3;
					getNormalMatrix: (matrix4: Matrix4) => Matrix3;
					transposeIntoArray: (r: number[]) => Matrix3;
					setUvTransform: (tx: number, ty: number, sx: number, sy: number, rotation: number, cx: number, cy: number) => Matrix3;
					scale: (sx: number, sy: number) => Matrix3;
					makeTranslation: {
						(x: number, y: number): Matrix3;
						(x: number, y: number): Matrix3;
					};
					makeRotation: {
						(theta: number): Matrix3;
						(theta: number): Matrix3;
					};
					makeScale: {
						(x: number, y: number): Matrix3;
						(x: number, y: number): Matrix3;
					};
					rotate: (theta: number) => Matrix3;
					translate: (tx: number, ty: number) => Matrix3;
					equals: (matrix: Matrix3) => boolean;
					fromArray: (array: number[] | ArrayLike<number>, offset?: number | undefined) => Matrix3;
					toArray: {
						(array?: number[] | undefined, offset?: number | undefined): number[];
						(array?: Matrix3Tuple | undefined, offset?: 0 | undefined): Matrix3Tuple;
						(array?: ArrayLike<number> | undefined, offset?: number | undefined): ArrayLike<number>;
					};
					multiply: (m: Matrix3) => Matrix3;
					premultiply: (m: Matrix3) => Matrix3;
					multiplyMatrices: (a: Matrix3, b: Matrix3) => Matrix3;
					multiplyVector3: (vector: Vector3) => any;
					multiplyVector3Array: (a: any) => any;
					getInverse: {
						(matrix: Matrix4, throwOnDegenerate?: boolean | undefined): Matrix3;
						(matrix: Matrix): Matrix;
					};
					flattenToArrayOffset: (array: number[], offset: number) => number[];
				};
				matrix: {
					elements: number[];
					set: (n11: number, n12: number, n13: number, n14: number, n21: number, n22: number, n23: number, n24: number, n31: number, n32: number, n33: number, n34: number, n41: number, n42: number, n43: number, n44: number) => Matrix4;
					identity: () => Matrix4;
					clone: () => Matrix4;
					copy: (m: Matrix4) => Matrix4;
					copyPosition: (m: Matrix4) => Matrix4;
					extractBasis: (xAxis: Vector3, yAxis: Vector3, zAxis: Vector3) => Matrix4;
					makeBasis: (xAxis: Vector3, yAxis: Vector3, zAxis: Vector3) => Matrix4;
					extractRotation: (m: Matrix4) => Matrix4;
					makeRotationFromEuler: (euler: Euler) => Matrix4;
					makeRotationFromQuaternion: (q: Quaternion) => Matrix4;
					lookAt: (eye: Vector3, target: Vector3, up: Vector3) => Matrix4;
					multiply: (m: Matrix4) => Matrix4;
					premultiply: (m: Matrix4) => Matrix4;
					multiplyMatrices: (a: Matrix4, b: Matrix4) => Matrix4;
					multiplyToArray: (a: Matrix4, b: Matrix4, r: number[]) => Matrix4;
					multiplyScalar: (s: number) => Matrix4;
					determinant: () => number;
					transpose: () => Matrix4;
					setPosition: (v: number | Vector3, y?: number | undefined, z?: number | undefined) => Matrix4;
					invert: () => Matrix4;
					scale: (v: Vector3) => Matrix4;
					getMaxScaleOnAxis: () => number;
					makeTranslation: (x: number, y: number, z: number) => Matrix4;
					makeRotationX: (theta: number) => Matrix4;
					makeRotationY: (theta: number) => Matrix4;
					makeRotationZ: (theta: number) => Matrix4;
					makeRotationAxis: (axis: Vector3, angle: number) => Matrix4;
					makeScale: (x: number, y: number, z: number) => Matrix4;
					makeShear: (xy: number, xz: number, yx: number, yz: number, zx: number, zy: number) => Matrix4;
					compose: (translation: Vector3, rotation: Quaternion, scale: Vector3) => Matrix4;
					decompose: (translation: Vector3, rotation: Quaternion, scale: Vector3) => Matrix4;
					makePerspective: {
						(left: number, right: number, bottom: number, top: number, near: number, far: number): Matrix4;
						(fov: number, aspect: number, near: number, far: number): Matrix4;
					};
					makeOrthographic: (left: number, right: number, top: number, bottom: number, near: number, far: number) => Matrix4;
					equals: (matrix: Matrix4) => boolean;
					fromArray: (array: number[] | ArrayLike<number>, offset?: number | undefined) => Matrix4;
					toArray: {
						(array?: number[] | undefined, offset?: number | undefined): number[];
						(array?: Matrix4Tuple | undefined, offset?: 0 | undefined): Matrix4Tuple;
						(array?: ArrayLike<number> | undefined, offset?: number | undefined): ArrayLike<number>;
					};
					setFromMatrix3: (m: Matrix3) => Matrix4;
					extractPosition: (m: Matrix4) => Matrix4;
					setRotationFromQuaternion: (q: Quaternion) => Matrix4;
					multiplyVector3: (v: any) => any;
					multiplyVector4: (v: any) => any;
					multiplyVector3Array: (array: number[]) => number[];
					rotateAxis: (v: any) => void;
					crossVector: (v: any) => void;
					flattenToArrayOffset: (array: number[], offset: number) => number[];
					getInverse: (matrix: Matrix) => Matrix;
				};
				matrixWorld: {
					elements: number[];
					set: (n11: number, n12: number, n13: number, n14: number, n21: number, n22: number, n23: number, n24: number, n31: number, n32: number, n33: number, n34: number, n41: number, n42: number, n43: number, n44: number) => Matrix4;
					identity: () => Matrix4;
					clone: () => Matrix4;
					copy: (m: Matrix4) => Matrix4;
					copyPosition: (m: Matrix4) => Matrix4;
					extractBasis: (xAxis: Vector3, yAxis: Vector3, zAxis: Vector3) => Matrix4;
					makeBasis: (xAxis: Vector3, yAxis: Vector3, zAxis: Vector3) => Matrix4;
					extractRotation: (m: Matrix4) => Matrix4;
					makeRotationFromEuler: (euler: Euler) => Matrix4;
					makeRotationFromQuaternion: (q: Quaternion) => Matrix4;
					lookAt: (eye: Vector3, target: Vector3, up: Vector3) => Matrix4;
					multiply: (m: Matrix4) => Matrix4;
					premultiply: (m: Matrix4) => Matrix4;
					multiplyMatrices: (a: Matrix4, b: Matrix4) => Matrix4;
					multiplyToArray: (a: Matrix4, b: Matrix4, r: number[]) => Matrix4;
					multiplyScalar: (s: number) => Matrix4;
					determinant: () => number;
					transpose: () => Matrix4;
					setPosition: (v: number | Vector3, y?: number | undefined, z?: number | undefined) => Matrix4;
					invert: () => Matrix4;
					scale: (v: Vector3) => Matrix4;
					getMaxScaleOnAxis: () => number;
					makeTranslation: (x: number, y: number, z: number) => Matrix4;
					makeRotationX: (theta: number) => Matrix4;
					makeRotationY: (theta: number) => Matrix4;
					makeRotationZ: (theta: number) => Matrix4;
					makeRotationAxis: (axis: Vector3, angle: number) => Matrix4;
					makeScale: (x: number, y: number, z: number) => Matrix4;
					makeShear: (xy: number, xz: number, yx: number, yz: number, zx: number, zy: number) => Matrix4;
					compose: (translation: Vector3, rotation: Quaternion, scale: Vector3) => Matrix4;
					decompose: (translation: Vector3, rotation: Quaternion, scale: Vector3) => Matrix4;
					makePerspective: {
						(left: number, right: number, bottom: number, top: number, near: number, far: number): Matrix4;
						(fov: number, aspect: number, near: number, far: number): Matrix4;
					};
					makeOrthographic: (left: number, right: number, top: number, bottom: number, near: number, far: number) => Matrix4;
					equals: (matrix: Matrix4) => boolean;
					fromArray: (array: number[] | ArrayLike<number>, offset?: number | undefined) => Matrix4;
					toArray: {
						(array?: number[] | undefined, offset?: number | undefined): number[];
						(array?: Matrix4Tuple | undefined, offset?: 0 | undefined): Matrix4Tuple;
						(array?: ArrayLike<number> | undefined, offset?: number | undefined): ArrayLike<number>;
					};
					setFromMatrix3: (m: Matrix3) => Matrix4;
					extractPosition: (m: Matrix4) => Matrix4;
					setRotationFromQuaternion: (q: Quaternion) => Matrix4;
					multiplyVector3: (v: any) => any;
					multiplyVector4: (v: any) => any;
					multiplyVector3Array: (array: number[]) => number[];
					rotateAxis: (v: any) => void;
					crossVector: (v: any) => void;
					flattenToArrayOffset: (array: number[], offset: number) => number[];
					getInverse: (matrix: Matrix) => Matrix;
				};
				matrixAutoUpdate: boolean;
				matrixWorldAutoUpdate: boolean;
				matrixWorldNeedsUpdate: boolean;
				layers: {
					mask: number;
					set: (layer: number) => void;
					enable: (layer: number) => void;
					enableAll: () => void;
					toggle: (layer: number) => void;
					disable: (layer: number) => void;
					disableAll: () => void;
					test: (layers: Layers) => boolean;
					isEnabled: (layer: number) => boolean;
				};
				visible: boolean;
				castShadow: boolean;
				receiveShadow: boolean;
				frustumCulled: boolean;
				renderOrder: number;
				animations: {
					name: string;
					tracks: {
						name: string;
						times: {
							[x: number]: number;
							readonly BYTES_PER_ELEMENT: number;
							readonly buffer: {
								readonly byteLength: number;
								slice: (begin: number, end?: number | undefined) => ArrayBuffer;
								readonly [Symbol.toStringTag]: string;
							} | {
								readonly byteLength: number;
								slice: (begin: number, end?: number | undefined) => SharedArrayBuffer;
								readonly [Symbol.species]: SharedArrayBuffer;
								readonly [Symbol.toStringTag]: "SharedArrayBuffer";
							};
							readonly byteLength: number;
							readonly byteOffset: number;
							copyWithin: (target: number, start: number, end?: number | undefined) => Float32Array;
							every: (predicate: (value: number, index: number, array: Float32Array) => unknown, thisArg?: any) => boolean;
							fill: (value: number, start?: number | undefined, end?: number | undefined) => Float32Array;
							filter: (predicate: (value: number, index: number, array: Float32Array) => any, thisArg?: any) => Float32Array;
							find: (predicate: (value: number, index: number, obj: Float32Array) => boolean, thisArg?: any) => number | undefined;
							findIndex: (predicate: (value: number, index: number, obj: Float32Array) => boolean, thisArg?: any) => number;
							forEach: (callbackfn: (value: number, index: number, array: Float32Array) => void, thisArg?: any) => void;
							indexOf: (searchElement: number, fromIndex?: number | undefined) => number;
							join: (separator?: string | undefined) => string;
							lastIndexOf: (searchElement: number, fromIndex?: number | undefined) => number;
							readonly length: number;
							map: (callbackfn: (value: number, index: number, array: Float32Array) => number, thisArg?: any) => Float32Array;
							reduce: {
								(callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number): number;
								(callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number, initialValue: number): number;
								<U>(callbackfn: (previousValue: U, currentValue: number, currentIndex: number, array: Float32Array) => U, initialValue: U): U;
							};
							reduceRight: {
								(callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number): number;
								(callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number, initialValue: number): number;
								<U_1>(callbackfn: (previousValue: U_1, currentValue: number, currentIndex: number, array: Float32Array) => U_1, initialValue: U_1): U_1;
							};
							reverse: () => Float32Array;
							set: (array: ArrayLike<number>, offset?: number | undefined) => void;
							slice: (start?: number | undefined, end?: number | undefined) => Float32Array;
							some: (predicate: (value: number, index: number, array: Float32Array) => unknown, thisArg?: any) => boolean;
							sort: (compareFn?: ((a: number, b: number) => number) | undefined) => Float32Array;
							subarray: (begin?: number | undefined, end?: number | undefined) => Float32Array;
							toLocaleString: () => string;
							toString: () => string;
							valueOf: () => Float32Array;
							entries: () => IterableIterator<[
								number,
								number
							]>;
							keys: () => IterableIterator<number>;
							values: () => IterableIterator<number>;
							includes: (searchElement: number, fromIndex?: number | undefined) => boolean;
							[Symbol.iterator]: () => IterableIterator<number>;
							readonly [Symbol.toStringTag]: "Float32Array";
							at: (index: number) => number | undefined;
						};
						values: {
							[x: number]: number;
							readonly BYTES_PER_ELEMENT: number;
							readonly buffer: {
								readonly byteLength: number;
								slice: (begin: number, end?: number | undefined) => ArrayBuffer;
								readonly [Symbol.toStringTag]: string;
							} | {
								readonly byteLength: number;
								slice: (begin: number, end?: number | undefined) => SharedArrayBuffer;
								readonly [Symbol.species]: SharedArrayBuffer;
								readonly [Symbol.toStringTag]: "SharedArrayBuffer";
							};
							readonly byteLength: number;
							readonly byteOffset: number;
							copyWithin: (target: number, start: number, end?: number | undefined) => Float32Array;
							every: (predicate: (value: number, index: number, array: Float32Array) => unknown, thisArg?: any) => boolean;
							fill: (value: number, start?: number | undefined, end?: number | undefined) => Float32Array;
							filter: (predicate: (value: number, index: number, array: Float32Array) => any, thisArg?: any) => Float32Array;
							find: (predicate: (value: number, index: number, obj: Float32Array) => boolean, thisArg?: any) => number | undefined;
							findIndex: (predicate: (value: number, index: number, obj: Float32Array) => boolean, thisArg?: any) => number;
							forEach: (callbackfn: (value: number, index: number, array: Float32Array) => void, thisArg?: any) => void;
							indexOf: (searchElement: number, fromIndex?: number | undefined) => number;
							join: (separator?: string | undefined) => string;
							lastIndexOf: (searchElement: number, fromIndex?: number | undefined) => number;
							readonly length: number;
							map: (callbackfn: (value: number, index: number, array: Float32Array) => number, thisArg?: any) => Float32Array;
							reduce: {
								(callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number): number;
								(callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number, initialValue: number): number;
								<U>(callbackfn: (previousValue: U, currentValue: number, currentIndex: number, array: Float32Array) => U, initialValue: U): U;
							};
							reduceRight: {
								(callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number): number;
								(callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number, initialValue: number): number;
								<U_1>(callbackfn: (previousValue: U_1, currentValue: number, currentIndex: number, array: Float32Array) => U_1, initialValue: U_1): U_1;
							};
							reverse: () => Float32Array;
							set: (array: ArrayLike<number>, offset?: number | undefined) => void;
							slice: (start?: number | undefined, end?: number | undefined) => Float32Array;
							some: (predicate: (value: number, index: number, array: Float32Array) => unknown, thisArg?: any) => boolean;
							sort: (compareFn?: ((a: number, b: number) => number) | undefined) => Float32Array;
							subarray: (begin?: number | undefined, end?: number | undefined) => Float32Array;
							toLocaleString: () => string;
							toString: () => string;
							valueOf: () => Float32Array;
							entries: () => IterableIterator<[
								number,
								number
							]>;
							keys: () => IterableIterator<number>;
							values: () => IterableIterator<number>;
							includes: (searchElement: number, fromIndex?: number | undefined) => boolean;
							[Symbol.iterator]: () => IterableIterator<number>;
							readonly [Symbol.toStringTag]: "Float32Array";
							at: (index: number) => number | undefined;
						};
						ValueTypeName: string;
						TimeBufferType: {
							[x: number]: number;
							readonly BYTES_PER_ELEMENT: number;
							readonly buffer: {
								readonly byteLength: number;
								slice: (begin: number, end?: number | undefined) => ArrayBuffer;
								readonly [Symbol.toStringTag]: string;
							} | {
								readonly byteLength: number;
								slice: (begin: number, end?: number | undefined) => SharedArrayBuffer;
								readonly [Symbol.species]: SharedArrayBuffer;
								readonly [Symbol.toStringTag]: "SharedArrayBuffer";
							};
							readonly byteLength: number;
							readonly byteOffset: number;
							copyWithin: (target: number, start: number, end?: number | undefined) => Float32Array;
							every: (predicate: (value: number, index: number, array: Float32Array) => unknown, thisArg?: any) => boolean;
							fill: (value: number, start?: number | undefined, end?: number | undefined) => Float32Array;
							filter: (predicate: (value: number, index: number, array: Float32Array) => any, thisArg?: any) => Float32Array;
							find: (predicate: (value: number, index: number, obj: Float32Array) => boolean, thisArg?: any) => number | undefined;
							findIndex: (predicate: (value: number, index: number, obj: Float32Array) => boolean, thisArg?: any) => number;
							forEach: (callbackfn: (value: number, index: number, array: Float32Array) => void, thisArg?: any) => void;
							indexOf: (searchElement: number, fromIndex?: number | undefined) => number;
							join: (separator?: string | undefined) => string;
							lastIndexOf: (searchElement: number, fromIndex?: number | undefined) => number;
							readonly length: number;
							map: (callbackfn: (value: number, index: number, array: Float32Array) => number, thisArg?: any) => Float32Array;
							reduce: {
								(callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number): number;
								(callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number, initialValue: number): number;
								<U>(callbackfn: (previousValue: U, currentValue: number, currentIndex: number, array: Float32Array) => U, initialValue: U): U;
							};
							reduceRight: {
								(callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number): number;
								(callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number, initialValue: number): number;
								<U_1>(callbackfn: (previousValue: U_1, currentValue: number, currentIndex: number, array: Float32Array) => U_1, initialValue: U_1): U_1;
							};
							reverse: () => Float32Array;
							set: (array: ArrayLike<number>, offset?: number | undefined) => void;
							slice: (start?: number | undefined, end?: number | undefined) => Float32Array;
							some: (predicate: (value: number, index: number, array: Float32Array) => unknown, thisArg?: any) => boolean;
							sort: (compareFn?: ((a: number, b: number) => number) | undefined) => Float32Array;
							subarray: (begin?: number | undefined, end?: number | undefined) => Float32Array;
							toLocaleString: () => string;
							toString: () => string;
							valueOf: () => Float32Array;
							entries: () => IterableIterator<[
								number,
								number
							]>;
							keys: () => IterableIterator<number>;
							values: () => IterableIterator<number>;
							includes: (searchElement: number, fromIndex?: number | undefined) => boolean;
							[Symbol.iterator]: () => IterableIterator<number>;
							readonly [Symbol.toStringTag]: "Float32Array";
							at: (index: number) => number | undefined;
						};
						ValueBufferType: {
							[x: number]: number;
							readonly BYTES_PER_ELEMENT: number;
							readonly buffer: {
								readonly byteLength: number;
								slice: (begin: number, end?: number | undefined) => ArrayBuffer;
								readonly [Symbol.toStringTag]: string;
							} | {
								readonly byteLength: number;
								slice: (begin: number, end?: number | undefined) => SharedArrayBuffer;
								readonly [Symbol.species]: SharedArrayBuffer;
								readonly [Symbol.toStringTag]: "SharedArrayBuffer";
							};
							readonly byteLength: number;
							readonly byteOffset: number;
							copyWithin: (target: number, start: number, end?: number | undefined) => Float32Array;
							every: (predicate: (value: number, index: number, array: Float32Array) => unknown, thisArg?: any) => boolean;
							fill: (value: number, start?: number | undefined, end?: number | undefined) => Float32Array;
							filter: (predicate: (value: number, index: number, array: Float32Array) => any, thisArg?: any) => Float32Array;
							find: (predicate: (value: number, index: number, obj: Float32Array) => boolean, thisArg?: any) => number | undefined;
							findIndex: (predicate: (value: number, index: number, obj: Float32Array) => boolean, thisArg?: any) => number;
							forEach: (callbackfn: (value: number, index: number, array: Float32Array) => void, thisArg?: any) => void;
							indexOf: (searchElement: number, fromIndex?: number | undefined) => number;
							join: (separator?: string | undefined) => string;
							lastIndexOf: (searchElement: number, fromIndex?: number | undefined) => number;
							readonly length: number;
							map: (callbackfn: (value: number, index: number, array: Float32Array) => number, thisArg?: any) => Float32Array;
							reduce: {
								(callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number): number;
								(callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number, initialValue: number): number;
								<U>(callbackfn: (previousValue: U, currentValue: number, currentIndex: number, array: Float32Array) => U, initialValue: U): U;
							};
							reduceRight: {
								(callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number): number;
								(callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number, initialValue: number): number;
								<U_1>(callbackfn: (previousValue: U_1, currentValue: number, currentIndex: number, array: Float32Array) => U_1, initialValue: U_1): U_1;
							};
							reverse: () => Float32Array;
							set: (array: ArrayLike<number>, offset?: number | undefined) => void;
							slice: (start?: number | undefined, end?: number | undefined) => Float32Array;
							some: (predicate: (value: number, index: number, array: Float32Array) => unknown, thisArg?: any) => boolean;
							sort: (compareFn?: ((a: number, b: number) => number) | undefined) => Float32Array;
							subarray: (begin?: number | undefined, end?: number | undefined) => Float32Array;
							toLocaleString: () => string;
							toString: () => string;
							valueOf: () => Float32Array;
							entries: () => IterableIterator<[
								number,
								number
							]>;
							keys: () => IterableIterator<number>;
							values: () => IterableIterator<number>;
							includes: (searchElement: number, fromIndex?: number | undefined) => boolean;
							[Symbol.iterator]: () => IterableIterator<number>;
							readonly [Symbol.toStringTag]: "Float32Array";
							at: (index: number) => number | undefined;
						};
						DefaultInterpolation: InterpolationModes;
						InterpolantFactoryMethodDiscrete: (result: any) => DiscreteInterpolant;
						InterpolantFactoryMethodLinear: (result: any) => LinearInterpolant;
						InterpolantFactoryMethodSmooth: (result: any) => CubicInterpolant;
						setInterpolation: (interpolation: InterpolationModes) => KeyframeTrack;
						getInterpolation: () => InterpolationModes;
						createInterpolant: () => Interpolant;
						getValueSize: () => number;
						shift: (timeOffset: number) => KeyframeTrack;
						scale: (timeScale: number) => KeyframeTrack;
						trim: (startTime: number, endTime: number) => KeyframeTrack;
						validate: () => boolean;
						optimize: () => KeyframeTrack;
						clone: () => KeyframeTrack;
					}[];
					blendMode: AnimationBlendMode;
					duration: number;
					uuid: string;
					results: any[];
					resetDuration: () => AnimationClip;
					trim: () => AnimationClip;
					validate: () => boolean;
					optimize: () => AnimationClip;
					clone: () => AnimationClip;
					toJSON: (clip: AnimationClip) => any;
				}[];
				userData: {
					[key: string]: any;
				};
				customDepthMaterial?: {
					alphaTest: number;
					alphaToCoverage: boolean;
					blendDst: BlendingDstFactor;
					blendDstAlpha: number | null;
					blendEquation: BlendingEquation;
					blendEquationAlpha: number | null;
					blending: Blending;
					blendSrc: 210 | BlendingDstFactor;
					blendSrcAlpha: number | null;
					clipIntersection: boolean;
					clippingPlanes: any;
					clipShadows: boolean;
					colorWrite: boolean;
					defines: {
						[key: string]: any;
					} | undefined;
					depthFunc: DepthModes;
					depthTest: boolean;
					depthWrite: boolean;
					id: number;
					stencilWrite: boolean;
					stencilFunc: StencilFunc;
					stencilRef: number;
					stencilWriteMask: number;
					stencilFuncMask: number;
					stencilFail: StencilOp;
					stencilZFail: StencilOp;
					stencilZPass: StencilOp;
					readonly isMaterial: true;
					name: string;
					needsUpdate: boolean;
					opacity: number;
					polygonOffset: boolean;
					polygonOffsetFactor: number;
					polygonOffsetUnits: number;
					precision: "highp" | "mediump" | "lowp" | null;
					premultipliedAlpha: boolean;
					forceSinglePass: boolean;
					dithering: boolean;
					side: Side;
					shadowSide: Side | null;
					toneMapped: boolean;
					transparent: boolean;
					type: string;
					uuid: string;
					vertexColors: boolean;
					visible: boolean;
					userData: any;
					version: number;
					clone: () => Material;
					copy: (material: Material) => Material;
					dispose: () => void;
					onBeforeCompile: (shader: Shader, renderer: WebGLRenderer) => void;
					customProgramCacheKey: () => string;
					setValues: (values: MaterialParameters) => void;
					toJSON: (meta?: any) => any;
					addEventListener: <T extends string>(type: T, listener: EventListener<Event, T, Material>) => void;
					hasEventListener: <T_1 extends string>(type: T_1, listener: EventListener<Event, T_1, Material>) => boolean;
					removeEventListener: <T_2 extends string>(type: T_2, listener: EventListener<Event, T_2, Material>) => void;
					dispatchEvent: (event: Event) => void;
				} | undefined;
				customDistanceMaterial?: {
					alphaTest: number;
					alphaToCoverage: boolean;
					blendDst: BlendingDstFactor;
					blendDstAlpha: number | null;
					blendEquation: BlendingEquation;
					blendEquationAlpha: number | null;
					blending: Blending;
					blendSrc: 210 | BlendingDstFactor;
					blendSrcAlpha: number | null;
					clipIntersection: boolean;
					clippingPlanes: any;
					clipShadows: boolean;
					colorWrite: boolean;
					defines: {
						[key: string]: any;
					} | undefined;
					depthFunc: DepthModes;
					depthTest: boolean;
					depthWrite: boolean;
					id: number;
					stencilWrite: boolean;
					stencilFunc: StencilFunc;
					stencilRef: number;
					stencilWriteMask: number;
					stencilFuncMask: number;
					stencilFail: StencilOp;
					stencilZFail: StencilOp;
					stencilZPass: StencilOp;
					readonly isMaterial: true;
					name: string;
					needsUpdate: boolean;
					opacity: number;
					polygonOffset: boolean;
					polygonOffsetFactor: number;
					polygonOffsetUnits: number;
					precision: "highp" | "mediump" | "lowp" | null;
					premultipliedAlpha: boolean;
					forceSinglePass: boolean;
					dithering: boolean;
					side: Side;
					shadowSide: Side | null;
					toneMapped: boolean;
					transparent: boolean;
					type: string;
					uuid: string;
					vertexColors: boolean;
					visible: boolean;
					userData: any;
					version: number;
					clone: () => Material;
					copy: (material: Material) => Material;
					dispose: () => void;
					onBeforeCompile: (shader: Shader, renderer: WebGLRenderer) => void;
					customProgramCacheKey: () => string;
					setValues: (values: MaterialParameters) => void;
					toJSON: (meta?: any) => any;
					addEventListener: <T extends string>(type: T, listener: EventListener<Event, T, Material>) => void;
					hasEventListener: <T_1 extends string>(type: T_1, listener: EventListener<Event, T_1, Material>) => boolean;
					removeEventListener: <T_2 extends string>(type: T_2, listener: EventListener<Event, T_2, Material>) => void;
					dispatchEvent: (event: Event) => void;
				} | undefined;
				onBeforeRender: (renderer: WebGLRenderer, scene: Scene, camera: Camera, geometry: BufferGeometry<NormalBufferAttributes>, material: Material, group: Group) => void;
				onAfterRender: (renderer: WebGLRenderer, scene: Scene, camera: Camera, geometry: BufferGeometry<NormalBufferAttributes>, material: Material, group: Group) => void;
				applyMatrix4: (matrix: Matrix4) => void;
				applyQuaternion: (quaternion: Quaternion) => Object3D<Event>;
				setRotationFromAxisAngle: (axis: Vector3, angle: number) => void;
				setRotationFromEuler: (euler: Euler) => void;
				setRotationFromMatrix: (m: Matrix4) => void;
				setRotationFromQuaternion: (q: Quaternion) => void;
				rotateOnAxis: (axis: Vector3, angle: number) => Object3D<Event>;
				rotateOnWorldAxis: (axis: Vector3, angle: number) => Object3D<Event>;
				rotateX: (angle: number) => Object3D<Event>;
				rotateY: (angle: number) => Object3D<Event>;
				rotateZ: (angle: number) => Object3D<Event>;
				translateOnAxis: (axis: Vector3, distance: number) => Object3D<Event>;
				translateX: (distance: number) => Object3D<Event>;
				translateY: (distance: number) => Object3D<Event>;
				translateZ: (distance: number) => Object3D<Event>;
				localToWorld: (vector: Vector3) => Vector3;
				worldToLocal: (vector: Vector3) => Vector3;
				lookAt: {
					(vector: Vector3): void;
					(x: number, y: number, z: number): void;
				};
				add: (...object: Object3D<Event>[]) => Object3D<Event>;
				remove: (...object: Object3D<Event>[]) => Object3D<Event>;
				removeFromParent: () => Object3D<Event>;
				clear: () => Object3D<Event>;
				attach: (object: Object3D<Event>) => Object3D<Event>;
				getObjectById: (id: number) => Object3D<Event> | undefined;
				getObjectByName: (name: string) => Object3D<Event> | undefined;
				getObjectByProperty: (name: string, value: any) => Object3D<Event> | undefined;
				getObjectsByProperty: (name: string, value: any) => Object3D<Event>[];
				getWorldPosition: (target: Vector3) => Vector3;
				getWorldQuaternion: (target: Quaternion) => Quaternion;
				getWorldScale: (target: Vector3) => Vector3;
				getWorldDirection: (target: Vector3) => Vector3;
				raycast: (raycaster: Raycaster, intersects: Intersection<Object3D<Event>>[]) => void;
				traverse: (callback: (object: Object3D<Event>) => any) => void;
				traverseVisible: (callback: (object: Object3D<Event>) => any) => void;
				traverseAncestors: (callback: (object: Object3D<Event>) => any) => void;
				updateMatrix: () => void;
				updateMatrixWorld: (force?: boolean | undefined) => void;
				updateWorldMatrix: (updateParents: boolean, updateChildren: boolean) => void;
				toJSON: (meta?: {
					geometries: any;
					materials: any;
					textures: any;
					images: any;
				} | undefined) => any;
				clone: (recursive?: boolean | undefined) => Object3D<Event>;
				copy: (source: Object3D<Event>, recursive?: boolean | undefined) => Object3D<Event>;
				addEventListener: <T_3 extends string>(type: T_3, listener: EventListener<Event, T_3, Object3D<Event>>) => void;
				hasEventListener: <T_4 extends string>(type: T_4, listener: EventListener<Event, T_4, Object3D<Event>>) => boolean;
				removeEventListener: <T_5 extends string>(type: T_5, listener: EventListener<Event, T_5, Object3D<Event>>) => void;
				dispatchEvent: (event: Event) => void;
			} | null;
			children: {
				readonly isObject3D: true;
				readonly id: number;
				uuid: string;
				name: string;
				readonly type: string;
				parent: any | null;
				children: any[];
				up: {
					x: number;
					y: number;
					z: number;
					readonly isVector3: true;
					set: (x: number, y: number, z: number) => Vector3;
					setScalar: (scalar: number) => Vector3;
					setX: (x: number) => Vector3;
					setY: (y: number) => Vector3;
					setZ: (z: number) => Vector3;
					setComponent: (index: number, value: number) => Vector3;
					setFromColor: (color: Color) => Vector3;
					getComponent: (index: number) => number;
					clone: () => Vector3;
					copy: (v: Vector3) => Vector3;
					add: (v: Vector3) => Vector3;
					addScalar: (s: number) => Vector3;
					addScaledVector: (v: Vector3, s: number) => Vector3;
					addVectors: (a: Vector3, b: Vector3) => Vector3;
					sub: (a: Vector3) => Vector3;
					subScalar: (s: number) => Vector3;
					subVectors: (a: Vector3, b: Vector3) => Vector3;
					multiply: (v: Vector3) => Vector3;
					multiplyScalar: (s: number) => Vector3;
					multiplyVectors: (a: Vector3, b: Vector3) => Vector3;
					applyEuler: (euler: Euler) => Vector3;
					applyAxisAngle: (axis: Vector3, angle: number) => Vector3;
					applyMatrix3: (m: Matrix3) => Vector3;
					applyNormalMatrix: (m: Matrix3) => Vector3;
					applyMatrix4: (m: Matrix4) => Vector3;
					applyQuaternion: (q: Quaternion) => Vector3;
					project: (camera: Camera) => Vector3;
					unproject: (camera: Camera) => Vector3;
					transformDirection: (m: Matrix4) => Vector3;
					divide: (v: Vector3) => Vector3;
					divideScalar: (s: number) => Vector3;
					min: (v: Vector3) => Vector3;
					max: (v: Vector3) => Vector3;
					clamp: (min: Vector3, max: Vector3) => Vector3;
					clampScalar: (min: number, max: number) => Vector3;
					clampLength: (min: number, max: number) => Vector3;
					floor: () => Vector3;
					ceil: () => Vector3;
					round: () => Vector3;
					roundToZero: () => Vector3;
					negate: () => Vector3;
					dot: (v: Vector3) => number;
					lengthSq: () => number;
					length: () => number;
					lengthManhattan: () => number;
					manhattanLength: () => number;
					manhattanDistanceTo: (v: Vector3) => number;
					normalize: () => Vector3;
					setLength: (l: number) => Vector3;
					lerp: (v: Vector3, alpha: number) => Vector3;
					lerpVectors: (v1: Vector3, v2: Vector3, alpha: number) => Vector3;
					cross: (a: Vector3) => Vector3;
					crossVectors: (a: Vector3, b: Vector3) => Vector3;
					projectOnVector: (v: Vector3) => Vector3;
					projectOnPlane: (planeNormal: Vector3) => Vector3;
					reflect: (vector: Vector3) => Vector3;
					angleTo: (v: Vector3) => number;
					distanceTo: (v: Vector3) => number;
					distanceToSquared: (v: Vector3) => number;
					distanceToManhattan: (v: Vector3) => number;
					setFromSpherical: (s: Spherical) => Vector3;
					setFromSphericalCoords: (r: number, phi: number, theta: number) => Vector3;
					setFromCylindrical: (s: Cylindrical) => Vector3;
					setFromCylindricalCoords: (radius: number, theta: number, y: number) => Vector3;
					setFromMatrixPosition: (m: Matrix4) => Vector3;
					setFromMatrixScale: (m: Matrix4) => Vector3;
					setFromMatrixColumn: (matrix: Matrix4, index: number) => Vector3;
					setFromMatrix3Column: (matrix: Matrix3, index: number) => Vector3;
					setFromEuler: (e: Euler) => Vector3;
					equals: (v: Vector3) => boolean;
					fromArray: (array: number[] | ArrayLike<number>, offset?: number | undefined) => Vector3;
					toArray: {
						(array?: number[] | undefined, offset?: number | undefined): number[];
						(array?: Vector3Tuple | undefined, offset?: 0 | undefined): Vector3Tuple;
						(array: ArrayLike<number>, offset?: number | undefined): ArrayLike<number>;
					};
					fromBufferAttribute: (attribute: BufferAttribute | InterleavedBufferAttribute, index: number) => Vector3;
					random: () => Vector3;
					randomDirection: () => Vector3;
				};
				readonly position: {
					x: number;
					y: number;
					z: number;
					readonly isVector3: true;
					set: (x: number, y: number, z: number) => Vector3;
					setScalar: (scalar: number) => Vector3;
					setX: (x: number) => Vector3;
					setY: (y: number) => Vector3;
					setZ: (z: number) => Vector3;
					setComponent: (index: number, value: number) => Vector3;
					setFromColor: (color: Color) => Vector3;
					getComponent: (index: number) => number;
					clone: () => Vector3;
					copy: (v: Vector3) => Vector3;
					add: (v: Vector3) => Vector3;
					addScalar: (s: number) => Vector3;
					addScaledVector: (v: Vector3, s: number) => Vector3;
					addVectors: (a: Vector3, b: Vector3) => Vector3;
					sub: (a: Vector3) => Vector3;
					subScalar: (s: number) => Vector3;
					subVectors: (a: Vector3, b: Vector3) => Vector3;
					multiply: (v: Vector3) => Vector3;
					multiplyScalar: (s: number) => Vector3;
					multiplyVectors: (a: Vector3, b: Vector3) => Vector3;
					applyEuler: (euler: Euler) => Vector3;
					applyAxisAngle: (axis: Vector3, angle: number) => Vector3;
					applyMatrix3: (m: Matrix3) => Vector3;
					applyNormalMatrix: (m: Matrix3) => Vector3;
					applyMatrix4: (m: Matrix4) => Vector3;
					applyQuaternion: (q: Quaternion) => Vector3;
					project: (camera: Camera) => Vector3;
					unproject: (camera: Camera) => Vector3;
					transformDirection: (m: Matrix4) => Vector3;
					divide: (v: Vector3) => Vector3;
					divideScalar: (s: number) => Vector3;
					min: (v: Vector3) => Vector3;
					max: (v: Vector3) => Vector3;
					clamp: (min: Vector3, max: Vector3) => Vector3;
					clampScalar: (min: number, max: number) => Vector3;
					clampLength: (min: number, max: number) => Vector3;
					floor: () => Vector3;
					ceil: () => Vector3;
					round: () => Vector3;
					roundToZero: () => Vector3;
					negate: () => Vector3;
					dot: (v: Vector3) => number;
					lengthSq: () => number;
					length: () => number;
					lengthManhattan: () => number;
					manhattanLength: () => number;
					manhattanDistanceTo: (v: Vector3) => number;
					normalize: () => Vector3;
					setLength: (l: number) => Vector3;
					lerp: (v: Vector3, alpha: number) => Vector3;
					lerpVectors: (v1: Vector3, v2: Vector3, alpha: number) => Vector3;
					cross: (a: Vector3) => Vector3;
					crossVectors: (a: Vector3, b: Vector3) => Vector3;
					projectOnVector: (v: Vector3) => Vector3;
					projectOnPlane: (planeNormal: Vector3) => Vector3;
					reflect: (vector: Vector3) => Vector3;
					angleTo: (v: Vector3) => number;
					distanceTo: (v: Vector3) => number;
					distanceToSquared: (v: Vector3) => number;
					distanceToManhattan: (v: Vector3) => number;
					setFromSpherical: (s: Spherical) => Vector3;
					setFromSphericalCoords: (r: number, phi: number, theta: number) => Vector3;
					setFromCylindrical: (s: Cylindrical) => Vector3;
					setFromCylindricalCoords: (radius: number, theta: number, y: number) => Vector3;
					setFromMatrixPosition: (m: Matrix4) => Vector3;
					setFromMatrixScale: (m: Matrix4) => Vector3;
					setFromMatrixColumn: (matrix: Matrix4, index: number) => Vector3;
					setFromMatrix3Column: (matrix: Matrix3, index: number) => Vector3;
					setFromEuler: (e: Euler) => Vector3;
					equals: (v: Vector3) => boolean;
					fromArray: (array: number[] | ArrayLike<number>, offset?: number | undefined) => Vector3;
					toArray: {
						(array?: number[] | undefined, offset?: number | undefined): number[];
						(array?: Vector3Tuple | undefined, offset?: 0 | undefined): Vector3Tuple;
						(array: ArrayLike<number>, offset?: number | undefined): ArrayLike<number>;
					};
					fromBufferAttribute: (attribute: BufferAttribute | InterleavedBufferAttribute, index: number) => Vector3;
					random: () => Vector3;
					randomDirection: () => Vector3;
				};
				readonly rotation: {
					x: number;
					y: number;
					z: number;
					order: EulerOrder;
					readonly isEuler: true;
					_onChangeCallback: () => void;
					set: (x: number, y: number, z: number, order?: EulerOrder | undefined) => Euler;
					clone: () => Euler;
					copy: (euler: Euler) => Euler;
					setFromRotationMatrix: (m: Matrix4, order?: EulerOrder | undefined, update?: boolean | undefined) => Euler;
					setFromQuaternion: (q: Quaternion, order?: EulerOrder | undefined, update?: boolean | undefined) => Euler;
					setFromVector3: (v: Vector3, order?: EulerOrder | undefined) => Euler;
					reorder: (newOrder: EulerOrder) => Euler;
					equals: (euler: Euler) => boolean;
					fromArray: (xyzo: [
						number,
						number,
						number,
						(EulerOrder | undefined)?,
						...any[]
					]) => Euler;
					toArray: (array?: (string | number | undefined)[] | undefined, offset?: number | undefined) => (string | number | undefined)[];
					_onChange: (callback: () => void) => Euler;
					[Symbol.iterator]: () => Generator<string | number, void, unknown>;
				};
				readonly quaternion: {
					x: number;
					y: number;
					z: number;
					w: number;
					readonly isQuaternion: true;
					set: (x: number, y: number, z: number, w: number) => Quaternion;
					clone: () => Quaternion;
					copy: (q: Quaternion) => Quaternion;
					setFromEuler: (euler: Euler, update?: boolean | undefined) => Quaternion;
					setFromAxisAngle: (axis: Vector3, angle: number) => Quaternion;
					setFromRotationMatrix: (m: Matrix4) => Quaternion;
					setFromUnitVectors: (vFrom: Vector3, vTo: Vector3) => Quaternion;
					angleTo: (q: Quaternion) => number;
					rotateTowards: (q: Quaternion, step: number) => Quaternion;
					identity: () => Quaternion;
					invert: () => Quaternion;
					conjugate: () => Quaternion;
					dot: (v: Quaternion) => number;
					lengthSq: () => number;
					length: () => number;
					normalize: () => Quaternion;
					multiply: (q: Quaternion) => Quaternion;
					premultiply: (q: Quaternion) => Quaternion;
					multiplyQuaternions: (a: Quaternion, b: Quaternion) => Quaternion;
					slerp: (qb: Quaternion, t: number) => Quaternion;
					slerpQuaternions: (qa: Quaternion, qb: Quaternion, t: number) => Quaternion;
					equals: (v: Quaternion) => boolean;
					fromArray: (array: number[] | ArrayLike<number>, offset?: number | undefined) => Quaternion;
					toArray: {
						(array?: number[] | undefined, offset?: number | undefined): number[];
						(array: ArrayLike<number>, offset?: number | undefined): ArrayLike<number>;
					};
					toJSON: () => [
						number,
						number,
						number,
						number
					];
					fromBufferAttribute: (attribute: BufferAttribute | InterleavedBufferAttribute, index: number) => Quaternion;
					_onChange: (callback: () => void) => Quaternion;
					_onChangeCallback: () => void;
					multiplyVector3: (v: any) => any;
					random: () => Quaternion;
					[Symbol.iterator]: () => Generator<number, void, unknown>;
				};
				readonly scale: {
					x: number;
					y: number;
					z: number;
					readonly isVector3: true;
					set: (x: number, y: number, z: number) => Vector3;
					setScalar: (scalar: number) => Vector3;
					setX: (x: number) => Vector3;
					setY: (y: number) => Vector3;
					setZ: (z: number) => Vector3;
					setComponent: (index: number, value: number) => Vector3;
					setFromColor: (color: Color) => Vector3;
					getComponent: (index: number) => number;
					clone: () => Vector3;
					copy: (v: Vector3) => Vector3;
					add: (v: Vector3) => Vector3;
					addScalar: (s: number) => Vector3;
					addScaledVector: (v: Vector3, s: number) => Vector3;
					addVectors: (a: Vector3, b: Vector3) => Vector3;
					sub: (a: Vector3) => Vector3;
					subScalar: (s: number) => Vector3;
					subVectors: (a: Vector3, b: Vector3) => Vector3;
					multiply: (v: Vector3) => Vector3;
					multiplyScalar: (s: number) => Vector3;
					multiplyVectors: (a: Vector3, b: Vector3) => Vector3;
					applyEuler: (euler: Euler) => Vector3;
					applyAxisAngle: (axis: Vector3, angle: number) => Vector3;
					applyMatrix3: (m: Matrix3) => Vector3;
					applyNormalMatrix: (m: Matrix3) => Vector3;
					applyMatrix4: (m: Matrix4) => Vector3;
					applyQuaternion: (q: Quaternion) => Vector3;
					project: (camera: Camera) => Vector3;
					unproject: (camera: Camera) => Vector3;
					transformDirection: (m: Matrix4) => Vector3;
					divide: (v: Vector3) => Vector3;
					divideScalar: (s: number) => Vector3;
					min: (v: Vector3) => Vector3;
					max: (v: Vector3) => Vector3;
					clamp: (min: Vector3, max: Vector3) => Vector3;
					clampScalar: (min: number, max: number) => Vector3;
					clampLength: (min: number, max: number) => Vector3;
					floor: () => Vector3;
					ceil: () => Vector3;
					round: () => Vector3;
					roundToZero: () => Vector3;
					negate: () => Vector3;
					dot: (v: Vector3) => number;
					lengthSq: () => number;
					length: () => number;
					lengthManhattan: () => number;
					manhattanLength: () => number;
					manhattanDistanceTo: (v: Vector3) => number;
					normalize: () => Vector3;
					setLength: (l: number) => Vector3;
					lerp: (v: Vector3, alpha: number) => Vector3;
					lerpVectors: (v1: Vector3, v2: Vector3, alpha: number) => Vector3;
					cross: (a: Vector3) => Vector3;
					crossVectors: (a: Vector3, b: Vector3) => Vector3;
					projectOnVector: (v: Vector3) => Vector3;
					projectOnPlane: (planeNormal: Vector3) => Vector3;
					reflect: (vector: Vector3) => Vector3;
					angleTo: (v: Vector3) => number;
					distanceTo: (v: Vector3) => number;
					distanceToSquared: (v: Vector3) => number;
					distanceToManhattan: (v: Vector3) => number;
					setFromSpherical: (s: Spherical) => Vector3;
					setFromSphericalCoords: (r: number, phi: number, theta: number) => Vector3;
					setFromCylindrical: (s: Cylindrical) => Vector3;
					setFromCylindricalCoords: (radius: number, theta: number, y: number) => Vector3;
					setFromMatrixPosition: (m: Matrix4) => Vector3;
					setFromMatrixScale: (m: Matrix4) => Vector3;
					setFromMatrixColumn: (matrix: Matrix4, index: number) => Vector3;
					setFromMatrix3Column: (matrix: Matrix3, index: number) => Vector3;
					setFromEuler: (e: Euler) => Vector3;
					equals: (v: Vector3) => boolean;
					fromArray: (array: number[] | ArrayLike<number>, offset?: number | undefined) => Vector3;
					toArray: {
						(array?: number[] | undefined, offset?: number | undefined): number[];
						(array?: Vector3Tuple | undefined, offset?: 0 | undefined): Vector3Tuple;
						(array: ArrayLike<number>, offset?: number | undefined): ArrayLike<number>;
					};
					fromBufferAttribute: (attribute: BufferAttribute | InterleavedBufferAttribute, index: number) => Vector3;
					random: () => Vector3;
					randomDirection: () => Vector3;
				};
				readonly modelViewMatrix: {
					elements: number[];
					set: (n11: number, n12: number, n13: number, n14: number, n21: number, n22: number, n23: number, n24: number, n31: number, n32: number, n33: number, n34: number, n41: number, n42: number, n43: number, n44: number) => Matrix4;
					identity: () => Matrix4;
					clone: () => Matrix4;
					copy: (m: Matrix4) => Matrix4;
					copyPosition: (m: Matrix4) => Matrix4;
					extractBasis: (xAxis: Vector3, yAxis: Vector3, zAxis: Vector3) => Matrix4;
					makeBasis: (xAxis: Vector3, yAxis: Vector3, zAxis: Vector3) => Matrix4;
					extractRotation: (m: Matrix4) => Matrix4;
					makeRotationFromEuler: (euler: Euler) => Matrix4;
					makeRotationFromQuaternion: (q: Quaternion) => Matrix4;
					lookAt: (eye: Vector3, target: Vector3, up: Vector3) => Matrix4;
					multiply: (m: Matrix4) => Matrix4;
					premultiply: (m: Matrix4) => Matrix4;
					multiplyMatrices: (a: Matrix4, b: Matrix4) => Matrix4;
					multiplyToArray: (a: Matrix4, b: Matrix4, r: number[]) => Matrix4;
					multiplyScalar: (s: number) => Matrix4;
					determinant: () => number;
					transpose: () => Matrix4;
					setPosition: (v: number | Vector3, y?: number | undefined, z?: number | undefined) => Matrix4;
					invert: () => Matrix4;
					scale: (v: Vector3) => Matrix4;
					getMaxScaleOnAxis: () => number;
					makeTranslation: (x: number, y: number, z: number) => Matrix4;
					makeRotationX: (theta: number) => Matrix4;
					makeRotationY: (theta: number) => Matrix4;
					makeRotationZ: (theta: number) => Matrix4;
					makeRotationAxis: (axis: Vector3, angle: number) => Matrix4;
					makeScale: (x: number, y: number, z: number) => Matrix4;
					makeShear: (xy: number, xz: number, yx: number, yz: number, zx: number, zy: number) => Matrix4;
					compose: (translation: Vector3, rotation: Quaternion, scale: Vector3) => Matrix4;
					decompose: (translation: Vector3, rotation: Quaternion, scale: Vector3) => Matrix4;
					makePerspective: {
						(left: number, right: number, bottom: number, top: number, near: number, far: number): Matrix4;
						(fov: number, aspect: number, near: number, far: number): Matrix4;
					};
					makeOrthographic: (left: number, right: number, top: number, bottom: number, near: number, far: number) => Matrix4;
					equals: (matrix: Matrix4) => boolean;
					fromArray: (array: number[] | ArrayLike<number>, offset?: number | undefined) => Matrix4;
					toArray: {
						(array?: number[] | undefined, offset?: number | undefined): number[];
						(array?: Matrix4Tuple | undefined, offset?: 0 | undefined): Matrix4Tuple;
						(array?: ArrayLike<number> | undefined, offset?: number | undefined): ArrayLike<number>;
					};
					setFromMatrix3: (m: Matrix3) => Matrix4;
					extractPosition: (m: Matrix4) => Matrix4;
					setRotationFromQuaternion: (q: Quaternion) => Matrix4;
					multiplyVector3: (v: any) => any;
					multiplyVector4: (v: any) => any;
					multiplyVector3Array: (array: number[]) => number[];
					rotateAxis: (v: any) => void;
					crossVector: (v: any) => void;
					flattenToArrayOffset: (array: number[], offset: number) => number[];
					getInverse: (matrix: Matrix) => Matrix;
				};
				readonly normalMatrix: {
					elements: number[];
					set: (n11: number, n12: number, n13: number, n21: number, n22: number, n23: number, n31: number, n32: number, n33: number) => Matrix3;
					identity: () => Matrix3;
					clone: () => Matrix3;
					copy: (m: Matrix3) => Matrix3;
					extractBasis: (xAxis: Vector3, yAxis: Vector3, zAxis: Vector3) => Matrix3;
					setFromMatrix4: (m: Matrix4) => Matrix3;
					multiplyScalar: (s: number) => Matrix3;
					determinant: () => number;
					invert: () => Matrix3;
					transpose: () => Matrix3;
					getNormalMatrix: (matrix4: Matrix4) => Matrix3;
					transposeIntoArray: (r: number[]) => Matrix3;
					setUvTransform: (tx: number, ty: number, sx: number, sy: number, rotation: number, cx: number, cy: number) => Matrix3;
					scale: (sx: number, sy: number) => Matrix3;
					makeTranslation: {
						(x: number, y: number): Matrix3;
						(x: number, y: number): Matrix3;
					};
					makeRotation: {
						(theta: number): Matrix3;
						(theta: number): Matrix3;
					};
					makeScale: {
						(x: number, y: number): Matrix3;
						(x: number, y: number): Matrix3;
					};
					rotate: (theta: number) => Matrix3;
					translate: (tx: number, ty: number) => Matrix3;
					equals: (matrix: Matrix3) => boolean;
					fromArray: (array: number[] | ArrayLike<number>, offset?: number | undefined) => Matrix3;
					toArray: {
						(array?: number[] | undefined, offset?: number | undefined): number[];
						(array?: Matrix3Tuple | undefined, offset?: 0 | undefined): Matrix3Tuple;
						(array?: ArrayLike<number> | undefined, offset?: number | undefined): ArrayLike<number>;
					};
					multiply: (m: Matrix3) => Matrix3;
					premultiply: (m: Matrix3) => Matrix3;
					multiplyMatrices: (a: Matrix3, b: Matrix3) => Matrix3;
					multiplyVector3: (vector: Vector3) => any;
					multiplyVector3Array: (a: any) => any;
					getInverse: {
						(matrix: Matrix4, throwOnDegenerate?: boolean | undefined): Matrix3;
						(matrix: Matrix): Matrix;
					};
					flattenToArrayOffset: (array: number[], offset: number) => number[];
				};
				matrix: {
					elements: number[];
					set: (n11: number, n12: number, n13: number, n14: number, n21: number, n22: number, n23: number, n24: number, n31: number, n32: number, n33: number, n34: number, n41: number, n42: number, n43: number, n44: number) => Matrix4;
					identity: () => Matrix4;
					clone: () => Matrix4;
					copy: (m: Matrix4) => Matrix4;
					copyPosition: (m: Matrix4) => Matrix4;
					extractBasis: (xAxis: Vector3, yAxis: Vector3, zAxis: Vector3) => Matrix4;
					makeBasis: (xAxis: Vector3, yAxis: Vector3, zAxis: Vector3) => Matrix4;
					extractRotation: (m: Matrix4) => Matrix4;
					makeRotationFromEuler: (euler: Euler) => Matrix4;
					makeRotationFromQuaternion: (q: Quaternion) => Matrix4;
					lookAt: (eye: Vector3, target: Vector3, up: Vector3) => Matrix4;
					multiply: (m: Matrix4) => Matrix4;
					premultiply: (m: Matrix4) => Matrix4;
					multiplyMatrices: (a: Matrix4, b: Matrix4) => Matrix4;
					multiplyToArray: (a: Matrix4, b: Matrix4, r: number[]) => Matrix4;
					multiplyScalar: (s: number) => Matrix4;
					determinant: () => number;
					transpose: () => Matrix4;
					setPosition: (v: number | Vector3, y?: number | undefined, z?: number | undefined) => Matrix4;
					invert: () => Matrix4;
					scale: (v: Vector3) => Matrix4;
					getMaxScaleOnAxis: () => number;
					makeTranslation: (x: number, y: number, z: number) => Matrix4;
					makeRotationX: (theta: number) => Matrix4;
					makeRotationY: (theta: number) => Matrix4;
					makeRotationZ: (theta: number) => Matrix4;
					makeRotationAxis: (axis: Vector3, angle: number) => Matrix4;
					makeScale: (x: number, y: number, z: number) => Matrix4;
					makeShear: (xy: number, xz: number, yx: number, yz: number, zx: number, zy: number) => Matrix4;
					compose: (translation: Vector3, rotation: Quaternion, scale: Vector3) => Matrix4;
					decompose: (translation: Vector3, rotation: Quaternion, scale: Vector3) => Matrix4;
					makePerspective: {
						(left: number, right: number, bottom: number, top: number, near: number, far: number): Matrix4;
						(fov: number, aspect: number, near: number, far: number): Matrix4;
					};
					makeOrthographic: (left: number, right: number, top: number, bottom: number, near: number, far: number) => Matrix4;
					equals: (matrix: Matrix4) => boolean;
					fromArray: (array: number[] | ArrayLike<number>, offset?: number | undefined) => Matrix4;
					toArray: {
						(array?: number[] | undefined, offset?: number | undefined): number[];
						(array?: Matrix4Tuple | undefined, offset?: 0 | undefined): Matrix4Tuple;
						(array?: ArrayLike<number> | undefined, offset?: number | undefined): ArrayLike<number>;
					};
					setFromMatrix3: (m: Matrix3) => Matrix4;
					extractPosition: (m: Matrix4) => Matrix4;
					setRotationFromQuaternion: (q: Quaternion) => Matrix4;
					multiplyVector3: (v: any) => any;
					multiplyVector4: (v: any) => any;
					multiplyVector3Array: (array: number[]) => number[];
					rotateAxis: (v: any) => void;
					crossVector: (v: any) => void;
					flattenToArrayOffset: (array: number[], offset: number) => number[];
					getInverse: (matrix: Matrix) => Matrix;
				};
				matrixWorld: {
					elements: number[];
					set: (n11: number, n12: number, n13: number, n14: number, n21: number, n22: number, n23: number, n24: number, n31: number, n32: number, n33: number, n34: number, n41: number, n42: number, n43: number, n44: number) => Matrix4;
					identity: () => Matrix4;
					clone: () => Matrix4;
					copy: (m: Matrix4) => Matrix4;
					copyPosition: (m: Matrix4) => Matrix4;
					extractBasis: (xAxis: Vector3, yAxis: Vector3, zAxis: Vector3) => Matrix4;
					makeBasis: (xAxis: Vector3, yAxis: Vector3, zAxis: Vector3) => Matrix4;
					extractRotation: (m: Matrix4) => Matrix4;
					makeRotationFromEuler: (euler: Euler) => Matrix4;
					makeRotationFromQuaternion: (q: Quaternion) => Matrix4;
					lookAt: (eye: Vector3, target: Vector3, up: Vector3) => Matrix4;
					multiply: (m: Matrix4) => Matrix4;
					premultiply: (m: Matrix4) => Matrix4;
					multiplyMatrices: (a: Matrix4, b: Matrix4) => Matrix4;
					multiplyToArray: (a: Matrix4, b: Matrix4, r: number[]) => Matrix4;
					multiplyScalar: (s: number) => Matrix4;
					determinant: () => number;
					transpose: () => Matrix4;
					setPosition: (v: number | Vector3, y?: number | undefined, z?: number | undefined) => Matrix4;
					invert: () => Matrix4;
					scale: (v: Vector3) => Matrix4;
					getMaxScaleOnAxis: () => number;
					makeTranslation: (x: number, y: number, z: number) => Matrix4;
					makeRotationX: (theta: number) => Matrix4;
					makeRotationY: (theta: number) => Matrix4;
					makeRotationZ: (theta: number) => Matrix4;
					makeRotationAxis: (axis: Vector3, angle: number) => Matrix4;
					makeScale: (x: number, y: number, z: number) => Matrix4;
					makeShear: (xy: number, xz: number, yx: number, yz: number, zx: number, zy: number) => Matrix4;
					compose: (translation: Vector3, rotation: Quaternion, scale: Vector3) => Matrix4;
					decompose: (translation: Vector3, rotation: Quaternion, scale: Vector3) => Matrix4;
					makePerspective: {
						(left: number, right: number, bottom: number, top: number, near: number, far: number): Matrix4;
						(fov: number, aspect: number, near: number, far: number): Matrix4;
					};
					makeOrthographic: (left: number, right: number, top: number, bottom: number, near: number, far: number) => Matrix4;
					equals: (matrix: Matrix4) => boolean;
					fromArray: (array: number[] | ArrayLike<number>, offset?: number | undefined) => Matrix4;
					toArray: {
						(array?: number[] | undefined, offset?: number | undefined): number[];
						(array?: Matrix4Tuple | undefined, offset?: 0 | undefined): Matrix4Tuple;
						(array?: ArrayLike<number> | undefined, offset?: number | undefined): ArrayLike<number>;
					};
					setFromMatrix3: (m: Matrix3) => Matrix4;
					extractPosition: (m: Matrix4) => Matrix4;
					setRotationFromQuaternion: (q: Quaternion) => Matrix4;
					multiplyVector3: (v: any) => any;
					multiplyVector4: (v: any) => any;
					multiplyVector3Array: (array: number[]) => number[];
					rotateAxis: (v: any) => void;
					crossVector: (v: any) => void;
					flattenToArrayOffset: (array: number[], offset: number) => number[];
					getInverse: (matrix: Matrix) => Matrix;
				};
				matrixAutoUpdate: boolean;
				matrixWorldAutoUpdate: boolean;
				matrixWorldNeedsUpdate: boolean;
				layers: {
					mask: number;
					set: (layer: number) => void;
					enable: (layer: number) => void;
					enableAll: () => void;
					toggle: (layer: number) => void;
					disable: (layer: number) => void;
					disableAll: () => void;
					test: (layers: Layers) => boolean;
					isEnabled: (layer: number) => boolean;
				};
				visible: boolean;
				castShadow: boolean;
				receiveShadow: boolean;
				frustumCulled: boolean;
				renderOrder: number;
				animations: {
					name: string;
					tracks: {
						name: string;
						times: {
							[x: number]: number;
							readonly BYTES_PER_ELEMENT: number;
							readonly buffer: {
								readonly byteLength: number;
								slice: (begin: number, end?: number | undefined) => ArrayBuffer;
								readonly [Symbol.toStringTag]: string;
							} | {
								readonly byteLength: number;
								slice: (begin: number, end?: number | undefined) => SharedArrayBuffer;
								readonly [Symbol.species]: SharedArrayBuffer;
								readonly [Symbol.toStringTag]: "SharedArrayBuffer";
							};
							readonly byteLength: number;
							readonly byteOffset: number;
							copyWithin: (target: number, start: number, end?: number | undefined) => Float32Array;
							every: (predicate: (value: number, index: number, array: Float32Array) => unknown, thisArg?: any) => boolean;
							fill: (value: number, start?: number | undefined, end?: number | undefined) => Float32Array;
							filter: (predicate: (value: number, index: number, array: Float32Array) => any, thisArg?: any) => Float32Array;
							find: (predicate: (value: number, index: number, obj: Float32Array) => boolean, thisArg?: any) => number | undefined;
							findIndex: (predicate: (value: number, index: number, obj: Float32Array) => boolean, thisArg?: any) => number;
							forEach: (callbackfn: (value: number, index: number, array: Float32Array) => void, thisArg?: any) => void;
							indexOf: (searchElement: number, fromIndex?: number | undefined) => number;
							join: (separator?: string | undefined) => string;
							lastIndexOf: (searchElement: number, fromIndex?: number | undefined) => number;
							readonly length: number;
							map: (callbackfn: (value: number, index: number, array: Float32Array) => number, thisArg?: any) => Float32Array;
							reduce: {
								(callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number): number;
								(callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number, initialValue: number): number;
								<U>(callbackfn: (previousValue: U, currentValue: number, currentIndex: number, array: Float32Array) => U, initialValue: U): U;
							};
							reduceRight: {
								(callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number): number;
								(callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number, initialValue: number): number;
								<U_1>(callbackfn: (previousValue: U_1, currentValue: number, currentIndex: number, array: Float32Array) => U_1, initialValue: U_1): U_1;
							};
							reverse: () => Float32Array;
							set: (array: ArrayLike<number>, offset?: number | undefined) => void;
							slice: (start?: number | undefined, end?: number | undefined) => Float32Array;
							some: (predicate: (value: number, index: number, array: Float32Array) => unknown, thisArg?: any) => boolean;
							sort: (compareFn?: ((a: number, b: number) => number) | undefined) => Float32Array;
							subarray: (begin?: number | undefined, end?: number | undefined) => Float32Array;
							toLocaleString: () => string;
							toString: () => string;
							valueOf: () => Float32Array;
							entries: () => IterableIterator<[
								number,
								number
							]>;
							keys: () => IterableIterator<number>;
							values: () => IterableIterator<number>;
							includes: (searchElement: number, fromIndex?: number | undefined) => boolean;
							[Symbol.iterator]: () => IterableIterator<number>;
							readonly [Symbol.toStringTag]: "Float32Array";
							at: (index: number) => number | undefined;
						};
						values: {
							[x: number]: number;
							readonly BYTES_PER_ELEMENT: number;
							readonly buffer: {
								readonly byteLength: number;
								slice: (begin: number, end?: number | undefined) => ArrayBuffer;
								readonly [Symbol.toStringTag]: string;
							} | {
								readonly byteLength: number;
								slice: (begin: number, end?: number | undefined) => SharedArrayBuffer;
								readonly [Symbol.species]: SharedArrayBuffer;
								readonly [Symbol.toStringTag]: "SharedArrayBuffer";
							};
							readonly byteLength: number;
							readonly byteOffset: number;
							copyWithin: (target: number, start: number, end?: number | undefined) => Float32Array;
							every: (predicate: (value: number, index: number, array: Float32Array) => unknown, thisArg?: any) => boolean;
							fill: (value: number, start?: number | undefined, end?: number | undefined) => Float32Array;
							filter: (predicate: (value: number, index: number, array: Float32Array) => any, thisArg?: any) => Float32Array;
							find: (predicate: (value: number, index: number, obj: Float32Array) => boolean, thisArg?: any) => number | undefined;
							findIndex: (predicate: (value: number, index: number, obj: Float32Array) => boolean, thisArg?: any) => number;
							forEach: (callbackfn: (value: number, index: number, array: Float32Array) => void, thisArg?: any) => void;
							indexOf: (searchElement: number, fromIndex?: number | undefined) => number;
							join: (separator?: string | undefined) => string;
							lastIndexOf: (searchElement: number, fromIndex?: number | undefined) => number;
							readonly length: number;
							map: (callbackfn: (value: number, index: number, array: Float32Array) => number, thisArg?: any) => Float32Array;
							reduce: {
								(callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number): number;
								(callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number, initialValue: number): number;
								<U>(callbackfn: (previousValue: U, currentValue: number, currentIndex: number, array: Float32Array) => U, initialValue: U): U;
							};
							reduceRight: {
								(callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number): number;
								(callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number, initialValue: number): number;
								<U_1>(callbackfn: (previousValue: U_1, currentValue: number, currentIndex: number, array: Float32Array) => U_1, initialValue: U_1): U_1;
							};
							reverse: () => Float32Array;
							set: (array: ArrayLike<number>, offset?: number | undefined) => void;
							slice: (start?: number | undefined, end?: number | undefined) => Float32Array;
							some: (predicate: (value: number, index: number, array: Float32Array) => unknown, thisArg?: any) => boolean;
							sort: (compareFn?: ((a: number, b: number) => number) | undefined) => Float32Array;
							subarray: (begin?: number | undefined, end?: number | undefined) => Float32Array;
							toLocaleString: () => string;
							toString: () => string;
							valueOf: () => Float32Array;
							entries: () => IterableIterator<[
								number,
								number
							]>;
							keys: () => IterableIterator<number>;
							values: () => IterableIterator<number>;
							includes: (searchElement: number, fromIndex?: number | undefined) => boolean;
							[Symbol.iterator]: () => IterableIterator<number>;
							readonly [Symbol.toStringTag]: "Float32Array";
							at: (index: number) => number | undefined;
						};
						ValueTypeName: string;
						TimeBufferType: {
							[x: number]: number;
							readonly BYTES_PER_ELEMENT: number;
							readonly buffer: {
								readonly byteLength: number;
								slice: (begin: number, end?: number | undefined) => ArrayBuffer;
								readonly [Symbol.toStringTag]: string;
							} | {
								readonly byteLength: number;
								slice: (begin: number, end?: number | undefined) => SharedArrayBuffer;
								readonly [Symbol.species]: SharedArrayBuffer;
								readonly [Symbol.toStringTag]: "SharedArrayBuffer";
							};
							readonly byteLength: number;
							readonly byteOffset: number;
							copyWithin: (target: number, start: number, end?: number | undefined) => Float32Array;
							every: (predicate: (value: number, index: number, array: Float32Array) => unknown, thisArg?: any) => boolean;
							fill: (value: number, start?: number | undefined, end?: number | undefined) => Float32Array;
							filter: (predicate: (value: number, index: number, array: Float32Array) => any, thisArg?: any) => Float32Array;
							find: (predicate: (value: number, index: number, obj: Float32Array) => boolean, thisArg?: any) => number | undefined;
							findIndex: (predicate: (value: number, index: number, obj: Float32Array) => boolean, thisArg?: any) => number;
							forEach: (callbackfn: (value: number, index: number, array: Float32Array) => void, thisArg?: any) => void;
							indexOf: (searchElement: number, fromIndex?: number | undefined) => number;
							join: (separator?: string | undefined) => string;
							lastIndexOf: (searchElement: number, fromIndex?: number | undefined) => number;
							readonly length: number;
							map: (callbackfn: (value: number, index: number, array: Float32Array) => number, thisArg?: any) => Float32Array;
							reduce: {
								(callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number): number;
								(callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number, initialValue: number): number;
								<U>(callbackfn: (previousValue: U, currentValue: number, currentIndex: number, array: Float32Array) => U, initialValue: U): U;
							};
							reduceRight: {
								(callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number): number;
								(callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number, initialValue: number): number;
								<U_1>(callbackfn: (previousValue: U_1, currentValue: number, currentIndex: number, array: Float32Array) => U_1, initialValue: U_1): U_1;
							};
							reverse: () => Float32Array;
							set: (array: ArrayLike<number>, offset?: number | undefined) => void;
							slice: (start?: number | undefined, end?: number | undefined) => Float32Array;
							some: (predicate: (value: number, index: number, array: Float32Array) => unknown, thisArg?: any) => boolean;
							sort: (compareFn?: ((a: number, b: number) => number) | undefined) => Float32Array;
							subarray: (begin?: number | undefined, end?: number | undefined) => Float32Array;
							toLocaleString: () => string;
							toString: () => string;
							valueOf: () => Float32Array;
							entries: () => IterableIterator<[
								number,
								number
							]>;
							keys: () => IterableIterator<number>;
							values: () => IterableIterator<number>;
							includes: (searchElement: number, fromIndex?: number | undefined) => boolean;
							[Symbol.iterator]: () => IterableIterator<number>;
							readonly [Symbol.toStringTag]: "Float32Array";
							at: (index: number) => number | undefined;
						};
						ValueBufferType: {
							[x: number]: number;
							readonly BYTES_PER_ELEMENT: number;
							readonly buffer: {
								readonly byteLength: number;
								slice: (begin: number, end?: number | undefined) => ArrayBuffer;
								readonly [Symbol.toStringTag]: string;
							} | {
								readonly byteLength: number;
								slice: (begin: number, end?: number | undefined) => SharedArrayBuffer;
								readonly [Symbol.species]: SharedArrayBuffer;
								readonly [Symbol.toStringTag]: "SharedArrayBuffer";
							};
							readonly byteLength: number;
							readonly byteOffset: number;
							copyWithin: (target: number, start: number, end?: number | undefined) => Float32Array;
							every: (predicate: (value: number, index: number, array: Float32Array) => unknown, thisArg?: any) => boolean;
							fill: (value: number, start?: number | undefined, end?: number | undefined) => Float32Array;
							filter: (predicate: (value: number, index: number, array: Float32Array) => any, thisArg?: any) => Float32Array;
							find: (predicate: (value: number, index: number, obj: Float32Array) => boolean, thisArg?: any) => number | undefined;
							findIndex: (predicate: (value: number, index: number, obj: Float32Array) => boolean, thisArg?: any) => number;
							forEach: (callbackfn: (value: number, index: number, array: Float32Array) => void, thisArg?: any) => void;
							indexOf: (searchElement: number, fromIndex?: number | undefined) => number;
							join: (separator?: string | undefined) => string;
							lastIndexOf: (searchElement: number, fromIndex?: number | undefined) => number;
							readonly length: number;
							map: (callbackfn: (value: number, index: number, array: Float32Array) => number, thisArg?: any) => Float32Array;
							reduce: {
								(callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number): number;
								(callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number, initialValue: number): number;
								<U>(callbackfn: (previousValue: U, currentValue: number, currentIndex: number, array: Float32Array) => U, initialValue: U): U;
							};
							reduceRight: {
								(callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number): number;
								(callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number, initialValue: number): number;
								<U_1>(callbackfn: (previousValue: U_1, currentValue: number, currentIndex: number, array: Float32Array) => U_1, initialValue: U_1): U_1;
							};
							reverse: () => Float32Array;
							set: (array: ArrayLike<number>, offset?: number | undefined) => void;
							slice: (start?: number | undefined, end?: number | undefined) => Float32Array;
							some: (predicate: (value: number, index: number, array: Float32Array) => unknown, thisArg?: any) => boolean;
							sort: (compareFn?: ((a: number, b: number) => number) | undefined) => Float32Array;
							subarray: (begin?: number | undefined, end?: number | undefined) => Float32Array;
							toLocaleString: () => string;
							toString: () => string;
							valueOf: () => Float32Array;
							entries: () => IterableIterator<[
								number,
								number
							]>;
							keys: () => IterableIterator<number>;
							values: () => IterableIterator<number>;
							includes: (searchElement: number, fromIndex?: number | undefined) => boolean;
							[Symbol.iterator]: () => IterableIterator<number>;
							readonly [Symbol.toStringTag]: "Float32Array";
							at: (index: number) => number | undefined;
						};
						DefaultInterpolation: InterpolationModes;
						InterpolantFactoryMethodDiscrete: (result: any) => DiscreteInterpolant;
						InterpolantFactoryMethodLinear: (result: any) => LinearInterpolant;
						InterpolantFactoryMethodSmooth: (result: any) => CubicInterpolant;
						setInterpolation: (interpolation: InterpolationModes) => KeyframeTrack;
						getInterpolation: () => InterpolationModes;
						createInterpolant: () => Interpolant;
						getValueSize: () => number;
						shift: (timeOffset: number) => KeyframeTrack;
						scale: (timeScale: number) => KeyframeTrack;
						trim: (startTime: number, endTime: number) => KeyframeTrack;
						validate: () => boolean;
						optimize: () => KeyframeTrack;
						clone: () => KeyframeTrack;
					}[];
					blendMode: AnimationBlendMode;
					duration: number;
					uuid: string;
					results: any[];
					resetDuration: () => AnimationClip;
					trim: () => AnimationClip;
					validate: () => boolean;
					optimize: () => AnimationClip;
					clone: () => AnimationClip;
					toJSON: (clip: AnimationClip) => any;
				}[];
				userData: {
					[key: string]: any;
				};
				customDepthMaterial?: {
					alphaTest: number;
					alphaToCoverage: boolean;
					blendDst: BlendingDstFactor;
					blendDstAlpha: number | null;
					blendEquation: BlendingEquation;
					blendEquationAlpha: number | null;
					blending: Blending;
					blendSrc: 210 | BlendingDstFactor;
					blendSrcAlpha: number | null;
					clipIntersection: boolean;
					clippingPlanes: any;
					clipShadows: boolean;
					colorWrite: boolean;
					defines: {
						[key: string]: any;
					} | undefined;
					depthFunc: DepthModes;
					depthTest: boolean;
					depthWrite: boolean;
					id: number;
					stencilWrite: boolean;
					stencilFunc: StencilFunc;
					stencilRef: number;
					stencilWriteMask: number;
					stencilFuncMask: number;
					stencilFail: StencilOp;
					stencilZFail: StencilOp;
					stencilZPass: StencilOp;
					readonly isMaterial: true;
					name: string;
					needsUpdate: boolean;
					opacity: number;
					polygonOffset: boolean;
					polygonOffsetFactor: number;
					polygonOffsetUnits: number;
					precision: "highp" | "mediump" | "lowp" | null;
					premultipliedAlpha: boolean;
					forceSinglePass: boolean;
					dithering: boolean;
					side: Side;
					shadowSide: Side | null;
					toneMapped: boolean;
					transparent: boolean;
					type: string;
					uuid: string;
					vertexColors: boolean;
					visible: boolean;
					userData: any;
					version: number;
					clone: () => Material;
					copy: (material: Material) => Material;
					dispose: () => void;
					onBeforeCompile: (shader: Shader, renderer: WebGLRenderer) => void;
					customProgramCacheKey: () => string;
					setValues: (values: MaterialParameters) => void;
					toJSON: (meta?: any) => any;
					addEventListener: <T extends string>(type: T, listener: EventListener<Event, T, Material>) => void;
					hasEventListener: <T_1 extends string>(type: T_1, listener: EventListener<Event, T_1, Material>) => boolean;
					removeEventListener: <T_2 extends string>(type: T_2, listener: EventListener<Event, T_2, Material>) => void;
					dispatchEvent: (event: Event) => void;
				} | undefined;
				customDistanceMaterial?: {
					alphaTest: number;
					alphaToCoverage: boolean;
					blendDst: BlendingDstFactor;
					blendDstAlpha: number | null;
					blendEquation: BlendingEquation;
					blendEquationAlpha: number | null;
					blending: Blending;
					blendSrc: 210 | BlendingDstFactor;
					blendSrcAlpha: number | null;
					clipIntersection: boolean;
					clippingPlanes: any;
					clipShadows: boolean;
					colorWrite: boolean;
					defines: {
						[key: string]: any;
					} | undefined;
					depthFunc: DepthModes;
					depthTest: boolean;
					depthWrite: boolean;
					id: number;
					stencilWrite: boolean;
					stencilFunc: StencilFunc;
					stencilRef: number;
					stencilWriteMask: number;
					stencilFuncMask: number;
					stencilFail: StencilOp;
					stencilZFail: StencilOp;
					stencilZPass: StencilOp;
					readonly isMaterial: true;
					name: string;
					needsUpdate: boolean;
					opacity: number;
					polygonOffset: boolean;
					polygonOffsetFactor: number;
					polygonOffsetUnits: number;
					precision: "highp" | "mediump" | "lowp" | null;
					premultipliedAlpha: boolean;
					forceSinglePass: boolean;
					dithering: boolean;
					side: Side;
					shadowSide: Side | null;
					toneMapped: boolean;
					transparent: boolean;
					type: string;
					uuid: string;
					vertexColors: boolean;
					visible: boolean;
					userData: any;
					version: number;
					clone: () => Material;
					copy: (material: Material) => Material;
					dispose: () => void;
					onBeforeCompile: (shader: Shader, renderer: WebGLRenderer) => void;
					customProgramCacheKey: () => string;
					setValues: (values: MaterialParameters) => void;
					toJSON: (meta?: any) => any;
					addEventListener: <T extends string>(type: T, listener: EventListener<Event, T, Material>) => void;
					hasEventListener: <T_1 extends string>(type: T_1, listener: EventListener<Event, T_1, Material>) => boolean;
					removeEventListener: <T_2 extends string>(type: T_2, listener: EventListener<Event, T_2, Material>) => void;
					dispatchEvent: (event: Event) => void;
				} | undefined;
				onBeforeRender: (renderer: WebGLRenderer, scene: Scene, camera: Camera, geometry: BufferGeometry<NormalBufferAttributes>, material: Material, group: Group) => void;
				onAfterRender: (renderer: WebGLRenderer, scene: Scene, camera: Camera, geometry: BufferGeometry<NormalBufferAttributes>, material: Material, group: Group) => void;
				applyMatrix4: (matrix: Matrix4) => void;
				applyQuaternion: (quaternion: Quaternion) => Object3D<Event>;
				setRotationFromAxisAngle: (axis: Vector3, angle: number) => void;
				setRotationFromEuler: (euler: Euler) => void;
				setRotationFromMatrix: (m: Matrix4) => void;
				setRotationFromQuaternion: (q: Quaternion) => void;
				rotateOnAxis: (axis: Vector3, angle: number) => Object3D<Event>;
				rotateOnWorldAxis: (axis: Vector3, angle: number) => Object3D<Event>;
				rotateX: (angle: number) => Object3D<Event>;
				rotateY: (angle: number) => Object3D<Event>;
				rotateZ: (angle: number) => Object3D<Event>;
				translateOnAxis: (axis: Vector3, distance: number) => Object3D<Event>;
				translateX: (distance: number) => Object3D<Event>;
				translateY: (distance: number) => Object3D<Event>;
				translateZ: (distance: number) => Object3D<Event>;
				localToWorld: (vector: Vector3) => Vector3;
				worldToLocal: (vector: Vector3) => Vector3;
				lookAt: {
					(vector: Vector3): void;
					(x: number, y: number, z: number): void;
				};
				add: (...object: Object3D<Event>[]) => Object3D<Event>;
				remove: (...object: Object3D<Event>[]) => Object3D<Event>;
				removeFromParent: () => Object3D<Event>;
				clear: () => Object3D<Event>;
				attach: (object: Object3D<Event>) => Object3D<Event>;
				getObjectById: (id: number) => Object3D<Event> | undefined;
				getObjectByName: (name: string) => Object3D<Event> | undefined;
				getObjectByProperty: (name: string, value: any) => Object3D<Event> | undefined;
				getObjectsByProperty: (name: string, value: any) => Object3D<Event>[];
				getWorldPosition: (target: Vector3) => Vector3;
				getWorldQuaternion: (target: Quaternion) => Quaternion;
				getWorldScale: (target: Vector3) => Vector3;
				getWorldDirection: (target: Vector3) => Vector3;
				raycast: (raycaster: Raycaster, intersects: Intersection<Object3D<Event>>[]) => void;
				traverse: (callback: (object: Object3D<Event>) => any) => void;
				traverseVisible: (callback: (object: Object3D<Event>) => any) => void;
				traverseAncestors: (callback: (object: Object3D<Event>) => any) => void;
				updateMatrix: () => void;
				updateMatrixWorld: (force?: boolean | undefined) => void;
				updateWorldMatrix: (updateParents: boolean, updateChildren: boolean) => void;
				toJSON: (meta?: {
					geometries: any;
					materials: any;
					textures: any;
					images: any;
				} | undefined) => any;
				clone: (recursive?: boolean | undefined) => Object3D<Event>;
				copy: (source: Object3D<Event>, recursive?: boolean | undefined) => Object3D<Event>;
				addEventListener: <T_3 extends string>(type: T_3, listener: EventListener<Event, T_3, Object3D<Event>>) => void;
				hasEventListener: <T_4 extends string>(type: T_4, listener: EventListener<Event, T_4, Object3D<Event>>) => boolean;
				removeEventListener: <T_5 extends string>(type: T_5, listener: EventListener<Event, T_5, Object3D<Event>>) => void;
				dispatchEvent: (event: Event) => void;
			}[];
			up: {
				x: number;
				y: number;
				z: number;
				readonly isVector3: true;
				set: (x: number, y: number, z: number) => Vector3;
				setScalar: (scalar: number) => Vector3;
				setX: (x: number) => Vector3;
				setY: (y: number) => Vector3;
				setZ: (z: number) => Vector3;
				setComponent: (index: number, value: number) => Vector3;
				setFromColor: (color: Color) => Vector3;
				getComponent: (index: number) => number;
				clone: () => Vector3;
				copy: (v: Vector3) => Vector3;
				add: (v: Vector3) => Vector3;
				addScalar: (s: number) => Vector3;
				addScaledVector: (v: Vector3, s: number) => Vector3;
				addVectors: (a: Vector3, b: Vector3) => Vector3;
				sub: (a: Vector3) => Vector3;
				subScalar: (s: number) => Vector3;
				subVectors: (a: Vector3, b: Vector3) => Vector3;
				multiply: (v: Vector3) => Vector3;
				multiplyScalar: (s: number) => Vector3;
				multiplyVectors: (a: Vector3, b: Vector3) => Vector3;
				applyEuler: (euler: Euler) => Vector3;
				applyAxisAngle: (axis: Vector3, angle: number) => Vector3;
				applyMatrix3: (m: Matrix3) => Vector3;
				applyNormalMatrix: (m: Matrix3) => Vector3;
				applyMatrix4: (m: Matrix4) => Vector3;
				applyQuaternion: (q: Quaternion) => Vector3;
				project: (camera: Camera) => Vector3;
				unproject: (camera: Camera) => Vector3;
				transformDirection: (m: Matrix4) => Vector3;
				divide: (v: Vector3) => Vector3;
				divideScalar: (s: number) => Vector3;
				min: (v: Vector3) => Vector3;
				max: (v: Vector3) => Vector3;
				clamp: (min: Vector3, max: Vector3) => Vector3;
				clampScalar: (min: number, max: number) => Vector3;
				clampLength: (min: number, max: number) => Vector3;
				floor: () => Vector3;
				ceil: () => Vector3;
				round: () => Vector3;
				roundToZero: () => Vector3;
				negate: () => Vector3;
				dot: (v: Vector3) => number;
				lengthSq: () => number;
				length: () => number;
				lengthManhattan: () => number;
				manhattanLength: () => number;
				manhattanDistanceTo: (v: Vector3) => number;
				normalize: () => Vector3;
				setLength: (l: number) => Vector3;
				lerp: (v: Vector3, alpha: number) => Vector3;
				lerpVectors: (v1: Vector3, v2: Vector3, alpha: number) => Vector3;
				cross: (a: Vector3) => Vector3;
				crossVectors: (a: Vector3, b: Vector3) => Vector3;
				projectOnVector: (v: Vector3) => Vector3;
				projectOnPlane: (planeNormal: Vector3) => Vector3;
				reflect: (vector: Vector3) => Vector3;
				angleTo: (v: Vector3) => number;
				distanceTo: (v: Vector3) => number;
				distanceToSquared: (v: Vector3) => number;
				distanceToManhattan: (v: Vector3) => number;
				setFromSpherical: (s: Spherical) => Vector3;
				setFromSphericalCoords: (r: number, phi: number, theta: number) => Vector3;
				setFromCylindrical: (s: Cylindrical) => Vector3;
				setFromCylindricalCoords: (radius: number, theta: number, y: number) => Vector3;
				setFromMatrixPosition: (m: Matrix4) => Vector3;
				setFromMatrixScale: (m: Matrix4) => Vector3;
				setFromMatrixColumn: (matrix: Matrix4, index: number) => Vector3;
				setFromMatrix3Column: (matrix: Matrix3, index: number) => Vector3;
				setFromEuler: (e: Euler) => Vector3;
				equals: (v: Vector3) => boolean;
				fromArray: (array: number[] | ArrayLike<number>, offset?: number | undefined) => Vector3;
				toArray: {
					(array?: number[] | undefined, offset?: number | undefined): number[];
					(array?: Vector3Tuple | undefined, offset?: 0 | undefined): Vector3Tuple;
					(array: ArrayLike<number>, offset?: number | undefined): ArrayLike<number>;
				};
				fromBufferAttribute: (attribute: BufferAttribute | InterleavedBufferAttribute, index: number) => Vector3;
				random: () => Vector3;
				randomDirection: () => Vector3;
			};
			readonly position: {
				x: number;
				y: number;
				z: number;
				readonly isVector3: true;
				set: (x: number, y: number, z: number) => Vector3;
				setScalar: (scalar: number) => Vector3;
				setX: (x: number) => Vector3;
				setY: (y: number) => Vector3;
				setZ: (z: number) => Vector3;
				setComponent: (index: number, value: number) => Vector3;
				setFromColor: (color: Color) => Vector3;
				getComponent: (index: number) => number;
				clone: () => Vector3;
				copy: (v: Vector3) => Vector3;
				add: (v: Vector3) => Vector3;
				addScalar: (s: number) => Vector3;
				addScaledVector: (v: Vector3, s: number) => Vector3;
				addVectors: (a: Vector3, b: Vector3) => Vector3;
				sub: (a: Vector3) => Vector3;
				subScalar: (s: number) => Vector3;
				subVectors: (a: Vector3, b: Vector3) => Vector3;
				multiply: (v: Vector3) => Vector3;
				multiplyScalar: (s: number) => Vector3;
				multiplyVectors: (a: Vector3, b: Vector3) => Vector3;
				applyEuler: (euler: Euler) => Vector3;
				applyAxisAngle: (axis: Vector3, angle: number) => Vector3;
				applyMatrix3: (m: Matrix3) => Vector3;
				applyNormalMatrix: (m: Matrix3) => Vector3;
				applyMatrix4: (m: Matrix4) => Vector3;
				applyQuaternion: (q: Quaternion) => Vector3;
				project: (camera: Camera) => Vector3;
				unproject: (camera: Camera) => Vector3;
				transformDirection: (m: Matrix4) => Vector3;
				divide: (v: Vector3) => Vector3;
				divideScalar: (s: number) => Vector3;
				min: (v: Vector3) => Vector3;
				max: (v: Vector3) => Vector3;
				clamp: (min: Vector3, max: Vector3) => Vector3;
				clampScalar: (min: number, max: number) => Vector3;
				clampLength: (min: number, max: number) => Vector3;
				floor: () => Vector3;
				ceil: () => Vector3;
				round: () => Vector3;
				roundToZero: () => Vector3;
				negate: () => Vector3;
				dot: (v: Vector3) => number;
				lengthSq: () => number;
				length: () => number;
				lengthManhattan: () => number;
				manhattanLength: () => number;
				manhattanDistanceTo: (v: Vector3) => number;
				normalize: () => Vector3;
				setLength: (l: number) => Vector3;
				lerp: (v: Vector3, alpha: number) => Vector3;
				lerpVectors: (v1: Vector3, v2: Vector3, alpha: number) => Vector3;
				cross: (a: Vector3) => Vector3;
				crossVectors: (a: Vector3, b: Vector3) => Vector3;
				projectOnVector: (v: Vector3) => Vector3;
				projectOnPlane: (planeNormal: Vector3) => Vector3;
				reflect: (vector: Vector3) => Vector3;
				angleTo: (v: Vector3) => number;
				distanceTo: (v: Vector3) => number;
				distanceToSquared: (v: Vector3) => number;
				distanceToManhattan: (v: Vector3) => number;
				setFromSpherical: (s: Spherical) => Vector3;
				setFromSphericalCoords: (r: number, phi: number, theta: number) => Vector3;
				setFromCylindrical: (s: Cylindrical) => Vector3;
				setFromCylindricalCoords: (radius: number, theta: number, y: number) => Vector3;
				setFromMatrixPosition: (m: Matrix4) => Vector3;
				setFromMatrixScale: (m: Matrix4) => Vector3;
				setFromMatrixColumn: (matrix: Matrix4, index: number) => Vector3;
				setFromMatrix3Column: (matrix: Matrix3, index: number) => Vector3;
				setFromEuler: (e: Euler) => Vector3;
				equals: (v: Vector3) => boolean;
				fromArray: (array: number[] | ArrayLike<number>, offset?: number | undefined) => Vector3;
				toArray: {
					(array?: number[] | undefined, offset?: number | undefined): number[];
					(array?: Vector3Tuple | undefined, offset?: 0 | undefined): Vector3Tuple;
					(array: ArrayLike<number>, offset?: number | undefined): ArrayLike<number>;
				};
				fromBufferAttribute: (attribute: BufferAttribute | InterleavedBufferAttribute, index: number) => Vector3;
				random: () => Vector3;
				randomDirection: () => Vector3;
			};
			readonly rotation: {
				x: number;
				y: number;
				z: number;
				order: EulerOrder;
				readonly isEuler: true;
				_onChangeCallback: () => void;
				set: (x: number, y: number, z: number, order?: EulerOrder | undefined) => Euler;
				clone: () => Euler;
				copy: (euler: Euler) => Euler;
				setFromRotationMatrix: (m: Matrix4, order?: EulerOrder | undefined, update?: boolean | undefined) => Euler;
				setFromQuaternion: (q: Quaternion, order?: EulerOrder | undefined, update?: boolean | undefined) => Euler;
				setFromVector3: (v: Vector3, order?: EulerOrder | undefined) => Euler;
				reorder: (newOrder: EulerOrder) => Euler;
				equals: (euler: Euler) => boolean;
				fromArray: (xyzo: [
					number,
					number,
					number,
					(EulerOrder | undefined)?,
					...any[]
				]) => Euler;
				toArray: (array?: (string | number | undefined)[] | undefined, offset?: number | undefined) => (string | number | undefined)[];
				_onChange: (callback: () => void) => Euler;
				[Symbol.iterator]: () => Generator<string | number, void, unknown>;
			};
			readonly quaternion: {
				x: number;
				y: number;
				z: number;
				w: number;
				readonly isQuaternion: true;
				set: (x: number, y: number, z: number, w: number) => Quaternion;
				clone: () => Quaternion;
				copy: (q: Quaternion) => Quaternion;
				setFromEuler: (euler: Euler, update?: boolean | undefined) => Quaternion;
				setFromAxisAngle: (axis: Vector3, angle: number) => Quaternion;
				setFromRotationMatrix: (m: Matrix4) => Quaternion;
				setFromUnitVectors: (vFrom: Vector3, vTo: Vector3) => Quaternion;
				angleTo: (q: Quaternion) => number;
				rotateTowards: (q: Quaternion, step: number) => Quaternion;
				identity: () => Quaternion;
				invert: () => Quaternion;
				conjugate: () => Quaternion;
				dot: (v: Quaternion) => number;
				lengthSq: () => number;
				length: () => number;
				normalize: () => Quaternion;
				multiply: (q: Quaternion) => Quaternion;
				premultiply: (q: Quaternion) => Quaternion;
				multiplyQuaternions: (a: Quaternion, b: Quaternion) => Quaternion;
				slerp: (qb: Quaternion, t: number) => Quaternion;
				slerpQuaternions: (qa: Quaternion, qb: Quaternion, t: number) => Quaternion;
				equals: (v: Quaternion) => boolean;
				fromArray: (array: number[] | ArrayLike<number>, offset?: number | undefined) => Quaternion;
				toArray: {
					(array?: number[] | undefined, offset?: number | undefined): number[];
					(array: ArrayLike<number>, offset?: number | undefined): ArrayLike<number>;
				};
				toJSON: () => [
					number,
					number,
					number,
					number
				];
				fromBufferAttribute: (attribute: BufferAttribute | InterleavedBufferAttribute, index: number) => Quaternion;
				_onChange: (callback: () => void) => Quaternion;
				_onChangeCallback: () => void;
				multiplyVector3: (v: any) => any;
				random: () => Quaternion;
				[Symbol.iterator]: () => Generator<number, void, unknown>;
			};
			readonly scale: {
				x: number;
				y: number;
				z: number;
				readonly isVector3: true;
				set: (x: number, y: number, z: number) => Vector3;
				setScalar: (scalar: number) => Vector3;
				setX: (x: number) => Vector3;
				setY: (y: number) => Vector3;
				setZ: (z: number) => Vector3;
				setComponent: (index: number, value: number) => Vector3;
				setFromColor: (color: Color) => Vector3;
				getComponent: (index: number) => number;
				clone: () => Vector3;
				copy: (v: Vector3) => Vector3;
				add: (v: Vector3) => Vector3;
				addScalar: (s: number) => Vector3;
				addScaledVector: (v: Vector3, s: number) => Vector3;
				addVectors: (a: Vector3, b: Vector3) => Vector3;
				sub: (a: Vector3) => Vector3;
				subScalar: (s: number) => Vector3;
				subVectors: (a: Vector3, b: Vector3) => Vector3;
				multiply: (v: Vector3) => Vector3;
				multiplyScalar: (s: number) => Vector3;
				multiplyVectors: (a: Vector3, b: Vector3) => Vector3;
				applyEuler: (euler: Euler) => Vector3;
				applyAxisAngle: (axis: Vector3, angle: number) => Vector3;
				applyMatrix3: (m: Matrix3) => Vector3;
				applyNormalMatrix: (m: Matrix3) => Vector3;
				applyMatrix4: (m: Matrix4) => Vector3;
				applyQuaternion: (q: Quaternion) => Vector3;
				project: (camera: Camera) => Vector3;
				unproject: (camera: Camera) => Vector3;
				transformDirection: (m: Matrix4) => Vector3;
				divide: (v: Vector3) => Vector3;
				divideScalar: (s: number) => Vector3;
				min: (v: Vector3) => Vector3;
				max: (v: Vector3) => Vector3;
				clamp: (min: Vector3, max: Vector3) => Vector3;
				clampScalar: (min: number, max: number) => Vector3;
				clampLength: (min: number, max: number) => Vector3;
				floor: () => Vector3;
				ceil: () => Vector3;
				round: () => Vector3;
				roundToZero: () => Vector3;
				negate: () => Vector3;
				dot: (v: Vector3) => number;
				lengthSq: () => number;
				length: () => number;
				lengthManhattan: () => number;
				manhattanLength: () => number;
				manhattanDistanceTo: (v: Vector3) => number;
				normalize: () => Vector3;
				setLength: (l: number) => Vector3;
				lerp: (v: Vector3, alpha: number) => Vector3;
				lerpVectors: (v1: Vector3, v2: Vector3, alpha: number) => Vector3;
				cross: (a: Vector3) => Vector3;
				crossVectors: (a: Vector3, b: Vector3) => Vector3;
				projectOnVector: (v: Vector3) => Vector3;
				projectOnPlane: (planeNormal: Vector3) => Vector3;
				reflect: (vector: Vector3) => Vector3;
				angleTo: (v: Vector3) => number;
				distanceTo: (v: Vector3) => number;
				distanceToSquared: (v: Vector3) => number;
				distanceToManhattan: (v: Vector3) => number;
				setFromSpherical: (s: Spherical) => Vector3;
				setFromSphericalCoords: (r: number, phi: number, theta: number) => Vector3;
				setFromCylindrical: (s: Cylindrical) => Vector3;
				setFromCylindricalCoords: (radius: number, theta: number, y: number) => Vector3;
				setFromMatrixPosition: (m: Matrix4) => Vector3;
				setFromMatrixScale: (m: Matrix4) => Vector3;
				setFromMatrixColumn: (matrix: Matrix4, index: number) => Vector3;
				setFromMatrix3Column: (matrix: Matrix3, index: number) => Vector3;
				setFromEuler: (e: Euler) => Vector3;
				equals: (v: Vector3) => boolean;
				fromArray: (array: number[] | ArrayLike<number>, offset?: number | undefined) => Vector3;
				toArray: {
					(array?: number[] | undefined, offset?: number | undefined): number[];
					(array?: Vector3Tuple | undefined, offset?: 0 | undefined): Vector3Tuple;
					(array: ArrayLike<number>, offset?: number | undefined): ArrayLike<number>;
				};
				fromBufferAttribute: (attribute: BufferAttribute | InterleavedBufferAttribute, index: number) => Vector3;
				random: () => Vector3;
				randomDirection: () => Vector3;
			};
			readonly modelViewMatrix: {
				elements: number[];
				set: (n11: number, n12: number, n13: number, n14: number, n21: number, n22: number, n23: number, n24: number, n31: number, n32: number, n33: number, n34: number, n41: number, n42: number, n43: number, n44: number) => Matrix4;
				identity: () => Matrix4;
				clone: () => Matrix4;
				copy: (m: Matrix4) => Matrix4;
				copyPosition: (m: Matrix4) => Matrix4;
				extractBasis: (xAxis: Vector3, yAxis: Vector3, zAxis: Vector3) => Matrix4;
				makeBasis: (xAxis: Vector3, yAxis: Vector3, zAxis: Vector3) => Matrix4;
				extractRotation: (m: Matrix4) => Matrix4;
				makeRotationFromEuler: (euler: Euler) => Matrix4;
				makeRotationFromQuaternion: (q: Quaternion) => Matrix4;
				lookAt: (eye: Vector3, target: Vector3, up: Vector3) => Matrix4;
				multiply: (m: Matrix4) => Matrix4;
				premultiply: (m: Matrix4) => Matrix4;
				multiplyMatrices: (a: Matrix4, b: Matrix4) => Matrix4;
				multiplyToArray: (a: Matrix4, b: Matrix4, r: number[]) => Matrix4;
				multiplyScalar: (s: number) => Matrix4;
				determinant: () => number;
				transpose: () => Matrix4;
				setPosition: (v: number | Vector3, y?: number | undefined, z?: number | undefined) => Matrix4;
				invert: () => Matrix4;
				scale: (v: Vector3) => Matrix4;
				getMaxScaleOnAxis: () => number;
				makeTranslation: (x: number, y: number, z: number) => Matrix4;
				makeRotationX: (theta: number) => Matrix4;
				makeRotationY: (theta: number) => Matrix4;
				makeRotationZ: (theta: number) => Matrix4;
				makeRotationAxis: (axis: Vector3, angle: number) => Matrix4;
				makeScale: (x: number, y: number, z: number) => Matrix4;
				makeShear: (xy: number, xz: number, yx: number, yz: number, zx: number, zy: number) => Matrix4;
				compose: (translation: Vector3, rotation: Quaternion, scale: Vector3) => Matrix4;
				decompose: (translation: Vector3, rotation: Quaternion, scale: Vector3) => Matrix4;
				makePerspective: {
					(left: number, right: number, bottom: number, top: number, near: number, far: number): Matrix4;
					(fov: number, aspect: number, near: number, far: number): Matrix4;
				};
				makeOrthographic: (left: number, right: number, top: number, bottom: number, near: number, far: number) => Matrix4;
				equals: (matrix: Matrix4) => boolean;
				fromArray: (array: number[] | ArrayLike<number>, offset?: number | undefined) => Matrix4;
				toArray: {
					(array?: number[] | undefined, offset?: number | undefined): number[];
					(array?: Matrix4Tuple | undefined, offset?: 0 | undefined): Matrix4Tuple;
					(array?: ArrayLike<number> | undefined, offset?: number | undefined): ArrayLike<number>;
				};
				setFromMatrix3: (m: Matrix3) => Matrix4;
				extractPosition: (m: Matrix4) => Matrix4;
				setRotationFromQuaternion: (q: Quaternion) => Matrix4;
				multiplyVector3: (v: any) => any;
				multiplyVector4: (v: any) => any;
				multiplyVector3Array: (array: number[]) => number[];
				rotateAxis: (v: any) => void;
				crossVector: (v: any) => void;
				flattenToArrayOffset: (array: number[], offset: number) => number[];
				getInverse: (matrix: Matrix) => Matrix;
			};
			readonly normalMatrix: {
				elements: number[];
				set: (n11: number, n12: number, n13: number, n21: number, n22: number, n23: number, n31: number, n32: number, n33: number) => Matrix3;
				identity: () => Matrix3;
				clone: () => Matrix3;
				copy: (m: Matrix3) => Matrix3;
				extractBasis: (xAxis: Vector3, yAxis: Vector3, zAxis: Vector3) => Matrix3;
				setFromMatrix4: (m: Matrix4) => Matrix3;
				multiplyScalar: (s: number) => Matrix3;
				determinant: () => number;
				invert: () => Matrix3;
				transpose: () => Matrix3;
				getNormalMatrix: (matrix4: Matrix4) => Matrix3;
				transposeIntoArray: (r: number[]) => Matrix3;
				setUvTransform: (tx: number, ty: number, sx: number, sy: number, rotation: number, cx: number, cy: number) => Matrix3;
				scale: (sx: number, sy: number) => Matrix3;
				makeTranslation: {
					(x: number, y: number): Matrix3;
					(x: number, y: number): Matrix3;
				};
				makeRotation: {
					(theta: number): Matrix3;
					(theta: number): Matrix3;
				};
				makeScale: {
					(x: number, y: number): Matrix3;
					(x: number, y: number): Matrix3;
				};
				rotate: (theta: number) => Matrix3;
				translate: (tx: number, ty: number) => Matrix3;
				equals: (matrix: Matrix3) => boolean;
				fromArray: (array: number[] | ArrayLike<number>, offset?: number | undefined) => Matrix3;
				toArray: {
					(array?: number[] | undefined, offset?: number | undefined): number[];
					(array?: Matrix3Tuple | undefined, offset?: 0 | undefined): Matrix3Tuple;
					(array?: ArrayLike<number> | undefined, offset?: number | undefined): ArrayLike<number>;
				};
				multiply: (m: Matrix3) => Matrix3;
				premultiply: (m: Matrix3) => Matrix3;
				multiplyMatrices: (a: Matrix3, b: Matrix3) => Matrix3;
				multiplyVector3: (vector: Vector3) => any;
				multiplyVector3Array: (a: any) => any;
				getInverse: {
					(matrix: Matrix4, throwOnDegenerate?: boolean | undefined): Matrix3;
					(matrix: Matrix): Matrix;
				};
				flattenToArrayOffset: (array: number[], offset: number) => number[];
			};
			matrix: {
				elements: number[];
				set: (n11: number, n12: number, n13: number, n14: number, n21: number, n22: number, n23: number, n24: number, n31: number, n32: number, n33: number, n34: number, n41: number, n42: number, n43: number, n44: number) => Matrix4;
				identity: () => Matrix4;
				clone: () => Matrix4;
				copy: (m: Matrix4) => Matrix4;
				copyPosition: (m: Matrix4) => Matrix4;
				extractBasis: (xAxis: Vector3, yAxis: Vector3, zAxis: Vector3) => Matrix4;
				makeBasis: (xAxis: Vector3, yAxis: Vector3, zAxis: Vector3) => Matrix4;
				extractRotation: (m: Matrix4) => Matrix4;
				makeRotationFromEuler: (euler: Euler) => Matrix4;
				makeRotationFromQuaternion: (q: Quaternion) => Matrix4;
				lookAt: (eye: Vector3, target: Vector3, up: Vector3) => Matrix4;
				multiply: (m: Matrix4) => Matrix4;
				premultiply: (m: Matrix4) => Matrix4;
				multiplyMatrices: (a: Matrix4, b: Matrix4) => Matrix4;
				multiplyToArray: (a: Matrix4, b: Matrix4, r: number[]) => Matrix4;
				multiplyScalar: (s: number) => Matrix4;
				determinant: () => number;
				transpose: () => Matrix4;
				setPosition: (v: number | Vector3, y?: number | undefined, z?: number | undefined) => Matrix4;
				invert: () => Matrix4;
				scale: (v: Vector3) => Matrix4;
				getMaxScaleOnAxis: () => number;
				makeTranslation: (x: number, y: number, z: number) => Matrix4;
				makeRotationX: (theta: number) => Matrix4;
				makeRotationY: (theta: number) => Matrix4;
				makeRotationZ: (theta: number) => Matrix4;
				makeRotationAxis: (axis: Vector3, angle: number) => Matrix4;
				makeScale: (x: number, y: number, z: number) => Matrix4;
				makeShear: (xy: number, xz: number, yx: number, yz: number, zx: number, zy: number) => Matrix4;
				compose: (translation: Vector3, rotation: Quaternion, scale: Vector3) => Matrix4;
				decompose: (translation: Vector3, rotation: Quaternion, scale: Vector3) => Matrix4;
				makePerspective: {
					(left: number, right: number, bottom: number, top: number, near: number, far: number): Matrix4;
					(fov: number, aspect: number, near: number, far: number): Matrix4;
				};
				makeOrthographic: (left: number, right: number, top: number, bottom: number, near: number, far: number) => Matrix4;
				equals: (matrix: Matrix4) => boolean;
				fromArray: (array: number[] | ArrayLike<number>, offset?: number | undefined) => Matrix4;
				toArray: {
					(array?: number[] | undefined, offset?: number | undefined): number[];
					(array?: Matrix4Tuple | undefined, offset?: 0 | undefined): Matrix4Tuple;
					(array?: ArrayLike<number> | undefined, offset?: number | undefined): ArrayLike<number>;
				};
				setFromMatrix3: (m: Matrix3) => Matrix4;
				extractPosition: (m: Matrix4) => Matrix4;
				setRotationFromQuaternion: (q: Quaternion) => Matrix4;
				multiplyVector3: (v: any) => any;
				multiplyVector4: (v: any) => any;
				multiplyVector3Array: (array: number[]) => number[];
				rotateAxis: (v: any) => void;
				crossVector: (v: any) => void;
				flattenToArrayOffset: (array: number[], offset: number) => number[];
				getInverse: (matrix: Matrix) => Matrix;
			};
			matrixWorld: {
				elements: number[];
				set: (n11: number, n12: number, n13: number, n14: number, n21: number, n22: number, n23: number, n24: number, n31: number, n32: number, n33: number, n34: number, n41: number, n42: number, n43: number, n44: number) => Matrix4;
				identity: () => Matrix4;
				clone: () => Matrix4;
				copy: (m: Matrix4) => Matrix4;
				copyPosition: (m: Matrix4) => Matrix4;
				extractBasis: (xAxis: Vector3, yAxis: Vector3, zAxis: Vector3) => Matrix4;
				makeBasis: (xAxis: Vector3, yAxis: Vector3, zAxis: Vector3) => Matrix4;
				extractRotation: (m: Matrix4) => Matrix4;
				makeRotationFromEuler: (euler: Euler) => Matrix4;
				makeRotationFromQuaternion: (q: Quaternion) => Matrix4;
				lookAt: (eye: Vector3, target: Vector3, up: Vector3) => Matrix4;
				multiply: (m: Matrix4) => Matrix4;
				premultiply: (m: Matrix4) => Matrix4;
				multiplyMatrices: (a: Matrix4, b: Matrix4) => Matrix4;
				multiplyToArray: (a: Matrix4, b: Matrix4, r: number[]) => Matrix4;
				multiplyScalar: (s: number) => Matrix4;
				determinant: () => number;
				transpose: () => Matrix4;
				setPosition: (v: number | Vector3, y?: number | undefined, z?: number | undefined) => Matrix4;
				invert: () => Matrix4;
				scale: (v: Vector3) => Matrix4;
				getMaxScaleOnAxis: () => number;
				makeTranslation: (x: number, y: number, z: number) => Matrix4;
				makeRotationX: (theta: number) => Matrix4;
				makeRotationY: (theta: number) => Matrix4;
				makeRotationZ: (theta: number) => Matrix4;
				makeRotationAxis: (axis: Vector3, angle: number) => Matrix4;
				makeScale: (x: number, y: number, z: number) => Matrix4;
				makeShear: (xy: number, xz: number, yx: number, yz: number, zx: number, zy: number) => Matrix4;
				compose: (translation: Vector3, rotation: Quaternion, scale: Vector3) => Matrix4;
				decompose: (translation: Vector3, rotation: Quaternion, scale: Vector3) => Matrix4;
				makePerspective: {
					(left: number, right: number, bottom: number, top: number, near: number, far: number): Matrix4;
					(fov: number, aspect: number, near: number, far: number): Matrix4;
				};
				makeOrthographic: (left: number, right: number, top: number, bottom: number, near: number, far: number) => Matrix4;
				equals: (matrix: Matrix4) => boolean;
				fromArray: (array: number[] | ArrayLike<number>, offset?: number | undefined) => Matrix4;
				toArray: {
					(array?: number[] | undefined, offset?: number | undefined): number[];
					(array?: Matrix4Tuple | undefined, offset?: 0 | undefined): Matrix4Tuple;
					(array?: ArrayLike<number> | undefined, offset?: number | undefined): ArrayLike<number>;
				};
				setFromMatrix3: (m: Matrix3) => Matrix4;
				extractPosition: (m: Matrix4) => Matrix4;
				setRotationFromQuaternion: (q: Quaternion) => Matrix4;
				multiplyVector3: (v: any) => any;
				multiplyVector4: (v: any) => any;
				multiplyVector3Array: (array: number[]) => number[];
				rotateAxis: (v: any) => void;
				crossVector: (v: any) => void;
				flattenToArrayOffset: (array: number[], offset: number) => number[];
				getInverse: (matrix: Matrix) => Matrix;
			};
			matrixAutoUpdate: boolean;
			matrixWorldAutoUpdate: boolean;
			matrixWorldNeedsUpdate: boolean;
			visible: boolean;
			castShadow: boolean;
			receiveShadow: boolean;
			frustumCulled: boolean;
			renderOrder: number;
			animations: {
				name: string;
				tracks: {
					name: string;
					times: {
						[x: number]: number;
						readonly BYTES_PER_ELEMENT: number;
						readonly buffer: {
							readonly byteLength: number;
							slice: (begin: number, end?: number | undefined) => ArrayBuffer;
							readonly [Symbol.toStringTag]: string;
						} | {
							readonly byteLength: number;
							slice: (begin: number, end?: number | undefined) => SharedArrayBuffer;
							readonly [Symbol.species]: SharedArrayBuffer;
							readonly [Symbol.toStringTag]: "SharedArrayBuffer";
						};
						readonly byteLength: number;
						readonly byteOffset: number;
						copyWithin: (target: number, start: number, end?: number | undefined) => Float32Array;
						every: (predicate: (value: number, index: number, array: Float32Array) => unknown, thisArg?: any) => boolean;
						fill: (value: number, start?: number | undefined, end?: number | undefined) => Float32Array;
						filter: (predicate: (value: number, index: number, array: Float32Array) => any, thisArg?: any) => Float32Array;
						find: (predicate: (value: number, index: number, obj: Float32Array) => boolean, thisArg?: any) => number | undefined;
						findIndex: (predicate: (value: number, index: number, obj: Float32Array) => boolean, thisArg?: any) => number;
						forEach: (callbackfn: (value: number, index: number, array: Float32Array) => void, thisArg?: any) => void;
						indexOf: (searchElement: number, fromIndex?: number | undefined) => number;
						join: (separator?: string | undefined) => string;
						lastIndexOf: (searchElement: number, fromIndex?: number | undefined) => number;
						readonly length: number;
						map: (callbackfn: (value: number, index: number, array: Float32Array) => number, thisArg?: any) => Float32Array;
						reduce: {
							(callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number): number;
							(callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number, initialValue: number): number;
							<U>(callbackfn: (previousValue: U, currentValue: number, currentIndex: number, array: Float32Array) => U, initialValue: U): U;
						};
						reduceRight: {
							(callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number): number;
							(callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number, initialValue: number): number;
							<U_1>(callbackfn: (previousValue: U_1, currentValue: number, currentIndex: number, array: Float32Array) => U_1, initialValue: U_1): U_1;
						};
						reverse: () => Float32Array;
						set: (array: ArrayLike<number>, offset?: number | undefined) => void;
						slice: (start?: number | undefined, end?: number | undefined) => Float32Array;
						some: (predicate: (value: number, index: number, array: Float32Array) => unknown, thisArg?: any) => boolean;
						sort: (compareFn?: ((a: number, b: number) => number) | undefined) => Float32Array;
						subarray: (begin?: number | undefined, end?: number | undefined) => Float32Array;
						toLocaleString: () => string;
						toString: () => string;
						valueOf: () => Float32Array;
						entries: () => IterableIterator<[
							number,
							number
						]>;
						keys: () => IterableIterator<number>;
						values: () => IterableIterator<number>;
						includes: (searchElement: number, fromIndex?: number | undefined) => boolean;
						[Symbol.iterator]: () => IterableIterator<number>;
						readonly [Symbol.toStringTag]: "Float32Array";
						at: (index: number) => number | undefined;
					};
					values: {
						[x: number]: number;
						readonly BYTES_PER_ELEMENT: number;
						readonly buffer: {
							readonly byteLength: number;
							slice: (begin: number, end?: number | undefined) => ArrayBuffer;
							readonly [Symbol.toStringTag]: string;
						} | {
							readonly byteLength: number;
							slice: (begin: number, end?: number | undefined) => SharedArrayBuffer;
							readonly [Symbol.species]: SharedArrayBuffer;
							readonly [Symbol.toStringTag]: "SharedArrayBuffer";
						};
						readonly byteLength: number;
						readonly byteOffset: number;
						copyWithin: (target: number, start: number, end?: number | undefined) => Float32Array;
						every: (predicate: (value: number, index: number, array: Float32Array) => unknown, thisArg?: any) => boolean;
						fill: (value: number, start?: number | undefined, end?: number | undefined) => Float32Array;
						filter: (predicate: (value: number, index: number, array: Float32Array) => any, thisArg?: any) => Float32Array;
						find: (predicate: (value: number, index: number, obj: Float32Array) => boolean, thisArg?: any) => number | undefined;
						findIndex: (predicate: (value: number, index: number, obj: Float32Array) => boolean, thisArg?: any) => number;
						forEach: (callbackfn: (value: number, index: number, array: Float32Array) => void, thisArg?: any) => void;
						indexOf: (searchElement: number, fromIndex?: number | undefined) => number;
						join: (separator?: string | undefined) => string;
						lastIndexOf: (searchElement: number, fromIndex?: number | undefined) => number;
						readonly length: number;
						map: (callbackfn: (value: number, index: number, array: Float32Array) => number, thisArg?: any) => Float32Array;
						reduce: {
							(callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number): number;
							(callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number, initialValue: number): number;
							<U>(callbackfn: (previousValue: U, currentValue: number, currentIndex: number, array: Float32Array) => U, initialValue: U): U;
						};
						reduceRight: {
							(callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number): number;
							(callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number, initialValue: number): number;
							<U_1>(callbackfn: (previousValue: U_1, currentValue: number, currentIndex: number, array: Float32Array) => U_1, initialValue: U_1): U_1;
						};
						reverse: () => Float32Array;
						set: (array: ArrayLike<number>, offset?: number | undefined) => void;
						slice: (start?: number | undefined, end?: number | undefined) => Float32Array;
						some: (predicate: (value: number, index: number, array: Float32Array) => unknown, thisArg?: any) => boolean;
						sort: (compareFn?: ((a: number, b: number) => number) | undefined) => Float32Array;
						subarray: (begin?: number | undefined, end?: number | undefined) => Float32Array;
						toLocaleString: () => string;
						toString: () => string;
						valueOf: () => Float32Array;
						entries: () => IterableIterator<[
							number,
							number
						]>;
						keys: () => IterableIterator<number>;
						values: () => IterableIterator<number>;
						includes: (searchElement: number, fromIndex?: number | undefined) => boolean;
						[Symbol.iterator]: () => IterableIterator<number>;
						readonly [Symbol.toStringTag]: "Float32Array";
						at: (index: number) => number | undefined;
					};
					ValueTypeName: string;
					TimeBufferType: {
						[x: number]: number;
						readonly BYTES_PER_ELEMENT: number;
						readonly buffer: {
							readonly byteLength: number;
							slice: (begin: number, end?: number | undefined) => ArrayBuffer;
							readonly [Symbol.toStringTag]: string;
						} | {
							readonly byteLength: number;
							slice: (begin: number, end?: number | undefined) => SharedArrayBuffer;
							readonly [Symbol.species]: SharedArrayBuffer;
							readonly [Symbol.toStringTag]: "SharedArrayBuffer";
						};
						readonly byteLength: number;
						readonly byteOffset: number;
						copyWithin: (target: number, start: number, end?: number | undefined) => Float32Array;
						every: (predicate: (value: number, index: number, array: Float32Array) => unknown, thisArg?: any) => boolean;
						fill: (value: number, start?: number | undefined, end?: number | undefined) => Float32Array;
						filter: (predicate: (value: number, index: number, array: Float32Array) => any, thisArg?: any) => Float32Array;
						find: (predicate: (value: number, index: number, obj: Float32Array) => boolean, thisArg?: any) => number | undefined;
						findIndex: (predicate: (value: number, index: number, obj: Float32Array) => boolean, thisArg?: any) => number;
						forEach: (callbackfn: (value: number, index: number, array: Float32Array) => void, thisArg?: any) => void;
						indexOf: (searchElement: number, fromIndex?: number | undefined) => number;
						join: (separator?: string | undefined) => string;
						lastIndexOf: (searchElement: number, fromIndex?: number | undefined) => number;
						readonly length: number;
						map: (callbackfn: (value: number, index: number, array: Float32Array) => number, thisArg?: any) => Float32Array;
						reduce: {
							(callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number): number;
							(callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number, initialValue: number): number;
							<U>(callbackfn: (previousValue: U, currentValue: number, currentIndex: number, array: Float32Array) => U, initialValue: U): U;
						};
						reduceRight: {
							(callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number): number;
							(callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number, initialValue: number): number;
							<U_1>(callbackfn: (previousValue: U_1, currentValue: number, currentIndex: number, array: Float32Array) => U_1, initialValue: U_1): U_1;
						};
						reverse: () => Float32Array;
						set: (array: ArrayLike<number>, offset?: number | undefined) => void;
						slice: (start?: number | undefined, end?: number | undefined) => Float32Array;
						some: (predicate: (value: number, index: number, array: Float32Array) => unknown, thisArg?: any) => boolean;
						sort: (compareFn?: ((a: number, b: number) => number) | undefined) => Float32Array;
						subarray: (begin?: number | undefined, end?: number | undefined) => Float32Array;
						toLocaleString: () => string;
						toString: () => string;
						valueOf: () => Float32Array;
						entries: () => IterableIterator<[
							number,
							number
						]>;
						keys: () => IterableIterator<number>;
						values: () => IterableIterator<number>;
						includes: (searchElement: number, fromIndex?: number | undefined) => boolean;
						[Symbol.iterator]: () => IterableIterator<number>;
						readonly [Symbol.toStringTag]: "Float32Array";
						at: (index: number) => number | undefined;
					};
					ValueBufferType: {
						[x: number]: number;
						readonly BYTES_PER_ELEMENT: number;
						readonly buffer: {
							readonly byteLength: number;
							slice: (begin: number, end?: number | undefined) => ArrayBuffer;
							readonly [Symbol.toStringTag]: string;
						} | {
							readonly byteLength: number;
							slice: (begin: number, end?: number | undefined) => SharedArrayBuffer;
							readonly [Symbol.species]: SharedArrayBuffer;
							readonly [Symbol.toStringTag]: "SharedArrayBuffer";
						};
						readonly byteLength: number;
						readonly byteOffset: number;
						copyWithin: (target: number, start: number, end?: number | undefined) => Float32Array;
						every: (predicate: (value: number, index: number, array: Float32Array) => unknown, thisArg?: any) => boolean;
						fill: (value: number, start?: number | undefined, end?: number | undefined) => Float32Array;
						filter: (predicate: (value: number, index: number, array: Float32Array) => any, thisArg?: any) => Float32Array;
						find: (predicate: (value: number, index: number, obj: Float32Array) => boolean, thisArg?: any) => number | undefined;
						findIndex: (predicate: (value: number, index: number, obj: Float32Array) => boolean, thisArg?: any) => number;
						forEach: (callbackfn: (value: number, index: number, array: Float32Array) => void, thisArg?: any) => void;
						indexOf: (searchElement: number, fromIndex?: number | undefined) => number;
						join: (separator?: string | undefined) => string;
						lastIndexOf: (searchElement: number, fromIndex?: number | undefined) => number;
						readonly length: number;
						map: (callbackfn: (value: number, index: number, array: Float32Array) => number, thisArg?: any) => Float32Array;
						reduce: {
							(callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number): number;
							(callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number, initialValue: number): number;
							<U>(callbackfn: (previousValue: U, currentValue: number, currentIndex: number, array: Float32Array) => U, initialValue: U): U;
						};
						reduceRight: {
							(callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number): number;
							(callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number, initialValue: number): number;
							<U_1>(callbackfn: (previousValue: U_1, currentValue: number, currentIndex: number, array: Float32Array) => U_1, initialValue: U_1): U_1;
						};
						reverse: () => Float32Array;
						set: (array: ArrayLike<number>, offset?: number | undefined) => void;
						slice: (start?: number | undefined, end?: number | undefined) => Float32Array;
						some: (predicate: (value: number, index: number, array: Float32Array) => unknown, thisArg?: any) => boolean;
						sort: (compareFn?: ((a: number, b: number) => number) | undefined) => Float32Array;
						subarray: (begin?: number | undefined, end?: number | undefined) => Float32Array;
						toLocaleString: () => string;
						toString: () => string;
						valueOf: () => Float32Array;
						entries: () => IterableIterator<[
							number,
							number
						]>;
						keys: () => IterableIterator<number>;
						values: () => IterableIterator<number>;
						includes: (searchElement: number, fromIndex?: number | undefined) => boolean;
						[Symbol.iterator]: () => IterableIterator<number>;
						readonly [Symbol.toStringTag]: "Float32Array";
						at: (index: number) => number | undefined;
					};
					DefaultInterpolation: InterpolationModes;
					InterpolantFactoryMethodDiscrete: (result: any) => DiscreteInterpolant;
					InterpolantFactoryMethodLinear: (result: any) => LinearInterpolant;
					InterpolantFactoryMethodSmooth: (result: any) => CubicInterpolant;
					setInterpolation: (interpolation: InterpolationModes) => KeyframeTrack;
					getInterpolation: () => InterpolationModes;
					createInterpolant: () => Interpolant;
					getValueSize: () => number;
					shift: (timeOffset: number) => KeyframeTrack;
					scale: (timeScale: number) => KeyframeTrack;
					trim: (startTime: number, endTime: number) => KeyframeTrack;
					validate: () => boolean;
					optimize: () => KeyframeTrack;
					clone: () => KeyframeTrack;
				}[];
				blendMode: AnimationBlendMode;
				duration: number;
				uuid: string;
				results: any[];
				resetDuration: () => AnimationClip;
				trim: () => AnimationClip;
				validate: () => boolean;
				optimize: () => AnimationClip;
				clone: () => AnimationClip;
				toJSON: (clip: AnimationClip) => any;
			}[];
			userData: {
				[key: string]: any;
			};
			customDepthMaterial?: {
				alphaTest: number;
				alphaToCoverage: boolean;
				blendDst: BlendingDstFactor;
				blendDstAlpha: number | null;
				blendEquation: BlendingEquation;
				blendEquationAlpha: number | null;
				blending: Blending;
				blendSrc: 210 | BlendingDstFactor;
				blendSrcAlpha: number | null;
				clipIntersection: boolean;
				clippingPlanes: any;
				clipShadows: boolean;
				colorWrite: boolean;
				defines: {
					[key: string]: any;
				} | undefined;
				depthFunc: DepthModes;
				depthTest: boolean;
				depthWrite: boolean;
				id: number;
				stencilWrite: boolean;
				stencilFunc: StencilFunc;
				stencilRef: number;
				stencilWriteMask: number;
				stencilFuncMask: number;
				stencilFail: StencilOp;
				stencilZFail: StencilOp;
				stencilZPass: StencilOp;
				readonly isMaterial: true;
				name: string;
				needsUpdate: boolean;
				opacity: number;
				polygonOffset: boolean;
				polygonOffsetFactor: number;
				polygonOffsetUnits: number;
				precision: "highp" | "mediump" | "lowp" | null;
				premultipliedAlpha: boolean;
				forceSinglePass: boolean;
				dithering: boolean;
				side: Side;
				shadowSide: Side | null;
				toneMapped: boolean;
				transparent: boolean;
				type: string;
				uuid: string;
				vertexColors: boolean;
				visible: boolean;
				userData: any;
				version: number;
				clone: () => Material;
				copy: (material: Material) => Material;
				dispose: () => void;
				onBeforeCompile: (shader: Shader, renderer: WebGLRenderer) => void;
				customProgramCacheKey: () => string;
				setValues: (values: MaterialParameters) => void;
				toJSON: (meta?: any) => any;
				addEventListener: <T extends string>(type: T, listener: EventListener<Event, T, Material>) => void;
				hasEventListener: <T_1 extends string>(type: T_1, listener: EventListener<Event, T_1, Material>) => boolean;
				removeEventListener: <T_2 extends string>(type: T_2, listener: EventListener<Event, T_2, Material>) => void;
				dispatchEvent: (event: Event) => void;
			} | undefined;
			customDistanceMaterial?: {
				alphaTest: number;
				alphaToCoverage: boolean;
				blendDst: BlendingDstFactor;
				blendDstAlpha: number | null;
				blendEquation: BlendingEquation;
				blendEquationAlpha: number | null;
				blending: Blending;
				blendSrc: 210 | BlendingDstFactor;
				blendSrcAlpha: number | null;
				clipIntersection: boolean;
				clippingPlanes: any;
				clipShadows: boolean;
				colorWrite: boolean;
				defines: {
					[key: string]: any;
				} | undefined;
				depthFunc: DepthModes;
				depthTest: boolean;
				depthWrite: boolean;
				id: number;
				stencilWrite: boolean;
				stencilFunc: StencilFunc;
				stencilRef: number;
				stencilWriteMask: number;
				stencilFuncMask: number;
				stencilFail: StencilOp;
				stencilZFail: StencilOp;
				stencilZPass: StencilOp;
				readonly isMaterial: true;
				name: string;
				needsUpdate: boolean;
				opacity: number;
				polygonOffset: boolean;
				polygonOffsetFactor: number;
				polygonOffsetUnits: number;
				precision: "highp" | "mediump" | "lowp" | null;
				premultipliedAlpha: boolean;
				forceSinglePass: boolean;
				dithering: boolean;
				side: Side;
				shadowSide: Side | null;
				toneMapped: boolean;
				transparent: boolean;
				type: string;
				uuid: string;
				vertexColors: boolean;
				visible: boolean;
				userData: any;
				version: number;
				clone: () => Material;
				copy: (material: Material) => Material;
				dispose: () => void;
				onBeforeCompile: (shader: Shader, renderer: WebGLRenderer) => void;
				customProgramCacheKey: () => string;
				setValues: (values: MaterialParameters) => void;
				toJSON: (meta?: any) => any;
				addEventListener: <T extends string>(type: T, listener: EventListener<Event, T, Material>) => void;
				hasEventListener: <T_1 extends string>(type: T_1, listener: EventListener<Event, T_1, Material>) => boolean;
				removeEventListener: <T_2 extends string>(type: T_2, listener: EventListener<Event, T_2, Material>) => void;
				dispatchEvent: (event: Event) => void;
			} | undefined;
			onBeforeRender: (renderer: WebGLRenderer, scene: Scene, camera: Camera, geometry: BufferGeometry<NormalBufferAttributes>, material: Material, group: Group) => void;
			onAfterRender: (renderer: WebGLRenderer, scene: Scene, camera: Camera, geometry: BufferGeometry<NormalBufferAttributes>, material: Material, group: Group) => void;
			applyMatrix4: (matrix: Matrix4) => void;
			applyQuaternion: (quaternion: Quaternion) => Camera;
			setRotationFromAxisAngle: (axis: Vector3, angle: number) => void;
			setRotationFromEuler: (euler: Euler) => void;
			setRotationFromMatrix: (m: Matrix4) => void;
			setRotationFromQuaternion: (q: Quaternion) => void;
			rotateOnAxis: (axis: Vector3, angle: number) => Camera;
			rotateOnWorldAxis: (axis: Vector3, angle: number) => Camera;
			rotateX: (angle: number) => Camera;
			rotateY: (angle: number) => Camera;
			rotateZ: (angle: number) => Camera;
			translateOnAxis: (axis: Vector3, distance: number) => Camera;
			translateX: (distance: number) => Camera;
			translateY: (distance: number) => Camera;
			translateZ: (distance: number) => Camera;
			localToWorld: (vector: Vector3) => Vector3;
			worldToLocal: (vector: Vector3) => Vector3;
			lookAt: {
				(vector: Vector3): void;
				(x: number, y: number, z: number): void;
			};
			add: (...object: Object3D<Event>[]) => Camera;
			remove: (...object: Object3D<Event>[]) => Camera;
			removeFromParent: () => Camera;
			clear: () => Camera;
			attach: (object: Object3D<Event>) => Camera;
			getObjectById: (id: number) => Object3D<Event> | undefined;
			getObjectByName: (name: string) => Object3D<Event> | undefined;
			getObjectByProperty: (name: string, value: any) => Object3D<Event> | undefined;
			getObjectsByProperty: (name: string, value: any) => Object3D<Event>[];
			getWorldPosition: (target: Vector3) => Vector3;
			getWorldQuaternion: (target: Quaternion) => Quaternion;
			getWorldScale: (target: Vector3) => Vector3;
			raycast: (raycaster: Raycaster, intersects: Intersection<Object3D<Event>>[]) => void;
			traverse: (callback: (object: Object3D<Event>) => any) => void;
			traverseVisible: (callback: (object: Object3D<Event>) => any) => void;
			traverseAncestors: (callback: (object: Object3D<Event>) => any) => void;
			updateMatrix: () => void;
			updateMatrixWorld: (force?: boolean | undefined) => void;
			updateWorldMatrix: (updateParents: boolean, updateChildren: boolean) => void;
			toJSON: (meta?: {
				geometries: any;
				materials: any;
				textures: any;
				images: any;
			} | undefined) => any;
			clone: (recursive?: boolean | undefined) => Camera;
			copy: (source: Camera, recursive?: boolean | undefined) => Camera;
			addEventListener: <T_6 extends string>(type: T_6, listener: EventListener<Event, T_6, Camera>) => void;
			hasEventListener: <T_7 extends string>(type: T_7, listener: EventListener<Event, T_7, Camera>) => boolean;
			removeEventListener: <T_8 extends string>(type: T_8, listener: EventListener<Event, T_8, Camera>) => void;
			dispatchEvent: (event: Event) => void;
		};
		layers: {
			mask: number;
			set: (layer: number) => void;
			enable: (layer: number) => void;
			enableAll: () => void;
			toggle: (layer: number) => void;
			disable: (layer: number) => void;
			disableAll: () => void;
			test: (layers: Layers) => boolean;
			isEnabled: (layer: number) => boolean;
		};
		params: {
			Mesh?: any;
			Line?: {
				threshold: number;
			} | undefined;
			Line2?: {
				threshold: number;
			} | undefined;
			LOD?: any;
			Points?: {
				threshold: number;
			} | undefined;
			Sprite?: any;
		};
		set: (origin: Vector3, direction: Vector3) => void;
		setFromCamera: (coords: Vector2, camera: Camera) => void;
		intersectObject: <TIntersected extends Object3D<Event>>(object: Object3D<Event>, recursive?: boolean | undefined, optionalTarget?: Intersection<TIntersected>[] | undefined) => Intersection<TIntersected>[];
		intersectObjects: <TIntersected_1 extends Object3D<Event>>(objects: Object3D<Event>[], recursive?: boolean | undefined, optionalTarget?: Intersection<TIntersected_1>[] | undefined) => Intersection<TIntersected_1>[];
		firstHitOnly?: boolean | undefined;
	}>;
	cursor(): import("@vue/reactivity").Ref<{
		x: number;
		y: number;
		width: number;
		height: number;
		readonly isVector2: true;
		set: (x: number, y: number) => Vector2;
		setScalar: (scalar: number) => Vector2;
		setX: (x: number) => Vector2;
		setY: (y: number) => Vector2;
		setComponent: (index: number, value: number) => Vector2;
		getComponent: (index: number) => number;
		clone: () => Vector2;
		copy: (v: Vector2) => Vector2;
		add: (v: Vector2, w?: Vector2 | undefined) => Vector2;
		addScalar: (s: number) => Vector2;
		addVectors: (a: Vector2, b: Vector2) => Vector2;
		addScaledVector: (v: Vector2, s: number) => Vector2;
		sub: (v: Vector2) => Vector2;
		subScalar: (s: number) => Vector2;
		subVectors: (a: Vector2, b: Vector2) => Vector2;
		multiply: (v: Vector2) => Vector2;
		multiplyScalar: (scalar: number) => Vector2;
		divide: (v: Vector2) => Vector2;
		divideScalar: (s: number) => Vector2;
		applyMatrix3: (m: Matrix3) => Vector2;
		min: (v: Vector2) => Vector2;
		max: (v: Vector2) => Vector2;
		clamp: (min: Vector2, max: Vector2) => Vector2;
		clampScalar: (min: number, max: number) => Vector2;
		clampLength: (min: number, max: number) => Vector2;
		floor: () => Vector2;
		ceil: () => Vector2;
		round: () => Vector2;
		roundToZero: () => Vector2;
		negate: () => Vector2;
		dot: (v: Vector2) => number;
		cross: (v: Vector2) => number;
		lengthSq: () => number;
		length: () => number;
		lengthManhattan: () => number;
		manhattanLength: () => number;
		normalize: () => Vector2;
		angle: () => number;
		angleTo: (v: Vector2) => number;
		distanceTo: (v: Vector2) => number;
		distanceToSquared: (v: Vector2) => number;
		distanceToManhattan: (v: Vector2) => number;
		manhattanDistanceTo: (v: Vector2) => number;
		setLength: (length: number) => Vector2;
		lerp: (v: Vector2, alpha: number) => Vector2;
		lerpVectors: (v1: Vector2, v2: Vector2, alpha: number) => Vector2;
		equals: (v: Vector2) => boolean;
		fromArray: (array: number[] | ArrayLike<number>, offset?: number | undefined) => Vector2;
		toArray: {
			(array?: number[] | undefined, offset?: number | undefined): number[];
			(array?: Vector2Tuple | undefined, offset?: 0 | undefined): Vector2Tuple;
			(array: ArrayLike<number>, offset?: number | undefined): ArrayLike<number>;
		};
		fromBufferAttribute: (attribute: BufferAttribute, index: number) => Vector2;
		rotateAround: (center: Vector2, angle: number) => Vector2;
		random: () => Vector2;
	}>;
	updateRaycast(options: RaycasterUpdateOptions): void;
}
declare class WindowEventsController extends BaseSceneEventsController<Event, PointerEventNode> {
	protected _requireCanvasEventListeners: boolean;
	type(): string;
	acceptedEventTypes(): Set<string>;
}
declare class TouchEventsController extends BaseSceneEventsController<MouseEvent, PointerEventNode> {
	protected _requireCanvasEventListeners: boolean;
	type(): string;
	acceptedEventTypes(): Set<TouchEventType>;
}
declare enum GlConnectionPointType {
	BOOL = "bool",
	INT = "int",
	FLOAT = "float",
	MAT3 = "mat3",
	MAT4 = "mat4",
	VEC2 = "vec2",
	VEC3 = "vec3",
	VEC4 = "vec4",
	SAMPLER_2D = "sampler2D",
	SAMPLER_2D_ARRAY = "sampler2DArray",
	SAMPLER_3D = "sampler3D",
	SAMPLER_CUBE = "samplerCube",
	SSS_MODEL = "SSSModel",
	SDF_CONTEXT = "SDFContext",
	SDF_MATERIAL = "SDFMaterial"
}
type GlConnectionPointTypeToParamTypeMapGeneric = {
	[key in GlConnectionPointType]: ParamType;
};
interface GlIConnectionPointTypeToParamTypeMap extends GlConnectionPointTypeToParamTypeMapGeneric {
	[GlConnectionPointType.BOOL]: ParamType.BOOLEAN;
	[GlConnectionPointType.INT]: ParamType.INTEGER;
	[GlConnectionPointType.FLOAT]: ParamType.FLOAT;
	[GlConnectionPointType.VEC2]: ParamType.VECTOR2;
	[GlConnectionPointType.VEC3]: ParamType.VECTOR3;
	[GlConnectionPointType.VEC4]: ParamType.VECTOR4;
	[GlConnectionPointType.MAT3]: ParamType.BUTTON;
	[GlConnectionPointType.MAT4]: ParamType.BUTTON;
}
type GlConnectionPointInitValueMapGeneric = {
	[key in GlConnectionPointType]: ParamInitValuesTypeMap[GlIConnectionPointTypeToParamTypeMap[key]];
};
interface GlConnectionPointData<T extends GlConnectionPointType> {
	name: string;
	type: T;
	isArray?: boolean;
}
declare class GlConnectionPoint<T extends GlConnectionPointType> extends BaseConnectionPoint {
	protected _name: string;
	protected _type: T;
	protected _init_value?: GlConnectionPointInitValueMapGeneric[T] | undefined;
	protected _json: GlConnectionPointData<T> | undefined;
	constructor(_name: string, _type: T, _init_value?: GlConnectionPointInitValueMapGeneric[T] | undefined);
	type(): T;
	are_types_matched(src_type: string, dest_type: string): boolean;
	get param_type(): GlIConnectionPointTypeToParamTypeMap[T];
	get init_value(): GlConnectionPointInitValueMapGeneric[T] | undefined;
	toJSON(): GlConnectionPointData<T>;
	protected _createJSON(): GlConnectionPointData<T>;
}
type BaseGlConnectionPoint = GlConnectionPoint<GlConnectionPointType>;
declare enum EventConnectionPointType {
	BASE = "base",
	DRAG = "drag",
	KEYBOARD = "keyboard",
	MOUSE = "mouse",
	POINTER = "pointer"
}
interface EventConnectionPointData<T extends EventConnectionPointType> {
	name: string;
	type: T;
	isArray?: boolean;
}
declare class EventConnectionPoint<T extends EventConnectionPointType> extends BaseConnectionPoint {
	protected _name: string;
	protected _type: T;
	protected _event_listener?: ((event_context: EventContext<any>) => void) | undefined;
	protected _json: EventConnectionPointData<T> | undefined;
	constructor(_name: string, _type: T, // protected _init_value?: ConnectionPointInitValueMapGeneric[T]
	_event_listener?: ((event_context: EventContext<any>) => void) | undefined);
	type(): T;
	get param_type(): ParamType;
	are_types_matched(src_type: string, dest_type: string): boolean;
	get event_listener(): ((event_context: EventContext<any>) => void) | undefined;
	toJSON(): EventConnectionPointData<T>;
	protected _createJSON(): EventConnectionPointData<T>;
}
type BaseEventConnectionPoint = EventConnectionPoint<EventConnectionPointType>;
type ConnectionPointTypeMapGeneric = {
	[key in NodeContext]: BaseEventConnectionPoint | BaseGlConnectionPoint | BaseJsConnectionPoint | undefined;
};
interface ConnectionPointTypeMap extends ConnectionPointTypeMapGeneric {
	[NodeContext.ANIM]: undefined;
	[NodeContext.AUDIO]: undefined;
	[NodeContext.COP]: undefined;
	[NodeContext.EVENT]: BaseEventConnectionPoint;
	[NodeContext.GL]: BaseGlConnectionPoint;
	[NodeContext.JS]: BaseJsConnectionPoint;
	[NodeContext.MANAGER]: undefined;
	[NodeContext.MAT]: undefined;
	[NodeContext.OBJ]: undefined;
	[NodeContext.POST]: undefined;
	[NodeContext.ROP]: undefined;
	[NodeContext.SOP]: undefined;
}
type ConnectionPointEnumMapGeneric = {
	[key in NodeContext]: EventConnectionPointType | GlConnectionPointType | JsConnectionPointType | undefined;
};
interface ConnectionPointEnumMap extends ConnectionPointEnumMapGeneric {
	[NodeContext.ANIM]: undefined;
	[NodeContext.AUDIO]: undefined;
	[NodeContext.COP]: undefined;
	[NodeContext.EVENT]: EventConnectionPointType;
	[NodeContext.GL]: GlConnectionPointType;
	[NodeContext.JS]: JsConnectionPointType;
	[NodeContext.MANAGER]: undefined;
	[NodeContext.MAT]: undefined;
	[NodeContext.OBJ]: undefined;
	[NodeContext.POST]: undefined;
	[NodeContext.ROP]: undefined;
	[NodeContext.SOP]: undefined;
}
interface DisconnectionOptions {
	setInput?: boolean;
	ignoreLockedState?: boolean;
}
declare class TypedNodeConnection<NC extends NodeContext> {
	private _nodeSrc;
	private _nodeDest;
	private _outputIndex;
	private _inputIndex;
	private static _nextId;
	private _id;
	constructor(_nodeSrc: TypedNode<NC, any>, _nodeDest: TypedNode<NC, any>, _outputIndex?: number, _inputIndex?: number);
	id(): number;
	nodeSrc(): BaseNodeByContextMap[NC];
	nodeDest(): BaseNodeByContextMap[NC];
	outputIndex(): number;
	inputIndex(): number;
	srcConnectionPoint(): ConnectionPointTypeMap[NC] | undefined;
	destConnectionPoint(): ConnectionPointTypeMap[NC] | undefined;
	disconnect(options?: DisconnectionOptions): void;
	private __eventDispatcher;
	_eventDispatcher(): EventDispatcher<Event> | undefined;
	eventDispatcher(): EventDispatcher<Event>;
}
declare class SceneConnectionTriggerDispatcher {
	constructor();
	dispatchTrigger<NC extends NodeContext>(connection: TypedNodeConnection<NC>): void;
}
declare class SceneEventsDispatcher {
	scene: PolyScene;
	readonly sceneEventsController: SceneEventsController;
	private _keyboardEventsController?;
	private _mouseEventsController?;
	private _dragEventsController?;
	private _pointerEventsController?;
	private _windowEventsController?;
	private _touchEventsController?;
	private _controllers;
	constructor(scene: PolyScene);
	registerEvaluatorGenerator(evaluatorGenerator: ActorEvaluatorGenerator): void;
	unregisterEvaluatorGenerator(evaluatorGenerator: ActorEvaluatorGenerator): void;
	registerEventNode(node: BaseInputEventNodeType): void;
	unregisterEventNode(node: BaseInputEventNodeType): void;
	updateViewerEventListeners(node: BaseInputEventNodeType): void;
	traverseControllers(callback: (controller: BaseSceneEventsController<Event, BaseInputEventNodeType>) => void): void;
	setRaycaster(raycaster: Raycaster): void;
	private _findOrCreateControllerForEventNode;
	private _findOrCreateControllerForEvaluator;
	private _findOrCreateControllerForEventInputType;
	private _findOrCreateControllerForJsType;
	get keyboardEventsController(): KeyboardEventsController;
	get mouseEventsController(): MouseEventsController;
	get dragEventsController(): DragEventsController;
	get pointerEventsController(): PointerEventsController;
	get windowEventsController(): WindowEventsController;
	get touchEventsController(): TouchEventsController;
	private _createController;
	private _connectionTriggerDispatcher;
	get connectionTriggerDispatcher(): SceneConnectionTriggerDispatcher;
}
interface CameraControls {
	name?: string;
	enabled?: boolean;
	dispose: () => void;
	update: (delta: number) => void;
	addEventListener: (eventName: string, callback: () => void) => void;
	removeEventListener: (eventName: string, callback: () => void) => void;
}
declare abstract class TypedCameraControlsEventNode<K extends NodeParamsConfig> extends TypedEventNode<K> {
	private _controls_by_viewer;
	applyControls(camera: Camera, viewer: BaseViewerType): Promise<CameraControls | undefined>;
	controls_id(): string;
	abstract updateRequired(): boolean;
	cook(): void;
	abstract setupControls(controls: CameraControls): void;
	abstract disposeControlsForHtmlElementId(html_element_id: string): void;
	abstract createControlsInstance(camera: Camera, element: HTMLElement): Promise<CameraControls>;
	abstract endEventName(): string;
}
type GetTargetFunction = (target: Vector3) => void;
type SetTargetFunction = (target: Vector3) => void;
interface ApplicableControlsNode {
	type(): string;
	applyControls: (camera: Camera, viewer: BaseViewerType) => Promise<CameraControls>;
	target?: GetTargetFunction;
	setTarget?: SetTargetFunction;
}
declare class ViewerCamerasController {
	private _viewer;
	private _size;
	private _aspect;
	constructor(_viewer: BaseViewerType);
	camera(): Camera;
	get size(): Vector2;
	get aspect(): number;
	computeSizeAndAspect(pixelRatio: number): void;
	private _updateSize;
	private _getAspect;
	updateCameraAspect(): void;
	prepareCurrentCamera(): Promise<void>;
	_updateFromCameraContainer(): Promise<void>;
}
declare class ViewerControlsController<C extends Camera> {
	private viewer;
	protected _active: boolean;
	private _updateControlsFunc;
	protected _controls: CameraControls | undefined;
	private _unmounted;
	constructor(viewer: TypedViewer<C>);
	controls(): CameraControls | undefined;
	mount(): void;
	unmount(): void;
	private _disposeControls;
	update(delta: number): void;
	setActive(active: boolean): void;
}
type ViewerEventListener = (e: Event) => void;
interface EventListenerWithData {
	listener: ViewerEventListener;
	data: EventData;
}
type ListenerByEventType = Map<EventType, EventListenerWithData>;
declare class ViewerEventsController {
	protected viewer: BaseViewerType;
	protected _bound_listener_map_by_event_controller_type: Map<string, ListenerByEventType>;
	constructor(viewer: BaseViewerType);
	updateEvents(eventsController: BaseSceneEventsControllerType): void;
	camera(): Camera;
	canvas(): HTMLCanvasElement;
	init(): void;
	registeredEventTypes(): string[];
	dispose(): void;
}
declare class ViewerWebGLController {
	protected viewer: BaseViewerType;
	request_animation_frame_id: number | undefined;
	constructor(viewer: BaseViewerType);
	init(): void;
	protected _on_webglcontextlost(): void;
	protected _on_webglcontextrestored(): void;
}
declare class ViewerAudioController {
	private _viewer;
	private __iconContainer;
	private _onIcon;
	private _offIcon;
	constructor(_viewer: BaseViewerType);
	update(): void;
	unmount(): void;
	private _showIcon;
	private _hideIcon;
	private _iconContainer;
	private _createIconContainer;
	private _setIconContainerStyle;
	private offIcon;
	private onIcon;
	private _toggleSound;
	private _updateIcon;
}
type AbstractRenderer = Pick<WebGLRenderer, "domElement" | "render" | "getPixelRatio" | "compile" | "dispose" | "setSize" | "setRenderTarget" | "readRenderTargetPixels" | "capabilities">;
declare class RenderersController {
	private static _nextGlContextId;
	private _printDebug;
	private _requireWebGL2;
	private _webgl2_available;
	private _webGLContextByCanvas;
	private _defaultRendererByCanvas;
	dispose(): void;
	setPrintDebug(state?: boolean): void;
	printDebug(): boolean;
	printDebugMessage(message: any): void;
	setRequireWebGL2(): void;
	webGL2Available(canvas?: HTMLCanvasElement): boolean;
	private _getWebGL2Available;
	defaultWebGLRendererForCanvas(canvas: HTMLCanvasElement): WebGLRenderer;
	createWebGLRenderer(params: WebGLRendererParameters): WebGLRenderer;
	assignIdToRenderer(renderer: AbstractRenderer): void;
	rendererId(renderer: AbstractRenderer): number | undefined;
	getRenderingContext(canvas: HTMLCanvasElement): WebGLRenderingContext | null;
	private _getRenderingContextWebgl;
	createRenderTarget(width: number, height: number, parameters: WebGLRenderTargetOptions): WebGLRenderTarget;
	private _linearRenderer;
	linearRenderer(): WebGLRenderer | undefined;
	private _createLinearRenderer;
}
declare class PolyLibsController {
	private _rootPrefix;
	private _root;
	root(): string | undefined;
	setRoot(url: string | null): void;
	setRootPrefix(prefix: string): void;
	private _KTX2Path;
	KTX2Path(): string | null;
	private _DRACOPath;
	DRACOPath(): string | null;
	private _DRACOGLTFPath;
	DRACOGLTFPath(): string | null;
	private _XATLASPath;
	XATLASPath(): string | null;
	private _OCCTPath;
	OCCTPath(): string | null;
	private _ManifoldPath;
	ManifoldPath(): string | null;
	private _WebIFCPath;
	webIFCPath(): string | null;
}
declare class BaseCoreLogger {
	log(message?: any, ...optionalParams: any[]): void;
	warn(message?: any, ...optionalParams: any[]): void;
	error(message?: any, ...optionalParams: any[]): void;
}
declare enum InputCloneMode {
	ALWAYS = "always",
	NEVER = "never",
	FROM_NODE = "from_node"
}
declare class AnimationContainer extends TypedContainer<NodeContext.ANIM> {
	set_content(content: ContainableMap[NodeContext.ANIM]): void;
	setTimelineBuilder(timeline_builder: TimelineBuilder): void;
	timelineBuilder(): TimelineBuilder;
	coreContentCloned(): TimelineBuilder | undefined;
}
declare class AudioContainer extends TypedContainer<NodeContext.AUDIO> {
	setContent(content: ContainableMap[NodeContext.AUDIO]): void;
	setAudioBuilder(audioBuilder: AudioBuilder): void;
	audioBuilder(): AudioBuilder;
	coreContentCloned(): AudioBuilder | undefined;
}
declare class EventContainer extends TypedContainer<NodeContext.EVENT> {
	set_content(content: ContainableMap[NodeContext.EVENT]): void;
}
declare class GeometryContainer extends TypedContainer<NodeContext.SOP> {
	coreContentCloned(): CoreGroup | undefined;
	set_content(content: ContainableMap[NodeContext.SOP]): void;
}
declare class GlContainer extends TypedContainer<NodeContext.GL> {
	object(): string;
}
declare class JsContainer extends TypedContainer<NodeContext.JS> {
	object(): string;
}
declare class ManagerContainer extends TypedContainer<NodeContext.MANAGER> {
	set_content(content: ContainableMap[NodeContext.MANAGER]): void;
}
declare class MaterialContainer extends TypedContainer<NodeContext.MAT> {
	set_content(content: ContainableMap[NodeContext.MAT]): void;
	coreContentCloned(): ContainableMap[NodeContext.MAT] | undefined;
	set_material(material: Material): void;
	has_material(): boolean;
	material(): Material;
}
// @ts-ignore
declare class ObjectContainer extends TypedContainer<NodeContext.OBJ> {
	set_content(content: ContainableMap[NodeContext.OBJ]): void;
	set_object(object: Object3D): void;
	has_object(): boolean;
	object(): Object3D<Event>;
}
// @ts-ignore
declare class TextureContainer extends TypedContainer<NodeContext.COP> {
	set_content(content: ContainableMap[NodeContext.COP]): void;
	texture(): ContainableMap[NodeContext.COP];
	coreContent(): ContainableMap[NodeContext.COP];
	coreContentCloned(): ContainableMap[NodeContext.COP] | undefined;
	object(): Texture;
	infos(): Texture[] | undefined;
	resolution(): Number2;
}
declare class PostProcessContainer extends TypedContainer<NodeContext.POST> {
	set_content(content: ContainableMap[NodeContext.POST]): void;
	render_pass(): number;
	object(options?: {}): number;
}
declare class RopContainer extends TypedContainer<NodeContext.ROP> {
	set_content(content: ContainableMap[NodeContext.ROP]): void;
	renderer(): any;
}
type ContainerMapGeneric = {
	[key in NodeContext]: TypedContainer<key>;
};
interface ContainerMap extends ContainerMapGeneric {
	[NodeContext.ANIM]: AnimationContainer;
	[NodeContext.AUDIO]: AudioContainer;
	[NodeContext.COP]: TextureContainer;
	[NodeContext.EVENT]: EventContainer;
	[NodeContext.GL]: GlContainer;
	[NodeContext.JS]: JsContainer;
	[NodeContext.MANAGER]: ManagerContainer;
	[NodeContext.MAT]: MaterialContainer;
	[NodeContext.OBJ]: ObjectContainer;
	[NodeContext.ROP]: RopContainer;
	[NodeContext.POST]: PostProcessContainer;
	[NodeContext.SOP]: GeometryContainer;
}
type OnUpdateHook = () => void;
type OnEvalSingleInputListen = () => Promise<void>;
interface SetInputsOptions {
	noExceptionOnInvalidInput?: boolean;
	ignoreLockedState?: boolean;
}
declare class NodeInputsController<NC extends NodeContext> {
	node: TypedNode<NC, any>;
	private _graphNode;
	private _graphNodeInputs;
	private _inputs;
	private _has_named_inputs;
	private _named_input_connection_points;
	private _minInputsCount;
	private _maxInputsCount;
	private _maxInputsCountOnInput;
	private _depends_on_inputs;
	private _on_update_hooks;
	private _on_update_hook_names;
	dispose(): void;
	constructor(node: TypedNode<NC, any>);
	setDependsOnInputs(depends_on_inputs: boolean): void;
	private setMinCount;
	minCount(): number;
	private setMaxCount;
	private _singleInputIndexListenedTo;
	listenToSingleInputIndex(index: number): void;
	private _onEnsureListenToSingleInputIndexUpdatedCallback;
	onEnsureListenToSingleInputIndexUpdated(callback: OnEvalSingleInputListen): void;
	namedInputConnectionPointsByName(name: string): ConnectionPointTypeMap[NC] | undefined;
	setNamedInputConnectionPoints(newConnectionPoints: ConnectionPointTypeMap[NC][]): void;
	hasNamedInputs(): boolean;
	namedInputConnectionPoints(): ConnectionPointTypeMap[NC][] | undefined;
	private _initGraphNodeInputs;
	private _createGraphNodeInput;
	graphNode(): CoreGraphNode;
	private _createGraphNode;
	maxInputsCount(): number;
	maxInputsCountOverriden(): boolean;
	inputGraphNode(input_index: number): CoreGraphNode;
	setCount(min: number, max?: number): void;
	private _initConnectionControllerInputs;
	isGraphNodeDirty(): boolean;
	private _isAnyInputDirty;
	containersWithoutEvaluation(target: Array<ContainerMap[NC] | null>): (ContainerMap[NC] | null)[];
	private _existingInputIndices;
	evalRequiredInputs(target: Array<ContainerMap[NC] | null | undefined>): Promise<Array<ContainerMap[NC] | null | undefined>>;
	evalRequiredInput(inputIndex: number): Promise<ContainerMap[NC] | undefined>;
	getNamedInputIndex(name: string): number;
	getInputIndex(input_index_or_name: number | string): number;
	setInput(inputIndexOrName: number | string, node: BaseNodeByContextMap[NC] | null, outputIndexOrName?: number | string, options?: Readonly<SetInputsOptions>): void;
	input(input_index: number): BaseNodeByContextMap[NC] | null;
	named_input(input_name: string): BaseNodeByContextMap[NC] | null;
	named_input_connection_point(input_name: string): ConnectionPointTypeMap[NC] | undefined;
	has_named_input(name: string): boolean;
	hasInput(input_index: number): boolean;
	inputs(): (BaseNodeByContextMap[NC] | null)[];
	private _clonedStatesController;
	initInputsClonedState(states: InputCloneMode | InputCloneMode[]): void;
	overrideClonedStateAllowed(): boolean;
	overrideClonedState(state: boolean): void;
	clonedStateOverriden(): boolean;
	cloneRequired(index: number): boolean;
	cloneRequiredStates(): boolean | boolean[];
	private _updateCloneRequiredState;
	add_on_set_input_hook(name: string, hook: OnUpdateHook): void;
	private _run_on_set_input_hooks;
}
declare class OutputsController<NC extends NodeContext> {
	private node;
	private _has_outputs;
	private _named_output_connection_points;
	private _has_named_outputs;
	private _connections;
	constructor(node: TypedNode<NC, any>);
	private _onPlayingStateChangeBound;
	private _onPlayingStateChange;
	private _outputIndexCache;
	private _clearCache;
	dispose(): void;
	setHasOneOutput(): void;
	setHasNoOutput(): void;
	hasOutputs(): boolean;
	hasNamedOutputs(): boolean;
	hasNamedOutput(name: string): boolean;
	namedOutputConnectionPoints(): Readonly<ConnectionPointTypeMap[NC][]> | undefined;
	namedOutputConnection(index: number): Readonly<ConnectionPointTypeMap[NC]> | undefined;
	getNamedOutputIndex(name: string): number;
	getOutputIndex(output_index_or_name: number | string): number;
	private _getOutputIndex;
	namedOutputConnectionPointsByName(name: string): ConnectionPointTypeMap[NC] | undefined;
	setNamedOutputConnectionPoints(connection_points: ConnectionPointTypeMap[NC][], set_dirty?: boolean): void;
	used_output_names(): string[];
}
declare class ConnectionsController<NC extends NodeContext> {
	protected _node: TypedNode<NC, any>;
	private _inputConnections;
	private _outputConnections;
	constructor(_node: TypedNode<NC, any>);
	initInputs(): void;
	dispose(): void;
	addInputConnection(connection: TypedNodeConnection<NC>): void;
	removeInputConnection(connection: TypedNodeConnection<NC>): void;
	inputConnection(index: number): TypedNodeConnection<NC> | undefined;
	firstInputConnection(): TypedNodeConnection<NC> | null;
	inputConnections(): (TypedNodeConnection<NC> | undefined)[] | undefined;
	existingInputConnections(): (TypedNodeConnection<NC> | undefined)[] | undefined;
	addOutputConnection(connection: TypedNodeConnection<NC>): void;
	removeOutputConnection(connection: TypedNodeConnection<NC>): void;
	outputConnectionsByOutputIndex(outputIndex: number): Map<number, TypedNodeConnection<NC>> | undefined;
	outputConnections(target: TypedNodeConnection<NC>[]): TypedNodeConnection<NC>[];
}
declare class SavedConnectionPointsDataController<NC extends NodeContext> {
	protected _node: TypedNode<NC, any>;
	private _in;
	private _out;
	constructor(_node: TypedNode<NC, any>);
	set_in(data: BaseConnectionPointData[]): void;
	set_out(data: BaseConnectionPointData[]): void;
	clear(): void;
	in(): BaseConnectionPointData[] | undefined;
	out(): BaseConnectionPointData[] | undefined;
}
declare class ConnectionPointsSpareParamsController<NC extends NodeContext> {
	private node;
	private _context;
	private _inputlessParamNames;
	private _raw_input_serialized_by_param_name;
	private _default_value_serialized_by_param_name;
	constructor(node: TypedNode<NC, any>, _context: NC);
	private _initialized;
	initializeNode(): void;
	initialized(): boolean;
	private _createInputsFromParams;
	setInputlessParamNames(names: string[]): string[];
	createSpareParameters(): void;
}
type IONameFunction = (index: number) => string;
type ExpectedConnectionTypesFunction<NC extends NodeContext> = () => ConnectionPointEnumMap[NC][];
declare class ConnectionPointsController<NC extends NodeContext> {
	private node;
	private _context;
	private _spare_params_controller;
	private _create_spare_params_from_inputs;
	private _functions_overridden;
	constructor(node: TypedNode<NC, any>, _context: NC);
	private _input_name_function;
	private _output_name_function;
	private _expected_input_types_function;
	private _expected_output_types_function;
	protected default_connection_type(): ConnectionPointEnumMap[NC];
	protected createConnectionPoint(name: string, type: ConnectionPointEnumMap[NC]): ConnectionPointTypeMap[NC];
	functions_overridden(): boolean;
	initialized(): boolean;
	set_create_spare_params_from_inputs(state: boolean): void;
	set_input_name_function(func: IONameFunction): void;
	set_output_name_function(func: IONameFunction): void;
	set_expected_input_types_function(func: ExpectedConnectionTypesFunction<NC>): void;
	set_expected_output_types_function(func: ExpectedConnectionTypesFunction<NC>): void;
	input_name(index: number): string;
	output_name(index: number): string;
	private _update_signature_if_required_bound;
	private _initialized;
	initializeNode(): void;
	private _initialize_if_required;
	get spare_params(): ConnectionPointsSpareParamsController<NC>;
	update_signature_if_required(): void;
	private _successorsCopy;
	private make_successors_update_signatures;
	update_connection_types(): void;
	protected _inputsOutputsMatchExpectations(): boolean;
	private _wrapped_expected_input_types_function;
	private _wrapped_expected_output_types_function;
	private _wrapped_input_name_function;
	private _wrapped_output_name_function;
	first_input_connection_type(): ConnectionPointEnumMap[NC] | undefined;
	input_connection_type(index: number): ConnectionPointEnumMap[NC] | undefined;
}
type OverridenOptions = PolyDictionary<string | number>;
type SimpleParamJsonExporterData<T extends ParamType> = ParamInitValueSerializedTypeMap[T];
interface ComplexParamJsonExporterData<T extends ParamType> {
	type?: T;
	default_value?: ParamInitValueSerializedTypeMap[T];
	raw_input?: ParamInitValueSerializedTypeMap[T];
// @ts-ignore
	options?: ParamOptions;
	overriden_options?: OverridenOptions;
}
type ParamJsonExporterData<T extends ParamType> = SimpleParamJsonExporterData<T> | ComplexParamJsonExporterData<T>;
interface ParamInitData<T extends ParamType> {
	raw_input?: ParamInitValueSerializedTypeMap[T];
	simple_data?: SimpleParamJsonExporterData<T>;
	complex_data?: ComplexParamJsonExporterData<T>;
}
type ParamsInitData = PolyDictionary<ParamInitData<ParamType>>;
declare class IOController<NC extends NodeContext> {
	protected node: TypedNode<NC, any>;
	protected _inputs: NodeInputsController<NC> | undefined;
	protected _outputs: OutputsController<NC> | undefined;
	protected _connections: ConnectionsController<NC>;
	protected _saved_connection_points_data: SavedConnectionPointsDataController<NC> | undefined;
	protected _connection_points: ConnectionPointsController<NC> | undefined;
	constructor(node: TypedNode<NC, any>);
	dispose(): void;
	get connections(): ConnectionsController<NC>;
	get inputs(): NodeInputsController<NC>;
	hasInputs(): boolean;
	get outputs(): OutputsController<NC>;
	has_outputs(): boolean;
	get connection_points(): ConnectionPointsController<NC>;
	get has_connection_points_controller(): boolean;
	get saved_connection_points_data(): SavedConnectionPointsDataController<NC>;
	clear_saved_connection_points_data(): void;
}
type DefaultOperationParam<T extends ParamType> = ParamValuesTypeMap[T];
type DefaultOperationParams = PolyDictionary<DefaultOperationParam<ParamType>>;
interface OperationRegisterOptions {
	printWarnings?: boolean;
}
interface NodeRegisterOptions {
	only?: string[];
	except?: string[];
	userAllowed?: boolean;
	polyNode?: boolean;
	printWarnings?: boolean;
}
type BaseNodeConstructor = typeof BaseNodeClass;
type NodeConstructorByType = Map<string, BaseNodeConstructor>;
type NodeConstructorByTypeByContext = Map<NodeContext, NodeConstructorByType>;
type BaseOperationConstructor = typeof BaseOperation;
type OnNodeRegisterCallback = (poly: PolyEngine) => void;
type OnOperationRegisterCallback = (poly: PolyEngine) => void;
declare class NodesRegister {
	private poly;
	private _nodesRegister;
	private _nodesRegisterCategories;
	private _nodesRegisterOptions;
	constructor(poly: PolyEngine);
	private static type;
	private static filterType;
	register(node: BaseNodeConstructor, tabMenuCategory?: string | string[], options?: NodeRegisterOptions): void;
	deregister(context: NodeContext, nodeType: string): void;
	isRegistered(context: NodeContext, nodeType: string): boolean;
	nodeOptions(context: NodeContext, nodeType: string): NodeRegisterOptions | undefined;
	registeredNodesForParentNode(parentNode: BaseNodeType): (typeof BaseNodeClass)[];
	registeredNodes(parentNode: BaseNodeType): PolyDictionary<BaseNodeConstructor>;
	registeredCategory(context: NodeContext, nodeType: string): string[] | undefined;
	map(): NodeConstructorByTypeByContext;
}
declare class OperationsRegister {
	private poly;
	private _operation_register;
	constructor(poly: PolyEngine);
	private static type;
	private static filterType;
	register(operation: BaseOperationConstructor, options?: OperationRegisterOptions): void;
	registeredOperationsForContextAndParentType(context: NodeContext, parentNodeType: string): (typeof BaseOperation)[];
	registeredOperation(context: NodeContext, operationType: string): BaseOperationConstructor | undefined;
}
interface ConvertExportParamDataParams {
	paramName: string;
	paramData: SimpleParamJsonExporterData<ParamType>;
	params: DefaultOperationParams;
}
declare class BaseOperation<NC extends NodeContext> {
	protected _scene: PolyScene;
	protected states?: NodeStatesController<NC> | undefined;
	protected _node?: BaseNodeType | undefined;
	static type(): string;
	type(): string;
	static onRegister: OnOperationRegisterCallback | undefined;
	static context(): NodeContext;
	context(): NodeContext;
	static readonly DEFAULT_PARAMS: DefaultOperationParams;
	static readonly INPUT_CLONED_STATE: InputCloneMode | InputCloneMode[];
	constructor(_scene: PolyScene, states?: NodeStatesController<NC> | undefined, _node?: BaseNodeType | undefined);
	scene(): PolyScene;
	cook(input_contents: any[], params: object): any;
	convertExportParamData(options: ConvertExportParamDataParams): string | number | boolean | void;
}
interface BlobsControllerFetchNodeOptions {
	multiAssetsForNode?: boolean;
}
interface FetchNodeBlobUrlOptions extends BlobsControllerFetchNodeOptions {
	fullUrl: string;
	node: BaseNodeType;
}
interface FetchBlobResponse {
	blobWrapper?: BlobWrapper;
	error?: string;
}
interface BlobWrapper {
	blob: Blob;
	blobUrl: string;
	referringNodeIds: Set<CoreGraphNodeId>;
}
interface BlobData {
	url: string;
	blobWrapper: BlobWrapper;
}
type BlobDataCallback = (params: BlobData) => void;
declare class BlobsController {
	private poly;
	private _blobWrappersByUrl;
	constructor(poly: PolyEngine);
	recording(): boolean;
	blobUrl(url: string): string | undefined;
	clear(): void;
	clearBlobsForNode(node: BaseNodeType): void;
	private _assignBlobToNode;
	setVirtualFile(file: File, uniqueId: string): Promise<void>;
	fetchBlobGlobal(url: string): Promise<FetchBlobResponse>;
	fetchBlobForNode(options: FetchNodeBlobUrlOptions): Promise<{
		blobWrapper?: undefined;
		error?: undefined;
	} | {
		blobWrapper: BlobWrapper;
		error?: undefined;
	} | {
		error: string;
		blobWrapper?: undefined;
	}>;
	traverse(callback: BlobDataCallback): void;
	private _createBlobUrl;
	assetsManifestWithBlobsMap(): {
		manifest: PolyDictionary<string>;
		blobsMap: Map<string, Blob>;
	};
}
declare class AssetUrlsController {
	private _map;
	setMap(map: PolyDictionary<string>): void;
	remapedUrl(url: string): string | undefined;
}
interface PerformanceManager {
	now: () => number;
}
declare class PolyPerformanceformanceController {
	private _performanceManager;
	setPerformanceManager(p: PerformanceManager): void;
	performanceManager(): PerformanceManager;
}
declare class ScenesRegister {
	private _lastRegisteredScene;
	private _scenes;
	private _registerTimeByScene;
	registerScene(scene: PolyScene): void;
	deregisterScene(scene: PolyScene): void;
	dispose(): void;
	lastRegisteredScene(): PolyScene | undefined;
	scenes(): PolyScene[];
	private _updateCache;
}
type GetTokenFunc = () => Promise<string | undefined>;
declare class PolyThirdPartyMapboxController {
	private _token;
	private _getTokenFunc;
	setToken(token: string): void;
	setGetTokenFunction(tokenFunc: GetTokenFunc): void;
	token(): Promise<string | undefined>;
}
type MarkerTrackingControllerRenderFunction = () => void;
type MarkerTrackingControllerMountFunction = () => void;
type MarkerTrackingControllerUnmountFunction = () => void;
interface MarkerTrackingControllerConfig {
	renderFunction: MarkerTrackingControllerRenderFunction;
	mountFunction: MarkerTrackingControllerMountFunction;
	unmountFunction: MarkerTrackingControllerUnmountFunction;
}
declare enum MarkerTrackingSourceMode {
	WEBCAM = "webcam",
	IMAGE = "image",
	VIDEO = "video"
}
declare enum MarkerTrackingTransformMode {
	CAMERA = "camera",
	MARKER = "marker"
}
interface CoreMarkerTrackingControllerOptions {
	sourceMode: MarkerTrackingSourceMode;
	sourceUrl?: string;
	canvas: HTMLCanvasElement;
	camera: Camera;
	scene: Scene;
	barCode: {
		type: string;
		value: number;
	};
	transformMode: MarkerTrackingTransformMode;
	smooth: {
		active: boolean;
		count: number;
	};
}
declare class CoreMarkerTrackingController {
	constructor(options: CoreMarkerTrackingControllerOptions);
	errorMessage(): string | void;
	trackedMatrix(targetMatrix: Matrix4): void;
	config(): MarkerTrackingControllerConfig;
}
type MarkerTrackingControllerCreateFunc = (options: CoreMarkerTrackingControllerOptions) => CoreMarkerTrackingController;
type MarkerTrackingBarCodeUrlFunc = (type: string, value: number) => string;
interface MarkerTrackingConfig {
	barcodeUrl: MarkerTrackingBarCodeUrlFunc;
	createController: MarkerTrackingControllerCreateFunc;
	barCodes: {
		types: string[];
		valuesCountByType: Record<string, number>;
	};
}
declare class PolyMarkerTrackingController {
	private _config;
	private _controller;
	setConfig(config: MarkerTrackingConfig): void;
	barCodeUrl(type: string, value: number): string | void;
	barCodeTypes(): string[];
	config(): MarkerTrackingConfig | undefined;
	hasController(): boolean;
	createController(options: CoreMarkerTrackingControllerOptions): CoreMarkerTrackingController | undefined;
	controller(): CoreMarkerTrackingController | null;
}
declare class PolyThirdPartyController {
	private _markerTracking;
	markerTracking(): PolyMarkerTrackingController;
	private _mapbox;
	mapbox(): PolyThirdPartyMapboxController;
}
interface HookHandler {
	graphNodeId(): number;
	updateObjectOnAdd(object: ObjectContent<CoreObjectType>, parent: ObjectContent<CoreObjectType>): void;
	updateObjectOnRemove(object: ObjectContent<CoreObjectType>, parent: ObjectContent<CoreObjectType>): void;
}
declare class PolyOnObjectsAddRemoveHooksController {
	assignOnAddHookHandler(object: ObjectContent<CoreObjectType>, node: HookHandler): void;
	assignOnRemoveHookHandler(object: ObjectContent<CoreObjectType>, node: HookHandler): void;
	runOnAddHooks(scene: PolyScene, parent: ObjectContent<CoreObjectType>): void;
	runOnRemoveHooks(scene: PolyScene, parent: ObjectContent<CoreObjectType>): void;
	runOnAddHookOnObject(scene: PolyScene, object: ObjectContent<CoreObjectType>): void;
	runOnRemoveHookOnObject(scene: PolyScene, object: ObjectContent<CoreObjectType>): void;
}
type Hook = () => void;
declare class PolyOnSceneUpdatedHooksController {
	private _map;
	private _hooks;
	registerHook(node: BaseNodeType, hook: Hook): void;
	unregisterHook(node: BaseNodeType): void;
	runHooks(): void;
	hookedNodes(): BaseNodeType[];
	private _updateCache;
}
interface Params extends CSGOBJTesselationParams, CADOBJTesselationParams, QUADOBJTesselationParams, TetOBJTesselationParams {
}
type SpecializedChildrenHook = (displayNode: BaseSopNodeType, coreGroup: CoreGroup, newObjects: Object3D[], params: Params) => boolean;
declare class PolySpecializedChildrenController {
	private _map;
	private _hooks;
	registerHook(hookName: string, hook: SpecializedChildrenHook): void;
	private _updateCache;
	runHooks(displayNode: BaseSopNodeType, coreGroup: CoreGroup, newObjects: Object3D[], params: Params): boolean;
}
type PolyPluginCallback = (poly: PolyEngine) => void;
interface PolyPluginOptions {
	libraryName: string;
	libraryImportPath: string;
}
interface PolyPluginData {
	name: string;
	libraryName: string;
	libraryImportPath: string;
}
declare class PolyPlugin {
	protected _name: string;
	protected _callback: PolyPluginCallback;
	protected _options: PolyPluginOptions;
	constructor(_name: string, _callback: PolyPluginCallback, _options: PolyPluginOptions);
	name(): string;
	libraryName(): string;
	init(poly: PolyEngine): void;
	toJSON(): PolyPluginData;
}
type PolyPluginInterface = Pick<PolyPlugin, "name" | "libraryName" | "init" | "toJSON">;
interface PluginsRegisterData {
	plugins: PolyDictionary<PolyPluginData>;
	nodes: PolyDictionary<PolyDictionary<string>>;
	operations: PolyDictionary<PolyDictionary<string>>;
}
type WrapConfigurePolygonjsCallback = () => void | Promise<void>;
declare class PluginsRegister {
	private poly;
	private _configurePolygonjsPlugin;
	private _currentPlugin;
	private _pluginsByName;
	private _pluginNameByNodeContextByType;
	private _pluginNameByOperationContextByType;
	constructor(poly: PolyEngine);
	wrapConfigurePolygonjs(callback: WrapConfigurePolygonjsCallback): Promise<void>;
	register(plugin: PolyPluginInterface): void;
	pluginByName(pluginName: string): PolyPluginInterface | undefined;
	registerNode(node: BaseNodeConstructor): void;
	registerOperation(operation: BaseOperationConstructor): void;
	toJson(): PluginsRegisterData;
}
interface ViewerCallbackOptions<C extends Camera> {
	camera: C;
	scene: PolyScene;
	canvas?: HTMLCanvasElement;
	renderer?: AbstractRenderer;
}
type ViewerCreateCallback<C extends Camera> = (options: ViewerCallbackOptions<C>) => TypedViewer<C>;
declare class PolyCamerasRegister {
	private _cameraNodeTypes;
	private _registeredViewerCreateCallbackByCamera;
	constructor(poly: PolyEngine);
	registerNodeType(nodeType: string): void;
	registeredNodeTypes(): string[];
	register<C extends Camera>(cameraClass: any, viewerCreateCallback: ViewerCreateCallback<C>): void;
	createViewer<C extends Camera>(options: ViewerCallbackOptions<C>): TypedViewer<Camera> | undefined;
	objectRegistered(object: Object3D): boolean;
}
interface BaseModule<M extends ModuleName> {
	moduleName: M;
	onRegister: (poly: PolyEngine) => void;
}
interface ModuleRegisterOptions {
	printWarnings?: boolean;
}
declare class BaseModulesRegister {
	private poly;
	private _moduleByName;
	constructor(poly: PolyEngine);
	register<K extends ModuleName>(moduleName: K, module: BaseModule<K>, options?: ModuleRegisterOptions): void;
	moduleNames(): ModuleName[];
}
declare class DynamicModulesRegister extends BaseModulesRegister {
}
declare enum ExpressionType {
	animationNames = "animationNames",
	arg = "arg",
	argc = "argc",
	bbox = "bbox",
	blob = "blob",
	cameraName = "cameraName",
	cameraNames = "cameraNames",
	camerasCount = "camerasCount",
	centroid = "centroid",
	ch = "ch",
	chsop = "chsop",
	copy = "copy",
	copRes = "copRes",
	isDeviceMobile = "isDeviceMobile",
	isDeviceTouch = "isDeviceTouch",
	len = "len",
	join = "join",
	js = "js",
	object = "object",
	objectsCount = "objectsCount",
	objectName = "objectName",
	objectNames = "objectNames",
	opdigits = "opdigits",
	opname = "opname",
	padzero = "padzero",
	playerMode = "playerMode",
	point = "point",
	pointsCount = "pointsCount",
	smoothstep = "smoothstep",
	smootherstep = "smootherstep",
	solverIteration = "solverIteration",
	strCharsCount = "strCharsCount",
	strConcat = "strConcat",
	strIndex = "strIndex",
	strSub = "strSub",
	windowSize = "windowSize"
}
declare class BaseExpressionRegister {
	private _methodsNames;
	private _methodsByName;
	register(expression: typeof BaseMethod, name: ExpressionType): void;
	getMethod(name: ExpressionType): typeof BaseMethod | undefined;
	availableMethods(): ExpressionType[];
}
declare class AnimationNamesExpression extends BaseMethod {
	static requiredArguments(): string[][];
	findDependency(args: BaseMethodFindDependencyArgs): MethodDependency | null;
	processArguments(args: any[]): Promise<any>;
}
declare class ArgExpression extends BaseMethod {
	static requiredArguments(): string[][];
	processArguments(args: any[]): Promise<any>;
}
declare class ArgcExpression extends BaseMethod {
	static requiredArguments(): string[][];
	processArguments(args: any[]): Promise<any>;
}
declare class BboxExpression extends BaseMethod {
	static requiredArguments(): string[][];
	findDependency(args: BaseMethodFindDependencyArgs): MethodDependency | null;
	processArguments(args: any[]): Promise<number | Vector3 | Box3>;
	private _get_value_from_container;
}
declare class BlobExpression extends BaseMethod {
	static requiredArguments(): string[][];
	processArguments(args: any[]): Promise<string>;
}
declare class CameraNameExpression extends BaseMethod {
	static requiredArguments(): string[][];
	findDependency(args: BaseMethodFindDependencyArgs): MethodDependency | null;
	processArguments(args: any[]): Promise<string>;
}
declare class CameraNamesExpression extends BaseMethod {
	static requiredArguments(): string[][];
	findDependency(args: BaseMethodFindDependencyArgs): MethodDependency | null;
	processArguments(args: any[]): Promise<string[]>;
}
declare class CamerasCountExpression extends BaseMethod {
	static requiredArguments(): string[][];
	findDependency(args: BaseMethodFindDependencyArgs): MethodDependency | null;
	processArguments(args: any[]): Promise<number>;
}
declare class CentroidExpression extends BaseMethod {
	static requiredArguments(): string[][];
	findDependency(args: BaseMethodFindDependencyArgs): MethodDependency | null;
	processArguments(args: any[]): Promise<number | Vector3>;
}
declare class ChExpression extends BaseMethod {
	static requiredArguments(): string[][];
	private _referencedParam;
	findDependency(args: BaseMethodFindDependencyArgs): MethodDependency | null;
	processArguments(args: any[]): Promise<any>;
}
declare class ChsopExpression extends BaseMethod {
	static requiredArguments(): string[][];
	private _referencedParam;
	findDependency(args: BaseMethodFindDependencyArgs): MethodDependency | null;
	processArguments(args: any[]): Promise<any>;
}
declare class CopyExpression extends BaseMethod {
	static requiredArguments(): string[][];
	static optionalArguments(): string[][];
	findDependency(args: BaseMethodFindDependencyArgs): MethodDependency | null;
	processArguments(args: any[]): Promise<any>;
}
declare class CopResExpression extends BaseMethod {
	static requiredArguments(): string[][];
	findDependency(args: BaseMethodFindDependencyArgs): MethodDependency | null;
	private _resolution;
	processArguments(args: any[]): Promise<number | Vector2>;
}
declare class isDeviceMobileExpression extends BaseMethod {
	static requiredArguments(): never[];
	processArguments(args: any[]): Promise<boolean>;
}
declare class isDeviceTouchExpression extends BaseMethod {
	static requiredArguments(): never[];
	processArguments(args: any[]): Promise<boolean>;
}
declare class LenExpression extends BaseMethod {
	static requiredArguments(): string[][];
	processArguments(args: any[]): Promise<number>;
}
declare class JoinExpression extends BaseMethod {
	static requiredArguments(): string[][];
	processArguments(args: any[]): Promise<string>;
}
declare class JsExpression extends BaseMethod {
	private _function;
	static requiredArguments(): string[][];
	processArguments(args: any[]): Promise<any>;
	private _create_function;
}
declare class ObjectExpression extends BaseMethod {
	static requiredArguments(): string[][];
	findDependency(args: BaseMethodFindDependencyArgs): MethodDependency | null;
	processArguments(args: any[]): Promise<any>;
	_get_value_from_container(container: GeometryContainer, attrib_name: string, point_index: number): string | number | boolean | Vector2Like | ColorLike | Number2 | Number3 | Number4 | null | undefined;
}
declare class ObjectsCountExpression extends BaseMethod {
	static requiredArguments(): string[][];
	findDependency(args: BaseMethodFindDependencyArgs): MethodDependency | null;
	processArguments(args: any[]): Promise<number>;
}
declare class ObjectNameExpression extends BaseMethod {
	static requiredArguments(): string[][];
	findDependency(args: BaseMethodFindDependencyArgs): MethodDependency | null;
	processArguments(args: any[]): Promise<string>;
}
declare class ObjectNamesExpression extends BaseMethod {
	static requiredArguments(): string[][];
	findDependency(args: BaseMethodFindDependencyArgs): MethodDependency | null;
	processArguments(args: any[]): Promise<string[]>;
}
declare class OpdigitsExpression extends BaseMethod {
	static requiredArguments(): string[][];
	findDependency(args: BaseMethodFindDependencyArgs): MethodDependency | null;
	processArguments(args: any[]): Promise<number>;
}
declare class OpnameExpression extends BaseMethod {
	static requiredArguments(): string[][];
	findDependency(args: BaseMethodFindDependencyArgs): MethodDependency | null;
	processArguments(args: any[]): Promise<string>;
}
declare class PadzeroExpression extends BaseMethod {
	static requiredArguments(): string[][];
	processArguments(args: any[]): Promise<string>;
}
declare class PlayerModeExpression extends BaseMethod {
	static requiredArguments(): never[];
	processArguments(args: any[]): Promise<any>;
}
declare class PointExpression extends BaseMethod {
	static requiredArguments(): string[][];
	findDependency(args: BaseMethodFindDependencyArgs): MethodDependency | null;
	processArguments(args: any[]): Promise<any>;
	_get_value_from_container(container: GeometryContainer, attrib_name: string, point_index: number): string | number | boolean | Vector2Like | ColorLike | Number2 | Number3 | Number4 | null;
}
declare class PointsCountExpression extends BaseMethod {
	static requiredArguments(): string[][];
	findDependency(args: BaseMethodFindDependencyArgs): MethodDependency | null;
	processArguments(args: any[]): Promise<number>;
}
declare class SmoothstepExpression extends BaseMethod {
	static requiredArguments(): (string[] | undefined)[];
	processArguments(args: any[]): Promise<number>;
}
declare class SmootherstepExpression extends BaseMethod {
	static requiredArguments(): (string[] | undefined)[];
	processArguments(args: any[]): Promise<number>;
}
declare class SolverIterationExpression extends BaseMethod {
	static requiredArguments(): never[];
	static optionalArguments(): string[][];
	private _solverNode;
	findDependency(args: BaseMethodFindDependencyArgs): MethodDependency | null;
	processArguments(args: any[]): Promise<number>;
}
declare class StrCharsCountExpression extends BaseMethod {
	static requiredArguments(): string[][];
	processArguments(args: any[]): Promise<number>;
}
declare class StrConcatExpression extends BaseMethod {
	static requiredArguments(): any[];
	processArguments(args: any[]): Promise<string>;
}
declare class StrIndexExpression extends BaseMethod {
	static requiredArguments(): string[][];
	processArguments(args: any[]): Promise<number>;
}
declare class StrSubExpression extends BaseMethod {
	static requiredArguments(): string[][];
	processArguments(args: any[]): Promise<string>;
}
declare class WindowSizeExpression extends BaseMethod {
	static requiredArguments(): never[][];
	findDependency(indexOrPath: BaseMethodFindDependencyArgs): null;
	private _windowSize;
	processArguments(args: any[]): Promise<Vector2>;
}
interface ExpressionMap extends PolyDictionary<typeof BaseMethod> {
	animationNames: typeof AnimationNamesExpression;
	arg: typeof ArgExpression;
	argc: typeof ArgcExpression;
	bbox: typeof BboxExpression;
	blob: typeof BlobExpression;
	cameraName: typeof CameraNameExpression;
	cameraNames: typeof CameraNamesExpression;
	camerasCount: typeof CamerasCountExpression;
	centroid: typeof CentroidExpression;
	ch: typeof ChExpression;
	chsop: typeof ChsopExpression;
	copy: typeof CopyExpression;
	copRes: typeof CopResExpression;
	isDeviceMobile: typeof isDeviceMobileExpression;
	isDeviceTouch: typeof isDeviceTouchExpression;
	join: typeof JoinExpression;
	js: typeof JsExpression;
	len: typeof LenExpression;
	object: typeof ObjectExpression;
	objectsCount: typeof ObjectsCountExpression;
	objectName: typeof ObjectNameExpression;
	objectNames: typeof ObjectNamesExpression;
	opdigits: typeof OpdigitsExpression;
	opname: typeof OpnameExpression;
	padzero: typeof PadzeroExpression;
	playerMode: typeof PlayerModeExpression;
	point: typeof PointExpression;
	pointsCount: typeof PointsCountExpression;
	smoothstep: typeof SmoothstepExpression;
	smootherstep: typeof SmootherstepExpression;
	solverIteration: typeof SolverIterationExpression;
	strCharsCount: typeof StrCharsCountExpression;
	strConcat: typeof StrConcatExpression;
	strIndex: typeof StrIndexExpression;
	strSub: typeof StrSubExpression;
	windowSize: typeof WindowSizeExpression;
}
declare class AllExpressionsRegister {
	static run(poly: PolyEngine): void;
}
declare class ExpressionRegister extends BaseExpressionRegister {
	getMethod<K extends keyof ExpressionMap>(name: K): ExpressionMap[K] | undefined;
}
declare enum AssemblerName {
	GL_CLOTH = "GL_CLOTH",
	GL_LINE = "GL_LINE",
	GL_MESH_BASIC = "GL_MESH_BASIC",
	GL_MESH_DEPTH = "GL_MESH_DEPTH",
	GL_MESH_DISTANCE = "GL_MESH_DISTANCE",
	GL_MESH_LAMBERT = "GL_MESH_LAMBERT",
	GL_MESH_PHONG = "GL_MESH_PHONG",
	GL_MESH_PHYSICAL = "GL_MESH_PHYSICAL",
	GL_MESH_STANDARD = "GL_MESH_STANDARD",
	GL_MESH_TOON = "GL_MESH_TOON",
	GL_PARTICLES = "GL_PARTICLES",
	GL_POINTS = "GL_POINTS",
	GL_POST = "GL_POST",
	GL_RAYMARCHING = "GL_RAYMARCHING",
	GL_TEXTURE = "GL_TEXTURE",
	GL_TEXTURE_2D_ARRAY = "GL_TEXTURE_2D_ARRAY",
	GL_VOLUME = "GL_VOLUME",
	JS_ACTOR = "JS_ACTOR",
	JS_INSTANCE_BUILDER = "JS_INSTANCE_BUILDER",
	JS_OBJECT_BUILDER = "JS_OBJECT_BUILDER",
	JS_POINT_BUILDER = "JS_POINT_BUILDER",
	JS_SDF = "JS_SDF",
	JS_SOFT_BODY = "JS_SOFT_BODY"
}
interface ControllerAssemblerPair {
	controller: any;
	assembler: any;
}
type TraverseCallback = (pair: ControllerAssemblerPair, name: AssemblerName) => void;
declare class BaseAssemblersRegister {
	protected _controllerAssemblerByName: Map<AssemblerName, ControllerAssemblerPair>;
	register(name: AssemblerName, controller: any, assembler: any): void;
	unregister(name: AssemblerName): void;
	traverse(callback: TraverseCallback): void;
}
declare enum LineType {
	FUNCTION_DECLARATION = "function_declaration",
// @ts-ignore
	DEFINE = "define",
// @ts-ignore
	BODY = "body"
}
declare enum ShaderName {
	VERTEX = "vertex",
	FRAGMENT = "fragment",
	LEAVES_FROM_NODES_SHADER = "leaves_from_nodes_shader"
}
declare enum JsFunctionName {
	MAIN = "main",
	VELOCITY = "velocity",
	COLLIDER = "collider"
}
interface ShaderNameByContextMap {
	[NodeContext.GL]: ShaderName;
	[NodeContext.JS]: JsFunctionName;
	[NodeContext.ANIM]: ShaderName;
	[NodeContext.AUDIO]: ShaderName;
	[NodeContext.COP]: ShaderName;
	[NodeContext.EVENT]: ShaderName;
	[NodeContext.MANAGER]: ShaderName;
	[NodeContext.MAT]: ShaderName;
	[NodeContext.OBJ]: ShaderName;
	[NodeContext.POST]: ShaderName;
	[NodeContext.SOP]: ShaderName;
	[NodeContext.ROP]: ShaderName;
}
declare class ShaderConfig {
	private _name;
	private _input_names;
	private _dependencies;
	constructor(_name: ShaderName, _input_names: string[], _dependencies: ShaderName[]);
	name(): ShaderName;
	input_names(): string[];
	dependencies(): ShaderName[];
}
interface VariableConfigOptions {
	default_from_attribute?: boolean;
	default?: string;
	if?: string;
	prefix?: string;
	suffix?: string;
	postLines?: string[];
}
// @ts-ignore
declare class VariableConfig {
	private _name;
	private _options;
	constructor(_name: string, _options?: VariableConfigOptions);
	name(): string;
	default_from_attribute(): boolean;
	default(): string | undefined;
	if_condition(): string | undefined;
	prefix(): string;
	suffix(): string;
	postLines(): string[] | undefined;
}
declare class ParamConfigsController<PC extends ParamConfig> {
	private _param_configs;
	reset(): void;
	push(param_config: PC): void;
	list(): Readonly<PC[]>;
}
declare class TypedGLDefinitionCollection<T extends GLDefinitionType> {
	private _definitions;
	_errored: boolean;
	_error_message: string | undefined;
	constructor(_definitions?: TypedGLDefinition<T>[]);
	get errored(): boolean;
	get error_message(): string | undefined;
	uniq(): TypedGLDefinition<T>[];
}
declare enum GLDefinitionType {
	ATTRIBUTE = "attribute",
	FUNCTION = "function",
	PRECISION = "precision",
	UNIFORM = "uniform",
	VARYING = "varying"
}
declare abstract class TypedGLDefinition<T extends GLDefinitionType> {
	protected _definition_type: T;
	protected _data_type: GlConnectionPointType;
	protected _node: BaseGlNodeType;
	protected _name: string;
	constructor(_definition_type: T, _data_type: GlConnectionPointType, _node: BaseGlNodeType, _name: string);
	get definition_type(): T;
	get data_type(): GlConnectionPointType;
	get node(): BaseGlNodeType;
	name(): string;
	abstract get line(): string;
	collection_instance(): TypedGLDefinitionCollection<T>;
}
declare class FunctionGLDefinition extends TypedGLDefinition<GLDefinitionType.FUNCTION> {
	protected _node: BaseGlNodeType;
	protected _name: string;
	constructor(_node: BaseGlNodeType, _name: string);
	get line(): string;
}
type BaseGLDefinition = TypedGLDefinition<GLDefinitionType>;
// @ts-ignore
type DefinitionTraverseCallback = (definition: BaseGLDefinition) => void;
interface AddBodyLinesOptions {
	makeUniq: boolean;
}
declare class LinesController {
	private _shader_name;
	private _definitionsByNodeId;
	private _bodyLinesByNodeId;
	constructor(_shader_name: ShaderName);
	get shader_name(): ShaderName;
	addDefinitions(node: BaseGlNodeType, definitions: BaseGLDefinition[]): void;
	private _addDefinitionsForNodeId;
	definitions(node: BaseGlNodeType): BaseGLDefinition[] | undefined;
	traverseDefinitions(callback: DefinitionTraverseCallback): void;
	addBodyLines(node: BaseGlNodeType, lines: string[], options?: AddBodyLinesOptions): void;
	private _addBodyLinesForNodeId;
	bodyLines(node: BaseGlNodeType): string[] | undefined;
}
declare abstract class TypedAssembler<NC extends NodeContext> {
	abstract shaderNames(): ShaderNameByContextMap[NC][];
	abstract inputNamesForShaderName(node: BaseNodeByContextMap[NC], shaderName: ShaderNameByContextMap[NC]): string[];
	abstract rootNodesByShaderName(shaderName: ShaderNameByContextMap[NC], rootNodes: BaseNodeByContextMap[NC][]): BaseNodeByContextMap[NC][];
}
declare class ShadersCollectionController {
	private _shaderNames;
	private _currentShaderName;
	private _assembler;
	private _linesControllerByShaderName;
	constructor(_shaderNames: ShaderName[], _currentShaderName: ShaderName, _assembler: TypedAssembler<NodeContext.GL>);
	assembler(): TypedAssembler<NodeContext.GL>;
	linesController(shaderName: ShaderName): LinesController | undefined;
	shaderNames(): ShaderName[];
	setCurrentShaderName(shaderName: ShaderName): void;
	currentShaderName(): ShaderName;
	addDefinitions(node: BaseGlNodeType, definitions: BaseGLDefinition[], shaderName?: ShaderName): void;
	definitions(shaderName: ShaderName, node: BaseGlNodeType): BaseGLDefinition[] | undefined;
	traverseDefinitions(shaderName: ShaderName, callback: DefinitionTraverseCallback): void;
	addBodyLines(node: BaseGlNodeType, lines: string[], shaderName?: ShaderName, options?: AddBodyLinesOptions): void;
	bodyLines(shaderName: ShaderName, node: BaseGlNodeType): string[] | undefined;
}
type ParamInitValueSerialized = ParamInitValueSerializedTypeMap[keyof ParamInitValueSerializedTypeMap];
declare class BaseParamConfig<T extends ParamType> {
	protected _type: T;
	protected _name: string;
	protected _defaultValue: ParamInitValuesTypeMap[T];
	constructor(_type: T, _name: string, _defaultValue: ParamInitValuesTypeMap[T]);
	static fromParam<K extends ParamType>(param: TypedParam<K>): BaseParamConfig<K>;
	type(): T;
	name(): string;
	defaultValue(): ParamInitValuesTypeMap[T];
// @ts-ignore
	paramOptions(): ParamOptions;
	applyToNode(node: BaseNodeType): void;
	executeCallback(node: BaseNodeType, param: BaseParamType): void;
	protected _callback(node: BaseNodeType, param: BaseParamType): void;
}
interface GlParamConfigJSON<T extends ParamType> {
	type: T;
	name: string;
	defaultValue: ParamInitValuesTypeMap[T];
	uniformName: string;
}
declare class GlParamConfig<T extends ParamType> extends BaseParamConfig<T> {
	private _uniformName;
	private _uniform;
	constructor(_type: T, _name: string, _defaultValue: ParamInitValuesTypeMap[T], _uniformName: string);
	toJSON(): GlParamConfigJSON<T>;
	static fromJSON(json: GlParamConfigJSON<ParamType>): GlParamConfig<ParamType>;
	uniformName(): string;
	uniform(): IUniform<any>;
	private _createUniform;
	protected _callback(node: BaseNodeType, param: BaseParamType): void;
	static callback(param: BaseParamType, uniform: IUniform): void;
	static uniformByType(type: ParamType): IUniform;
	private static setUniformValueFromTextureFromNodePathParam;
}
declare class TypedGlNode<K extends NodeParamsConfig> extends TypedNode<NodeContext.GL, K> {
	static context(): NodeContext;
	protected _param_configs_controller: ParamConfigsController<GlParamConfig<ParamType>> | undefined;
	protected _assembler: BaseGlShaderAssembler | undefined;
	private _paramsEditableStatesController;
	initializeBaseNode(): void;
	cook(): void;
	protected _setMatToRecompile(): void;
	materialNode(): AssemblerGlControllerNode | undefined;
	glVarName(varName: string): string;
	protected _glVarNameBase(): string;
	variableForInputParam(param: IntegerParam | FloatParam | Vector2Param | Vector3Param | Vector4Param | ColorParam | BooleanParam): string;
	variableForInput(inputName: string): string;
	setLines(shaders_collection_controller: ShadersCollectionController): void;
	reset_code(): void;
	setParamConfigs(): void;
	param_configs(): readonly GlParamConfig<ParamType>[] | undefined;
	paramsGenerating(): boolean;
	paramDefaultValue(name: string): ParamInitValueSerialized;
}
type BaseGlNodeType = TypedGlNode<NodeParamsConfig>;
declare class ParamlessGlParamsConfig extends NodeParamsConfig {
}
declare class ParamlessTypedGlNode extends TypedGlNode<ParamlessGlParamsConfig> {
	paramsConfig: ParamlessGlParamsConfig;
}
type DisplayControllerCallback = () => void;
interface DisplayNodeControllerCallbacks {
	onDisplayNodeRemove: DisplayControllerCallback;
	onDisplayNodeSet: DisplayControllerCallback;
	onDisplayNodeUpdate: DisplayControllerCallback;
}
interface DisplayNodeControllerOptions {
	dependsOnDisplayNode: boolean;
}
declare class DisplayNodeController {
	protected node: BaseNodeType;
	private options;
	private _initialized;
	private _graphNode;
	private _displayNode;
	private _displayNodeOverride;
	private _onDisplayNodeRemoveCallback;
	private _onDisplayNodeSetCallback;
	private _onDisplayNodeUpdateCallback;
	constructor(node: BaseNodeType, callbacks: DisplayNodeControllerCallbacks, options?: DisplayNodeControllerOptions);
	dispose(): void;
	displayNode(): BaseNodeClassWithDisplayFlag | undefined;
	firstNonBypassedDisplayNode(): TypedNode<any, any> | undefined;
	initializeNode(): void;
	setDisplayNodeOverride(newDisplayNodeOverride: BaseNodeClassWithDisplayFlag | undefined): void;
	setDisplayNode(newDisplayNode: BaseNodeClassWithDisplayFlag | undefined): void;
	private _commitDisplayNode;
}
type OnSopGroupUpdatedHook = () => void;
// @ts-ignore
interface BaseObjNodeClassWithDisplayNode extends BaseObjNodeClass {
	displayNodeController: DisplayNodeController;
}
declare class ObjChildrenDisplayController {
	protected node: BaseObjNodeClassWithDisplayNode;
	protected _childrenUuids: Set<string>;
	protected _sopGroup: Group;
	protected _newSpecializedObjects: Object3D[];
	protected _newObjectsAreDifferent: boolean;
	private _scene;
	constructor(node: BaseObjNodeClassWithDisplayNode);
	private _createSopGroup;
	sopGroup(): Group;
	setSopGroupName(): void;
	dispose(): void;
	displayNodeControllerCallbacks(): DisplayNodeControllerCallbacks;
	initializeNode(): void;
	private _updateSopGroupHierarchy;
	usedInScene(): boolean;
	requestDisplayNodeContainer(): Promise<void>;
	private removeChildren;
	_setContentUnderSopGroup(): Promise<void>;
	private _notifyCamerasController;
	protected _addSpecializedObjects(displayNode: BaseSopNodeType, coreGroup: CoreGroup, newObjects: Object3D[]): void;
	private _onSopGroupUpdatedHookNames;
	private _onSopGroupUpdatedHooks;
	registerOnSopGroupUpdated(callbackName: string, callback: OnSopGroupUpdatedHook): void;
	private _clearHooks;
	deregisterOnSopGroupUpdated(callbackName: string): void;
	private _runOnSopGroupUpdatedHooks;
	onSopGroupUpdatedCallbackNames(): string[] | undefined;
}
declare const TransformedParamsConfig_base: {
	new (...args: any[]): {
		transform: ParamTemplate<ParamType.FOLDER>;
		/** @param toggle on to keep world position when adding a parent or removing from one */
		keepPosWhenParenting: ParamTemplate<ParamType.BOOLEAN>;
		/** @param rotation order */
		rotationOrder: ParamTemplate<ParamType.INTEGER>;
		/** @param translate */
		t: ParamTemplate<ParamType.VECTOR3>;
		/** @param rotation */
		r: ParamTemplate<ParamType.VECTOR3>;
		/** @param scale */
		s: ParamTemplate<ParamType.VECTOR3>;
		/** @param scale */
		scale: ParamTemplate<ParamType.FLOAT>;
		/** @param set for the matrix to be updated every frame */
		matrixAutoUpdate: ParamTemplate<ParamType.BOOLEAN>;
		updateTransformFromObject: ParamTemplate<ParamType.BUTTON>;
	};
} & typeof NodeParamsConfig;
declare class TransformedParamsConfig extends TransformedParamsConfig_base {
}
declare class TransformedObjNode extends TypedObjNode<Object3D, TransformedParamsConfig> {
	readonly transformController: TransformController;
}
declare class TransformController {
	private node;
	constructor(node: TransformedObjNode);
	initializeNode(): void;
	private _cook_main_without_inputs_when_dirty_bound;
	private _cook_main_without_inputs_when_dirty;
	update(): void;
	update_transform_with_matrix(matrix?: Matrix4): void;
	private _core_transform;
	private _update_matrix_from_params_with_core_transform;
	private _apply_look_at;
	set_params_from_matrix(matrix: Matrix4, options?: SetParamsFromMatrixOptions): void;
	static update_node_transform_params_if_required(node: TransformedObjNode, new_parent_object: Object3D): void;
	private _keep_pos_when_parenting_m_object;
	private _keep_pos_when_parenting_m_new_parent_inv;
	update_node_transform_params_if_required(new_parent_object: Object3D): void;
	update_node_transform_params_from_object(update_matrix?: boolean): void;
	static PARAM_CALLBACK_update_transform_from_object(node: TransformedObjNode): void;
}
declare class HierarchyParamsConfig extends NodeParamsConfig {
}
declare class HierarchyObjNode extends TypedObjNode<Object3D, HierarchyParamsConfig> {
	readonly hierarchyController: HierarchyController;
}
declare class HierarchyController {
	private node;
	constructor(node: HierarchyObjNode);
	initializeNode(): void;
	static on_input_updated(node: BaseObjNodeType): void;
	on_input_updated(): void;
}
declare class TypedObjNode<O extends Object3D, K extends NodeParamsConfig> extends TypedNode<NodeContext.OBJ, K> {
	static context(): NodeContext;
	readonly renderOrder: number;
	readonly transformController: TransformController | undefined;
	readonly hierarchyController: HierarchyController | undefined;
	protected _children_group: Group;
	protected _object: O;
	private _create_children_group;
	protected _attachableToHierarchy: boolean;
	attachableToHierarchy(): boolean;
	protected _usedInScene: boolean;
	usedInScene(): boolean;
	addObjectToParent(parent: Object3D): void;
	removeObjectFromParent(): void;
	readonly childrenDisplayController: ObjChildrenDisplayController | undefined;
	dispose(): void;
	initializeBaseNode(): void;
	childrenGroup(): Group;
	get object(): O;
	_create_object_with_attributes(): O;
	protected set_object_name(): void;
	createObject(): Object3D;
	isDisplayNodeCooking(): boolean;
	isDisplayed(): boolean;
}
type BaseObjNodeType = TypedObjNode<Object3D, any>;
declare class BaseObjNodeClass extends TypedObjNode<Object3D, any> {
}
declare enum LineType {
	MEMBER = "member",
	CONSTRUCTOR = "constructor",
// @ts-ignore
	DEFINE = "define",
// @ts-ignore
	BODY = "body"
}
interface VariableConfigOptions {
	default_from_attribute?: boolean;
	default?: string;
	if?: string;
	prefix?: string;
	suffix?: string;
	postLines?: string[];
}
// @ts-ignore
declare class VariableConfig {
	private _name;
	private _options;
	constructor(_name: string, _options?: VariableConfigOptions);
	name(): string;
	default_from_attribute(): boolean;
	default(): string | undefined;
	if_condition(): string | undefined;
	prefix(): string;
	suffix(): string;
	postLines(): string[] | undefined;
}
declare class TypedJsDefinitionCollection<T extends JsDefinitionType> {
	private _definitions;
	_errored: boolean;
	_error_message: string | undefined;
	constructor(_definitions?: TypedJsDefinition<T>[]);
	get errored(): boolean;
	get error_message(): string | undefined;
	uniq(): TypedJsDefinition<T>[];
}
declare enum JsDefinitionType {
	LOCAL_FUNCTION = "localFunction",
	COMPUTED = "computed",
	CONSTANT = "constant",
	REF = "ref",
	WATCH = "watch",
	INIT_FUNCTION = "initFunction",
	TRIGGERING = "triggering",
	TRIGGERABLE = "triggerable"
}
declare abstract class TypedJsDefinition<T extends JsDefinitionType> {
	protected _definitionType: T;
	protected _node: BaseJsNodeType;
	protected _shaderCollectionController: JsLinesCollectionController;
	protected _dataType: JsConnectionPointType;
	protected _name: string;
	constructor(_definitionType: T, _node: BaseJsNodeType, _shaderCollectionController: JsLinesCollectionController, _dataType: JsConnectionPointType, _name: string);
	static gather(definitions: BaseJsDefinition[], linesForShader: Map<LineType, string[]>, lineType: LineType): void;
	definitionType(): T;
	dataType(): JsConnectionPointType;
	node(): BaseJsNodeType;
	name(): string;
	abstract line(): string;
	collectionInstance(): TypedJsDefinitionCollection<T>;
}
interface TriggerableJsDefinitionOptions {
	async?: boolean;
	methodName?: string;
}
type BaseJsDefinition = TypedJsDefinition<JsDefinitionType>;
// @ts-ignore
type DefinitionTraverseCallback = (definition: BaseJsDefinition) => void;
interface AddBodyLinesOptions {
	makeUniq: boolean;
}
declare class JsLinesController {
	private _shader_name;
	private _definitionsByNodeId;
	private _bodyLinesByNodeId;
	constructor(_shader_name: JsFunctionName);
	get shader_name(): JsFunctionName;
	addDefinitions(node: BaseJsNodeType, definitions: BaseJsDefinition[]): void;
	private _addDefinitionsForNodeId;
	definitions(node: BaseJsNodeType): BaseJsDefinition[] | undefined;
	traverseDefinitions(callback: DefinitionTraverseCallback): void;
	addBodyLines(node: BaseJsNodeType, lines: string[], options?: AddBodyLinesOptions): void;
	private _addBodyLinesForNodeId;
	bodyLines(node: BaseJsNodeType): string[] | undefined;
}
type RegisterableVariable = Box3 | Color | Euler | Plane | Quaternion | Matrix4 | Ray | Sphere | Vector2 | Vector3 | Vector4 | PrimitiveArray<PrimitiveArrayElement> | VectorArray<VectorArrayElement>;
declare class PrimitiveArray<V extends PrimitiveArrayElement> {
	protected _elements: V[];
	readonly isPrimitiveArray = true;
	constructor(_elements: V[]);
	elements(): V[];
	clone(): V[];
}
declare class VectorArray<V extends VectorArrayElement> {
	protected _elements: V[];
	readonly isVectorArray = true;
	constructor(_elements: V[]);
	elements(): V[];
	clone(): V[];
}
declare enum SerializedVariableType {
	Box3 = "Box3",
	Color = "Color",
	Euler = "Euler",
	Matrix4 = "Matrix4",
	Plane = "Plane",
	Quaternion = "Quaternion",
	Ray = "Ray",
	Sphere = "Sphere",
	Vector2 = "Vector2",
	Vector3 = "Vector3",
	Vector4 = "Vector4",
	boolean_Array = "boolean[]",
	number_Array = "number[]",
	string_Array = "string[]",
	Color_Array = "Color[]",
	Euler_Array = "Euler[]",
	Matrix4_Array = "Matrix4[]",
	Quaternion_Array = "Quaternion[]",
	Vector2_Array = "Vector2[]",
	Vector3_Array = "Vector3[]",
	Vector4_Array = "Vector4[]"
}
interface EulerSerialized {
	rotation: Number3;
	rotationOrder: EulerOrder;
}
interface SerializedDataByType {
	[SerializedVariableType.Box3]: {
		min: Number3;
		max: Number3;
	};
	[SerializedVariableType.Color]: Number3;
	[SerializedVariableType.Euler]: EulerSerialized;
	[SerializedVariableType.Matrix4]: Number16;
	[SerializedVariableType.Plane]: {
		normal: Number3;
		constant: number;
	};
	[SerializedVariableType.Quaternion]: Number4;
	[SerializedVariableType.Ray]: {
		origin: Number3;
		direction: Number3;
	};
	[SerializedVariableType.Sphere]: {
		center: Number3;
		radius: number;
	};
	[SerializedVariableType.Vector2]: Number2;
	[SerializedVariableType.Vector3]: Number3;
	[SerializedVariableType.Vector4]: Number4;
	[SerializedVariableType.boolean_Array]: boolean[];
	[SerializedVariableType.number_Array]: number[];
	[SerializedVariableType.string_Array]: string[];
	[SerializedVariableType.Color_Array]: Number3[];
	[SerializedVariableType.Euler_Array]: EulerSerialized[];
	[SerializedVariableType.Matrix4_Array]: Number16[];
	[SerializedVariableType.Quaternion_Array]: Number4[];
	[SerializedVariableType.Vector2_Array]: Number2[];
	[SerializedVariableType.Vector3_Array]: Number3[];
	[SerializedVariableType.Vector4_Array]: Number4[];
}
interface SerializedVariable<T extends SerializedVariableType> {
	type: SerializedVariableType;
	data: SerializedDataByType[T];
}
type onTimeTickHook = (delta: number) => void;
type onPlayingStateChangeCallback = () => void;
interface TimeControllerUpdateTimeOptions {
	updateClockDelta?: boolean;
}
type onTimeTickCallbacksMap = Map<string, onTimeTickHook>;
declare class TimeController {
	private scene;
	static START_FRAME: Readonly<number>;
	private _frame;
	private _timeUniform;
	private _timeDeltaUniform;
	private _graphNode;
	private _realtimeState;
	private _maxFrame;
	private _maxFrameLocked;
	private _playing;
	private _clock;
	constructor(scene: PolyScene);
	get graphNode(): CoreGraphNode;
	dispose(): void;
	updateClockDelta(): number;
	delta(): number;
	setDelta(delta: number): number;
	frame(): number;
	timeUniform(): import("@vue/reactivity").Ref<number>;
	timeDeltaUniform(): import("@vue/reactivity").Ref<number>;
	time(): number;
	maxFrame(): number;
	maxFrameLocked(): boolean;
	realtimeState(): boolean;
	setMaxFrame(maxFrame: number): void;
	setMaxFrameLocked(state: boolean): void;
	setRealtimeState(state: boolean): void;
	setTime(time: number, updateFrame?: boolean): void;
	setFrame(frame: number, updateTime?: boolean): void;
	setFrameToStart(): void;
	incrementTimeIfPlaying(options?: TimeControllerUpdateTimeOptions): void;
	incrementTime(options?: TimeControllerUpdateTimeOptions): void;
	private _ensureFrameWithinBounds;
	playing(): boolean;
	pause(): void;
	play(): void;
	togglePlayPause(): void;
	private _playAllowedWithoutAllNodesCooked;
	forbidPlayUntilAllNodesCooked(): void;
	private _onBeforeTickCallbacksMap;
	private _onAfterTickCallbacksMap;
	private _onPlayingStateChangeCallbacksMap;
	private _onBeforeTickCallbacks;
	private _onAfterTickCallbacks;
	private _onPlayingStateChangeCallbacks;
	registerOnBeforeTick(callbackName: string, callback: onTimeTickHook): void;
	unRegisterOnBeforeTick(callbackName: string): void;
	registeredBeforeTickCallbacks(): Map<any, any>;
	hasBeforeTickCallback(callbackName: string): boolean;
	registerOnAfterTick(callbackName: string, callback: onTimeTickHook): void;
	unRegisterOnAfterTick(callbackName: string): void;
	registeredAfterTickCallbacks(): onTimeTickCallbacksMap;
	hasAfterTickCallback(callbackName: string): boolean;
	onPlayingStateChange(callback: onPlayingStateChangeCallback): void;
	removeOnPlayingStateChange(callback: onPlayingStateChangeCallback): void;
	private _updateOnPlayingStateChangeCallbacks;
	private _registerCallback;
	private _unregisterCallback;
	private _updateCallbacks;
}
declare abstract class BaseNamedFunction {
	readonly node: BaseNodeType;
	readonly shadersCollectionController?: JsLinesCollectionController | undefined;
	static type(): string;
	type(): string;
	readonly scene: PolyScene;
	readonly jsNode?: BaseJsNodeType;
	readonly functionNode: AssemblerControllerNode<BaseJsShaderAssembler>;
	readonly timeController: TimeController;
	constructor(node: BaseNodeType, shadersCollectionController?: JsLinesCollectionController | undefined);
	abstract func(...args: any): any;
	asString(...args: any): string;
}
declare abstract class NamedFunction<ARGS extends Array<any>, ARGS_STR extends Array<string>> extends BaseNamedFunction {
	abstract func(...args: ARGS): any;
	async: boolean;
	asString(...args: ARGS_STR): string;
}
declare abstract class NamedFunction0 extends NamedFunction<[
], [
]> {
}
declare abstract class NamedFunction1<ARGS extends Tuple1<any>> extends NamedFunction<ARGS, Tuple1<any>> {
}
declare abstract class NamedFunction2<ARGS extends Tuple2<any>> extends NamedFunction<ARGS, Tuple2<string>> {
}
declare abstract class NamedFunction3<ARGS extends Tuple3<any>> extends NamedFunction<ARGS, Tuple3<string>> {
}
declare abstract class NamedFunction4<ARGS extends Tuple4<any>> extends NamedFunction<ARGS, Tuple4<string>> {
}
declare abstract class NamedFunction5<ARGS extends Tuple5<any>> extends NamedFunction<ARGS, Tuple5<string>> {
}
declare abstract class NamedFunction6<ARGS extends Tuple6<any>> extends NamedFunction<ARGS, Tuple6<string>> {
}
declare abstract class NamedFunction7<ARGS extends Tuple7<any>> extends NamedFunction<ARGS, Tuple7<string>> {
}
declare abstract class NamedFunction8<ARGS extends Tuple8<any>> extends NamedFunction<ARGS, Tuple8<string>> {
}
declare abstract class NamedFunction9<ARGS extends Tuple9<any>> extends NamedFunction<ARGS, Tuple9<string>> {
}
declare abstract class ObjectNamedFunction<ARGS extends Array<any>, ARGS_STR extends Array<string>> extends BaseNamedFunction {
	abstract func(object: Object3D, ...args: ARGS): any;
	asString(...args: ARGS_STR): string;
}
declare abstract class ObjectNamedFunction0 extends ObjectNamedFunction<[
], Tuple1<string>> {
}
declare abstract class ObjectNamedFunction1<ARGS extends Tuple1<any>> extends ObjectNamedFunction<ARGS, Tuple2<string>> {
}
declare abstract class ObjectNamedFunction2<ARGS extends Tuple2<any>> extends ObjectNamedFunction<ARGS, Tuple3<string>> {
}
declare abstract class ObjectNamedFunction3<ARGS extends Tuple3<any>> extends ObjectNamedFunction<ARGS, Tuple4<string>> {
}
declare abstract class ObjectNamedFunction4<ARGS extends Tuple4<any>> extends ObjectNamedFunction<ARGS, Tuple5<string>> {
}
declare abstract class ObjectNamedFunction5<ARGS extends Tuple5<any>> extends ObjectNamedFunction<ARGS, Tuple6<string>> {
}
declare abstract class ObjectNamedFunction6<ARGS extends Tuple6<any>> extends ObjectNamedFunction<ARGS, Tuple7<string>> {
}
interface ComputedValueJsDefinitionData {
	dataType: JsConnectionPointType;
	varName: string;
	value: string;
}
interface TriggeringJsDefinitionOptionsExtended {
	gatherable: boolean;
	triggeringMethodName?: EvaluatorMethodName;
	nodeMethodName?: string;
}
interface TriggerableJsDefinitionOptionsExtended extends TriggerableJsDefinitionOptions {
	addTriggeredLines?: boolean;
}
declare class JsLinesCollectionController {
	private _shaderNames;
	private _currentShaderName;
	private _assembler;
	private _linesControllerByShaderName;
	constructor(_shaderNames: JsFunctionName[], _currentShaderName: JsFunctionName, _assembler: BaseJsShaderAssembler);
	assembler(): BaseJsShaderAssembler;
	linesController(shaderName: JsFunctionName): JsLinesController | undefined;
	shaderNames(): JsFunctionName[];
	setCurrentShaderName(shaderName: JsFunctionName): void;
	currentShaderName(): JsFunctionName;
	addVariable(node: BaseJsNodeType, variable: RegisterableVariable, varName?: string): string;
	addFunction(node: BaseJsNodeType, namedFunction: BaseNamedFunction): void;
	addTriggeringLines(node: BaseJsNodeType, triggeringLines: string[], options: TriggeringJsDefinitionOptionsExtended): void;
	addTriggerableLines(node: BaseJsNodeType, triggerableLines: string[], options?: TriggerableJsDefinitionOptionsExtended): void;
	addComputedVarName(varName: string): void;
	registeredAsComputed(varName: string): boolean;
	addBodyOrComputed(node: BaseJsNodeType, linesData: ComputedValueJsDefinitionData[]): void;
	addComputed(node: BaseJsNodeType, linesData: ComputedValueJsDefinitionData[]): void;
	addDefinitions(node: BaseJsNodeType, definitions: BaseJsDefinition[], shaderName?: JsFunctionName): void;
	definitions(shaderName: JsFunctionName, node: BaseJsNodeType): BaseJsDefinition[] | undefined;
	traverseDefinitions(shaderName: JsFunctionName, callback: DefinitionTraverseCallback): void;
	_addBodyLines(node: BaseJsNodeType, lines: string[], shaderName?: JsFunctionName, options?: AddBodyLinesOptions): void;
	bodyLines(shaderName: JsFunctionName, node: BaseJsNodeType): string[] | undefined;
}
interface JsParamConfigJSON<T extends ParamType> {
	type: T;
	name: string;
	defaultValue: ParamInitValuesTypeMap[T];
	uniformName: string;
}
declare class JsParamConfig<T extends ParamType> extends BaseParamConfig<T> {
	private _uniformName;
	constructor(_type: T, _name: string, _defaultValue: ParamInitValuesTypeMap[T], _uniformName: string);
	toJSON(): JsParamConfigJSON<T>;
	static fromJSON(json: JsParamConfigJSON<ParamType>): JsParamConfig<ParamType>;
	uniformName(): string;
	protected _callback(node: BaseNodeType, param: BaseParamType): void;
	static callback(node: BaseNodeType, paramName: string): void;
}
type RootNodesForJsFunctionMethod = (shader_name: JsFunctionName, rootNodes: BaseJsNodeType[]) => BaseJsNodeType[];
interface CodeBuilderSetCodeLinesOptions {
	otherFragmentShaderCollectionController?: JsLinesCollectionController;
	actor: {
		triggeringNodes: Set<BaseJsNodeType>;
		triggerableNodes: Set<BaseJsNodeType>;
		functionNode: ActorBuilderNode;
	};
}
declare class JsCodeBuilder {
	private _nodeTraverser;
	private _rootNodesByShaderName;
	private _assembler;
	private _param_configs_controller;
	private _param_configs_set_allowed;
	private _shadersCollectionController;
	private _lines;
	constructor(_nodeTraverser: TypedNodeTraverser<NodeContext.JS>, _rootNodesByShaderName: RootNodesForJsFunctionMethod, _assembler: BaseJsShaderAssembler);
	nodeTraverser(): TypedNodeTraverser<NodeContext.JS>;
	shaderNames(): JsFunctionName[];
	buildFromNodes(rootNodes: BaseJsNodeType[], paramNodes: BaseJsNodeType[], setCodeLinesOptions?: CodeBuilderSetCodeLinesOptions): void;
	shadersCollectionController(): JsLinesCollectionController | undefined;
	disallow_new_param_configs(): void;
	allow_new_param_configs(): void;
	private reset;
	param_configs(): readonly JsParamConfig<ParamType>[];
	lines(shader_name: JsFunctionName, line_type: LineType): string[];
	all_lines(): Map<JsFunctionName, Map<LineType, string[]>>;
	setParamConfigs(nodes: BaseJsNodeType[]): void;
	private _setCodeLines;
	private _addCodeLines;
	private addDefinitions;
	add_code_line_for_nodes_and_line_type(nodes: BaseJsNodeType[], shaderName: JsFunctionName, lineType: LineType): void;
	add_code_line_for_node_and_line_type(node: BaseJsNodeType, shaderName: JsFunctionName, lineType: LineType, isLast: boolean): void;
}
declare class JsShaderConfig {
	private _name;
	private _input_names;
	private _dependencies;
	constructor(_name: JsFunctionName, _input_names: string[], _dependencies: JsFunctionName[]);
	name(): JsFunctionName;
	input_names(): string[];
	dependencies(): JsFunctionName[];
}
declare class OutputJsParamsConfig extends NodeParamsConfig {
}
declare class OutputJsNode extends TypedJsNode<OutputJsParamsConfig> {
	paramsConfig: OutputJsParamsConfig;
	static type(): JsType;
	initializeNode(): void;
	setLines(linesController: JsLinesCollectionController): void;
}
declare class GlobalsJsParamsConfig extends NodeParamsConfig {
}
declare class GlobalsJsNode extends TypedJsNode<GlobalsJsParamsConfig> {
	paramsConfig: GlobalsJsParamsConfig;
	static type(): JsType;
	initializeNode(): void;
	setLines(linesController: JsLinesCollectionController): void;
}
declare enum GlType {
	ADJACENT_POINTS_ATTRIB_SMOOTH = "adjacentPointsAttribSmooth",
	ADJACENT_UV_ATTRIB_SMOOTH = "adjacentUvAttribSmooth",
	ATTRIBUTE = "attribute",
	COMPUTE_NORMALS = "computeNormals",
	CONSTANT = "constant",
	FOR_LOOP = "forLoop",
	IF_THEN = "ifThen",
	GLOBALS = "globals",
	NOISE = "noise",
	OUTPUT = "output",
	PARAM = "param",
	RAMP = "ramp",
	SDF_2D_BOX = "SDF2DBox",
	SDF_2D_CIRCLE = "SDF2DCircle",
	SDF_2D_CROSS = "SDF2DCross",
	SDF_2D_HEART = "SDF2DHeart",
	SDF_2D_ROUNDED_X = "SDF2DRoundedX",
	SDF_2D_STAIRS = "SDF2DStairs",
	SDF_BOX = "SDFBox",
	SDF_BOX_FRAME = "SDFBoxFrame",
	SDF_BOX_ROUND = "SDFBoxRound",
	SDF_CAPSULE = "SDFCapsule",
	SDF_CAPSULE_VERTICAL = "SDFCapsuleVertical",
	SDF_CONE = "SDFCone",
	SDF_CONE_ROUND = "SDFConeRound",
	SDF_ELONGATE = "SDFElongate",
	SDF_FRACTAL_MANDELBROT = "SDFFractalMandelbrot",
	SDF_GRADIENT = "SDFGradient",
	SDF_HEXAGONAL_PRISM = "SDFHexagonalPrism",
	SDF_HORSE_SHOE = "SDFHorseShoe",
	SDF_LINK = "SDFLink",
	SDF_OCTAHEDRON = "SDFOctahedron",
	SDF_OCTOGONAL_PRISM = "SDFOctogonalPrism",
	SDF_ONION = "SDFOnion",
	SDF_PLANE = "SDFPlane",
	SDF_PYRAMID = "SDFPyramid",
	SDF_QUAD = "SDFQuad",
	SDF_REPEAT_POLAR = "SDFRepeatPolar",
	SDF_REVOLUTION = "SDFRevolution",
	SDF_RHOMBUS = "SDFRhombus",
	SDF_RHOMBUS_TRIACONTAHEDRON = "SDFRhombusTriacontahedron",
	SDF_SOLID_ANGLE = "SDFSolidAngle",
	SDF_SPHERE = "SDFSphere",
	SDF_SPHERE_CUT = "SDFSphereCut",
	SDF_SPHERE_HOLLOW = "SDFSphereHollow",
	SDF_TORUS = "SDFTorus",
	SDF_TRANSFORM = "SDFTransform",
	SDF_TRIANGULAR_PRISM = "SDFTriangularPrism",
	SDF_TRIANGLE = "SDFTriangle",
	SDF_TUBE = "SDFTube",
	SDF_TWIST = "SDFTwist",
	SDF_CONTEXT = "SDFContext",
	SDF_MATERIAL = "SDFMaterial",
	TEXTURE = "texture",
	TEXTURE_DISPLACEMENT = "textureDisplacement",
	TEXTURE_SDF = "textureSDF",
	VARYING_READ = "varyingRead",
	VARYING_WRITE = "varyingWrite",
	VERTEX_ANIMATION_TEXTURE = "vertexAnimationTexture",
	VERTEX_ANIMATION_TEXTURE_INTERPOLATED = "vertexAnimationTextureInterpolated"
}
declare class OutputGlParamsConfig extends NodeParamsConfig {
}
declare class OutputGlNode extends TypedGlNode<OutputGlParamsConfig> {
	paramsConfig: OutputGlParamsConfig;
	static type(): GlType;
	initializeNode(): void;
	setLines(shaders_collection_controller: ShadersCollectionController): void;
}
declare class AttributeGlParamsConfig extends NodeParamsConfig {
	/** @param attribute name */
	name: ParamTemplate<ParamType.STRING>;
	/** @param attribute type (float, vec2, vec3, vec4) */
	type: ParamTemplate<ParamType.INTEGER>;
	/** @param allows to export the attribute to a material (when used inside a particles system) */
	texportWhenConnected: ParamTemplate<ParamType.BOOLEAN>;
	/** @param allows to export the attribute to a material (when used inside a particles system) */
	exportWhenConnected: ParamTemplate<ParamType.BOOLEAN>;
}
declare class AttributeGlNode extends TypedGlNode<AttributeGlParamsConfig> {
	paramsConfig: AttributeGlParamsConfig;
	static type(): Readonly<GlType.ATTRIBUTE>;
	static readonly INPUT_NAME = "in";
	static readonly OUTPUT_NAME = "val";
	initializeNode(): void;
	private _bound_setExportWhenConnectedStatus;
	private _setExportWhenConnectedStatus;
	setAttribSize(size: number): void;
	inputName(): string;
	outputName(): string;
	varyingName(): string;
	setLines(shadersCollectionController: ShadersCollectionController): void;
	attributeName(): string;
	glType(): GlConnectionPointType;
	setGlType(type: GlConnectionPointType): void;
	connected_input_node(): BaseGlNodeType | null;
	connected_input_connection_point(): BaseGlConnectionPoint | undefined;
	output_connection_point(): BaseGlConnectionPoint | undefined;
	isImporting(): boolean;
	isExporting(): boolean;
	private _setMatToRecompileIfIsExporting;
}
declare class GlobalsGlParamsConfig extends NodeParamsConfig {
}
declare class GlobalsGlNode extends TypedGlNode<GlobalsGlParamsConfig> {
	paramsConfig: GlobalsGlParamsConfig;
	static type(): GlType;
	initializeNode(): void;
	setLines(shaders_collection_controller: ShadersCollectionController): void;
}
interface IUniformN {
	value: number;
}
interface IUniformV2 {
	value: Vector2;
}
interface IUniformV3 {
	value: Vector3;
}
interface IUniformTexture {
	value: Texture | null;
}
interface OnBeforeCompileData {
	vertexShader: string;
	fragmentShader: string;
	paramConfigs: readonly GlParamConfig<ParamType>[];
	additionalTextureUniforms: PolyDictionary<IUniformTexture>;
	timeDependent: boolean;
	resolutionDependent: boolean;
	raymarchingLightsWorldCoordsDependent: boolean;
}
type RemoveParamConfigField<Type> = {
	[Property in keyof Type as Exclude<Property, "paramConfigs" | "additionalTextureUniforms">]: Type[Property];
};
interface OnBeforeCompileDataJSON extends RemoveParamConfigField<OnBeforeCompileData> {
	paramConfigs: GlParamConfigJSON<ParamType>[];
}
type CustomAssemblerMap = Map<CustomMaterialName, typeof ShaderAssemblerMaterial>;
interface HandleGlobalsOutputOptions {
	globals_node: GlobalsGlNode;
	shaders_collection_controller: ShadersCollectionController;
	output_name: string;
	globals_shader_name: ShaderName;
	definitions_by_shader_name: Map<ShaderName, BaseGLDefinition[]>;
	body_lines: string[];
	var_name: string;
	shader_name: ShaderName;
	dependencies: ShaderName[];
	body_lines_by_shader_name: Map<ShaderName, string[]>;
}
type CustomAssemblerCallback = (a: ShaderAssemblerMaterial, assemblerName: CustomMaterialName) => void;
declare class ShaderAssemblerMaterial extends BaseGlShaderAssembler {
	private _assemblersByCustomName;
	createMaterial(): Material;
	customAssemblerClassByCustomName(): CustomAssemblerMap | undefined;
	traverseCustomAssemblers(callback: CustomAssemblerCallback): void;
	protected _addCustomMaterials(material: Material): void;
	private _addCustomMaterial;
	compileCustomMaterials(material: MaterialWithCustomMaterials, parentAssembler: ShaderAssemblerMaterial): void;
	private _filterFragmentShaderCallbacks;
	protected _resetFilterFragmentShaderCallbacks(): void;
	_addFilterFragmentShaderCallback(callbackName: string, callback: (s: string) => string): void;
	_removeFilterFragmentShaderCallback(callbackName: string): void;
	private _filterFragmentShaderMethodOwner;
	setFilterFragmentShaderMethodOwner(owner: ShaderAssemblerMaterial | undefined): void;
	filterFragmentShader(fragmentShader: string): string;
	processFilterFragmentShader(fragmentShader: string): string;
	private _onBeforeCompileData;
	onBeforeCompileData(): OnBeforeCompileData | undefined;
	private _additionalTextureUniforms;
	clearAdditionalTextureUniforms(): void;
	addAdditionalTextureUniforms(uniformName: string, uniform: IUniformTexture): void;
	private _setAdditionalTextureUniforms;
	compileMaterial(material: Material, codeBuilderOptions?: CodeBuilderSetCodeLinesOptions): void;
	prepareOnBeforeCompileData(material: Material): void;
	protected updateShaders(codeBuilderOptions?: CodeBuilderSetCodeLinesOptions): void;
	shadow_assembler_class_by_custom_name(): {};
	add_output_body_line(output_node: OutputGlNode, shaders_collection_controller: ShadersCollectionController, input_name: string): void;
	set_node_lines_output(output_node: OutputGlNode, shadersCollectionController: ShadersCollectionController): void;
	setNodeLinesAttribute(attribute_node: AttributeGlNode, shadersCollectionController: ShadersCollectionController): void;
	handle_globals_output_name(options: HandleGlobalsOutputOptions): void;
	handleTime(options: HandleGlobalsOutputOptions): void;
	handle_resolution(options: HandleGlobalsOutputOptions): void;
	handle_mvPosition(options: HandleGlobalsOutputOptions): void;
	handle_gl_Position(options: HandleGlobalsOutputOptions): void;
	handle_gl_FragCoord(options: HandleGlobalsOutputOptions): void;
	handle_gl_PointCoord(options: HandleGlobalsOutputOptions): void;
	set_node_lines_globals(globals_node: GlobalsGlNode, shaders_collection_controller: ShadersCollectionController): void;
	private used_output_names_for_shader;
}
declare class TypedBaseManagerNode<K extends NodeParamsConfig> extends TypedNode<NodeContext.MANAGER, K> {
	static context(): NodeContext;
}
type BaseManagerNodeType = TypedBaseManagerNode<any>;
declare abstract class TypedLightObjNode<L extends Object3D, K extends NodeParamsConfig> extends TypedObjNode<Group, K> {
	readonly flags: FlagsControllerD;
	readonly renderOrder: number;
	protected _light: L;
	get light(): L;
	protected abstract createLight(): L;
	protected _usedInScene: boolean;
	initializeBaseNode(): void;
	private _cook_main_without_inputs_when_dirty_bound;
	private _cook_main_without_inputs_when_dirty;
	protected set_object_name(): void;
	private _updateLightAttachment;
	cook(): Promise<void>;
	protected updateLightParams(): void | Promise<void>;
	protected updateShadowParams(): void;
}
declare const AmbientLightObjParamsConfig_base: {
	new (...args: any[]): {
		color: ParamTemplate<ParamType.COLOR>;
		intensity: ParamTemplate<ParamType.FLOAT>;
		name: ParamTemplate<ParamType.STRING>;
	};
} & typeof NodeParamsConfig;
declare class AmbientLightObjParamsConfig extends AmbientLightObjParamsConfig_base {
}
declare class AmbientLightObjNode extends TypedLightObjNode<AmbientLight, AmbientLightObjParamsConfig> {
	paramsConfig: AmbientLightObjParamsConfig;
	static type(): string;
	initializeNode(): void;
	private __operation__;
	private _operation;
	createLight(): AmbientLight;
	protected updateLightParams(): void;
}
declare const TransformedObjParamConfig_base: {
	new (...args: any[]): {
		transform: ParamTemplate<ParamType.FOLDER>;
		keepPosWhenParenting: ParamTemplate<ParamType.BOOLEAN>;
		rotationOrder: ParamTemplate<ParamType.INTEGER>;
		t: ParamTemplate<ParamType.VECTOR3>;
		r: ParamTemplate<ParamType.VECTOR3>;
		s: ParamTemplate<ParamType.VECTOR3>;
		scale: ParamTemplate<ParamType.FLOAT>;
		matrixAutoUpdate: ParamTemplate<ParamType.BOOLEAN>;
		updateTransformFromObject: ParamTemplate<ParamType.BUTTON>;
	};
} & typeof NodeParamsConfig;
declare class TransformedObjParamConfig extends TransformedObjParamConfig_base {
}
declare abstract class BaseLightTransformedObjNode<L extends Object3D, K extends TransformedObjParamConfig> extends TypedLightObjNode<L, K> {
	readonly flags: FlagsControllerD;
	readonly hierarchyController: HierarchyController;
	readonly transformController: TransformController;
	initializeBaseNode(): void;
	cook(): Promise<void>;
}
declare enum LightType {
	AREA = "areaLight",
	DIRECTIONAL = "directionalLight",
	HEMISPHERE = "hemisphereLight",
	POINT = "pointLight",
	PROBE = "lightProbe",
	SPOT = "spotLight"
}
declare const AreaLightObjParamsConfig_base: {
	new (...args: any[]): {
		light: ParamTemplate<ParamType.FOLDER>;
		color: ParamTemplate<ParamType.COLOR>;
		intensity: ParamTemplate<ParamType.FLOAT>;
		width: ParamTemplate<ParamType.FLOAT>;
		height: ParamTemplate<ParamType.FLOAT>;
		showHelper: ParamTemplate<ParamType.BOOLEAN>;
		name: ParamTemplate<ParamType.STRING>;
	};
} & {
	new (...args: any[]): {
		transform: ParamTemplate<ParamType.FOLDER>;
		keepPosWhenParenting: ParamTemplate<ParamType.BOOLEAN>;
		rotationOrder: ParamTemplate<ParamType.INTEGER>;
		t: ParamTemplate<ParamType.VECTOR3>;
		r: ParamTemplate<ParamType.VECTOR3>;
		s: ParamTemplate<ParamType.VECTOR3>;
		scale: ParamTemplate<ParamType.FLOAT>;
		matrixAutoUpdate: ParamTemplate<ParamType.BOOLEAN>;
		updateTransformFromObject: ParamTemplate<ParamType.BUTTON>;
	};
} & typeof NodeParamsConfig;
declare class AreaLightObjParamsConfig extends AreaLightObjParamsConfig_base {
}
declare class AreaLightObjNode extends BaseLightTransformedObjNode<RectAreaLight, AreaLightObjParamsConfig> {
	paramsConfig: AreaLightObjParamsConfig;
	static type(): LightType;
	private __operation__;
	private _operation;
	createLight(): RectAreaLight;
	protected updateLightParams(): void;
	private _helper;
}
interface DirectionalLightContainerParams {
	showHelper: boolean;
}
declare class DirectionalLightContainer extends Group {
	readonly nodeName: string;
	private _light;
	private _target;
	showHelper: boolean;
	matrixAutoUpdate: boolean;
	constructor(options: DirectionalLightContainerParams, nodeName: string);
	light(): DirectionalLight;
	copy(source: this, recursive?: boolean): this;
	clone(recursive?: boolean): this;
	updateHelper(): void;
	private __helper__;
}
declare const DirectionalLightObjParamsConfig_base: {
	new (...args: any[]): {
		light: ParamTemplate<ParamType.FOLDER>;
		color: ParamTemplate<ParamType.COLOR>;
		intensity: ParamTemplate<ParamType.FLOAT>;
		distance: ParamTemplate<ParamType.FLOAT>;
		showHelper: ParamTemplate<ParamType.BOOLEAN>;
		name: ParamTemplate<ParamType.STRING>;
		shadow: ParamTemplate<ParamType.FOLDER>;
		castShadow: ParamTemplate<ParamType.BOOLEAN>;
		shadowAutoUpdate: ParamTemplate<ParamType.BOOLEAN>;
		shadowUpdateOnNextRender: ParamTemplate<ParamType.BOOLEAN>;
		shadowRes: ParamTemplate<ParamType.VECTOR2>;
		shadowSize: ParamTemplate<ParamType.VECTOR2>;
		shadowBias: ParamTemplate<ParamType.FLOAT>;
		shadowRadius: ParamTemplate<ParamType.FLOAT>;
		raymarching: ParamTemplate<ParamType.FOLDER>;
		raymarchingPenumbra: ParamTemplate<ParamType.FLOAT>;
		raymarchingShadowBiasAngle: ParamTemplate<ParamType.FLOAT>;
		raymarchingShadowBiasDistance: ParamTemplate<ParamType.FLOAT>;
	};
} & {
	new (...args: any[]): {
		transform: ParamTemplate<ParamType.FOLDER>;
		keepPosWhenParenting: ParamTemplate<ParamType.BOOLEAN>;
		rotationOrder: ParamTemplate<ParamType.INTEGER>;
		t: ParamTemplate<ParamType.VECTOR3>;
		r: ParamTemplate<ParamType.VECTOR3>;
		s: ParamTemplate<ParamType.VECTOR3>;
		scale: ParamTemplate<ParamType.FLOAT>;
		matrixAutoUpdate: ParamTemplate<ParamType.BOOLEAN>;
		updateTransformFromObject: ParamTemplate<ParamType.BUTTON>;
	};
} & typeof NodeParamsConfig;
declare class DirectionalLightObjParamsConfig extends DirectionalLightObjParamsConfig_base {
}
declare class DirectionalLightObjNode extends BaseLightTransformedObjNode<DirectionalLightContainer, DirectionalLightObjParamsConfig> {
	paramsConfig: DirectionalLightObjParamsConfig;
	static type(): LightType;
	private __operation__;
	private _operation;
	createLight(): DirectionalLightContainer;
	protected updateLightParams(): void;
	protected updateShadowParams(): void;
}
declare const HemisphereLightObjParamsConfig_base: {
	new (...args: any[]): {
		skyColor: ParamTemplate<ParamType.COLOR>;
		groundColor: ParamTemplate<ParamType.COLOR>;
		intensity: ParamTemplate<ParamType.FLOAT>;
		position: ParamTemplate<ParamType.VECTOR3>;
		name: ParamTemplate<ParamType.STRING>;
	};
} & typeof NodeParamsConfig;
declare class HemisphereLightObjParamsConfig extends HemisphereLightObjParamsConfig_base {
}
declare class HemisphereLightObjNode extends TypedLightObjNode<HemisphereLight, HemisphereLightObjParamsConfig> {
	paramsConfig: HemisphereLightObjParamsConfig;
	static type(): LightType;
	private __operation__;
	private _operation;
	createLight(): HemisphereLight;
	protected updateLightParams(): void;
}
declare const LightProbeObjParamsConfig_base: {
	new (...args: any[]): {
		cubeMap: ParamTemplate<ParamType.NODE_PATH>;
		intensity: ParamTemplate<ParamType.FLOAT>;
		name: ParamTemplate<ParamType.STRING>;
	};
} & typeof NodeParamsConfig;
declare class LightProbeObjParamsConfig extends LightProbeObjParamsConfig_base {
}
declare class LightProbeObjNode extends TypedLightObjNode<LightProbe, LightProbeObjParamsConfig> {
	paramsConfig: LightProbeObjParamsConfig;
	static type(): LightType;
	private __operation__;
	private _operation;
	createLight(): LightProbe;
	protected updateLightParams(): Promise<void>;
}
declare const PointLightObjParamsConfig_base: {
	new (...args: any[]): {
		light: ParamTemplate<ParamType.FOLDER>;
		color: ParamTemplate<ParamType.COLOR>;
		intensity: ParamTemplate<ParamType.FLOAT>;
		decay: ParamTemplate<ParamType.FLOAT>;
		distance: ParamTemplate<ParamType.FLOAT>;
		showHelper: ParamTemplate<ParamType.BOOLEAN>;
		helperSize: ParamTemplate<ParamType.FLOAT>;
		name: ParamTemplate<ParamType.STRING>;
		shadow: ParamTemplate<ParamType.FOLDER>;
		castShadow: ParamTemplate<ParamType.BOOLEAN>;
		shadowAutoUpdate: ParamTemplate<ParamType.BOOLEAN>;
		shadowUpdateOnNextRender: ParamTemplate<ParamType.BOOLEAN>;
		shadowRes: ParamTemplate<ParamType.VECTOR2>;
		shadowBias: ParamTemplate<ParamType.FLOAT>;
		shadowNear: ParamTemplate<ParamType.FLOAT>;
		shadowFar: ParamTemplate<ParamType.FLOAT>;
		raymarching: ParamTemplate<ParamType.FOLDER>;
		raymarchingPenumbra: ParamTemplate<ParamType.FLOAT>;
		raymarchingShadowBiasAngle: ParamTemplate<ParamType.FLOAT>;
		raymarchingShadowBiasDistance: ParamTemplate<ParamType.FLOAT>;
	};
} & {
	new (...args: any[]): {
		transform: ParamTemplate<ParamType.FOLDER>;
		keepPosWhenParenting: ParamTemplate<ParamType.BOOLEAN>;
		rotationOrder: ParamTemplate<ParamType.INTEGER>;
		t: ParamTemplate<ParamType.VECTOR3>;
		r: ParamTemplate<ParamType.VECTOR3>;
		s: ParamTemplate<ParamType.VECTOR3>;
		scale: ParamTemplate<ParamType.FLOAT>;
		matrixAutoUpdate: ParamTemplate<ParamType.BOOLEAN>;
		updateTransformFromObject: ParamTemplate<ParamType.BUTTON>;
	};
} & typeof NodeParamsConfig;
declare class PointLightObjParamsConfig extends PointLightObjParamsConfig_base {
}
declare class PointLightObjNode extends BaseLightTransformedObjNode<PointLight, PointLightObjParamsConfig> {
	paramsConfig: PointLightObjParamsConfig;
	static type(): LightType;
	private _helperController;
	initializeNode(): void;
	private __operation__;
	private _operation;
	createLight(): PointLight;
	protected updateLightParams(): void;
	protected updateShadowParams(): void;
}
interface CoreSpotLightHelperParams {
	helperSize: number;
}
interface SpotLightContainerParams extends CoreSpotLightHelperParams {
	showHelper: boolean;
	tvolumetric: boolean;
	volAnglePower: number;
	volAttenuation: number;
}
declare class SpotLightContainer extends Group {
	readonly nodeName: string;
	private _light;
	private _target;
	matrixAutoUpdate: boolean;
	params: SpotLightContainerParams;
	constructor(params: Partial<SpotLightContainerParams>, nodeName: string);
	updateParams(params: Partial<SpotLightContainerParams>): void;
	light(): SpotLight;
	copy(source: this, recursive?: boolean): this;
	clone(recursive?: boolean): this;
	private __helper__;
	updateHelper(): void;
	private __volumetric__;
	updateVolumetric(): void;
}
declare const SpotLightObjParamsConfig_base: {
	new (...args: any[]): {
		light: ParamTemplate<ParamType.FOLDER>;
		color: ParamTemplate<ParamType.COLOR>;
		intensity: ParamTemplate<ParamType.FLOAT>;
		angle: ParamTemplate<ParamType.FLOAT>;
		penumbra: ParamTemplate<ParamType.FLOAT>;
		decay: ParamTemplate<ParamType.FLOAT>;
		distance: ParamTemplate<ParamType.FLOAT>;
		showHelper: ParamTemplate<ParamType.BOOLEAN>;
		helperSize: ParamTemplate<ParamType.FLOAT>;
		tmap: ParamTemplate<ParamType.BOOLEAN>;
		map: ParamTemplate<ParamType.NODE_PATH>;
		name: ParamTemplate<ParamType.STRING>;
		shadow: ParamTemplate<ParamType.FOLDER>;
		castShadow: ParamTemplate<ParamType.BOOLEAN>;
		shadowAutoUpdate: ParamTemplate<ParamType.BOOLEAN>;
		shadowUpdateOnNextRender: ParamTemplate<ParamType.BOOLEAN>;
		shadowRes: ParamTemplate<ParamType.VECTOR2>;
		shadowBias: ParamTemplate<ParamType.FLOAT>;
		shadowNear: ParamTemplate<ParamType.FLOAT>;
		shadowFar: ParamTemplate<ParamType.FLOAT>;
		shadowRadius: ParamTemplate<ParamType.FLOAT>;
		volumetric: ParamTemplate<ParamType.FOLDER>;
		tvolumetric: ParamTemplate<ParamType.BOOLEAN>;
		volAttenuation: ParamTemplate<ParamType.FLOAT>;
		volAnglePower: ParamTemplate<ParamType.FLOAT>;
		raymarching: ParamTemplate<ParamType.FOLDER>;
		raymarchingPenumbra: ParamTemplate<ParamType.FLOAT>;
		raymarchingShadowBiasAngle: ParamTemplate<ParamType.FLOAT>;
		raymarchingShadowBiasDistance: ParamTemplate<ParamType.FLOAT>;
	};
} & {
	new (...args: any[]): {
		transform: ParamTemplate<ParamType.FOLDER>;
		keepPosWhenParenting: ParamTemplate<ParamType.BOOLEAN>;
		rotationOrder: ParamTemplate<ParamType.INTEGER>;
		t: ParamTemplate<ParamType.VECTOR3>;
		r: ParamTemplate<ParamType.VECTOR3>;
		s: ParamTemplate<ParamType.VECTOR3>;
		scale: ParamTemplate<ParamType.FLOAT>;
		matrixAutoUpdate: ParamTemplate<ParamType.BOOLEAN>;
		updateTransformFromObject: ParamTemplate<ParamType.BUTTON>;
	};
} & typeof NodeParamsConfig;
declare class SpotLightObjParamsConfig extends SpotLightObjParamsConfig_base {
}
declare class SpotLightObjNode extends BaseLightTransformedObjNode<SpotLightContainer, SpotLightObjParamsConfig> {
	paramsConfig: SpotLightObjParamsConfig;
	static type(): LightType;
	private __operation__;
	private _operation;
	createLight(): SpotLightContainer;
	protected updateLightParams(): Promise<void>;
	protected updateShadowParams(): void;
}
declare enum ObjType {
	GEO = "geo",
	CUBE_CAMERA = "cubeCamera",
	AUDIO_LISTENER = "audioListener",
	POSITIONAL_AUDIO = "positionalAudio",
	SCENE = "scene"
}
declare enum DistanceModel {
	LINEAR = "linear",
	INVERSE = "inverse",
	EXPONENTIAL = "exponential"
}
declare class CorePositionalAudio extends Object3D {
	private tonePanner;
	private pannerNode;
	listenerTransformAutoUpdate: boolean;
	constructor();
	disconnect(): void;
	private _currentAudioNode;
	setInput(audioNode: ToneAudioNode | undefined): void;
	connect(audioNode: ToneAudioNode): void;
	getRefDistance(): number;
	setRefDistance(value: number): this;
	getRolloffFactor(): number;
	setRolloffFactor(value: number): this;
	getDistanceModel(): DistanceModelType;
	setDistanceModel(value: DistanceModel): this;
	getMaxDistance(): number;
	setMaxDistance(value: number): this;
	setDirectionalCone(coneInnerAngle: number, coneOuterAngle: number, coneOuterGain: number): this;
	coneInnerAngle(): number;
	coneOuterAngle(): number;
	updateMatrixWorld(force: boolean): void;
}
declare class CoreAudioListener extends Object3D {
	private context;
	private timeDelta;
	private _clock;
	private gain;
	listenerTransformAutoUpdate: boolean;
	constructor();
	addInput(positionalAudioNode: CorePositionalAudio): Promise<void>;
	dispose(): void;
	setMasterVolume(value: number): this;
	masterVolume(): number;
	updateMatrixWorld(force: boolean): void;
}
declare const AudioListenerParamConfig_base: {
	new (...args: any[]): {
		transform: ParamTemplate<ParamType.FOLDER>;
		keepPosWhenParenting: ParamTemplate<ParamType.BOOLEAN>;
		rotationOrder: ParamTemplate<ParamType.INTEGER>;
		t: ParamTemplate<ParamType.VECTOR3>;
		r: ParamTemplate<ParamType.VECTOR3>;
		s: ParamTemplate<ParamType.VECTOR3>;
		scale: ParamTemplate<ParamType.FLOAT>;
		matrixAutoUpdate: ParamTemplate<ParamType.BOOLEAN>;
		updateTransformFromObject: ParamTemplate<ParamType.BUTTON>;
	};
} & typeof NodeParamsConfig;
declare class AudioListenerParamConfig extends AudioListenerParamConfig_base {
	audio: ParamTemplate<ParamType.FOLDER>;
	/** @param soundOn */
	soundOn: ParamTemplate<ParamType.BOOLEAN>;
	/** @param volume */
	masterVolume: ParamTemplate<ParamType.FLOAT>;
	/** @param ensures the transform of the audio listener is updated on very frame */
	listenerTransformAutoUpdate: ParamTemplate<ParamType.BOOLEAN>;
}
declare class AudioListenerObjNode extends TypedObjNode<CoreAudioListener, AudioListenerParamConfig> {
	paramsConfig: AudioListenerParamConfig;
	static type(): ObjType;
	readonly hierarchyController: HierarchyController;
	readonly transformController: TransformController;
	readonly flags: FlagsControllerD;
	createObject(): CoreAudioListener;
	initializeNode(): void;
	dispose(): void;
	toggleSound(): void;
	private _setPositionalAudioNodesDirty;
	cook(): void;
	private _validateUniq;
	private _updateAudioListener;
	private _updateViewers;
	private _updateListenerAndViewers;
	static PARAM_CALLBACK_update(node: AudioListenerObjNode): void;
	private static _eventsAdded;
	private static _audioActivated;
	private _onpointerdown;
	private _onkeypress;
	static soundActivated(): boolean;
	soundActivated(): boolean;
	activateSound(): Promise<void>;
	private _boundEvents;
	addAudioActivationEvents(): void;
	private _removeAudioActivationEvents;
}
declare class BlendObjParamConfig extends NodeParamsConfig {
	/** @param object to blend transform from */
	object0: ParamTemplate<ParamType.NODE_PATH>;
	/** @param object to blend transform to */
	object1: ParamTemplate<ParamType.NODE_PATH>;
	/** @param blend mode */
	mode: ParamTemplate<ParamType.INTEGER>;
	/** @param blend value */
	blend: ParamTemplate<ParamType.FLOAT>;
	/** @param blend translation value */
	blendT: ParamTemplate<ParamType.FLOAT>;
	/** @param blend rotation value */
	blendR: ParamTemplate<ParamType.FLOAT>;
	/** @param updateOnRender */
	updateOnRender: ParamTemplate<ParamType.BOOLEAN>;
}
declare class BlendObjNode extends TypedObjNode<Mesh, BlendObjParamConfig> {
	paramsConfig: BlendObjParamConfig;
	static type(): string;
	readonly hierarchyController: HierarchyController;
	readonly flags: FlagsControllerD;
	private _helper;
	createObject(): Mesh<BufferGeometry<NormalBufferAttributes>, Material | Material[]>;
	initializeNode(): void;
	private _updateHelperHierarchy;
	private _object0;
	private _object1;
	cook(): Promise<void>;
	private _onBeforeRender;
	private _computeBlendedMatrix;
	private _t0;
	private _q0;
	private _s0;
	private _t1;
	private _q1;
	private _s1;
	private _blendTogether;
	private _blendSeparately;
	private _decomposeMatrices;
	private _updateMatrix;
}
declare enum SopType {
	ACTOR = "actor",
	ACTOR_INSTANCE = "actorInstance",
	ACTOR_POINT = "actorPoint",
	ADD = "add",
	ADJACENCY = "adjacency",
	ANIMATION_COPY = "animationCopy",
	ATTRIB_ADD_MULT = "attribAddMult",
	ATTRIB_COPY = "attribCopy",
	ATTRIB_CREATE = "attribCreate",
	ATTRIB_DELETE = "attribDelete",
	ATTRIB_ID = "attribId",
	ATTRIB_PROMOTE = "attribPromote",
	ATTRIB_RENAME = "attribRename",
	ATTRIB_SET_AT_INDEX = "attribSetAtIndex",
	ATTRIB_TRANSFER = "attribTransfer",
	AUDIO_NOTES = "audioNotes",
	AXES_HELPER = "axesHelper",
	BBOX_SCATTER = "bboxScatter",
	BLEND = "blend",
	BOX = "box",
	BOX_LINES = "boxLines",
	BVH = "BVH",
	BVH_VISUALIZER = "BVHVisualizer",
	CACHE = "cache",
	CAD_BOOLEAN = "CADBoolean",
	CAD_BOX = "CADBox",
	CAD_CIRCLE = "CADCircle",
	CAD_CIRCLE_2D = "CADCircle2D",
	CAD_CIRCLE_3_POINTS = "CADCircle3Points",
	CAD_CONE = "CADCone",
	CAD_CONVERT_DIMENSION = "CADConvertDimension",
	CAD_CURVE_2D_TO_SURFACE = "CADCurve2DToSurface",
	CAD_CURVE_FROM_POINTS = "CADCurveFromPoints",
	CAD_CURVE_FROM_POINTS_2D = "CADCurveFromPoints2D",
	CAD_CURVE_TRIM = "CADCurveTrim",
	CAD_ELLIPSE = "CADEllipse",
	CAD_ELLIPSE_2D = "CADEllipse2D",
	CAD_EXPORTER_STEP = "CADExporterSTEP",
	CAD_EXTRUDE = "CADExtrude",
	CAD_FILE_STEP = "CADFileSTEP",
	CAD_FILLET = "CADFillet",
	CAD_GROUP = "CADGroup",
	CAD_LOFT = "CADLoft",
	CAD_MIRROR = "CADMirror",
	CAD_PIPE = "CADPipe",
	CAD_POINT = "CADPoint",
	CAD_POINT_2D = "CADPoint2D",
	CAD_POINTS_FROM_CURVE = "CADPointsFromCurve",
	CAD_RECTANGLE = "CADRectangle",
	CAD_REVOLUTION = "CADRevolution",
	CAD_SEGMENT = "CADSegment",
	CAD_SPHERE = "CADSphere",
	CAD_THICKNESS = "CADThickness",
	CAD_TORUS = "CADTorus",
	CAD_TRANSFORM = "CADTransform",
	CAD_TRANSFORM_2D = "CADTransform2D",
	CAD_TRIANGULATE = "CADTriangulate",
	CAD_TUBE = "CADTube",
	CAD_UNPACK = "CADUnpack",
	CAD_WEDGE = "CADWedge",
	CAMERA_PROJECT = "cameraProject",
	CAPSULE = "capsule",
	CIRCLE = "circle",
	CIRCLE_3_POINTS = "circle3Points",
	CLOTH_PREPARE = "clothPrepare",
	CLOTH_SOLVER = "clothSolver",
	COLOR = "color",
	CONE = "cone",
	CONTACT_SHADOWS = "contactShadows",
	COPY = "copy",
	CURVE_FROM_POINTS = "curveFromPoints",
	CSG_ARC = "CSGArc",
	CSG_BOOLEAN = "CSGBoolean",
	CSG_CENTER = "CSGCenter",
	CSG_CIRCLE = "CSGCircle",
	CSG_BOX = "CSGBox",
	CSG_DODECAHEDRON = "CSGDodecahedron",
	CSG_ELLIPSE = "CSGEllipse",
	CSG_ELLIPSOID = "CSGEllipsoid",
	CSG_EXPAND = "CSGExpand",
	CSG_EXTRUDE_LINEAR = "CSGExtrudeLinear",
	CSG_EXTRUDE_RECTANGULAR = "CSGExtrudeRectangular",
	CSG_EXTRUDE_ROTATE = "CSGExtrudeRotate",
	CSG_HULL = "CSGHull",
	CSG_LINE = "CSGLine",
	CSG_MIRROR = "CSGMirror",
	CSG_OFFSET = "CSGOffset",
	CSG_POLYGON = "CSGPolygon",
	CSG_POLYHEDRON = "CSGPolyhedron",
	CSG_PROJECT = "CSGProject",
	CSG_RECTANGLE = "CSGRectangle",
	CSG_SPHERE = "CSGSphere",
	CSG_STAR = "CSGStar",
	CSG_TORUS = "CSGTorus",
	CSG_TRANSFORM_2D = "CSGTransform2D",
	CSG_TRANSFORM_RESET = "CSGTransformReset",
	CSG_TRIANGLE = "CSGTriangle",
	CSG_TRIANGULATE = "CSGTriangulate",
	CSG_TUBE = "CSGTube",
	CSG_TUBE_ELLIPTIC = "CSGTubeElliptic",
	CSS2D_OBJECT = "CSS2DObject",
	CSS3D_OBJECT = "CSS3DObject",
	DATA = "data",
	DATA_URL = "dataUrl",
	DECAL = "decal",
	DELETE = "delete",
	DELETE_BY_NAME = "deleteByName",
	FACET = "facet",
	FUSE = "fuse",
	GROUND_PROJECTED_SKYBOX = "groundProjectedSkybox",
	HIERARCHY = "hierarchy",
	ICOSAHEDRON = "icosahedron",
	IFC_FILTER_CATEGORIES = "IFCFilterCategories",
	INSTANCE = "instance",
	INSTANCE_BUILDER = "instanceBuilder",
	INSTANCE_UPDATE = "instanceUpdate",
	JITTER = "jitter",
	LATTICE = "lattice",
	LAYER = "layer",
	LOD = "lod",
	LOOK_AT = "lookAt",
	MAPBOX_TRANSFORM = "mapboxTransform",
	MATERIAL = "material",
	MATERIAL_PROPERTIES = "materialProperties",
	MERGE = "merge",
	METABALL = "metaball",
	MIRROR = "mirror",
	NOISE = "noise",
	NORMALS = "normals",
	NORMALS_HELPER = "normalsHelper",
	OBJECT_BUILDER = "objectBuilder",
	OBJECT_PROPERTIES = "objectProperties",
	OBJECTS_LAYOUT = "objectsLayout",
	PALETTE = "palette",
	PARTICLES_SYSTEM_GPU = "particlesSystemGpu",
	PARTICLES_SYSTEM_GPU_ATTRIBUTES = "particlesSystemGpuAttributes",
	PARTICLES_SYSTEM_GPU_MATERIAL = "particlesSystemGpuMaterial",
	PHYSICS_DEBUG = "physicsDebug",
	PHYSICS_GROUND = "physicsGround",
	PHYSICS_RBD_ATTRIBUTES = "physicsRBDAttributes",
	PHYSICS_RBD_JOINTS = "physicsRBDJoints",
	PHYSICS_WORLD = "physicsWorld",
	PHYSICS_PLAYER = "physicsPlayer",
	PLANE = "plane",
	POINT = "point",
	POINT_BUILDER = "pointBuilder",
	POLAR_TRANSFORM = "polarTransform",
	POLYWIRE = "polywire",
	QUAD_PLANE = "quadPlane",
	QUAD_SMOOTH = "quadSmooth",
	QUAD_TRIANGULATE = "quadTriangulate",
	QUADRANGULATE = "quadrangulate",
	RAY = "ray",
	REFLECTOR = "reflector",
	RING = "ring",
	ROUNDED_BOX = "roundedBox",
	SCATTER = "scatter",
	SDF_BUILDER = "SDFBuilder",
	SET_CHILDREN = "setChildren",
	SET_GEOMETRY = "setGeometry",
	SHEAR = "shear",
	SHORTEST_PATH = "shortestPath",
	SKELETON_HELPER = "skeletonHelper",
	SKIN = "skin",
	SORT = "sort",
	SPHERE = "sphere",
	SPLIT = "split",
	SUBDIVIDE = "subdivide",
	SWITCH = "switch",
	TANGENT = "tangent",
	TANGENTS_HELPER = "tangentsHelper",
	TET_DELETE = "tetDelete",
	TET_EMBED = "tetEmbed",
	TET_SOFT_BODY_SOLVER = "tetSoftBodySolver",
	TET_TRIANGULATE = "tetTriangulate",
	TETRAHEDRALIZE = "tetrahedralize",
	TETRAHEDRON = "tetrahedron",
	TEXT = "text",
	TEXTURE_COPY = "textureCopy",
	TEXTURE_PROPERTIES = "textureProperties",
	TORUS = "torus",
	TORUS_KNOT = "torusKnot",
	TRANSFORM = "transform",
	TRANSFORM_COPY = "transformCopy",
	TRANSFORM_MULTI = "transformMulti",
	TRANSFORM_RESET = "transformReset",
	TUBE = "tube",
	UV_LAYOUT = "uvLayout",
	UV_TRANSFORM = "uvTransform",
	UV_UNWRAP = "uvUnwrap",
	WEB_XR_AR_ESTIMATED_LIGHT = "webXRAREstimatedLight",
	WFC_BUILDER = "WFCBuilder",
	WFC_DEBUG = "WFCDebug",
	WFC_SOLVER = "WFCSolver",
	WFC_RULE_FROM_PROXIMITY = "WFCRuleFromProximity",
	WFC_RULE_CONNECTION_FROM_SIDE_NAME = "WFCRuleConnectionFromSideName",
	WFC_RULE_CONNECTION_TO_GRID_BORDER = "WFCRuleConnectionToGridBorder",
	WFC_RULE_TILE_WEIGHT = "WFCRuleTileWeight",
	WFC_TILE_EMPTY_OBJECT = "WFCTileEmptyObject",
	WFC_TILE_ERROR_OBJECT = "WFCTileErrorObject",
	WFC_TILE_UNRESOLVED_OBJECT = "WFCTileUnresolvedObject",
	WFC_TILE_PROPERTIES = "WFCTileProperties",
	WFC_TILE_SIDE_NAME = "WFCTileSideName",
	WFC_TILE_TRANSFORM = "WFCTileTransform"
}
declare enum SopTypeFile {
	FILE_3DS = "file3DS",
	FILE_DRC = "fileDRC",
	FILE_FBX = "fileFBX",
	FILE_GEOJSON = "fileGEOJSON",
	FILE_GLTF = "fileGLTF",
	FILE_IFC = "fileIFC",
	FILE_JSON = "fileJSON",
	FILE_MPD = "fileMPD",
	FILE_OBJ = "fileOBJ",
	FILE_PDB = "filePDB",
	FILE_PLY = "filePLY",
	FILE_STL = "fileSTL",
	FILE_SVG = "fileSVG",
	FILE_USDZ = "fileUSDZ",
	FILE_VOX = "fileVOX"
}
declare enum SopTypeFileMulti {
	FILE_DRC = "fileMultiDRC",
	FILE_FBX = "fileMultiFBX",
	FILE_GLTF = "fileMultiGLTF",
	FILE_JSON = "fileMultiJSON",
	FILE_MPD = "fileMultiMPD",
	FILE_OBJ = "fileMultiOBJ",
	FILE_PDB = "fileMultiPDB",
	FILE_PLY = "fileMultiPLY",
	FILE_STL = "fileMultiSTL",
	FILE_SVG = "fileMultiSVG"
}
declare enum SopExporter {
	EXPORTER_GLTF = "exporterGLTF",
	EXPORTER_OBJ = "exporterOBJ",
	EXPORTER_PLY = "exporterPLY",
	EXPORTER_STL = "exporterSTL",
	EXPORTER_USDZ = "exporterUSDZ"
}
declare class BaseJsMathFunctionParamsConfig extends NodeParamsConfig {
}
declare abstract class BaseMathFunctionJsNode extends TypedJsNode<BaseJsMathFunctionParamsConfig> {
	paramsConfig: BaseJsMathFunctionParamsConfig;
	initializeNode(): void;
	protected _expectedInputTypes(): JsConnectionPointType[];
	protected _expectedOutputTypes(): JsConnectionPointType[];
	protected _expectedInputName(index: number): string;
	protected _expectedOutputName(index: number): string;
}
declare const AbsJsNode_base: typeof BaseMathFunctionJsNode;
declare class AbsJsNode extends AbsJsNode_base {
}
declare const AcosJsNode_base: typeof BaseMathFunctionJsNode;
declare class AcosJsNode extends AcosJsNode_base {
}
declare const AddJsNode_base: typeof BaseMathFunctionJsNode;
declare class AddJsNode extends AddJsNode_base {
}
// @ts-ignore
type AllowedType = JsConnectionPointType.BOOLEAN | JsConnectionPointType.BOOLEAN_ARRAY;
declare abstract class BaseLogicOperationJsNode extends ParamlessTypedJsNode {
	initializeNode(): void;
	protected _expectedInputName(index: number): string;
	protected _expectedInputTypes(): AllowedType[];
	protected _expectedOutputTypes(): JsConnectionPointType[];
	protected abstract _expectedOutputName(index: number): string;
	protected abstract _functionName(firstType: AllowedType): "orBooleans" | "orArrays" | "andBooleans" | "andArrays";
	setLines(shadersCollectionController: JsLinesCollectionController): void;
}
declare class AndJsNode extends BaseLogicOperationJsNode {
	static type(): string;
	protected _expectedOutputName(): string;
	protected _functionName(firstType: AllowedType): "andArrays" | "andBooleans";
}
declare class AnimationActionJsParamsConfig extends NodeParamsConfig {
	clipName: ParamTemplate<ParamType.STRING>;
	autoPlay: ParamTemplate<ParamType.BOOLEAN>;
}
declare class AnimationActionJsNode extends TypedJsNode<AnimationActionJsParamsConfig> {
	readonly paramsConfig: AnimationActionJsParamsConfig;
	static type(): string;
	static readonly OUTPUT_NAME = "val";
	initializeNode(): void;
	setLines(shadersCollectionController: JsLinesCollectionController): void;
}
declare class AnimationActionCrossFadeJsParamsConfig extends NodeParamsConfig {
	/** @param fadeIn duration */
	duration: ParamTemplate<ParamType.FLOAT>;
	/** @param additional warping (gradually changes of the time scales) will be applied */
	warp: ParamTemplate<ParamType.BOOLEAN>;
	/** @param starts cross fade when the from action ends */
	startOnFromActionEnd: ParamTemplate<ParamType.BOOLEAN>;
}
declare class AnimationActionCrossFadeJsNode extends TypedJsNode<AnimationActionCrossFadeJsParamsConfig> {
	readonly paramsConfig: AnimationActionCrossFadeJsParamsConfig;
	static type(): string;
	initializeNode(): void;
	setTriggerableLines(shadersCollectionController: JsLinesCollectionController): void;
}
declare class AnimationActionFadeOutJsParamsConfig extends NodeParamsConfig {
	/** @param manual trigger */
	/** @param fadeIn duration */
	duration: ParamTemplate<ParamType.FLOAT>;
}
declare class AnimationActionFadeOutJsNode extends TypedJsNode<AnimationActionFadeOutJsParamsConfig> {
	readonly paramsConfig: AnimationActionFadeOutJsParamsConfig;
	static type(): string;
	initializeNode(): void;
	setTriggerableLines(shadersCollectionController: JsLinesCollectionController): void;
}
declare class AnimationActionFadeInJsParamsConfig extends NodeParamsConfig {
	/** @param fadeIn duration */
	duration: ParamTemplate<ParamType.FLOAT>;
	/** @param fade out other actions */
	fadeOutOtherActions: ParamTemplate<ParamType.BOOLEAN>;
	/** @param additional warping (gradually changes of the time scales) will be applied */
	warp: ParamTemplate<ParamType.BOOLEAN>;
	/** @param starts cross fade when the from action ends */
	startOnFromActionEnd: ParamTemplate<ParamType.BOOLEAN>;
}
declare class AnimationActionFadeInJsNode extends TypedJsNode<AnimationActionFadeInJsParamsConfig> {
	readonly paramsConfig: AnimationActionFadeInJsParamsConfig;
	static type(): string;
	initializeNode(): void;
	setTriggerableLines(shadersCollectionController: JsLinesCollectionController): void;
}
declare class AnimationActionPlayJsParamsConfig extends NodeParamsConfig {
}
declare class AnimationActionPlayJsNode extends TypedJsNode<AnimationActionPlayJsParamsConfig> {
	readonly paramsConfig: AnimationActionPlayJsParamsConfig;
	static type(): string;
	initializeNode(): void;
	setTriggerableLines(shadersCollectionController: JsLinesCollectionController): void;
}
declare class AnimationActionStopJsParamsConfig extends NodeParamsConfig {
}
declare class AnimationActionStopJsNode extends TypedJsNode<AnimationActionStopJsParamsConfig> {
	readonly paramsConfig: AnimationActionStopJsParamsConfig;
	static type(): string;
	initializeNode(): void;
	setTriggerableLines(shadersCollectionController: JsLinesCollectionController): void;
}
declare class AnimationMixerJsParamsConfig extends NodeParamsConfig {
}
declare class AnimationMixerJsNode extends TypedJsNode<AnimationMixerJsParamsConfig> {
	readonly paramsConfig: AnimationMixerJsParamsConfig;
	static type(): JsType;
	static readonly OUTPUT_NAME = "val";
	initializeNode(): void;
	setLines(shadersCollectionController: JsLinesCollectionController): void;
}
declare class AnimationMixerUpdateJsParamsConfig extends NodeParamsConfig {
}
declare class AnimationMixerUpdateJsNode extends TypedJsNode<AnimationMixerUpdateJsParamsConfig> {
	readonly paramsConfig: AnimationMixerUpdateJsParamsConfig;
	static type(): JsType;
	initializeNode(): void;
	setTriggerableLines(shadersCollectionController: JsLinesCollectionController): void;
}
declare class AnyTriggerJsParamsConfig extends NodeParamsConfig {
	/** @param audio node */
	condition: ParamTemplate<ParamType.BOOLEAN>;
}
declare class AnyTriggerJsNode extends TypedJsNode<AnyTriggerJsParamsConfig> {
	readonly paramsConfig: AnyTriggerJsParamsConfig;
	static type(): string;
	initializeNode(): void;
	protected _expectedInputTypes(): any[];
	protected _expectedOutputTypes(): JsConnectionPointType[];
	protected _expectedInputName(index: number): string;
	protected _expectedOutputName(index: number): string;
	setTriggerableLines(shadersCollectionController: JsLinesCollectionController): void;
}
declare class BaseArrayElementJsNode<T extends NodeParamsConfig> extends TypedJsNode<T> {
	initializeNode(): void;
	protected _expectedInputTypes(): JsConnectionPointType[];
	protected _expectedInputName(index: number): string;
	protected _expectedOutputName(index: number): string;
	protected _expectedOutputTypes(): (JsConnectionPointType.ANIMATION_MIXER | JsConnectionPointType.ANIMATION_ACTION | JsConnectionPointType.BOOLEAN | JsConnectionPointType.BOX3 | JsConnectionPointType.CAMERA | JsConnectionPointType.CATMULL_ROM_CURVE3 | JsConnectionPointType.COLOR | JsConnectionPointType.EULER | JsConnectionPointType.FLOAT | JsConnectionPointType.INT | JsConnectionPointType.INTERSECTION | JsConnectionPointType.MATERIAL | JsConnectionPointType.MATRIX4 | JsConnectionPointType.NODE | JsConnectionPointType.OBJECT_3D | JsConnectionPointType.PARAM | JsConnectionPointType.PLANE | JsConnectionPointType.QUATERNION | JsConnectionPointType.RAY | JsConnectionPointType.SPHERE | JsConnectionPointType.STRING | JsConnectionPointType.TEXTURE | JsConnectionPointType.TRIGGER | JsConnectionPointType.VECTOR2 | JsConnectionPointType.VECTOR3 | JsConnectionPointType.VECTOR4)[];
	setLines(linesController: JsLinesCollectionController): void;
	protected _setLinesAsPrimitive(linesController: JsLinesCollectionController): void;
	protected _setLinesAsVector(linesController: JsLinesCollectionController): void;
}
declare class ArrayElementJsParamsConfig extends NodeParamsConfig {
	index: ParamTemplate<ParamType.INTEGER>;
}
declare class ArrayElementJsNode extends BaseArrayElementJsNode<ArrayElementJsParamsConfig> {
	readonly paramsConfig: ArrayElementJsParamsConfig;
	static type(): string;
	protected _expectedInputTypes(): [
		JsConnectionPointTypeArray,
		JsConnectionPointType
	];
	protected _expectedInputName(index: number): string;
	protected _setLinesAsPrimitive(linesController: JsLinesCollectionController): void;
	protected _setLinesAsVector(linesController: JsLinesCollectionController): void;
}
declare class ArrayLengthJsParamsConfig extends NodeParamsConfig {
}
declare class ArrayLengthJsNode extends TypedJsNode<ArrayLengthJsParamsConfig> {
	readonly paramsConfig: ArrayLengthJsParamsConfig;
	static type(): string;
	initializeNode(): void;
	protected _expectedInputTypes(): JsConnectionPointTypeArray[];
	protected _expectedInputName(index: number): string;
	protected _expectedOutputName(index: number): string;
	protected _expectedOutputTypes(): JsConnectionPointType[];
	setLines(shadersCollectionController: JsLinesCollectionController): void;
}
declare class ArrayPopJsParamsConfig extends NodeParamsConfig {
}
declare class ArrayPopJsNode extends BaseArrayElementJsNode<ArrayPopJsParamsConfig> {
	readonly paramsConfig: ArrayPopJsParamsConfig;
	static type(): string;
	protected _setLinesAsPrimitive(linesController: JsLinesCollectionController): void;
	protected _setLinesAsVector(linesController: JsLinesCollectionController): void;
}
declare class ArrayShiftJsParamsConfig extends NodeParamsConfig {
}
declare class ArrayShiftJsNode extends BaseArrayElementJsNode<ArrayShiftJsParamsConfig> {
	readonly paramsConfig: ArrayShiftJsParamsConfig;
	static type(): string;
	protected _setLinesAsPrimitive(linesController: JsLinesCollectionController): void;
	protected _setLinesAsVector(linesController: JsLinesCollectionController): void;
}
declare const AsinJsNode_base: typeof BaseMathFunctionJsNode;
declare class AsinJsNode extends AsinJsNode_base {
}
declare const AtanJsNode_base: typeof BaseMathFunctionJsNode;
declare class AtanJsNode extends AtanJsNode_base {
}
declare class IntToBoolJsParamsConfig extends NodeParamsConfig {
	int: ParamTemplate<ParamType.INTEGER>;
}
declare class IntToBoolJsNode extends TypedJsNode<IntToBoolJsParamsConfig> {
	paramsConfig: IntToBoolJsParamsConfig;
	static type(): string;
	initializeNode(): void;
	setLines(shadersCollectionController: JsLinesCollectionController): void;
}
declare class BoolToIntJsParamsConfig extends NodeParamsConfig {
	bool: ParamTemplate<ParamType.INTEGER>;
}
declare class BoolToIntJsNode extends TypedJsNode<BoolToIntJsParamsConfig> {
	paramsConfig: BoolToIntJsParamsConfig;
	static type(): string;
	initializeNode(): void;
	setLines(shadersCollectionController: JsLinesCollectionController): void;
}
declare class IntToFloatJsParamsConfig extends NodeParamsConfig {
	int: ParamTemplate<ParamType.INTEGER>;
}
declare class IntToFloatJsNode extends TypedJsNode<IntToFloatJsParamsConfig> {
	paramsConfig: IntToFloatJsParamsConfig;
	static type(): string;
	initializeNode(): void;
	setLines(shadersCollectionController: JsLinesCollectionController): void;
}
declare class FloatToIntJsParamsConfig extends NodeParamsConfig {
	float: ParamTemplate<ParamType.FLOAT>;
}
declare class FloatToIntJsNode extends TypedJsNode<FloatToIntJsParamsConfig> {
	paramsConfig: FloatToIntJsParamsConfig;
	static type(): string;
	initializeNode(): void;
	setLines(shadersCollectionController: JsLinesCollectionController): void;
}
declare class Box3JsParamsConfig extends NodeParamsConfig {
	/** @param position representing the lower bound of the box */
	min: ParamTemplate<ParamType.VECTOR3>;
	/** @param position representing the upper bound of the box */
	max: ParamTemplate<ParamType.VECTOR3>;
}
declare class Box3JsNode extends TypedJsNode<Box3JsParamsConfig> {
	paramsConfig: Box3JsParamsConfig;
	static type(): string;
	initializeNode(): void;
	setLines(shadersCollectionController: JsLinesCollectionController): void;
}
declare class Box3ContainsPointJsParamsConfig extends NodeParamsConfig {
	position: ParamTemplate<ParamType.VECTOR3>;
}
declare class Box3ContainsPointJsNode extends TypedJsNode<Box3ContainsPointJsParamsConfig> {
	paramsConfig: Box3ContainsPointJsParamsConfig;
	static type(): string;
	initializeNode(): void;
	setLines(linesController: JsLinesCollectionController): void;
}
declare class Box3IntersectsBox3JsParamsConfig extends NodeParamsConfig {
}
declare class Box3IntersectsBox3JsNode extends TypedJsNode<Box3IntersectsBox3JsParamsConfig> {
	paramsConfig: Box3IntersectsBox3JsParamsConfig;
	static type(): string;
	initializeNode(): void;
	setLines(linesController: JsLinesCollectionController): void;
}
declare class Box3SetFromObjectJsParamsConfig extends NodeParamsConfig {
	/** @param precise */
	precise: ParamTemplate<ParamType.BOOLEAN>;
}
declare class Box3SetFromObjectJsNode extends TypedJsNode<Box3SetFromObjectJsParamsConfig> {
	paramsConfig: Box3SetFromObjectJsParamsConfig;
	static type(): string;
	initializeNode(): void;
	setLines(linesController: JsLinesCollectionController): void;
}
declare class CatmullRomCurve3GetPointJsParamsConfig extends NodeParamsConfig {
	t: ParamTemplate<ParamType.FLOAT>;
}
declare class CatmullRomCurve3GetPointJsNode extends TypedJsNode<CatmullRomCurve3GetPointJsParamsConfig> {
	paramsConfig: CatmullRomCurve3GetPointJsParamsConfig;
	static type(): string;
	initializeNode(): void;
	setLines(shadersCollectionController: JsLinesCollectionController): void;
}
declare const CeilJsNode_base: typeof BaseMathFunctionJsNode;
declare class CeilJsNode extends CeilJsNode_base {
}
declare const ClampJsNode_base: typeof BaseMathFunctionJsNode;
declare class ClampJsNode extends ClampJsNode_base {
	protected _coreFunction(shadersCollectionController: JsLinesCollectionController): string;
	paramDefaultValue(name: string): number;
	protected _expectedInputName(index: number): string;
	protected _expectedInputTypes(): JsConnectionPointType[];
}
declare abstract class BaseTriggerAndObjectJsNode<K extends NodeParamsConfig> extends TypedJsNode<K> {
	initializeNode(): void;
	setLines(linesController: JsLinesCollectionController): void;
	protected _additionalInputs(): JsConnectionPoint<JsConnectionPointType>[];
	protected _additionalOutputs(): JsConnectionPoint<JsConnectionPointType>[];
}
declare class BaseTriggerAndObjectJsParamsConfig extends NodeParamsConfig {
}
declare abstract class ParamlessBaseTriggerAndObjectJsNode extends BaseTriggerAndObjectJsNode<BaseTriggerAndObjectJsParamsConfig> {
	readonly paramsConfig: BaseTriggerAndObjectJsParamsConfig;
}
declare class ClothSolverResetJsNode extends ParamlessBaseTriggerAndObjectJsNode {
	static type(): string;
	setTriggerableLines(shadersCollectionController: JsLinesCollectionController): void;
}
declare class ClothSolverStepSimulationJsParamsConfig extends NodeParamsConfig {
	stepsCount: ParamTemplate<ParamType.INTEGER>;
	constraintInfluence: ParamTemplate<ParamType.FLOAT>;
	viscosity: ParamTemplate<ParamType.FLOAT>;
	spring: ParamTemplate<ParamType.FLOAT>;
}
declare class ClothSolverStepSimulationJsNode extends TypedJsNode<ClothSolverStepSimulationJsParamsConfig> {
	readonly paramsConfig: ClothSolverStepSimulationJsParamsConfig;
	static type(): string;
	initializeNode(): void;
	setLines(linesController: JsLinesCollectionController): void;
	setTriggerableLines(linesController: JsLinesCollectionController): void;
	private _refToString;
	private _addRefs;
}
declare class ClothSolverUpdateMaterialJsParamsConfig extends NodeParamsConfig {
	tSizeName: ParamTemplate<ParamType.STRING>;
	tPosition0Name: ParamTemplate<ParamType.STRING>;
	tPosition1Name: ParamTemplate<ParamType.STRING>;
	tNormalName: ParamTemplate<ParamType.STRING>;
}
declare class ClothSolverUpdateMaterialJsNode extends TypedJsNode<ClothSolverUpdateMaterialJsParamsConfig> {
	readonly paramsConfig: ClothSolverUpdateMaterialJsParamsConfig;
	static type(): string;
	initializeNode(): void;
	setTriggerableLines(linesController: JsLinesCollectionController): void;
}
declare class BaseCodeProcessor {
	protected node: BaseNodeType;
	constructor(node: BaseNodeType);
}
type ParamsValueAccessorType<T extends NodeParamsConfig> = {
	// @ts-ignore
	// @ts-ignore
	// @ts-ignore
	readonly [P in keyof T]: T[P]["value_type"];
};
type ParamsAccessorType<T extends NodeParamsConfig> = {
	// @ts-ignore
	// @ts-ignore
	// @ts-ignore
	readonly [P in keyof T]: T[P]["param_class"];
};
interface CompileOptions {
	triggerFunctionNode: boolean;
}
declare class BaseCodeJsProcessor extends BaseCodeProcessor {
	protected node: CodeJsNode;
	constructor(node: CodeJsNode);
	get pv(): ParamsValueAccessorType<CodeJsParamsConfig>;
	get p(): ParamsAccessorType<CodeJsParamsConfig>;
	get io(): IOController<NodeContext.JS>;
	initializeProcessor(): void;
	setTriggerableLines(controller: JsLinesCollectionController): void;
	inputObject3D(processor: BaseCodeJsProcessor, controller: JsLinesCollectionController): string;
	protected variableForInput(controller: JsLinesCollectionController, inputName: string): string;
	protected addTriggerableLines(controller: JsLinesCollectionController, bodyLines: string[]): void;
}
declare class CodeJsParamsConfig extends NodeParamsConfig {
	codeTypescript: ParamTemplate<ParamType.STRING>;
	codeJavascript: ParamTemplate<ParamType.STRING>;
}
declare class CodeJsNode extends TypedJsNode<CodeJsParamsConfig> {
	paramsConfig: CodeJsParamsConfig;
	static BaseCodeJsProcessor: typeof BaseCodeJsProcessor;
	static type(): JsType;
	protected _processor: BaseCodeJsProcessor | undefined;
	initializeNode(): void;
	setTriggerableLines(controller: JsLinesCollectionController): void;
	private _lastCompiledCode;
	private _compilationSuccessful;
	compiled(): boolean;
	compile(options: CompileOptions): void;
	static PARAM_CALLBACK_requestCompile(node: CodeJsNode): void;
}
declare class VecToParamsJsConfig extends NodeParamsConfig {
}
declare class BaseVecToJsNode extends TypedJsNode<VecToParamsJsConfig> {
	paramsConfig: VecToParamsJsConfig;
}
declare const Vec2ToFloatJsNode_base: typeof BaseVecToJsNode;
declare class Vec2ToFloatJsNode extends Vec2ToFloatJsNode_base {
}
declare const Vec3ToFloatJsNode_base: typeof BaseVecToJsNode;
declare class Vec3ToFloatJsNode extends Vec3ToFloatJsNode_base {
}
declare const Vec4ToFloatJsNode_base: typeof BaseVecToJsNode;
declare class Vec4ToFloatJsNode extends Vec4ToFloatJsNode_base {
}
declare class Vec3ToVec2ParamsJsConfig extends NodeParamsConfig {
	vec3: ParamTemplate<ParamType.VECTOR3>;
}
declare class Vec3ToVec2JsNode extends TypedJsNode<Vec3ToVec2ParamsJsConfig> {
	paramsConfig: Vec3ToVec2ParamsJsConfig;
	static type(): string;
	static readonly OUTPUT_NAME_VEC2 = "vec2";
	static readonly OUTPUT_NAME_Z = "z";
	initializeNode(): void;
	setLines(shadersCollectionController: JsLinesCollectionController): void;
}
declare class Vec2ToVec3ParamsJsConfig extends NodeParamsConfig {
	Vector2: ParamTemplate<ParamType.VECTOR2>;
	z: ParamTemplate<ParamType.FLOAT>;
}
declare class Vec2ToVec3JsNode extends TypedJsNode<Vec2ToVec3ParamsJsConfig> {
	paramsConfig: Vec2ToVec3ParamsJsConfig;
	static type(): string;
	static readonly OUTPUT_NAME_VEC3 = "vec3";
	initializeNode(): void;
	setLines(shadersCollectionController: JsLinesCollectionController): void;
}
declare class Vec3ToVec4ParamsJsConfig extends NodeParamsConfig {
	vec3: ParamTemplate<ParamType.VECTOR3>;
	w: ParamTemplate<ParamType.FLOAT>;
}
declare class Vec3ToVec4JsNode extends TypedJsNode<Vec3ToVec4ParamsJsConfig> {
	paramsConfig: Vec3ToVec4ParamsJsConfig;
	static type(): string;
	static readonly OUTPUT_NAME_VEC4 = "vec4";
	initializeNode(): void;
	setLines(shadersCollectionController: JsLinesCollectionController): void;
}
declare class Vec3ToColorParamsJsConfig extends NodeParamsConfig {
	vec3: ParamTemplate<ParamType.VECTOR3>;
}
declare class Vec3ToColorJsNode extends TypedJsNode<Vec3ToColorParamsJsConfig> {
	paramsConfig: Vec3ToColorParamsJsConfig;
	static type(): string;
	initializeNode(): void;
	setLines(shadersCollectionController: JsLinesCollectionController): void;
}
declare class ColorToVec3ParamsJsConfig extends NodeParamsConfig {
	color: ParamTemplate<ParamType.COLOR>;
}
declare class ColorToVec3JsNode extends TypedJsNode<ColorToVec3ParamsJsConfig> {
	paramsConfig: ColorToVec3ParamsJsConfig;
	static type(): string;
	initializeNode(): void;
	setLines(shadersCollectionController: JsLinesCollectionController): void;
}
declare enum JsCompareTestName {
	EQUAL = "Equal",
	LESS_THAN = "Less Than",
	GREATER_THAN = "Greater Than",
	LESS_THAN_OR_EQUAL = "Less Than Or Equal",
	GREATER_THAN_OR_EQUAL = "Greater Than Or Equal",
	NOT_EQUAL = "Not Equal"
}
declare enum JsCompareTestOperation {
	EQUAL = "==",
	LESS_THAN = "<",
	GREATER_THAN = ">",
	LESS_THAN_OR_EQUAL = "<=",
	GREATER_THAN_OR_EQUAL = ">=",
	NOT_EQUAL = "!="
}
declare enum CompareInputName {
	VALUE0 = "value0",
	VALUE1 = "value1"
}
declare class CompareJsParamsConfig extends NodeParamsConfig {
	test: ParamTemplate<ParamType.INTEGER>;
}
declare class CompareJsNode extends TypedJsNode<CompareJsParamsConfig> {
	paramsConfig: CompareJsParamsConfig;
	static type(): string;
	initializeNode(): void;
	setTestName(test: JsCompareTestName): void;
	testName(): JsCompareTestName;
	operator(): JsCompareTestOperation;
	protected _expectedInputName(index: number): CompareInputName;
	protected _expectedInputTypes(): JsConnectionPointType[];
	private _expectedOutputTypes;
	private _expectedOutputName;
	setLines(shadersCollectionController: JsLinesCollectionController): void;
}
declare const ComplementJsNode_base: typeof BaseMathFunctionJsNode;
declare class ComplementJsNode extends ComplementJsNode_base {
	protected _coreFunction(shadersCollectionController: JsLinesCollectionController): string;
}
declare class ComputeVelocityJsParamsConfig extends NodeParamsConfig {
	/** @param forces */
	forces: ParamTemplate<ParamType.VECTOR3>;
	/** @param velocity */
	velocity: ParamTemplate<ParamType.VECTOR3>;
	/** @param dt */
	delta: ParamTemplate<ParamType.FLOAT>;
	/** @param drag */
	drag: ParamTemplate<ParamType.FLOAT>;
}
declare class ComputeVelocityJsNode extends TypedJsNode<ComputeVelocityJsParamsConfig> {
	paramsConfig: ComputeVelocityJsParamsConfig;
	static type(): string;
	initializeNode(): void;
	setLines(linesController: JsLinesCollectionController): void;
}
declare class ConstantJsParamsConfig extends NodeParamsConfig {
	type: ParamTemplate<ParamType.INTEGER>;
	boolean: ParamTemplate<ParamType.BOOLEAN>;
	color: ParamTemplate<ParamType.COLOR>;
	float: ParamTemplate<ParamType.FLOAT>;
	int: ParamTemplate<ParamType.INTEGER>;
	string: ParamTemplate<ParamType.STRING>;
	vector2: ParamTemplate<ParamType.VECTOR2>;
	vector3: ParamTemplate<ParamType.VECTOR3>;
	vector4: ParamTemplate<ParamType.VECTOR4>;
}
declare class ConstantJsNode extends TypedJsNode<ConstantJsParamsConfig> {
	paramsConfig: ConstantJsParamsConfig;
	static type(): string;
	static readonly OUTPUT_NAME = "val";
	initializeNode(): void;
	setLines(shadersCollectionController: JsLinesCollectionController): void;
	private _currentConnectionType;
	currentParam(): BooleanParam | ColorParam | FloatParam | IntegerParam | StringParam | Vector2Param | Vector3Param | Vector4Param;
	currentValue(): string | undefined;
	setJsType(type: JsConnectionPointType): void;
}
declare class CookNodeJsParamsConfig extends NodeParamsConfig {
	/** @param  node to cook */
	node: ParamTemplate<ParamType.NODE_PATH>;
}
declare class CookNodeJsNode extends TypedJsNode<CookNodeJsParamsConfig> {
	readonly paramsConfig: CookNodeJsParamsConfig;
	static type(): string;
	initializeNode(): void;
	setTriggerableLines(shadersCollectionController: JsLinesCollectionController): void;
}
declare const CosJsNode_base: typeof BaseMathFunctionJsNode;
declare class CosJsNode extends CosJsNode_base {
}
declare class CreateClothConstraintJsParamsConfig extends NodeParamsConfig {
	index: ParamTemplate<ParamType.INTEGER>;
}
declare class CreateClothConstraintJsNode extends BaseTriggerAndObjectJsNode<CreateClothConstraintJsParamsConfig> {
	readonly paramsConfig: CreateClothConstraintJsParamsConfig;
	static type(): string;
	setTriggerableLines(linesController: JsLinesCollectionController): void;
}
declare class CreateObjectsJsParamsConfig extends NodeParamsConfig {
}
declare class CreateObjectsJsNode extends BaseTriggerAndObjectJsNode<CreateObjectsJsParamsConfig> {
	readonly paramsConfig: CreateObjectsJsParamsConfig;
	static type(): string;
	initializeNode(): void;
	private _expectedInputName;
	private _expectedOutputName;
	private _expectedInputTypes;
	private _expectedOutputTypes;
	private _isInputArray;
	private _childInputName;
	private _childOutputName;
	private _childInputType;
	setLines(linesController: JsLinesCollectionController): void;
	setTriggerableLines(linesController: JsLinesCollectionController): void;
}
declare class CreatePhysicsRBDKinematicConstraintJsParamsConfig extends NodeParamsConfig {
	anchor: ParamTemplate<ParamType.VECTOR3>;
}
declare class CreatePhysicsRBDKinematicConstraintJsNode extends BaseTriggerAndObjectJsNode<CreatePhysicsRBDKinematicConstraintJsParamsConfig> {
	readonly paramsConfig: CreatePhysicsRBDKinematicConstraintJsParamsConfig;
	static type(): string;
	protected _additionalOutputs(): JsConnectionPoint<JsConnectionPointType>[];
	setLines(linesController: JsLinesCollectionController): void;
	setTriggerableLines(linesController: JsLinesCollectionController): void;
	private _addRBDIdRef;
}
declare class CreatePhysicsRBDsJsParamsConfig extends NodeParamsConfig {
}
declare class CreatePhysicsRBDsJsNode extends BaseTriggerAndObjectJsNode<CreatePhysicsRBDsJsParamsConfig> {
	readonly paramsConfig: CreatePhysicsRBDsJsParamsConfig;
	static type(): string;
	initializeNode(): void;
	private _expectedInputName;
	private _expectedOutputName;
	private _expectedInputTypes;
	private _expectedOutputTypes;
	private _isInputArray;
	private _childInputName;
	private _childOutputName;
	private _childInputType;
	private _childOutputType;
	setLines(linesController: JsLinesCollectionController): void;
	setTriggerableLines(linesController: JsLinesCollectionController): void;
	private _addRBDIdRef;
}
declare class CreateSoftBodyConstraintJsParamsConfig extends NodeParamsConfig {
	index: ParamTemplate<ParamType.INTEGER>;
}
declare class CreateSoftBodyConstraintJsNode extends BaseTriggerAndObjectJsNode<CreateSoftBodyConstraintJsParamsConfig> {
	readonly paramsConfig: CreateSoftBodyConstraintJsParamsConfig;
	static type(): string;
	initializeNode(): void;
	setTriggerableLines(linesController: JsLinesCollectionController): void;
	setLines(linesController: JsLinesCollectionController): void;
	private _addConstraintIdRef;
}
declare enum CrossJsNodeInputName {
	VALUE0 = "v0",
	VALUE1 = "v1"
}
declare class CrossJsNode extends ParamlessTypedJsNode {
	static type(): string;
	initializeNode(): void;
	setLines(shadersCollectionController: JsLinesCollectionController): void;
	protected _expectedInputTypes(): JsConnectionPointType[];
	protected _expectedOutputTypes(): JsConnectionPointType[];
	protected _expectedInputName(index: number): CrossJsNodeInputName;
	protected _expectedOutputName(index: number): string;
	paramDefaultValue(name: string): number;
}
declare abstract class BaseUserInputJsNode<K extends NodeParamsConfig> extends TypedJsNode<K> {
	isTriggering(): boolean;
	eventEmitter(): CoreEventEmitter;
}
declare class CursorJsParamsConfig extends NodeParamsConfig {
	/** @param set which element triggers the event */
	element: ParamTemplate<ParamType.INTEGER>;
}
declare class CursorJsNode extends BaseUserInputJsNode<CursorJsParamsConfig> {
	paramsConfig: CursorJsParamsConfig;
	static type(): JsType.CURSOR;
	eventData(): EvaluatorEventData | undefined;
	eventEmitter(): CoreEventEmitter;
	setEventEmitter(emitter: CoreEventEmitter): void;
	initializeNode(): void;
	setLines(shadersCollectionController: JsLinesCollectionController): void;
}
declare class CursorToUvJsParamsConfig extends NodeParamsConfig {
	cursor: ParamTemplate<ParamType.VECTOR2>;
}
declare class CursorToUvJsNode extends TypedJsNode<CursorToUvJsParamsConfig> {
	readonly paramsConfig: CursorToUvJsParamsConfig;
	static type(): string;
	initializeNode(): void;
	setLines(linesController: JsLinesCollectionController): void;
}
declare class DebugJsParamsConfig extends NodeParamsConfig {
	displayValue: ParamTemplate<ParamType.BOOLEAN>;
	displayFrame: ParamTemplate<ParamType.BOOLEAN>;
	displayTime: ParamTemplate<ParamType.BOOLEAN>;
	displayNodePath: ParamTemplate<ParamType.BOOLEAN>;
	message: ParamTemplate<ParamType.STRING>;
	bundleByObject: ParamTemplate<ParamType.BOOLEAN>;
}
declare class DebugJsNode extends TypedJsNode<DebugJsParamsConfig> {
	readonly paramsConfig: DebugJsParamsConfig;
	static type(): string;
	initializeNode(): void;
	protected _expectedInputTypes(): [
		JsConnectionPointType
	];
	protected _expectedInputName(index: number): string;
	protected _expectedOutputName(index: number): string;
	protected _expectedOutputTypes(): [
		JsConnectionPointType
	];
	setLines(linesController: JsLinesCollectionController): void;
	setTriggerableLines(linesController: JsLinesCollectionController): void;
	private _function;
}
declare class DeformGeometryCubeLatticeJsParamsConfig extends NodeParamsConfig {
	p0: ParamTemplate<ParamType.VECTOR3>;
	p1: ParamTemplate<ParamType.VECTOR3>;
	p2: ParamTemplate<ParamType.VECTOR3>;
	p3: ParamTemplate<ParamType.VECTOR3>;
	p4: ParamTemplate<ParamType.VECTOR3>;
	p5: ParamTemplate<ParamType.VECTOR3>;
	p6: ParamTemplate<ParamType.VECTOR3>;
	p7: ParamTemplate<ParamType.VECTOR3>;
}
declare class DeformGeometryCubeLatticeJsNode extends TypedJsNode<DeformGeometryCubeLatticeJsParamsConfig> {
	readonly paramsConfig: DeformGeometryCubeLatticeJsParamsConfig;
	static type(): string;
	initializeNode(): void;
	setTriggerableLines(shadersCollectionController: JsLinesCollectionController): void;
}
declare class DeleteClothConstraintJsParamsConfig extends NodeParamsConfig {
}
declare class DeleteClothConstraintJsNode extends BaseTriggerAndObjectJsNode<DeleteClothConstraintJsParamsConfig> {
	readonly paramsConfig: DeleteClothConstraintJsParamsConfig;
	static type(): string;
	setTriggerableLines(linesController: JsLinesCollectionController): void;
}
declare class DeleteObjectJsParamsConfig extends NodeParamsConfig {
}
declare class DeleteObjectJsNode extends BaseTriggerAndObjectJsNode<DeleteObjectJsParamsConfig> {
	readonly paramsConfig: DeleteObjectJsParamsConfig;
	static type(): string;
	setTriggerableLines(linesController: JsLinesCollectionController): void;
}
declare class DeletePhysicsRBDJsParamsConfig extends NodeParamsConfig {
}
declare class DeletePhysicsRBDJsNode extends BaseTriggerAndObjectJsNode<DeletePhysicsRBDJsParamsConfig> {
	readonly paramsConfig: DeletePhysicsRBDJsParamsConfig;
	static type(): string;
	setTriggerableLines(linesController: JsLinesCollectionController): void;
}
declare class DeletePhysicsRBDKinematicConstraintJsParamsConfig extends NodeParamsConfig {
}
declare class DeletePhysicsRBDKinematicConstraintJsNode extends BaseTriggerAndObjectJsNode<DeletePhysicsRBDKinematicConstraintJsParamsConfig> {
	readonly paramsConfig: DeletePhysicsRBDKinematicConstraintJsParamsConfig;
	static type(): string;
	setTriggerableLines(linesController: JsLinesCollectionController): void;
}
declare class DeletePhysicsRBDConstraintsJsParamsConfig extends NodeParamsConfig {
}
declare class DeletePhysicsRBDConstraintsJsNode extends BaseTriggerAndObjectJsNode<DeletePhysicsRBDConstraintsJsParamsConfig> {
	readonly paramsConfig: DeletePhysicsRBDConstraintsJsParamsConfig;
	static type(): string;
	setTriggerableLines(linesController: JsLinesCollectionController): void;
}
declare class DeleteSoftBodyConstraintJsParamsConfig extends NodeParamsConfig {
	id: ParamTemplate<ParamType.INTEGER>;
}
declare class DeleteSoftBodyConstraintJsNode extends BaseTriggerAndObjectJsNode<DeleteSoftBodyConstraintJsParamsConfig> {
	readonly paramsConfig: DeleteSoftBodyConstraintJsParamsConfig;
	static type(): string;
	setTriggerableLines(shadersCollectionController: JsLinesCollectionController): void;
}
declare const DegToRadJsNode_base: typeof BaseMathFunctionJsNode;
declare class DegToRadJsNode extends DegToRadJsNode_base {
	protected _coreFunction(shadersCollectionController: JsLinesCollectionController): string;
}
declare class DeviceOrientationJsNode extends ParamlessTypedJsNode {
	static type(): string;
	initializeNode(): void;
	setLines(linesController: JsLinesCollectionController): void;
}
declare enum DistanceJsNodeInputName {
	VALUE0 = "v0",
	VALUE1 = "v1"
}
declare class DistanceJsNode extends ParamlessTypedJsNode {
	static type(): string;
	initializeNode(): void;
	setLines(shadersCollectionController: JsLinesCollectionController): void;
	protected _expectedInputTypes(): JsConnectionPointType[];
	protected _expectedOutputTypes(): JsConnectionPointType[];
	protected _expectedInputName(index: number): DistanceJsNodeInputName;
	protected _expectedOutputName(index: number): string;
	paramDefaultValue(name: string): Number3;
}
declare const DivideJsNode_base: typeof BaseMathFunctionJsNode;
declare class DivideJsNode extends DivideJsNode_base {
	paramDefaultValue(name: string): number;
}
declare enum DotJsNodeInputName {
	VALUE0 = "v0",
	VALUE1 = "v1"
}
declare class DotJsNode extends ParamlessTypedJsNode {
	static type(): string;
	initializeNode(): void;
	setLines(shadersCollectionController: JsLinesCollectionController): void;
	protected _expectedInputTypes(): JsConnectionPointType[];
	protected _expectedOutputTypes(): JsConnectionPointType[];
	protected _expectedInputName(index: number): DotJsNodeInputName;
	protected _expectedOutputName(index: number): string;
	paramDefaultValue(name: string): number;
}
declare class EasingJsParamsConfig extends NodeParamsConfig {
	type: ParamTemplate<ParamType.INTEGER>;
}
declare class EasingJsNode extends TypedJsNode<EasingJsParamsConfig> {
	readonly paramsConfig: EasingJsParamsConfig;
	static type(): string;
	initializeNode(): void;
	private _expectedInputTypes;
	private _expectedOutputTypes;
	private _expectedInputName;
	private _expectedOutputName;
	setLines(shadersCollectionController: JsLinesCollectionController): void;
}
declare class ElementsToArrayJsParamsConfig extends NodeParamsConfig {
}
declare class ElementsToArrayJsNode extends TypedJsNode<ElementsToArrayJsParamsConfig> {
	readonly paramsConfig: ElementsToArrayJsParamsConfig;
	static type(): string;
	initializeNode(): void;
	protected _expectedInputTypes(): ArrayableConnectionPointType[];
	protected _expectedInputName(index: number): string;
	protected _expectedOutputName(index: number): string;
	protected _expectedOutputTypes(): (JsConnectionPointType.BOOLEAN_ARRAY | JsConnectionPointType.COLOR_ARRAY | JsConnectionPointType.FLOAT_ARRAY | JsConnectionPointType.INT_ARRAY | JsConnectionPointType.INTERSECTION_ARRAY | JsConnectionPointType.MATRIX4_ARRAY | JsConnectionPointType.QUATERNION_ARRAY | JsConnectionPointType.STRING_ARRAY | JsConnectionPointType.TEXTURE_ARRAY | JsConnectionPointType.VECTOR2_ARRAY | JsConnectionPointType.VECTOR3_ARRAY | JsConnectionPointType.VECTOR4_ARRAY)[];
	setLines(shadersCollectionController: JsLinesCollectionController): void;
	private _setLinesAsPrimitive;
	private _setLinesAsVector;
	private _setLinesAsIntersection;
	private _setLinesAsTexture;
}
declare class EulerJsParamsConfig extends NodeParamsConfig {
	/** @param euler value */
	Euler: ParamTemplate<ParamType.VECTOR3>;
	/** @param rotation order */
	order: ParamTemplate<ParamType.INTEGER>;
}
declare class EulerJsNode extends TypedJsNode<EulerJsParamsConfig> {
	paramsConfig: EulerJsParamsConfig;
	static type(): string;
	initializeNode(): void;
	setLines(linesController: JsLinesCollectionController): void;
}
declare class EulerFromQuaternionJsParamsConfig extends NodeParamsConfig {
}
declare class EulerFromQuaternionJsNode extends TypedJsNode<EulerFromQuaternionJsParamsConfig> {
	paramsConfig: EulerFromQuaternionJsParamsConfig;
	static type(): string;
	initializeNode(): void;
	setLines(linesController: JsLinesCollectionController): void;
}
declare const FitJsNode_base: typeof BaseMathFunctionJsNode;
declare class FitJsNode extends FitJsNode_base {
	protected _coreFunction(shadersCollectionController: JsLinesCollectionController): string;
	protected _inputValuesCount(): number;
	paramDefaultValue(name: string): number;
	protected _expectedInputName(index: number): string;
	protected _expectedInputTypes(): JsConnectionPointType[];
}
declare class FloatToColorJsParamsConfig extends NodeParamsConfig {
	r: ParamTemplate<ParamType.FLOAT>;
	g: ParamTemplate<ParamType.FLOAT>;
	b: ParamTemplate<ParamType.FLOAT>;
}
declare class FloatToColorJsNode extends TypedJsNode<FloatToColorJsParamsConfig> {
	paramsConfig: FloatToColorJsParamsConfig;
	static type(): string;
	static readonly OUTPUT_NAME = "Color";
	initializeNode(): void;
	setLines(shadersCollectionController: JsLinesCollectionController): void;
}
declare class FloatToVec2JsParamsConfig extends NodeParamsConfig {
	x: ParamTemplate<ParamType.FLOAT>;
	y: ParamTemplate<ParamType.FLOAT>;
}
declare class FloatToVec2JsNode extends TypedJsNode<FloatToVec2JsParamsConfig> {
	paramsConfig: FloatToVec2JsParamsConfig;
	static type(): string;
	static readonly OUTPUT_NAME = "vec2";
	initializeNode(): void;
	setLines(shadersCollectionController: JsLinesCollectionController): void;
}
declare class FloatToVec3JsParamsConfig extends NodeParamsConfig {
	x: ParamTemplate<ParamType.FLOAT>;
	y: ParamTemplate<ParamType.FLOAT>;
	z: ParamTemplate<ParamType.FLOAT>;
}
declare class FloatToVec3JsNode extends TypedJsNode<FloatToVec3JsParamsConfig> {
	paramsConfig: FloatToVec3JsParamsConfig;
	static type(): string;
	static readonly OUTPUT_NAME = "vec3";
	initializeNode(): void;
	setLines(shadersCollectionController: JsLinesCollectionController): void;
}
declare class FloatToVec4JsParamsConfig extends NodeParamsConfig {
	x: ParamTemplate<ParamType.FLOAT>;
	y: ParamTemplate<ParamType.FLOAT>;
	z: ParamTemplate<ParamType.FLOAT>;
	w: ParamTemplate<ParamType.FLOAT>;
}
declare class FloatToVec4JsNode extends TypedJsNode<FloatToVec4JsParamsConfig> {
	paramsConfig: FloatToVec4JsParamsConfig;
	static type(): string;
	static readonly OUTPUT_NAME = "vec4";
	initializeNode(): void;
	setLines(shadersCollectionController: JsLinesCollectionController): void;
}
declare const FloorJsNode_base: typeof BaseMathFunctionJsNode;
declare class FloorJsNode extends FloorJsNode_base {
}
declare class GeolocationCurrentPositionJsNode extends ParamlessTypedJsNode {
	static type(): JsType;
	isTriggering(): boolean;
	initializeNode(): void;
	setLines(linesController: JsLinesCollectionController): void;
	setTriggeringLines(linesController: JsLinesCollectionController, triggeredMethods: string): void;
	setTriggerableLines(linesController: JsLinesCollectionController): void;
}
declare class GetBox3PropertyJsNode extends ParamlessTypedJsNode {
	static type(): string;
	initializeNode(): void;
	setLines(shadersCollectionController: JsLinesCollectionController): void;
}
declare enum GetChildrenAttributesInputName {
	attribName = "attribName"
}
declare class GetChildrenAttributesJsParamsConfig extends NodeParamsConfig {
	type: ParamTemplate<ParamType.INTEGER>;
}
declare class GetChildrenAttributesJsNode extends TypedJsNode<GetChildrenAttributesJsParamsConfig> {
	readonly paramsConfig: GetChildrenAttributesJsParamsConfig;
	static type(): string;
	static readonly OUTPUT_NAME = "val";
	initializeNode(): void;
	private _currentConnectionType;
	private _nextAttribName;
	paramDefaultValue(name: GetChildrenAttributesInputName): string;
	setAttribType(type: ParamConvertibleJsType): void;
	attribType(): JsConnectionPointType;
	setAttribName(attribName: string): void;
	attribName(): string;
	setLines(shadersCollectionController: JsLinesCollectionController): void;
}
declare class GetChildrenPhysicsRBDPropertiesJsNode extends ParamlessTypedJsNode {
	static type(): string;
	initializeNode(): void;
	setLines(shadersCollectionController: JsLinesCollectionController): void;
}
declare class GetChildrenPropertiesJsNode extends ParamlessTypedJsNode {
	static type(): string;
	initializeNode(): void;
	setLines(shadersCollectionController: JsLinesCollectionController): void;
}
declare class GetDefaultCameraJsParamsConfig extends NodeParamsConfig {
}
declare class GetDefaultCameraJsNode extends TypedJsNode<GetDefaultCameraJsParamsConfig> {
	readonly paramsConfig: GetDefaultCameraJsParamsConfig;
	static type(): string;
	initializeNode(): void;
	setLines(shadersCollectionController: JsLinesCollectionController): void;
}
declare class GetGeometryBoundingBoxJsParamsConfig extends NodeParamsConfig {
	forceCompute: ParamTemplate<ParamType.BOOLEAN>;
}
declare class GetGeometryBoundingBoxJsNode extends TypedJsNode<GetGeometryBoundingBoxJsParamsConfig> {
	readonly paramsConfig: GetGeometryBoundingBoxJsParamsConfig;
	static type(): string;
	initializeNode(): void;
	setLines(linesController: JsLinesCollectionController): void;
}
declare class GetGeometryNodeObjectsJsParamsConfig extends NodeParamsConfig {
}
declare class GetGeometryNodeObjectsJsNode extends TypedJsNode<GetGeometryNodeObjectsJsParamsConfig> {
	readonly paramsConfig: GetGeometryNodeObjectsJsParamsConfig;
	static type(): string;
	initializeNode(): void;
	setLines(linesController: JsLinesCollectionController): void;
	setTriggerableLines(linesController: JsLinesCollectionController): void;
	private _addObjectsRef;
}
declare class GetGeometryPositionsJsParamsConfig extends NodeParamsConfig {
}
declare class GetGeometryPositionsJsNode extends TypedJsNode<GetGeometryPositionsJsParamsConfig> {
	readonly paramsConfig: GetGeometryPositionsJsParamsConfig;
	static type(): string;
	initializeNode(): void;
	setLines(linesController: JsLinesCollectionController): void;
}
type AvailableType = JsConnectionPointType.FLOAT | JsConnectionPointType.INT | JsConnectionPointType.VECTOR2 | JsConnectionPointType.VECTOR3 | JsConnectionPointType.VECTOR4;
declare enum GetPointAttributeInputName {
	attribName = "attribName"
}
// @ts-ignore
declare class GetObjectAttributeJsParamsConfig extends NodeParamsConfig {
	type: ParamTemplate<ParamType.INTEGER>;
	defaultFloat: ParamTemplate<ParamType.FLOAT>;
	defaultInteger: ParamTemplate<ParamType.INTEGER>;
	defaultVector2: ParamTemplate<ParamType.VECTOR2>;
	defaultVector3: ParamTemplate<ParamType.VECTOR3>;
	defaultVector4: ParamTemplate<ParamType.VECTOR4>;
}
declare class GetPointAttributeJsNode extends TypedJsNode<GetObjectAttributeJsParamsConfig> {
	readonly paramsConfig: GetObjectAttributeJsParamsConfig;
	static type(): JsType;
	initializeNode(): void;
	private _currentConnectionType;
	defaultValueParam(): FloatParam | IntegerParam | Vector2Param | Vector3Param | Vector4Param;
	private _bodyLine;
	private _nextAttribName;
	paramDefaultValue(name: GetPointAttributeInputName): string;
	setAttribType(type: AvailableType): void;
	attribType(): AvailableType;
	setAttribName(attribName: string): void;
	attributeName(): string;
	setLines(linesController: JsLinesCollectionController): void;
}
declare class GetInstanceAttributeJsNode extends GetPointAttributeJsNode {
	static type(): JsType;
}
declare class GetInstancePropertyJsNode extends ParamlessTypedJsNode {
	static type(): JsType;
	initializeNode(): void;
	setLines(linesController: JsLinesCollectionController): void;
}
declare enum GetIntersectionAttributeInputName {
	attribName = "attribName",
	notFoundValue = "notFoundValue"
}
declare class GetIntersectionAttributeJsParamsConfig extends NodeParamsConfig {
	type: ParamTemplate<ParamType.INTEGER>;
	interpolated: ParamTemplate<ParamType.BOOLEAN>;
}
declare class GetIntersectionAttributeJsNode extends TypedJsNode<GetIntersectionAttributeJsParamsConfig> {
	readonly paramsConfig: GetIntersectionAttributeJsParamsConfig;
	static type(): string;
	static readonly OUTPUT_NAME = "val";
	initializeNode(): void;
	private _expectedInputTypes;
	private _expectedInputNames;
	private _nextAttribName;
	paramDefaultValue(name: GetIntersectionAttributeInputName): string | number;
	setAttribType(type: ParamConvertibleJsType): void;
	attribType(): ParamConvertibleJsType;
	setAttribName(attribName: string): void;
	attributeName(): string;
	setLines(shadersCollectionController: JsLinesCollectionController): void;
	private _getBodyLine;
}
declare class GetIntersectionPropertyJsNode extends ParamlessTypedJsNode {
	static type(): string;
	initializeNode(): void;
	setLines(shadersCollectionController: JsLinesCollectionController): void;
}
declare class GetMaterialJsParamsConfig extends NodeParamsConfig {
	/** @param the material node */
	node: ParamTemplate<ParamType.NODE_PATH>;
}
declare class GetMaterialJsNode extends TypedJsNode<GetMaterialJsParamsConfig> {
	readonly paramsConfig: GetMaterialJsParamsConfig;
	static type(): string;
	initializeNode(): void;
	setLines(shadersCollectionController: JsLinesCollectionController): void;
}
declare class GetNodeJsParamsConfig extends NodeParamsConfig {
	/** @param parameter to get */
	Node: ParamTemplate<ParamType.NODE_PATH>;
}
declare class GetNodeJsNode extends TypedJsNode<GetNodeJsParamsConfig> {
	readonly paramsConfig: GetNodeJsParamsConfig;
	static type(): JsType;
	initializeNode(): void;
	setNodePath(nodePath: string): void;
	setLines(linesController: JsLinesCollectionController): void;
}
declare class GetObjectJsParamsConfig extends NodeParamsConfig {
	/** @param use current object */
	getCurrentObject: ParamTemplate<ParamType.BOOLEAN>;
	/** @param object mask */
	mask: ParamTemplate<ParamType.STRING>;
}
declare class GetObjectJsNode extends TypedJsNode<GetObjectJsParamsConfig> {
	readonly paramsConfig: GetObjectJsParamsConfig;
	static type(): string;
	initializeNode(): void;
	setLines(linesController: JsLinesCollectionController): void;
}
declare enum GetObjectAttributeInputName {
	attribName = "attribName"
}
// @ts-ignore
declare class GetObjectAttributeJsParamsConfig extends NodeParamsConfig {
	type: ParamTemplate<ParamType.INTEGER>;
}
declare class GetObjectAttributeJsNode extends TypedJsNode<GetObjectAttributeJsParamsConfig> {
	readonly paramsConfig: GetObjectAttributeJsParamsConfig;
	static type(): JsType;
	initializeNode(): void;
	private _expectedInputTypes;
	private _expectedInputNames;
	private _expectedOutputTypes;
	private _expectedOutputNames;
	private _currentConnectionType;
	defaultValueName(): string;
	private _nextAttribName;
	paramDefaultValue(name: GetObjectAttributeInputName): string;
	setAttribType(type: ParamConvertibleJsType): void;
	setAttribName(attribName: string): void;
	attributeName(): string;
	setLines(linesController: JsLinesCollectionController): void;
}
declare class GetObjectChildJsParamsConfig extends NodeParamsConfig {
	/** @param child index */
	index: ParamTemplate<ParamType.INTEGER>;
}
declare class GetObjectChildJsNode extends TypedJsNode<GetObjectChildJsParamsConfig> {
	readonly paramsConfig: GetObjectChildJsParamsConfig;
	static type(): string;
	initializeNode(): void;
	setLines(shadersCollectionController: JsLinesCollectionController): void;
}
declare class GetObjectPropertyJsNode extends ParamlessTypedJsNode {
	static type(): JsType;
	initializeNode(): void;
	setLines(linesController: JsLinesCollectionController): void;
}
declare class GetObjectUserDataJsParamsConfig extends NodeParamsConfig {
	type: ParamTemplate<ParamType.INTEGER>;
	name: ParamTemplate<ParamType.STRING>;
}
declare class GetObjectUserDataJsNode extends TypedJsNode<GetObjectUserDataJsParamsConfig> {
	readonly paramsConfig: GetObjectUserDataJsParamsConfig;
	static type(): JsType;
	static readonly OUTPUT_NAME = "val";
	initializeNode(): void;
	private _currentConnectionType;
	setUserDataType(type: JsConnectionPointType): void;
	setLines(shadersCollectionController: JsLinesCollectionController): void;
}
declare class GetObjectWorldPositionJsNode extends ParamlessTypedJsNode {
	static type(): string;
	initializeNode(): void;
	setLines(shadersCollectionController: JsLinesCollectionController): void;
}
declare class GetParamJsParamsConfig extends NodeParamsConfig {
	/** @param parameter to get */
	Param: ParamTemplate<ParamType.PARAM_PATH>;
}
declare class GetParamJsNode extends TypedJsNode<GetParamJsParamsConfig> {
	readonly paramsConfig: GetParamJsParamsConfig;
	static type(): JsType;
	initializeNode(): void;
	setParamPath(paramPath: string): void;
	setLines(linesController: JsLinesCollectionController): void;
}
declare class GetParentJsParamsConfig extends NodeParamsConfig {
}
declare class GetParentJsNode extends TypedJsNode<GetParentJsParamsConfig> {
	readonly paramsConfig: GetParentJsParamsConfig;
	static type(): string;
	initializeNode(): void;
	setLines(shadersCollectionController: JsLinesCollectionController): void;
}
declare class GetPhysicsRBDJsNode extends ParamlessTypedJsNode {
	static type(): string;
	initializeNode(): void;
	setLines(linesController: JsLinesCollectionController): void;
}
declare class GetPhysicsRBDConePropertyJsNode extends ParamlessTypedJsNode {
	static type(): string;
	initializeNode(): void;
	setLines(shadersCollectionController: JsLinesCollectionController): void;
}
declare class GetPhysicsRBDCapsulePropertyJsNode extends ParamlessTypedJsNode {
	static type(): string;
	initializeNode(): void;
	setLines(shadersCollectionController: JsLinesCollectionController): void;
}
declare class GetPhysicsRBDCylinderPropertyJsNode extends ParamlessTypedJsNode {
	static type(): string;
	initializeNode(): void;
	setLines(shadersCollectionController: JsLinesCollectionController): void;
}
declare class GetPhysicsRBDCuboidPropertyJsNode extends ParamlessTypedJsNode {
	static type(): string;
	initializeNode(): void;
	setLines(shadersCollectionController: JsLinesCollectionController): void;
}
declare class GetPhysicsRBDSpherePropertyJsNode extends ParamlessTypedJsNode {
	static type(): string;
	initializeNode(): void;
	setLines(shadersCollectionController: JsLinesCollectionController): void;
}
declare class GetPhysicsRBDPropertyJsNode extends ParamlessTypedJsNode {
	static type(): string;
	initializeNode(): void;
	setLines(shadersCollectionController: JsLinesCollectionController): void;
}
declare class GetPlanePropertyJsNode extends ParamlessTypedJsNode {
	static type(): string;
	initializeNode(): void;
	setLines(shadersCollectionController: JsLinesCollectionController): void;
}
declare class GetPointPropertyJsNode extends ParamlessTypedJsNode {
	static type(): JsType;
	initializeNode(): void;
	setLines(linesController: JsLinesCollectionController): void;
}
declare class GetRayPropertyJsNode extends ParamlessTypedJsNode {
	static type(): string;
	initializeNode(): void;
	setLines(shadersCollectionController: JsLinesCollectionController): void;
}
declare class GetSibblingJsParamsConfig extends NodeParamsConfig {
	offset: ParamTemplate<ParamType.INTEGER>;
}
declare class GetSibblingJsNode extends TypedJsNode<GetSibblingJsParamsConfig> {
	readonly paramsConfig: GetSibblingJsParamsConfig;
	static type(): string;
	initializeNode(): void;
	setLines(shadersCollectionController: JsLinesCollectionController): void;
}
declare class GetSpherePropertyJsNode extends ParamlessTypedJsNode {
	static type(): string;
	initializeNode(): void;
	setLines(shadersCollectionController: JsLinesCollectionController): void;
}
declare class GetTextureJsParamsConfig extends NodeParamsConfig {
	/** @param the material node */
	node: ParamTemplate<ParamType.NODE_PATH>;
}
declare class GetTextureJsNode extends TypedJsNode<GetTextureJsParamsConfig> {
	readonly paramsConfig: GetTextureJsParamsConfig;
	static type(): string;
	initializeNode(): void;
	setLines(shadersCollectionController: JsLinesCollectionController): void;
}
declare class GetTrackedHandPropertyJsNode extends ParamlessTypedJsNode {
	static type(): string;
	initializeNode(): void;
	setLines(shadersCollectionController: JsLinesCollectionController): void;
}
declare class GetVideoPropertyJsParamsConfig extends NodeParamsConfig {
	node: ParamTemplate<ParamType.NODE_PATH>;
}
declare class GetVideoPropertyJsNode extends TypedJsNode<GetVideoPropertyJsParamsConfig> {
	paramsConfig: GetVideoPropertyJsParamsConfig;
	static type(): string;
	initializeNode(): void;
	setLines(shadersCollectionController: JsLinesCollectionController): void;
}
declare class GetWebXRARSessionPropertyJsParamsConfig extends NodeParamsConfig {
}
declare class GetWebXRARSessionPropertyJsNode extends TypedJsNode<GetWebXRARSessionPropertyJsParamsConfig> {
	paramsConfig: GetWebXRARSessionPropertyJsParamsConfig;
	static type(): string;
	initializeNode(): void;
	setLines(shadersCollectionController: JsLinesCollectionController): void;
}
declare class GetWebXRControllerPropertyJsParamsConfig extends NodeParamsConfig {
	/** @param  controller index */
	controllerIndex: ParamTemplate<ParamType.INTEGER>;
}
declare class GetWebXRControllerPropertyJsNode extends TypedJsNode<GetWebXRControllerPropertyJsParamsConfig> {
	paramsConfig: GetWebXRControllerPropertyJsParamsConfig;
	static type(): string;
	initializeNode(): void;
	setLines(shadersCollectionController: JsLinesCollectionController): void;
}
declare class GetWebXRTrackedMarkerJsParamsConfig extends NodeParamsConfig {
}
declare class GetWebXRTrackedMarkerPropertyJsNode extends TypedJsNode<GetWebXRTrackedMarkerJsParamsConfig> {
	paramsConfig: GetWebXRTrackedMarkerJsParamsConfig;
	static type(): string;
	initializeNode(): void;
	setLines(shadersCollectionController: JsLinesCollectionController): void;
}
declare class GlobalsAmbientLightJsParamsConfig extends NodeParamsConfig {
}
declare class GlobalsAmbientLightJsNode extends TypedJsNode<GlobalsAmbientLightJsParamsConfig> {
	paramsConfig: GlobalsAmbientLightJsParamsConfig;
	static type(): JsType;
	initializeNode(): void;
	setLines(linesController: JsLinesCollectionController): void;
}
declare class GlobalsAreaLightJsParamsConfig extends NodeParamsConfig {
}
declare class GlobalsAreaLightJsNode extends TypedJsNode<GlobalsAreaLightJsParamsConfig> {
	paramsConfig: GlobalsAreaLightJsParamsConfig;
	static type(): JsType;
	initializeNode(): void;
	setLines(linesController: JsLinesCollectionController): void;
}
declare class GlobalsDirectionalLightJsParamsConfig extends NodeParamsConfig {
}
declare class GlobalsDirectionalLightJsNode extends TypedJsNode<GlobalsDirectionalLightJsParamsConfig> {
	paramsConfig: GlobalsDirectionalLightJsParamsConfig;
	static type(): JsType;
	initializeNode(): void;
	setLines(linesController: JsLinesCollectionController): void;
}
declare class GlobalsHemisphereLightJsParamsConfig extends NodeParamsConfig {
}
declare class GlobalsHemisphereLightJsNode extends TypedJsNode<GlobalsHemisphereLightJsParamsConfig> {
	paramsConfig: GlobalsHemisphereLightJsParamsConfig;
	static type(): JsType;
	initializeNode(): void;
	setLines(linesController: JsLinesCollectionController): void;
}
declare class GlobalsPointLightJsParamsConfig extends NodeParamsConfig {
}
declare class GlobalsPointLightJsNode extends TypedJsNode<GlobalsPointLightJsParamsConfig> {
	paramsConfig: GlobalsPointLightJsParamsConfig;
	static type(): JsType;
	initializeNode(): void;
	setLines(linesController: JsLinesCollectionController): void;
}
declare class GlobalsSpotLightJsParamsConfig extends NodeParamsConfig {
}
declare class GlobalsSpotLightJsNode extends TypedJsNode<GlobalsSpotLightJsParamsConfig> {
	paramsConfig: GlobalsSpotLightJsParamsConfig;
	static type(): JsType;
	initializeNode(): void;
	setLines(linesController: JsLinesCollectionController): void;
}
declare class HsvToRgbParamsJsConfig extends NodeParamsConfig {
	hsv: ParamTemplate<ParamType.VECTOR3>;
}
declare class HsvToRgbJsNode extends TypedJsNode<HsvToRgbParamsJsConfig> {
	paramsConfig: HsvToRgbParamsJsConfig;
	static type(): string;
	initializeNode(): void;
	setLines(linesController: JsLinesCollectionController): void;
}
declare enum IsDefinedInputName {
	VALUE = "value"
}
declare class IsDefinedJsParamsConfig extends NodeParamsConfig {
}
declare class IsDefinedJsNode extends TypedJsNode<IsDefinedJsParamsConfig> {
	paramsConfig: IsDefinedJsParamsConfig;
	static type(): string;
	initializeNode(): void;
	protected _expectedInputName(index: number): IsDefinedInputName;
	protected _expectedInputTypes(): JsConnectionPointType[];
	private _expectedOutputTypes;
	private _expectedOutputName;
	setLines(linesController: JsLinesCollectionController): void;
}
declare class IsTouchDeviceJsParamsConfig extends NodeParamsConfig {
}
declare class IsTouchDeviceJsNode extends TypedJsNode<IsTouchDeviceJsParamsConfig> {
	paramsConfig: IsTouchDeviceJsParamsConfig;
	static type(): string;
	initializeNode(): void;
	setLines(linesController: JsLinesCollectionController): void;
}
interface KeyframeTangent {
	slope: number;
	accel: number;
}
interface KeyframeData {
	pos: number;
	value: number;
	in: KeyframeTangent;
	out?: KeyframeTangent;
}
declare enum ChannelInterpolation {
	LINEAR = "linear",
	CUBIC = "cubic"
}
type ChannelData = {
	keyframes: KeyframeData[];
	interpolation: ChannelInterpolation;
};
type SetCurveCallback = (keyframeStart: KeyframeData, keyframeEnd: KeyframeData) => void;
type GetValueCallback = (pos: number) => number;
declare enum KeyframesJsNodeInputName {
	time = "time"
}
type AvailableJsConnectionType = JsConnectionPointType.FLOAT | JsConnectionPointType.VECTOR2 | JsConnectionPointType.VECTOR3 | JsConnectionPointType.VECTOR4;
declare class KeyframesJsParamsConfig extends NodeParamsConfig {
	channels: ParamTemplate<ParamType.FOLDER>;
	channelsCount: ParamTemplate<ParamType.INTEGER>;
	channelType0: ParamTemplate<ParamType.INTEGER>;
	channelName0: ParamTemplate<ParamType.STRING>;
	data0: ParamTemplate<ParamType.STRING>;
	channelType1: ParamTemplate<ParamType.INTEGER>;
	channelName1: ParamTemplate<ParamType.STRING>;
	data1: ParamTemplate<ParamType.STRING>;
	channelType2: ParamTemplate<ParamType.INTEGER>;
	channelName2: ParamTemplate<ParamType.STRING>;
	data2: ParamTemplate<ParamType.STRING>;
	channelType3: ParamTemplate<ParamType.INTEGER>;
	channelName3: ParamTemplate<ParamType.STRING>;
	data3: ParamTemplate<ParamType.STRING>;
	channelType4: ParamTemplate<ParamType.INTEGER>;
	channelName4: ParamTemplate<ParamType.STRING>;
	data4: ParamTemplate<ParamType.STRING>;
	channelType5: ParamTemplate<ParamType.INTEGER>;
	channelName5: ParamTemplate<ParamType.STRING>;
	data5: ParamTemplate<ParamType.STRING>;
	channelType6: ParamTemplate<ParamType.INTEGER>;
	channelName6: ParamTemplate<ParamType.STRING>;
	data6: ParamTemplate<ParamType.STRING>;
	channelType7: ParamTemplate<ParamType.INTEGER>;
	channelName7: ParamTemplate<ParamType.STRING>;
	data7: ParamTemplate<ParamType.STRING>;
	channelType8: ParamTemplate<ParamType.INTEGER>;
	channelName8: ParamTemplate<ParamType.STRING>;
	data8: ParamTemplate<ParamType.STRING>;
	channelType9: ParamTemplate<ParamType.INTEGER>;
	channelName9: ParamTemplate<ParamType.STRING>;
	data9: ParamTemplate<ParamType.STRING>;
	spare: ParamTemplate<ParamType.FOLDER>;
}
declare class KeyframesJsNode extends TypedJsNode<KeyframesJsParamsConfig> {
	readonly paramsConfig: KeyframesJsParamsConfig;
	static type(): JsType;
	initializeNode(): void;
	channelTypeParams(): IntegerParam[];
	channelNameParams(): StringParam[];
	channelDataParams(): StringParam[];
	setChannelType(index: number, type: AvailableJsConnectionType): void;
	setChannelName(index: number, inputName: string): void;
	setChannelData(index: number, data: ChannelData[]): void;
	channelData(index: number): ChannelData | ChannelData[] | undefined;
	protected _channelsCount(): number;
	protected _expectedInputTypes(): JsConnectionPointType[];
	protected _expectedInputName(index: number): KeyframesJsNodeInputName;
	protected _expectedOutputTypes(): AvailableJsConnectionType[];
	protected _expectedOutputName(index: number): string;
	setLines(linesController: JsLinesCollectionController): void;
}
declare enum LengthJsNodeInputName {
	VALUE = "v"
}
declare class LengthJsNode extends ParamlessTypedJsNode {
	static type(): string;
	initializeNode(): void;
	setLines(shadersCollectionController: JsLinesCollectionController): void;
	protected _expectedInputTypes(): JsConnectionPointType[];
	protected _expectedOutputTypes(): JsConnectionPointType[];
	protected _expectedInputName(index: number): LengthJsNodeInputName;
	protected _expectedOutputName(index: number): string;
	paramDefaultValue(name: string): number;
}
declare abstract class MathNamedFunction2<ARGS extends [
	any,
	any
]> extends NamedFunction<ARGS, string[]> {
}
declare abstract class MathNamedFunction3<ARGS extends [
	any,
	any,
	any
]> extends NamedFunction<ARGS, string[]> {
}
declare abstract class MathNamedFunction4<ARGS extends [
	any,
	any,
	any,
	any
]> extends NamedFunction<ARGS, string[]> {
}
declare abstract class MathNamedFunction5<ARGS extends [
	any,
	any,
	any,
	any,
	any
]> extends NamedFunction<ARGS, string[]> {
}
declare abstract class MathNamedFunction6<ARGS extends [
	any,
	any,
	any,
	any,
	any,
	any
]> extends NamedFunction<ARGS, string[]> {
}
declare abstract class MathNamedFunction7<ARGS extends [
	any,
	any,
	any,
	any,
	any,
	any,
	any
]> extends NamedFunction<ARGS, string[]> {
}
declare abstract class MathNamedFunction8<ARGS extends [
	any,
	any,
	any,
	any,
	any,
	any,
	any,
	any
]> extends NamedFunction<ARGS, string[]> {
}
type MathFunction1 = (x: number) => number;
type MathFunction2 = (x: number, arg1: number) => number;
type MathFunction3 = (x: number, arg1: number, arg2: number) => number;
type MathFunction4 = (x: number, arg1: number, arg2: number, arg3: number) => number;
type MathFunction5 = (x: number, arg1: number, arg2: number, arg3: number, arg4: number) => number;
type MathVectorFunction1 = "mathColor_1" | "mathVector2_1" | "mathVector3_1" | "mathVector4_1";
type MathVectorFunction2 = "mathColor_2" | "mathVector2_2" | "mathVector3_2" | "mathVector4_2";
type MathVectorFunction3 = "mathColor_3" | "mathVector2_3" | "mathVector3_3" | "mathVector4_3";
type MathVectorFunction3vvf = "mathColor_3vvf" | "mathVector2_3vvf" | "mathVector3_3vvf" | "mathVector4_3vvf";
type MathVectorFunction4 = "mathColor_4" | "mathVector2_4" | "mathVector3_4" | "mathVector4_4";
type MathVectorFunction5 = "mathColor_5" | "mathVector2_5" | "mathVector3_5" | "mathVector4_5";
type MathVectorFunction = MathVectorFunction1 | MathVectorFunction2 | MathVectorFunction3 | MathVectorFunction3vvf | MathVectorFunction4 | MathVectorFunction5;
type MathFloat = "mathFloat_1" | "mathFloat_2" | "mathFloat_3" | "mathFloat_4" | "mathFloat_5";
type MathPrimArray = "mathPrimArray_1" | "mathPrimArray_2" | "mathPrimArray_3" | "mathPrimArray_4" | "mathPrimArray_5";
type MathVectorArray = "mathVectorArray_1" | "mathVectorArray_2" | "mathVectorArray_3" | "mathVectorArray_4" | "mathVectorArray_5";
type VectorFunctionName<T extends MathVectorFunction> = (inputType: JsConnectionPointType) => T | undefined;
type MathArrayVectorElement = Color | Vector2 | Vector3 | Vector4;
type MathArrayVectorElementFunction1<T extends MathArrayVectorElement> = (func: MathFunction1, src: T, target: T) => T;
type MathArrayVectorElementFunction2<T extends MathArrayVectorElement> = (func: MathFunction2, src: T, arg1: T, target: T) => T;
type MathArrayVectorElementFunction3<T extends MathArrayVectorElement> = (func: MathFunction3, src: T, arg1: T, arg2: T, target: T) => T;
type MathArrayVectorElementFunction3VVF<T extends MathArrayVectorElement> = (func: MathFunction3, src: T, arg1: T, arg2: number, target: T) => T;
type MathArrayVectorElementFunction4<T extends MathArrayVectorElement> = (func: MathFunction4, src: T, arg1: T, arg2: T, arg3: T, target: T) => T;
type MathArrayVectorElementFunction5<T extends MathArrayVectorElement> = (func: MathFunction5, src: T, arg1: T, arg2: T, arg3: T, arg4: T, target: T) => T;
declare class mathFloat_1 extends MathNamedFunction2<[
	MathFunction1,
	number
]> {
	static type(): string;
	func(_func: MathFunction1, value: number): number;
}
declare class mathFloat_2 extends MathNamedFunction3<[
	MathFunction2,
	number,
	number
]> {
	static type(): string;
	func(_func: MathFunction2, value: number, arg1: number): number;
}
declare class mathFloat_3 extends MathNamedFunction4<[
	MathFunction3,
	number,
	number,
	number
]> {
	static type(): string;
	func(_func: MathFunction3, value: number, arg1: number, arg2: number): number;
}
declare class mathFloat_4 extends MathNamedFunction5<[
	MathFunction4,
	number,
	number,
	number,
	number
]> {
	static type(): string;
	func(_func: MathFunction4, value: number, arg1: number, arg2: number, arg3: number): number;
}
declare class mathFloat_5 extends MathNamedFunction6<[
	MathFunction5,
	number,
	number,
	number,
	number,
	number
]> {
	static type(): string;
	func(_func: MathFunction5, value: number, arg1: number, arg2: number, arg3: number, arg4: number): number;
}
declare class mathColor_1 extends MathNamedFunction3<[
	MathFunction1,
	Color,
	Color
]> {
	static type(): string;
	func: MathArrayVectorElementFunction1<Color>;
}
declare class mathColor_2 extends MathNamedFunction4<[
	MathFunction2,
	Color,
	Color,
	Color
]> {
	static type(): string;
	func: MathArrayVectorElementFunction2<Color>;
}
declare class mathColor_3 extends MathNamedFunction5<[
	MathFunction2,
	Color,
	Color,
	Color,
	Color
]> {
	static type(): string;
	func: MathArrayVectorElementFunction3<Color>;
}
declare class mathColor_3vvf extends MathNamedFunction5<[
	MathFunction2,
	Color,
	Color,
	number,
	Color
]> {
	static type(): string;
	func: MathArrayVectorElementFunction3VVF<Color>;
}
declare class mathColor_4 extends MathNamedFunction6<[
	MathFunction2,
	Color,
	Color,
	Color,
	Color,
	Color
]> {
	static type(): string;
	func: MathArrayVectorElementFunction4<Color>;
}
declare class mathColor_5 extends MathNamedFunction7<[
	MathFunction2,
	Color,
	Color,
	Color,
	Color,
	Color,
	Color
]> {
	static type(): string;
	func: MathArrayVectorElementFunction5<Color>;
}
declare class mathVector2_1 extends MathNamedFunction3<[
	MathFunction1,
	Vector2,
	Vector2
]> {
	static type(): string;
	func: MathArrayVectorElementFunction1<Vector2>;
}
declare class mathVector2_2 extends MathNamedFunction4<[
	MathFunction1,
	Vector2,
	Vector2,
	Vector2
]> {
	static type(): string;
	func: MathArrayVectorElementFunction2<Vector2>;
}
declare class mathVector2_3 extends MathNamedFunction5<[
	MathFunction1,
	Vector2,
	Vector2,
	Vector2,
	Vector2
]> {
	static type(): string;
	func: MathArrayVectorElementFunction3<Vector2>;
}
declare class mathVector2_3vvf extends MathNamedFunction5<[
	MathFunction1,
	Vector2,
	Vector2,
	number,
	Vector2
]> {
	static type(): string;
	func: MathArrayVectorElementFunction3VVF<Vector2>;
}
declare class mathVector2_4 extends MathNamedFunction6<[
	MathFunction1,
	Vector2,
	Vector2,
	Vector2,
	Vector2,
	Vector2
]> {
	static type(): string;
	func: MathArrayVectorElementFunction4<Vector2>;
}
declare class mathVector2_5 extends MathNamedFunction7<[
	MathFunction1,
	Vector2,
	Vector2,
	Vector2,
	Vector2,
	Vector2,
	Vector2
]> {
	static type(): string;
	func: MathArrayVectorElementFunction5<Vector2>;
}
declare class mathVector3_1 extends MathNamedFunction3<[
	MathFunction1,
	Vector3,
	Vector3
]> {
	static type(): string;
	func: MathArrayVectorElementFunction1<Vector3>;
}
declare class mathVector3_2 extends MathNamedFunction4<[
	MathFunction1,
	Vector3,
	Vector3,
	Vector3
]> {
	static type(): string;
	func: MathArrayVectorElementFunction2<Vector3>;
}
declare class mathVector3_3 extends MathNamedFunction5<[
	MathFunction1,
	Vector3,
	Vector3,
	Vector3,
	Vector3
]> {
	static type(): string;
	func: MathArrayVectorElementFunction3<Vector3>;
}
declare class mathVector3_3vvf extends MathNamedFunction5<[
	MathFunction1,
	Vector3,
	Vector3,
	number,
	Vector3
]> {
	static type(): string;
	func: MathArrayVectorElementFunction3VVF<Vector3>;
}
declare class mathVector3_4 extends MathNamedFunction6<[
	MathFunction1,
	Vector3,
	Vector3,
	Vector3,
	Vector3,
	Vector3
]> {
	static type(): string;
	func: MathArrayVectorElementFunction4<Vector3>;
}
declare class mathVector3_5 extends MathNamedFunction7<[
	MathFunction1,
	Vector3,
	Vector3,
	Vector3,
	Vector3,
	Vector3,
	Vector3
]> {
	static type(): string;
	func: MathArrayVectorElementFunction5<Vector3>;
}
declare class mathVector4_1 extends MathNamedFunction3<[
	MathFunction1,
	Vector4,
	Vector4
]> {
	static type(): string;
	func: MathArrayVectorElementFunction1<Vector4>;
}
declare class mathVector4_2 extends MathNamedFunction4<[
	MathFunction1,
	Vector4,
	Vector4,
	Vector4
]> {
	static type(): string;
	func: MathArrayVectorElementFunction2<Vector4>;
}
declare class mathVector4_3 extends MathNamedFunction5<[
	MathFunction1,
	Vector4,
	Vector4,
	Vector4,
	Vector4
]> {
	static type(): string;
	func: MathArrayVectorElementFunction3<Vector4>;
}
declare class mathVector4_3vvf extends MathNamedFunction5<[
	MathFunction1,
	Vector4,
	Vector4,
	number,
	Vector4
]> {
	static type(): string;
	func: MathArrayVectorElementFunction3VVF<Vector4>;
}
declare class mathVector4_4 extends MathNamedFunction6<[
	MathFunction1,
	Vector4,
	Vector4,
	Vector4,
	Vector4,
	Vector4
]> {
	static type(): string;
	func: MathArrayVectorElementFunction4<Vector4>;
}
declare class mathVector4_5 extends MathNamedFunction7<[
	MathFunction1,
	Vector4,
	Vector4,
	Vector4,
	Vector4,
	Vector4,
	Vector4
]> {
	static type(): string;
	func: MathArrayVectorElementFunction5<Vector4>;
}
declare class mathPrimArray_1 extends MathNamedFunction3<[
	MathFunction1,
	number[],
	number[]
]> {
	static type(): string;
	func(_func: MathFunction1, srcElements: number[], targetElements: number[]): number[];
}
declare class mathPrimArray_2 extends MathNamedFunction4<[
	MathFunction2,
	number[],
	number,
	number[]
]> {
	static type(): string;
	func(_func: MathFunction2, srcElements: number[], arg1: number, targetElements: number[]): number[];
}
declare class mathPrimArray_3 extends MathNamedFunction5<[
	MathFunction3,
	number[],
	number,
	number,
	number[]
]> {
	static type(): string;
	func(_func: MathFunction3, srcElements: number[], arg1: number, arg2: number, targetElements: number[]): number[];
}
declare class mathPrimArray_4 extends MathNamedFunction6<[
	MathFunction4,
	number[],
	number,
	number,
	number,
	number[]
]> {
	static type(): string;
	func(_func: MathFunction4, srcElements: number[], arg1: number, arg2: number, arg3: number, targetElements: number[]): number[];
}
declare class mathPrimArray_5 extends MathNamedFunction7<[
	MathFunction5,
	number[],
	number,
	number,
	number,
	number,
	number[]
]> {
	static type(): string;
	func(_func: MathFunction5, srcElements: number[], arg1: number, arg2: number, arg3: number, arg4: number, targetElements: number[]): number[];
}
declare class mathVectorArray_1<T extends MathArrayVectorElement> extends MathNamedFunction4<[
	MathFunction1,
	MathArrayVectorElementFunction1<T>,
	T[],
	T[]
]> {
	static type(): string;
	func(_func: MathFunction1, vectorFunc: MathArrayVectorElementFunction1<T>, srcElements: T[], targetElements: T[]): T[];
}
declare class mathVectorArray_2<T extends MathArrayVectorElement> extends MathNamedFunction5<[
	MathFunction2,
	MathArrayVectorElementFunction2<T>,
	T[],
	T,
	T[]
]> {
	static type(): string;
	func(_func: MathFunction2, vectorFunc: MathArrayVectorElementFunction2<T>, srcElements: T[], arg1: T, targetElements: T[]): T[];
}
declare class mathVectorArray_3<T extends MathArrayVectorElement> extends MathNamedFunction6<[
	MathFunction3,
	MathArrayVectorElementFunction3<T>,
	T[],
	T,
	T,
	T[]
]> {
	static type(): string;
	func(_func: MathFunction3, vectorFunc: MathArrayVectorElementFunction3<T>, srcElements: T[], arg1: T, arg2: T, targetElements: T[]): T[];
}
declare class mathVectorArray_4<T extends MathArrayVectorElement> extends MathNamedFunction7<[
	MathFunction4,
	MathArrayVectorElementFunction4<T>,
	T[],
	T,
	T,
	T,
	T[]
]> {
	static type(): string;
	func(_func: MathFunction4, vectorFunc: MathArrayVectorElementFunction4<T>, srcElements: T[], arg1: T, arg2: T, arg3: T, targetElements: T[]): T[];
}
declare class mathVectorArray_5<T extends MathArrayVectorElement> extends MathNamedFunction8<[
	MathFunction5,
	MathArrayVectorElementFunction5<T>,
	T[],
	T,
	T,
	T,
	T,
	T[]
]> {
	static type(): string;
	func(_func: MathFunction5, vectorFunc: MathArrayVectorElementFunction5<T>, srcElements: T[], arg1: T, arg2: T, arg3: T, arg4: T, targetElements: T[]): T[];
}
interface MathFunctionData<MVF extends MathVectorFunction> {
	vectorFunctionNameFunction: VectorFunctionName<MVF>;
	mathFloat: MathFloat;
	mathPrimArray: MathPrimArray;
	mathVectorArray: MathVectorArray;
}
declare const LerpJsNode_base: typeof BaseMathFunctionJsNode;
declare class LerpJsNode extends LerpJsNode_base {
	protected _coreFunction(shadersCollectionController: JsLinesCollectionController): string;
	protected _functionData(): MathFunctionData<MathVectorFunction3vvf>;
	paramDefaultValue(name: string): number;
	protected _expectedInputName(index: number): string;
	protected _expectedInputTypes(): JsConnectionPointType[];
}
declare enum ManhattanDistanceJsNodeInputName {
	VALUE0 = "v0",
	VALUE1 = "v1"
}
declare class ManhattanDistanceJsNode extends ParamlessTypedJsNode {
	static type(): string;
	initializeNode(): void;
	setLines(shadersCollectionController: JsLinesCollectionController): void;
	protected _expectedInputTypes(): JsConnectionPointType[];
	protected _expectedOutputTypes(): JsConnectionPointType[];
	protected _expectedInputName(index: number): ManhattanDistanceJsNodeInputName;
	protected _expectedOutputName(index: number): string;
	paramDefaultValue(name: string): number;
}
declare class Matrix4LookAtJsParamsConfig extends NodeParamsConfig {
	/** @param eye */
	eye: ParamTemplate<ParamType.VECTOR3>;
	/** @param target */
	target: ParamTemplate<ParamType.VECTOR3>;
	/** @param up */
	up: ParamTemplate<ParamType.VECTOR3>;
}
declare class Matrix4LookAtJsNode extends TypedJsNode<Matrix4LookAtJsParamsConfig> {
	paramsConfig: Matrix4LookAtJsParamsConfig;
	static type(): string;
	initializeNode(): void;
	setLines(linesController: JsLinesCollectionController): void;
}
declare class Matrix4MakeTranslationJsParamsConfig extends NodeParamsConfig {
	/** @param t */
	t: ParamTemplate<ParamType.VECTOR3>;
}
declare class Matrix4MakeTranslationJsNode extends TypedJsNode<Matrix4MakeTranslationJsParamsConfig> {
	paramsConfig: Matrix4MakeTranslationJsParamsConfig;
	static type(): string;
	initializeNode(): void;
	setLines(linesController: JsLinesCollectionController): void;
}
declare class Matrix4MultiplyJsParamsConfig extends NodeParamsConfig {
}
declare class Matrix4MultiplyJsNode extends TypedJsNode<Matrix4MultiplyJsParamsConfig> {
	paramsConfig: Matrix4MultiplyJsParamsConfig;
	static type(): string;
	initializeNode(): void;
	setLines(linesController: JsLinesCollectionController): void;
}
declare const MaxJsNode_base: typeof BaseMathFunctionJsNode;
declare class MaxJsNode extends MaxJsNode_base {
	paramDefaultValue(name: string): number;
	protected _expectedInputName(index: number): string;
	protected _expectedInputTypes(): JsConnectionPointType[];
}
declare enum MaxLengthJsNodeInputName {
	VALUE = "value",
	MAX = "max"
}
declare class MaxLengthJsNode extends ParamlessTypedJsNode {
	static type(): string;
	initializeNode(): void;
	setLines(shadersCollectionController: JsLinesCollectionController): void;
	protected _expectedInputTypes(): JsConnectionPointType[];
	protected _expectedOutputTypes(): JsConnectionPointType[];
	protected _expectedInputName(index: number): MaxLengthJsNodeInputName;
	protected _expectedOutputName(index: number): string;
	paramDefaultValue(name: string): number;
}
declare const MinJsNode_base: typeof BaseMathFunctionJsNode;
declare class MinJsNode extends MinJsNode_base {
	paramDefaultValue(name: string): number;
	protected _expectedInputName(index: number): string;
	protected _expectedInputTypes(): JsConnectionPointType[];
}
declare const MixJsNode_base: typeof BaseMathFunctionJsNode;
declare class MixJsNode extends MixJsNode_base {
	protected _coreFunction(shadersCollectionController: JsLinesCollectionController): string;
	protected _functionData(): MathFunctionData<MathVectorFunction3vvf>;
	paramDefaultValue(name: string): number;
	protected _expectedInputName(index: number): string;
	protected _expectedInputTypes(): JsConnectionPointType[];
}
declare const ModJsNode_base: typeof BaseMathFunctionJsNode;
declare class ModJsNode extends ModJsNode_base {
	protected _coreFunction(shadersCollectionController: JsLinesCollectionController): string;
	paramDefaultValue(name: string): number;
	protected _expectedInputName(index: number): string;
	protected _expectedInputTypes(): JsConnectionPointType[];
}
declare const MultJsNode_base: typeof BaseMathFunctionJsNode;
declare class MultJsNode extends MultJsNode_base {
	paramDefaultValue(name: string): number;
}
declare const MultAddJsNode_base: typeof BaseMathFunctionJsNode;
declare class MultAddJsNode extends MultAddJsNode_base {
	protected _coreFunction(shadersCollectionController: JsLinesCollectionController): string;
	paramDefaultValue(name: string): number;
	protected _expectedInputName(index: number): string;
	protected _expectedInputTypes(): JsConnectionPointType[];
}
declare enum MultScalarJsNodeInputName {
	VALUE = "value",
	MULT = "mult"
}
declare class MultScalarJsNode extends ParamlessTypedJsNode {
	static type(): string;
	initializeNode(): void;
	setLines(shadersCollectionController: JsLinesCollectionController): void;
	protected _expectedInputTypes(): JsConnectionPointType[];
	protected _expectedOutputTypes(): JsConnectionPointType[];
	protected _expectedInputName(index: number): MultScalarJsNodeInputName;
	protected _expectedOutputName(index: number): string;
	paramDefaultValue(name: string): number;
}
declare class NearestPositionJsParamsConfig extends NodeParamsConfig {
	/** @param vector3 */
	Vector3: ParamTemplate<ParamType.VECTOR3>;
}
declare class NearestPositionJsNode extends TypedJsNode<NearestPositionJsParamsConfig> {
	paramsConfig: NearestPositionJsParamsConfig;
	static type(): string;
	initializeNode(): void;
	setLines(shadersCollectionController: JsLinesCollectionController): void;
}
declare const NegateJsNode_base: typeof BaseMathFunctionJsNode;
declare class NegateJsNode extends NegateJsNode_base {
	protected _coreFunction(shadersCollectionController: JsLinesCollectionController): string;
}
declare enum NoiseImprovedJsNodeInputName {
	POSITION = "position",
	AMP = "amp",
	FREQ = "freq",
	OFFSET = "offset",
	OCTAVES = "octaves",
	AMP_MULT = "ampMult",
	FREQ_MULT = "freqMult"
}
declare class NoiseImprovedJsNode extends ParamlessTypedJsNode {
	static type(): string;
	initializeNode(): void;
	private _firstType;
	protected _expectedInputTypes(): JsConnectionPointType[];
	protected _expectedOutputTypes(): JsConnectionPointType[];
	protected _expectedInputName(index: number): NoiseImprovedJsNodeInputName;
	protected _expectedOutputName(index: number): string;
	paramDefaultValue(name: string): number;
	setLines(shadersCollectionController: JsLinesCollectionController): void;
}
declare enum NoiseSimplexJsNodeInputName {
	POSITION = "position",
	AMP = "amp",
	FREQ = "freq",
	OFFSET = "offset",
	OCTAVES = "octaves",
	AMP_MULT = "ampMult",
	FREQ_MULT = "freqMult",
	SEED = "seed"
}
declare class NoiseSimplexJsNode extends ParamlessTypedJsNode {
	static type(): string;
	initializeNode(): void;
	private _firstType;
	protected _expectedInputTypes(): JsConnectionPointType[];
	protected _expectedOutputTypes(): JsConnectionPointType[];
	protected _expectedInputName(index: number): NoiseSimplexJsNodeInputName;
	protected _expectedOutputName(index: number): string;
	paramDefaultValue(name: string): number;
	setLines(shadersCollectionController: JsLinesCollectionController): void;
}
declare enum NormalizeJsNodeInputName {
	VALUE = "v"
}
declare class NormalizeJsNode extends ParamlessTypedJsNode {
	static type(): string;
	initializeNode(): void;
	setLines(shadersCollectionController: JsLinesCollectionController): void;
	protected _expectedInputTypes(): JsConnectionPointType[];
	protected _expectedOutputTypes(): JsConnectionPointType[];
	protected _expectedInputName(index: number): NormalizeJsNodeInputName;
	protected _expectedOutputName(index: number): string;
	paramDefaultValue(name: string): number;
}
declare class NullJsParamsConfig extends NodeParamsConfig {
}
declare class NullJsNode extends TypedJsNode<NullJsParamsConfig> {
	readonly paramsConfig: NullJsParamsConfig;
	static type(): string;
	initializeNode(): void;
	protected _expectedInputTypes(): [
		JsConnectionPointType
	];
	protected _expectedInputName(index: number): string;
	protected _expectedOutputName(index: number): string;
	protected _expectedOutputTypes(): JsConnectionPointType[];
	setLines(shadersCollectionController: JsLinesCollectionController): void;
}
declare class Object3DLocalToWorldJsParamsConfig extends NodeParamsConfig {
	/** @param vector3 */
	Vector3: ParamTemplate<ParamType.VECTOR3>;
}
declare class Object3DLocalToWorldJsNode extends TypedJsNode<Object3DLocalToWorldJsParamsConfig> {
	paramsConfig: Object3DLocalToWorldJsParamsConfig;
	static type(): string;
	initializeNode(): void;
	setLines(shadersCollectionController: JsLinesCollectionController): void;
}
declare class Object3DWorldToLocalJsParamsConfig extends NodeParamsConfig {
	/** @param vector3 */
	Vector3: ParamTemplate<ParamType.VECTOR3>;
}
declare class Object3DWorldToLocalJsNode extends TypedJsNode<Object3DWorldToLocalJsParamsConfig> {
	paramsConfig: Object3DWorldToLocalJsParamsConfig;
	static type(): string;
	initializeNode(): void;
	setLines(shadersCollectionController: JsLinesCollectionController): void;
}
declare class Object3DUpdateMatrixJsParamsConfig extends NodeParamsConfig {
}
declare class Object3DUpdateMatrixJsNode extends TypedJsNode<Object3DUpdateMatrixJsParamsConfig> {
	readonly paramsConfig: Object3DUpdateMatrixJsParamsConfig;
	static type(): string;
	initializeNode(): void;
	setTriggerableLines(shadersCollectionController: JsLinesCollectionController): void;
}
declare class Object3DUpdateWorldMatrixJsParamsConfig extends NodeParamsConfig {
	/** @param updates the matrix of the parents */
	updateParents: ParamTemplate<ParamType.BOOLEAN>;
	/** @param updates the matrix of the children */
	updateChildren: ParamTemplate<ParamType.BOOLEAN>;
}
declare class Object3DUpdateWorldMatrixJsNode extends TypedJsNode<Object3DUpdateWorldMatrixJsParamsConfig> {
	readonly paramsConfig: Object3DUpdateWorldMatrixJsParamsConfig;
	static type(): string;
	initializeNode(): void;
	setTriggerableLines(shadersCollectionController: JsLinesCollectionController): void;
}
declare class ObjectDispatchEventJsParamsConfig extends NodeParamsConfig {
	/** @param event name */
	eventName: ParamTemplate<ParamType.STRING>;
}
declare class ObjectDispatchEventJsNode extends TypedJsNode<ObjectDispatchEventJsParamsConfig> {
	readonly paramsConfig: ObjectDispatchEventJsParamsConfig;
	static type(): string;
	initializeNode(): void;
	setTriggerableLines(shadersCollectionController: JsLinesCollectionController): void;
}
declare enum OnChildAttributeUpdateInputName {
	attribName = "attribName"
}
declare class OnChildAttributeUpdateJsParamsConfig extends NodeParamsConfig {
	type: ParamTemplate<ParamType.INTEGER>;
}
declare class OnChildAttributeUpdateJsNode extends TypedJsNode<OnChildAttributeUpdateJsParamsConfig> {
	readonly paramsConfig: OnChildAttributeUpdateJsParamsConfig;
	static type(): JsType;
	isTriggering(): boolean;
	static readonly OUTPUT_NEW_VALUES = "newValues";
	static readonly OUTPUT_PREV_VALUES = "previousValues";
	initializeNode(): void;
	private _currentConnectionType;
	private _nextAttribName;
	paramDefaultValue(name: OnChildAttributeUpdateInputName): string;
	setAttribType(type: ParamConvertibleJsType): void;
	attribType(): JsConnectionPointType;
	setAttribName(attribName: string): void;
	attributeName(): string;
	setLines(shadersCollectionController: JsLinesCollectionController): void;
	setTriggeringLines(shadersCollectionController: JsLinesCollectionController, triggeredMethods: string): void;
}
declare class BaseOnKeyEventJsParamsConfig extends NodeParamsConfig {
	/** @param set which element triggers the event */
	element: ParamTemplate<ParamType.INTEGER>;
	/** @param space separated list of accepted key codes. If this is empty then any key is accepted. */
	keyCodes: ParamTemplate<ParamType.STRING>;
	/** @param requires ctrlKey */
	ctrlKey: ParamTemplate<ParamType.INTEGER>;
	/** @param requires altKey */
	altKey: ParamTemplate<ParamType.INTEGER>;
	/** @param requires shiftKey */
	shiftKey: ParamTemplate<ParamType.INTEGER>;
	/** @param requires metaKey */
	metaKey: ParamTemplate<ParamType.INTEGER>;
}
declare abstract class BaseOnKeyEventJsNode extends BaseUserInputJsNode<BaseOnKeyEventJsParamsConfig> {
	readonly paramsConfig: BaseOnKeyEventJsParamsConfig;
	isTriggering(): boolean;
	initializeNode(): void;
	eventEmitter(): CoreEventEmitter;
	setEventEmitter(emitter: CoreEventEmitter): void;
	setTriggeringLines(shadersCollectionController: JsLinesCollectionController, triggeredMethods: string): void;
}
declare class OnKeyJsNode extends BaseOnKeyEventJsNode {
	static type(): JsType;
	eventData(): EvaluatorEventData[] | undefined;
}
declare class OnKeydownJsNode extends BaseOnKeyEventJsNode {
	static type(): JsType;
	eventData(): EvaluatorEventData | undefined;
}
declare class OnKeypressJsNode extends BaseOnKeyEventJsNode {
	static type(): JsType;
	eventData(): EvaluatorEventData | undefined;
}
declare class OnKeyupJsNode extends BaseOnKeyEventJsNode {
	static type(): JsType;
	eventData(): EvaluatorEventData | undefined;
}
declare class OnManualTriggerJsParamsConfig extends NodeParamsConfig {
	trigger: ParamTemplate<ParamType.BUTTON>;
}
declare class OnManualTriggerJsNode extends TypedJsNode<OnManualTriggerJsParamsConfig> {
	readonly paramsConfig: OnManualTriggerJsParamsConfig;
	static type(): JsType;
	isTriggering(): boolean;
	initializeNode(): void;
	static PARAM_CALLBACK_sendTrigger(node: OnManualTriggerJsNode): void;
	setTriggeringLines(shadersCollectionController: JsLinesCollectionController, triggeredMethods: string): void;
	private _triggerWithNode;
}
declare class OnMapboxCameraMoveJsParamsConfig extends NodeParamsConfig {
}
declare class OnMapboxCameraMoveJsNode extends TypedJsNode<OnMapboxCameraMoveJsParamsConfig> {
	readonly paramsConfig: OnMapboxCameraMoveJsParamsConfig;
	static type(): JsType;
	isTriggering(): boolean;
	initializeNode(): void;
	setTriggeringLines(shadersCollectionController: JsLinesCollectionController, triggeredMethods: string): void;
}
declare class OnMapboxCameraMoveEndJsParamsConfig extends NodeParamsConfig {
}
declare class OnMapboxCameraMoveEndJsNode extends TypedJsNode<OnMapboxCameraMoveEndJsParamsConfig> {
	readonly paramsConfig: OnMapboxCameraMoveEndJsParamsConfig;
	static type(): JsType;
	isTriggering(): boolean;
	initializeNode(): void;
	setTriggeringLines(shadersCollectionController: JsLinesCollectionController, triggeredMethods: string): void;
}
declare class OnMapboxCameraMoveStartJsParamsConfig extends NodeParamsConfig {
}
declare class OnMapboxCameraMoveStartJsNode extends TypedJsNode<OnMapboxCameraMoveStartJsParamsConfig> {
	readonly paramsConfig: OnMapboxCameraMoveStartJsParamsConfig;
	static type(): JsType;
	isTriggering(): boolean;
	initializeNode(): void;
	setTriggeringLines(shadersCollectionController: JsLinesCollectionController, triggeredMethods: string): void;
}
declare class OnObjectAttributeUpdateJsParamsConfig extends NodeParamsConfig {
	/** @param type */
	type: ParamTemplate<ParamType.INTEGER>;
}
declare class OnObjectAttributeUpdateJsNode extends TypedJsNode<OnObjectAttributeUpdateJsParamsConfig> {
	readonly paramsConfig: OnObjectAttributeUpdateJsParamsConfig;
	static type(): JsType;
	isTriggering(): boolean;
	static readonly OUTPUT_NEW_VAL = "newValue";
	static readonly OUTPUT_PREV_VAL = "previousValue";
	initializeNode(): void;
	private _currentConnectionType;
	setAttribType(type: ParamConvertibleJsType): void;
	attribType(): JsConnectionPointType;
	setAttribName(attribName: string): void;
	attributeName(): string;
	setLines(linesController: JsLinesCollectionController): void;
	setTriggeringLines(linesController: JsLinesCollectionController, triggeredMethods: string): void;
}
declare class OnObjectBeforeDeleteJsParamsConfig extends NodeParamsConfig {
}
declare class OnObjectBeforeDeleteJsNode extends TypedJsNode<OnObjectBeforeDeleteJsParamsConfig> {
	readonly paramsConfig: OnObjectBeforeDeleteJsParamsConfig;
	static type(): JsType.ON_OBJECT_BEFORE_DELETE;
	isTriggering(): boolean;
	initializeNode(): void;
	setTriggeringLines(shadersCollectionController: JsLinesCollectionController, triggeredMethods: string): void;
}
declare class OnObjectHoverJsParamsConfig extends NodeParamsConfig {
	/** @param include children */
	traverseChildren: ParamTemplate<ParamType.BOOLEAN>;
	/** @param pointsThreshold */
	pointsThreshold: ParamTemplate<ParamType.FLOAT>;
	/** @param lineThreshold */
	lineThreshold: ParamTemplate<ParamType.FLOAT>;
}
declare abstract class BaseOnObjectPointerEventJsNode extends BaseUserInputJsNode<OnObjectHoverJsParamsConfig> {
	readonly paramsConfig: OnObjectHoverJsParamsConfig;
	isTriggering(): boolean;
	eventEmitter(): CoreEventEmitter;
	initializeNode(): void;
}
declare class OnObjectClickJsNode extends BaseOnObjectPointerEventJsNode {
	static type(): JsType;
	isTriggering(): boolean;
	eventData(): EvaluatorEventData | undefined;
	initializeNode(): void;
	setLines(shadersCollectionController: JsLinesCollectionController): void;
	setTriggeringLines(shadersCollectionController: JsLinesCollectionController, triggeredMethods: string): void;
	private _addIntersectionRef;
}
declare class OnObjectDispatchEventJsParamsConfig extends NodeParamsConfig {
	/** @param event names (space separated) */
	eventNames: ParamTemplate<ParamType.STRING>;
}
declare class OnObjectDispatchEventJsNode extends TypedJsNode<OnObjectDispatchEventJsParamsConfig> {
	readonly paramsConfig: OnObjectDispatchEventJsParamsConfig;
	static type(): JsType.ON_OBJECT_DISPATCH_EVENT;
	isTriggering(): boolean;
	initializeNode(): void;
	setTriggeringLines(shadersCollectionController: JsLinesCollectionController, triggeredMethods: string): void;
}
declare class OnObjectHoverJsNode extends BaseOnObjectPointerEventJsNode {
	static type(): JsType;
	isTriggering(): boolean;
	eventData(): EvaluatorEventData | undefined;
	initializeNode(): void;
	setLines(linesController: JsLinesCollectionController): void;
	setTriggeringLines(linesController: JsLinesCollectionController, triggeredMethods: string): void;
	private _addIntersectionRef;
	private _addHoveredRef;
}
declare class OnObjectPointerdownJsNode extends BaseOnObjectPointerEventJsNode {
	static type(): JsType;
	eventData(): EvaluatorEventData | undefined;
	initializeNode(): void;
	setLines(linesController: JsLinesCollectionController): void;
	setTriggeringLines(linesController: JsLinesCollectionController, triggeredMethods: string): void;
	private _addIntersectionRef;
}
declare class OnObjectPointerupJsNode extends BaseOnObjectPointerEventJsNode {
	static type(): JsType;
	eventData(): EvaluatorEventData | undefined;
	initializeNode(): void;
	setLines(linesController: JsLinesCollectionController): void;
	setTriggeringLines(linesController: JsLinesCollectionController, triggeredMethods: string): void;
	private _addIntersectionRef;
}
declare abstract class BaseOnObjectSwipeEventJsNode extends BaseOnObjectPointerEventJsNode {
	eventData(): EvaluatorEventData[];
	initializeNode(): void;
	setLines(linesController: JsLinesCollectionController): void;
	setTriggeringLines(linesController: JsLinesCollectionController, triggeredMethods: string): void;
	private _addIntersectionRef;
	protected abstract _cursorComparison(onPointerdownCursor: string, onPointerupCursor: string): string;
}
declare class OnObjectSwipedownJsNode extends BaseOnObjectSwipeEventJsNode {
	static type(): JsType;
	protected _cursorComparison(onPointerdownCursor: string, onPointerupCursor: string): string;
}
declare class OnObjectSwipeleftJsNode extends BaseOnObjectSwipeEventJsNode {
	static type(): JsType;
	protected _cursorComparison(onPointerdownCursor: string, onPointerupCursor: string): string;
}
declare class OnObjectSwiperightJsNode extends BaseOnObjectSwipeEventJsNode {
	static type(): JsType;
	protected _cursorComparison(onPointerdownCursor: string, onPointerupCursor: string): string;
}
declare class OnObjectSwipeupJsNode extends BaseOnObjectSwipeEventJsNode {
	static type(): JsType;
	protected _cursorComparison(onPointerdownCursor: string, onPointerupCursor: string): string;
}
declare class OnPerformanceChangeJsParamsConfig extends NodeParamsConfig {
	threshold: ParamTemplate<ParamType.FLOAT>;
}
declare class OnPerformanceChangeJsNode extends TypedJsNode<OnPerformanceChangeJsParamsConfig> {
	readonly paramsConfig: OnPerformanceChangeJsParamsConfig;
	static type(): JsType;
	isTriggering(): boolean;
	static OUTPUT_NAME_ABOVE: string;
	static OUTPUT_NAME_BELOW: string;
	initializeNode(): void;
	setTriggeringLines(shadersCollectionController: JsLinesCollectionController, triggeredMethods: string): void;
}
declare class OnPointerdownJsParamsConfig extends NodeParamsConfig {
	/** @param set which element triggers the event */
	element: ParamTemplate<ParamType.INTEGER>;
}
declare class OnPointerdownJsNode extends BaseUserInputJsNode<OnPointerdownJsParamsConfig> {
	readonly paramsConfig: OnPointerdownJsParamsConfig;
	static type(): JsType;
	eventData(): EvaluatorEventData | undefined;
	eventEmitter(): CoreEventEmitter;
	setEventEmitter(emitter: CoreEventEmitter): void;
	initializeNode(): void;
	setTriggeringLines(shadersCollectionController: JsLinesCollectionController, triggeredMethods: string): void;
}
declare class OnPointerupJsParamsConfig extends NodeParamsConfig {
	/** @param set which element triggers the event */
	element: ParamTemplate<ParamType.INTEGER>;
}
declare class OnPointerupJsNode extends BaseUserInputJsNode<OnPointerupJsParamsConfig> {
	readonly paramsConfig: OnPointerupJsParamsConfig;
	static type(): JsType;
	eventData(): EvaluatorEventData[] | undefined;
	eventEmitter(): CoreEventEmitter;
	setEventEmitter(emitter: CoreEventEmitter): void;
	initializeNode(): void;
	setTriggeringLines(shadersCollectionController: JsLinesCollectionController, triggeredMethods: string): void;
}
declare class OnScenePauseJsParamsConfig extends NodeParamsConfig {
}
declare class OnScenePauseJsNode extends TypedJsNode<OnScenePauseJsParamsConfig> {
	readonly paramsConfig: OnScenePauseJsParamsConfig;
	static type(): JsType;
	isTriggering(): boolean;
	initializeNode(): void;
	setTriggeringLines(shadersCollectionController: JsLinesCollectionController, triggeredMethods: string): void;
}
declare class OnScenePlayJsParamsConfig extends NodeParamsConfig {
}
declare class OnScenePlayJsNode extends TypedJsNode<OnScenePlayJsParamsConfig> {
	readonly paramsConfig: OnScenePlayJsParamsConfig;
	static type(): JsType;
	isTriggering(): boolean;
	initializeNode(): void;
	setTriggeringLines(shadersCollectionController: JsLinesCollectionController, triggeredMethods: string): void;
}
declare class OnSceneResetJsParamsConfig extends NodeParamsConfig {
}
declare class OnSceneResetJsNode extends TypedJsNode<OnSceneResetJsParamsConfig> {
	readonly paramsConfig: OnSceneResetJsParamsConfig;
	static type(): JsType;
	isTriggering(): boolean;
	initializeNode(): void;
	setTriggeringLines(shadersCollectionController: JsLinesCollectionController, triggeredMethods: string): void;
}
declare class OnScrollJsParamsConfig extends NodeParamsConfig {
	element: ParamTemplate<ParamType.STRING>;
	useViewport: ParamTemplate<ParamType.BOOLEAN>;
	scroller: ParamTemplate<ParamType.STRING>;
	displayMarkers: ParamTemplate<ParamType.BOOLEAN>;
}
declare class OnScrollJsNode extends TypedJsNode<OnScrollJsParamsConfig> {
	readonly paramsConfig: OnScrollJsParamsConfig;
	static type(): JsType;
	requiredModules(): ModuleName[];
	isTriggering(): boolean;
	initializeNode(): void;
	setLines(linesController: JsLinesCollectionController): void;
	setTriggeringLines(linesController: JsLinesCollectionController, triggeredMethods: string): void;
	private _addCreateScrollListenerLines;
	private _addProgressRef;
}
declare class OnTickJsParamsConfig extends NodeParamsConfig {
}
declare class OnTickJsNode extends TypedJsNode<OnTickJsParamsConfig> {
	readonly paramsConfig: OnTickJsParamsConfig;
	static type(): JsType;
	isTriggering(): boolean;
	initializeNode(): void;
	setTriggeringLines(linesController: JsLinesCollectionController, triggeredMethods: string): void;
	setLines(linesController: JsLinesCollectionController): void;
}
declare class OnVideoEventJsParamsConfig extends NodeParamsConfig {
	/** @param video node */
	node: ParamTemplate<ParamType.NODE_PATH>;
}
declare class OnVideoEventJsNode extends TypedJsNode<OnVideoEventJsParamsConfig> {
	readonly paramsConfig: OnVideoEventJsParamsConfig;
	static type(): JsType.ON_VIDEO_EVENT;
	isTriggering(): boolean;
	initializeNode(): void;
	setTriggeringLines(shadersCollectionController: JsLinesCollectionController, triggeredMethods: string): void;
}
declare class OnWebXRControllerEventJsParamsConfig extends NodeParamsConfig {
	/** @param  controller index */
	controllerIndex: ParamTemplate<ParamType.INTEGER>;
}
declare class OnWebXRControllerEventJsNode extends TypedJsNode<OnWebXRControllerEventJsParamsConfig> {
	readonly paramsConfig: OnWebXRControllerEventJsParamsConfig;
	static type(): JsType.ON_WEBXR_CONTROLLER_EVENT;
	isTriggering(): boolean;
	initializeNode(): void;
	initOnPlay(): void;
	disposeOnPause(): void;
	private _addEventListenersToObjects;
	private _listenerByObjectByControllerIndex;
	dispose(): void;
	private _removeWebXREventListener;
}
declare class OrJsNode extends BaseLogicOperationJsNode {
	static type(): string;
	protected _expectedOutputName(): string;
	protected _functionName(firstType: AllowedType): "orArrays" | "orBooleans";
}
declare class OutputAmbientLightJsParamsConfig extends NodeParamsConfig {
}
declare class OutputAmbientLightJsNode extends TypedJsNode<OutputAmbientLightJsParamsConfig> {
	paramsConfig: OutputAmbientLightJsParamsConfig;
	static type(): JsType;
	initializeNode(): void;
	setLines(linesController: JsLinesCollectionController): void;
}
declare class OutputAreaLightJsParamsConfig extends NodeParamsConfig {
}
declare class OutputAreaLightJsNode extends TypedJsNode<OutputAreaLightJsParamsConfig> {
	paramsConfig: OutputAreaLightJsParamsConfig;
	static type(): JsType;
	initializeNode(): void;
	setLines(linesController: JsLinesCollectionController): void;
}
declare class OutputDirectionalLightJsParamsConfig extends NodeParamsConfig {
}
declare class OutputDirectionalLightJsNode extends TypedJsNode<OutputDirectionalLightJsParamsConfig> {
	paramsConfig: OutputDirectionalLightJsParamsConfig;
	static type(): JsType;
	initializeNode(): void;
	setLines(linesController: JsLinesCollectionController): void;
}
declare class OutputHemisphereLightJsParamsConfig extends NodeParamsConfig {
}
declare class OutputHemisphereLightJsNode extends TypedJsNode<OutputHemisphereLightJsParamsConfig> {
	paramsConfig: OutputHemisphereLightJsParamsConfig;
	static type(): JsType;
	initializeNode(): void;
	setLines(linesController: JsLinesCollectionController): void;
}
declare class OutputPointLightJsParamsConfig extends NodeParamsConfig {
}
declare class OutputPointLightJsNode extends TypedJsNode<OutputPointLightJsParamsConfig> {
	paramsConfig: OutputPointLightJsParamsConfig;
	static type(): JsType;
	initializeNode(): void;
	setLines(linesController: JsLinesCollectionController): void;
}
declare class OutputSpotLightJsParamsConfig extends NodeParamsConfig {
}
declare class OutputSpotLightJsNode extends TypedJsNode<OutputSpotLightJsParamsConfig> {
	paramsConfig: OutputSpotLightJsParamsConfig;
	static type(): JsType;
	initializeNode(): void;
	setLines(linesController: JsLinesCollectionController): void;
}
declare class ParamJsParamsConfig extends NodeParamsConfig {
	name: ParamTemplate<ParamType.STRING>;
	type: ParamTemplate<ParamType.INTEGER>;
}
declare class ParamJsNode extends TypedJsNode<ParamJsParamsConfig> {
	paramsConfig: ParamJsParamsConfig;
	static type(): string;
	static readonly OUTPUT_NAME = "val";
	initializeNode(): void;
	setLines(shadersCollectionController: JsLinesCollectionController): void;
	setParamConfigs(): void;
	uniformName(): string;
	setJsType(type: ParamConvertibleJsType): void;
	paramsGenerating(): boolean;
}
declare class ParticlesSystemResetJsNode extends ParamlessBaseTriggerAndObjectJsNode {
	static type(): string;
	setTriggerableLines(shadersCollectionController: JsLinesCollectionController): void;
}
type OnSceneLoadHook = () => void;
type PostCreateParamsHook = () => void;
interface ParamOptionToAdd<T extends ParamType> {
	name: string;
	type: T;
	initValue: ParamInitValueSerializedTypeMap[T];
	rawInput: ParamInitValueSerializedTypeMap[T];
// @ts-ignore
	options?: ParamOptions;
}
interface ParamsUpdateOptions {
	namesToDelete?: string[];
	toAdd?: ParamOptionToAdd<ParamType>[];
}
declare class ParamsController {
	readonly node: BaseNodeType;
	private _param_create_mode;
	private _params_created;
	private _paramsByName;
	private _paramsList;
	private _paramNames;
	private _non_spare_params;
	private _spare_params;
	private _non_spare_param_names;
	private _spare_param_names;
	private _params_node;
	private _params_added_since_last_params_eval;
	private _post_create_params_hook_names;
	private _post_create_params_hooks;
	private _on_scene_load_hooks;
	private _on_scene_load_hook_names;
	constructor(node: BaseNodeType);
	dispose(): void;
	private initDependencyNode;
	init(): void;
	private _postCreateParams;
	postCreateSpareParams(): void;
	updateParams(options: ParamsUpdateOptions): void;
	private _initFromParamsConfig;
	private _initParamAccessors;
	private _removeUnneededAccessors;
	get params_node(): CoreGraphNode | undefined;
	get all(): BaseParamType[];
	get non_spare(): BaseParamType[];
	get spare(): BaseParamType[];
	get names(): string[];
	get non_spare_names(): string[];
	get spare_names(): string[];
	private set_with_type;
	set_float(paramName: string, value: ParamInitValuesTypeMap[ParamType.FLOAT]): void;
	set_vector3(paramName: string, value: ParamInitValuesTypeMap[ParamType.VECTOR3]): void;
	has_param(paramName: string): boolean;
	has(paramName: string): boolean;
	get(paramName: string): BaseParamType | null;
	paramWithType<T extends ParamType>(param_name: string, type: T): ParamConstructorMap[T] | undefined;
	getFloat(param_name: string): FloatParam;
	value(paramName: string): string | number | boolean | Vector3 | Vector2 | Vector4 | Color | RampValue | TypedParamPathParamValue | TypedNodePathParamValue | null | undefined;
	valueWithType<T extends ParamType>(paramName: string, type: T): ParamValuesTypeMap[T];
	boolean(paramName: string): boolean;
	float(paramName: string): number;
	integer(paramName: string): number;
	string(paramName: string): string;
	vector2(paramName: string): Vector2;
	vector3(paramName: string): Vector3;
	color(paramName: string): Color;
	param(paramName: string): BaseParamType | null;
	private _deleteParam;
// @ts-ignore
	addParam<T extends ParamType>(type: T, paramName: string, defaultValue: ParamInitValuesTypeMap[T], options?: ParamOptions, initData?: ParamInitData<T>): ParamConstructorMap[T] | undefined;
	private _updateCaches;
	_evalParam(param: BaseParamType): Promise<void>;
	private _promises;
	evalParams(params: BaseParamType[]): Promise<void>;
	paramsEvalRequired(): boolean;
	evalAll(): Promise<void>;
	onParamsCreated(hook_name: string, hook: PostCreateParamsHook): void;
	addOnSceneLoadHook(param_name: string, method: OnSceneLoadHook): void;
	private _runPostCreateParamsHooks;
	runOnSceneLoadHooks(): void;
}
interface NamedInputData {
	index?: number;
	inputName?: string;
	node: string;
	output: string;
}
type IndexedInputData = string | null;
type InputData = NamedInputData | IndexedInputData;
interface FlagsData {
	bypass?: boolean;
	display?: boolean;
	optimize?: boolean;
}
interface IoConnectionPointsData {
	in?: BaseConnectionPointData[];
	out?: BaseConnectionPointData[];
}
interface NodeJsonExporterData {
	type: string;
	nodes?: PolyDictionary<NodeJsonExporterData>;
	children_context?: NodeContext;
	params?: PolyDictionary<ParamJsonExporterData<ParamType>>;
	maxInputsCount?: number;
	inputs?: InputData[];
	connection_points?: IoConnectionPointsData;
	flags?: FlagsData;
	cloned_state_overriden?: boolean;
	persisted_config?: PersistedConfigWithShaders;
	polyNode?: {
		locked: boolean;
	};
}
interface NodeJsonExporterUIData {
	pos?: Number2;
	comment?: string;
	selection?: string[];
	nodes?: PolyDictionary<NodeJsonExporterUIData>;
}
type NodeJSONShadersData = PolyDictionary<PolyDictionary<string>>;
type NodeJSONFunctionBodiesData = PolyDictionary<string | PolyDictionary<string>>;
interface PolyNodeSimpleInputsData {
	min: number;
	max: number;
	names?: string[];
}
interface PolyNodeTypedInputData {
	type: string;
	name: string;
}
interface PolyNodeTypedInputsData {
	types: PolyNodeTypedInputData[];
}
interface PolyNodesInputsData {
	simple?: PolyNodeSimpleInputsData;
	typed?: PolyNodeTypedInputsData;
}
interface PolyNodeMetadata {
	version: {
		marketplace?: number;
		editor?: string;
		polygonjs: string;
	};
	createdAt: number;
}
interface PolyNodeDefinition {
	metadata: PolyNodeMetadata;
	nodeContext: NodeContext;
	inputs?: PolyNodesInputsData;
	params?: ParamOptionToAdd<ParamType>[];
	nodes?: PolyDictionary<NodeJsonExporterData>;
	ui?: PolyDictionary<NodeJsonExporterUIData>;
}
declare class PolyNodeParamsConfig {
	static ParamsConfig(data: PolyNodeDefinition, paramsConfig?: NodeParamsConfig): NodeParamsConfig;
}
declare class ParticlesSystemStepSimulationJsParamsConfig extends PolyNodeParamsConfig {
	texturesCount: ParamTemplate<ParamType.INTEGER>;
	textureName0: ParamTemplate<ParamType.STRING>;
	textureName1: ParamTemplate<ParamType.STRING>;
	textureName2: ParamTemplate<ParamType.STRING>;
	textureName3: ParamTemplate<ParamType.STRING>;
	textureName4: ParamTemplate<ParamType.STRING>;
	textureName5: ParamTemplate<ParamType.STRING>;
	textureName6: ParamTemplate<ParamType.STRING>;
	textureName7: ParamTemplate<ParamType.STRING>;
	textureName8: ParamTemplate<ParamType.STRING>;
	textureName9: ParamTemplate<ParamType.STRING>;
}
declare class ParticlesSystemStepSimulationJsNode extends TypedJsNode<ParticlesSystemStepSimulationJsParamsConfig> {
	readonly paramsConfig: ParticlesSystemStepSimulationJsParamsConfig;
	static type(): string;
	initializeNode(): void;
	protected _textureNameParams(): StringParam[];
	setTextureName(index: number, textureName: string): void;
	private _expectedInputTypes;
	private _expectedInputName;
	private _expectedOutputTypes;
	private _expectedOutputName;
	setLines(linesController: JsLinesCollectionController): void;
	setTriggerableLines(linesController: JsLinesCollectionController): void;
	private _refToString;
	private _addRefs;
}
declare class PauseAudioSourceJsParamsConfig extends NodeParamsConfig {
	/** @param audio node */
	node: ParamTemplate<ParamType.NODE_PATH>;
}
declare abstract class BaseAudioSourceJsNode extends TypedJsNode<PauseAudioSourceJsParamsConfig> {
	readonly paramsConfig: PauseAudioSourceJsParamsConfig;
	initializeNode(): void;
}
declare class PauseAudioSourceJsNode extends BaseAudioSourceJsNode {
	static type(): string;
	setTriggerableLines(shadersCollectionController: JsLinesCollectionController): void;
	setTriggeringLines(shadersCollectionController: JsLinesCollectionController, triggeredMethods: string): void;
}
declare class PhysicsDebugUpdateJsNode extends ParamlessBaseTriggerAndObjectJsNode {
	static type(): string;
	setTriggerableLines(shadersCollectionController: JsLinesCollectionController): void;
}
declare class PhysicsPlayerUpdateJsParamsConfig extends NodeParamsConfig {
	/** @param travel speed */
	speed: ParamTemplate<ParamType.FLOAT>;
	/** @param run Allowed */
	runAllowed: ParamTemplate<ParamType.BOOLEAN>;
	/** @param jump Force */
	runSpeedMult: ParamTemplate<ParamType.FLOAT>;
	/** @param jump Allowed */
	jumpAllowed: ParamTemplate<ParamType.BOOLEAN>;
	/** @param jump Force */
	jumpStrength: ParamTemplate<ParamType.FLOAT>;
	/** @param reset if position is below a threshold */
	resetIfBelowThreshold: ParamTemplate<ParamType.BOOLEAN>;
	/** @param height under which the player gets reset */
	resetThreshold: ParamTemplate<ParamType.FLOAT>;
}
declare class PhysicsPlayerUpdateJsNode extends TypedJsNode<PhysicsPlayerUpdateJsParamsConfig> {
	readonly paramsConfig: PhysicsPlayerUpdateJsParamsConfig;
	static type(): string;
	initializeNode(): void;
	setTriggerableLines(shadersCollectionController: JsLinesCollectionController): void;
}
declare class PhysicsRBDAddForceJsParamsConfig extends NodeParamsConfig {
	/** @param force */
	force: ParamTemplate<ParamType.VECTOR3>;
}
declare class PhysicsRBDAddForceJsNode extends TypedJsNode<PhysicsRBDAddForceJsParamsConfig> {
	readonly paramsConfig: PhysicsRBDAddForceJsParamsConfig;
	static type(): string;
	initializeNode(): void;
	setTriggerableLines(shadersCollectionController: JsLinesCollectionController): void;
}
declare class PhysicsRBDAddForceAtPointJsParamsConfig extends NodeParamsConfig {
	/** @param force */
	force: ParamTemplate<ParamType.VECTOR3>;
	/** @param point */
	point: ParamTemplate<ParamType.VECTOR3>;
}
declare class PhysicsRBDAddForceAtPointJsNode extends TypedJsNode<PhysicsRBDAddForceAtPointJsParamsConfig> {
	readonly paramsConfig: PhysicsRBDAddForceAtPointJsParamsConfig;
	static type(): string;
	initializeNode(): void;
	setTriggerableLines(shadersCollectionController: JsLinesCollectionController): void;
}
declare class PhysicsRBDAddTorqueJsParamsConfig extends NodeParamsConfig {
	/** @param torque */
	torque: ParamTemplate<ParamType.VECTOR3>;
}
declare class PhysicsRBDAddTorqueJsNode extends TypedJsNode<PhysicsRBDAddTorqueJsParamsConfig> {
	readonly paramsConfig: PhysicsRBDAddTorqueJsParamsConfig;
	static type(): string;
	initializeNode(): void;
	setTriggerableLines(shadersCollectionController: JsLinesCollectionController): void;
}
declare class PhysicsRBDApplyImpulseJsParamsConfig extends NodeParamsConfig {
	/** @param impulse */
	impulse: ParamTemplate<ParamType.VECTOR3>;
}
declare class PhysicsRBDApplyImpulseJsNode extends TypedJsNode<PhysicsRBDApplyImpulseJsParamsConfig> {
	readonly paramsConfig: PhysicsRBDApplyImpulseJsParamsConfig;
	static type(): string;
	initializeNode(): void;
	setTriggerableLines(shadersCollectionController: JsLinesCollectionController): void;
}
declare class PhysicsRBDApplyTorqueImpulseJsParamsConfig extends NodeParamsConfig {
	/** @param impulse */
	impulse: ParamTemplate<ParamType.VECTOR3>;
}
declare class PhysicsRBDApplyTorqueImpulseJsNode extends TypedJsNode<PhysicsRBDApplyTorqueImpulseJsParamsConfig> {
	readonly paramsConfig: PhysicsRBDApplyTorqueImpulseJsParamsConfig;
	static type(): string;
	initializeNode(): void;
	setTriggerableLines(shadersCollectionController: JsLinesCollectionController): void;
}
declare class PhysicsRBDApplyImpulseAtPointJsParamsConfig extends NodeParamsConfig {
	/** @param impulse */
	impulse: ParamTemplate<ParamType.VECTOR3>;
	/** @param point */
	point: ParamTemplate<ParamType.VECTOR3>;
}
declare class PhysicsRBDApplyImpulseAtPointJsNode extends TypedJsNode<PhysicsRBDApplyImpulseAtPointJsParamsConfig> {
	readonly paramsConfig: PhysicsRBDApplyImpulseAtPointJsParamsConfig;
	static type(): string;
	initializeNode(): void;
	setTriggerableLines(shadersCollectionController: JsLinesCollectionController): void;
}
declare class PhysicsRBDResetAllJsParamsConfig extends NodeParamsConfig {
	/** @param wakeup */
	wakeup: ParamTemplate<ParamType.BOOLEAN>;
}
declare class PhysicsRBDResetAllJsNode extends TypedJsNode<PhysicsRBDResetAllJsParamsConfig> {
	readonly paramsConfig: PhysicsRBDResetAllJsParamsConfig;
	static type(): string;
	initializeNode(): void;
	setTriggerableLines(shadersCollectionController: JsLinesCollectionController): void;
}
declare class PhysicsRBDResetForcesJsParamsConfig extends NodeParamsConfig {
	/** @param wakeup */
	wakeup: ParamTemplate<ParamType.BOOLEAN>;
}
declare class PhysicsRBDResetForcesJsNode extends TypedJsNode<PhysicsRBDResetForcesJsParamsConfig> {
	readonly paramsConfig: PhysicsRBDResetForcesJsParamsConfig;
	static type(): string;
	initializeNode(): void;
	setTriggerableLines(shadersCollectionController: JsLinesCollectionController): void;
}
declare class PhysicsRBDResetTorquesJsParamsConfig extends NodeParamsConfig {
	/** @param wakeup */
	wakeup: ParamTemplate<ParamType.BOOLEAN>;
}
declare class PhysicsRBDResetTorquesJsNode extends TypedJsNode<PhysicsRBDResetTorquesJsParamsConfig> {
	readonly paramsConfig: PhysicsRBDResetTorquesJsParamsConfig;
	static type(): string;
	initializeNode(): void;
	setTriggerableLines(shadersCollectionController: JsLinesCollectionController): void;
}
declare class PhysicsWorldResetJsNode extends ParamlessBaseTriggerAndObjectJsNode {
	static type(): string;
	setTriggerableLines(shadersCollectionController: JsLinesCollectionController): void;
}
declare class PhysicsWorldStepSimulationJsNode extends ParamlessBaseTriggerAndObjectJsNode {
	static type(): string;
	setTriggerableLines(shadersCollectionController: JsLinesCollectionController): void;
}
declare class PlaneJsParamsConfig extends NodeParamsConfig {
	/** @param a unit length vector defining the normal of the plane */
	normal: ParamTemplate<ParamType.VECTOR3>;
	/** @param the signed distance from the origin to the plane */
	constant: ParamTemplate<ParamType.FLOAT>;
}
declare class PlaneJsNode extends TypedJsNode<PlaneJsParamsConfig> {
	paramsConfig: PlaneJsParamsConfig;
	static type(): string;
	initializeNode(): void;
	setLines(shadersCollectionController: JsLinesCollectionController): void;
}
declare class PlayAnimationJsParamsConfig extends NodeParamsConfig {
	/** @param include children */
	node: ParamTemplate<ParamType.NODE_PATH>;
}
declare class PlayAnimationJsNode extends TypedJsNode<PlayAnimationJsParamsConfig> {
	readonly paramsConfig: PlayAnimationJsParamsConfig;
	static type(): string;
	requiredModules(): ModuleName[];
	initializeNode(): void;
	setTriggerableLines(shadersCollectionController: JsLinesCollectionController): void;
}
declare class PlayAudioSourceJsNode extends BaseAudioSourceJsNode {
	static type(): string;
	private _targetNodePath;
	setTriggerableLines(shadersCollectionController: JsLinesCollectionController): void;
}
declare class PlayerModeJsParamsConfig extends NodeParamsConfig {
}
declare class PlayerModeJsNode extends TypedJsNode<PlayerModeJsParamsConfig> {
	paramsConfig: PlayerModeJsParamsConfig;
	static type(): string;
	static readonly OUTPUT_NAME = "mode";
	initializeNode(): void;
	setLines(linesController: JsLinesCollectionController): void;
}
declare class PlayerUpdateJsParamsConfig extends NodeParamsConfig {
	/** @param travel speed */
	speed: ParamTemplate<ParamType.FLOAT>;
	/** @param run Allowed */
	runAllowed: ParamTemplate<ParamType.BOOLEAN>;
	/** @param jump Force */
	runSpeedMult: ParamTemplate<ParamType.FLOAT>;
	/** @param jump Allowed */
	jumpAllowed: ParamTemplate<ParamType.BOOLEAN>;
	/** @param jump Force */
	jumpStrength: ParamTemplate<ParamType.FLOAT>;
	/** @param physics Steps */
	physicsSteps: ParamTemplate<ParamType.INTEGER>;
	/** @param gravity */
	gravity: ParamTemplate<ParamType.VECTOR3>;
	/** @param collision Capsule Radius */
	capsuleRadius: ParamTemplate<ParamType.FLOAT>;
	/** @param collision Capsule Height */
	capsuleHeight: ParamTemplate<ParamType.FLOAT>;
}
declare class PlayerUpdateJsNode extends TypedJsNode<PlayerUpdateJsParamsConfig> {
	readonly paramsConfig: PlayerUpdateJsParamsConfig;
	static type(): string;
	initializeNode(): void;
	setTriggerableLines(shadersCollectionController: JsLinesCollectionController): void;
	setLines(shadersCollectionController: JsLinesCollectionController): void;
}
declare class PlayInstrumentNoteJsParamsConfig extends NodeParamsConfig {
	/** @param audio node */
	node: ParamTemplate<ParamType.NODE_PATH>;
	/** @param note */
	note: ParamTemplate<ParamType.STRING>;
	/** @param duration */
	duration: ParamTemplate<ParamType.FLOAT>;
}
declare class PlayInstrumentNoteJsNode extends TypedJsNode<PlayInstrumentNoteJsParamsConfig> {
	readonly paramsConfig: PlayInstrumentNoteJsParamsConfig;
	static type(): string;
	initializeNode(): void;
	setTriggerableLines(shadersCollectionController: JsLinesCollectionController): void;
}
declare class PolarTransformJsParamsConfig extends NodeParamsConfig {
	/** @param center of the transform */
	center: ParamTemplate<ParamType.VECTOR3>;
	/** @param moves the objects along the longitude, which is equivalent to a rotation on the y axis */
	longitude: ParamTemplate<ParamType.FLOAT>;
	/** @param moves the objects along the latitude, which is equivalent to a rotation on the z or x axis */
	latitude: ParamTemplate<ParamType.FLOAT>;
	/** @param moves the point aways from the center */
	depth: ParamTemplate<ParamType.FLOAT>;
}
declare class PolarTransformJsNode extends TypedJsNode<PolarTransformJsParamsConfig> {
	readonly paramsConfig: PolarTransformJsParamsConfig;
	static type(): string;
	initializeNode(): void;
	setLines(linesController: JsLinesCollectionController): void;
}
declare const PowJsNode_base: typeof BaseMathFunctionJsNode;
declare class PowJsNode extends PowJsNode_base {
	paramDefaultValue(name: string): number;
	protected _expectedInputName(index: number): string;
	protected _expectedInputTypes(): JsConnectionPointType[];
}
declare class PressButtonParamJsParamsConfig extends NodeParamsConfig {
	/** @param the parameter to update */
	Param: ParamTemplate<ParamType.PARAM_PATH>;
}
declare class PressButtonParamJsNode extends TypedJsNode<PressButtonParamJsParamsConfig> {
	readonly paramsConfig: PressButtonParamJsParamsConfig;
	static type(): string;
	initializeNode(): void;
	setParamPath(paramPath: string): void;
	setParamParam(param: BaseParamType): void;
	setTriggerableLines(linesController: JsLinesCollectionController): void;
}
declare enum PreviousValueJsNodeInputName {
	current = "current",
	offset = "offset"
}
declare class PreviousJsParamsConfig extends NodeParamsConfig {
	offset: ParamTemplate<ParamType.INTEGER>;
}
declare class PreviousValueJsNode extends TypedJsNode<PreviousJsParamsConfig> {
	paramsConfig: PreviousJsParamsConfig;
	static type(): string;
	static readonly OUTPUT_NAME = "prev";
	initializeNode(): void;
	paramDefaultValue(name: PreviousValueJsNodeInputName): number;
	protected _expectedInputTypes(): JsConnectionPointType[];
	protected _expectedInputName(index: number): string;
	protected _expectedOutputName(index: number): string;
	protected _expectedOutputTypes(): JsConnectionPointType[];
	setLines(shadersCollectionController: JsLinesCollectionController): void;
	private _functionName;
}
declare class QuaternionJsParamsConfig extends NodeParamsConfig {
	/** @param axis */
	axis: ParamTemplate<ParamType.VECTOR3>;
	/** @param rotation order */
	angle: ParamTemplate<ParamType.FLOAT>;
}
declare class QuaternionJsNode extends TypedJsNode<QuaternionJsParamsConfig> {
	paramsConfig: QuaternionJsParamsConfig;
	static type(): string;
	initializeNode(): void;
	setLines(linesController: JsLinesCollectionController): void;
}
declare class QuaternionAngleToJsParamsConfig extends NodeParamsConfig {
}
declare class QuaternionAngleToJsNode extends TypedJsNode<QuaternionAngleToJsParamsConfig> {
	paramsConfig: QuaternionAngleToJsParamsConfig;
	static type(): string;
	initializeNode(): void;
	setLines(linesController: JsLinesCollectionController): void;
}
declare class QuaternionSlerpJsParamsConfig extends NodeParamsConfig {
	lerp: ParamTemplate<ParamType.FLOAT>;
}
declare class QuaternionSlerpJsNode extends TypedJsNode<QuaternionSlerpJsParamsConfig> {
	paramsConfig: QuaternionSlerpJsParamsConfig;
	static type(): string;
	initializeNode(): void;
	setLines(linesController: JsLinesCollectionController): void;
}
declare const RadToDegJsNode_base: typeof BaseMathFunctionJsNode;
declare class RadToDegJsNode extends RadToDegJsNode_base {
	protected _coreFunction(shadersCollectionController: JsLinesCollectionController): string;
}
declare const RandJsNode_base: typeof BaseMathFunctionJsNode;
declare class RandJsNode extends RandJsNode_base {
	protected _coreFunction(shadersCollectionController: JsLinesCollectionController): string;
	paramDefaultValue(name: string): number;
	protected _expectedInputName(index: number): string;
	protected _expectedInputTypes(): JsConnectionPointType[];
}
declare class RandomJsParamsConfig extends NodeParamsConfig {
}
declare class RandomJsNode extends TypedJsNode<RandomJsParamsConfig> {
	readonly paramsConfig: RandomJsParamsConfig;
	static type(): string;
	initializeNode(): void;
	setLines(shadersCollectionController: JsLinesCollectionController): void;
}
declare class RayJsParamsConfig extends NodeParamsConfig {
	/** @param ray origin */
	origin: ParamTemplate<ParamType.VECTOR3>;
	/** @param ray direction */
	direction: ParamTemplate<ParamType.VECTOR3>;
}
declare class RayJsNode extends TypedJsNode<RayJsParamsConfig> {
	paramsConfig: RayJsParamsConfig;
	static type(): string;
	initializeNode(): void;
	setLines(shadersCollectionController: JsLinesCollectionController): void;
}
declare class RayFromCameraJsParamsConfig extends NodeParamsConfig {
	/** @param x position in screen space  */
	x: ParamTemplate<ParamType.FLOAT>;
	/** @param y position in screen space */
	y: ParamTemplate<ParamType.FLOAT>;
}
declare class RayFromCameraJsNode extends TypedJsNode<RayFromCameraJsParamsConfig> {
	paramsConfig: RayFromCameraJsParamsConfig;
	static type(): JsType;
	initializeNode(): void;
	setLines(shadersCollectionController: JsLinesCollectionController): void;
}
declare class RayFromCursorJsParamsConfig extends NodeParamsConfig {
	/** @param set which element triggers the event */
	element: ParamTemplate<ParamType.INTEGER>;
}
declare class RayFromCursorJsNode extends BaseUserInputJsNode<RayFromCursorJsParamsConfig> {
	paramsConfig: RayFromCursorJsParamsConfig;
	static type(): JsType;
	eventData(): EvaluatorEventData[] | undefined;
	eventEmitter(): CoreEventEmitter;
	setEventEmitter(emitter: CoreEventEmitter): void;
	initializeNode(): void;
	setLines(shadersCollectionController: JsLinesCollectionController): void;
}
declare class BaseRayBox3JsParamsConfig extends NodeParamsConfig {
}
declare abstract class BaseRayBox3JsNode extends TypedJsNode<BaseRayBox3JsParamsConfig> {
	paramsConfig: BaseRayBox3JsParamsConfig;
	initializeNode(): void;
}
declare class RayIntersectBoxJsNode extends BaseRayBox3JsNode {
	static type(): string;
	initializeNode(): void;
	setLines(shadersCollectionController: JsLinesCollectionController): void;
}
declare class RayIntersectsBoxJsNode extends BaseRayBox3JsNode {
	static type(): string;
	initializeNode(): void;
	setLines(shadersCollectionController: JsLinesCollectionController): void;
}
declare class RayIntersectObjectJsParamsConfig extends NodeParamsConfig {
	recursive: ParamTemplate<ParamType.BOOLEAN>;
}
declare class RayIntersectObjectJsNode extends TypedJsNode<RayIntersectObjectJsParamsConfig> {
	paramsConfig: RayIntersectObjectJsParamsConfig;
	static type(): string;
	initializeNode(): void;
	setLines(linesController: JsLinesCollectionController): void;
}
declare class BaseRayObjectJsParamsConfig extends NodeParamsConfig {
}
declare abstract class BaseRayObjectJsNode extends TypedJsNode<BaseRayObjectJsParamsConfig> {
	paramsConfig: BaseRayObjectJsParamsConfig;
	initializeNode(): void;
	protected _additionalInputs(): JsConnectionPoint<JsConnectionPointType>[];
}
declare class RayIntersectsObjectJsNode extends BaseRayObjectJsNode {
	static type(): string;
	initializeNode(): void;
	protected _additionalInputs(): JsConnectionPoint<JsConnectionPointType>[];
	setLines(linesController: JsLinesCollectionController): void;
}
declare class BaseRayPlaneJsParamsConfig extends NodeParamsConfig {
}
declare abstract class BaseRayPlaneJsNode extends TypedJsNode<BaseRayPlaneJsParamsConfig> {
	paramsConfig: BaseRayPlaneJsParamsConfig;
	initializeNode(): void;
}
declare class RayDistanceToPlaneJsNode extends BaseRayPlaneJsNode {
	static type(): string;
	initializeNode(): void;
	setLines(shadersCollectionController: JsLinesCollectionController): void;
}
declare class RayIntersectPlaneJsNode extends BaseRayPlaneJsNode {
	static type(): string;
	initializeNode(): void;
	setLines(shadersCollectionController: JsLinesCollectionController): void;
}
declare class RayIntersectsPlaneJsNode extends BaseRayPlaneJsNode {
	static type(): string;
	initializeNode(): void;
	setLines(shadersCollectionController: JsLinesCollectionController): void;
}
declare class BaseRaySphereJsParamsConfig extends NodeParamsConfig {
}
declare abstract class BaseRaySphereJsNode extends TypedJsNode<BaseRaySphereJsParamsConfig> {
	paramsConfig: BaseRaySphereJsParamsConfig;
	initializeNode(): void;
}
declare class RayIntersectSphereJsNode extends BaseRaySphereJsNode {
	static type(): string;
	initializeNode(): void;
	setLines(shadersCollectionController: JsLinesCollectionController): void;
}
declare class RayIntersectsSphereJsNode extends BaseRaySphereJsNode {
	static type(): string;
	initializeNode(): void;
	setLines(shadersCollectionController: JsLinesCollectionController): void;
}
declare class RenderPixelJsParamsConfig extends NodeParamsConfig {
	uv: ParamTemplate<ParamType.VECTOR2>;
	backgroundColor: ParamTemplate<ParamType.COLOR>;
}
declare class RenderPixelJsNode extends TypedJsNode<RenderPixelJsParamsConfig> {
	readonly paramsConfig: RenderPixelJsParamsConfig;
	static type(): string;
	initializeNode(): void;
	setLines(linesController: JsLinesCollectionController): void;
	setTriggerableLines(linesController: JsLinesCollectionController): void;
	private _addValueRef;
}
declare enum JsRotateMode {
	AXIS = 0,
	QUAT = 1
}
// @ts-ignore
declare class RotateParamsConfig extends NodeParamsConfig {
	mode: ParamTemplate<ParamType.INTEGER>;
}
declare class RotateJsNode extends TypedJsNode<RotateParamsConfig> {
	paramsConfig: RotateParamsConfig;
	static type(): string;
	initializeNode(): void;
	setMode(mode: JsRotateMode): void;
	mode(): JsRotateMode;
	protected _expectedInputName(index: number): string;
	protected _expectedOutputName(index: number): JsConnectionPointType;
	paramDefaultValue(name: string): Number3;
	functionName(): string;
	protected _expectedInputTypes(): JsConnectionPointType[];
	protected _expectedOutputTypes(): JsConnectionPointType[];
	setLines(linesController: JsLinesCollectionController): void;
	private _setLinesForAxisAngle;
	private _setLinesForQuat;
}
declare const RoundJsNode_base: typeof BaseMathFunctionJsNode;
declare class RoundJsNode extends RoundJsNode_base {
}
declare class BaseSDF2DJsParamsConfig extends NodeParamsConfig {
	position: ParamTemplate<ParamType.VECTOR2>;
}
declare class BaseSDF2DJsNode<K extends BaseSDF2DJsParamsConfig> extends TypedJsNode<K> {
}
declare class SDF2DBoxJsParamsConfig extends NodeParamsConfig {
	position: ParamTemplate<ParamType.VECTOR2>;
	center: ParamTemplate<ParamType.VECTOR2>;
	sizes: ParamTemplate<ParamType.VECTOR2>;
}
declare class SDF2DBoxJsNode extends BaseSDF2DJsNode<SDF2DBoxJsParamsConfig> {
	paramsConfig: SDF2DBoxJsParamsConfig;
	static type(): JsType;
	initializeNode(): void;
	setLines(shadersCollectionController: JsLinesCollectionController): void;
}
declare class SDF2DCircleJsParamsConfig extends NodeParamsConfig {
	position: ParamTemplate<ParamType.VECTOR2>;
	center: ParamTemplate<ParamType.VECTOR2>;
	radius: ParamTemplate<ParamType.FLOAT>;
}
declare class SDF2DCircleJsNode extends BaseSDF2DJsNode<SDF2DCircleJsParamsConfig> {
	paramsConfig: SDF2DCircleJsParamsConfig;
	static type(): JsType;
	initializeNode(): void;
	setLines(shadersCollectionController: JsLinesCollectionController): void;
}
declare class SDF2DCrossJsParamsConfig extends NodeParamsConfig {
	position: ParamTemplate<ParamType.VECTOR2>;
	center: ParamTemplate<ParamType.VECTOR2>;
	length: ParamTemplate<ParamType.FLOAT>;
	width: ParamTemplate<ParamType.FLOAT>;
	radius: ParamTemplate<ParamType.FLOAT>;
}
declare class SDF2DCrossJsNode extends BaseSDF2DJsNode<SDF2DCrossJsParamsConfig> {
	paramsConfig: SDF2DCrossJsParamsConfig;
	static type(): JsType;
	initializeNode(): void;
	setLines(shadersCollectionController: JsLinesCollectionController): void;
}
declare class SDF2DHeartJsParamsConfig extends NodeParamsConfig {
	position: ParamTemplate<ParamType.VECTOR2>;
	center: ParamTemplate<ParamType.VECTOR2>;
}
declare class SDF2DHeartJsNode extends BaseSDF2DJsNode<SDF2DHeartJsParamsConfig> {
	paramsConfig: SDF2DHeartJsParamsConfig;
	static type(): JsType;
	initializeNode(): void;
	setLines(shadersCollectionController: JsLinesCollectionController): void;
}
declare class SDF2DRoundedXJsParamsConfig extends NodeParamsConfig {
	position: ParamTemplate<ParamType.VECTOR2>;
	center: ParamTemplate<ParamType.VECTOR2>;
	length: ParamTemplate<ParamType.FLOAT>;
	radius: ParamTemplate<ParamType.FLOAT>;
}
declare class SDF2DRoundedXJsNode extends BaseSDF2DJsNode<SDF2DRoundedXJsParamsConfig> {
	paramsConfig: SDF2DRoundedXJsParamsConfig;
	static type(): JsType;
	initializeNode(): void;
	setLines(shadersCollectionController: JsLinesCollectionController): void;
}
declare class BaseSDFJsParamsConfig extends NodeParamsConfig {
	position: ParamTemplate<ParamType.VECTOR3>;
}
declare class BaseSDFJsNode<K extends BaseSDFJsParamsConfig> extends TypedJsNode<K> {
	protected position(shadersCollectionController: JsLinesCollectionController): string;
	private _defaultPosition;
}
declare class SDFBoxJsParamsConfig extends NodeParamsConfig {
	position: ParamTemplate<ParamType.VECTOR3>;
	center: ParamTemplate<ParamType.VECTOR3>;
	size: ParamTemplate<ParamType.FLOAT>;
	sizes: ParamTemplate<ParamType.VECTOR3>;
}
declare class SDFBoxJsNode extends BaseSDFJsNode<SDFBoxJsParamsConfig> {
	paramsConfig: SDFBoxJsParamsConfig;
	static type(): JsType;
	initializeNode(): void;
	setLines(shadersCollectionController: JsLinesCollectionController): void;
}
declare class SDFElongateJsParamsConfig extends NodeParamsConfig {
	position: ParamTemplate<ParamType.VECTOR3>;
	center: ParamTemplate<ParamType.VECTOR3>;
	mult: ParamTemplate<ParamType.VECTOR3>;
	fast: ParamTemplate<ParamType.BOOLEAN>;
}
declare class SDFElongateJsNode extends BaseSDFJsNode<SDFElongateJsParamsConfig> {
	paramsConfig: SDFElongateJsParamsConfig;
	static type(): string;
	initializeNode(): void;
	setLines(linesController: JsLinesCollectionController): void;
}
declare class SDFIntersectJsParamsConfig extends NodeParamsConfig {
	sdf0: ParamTemplate<ParamType.FLOAT>;
	sdf1: ParamTemplate<ParamType.FLOAT>;
	smooth: ParamTemplate<ParamType.BOOLEAN>;
	smoothFactor: ParamTemplate<ParamType.FLOAT>;
}
declare class SDFIntersectJsNode extends TypedJsNode<SDFIntersectJsParamsConfig> {
	paramsConfig: SDFIntersectJsParamsConfig;
	static type(): string;
	initializeNode(): void;
	setLines(shadersCollectionController: JsLinesCollectionController): void;
}
declare class SDFOnionJsParamsConfig extends NodeParamsConfig {
	sdf: ParamTemplate<ParamType.FLOAT>;
	thickness: ParamTemplate<ParamType.FLOAT>;
}
declare class SDFOnionJsNode extends TypedJsNode<SDFOnionJsParamsConfig> {
	paramsConfig: SDFOnionJsParamsConfig;
	static type(): JsType;
	initializeNode(): void;
	setLines(linesController: JsLinesCollectionController): void;
}
declare class SDFPlaneJsParamsConfig extends NodeParamsConfig {
	position: ParamTemplate<ParamType.VECTOR3>;
	center: ParamTemplate<ParamType.VECTOR3>;
	normal: ParamTemplate<ParamType.VECTOR3>;
	offset: ParamTemplate<ParamType.FLOAT>;
}
declare class SDFPlaneJsNode extends BaseSDFJsNode<SDFPlaneJsParamsConfig> {
	paramsConfig: SDFPlaneJsParamsConfig;
	static type(): JsType;
	initializeNode(): void;
	setLines(shadersCollectionController: JsLinesCollectionController): void;
}
declare enum SDFRevolutionJsAxis {
	X = "X",
	Y = "Y",
	Z = "Z"
}
declare class SDFRevolutionJsParamsConfig extends NodeParamsConfig {
	position: ParamTemplate<ParamType.VECTOR3>;
	center: ParamTemplate<ParamType.VECTOR3>;
	radius: ParamTemplate<ParamType.FLOAT>;
	axis: ParamTemplate<ParamType.INTEGER>;
}
declare class SDFRevolutionJsNode extends BaseSDFJsNode<SDFRevolutionJsParamsConfig> {
	paramsConfig: SDFRevolutionJsParamsConfig;
	static type(): JsType;
	initializeNode(): void;
	setAxis(axis: SDFRevolutionJsAxis): void;
	setLines(linesController: JsLinesCollectionController): void;
	private _functionName;
}
declare class SDFSphereJsParamsConfig extends NodeParamsConfig {
	position: ParamTemplate<ParamType.VECTOR3>;
	center: ParamTemplate<ParamType.VECTOR3>;
	radius: ParamTemplate<ParamType.FLOAT>;
}
declare class SDFSphereJsNode extends BaseSDFJsNode<SDFSphereJsParamsConfig> {
	paramsConfig: SDFSphereJsParamsConfig;
	static type(): JsType;
	initializeNode(): void;
	setLines(shadersCollectionController: JsLinesCollectionController): void;
}
declare class SDFSubtractJsParamsConfig extends NodeParamsConfig {
	sdf0: ParamTemplate<ParamType.FLOAT>;
	sdf1: ParamTemplate<ParamType.FLOAT>;
	smooth: ParamTemplate<ParamType.BOOLEAN>;
	smoothFactor: ParamTemplate<ParamType.FLOAT>;
}
declare class SDFSubtractJsNode extends TypedJsNode<SDFSubtractJsParamsConfig> {
	paramsConfig: SDFSubtractJsParamsConfig;
	static type(): string;
	initializeNode(): void;
	setLines(shadersCollectionController: JsLinesCollectionController): void;
}
declare class SDFTorusJsParamsConfig extends NodeParamsConfig {
	position: ParamTemplate<ParamType.VECTOR3>;
	center: ParamTemplate<ParamType.VECTOR3>;
	radius1: ParamTemplate<ParamType.FLOAT>;
	radius2: ParamTemplate<ParamType.FLOAT>;
}
declare class SDFTorusJsNode extends BaseSDFJsNode<SDFTorusJsParamsConfig> {
	paramsConfig: SDFTorusJsParamsConfig;
	static type(): JsType;
	initializeNode(): void;
	setLines(shadersCollectionController: JsLinesCollectionController): void;
}
declare class SDFTransformJsParamsConfig extends NodeParamsConfig {
	position: ParamTemplate<ParamType.VECTOR3>;
	t: ParamTemplate<ParamType.VECTOR3>;
	r: ParamTemplate<ParamType.VECTOR3>;
}
declare class SDFTransformJsNode extends BaseSDFJsNode<SDFTransformJsParamsConfig> {
	paramsConfig: SDFTransformJsParamsConfig;
	static type(): JsType;
	initializeNode(): void;
	setLines(linesController: JsLinesCollectionController): void;
}
declare class SDFTubeJsParamsConfig extends NodeParamsConfig {
	position: ParamTemplate<ParamType.VECTOR3>;
	center: ParamTemplate<ParamType.VECTOR3>;
	radius: ParamTemplate<ParamType.FLOAT>;
}
declare class SDFTubeJsNode extends BaseSDFJsNode<SDFTubeJsParamsConfig> {
	paramsConfig: SDFTubeJsParamsConfig;
	static type(): JsType;
	initializeNode(): void;
	setLines(shadersCollectionController: JsLinesCollectionController): void;
}
declare class SDFUnionJsParamsConfig extends NodeParamsConfig {
	sdf0: ParamTemplate<ParamType.FLOAT>;
	sdf1: ParamTemplate<ParamType.FLOAT>;
	smooth: ParamTemplate<ParamType.BOOLEAN>;
	smoothFactor: ParamTemplate<ParamType.FLOAT>;
}
declare class SDFUnionJsNode extends TypedJsNode<SDFUnionJsParamsConfig> {
	paramsConfig: SDFUnionJsParamsConfig;
	static type(): string;
	initializeNode(): void;
	setLines(shadersCollectionController: JsLinesCollectionController): void;
}
declare class SetCameraViewOffsetJsParamsConfig extends NodeParamsConfig {
	/** @param min */
	min: ParamTemplate<ParamType.VECTOR2>;
	/** @param max */
	max: ParamTemplate<ParamType.VECTOR2>;
}
declare class SetCameraViewOffsetJsNode extends TypedJsNode<SetCameraViewOffsetJsParamsConfig> {
	readonly paramsConfig: SetCameraViewOffsetJsParamsConfig;
	static type(): string;
	initializeNode(): void;
	setLines(linesController: JsLinesCollectionController): void;
	setTriggerableLines(shadersCollectionController: JsLinesCollectionController): void;
}
declare class SetClothConstraintPositionJsParamsConfig extends NodeParamsConfig {
	position: ParamTemplate<ParamType.VECTOR3>;
	lerp: ParamTemplate<ParamType.FLOAT>;
}
declare class SetClothConstraintPositionJsNode extends BaseTriggerAndObjectJsNode<SetClothConstraintPositionJsParamsConfig> {
	readonly paramsConfig: SetClothConstraintPositionJsParamsConfig;
	static type(): string;
	setTriggerableLines(shadersCollectionController: JsLinesCollectionController): void;
}
declare class SetCSSObjectClassJsParamsConfig extends NodeParamsConfig {
	/** @param class */
	class: ParamTemplate<ParamType.STRING>;
	/** @param set to true to add the class, or false to remove */
	addRemove: ParamTemplate<ParamType.BOOLEAN>;
}
declare class SetCSSObjectClassJsNode extends TypedJsNode<SetCSSObjectClassJsParamsConfig> {
	readonly paramsConfig: SetCSSObjectClassJsParamsConfig;
	static type(): string;
	initializeNode(): void;
	setLines(linesController: JsLinesCollectionController): void;
	setTriggerableLines(linesController: JsLinesCollectionController): void;
}
declare class SetGeometryInstanceAttributeJsParamsConfig extends NodeParamsConfig {
	/** @param attribute name */
	attribName: ParamTemplate<ParamType.STRING>;
}
declare class SetGeometryInstanceAttributeJsNode extends TypedJsNode<SetGeometryInstanceAttributeJsParamsConfig> {
	readonly paramsConfig: SetGeometryInstanceAttributeJsParamsConfig;
	static type(): string;
	initializeNode(): void;
	private _expectedInputTypes;
	paramDefaultValue(name: string): number | boolean;
	setLines(linesController: JsLinesCollectionController): void;
	protected _expectedInputName(index: number): string;
	setTriggerableLines(shadersCollectionController: JsLinesCollectionController): void;
	private _functionName;
}
declare class SetGeometryInstancePositionsJsParamsConfig extends NodeParamsConfig {
}
declare class SetGeometryInstancePositionsJsNode extends TypedJsNode<SetGeometryInstancePositionsJsParamsConfig> {
	readonly paramsConfig: SetGeometryInstancePositionsJsParamsConfig;
	static type(): string;
	initializeNode(): void;
	paramDefaultValue(name: string): number | boolean;
	expectedInputTypes(): JsConnectionPointType[];
	protected _expectedOutputTypes(): JsConnectionPointType[];
	protected _expectedInputName(index: number): string;
	setLines(linesController: JsLinesCollectionController): void;
	setTriggerableLines(shadersCollectionController: JsLinesCollectionController): void;
}
declare class SetGeometryInstanceQuaternionsJsParamsConfig extends NodeParamsConfig {
}
declare class SetGeometryInstanceQuaternionsJsNode extends TypedJsNode<SetGeometryInstanceQuaternionsJsParamsConfig> {
	readonly paramsConfig: SetGeometryInstanceQuaternionsJsParamsConfig;
	static type(): string;
	initializeNode(): void;
	paramDefaultValue(name: string): number | boolean;
	expectedInputTypes(): JsConnectionPointType[];
	protected _expectedOutputTypes(): JsConnectionPointType[];
	protected _expectedInputName(index: number): string;
	setLines(linesController: JsLinesCollectionController): void;
	setTriggerableLines(shadersCollectionController: JsLinesCollectionController): void;
}
declare class SetGeometryInstanceScalesJsParamsConfig extends NodeParamsConfig {
}
declare class SetGeometryInstanceScalesJsNode extends TypedJsNode<SetGeometryInstanceScalesJsParamsConfig> {
	readonly paramsConfig: SetGeometryInstanceScalesJsParamsConfig;
	static type(): string;
	initializeNode(): void;
	paramDefaultValue(name: string): number | boolean;
	expectedInputTypes(): JsConnectionPointType[];
	protected _expectedOutputTypes(): JsConnectionPointType[];
	protected _expectedInputName(index: number): string;
	setLines(linesController: JsLinesCollectionController): void;
	setTriggerableLines(shadersCollectionController: JsLinesCollectionController): void;
}
declare class SetGeometryInstanceTransformsJsParamsConfig extends NodeParamsConfig {
}
declare class SetGeometryInstanceTransformsJsNode extends TypedJsNode<SetGeometryInstanceTransformsJsParamsConfig> {
	readonly paramsConfig: SetGeometryInstanceTransformsJsParamsConfig;
	static type(): string;
	initializeNode(): void;
	paramDefaultValue(name: string): number | boolean;
	expectedInputTypes(): JsConnectionPointType[];
	protected _expectedOutputTypes(): JsConnectionPointType[];
	protected _expectedInputName(index: number): string;
	setLines(linesController: JsLinesCollectionController): void;
	setTriggerableLines(shadersCollectionController: JsLinesCollectionController): void;
}
declare class SetGeometryPositionsJsParamsConfig extends NodeParamsConfig {
	lerp: ParamTemplate<ParamType.FLOAT>;
	attributeNeedsUpdate: ParamTemplate<ParamType.BOOLEAN>;
	computeNormals: ParamTemplate<ParamType.BOOLEAN>;
	computeTangents: ParamTemplate<ParamType.BOOLEAN>;
}
declare class SetGeometryPositionsJsNode extends TypedJsNode<SetGeometryPositionsJsParamsConfig> {
	readonly paramsConfig: SetGeometryPositionsJsParamsConfig;
	static type(): string;
	initializeNode(): void;
	paramDefaultValue(name: string): number | boolean;
	expectedInputTypes(): JsConnectionPointType[];
	protected _expectedInputName(index: number): string;
	protected _expectedOutputTypes(): JsConnectionPointType[];
	protected _expectedOutputNames(i: number): JsConnectionPointType;
	setLines(linesController: JsLinesCollectionController): void;
	setTriggerableLines(shadersCollectionController: JsLinesCollectionController): void;
}
declare class SetPointAttributeJsParamsConfig extends NodeParamsConfig {
	/** @param attribute type */
	type: ParamTemplate<ParamType.INTEGER>;
	/** @param attribName */
	attribName: ParamTemplate<ParamType.STRING>;
	/** @param point index */
	ptnum: ParamTemplate<ParamType.INTEGER>;
	/** @param lerp factor */
	lerp: ParamTemplate<ParamType.FLOAT>;
}
declare class SetPointAttributeJsNode extends TypedJsNode<SetPointAttributeJsParamsConfig> {
	readonly paramsConfig: SetPointAttributeJsParamsConfig;
	static type(): JsType;
	initializeNode(): void;
	private _expectedInputType;
	private _expectedOutputTypes;
	private _expectedInputName;
	private _expectedOutputName;
	private _currentConnectionType;
	setAttribType(type: PointAttributeJsType): void;
	setAttribName(attribName: string): void;
	setLines(linesController: JsLinesCollectionController): void;
	setTriggerableLines(linesController: JsLinesCollectionController): void;
	private _functionName;
}
declare class SetInstanceAttributeJsNode extends SetPointAttributeJsNode {
	static type(): JsType;
}
declare class SetInstanceLookAtJsParamsConfig extends NodeParamsConfig {
	/** @param point index */
	ptnum: ParamTemplate<ParamType.INTEGER>;
	/** @param target position */
	targetPosition: ParamTemplate<ParamType.VECTOR3>;
	/** @param up */
	up: ParamTemplate<ParamType.VECTOR3>;
	/** @param lerp factor */
	lerp: ParamTemplate<ParamType.FLOAT>;
}
declare class SetInstanceLookAtJsNode extends BaseTriggerAndObjectJsNode<SetInstanceLookAtJsParamsConfig> {
	readonly paramsConfig: SetInstanceLookAtJsParamsConfig;
	static type(): JsType;
	protected _additionalOutputs(): JsConnectionPoint<JsConnectionPointType>[];
	setLines(linesController: JsLinesCollectionController): void;
	setTriggerableLines(linesController: JsLinesCollectionController): void;
}
declare class SetInstancePositionJsParamsConfig extends NodeParamsConfig {
	/** @param point index */
	ptnum: ParamTemplate<ParamType.INTEGER>;
	/** @param target position */
	position: ParamTemplate<ParamType.VECTOR3>;
	/** @param lerp factor */
	lerp: ParamTemplate<ParamType.FLOAT>;
}
declare class SetInstancePositionJsNode extends BaseTriggerAndObjectJsNode<SetInstancePositionJsParamsConfig> {
	readonly paramsConfig: SetInstancePositionJsParamsConfig;
	static type(): JsType;
	protected _additionalOutputs(): JsConnectionPoint<JsConnectionPointType>[];
	setLines(linesController: JsLinesCollectionController): void;
	setTriggerableLines(linesController: JsLinesCollectionController): void;
}
declare class SetInstanceQuaternionJsParamsConfig extends NodeParamsConfig {
	/** @param point index */
	ptnum: ParamTemplate<ParamType.INTEGER>;
	/** @param lerp factor */
	lerp: ParamTemplate<ParamType.FLOAT>;
}
declare class SetInstanceQuaternionJsNode extends TypedJsNode<SetInstanceQuaternionJsParamsConfig> {
	readonly paramsConfig: SetInstanceQuaternionJsParamsConfig;
	static type(): JsType;
	initializeNode(): void;
	setLines(linesController: JsLinesCollectionController): void;
	setTriggerableLines(linesController: JsLinesCollectionController): void;
}
declare class SetInstanceScaleJsParamsConfig extends NodeParamsConfig {
	/** @param point index */
	ptnum: ParamTemplate<ParamType.INTEGER>;
	/** @param target scale */
	scale: ParamTemplate<ParamType.VECTOR3>;
	/** @param target scale */
	mult: ParamTemplate<ParamType.FLOAT>;
	/** @param lerp factor */
	lerp: ParamTemplate<ParamType.FLOAT>;
}
declare class SetInstanceScaleJsNode extends BaseTriggerAndObjectJsNode<SetInstanceScaleJsParamsConfig> {
	readonly paramsConfig: SetInstanceScaleJsParamsConfig;
	static type(): JsType;
	protected _additionalOutputs(): JsConnectionPoint<JsConnectionPointType>[];
	setLines(linesController: JsLinesCollectionController): void;
	setTriggerableLines(linesController: JsLinesCollectionController): void;
}
declare class BaseSetMaterialTextureJsParamsConfig extends NodeParamsConfig {
}
declare abstract class BaseSetMaterialTextureJsNode extends TypedJsNode<BaseSetMaterialTextureJsParamsConfig> {
	readonly paramsConfig: BaseSetMaterialTextureJsParamsConfig;
	initializeNode(): void;
	setLines(linesController: JsLinesCollectionController): void;
	setTriggerableLines(linesController: JsLinesCollectionController): void;
	abstract _functionName(): "setMaterialMap" | "setMaterialAlphaMap" | "setMaterialAOMap" | "setMaterialDisplacementMap" | "setMaterialEnvMap" | "setMaterialEmissiveMap" | "setMaterialMetalnessMap" | "setMaterialRoughnessMap";
}
declare class SetMaterialAlphaMapJsNode extends BaseSetMaterialTextureJsNode {
	static type(): string;
	_functionName(): "setMaterialAlphaMap";
}
declare class SetMaterialAOMapJsNode extends BaseSetMaterialTextureJsNode {
	static type(): string;
	_functionName(): "setMaterialAOMap";
}
declare class BaseSetMaterialColorJsParamsConfig extends NodeParamsConfig {
	/** @param color */
	color: ParamTemplate<ParamType.COLOR>;
	/** @param lerp factor */
	lerp: ParamTemplate<ParamType.FLOAT>;
}
declare abstract class BaseSetMaterialColorJsNode extends TypedJsNode<BaseSetMaterialColorJsParamsConfig> {
	readonly paramsConfig: BaseSetMaterialColorJsParamsConfig;
	initializeNode(): void;
	setLines(linesController: JsLinesCollectionController): void;
	setTriggerableLines(shadersCollectionController: JsLinesCollectionController): void;
	abstract _functionName(): "setMaterialColor" | "setMaterialEmissiveColor";
}
declare class SetMaterialColorJsNode extends BaseSetMaterialColorJsNode {
	static type(): string;
	_functionName(): "setMaterialColor";
}
declare class SetMaterialDisplacementMapJsNode extends BaseSetMaterialTextureJsNode {
	static type(): string;
	_functionName(): "setMaterialDisplacementMap";
}
declare class SetMaterialEmissiveColorJsNode extends BaseSetMaterialColorJsNode {
	static type(): string;
	_functionName(): "setMaterialEmissiveColor";
}
declare class SetMaterialEnvMapJsNode extends BaseSetMaterialTextureJsNode {
	static type(): string;
	_functionName(): "setMaterialEnvMap";
}
declare class SetMaterialEmissiveMapJsNode extends BaseSetMaterialTextureJsNode {
	static type(): string;
	_functionName(): "setMaterialEmissiveMap";
}
declare class SetMaterialMapJsNode extends BaseSetMaterialTextureJsNode {
	static type(): string;
	_functionName(): "setMaterialMap";
}
declare class SetMaterialMetalnessMapJsNode extends BaseSetMaterialTextureJsNode {
	static type(): string;
	_functionName(): "setMaterialMetalnessMap";
}
declare class SetMaterialRoughnessMapJsNode extends BaseSetMaterialTextureJsNode {
	static type(): string;
	_functionName(): "setMaterialRoughnessMap";
}
declare class BaseSetMaterialFloatJsParamsConfig extends NodeParamsConfig {
	/** @param float */
	float: ParamTemplate<ParamType.FLOAT>;
	/** @param lerp factor */
	lerp: ParamTemplate<ParamType.FLOAT>;
}
declare abstract class BaseSetMaterialFloatJsNode extends TypedJsNode<BaseSetMaterialFloatJsParamsConfig> {
	readonly paramsConfig: BaseSetMaterialFloatJsParamsConfig;
	initializeNode(): void;
	setLines(linesController: JsLinesCollectionController): void;
	setTriggerableLines(shadersCollectionController: JsLinesCollectionController): void;
	abstract _functionName(): "setMaterialOpacity";
}
declare class SetMaterialOpacityJsNode extends BaseSetMaterialFloatJsNode {
	static type(): string;
	_functionName(): "setMaterialOpacity";
}
type AvailableJsType = JsConnectionPointType.COLOR | JsConnectionPointType.FLOAT | JsConnectionPointType.INT | JsConnectionPointType.TEXTURE | JsConnectionPointType.VECTOR2 | JsConnectionPointType.VECTOR3 | JsConnectionPointType.VECTOR4;
declare class SetMaterialUniformJsParamsConfig extends NodeParamsConfig {
	/** @param printWarnings */
	printWarnings: ParamTemplate<ParamType.BOOLEAN>;
	/** @param add prefix */
	addPrefix: ParamTemplate<ParamType.BOOLEAN>;
	/** @param uniform type */
	type: ParamTemplate<ParamType.INTEGER>;
}
declare class SetMaterialUniformJsNode extends TypedJsNode<SetMaterialUniformJsParamsConfig> {
	readonly paramsConfig: SetMaterialUniformJsParamsConfig;
	static type(): string;
	initializeNode(): void;
	private _expectedInputNames;
	private _expectedInputType;
	paramDefaultValue(name: "lerp"): number;
	uniformType(): AvailableJsType;
	setUniformType(type: AvailableJsType): void;
	setLines(linesController: JsLinesCollectionController): void;
	setTriggerableLines(shadersCollectionController: JsLinesCollectionController): void;
	private _isUniformNumber;
	private _isUniformVectorColor;
	private _lerpAllowed;
}
declare enum SetObjectAttributeInputName {
	attribName = "attribName",
	lerp = "lerp",
	val = "val"
}
declare class SetObjectAttributeJsParamsConfig extends NodeParamsConfig {
	/** @param attribute type */
	type: ParamTemplate<ParamType.INTEGER>;
}
declare class SetObjectAttributeJsNode extends TypedJsNode<SetObjectAttributeJsParamsConfig> {
	readonly paramsConfig: SetObjectAttributeJsParamsConfig;
	static type(): JsType;
	initializeNode(): void;
	private _currentConnectionType;
	private _nextAttribName;
	paramDefaultValue(name: SetObjectAttributeInputName): string | number;
	setAttribType(type: ParamConvertibleJsType): void;
	setAttribName(attribName: string): void;
	setLines(linesController: JsLinesCollectionController): void;
	setTriggerableLines(shadersCollectionController: JsLinesCollectionController): void;
}
declare class SetObjectCastShadowJsParamsConfig extends NodeParamsConfig {
	/** @param target castShadow state */
	castShadow: ParamTemplate<ParamType.BOOLEAN>;
}
declare class SetObjectCastShadowJsNode extends TypedJsNode<SetObjectCastShadowJsParamsConfig> {
	readonly paramsConfig: SetObjectCastShadowJsParamsConfig;
	static type(): string;
	initializeNode(): void;
	setLines(linesController: JsLinesCollectionController): void;
	setTriggerableLines(shadersCollectionController: JsLinesCollectionController): void;
}
declare class SetObjectFrustumCulledJsParamsConfig extends NodeParamsConfig {
	/** @param target FrustumCulled state */
	frustumCulled: ParamTemplate<ParamType.BOOLEAN>;
}
declare class SetObjectFrustumCulledJsNode extends TypedJsNode<SetObjectFrustumCulledJsParamsConfig> {
	readonly paramsConfig: SetObjectFrustumCulledJsParamsConfig;
	static type(): string;
	initializeNode(): void;
	setLines(linesController: JsLinesCollectionController): void;
	setTriggerableLines(shadersCollectionController: JsLinesCollectionController): void;
}
declare class SetObjectLookAtJsParamsConfig extends NodeParamsConfig {
	/** @param targetPosition */
	targetPosition: ParamTemplate<ParamType.VECTOR3>;
	/** @param up */
	up: ParamTemplate<ParamType.VECTOR3>;
	/** @param lerp factor */
	lerp: ParamTemplate<ParamType.FLOAT>;
	/** @param invertDirection */
	invertDirection: ParamTemplate<ParamType.BOOLEAN>;
	/** @param sets if the matrix should be updated as the animation progresses */
	updateMatrix: ParamTemplate<ParamType.BOOLEAN>;
}
declare class SetObjectLookAtJsNode extends TypedJsNode<SetObjectLookAtJsParamsConfig> {
	readonly paramsConfig: SetObjectLookAtJsParamsConfig;
	static type(): JsType;
	initializeNode(): void;
	setLines(linesController: JsLinesCollectionController): void;
	setTriggerableLines(linesController: JsLinesCollectionController): void;
}
declare class SetObjectMaterialJsNode extends ParamlessTypedJsNode {
	static type(): string;
	initializeNode(): void;
	setLines(linesController: JsLinesCollectionController): void;
	setTriggerableLines(shadersCollectionController: JsLinesCollectionController): void;
}
declare class SetObjectMaterialColorJsParamsConfig extends NodeParamsConfig {
	/** @param color */
	color: ParamTemplate<ParamType.COLOR>;
	/** @param lerp factor */
	lerp: ParamTemplate<ParamType.FLOAT>;
}
declare class SetObjectMaterialColorJsNode extends TypedJsNode<SetObjectMaterialColorJsParamsConfig> {
	readonly paramsConfig: SetObjectMaterialColorJsParamsConfig;
	static type(): string;
	initializeNode(): void;
	setLines(linesController: JsLinesCollectionController): void;
	setTriggerableLines(shadersCollectionController: JsLinesCollectionController): void;
}
declare class SetObjectMatrixJsParamsConfig extends NodeParamsConfig {
}
declare class SetObjectMatrixJsNode extends TypedJsNode<SetObjectMatrixJsParamsConfig> {
	readonly paramsConfig: SetObjectMatrixJsParamsConfig;
	static type(): string;
	initializeNode(): void;
	setLines(linesController: JsLinesCollectionController): void;
	setTriggerableLines(shadersCollectionController: JsLinesCollectionController): void;
}
declare class SetObjectMatrixAutoUpdateJsParamsConfig extends NodeParamsConfig {
	/** @param target MatrixAutoUpdate state */
	matrixAutoUpdate: ParamTemplate<ParamType.BOOLEAN>;
}
declare class SetObjectMatrixAutoUpdateJsNode extends TypedJsNode<SetObjectMatrixAutoUpdateJsParamsConfig> {
	readonly paramsConfig: SetObjectMatrixAutoUpdateJsParamsConfig;
	static type(): string;
	initializeNode(): void;
	setLines(linesController: JsLinesCollectionController): void;
	setTriggerableLines(shadersCollectionController: JsLinesCollectionController): void;
}
declare class SetObjectPositionJsParamsConfig extends NodeParamsConfig {
	/** @param target position */
	position: ParamTemplate<ParamType.VECTOR3>;
	/** @param lerp factor */
	lerp: ParamTemplate<ParamType.FLOAT>;
	/** @param sets if the matrix should be updated as the animation progresses */
	updateMatrix: ParamTemplate<ParamType.BOOLEAN>;
}
declare class SetObjectPositionJsNode extends BaseTriggerAndObjectJsNode<SetObjectPositionJsParamsConfig> {
	readonly paramsConfig: SetObjectPositionJsParamsConfig;
	static type(): JsType;
	protected _additionalOutputs(): JsConnectionPoint<JsConnectionPointType>[];
	setLines(linesController: JsLinesCollectionController): void;
	setTriggerableLines(shadersCollectionController: JsLinesCollectionController): void;
}
declare class SetObjectReceiveShadowJsParamsConfig extends NodeParamsConfig {
	/** @param target ReceiveShadow state */
	receiveShadow: ParamTemplate<ParamType.BOOLEAN>;
}
declare class SetObjectReceiveShadowJsNode extends TypedJsNode<SetObjectReceiveShadowJsParamsConfig> {
	readonly paramsConfig: SetObjectReceiveShadowJsParamsConfig;
	static type(): string;
	initializeNode(): void;
	setLines(linesController: JsLinesCollectionController): void;
	setTriggerableLines(shadersCollectionController: JsLinesCollectionController): void;
}
declare class SetObjectRotationJsParamsConfig extends NodeParamsConfig {
	/** @param lerp factor */
	lerp: ParamTemplate<ParamType.FLOAT>;
	/** @param sets if the matrix should be updated as the animation progresses */
	updateMatrix: ParamTemplate<ParamType.BOOLEAN>;
}
declare class SetObjectRotationJsNode extends TypedJsNode<SetObjectRotationJsParamsConfig> {
	readonly paramsConfig: SetObjectRotationJsParamsConfig;
	static type(): string;
	initializeNode(): void;
	setLines(linesController: JsLinesCollectionController): void;
	setTriggerableLines(shadersCollectionController: JsLinesCollectionController): void;
}
declare class SetObjectQuaternionJsParamsConfig extends NodeParamsConfig {
	/** @param lerp factor */
	lerp: ParamTemplate<ParamType.FLOAT>;
	/** @param sets if the matrix should be updated as the animation progresses */
	updateMatrix: ParamTemplate<ParamType.BOOLEAN>;
}
declare class SetObjectQuaternionJsNode extends TypedJsNode<SetObjectQuaternionJsParamsConfig> {
	readonly paramsConfig: SetObjectQuaternionJsParamsConfig;
	static type(): JsType;
	initializeNode(): void;
	setLines(linesController: JsLinesCollectionController): void;
	setTriggerableLines(shadersCollectionController: JsLinesCollectionController): void;
}
declare class SetObjectPolarTransformJsParamsConfig extends NodeParamsConfig {
	/** @param center of the transform */
	center: ParamTemplate<ParamType.VECTOR3>;
	/** @param moves the objects along the longitude, which is equivalent to a rotation on the y axis */
	longitude: ParamTemplate<ParamType.FLOAT>;
	/** @param moves the objects along the latitude, which is equivalent to a rotation on the z or x axis */
	latitude: ParamTemplate<ParamType.FLOAT>;
	/** @param moves the point aways from the center */
	depth: ParamTemplate<ParamType.FLOAT>;
}
declare class SetObjectPolarTransformJsNode extends TypedJsNode<SetObjectPolarTransformJsParamsConfig> {
	readonly paramsConfig: SetObjectPolarTransformJsParamsConfig;
	static type(): string;
	initializeNode(): void;
	setLines(linesController: JsLinesCollectionController): void;
	setTriggerableLines(linesController: JsLinesCollectionController): void;
}
declare class SetObjectScaleJsParamsConfig extends NodeParamsConfig {
	/** @param target scale */
	scale: ParamTemplate<ParamType.VECTOR3>;
	/** @param target scale */
	mult: ParamTemplate<ParamType.FLOAT>;
	/** @param lerp factor */
	lerp: ParamTemplate<ParamType.FLOAT>;
	/** @param sets if the matrix should be updated as the animation progresses */
	updateMatrix: ParamTemplate<ParamType.BOOLEAN>;
}
declare class SetObjectScaleJsNode extends BaseTriggerAndObjectJsNode<SetObjectScaleJsParamsConfig> {
	readonly paramsConfig: SetObjectScaleJsParamsConfig;
	static type(): JsType;
	protected _additionalOutputs(): JsConnectionPoint<JsConnectionPointType>[];
	setLines(linesController: JsLinesCollectionController): void;
	setTriggerableLines(linesController: JsLinesCollectionController): void;
}
declare class SetObjectVisibleJsParamsConfig extends NodeParamsConfig {
	/** @param target visible state */
	visible: ParamTemplate<ParamType.BOOLEAN>;
}
declare class SetObjectVisibleJsNode extends TypedJsNode<SetObjectVisibleJsParamsConfig> {
	readonly paramsConfig: SetObjectVisibleJsParamsConfig;
	static type(): string;
	initializeNode(): void;
	setLines(linesController: JsLinesCollectionController): void;
	setTriggerableLines(shadersCollectionController: JsLinesCollectionController): void;
}
declare class SetParamJsParamsConfig extends NodeParamsConfig {
	/** @param type of the parameter to update */
	type: ParamTemplate<ParamType.INTEGER>;
}
declare class SetParamJsNode extends TypedJsNode<SetParamJsParamsConfig> {
	readonly paramsConfig: SetParamJsParamsConfig;
	static type(): JsType;
	initializeNode(): void;
	private _currentConnectionType;
	setParamType(paramType: ParamConvertibleJsType): void;
	setParamPath(paramPath: string): void;
	setParamParam(param: BaseParamType): void;
	setTriggerableLines(controller: JsLinesCollectionController): void;
	private _bodyLine;
	private _setBoolean;
	private _setColor;
	private _setFloat;
	private _setInt;
	private _setString;
	private _setVector2;
	private _setVector3;
	private _setVector4;
}
declare class SetPerspectiveCameraFovJsParamsConfig extends NodeParamsConfig {
	/** @param focal length */
	fov: ParamTemplate<ParamType.FLOAT>;
	/** @param lerp factor */
	lerp: ParamTemplate<ParamType.FLOAT>;
	/** @param sets if the projection matrix should be updated as the animation progresses */
	updateProjectionMatrix: ParamTemplate<ParamType.BOOLEAN>;
}
declare class SetPerspectiveCameraFovJsNode extends TypedJsNode<SetPerspectiveCameraFovJsParamsConfig> {
	readonly paramsConfig: SetPerspectiveCameraFovJsParamsConfig;
	static type(): string;
	initializeNode(): void;
	setLines(linesController: JsLinesCollectionController): void;
	setTriggerableLines(shadersCollectionController: JsLinesCollectionController): void;
}
declare class SetPerspectiveCameraNearFarJsParamsConfig extends NodeParamsConfig {
	/** @param near */
	near: ParamTemplate<ParamType.FLOAT>;
	/** @param far */
	far: ParamTemplate<ParamType.FLOAT>;
	/** @param lerp factor */
	lerp: ParamTemplate<ParamType.FLOAT>;
	/** @param sets if the projection matrix should be updated as the animation progresses */
	updateProjectionMatrix: ParamTemplate<ParamType.BOOLEAN>;
}
declare class SetPerspectiveCameraNearFarJsNode extends TypedJsNode<SetPerspectiveCameraNearFarJsParamsConfig> {
	readonly paramsConfig: SetPerspectiveCameraNearFarJsParamsConfig;
	static type(): string;
	initializeNode(): void;
	setLines(linesController: JsLinesCollectionController): void;
	setTriggerableLines(shadersCollectionController: JsLinesCollectionController): void;
}
declare class SetPhysicsRBDAngularVelocityJsParamsConfig extends NodeParamsConfig {
	/** @param target velocity */
	velocity: ParamTemplate<ParamType.VECTOR3>;
	/** @param lerp factor */
	lerp: ParamTemplate<ParamType.FLOAT>;
}
declare class SetPhysicsRBDAngularVelocityJsNode extends TypedJsNode<SetPhysicsRBDAngularVelocityJsParamsConfig> {
	readonly paramsConfig: SetPhysicsRBDAngularVelocityJsParamsConfig;
	static type(): string;
	initializeNode(): void;
	setLines(linesController: JsLinesCollectionController): void;
	setTriggerableLines(shadersCollectionController: JsLinesCollectionController): void;
}
declare class SetPhysicsRBDLinearVelocityJsParamsConfig extends NodeParamsConfig {
	/** @param target position */
	velocity: ParamTemplate<ParamType.VECTOR3>;
	/** @param lerp factor */
	lerp: ParamTemplate<ParamType.FLOAT>;
}
declare class SetPhysicsRBDLinearVelocityJsNode extends TypedJsNode<SetPhysicsRBDLinearVelocityJsParamsConfig> {
	readonly paramsConfig: SetPhysicsRBDLinearVelocityJsParamsConfig;
	static type(): string;
	initializeNode(): void;
	setLines(linesController: JsLinesCollectionController): void;
	setTriggerableLines(shadersCollectionController: JsLinesCollectionController): void;
}
declare class SetPhysicsRBDPositionJsParamsConfig extends NodeParamsConfig {
	/** @param target position */
	position: ParamTemplate<ParamType.VECTOR3>;
	/** @param lerp factor */
	lerp: ParamTemplate<ParamType.FLOAT>;
}
declare class SetPhysicsRBDPositionJsNode extends TypedJsNode<SetPhysicsRBDPositionJsParamsConfig> {
	readonly paramsConfig: SetPhysicsRBDPositionJsParamsConfig;
	static type(): JsType;
	initializeNode(): void;
	setLines(linesController: JsLinesCollectionController): void;
	setTriggerableLines(shadersCollectionController: JsLinesCollectionController): void;
}
declare class SetPhysicsRBDRotationJsParamsConfig extends NodeParamsConfig {
	/** @param target rotation */
	quaternion: ParamTemplate<ParamType.VECTOR4>;
	/** @param lerp factor */
	lerp: ParamTemplate<ParamType.FLOAT>;
}
declare class SetPhysicsRBDRotationJsNode extends TypedJsNode<SetPhysicsRBDRotationJsParamsConfig> {
	readonly paramsConfig: SetPhysicsRBDRotationJsParamsConfig;
	static type(): string;
	initializeNode(): void;
	setLines(linesController: JsLinesCollectionController): void;
	setTriggerableLines(shadersCollectionController: JsLinesCollectionController): void;
}
declare class SetPhysicsRBDCapsulePropertyJsParamsConfig extends NodeParamsConfig {
	/** @param target scale */
	scale: ParamTemplate<ParamType.FLOAT>;
	/** @param lerp factor */
	lerp: ParamTemplate<ParamType.FLOAT>;
	/** @param sets if the matrix should be updated as the animation progresses */
	updateMatrix: ParamTemplate<ParamType.BOOLEAN>;
}
declare class SetPhysicsRBDCapsulePropertyJsNode extends TypedJsNode<SetPhysicsRBDCapsulePropertyJsParamsConfig> {
	readonly paramsConfig: SetPhysicsRBDCapsulePropertyJsParamsConfig;
	static type(): string;
	initializeNode(): void;
	setLines(linesController: JsLinesCollectionController): void;
	setTriggerableLines(shadersCollectionController: JsLinesCollectionController): void;
}
declare class SetPhysicsRBDConePropertyJsParamsConfig extends NodeParamsConfig {
	/** @param target radius */
	radius: ParamTemplate<ParamType.FLOAT>;
	/** @param target height */
	height: ParamTemplate<ParamType.FLOAT>;
	/** @param lerp factor */
	lerp: ParamTemplate<ParamType.FLOAT>;
	/** @param sets if the matrix should be updated as the animation progresses */
	updateMatrix: ParamTemplate<ParamType.BOOLEAN>;
}
declare class SetPhysicsRBDConePropertyJsNode extends TypedJsNode<SetPhysicsRBDConePropertyJsParamsConfig> {
	readonly paramsConfig: SetPhysicsRBDConePropertyJsParamsConfig;
	static type(): string;
	initializeNode(): void;
	setLines(linesController: JsLinesCollectionController): void;
	setTriggerableLines(shadersCollectionController: JsLinesCollectionController): void;
}
declare class SetPhysicsRBDCylinderPropertyJsParamsConfig extends NodeParamsConfig {
	/** @param target radius */
	radius: ParamTemplate<ParamType.FLOAT>;
	/** @param target height */
	height: ParamTemplate<ParamType.FLOAT>;
	/** @param lerp factor */
	lerp: ParamTemplate<ParamType.FLOAT>;
	/** @param sets if the matrix should be updated as the animation progresses */
	updateMatrix: ParamTemplate<ParamType.BOOLEAN>;
}
declare class SetPhysicsRBDCylinderPropertyJsNode extends TypedJsNode<SetPhysicsRBDCylinderPropertyJsParamsConfig> {
	readonly paramsConfig: SetPhysicsRBDCylinderPropertyJsParamsConfig;
	static type(): string;
	initializeNode(): void;
	setLines(linesController: JsLinesCollectionController): void;
	setTriggerableLines(shadersCollectionController: JsLinesCollectionController): void;
}
declare class SetPhysicsRBDCuboidPropertyJsParamsConfig extends NodeParamsConfig {
	/** @param target sizes */
	sizes: ParamTemplate<ParamType.VECTOR3>;
	/** @param target size */
	size: ParamTemplate<ParamType.FLOAT>;
	/** @param lerp factor */
	lerp: ParamTemplate<ParamType.FLOAT>;
	/** @param sets if the matrix should be updated as the animation progresses */
	updateMatrix: ParamTemplate<ParamType.BOOLEAN>;
}
declare class SetPhysicsRBDCuboidPropertyJsNode extends TypedJsNode<SetPhysicsRBDCuboidPropertyJsParamsConfig> {
	readonly paramsConfig: SetPhysicsRBDCuboidPropertyJsParamsConfig;
	static type(): string;
	initializeNode(): void;
	setLines(linesController: JsLinesCollectionController): void;
	setTriggerableLines(shadersCollectionController: JsLinesCollectionController): void;
}
declare class SetPhysicsRBDSpherePropertyJsParamsConfig extends NodeParamsConfig {
	/** @param target radois */
	radius: ParamTemplate<ParamType.FLOAT>;
	/** @param lerp factor */
	lerp: ParamTemplate<ParamType.FLOAT>;
	/** @param sets if the matrix should be updated as the animation progresses */
	updateMatrix: ParamTemplate<ParamType.BOOLEAN>;
}
declare class SetPhysicsRBDSpherePropertyJsNode extends TypedJsNode<SetPhysicsRBDSpherePropertyJsParamsConfig> {
	readonly paramsConfig: SetPhysicsRBDSpherePropertyJsParamsConfig;
	static type(): string;
	initializeNode(): void;
	setLines(linesController: JsLinesCollectionController): void;
	setTriggerableLines(shadersCollectionController: JsLinesCollectionController): void;
}
declare class SetPhysicsWorldGravityJsParamsConfig extends NodeParamsConfig {
	gravity: ParamTemplate<ParamType.VECTOR3>;
	lerp: ParamTemplate<ParamType.FLOAT>;
}
declare class SetPhysicsWorldGravityJsNode extends TypedJsNode<SetPhysicsWorldGravityJsParamsConfig> {
	readonly paramsConfig: SetPhysicsWorldGravityJsParamsConfig;
	static type(): string;
	initializeNode(): void;
	setLines(linesController: JsLinesCollectionController): void;
	setTriggerableLines(shadersCollectionController: JsLinesCollectionController): void;
}
declare class SetPlayerInputParamsConfig extends NodeParamsConfig {
	/** @param stopEventsPropagation: even though this node can intercept keydown and keyup events, you may encounter situations where pressing spare or arrow keys would trigger a page scroll. This node currently does not handle those situation, and it is recommended to manually intercept those and call event.stopImmediatePropagation() and event.stopPropagation() on keypress events */
	stopEventsPropagation: ParamTemplate<ParamType.BOOLEAN>;
}
declare class SetPlayerInputJsNode extends TypedJsNode<SetPlayerInputParamsConfig> {
	paramsConfig: SetPlayerInputParamsConfig;
	static type(): JsType;
	initializeNode(): void;
	setTriggerableLines(shadersCollectionController: JsLinesCollectionController): void;
	setLines(shadersCollectionController: JsLinesCollectionController): void;
}
declare class SetPointPositionJsParamsConfig extends NodeParamsConfig {
	/** @param point index */
	ptnum: ParamTemplate<ParamType.INTEGER>;
	/** @param target position */
	position: ParamTemplate<ParamType.VECTOR3>;
	/** @param lerp factor */
	lerp: ParamTemplate<ParamType.FLOAT>;
}
declare class SetPointPositionJsNode extends BaseTriggerAndObjectJsNode<SetPointPositionJsParamsConfig> {
	readonly paramsConfig: SetPointPositionJsParamsConfig;
	static type(): JsType;
	protected _additionalOutputs(): JsConnectionPoint<JsConnectionPointType>[];
	setLines(linesController: JsLinesCollectionController): void;
	setTriggerableLines(linesController: JsLinesCollectionController): void;
}
declare class SetSoftBodyPositionJsParamsConfig extends NodeParamsConfig {
	/** @param target position */
	position: ParamTemplate<ParamType.VECTOR3>;
	/** @param lerp factor */
	lerp: ParamTemplate<ParamType.FLOAT>;
}
declare class SetSoftBodyPositionJsNode extends BaseTriggerAndObjectJsNode<SetSoftBodyPositionJsParamsConfig> {
	readonly paramsConfig: SetSoftBodyPositionJsParamsConfig;
	static type(): JsType;
	protected _additionalOutputs(): JsConnectionPoint<JsConnectionPointType>[];
	setLines(linesController: JsLinesCollectionController): void;
	setTriggerableLines(shadersCollectionController: JsLinesCollectionController): void;
}
declare class SetSoftBodyVelocityJsParamsConfig extends NodeParamsConfig {
	/** @param multiplier */
	mult: ParamTemplate<ParamType.FLOAT>;
}
declare class SetSoftBodyVelocityJsNode extends BaseTriggerAndObjectJsNode<SetSoftBodyVelocityJsParamsConfig> {
	readonly paramsConfig: SetSoftBodyVelocityJsParamsConfig;
	static type(): JsType;
	protected _additionalOutputs(): JsConnectionPoint<JsConnectionPointType>[];
	setLines(linesController: JsLinesCollectionController): void;
	setTriggerableLines(shadersCollectionController: JsLinesCollectionController): void;
}
declare class SetSoftBodyConstraintPositionJsParamsConfig extends NodeParamsConfig {
	id: ParamTemplate<ParamType.INTEGER>;
	position: ParamTemplate<ParamType.VECTOR3>;
	lerp: ParamTemplate<ParamType.FLOAT>;
}
declare class SetSoftBodyConstraintPositionJsNode extends BaseTriggerAndObjectJsNode<SetSoftBodyConstraintPositionJsParamsConfig> {
	readonly paramsConfig: SetSoftBodyConstraintPositionJsParamsConfig;
	static type(): JsType;
	setTriggerableLines(shadersCollectionController: JsLinesCollectionController): void;
}
declare class SetSpotLightIntensityJsParamsConfig extends NodeParamsConfig {
	/** @param intensity */
	intensity: ParamTemplate<ParamType.FLOAT>;
	/** @param lerp factor */
	lerp: ParamTemplate<ParamType.FLOAT>;
}
declare class SetSpotLightIntensityJsNode extends TypedJsNode<SetSpotLightIntensityJsParamsConfig> {
	readonly paramsConfig: SetSpotLightIntensityJsParamsConfig;
	static type(): string;
	initializeNode(): void;
	setLines(linesController: JsLinesCollectionController): void;
	setTriggerableLines(shadersCollectionController: JsLinesCollectionController): void;
}
declare class SetViewerJsParamsConfig extends NodeParamsConfig {
	/** @param sets the class of the viewer */
	className: ParamTemplate<ParamType.STRING>;
	/** @param set or unset */
	set: ParamTemplate<ParamType.BOOLEAN>;
}
declare class SetViewerJsNode extends TypedJsNode<SetViewerJsParamsConfig> {
	readonly paramsConfig: SetViewerJsParamsConfig;
	static type(): string;
	initializeNode(): void;
	setTriggerableLines(shadersCollectionController: JsLinesCollectionController): void;
}
declare class SetViewerControlsJsParamsConfig extends NodeParamsConfig {
	/** @param set or unset */
	active: ParamTemplate<ParamType.BOOLEAN>;
}
declare class SetViewerControlsJsNode extends TypedJsNode<SetViewerControlsJsParamsConfig> {
	readonly paramsConfig: SetViewerControlsJsParamsConfig;
	static type(): string;
	initializeNode(): void;
	setTriggerableLines(shadersCollectionController: JsLinesCollectionController): void;
}
declare const SignJsNode_base: typeof BaseMathFunctionJsNode;
declare class SignJsNode extends SignJsNode_base {
}
declare const SinJsNode_base: typeof BaseMathFunctionJsNode;
declare class SinJsNode extends SinJsNode_base {
}
declare const SmoothstepJsNode_base: typeof BaseMathFunctionJsNode;
declare class SmoothstepJsNode extends SmoothstepJsNode_base {
	protected _coreFunction(shadersCollectionController: JsLinesCollectionController): string;
	paramDefaultValue(name: string): number;
	protected _expectedInputName(index: number): string;
	protected _expectedInputTypes(): JsConnectionPointType[];
}
declare const SmootherstepJsNode_base: typeof BaseMathFunctionJsNode;
declare class SmootherstepJsNode extends SmootherstepJsNode_base {
	protected _coreFunction(shadersCollectionController: JsLinesCollectionController): string;
	paramDefaultValue(name: string): number;
	protected _expectedInputName(index: number): string;
	protected _expectedInputTypes(): JsConnectionPointType[];
}
declare class SoftBodySolverStepSimulationJsParamsConfig extends NodeParamsConfig {
	stepsCount: ParamTemplate<ParamType.INTEGER>;
	/** @param edgeCompliance */
	edgeCompliance: ParamTemplate<ParamType.FLOAT>;
	/** @param volumeCompliance */
	volumeCompliance: ParamTemplate<ParamType.FLOAT>;
	/** @param preciseCollisions */
	preciseCollisions: ParamTemplate<ParamType.BOOLEAN>;
}
declare class SoftBodySolverStepSimulationJsNode extends TypedJsNode<SoftBodySolverStepSimulationJsParamsConfig> {
	readonly paramsConfig: SoftBodySolverStepSimulationJsParamsConfig;
	static type(): string;
	initializeNode(): void;
	setLines(linesController: JsLinesCollectionController): void;
	setTriggerableLines(linesController: JsLinesCollectionController): void;
}
declare class SphereJsParamsConfig extends NodeParamsConfig {
	/** @param sphere center */
	center: ParamTemplate<ParamType.VECTOR3>;
	/** @param sphere radius */
	radius: ParamTemplate<ParamType.FLOAT>;
}
declare class SphereJsNode extends TypedJsNode<SphereJsParamsConfig> {
	paramsConfig: SphereJsParamsConfig;
	static type(): string;
	initializeNode(): void;
	setLines(shadersCollectionController: JsLinesCollectionController): void;
}
declare const SqrtJsNode_base: typeof BaseMathFunctionJsNode;
declare class SqrtJsNode extends SqrtJsNode_base {
}
declare class CoreNodeSelection {
	private _node;
	private _nodeIds;
	constructor(_node: BaseNodeType);
	node(): BaseNodeType;
	nodeIds(): number[];
	nodeFromIndex(index: number): BaseNodeType | undefined;
	nodes(target: BaseNodeType[]): BaseNodeType[];
	contains(node: BaseNodeType): boolean;
	equals(nodes: BaseNodeType[]): boolean;
	clear(): void;
	set(nodes: Readonly<BaseNodeType[]>): void;
	add(nodesToAdd: Readonly<BaseNodeType[]>): void;
	remove(nodesToRemove: Readonly<BaseNodeType[]>): void;
	private _checkValidity;
	private _sendUpdateEvent;
	toJSON(target: CoreGraphNodeId[]): void;
}
declare class OperationInputsController<NC extends NodeContext> {
	private operationContainer;
	constructor(operationContainer: BaseOperationContainer<NC>);
	inputsCount(): number;
	private _clonedStatesController;
	initInputsClonedState(states: InputCloneMode | InputCloneMode[]): void;
	cloneRequired(index: number): boolean;
	override_cloned_state(state: boolean): void;
}
declare class BaseOperationContainer<NC extends NodeContext> {
	protected operation: BaseOperation<NC>;
	protected name: string;
	protected params: DefaultOperationParams;
	private _path_params;
	constructor(operation: BaseOperation<NC>, name: string, init_params: ParamsInitData);
	pathParamResolveRequired(): boolean;
	resolvePathParams(node_start: BaseNodeType): void;
	private _applyDefaultParams;
	private _applyInitParams;
	private _convertParamData;
	protected _inputs: BaseOperationContainer<NC>[] | undefined;
	setInput(index: number, input: BaseOperationContainer<NC>): void;
	inputsCount(): number;
	private _inputsController;
	protected inputsController(): OperationInputsController<NC>;
	private _initClonedStates;
	inputCloneRequired(index: number): boolean;
	overrideInputCloneState(state: boolean): void;
	cook(input_contents: any[]): any;
}
interface NodeSerializerData {
	name: string;
	type: string;
	graph_node_id: CoreGraphNodeId;
	is_dirty: boolean;
	ui_data_json: NodeUIDataJson;
	error_message: string | undefined;
	children: CoreGraphNodeId[];
	maxInputsCount: number;
	inputs: Readonly<Array<CoreGraphNodeId | undefined>>;
	input_connection_output_indices: Readonly<Array<number | undefined>> | undefined;
	named_input_connection_points: Readonly<BaseConnectionPointData[]>;
	named_output_connection_points: Readonly<BaseConnectionPointData[]>;
	param_ids: CoreGraphNodeId[];
	override_cloned_state_allowed: boolean;
	inputs_clone_required_states: boolean | boolean[];
	flags?: {
		display?: boolean;
		bypass?: boolean;
		optimize?: boolean;
	};
	selection?: CoreGraphNodeId[];
	polyNode?: {
		locked: boolean;
	};
}
declare class CoreNodeSerializer {
	protected node: BaseNodeType;
	constructor(node: BaseNodeType);
	dispose(): void;
	toJSON(includeParamComponents?: boolean): NodeSerializerData;
	childrenIds(): number[];
	maxInputsCount(): number;
	inputIds(): Readonly<(CoreGraphNodeId | undefined)[]>;
	inputConnectionOutputIndices(): Readonly<(number | undefined)[]> | undefined;
	namedInputConnectionPoints(): Readonly<BaseConnectionPointData[]>;
	namedOutputConnectionPoints(): Readonly<BaseConnectionPointData[]>;
	to_json_params_from_names(param_names: string[], include_components?: boolean): number[];
	to_json_params(include_components?: boolean): number[];
}
type OutputNodeFindMethod = (() => BaseNodeType) | undefined;
type TraverseNodeCallback = (node: BaseNodeType) => void;
type TraverseNodeConditionCallback = (node: BaseNodeType) => boolean;
interface NodeCreateOptions {
	paramsInitValueOverrides?: ParamsInitData;
	nodeName?: string;
	serializerClass?: typeof CoreNodeSerializer;
}
declare class HierarchyChildrenController {
	protected node: BaseNodeType;
	private _context;
	private _childrenByName;
	private _childrenIdByType;
	private _childrenByType;
	private _childrenAndGrandchildrenByContext;
	private _selection;
	get selection(): CoreNodeSelection;
	constructor(node: BaseNodeType, _context: NodeContext);
	dispose(): void;
	get context(): NodeContext;
	private _outputNodeFindMethod;
	setOutputNodeFindMethod(method: OutputNodeFindMethod): void;
	outputNode(): BaseNodeType | undefined;
	setChildName(node: BaseNodeType, newName: string): void;
	private _nextAvailableChildName;
	nodeContextSignature(): string;
	availableChildrenClasses(): PolyDictionary<typeof BaseNodeClass>;
	isValidChildType(node_type: string): boolean;
	createNode<K extends BaseNodeType>(nodeClassOrString: string | Constructor<K>, options?: NodeCreateOptions): K;
	private _createAndInitNode;
	private _findNodeClass;
	createOperationContainer(operationType: string, operationContainerName: string, options?: NodeCreateOptions): BaseOperationContainer<any>;
	private _addNode;
	removeNode(childNode: BaseNodeType): void;
	private _addToNodesByType;
	private _removeFromNodesByType;
	private _addToChildrenAndGrandchildrenByContext;
	private _removeFromChildrenAndGrandchildrenByContext;
	nodesByType(type: string, target?: BaseNodeType[]): BaseNodeType[];
	childByName(name: string): BaseNodeType | null;
	hasChildrenAndGrandchildrenWithContext(context: NodeContext): boolean;
	private _children;
	private _childrenNames;
	private _updateCache;
	children(): Readonly<BaseNodeType[]>;
	childrenNames(): Readonly<string[]>;
	traverseChildren(callback: TraverseNodeCallback, conditionCallback?: TraverseNodeConditionCallback): void;
}
declare const TypedSubnetJsParamsConfig_base: {
	new (...args: any[]): {
		main: ParamTemplate<ParamType.FOLDER>;
		time: ParamTemplate<ParamType.FLOAT>;
		inputs: ParamTemplate<ParamType.FOLDER>;
		inputsCount: ParamTemplate<ParamType.INTEGER>;
		inputType0: ParamTemplate<ParamType.INTEGER>;
		inputName0: ParamTemplate<ParamType.STRING>;
		inputType1: ParamTemplate<ParamType.INTEGER>;
		inputName1: ParamTemplate<ParamType.STRING>;
		inputType2: ParamTemplate<ParamType.INTEGER>;
		inputName2: ParamTemplate<ParamType.STRING>;
		inputType3: ParamTemplate<ParamType.INTEGER>;
		inputName3: ParamTemplate<ParamType.STRING>;
		inputType4: ParamTemplate<ParamType.INTEGER>;
		inputName4: ParamTemplate<ParamType.STRING>;
		inputType5: ParamTemplate<ParamType.INTEGER>;
		inputName5: ParamTemplate<ParamType.STRING>;
		inputType6: ParamTemplate<ParamType.INTEGER>;
		inputName6: ParamTemplate<ParamType.STRING>;
		inputType7: ParamTemplate<ParamType.INTEGER>;
		inputName7: ParamTemplate<ParamType.STRING>;
		inputType8: ParamTemplate<ParamType.INTEGER>;
		inputName8: ParamTemplate<ParamType.STRING>;
		inputType9: ParamTemplate<ParamType.INTEGER>;
		inputName9: ParamTemplate<ParamType.STRING>;
		spare: ParamTemplate<ParamType.FOLDER>;
	};
} & typeof NodeParamsConfig;
declare class TypedSubnetJsParamsConfig extends TypedSubnetJsParamsConfig_base {
}
declare class AbstractTypedSubnetJsNode<K extends NodeParamsConfig> extends TypedJsNode<K> {
	protected _childrenControllerContext: NodeContext;
	initializeNode(): void;
	protected _expectedInputTypes(): JsConnectionPointType[];
	protected _expectedInputName(index: number): string;
	protected _expectedOutputTypes(): JsConnectionPointType[];
	protected _expectedOutputName(index: number): string;
	childExpectedInputConnectionPointTypes(): JsConnectionPointType[];
	childExpectedOutputConnectionPointTypes(): JsConnectionPointType[];
	childExpectedInputConnectionPointName(index: number): string;
	childExpectedOutputConnectionPointName(index: number): string;
	createNode<S extends keyof JsNodeChildrenMap>(node_class: S, options?: NodeCreateOptions): JsNodeChildrenMap[S];
	createNode<K extends valueof<JsNodeChildrenMap>>(node_class: Constructor<K>, options?: NodeCreateOptions): K;
	children(): BaseJsNodeType[];
	nodesByType<K extends keyof JsNodeChildrenMap>(type: K): JsNodeChildrenMap[K][];
}
declare class TypedSubnetJsNode<K extends TypedSubnetJsParamsConfig> extends AbstractTypedSubnetJsNode<K> {
	initializeNode(): void;
	protected _inputTypeParams(): IntegerParam[];
	protected _inputNameParams(): StringParam[];
	setInputType(index: number, type: JsConnectionPointType): void;
	setInputName(index: number, inputName: string): void;
	protected _expectedInputsCount(): number;
	protected _expectedInputTypes(): JsConnectionPointType[];
	protected _expectedInputName(index: number): string;
	protected _expectedOutputTypes(): JsConnectionPointType[];
	protected _expectedOutputName(index: number): string;
}
declare const SubnetJsParamsConfig_base: {
	new (...args: any[]): {
		main: ParamTemplate<ParamType.FOLDER>;
		time: ParamTemplate<ParamType.FLOAT>;
		inputs: ParamTemplate<ParamType.FOLDER>;
		inputsCount: ParamTemplate<ParamType.INTEGER>;
		inputType0: ParamTemplate<ParamType.INTEGER>;
		inputName0: ParamTemplate<ParamType.STRING>;
		inputType1: ParamTemplate<ParamType.INTEGER>;
		inputName1: ParamTemplate<ParamType.STRING>;
		inputType2: ParamTemplate<ParamType.INTEGER>;
		inputName2: ParamTemplate<ParamType.STRING>;
		inputType3: ParamTemplate<ParamType.INTEGER>;
		inputName3: ParamTemplate<ParamType.STRING>;
		inputType4: ParamTemplate<ParamType.INTEGER>;
		inputName4: ParamTemplate<ParamType.STRING>;
		inputType5: ParamTemplate<ParamType.INTEGER>;
		inputName5: ParamTemplate<ParamType.STRING>;
		inputType6: ParamTemplate<ParamType.INTEGER>;
		inputName6: ParamTemplate<ParamType.STRING>;
		inputType7: ParamTemplate<ParamType.INTEGER>;
		inputName7: ParamTemplate<ParamType.STRING>;
		inputType8: ParamTemplate<ParamType.INTEGER>;
		inputName8: ParamTemplate<ParamType.STRING>;
		inputType9: ParamTemplate<ParamType.INTEGER>;
		inputName9: ParamTemplate<ParamType.STRING>;
		spare: ParamTemplate<ParamType.FOLDER>;
	};
} & typeof NodeParamsConfig;
declare class SubnetJsParamsConfig extends SubnetJsParamsConfig_base {
}
declare class SubnetJsNode extends TypedSubnetJsNode<SubnetJsParamsConfig> {
	paramsConfig: SubnetJsParamsConfig;
	static type(): NetworkNodeType;
	inputNameForSubnetInput(index: number): string;
	outputNameForSubnetOutput(index: number): string;
}
declare class SubnetInputJsParamsConfig extends NodeParamsConfig {
}
declare class SubnetInputJsNode extends TypedJsNode<SubnetInputJsParamsConfig> {
	paramsConfig: SubnetInputJsParamsConfig;
	static type(): NetworkChildNodeType;
	initializeNode(): void;
	parent(): SubnetJsNode | null;
	private _expectedOutputNames;
	protected _expectedOutputTypes(): JsConnectionPointType[];
	setLines(shadersCollectionController: JsLinesCollectionController): void;
}
declare class SubnetOutputJsParamsConfig extends NodeParamsConfig {
}
declare class SubnetOutputJsNode extends TypedJsNode<SubnetOutputJsParamsConfig> {
	paramsConfig: SubnetOutputJsParamsConfig;
	static type(): Readonly<NetworkChildNodeType.OUTPUT>;
	initializeNode(): void;
	parent(): SubnetJsNode | null;
	protected _expectedInputName(index: number): string;
	protected _expectedInputTypes(): JsConnectionPointType[];
	setLines(shadersCollectionController: JsLinesCollectionController): void;
}
declare const SubtractJsNode_base: typeof BaseMathFunctionJsNode;
declare class SubtractJsNode extends SubtractJsNode_base {
}
declare class SwitchJsNode extends ParamlessTypedJsNode {
	static type(): string;
	static INPUT_INDEX_NAME: string;
	static OUTPUT_NAME: string;
	initializeNode(): void;
	protected _expectedInputName(index: number): string;
	protected _expectedOutputName(): string;
	protected _expectedInputTypes(): JsConnectionPointType[];
	protected _expectedOutputTypes(): JsConnectionPointType[];
	setLines(shadersCollectionController: JsLinesCollectionController): void;
}
declare const TanJsNode_base: typeof BaseMathFunctionJsNode;
declare class TanJsNode extends TanJsNode_base {
}
declare class TrackFaceJsParamsConfig extends NodeParamsConfig {
	faceIndex: ParamTemplate<ParamType.INTEGER>;
}
declare class TrackFaceJsNode extends TypedJsNode<TrackFaceJsParamsConfig> {
	readonly paramsConfig: TrackFaceJsParamsConfig;
	static type(): string;
	initializeNode(): void;
	setTriggerableLines(shadersCollectionController: JsLinesCollectionController): void;
	setLines(shadersCollectionController: JsLinesCollectionController): void;
}
declare class TrackHandJsParamsConfig extends NodeParamsConfig {
	handIndex: ParamTemplate<ParamType.INTEGER>;
}
declare class TrackHandJsNode extends TypedJsNode<TrackHandJsParamsConfig> {
	readonly paramsConfig: TrackHandJsParamsConfig;
	static type(): string;
	initializeNode(): void;
	setTriggerableLines(shadersCollectionController: JsLinesCollectionController): void;
	setLines(shadersCollectionController: JsLinesCollectionController): void;
}
declare class TriggerDelayJsParamsConfig extends NodeParamsConfig {
	/** @param delay (in milliseconds) */
	delay: ParamTemplate<ParamType.FLOAT>;
}
declare class TriggerDelayJsNode extends TypedJsNode<TriggerDelayJsParamsConfig> {
	readonly paramsConfig: TriggerDelayJsParamsConfig;
	static type(): string;
	initializeNode(): void;
	setTriggerableLines(shadersCollectionController: JsLinesCollectionController): void;
}
declare class TriggerFilterJsParamsConfig extends NodeParamsConfig {
	/** @param If true, the trigger will be forwarded. If false, it will not be. */
	condition: ParamTemplate<ParamType.BOOLEAN>;
}
declare class TriggerFilterJsNode extends TypedJsNode<TriggerFilterJsParamsConfig> {
	readonly paramsConfig: TriggerFilterJsParamsConfig;
	static type(): string;
	initializeNode(): void;
	setTriggerableLines(shadersCollectionController: JsLinesCollectionController): void;
}
declare class TriggerSwitchJsParamsConfig extends NodeParamsConfig {
	/** @param triggersCount */
	triggersCount: ParamTemplate<ParamType.INTEGER>;
	/** @param defines which trigger will be dispatched */
	index: ParamTemplate<ParamType.INTEGER>;
}
declare class TriggerSwitchJsNode extends TypedJsNode<TriggerSwitchJsParamsConfig> {
	readonly paramsConfig: TriggerSwitchJsParamsConfig;
	static type(): string;
	initializeNode(): void;
	private _expectedOutputNames;
	private _expectedOutputTypes;
	setTriggerableLines(shadersCollectionController: JsLinesCollectionController): void;
}
declare class TriggerTwoWaySwitchJsParamsConfig extends NodeParamsConfig {
	/** @param if true, trigger will be forward through the 1st output. If false, it will be forwarded through the 2nd output. */
	condition: ParamTemplate<ParamType.BOOLEAN>;
}
declare class TriggerTwoWaySwitchJsNode extends TypedJsNode<TriggerTwoWaySwitchJsParamsConfig> {
	readonly paramsConfig: TriggerTwoWaySwitchJsParamsConfig;
	static type(): string;
	static OUTPUT_NAME_IF_TRUE: string;
	static OUTPUT_NAME_IF_FALSE: string;
	initializeNode(): void;
	setTriggerableLines(shadersCollectionController: JsLinesCollectionController): void;
}
declare enum TwoWaySwitchJsNodeInputName {
	CONDITION = "condition",
	IF_TRUE = "ifTrue",
	IF_FALSE = "ifFalse"
}
declare class TwoWaySwitchJsNode extends ParamlessTypedJsNode {
	static type(): string;
	initializeNode(): void;
	protected _expectedInputName(index: number): TwoWaySwitchJsNodeInputName;
	protected _expectedOutputName(): string;
	protected _expectedInputTypes(): JsConnectionPointType[];
	protected _expectedOutputTypes(): JsConnectionPointType[];
	setLines(shadersCollectionController: JsLinesCollectionController): void;
}
declare class Vector3AngleToJsParamsConfig extends NodeParamsConfig {
	/** @param vector 1 */
	v1: ParamTemplate<ParamType.VECTOR3>;
	/** @param vector 2 */
	v2: ParamTemplate<ParamType.VECTOR3>;
}
declare class Vector3AngleToJsNode extends TypedJsNode<Vector3AngleToJsParamsConfig> {
	paramsConfig: Vector3AngleToJsParamsConfig;
	static type(): string;
	initializeNode(): void;
	setLines(shadersCollectionController: JsLinesCollectionController): void;
}
declare class Vector3ProjectJsParamsConfig extends NodeParamsConfig {
	/** @param vector3 */
	Vector3: ParamTemplate<ParamType.VECTOR3>;
}
declare class Vector3ProjectJsNode extends TypedJsNode<Vector3ProjectJsParamsConfig> {
	paramsConfig: Vector3ProjectJsParamsConfig;
	static type(): string;
	initializeNode(): void;
	setLines(shadersCollectionController: JsLinesCollectionController): void;
}
declare class Vector3ProjectOnPlaneJsParamsConfig extends NodeParamsConfig {
	/** @param vector3 */
	Vector3: ParamTemplate<ParamType.VECTOR3>;
	/** @param planeNormal */
	planeNormal: ParamTemplate<ParamType.VECTOR3>;
}
declare class Vector3ProjectOnPlaneJsNode extends TypedJsNode<Vector3ProjectOnPlaneJsParamsConfig> {
	paramsConfig: Vector3ProjectOnPlaneJsParamsConfig;
	static type(): string;
	initializeNode(): void;
	setLines(shadersCollectionController: JsLinesCollectionController): void;
}
declare class Vector3UnprojectJsParamsConfig extends NodeParamsConfig {
	/** @param vector3 */
	Vector3: ParamTemplate<ParamType.VECTOR3>;
}
declare class Vector3UnprojectJsNode extends TypedJsNode<Vector3UnprojectJsParamsConfig> {
	paramsConfig: Vector3UnprojectJsParamsConfig;
	static type(): string;
	initializeNode(): void;
	setLines(shadersCollectionController: JsLinesCollectionController): void;
}
// @ts-ignore
type AllowedType = JsConnectionPointType.VECTOR4 | JsConnectionPointType.VECTOR4_ARRAY;
declare class Vec4ToVec3ParamsJsConfig extends NodeParamsConfig {
	Vector4: ParamTemplate<ParamType.VECTOR4>;
}
declare class Vec4ToVec3JsNode extends TypedJsNode<Vec4ToVec3ParamsJsConfig> {
	paramsConfig: Vec4ToVec3ParamsJsConfig;
	static type(): string;
	initializeNode(): void;
	_expectedInputName(index: number): string;
	_expectedOutputName(index: number): string;
	protected _expectedInputTypes(): AllowedType[];
	protected _expectedOutputTypes(): JsConnectionPointType[];
	setLines(shadersCollectionController: JsLinesCollectionController): void;
	private _setLinesAsVector4;
	private _setLinesAsVector4Array;
}
declare class Vector2JsParamsConfig extends NodeParamsConfig {
	/** @param vector value */
	Vector2: ParamTemplate<ParamType.VECTOR2>;
}
declare class Vector2JsNode extends TypedJsNode<Vector2JsParamsConfig> {
	paramsConfig: Vector2JsParamsConfig;
	static type(): string;
	initializeNode(): void;
	setLines(shadersCollectionController: JsLinesCollectionController): void;
}
declare class Vector3JsParamsConfig extends NodeParamsConfig {
	/** @param vector value */
	Vector3: ParamTemplate<ParamType.VECTOR3>;
}
declare class Vector3JsNode extends TypedJsNode<Vector3JsParamsConfig> {
	paramsConfig: Vector3JsParamsConfig;
	static type(): string;
	initializeNode(): void;
	setLines(shadersCollectionController: JsLinesCollectionController): void;
}
declare class Vector4JsParamsConfig extends NodeParamsConfig {
	/** @param vector value */
	Vector4: ParamTemplate<ParamType.VECTOR4>;
}
declare class Vector4JsNode extends TypedJsNode<Vector4JsParamsConfig> {
	paramsConfig: Vector4JsParamsConfig;
	static type(): string;
	initializeNode(): void;
	setLines(shadersCollectionController: JsLinesCollectionController): void;
}
interface JsNodeChildrenMap {
	abs: AbsJsNode;
	add: AddJsNode;
	acos: AcosJsNode;
	and: AndJsNode;
	animationAction: AnimationActionJsNode;
	animationActionCrossFade: AnimationActionCrossFadeJsNode;
	animationActionFadeOut: AnimationActionFadeOutJsNode;
	animationActionFadeIn: AnimationActionFadeInJsNode;
	animationActionPlay: AnimationActionPlayJsNode;
	animationActionStop: AnimationActionStopJsNode;
	animationMixer: AnimationMixerJsNode;
	animationMixerUpdate: AnimationMixerUpdateJsNode;
	anyTrigger: AnyTriggerJsNode;
	arrayElement: ArrayElementJsNode;
	arrayLength: ArrayLengthJsNode;
	arrayPop: ArrayPopJsNode;
	arrayShift: ArrayShiftJsNode;
	asin: AsinJsNode;
	atan: AtanJsNode;
	attribute: AttributeJsNode;
	boolToInt: BoolToIntJsNode;
	box3: Box3JsNode;
	box3ContainsPoint: Box3ContainsPointJsNode;
	box3IntersectsBox3: Box3IntersectsBox3JsNode;
	box3SetFromObject: Box3SetFromObjectJsNode;
	catmullRomCurve3GetPoint: CatmullRomCurve3GetPointJsNode;
	ceil: CeilJsNode;
	clamp: ClampJsNode;
	clothSolverReset: ClothSolverResetJsNode;
	clothSolverStepSimulation: ClothSolverStepSimulationJsNode;
	clothSolverUpdateMaterial: ClothSolverUpdateMaterialJsNode;
	code: CodeJsNode;
	compare: CompareJsNode;
	complement: ComplementJsNode;
	computeVelocity: ComputeVelocityJsNode;
	cookNode: CookNodeJsNode;
	colorToVec3: ColorToVec3JsNode;
	constant: ConstantJsNode;
	cos: CosJsNode;
	createClothConstraint: CreateClothConstraintJsNode;
	createObjects: CreateObjectsJsNode;
	createPhysicsRBDKinematicConstraint: CreatePhysicsRBDKinematicConstraintJsNode;
	createPhysicsRBDs: CreatePhysicsRBDsJsNode;
	createSoftBodyConstraint: CreateSoftBodyConstraintJsNode;
	cross: CrossJsNode;
	cursor: CursorJsNode;
	cursorToUv: CursorToUvJsNode;
	debug: DebugJsNode;
	deformGeometryCubeLattice: DeformGeometryCubeLatticeJsNode;
	deleteClothonstraint: DeleteClothConstraintJsNode;
	deleteObject: DeleteObjectJsNode;
	deletePhysicsRBD: DeletePhysicsRBDJsNode;
	deletePhysicsRBDKinematicConstraint: DeletePhysicsRBDKinematicConstraintJsNode;
	deletePhysicsRBDConstraints: DeletePhysicsRBDConstraintsJsNode;
	deleteSoftBodyConstraint: DeleteSoftBodyConstraintJsNode;
	degToRad: DegToRadJsNode;
	deviceOrientation: DeviceOrientationJsNode;
	dot: DotJsNode;
	distance: DistanceJsNode;
	divide: DivideJsNode;
	easing: EasingJsNode;
	elementsToArray: ElementsToArrayJsNode;
	euler: EulerJsNode;
	eulerFromQuaternion: EulerFromQuaternionJsNode;
	fit: FitJsNode;
	floatToColor: FloatToColorJsNode;
	floatToInt: FloatToIntJsNode;
	floatToVec2: FloatToVec2JsNode;
	floatToVec3: FloatToVec3JsNode;
	floatToVec4: FloatToVec4JsNode;
	floor: FloorJsNode;
	geolocationCurrentPosition: GeolocationCurrentPositionJsNode;
	getBox3Property: GetBox3PropertyJsNode;
	getChildrenAttributes: GetChildrenAttributesJsNode;
	getChildrenPhysicsRBDProperties: GetChildrenPhysicsRBDPropertiesJsNode;
	getChildrenProperties: GetChildrenPropertiesJsNode;
	getDefaultCamera: GetDefaultCameraJsNode;
	getGeometryBoundingBox: GetGeometryBoundingBoxJsNode;
	getGeometryNodeObjects: GetGeometryNodeObjectsJsNode;
	getGeometryPositions: GetGeometryPositionsJsNode;
	getInstanceAttribute: GetInstanceAttributeJsNode;
	getInstanceProperty: GetInstancePropertyJsNode;
	getIntersectionAttribute: GetIntersectionAttributeJsNode;
	getIntersectionProperty: GetIntersectionPropertyJsNode;
	getMaterial: GetMaterialJsNode;
	getNode: GetNodeJsNode;
	getObject: GetObjectJsNode;
	getObjectAttribute: GetObjectAttributeJsNode;
	getObjectChild: GetObjectChildJsNode;
	getObjectProperty: GetObjectPropertyJsNode;
	getObjectUserData: GetObjectUserDataJsNode;
	getObjectWorldPosition: GetObjectWorldPositionJsNode;
	getParam: GetParamJsNode;
	getParent: GetParentJsNode;
	getPlaneProperty: GetPlanePropertyJsNode;
	getPhysicsRBD: GetPhysicsRBDJsNode;
	getPhysicsRBDCapsuleProperty: GetPhysicsRBDCapsulePropertyJsNode;
	getPhysicsRBDConeProperty: GetPhysicsRBDConePropertyJsNode;
	getPhysicsRBDCylinderProperty: GetPhysicsRBDCylinderPropertyJsNode;
	getPhysicsRBDCuboidProperty: GetPhysicsRBDCuboidPropertyJsNode;
	getPhysicsRBDSphereProperty: GetPhysicsRBDSpherePropertyJsNode;
	getPhysicsRBDProperty: GetPhysicsRBDPropertyJsNode;
	getPointAttribute: GetPointAttributeJsNode;
	getPointProperty: GetPointPropertyJsNode;
	getRayProperty: GetRayPropertyJsNode;
	getSibbling: GetSibblingJsNode;
	getSphereProperty: GetSpherePropertyJsNode;
	getTexture: GetTextureJsNode;
	getTrackedHandProperty: GetTrackedHandPropertyJsNode;
	getVideoProperty: GetVideoPropertyJsNode;
	getWebXRARSessionProperty: GetWebXRARSessionPropertyJsNode;
	getWebXRControllerProperty: GetWebXRControllerPropertyJsNode;
	getWebXRTrackedMarkerProperty: GetWebXRTrackedMarkerPropertyJsNode;
	globals: GlobalsJsNode;
	globalsAmbientLight: GlobalsAmbientLightJsNode;
	globalsAreaLight: GlobalsAreaLightJsNode;
	globalsDirectionalLight: GlobalsDirectionalLightJsNode;
	globalsHemisphereLight: GlobalsHemisphereLightJsNode;
	globalsPointLight: GlobalsPointLightJsNode;
	globalsSpotLight: GlobalsSpotLightJsNode;
	hsvToRgb: HsvToRgbJsNode;
	intToBool: IntToBoolJsNode;
	intToFloat: IntToFloatJsNode;
	isDefined: IsDefinedJsNode;
	IsTouchDevice: IsTouchDeviceJsNode;
	keyframes: KeyframesJsNode;
	length: LengthJsNode;
	lerp: LerpJsNode;
	manhattanDistance: ManhattanDistanceJsNode;
	matrix4LookAt: Matrix4LookAtJsNode;
	matrix4MakeTranslation: Matrix4MakeTranslationJsNode;
	matrix4Multiply: Matrix4MultiplyJsNode;
	max: MaxJsNode;
	maxLength: MaxLengthJsNode;
	min: MinJsNode;
	mix: MixJsNode;
	mod: ModJsNode;
	mult: MultJsNode;
	multAdd: MultAddJsNode;
	multScalar: MultScalarJsNode;
	nearestPosition: NearestPositionJsNode;
	negate: NegateJsNode;
	noiseImproved: NoiseImprovedJsNode;
	noiseSimplex: NoiseSimplexJsNode;
	normalize: NormalizeJsNode;
	null: NullJsNode;
	object3DLocalToWorld: Object3DLocalToWorldJsNode;
	object3DWorldToLocal: Object3DWorldToLocalJsNode;
	object3DUpdateMatrix: Object3DUpdateMatrixJsNode;
	object3DUpdateWorldMatrix: Object3DUpdateWorldMatrixJsNode;
	objectDispatchEvent: ObjectDispatchEventJsNode;
	onChildAttributeUpdate: OnChildAttributeUpdateJsNode;
	onKey: OnKeyJsNode;
	onKeydown: OnKeydownJsNode;
	onKeypress: OnKeypressJsNode;
	onKeyup: OnKeyupJsNode;
	onManualTrigger: OnManualTriggerJsNode;
	onMapboxCameraMove: OnMapboxCameraMoveJsNode;
	onMapboxCameraMoveEnd: OnMapboxCameraMoveEndJsNode;
	onMapboxCameraMoveStart: OnMapboxCameraMoveStartJsNode;
	onObjectAttributeUpdate: OnObjectAttributeUpdateJsNode;
	onObjectBeforeDelete: OnObjectBeforeDeleteJsNode;
	onObjectClick: OnObjectClickJsNode;
	onObjectDispatchEvent: OnObjectDispatchEventJsNode;
	onObjectHover: OnObjectHoverJsNode;
	onObjectPointerdown: OnObjectPointerdownJsNode;
	onObjectPointerup: OnObjectPointerupJsNode;
	onObjectSwipedown: OnObjectSwipedownJsNode;
	onObjectSwipeleft: OnObjectSwipeleftJsNode;
	onObjectSwiperight: OnObjectSwiperightJsNode;
	onObjectSwipeup: OnObjectSwipeupJsNode;
	onPerformanceChange: OnPerformanceChangeJsNode;
	onPointerdown: OnPointerdownJsNode;
	onPointerup: OnPointerupJsNode;
	onScenePause: OnScenePauseJsNode;
	onScenePlay: OnScenePlayJsNode;
	onSceneReset: OnSceneResetJsNode;
	onScroll: OnScrollJsNode;
	onTick: OnTickJsNode;
	onVideoEvent: OnVideoEventJsNode;
	onWebXRControllerEvent: OnWebXRControllerEventJsNode;
	or: OrJsNode;
	output: OutputJsNode;
	outputAmbientLight: OutputAmbientLightJsNode;
	outputAreaLight: OutputAreaLightJsNode;
	outputDirectionalLight: OutputDirectionalLightJsNode;
	outputHemisphereLight: OutputHemisphereLightJsNode;
	outputPointLight: OutputPointLightJsNode;
	outputSpotLight: OutputSpotLightJsNode;
	param: ParamJsNode;
	particlesSystemReset: ParticlesSystemResetJsNode;
	particlesSystemStepSimulation: ParticlesSystemStepSimulationJsNode;
	pauseAudioSource: PauseAudioSourceJsNode;
	physicsDebugUpdate: PhysicsDebugUpdateJsNode;
	physicsPlayerUpdate: PhysicsPlayerUpdateJsNode;
	physicsRBDAddForce: PhysicsRBDAddForceJsNode;
	physicsRBDAddForceAtPoint: PhysicsRBDAddForceAtPointJsNode;
	physicsRBDAddTorque: PhysicsRBDAddTorqueJsNode;
	physicsRBDApplyImpulse: PhysicsRBDApplyImpulseJsNode;
	physicsRBDApplyTorqueImpulse: PhysicsRBDApplyTorqueImpulseJsNode;
	physicsRBDApplyImpulseAtPoint: PhysicsRBDApplyImpulseAtPointJsNode;
	physicsRBDResetAll: PhysicsRBDResetAllJsNode;
	physicsRBDResetForces: PhysicsRBDResetForcesJsNode;
	physicsRBDResetTorques: PhysicsRBDResetTorquesJsNode;
	physicsWorldReset: PhysicsWorldResetJsNode;
	physicsWorldStepSimulation: PhysicsWorldStepSimulationJsNode;
	plane: PlaneJsNode;
	playAnimation: PlayAnimationJsNode;
	playAudioSource: PlayAudioSourceJsNode;
	playerMode: PlayerModeJsNode;
	playInstrumentNote: PlayInstrumentNoteJsNode;
	playerUpdate: PlayerUpdateJsNode;
	polarTransform: PolarTransformJsNode;
	pow: PowJsNode;
	pressButtonParam: PressButtonParamJsNode;
	previousValue: PreviousValueJsNode;
	quaternion: QuaternionJsNode;
	quaternionAngleTo: QuaternionAngleToJsNode;
	quaternionSlerp: QuaternionSlerpJsNode;
	radToDeg: RadToDegJsNode;
	rand: RandJsNode;
	random: RandomJsNode;
	ray: RayJsNode;
	rayFromCamera: RayFromCameraJsNode;
	rayFromCursor: RayFromCursorJsNode;
	rayIntersectBox: RayIntersectBoxJsNode;
	rayIntersectsBox: RayIntersectsBoxJsNode;
	rayIntersectObject: RayIntersectObjectJsNode;
	rayIntersectsObject: RayIntersectsObjectJsNode;
	rayDistanceToPlane: RayDistanceToPlaneJsNode;
	rayIntersectPlane: RayIntersectPlaneJsNode;
	rayIntersectsPlane: RayIntersectsPlaneJsNode;
	rayIntersectSphere: RayIntersectSphereJsNode;
	rayIntersectsSphere: RayIntersectsSphereJsNode;
	renderPixel: RenderPixelJsNode;
	rotate: RotateJsNode;
	round: RoundJsNode;
	SDF2DBox: SDF2DBoxJsNode;
	SDF2DCircle: SDF2DCircleJsNode;
	SDF2DCross: SDF2DCrossJsNode;
	SDF2DHeart: SDF2DHeartJsNode;
	SDF2DRoundedX: SDF2DRoundedXJsNode;
	SDFBox: SDFBoxJsNode;
	SDFElongate: SDFElongateJsNode;
	SDFIntersect: SDFIntersectJsNode;
	SDFOnion: SDFOnionJsNode;
	SDFPlane: SDFPlaneJsNode;
	SDFRevolution: SDFRevolutionJsNode;
	SDFSphere: SDFSphereJsNode;
	SDFSubtract: SDFSubtractJsNode;
	SDFTorus: SDFTorusJsNode;
	SDFTransform: SDFTransformJsNode;
	SDFTube: SDFTubeJsNode;
	SDFUnion: SDFUnionJsNode;
	setCameraViewOffset: SetCameraViewOffsetJsNode;
	setCSSObjectClass: SetCSSObjectClassJsNode;
	setGeometryInstanceAttribute: SetGeometryInstanceAttributeJsNode;
	setGeometryInstancePositions: SetGeometryInstancePositionsJsNode;
	setGeometryInstanceQuaternions: SetGeometryInstanceQuaternionsJsNode;
	setGeometryInstanceScales: SetGeometryInstanceScalesJsNode;
	setGeometryInstanceTransforms: SetGeometryInstanceTransformsJsNode;
	setGeometryPositions: SetGeometryPositionsJsNode;
	setInstanceAttribute: SetInstanceAttributeJsNode;
	setInstanceLookAt: SetInstanceLookAtJsNode;
	setInstancePosition: SetInstancePositionJsNode;
	setInstanceQuaternion: SetInstanceQuaternionJsNode;
	setInstanceScale: SetInstanceScaleJsNode;
	setMaterialAlphaMap: SetMaterialAlphaMapJsNode;
	setMaterialAOMap: SetMaterialAOMapJsNode;
	setMaterialColor: SetMaterialColorJsNode;
	setMaterialDisplacementMap: SetMaterialDisplacementMapJsNode;
	setMaterialEmissiveColor: SetMaterialEmissiveColorJsNode;
	setMaterialEnvMapJsNode: SetMaterialEnvMapJsNode;
	setMaterialEmissiveMapJsNode: SetMaterialEmissiveMapJsNode;
	setMaterialMap: SetMaterialMapJsNode;
	setMaterialMetalnessMap: SetMaterialMetalnessMapJsNode;
	setMaterialRoughnessMap: SetMaterialRoughnessMapJsNode;
	setMaterialOpacity: SetMaterialOpacityJsNode;
	setMaterialUniform: SetMaterialUniformJsNode;
	setObjectAttribute: SetObjectAttributeJsNode;
	setObjectCastShadow: SetObjectCastShadowJsNode;
	setObjectFrustumCulled: SetObjectFrustumCulledJsNode;
	setObjectLookAt: SetObjectLookAtJsNode;
	setObjectMaterial: SetObjectMaterialJsNode;
	setObjectMaterialColor: SetObjectMaterialColorJsNode;
	setObjectMatrix: SetObjectMatrixJsNode;
	setObjectMatrixAutoUpdate: SetObjectMatrixAutoUpdateJsNode;
	setObjectPosition: SetObjectPositionJsNode;
	setObjectPolarTransform: SetObjectPolarTransformJsNode;
	setObjectQuaternion: SetObjectQuaternionJsNode;
	setObjectRotation: SetObjectRotationJsNode;
	setObjectReceiveShadow: SetObjectReceiveShadowJsNode;
	setObjectScale: SetObjectScaleJsNode;
	setObjectVisible: SetObjectVisibleJsNode;
	setParam: SetParamJsNode;
	setPerspectiveCameraFov: SetPerspectiveCameraFovJsNode;
	setPerspectiveCameraNearFar: SetPerspectiveCameraNearFarJsNode;
	setPhysicsRBDAngularVelocity: SetPhysicsRBDAngularVelocityJsNode;
	setPhysicsRBDLinearVelocity: SetPhysicsRBDLinearVelocityJsNode;
	setPhysicsRBDPosition: SetPhysicsRBDPositionJsNode;
	setPhysicsRBDRotation: SetPhysicsRBDRotationJsNode;
	setPhysicsRBDCapsuleProperty: SetPhysicsRBDCapsulePropertyJsNode;
	setPhysicsRBDConeProperty: SetPhysicsRBDConePropertyJsNode;
	setPhysicsRBDCylinderProperty: SetPhysicsRBDCylinderPropertyJsNode;
	setPhysicsRBDCuboidProperty: SetPhysicsRBDCuboidPropertyJsNode;
	setPhysicsRBDSphereProperty: SetPhysicsRBDSpherePropertyJsNode;
	setPhysicsWorldGravity: SetPhysicsWorldGravityJsNode;
	setPlayerInput: SetPlayerInputJsNode;
	setPointAttribute: SetPointAttributeJsNode;
	setPointPosition: SetPointPositionJsNode;
	setClothConstraintPosition: SetClothConstraintPositionJsNode;
	setSoftBodyPosition: SetSoftBodyPositionJsNode;
	setSoftBodyVelocity: SetSoftBodyVelocityJsNode;
	setSoftBodyConstraintPosition: SetSoftBodyConstraintPositionJsNode;
	setSpotLightIntensity: SetSpotLightIntensityJsNode;
	setViewer: SetViewerJsNode;
	setViewerControls: SetViewerControlsJsNode;
	sign: SignJsNode;
	sin: SinJsNode;
	smoothstep: SmoothstepJsNode;
	smootherstep: SmootherstepJsNode;
	softBodySolverStepSimulation: SoftBodySolverStepSimulationJsNode;
	sphere: SphereJsNode;
	sqrt: SqrtJsNode;
	subnet: SubnetJsNode;
	subnetInput: SubnetInputJsNode;
	subnetOutput: SubnetOutputJsNode;
	subtract: SubtractJsNode;
	switch: SwitchJsNode;
	tan: TanJsNode;
	trackFace: TrackFaceJsNode;
	trackHand: TrackHandJsNode;
	triggerDelay: TriggerDelayJsNode;
	triggerFilter: TriggerFilterJsNode;
	triggerSwitch: TriggerSwitchJsNode;
	triggerTwoWaySwitch: TriggerTwoWaySwitchJsNode;
	twoWaySwitch: TwoWaySwitchJsNode;
	vector3AngleTo: Vector3AngleToJsNode;
	vector3Project: Vector3ProjectJsNode;
	vector3ProjectOnPlane: Vector3ProjectOnPlaneJsNode;
	vector3Unproject: Vector3UnprojectJsNode;
	vec2ToFloat: Vec2ToFloatJsNode;
	vec2ToVec3: Vec2ToVec3JsNode;
	vec3ToColor: Vec3ToColorJsNode;
	vec3ToFloat: Vec3ToFloatJsNode;
	vec3ToVec2: Vec3ToVec2JsNode;
	vec3ToVec4: Vec3ToVec4JsNode;
	vec4ToFloat: Vec4ToFloatJsNode;
	vec4ToVec3: Vec4ToVec3JsNode;
	vector2: Vector2JsNode;
	vector3: Vector3JsNode;
	vector4: Vector4JsNode;
}
// @ts-ignore
type Listener = () => void;
declare class addAudioStopEventListener extends NamedFunction3<[
	string,
	Listener,
	ActorEvaluator
]> {
	static type(): string;
	func(nodePath: string, listener: Listener, evaluator: ActorEvaluator): void;
}
declare class playAudioSource extends ObjectNamedFunction1<[
	string
]> {
	static type(): string;
	func(object3D: Object3D, nodePath: string): void;
}
declare class pauseAudioSource extends ObjectNamedFunction1<[
	string
]> {
	static type(): string;
	func(object3D: Object3D, nodePath: string): void;
}
declare class playInstrumentNote extends ObjectNamedFunction3<[
	string,
	string,
	number
]> {
	static type(): string;
	func(object3D: Object3D, nodePath: string, note: string, duration: number): void;
}
declare class addNumber extends NamedFunction<Array<number>, Array<string>> {
	static type(): string;
	func(...args: Array<number>): number;
}
// @ts-ignore
type AvailableItem = Vector2 | Vector3 | Vector4;
declare class addVector<V extends AvailableItem> extends NamedFunction<Array<V>, Array<string>> {
	static type(): string;
	func(...args: Array<V>): V;
}
declare class addVectorNumber<V extends AvailableItem> extends NamedFunction2<[
	V,
	number
]> {
	static type(): string;
	func(vector: V, number: number): V;
}
declare enum VideoEvent {
	PLAY = "play",
	PAUSE = "pause",
	TIME_UPDATE = "timeupdate",
	VOLUME_CHANGE = "volumechange"
}
type CallbackByVideoEvent = Record<VideoEvent, NodeEventListener>;
declare class addVideoEventListener extends NamedFunction3<[
	string,
	CallbackByVideoEvent,
	ActorEvaluator
]> {
	static type(): string;
	func(nodePath: string, listeners: CallbackByVideoEvent, evaluator: ActorEvaluator): void;
}
declare class getVideoPropertyCurrentTime extends NamedFunction1<[
	string
]> {
	static type(): string;
	func(nodePath: string): number;
}
declare class getVideoPropertyDuration extends NamedFunction1<[
	string
]> {
	static type(): string;
	func(nodePath: string): number;
}
declare class getVideoPropertyPlaying extends NamedFunction1<[
	string
]> {
	static type(): string;
	func(nodePath: string): boolean;
}
declare class getVideoPropertyMuted extends NamedFunction1<[
	string
]> {
	static type(): string;
	func(nodePath: string): boolean;
}
declare class andArrays extends NamedFunction1<[
	Array<boolean[]>
]> {
	static type(): string;
	func(arrays: Array<boolean[]>): boolean;
}
declare class andBooleans extends NamedFunction1<[
	boolean[]
]> {
	static type(): string;
	func(arrays: boolean[]): boolean;
}
declare class orArrays extends NamedFunction1<[
	Array<boolean[]>
]> {
	static type(): string;
	func(arrays: Array<boolean[]>): boolean;
}
declare class orBooleans extends NamedFunction1<[
	boolean[]
]> {
	static type(): string;
	func(arrays: boolean[]): boolean;
}
type GetAnimationAction = () => AnimationAction;
declare class getAnimationMixer extends ObjectNamedFunction0 {
	static type(): string;
	func(object3D: Object3D): AnimationMixer;
}
declare class animationMixerUpdate extends ObjectNamedFunction0 {
	static type(): string;
	func(object3D: Object3D): void;
}
declare class getAnimationAction extends NamedFunction3<[
	AnimationMixer,
	string,
	boolean
]> {
	static type(): string;
	func(mixer: AnimationMixer, clipName: string, autoPlay: boolean): AnimationAction;
}
declare class animationActionPlay extends NamedFunction1<[
	AnimationAction
]> {
	static type(): string;
	func(action: AnimationAction): void;
}
declare class animationActionStop extends NamedFunction1<[
	AnimationAction
]> {
	static type(): string;
	func(action: AnimationAction): void;
}
declare class animationActionFadeIn extends NamedFunction5<[
	AnimationAction,
	number,
	boolean,
	boolean,
	boolean
]> {
	static type(): string;
	func(action: AnimationAction, duration: number, fadeOutOtherActions: boolean, warp: boolean, startOnFromActionEnd: boolean): void;
}
declare class animationActionFadeOut extends NamedFunction2<[
	AnimationAction,
	number
]> {
	static type(): string;
	func(action: AnimationAction, duration: number): void;
}
declare class animationActionCrossFade extends NamedFunction5<[
	AnimationAction,
	GetAnimationAction,
	number,
	boolean,
	boolean
]> {
	static type(): string;
	func(actionFrom: AnimationAction, actionToGet: GetAnimationAction, duration: number, warp: boolean, startOnFromActionEnd: boolean): void;
}
declare class arrayLength extends NamedFunction1<[
	Array<any>
]> {
	static type(): string;
	func(array: Array<any>): number;
}
declare class elementsToArrayPrimitive<T extends PrimitiveArrayElement> extends NamedFunction2<[
	Array<T>,
	Array<T>
]> {
	static type(): string;
	func(src: Array<T>, target: Array<T>): Array<T>;
}
declare class elementsToArrayVector<T extends VectorArrayElement> extends NamedFunction2<[
	Array<T>,
	Array<T>
]> {
	static type(): string;
	func(src: Array<T>, target: Array<T>): Array<T>;
}
declare class arrayElementPrimitive<T extends PrimitiveArrayElement> extends NamedFunction2<[
	Array<T>,
	number
]> {
	static type(): string;
	func(src: Array<T>, index: number): T;
}
declare class arrayElementVector<T extends VectorArrayElement> extends NamedFunction3<[
	Array<T>,
	number,
	T
]> {
	static type(): string;
	func(src: Array<T>, index: number, target: T): T;
}
declare class arrayPopPrimitive<T extends PrimitiveArrayElement> extends NamedFunction1<[
	Array<T>
]> {
	static type(): string;
	func(src: Array<T>): T | undefined;
}
declare class arrayPopVector<T extends VectorArrayElement> extends NamedFunction2<[
	Array<T>,
	T
]> {
	static type(): string;
	func(src: Array<T>, target: T): T;
}
declare class arrayShiftPrimitive<T extends PrimitiveArrayElement> extends NamedFunction1<[
	Array<T>
]> {
	static type(): string;
	func(src: Array<T>): T | undefined;
}
declare class arrayShiftVector<T extends VectorArrayElement> extends NamedFunction2<[
	Array<T>,
	T
]> {
	static type(): string;
	func(src: Array<T>, target: T): T;
}
declare class boolToInt extends NamedFunction1<[
	boolean
]> {
	static type(): string;
	func(b: boolean): number;
}
declare class intToBool extends NamedFunction1<[
	number
]> {
	static type(): string;
	func(v: number): boolean;
}
declare class floatToInt extends NamedFunction1<[
	number
]> {
	static type(): string;
	func(v: number): number;
}
declare class intToFloat extends NamedFunction1<[
	number
]> {
	static type(): string;
	func(v: number): number;
}
declare class floatToColor extends NamedFunction4<[
	number,
	number,
	number,
	Color
]> {
	static type(): string;
	func(r: number, g: number, b: number, target: Color): Color;
}
declare class floatToVec2 extends NamedFunction3<[
	number,
	number,
	Vector2
]> {
	static type(): string;
	func(x: number, y: number, target: Vector2): Vector2;
}
declare class floatToVec3 extends NamedFunction4<[
	number,
	number,
	number,
	Vector3
]> {
	static type(): string;
	func(x: number, y: number, z: number, target: Vector3): Vector3;
}
declare class floatToVec4 extends NamedFunction5<[
	number,
	number,
	number,
	number,
	Vector4
]> {
	static type(): string;
	func(x: number, y: number, z: number, w: number, target: Vector4): Vector4;
}
declare class vec2ToVec3 extends NamedFunction3<[
	Vector2,
	number,
	Vector3
]> {
	static type(): string;
	func(src: Vector2, z: number, target: Vector3): Vector3;
}
declare class vec3ToVec4 extends NamedFunction3<[
	Vector3,
	number,
	Vector4
]> {
	static type(): string;
	func(src: Vector3, w: number, target: Vector4): Vector4;
}
declare class vec3ToColor extends NamedFunction2<[
	Vector3,
	Color
]> {
	static type(): string;
	func(src: Vector3, target: Color): Color;
}
declare class colorToVec3 extends NamedFunction2<[
	Color,
	Vector3
]> {
	static type(): string;
	func(src: Color, target: Vector3): Vector3;
}
declare class box3Set extends NamedFunction3<[
	Vector3,
	Vector3,
	Box3
]> {
	static type(): string;
	func(min: Vector3, max: Vector3, target: Box3): Box3;
}
declare class box3SetFromObject extends ObjectNamedFunction2<[
	boolean,
	Box3
]> {
	static type(): string;
	func(object: Object3D, precise: boolean, target: Box3): Box3;
}
declare class box3ContainsPoint extends NamedFunction2<[
	Box3,
	Vector3
]> {
	static type(): string;
	func(box3: Box3, point: Vector3): boolean;
}
declare class box3IntersectsBox3 extends NamedFunction2<[
	Box3,
	Box3
]> {
	static type(): string;
	func(box3a: Box3, box3b: Box3): boolean;
}
declare class getBox3Center extends NamedFunction2<[
	Box3,
	Vector3
]> {
	static type(): string;
	func(box3: Box3, target: Vector3): Vector3;
}
declare class getBox3Min extends NamedFunction2<[
	Box3,
	Vector3
]> {
	static type(): string;
	func(box3: Box3, target: Vector3): Vector3;
}
declare class getBox3Max extends NamedFunction2<[
	Box3,
	Vector3
]> {
	static type(): string;
	func(box3: Box3, target: Vector3): Vector3;
}
declare class catmullRomCurve3GetPoint extends NamedFunction3<[
	CatmullRomCurve3,
	number,
	Vector3
]> {
	static type(): string;
	func(curve: CatmullRomCurve3, t: number, target: Vector3): Vector3;
}
declare class Channel {
	readonly data: ChannelData;
	private _valuesByPos;
	protected _setCurveCallback: SetCurveCallback;
	protected _getValueCallback: GetValueCallback;
	constructor(data: ChannelData);
	static fromJSON(data: ChannelData): Channel;
	value(t: number): number;
	static validate(data: ChannelData): void;
	private _setCallbacks;
	compute(): void;
}
type ChannelData1 = ChannelData;
type ChannelData2 = [
	ChannelData,
	ChannelData
];
type ChannelData3 = [
	ChannelData,
	ChannelData,
	ChannelData
];
type ChannelData4 = [
	ChannelData,
	ChannelData,
	ChannelData,
	ChannelData
];
type Channel2 = {
	x: Channel;
	y: Channel;
};
type Channel3 = {
	x: Channel;
	y: Channel;
	z: Channel;
};
type Channel4 = {
	x: Channel;
	y: Channel;
	z: Channel;
	w: Channel;
};
declare class channelFloat extends NamedFunction1<[
	ChannelData1
]> {
	static type(): string;
	func(data: ChannelData1): Channel;
}
declare class channelVector2 extends NamedFunction1<[
	ChannelData2
]> {
	static type(): string;
	func(data: ChannelData2): Channel2;
}
declare class channelVector3 extends NamedFunction1<[
	ChannelData3
]> {
	static type(): string;
	func(data: ChannelData3): Channel3;
}
declare class channelVector4 extends NamedFunction1<[
	ChannelData4
]> {
	static type(): string;
	func(data: ChannelData4): Channel4;
}
declare class channelValueFloat extends NamedFunction2<[
	Channel,
	number
]> {
	static type(): string;
	func(channel: Channel, t: number): number;
}
declare class channelValueVector2 extends NamedFunction3<[
	Channel2,
	number,
	Vector2
]> {
	static type(): string;
	func(channel: Channel2, t: number, target: Vector2): Vector2;
}
declare class channelValueVector3 extends NamedFunction3<[
	Channel3,
	number,
	Vector3
]> {
	static type(): string;
	func(channel: Channel3, t: number, target: Vector3): Vector3;
}
declare class channelValueVector4 extends NamedFunction3<[
	Channel4,
	number,
	Vector4
]> {
	static type(): string;
	func(channel: Channel4, t: number, target: Vector4): Vector4;
}
// @ts-ignore
declare class clamp extends NamedFunction3<[
	number,
	number,
	number
]> {
	static type(): string;
	func(value: number, min: number, max: number): number;
}
declare class complement extends NamedFunction1<[
	number
]> {
	static type(): string;
	func(value: number): number;
}
declare class degToRad extends NamedFunction1<[
	number
]> {
	static type(): string;
	func(value: number): number;
}
// @ts-ignore
declare class radToDeg extends NamedFunction1<[
	number
]> {
	static type(): string;
	func(value: number): number;
}
// @ts-ignore
declare class fit extends NamedFunction5<[
	number,
	number,
	number,
	number,
	number
]> {
	static type(): string;
	func(value: number, srcMin: number, srcMax: number, destMin: number, destMax: number): number;
}
declare class fitClamp extends NamedFunction5<[
	number,
	number,
	number,
	number,
	number
]> {
	static type(): string;
	func(value: number, srcMin: number, srcMax: number, destMin: number, destMax: number): number;
}
declare class mix extends NamedFunction3<[
	number,
	number,
	number
]> {
	static type(): string;
	func(value0: number, value1: number, blend: number): number;
}
declare class mod extends NamedFunction2<[
	number,
	number
]> {
	static type(): string;
	func(v1: number, v2: number): number;
}
declare class multAdd extends NamedFunction4<[
	number,
	number,
	number,
	number
]> {
	static type(): string;
	func(value: number, preAdd: number, mult: number, postAdd: number): number;
}
declare class negate<T extends number | boolean> extends NamedFunction1<[
	T
]> {
	static type(): string;
	func(value: T): T;
}
declare class rand extends NamedFunction2<[
	number,
	number
]> {
	static type(): string;
	func(value0: number, value1: number): number;
}
declare class random extends NamedFunction0 {
	static type(): string;
	func(): number;
}
declare class smoothstep extends NamedFunction3<[
	number,
	number,
	number
]> {
	static type(): string;
	func(value: number, min: number, max: number): number;
}
declare class smootherstep extends NamedFunction3<[
	number,
	number,
	number
]> {
	static type(): string;
	func(value: number, min: number, max: number): number;
}
type RawMaterialUniforms = {
	[uniform: string]: IUniform;
};
interface CopyUniforms extends RawMaterialUniforms {
	order: IUniformN;
	tSize: IUniformV2;
	texture: IUniformTexture;
}
interface IntegrationUniforms extends RawMaterialUniforms {
	timeDelta: IUniformN;
	time: IUniformN;
	viscosity: IUniformN;
	spring: IUniformN;
	tSize: IUniformV2;
	order: IUniformN;
	tOriginal: IUniformTexture;
	tPrevious0: IUniformTexture;
	tPrevious1: IUniformTexture;
	tPosition0: IUniformTexture;
	tPosition1: IUniformTexture;
	tViscositySpring: IUniformTexture;
}
interface MouseUniforms extends RawMaterialUniforms {
	time: IUniformN;
	vertex: IUniformN;
	coordinates: IUniformV3;
	order: IUniformN;
	tSize: IUniformV2;
	tOriginal: IUniformTexture;
	tPosition0: IUniformTexture;
	tPosition1: IUniformTexture;
}
interface ConstraintsUniforms extends RawMaterialUniforms {
	time: IUniformN;
	tSize: IUniformV2;
	order: IUniformN;
	constraintInfluence: IUniformN;
	tPosition0: IUniformTexture;
	tPosition1: IUniformTexture;
	tAdjacentsA: IUniformTexture;
	tAdjacentsB: IUniformTexture;
	tDistancesA: IUniformTexture;
	tDistancesB: IUniformTexture;
	secondaryMotionMult: IUniformN;
}
interface NormalsUniforms extends RawMaterialUniforms {
	tSize: IUniformV2;
	tPosition0: IUniformTexture;
	tPosition1: IUniformTexture;
	tAdjacentsA: IUniformTexture;
	tAdjacentsB: IUniformTexture;
}
interface CopyMaterial extends RawShaderMaterial {
	uniforms: CopyUniforms;
}
interface IntegrationMaterial extends RawShaderMaterial {
	uniforms: IntegrationUniforms;
}
interface MouseMaterial extends RawShaderMaterial {
	uniforms: MouseUniforms;
}
interface ConstraintsMaterial extends RawShaderMaterial {
	uniforms: ConstraintsUniforms;
}
interface NormalsMaterial extends RawShaderMaterial {
	uniforms: NormalsUniforms;
}
declare class ClothMaterialController {
	readonly mainController: ClothController;
	readonly copyShader: CopyMaterial;
	readonly integrateShader: IntegrationMaterial;
	readonly mouseShader: MouseMaterial;
	readonly constraintsShader: ConstraintsMaterial;
	readonly normalsShader: NormalsMaterial;
	constructor(mainController: ClothController);
}
declare class ClothGeometryInitController {
	mesh: Mesh;
	adjacency: number[][];
	geometry: BufferGeometry;
	readonly resolution: Vector2;
	constructor(mesh: Mesh);
}
interface TextureVariableData {
	name: string;
	size: number;
	nodes: string[];
}
declare class TextureVariable {
	private _name;
	private _size;
	private _allocation;
	private _position;
	private _readonly;
	private _graphNodeIds;
	constructor(_name: string, _size: number);
	merge(variable: TextureVariable): void;
	setReadonly(state: boolean): void;
	readonly(): boolean;
	setAllocation(allocation: TextureAllocation): void;
	allocation(): TextureAllocation | undefined;
	graphNodeIds(): Set<number> | undefined;
	addGraphNodeId(id: CoreGraphNodeId): void;
	name(): string;
	size(): number;
	setPosition(position: number): void;
	position(): number;
	component(): string;
	static fromJSON(data: TextureVariableData): TextureVariable;
	toJSON(scene: PolyScene): TextureVariableData;
}
type TextureAllocationData = TextureVariableData[];
declare class TextureAllocation {
	private _variables;
	private _size;
	constructor();
	addVariable(variable: TextureVariable): void;
	hasSpaceForVariable(variable: TextureVariable): boolean;
	shaderName(): ShaderName;
	textureName(): string;
	variables(): TextureVariable[] | undefined;
	variablesForInputNode(root_node: BaseGlNodeType): TextureVariable[] | undefined;
	inputNamesForNode(root_node: BaseGlNodeType): string[] | undefined;
	variable(variable_name: string): TextureVariable | undefined;
	static fromJSON(data: TextureAllocationData): TextureAllocation;
	toJSON(scene: PolyScene): TextureAllocationData;
}
type TextureAllocationsControllerData = {
	writable: PolyDictionary<TextureAllocationData>[];
	readonly: PolyDictionary<TextureAllocationData>[];
};
declare class TextureAllocationsController {
	private _writableAllocations;
	private _readonlyAllocations;
	constructor();
	dispose(): void;
	private static _sortNodes;
	allocateConnectionsFromRootNodes(rootNodes: BaseGlNodeType[], leafNodes: BaseGlNodeType[]): void;
	private _allocateVariables;
	private _ensureVariablesAreUnique;
	private _allocateVariable;
	private _addWritableAllocation;
	private _addReadonlyAllocation;
	readonlyAllocations(): TextureAllocation[];
	shaderNames(): ShaderName[];
	createShaderConfigs(): ShaderConfig[];
	allocationForShaderName(shader_name: ShaderName): TextureAllocation | undefined;
	inputNamesForShaderName(root_node: BaseGlNodeType, shader_name: ShaderName): string[] | undefined;
	variable(variable_name: string): TextureVariable | undefined;
	variables(): TextureVariable[];
	hasVariable(name: string): boolean;
	static fromJSON(data: TextureAllocationsControllerData): TextureAllocationsController;
	toJSON(scene: PolyScene): TextureAllocationsControllerData;
	print(scene: PolyScene): void;
}
declare class ShaderAssemblerCloth extends BaseGlShaderAssembler {
	private _textureAllocationsController;
	templateShader(): undefined;
	protected _template_shader_for_shader_name(shader_name: ShaderName): string;
	compile(): void;
	rootNodesByShaderName(shader_name: ShaderName, rootNodes: BaseGlNodeType[]): BaseGlNodeType[];
	setup_shader_names_and_variables(): void;
	private _updateShaders;
	add_output_inputs(output_child: OutputGlNode): void;
	add_globals_outputs(globals_node: GlobalsGlNode): void;
	allow_attribute_exports(): boolean;
	textureAllocationsController(): TextureAllocationsController;
	create_shader_configs(): ShaderConfig[];
	create_variable_configs(): never[];
	shaderNames(): ShaderName[];
	inputNamesForShaderName(root_node: BaseGlNodeType, shader_name: ShaderName): string[];
	protected insertDefineAfter(shader_name: ShaderName): string;
	protected insertBodyAfter(shader_name: ShaderName): string;
	protected linesToRemove(shader_name: ShaderName): string[];
	add_export_body_line(exportNode: BaseGlNodeType, inputName: string, input: BaseGlNodeType, variableName: string, linesController: ShadersCollectionController): void;
	set_node_lines_output(outputNode: BaseGlNodeType, linesController: ShadersCollectionController): void;
	setNodeLinesAttribute(attributeNode: AttributeGlNode, linesController: ShadersCollectionController): void;
	set_node_lines_globals(globals_node: GlobalsGlNode, linesController: ShadersCollectionController): void;
	private _handleGlobalsUniform;
	private _handleGlobalsPosition;
}
interface PersistedConfigBaseClothData extends PersistedConfigWithShaders {
	texture_allocations: TextureAllocationsControllerData;
	param_uniform_pairs: [
		string,
		string
	][];
	uniforms_owner: object;
}
declare class ClothPersistedConfig extends BasePersistedConfig {
	protected node: ClothSolverSopNode;
	private _loaded_data;
	constructor(node: ClothSolverSopNode);
	toData(): Promise<PersistedConfigBaseClothData | undefined>;
	load(data: PersistedConfigBaseClothData): void;
	loaded_data(): PersistedConfigBaseClothData | undefined;
	shaders_by_name(): Map<ShaderName, string> | undefined;
	texture_allocations_controller(): TextureAllocationsController | undefined;
	uniforms(): {
		[uniform: string]: IUniform<any>;
	} | undefined;
}
declare class FloatToIntGlParamsConfig extends NodeParamsConfig {
	float: ParamTemplate<ParamType.FLOAT>;
}
declare class FloatToIntGlNode extends TypedGlNode<FloatToIntGlParamsConfig> {
	paramsConfig: FloatToIntGlParamsConfig;
	static type(): string;
	initializeNode(): void;
	setLines(shaders_collection_controller: ShadersCollectionController): void;
}
declare class IntToFloatGlParamsConfig extends NodeParamsConfig {
	int: ParamTemplate<ParamType.INTEGER>;
}
declare class IntToFloatGlNode extends TypedGlNode<IntToFloatGlParamsConfig> {
	paramsConfig: IntToFloatGlParamsConfig;
	static type(): string;
	initializeNode(): void;
	setLines(shaders_collection_controller: ShadersCollectionController): void;
}
declare class IntToBoolGlParamsConfig extends NodeParamsConfig {
	int: ParamTemplate<ParamType.INTEGER>;
}
declare class IntToBoolGlNode extends TypedGlNode<IntToBoolGlParamsConfig> {
	paramsConfig: IntToBoolGlParamsConfig;
	static type(): string;
	initializeNode(): void;
	setLines(shaders_collection_controller: ShadersCollectionController): void;
}
declare class BoolToIntGlParamsConfig extends NodeParamsConfig {
	bool: ParamTemplate<ParamType.BOOLEAN>;
}
declare class BoolToIntGlNode extends TypedGlNode<BoolToIntGlParamsConfig> {
	paramsConfig: BoolToIntGlParamsConfig;
	static type(): string;
	initializeNode(): void;
	setLines(shaders_collection_controller: ShadersCollectionController): void;
}
declare class FloatToVec2GlParamsConfig extends NodeParamsConfig {
	x: ParamTemplate<ParamType.FLOAT>;
	y: ParamTemplate<ParamType.FLOAT>;
}
declare class FloatToVec2GlNode extends TypedGlNode<FloatToVec2GlParamsConfig> {
	paramsConfig: FloatToVec2GlParamsConfig;
	static type(): string;
	static readonly OUTPUT_NAME = "vec2";
	initializeNode(): void;
	setLines(shaders_collection_controller: ShadersCollectionController): void;
}
declare class FloatToVec3GlParamsConfig extends NodeParamsConfig {
	x: ParamTemplate<ParamType.FLOAT>;
	y: ParamTemplate<ParamType.FLOAT>;
	z: ParamTemplate<ParamType.FLOAT>;
}
declare class FloatToVec3GlNode extends TypedGlNode<FloatToVec3GlParamsConfig> {
	paramsConfig: FloatToVec3GlParamsConfig;
	static type(): string;
	static readonly OUTPUT_NAME = "vec3";
	initializeNode(): void;
	setLines(shaders_collection_controller: ShadersCollectionController): void;
}
declare class FloatToVec4GlParamsConfig extends NodeParamsConfig {
	x: ParamTemplate<ParamType.FLOAT>;
	y: ParamTemplate<ParamType.FLOAT>;
	z: ParamTemplate<ParamType.FLOAT>;
	w: ParamTemplate<ParamType.FLOAT>;
}
declare class FloatToVec4GlNode extends TypedGlNode<FloatToVec4GlParamsConfig> {
	paramsConfig: FloatToVec4GlParamsConfig;
	static type(): string;
	static readonly OUTPUT_NAME = "vec4";
	initializeNode(): void;
	setLines(shaders_collection_controller: ShadersCollectionController): void;
}
declare class VecToParamsGlConfig extends NodeParamsConfig {
}
declare class BaseVecToGlNode extends TypedGlNode<VecToParamsGlConfig> {
	paramsConfig: VecToParamsGlConfig;
}
declare const Vec2ToFloatGlNode_base: typeof BaseVecToGlNode;
declare class Vec2ToFloatGlNode extends Vec2ToFloatGlNode_base {
}
declare const Vec3ToFloatGlNode_base: typeof BaseVecToGlNode;
declare class Vec3ToFloatGlNode extends Vec3ToFloatGlNode_base {
}
declare const Vec4ToFloatGlNode_base: typeof BaseVecToGlNode;
declare class Vec4ToFloatGlNode extends Vec4ToFloatGlNode_base {
}
declare class Vec4ToVec3GlNode extends BaseVecToGlNode {
	static type(): string;
	static readonly INPUT_NAME_VEC4 = "vec4";
	static readonly OUTPUT_NAME_VEC3 = "vec3";
	static readonly OUTPUT_NAME_W = "w";
	initializeNode(): void;
	createParams(): void;
	setLines(shaders_collection_controller: ShadersCollectionController): void;
}
declare class Vec3ToVec2GlNode extends BaseVecToGlNode {
	static type(): string;
	static readonly INPUT_NAME_VEC3 = "vec3";
	static readonly OUTPUT_NAME_VEC2 = "vec2";
	static readonly OUTPUT_NAME_Z = "z";
	initializeNode(): void;
	createParams(): void;
	setLines(shaders_collection_controller: ShadersCollectionController): void;
}
declare class Vec2ToVec3GlNode extends BaseVecToGlNode {
	static type(): string;
	static readonly INPUT_NAME_VEC2 = "vec2";
	static readonly INPUT_NAME_Z = "z";
	static readonly OUTPUT_NAME_VEC3 = "vec3";
	initializeNode(): void;
	createParams(): void;
	setLines(shaders_collection_controller: ShadersCollectionController): void;
}
declare class Vec3ToVec4GlNode extends BaseVecToGlNode {
	static type(): string;
	static readonly INPUT_NAME_VEC3 = "vec3";
	static readonly INPUT_NAME_W = "w";
	static readonly OUTPUT_NAME_VEC4 = "vec4";
	initializeNode(): void;
	createParams(): void;
	setLines(shaders_collection_controller: ShadersCollectionController): void;
}
declare class BaseGlMathFunctionParamsConfig extends NodeParamsConfig {
}
declare abstract class BaseGlMathFunctionGlNode extends TypedGlNode<BaseGlMathFunctionParamsConfig> {
	paramsConfig: BaseGlMathFunctionParamsConfig;
	protected gl_method_name(): string;
	protected gl_function_definitions(): TypedGLDefinition<GLDefinitionType>[];
	initializeNode(): void;
	protected _expected_input_types(): GlConnectionPointType[];
	protected _expected_output_types(): GlConnectionPointType[];
	protected _gl_input_name(index: number): string;
	setLines(shaders_collection_controller: ShadersCollectionController): void;
}
declare abstract class BaseNodeGlMathFunctionArg1GlNode extends BaseGlMathFunctionGlNode {
	protected _gl_input_name(index: number): string;
	protected _expected_input_types(): GlConnectionPointType[];
}
declare abstract class BaseNodeGlMathFunctionArg2GlNode extends BaseGlMathFunctionGlNode {
	protected _expected_input_types(): GlConnectionPointType[];
}
declare abstract class BaseNodeGlMathFunctionArg3GlNode extends BaseGlMathFunctionGlNode {
	protected _expected_input_types(): GlConnectionPointType[];
}
declare abstract class BaseNodeGlMathFunctionArg4GlNode extends BaseGlMathFunctionGlNode {
	protected _expected_input_types(): GlConnectionPointType[];
}
declare abstract class BaseNodeGlMathFunctionArg5GlNode extends BaseGlMathFunctionGlNode {
	protected _expected_input_types(): GlConnectionPointType[];
}
declare const AbsGlNode_base: typeof BaseNodeGlMathFunctionArg1GlNode;
declare class AbsGlNode extends AbsGlNode_base {
}
declare const AcosGlNode_base: typeof BaseNodeGlMathFunctionArg1GlNode;
declare class AcosGlNode extends AcosGlNode_base {
}
declare const AsinGlNode_base: typeof BaseNodeGlMathFunctionArg1GlNode;
declare class AsinGlNode extends AsinGlNode_base {
}
declare const AtanGlNode_base: typeof BaseNodeGlMathFunctionArg1GlNode;
declare class AtanGlNode extends AtanGlNode_base {
}
declare const CeilGlNode_base: typeof BaseNodeGlMathFunctionArg1GlNode;
declare class CeilGlNode extends CeilGlNode_base {
}
declare const CosGlNode_base: typeof BaseNodeGlMathFunctionArg1GlNode;
declare class CosGlNode extends CosGlNode_base {
}
declare const DegreesGlNode_base: typeof BaseNodeGlMathFunctionArg1GlNode;
declare class DegreesGlNode extends DegreesGlNode_base {
}
declare const ExpGlNode_base: typeof BaseNodeGlMathFunctionArg1GlNode;
declare class ExpGlNode extends ExpGlNode_base {
}
declare const Exp2GlNode_base: typeof BaseNodeGlMathFunctionArg1GlNode;
declare class Exp2GlNode extends Exp2GlNode_base {
}
declare const FloorGlNode_base: typeof BaseNodeGlMathFunctionArg1GlNode;
declare class FloorGlNode extends FloorGlNode_base {
}
declare const FractGlNode_base: typeof BaseNodeGlMathFunctionArg1GlNode;
declare class FractGlNode extends FractGlNode_base {
}
declare const InverseSqrtGlNode_base: typeof BaseNodeGlMathFunctionArg1GlNode;
declare class InverseSqrtGlNode extends InverseSqrtGlNode_base {
}
declare const LogGlNode_base: typeof BaseNodeGlMathFunctionArg1GlNode;
declare class LogGlNode extends LogGlNode_base {
}
declare const Log2GlNode_base: typeof BaseNodeGlMathFunctionArg1GlNode;
declare class Log2GlNode extends Log2GlNode_base {
}
declare const NormalizeGlNode_base: typeof BaseNodeGlMathFunctionArg1GlNode;
declare class NormalizeGlNode extends NormalizeGlNode_base {
}
declare const RadiansGlNode_base: typeof BaseNodeGlMathFunctionArg1GlNode;
declare class RadiansGlNode extends RadiansGlNode_base {
}
declare const SignGlNode_base: typeof BaseNodeGlMathFunctionArg1GlNode;
declare class SignGlNode extends SignGlNode_base {
}
declare const SinGlNode_base: typeof BaseNodeGlMathFunctionArg1GlNode;
declare class SinGlNode extends SinGlNode_base {
}
declare const SqrtGlNode_base: typeof BaseNodeGlMathFunctionArg1GlNode;
declare class SqrtGlNode extends SqrtGlNode_base {
}
declare const TanGlNode_base: typeof BaseNodeGlMathFunctionArg1GlNode;
declare class TanGlNode extends TanGlNode_base {
}
declare const DistanceGlNode_base: typeof BaseNodeGlMathFunctionArg2GlNode;
declare class DistanceGlNode extends DistanceGlNode_base {
}
declare const DotGlNode_base: typeof BaseNodeGlMathFunctionArg2GlNode;
declare class DotGlNode extends DotGlNode_base {
}
declare const MaxGlNode_base: typeof BaseNodeGlMathFunctionArg2GlNode;
declare class MaxGlNode extends MaxGlNode_base {
}
declare const MinGlNode_base: typeof BaseNodeGlMathFunctionArg2GlNode;
declare class MinGlNode extends MinGlNode_base {
}
declare const ModGlNode_base: typeof BaseNodeGlMathFunctionArg2GlNode;
declare class ModGlNode extends ModGlNode_base {
	paramDefaultValue(name: string): number;
	_expected_input_types(): GlConnectionPointType[];
}
declare const PowGlNode_base: typeof BaseNodeGlMathFunctionArg2GlNode;
declare class PowGlNode extends PowGlNode_base {
}
declare const ReflectGlNode_base: typeof BaseNodeGlMathFunctionArg2GlNode;
declare class ReflectGlNode extends ReflectGlNode_base {
}
declare const StepGlNode_base: typeof BaseNodeGlMathFunctionArg2GlNode;
declare class StepGlNode extends StepGlNode_base {
}
declare const ClampGlNode_base: typeof BaseNodeGlMathFunctionArg3GlNode;
declare class ClampGlNode extends ClampGlNode_base {
	protected _expected_output_types(): GlConnectionPointType[];
}
declare const FaceforwardGlNode_base: typeof BaseNodeGlMathFunctionArg3GlNode;
declare class FaceforwardGlNode extends FaceforwardGlNode_base {
}
declare const SmoothstepGlNode_base: typeof BaseNodeGlMathFunctionArg3GlNode;
declare class SmoothstepGlNode extends SmoothstepGlNode_base {
	protected _expected_output_types(): GlConnectionPointType[];
}
declare const AddGlNode_base: typeof BaseNodeGlMathFunctionArg2GlNode;
declare class AddGlNode extends AddGlNode_base {
}
declare const DivideGlNode_base: typeof BaseNodeGlMathFunctionArg2GlNode;
declare class DivideGlNode extends DivideGlNode_base {
	paramDefaultValue(name: string): number;
}
declare const SubtractGlNode_base: typeof BaseNodeGlMathFunctionArg2GlNode;
declare class SubtractGlNode extends SubtractGlNode_base {
}
declare const MultGlNode_base: typeof BaseNodeGlMathFunctionArg2GlNode;
declare class MultGlNode extends MultGlNode_base {
	static type(): string;
	paramDefaultValue(name: string): number;
	initializeNode(): void;
	protected _expected_output_type(): GlConnectionPointType[];
	protected _expected_input_types(): GlConnectionPointType[];
}
declare abstract class BaseNodeGlMathFunctionArgBoolean2GlNode extends BaseNodeGlMathFunctionArg2GlNode {
	initializeNode(): void;
	protected _expected_input_types(): GlConnectionPointType[];
	protected _expected_output_types(): GlConnectionPointType[];
	boolean_operation(): string;
	setLines(shaders_collection_controller: ShadersCollectionController): void;
}
declare const AndGlNode_base: typeof BaseNodeGlMathFunctionArgBoolean2GlNode;
declare class AndGlNode extends AndGlNode_base {
}
declare const OrGlNode_base: typeof BaseNodeGlMathFunctionArgBoolean2GlNode;
declare class OrGlNode extends OrGlNode_base {
}
declare enum AccelerationGlInput {
	POSITION = "position",
	VELOCITY = "velocity",
	MASS = "mass",
	FORCE = "force"
}
declare enum AccelerationGlOutput {
	POSITION = "position",
	VELOCITY = "velocity"
}
declare class AccelerationGlParamsConfig extends NodeParamsConfig {
}
declare class AccelerationGlNode extends TypedGlNode<AccelerationGlParamsConfig> {
	paramsConfig: AccelerationGlParamsConfig;
	static type(): string;
	initializeNode(): void;
	protected _expected_input_types(): GlConnectionPointType[];
	private _expected_output_types;
	protected _gl_input_name(index: number): AccelerationGlInput;
	protected _gl_output_name(index: number): AccelerationGlOutput;
	paramDefaultValue(name: string): number | Number3;
	setLines(shaders_collection_controller: ShadersCollectionController): void;
}
declare class AdjacentPointsAttribSmoothGlParamsConfig extends NodeParamsConfig {
	positionAttribName: ParamTemplate<ParamType.STRING>;
	position: ParamTemplate<ParamType.VECTOR3>;
	textureSize: ParamTemplate<ParamType.VECTOR2>;
	adjacencyCount: ParamTemplate<ParamType.FLOAT>;
	adjacencyBaseName: ParamTemplate<ParamType.STRING>;
	attribName: ParamTemplate<ParamType.STRING>;
	attribValue: ParamTemplate<ParamType.FLOAT>;
	deltaThreshold: ParamTemplate<ParamType.FLOAT>;
	smoothAmount: ParamTemplate<ParamType.FLOAT>;
}
declare class AdjacentPointsAttribSmoothGlNode extends TypedGlNode<AdjacentPointsAttribSmoothGlParamsConfig> {
	paramsConfig: AdjacentPointsAttribSmoothGlParamsConfig;
	static type(): GlType;
	initializeNode(): void;
	glType(): GlConnectionPointType;
	attributeName(): string;
	setLines(linesController: ShadersCollectionController): void;
	textureAllocationData(): string[];
	private _templateFunctionDefinition;
}
declare class AdjacentUvAttribSmoothGlParamsConfig extends NodeParamsConfig {
	textureSize: ParamTemplate<ParamType.VECTOR2>;
	attribName: ParamTemplate<ParamType.STRING>;
	attribValue: ParamTemplate<ParamType.FLOAT>;
	deltaThreshold: ParamTemplate<ParamType.FLOAT>;
	smoothAmount: ParamTemplate<ParamType.FLOAT>;
}
declare class AdjacentUvAttribSmoothGlNode extends TypedGlNode<AdjacentUvAttribSmoothGlParamsConfig> {
	paramsConfig: AdjacentUvAttribSmoothGlParamsConfig;
	static type(): GlType;
	initializeNode(): void;
	glType(): GlConnectionPointType;
	attributeName(): string;
	setLines(linesController: ShadersCollectionController): void;
	private _templateFunctionDefinition;
}
declare class AlignGlNode extends BaseNodeGlMathFunctionArg2GlNode {
	static type(): string;
	initializeNode(): void;
	paramDefaultValue(name: string): Number3;
	gl_method_name(): string;
	gl_function_definitions(): FunctionGLDefinition[];
}
declare class CartesianToPolarGlParamsConfig extends NodeParamsConfig {
	xyz: ParamTemplate<ParamType.VECTOR3>;
}
declare class CartesianToPolarGlNode extends TypedGlNode<CartesianToPolarGlParamsConfig> {
	paramsConfig: CartesianToPolarGlParamsConfig;
	static type(): string;
	initializeNode(): void;
	setLines(shadersCollectionController: ShadersCollectionController): void;
}
declare class CheckersGlParamsConfig extends NodeParamsConfig {
	uv: ParamTemplate<ParamType.VECTOR2>;
	freq: ParamTemplate<ParamType.VECTOR2>;
	freqMult: ParamTemplate<ParamType.FLOAT>;
	filtered: ParamTemplate<ParamType.BOOLEAN>;
}
declare class CheckersGlNode extends TypedGlNode<CheckersGlParamsConfig> {
	paramsConfig: CheckersGlParamsConfig;
	static type(): string;
	initializeNode(): void;
	setLines(shadersCollectionController: ShadersCollectionController): void;
}
declare class ClothSolverPositionGlParamsConfig extends NodeParamsConfig {
	id: ParamTemplate<ParamType.FLOAT>;
	size: ParamTemplate<ParamType.STRING>;
	position0: ParamTemplate<ParamType.STRING>;
	position1: ParamTemplate<ParamType.STRING>;
	normal: ParamTemplate<ParamType.STRING>;
}
declare class ClothSolverPositionGlNode extends TypedGlNode<ClothSolverPositionGlParamsConfig> {
	paramsConfig: ClothSolverPositionGlParamsConfig;
	static type(): Readonly<"clothSolverPosition">;
	initializeNode(): void;
	setLines(shaders_collection_controller: ShadersCollectionController): void;
	paramsGenerating(): boolean;
	setParamConfigs(): void;
	uniformNameSize(): string;
	uniformNamePosition0(): string;
	uniformNamePosition1(): string;
	uniformNameNormal(): string;
}
declare class ClothSolverUvGlParamsConfig extends NodeParamsConfig {
	id: ParamTemplate<ParamType.FLOAT>;
	size: ParamTemplate<ParamType.STRING>;
}
declare class ClothSolverUvGlNode extends TypedGlNode<ClothSolverUvGlParamsConfig> {
	paramsConfig: ClothSolverUvGlParamsConfig;
	static type(): Readonly<"clothSolverUv">;
	initializeNode(): void;
	setLines(shaders_collection_controller: ShadersCollectionController): void;
	paramsGenerating(): boolean;
	setParamConfigs(): void;
	uniformNameSize(): string;
}
declare enum ColorCorrectType {
	LINEAR = "Linear",
	SRGB = "sRGB"
}
declare class ColorCorrectParamsConfig extends NodeParamsConfig {
	color: ParamTemplate<ParamType.VECTOR4>;
	from: ParamTemplate<ParamType.INTEGER>;
	to: ParamTemplate<ParamType.INTEGER>;
}
declare class ColorCorrectGlNode extends TypedGlNode<ColorCorrectParamsConfig> {
	paramsConfig: ColorCorrectParamsConfig;
	static type(): string;
	static INPUT_NAME: string;
	static OUTPUT_NAME: string;
	initializeNode(): void;
	colorSpaces(): {
		from: ColorCorrectType;
		to: ColorCorrectType;
	};
	setLines(shaders_collection_controller: ShadersCollectionController): void;
}
declare enum GlCompareTestName {
	EQUAL = "Equal",
	LESS_THAN = "Less Than",
	GREATER_THAN = "Greater Than",
	LESS_THAN_OR_EQUAL = "Less Than Or Equal",
	GREATER_THAN_OR_EQUAL = "Greater Than Or Equal",
	NOT_EQUAL = "Not Equal"
}
declare enum GlCompareTestOperation {
	EQUAL = "==",
	LESS_THAN = "<",
	GREATER_THAN = ">",
	LESS_THAN_OR_EQUAL = "<=",
	GREATER_THAN_OR_EQUAL = ">=",
	NOT_EQUAL = "!="
}
declare class CompareGlParamsConfig extends NodeParamsConfig {
	test: ParamTemplate<ParamType.INTEGER>;
}
declare class CompareGlNode extends TypedGlNode<CompareGlParamsConfig> {
	paramsConfig: CompareGlParamsConfig;
	static type(): string;
	initializeNode(): void;
	setTestName(test: GlCompareTestName): void;
	testName(): GlCompareTestName;
	operator(): GlCompareTestOperation;
	protected _gl_input_name(index: number): string;
	protected _expected_input_type(): GlConnectionPointType[];
	setLines(shaders_collection_controller: ShadersCollectionController): void;
}
declare class ComplementGlNode extends BaseNodeGlMathFunctionArg1GlNode {
	static type(): string;
	gl_method_name(): string;
	gl_function_definitions(): FunctionGLDefinition[];
}
declare class SubnetOutputGlParamsConfig extends NodeParamsConfig {
}
declare class SubnetOutputGlNode extends TypedGlNode<SubnetOutputGlParamsConfig> {
	paramsConfig: SubnetOutputGlParamsConfig;
	static type(): Readonly<NetworkChildNodeType.OUTPUT>;
	initializeNode(): void;
	parent(): SubnetGlNode | null;
	protected _expected_input_name(index: number): string;
	protected _expected_input_types(): GlConnectionPointType[];
	setLines(shadersCollectionController: ShadersCollectionController): never[];
}
declare class SubnetInputGlParamsConfig extends NodeParamsConfig {
}
declare class SubnetInputGlNode extends TypedGlNode<SubnetInputGlParamsConfig> {
	paramsConfig: SubnetInputGlParamsConfig;
	static type(): NetworkChildNodeType;
	initializeNode(): void;
	parent(): SubnetGlNode | null;
	private _expected_output_names;
	protected _expected_output_types(): GlConnectionPointType[];
	setLines(shaders_collection_controller: ShadersCollectionController): void;
}
declare const TypedSubnetGlParamsConfig_base: {
	new (...args: any[]): {
		inputs: ParamTemplate<ParamType.FOLDER>;
		inputsCount: ParamTemplate<ParamType.INTEGER>;
		inputType0: ParamTemplate<ParamType.INTEGER>;
		inputName0: ParamTemplate<ParamType.STRING>;
		inputType1: ParamTemplate<ParamType.INTEGER>;
		inputName1: ParamTemplate<ParamType.STRING>;
		inputType2: ParamTemplate<ParamType.INTEGER>;
		inputName2: ParamTemplate<ParamType.STRING>;
		inputType3: ParamTemplate<ParamType.INTEGER>;
		inputName3: ParamTemplate<ParamType.STRING>;
		inputType4: ParamTemplate<ParamType.INTEGER>;
		inputName4: ParamTemplate<ParamType.STRING>;
		inputType5: ParamTemplate<ParamType.INTEGER>;
		inputName5: ParamTemplate<ParamType.STRING>;
		inputType6: ParamTemplate<ParamType.INTEGER>;
		inputName6: ParamTemplate<ParamType.STRING>;
		inputType7: ParamTemplate<ParamType.INTEGER>;
		inputName7: ParamTemplate<ParamType.STRING>;
		inputType8: ParamTemplate<ParamType.INTEGER>;
		inputName8: ParamTemplate<ParamType.STRING>;
		inputType9: ParamTemplate<ParamType.INTEGER>;
		inputName9: ParamTemplate<ParamType.STRING>;
		spare: ParamTemplate<ParamType.FOLDER>;
	};
} & typeof NodeParamsConfig;
declare class TypedSubnetGlParamsConfig extends TypedSubnetGlParamsConfig_base {
}
declare class AbstractTypedSubnetGlNode<K extends NodeParamsConfig> extends TypedGlNode<K> {
	protected _childrenControllerContext: NodeContext;
	initializeNode(): void;
	protected _expectedInputTypes(): GlConnectionPointType[];
	protected _expectedInputName(index: number): string;
	protected _expectedOutputTypes(): GlConnectionPointType[];
	protected _expectedOutputName(index: number): string;
	childExpectedInputConnectionPointTypes(): GlConnectionPointType[];
	childExpectedOutputConnectionPointTypes(): GlConnectionPointType[];
	childExpectedInputConnectionPointName(index: number): string;
	childExpectedOutputConnectionPointName(index: number): string;
	createNode<S extends keyof GlNodeChildrenMap>(node_class: S, options?: NodeCreateOptions): GlNodeChildrenMap[S];
	createNode<K extends valueof<GlNodeChildrenMap>>(node_class: Constructor<K>, options?: NodeCreateOptions): K;
	children(): BaseGlNodeType[];
	nodesByType<K extends keyof GlNodeChildrenMap>(type: K): GlNodeChildrenMap[K][];
	protected _setLinesPreBlock(shadersCollectionController: ShadersCollectionController): void;
	protected setLinesBlockStart(shadersCollectionController: ShadersCollectionController): void;
	protected setLinesBlockEnd(shadersCollectionController: ShadersCollectionController): void;
	setSubnetInputLines(shadersCollectionController: ShadersCollectionController, childNode: SubnetInputGlNode): void;
	protected subnetOutputLines(childNode: SubnetOutputGlNode): string[];
	setSubnetOutputLines(shadersCollectionController: ShadersCollectionController, childNode: SubnetOutputGlNode): void;
	setLines(shadersCollectionController: ShadersCollectionController): void;
	protected linesBlockContent(shadersCollectionController: ShadersCollectionController): string[] | undefined;
	private _setLinesBlockContent;
	protected _runCodeBuilder(shadersCollectionController: ShadersCollectionController): CodeBuilder | undefined;
	private _addCodeBuilderDefinition;
	protected _sanitizeBodyLines(lines: string[]): string[];
}
declare class TypedSubnetGlNode<K extends TypedSubnetGlParamsConfig> extends AbstractTypedSubnetGlNode<K> {
	initializeNode(): void;
	protected _inputTypeParams(): IntegerParam[];
	protected _inputNameParams(): StringParam[];
	setInputType(index: number, type: GlConnectionPointType): void;
	setInputName(index: number, inputName: string): void;
	protected _expectedInputsCount(): number;
	protected _expectedInputTypes(): GlConnectionPointType[];
	protected _expectedInputName(index: number): string;
	protected _expectedOutputTypes(): GlConnectionPointType[];
	protected _expectedOutputName(index: number): string;
}
declare const SubnetGlParamsConfig_base: {
	new (...args: any[]): {
		inputs: ParamTemplate<ParamType.FOLDER>;
		inputsCount: ParamTemplate<ParamType.INTEGER>;
		inputType0: ParamTemplate<ParamType.INTEGER>;
		inputName0: ParamTemplate<ParamType.STRING>;
		inputType1: ParamTemplate<ParamType.INTEGER>;
		inputName1: ParamTemplate<ParamType.STRING>;
		inputType2: ParamTemplate<ParamType.INTEGER>;
		inputName2: ParamTemplate<ParamType.STRING>;
		inputType3: ParamTemplate<ParamType.INTEGER>;
		inputName3: ParamTemplate<ParamType.STRING>;
		inputType4: ParamTemplate<ParamType.INTEGER>;
		inputName4: ParamTemplate<ParamType.STRING>;
		inputType5: ParamTemplate<ParamType.INTEGER>;
		inputName5: ParamTemplate<ParamType.STRING>;
		inputType6: ParamTemplate<ParamType.INTEGER>;
		inputName6: ParamTemplate<ParamType.STRING>;
		inputType7: ParamTemplate<ParamType.INTEGER>;
		inputName7: ParamTemplate<ParamType.STRING>;
		inputType8: ParamTemplate<ParamType.INTEGER>;
		inputName8: ParamTemplate<ParamType.STRING>;
		inputType9: ParamTemplate<ParamType.INTEGER>;
		inputName9: ParamTemplate<ParamType.STRING>;
		spare: ParamTemplate<ParamType.FOLDER>;
	};
} & typeof NodeParamsConfig;
declare class SubnetGlParamsConfig extends SubnetGlParamsConfig_base {
}
declare class SubnetGlNode extends TypedSubnetGlNode<SubnetGlParamsConfig> {
	paramsConfig: SubnetGlParamsConfig;
	static type(): NetworkNodeType;
}
declare enum ComputeNormalsInput {
	P = "P",
	N = "N",
	TEXTURE_SIZE = "textureSize",
	UV = "adjacencyUv",
	ID = "adjacencyId"
}
declare enum VariablesLookupMode {
	CURRENT_POINT = "currentPoint",
	ADJACENT_POINT = "adjacentPoint"
}
declare const ComputeNormalsGlParamsConfig_base: {
	new (...args: any[]): {
		inputs: ParamTemplate<ParamType.FOLDER>;
		inputsCount: ParamTemplate<ParamType.INTEGER>;
		inputType0: ParamTemplate<ParamType.INTEGER>;
		inputName0: ParamTemplate<ParamType.STRING>;
		inputType1: ParamTemplate<ParamType.INTEGER>;
		inputName1: ParamTemplate<ParamType.STRING>;
		inputType2: ParamTemplate<ParamType.INTEGER>;
		inputName2: ParamTemplate<ParamType.STRING>;
		inputType3: ParamTemplate<ParamType.INTEGER>;
		inputName3: ParamTemplate<ParamType.STRING>;
		inputType4: ParamTemplate<ParamType.INTEGER>;
		inputName4: ParamTemplate<ParamType.STRING>;
		inputType5: ParamTemplate<ParamType.INTEGER>;
		inputName5: ParamTemplate<ParamType.STRING>;
		inputType6: ParamTemplate<ParamType.INTEGER>;
		inputName6: ParamTemplate<ParamType.STRING>;
		inputType7: ParamTemplate<ParamType.INTEGER>;
		inputName7: ParamTemplate<ParamType.STRING>;
		inputType8: ParamTemplate<ParamType.INTEGER>;
		inputName8: ParamTemplate<ParamType.STRING>;
		inputType9: ParamTemplate<ParamType.INTEGER>;
		inputName9: ParamTemplate<ParamType.STRING>;
		spare: ParamTemplate<ParamType.FOLDER>;
	};
} & typeof NodeParamsConfig;
declare class ComputeNormalsGlParamsConfig extends ComputeNormalsGlParamsConfig_base {
	adjacencyCount: ParamTemplate<ParamType.FLOAT>;
	adjacencyBaseName: ParamTemplate<ParamType.STRING>;
}
declare class ComputeNormalsGlNode extends TypedSubnetGlNode<ComputeNormalsGlParamsConfig> {
	paramsConfig: ComputeNormalsGlParamsConfig;
	static type(): GlType;
	protected _expectedOutputTypes(): GlConnectionPointType[];
	protected _expectedInputTypes(): GlConnectionPointType[];
	protected _expectedOutputName(index: number): ComputeNormalsInput;
	protected _expectedInputName(index: number): ComputeNormalsInput;
	childExpectedInputConnectionPointTypes(): GlConnectionPointType[];
	childExpectedInputConnectionPointName(index: number): ComputeNormalsInput;
	childExpectedOutputConnectionPointTypes(): GlConnectionPointType[];
	childExpectedOutputConnectionPointName(index: number): string;
	_variableLookupMode: VariablesLookupMode;
	protected _glVarNameBase(): string;
	private _withCurrentPoint;
	private _adjacencyLookupId;
	private _adjacencyLookupUv;
	protected setLinesBlockStart(linesController: ShadersCollectionController): void;
	protected setLinesBlockEnd(shadersCollectionController: ShadersCollectionController): void;
	setSubnetInputLines(linesController: ShadersCollectionController, childNode: SubnetInputGlNode): void;
}
declare class ConstantGlParamsConfig extends NodeParamsConfig {
	type: ParamTemplate<ParamType.INTEGER>;
	bool: ParamTemplate<ParamType.BOOLEAN>;
	int: ParamTemplate<ParamType.INTEGER>;
	float: ParamTemplate<ParamType.FLOAT>;
	vec2: ParamTemplate<ParamType.VECTOR2>;
	vec3: ParamTemplate<ParamType.VECTOR3>;
	color: ParamTemplate<ParamType.COLOR>;
	vec4: ParamTemplate<ParamType.VECTOR4>;
	/** @param when using vec3, use toggle on it should be a color */
	asColor: ParamTemplate<ParamType.BOOLEAN>;
}
declare class ConstantGlNode extends TypedGlNode<ConstantGlParamsConfig> {
	paramsConfig: ConstantGlParamsConfig;
	static type(): GlType;
	static readonly OUTPUT_NAME = "val";
	initializeNode(): void;
	setLines(shaders_collection_controller: ShadersCollectionController): void;
	private _currentConnectionType;
	currentParam(): BaseParamType;
	private _currentVarName;
	currentValue(): string | undefined;
	setGlType(type: GlConnectionPointType): void;
}
declare class CrossGlParamsConfig extends NodeParamsConfig {
	x: ParamTemplate<ParamType.VECTOR3>;
	y: ParamTemplate<ParamType.VECTOR3>;
}
declare class CrossGlNode extends TypedGlNode<CrossGlParamsConfig> {
	paramsConfig: CrossGlParamsConfig;
	static type(): string;
	initializeNode(): void;
	setLines(shaders_collection_controller: ShadersCollectionController): void;
}
declare const CycleGlNode_base: typeof BaseNodeGlMathFunctionArg3GlNode;
declare class CycleGlNode extends CycleGlNode_base {
}
declare class DiskGlParamsConfig extends NodeParamsConfig {
	position: ParamTemplate<ParamType.VECTOR2>;
	center: ParamTemplate<ParamType.VECTOR2>;
	radius: ParamTemplate<ParamType.FLOAT>;
	feather: ParamTemplate<ParamType.FLOAT>;
}
declare class DiskGlNode extends TypedGlNode<DiskGlParamsConfig> {
	paramsConfig: DiskGlParamsConfig;
	static type(): string;
	initializeNode(): void;
	setLines(shaders_collection_controller: ShadersCollectionController): void;
}
declare class DitherGlParamsConfig extends NodeParamsConfig {
	alpha: ParamTemplate<ParamType.FLOAT>;
	alphaTest: ParamTemplate<ParamType.FLOAT>;
}
declare class DitherGlNode extends TypedGlNode<DitherGlParamsConfig> {
	paramsConfig: DitherGlParamsConfig;
	static type(): string;
	initializeNode(): void;
	setLines(shadersCollectionController: ShadersCollectionController): void;
}
declare class EasingGlParamsConfig extends NodeParamsConfig {
	type: ParamTemplate<ParamType.INTEGER>;
}
declare class EasingGlNode extends TypedGlNode<EasingGlParamsConfig> {
	paramsConfig: EasingGlParamsConfig;
	static type(): string;
	initializeNode(): void;
	private _expected_input_types;
	private _expected_output_types;
	_gl_input_name(index: number): string;
	_gl_output_name(index: number): string;
	setLines(shaders_collection_controller: ShadersCollectionController): void;
	private _buildBodyLines;
}
declare class FitGlNode extends BaseNodeGlMathFunctionArg5GlNode {
	static type(): string;
	protected _gl_input_name(index: number): string;
	paramDefaultValue(name: string): number;
	protected gl_method_name(): string;
	gl_function_definitions(): FunctionGLDefinition[];
}
declare class FitTo01GlNode extends BaseNodeGlMathFunctionArg3GlNode {
	static type(): string;
	_gl_input_name(index: number): string;
	paramDefaultValue(name: string): number;
	gl_method_name(): string;
	gl_function_definitions(): FunctionGLDefinition[];
}
declare class FitFrom01GlNode extends BaseNodeGlMathFunctionArg3GlNode {
	static type(): string;
	_gl_input_name(index: number): string;
	paramDefaultValue(name: string): number;
	gl_method_name(): string;
	gl_function_definitions(): FunctionGLDefinition[];
}
declare class FitFrom01ToVarianceGlNode extends BaseNodeGlMathFunctionArg3GlNode {
	static type(): string;
	_gl_input_name(index: number): string;
	paramDefaultValue(name: string): number;
	gl_method_name(): string;
	gl_function_definitions(): FunctionGLDefinition[];
}
declare class FogGlParamsConfig extends NodeParamsConfig {
	mvPosition: ParamTemplate<ParamType.VECTOR4>;
	baseColor: ParamTemplate<ParamType.COLOR>;
	fogColor: ParamTemplate<ParamType.COLOR>;
	near: ParamTemplate<ParamType.FLOAT>;
	far: ParamTemplate<ParamType.FLOAT>;
}
declare class FogGlNode extends TypedGlNode<FogGlParamsConfig> {
	paramsConfig: FogGlParamsConfig;
	static type(): string;
	initializeNode(): void;
	setLines(shaders_collection_controller: ShadersCollectionController): void;
}
declare const ForLoopGlParamsConfig_base: {
	new (...args: any[]): {
		inputs: ParamTemplate<ParamType.FOLDER>;
		inputsCount: ParamTemplate<ParamType.INTEGER>;
		inputType0: ParamTemplate<ParamType.INTEGER>;
		inputName0: ParamTemplate<ParamType.STRING>;
		inputType1: ParamTemplate<ParamType.INTEGER>;
		inputName1: ParamTemplate<ParamType.STRING>;
		inputType2: ParamTemplate<ParamType.INTEGER>;
		inputName2: ParamTemplate<ParamType.STRING>;
		inputType3: ParamTemplate<ParamType.INTEGER>;
		inputName3: ParamTemplate<ParamType.STRING>;
		inputType4: ParamTemplate<ParamType.INTEGER>;
		inputName4: ParamTemplate<ParamType.STRING>;
		inputType5: ParamTemplate<ParamType.INTEGER>;
		inputName5: ParamTemplate<ParamType.STRING>;
		inputType6: ParamTemplate<ParamType.INTEGER>;
		inputName6: ParamTemplate<ParamType.STRING>;
		inputType7: ParamTemplate<ParamType.INTEGER>;
		inputName7: ParamTemplate<ParamType.STRING>;
		inputType8: ParamTemplate<ParamType.INTEGER>;
		inputName8: ParamTemplate<ParamType.STRING>;
		inputType9: ParamTemplate<ParamType.INTEGER>;
		inputName9: ParamTemplate<ParamType.STRING>;
		spare: ParamTemplate<ParamType.FOLDER>;
	};
} & typeof NodeParamsConfig;
declare class ForLoopGlParamsConfig extends ForLoopGlParamsConfig_base {
	start: ParamTemplate<ParamType.FLOAT>;
	max: ParamTemplate<ParamType.FLOAT>;
	step: ParamTemplate<ParamType.FLOAT>;
	asFloat: ParamTemplate<ParamType.BOOLEAN>;
}
declare class ForLoopGlNode extends TypedSubnetGlNode<ForLoopGlParamsConfig> {
	paramsConfig: ForLoopGlParamsConfig;
	static type(): GlType;
	paramDefaultValue(name: string): number;
	childExpectedInputConnectionPointTypes(): GlConnectionPointType[];
	childExpectedInputConnectionPointName(index: number): string;
	protected setLinesBlockStart(shaders_collection_controller: ShadersCollectionController): void;
	setSubnetInputLines(shadersCollectionController: ShadersCollectionController, childNode: SubnetInputGlNode): void;
	private _typesData;
}
declare class FresnelGlParamsConfig extends NodeParamsConfig {
	worldPosition: ParamTemplate<ParamType.VECTOR4>;
	worldNormal: ParamTemplate<ParamType.VECTOR3>;
	cameraPosition: ParamTemplate<ParamType.VECTOR3>;
}
declare class FresnelGlNode extends TypedGlNode<FresnelGlParamsConfig> {
	paramsConfig: FresnelGlParamsConfig;
	static type(): string;
	initializeNode(): void;
	setLines(shadersCollectionController: ShadersCollectionController): void;
	private _varFromParam;
	private _getGlobalVar;
}
declare class GeometryAttributeLookupUvGlParamsConfig extends NodeParamsConfig {
	id: ParamTemplate<ParamType.FLOAT>;
	textureSize: ParamTemplate<ParamType.VECTOR2>;
}
declare class GeometryAttributeLookupUvGlNode extends TypedGlNode<GeometryAttributeLookupUvGlParamsConfig> {
	paramsConfig: GeometryAttributeLookupUvGlParamsConfig;
	static type(): string;
	initializeNode(): void;
	setLines(shadersCollectionController: ShadersCollectionController): void;
}
declare class GridGlParamsConfig extends NodeParamsConfig {
	uv: ParamTemplate<ParamType.VECTOR2>;
	lineWidth: ParamTemplate<ParamType.FLOAT>;
	freq: ParamTemplate<ParamType.VECTOR2>;
	freqMult: ParamTemplate<ParamType.FLOAT>;
	filtered: ParamTemplate<ParamType.BOOLEAN>;
}
declare class GridGlNode extends TypedGlNode<GridGlParamsConfig> {
	paramsConfig: GridGlParamsConfig;
	static type(): string;
	initializeNode(): void;
	setLines(shadersCollectionController: ShadersCollectionController): void;
}
declare class LabToRgbGlParamsConfig extends NodeParamsConfig {
	hsluv: ParamTemplate<ParamType.VECTOR3>;
}
declare class HsluvToRgbGlNode extends TypedGlNode<LabToRgbGlParamsConfig> {
	paramsConfig: LabToRgbGlParamsConfig;
	static type(): string;
	initializeNode(): void;
	setLines(shaders_collection_controller: ShadersCollectionController): void;
}
declare class HsvToRgbGlParamsConfig extends NodeParamsConfig {
	hsv: ParamTemplate<ParamType.VECTOR3>;
}
declare class HsvToRgbGlNode extends TypedGlNode<HsvToRgbGlParamsConfig> {
	paramsConfig: HsvToRgbGlParamsConfig;
	static type(): string;
	initializeNode(): void;
	setLines(shaders_collection_controller: ShadersCollectionController): void;
}
declare const IfThenGlParamsConfig_base: {
	new (...args: any[]): {
		inputs: ParamTemplate<ParamType.FOLDER>;
		inputsCount: ParamTemplate<ParamType.INTEGER>;
		inputType0: ParamTemplate<ParamType.INTEGER>;
		inputName0: ParamTemplate<ParamType.STRING>;
		inputType1: ParamTemplate<ParamType.INTEGER>;
		inputName1: ParamTemplate<ParamType.STRING>;
		inputType2: ParamTemplate<ParamType.INTEGER>;
		inputName2: ParamTemplate<ParamType.STRING>;
		inputType3: ParamTemplate<ParamType.INTEGER>;
		inputName3: ParamTemplate<ParamType.STRING>;
		inputType4: ParamTemplate<ParamType.INTEGER>;
		inputName4: ParamTemplate<ParamType.STRING>;
		inputType5: ParamTemplate<ParamType.INTEGER>;
		inputName5: ParamTemplate<ParamType.STRING>;
		inputType6: ParamTemplate<ParamType.INTEGER>;
		inputName6: ParamTemplate<ParamType.STRING>;
		inputType7: ParamTemplate<ParamType.INTEGER>;
		inputName7: ParamTemplate<ParamType.STRING>;
		inputType8: ParamTemplate<ParamType.INTEGER>;
		inputName8: ParamTemplate<ParamType.STRING>;
		inputType9: ParamTemplate<ParamType.INTEGER>;
		inputName9: ParamTemplate<ParamType.STRING>;
		spare: ParamTemplate<ParamType.FOLDER>;
	};
} & typeof NodeParamsConfig;
declare class IfThenGlParamsConfig extends IfThenGlParamsConfig_base {
}
declare class IfThenGlNode extends TypedSubnetGlNode<IfThenGlParamsConfig> {
	paramsConfig: IfThenGlParamsConfig;
	static type(): Readonly<GlType.IF_THEN>;
	protected _expectedInputTypes(): GlConnectionPointType[];
	protected _expectedInputName(index: number): string;
	childExpectedInputConnectionPointTypes(): GlConnectionPointType[];
	childExpectedInputConnectionPointName(index: number): string;
	protected _setLinesPreBlock(shadersCollectionController: ShadersCollectionController): void;
	setSubnetInputLines(shadersCollectionController: ShadersCollectionController, childNode: SubnetInputGlNode): void;
	protected setLinesBlockStart(shaders_collection_controller: ShadersCollectionController): void;
}
declare class InRangeGlParamsConfig extends NodeParamsConfig {
}
declare class InRangeGlNode extends TypedGlNode<InRangeGlParamsConfig> {
	paramsConfig: InRangeGlParamsConfig;
	static type(): string;
	static OUTPUT: string;
	static INPUT: string;
	static INPUT_MIN: string;
	static INPUT_MAX: string;
	initializeNode(): void;
	private _expected_input_types;
	setLines(shadersCollectionController: ShadersCollectionController): void;
}
declare class IsInfOrNanGlParamsConfig extends NodeParamsConfig {
	testIsInf: ParamTemplate<ParamType.BOOLEAN>;
	testIsNan: ParamTemplate<ParamType.BOOLEAN>;
}
declare class IsInfOrNanGlNode extends TypedGlNode<IsInfOrNanGlParamsConfig> {
	paramsConfig: IsInfOrNanGlParamsConfig;
	static type(): string;
	static OUTPUT: string;
	static INPUT: string;
	initializeNode(): void;
	private _expected_input_types;
	setLines(shadersCollectionController: ShadersCollectionController): void;
	private _functionCalls;
}
declare class ImpostorUvGlParamsConfig extends NodeParamsConfig {
	center: ParamTemplate<ParamType.VECTOR3>;
	cameraPos: ParamTemplate<ParamType.VECTOR3>;
	uv: ParamTemplate<ParamType.VECTOR2>;
	tilesCount: ParamTemplate<ParamType.INTEGER>;
	offset: ParamTemplate<ParamType.FLOAT>;
}
declare class ImpostorUvGlNode extends TypedGlNode<ImpostorUvGlParamsConfig> {
	paramsConfig: ImpostorUvGlParamsConfig;
	static type(): string;
	initializeNode(): void;
	setLines(shaders_collection_controller: ShadersCollectionController): void;
}
declare class InstanceTransformGlParamsConfig extends NodeParamsConfig {
	position: ParamTemplate<ParamType.VECTOR3>;
	normal: ParamTemplate<ParamType.VECTOR3>;
	instancePosition: ParamTemplate<ParamType.VECTOR3>;
	instanceQuaternion: ParamTemplate<ParamType.VECTOR4>;
	instanceScale: ParamTemplate<ParamType.VECTOR3>;
}
declare class InstanceTransformGlNode extends TypedGlNode<InstanceTransformGlParamsConfig> {
	paramsConfig: InstanceTransformGlParamsConfig;
	static type(): string;
	initializeNode(): void;
	setLines(shaders_collection_controller: ShadersCollectionController): void;
	gl_output_name_position(): string;
	gl_output_name_normal(): string;
	private _defaultPosition;
	private _defaultNormal;
	private _defaultInstancePosition;
	private _defaultInputInstanceQuaternion;
	private _defaultInputInstanceScale;
}
declare class InverseTransformDirectionGlParamsConfig extends NodeParamsConfig {
	normal: ParamTemplate<ParamType.VECTOR3>;
}
declare class InverseTransformDirectionGlNode extends TypedGlNode<InverseTransformDirectionGlParamsConfig> {
	paramsConfig: InverseTransformDirectionGlParamsConfig;
	static type(): Readonly<"inverseTransformDirection">;
	initializeNode(): void;
	setLines(linesController: ShadersCollectionController): void;
}
declare class LengthGlNode extends BaseNodeGlMathFunctionArg1GlNode {
	static type(): string;
	initializeNode(): void;
	protected _gl_input_name(index: number): string;
	gl_method_name(): string;
	protected _expected_output_types(): GlConnectionPointType[];
}
declare class LuminanceGlParamsConfig extends NodeParamsConfig {
	color: ParamTemplate<ParamType.VECTOR3>;
}
declare class LuminanceGlNode extends TypedGlNode<LuminanceGlParamsConfig> {
	paramsConfig: LuminanceGlParamsConfig;
	static type(): string;
	initializeNode(): void;
	setLines(shadersCollectionController: ShadersCollectionController): void;
}
declare class MaxLengthGlNode extends BaseNodeGlMathFunctionArg2GlNode {
	static type(): string;
	protected _expected_input_types(): GlConnectionPointType[];
	protected _gl_input_name(index: number): string;
	paramDefaultValue(name: string): number;
	protected gl_method_name(): string;
	gl_function_definitions(): FunctionGLDefinition[];
}
declare class MixGlNode extends BaseGlMathFunctionGlNode {
	static type(): string;
	protected gl_method_name(): string;
	paramDefaultValue(name: string): number;
	initializeNode(): void;
	protected _gl_output_name(): string;
	protected _expected_input_types(): GlConnectionPointType[];
	protected _expected_output_types(): GlConnectionPointType[];
}
declare class ModelMatrixMultGlParamsConfig extends NodeParamsConfig {
	vector: ParamTemplate<ParamType.VECTOR3>;
}
declare class ModelMatrixMultGlNode extends TypedGlNode<ModelMatrixMultGlParamsConfig> {
	paramsConfig: ModelMatrixMultGlParamsConfig;
	static type(): Readonly<"modelMatrixMult">;
	initializeNode(): void;
	setLines(linesController: ShadersCollectionController): void;
}
declare class ModelViewMatrixMultGlParamsConfig extends NodeParamsConfig {
	vector: ParamTemplate<ParamType.VECTOR3>;
}
declare class ModelViewMatrixMultGlNode extends TypedGlNode<ModelViewMatrixMultGlParamsConfig> {
	paramsConfig: ModelViewMatrixMultGlParamsConfig;
	static type(): Readonly<"modelViewMatrixMult">;
	initializeNode(): void;
	setLines(linesController: ShadersCollectionController): void;
}
declare enum MultAddGlNodeInputName {
	VALUE = "value",
	PRE_ADD = "preAdd",
	MULT = "mult",
	POST_ADD = "postAdd"
}
declare class MultAddGlNode extends BaseNodeGlMathFunctionArg4GlNode {
	static type(): string;
	protected _gl_input_name(index: number): MultAddGlNodeInputName;
	paramDefaultValue(name: string): number;
	setLines(shaders_collection_controller: ShadersCollectionController): void;
}
declare enum MultScalarGlNodeInputName {
	VALUE = "value",
	MULT = "mult"
}
declare class MultScalarGlNode extends BaseNodeGlMathFunctionArg2GlNode {
	static type(): string;
	protected _expected_input_types(): GlConnectionPointType[];
	protected _gl_input_name(index: number): MultScalarGlNodeInputName;
	paramDefaultValue(name: string): number;
	setLines(shaders_collection_controller: ShadersCollectionController): void;
}
declare class MultVectorMatrixGlParamsConfig extends NodeParamsConfig {
}
declare class MultVectorMatrixGlNode extends TypedGlNode<MultVectorMatrixGlParamsConfig> {
	paramsConfig: MultVectorMatrixGlParamsConfig;
	static type(): Readonly<"multVectorMatrix">;
	initializeNode(): void;
	protected _expectedInputTypes(): GlConnectionPointType[];
	protected _expectedOutputTypes(): GlConnectionPointType[];
	_glInputName(index: number): string;
	_glOutputName(index: number): string;
	setLines(linesController: ShadersCollectionController): void;
}
declare class NegateGlNode extends BaseNodeGlMathFunctionArg1GlNode {
	static type(): string;
	initializeNode(): void;
	protected _gl_input_name(index: number): string;
	setLines(shaders_collection_controller: ShadersCollectionController): void;
}
declare class NeighbourAttractGlParamsConfig extends NodeParamsConfig {
	positionAttribName: ParamTemplate<ParamType.STRING>;
	position: ParamTemplate<ParamType.VECTOR3>;
	amount: ParamTemplate<ParamType.FLOAT>;
	startDist: ParamTemplate<ParamType.FLOAT>;
	midDist: ParamTemplate<ParamType.FLOAT>;
	endDist: ParamTemplate<ParamType.FLOAT>;
}
declare class NeighbourAttractGlNode extends TypedGlNode<NeighbourAttractGlParamsConfig> {
	paramsConfig: NeighbourAttractGlParamsConfig;
	static type(): string;
	initializeNode(): void;
	setLines(shadersCollectionController: ShadersCollectionController): void;
	private _templateFunctionDefinition;
}
declare class NeighbourAttractRepulseParamsConfig extends NodeParamsConfig {
	positionAttribName: ParamTemplate<ParamType.STRING>;
	position: ParamTemplate<ParamType.VECTOR3>;
	repulse: ParamTemplate<ParamType.BOOLEAN>;
	repulseAmount: ParamTemplate<ParamType.FLOAT>;
	repulseMinDist: ParamTemplate<ParamType.FLOAT>;
	repulseMaxDist: ParamTemplate<ParamType.FLOAT>;
	attract: ParamTemplate<ParamType.BOOLEAN>;
	attractAmount: ParamTemplate<ParamType.FLOAT>;
	attractStartDist: ParamTemplate<ParamType.FLOAT>;
	attractMidDist: ParamTemplate<ParamType.FLOAT>;
	attractEndDist: ParamTemplate<ParamType.FLOAT>;
}
declare class NeighbourAttractRepulseGlNode extends TypedGlNode<NeighbourAttractRepulseParamsConfig> {
	paramsConfig: NeighbourAttractRepulseParamsConfig;
	static type(): string;
	initializeNode(): void;
	setLines(shadersCollectionController: ShadersCollectionController): void;
	private _templateFlocking;
}
declare class NeighbourAttribSmoothGlParamsConfig extends NodeParamsConfig {
	positionAttribName: ParamTemplate<ParamType.STRING>;
	position: ParamTemplate<ParamType.VECTOR3>;
	attribName: ParamTemplate<ParamType.STRING>;
	attribValue: ParamTemplate<ParamType.FLOAT>;
	maxDist: ParamTemplate<ParamType.FLOAT>;
	deltaThreshold: ParamTemplate<ParamType.FLOAT>;
	smoothAmount: ParamTemplate<ParamType.FLOAT>;
}
declare class NeighbourAttribSmoothGlNode extends TypedGlNode<NeighbourAttribSmoothGlParamsConfig> {
	paramsConfig: NeighbourAttribSmoothGlParamsConfig;
	static type(): string;
	initializeNode(): void;
	setLines(shadersCollectionController: ShadersCollectionController): void;
	private _templateFunctionDefinition;
}
declare class NeighbourDensityGlParamsConfig extends NodeParamsConfig {
	positionAttribName: ParamTemplate<ParamType.STRING>;
	position: ParamTemplate<ParamType.VECTOR3>;
	maxDist: ParamTemplate<ParamType.FLOAT>;
}
declare class NeighbourDensityGlNode extends TypedGlNode<NeighbourDensityGlParamsConfig> {
	paramsConfig: NeighbourDensityGlParamsConfig;
	static type(): string;
	initializeNode(): void;
	setLines(shadersCollectionController: ShadersCollectionController): void;
	private _templateFunctionDefinition;
}
declare class NeighbourRepulseGlParamsConfig extends NodeParamsConfig {
	positionAttribName: ParamTemplate<ParamType.STRING>;
	position: ParamTemplate<ParamType.VECTOR3>;
	amount: ParamTemplate<ParamType.FLOAT>;
	minDist: ParamTemplate<ParamType.FLOAT>;
	maxDist: ParamTemplate<ParamType.FLOAT>;
}
declare class NeighbourRepulseGlNode extends TypedGlNode<NeighbourRepulseGlParamsConfig> {
	paramsConfig: NeighbourRepulseGlParamsConfig;
	static type(): string;
	initializeNode(): void;
	setLines(shadersCollectionController: ShadersCollectionController): void;
	private _templateFunctionDefinition;
}
declare enum NoiseName {
	CLASSIC_PERLIN_2D = "Classic Perlin 2D",
	CLASSIC_PERLIN_3D = "Classic Perlin 3D",
	CLASSIC_PERLIN_4D = "Classic Perlin 4D",
	NOISE_2D = "noise2D",
	NOISE_3D = "noise3D",
	NOISE_4D = "noise4D"
}
declare enum NoiseOutputType {
	NoChange = 0,
	Float = 1,
	Vec2 = 2,
	Vec3 = 3,
	Vec4 = 4
}
declare enum NoiseGlNodeInputName {
	AMP = "amp",
	POSITION = "position",
	FREQ = "freq",
	OFFSET = "offset"
}
declare class NoiseGlParamsConfig extends NodeParamsConfig {
	type: ParamTemplate<ParamType.INTEGER>;
	outputType: ParamTemplate<ParamType.INTEGER>;
	octaves: ParamTemplate<ParamType.INTEGER>;
	ampAttenuation: ParamTemplate<ParamType.FLOAT>;
	freqIncrease: ParamTemplate<ParamType.FLOAT>;
}
declare class NoiseGlNode extends TypedGlNode<NoiseGlParamsConfig> {
	paramsConfig: NoiseGlParamsConfig;
	static type(): GlType;
	initializeNode(): void;
	setNoiseName(noiseName: NoiseName): void;
	setOutputType(outputType: NoiseOutputType): void;
	protected _gl_input_name(index: number): NoiseGlNodeInputName;
	paramDefaultValue(name: string): number;
	private _expected_input_types;
	private _expected_output_types;
	setLines(shaders_collection_controller: ShadersCollectionController): void;
	private fbmMethodName;
	private fbmFunction;
	private singleNoiseLine;
}
declare class NormalToWorldGlParamsConfig extends NodeParamsConfig {
	normal: ParamTemplate<ParamType.VECTOR3>;
}
declare class NormalToWorldGlNode extends TypedGlNode<NormalToWorldGlParamsConfig> {
	paramsConfig: NormalToWorldGlParamsConfig;
	static type(): Readonly<"normalToWorld">;
	initializeNode(): void;
	setLines(linesController: ShadersCollectionController): void;
}
declare class NullGlNode extends BaseNodeGlMathFunctionArg1GlNode {
	static type(): string;
	setLines(shaders_collection_controller: ShadersCollectionController): void;
}
declare class ParamGlParamsConfig extends NodeParamsConfig {
	name: ParamTemplate<ParamType.STRING>;
	type: ParamTemplate<ParamType.INTEGER>;
	asColor: ParamTemplate<ParamType.BOOLEAN>;
}
declare class ParamGlNode extends TypedGlNode<ParamGlParamsConfig> {
	paramsConfig: ParamGlParamsConfig;
	static type(): Readonly<GlType.PARAM>;
	initializeNode(): void;
	setLines(shadersCollectionController: ShadersCollectionController): void;
	paramsGenerating(): boolean;
	setParamConfigs(): void;
	uniformName(): string;
	setGlType(type: GlConnectionPointType): void;
	glType(): GlConnectionPointType;
}
declare class PositionToWorldGlParamsConfig extends NodeParamsConfig {
	position: ParamTemplate<ParamType.VECTOR3>;
}
declare class PositionToWorldGlNode extends TypedGlNode<PositionToWorldGlParamsConfig> {
	paramsConfig: PositionToWorldGlParamsConfig;
	static type(): Readonly<"positionToWorld">;
	initializeNode(): void;
	setLines(linesController: ShadersCollectionController): void;
}
declare class OklabToRgbGlParamsConfig extends NodeParamsConfig {
	oklab: ParamTemplate<ParamType.VECTOR3>;
}
declare class OklabToRgbGlNode extends TypedGlNode<OklabToRgbGlParamsConfig> {
	paramsConfig: OklabToRgbGlParamsConfig;
	static type(): string;
	initializeNode(): void;
	setLines(shaders_collection_controller: ShadersCollectionController): void;
}
declare class PolarToCartesianGlParamsConfig extends NodeParamsConfig {
	polar: ParamTemplate<ParamType.VECTOR3>;
}
declare class PolarToCartesianGlNode extends TypedGlNode<PolarToCartesianGlParamsConfig> {
	paramsConfig: PolarToCartesianGlParamsConfig;
	static type(): string;
	initializeNode(): void;
	setLines(shadersCollectionController: ShadersCollectionController): void;
}
declare class QuatMultGlNode extends BaseNodeGlMathFunctionArg1GlNode {
	static type(): string;
	initializeNode(): void;
	gl_method_name(): string;
	gl_function_definitions(): FunctionGLDefinition[];
}
declare class QuatFromAxisAngleGlNode extends BaseNodeGlMathFunctionArg2GlNode {
	static type(): string;
	initializeNode(): void;
	paramDefaultValue(name: string): number | Number3;
	gl_method_name(): string;
	gl_function_definitions(): FunctionGLDefinition[];
}
declare class QuatSlerpGlNode extends BaseNodeGlMathFunctionArg1GlNode {
	static type(): string;
	initializeNode(): void;
	gl_method_name(): string;
	gl_function_definitions(): FunctionGLDefinition[];
}
declare class QuatToAngleGlNode extends BaseNodeGlMathFunctionArg1GlNode {
	static type(): string;
	initializeNode(): void;
	gl_method_name(): string;
	gl_function_definitions(): FunctionGLDefinition[];
}
declare class QuatToAxisGlNode extends BaseNodeGlMathFunctionArg1GlNode {
	static type(): string;
	initializeNode(): void;
	gl_method_name(): string;
	gl_function_definitions(): FunctionGLDefinition[];
}
declare class RampGlParamsConfig extends NodeParamsConfig {
	name: ParamTemplate<ParamType.STRING>;
	input: ParamTemplate<ParamType.FLOAT>;
}
declare class RampGlNode extends TypedGlNode<RampGlParamsConfig> {
	paramsConfig: RampGlParamsConfig;
	static type(): Readonly<GlType.RAMP>;
	initializeNode(): void;
	setLines(shadersCollectionController: ShadersCollectionController): void;
	paramsGenerating(): boolean;
	setParamConfigs(): void;
	uniformName(): string;
}
declare class RandomGlParamsConfig extends NodeParamsConfig {
	seed: ParamTemplate<ParamType.VECTOR2>;
}
declare class RandomGlNode extends TypedGlNode<RandomGlParamsConfig> {
	paramsConfig: RandomGlParamsConfig;
	static type(): string;
	initializeNode(): void;
	setLines(shaders_collection_controller: ShadersCollectionController): void;
}
declare class RefractGlNode extends BaseGlMathFunctionGlNode {
	static type(): string;
	initializeNode(): void;
	gl_method_name(): string;
	protected _expected_input_types(): GlConnectionPointType[];
	protected _expected_output_types(): GlConnectionPointType[];
}
declare class RgbToHsvGlParamsConfig extends NodeParamsConfig {
	rgb: ParamTemplate<ParamType.VECTOR3>;
}
declare class RgbToHsvGlNode extends TypedGlNode<RgbToHsvGlParamsConfig> {
	paramsConfig: RgbToHsvGlParamsConfig;
	static type(): string;
	initializeNode(): void;
	setLines(shaders_collection_controller: ShadersCollectionController): void;
}
declare enum GlRotateMode {
	AXIS = 0,
	QUAT = 1
}
// @ts-ignore
declare class RotateParamsConfig extends NodeParamsConfig {
	signature: ParamTemplate<ParamType.INTEGER>;
}
declare class RotateGlNode extends TypedGlNode<RotateParamsConfig> {
	paramsConfig: RotateParamsConfig;
	static type(): string;
	initializeNode(): void;
	setSignature(mode: GlRotateMode): void;
	mode(): GlRotateMode;
	protected _expectedInputName(index: number): string;
	paramDefaultValue(name: string): Number3;
	functionName(): string;
	protected _expectedInputTypes(): GlConnectionPointType[];
	protected _expectedOutputTypes(): GlConnectionPointType[];
	functionDefinitions(): FunctionGLDefinition[];
	setLines(shadersCollectionController: ShadersCollectionController): void;
}
declare class RoundGlNode extends BaseNodeGlMathFunctionArg1GlNode {
	static type(): string;
	setLines(shadersCollectionController: ShadersCollectionController): void;
	private _singleLine;
}
declare class BaseSDF2DGlParamsConfig extends NodeParamsConfig {
	position: ParamTemplate<ParamType.VECTOR2>;
}
declare class BaseSDF2DGlNode<K extends BaseSDF2DGlParamsConfig> extends TypedGlNode<K> {
	protected position(): string;
	private _defaultPosition;
	protected _addSDF2DMethods(shadersCollectionController: ShadersCollectionController): void;
}
declare class SDF2DBoxGlParamsConfig extends NodeParamsConfig {
	position: ParamTemplate<ParamType.VECTOR2>;
	center: ParamTemplate<ParamType.VECTOR2>;
	size: ParamTemplate<ParamType.VECTOR2>;
}
declare class SDF2DBoxGlNode extends BaseSDF2DGlNode<SDF2DBoxGlParamsConfig> {
	paramsConfig: SDF2DBoxGlParamsConfig;
	static type(): GlType;
	initializeNode(): void;
	setLines(shadersCollectionController: ShadersCollectionController): void;
}
declare class SDF2DCircleGlParamsConfig extends NodeParamsConfig {
	position: ParamTemplate<ParamType.VECTOR2>;
	center: ParamTemplate<ParamType.VECTOR2>;
	radius: ParamTemplate<ParamType.FLOAT>;
}
declare class SDF2DCircleGlNode extends BaseSDF2DGlNode<SDF2DCircleGlParamsConfig> {
	paramsConfig: SDF2DCircleGlParamsConfig;
	static type(): GlType;
	initializeNode(): void;
	setLines(shadersCollectionController: ShadersCollectionController): void;
}
declare class SDF2DCrossGlParamsConfig extends NodeParamsConfig {
	position: ParamTemplate<ParamType.VECTOR2>;
	center: ParamTemplate<ParamType.VECTOR2>;
	length: ParamTemplate<ParamType.FLOAT>;
	width: ParamTemplate<ParamType.FLOAT>;
	radius: ParamTemplate<ParamType.FLOAT>;
}
declare class SDF2DCrossGlNode extends BaseSDF2DGlNode<SDF2DCrossGlParamsConfig> {
	paramsConfig: SDF2DCrossGlParamsConfig;
	static type(): GlType;
	initializeNode(): void;
	setLines(shadersCollectionController: ShadersCollectionController): void;
}
declare class SDF2DHeartGlParamsConfig extends NodeParamsConfig {
	position: ParamTemplate<ParamType.VECTOR2>;
	center: ParamTemplate<ParamType.VECTOR2>;
}
declare class SDF2DHeartGlNode extends BaseSDF2DGlNode<SDF2DHeartGlParamsConfig> {
	paramsConfig: SDF2DHeartGlParamsConfig;
	static type(): GlType;
	initializeNode(): void;
	setLines(shadersCollectionController: ShadersCollectionController): void;
}
declare class SDF2DRoundedXGlParamsConfig extends NodeParamsConfig {
	position: ParamTemplate<ParamType.VECTOR2>;
	center: ParamTemplate<ParamType.VECTOR2>;
	length: ParamTemplate<ParamType.FLOAT>;
	radius: ParamTemplate<ParamType.FLOAT>;
}
declare class SDF2DRoundedXGlNode extends BaseSDF2DGlNode<SDF2DRoundedXGlParamsConfig> {
	paramsConfig: SDF2DRoundedXGlParamsConfig;
	static type(): GlType;
	initializeNode(): void;
	setLines(shadersCollectionController: ShadersCollectionController): void;
}
declare class SDF2DStairsGlParamsConfig extends NodeParamsConfig {
	position: ParamTemplate<ParamType.VECTOR2>;
	center: ParamTemplate<ParamType.VECTOR2>;
	width: ParamTemplate<ParamType.FLOAT>;
	height: ParamTemplate<ParamType.FLOAT>;
	steps: ParamTemplate<ParamType.FLOAT>;
}
declare class SDF2DStairsGlNode extends BaseSDF2DGlNode<SDF2DStairsGlParamsConfig> {
	paramsConfig: SDF2DStairsGlParamsConfig;
	static type(): GlType;
	initializeNode(): void;
	setLines(shadersCollectionController: ShadersCollectionController): void;
}
declare class BaseSDFGlParamsConfig extends NodeParamsConfig {
	position: ParamTemplate<ParamType.VECTOR3>;
}
declare class BaseSDFGlNode<K extends BaseSDFGlParamsConfig> extends TypedGlNode<K> {
	protected position(): string;
	private _defaultPosition;
	protected _addSDFMethods(shadersCollectionController: ShadersCollectionController): void;
	static addSDFMethods(shadersCollectionController: ShadersCollectionController, node: BaseGlNodeType): void;
}
declare class SDFBoxGlParamsConfig extends NodeParamsConfig {
	position: ParamTemplate<ParamType.VECTOR3>;
	center: ParamTemplate<ParamType.VECTOR3>;
	size: ParamTemplate<ParamType.FLOAT>;
	sizes: ParamTemplate<ParamType.VECTOR3>;
}
declare class SDFBoxGlNode extends BaseSDFGlNode<SDFBoxGlParamsConfig> {
	paramsConfig: SDFBoxGlParamsConfig;
	static type(): GlType;
	initializeNode(): void;
	setLines(shadersCollectionController: ShadersCollectionController): void;
}
declare class SDFBoxFrameGlParamsConfig extends NodeParamsConfig {
	position: ParamTemplate<ParamType.VECTOR3>;
	center: ParamTemplate<ParamType.VECTOR3>;
	size: ParamTemplate<ParamType.FLOAT>;
	sizes: ParamTemplate<ParamType.VECTOR3>;
	width: ParamTemplate<ParamType.FLOAT>;
}
declare class SDFBoxFrameGlNode extends BaseSDFGlNode<SDFBoxFrameGlParamsConfig> {
	paramsConfig: SDFBoxFrameGlParamsConfig;
	static type(): GlType;
	initializeNode(): void;
	setLines(shadersCollectionController: ShadersCollectionController): void;
}
declare class SDFBoxRoundGlParamsConfig extends NodeParamsConfig {
	position: ParamTemplate<ParamType.VECTOR3>;
	center: ParamTemplate<ParamType.VECTOR3>;
	size: ParamTemplate<ParamType.FLOAT>;
	sizes: ParamTemplate<ParamType.VECTOR3>;
	radius: ParamTemplate<ParamType.FLOAT>;
}
declare class SDFBoxRoundGlNode extends BaseSDFGlNode<SDFBoxRoundGlParamsConfig> {
	paramsConfig: SDFBoxRoundGlParamsConfig;
	static type(): GlType;
	initializeNode(): void;
	setLines(shadersCollectionController: ShadersCollectionController): void;
}
declare class SDFCapsuleGlParamsConfig extends NodeParamsConfig {
	position: ParamTemplate<ParamType.VECTOR3>;
	center: ParamTemplate<ParamType.VECTOR3>;
	start: ParamTemplate<ParamType.VECTOR3>;
	end: ParamTemplate<ParamType.VECTOR3>;
	radius: ParamTemplate<ParamType.FLOAT>;
}
declare class SDFCapsuleGlNode extends BaseSDFGlNode<SDFCapsuleGlParamsConfig> {
	paramsConfig: SDFCapsuleGlParamsConfig;
	static type(): GlType;
	initializeNode(): void;
	setLines(shadersCollectionController: ShadersCollectionController): void;
}
declare class SDFCapsuleVerticalGlParamsConfig extends NodeParamsConfig {
	position: ParamTemplate<ParamType.VECTOR3>;
	center: ParamTemplate<ParamType.VECTOR3>;
	height: ParamTemplate<ParamType.FLOAT>;
	radius: ParamTemplate<ParamType.FLOAT>;
}
declare class SDFCapsuleVerticalGlNode extends BaseSDFGlNode<SDFCapsuleVerticalGlParamsConfig> {
	paramsConfig: SDFCapsuleVerticalGlParamsConfig;
	static type(): GlType;
	initializeNode(): void;
	setLines(shadersCollectionController: ShadersCollectionController): void;
}
declare class SDFConeGlParamsConfig extends NodeParamsConfig {
	position: ParamTemplate<ParamType.VECTOR3>;
	center: ParamTemplate<ParamType.VECTOR3>;
	height: ParamTemplate<ParamType.FLOAT>;
	angle: ParamTemplate<ParamType.FLOAT>;
}
declare class SDFConeGlNode extends BaseSDFGlNode<SDFConeGlParamsConfig> {
	paramsConfig: SDFConeGlParamsConfig;
	static type(): GlType;
	initializeNode(): void;
	setLines(shadersCollectionController: ShadersCollectionController): void;
}
declare class SDFConeRoundGlParamsConfig extends NodeParamsConfig {
	position: ParamTemplate<ParamType.VECTOR3>;
	center: ParamTemplate<ParamType.VECTOR3>;
	height: ParamTemplate<ParamType.FLOAT>;
	radius1: ParamTemplate<ParamType.FLOAT>;
	radius2: ParamTemplate<ParamType.FLOAT>;
}
declare class SDFConeRoundGlNode extends BaseSDFGlNode<SDFConeRoundGlParamsConfig> {
	paramsConfig: SDFConeRoundGlParamsConfig;
	static type(): GlType;
	initializeNode(): void;
	setLines(shadersCollectionController: ShadersCollectionController): void;
}
declare class SDFContextGlParamsConfig extends NodeParamsConfig {
}
declare class SDFContextGlNode extends TypedGlNode<SDFContextGlParamsConfig> {
	paramsConfig: SDFContextGlParamsConfig;
	static type(): GlType;
	initializeNode(): void;
	private _expectedInputTypes;
	private _expectedOutputTypes;
	private _glInputNames;
	private _glOutputNames;
	setLines(shaders_collection_controller: ShadersCollectionController): void;
}
declare class SDFElongateGlParamsConfig extends NodeParamsConfig {
	position: ParamTemplate<ParamType.VECTOR3>;
	center: ParamTemplate<ParamType.VECTOR3>;
	mult: ParamTemplate<ParamType.VECTOR3>;
	fast: ParamTemplate<ParamType.BOOLEAN>;
}
declare class SDFElongateGlNode extends BaseSDFGlNode<SDFElongateGlParamsConfig> {
	paramsConfig: SDFElongateGlParamsConfig;
	static type(): GlType;
	initializeNode(): void;
	setLines(shadersCollectionController: ShadersCollectionController): void;
}
declare enum SDFExtrudeAxis {
	X = "X",
	Y = "Y",
	Z = "Z"
}
declare class SDFExtrudeGlParamsConfig extends NodeParamsConfig {
	position: ParamTemplate<ParamType.VECTOR3>;
	center: ParamTemplate<ParamType.VECTOR3>;
	height: ParamTemplate<ParamType.FLOAT>;
	d: ParamTemplate<ParamType.FLOAT>;
	axis: ParamTemplate<ParamType.INTEGER>;
}
declare class SDFExtrudeGlNode extends BaseSDFGlNode<SDFExtrudeGlParamsConfig> {
	paramsConfig: SDFExtrudeGlParamsConfig;
	static type(): string;
	initializeNode(): void;
	setAxis(axis: SDFExtrudeAxis): void;
	setLines(shadersCollectionController: ShadersCollectionController): void;
	private _functionName;
}
declare class SDFFractalMandelbrotGlParamsConfig extends NodeParamsConfig {
	position: ParamTemplate<ParamType.VECTOR3>;
	center: ParamTemplate<ParamType.VECTOR3>;
	power: ParamTemplate<ParamType.FLOAT>;
	QPreMult: ParamTemplate<ParamType.VECTOR3>;
	QPostMult: ParamTemplate<ParamType.VECTOR3>;
	thetaMult: ParamTemplate<ParamType.FLOAT>;
	iterations: ParamTemplate<ParamType.INTEGER>;
	externalBoundingRadius: ParamTemplate<ParamType.FLOAT>;
}
declare class SDFFractalMandelbrotGlNode extends BaseSDFGlNode<SDFFractalMandelbrotGlParamsConfig> {
	paramsConfig: SDFFractalMandelbrotGlParamsConfig;
	static type(): GlType;
	initializeNode(): void;
	setLines(shadersCollectionController: ShadersCollectionController): void;
}
declare const SDFGradientGlParamsConfig_base: {
	new (...args: any[]): {
		inputs: ParamTemplate<ParamType.FOLDER>;
		inputsCount: ParamTemplate<ParamType.INTEGER>;
		inputType0: ParamTemplate<ParamType.INTEGER>;
		inputName0: ParamTemplate<ParamType.STRING>;
		inputType1: ParamTemplate<ParamType.INTEGER>;
		inputName1: ParamTemplate<ParamType.STRING>;
		inputType2: ParamTemplate<ParamType.INTEGER>;
		inputName2: ParamTemplate<ParamType.STRING>;
		inputType3: ParamTemplate<ParamType.INTEGER>;
		inputName3: ParamTemplate<ParamType.STRING>;
		inputType4: ParamTemplate<ParamType.INTEGER>;
		inputName4: ParamTemplate<ParamType.STRING>;
		inputType5: ParamTemplate<ParamType.INTEGER>;
		inputName5: ParamTemplate<ParamType.STRING>;
		inputType6: ParamTemplate<ParamType.INTEGER>;
		inputName6: ParamTemplate<ParamType.STRING>;
		inputType7: ParamTemplate<ParamType.INTEGER>;
		inputName7: ParamTemplate<ParamType.STRING>;
		inputType8: ParamTemplate<ParamType.INTEGER>;
		inputName8: ParamTemplate<ParamType.STRING>;
		inputType9: ParamTemplate<ParamType.INTEGER>;
		inputName9: ParamTemplate<ParamType.STRING>;
		spare: ParamTemplate<ParamType.FOLDER>;
	};
} & typeof NodeParamsConfig;
declare class SDFGradientGlParamsConfig extends SDFGradientGlParamsConfig_base {
	epsilon: ParamTemplate<ParamType.FLOAT>;
}
declare class SDFGradientGlNode extends TypedSubnetGlNode<SDFGradientGlParamsConfig> {
	paramsConfig: SDFGradientGlParamsConfig;
	static type(): Readonly<GlType.SDF_GRADIENT>;
	protected _expectedInputsCount(): number;
	protected _expectedInputTypes(): GlConnectionPointType[];
	protected _expectedOutputTypes(): GlConnectionPointType[];
	protected _expectedInputName(index: number): string;
	protected _expectedOutputName(index: number): string;
	childExpectedOutputConnectionPointTypes(): GlConnectionPointType[];
	childExpectedOutputConnectionPointName(index: number): string;
	setSubnetInputLines(shadersCollectionController: ShadersCollectionController, childNode: SubnetInputGlNode): void;
	setSubnetOutputLines(shadersCollectionController: ShadersCollectionController, childNode: SubnetOutputGlNode): void;
	setLines(shadersCollectionController: ShadersCollectionController): void;
	private _declareFunctions;
	private _callFunctions;
}
declare class SDFHexagonalPrismGlParamsConfig extends NodeParamsConfig {
	position: ParamTemplate<ParamType.VECTOR3>;
	center: ParamTemplate<ParamType.VECTOR3>;
	radius: ParamTemplate<ParamType.FLOAT>;
	height: ParamTemplate<ParamType.FLOAT>;
}
declare class SDFHexagonalPrismGlNode extends BaseSDFGlNode<SDFHexagonalPrismGlParamsConfig> {
	paramsConfig: SDFHexagonalPrismGlParamsConfig;
	static type(): GlType;
	initializeNode(): void;
	setLines(shadersCollectionController: ShadersCollectionController): void;
}
declare class SDFHorseShoeGlParamsConfig extends NodeParamsConfig {
	position: ParamTemplate<ParamType.VECTOR3>;
	center: ParamTemplate<ParamType.VECTOR3>;
	angle: ParamTemplate<ParamType.FLOAT>;
	radius: ParamTemplate<ParamType.FLOAT>;
	length: ParamTemplate<ParamType.FLOAT>;
	thickness: ParamTemplate<ParamType.FLOAT>;
	width: ParamTemplate<ParamType.FLOAT>;
}
declare class SDFHorseShoeGlNode extends BaseSDFGlNode<SDFHorseShoeGlParamsConfig> {
	paramsConfig: SDFHorseShoeGlParamsConfig;
	static type(): GlType;
	initializeNode(): void;
	setLines(shadersCollectionController: ShadersCollectionController): void;
}
declare class SDFIntersectGlParamsConfig extends NodeParamsConfig {
	smooth: ParamTemplate<ParamType.BOOLEAN>;
}
declare class SDFIntersectGlNode extends TypedGlNode<SDFIntersectGlParamsConfig> {
	paramsConfig: SDFIntersectGlParamsConfig;
	static type(): string;
	initializeNode(): void;
	private _glInputName;
	private _glOutputName;
	private _expectedInputTypes;
	private _expectedOutputTypes;
	setLines(shadersCollectionController: ShadersCollectionController): void;
}
declare class SDFLinkGlParamsConfig extends NodeParamsConfig {
	position: ParamTemplate<ParamType.VECTOR3>;
	center: ParamTemplate<ParamType.VECTOR3>;
	halfLength: ParamTemplate<ParamType.FLOAT>;
	radius1: ParamTemplate<ParamType.FLOAT>;
	radius2: ParamTemplate<ParamType.FLOAT>;
}
declare class SDFLinkGlNode extends BaseSDFGlNode<SDFLinkGlParamsConfig> {
	paramsConfig: SDFLinkGlParamsConfig;
	static type(): GlType;
	initializeNode(): void;
	setLines(shadersCollectionController: ShadersCollectionController): void;
}
declare class SDFMaterialGlParamsConfig extends NodeParamsConfig {
	globals: ParamTemplate<ParamType.FOLDER>;
	color: ParamTemplate<ParamType.COLOR>;
	useEnvMap: ParamTemplate<ParamType.BOOLEAN>;
	useReflection: ParamTemplate<ParamType.BOOLEAN>;
	useRefraction: ParamTemplate<ParamType.BOOLEAN>;
	lighting: ParamTemplate<ParamType.FOLDER>;
	useLights: ParamTemplate<ParamType.BOOLEAN>;
	diffuse: ParamTemplate<ParamType.COLOR>;
	emissive: ParamTemplate<ParamType.COLOR>;
	envMap: ParamTemplate<ParamType.FOLDER>;
	envMapTint: ParamTemplate<ParamType.COLOR>;
	envMapIntensity: ParamTemplate<ParamType.FLOAT>;
	envMapRoughness: ParamTemplate<ParamType.FLOAT>;
	envMapFresnel: ParamTemplate<ParamType.FLOAT>;
	envMapFresnelPower: ParamTemplate<ParamType.FLOAT>;
	reflection: ParamTemplate<ParamType.FOLDER>;
	reflectionTint: ParamTemplate<ParamType.COLOR>;
	reflectionDepth: ParamTemplate<ParamType.INTEGER>;
	reflectivity: ParamTemplate<ParamType.FLOAT>;
	reflectionBiasMult: ParamTemplate<ParamType.FLOAT>;
	refraction: ParamTemplate<ParamType.FOLDER>;
	refractionTint: ParamTemplate<ParamType.COLOR>;
	ior: ParamTemplate<ParamType.FLOAT>;
	splitRGB: ParamTemplate<ParamType.BOOLEAN>;
	iorOffset: ParamTemplate<ParamType.VECTOR3>;
	transmission: ParamTemplate<ParamType.FLOAT>;
	absorption: ParamTemplate<ParamType.FLOAT>;
	refractionDepth: ParamTemplate<ParamType.INTEGER>;
	refractionMaxDist: ParamTemplate<ParamType.FLOAT>;
	refractionBiasMult: ParamTemplate<ParamType.FLOAT>;
	sampleEnvMapOnLastRefractionRay: ParamTemplate<ParamType.BOOLEAN>;
	refractionStartOutsideMedium: ParamTemplate<ParamType.BOOLEAN>;
}
declare class SDFMaterialGlNode extends TypedGlNode<SDFMaterialGlParamsConfig> {
	paramsConfig: SDFMaterialGlParamsConfig;
	static type(): GlType;
	initializeNode(): void;
	materialIdName(): string;
	private _materialId;
	setLines(shadersCollectionController: ShadersCollectionController): void;
}
declare class SDFMaxGlParamsConfig extends NodeParamsConfig {
}
declare class SDFMaxGlNode extends TypedGlNode<SDFMaxGlParamsConfig> {
	paramsConfig: SDFMaxGlParamsConfig;
	static type(): string;
	initializeNode(): void;
	private _glInputName;
	private _glOutputName;
	private _expectedInputTypes;
	private _expectedOutputTypes;
	setLines(shadersCollectionController: ShadersCollectionController): void;
	private _setLinesFloat;
	private _setLinesSDFContext;
}
declare class SDFMinGlParamsConfig extends NodeParamsConfig {
}
declare class SDFMinGlNode extends TypedGlNode<SDFMinGlParamsConfig> {
	paramsConfig: SDFMinGlParamsConfig;
	static type(): string;
	initializeNode(): void;
	private _glInputName;
	private _glOutputName;
	private _expectedInputTypes;
	private _expectedOutputTypes;
	setLines(shadersCollectionController: ShadersCollectionController): void;
	private _setLinesFloat;
	private _setLinesSDFContext;
}
declare class SDFMirrorGlParamsConfig extends NodeParamsConfig {
	position: ParamTemplate<ParamType.VECTOR3>;
	center: ParamTemplate<ParamType.VECTOR3>;
	smooth: ParamTemplate<ParamType.BOOLEAN>;
	smoothFactor: ParamTemplate<ParamType.FLOAT>;
	mirrorX: ParamTemplate<ParamType.BOOLEAN>;
	mirrorY: ParamTemplate<ParamType.BOOLEAN>;
	mirrorZ: ParamTemplate<ParamType.BOOLEAN>;
}
declare class SDFMirrorGlNode extends BaseSDFGlNode<SDFMirrorGlParamsConfig> {
	paramsConfig: SDFMirrorGlParamsConfig;
	static type(): string;
	initializeNode(): void;
	setLines(shadersCollectionController: ShadersCollectionController): void;
	private _functionSuffix;
}
declare class SDFOctahedronGlParamsConfig extends NodeParamsConfig {
	position: ParamTemplate<ParamType.VECTOR3>;
	center: ParamTemplate<ParamType.VECTOR3>;
	size: ParamTemplate<ParamType.FLOAT>;
}
declare class SDFOctahedronGlNode extends BaseSDFGlNode<SDFOctahedronGlParamsConfig> {
	paramsConfig: SDFOctahedronGlParamsConfig;
	static type(): GlType;
	initializeNode(): void;
	setLines(shadersCollectionController: ShadersCollectionController): void;
}
declare class SDFOctogonalPrismGlParamsConfig extends NodeParamsConfig {
	position: ParamTemplate<ParamType.VECTOR3>;
	center: ParamTemplate<ParamType.VECTOR3>;
	radius: ParamTemplate<ParamType.FLOAT>;
	height: ParamTemplate<ParamType.FLOAT>;
}
declare class SDFOctogonalPrismGlNode extends BaseSDFGlNode<SDFOctogonalPrismGlParamsConfig> {
	paramsConfig: SDFOctogonalPrismGlParamsConfig;
	static type(): GlType;
	initializeNode(): void;
	setLines(shadersCollectionController: ShadersCollectionController): void;
}
declare class SDFOnionGlParamsConfig extends NodeParamsConfig {
}
declare class SDFOnionGlNode extends TypedGlNode<SDFOnionGlParamsConfig> {
	paramsConfig: SDFOnionGlParamsConfig;
	static type(): JsType;
	initializeNode(): void;
	paramDefaultValue(name: string): number;
	private _glInputName;
	private _glOutputName;
	private _expectedInputTypes;
	private _expectedOutputTypes;
	setLines(shadersCollectionController: ShadersCollectionController): void;
}
declare class SDFPlaneGlParamsConfig extends NodeParamsConfig {
	position: ParamTemplate<ParamType.VECTOR3>;
	center: ParamTemplate<ParamType.VECTOR3>;
	normal: ParamTemplate<ParamType.VECTOR3>;
	offset: ParamTemplate<ParamType.FLOAT>;
}
declare class SDFPlaneGlNode extends BaseSDFGlNode<SDFPlaneGlParamsConfig> {
	paramsConfig: SDFPlaneGlParamsConfig;
	static type(): GlType;
	initializeNode(): void;
	setLines(shadersCollectionController: ShadersCollectionController): void;
}
declare class SDFPyramidGlParamsConfig extends NodeParamsConfig {
	position: ParamTemplate<ParamType.VECTOR3>;
	center: ParamTemplate<ParamType.VECTOR3>;
	height: ParamTemplate<ParamType.FLOAT>;
}
declare class SDFPyramidGlNode extends BaseSDFGlNode<SDFPyramidGlParamsConfig> {
	paramsConfig: SDFPyramidGlParamsConfig;
	static type(): GlType;
	initializeNode(): void;
	setLines(shadersCollectionController: ShadersCollectionController): void;
}
declare class SDFQuadGlParamsConfig extends NodeParamsConfig {
	position: ParamTemplate<ParamType.VECTOR3>;
	center: ParamTemplate<ParamType.VECTOR3>;
	a: ParamTemplate<ParamType.VECTOR3>;
	b: ParamTemplate<ParamType.VECTOR3>;
	c: ParamTemplate<ParamType.VECTOR3>;
	d: ParamTemplate<ParamType.VECTOR3>;
	thickness: ParamTemplate<ParamType.FLOAT>;
}
declare class SDFQuadGlNode extends BaseSDFGlNode<SDFQuadGlParamsConfig> {
	paramsConfig: SDFQuadGlParamsConfig;
	static type(): GlType;
	initializeNode(): void;
	setLines(shadersCollectionController: ShadersCollectionController): void;
}
declare class SDFRepeatGlParamsConfig extends NodeParamsConfig {
	position: ParamTemplate<ParamType.VECTOR3>;
	center: ParamTemplate<ParamType.VECTOR3>;
	period: ParamTemplate<ParamType.VECTOR3>;
	repeatX: ParamTemplate<ParamType.BOOLEAN>;
	repeatY: ParamTemplate<ParamType.BOOLEAN>;
	repeatZ: ParamTemplate<ParamType.BOOLEAN>;
	clamped: ParamTemplate<ParamType.BOOLEAN>;
	clampedX: ParamTemplate<ParamType.BOOLEAN>;
	boundX: ParamTemplate<ParamType.VECTOR2>;
	clampedY: ParamTemplate<ParamType.BOOLEAN>;
	boundY: ParamTemplate<ParamType.VECTOR2>;
	clampedZ: ParamTemplate<ParamType.BOOLEAN>;
	boundZ: ParamTemplate<ParamType.VECTOR2>;
}
declare class SDFRepeatGlNode extends BaseSDFGlNode<SDFRepeatGlParamsConfig> {
	paramsConfig: SDFRepeatGlParamsConfig;
	static type(): string;
	initializeNode(): void;
	setLines(shadersCollectionController: ShadersCollectionController): void;
	private _clampedAxisesCount;
	repeatAll(): boolean;
	clamped(): boolean;
	clampedX(): boolean;
	clampedY(): boolean;
	clampedZ(): boolean;
	clampedAll(): boolean;
	private _functionSuffixUnclamped;
}
declare class SDFRepeatPolarGlParamsConfig extends NodeParamsConfig {
	position: ParamTemplate<ParamType.VECTOR3>;
	center: ParamTemplate<ParamType.VECTOR3>;
	periodLon: ParamTemplate<ParamType.FLOAT>;
}
declare class SDFRepeatPolarGlNode extends BaseSDFGlNode<SDFRepeatPolarGlParamsConfig> {
	paramsConfig: SDFRepeatPolarGlParamsConfig;
	static type(): string;
	initializeNode(): void;
	setLines(shadersCollectionController: ShadersCollectionController): void;
}
declare enum SDFRevolutionGlAxis {
	X = "X",
	Y = "Y",
	Z = "Z"
}
declare class SDFRevolutionGlParamsConfig extends NodeParamsConfig {
	position: ParamTemplate<ParamType.VECTOR3>;
	center: ParamTemplate<ParamType.VECTOR3>;
	radius: ParamTemplate<ParamType.FLOAT>;
	axis: ParamTemplate<ParamType.INTEGER>;
}
declare class SDFRevolutionGlNode extends BaseSDFGlNode<SDFRevolutionGlParamsConfig> {
	paramsConfig: SDFRevolutionGlParamsConfig;
	static type(): GlType;
	initializeNode(): void;
	setAxis(axis: SDFRevolutionGlAxis): void;
	setLines(shadersCollectionController: ShadersCollectionController): void;
	private _functionName;
}
declare class SDFRhombusGlParamsConfig extends NodeParamsConfig {
	position: ParamTemplate<ParamType.VECTOR3>;
	center: ParamTemplate<ParamType.VECTOR3>;
	length1: ParamTemplate<ParamType.FLOAT>;
	length2: ParamTemplate<ParamType.FLOAT>;
	height: ParamTemplate<ParamType.FLOAT>;
	radius: ParamTemplate<ParamType.FLOAT>;
}
declare class SDFRhombusGlNode extends BaseSDFGlNode<SDFRhombusGlParamsConfig> {
	paramsConfig: SDFRhombusGlParamsConfig;
	static type(): GlType;
	initializeNode(): void;
	setLines(shadersCollectionController: ShadersCollectionController): void;
}
declare class SDFRhombusTriacontahedronGlParamsConfig extends NodeParamsConfig {
	position: ParamTemplate<ParamType.VECTOR3>;
	center: ParamTemplate<ParamType.VECTOR3>;
	m1: ParamTemplate<ParamType.FLOAT>;
	m2: ParamTemplate<ParamType.FLOAT>;
	f: ParamTemplate<ParamType.FLOAT>;
}
declare class SDFRhombusTriacontahedronGlNode extends BaseSDFGlNode<SDFRhombusTriacontahedronGlParamsConfig> {
	paramsConfig: SDFRhombusTriacontahedronGlParamsConfig;
	static type(): GlType;
	initializeNode(): void;
	setLines(shadersCollectionController: ShadersCollectionController): void;
}
declare class SDFSolidAngleGlParamsConfig extends NodeParamsConfig {
	position: ParamTemplate<ParamType.VECTOR3>;
	center: ParamTemplate<ParamType.VECTOR3>;
	angle: ParamTemplate<ParamType.FLOAT>;
	radius: ParamTemplate<ParamType.FLOAT>;
}
declare class SDFSolidAngleGlNode extends BaseSDFGlNode<SDFSolidAngleGlParamsConfig> {
	paramsConfig: SDFSolidAngleGlParamsConfig;
	static type(): GlType;
	initializeNode(): void;
	setLines(shadersCollectionController: ShadersCollectionController): void;
}
declare class SDFSphereGlParamsConfig extends NodeParamsConfig {
	position: ParamTemplate<ParamType.VECTOR3>;
	center: ParamTemplate<ParamType.VECTOR3>;
	radius: ParamTemplate<ParamType.FLOAT>;
}
declare class SDFSphereGlNode extends BaseSDFGlNode<SDFSphereGlParamsConfig> {
	paramsConfig: SDFSphereGlParamsConfig;
	static type(): GlType;
	initializeNode(): void;
	setLines(shadersCollectionController: ShadersCollectionController): void;
}
declare class SDFSphereCutGlParamsConfig extends NodeParamsConfig {
	position: ParamTemplate<ParamType.VECTOR3>;
	center: ParamTemplate<ParamType.VECTOR3>;
	radius: ParamTemplate<ParamType.FLOAT>;
	height: ParamTemplate<ParamType.FLOAT>;
}
declare class SDFSphereCutGlNode extends BaseSDFGlNode<SDFSphereCutGlParamsConfig> {
	paramsConfig: SDFSphereCutGlParamsConfig;
	static type(): GlType;
	initializeNode(): void;
	setLines(shadersCollectionController: ShadersCollectionController): void;
}
declare class SDFSphereHollowGlParamsConfig extends NodeParamsConfig {
	position: ParamTemplate<ParamType.VECTOR3>;
	center: ParamTemplate<ParamType.VECTOR3>;
	radius: ParamTemplate<ParamType.FLOAT>;
	height: ParamTemplate<ParamType.FLOAT>;
	thickness: ParamTemplate<ParamType.FLOAT>;
}
declare class SDFSphereHollowGlNode extends BaseSDFGlNode<SDFSphereHollowGlParamsConfig> {
	paramsConfig: SDFSphereHollowGlParamsConfig;
	static type(): GlType;
	initializeNode(): void;
	setLines(shadersCollectionController: ShadersCollectionController): void;
}
declare class SDFSubtractGlParamsConfig extends NodeParamsConfig {
	smooth: ParamTemplate<ParamType.BOOLEAN>;
}
declare class SDFSubtractGlNode extends TypedGlNode<SDFSubtractGlParamsConfig> {
	paramsConfig: SDFSubtractGlParamsConfig;
	static type(): string;
	initializeNode(): void;
	private _glInputName;
	private _glOutputName;
	private _expectedInputTypes;
	private _expectedOutputTypes;
	setLines(shadersCollectionController: ShadersCollectionController): void;
}
declare class SDFTorusGlParamsConfig extends NodeParamsConfig {
	position: ParamTemplate<ParamType.VECTOR3>;
	center: ParamTemplate<ParamType.VECTOR3>;
	radius1: ParamTemplate<ParamType.FLOAT>;
	radius2: ParamTemplate<ParamType.FLOAT>;
	capped: ParamTemplate<ParamType.BOOLEAN>;
	angle: ParamTemplate<ParamType.FLOAT>;
}
declare class SDFTorusGlNode extends BaseSDFGlNode<SDFTorusGlParamsConfig> {
	paramsConfig: SDFTorusGlParamsConfig;
	static type(): GlType;
	initializeNode(): void;
	setLines(shadersCollectionController: ShadersCollectionController): void;
}
declare class SDFTransformGlParamsConfig extends NodeParamsConfig {
	position: ParamTemplate<ParamType.VECTOR3>;
	t: ParamTemplate<ParamType.VECTOR3>;
	r: ParamTemplate<ParamType.VECTOR3>;
}
declare class SDFTransformGlNode extends BaseSDFGlNode<SDFTransformGlParamsConfig> {
	paramsConfig: SDFTransformGlParamsConfig;
	static type(): GlType;
	initializeNode(): void;
	setLines(shadersCollectionController: ShadersCollectionController): void;
}
declare class SDFTriangleGlParamsConfig extends NodeParamsConfig {
	position: ParamTemplate<ParamType.VECTOR3>;
	center: ParamTemplate<ParamType.VECTOR3>;
	a: ParamTemplate<ParamType.VECTOR3>;
	b: ParamTemplate<ParamType.VECTOR3>;
	c: ParamTemplate<ParamType.VECTOR3>;
	thickness: ParamTemplate<ParamType.FLOAT>;
}
declare class SDFTriangleGlNode extends BaseSDFGlNode<SDFTriangleGlParamsConfig> {
	paramsConfig: SDFTriangleGlParamsConfig;
	static type(): GlType;
	initializeNode(): void;
	setLines(shadersCollectionController: ShadersCollectionController): void;
}
declare class SDFTriangularPrismGlParamsConfig extends NodeParamsConfig {
	position: ParamTemplate<ParamType.VECTOR3>;
	center: ParamTemplate<ParamType.VECTOR3>;
	radius: ParamTemplate<ParamType.FLOAT>;
	height: ParamTemplate<ParamType.FLOAT>;
}
declare class SDFTriangularPrismGlNode extends BaseSDFGlNode<SDFTriangularPrismGlParamsConfig> {
	paramsConfig: SDFTriangularPrismGlParamsConfig;
	static type(): GlType;
	initializeNode(): void;
	setLines(shadersCollectionController: ShadersCollectionController): void;
}
declare class SDFTubeGlParamsConfig extends NodeParamsConfig {
	position: ParamTemplate<ParamType.VECTOR3>;
	center: ParamTemplate<ParamType.VECTOR3>;
	capped: ParamTemplate<ParamType.BOOLEAN>;
	radius: ParamTemplate<ParamType.FLOAT>;
	height: ParamTemplate<ParamType.FLOAT>;
}
declare class SDFTubeGlNode extends BaseSDFGlNode<SDFTubeGlParamsConfig> {
	paramsConfig: SDFTubeGlParamsConfig;
	static type(): GlType;
	initializeNode(): void;
	setLines(shadersCollectionController: ShadersCollectionController): void;
}
declare class SDFTwistGlParamsConfig extends NodeParamsConfig {
	position: ParamTemplate<ParamType.VECTOR3>;
	center: ParamTemplate<ParamType.VECTOR3>;
	twist: ParamTemplate<ParamType.FLOAT>;
	axis: ParamTemplate<ParamType.INTEGER>;
}
declare class SDFTwistGlNode extends BaseSDFGlNode<SDFTwistGlParamsConfig> {
	paramsConfig: SDFTwistGlParamsConfig;
	static type(): string;
	initializeNode(): void;
	setLines(shadersCollectionController: ShadersCollectionController): void;
	private _functionSuffix;
}
declare class SDFUnionGlParamsConfig extends NodeParamsConfig {
	smooth: ParamTemplate<ParamType.BOOLEAN>;
}
declare class SDFUnionGlNode extends TypedGlNode<SDFUnionGlParamsConfig> {
	paramsConfig: SDFUnionGlParamsConfig;
	static type(): string;
	initializeNode(): void;
	private _glInputName;
	private _glOutputName;
	private _expectedInputTypes;
	private _expectedOutputTypes;
	setLines(shadersCollectionController: ShadersCollectionController): void;
}
declare class SkinningGlParamsConfig extends NodeParamsConfig {
	position: ParamTemplate<ParamType.VECTOR3>;
	normal: ParamTemplate<ParamType.VECTOR3>;
}
declare class SkinningGlNode extends TypedGlNode<SkinningGlParamsConfig> {
	paramsConfig: SkinningGlParamsConfig;
	static type(): Readonly<"skinning">;
	initializeNode(): void;
	setLines(linesController: ShadersCollectionController): void;
}
declare class VATDataGlParamsConfig extends NodeParamsConfig {
	color: ParamTemplate<ParamType.COLOR>;
	thickness: ParamTemplate<ParamType.FLOAT>;
	power: ParamTemplate<ParamType.FLOAT>;
	scale: ParamTemplate<ParamType.FLOAT>;
	distortion: ParamTemplate<ParamType.FLOAT>;
	ambient: ParamTemplate<ParamType.FLOAT>;
	attenuation: ParamTemplate<ParamType.FLOAT>;
}
declare class SSSModelGlNode extends TypedGlNode<VATDataGlParamsConfig> {
	paramsConfig: VATDataGlParamsConfig;
	static type(): string;
	initializeNode(): void;
	setLines(shaders_collection_controller: ShadersCollectionController): void;
	private _paramLineFloat;
}
declare class SphereGlParamsConfig extends NodeParamsConfig {
	position: ParamTemplate<ParamType.VECTOR3>;
	center: ParamTemplate<ParamType.VECTOR3>;
	radius: ParamTemplate<ParamType.FLOAT>;
	feather: ParamTemplate<ParamType.FLOAT>;
}
declare class SphereGlNode extends TypedGlNode<SphereGlParamsConfig> {
	paramsConfig: SphereGlParamsConfig;
	static type(): string;
	initializeNode(): void;
	setLines(shaders_collection_controller: ShadersCollectionController): void;
}
declare class SwitchParamsConfig extends NodeParamsConfig {
}
declare class SwitchGlNode extends TypedGlNode<SwitchParamsConfig> {
	paramsConfig: SwitchParamsConfig;
	static type(): string;
	static INPUT_INDEX: string;
	initializeNode(): void;
	protected _gl_input_name(index: number): string;
	protected _expected_input_types(): GlConnectionPointType[];
	protected _expected_output_types(): GlConnectionPointType[];
	setLines(shaders_collection_controller: ShadersCollectionController): void;
}
declare class TextureGlParamsConfig extends NodeParamsConfig {
	paramName: ParamTemplate<ParamType.STRING>;
	uv: ParamTemplate<ParamType.VECTOR2>;
	tblur: ParamTemplate<ParamType.BOOLEAN>;
	resolution: ParamTemplate<ParamType.VECTOR2>;
	blurPixelsCountX: ParamTemplate<ParamType.INTEGER>;
	blurPixelsCountY: ParamTemplate<ParamType.INTEGER>;
}
declare class TextureGlNode extends TypedGlNode<TextureGlParamsConfig> {
	paramsConfig: TextureGlParamsConfig;
	static type(): Readonly<GlType.TEXTURE>;
	static readonly OUTPUT_NAME = "rgba";
	initializeNode(): void;
	setLines(shaders_collection_controller: ShadersCollectionController): void;
	paramsGenerating(): boolean;
	setParamConfigs(): void;
	uniformName(): string;
}
declare class Texture2DArrayGlParamsConfig extends NodeParamsConfig {
	paramName: ParamTemplate<ParamType.STRING>;
	uv: ParamTemplate<ParamType.VECTOR2>;
	layer: ParamTemplate<ParamType.INTEGER>;
}
declare class Texture2DArrayGlNode extends TypedGlNode<Texture2DArrayGlParamsConfig> {
	paramsConfig: Texture2DArrayGlParamsConfig;
	static type(): Readonly<"texture2DArray">;
	static readonly OUTPUT_NAME = "rgba";
	initializeNode(): void;
	setLines(shaders_collection_controller: ShadersCollectionController): void;
	paramsGenerating(): boolean;
	setParamConfigs(): void;
	uniformName(): string;
}
declare class TextureDisplacementGlParamsConfig extends NodeParamsConfig {
	paramName: ParamTemplate<ParamType.STRING>;
	computeAllNeighbours: ParamTemplate<ParamType.BOOLEAN>;
	position: ParamTemplate<ParamType.VECTOR3>;
	normal: ParamTemplate<ParamType.VECTOR3>;
	uv: ParamTemplate<ParamType.VECTOR2>;
	amount: ParamTemplate<ParamType.FLOAT>;
	textureSize: ParamTemplate<ParamType.VECTOR2>;
	tangentsPosOffset: ParamTemplate<ParamType.VECTOR2>;
	textureComponent: ParamTemplate<ParamType.INTEGER>;
}
declare class TextureDisplacementGlNode extends TypedGlNode<TextureDisplacementGlParamsConfig> {
	paramsConfig: TextureDisplacementGlParamsConfig;
	static type(): GlType;
	initializeNode(): void;
	setLines(linesController: ShadersCollectionController): void;
	paramsGenerating(): boolean;
	setParamConfigs(): void;
	uniformName(): string;
}
declare class TextureSDFGlParamsConfig extends NodeParamsConfig {
	paramName: ParamTemplate<ParamType.STRING>;
	position: ParamTemplate<ParamType.VECTOR3>;
	center: ParamTemplate<ParamType.VECTOR3>;
	boundMin: ParamTemplate<ParamType.VECTOR3>;
	boundMax: ParamTemplate<ParamType.VECTOR3>;
	boundScale: ParamTemplate<ParamType.VECTOR3>;
	bias: ParamTemplate<ParamType.FLOAT>;
	tblur: ParamTemplate<ParamType.BOOLEAN>;
	blurDist: ParamTemplate<ParamType.FLOAT>;
}
declare class TextureSDFGlNode extends BaseSDFGlNode<TextureSDFGlParamsConfig> {
	paramsConfig: TextureSDFGlParamsConfig;
	static type(): Readonly<GlType.TEXTURE_SDF>;
	static readonly OUTPUT_NAME = "d";
	initializeNode(): void;
	setLines(shadersCollectionController: ShadersCollectionController): void;
	paramsGenerating(): boolean;
	setParamConfigs(): void;
	uniformName(): string;
}
declare class TileUvGlParamsConfig extends NodeParamsConfig {
	uv: ParamTemplate<ParamType.VECTOR2>;
	tile: ParamTemplate<ParamType.FLOAT>;
	tilesCount: ParamTemplate<ParamType.VECTOR2>;
}
declare class TileUvGlNode extends TypedGlNode<TileUvGlParamsConfig> {
	paramsConfig: TileUvGlParamsConfig;
	static type(): string;
	initializeNode(): void;
	setLines(shaders_collection_controller: ShadersCollectionController): void;
}
declare class ToWorldSpaceGlParamsConfig extends NodeParamsConfig {
	vec: ParamTemplate<ParamType.VECTOR3>;
	interpretation: ParamTemplate<ParamType.INTEGER>;
}
declare class ToWorldSpaceGlNode extends TypedGlNode<ToWorldSpaceGlParamsConfig> {
	paramsConfig: ToWorldSpaceGlParamsConfig;
	static type(): string;
	initializeNode(): void;
	setLines(shaders_collection_controller: ShadersCollectionController): void;
}
declare enum TwoWaySwitchGlNodeInputName {
	CONDITION = "condition",
	IF_TRUE = "ifTrue",
	IF_FALSE = "ifFalse"
}
declare class TwoWaySwitchGlNode extends ParamlessTypedGlNode {
	static type(): string;
	initializeNode(): void;
	protected _gl_input_name(index: number): TwoWaySwitchGlNodeInputName;
	protected _gl_output_name(): string;
	protected _expected_input_types(): GlConnectionPointType[];
	protected _expected_output_types(): GlConnectionPointType[];
	setLines(shaders_collection_controller: ShadersCollectionController): void;
}
declare class UvToOklabGlParamsConfig extends NodeParamsConfig {
	uvw: ParamTemplate<ParamType.VECTOR3>;
}
declare class UvToOklabGlNode extends TypedGlNode<UvToOklabGlParamsConfig> {
	paramsConfig: UvToOklabGlParamsConfig;
	static type(): string;
	initializeNode(): void;
	setLines(shaders_collection_controller: ShadersCollectionController): void;
}
declare class VaryingWriteGlParamsConfig extends NodeParamsConfig {
	name: ParamTemplate<ParamType.STRING>;
	type: ParamTemplate<ParamType.INTEGER>;
}
declare class VaryingWriteGlNode extends TypedGlNode<VaryingWriteGlParamsConfig> {
	paramsConfig: VaryingWriteGlParamsConfig;
	static type(): Readonly<GlType.VARYING_WRITE>;
	static readonly INPUT_NAME = "vertex";
	initializeNode(): void;
	inputName(): string;
	setLines(shaders_collection_controller: ShadersCollectionController): void;
	attributeName(): string;
	glType(): GlConnectionPointType | undefined;
	setGlType(type: GlConnectionPointType): void;
}
declare class VaryingReadGlParamsConfig extends NodeParamsConfig {
	name: ParamTemplate<ParamType.STRING>;
	type: ParamTemplate<ParamType.INTEGER>;
}
declare class VaryingReadGlNode extends TypedGlNode<VaryingReadGlParamsConfig> {
	paramsConfig: VaryingReadGlParamsConfig;
	static type(): Readonly<GlType.VARYING_READ>;
	static readonly OUTPUT_NAME = "fragment";
	initializeNode(): void;
	outputName(): string;
	setLines(shaders_collection_controller: ShadersCollectionController): void;
	attributeName(): string;
	glType(): GlConnectionPointType;
	setGlType(type: GlConnectionPointType): void;
}
declare const VectorAlignGlNode_base: typeof BaseNodeGlMathFunctionArg3GlNode;
declare class VectorAlignGlNode extends VectorAlignGlNode_base {
	protected _expected_input_types(): GlConnectionPointType[];
	protected _expected_output_types(): GlConnectionPointType[];
	paramDefaultValue(name: string): Number3;
}
declare const VectorAngleGlNode_base: typeof BaseNodeGlMathFunctionArg2GlNode;
declare class VectorAngleGlNode extends VectorAngleGlNode_base {
	_expected_input_types(): GlConnectionPointType[];
	_expected_output_types(): GlConnectionPointType[];
	paramDefaultValue(name: string): Number3;
}
declare class VertexAnimationTextureGlParamsConfig extends NodeParamsConfig {
	frame: ParamTemplate<ParamType.FLOAT>;
	framesCount: ParamTemplate<ParamType.FLOAT>;
	uv: ParamTemplate<ParamType.VECTOR2>;
	paddedRatio: ParamTemplate<ParamType.VECTOR2>;
	textureP: ParamTemplate<ParamType.STRING>;
	textureP2: ParamTemplate<ParamType.STRING>;
	textureN: ParamTemplate<ParamType.STRING>;
}
declare class VertexAnimationTextureGlNode extends TypedGlNode<VertexAnimationTextureGlParamsConfig> {
	paramsConfig: VertexAnimationTextureGlParamsConfig;
	static type(): GlType;
	initializeNode(): void;
	setLines(shadersCollectionController: ShadersCollectionController): void;
	paramsGenerating(): boolean;
	setParamConfigs(): void;
	private _uniformName;
}
declare class VertexAnimationTextureInterpolatedGlParamsConfig extends NodeParamsConfig {
	frame: ParamTemplate<ParamType.FLOAT>;
	framesCount: ParamTemplate<ParamType.FLOAT>;
	uv: ParamTemplate<ParamType.VECTOR2>;
	paddedRatio: ParamTemplate<ParamType.VECTOR2>;
	textureP: ParamTemplate<ParamType.STRING>;
	textureP2: ParamTemplate<ParamType.STRING>;
	textureN: ParamTemplate<ParamType.STRING>;
	speed: ParamTemplate<ParamType.FLOAT>;
	boundMin: ParamTemplate<ParamType.FLOAT>;
	boundMax: ParamTemplate<ParamType.FLOAT>;
	Poffset: ParamTemplate<ParamType.VECTOR3>;
}
declare class VertexAnimationTextureInterpolatedGlNode extends TypedGlNode<VertexAnimationTextureInterpolatedGlParamsConfig> {
	paramsConfig: VertexAnimationTextureInterpolatedGlParamsConfig;
	static type(): GlType;
	initializeNode(): void;
	setLines(shadersCollectionController: ShadersCollectionController): void;
	paramsGenerating(): boolean;
	setParamConfigs(): void;
	private _uniformName;
}
declare class WavesGlParamsConfig extends NodeParamsConfig {
	position: ParamTemplate<ParamType.VECTOR2>;
	time: ParamTemplate<ParamType.FLOAT>;
	freq: ParamTemplate<ParamType.FLOAT>;
	freqMult: ParamTemplate<ParamType.FLOAT>;
	speedMult: ParamTemplate<ParamType.FLOAT>;
}
declare class WavesGlNode extends TypedGlNode<WavesGlParamsConfig> {
	paramsConfig: WavesGlParamsConfig;
	static type(): string;
	initializeNode(): void;
	setLines(linesController: ShadersCollectionController): void;
}
interface GlNodeChildrenMap {
	abs: AbsGlNode;
	acceleration: AccelerationGlNode;
	acos: AcosGlNode;
	add: AddGlNode;
	adjacentPointsAttribSmooth: AdjacentPointsAttribSmoothGlNode;
	adjacentUvAttribSmooth: AdjacentUvAttribSmoothGlNode;
	align: AlignGlNode;
	and: AndGlNode;
	asin: AsinGlNode;
	atan: AtanGlNode;
	attribute: AttributeGlNode;
	boolToInt: BoolToIntGlNode;
	cartesianToPolar: CartesianToPolarGlNode;
	ceil: CeilGlNode;
	clamp: ClampGlNode;
	checkers: CheckersGlNode;
	clothSolverPosition: ClothSolverPositionGlNode;
	clothSolverUv: ClothSolverUvGlNode;
	colorCorrect: ColorCorrectGlNode;
	compare: CompareGlNode;
	complement: ComplementGlNode;
	computeNormals: ComputeNormalsGlNode;
	constant: ConstantGlNode;
	cos: CosGlNode;
	cross: CrossGlNode;
	cycle: CycleGlNode;
	degrees: DegreesGlNode;
	disk: DiskGlNode;
	distance: DistanceGlNode;
	dither: DitherGlNode;
	divide: DivideGlNode;
	dot: DotGlNode;
	easing: EasingGlNode;
	exp: ExpGlNode;
	exp2: Exp2GlNode;
	faceForward: FaceforwardGlNode;
	fit: FitGlNode;
	fitTo01: FitTo01GlNode;
	fitFrom01: FitFrom01GlNode;
	fitFrom01ToVariance: FitFrom01ToVarianceGlNode;
	floatToInt: FloatToIntGlNode;
	floatToVec2: FloatToVec2GlNode;
	floatToVec3: FloatToVec3GlNode;
	floatToVec4: FloatToVec4GlNode;
	floor: FloorGlNode;
	fract: FractGlNode;
	fresnel: FresnelGlNode;
	fog: FogGlNode;
	forLoop: ForLoopGlNode;
	geometryAttributeLookupUv: GeometryAttributeLookupUvGlNode;
	globals: GlobalsGlNode;
	grid: GridGlNode;
	hsluvToRgb: HsluvToRgbGlNode;
	hsvToRgb: HsvToRgbGlNode;
	ifThen: IfThenGlNode;
	impostorUv: ImpostorUvGlNode;
	inRange: InRangeGlNode;
	intToBool: IntToBoolGlNode;
	intToFloat: IntToFloatGlNode;
	instanceTransform: InstanceTransformGlNode;
	inverseSqrt: InverseSqrtGlNode;
	inverseTransformDirection: InverseTransformDirectionGlNode;
	isInfOrNan: IsInfOrNanGlNode;
	length: LengthGlNode;
	log: LogGlNode;
	log2: Log2GlNode;
	luminance: LuminanceGlNode;
	max: MaxGlNode;
	maxLength: MaxLengthGlNode;
	min: MinGlNode;
	mix: MixGlNode;
	mod: ModGlNode;
	modelMatrixMult: ModelMatrixMultGlNode;
	modelViewMatrixMult: ModelViewMatrixMultGlNode;
	mult: MultGlNode;
	multAdd: MultAddGlNode;
	multScalar: MultScalarGlNode;
	multVectorMatrix: MultVectorMatrixGlNode;
	negate: NegateGlNode;
	neighbourAttract: NeighbourAttractGlNode;
	neighbourAttractRepulse: NeighbourAttractRepulseGlNode;
	neighbourAttribSmooth: NeighbourAttribSmoothGlNode;
	neighbourDensity: NeighbourDensityGlNode;
	neighbourRepulse: NeighbourRepulseGlNode;
	noise: NoiseGlNode;
	normalToWorld: NormalToWorldGlNode;
	normalize: NormalizeGlNode;
	null: NullGlNode;
	oklabToRgb: OklabToRgbGlNode;
	or: OrGlNode;
	output: OutputGlNode;
	param: ParamGlNode;
	polarToCartesian: PolarToCartesianGlNode;
	positionToWorld: PositionToWorldGlNode;
	pow: PowGlNode;
	quatMult: QuatMultGlNode;
	quatFromAxisAngle: QuatFromAxisAngleGlNode;
	quatSlerp: QuatSlerpGlNode;
	quatToAngle: QuatToAngleGlNode;
	quatToAxis: QuatToAxisGlNode;
	radians: RadiansGlNode;
	ramp: RampGlNode;
	random: RandomGlNode;
	reflect: ReflectGlNode;
	refract: RefractGlNode;
	rgbToHsv: RgbToHsvGlNode;
	rotate: RotateGlNode;
	round: RoundGlNode;
	SDF2DBox: SDF2DBoxGlNode;
	SDF2DCircle: SDF2DCircleGlNode;
	SDF2DCross: SDF2DCrossGlNode;
	SDF2DHeart: SDF2DHeartGlNode;
	SDF2DRoundedX: SDF2DRoundedXGlNode;
	SDF2DStairs: SDF2DStairsGlNode;
	SDFBox: SDFBoxGlNode;
	SDFBoxFrame: SDFBoxFrameGlNode;
	SDFBoxRound: SDFBoxRoundGlNode;
	SDFCapsule: SDFCapsuleGlNode;
	SDFCapsuleVertical: SDFCapsuleVerticalGlNode;
	SDFCone: SDFConeGlNode;
	SDFConeRound: SDFConeRoundGlNode;
	SDFContext: SDFContextGlNode;
	SDFElongate: SDFElongateGlNode;
	SDFExtrude: SDFExtrudeGlNode;
	SDFFractalMandelbrot: SDFFractalMandelbrotGlNode;
	SDFGradient: SDFGradientGlNode;
	SDFHexagonalPrism: SDFHexagonalPrismGlNode;
	SDFHorseShoe: SDFHorseShoeGlNode;
	SDFIntersect: SDFIntersectGlNode;
	SDFLink: SDFLinkGlNode;
	SDFMaterial: SDFMaterialGlNode;
	SDFMax: SDFMaxGlNode;
	SDFMin: SDFMinGlNode;
	SDFMirror: SDFMirrorGlNode;
	SDFOctahedron: SDFOctahedronGlNode;
	SDFOctogonalPrism: SDFOctogonalPrismGlNode;
	SDFOnion: SDFOnionGlNode;
	SDFPlane: SDFPlaneGlNode;
	SDFPyramid: SDFPyramidGlNode;
	SDFQuad: SDFQuadGlNode;
	SDFRepeat: SDFRepeatGlNode;
	SDFRepeatPolar: SDFRepeatPolarGlNode;
	SDFRevolution: SDFRevolutionGlNode;
	SDFRhombus: SDFRhombusGlNode;
	SDFRhombusTriacontahedron: SDFRhombusTriacontahedronGlNode;
	SDFSolidAngle: SDFSolidAngleGlNode;
	SDFSphere: SDFSphereGlNode;
	SDFSphereCut: SDFSphereCutGlNode;
	SDFSphereHollow: SDFSphereHollowGlNode;
	SDFSubtract: SDFSubtractGlNode;
	SDFTorus: SDFTorusGlNode;
	SDFTube: SDFTubeGlNode;
	SDFTransform: SDFTransformGlNode;
	SDFTriangle: SDFTriangleGlNode;
	SDFTriangularPrism: SDFTriangularPrismGlNode;
	SDFTwist: SDFTwistGlNode;
	SDFUnion: SDFUnionGlNode;
	SSSModel: SSSModelGlNode;
	sign: SignGlNode;
	sin: SinGlNode;
	skinning: SkinningGlNode;
	smoothstep: SmoothstepGlNode;
	sphere: SphereGlNode;
	sqrt: SqrtGlNode;
	step: StepGlNode;
	subnet: SubnetGlNode;
	subnetInput: SubnetInputGlNode;
	subnetOutput: SubnetOutputGlNode;
	subtract: SubtractGlNode;
	switch: SwitchGlNode;
	tan: TanGlNode;
	texture: TextureGlNode;
	texture2DArray: Texture2DArrayGlNode;
	textureDisplacement: TextureDisplacementGlNode;
	textureSDF: TextureSDFGlNode;
	tileUv: TileUvGlNode;
	toWorldSpace: ToWorldSpaceGlNode;
	twoWaySwitch: TwoWaySwitchGlNode;
	uvToOklab: UvToOklabGlNode;
	varyingWrite: VaryingWriteGlNode;
	varyingRead: VaryingReadGlNode;
	vec2ToFloat: Vec2ToFloatGlNode;
	vec2ToVec3: Vec2ToVec3GlNode;
	vec3ToFloat: Vec3ToFloatGlNode;
	vec3ToVec2: Vec3ToVec2GlNode;
	vec3ToVec4: Vec3ToVec4GlNode;
	vec4ToFloat: Vec4ToFloatGlNode;
	vec4ToVec3: Vec4ToVec3GlNode;
	vectorAlign: VectorAlignGlNode;
	vectorAngle: VectorAngleGlNode;
	vertexAnimationTexture: VertexAnimationTextureGlNode;
	vertexAnimationTextureInterpolated: VertexAnimationTextureInterpolatedGlNode;
	waves: WavesGlNode;
}
declare class ClothSolverSopParamsConfig extends NodeParamsConfig {
}
declare class ClothSolverSopNode extends TypedSopNode<ClothSolverSopParamsConfig> {
	readonly paramsConfig: ClothSolverSopParamsConfig;
	static type(): SopType.CLOTH_SOLVER;
	assemblerController(): GlAssemblerController<ShaderAssemblerCloth> | undefined;
	usedAssembler(): Readonly<AssemblerName.GL_CLOTH>;
	protected _assemblerController: GlAssemblerController<ShaderAssemblerCloth> | undefined;
	private _createAssemblerController;
	readonly persisted_config: ClothPersistedConfig;
	private _globalsHandler;
	private _shadersByName;
	shadersByName(): Map<ShaderName, string>;
	protected _childrenControllerContext: NodeContext;
	protected initializeNode(): void;
	createNode<S extends keyof GlNodeChildrenMap>(node_class: S, options?: NodeCreateOptions): GlNodeChildrenMap[S];
	createNode<K extends valueof<GlNodeChildrenMap>>(node_class: Constructor<K>, options?: NodeCreateOptions): K;
	children(): BaseGlNodeType[];
	nodesByType<K extends keyof GlNodeChildrenMap>(type: K): GlNodeChildrenMap[K][];
	childrenAllowed(): boolean;
	sceneReadonly(): boolean;
	cook(inputCoreGroups: CoreGroup[]): Promise<void>;
	updateObjectOnAdd(object: Object3D): void;
	compileIfRequired(): void;
	run_assembler(): void;
	private _setShaderNames;
	init_with_persisted_config(): void;
	initCoreClothControllerFromPersistedConfig(coreClothController: ClothController): void;
	private _findExportNodes;
}
declare class ClothController {
	scene: PolyScene;
	private _node;
	clothObject: Mesh;
	readonly materials: ClothMaterialController;
	readonly geometryInit: ClothGeometryInitController;
	private _persistedTextureAllocationsController;
	readonly fbo: ClothFBOController;
	stepsCount: number;
	constraintInfluence: number;
	viscosity: number;
	spring: number;
	constructor(scene: PolyScene, _node: ClothSolverSopNode, clothObject: Mesh);
	dispose(): void;
	setPersistedTextureAllocationController(controller: TextureAllocationsController): void;
	integrationFragmentShader(): string | undefined;
	textureAllocationsController(): TextureAllocationsController | undefined;
	assignReadonlyTextures(material: ShaderMaterial, texturesByName: Record<string, Texture>): void;
	addMaterialUniforms(material: ShaderMaterial): void;
	init(renderer: WebGLRenderer): void;
	update(config: ClothMaterialUniformConfigRef): void;
	private _selectedVertexIndex;
	private _selectedVertexPosition;
	private _setSelectedVertexIndex;
	createConstraint(index: number): void;
	deleteConstraint(): void;
	selectedVertexIndex(): number;
	setConstraintPosition(position: Vector3): void;
	constraintPosition(target: Vector3): void;
}
interface ClothMaterialUniformConfigRef {
	tSize: Ref<Vector2>;
	tPosition0: Ref<Texture>;
	tPosition1: Ref<Texture>;
	tNormal: Ref<Texture>;
	tOriginalRT: Ref<Texture>;
	tViscositySpringT: Ref<Texture>;
	tPreviousRT0: Ref<Texture>;
	tPreviousRT1: Ref<Texture>;
	tTargetRT0: Ref<Texture>;
	tTargetRT1: Ref<Texture>;
	tNormalsRT: Ref<Texture>;
	tPositionRT0: Ref<Texture>;
	tPositionRT1: Ref<Texture>;
	tAdjacentsRT0: Ref<Texture>;
	tAdjacentsRT1: Ref<Texture>;
	tDistanceRT0: Ref<Texture>;
	tDistanceRT1: Ref<Texture>;
	integrationMat: Ref<Material>;
}
// @ts-ignore
interface TextureContainer {
	texture: DataTexture | null;
}
declare class ClothFBOController {
	readonly mainController: ClothController;
	readonly tSize: Vector2;
	readonly fboScene: Scene;
	readonly fboCamera: OrthographicCamera;
	readonly fboMesh: Mesh;
	RESOLUTION: Vector2;
	originalRT: TextureContainer;
	viscositySpringT: TextureContainer;
	readonly previousRT: [
		WebGLRenderTarget,
		WebGLRenderTarget
	];
	readonly targetRT: [
		WebGLRenderTarget,
		WebGLRenderTarget
	];
	normalsRT: WebGLRenderTarget;
	readonly positionRT: [
		WebGLRenderTarget,
		WebGLRenderTarget
	];
	readonly adjacentsRT: [
		TextureContainer,
		TextureContainer
	];
	readonly distancesRT: [
		TextureContainer,
		TextureContainer
	];
	renderer: WebGLRenderer | undefined;
	constructor(mainController: ClothController);
	private _initialized;
	init(renderer: WebGLRenderer): void;
	private copyTexture;
	private createPositionTexture;
	private createViscositySpringTexture;
	private createTexturesFromAllocation;
	private createAdjacentsTexture;
	private createDistancesTexture;
	update(config?: ClothMaterialUniformConfigRef): void;
	private _updateTextureRefs;
	private integrate;
	protected solveConstraints(renderer: WebGLRenderer, secondaryMotionMult: number): void;
	protected mouseOffset(renderer: WebGLRenderer): void;
	protected computeVertexNormals(renderer: WebGLRenderer): void;
}
declare class clothSolverReset extends ObjectNamedFunction0 {
	static type(): string;
	func(object3D: Object3D): void;
}
declare class clothSolverStepSimulation extends ObjectNamedFunction5<[
	number,
	number,
	number,
	number,
	ClothMaterialUniformConfigRef
]> {
	static type(): string;
	func(object3D: Object3D, stepsCount: number, constraintInfluence: number, viscosity: number, spring: number, uniformConfigRef: ClothMaterialUniformConfigRef): void;
}
declare class clothSolverUpdateMaterial extends NamedFunction9<[
	Material,
	string,
	string,
	string,
	string,
	Vector2,
	Texture,
	Texture,
	Texture
]> {
	static type(): string;
	func(material: Material, tSizeName: string, tPosition0Name: string, tPosition1Name: string, tNormalName: string, tSize: Vector2, tPosition0: Texture, tPosition1: Texture, tNormal: Texture): void;
}
declare class clothCreateConstraint extends ObjectNamedFunction1<[
	number
]> {
	static type(): string;
	func(object3D: Object3D, index: number): void;
}
declare class clothDeleteConstraint extends ObjectNamedFunction0 {
	static type(): string;
	func(object3D: Object3D): void;
}
declare class clothConstraintSetPosition extends ObjectNamedFunction2<[
	Vector3,
	number
]> {
	static type(): string;
	func(object3D: Object3D, position: Vector3, lerp: number): void;
}
declare class colorSetRGB extends NamedFunction4<[
	Color,
	number,
	number,
	number
]> {
	static type(): string;
	func(color: Color, r: number, g: number, b: number): Color;
}
declare class hsvToRgb extends NamedFunction2<[
	Vector3,
	Color
]> {
	static type(): string;
	func(hsv: Vector3, target: Color): Color;
}
declare class softBodySolverStepSimulation extends ObjectNamedFunction4<[
	number,
	number,
	number,
	boolean
]> {
	static type(): string;
	func(object3D: Object3D, stepsCount: number, edgeCompliance: number, volumeCompliance: number, preciseCollisions: boolean): void;
}
declare class computeVelocity extends NamedFunction5<[
	Vector3,
	Vector3,
	number,
	number,
	Vector3
]> {
	static type(): string;
	func(velocity: Vector3, forces: Vector3, dt: number, drag: number, target: Vector3): Vector3;
}
declare class softBodySetPosition extends ObjectNamedFunction2<[
	Vector3,
	number
]> {
	static type(): string;
	func(object3D: Object3D, position: Vector3, lerp: number): void;
}
declare class softBodyMultiplyVelocity extends ObjectNamedFunction1<[
	number
]> {
	static type(): string;
	func(object3D: Object3D, mult: number): void;
}
declare class softBodyConstraintCreate extends ObjectNamedFunction2<[
	number,
	Ref<number>
]> {
	static type(): string;
	func(object3D: Object3D, index: number, constraintIdRef: Ref<number>): void;
}
declare class softBodyConstraintSetPosition extends ObjectNamedFunction3<[
	number,
	Vector3,
	number
]> {
	static type(): string;
	func(object3D: Object3D, constraintId: number, position: Vector3, lerp: number): void;
}
declare class softBodyConstraintDelete extends ObjectNamedFunction1<[
	number
]> {
	static type(): string;
	func(object3D: Object3D, constraintId: number): void;
}
declare class cookNode extends NamedFunction1<[
	string
]> {
	static type(): string;
	func(nodePath: string): void;
}
declare class getGeometryNodeObjects extends NamedFunction2<[
	BaseSopNodeType,
	Object3D[]
]> {
	static type(): string;
	async: boolean;
	func(node: BaseSopNodeType, objects: Object3D[]): Promise<void>;
}
declare class createObject extends ObjectNamedFunction1<[
	Object3D | undefined
]> {
	static type(): string;
	func(parent: Object3D, child: Object3D | undefined): void;
}
declare class createObjects extends ObjectNamedFunction1<[
	Object3D[]
]> {
	static type(): string;
	func(parent: Object3D, children: Object3D[]): void;
}
declare class objectDelete extends ObjectNamedFunction0 {
	static type(): string;
	func(object3D: Object3D): void;
}
declare class physicsWorldReset extends ObjectNamedFunction0 {
	static type(): string;
	func(object3D: Object3D): void;
}
declare class physicsWorldStepSimulation extends ObjectNamedFunction0 {
	static type(): string;
	func(object3D: Object3D): void;
}
declare class physicsDebugUpdate extends ObjectNamedFunction0 {
	static type(): string;
	func(object3D: Object3D): void;
}
declare class setPhysicsWorldGravity extends ObjectNamedFunction2<[
	Vector3,
	number
]> {
	static type(): string;
	func(object3D: Object3D, gravity: Vector3, lerp: number): void;
}
declare class getPhysicsRBD extends NamedFunction1<[
	string
]> {
	static type(): string;
	func(rbdId: string): Object3D | undefined;
}
declare class getPhysicsRBDCapsuleRadius extends ObjectNamedFunction0 {
	static type(): string;
	func(object3D: Object3D): number;
}
declare class getPhysicsRBDCapsuleHeight extends ObjectNamedFunction0 {
	static type(): string;
	func(object3D: Object3D): number;
}
declare class getPhysicsRBDConeHeight extends ObjectNamedFunction0 {
	static type(): string;
	func(object3D: Object3D): number;
}
declare class getPhysicsRBDConeRadius extends ObjectNamedFunction0 {
	static type(): string;
	func(object3D: Object3D): number;
}
declare class getPhysicsRBDCuboidSizes extends ObjectNamedFunction1<[
	Vector3
]> {
	static type(): string;
	func(object3D: Object3D, target: Vector3): Vector3;
}
declare class getPhysicsRBDCylinderHeight extends ObjectNamedFunction0 {
	static type(): string;
	func(object3D: Object3D): number;
}
declare class getPhysicsRBDCylinderRadius extends ObjectNamedFunction0 {
	static type(): string;
	func(object3D: Object3D): number;
}
declare class getPhysicsRBDSphereRadius extends ObjectNamedFunction0 {
	static type(): string;
	func(object3D: Object3D): number;
}
declare class setPhysicsRBDCapsuleProperty extends ObjectNamedFunction3<[
	number,
	number,
	boolean
]> {
	static type(): string;
	func(object3D: Object3D, scale: number, lerp: number, updateMatrix: boolean): void;
}
declare class setPhysicsRBDConeProperty extends ObjectNamedFunction4<[
	number,
	number,
	number,
	boolean
]> {
	static type(): string;
	func(object3D: Object3D, radius: number, height: number, lerp: number, updateMatrix: boolean): void;
}
declare class setPhysicsRBDCuboidProperty extends ObjectNamedFunction4<[
	Vector3,
	number,
	number,
	boolean
]> {
	static type(): string;
	func(object3D: Object3D, sizes: Vector3, size: number, lerp: number, updateMatrix: boolean): void;
}
declare class setPhysicsRBDCylinderProperty extends ObjectNamedFunction4<[
	number,
	number,
	number,
	boolean
]> {
	static type(): string;
	func(object3D: Object3D, radius: number, height: number, lerp: number, updateMatrix: boolean): void;
}
declare class setPhysicsRBDSphereProperty extends ObjectNamedFunction3<[
	number,
	number,
	boolean
]> {
	static type(): string;
	func(object3D: Object3D, radius: number, lerp: number, updateMatrix: boolean): void;
}
declare class getPhysicsRBDAngularVelocity extends ObjectNamedFunction1<[
	Vector3
]> {
	static type(): string;
	func(object3D: Object3D, target: Vector3): Vector3;
}
declare class getChildrenPhysicsRBDPropertiesAngularVelocity extends ObjectNamedFunction1<[
	Array<Vector3>
]> {
	static type(): string;
	func(object3D: Object3D, values: Vector3[]): Vector3[];
}
declare class getPhysicsRBDLinearVelocity extends ObjectNamedFunction1<[
	Vector3
]> {
	static type(): string;
	func(object3D: Object3D, target: Vector3): Vector3;
}
declare class getChildrenPhysicsRBDPropertiesLinearVelocity extends ObjectNamedFunction1<[
	Array<Vector3>
]> {
	static type(): string;
	func(object3D: Object3D, values: Vector3[]): Vector3[];
}
declare class getPhysicsRBDAngularDamping extends ObjectNamedFunction0 {
	static type(): string;
	func(object3D: Object3D): number;
}
declare class getChildrenPhysicsRBDPropertiesAngularDamping extends ObjectNamedFunction1<[
	Array<number>
]> {
	static type(): string;
	func(object3D: Object3D, values: number[]): number[];
}
declare class getPhysicsRBDLinearDamping extends ObjectNamedFunction0 {
	static type(): string;
	func(object3D: Object3D): number;
}
declare class getChildrenPhysicsRBDPropertiesLinearDamping extends ObjectNamedFunction1<[
	Array<number>
]> {
	static type(): string;
	func(object3D: Object3D, values: number[]): number[];
}
declare class getPhysicsRBDIsSleeping extends ObjectNamedFunction0 {
	static type(): string;
	func(object3D: Object3D): boolean;
}
declare class getChildrenPhysicsRBDPropertiesIsSleeping extends ObjectNamedFunction1<[
	Array<boolean>
]> {
	static type(): string;
	func(object3D: Object3D, values: boolean[]): boolean[];
}
declare class getPhysicsRBDIsMoving extends ObjectNamedFunction0 {
	static type(): string;
	func(object3D: Object3D): boolean;
}
declare class getChildrenPhysicsRBDPropertiesIsMoving extends ObjectNamedFunction1<[
	Array<boolean>
]> {
	static type(): string;
	func(object3D: Object3D, values: boolean[]): boolean[];
}
declare class setPhysicsRBDPosition extends ObjectNamedFunction2<[
	Vector3,
	number
]> {
	static type(): string;
	func(object3D: Object3D, position: Vector3, lerp: number): void;
}
declare class setPhysicsRBDRotation extends ObjectNamedFunction2<[
	Quaternion,
	number
]> {
	static type(): string;
	func(object3D: Object3D, quat: Quaternion, lerp: number): void;
}
declare class setPhysicsRBDAngularVelocity extends ObjectNamedFunction2<[
	Vector3,
	number
]> {
	static type(): string;
	func(object3D: Object3D, velocity: Vector3, lerp: number): void;
}
declare class setPhysicsRBDLinearVelocity extends ObjectNamedFunction2<[
	Vector3,
	number
]> {
	static type(): string;
	func(object3D: Object3D, velocity: Vector3, lerp: number): void;
}
declare class physicsRBDAddForce extends ObjectNamedFunction1<[
	Vector3
]> {
	static type(): string;
	func(object3D: Object3D, force: Vector3): void;
}
declare class physicsRBDAddForceAtPoint extends ObjectNamedFunction2<[
	Vector3,
	Vector3
]> {
	static type(): string;
	func(object3D: Object3D, force: Vector3, point: Vector3): void;
}
declare class physicsRBDAddTorque extends ObjectNamedFunction1<[
	Vector3
]> {
	static type(): string;
	func(object3D: Object3D, force: Vector3): void;
}
declare class physicsRBDApplyTorqueImpulse extends ObjectNamedFunction1<[
	Vector3
]> {
	static type(): string;
	func(object3D: Object3D, impulse: Vector3): void;
}
declare class physicsRBDApplyImpulse extends ObjectNamedFunction1<[
	Vector3
]> {
	static type(): string;
	func(object3D: Object3D, impulse: Vector3): void;
}
declare class physicsRBDApplyImpulseAtPoint extends ObjectNamedFunction2<[
	Vector3,
	Vector3
]> {
	static type(): string;
	func(object3D: Object3D, impulse: Vector3, point: Vector3): void;
}
declare class physicsRBDResetAll extends ObjectNamedFunction1<[
	boolean
]> {
	static type(): string;
	func(object3D: Object3D, wakeup: boolean): void;
}
declare class physicsRBDResetForces extends ObjectNamedFunction1<[
	boolean
]> {
	static type(): string;
	func(object3D: Object3D, wakeup: boolean): void;
}
declare class physicsRBDResetTorques extends ObjectNamedFunction1<[
	boolean
]> {
	static type(): string;
	func(object3D: Object3D, wakeup: boolean): void;
}
declare class createPhysicsRBD extends ObjectNamedFunction2<[
	Object3D,
	Ref<string>
]> {
	static type(): string;
	func(worldObject: Object3D, object: Object3D, rbdId: Ref<string>): void;
}
declare class createPhysicsRBDs extends ObjectNamedFunction2<[
	Object3D[],
	Ref<string[]>
]> {
	static type(): string;
	func(worldObject: Object3D, objects: Object3D[], rbdIds: Ref<string[]>): void;
}
declare class physicsRBDDelete extends ObjectNamedFunction0 {
	static type(): string;
	func(object3D: Object3D): void;
}
declare class createPhysicsRBDKinematicConstraint extends ObjectNamedFunction2<[
	Vector3,
	Ref<string>
]> {
	static type(): string;
	func(object3D: Object3D, anchor: Vector3, rbdIdRef: Ref<string>): void;
}
declare class deletePhysicsRBDKinematicConstraint extends ObjectNamedFunction0 {
	static type(): string;
	func(object3D: Object3D): void;
}
declare class deletePhysicsRBDConstraints extends ObjectNamedFunction0 {
	static type(): string;
	func(object3D: Object3D): void;
}
declare enum ScrollEvent {
	onUpdate = "onUpdate",
	onToggle = "onToggle",
	onEnter = "onEnter",
	onLeave = "onLeave",
	onEnterBack = "onEnterBack",
	onLeaveBack = "onLeaveBack"
}
type ScrollEventListener = () => void;
interface CreateScrollTriggerOptions {
	element: string;
	useViewport: boolean;
	scroller: string;
	displayMarkers: boolean;
	nodePath: string;
}
type CallbackByScrollEvent = Record<ScrollEvent, ScrollEventListener>;
declare class createScrollListener extends NamedFunction4<[
	CreateScrollTriggerOptions,
	CallbackByScrollEvent,
	ActorEvaluator,
	Ref<number>
]> {
	static type(): string;
	func(createOptions: CreateScrollTriggerOptions, listeners: CallbackByScrollEvent, evaluator: ActorEvaluator, progressRef: Ref<number>): void;
}
declare class crossVector2 extends NamedFunction2<[
	Vector2,
	Vector2
]> {
	static type(): string;
	func(v1: Vector2, v2: Vector2): number;
}
declare class crossVector3 extends NamedFunction3<[
	Vector3,
	Vector3,
	Vector3
]> {
	static type(): string;
	func(v1: Vector3, v2: Vector3, target: Vector3): Vector3;
}
type Vector3_8 = [
	Vector3,
	Vector3,
	Vector3,
	Vector3,
	Vector3,
	Vector3,
	Vector3,
	Vector3
];
declare class cubeLatticeDeform extends ObjectNamedFunction1<[
	Vector3_8
]> {
	static type(): string;
	func(object3D: Object3D, points: Vector3_8): void;
}
declare class cursorToUv extends NamedFunction2<[
	Vector2,
	Vector2
]> {
	static type(): string;
	func(cursor: Vector2, target: Vector2): Vector2;
}
declare class renderPixel extends ObjectNamedFunction5<[
	Material,
	Camera,
	Color,
	Vector2,
	Vector4
]> {
	private _renderTarget;
	private _renderScene;
	private _restoreContext;
	private _read;
	private _getDefaultCamera;
	static type(): string;
	func(object3D: Object3D, material: Material | null, camera: Camera, backgroundColor: Color, uv: Vector2, target: Vector4): Vector4;
	private _prepare;
	private _render;
	private _restore;
}
interface DebugLine {
	objectName: string;
	value: JsDataType;
	displayableValue: string;
}
interface DebugOptions {
	displayValue: boolean;
	displayFrame: boolean;
	displayTime: boolean;
	displayNodePath: boolean;
	message: string;
	bundleByObject: boolean;
}
declare class debug<T extends JsDataType> extends ObjectNamedFunction3<[
	string,
	T,
	DebugOptions
]> {
	static type(): string;
	func(object3D: Object3D, nodePath: string, input: T, debugOptions: DebugOptions): T;
}
declare class deviceOrientation extends NamedFunction1<[
	Quaternion
]> {
	static type(): string;
	func(target: Quaternion): Quaternion;
}
declare class distanceVector2 extends NamedFunction2<[
	Vector2,
	Vector2
]> {
	static type(): string;
	func(v1: Vector2, v2: Vector2): number;
}
declare class distanceVector3 extends NamedFunction2<[
	Vector3,
	Vector3
]> {
	static type(): string;
	func(v1: Vector3, v2: Vector3): number;
}
declare class divideNumber extends NamedFunction<Array<number>, Array<string>> {
	static type(): string;
	func(...args: Array<number>): number;
}
// @ts-ignore
type AvailableItem = Vector2 | Vector3 | Vector4;
declare class divideVectorNumber<V extends AvailableItem> extends NamedFunction2<[
	V,
	number
]> {
	static type(): string;
	func(vector: V, number: number): V;
}
declare class dotVector2 extends NamedFunction2<[
	Vector2,
	Vector2
]> {
	static type(): string;
	func(v1: Vector2, v2: Vector2): number;
}
declare class dotVector3 extends NamedFunction2<[
	Vector3,
	Vector3
]> {
	static type(): string;
	func(v1: Vector3, v2: Vector3): number;
}
declare class easeI2 extends NamedFunction1<[
	number
]> {
	static type(): string;
	func: (num: number) => number;
}
declare class easeO2 extends NamedFunction1<[
	number
]> {
	static type(): string;
	func: (num: number) => number;
}
declare class easeIO2 extends NamedFunction1<[
	number
]> {
	static type(): string;
	func: (num: number) => number;
}
declare class easeI3 extends NamedFunction1<[
	number
]> {
	static type(): string;
	func: (num: number) => number;
}
declare class easeO3 extends NamedFunction1<[
	number
]> {
	static type(): string;
	func: (num: number) => number;
}
declare class easeIO3 extends NamedFunction1<[
	number
]> {
	static type(): string;
	func: (num: number) => number;
}
declare class easeI4 extends NamedFunction1<[
	number
]> {
	static type(): string;
	func: (num: number) => number;
}
declare class easeO4 extends NamedFunction1<[
	number
]> {
	static type(): string;
	func: (num: number) => number;
}
declare class easeIO4 extends NamedFunction1<[
	number
]> {
	static type(): string;
	func: (num: number) => number;
}
declare class easeSinI extends NamedFunction1<[
	number
]> {
	static type(): string;
	func: (num: number) => number;
}
declare class easeSinO extends NamedFunction1<[
	number
]> {
	static type(): string;
	func: (num: number) => number;
}
declare class easeSinIO extends NamedFunction1<[
	number
]> {
	static type(): string;
	func: (num: number) => number;
}
declare class easeElasticI extends NamedFunction1<[
	number
]> {
	static type(): string;
	func: (num: number) => number;
}
declare class easeElasticO extends NamedFunction1<[
	number
]> {
	static type(): string;
	func: (num: number) => number;
}
declare class easeElasticIO extends NamedFunction1<[
	number
]> {
	static type(): string;
	func: (num: number) => number;
}
declare class eulerSetFromVector3 extends NamedFunction3<[
	Vector3,
	number | EulerOrder,
	Euler
]> {
	static type(): string;
	func(values: Vector3, orderIndex: number | EulerOrder, target: Euler): Euler;
}
declare class eulerSetFromQuaternion extends NamedFunction2<[
	Quaternion,
	Euler
]> {
	static type(): string;
	func(values: Quaternion, target: Euler): Euler;
}
interface lngLat {
	lng: number;
	lat: number;
}
declare class geolocationCurrentPositionRef extends NamedFunction0 {
	static type(): string;
	func(): Ref<lngLat>;
}
declare class geolocationLatitude extends NamedFunction0 {
	static type(): string;
	func(): number;
}
declare class geolocationLongitude extends NamedFunction0 {
	static type(): string;
	func(): number;
}
declare class geolocationGetCurrentPosition extends NamedFunction0 {
	static type(): string;
	func(): void;
}
declare class getActorNodeParamValue extends NamedFunction1<[
	string
]> {
	static type(): string;
	func(paramName: string): string | number | boolean | Vector3 | Vector2 | Vector4 | Color | RampValue | TypedParamPathParamValue | TypedNodePathParamValue | null | undefined;
}
declare class getChildrenAttributes extends ObjectNamedFunction3<[
	string,
	string,
	Array<AttribValue>
]> {
	static type(): string;
	func(object3D: Object3D, attribName: string, type: ParamConvertibleJsType, values: AttribValue[]): AttribValue[];
}
declare class getChildrenAttributesPrevious extends ObjectNamedFunction3<[
	string,
	string,
	Array<AttribValue>
]> {
	static type(): string;
	func(object3D: Object3D, attribName: string, type: ParamConvertibleJsType, values: AttribValue[]): AttribValue[];
}
declare class getChildrenAttributesRef extends ObjectNamedFunction3<[
	string,
	string,
	Array<Ref<AttribValue>>
]> {
	static type(): string;
	func(object3D: Object3D, attribName: string, type: ParamConvertibleJsType, values: Ref<AttribValue>[]): Ref<AttribValue>[];
}
interface PropertyType {
	position: Vector3;
	rotation: Euler;
	quaternion: Quaternion;
	scale: Vector3;
	matrix: Matrix4;
	visible: boolean;
	castShadow: boolean;
	receiveShadow: boolean;
	frustumCulled: boolean;
	up: Vector3;
	matrixAutoUpdate: boolean;
	material: Material;
}
declare class getObjectProperty extends ObjectNamedFunction1<[
	string
]> {
	static type(): string;
	func<K extends keyof PropertyType>(object3D: Object3D, propertyName: K): PropertyType[K];
}
declare class getObjectWorldPosition extends ObjectNamedFunction1<[
	Vector3
]> {
	static type(): string;
	func(object3D: Object3D, target: Vector3): Vector3;
}
declare class object3DLocalToWorld extends ObjectNamedFunction2<[
	Vector3,
	Vector3
]> {
	static type(): string;
	func(object3D: Object3D, position: Vector3, target: Vector3): Vector3;
}
declare class object3DWorldToLocal extends ObjectNamedFunction2<[
	Vector3,
	Vector3
]> {
	static type(): string;
	func(object3D: Object3D, position: Vector3, target: Vector3): Vector3;
}
declare class getChildrenPropertiesPosition extends ObjectNamedFunction1<[
	Array<Vector3>
]> {
	static type(): string;
	func: (object3D: Object3D<Event>, targets: Vector3[]) => Vector3[];
}
declare class getChildrenPropertiesQuaternion extends ObjectNamedFunction1<[
	Array<Quaternion>
]> {
	static type(): string;
	func: (object3D: Object3D<Event>, targets: Quaternion[]) => Quaternion[];
}
declare class getChildrenPropertiesScale extends ObjectNamedFunction1<[
	Array<Vector3>
]> {
	static type(): string;
	func: (object3D: Object3D<Event>, targets: Vector3[]) => Vector3[];
}
declare class getChildrenPropertiesUp extends ObjectNamedFunction1<[
	Array<Vector3>
]> {
	static type(): string;
	func: (object3D: Object3D<Event>, targets: Vector3[]) => Vector3[];
}
declare class getChildrenPropertiesVisible extends ObjectNamedFunction1<[
	Array<boolean>
]> {
	static type(): string;
	func: (object3D: Object3D<Event>, targets: boolean[]) => boolean[];
}
declare class getChildrenPropertiesMatrixAutoUpdate extends ObjectNamedFunction1<[
	Array<boolean>
]> {
	static type(): string;
	func: (object3D: Object3D<Event>, targets: boolean[]) => boolean[];
}
declare class getChildrenPropertiesCastShadow extends ObjectNamedFunction1<[
	Array<boolean>
]> {
	static type(): string;
	func: (object3D: Object3D<Event>, targets: boolean[]) => boolean[];
}
declare class getChildrenPropertiesReceiveShadow extends ObjectNamedFunction1<[
	Array<boolean>
]> {
	static type(): string;
	func: (object3D: Object3D<Event>, targets: boolean[]) => boolean[];
}
declare class getChildrenPropertiesFrustumCulled extends ObjectNamedFunction1<[
	Array<boolean>
]> {
	static type(): string;
	func: (object3D: Object3D<Event>, targets: boolean[]) => boolean[];
}
declare class setPerspectiveCameraFov extends ObjectNamedFunction3<[
	number,
	number,
	boolean
]> {
	static type(): string;
	func(object3D: Object3D, fov: number, lerp: number, updateProjectionMatrix: boolean): void;
}
declare class setPerspectiveCameraNearFar extends ObjectNamedFunction4<[
	number,
	number,
	number,
	boolean
]> {
	static type(): string;
	func(object3D: Object3D, near: number, far: number, lerp: number, updateProjectionMatrix: boolean): void;
}
declare class getDefaultCamera extends NamedFunction0 {
	static type(): string;
	func(): Camera;
}
declare class setCameraViewOffset extends ObjectNamedFunction2<[
	Vector2,
	Vector2
]> {
	static type(): string;
	func(object3D: Object3D, min: Vector2, max: Vector2): void;
}
declare class getGeometryPositions extends ObjectNamedFunction1<[
	Vector3[]
]> {
	static type(): string;
	func(object3D: Object3D, target: Vector3[]): Vector3[];
}
declare class getGeometryBoundingBox extends ObjectNamedFunction2<[
	boolean,
	Box3
]> {
	static type(): string;
	func(object3D: Object3D, forceCompute: boolean, target: Box3): Box3;
}
declare class setGeometryPositions extends ObjectNamedFunction5<[
	Vector3[],
	number,
	boolean,
	boolean,
	boolean
]> {
	static type(): string;
	func(object3D: Object3D, values: Vector3[], lerp: number, attributeNeedsUpdate: boolean, computeNormals: boolean, computeTangents: boolean): void;
}
declare class getIntersectionAttributeNumberNearest extends NamedFunction3<[
	Intersection | undefined,
	string,
	number
]> {
	static type(): string;
	func(intersection: Intersection | undefined, attribName: string, notFoundValue: number): number;
}
declare class getIntersectionAttributeNumberInterpolated extends NamedFunction3<[
	Intersection | undefined,
	string,
	number
]> {
	static type(): string;
	func(intersection: Intersection | undefined, attribName: string, notFoundValue: number): number;
}
declare class getIntersectionAttributeColorNearest extends NamedFunction4<[
	Intersection | undefined,
	string,
	Color,
	Color
]> {
	static type(): string;
	func(intersection: Intersection | undefined, attribName: string, notFoundValue: Color, target: Color): Color;
}
declare class getIntersectionAttributeColorInterpolated extends NamedFunction4<[
	Intersection | undefined,
	string,
	Color,
	Color
]> {
	static type(): string;
	func(intersection: Intersection | undefined, attribName: string, notFoundValue: Color, target: Color): Color;
}
declare class getIntersectionAttributeStringNearest extends NamedFunction2<[
	Intersection | undefined,
	string
]> {
	static type(): string;
	func(intersection: Intersection | undefined, attribName: string): string;
}
declare class getIntersectionAttributeVector2Nearest extends NamedFunction4<[
	Intersection | undefined,
	string,
	Vector2,
	Vector2
]> {
	static type(): string;
	func(intersection: Intersection | undefined, attribName: string, notFoundValue: Vector2, target: Vector2): Vector2;
}
declare class getIntersectionAttributeVector2Interpolated extends NamedFunction4<[
	Intersection | undefined,
	string,
	Vector2,
	Vector2
]> {
	static type(): string;
	func(intersection: Intersection | undefined, attribName: string, notFoundValue: Vector2, target: Vector2): Vector2;
}
declare class getIntersectionAttributeVector3Nearest extends NamedFunction4<[
	Intersection | undefined,
	string,
	Vector3,
	Vector3
]> {
	static type(): string;
	func(intersection: Intersection | undefined, attribName: string, notFoundValue: Vector3, target: Vector3): Vector3;
}
declare class getIntersectionAttributeVector3Interpolated extends NamedFunction4<[
	Intersection | undefined,
	string,
	Vector3,
	Vector3
]> {
	static type(): string;
	func(intersection: Intersection | undefined, attribName: string, notFoundValue: Vector3, target: Vector3): Vector3;
}
declare class getIntersectionAttributeVector4Nearest extends NamedFunction4<[
	Intersection | undefined,
	string,
	Vector4,
	Vector4
]> {
	static type(): string;
	func(intersection: Intersection | undefined, attribName: string, notFoundValue: Vector4, target: Vector4): Vector4;
}
declare class getIntersectionAttributeVector4Interpolated extends NamedFunction4<[
	Intersection | undefined,
	string,
	Vector4,
	Vector4
]> {
	static type(): string;
	func(intersection: Intersection | undefined, attribName: string, notFoundValue: Vector4, target: Vector4): Vector4;
}
declare class getIntersectionPropertyDistance extends NamedFunction1<[
	Intersection | undefined
]> {
	static type(): string;
	func(intersection: Intersection | undefined): number;
}
declare class getIntersectionPropertyObject extends ObjectNamedFunction1<[
	Intersection | undefined
]> {
	static type(): string;
	func(object3D: Object3D, intersection: Intersection | undefined): Object3D;
}
declare class getIntersectionPropertyPoint extends NamedFunction2<[
	Intersection | undefined,
	Vector3
]> {
	static type(): string;
	func(intersection: Intersection | undefined, target: Vector3): Vector3;
}
declare class getIntersectionPropertyNormal extends NamedFunction2<[
	Intersection | undefined,
	Vector3
]> {
	static type(): string;
	func(intersection: Intersection | undefined, target: Vector3): Vector3;
}
declare class getIntersectionPropertyUv extends NamedFunction2<[
	Intersection | undefined,
	Vector2
]> {
	static type(): string;
	func(intersection: Intersection | undefined, target: Vector2): Vector2;
}
declare class getTexture extends NamedFunction1<[
	string
]> {
	static type(): string;
	func(nodePath: string): Texture | undefined;
}
declare class getMaterial extends NamedFunction1<[
	string
]> {
	static type(): string;
	func(nodePath: string): Material | undefined;
}
declare class getNode extends NamedFunction1<[
	string
]> {
	static type(): string;
	func(nodePath: string): BaseNodeType;
}
declare class getObject extends ObjectNamedFunction2<[
	boolean,
	string
]> {
	static type(): string;
	func(object3D: Object3D, getCurrentObject: boolean, mask: string): Object3D<Event> | ObjectContent<CoreObjectType>;
}
declare class getObjectAttribute<T extends ParamConvertibleJsType> extends ObjectNamedFunction3<[
	string,
	T,
	JsIConnectionPointTypeToDataTypeMap[T]
]> {
	static type(): string;
	func(object3D: Object3D, attribName: string, type: T, defaultValue: JsIConnectionPointTypeToDataTypeMap[T]): AttribValue;
}
declare class getObjectAttributeAutoDefault<T extends ParamConvertibleJsType> extends ObjectNamedFunction2<[
	string,
	T
]> {
	static type(): string;
	func(object3D: Object3D, attribName: string, type: T): AttribValue;
}
declare class getObjectAttributePrevious extends ObjectNamedFunction2<[
	string,
	ParamConvertibleJsType
]> {
	static type(): string;
	func(object3D: Object3D, attribName: string, type: ParamConvertibleJsType): AttribValue;
}
declare class getObjectAttributeRef extends ObjectNamedFunction2<[
	string,
	ParamConvertibleJsType
]> {
	static type(): string;
	func(object3D: Object3D, attribName: string, type: ParamConvertibleJsType): Ref<AttribValue>;
}
declare class getObjectChild extends ObjectNamedFunction1<[
	number
]> {
	static type(): string;
	func(object3D: Object3D, index: number): Object3D;
}
declare class getObjectHoveredIntersection extends ObjectNamedFunction0 {
	static type(): string;
	func(object3D: Object3D): Intersection;
}
declare class getObjectHoveredState extends ObjectNamedFunction4<[
	boolean,
	number,
	number,
	Ref<Intersection | null>
]> {
	static type(): string;
	func(object3D: Object3D, traverseChildren: boolean, pointsThreshold: number, lineThreshold: number, intersectionRef: Ref<Intersection | null>): boolean;
}
// @ts-ignore
type Listener = () => void;
declare class objectDispatchEvent extends ObjectNamedFunction1<[
	string
]> {
	static type(): string;
	func(object3D: Object3D, eventName: string): void;
}
declare class getObjectLastDispatchedEventName extends ObjectNamedFunction0 {
	static type(): string;
	func(object3D: Object3D): string;
}
declare class objectAddEventListeners extends ObjectNamedFunction3<[
	string,
	ActorEvaluator,
	Listener
]> {
	static type(): string;
	func(object3D: Object3D, eventNamesList: string, evaluator: ActorEvaluator, boundListener: Listener): string;
}
declare class objectAddOnBeforeDeleteEventListener extends ObjectNamedFunction2<[
	ActorEvaluator,
	Listener
]> {
	static type(): string;
	func(object3D: Object3D, evaluator: ActorEvaluator, boundListener: Listener): string;
}
declare class getObjectUserData extends ObjectNamedFunction1<[
	string
]> {
	static type(): string;
	func(object3D: Object3D, userDataName: string): any;
}
declare class getParam extends NamedFunction1<[
	string
]> {
	static type(): string;
	func(paramPath: string): BaseParamType;
}
declare class setParamBoolean extends NamedFunction2<[
	BooleanParam,
	boolean
]> {
	static type(): string;
	func(param: BooleanParam, value: boolean): void;
}
declare class setParamBooleanToggle extends NamedFunction1<[
	BooleanParam
]> {
	static type(): string;
	func(param: BooleanParam): void;
}
declare class setParamColor extends NamedFunction3<[
	ColorParam,
	Color,
	number
]> {
	static type(): string;
	func(param: ColorParam, value: Color, lerp: number): void;
}
declare class setParamFloat extends NamedFunction3<[
	FloatParam,
	number,
	number
]> {
	static type(): string;
	func(param: FloatParam, value: number, lerp: number): void;
}
declare class setParamInteger extends NamedFunction3<[
	IntegerParam,
	number,
	number
]> {
	static type(): string;
	func(param: IntegerParam, value: number, lerp: number): void;
}
declare class setParamString extends NamedFunction2<[
	StringParam,
	string
]> {
	static type(): string;
	func(param: StringParam, value: string): void;
}
declare class setParamVector2 extends NamedFunction3<[
	Vector2Param,
	Vector2,
	number
]> {
	static type(): string;
	func(param: Vector2Param, value: Vector2, lerp: number): void;
}
declare class setParamVector3 extends NamedFunction3<[
	Vector3Param,
	Vector3,
	number
]> {
	static type(): string;
	func(param: Vector3Param, value: Vector3, lerp: number): void;
}
declare class setParamVector4 extends NamedFunction3<[
	Vector4Param,
	Vector4,
	number
]> {
	static type(): string;
	func(param: Vector4Param, value: Vector4, lerp: number): void;
}
declare class pressButtonParam extends NamedFunction1<[
	ButtonParam
]> {
	static type(): string;
	func(param: ButtonParam): void;
}
declare class getParent extends ObjectNamedFunction0 {
	static type(): string;
	func(object3D: Object3D): Object3D<Event>;
}
declare class planeSet extends NamedFunction3<[
	Vector3,
	number,
	Plane
]> {
	static type(): string;
	func(normal: Vector3, constant: number, target: Plane): Plane;
}
declare class getPlaneNormal extends NamedFunction2<[
	Plane,
	Vector3
]> {
	static type(): string;
	func(plane: Plane, target: Vector3): Vector3;
}
declare class getPlaneConstant extends NamedFunction1<[
	Plane
]> {
	static type(): string;
	func(plane: Plane): number;
}
declare class setPlayerInput extends ObjectNamedFunction1<[
	boolean
]> {
	static type(): string;
	func(object3D: Object3D, stopEventsPropagation: boolean): void;
}
declare class getPlayerInputDataLeft extends ObjectNamedFunction0 {
	static type(): string;
	func(object3D: Object3D): boolean;
}
declare class getPlayerInputDataRight extends ObjectNamedFunction0 {
	static type(): string;
	func(object3D: Object3D): boolean;
}
declare class getPlayerInputDataForward extends ObjectNamedFunction0 {
	static type(): string;
	func(object3D: Object3D): boolean;
}
declare class getPlayerInputDataBackward extends ObjectNamedFunction0 {
	static type(): string;
	func(object3D: Object3D): boolean;
}
declare class getPlayerInputDataRun extends ObjectNamedFunction0 {
	static type(): string;
	func(object3D: Object3D): boolean;
}
declare class getPlayerInputDataJump extends ObjectNamedFunction0 {
	static type(): string;
	func(object3D: Object3D): boolean;
}
interface PlayerUpdateOptions {
	collider: Object3D;
	speed: number;
	runAllowed: boolean;
	runSpeedMult: number;
	jumpAllowed: boolean;
	jumpStrength: number;
	physicsSteps: number;
	gravity: Vector3;
	capsuleRadius: number;
	capsuleHeight: number;
	left: boolean;
	right: boolean;
	backward: boolean;
	forward: boolean;
	run: boolean;
	jump: boolean;
}
declare class playerSimpleUpdate extends ObjectNamedFunction1<[
	PlayerUpdateOptions
]> {
	static type(): string;
	func(object3D: Object3D, options: PlayerUpdateOptions): void;
}
declare class getPlayerSimplePropertyOnGround extends ObjectNamedFunction0 {
	static type(): string;
	func(object3D: Object3D): boolean;
}
declare class getPlayerSimplePropertyVelocity extends ObjectNamedFunction1<[
	Vector3
]> {
	static type(): string;
	func(object3D: Object3D, target: Vector3): Vector3;
}
declare class getPointIndex extends ObjectNamedFunction0 {
	static type(): string;
	func(object3D: Object3D): number;
}
declare class setPointIndex extends ObjectNamedFunction1<[
	number
]> {
	static type(): string;
	func(object3D: Object3D, ptnum: number): number;
}
declare class getPointPosition extends ObjectNamedFunction2<[
	number,
	Vector3
]> {
	static type(): string;
	func(object3D: Object3D, ptnum: number, target: Vector3): Vector3;
}
declare class getPointAttributeNumber extends ObjectNamedFunction3<[
	number,
	string,
	number
]> {
	static type(): string;
	func(object3D: Object3D, ptnum: number, attribName: string, defaultValue: number): number;
}
declare class getPointAttributeVector2 extends ObjectNamedFunction4<[
	number,
	string,
	Vector2,
	Vector2
]> {
	static type(): string;
	func(object3D: Object3D, ptnum: number, attribName: string, defaultValue: Vector2, target: Vector2): Vector2;
}
declare class getPointAttributeVector3 extends ObjectNamedFunction4<[
	number,
	string,
	Vector3,
	Vector3
]> {
	static type(): string;
	func(object3D: Object3D, ptnum: number, attribName: string, defaultValue: Vector3, target: Vector3): Vector3;
}
declare class getPointAttributeVector4 extends ObjectNamedFunction4<[
	number,
	string,
	Vector4,
	Vector4
]> {
	static type(): string;
	func(object3D: Object3D, ptnum: number, attribName: string, defaultValue: Vector4, target: Vector4): Vector4;
}
declare class getPointInstancePosition extends ObjectNamedFunction2<[
	number,
	Vector3
]> {
	static type(): string;
	func(object3D: Object3D, ptnum: number, target: Vector3): Vector3;
}
declare class getPointInstanceQuaternion extends ObjectNamedFunction2<[
	number,
	Quaternion
]> {
	static type(): string;
	func(object3D: Object3D, ptnum: number, target: Quaternion): Quaternion;
}
declare class getPointInstanceScale extends ObjectNamedFunction2<[
	number,
	Vector3
]> {
	static type(): string;
	func(object3D: Object3D, ptnum: number, target: Vector3): Vector3;
}
declare class raySet extends NamedFunction3<[
	Vector3,
	Vector3,
	Ray
]> {
	static type(): string;
	func(origin: Vector3, direction: Vector3, target: Ray): Ray;
}
declare class rayFromCamera extends ObjectNamedFunction3<[
	number,
	number,
	Ray
]> {
	static type(): string;
	private _getDefaultCamera;
	func(object3D: Object3D, x: number, y: number, target: Ray): Ray;
}
declare class getRayOrigin extends NamedFunction2<[
	Ray,
	Vector3
]> {
	static type(): string;
	func(ray: Ray, target: Vector3): Vector3;
}
declare class getRayDirection extends NamedFunction2<[
	Ray,
	Vector3
]> {
	static type(): string;
	func(ray: Ray, target: Vector3): Vector3;
}
declare class rayIntersectBox3 extends NamedFunction3<[
	Ray,
	Box3,
	Vector3
]> {
	static type(): string;
	func(ray: Ray, box: Box3, target: Vector3): Vector3;
}
declare class rayIntersectsBox3 extends NamedFunction2<[
	Ray,
	Box3
]> {
	static type(): string;
	func(ray: Ray, box: Box3): boolean;
}
declare class rayIntersectObject3D extends NamedFunction3<[
	Ray,
	Object3D,
	boolean
]> {
	static type(): string;
	func(ray: Ray, object3D: Object3D, recursive: boolean): Intersection;
}
declare class rayIntersectsObject3D extends NamedFunction3<[
	Ray,
	Object3D,
	boolean
]> {
	static type(): string;
	func(ray: Ray, object3D: Object3D, recursive: boolean): boolean;
}
declare class rayIntersectPlane extends NamedFunction3<[
	Ray,
	Plane,
	Vector3
]> {
	static type(): string;
	func(ray: Ray, plane: Plane, target: Vector3): Vector3;
}
declare class rayIntersectsPlane extends NamedFunction2<[
	Ray,
	Plane
]> {
	static type(): string;
	func(ray: Ray, plane: Plane): boolean;
}
declare class rayDistanceToPlane extends NamedFunction2<[
	Ray,
	Plane
]> {
	static type(): string;
	func(ray: Ray, plane: Plane): number;
}
declare class rayIntersectSphere extends NamedFunction3<[
	Ray,
	Sphere,
	Vector3
]> {
	static type(): string;
	func(ray: Ray, sphere: Sphere, target: Vector3): Vector3;
}
declare class rayIntersectsSphere extends NamedFunction2<[
	Ray,
	Sphere
]> {
	static type(): string;
	func(ray: Ray, sphere: Sphere): boolean;
}
declare class getSibbling extends ObjectNamedFunction1<[
	number
]> {
	static type(): string;
	func(object3D: Object3D, offset: number): Object3D<Event>;
}
declare class sphereSet extends NamedFunction3<[
	Vector3,
	number,
	Sphere
]> {
	static type(): string;
	func(center: Vector3, radius: number, target: Sphere): Sphere;
}
declare class getSphereCenter extends NamedFunction2<[
	Sphere,
	Vector3
]> {
	static type(): string;
	func(sphere: Sphere, target: Vector3): Vector3;
}
declare class getSphereRadius extends NamedFunction1<[
	Sphere
]> {
	static type(): string;
	func(sphere: Sphere): number;
}
declare class trackHand extends ObjectNamedFunction1<[
	Texture
]> {
	static type(): string;
	func(object3D: Object3D, texture: Texture): void;
}
declare class trackHandGetNormalizedLandmarks extends ObjectNamedFunction2<[
	number,
	Vector4[]
]> {
	static type(): string;
	func(object3D: Object3D, handIndex: number, target: Vector4[]): Vector4[];
}
declare class trackHandGetWorldLandmarks extends ObjectNamedFunction2<[
	number,
	Vector4[]
]> {
	static type(): string;
	func(object3D: Object3D, handIndex: number, target: Vector4[]): Vector4[];
}
declare class getTrackedHandThumbDirection extends NamedFunction2<[
	Vector4[],
	Vector3
]> {
	static type(): string;
	func(values: Vector4[], target: Vector3): Vector3;
}
declare class getTrackedHandIndexDirection extends NamedFunction2<[
	Vector4[],
	Vector3
]> {
	static type(): string;
	func(values: Vector4[], target: Vector3): Vector3;
}
declare class getTrackedHandMiddleDirection extends NamedFunction2<[
	Vector4[],
	Vector3
]> {
	static type(): string;
	func(values: Vector4[], target: Vector3): Vector3;
}
declare class getTrackedHandRingDirection extends NamedFunction2<[
	Vector4[],
	Vector3
]> {
	static type(): string;
	func(values: Vector4[], target: Vector3): Vector3;
}
declare class getTrackedHandPinkyDirection extends NamedFunction2<[
	Vector4[],
	Vector3
]> {
	static type(): string;
	func(values: Vector4[], target: Vector3): Vector3;
}
declare class getWebXRARHitDetected extends NamedFunction0 {
	static type(): string;
	func(): boolean;
}
declare class getWebXRARHitMatrix extends NamedFunction1<[
	Matrix4
]> {
	static type(): string;
	func(target: Matrix4): Matrix4;
}
declare class getWebXRARHitPosition extends NamedFunction1<[
	Vector3
]> {
	static type(): string;
	func(target: Vector3): Vector3;
}
declare class getWebXRARHitQuaternion extends NamedFunction1<[
	Quaternion
]> {
	static type(): string;
	func(target: Quaternion): Quaternion;
}
declare class getWebXRControllerObject extends ObjectNamedFunction1<[
	number
]> {
	static type(): string;
	func(object3D: Object3D, controllerIndex: number): Object3D;
}
declare class getWebXRControllerRay extends ObjectNamedFunction2<[
	number,
	Ray
]> {
	static type(): string;
	func(object3D: Object3D, controllerIndex: number, target: Ray): Ray;
}
declare class getWebXRControllerHasAngularVelocity extends ObjectNamedFunction1<[
	number
]> {
	static type(): string;
	func(object3D: Object3D, controllerIndex: number): boolean;
}
declare class getWebXRControllerAngularVelocity extends ObjectNamedFunction2<[
	number,
	Vector3
]> {
	static type(): string;
	func(object3D: Object3D, controllerIndex: number, target: Vector3): Vector3;
}
declare class getWebXRControllerHasLinearVelocity extends ObjectNamedFunction1<[
	number
]> {
	static type(): string;
	func(object3D: Object3D, controllerIndex: number): boolean;
}
declare class getWebXRControllerLinearVelocity extends ObjectNamedFunction2<[
	number,
	Vector3
]> {
	static type(): string;
	func(object3D: Object3D, controllerIndex: number, target: Vector3): Vector3;
}
declare class getWebXRTrackedMarkerMatrix extends NamedFunction1<[
	Matrix4
]> {
	static type(): string;
	func(target: Matrix4): Matrix4;
}
declare abstract class GlobalsTimeFunction0 extends NamedFunction0 {
	constructor(node: BaseNodeType, shadersCollectionController?: JsLinesCollectionController);
}
declare abstract class PointerEventsTimeFunction0 extends NamedFunction0 {
	protected pointerEventsController: PointerEventsController;
	constructor(node: BaseNodeType, shadersCollectionController?: JsLinesCollectionController);
}
declare class globalsTime extends GlobalsTimeFunction0 {
	static type(): string;
	func(): number;
}
declare class globalsTimeDelta extends GlobalsTimeFunction0 {
	static type(): string;
	func(): number;
}
declare class globalsRaycaster extends PointerEventsTimeFunction0 {
	static type(): string;
	func(): Raycaster;
}
declare class globalsRayFromCursor extends PointerEventsTimeFunction0 {
	static type(): string;
	func(): Ray;
}
declare class globalsCursor extends PointerEventsTimeFunction0 {
	static type(): string;
	func(): Vector2;
}
declare class isTouchDevice extends NamedFunction0 {
	static type(): string;
	func(): boolean;
}
declare class keyboardEventMatchesConfig extends NamedFunction5<[
	string,
	number,
	number,
	number,
	number
]> {
	static type(): string;
	func(keyCodes: string, _ctrlKey: number, _shiftKey: number, _altKey: number, _metaKey: number): boolean;
}
declare class lengthVector<V extends Vector2 | Vector3 | Vector4> extends NamedFunction1<[
	V
]> {
	static type(): string;
	func(src: V): number;
}
declare class lengthVectorArray<V extends Vector2 | Vector3 | Vector4> extends NamedFunction2<[
	Array<V>,
	Array<number>
]> {
	static type(): string;
	func(src: V[], target: number[]): number[];
}
declare class lerpNumber extends NamedFunction3<[
	number,
	number,
	number
]> {
	static type(): string;
	func(v1: number, v2: number, lerp: number): number;
}
declare class lerpColor extends NamedFunction4<[
	Color,
	Color,
	number,
	Color
]> {
	static type(): string;
	func(v1: Color, v2: Color, lerp: number, target: Color): Color;
}
declare class lerpQuaternion extends NamedFunction4<[
	Quaternion,
	Quaternion,
	number,
	Quaternion
]> {
	static type(): string;
	func(v1: Quaternion, v2: Quaternion, lerp: number, target: Quaternion): Quaternion;
}
declare class lerpVector2 extends NamedFunction4<[
	Vector2,
	Vector2,
	number,
	Vector2
]> {
	static type(): string;
	func(v1: Vector2, v2: Vector2, lerp: number, target: Vector2): Vector2;
}
declare class lerpVector3 extends NamedFunction4<[
	Vector3,
	Vector3,
	number,
	Vector3
]> {
	static type(): string;
	func(v1: Vector3, v2: Vector3, lerp: number, target: Vector3): Vector3;
}
declare class lerpVector4 extends NamedFunction4<[
	Vector4,
	Vector4,
	number,
	Vector4
]> {
	static type(): string;
	func(v1: Vector4, v2: Vector4, lerp: number, target: Vector4): Vector4;
}
declare class manhattanDistanceVector2 extends NamedFunction2<[
	Vector2,
	Vector2
]> {
	static type(): string;
	func(v1: Vector2, v2: Vector2): number;
}
declare class manhattanDistanceVector3 extends NamedFunction2<[
	Vector3,
	Vector3
]> {
	static type(): string;
	func(v1: Vector3, v2: Vector3): number;
}
declare class matrix4LookAt extends NamedFunction4<[
	Vector3,
	Vector3,
	Vector3,
	Matrix4
]> {
	static type(): string;
	func(eye: Vector3, lookAtTarget: Vector3, up: Vector3, target: Matrix4): Matrix4;
}
declare class matrix4MakeTranslation extends NamedFunction2<[
	Vector3,
	Matrix4
]> {
	static type(): string;
	func(t: Vector3, target: Matrix4): Matrix4;
}
declare class matrix4Multiply extends NamedFunction3<[
	Matrix4,
	Matrix4,
	Matrix4
]> {
	static type(): string;
	func(m1: Matrix4, m2: Matrix4, target: Matrix4): Matrix4;
}
declare class maxLengthVector2 extends NamedFunction3<[
	Vector2,
	number,
	Vector2
]> {
	static type(): string;
	func(src: Vector2, maxLength: number, target: Vector2): Vector2;
}
declare class maxLengthVector3 extends NamedFunction3<[
	Vector3,
	number,
	Vector3
]> {
	static type(): string;
	func(src: Vector3, maxLength: number, target: Vector3): Vector3;
}
declare class maxLengthVector4 extends NamedFunction3<[
	Vector4,
	number,
	Vector4
]> {
	static type(): string;
	func(src: Vector4, maxLength: number, target: Vector4): Vector4;
}
declare class multNumber extends NamedFunction<Array<number>, Array<string>> {
	static type(): string;
	func(...args: Array<number>): number;
}
// @ts-ignore
type AvailableItem = Vector2 | Vector3 | Vector4;
declare class multVector<V extends AvailableItem> extends NamedFunction<Array<V>, Array<string>> {
	static type(): string;
	func(...args: Array<V>): V;
}
declare class multVectorNumber<V extends AvailableItem> extends NamedFunction2<[
	V,
	number
]> {
	static type(): string;
	func(vector: V, number: number): V;
}
declare class multScalarColor extends NamedFunction3<[
	Color,
	number,
	Color
]> {
	static type(): string;
	func(src: Color, scalar: number, target: Color): Color;
}
declare class multScalarVector2 extends NamedFunction3<[
	Vector2,
	number,
	Vector2
]> {
	static type(): string;
	func(src: Vector2, scalar: number, target: Vector2): Vector2;
}
declare class multScalarVector3 extends NamedFunction3<[
	Vector3,
	number,
	Vector3
]> {
	static type(): string;
	func(src: Vector3, scalar: number, target: Vector3): Vector3;
}
declare class multScalarVector4 extends NamedFunction3<[
	Vector4,
	number,
	Vector4
]> {
	static type(): string;
	func(src: Vector4, scalar: number, target: Vector4): Vector4;
}
declare class multScalarVectorArray<V extends Color | Vector2 | Vector3 | Vector4> extends NamedFunction3<[
	Array<V>,
	number,
	Array<V>
]> {
	static type(): string;
	func(src: V[], scalar: number, target: V[]): V[];
}
declare class multScalarArrayVectorArray<V extends Color | Vector2 | Vector3 | Vector4> extends NamedFunction3<[
	Array<V>,
	number[],
	Array<V>
]> {
	static type(): string;
	func(src: V[], scalar: number[], target: V[]): V[];
}
declare class nearestPosition extends NamedFunction3<[
	Vector3,
	Array<Vector3>,
	Vector3
]> {
	static type(): string;
	func(v3: Vector3, positions: Vector3[], target: Vector3): Vector3;
}
declare class noiseImprovedVector3 extends NamedFunction7<[
	Vector3,
	number,
	Vector3,
	Vector3,
	number,
	number,
	number
]> {
	static type(): string;
	func(position: Vector3, amp: number, freq: Vector3, offset: Vector3, octaves: number, ampMult: number, freqMult: number): number;
}
declare class noiseSimplexVector2 extends NamedFunction8<[
	Vector2,
	number,
	Vector2,
	Vector2,
	number,
	number,
	number,
	number
]> {
	static type(): string;
	func(position: Vector2, amp: number, freq: Vector2, offset: Vector2, octaves: number, ampMult: number, freqMult: number, seed: number): number;
}
declare class noiseSimplexVector3 extends NamedFunction8<[
	Vector3,
	number,
	Vector3,
	Vector3,
	number,
	number,
	number,
	number
]> {
	static type(): string;
	func(position: Vector3, amp: number, freq: Vector3, offset: Vector3, octaves: number, ampMult: number, freqMult: number, seed: number): number;
}
declare class noiseSimplexVector4 extends NamedFunction8<[
	Vector4,
	number,
	Vector4,
	Vector4,
	number,
	number,
	number,
	number
]> {
	static type(): string;
	func(position: Vector4, amp: number, freq: Vector4, offset: Vector4, octaves: number, ampMult: number, freqMult: number, seed: number): number;
}
declare class normalizeVector2 extends NamedFunction2<[
	Vector2,
	Vector2
]> {
	static type(): string;
	func(src: Vector2, target: Vector2): Vector2;
}
declare class normalizeVector3 extends NamedFunction2<[
	Vector3,
	Vector3
]> {
	static type(): string;
	func(src: Vector3, target: Vector3): Vector3;
}
declare class normalizeVector4 extends NamedFunction2<[
	Vector4,
	Vector4
]> {
	static type(): string;
	func(src: Vector4, target: Vector4): Vector4;
}
declare class setObjectCastShadow extends ObjectNamedFunction1<[
	boolean
]> {
	static type(): string;
	func(object3D: Object3D, castShadow: boolean): void;
}
declare class setObjectReceiveShadow extends ObjectNamedFunction1<[
	boolean
]> {
	static type(): string;
	func(object3D: Object3D, receiveShadow: boolean): void;
}
declare class setObjectFrustumCulled extends ObjectNamedFunction1<[
	boolean
]> {
	static type(): string;
	func(object3D: Object3D, frustumCulled: boolean): void;
}
declare class setObjectMatrix extends ObjectNamedFunction1<[
	Matrix4
]> {
	static type(): string;
	func(object3D: Object3D, matrix: Matrix4): void;
}
declare class setObjectMatrixAutoUpdate extends ObjectNamedFunction1<[
	boolean
]> {
	static type(): string;
	func(object3D: Object3D, matrixAutoUpdate: boolean): void;
}
declare class setObjectVisible extends ObjectNamedFunction1<[
	boolean
]> {
	static type(): string;
	func(object3D: Object3D, visible: boolean): void;
}
declare class objectUpdateMatrix extends ObjectNamedFunction0 {
	static type(): string;
	func(object3D: Object3D): void;
}
declare class objectUpdateWorldMatrix extends ObjectNamedFunction2<[
	boolean,
	boolean
]> {
	static type(): string;
	func(object3D: Object3D, updateParents: boolean, updateChildren: boolean): void;
}
declare enum PerformanceChangeEvent {
	aboveThreshold = "aboveThreshold",
	belowThreshold = "belowThreshold"
}
type CallbackByPerformanceEvent = Record<PerformanceChangeEvent, Function>;
declare class onPerformanceChange extends NamedFunction3<[
	number,
	CallbackByPerformanceEvent,
	ActorEvaluator
]> {
	static type(): string;
	func(threshold: number, callbacks: CallbackByPerformanceEvent, evaluator: ActorEvaluator): void;
}
type GPUComputationConfigRef = Record<string, Ref<Texture>>;
interface GPUComputationRendererVariable {
	name: string;
	renderTargets: WebGLRenderTarget[];
	material: ShaderMaterial;
}
declare class GPUComputationRenderer {
	constructor(x: number, y: number, renderer: AbstractRenderer);
	compute(configRef: GPUComputationConfigRef): void;
	init(): GPUComputationConfigRef | undefined;
	dispose(): void;
	setDataType(type: TextureDataType): void;
	addVariable(name: string, fragment_shader: string, variable: DataTexture): GPUComputationRendererVariable;
	setVariableDependencies(variable: GPUComputationRendererVariable, vars: GPUComputationRendererVariable[]): void;
	renderTexture(texture: DataTexture, render_target: WebGLRenderTarget): void;
	createTexture(): DataTexture;
	getCurrentRenderTarget(variable: GPUComputationRendererVariable): WebGLRenderTarget;
}
declare class particlesSystemReset extends ObjectNamedFunction0 {
	static type(): string;
	func(object3D: Object3D): void;
}
declare class particlesSystemStepSimulation extends ObjectNamedFunction1<[
	GPUComputationConfigRef
]> {
	static type(): string;
	func(object3D: Object3D, configRef: GPUComputationConfigRef): void;
}
declare class playAnimation extends ObjectNamedFunction1<[
	string
]> {
	static type(): string;
	func(object3D: Object3D, nodePath: string): Promise<void>;
}
declare class playerMode extends NamedFunction0 {
	static type(): string;
	func(): boolean;
}
interface PlayerUpdateOptions {
	speed: number;
	runAllowed: boolean;
	runSpeedMult: number;
	jumpAllowed: boolean;
	jumpStrength: number;
	resetIfBelowThreshold: boolean;
	resetThreshold: number;
	left: boolean;
	right: boolean;
	backward: boolean;
	forward: boolean;
	run: boolean;
	jump: boolean;
}
declare class playerPhysicsUpdate extends ObjectNamedFunction1<[
	PlayerUpdateOptions
]> {
	static type(): string;
	func(object3D: Object3D, options: PlayerUpdateOptions): void;
}
declare class setObjectPolarTransform extends ObjectNamedFunction4<[
	Vector3,
	number,
	number,
	number
]> {
	static type(): string;
	func(object3D: Object3D, center: Vector3, longitude: number, latitude: number, depth: number): void;
}
declare class polarTransform extends NamedFunction5<[
	Vector3,
	number,
	number,
	number,
	Matrix4
]> {
	static type(): string;
	func(center: Vector3, longitude: number, latitude: number, depth: number, target: Matrix4): Matrix4;
}
declare class previousValuePrimitive<T extends boolean | number | string> extends NamedFunction3<[
	string,
	number,
	T
]> {
	static type(): string;
	func(nodePath: string, offset: number, newValue: T): T;
}
declare class previousValueColor extends NamedFunction3<[
	string,
	number,
	Color
]> {
	static type(): string;
	func(nodePath: string, offset: number, newValue: Color): Color;
}
declare class previousValueVector2 extends NamedFunction3<[
	string,
	number,
	Vector2
]> {
	static type(): string;
	func(nodePath: string, offset: number, newValue: Vector2): Vector2;
}
declare class previousValueVector3 extends NamedFunction3<[
	string,
	number,
	Vector3
]> {
	static type(): string;
	func(nodePath: string, offset: number, newValue: Vector3): Vector3;
}
declare class previousValueVector4 extends NamedFunction3<[
	string,
	number,
	Vector4
]> {
	static type(): string;
	func(nodePath: string, offset: number, newValue: Vector4): Vector4;
}
declare class quaternionSetFromEuler extends NamedFunction2<[
	Euler,
	Quaternion
]> {
	static type(): string;
	func(euler: Euler, target: Quaternion): Quaternion;
}
declare class quaternionSetFromAxisAngle extends NamedFunction3<[
	Vector3,
	number,
	Quaternion
]> {
	static type(): string;
	func(axis: Vector3, angle: number, target: Quaternion): Quaternion;
}
declare class quaternionAngleTo extends NamedFunction2<[
	Quaternion,
	Quaternion
]> {
	static type(): string;
	func(src: Quaternion, to: Quaternion): number;
}
declare class quaternionSlerp extends NamedFunction4<[
	Quaternion,
	Quaternion,
	number,
	Quaternion
]> {
	static type(): string;
	func(q1: Quaternion, q2: Quaternion, lerp: number, target: Quaternion): Quaternion;
}
declare class rotateWithAxisAngle extends NamedFunction4<[
	Vector3,
	Vector3,
	number,
	Vector3
]> {
	static type(): string;
	func(vector: Vector3, axis: Vector3, angle: number, target: Vector3): Vector3;
}
declare class rotateWithQuaternion extends NamedFunction3<[
	Vector3,
	Quaternion,
	Vector3
]> {
	static type(): string;
	func(vector: Vector3, quat: Quaternion, target: Vector3): Vector3;
}
declare class SDF2DBox extends NamedFunction3<[
	Vector2,
	Vector2,
	Vector2
]> {
	static type(): string;
	func(p: Vector2, center: Vector2, size: Vector2): number;
}
declare class SDF2DCircle extends NamedFunction3<[
	Vector2,
	Vector2,
	number
]> {
	static type(): string;
	func(p: Vector2, center: Vector2, radius: number): number;
}
declare class SDF2DCross extends NamedFunction5<[
	Vector2,
	Vector2,
	number,
	number,
	number
]> {
	static type(): string;
	func(p: Vector2, center: Vector2, length: number, width: number, radius: number): number;
}
declare class SDF2DHeart extends NamedFunction2<[
	Vector2,
	Vector2
]> {
	static type(): string;
	func(p: Vector2, center: Vector2): number;
}
declare class SDF2DRoundedX extends NamedFunction4<[
	Vector2,
	Vector2,
	number,
	number
]> {
	static type(): string;
	func(p: Vector2, center: Vector2, w: number, r: number): number;
}
declare function _SDFBox(p: Vector3, center: Vector3, sizes: Vector3, size: number): number;
declare class SDFBox extends NamedFunction4<[
	Vector3,
	Vector3,
	Vector3,
	number
]> {
	static type(): string;
	func: typeof _SDFBox;
}
declare function _SDFPlane(p: Vector3, center: Vector3, normal: Vector3, offset: number): number;
declare class SDFPlane extends NamedFunction4<[
	Vector3,
	Vector3,
	Vector3,
	number
]> {
	static type(): string;
	func: typeof _SDFPlane;
}
declare function _SDFSphere(p: Vector3, center: Vector3, s: number): number;
declare class SDFSphere extends NamedFunction3<[
	Vector3,
	Vector3,
	number
]> {
	static type(): string;
	func: typeof _SDFSphere;
}
declare function _SDFTorus(p: Vector3, center: Vector3, radius1: number, radius2: number): number;
declare class SDFTorus extends NamedFunction4<[
	Vector3,
	Vector3,
	number,
	number
]> {
	static type(): string;
	func: typeof _SDFTorus;
}
declare function _SDFTube(p: Vector3, center: Vector3, radius: number): number;
declare class SDFTube extends NamedFunction3<[
	Vector3,
	Vector3,
	number
]> {
	static type(): string;
	func: typeof _SDFTube;
}
declare class SDFUnion extends NamedFunction2<[
	number,
	number
]> {
	static type(): string;
	func(d1: number, d2: number): number;
}
declare class SDFSubtract extends NamedFunction2<[
	number,
	number
]> {
	static type(): string;
	func(d1: number, d2: number): number;
}
declare class SDFIntersect extends NamedFunction2<[
	number,
	number
]> {
	static type(): string;
	func(d1: number, d2: number): number;
}
declare class SDFSmoothUnion extends NamedFunction3<[
	number,
	number,
	number
]> {
	static type(): string;
	func(d1: number, d2: number, k: number): number;
}
declare class SDFSmoothSubtract extends NamedFunction3<[
	number,
	number,
	number
]> {
	static type(): string;
	func(d1: number, d2: number, k: number): number;
}
declare class SDFSmoothIntersect extends NamedFunction3<[
	number,
	number,
	number
]> {
	static type(): string;
	func(d1: number, d2: number, k: number): number;
}
declare class SDFElongateFast extends NamedFunction4<[
	Vector3,
	Vector3,
	Vector3,
	Vector3
]> {
	static type(): string;
	func(p: Vector3, center: Vector3, h: Vector3, target: Vector3): Vector3;
}
declare class SDFElongateSlow extends NamedFunction4<[
	Vector3,
	Vector3,
	Vector3,
	Vector3
]> {
	static type(): string;
	func(p: Vector3, center: Vector3, h: Vector3, target: Vector3): Vector3;
}
declare class SDFOnion extends NamedFunction2<[
	number,
	number
]> {
	static type(): string;
	func(sdf: number, thickness: number): number;
}
declare class SDFTransform extends NamedFunction4<[
	Vector3,
	Vector3,
	Vector3,
	Vector3
]> {
	static type(): string;
	func(p: Vector3, t: Vector3, r: Vector3, target: Vector3): Vector3;
}
declare class SDFRevolutionX extends NamedFunction4<[
	Vector3,
	Vector3,
	number,
	Vector2
]> {
	static type(): string;
	func(p: Vector3, center: Vector3, o: number, target: Vector2): Vector2;
}
declare class SDFRevolutionY extends NamedFunction4<[
	Vector3,
	Vector3,
	number,
	Vector2
]> {
	static type(): string;
	func(p: Vector3, center: Vector3, o: number, target: Vector2): Vector2;
}
declare class SDFRevolutionZ extends NamedFunction4<[
	Vector3,
	Vector3,
	number,
	Vector2
]> {
	static type(): string;
	func(p: Vector3, center: Vector3, o: number, target: Vector2): Vector2;
}
declare class CSS2DObject extends Object3D {
	element: HTMLDivElement;
	readonly isCSS2DObject = true;
	constructor(element?: HTMLDivElement);
	copy(source: CSS2DObject, recursive: boolean): this;
}
declare class CSS3DObject extends Object3D {
	element: HTMLDivElement;
	readonly isCSS3DObject = true;
	constructor(element?: HTMLDivElement);
	copy(source: CSS3DObject, recursive: boolean): this;
}
type CSSObject = CSS2DObject | CSS3DObject;
declare class setCSSObjectClass extends ObjectNamedFunction2<[
	string,
	boolean
]> {
	static type(): string;
	func(CSSObject: CSSObject, className: string, addRemove: boolean): void;
}
declare class setGeometryInstancePositions extends ObjectNamedFunction3<[
	Array<Vector3>,
	number,
	boolean
]> {
	static type(): string;
	func(object3D: Object3D, newValues: Vector3[], lerp: number, attributeNeedsUpdate: boolean): void;
}
declare class setGeometryInstanceQuaternions extends ObjectNamedFunction3<[
	Array<Quaternion>,
	number,
	boolean
]> {
	static type(): string;
	func(object3D: Object3D, newValues: Quaternion[], lerp: number, attributeNeedsUpdate: boolean): void;
}
declare class setGeometryInstanceScales extends ObjectNamedFunction4<[
	Array<Vector3>,
	number[],
	number,
	boolean
]> {
	static type(): string;
	func(object3D: Object3D, scaleValues: Vector3[], multValues: number[], lerp: number, attributeNeedsUpdate: boolean): void;
}
declare class setGeometryInstanceTransforms extends ObjectNamedFunction6<[
	Array<Vector3>,
	Array<Quaternion>,
	Array<Vector3>,
	number[],
	number,
	boolean
]> {
	static type(): string;
	func(object3D: Object3D, positions: Vector3[], quaternions: Quaternion[], scaleValues: Vector3[], multValues: number[], lerp: number, attributeNeedsUpdate: boolean): void;
}
declare class setGeometryInstanceAttributeFloat extends ObjectNamedFunction4<[
	string,
	Array<number>,
	number,
	boolean
]> {
	static type(): string;
	func(object3D: Object3D, attribName: string, newValues: number[], lerp: number, attributeNeedsUpdate: boolean): void;
}
declare class setGeometryInstanceAttributeColor extends ObjectNamedFunction4<[
	string,
	Array<Color>,
	number,
	boolean
]> {
	static type(): string;
	func(object3D: Object3D, attribName: string, newValues: Color[], lerp: number, attributeNeedsUpdate: boolean): void;
}
declare class setGeometryInstanceAttributeQuaternion extends ObjectNamedFunction4<[
	string,
	Array<Quaternion>,
	number,
	boolean
]> {
	static type(): string;
	func(object3D: Object3D, attribName: string, newValues: Quaternion[], lerp: number, attributeNeedsUpdate: boolean): void;
}
declare class setGeometryInstanceAttributeVector2 extends ObjectNamedFunction4<[
	string,
	Array<Vector2>,
	number,
	boolean
]> {
	static type(): string;
	func(object3D: Object3D, attribName: string, newValues: Vector2[], lerp: number, attributeNeedsUpdate: boolean): void;
}
declare class setGeometryInstanceAttributeVector3 extends ObjectNamedFunction4<[
	string,
	Array<Vector3>,
	number,
	boolean
]> {
	static type(): string;
	func(object3D: Object3D, attribName: string, newValues: Vector3[], lerp: number, attributeNeedsUpdate: boolean): void;
}
declare class setGeometryInstanceAttributeVector4 extends ObjectNamedFunction4<[
	string,
	Array<Vector4>,
	number,
	boolean
]> {
	static type(): string;
	func(object3D: Object3D, attribName: string, newValues: Vector4[], lerp: number, attributeNeedsUpdate: boolean): void;
}
declare class setObjectMaterial extends ObjectNamedFunction1<[
	Material
]> {
	static type(): string;
	func(object3D: Object3D, material: Material): void;
}
declare class setObjectMaterialColor extends ObjectNamedFunction2<[
	Color,
	number
]> {
	static type(): string;
	func(object3D: Object3D, color: Color, lerp: number): void;
}
declare class setMaterialColor extends NamedFunction3<[
	Material,
	Color,
	number
]> {
	static type(): string;
	func(material: Material, color: Color, lerp: number): void;
}
declare class setMaterialEmissiveColor extends NamedFunction3<[
	Material,
	Color,
	number
]> {
	static type(): string;
	func(material: Material, color: Color, lerp: number): void;
}
declare const setMaterialMap_base: {
	new (node: BaseNodeType, shadersCollectionController?: JsLinesCollectionController | undefined): {
		func(material: Material, texture: Texture): void;
		async: boolean;
		asString(args_0: string, args_1: string): string;
		type(): string;
		readonly scene: PolyScene;
		readonly jsNode?: BaseJsNodeType | undefined;
		readonly functionNode: AssemblerControllerNode<BaseJsShaderAssembler>;
		readonly timeController: TimeController;
		readonly node: BaseNodeType;
		readonly shadersCollectionController?: JsLinesCollectionController | undefined;
	};
	type(): string;
};
declare class setMaterialMap extends setMaterialMap_base {
}
declare const setMaterialAlphaMap_base: {
	new (node: BaseNodeType, shadersCollectionController?: JsLinesCollectionController | undefined): {
		func(material: Material, texture: Texture): void;
		async: boolean;
		asString(args_0: string, args_1: string): string;
		type(): string;
		readonly scene: PolyScene;
		readonly jsNode?: BaseJsNodeType | undefined;
		readonly functionNode: AssemblerControllerNode<BaseJsShaderAssembler>;
		readonly timeController: TimeController;
		readonly node: BaseNodeType;
		readonly shadersCollectionController?: JsLinesCollectionController | undefined;
	};
	type(): string;
};
declare class setMaterialAlphaMap extends setMaterialAlphaMap_base {
}
declare const setMaterialAOMap_base: {
	new (node: BaseNodeType, shadersCollectionController?: JsLinesCollectionController | undefined): {
		func(material: Material, texture: Texture): void;
		async: boolean;
		asString(args_0: string, args_1: string): string;
		type(): string;
		readonly scene: PolyScene;
		readonly jsNode?: BaseJsNodeType | undefined;
		readonly functionNode: AssemblerControllerNode<BaseJsShaderAssembler>;
		readonly timeController: TimeController;
		readonly node: BaseNodeType;
		readonly shadersCollectionController?: JsLinesCollectionController | undefined;
	};
	type(): string;
};
declare class setMaterialAOMap extends setMaterialAOMap_base {
}
declare const setMaterialDisplacementMap_base: {
	new (node: BaseNodeType, shadersCollectionController?: JsLinesCollectionController | undefined): {
		func(material: Material, texture: Texture): void;
		async: boolean;
		asString(args_0: string, args_1: string): string;
		type(): string;
		readonly scene: PolyScene;
		readonly jsNode?: BaseJsNodeType | undefined;
		readonly functionNode: AssemblerControllerNode<BaseJsShaderAssembler>;
		readonly timeController: TimeController;
		readonly node: BaseNodeType;
		readonly shadersCollectionController?: JsLinesCollectionController | undefined;
	};
	type(): string;
};
declare class setMaterialDisplacementMap extends setMaterialDisplacementMap_base {
}
declare const setMaterialEnvMap_base: {
	new (node: BaseNodeType, shadersCollectionController?: JsLinesCollectionController | undefined): {
		func(material: Material, texture: Texture): void;
		async: boolean;
		asString(args_0: string, args_1: string): string;
		type(): string;
		readonly scene: PolyScene;
		readonly jsNode?: BaseJsNodeType | undefined;
		readonly functionNode: AssemblerControllerNode<BaseJsShaderAssembler>;
		readonly timeController: TimeController;
		readonly node: BaseNodeType;
		readonly shadersCollectionController?: JsLinesCollectionController | undefined;
	};
	type(): string;
};
declare class setMaterialEnvMap extends setMaterialEnvMap_base {
}
declare const setMaterialEmissiveMap_base: {
	new (node: BaseNodeType, shadersCollectionController?: JsLinesCollectionController | undefined): {
		func(material: Material, texture: Texture): void;
		async: boolean;
		asString(args_0: string, args_1: string): string;
		type(): string;
		readonly scene: PolyScene;
		readonly jsNode?: BaseJsNodeType | undefined;
		readonly functionNode: AssemblerControllerNode<BaseJsShaderAssembler>;
		readonly timeController: TimeController;
		readonly node: BaseNodeType;
		readonly shadersCollectionController?: JsLinesCollectionController | undefined;
	};
	type(): string;
};
declare class setMaterialEmissiveMap extends setMaterialEmissiveMap_base {
}
declare const setMaterialMetalnessMap_base: {
	new (node: BaseNodeType, shadersCollectionController?: JsLinesCollectionController | undefined): {
		func(material: Material, texture: Texture): void;
		async: boolean;
		asString(args_0: string, args_1: string): string;
		type(): string;
		readonly scene: PolyScene;
		readonly jsNode?: BaseJsNodeType | undefined;
		readonly functionNode: AssemblerControllerNode<BaseJsShaderAssembler>;
		readonly timeController: TimeController;
		readonly node: BaseNodeType;
		readonly shadersCollectionController?: JsLinesCollectionController | undefined;
	};
	type(): string;
};
declare class setMaterialMetalnessMap extends setMaterialMetalnessMap_base {
}
declare const setMaterialRoughnessMap_base: {
	new (node: BaseNodeType, shadersCollectionController?: JsLinesCollectionController | undefined): {
		func(material: Material, texture: Texture): void;
		async: boolean;
		asString(args_0: string, args_1: string): string;
		type(): string;
		readonly scene: PolyScene;
		readonly jsNode?: BaseJsNodeType | undefined;
		readonly functionNode: AssemblerControllerNode<BaseJsShaderAssembler>;
		readonly timeController: TimeController;
		readonly node: BaseNodeType;
		readonly shadersCollectionController?: JsLinesCollectionController | undefined;
	};
	type(): string;
};
declare class setMaterialRoughnessMap extends setMaterialRoughnessMap_base {
}
declare class setMaterialOpacity extends NamedFunction3<[
	Material,
	number,
	number
]> {
	static type(): string;
	func(material: Material, opacity: number, lerp: number): void;
}
declare class setMaterialUniformNumber extends NamedFunction6<[
	Material,
	string,
	number,
	number,
	boolean,
	boolean
]> {
	static type(): string;
	func(material: Material, uniformName: string, value: number, lerp: number, addPrefix: boolean, printWarnings: boolean): void;
}
type VectorColorUniform = Color | Vector2 | Vector3 | Vector4;
declare class setMaterialUniformVectorColor extends NamedFunction6<[
	Material,
	string,
	VectorColorUniform,
	number,
	boolean,
	boolean
]> {
	static type(): string;
	func(material: Material, uniformName: string, value: VectorColorUniform, lerp: number, addPrefix: boolean, printWarnings: boolean): void;
}
declare class setMaterialUniformTexture extends NamedFunction5<[
	Material,
	string,
	Texture,
	boolean,
	boolean
]> {
	static type(): string;
	func(material: Material, uniformName: string, value: Texture, addPrefix: boolean, printWarnings: boolean): void;
}
declare class setObjectAttribute extends ObjectNamedFunction4<[
	string,
	number,
	AttribValue,
	ParamConvertibleJsType
]> {
	static type(): string;
	func(object3D: Object3D, attribName: string, lerp: number, newValue: AttribValue, type: ParamConvertibleJsType): void;
}
declare class setObjectLookAt extends ObjectNamedFunction5<[
	Vector3,
	Vector3,
	number,
	boolean,
	boolean
]> {
	static type(): string;
	func(object3D: Object3D, targetPosition: Vector3, up: Vector3, lerp: number, invertDirection: boolean, updateMatrix: boolean): void;
}
declare class setObjectPosition extends ObjectNamedFunction3<[
	Vector3,
	number,
	boolean
]> {
	static type(): string;
	func(object3D: Object3D, position: Vector3, lerp: number, updateMatrix: boolean): void;
}
declare class setObjectQuaternion extends ObjectNamedFunction3<[
	Quaternion,
	number,
	boolean
]> {
	static type(): string;
	func(object3D: Object3D, quaternion: Quaternion, lerp: number, updateMatrix: boolean): void;
}
declare class setObjectRotation extends ObjectNamedFunction3<[
	Euler,
	number,
	boolean
]> {
	static type(): string;
	func(object3D: Object3D, euler: Euler, lerp: number, updateMatrix: boolean): void;
}
declare class setObjectScale extends ObjectNamedFunction4<[
	Vector3,
	number,
	number,
	boolean
]> {
	static type(): string;
	func(object3D: Object3D, scale: Vector3, mult: number, lerp: number, updateMatrix: boolean): void;
}
declare class setPointPosition extends ObjectNamedFunction3<[
	number,
	Vector3,
	number
]> {
	static type(): string;
	func: (object3D: Object3D<Event>, ptnum: number, newValue: Vector3, lerp: number) => void;
}
declare class setPointAttributeNumber extends ObjectNamedFunction4<[
	string,
	number,
	number,
	number
]> {
	static type(): string;
	func: (object3D: Object3D<Event>, attribName: string, ptnum: number, newValue: number, lerp: number) => void;
}
declare class setPointAttributeColor extends ObjectNamedFunction4<[
	string,
	number,
	Color,
	number
]> {
	static type(): string;
	func: (object3D: Object3D<Event>, attribName: string, ptnum: number, newValue: Color, lerp: number) => void;
}
declare class setPointAttributeVector2 extends ObjectNamedFunction4<[
	string,
	number,
	Vector2,
	number
]> {
	static type(): string;
	func: (object3D: Object3D<Event>, attribName: string, ptnum: number, newValue: Vector2, lerp: number) => void;
}
declare class setPointAttributeVector3 extends ObjectNamedFunction4<[
	string,
	number,
	Vector3,
	number
]> {
	static type(): string;
	func: (object3D: Object3D<Event>, attribName: string, ptnum: number, newValue: Vector3, lerp: number) => void;
}
declare class setPointAttributeVector4 extends ObjectNamedFunction4<[
	string,
	number,
	Vector4,
	number
]> {
	static type(): string;
	func: (object3D: Object3D<Event>, attribName: string, ptnum: number, newValue: Vector4, lerp: number) => void;
}
declare class setPointInstanceLookAt extends ObjectNamedFunction4<[
	number,
	Vector3,
	Vector3,
	number
]> {
	static type(): string;
	func(object3D: Object3D, ptnum: number, targetPosition: Vector3, up: Vector3, lerp: number): void;
}
declare class setPointInstancePosition extends ObjectNamedFunction3<[
	number,
	Vector3,
	number
]> {
	static type(): string;
	func: (object3D: Object3D<Event>, ptnum: number, newValue: Vector3, lerp: number) => void;
}
declare class setPointInstanceQuaternion extends ObjectNamedFunction3<[
	number,
	Quaternion,
	number
]> {
	static type(): string;
	func: (object3D: Object3D<Event>, ptnum: number, newValue: Quaternion, lerp: number) => void;
}
declare class setPointInstanceScale extends ObjectNamedFunction4<[
	number,
	Vector3,
	number,
	number
]> {
	static type(): string;
	func: (object3D: Object3D<Event>, ptnum: number, newValue: Vector3, mult: number, lerp: number) => void;
}
declare class setSpotLightIntensity extends ObjectNamedFunction2<[
	number,
	number
]> {
	static type(): string;
	func(object3D: Object3D, intensity: number, lerp: number): void;
}
declare class setViewer extends NamedFunction2<[
	string,
	boolean
]> {
	static type(): string;
	func(className: string, addClass: boolean): void;
}
declare class setViewerControls extends NamedFunction1<[
	boolean
]> {
	static type(): string;
	func(active: boolean): void;
}
declare function _sizzleVec3XY(src: Vector3, target: Vector2): Vector2;
declare class sizzleVec3XY extends NamedFunction2<[
	Vector3,
	Vector2
]> {
	static type(): string;
	func: typeof _sizzleVec3XY;
}
declare function _sizzleVec3XZ(src: Vector3, target: Vector2): Vector2;
declare class sizzleVec3XZ extends NamedFunction2<[
	Vector3,
	Vector2
]> {
	static type(): string;
	func: typeof _sizzleVec3XZ;
}
declare function _sizzleVec3YZ(src: Vector3, target: Vector2): Vector2;
declare class sizzleVec3YZ extends NamedFunction2<[
	Vector3,
	Vector2
]> {
	static type(): string;
	func: typeof _sizzleVec3YZ;
}
declare class sizzleVec4XYZ extends NamedFunction2<[
	Vector4,
	Vector3
]> {
	static type(): string;
	func(src: Vector4, target: Vector3): Vector3;
}
declare class sizzleVec4XYZArray extends NamedFunction2<[
	Vector4[],
	Vector3[]
]> {
	static type(): string;
	func(src: Vector4[], target: Vector3[]): Vector3[];
}
declare class sizzleVec4WArray extends NamedFunction2<[
	Vector4[],
	number[]
]> {
	static type(): string;
	func(src: Vector4[], target: number[]): number[];
}
declare class sleep extends NamedFunction1<[
	number
]> {
	static type(): string;
	async: boolean;
	func(delay: number): Promise<void>;
}
declare class subtractNumber extends NamedFunction<Array<number>, Array<string>> {
	static type(): string;
	func(...args: Array<number>): number;
}
// @ts-ignore
type AvailableItem = Vector2 | Vector3 | Vector4;
declare class subtractVector<V extends AvailableItem> extends NamedFunction<Array<V>, Array<string>> {
	static type(): string;
	func(...args: Array<V>): V;
}
declare class subtractVectorNumber<V extends AvailableItem> extends NamedFunction2<[
	V,
	number
]> {
	static type(): string;
	func(vector: V, number: number): V;
}
declare class trackFace extends ObjectNamedFunction1<[
	Texture
]> {
	static type(): string;
	func(object3D: Object3D, texture: Texture): void;
}
declare class trackFaceGetLandmarks extends ObjectNamedFunction2<[
	number,
	Vector4[]
]> {
	static type(): string;
	func(object3D: Object3D, faceIndex: number, target: Vector4[]): Vector4[];
}
declare class triggerFilter extends NamedFunction1<[
	boolean
]> {
	static type(): string;
	func(condition: boolean): boolean;
	asString(condition: string): string;
}
declare class triggerTwoWaySwitch extends NamedFunction3<[
	boolean,
	Function,
	Function
]> {
	static type(): string;
	func(condition: boolean, _func0: Function, _func1: Function): void;
}
declare class triggerSwitch extends NamedFunction2<[
	number,
	Array<Function>
]> {
	static type(): string;
	func(index: number, _functions: Array<Function>): void;
}
declare class vector3AngleTo extends NamedFunction2<[
	Vector3,
	Vector3
]> {
	static type(): string;
	func(v1: Vector3, v2: Vector3): number;
}
declare class vector3ProjectOnPlane extends NamedFunction3<[
	Vector3,
	Vector3,
	Vector3
]> {
	static type(): string;
	func(src: Vector3, planeNormal: Vector3, target: Vector3): Vector3;
}
declare class vector3Project extends NamedFunction3<[
	Vector3,
	Object3D,
	Vector3
]> {
	static type(): string;
	private _getDefaultCamera;
	func(src: Vector3, object3D: Object3D, target: Vector3): Vector3;
}
declare class vector3Unproject extends NamedFunction3<[
	Vector3,
	Object3D,
	Vector3
]> {
	static type(): string;
	private _getDefaultCamera;
	func(src: Vector3, object3D: Object3D, target: Vector3): Vector3;
}
interface NamedFunctionMap {
	addAudioStopEventListener: addAudioStopEventListener;
	addNumber: addNumber;
	addVector: addVector<Vector2 | Vector3 | Vector4>;
	addVectorNumber: addVectorNumber<Vector2 | Vector3 | Vector4>;
	addVideoEventListener: addVideoEventListener;
	andArrays: andArrays;
	andBooleans: andBooleans;
	animationActionCrossFade: animationActionCrossFade;
	animationActionFadeIn: animationActionFadeIn;
	animationActionFadeOut: animationActionFadeOut;
	animationActionPlay: animationActionPlay;
	animationActionStop: animationActionStop;
	animationMixerUpdate: animationMixerUpdate;
	arrayElementPrimitive: arrayElementPrimitive<PrimitiveArrayElement>;
	arrayElementVector: arrayElementVector<Vector2 | Vector3 | Vector4>;
	arrayLength: arrayLength;
	arrayPopPrimitive: arrayPopPrimitive<PrimitiveArrayElement>;
	arrayPopVector: arrayPopVector<Vector2 | Vector3 | Vector4>;
	arrayShiftPrimitive: arrayShiftPrimitive<PrimitiveArrayElement>;
	arrayShiftVector: arrayShiftVector<Vector2 | Vector3 | Vector4>;
	boolToInt: boolToInt;
	box3ContainsPoint: box3ContainsPoint;
	box3IntersectsBox3: box3IntersectsBox3;
	box3Set: box3Set;
	box3SetFromObject: box3SetFromObject;
	catmullRomCurve3GetPoint: catmullRomCurve3GetPoint;
	channelFloat: channelFloat;
	channelValueFloat: channelValueFloat;
	channelValueVector2: channelValueVector2;
	channelValueVector3: channelValueVector3;
	channelValueVector4: channelValueVector4;
	channelVector2: channelVector2;
	channelVector3: channelVector3;
	channelVector4: channelVector4;
	clamp: clamp;
	clothConstraintSetPosition: clothConstraintSetPosition;
	clothCreateConstraint: clothCreateConstraint;
	clothDeleteConstraint: clothDeleteConstraint;
	clothSolverReset: clothSolverReset;
	clothSolverStepSimulation: clothSolverStepSimulation;
	clothSolverUpdateMaterial: clothSolverUpdateMaterial;
	colorSetRGB: colorSetRGB;
	colorToVec3: colorToVec3;
	complement: complement;
	computeVelocity: computeVelocity;
	cookNode: cookNode;
	createObject: createObject;
	createObjects: createObjects;
	createPhysicsRBD: createPhysicsRBD;
	createPhysicsRBDKinematicConstraint: createPhysicsRBDKinematicConstraint;
	createPhysicsRBDs: createPhysicsRBDs;
	createScrollListener: createScrollListener;
	crossVector2: crossVector2;
	crossVector3: crossVector3;
	cubeLatticeDeform: cubeLatticeDeform;
	cursorToUv: cursorToUv;
	debug: debug<any>;
	degToRad: degToRad;
	deletePhysicsRBDConstraints: deletePhysicsRBDConstraints;
	deletePhysicsRBDKinematicConstraint: deletePhysicsRBDKinematicConstraint;
	deviceOrientation: deviceOrientation;
	distanceVector2: distanceVector2;
	distanceVector3: distanceVector3;
	divideNumber: divideNumber;
	divideVectorNumber: divideVectorNumber<Vector2 | Vector3 | Vector4>;
	dotVector2: dotVector2;
	dotVector3: dotVector3;
	easeElasticI: easeElasticI;
	easeElasticIO: easeElasticIO;
	easeElasticO: easeElasticO;
	easeI2: easeI2;
	easeI3: easeI3;
	easeI4: easeI4;
	easeIO2: easeIO2;
	easeIO3: easeIO3;
	easeIO4: easeIO4;
	easeO2: easeO2;
	easeO3: easeO3;
	easeO4: easeO4;
	easeSinI: easeSinI;
	easeSinIO: easeSinIO;
	easeSinO: easeSinO;
	elementsToArrayPrimitive: elementsToArrayPrimitive<PrimitiveArrayElement>;
	elementsToArrayVector: elementsToArrayVector<VectorArrayElement>;
	eulerSetFromQuaternion: eulerSetFromQuaternion;
	eulerSetFromVector3: eulerSetFromVector3;
	fit: fit;
	fitClamp: fitClamp;
	floatToColor: floatToColor;
	floatToInt: floatToInt;
	floatToVec2: floatToVec2;
	floatToVec3: floatToVec3;
	floatToVec4: floatToVec4;
	geolocationCurrentPositionRef: geolocationCurrentPositionRef;
	geolocationGetCurrentPosition: geolocationGetCurrentPosition;
	geolocationLatitude: geolocationLatitude;
	geolocationLongitude: geolocationLongitude;
	getActorNodeParamValue: getActorNodeParamValue;
	getAnimationAction: getAnimationAction;
	getAnimationMixer: getAnimationMixer;
	getBox3Center: getBox3Center;
	getBox3Max: getBox3Max;
	getBox3Min: getBox3Min;
	getChildrenAttributes: getChildrenAttributes;
	getChildrenAttributesPrevious: getChildrenAttributesPrevious;
	getChildrenAttributesRef: getChildrenAttributesRef;
	getChildrenPhysicsRBDPropertiesAngularDamping: getChildrenPhysicsRBDPropertiesAngularDamping;
	getChildrenPhysicsRBDPropertiesAngularVelocity: getChildrenPhysicsRBDPropertiesAngularVelocity;
	getChildrenPhysicsRBDPropertiesIsMoving: getChildrenPhysicsRBDPropertiesIsMoving;
	getChildrenPhysicsRBDPropertiesIsSleeping: getChildrenPhysicsRBDPropertiesIsSleeping;
	getChildrenPhysicsRBDPropertiesLinearDamping: getChildrenPhysicsRBDPropertiesLinearDamping;
	getChildrenPhysicsRBDPropertiesLinearVelocity: getChildrenPhysicsRBDPropertiesLinearVelocity;
	getChildrenPropertiesCastShadow: getChildrenPropertiesCastShadow;
	getChildrenPropertiesFrustumCulled: getChildrenPropertiesFrustumCulled;
	getChildrenPropertiesMatrixAutoUpdate: getChildrenPropertiesMatrixAutoUpdate;
	getChildrenPropertiesPosition: getChildrenPropertiesPosition;
	getChildrenPropertiesQuaternion: getChildrenPropertiesQuaternion;
	getChildrenPropertiesReceiveShadow: getChildrenPropertiesReceiveShadow;
	getChildrenPropertiesScale: getChildrenPropertiesScale;
	getChildrenPropertiesUp: getChildrenPropertiesUp;
	getChildrenPropertiesVisible: getChildrenPropertiesVisible;
	getDefaultCamera: getDefaultCamera;
	getGeometryBoundingBox: getGeometryBoundingBox;
	getGeometryNodeObjects: getGeometryNodeObjects;
	getGeometryPositions: getGeometryPositions;
	getIntersectionAttributeColorInterpolated: getIntersectionAttributeColorInterpolated;
	getIntersectionAttributeColorNearest: getIntersectionAttributeColorNearest;
	getIntersectionAttributeNumberInterpolated: getIntersectionAttributeNumberInterpolated;
	getIntersectionAttributeNumberNearest: getIntersectionAttributeNumberNearest;
	getIntersectionAttributeStringNearest: getIntersectionAttributeStringNearest;
	getIntersectionAttributeVector2Interpolated: getIntersectionAttributeVector2Interpolated;
	getIntersectionAttributeVector2Nearest: getIntersectionAttributeVector2Nearest;
	getIntersectionAttributeVector3Interpolated: getIntersectionAttributeVector3Interpolated;
	getIntersectionAttributeVector3Nearest: getIntersectionAttributeVector3Nearest;
	getIntersectionAttributeVector4Interpolated: getIntersectionAttributeVector4Interpolated;
	getIntersectionAttributeVector4Nearest: getIntersectionAttributeVector4Nearest;
	getIntersectionPropertyDistance: getIntersectionPropertyDistance;
	getIntersectionPropertyNormal: getIntersectionPropertyNormal;
	getIntersectionPropertyObject: getIntersectionPropertyObject;
	getIntersectionPropertyPoint: getIntersectionPropertyPoint;
	getIntersectionPropertyUv: getIntersectionPropertyUv;
	getMaterial: getMaterial;
	getNode: getNode;
	getObject: getObject;
	getObjectAttribute: getObjectAttribute<ParamConvertibleJsType>;
	getObjectAttributeAutoDefault: getObjectAttributeAutoDefault<ParamConvertibleJsType>;
	getObjectAttributePrevious: getObjectAttributePrevious;
	getObjectAttributeRef: getObjectAttributeRef;
	getObjectChild: getObjectChild;
	getObjectHoveredIntersection: getObjectHoveredIntersection;
	getObjectHoveredState: getObjectHoveredState;
	getObjectLastDispatchedEventName: getObjectLastDispatchedEventName;
	getObjectProperty: getObjectProperty;
	getObjectUserData: getObjectUserData;
	getObjectWorldPosition: getObjectWorldPosition;
	getParam: getParam;
	getParent: getParent;
	getPhysicsRBD: getPhysicsRBD;
	getPhysicsRBDAngularDamping: getPhysicsRBDAngularDamping;
	getPhysicsRBDAngularVelocity: getPhysicsRBDAngularVelocity;
	getPhysicsRBDCapsuleHeight: getPhysicsRBDCapsuleHeight;
	getPhysicsRBDCapsuleRadius: getPhysicsRBDCapsuleRadius;
	getPhysicsRBDConeHeight: getPhysicsRBDConeHeight;
	getPhysicsRBDConeRadius: getPhysicsRBDConeRadius;
	getPhysicsRBDCuboidSizes: getPhysicsRBDCuboidSizes;
	getPhysicsRBDCylinderHeight: getPhysicsRBDCylinderHeight;
	getPhysicsRBDCylinderRadius: getPhysicsRBDCylinderRadius;
	getPhysicsRBDIsMoving: getPhysicsRBDIsMoving;
	getPhysicsRBDIsSleeping: getPhysicsRBDIsSleeping;
	getPhysicsRBDLinearDamping: getPhysicsRBDLinearDamping;
	getPhysicsRBDLinearVelocity: getPhysicsRBDLinearVelocity;
	getPhysicsRBDSphereRadius: getPhysicsRBDSphereRadius;
	getPlaneConstant: getPlaneConstant;
	getPlaneNormal: getPlaneNormal;
	getPlayerInputDataBackward: getPlayerInputDataBackward;
	getPlayerInputDataForward: getPlayerInputDataForward;
	getPlayerInputDataJump: getPlayerInputDataJump;
	getPlayerInputDataLeft: getPlayerInputDataLeft;
	getPlayerInputDataRight: getPlayerInputDataRight;
	getPlayerInputDataRun: getPlayerInputDataRun;
	getPlayerSimplePropertyOnGround: getPlayerSimplePropertyOnGround;
	getPlayerSimplePropertyVelocity: getPlayerSimplePropertyVelocity;
	getPointAttributeNumber: getPointAttributeNumber;
	getPointAttributeVector2: getPointAttributeVector2;
	getPointAttributeVector3: getPointAttributeVector3;
	getPointAttributeVector4: getPointAttributeVector4;
	getPointIndex: getPointIndex;
	getPointInstancePosition: getPointInstancePosition;
	getPointInstanceQuaternion: getPointInstanceQuaternion;
	getPointInstanceScale: getPointInstanceScale;
	getPointPosition: getPointPosition;
	getRayDirection: getRayDirection;
	getRayOrigin: getRayOrigin;
	getSibbling: getSibbling;
	getSphereCenter: getSphereCenter;
	getSphereRadius: getSphereRadius;
	getTexture: getTexture;
	getTrackedHandIndexDirection: getTrackedHandIndexDirection;
	getTrackedHandMiddleDirection: getTrackedHandMiddleDirection;
	getTrackedHandPinkyDirection: getTrackedHandPinkyDirection;
	getTrackedHandRingDirection: getTrackedHandRingDirection;
	getTrackedHandThumbDirection: getTrackedHandThumbDirection;
	getVideoPropertyCurrentTime: getVideoPropertyCurrentTime;
	getVideoPropertyDuration: getVideoPropertyDuration;
	getVideoPropertyMuted: getVideoPropertyMuted;
	getVideoPropertyPlaying: getVideoPropertyPlaying;
	getWebXRARHitDetected: getWebXRARHitDetected;
	getWebXRARHitMatrix: getWebXRARHitMatrix;
	getWebXRARHitPosition: getWebXRARHitPosition;
	getWebXRARHitQuaternion: getWebXRARHitQuaternion;
	getWebXRControllerAngularVelocity: getWebXRControllerAngularVelocity;
	getWebXRControllerHasAngularVelocity: getWebXRControllerHasAngularVelocity;
	getWebXRControllerHasLinearVelocity: getWebXRControllerHasLinearVelocity;
	getWebXRControllerLinearVelocity: getWebXRControllerLinearVelocity;
	getWebXRControllerObject: getWebXRControllerObject;
	getWebXRControllerRay: getWebXRControllerRay;
	getWebXRTrackedMarkerMatrix: getWebXRTrackedMarkerMatrix;
	globalsCursor: globalsCursor;
	globalsRaycaster: globalsRaycaster;
	globalsRayFromCursor: globalsRayFromCursor;
	globalsTime: globalsTime;
	globalsTimeDelta: globalsTimeDelta;
	hsvToRgb: hsvToRgb;
	intToBool: intToBool;
	intToFloat: intToFloat;
	isTouchDevice: isTouchDevice;
	keyboardEventMatchesConfig: keyboardEventMatchesConfig;
	lengthVector: lengthVector<Vector2 | Vector3 | Vector4>;
	lengthVectorArray: lengthVectorArray<Vector2 | Vector3 | Vector4>;
	lerpColor: lerpColor;
	lerpNumber: lerpNumber;
	lerpQuaternion: lerpQuaternion;
	lerpVector2: lerpVector2;
	lerpVector3: lerpVector3;
	lerpVector4: lerpVector4;
	manhattanDistanceVector2: manhattanDistanceVector2;
	manhattanDistanceVector3: manhattanDistanceVector3;
	mathColor_1: mathColor_1;
	mathColor_2: mathColor_2;
	mathColor_3: mathColor_3;
	mathColor_3vvf: mathColor_3vvf;
	mathColor_4: mathColor_4;
	mathColor_5: mathColor_5;
	mathFloat_1: mathFloat_1;
	mathFloat_2: mathFloat_2;
	mathFloat_3: mathFloat_3;
	mathFloat_4: mathFloat_4;
	mathFloat_5: mathFloat_5;
	mathPrimArray_1: mathPrimArray_1;
	mathPrimArray_2: mathPrimArray_2;
	mathPrimArray_3: mathPrimArray_3;
	mathPrimArray_4: mathPrimArray_4;
	mathPrimArray_5: mathPrimArray_5;
	mathVector2_1: mathVector2_1;
	mathVector2_2: mathVector2_2;
	mathVector2_3: mathVector2_3;
	mathVector2_3vvf: mathVector2_3vvf;
	mathVector2_4: mathVector2_4;
	mathVector2_5: mathVector2_5;
	mathVector3_1: mathVector3_1;
	mathVector3_2: mathVector3_2;
	mathVector3_3: mathVector3_3;
	mathVector3_3vvf: mathVector3_3vvf;
	mathVector3_4: mathVector3_4;
	mathVector3_5: mathVector3_5;
	mathVector4_1: mathVector4_1;
	mathVector4_2: mathVector4_2;
	mathVector4_3: mathVector4_3;
	mathVector4_3vvf: mathVector4_3vvf;
	mathVector4_4: mathVector4_4;
	mathVector4_5: mathVector4_5;
	mathVectorArray_1: mathVectorArray_1<MathArrayVectorElement>;
	mathVectorArray_2: mathVectorArray_2<MathArrayVectorElement>;
	mathVectorArray_3: mathVectorArray_3<MathArrayVectorElement>;
	mathVectorArray_4: mathVectorArray_4<MathArrayVectorElement>;
	mathVectorArray_5: mathVectorArray_5<MathArrayVectorElement>;
	matrix4LookAt: matrix4LookAt;
	matrix4MakeTranslation: matrix4MakeTranslation;
	matrix4Multiply: matrix4Multiply;
	maxLengthVector2: maxLengthVector2;
	maxLengthVector3: maxLengthVector3;
	maxLengthVector4: maxLengthVector4;
	mix: mix;
	mod: mod;
	multAdd: multAdd;
	multNumber: multNumber;
	multScalarArrayVectorArray: multScalarArrayVectorArray<Color | Vector2 | Vector3 | Vector4>;
	multScalarColor: multScalarColor;
	multScalarVector2: multScalarVector2;
	multScalarVector3: multScalarVector3;
	multScalarVector4: multScalarVector4;
	multScalarVectorArray: multScalarVectorArray<Color | Vector2 | Vector3 | Vector4>;
	multVector: multVector<Vector2 | Vector3 | Vector4>;
	multVectorNumber: multVectorNumber<Vector2 | Vector3 | Vector4>;
	nearestPosition: nearestPosition;
	negate: negate<boolean | number>;
	noiseImprovedVector3: noiseImprovedVector3;
	noiseSimplexVector2: noiseSimplexVector2;
	noiseSimplexVector3: noiseSimplexVector3;
	noiseSimplexVector4: noiseSimplexVector4;
	normalizeVector2: normalizeVector2;
	normalizeVector3: normalizeVector3;
	normalizeVector4: normalizeVector4;
	object3DLocalToWorld: object3DLocalToWorld;
	object3DWorldToLocal: object3DWorldToLocal;
	objectAddEventListeners: objectAddEventListeners;
	objectAddOnBeforeDeleteEventListener: objectAddOnBeforeDeleteEventListener;
	objectDelete: objectDelete;
	objectDispatchEvent: objectDispatchEvent;
	objectUpdateMatrix: objectUpdateMatrix;
	objectUpdateWorldMatrix: objectUpdateWorldMatrix;
	onPerformanceChange: onPerformanceChange;
	orArrays: orArrays;
	orBooleans: orBooleans;
	particlesSystemReset: particlesSystemReset;
	particlesSystemStepSimulation: particlesSystemStepSimulation;
	pauseAudioSource: pauseAudioSource;
	physicsDebugUpdate: physicsDebugUpdate;
	physicsRBDAddForce: physicsRBDAddForce;
	physicsRBDAddForceAtPoint: physicsRBDAddForceAtPoint;
	physicsRBDAddTorque: physicsRBDAddTorque;
	physicsRBDApplyImpulse: physicsRBDApplyImpulse;
	physicsRBDApplyImpulseAtPoint: physicsRBDApplyImpulseAtPoint;
	physicsRBDApplyTorqueImpulse: physicsRBDApplyTorqueImpulse;
	physicsRBDDelete: physicsRBDDelete;
	physicsRBDResetAll: physicsRBDResetAll;
	physicsRBDResetForces: physicsRBDResetForces;
	physicsRBDResetTorques: physicsRBDResetTorques;
	physicsWorldReset: physicsWorldReset;
	physicsWorldStepSimulation: physicsWorldStepSimulation;
	planeSet: planeSet;
	playAnimation: playAnimation;
	playAudioSource: playAudioSource;
	playerMode: playerMode;
	playerPhysicsUpdate: playerPhysicsUpdate;
	playerSimpleUpdate: playerSimpleUpdate;
	playInstrumentNote: playInstrumentNote;
	polarTransform: polarTransform;
	pressButtonParam: pressButtonParam;
	previousValueColor: previousValueColor;
	previousValuePrimitive: previousValuePrimitive<boolean | number | string>;
	previousValueVector2: previousValueVector2;
	previousValueVector3: previousValueVector3;
	previousValueVector4: previousValueVector4;
	quaternionAngleTo: quaternionAngleTo;
	quaternionSetFromAxisAngle: quaternionSetFromAxisAngle;
	quaternionSetFromEuler: quaternionSetFromEuler;
	quaternionSlerp: quaternionSlerp;
	radToDeg: radToDeg;
	rand: rand;
	random: random;
	rayDistanceToPlane: rayDistanceToPlane;
	rayFromCamera: rayFromCamera;
	rayIntersectBox3: rayIntersectBox3;
	rayIntersectObject3D: rayIntersectObject3D;
	rayIntersectPlane: rayIntersectPlane;
	rayIntersectsBox3: rayIntersectsBox3;
	rayIntersectsObject3D: rayIntersectsObject3D;
	rayIntersectSphere: rayIntersectSphere;
	rayIntersectsPlane: rayIntersectsPlane;
	rayIntersectsSphere: rayIntersectsSphere;
	raySet: raySet;
	renderPixel: renderPixel;
	rotateWithAxisAngle: rotateWithAxisAngle;
	rotateWithQuaternion: rotateWithQuaternion;
	SDF2DBox: SDF2DBox;
	SDF2DCircle: SDF2DCircle;
	SDF2DCross: SDF2DCross;
	SDF2DHeart: SDF2DHeart;
	SDF2DRoundedX: SDF2DRoundedX;
	SDFBox: SDFBox;
	SDFElongateFast: SDFElongateFast;
	SDFElongateSlow: SDFElongateSlow;
	SDFIntersect: SDFIntersect;
	SDFOnion: SDFOnion;
	SDFPlane: SDFPlane;
	SDFRevolutionX: SDFRevolutionX;
	SDFRevolutionY: SDFRevolutionY;
	SDFRevolutionZ: SDFRevolutionZ;
	SDFSmoothIntersect: SDFSmoothIntersect;
	SDFSmoothSubtract: SDFSmoothSubtract;
	SDFSmoothUnion: SDFSmoothUnion;
	SDFSphere: SDFSphere;
	SDFSubtract: SDFSubtract;
	SDFTorus: SDFTorus;
	SDFTransform: SDFTransform;
	SDFTube: SDFTube;
	SDFUnion: SDFUnion;
	setCameraViewOffset: setCameraViewOffset;
	setCSSObjectClass: setCSSObjectClass;
	setGeometryInstanceAttributeColor: setGeometryInstanceAttributeColor;
	setGeometryInstanceAttributeFloat: setGeometryInstanceAttributeFloat;
	setGeometryInstanceAttributeQuaternion: setGeometryInstanceAttributeQuaternion;
	setGeometryInstanceAttributeVector2: setGeometryInstanceAttributeVector2;
	setGeometryInstanceAttributeVector3: setGeometryInstanceAttributeVector3;
	setGeometryInstanceAttributeVector4: setGeometryInstanceAttributeVector4;
	setGeometryInstancePositions: setGeometryInstancePositions;
	setGeometryInstanceQuaternions: setGeometryInstanceQuaternions;
	setGeometryInstanceScales: setGeometryInstanceScales;
	setGeometryInstanceTransforms: setGeometryInstanceTransforms;
	setGeometryPositions: setGeometryPositions;
	setMaterialAlphaMap: setMaterialAlphaMap;
	setMaterialAOMap: setMaterialAOMap;
	setMaterialColor: setMaterialColor;
	setMaterialDisplacementMap: setMaterialDisplacementMap;
	setMaterialEmissiveColor: setMaterialEmissiveColor;
	setMaterialEmissiveMap: setMaterialEmissiveMap;
	setMaterialEnvMap: setMaterialEnvMap;
	setMaterialMap: setMaterialMap;
	setMaterialMetalnessMap: setMaterialMetalnessMap;
	setMaterialOpacity: setMaterialOpacity;
	setMaterialRoughnessMap: setMaterialRoughnessMap;
	setMaterialUniformNumber: setMaterialUniformNumber;
	setMaterialUniformTexture: setMaterialUniformTexture;
	setMaterialUniformVectorColor: setMaterialUniformVectorColor;
	setObjectAttribute: setObjectAttribute;
	setObjectCastShadow: setObjectCastShadow;
	setObjectFrustumCulled: setObjectFrustumCulled;
	setObjectLookAt: setObjectLookAt;
	setObjectMaterial: setObjectMaterial;
	setObjectMaterialColor: setObjectMaterialColor;
	setObjectMatrix: setObjectMatrix;
	setObjectMatrixAutoUpdate: setObjectMatrixAutoUpdate;
	setObjectPolarTransform: setObjectPolarTransform;
	setObjectPosition: setObjectPosition;
	setObjectQuaternion: setObjectQuaternion;
	setObjectReceiveShadow: setObjectReceiveShadow;
	setObjectRotation: setObjectRotation;
	setObjectScale: setObjectScale;
	setObjectVisible: setObjectVisible;
	setParamBoolean: setParamBoolean;
	setParamBooleanToggle: setParamBooleanToggle;
	setParamColor: setParamColor;
	setParamFloat: setParamFloat;
	setParamInteger: setParamInteger;
	setParamString: setParamString;
	setParamVector2: setParamVector2;
	setParamVector3: setParamVector3;
	setParamVector4: setParamVector4;
	setPerspectiveCameraFov: setPerspectiveCameraFov;
	setPerspectiveCameraNearFar: setPerspectiveCameraNearFar;
	setPhysicsRBDAngularVelocity: setPhysicsRBDAngularVelocity;
	setPhysicsRBDCapsuleProperty: setPhysicsRBDCapsuleProperty;
	setPhysicsRBDConeProperty: setPhysicsRBDConeProperty;
	setPhysicsRBDCuboidProperty: setPhysicsRBDCuboidProperty;
	setPhysicsRBDCylinderProperty: setPhysicsRBDCylinderProperty;
	setPhysicsRBDLinearVelocity: setPhysicsRBDLinearVelocity;
	setPhysicsRBDPosition: setPhysicsRBDPosition;
	setPhysicsRBDRotation: setPhysicsRBDRotation;
	setPhysicsRBDSphereProperty: setPhysicsRBDSphereProperty;
	setPhysicsWorldGravity: setPhysicsWorldGravity;
	setPlayerInput: setPlayerInput;
	setPointAttributeColor: setPointAttributeColor;
	setPointAttributeNumber: setPointAttributeNumber;
	setPointAttributeVector2: setPointAttributeVector2;
	setPointAttributeVector3: setPointAttributeVector3;
	setPointAttributeVector4: setPointAttributeVector4;
	setPointIndex: setPointIndex;
	setPointInstanceLookAt: setPointInstanceLookAt;
	setPointInstancePosition: setPointInstancePosition;
	setPointInstanceQuaternion: setPointInstanceQuaternion;
	setPointInstanceScale: setPointInstanceScale;
	setPointPosition: setPointPosition;
	setSpotLightIntensity: setSpotLightIntensity;
	setViewer: setViewer;
	setViewerControls: setViewerControls;
	sizzleVec3XY: sizzleVec3XY;
	sizzleVec3XZ: sizzleVec3XZ;
	sizzleVec3YZ: sizzleVec3YZ;
	sizzleVec4WArray: sizzleVec4WArray;
	sizzleVec4XYZ: sizzleVec4XYZ;
	sizzleVec4XYZArray: sizzleVec4XYZArray;
	sleep: sleep;
	smootherstep: smootherstep;
	smoothstep: smoothstep;
	softBodyConstraintCreate: softBodyConstraintCreate;
	softBodyConstraintDelete: softBodyConstraintDelete;
	softBodyConstraintSetPosition: softBodyConstraintSetPosition;
	softBodyMultiplyVelocity: softBodyMultiplyVelocity;
	softBodySetPosition: softBodySetPosition;
	softBodySolverStepSimulation: softBodySolverStepSimulation;
	sphereSet: sphereSet;
	subtractNumber: subtractNumber;
	subtractVector: subtractVector<Vector2 | Vector3 | Vector4>;
	subtractVectorNumber: subtractVectorNumber<Vector2 | Vector3 | Vector4>;
	trackFace: trackFace;
	trackFaceGetLandmarks: trackFaceGetLandmarks;
	trackHand: trackHand;
	trackHandGetNormalizedLandmarks: trackHandGetNormalizedLandmarks;
	trackHandGetWorldLandmarks: trackHandGetWorldLandmarks;
	triggerFilter: triggerFilter;
	triggerSwitch: triggerSwitch;
	triggerTwoWaySwitch: triggerTwoWaySwitch;
	vec2ToVec3: vec2ToVec3;
	vec3ToColor: vec3ToColor;
	vec3ToVec4: vec3ToVec4;
	vector3AngleTo: vector3AngleTo;
	vector3Project: vector3Project;
	vector3ProjectOnPlane: vector3ProjectOnPlane;
	vector3Unproject: vector3Unproject;
}
interface PersistedConfigBaseJsData extends PersistedConfigWithShaders {
	variableNames: string[];
	variables: SerializedVariable<SerializedVariableType>[];
	functionNames: Array<keyof NamedFunctionMap>;
	serializedParamConfigs: JsParamConfigJSON<ParamType>[];
}
interface SingleBodyPersistedConfigBaseJsData extends PersistedConfigBaseJsData {
	functionBody: string;
}
interface ActorFunctionData extends SingleBodyFunctionData {
	eventDatas: EvaluatorEventData[];
}
interface ActorPersistedConfigBaseJsData extends PersistedConfigBaseJsData {
	functionBody: string;
	variableNames: string[];
	variables: SerializedVariable<SerializedVariableType>[];
	functionNames: Array<keyof NamedFunctionMap>;
	serializedParamConfigs: JsParamConfigJSON<ParamType>[];
	eventDatas: EvaluatorEventData[];
}
declare class ActorPersistedConfig extends BasePersistedConfig {
	protected node: ActorBuilderNode;
	constructor(node: ActorBuilderNode);
	toData(): Promise<ActorPersistedConfigBaseJsData | undefined>;
	load(data: ActorPersistedConfigBaseJsData): void;
}
declare class JsAssemblerActor extends BaseJsShaderAssembler {
	makeFunctionNodeDirtyOnChange(): boolean;
	templateShader(): {
		main: string;
	};
	inputNamesForShaderName(rootNode: BaseJsNodeType, shaderName: JsFunctionName): string[];
	computedVariablesAllowed(): boolean;
// @ts-ignore
	spareParamsOptions(options: SpareParamOptions): ParamOptions;
	defaultObject3DVariable(): string;
	defaultObject3DMaterialVariable(): string;
	defaultPointIndexVariable(): string;
	createFunctionData(additionalRootNodes: BaseJsNodeType[]): ActorFunctionData | undefined;
	private _createFunctionData;
	rootNodesByShaderName(shaderName: JsFunctionName, rootNodes: BaseJsNodeType[]): BaseJsNodeType[];
	create_shader_configs(): JsShaderConfig[];
	create_variable_configs(): never[];
}
type OnCompilationCompletedHook = () => void;
declare class ActorCompilationController {
	protected node: ActorBuilderNode;
	constructor(node: ActorBuilderNode);
	compileIfRequired(): void;
	private _evaluatorGenerator;
	evaluatorGenerator(): ActorEvaluatorGenerator;
	private _functionData;
	functionData(): ActorFunctionData | undefined;
	private _resetFunctionData;
	updateFromFunctionData(functionData: ActorFunctionData): void;
	private _setEvaluatorGenerator;
	compile(): void;
	private _onCompilationCompletedCallbacks;
	addOnCompilationCompleted(callback: OnCompilationCompletedHook): void;
	removeOnCompilationCompleted(callback: OnCompilationCompletedHook): void;
	private _runOnCompilationCompletedCallbacks;
}
declare class TypedActorSopNode<K extends NodeParamsConfig> extends TypedSopNode<K> {
	protected _childrenControllerContext: NodeContext;
	createNode<S extends keyof JsNodeChildrenMap>(node_class: S, options?: NodeCreateOptions): JsNodeChildrenMap[S];
	createNode<K extends valueof<JsNodeChildrenMap>>(node_class: Constructor<K>, options?: NodeCreateOptions): K;
	children(): BaseJsNodeType[];
	nodesByType<K extends keyof JsNodeChildrenMap>(type: K): JsNodeChildrenMap[K][];
	childrenAllowed(): boolean;
	sceneReadonly(): boolean;
	readonly persisted_config: ActorPersistedConfig;
	assemblerController(): JsAssemblerController<JsAssemblerActor> | undefined;
	usedAssembler(): Readonly<AssemblerName.JS_ACTOR>;
	protected _assemblerController: JsAssemblerController<JsAssemblerActor> | undefined;
	private _createAssemblerController;
	readonly compilationController: ActorCompilationController;
	compile(): void;
	functionData(): ActorFunctionData | undefined;
	updateObjectOnRemove(object: ObjectContent<CoreObjectType>, parent: ObjectContent<CoreObjectType>): void;
}
declare class ActorSopParamsConfig extends NodeParamsConfig {
	/** @param select which objects this applies the actor behavior to */
	group: ParamTemplate<ParamType.STRING>;
	/** @param build actor from child nodes */
	useThisNode: ParamTemplate<ParamType.BOOLEAN>;
	/** @param actor node */
	node: ParamTemplate<ParamType.NODE_PATH>;
}
declare class ActorSopNode extends TypedActorSopNode<ActorSopParamsConfig> {
	readonly paramsConfig: ActorSopParamsConfig;
	static type(): SopType;
	protected initializeNode(): void;
	cook(inputCoreGroups: CoreGroup[]): Promise<void>;
	private _findActorNode;
}
declare class ActorInstanceSopParamsConfig extends NodeParamsConfig {
	/** @param select which objects this applies the actor behavior to */
	group: ParamTemplate<ParamType.STRING>;
	/** @param build actor from child nodes */
	useThisNode: ParamTemplate<ParamType.BOOLEAN>;
	/** @param actor node */
	node: ParamTemplate<ParamType.NODE_PATH>;
}
declare class ActorInstanceSopNode extends TypedActorSopNode<ActorInstanceSopParamsConfig> {
	readonly paramsConfig: ActorInstanceSopParamsConfig;
	static type(): SopType;
	protected initializeNode(): void;
	cook(inputCoreGroups: CoreGroup[]): Promise<void>;
	private _findActorNode;
}
declare class ActorPointSopParamsConfig extends NodeParamsConfig {
	/** @param select which objects this applies the actor behavior to */
	group: ParamTemplate<ParamType.STRING>;
	/** @param build actor from child nodes */
	useThisNode: ParamTemplate<ParamType.BOOLEAN>;
	/** @param actor node */
	node: ParamTemplate<ParamType.NODE_PATH>;
}
declare class ActorPointSopNode extends TypedActorSopNode<ActorPointSopParamsConfig> {
	readonly paramsConfig: ActorPointSopParamsConfig;
	static type(): SopType;
	protected initializeNode(): void;
	cook(inputCoreGroups: CoreGroup[]): Promise<void>;
	private _findActorNode;
}
declare class AddSopParamsConfig extends NodeParamsConfig {
	/** @param toggle to create points */
	createPoint: ParamTemplate<ParamType.BOOLEAN>;
	/** @param define the number of points to create */
	pointsCount: ParamTemplate<ParamType.INTEGER>;
	/** @param the position of the created points */
	position: ParamTemplate<ParamType.VECTOR3>;
	/** @param toggle on to connect the points from the input geometry */
	connectInputPoints: ParamTemplate<ParamType.BOOLEAN>;
	/** @param check if the last point is connected */
	connectToLastPoint: ParamTemplate<ParamType.BOOLEAN>;
}
declare class AddSopNode extends TypedSopNode<AddSopParamsConfig> {
	paramsConfig: AddSopParamsConfig;
	static type(): SopType;
	initializeNode(): void;
	private _operation;
	cook(input_contents: CoreGroup[]): void;
}
declare class AdjacencySopParamsConfig extends NodeParamsConfig {
	/** @param select which objects this add adjacency attributes to */
	group: ParamTemplate<ParamType.STRING>;
	/** @param name of attribute with count of adjacency attributes */
	adjacencyCountName: ParamTemplate<ParamType.STRING>;
	/** @param name of adjacency attribute */
	adjacencyBaseName: ParamTemplate<ParamType.STRING>;
}
declare class AdjacencySopNode extends TypedSopNode<AdjacencySopParamsConfig> {
	paramsConfig: AdjacencySopParamsConfig;
	static type(): SopType;
	initializeNode(): void;
	private _operation;
	cook(inputCoreGroups: CoreGroup[]): void;
}
declare const AmbientLightSopParamsConfig_base: {
	new (...args: any[]): {
		color: ParamTemplate<ParamType.COLOR>;
		intensity: ParamTemplate<ParamType.FLOAT>;
		name: ParamTemplate<ParamType.STRING>;
	};
} & typeof NodeParamsConfig;
declare class AmbientLightSopParamsConfig extends AmbientLightSopParamsConfig_base {
}
declare class AmbientLightSopNode extends TypedSopNode<AmbientLightSopParamsConfig> {
	paramsConfig: AmbientLightSopParamsConfig;
	static type(): string;
	initializeNode(): void;
	private _operation;
	cook(input_contents: CoreGroup[]): void;
}
declare class AnimationCopySopParamsConfig extends NodeParamsConfig {
}
declare class AnimationCopySopNode extends TypedSopNode<AnimationCopySopParamsConfig> {
	paramsConfig: AnimationCopySopParamsConfig;
	static type(): SopType;
	initializeNode(): void;
	cook(input_contents: CoreGroup[]): void;
}
declare const AreaLightSopParamsConfig_base: {
	new (...args: any[]): {
		light: ParamTemplate<ParamType.FOLDER>;
		color: ParamTemplate<ParamType.COLOR>;
		intensity: ParamTemplate<ParamType.FLOAT>;
		width: ParamTemplate<ParamType.FLOAT>;
		height: ParamTemplate<ParamType.FLOAT>;
		showHelper: ParamTemplate<ParamType.BOOLEAN>;
		name: ParamTemplate<ParamType.STRING>;
	};
} & typeof NodeParamsConfig;
declare class AreaLightSopParamsConfig extends AreaLightSopParamsConfig_base {
}
declare class AreaLightSopNode extends TypedSopNode<AreaLightSopParamsConfig> {
	paramsConfig: AreaLightSopParamsConfig;
	static type(): LightType;
	initializeNode(): void;
	private _operation;
	cook(input_contents: CoreGroup[]): void;
}
declare class AttribAddMultSopParamsConfig extends NodeParamsConfig {
	/** @param attribute name */
	name: ParamTemplate<ParamType.STRING>;
	/** @param value to add before the multiplication */
	preAdd: ParamTemplate<ParamType.FLOAT>;
	/** @param value to multiply */
	mult: ParamTemplate<ParamType.FLOAT>;
	/** @param value to add after the multiplication */
	postAdd: ParamTemplate<ParamType.FLOAT>;
}
declare class AttribAddMultSopNode extends TypedSopNode<AttribAddMultSopParamsConfig> {
	paramsConfig: AttribAddMultSopParamsConfig;
	static type(): SopType;
	initializeNode(): void;
	private _operation;
	cook(input_contents: CoreGroup[]): void;
}
declare class IndexCastSopParamsConfig extends NodeParamsConfig {
	/** @param toggle on to cast attributes */
	castAttributes: ParamTemplate<ParamType.BOOLEAN>;
	/** @param attrib mask */
	mask: ParamTemplate<ParamType.STRING>;
	/** @param toggle on to cast index */
	castIndex: ParamTemplate<ParamType.BOOLEAN>;
	/** @param type of attribute to cast to */
	type: ParamTemplate<ParamType.INTEGER>;
}
declare class AttribCastSopNode extends TypedSopNode<IndexCastSopParamsConfig> {
	paramsConfig: IndexCastSopParamsConfig;
	static type(): string;
	initializeNode(): void;
	private _operation;
	cook(input_contents: CoreGroup[]): void;
}
declare class AttribCopySopParamsConfig extends NodeParamsConfig {
	/** @param the attribute class (geometry or object) */
	class: ParamTemplate<ParamType.INTEGER>;
	/** @param name of the attribute to copy */
	name: ParamTemplate<ParamType.STRING>;
	/** @param toggle if you want to copy to another name */
	tnewName: ParamTemplate<ParamType.BOOLEAN>;
	/** @param the new name of the attribute */
	newName: ParamTemplate<ParamType.STRING>;
	/** @param this defines which component the copy starts from. If you want to copy the whole attribute, leave it at 0. If you want to copy only the y component, set it to 1. If you want to copy the z component, set it to 2. Note that this only makes sense if you copy from an attribute that has enough components to copy from. So setting it to 2 (for z) to copy from a vector2 attribute will raise an error. */
	srcOffset: ParamTemplate<ParamType.INTEGER>;
	/** @param this defines which component the attribute is copied to */
	destOffset: ParamTemplate<ParamType.INTEGER>;
}
declare class AttribCopySopNode extends TypedSopNode<AttribCopySopParamsConfig> {
	paramsConfig: AttribCopySopParamsConfig;
	static type(): SopType;
	initializeNode(): void;
	private _operation;
	cook(input_contents: CoreGroup[]): void;
	setAttribClass(attribClass: AttribClass): void;
	attribClass(): AttribClass;
}
declare class AttribCreateSopParamsConfig extends NodeParamsConfig {
	/** @param the group this applies to */
	group: ParamTemplate<ParamType.STRING>;
	/** @param the attribute class (geometry or object) */
	class: ParamTemplate<ParamType.INTEGER>;
	/** @param the attribute type (numeric or string) */
	type: ParamTemplate<ParamType.INTEGER>;
	/** @param the attribute name */
	name: ParamTemplate<ParamType.STRING>;
	/** @param the attribute size (1 for float, 2 for vector2, 3 for vector3, 4 for vector4) */
	size: ParamTemplate<ParamType.INTEGER>;
	/** @param the value for a float attribute */
	value1: ParamTemplate<ParamType.FLOAT>;
	/** @param the value for a vector2 */
	value2: ParamTemplate<ParamType.VECTOR2>;
	/** @param the value for a vector3 */
	value3: ParamTemplate<ParamType.VECTOR3>;
	/** @param the value for a vector4 */
	value4: ParamTemplate<ParamType.VECTOR4>;
	/** @param the value for a string attribute */
	string: ParamTemplate<ParamType.STRING>;
}
declare class AttribCreateSopNode extends TypedSopNode<AttribCreateSopParamsConfig> {
	paramsConfig: AttribCreateSopParamsConfig;
	static type(): SopType;
	initializeNode(): void;
	private _operation;
	cook(inputCoreGroups: CoreGroup[]): Promise<void>;
	private _addAttribute;
	private _isUsingExpression;
	setAttribClass(attribClass: AttribClass): void;
	attribClass(): AttribClass;
	setAttribType(type: AttribType): void;
	attribType(): AttribType;
}
declare class AttribDeleteSopParamsConfig extends NodeParamsConfig {
	/** @param the group this applies to */
	group: ParamTemplate<ParamType.STRING>;
	/** @param attribute class (geometry or object) */
	class: ParamTemplate<ParamType.INTEGER>;
	/** @param attribute name to delete */
	name: ParamTemplate<ParamType.STRING>;
}
declare class AttribDeleteSopNode extends TypedSopNode<AttribDeleteSopParamsConfig> {
	paramsConfig: AttribDeleteSopParamsConfig;
	static type(): SopType;
	initializeNode(): void;
	setAttribClass(attribClass: AttribClass): void;
	attribClass(): AttribClass;
	private _operation;
	cook(inputCoreGroups: CoreGroup[]): void;
}
declare class AttribFromTextureSopParamsConfig extends NodeParamsConfig {
	/** @param texture node */
	texture: ParamTemplate<ParamType.NODE_PATH>;
	/** @param uv attribute */
	uvAttrib: ParamTemplate<ParamType.STRING>;
	/** @param attribute to set the value to */
	attrib: ParamTemplate<ParamType.STRING>;
	/** @param target attribute size */
	attribSize: ParamTemplate<ParamType.INTEGER>;
	/** @param value to add to the attribute */
	add: ParamTemplate<ParamType.FLOAT>;
	/** @param value to multiply the attribute with */
	mult: ParamTemplate<ParamType.FLOAT>;
}
declare class AttribFromTextureSopNode extends TypedSopNode<AttribFromTextureSopParamsConfig> {
	paramsConfig: AttribFromTextureSopParamsConfig;
	static type(): string;
	initializeNode(): void;
	private _operation;
	cook(input_contents: CoreGroup[]): Promise<void>;
}
declare class AttribIdSopParamsConfig extends NodeParamsConfig {
	/** @param the attribute class (geometry or object) */
	class: ParamTemplate<ParamType.INTEGER>;
	/** @param sets to true to create the id attribute */
	id: ParamTemplate<ParamType.BOOLEAN>;
	/** @param name of id attribute */
	idName: ParamTemplate<ParamType.STRING>;
	/** @param sets to true to create the id attribute */
	idn: ParamTemplate<ParamType.BOOLEAN>;
	/** @param name of the position attribute */
	/** @param name of idn attribute */
	idnName: ParamTemplate<ParamType.STRING>;
}
declare class AttribIdSopNode extends TypedSopNode<AttribIdSopParamsConfig> {
	paramsConfig: AttribIdSopParamsConfig;
	static type(): SopType;
	initializeNode(): void;
	private _operation;
	cook(inputCoreGroups: CoreGroup[]): void;
	setAttribClass(attribClass: AttribClass): void;
	attribClass(): AttribClass;
}
declare class BaseSopOperation extends BaseOperation<NodeContext.SOP> {
	static context(): NodeContext;
	cook(inputCoreGroups: CoreGroup[], params: any): CoreGroup | Promise<CoreGroup> | void;
	protected createCoreGroupFromObjects(objects: ObjectContent<CoreObjectType>[]): CoreGroup;
	protected createCoreGroupFromGeometry(geometry: BufferGeometry, type?: ObjectType): CoreGroup;
	protected createObject<OT extends ObjectType>(geometry: BufferGeometry, type: OT, material?: Material): ObjectByObjectType[OT];
	static createObject<OT extends ObjectType>(geometry: BufferGeometry, type: OT, material?: Material): ObjectByObjectType[OT];
	static applyObjectDefault(object: Object3D): void;
	protected createIndexIfNone(geometry: BufferGeometry): void;
	static createIndexIfNone(geometry: BufferGeometry): void;
}
declare enum NormalizeMode {
	MIN_MAX_TO_01 = "min/max to 0/1",
	VECTOR_TO_LENGTH_1 = "vectors to length 1"
}
declare class AttribNormalizeSopParamsConfig extends NodeParamsConfig {
	/** @param defines if the value should be normalized between 0 and 1, or for vectors if the length should be 1 */
	mode: ParamTemplate<ParamType.INTEGER>;
	/** @param attribute to normalize */
	name: ParamTemplate<ParamType.STRING>;
	/** @param toggle to change the name of the attribute */
	changeName: ParamTemplate<ParamType.BOOLEAN>;
	/** @param new attribute name */
	newName: ParamTemplate<ParamType.STRING>;
}
declare class AttribNormalizeSopNode extends TypedSopNode<AttribNormalizeSopParamsConfig> {
	paramsConfig: AttribNormalizeSopParamsConfig;
	static type(): string;
	initializeNode(): void;
	set_mode(mode: NormalizeMode): void;
	private _operation;
	cook(input_contents: CoreGroup[]): void;
}
declare enum AttribPromoteMode {
	MIN = "min",
	MAX = "max",
	FIRST_FOUND = "first found"
}
declare class AttribPromoteSopParamsConfig extends NodeParamsConfig {
	/** @param the group this applies to */
	group: ParamTemplate<ParamType.STRING>;
	/** @param class the attribute is from (object or geometry) */
	classFrom: ParamTemplate<ParamType.INTEGER>;
	/** @param class the attribute should be promoted to (object or geometry) */
	classTo: ParamTemplate<ParamType.INTEGER>;
	/** @param mode used to promote the attribute (min, max or first_found) */
	mode: ParamTemplate<ParamType.INTEGER>;
	/** @param name of the attribute to promote */
	name: ParamTemplate<ParamType.STRING>;
}
declare class AttribPromoteSopNode extends TypedSopNode<AttribPromoteSopParamsConfig> {
	paramsConfig: AttribPromoteSopParamsConfig;
	static type(): SopType;
	initializeNode(): void;
	private _operation;
	cook(inputCoreGroups: CoreGroup[]): void;
	setAttribClassFrom(attribClass: AttribClass): void;
	attribClassFrom(): AttribClass;
	setAttribClassTo(attribClass: AttribClass): void;
	attribClassTo(): AttribClass;
	setPromoteMode(mode: AttribPromoteMode): void;
}
declare class AttribRemapSopParamsConfig extends NodeParamsConfig {
	/** @param name of the attribute to remap */
	name: ParamTemplate<ParamType.STRING>;
	/** @param ramp used to remap */
	ramp: ParamTemplate<ParamType.RAMP>;
	/** @param toggle if you want to create a new attribute */
	changeName: ParamTemplate<ParamType.BOOLEAN>;
	/** @param new attribute name */
	newName: ParamTemplate<ParamType.STRING>;
}
declare class AttribRemapSopNode extends TypedSopNode<AttribRemapSopParamsConfig> {
	paramsConfig: AttribRemapSopParamsConfig;
	static type(): string;
	initializeNode(): void;
	cook(inputCoreGroups: CoreGroup[]): void;
	private _remapAttribute;
	private _get_remaped_values;
	private _getNormalizedFloat;
	private _getNormalizedVector2;
	private _getNormalizedVector3;
	private _getNormalizedVector4;
}
declare class AttribRenameSopParamsConfig extends NodeParamsConfig {
	/** @param the group this applies to */
	group: ParamTemplate<ParamType.STRING>;
	/** @param class of the attribute to rename (object or geometry) */
	class: ParamTemplate<ParamType.INTEGER>;
	/** @param old attribute name */
	oldName: ParamTemplate<ParamType.STRING>;
	/** @param new attribute name */
	newName: ParamTemplate<ParamType.STRING>;
}
declare class AttribRenameSopNode extends TypedSopNode<AttribRenameSopParamsConfig> {
	paramsConfig: AttribRenameSopParamsConfig;
	static type(): string;
	initializeNode(): void;
	setAttribClass(attribClass: AttribClass): void;
	attribClass(): AttribClass;
	private _operation;
	cook(inputCoreGroups: CoreGroup[]): void;
}
declare class AttribSetAtIndexSopParamsConfig extends NodeParamsConfig {
	/** @param the point or object index this applies to */
	index: ParamTemplate<ParamType.INTEGER>;
	/** @param the attribute class (geometry or object) */
	class: ParamTemplate<ParamType.INTEGER>;
	/** @param the attribute type (numeric or string) */
	type: ParamTemplate<ParamType.INTEGER>;
	/** @param the attribute name */
	name: ParamTemplate<ParamType.STRING>;
	/** @param the attribute size (1 for float, 2 for vector2, 3 for vector3, 4 for vector4) */
	size: ParamTemplate<ParamType.INTEGER>;
	/** @param the value for a float attribute */
	value1: ParamTemplate<ParamType.FLOAT>;
	/** @param the value for a vector2 */
	value2: ParamTemplate<ParamType.VECTOR2>;
	/** @param the value for a vector3 */
	value3: ParamTemplate<ParamType.VECTOR3>;
	/** @param the value for a vector4 */
	value4: ParamTemplate<ParamType.VECTOR4>;
	/** @param the value for a string attribute */
	string: ParamTemplate<ParamType.STRING>;
}
declare class AttribSetAtIndexSopNode extends TypedSopNode<AttribSetAtIndexSopParamsConfig> {
	paramsConfig: AttribSetAtIndexSopParamsConfig;
	static type(): string;
	initializeNode(): void;
	private _operation;
	cook(inputCoreGroups: CoreGroup[]): void;
	private _addAttribute;
	private _addPointAttribute;
	private _addObjectAttribute;
	private _addCoreGroupAttribute;
	private _addNumericAttributeToPoints;
	private _addNumericAttributeToObject;
	private _addNumericAttributeToCoreGroup;
	private _addStringAttributeToPoints;
	private _addStringAttributeToObject;
	private _addStringAttributeToCoreGroup;
	private _isUsingExpression;
	setAttribClass(attribClass: AttribClass): void;
	attribClass(): AttribClass;
	setAttribType(type: AttribType): void;
	attribType(): AttribType;
}
declare class AttribTransferSopParamsConfig extends NodeParamsConfig {
	/** @param source group to transfer from (right input, or input 1) */
	srcGroup: ParamTemplate<ParamType.STRING>;
	/** @param dest group to transfer to (left input, or input 0) */
	destGroup: ParamTemplate<ParamType.STRING>;
	/** @param name of the attribute to transfer */
	name: ParamTemplate<ParamType.STRING>;
	/** @param max number of samples to use */
	maxSamplesCount: ParamTemplate<ParamType.INTEGER>;
	/** @param max distance to search points to transfer from */
	distanceThreshold: ParamTemplate<ParamType.FLOAT>;
	/** @param blend width */
	blendWidth: ParamTemplate<ParamType.FLOAT>;
}
declare class AttribTransferSopNode extends TypedSopNode<AttribTransferSopParamsConfig> {
	paramsConfig: AttribTransferSopParamsConfig;
	static type(): SopType;
	initializeNode(): void;
	cook(inputCoreGroups: CoreGroup[]): Promise<void>;
	private _transferAttributes;
	private _addAttributeIfRequired;
	private _transferAttributesForPoint;
	private _interpolatePoints;
}
declare class AudioNotesSopParamsConfig extends NodeParamsConfig {
	/** @param the attribute class (geometry or object) */
	class: ParamTemplate<ParamType.INTEGER>;
	/** @param attribute name */
	name: ParamTemplate<ParamType.STRING>;
	/** @param adds an octave attribute */
	toctave: ParamTemplate<ParamType.BOOLEAN>;
	/** @param octave attribute name */
	octaveName: ParamTemplate<ParamType.STRING>;
	/** @param octave to start iterating the notes from */
	startOctave: ParamTemplate<ParamType.INTEGER>;
	/** @param last octave up to which the nodes will be added */
	endOctave: ParamTemplate<ParamType.INTEGER>;
	/** @param behavior if there are more objects than notes within the selected octave range */
	outOfRangeBehavior: ParamTemplate<ParamType.INTEGER>;
}
declare class AudioNotesSopNode extends TypedSopNode<AudioNotesSopParamsConfig> {
	paramsConfig: AudioNotesSopParamsConfig;
	static type(): SopType;
	initializeNode(): void;
	private _operation;
	cook(input_contents: CoreGroup[]): void;
	setAttribClass(attribClass: AttribClass): void;
	attribClass(): AttribClass;
}
declare class AxesHelperSopParamsConfig extends NodeParamsConfig {
	/** @param center of the geometry */
	center: ParamTemplate<ParamType.VECTOR3>;
}
declare class AxesHelperSopNode extends TypedSopNode<AxesHelperSopParamsConfig> {
	paramsConfig: AxesHelperSopParamsConfig;
	static type(): SopType;
	initializeNode(): void;
	private _operation;
	cook(input_contents: CoreGroup[]): void;
}
declare class BboxScatterSopParamsConfig extends NodeParamsConfig {
	/** @param the smaller the step size, the more points this will create */
	stepSize: ParamTemplate<ParamType.FLOAT>;
}
declare class BboxScatterSopNode extends TypedSopNode<BboxScatterSopParamsConfig> {
	paramsConfig: BboxScatterSopParamsConfig;
	static type(): SopType;
	initializeNode(): void;
	private _operation;
	cook(input_contents: CoreGroup[]): void;
}
declare class BlendSopParamsConfig extends NodeParamsConfig {
	/** @param name of the attribute to blend */
	attribName: ParamTemplate<ParamType.STRING>;
	/** @param blend value. 0 means the result will equal the left input, 1 will equal the right input, and 0.5 will be an average of both. */
	blend: ParamTemplate<ParamType.FLOAT>;
	/** @param update normals */
	updateNormals: ParamTemplate<ParamType.BOOLEAN>;
}
declare class BlendSopNode extends TypedSopNode<BlendSopParamsConfig> {
	paramsConfig: BlendSopParamsConfig;
	static type(): SopType;
	initializeNode(): void;
	cook(inputCoreGroups: CoreGroup[]): void;
	private blend;
}
declare enum BooleanOperation {
	INTERSECT = "intersect",
	SUBTRACT = "subtract",
	ADD = "add",
	DIFFERENCE = "difference"
}
declare class BooleanSopParamsConfig extends NodeParamsConfig {
	/** @param url to load the geometry from */
	operation: ParamTemplate<ParamType.INTEGER>;
	/** @param preserves the color attribute of both input */
	keepVertexColor: ParamTemplate<ParamType.BOOLEAN>;
	/** @param add any additional attribute to be preserved */
	additionalAttributes: ParamTemplate<ParamType.STRING>;
	/** @param defines if only the material from the first input is used, or if the ones from both inputs should be used */
	keepMaterials: ParamTemplate<ParamType.BOOLEAN>;
	/** @param if one of the input has multiple material for a single object, and you'd like to preserve those, toggle this on */
	useInputGroups: ParamTemplate<ParamType.BOOLEAN>;
	/** @param intersectionEdgesOnly */
	intersectionEdgesOnly: ParamTemplate<ParamType.BOOLEAN>;
}
declare class BooleanSopNode extends TypedSopNode<BooleanSopParamsConfig> {
	paramsConfig: BooleanSopParamsConfig;
	static type(): string;
	initializeNode(): void;
	setOperation(operation: BooleanOperation): void;
	private _operation;
	cook(inputCoreGroups: CoreGroup[]): void;
}
declare class BoxSopParamsConfig extends NodeParamsConfig {
	/** @param size of the box */
	size: ParamTemplate<ParamType.FLOAT>;
	/** @param sizes on each axis */
	sizes: ParamTemplate<ParamType.VECTOR3>;
	/** @param number of segments on each axis */
	divisions: ParamTemplate<ParamType.VECTOR3>;
	/** @param center of the geometry */
	center: ParamTemplate<ParamType.VECTOR3>;
}
declare class BoxSopNode extends TypedSopNode<BoxSopParamsConfig> {
	readonly paramsConfig: BoxSopParamsConfig;
	static type(): SopType;
	protected initializeNode(): void;
	private _operation;
	cook(inputCoreGroups: CoreGroup[]): void;
}
declare class BoxLinesSopParamsConfig extends NodeParamsConfig {
	/** @param size of the box */
	size: ParamTemplate<ParamType.FLOAT>;
	/** @param sizes on each axis */
	sizes: ParamTemplate<ParamType.VECTOR3>;
	/** @param divisions on each axis */
	divisions: ParamTemplate<ParamType.VECTOR3>;
	/** @param center of the geometry */
	center: ParamTemplate<ParamType.VECTOR3>;
}
declare class BoxLinesSopNode extends TypedSopNode<BoxLinesSopParamsConfig> {
	readonly paramsConfig: BoxLinesSopParamsConfig;
	static type(): SopType;
	protected initializeNode(): void;
	private _operation;
	cook(inputCoreGroups: CoreGroup[]): void;
}
declare class BVHSopParamsConfig extends NodeParamsConfig {
	strategy: ParamTemplate<ParamType.INTEGER>;
	maxDepth: ParamTemplate<ParamType.INTEGER>;
	maxLeafTris: ParamTemplate<ParamType.INTEGER>;
	verbose: ParamTemplate<ParamType.BOOLEAN>;
	keepOnlyPosition: ParamTemplate<ParamType.BOOLEAN>;
}
declare class BVHSopNode extends TypedSopNode<BVHSopParamsConfig> {
	paramsConfig: BVHSopParamsConfig;
	static type(): SopType;
	initializeNode(): void;
	private _operation;
	cook(input_contents: CoreGroup[]): void;
}
declare class BVHVisualizerSopParamsConfig extends NodeParamsConfig {
	/** @param depth */
	depth: ParamTemplate<ParamType.INTEGER>;
	/** @param opacity */
	opacity: ParamTemplate<ParamType.FLOAT>;
	/** @param depth */
	displayEdges: ParamTemplate<ParamType.BOOLEAN>;
	/** @param depth */
	displayParents: ParamTemplate<ParamType.BOOLEAN>;
}
declare class BVHVisualizerSopNode extends TypedSopNode<BVHVisualizerSopParamsConfig> {
	paramsConfig: BVHVisualizerSopParamsConfig;
	static type(): SopType;
	initializeNode(): void;
	private _operation;
	cook(input_contents: CoreGroup[]): void;
}
declare class CacheSopParamsConfig extends NodeParamsConfig {
	/** @param content of the cache (hidden) */
	cache: ParamTemplate<ParamType.STRING>;
	/** @param clears the cache */
	reset: ParamTemplate<ParamType.BUTTON>;
}
declare class CacheSopNode extends TypedSopNode<CacheSopParamsConfig> {
	paramsConfig: CacheSopParamsConfig;
	static type(): SopType;
	initializeNode(): void;
	cook(inputCoreGroups: CoreGroup[]): void;
	static PARAM_CALLBACK_reset(node: CacheSopNode, param: BaseParamType): void;
	param_callback_PARAM_CALLBACK_reset(): Promise<void>;
}
declare class CADSopNode<K extends NodeParamsConfig> extends TypedSopNode<K> {
	dataType(): string;
	requiredModules(): ModuleName[];
// @ts-ignore
	setCADGeom2dCurve(curve: Geom2d_Curve): void;
// @ts-ignore
	setCADShape(shape: TopoDS_Shape): void;
// @ts-ignore
	setCADShapes(shapes: TopoDS_Shape[]): void;
	setCADObjects(cadObjects: CadObject<CadGeometryType>[]): void;
	setCADObject(cadObject: CadObject<CadGeometryType>): void;
	protected _setContainerCadObjects(objects: CadObject<CadGeometryType>[]): void;
	processError(e: unknown): string;
}
declare enum BooleanCadOperationType {
	INTERSECT = "intersect",
	SECTION = "section",
	SUBTRACT = "subtract",
	UNION = "union"
}
declare class CADBooleanSopParamsConfig extends NodeParamsConfig {
	/** @param operation */
	operation: ParamTemplate<ParamType.INTEGER>;
	/** @param mode */
	mode: ParamTemplate<ParamType.INTEGER>;
}
declare class CADBooleanSopNode extends CADSopNode<CADBooleanSopParamsConfig> {
	paramsConfig: CADBooleanSopParamsConfig;
	static type(): SopType;
	protected initializeNode(): void;
	setOperation(operation: BooleanCadOperationType): void;
	cook(inputCoreGroups: CoreGroup[]): void;
	private _createBooleansAllInSequence;
	private _createBooleansOneToOne;
	private _createBooleansOneToMany;
}
declare class CADBoxSopParamsConfig extends NodeParamsConfig {
	/** @param size */
	size: ParamTemplate<ParamType.FLOAT>;
	/** @param sizes */
	sizes: ParamTemplate<ParamType.VECTOR3>;
	/** @param center */
	center: ParamTemplate<ParamType.VECTOR3>;
}
declare class CADBoxSopNode extends CADSopNode<CADBoxSopParamsConfig> {
	readonly paramsConfig: CADBoxSopParamsConfig;
	static type(): SopType;
	cook(): Promise<void>;
}
declare class CADCircleSopParamsConfig extends NodeParamsConfig {
	/** @param radius */
	radius: ParamTemplate<ParamType.FLOAT>;
	/** @param axis */
	axis: ParamTemplate<ParamType.VECTOR3>;
	/** @param center */
	center: ParamTemplate<ParamType.VECTOR3>;
}
declare class CADCircleSopNode extends CADSopNode<CADCircleSopParamsConfig> {
	paramsConfig: CADCircleSopParamsConfig;
	static type(): SopType;
	cook(inputCoreGroups: CoreGroup[]): Promise<void>;
}
declare class CADCircle2DSopParamsConfig extends NodeParamsConfig {
	/** @param radius */
	radius: ParamTemplate<ParamType.FLOAT>;
	/** @param center */
	center: ParamTemplate<ParamType.VECTOR2>;
}
declare class CADCircle2DSopNode extends CADSopNode<CADCircle2DSopParamsConfig> {
	paramsConfig: CADCircle2DSopParamsConfig;
	static type(): SopType;
	cook(inputCoreGroups: CoreGroup[]): Promise<void>;
}
declare class CADCircle3PointsSopParamsConfig extends NodeParamsConfig {
}
declare class CADCircle3PointsSopNode extends CADSopNode<CADCircle3PointsSopParamsConfig> {
	paramsConfig: CADCircle3PointsSopParamsConfig;
	static type(): SopType;
	protected initializeNode(): void;
	cook(inputCoreGroups: CoreGroup[]): Promise<void>;
}
declare class CADConeSopParamsConfig extends NodeParamsConfig {
	/** @param base radius */
	baseRadius: ParamTemplate<ParamType.FLOAT>;
	/** @param top radius */
	topRadius: ParamTemplate<ParamType.FLOAT>;
	/** @param height */
	height: ParamTemplate<ParamType.FLOAT>;
	/** @param center */
	center: ParamTemplate<ParamType.VECTOR3>;
	/** @param axis */
	axis: ParamTemplate<ParamType.VECTOR3>;
	/** @param closed */
	closed: ParamTemplate<ParamType.BOOLEAN>;
	/** @param phi */
	phi: ParamTemplate<ParamType.FLOAT>;
}
declare class CADConeSopNode extends CADSopNode<CADConeSopParamsConfig> {
	paramsConfig: CADConeSopParamsConfig;
	static type(): SopType;
	cook(inputCoreGroups: CoreGroup[]): Promise<void>;
}
declare enum ConversionMode {
	TO_2D = "to 2D",
	TO_3D = "to 3D"
}
declare class CADConvertDimensionSopParamsConfig extends NodeParamsConfig {
	/** @param mode */
	mode: ParamTemplate<ParamType.INTEGER>;
}
declare class CADConvertDimensionSopNode extends CADSopNode<CADConvertDimensionSopParamsConfig> {
	paramsConfig: CADConvertDimensionSopParamsConfig;
	static type(): SopType;
	protected initializeNode(): void;
	setMode(mode: ConversionMode): void;
	cook(inputCoreGroups: CoreGroup[]): void;
}
declare class CADCurve2DToSurfaceSopParamsConfig extends NodeParamsConfig {
}
declare class CADCurve2DToSurfaceSopNode extends CADSopNode<CADCurve2DToSurfaceSopParamsConfig> {
	paramsConfig: CADCurve2DToSurfaceSopParamsConfig;
	static type(): SopType;
	protected initializeNode(): void;
	cook(inputCoreGroups: CoreGroup[]): void;
}
declare class CADCurveFromPointsSopParamsConfig extends NodeParamsConfig {
}
declare class CADCurveFromPointsSopNode extends CADSopNode<CADCurveFromPointsSopParamsConfig> {
	paramsConfig: CADCurveFromPointsSopParamsConfig;
	static type(): SopType;
	protected initializeNode(): void;
	cook(inputCoreGroups: CoreGroup[]): void;
}
declare class CADCurveFromPoints2DSopParamsConfig extends NodeParamsConfig {
}
declare class CADCurveFromPoints2DSopNode extends CADSopNode<CADCurveFromPoints2DSopParamsConfig> {
	paramsConfig: CADCurveFromPoints2DSopParamsConfig;
	static type(): SopType;
	protected initializeNode(): void;
	cook(inputCoreGroups: CoreGroup[]): void;
}
declare class CADCurveTrimSopParamsConfig extends NodeParamsConfig {
	/** @param min */
	min: ParamTemplate<ParamType.FLOAT>;
	/** @param max */
	max: ParamTemplate<ParamType.FLOAT>;
}
declare class CADCurveTrimSopNode extends CADSopNode<CADCurveTrimSopParamsConfig> {
	paramsConfig: CADCurveTrimSopParamsConfig;
	static type(): SopType;
	protected initializeNode(): void;
	cook(inputCoreGroups: CoreGroup[]): void;
}
declare class CADEllipseSopParamsConfig extends NodeParamsConfig {
	/** @param major radius */
	majorRadius: ParamTemplate<ParamType.FLOAT>;
	/** @param minor radius */
	minorRadius: ParamTemplate<ParamType.FLOAT>;
	/** @param axis */
	axis: ParamTemplate<ParamType.VECTOR3>;
	/** @param center */
	center: ParamTemplate<ParamType.VECTOR3>;
}
declare class CADEllipseSopNode extends CADSopNode<CADEllipseSopParamsConfig> {
	paramsConfig: CADEllipseSopParamsConfig;
	static type(): SopType;
	cook(inputCoreGroups: CoreGroup[]): Promise<void>;
}
declare class CADEllipse2DSopParamsConfig extends NodeParamsConfig {
	/** @param major radius */
	majorRadius: ParamTemplate<ParamType.FLOAT>;
	/** @param minor radius */
	minorRadius: ParamTemplate<ParamType.FLOAT>;
	/** @param axis */
	/** @param center */
	center: ParamTemplate<ParamType.VECTOR2>;
}
declare class CADEllipse2DSopNode extends CADSopNode<CADEllipse2DSopParamsConfig> {
	paramsConfig: CADEllipse2DSopParamsConfig;
	static type(): SopType;
	cook(inputCoreGroups: CoreGroup[]): Promise<void>;
}
type Result = ArrayBuffer | string | object;
declare class BaseExporterSopParamsConfig extends NodeParamsConfig {
	/** @param fileName */
	fileName: ParamTemplate<ParamType.STRING>;
	/** @param export */
	download: ParamTemplate<ParamType.BUTTON>;
}
declare abstract class ExporterSopNode<K extends BaseExporterSopParamsConfig> extends TypedSopNode<K> {
	abstract fileExtension(): string;
	abstract createBlob(): Promise<Blob>;
	initializeNode(): void;
	cook(inputCoreGroups: CoreGroup[]): Promise<void>;
	static PARAM_CALLBACK_download(node: ExporterSopNode<BaseExporterSopParamsConfig>): void;
	fileName(): Promise<string>;
	_paramCallbackDownload(): Promise<void>;
	protected _prepareScene(): Promise<{
		scene: Scene;
		objects: Object3D<Event>[];
	} | undefined>;
	protected _handleResult(result: Result, objects: Object3D[], resolve: (blob: Blob) => void): void;
}
declare abstract class CADExporterSopNode<K extends BaseExporterSopParamsConfig> extends CADSopNode<K> {
	abstract fileExtension(): string;
	abstract createBlob(): Promise<Blob>;
	initializeNode(): void;
	cook(inputCoreGroups: CoreGroup[]): Promise<void>;
	static PARAM_CALLBACK_download(node: CADExporterSopNode<BaseExporterSopParamsConfig>): void;
	fileName(): Promise<string>;
	_paramCallbackDownload(): Promise<void>;
	protected _prepareScene(): Promise<{
		cadObjects: CadObject<CadGeometryType>[];
	} | undefined>;
}
declare class ExporterSTEPSopParamsConfig extends BaseExporterSopParamsConfig {
}
declare class CADExporterSTEPSopNode extends CADExporterSopNode<ExporterSTEPSopParamsConfig> {
	paramsConfig: ExporterSTEPSopParamsConfig;
	static type(): SopType;
	fileExtension(): string;
	createBlob(): Promise<Blob>;
}
declare class CADExtrudeSopParamsConfig extends NodeParamsConfig {
	/** @param direction */
	dir: ParamTemplate<ParamType.VECTOR3>;
	/** @param height */
	height: ParamTemplate<ParamType.FLOAT>;
	/** @param create caps */
	cap: ParamTemplate<ParamType.BOOLEAN>;
	/** @param convert caps to faces */
	capsAsFaces: ParamTemplate<ParamType.BOOLEAN>;
}
declare class CADExtrudeSopNode extends CADSopNode<CADExtrudeSopParamsConfig> {
	paramsConfig: CADExtrudeSopParamsConfig;
	static type(): SopType;
	protected initializeNode(): void;
	cook(inputCoreGroups: CoreGroup[]): void;
	private _processObject;
	private _processVertexObject;
	private _processEdgeObject;
	private _processWireObject;
	private _processWire;
	private _processFaceObject;
	private _processFace;
	private _processShellObject;
}
declare class DRACOLoader extends Loader {
	constructor(manager?: LoadingManager);
	load(url: string, onLoad: (geometry: BufferGeometry) => void, onProgress?: (event: ProgressEvent) => void, onError?: (event: ErrorEvent) => void): void;
	loadAsync(url: string, onProgress?: (event: ProgressEvent) => void): Promise<BufferGeometry>;
	setDecoderPath(path: string): DRACOLoader;
	setDecoderConfig(config: object): DRACOLoader;
	setWorkerLimit(workerLimit: number): DRACOLoader;
	preload(): DRACOLoader;
	dispose(): DRACOLoader;
}
declare class KTX2Loader extends CompressedTextureLoader {
	constructor(manager?: LoadingManager);
	setTranscoderPath(path: string): KTX2Loader;
	setWorkerLimit(limit: number): KTX2Loader;
	detectSupport(renderer: WebGLRenderer): KTX2Loader;
	dispose(): KTX2Loader;
	parse(buffer: ArrayBuffer, onLoad: (texture: CompressedTexture) => void, onError?: (event: ErrorEvent) => void): KTX2Loader;
}
interface GLTF {
	animations: AnimationClip[];
	scene: Group;
	scenes: Group[];
	cameras: Camera[];
	asset: {
		copyright?: string | undefined;
		generator?: string | undefined;
		version?: string | undefined;
		minVersion?: string | undefined;
		extensions?: any;
		extras?: any;
	};
	parser: GLTFParser;
	userData: any;
}
declare class GLTFLoader extends Loader {
	constructor(manager?: LoadingManager);
	dracoLoader: DRACOLoader | null;
	load(url: string, onLoad: (gltf: GLTF) => void, onProgress?: (event: ProgressEvent) => void, onError?: (event: ErrorEvent) => void): void;
	loadAsync(url: string, onProgress?: (event: ProgressEvent) => void): Promise<GLTF>;
	setDRACOLoader(dracoLoader: DRACOLoader): GLTFLoader;
	register(callback: (parser: GLTFParser) => GLTFLoaderPlugin): GLTFLoader;
	unregister(callback: (parser: GLTFParser) => GLTFLoaderPlugin): GLTFLoader;
	setKTX2Loader(ktx2Loader: KTX2Loader): GLTFLoader;
	setMeshoptDecoder(meshoptDecoder: any): GLTFLoader;
	parse(data: ArrayBuffer | string, path: string, onLoad: (gltf: GLTF) => void, onError?: (event: ErrorEvent) => void): void;
	parseAsync(data: ArrayBuffer | string, path: string): Promise<GLTF>;
}
interface GLTFReference {
	materials?: number;
	nodes?: number;
	textures?: number;
	meshes?: number;
}
declare class GLTFParser {
	json: any;
	options: {
		path: string;
		manager: LoadingManager;
		ktx2Loader: KTX2Loader;
		meshoptDecoder: any;
		crossOrigin: string;
		requestHeader: {
			[header: string]: string;
		};
	};
	fileLoader: FileLoader;
	textureLoader: TextureLoader | ImageBitmapLoader;
	plugins: {
		[name: string]: GLTFLoaderPlugin;
	};
	extensions: {
		[name: string]: any;
	};
	associations: Map<Object3D | Material | Texture, GLTFReference>;
	setExtensions(extensions: {
		[name: string]: any;
	}): void;
	setPlugins(plugins: {
		[name: string]: GLTFLoaderPlugin;
	}): void;
	parse(onLoad: (gltf: GLTF) => void, onError?: (event: ErrorEvent) => void): void;
	getDependency: (type: string, index: number) => Promise<any>;
	getDependencies: (type: string) => Promise<any[]>;
	loadBuffer: (bufferIndex: number) => Promise<ArrayBuffer>;
	loadBufferView: (bufferViewIndex: number) => Promise<ArrayBuffer>;
	loadAccessor: (accessorIndex: number) => Promise<BufferAttribute | InterleavedBufferAttribute>;
	loadTexture: (textureIndex: number) => Promise<Texture>;
	loadTextureImage: (textureIndex: number, sourceIndex: number, loader: Loader) => Promise<Texture>;
	loadImageSource: (sourceIndex: number, loader: Loader) => Promise<Texture>;
	assignTexture: (materialParams: {
		[key: string]: any;
	}, mapName: string, mapDef: {
		index: number;
		texCoord?: number | undefined;
		extensions?: any;
	}) => Promise<void>;
	assignFinalMaterial: (object: Mesh) => void;
	getMaterialType: () => typeof MeshStandardMaterial;
	loadMaterial: (materialIndex: number) => Promise<Material>;
	createUniqueName: (originalName: string) => string;
	createNodeMesh: (nodeIndex: number) => Promise<Group | Mesh | SkinnedMesh>;
	loadGeometries: (
	/**
	 * GLTF.Primitive[]
	 * See: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/schema/mesh.primitive.schema.json
	 */
	primitives: Array<{
		[key: string]: any;
	}>) => Promise<BufferGeometry[]>;
	loadMesh: (meshIndex: number) => Promise<Group | Mesh | SkinnedMesh>;
	loadCamera: (cameraIndex: number) => Promise<Camera>;
	loadSkin: (skinIndex: number) => Promise<Skeleton>;
	loadAnimation: (animationIndex: number) => Promise<AnimationClip>;
	loadNode: (nodeIndex: number) => Promise<Object3D>;
	loadScene: () => Promise<Group>;
}
interface GLTFLoaderPlugin {
	beforeRoot?: (() => Promise<void> | null) | undefined;
	afterRoot?: ((result: GLTF) => Promise<void> | null) | undefined;
	loadNode?: ((nodeIndex: number) => Promise<Object3D> | null) | undefined;
	loadMesh?: ((meshIndex: number) => Promise<Group | Mesh | SkinnedMesh> | null) | undefined;
	loadBufferView?: ((bufferViewIndex: number) => Promise<ArrayBuffer> | null) | undefined;
	loadMaterial?: ((materialIndex: number) => Promise<Material> | null) | undefined;
	loadTexture?: ((textureIndex: number) => Promise<Texture> | null) | undefined;
	getMaterialType?: ((materialIndex: number) => typeof Material | null) | undefined;
	extendMaterialParams?: ((materialIndex: number, materialParams: {
		[key: string]: any;
	}) => Promise<any> | null) | undefined;
	createNodeMesh?: ((nodeIndex: number) => Promise<Group | Mesh | SkinnedMesh> | null) | undefined;
	createNodeAttachment?: ((nodeIndex: number) => Promise<Object3D> | null) | undefined;
}
interface PDB {
	geometryAtoms: BufferGeometry;
	geometryBonds: BufferGeometry;
	json: {
		atoms: any[][];
	};
}
interface Chunk {
	palette: number[];
	size: {
		x: number;
		y: number;
		z: number;
	};
	data: Uint8Array;
}
type IFCModel = Object3D;
type BaseGeoLoaderOutput = Object3D | BufferGeometry | Chunk[] | PDB | GLTF | IFCModel | Array<ObjectContent<CoreObjectType>>;
type OnSuccess<O extends BaseGeoLoaderOutput> = (o: O) => void;
type OnProgress = (n: ProgressEvent<EventTarget>) => void;
type OnError = (event: any) => void;
interface BaseLoaderLoadOptions {
	node: BaseNodeType;
}
interface MultipleDependenciesLoadFileOptions {
	fullUrl: string;
}
interface MultipleDependenciesLoadOptions {
	files: MultipleDependenciesLoadFileOptions[];
	error: string;
	node?: BaseNodeType;
}
type OnAssetLoadedCallback = (url: string, asset?: BaseGeoLoaderOutput | Texture) => void;
declare class CoreBaseLoader<U extends string | Array<string>> {
	protected _url: U;
	protected _node?: BaseNodeType | undefined;
	blobOptions: BlobsControllerFetchNodeOptions;
	static readonly loadingManager: LoadingManager;
	readonly loadingManager: LoadingManager;
	constructor(_url: U, _node?: BaseNodeType | undefined, blobOptions?: BlobsControllerFetchNodeOptions);
	static extension(url: string): string;
	extension(): string;
	protected _urlToLoad(): Promise<U>;
	protected static _loadMultipleBlobGlobal(options: MultipleDependenciesLoadOptions): Promise<void>;
	private static _onAssetLoadedCallbacks;
	static onAssetLoaded(callback: OnAssetLoadedCallback): void;
	static _runOnAssetLoadedCallbacks(url: string, asset?: BaseGeoLoaderOutput | Texture): void;
}
declare abstract class BaseGeoLoader<O extends BaseGeoLoaderOutput> {
	abstract load: (url: string, onSuccess: OnSuccess<O>, onProgress?: OnProgress, onError?: OnError) => void;
}
declare abstract class BaseLoaderHandler<O extends BaseGeoLoaderOutput, OC extends ObjectContent<CoreObjectType>> extends CoreBaseLoader<string> {
	protected _loader: BaseGeoLoader<O> | undefined;
	reset(): void;
	load(options: BaseLoaderLoadOptions): Promise<OC[] | undefined>;
	protected _errorMessage(url: string, event: ErrorEvent): string;
	protected abstract _getLoader(options: BaseLoaderLoadOptions): Promise<BaseGeoLoader<O>>;
	protected abstract _onLoadSuccess(o: O): OC[] | Promise<OC[]>;
}
declare abstract class BaseObject3DLoaderHandler<O extends BaseGeoLoaderOutput> extends BaseLoaderHandler<O, Object3D> {
	protected _onLoadSuccess(o: O): Object3D[] | Promise<Object3D[]>;
}
type TypedCadObject = CadObject<CadGeometryType>;
type CadObjectArray = Array<TypedCadObject>;
declare class STEPLoaderHandler extends BaseLoaderHandler<CadObjectArray, TypedCadObject> {
	protected _getLoader(options: BaseLoaderLoadOptions): Promise<BaseGeoLoader<CadObjectArray>>;
	protected _onLoadSuccess(o: CadObjectArray): CadObjectArray;
}
declare class CADFileSTEPSopParamsConfig extends NodeParamsConfig {
	/** @param url to load the geometry from */
	url: ParamTemplate<ParamType.STRING>;
	/** @param sets the matrixAutoUpdate attribute for the objects loaded */
	matrixAutoUpdate: ParamTemplate<ParamType.BOOLEAN>;
	/** @param reload the geometry */
	reload: ParamTemplate<ParamType.BUTTON>;
}
declare class CADFileSTEPSopNode extends CADSopNode<CADFileSTEPSopParamsConfig> {
	readonly paramsConfig: CADFileSTEPSopParamsConfig;
	static type(): SopType;
	dispose(): void;
	cook(inputCoreGroups: CoreGroup[]): Promise<void>;
	protected _createGeoLoaderHandler(url: string): STEPLoaderHandler;
	static PARAM_CALLBACK_reload(node: CADFileSTEPSopNode): void;
	private _paramCallbackReload;
}
declare class CADFilletSopParamsConfig extends NodeParamsConfig {
	/** @param edges group */
	group: ParamTemplate<ParamType.STRING>;
	/** @param mode */
	mode: ParamTemplate<ParamType.INTEGER>;
	/** @param radius */
	radius: ParamTemplate<ParamType.FLOAT>;
}
declare class CADFilletSopNode extends CADSopNode<CADFilletSopParamsConfig> {
	paramsConfig: CADFilletSopParamsConfig;
	static type(): SopType;
	protected initializeNode(): void;
	cook(inputCoreGroups: CoreGroup[]): void;
}
declare class GroupByExpressionHelper {
	private node;
	constructor(node: CADGroupSopNode);
	evalForEntities(allEntities: CoreEntity[], selectionStates: CoreEntitySelectionState): Promise<void>;
	private _evalEntityDependentExpression;
	private _evalExpressionsWithoutEntityDependentExpression;
}
declare class GroupByBoundingBoxHelper {
	private node;
	constructor(node: CADGroupSopNode);
	evalForEntities(allEntities: CoreEntity[], selectionStates: CoreEntitySelectionState): void;
}
declare class GroupByBoundingObjectHelper {
	evalForEntities(allEntities: CoreEntity[], selectionStates: CoreEntitySelectionState, boundingCoreGroup: CoreGroup): void;
}
declare class CADGroupSopParamsConfig extends NodeParamsConfig {
	/** @param group name */
	name: ParamTemplate<ParamType.STRING>;
	/** @param group type */
	type: ParamTemplate<ParamType.INTEGER>;
	/** @param mode */
	operation: ParamTemplate<ParamType.INTEGER>;
	/** @param deletes objects by an expression */
	byExpression: ParamTemplate<ParamType.BOOLEAN>;
	/** @param sets the expression to select what should be deleted */
	expression: ParamTemplate<ParamType.BOOLEAN>;
	/** @param deletes objects that are inside a bounding box */
	byBoundingBox: ParamTemplate<ParamType.BOOLEAN>;
	/** @param the bounding box size */
	boundingBoxSize: ParamTemplate<ParamType.VECTOR3>;
	/** @param the bounding box center */
	boundingBoxCenter: ParamTemplate<ParamType.VECTOR3>;
	/** @param deletes objects that are inside an object. This uses the object from the 2nd input */
	byBoundingObject: ParamTemplate<ParamType.BOOLEAN>;
	/** @param invert */
	invert: ParamTemplate<ParamType.BOOLEAN>;
}
declare class CADGroupSopNode extends CADSopNode<CADGroupSopParamsConfig> {
	readonly paramsConfig: CADGroupSopParamsConfig;
	static type(): SopType;
	readonly byExpressionHelper: GroupByExpressionHelper;
	readonly byBoundingBoxHelper: GroupByBoundingBoxHelper;
	readonly byBoundingObjectHelper: GroupByBoundingObjectHelper;
	initializeNode(): void;
	setGroupType(groupType: EntityGroupType): void;
	groupType(): EntityGroupType;
	groupName(): string;
	cook(inputCoreGroups: CoreGroup[]): Promise<void>;
	private selectedStates;
	private _evalEdges;
}
declare class CADLoftSopParamsConfig extends NodeParamsConfig {
	/** @param create solid */
	solid: ParamTemplate<ParamType.BOOLEAN>;
}
declare class CADLoftSopNode extends CADSopNode<CADLoftSopParamsConfig> {
	readonly paramsConfig: CADLoftSopParamsConfig;
	static type(): SopType;
	protected initializeNode(): void;
	cook(inputCoreGroups: CoreGroup[]): void;
}
declare class CADMirrorSopParamsConfig extends NodeParamsConfig {
	/** @param origin */
	/** @param axis */
	axis: ParamTemplate<ParamType.VECTOR3>;
}
declare class CADMirrorSopNode extends CADSopNode<CADMirrorSopParamsConfig> {
	paramsConfig: CADMirrorSopParamsConfig;
	static type(): SopType;
	protected initializeNode(): void;
	cook(inputCoreGroups: CoreGroup[]): void;
}
declare class CADPipeSopParamsConfig extends NodeParamsConfig {
	/** @param create caps */
	cap: ParamTemplate<ParamType.BOOLEAN>;
	/** @param convert caps to faces */
	capsAsFaces: ParamTemplate<ParamType.BOOLEAN>;
}
declare class CADPipeSopNode extends CADSopNode<CADPipeSopParamsConfig> {
	readonly paramsConfig: CADPipeSopParamsConfig;
	static type(): SopType;
	protected initializeNode(): void;
	cook(inputCoreGroups: CoreGroup[]): void;
}
declare class CADPointSopParamsConfig extends NodeParamsConfig {
	/** @param translate */
	center: ParamTemplate<ParamType.VECTOR3>;
}
declare class CADPointSopNode extends CADSopNode<CADPointSopParamsConfig> {
	paramsConfig: CADPointSopParamsConfig;
	static type(): SopType;
	cook(inputCoreGroups: CoreGroup[]): Promise<void>;
}
declare class CADPoint2DSopParamsConfig extends NodeParamsConfig {
	/** @param center */
	center: ParamTemplate<ParamType.VECTOR2>;
}
declare class CADPoint2DSopNode extends CADSopNode<CADPoint2DSopParamsConfig> {
	paramsConfig: CADPoint2DSopParamsConfig;
	static type(): SopType;
	cook(): Promise<void>;
}
declare class CADPointsFromCurveSopParamsConfig extends NodeParamsConfig {
	/** @param points count */
	count: ParamTemplate<ParamType.INTEGER>;
	/** @param min */
	min: ParamTemplate<ParamType.FLOAT>;
	/** @param max */
	max: ParamTemplate<ParamType.FLOAT>;
}
declare class CADPointsFromCurveSopNode extends CADSopNode<CADPointsFromCurveSopParamsConfig> {
	paramsConfig: CADPointsFromCurveSopParamsConfig;
	static type(): SopType;
	protected initializeNode(): void;
	cook(inputCoreGroups: CoreGroup[]): void;
}
declare class CADRectangleSopParamsConfig extends NodeParamsConfig {
	/** @param size */
	size: ParamTemplate<ParamType.VECTOR2>;
	/** @param center */
	center: ParamTemplate<ParamType.VECTOR3>;
	/** @param fillet radius */
	filletRadius: ParamTemplate<ParamType.FLOAT>;
}
declare class CADRectangleSopNode extends CADSopNode<CADRectangleSopParamsConfig> {
	paramsConfig: CADRectangleSopParamsConfig;
	static type(): SopType;
	cook(inputCoreGroups: CoreGroup[]): Promise<void>;
}
declare class CADRevolutionSopParamsConfig extends NodeParamsConfig {
	/** @param axis */
	axis: ParamTemplate<ParamType.VECTOR3>;
	/** @param closed */
	closed: ParamTemplate<ParamType.BOOLEAN>;
	/** @param thetaMin */
	/** @param thetaMax */
	/** @param phi */
	phi: ParamTemplate<ParamType.FLOAT>;
}
declare class CADRevolutionSopNode extends CADSopNode<CADRevolutionSopParamsConfig> {
	paramsConfig: CADRevolutionSopParamsConfig;
	static type(): SopType;
	protected initializeNode(): void;
	cook(inputCoreGroups: CoreGroup[]): void;
}
declare class CADSegmentSopParamsConfig extends NodeParamsConfig {
	/** @param mode */
	mode: ParamTemplate<ParamType.INTEGER>;
}
declare class CADSegmentSopNode extends CADSopNode<CADSegmentSopParamsConfig> {
	paramsConfig: CADSegmentSopParamsConfig;
	static type(): SopType;
	protected initializeNode(): void;
	cook(inputCoreGroups: CoreGroup[]): Promise<void>;
	private _createSegmentsFromPairs;
	private _createSegmentsFromAll;
}
declare class CADSphereSopParamsConfig extends NodeParamsConfig {
	/** @param radius */
	radius: ParamTemplate<ParamType.FLOAT>;
	/** @param center */
	center: ParamTemplate<ParamType.VECTOR3>;
	/** @param axis */
	axis: ParamTemplate<ParamType.VECTOR3>;
	/** @param closed */
	closed: ParamTemplate<ParamType.BOOLEAN>;
	/** @param thetaMin */
	thetaMin: ParamTemplate<ParamType.FLOAT>;
	/** @param thetaMax */
	thetaMax: ParamTemplate<ParamType.FLOAT>;
	/** @param phi */
	phi: ParamTemplate<ParamType.FLOAT>;
}
declare class CADSphereSopNode extends CADSopNode<CADSphereSopParamsConfig> {
	paramsConfig: CADSphereSopParamsConfig;
	static type(): SopType;
	cook(inputCoreGroups: CoreGroup[]): Promise<void>;
}
declare class CADThicknessSopParamsConfig extends NodeParamsConfig {
	/** @param faces group */
	facesGroupToDelete: ParamTemplate<ParamType.STRING>;
	/** @param offset */
	offset: ParamTemplate<ParamType.FLOAT>;
}
declare class CADThicknessSopNode extends CADSopNode<CADThicknessSopParamsConfig> {
	paramsConfig: CADThicknessSopParamsConfig;
	static type(): SopType;
	protected initializeNode(): void;
	cook(inputCoreGroups: CoreGroup[]): void;
	private _makeSolidByJoin;
}
declare class CADTorusSopParamsConfig extends NodeParamsConfig {
	/** @param outer radius */
	outerRadius: ParamTemplate<ParamType.FLOAT>;
	/** @param inner radius */
	innerRadius: ParamTemplate<ParamType.FLOAT>;
	/** @param center */
	center: ParamTemplate<ParamType.VECTOR3>;
	/** @param axis */
	axis: ParamTemplate<ParamType.VECTOR3>;
	/** @param closed */
	closed: ParamTemplate<ParamType.BOOLEAN>;
	/** @param phi */
	phi: ParamTemplate<ParamType.FLOAT>;
}
declare class CADTorusSopNode extends CADSopNode<CADTorusSopParamsConfig> {
	paramsConfig: CADTorusSopParamsConfig;
	static type(): SopType;
	cook(inputCoreGroups: CoreGroup[]): Promise<void>;
}
declare class CADTransformSopParamConfig extends NodeParamsConfig {
	/** @param translate */
	t: ParamTemplate<ParamType.VECTOR3>;
	/** @param rotation */
	r: ParamTemplate<ParamType.VECTOR3>;
	/** @param scale (as a float) */
	s: ParamTemplate<ParamType.FLOAT>;
	/** @param pivot */
	pivot: ParamTemplate<ParamType.VECTOR3>;
}
declare class CADTransformSopNode extends CADSopNode<CADTransformSopParamConfig> {
	paramsConfig: CADTransformSopParamConfig;
	static type(): SopType;
	initializeNode(): void;
	cook(inputCoreGroups: CoreGroup[]): void;
}
declare class CADTransform2DSopParamsConfig extends NodeParamsConfig {
	/** @param translate */
	t: ParamTemplate<ParamType.VECTOR2>;
	/** @param rotation */
	r: ParamTemplate<ParamType.FLOAT>;
	/** @param scale (as a float) */
	s: ParamTemplate<ParamType.FLOAT>;
	/** @param pivot */
	pivot: ParamTemplate<ParamType.VECTOR2>;
}
declare class CADTransform2DSopNode extends CADSopNode<CADTransform2DSopParamsConfig> {
	paramsConfig: CADTransform2DSopParamsConfig;
	static type(): SopType.CAD_TRANSFORM_2D;
	protected initializeNode(): void;
	cook(inputCoreGroups: CoreGroup[]): Promise<void>;
}
declare const CADTriangulateSopParamsConfig_base: {
	new (...args: any[]): {
		linearTolerance: ParamTemplate<ParamType.FLOAT>;
		angularTolerance: ParamTemplate<ParamType.FLOAT>;
		curveAbscissa: ParamTemplate<ParamType.FLOAT>;
		curveTolerance: ParamTemplate<ParamType.FLOAT>;
		displayEdges: ParamTemplate<ParamType.BOOLEAN>;
		edgesColor: ParamTemplate<ParamType.COLOR>;
		displayMeshes: ParamTemplate<ParamType.BOOLEAN>;
		meshesColor: ParamTemplate<ParamType.COLOR>;
		wireframe: ParamTemplate<ParamType.BOOLEAN>;
	};
} & typeof NodeParamsConfig;
declare class CADTriangulateSopParamsConfig extends CADTriangulateSopParamsConfig_base {
}
declare class CADTriangulateSopNode extends CADSopNode<CADTriangulateSopParamsConfig> {
	readonly paramsConfig: CADTriangulateSopParamsConfig;
	static type(): SopType;
	protected initializeNode(): void;
	cook(inputCoreGroups: CoreGroup[]): Promise<void>;
}
declare class CADTubeSopParamsConfig extends NodeParamsConfig {
	/** @param radius */
	radius: ParamTemplate<ParamType.FLOAT>;
	/** @param height */
	height: ParamTemplate<ParamType.FLOAT>;
	/** @param center */
	center: ParamTemplate<ParamType.VECTOR3>;
	/** @param axis */
	axis: ParamTemplate<ParamType.VECTOR3>;
	/** @param closed */
	closed: ParamTemplate<ParamType.BOOLEAN>;
	/** @param angle */
	angle: ParamTemplate<ParamType.FLOAT>;
}
declare class CADTubeSopNode extends CADSopNode<CADTubeSopParamsConfig> {
	paramsConfig: CADTubeSopParamsConfig;
	static type(): SopType;
	cook(inputCoreGroups: CoreGroup[]): Promise<void>;
}
declare class CADUnpackSopParamsConfig extends NodeParamsConfig {
}
declare class CADUnpackSopNode extends CADSopNode<CADUnpackSopParamsConfig> {
	paramsConfig: CADUnpackSopParamsConfig;
	static type(): SopType;
	protected initializeNode(): void;
	cook(inputCoreGroups: CoreGroup[]): void;
}
declare class CADWedgeSopParamsConfig extends NodeParamsConfig {
	/** @param size */
	size: ParamTemplate<ParamType.FLOAT>;
	/** @param sizes */
	sizes: ParamTemplate<ParamType.VECTOR3>;
	/** @param center */
	center: ParamTemplate<ParamType.VECTOR3>;
	/** @param end width */
	endWidth: ParamTemplate<ParamType.FLOAT>;
}
declare class CADWedgeSopNode extends CADSopNode<CADWedgeSopParamsConfig> {
	readonly paramsConfig: CADWedgeSopParamsConfig;
	static type(): SopType;
	cook(): Promise<void>;
}
declare class AnimationEventParamsConfig extends NodeParamsConfig {
	/** @parm animation node */
	animation: ParamTemplate<ParamType.NODE_PATH>;
	/** @parm presses to play the animation */
	play: ParamTemplate<ParamType.BUTTON>;
	/** @parm presses to pause the animation */
	pause: ParamTemplate<ParamType.BUTTON>;
	/** @param stops previous animations still in progress started by this node */
	stopsPreviousAnim: ParamTemplate<ParamType.BOOLEAN>;
}
declare class AnimationEventNode extends TypedEventNode<AnimationEventParamsConfig> {
	paramsConfig: AnimationEventParamsConfig;
	static type(): string;
	requiredModules(): ModuleName[];
	private _timelineBuilder;
	private _timeline;
	initializeNode(): void;
	processEvent(event_context: EventContext<Event>): void;
	static PARAM_CALLBACK_play(node: AnimationEventNode): void;
	static PARAM_CALLBACK_pause(node: AnimationEventNode): void;
	private _play;
	private _pause;
	private _triggerAnimationStarted;
	private _triggerAnimationCompleted;
}
declare class AnyEventParamsConfig extends NodeParamsConfig {
	/** @param toggle on to ensure events are transfered */
	active: ParamTemplate<ParamType.BOOLEAN>;
	/** @param number of possible events */
	inputsCount: ParamTemplate<ParamType.INTEGER>;
}
declare class AnyEventNode extends TypedEventNode<AnyEventParamsConfig> {
	paramsConfig: AnyEventParamsConfig;
	static type(): string;
	initializeNode(): void;
	private _expected_input_types;
	protected _input_name(index: number): string;
	processEvent(event_context: EventContext<Event>): Promise<void>;
}
declare class AudioEventParamsConfig extends NodeParamsConfig {
	/** @parm audio node */
	audio: ParamTemplate<ParamType.NODE_PATH>;
	/** @param note */
	note: ParamTemplate<ParamType.STRING>;
	/** @param duration */
	duration: ParamTemplate<ParamType.FLOAT>;
	/** @param button to presse to trigger the event */
	play: ParamTemplate<ParamType.BUTTON>;
}
declare class AudioEventNode extends TypedEventNode<AudioEventParamsConfig> {
	paramsConfig: AudioEventParamsConfig;
	static type(): string;
	initializeNode(): void;
	private _sourcePlayer;
	private _triggerPlay;
	private _play;
	dispose(): void;
	private _addPlayerEvent;
	private _removePlayerEvent;
	private _onSourcePlayerStopBound;
	private _onSourcePlayerStop;
	private _getPlayable;
	static PARAM_CALLBACK_play(node: AudioEventNode): void;
}
declare class BlockParamsConfig extends NodeParamsConfig {
	/** @param toggle on to block incoming events */
	blocking: ParamTemplate<ParamType.BOOLEAN>;
}
declare class BlockEventNode extends TypedEventNode<BlockParamsConfig> {
	paramsConfig: BlockParamsConfig;
	static type(): string;
	static readonly OUTPUT = "output";
	initializeNode(): void;
	private trigger_output;
	private _process_incoming_event;
}
declare class ButtonEventParamsConfig extends NodeParamsConfig {
	/** @param button to presse to trigger the event */
	dispatch: ParamTemplate<ParamType.BUTTON>;
}
declare class ButtonEventNode extends TypedEventNode<ButtonEventParamsConfig> {
	paramsConfig: ButtonEventParamsConfig;
	static type(): string;
	initializeNode(): void;
	processEvent(event_context: EventContext<Event>): void;
	private process_event_execute;
	static PARAM_CALLBACK_execute(node: ButtonEventNode): void;
}
declare class OrbitControls {
	constructor(object: Camera, domElement?: HTMLElement);
	object: Camera;
	domElement: HTMLElement | HTMLDocument;
	// API
	enabled: boolean;
	target: Vector3;
	// deprecated
	center: Vector3;
	minDistance: number;
	maxDistance: number;
	minZoom: number;
	maxZoom: number;
	minPolarAngle: number;
	maxPolarAngle: number;
	minAzimuthAngle: number;
	maxAzimuthAngle: number;
	enableDamping: boolean;
	dampingFactor: number;
	enableZoom: boolean;
	zoomSpeed: number;
	enableRotate: boolean;
	rotateSpeed: number;
	enablePan: boolean;
	panSpeed: number;
	screenSpacePanning: boolean;
	keyPanSpeed: number;
	keyRotateSpeedVertical: number;
	keyRotateSpeedHorizontal: number;
	autoRotate: boolean;
	autoRotateSpeed: number;
	enableKeys: boolean;
	keyMode: string;
	keys: {
		LEFT: string;
		UP: string;
		RIGHT: string;
		BOTTOM: string;
	};
	mouseButtons: {
		LEFT: MOUSE;
		MIDDLE: MOUSE;
		RIGHT: MOUSE;
	};
	touches: {
		ONE: TOUCH;
		TWO: TOUCH;
	};
	update(): boolean;
	listenToKeyEvents(domElement: HTMLElement): void;
	saveState(): void;
	reset(): void;
	dispose(): void;
	getPolarAngle(): number;
	getAzimuthalAngle(): number;
	// EventDispatcher mixins
	addEventListener(type: string, listener: (event: any) => void): void;
	hasEventListener(type: string, listener: (event: any) => void): boolean;
	removeEventListener(type: string, listener: (event: any) => void): void;
	dispatchEvent(event: {
		type: string;
		target: any;
	}): void;
}
declare class MapControls extends OrbitControls {
	constructor(object: Camera, domElement?: HTMLElement);
}
declare class CameraOrbitEventParamsConfig extends NodeParamsConfig {
	main: ParamTemplate<ParamType.FOLDER>;
	/** @param enable/disable */
	enabled: ParamTemplate<ParamType.BOOLEAN>;
	/** @param toggle on to allow pan */
	allowPan: ParamTemplate<ParamType.BOOLEAN>;
	/** @param toggle on to allow rotate */
	allowRotate: ParamTemplate<ParamType.BOOLEAN>;
	/** @param toggle on to allow zoom */
	allowZoom: ParamTemplate<ParamType.BOOLEAN>;
	/** @param toggle on to have damping */
	tdamping: ParamTemplate<ParamType.BOOLEAN>;
	/** @param damping value */
	damping: ParamTemplate<ParamType.FLOAT>;
	/** @param toggle on to have the pan in screen space */
	screenSpacePanning: ParamTemplate<ParamType.BOOLEAN>;
	/** @param rotation speed */
	rotateSpeed: ParamTemplate<ParamType.FLOAT>;
	limits: ParamTemplate<ParamType.FOLDER>;
	/** @param smallest distance the camera can go to the target */
	minDistance: ParamTemplate<ParamType.FLOAT>;
	/** @param max distance the camera can go away the target */
	maxDistance: ParamTemplate<ParamType.FLOAT>;
	/** @param toggle on to limit the azimuth (up-down) angle */
	limitAzimuthAngle: ParamTemplate<ParamType.BOOLEAN>;
	/** @param azimuth angle range */
	azimuthAngleRange: ParamTemplate<ParamType.VECTOR2>;
	/** @param polar (left-right) angle range */
	polarAngleRange: ParamTemplate<ParamType.VECTOR2>;
	controls: ParamTemplate<ParamType.FOLDER>;
	/** @param leftMouseButton */
	leftMouseButton: ParamTemplate<ParamType.INTEGER>;
	/** @param leftMouseButton */
	middleMouseButton: ParamTemplate<ParamType.INTEGER>;
	/** @param leftMouseButton */
	rightMouseButton: ParamTemplate<ParamType.INTEGER>;
	/** @param 1 finger touch */
	oneFingerTouch: ParamTemplate<ParamType.INTEGER>;
	/** @param 2 fingers touch */
	twoFingersTouch: ParamTemplate<ParamType.INTEGER>;
	misc: ParamTemplate<ParamType.FOLDER>;
	/** @param target position. This is updated automatically as the camera is controlled by user events */
	target: ParamTemplate<ParamType.VECTOR3>;
}
declare class CameraOrbitControlsEventNode extends TypedCameraControlsEventNode<CameraOrbitEventParamsConfig> {
	paramsConfig: CameraOrbitEventParamsConfig;
	static type(): CameraControlsNodeType;
	endEventName(): string;
	initializeNode(): void;
	private _controlsByElementId;
	private _firstControls;
	protected _createControls(camera: Camera, element: HTMLElement): OrbitControls;
	createControlsInstance(camera: Camera, element: HTMLElement): Promise<OrbitControls>;
	protected _bind_listeners_to_controls_instance(controls: OrbitControls): void;
	setupControls(controls: OrbitControls): void;
	private _set_azimuth_angle;
	updateRequired(): boolean;
	private _on_controls_end;
	static PARAM_CALLBACK_updateTarget(node: CameraOrbitControlsEventNode): void;
	private _updateTarget;
	target(target: Vector3): void;
	setTarget(newTarget: Vector3): void;
	disposeControlsForHtmlElementId(html_element_id: string): void;
	private _updateCache;
}
declare class CameraMapControlsEventNode extends CameraOrbitControlsEventNode {
	static type(): CameraControlsNodeType;
	protected _createControls(camera: Camera, element: HTMLElement): MapControls;
}
declare class DebounceEventParamsConfig extends NodeParamsConfig {
	/** @param max wait time between each event, in milliseconds */
	maxwait: ParamTemplate<ParamType.INTEGER>;
	/** @param defines if event is dispatched on the leading edge of the timeout */
	leading: ParamTemplate<ParamType.BOOLEAN>;
	/** @param defines if event is trailing on the leading edge of the timeout */
	trailing: ParamTemplate<ParamType.BOOLEAN>;
}
declare class DebounceEventNode extends TypedEventNode<DebounceEventParamsConfig> {
	paramsConfig: DebounceEventParamsConfig;
	static type(): string;
	static readonly OUTPUT_NAME = "output";
	initializeNode(): void;
	private _debouncedFunc;
	private _lastEventContextReceived;
	processEvent(eventContext: EventContext<Event>): void;
	private _buildDebouncedFunc;
	private _resetDebouncedFunc;
	static PARAM_CALLBACK_resetDebouncedFunc(node: DebounceEventNode): void;
}
declare class DelayEventParamsConfig extends NodeParamsConfig {
	/** @param delay before dispatching (in milliseconds) */
	delay: ParamTemplate<ParamType.INTEGER>;
}
declare class DelayEventNode extends TypedEventNode<DelayEventParamsConfig> {
	paramsConfig: DelayEventParamsConfig;
	static type(): string;
	initializeNode(): void;
	private _process_input;
}
declare class BaseCodeEventProcessor extends BaseCodeProcessor {
	protected node: CodeEventNode;
	constructor(node: CodeEventNode);
	get pv(): ParamsValueAccessorType<CodeEventParamsConfig>;
	get p(): ParamsAccessorType<CodeEventParamsConfig>;
	get io(): IOController<NodeContext.EVENT>;
	initializeProcessor(): void;
	processTrigger0(eventContext: EventContext<Event>): void;
	processTrigger1(eventContext: EventContext<Event>): void;
	processTrigger2(eventContext: EventContext<Event>): void;
	processTrigger3(eventContext: EventContext<Event>): void;
	processTrigger4(eventContext: EventContext<Event>): void;
	dispatchEventToOutput(outputName: string, eventContext: EventContext<Event>): void;
}
declare class CodeEventParamsConfig extends NodeParamsConfig {
	codeTypescript: ParamTemplate<ParamType.STRING>;
	codeJavascript: ParamTemplate<ParamType.STRING>;
}
declare class CodeEventNode extends TypedEventNode<CodeEventParamsConfig> {
	paramsConfig: CodeEventParamsConfig;
	static BaseCodeEventProcessor: typeof BaseCodeEventProcessor;
	static type(): string;
	private _lastCompiledCode;
	private _processor;
	initializeNode(): void;
	private _processTrigger0;
	private _processTrigger1;
	private _processTrigger2;
	private _processTrigger3;
	private _processTrigger4;
	_dispatchEventToOutputFromProcessor(outputName: string, eventContext: EventContext<Event>): void;
	private _compileIfRequired;
	private _compile;
}
declare class DragEventParamsConfig extends NodeParamsConfig {
	/** @param toggle on to allow any event to be listened to */
	active: ParamTemplate<ParamType.BOOLEAN>;
	/** @param set which element triggers the event */
	element: ParamTemplate<ParamType.INTEGER>;
	/** @param toggle on to listen to dragover events */
	dragover: ParamTemplate<ParamType.BOOLEAN>;
	/** @param requires ctrlKey */
	ctrlKey: ParamTemplate<ParamType.BOOLEAN>;
	/** @param requires altKey */
	altKey: ParamTemplate<ParamType.BOOLEAN>;
	/** @param requires shiftKey */
	shiftKey: ParamTemplate<ParamType.BOOLEAN>;
	/** @param requires metaKey */
	metaKey: ParamTemplate<ParamType.BOOLEAN>;
}
declare class DragEventNode extends TypedInputEventNode<DragEventParamsConfig> {
	paramsConfig: DragEventParamsConfig;
	static type(): EventInputType;
	protected acceptedEventTypes(): Set<DragEventType>;
	initializeNode(): void;
	processEvent(eventContext: EventContext<DragEvent>): void;
}
// @ts-ignore
interface BufferGeometry {
	boundsTree?: MeshBVH;
// @ts-ignore
	computeBoundsTree: typeof computeBoundsTree;
// @ts-ignore
	disposeBoundsTree: typeof disposeBoundsTree;
}
// @ts-ignore
interface Raycaster {
	firstHitOnly?: boolean;
}
interface BufferGeometryWithBVH extends BufferGeometry {
	boundsTree: MeshBVH;
}
interface MeshWithBVH extends Mesh {
	geometry: BufferGeometryWithBVH;
}
declare class MeshBVHUniformStruct {
	updateFrom(bvh: MeshBVH): void;
	dispose(): void;
}
interface CapsuleOptions {
	radius: number;
	height: number;
	divisions: number;
	center: Vector3;
}
interface CorePlayerOptions {
	object: Object3D;
	collider: MeshWithBVH;
}
type ResetRequiredCallback = () => boolean;
declare class CorePlayer {
	private _pressed;
	private _onGround;
	private _velocity;
	readonly capsuleInfo: {
		radius: number;
		segment: Line3;
	};
	object: Object3D;
	collider: MeshWithBVH;
	startPosition: Vector3;
	startRotation: Vector3;
	jumpAllowed: boolean;
	jumpStrength: number;
	runAllowed: boolean;
	runSpeedMult: number;
	private _running;
	speed: number;
	physicsSteps: number;
	gravity: Vector3;
	private _azimuthalAngle;
	private _resetYMax;
	private _resetRequiredCallback;
	constructor(options: CorePlayerOptions);
	setOptions(options: CorePlayerOptions): void;
	private _setObject;
	setCollider(collider: MeshWithBVH): void;
	setCapsule(capsuleOptions: CapsuleOptions): void;
	reset(): void;
	stop(): void;
	setResetRequiredCallback(callback: ResetRequiredCallback): void;
	setAzimuthalAngle(angle: number): void;
	update(delta: number): void;
	private _updateStep;
	setForward(state: boolean): void;
	setBackward(state: boolean): void;
	setLeft(state: boolean): void;
	setRight(state: boolean): void;
	jump(): void;
	setRun(state: boolean): void;
	running(): boolean;
}
interface PointerLockControlsOptions {
	lockHTMLElement?: HTMLElement;
}
declare class PointerLockControls extends EventDispatcher {
	private camera;
	readonly domElement: HTMLElement;
	private options;
	private player?;
	private isLocked;
	minPolarAngle: number;
	maxPolarAngle: number;
	rotateSpeed: number;
	private euler;
	private boundMethods;
	private _azimuthalAngle;
	private _corePlayerKeyEvents;
	constructor(camera: Camera, domElement: HTMLElement, options: PointerLockControlsOptions, player?: CorePlayer | undefined);
	onMouseMove(event: MouseEvent): void;
	private _computeAzimuthalAngle;
	onPointerlockChange(): void;
	onPointerlockError(): void;
	connect(): void;
	disconnect(): void;
	dispose(): void;
	getObject(): Camera;
	lock(): void;
	unlock(): void;
	update(delta: number): void;
	private __unlockHTMLElement;
	private _unlockHTMLElementParent;
	private _unlockHTMLElement;
	private _showUnlockHTMLElement;
	private _getUnlockHTMLElement;
	private _createUnlockHTMLElement;
	private _removeHTMLElement;
}
declare const ColliderParamsConfig_base: {
	new (...args: any[]): {
		colliderObject: ParamTemplate<ParamType.NODE_PATH>;
	};
} & typeof NodeParamsConfig;
declare class ColliderParamsConfig extends ColliderParamsConfig_base {
}
declare abstract class ColliderEventNode extends TypedEventNode<ColliderParamsConfig> {
	abstract player(): CorePlayer | undefined;
	abstract collisionController(): CollisionController;
	static PARAM_CALLBACK_updateCollider(node: ColliderEventNode): void;
}
declare class CollisionController {
	protected node: ColliderEventNode;
	constructor(node: ColliderEventNode);
	private _colliderNode;
	private __colliderNodeGraphNode;
	private _colliderNodeGraphNode;
	getCollider(): Promise<MeshWithBVH | undefined>;
	updateCollider(): Promise<void>;
}
type PointerLockControlsMap = Map<string, PointerLockControls>;
declare class FirstPersonEventParamsConfig extends NodeParamsConfig {
	main: ParamTemplate<ParamType.FOLDER>;
	/** @param collider object */
	colliderObject: ParamTemplate<ParamType.NODE_PATH>;
	/** @param click to lock controls */
	lock: ParamTemplate<ParamType.BUTTON>;
	/** @param click to unlock controls */
	unlock: ParamTemplate<ParamType.BUTTON>;
	/** @param collision Capsule Radius */
	capsuleRadius: ParamTemplate<ParamType.FLOAT>;
	/** @param collision Capsule Height */
	capsuleHeight: ParamTemplate<ParamType.FLOAT>;
	physics: ParamTemplate<ParamType.FOLDER>;
	/** @param physics Steps */
	physicsSteps: ParamTemplate<ParamType.INTEGER>;
	/** @param gravity */
	gravity: ParamTemplate<ParamType.VECTOR3>;
	/** @param translate speed */
	translateSpeed: ParamTemplate<ParamType.FLOAT>;
	/** @param rotate speed */
	rotateSpeed: ParamTemplate<ParamType.FLOAT>;
	/** @param jump Allowed */
	jumpAllowed: ParamTemplate<ParamType.BOOLEAN>;
	/** @param jump Force */
	jumpStrength: ParamTemplate<ParamType.FLOAT>;
	/** @param run Allowed */
	runAllowed: ParamTemplate<ParamType.BOOLEAN>;
	/** @param run speed mult */
	runSpeedMult: ParamTemplate<ParamType.FLOAT>;
	/** @param recompute colliding geo */
	updateCollider: ParamTemplate<ParamType.BUTTON>;
	init: ParamTemplate<ParamType.FOLDER>;
	/** @param start Position */
	startPosition: ParamTemplate<ParamType.VECTOR3>;
	/** @param start Position */
	startRotation: ParamTemplate<ParamType.VECTOR3>;
	/** @param reset */
	reset: ParamTemplate<ParamType.BUTTON>;
	/** @param min rotation angle */
	minPolarAngle: ParamTemplate<ParamType.FLOAT>;
	/** @param max rotation angle */
	maxPolarAngle: ParamTemplate<ParamType.FLOAT>;
	html: ParamTemplate<ParamType.FOLDER>;
	/** @param specify a custom HTML element */
	customLockCursorElement: ParamTemplate<ParamType.BOOLEAN>;
	/** @param jump HTML element selector */
	lockCursorElementSelector: ParamTemplate<ParamType.STRING>;
}
declare class FirstPersonControlsEventNode extends TypedCameraControlsEventNode<FirstPersonEventParamsConfig> {
	paramsConfig: FirstPersonEventParamsConfig;
	static type(): CameraControlsNodeType;
	endEventName(): string;
	static readonly INPUT_UPDATE_COLLIDER = "updateCollider";
	static readonly INPUT_RESET = "reset";
	private _collisionController;
	collisionController(): CollisionController;
	initializeNode(): void;
	protected _controls_by_element_id: PointerLockControlsMap;
	private _player;
	createControlsInstance(camera: Camera, element: HTMLElement): Promise<PointerLockControls>;
	private _initPlayer;
	private _playerOptions;
	player(): CorePlayer | undefined;
	private _updatePlayerParams;
	private _resetPlayer;
	private _updateCollider;
	protected _bind_listeners_to_controls_instance(controls: PointerLockControls): void;
	updateRequired(): boolean;
	setupControls(controls: PointerLockControls): void;
	disposeControlsForHtmlElementId(htmlElementId: string): void;
	unlockControls(): void;
	private lockControls;
	private _firstControls;
	static PARAM_CALLBACK_lockControls(node: FirstPersonControlsEventNode): void;
	static PARAM_CALLBACK_unlockControls(node: FirstPersonControlsEventNode): void;
	static PARAM_CALLBACK_updateCollider(node: FirstPersonControlsEventNode): void;
	static PARAM_CALLBACK_updatePlayerParams(node: FirstPersonControlsEventNode): void;
	static PARAM_CALLBACK_resetPlayer(node: FirstPersonControlsEventNode): void;
}
declare class IntersectDataParamsConfig extends NodeParamsConfig {
	/** @param geometry vertex attribute to read */
	attributeName: ParamTemplate<ParamType.STRING>;
	/** @param type of attribute */
	attributeType: ParamTemplate<ParamType.INTEGER>;
	/** @param attribute value for float */
	attributeValue1: ParamTemplate<ParamType.FLOAT>;
	/** @param attribute value that attributeValue1 is set to when no object is intersected */
	resetValue1: ParamTemplate<ParamType.FLOAT>;
	/** @param attribute value for string */
	attributeValues: ParamTemplate<ParamType.STRING>;
	/** @param attribute value that attributeValues is set to when no object is intersected */
	resetValues: ParamTemplate<ParamType.STRING>;
}
declare class IntersectDataEventNode extends TypedEventNode<IntersectDataParamsConfig> {
	paramsConfig: IntersectDataParamsConfig;
	static type(): string;
	static readonly INPUT_HIT = "hit";
	static readonly INPUT_MISS = "miss";
	initializeNode(): void;
	private _processHit;
	private _processMiss;
	private _resolveIntersectAttribute;
	static resolveObjectAttribute(intersection: Intersection, attribName: string): string | number | undefined;
}
declare class LimitEventParamsConfig extends NodeParamsConfig {
	/** @param max number of events that can be processed */
	maxCount: ParamTemplate<ParamType.INTEGER>;
	/** @param resets the count */
	reset: ParamTemplate<ParamType.BUTTON>;
}
declare class LimitEventNode extends TypedEventNode<LimitEventParamsConfig> {
	paramsConfig: LimitEventParamsConfig;
	static type(): string;
	private _process_count;
	private _last_dispatched;
	initializeNode(): void;
	processEvent(event_context: EventContext<Event>): void;
	private processEventTrigger;
	private process_event_reset;
	static PARAM_CALLBACK_reset(node: LimitEventNode): void;
}
declare class MessageParamsConfig extends NodeParamsConfig {
	/** @param toggle on for the message to be displayed in a popup */
	alert: ParamTemplate<ParamType.BOOLEAN>;
	/** @param toggle on for the message to be printed in the console */
	console: ParamTemplate<ParamType.BOOLEAN>;
}
declare class MessageEventNode extends TypedEventNode<MessageParamsConfig> {
	paramsConfig: MessageParamsConfig;
	static type(): string;
	static readonly OUTPUT = "output";
	initializeNode(): void;
	private trigger_output;
	private _process_trigger_event;
}
// @ts-ignore
declare class Capsule {
	constructor(start?: Vector3, end?: Vector3, radius?: number);
	start: Vector3;
	end: Vector3;
	radius: number;
	set(start: Vector3, end: Vector3, radius: number): this;
	clone(): Capsule;
	copy(capsule: Capsule): this;
	getCenter(target: Vector3): Vector3;
	translate(v: Vector3): this;
	checkAABBAxis(p1x: number, p1y: number, p2x: number, p2y: number, minx: number, maxx: number, miny: number, maxy: number, radius: number): boolean;
	intersectsBox(box: Box3): boolean;
	lineLineMinimumPoints(line1: Line3, line2: Line3): Vector3[];
}
interface CapsuleCollisionResult {
	normal: Vector3;
	point: Vector3;
	depth: number;
}
declare class PlayerCollisionController {
	private _object;
	private _octree;
	private _capsuleHeight;
	private _capsule;
	constructor(_object: Object3D);
	setCapsule(capsule: Capsule): void;
	testPosition(position: Vector3): CapsuleCollisionResult | false;
}
// @ts-ignore
declare class Capsule {
	constructor(start?: Vector3, end?: Vector3, radius?: number);
	start: Vector3;
	end: Vector3;
	radius: number;
	set(start: Vector3, end: Vector3, radius: number): this;
	clone(): Capsule;
	copy(capsule: Capsule): this;
	getCenter(target: Vector3): Vector3;
	translate(v: Vector3): this;
	checkAABBAxis(p1x: number, p1y: number, p2x: number, p2y: number, minx: number, maxx: number, miny: number, maxy: number, radius: number): boolean;
	intersectsBox(box: Box3): boolean;
	lineLineMinimumPoints(line1: Line3, line2: Line3): Vector3[];
}
interface JumpParams {
	duration: number;
	force: number;
}
declare class BaseCollisionHandler extends EventDispatcher {
	protected _playerCollisionController: PlayerCollisionController | undefined;
	setCheckCollisions(collisionObject?: Object3D): void;
	setCollisionCapsule(capsule: Capsule): void;
	setJumpParams(params: JumpParams): void;
	setGravity(gravity: Vector3): void;
	setPlayerMass(mass: number): void;
}
interface RotationRange {
	min: number;
	max: number;
}
interface MobileJoystickControlsOptions {
	translateDomElement?: HTMLElement;
	jumpDomElement?: HTMLElement;
	runDomElement?: HTMLElement;
}
declare class MobileJoystickControls extends BaseCollisionHandler {
	private _camera;
	private domElement;
	private options;
	private player?;
	private translationData;
	private rotationData;
	private _boundMethods;
	private _startCameraRotation;
	private _rotationSpeed;
	private _rotationRange;
	private _azimuthalAngle;
	private _translateDomElement;
	private _translateDomElementRect;
	private _jumpDomElement;
	private _runDomElement;
	constructor(_camera: Camera, domElement: HTMLElement, options: MobileJoystickControlsOptions, player?: CorePlayer | undefined);
	dispose(): void;
	private _createTranslateDomElement;
	private _jumpDomElementSize;
	private _createJumpDomElement;
	private _createRunDomElement;
	private _addElements;
	private _removeElements;
	updateElements(): void;
	private _addEvents;
	private _removeEvents;
	setRotationSpeed(speed: number): void;
	setRotationRange(range: RotationRange): void;
	private vLeft;
	private vRight;
	private vTop;
	private vBottom;
	private angleY;
	private angleX;
	private _rotationStartPosition;
	private _rotationMovePosition;
	private _rotationDelta;
	private _onRotateStart;
	private _onRotateMove;
	private _onRotateEnd;
	private _rotateCamera;
	private _computeAzimuthalAngle;
	private _startCameraPosition;
	private _translationStartPosition;
	private _translationMovePosition;
	private _translationDelta;
	private _onTranslateStart;
	private _onTranslateMove;
	private _onTranslateEnd;
	private _updatePlayerTranslate;
	private _onJump;
	private _onRunToggle;
	update(delta: number): void;
	private _getTouch;
}
declare class MobileJoystickEventParamsConfig extends NodeParamsConfig {
	main: ParamTemplate<ParamType.FOLDER>;
	/** @param collider object */
	colliderObject: ParamTemplate<ParamType.NODE_PATH>;
	/** @param collision Capsule Radius */
	capsuleRadius: ParamTemplate<ParamType.FLOAT>;
	/** @param collision Capsule Height */
	capsuleHeight: ParamTemplate<ParamType.FLOAT>;
	physics: ParamTemplate<ParamType.FOLDER>;
	/** @param physics Steps */
	physicsSteps: ParamTemplate<ParamType.INTEGER>;
	/** @param gravity */
	gravity: ParamTemplate<ParamType.VECTOR3>;
	/** @param translation speed */
	translateSpeed: ParamTemplate<ParamType.FLOAT>;
	/** @param rotation speed */
	rotateSpeed: ParamTemplate<ParamType.FLOAT>;
	/** @param specify a custom HTML element */
	customTranslateElement: ParamTemplate<ParamType.BOOLEAN>;
	/** @param jump HTML element selector */
	translateElementSelector: ParamTemplate<ParamType.STRING>;
	/** @param jump Allowed */
	jumpAllowed: ParamTemplate<ParamType.BOOLEAN>;
	/** @param jump Force */
	jumpStrength: ParamTemplate<ParamType.FLOAT>;
	/** @param specify a custom HTML element */
	customJumpElement: ParamTemplate<ParamType.BOOLEAN>;
	/** @param jump HTML element selector */
	jumpElementSelector: ParamTemplate<ParamType.STRING>;
	/** @param run Allowed */
	runAllowed: ParamTemplate<ParamType.BOOLEAN>;
	/** @param run speed mult */
	runSpeedMult: ParamTemplate<ParamType.FLOAT>;
	/** @param specify a custom HTML element */
	customRunElement: ParamTemplate<ParamType.BOOLEAN>;
	/** @param jump HTML element selector */
	runElementSelector: ParamTemplate<ParamType.STRING>;
	/** @param recompute colliding geo */
	updateCollider: ParamTemplate<ParamType.BUTTON>;
	init: ParamTemplate<ParamType.FOLDER>;
	/** @param start Position */
	startPosition: ParamTemplate<ParamType.VECTOR3>;
	/** @param start Position */
	startRotation: ParamTemplate<ParamType.VECTOR3>;
	/** @param reset */
	reset: ParamTemplate<ParamType.BUTTON>;
	/** @param min polar angle */
	minPolarAngle: ParamTemplate<ParamType.FLOAT>;
	/** @param max polar angle */
	maxPolarAngle: ParamTemplate<ParamType.FLOAT>;
}
declare class MobileJoystickControlsEventNode extends TypedCameraControlsEventNode<MobileJoystickEventParamsConfig> {
	paramsConfig: MobileJoystickEventParamsConfig;
	static type(): CameraControlsNodeType;
	endEventName(): string;
	static readonly INPUT_UPDATE_COLLIDER = "updateCollider";
	private _collisionController;
	collisionController(): CollisionController;
	initializeNode(): void;
	private _controls_by_element_id;
	private _player;
	createControlsInstance(camera: Camera, element: HTMLElement): Promise<MobileJoystickControls>;
	private _initPlayer;
	private _playerOptions;
	player(): CorePlayer | undefined;
	private _updatePlayerParams;
	private _resetPlayer;
	private _updateCollider;
	protected _bind_listeners_to_controls_instance(controls: MobileJoystickControls): void;
	updateRequired(): boolean;
	setupControls(controls: MobileJoystickControls): void;
	disposeControlsForHtmlElementId(html_element_id: string): void;
	static PARAM_CALLBACK_updateCollider(node: MobileJoystickControlsEventNode): void;
	static PARAM_CALLBACK_updatePlayerParams(node: MobileJoystickControlsEventNode): void;
	static PARAM_CALLBACK_resetPlayer(node: MobileJoystickControlsEventNode): void;
}
declare class NodeCookEventParamsConfig extends NodeParamsConfig {
	/** @param mask to select which nodes this will cook or listen to */
	mask: ParamTemplate<ParamType.STRING>;
	/** @param forces cook of nodes mentioned in the mask param */
	force: ParamTemplate<ParamType.BOOLEAN>;
	/** @param defines if the nodes should cook one after the other or in parallel */
	cookMode: ParamTemplate<ParamType.INTEGER>;
	/** @param batch size */
	batchSize: ParamTemplate<ParamType.INTEGER>;
	/** @param if on, we only trigger the first time a specific node has cooked. If false, we register every time a node cooks */
	registerOnlyFirstCooks: ParamTemplate<ParamType.BOOLEAN>;
	/** @param updates the list of nodes from the mask parameter. This can be useful if nodes are added or removed from the scene */
	updateResolve: ParamTemplate<ParamType.BUTTON>;
	/** @param prints the list of nodes the mask resolves to to the console. Useful for debugging */
	printResolve: ParamTemplate<ParamType.BUTTON>;
}
declare class NodeCookEventNode extends TypedEventNode<NodeCookEventParamsConfig> {
	paramsConfig: NodeCookEventParamsConfig;
	static type(): Readonly<"nodeCook">;
	static readonly INPUT_TRIGGER = "trigger";
	static readonly OUTPUT_FIRST_NODE = "first";
	static readonly OUTPUT_EACH_NODE = "each";
	static readonly OUTPUT_ALL_NODES = "all";
	private _resolvedNodes;
	initializeNode(): void;
	trigger(): void;
	cook(): void;
	dispose(): void;
	resolvedNodes(): BaseNodeType[];
	private processEventTrigger;
	private _cookNodesWithMode;
	private _cookNodesAllTogether;
	private _cookNodesInBatch;
	private _cookNodes;
	private _cookNode;
	static PARAM_CALLBACK_updateResolvedNodes(node: NodeCookEventNode): void;
	private _updateResolvedNodes;
	private _callbackNameForNode;
	private _dispatchedFirstNodeCooked;
	private _dispatchedAllNodesCooked;
	private _cookStateByNodeId;
	private _reset;
	private _allNodesHaveCooked;
	private _onNodeCookComplete;
	static PARAM_CALLBACK_updateResolve(node: NodeCookEventNode): void;
	static PARAM_CALLBACK_printResolve(node: NodeCookEventNode): void;
	private printResolve;
}
declare class NullEventParamsConfig extends NodeParamsConfig {
}
declare class NullEventNode extends TypedEventNode<NullEventParamsConfig> {
	paramsConfig: NullEventParamsConfig;
	static type(): string;
	initializeNode(): void;
	processEvent(event_context: EventContext<Event>): void;
	private processEventTrigger;
}
declare class ParamEventParamsConfig extends NodeParamsConfig {
	/** @param set to listen or stop listening to the param */
	active: ParamTemplate<ParamType.BOOLEAN>;
	/** @param the parameter to update */
	param: ParamTemplate<ParamType.PARAM_PATH>;
	boolean: ParamTemplate<ParamType.BOOLEAN>;
	integer: ParamTemplate<ParamType.INTEGER>;
	float: ParamTemplate<ParamType.FLOAT>;
	vector2: ParamTemplate<ParamType.VECTOR2>;
	vector3: ParamTemplate<ParamType.VECTOR3>;
	vector4: ParamTemplate<ParamType.VECTOR4>;
	ramp: ParamTemplate<ParamType.RAMP>;
	string: ParamTemplate<ParamType.STRING>;
}
declare class ParamEventNode extends TypedEventNode<ParamEventParamsConfig> {
	paramsConfig: ParamEventParamsConfig;
	static type(): Readonly<"param">;
	static readonly OUTPUT_NAME = "valueChanged";
	initializeNode(): void;
	cook(): Promise<void>;
	dispose(): void;
	private _reset;
	private _resolvedParam;
	private _previousValueParam;
	private _listenToParam;
	private paramGraphNode;
	private __paramCoreGraphNode__;
	private _createCoreGraphNode;
	private _onParamDirtyBound;
	private _onParamDirty;
}
declare class RaycastCPUVelocityController {
	private _node;
	constructor(_node: RaycastEventNode);
	private _prevPosition;
	private _foundVelocityTargetParam;
	private _hitVelocity;
	private _hitVelocityArray;
	process(hitPosition: Vector3): void;
	reset(): void;
}
declare class CursorHelper {
	setCursorForCPU(context: EventContext<MouseEvent | DragEvent | PointerEvent | TouchEvent>, target: Vector2): void;
	setCursorForGPU(context: EventContext<MouseEvent | DragEvent | PointerEvent | TouchEvent>, target: Vector2): void;
	private setCursor;
	private _updateFromCursor;
}
declare class BaseRaycastController {
	protected _cursorHelper: CursorHelper;
	protected _cursor: Vector2;
}
declare class RaycastCPUController extends BaseRaycastController {
	private _node;
	private _cursorArray;
	private _resolvedTargets;
	readonly velocityController: RaycastCPUVelocityController;
	constructor(_node: RaycastEventNode);
	updateMouse(eventContext: EventContext<MouseEvent | DragEvent | PointerEvent | TouchEvent>): void;
	processEvent(context: EventContext<MouseEvent>): void;
	private _plane;
	private _plane_intersect_target;
	private _intersectPlane;
	private _intersections;
	private _intersectGeometry;
	private _resolveIntersectAttribute;
	private _foundPositionTargetParam;
	private _hitPositionArray;
	private _setPositionParam;
	private _prepareRaycaster;
	updateTarget(): void;
	private _updateTargetFromNode;
	private _updateTargetFromSceneGraph;
	static PARAM_CALLBACK_updateTarget(node: RaycastEventNode): void;
}
declare class RaycastGPUController extends BaseRaycastController {
	private _node;
	private _resolvedMaterial;
	private _restoreContext;
	private _cursorArray;
	private _renderTarget;
	private _read;
	private _paramColor;
	private _paramAlpha;
	constructor(_node: RaycastEventNode);
	updateMouse(eventContext: EventContext<MouseEvent | DragEvent | PointerEvent>): void;
	processEvent(context: EventContext<MouseEvent>): void;
	private _modifySceneAndRenderer;
	private _restoreSceneAndRenderer;
	private _updateMaterial;
	static PARAM_CALLBACK_updateMaterial(node: RaycastEventNode): void;
}
declare class RaycastParamsConfig extends NodeParamsConfig {
	/** @param defines if the ray detection is done on the CPU or GPU (GPU being currently experimental) */
	mode: ParamTemplate<ParamType.INTEGER>;
	/** @param defines if the mouse parameter is update when the cursor screen position changes */
	tmouse: ParamTemplate<ParamType.BOOLEAN>;
	/** @param mouse coordinates (0,0) being the center of the screen, (-1,-1) being the bottom left corner and (1,1) being the top right corner */
	mouse: ParamTemplate<ParamType.VECTOR2>;
	/** @param by default the ray is sent from the current camera, but this allows to set another camera */
	/** @param by default the ray is sent from the current camera, but this allows to set a custom ray */
	/** @param the camera to override to */
	/** @param the ray origin */
	/** @param the ray direction */
	/** @param the material to use on the scene for GPU detection */
	overrideMaterial: ParamTemplate<ParamType.BOOLEAN>;
	/** @param the material to use on the scene for GPU detection */
	material: ParamTemplate<ParamType.NODE_PATH>;
	/** @param the current pixel color being read */
	pixelColor: ParamTemplate<ParamType.COLOR>;
	pixelAlpha: ParamTemplate<ParamType.FLOAT>;
	/** @param the value threshold for which a hit is detected */
	hitThreshold: ParamTemplate<ParamType.FLOAT>;
	/** @param defines the hit it tested against geometry or just a plane */
	intersectWith: ParamTemplate<ParamType.INTEGER>;
	/** @param threshold used to test hit with points */
	pointsThreshold: ParamTemplate<ParamType.FLOAT>;
	/** @param plane direction if the hit is tested against a plane */
	planeDirection: ParamTemplate<ParamType.VECTOR3>;
	/** @param plane offset if the hit is tested against a plane */
	planeOffset: ParamTemplate<ParamType.FLOAT>;
	targetType: ParamTemplate<ParamType.INTEGER>;
	/** @param node whose objects to test hit against, when testing against geometries */
	targetNode: ParamTemplate<ParamType.NODE_PATH>;
	/** @param objects to test hit against, when testing against geometries */
	objectMask: ParamTemplate<ParamType.STRING>;
	/** @param toggle to hit if tested against children */
	traverseChildren: ParamTemplate<ParamType.BOOLEAN>;
	/** @param toggle on to update hit position */
	tposition: ParamTemplate<ParamType.BOOLEAN>;
	/** @param toggle on to set the param to the hit position */
	tpositionTarget: ParamTemplate<ParamType.BOOLEAN>;
	/** @param this will be set to the hit position */
	position: ParamTemplate<ParamType.VECTOR3>;
	/** @param this parameter will be set to the hit position */
	positionTarget: ParamTemplate<ParamType.PARAM_PATH>;
	/** @param toggle on to set the param to the mouse velocity (experimental) */
	tvelocity: ParamTemplate<ParamType.BOOLEAN>;
	/** @param toggle on to set the param to the mouse velocity */
	tvelocityTarget: ParamTemplate<ParamType.BOOLEAN>;
	/** @param this will be set to the mouse velocity */
	velocity: ParamTemplate<ParamType.VECTOR3>;
	/** @param this will be set to the mouse velocity */
	velocityTarget: ParamTemplate<ParamType.PARAM_PATH>;
	/** @param for geometry hit tests, a vertex attribute can be read */
	geoAttribute: ParamTemplate<ParamType.BOOLEAN>;
	/** @param geometry vertex attribute to read */
	geoAttributeName: ParamTemplate<ParamType.STRING>;
	/** @param type of attribute */
	geoAttributeType: ParamTemplate<ParamType.INTEGER>;
	/** @param attribute value for float */
	geoAttributeValue1: ParamTemplate<ParamType.FLOAT>;
	/** @param attribute value for string */
	geoAttributeValues: ParamTemplate<ParamType.STRING>;
}
declare class RaycastEventNode extends TypedEventNode<RaycastParamsConfig> {
	paramsConfig: RaycastParamsConfig;
	static type(): string;
	static readonly INPUT_TRIGGER = "trigger";
	static readonly INPUT_MOUSE = "mouse";
	static readonly INPUT_UPDATE_OBJECTS = "updateObjects";
	static readonly INPUT_TRIGGER_VEL_RESET = "triggerVelReset";
	static readonly OUTPUT_HIT = "hit";
	static readonly OUTPUT_MISS = "miss";
	readonly cpuController: RaycastCPUController;
	readonly gpuController: RaycastGPUController;
	initializeNode(): void;
	triggerHit(context: EventContext<MouseEvent>): void;
	triggerMiss(context: EventContext<MouseEvent>): void;
	private _processMouseEvent;
	private _lastEventProcessedAt;
	private _processTriggerEventThrottled;
	private _processTriggerEvent;
	private _processTriggerUpdateObjects;
	private _processTriggerVelReset;
}
declare class SceneEventParamsConfig extends NodeParamsConfig {
	/** @param toggle on to allow any event to be listened to */
	active: ParamTemplate<ParamType.BOOLEAN>;
	/** @param set which element triggers the event */
	element: ParamTemplate<ParamType.INTEGER>;
	/** @param toggle on to trigger an event when the scene has been created. This can be useful to initialize other nodes */
	created: ParamTemplate<ParamType.BOOLEAN>;
	/** @param toggle on to trigger an event when every object in the scene has been loaded. This can be useful to initialize other nodes */
	ready: ParamTemplate<ParamType.BOOLEAN>;
	/** @param toggle on to trigger an event when the scene starts playing */
	play: ParamTemplate<ParamType.BOOLEAN>;
	/** @param toggle on to trigger an event when the scene pauses */
	pause: ParamTemplate<ParamType.BOOLEAN>;
	/** @param toggle on to trigger an event on every tick */
	tick: ParamTemplate<ParamType.BOOLEAN>;
	/** @param toggle on to trigger an event on every tick */
	treachedTime: ParamTemplate<ParamType.BOOLEAN>;
	/** @param time to trigger an event */
	reachedTime: ParamTemplate<ParamType.FLOAT>;
	/** @param frame to set */
	setFrameValue: ParamTemplate<ParamType.INTEGER>;
	/** @param button to set a specific frame */
	setFrame: ParamTemplate<ParamType.BUTTON>;
}
declare class SceneEventNode extends TypedEventNode<SceneEventParamsConfig> {
	paramsConfig: SceneEventParamsConfig;
	static type(): string;
	private _graphNode;
	dispose(): void;
	initializeNode(): void;
	processEvent(eventContext: EventContext<Event>): Promise<void> | undefined;
	private _onSetFrame;
	private _play;
	private _pause;
	private _timeReached;
	private _onTickCheckTimeReached;
	private _onTickEvent;
	private _updateTimeDependency;
	private _buildOnTickCallback;
	static PARAM_CALLBACK_setFrame(node: SceneEventNode): void;
	static PARAM_CALLBACK_updateTimeDependency(node: SceneEventNode): void;
	static PARAM_CALLBACK_updateSceneEventsController(node: SceneEventNode): void;
	static PARAM_CALLBACK_updateActiveState(node: SceneEventNode): void;
	private _updateSceneEventsController;
}
declare class ScrollTriggerParamsConfig extends NodeParamsConfig {
	/** @param active */
	active: ParamTemplate<ParamType.BOOLEAN>;
	/** @param selector of the element the scroll events are detected for */
	element: ParamTemplate<ParamType.STRING>;
	/** @param use viewport as scroller */
	useViewport: ParamTemplate<ParamType.BOOLEAN>;
	/** @param override the scroller */
	scroller: ParamTemplate<ParamType.STRING>;
	/** @param add markers for debugging */
	markers: ParamTemplate<ParamType.BOOLEAN>;
	/** @param define if progress should be updated */
	tprogress: ParamTemplate<ParamType.BOOLEAN>;
	/** @param progress */
	progress: ParamTemplate<ParamType.FLOAT>;
	/** @param define if the scroll is inside the element */
	tinsideElement: ParamTemplate<ParamType.BOOLEAN>;
	/** @param 1 if the scroll is inside the element */
	insideElement: ParamTemplate<ParamType.BOOLEAN>;
	/** @param sends a trigger when we leaving or entering the element */
	onToggle: ParamTemplate<ParamType.BOOLEAN>;
	/** @param sends a trigger when entering the element */
	onEnter: ParamTemplate<ParamType.BOOLEAN>;
	/** @param sends a trigger when leaving the element */
	onLeave: ParamTemplate<ParamType.BOOLEAN>;
	/** @param sends a trigger when entering again the element */
	onEnterBack: ParamTemplate<ParamType.BOOLEAN>;
	/** @param sends a trigger when leaving again the element */
	onLeaveBack: ParamTemplate<ParamType.BOOLEAN>;
}
declare class ScrollTriggerEventNode extends TypedEventNode<ScrollTriggerParamsConfig> {
	paramsConfig: ScrollTriggerParamsConfig;
	gsap: any | undefined;
	ScrollTrigger: any;
	static type(): string;
	requiredModules(): ModuleName[];
	dispose(): void;
	initializeNode(): void;
	private _scrollTrigger;
	private _onCreateTrigger;
	private _updateScrollTrigger;
	private _onDisposeTrigger;
	private _disposeScrollTrigger;
	private _querySelector;
	static PARAM_CALLBACK_updateScrollTrigger(node: ScrollTriggerEventNode): void;
}
declare class SetFlagParamsConfig extends NodeParamsConfig {
	/** @param mask to select which nodes this can change the flags of */
	mask: ParamTemplate<ParamType.STRING>;
	/** @param toggle on to update the display flag */
	tdisplay: ParamTemplate<ParamType.BOOLEAN>;
	/** @param sets how the display flag will be updated (set to a value or toggle) */
	displayMode: ParamTemplate<ParamType.INTEGER>;
	/** @param new display flag state */
	display: ParamTemplate<ParamType.BOOLEAN>;
	/** @param toggle on to update the bypass flag */
	tbypass: ParamTemplate<ParamType.BOOLEAN>;
	/** @param sets how the bypass flag will be updated (set to a value or toggle) */
	bypassMode: ParamTemplate<ParamType.INTEGER>;
	/** @param new bypass flag state */
	bypass: ParamTemplate<ParamType.BOOLEAN>;
	/** @param button to trigger the node. Useful to debug */
	execute: ParamTemplate<ParamType.BUTTON>;
}
declare class SetFlagEventNode extends TypedEventNode<SetFlagParamsConfig> {
	paramsConfig: SetFlagParamsConfig;
	static type(): string;
	initializeNode(): void;
	processEvent(eventContext: EventContext<Event>): Promise<void>;
	private _updateNodeFlags;
	private _updateNodeDisplayFlag;
	private _updateNodeBypassFlag;
	static PARAM_CALLBACK_execute(node: SetFlagEventNode): void;
}
declare enum SetParamParamType {
	BOOLEAN = "boolean",
	BUTTON = "button",
	NUMBER = "number",
	VECTOR2 = "vector2",
	VECTOR3 = "vector3",
	VECTOR4 = "vector4",
	STRING = "string"
}
declare class SetParamParamsConfig extends NodeParamsConfig {
	/** @param the parameter to update */
	param: ParamTemplate<ParamType.PARAM_PATH>;
	/** @param type of the parameter to update */
	type: ParamTemplate<ParamType.INTEGER>;
	/** @param for a boolean parameter, sets to toggle its value */
	toggle: ParamTemplate<ParamType.BOOLEAN>;
	/** @param if toggle is set to off, this will set the value of the parameter */
	boolean: ParamTemplate<ParamType.BOOLEAN>;
	/** @param param value for a float parameter */
	number: ParamTemplate<ParamType.FLOAT>;
	/** @param param value for a vector2 parameter */
	vector2: ParamTemplate<ParamType.VECTOR2>;
	/** @param param value for a vector3 parameter */
	vector3: ParamTemplate<ParamType.VECTOR3>;
	/** @param param value for a vector4 parameter */
	vector4: ParamTemplate<ParamType.VECTOR4>;
	/** @param if on, the value will be incremented by the value, as opposed to be set to the value */
	increment: ParamTemplate<ParamType.BOOLEAN>;
	/** @param param value for a string parameter */
	string: ParamTemplate<ParamType.STRING>;
	/** @param execute button to test the node */
	execute: ParamTemplate<ParamType.BUTTON>;
}
declare class SetParamEventNode extends TypedEventNode<SetParamParamsConfig> {
	paramsConfig: SetParamParamsConfig;
	static type(): string;
	initializeNode(): void;
	setParamType(paramType: SetParamParamType): void;
	processEvent(event_context: EventContext<Event>): Promise<void>;
	private _tmp_vector2;
	private _tmp_vector3;
	private _tmp_vector4;
	private _tmp_array2;
	private _tmp_array3;
	private _tmp_array4;
	private _newParamValue;
	static PARAM_CALLBACK_execute(node: SetParamEventNode): void;
	private _computeParamsIfDirty;
}
declare class PassEventParamsConfig extends NodeParamsConfig {
	/** @param number of possible outputs */
	outputsCount: ParamTemplate<ParamType.INTEGER>;
}
declare class SequenceEventNode extends TypedEventNode<PassEventParamsConfig> {
	paramsConfig: PassEventParamsConfig;
	static type(): string;
	initializeNode(): void;
	private _expected_output_types;
	protected _output_name(index: number): string;
	processEvent(event_context: EventContext<Event>): void;
}
declare class ThrottleEventParamsConfig extends NodeParamsConfig {
	/** @param max time between each event */
	time: ParamTemplate<ParamType.INTEGER>;
	/** @param defines if event is dispatched on the leading edge of the timeout */
	leading: ParamTemplate<ParamType.BOOLEAN>;
	/** @param defines if event is trailing on the leading edge of the timeout */
	trailing: ParamTemplate<ParamType.BOOLEAN>;
}
declare class ThrottleEventNode extends TypedEventNode<ThrottleEventParamsConfig> {
	paramsConfig: ThrottleEventParamsConfig;
	static type(): string;
	static readonly OUTPUT_NAME = "output";
	initializeNode(): void;
	private _debouncedFunc;
	private _lastEventContextReceived;
	processEvent(eventContext: EventContext<Event>): void;
	private _buildDebouncedFunc;
	private _resetDebouncedFunc;
	static PARAM_CALLBACK_resetDebouncedFunc(node: ThrottleEventNode): void;
}
declare class TimerEventParamsConfig extends NodeParamsConfig {
	/** @param period between each interval */
	period: ParamTemplate<ParamType.INTEGER>;
	/** @param number of times the timer should repeat. Set to -1 to never stop */
	count: ParamTemplate<ParamType.INTEGER>;
}
declare class TimerEventNode extends TypedEventNode<TimerEventParamsConfig> {
	paramsConfig: TimerEventParamsConfig;
	static type(): string;
	initializeNode(): void;
	private _timer_active;
	private _current_count;
	private _start_timer;
	protected _stop_timer(): void;
	private _run_timer;
}
declare class TouchEventParamsConfig extends NodeParamsConfig {
	/** @param toggle on to allow any event to be listened to */
	active: ParamTemplate<ParamType.BOOLEAN>;
	/** @param set which element triggers the event */
	element: ParamTemplate<ParamType.INTEGER>;
	/** @param toggle on to listen to touchstart events */
	touchstart: ParamTemplate<ParamType.BOOLEAN>;
	/** @param toggle on to listen to touchmove events */
	touchmove: ParamTemplate<ParamType.BOOLEAN>;
	/** @param toggle on to listen to touchend events */
	touchend: ParamTemplate<ParamType.BOOLEAN>;
}
declare class TouchEventNode extends TypedInputEventNode<TouchEventParamsConfig> {
	paramsConfig: TouchEventParamsConfig;
	static type(): EventInputType;
	protected acceptedEventTypes(): Set<TouchEventType>;
	initializeNode(): void;
	processEvent(eventContext: EventContext<TouchEvent>): void;
}
declare class ViewerParamsConfig extends NodeParamsConfig {
	/** @param sets the class of the viewer */
	className: ParamTemplate<ParamType.STRING>;
}
declare class ViewerEventNode extends TypedEventNode<ViewerParamsConfig> {
	paramsConfig: ViewerParamsConfig;
	static type(): string;
	initializeNode(): void;
	private _getViewer;
	private _process_trigger_setClass;
	private _process_trigger_unsetClass;
}
declare class WindowEventParamsConfig extends NodeParamsConfig {
	/** @param toggle on to allow any event to be listened to */
	active: ParamTemplate<ParamType.BOOLEAN>;
	/** @param set which element triggers the event */
	element: ParamTemplate<ParamType.INTEGER>;
	/** @param toggle on to listen to resize events */
	resize: ParamTemplate<ParamType.BOOLEAN>;
}
declare class WindowEventNode extends TypedInputEventNode<WindowEventParamsConfig> {
	paramsConfig: WindowEventParamsConfig;
	static type(): EventInputType;
	protected acceptedEventTypes(): Set<WindowEventType>;
	initializeNode(): void;
	processEvent(eventContext: EventContext<Event>): void;
}
declare class ParamLessNetworkEventParamsConfig extends NodeParamsConfig {
}
declare class BaseNetworkEventNode<K extends NodeParamsConfig> extends TypedNode<NodeContext.EVENT, K> {
	static context(): NodeContext;
	cook(): void;
}
declare class ParamLessBaseNetworkEventNode extends BaseNetworkEventNode<ParamLessNetworkEventParamsConfig> {
}
declare class ActorsNetworkEventNode extends ParamLessBaseNetworkEventNode {
	static type(): NetworkNodeType;
	protected _childrenControllerContext: NodeContext;
	createNode<S extends keyof JsNodeChildrenMap>(node_class: S, options?: NodeCreateOptions): JsNodeChildrenMap[S];
	createNode<K extends valueof<JsNodeChildrenMap>>(node_class: Constructor<K>, options?: NodeCreateOptions): K;
	children(): BaseJsNodeType[];
	nodesByType<K extends keyof JsNodeChildrenMap>(type: K): JsNodeChildrenMap[K][];
	childrenAllowed(): boolean;
	sceneReadonly(): boolean;
	readonly persisted_config: ActorPersistedConfig;
	assemblerController(): JsAssemblerController<JsAssemblerActor> | undefined;
	usedAssembler(): Readonly<AssemblerName.JS_ACTOR>;
	protected _assemblerController: JsAssemblerController<JsAssemblerActor> | undefined;
	private _createAssemblerController;
	readonly compilationController: ActorCompilationController;
	compile(): void;
	cook(): void;
}
declare class DelayAnimParamsConfig extends NodeParamsConfig {
	/** @param delay */
	delay: ParamTemplate<ParamType.FLOAT>;
}
declare class DelayAnimNode extends TypedAnimNode<DelayAnimParamsConfig> {
	readonly paramsConfig: DelayAnimParamsConfig;
	static type(): string;
	initializeNode(): void;
	cook(input_contents: TimelineBuilder[]): void;
}
declare class DurationAnimParamsConfig extends NodeParamsConfig {
	/** @param duration */
	duration: ParamTemplate<ParamType.FLOAT>;
}
declare class DurationAnimNode extends TypedAnimNode<DurationAnimParamsConfig> {
	readonly paramsConfig: DurationAnimParamsConfig;
	static type(): string;
	initializeNode(): void;
	cook(input_contents: TimelineBuilder[]): void;
}
declare enum AnimNodeEasing {
	NONE = "none",
	POWER1 = "power1",
	POWER2 = "power2",
	POWER3 = "power3",
	POWER4 = "power4",
	BACK = "back",
	ELASTIC = "elastic",
	BOUNCE = "bounce",
	SLOW = "slow",
	STEPS = "steps",
	CIRC = "circ",
	EXPO = "expo",
	SINE = "sine"
}
declare enum InOutMode {
	IN = "in",
	OUT = "out",
	IN_OUT = "inOut"
}
declare enum AnimType {
	COPY = "copy",
	EASING = "easing",
	PLAY = "play",
	TARGET = "target"
}
declare class EasingAnimParamsConfig extends NodeParamsConfig {
	/** @param name of easing */
	name: ParamTemplate<ParamType.INTEGER>;
	/** @param defines if the easing is 'in', 'out' or 'in-out' */
	inOut: ParamTemplate<ParamType.INTEGER>;
}
declare class EasingAnimNode extends TypedAnimNode<EasingAnimParamsConfig> {
	readonly paramsConfig: EasingAnimParamsConfig;
	static type(): AnimType;
	initializeNode(): void;
	setEasing(mode: AnimNodeEasing): void;
	setInOut(inOut: InOutMode): void;
	static easingFullName(node: EasingAnimNode): string;
	cook(input_contents: TimelineBuilder[]): void;
}
declare class MergeAnimParamsConfig extends NodeParamsConfig {
	/** @param mode (at the same time or one after the other) */
	mode: ParamTemplate<ParamType.INTEGER>;
	/** @param offset if run one after the other */
	offset: ParamTemplate<ParamType.FLOAT>;
	/** @param override the position */
	overridePositions: ParamTemplate<ParamType.BOOLEAN>;
	/** @param number of inputs that this node can merge animations from */
	inputsCount: ParamTemplate<ParamType.INTEGER>;
}
declare class MergeAnimNode extends TypedAnimNode<MergeAnimParamsConfig> {
	readonly paramsConfig: MergeAnimParamsConfig;
	static type(): string;
	initializeNode(): void;
	cook(inputContents: TimelineBuilder[]): void;
	private _updateTimelineBuilder;
	private _setPlayAllTogether;
	private _setPlayOneAtATime;
	private _callbackUpdateInputsCount;
	static PARAM_CALLBACK_setInputsCount(node: MergeAnimNode): void;
}
declare class NullAnimParamsConfig extends NodeParamsConfig {
	/** @param play the animations */
	play: ParamTemplate<ParamType.BUTTON>;
	/** @param pause the animations */
	pause: ParamTemplate<ParamType.BUTTON>;
	/** @param sets if the animations created can be stopped when a new animation in generated on the same property */
	stoppable: ParamTemplate<ParamType.BOOLEAN>;
	/** @param toggle to see debug infos printed in the console */
	debug: ParamTemplate<ParamType.BOOLEAN>;
}
declare class NullAnimNode extends TypedAnimNode<NullAnimParamsConfig> {
	paramsConfig: NullAnimParamsConfig;
	static type(): string;
	initializeNode(): void;
	cook(inputContents: TimelineBuilder[]): void;
	private _timeline;
	timelineBuilder(): Promise<TimelineBuilder | undefined>;
	play(): Promise<void>;
	pause(): Promise<void>;
	static PARAM_CALLBACK_play(node: NullAnimNode): void;
	static PARAM_CALLBACK_pause(node: NullAnimNode): void;
}
declare class OperationAnimParamsConfig extends NodeParamsConfig {
	/** @param sets the operation (set, add or subtract) */
	operation: ParamTemplate<ParamType.INTEGER>;
}
declare class OperationAnimNode extends TypedAnimNode<OperationAnimParamsConfig> {
	paramsConfig: OperationAnimParamsConfig;
	static type(): string;
	initializeNode(): void;
	cook(input_contents: TimelineBuilder[]): void;
}
declare class PositionAnimParamsConfig extends NodeParamsConfig {
	/** @param sets the mode of the position. It can either be relative or absolute */
	mode: ParamTemplate<ParamType.INTEGER>;
	/** @param if sets to relative, sets if it is relative to the start or end */
	relativeTo: ParamTemplate<ParamType.INTEGER>;
	/** @param offset */
	offset: ParamTemplate<ParamType.FLOAT>;
}
declare class PositionAnimNode extends TypedAnimNode<PositionAnimParamsConfig> {
	paramsConfig: PositionAnimParamsConfig;
	static type(): string;
	initializeNode(): void;
	setMode(mode: AnimationPositionMode): void;
	setRelativeTo(relativeTo: AnimationPositionRelativeTo): void;
	cook(input_contents: TimelineBuilder[]): void;
}
declare class PropertyNameAnimParamsConfig extends NodeParamsConfig {
	/** @param name */
	name: ParamTemplate<ParamType.STRING>;
}
declare class PropertyNameAnimNode extends TypedAnimNode<PropertyNameAnimParamsConfig> {
	paramsConfig: PropertyNameAnimParamsConfig;
	static type(): string;
	initializeNode(): void;
	cook(inputContents: TimelineBuilder[]): void;
}
declare enum AnimPropertyValueNodeMode {
	CUSTOM = "custom",
	FROM_SCENE_GRAPH = "from scene graph",
	FROM_NODE = "from node"
}
declare class PropertyValueAnimParamsConfig extends NodeParamsConfig {
	/** @param mode */
	mode: ParamTemplate<ParamType.INTEGER>;
	/** @param if set to a Polygonjs node, this is the node path */
	nodePath: ParamTemplate<ParamType.NODE_PATH>;
	/** @param if set to a THREE object, this is a mask to find the objects */
	objectMask: ParamTemplate<ParamType.STRING>;
	/** @param print the object matching the objectMask, to help debugging */
	printResolve: ParamTemplate<ParamType.BUTTON>;
	overridePropertyName: ParamTemplate<ParamType.BOOLEAN>;
	propertyName: ParamTemplate<ParamType.STRING>;
	/** @param size of the parameter to animate */
	size: ParamTemplate<ParamType.INTEGER>;
	/** @param value for a float */
	value1: ParamTemplate<ParamType.FLOAT>;
	/** @param value for a vector2 */
	value2: ParamTemplate<ParamType.VECTOR2>;
	/** @param value for a vector3 */
	value3: ParamTemplate<ParamType.VECTOR3>;
	/** @param value for a vector3 as color */
	color: ParamTemplate<ParamType.COLOR>;
	/** @param value for a vector4 */
	value4: ParamTemplate<ParamType.VECTOR4>;
	/** @param when using vector3, use toggle on it should be a color */
	asColor: ParamTemplate<ParamType.BOOLEAN>;
}
declare class PropertyValueAnimNode extends TypedAnimNode<PropertyValueAnimParamsConfig> {
	paramsConfig: PropertyValueAnimParamsConfig;
	static type(): string;
	initializeNode(): void;
	cook(inputContents: TimelineBuilder[]): Promise<void>;
	setMode(targetType: AnimPropertyValueNodeMode): void;
	private _prepareTimelineBuilder;
	private _prepareTimebuilderCustom;
	private _prepareTimebuilderFromSceneGraph;
	private _prepareTimebuilderFromNode;
	static PARAM_CALLBACK_printResolve(node: PropertyValueAnimNode): void;
	private _foundObjectFromSceneGraph;
	private printResolve;
}
declare class RepeatAnimParamsConfig extends NodeParamsConfig {
	/** @param sets if it should repeat indefinitely */
	unlimited: ParamTemplate<ParamType.BOOLEAN>;
	/** @param number of times the animation should repeat */
	count: ParamTemplate<ParamType.INTEGER>;
	/** @param delay */
	delay: ParamTemplate<ParamType.FLOAT>;
	/** @param sets if the animation should go back and forth at each repeat */
	yoyo: ParamTemplate<ParamType.BOOLEAN>;
}
declare class RepeatAnimNode extends TypedAnimNode<RepeatAnimParamsConfig> {
	paramsConfig: RepeatAnimParamsConfig;
	static type(): string;
	initializeNode(): void;
	private _repeat_params;
	cook(input_contents: TimelineBuilder[]): void;
}
declare class PlayAnimParamsConfig extends NodeParamsConfig {
	/** @param play the animations */
	play: ParamTemplate<ParamType.BUTTON>;
	/** @param pause the animations */
	pause: ParamTemplate<ParamType.BUTTON>;
	/** @param reset the animations */
	reset: ParamTemplate<ParamType.BUTTON>;
	/** @param sets if the animations created can be stopped when a new animation in generated on the same property */
	stoppable: ParamTemplate<ParamType.BOOLEAN>;
	/** @param toggle to see debug infos printed in the console */
	debug: ParamTemplate<ParamType.BOOLEAN>;
	/** @param seek */
	seek: ParamTemplate<ParamType.FLOAT>;
}
declare class PlayAnimNode extends TypedAnimNode<PlayAnimParamsConfig> {
	paramsConfig: PlayAnimParamsConfig;
	gsap: typeof gsap | undefined;
	static type(): AnimType;
	initializeNode(): void;
	cook(inputContents: TimelineBuilder[]): void;
	private _timeline;
	timelineBuilder(inputIndex: number): Promise<TimelineBuilder | undefined>;
	private _playFromInput;
	play(): Promise<void>;
	reset(): Promise<void>;
	pause(): Promise<void>;
	seek(): Promise<void>;
	static PARAM_CALLBACK_play(node: PlayAnimNode): void;
	static PARAM_CALLBACK_pause(node: PlayAnimNode): void;
	static PARAM_CALLBACK_reset(node: PlayAnimNode): void;
	static PARAM_CALLBACK_seek(node: PlayAnimNode): void;
}
declare class ParamLessSubnetAnimParamsConfig extends NodeParamsConfig {
}
declare class BaseSubnetAnimNode<K extends NodeParamsConfig> extends TypedAnimNode<K> {
	initializeNode(): void;
	protected _childrenControllerContext: NodeContext;
	createNode<S extends keyof AnimNodeChildrenMap>(nodeClass: S, options?: NodeCreateOptions): AnimNodeChildrenMap[S];
	createNode<K extends valueof<AnimNodeChildrenMap>>(nodeClass: Constructor<K>, options?: NodeCreateOptions): K;
	children(): BaseAnimNodeType[];
	nodesByType<K extends keyof AnimNodeChildrenMap>(type: K): AnimNodeChildrenMap[K][];
	cook(inputContents: TimelineBuilder[]): Promise<void>;
}
declare class SubnetAnimNode extends BaseSubnetAnimNode<ParamLessSubnetAnimParamsConfig> {
	paramsConfig: ParamLessSubnetAnimParamsConfig;
	static type(): NetworkNodeType;
}
declare class SubnetInputAnimParamsConfig extends NodeParamsConfig {
	/** @param sets which input of the parent subnet node is used */
	input: ParamTemplate<ParamType.INTEGER>;
}
declare class SubnetInputAnimNode extends TypedAnimNode<SubnetInputAnimParamsConfig> {
	paramsConfig: SubnetInputAnimParamsConfig;
	static type(): NetworkChildNodeType;
	private _currentParentInputGraphNode;
	initializeNode(): void;
	cook(): Promise<void>;
	static PARAM_CALLBACK_reset(node: SubnetInputAnimNode): void;
	private _setParentInputDependency;
}
declare class AnimSubnetOutputSopParamsConfig extends NodeParamsConfig {
}
declare class SubnetOutputAnimNode extends TypedAnimNode<AnimSubnetOutputSopParamsConfig> {
	paramsConfig: AnimSubnetOutputSopParamsConfig;
	static type(): Readonly<NetworkChildNodeType.OUTPUT>;
	initializeNode(): void;
	dispose(): void;
	cook(inputContents: TimelineBuilder[]): void;
	private _setParentDirtyBound;
	private _setParentDirty;
}
declare class SwitchAnimParamsConfig extends NodeParamsConfig {
	/** @param input to process */
	input: ParamTemplate<ParamType.INTEGER>;
}
declare class SwitchAnimNode extends TypedAnimNode<SwitchAnimParamsConfig> {
	paramsConfig: SwitchAnimParamsConfig;
	static type(): string;
	initializeNode(): void;
	cook(input_contents: TimelineBuilder[]): void;
}
declare enum AnimTargetNodeTargetType {
	SCENE_GRAPH = "scene graph",
	NODE = "node"
}
declare class TargetAnimParamsConfig extends NodeParamsConfig {
	/** @param sets if the target is a Polygonjs node, or a THREE object */
	type: ParamTemplate<ParamType.INTEGER>;
	/** @param if set to a Polygonjs node, this is the node path */
	nodePath: ParamTemplate<ParamType.NODE_PATH>;
	/** @param if set to a THREE object, this is a mask to find the objects */
	objectMask: ParamTemplate<ParamType.STRING>;
	/** @param sets if the matrix should be updated as the animation progresses */
	updateMatrix: ParamTemplate<ParamType.BOOLEAN>;
	/** @param prints which objects are targeted by this node, for debugging */
	printResolve: ParamTemplate<ParamType.BUTTON>;
}
declare class TargetAnimNode extends TypedAnimNode<TargetAnimParamsConfig> {
	paramsConfig: TargetAnimParamsConfig;
	static type(): AnimType;
	initializeNode(): void;
	cook(inputCoreContents: TimelineBuilder[]): void;
	setTargetType(targetType: AnimTargetNodeTargetType): void;
	private _create_target;
	private _set_update_callback;
	static PARAM_CALLBACK_print_resolve(node: TargetAnimNode): void;
	private print_resolve;
}
declare class ParamLessNetworkAnimParamsConfig extends NodeParamsConfig {
}
declare class BaseNetworkAnimNode<K extends NodeParamsConfig> extends TypedNode<NodeContext.ANIM, K> {
	static context(): NodeContext;
	cook(): void;
}
declare class ParamLessBaseNetworkAnimNode extends BaseNetworkAnimNode<ParamLessNetworkAnimParamsConfig> {
}
declare class ActorsNetworkAnimNode extends ParamLessBaseNetworkAnimNode {
	static type(): NetworkNodeType;
	protected _childrenControllerContext: NodeContext;
	createNode<S extends keyof JsNodeChildrenMap>(node_class: S, options?: NodeCreateOptions): JsNodeChildrenMap[S];
	createNode<K extends valueof<JsNodeChildrenMap>>(node_class: Constructor<K>, options?: NodeCreateOptions): K;
	children(): BaseJsNodeType[];
	nodesByType<K extends keyof JsNodeChildrenMap>(type: K): JsNodeChildrenMap[K][];
	childrenAllowed(): boolean;
	sceneReadonly(): boolean;
	readonly persisted_config: ActorPersistedConfig;
	assemblerController(): JsAssemblerController<JsAssemblerActor> | undefined;
	usedAssembler(): Readonly<AssemblerName.JS_ACTOR>;
	protected _assemblerController: JsAssemblerController<JsAssemblerActor> | undefined;
	private _createAssemblerController;
	readonly compilationController: ActorCompilationController;
	compile(): void;
	cook(): void;
}
declare class AnimationsNetworkAnimNode extends ParamLessBaseNetworkAnimNode {
	static type(): NetworkNodeType;
	protected _childrenControllerContext: NodeContext;
	createNode<S extends keyof AnimNodeChildrenMap>(node_class: S, options?: NodeCreateOptions): AnimNodeChildrenMap[S];
	createNode<K extends valueof<AnimNodeChildrenMap>>(node_class: Constructor<K>, options?: NodeCreateOptions): K;
	children(): BaseAnimNodeType[];
	nodesByType<K extends keyof AnimNodeChildrenMap>(type: K): AnimNodeChildrenMap[K][];
}
declare enum AudioType {
	AM_SYNTH = "AMSynth",
	FM_SYNTH = "FMSynth",
	FILE = "file",
	MONO_SYNTH = "monoSynth",
	POLY_SYNTH = "polySynth",
	SAMPLER = "sampler",
	SWITCH = "switch",
	SYNTH = "synth"
}
declare class AMSynthAudioParamsConfig extends NodeParamsConfig {
}
declare class AMSynthAudioNode extends TypedAudioNode<AMSynthAudioParamsConfig> {
	paramsConfig: AMSynthAudioParamsConfig;
	static type(): AudioType;
	initializeNode(): void;
	cook(inputContents: AudioBuilder[]): void;
}
declare class AutoFilterAudioParamsConfig extends NodeParamsConfig {
	/** @param baseFrequency */
	baseFrequency: ParamTemplate<ParamType.FLOAT>;
	/** @param octaves */
	octaves: ParamTemplate<ParamType.FLOAT>;
}
declare class AutoFilterAudioNode extends TypedAudioNode<AutoFilterAudioParamsConfig> {
	paramsConfig: AutoFilterAudioParamsConfig;
	static type(): string;
	initializeNode(): void;
	cook(inputContents: AudioBuilder[]): void;
	private __effect__;
	private _effect;
	private _createEffect;
	static PARAM_CALLBACK_updateEffect(node: AutoFilterAudioNode): void;
	private _updateEffect;
}
declare class AutoWahAudioParamsConfig extends NodeParamsConfig {
	/** @param baseFrequency */
	baseFrequency: ParamTemplate<ParamType.FLOAT>;
	/** @param octaves */
	octaves: ParamTemplate<ParamType.FLOAT>;
	/** @param sensitivity */
	sensitivity: ParamTemplate<ParamType.FLOAT>;
	/** @param follower */
	follower: ParamTemplate<ParamType.FLOAT>;
}
declare class AutoWahAudioNode extends TypedAudioNode<AutoWahAudioParamsConfig> {
	paramsConfig: AutoWahAudioParamsConfig;
	static type(): string;
	initializeNode(): void;
	cook(inputContents: AudioBuilder[]): void;
	private __effect__;
	private _effect;
	private _createEffect;
	static PARAM_CALLBACK_updateEffect(node: AutoWahAudioNode): void;
	private _updateEffect;
}
declare class BitCrusherAudioParamsConfig extends NodeParamsConfig {
	/** @param bits */
	bits: ParamTemplate<ParamType.INTEGER>;
}
declare class BitCrusherAudioNode extends TypedAudioNode<BitCrusherAudioParamsConfig> {
	paramsConfig: BitCrusherAudioParamsConfig;
	static type(): string;
	initializeNode(): void;
	cook(inputContents: AudioBuilder[]): void;
}
declare class ChebyshevAudioParamsConfig extends NodeParamsConfig {
	/** @param order */
	order: ParamTemplate<ParamType.INTEGER>;
	/** @param oversample */
	oversample: ParamTemplate<ParamType.INTEGER>;
}
declare class ChebyshevAudioNode extends TypedAudioNode<ChebyshevAudioParamsConfig> {
	paramsConfig: ChebyshevAudioParamsConfig;
	static type(): string;
	initializeNode(): void;
	cook(inputContents: AudioBuilder[]): void;
	private __effect__;
	private _effect;
	private _createEffect;
	static PARAM_CALLBACK_updateEffect(node: ChebyshevAudioNode): void;
	private _updateEffect;
}
declare class ChorusAudioParamsConfig extends NodeParamsConfig {
	/** @param The frequency of the LFO. */
	frequency: ParamTemplate<ParamType.FLOAT>;
	/** The delay of the chorus effect in ms */
	delayTime: ParamTemplate<ParamType.FLOAT>;
	/** The depth of the chorus */
	depth: ParamTemplate<ParamType.FLOAT>;
}
declare class ChorusAudioNode extends TypedAudioNode<ChorusAudioParamsConfig> {
	paramsConfig: ChorusAudioParamsConfig;
	static type(): string;
	initializeNode(): void;
	cook(inputContents: AudioBuilder[]): void;
	private __effect__;
	private _effect;
	private _createEffect;
	static PARAM_CALLBACK_updateEffect(node: ChorusAudioNode): void;
	private _updateEffect;
}
declare class DistortionAudioParamsConfig extends NodeParamsConfig {
	/** @param distortion */
	distortion: ParamTemplate<ParamType.FLOAT>;
	/** @param oversample */
	oversample: ParamTemplate<ParamType.INTEGER>;
}
declare class DistortionAudioNode extends TypedAudioNode<DistortionAudioParamsConfig> {
	paramsConfig: DistortionAudioParamsConfig;
	static type(): string;
	initializeNode(): void;
	cook(inputContents: AudioBuilder[]): void;
	private __effect__;
	private _effect;
	private _createEffect;
	static PARAM_CALLBACK_updateEffect(node: DistortionAudioNode): void;
	private _updateEffect;
}
declare class EnvelopeAudioParamsConfig extends NodeParamsConfig {
	/** @param The amount of time it takes for the envelope to go from 0 to it's maximum value. */
	attack: ParamTemplate<ParamType.FLOAT>;
	/** The period of time after the attack that it takes for the envelope to fall to the sustain value. */
	decay: ParamTemplate<ParamType.FLOAT>;
	/** The percent of the maximum value that the envelope rests at until the release is triggered. */
	sustain: ParamTemplate<ParamType.FLOAT>;
	/** The amount of time after the release is triggered it takes to reach 0. */
	release: ParamTemplate<ParamType.FLOAT>;
}
declare class EnvelopeAudioNode extends TypedAudioNode<EnvelopeAudioParamsConfig> {
	paramsConfig: EnvelopeAudioParamsConfig;
	static type(): string;
	initializeNode(): void;
	cook(inputContents: AudioBuilder[]): void;
}
declare abstract class BaseAnalyserAudioNode<K extends NodeParamsConfig> extends TypedAudioNode<K> {
	abstract getAnalyserValue(): Float32Array | number[] | undefined;
}
declare class FFTAudioParamsConfig extends NodeParamsConfig {
	/** @param array size will be 2**sizeExponent */
	sizeExponent: ParamTemplate<ParamType.INTEGER>;
	/** @param array size */
	arraySize: ParamTemplate<ParamType.INTEGER>;
	/** @param a value from between 0 and 1 where 0 represents no time averaging with the last analysis frame */
	smoothing: ParamTemplate<ParamType.FLOAT>;
	/** @param normalizes the output between 0 and 1. The value will be in decibel otherwise. */
	normalRange: ParamTemplate<ParamType.BOOLEAN>;
	/** @param groups the FFT frequency bands into octave bands */
	asOctaves: ParamTemplate<ParamType.BOOLEAN>;
	octaveDivisions: ParamTemplate<ParamType.INTEGER>;
	/** @param display range param */
	updateRangeParam: ParamTemplate<ParamType.BOOLEAN>;
	/** @param range value */
	range: ParamTemplate<ParamType.VECTOR2>;
	/** @param accumulated range */
	maxRange: ParamTemplate<ParamType.VECTOR2>;
	/** @param resetMaxRange */
	resetMaxRange: ParamTemplate<ParamType.BUTTON>;
}
declare class FFTAudioNode extends BaseAnalyserAudioNode<FFTAudioParamsConfig> {
	paramsConfig: FFTAudioParamsConfig;
	static type(): AudioNodeAnalyserType;
	initializeNode(): void;
	cook(inputContents: AudioBuilder[]): void;
	getAnalyserValue(): Float32Array | undefined;
	private __octaveValues;
	private _octaveDivisions;
	private _octaveValues;
	private __effect__;
	private _effect;
	private _createEffect;
	private _resetEffect;
	static PARAM_CALLBACK_updateEffect(node: FFTAudioNode): void;
	private _updateEffect;
	private _FFTSize;
	static PARAM_CALLBACK_updateUpdateRangeParam(node: FFTAudioNode): void;
	static PARAM_CALLBACK_resetMaxRange(node: FFTAudioNode): void;
	private _updateRangeParam;
	private _updateOnTickHook;
	private _registerOnTickHook;
	private _unRegisterOnTickHook;
	private _tickCallbackName;
}
declare class FMSynthAudioParamsConfig extends NodeParamsConfig {
}
declare class FMSynthAudioNode extends TypedAudioNode<FMSynthAudioParamsConfig> {
	paramsConfig: FMSynthAudioParamsConfig;
	static type(): AudioType;
	initializeNode(): void;
	cook(inputContents: AudioBuilder[]): void;
}
declare class FeedbackDelayAudioParamsConfig extends NodeParamsConfig {
	/** @param delayTime */
	delayTime: ParamTemplate<ParamType.FLOAT>;
	/** @param maxDelay */
	maxDelay: ParamTemplate<ParamType.FLOAT>;
	/** @param feedback */
	feedback: ParamTemplate<ParamType.FLOAT>;
}
declare class FeedbackDelayAudioNode extends TypedAudioNode<FeedbackDelayAudioParamsConfig> {
	paramsConfig: FeedbackDelayAudioParamsConfig;
	static type(): string;
	initializeNode(): void;
	cook(inputContents: AudioBuilder[]): void;
}
declare class FetchAudioParamsConfig extends NodeParamsConfig {
	/** @param which node to import */
	audioNode: ParamTemplate<ParamType.NODE_PATH>;
}
declare class FetchAudioNode extends TypedAudioNode<FetchAudioParamsConfig> {
	paramsConfig: FetchAudioParamsConfig;
	static type(): string;
	initializeNode(): void;
	cook(inputContents: AudioBuilder[]): Promise<void>;
}
type OnBeforePlayCallback = (offset: number) => void;
type OnPlaySuccessCallback = () => void;
type OnPlayErrorCallback = (err: unknown) => void;
type OnStopCallback = () => void;
declare class FileAudioParamsConfig extends NodeParamsConfig {
	/** @param url to fetch the audio file from */
	url: ParamTemplate<ParamType.STRING>;
	/** @param auto start */
	autostart: ParamTemplate<ParamType.BOOLEAN>;
	/** @param duration */
	duration: ParamTemplate<ParamType.FLOAT>;
	/** @param display currentTime param */
	updateCurrentTimeParam: ParamTemplate<ParamType.BOOLEAN>;
	/** @param currentTime */
	currentTime: ParamTemplate<ParamType.FLOAT>;
	/** @param loop */
	loop: ParamTemplate<ParamType.BOOLEAN>;
	/** @param useLoopRange */
	/** @param loop Range */
	/** @param play the audio */
	play: ParamTemplate<ParamType.BUTTON>;
	/** @param stop the audio */
	pause: ParamTemplate<ParamType.BUTTON>;
	/** @param restart the audio */
	restart: ParamTemplate<ParamType.BUTTON>;
	/** @param seek 10 seconds back */
	seekM10: ParamTemplate<ParamType.BUTTON>;
	/** @param seek 5 seconds back */
	seekM5: ParamTemplate<ParamType.BUTTON>;
	/** @param seek 5 seconds forward */
	seekP5: ParamTemplate<ParamType.BUTTON>;
	/** @param seek 10 seconds forward */
	seekP10: ParamTemplate<ParamType.BUTTON>;
}
declare class FileAudioNode extends TypedAudioNode<FileAudioParamsConfig> {
	paramsConfig: FileAudioParamsConfig;
	static type(): AudioType;
	initializeNode(): void;
	dispose(): void;
	private _startedAt;
	private _stoppedAt;
	cook(inputContents: AudioBuilder[]): Promise<void>;
	private _player;
	private _loadUrl;
	play(): Promise<void>;
	pause(): Promise<void>;
	private _reset;
	restart(): Promise<void>;
	seekOffset(offset: number): void;
	static PARAM_CALLBACK_updateUpdateCurrentTimeParam(node: FileAudioNode): void;
	private _updateCurrentTimeParam;
	private _currentTime;
	static PARAM_CALLBACK_updateLoop(node: FileAudioNode): void;
	private _updateLoop;
	private _updateOnTickHook;
	private _registerOnTickHook;
	private _unRegisterOnTickHook;
	private _tickCallbackName;
	static PARAM_CALLBACK_seekOffset(node: FileAudioNode, offset: number): void;
	static PARAM_CALLBACK_play(node: FileAudioNode): void;
	static PARAM_CALLBACK_pause(node: FileAudioNode): void;
	static PARAM_CALLBACK_restart(node: FileAudioNode): void;
	private _playerCallbacks;
	onBeforePlay(callback: OnBeforePlayCallback): void;
	private _runOnBeforePlay;
	onPlaySuccess(callback: OnPlaySuccessCallback): void;
	private _runOnPlaySuccess;
	onPlayError(callback: OnPlayErrorCallback): void;
	private _runOnPlayError;
	onStop(callback: OnStopCallback): void;
	removeOnStop(callback: OnStopCallback): void;
	private _runOnStop;
	private _on;
	private _removeCallback;
}
declare class FrequencyShifterAudioParamsConfig extends NodeParamsConfig {
	/** @param frequency */
	frequency: ParamTemplate<ParamType.FLOAT>;
}
declare class FrequencyShifterAudioNode extends TypedAudioNode<FrequencyShifterAudioParamsConfig> {
	paramsConfig: FrequencyShifterAudioParamsConfig;
	static type(): string;
	initializeNode(): void;
	cook(inputContents: AudioBuilder[]): void;
}
declare class MeterAudioParamsConfig extends NodeParamsConfig {
	/** @param a value from between 0 and 1 where 0 represents no time averaging with the last analysis frame */
	smoothing: ParamTemplate<ParamType.FLOAT>;
	/** @param normalizes the output between 0 and 1. The value will be in decibel otherwise. */
	normalRange: ParamTemplate<ParamType.BOOLEAN>;
	/** @param display meter param */
	updateValueParam: ParamTemplate<ParamType.BOOLEAN>;
	/** @param meter value */
	value: ParamTemplate<ParamType.FLOAT>;
	/** @param display meter param */
	updateRangeParam: ParamTemplate<ParamType.BOOLEAN>;
	/** @param accumulated range */
	maxRange: ParamTemplate<ParamType.VECTOR2>;
	/** @param resetMaxRange */
	resetMaxRange: ParamTemplate<ParamType.BUTTON>;
}
declare class MeterAudioNode extends BaseAnalyserAudioNode<MeterAudioParamsConfig> {
	paramsConfig: MeterAudioParamsConfig;
	static type(): AudioNodeAnalyserType;
	initializeNode(): void;
	cook(inputContents: AudioBuilder[]): void;
	private _arrayValue;
	getAnalyserValue(): Float32Array | number[] | undefined;
	private __effect__;
	private _effect;
	private _createEffect;
	private _resetEffect;
	static PARAM_CALLBACK_updateEffect(node: MeterAudioNode): void;
	private _updateEffect;
	static PARAM_CALLBACK_updateUpdateMeterParam(node: MeterAudioNode): void;
	static PARAM_CALLBACK_resetMaxRange(node: MeterAudioNode): void;
	private _updateMeterParam;
	private _updateOnTickHook;
	private _registerOnTickHook;
	private _unRegisterOnTickHook;
	private _tickCallbackName;
}
declare class MonoSynthAudioParamsConfig extends NodeParamsConfig {
}
declare class MonoSynthAudioNode extends TypedAudioNode<MonoSynthAudioParamsConfig> {
	paramsConfig: MonoSynthAudioParamsConfig;
	static type(): AudioType;
	initializeNode(): void;
	cook(inputContents: AudioBuilder[]): void;
}
declare class NoiseAudioParamsConfig extends NodeParamsConfig {
	/** @param Noise type */
	type: ParamTemplate<ParamType.INTEGER>;
	/** playbackRate */
	playbackRate: ParamTemplate<ParamType.FLOAT>;
	/** fadeIn */
	fadeIn: ParamTemplate<ParamType.FLOAT>;
	/** fadeOut */
	fadeOut: ParamTemplate<ParamType.FLOAT>;
	/** play */
	play: ParamTemplate<ParamType.BOOLEAN>;
}
declare class NoiseAudioNode extends TypedAudioNode<NoiseAudioParamsConfig> {
	paramsConfig: NoiseAudioParamsConfig;
	static type(): string;
	initializeNode(): void;
	cook(inputContents: AudioBuilder[]): void;
	private __noise__;
	private _noise;
	private _createEffect;
	static PARAM_CALLBACK_updateNoise(node: NoiseAudioNode): void;
	private _updateNoise;
}
declare class NullAudioParamsConfig extends NodeParamsConfig {
}
declare class NullAudioNode extends TypedAudioNode<NullAudioParamsConfig> {
	paramsConfig: NullAudioParamsConfig;
	static type(): string;
	initializeNode(): void;
	cook(inputContents: AudioBuilder[]): void;
}
declare class PhaserAudioParamsConfig extends NodeParamsConfig {
	/** @param frequency */
	frequency: ParamTemplate<ParamType.FLOAT>;
	/** @param baseFrequency */
	baseFrequency: ParamTemplate<ParamType.FLOAT>;
	/** @param octaves */
	octaves: ParamTemplate<ParamType.FLOAT>;
	/** @param sensitivity */
	stages: ParamTemplate<ParamType.FLOAT>;
	/** @param Q */
	Q: ParamTemplate<ParamType.FLOAT>;
}
declare class PhaserAudioNode extends TypedAudioNode<PhaserAudioParamsConfig> {
	paramsConfig: PhaserAudioParamsConfig;
	static type(): string;
	initializeNode(): void;
	cook(inputContents: AudioBuilder[]): void;
	private __effect__;
	private _effect;
	private _createEffect;
	private _resetEffect;
	static PARAM_CALLBACK_updateEffect(node: PhaserAudioNode): void;
	private _updateEffect;
}
declare class PingPongDelayAudioParamsConfig extends NodeParamsConfig {
	/** @param delayTime */
	delayTime: ParamTemplate<ParamType.FLOAT>;
	/** @param maxDelay */
	maxDelay: ParamTemplate<ParamType.FLOAT>;
}
declare class PingPongDelayAudioNode extends TypedAudioNode<PingPongDelayAudioParamsConfig> {
	paramsConfig: PingPongDelayAudioParamsConfig;
	static type(): string;
	initializeNode(): void;
	cook(inputContents: AudioBuilder[]): void;
	private _createEffect;
}
declare class PitchShiftAudioParamsConfig extends NodeParamsConfig {
	/** @param The interval to transpose the incoming signal by */
	pitch: ParamTemplate<ParamType.FLOAT>;
}
declare class PitchShiftAudioNode extends TypedAudioNode<PitchShiftAudioParamsConfig> {
	paramsConfig: PitchShiftAudioParamsConfig;
	static type(): string;
	initializeNode(): void;
	cook(inputContents: AudioBuilder[]): void;
	private __effect__;
	private _effect;
	private _createEffect;
	static PARAM_CALLBACK_updateEffect(node: PitchShiftAudioNode): void;
	private _updateEffect;
}
declare class PlayInstrumentAudioParamsConfig extends NodeParamsConfig {
	/** @param note */
	note: ParamTemplate<ParamType.STRING>;
	/** @param duration */
	duration: ParamTemplate<ParamType.FLOAT>;
	/** @param play the audio */
	/** @param stop the audio */
	showNotes: ParamTemplate<ParamType.BOOLEAN>;
	showKeys: ParamTemplate<ParamType.BOOLEAN>;
	startOctave: ParamTemplate<ParamType.INTEGER>;
	endOctave: ParamTemplate<ParamType.INTEGER>;
	updateNoteFromInstrument: ParamTemplate<ParamType.BOOLEAN>;
}
declare class PlayInstrumentAudioNode extends TypedAudioNode<PlayInstrumentAudioParamsConfig> {
	paramsConfig: PlayInstrumentAudioParamsConfig;
	static type(): string;
	initializeNode(): void;
	cook(inputContents: AudioBuilder[]): void;
	play(): Promise<void>;
	private _getInstrument;
}
declare class PolySynthAudioParamsConfig extends NodeParamsConfig {
}
declare class PolySynthAudioNode extends TypedAudioNode<PolySynthAudioParamsConfig> {
	paramsConfig: PolySynthAudioParamsConfig;
	static type(): AudioType;
	initializeNode(): void;
	cook(inputContents: AudioBuilder[]): void;
}
declare class ReverbAudioParamsConfig extends NodeParamsConfig {
	/** @param The duration of the reverb. */
	decay: ParamTemplate<ParamType.FLOAT>;
	/** The amount of time before the reverb is fully ramped in */
	preDelay: ParamTemplate<ParamType.FLOAT>;
}
declare class ReverbAudioNode extends TypedAudioNode<ReverbAudioParamsConfig> {
	paramsConfig: ReverbAudioParamsConfig;
	static type(): string;
	initializeNode(): void;
	cook(inputContents: AudioBuilder[]): void;
	private __effect__;
	private _effect;
	private _createEffect;
	static PARAM_CALLBACK_updateEffect(node: ReverbAudioNode): void;
	private _updateEffect;
}
declare class SamplerAudioParamsConfig extends NodeParamsConfig {
	/** @param map of notes to load */
	urlsMap: ParamTemplate<ParamType.STRING>;
	/** @param base url */
	baseUrl: ParamTemplate<ParamType.STRING>;
	/** @param extension */
	extension: ParamTemplate<ParamType.STRING>;
}
declare class SamplerAudioNode extends TypedAudioNode<SamplerAudioParamsConfig> {
	paramsConfig: SamplerAudioParamsConfig;
	static type(): AudioType;
	initializeNode(): void;
	dispose(): void;
	cook(inputContents: AudioBuilder[]): Promise<void>;
}
declare class StereoWidenerAudioParamsConfig extends NodeParamsConfig {
	/** @param width */
	width: ParamTemplate<ParamType.FLOAT>;
}
declare class StereoWidenerAudioNode extends TypedAudioNode<StereoWidenerAudioParamsConfig> {
	paramsConfig: StereoWidenerAudioParamsConfig;
	static type(): string;
	initializeNode(): void;
	cook(inputContents: AudioBuilder[]): void;
}
declare class SwitchAudioParamsConfig extends NodeParamsConfig {
	/** @param sets which input is used */
	input: ParamTemplate<ParamType.INTEGER>;
	/** @param number of inputs that this node can merge geometries from */
	inputsCount: ParamTemplate<ParamType.INTEGER>;
}
declare class SwitchAudioNode extends TypedAudioNode<SwitchAudioParamsConfig> {
	paramsConfig: SwitchAudioParamsConfig;
	static type(): AudioType;
	initializeNode(): void;
	cook(inputContents: AudioBuilder[]): Promise<void>;
	private _callbackUpdateInputsEvaluation;
	static PARAM_CALLBACK_setInputsEvaluation(node: SwitchAudioNode): void;
	private _callbackUpdateInputsCount;
	static PARAM_CALLBACK_setInputsCount(node: SwitchAudioNode): void;
}
declare class SynthAudioParamsConfig extends NodeParamsConfig {
	/** @param The glide time between notes. */
	portamento: ParamTemplate<ParamType.FLOAT>;
}
declare class SynthAudioNode extends TypedAudioNode<SynthAudioParamsConfig> {
	paramsConfig: SynthAudioParamsConfig;
	static type(): AudioType;
	initializeNode(): void;
	cook(inputContents: AudioBuilder[]): void;
}
declare class TremoloAudioParamsConfig extends NodeParamsConfig {
	/** @param frequency */
	frequency: ParamTemplate<ParamType.FLOAT>;
	/** @param depth */
	depth: ParamTemplate<ParamType.FLOAT>;
	/** @param spread (degrees) */
	spread: ParamTemplate<ParamType.FLOAT>;
}
declare class TremoloAudioNode extends TypedAudioNode<TremoloAudioParamsConfig> {
	paramsConfig: TremoloAudioParamsConfig;
	static type(): string;
	initializeNode(): void;
	cook(inputContents: AudioBuilder[]): void;
	private _createEffect;
}
declare class UserMediaAudioParamsConfig extends NodeParamsConfig {
	autostart: ParamTemplate<ParamType.BOOLEAN>;
	/** @param play the audio */
	open: ParamTemplate<ParamType.BUTTON>;
	/** @param stop the audio */
	close: ParamTemplate<ParamType.BUTTON>;
}
declare class UserMediaAudioNode extends TypedAudioNode<UserMediaAudioParamsConfig> {
	paramsConfig: UserMediaAudioParamsConfig;
	static type(): string;
	initializeNode(): void;
	cook(inputContents: AudioBuilder[]): Promise<void>;
	private __userMedia__;
	private _userMedia;
	private _createEffect;
	open(): Promise<UserMedia>;
	close(): void;
	static PARAM_CALLBACK_open(node: UserMediaAudioNode): void;
	static PARAM_CALLBACK_close(node: UserMediaAudioNode): void;
}
declare class VibratoAudioParamsConfig extends NodeParamsConfig {
	/** @param maxDelay */
	maxDelay: ParamTemplate<ParamType.FLOAT>;
	/** @param frequency */
	frequency: ParamTemplate<ParamType.FLOAT>;
	/** @param depth */
	depth: ParamTemplate<ParamType.FLOAT>;
}
declare class VibratoAudioNode extends TypedAudioNode<VibratoAudioParamsConfig> {
	paramsConfig: VibratoAudioParamsConfig;
	static type(): string;
	initializeNode(): void;
	cook(inputContents: AudioBuilder[]): void;
	private _createEffect;
}
declare class VolumeAudioParamsConfig extends NodeParamsConfig {
	/** @param volume */
	volume: ParamTemplate<ParamType.FLOAT>;
}
declare class VolumeAudioNode extends TypedAudioNode<VolumeAudioParamsConfig> {
	paramsConfig: VolumeAudioParamsConfig;
	static type(): string;
	initializeNode(): void;
	cook(inputContents: AudioBuilder[]): void;
	private __effect__;
	private _effect;
	private _createEffect;
	static PARAM_CALLBACK_updateEffect(node: VolumeAudioNode): void;
	private _updateEffect;
}
declare class WaveformAudioParamsConfig extends NodeParamsConfig {
	/** @param array size will be 2**sizeExponent */
	sizeExponent: ParamTemplate<ParamType.INTEGER>;
	/** @param array size */
	arraySize: ParamTemplate<ParamType.INTEGER>;
	/** @param a value from between 0 and 1 where 0 represents no time averaging with the last analysis frame */
	smoothing: ParamTemplate<ParamType.FLOAT>;
	/** @param normalizes the output between 0 and 1. The value will be in decibel otherwise. */
	normalRange: ParamTemplate<ParamType.BOOLEAN>;
	/** @param display range param */
	updateRangeParam: ParamTemplate<ParamType.BOOLEAN>;
	/** @param range value */
	range: ParamTemplate<ParamType.VECTOR2>;
	/** @param accumulated range */
	maxRange: ParamTemplate<ParamType.VECTOR2>;
	/** @param resetMaxRange */
	resetMaxRange: ParamTemplate<ParamType.BUTTON>;
}
declare class WaveformAudioNode extends BaseAnalyserAudioNode<WaveformAudioParamsConfig> {
	paramsConfig: WaveformAudioParamsConfig;
	static type(): AudioNodeAnalyserType;
	initializeNode(): void;
	cook(inputContents: AudioBuilder[]): void;
	private _previousValue;
	getAnalyserValue(): Float32Array | undefined;
	private _getWaveFormValue;
	private _blendValue;
	private __effect__;
	private _effect;
	private _createEffect;
	private _resetEffect;
	private _effectSize;
	static PARAM_CALLBACK_updateUpdateRangeParam(node: WaveformAudioNode): void;
	static PARAM_CALLBACK_resetMaxRange(node: WaveformAudioNode): void;
	private _updateRangeParam;
	private _updateOnTickHook;
	private _registerOnTickHook;
	private _unRegisterOnTickHook;
	private _tickCallbackName;
}
declare class ParamLessNetworkAudioParamsConfig extends NodeParamsConfig {
}
declare class BaseNetworkAudioNode<K extends NodeParamsConfig> extends TypedNode<NodeContext.AUDIO, K> {
	static context(): NodeContext;
	cook(): void;
}
declare class ParamLessBaseNetworkAudioNode extends BaseNetworkAudioNode<ParamLessNetworkAudioParamsConfig> {
}
declare class ActorsNetworkAudioNode extends ParamLessBaseNetworkAudioNode {
	static type(): NetworkNodeType;
	protected _childrenControllerContext: NodeContext;
	createNode<S extends keyof JsNodeChildrenMap>(node_class: S, options?: NodeCreateOptions): JsNodeChildrenMap[S];
	createNode<K extends valueof<JsNodeChildrenMap>>(node_class: Constructor<K>, options?: NodeCreateOptions): K;
	children(): BaseJsNodeType[];
	nodesByType<K extends keyof JsNodeChildrenMap>(type: K): JsNodeChildrenMap[K][];
	childrenAllowed(): boolean;
	sceneReadonly(): boolean;
	readonly persisted_config: ActorPersistedConfig;
	assemblerController(): JsAssemblerController<JsAssemblerActor> | undefined;
	usedAssembler(): Readonly<AssemblerName.JS_ACTOR>;
	protected _assemblerController: JsAssemblerController<JsAssemblerActor> | undefined;
	private _createAssemblerController;
	readonly compilationController: ActorCompilationController;
	compile(): void;
	cook(): void;
}
declare class AnimationsNetworkAudioNode extends ParamLessBaseNetworkAudioNode {
	static type(): NetworkNodeType;
	protected _childrenControllerContext: NodeContext;
	createNode<S extends keyof AnimNodeChildrenMap>(node_class: S, options?: NodeCreateOptions): AnimNodeChildrenMap[S];
	createNode<K extends valueof<AnimNodeChildrenMap>>(node_class: Constructor<K>, options?: NodeCreateOptions): K;
	children(): BaseAnimNodeType[];
	nodesByType<K extends keyof AnimNodeChildrenMap>(type: K): AnimNodeChildrenMap[K][];
}
declare class AudioNetworkAudioNode extends ParamLessBaseNetworkAudioNode {
	static type(): NetworkNodeType;
	protected _childrenControllerContext: NodeContext;
	createNode<S extends keyof AudioNodeChildrenMap>(node_class: S, options?: NodeCreateOptions): AudioNodeChildrenMap[S];
	createNode<K extends valueof<AudioNodeChildrenMap>>(node_class: Constructor<K>, options?: NodeCreateOptions): K;
	children(): BaseAudioNodeType[];
	nodesByType<K extends keyof AudioNodeChildrenMap>(type: K): AudioNodeChildrenMap[K][];
}
declare class CopNetworkAudioNode extends ParamLessBaseNetworkAudioNode {
	static type(): NetworkNodeType;
	protected _childrenControllerContext: NodeContext;
	createNode<S extends keyof AudioNodeChildrenMap>(node_class: S, options?: NodeCreateOptions): AudioNodeChildrenMap[S];
	createNode<K extends valueof<AudioNodeChildrenMap>>(node_class: Constructor<K>, options?: NodeCreateOptions): K;
	children(): BaseAudioNodeType[];
	nodesByType<K extends keyof AudioNodeChildrenMap>(type: K): AudioNodeChildrenMap[K][];
}
declare class EventsNetworkAudioNode extends ParamLessBaseNetworkAudioNode {
	static type(): NetworkNodeType;
	protected _childrenControllerContext: NodeContext;
	createNode<S extends keyof EventNodeChildrenMap>(node_class: S, options?: NodeCreateOptions): EventNodeChildrenMap[S];
	createNode<K extends valueof<EventNodeChildrenMap>>(node_class: Constructor<K>, options?: NodeCreateOptions): K;
	children(): BaseEventNodeType[];
	nodesByType<K extends keyof EventNodeChildrenMap>(type: K): EventNodeChildrenMap[K][];
}
type MaterialTexturesRecord = Map<string, Texture | null>;
type SetParamsTextureNodesRecord = Map<string, BaseCopNodeType>;
declare abstract class BaseController {
	protected node: BaseNodeType;
	constructor(node: BaseNodeType);
	initializeNode(): void;
	abstract updateMaterial(material: Material): void | Promise<void>;
	setParamsFromMaterial(material: Material, record: SetParamsTextureNodesRecord): void;
	getTextures(material: Material, record: MaterialTexturesRecord): void;
}
declare abstract class TypedMatNode<M extends Material, K extends NodeParamsConfig> extends TypedNode<NodeContext.MAT, K> {
	static context(): NodeContext;
	initializeBaseNode(): void;
	protected _cookWhenDirtyBound: () => Promise<void>;
	protected _cookMainWithoutInputsWhenDirty(): Promise<void>;
	abstract material(): Promise<M | undefined>;
	setMaterial(material: M): void;
}
declare abstract class PrimitiveMatNode<M extends Material, K extends NodeParamsConfig> extends TypedMatNode<M, K> {
	protected _material: M | undefined;
	abstract createMaterial(): M;
	__materialSync__(): M;
	material(): Promise<M>;
	initializeBaseNode(): void;
	private set_material_name;
	setMaterial(material: M): void;
	getTextures(material: M, record: MaterialTexturesRecord): void;
	setParamsFromMaterial(material: M, record: SetParamsTextureNodesRecord): void;
	protected controllersList: Array<BaseController>;
	protected controllersPromises(material: M): Array<void | Promise<void>>;
	initializeNode(): void;
}
declare class UpdateMatNode<M extends Material, K extends NodeParamsConfig> extends TypedMatNode<M, K> {
	readonly flags: FlagsControllerB;
	protected _cookWhenDirtyBound: () => Promise<void>;
	protected _cookMainWithoutInputsWhenDirty(): Promise<void>;
	material(): Promise<M | undefined>;
	initializeBaseNode(): void;
}
type BaseMatNodeType = TypedMatNode<Material, any>;
declare enum AdditionalType {
	COLOR = "color",
	TEXTURE = "texture"
}
declare class BuilderUniformUpdateMatParamsConfig extends NodeParamsConfig {
	/** @param name of the uniform */
	uniformName: ParamTemplate<ParamType.STRING>;
	/** @param type of the uniform */
	type: ParamTemplate<ParamType.INTEGER>;
	bool: ParamTemplate<ParamType.BOOLEAN>;
	int: ParamTemplate<ParamType.INTEGER>;
	float: ParamTemplate<ParamType.FLOAT>;
	vec2: ParamTemplate<ParamType.VECTOR2>;
	vec3: ParamTemplate<ParamType.VECTOR3>;
	color: ParamTemplate<ParamType.COLOR>;
	vec4: ParamTemplate<ParamType.VECTOR4>;
	texture: ParamTemplate<ParamType.NODE_PATH>;
}
declare class BuilderUniformUpdateMatNode extends UpdateMatNode<ShaderMaterial, BuilderUniformUpdateMatParamsConfig> {
	paramsConfig: BuilderUniformUpdateMatParamsConfig;
	static type(): string;
	private _paramConfig;
	cook(inputMaterials: Material[]): Promise<void>;
	private _handleCustomMaterial;
	setType(type: GlConnectionPointType | AdditionalType): void;
	static PARAM_CALLBACK_applyCurrentParam(node: BuilderUniformUpdateMatNode): void;
	private _applyCurrentParam;
	private _updateTexture;
}
declare class ClippingPlaneMatParamsConfig extends NodeParamsConfig {
	/** @param plane normal */
	normal: ParamTemplate<ParamType.VECTOR3>;
	/** @param plane constant */
	constant: ParamTemplate<ParamType.FLOAT>;
}
declare class ClippingPlaneMatNode extends UpdateMatNode<ShaderMaterial, ClippingPlaneMatParamsConfig> {
	paramsConfig: ClippingPlaneMatParamsConfig;
	static type(): string;
	private _plane;
	cook(inputMaterials: Material[]): Promise<void>;
}
declare class ClipPropertiesMatParamsConfig extends NodeParamsConfig {
	/** @param clipIntersection */
	clipIntersection: ParamTemplate<ParamType.BOOLEAN>;
	/** @param clipShadows */
	clipShadows: ParamTemplate<ParamType.BOOLEAN>;
}
declare class ClipPropertiesMatNode extends UpdateMatNode<ShaderMaterial, ClipPropertiesMatParamsConfig> {
	paramsConfig: ClipPropertiesMatParamsConfig;
	static type(): string;
	cook(inputMaterials: Material[]): Promise<void>;
}
declare const AdvancedCommonParamsConfig_base: {
	new (...args: any[]): {
		/** @param defines if the material is double sided or not */
		doubleSided: ParamTemplate<ParamType.BOOLEAN>;
		/** @param if the material is not double sided, it can be front sided, or back sided */
		front: ParamTemplate<ParamType.BOOLEAN>;
		/** @param override the default shadowSide behavior */
		overrideShadowSide: ParamTemplate<ParamType.BOOLEAN>;
		/** @param defines which side(s) are used when rendering shadows */
		shadowDoubleSided: ParamTemplate<ParamType.BOOLEAN>;
		/** @param if the material is not double sided, it can be front sided, or back sided, when computing shadows */
		shadowFront: ParamTemplate<ParamType.BOOLEAN>;
		/** @param defines if the objects using this material will be rendered in the color buffer. Setting it to false can have those objects occlude the ones behind */
		colorWrite: ParamTemplate<ParamType.BOOLEAN>;
		/** @param defines if the objects using this material will be rendered in the depth buffer. This can often help transparent objects */
		depthWrite: ParamTemplate<ParamType.BOOLEAN>;
		/** @param toggle depth test */
		depthTest: ParamTemplate<ParamType.BOOLEAN>;
		/** @param premultipliedAlpha */
		premultipliedAlpha: ParamTemplate<ParamType.BOOLEAN>;
		/** @param blending */
		blending: ParamTemplate<ParamType.INTEGER>;
		/** @param dithering, which can be useful when using postprocessing and banding appears on some objects */
		dithering: ParamTemplate<ParamType.BOOLEAN>;
		/** @param activate polygon offset */
		polygonOffset: ParamTemplate<ParamType.BOOLEAN>;
		polygonOffsetFactor: ParamTemplate<ParamType.INTEGER>;
		polygonOffsetUnits: ParamTemplate<ParamType.INTEGER>;
	};
} & typeof NodeParamsConfig;
declare class AdvancedCommonParamsConfig extends AdvancedCommonParamsConfig_base {
}
interface AdvancedCommonControllers {
	advancedCommon: AdvancedCommonController;
}
declare abstract class AdvancedCommonMapMatNode extends TypedMatNode<Material, AdvancedCommonParamsConfig> {
	controllers: AdvancedCommonControllers;
	material(): Promise<Material | undefined>;
}
declare class AdvancedCommonController extends BaseController {
	protected node: AdvancedCommonMapMatNode;
	constructor(node: AdvancedCommonMapMatNode);
	static update(node: AdvancedCommonMapMatNode): Promise<void>;
	updateMaterial(material: Material): void;
	setParamsFromMaterial(material: Material, record: SetParamsTextureNodesRecord): void;
}
interface UniformsTransparencyControllers {
	uniformTransparency: UniformsTransparencyController;
}
type TransparencyMaterial = Material;
declare const TransparencyParamsConfig_base: {
	new (...args: any[]): {
		/** @param sets the material to transparent */
		transparent: ParamTemplate<ParamType.BOOLEAN>;
		/** @param sets the material opacity */
		opacity: ParamTemplate<ParamType.FLOAT>;
		/** @param sets the min alpha below which the material is invisible */
		alphaTest: ParamTemplate<ParamType.FLOAT>;
	};
} & typeof NodeParamsConfig;
declare class TransparencyParamsConfig extends TransparencyParamsConfig_base {
}
declare class TransparencyMatNode extends TypedMatNode<TransparencyMaterial, TransparencyParamsConfig> {
	material(): Promise<Material | undefined>;
	controllers: UniformsTransparencyControllers;
}
declare class UniformsTransparencyController extends BaseController {
	protected node: TransparencyMatNode;
	constructor(node: TransparencyMatNode);
	static update(node: TransparencyMatNode): Promise<void>;
	updateMaterial(material: TransparencyMaterial): void;
	private _updateTransparency;
	private _updateCommon;
}
interface WireframeShaderMaterialControllers {
	wireframeShader: WireframeShaderMaterialController;
}
declare const WireframeShaderParamsConfig_base: {
	new (...args: any[]): {
		/** @param toggle on to set material to wireframe */
		wireframe: ParamTemplate<ParamType.BOOLEAN>;
		/** @param wireframe line width */
		wireframeLinewidth: ParamTemplate<ParamType.FLOAT>;
	};
} & typeof NodeParamsConfig;
declare class WireframeShaderParamsConfig extends WireframeShaderParamsConfig_base {
}
declare class WireframedShaderMatNode extends TypedMatNode<Material, WireframeShaderParamsConfig> {
	material(): Promise<Material | undefined>;
	controllers: WireframeShaderMaterialControllers;
}
declare class WireframeShaderMaterialController extends BaseController {
	protected node: WireframedShaderMatNode;
	constructor(node: WireframedShaderMatNode);
	static update(node: WireframedShaderMatNode): Promise<void>;
	updateMaterial(material: Material): void;
}
interface FogControllers {
	fog: FogController;
}
type FoggableMaterial = ShaderMaterial | MeshToonMaterial | MeshStandardMaterial | MeshPhysicalMaterial | MeshPhongMaterial | MeshMatcapMaterial | MeshLambertMaterial | MeshBasicMaterial;
declare const FogParamsConfig_base: {
	new (...args: any[]): {
		/** @param toggle on if you have a fog in the scene and the material should be affected by it */
		useFog: ParamTemplate<ParamType.BOOLEAN>;
	};
} & typeof NodeParamsConfig;
declare class FogParamsConfig extends FogParamsConfig_base {
}
declare abstract class FogMatNode extends TypedMatNode<FoggableMaterial, FogParamsConfig> {
	controllers: FogControllers;
	material(): Promise<FoggableMaterial | undefined>;
}
declare class FogController extends BaseController {
	protected node: FogMatNode;
	constructor(node: FogMatNode);
	static update(node: FogMatNode): Promise<void>;
	updateMaterial(material: FoggableMaterial): void;
}
interface CodeControllers extends AdvancedCommonControllers, FogControllers, UniformsTransparencyControllers, WireframeShaderMaterialControllers {
}
declare const CodeMatParamsConfig_base: {
	new (...args: any[]): {
		useFog: ParamTemplate<ParamType.BOOLEAN>;
	};
} & {
	new (...args: any[]): {
		wireframe: ParamTemplate<ParamType.BOOLEAN>;
		wireframeLinewidth: ParamTemplate<ParamType.FLOAT>;
	};
} & {
	new (...args: any[]): {
		doubleSided: ParamTemplate<ParamType.BOOLEAN>;
		front: ParamTemplate<ParamType.BOOLEAN>;
		overrideShadowSide: ParamTemplate<ParamType.BOOLEAN>;
		shadowDoubleSided: ParamTemplate<ParamType.BOOLEAN>;
		shadowFront: ParamTemplate<ParamType.BOOLEAN>;
		colorWrite: ParamTemplate<ParamType.BOOLEAN>;
		depthWrite: ParamTemplate<ParamType.BOOLEAN>;
		depthTest: ParamTemplate<ParamType.BOOLEAN>;
		premultipliedAlpha: ParamTemplate<ParamType.BOOLEAN>;
		blending: ParamTemplate<ParamType.INTEGER>;
		dithering: ParamTemplate<ParamType.BOOLEAN>;
		polygonOffset: ParamTemplate<ParamType.BOOLEAN>;
		polygonOffsetFactor: ParamTemplate<ParamType.INTEGER>;
		polygonOffsetUnits: ParamTemplate<ParamType.INTEGER>;
	};
} & {
	new (...args: any[]): {
		transparent: ParamTemplate<ParamType.BOOLEAN>;
		opacity: ParamTemplate<ParamType.FLOAT>;
		alphaTest: ParamTemplate<ParamType.FLOAT>;
	};
} & {
	new (...args: any[]): {
		advanced: ParamTemplate<ParamType.FOLDER>;
	};
} & {
	new (...args: any[]): {
		vertexShader: ParamTemplate<ParamType.FOLDER>;
		vertex: ParamTemplate<ParamType.STRING>;
		fragmentShader: ParamTemplate<ParamType.FOLDER>;
		fragment: ParamTemplate<ParamType.STRING>;
		extensions: ParamTemplate<ParamType.FOLDER>;
		derivatives: ParamTemplate<ParamType.BOOLEAN>;
	};
} & typeof NodeParamsConfig;
declare class CodeMatParamsConfig extends CodeMatParamsConfig_base {
}
declare class CodeMatNode extends PrimitiveMatNode<ShaderMaterial, CodeMatParamsConfig> {
	paramsConfig: CodeMatParamsConfig;
	static type(): string;
	createMaterial(): ShaderMaterial;
	readonly controllers: CodeControllers;
	protected controllersList: any[];
	cook(): Promise<void>;
}
type ColoredMaterial = MeshBasicMaterial | ShadowMaterial | MeshStandardMaterial;
declare const ColorParamsConfig_base: {
	new (...args: any[]): {
		/** @param material color */
		color: ParamTemplate<ParamType.COLOR>;
		/** @param defines if the color attribute on the geometry is used */
		useVertexColors: ParamTemplate<ParamType.BOOLEAN>;
		/** @param sets the material to transparent */
		transparent: ParamTemplate<ParamType.BOOLEAN>;
		/** @param sets the material opacity */
		opacity: ParamTemplate<ParamType.FLOAT>;
		/** @param sets the min alpha below which the material is invisible */
		alphaTest: ParamTemplate<ParamType.FLOAT>;
	};
} & typeof NodeParamsConfig;
declare class ColorParamsConfig extends ColorParamsConfig_base {
}
interface ColorsControllers {
	colors: ColorsController;
}
declare class ColoredMatNode extends TypedMatNode<ColoredMaterial, ColorParamsConfig> {
	controllers: ColorsControllers;
	material(): Promise<ColoredMaterial | undefined>;
}
declare class ColorsController extends BaseController {
	protected node: ColoredMatNode;
	constructor(node: ColoredMatNode);
	static update(node: ColoredMatNode): Promise<void>;
	updateMaterial(material: ColoredMaterial): void;
	setParamsFromMaterial(material: ColoredMaterial, record: SetParamsTextureNodesRecord): void;
}
interface ColorControllers {
	colors: ColorsController;
}
declare const ColorMatParamsConfig_base: {
	new (...args: any[]): {
		color: ParamTemplate<ParamType.COLOR>;
		useVertexColors: ParamTemplate<ParamType.BOOLEAN>;
		transparent: ParamTemplate<ParamType.BOOLEAN>;
		opacity: ParamTemplate<ParamType.FLOAT>;
		alphaTest: ParamTemplate<ParamType.FLOAT>;
	};
} & typeof NodeParamsConfig;
declare class ColorMatParamsConfig extends ColorMatParamsConfig_base {
}
declare class ColorMatNode extends UpdateMatNode<ColoredMaterial, ColorMatParamsConfig> {
	paramsConfig: ColorMatParamsConfig;
	static type(): string;
	readonly controllers: ColorControllers;
	cook(inputMaterials: Material[]): Promise<void>;
}
type FilterFlags<Base, Condition> = {
	[Key in keyof Base]: Base[Key] extends Condition ? Key : never;
};
type AllowedNames<Base, Condition> = FilterFlags<Base, Condition>[keyof Base];
type SubType<Base, Condition> = Pick<Base, AllowedNames<Base, Condition>>;
type BaseTextureControllerCurrentMaterial = Material;
declare abstract class BaseTextureMapController extends BaseController {
	protected node: BaseMatNodeType;
	constructor(node: BaseMatNodeType);
	protected add_hooks(use_map_param: BooleanParam, path_param: NodePathParam): void;
	static update(node: BaseNodeType): Promise<void>;
	private updateBound;
	update(): Promise<void>;
	_update<M extends BaseTextureControllerCurrentMaterial>(material: M, mat_attrib_name: string, use_map_param: BooleanParam, path_param: NodePathParam): Promise<void>;
	_update_texture_on_material<M extends Material>(material: M, mat_attrib_name: keyof SubType<M, Texture | null>, use_map_param: BooleanParam, path_param: NodePathParam): Promise<void>;
	private _apply_texture_on_material;
	private _remove_texture_from_material;
	private _update_required_attribute;
}
type TextureEnvMapControllerCurrentMaterial = MeshStandardMaterial | MeshPhysicalMaterial;
declare const TextureEnvMapParamsConfig_base: {
	new (...args: any[]): {
		/** @param toggle if you want to use an environment map */
		useEnvMap: ParamTemplate<ParamType.BOOLEAN>;
		/** @param specify the environment map COP node */
		envMap: ParamTemplate<ParamType.NODE_PATH>;
		/** @param environment intensity */
		envMapIntensity: ParamTemplate<ParamType.FLOAT>;
	};
} & typeof NodeParamsConfig;
declare class TextureEnvMapParamsConfig extends TextureEnvMapParamsConfig_base {
}
interface TextureEnvMapControllers {
	envMap: TextureEnvMapController;
}
declare abstract class TextureEnvMapMatNode extends TypedMatNode<TextureEnvMapControllerCurrentMaterial, TextureEnvMapParamsConfig> {
	controllers: TextureEnvMapControllers;
	material(): Promise<TextureEnvMapControllerCurrentMaterial | undefined>;
}
declare class TextureEnvMapController extends BaseTextureMapController {
	protected node: TextureEnvMapMatNode;
	constructor(node: TextureEnvMapMatNode);
	initializeNode(): void;
	static update(node: TextureEnvMapMatNode): Promise<void>;
	update(): Promise<void>;
	updateMaterial(material: TextureEnvMapControllerCurrentMaterial): Promise<void>;
	getTextures(material: TextureEnvMapControllerCurrentMaterial, record: MaterialTexturesRecord): void;
	setParamsFromMaterial(material: TextureEnvMapControllerCurrentMaterial, record: SetParamsTextureNodesRecord): void;
}
interface EnvMapControllers {
	envMap: TextureEnvMapController;
}
declare const EnvMapMatParamsConfig_base: {
	new (...args: any[]): {
		useEnvMap: ParamTemplate<ParamType.BOOLEAN>;
		envMap: ParamTemplate<ParamType.NODE_PATH>;
		envMapIntensity: ParamTemplate<ParamType.FLOAT>;
	};
} & typeof NodeParamsConfig;
declare class EnvMapMatParamsConfig extends EnvMapMatParamsConfig_base {
}
declare class EnvMapMatNode extends UpdateMatNode<MeshStandardMaterial, EnvMapMatParamsConfig> {
	paramsConfig: EnvMapMatParamsConfig;
	static type(): string;
	readonly controllers: EnvMapControllers;
	cook(inputMaterials: Material[]): Promise<void>;
}
declare enum MatType {
	LINE_BASIC = "lineBasic",
	LINE_BASIC_BUILDER = "lineBasicBuilder",
	MESH_BASIC = "meshBasic",
	MESH_BASIC_BUILDER = "meshBasicBuilder",
	MESH_DEPTH_BUILDER = "meshDepthBuilder",
	MESH_DISTANCE_BUILDER = "meshDistanceBuilder",
	MESH_LAMBERT = "meshLambert",
	MESH_LAMBERT_BUILDER = "meshLambertBuilder",
	MESH_MATCAP = "meshMatcap",
	MESH_NORMAL = "meshNormal",
	MESH_PHONG = "meshPhong",
	MESH_PHONG_BUILDER = "meshPhongBuilder",
	MESH_PHYSICAL = "meshPhysical",
	MESH_PHYSICAL_BUILDER = "meshPhysicalBuilder",
	MESH_STANDARD = "meshStandard",
	MESH_STANDARD_BUILDER = "meshStandardBuilder",
	MESH_TOON = "meshToon",
	MESH_TOON_BUILDER = "meshToonBuilder",
	POINTS = "points",
	POINTS_BUILDER = "pointsBuilder",
	RAY_MARCHING_BUILDER = "rayMarchingBuilder",
	SHADOW = "shadow",
	SKY = "sky",
	VOLUME = "volume",
	VOLUME_BUILDER = "volumeBuilder"
}
interface LineBasicBuilderControllers extends AdvancedCommonControllers {
}
declare const LineBasicMatParamsConfig_base: {
	new (...args: any[]): {
		doubleSided: ParamTemplate<ParamType.BOOLEAN>;
		front: ParamTemplate<ParamType.BOOLEAN>;
		overrideShadowSide: ParamTemplate<ParamType.BOOLEAN>;
		shadowDoubleSided: ParamTemplate<ParamType.BOOLEAN>;
		shadowFront: ParamTemplate<ParamType.BOOLEAN>;
		colorWrite: ParamTemplate<ParamType.BOOLEAN>;
		depthWrite: ParamTemplate<ParamType.BOOLEAN>;
		depthTest: ParamTemplate<ParamType.BOOLEAN>;
		premultipliedAlpha: ParamTemplate<ParamType.BOOLEAN>;
		blending: ParamTemplate<ParamType.INTEGER>;
		dithering: ParamTemplate<ParamType.BOOLEAN>;
		polygonOffset: ParamTemplate<ParamType.BOOLEAN>;
		polygonOffsetFactor: ParamTemplate<ParamType.INTEGER>;
		polygonOffsetUnits: ParamTemplate<ParamType.INTEGER>;
	};
} & typeof NodeParamsConfig;
declare class LineBasicMatParamsConfig extends LineBasicMatParamsConfig_base {
	/** @param line color */
	color: ParamTemplate<ParamType.COLOR>;
	/** @param line width */
	lineWidth: ParamTemplate<ParamType.FLOAT>;
}
declare class LineBasicMatNode extends PrimitiveMatNode<LineBasicMaterial, LineBasicMatParamsConfig> {
	paramsConfig: LineBasicMatParamsConfig;
	static type(): MatType.LINE_BASIC;
	createMaterial(): LineBasicMaterial;
	readonly controllers: LineBasicBuilderControllers;
	protected controllersList: any[];
	cook(): Promise<void>;
}
declare class ShaderAssemblerLine extends ShaderAssemblerMaterial {
	templateShader(): {
		vertexShader: string;
		fragmentShader: string;
		uniforms: {
			[uniform: string]: IUniform<any>;
		};
	};
	createMaterial(): LineBasicMaterial;
	customAssemblerClassByCustomName(): CustomAssemblerMap;
	create_shader_configs(): ShaderConfig[];
	static output_input_connection_points(): (GlConnectionPoint<GlConnectionPointType.VEC3> | GlConnectionPoint<GlConnectionPointType.VEC2> | GlConnectionPoint<GlConnectionPointType.FLOAT>)[];
	add_output_inputs(output_child: OutputGlNode): void;
	static create_globals_node_output_connections(): (GlConnectionPoint<GlConnectionPointType.VEC3> | GlConnectionPoint<GlConnectionPointType.VEC2> | GlConnectionPoint<GlConnectionPointType.VEC4> | GlConnectionPoint<GlConnectionPointType.FLOAT>)[];
	create_globals_node_output_connections(): (GlConnectionPoint<GlConnectionPointType.VEC3> | GlConnectionPoint<GlConnectionPointType.VEC2> | GlConnectionPoint<GlConnectionPointType.VEC4> | GlConnectionPoint<GlConnectionPointType.FLOAT>)[];
	create_variable_configs(): VariableConfig[];
	protected linesToRemove(shader_name: ShaderName): string[] | undefined;
}
type RemoveShaders<Type> = {
	[Property in keyof Type as Exclude<Property, "fragmentShader" | "vertexShader">]: Type[Property];
};
interface OnBeforeCompileDataJSONWithoutShaders extends RemoveShaders<OnBeforeCompileDataJSON> {
}
interface PersistedConfigBaseMaterialData {
	material: object;
	onBeforeCompileDataJSONWithoutShaders: OnBeforeCompileDataJSONWithoutShaders;
	customMaterials?: PolyDictionary<PersistedConfigBaseMaterialData>;
}
interface PersistedConfigBaseMaterialDataWithShaders extends PersistedConfigBaseMaterialData, PersistedConfigWithShaders {
}
declare class MaterialPersistedConfig extends BasePersistedConfig {
	protected node: BaseBuilderMatNodeType;
	private _material;
	constructor(node: BaseBuilderMatNodeType);
	toData(): Promise<PersistedConfigBaseMaterialDataWithShaders | undefined>;
	load(data: PersistedConfigBaseMaterialDataWithShaders): void;
	material(): MaterialWithCustomMaterials | undefined;
}
declare const MatBuilderParamsConfig_base: {
	new (...args: any[]): {
		/** @param if toggled on, the shader will be built from the gl nodes of another material. This can be useful to have multiple materials use the same gl network, but still set the uniforms differently */
		setBuilderNode: ParamTemplate<ParamType.BOOLEAN>;
		/** @param builder node */
		builderNode: ParamTemplate<ParamType.NODE_PATH>;
	};
} & typeof NodeParamsConfig;
declare class MatBuilderParamsConfig extends MatBuilderParamsConfig_base {
}
declare abstract class TypedBuilderMatNode<M extends MaterialWithCustomMaterials, A extends ShaderAssemblerMaterial, K extends MatBuilderParamsConfig> extends PrimitiveMatNode<M, K> {
	protected _assemblerController: GlAssemblerController<A> | undefined;
	protected _childrenControllerContext: NodeContext;
	readonly persisted_config: MaterialPersistedConfig;
	createMaterial(): M;
	assemblerController(): GlAssemblerController<A> | undefined;
	protected abstract _createAssemblerController(): GlAssemblerController<A> | undefined;
	customMaterialRequested(customName: CustomMaterialName): boolean;
	createNode<S extends keyof GlNodeChildrenMap>(node_class: S, options?: NodeCreateOptions): GlNodeChildrenMap[S];
	createNode<K extends valueof<GlNodeChildrenMap>>(node_class: Constructor<K>, options?: NodeCreateOptions): K;
	children(): BaseGlNodeType[];
	nodesByType<K extends keyof GlNodeChildrenMap>(type: K): GlNodeChildrenMap[K][];
	childrenAllowed(): boolean;
	sceneReadonly(): boolean;
	compileIfRequired(material: M): void;
	protected _compile(material: M): void;
	private _setAssemblerGlParentNode;
	static PARAM_CALLBACK_setCompileRequired(node: BaseBuilderMatNodeType): void;
	private PARAM_CALLBACK_setCompileRequired;
}
type BaseBuilderMatNodeType = TypedBuilderMatNode<MaterialWithCustomMaterials, ShaderAssemblerMaterial, MatBuilderParamsConfig>;
interface LineBasicBuilderControllers extends AdvancedCommonControllers, UniformsTransparencyControllers {
}
interface LineBasicBuilderMaterial extends LineBasicMaterial {
	vertexShader: string;
	fragmentShader: string;
	customMaterials: {
		[key in CustomMaterialName]?: Material;
	};
}
declare const LineBasicBuilderMatParamsConfig_base: {
	new (...args: any[]): {
		overrideCustomMaterials: ParamTemplate<ParamType.BOOLEAN>;
		createCustomMatDistance: ParamTemplate<ParamType.BOOLEAN>;
		createCustomMatDepth: ParamTemplate<ParamType.BOOLEAN>;
		createCustomMatDepthDOF: ParamTemplate<ParamType.BOOLEAN>;
	};
} & {
	new (...args: any[]): {
		doubleSided: ParamTemplate<ParamType.BOOLEAN>;
		front: ParamTemplate<ParamType.BOOLEAN>;
		overrideShadowSide: ParamTemplate<ParamType.BOOLEAN>;
		shadowDoubleSided: ParamTemplate<ParamType.BOOLEAN>;
		shadowFront: ParamTemplate<ParamType.BOOLEAN>;
		colorWrite: ParamTemplate<ParamType.BOOLEAN>;
		depthWrite: ParamTemplate<ParamType.BOOLEAN>;
		depthTest: ParamTemplate<ParamType.BOOLEAN>;
		premultipliedAlpha: ParamTemplate<ParamType.BOOLEAN>;
		blending: ParamTemplate<ParamType.INTEGER>;
		dithering: ParamTemplate<ParamType.BOOLEAN>;
		polygonOffset: ParamTemplate<ParamType.BOOLEAN>;
		polygonOffsetFactor: ParamTemplate<ParamType.INTEGER>;
		polygonOffsetUnits: ParamTemplate<ParamType.INTEGER>;
	};
} & {
	new (...args: any[]): {
		setBuilderNode: ParamTemplate<ParamType.BOOLEAN>;
		builderNode: ParamTemplate<ParamType.NODE_PATH>;
	};
} & {
	new (...args: any[]): {
		advanced: ParamTemplate<ParamType.FOLDER>;
	};
} & {
	new (...args: any[]): {
		transparent: ParamTemplate<ParamType.BOOLEAN>;
		opacity: ParamTemplate<ParamType.FLOAT>;
		alphaTest: ParamTemplate<ParamType.FLOAT>;
	};
} & {
	new (...args: any[]): {
		default: ParamTemplate<ParamType.FOLDER>;
	};
} & typeof NodeParamsConfig;
declare class LineBasicBuilderMatParamsConfig extends LineBasicBuilderMatParamsConfig_base {
	linewidth: ParamTemplate<ParamType.FLOAT>;
}
declare class LineBasicBuilderMatNode extends TypedBuilderMatNode<LineBasicBuilderMaterial, ShaderAssemblerLine, LineBasicBuilderMatParamsConfig> {
	paramsConfig: LineBasicBuilderMatParamsConfig;
	static type(): MatType;
	usedAssembler(): Readonly<AssemblerName.GL_LINE>;
	protected _createAssemblerController(): GlAssemblerController<ShaderAssemblerLine> | undefined;
	customMaterialRequested(customName: CustomMaterialName): boolean;
	readonly controllers: LineBasicBuilderControllers;
	protected controllersList: any[];
	cook(): Promise<void>;
}
type TextureMapCurrentMaterial = MeshBasicMaterial | MeshLambertMaterial | MeshMatcapMaterial | MeshPhongMaterial | MeshStandardMaterial | MeshPhysicalMaterial | MeshToonMaterial | PointsMaterial;
declare const TextureMapParamsConfig_base: {
	new (...args: any[]): {
		/** @param toggle on to use a map affecting color */
		useMap: ParamTemplate<ParamType.BOOLEAN>;
		/** @param texture map affecting color */
		map: ParamTemplate<ParamType.NODE_PATH>;
	};
} & typeof NodeParamsConfig;
declare class TextureMapParamsConfig extends TextureMapParamsConfig_base {
}
interface TextureMapControllers {
	map: TextureMapController;
}
declare abstract class TextureMapMatNode extends TypedMatNode<TextureMapCurrentMaterial, TextureMapParamsConfig> {
	controllers: TextureMapControllers;
	material(): Promise<TextureMapCurrentMaterial | undefined>;
}
declare class TextureMapController extends BaseTextureMapController {
	protected node: TextureMapMatNode;
	constructor(node: TextureMapMatNode);
	initializeNode(): void;
	static update(node: TextureMapMatNode): Promise<void>;
	update(): Promise<void>;
	updateMaterial(material: TextureMapCurrentMaterial): Promise<void>;
	getTextures(material: TextureMapCurrentMaterial, record: MaterialTexturesRecord): void;
	setParamsFromMaterial(material: TextureMapCurrentMaterial, record: SetParamsTextureNodesRecord): void;
}
type TextureAlphaMapControllerCurrentMaterial = MeshBasicMaterial | MeshLambertMaterial | MeshPhongMaterial | MeshStandardMaterial | MeshPhysicalMaterial | MeshMatcapMaterial | MeshToonMaterial | PointsMaterial;
declare const TextureAlphaMapParamsConfig_base: {
	new (...args: any[]): {
		/** @param toggle if you want to use an alpha map */
		useAlphaMap: ParamTemplate<ParamType.BOOLEAN>;
		/** @param specify the alpha map COP node */
		alphaMap: ParamTemplate<ParamType.NODE_PATH>;
	};
} & typeof NodeParamsConfig;
declare class TextureAlphaMapParamsConfig extends TextureAlphaMapParamsConfig_base {
}
interface TextureAlphaMapControllers {
	alphaMap: TextureAlphaMapController;
}
declare abstract class TextureAlphaMapMatNode extends TypedMatNode<TextureAlphaMapControllerCurrentMaterial, TextureAlphaMapParamsConfig> {
	controllers: TextureAlphaMapControllers;
	material(): Promise<TextureAlphaMapControllerCurrentMaterial | undefined>;
}
declare class TextureAlphaMapController extends BaseTextureMapController {
	protected node: TextureAlphaMapMatNode;
	constructor(node: TextureAlphaMapMatNode);
	initializeNode(): void;
	static update(node: TextureAlphaMapMatNode): Promise<void>;
	update(): Promise<void>;
	updateMaterial(material: TextureAlphaMapControllerCurrentMaterial): Promise<void>;
	getTextures(material: TextureAlphaMapControllerCurrentMaterial, record: MaterialTexturesRecord): void;
	setParamsFromMaterial(material: TextureAlphaMapControllerCurrentMaterial, record: SetParamsTextureNodesRecord): void;
}
type TextureAOMapControllerCurrentMaterial = MeshBasicMaterial | MeshLambertMaterial | MeshStandardMaterial | MeshPhysicalMaterial | MeshToonMaterial;
declare const TextureAOMapParamsConfig_base: {
	new (...args: any[]): {
		/** @param toggle if you want to use an ambient occlusion map */
		useAOMap: ParamTemplate<ParamType.BOOLEAN>;
		/** @param specify the AO map COP node */
		aoMap: ParamTemplate<ParamType.NODE_PATH>;
		/** @param ambient occlusion intensity */
		aoMapIntensity: ParamTemplate<ParamType.FLOAT>;
	};
} & typeof NodeParamsConfig;
declare class TextureAOMapParamsConfig extends TextureAOMapParamsConfig_base {
}
interface TextureAOMapControllers {
	aoMap: TextureAOMapController;
}
declare abstract class TextureAOMapMatNode extends TypedMatNode<TextureAOMapControllerCurrentMaterial, TextureAOMapParamsConfig> {
	controllers: TextureAOMapControllers;
	material(): Promise<TextureAOMapControllerCurrentMaterial | undefined>;
}
declare class TextureAOMapController extends BaseTextureMapController {
	protected node: TextureAOMapMatNode;
	constructor(node: TextureAOMapMatNode);
	initializeNode(): void;
	static update(node: TextureAOMapMatNode): Promise<void>;
	update(): Promise<void>;
	updateMaterial(material: TextureAOMapControllerCurrentMaterial): Promise<void>;
	getTextures(material: TextureAOMapControllerCurrentMaterial, record: MaterialTexturesRecord): void;
	setParamsFromMaterial(material: TextureAOMapControllerCurrentMaterial, record: SetParamsTextureNodesRecord): void;
}
type TextureEnvMapSimpleCurrentMaterial = MeshBasicMaterial | MeshLambertMaterial | MeshPhongMaterial;
declare const TextureEnvMapSimpleParamsConfig_base: {
	new (...args: any[]): {
		/** @param toggle if you want to use an environment map */
		useEnvMap: ParamTemplate<ParamType.BOOLEAN>;
		/** @param specify the environment map COP node. Note that this only works with CubeCamera */
		envMap: ParamTemplate<ParamType.NODE_PATH>;
		/** @param defines how the env map is combined with the color */
		combine: ParamTemplate<ParamType.INTEGER>;
		/** @param environment intensity */
		reflectivity: ParamTemplate<ParamType.FLOAT>;
		/** @param refraction ratio */
		refractionRatio: ParamTemplate<ParamType.FLOAT>;
	};
} & typeof NodeParamsConfig;
declare class TextureEnvMapSimpleParamsConfig extends TextureEnvMapSimpleParamsConfig_base {
}
interface TextureEnvMapSimpleControllers {
	envMap: TextureEnvMapSimpleController;
}
declare abstract class TextureEnvMapSimpleMatNode extends TypedMatNode<TextureEnvMapSimpleCurrentMaterial, TextureEnvMapSimpleParamsConfig> {
	controllers: TextureEnvMapSimpleControllers;
	material(): Promise<TextureEnvMapSimpleCurrentMaterial | undefined>;
}
declare class TextureEnvMapSimpleController extends BaseTextureMapController {
	protected node: TextureEnvMapSimpleMatNode;
	constructor(node: TextureEnvMapSimpleMatNode);
	initializeNode(): void;
	static update(node: TextureEnvMapSimpleMatNode): Promise<void>;
	update(): Promise<void>;
	updateMaterial(material: TextureEnvMapSimpleCurrentMaterial): Promise<void>;
	getTextures(material: TextureEnvMapSimpleCurrentMaterial, record: MaterialTexturesRecord): void;
	setParamsFromMaterial(material: TextureEnvMapSimpleCurrentMaterial, record: SetParamsTextureNodesRecord): void;
}
type TextureLightMapCurrentMaterial = MeshBasicMaterial | MeshLambertMaterial | MeshStandardMaterial | MeshPhysicalMaterial | MeshToonMaterial;
declare const TextureLightMapParamsConfig_base: {
	new (...args: any[]): {
		/** @param toggle if you want to use a light map */
		useLightMap: ParamTemplate<ParamType.BOOLEAN>;
		/** @param specify the light map COP node */
		lightMap: ParamTemplate<ParamType.NODE_PATH>;
		/** @param light. When set to 0, reflections from environment maps will be very sharp, or blurred when 1. Any value between 0 and 1 can help modulate this. */
		lightMapIntensity: ParamTemplate<ParamType.FLOAT>;
	};
} & typeof NodeParamsConfig;
declare class TextureLightMapParamsConfig extends TextureLightMapParamsConfig_base {
}
interface TextureLightMapControllers {
	lightMap: TextureLightMapController;
}
declare abstract class TextureLightMapMatNode extends TypedMatNode<TextureLightMapCurrentMaterial, TextureLightMapParamsConfig> {
	controllers: TextureLightMapControllers;
	material(): Promise<TextureLightMapCurrentMaterial | undefined>;
}
declare class TextureLightMapController extends BaseTextureMapController {
	protected node: TextureLightMapMatNode;
	constructor(node: TextureLightMapMatNode);
	initializeNode(): void;
	static update(node: TextureLightMapMatNode): Promise<void>;
	update(): Promise<void>;
	updateMaterial(material: TextureLightMapCurrentMaterial): Promise<void>;
	getTextures(material: TextureLightMapCurrentMaterial, record: MaterialTexturesRecord): void;
	setParamsFromMaterial(material: TextureLightMapCurrentMaterial, record: SetParamsTextureNodesRecord): void;
}
interface WireframeControllers {
	wireframe: WireframeController;
}
type WireframedMaterial = MeshToonMaterial | MeshBasicMaterial | MeshStandardMaterial | MeshPhysicalMaterial;
declare const WireframeParamsConfig_base: {
	new (...args: any[]): {
		/** @param toggle on to set material to wireframe */
		wireframe: ParamTemplate<ParamType.BOOLEAN>;
		/** @param wireframe line width */
		wireframeLinewidth: ParamTemplate<ParamType.FLOAT>;
		/** @param define appearance of line ends */
		wireframeLinecap: ParamTemplate<ParamType.INTEGER>;
		/** @param Define appearance of line joints */
		wireframeLinejoin: ParamTemplate<ParamType.INTEGER>;
	};
} & typeof NodeParamsConfig;
declare class WireframeParamsConfig extends WireframeParamsConfig_base {
}
declare class WireframedMatNode extends TypedMatNode<WireframedMaterial, WireframeParamsConfig> {
	material(): Promise<WireframedMaterial | undefined>;
	controllers: WireframeControllers;
}
declare class WireframeController extends BaseController {
	protected node: WireframedMatNode;
	constructor(node: WireframedMatNode);
	static update(node: WireframedMatNode): Promise<void>;
	updateMaterial(material: WireframedMaterial): void;
	getTextures(material: WireframedMaterial, record: MaterialTexturesRecord): void;
	setParamsFromMaterial(material: WireframedMaterial, record: SetParamsTextureNodesRecord): void;
}
interface MeshBasicMaterialWithLightMap extends MeshBasicMaterial {
	lightMap: Texture | null;
	lightMapIntensity: number;
}
interface MeshBasicControllers extends AdvancedCommonControllers, ColorsControllers, FogControllers, TextureAlphaMapControllers, TextureAOMapControllers, TextureEnvMapSimpleControllers, TextureLightMapControllers, TextureMapControllers, WireframeControllers {
}
declare const MeshBasicMatParamsConfig_base: {
	new (...args: any[]): {
		useFog: ParamTemplate<ParamType.BOOLEAN>;
	};
} & {
	new (...args: any[]): {
		wireframe: ParamTemplate<ParamType.BOOLEAN>;
		wireframeLinewidth: ParamTemplate<ParamType.FLOAT>;
		wireframeLinecap: ParamTemplate<ParamType.INTEGER>;
		wireframeLinejoin: ParamTemplate<ParamType.INTEGER>;
	};
} & {
	new (...args: any[]): {
		doubleSided: ParamTemplate<ParamType.BOOLEAN>;
		front: ParamTemplate<ParamType.BOOLEAN>;
		overrideShadowSide: ParamTemplate<ParamType.BOOLEAN>;
		shadowDoubleSided: ParamTemplate<ParamType.BOOLEAN>;
		shadowFront: ParamTemplate<ParamType.BOOLEAN>;
		colorWrite: ParamTemplate<ParamType.BOOLEAN>;
		depthWrite: ParamTemplate<ParamType.BOOLEAN>;
		depthTest: ParamTemplate<ParamType.BOOLEAN>;
		premultipliedAlpha: ParamTemplate<ParamType.BOOLEAN>;
		blending: ParamTemplate<ParamType.INTEGER>;
		dithering: ParamTemplate<ParamType.BOOLEAN>;
		polygonOffset: ParamTemplate<ParamType.BOOLEAN>;
		polygonOffsetFactor: ParamTemplate<ParamType.INTEGER>;
		polygonOffsetUnits: ParamTemplate<ParamType.INTEGER>;
	};
} & {
	new (...args: any[]): {
		advanced: ParamTemplate<ParamType.FOLDER>;
	};
} & {
	new (...args: any[]): {
		useLightMap: ParamTemplate<ParamType.BOOLEAN>;
		lightMap: ParamTemplate<ParamType.NODE_PATH>;
		lightMapIntensity: ParamTemplate<ParamType.FLOAT>;
	};
} & {
	new (...args: any[]): {
		useEnvMap: ParamTemplate<ParamType.BOOLEAN>;
		envMap: ParamTemplate<ParamType.NODE_PATH>;
		combine: ParamTemplate<ParamType.INTEGER>;
		reflectivity: ParamTemplate<ParamType.FLOAT>;
		refractionRatio: ParamTemplate<ParamType.FLOAT>;
	};
} & {
	new (...args: any[]): {
		useAOMap: ParamTemplate<ParamType.BOOLEAN>;
		aoMap: ParamTemplate<ParamType.NODE_PATH>;
		aoMapIntensity: ParamTemplate<ParamType.FLOAT>;
	};
} & {
	new (...args: any[]): {
		useAlphaMap: ParamTemplate<ParamType.BOOLEAN>;
		alphaMap: ParamTemplate<ParamType.NODE_PATH>;
	};
} & {
	new (...args: any[]): {
		useMap: ParamTemplate<ParamType.BOOLEAN>;
		map: ParamTemplate<ParamType.NODE_PATH>;
	};
} & {
	new (...args: any[]): {
		textures: ParamTemplate<ParamType.FOLDER>;
	};
} & {
	new (...args: any[]): {
		color: ParamTemplate<ParamType.COLOR>;
		useVertexColors: ParamTemplate<ParamType.BOOLEAN>;
		transparent: ParamTemplate<ParamType.BOOLEAN>;
		opacity: ParamTemplate<ParamType.FLOAT>;
		alphaTest: ParamTemplate<ParamType.FLOAT>;
	};
} & {
	new (...args: any[]): {
		default: ParamTemplate<ParamType.FOLDER>;
	};
} & typeof NodeParamsConfig;
declare class MeshBasicMatParamsConfig extends MeshBasicMatParamsConfig_base {
}
declare class MeshBasicMatNode extends PrimitiveMatNode<MeshBasicMaterialWithLightMap, MeshBasicMatParamsConfig> {
	paramsConfig: MeshBasicMatParamsConfig;
	static type(): MatType.MESH_BASIC;
	createMaterial(): MeshBasicMaterialWithLightMap;
	readonly controllers: MeshBasicControllers;
	protected controllersList: any[];
	cook(): Promise<void>;
}
declare abstract class ShaderAssemblerMesh extends ShaderAssemblerMaterial {
	customAssemblerClassByCustomName(): CustomAssemblerMap | undefined;
	protected insertDefineAfter(shaderName: ShaderName): string | undefined;
}
declare class ShaderAssemblerBasic extends ShaderAssemblerMesh {
	templateShader(): {
		vertexShader: string;
		fragmentShader: string;
		uniforms: {
			[uniform: string]: IUniform<any>;
		};
	};
	createMaterial(): MeshBasicMaterial;
}
interface UniformFogControllers {
	uniformFog: UniformFogController;
}
declare const FogUniformsParamsConfig_base: {
	new (...args: any[]): {
		/** @param toggle on if you have a fog in the scene and the material should be affected by it */
		useFog: ParamTemplate<ParamType.BOOLEAN>;
	};
} & typeof NodeParamsConfig;
declare class FogUniformsParamsConfig extends FogUniformsParamsConfig_base {
}
type FoggableUniformsMaterial = ShaderMaterial | PointsMaterial | MeshStandardMaterial | MeshPhysicalMaterial | MeshPhongMaterial | MeshLambertMaterial | MeshBasicMaterial | MeshToonMaterial;
declare abstract class FogUniformsMatNode extends TypedMatNode<FoggableUniformsMaterial, FogUniformsParamsConfig> {
	controllers: UniformFogControllers;
}
declare class UniformFogController extends BaseController {
	protected node: FogUniformsMatNode;
	constructor(node: FogUniformsMatNode);
	static update(node: FogUniformsMatNode): Promise<void>;
	updateMaterial(material: FoggableUniformsMaterial): void;
	getTextures(material: FoggableUniformsMaterial, record: MaterialTexturesRecord): void;
	setParamsFromMaterial(material: FoggableUniformsMaterial, record: SetParamsTextureNodesRecord): void;
}
interface MeshBasicBuilderControllers extends AdvancedCommonControllers, UniformFogControllers, TextureAlphaMapControllers, TextureAOMapControllers, TextureEnvMapSimpleControllers, TextureMapControllers, UniformsTransparencyControllers, WireframeShaderMaterialControllers {
}
interface MeshBasicBuilderMaterial extends MeshBasicMaterial {
	vertexShader: string;
	fragmentShader: string;
	uniforms: IUniforms;
	customMaterials: {
		[key in CustomMaterialName]?: Material;
	};
}
declare const MeshBasicBuilderMatParamsConfig_base: {
	new (...args: any[]): {
		overrideCustomMaterials: ParamTemplate<ParamType.BOOLEAN>;
		createCustomMatDistance: ParamTemplate<ParamType.BOOLEAN>;
		createCustomMatDepth: ParamTemplate<ParamType.BOOLEAN>;
		createCustomMatDepthDOF: ParamTemplate<ParamType.BOOLEAN>;
	};
} & {
	new (...args: any[]): {
		useFog: ParamTemplate<ParamType.BOOLEAN>;
	};
} & {
	new (...args: any[]): {
		wireframe: ParamTemplate<ParamType.BOOLEAN>;
		wireframeLinewidth: ParamTemplate<ParamType.FLOAT>;
	};
} & {
	new (...args: any[]): {
		doubleSided: ParamTemplate<ParamType.BOOLEAN>;
		front: ParamTemplate<ParamType.BOOLEAN>;
		overrideShadowSide: ParamTemplate<ParamType.BOOLEAN>;
		shadowDoubleSided: ParamTemplate<ParamType.BOOLEAN>;
		shadowFront: ParamTemplate<ParamType.BOOLEAN>;
		colorWrite: ParamTemplate<ParamType.BOOLEAN>;
		depthWrite: ParamTemplate<ParamType.BOOLEAN>;
		depthTest: ParamTemplate<ParamType.BOOLEAN>;
		premultipliedAlpha: ParamTemplate<ParamType.BOOLEAN>;
		blending: ParamTemplate<ParamType.INTEGER>;
		dithering: ParamTemplate<ParamType.BOOLEAN>;
		polygonOffset: ParamTemplate<ParamType.BOOLEAN>;
		polygonOffsetFactor: ParamTemplate<ParamType.INTEGER>;
		polygonOffsetUnits: ParamTemplate<ParamType.INTEGER>;
	};
} & {
	new (...args: any[]): {
		setBuilderNode: ParamTemplate<ParamType.BOOLEAN>;
		builderNode: ParamTemplate<ParamType.NODE_PATH>;
	};
} & {
	new (...args: any[]): {
		advanced: ParamTemplate<ParamType.FOLDER>;
	};
} & {
	new (...args: any[]): {
		useEnvMap: ParamTemplate<ParamType.BOOLEAN>;
		envMap: ParamTemplate<ParamType.NODE_PATH>;
		combine: ParamTemplate<ParamType.INTEGER>;
		reflectivity: ParamTemplate<ParamType.FLOAT>;
		refractionRatio: ParamTemplate<ParamType.FLOAT>;
	};
} & {
	new (...args: any[]): {
		useAOMap: ParamTemplate<ParamType.BOOLEAN>;
		aoMap: ParamTemplate<ParamType.NODE_PATH>;
		aoMapIntensity: ParamTemplate<ParamType.FLOAT>;
	};
} & {
	new (...args: any[]): {
		useAlphaMap: ParamTemplate<ParamType.BOOLEAN>;
		alphaMap: ParamTemplate<ParamType.NODE_PATH>;
	};
} & {
	new (...args: any[]): {
		useMap: ParamTemplate<ParamType.BOOLEAN>;
		map: ParamTemplate<ParamType.NODE_PATH>;
	};
} & {
	new (...args: any[]): {
		textures: ParamTemplate<ParamType.FOLDER>;
	};
} & {
	new (...args: any[]): {
		transparent: ParamTemplate<ParamType.BOOLEAN>;
		opacity: ParamTemplate<ParamType.FLOAT>;
		alphaTest: ParamTemplate<ParamType.FLOAT>;
	};
} & {
	new (...args: any[]): {
		default: ParamTemplate<ParamType.FOLDER>;
	};
} & typeof NodeParamsConfig;
declare class MeshBasicBuilderMatParamsConfig extends MeshBasicBuilderMatParamsConfig_base {
}
declare class MeshBasicBuilderMatNode extends TypedBuilderMatNode<MeshBasicBuilderMaterial, ShaderAssemblerBasic, MeshBasicBuilderMatParamsConfig> {
	paramsConfig: MeshBasicBuilderMatParamsConfig;
	static type(): MatType;
	usedAssembler(): Readonly<AssemblerName.GL_MESH_BASIC>;
	protected _createAssemblerController(): GlAssemblerController<ShaderAssemblerBasic> | undefined;
	customMaterialRequested(customName: CustomMaterialName): boolean;
	readonly controllers: MeshBasicBuilderControllers;
	protected controllersList: any[];
	cook(): Promise<void>;
}
interface MeshDepthControllers extends AdvancedCommonControllers {
}
declare const MeshDepthMatParamsConfig_base: {
	new (...args: any[]): {
		doubleSided: ParamTemplate<ParamType.BOOLEAN>;
		front: ParamTemplate<ParamType.BOOLEAN>;
		overrideShadowSide: ParamTemplate<ParamType.BOOLEAN>;
		shadowDoubleSided: ParamTemplate<ParamType.BOOLEAN>;
		shadowFront: ParamTemplate<ParamType.BOOLEAN>;
		colorWrite: ParamTemplate<ParamType.BOOLEAN>;
		depthWrite: ParamTemplate<ParamType.BOOLEAN>;
		depthTest: ParamTemplate<ParamType.BOOLEAN>;
		premultipliedAlpha: ParamTemplate<ParamType.BOOLEAN>;
		blending: ParamTemplate<ParamType.INTEGER>;
		dithering: ParamTemplate<ParamType.BOOLEAN>;
		polygonOffset: ParamTemplate<ParamType.BOOLEAN>;
		polygonOffsetFactor: ParamTemplate<ParamType.INTEGER>;
		polygonOffsetUnits: ParamTemplate<ParamType.INTEGER>;
	};
} & typeof NodeParamsConfig;
declare class MeshDepthMatParamsConfig extends MeshDepthMatParamsConfig_base {
}
declare class MeshDepthMatNode extends PrimitiveMatNode<MeshDepthMaterial, MeshDepthMatParamsConfig> {
	paramsConfig: MeshDepthMatParamsConfig;
	static type(): string;
	createMaterial(): MeshDepthMaterial;
	readonly controllers: MeshDepthControllers;
	protected controllersList: any[];
	cook(): Promise<void>;
}
declare class ShaderAssemblerCustomMeshDepth extends ShaderAssemblerMaterial {
	protected _gl_parent_node: AssemblerGlControllerNode;
	constructor(_gl_parent_node: AssemblerGlControllerNode);
	templateShader(): {
		vertexShader: string;
		fragmentShader: string;
		uniforms: {
			[uniform: string]: IUniform<any>;
		};
	};
	protected insertDefineAfter(shaderName: ShaderName): string | undefined;
	protected insertBodyAfter(shaderName: ShaderName): string | undefined;
	protected depthPacking(): DepthPackingStrategies;
	createMaterial(): MeshDepthMaterial;
}
declare class ShaderAssemblerCustomMeshDepthForRender extends ShaderAssemblerCustomMeshDepth {
	protected depthPacking(): 3200;
}
interface MeshDepthBuilderControllers extends AdvancedCommonControllers, UniformsTransparencyControllers {
}
interface MeshDepthBuilderMaterial extends MeshDepthMaterial {
	vertexShader: string;
	fragmentShader: string;
	uniforms: IUniforms;
	customMaterials: {
		[key in CustomMaterialName]?: Material;
	};
}
declare const MeshDepthBuilderMatParamsConfig_base: {
	new (...args: any[]): {
		doubleSided: ParamTemplate<ParamType.BOOLEAN>;
		front: ParamTemplate<ParamType.BOOLEAN>;
		overrideShadowSide: ParamTemplate<ParamType.BOOLEAN>;
		shadowDoubleSided: ParamTemplate<ParamType.BOOLEAN>;
		shadowFront: ParamTemplate<ParamType.BOOLEAN>;
		colorWrite: ParamTemplate<ParamType.BOOLEAN>;
		depthWrite: ParamTemplate<ParamType.BOOLEAN>;
		depthTest: ParamTemplate<ParamType.BOOLEAN>;
		premultipliedAlpha: ParamTemplate<ParamType.BOOLEAN>;
		blending: ParamTemplate<ParamType.INTEGER>;
		dithering: ParamTemplate<ParamType.BOOLEAN>;
		polygonOffset: ParamTemplate<ParamType.BOOLEAN>;
		polygonOffsetFactor: ParamTemplate<ParamType.INTEGER>;
		polygonOffsetUnits: ParamTemplate<ParamType.INTEGER>;
	};
} & {
	new (...args: any[]): {
		setBuilderNode: ParamTemplate<ParamType.BOOLEAN>;
		builderNode: ParamTemplate<ParamType.NODE_PATH>;
	};
} & {
	new (...args: any[]): {
		transparent: ParamTemplate<ParamType.BOOLEAN>;
		opacity: ParamTemplate<ParamType.FLOAT>;
		alphaTest: ParamTemplate<ParamType.FLOAT>;
	};
} & typeof NodeParamsConfig;
declare class MeshDepthBuilderMatParamsConfig extends MeshDepthBuilderMatParamsConfig_base {
}
declare class MeshDepthBuilderMatNode extends TypedBuilderMatNode<MeshDepthBuilderMaterial, ShaderAssemblerCustomMeshDepth, MeshDepthBuilderMatParamsConfig> {
	paramsConfig: MeshDepthBuilderMatParamsConfig;
	static type(): MatType;
	usedAssembler(): Readonly<AssemblerName.GL_MESH_DEPTH>;
	protected _createAssemblerController(): GlAssemblerController<ShaderAssemblerCustomMeshDepthForRender> | undefined;
	customMaterialRequested(customName: CustomMaterialName): boolean;
	readonly controllers: MeshDepthBuilderControllers;
	protected controllersList: any[];
	cook(): Promise<void>;
}
interface MeshDistanceControllers extends AdvancedCommonControllers {
}
declare const MeshDistanceMatParamsConfig_base: {
	new (...args: any[]): {
		doubleSided: ParamTemplate<ParamType.BOOLEAN>;
		front: ParamTemplate<ParamType.BOOLEAN>;
		overrideShadowSide: ParamTemplate<ParamType.BOOLEAN>;
		shadowDoubleSided: ParamTemplate<ParamType.BOOLEAN>;
		shadowFront: ParamTemplate<ParamType.BOOLEAN>;
		colorWrite: ParamTemplate<ParamType.BOOLEAN>;
		depthWrite: ParamTemplate<ParamType.BOOLEAN>;
		depthTest: ParamTemplate<ParamType.BOOLEAN>;
		premultipliedAlpha: ParamTemplate<ParamType.BOOLEAN>;
		blending: ParamTemplate<ParamType.INTEGER>;
		dithering: ParamTemplate<ParamType.BOOLEAN>;
		polygonOffset: ParamTemplate<ParamType.BOOLEAN>;
		polygonOffsetFactor: ParamTemplate<ParamType.INTEGER>;
		polygonOffsetUnits: ParamTemplate<ParamType.INTEGER>;
	};
} & typeof NodeParamsConfig;
declare class MeshDistanceMatParamsConfig extends MeshDistanceMatParamsConfig_base {
}
declare class MeshDistanceMatNode extends PrimitiveMatNode<MeshDistanceMaterial, MeshDistanceMatParamsConfig> {
	paramsConfig: MeshDistanceMatParamsConfig;
	static type(): string;
	createMaterial(): MeshDistanceMaterial;
	readonly controllers: MeshDistanceControllers;
	protected controllersList: any[];
	cook(): Promise<void>;
}
declare class ShaderAssemblerCustomMeshDistance extends ShaderAssemblerMaterial {
	protected _gl_parent_node: AssemblerGlControllerNode;
	constructor(_gl_parent_node: AssemblerGlControllerNode);
	templateShader(): {
		vertexShader: string;
		fragmentShader: string;
		uniforms: {
			[uniform: string]: IUniform<any>;
		};
	};
	protected insertDefineAfter(shaderName: ShaderName): string | undefined;
	protected insertBodyAfter(shaderName: ShaderName): string | undefined;
	createMaterial(): MeshDistanceMaterial;
}
declare class ShaderAssemblerCustomMeshDistanceForRender extends ShaderAssemblerCustomMeshDistance {
}
interface MeshDistanceBuilderControllers extends AdvancedCommonControllers, UniformsTransparencyControllers {
}
interface MeshDistanceBuilderMaterial extends MeshDistanceMaterial {
	vertexShader: string;
	fragmentShader: string;
	uniforms: IUniforms;
	customMaterials: {
		[key in CustomMaterialName]?: Material;
	};
}
declare const MeshDistanceBuilderMatParamsConfig_base: {
	new (...args: any[]): {
		doubleSided: ParamTemplate<ParamType.BOOLEAN>;
		front: ParamTemplate<ParamType.BOOLEAN>;
		overrideShadowSide: ParamTemplate<ParamType.BOOLEAN>;
		shadowDoubleSided: ParamTemplate<ParamType.BOOLEAN>;
		shadowFront: ParamTemplate<ParamType.BOOLEAN>;
		colorWrite: ParamTemplate<ParamType.BOOLEAN>;
		depthWrite: ParamTemplate<ParamType.BOOLEAN>;
		depthTest: ParamTemplate<ParamType.BOOLEAN>;
		premultipliedAlpha: ParamTemplate<ParamType.BOOLEAN>;
		blending: ParamTemplate<ParamType.INTEGER>;
		dithering: ParamTemplate<ParamType.BOOLEAN>;
		polygonOffset: ParamTemplate<ParamType.BOOLEAN>;
		polygonOffsetFactor: ParamTemplate<ParamType.INTEGER>;
		polygonOffsetUnits: ParamTemplate<ParamType.INTEGER>;
	};
} & {
	new (...args: any[]): {
		setBuilderNode: ParamTemplate<ParamType.BOOLEAN>;
		builderNode: ParamTemplate<ParamType.NODE_PATH>;
	};
} & {
	new (...args: any[]): {
		transparent: ParamTemplate<ParamType.BOOLEAN>;
		opacity: ParamTemplate<ParamType.FLOAT>;
		alphaTest: ParamTemplate<ParamType.FLOAT>;
	};
} & typeof NodeParamsConfig;
declare class MeshDistanceBuilderMatParamsConfig extends MeshDistanceBuilderMatParamsConfig_base {
}
declare class MeshDistanceBuilderMatNode extends TypedBuilderMatNode<MeshDistanceBuilderMaterial, ShaderAssemblerCustomMeshDistance, MeshDistanceBuilderMatParamsConfig> {
	paramsConfig: MeshDistanceBuilderMatParamsConfig;
	static type(): MatType;
	usedAssembler(): Readonly<AssemblerName.GL_MESH_DISTANCE>;
	protected _createAssemblerController(): GlAssemblerController<ShaderAssemblerCustomMeshDistanceForRender> | undefined;
	customMaterialRequested(customName: CustomMaterialName): boolean;
	readonly controllers: MeshDistanceBuilderControllers;
	protected controllersList: any[];
	cook(): Promise<void>;
}
type TextureEmissiveMapControllerCurrentMaterial = MeshPhongMaterial | MeshLambertMaterial | MeshStandardMaterial | MeshPhysicalMaterial | MeshToonMaterial;
declare const TextureEmissiveMapParamsConfig_base: {
	new (...args: any[]): {
		/** @param emissive color */
		emissive: ParamTemplate<ParamType.COLOR>;
		/** @param toggle if you want to use a emissive map */
		useEmissiveMap: ParamTemplate<ParamType.BOOLEAN>;
		/** @param specify the emissive map COP node */
		emissiveMap: ParamTemplate<ParamType.NODE_PATH>;
		/** @param emissive intensity */
		emissiveIntensity: ParamTemplate<ParamType.FLOAT>;
	};
} & typeof NodeParamsConfig;
declare class TextureEmissiveMapParamsConfig extends TextureEmissiveMapParamsConfig_base {
}
interface TextureEmissiveMapControllers {
	emissiveMap: TextureEmissiveMapController;
}
declare abstract class TextureEmissiveMapMatNode extends TypedMatNode<TextureEmissiveMapControllerCurrentMaterial, TextureEmissiveMapParamsConfig> {
	controllers: TextureEmissiveMapControllers;
	material(): Promise<TextureEmissiveMapControllerCurrentMaterial | undefined>;
}
declare class TextureEmissiveMapController extends BaseTextureMapController {
	protected node: TextureEmissiveMapMatNode;
	constructor(node: TextureEmissiveMapMatNode);
	initializeNode(): void;
	static update(node: TextureEmissiveMapMatNode): Promise<void>;
	update(): Promise<void>;
	updateMaterial(material: TextureEmissiveMapControllerCurrentMaterial): Promise<void>;
	getTextures(material: TextureEmissiveMapControllerCurrentMaterial, record: MaterialTexturesRecord): void;
	setParamsFromMaterial(material: TextureEmissiveMapControllerCurrentMaterial, record: SetParamsTextureNodesRecord): void;
}
declare const FlatShadingParamsConfig_base: {
	new (...args: any[]): {
		/** @param defines if the material is flat shaded */
		flatShading: ParamTemplate<ParamType.BOOLEAN>;
	};
} & typeof NodeParamsConfig;
declare class FlatShadingParamsConfig extends FlatShadingParamsConfig_base {
}
interface FlatShadingControllers {
	flatShading: FlatShadingController;
}
type FlatShadingControllerCurrentMaterial = MeshLambertMaterial | MeshMatcapMaterial | MeshNormalMaterial | MeshPhongMaterial | MeshStandardMaterial;
declare abstract class FlatShadingMapMatNode extends TypedMatNode<FlatShadingControllerCurrentMaterial, FlatShadingParamsConfig> {
	controllers: FlatShadingControllers;
	material(): Promise<FlatShadingControllerCurrentMaterial | undefined>;
}
declare class FlatShadingController extends BaseController {
	protected node: FlatShadingMapMatNode;
	constructor(node: FlatShadingMapMatNode);
	static update(node: FlatShadingMapMatNode): Promise<void>;
	updateMaterial(material: FlatShadingControllerCurrentMaterial): void;
	setParamsFromMaterial(material: FlatShadingControllerCurrentMaterial, record: SetParamsTextureNodesRecord): void;
}
interface MeshLambertControllers extends AdvancedCommonControllers, ColorsControllers, FogControllers, FlatShadingControllers, TextureAlphaMapControllers, TextureAOMapControllers, TextureEmissiveMapControllers, TextureEnvMapSimpleControllers, TextureLightMapControllers, TextureMapControllers, WireframeControllers {
}
declare const MeshLambertMatParamsConfig_base: {
	new (...args: any[]): {
		useFog: ParamTemplate<ParamType.BOOLEAN>;
	};
} & {
	new (...args: any[]): {
		wireframe: ParamTemplate<ParamType.BOOLEAN>;
		wireframeLinewidth: ParamTemplate<ParamType.FLOAT>;
		wireframeLinecap: ParamTemplate<ParamType.INTEGER>;
		wireframeLinejoin: ParamTemplate<ParamType.INTEGER>;
	};
} & {
	new (...args: any[]): {
		doubleSided: ParamTemplate<ParamType.BOOLEAN>;
		front: ParamTemplate<ParamType.BOOLEAN>;
		overrideShadowSide: ParamTemplate<ParamType.BOOLEAN>;
		shadowDoubleSided: ParamTemplate<ParamType.BOOLEAN>;
		shadowFront: ParamTemplate<ParamType.BOOLEAN>;
		colorWrite: ParamTemplate<ParamType.BOOLEAN>;
		depthWrite: ParamTemplate<ParamType.BOOLEAN>;
		depthTest: ParamTemplate<ParamType.BOOLEAN>;
		premultipliedAlpha: ParamTemplate<ParamType.BOOLEAN>;
		blending: ParamTemplate<ParamType.INTEGER>;
		dithering: ParamTemplate<ParamType.BOOLEAN>;
		polygonOffset: ParamTemplate<ParamType.BOOLEAN>;
		polygonOffsetFactor: ParamTemplate<ParamType.INTEGER>;
		polygonOffsetUnits: ParamTemplate<ParamType.INTEGER>;
	};
} & {
	new (...args: any[]): {
		flatShading: ParamTemplate<ParamType.BOOLEAN>;
	};
} & {
	new (...args: any[]): {
		advanced: ParamTemplate<ParamType.FOLDER>;
	};
} & {
	new (...args: any[]): {
		useLightMap: ParamTemplate<ParamType.BOOLEAN>;
		lightMap: ParamTemplate<ParamType.NODE_PATH>;
		lightMapIntensity: ParamTemplate<ParamType.FLOAT>;
	};
} & {
	new (...args: any[]): {
		useEnvMap: ParamTemplate<ParamType.BOOLEAN>;
		envMap: ParamTemplate<ParamType.NODE_PATH>;
		combine: ParamTemplate<ParamType.INTEGER>;
		reflectivity: ParamTemplate<ParamType.FLOAT>;
		refractionRatio: ParamTemplate<ParamType.FLOAT>;
	};
} & {
	new (...args: any[]): {
		emissive: ParamTemplate<ParamType.COLOR>;
		useEmissiveMap: ParamTemplate<ParamType.BOOLEAN>;
		emissiveMap: ParamTemplate<ParamType.NODE_PATH>;
		emissiveIntensity: ParamTemplate<ParamType.FLOAT>;
	};
} & {
	new (...args: any[]): {
		useAOMap: ParamTemplate<ParamType.BOOLEAN>;
		aoMap: ParamTemplate<ParamType.NODE_PATH>;
		aoMapIntensity: ParamTemplate<ParamType.FLOAT>;
	};
} & {
	new (...args: any[]): {
		useAlphaMap: ParamTemplate<ParamType.BOOLEAN>;
		alphaMap: ParamTemplate<ParamType.NODE_PATH>;
	};
} & {
	new (...args: any[]): {
		useMap: ParamTemplate<ParamType.BOOLEAN>;
		map: ParamTemplate<ParamType.NODE_PATH>;
	};
} & {
	new (...args: any[]): {
		textures: ParamTemplate<ParamType.FOLDER>;
	};
} & {
	new (...args: any[]): {
		color: ParamTemplate<ParamType.COLOR>;
		useVertexColors: ParamTemplate<ParamType.BOOLEAN>;
		transparent: ParamTemplate<ParamType.BOOLEAN>;
		opacity: ParamTemplate<ParamType.FLOAT>;
		alphaTest: ParamTemplate<ParamType.FLOAT>;
	};
} & {
	new (...args: any[]): {
		default: ParamTemplate<ParamType.FOLDER>;
	};
} & typeof NodeParamsConfig;
declare class MeshLambertMatParamsConfig extends MeshLambertMatParamsConfig_base {
}
declare class MeshLambertMatNode extends PrimitiveMatNode<MeshLambertMaterial, MeshLambertMatParamsConfig> {
	paramsConfig: MeshLambertMatParamsConfig;
	static type(): MatType.MESH_LAMBERT;
	createMaterial(): MeshLambertMaterial;
	readonly controllers: MeshLambertControllers;
	protected controllersList: any[];
	cook(): Promise<void>;
}
declare class ShaderAssemblerLambert extends ShaderAssemblerMesh {
	templateShader(): {
		vertexShader: string;
		fragmentShader: string;
		uniforms: {
			[uniform: string]: IUniform<any>;
		};
	};
	createMaterial(): MeshLambertMaterial;
}
declare const PCSSParamsConfig_base: {
	new (...args: any[]): {
		/** @param if on, the material will blur shadows cast on this object. Note that you should adjust the near parameter of the light shadow to get the result visible */
		shadowPCSS: ParamTemplate<ParamType.BOOLEAN>;
		/** @param shadowPCSSFilterSize PCSS Shadow filter size */
		shadowPCSSFilterSize: ParamTemplate<ParamType.FLOAT>;
	};
} & typeof NodeParamsConfig;
declare class PCSSParamsConfig extends PCSSParamsConfig_base {
}
interface PCSSControllers {
	PCSS: PCSSController;
}
declare abstract class PCSSMapMatNode extends TypedMatNode<Material, PCSSParamsConfig> {
	controllers: PCSSControllers;
	material(): Promise<Material | undefined>;
}
declare class PCSSController extends BaseController {
	protected node: PCSSMapMatNode;
	constructor(node: PCSSMapMatNode);
	static filterFragmentShader(node: PCSSMapMatNode, fragmentShader: string): string;
	static update(node: PCSSMapMatNode): Promise<void>;
	update(): Promise<void>;
	updateMaterial(material: Material): void;
	static PARAM_CALLBACK_setRecompileRequired(node: PCSSMapMatNode): void;
}
interface MeshLambertBuilderMaterial extends MeshLambertMaterial {
	vertexShader: string;
	fragmentShader: string;
	uniforms: IUniforms;
	customMaterials: {
		[key in CustomMaterialName]?: Material;
	};
}
interface MeshLambertBuilderControllers extends AdvancedCommonControllers, PCSSControllers, TextureAlphaMapControllers, TextureAOMapControllers, TextureEmissiveMapControllers, TextureEnvMapSimpleControllers, TextureLightMapControllers, TextureMapControllers, UniformFogControllers, UniformsTransparencyControllers, WireframeShaderMaterialControllers {
}
declare const MeshLambertBuilderMatParamsConfig_base: {
	new (...args: any[]): {
		overrideCustomMaterials: ParamTemplate<ParamType.BOOLEAN>;
		createCustomMatDistance: ParamTemplate<ParamType.BOOLEAN>;
		createCustomMatDepth: ParamTemplate<ParamType.BOOLEAN>;
		createCustomMatDepthDOF: ParamTemplate<ParamType.BOOLEAN>;
	};
} & {
	new (...args: any[]): {
		shadowPCSS: ParamTemplate<ParamType.BOOLEAN>;
		shadowPCSSFilterSize: ParamTemplate<ParamType.FLOAT>;
	};
} & {
	new (...args: any[]): {
		useFog: ParamTemplate<ParamType.BOOLEAN>;
	};
} & {
	new (...args: any[]): {
		wireframe: ParamTemplate<ParamType.BOOLEAN>;
		wireframeLinewidth: ParamTemplate<ParamType.FLOAT>;
	};
} & {
	new (...args: any[]): {
		doubleSided: ParamTemplate<ParamType.BOOLEAN>;
		front: ParamTemplate<ParamType.BOOLEAN>;
		overrideShadowSide: ParamTemplate<ParamType.BOOLEAN>;
		shadowDoubleSided: ParamTemplate<ParamType.BOOLEAN>;
		shadowFront: ParamTemplate<ParamType.BOOLEAN>;
		colorWrite: ParamTemplate<ParamType.BOOLEAN>;
		depthWrite: ParamTemplate<ParamType.BOOLEAN>;
		depthTest: ParamTemplate<ParamType.BOOLEAN>;
		premultipliedAlpha: ParamTemplate<ParamType.BOOLEAN>;
		blending: ParamTemplate<ParamType.INTEGER>;
		dithering: ParamTemplate<ParamType.BOOLEAN>;
		polygonOffset: ParamTemplate<ParamType.BOOLEAN>;
		polygonOffsetFactor: ParamTemplate<ParamType.INTEGER>;
		polygonOffsetUnits: ParamTemplate<ParamType.INTEGER>;
	};
} & {
	new (...args: any[]): {
		setBuilderNode: ParamTemplate<ParamType.BOOLEAN>;
		builderNode: ParamTemplate<ParamType.NODE_PATH>;
	};
} & {
	new (...args: any[]): {
		advanced: ParamTemplate<ParamType.FOLDER>;
	};
} & {
	new (...args: any[]): {
		useLightMap: ParamTemplate<ParamType.BOOLEAN>;
		lightMap: ParamTemplate<ParamType.NODE_PATH>;
		lightMapIntensity: ParamTemplate<ParamType.FLOAT>;
	};
} & {
	new (...args: any[]): {
		useEnvMap: ParamTemplate<ParamType.BOOLEAN>;
		envMap: ParamTemplate<ParamType.NODE_PATH>;
		combine: ParamTemplate<ParamType.INTEGER>;
		reflectivity: ParamTemplate<ParamType.FLOAT>;
		refractionRatio: ParamTemplate<ParamType.FLOAT>;
	};
} & {
	new (...args: any[]): {
		emissive: ParamTemplate<ParamType.COLOR>;
		useEmissiveMap: ParamTemplate<ParamType.BOOLEAN>;
		emissiveMap: ParamTemplate<ParamType.NODE_PATH>;
		emissiveIntensity: ParamTemplate<ParamType.FLOAT>;
	};
} & {
	new (...args: any[]): {
		useAOMap: ParamTemplate<ParamType.BOOLEAN>;
		aoMap: ParamTemplate<ParamType.NODE_PATH>;
		aoMapIntensity: ParamTemplate<ParamType.FLOAT>;
	};
} & {
	new (...args: any[]): {
		useAlphaMap: ParamTemplate<ParamType.BOOLEAN>;
		alphaMap: ParamTemplate<ParamType.NODE_PATH>;
	};
} & {
	new (...args: any[]): {
		useMap: ParamTemplate<ParamType.BOOLEAN>;
		map: ParamTemplate<ParamType.NODE_PATH>;
	};
} & {
	new (...args: any[]): {
		textures: ParamTemplate<ParamType.FOLDER>;
	};
} & {
	new (...args: any[]): {
		transparent: ParamTemplate<ParamType.BOOLEAN>;
		opacity: ParamTemplate<ParamType.FLOAT>;
		alphaTest: ParamTemplate<ParamType.FLOAT>;
	};
} & {
	new (...args: any[]): {
		default: ParamTemplate<ParamType.FOLDER>;
	};
} & typeof NodeParamsConfig;
declare class MeshLambertBuilderMatParamsConfig extends MeshLambertBuilderMatParamsConfig_base {
}
declare class MeshLambertBuilderMatNode extends TypedBuilderMatNode<MeshLambertBuilderMaterial, ShaderAssemblerLambert, MeshLambertBuilderMatParamsConfig> {
	paramsConfig: MeshLambertBuilderMatParamsConfig;
	static type(): MatType;
	usedAssembler(): Readonly<AssemblerName.GL_MESH_LAMBERT>;
	protected _createAssemblerController(): GlAssemblerController<ShaderAssemblerLambert> | undefined;
	customMaterialRequested(customName: CustomMaterialName): boolean;
	readonly controllers: MeshLambertBuilderControllers;
	protected controllersList: any[];
	cook(): Promise<void>;
}
type TextureBumpMapControllerCurrentMaterial = MeshMatcapMaterial | MeshNormalMaterial | MeshPhysicalMaterial | MeshStandardMaterial | MeshToonMaterial;
declare const TextureBumpMapParamsConfig_base: {
	new (...args: any[]): {
		/** @param toggle if you want to use a bump map */
		useBumpMap: ParamTemplate<ParamType.BOOLEAN>;
		/** @param specify the bump map COP node */
		bumpMap: ParamTemplate<ParamType.NODE_PATH>;
		/** @param bump scale */
		bumpScale: ParamTemplate<ParamType.FLOAT>;
		/** @param bump bias */
		bumpBias: ParamTemplate<ParamType.FLOAT>;
	};
} & typeof NodeParamsConfig;
declare class TextureBumpMapParamsConfig extends TextureBumpMapParamsConfig_base {
}
interface TextureBumpMapControllers {
	bumpMap: TextureBumpMapController;
}
declare abstract class TextureBumpMapMatNode extends TypedMatNode<TextureBumpMapControllerCurrentMaterial, TextureBumpMapParamsConfig> {
	controllers: TextureBumpMapControllers;
	material(): Promise<TextureBumpMapControllerCurrentMaterial | undefined>;
}
declare class TextureBumpMapController extends BaseTextureMapController {
	protected node: TextureBumpMapMatNode;
	constructor(node: TextureBumpMapMatNode);
	initializeNode(): void;
	static update(node: TextureBumpMapMatNode): Promise<void>;
	update(): Promise<void>;
	updateMaterial(material: TextureBumpMapControllerCurrentMaterial): Promise<void>;
	getTextures(material: TextureBumpMapControllerCurrentMaterial, record: MaterialTexturesRecord): void;
	setParamsFromMaterial(material: TextureBumpMapControllerCurrentMaterial, record: SetParamsTextureNodesRecord): void;
}
type TextureNormalMapControllerCurrentMaterial = MeshPhongMaterial | MeshNormalMaterial | MeshMatcapMaterial | MeshPhysicalMaterial | MeshToonMaterial | MeshStandardMaterial;
declare const TextureNormalMapParamsConfig_base: {
	new (...args: any[]): {
		/** @param toggle if you want to use a normal map */
		useNormalMap: ParamTemplate<ParamType.BOOLEAN>;
		/** @param specify the normal map COP node */
		normalMap: ParamTemplate<ParamType.NODE_PATH>;
		/** @param type of normal map being used */
		normalMapType: ParamTemplate<ParamType.INTEGER>;
		/** @param How much the normal map affects the material. Typical ranges are 0-1 */
		normalScale: ParamTemplate<ParamType.VECTOR2>;
		/** @param Normal Map Scale Multiplier, which multiples normalScale */
		normalScaleMult: ParamTemplate<ParamType.FLOAT>;
	};
} & typeof NodeParamsConfig;
declare class TextureNormalMapParamsConfig extends TextureNormalMapParamsConfig_base {
}
interface TextureNormalMapControllers {
	normalMap: TextureNormalMapController;
}
declare abstract class TextureNormalMapMatNode extends TypedMatNode<TextureNormalMapControllerCurrentMaterial, TextureNormalMapParamsConfig> {
	controllers: TextureNormalMapControllers;
	material(): Promise<TextureNormalMapControllerCurrentMaterial | undefined>;
}
declare class TextureNormalMapController extends BaseTextureMapController {
	protected node: TextureNormalMapMatNode;
	constructor(node: TextureNormalMapMatNode);
	initializeNode(): void;
	static update(node: TextureNormalMapMatNode): Promise<void>;
	update(): Promise<void>;
	updateMaterial(material: TextureNormalMapControllerCurrentMaterial): Promise<void>;
	getTextures(material: TextureNormalMapControllerCurrentMaterial, record: MaterialTexturesRecord): void;
	setParamsFromMaterial(material: TextureNormalMapControllerCurrentMaterial, record: SetParamsTextureNodesRecord): void;
}
type TextureDisplacementMapControllerCurrentMaterial = MeshMatcapMaterial | MeshNormalMaterial | MeshStandardMaterial | MeshPhysicalMaterial | MeshToonMaterial;
declare const TextureDisplacementMapParamsConfig_base: {
	new (...args: any[]): {
		/** @param toggle if you want to use a displacement map */
		useDisplacementMap: ParamTemplate<ParamType.BOOLEAN>;
		/** @param specify the displacement map COP node */
		displacementMap: ParamTemplate<ParamType.NODE_PATH>;
		/** @param displacement scale */
		displacementScale: ParamTemplate<ParamType.FLOAT>;
		/** @param displacement bias */
		displacementBias: ParamTemplate<ParamType.FLOAT>;
	};
} & typeof NodeParamsConfig;
declare class TextureDisplacementMapParamsConfig extends TextureDisplacementMapParamsConfig_base {
}
interface TextureDisplacementMapControllers {
	displacementMap: TextureDisplacementMapController;
}
declare abstract class TextureDisplacementMapMatNode extends TypedMatNode<TextureDisplacementMapControllerCurrentMaterial, TextureDisplacementMapParamsConfig> {
	controllers: TextureDisplacementMapControllers;
	material(): Promise<TextureDisplacementMapControllerCurrentMaterial | undefined>;
}
declare class TextureDisplacementMapController extends BaseTextureMapController {
	protected node: TextureDisplacementMapMatNode;
	constructor(node: TextureDisplacementMapMatNode);
	initializeNode(): void;
	static update(node: TextureDisplacementMapMatNode): Promise<void>;
	update(): Promise<void>;
	updateMaterial(material: TextureDisplacementMapControllerCurrentMaterial): Promise<void>;
	getTextures(material: TextureDisplacementMapControllerCurrentMaterial, record: MaterialTexturesRecord): void;
	setParamsFromMaterial(material: TextureDisplacementMapControllerCurrentMaterial, record: SetParamsTextureNodesRecord): void;
}
type TextureMatcapMaterial = MeshMatcapMaterial;
type TextureMatCapControllerCurrentMaterial = TextureMatcapMaterial;
declare const TextureMatcapMapParamsConfig_base: {
	new (...args: any[]): {
		/** @param toggle if you want to use a matcap map */
		useMatcapMap: ParamTemplate<ParamType.BOOLEAN>;
		/** @param specify the matcap map COP node */
		matcapMap: ParamTemplate<ParamType.NODE_PATH>;
	};
} & typeof NodeParamsConfig;
declare class TextureMatcapMapParamsConfig extends TextureMatcapMapParamsConfig_base {
}
interface TextureMatcapMapControllers {
	matcap: TextureMatcapMapController;
}
declare abstract class TextureMatcapMapMatNode extends TypedMatNode<TextureMatCapControllerCurrentMaterial, TextureMatcapMapParamsConfig> {
	controllers: TextureMatcapMapControllers;
	material(): Promise<MeshMatcapMaterial | undefined>;
}
declare class TextureMatcapMapController extends BaseTextureMapController {
	protected node: TextureMatcapMapMatNode;
	constructor(node: TextureMatcapMapMatNode);
	initializeNode(): void;
	static update(node: TextureMatcapMapMatNode): Promise<void>;
	update(): Promise<void>;
	updateMaterial(material: TextureMatCapControllerCurrentMaterial): Promise<void>;
	getTextures(material: TextureMatCapControllerCurrentMaterial, record: MaterialTexturesRecord): void;
	setParamsFromMaterial(material: TextureMatCapControllerCurrentMaterial, record: SetParamsTextureNodesRecord): void;
}
interface MeshMatCapControllers extends AdvancedCommonControllers, ColorsControllers, FogControllers, FlatShadingControllers, TextureAlphaMapControllers, TextureBumpMapControllers, TextureDisplacementMapControllers, TextureMapControllers, TextureMatcapMapControllers, TextureNormalMapControllers {
}
declare const MeshMatCapMatParamsConfig_base: {
	new (...args: any[]): {
		useFog: ParamTemplate<ParamType.BOOLEAN>;
	};
} & {
	new (...args: any[]): {
		doubleSided: ParamTemplate<ParamType.BOOLEAN>;
		front: ParamTemplate<ParamType.BOOLEAN>;
		overrideShadowSide: ParamTemplate<ParamType.BOOLEAN>;
		shadowDoubleSided: ParamTemplate<ParamType.BOOLEAN>;
		shadowFront: ParamTemplate<ParamType.BOOLEAN>;
		colorWrite: ParamTemplate<ParamType.BOOLEAN>;
		depthWrite: ParamTemplate<ParamType.BOOLEAN>;
		depthTest: ParamTemplate<ParamType.BOOLEAN>;
		premultipliedAlpha: ParamTemplate<ParamType.BOOLEAN>;
		blending: ParamTemplate<ParamType.INTEGER>;
		dithering: ParamTemplate<ParamType.BOOLEAN>;
		polygonOffset: ParamTemplate<ParamType.BOOLEAN>;
		polygonOffsetFactor: ParamTemplate<ParamType.INTEGER>;
		polygonOffsetUnits: ParamTemplate<ParamType.INTEGER>;
	};
} & {
	new (...args: any[]): {
		flatShading: ParamTemplate<ParamType.BOOLEAN>;
	};
} & {
	new (...args: any[]): {
		advanced: ParamTemplate<ParamType.FOLDER>;
	};
} & {
	new (...args: any[]): {
		useNormalMap: ParamTemplate<ParamType.BOOLEAN>;
		normalMap: ParamTemplate<ParamType.NODE_PATH>;
		normalMapType: ParamTemplate<ParamType.INTEGER>;
		normalScale: ParamTemplate<ParamType.VECTOR2>;
		normalScaleMult: ParamTemplate<ParamType.FLOAT>;
	};
} & {
	new (...args: any[]): {
		useDisplacementMap: ParamTemplate<ParamType.BOOLEAN>;
		displacementMap: ParamTemplate<ParamType.NODE_PATH>;
		displacementScale: ParamTemplate<ParamType.FLOAT>;
		displacementBias: ParamTemplate<ParamType.FLOAT>;
	};
} & {
	new (...args: any[]): {
		useBumpMap: ParamTemplate<ParamType.BOOLEAN>;
		bumpMap: ParamTemplate<ParamType.NODE_PATH>;
		bumpScale: ParamTemplate<ParamType.FLOAT>;
		bumpBias: ParamTemplate<ParamType.FLOAT>;
	};
} & {
	new (...args: any[]): {
		useAlphaMap: ParamTemplate<ParamType.BOOLEAN>;
		alphaMap: ParamTemplate<ParamType.NODE_PATH>;
	};
} & {
	new (...args: any[]): {
		useMap: ParamTemplate<ParamType.BOOLEAN>;
		map: ParamTemplate<ParamType.NODE_PATH>;
	};
} & {
	new (...args: any[]): {
		useMatcapMap: ParamTemplate<ParamType.BOOLEAN>;
		matcapMap: ParamTemplate<ParamType.NODE_PATH>;
	};
} & {
	new (...args: any[]): {
		textures: ParamTemplate<ParamType.FOLDER>;
	};
} & {
	new (...args: any[]): {
		color: ParamTemplate<ParamType.COLOR>;
		useVertexColors: ParamTemplate<ParamType.BOOLEAN>;
		transparent: ParamTemplate<ParamType.BOOLEAN>;
		opacity: ParamTemplate<ParamType.FLOAT>;
		alphaTest: ParamTemplate<ParamType.FLOAT>;
	};
} & {
	new (...args: any[]): {
		default: ParamTemplate<ParamType.FOLDER>;
	};
} & typeof NodeParamsConfig;
declare class MeshMatCapMatParamsConfig extends MeshMatCapMatParamsConfig_base {
}
declare class MeshMatcapMatNode extends PrimitiveMatNode<MeshMatcapMaterial, MeshMatCapMatParamsConfig> {
	paramsConfig: MeshMatCapMatParamsConfig;
	static type(): MatType.MESH_MATCAP;
	createMaterial(): MeshMatcapMaterial;
	readonly controllers: MeshMatCapControllers;
	protected controllersList: any[];
	cook(): Promise<void>;
}
interface MeshNormalControllers extends AdvancedCommonControllers, TextureBumpMapControllers, TextureDisplacementMapControllers, FlatShadingControllers, TextureNormalMapControllers {
}
declare const MeshNormalMatParamsConfig_base: {
	new (...args: any[]): {
		doubleSided: ParamTemplate<ParamType.BOOLEAN>;
		front: ParamTemplate<ParamType.BOOLEAN>;
		overrideShadowSide: ParamTemplate<ParamType.BOOLEAN>;
		shadowDoubleSided: ParamTemplate<ParamType.BOOLEAN>;
		shadowFront: ParamTemplate<ParamType.BOOLEAN>;
		colorWrite: ParamTemplate<ParamType.BOOLEAN>;
		depthWrite: ParamTemplate<ParamType.BOOLEAN>;
		depthTest: ParamTemplate<ParamType.BOOLEAN>;
		premultipliedAlpha: ParamTemplate<ParamType.BOOLEAN>;
		blending: ParamTemplate<ParamType.INTEGER>;
		dithering: ParamTemplate<ParamType.BOOLEAN>;
		polygonOffset: ParamTemplate<ParamType.BOOLEAN>;
		polygonOffsetFactor: ParamTemplate<ParamType.INTEGER>;
		polygonOffsetUnits: ParamTemplate<ParamType.INTEGER>;
	};
} & {
	new (...args: any[]): {
		flatShading: ParamTemplate<ParamType.BOOLEAN>;
	};
} & {
	new (...args: any[]): {
		useNormalMap: ParamTemplate<ParamType.BOOLEAN>;
		normalMap: ParamTemplate<ParamType.NODE_PATH>;
		normalMapType: ParamTemplate<ParamType.INTEGER>;
		normalScale: ParamTemplate<ParamType.VECTOR2>;
		normalScaleMult: ParamTemplate<ParamType.FLOAT>;
	};
} & {
	new (...args: any[]): {
		useDisplacementMap: ParamTemplate<ParamType.BOOLEAN>;
		displacementMap: ParamTemplate<ParamType.NODE_PATH>;
		displacementScale: ParamTemplate<ParamType.FLOAT>;
		displacementBias: ParamTemplate<ParamType.FLOAT>;
	};
} & {
	new (...args: any[]): {
		useBumpMap: ParamTemplate<ParamType.BOOLEAN>;
		bumpMap: ParamTemplate<ParamType.NODE_PATH>;
		bumpScale: ParamTemplate<ParamType.FLOAT>;
		bumpBias: ParamTemplate<ParamType.FLOAT>;
	};
} & {
	new (...args: any[]): {
		textures: ParamTemplate<ParamType.FOLDER>;
	};
} & {
	new (...args: any[]): {
		default: ParamTemplate<ParamType.FOLDER>;
	};
} & typeof NodeParamsConfig;
declare class MeshNormalMatParamsConfig extends MeshNormalMatParamsConfig_base {
}
declare class MeshNormalMatNode extends PrimitiveMatNode<MeshNormalMaterial, MeshNormalMatParamsConfig> {
	paramsConfig: MeshNormalMatParamsConfig;
	static type(): MatType.MESH_NORMAL;
	createMaterial(): MeshNormalMaterial;
	readonly controllers: MeshNormalControllers;
	protected controllersList: any[];
	cook(): Promise<void>;
}
type TextureSpecularMapControllerCurrentMaterial = MeshPhongMaterial;
declare const TextureSpecularMapParamsConfig_base: {
	new (...args: any[]): {
		/** @param toggle if you want to use a specular map */
		useSpecularMap: ParamTemplate<ParamType.BOOLEAN>;
		/** @param specify the specular map COP node */
		specularMap: ParamTemplate<ParamType.NODE_PATH>;
	};
} & typeof NodeParamsConfig;
declare class TextureSpecularMapParamsConfig extends TextureSpecularMapParamsConfig_base {
}
interface TextureSpecularMapControllers {
	specularMap: TextureSpecularMapController;
}
declare abstract class TextureSpecularMapMatNode extends TypedMatNode<TextureSpecularMapControllerCurrentMaterial, TextureSpecularMapParamsConfig> {
	controllers: TextureSpecularMapControllers;
}
declare class TextureSpecularMapController extends BaseTextureMapController {
	protected node: TextureSpecularMapMatNode;
	constructor(node: TextureSpecularMapMatNode);
	initializeNode(): void;
	static update(node: TextureSpecularMapMatNode): Promise<void>;
	update(): Promise<void>;
	updateMaterial(material: TextureSpecularMapControllerCurrentMaterial): Promise<void>;
	getTextures(material: TextureSpecularMapControllerCurrentMaterial, record: MaterialTexturesRecord): void;
	setParamsFromMaterial(material: TextureSpecularMapControllerCurrentMaterial, record: SetParamsTextureNodesRecord): void;
}
interface MeshPhongControllers extends AdvancedCommonControllers, ColorsControllers, FogControllers, FlatShadingControllers, TextureAlphaMapControllers, TextureAOMapControllers, TextureBumpMapControllers, TextureDisplacementMapControllers, TextureEmissiveMapControllers, TextureEnvMapSimpleControllers, TextureLightMapControllers, TextureMapControllers, TextureNormalMapControllers, TextureSpecularMapControllers, WireframeControllers {
}
declare const MeshPhongMatParamsConfig_base: {
	new (...args: any[]): {
		useFog: ParamTemplate<ParamType.BOOLEAN>;
	};
} & {
	new (...args: any[]): {
		wireframe: ParamTemplate<ParamType.BOOLEAN>;
		wireframeLinewidth: ParamTemplate<ParamType.FLOAT>;
		wireframeLinecap: ParamTemplate<ParamType.INTEGER>;
		wireframeLinejoin: ParamTemplate<ParamType.INTEGER>;
	};
} & {
	new (...args: any[]): {
		doubleSided: ParamTemplate<ParamType.BOOLEAN>;
		front: ParamTemplate<ParamType.BOOLEAN>;
		overrideShadowSide: ParamTemplate<ParamType.BOOLEAN>;
		shadowDoubleSided: ParamTemplate<ParamType.BOOLEAN>;
		shadowFront: ParamTemplate<ParamType.BOOLEAN>;
		colorWrite: ParamTemplate<ParamType.BOOLEAN>;
		depthWrite: ParamTemplate<ParamType.BOOLEAN>;
		depthTest: ParamTemplate<ParamType.BOOLEAN>;
		premultipliedAlpha: ParamTemplate<ParamType.BOOLEAN>;
		blending: ParamTemplate<ParamType.INTEGER>;
		dithering: ParamTemplate<ParamType.BOOLEAN>;
		polygonOffset: ParamTemplate<ParamType.BOOLEAN>;
		polygonOffsetFactor: ParamTemplate<ParamType.INTEGER>;
		polygonOffsetUnits: ParamTemplate<ParamType.INTEGER>;
	};
} & {
	new (...args: any[]): {
		flatShading: ParamTemplate<ParamType.BOOLEAN>;
	};
} & {
	new (...args: any[]): {
		advanced: ParamTemplate<ParamType.FOLDER>;
	};
} & {
	new (...args: any[]): {
		useSpecularMap: ParamTemplate<ParamType.BOOLEAN>;
		specularMap: ParamTemplate<ParamType.NODE_PATH>;
	};
} & {
	new (...args: any[]): {
		useNormalMap: ParamTemplate<ParamType.BOOLEAN>;
		normalMap: ParamTemplate<ParamType.NODE_PATH>;
		normalMapType: ParamTemplate<ParamType.INTEGER>;
		normalScale: ParamTemplate<ParamType.VECTOR2>;
		normalScaleMult: ParamTemplate<ParamType.FLOAT>;
	};
} & {
	new (...args: any[]): {
		useLightMap: ParamTemplate<ParamType.BOOLEAN>;
		lightMap: ParamTemplate<ParamType.NODE_PATH>;
		lightMapIntensity: ParamTemplate<ParamType.FLOAT>;
	};
} & {
	new (...args: any[]): {
		useEnvMap: ParamTemplate<ParamType.BOOLEAN>;
		envMap: ParamTemplate<ParamType.NODE_PATH>;
		combine: ParamTemplate<ParamType.INTEGER>;
		reflectivity: ParamTemplate<ParamType.FLOAT>;
		refractionRatio: ParamTemplate<ParamType.FLOAT>;
	};
} & {
	new (...args: any[]): {
		emissive: ParamTemplate<ParamType.COLOR>;
		useEmissiveMap: ParamTemplate<ParamType.BOOLEAN>;
		emissiveMap: ParamTemplate<ParamType.NODE_PATH>;
		emissiveIntensity: ParamTemplate<ParamType.FLOAT>;
	};
} & {
	new (...args: any[]): {
		useDisplacementMap: ParamTemplate<ParamType.BOOLEAN>;
		displacementMap: ParamTemplate<ParamType.NODE_PATH>;
		displacementScale: ParamTemplate<ParamType.FLOAT>;
		displacementBias: ParamTemplate<ParamType.FLOAT>;
	};
} & {
	new (...args: any[]): {
		useBumpMap: ParamTemplate<ParamType.BOOLEAN>;
		bumpMap: ParamTemplate<ParamType.NODE_PATH>;
		bumpScale: ParamTemplate<ParamType.FLOAT>;
		bumpBias: ParamTemplate<ParamType.FLOAT>;
	};
} & {
	new (...args: any[]): {
		useAOMap: ParamTemplate<ParamType.BOOLEAN>;
		aoMap: ParamTemplate<ParamType.NODE_PATH>;
		aoMapIntensity: ParamTemplate<ParamType.FLOAT>;
	};
} & {
	new (...args: any[]): {
		useAlphaMap: ParamTemplate<ParamType.BOOLEAN>;
		alphaMap: ParamTemplate<ParamType.NODE_PATH>;
	};
} & {
	new (...args: any[]): {
		useMap: ParamTemplate<ParamType.BOOLEAN>;
		map: ParamTemplate<ParamType.NODE_PATH>;
	};
} & {
	new (...args: any[]): {
		textures: ParamTemplate<ParamType.FOLDER>;
	};
} & {
	new (...args: any[]): {
		color: ParamTemplate<ParamType.COLOR>;
		useVertexColors: ParamTemplate<ParamType.BOOLEAN>;
		transparent: ParamTemplate<ParamType.BOOLEAN>;
		opacity: ParamTemplate<ParamType.FLOAT>;
		alphaTest: ParamTemplate<ParamType.FLOAT>;
	};
} & {
	new (...args: any[]): {
		default: ParamTemplate<ParamType.FOLDER>;
	};
} & typeof NodeParamsConfig;
declare class MeshPhongMatParamsConfig extends MeshPhongMatParamsConfig_base {
}
declare class MeshPhongMatNode extends PrimitiveMatNode<MeshPhongMaterial, MeshPhongMatParamsConfig> {
	paramsConfig: MeshPhongMatParamsConfig;
	static type(): MatType.MESH_PHONG;
	createMaterial(): MeshPhongMaterial;
	readonly controllers: MeshPhongControllers;
	protected controllersList: any[];
	cook(): Promise<void>;
}
declare class ShaderAssemblerPhong extends ShaderAssemblerMesh {
	templateShader(): {
		vertexShader: string;
		fragmentShader: string;
		uniforms: {
			[uniform: string]: IUniform<any>;
		};
	};
	createMaterial(): MeshPhongMaterial;
}
interface MeshPhongBuilderMaterial extends MeshPhongMaterial {
	vertexShader: string;
	fragmentShader: string;
	uniforms: IUniforms;
	customMaterials: {
		[key in CustomMaterialName]?: Material;
	};
}
interface MeshPhongBuilderControllers extends AdvancedCommonControllers, PCSSControllers, TextureAlphaMapControllers, TextureAOMapControllers, TextureBumpMapControllers, TextureDisplacementMapControllers, TextureEmissiveMapControllers, TextureEnvMapSimpleControllers, TextureLightMapControllers, TextureMapControllers, TextureNormalMapControllers, TextureSpecularMapControllers, UniformFogControllers, UniformsTransparencyControllers, WireframeShaderMaterialControllers {
}
declare const MeshPhongBuilderMatParamsConfig_base: {
	new (...args: any[]): {
		overrideCustomMaterials: ParamTemplate<ParamType.BOOLEAN>;
		createCustomMatDistance: ParamTemplate<ParamType.BOOLEAN>;
		createCustomMatDepth: ParamTemplate<ParamType.BOOLEAN>;
		createCustomMatDepthDOF: ParamTemplate<ParamType.BOOLEAN>;
	};
} & {
	new (...args: any[]): {
		shadowPCSS: ParamTemplate<ParamType.BOOLEAN>;
		shadowPCSSFilterSize: ParamTemplate<ParamType.FLOAT>;
	};
} & {
	new (...args: any[]): {
		useFog: ParamTemplate<ParamType.BOOLEAN>;
	};
} & {
	new (...args: any[]): {
		wireframe: ParamTemplate<ParamType.BOOLEAN>;
		wireframeLinewidth: ParamTemplate<ParamType.FLOAT>;
	};
} & {
	new (...args: any[]): {
		doubleSided: ParamTemplate<ParamType.BOOLEAN>;
		front: ParamTemplate<ParamType.BOOLEAN>;
		overrideShadowSide: ParamTemplate<ParamType.BOOLEAN>;
		shadowDoubleSided: ParamTemplate<ParamType.BOOLEAN>;
		shadowFront: ParamTemplate<ParamType.BOOLEAN>;
		colorWrite: ParamTemplate<ParamType.BOOLEAN>;
		depthWrite: ParamTemplate<ParamType.BOOLEAN>;
		depthTest: ParamTemplate<ParamType.BOOLEAN>;
		premultipliedAlpha: ParamTemplate<ParamType.BOOLEAN>;
		blending: ParamTemplate<ParamType.INTEGER>;
		dithering: ParamTemplate<ParamType.BOOLEAN>;
		polygonOffset: ParamTemplate<ParamType.BOOLEAN>;
		polygonOffsetFactor: ParamTemplate<ParamType.INTEGER>;
		polygonOffsetUnits: ParamTemplate<ParamType.INTEGER>;
	};
} & {
	new (...args: any[]): {
		setBuilderNode: ParamTemplate<ParamType.BOOLEAN>;
		builderNode: ParamTemplate<ParamType.NODE_PATH>;
	};
} & {
	new (...args: any[]): {
		advanced: ParamTemplate<ParamType.FOLDER>;
	};
} & {
	new (...args: any[]): {
		useSpecularMap: ParamTemplate<ParamType.BOOLEAN>;
		specularMap: ParamTemplate<ParamType.NODE_PATH>;
	};
} & {
	new (...args: any[]): {
		useNormalMap: ParamTemplate<ParamType.BOOLEAN>;
		normalMap: ParamTemplate<ParamType.NODE_PATH>;
		normalMapType: ParamTemplate<ParamType.INTEGER>;
		normalScale: ParamTemplate<ParamType.VECTOR2>;
		normalScaleMult: ParamTemplate<ParamType.FLOAT>;
	};
} & {
	new (...args: any[]): {
		useLightMap: ParamTemplate<ParamType.BOOLEAN>;
		lightMap: ParamTemplate<ParamType.NODE_PATH>;
		lightMapIntensity: ParamTemplate<ParamType.FLOAT>;
	};
} & {
	new (...args: any[]): {
		useEnvMap: ParamTemplate<ParamType.BOOLEAN>;
		envMap: ParamTemplate<ParamType.NODE_PATH>;
		combine: ParamTemplate<ParamType.INTEGER>;
		reflectivity: ParamTemplate<ParamType.FLOAT>;
		refractionRatio: ParamTemplate<ParamType.FLOAT>;
	};
} & {
	new (...args: any[]): {
		emissive: ParamTemplate<ParamType.COLOR>;
		useEmissiveMap: ParamTemplate<ParamType.BOOLEAN>;
		emissiveMap: ParamTemplate<ParamType.NODE_PATH>;
		emissiveIntensity: ParamTemplate<ParamType.FLOAT>;
	};
} & {
	new (...args: any[]): {
		useDisplacementMap: ParamTemplate<ParamType.BOOLEAN>;
		displacementMap: ParamTemplate<ParamType.NODE_PATH>;
		displacementScale: ParamTemplate<ParamType.FLOAT>;
		displacementBias: ParamTemplate<ParamType.FLOAT>;
	};
} & {
	new (...args: any[]): {
		useBumpMap: ParamTemplate<ParamType.BOOLEAN>;
		bumpMap: ParamTemplate<ParamType.NODE_PATH>;
		bumpScale: ParamTemplate<ParamType.FLOAT>;
		bumpBias: ParamTemplate<ParamType.FLOAT>;
	};
} & {
	new (...args: any[]): {
		useAOMap: ParamTemplate<ParamType.BOOLEAN>;
		aoMap: ParamTemplate<ParamType.NODE_PATH>;
		aoMapIntensity: ParamTemplate<ParamType.FLOAT>;
	};
} & {
	new (...args: any[]): {
		useAlphaMap: ParamTemplate<ParamType.BOOLEAN>;
		alphaMap: ParamTemplate<ParamType.NODE_PATH>;
	};
} & {
	new (...args: any[]): {
		useMap: ParamTemplate<ParamType.BOOLEAN>;
		map: ParamTemplate<ParamType.NODE_PATH>;
	};
} & {
	new (...args: any[]): {
		textures: ParamTemplate<ParamType.FOLDER>;
	};
} & {
	new (...args: any[]): {
		transparent: ParamTemplate<ParamType.BOOLEAN>;
		opacity: ParamTemplate<ParamType.FLOAT>;
		alphaTest: ParamTemplate<ParamType.FLOAT>;
	};
} & {
	new (...args: any[]): {
		default: ParamTemplate<ParamType.FOLDER>;
	};
} & typeof NodeParamsConfig;
declare class MeshPhongBuilderMatParamsConfig extends MeshPhongBuilderMatParamsConfig_base {
}
declare class MeshPhongBuilderMatNode extends TypedBuilderMatNode<MeshPhongBuilderMaterial, ShaderAssemblerPhong, MeshPhongBuilderMatParamsConfig> {
	paramsConfig: MeshPhongBuilderMatParamsConfig;
	static type(): MatType;
	usedAssembler(): Readonly<AssemblerName.GL_MESH_PHONG>;
	protected _createAssemblerController(): GlAssemblerController<ShaderAssemblerPhong> | undefined;
	customMaterialRequested(customName: CustomMaterialName): boolean;
	readonly controllers: MeshPhongBuilderControllers;
	protected controllersList: any[];
	cook(): Promise<void>;
}
type TextureMetalnessRoughnessCurrentMaterial = MeshStandardMaterial | MeshPhysicalMaterial;
declare const TextureMetalnessMapParamsConfig_base: {
	new (...args: any[]): {
		/** @param toggle if you want to use a metalness map */
		useMetalnessMap: ParamTemplate<ParamType.BOOLEAN>;
		/** @param specify the metalness map COP node */
		metalnessMap: ParamTemplate<ParamType.NODE_PATH>;
		/** @param metalness. It's recommended to either set this value to 0 or to 1, as objects are either metallic or not. Any value in between tends to look like an alien plastic */
		metalness: ParamTemplate<ParamType.FLOAT>;
		/** @param toggle if you want to use a roughness map */
		useRoughnessMap: ParamTemplate<ParamType.BOOLEAN>;
		/** @param specify the roughness map COP node */
		roughnessMap: ParamTemplate<ParamType.NODE_PATH>;
		/** @param roughness. When set to 0, reflections from environment maps will be very sharp, or blurred when 1. Any value between 0 and 1 can help modulate this. */
		roughness: ParamTemplate<ParamType.FLOAT>;
	};
} & typeof NodeParamsConfig;
declare class TextureMetalnessMapParamsConfig extends TextureMetalnessMapParamsConfig_base {
}
interface TextureMetalnessRoughnessMapControllers {
	metalnessRoughnessMap: TextureMetalnessRoughnessMapController;
}
declare abstract class TextureMetalnessMapMatNode extends TypedMatNode<TextureMetalnessRoughnessCurrentMaterial, TextureMetalnessMapParamsConfig> {
	controllers: TextureMetalnessRoughnessMapControllers;
	material(): Promise<TextureMetalnessRoughnessCurrentMaterial | undefined>;
}
declare class TextureMetalnessRoughnessMapController extends BaseTextureMapController {
	protected node: TextureMetalnessMapMatNode;
	constructor(node: TextureMetalnessMapMatNode);
	initializeNode(): void;
	static update(node: TextureMetalnessMapMatNode): Promise<void>;
	update(): Promise<void>;
	updateMaterial(material: TextureMetalnessRoughnessCurrentMaterial): Promise<void>;
	getTextures(material: TextureMetalnessRoughnessCurrentMaterial, record: MaterialTexturesRecord): void;
	setParamsFromMaterial(material: TextureMetalnessRoughnessCurrentMaterial, record: SetParamsTextureNodesRecord): void;
}
type MeshPhysicalControllerCurrentMaterial = MeshPhysicalMaterial;
declare const TextureClearCoatMapParamsConfig_base: {
	new (...args: any[]): {
		/** @param Represents the thickness of the clear coat layer, from 0.0 to 1.0 */
		clearcoat: ParamTemplate<ParamType.FLOAT>;
		/** @param toggle if you want to use a roughness map */
		useClearCoatMap: ParamTemplate<ParamType.BOOLEAN>;
		/** @param specify the roughness map COP node */
		clearcoatMap: ParamTemplate<ParamType.NODE_PATH>;
		/** @param toggle if you want to use a clear coat normal map */
		useClearCoatNormalMap: ParamTemplate<ParamType.BOOLEAN>;
		/** @param specify the roughness map COP node */
		clearcoatNormalMap: ParamTemplate<ParamType.NODE_PATH>;
		/** @param How much the normal map affects the material. Typical ranges are 0-1 */
		clearcoatNormalScale: ParamTemplate<ParamType.VECTOR2>;
		/** @param clearcoatRoughness */
		clearcoatRoughness: ParamTemplate<ParamType.FLOAT>;
		/** @param toggle if you want to use a clear cloat map */
		useClearCoatRoughnessMap: ParamTemplate<ParamType.BOOLEAN>;
		/** @param specify the roughness map COP node */
		clearcoatRoughnessMap: ParamTemplate<ParamType.NODE_PATH>;
		/** @param toggle if you want to use sheen */
		useSheen: ParamTemplate<ParamType.BOOLEAN>;
		/** @param The intensity of the sheen layer, from 0.0 to 1.0. Default is 0.0. */
		sheen: ParamTemplate<ParamType.FLOAT>;
		/** @param If a color is assigned to this property, the material will use a special sheen BRDF intended for rendering cloth materials such as velvet. The sheen color provides the ability to create two-tone specular materials. null by default */
		sheenRoughness: ParamTemplate<ParamType.FLOAT>;
		/** @param If a color is assigned to this property, the material will use a special sheen BRDF intended for rendering cloth materials such as velvet. The sheen color provides the ability to create two-tone specular materials. null by default */
		sheenColor: ParamTemplate<ParamType.COLOR>;
		/** @param toggle if you want to use iridescence */
		useIridescence: ParamTemplate<ParamType.BOOLEAN>;
		/** @param Iridescence amount */
		iridescence: ParamTemplate<ParamType.FLOAT>;
		/** @param iridescence index of refraction */
		iridescenceIOR: ParamTemplate<ParamType.FLOAT>;
		/** @param Iridescence Thickness Range */
		iridescenceThicknessRange: ParamTemplate<ParamType.VECTOR2>;
		/** @param toggle if you want to use an iridescence map */
		useIridescenceMap: ParamTemplate<ParamType.BOOLEAN>;
		/** @param specify the iridescence map COP node */
		iridescenceMap: ParamTemplate<ParamType.NODE_PATH>;
		/** @param toggle if you want to use an iridescence map */
		useIridescenceThicknessMap: ParamTemplate<ParamType.BOOLEAN>;
		/** @param specify the iridescence map COP node */
		iridescenceThicknessMap: ParamTemplate<ParamType.NODE_PATH>;
		/** @param Degree of transmission (or optical transparency), from 0.0 to 1.0. Default is 0.0.
Thin, transparent or semitransparent, plastic or glass materials remain largely reflective even if they are fully transmissive. The transmission property can be used to model these materials.
When transmission is non-zero, opacity should be set to 1.  */
		transmission: ParamTemplate<ParamType.FLOAT>;
		/** @param toggle if you want to use a transmission map */
		useTransmissionMap: ParamTemplate<ParamType.BOOLEAN>;
		/** @param specify the roughness map COP node */
		transmissionMap: ParamTemplate<ParamType.NODE_PATH>;
		/** @param Index-of-refraction for non-metallic materials */
		ior: ParamTemplate<ParamType.FLOAT>;
		/** @param thickness  */
		thickness: ParamTemplate<ParamType.FLOAT>;
		/** @param toggle if you want to use a thickness map */
		useThicknessMap: ParamTemplate<ParamType.BOOLEAN>;
		/** @param specify the roughness map COP node */
		thicknessMap: ParamTemplate<ParamType.NODE_PATH>;
		/** @param attenuation distance */
		attenuationDistance: ParamTemplate<ParamType.FLOAT>;
		/** @param attenuation color */
		attenuationColor: ParamTemplate<ParamType.COLOR>;
	};
} & typeof NodeParamsConfig;
declare class TextureClearCoatMapParamsConfig extends TextureClearCoatMapParamsConfig_base {
}
interface MeshPhysicalControllers {
	physical: MeshPhysicalController;
}
declare abstract class TextureClearCoatMapMatNode extends TypedMatNode<MeshPhysicalControllerCurrentMaterial, TextureClearCoatMapParamsConfig> {
	controllers: MeshPhysicalControllers;
	material(): Promise<MeshPhysicalMaterial | undefined>;
}
declare class MeshPhysicalController extends BaseTextureMapController {
	protected node: TextureClearCoatMapMatNode;
	constructor(node: TextureClearCoatMapMatNode);
	initializeNode(): void;
	private _sheenColorClone;
	private _iridescenceRange;
	static update(node: TextureClearCoatMapMatNode): Promise<void>;
	updateMaterial(material: MeshPhysicalControllerCurrentMaterial): Promise<void>;
	getTextures(material: MeshPhysicalControllerCurrentMaterial, record: MaterialTexturesRecord): void;
	setParamsFromMaterial(material: MeshPhysicalControllerCurrentMaterial, record: SetParamsTextureNodesRecord): void;
}
interface MeshPhysicalMatControllers extends AdvancedCommonControllers, ColorsControllers, TextureAlphaMapControllers, TextureAOMapControllers, TextureBumpMapControllers, TextureDisplacementMapControllers, TextureEmissiveMapControllers, TextureEnvMapControllers, TextureLightMapControllers, TextureMapControllers, TextureMetalnessRoughnessMapControllers, TextureNormalMapControllers, MeshPhysicalControllers, FogControllers, WireframeControllers {
}
declare const MeshPhysicalMatParamsConfig_base: {
	new (...args: any[]): {
		useFog: ParamTemplate<ParamType.BOOLEAN>;
	};
} & {
	new (...args: any[]): {
		wireframe: ParamTemplate<ParamType.BOOLEAN>;
		wireframeLinewidth: ParamTemplate<ParamType.FLOAT>;
		wireframeLinecap: ParamTemplate<ParamType.INTEGER>;
		wireframeLinejoin: ParamTemplate<ParamType.INTEGER>;
	};
} & {
	new (...args: any[]): {
		doubleSided: ParamTemplate<ParamType.BOOLEAN>;
		front: ParamTemplate<ParamType.BOOLEAN>;
		overrideShadowSide: ParamTemplate<ParamType.BOOLEAN>;
		shadowDoubleSided: ParamTemplate<ParamType.BOOLEAN>;
		shadowFront: ParamTemplate<ParamType.BOOLEAN>;
		colorWrite: ParamTemplate<ParamType.BOOLEAN>;
		depthWrite: ParamTemplate<ParamType.BOOLEAN>;
		depthTest: ParamTemplate<ParamType.BOOLEAN>;
		premultipliedAlpha: ParamTemplate<ParamType.BOOLEAN>;
		blending: ParamTemplate<ParamType.INTEGER>;
		dithering: ParamTemplate<ParamType.BOOLEAN>;
		polygonOffset: ParamTemplate<ParamType.BOOLEAN>;
		polygonOffsetFactor: ParamTemplate<ParamType.INTEGER>;
		polygonOffsetUnits: ParamTemplate<ParamType.INTEGER>;
	};
} & {
	new (...args: any[]): {
		advanced: ParamTemplate<ParamType.FOLDER>;
	};
} & {
	new (...args: any[]): {
		clearcoat: ParamTemplate<ParamType.FLOAT>;
		useClearCoatMap: ParamTemplate<ParamType.BOOLEAN>;
		clearcoatMap: ParamTemplate<ParamType.NODE_PATH>;
		useClearCoatNormalMap: ParamTemplate<ParamType.BOOLEAN>;
		clearcoatNormalMap: ParamTemplate<ParamType.NODE_PATH>;
		clearcoatNormalScale: ParamTemplate<ParamType.VECTOR2>;
		clearcoatRoughness: ParamTemplate<ParamType.FLOAT>;
		useClearCoatRoughnessMap: ParamTemplate<ParamType.BOOLEAN>;
		clearcoatRoughnessMap: ParamTemplate<ParamType.NODE_PATH>;
		useSheen: ParamTemplate<ParamType.BOOLEAN>;
		sheen: ParamTemplate<ParamType.FLOAT>;
		sheenRoughness: ParamTemplate<ParamType.FLOAT>;
		sheenColor: ParamTemplate<ParamType.COLOR>;
		useIridescence: ParamTemplate<ParamType.BOOLEAN>;
		iridescence: ParamTemplate<ParamType.FLOAT>;
		iridescenceIOR: ParamTemplate<ParamType.FLOAT>;
		iridescenceThicknessRange: ParamTemplate<ParamType.VECTOR2>;
		useIridescenceMap: ParamTemplate<ParamType.BOOLEAN>;
		iridescenceMap: ParamTemplate<ParamType.NODE_PATH>;
		useIridescenceThicknessMap: ParamTemplate<ParamType.BOOLEAN>;
		iridescenceThicknessMap: ParamTemplate<ParamType.NODE_PATH>;
		transmission: ParamTemplate<ParamType.FLOAT>;
		useTransmissionMap: ParamTemplate<ParamType.BOOLEAN>;
		transmissionMap: ParamTemplate<ParamType.NODE_PATH>;
		ior: ParamTemplate<ParamType.FLOAT>;
		thickness: ParamTemplate<ParamType.FLOAT>;
		useThicknessMap: ParamTemplate<ParamType.BOOLEAN>;
		thicknessMap: ParamTemplate<ParamType.NODE_PATH>;
		attenuationDistance: ParamTemplate<ParamType.FLOAT>;
		attenuationColor: ParamTemplate<ParamType.COLOR>;
	};
} & {
	new (...args: any[]): {
		useMetalnessMap: ParamTemplate<ParamType.BOOLEAN>;
		metalnessMap: ParamTemplate<ParamType.NODE_PATH>;
		metalness: ParamTemplate<ParamType.FLOAT>;
		useRoughnessMap: ParamTemplate<ParamType.BOOLEAN>;
		roughnessMap: ParamTemplate<ParamType.NODE_PATH>;
		roughness: ParamTemplate<ParamType.FLOAT>;
	};
} & {
	new (...args: any[]): {
		useNormalMap: ParamTemplate<ParamType.BOOLEAN>;
		normalMap: ParamTemplate<ParamType.NODE_PATH>;
		normalMapType: ParamTemplate<ParamType.INTEGER>;
		normalScale: ParamTemplate<ParamType.VECTOR2>;
		normalScaleMult: ParamTemplate<ParamType.FLOAT>;
	};
} & {
	new (...args: any[]): {
		useLightMap: ParamTemplate<ParamType.BOOLEAN>;
		lightMap: ParamTemplate<ParamType.NODE_PATH>;
		lightMapIntensity: ParamTemplate<ParamType.FLOAT>;
	};
} & {
	new (...args: any[]): {
		useEnvMap: ParamTemplate<ParamType.BOOLEAN>;
		envMap: ParamTemplate<ParamType.NODE_PATH>;
		envMapIntensity: ParamTemplate<ParamType.FLOAT>;
	};
} & {
	new (...args: any[]): {
		emissive: ParamTemplate<ParamType.COLOR>;
		useEmissiveMap: ParamTemplate<ParamType.BOOLEAN>;
		emissiveMap: ParamTemplate<ParamType.NODE_PATH>;
		emissiveIntensity: ParamTemplate<ParamType.FLOAT>;
	};
} & {
	new (...args: any[]): {
		useDisplacementMap: ParamTemplate<ParamType.BOOLEAN>;
		displacementMap: ParamTemplate<ParamType.NODE_PATH>;
		displacementScale: ParamTemplate<ParamType.FLOAT>;
		displacementBias: ParamTemplate<ParamType.FLOAT>;
	};
} & {
	new (...args: any[]): {
		useBumpMap: ParamTemplate<ParamType.BOOLEAN>;
		bumpMap: ParamTemplate<ParamType.NODE_PATH>;
		bumpScale: ParamTemplate<ParamType.FLOAT>;
		bumpBias: ParamTemplate<ParamType.FLOAT>;
	};
} & {
	new (...args: any[]): {
		useAOMap: ParamTemplate<ParamType.BOOLEAN>;
		aoMap: ParamTemplate<ParamType.NODE_PATH>;
		aoMapIntensity: ParamTemplate<ParamType.FLOAT>;
	};
} & {
	new (...args: any[]): {
		useAlphaMap: ParamTemplate<ParamType.BOOLEAN>;
		alphaMap: ParamTemplate<ParamType.NODE_PATH>;
	};
} & {
	new (...args: any[]): {
		useMap: ParamTemplate<ParamType.BOOLEAN>;
		map: ParamTemplate<ParamType.NODE_PATH>;
	};
} & {
	new (...args: any[]): {
		textures: ParamTemplate<ParamType.FOLDER>;
	};
} & {
	new (...args: any[]): {
		color: ParamTemplate<ParamType.COLOR>;
		useVertexColors: ParamTemplate<ParamType.BOOLEAN>;
		transparent: ParamTemplate<ParamType.BOOLEAN>;
		opacity: ParamTemplate<ParamType.FLOAT>;
		alphaTest: ParamTemplate<ParamType.FLOAT>;
	};
} & {
	new (...args: any[]): {
		default: ParamTemplate<ParamType.FOLDER>;
	};
} & typeof NodeParamsConfig;
declare class MeshPhysicalMatParamsConfig extends MeshPhysicalMatParamsConfig_base {
}
declare class MeshPhysicalMatNode extends PrimitiveMatNode<MeshPhysicalMaterial, MeshPhysicalMatParamsConfig> {
	paramsConfig: MeshPhysicalMatParamsConfig;
	static type(): MatType.MESH_PHYSICAL;
	createMaterial(): MeshPhysicalMaterial;
	readonly controllers: MeshPhysicalMatControllers;
	protected controllersList: any[];
	cook(): Promise<void>;
}
declare class ShaderAssemblerStandard extends ShaderAssemblerMesh {
	protected _gl_parent_node: AssemblerGlControllerNode;
	static USE_SSS: Readonly<boolean>;
	isPhysical(): boolean;
	constructor(_gl_parent_node: AssemblerGlControllerNode);
	templateShader(): {
		vertexShader: string;
		fragmentShader: string;
		uniforms: {
			[uniform: string]: IUniform<any>;
		};
	};
	static filterFragmentShader(fragmentShader: string): string;
	createMaterial(): any;
	add_output_inputs(output_child: OutputGlNode): void;
	create_shader_configs(): ShaderConfig[];
	create_variable_configs(): VariableConfig[];
}
declare class ShaderAssemblerPhysical extends ShaderAssemblerStandard {
	protected _gl_parent_node: AssemblerGlControllerNode;
	constructor(_gl_parent_node: AssemblerGlControllerNode);
	isPhysical(): boolean;
	static filterFragmentShader(fragmentShader: string): string;
	createMaterial(): any;
}
interface MeshPhysicalBuilderMaterial extends MeshPhysicalMaterial {
	vertexShader: string;
	fragmentShader: string;
	uniforms: IUniforms;
	customMaterials: {
		[key in CustomMaterialName]?: Material;
	};
}
interface MeshPhysicalBuilderControllers extends AdvancedCommonControllers, PCSSControllers, TextureAlphaMapControllers, TextureAOMapControllers, TextureBumpMapControllers, TextureDisplacementMapControllers, TextureEmissiveMapControllers, TextureEnvMapControllers, TextureLightMapControllers, TextureMapControllers, TextureMetalnessRoughnessMapControllers, TextureNormalMapControllers, MeshPhysicalControllers, UniformFogControllers, UniformsTransparencyControllers, WireframeShaderMaterialControllers {
}
declare const MeshPhysicalBuilderMatParamsConfig_base: {
	new (...args: any[]): {
		overrideCustomMaterials: ParamTemplate<ParamType.BOOLEAN>;
		createCustomMatDistance: ParamTemplate<ParamType.BOOLEAN>;
		createCustomMatDepth: ParamTemplate<ParamType.BOOLEAN>;
		createCustomMatDepthDOF: ParamTemplate<ParamType.BOOLEAN>;
	};
} & {
	new (...args: any[]): {
		shadowPCSS: ParamTemplate<ParamType.BOOLEAN>;
		shadowPCSSFilterSize: ParamTemplate<ParamType.FLOAT>;
		useFog: ParamTemplate<ParamType.BOOLEAN>;
		wireframe: ParamTemplate<ParamType.BOOLEAN>;
		wireframeLinewidth: ParamTemplate<ParamType.FLOAT>;
		doubleSided: ParamTemplate<ParamType.BOOLEAN>;
		front: ParamTemplate<ParamType.BOOLEAN>;
		overrideShadowSide: ParamTemplate<ParamType.BOOLEAN>;
		shadowDoubleSided: ParamTemplate<ParamType.BOOLEAN>;
		shadowFront: ParamTemplate<ParamType.BOOLEAN>;
		colorWrite: ParamTemplate<ParamType.BOOLEAN>;
		depthWrite: ParamTemplate<ParamType.BOOLEAN>;
		depthTest: ParamTemplate<ParamType.BOOLEAN>;
		premultipliedAlpha: ParamTemplate<ParamType.BOOLEAN>;
		blending: ParamTemplate<ParamType.INTEGER>;
		dithering: ParamTemplate<ParamType.BOOLEAN>;
		polygonOffset: ParamTemplate<ParamType.BOOLEAN>;
		polygonOffsetFactor: ParamTemplate<ParamType.INTEGER>;
		polygonOffsetUnits: ParamTemplate<ParamType.INTEGER>;
		setBuilderNode: ParamTemplate<ParamType.BOOLEAN>;
		builderNode: ParamTemplate<ParamType.NODE_PATH>;
	};
} & {
	new (...args: any[]): {
		advanced: ParamTemplate<ParamType.FOLDER>;
	};
} & {
	new (...args: any[]): {
		clearcoat: ParamTemplate<ParamType.FLOAT>;
		useClearCoatMap: ParamTemplate<ParamType.BOOLEAN>;
		clearcoatMap: ParamTemplate<ParamType.NODE_PATH>;
		useClearCoatNormalMap: ParamTemplate<ParamType.BOOLEAN>;
		clearcoatNormalMap: ParamTemplate<ParamType.NODE_PATH>;
		clearcoatNormalScale: ParamTemplate<ParamType.VECTOR2>;
		clearcoatRoughness: ParamTemplate<ParamType.FLOAT>;
		useClearCoatRoughnessMap: ParamTemplate<ParamType.BOOLEAN>;
		clearcoatRoughnessMap: ParamTemplate<ParamType.NODE_PATH>;
		useSheen: ParamTemplate<ParamType.BOOLEAN>;
		sheen: ParamTemplate<ParamType.FLOAT>;
		sheenRoughness: ParamTemplate<ParamType.FLOAT>;
		sheenColor: ParamTemplate<ParamType.COLOR>;
		useIridescence: ParamTemplate<ParamType.BOOLEAN>;
		iridescence: ParamTemplate<ParamType.FLOAT>;
		iridescenceIOR: ParamTemplate<ParamType.FLOAT>;
		iridescenceThicknessRange: ParamTemplate<ParamType.VECTOR2>;
		useIridescenceMap: ParamTemplate<ParamType.BOOLEAN>;
		iridescenceMap: ParamTemplate<ParamType.NODE_PATH>;
		useIridescenceThicknessMap: ParamTemplate<ParamType.BOOLEAN>;
		iridescenceThicknessMap: ParamTemplate<ParamType.NODE_PATH>;
		transmission: ParamTemplate<ParamType.FLOAT>;
		useTransmissionMap: ParamTemplate<ParamType.BOOLEAN>;
		transmissionMap: ParamTemplate<ParamType.NODE_PATH>;
		ior: ParamTemplate<ParamType.FLOAT>;
		thickness: ParamTemplate<ParamType.FLOAT>;
		useThicknessMap: ParamTemplate<ParamType.BOOLEAN>;
		thicknessMap: ParamTemplate<ParamType.NODE_PATH>;
		attenuationDistance: ParamTemplate<ParamType.FLOAT>;
		attenuationColor: ParamTemplate<ParamType.COLOR>;
	};
} & {
	new (...args: any[]): {
		useMetalnessMap: ParamTemplate<ParamType.BOOLEAN>;
		metalnessMap: ParamTemplate<ParamType.NODE_PATH>;
		metalness: ParamTemplate<ParamType.FLOAT>;
		useRoughnessMap: ParamTemplate<ParamType.BOOLEAN>;
		roughnessMap: ParamTemplate<ParamType.NODE_PATH>;
		roughness: ParamTemplate<ParamType.FLOAT>;
	};
} & {
	new (...args: any[]): {
		useNormalMap: ParamTemplate<ParamType.BOOLEAN>;
		normalMap: ParamTemplate<ParamType.NODE_PATH>;
		normalMapType: ParamTemplate<ParamType.INTEGER>;
		normalScale: ParamTemplate<ParamType.VECTOR2>;
		normalScaleMult: ParamTemplate<ParamType.FLOAT>;
	};
} & {
	new (...args: any[]): {
		useLightMap: ParamTemplate<ParamType.BOOLEAN>;
		lightMap: ParamTemplate<ParamType.NODE_PATH>;
		lightMapIntensity: ParamTemplate<ParamType.FLOAT>;
	};
} & {
	new (...args: any[]): {
		useEnvMap: ParamTemplate<ParamType.BOOLEAN>;
		envMap: ParamTemplate<ParamType.NODE_PATH>;
		envMapIntensity: ParamTemplate<ParamType.FLOAT>;
	};
} & {
	new (...args: any[]): {
		emissive: ParamTemplate<ParamType.COLOR>;
		useEmissiveMap: ParamTemplate<ParamType.BOOLEAN>;
		emissiveMap: ParamTemplate<ParamType.NODE_PATH>;
		emissiveIntensity: ParamTemplate<ParamType.FLOAT>;
	};
} & {
	new (...args: any[]): {
		useDisplacementMap: ParamTemplate<ParamType.BOOLEAN>;
		displacementMap: ParamTemplate<ParamType.NODE_PATH>;
		displacementScale: ParamTemplate<ParamType.FLOAT>;
		displacementBias: ParamTemplate<ParamType.FLOAT>;
	};
} & {
	new (...args: any[]): {
		useBumpMap: ParamTemplate<ParamType.BOOLEAN>;
		bumpMap: ParamTemplate<ParamType.NODE_PATH>;
		bumpScale: ParamTemplate<ParamType.FLOAT>;
		bumpBias: ParamTemplate<ParamType.FLOAT>;
	};
} & {
	new (...args: any[]): {
		useAOMap: ParamTemplate<ParamType.BOOLEAN>;
		aoMap: ParamTemplate<ParamType.NODE_PATH>;
		aoMapIntensity: ParamTemplate<ParamType.FLOAT>;
	};
} & {
	new (...args: any[]): {
		useAlphaMap: ParamTemplate<ParamType.BOOLEAN>;
		alphaMap: ParamTemplate<ParamType.NODE_PATH>;
	};
} & {
	new (...args: any[]): {
		useMap: ParamTemplate<ParamType.BOOLEAN>;
		map: ParamTemplate<ParamType.NODE_PATH>;
	};
} & {
	new (...args: any[]): {
		textures: ParamTemplate<ParamType.FOLDER>;
	};
} & {
	new (...args: any[]): {
		transparent: ParamTemplate<ParamType.BOOLEAN>;
		opacity: ParamTemplate<ParamType.FLOAT>;
		alphaTest: ParamTemplate<ParamType.FLOAT>;
	};
} & {
	new (...args: any[]): {
		default: ParamTemplate<ParamType.FOLDER>;
	};
} & typeof NodeParamsConfig;
declare class MeshPhysicalBuilderMatParamsConfig extends MeshPhysicalBuilderMatParamsConfig_base {
}
declare class MeshPhysicalBuilderMatNode extends TypedBuilderMatNode<MeshPhysicalBuilderMaterial, ShaderAssemblerPhysical, MeshPhysicalBuilderMatParamsConfig> {
	paramsConfig: MeshPhysicalBuilderMatParamsConfig;
	static type(): MatType;
	usedAssembler(): Readonly<AssemblerName.GL_MESH_PHYSICAL>;
	protected _createAssemblerController(): GlAssemblerController<ShaderAssemblerPhysical> | undefined;
	customMaterialRequested(customName: CustomMaterialName): boolean;
	readonly controllers: MeshPhysicalBuilderControllers;
	protected controllersList: any[];
	createMaterial(): MeshPhysicalBuilderMaterial;
	cook(): Promise<void>;
}
interface MeshStandardControllers extends AdvancedCommonControllers, ColorsControllers, FlatShadingControllers, FogControllers, TextureAlphaMapControllers, TextureAOMapControllers, TextureBumpMapControllers, TextureDisplacementMapControllers, TextureEmissiveMapControllers, TextureEnvMapControllers, TextureLightMapControllers, TextureMapControllers, TextureMetalnessRoughnessMapControllers, TextureNormalMapControllers, WireframeControllers {
}
declare const MeshStandardMatParamsConfig_base: {
	new (...args: any[]): {
		useFog: ParamTemplate<ParamType.BOOLEAN>;
	};
} & {
	new (...args: any[]): {
		wireframe: ParamTemplate<ParamType.BOOLEAN>;
		wireframeLinewidth: ParamTemplate<ParamType.FLOAT>;
		wireframeLinecap: ParamTemplate<ParamType.INTEGER>;
		wireframeLinejoin: ParamTemplate<ParamType.INTEGER>;
	};
} & {
	new (...args: any[]): {
		doubleSided: ParamTemplate<ParamType.BOOLEAN>;
		front: ParamTemplate<ParamType.BOOLEAN>;
		overrideShadowSide: ParamTemplate<ParamType.BOOLEAN>;
		shadowDoubleSided: ParamTemplate<ParamType.BOOLEAN>;
		shadowFront: ParamTemplate<ParamType.BOOLEAN>;
		colorWrite: ParamTemplate<ParamType.BOOLEAN>;
		depthWrite: ParamTemplate<ParamType.BOOLEAN>;
		depthTest: ParamTemplate<ParamType.BOOLEAN>;
		premultipliedAlpha: ParamTemplate<ParamType.BOOLEAN>;
		blending: ParamTemplate<ParamType.INTEGER>;
		dithering: ParamTemplate<ParamType.BOOLEAN>;
		polygonOffset: ParamTemplate<ParamType.BOOLEAN>;
		polygonOffsetFactor: ParamTemplate<ParamType.INTEGER>;
		polygonOffsetUnits: ParamTemplate<ParamType.INTEGER>;
	};
} & {
	new (...args: any[]): {
		flatShading: ParamTemplate<ParamType.BOOLEAN>;
	};
} & {
	new (...args: any[]): {
		advanced: ParamTemplate<ParamType.FOLDER>;
	};
} & {
	new (...args: any[]): {
		useMetalnessMap: ParamTemplate<ParamType.BOOLEAN>;
		metalnessMap: ParamTemplate<ParamType.NODE_PATH>;
		metalness: ParamTemplate<ParamType.FLOAT>;
		useRoughnessMap: ParamTemplate<ParamType.BOOLEAN>;
		roughnessMap: ParamTemplate<ParamType.NODE_PATH>;
		roughness: ParamTemplate<ParamType.FLOAT>;
	};
} & {
	new (...args: any[]): {
		useNormalMap: ParamTemplate<ParamType.BOOLEAN>;
		normalMap: ParamTemplate<ParamType.NODE_PATH>;
		normalMapType: ParamTemplate<ParamType.INTEGER>;
		normalScale: ParamTemplate<ParamType.VECTOR2>;
		normalScaleMult: ParamTemplate<ParamType.FLOAT>;
	};
} & {
	new (...args: any[]): {
		useLightMap: ParamTemplate<ParamType.BOOLEAN>;
		lightMap: ParamTemplate<ParamType.NODE_PATH>;
		lightMapIntensity: ParamTemplate<ParamType.FLOAT>;
	};
} & {
	new (...args: any[]): {
		useEnvMap: ParamTemplate<ParamType.BOOLEAN>;
		envMap: ParamTemplate<ParamType.NODE_PATH>;
		envMapIntensity: ParamTemplate<ParamType.FLOAT>;
	};
} & {
	new (...args: any[]): {
		emissive: ParamTemplate<ParamType.COLOR>;
		useEmissiveMap: ParamTemplate<ParamType.BOOLEAN>;
		emissiveMap: ParamTemplate<ParamType.NODE_PATH>;
		emissiveIntensity: ParamTemplate<ParamType.FLOAT>;
	};
} & {
	new (...args: any[]): {
		useDisplacementMap: ParamTemplate<ParamType.BOOLEAN>;
		displacementMap: ParamTemplate<ParamType.NODE_PATH>;
		displacementScale: ParamTemplate<ParamType.FLOAT>;
		displacementBias: ParamTemplate<ParamType.FLOAT>;
	};
} & {
	new (...args: any[]): {
		useBumpMap: ParamTemplate<ParamType.BOOLEAN>;
		bumpMap: ParamTemplate<ParamType.NODE_PATH>;
		bumpScale: ParamTemplate<ParamType.FLOAT>;
		bumpBias: ParamTemplate<ParamType.FLOAT>;
	};
} & {
	new (...args: any[]): {
		useAOMap: ParamTemplate<ParamType.BOOLEAN>;
		aoMap: ParamTemplate<ParamType.NODE_PATH>;
		aoMapIntensity: ParamTemplate<ParamType.FLOAT>;
	};
} & {
	new (...args: any[]): {
		useAlphaMap: ParamTemplate<ParamType.BOOLEAN>;
		alphaMap: ParamTemplate<ParamType.NODE_PATH>;
	};
} & {
	new (...args: any[]): {
		useMap: ParamTemplate<ParamType.BOOLEAN>;
		map: ParamTemplate<ParamType.NODE_PATH>;
	};
} & {
	new (...args: any[]): {
		textures: ParamTemplate<ParamType.FOLDER>;
	};
} & {
	new (...args: any[]): {
		color: ParamTemplate<ParamType.COLOR>;
		useVertexColors: ParamTemplate<ParamType.BOOLEAN>;
		transparent: ParamTemplate<ParamType.BOOLEAN>;
		opacity: ParamTemplate<ParamType.FLOAT>;
		alphaTest: ParamTemplate<ParamType.FLOAT>;
	};
} & {
	new (...args: any[]): {
		default: ParamTemplate<ParamType.FOLDER>;
	};
} & typeof NodeParamsConfig;
declare class MeshStandardMatParamsConfig extends MeshStandardMatParamsConfig_base {
}
declare class MeshStandardMatNode extends PrimitiveMatNode<MeshStandardMaterial, MeshStandardMatParamsConfig> {
	paramsConfig: MeshStandardMatParamsConfig;
	static type(): MatType.MESH_STANDARD;
	createMaterial(): MeshStandardMaterial;
	readonly controllers: MeshStandardControllers;
	protected controllersList: any[];
	cook(): Promise<void>;
}
interface MeshStandardBuilderControllers extends AdvancedCommonControllers, PCSSControllers, TextureAlphaMapControllers, TextureAOMapControllers, TextureBumpMapControllers, TextureDisplacementMapControllers, TextureEmissiveMapControllers, TextureEnvMapControllers, TextureLightMapControllers, TextureMapControllers, TextureMetalnessRoughnessMapControllers, TextureNormalMapControllers, UniformFogControllers, UniformsTransparencyControllers, WireframeShaderMaterialControllers {
}
interface MeshStandardBuilderMaterial extends MeshStandardMaterial {
	vertexShader: string;
	fragmentShader: string;
	uniforms: IUniforms;
	customMaterials: {
		[key in CustomMaterialName]?: Material;
	};
}
declare const MeshStandardBuilderMatParamsConfig_base: {
	new (...args: any[]): {
		overrideCustomMaterials: ParamTemplate<ParamType.BOOLEAN>;
		createCustomMatDistance: ParamTemplate<ParamType.BOOLEAN>;
		createCustomMatDepth: ParamTemplate<ParamType.BOOLEAN>;
		createCustomMatDepthDOF: ParamTemplate<ParamType.BOOLEAN>;
	};
} & {
	new (...args: any[]): {
		shadowPCSS: ParamTemplate<ParamType.BOOLEAN>;
		shadowPCSSFilterSize: ParamTemplate<ParamType.FLOAT>;
	};
} & {
	new (...args: any[]): {
		useFog: ParamTemplate<ParamType.BOOLEAN>;
	};
} & {
	new (...args: any[]): {
		wireframe: ParamTemplate<ParamType.BOOLEAN>;
		wireframeLinewidth: ParamTemplate<ParamType.FLOAT>;
	};
} & {
	new (...args: any[]): {
		doubleSided: ParamTemplate<ParamType.BOOLEAN>;
		front: ParamTemplate<ParamType.BOOLEAN>;
		overrideShadowSide: ParamTemplate<ParamType.BOOLEAN>;
		shadowDoubleSided: ParamTemplate<ParamType.BOOLEAN>;
		shadowFront: ParamTemplate<ParamType.BOOLEAN>;
		colorWrite: ParamTemplate<ParamType.BOOLEAN>;
		depthWrite: ParamTemplate<ParamType.BOOLEAN>;
		depthTest: ParamTemplate<ParamType.BOOLEAN>;
		premultipliedAlpha: ParamTemplate<ParamType.BOOLEAN>;
		blending: ParamTemplate<ParamType.INTEGER>;
		dithering: ParamTemplate<ParamType.BOOLEAN>;
		polygonOffset: ParamTemplate<ParamType.BOOLEAN>;
		polygonOffsetFactor: ParamTemplate<ParamType.INTEGER>;
		polygonOffsetUnits: ParamTemplate<ParamType.INTEGER>;
	};
} & {
	new (...args: any[]): {
		setBuilderNode: ParamTemplate<ParamType.BOOLEAN>;
		builderNode: ParamTemplate<ParamType.NODE_PATH>;
	};
} & {
	new (...args: any[]): {
		advanced: ParamTemplate<ParamType.FOLDER>;
	};
} & {
	new (...args: any[]): {
		useMetalnessMap: ParamTemplate<ParamType.BOOLEAN>;
		metalnessMap: ParamTemplate<ParamType.NODE_PATH>;
		metalness: ParamTemplate<ParamType.FLOAT>;
		useRoughnessMap: ParamTemplate<ParamType.BOOLEAN>;
		roughnessMap: ParamTemplate<ParamType.NODE_PATH>;
		roughness: ParamTemplate<ParamType.FLOAT>;
	};
} & {
	new (...args: any[]): {
		useNormalMap: ParamTemplate<ParamType.BOOLEAN>;
		normalMap: ParamTemplate<ParamType.NODE_PATH>;
		normalMapType: ParamTemplate<ParamType.INTEGER>;
		normalScale: ParamTemplate<ParamType.VECTOR2>;
		normalScaleMult: ParamTemplate<ParamType.FLOAT>;
	};
} & {
	new (...args: any[]): {
		useLightMap: ParamTemplate<ParamType.BOOLEAN>;
		lightMap: ParamTemplate<ParamType.NODE_PATH>;
		lightMapIntensity: ParamTemplate<ParamType.FLOAT>;
	};
} & {
	new (...args: any[]): {
		useEnvMap: ParamTemplate<ParamType.BOOLEAN>;
		envMap: ParamTemplate<ParamType.NODE_PATH>;
		envMapIntensity: ParamTemplate<ParamType.FLOAT>;
	};
} & {
	new (...args: any[]): {
		emissive: ParamTemplate<ParamType.COLOR>;
		useEmissiveMap: ParamTemplate<ParamType.BOOLEAN>;
		emissiveMap: ParamTemplate<ParamType.NODE_PATH>;
		emissiveIntensity: ParamTemplate<ParamType.FLOAT>;
	};
} & {
	new (...args: any[]): {
		useDisplacementMap: ParamTemplate<ParamType.BOOLEAN>;
		displacementMap: ParamTemplate<ParamType.NODE_PATH>;
		displacementScale: ParamTemplate<ParamType.FLOAT>;
		displacementBias: ParamTemplate<ParamType.FLOAT>;
	};
} & {
	new (...args: any[]): {
		useBumpMap: ParamTemplate<ParamType.BOOLEAN>;
		bumpMap: ParamTemplate<ParamType.NODE_PATH>;
		bumpScale: ParamTemplate<ParamType.FLOAT>;
		bumpBias: ParamTemplate<ParamType.FLOAT>;
	};
} & {
	new (...args: any[]): {
		useAOMap: ParamTemplate<ParamType.BOOLEAN>;
		aoMap: ParamTemplate<ParamType.NODE_PATH>;
		aoMapIntensity: ParamTemplate<ParamType.FLOAT>;
	};
} & {
	new (...args: any[]): {
		useAlphaMap: ParamTemplate<ParamType.BOOLEAN>;
		alphaMap: ParamTemplate<ParamType.NODE_PATH>;
	};
} & {
	new (...args: any[]): {
		useMap: ParamTemplate<ParamType.BOOLEAN>;
		map: ParamTemplate<ParamType.NODE_PATH>;
	};
} & {
	new (...args: any[]): {
		textures: ParamTemplate<ParamType.FOLDER>;
	};
} & {
	new (...args: any[]): {
		transparent: ParamTemplate<ParamType.BOOLEAN>;
		opacity: ParamTemplate<ParamType.FLOAT>;
		alphaTest: ParamTemplate<ParamType.FLOAT>;
	};
} & {
	new (...args: any[]): {
		default: ParamTemplate<ParamType.FOLDER>;
	};
} & typeof NodeParamsConfig;
declare class MeshStandardBuilderMatParamsConfig extends MeshStandardBuilderMatParamsConfig_base {
}
declare class MeshStandardBuilderMatNode extends TypedBuilderMatNode<MeshStandardBuilderMaterial, ShaderAssemblerStandard, MeshStandardBuilderMatParamsConfig> {
	paramsConfig: MeshStandardBuilderMatParamsConfig;
	static type(): MatType;
	usedAssembler(): Readonly<AssemblerName.GL_MESH_STANDARD>;
	protected _createAssemblerController(): GlAssemblerController<ShaderAssemblerStandard> | undefined;
	customMaterialRequested(customName: CustomMaterialName): boolean;
	readonly controllers: MeshStandardBuilderControllers;
	protected controllersList: any[];
	cook(): Promise<void>;
}
type TextureGradientMaterial = MeshToonMaterial;
type TextureGradientMapCurrentMaterial = TextureGradientMaterial;
declare const TextureGradientMapParamsConfig_base: {
	new (...args: any[]): {
		/** @param toggle if you want to use a gradient map */
		useGradientMap: ParamTemplate<ParamType.BOOLEAN>;
		/** Gradient map for toon shading. It's required to set Texture.minFilter and Texture.magFilter to NearestFilter when using this type of texture */
		gradientMap: ParamTemplate<ParamType.NODE_PATH>;
	};
} & typeof NodeParamsConfig;
declare class TextureGradientMapParamsConfig extends TextureGradientMapParamsConfig_base {
}
interface TextureGradientMapControllers {
	gradientMap: TextureGradientMapController;
}
declare abstract class TextureGradientMapMatNode extends TypedMatNode<TextureGradientMapCurrentMaterial, TextureGradientMapParamsConfig> {
	controllers: TextureGradientMapControllers;
	material(): Promise<MeshToonMaterial | undefined>;
}
declare class TextureGradientMapController extends BaseTextureMapController {
	protected node: TextureGradientMapMatNode;
	constructor(node: TextureGradientMapMatNode);
	initializeNode(): void;
	static update(node: TextureGradientMapMatNode): Promise<void>;
	update(): Promise<void>;
	updateMaterial(material: TextureGradientMapCurrentMaterial): Promise<void>;
	getTextures(material: TextureGradientMapCurrentMaterial, record: MaterialTexturesRecord): void;
	setParamsFromMaterial(material: TextureGradientMapCurrentMaterial, record: SetParamsTextureNodesRecord): void;
}
interface MeshToonControllers extends AdvancedCommonControllers, ColorsControllers, FogControllers, TextureAlphaMapControllers, TextureAOMapControllers, TextureBumpMapControllers, TextureDisplacementMapControllers, TextureEmissiveMapControllers, TextureGradientMapControllers, TextureLightMapControllers, TextureMapControllers, TextureNormalMapControllers, WireframeControllers {
}
declare const MeshToonMatParamsConfig_base: {
	new (...args: any[]): {
		useFog: ParamTemplate<ParamType.BOOLEAN>;
	};
} & {
	new (...args: any[]): {
		wireframe: ParamTemplate<ParamType.BOOLEAN>;
		wireframeLinewidth: ParamTemplate<ParamType.FLOAT>;
		wireframeLinecap: ParamTemplate<ParamType.INTEGER>;
		wireframeLinejoin: ParamTemplate<ParamType.INTEGER>;
	};
} & {
	new (...args: any[]): {
		doubleSided: ParamTemplate<ParamType.BOOLEAN>;
		front: ParamTemplate<ParamType.BOOLEAN>;
		overrideShadowSide: ParamTemplate<ParamType.BOOLEAN>;
		shadowDoubleSided: ParamTemplate<ParamType.BOOLEAN>;
		shadowFront: ParamTemplate<ParamType.BOOLEAN>;
		colorWrite: ParamTemplate<ParamType.BOOLEAN>;
		depthWrite: ParamTemplate<ParamType.BOOLEAN>;
		depthTest: ParamTemplate<ParamType.BOOLEAN>;
		premultipliedAlpha: ParamTemplate<ParamType.BOOLEAN>;
		blending: ParamTemplate<ParamType.INTEGER>;
		dithering: ParamTemplate<ParamType.BOOLEAN>;
		polygonOffset: ParamTemplate<ParamType.BOOLEAN>;
		polygonOffsetFactor: ParamTemplate<ParamType.INTEGER>;
		polygonOffsetUnits: ParamTemplate<ParamType.INTEGER>;
	};
} & {
	new (...args: any[]): {
		advanced: ParamTemplate<ParamType.FOLDER>;
	};
} & {
	new (...args: any[]): {
		useNormalMap: ParamTemplate<ParamType.BOOLEAN>;
		normalMap: ParamTemplate<ParamType.NODE_PATH>;
		normalMapType: ParamTemplate<ParamType.INTEGER>;
		normalScale: ParamTemplate<ParamType.VECTOR2>;
		normalScaleMult: ParamTemplate<ParamType.FLOAT>;
	};
} & {
	new (...args: any[]): {
		useLightMap: ParamTemplate<ParamType.BOOLEAN>;
		lightMap: ParamTemplate<ParamType.NODE_PATH>;
		lightMapIntensity: ParamTemplate<ParamType.FLOAT>;
	};
} & {
	new (...args: any[]): {
		useGradientMap: ParamTemplate<ParamType.BOOLEAN>;
		gradientMap: ParamTemplate<ParamType.NODE_PATH>;
	};
} & {
	new (...args: any[]): {
		emissive: ParamTemplate<ParamType.COLOR>;
		useEmissiveMap: ParamTemplate<ParamType.BOOLEAN>;
		emissiveMap: ParamTemplate<ParamType.NODE_PATH>;
		emissiveIntensity: ParamTemplate<ParamType.FLOAT>;
	};
} & {
	new (...args: any[]): {
		useDisplacementMap: ParamTemplate<ParamType.BOOLEAN>;
		displacementMap: ParamTemplate<ParamType.NODE_PATH>;
		displacementScale: ParamTemplate<ParamType.FLOAT>;
		displacementBias: ParamTemplate<ParamType.FLOAT>;
	};
} & {
	new (...args: any[]): {
		useBumpMap: ParamTemplate<ParamType.BOOLEAN>;
		bumpMap: ParamTemplate<ParamType.NODE_PATH>;
		bumpScale: ParamTemplate<ParamType.FLOAT>;
		bumpBias: ParamTemplate<ParamType.FLOAT>;
	};
} & {
	new (...args: any[]): {
		useAOMap: ParamTemplate<ParamType.BOOLEAN>;
		aoMap: ParamTemplate<ParamType.NODE_PATH>;
		aoMapIntensity: ParamTemplate<ParamType.FLOAT>;
	};
} & {
	new (...args: any[]): {
		useAlphaMap: ParamTemplate<ParamType.BOOLEAN>;
		alphaMap: ParamTemplate<ParamType.NODE_PATH>;
	};
} & {
	new (...args: any[]): {
		useMap: ParamTemplate<ParamType.BOOLEAN>;
		map: ParamTemplate<ParamType.NODE_PATH>;
	};
} & {
	new (...args: any[]): {
		textures: ParamTemplate<ParamType.FOLDER>;
	};
} & {
	new (...args: any[]): {
		color: ParamTemplate<ParamType.COLOR>;
		useVertexColors: ParamTemplate<ParamType.BOOLEAN>;
		transparent: ParamTemplate<ParamType.BOOLEAN>;
		opacity: ParamTemplate<ParamType.FLOAT>;
		alphaTest: ParamTemplate<ParamType.FLOAT>;
	};
} & {
	new (...args: any[]): {
		default: ParamTemplate<ParamType.FOLDER>;
	};
} & typeof NodeParamsConfig;
declare class MeshToonMatParamsConfig extends MeshToonMatParamsConfig_base {
}
declare class MeshToonMatNode extends PrimitiveMatNode<MeshToonMaterial, MeshToonMatParamsConfig> {
	paramsConfig: MeshToonMatParamsConfig;
	static type(): MatType.MESH_TOON;
	createMaterial(): MeshToonMaterial;
	readonly controllers: MeshToonControllers;
	private controllerNames;
	initializeNode(): void;
	cook(): Promise<void>;
}
declare class ShaderAssemblerToon extends ShaderAssemblerMesh {
	templateShader(): {
		vertexShader: string;
		fragmentShader: string;
		uniforms: {
			[uniform: string]: IUniform<any>;
		};
	};
	createMaterial(): MeshToonMaterial;
}
interface MeshToonBuilderMaterial extends MeshToonMaterial {
	vertexShader: string;
	fragmentShader: string;
	uniforms: IUniforms;
	customMaterials: {
		[key in CustomMaterialName]?: Material;
	};
}
interface MeshToonBuilderControllers extends AdvancedCommonControllers, PCSSControllers, TextureAlphaMapControllers, TextureAOMapControllers, TextureBumpMapControllers, TextureDisplacementMapControllers, TextureEmissiveMapControllers, TextureGradientMapControllers, TextureLightMapControllers, TextureMapControllers, TextureNormalMapControllers, UniformFogControllers, UniformsTransparencyControllers, WireframeShaderMaterialControllers {
}
declare const MeshToonBuilderMatParamsConfig_base: {
	new (...args: any[]): {
		overrideCustomMaterials: ParamTemplate<ParamType.BOOLEAN>;
		createCustomMatDistance: ParamTemplate<ParamType.BOOLEAN>;
		createCustomMatDepth: ParamTemplate<ParamType.BOOLEAN>;
		createCustomMatDepthDOF: ParamTemplate<ParamType.BOOLEAN>;
	};
} & {
	new (...args: any[]): {
		shadowPCSS: ParamTemplate<ParamType.BOOLEAN>;
		shadowPCSSFilterSize: ParamTemplate<ParamType.FLOAT>;
	};
} & {
	new (...args: any[]): {
		useFog: ParamTemplate<ParamType.BOOLEAN>;
	};
} & {
	new (...args: any[]): {
		wireframe: ParamTemplate<ParamType.BOOLEAN>;
		wireframeLinewidth: ParamTemplate<ParamType.FLOAT>;
	};
} & {
	new (...args: any[]): {
		doubleSided: ParamTemplate<ParamType.BOOLEAN>;
		front: ParamTemplate<ParamType.BOOLEAN>;
		overrideShadowSide: ParamTemplate<ParamType.BOOLEAN>;
		shadowDoubleSided: ParamTemplate<ParamType.BOOLEAN>;
		shadowFront: ParamTemplate<ParamType.BOOLEAN>;
		colorWrite: ParamTemplate<ParamType.BOOLEAN>;
		depthWrite: ParamTemplate<ParamType.BOOLEAN>;
		depthTest: ParamTemplate<ParamType.BOOLEAN>;
		premultipliedAlpha: ParamTemplate<ParamType.BOOLEAN>;
		blending: ParamTemplate<ParamType.INTEGER>;
		dithering: ParamTemplate<ParamType.BOOLEAN>;
		polygonOffset: ParamTemplate<ParamType.BOOLEAN>;
		polygonOffsetFactor: ParamTemplate<ParamType.INTEGER>;
		polygonOffsetUnits: ParamTemplate<ParamType.INTEGER>;
	};
} & {
	new (...args: any[]): {
		setBuilderNode: ParamTemplate<ParamType.BOOLEAN>;
		builderNode: ParamTemplate<ParamType.NODE_PATH>;
	};
} & {
	new (...args: any[]): {
		advanced: ParamTemplate<ParamType.FOLDER>;
	};
} & {
	new (...args: any[]): {
		useNormalMap: ParamTemplate<ParamType.BOOLEAN>;
		normalMap: ParamTemplate<ParamType.NODE_PATH>;
		normalMapType: ParamTemplate<ParamType.INTEGER>;
		normalScale: ParamTemplate<ParamType.VECTOR2>;
		normalScaleMult: ParamTemplate<ParamType.FLOAT>;
	};
} & {
	new (...args: any[]): {
		useLightMap: ParamTemplate<ParamType.BOOLEAN>;
		lightMap: ParamTemplate<ParamType.NODE_PATH>;
		lightMapIntensity: ParamTemplate<ParamType.FLOAT>;
	};
} & {
	new (...args: any[]): {
		useGradientMap: ParamTemplate<ParamType.BOOLEAN>;
		gradientMap: ParamTemplate<ParamType.NODE_PATH>;
	};
} & {
	new (...args: any[]): {
		emissive: ParamTemplate<ParamType.COLOR>;
		useEmissiveMap: ParamTemplate<ParamType.BOOLEAN>;
		emissiveMap: ParamTemplate<ParamType.NODE_PATH>;
		emissiveIntensity: ParamTemplate<ParamType.FLOAT>;
	};
} & {
	new (...args: any[]): {
		useDisplacementMap: ParamTemplate<ParamType.BOOLEAN>;
		displacementMap: ParamTemplate<ParamType.NODE_PATH>;
		displacementScale: ParamTemplate<ParamType.FLOAT>;
		displacementBias: ParamTemplate<ParamType.FLOAT>;
	};
} & {
	new (...args: any[]): {
		useBumpMap: ParamTemplate<ParamType.BOOLEAN>;
		bumpMap: ParamTemplate<ParamType.NODE_PATH>;
		bumpScale: ParamTemplate<ParamType.FLOAT>;
		bumpBias: ParamTemplate<ParamType.FLOAT>;
	};
} & {
	new (...args: any[]): {
		useAOMap: ParamTemplate<ParamType.BOOLEAN>;
		aoMap: ParamTemplate<ParamType.NODE_PATH>;
		aoMapIntensity: ParamTemplate<ParamType.FLOAT>;
	};
} & {
	new (...args: any[]): {
		useAlphaMap: ParamTemplate<ParamType.BOOLEAN>;
		alphaMap: ParamTemplate<ParamType.NODE_PATH>;
	};
} & {
	new (...args: any[]): {
		useMap: ParamTemplate<ParamType.BOOLEAN>;
		map: ParamTemplate<ParamType.NODE_PATH>;
	};
} & {
	new (...args: any[]): {
		textures: ParamTemplate<ParamType.FOLDER>;
	};
} & {
	new (...args: any[]): {
		transparent: ParamTemplate<ParamType.BOOLEAN>;
		opacity: ParamTemplate<ParamType.FLOAT>;
		alphaTest: ParamTemplate<ParamType.FLOAT>;
	};
} & {
	new (...args: any[]): {
		default: ParamTemplate<ParamType.FOLDER>;
	};
} & typeof NodeParamsConfig;
declare class MeshToonBuilderMatParamsConfig extends MeshToonBuilderMatParamsConfig_base {
}
declare class MeshToonBuilderMatNode extends TypedBuilderMatNode<MeshToonBuilderMaterial, ShaderAssemblerToon, MeshToonBuilderMatParamsConfig> {
	paramsConfig: MeshToonBuilderMatParamsConfig;
	static type(): MatType;
	usedAssembler(): Readonly<AssemblerName.GL_MESH_TOON>;
	protected _createAssemblerController(): GlAssemblerController<ShaderAssemblerToon> | undefined;
	customMaterialRequested(customName: CustomMaterialName): boolean;
	readonly controllers: MeshToonBuilderControllers;
	protected controllersList: any[];
	cook(): Promise<void>;
}
interface PointsSizeControllers {
	pointsSize: PointsSizeController;
}
declare const PointsParamsConfig_base: {
	new (...args: any[]): {
		size: ParamTemplate<ParamType.FLOAT>;
		sizeAttenuation: ParamTemplate<ParamType.BOOLEAN>;
	};
} & typeof NodeParamsConfig;
declare class PointsParamsConfig extends PointsParamsConfig_base {
}
declare class PointsSizeMatNode extends TypedMatNode<PointsMaterial, PointsParamsConfig> {
	material(): Promise<PointsMaterial | undefined>;
	controllers: PointsSizeControllers;
}
declare class PointsSizeController extends BaseController {
	protected node: PointsSizeMatNode;
	constructor(node: PointsSizeMatNode);
	static update(node: PointsSizeMatNode): Promise<void>;
	updateMaterial(material: PointsMaterial): void;
}
interface PointsControllers extends AdvancedCommonControllers, ColorsControllers, PointsSizeControllers, TextureAlphaMapControllers, TextureMapControllers, UniformFogControllers {
}
declare const PointsMatParamsConfig_base: {
	new (...args: any[]): {
		useFog: ParamTemplate<ParamType.BOOLEAN>;
	};
} & {
	new (...args: any[]): {
		doubleSided: ParamTemplate<ParamType.BOOLEAN>;
		front: ParamTemplate<ParamType.BOOLEAN>;
		overrideShadowSide: ParamTemplate<ParamType.BOOLEAN>;
		shadowDoubleSided: ParamTemplate<ParamType.BOOLEAN>;
		shadowFront: ParamTemplate<ParamType.BOOLEAN>;
		colorWrite: ParamTemplate<ParamType.BOOLEAN>;
		depthWrite: ParamTemplate<ParamType.BOOLEAN>;
		depthTest: ParamTemplate<ParamType.BOOLEAN>;
		premultipliedAlpha: ParamTemplate<ParamType.BOOLEAN>;
		blending: ParamTemplate<ParamType.INTEGER>;
		dithering: ParamTemplate<ParamType.BOOLEAN>;
		polygonOffset: ParamTemplate<ParamType.BOOLEAN>;
		polygonOffsetFactor: ParamTemplate<ParamType.INTEGER>;
		polygonOffsetUnits: ParamTemplate<ParamType.INTEGER>;
	};
} & {
	new (...args: any[]): {
		advanced: ParamTemplate<ParamType.FOLDER>;
	};
} & {
	new (...args: any[]): {
		useAlphaMap: ParamTemplate<ParamType.BOOLEAN>;
		alphaMap: ParamTemplate<ParamType.NODE_PATH>;
	};
} & {
	new (...args: any[]): {
		useMap: ParamTemplate<ParamType.BOOLEAN>;
		map: ParamTemplate<ParamType.NODE_PATH>;
	};
} & {
	new (...args: any[]): {
		textures: ParamTemplate<ParamType.FOLDER>;
	};
} & {
	new (...args: any[]): {
		color: ParamTemplate<ParamType.COLOR>;
		useVertexColors: ParamTemplate<ParamType.BOOLEAN>;
		transparent: ParamTemplate<ParamType.BOOLEAN>;
		opacity: ParamTemplate<ParamType.FLOAT>;
		alphaTest: ParamTemplate<ParamType.FLOAT>;
	};
} & {
	new (...args: any[]): {
		size: ParamTemplate<ParamType.FLOAT>;
		sizeAttenuation: ParamTemplate<ParamType.BOOLEAN>;
	};
} & {
	new (...args: any[]): {
		default: ParamTemplate<ParamType.FOLDER>;
	};
} & typeof NodeParamsConfig;
declare class PointsMatParamsConfig extends PointsMatParamsConfig_base {
}
declare class PointsMatNode extends PrimitiveMatNode<PointsMaterial, PointsMatParamsConfig> {
	paramsConfig: PointsMatParamsConfig;
	static type(): MatType.POINTS;
	createMaterial(): PointsMaterial;
	readonly controllers: PointsControllers;
	protected controllersList: any[];
	cook(): Promise<void>;
}
declare class ShaderAssemblerPoints extends ShaderAssemblerMaterial {
	customAssemblerClassByCustomName(): CustomAssemblerMap;
	templateShader(): {
		vertexShader: string;
		fragmentShader: string;
		uniforms: {
			[uniform: string]: IUniform<any>;
		};
	};
	createMaterial(): PointsMaterial;
	add_output_inputs(output_child: OutputGlNode): void;
	create_globals_node_output_connections(): (GlConnectionPoint<GlConnectionPointType.VEC3> | GlConnectionPoint<GlConnectionPointType.VEC2> | GlConnectionPoint<GlConnectionPointType.VEC4> | GlConnectionPoint<GlConnectionPointType.FLOAT> | GlConnectionPoint<GlConnectionPointType.MAT4> | GlConnectionPoint<GlConnectionPointType.MAT3>)[];
	create_shader_configs(): ShaderConfig[];
	create_variable_configs(): VariableConfig[];
	protected linesToRemove(shader_name: ShaderName): string[] | undefined;
}
interface PointsBuilderControllers extends AdvancedCommonControllers, PointsSizeControllers, UniformFogControllers, UniformsTransparencyControllers {
}
interface PointsBuilderMaterial extends PointsMaterial {
	vertexShader: string;
	fragmentShader: string;
	customMaterials: {
		[key in CustomMaterialName]?: Material;
	};
}
declare const PointsBuilderMatParamsConfig_base: {
	new (...args: any[]): {
		overrideCustomMaterials: ParamTemplate<ParamType.BOOLEAN>;
		createCustomMatDistance: ParamTemplate<ParamType.BOOLEAN>;
		createCustomMatDepth: ParamTemplate<ParamType.BOOLEAN>;
		createCustomMatDepthDOF: ParamTemplate<ParamType.BOOLEAN>;
	};
} & {
	new (...args: any[]): {
		useFog: ParamTemplate<ParamType.BOOLEAN>;
	};
} & {
	new (...args: any[]): {
		doubleSided: ParamTemplate<ParamType.BOOLEAN>;
		front: ParamTemplate<ParamType.BOOLEAN>;
		overrideShadowSide: ParamTemplate<ParamType.BOOLEAN>;
		shadowDoubleSided: ParamTemplate<ParamType.BOOLEAN>;
		shadowFront: ParamTemplate<ParamType.BOOLEAN>;
		colorWrite: ParamTemplate<ParamType.BOOLEAN>;
		depthWrite: ParamTemplate<ParamType.BOOLEAN>;
		depthTest: ParamTemplate<ParamType.BOOLEAN>;
		premultipliedAlpha: ParamTemplate<ParamType.BOOLEAN>;
		blending: ParamTemplate<ParamType.INTEGER>;
		dithering: ParamTemplate<ParamType.BOOLEAN>;
		polygonOffset: ParamTemplate<ParamType.BOOLEAN>;
		polygonOffsetFactor: ParamTemplate<ParamType.INTEGER>;
		polygonOffsetUnits: ParamTemplate<ParamType.INTEGER>;
	};
} & {
	new (...args: any[]): {
		setBuilderNode: ParamTemplate<ParamType.BOOLEAN>;
		builderNode: ParamTemplate<ParamType.NODE_PATH>;
	};
} & {
	new (...args: any[]): {
		advanced: ParamTemplate<ParamType.FOLDER>;
	};
} & {
	new (...args: any[]): {
		transparent: ParamTemplate<ParamType.BOOLEAN>;
		opacity: ParamTemplate<ParamType.FLOAT>;
		alphaTest: ParamTemplate<ParamType.FLOAT>;
	};
} & {
	new (...args: any[]): {
		size: ParamTemplate<ParamType.FLOAT>;
		sizeAttenuation: ParamTemplate<ParamType.BOOLEAN>;
	};
} & {
	new (...args: any[]): {
		default: ParamTemplate<ParamType.FOLDER>;
	};
} & typeof NodeParamsConfig;
declare class PointsBuilderMatParamsConfig extends PointsBuilderMatParamsConfig_base {
}
declare class PointsBuilderMatNode extends TypedBuilderMatNode<PointsBuilderMaterial, ShaderAssemblerPoints, PointsBuilderMatParamsConfig> {
	paramsConfig: PointsBuilderMatParamsConfig;
	static type(): MatType;
	usedAssembler(): Readonly<AssemblerName.GL_POINTS>;
	protected _createAssemblerController(): GlAssemblerController<ShaderAssemblerPoints> | undefined;
	customMaterialRequested(customName: CustomMaterialName): boolean;
	readonly controllers: PointsBuilderControllers;
	protected controllersList: any[];
	cook(): Promise<void>;
}
declare abstract class BaseShaderAssemblerRayMarchingAbstract extends ShaderAssemblerMaterial {
	customAssemblerClassByCustomName(): CustomAssemblerMap;
	set_node_lines_globals(globals_node: GlobalsGlNode, shaders_collection_controller: ShadersCollectionController): void;
}
declare class BaseShaderAssemblerRayMarchingRendered extends BaseShaderAssemblerRayMarchingAbstract {
	protected _gl_parent_node: AssemblerGlControllerNode;
	constructor(_gl_parent_node: AssemblerGlControllerNode);
	templateShader(): {
		vertexShader: string;
		fragmentShader: string;
		uniforms: any;
	};
	createMaterial(): ShaderMaterial;
	protected _raymarchingLightsWorldCoordsDependent(): boolean;
	add_output_inputs(output_child: OutputGlNode): void;
	static create_globals_node_output_connections(): (GlConnectionPoint<GlConnectionPointType.VEC3> | GlConnectionPoint<GlConnectionPointType.FLOAT>)[];
	create_globals_node_output_connections(): (GlConnectionPoint<GlConnectionPointType.VEC3> | GlConnectionPoint<GlConnectionPointType.FLOAT>)[];
	protected insertBodyAfter(shaderName: ShaderName): string | undefined;
	protected insertDefineAfter(shaderName: ShaderName): string | undefined;
	protected linesToRemove(shaderName: ShaderName): string[] | undefined;
	create_shader_configs(): ShaderConfig[];
	static create_variable_configs(): VariableConfig[];
	create_variable_configs(): VariableConfig[];
	private _applyMaterialAssembler;
	private _applyMaterialMaterial;
	setGlParentNode(gl_parent_node: AssemblerGlControllerNode): void;
	compileMaterial(material: Material): void;
	applyMaterialAssemblerFilterFragmentShader(fragmentShader: string): string;
}
declare class ShaderAssemblerRayMarching extends BaseShaderAssemblerRayMarchingRendered {
	templateShader(): {
		vertexShader: string;
		fragmentShader: string;
		uniforms: any;
	};
	customAssemblerClassByCustomName(): CustomAssemblerMap;
	createMaterial(): ShaderMaterial;
}
declare const RayMarchingBuilderMatParamsConfig_base: {
	new (...args: any[]): {
		debug: ParamTemplate<ParamType.BOOLEAN>;
		debugMode: ParamTemplate<ParamType.INTEGER>;
		debugMinSteps: ParamTemplate<ParamType.INTEGER>;
		debugMaxSteps: ParamTemplate<ParamType.INTEGER>;
		debugMinDepth: ParamTemplate<ParamType.FLOAT>;
		debugMaxDepth: ParamTemplate<ParamType.FLOAT>;
	};
} & {
	new (...args: any[]): {
		overrideCustomMaterials: ParamTemplate<ParamType.BOOLEAN>;
		createCustomMatDistance: ParamTemplate<ParamType.BOOLEAN>;
		shadowDistanceMin: ParamTemplate<ParamType.FLOAT>;
		shadowDistanceMax: ParamTemplate<ParamType.FLOAT>;
		createCustomMatDepth: ParamTemplate<ParamType.BOOLEAN>;
		shadowDepthMin: ParamTemplate<ParamType.FLOAT>;
		shadowDepthMax: ParamTemplate<ParamType.FLOAT>;
	};
} & {
	new (...args: any[]): {
		useFog: ParamTemplate<ParamType.BOOLEAN>;
	};
} & {
	new (...args: any[]): {
		/** @param defines if the material is double sided or not */
		doubleSided: ParamTemplate<ParamType.BOOLEAN>;
		/** @param if the material is not double sided, it can be front sided, or back sided */
		front: ParamTemplate<ParamType.BOOLEAN>;
	};
} & {
	new (...args: any[]): {
		setBuilderNode: ParamTemplate<ParamType.BOOLEAN>;
		builderNode: ParamTemplate<ParamType.NODE_PATH>;
	};
} & {
	new (...args: any[]): {
		advanced: ParamTemplate<ParamType.FOLDER>;
	};
} & {
	new (...args: any[]): {
		useEnvMap: ParamTemplate<ParamType.BOOLEAN>;
		envMap: ParamTemplate<ParamType.NODE_PATH>;
		envMapIntensity: ParamTemplate<ParamType.FLOAT>;
		envMapRoughness: ParamTemplate<ParamType.FLOAT>;
		tEnvMapRotate: ParamTemplate<ParamType.BOOLEAN>;
		envMapRotation: ParamTemplate<ParamType.FLOAT>;
	};
} & {
	new (...args: any[]): {
		textures: ParamTemplate<ParamType.FOLDER>;
	};
} & {
	new (...args: any[]): {
		maxSteps: ParamTemplate<ParamType.INTEGER>;
		maxDist: ParamTemplate<ParamType.FLOAT>;
		surfDist: ParamTemplate<ParamType.FLOAT>;
		normalsBias: ParamTemplate<ParamType.FLOAT>;
		shadowBias: ParamTemplate<ParamType.FLOAT>;
	};
} & {
	new (...args: any[]): {
		default: ParamTemplate<ParamType.FOLDER>;
	};
} & typeof NodeParamsConfig;
declare class RayMarchingBuilderMatParamsConfig extends RayMarchingBuilderMatParamsConfig_base {
}
declare class RayMarchingBuilderMatNode extends TypedBuilderMatNode<ShaderMaterialWithCustomMaterials, ShaderAssemblerRayMarching, RayMarchingBuilderMatParamsConfig> {
	paramsConfig: RayMarchingBuilderMatParamsConfig;
	static type(): MatType;
	usedAssembler(): Readonly<AssemblerName.GL_RAYMARCHING>;
	protected _createAssemblerController(): GlAssemblerController<ShaderAssemblerRayMarching> | undefined;
	customMaterialRequested(customName: CustomMaterialName): boolean;
	private _rayMarchingController;
	initializeNode(): void;
	controllers: UniformFogControllers;
	cook(): Promise<void>;
}
interface ShadowControllers extends AdvancedCommonControllers, ColorsControllers {
}
declare const ShadowMatParamsConfig_base: {
	new (...args: any[]): {
		doubleSided: ParamTemplate<ParamType.BOOLEAN>;
		front: ParamTemplate<ParamType.BOOLEAN>;
		overrideShadowSide: ParamTemplate<ParamType.BOOLEAN>;
		shadowDoubleSided: ParamTemplate<ParamType.BOOLEAN>;
		shadowFront: ParamTemplate<ParamType.BOOLEAN>;
		colorWrite: ParamTemplate<ParamType.BOOLEAN>;
		depthWrite: ParamTemplate<ParamType.BOOLEAN>;
		depthTest: ParamTemplate<ParamType.BOOLEAN>;
		premultipliedAlpha: ParamTemplate<ParamType.BOOLEAN>;
		blending: ParamTemplate<ParamType.INTEGER>;
		dithering: ParamTemplate<ParamType.BOOLEAN>;
		polygonOffset: ParamTemplate<ParamType.BOOLEAN>;
		polygonOffsetFactor: ParamTemplate<ParamType.INTEGER>;
		polygonOffsetUnits: ParamTemplate<ParamType.INTEGER>;
	};
} & {
	new (...args: any[]): {
		color: ParamTemplate<ParamType.COLOR>;
		useVertexColors: ParamTemplate<ParamType.BOOLEAN>;
		transparent: ParamTemplate<ParamType.BOOLEAN>;
		opacity: ParamTemplate<ParamType.FLOAT>;
		alphaTest: ParamTemplate<ParamType.FLOAT>;
	};
} & typeof NodeParamsConfig;
declare class ShadowMatParamsConfig extends ShadowMatParamsConfig_base {
}
declare class ShadowMatNode extends PrimitiveMatNode<ShadowMaterial, ShadowMatParamsConfig> {
	paramsConfig: ShadowMatParamsConfig;
	static type(): MatType;
	createMaterial(): ShadowMaterial;
	readonly controllers: ShadowControllers;
	protected controllersList: any[];
	cook(): Promise<void>;
}
interface ShaderMaterialWithSkyUniforms extends ShaderMaterial {
	uniforms: {
		turbidity: {
			value: number;
		};
		rayleigh: {
			value: number;
		};
		mieCoefficient: {
			value: number;
		};
		mieDirectionalG: {
			value: number;
		};
		sunPosition: {
			value: Vector3;
		};
		up: {
			value: Vector3;
		};
	};
}
declare class SkyMatParamsConfig extends NodeParamsConfig {
	/** @param turbidity */
	turbidity: ParamTemplate<ParamType.FLOAT>;
	/** @param rayleigh */
	rayleigh: ParamTemplate<ParamType.FLOAT>;
	/** @param mieCoefficient */
	mieCoefficient: ParamTemplate<ParamType.FLOAT>;
	/** @param mieDirectional */
	mieDirectional: ParamTemplate<ParamType.FLOAT>;
	/** @param inclination */
	inclination: ParamTemplate<ParamType.FLOAT>;
	/** @param azimuth */
	azimuth: ParamTemplate<ParamType.FLOAT>;
	/** @param up */
	up: ParamTemplate<ParamType.VECTOR3>;
}
declare class SkyMatNode extends PrimitiveMatNode<ShaderMaterialWithSkyUniforms, SkyMatParamsConfig> {
	paramsConfig: SkyMatParamsConfig;
	static type(): MatType;
	createMaterial(): ShaderMaterialWithSkyUniforms;
	cook(): Promise<void>;
}
declare class StencilPropertiesMatParamsConfig extends NodeParamsConfig {
	/** @param stencilWrite */
	stencilWrite: ParamTemplate<ParamType.BOOLEAN>;
	/** @param stencilFunc */
	stencilFunc: ParamTemplate<ParamType.INTEGER>;
	/** @param stencilWriteMask */
	stencilWriteMask: ParamTemplate<ParamType.INTEGER>;
	/** @param stencilWriteMask */
	stencilFuncMask: ParamTemplate<ParamType.INTEGER>;
	/** @param stencilRef */
	stencilRef: ParamTemplate<ParamType.INTEGER>;
	/** @param stencilFail */
	stencilFail: ParamTemplate<ParamType.INTEGER>;
	/** @param stencilZFail */
	stencilZFail: ParamTemplate<ParamType.INTEGER>;
	/** @param stencilZPass */
	stencilZPass: ParamTemplate<ParamType.INTEGER>;
}
declare class StencilPropertiesMatNode extends UpdateMatNode<ShaderMaterial, StencilPropertiesMatParamsConfig> {
	paramsConfig: StencilPropertiesMatParamsConfig;
	static type(): string;
	cook(inputMaterials: Material[]): Promise<void>;
}
declare const VolumeMatParamsConfig_base: {
	new (...args: any[]): {
		color: ParamTemplate<ParamType.COLOR>;
		stepSize: ParamTemplate<ParamType.FLOAT>;
		density: ParamTemplate<ParamType.FLOAT>;
		shadowDensity: ParamTemplate<ParamType.FLOAT>;
		lightDir: ParamTemplate<ParamType.VECTOR3>;
	};
} & typeof NodeParamsConfig;
declare class VolumeMatParamsConfig extends VolumeMatParamsConfig_base {
}
declare class VolumeMatNode extends PrimitiveMatNode<ShaderMaterial, VolumeMatParamsConfig> {
	paramsConfig: VolumeMatParamsConfig;
	static type(): MatType;
	private _volumeController;
	createMaterial(): ShaderMaterial;
	initializeNode(): void;
	cook(): Promise<void>;
}
declare abstract class BaseShaderAssemblerVolume extends ShaderAssemblerMaterial {
	customAssemblerClassByCustomName(): CustomAssemblerMap;
}
declare class ShaderAssemblerVolume extends BaseShaderAssemblerVolume {
	templateShader(): {
		vertexShader: string;
		fragmentShader: string;
		uniforms: any;
	};
	createMaterial(): ShaderMaterial;
	add_output_inputs(output_child: OutputGlNode): void;
	static create_globals_node_output_connections(): (GlConnectionPoint<GlConnectionPointType.VEC3> | GlConnectionPoint<GlConnectionPointType.FLOAT>)[];
	create_globals_node_output_connections(): (GlConnectionPoint<GlConnectionPointType.VEC3> | GlConnectionPoint<GlConnectionPointType.FLOAT>)[];
	protected insertBodyAfter(shader_name: ShaderName): string | undefined;
	protected linesToRemove(shader_name: ShaderName): string[] | undefined;
	create_shader_configs(): ShaderConfig[];
	static create_variable_configs(): VariableConfig[];
	create_variable_configs(): VariableConfig[];
	set_node_lines_globals(globals_node: GlobalsGlNode, shaders_collection_controller: ShadersCollectionController): void;
}
declare const VolumeBuilderMatParamsConfig_base: {
	new (...args: any[]): {
		setBuilderNode: ParamTemplate<ParamType.BOOLEAN>;
		builderNode: ParamTemplate<ParamType.NODE_PATH>;
	};
} & {
	new (...args: any[]): {
		color: ParamTemplate<ParamType.COLOR>;
		stepSize: ParamTemplate<ParamType.FLOAT>;
		density: ParamTemplate<ParamType.FLOAT>;
		shadowDensity: ParamTemplate<ParamType.FLOAT>;
		lightDir: ParamTemplate<ParamType.VECTOR3>;
	};
} & typeof NodeParamsConfig;
declare class VolumeBuilderMatParamsConfig extends VolumeBuilderMatParamsConfig_base {
}
declare class VolumeBuilderMatNode extends TypedBuilderMatNode<ShaderMaterialWithCustomMaterials, ShaderAssemblerVolume, VolumeBuilderMatParamsConfig> {
	paramsConfig: VolumeBuilderMatParamsConfig;
	static type(): MatType;
	usedAssembler(): Readonly<AssemblerName.GL_VOLUME>;
	protected _createAssemblerController(): GlAssemblerController<ShaderAssemblerVolume> | undefined;
	private _volumeController;
	initializeNode(): void;
	cook(): Promise<void>;
}
declare class ParamLessNetworkMatParamsConfig extends NodeParamsConfig {
}
declare class BaseNetworkMatNode<K extends NodeParamsConfig> extends TypedNode<NodeContext.MAT, K> {
	static context(): NodeContext;
	cook(): void;
}
declare class ParamLessBaseNetworkMatNode extends BaseNetworkMatNode<ParamLessNetworkMatParamsConfig> {
}
declare class ActorsNetworkMatNode extends ParamLessBaseNetworkMatNode {
	static type(): NetworkNodeType;
	protected _childrenControllerContext: NodeContext;
	createNode<S extends keyof JsNodeChildrenMap>(node_class: S, options?: NodeCreateOptions): JsNodeChildrenMap[S];
	createNode<K extends valueof<JsNodeChildrenMap>>(node_class: Constructor<K>, options?: NodeCreateOptions): K;
	children(): BaseJsNodeType[];
	nodesByType<K extends keyof JsNodeChildrenMap>(type: K): JsNodeChildrenMap[K][];
	childrenAllowed(): boolean;
	sceneReadonly(): boolean;
	readonly persisted_config: ActorPersistedConfig;
	assemblerController(): JsAssemblerController<JsAssemblerActor> | undefined;
	usedAssembler(): Readonly<AssemblerName.JS_ACTOR>;
	protected _assemblerController: JsAssemblerController<JsAssemblerActor> | undefined;
	private _createAssemblerController;
	readonly compilationController: ActorCompilationController;
	compile(): void;
	cook(): void;
}
declare class AnimationsNetworkMatNode extends ParamLessBaseNetworkMatNode {
	static type(): NetworkNodeType;
	protected _childrenControllerContext: NodeContext;
	createNode<S extends keyof AnimNodeChildrenMap>(node_class: S, options?: NodeCreateOptions): AnimNodeChildrenMap[S];
	createNode<K extends valueof<AnimNodeChildrenMap>>(node_class: Constructor<K>, options?: NodeCreateOptions): K;
	children(): BaseAnimNodeType[];
	nodesByType<K extends keyof AnimNodeChildrenMap>(type: K): AnimNodeChildrenMap[K][];
}
declare class AudioNetworkMatNode extends ParamLessBaseNetworkMatNode {
	static type(): NetworkNodeType;
	protected _childrenControllerContext: NodeContext;
	createNode<S extends keyof AudioNodeChildrenMap>(node_class: S, options?: NodeCreateOptions): AudioNodeChildrenMap[S];
	createNode<K extends valueof<AudioNodeChildrenMap>>(node_class: Constructor<K>, options?: NodeCreateOptions): K;
	children(): BaseAudioNodeType[];
	nodesByType<K extends keyof AudioNodeChildrenMap>(type: K): AudioNodeChildrenMap[K][];
}
declare class AudioAnalyserCopParamsConfig extends NodeParamsConfig {
	/** @param if off, the texture will not be updated */
	activeR: ParamTemplate<ParamType.BOOLEAN>;
	/** @param audio node to read data from, into the RED channel */
	audioNodeR: ParamTemplate<ParamType.NODE_PATH>;
	/** @param decibel range */
	rangeR: ParamTemplate<ParamType.VECTOR2>;
	/** @param speed mult */
	speedMultR: ParamTemplate<ParamType.FLOAT>;
	/** @param if off, the texture will not be updated */
	activeG: ParamTemplate<ParamType.BOOLEAN>;
	/** @param audio node to read data from, into the GREEN channel */
	audioNodeG: ParamTemplate<ParamType.NODE_PATH>;
	/** @param decibel range */
	rangeG: ParamTemplate<ParamType.VECTOR2>;
	/** @param speed mult */
	speedMultG: ParamTemplate<ParamType.FLOAT>;
	/** @param if off, the texture will not be updated */
	activeB: ParamTemplate<ParamType.BOOLEAN>;
	/** @param audio node to read data from, into the BLUE channel */
	audioNodeB: ParamTemplate<ParamType.NODE_PATH>;
	/** @param decibel range */
	rangeB: ParamTemplate<ParamType.VECTOR2>;
	/** @param speed mult */
	speedMultB: ParamTemplate<ParamType.FLOAT>;
	/** @param if off, the texture will not be updated */
	activeA: ParamTemplate<ParamType.BOOLEAN>;
	/** @param audio node to read data from, into the ALPHA channel */
	audioNodeA: ParamTemplate<ParamType.NODE_PATH>;
	/** @param decibel range */
	rangeA: ParamTemplate<ParamType.VECTOR2>;
	/** @param speed mult */
	speedMultA: ParamTemplate<ParamType.FLOAT>;
}
declare class AudioAnalyserCopNode extends TypedCopNode<AudioAnalyserCopParamsConfig> {
	paramsConfig: AudioAnalyserCopParamsConfig;
	static type(): string;
	cook(): Promise<void>;
	dispose(): void;
	private _audioNodesByChannel;
	private _valuesByChannel;
	private _getAudioNodes;
	private _getAudioNode;
	private _updateTexture;
	private _valuesForChannel;
	private _updateTextureChannel;
	private _dataTexture;
	private _createDataTexture;
	private _paramSetByChannel;
	private _initParamsByChannel;
	private _registerOnTickHook;
	private _unRegisterOnTickHook;
	private _tickCallbackName;
}
declare enum CopType {
	BUILDER = "builder",
	BUILDER_2D_ARRAY = "builder2DArray",
	CUBE_MAP = "cubeMap",
	CUBE_CAMERA = "cubeCamera",
	CUBE_MAP_FROM_SCENE = "cubeMapFromScene",
	ENV_MAP = "envMap",
	GIF = "gif",
	LIGHT_MAP = "lightMap",
	LUT = "lut",
	RENDER = "render",
	SDF_BLUR = "SDFBlur",
	SDF_FROM_OBJECT = "SDFFromObject",
	SDF_FROM_URL = "SDFFromUrl",
	SNAPSHOT = "snapshot",
	TEXT = "text",
	VIDEO = "video",
	WEB_CAM = "webCam"
}
declare const CopTextureParamsConfig_base: {
	new (...args: any[]): {
		/** @param toggle on to allow updating the texture encoding */
		tcolorSpace: ParamTemplate<ParamType.BOOLEAN>;
		/** @param sets the texture encoding */
		colorSpace: ParamTemplate<ParamType.STRING>;
		/** @param toggle on to allow updating the texture mapping */
		tmapping: ParamTemplate<ParamType.BOOLEAN>;
		/** @param sets the texture mapping */
		mapping: ParamTemplate<ParamType.INTEGER>;
		/** @param toggle on to allow updating the texture wrap */
		twrap: ParamTemplate<ParamType.BOOLEAN>;
		/** @param sets the texture wrapS */
		wrapS: ParamTemplate<ParamType.INTEGER>;
		/** @param sets the texture wrapT */
		wrapT: ParamTemplate<ParamType.INTEGER>;
		/** @param toggle on to allow updating the texture min filter */
		tminFilter: ParamTemplate<ParamType.BOOLEAN>;
		/** @param sets the texture min filter */
		minFilter: ParamTemplate<ParamType.INTEGER>;
		/** @param toggle on to allow updating the texture mag filter */
		tmagFilter: ParamTemplate<ParamType.BOOLEAN>;
		/** @param sets the texture mag filter */
		magFilter: ParamTemplate<ParamType.INTEGER>;
		/** @param toggle on to allow updating the texture anisotropy */
		tanisotropy: ParamTemplate<ParamType.BOOLEAN>;
		/** @param sets the anisotropy from the max value allowed by the renderer */
		useRendererMaxAnisotropy: ParamTemplate<ParamType.BOOLEAN>;
		/** @param sets the anisotropy manually */
		anisotropy: ParamTemplate<ParamType.INTEGER>;
		/** @param Toggle on to update the flipY */
		tflipY: ParamTemplate<ParamType.BOOLEAN>;
		/** @param sets the flipY */
		flipY: ParamTemplate<ParamType.BOOLEAN>;
		/** @param toggle on to update the texture transform */
		ttransform: ParamTemplate<ParamType.BOOLEAN>;
		/** @param updates the texture offset */
		offset: ParamTemplate<ParamType.VECTOR2>;
		/** @param updates the texture repeat */
		repeat: ParamTemplate<ParamType.VECTOR2>;
		/** @param updates the texture rotation */
		rotation: ParamTemplate<ParamType.FLOAT>;
		/** @param updates the texture center */
		center: ParamTemplate<ParamType.VECTOR2>;
		/** @param toggle on to display advanced parameters */
		tadvanced: ParamTemplate<ParamType.BOOLEAN>;
		/** @param toggle on to allow overriding the texture format */
		tformat: ParamTemplate<ParamType.BOOLEAN>;
		/** @param sets the texture format */
		format: ParamTemplate<ParamType.INTEGER>;
		/** @param toggle on to allow overriding the texture type */
		ttype: ParamTemplate<ParamType.BOOLEAN>;
		/** @param sets the texture ty[e] */
		type: ParamTemplate<ParamType.INTEGER>;
	};
} & typeof NodeParamsConfig;
declare class CopTextureParamsConfig extends CopTextureParamsConfig_base {
}
declare class TextureCopNode extends TypedCopNode<CopTextureParamsConfig> {
	paramsConfig: CopTextureParamsConfig;
	readonly textureParamsController: TextureParamsController;
}
declare class TextureParamsController {
	protected node: TextureCopNode;
	constructor(node: TextureCopNode);
	update(texture: Texture): Promise<void>;
	private _updateColorSpace;
	private _updateAdvanced;
	private _updateMapping;
	private _updateWrap;
	private _updateFilter;
	private _updateFlip;
	private _rendererController;
	private _updateAnisotropy;
	private _maxRendererAnisotropy;
	private _updateTransform;
	private _updateTransformOffset;
	private _updateTransformRepeat;
	private _updateTransformRotation;
	private _updateTransformCenter;
	static PARAM_CALLBACK_update_encoding(node: TextureCopNode): void;
	static PARAM_CALLBACK_update_mapping(node: TextureCopNode): void;
	static PARAM_CALLBACK_update_wrap(node: TextureCopNode): void;
	static PARAM_CALLBACK_update_filter(node: TextureCopNode): void;
	static PARAM_CALLBACK_update_anisotropy(node: TextureCopNode): void;
	static PARAM_CALLBACK_update_flipY(node: TextureCopNode): void;
	static PARAM_CALLBACK_update_transform(node: TextureCopNode): void;
	static PARAM_CALLBACK_update_offset(node: TextureCopNode): void;
	static PARAM_CALLBACK_update_repeat(node: TextureCopNode): void;
	static PARAM_CALLBACK_update_rotation(node: TextureCopNode): void;
	static PARAM_CALLBACK_update_center(node: TextureCopNode): void;
	static PARAM_CALLBACK_update_advanced(node: TextureCopNode): void;
	static copyTextureAttributes(texture: Texture, inputTexture: Texture): void;
	paramLabelsParams(): (BooleanParam | IntegerParam | StringParam)[];
	paramLabels(): string[];
}
declare class ShaderAssemblerTexture2DArray extends BaseGlShaderAssembler {
	private _uniforms;
	templateShader(): {
		fragmentShader: string;
		vertexShader: undefined;
		uniforms: {
			uLayer: {
				value: number;
			};
		};
	};
	fragment_shader(): string | undefined;
	uniforms(): IUniforms | undefined;
	updateFragmentShader(): void;
	add_output_inputs(output_child: OutputGlNode): void;
	add_globals_outputs(globals_node: GlobalsGlNode): void;
	create_shader_configs(): ShaderConfig[];
	create_variable_configs(): VariableConfig[];
	protected insertDefineAfter(shader_name: ShaderName): string;
	protected insertBodyAfter(shader_name: ShaderName): string;
	protected linesToRemove(shader_name: ShaderName): string[];
	private _handle_gl_FragCoord;
	private _handle_resolution;
	private _handleUVW;
	private _handleLayer;
	set_node_lines_output(output_node: OutputGlNode, shaders_collection_controller: ShadersCollectionController): void;
	set_node_lines_globals(globals_node: GlobalsGlNode, shaders_collection_controller: ShadersCollectionController): void;
}
declare const Builder2DArrayCopParamsConfig_base: {
	new (...args: any[]): {
		tcolorSpace: ParamTemplate<ParamType.BOOLEAN>;
		colorSpace: ParamTemplate<ParamType.STRING>;
		tmapping: ParamTemplate<ParamType.BOOLEAN>;
		mapping: ParamTemplate<ParamType.INTEGER>;
		twrap: ParamTemplate<ParamType.BOOLEAN>;
		wrapS: ParamTemplate<ParamType.INTEGER>;
		wrapT: ParamTemplate<ParamType.INTEGER>;
		tminFilter: ParamTemplate<ParamType.BOOLEAN>;
		minFilter: ParamTemplate<ParamType.INTEGER>;
		tmagFilter: ParamTemplate<ParamType.BOOLEAN>;
		magFilter: ParamTemplate<ParamType.INTEGER>;
		tanisotropy: ParamTemplate<ParamType.BOOLEAN>;
		useRendererMaxAnisotropy: ParamTemplate<ParamType.BOOLEAN>;
		anisotropy: ParamTemplate<ParamType.INTEGER>;
		tflipY: ParamTemplate<ParamType.BOOLEAN>;
		flipY: ParamTemplate<ParamType.BOOLEAN>;
		ttransform: ParamTemplate<ParamType.BOOLEAN>;
		offset: ParamTemplate<ParamType.VECTOR2>;
		repeat: ParamTemplate<ParamType.VECTOR2>;
		rotation: ParamTemplate<ParamType.FLOAT>;
		center: ParamTemplate<ParamType.VECTOR2>;
		tadvanced: ParamTemplate<ParamType.BOOLEAN>;
		tformat: ParamTemplate<ParamType.BOOLEAN>;
		format: ParamTemplate<ParamType.INTEGER>;
		ttype: ParamTemplate<ParamType.BOOLEAN>;
		type: ParamTemplate<ParamType.INTEGER>;
	};
} & {
	new (...args: any[]): {
		/** @param textures resolution */
		resolution: ParamTemplate<ParamType.VECTOR2>;
		/** @param layers */
		layers: ParamTemplate<ParamType.INTEGER>;
		/** @param use the main camera renderer. This can save memory, but can also lead to colors being affected by the renderer's output color space */
		useCameraRenderer: ParamTemplate<ParamType.BOOLEAN>;
		/** @param use a data texture instead of a render target, which can be useful when using that texture as and envMap */
		/** @param force Render */
		render: ParamTemplate<ParamType.BUTTON>;
	};
} & typeof NodeParamsConfig;
declare class Builder2DArrayCopParamsConfig extends Builder2DArrayCopParamsConfig_base {
}
declare class Builder2DArrayCopNode extends TypedCopNode<Builder2DArrayCopParamsConfig> {
	paramsConfig: Builder2DArrayCopParamsConfig;
	static type(): CopType;
	readonly persisted_config: TexturePersistedConfig;
	protected _assemblerController: GlAssemblerController<ShaderAssemblerTexture2DArray> | undefined;
	usedAssembler(): Readonly<AssemblerName.GL_TEXTURE_2D_ARRAY>;
	protected _createAssemblerController(): GlAssemblerController<ShaderAssemblerTexture2DArray> | undefined;
	assemblerController(): GlAssemblerController<ShaderAssemblerTexture2DArray> | undefined;
	private _textureMesh;
	private _fragmentShader;
	private _uniforms;
	readonly textureMaterial: ShaderMaterial;
	private _textureScene;
	private _textureCamera;
	private _renderTarget;
	private _dataTextureController;
	private _rendererController;
	readonly textureParamsController: TextureParamsController;
	protected _childrenControllerContext: NodeContext;
	initializeNode(): void;
	createNode<S extends keyof GlNodeChildrenMap>(node_class: S, options?: NodeCreateOptions): GlNodeChildrenMap[S];
	createNode<K extends valueof<GlNodeChildrenMap>>(node_class: Constructor<K>, options?: NodeCreateOptions): K;
	children(): BaseGlNodeType[];
	nodesByType<K extends keyof GlNodeChildrenMap>(type: K): GlNodeChildrenMap[K][];
	childrenAllowed(): boolean;
	sceneReadonly(): boolean;
	private _cook_main_without_inputs_when_dirty_bound;
	private _cook_main_without_inputs_when_dirty;
	cook(): Promise<void>;
	shaders_by_name(): {
		fragment: string | undefined;
	};
	compileIfRequired(): void;
	private compile;
	callbackName(): string;
	dispose(): void;
	removeCallbacks(): void;
	readonly boundRenderOnTarget: () => Promise<void>;
	renderOnTargetWithoutUpdatingTextureFromParams(): Promise<void>;
	private _renderOnTarget;
	private _postRender;
	private _prevTarget;
	private _prevOutputColorSpace;
	private _prevToneMapping;
	private _saveRendererState;
	private _prepareRenderer;
	private _setRenderLayer;
	private _restoreRendererState;
	private _renderer;
	private _createRendererIfRequired;
	private _resetRenderer;
	renderer(): WebGLRenderer | undefined;
	renderTarget(): Promise<WebGLArrayRenderTarget>;
	private createRenderTargetIfRequired;
	private _renderTargetResolutionValid;
	private _createRenderTarget;
	static PARAM_CALLBACK_render(node: Builder2DArrayCopNode): void;
	static PARAM_CALLBACK_resetRenderer(node: Builder2DArrayCopNode): void;
}
interface PersistedConfigBaseTextureData extends PersistedConfigWithShaders {
	uniforms: IUniforms;
	param_uniform_pairs: [
		string,
		string
	][];
	uniforms_time_dependent?: boolean;
	uniforms_resolution_dependent?: boolean;
}
declare class TexturePersistedConfig extends BasePersistedConfig {
	protected node: BuilderCopNode | Builder2DArrayCopNode;
	constructor(node: BuilderCopNode | Builder2DArrayCopNode);
	toData(): Promise<PersistedConfigBaseTextureData | undefined>;
	load(data: PersistedConfigBaseTextureData): void;
}
declare class ShaderAssemblerTexture extends BaseGlShaderAssembler {
	private _uniforms;
	templateShader(): {
		fragmentShader: string;
		vertexShader: undefined;
		uniforms: undefined;
	};
	fragment_shader(): string | undefined;
	uniforms(): IUniforms | undefined;
	updateFragmentShader(): void;
	add_output_inputs(output_child: OutputGlNode): void;
	add_globals_outputs(globals_node: GlobalsGlNode): void;
	create_shader_configs(): ShaderConfig[];
	create_variable_configs(): VariableConfig[];
	protected insertDefineAfter(shader_name: ShaderName): string;
	protected insertBodyAfter(shader_name: ShaderName): string;
	protected linesToRemove(shader_name: ShaderName): string[];
	private _handle_gl_FragCoord;
	private _handle_resolution;
	private _handleUV;
	set_node_lines_output(output_node: OutputGlNode, shaders_collection_controller: ShadersCollectionController): void;
	set_node_lines_globals(globals_node: GlobalsGlNode, shaders_collection_controller: ShadersCollectionController): void;
}
declare const BuilderCopParamsConfig_base: {
	new (...args: any[]): {
		tcolorSpace: ParamTemplate<ParamType.BOOLEAN>;
		colorSpace: ParamTemplate<ParamType.STRING>;
		tmapping: ParamTemplate<ParamType.BOOLEAN>;
		mapping: ParamTemplate<ParamType.INTEGER>;
		twrap: ParamTemplate<ParamType.BOOLEAN>;
		wrapS: ParamTemplate<ParamType.INTEGER>;
		wrapT: ParamTemplate<ParamType.INTEGER>;
		tminFilter: ParamTemplate<ParamType.BOOLEAN>;
		minFilter: ParamTemplate<ParamType.INTEGER>;
		tmagFilter: ParamTemplate<ParamType.BOOLEAN>;
		magFilter: ParamTemplate<ParamType.INTEGER>;
		tanisotropy: ParamTemplate<ParamType.BOOLEAN>;
		useRendererMaxAnisotropy: ParamTemplate<ParamType.BOOLEAN>;
		anisotropy: ParamTemplate<ParamType.INTEGER>;
		tflipY: ParamTemplate<ParamType.BOOLEAN>;
		flipY: ParamTemplate<ParamType.BOOLEAN>;
		ttransform: ParamTemplate<ParamType.BOOLEAN>;
		offset: ParamTemplate<ParamType.VECTOR2>;
		repeat: ParamTemplate<ParamType.VECTOR2>;
		rotation: ParamTemplate<ParamType.FLOAT>;
		center: ParamTemplate<ParamType.VECTOR2>;
		tadvanced: ParamTemplate<ParamType.BOOLEAN>;
		tformat: ParamTemplate<ParamType.BOOLEAN>;
		format: ParamTemplate<ParamType.INTEGER>;
		ttype: ParamTemplate<ParamType.BOOLEAN>;
		type: ParamTemplate<ParamType.INTEGER>;
	};
} & {
	new (...args: any[]): {
		/** @param texture resolution */
		resolution: ParamTemplate<ParamType.VECTOR2>;
		/** @param use the main camera renderer. This can save memory, but can also lead to colors being affected by the renderer's output color space */
		useCameraRenderer: ParamTemplate<ParamType.BOOLEAN>;
		/** @param use a data texture instead of a render target, which can be useful when using that texture as and envMap */
		useDataTexture: ParamTemplate<ParamType.BOOLEAN>;
		/** @param force Render */
		render: ParamTemplate<ParamType.BUTTON>;
	};
} & typeof NodeParamsConfig;
declare class BuilderCopParamsConfig extends BuilderCopParamsConfig_base {
}
declare class BuilderCopNode extends TypedCopNode<BuilderCopParamsConfig> {
	paramsConfig: BuilderCopParamsConfig;
	static type(): CopType;
	readonly persisted_config: TexturePersistedConfig;
	protected _assemblerController: GlAssemblerController<ShaderAssemblerTexture> | undefined;
	usedAssembler(): Readonly<AssemblerName.GL_TEXTURE>;
	protected _createAssemblerController(): GlAssemblerController<ShaderAssemblerTexture> | undefined;
	assemblerController(): GlAssemblerController<ShaderAssemblerTexture> | undefined;
	private _textureMesh;
	private _fragmentShader;
	private _uniforms;
	readonly textureMaterial: ShaderMaterial;
	private _textureScene;
	private _textureCamera;
	private _renderTarget;
	private _dataTextureController;
	private _rendererController;
	readonly textureParamsController: TextureParamsController;
	protected _childrenControllerContext: NodeContext;
	initializeNode(): void;
	createNode<S extends keyof GlNodeChildrenMap>(node_class: S, options?: NodeCreateOptions): GlNodeChildrenMap[S];
	createNode<K extends valueof<GlNodeChildrenMap>>(node_class: Constructor<K>, options?: NodeCreateOptions): K;
	children(): BaseGlNodeType[];
	nodesByType<K extends keyof GlNodeChildrenMap>(type: K): GlNodeChildrenMap[K][];
	childrenAllowed(): boolean;
	sceneReadonly(): boolean;
	private _cook_main_without_inputs_when_dirty_bound;
	private _cook_main_without_inputs_when_dirty;
	cook(): Promise<void>;
	shaders_by_name(): {
		fragment: string | undefined;
	};
	compileIfRequired(): void;
	private compile;
	callbackName(): string;
	dispose(): void;
	removeCallbacks(): void;
	readonly boundRenderOnTarget: () => Promise<void>;
	renderOnTargetWithoutUpdatingTextureFromParams(): Promise<void>;
	private _renderOnTarget;
	private _postRender;
	private _prevTarget;
	private _prevOutputColorSpace;
	private _prevToneMapping;
	private _saveRendererState;
	private _prepareRenderer;
	private _restoreRendererState;
	private _renderer;
	private _createRendererIfRequired;
	private _resetRenderer;
	renderer(): WebGLRenderer | undefined;
	renderTarget(): Promise<WebGLRenderTarget>;
	private createRenderTargetIfRequired;
	private _renderTargetResolutionValid;
	private _createRenderTarget;
	static PARAM_CALLBACK_render(node: BuilderCopNode): void;
	static PARAM_CALLBACK_resetRenderer(node: BuilderCopNode): void;
}
declare const CanvasCopParamConfig_base: {
	new (...args: any[]): {
		tcolorSpace: ParamTemplate<ParamType.BOOLEAN>;
		colorSpace: ParamTemplate<ParamType.STRING>;
		tmapping: ParamTemplate<ParamType.BOOLEAN>;
		mapping: ParamTemplate<ParamType.INTEGER>;
		twrap: ParamTemplate<ParamType.BOOLEAN>;
		wrapS: ParamTemplate<ParamType.INTEGER>;
		wrapT: ParamTemplate<ParamType.INTEGER>;
		tminFilter: ParamTemplate<ParamType.BOOLEAN>;
		minFilter: ParamTemplate<ParamType.INTEGER>;
		tmagFilter: ParamTemplate<ParamType.BOOLEAN>;
		magFilter: ParamTemplate<ParamType.INTEGER>;
		tanisotropy: ParamTemplate<ParamType.BOOLEAN>;
		useRendererMaxAnisotropy: ParamTemplate<ParamType.BOOLEAN>;
		anisotropy: ParamTemplate<ParamType.INTEGER>;
		tflipY: ParamTemplate<ParamType.BOOLEAN>;
		flipY: ParamTemplate<ParamType.BOOLEAN>;
		ttransform: ParamTemplate<ParamType.BOOLEAN>;
		offset: ParamTemplate<ParamType.VECTOR2>;
		repeat: ParamTemplate<ParamType.VECTOR2>;
		rotation: ParamTemplate<ParamType.FLOAT>;
		center: ParamTemplate<ParamType.VECTOR2>;
		tadvanced: ParamTemplate<ParamType.BOOLEAN>;
		tformat: ParamTemplate<ParamType.BOOLEAN>;
		format: ParamTemplate<ParamType.INTEGER>;
		ttype: ParamTemplate<ParamType.BOOLEAN>;
		type: ParamTemplate<ParamType.INTEGER>;
	};
} & {
	new (...args: any[]): {
		/** @param HTML id of the canvas element */
		canvasId: ParamTemplate<ParamType.STRING>;
		/** @param forces the texture to update */
		update: ParamTemplate<ParamType.BUTTON>;
	};
} & typeof NodeParamsConfig;
declare class CanvasCopParamConfig extends CanvasCopParamConfig_base {
}
declare class CanvasCopNode extends TypedCopNode<CanvasCopParamConfig> {
	paramsConfig: CanvasCopParamConfig;
	static type(): Readonly<"canvas">;
	readonly textureParamsController: TextureParamsController;
	cook(): Promise<void>;
	static PARAM_CALLBACK_update(node: CanvasCopNode): void;
	private markTextureNeedsUpdate;
}
declare class ColorCopParamsConfig extends NodeParamsConfig {
	/** @param texture resolution */
	resolution: ParamTemplate<ParamType.VECTOR2>;
	/** @param color to generate */
	color: ParamTemplate<ParamType.COLOR>;
	/** @param alpha */
	alpha: ParamTemplate<ParamType.FLOAT>;
}
declare class ColorCopNode extends TypedCopNode<ColorCopParamsConfig> {
	paramsConfig: ColorCopParamsConfig;
	static type(): string;
	private _dataTexture;
	cook(): void;
	private _createDataTexture;
	private _createPixelBuffer;
	static PARAM_CALLBACK_reset(node: ColorCopNode): void;
	private _reset;
}
declare const CubeMapCopParamsConfig_base: {
	new (...args: any[]): {
		tcolorSpace: ParamTemplate<ParamType.BOOLEAN>;
		colorSpace: ParamTemplate<ParamType.STRING>;
		tmapping: ParamTemplate<ParamType.BOOLEAN>;
		mapping: ParamTemplate<ParamType.INTEGER>;
		twrap: ParamTemplate<ParamType.BOOLEAN>;
		wrapS: ParamTemplate<ParamType.INTEGER>;
		wrapT: ParamTemplate<ParamType.INTEGER>;
		tminFilter: ParamTemplate<ParamType.BOOLEAN>;
		minFilter: ParamTemplate<ParamType.INTEGER>;
		tmagFilter: ParamTemplate<ParamType.BOOLEAN>;
		magFilter: ParamTemplate<ParamType.INTEGER>;
		tanisotropy: ParamTemplate<ParamType.BOOLEAN>;
		useRendererMaxAnisotropy: ParamTemplate<ParamType.BOOLEAN>;
		anisotropy: ParamTemplate<ParamType.INTEGER>;
		tflipY: ParamTemplate<ParamType.BOOLEAN>;
		flipY: ParamTemplate<ParamType.BOOLEAN>;
		ttransform: ParamTemplate<ParamType.BOOLEAN>;
		offset: ParamTemplate<ParamType.VECTOR2>;
		repeat: ParamTemplate<ParamType.VECTOR2>;
		rotation: ParamTemplate<ParamType.FLOAT>;
		center: ParamTemplate<ParamType.VECTOR2>;
		tadvanced: ParamTemplate<ParamType.BOOLEAN>;
		tformat: ParamTemplate<ParamType.BOOLEAN>;
		format: ParamTemplate<ParamType.INTEGER>;
		ttype: ParamTemplate<ParamType.BOOLEAN>;
		type: ParamTemplate<ParamType.INTEGER>;
	};
} & {
	new (...args: any[]): {
		/** @param url prefix */
		prefix: ParamTemplate<ParamType.STRING>;
		/** @param url prefix */
		suffix: ParamTemplate<ParamType.STRING>;
		/** @param reload the image */
		reload: ParamTemplate<ParamType.BUTTON>;
		/** @param px url */
		px: ParamTemplate<ParamType.STRING>;
		/** @param nx url */
		nx: ParamTemplate<ParamType.STRING>;
		/** @param py url */
		py: ParamTemplate<ParamType.STRING>;
		/** @param ny url */
		ny: ParamTemplate<ParamType.STRING>;
		/** @param pz url */
		pz: ParamTemplate<ParamType.STRING>;
		/** @param nz url */
		nz: ParamTemplate<ParamType.STRING>;
	};
} & typeof NodeParamsConfig;
declare class CubeMapCopParamsConfig extends CubeMapCopParamsConfig_base {
}
declare class CubeMapCopNode extends TypedCopNode<CubeMapCopParamsConfig> {
	paramsConfig: CubeMapCopParamsConfig;
	static type(): CopType;
	readonly textureParamsController: TextureParamsController;
	initializeNode(): void;
	cook(inputContents: Texture[]): Promise<void>;
	dispose(): void;
	private _loadTexture;
	static PARAM_CALLBACK_reload(node: CubeMapCopNode): void;
	private paramCallbackReload;
}
declare class CubeCameraCopParamsConfig extends NodeParamsConfig {
	/** @param cube camera OBJ node */
	cameraPath: ParamTemplate<ParamType.STRING>;
	/** @param objects to render */
	/** @param defines if the texture is used for reflection or refraction */
	mode: ParamTemplate<ParamType.INTEGER>;
	/** @param transparent background */
	transparentBackground: ParamTemplate<ParamType.BOOLEAN>;
	/** @param bg Color */
	backgroundColor: ParamTemplate<ParamType.COLOR>;
	/** @param autoRender */
	autoRender: ParamTemplate<ParamType.BOOLEAN>;
	/** @param render button */
	render: ParamTemplate<ParamType.BUTTON>;
}
declare class CubeCameraCopNode extends TypedCopNode<CubeCameraCopParamsConfig> {
	paramsConfig: CubeCameraCopParamsConfig;
	static type(): CopType;
	private _rendererController;
	cook(): Promise<void>;
	private _addOnBeforeTickCallback;
	private _removeOnBeforeTickCallback;
	private _onBeforeRenderCallbackName;
	dispose(): void;
	private _getCameraSync;
	private _getCamera;
	private _renderOnTargetBound;
	private _prevCamera;
	private _prevRenderer;
	renderOnTarget(setDirtyIfChangesDetected: boolean): Promise<Texture | undefined>;
	renderTarget(): Promise<CubeTexture | undefined>;
	static PARAM_CALLBACK_render(node: CubeCameraCopNode): void;
}
declare const CubeMapFromSceneCopParamsConfig_base: {
	new (...args: any[]): {
		/** @param force Render */
		blur: ParamTemplate<ParamType.FLOAT>;
		/** @param camera near */
		near: ParamTemplate<ParamType.FLOAT>;
		/** @param camera far */
		far: ParamTemplate<ParamType.FLOAT>;
		/** @param force Render */
		render: ParamTemplate<ParamType.BUTTON>;
	};
} & typeof NodeParamsConfig;
declare class CubeMapFromSceneCopParamsConfig extends CubeMapFromSceneCopParamsConfig_base {
}
declare class CubeMapFromSceneCopNode extends TypedCopNode<CubeMapFromSceneCopParamsConfig> {
	paramsConfig: CubeMapFromSceneCopParamsConfig;
	static type(): CopType;
	private _rendererController;
	private _lastGeneratedRenderTarget;
	lastGeneratedRenderTarget(): WebGLRenderTarget | undefined;
	private _setDirtyBound;
	readonly displayNodeController: DisplayNodeController;
	protected _childrenControllerContext: NodeContext;
	initializeNode(): void;
	dispose(): void;
	createNode<S extends keyof GeoNodeChildrenMap>(node_class: S, options?: NodeCreateOptions): GeoNodeChildrenMap[S];
	createNode<K extends valueof<GeoNodeChildrenMap>>(node_class: Constructor<K>, options?: NodeCreateOptions): K;
	children(): BaseGlNodeType[];
	nodesByType<K extends keyof GeoNodeChildrenMap>(type: K): GeoNodeChildrenMap[K][];
	childrenAllowed(): boolean;
	private _setDirty;
	private _cookMainWithoutInputsWhenDirtyBound;
	private _cookMainWithoutInputsWhenDirty;
	cook(): Promise<void>;
	private _renderScene;
	private _pmremGenerator;
	private _updateRenderScene;
	private _renderCubeMap;
	static PARAM_CALLBACK_render(node: CubeMapFromSceneCopNode): Promise<void>;
}
declare class EnvMapCopParamsConfig extends NodeParamsConfig {
	/** @param defines if the shader is rendered via the same camera used to render the scene */
	useCameraRenderer: ParamTemplate<ParamType.BOOLEAN>;
}
declare class EnvMapCopNode extends TypedCopNode<EnvMapCopParamsConfig> {
	paramsConfig: EnvMapCopParamsConfig;
	static type(): CopType;
	private _dataTextureController;
	private _rendererController;
	initializeNode(): void;
	cook(inputTextures: Texture[]): Promise<void>;
	private _convertTextureToEnvMap;
	private _setMapping;
}
declare class GeometryAttributeCopParamsConfig extends NodeParamsConfig {
	/** @param sop node */
	node: ParamTemplate<ParamType.NODE_PATH>;
	/** @param group to read the material from */
	group: ParamTemplate<ParamType.STRING>;
	/** @param attribute name */
	attribute: ParamTemplate<ParamType.STRING>;
}
declare class GeometryAttributeCopNode extends TypedCopNode<GeometryAttributeCopParamsConfig> {
	paramsConfig: GeometryAttributeCopParamsConfig;
	static type(): "geometryAttribute";
	cook(): Promise<void>;
	private _textureFromGeometry;
}
declare const GifCopParamsConfig_base: {
	new (...args: any[]): {
		tcolorSpace: ParamTemplate<ParamType.BOOLEAN>;
		colorSpace: ParamTemplate<ParamType.STRING>;
		tmapping: ParamTemplate<ParamType.BOOLEAN>;
		mapping: ParamTemplate<ParamType.INTEGER>;
		twrap: ParamTemplate<ParamType.BOOLEAN>;
		wrapS: ParamTemplate<ParamType.INTEGER>;
		wrapT: ParamTemplate<ParamType.INTEGER>;
		tminFilter: ParamTemplate<ParamType.BOOLEAN>;
		minFilter: ParamTemplate<ParamType.INTEGER>;
		tmagFilter: ParamTemplate<ParamType.BOOLEAN>;
		magFilter: ParamTemplate<ParamType.INTEGER>;
		tanisotropy: ParamTemplate<ParamType.BOOLEAN>;
		useRendererMaxAnisotropy: ParamTemplate<ParamType.BOOLEAN>;
		anisotropy: ParamTemplate<ParamType.INTEGER>;
		tflipY: ParamTemplate<ParamType.BOOLEAN>;
		flipY: ParamTemplate<ParamType.BOOLEAN>;
		ttransform: ParamTemplate<ParamType.BOOLEAN>;
		offset: ParamTemplate<ParamType.VECTOR2>;
		repeat: ParamTemplate<ParamType.VECTOR2>;
		rotation: ParamTemplate<ParamType.FLOAT>;
		center: ParamTemplate<ParamType.VECTOR2>;
		tadvanced: ParamTemplate<ParamType.BOOLEAN>;
		tformat: ParamTemplate<ParamType.BOOLEAN>;
		format: ParamTemplate<ParamType.INTEGER>;
		ttype: ParamTemplate<ParamType.BOOLEAN>;
		type: ParamTemplate<ParamType.INTEGER>;
	};
} & {
	new (...args: any[]): {
		/** @param url to fetch the gif from */
		url: ParamTemplate<ParamType.STRING>;
		/** @param reload the image */
		reload: ParamTemplate<ParamType.BUTTON>;
		/** @param play the gif */
		play: ParamTemplate<ParamType.BOOLEAN>;
		/** @param set the gif frame */
		gifFrame: ParamTemplate<ParamType.INTEGER>;
	};
} & typeof NodeParamsConfig;
declare class GifCopParamsConfig extends GifCopParamsConfig_base {
}
declare class GifCopNode extends TypedCopNode<GifCopParamsConfig> {
	paramsConfig: GifCopParamsConfig;
	static type(): CopType;
	readonly textureParamsController: TextureParamsController;
	initializeNode(): void;
	cook(input_contents: Texture[]): Promise<void>;
	private _gifCanvasElement;
	private _gifCanvasContext;
	private _tmpCanvasElement;
	private _tmpCanvasContext;
	private _parsedFrames;
	private _frameDelay;
	private _frameIndex;
	private _frameImageData;
	private _createCanvas;
	private _drawOnCanvas;
	private _drawNextFrame;
	private gifUpdateFrameIndex;
	static PARAM_CALLBACK_reload(node: GifCopNode): void;
	private paramCallbackReload;
	static PARAM_CALLBACK_gifUpdatePlay(node: GifCopNode): void;
	private gifUpdatePlay;
	static PARAM_CALLBACK_gifUpdateFrameIndex(node: GifCopNode): void;
}
declare const BaseImageCopParamsConfig_base: {
	new (...args: any[]): {
		checkFileType: ParamTemplate<ParamType.BOOLEAN>;
	};
} & {
	new (...args: any[]): {
		tcolorSpace: ParamTemplate<ParamType.BOOLEAN>;
		colorSpace: ParamTemplate<ParamType.STRING>;
		tmapping: ParamTemplate<ParamType.BOOLEAN>;
		mapping: ParamTemplate<ParamType.INTEGER>;
		twrap: ParamTemplate<ParamType.BOOLEAN>;
		wrapS: ParamTemplate<ParamType.INTEGER>;
		wrapT: ParamTemplate<ParamType.INTEGER>;
		tminFilter: ParamTemplate<ParamType.BOOLEAN>;
		minFilter: ParamTemplate<ParamType.INTEGER>;
		tmagFilter: ParamTemplate<ParamType.BOOLEAN>;
		magFilter: ParamTemplate<ParamType.INTEGER>;
		tanisotropy: ParamTemplate<ParamType.BOOLEAN>;
		useRendererMaxAnisotropy: ParamTemplate<ParamType.BOOLEAN>;
		anisotropy: ParamTemplate<ParamType.INTEGER>;
		tflipY: ParamTemplate<ParamType.BOOLEAN>;
		flipY: ParamTemplate<ParamType.BOOLEAN>;
		ttransform: ParamTemplate<ParamType.BOOLEAN>;
		offset: ParamTemplate<ParamType.VECTOR2>;
		repeat: ParamTemplate<ParamType.VECTOR2>;
		rotation: ParamTemplate<ParamType.FLOAT>;
		center: ParamTemplate<ParamType.VECTOR2>;
		tadvanced: ParamTemplate<ParamType.BOOLEAN>;
		tformat: ParamTemplate<ParamType.BOOLEAN>;
		format: ParamTemplate<ParamType.INTEGER>;
		ttype: ParamTemplate<ParamType.BOOLEAN>;
		type: ParamTemplate<ParamType.INTEGER>;
	};
} & {
	new (...args: any[]): {
		/** @param url to fetch the image from */
		url: ParamTemplate<ParamType.STRING>;
		/** @param reload the image */
		reload: ParamTemplate<ParamType.BUTTON>;
	};
} & typeof NodeParamsConfig;
declare class BaseImageCopParamsConfig extends BaseImageCopParamsConfig_base {
}
declare class copImageNodeFactoryFactoryResult extends TypedCopNode<BaseImageCopParamsConfig> {
	paramsConfig: BaseImageCopParamsConfig;
	readonly textureParamsController: TextureParamsController;
}
declare const ImageCopNode_base: typeof copImageNodeFactoryFactoryResult;
declare class ImageCopNode extends ImageCopNode_base {
}
declare const ImageEXRCopNode_base: typeof copImageNodeFactoryFactoryResult;
declare class ImageEXRCopNode extends ImageEXRCopNode_base {
}
declare const ImageHDRCopNode_base: typeof copImageNodeFactoryFactoryResult;
declare class ImageHDRCopNode extends ImageHDRCopNode_base {
}
declare const ImageKTX2CopNode_base: typeof copImageNodeFactoryFactoryResult;
declare class ImageKTX2CopNode extends ImageKTX2CopNode_base {
}
declare class LightMapCopParamConfig extends NodeParamsConfig {
	/** @param click to update shadow, when mode is manual */
	update: ParamTemplate<ParamType.BUTTON>;
	/** @param defines if the shader is rendered via the same camera used to render the scene */
	useCameraRenderer: ParamTemplate<ParamType.BOOLEAN>;
	/** @param shadow resolution */
	lightMapRes: ParamTemplate<ParamType.INTEGER>;
	/** @param iterations */
	iterations: ParamTemplate<ParamType.INTEGER>;
	/** @param blendWindow */
	/** @param blurEdges */
	blur: ParamTemplate<ParamType.BOOLEAN>;
	/** @param blurAmount */
	blurAmount: ParamTemplate<ParamType.FLOAT>;
	/** @param lightPositionVariation */
	lightRadius: ParamTemplate<ParamType.FLOAT>;
	objectsMask: ParamTemplate<ParamType.STRING>;
	lightsMask: ParamTemplate<ParamType.STRING>;
}
declare class LightMapCopNode extends TypedCopNode<LightMapCopParamConfig> {
	paramsConfig: LightMapCopParamConfig;
	static type(): Readonly<CopType.LIGHT_MAP>;
	private lightMapController;
	private _includedObjects;
	private _includedLights;
	private _dataTextureController;
	private _rendererController;
	cook(): Promise<void>;
	private _createLightMapController;
	private _render;
	static PARAM_CALLBACK_updateManual(node: LightMapCopNode): void;
	private _updateObjectsAndLightsList;
}
declare class LutCopParamsConfig extends NodeParamsConfig {
	/** @param url to fetch the lut from */
	url: ParamTemplate<ParamType.STRING>;
	/** @param reload the image */
	reload: ParamTemplate<ParamType.BUTTON>;
}
declare class LutCopNode extends TypedCopNode<LutCopParamsConfig> {
	paramsConfig: LutCopParamsConfig;
	static type(): CopType;
	initializeNode(): void;
	cook(input_contents: Texture[]): Promise<void>;
	static PARAM_CALLBACK_reload(node: LutCopNode): void;
	private paramCallbackReload;
}
declare class MapboxElevationCopParamsConfig extends NodeParamsConfig {
	/** @param longitude */
	longitude: ParamTemplate<ParamType.FLOAT>;
	/** @param latitude */
	latitude: ParamTemplate<ParamType.FLOAT>;
	/** @param zoom value */
	zoom: ParamTemplate<ParamType.INTEGER>;
	/** @param highres */
	highres: ParamTemplate<ParamType.BOOLEAN>;
	/** @param source range */
	sourceRange: ParamTemplate<ParamType.VECTOR2>;
	/** @param updateRange */
	updateRange: ParamTemplate<ParamType.BOOLEAN>;
	/** @param min */
	min: ParamTemplate<ParamType.FLOAT>;
	/** @param mult */
	mult: ParamTemplate<ParamType.FLOAT>;
}
declare class MapboxElevationCopNode extends TypedCopNode<MapboxElevationCopParamsConfig> {
	paramsConfig: MapboxElevationCopParamsConfig;
	static type(): string;
	cook(): Promise<void>;
	private _cookForElevation;
	private _url;
	private _createTexture;
}
declare class MapboxSatelliteCopParamsConfig extends NodeParamsConfig {
	/** @param longitude */
	longitude: ParamTemplate<ParamType.FLOAT>;
	/** @param latitude */
	latitude: ParamTemplate<ParamType.FLOAT>;
	/** @param zoom value */
	zoom: ParamTemplate<ParamType.INTEGER>;
	/** @param highres */
	highres: ParamTemplate<ParamType.BOOLEAN>;
}
declare class MapboxSatelliteCopNode extends TypedCopNode<MapboxSatelliteCopParamsConfig> {
	paramsConfig: MapboxSatelliteCopParamsConfig;
	static type(): string;
	cook(): Promise<void>;
	private _cookForSatellite;
	private _url;
	private _createTexture;
}
declare class NullCopNode extends TypedCopNode<NodeParamsConfig> {
	paramsConfig: NodeParamsConfig;
	static type(): string;
	initializeNode(): void;
	cook(input_contents: Texture[]): Promise<void>;
}
declare class PaletteController<NC extends NodeContext> {
	private node;
	constructor(node: PaletteAbstractNode<NC>);
	static PARAM_CALLBACK_pickNext(node: PaletteAbstractNode<any>): void;
	static PARAM_CALLBACK_pickPrevious(node: PaletteAbstractNode<any>): void;
	static PARAM_CALLBACK_pickRandom(node: PaletteAbstractNode<any>): void;
	static PARAM_CALLBACK_updateColors(node: PaletteAbstractNode<any>): void;
	PARAM_CALLBACK_pickNext(): void;
	PARAM_CALLBACK_pickPrevious(): void;
	PARAM_CALLBACK_pickRandom(): void;
	private _batchUpdatesWithPalette;
	PARAM_CALLBACK_updateColors(): void;
	private _updateColors;
}
declare class PaletteAbstractNodeParamsConfig extends NodeParamsConfig {
	/** @param name of the palette */
	paletteName: ParamTemplate<ParamType.STRING>;
	/** @param click to set the node to the next palette */
	pickNext: ParamTemplate<ParamType.BUTTON>;
	/** @param click to set the node to the previous palette */
	pickPrevious: ParamTemplate<ParamType.BUTTON>;
	/** @param click to set the node to a random palette */
	pickRandom: ParamTemplate<ParamType.BUTTON>;
	colorsCount: ParamTemplate<ParamType.INTEGER>;
	/** @param palette color 1 */
	color1: ParamTemplate<ParamType.COLOR>;
	/** @param palette color 2 */
	color2: ParamTemplate<ParamType.COLOR>;
	/** @param palette color 3 */
	color3: ParamTemplate<ParamType.COLOR>;
	/** @param palette color 4 */
	color4: ParamTemplate<ParamType.COLOR>;
	/** @param palette color 5 */
	color5: ParamTemplate<ParamType.COLOR>;
}
declare class PaletteAbstractNode<NC extends NodeContext> extends TypedNode<NC, PaletteAbstractNodeParamsConfig> {
	paramsConfig: PaletteAbstractNodeParamsConfig;
	readonly paletteController: PaletteController<NC>;
}
declare class PaletteCopParamsConfig extends NodeParamsConfig {
	/** @param texture resolution */
	resolution: ParamTemplate<ParamType.VECTOR2>;
	/** @param name of the palette */
	paletteName: ParamTemplate<ParamType.STRING>;
	/** @param click to set the node to the next palette */
	pickNext: ParamTemplate<ParamType.BUTTON>;
	/** @param click to set the node to the previous palette */
	pickPrevious: ParamTemplate<ParamType.BUTTON>;
	/** @param click to set the node to a random palette */
	pickRandom: ParamTemplate<ParamType.BUTTON>;
	colorsCount: ParamTemplate<ParamType.INTEGER>;
	/** @param palette color 1 */
	color1: ParamTemplate<ParamType.COLOR>;
	/** @param palette color 2 */
	color2: ParamTemplate<ParamType.COLOR>;
	/** @param palette color 3 */
	color3: ParamTemplate<ParamType.COLOR>;
	/** @param palette color 4 */
	color4: ParamTemplate<ParamType.COLOR>;
	/** @param palette color 5 */
	color5: ParamTemplate<ParamType.COLOR>;
}
declare class PaletteCopNode extends TypedCopNode<PaletteCopParamsConfig> {
	paramsConfig: PaletteCopParamsConfig;
	static type(): string;
	readonly paletteController: PaletteController<NodeContext.COP>;
	private _dataTexture;
	private _colorParams;
	initializeNode(): void;
	private _colors;
	cook(): void;
	private _intervalIndex;
	private _createDataTexture;
	private _createPixelBuffer;
	static PARAM_CALLBACK_reset(node: PaletteCopNode): void;
	private _reset;
}
declare class FetchCopParamsConfig extends NodeParamsConfig {
	/** @param sop node */
	node: ParamTemplate<ParamType.NODE_PATH>;
	/** @param group to read the material from */
	group: ParamTemplate<ParamType.STRING>;
	/** @param texture name */
	name: ParamTemplate<ParamType.STRING>;
}
declare class FetchCopNode extends TypedCopNode<FetchCopParamsConfig> {
	paramsConfig: FetchCopParamsConfig;
	static type(): "fetch";
	cook(): Promise<void>;
	private _textureFromMaterial;
}
declare const RenderCopParamConfig_base: {
	new (...args: any[]): {
		tcolorSpace: ParamTemplate<ParamType.BOOLEAN>;
		colorSpace: ParamTemplate<ParamType.STRING>;
		tmapping: ParamTemplate<ParamType.BOOLEAN>;
		mapping: ParamTemplate<ParamType.INTEGER>;
		twrap: ParamTemplate<ParamType.BOOLEAN>;
		wrapS: ParamTemplate<ParamType.INTEGER>;
		wrapT: ParamTemplate<ParamType.INTEGER>;
		tminFilter: ParamTemplate<ParamType.BOOLEAN>;
		minFilter: ParamTemplate<ParamType.INTEGER>;
		tmagFilter: ParamTemplate<ParamType.BOOLEAN>;
		magFilter: ParamTemplate<ParamType.INTEGER>;
		tanisotropy: ParamTemplate<ParamType.BOOLEAN>;
		useRendererMaxAnisotropy: ParamTemplate<ParamType.BOOLEAN>;
		anisotropy: ParamTemplate<ParamType.INTEGER>;
		tflipY: ParamTemplate<ParamType.BOOLEAN>;
		flipY: ParamTemplate<ParamType.BOOLEAN>;
		ttransform: ParamTemplate<ParamType.BOOLEAN>;
		offset: ParamTemplate<ParamType.VECTOR2>;
		repeat: ParamTemplate<ParamType.VECTOR2>;
		rotation: ParamTemplate<ParamType.FLOAT>;
		center: ParamTemplate<ParamType.VECTOR2>;
		tadvanced: ParamTemplate<ParamType.BOOLEAN>;
		tformat: ParamTemplate<ParamType.BOOLEAN>;
		format: ParamTemplate<ParamType.INTEGER>;
		ttype: ParamTemplate<ParamType.BOOLEAN>;
		type: ParamTemplate<ParamType.INTEGER>;
	};
} & {
	new (...args: any[]): {
		/** @param path to the main camera object that will be used when the scene loads outside of the editor */
		cameraPath: ParamTemplate<ParamType.STRING>;
		/** @param transparent background */
		transparentBackground: ParamTemplate<ParamType.BOOLEAN>;
		/** @param bg Color */
		backgroundColor: ParamTemplate<ParamType.COLOR>;
		/** @param use same resolution as renderer */
		useRendererRes: ParamTemplate<ParamType.BOOLEAN>;
		/** @param render resolution */
		resolution: ParamTemplate<ParamType.VECTOR2>;
		/** @param use a data texture instead of a render target, which can be useful when using that texture as and envMap */
		useDataTexture: ParamTemplate<ParamType.BOOLEAN>;
		/** @param autoRender */
		autoRender: ParamTemplate<ParamType.BOOLEAN>;
		/** @param render button */
		render: ParamTemplate<ParamType.BUTTON>;
	};
} & typeof NodeParamsConfig;
declare class RenderCopParamConfig extends RenderCopParamConfig_base {
}
declare class RenderCopNode extends TypedCopNode<RenderCopParamConfig> {
	paramsConfig: RenderCopParamConfig;
	static type(): Readonly<CopType.RENDER>;
	readonly textureParamsController: TextureParamsController;
	private _rendererController;
	private _dataTextureController;
	private _renderTargetByRenderer;
	cook(): Promise<void>;
	private _addOnBeforeTickCallback;
	private _removeOnBeforeTickCallback;
	private _onBeforeRenderCallbackName;
	dispose(): void;
	private _getCameraSync;
	private _getCamera;
	private _renderOnTargetBound;
	renderOnTarget(): Promise<void>;
	renderTarget(renderer: WebGLRenderer): Promise<WebGLRenderTarget | undefined>;
	private createRenderTargetIfRequired;
	private _requestedResolution;
	private _ensureRenderTargetResolutionValid;
	private _createRenderTarget;
	static PARAM_CALLBACK_render(node: RenderCopNode): void;
}
declare class SDFBlurCopParamsConfig extends NodeParamsConfig {
	/** @param resolution */
	resolution: ParamTemplate<ParamType.VECTOR3>;
	/** @param boundMin */
	boundMin: ParamTemplate<ParamType.VECTOR3>;
	/** @param boundMax */
	boundMax: ParamTemplate<ParamType.VECTOR3>;
}
declare class SDFBlurCopNode extends TypedCopNode<SDFBlurCopParamsConfig> {
	paramsConfig: SDFBlurCopParamsConfig;
	static type(): CopType;
	initializeNode(): void;
	cook(inputContents: Texture[]): Promise<void>;
}
declare class SDFExporterCopParamsConfig extends NodeParamsConfig {
	/** @param fileName */
	fileName: ParamTemplate<ParamType.STRING>;
	/** @param download texture */
	download: ParamTemplate<ParamType.BUTTON>;
}
declare class SDFExporterCopNode extends TypedCopNode<SDFExporterCopParamsConfig> {
	paramsConfig: SDFExporterCopParamsConfig;
	static type(): string;
	initializeNode(): void;
	cook(inputContents: Texture[]): Promise<void>;
	static PARAM_CALLBACK_download(node: SDFExporterCopNode): void;
	private _downloadTexture;
}
interface FillTextureOptions {
	resolution: Vector3;
	bbox: Box3;
	bboxSize: Vector3;
	voxelSizes: Vector3;
}
declare class SDFFromObjectCopParamsConfig extends NodeParamsConfig {
	/** @param which SOP node to import from */
	geometry: ParamTemplate<ParamType.NODE_PATH>;
	/** @param voxelSize */
	voxelSize: ParamTemplate<ParamType.FLOAT>;
	/** @param padding */
	padding: ParamTemplate<ParamType.INTEGER>;
	/** @param resolution */
	resolution: ParamTemplate<ParamType.VECTOR3>;
	/** @param boundMin */
	boundMin: ParamTemplate<ParamType.VECTOR3>;
	/** @param boundMax */
	boundMax: ParamTemplate<ParamType.VECTOR3>;
}
declare class SDFFromObjectCopNode extends TypedCopNode<SDFFromObjectCopParamsConfig> {
	paramsConfig: SDFFromObjectCopParamsConfig;
	static type(): CopType;
	cook(inputContents: Texture[]): Promise<void>;
	_fillTexture(object: MeshWithBVH, options: FillTextureOptions): Data3DTexture;
	private __dataTexture;
	private _resolutionUsed;
	_dataTexture(resolution: Vector3): Data3DTexture;
	private createTextureTargetIfRequired;
	private _textureResolutionValid;
	private _createTexture;
}
declare class SDFFromUrlCopParamsConfig extends NodeParamsConfig {
	/** @param url to fetch the image from */
	url: ParamTemplate<ParamType.STRING>;
	/** @param reload */
	reload: ParamTemplate<ParamType.BUTTON>;
	/** @param resolution */
	resolution: ParamTemplate<ParamType.VECTOR3>;
	/** @param boundMin */
	boundMin: ParamTemplate<ParamType.VECTOR3>;
	/** @param boundMax */
	boundMax: ParamTemplate<ParamType.VECTOR3>;
}
declare class SDFFromUrlCopNode extends TypedCopNode<SDFFromUrlCopParamsConfig> {
	paramsConfig: SDFFromUrlCopParamsConfig;
	static type(): CopType;
	cook(inputContents: Texture[]): Promise<void>;
	static PARAM_CALLBACK_reload(node: SDFFromUrlCopNode): void;
}
declare const SnapshotCopParamsConfig_base: {
	new (...args: any[]): {
		/** @param capture */
		capture: ParamTemplate<ParamType.BUTTON>;
	};
} & typeof NodeParamsConfig;
declare class SnapshotCopParamsConfig extends SnapshotCopParamsConfig_base {
}
declare class SnapshotCopNode extends TypedCopNode<SnapshotCopParamsConfig> {
	paramsConfig: SnapshotCopParamsConfig;
	static type(): CopType;
	initializeNode(): void;
	cook(inputTextures: Texture[]): Promise<void>;
	static PARAM_CALLBACK_snapshot(node: SnapshotCopNode): void;
	private paramCallbackSnapshot;
	private _videoSnapshotCanvas;
	private _canvas;
	private _canvasTexture;
}
declare class SwitchCopParamsConfig extends NodeParamsConfig {
	/** @param input index */
	input: ParamTemplate<ParamType.INTEGER>;
}
declare class SwitchCopNode extends TypedCopNode<SwitchCopParamsConfig> {
	paramsConfig: SwitchCopParamsConfig;
	static type(): string;
	initializeNode(): void;
	cook(): Promise<void>;
	private _callbackUpdateInputsEvaluation;
	static PARAM_CALLBACK_setInputsEvaluation(node: SwitchCopNode): void;
}
declare const TextCopParamConfig_base: {
	new (...args: any[]): {
		tcolorSpace: ParamTemplate<ParamType.BOOLEAN>;
		colorSpace: ParamTemplate<ParamType.STRING>;
		tmapping: ParamTemplate<ParamType.BOOLEAN>;
		mapping: ParamTemplate<ParamType.INTEGER>;
		twrap: ParamTemplate<ParamType.BOOLEAN>;
		wrapS: ParamTemplate<ParamType.INTEGER>;
		wrapT: ParamTemplate<ParamType.INTEGER>;
		tminFilter: ParamTemplate<ParamType.BOOLEAN>;
		minFilter: ParamTemplate<ParamType.INTEGER>;
		tmagFilter: ParamTemplate<ParamType.BOOLEAN>;
		magFilter: ParamTemplate<ParamType.INTEGER>;
		tanisotropy: ParamTemplate<ParamType.BOOLEAN>;
		useRendererMaxAnisotropy: ParamTemplate<ParamType.BOOLEAN>;
		anisotropy: ParamTemplate<ParamType.INTEGER>;
		tflipY: ParamTemplate<ParamType.BOOLEAN>;
		flipY: ParamTemplate<ParamType.BOOLEAN>;
		ttransform: ParamTemplate<ParamType.BOOLEAN>;
		offset: ParamTemplate<ParamType.VECTOR2>;
		repeat: ParamTemplate<ParamType.VECTOR2>;
		rotation: ParamTemplate<ParamType.FLOAT>;
		center: ParamTemplate<ParamType.VECTOR2>;
		tadvanced: ParamTemplate<ParamType.BOOLEAN>;
		tformat: ParamTemplate<ParamType.BOOLEAN>;
		format: ParamTemplate<ParamType.INTEGER>;
		ttype: ParamTemplate<ParamType.BOOLEAN>;
		type: ParamTemplate<ParamType.INTEGER>;
	};
} & {
	new (...args: any[]): {
		/** @param font used */
		font: ParamTemplate<ParamType.STRING>;
		/** @param text created */
		text: ParamTemplate<ParamType.STRING>;
		/** @param render resolution */
		resolution: ParamTemplate<ParamType.VECTOR2>;
		/** @param font size */
		fontSize: ParamTemplate<ParamType.INTEGER>;
		/** @param background color */
		bgColor: ParamTemplate<ParamType.COLOR>;
		/** @param background alpha */
		bgAlpha: ParamTemplate<ParamType.FLOAT>;
		/** @param text color */
		textColor: ParamTemplate<ParamType.COLOR>;
		/** @param text alpha */
		textAlpha: ParamTemplate<ParamType.FLOAT>;
	};
} & typeof NodeParamsConfig;
declare class TextCopParamConfig extends TextCopParamConfig_base {
}
declare class TextCopNode extends TypedCopNode<TextCopParamConfig> {
	paramsConfig: TextCopParamConfig;
	static type(): Readonly<CopType.TEXT>;
	readonly textureParamsController: TextureParamsController;
	private __dataTexture;
	cook(): Promise<void>;
	private _dataTexture;
	private _dataTextureResolutionValid;
	private _requestedResolution;
	private _createDataTexture;
}
declare const TexturePropertiesCopParamsConfig_base: {
	new (...args: any[]): {
		tcolorSpace: ParamTemplate<ParamType.BOOLEAN>;
		colorSpace: ParamTemplate<ParamType.STRING>;
		tmapping: ParamTemplate<ParamType.BOOLEAN>;
		mapping: ParamTemplate<ParamType.INTEGER>;
		twrap: ParamTemplate<ParamType.BOOLEAN>;
		wrapS: ParamTemplate<ParamType.INTEGER>;
		wrapT: ParamTemplate<ParamType.INTEGER>;
		tminFilter: ParamTemplate<ParamType.BOOLEAN>;
		minFilter: ParamTemplate<ParamType.INTEGER>;
		tmagFilter: ParamTemplate<ParamType.BOOLEAN>;
		magFilter: ParamTemplate<ParamType.INTEGER>;
		tanisotropy: ParamTemplate<ParamType.BOOLEAN>;
		useRendererMaxAnisotropy: ParamTemplate<ParamType.BOOLEAN>;
		anisotropy: ParamTemplate<ParamType.INTEGER>;
		tflipY: ParamTemplate<ParamType.BOOLEAN>;
		flipY: ParamTemplate<ParamType.BOOLEAN>;
		ttransform: ParamTemplate<ParamType.BOOLEAN>;
		offset: ParamTemplate<ParamType.VECTOR2>;
		repeat: ParamTemplate<ParamType.VECTOR2>;
		rotation: ParamTemplate<ParamType.FLOAT>;
		center: ParamTemplate<ParamType.VECTOR2>;
		tadvanced: ParamTemplate<ParamType.BOOLEAN>;
		tformat: ParamTemplate<ParamType.BOOLEAN>;
		format: ParamTemplate<ParamType.INTEGER>;
		ttype: ParamTemplate<ParamType.BOOLEAN>;
		type: ParamTemplate<ParamType.INTEGER>;
	};
} & typeof NodeParamsConfig;
declare class TexturePropertiesCopParamsConfig extends TexturePropertiesCopParamsConfig_base {
}
declare class TexturePropertiesCopNode extends TypedCopNode<TexturePropertiesCopParamsConfig> {
	paramsConfig: TexturePropertiesCopParamsConfig;
	static type(): string;
	readonly textureParamsController: TextureParamsController;
	initializeNode(): void;
	cook(input_contents: Texture[]): Promise<void>;
}
declare enum VideoMode {
	FROM_URLS = "From Urls",
	FROM_HTML_ELEMENT = "From HTML Element"
}
declare const VideoCopParamsConfig_base: {
	new (...args: any[]): {
		checkFileType: ParamTemplate<ParamType.BOOLEAN>;
	};
} & {
	new (...args: any[]): {
		tcolorSpace: ParamTemplate<ParamType.BOOLEAN>;
		colorSpace: ParamTemplate<ParamType.STRING>;
		tmapping: ParamTemplate<ParamType.BOOLEAN>;
		mapping: ParamTemplate<ParamType.INTEGER>;
		twrap: ParamTemplate<ParamType.BOOLEAN>;
		wrapS: ParamTemplate<ParamType.INTEGER>;
		wrapT: ParamTemplate<ParamType.INTEGER>;
		tminFilter: ParamTemplate<ParamType.BOOLEAN>;
		minFilter: ParamTemplate<ParamType.INTEGER>;
		tmagFilter: ParamTemplate<ParamType.BOOLEAN>;
		magFilter: ParamTemplate<ParamType.INTEGER>;
		tanisotropy: ParamTemplate<ParamType.BOOLEAN>;
		useRendererMaxAnisotropy: ParamTemplate<ParamType.BOOLEAN>;
		anisotropy: ParamTemplate<ParamType.INTEGER>;
		tflipY: ParamTemplate<ParamType.BOOLEAN>;
		flipY: ParamTemplate<ParamType.BOOLEAN>;
		ttransform: ParamTemplate<ParamType.BOOLEAN>;
		offset: ParamTemplate<ParamType.VECTOR2>;
		repeat: ParamTemplate<ParamType.VECTOR2>;
		rotation: ParamTemplate<ParamType.FLOAT>;
		center: ParamTemplate<ParamType.VECTOR2>;
		tadvanced: ParamTemplate<ParamType.BOOLEAN>;
		tformat: ParamTemplate<ParamType.BOOLEAN>;
		format: ParamTemplate<ParamType.INTEGER>;
		ttype: ParamTemplate<ParamType.BOOLEAN>;
		type: ParamTemplate<ParamType.INTEGER>;
	};
} & {
	new (...args: any[]): {
		/** @param mode */
		mode: ParamTemplate<ParamType.INTEGER>;
		/** @param number of video files to fetch */
		urlsCount: ParamTemplate<ParamType.INTEGER>;
		/** @param url to fetch the video from */
		url1: ParamTemplate<ParamType.STRING>;
		/** @param url to fetch the video from */
		url2: ParamTemplate<ParamType.STRING>;
		/** @param url to fetch the video from */
		url3: ParamTemplate<ParamType.STRING>;
		/** @param selector */
		selector: ParamTemplate<ParamType.STRING>;
		/** @param reload the video */
		reload: ParamTemplate<ParamType.BUTTON>;
		/** @param play the video */
		play: ParamTemplate<ParamType.BOOLEAN>;
		/** @param set the video muted attribute */
		muted: ParamTemplate<ParamType.BOOLEAN>;
		/** @param set the video loop attribute */
		loop: ParamTemplate<ParamType.BOOLEAN>;
		/** @param set the video time */
		videoTime: ParamTemplate<ParamType.FLOAT>;
		/** @param seek the video at the time specified in videoTime */
		setVideoTime: ParamTemplate<ParamType.BUTTON>;
	};
} & typeof NodeParamsConfig;
declare class VideoCopParamsConfig extends VideoCopParamsConfig_base {
}
declare class VideoCopNode extends TypedCopNode<VideoCopParamsConfig> {
	paramsConfig: VideoCopParamsConfig;
	static type(): CopType;
	private _video;
	HTMLVideoElement(): HTMLVideoElement | undefined;
	readonly textureParamsController: TextureParamsController;
	initializeNode(): void;
	dispose(): void;
	private _disposeHTMLVideoElement;
	setMode(mode: VideoMode): void;
	mode(): VideoMode;
	cook(input_contents: Texture[]): Promise<void>;
	private _videoBoundEvents;
	private _addVideoEvents;
	private _removeVideoEvents;
	private _onVideoEvent;
	private _onVideoEventPlay;
	private _onVideoEventPause;
	private _onVideoEventTimeUpdate;
	private _onVideoEventVolumeChange;
	videoStatePlaying(): boolean;
	videoStateMuted(): boolean;
	videoDuration(): number;
	videoCurrentTime(): number;
	static PARAM_CALLBACK_videoUpdateTime(node: VideoCopNode): void;
	private videoUpdateTime;
	private _videoUpdateTime;
	static PARAM_CALLBACK_videoUpdatePlay(node: VideoCopNode): void;
	private videoUpdatePlay;
	private _videoUpdatePlay;
	static PARAM_CALLBACK_videoUpdateMuted(node: VideoCopNode): void;
	private videoUpdateMuted;
	private _videoUpdateMuted;
	static PARAM_CALLBACK_videoUpdateLoop(node: VideoCopNode): void;
	private videoUpdateLoop;
	private _videoUpdateLoop;
	private _videoTextureFromSelector;
	urlParams(): StringParam[];
	private _urlsToLoad;
	static PARAM_CALLBACK_reload(node: VideoCopNode, param: BaseParamType): void;
	private paramCallbackReload;
	private _loadTexture;
}
declare enum WebCamFacingMode {
	USER = "user",
	ENVIRONMENT = "environment"
}
declare const WebCamCopParamsConfig_base: {
	new (...args: any[]): {
		tcolorSpace: ParamTemplate<ParamType.BOOLEAN>;
		colorSpace: ParamTemplate<ParamType.STRING>;
		tmapping: ParamTemplate<ParamType.BOOLEAN>;
		mapping: ParamTemplate<ParamType.INTEGER>;
		twrap: ParamTemplate<ParamType.BOOLEAN>;
		wrapS: ParamTemplate<ParamType.INTEGER>;
		wrapT: ParamTemplate<ParamType.INTEGER>;
		tminFilter: ParamTemplate<ParamType.BOOLEAN>;
		minFilter: ParamTemplate<ParamType.INTEGER>;
		tmagFilter: ParamTemplate<ParamType.BOOLEAN>;
		magFilter: ParamTemplate<ParamType.INTEGER>;
		tanisotropy: ParamTemplate<ParamType.BOOLEAN>;
		useRendererMaxAnisotropy: ParamTemplate<ParamType.BOOLEAN>;
		anisotropy: ParamTemplate<ParamType.INTEGER>;
		tflipY: ParamTemplate<ParamType.BOOLEAN>;
		flipY: ParamTemplate<ParamType.BOOLEAN>;
		ttransform: ParamTemplate<ParamType.BOOLEAN>;
		offset: ParamTemplate<ParamType.VECTOR2>;
		repeat: ParamTemplate<ParamType.VECTOR2>;
		rotation: ParamTemplate<ParamType.FLOAT>;
		center: ParamTemplate<ParamType.VECTOR2>;
		tadvanced: ParamTemplate<ParamType.BOOLEAN>;
		tformat: ParamTemplate<ParamType.BOOLEAN>;
		format: ParamTemplate<ParamType.INTEGER>;
		ttype: ParamTemplate<ParamType.BOOLEAN>;
		type: ParamTemplate<ParamType.INTEGER>;
	};
} & {
	new (...args: any[]): {
		/** @param texture resolution */
		res: ParamTemplate<ParamType.VECTOR2>;
		/** @param facingMode (on a mobile device, 'user' is the front camera, 'environment' is the back one ) */
		facingMode: ParamTemplate<ParamType.INTEGER>;
	};
} & typeof NodeParamsConfig;
declare class WebCamCopParamsConfig extends WebCamCopParamsConfig_base {
}
declare class WebCamCopNode extends TypedCopNode<WebCamCopParamsConfig> {
	paramsConfig: WebCamCopParamsConfig;
	static type(): CopType;
	private _video;
	HTMLVideoElement(): HTMLVideoElement | undefined;
	readonly textureParamsController: TextureParamsController;
	initializeNode(): void;
	dispose(): void;
	setFacingMode(facingMode: WebCamFacingMode): void;
	private _stream;
	private _cancelWebcamRequest;
	private _createHTMLVideoElement;
	cook(inputContents: Texture[]): Promise<void>;
}
declare class ParamLessNetworkCopParamsConfig extends NodeParamsConfig {
}
declare class BaseNetworkCopNode<K extends NodeParamsConfig> extends TypedNode<NodeContext.COP, K> {
	static context(): NodeContext;
	cook(): void;
}
declare class ParamLessBaseNetworkCopNode extends BaseNetworkCopNode<ParamLessNetworkCopParamsConfig> {
}
declare class ActorsNetworkCopNode extends ParamLessBaseNetworkCopNode {
	static type(): NetworkNodeType;
	protected _childrenControllerContext: NodeContext;
	createNode<S extends keyof JsNodeChildrenMap>(node_class: S, options?: NodeCreateOptions): JsNodeChildrenMap[S];
	createNode<K extends valueof<JsNodeChildrenMap>>(node_class: Constructor<K>, options?: NodeCreateOptions): K;
	children(): BaseJsNodeType[];
	nodesByType<K extends keyof JsNodeChildrenMap>(type: K): JsNodeChildrenMap[K][];
	childrenAllowed(): boolean;
	sceneReadonly(): boolean;
	readonly persisted_config: ActorPersistedConfig;
	assemblerController(): JsAssemblerController<JsAssemblerActor> | undefined;
	usedAssembler(): Readonly<AssemblerName.JS_ACTOR>;
	protected _assemblerController: JsAssemblerController<JsAssemblerActor> | undefined;
	private _createAssemblerController;
	readonly compilationController: ActorCompilationController;
	compile(): void;
	cook(): void;
}
declare class AnimationsNetworkCopNode extends ParamLessBaseNetworkCopNode {
	static type(): NetworkNodeType;
	protected _childrenControllerContext: NodeContext;
	createNode<S extends keyof AnimNodeChildrenMap>(node_class: S, options?: NodeCreateOptions): AnimNodeChildrenMap[S];
	createNode<K extends valueof<AnimNodeChildrenMap>>(node_class: Constructor<K>, options?: NodeCreateOptions): K;
	children(): BaseAnimNodeType[];
	nodesByType<K extends keyof AnimNodeChildrenMap>(type: K): AnimNodeChildrenMap[K][];
}
declare class AudioNetworkCopNode extends ParamLessBaseNetworkCopNode {
	static type(): NetworkNodeType;
	protected _childrenControllerContext: NodeContext;
	createNode<S extends keyof AudioNodeChildrenMap>(node_class: S, options?: NodeCreateOptions): AudioNodeChildrenMap[S];
	createNode<K extends valueof<AudioNodeChildrenMap>>(node_class: Constructor<K>, options?: NodeCreateOptions): K;
	children(): BaseAudioNodeType[];
	nodesByType<K extends keyof AudioNodeChildrenMap>(type: K): AudioNodeChildrenMap[K][];
}
declare class EventsNetworkCopNode extends ParamLessBaseNetworkCopNode {
	static type(): NetworkNodeType;
	protected _childrenControllerContext: NodeContext;
	createNode<S extends keyof EventNodeChildrenMap>(node_class: S, options?: NodeCreateOptions): EventNodeChildrenMap[S];
	createNode<K extends valueof<EventNodeChildrenMap>>(node_class: Constructor<K>, options?: NodeCreateOptions): K;
	children(): BaseEventNodeType[];
	nodesByType<K extends keyof EventNodeChildrenMap>(type: K): EventNodeChildrenMap[K][];
}
declare class CopNetworkCopNode extends ParamLessBaseNetworkCopNode {
	static type(): NetworkNodeType;
	protected _childrenControllerContext: NodeContext;
	createNode<S extends keyof CopNodeChildrenMap>(node_class: S, options?: NodeCreateOptions): CopNodeChildrenMap[S];
	createNode<K extends valueof<CopNodeChildrenMap>>(node_class: Constructor<K>, options?: NodeCreateOptions): K;
	children(): BaseCopNodeType[];
	nodesByType<K extends keyof CopNodeChildrenMap>(type: K): CopNodeChildrenMap[K][];
}
declare class MaterialsNetworkCopNode extends ParamLessBaseNetworkCopNode {
	static type(): NetworkNodeType;
	protected _childrenControllerContext: NodeContext;
	createNode<S extends keyof MatNodeChildrenMap>(node_class: S, options?: NodeCreateOptions): MatNodeChildrenMap[S];
	createNode<K extends valueof<MatNodeChildrenMap>>(node_class: Constructor<K>, options?: NodeCreateOptions): K;
	children(): BaseMatNodeType[];
	nodesByType<K extends keyof MatNodeChildrenMap>(type: K): MatNodeChildrenMap[K][];
}
declare const PostProcessNetworkParamsConfig_base: {
	new (...args: any[]): {
		prependRenderPass: ParamTemplate<ParamType.BOOLEAN>;
		depthBuffer: ParamTemplate<ParamType.BOOLEAN>;
		stencilBuffer: ParamTemplate<ParamType.BOOLEAN>;
		sampling: ParamTemplate<ParamType.INTEGER>;
		tTextureType: ParamTemplate<ParamType.BOOLEAN>;
		textureType: ParamTemplate<ParamType.INTEGER>;
	};
} & typeof NodeParamsConfig;
declare class PostProcessNetworkParamsConfig extends PostProcessNetworkParamsConfig_base {
}
interface BaseNetworkPostProcessNodeType extends TypedNode<any, PostProcessNetworkParamsConfig> {
	readonly displayNodeController: DisplayNodeController;
	createNode<S extends keyof PostNodeChildrenMap>(node_class: S): PostNodeChildrenMap[S];
	createNode<K extends valueof<PostNodeChildrenMap>>(node_class: Constructor<K>): K;
	children(): BasePostProcessNodeType[];
	nodesByType<K extends keyof PostNodeChildrenMap>(type: K): PostNodeChildrenMap[K][];
	readonly effectsComposerController: EffectComposerController;
}
interface CreateEffectsComposerOptions {
	renderer: WebGLRenderer;
	scene: Scene;
	camera: Camera;
	viewer: BaseViewerType;
}
declare class EffectComposerController {
	private node;
	private _composerAndOptionsByCamera;
	constructor(node: BaseNetworkPostProcessNodeType);
	displayNodeControllerCallbacks(): DisplayNodeControllerCallbacks;
	private _nextId;
	createEffectsComposer(options: CreateEffectsComposerOptions): EffectComposer;
	createEffectsComposerAndBuildPasses(options: CreateEffectsComposerOptions): EffectComposer;
	private _updateComposers;
	private _passByNodeInBuildPassesProcess;
	addPassByNodeInBuildPassesProcess(node: BaseNodeType, pass: Pass, composer: EffectComposer): void;
	private _buildPasses;
}
interface TypedPostNodeContext {
	composerController: EffectComposerController;
	composer: EffectComposer;
	camera: Camera;
	renderer: WebGLRenderer;
	scene: Scene;
	viewer: BaseViewerType;
}
declare class TypedPostNode<P extends Pass, K extends NodeParamsConfig> extends TypedNode<NodeContext.POST, K> {
	static context(): NodeContext;
	readonly flags: FlagsControllerDB;
	protected _passesByEffectsComposer: Map<EffectComposer, P | P[]>;
	initializeNode(): void;
	cook(): void;
	setupComposer(context: TypedPostNodeContext): void;
	protected _setupComposerIfActive(context: TypedPostNodeContext): void;
	passesByComposer(composer: EffectComposer): P | P[] | undefined;
	protected _addPassFromInput(index: number, context: TypedPostNodeContext): void;
	createPassForContext(context: TypedPostNodeContext): P | P[] | undefined;
	createPass(context: TypedPostNodeContext): P | P[] | undefined;
	static PARAM_CALLBACK_updatePasses(node: BasePostProcessNodeType): void;
	protected _updatePasses(): void;
	protected updatePass(pass: P): void;
	protected _postProcessNetworkNode(): BaseNetworkPostProcessNodeType;
}
type BasePostProcessNodeType = TypedPostNode<Pass, NodeParamsConfig>;
declare class AntialiasingPostParamsConfig extends NodeParamsConfig {
	/** @param opacity */
	opacity: ParamTemplate<ParamType.FLOAT>;
}
declare class AntialiasingPostNode extends TypedPostNode<EffectPass, AntialiasingPostParamsConfig> {
	paramsConfig: AntialiasingPostParamsConfig;
	static type(): string;
	createPass(context: TypedPostNodeContext): EffectPass;
	updatePass(pass: EffectPass): void;
}
declare class BloomPostParamsConfig extends NodeParamsConfig {
	/** @param defines if this node applies a bloom to the whole scene or just a selection. Note that for now, it is necessary to reload your scene when toggling this parameter */
	useObjectMask: ParamTemplate<ParamType.BOOLEAN>;
	/** @param object mask of the objects that will be used for the bloom */
	objectsMask: ParamTemplate<ParamType.STRING>;
	/** @param updates the cached objects found by objectMask  */
	refreshObjects: ParamTemplate<ParamType.BUTTON>;
	/** @param effect strength */
	strength: ParamTemplate<ParamType.FLOAT>;
	/** @param effect threshold */
	threshold: ParamTemplate<ParamType.FLOAT>;
	/** @param effect scale */
	scale: ParamTemplate<ParamType.FLOAT>;
	/** @param effect radius */
	/** @param kernel size */
	kernelSize: ParamTemplate<ParamType.INTEGER>;
	/** @param effect luminance Smoothing */
	luminanceSmoothing: ParamTemplate<ParamType.FLOAT>;
	/** @param resolutionScale */
	resolutionScale: ParamTemplate<ParamType.FLOAT>;
	/** @param opacity */
	opacity: ParamTemplate<ParamType.FLOAT>;
	/** @param render mode */
	blendFunction: ParamTemplate<ParamType.INTEGER>;
}
declare class BloomPostNode extends TypedPostNode<EffectPass, BloomPostParamsConfig> {
	paramsConfig: BloomPostParamsConfig;
	static type(): string;
	private _rendererSize;
	createPass(context: TypedPostNodeContext): EffectPass;
	updatePass(pass: EffectPass): void;
	private __selectionController;
	private _selectionController;
	private _setSelectedObjects;
}
declare class BlurPostParamsConfig extends NodeParamsConfig {
	/** @param amount */
	amount: ParamTemplate<ParamType.FLOAT>;
	/** @param kernel size */
	kernelSize: ParamTemplate<ParamType.INTEGER>;
}
declare class BlurPostNode extends TypedPostNode<KawaseBlurPass, BlurPostParamsConfig> {
	paramsConfig: BlurPostParamsConfig;
	static type(): string;
	createPass(context: TypedPostNodeContext): KawaseBlurPass;
	updatePass(pass: KawaseBlurPass): void;
}
declare class BrightnessContrastPostParamsConfig extends NodeParamsConfig {
	/** @param brightness */
	brightness: ParamTemplate<ParamType.FLOAT>;
	/** @param contrast */
	contrast: ParamTemplate<ParamType.FLOAT>;
	/** @param effect opacity */
	opacity: ParamTemplate<ParamType.FLOAT>;
	/** @param render mode */
	blendFunction: ParamTemplate<ParamType.INTEGER>;
}
declare class BrightnessContrastPostNode extends TypedPostNode<EffectPass, BrightnessContrastPostParamsConfig> {
	paramsConfig: BrightnessContrastPostParamsConfig;
	static type(): string;
	createPass(context: TypedPostNodeContext): EffectPass;
	updatePass(pass: EffectPass): void;
}
interface IUniformsWithTime extends IUniforms {
	time: IUniformN;
}
interface AddUniformOptions {
	paramConfigs: readonly GlParamConfig<ParamType>[];
	additionalTextureUniforms: PolyDictionary<IUniformTexture>;
	timeDependent: boolean;
	resolutionDependent: boolean;
	raymarchingLightsWorldCoordsDependent: boolean;
}
declare class UniformsController {
	private scene;
	constructor(scene: PolyScene);
	addUniforms(uniforms: IUniforms, options: AddUniformOptions): void;
	addTimeUniform(uniforms: IUniforms): void;
	removeTimeUniform(uniforms: IUniforms): void;
	timeUniformValue(): number;
	addResolutionUniforms(uniforms: IUniforms): void;
	removeResolutionUniform(uniforms: IUniforms): void;
	updateResolution(resolution: Vector2, pixelRatio: number): void;
	addRaymarchingUniforms(uniforms: IUniforms): void;
	removeRaymarchingUniform(uniforms: IUniforms): void;
}
interface PersistedConfigBasePostData extends PersistedConfigWithShaders {
	uniforms: IUniforms;
	param_uniform_pairs: [
		string,
		string
	][];
	uniforms_time_dependent?: boolean;
	uniforms_resolution_dependent?: boolean;
}
declare class PostPersistedConfig extends BasePersistedConfig {
	protected node: BuilderPostNode;
	constructor(node: BuilderPostNode);
	toData(): Promise<PersistedConfigBasePostData | undefined>;
	load(data: PersistedConfigBasePostData): void;
}
declare enum PostType {
	BUILDER = "builder",
	EFFECT_PASS = "effectPass",
	TEXTURE = "texture",
	UPDATE_SCENE = "updateScene"
}
declare class ShaderAssemblerPost extends BaseGlShaderAssembler {
	private _uniforms;
	templateShader(): {
		fragmentShader: string;
		vertexShader: undefined;
		uniforms: undefined;
	};
	fragment_shader(): string | undefined;
	uniforms(): IUniforms | undefined;
	updateFragmentShader(): void;
	add_output_inputs(output_child: OutputGlNode): void;
	add_globals_outputs(globals_node: GlobalsGlNode): void;
	create_shader_configs(): ShaderConfig[];
	create_variable_configs(): VariableConfig[];
	protected insertDefineAfter(shader_name: ShaderName): string;
	protected insertBodyAfter(shader_name: ShaderName): string;
	protected linesToRemove(shader_name: ShaderName): string[];
	private _handle_gl_FragCoord;
	private _handle_resolution;
	private _handleUV;
	set_node_lines_output(output_node: OutputGlNode, shaders_collection_controller: ShadersCollectionController): void;
	set_node_lines_globals(globals_node: GlobalsGlNode, shaders_collection_controller: ShadersCollectionController): void;
}
declare class BuilderPostParamsConfig extends NodeParamsConfig {
	/** @param effect amount */
	useInput1OuputBuffer: ParamTemplate<ParamType.BOOLEAN>;
}
declare class BuilderPostNode extends TypedPostNode<EffectPass, BuilderPostParamsConfig> {
	paramsConfig: BuilderPostParamsConfig;
	static type(): PostType;
	readonly persisted_config: PostPersistedConfig;
	protected _assemblerController: GlAssemblerController<ShaderAssemblerPost> | undefined;
	usedAssembler(): Readonly<AssemblerName.GL_POST>;
	protected _createAssemblerController(): GlAssemblerController<ShaderAssemblerPost> | undefined;
	assemblerController(): GlAssemblerController<ShaderAssemblerPost> | undefined;
	protected _childrenControllerContext: NodeContext;
	initializeNode(): void;
	createNode<S extends keyof GlNodeChildrenMap>(node_class: S, options?: NodeCreateOptions): GlNodeChildrenMap[S];
	createNode<K extends valueof<GlNodeChildrenMap>>(node_class: Constructor<K>, options?: NodeCreateOptions): K;
	children(): BaseGlNodeType[];
	nodesByType<K extends keyof GlNodeChildrenMap>(type: K): GlNodeChildrenMap[K][];
	childrenAllowed(): boolean;
	sceneReadonly(): boolean;
	/**
	 *
	 * FRAGMENT SHADER UPDATE
	 *
	 */
	private _fragmentShader;
	private _uniforms;
	fragmentShader(): string;
	setFragmentShader(fragmentShader: string): void;
	uniforms(): IUniforms;
	setUniforms(uniforms: IUniforms): void;
	shaders_by_name(): {
		fragment: string;
	};
	compileIfRequired(): void;
	private compile;
	static handleDependencies(node: BuilderPostNode, timeDependent: boolean, uniforms?: IUniformsWithTime): void;
	/**
	 *
	 * PASS CREATE / UPDATE
	 *
	 */
	createPass(context: TypedPostNodeContext): EffectPass;
	updatePass(pass: EffectPass): void;
	protected _createEffectComposer(context: TypedPostNodeContext): import("postprocessing").EffectComposer;
}
declare class ChromaticAberrationPostParamsConfig extends NodeParamsConfig {
	/** @param effect amount */
	amount: ParamTemplate<ParamType.FLOAT>;
	/** @param effect dir */
	direction: ParamTemplate<ParamType.VECTOR2>;
}
declare class ChromaticAberrationPostNode extends TypedPostNode<EffectPass, ChromaticAberrationPostParamsConfig> {
	paramsConfig: ChromaticAberrationPostParamsConfig;
	static type(): string;
	createPass(context: TypedPostNodeContext): EffectPass;
	updatePass(pass: EffectPass): void;
}
declare class DepthOfFieldPostParamsConfig extends NodeParamsConfig {
	depthOfField: ParamTemplate<ParamType.FOLDER>;
	/** @param focalDepth */
	focusDistance: ParamTemplate<ParamType.FLOAT>;
	/** @param focalDepth */
	focusRange: ParamTemplate<ParamType.FLOAT>;
	/** @param bokeh scale */
	bokehScale: ParamTemplate<ParamType.FLOAT>;
	vignette: ParamTemplate<ParamType.FOLDER>;
	/** @param vignetting */
	vignetting: ParamTemplate<ParamType.BOOLEAN>;
	/** @param vignette technique */
	vignettingTechnique: ParamTemplate<ParamType.INTEGER>;
	/** @param vignette darkness */
	vignetteDarkness: ParamTemplate<ParamType.FLOAT>;
	/** @param vignette offset */
	vignetteOffset: ParamTemplate<ParamType.FLOAT>;
	debug: ParamTemplate<ParamType.FOLDER>;
	/** @param render mode */
	renderMode: ParamTemplate<ParamType.INTEGER>;
}
declare class DepthOfFieldPostNode extends TypedPostNode<EffectPass, DepthOfFieldPostParamsConfig> {
	paramsConfig: DepthOfFieldPostParamsConfig;
	static type(): string;
	createPass(context: TypedPostNodeContext): EffectPass;
	updatePass(pass: EffectPass): void;
	private _updateSmaaPass;
	private _updateDOFPass;
}
declare class EffectPassPostParamsConfig extends NodeParamsConfig {
	/** @param number of inputs that this node can merge geometries from */
	inputsCount: ParamTemplate<ParamType.INTEGER>;
}
declare class EffectPassPostNode extends TypedPostNode<EffectPass, EffectPassPostParamsConfig> {
	paramsConfig: EffectPassPostParamsConfig;
	static type(): PostType;
	initializeNode(): void;
	_setupComposerIfActive(context: TypedPostNodeContext): void;
	updatePass(pass: EffectPass): void;
	private _callbackUpdateInputsCount;
	static PARAM_CALLBACK_setInputsCount(node: EffectPassPostNode): void;
}
declare class GlitchPostParamsConfig extends NodeParamsConfig {
	texture: ParamTemplate<ParamType.NODE_PATH>;
	/** @param mode */
	mode: ParamTemplate<ParamType.INTEGER>;
	minDelay: ParamTemplate<ParamType.FLOAT>;
	maxDelay: ParamTemplate<ParamType.FLOAT>;
	minDuration: ParamTemplate<ParamType.FLOAT>;
	maxDuration: ParamTemplate<ParamType.FLOAT>;
	minStrength: ParamTemplate<ParamType.FLOAT>;
	maxStrength: ParamTemplate<ParamType.FLOAT>;
	/** @param columns */
	columns: ParamTemplate<ParamType.INTEGER>;
	/** @param ratio */
	ratio: ParamTemplate<ParamType.FLOAT>;
	/** @param blend function */
	blendFunction: ParamTemplate<ParamType.INTEGER>;
	/** @param if true, the offset parameter will be updated on each render to reflect the intensity of the glitch. This can be used to drive other effects with it */
	updateOffset: ParamTemplate<ParamType.BOOLEAN>;
	offset: ParamTemplate<ParamType.VECTOR2>;
}
declare class GlitchPostNode extends TypedPostNode<EffectPass, GlitchPostParamsConfig> {
	paramsConfig: GlitchPostParamsConfig;
	static type(): string;
	private _rendererSize;
	createPass(context: TypedPostNodeContext): EffectPass;
	updatePass(pass: EffectPass): Promise<void>;
	private _fetchTexture;
	private _lastEffect;
	private _lastViewer;
	private _offsetArray;
	private _onTickCallbackName;
	private _updateOnTickCallback;
	private _onRenderBound;
	private _onRender;
}
declare class GodRaysPostParamsConfig extends NodeParamsConfig {
	/** @param objects to emit godrays from. Note that while the mask can resolve multiple objects, only the first mesh or points will be used */
	objectMask: ParamTemplate<ParamType.STRING>;
	/** @param samples */
	samples: ParamTemplate<ParamType.INTEGER>;
	/** @param density */
	density: ParamTemplate<ParamType.FLOAT>;
	/** @param decay */
	decay: ParamTemplate<ParamType.FLOAT>;
	/** @param weight */
	weight: ParamTemplate<ParamType.FLOAT>;
	/** @param exposure */
	exposure: ParamTemplate<ParamType.FLOAT>;
	/** @param blur */
	blur: ParamTemplate<ParamType.BOOLEAN>;
	/** @param kernel size */
	kernelSize: ParamTemplate<ParamType.INTEGER>;
	/** @param resolutionScale */
	resolutionScale: ParamTemplate<ParamType.FLOAT>;
	/** @param effect opacity */
	opacity: ParamTemplate<ParamType.FLOAT>;
	/** @param render mode */
	blendFunction: ParamTemplate<ParamType.INTEGER>;
}
declare class GodRaysPostNode extends TypedPostNode<EffectPass, GodRaysPostParamsConfig> {
	paramsConfig: GodRaysPostParamsConfig;
	static type(): string;
	private _rendererSize;
	createPass(context: TypedPostNodeContext): EffectPass;
	updatePass(pass: EffectPass): void;
}
type GodRaysVolumetricAcceptedLightType = PointLight | DirectionalLight;
interface GodraysPassParams {
	/**
	 * The rate of accumulation for the godrays.  Higher values roughly equate to more humid air/denser fog.
	 */
	density: number;
	/**
	 * The maximum density of the godrays.  Limits the maximum brightness of the godrays.
	 */
	maxDensity: number;
	/**
	 * TODO: Document this
	 */
	edgeStrength: number;
	/**
	 * TODO: Document this
	 */
	edgeRadius: number;
	/**
	 * Higher values decrease the accumulation of godrays the further away they are from the light source.
	 */
	distanceAttenuation: number;
	/**
	 * The color of the godrays.
	 */
	color: Color;
}
declare class GodraysPass extends Pass implements Disposable {
	private props;
	private godraysRenderTarget;
	private illumPass;
	private compositorPass;
	/**
	 * Constructs a new GodraysPass.  Casts godrays from a point light source.  Add to your scene's composer like this:
	 *
	 * ```ts
	 * import { EffectComposer, RenderPass } from 'postprocessing';
	 * import { GodraysPass } from 'three-good-godrays';
	 *
	 * const composer = new EffectComposer(renderer);
	 * const renderPass = new RenderPass(scene, camera);
	 * renderPass.renderToScreen = false;
	 * composer.addPass(renderPass);
	 *
	 * const godraysPass = new GodraysPass(pointLight, camera);
	 * godraysPass.renderToScreen = true;
	 * composer.addPass(godraysPass);
	 *
	 * function animate() {
	 *   composer.render(scene, camera);
	 * }
	 * ```
	 *
	 * @param light The light source to use for the godrays.
	 * @param camera The camera used to render the scene.
	 * @param partialParams The parameters to use for the godrays effect.  Will use default values for any parameters not specified.
	 */
	constructor(light: GodRaysVolumetricAcceptedLightType, camera: PerspectiveCamera, partialParams?: Partial<GodraysPassParams>);
	setLight(light: GodRaysVolumetricAcceptedLightType): void;
	/**
	 * Updates the parameters used for the godrays effect.  Will use default values for any parameters not specified.
	 */
	setParams(partialParams: Partial<GodraysPassParams>): void;
// @ts-ignore
	render(renderer: WebGLRenderer, inputBuffer: WebGLRenderTarget, outputBuffer: WebGLRenderTarget, _deltaTime?: number | undefined, _stencilTest?: boolean | undefined): void;
// @ts-ignore
	setDepthTexture(depthTexture: Texture, depthPacking?: DepthPackingStrategies | undefined): void;
	setSize(width: number, height: number): void;
	dispose(): void;
}
declare class GodRaysVolumetricPostParamsConfig extends NodeParamsConfig {
	/** @param light type */
	lightType: ParamTemplate<ParamType.INTEGER>;
	/** @param light to emit godrays from. Note that while the mask can resolve multiple objects, only the first light will be used */
	lightMask: ParamTemplate<ParamType.STRING>;
	/** @param color */
	color: ParamTemplate<ParamType.COLOR>;
	/** @param density */
	density: ParamTemplate<ParamType.FLOAT>;
	/** @param maxDensity */
	maxDensity: ParamTemplate<ParamType.FLOAT>;
	/** @param distanceAttenuation */
	distanceAttenuation: ParamTemplate<ParamType.FLOAT>;
	/** @param edgeStrength */
	edgeStrength: ParamTemplate<ParamType.INTEGER>;
	/** @param edgeRadius */
	edgeRadius: ParamTemplate<ParamType.INTEGER>;
}
// @ts-ignore
declare class GodRaysVolumetricPostNode extends TypedPostNode<GodraysPass, GodRaysVolumetricPostParamsConfig> {
	paramsConfig: GodRaysVolumetricPostParamsConfig;
	static type(): string;
	private _rendererSize;
	createPass(context: TypedPostNodeContext): GodraysPass;
	updatePass(pass: GodraysPass): void;
	private _tmpLightSource;
}
declare class HueSaturationPostParamsConfig extends NodeParamsConfig {
	/** @param hue */
	hue: ParamTemplate<ParamType.FLOAT>;
	/** @param saturation */
	saturation: ParamTemplate<ParamType.FLOAT>;
	/** @param effect opacity */
	opacity: ParamTemplate<ParamType.FLOAT>;
	/** @param render mode */
	blendFunction: ParamTemplate<ParamType.INTEGER>;
}
declare class HueSaturationPostNode extends TypedPostNode<EffectPass, HueSaturationPostParamsConfig> {
	paramsConfig: HueSaturationPostParamsConfig;
	static type(): string;
	createPass(context: TypedPostNodeContext): EffectPass;
	updatePass(pass: EffectPass): void;
}
declare class LuminanceParamsConfig extends NodeParamsConfig {
}
declare class LuminancePostNode extends TypedPostNode<LuminancePass, LuminanceParamsConfig> {
	paramsConfig: LuminanceParamsConfig;
	static type(): string;
	createPass(context: TypedPostNodeContext): LuminancePass;
}
declare class LutPostParamsConfig extends NodeParamsConfig {
	/** @param texture */
	texture: ParamTemplate<ParamType.NODE_PATH>;
	/** @param effect opacity */
	opacity: ParamTemplate<ParamType.FLOAT>;
	/** @param render mode */
	blendFunction: ParamTemplate<ParamType.INTEGER>;
}
declare class LutPostNode extends TypedPostNode<EffectPass, LutPostParamsConfig> {
	paramsConfig: LutPostParamsConfig;
	static type(): string;
	createPass(context: TypedPostNodeContext): EffectPass[];
	updatePass(pass: EffectPass): Promise<void>;
	private _fetchTexture;
}
declare class NormalParamsConfig extends NodeParamsConfig {
}
declare class NormalPostNode extends TypedPostNode<NormalPass, NormalParamsConfig> {
	paramsConfig: NormalParamsConfig;
	static type(): string;
	createPass(context: TypedPostNodeContext): NormalPass;
}
declare class NoisePostParamsConfig extends NodeParamsConfig {
	/** @param effect strength */
	strength: ParamTemplate<ParamType.FLOAT>;
	/** @param premultiply */
	premultiply: ParamTemplate<ParamType.BOOLEAN>;
}
declare class NoisePostNode extends TypedPostNode<EffectPass, NoisePostParamsConfig> {
	paramsConfig: NoisePostParamsConfig;
	static type(): string;
	private _rendererSize;
	createPass(context: TypedPostNodeContext): EffectPass;
	updatePass(pass: EffectPass): void;
}
declare class NullPostParamsConfig extends NodeParamsConfig {
}
declare class NullPostNode extends TypedPostNode<Pass, NullPostParamsConfig> {
	paramsConfig: NullPostParamsConfig;
	static type(): string;
}
declare class OutlinePostParamsConfig extends NodeParamsConfig {
	/** @param object mask of the objects that will have an outline */
	objectsMask: ParamTemplate<ParamType.STRING>;
	/** @param updates the cached objects found by objectMask  */
	refreshObjects: ParamTemplate<ParamType.BUTTON>;
	/** @param edgeStrenth */
	edgeStrength: ParamTemplate<ParamType.FLOAT>;
	/** @param blur */
	blur: ParamTemplate<ParamType.BOOLEAN>;
	kernelSize: ParamTemplate<ParamType.INTEGER>;
	/** @param defines if the edges pulsate */
	pulseSpeed: ParamTemplate<ParamType.FLOAT>;
	/** @param visibleEdgeColor */
	visibleEdgeColor: ParamTemplate<ParamType.COLOR>;
	/** @param shows outline for hidden parts of objects */
	xRay: ParamTemplate<ParamType.BOOLEAN>;
	/** @param hiddenEdgeColor */
	hiddenEdgeColor: ParamTemplate<ParamType.COLOR>;
	/** @param opacity */
	opacity: ParamTemplate<ParamType.FLOAT>;
	/** @param render mode */
	blendFunction: ParamTemplate<ParamType.INTEGER>;
}
declare class OutlinePostNode extends TypedPostNode<EffectPass, OutlinePostParamsConfig> {
	paramsConfig: OutlinePostParamsConfig;
	static type(): string;
	createPass(context: TypedPostNodeContext): EffectPass;
	updatePass(pass: EffectPass): void;
	private _selectionController;
	private _setSelectedObjects;
}
declare class PixelPostParamsConfig extends NodeParamsConfig {
	/** @param pixelSize */
	pixelSize: ParamTemplate<ParamType.INTEGER>;
}
declare class PixelPostNode extends TypedPostNode<EffectPass, PixelPostParamsConfig> {
	paramsConfig: PixelPostParamsConfig;
	static type(): string;
	createPass(context: TypedPostNodeContext): EffectPass;
	updatePass(pass: EffectPass): void;
}
interface RenderPassContext {
	camera: Camera;
	scene: Scene;
}
declare class RenderPassWithContext extends RenderPass {
// @ts-ignore
	scene: Scene;
// @ts-ignore
	camera: Camera;
	context: RenderPassContext;
	constructor(scene: Scene, camera: Camera);
}
declare class RenderPostParamsConfig extends NodeParamsConfig {
	/** @param overrideScene */
	overrideScene: ParamTemplate<ParamType.BOOLEAN>;
	/** @param scene */
	scene: ParamTemplate<ParamType.NODE_PATH>;
	/** @param overrideCamera */
	overrideCamera: ParamTemplate<ParamType.BOOLEAN>;
	/** @param camera */
	camera: ParamTemplate<ParamType.STRING>;
}
declare class RenderPostNode extends TypedPostNode<RenderPass, RenderPostParamsConfig> {
	paramsConfig: RenderPostParamsConfig;
	static type(): string;
// @ts-ignore
	createPass(context: TypedPostNodeContext): RenderPassWithContext;
// @ts-ignore
	updatePass(pass: RenderPassWithContext): void;
	protected _updateCamera(pass: RenderPassWithContext): Promise<void>;
	protected _updateScene(pass: RenderPassWithContext): Promise<void>;
}
declare class N8AOPostPass extends Pass {
	configuration: {
		aoSamples: number;
		aoRadius: number;
		distanceFalloff: number;
		intensity: number;
		color: Color;
		denoiseSamples: number;
		denoiseRadius: number;
		denoiseIterations: number;
		logarithmicDepthBuffer: boolean;
		screenSpaceRadius: boolean;
		halfRef: boolean;
		depthAwareUpsampling: boolean;
	};
	constructor(scene: Scene, camera: Camera);
	setDisplayMode: (mode: string) => void;
}
declare class ScreenSpaceAmbientOcclusionParamsConfig extends NodeParamsConfig {
	main: ParamTemplate<ParamType.FOLDER>;
	/** @param color */
	color: ParamTemplate<ParamType.COLOR>;
	/** @param aoSamples */
	samples: ParamTemplate<ParamType.INTEGER>;
	/** @param intensity */
	intensity: ParamTemplate<ParamType.FLOAT>;
	/** @param radius */
	radius: ParamTemplate<ParamType.FLOAT>;
	/** @param distanceFallOff */
	distanceFallOff: ParamTemplate<ParamType.FLOAT>;
	/** @param halfRef */
	halfRef: ParamTemplate<ParamType.BOOLEAN>;
	/** @param screenSpaceRadius */
	screenSpaceRadius: ParamTemplate<ParamType.BOOLEAN>;
	/** @param denoise samples  */
	denoiseSamples: ParamTemplate<ParamType.INTEGER>;
	/** @param denoise radius */
	denoiseRadius: ParamTemplate<ParamType.FLOAT>;
	/** @param denoise iterations  */
	denoiseIterations: ParamTemplate<ParamType.INTEGER>;
	displayMode: ParamTemplate<ParamType.INTEGER>;
}
declare class ScreenSpaceAmbientOcclusionPostNode extends TypedPostNode<Pass, ScreenSpaceAmbientOcclusionParamsConfig> {
	paramsConfig: ScreenSpaceAmbientOcclusionParamsConfig;
	static type(): string;
	createPass(context: TypedPostNodeContext): Pass[];
	updatePass(pass: N8AOPostPass): void;
}
declare class SepiaPostParamsConfig extends NodeParamsConfig {
	/** @param amount */
	amount: ParamTemplate<ParamType.FLOAT>;
}
declare class SepiaPostNode extends TypedPostNode<EffectPass, SepiaPostParamsConfig> {
	paramsConfig: SepiaPostParamsConfig;
	static type(): string;
	createPass(context: TypedPostNodeContext): EffectPass;
	updatePass(pass: EffectPass): void;
}
declare class SequencePostParamsConfig extends NodeParamsConfig {
}
declare class SequencePostNode extends TypedPostNode<Pass, SequencePostParamsConfig> {
	paramsConfig: SequencePostParamsConfig;
	static type(): string;
	initializeNode(): void;
	setupComposer(context: TypedPostNodeContext): void;
}
declare class TexturePostParamsConfig extends NodeParamsConfig {
	/** @param texture */
	texture: ParamTemplate<ParamType.NODE_PATH>;
	/** @param opacity */
	opacity: ParamTemplate<ParamType.FLOAT>;
	/** @param render mode */
	blendFunction: ParamTemplate<ParamType.INTEGER>;
}
declare class TexturePostNode extends TypedPostNode<EffectPass, TexturePostParamsConfig> {
	paramsConfig: TexturePostParamsConfig;
	static type(): PostType;
	private _rendererSize;
	createPass(context: TypedPostNodeContext): EffectPass;
	updatePass(pass: EffectPass): Promise<void>;
}
interface UpdateSceneEffectOptions {
	reset: boolean;
	node: UpdateScenePostNode;
	nodeToReset?: UpdateScenePostNode;
}
declare class UpdateScenePass extends CopyPass {
	reset: boolean;
	node: UpdateScenePostNode;
	nodeToReset?: UpdateScenePostNode;
	constructor(options: UpdateSceneEffectOptions);
// @ts-ignore
	render(renderer: WebGLRenderer, inputBuffer: WebGLRenderTarget, outputBuffer: WebGLRenderTarget, deltaTime?: number, stencilTest?: boolean): void;
}
declare class UpdateScenePostParamsConfig extends NodeParamsConfig {
	/** @param reset */
	reset: ParamTemplate<ParamType.BOOLEAN>;
	/** @param objects Mask */
	objectsMask: ParamTemplate<ParamType.STRING>;
	/** @param invertMask */
	invertMask: ParamTemplate<ParamType.BOOLEAN>;
	/** @param prints which objects are targeted by this node, for debugging */
	/** @param update selected objects material to a matte one */
	setMatteMaterial: ParamTemplate<ParamType.BOOLEAN>;
	/** @param set visible state  */
	setVisible: ParamTemplate<ParamType.BOOLEAN>;
	/** @param set visible state  */
	visible: ParamTemplate<ParamType.BOOLEAN>;
	/** @param reset */
	resetChanges: ParamTemplate<ParamType.BUTTON>;
}
// @ts-ignore
declare class UpdateScenePostNode extends TypedPostNode<UpdateScenePass, UpdateScenePostParamsConfig> {
	paramsConfig: UpdateScenePostParamsConfig;
	static type(): PostType;
	initializeNode(): void;
	createPass(context: TypedPostNodeContext): UpdateScenePass;
	updatePass(pass: UpdateScenePass): void;
	private _nodeToReset;
	static PARAM_CALLBACK_resetChanges(node: UpdateScenePostNode): void;
	private _objectsList;
	objectsList(): ObjectContent<CoreObjectType>[];
	private _materialByMesh;
	private _visibleByObject;
	applyChanges(): void;
	resetChanges(): void;
	private _updateObjectBound;
	private _updateObject;
}
declare class VignettePostParamsConfig extends NodeParamsConfig {
	/** @param offset */
	offset: ParamTemplate<ParamType.FLOAT>;
	/** @param darkness */
	darkness: ParamTemplate<ParamType.FLOAT>;
}
declare class VignettePostNode extends TypedPostNode<EffectPass, VignettePostParamsConfig> {
	paramsConfig: VignettePostParamsConfig;
	static type(): string;
	createPass(context: TypedPostNodeContext): EffectPass;
	updatePass(pass: EffectPass): void;
}
declare class ParamLessNetworkPostParamsConfig extends NodeParamsConfig {
}
declare class BaseNetworkPostNode<K extends NodeParamsConfig> extends TypedNode<NodeContext.POST, K> {
	static context(): NodeContext;
	cook(): void;
}
declare class ParamLessBaseNetworkPostNode extends BaseNetworkPostNode<ParamLessNetworkPostParamsConfig> {
}
declare class ActorsNetworkPostNode extends ParamLessBaseNetworkPostNode {
	static type(): NetworkNodeType;
	protected _childrenControllerContext: NodeContext;
	createNode<S extends keyof JsNodeChildrenMap>(node_class: S, options?: NodeCreateOptions): JsNodeChildrenMap[S];
	createNode<K extends valueof<JsNodeChildrenMap>>(node_class: Constructor<K>, options?: NodeCreateOptions): K;
	children(): BaseJsNodeType[];
	nodesByType<K extends keyof JsNodeChildrenMap>(type: K): JsNodeChildrenMap[K][];
	childrenAllowed(): boolean;
	sceneReadonly(): boolean;
	readonly persisted_config: ActorPersistedConfig;
	assemblerController(): JsAssemblerController<JsAssemblerActor> | undefined;
	usedAssembler(): Readonly<AssemblerName.JS_ACTOR>;
	protected _assemblerController: JsAssemblerController<JsAssemblerActor> | undefined;
	private _createAssemblerController;
	readonly compilationController: ActorCompilationController;
	compile(): void;
	cook(): void;
}
declare class AnimationsNetworkPostNode extends ParamLessBaseNetworkPostNode {
	static type(): NetworkNodeType;
	protected _childrenControllerContext: NodeContext;
	createNode<S extends keyof AnimNodeChildrenMap>(node_class: S, options?: NodeCreateOptions): AnimNodeChildrenMap[S];
	createNode<K extends valueof<AnimNodeChildrenMap>>(node_class: Constructor<K>, options?: NodeCreateOptions): K;
	children(): BaseAnimNodeType[];
	nodesByType<K extends keyof AnimNodeChildrenMap>(type: K): AnimNodeChildrenMap[K][];
}
declare class AudioNetworkPostNode extends ParamLessBaseNetworkPostNode {
	static type(): NetworkNodeType;
	protected _childrenControllerContext: NodeContext;
	createNode<S extends keyof AudioNodeChildrenMap>(node_class: S, options?: NodeCreateOptions): AudioNodeChildrenMap[S];
	createNode<K extends valueof<AudioNodeChildrenMap>>(node_class: Constructor<K>, options?: NodeCreateOptions): K;
	children(): BaseAudioNodeType[];
	nodesByType<K extends keyof AudioNodeChildrenMap>(type: K): AudioNodeChildrenMap[K][];
}
declare class CopNetworkPostNode extends ParamLessBaseNetworkPostNode {
	static type(): NetworkNodeType;
	protected _childrenControllerContext: NodeContext;
	createNode<S extends keyof CopNodeChildrenMap>(node_class: S, options?: NodeCreateOptions): CopNodeChildrenMap[S];
	createNode<K extends valueof<CopNodeChildrenMap>>(node_class: Constructor<K>, options?: NodeCreateOptions): K;
	children(): BaseCopNodeType[];
	nodesByType<K extends keyof CopNodeChildrenMap>(type: K): CopNodeChildrenMap[K][];
}
declare class EventsNetworkPostNode extends ParamLessBaseNetworkPostNode {
	static type(): NetworkNodeType;
	protected _childrenControllerContext: NodeContext;
	createNode<S extends keyof EventNodeChildrenMap>(node_class: S, options?: NodeCreateOptions): EventNodeChildrenMap[S];
	createNode<K extends valueof<EventNodeChildrenMap>>(node_class: Constructor<K>, options?: NodeCreateOptions): K;
	children(): BaseEventNodeType[];
	nodesByType<K extends keyof EventNodeChildrenMap>(type: K): EventNodeChildrenMap[K][];
}
declare class MaterialsNetworkPostNode extends ParamLessBaseNetworkPostNode {
	static type(): NetworkNodeType;
	protected _childrenControllerContext: NodeContext;
	createNode<S extends keyof MatNodeChildrenMap>(node_class: S, options?: NodeCreateOptions): MatNodeChildrenMap[S];
	createNode<K extends valueof<MatNodeChildrenMap>>(node_class: Constructor<K>, options?: NodeCreateOptions): K;
	children(): BaseMatNodeType[];
	nodesByType<K extends keyof MatNodeChildrenMap>(type: K): MatNodeChildrenMap[K][];
}
declare class PostProcessNetworkPostNode extends BaseNetworkPostNode<PostProcessNetworkParamsConfig> {
	paramsConfig: PostProcessNetworkParamsConfig;
	static type(): NetworkNodeType;
	readonly effectsComposerController: EffectComposerController;
	readonly displayNodeController: DisplayNodeController;
	protected _childrenControllerContext: NodeContext;
	createNode<S extends keyof PostNodeChildrenMap>(node_class: S, options?: NodeCreateOptions): PostNodeChildrenMap[S];
	createNode<K extends valueof<PostNodeChildrenMap>>(node_class: Constructor<K>, options?: NodeCreateOptions): K;
	children(): BasePostProcessNodeType[];
	nodesByType<K extends keyof PostNodeChildrenMap>(type: K): PostNodeChildrenMap[K][];
}
declare class TypedRopNode<K extends NodeParamsConfig> extends TypedNode<NodeContext.ROP, K> {
	static context(): NodeContext;
	readonly flags: FlagsController;
	initializeBaseNode(): void;
	cook(): void;
}
type BaseRopNodeType = TypedRopNode<NodeParamsConfig>;
interface CSS2DParameters {
	element?: HTMLElement;
}
declare class CSS2DRenderer {
	private _width;
	private _height;
	private _widthHalf;
	private _heightHalf;
	private dataByObject;
	domElement: HTMLElement;
	appendedObjects: Set<CSS2DObject>;
	objectsToRender: Set<CSS2DObject>;
	objectsToRemove: Set<CSS2DObject>;
	constructor(parameters?: CSS2DParameters);
	getSize(): {
		width: number;
		height: number;
	};
	render(scene: Scene, camera: Camera): void;
	private removeElementsDeletedFromSceneGraph;
	setSize(width: number, height: number): void;
	renderObject(object: Object3D, scene: Scene, camera: Camera): void;
	getDistanceToSquared(object1: Object3D, object2: Object3D): number;
	filterAndFlatten(scene: Scene): CSS2DObject[];
	zOrder(scene: Scene): void;
}
declare enum RopType {
	CSS2D = "CSS2DRenderer",
	CSS3D = "CSS3DRenderer",
	WEBGL = "WebGLRenderer",
	PATH_TRACING = "pathTracingRenderer"
}
declare class CSS2DRendererRopParamsConfig extends NodeParamsConfig {
	/** @param css rules to be added in the html document */
	css: ParamTemplate<ParamType.STRING>;
}
declare class CSS2DRendererRopNode extends TypedRopNode<CSS2DRendererRopParamsConfig> {
	paramsConfig: CSS2DRendererRopParamsConfig;
	static type(): Readonly<RopType.CSS2D>;
	private _renderersByCanvasId;
	createRenderer(canvas: HTMLCanvasElement): CSS2DRenderer;
	mountRenderer(canvas: HTMLCanvasElement): void;
	unmountRenderer(canvas: HTMLCanvasElement): void;
	renderer(canvas: HTMLCanvasElement): CSS2DRenderer;
	cook(): void;
	private _updateRenderer;
	private _updateCSS;
	private __CSSElement;
	private _CSSElement;
	private _findElement;
	private _createElement;
	private _CSSElementId;
}
interface CSS3DParameters {
	element?: HTMLElement;
}
declare class CSS3DRenderer {
	private _width;
	private _height;
	private _widthHalf;
	private _heightHalf;
	domElement: HTMLElement;
	cameraElement: HTMLElement;
	private cache;
	appendedObjects: Set<CSS3DObject>;
	objectsToRender: Set<CSS3DObject>;
	objectsToRemove: Set<CSS3DObject>;
	constructor(parameters?: CSS3DParameters);
	getSize(): {
		width: number;
		height: number;
	};
	render(scene: Scene, camera: Camera): void;
	private removeElementsDeletedFromSceneGraph;
	setSize(width: number, height: number): void;
	renderObject(object: Object3D, scene: Scene, camera: Camera, cameraCSSMatrix: string): void;
}
declare class CSS3DRendererRopParamsConfig extends NodeParamsConfig {
	/** @param css rules to be added in the html document */
	css: ParamTemplate<ParamType.STRING>;
}
declare class CSS3DRendererRopNode extends TypedRopNode<CSS3DRendererRopParamsConfig> {
	paramsConfig: CSS3DRendererRopParamsConfig;
	static type(): Readonly<RopType.CSS3D>;
	private _renderersByCanvasId;
	createRenderer(canvas: HTMLCanvasElement): CSS3DRenderer;
	mountRenderer(canvas: HTMLCanvasElement): void;
	unmountRenderer(canvas: HTMLCanvasElement): void;
	renderer(canvas: HTMLCanvasElement): CSS3DRenderer;
	cook(): void;
	private _updateRenderer;
	private _updateCSS;
	private __CSSElement;
	private _CSSElement;
	private _findElement;
	private _createElement;
	private _CSSElementId;
}
declare class FullScreenQuad {
	constructor(material?: Material);
	render(renderer: WebGLRenderer): void;
	dispose(): void;
	material: Material;
}
declare class IESTexture {
}
declare class PhysicalCamera extends PerspectiveCamera {
	public bokehSize: number;
	public fStop: number;
	public apertureBlades: number;
	public apertureRotation: number;
	public focusDistance: number;
	public anamorphicRatio: number;
	constructor(fov?: number, aspect?: number, near?: number, far?: number);
}
declare class PhysicalSpotLight extends SpotLight {
	public iesTexture: IESTexture;
	public radius: number;
}
declare class PhysicalCameraUniform {
	updateFrom(other: PhysicalCamera): void;
}
declare class PathTracingRenderer {
	public samples: number;
	public camera: Camera;
	public target: WebGLRenderTarget;
	public material: PhysicalPathTracingMaterial;
	public stableNoise: boolean;
	public tiles: Vector2;
	constructor(renderer: WebGLRenderer);
	update(): void;
	setSize(x: number, y: number): void;
	reset(): void;
	dispose(): void;
}
type AllowedAttribute = BufferAttribute | InterleavedBufferAttribute | GLBufferAttribute;
declare class PhysicalPathTracingMaterial {
	public bounces: number;
	public transmissiveBounces: number;
	public filterGlossyFactor: number;
	public environmentIntensity: number;
	public physicalCamera: PhysicalCameraUniform;
	bvh: MeshBVHUniformStruct;
	attributesArray: {
		updateFrom(normal: AllowedAttribute, tangent: AllowedAttribute, uv: AllowedAttribute, color: AllowedAttribute): void;
	};
	materialIndexAttribute: {
		updateFrom(index: AllowedAttribute): void;
	};
	envMapInfo: {
		updateFrom(texture: Texture): void;
	};
	textures: {
		setTextures(renderer: WebGLTexture, x: number, y: number, textures: Texture[]): void;
	};
	materials: {
		updateFrom(materials: Material[], textures: Texture[]): void;
	};
	iesProfiles: {
		updateFrom(renderer: WebGLTexture, iesTextures: Array<IESTexture>): void;
	};
	lights: {
		updateFrom(lights: PhysicalSpotLight[], iesTextures: Array<IESTexture>): void;
	};
	setDefine(define: string, value?: number): void;
}
declare class MaterialBase extends ShaderMaterial {
}
interface DenoiseMaterialParams {
	map: Texture;
	blending: Blending;
	premultipliedAlpha: boolean;
}
declare class DenoiseMaterial extends MaterialBase {
	constructor(parameters: DenoiseMaterialParams);
	public map: Texture;
	public sigma: number;
	public threshold: number;
	public kSigma: number;
}
interface UpdateOptions {
	resolutionScale: number;
	displayDebug: boolean;
	bounces: number;
	transmissiveBounces: number;
	stableNoise: boolean;
	filterGlossyFactor: number;
	backgroundBlur: number;
	environmentIntensity: number;
	tiles: Vector2;
	multipleImportanceSampling: boolean;
	denoise: boolean;
	denoiseSigma: number;
	denoiseThreshold: number;
	denoiseKSigma: number;
	maxSamplesCount: number;
	samplesPerAnimationFrame: number;
	f: Vector2;
	useWorker: boolean;
}
interface PathtracingRendererContainerOptions {
	node: PathTracingRendererRopNode;
	webGLRenderer: WebGLRenderer;
	pathTracingRenderer: PathTracingRenderer;
	fsQuad: FullScreenQuad;
	fsQuadMat: MeshBasicMaterial;
	denoiseQuad: FullScreenQuad;
	denoiseMat: DenoiseMaterial;
}
declare class PathTracingRendererContainer implements AbstractRenderer {
	displayDebug: boolean;
	backgroundBlur: number;
	maxSamplesCount: number;
	samplesPerAnimationFrame: number;
	frameRange: Vector2;
	resolutionScale: number;
	private _useWorker;
	domElement: HTMLCanvasElement;
	private _generated;
	private _generating;
	readonly isPathTracingRendererContainer = true;
	private _denoiseActive;
	readonly node: PathTracingRendererRopNode;
	readonly webGLRenderer: WebGLRenderer;
	readonly pathTracingRenderer: PathTracingRenderer;
	readonly fsQuad: FullScreenQuad;
	readonly fsQuadMat: MeshBasicMaterial;
	readonly denoiseQuad: FullScreenQuad;
	readonly denoiseMat: DenoiseMaterial;
	constructor(options: PathtracingRendererContainerOptions);
	private _multipleImportanceSampling;
	update(options: UpdateOptions): void;
	render(scene: Scene, camera: PhysicalCamera): void;
	pbrRenderAllowed(): boolean;
	markAsNotGenerated(): void;
	renderRealtime(scene: Scene, camera: PhysicalCamera): void;
	private _preRender;
	private _postRender;
	samplesCount(): number;
	getPixelRatio(): number;
	compile(scene: Scene, camera: Camera): void;
	dispose(): void;
	setSize(w: number, h: number, setStyle: boolean): void;
	setRenderTarget(renderTarget: WebGLRenderTarget | WebGLMultipleRenderTargets | null, activeCubeFace?: number | undefined, activeMipmapLevel?: number | undefined): void;
	readRenderTargetPixels(renderTarget: WebGLRenderTarget | WebGLMultipleRenderTargets, x: number, y: number, width: number, height: number, buffer: Float32Array, activeCubeFaceIndex?: number | undefined): void;
	get capabilities(): WebGLCapabilities;
	private _generator;
	private _workerGenerator;
	private _generateRequired;
	generate(scene: Scene): Promise<void>;
	reset(): void;
	private _previousCameraProjectionMatrix;
	private _previousCameraWorldMatrix;
	private _resetIfCameraUpdated;
}
declare class PathTracingRendererRopParamsConfig extends NodeParamsConfig {
	realtime: ParamTemplate<ParamType.FOLDER>;
	/** @param display samples count */
	displayDebug: ParamTemplate<ParamType.BOOLEAN>;
	/** @param useWorker */
	useWorker: ParamTemplate<ParamType.BOOLEAN>;
	/** @param samples */
	maxSamplesCount: ParamTemplate<ParamType.INTEGER>;
	/** @param resolutionScale */
	resolutionScale: ParamTemplate<ParamType.FLOAT>;
	/** @param bounces */
	bounces: ParamTemplate<ParamType.INTEGER>;
	/** @param bounces inside transmissive material */
	transmissiveBounces: ParamTemplate<ParamType.INTEGER>;
	/** @param stableNoise*/
	stableNoise: ParamTemplate<ParamType.BOOLEAN>;
	/** @param multipleImportanceSampling */
	multipleImportanceSampling: ParamTemplate<ParamType.BOOLEAN>;
	/** @param filterGlossyFactor */
	filterGlossyFactor: ParamTemplate<ParamType.FLOAT>;
	/** @param backgroundBlur*/
	backgroundBlur: ParamTemplate<ParamType.FLOAT>;
	/** @param environmentIntensity*/
	environmentIntensity: ParamTemplate<ParamType.FLOAT>;
	denoise: ParamTemplate<ParamType.BOOLEAN>;
	denoiseSigma: ParamTemplate<ParamType.FLOAT>;
	denoiseThreshold: ParamTemplate<ParamType.FLOAT>;
	denoiseKSigma: ParamTemplate<ParamType.FLOAT>;
	/** @param toggle on to have alpha on (change requires page reload) */
	/** @param toggle on to have antialias on (change requires page reload) */
	/** @param tiles */
	tiles: ParamTemplate<ParamType.VECTOR2>;
	/** @param force update */
	sequenceRender: ParamTemplate<ParamType.FOLDER>;
	/** @param frame range */
	f: ParamTemplate<ParamType.VECTOR2>;
	/** @param samples */
	samplesPerAnimationFrame: ParamTemplate<ParamType.INTEGER>;
	/** @param resolution */
	resolution: ParamTemplate<ParamType.VECTOR2>;
	/** @param fileName */
	fileName: ParamTemplate<ParamType.STRING>;
	framePadding: ParamTemplate<ParamType.INTEGER>;
}
declare class PathTracingRendererRopNode extends TypedRopNode<PathTracingRendererRopParamsConfig> {
	paramsConfig: PathTracingRendererRopParamsConfig;
	static type(): Readonly<RopType.PATH_TRACING>;
	requiredModules(): ModuleName[];
	private _pathTracingRenderer;
	private _webGLRenderer;
	protected initializeNode(): void;
	dispose(): void;
	private _createWebGLRenderer;
	private _createPathTracingRenderer;
	renderer(canvas: HTMLCanvasElement, gl: WebGLRenderingContext): PathTracingRendererContainer;
	cook(): void;
	private _updateRenderer;
	static PARAM_CALLBACK_generate(node: PathTracingRendererRopNode): void;
	private _paramCallbackGenerate;
	static PARAM_CALLBACK_update(node: PathTracingRendererRopNode): void;
	private _paramCallbackUpdate;
}
declare class WebGLRendererRopParamsConfig extends NodeParamsConfig {
	common: ParamTemplate<ParamType.FOLDER>;
	/** @param tone mapping */
	toneMapping: ParamTemplate<ParamType.INTEGER>;
	/** @param tone mapping exposure */
	toneMappingExposure: ParamTemplate<ParamType.FLOAT>;
	/** @param output color space */
	outputColorSpace: ParamTemplate<ParamType.STRING>;
	/** @param physically correct lights */
	physicallyCorrectLights: ParamTemplate<ParamType.BOOLEAN>;
	/** @param sort objects, which can be necessary when rendering transparent objects */
	sortObjects: ParamTemplate<ParamType.BOOLEAN>;
	/** @param toggle to override the default pixel ratio, which is 1 for mobile devices, and Math.max(2, window.devicePixelRatio) for other devices */
	tpixelRatio: ParamTemplate<ParamType.BOOLEAN>;
	/** @param higher pixelRatio improves render sharpness but reduces performance */
	pixelRatio: ParamTemplate<ParamType.FLOAT>;
	shadow: ParamTemplate<ParamType.FOLDER>;
	/** @param toggle on to have shadow maps */
	tshadowMap: ParamTemplate<ParamType.BOOLEAN>;
	/** @param toggle on to recompute the shadow maps on every frame. If all objects are static, you may want to turn this off */
	shadowMapAutoUpdate: ParamTemplate<ParamType.BOOLEAN>;
	/** @param toggle on to trigger shadows update */
	shadowMapNeedsUpdate: ParamTemplate<ParamType.BOOLEAN>;
	/** @param shadows type */
	shadowMapType: ParamTemplate<ParamType.INTEGER>;
	advanced: ParamTemplate<ParamType.FOLDER>;
	/** @param toggle on to have alpha on (change requires page reload) */
	alpha: ParamTemplate<ParamType.BOOLEAN>;
	/** @param toggle on to have antialias on (change requires page reload) */
	antialias: ParamTemplate<ParamType.BOOLEAN>;
	/** @param premultipliedAlpha */
	premultipliedAlpha: ParamTemplate<ParamType.BOOLEAN>;
	/** @param stencil */
	stencil: ParamTemplate<ParamType.BOOLEAN>;
	/** @param depth */
	depth: ParamTemplate<ParamType.BOOLEAN>;
	/** @param localClippingEnabled */
	localClippingEnabled: ParamTemplate<ParamType.BOOLEAN>;
	/** @param logarithmicDepthBuffer */
	logarithmicDepthBuffer: ParamTemplate<ParamType.BOOLEAN>;
	/** @param preserveDrawingBuffer */
	preserveDrawingBuffer: ParamTemplate<ParamType.BOOLEAN>;
	/** @param toggle on to set the precision */
	tprecision: ParamTemplate<ParamType.BOOLEAN>;
	/** @param set the precision */
	precision: ParamTemplate<ParamType.INTEGER>;
	/** @param toggle on to set the power preferenc */
	tpowerPreference: ParamTemplate<ParamType.BOOLEAN>;
	/** @param set the precision */
	powerPreference: ParamTemplate<ParamType.INTEGER>;
}
declare class WebGLRendererRopNode extends TypedRopNode<WebGLRendererRopParamsConfig> {
	paramsConfig: WebGLRendererRopParamsConfig;
	static type(): Readonly<RopType.WEBGL>;
	private _rendererByCanvas;
	createRenderer(canvas: HTMLCanvasElement, gl: WebGLRenderingContext): WebGLRenderer;
	cook(): void;
	private _updateRenderer;
	private _traverseSceneAndUpdateMaterials;
	static PARAM_CALLBACK_updateToneMapping(node: WebGLRendererRopNode): void;
	static PARAM_CALLBACK_updateToneMappingExposure(node: WebGLRendererRopNode): void;
	static PARAM_CALLBACK_updateOutputColorSpace(node: WebGLRendererRopNode): void;
	static PARAM_CALLBACK_updateShadow(node: WebGLRendererRopNode): void;
	static PARAM_CALLBACK_updateSortObjects(node: WebGLRendererRopNode): void;
	static PARAM_CALLBACK_updatePhysicallyCorrect(node: WebGLRendererRopNode): void;
	static PARAM_CALLBACK_updatePixelRatio(node: WebGLRendererRopNode): void;
	private _updateRendererToneMapping;
	private _updateRendererToneMappingExposure;
	private _updateRendererOutputColorSpace;
	private _updateRendererShadow;
	private _updateRendererSortObjects;
	private _updateRendererPhysicallyCorrect;
	private _updateRendererPixelRatio;
}
declare class ParamLessNetworkRopParamsConfig extends NodeParamsConfig {
}
declare class BaseNetworkRopNode<K extends NodeParamsConfig> extends TypedNode<NodeContext.ROP, K> {
	static context(): NodeContext;
	cook(): void;
}
declare class ParamLessBaseNetworkRopNode extends BaseNetworkRopNode<ParamLessNetworkRopParamsConfig> {
}
declare class ActorsNetworkRopNode extends ParamLessBaseNetworkRopNode {
	static type(): NetworkNodeType;
	protected _childrenControllerContext: NodeContext;
	createNode<S extends keyof JsNodeChildrenMap>(node_class: S, options?: NodeCreateOptions): JsNodeChildrenMap[S];
	createNode<K extends valueof<JsNodeChildrenMap>>(node_class: Constructor<K>, options?: NodeCreateOptions): K;
	children(): BaseJsNodeType[];
	nodesByType<K extends keyof JsNodeChildrenMap>(type: K): JsNodeChildrenMap[K][];
	childrenAllowed(): boolean;
	sceneReadonly(): boolean;
	readonly persisted_config: ActorPersistedConfig;
	assemblerController(): JsAssemblerController<JsAssemblerActor> | undefined;
	usedAssembler(): Readonly<AssemblerName.JS_ACTOR>;
	protected _assemblerController: JsAssemblerController<JsAssemblerActor> | undefined;
	private _createAssemblerController;
	readonly compilationController: ActorCompilationController;
	compile(): void;
	cook(): void;
}
declare class AnimationsNetworkRopNode extends ParamLessBaseNetworkRopNode {
	static type(): NetworkNodeType;
	protected _childrenControllerContext: NodeContext;
	createNode<S extends keyof AnimNodeChildrenMap>(node_class: S, options?: NodeCreateOptions): AnimNodeChildrenMap[S];
	createNode<K extends valueof<AnimNodeChildrenMap>>(node_class: Constructor<K>, options?: NodeCreateOptions): K;
	children(): BaseAnimNodeType[];
	nodesByType<K extends keyof AnimNodeChildrenMap>(type: K): AnimNodeChildrenMap[K][];
}
declare class AudioNetworkRopNode extends ParamLessBaseNetworkRopNode {
	static type(): NetworkNodeType;
	protected _childrenControllerContext: NodeContext;
	createNode<S extends keyof AudioNodeChildrenMap>(node_class: S, options?: NodeCreateOptions): AudioNodeChildrenMap[S];
	createNode<K extends valueof<AudioNodeChildrenMap>>(node_class: Constructor<K>, options?: NodeCreateOptions): K;
	children(): BaseAudioNodeType[];
	nodesByType<K extends keyof AudioNodeChildrenMap>(type: K): AudioNodeChildrenMap[K][];
}
declare class CopNetworkRopNode extends ParamLessBaseNetworkRopNode {
	static type(): NetworkNodeType;
	protected _childrenControllerContext: NodeContext;
	createNode<S extends keyof CopNodeChildrenMap>(node_class: S, options?: NodeCreateOptions): CopNodeChildrenMap[S];
	createNode<K extends valueof<CopNodeChildrenMap>>(node_class: Constructor<K>, options?: NodeCreateOptions): K;
	children(): BaseCopNodeType[];
	nodesByType<K extends keyof CopNodeChildrenMap>(type: K): CopNodeChildrenMap[K][];
}
declare class EventsNetworkRopNode extends ParamLessBaseNetworkRopNode {
	static type(): NetworkNodeType;
	protected _childrenControllerContext: NodeContext;
	createNode<S extends keyof EventNodeChildrenMap>(node_class: S, options?: NodeCreateOptions): EventNodeChildrenMap[S];
	createNode<K extends valueof<EventNodeChildrenMap>>(node_class: Constructor<K>, options?: NodeCreateOptions): K;
	children(): BaseEventNodeType[];
	nodesByType<K extends keyof EventNodeChildrenMap>(type: K): EventNodeChildrenMap[K][];
}
declare class MaterialsNetworkRopNode extends ParamLessBaseNetworkRopNode {
	static type(): NetworkNodeType;
	protected _childrenControllerContext: NodeContext;
	createNode<S extends keyof MatNodeChildrenMap>(node_class: S, options?: NodeCreateOptions): MatNodeChildrenMap[S];
	createNode<K extends valueof<MatNodeChildrenMap>>(node_class: Constructor<K>, options?: NodeCreateOptions): K;
	children(): BaseMatNodeType[];
	nodesByType<K extends keyof MatNodeChildrenMap>(type: K): MatNodeChildrenMap[K][];
}
declare class PostProcessNetworkRopNode extends BaseNetworkRopNode<PostProcessNetworkParamsConfig> {
	paramsConfig: PostProcessNetworkParamsConfig;
	static type(): NetworkNodeType;
	readonly effectsComposerController: EffectComposerController;
	readonly displayNodeController: DisplayNodeController;
	protected _childrenControllerContext: NodeContext;
	createNode<S extends keyof PostNodeChildrenMap>(node_class: S, options?: NodeCreateOptions): PostNodeChildrenMap[S];
	createNode<K extends valueof<PostNodeChildrenMap>>(node_class: Constructor<K>, options?: NodeCreateOptions): K;
	children(): BasePostProcessNodeType[];
	nodesByType<K extends keyof PostNodeChildrenMap>(type: K): PostNodeChildrenMap[K][];
}
declare class RenderersNetworkRopNode extends ParamLessBaseNetworkRopNode {
	static type(): NetworkNodeType;
	protected _childrenControllerContext: NodeContext;
	createNode<S extends keyof RopNodeChildrenMap>(node_class: S, options?: NodeCreateOptions): RopNodeChildrenMap[S];
	createNode<K extends valueof<RopNodeChildrenMap>>(node_class: Constructor<K>, options?: NodeCreateOptions): K;
	children(): BaseRopNodeType[];
	nodesByType<K extends keyof RopNodeChildrenMap>(type: K): RopNodeChildrenMap[K][];
}
interface RopNodeChildrenMap {
	CSS2DRenderer: CSS2DRendererRopNode;
	CSS3DRenderer: CSS3DRendererRopNode;
	pathTracingRenderer: PathTracingRendererRopNode;
	WebGLRenderer: WebGLRendererRopNode;
	actorsNetwork: ActorsNetworkRopNode;
	animationsNetwork: AnimationsNetworkRopNode;
	audioNetwork: AudioNetworkRopNode;
	copNetwork: CopNetworkRopNode;
	eventsNetwork: EventsNetworkRopNode;
	materialsNetwork: MaterialsNetworkRopNode;
	postProcessNetwork: PostProcessNetworkRopNode;
	renderersNetwork: RenderersNetworkRopNode;
}
declare class RenderersNetworkPostNode extends ParamLessBaseNetworkPostNode {
	static type(): NetworkNodeType;
	protected _childrenControllerContext: NodeContext;
	createNode<S extends keyof RopNodeChildrenMap>(node_class: S, options?: NodeCreateOptions): RopNodeChildrenMap[S];
	createNode<K extends valueof<RopNodeChildrenMap>>(node_class: Constructor<K>, options?: NodeCreateOptions): K;
	children(): BaseRopNodeType[];
	nodesByType<K extends keyof RopNodeChildrenMap>(type: K): RopNodeChildrenMap[K][];
}
interface PostNodeChildrenMap {
	antialiasing: AntialiasingPostNode;
	bloom: BloomPostNode;
	blur: BlurPostNode;
	brightnessContrast: BrightnessContrastPostNode;
	builder: BuilderPostNode;
	chromaticAberration: ChromaticAberrationPostNode;
	depthOfField: DepthOfFieldPostNode;
	effectPass: EffectPassPostNode;
	glitch: GlitchPostNode;
	godRays: GodRaysPostNode;
	godRaysVolumetric: GodRaysVolumetricPostNode;
	hueSaturation: HueSaturationPostNode;
	luminance: LuminancePostNode;
	lut: LutPostNode;
	noise: NoisePostNode;
	normal: NormalPostNode;
	null: NullPostNode;
	outline: OutlinePostNode;
	pixel: PixelPostNode;
	render: RenderPostNode;
	screenSpaceAmbientOcclusion: ScreenSpaceAmbientOcclusionPostNode;
	sepia: SepiaPostNode;
	sequence: SequencePostNode;
	texture: TexturePostNode;
	updateScene: UpdateScenePostNode;
	vignette: VignettePostNode;
	actorsNetwork: ActorsNetworkPostNode;
	animationsNetwork: AnimationsNetworkPostNode;
	audioNetwork: AudioNetworkPostNode;
	copNetwork: CopNetworkPostNode;
	eventsNetwork: EventsNetworkPostNode;
	materialsNetwork: MaterialsNetworkPostNode;
	postProcessNetwork: PostProcessNetworkPostNode;
	renderersNetwork: RenderersNetworkPostNode;
}
declare class PostProcessNetworkCopNode extends BaseNetworkCopNode<PostProcessNetworkParamsConfig> {
	paramsConfig: PostProcessNetworkParamsConfig;
	static type(): NetworkNodeType;
	readonly effectsComposerController: EffectComposerController;
	readonly displayNodeController: DisplayNodeController;
	protected _childrenControllerContext: NodeContext;
	createNode<S extends keyof PostNodeChildrenMap>(node_class: S, options?: NodeCreateOptions): PostNodeChildrenMap[S];
	createNode<K extends valueof<PostNodeChildrenMap>>(node_class: Constructor<K>, options?: NodeCreateOptions): K;
	children(): BasePostProcessNodeType[];
	nodesByType<K extends keyof PostNodeChildrenMap>(type: K): PostNodeChildrenMap[K][];
}
declare class RenderersNetworkCopNode extends ParamLessBaseNetworkCopNode {
	static type(): NetworkNodeType;
	protected _childrenControllerContext: NodeContext;
	createNode<S extends keyof RopNodeChildrenMap>(node_class: S, options?: NodeCreateOptions): RopNodeChildrenMap[S];
	createNode<K extends valueof<RopNodeChildrenMap>>(node_class: Constructor<K>, options?: NodeCreateOptions): K;
	children(): BaseRopNodeType[];
	nodesByType<K extends keyof RopNodeChildrenMap>(type: K): RopNodeChildrenMap[K][];
}
interface CopNodeChildrenMap {
	audioAnalyser: AudioAnalyserCopNode;
	builder: BuilderCopNode;
	builder2DArray: Builder2DArrayCopNode;
	canvas: CanvasCopNode;
	color: ColorCopNode;
	cubeMap: CubeMapCopNode;
	cubeCamera: CubeCameraCopNode;
	cubeMapFromScene: CubeMapFromSceneCopNode;
	envMap: EnvMapCopNode;
	geometryAttribute: GeometryAttributeCopNode;
	gif: GifCopNode;
	image: ImageCopNode;
	imageEXR: ImageEXRCopNode;
	imageHDR: ImageHDRCopNode;
	imageKTX2: ImageKTX2CopNode;
	lightMap: LightMapCopNode;
	lut: LutCopNode;
	mapboxElevation: MapboxElevationCopNode;
	mapboxSatellite: MapboxSatelliteCopNode;
	null: NullCopNode;
	palette: PaletteCopNode;
	fetch: FetchCopNode;
	render: RenderCopNode;
	SDFBlur: SDFBlurCopNode;
	SDFExporter: SDFExporterCopNode;
	SDFFromObject: SDFFromObjectCopNode;
	SDFFromUrl: SDFFromUrlCopNode;
	snapshot: SnapshotCopNode;
	switch: SwitchCopNode;
	text: TextCopNode;
	textureProperties: TexturePropertiesCopNode;
	video: VideoCopNode;
	webCam: WebCamCopNode;
	actorsNetwork: ActorsNetworkCopNode;
	animationsNetwork: AnimationsNetworkCopNode;
	audioNetwork: AudioNetworkCopNode;
	copNetwork: CopNetworkCopNode;
	eventsNetwork: EventsNetworkCopNode;
	materialsNetwork: MaterialsNetworkCopNode;
	postProcessNetwork: PostProcessNetworkCopNode;
	renderersNetwork: RenderersNetworkCopNode;
}
declare class CopNetworkMatNode extends ParamLessBaseNetworkMatNode {
	static type(): NetworkNodeType;
	protected _childrenControllerContext: NodeContext;
	createNode<S extends keyof CopNodeChildrenMap>(node_class: S, options?: NodeCreateOptions): CopNodeChildrenMap[S];
	createNode<K extends valueof<CopNodeChildrenMap>>(node_class: Constructor<K>, options?: NodeCreateOptions): K;
	children(): BaseCopNodeType[];
	nodesByType<K extends keyof CopNodeChildrenMap>(type: K): CopNodeChildrenMap[K][];
}
declare class EventsNetworkMatNode extends ParamLessBaseNetworkMatNode {
	static type(): NetworkNodeType;
	protected _childrenControllerContext: NodeContext;
	createNode<S extends keyof EventNodeChildrenMap>(node_class: S, options?: NodeCreateOptions): EventNodeChildrenMap[S];
	createNode<K extends valueof<EventNodeChildrenMap>>(node_class: Constructor<K>, options?: NodeCreateOptions): K;
	children(): BaseEventNodeType[];
	nodesByType<K extends keyof EventNodeChildrenMap>(type: K): EventNodeChildrenMap[K][];
}
declare class MaterialsNetworkMatNode extends ParamLessBaseNetworkMatNode {
	static type(): NetworkNodeType;
	protected _childrenControllerContext: NodeContext;
	createNode<S extends keyof MatNodeChildrenMap>(node_class: S, options?: NodeCreateOptions): MatNodeChildrenMap[S];
	createNode<K extends valueof<MatNodeChildrenMap>>(node_class: Constructor<K>, options?: NodeCreateOptions): K;
	children(): BaseMatNodeType[];
	nodesByType<K extends keyof MatNodeChildrenMap>(type: K): MatNodeChildrenMap[K][];
}
declare class PostProcessNetworkMatNode extends BaseNetworkMatNode<PostProcessNetworkParamsConfig> {
	paramsConfig: PostProcessNetworkParamsConfig;
	static type(): NetworkNodeType;
	readonly effectsComposerController: EffectComposerController;
	readonly displayNodeController: DisplayNodeController;
	protected _childrenControllerContext: NodeContext;
	createNode<S extends keyof PostNodeChildrenMap>(node_class: S, options?: NodeCreateOptions): PostNodeChildrenMap[S];
	createNode<K extends valueof<PostNodeChildrenMap>>(node_class: Constructor<K>, options?: NodeCreateOptions): K;
	children(): BasePostProcessNodeType[];
	nodesByType<K extends keyof PostNodeChildrenMap>(type: K): PostNodeChildrenMap[K][];
}
declare class RenderersNetworkMatNode extends ParamLessBaseNetworkMatNode {
	static type(): NetworkNodeType;
	protected _childrenControllerContext: NodeContext;
	createNode<S extends keyof RopNodeChildrenMap>(node_class: S, options?: NodeCreateOptions): RopNodeChildrenMap[S];
	createNode<K extends valueof<RopNodeChildrenMap>>(node_class: Constructor<K>, options?: NodeCreateOptions): K;
	children(): BaseRopNodeType[];
	nodesByType<K extends keyof RopNodeChildrenMap>(type: K): RopNodeChildrenMap[K][];
}
interface MatNodeChildrenMap {
	builderUniformUpdate: BuilderUniformUpdateMatNode;
	clippingPlane: ClippingPlaneMatNode;
	clipProperties: ClipPropertiesMatNode;
	code: CodeMatNode;
	color: ColorMatNode;
	envMap: EnvMapMatNode;
	lineBasic: LineBasicMatNode;
	lineBasicBuilder: LineBasicBuilderMatNode;
	meshBasic: MeshBasicMatNode;
	meshBasicBuilder: MeshBasicBuilderMatNode;
	meshDepth: MeshDepthMatNode;
	meshDepthBuilder: MeshDepthBuilderMatNode;
	MeshDistance: MeshDistanceMatNode;
	meshDistanceBuilder: MeshDistanceBuilderMatNode;
	meshLambert: MeshLambertMatNode;
	meshLambertBuilder: MeshLambertBuilderMatNode;
	meshMatcap: MeshMatcapMatNode;
	meshNormal: MeshNormalMatNode;
	meshPhong: MeshPhongMatNode;
	meshPhongBuilder: MeshPhongBuilderMatNode;
	meshPhysical: MeshPhysicalMatNode;
	meshPhysicalBuilder: MeshPhysicalBuilderMatNode;
	meshStandard: MeshStandardMatNode;
	meshStandardBuilder: MeshStandardBuilderMatNode;
	meshToon: MeshToonMatNode;
	meshToonBuilder: MeshToonBuilderMatNode;
	points: PointsMatNode;
	pointsBuilder: PointsBuilderMatNode;
	rayMarchingBuilder: RayMarchingBuilderMatNode;
	shadow: ShadowMatNode;
	sky: SkyMatNode;
	stencilProperties: StencilPropertiesMatNode;
	volume: VolumeMatNode;
	volumeBuilder: VolumeBuilderMatNode;
	actorsNetwork: ActorsNetworkMatNode;
	animationsNetwork: AnimationsNetworkMatNode;
	audioNetwork: AudioNetworkMatNode;
	copNetwork: CopNetworkMatNode;
	eventsNetwork: EventsNetworkMatNode;
	materialsNetwork: MaterialsNetworkMatNode;
	postProcessNetwork: PostProcessNetworkMatNode;
	renderersNetwork: RenderersNetworkMatNode;
}
declare class MaterialsNetworkAudioNode extends ParamLessBaseNetworkAudioNode {
	static type(): NetworkNodeType;
	protected _childrenControllerContext: NodeContext;
	createNode<S extends keyof MatNodeChildrenMap>(node_class: S, options?: NodeCreateOptions): MatNodeChildrenMap[S];
	createNode<K extends valueof<MatNodeChildrenMap>>(node_class: Constructor<K>, options?: NodeCreateOptions): K;
	children(): BaseMatNodeType[];
	nodesByType<K extends keyof MatNodeChildrenMap>(type: K): MatNodeChildrenMap[K][];
}
declare class PostProcessNetworkAudioNode extends BaseNetworkAudioNode<PostProcessNetworkParamsConfig> {
	paramsConfig: PostProcessNetworkParamsConfig;
	static type(): NetworkNodeType;
	readonly effectsComposerController: EffectComposerController;
	readonly displayNodeController: DisplayNodeController;
	protected _childrenControllerContext: NodeContext;
	createNode<S extends keyof PostNodeChildrenMap>(node_class: S, options?: NodeCreateOptions): PostNodeChildrenMap[S];
	createNode<K extends valueof<PostNodeChildrenMap>>(node_class: Constructor<K>, options?: NodeCreateOptions): K;
	children(): BasePostProcessNodeType[];
	nodesByType<K extends keyof PostNodeChildrenMap>(type: K): PostNodeChildrenMap[K][];
}
declare class RenderersNetworkAudioNode extends ParamLessBaseNetworkAudioNode {
	static type(): NetworkNodeType;
	protected _childrenControllerContext: NodeContext;
	createNode<S extends keyof RopNodeChildrenMap>(node_class: S, options?: NodeCreateOptions): RopNodeChildrenMap[S];
	createNode<K extends valueof<RopNodeChildrenMap>>(node_class: Constructor<K>, options?: NodeCreateOptions): K;
	children(): BaseRopNodeType[];
	nodesByType<K extends keyof RopNodeChildrenMap>(type: K): RopNodeChildrenMap[K][];
}
interface AudioNodeChildrenMap {
	AMSynth: AMSynthAudioNode;
	autoFilter: AutoFilterAudioNode;
	autoWah: AutoWahAudioNode;
	bitCrusher: BitCrusherAudioNode;
	chebyshev: ChebyshevAudioNode;
	chorus: ChorusAudioNode;
	distortion: DistortionAudioNode;
	envelope: EnvelopeAudioNode;
	FFT: FFTAudioNode;
	FMSynth: FMSynthAudioNode;
	feedbackDelay: FeedbackDelayAudioNode;
	fetch: FetchAudioNode;
	file: FileAudioNode;
	frequencyShifter: FrequencyShifterAudioNode;
	meter: MeterAudioNode;
	monoSynth: MonoSynthAudioNode;
	noise: NoiseAudioNode;
	null: NullAudioNode;
	phaser: PhaserAudioNode;
	pingPongDelay: PingPongDelayAudioNode;
	pitchShift: PitchShiftAudioNode;
	playInstrument: PlayInstrumentAudioNode;
	polySynth: PolySynthAudioNode;
	reverb: ReverbAudioNode;
	sampler: SamplerAudioNode;
	stereoWidener: StereoWidenerAudioNode;
	switch: SwitchAudioNode;
	synth: SynthAudioNode;
	tremolo: TremoloAudioNode;
	userMedia: UserMediaAudioNode;
	vibrato: VibratoAudioNode;
	volume: VolumeAudioNode;
	waveform: WaveformAudioNode;
	actorsNetwork: ActorsNetworkAudioNode;
	animationsNetwork: AnimationsNetworkAudioNode;
	audioNetwork: AudioNetworkAudioNode;
	copNetwork: CopNetworkAudioNode;
	eventsNetwork: EventsNetworkAudioNode;
	materialsNetwork: MaterialsNetworkAudioNode;
	postProcessNetwork: PostProcessNetworkAudioNode;
	renderersNetwork: RenderersNetworkAudioNode;
}
declare class AudioNetworkAnimNode extends ParamLessBaseNetworkAnimNode {
	static type(): NetworkNodeType;
	protected _childrenControllerContext: NodeContext;
	createNode<S extends keyof AudioNodeChildrenMap>(node_class: S, options?: NodeCreateOptions): AudioNodeChildrenMap[S];
	createNode<K extends valueof<AudioNodeChildrenMap>>(node_class: Constructor<K>, options?: NodeCreateOptions): K;
	children(): BaseAudioNodeType[];
	nodesByType<K extends keyof AudioNodeChildrenMap>(type: K): AudioNodeChildrenMap[K][];
}
declare class CopNetworkAnimNode extends ParamLessBaseNetworkAnimNode {
	static type(): NetworkNodeType;
	protected _childrenControllerContext: NodeContext;
	createNode<S extends keyof CopNodeChildrenMap>(node_class: S, options?: NodeCreateOptions): CopNodeChildrenMap[S];
	createNode<K extends valueof<CopNodeChildrenMap>>(node_class: Constructor<K>, options?: NodeCreateOptions): K;
	children(): BaseCopNodeType[];
	nodesByType<K extends keyof CopNodeChildrenMap>(type: K): CopNodeChildrenMap[K][];
}
declare class EventsNetworkAnimNode extends ParamLessBaseNetworkAnimNode {
	static type(): NetworkNodeType;
	protected _childrenControllerContext: NodeContext;
	createNode<S extends keyof EventNodeChildrenMap>(node_class: S, options?: NodeCreateOptions): EventNodeChildrenMap[S];
	createNode<K extends valueof<EventNodeChildrenMap>>(node_class: Constructor<K>, options?: NodeCreateOptions): K;
	children(): BaseEventNodeType[];
	nodesByType<K extends keyof EventNodeChildrenMap>(type: K): EventNodeChildrenMap[K][];
}
declare class MaterialsNetworkAnimNode extends ParamLessBaseNetworkAnimNode {
	static type(): NetworkNodeType;
	protected _childrenControllerContext: NodeContext;
	createNode<S extends keyof MatNodeChildrenMap>(node_class: S, options?: NodeCreateOptions): MatNodeChildrenMap[S];
	createNode<K extends valueof<MatNodeChildrenMap>>(node_class: Constructor<K>, options?: NodeCreateOptions): K;
	children(): BaseMatNodeType[];
	nodesByType<K extends keyof MatNodeChildrenMap>(type: K): MatNodeChildrenMap[K][];
}
declare class PostProcessNetworkAnimNode extends BaseNetworkAnimNode<PostProcessNetworkParamsConfig> {
	paramsConfig: PostProcessNetworkParamsConfig;
	static type(): NetworkNodeType;
	readonly effectsComposerController: EffectComposerController;
	readonly displayNodeController: DisplayNodeController;
	protected _childrenControllerContext: NodeContext;
	createNode<S extends keyof PostNodeChildrenMap>(node_class: S, options?: NodeCreateOptions): PostNodeChildrenMap[S];
	createNode<K extends valueof<PostNodeChildrenMap>>(node_class: Constructor<K>, options?: NodeCreateOptions): K;
	children(): BasePostProcessNodeType[];
	nodesByType<K extends keyof PostNodeChildrenMap>(type: K): PostNodeChildrenMap[K][];
}
declare class RenderersNetworkAnimNode extends ParamLessBaseNetworkAnimNode {
	static type(): NetworkNodeType;
	protected _childrenControllerContext: NodeContext;
	createNode<S extends keyof RopNodeChildrenMap>(node_class: S, options?: NodeCreateOptions): RopNodeChildrenMap[S];
	createNode<K extends valueof<RopNodeChildrenMap>>(node_class: Constructor<K>, options?: NodeCreateOptions): K;
	children(): BaseRopNodeType[];
	nodesByType<K extends keyof RopNodeChildrenMap>(type: K): RopNodeChildrenMap[K][];
}
interface AnimNodeChildrenMap {
	delay: DelayAnimNode;
	duration: DurationAnimNode;
	easing: EasingAnimNode;
	merge: MergeAnimNode;
	null: NullAnimNode;
	operation: OperationAnimNode;
	play: PlayAnimNode;
	position: PositionAnimNode;
	propertyName: PropertyNameAnimNode;
	propertyValue: PropertyValueAnimNode;
	repeat: RepeatAnimNode;
	subnet: SubnetAnimNode;
	subnetInput: SubnetInputAnimNode;
	subnetOutput: SubnetOutputAnimNode;
	switch: SwitchAnimNode;
	target: TargetAnimNode;
	actorsNetwork: ActorsNetworkAnimNode;
	animationsNetwork: AnimationsNetworkAnimNode;
	audioNetwork: AudioNetworkAnimNode;
	copNetwork: CopNetworkAnimNode;
	eventsNetwork: EventsNetworkAnimNode;
	materialsNetwork: MaterialsNetworkAnimNode;
	postProcessNetwork: PostProcessNetworkAnimNode;
	renderersNetwork: RenderersNetworkAnimNode;
}
declare class AnimationsNetworkEventNode extends ParamLessBaseNetworkEventNode {
	static type(): NetworkNodeType;
	protected _childrenControllerContext: NodeContext;
	createNode<S extends keyof AnimNodeChildrenMap>(node_class: S, options?: NodeCreateOptions): AnimNodeChildrenMap[S];
	createNode<K extends valueof<AnimNodeChildrenMap>>(node_class: Constructor<K>, options?: NodeCreateOptions): K;
	children(): BaseAnimNodeType[];
	nodesByType<K extends keyof AnimNodeChildrenMap>(type: K): AnimNodeChildrenMap[K][];
}
declare class AudioNetworkEventNode extends ParamLessBaseNetworkEventNode {
	static type(): NetworkNodeType;
	protected _childrenControllerContext: NodeContext;
	createNode<S extends keyof AudioNodeChildrenMap>(node_class: S, options?: NodeCreateOptions): AudioNodeChildrenMap[S];
	createNode<K extends valueof<AudioNodeChildrenMap>>(node_class: Constructor<K>, options?: NodeCreateOptions): K;
	children(): BaseAudioNodeType[];
	nodesByType<K extends keyof AudioNodeChildrenMap>(type: K): AudioNodeChildrenMap[K][];
}
declare class CopNetworkEventNode extends ParamLessBaseNetworkEventNode {
	static type(): NetworkNodeType;
	protected _childrenControllerContext: NodeContext;
	createNode<S extends keyof CopNodeChildrenMap>(node_class: S, options?: NodeCreateOptions): CopNodeChildrenMap[S];
	createNode<K extends valueof<CopNodeChildrenMap>>(node_class: Constructor<K>, options?: NodeCreateOptions): K;
	children(): BaseCopNodeType[];
	nodesByType<K extends keyof CopNodeChildrenMap>(type: K): CopNodeChildrenMap[K][];
}
declare class EventsNetworkEventNode extends ParamLessBaseNetworkEventNode {
	static type(): NetworkNodeType;
	protected _childrenControllerContext: NodeContext;
	createNode<S extends keyof EventNodeChildrenMap>(node_class: S, options?: NodeCreateOptions): EventNodeChildrenMap[S];
	createNode<K extends valueof<EventNodeChildrenMap>>(node_class: Constructor<K>, options?: NodeCreateOptions): K;
	children(): BaseEventNodeType[];
	nodesByType<K extends keyof EventNodeChildrenMap>(type: K): EventNodeChildrenMap[K][];
}
declare class MaterialsNetworkEventNode extends ParamLessBaseNetworkEventNode {
	static type(): NetworkNodeType;
	protected _childrenControllerContext: NodeContext;
	createNode<S extends keyof MatNodeChildrenMap>(node_class: S, options?: NodeCreateOptions): MatNodeChildrenMap[S];
	createNode<K extends valueof<MatNodeChildrenMap>>(node_class: Constructor<K>, options?: NodeCreateOptions): K;
	children(): BaseMatNodeType[];
	nodesByType<K extends keyof MatNodeChildrenMap>(type: K): MatNodeChildrenMap[K][];
}
declare class PostProcessNetworkEventNode extends BaseNetworkEventNode<PostProcessNetworkParamsConfig> {
	paramsConfig: PostProcessNetworkParamsConfig;
	static type(): NetworkNodeType;
	readonly effectsComposerController: EffectComposerController;
	readonly displayNodeController: DisplayNodeController;
	protected _childrenControllerContext: NodeContext;
	createNode<S extends keyof PostNodeChildrenMap>(node_class: S, options?: NodeCreateOptions): PostNodeChildrenMap[S];
	createNode<K extends valueof<PostNodeChildrenMap>>(node_class: Constructor<K>, options?: NodeCreateOptions): K;
	children(): BasePostProcessNodeType[];
	nodesByType<K extends keyof PostNodeChildrenMap>(type: K): PostNodeChildrenMap[K][];
}
declare class RenderersNetworkEventNode extends ParamLessBaseNetworkEventNode {
	static type(): NetworkNodeType;
	protected _childrenControllerContext: NodeContext;
	createNode<S extends keyof RopNodeChildrenMap>(node_class: S, options?: NodeCreateOptions): RopNodeChildrenMap[S];
	createNode<K extends valueof<RopNodeChildrenMap>>(node_class: Constructor<K>, options?: NodeCreateOptions): K;
	children(): BaseRopNodeType[];
	nodesByType<K extends keyof RopNodeChildrenMap>(type: K): RopNodeChildrenMap[K][];
}
interface EventNodeChildrenMap {
	audio: AudioEventNode;
	animation: AnimationEventNode;
	any: AnyEventNode;
	block: BlockEventNode;
	button: ButtonEventNode;
	cameraMapControls: CameraOrbitControlsEventNode;
	cameraOrbitControls: CameraMapControlsEventNode;
	debounce: DebounceEventNode;
	delay: DelayEventNode;
	drag: DragEventNode;
	code: CodeEventNode;
	firstPersonControls: FirstPersonControlsEventNode;
	intersectData: IntersectDataEventNode;
	keyboard: KeyboardEventNode;
	limit: LimitEventNode;
	message: MessageEventNode;
	mobileJoystickControls: MobileJoystickControlsEventNode;
	mouse: MouseEventNode;
	nodeCook: NodeCookEventNode;
	null: NullEventNode;
	param: ParamEventNode;
	pointer: PointerEventNode;
	raycast: RaycastEventNode;
	scene: SceneEventNode;
	scrollTrigger: ScrollTriggerEventNode;
	setFlag: SetFlagEventNode;
	setParam: SetParamEventNode;
	sequence: SequenceEventNode;
	throttle: ThrottleEventNode;
	timer: TimerEventNode;
	touch: TouchEventNode;
	viewer: ViewerEventNode;
	window: WindowEventNode;
	actorsNetwork: ActorsNetworkEventNode;
	animationsNetwork: AnimationsNetworkEventNode;
	audioNetwork: AudioNetworkEventNode;
	copNetwork: CopNetworkEventNode;
	eventsNetwork: EventsNetworkEventNode;
	materialsNetwork: MaterialsNetworkEventNode;
	postProcessNetwork: PostProcessNetworkEventNode;
	renderersNetwork: RenderersNetworkEventNode;
}
declare class CameraControlsSopParamsConfig extends HierarchyParamConfigAll {
	/** @param renderer */
	node: ParamTemplate<ParamType.NODE_PATH>;
}
declare class CameraControlsSopNode extends TypedSopNode<CameraControlsSopParamsConfig> {
	readonly paramsConfig: CameraControlsSopParamsConfig;
	static type(): CameraSopNodeType;
	protected initializeNode(): void;
	private _operation;
	cook(inputCoreGroups: CoreGroup[]): void;
	protected _childrenControllerContext: NodeContext;
	createNode<S extends keyof EventNodeChildrenMap>(node_class: S, options?: NodeCreateOptions): EventNodeChildrenMap[S];
	createNode<K extends valueof<EventNodeChildrenMap>>(node_class: Constructor<K>, options?: NodeCreateOptions): K;
	children(): BaseEventNodeType[];
	nodesByType<K extends keyof EventNodeChildrenMap>(type: K): EventNodeChildrenMap[K][];
}
declare class CameraCSSRendererSopParamsConfig extends HierarchyParamConfigAll {
	/** @param renderer */
	node: ParamTemplate<ParamType.NODE_PATH>;
}
declare class CameraCSSRendererSopNode extends TypedSopNode<CameraCSSRendererSopParamsConfig> {
	readonly paramsConfig: CameraCSSRendererSopParamsConfig;
	static type(): CameraSopNodeType;
	protected initializeNode(): void;
	private _operation;
	cook(inputCoreGroups: CoreGroup[]): void;
	protected _childrenControllerContext: NodeContext;
	createNode<S extends keyof RopNodeChildrenMap>(node_class: S, options?: NodeCreateOptions): RopNodeChildrenMap[S];
	createNode<K extends valueof<RopNodeChildrenMap>>(node_class: Constructor<K>, options?: NodeCreateOptions): K;
	children(): BaseRopNodeType[];
	nodesByType<K extends keyof RopNodeChildrenMap>(type: K): RopNodeChildrenMap[K][];
}
declare const CameraFPSSopParamsConfig_base: {
	new (...args: any[]): {
		maxFPS: ParamTemplate<ParamType.INTEGER>;
		allowDynamicChange: ParamTemplate<ParamType.BOOLEAN>;
	};
} & typeof HierarchyParamConfigAll;
declare class CameraFPSSopParamsConfig extends CameraFPSSopParamsConfig_base {
}
declare class CameraFPSSopNode extends TypedSopNode<CameraFPSSopParamsConfig> {
	readonly paramsConfig: CameraFPSSopParamsConfig;
	static type(): CameraSopNodeType;
	protected initializeNode(): void;
	private _operation;
	cook(inputCoreGroups: CoreGroup[]): void;
}
declare const CameraFrameModeSopParamsConfig_base: {
	new (...args: any[]): {
		frameMode: ParamTemplate<ParamType.INTEGER>;
		expectedAspectRatio: ParamTemplate<ParamType.FLOAT>;
	};
} & typeof HierarchyParamConfigAll;
declare class CameraFrameModeSopParamsConfig extends CameraFrameModeSopParamsConfig_base {
}
declare class CameraFrameModeSopNode extends TypedSopNode<CameraFrameModeSopParamsConfig> {
	readonly paramsConfig: CameraFrameModeSopParamsConfig;
	static type(): CameraSopNodeType;
	protected initializeNode(): void;
	private _operation;
	cook(inputCoreGroups: CoreGroup[]): void;
}
declare class CameraPlaneSopParamsConfig extends NodeParamsConfig {
	/** @param camera */
	camera: ParamTemplate<ParamType.NODE_PATH>;
	/** @param axis perpendicular to the plane */
	direction: ParamTemplate<ParamType.VECTOR3>;
	/** @param plane offset */
	offset: ParamTemplate<ParamType.FLOAT>;
	/** @param defines if the plane resolution is sets via the number of segments or via the step size */
	useSegmentsCount: ParamTemplate<ParamType.BOOLEAN>;
	/** @param step size */
	stepSize: ParamTemplate<ParamType.FLOAT>;
	/** @param segments count */
	segments: ParamTemplate<ParamType.VECTOR2>;
	/** @param multiplies the size of the plane. This can be useful to scale down the plane. While it would cover a smaller part of the view, it would be faster to create  */
	sizeMult: ParamTemplate<ParamType.FLOAT>;
	/** @param update on window resize  */
	updateOnWindowResize: ParamTemplate<ParamType.BOOLEAN>;
	/** @param update */
	update: ParamTemplate<ParamType.BUTTON>;
}
declare class CameraPlaneSopNode extends TypedSopNode<CameraPlaneSopParamsConfig> {
	paramsConfig: CameraPlaneSopParamsConfig;
	static type(): string;
	private _plane;
	private _raycaster;
	private _planeCorners;
	private _planeCenter;
	private _coreTransform;
	cook(): void;
	private _updateWindowControllerDependency;
	private _computePlaneParams;
	private segments_count;
	private planeSize;
	private _createPlane;
	static PARAM_CALLBACK_update(node: CameraPlaneSopNode): void;
	private _paramCallbackUpdate;
}
declare const CameraPostProcessSopParamsConfig_base: {
	new (...args: any[]): {
		prependRenderPass: ParamTemplate<ParamType.BOOLEAN>;
		depthBuffer: ParamTemplate<ParamType.BOOLEAN>;
		stencilBuffer: ParamTemplate<ParamType.BOOLEAN>;
		sampling: ParamTemplate<ParamType.INTEGER>;
		tTextureType: ParamTemplate<ParamType.BOOLEAN>;
		textureType: ParamTemplate<ParamType.INTEGER>;
	};
} & {
	new (...args: any[]): {
		/** @param set to true to define the post process nodes from a different node than this one */
		useOtherNode: ParamTemplate<ParamType.BOOLEAN>;
		/** @param other parent node containing the post process nodes that will make up the passes used */
		node: ParamTemplate<ParamType.NODE_PATH>;
	};
} & typeof HierarchyParamConfigAll;
declare class CameraPostProcessSopParamsConfig extends CameraPostProcessSopParamsConfig_base {
}
declare class CameraPostProcessSopNode extends TypedSopNode<CameraPostProcessSopParamsConfig> {
	readonly paramsConfig: CameraPostProcessSopParamsConfig;
	static type(): CameraSopNodeType;
	protected initializeNode(): void;
	private _operation;
	cook(inputCoreGroups: CoreGroup[]): void;
	readonly effectsComposerController: EffectComposerController;
	readonly displayNodeController: DisplayNodeController;
	protected _childrenControllerContext: NodeContext;
	createNode<S extends keyof PostNodeChildrenMap>(node_class: S, options?: NodeCreateOptions): PostNodeChildrenMap[S];
	createNode<K extends valueof<PostNodeChildrenMap>>(node_class: Constructor<K>, options?: NodeCreateOptions): K;
	children(): BasePostProcessNodeType[];
	nodesByType<K extends keyof PostNodeChildrenMap>(type: K): PostNodeChildrenMap[K][];
}
declare class CameraProjectSopParamsConfig extends NodeParamsConfig {
	/** @param unproject */
	project: ParamTemplate<ParamType.BOOLEAN>;
}
declare class CameraProjectSopNode extends TypedSopNode<CameraProjectSopParamsConfig> {
	paramsConfig: CameraProjectSopParamsConfig;
	static type(): SopType;
	initializeNode(): void;
	private _operation;
	cook(input_contents: CoreGroup[]): void;
}
declare class CameraRenderSceneSopParamsConfig extends HierarchyParamConfigAll {
	/** @param renderer */
	node: ParamTemplate<ParamType.NODE_PATH>;
}
declare class CameraRenderSceneSopNode extends TypedSopNode<CameraRenderSceneSopParamsConfig> {
	readonly paramsConfig: CameraRenderSceneSopParamsConfig;
	static type(): CameraSopNodeType;
	protected initializeNode(): void;
	private _operation;
	cook(inputCoreGroups: CoreGroup[]): void;
}
declare class CameraRendererSopParamsConfig extends HierarchyParamConfigAll {
	/** @param renderer */
	node: ParamTemplate<ParamType.NODE_PATH>;
}
declare class CameraRendererSopNode extends TypedSopNode<CameraRendererSopParamsConfig> {
	readonly paramsConfig: CameraRendererSopParamsConfig;
	static type(): CameraSopNodeType;
	protected initializeNode(): void;
	private _operation;
	cook(inputCoreGroups: CoreGroup[]): void;
	protected _childrenControllerContext: NodeContext;
	createNode<S extends keyof RopNodeChildrenMap>(node_class: S, options?: NodeCreateOptions): RopNodeChildrenMap[S];
	createNode<K extends valueof<RopNodeChildrenMap>>(node_class: Constructor<K>, options?: NodeCreateOptions): K;
	children(): BaseRopNodeType[];
	nodesByType<K extends keyof RopNodeChildrenMap>(type: K): RopNodeChildrenMap[K][];
}
declare const CameraViewerCodeSopParamsConfig_base: {
	new (...args: any[]): {
		viewerId: ParamTemplate<ParamType.STRING>;
		html: ParamTemplate<ParamType.STRING>;
	};
} & typeof HierarchyParamConfigAll;
declare class CameraViewerCodeSopParamsConfig extends CameraViewerCodeSopParamsConfig_base {
}
declare class CameraViewerCodeSopNode extends TypedSopNode<CameraViewerCodeSopParamsConfig> {
	readonly paramsConfig: CameraViewerCodeSopParamsConfig;
	static type(): CameraSopNodeType;
	protected initializeNode(): void;
	private _operation;
	cook(inputCoreGroups: CoreGroup[]): void;
}
declare const CameraViewOffsetSopParamsConfig_base: {
	new (...args: any[]): {
		min: ParamTemplate<ParamType.VECTOR2>;
		max: ParamTemplate<ParamType.VECTOR2>;
	};
} & typeof HierarchyParamConfigAll;
declare class CameraViewOffsetSopParamsConfig extends CameraViewOffsetSopParamsConfig_base {
}
declare class CameraViewOffsetSopNode extends TypedSopNode<CameraViewOffsetSopParamsConfig> {
	readonly paramsConfig: CameraViewOffsetSopParamsConfig;
	static type(): CameraSopNodeType;
	protected initializeNode(): void;
	private _operation;
	cook(inputCoreGroups: CoreGroup[]): void;
}
declare const CameraWebXRARMarkerTrackingSopParamsConfig_base: {
	new (...args: any[]): {
		sourceMode: ParamTemplate<ParamType.INTEGER>;
		sourceUrl: ParamTemplate<ParamType.STRING>;
		transformMode: ParamTemplate<ParamType.INTEGER>;
		smooth: ParamTemplate<ParamType.BOOLEAN>;
		smoothCount: ParamTemplate<ParamType.INTEGER>;
		barCodeType: ParamTemplate<ParamType.STRING>;
		barCodeValue: ParamTemplate<ParamType.INTEGER>;
	};
} & typeof HierarchyParamConfigAll;
declare class CameraWebXRARMarkerTrackingSopParamsConfig extends CameraWebXRARMarkerTrackingSopParamsConfig_base {
}
declare class CameraWebXRARMarkerTrackingSopNode extends TypedSopNode<CameraWebXRARMarkerTrackingSopParamsConfig> {
	readonly paramsConfig: CameraWebXRARMarkerTrackingSopParamsConfig;
	static type(): CameraSopNodeType;
	protected initializeNode(): void;
	private _operation;
	cook(inputCoreGroups: CoreGroup[]): void;
	setSourceMode(sourceMode: MarkerTrackingSourceMode): void;
	sourceMode(): MarkerTrackingSourceMode;
	setTransformMode(sourceMode: MarkerTrackingTransformMode): void;
	transformMode(): MarkerTrackingTransformMode;
}
declare const CameraWebXRARSopParamsConfig_base: {
	new (...args: any[]): {
		hitTest: ParamTemplate<ParamType.INTEGER>;
		lightEstimation: ParamTemplate<ParamType.INTEGER>;
		cameraAccess: ParamTemplate<ParamType.INTEGER>;
		overrideReferenceSpaceType: ParamTemplate<ParamType.BOOLEAN>;
		referenceSpaceType: ParamTemplate<ParamType.INTEGER>;
	};
} & typeof HierarchyParamConfigAll;
declare class CameraWebXRARSopParamsConfig extends CameraWebXRARSopParamsConfig_base {
}
declare class CameraWebXRARSopNode extends TypedSopNode<CameraWebXRARSopParamsConfig> {
	readonly paramsConfig: CameraWebXRARSopParamsConfig;
	static type(): CameraSopNodeType;
	protected initializeNode(): void;
	private _operation;
	cook(inputCoreGroups: CoreGroup[]): void;
}
declare const CameraWebXRVRSopParamsConfig_base: {
	new (...args: any[]): {
		localFloor: ParamTemplate<ParamType.INTEGER>;
		boundedFloor: ParamTemplate<ParamType.INTEGER>;
		handTracking: ParamTemplate<ParamType.INTEGER>;
		layers: ParamTemplate<ParamType.INTEGER>;
		overrideReferenceSpaceType: ParamTemplate<ParamType.BOOLEAN>;
		referenceSpaceType: ParamTemplate<ParamType.INTEGER>;
	};
} & typeof HierarchyParamConfigAll;
declare class CameraWebXRVRSopParamsConfig extends CameraWebXRVRSopParamsConfig_base {
}
declare class CameraWebXRVRSopNode extends TypedSopNode<CameraWebXRVRSopParamsConfig> {
	readonly paramsConfig: CameraWebXRVRSopParamsConfig;
	static type(): CameraSopNodeType;
	protected initializeNode(): void;
	private _operation;
	cook(inputCoreGroups: CoreGroup[]): void;
}
declare class CapsuleSopParamsConfig extends NodeParamsConfig {
	/** @param radius */
	radius: ParamTemplate<ParamType.FLOAT>;
	/** @param height */
	height: ParamTemplate<ParamType.FLOAT>;
	/** @param divisions */
	divisions: ParamTemplate<ParamType.INTEGER>;
	/** @param center */
	center: ParamTemplate<ParamType.VECTOR3>;
}
declare class CapsuleSopNode extends TypedSopNode<CapsuleSopParamsConfig> {
	paramsConfig: CapsuleSopParamsConfig;
	static type(): SopType;
	initializeNode(): void;
	private _operation;
	cook(inputCoreGroups: CoreGroup[]): void;
}
declare enum CenterMode {
	OBJECT_ORIGIN = "object origin",
	GEOMETRY_CENTER = "geometry center"
}
declare class CenterSopParamsConfig extends NodeParamsConfig {
	mode: ParamTemplate<ParamType.INTEGER>;
}
declare class CenterSopNode extends TypedSopNode<CenterSopParamsConfig> {
	paramsConfig: CenterSopParamsConfig;
	static type(): string;
	initializeNode(): void;
	private _operation;
	cook(input_contents: CoreGroup[]): void;
	setMode(mode: CenterMode): void;
}
declare class CircleSopParamsConfig extends NodeParamsConfig {
	/** @param circle radius */
	radius: ParamTemplate<ParamType.FLOAT>;
	/** @param segments count */
	segments: ParamTemplate<ParamType.INTEGER>;
	/** @param toggle on to have an arc instead of a closed circle */
	open: ParamTemplate<ParamType.BOOLEAN>;
	/** @param connects last dot for open circle */
	connectLastPoint: ParamTemplate<ParamType.BOOLEAN>;
	/** @param angle fo the arc */
	arcAngle: ParamTemplate<ParamType.FLOAT>;
	/** @param direction of the axis perpendicular to the circle plane */
	direction: ParamTemplate<ParamType.VECTOR3>;
	/** @param center */
	center: ParamTemplate<ParamType.VECTOR3>;
}
declare class CircleSopNode extends TypedSopNode<CircleSopParamsConfig> {
	paramsConfig: CircleSopParamsConfig;
	static type(): SopType;
	private _operation;
	cook(): void;
}
declare enum PointsCountMode {
	SEGMENTS_COUNT = "segments count",
	SEGMENTS_LENGTH = "segments length"
}
declare class Circle3PointsSopParamsConfig extends NodeParamsConfig {
	/** @param toggle on to create the arc */
	arc: ParamTemplate<ParamType.BOOLEAN>;
	/** @param sets the mode how the points count is computed */
	pointsCountMode: ParamTemplate<ParamType.INTEGER>;
	/** @param length of each segment */
	segmentsLength: ParamTemplate<ParamType.FLOAT>;
	/** @param count of the number of segments */
	segmentsCount: ParamTemplate<ParamType.INTEGER>;
	/** @param toggle on to create a full circle */
	full: ParamTemplate<ParamType.BOOLEAN>;
	/** @param TBD */
	joinMode: ParamTemplate<ParamType.INTEGER>;
	/** @param add an id attribute for the generated points */
	addIdAttribute: ParamTemplate<ParamType.BOOLEAN>;
	/** @param add an idn attribute (same as id attribute, but normalized between 0 and 1) */
	addIdnAttribute: ParamTemplate<ParamType.BOOLEAN>;
	/** @param toggle on to create a point in the center */
	center: ParamTemplate<ParamType.BOOLEAN>;
}
declare class Circle3PointsSopNode extends TypedSopNode<Circle3PointsSopParamsConfig> {
	paramsConfig: Circle3PointsSopParamsConfig;
	static type(): SopType;
	initializeNode(): void;
	setPointsCountMode(mode: PointsCountMode): void;
	pointsCountMode(): PointsCountMode;
	cook(inputCoreGroups: CoreGroup[]): void;
	private a;
	private b;
	private c;
	private _create_circle;
}
declare class ClipSopParamsConfig extends NodeParamsConfig {
	/** @param origin */
	origin: ParamTemplate<ParamType.VECTOR3>;
	/** @param distance */
	distance: ParamTemplate<ParamType.FLOAT>;
	/** @param direction */
	direction: ParamTemplate<ParamType.VECTOR3>;
	/** @param intersectionEdges */
	intersectionEdges: ParamTemplate<ParamType.BOOLEAN>;
	/** @param keepBelowPlane */
	keepBelowPlane: ParamTemplate<ParamType.BOOLEAN>;
	/** @param keepAbovePlane */
	keepAbovePlane: ParamTemplate<ParamType.BOOLEAN>;
}
declare class ClipSopNode extends TypedSopNode<ClipSopParamsConfig> {
	paramsConfig: ClipSopParamsConfig;
	static type(): string;
	initializeNode(): void;
	private _operation;
	cook(inputCoreGroups: CoreGroup[]): void;
}
declare class ClothPrepareSopParamsConfig extends NodeParamsConfig {
	fuseDist: ParamTemplate<ParamType.FLOAT>;
	viscosity: ParamTemplate<ParamType.FLOAT>;
	spring: ParamTemplate<ParamType.FLOAT>;
}
declare class ClothPrepareSopNode extends TypedSopNode<ClothPrepareSopParamsConfig> {
	readonly paramsConfig: ClothPrepareSopParamsConfig;
	static type(): SopType.CLOTH_PREPARE;
	protected initializeNode(): void;
	cook(inputCoreGroups: CoreGroup[]): Promise<void>;
	private _applyFuse;
	private _addIdAttribute;
	private _addViscosityAttribute;
	private _addSpringAttribute;
	private _addFloatAttribute;
	private _addAdjacencyAttributes;
}
declare class BaseCodeSopProcessor extends BaseCodeProcessor {
	protected node: CodeSopNode;
	constructor(node: CodeSopNode);
	get pv(): ParamsValueAccessorType<CodeSopParamsConfig>;
	get p(): ParamsAccessorType<CodeSopParamsConfig>;
	initializeProcessor(): void;
	cook(inputCoreGroups: CoreGroup[]): void;
	protected setCoreGroup(coreGroup: CoreGroup): void;
	protected setObjects(objects: Object3D[]): void;
}
declare class CodeSopParamsConfig extends NodeParamsConfig {
	codeTypescript: ParamTemplate<ParamType.STRING>;
	codeJavascript: ParamTemplate<ParamType.STRING>;
}
declare class CodeSopNode extends TypedSopNode<CodeSopParamsConfig> {
	paramsConfig: CodeSopParamsConfig;
	static BaseCodeSopProcessor: typeof BaseCodeSopProcessor;
	static type(): string;
	private _lastCompiledCode;
	private _processor;
	initializeNode(): void;
	cook(inputCoreGroups: CoreGroup[]): void;
	private _compileIfRequired;
	private _compile;
}
declare class ColorSopParamsConfig extends NodeParamsConfig {
	/** @param toggle on if the color should be copied from another attribute */
	fromAttribute: ParamTemplate<ParamType.BOOLEAN>;
	/** @param attribute name to copy value from */
	attribName: ParamTemplate<ParamType.STRING>;
	/** @param color valu */
	color: ParamTemplate<ParamType.COLOR>;
	/** @param toggle on if the value should be set with hsv values rather than rgb */
	asHsv: ParamTemplate<ParamType.BOOLEAN>;
}
declare class ColorSopNode extends TypedSopNode<ColorSopParamsConfig> {
	paramsConfig: ColorSopParamsConfig;
	static type(): SopType;
	private _arrayByGeometryUUID;
	initializeNode(): void;
	cook(inputCoreGroups: CoreGroup[]): Promise<void>;
	_setFromAttribute<T extends CoreObjectType>(object: ObjectContent<T>): void;
	private _createInitColor;
	_evalSimpleValues<T extends CoreObjectType>(object: ObjectContent<T>): void;
	_evalExpressions<T extends CoreObjectType>(object: ObjectContent<T>): Promise<void>;
	private _updateFromParam;
	private _initArrayIfRequired;
	private _commitTmpValues;
}
declare class ConeSopParamsConfig extends NodeParamsConfig {
	/** @param cone radius */
	radius: ParamTemplate<ParamType.FLOAT>;
	/** @param cone height */
	height: ParamTemplate<ParamType.FLOAT>;
	/** @param radial segments count */
	segmentsRadial: ParamTemplate<ParamType.INTEGER>;
	/** @param height segments count */
	segmentsHeight: ParamTemplate<ParamType.INTEGER>;
	/** @param adds a cap */
	cap: ParamTemplate<ParamType.BOOLEAN>;
	/** @param theta start */
	thetaStart: ParamTemplate<ParamType.FLOAT>;
	/** @param start length */
	thetaLength: ParamTemplate<ParamType.FLOAT>;
	/** @param center */
	center: ParamTemplate<ParamType.VECTOR3>;
	/** @param direction */
	direction: ParamTemplate<ParamType.VECTOR3>;
}
declare class ConeSopNode extends TypedSopNode<ConeSopParamsConfig> {
	paramsConfig: ConeSopParamsConfig;
	static type(): SopType;
	cook(): void;
}
interface ContactShadowOptions {
	scene: PolyScene;
	mesh: Mesh;
	dist: number;
	renderTargetSize: Vector2;
	darkness: number;
	blur: number;
	tblur2: boolean;
	blur2: number;
	renderAllObjects: boolean;
	objectsMask: string;
	showHelper: boolean;
}
declare class ContactShadowController {
	protected _options: ContactShadowOptions;
	private _shadowCamera;
	private _planeMaterial;
	private _depthMaterial;
	private _darknessUniform;
	readonly renderTarget: WebGLRenderTarget;
	private _coreRenderBlur;
	private _emptyOnBeforeRender;
	private _helper;
	private _initialVisibilityState;
	private _includedObjects;
	private _mesh;
	private _scene;
	constructor(_options: ContactShadowOptions);
	renderShadow(renderer: WebGLRenderer, scene: Scene): void;
	private _createMaterials;
	private _createDepthCamera;
	/**
	 *
	 * VISIBILITY
	 *
	 */
	private _initVisibility;
	private _restoreVisibility;
}
declare class ContactShadowsSopParamsConfig extends NodeParamsConfig {
	renderAllObjects: ParamTemplate<ParamType.BOOLEAN>;
	objects: ParamTemplate<ParamType.STRING>;
	/** @param distance from the ground up to which shadows are visible */
	dist: ParamTemplate<ParamType.FLOAT>;
	/** @param shadow resolution */
	shadowRes: ParamTemplate<ParamType.VECTOR2>;
	/** @param shadow opacity */
	opacity: ParamTemplate<ParamType.FLOAT>;
	/** @param blur amount */
	blur: ParamTemplate<ParamType.FLOAT>;
	/** @param toggle on to add a secondary blur, which may be useful to get rid of artefacts */
	tblur2: ParamTemplate<ParamType.BOOLEAN>;
	/** @param secondary blur amount */
	blur2: ParamTemplate<ParamType.FLOAT>;
	/** @param show helper */
	showHelper: ParamTemplate<ParamType.BOOLEAN>;
}
declare class ContactShadowsSopNode extends TypedSopNode<ContactShadowsSopParamsConfig> {
	paramsConfig: ContactShadowsSopParamsConfig;
	static type(): SopType;
	initializeNode(): void;
	private _planeOperation;
	cook(inputCoreGroups: CoreGroup[]): void;
	private _defaultCoreGroup;
	updateObjectOnAdd(object: Object3D, parent: Object3D): void;
	private _lastContactShadowsController;
	lastContactShadowsController(): ContactShadowController | undefined;
}
declare class ConvexHullSopParamsConfig extends NodeParamsConfig {
}
declare class ConvexHullSopNode extends TypedSopNode<ConvexHullSopParamsConfig> {
	readonly paramsConfig: ConvexHullSopParamsConfig;
	static type(): string;
	protected initializeNode(): void;
	private _operation;
	cook(inputCoreGroups: CoreGroup[]): void;
}
declare class BaseCopyStamp extends CoreGraphNode {
	protected _globalIndex: number | undefined;
	constructor(scene: PolyScene);
	reset(): void;
	setGlobalIndex(index: number): void;
	value(attribName?: string): AttribValue | undefined;
}
declare class SopCopyStamp extends BaseCopyStamp {
	protected _point: CorePoint | undefined;
	reset(): void;
	setPoint(point?: CorePoint): void;
	value(attribName?: string): string | number | boolean | Vector2Like | ColorLike | Number2 | Number3 | Number4 | undefined;
}
declare class CopySopParamsConfig extends NodeParamsConfig {
	/** @param select which objects are copied */
	srcGroup: ParamTemplate<ParamType.STRING>;
	/** @param select which objects the src objects are copied onto */
	templateGroup: ParamTemplate<ParamType.STRING>;
	/** @param copies count, used when the second input is not given */
	count: ParamTemplate<ParamType.INTEGER>;
	/** @param translate each copy */
	t: ParamTemplate<ParamType.VECTOR3>;
	/** @param rotate each copy */
	r: ParamTemplate<ParamType.VECTOR3>;
	/** @param scale each copy */
	s: ParamTemplate<ParamType.VECTOR3>;
	/** @param scale multiplier for each copy */
	scale: ParamTemplate<ParamType.FLOAT>;
	/** @param transforms every input object each on a single input point */
	transformOnly: ParamTemplate<ParamType.BOOLEAN>;
	/** @param defines if the objects or the geometries are transformed */
	transformMode: ParamTemplate<ParamType.INTEGER>;
	/** @param defines how the objects are transformed */
	objectTransformSpace: ParamTemplate<ParamType.INTEGER>;
	/** @param toggles on to copy attributes from the input points to the created objects. Note that the vertex attributes from the points become object attributes */
	copyAttributes: ParamTemplate<ParamType.BOOLEAN>;
	/** @param names of attributes to copy */
	attributesToCopy: ParamTemplate<ParamType.STRING>;
	/** @param toggle on to use the `copy` expression, which allows to change how the left input is evaluated for each point */
	useCopyExpr: ParamTemplate<ParamType.BOOLEAN>;
}
declare class CopySopNode extends TypedSopNode<CopySopParamsConfig> {
	paramsConfig: CopySopParamsConfig;
	static type(): SopType;
	private _attribNamesToCopy;
	private _objects;
	private _stampNode;
	initializeNode(): void;
	setTransformMode(transformMode: TransformTargetType): void;
	setObjectTransformSpace(transformSpace: ObjectTransformSpace): void;
	cook(inputCoreGroups: CoreGroup[]): Promise<void>;
	private _instancer;
	private cookWithTemplate;
	private _copyMovedObjectsOnTemplatePoints;
	private _instanceMatrix;
	private _copyMovedObjectOnTemplatePoint;
	private _getMovedObjectsForTemplatePoint;
	private _stampInstanceGroupIfRequired;
	private _copyMovedObjectsForEachInstance;
	private _copyMovedObjectsForInstance;
	private cookWithoutTemplate;
	private _copyAttributesGromTemplate;
	stampValue(attribName?: string): string | number | boolean | Vector2Like | ColorLike | Number2 | Number3 | Number4 | undefined;
	stampNode(): SopCopyStamp;
	private _createStampNode;
	dispose(): void;
	private _coreTransform;
	private _transformAccumulatedMatrix;
	private _transformMatrix;
	private _initAccumulatedTransform;
	private _accumulateTransform;
	private _applyMatrixToObject;
	private _applyAccumulatedTransform;
}
declare class CurveFromPointsSopParamsConfig extends NodeParamsConfig {
	/** @param points Count */
	pointsCount: ParamTemplate<ParamType.INTEGER>;
	/** @param closed */
	closed: ParamTemplate<ParamType.BOOLEAN>;
	/** @param curve type */
	curveType: ParamTemplate<ParamType.INTEGER>;
	/** @param tension */
	tension: ParamTemplate<ParamType.FLOAT>;
	/** @param add tangent attribute */
	tTangent: ParamTemplate<ParamType.BOOLEAN>;
	/** @param tangent attribute name */
	tangentName: ParamTemplate<ParamType.STRING>;
}
declare class CurveFromPointsSopNode extends TypedSopNode<CurveFromPointsSopParamsConfig> {
	readonly paramsConfig: CurveFromPointsSopParamsConfig;
	static type(): SopType;
	protected initializeNode(): void;
	private _operation;
	cook(inputCoreGroups: CoreGroup[]): void;
}
declare class CurveGetPointSopParamsConfig extends NodeParamsConfig {
	/** @param t */
	t: ParamTemplate<ParamType.FLOAT>;
	/** @param closed */
	closed: ParamTemplate<ParamType.BOOLEAN>;
	/** @param curve type */
	curveType: ParamTemplate<ParamType.INTEGER>;
	/** @param tension */
	tension: ParamTemplate<ParamType.FLOAT>;
	/** @param add tangent attribute */
	tTangent: ParamTemplate<ParamType.BOOLEAN>;
	/** @param tangent attribute name */
	tangentName: ParamTemplate<ParamType.STRING>;
}
declare class CurveGetPointSopNode extends TypedSopNode<CurveGetPointSopParamsConfig> {
	readonly paramsConfig: CurveGetPointSopParamsConfig;
	static type(): string;
	protected initializeNode(): void;
	private _operation;
	cook(inputCoreGroups: CoreGroup[]): void;
}
declare class CSGSopNode<K extends NodeParamsConfig> extends TypedSopNode<K> {
	dataType(): string;
	requiredModules(): ModuleName[];
	setCSGGeometry<T extends CsgGeometryType>(geometry: CsgTypeMap[T]): void;
	setCSGGeometries(geometries: CsgGeometry[]): void;
	setCSGObjects(csgObjects: CsgObject<CsgGeometryType>[]): void;
	setCSGObject(csgObject: CsgObject<CsgGeometryType>): void;
	protected _setContainerCsgObjects(objects: CsgObject<CsgGeometryType>[]): void;
}
declare class CSGArcSopParamsConfig extends NodeParamsConfig {
	/** @param radius */
	radius: ParamTemplate<ParamType.FLOAT>;
	/** @param segments */
	segments: ParamTemplate<ParamType.INTEGER>;
	/** @param center */
	center: ParamTemplate<ParamType.VECTOR2>;
	/** @param make tangents */
	makeTangent: ParamTemplate<ParamType.BOOLEAN>;
	/** @param start angle */
	startAngle: ParamTemplate<ParamType.FLOAT>;
	/** @param end angle */
	endAngle: ParamTemplate<ParamType.FLOAT>;
}
declare class CSGArcSopNode extends CSGSopNode<CSGArcSopParamsConfig> {
	paramsConfig: CSGArcSopParamsConfig;
	static type(): SopType;
	private _center;
	cook(inputCoreGroups: CoreGroup[]): void;
}
declare enum BooleanCsgOperationType {
	INTERSECT = "intersect",
	SUBTRACT = "subtract",
	UNION = "union"
}
declare class CSGBooleanSopParamsConfig extends NodeParamsConfig {
	/** @param operation */
	operation: ParamTemplate<ParamType.INTEGER>;
}
declare class CSGBooleanSopNode extends CSGSopNode<CSGBooleanSopParamsConfig> {
	paramsConfig: CSGBooleanSopParamsConfig;
	static type(): SopType;
	protected initializeNode(): void;
	setOperation(operation: BooleanCsgOperationType): void;
	cook(inputCoreGroups: CoreGroup[]): void;
	private _applyOperation;
	private _method;
}
declare class CSGBoxSopParamsConfig extends NodeParamsConfig {
	/** @param size */
	size: ParamTemplate<ParamType.FLOAT>; /** @param sizes */
	sizes: ParamTemplate<ParamType.VECTOR3>;
	/** @param center */
	center: ParamTemplate<ParamType.VECTOR3>;
	/** @param bevel */
	rounded: ParamTemplate<ParamType.BOOLEAN>;
	/** @param bevel radius */
	roundedRadius: ParamTemplate<ParamType.FLOAT>;
	/** @param bevel segments */
	roundedSegments: ParamTemplate<ParamType.INTEGER>;
}
declare class CSGBoxSopNode extends CSGSopNode<CSGBoxSopParamsConfig> {
	paramsConfig: CSGBoxSopParamsConfig;
	static type(): SopType;
	private _center;
	private _sizes;
	cook(inputCoreGroups: CoreGroup[]): void;
}
declare class CSGCenterSopParamsConfig extends NodeParamsConfig {
	/** @param x */
	x: ParamTemplate<ParamType.BOOLEAN>;
	/** @param y */
	y: ParamTemplate<ParamType.BOOLEAN>;
	/** @param z */
	z: ParamTemplate<ParamType.BOOLEAN>;
	/** @param relativeTo */
	relativeTo: ParamTemplate<ParamType.VECTOR3>;
}
declare class CSGCenterSopNode extends CSGSopNode<CSGCenterSopParamsConfig> {
	paramsConfig: CSGCenterSopParamsConfig;
	static type(): SopType;
	protected initializeNode(): void;
	private _relativeTo;
	private _axes;
	cook(inputCoreGroups: CoreGroup[]): void;
}
declare class CSGCircleSopParamsConfig extends NodeParamsConfig {
	/** @param radius */
	radius: ParamTemplate<ParamType.FLOAT>;
	/** @param segments */
	segments: ParamTemplate<ParamType.INTEGER>;
	/** @param center */
	center: ParamTemplate<ParamType.VECTOR2>;
	/** @param open */
	open: ParamTemplate<ParamType.BOOLEAN>;
	/** @param start angle */
	startAngle: ParamTemplate<ParamType.FLOAT>;
	/** @param end angle */
	endAngle: ParamTemplate<ParamType.FLOAT>;
}
declare class CSGCircleSopNode extends CSGSopNode<CSGCircleSopParamsConfig> {
	paramsConfig: CSGCircleSopParamsConfig;
	static type(): SopType;
	private _center;
	cook(inputCoreGroups: CoreGroup[]): void;
}
declare class CSGDodecahedronSopParamsConfig extends NodeParamsConfig {
	/** @param radius */
	radius: ParamTemplate<ParamType.FLOAT>;
}
declare class CSGDodecahedronSopNode extends CSGSopNode<CSGDodecahedronSopParamsConfig> {
	paramsConfig: CSGDodecahedronSopParamsConfig;
	static type(): SopType;
	protected initializeNode(): void;
	cook(inputCoreGroups: CoreGroup[]): void;
}
declare class CSGEllipseSopParamsConfig extends NodeParamsConfig {
	/** @param radius */
	radius: ParamTemplate<ParamType.VECTOR2>;
	/** @param segments */
	segments: ParamTemplate<ParamType.INTEGER>;
	/** @param center */
	center: ParamTemplate<ParamType.VECTOR2>;
	/** @param open */
	open: ParamTemplate<ParamType.BOOLEAN>;
	/** @param start angle */
	startAngle: ParamTemplate<ParamType.FLOAT>;
	/** @param end angle */
	endAngle: ParamTemplate<ParamType.FLOAT>;
}
declare class CSGEllipseSopNode extends CSGSopNode<CSGEllipseSopParamsConfig> {
	paramsConfig: CSGEllipseSopParamsConfig;
	static type(): SopType;
	private _center;
	private _radius;
	cook(inputCoreGroups: CoreGroup[]): void;
}
declare class CSGEllipsoidSopParamsConfig extends NodeParamsConfig {
	/** @param center */
	center: ParamTemplate<ParamType.VECTOR3>;
	/** @param radius */
	radius: ParamTemplate<ParamType.VECTOR3>;
	/** @param segments */
	segments: ParamTemplate<ParamType.INTEGER>;
}
declare class CSGEllipsoidSopNode extends CSGSopNode<CSGEllipsoidSopParamsConfig> {
	paramsConfig: CSGEllipsoidSopParamsConfig;
	static type(): SopType;
	private _center;
	private _radius;
	cook(inputCoreGroups: CoreGroup[]): void;
}
declare enum ExpandMode {
	_2D_ONLY = "2D Only",
	_2D_AND_3D_ONLY = "2D & 3D (Slow)"
}
declare class CSGExpandSopParamsConfig extends NodeParamsConfig {
	/** @param mode */
	mode: ParamTemplate<ParamType.INTEGER>;
	/** @param delta */
	delta: ParamTemplate<ParamType.FLOAT>;
	/** @param corners */
	corners: ParamTemplate<ParamType.INTEGER>;
	/** @param segments */
	segments: ParamTemplate<ParamType.INTEGER>;
	/** @param allow 3D expand (can be very slow) */
	allowExpand3D: ParamTemplate<ParamType.BOOLEAN>;
}
declare class CSGExpandSopNode extends CSGSopNode<CSGExpandSopParamsConfig> {
	paramsConfig: CSGExpandSopParamsConfig;
	static type(): SopType;
	protected initializeNode(): void;
	setMode(mode: ExpandMode): void;
	cook(inputCoreGroups: CoreGroup[]): void;
}
declare class CSGExtrudeLinearSopParamsConfig extends NodeParamsConfig {
	/** @param height */
	height: ParamTemplate<ParamType.FLOAT>;
	/** @param twistAngle */
	twistAngle: ParamTemplate<ParamType.FLOAT>;
	/** @param twistSteps */
	twistSteps: ParamTemplate<ParamType.INTEGER>;
}
declare class CSGExtrudeLinearSopNode extends CSGSopNode<CSGExtrudeLinearSopParamsConfig> {
	paramsConfig: CSGExtrudeLinearSopParamsConfig;
	static type(): SopType;
	protected initializeNode(): void;
	cook(inputCoreGroups: CoreGroup[]): void;
}
declare class CSGExtrudeRectangularSopParamsConfig extends NodeParamsConfig {
	/** @param size */
	size: ParamTemplate<ParamType.FLOAT>;
	/** @param height */
	height: ParamTemplate<ParamType.FLOAT>;
}
declare class CSGExtrudeRectangularSopNode extends CSGSopNode<CSGExtrudeRectangularSopParamsConfig> {
	paramsConfig: CSGExtrudeRectangularSopParamsConfig;
	static type(): SopType;
	protected initializeNode(): void;
	cook(inputCoreGroups: CoreGroup[]): void;
}
declare class CSGExtrudeRotateSopParamsConfig extends NodeParamsConfig {
	/** @param angle */
	angle: ParamTemplate<ParamType.FLOAT>;
	/** @param start angle */
	startAngle: ParamTemplate<ParamType.FLOAT>;
	/** @param segments */
	segments: ParamTemplate<ParamType.INTEGER>;
}
declare class CSGExtrudeRotateSopNode extends CSGSopNode<CSGExtrudeRotateSopParamsConfig> {
	paramsConfig: CSGExtrudeRotateSopParamsConfig;
	static type(): SopType;
	protected initializeNode(): void;
	cook(inputCoreGroups: CoreGroup[]): void;
}
declare class CSGHullSopParamsConfig extends NodeParamsConfig {
	/** @param chain */
	chain: ParamTemplate<ParamType.BOOLEAN>;
}
declare class CSGHullSopNode extends CSGSopNode<CSGHullSopParamsConfig> {
	paramsConfig: CSGHullSopParamsConfig;
	static type(): SopType;
	protected initializeNode(): void;
	cook(inputCoreGroups: CoreGroup[]): void;
}
declare class CSGLineSopParamsConfig extends NodeParamsConfig {
	/** @param length */
	length: ParamTemplate<ParamType.FLOAT>;
	/** @param points count */
	pointsCount: ParamTemplate<ParamType.INTEGER>;
	/** @param origin */
	origin: ParamTemplate<ParamType.VECTOR2>;
	/** @param direction */
	direction: ParamTemplate<ParamType.VECTOR2>;
}
declare class CSGLineSopNode extends CSGSopNode<CSGLineSopParamsConfig> {
	paramsConfig: CSGLineSopParamsConfig;
	static type(): SopType;
	cook(inputCoreGroups: CoreGroup[]): void;
}
declare class CSGMirrorSopParamsConfig extends NodeParamsConfig {
	/** @param origin */
	origin: ParamTemplate<ParamType.VECTOR3>;
	/** @param normal */
	normal: ParamTemplate<ParamType.VECTOR3>;
	/** @param invert */
	invert: ParamTemplate<ParamType.BOOLEAN>;
}
declare class CSGMirrorSopNode extends CSGSopNode<CSGMirrorSopParamsConfig> {
	paramsConfig: CSGMirrorSopParamsConfig;
	static type(): SopType;
	protected initializeNode(): void;
	private _origin;
	private _normal;
	cook(inputCoreGroups: CoreGroup[]): void;
}
declare class CSGOffsetSopParamsConfig extends NodeParamsConfig {
	/** @param delta */
	delta: ParamTemplate<ParamType.FLOAT>;
	/** @param corners */
	corners: ParamTemplate<ParamType.INTEGER>;
	/** @param segments */
	segments: ParamTemplate<ParamType.INTEGER>;
}
declare class CSGOffsetSopNode extends CSGSopNode<CSGOffsetSopParamsConfig> {
	paramsConfig: CSGOffsetSopParamsConfig;
	static type(): SopType;
	protected initializeNode(): void;
	cook(inputCoreGroups: CoreGroup[]): void;
}
declare class CSGPolygonSopParamsConfig extends NodeParamsConfig {
	/** @param points */
	points: ParamTemplate<ParamType.STRING>;
	/** @param paths */
	paths: ParamTemplate<ParamType.STRING>;
}
declare class CSGPolygonSopNode extends CSGSopNode<CSGPolygonSopParamsConfig> {
	paramsConfig: CSGPolygonSopParamsConfig;
	static type(): SopType;
	cook(inputCoreGroups: CoreGroup[]): void;
}
declare class CSGPolyhedronSopParamsConfig extends NodeParamsConfig {
	/** @param points */
	points: ParamTemplate<ParamType.STRING>;
	/** @param paths */
	faces: ParamTemplate<ParamType.STRING>;
	/** @param outward */
	outward: ParamTemplate<ParamType.BOOLEAN>;
}
declare class CSGPolyhedronSopNode extends CSGSopNode<CSGPolyhedronSopParamsConfig> {
	paramsConfig: CSGPolyhedronSopParamsConfig;
	static type(): SopType;
	cook(inputCoreGroups: CoreGroup[]): void;
}
declare class CSGProjectSopParamsConfig extends NodeParamsConfig {
	/** @param axis */
	axis: ParamTemplate<ParamType.VECTOR3>;
	/** @param origin */
	origin: ParamTemplate<ParamType.VECTOR3>;
}
declare class CSGProjectSopNode extends CSGSopNode<CSGProjectSopParamsConfig> {
	paramsConfig: CSGProjectSopParamsConfig;
	static type(): SopType;
	protected initializeNode(): void;
	private _axis;
	private _origin;
	cook(inputCoreGroups: CoreGroup[]): void;
}
declare class CSGRectangleSopParamsConfig extends NodeParamsConfig {
	/** @param size */
	size: ParamTemplate<ParamType.FLOAT>;
	/** @param sizes */
	sizes: ParamTemplate<ParamType.VECTOR2>;
	/** @param center */
	center: ParamTemplate<ParamType.VECTOR2>;
	/** @param rounded */
	rounded: ParamTemplate<ParamType.BOOLEAN>;
	/** @param rounded radius */
	roundedRadius: ParamTemplate<ParamType.FLOAT>;
	/** @param rounded segments */
	roundedSegments: ParamTemplate<ParamType.INTEGER>;
}
declare class CSGRectangleSopNode extends CSGSopNode<CSGRectangleSopParamsConfig> {
	paramsConfig: CSGRectangleSopParamsConfig;
	static type(): SopType;
	private _center;
	private _sizes;
	cook(inputCoreGroups: CoreGroup[]): void;
}
declare class CSGTransformResetSopParamsConfig extends NodeParamsConfig {
	/** @param bake matrix onto points */
	extract: ParamTemplate<ParamType.BOOLEAN>;
}
declare class CSGTransformResetSopNode extends CSGSopNode<CSGTransformResetSopParamsConfig> {
	paramsConfig: CSGTransformResetSopParamsConfig;
	static type(): SopType;
	protected initializeNode(): void;
	cook(inputCoreGroups: CoreGroup[]): void;
}
declare class CSGSphereSopParamsConfig extends NodeParamsConfig {
	/** @param radius */
	radius: ParamTemplate<ParamType.FLOAT>;
	/** @param center */
	center: ParamTemplate<ParamType.VECTOR3>;
	/** @param geodesic */
	geodesic: ParamTemplate<ParamType.BOOLEAN>;
	/** @param segments */
	segments: ParamTemplate<ParamType.INTEGER>;
	/** @param frequency */
	frequency: ParamTemplate<ParamType.INTEGER>;
}
declare class CSGSphereSopNode extends CSGSopNode<CSGSphereSopParamsConfig> {
	paramsConfig: CSGSphereSopParamsConfig;
	static type(): SopType;
	private _center;
	private _matrix4;
	cook(inputCoreGroups: CoreGroup[]): void;
	private _createSphere;
	private _createGeodesicSphere;
}
declare class CSGStarSopParamsConfig extends NodeParamsConfig {
	/** @param center */
	center: ParamTemplate<ParamType.VECTOR2>;
	/** @param vertices */
	vertices: ParamTemplate<ParamType.INTEGER>;
	/** @param outer radius */
	innerRadius: ParamTemplate<ParamType.FLOAT>;
	/** @param outer radius */
	outerRadius: ParamTemplate<ParamType.FLOAT>;
	/** @param start angle */
	startAngle: ParamTemplate<ParamType.FLOAT>;
}
declare class CSGStarSopNode extends CSGSopNode<CSGStarSopParamsConfig> {
	paramsConfig: CSGStarSopParamsConfig;
	static type(): SopType;
	private _center;
	cook(inputCoreGroups: CoreGroup[]): void;
}
declare class CSGTorusSopParamsConfig extends NodeParamsConfig {
	/** @param inner radius */
	innerRadius: ParamTemplate<ParamType.FLOAT>;
	/** @param outer radius */
	outerRadius: ParamTemplate<ParamType.FLOAT>;
	/** @param inner segments */
	innerSegments: ParamTemplate<ParamType.INTEGER>;
	/** @param outer segments */
	outerSegments: ParamTemplate<ParamType.INTEGER>;
	/** @param inner rotation */
	innerRotation: ParamTemplate<ParamType.FLOAT>;
	/** @param open */
	open: ParamTemplate<ParamType.BOOLEAN>;
	/** @param start angle */
	startAngle: ParamTemplate<ParamType.FLOAT>; /** @param outer rotation */
	outerRotation: ParamTemplate<ParamType.FLOAT>;
}
declare class CSGTorusSopNode extends CSGSopNode<CSGTorusSopParamsConfig> {
	paramsConfig: CSGTorusSopParamsConfig;
	static type(): SopType;
	cook(inputCoreGroups: CoreGroup[]): void;
}
declare class CSGTransform2DSopParamsConfig extends NodeParamsConfig {
	/** @param translate */
	t: ParamTemplate<ParamType.VECTOR2>;
	/** @param rotation */
	r: ParamTemplate<ParamType.FLOAT>;
	/** @param scale (as a float) */
	s: ParamTemplate<ParamType.FLOAT>;
}
declare class CSGTransform2DSopNode extends CSGSopNode<CSGTransform2DSopParamsConfig> {
	paramsConfig: CSGTransform2DSopParamsConfig;
	static type(): SopType.CSG_TRANSFORM_2D;
	protected initializeNode(): void;
	cook(inputCoreGroups: CoreGroup[]): Promise<void>;
}
declare const CSGTriangulateSopParamsConfig_base: {
	new (...args: any[]): {
		facetAngle: ParamTemplate<ParamType.FLOAT>;
		linesColor: ParamTemplate<ParamType.COLOR>;
		meshesColor: ParamTemplate<ParamType.COLOR>;
		wireframe: ParamTemplate<ParamType.BOOLEAN>;
	};
} & typeof NodeParamsConfig;
declare class CSGTriangulateSopParamsConfig extends CSGTriangulateSopParamsConfig_base {
}
declare class CSGTriangulateSopNode extends CSGSopNode<CSGTriangulateSopParamsConfig> {
	readonly paramsConfig: CSGTriangulateSopParamsConfig;
	static type(): SopType;
	protected initializeNode(): void;
	cook(inputCoreGroups: CoreGroup[]): Promise<void>;
}
declare class CSGTriangleSopParamsConfig extends NodeParamsConfig {
	/** @param type */
	type: ParamTemplate<ParamType.INTEGER>;
	/** @param angles */
	angles: ParamTemplate<ParamType.VECTOR2>;
}
declare class CSGTriangleSopNode extends CSGSopNode<CSGTriangleSopParamsConfig> {
	paramsConfig: CSGTriangleSopParamsConfig;
	static type(): SopType;
	private _angles;
	cook(inputCoreGroups: CoreGroup[]): void;
}
declare class CSGTubeSopParamsConfig extends NodeParamsConfig {
	/** @param height */
	height: ParamTemplate<ParamType.FLOAT>;
	/** @param radius */
	radius: ParamTemplate<ParamType.FLOAT>;
	/** @param segments */
	segments: ParamTemplate<ParamType.INTEGER>;
	/** @param center */
	center: ParamTemplate<ParamType.VECTOR3>;
	/** @param rounded */
	rounded: ParamTemplate<ParamType.BOOLEAN>;
	/** @param rounded radius */
	roundedRadius: ParamTemplate<ParamType.FLOAT>;
}
declare class CSGTubeSopNode extends CSGSopNode<CSGTubeSopParamsConfig> {
	paramsConfig: CSGTubeSopParamsConfig;
	static type(): SopType;
	private _center;
	cook(inputCoreGroups: CoreGroup[]): void;
}
declare class CSGTubeEllipticSopParamsConfig extends NodeParamsConfig {
	/** @param height */
	height: ParamTemplate<ParamType.FLOAT>;
	/** @param start radius */
	startRadius: ParamTemplate<ParamType.FLOAT>;
	/** @param start radiuses */
	startRadiuses: ParamTemplate<ParamType.VECTOR2>;
	/** @param end radius */
	endRadius: ParamTemplate<ParamType.FLOAT>;
	/** @param end radius */
	endRadiuses: ParamTemplate<ParamType.VECTOR2>;
	/** @param segments */
	segments: ParamTemplate<ParamType.INTEGER>;
	/** @param center */
	center: ParamTemplate<ParamType.VECTOR3>;
	/** @param open */
	open: ParamTemplate<ParamType.BOOLEAN>;
	/** @param start angle */
	startAngle: ParamTemplate<ParamType.FLOAT>;
	/** @param end angle */
	endAngle: ParamTemplate<ParamType.FLOAT>;
}
declare class CSGTubeEllipticSopNode extends CSGSopNode<CSGTubeEllipticSopParamsConfig> {
	paramsConfig: CSGTubeEllipticSopParamsConfig;
	static type(): SopType;
	private _center;
	private _startRadiuses;
	private _endRadiuses;
	cook(inputCoreGroups: CoreGroup[]): void;
}
declare class CSS2DObjectSopParamsConfig extends NodeParamsConfig {
	/** @param toggles on if attributes are copied from the geometry to the html element */
	copyAttributes: ParamTemplate<ParamType.BOOLEAN>;
	/** @param names of the attributes that are copied from the geometry to the html element */
	attributesToCopy: ParamTemplate<ParamType.STRING>;
	/** @param defines if the vertex id attribute is used to create the html id attribute */
	overrideId: ParamTemplate<ParamType.BOOLEAN>;
	/** @param value of the html element id attribute */
	id: ParamTemplate<ParamType.STRING>;
	/** @param defines if the vertex class attribute is used to create the html class */
	overrideClassName: ParamTemplate<ParamType.BOOLEAN>;
	/** @param value of the html class */
	className: ParamTemplate<ParamType.STRING>;
	/** @param defines if the vertex html attribute is used to create the html content */
	overrideHTML: ParamTemplate<ParamType.BOOLEAN>;
	/** @param value of the html content */
	html: ParamTemplate<ParamType.STRING>;
}
declare class CSS2DObjectSopNode extends TypedSopNode<CSS2DObjectSopParamsConfig> {
	paramsConfig: CSS2DObjectSopParamsConfig;
	static type(): SopType;
	initializeNode(): void;
	cook(inputCoreGroups: CoreGroup[]): void;
	private _addAttributes;
	updateObjectOnAdd(object: Object3D, parent: Object3D): void;
}
declare class CSS3DObjectSopParamsConfig extends NodeParamsConfig {
	/** @param toggles on if attributes are copied from the geometry to the html element */
	copyAttributes: ParamTemplate<ParamType.BOOLEAN>;
	/** @param names of the attributes that are copied from the geometry to the html element */
	attributesToCopy: ParamTemplate<ParamType.STRING>;
	/** @param HTML elements may appear to large at first, so this gives you a quick way to scale them down */
	scale: ParamTemplate<ParamType.FLOAT>;
	/** @param defines if the vertex id attribute is used to create the html id attribute */
	overrideId: ParamTemplate<ParamType.BOOLEAN>;
	/** @param value of the html element id attribute */
	id: ParamTemplate<ParamType.STRING>;
	/** @param defines if the vertex class attribute is used to create the html class */
	overrideClassName: ParamTemplate<ParamType.BOOLEAN>;
	/** @param value of the html class */
	className: ParamTemplate<ParamType.STRING>;
	/** @param defines if the vertex html attribute is used to create the html content */
	overrideHTML: ParamTemplate<ParamType.BOOLEAN>;
	/** @param value of the html content */
	html: ParamTemplate<ParamType.STRING>;
}
declare class CSS3DObjectSopNode extends TypedSopNode<CSS3DObjectSopParamsConfig> {
	paramsConfig: CSS3DObjectSopParamsConfig;
	static type(): SopType;
	initializeNode(): void;
	cook(inputCoreGroups: CoreGroup[]): void;
	private _addAttributes;
	updateObjectOnAdd(object: Object3D, parent: Object3D): void;
}
declare class CubeCameraSopParamsConfig extends NodeParamsConfig {
	/** @param camera near */
	near: ParamTemplate<ParamType.FLOAT>;
	/** @param camera far */
	far: ParamTemplate<ParamType.FLOAT>;
	/** @param resolution */
	resolution: ParamTemplate<ParamType.FLOAT>;
	/** @param camera position */
	position: ParamTemplate<ParamType.VECTOR3>;
	/** @param camera rotation */
	rotation: ParamTemplate<ParamType.VECTOR3>;
	/** @param show helper */
	showHelper: ParamTemplate<ParamType.BOOLEAN>;
	/** @param matrixAutoUpdate */
	matrixAutoUpdate: ParamTemplate<ParamType.BOOLEAN>;
	/** @param camera name */
	name: ParamTemplate<ParamType.STRING>;
}
declare class CubeCameraSopNode extends TypedSopNode<CubeCameraSopParamsConfig> {
	readonly paramsConfig: CubeCameraSopParamsConfig;
	static type(): CameraNodeType;
	static onRegister: OnNodeRegisterCallback;
	protected initializeNode(): void;
	private _operation;
	cook(inputCoreGroups: CoreGroup[]): void;
}
declare class DataSopParamsConfig extends NodeParamsConfig {
	/** @param json object used to create the geometry */
	data: ParamTemplate<ParamType.STRING>;
}
declare class DataSopNode extends TypedSopNode<DataSopParamsConfig> {
	paramsConfig: DataSopParamsConfig;
	static type(): SopType;
	cook(): void;
}
declare class DataUrlSopParamsConfig extends NodeParamsConfig {
	/** @param sets if the data is interpreted as json or csv */
	dataType: ParamTemplate<ParamType.INTEGER>;
	/** @param the url to fetch the data from */
	url: ParamTemplate<ParamType.STRING>;
	/** @param if the data is inside the payload, defines the prefix to read it from here */
	jsonDataKeysPrefix: ParamTemplate<ParamType.STRING>;
	/** @param which entries are skipped */
	skipEntries: ParamTemplate<ParamType.STRING>;
	/** @param sets if some attributes should be converted */
	convert: ParamTemplate<ParamType.BOOLEAN>;
	/** @param sets which attributes should be converted from string to numeric */
	convertToNumeric: ParamTemplate<ParamType.STRING>;
	/** @param when fetching from a csv, the attribute names will not be present. Those can then be mentioned here */
	readAttribNamesFromFile: ParamTemplate<ParamType.BOOLEAN>;
	/** @param list of attributes names when fetching from a csv */
	attribNames: ParamTemplate<ParamType.STRING>;
	/** @param reload the url */
	reload: ParamTemplate<ParamType.BUTTON>;
}
declare class DataUrlSopNode extends TypedSopNode<DataUrlSopParamsConfig> {
	paramsConfig: DataUrlSopParamsConfig;
	static type(): SopType;
	cook(): Promise<void>;
	private _load;
	dispose(): void;
	private _url;
	private _loadJSON;
	private _onLoad;
	private _onError;
	private _loadCSV;
	static PARAM_CALLBACK_reload(node: DataUrlSopNode, param: BaseParamType): void;
	param_callback_reload(): void;
}
declare class DecalSopParamsConfig extends NodeParamsConfig {
	/** @param decal position */
	t: ParamTemplate<ParamType.VECTOR3>;
	/** @param decal rotation */
	r: ParamTemplate<ParamType.VECTOR3>;
	/** @param decal scale */
	s: ParamTemplate<ParamType.VECTOR3>;
	/** @param decal scale multipler */
	scale: ParamTemplate<ParamType.FLOAT>;
}
declare class DecalSopNode extends TypedSopNode<DecalSopParamsConfig> {
	paramsConfig: DecalSopParamsConfig;
	static type(): SopType;
	initializeNode(): void;
	private _operation;
	cook(input_contents: CoreGroup[]): void;
}
declare class SopSubnetOutputSopParamsConfig extends NodeParamsConfig {
}
declare class SubnetOutputSopNode extends TypedSopNode<SopSubnetOutputSopParamsConfig> {
	paramsConfig: SopSubnetOutputSopParamsConfig;
	static type(): Readonly<NetworkChildNodeType.OUTPUT>;
	initializeNode(): void;
	cook(inputCoreGroups: CoreGroup[]): void;
}
declare class SubnetSopNodeLike<T extends NodeParamsConfig> extends TypedSopNode<T> {
	private _overrideOutputNode;
	initializeBaseNode(): void;
	readonly childrenDisplayController: SopSubnetChildrenDisplayController;
	readonly displayNodeController: DisplayNodeController;
	protected _childrenControllerContext: NodeContext;
	createNode<S extends keyof GeoNodeChildrenMap>(node_class: S, options?: NodeCreateOptions): GeoNodeChildrenMap[S];
	createNode<K extends valueof<GeoNodeChildrenMap>>(node_class: Constructor<K>, options?: NodeCreateOptions): K;
	children(): BaseSopNodeType[];
	nodesByType<K extends keyof GeoNodeChildrenMap>(type: K): GeoNodeChildrenMap[K][];
	cook(inputCoreGroups: CoreGroup[]): Promise<void>;
	private _cookFromChildOutputNode;
	outputNode(): SubnetOutputSopNode | BaseNodeClassWithDisplayFlag | undefined;
	setOverrideOutputNode(overrideOutputNode: boolean): void;
}
interface SopSubnetChildrenDisplayControllerOptions {
	dependsOnDisplayNode: boolean;
}
declare class SopSubnetChildrenDisplayController {
	private node;
	private options;
	private _outputNodeNeedsUpdate;
	private _outputNode;
	private _graphNode;
	constructor(node: SubnetSopNodeLike<any>, options?: SopSubnetChildrenDisplayControllerOptions);
	dispose(): void;
	displayNodeControllerCallbacks(): DisplayNodeControllerCallbacks;
	outputNode(): SubnetOutputSopNode | undefined;
	initializeNode(): void;
	private _updateOutputNode;
	private _createGraphNode;
}
declare class DecomposeSopParamsConfig extends NodeParamsConfig {
	/** @param decompose the input object */
	decompose: ParamTemplate<ParamType.BUTTON>;
}
declare class DecomposeSopNode extends SubnetSopNodeLike<DecomposeSopParamsConfig> {
	paramsConfig: DecomposeSopParamsConfig;
	static type(): NetworkNodeType;
	initializeNode(): void;
	static PARAM_CALLBACK_decompose(node: DecomposeSopNode): void;
	private _paramCallbackDecompose;
}
declare class DelaySopParamsConfig extends NodeParamsConfig {
	/** @param duration in milliseconds */
	duration: ParamTemplate<ParamType.INTEGER>;
}
declare class DelaySopNode extends TypedSopNode<DelaySopParamsConfig> {
	paramsConfig: DelaySopParamsConfig;
	static type(): string;
	initializeNode(): void;
	cook(inputs_contents: CoreGroup[]): void;
}
declare class EntitySelectionHelper {
	protected node: DeleteSopNode;
	readonly selectedState: Map<CoreEntity, boolean>;
	private _entitiesCount;
	private _selectedEntitiesCount;
	constructor(node: DeleteSopNode);
	init(entities: CoreEntity[]): void;
	select(entity: CoreEntity): void;
	entitiesToKeep(): CoreEntity[];
	entitiesToDelete(): CoreEntity[];
	private _entitiesForState;
}
declare class ByAttributeHelper {
	private node;
	constructor(node: DeleteSopNode);
	evalForEntities(entities: CoreEntity[]): void;
	private _evalForString;
	private _evalForNumeric;
	private _evalForPointsNumericFloat;
	private _evalForPointsNumericVector2;
	private _evalForPointsNumericVector3;
	private _evalForPointsNumericVector4;
}
declare class ByExpressionHelper {
	private node;
	constructor(node: DeleteSopNode);
	evalForEntities(entities: CoreEntity[]): Promise<void>;
	private _evalEntityDependentExpression;
	private _evalExpressionsWithoutEntityDependentExpression;
}
declare class ByBboxHelper {
	private node;
	constructor(node: DeleteSopNode);
	evalForPoints(points: CorePoint[]): void;
	private _setBbox;
}
declare class ByObjectTypeHelper {
	private node;
	constructor(node: DeleteSopNode);
	eval_for_objects(coreObjects: BaseCoreObject<CoreObjectType>[]): void;
}
declare class ByBoundingObjectHelper {
	private node;
	private _matDoubleSideTmpSetter;
	private _raycaster;
	private _intersections;
	constructor(node: DeleteSopNode);
	evalForPoints(points: CorePoint[], core_group2?: CoreGroup): void;
	private _isPositionInObject;
}
declare class DeleteSopParamsConfig extends NodeParamsConfig {
	/** @param defines the class that should be deleted (objects or vertices) */
	class: ParamTemplate<ParamType.INTEGER>;
	/** @param invert the selection created in the parameters below */
	invert: ParamTemplate<ParamType.BOOLEAN>;
	/** @param deletes objects by object type */
	byObjectType: ParamTemplate<ParamType.BOOLEAN>;
	/** @param sets which object types should be deleted */
	objectType: ParamTemplate<ParamType.INTEGER>;
	/** @param deletes objects by an expression */
	byExpression: ParamTemplate<ParamType.BOOLEAN>;
	/** @param sets the expression to select what should be deleted */
	expression: ParamTemplate<ParamType.BOOLEAN>;
	/** @param deletes objects by an attribute */
	byAttrib: ParamTemplate<ParamType.BOOLEAN>;
	/** @param sets the type of the attribute for which items should be deleted */
	attribType: ParamTemplate<ParamType.INTEGER>;
	/** @param name of the attribute used */
	attribName: ParamTemplate<ParamType.STRING>;
	/** @param size of the attribute used */
	attribSize: ParamTemplate<ParamType.INTEGER>;
	/** @param comparison operator */
	attribComparisonOperator: ParamTemplate<ParamType.INTEGER>;
	/** @param value of the attribute to compare with (when using float attribute) */
	attribValue1: ParamTemplate<ParamType.FLOAT>;
	/** @param value of the attribute to compare with (when using vector2 attribute) */
	attribValue2: ParamTemplate<ParamType.VECTOR2>;
	/** @param value of the attribute to compare with (when using vector3 attribute) */
	attribValue3: ParamTemplate<ParamType.VECTOR3>;
	/** @param value of the attribute to compare with (when using vector4 attribute) */
	attribValue4: ParamTemplate<ParamType.VECTOR4>;
	/** @param value of the attribute to compare with (when using string attribute) */
	attribString: ParamTemplate<ParamType.STRING>;
	/** @param deletes objects that are inside a bounding box */
	byBbox: ParamTemplate<ParamType.BOOLEAN>;
	/** @param the bounding box size */
	bboxSize: ParamTemplate<ParamType.VECTOR3>;
	/** @param the bounding box center */
	bboxCenter: ParamTemplate<ParamType.VECTOR3>;
	/** @param deletes objects that are inside an object. This uses the object from the 2nd input */
	byBoundingObject: ParamTemplate<ParamType.BOOLEAN>;
	/** @param keeps points */
	keepPoints: ParamTemplate<ParamType.BOOLEAN>;
}
declare class DeleteSopNode extends TypedSopNode<DeleteSopParamsConfig> {
	paramsConfig: DeleteSopParamsConfig;
	static type(): SopType;
	private _markedForDeletionPerObjectIndex;
	readonly entitySelectionHelper: EntitySelectionHelper;
	readonly byExpressionHelper: ByExpressionHelper;
	readonly byAttributeHelper: ByAttributeHelper;
	readonly byObjectTypeHelper: ByObjectTypeHelper;
	readonly byBboxHelper: ByBboxHelper;
	readonly byBoundingObjectHelper: ByBoundingObjectHelper;
	initializeNode(): void;
	cook(inputCoreGroups: CoreGroup[]): Promise<void>;
	setAttribClass(attribClass: AttribClass): void;
	attribClass(): AttribClass;
	setAttribType(attribType: AttribType): void;
	attribType(): AttribType;
	private _evalForPoints;
	private _evalForPrimitives;
	private _evalForObjects;
	private _pointObject;
}
declare class DeleteByNameSopParamConfig extends NodeParamsConfig {
	/** @param group to assign the material to */
	group: ParamTemplate<ParamType.STRING>;
	/** @param invert */
	invert: ParamTemplate<ParamType.BOOLEAN>;
}
declare class DeleteByNameSopNode extends TypedSopNode<DeleteByNameSopParamConfig> {
	paramsConfig: DeleteByNameSopParamConfig;
	static type(): SopType;
	initializeNode(): void;
	private _operation;
	cook(inputCoreGroups: CoreGroup[]): void;
}
declare const DirectionalLightSopParamsConfig_base: {
	new (...args: any[]): {
		light: ParamTemplate<ParamType.FOLDER>;
		color: ParamTemplate<ParamType.COLOR>;
		intensity: ParamTemplate<ParamType.FLOAT>;
		distance: ParamTemplate<ParamType.FLOAT>;
		showHelper: ParamTemplate<ParamType.BOOLEAN>;
		name: ParamTemplate<ParamType.STRING>;
		shadow: ParamTemplate<ParamType.FOLDER>;
		castShadow: ParamTemplate<ParamType.BOOLEAN>;
		shadowAutoUpdate: ParamTemplate<ParamType.BOOLEAN>;
		shadowUpdateOnNextRender: ParamTemplate<ParamType.BOOLEAN>;
		shadowRes: ParamTemplate<ParamType.VECTOR2>;
		shadowSize: ParamTemplate<ParamType.VECTOR2>;
		shadowBias: ParamTemplate<ParamType.FLOAT>;
		shadowRadius: ParamTemplate<ParamType.FLOAT>;
		raymarching: ParamTemplate<ParamType.FOLDER>;
		raymarchingPenumbra: ParamTemplate<ParamType.FLOAT>;
		raymarchingShadowBiasAngle: ParamTemplate<ParamType.FLOAT>;
		raymarchingShadowBiasDistance: ParamTemplate<ParamType.FLOAT>;
	};
} & typeof NodeParamsConfig;
declare class DirectionalLightSopParamsConfig extends DirectionalLightSopParamsConfig_base {
}
declare class DirectionalLightSopNode extends TypedSopNode<DirectionalLightSopParamsConfig> {
	paramsConfig: DirectionalLightSopParamsConfig;
	static type(): LightType;
	initializeNode(): void;
	private _operation;
	cook(input_contents: CoreGroup[]): void;
}
declare class DrawRangeSopParamsConfig extends NodeParamsConfig {
	/** @param start of the draw range */
	start: ParamTemplate<ParamType.INTEGER>;
	/** @param defines if count is used */
	useCount: ParamTemplate<ParamType.BOOLEAN>;
	/** @param number of items in the draw range */
	count: ParamTemplate<ParamType.INTEGER>;
}
declare class DrawRangeSopNode extends TypedSopNode<DrawRangeSopParamsConfig> {
	paramsConfig: DrawRangeSopParamsConfig;
	static type(): string;
	initializeNode(): void;
	cook(input_contents: CoreGroup[]): void;
}
declare class EmptyObjectSopParamsConfig extends NodeParamsConfig {
	type: ParamTemplate<ParamType.STRING>;
}
declare class EmptyObjectSopNode extends TypedSopNode<EmptyObjectSopParamsConfig> {
	readonly paramsConfig: EmptyObjectSopParamsConfig;
	static type(): string;
	protected initializeNode(): void;
	private _operation;
	cook(input_contents: CoreGroup[]): void;
	setObjectType(objectType: ObjectType): void;
	objectType(): ObjectType | undefined;
}
declare class ExporterGLTFSopParamsConfig extends BaseExporterSopParamsConfig {
}
declare class ExporterGLTFSopNode extends ExporterSopNode<ExporterGLTFSopParamsConfig> {
	paramsConfig: ExporterGLTFSopParamsConfig;
	static type(): SopExporter;
	fileExtension(): string;
	createBlob(): Promise<Blob>;
}
declare class ExporterOBJSopParamsConfig extends BaseExporterSopParamsConfig {
}
declare class ExporterOBJSopNode extends ExporterSopNode<ExporterOBJSopParamsConfig> {
	paramsConfig: ExporterOBJSopParamsConfig;
	static type(): SopExporter;
	fileExtension(): string;
	createBlob(): Promise<Blob>;
}
declare class ExporterPLYSopParamsConfig extends BaseExporterSopParamsConfig {
}
declare class ExporterPLYSopNode extends ExporterSopNode<ExporterPLYSopParamsConfig> {
	paramsConfig: ExporterPLYSopParamsConfig;
	static type(): SopExporter;
	fileExtension(): string;
	createBlob(): Promise<Blob>;
}
declare class ExporterSTLSopParamsConfig extends BaseExporterSopParamsConfig {
}
declare class ExporterSTLSopNode extends ExporterSopNode<ExporterSTLSopParamsConfig> {
	paramsConfig: ExporterSTLSopParamsConfig;
	static type(): SopExporter;
	fileExtension(): string;
	createBlob(): Promise<Blob>;
}
declare class FaceSopParamsConfig extends NodeParamsConfig {
	/** @param makes faces unique */
	makeFacesUnique: ParamTemplate<ParamType.BOOLEAN>;
	/** @param adds a vector3 attribute that represents the center of a face */
	addFaceCenterAttribute: ParamTemplate<ParamType.BOOLEAN>;
	/** @param add an id attribute for each face */
	addFaceId: ParamTemplate<ParamType.BOOLEAN>;
	/** @param allows to transform each face */
	transform: ParamTemplate<ParamType.BOOLEAN>;
	/** @param scales the faces indepedently */
	scale: ParamTemplate<ParamType.FLOAT>;
}
declare class FaceSopNode extends TypedSopNode<FaceSopParamsConfig> {
	paramsConfig: FaceSopParamsConfig;
	static type(): string;
	initializeNode(): void;
	private _face;
	private _points;
	cook(input_contents: CoreGroup[]): void;
	private _makeFacesUnique;
	private _addFaceCenterAttribute;
	private _addFaceId;
	private _transformFaces;
}
declare class FacetSopParamsConfig extends NodeParamsConfig {
	/** @param group to assign the material to */
	group: ParamTemplate<ParamType.STRING>;
	/** @param angle threshold to separate vertices */
	angle: ParamTemplate<ParamType.FLOAT>;
}
declare class FacetSopNode extends TypedSopNode<FacetSopParamsConfig> {
	paramsConfig: FacetSopParamsConfig;
	static type(): SopType;
	initializeNode(): void;
	cook(inputCoreGroups: CoreGroup[]): void;
}
declare class File3DSParamsConfig extends NodeParamsConfig {
	/** @param url to load the geometry from */
	url: ParamTemplate<ParamType.STRING>;
	/** @param texture folder url */
	resourceUrl: ParamTemplate<ParamType.STRING>;
	/** @param sets the matrixAutoUpdate attribute for the objects loaded */
	matrixAutoUpdate: ParamTemplate<ParamType.BOOLEAN>;
	/** @param reload the geometry */
	reload: ParamTemplate<ParamType.BUTTON>;
}
declare class File3DSSopNode extends TypedSopNode<File3DSParamsConfig> {
	paramsConfig: File3DSParamsConfig;
	static type(): SopTypeFile;
	dispose(): void;
	private _operation;
	cook(inputCoreGroups: CoreGroup[]): Promise<void>;
	static PARAM_CALLBACK_reload(node: File3DSSopNode): void;
	private _paramCallbackReload;
}
declare class BaseFileParamsConfigResult extends NodeParamsConfig {
	url: ParamTemplate<ParamType.STRING>;
	matrixAutoUpdate: ParamTemplate<ParamType.BOOLEAN>;
	reload: ParamTemplate<ParamType.BUTTON>;
}
declare class BaseFileSopNodeFactoryResult extends TypedSopNode<BaseFileParamsConfigResult> {
}
declare const FileDRCSopNode_base: typeof BaseFileSopNodeFactoryResult;
declare class FileDRCSopNode extends FileDRCSopNode_base {
}
declare const FileFBXSopNode_base: typeof BaseFileSopNodeFactoryResult;
declare class FileFBXSopNode extends FileFBXSopNode_base {
}
declare const FileGEOJSONSopNode_base: typeof BaseFileSopNodeFactoryResult;
declare class FileGEOJSONSopNode extends FileGEOJSONSopNode_base {
}
declare class FileGLTFParamsConfig extends NodeParamsConfig {
	/** @param url to load the geometry from */
	url: ParamTemplate<ParamType.STRING>;
	/** @param uses draco compression */
	draco: ParamTemplate<ParamType.BOOLEAN>;
	/** @param uses ktx2 compression */
	ktx2: ParamTemplate<ParamType.BOOLEAN>;
	/** @param sets the matrixAutoUpdate attribute for the objects loaded */
	matrixAutoUpdate: ParamTemplate<ParamType.BOOLEAN>;
	/** @param reload the geometry */
	reload: ParamTemplate<ParamType.BUTTON>;
}
declare class FileGLTFSopNode extends TypedSopNode<FileGLTFParamsConfig> {
	paramsConfig: FileGLTFParamsConfig;
	static type(): SopTypeFile;
	dispose(): void;
	private _operation;
	private operation;
	cook(inputCoreGroups: CoreGroup[]): Promise<void>;
	static PARAM_CALLBACK_reload(node: FileGLTFSopNode): void;
	private _paramCallbackReload;
}
declare class FileIFCParamsConfig extends NodeParamsConfig {
	/** @param url to load the geometry from */
	url: ParamTemplate<ParamType.STRING>;
	/** @param sets the matrixAutoUpdate attribute for the objects loaded */
	matrixAutoUpdate: ParamTemplate<ParamType.BOOLEAN>;
	/** @param centers the geometry to the origin */
	coordinateToOrigin: ParamTemplate<ParamType.BOOLEAN>;
	/** @param reload the geometry */
	reload: ParamTemplate<ParamType.BUTTON>;
}
declare class FileIFCSopNode extends TypedSopNode<FileIFCParamsConfig> {
	paramsConfig: FileIFCParamsConfig;
	static type(): SopTypeFile;
	dispose(): void;
	private _operation;
	private operation;
	cook(inputCoreGroups: CoreGroup[]): Promise<void>;
	static PARAM_CALLBACK_reload(node: FileIFCSopNode): void;
	private _paramCallbackReload;
}
declare const FileJSONSopNode_base: typeof BaseFileSopNodeFactoryResult;
declare class FileJSONSopNode extends FileJSONSopNode_base {
}
declare const FileMPDSopNode_base: typeof BaseFileSopNodeFactoryResult;
declare class FileMPDSopNode extends FileMPDSopNode_base {
}
declare class BaseFileMultiParamsConfig extends NodeParamsConfig {
	/** @param url to load the geometry from */
	url: ParamTemplate<ParamType.STRING>;
	/** @param sets the matrixAutoUpdate attribute for the objects loaded */
	matrixAutoUpdate: ParamTemplate<ParamType.BOOLEAN>;
	/** @param reload the geometry */
	reload: ParamTemplate<ParamType.BUTTON>;
}
declare abstract class BaseFileMultiSopNode<O extends BaseGeoLoaderOutput, K extends BaseFileMultiParamsConfig> extends TypedSopNode<K> {
	protected abstract _createLoader(url: string): BaseObject3DLoaderHandler<O>;
	dispose(): void;
	initializeNode(): void;
	private _instancer;
	private _instanceMatrix;
	cook(inputCoreGroups: CoreGroup[]): Promise<void>;
	private static _incrementUrlUsageCount;
	private _loadFromUrlPromises;
	private _loadObject;
	protected _loadWithLoader(loader: BaseObject3DLoaderHandler<O>): Promise<Object3D<Event>[] | undefined>;
	static PARAM_CALLBACK_reload(node: BaseFileMultiSopNode<BaseGeoLoaderOutput, BaseFileMultiParamsConfig>): void;
	private _paramCallbackReload;
}
interface GLTFLoaderLoadOptions extends BaseLoaderLoadOptions {
	draco: boolean;
	ktx2: boolean;
}
declare class GLTFLoaderHandler extends BaseObject3DLoaderHandler<GLTF> {
	private _gltfLoader;
	private _gltfdracoLoader;
	private _ktx2gltfLoader;
	private _ktx2gltfdracoLoader;
	private _dracoLoader;
	private _ktx2Loader;
	reset(): void;
	load(options: GLTFLoaderLoadOptions): Promise<Object3D[] | undefined>;
	protected _getLoader(options: GLTFLoaderLoadOptions): Promise<BaseGeoLoader<GLTF>>;
	private _createGLTFLoader;
	private _setupDRACO;
	protected _setupKTX2(gltfLoader: GLTFLoader, options: BaseLoaderLoadOptions): Promise<void>;
	private _createDRACOLoader;
	protected _onLoadSuccess(gltf: GLTF): Object3D[];
}
declare class FileMultiGLTFParamsConfig extends NodeParamsConfig {
	/** @param url to load the geometry from */
	url: ParamTemplate<ParamType.STRING>;
	/** @param uses draco compression */
	draco: ParamTemplate<ParamType.BOOLEAN>;
	/** @param uses ktx2 compression */
	ktx2: ParamTemplate<ParamType.BOOLEAN>;
	/** @param sets the matrixAutoUpdate attribute for the objects loaded */
	matrixAutoUpdate: ParamTemplate<ParamType.BOOLEAN>;
	/** @param reload the geometry */
	reload: ParamTemplate<ParamType.BUTTON>;
}
declare class FileMultiGLTFSopNode extends BaseFileMultiSopNode<GLTF, FileMultiGLTFParamsConfig> {
	paramsConfig: FileMultiGLTFParamsConfig;
	static type(): SopTypeFileMulti;
	protected _createLoader(url: string): GLTFLoaderHandler;
	protected _loadWithLoader(loader: GLTFLoaderHandler): Promise<Object3D<Event>[] | undefined>;
}
declare class OBJLoaderHandler extends BaseObject3DLoaderHandler<Object3D> {
	protected _getLoader(): Promise<BaseGeoLoader<Object3D>>;
}
declare class FileMultiOBJParamsConfig extends NodeParamsConfig {
	/** @param url to load the geometry from */
	url: ParamTemplate<ParamType.STRING>;
	/** @param sets the matrixAutoUpdate attribute for the objects loaded */
	matrixAutoUpdate: ParamTemplate<ParamType.BOOLEAN>;
	/** @param reload the geometry */
	reload: ParamTemplate<ParamType.BUTTON>;
}
declare class FileMultiOBJSopNode extends BaseFileMultiSopNode<Object3D, FileMultiOBJParamsConfig> {
	paramsConfig: FileMultiOBJParamsConfig;
	static type(): SopTypeFileMulti;
	protected _createLoader(url: string): OBJLoaderHandler;
}
declare const FileOBJSopNode_base: typeof BaseFileSopNodeFactoryResult;
declare class FileOBJSopNode extends FileOBJSopNode_base {
}
declare const FilePDBSopNode_base: typeof BaseFileSopNodeFactoryResult;
declare class FilePDBSopNode extends FilePDBSopNode_base {
}
declare const FilePLYSopNode_base: typeof BaseFileSopNodeFactoryResult;
declare class FilePLYSopNode extends FilePLYSopNode_base {
}
declare const FileSTLSopNode_base: typeof BaseFileSopNodeFactoryResult;
declare class FileSTLSopNode extends FileSTLSopNode_base {
}
declare class FileSVGSopParamsConfig extends NodeParamsConfig {
	/** @param url to load the geometry from */
	url: ParamTemplate<ParamType.STRING>;
	/** @param reload the geometry */
	reload: ParamTemplate<ParamType.BUTTON>;
	/** @param toggle on to draw the fillShapes */
	drawFillShapes: ParamTemplate<ParamType.BOOLEAN>;
	/** @param toggle on to draw the fillShapes as wireframe */
	fillShapesWireframe: ParamTemplate<ParamType.BOOLEAN>;
	/** @param toggle on to draw the strokes */
	drawStrokes: ParamTemplate<ParamType.BOOLEAN>;
	/** @param toggle on to draw the strokes as wireframe */
	strokesWireframe: ParamTemplate<ParamType.BOOLEAN>;
	/** @param style override */
	tStyleOverride: ParamTemplate<ParamType.BOOLEAN>;
	/** @param stroke width */
	strokeWidth: ParamTemplate<ParamType.FLOAT>;
	/** @param advanced */
	tadvanced: ParamTemplate<ParamType.BOOLEAN>;
	/** @param is counter clock wise: defines the vertex order when parsing the font */
	isCCW: ParamTemplate<ParamType.BOOLEAN>;
}
declare class FileSVGSopNode extends TypedSopNode<FileSVGSopParamsConfig> {
	paramsConfig: FileSVGSopParamsConfig;
	static type(): SopTypeFile;
	dispose(): void;
	private _operation;
	cook(inputCoreGroups: CoreGroup[]): Promise<void>;
	static PARAM_CALLBACK_reload(node: FileSVGSopNode): void;
	private param_callback_reload;
}
declare const FileUSDZSopNode_base: typeof BaseFileSopNodeFactoryResult;
declare class FileUSDZSopNode extends FileUSDZSopNode_base {
}
declare const FileVOXSopNode_base: typeof BaseFileSopNodeFactoryResult;
declare class FileVOXSopNode extends FileVOXSopNode_base {
}
declare class FuseSopParamsConfig extends NodeParamsConfig {
	/** @param group to assign the material to */
	group: ParamTemplate<ParamType.STRING>;
	/** @param distance threshold */
	dist: ParamTemplate<ParamType.FLOAT>;
	/** @param recompute normals */
	computeNormals: ParamTemplate<ParamType.BOOLEAN>;
}
declare class FuseSopNode extends TypedSopNode<FuseSopParamsConfig> {
	paramsConfig: FuseSopParamsConfig;
	static type(): SopType;
	initializeNode(): void;
	cook(inputCoreGroups: CoreGroup[]): void;
	private _filterObject;
	private _filterMesh;
	private _filterLineSegments;
	private _filterPoints;
	private _fuseGeometry;
}
declare class GroundProjectedSkyboxSopParamsConfig extends NodeParamsConfig {
	/** @param envMap */
	envMap: ParamTemplate<ParamType.NODE_PATH>;
	/** @param scale */
	scale: ParamTemplate<ParamType.FLOAT>;
	/** @param radius */
	radius: ParamTemplate<ParamType.FLOAT>;
	/** @param height */
	height: ParamTemplate<ParamType.FLOAT>;
}
declare class GroundProjectedSkyboxSopNode extends TypedSopNode<GroundProjectedSkyboxSopParamsConfig> {
	readonly paramsConfig: GroundProjectedSkyboxSopParamsConfig;
	static type(): SopType;
	protected initializeNode(): void;
	cook(inputCoreGroups: CoreGroup[]): Promise<void>;
}
declare class HexagonsSopParamsConfig extends NodeParamsConfig {
	/** @param plane size */
	size: ParamTemplate<ParamType.VECTOR2>;
	/** @param hexagons size */
	hexagonRadius: ParamTemplate<ParamType.FLOAT>;
	/** @param axis perpendicular to the plane */
	direction: ParamTemplate<ParamType.VECTOR3>;
	/** @param do not create polygons, only points */
	pointsOnly: ParamTemplate<ParamType.BOOLEAN>;
}
declare class HexagonsSopNode extends TypedSopNode<HexagonsSopParamsConfig> {
	paramsConfig: HexagonsSopParamsConfig;
	static type(): string;
	initializeNode(): void;
	private _operation;
	cook(input_contents: CoreGroup[]): void;
}
declare enum HierarchyMode {
	ADD_PARENT = "add parent",
	REMOVE_PARENT = "remove parent",
	ADD_CHILD = "add child"
}
declare enum AddChildMode {
	ONE_CHILD_PER_PARENT = "one child per parent",
	ALL_CHILDREN_UNDER_FIRST_PARENT = "all children under first parent",
	ALL_CHILDREN_UNDER_ALL_PARENTS = "all children under all parents"
}
declare class HierarchySopParamsConfig extends NodeParamsConfig {
	/** @param defines if parent objects will be added or removed */
	mode: ParamTemplate<ParamType.INTEGER>;
	/** @param defines how many parent objects will be added or removed */
	levels: ParamTemplate<ParamType.INTEGER>;
	/** @param when the mode is set to add_child, the mask defines which parent the children are added to. If the mask is an empty string, the children will be added to the objects at the top of the hierarchy. Also, the children are taken from the second input. */
	objectMask: ParamTemplate<ParamType.STRING>;
	/** @param defines how the children are added to the parents */
	addChildMode: ParamTemplate<ParamType.INTEGER>;
}
declare class HierarchySopNode extends TypedSopNode<HierarchySopParamsConfig> {
	paramsConfig: HierarchySopParamsConfig;
	static type(): SopType;
	initializeNode(): void;
	private _operation;
	cook(inputCoreGroups: CoreGroup[]): void;
	setMode(mode: HierarchyMode): void;
	setAddChildMode(mode: AddChildMode): void;
}
declare class HeightMapSopParamsConfig extends NodeParamsConfig {
	/** @param texture node to load the heightmap from */
	texture: ParamTemplate<ParamType.NODE_PATH>;
	/** @param values multiplier */
	mult: ParamTemplate<ParamType.FLOAT>;
}
declare class HeightMapSopNode extends TypedSopNode<HeightMapSopParamsConfig> {
	paramsConfig: HeightMapSopParamsConfig;
	static type(): string;
	initializeNode(): void;
	cook(inputCoreGroups: CoreGroup[]): Promise<void>;
	private _setPositionFromDataTexture;
	private _dataFromTexture;
	private _dataFromDefaultTexture;
	private _dataFromDataTexture;
}
declare const HemisphereLightSopParamsConfig_base: {
	new (...args: any[]): {
		skyColor: ParamTemplate<ParamType.COLOR>;
		groundColor: ParamTemplate<ParamType.COLOR>;
		intensity: ParamTemplate<ParamType.FLOAT>;
		position: ParamTemplate<ParamType.VECTOR3>;
		name: ParamTemplate<ParamType.STRING>;
	};
} & typeof NodeParamsConfig;
declare class HemisphereLightSopParamsConfig extends HemisphereLightSopParamsConfig_base {
}
declare class HemisphereLightSopNode extends TypedSopNode<HemisphereLightSopParamsConfig> {
	paramsConfig: HemisphereLightSopParamsConfig;
	static type(): string;
	initializeNode(): void;
	private _operation;
	cook(inputCoreGroups: CoreGroup[]): void;
}
declare class IcosahedronSopParamsConfig extends NodeParamsConfig {
	/** @param radius of the icosahedron */
	radius: ParamTemplate<ParamType.FLOAT>;
	/** @param resolution of the icosahedron */
	detail: ParamTemplate<ParamType.INTEGER>;
	/** @param do not create polygons, only points. */
	pointsOnly: ParamTemplate<ParamType.BOOLEAN>;
	/** @param center of the icosahedron */
	center: ParamTemplate<ParamType.VECTOR3>;
}
declare class IcosahedronSopNode extends TypedSopNode<IcosahedronSopParamsConfig> {
	paramsConfig: IcosahedronSopParamsConfig;
	static type(): SopType;
	private _operation;
	cook(): void;
}
declare class IFCFilterCategoriesSopParamsConfig extends NodeParamsConfig {
	/** @param get categories in the file */
	getCategories: ParamTemplate<ParamType.BUTTON>;
}
declare class IFCFilterCategoriesSopNode extends TypedSopNode<IFCFilterCategoriesSopParamsConfig> {
	paramsConfig: IFCFilterCategoriesSopParamsConfig;
	static type(): SopType;
	initializeNode(): void;
	cook(inputCoreGroups: CoreGroup[]): Promise<void>;
	static PARAM_CALLBACK_getCategories(node: IFCFilterCategoriesSopNode): void;
	private _paramCallbackGetCategories;
}
declare class InstanceSopParamsConfig extends NodeParamsConfig {
	/** @param attributes to copy to the instance */
	attributesToCopy: ParamTemplate<ParamType.STRING>;
	/** @param toggles on to apply a material. This is useful in most cases, but there may be situations where the material would be apply later, such as when you are feeding this node to a particles system */
	applyMaterial: ParamTemplate<ParamType.BOOLEAN>;
	/** @param material to apply */
	material: ParamTemplate<ParamType.NODE_PATH>;
}
declare class InstanceSopNode extends TypedSopNode<InstanceSopParamsConfig> {
	paramsConfig: InstanceSopParamsConfig;
	static type(): SopType;
	initializeNode(): void;
	private _operation;
	cook(inputCoreGroups: CoreGroup[]): Promise<void>;
}
declare class InstanceBuilderPersistedConfig extends BasePointBuilderPersistedConfig {
	protected node: InstanceBuilderSopNode;
	constructor(node: InstanceBuilderSopNode);
}
declare class JsAssemblerBasePointBuilder extends BaseJsShaderAssembler {
	makeFunctionNodeDirtyOnChange(): boolean;
	templateShader(): {
		main: string;
	};
	protected _closeClassDefinition(): string;
	protected _evaluatorName(): string;
// @ts-ignore
	spareParamsOptions(options: SpareParamOptions): ParamOptions;
	defaultObject3DVariable(): string;
	defaultObject3DMaterialVariable(): string;
	defaultPointIndexVariable(): string;
	functionData(): PointBuilderFunctionData | undefined;
	updateFunction(): void;
	setNodeLinesAttribute(attributeNode: AttributeJsNode, linesController: JsLinesCollectionController): void;
}
declare class JsAssemblerPointBuilder extends JsAssemblerBasePointBuilder {
	protected _evaluatorName(): string;
	add_output_inputs(output_child: OutputJsNode): void;
	add_globals_outputs(globals_node: GlobalsJsNode): void;
	create_shader_configs(): JsShaderConfig[];
	create_variable_configs(): VariableConfig[];
	setNodeLinesOutput(outputNode: OutputJsNode, linesController: JsLinesCollectionController): void;
	setNodeLinesGlobals(globalsNode: GlobalsJsNode, linesController: JsLinesCollectionController): void;
}
declare class JsAssemblerInstanceBuilder extends JsAssemblerBasePointBuilder {
	protected _evaluatorName(): string;
	add_output_inputs(output_child: OutputJsNode): void;
	add_globals_outputs(globals_node: GlobalsJsNode): void;
	create_shader_configs(): JsShaderConfig[];
	create_variable_configs(): VariableConfig[];
	setNodeLinesOutput(outputNode: OutputJsNode, linesController: JsLinesCollectionController): void;
	setNodeLinesGlobals(globalsNode: GlobalsJsNode, linesController: JsLinesCollectionController): void;
}
interface PointContainer {
	position: Vector3;
	normal: Vector3;
	ptnum: number;
	objnum: number;
	normalsUpdated: boolean;
}
interface InstanceContainer {
	instancePosition: Vector3;
	instanceQuaternion: Quaternion;
	instanceScale: Vector3;
	ptnum: number;
	objnum: number;
}
type PointBuilderEvaluator = () => void;
type AttributeItem = boolean | number | string | Color | Vector2 | Vector3 | Vector4;
type AttributesDict = Map<string, AttributeItem>;
declare class BasePointBuilderSopParamsConfig extends NodeParamsConfig {
	/** @param group to assign the material to */
	group: ParamTemplate<ParamType.STRING>;
}
declare abstract class BasePointBuilderSopNode<P extends BasePointBuilderSopParamsConfig> extends TypedSopNode<P> {
	assemblerController(): JsAssemblerController<JsAssemblerPointBuilder | JsAssemblerInstanceBuilder> | undefined;
	usedAssembler(): Readonly<AssemblerName.JS_POINT_BUILDER | AssemblerName.JS_INSTANCE_BUILDER>;
	protected _assemblerController: JsAssemblerController<JsAssemblerPointBuilder | JsAssemblerInstanceBuilder> | undefined;
	private _createAssemblerController;
	protected _childrenControllerContext: NodeContext;
	createNode<S extends keyof JsNodeChildrenMap>(node_class: S, options?: NodeCreateOptions): JsNodeChildrenMap[S];
	createNode<K extends valueof<JsNodeChildrenMap>>(node_class: Constructor<K>, options?: NodeCreateOptions): K;
	children(): BaseJsNodeType[];
	nodesByType<K extends keyof JsNodeChildrenMap>(type: K): JsNodeChildrenMap[K][];
	childrenAllowed(): boolean;
	sceneReadonly(): boolean;
	initializeNode(): void;
	cook(inputCoreGroups: CoreGroup[]): Promise<void>;
	protected abstract _processObject<T extends CoreObjectType>(object: ObjectContent<T>, objnum: number, evaluator: PointBuilderEvaluator): void;
	protected _resetRequiredAttributes(): void;
	protected _checkRequiredReadAttributes<T extends CoreObjectType>(object: ObjectContent<T>): {
		attribNames: string[];
		attributeByName: Map<string, BufferAttribute>;
		attribTypeByName: Map<string, JsConnectionPointType>;
	} | undefined;
	protected _checkRequiredWriteAttributes<T extends CoreObjectType>(object: ObjectContent<T>): {
		attribNames: string[];
		attributeByName: Map<string, BufferAttribute>;
		attribTypeByName: Map<string, JsConnectionPointType>;
	} | undefined;
	protected _readRequiredAttributes(ptnum: number, attribNames: string[], attributeByName: Map<string, BufferAttribute>, attribTypeByName: Map<string, JsConnectionPointType>): void;
	protected _writeRequiredAttributes(ptnum: number, attribNames: string[], attributeByName: Map<string, BufferAttribute>): void;
	compileIfRequired(): void;
	protected abstract _pointContainer: PointContainer | InstanceContainer;
	private _paramConfigs;
	private _functionData;
	private _functionCreationArgs;
	private _functionEvalArgs;
	private _function;
	private _attributesDict;
	functionData(): PointBuilderFunctionData | undefined;
	compile(): void;
	updateFromFunctionData(functionData: PointBuilderFunctionData): void;
	functionEvalArgsWithParamConfigs(): (number | boolean | Function | RegisterableVariable | InstanceContainer | PointContainer | AttributesDict)[];
}
declare class InstanceBuilderSopNode extends BasePointBuilderSopNode<BasePointBuilderSopParamsConfig> {
	paramsConfig: BasePointBuilderSopParamsConfig;
	static type(): SopType;
	readonly persisted_config: InstanceBuilderPersistedConfig;
	usedAssembler(): Readonly<AssemblerName.JS_INSTANCE_BUILDER>;
	protected _pointContainer: InstanceContainer;
	protected _processObject<T extends CoreObjectType>(object: ObjectContent<T>, objnum: number, evaluator: PointBuilderEvaluator): void;
}
declare enum InstanceUpdateMode {
	GEO = "geo",
	POINTS = "points"
}
declare class InstanceUpdateSopParamsConfig extends NodeParamsConfig {
	/** @param defines what this node updates, either the instanced geometry or the instance points. */
	mode: ParamTemplate<ParamType.INTEGER>;
	/** @param which attributes will be updated on the instanced geometry */
	geoAttributes: ParamTemplate<ParamType.STRING>;
	/** @param which attributes will be updated ont the instance points */
	pointAttributes: ParamTemplate<ParamType.STRING>;
}
declare class InstanceUpdateSopNode extends TypedSopNode<InstanceUpdateSopParamsConfig> {
	paramsConfig: InstanceUpdateSopParamsConfig;
	static type(): SopType;
	initializeNode(): void;
	setMode(mode: InstanceUpdateMode): void;
	private _operation;
	cook(input_contents: CoreGroup[]): void;
}
declare class InstancesCountSopParamsConfig extends NodeParamsConfig {
	/** @param sets if max is used */
	useMax: ParamTemplate<ParamType.BOOLEAN>;
	/** @param max number of instances to display */
	max: ParamTemplate<ParamType.INTEGER>;
}
declare class InstancesCountSopNode extends TypedSopNode<InstancesCountSopParamsConfig> {
	paramsConfig: InstancesCountSopParamsConfig;
	static type(): string;
	initializeNode(): void;
	cook(input_contents: CoreGroup[]): void;
}
declare class JitterSopParamsConfig extends NodeParamsConfig {
	/** @param amount of jitter */
	amount: ParamTemplate<ParamType.FLOAT>;
	/** @param mult of each axis */
	mult: ParamTemplate<ParamType.VECTOR3>;
	/** @param seed used to set the direction each point is moved to */
	seed: ParamTemplate<ParamType.INTEGER>;
}
declare class JitterSopNode extends TypedSopNode<JitterSopParamsConfig> {
	paramsConfig: JitterSopParamsConfig;
	static type(): SopType;
	initializeNode(): void;
	private _operation;
	cook(input_contents: CoreGroup[]): void;
}
declare class LatticeSopParamConfig extends NodeParamsConfig {
	group: ParamTemplate<ParamType.STRING>;
	p0: ParamTemplate<ParamType.VECTOR3>;
	p1: ParamTemplate<ParamType.VECTOR3>;
	p2: ParamTemplate<ParamType.VECTOR3>;
	p3: ParamTemplate<ParamType.VECTOR3>;
	p4: ParamTemplate<ParamType.VECTOR3>;
	p5: ParamTemplate<ParamType.VECTOR3>;
	p6: ParamTemplate<ParamType.VECTOR3>;
	p7: ParamTemplate<ParamType.VECTOR3>;
	offset: ParamTemplate<ParamType.VECTOR3>;
	moveObjectPosition: ParamTemplate<ParamType.BOOLEAN>;
}
declare class LatticeSopNode extends TypedSopNode<LatticeSopParamConfig> {
	paramsConfig: LatticeSopParamConfig;
	static type(): SopType;
	initializeNode(): void;
	private _operation;
	cook(inputCoreGroups: CoreGroup[]): void;
}
declare enum LayerUpdateMode {
	SET = "set",
	ADD = "add",
	REMOVE = "remove"
}
type AvailableLayerIndex = 0 | 1 | 2 | 3;
declare class LayerSopParamsConfig extends NodeParamsConfig {
	/** @param group to assign the material to */
	group: ParamTemplate<ParamType.STRING>;
	layersCount: ParamTemplate<ParamType.INTEGER>;
	/** @param updateMode */
	updateMode0: ParamTemplate<ParamType.INTEGER>;
	/** @param layer */
	layer0: ParamTemplate<ParamType.INTEGER>;
	/** @param updateMode */
	updateMode1: ParamTemplate<ParamType.INTEGER>;
	/** @param layer */
	layer1: ParamTemplate<ParamType.INTEGER>;
	/** @param updateMode */
	updateMode2: ParamTemplate<ParamType.INTEGER>;
	/** @param layer */
	layer2: ParamTemplate<ParamType.INTEGER>;
	/** @param updateMode */
	updateMode3: ParamTemplate<ParamType.INTEGER>;
	/** @param layer */
	layer3: ParamTemplate<ParamType.INTEGER>;
}
declare class LayerSopNode extends TypedSopNode<LayerSopParamsConfig> {
	paramsConfig: LayerSopParamsConfig;
	static type(): SopType;
	initializeNode(): void;
	cook(inputCoreGroups: CoreGroup[]): void;
	private _updateLayers;
	private _updateLayer;
	setMode(index: AvailableLayerIndex, mode: LayerUpdateMode): void;
	setLayer(index: AvailableLayerIndex, layer: number): void;
}
declare class LightMixerParamsConfig extends NodeParamsConfig {
	/** @param size of the box */
	setup: ParamTemplate<ParamType.BUTTON>;
}
declare class LightMixerSopNode extends TypedSopNode<LightMixerParamsConfig> {
	readonly paramsConfig: LightMixerParamsConfig;
	static type(): string;
	protected initializeNode(): void;
	private _lightsByName;
	cook(inputCoreGroups: CoreGroup[]): void;
	private _findLights;
	static PARAM_CALLBACK_setup(node: LightMixerSopNode): void;
	private _paramCallbackSetup;
}
declare const LightProbeSopParamsConfig_base: {
	new (...args: any[]): {
		cubeMap: ParamTemplate<ParamType.NODE_PATH>;
		intensity: ParamTemplate<ParamType.FLOAT>;
		name: ParamTemplate<ParamType.STRING>;
	};
} & typeof NodeParamsConfig;
declare class LightProbeSopParamsConfig extends LightProbeSopParamsConfig_base {
}
declare class LightProbeSopNode extends TypedSopNode<LightProbeSopParamsConfig> {
	paramsConfig: LightProbeSopParamsConfig;
	static type(): string;
	initializeNode(): void;
	private _operation;
	cook(inputCoreGroups: CoreGroup[]): Promise<void>;
}
declare class LineSopParamsConfig extends NodeParamsConfig {
	/** @param length of the line */
	length: ParamTemplate<ParamType.FLOAT>;
	/** @param number of points */
	pointsCount: ParamTemplate<ParamType.INTEGER>;
	/** @param start position of the line */
	origin: ParamTemplate<ParamType.VECTOR3>;
	/** @param direction of the line */
	direction: ParamTemplate<ParamType.VECTOR3>;
}
declare class LineSopNode extends TypedSopNode<LineSopParamsConfig> {
	paramsConfig: LineSopParamsConfig;
	static type(): string;
	initializeNode(): void;
	private _lastPt;
	private _current;
	cook(): void;
}
declare class LODSopParamsConfig extends NodeParamsConfig {
	/** @param distance when switching between high res and mid res (first input and second input) */
	distance0: ParamTemplate<ParamType.FLOAT>;
	/** @param distance when switching between mid res and low res (second input and third input) */
	distance1: ParamTemplate<ParamType.FLOAT>;
	/** @param Threshold used to avoid flickering at LOD boundaries, as a fraction of distance */
	hysteresis: ParamTemplate<ParamType.FLOAT>;
	/** @param sets if the switch is done automatically */
	autoUpdate: ParamTemplate<ParamType.BOOLEAN>;
	/** @param updates which object is displayed manually */
	update: ParamTemplate<ParamType.BUTTON>;
	/** @param sets which camera will be used when the switch is to be done manually */
	camera: ParamTemplate<ParamType.NODE_PATH>;
}
declare class LodSopNode extends TypedSopNode<LODSopParamsConfig> {
	paramsConfig: LODSopParamsConfig;
	static type(): SopType;
	private _lod;
	initializeNode(): void;
	private _createLOD;
	cook(inputCoreGroups: CoreGroup[]): void;
	_addLevel(coreGroup: CoreGroup | undefined, level: number): void;
	private _clearLOD;
	static PARAM_CALLBACK_update(node: LodSopNode): void;
	private _updateLOD;
}
declare class LookAtSopParamConfig extends NodeParamsConfig {
	/** @param target */
	target: ParamTemplate<ParamType.VECTOR3>;
	/** @param up vector */
	up: ParamTemplate<ParamType.VECTOR3>;
	/** @param lerp */
	lerp: ParamTemplate<ParamType.FLOAT>;
	/** @param invertDirection */
	invertDirection: ParamTemplate<ParamType.BOOLEAN>;
}
declare class LookAtSopNode extends TypedSopNode<LookAtSopParamConfig> {
	paramsConfig: LookAtSopParamConfig;
	static type(): SopType;
	initializeNode(): void;
	private _operation;
	cook(inputCoreGroups: CoreGroup[]): void;
}
declare class MapboxCameraSopParamsConfig extends NodeParamsConfig {
	style: ParamTemplate<ParamType.STRING>;
	/** @param longitude */
	longitude: ParamTemplate<ParamType.FLOAT>;
	/** @param latitude */
	latitude: ParamTemplate<ParamType.FLOAT>;
	pitch: ParamTemplate<ParamType.FLOAT>;
	bearing: ParamTemplate<ParamType.FLOAT>;
	zoom: ParamTemplate<ParamType.FLOAT>;
	minZoom: ParamTemplate<ParamType.FLOAT>;
	maxZoom: ParamTemplate<ParamType.FLOAT>;
	allowDragRotate: ParamTemplate<ParamType.BOOLEAN>;
	addZoomControl: ParamTemplate<ParamType.BOOLEAN>;
	tlayerBuildings: ParamTemplate<ParamType.BOOLEAN>;
	tlayer3D: ParamTemplate<ParamType.BOOLEAN>;
	tlayerSky: ParamTemplate<ParamType.BOOLEAN>;
	/** @param camera name */
	name: ParamTemplate<ParamType.STRING>;
	updateFromMap: ParamTemplate<ParamType.BUTTON>;
}
declare class MapboxCameraSopNode extends TypedSopNode<MapboxCameraSopParamsConfig> {
	readonly paramsConfig: MapboxCameraSopParamsConfig;
	static type(): CameraNodeType;
	static onRegister: OnNodeRegisterCallback;
	protected initializeNode(): void;
	private _operation;
	cook(inputCoreGroups: CoreGroup[]): Promise<void>;
	static PARAM_CALLBACK_updateFromMap(node: MapboxCameraSopNode): void;
	private _paramCallbackUpdateFromMap;
}
declare class MapboxLayerSopParamsConfig extends NodeParamsConfig {
	/** @param names of layers to create */
	updateLayers: ParamTemplate<ParamType.BUTTON>;
}
declare class MapboxLayerSopNode extends TypedSopNode<MapboxLayerSopParamsConfig> {
	paramsConfig: MapboxLayerSopParamsConfig;
	static type(): string;
	cook(): Promise<void>;
	private _featuresByName;
	private _groupFeaturesByName;
	private _feature_name;
	private _id_from_feature;
	static PARAM_CALLBACK_reload(node: MapboxLayerSopNode): void;
	private _paramCallbackReload;
}
declare class MapboxPlaneSopParamsConfig extends NodeParamsConfig {
	/** @param camera lng lat */
	/** @param type of plane (grid or hexagons) */
	type: ParamTemplate<ParamType.INTEGER>;
	/** @param plane resolution */
	resolution: ParamTemplate<ParamType.INTEGER>;
	/** @param multiplies the size of the plane. This can be useful to scale down the plane. While it would cover a smaller part of the view, it would be faster to create  */
	sizeMult: ParamTemplate<ParamType.FLOAT>;
	/** @param toggle on to make sure the plane will cover the full view */
	fullView: ParamTemplate<ParamType.BOOLEAN>;
	/** @param do not create polygons, only points */
	asPoints: ParamTemplate<ParamType.BOOLEAN>;
}
declare class MapboxPlaneSopNode extends TypedSopNode<MapboxPlaneSopParamsConfig> {
	paramsConfig: MapboxPlaneSopParamsConfig;
	static type(): string;
	private _hexagonsController;
	private transformer;
	cook(): Promise<void>;
	_buildPlane(map: mapboxgl.Map): BufferGeometry<NormalBufferAttributes> | undefined;
	private _mirrorLngLat;
	private _asHexagons;
}
declare class MapboxTransformSopParamsConfig extends NodeParamsConfig {
	/** @param sets if this node should transform objects or geometries */
	applyOn: ParamTemplate<ParamType.INTEGER>;
	/** @param camera longitude */
	longitude: ParamTemplate<ParamType.FLOAT>;
	/** @param camera latitude */
	latitude: ParamTemplate<ParamType.FLOAT>;
}
declare class MapboxTransformSopNode extends TypedSopNode<MapboxTransformSopParamsConfig> {
	paramsConfig: MapboxTransformSopParamsConfig;
	static type(): SopType;
	initializeNode(): void;
	private _transformer;
	cook(inputContents: CoreGroup[]): void;
	private _applyTransform;
	private _updateGeometries;
	private _updateObjects;
}
declare class MaterialSopParamsConfig extends NodeParamsConfig {
	/** @param group to assign the material to */
	group: ParamTemplate<ParamType.STRING>;
	/** @param toggle on to assign the new material */
	assignMat: ParamTemplate<ParamType.BOOLEAN>;
	/** @param the material node */
	material: ParamTemplate<ParamType.NODE_PATH>;
	/** @param Cloning the material would prevent the material node to have any effect on the processed geometries. But it would allow to have multiple materials, if this was used with a Copy SOP for instance */
	cloneMat: ParamTemplate<ParamType.BOOLEAN>;
	/** @param while cloning the material, you may only want to change basic properties (such as depthWrite or transparent), but you would want to still use the same custom uniforms created by GL/param nodes */
	shareCustomUniforms: ParamTemplate<ParamType.BOOLEAN>;
	/** @param swap one texture with another */
	swapCurrentTex: ParamTemplate<ParamType.BOOLEAN>;
	/** @param texture to swap */
	texSrc0: ParamTemplate<ParamType.STRING>;
	/** @param texture to swap */
	texDest0: ParamTemplate<ParamType.STRING>;
}
declare class MaterialSopNode extends TypedSopNode<MaterialSopParamsConfig> {
	paramsConfig: MaterialSopParamsConfig;
	static type(): SopType;
	protected initializeNode(): void;
	private _operation;
	cook(inputCoreGroups: CoreGroup[]): Promise<void>;
}
declare class MaterialPropertiesSopParamsConfig extends NodeParamsConfig {
	/** @param group to assign the material to */
	group: ParamTemplate<ParamType.STRING>;
	/** @param toggle on to allow updating the side properties of the materials */
	tside: ParamTemplate<ParamType.BOOLEAN>;
	/** @param defines if the material is double sided or not */
	doubleSided: ParamTemplate<ParamType.BOOLEAN>;
	/** @param if the material is not double sided, it can be front sided, or back sided */
	front: ParamTemplate<ParamType.BOOLEAN>;
	/** @param override the default shadowSide behavior */
	overrideShadowSide: ParamTemplate<ParamType.BOOLEAN>;
	/** @param defines which side(s) are used when rendering shadows */
	shadowDoubleSided: ParamTemplate<ParamType.BOOLEAN>;
	/** @param if the material is not double sided, it can be front sided, or back sided, when computing shadows */
	shadowFront: ParamTemplate<ParamType.BOOLEAN>;
	/** @param toggle on to allow updating the wireframe properties of the materials */
	twireframe: ParamTemplate<ParamType.BOOLEAN>;
	/** @param defines if the material is double sided or not */
	wireframe: ParamTemplate<ParamType.BOOLEAN>;
}
declare class MaterialPropertiesSopNode extends TypedSopNode<MaterialPropertiesSopParamsConfig> {
	paramsConfig: MaterialPropertiesSopParamsConfig;
	static type(): SopType;
	initializeNode(): void;
	private _operation;
	cook(inputCoreGroups: CoreGroup[]): void;
}
declare class MergeSopParamsConfig extends NodeParamsConfig {
	/** @param When off, input objects remain separate. When on, they are merged together by type (mesh, points and lines). In order to merge them correctly, you'll have to make sure they have the same attributes */
	compact: ParamTemplate<ParamType.BOOLEAN>;
	/** @param When off, objects with same type (mesh, points, lines) will be merged together, regardless of their material. When on, only objects with same type and same material will be merged */
	preserveMaterials: ParamTemplate<ParamType.BOOLEAN>;
	/** @param number of inputs that this node can merge geometries from */
	inputsCount: ParamTemplate<ParamType.INTEGER>;
}
declare class MergeSopNode extends TypedSopNode<MergeSopParamsConfig> {
	paramsConfig: MergeSopParamsConfig;
	static type(): SopType;
	setCompactMode(compact: boolean): void;
	initializeNode(): void;
	private _operation;
	cook(inputCoreGroups: CoreGroup[]): void;
	private _callbackUpdateInputsCount;
	static PARAM_CALLBACK_setInputsCount(node: MergeSopNode): void;
}
declare class MetaballSopParamsConfig extends NodeParamsConfig {
	/** @param resolution */
	resolution: ParamTemplate<ParamType.FLOAT>;
	/** @param isolation */
	isolation: ParamTemplate<ParamType.FLOAT>;
	/** @param useMetaStrengthAttrib */
	useMetaStrengthAttrib: ParamTemplate<ParamType.BOOLEAN>;
	/** @param metaStrength */
	metaStrength: ParamTemplate<ParamType.FLOAT>;
	/** @param useMetaSubtractAttrib */
	useMetaSubtractAttrib: ParamTemplate<ParamType.BOOLEAN>;
	/** @param metaStrength */
	metaSubtract: ParamTemplate<ParamType.FLOAT>;
	/** @param enableUVs */
	enableUVs: ParamTemplate<ParamType.BOOLEAN>;
	/** @param enableColors */
	enableColors: ParamTemplate<ParamType.BOOLEAN>;
}
declare class MetaballSopNode extends TypedSopNode<MetaballSopParamsConfig> {
	paramsConfig: MetaballSopParamsConfig;
	static type(): string;
	initializeNode(): void;
	private _operation;
	cook(input_contents: CoreGroup[]): void;
}
declare class MirrorSopParamConfig extends NodeParamsConfig {
	/** @param group to assign the material to */
	group: ParamTemplate<ParamType.STRING>;
	/** @param axis */
	axis: ParamTemplate<ParamType.VECTOR3>;
	/** @param center */
	center: ParamTemplate<ParamType.VECTOR3>;
	/** @param preserve input */
	preserveInput: ParamTemplate<ParamType.BOOLEAN>;
}
declare class MirrorSopNode extends TypedSopNode<MirrorSopParamConfig> {
	paramsConfig: MirrorSopParamConfig;
	static type(): SopType;
	initializeNode(): void;
	private _operation;
	cook(inputCoreGroups: CoreGroup[]): void;
}
declare enum NoiseOperation {
	ADD = "add",
	SET = "set",
	MULT = "mult",
	SUBTRACT = "subtract",
	DIVIDE = "divide"
}
declare class NoiseSopParamsConfig extends NodeParamsConfig {
	/** @param noise amplitude */
	amplitude: ParamTemplate<ParamType.FLOAT>;
	/** @param toggle on to multiply the amplitude by a vertex attribute */
	tamplitudeAttrib: ParamTemplate<ParamType.BOOLEAN>;
	/** @param which vertex attribute to use */
	amplitudeAttrib: ParamTemplate<ParamType.STRING>;
	/** @param noise frequency */
	freq: ParamTemplate<ParamType.VECTOR3>;
	/** @param noise offset */
	offset: ParamTemplate<ParamType.VECTOR3>;
	/** @param noise octaves */
	octaves: ParamTemplate<ParamType.INTEGER>;
	/** @param amplitude attenuation for higher octaves */
	ampAttenuation: ParamTemplate<ParamType.FLOAT>;
	/** @param frequency increase for higher octaves */
	freqIncrease: ParamTemplate<ParamType.FLOAT>;
	/** @param noise seed */
	seed: ParamTemplate<ParamType.INTEGER>;
	/** @param toggle on to have the noise be multiplied by the normal */
	useNormals: ParamTemplate<ParamType.BOOLEAN>;
	/** @param set which attribute will be affected by the noise */
	attribName: ParamTemplate<ParamType.STRING>;
	/** @param toggle on to use rest attributes. This can be useful when the noise is animated and this node does not clone the input geometry. Without using rest attributes, the noise would be based on an already modified position, and would therefore accumulate on itself after each cook. This may be what you are after, but for a more conventional result, using a rest attribute will ensure that the noise remains stable. Note that the rest attribute can be created by a RestAttributes node */
	useRestAttributes: ParamTemplate<ParamType.BOOLEAN>;
	/** @param name of rest position */
	restP: ParamTemplate<ParamType.STRING>;
	/** @param name of rest normal */
	restN: ParamTemplate<ParamType.STRING>;
	/** @param operation done when applying the noise (add, set, mult, subtract, divide) */
	operation: ParamTemplate<ParamType.INTEGER>;
	/** @param toggle on to recompute normals if the position has been updated */
	computeNormals: ParamTemplate<ParamType.BOOLEAN>;
}
declare class NoiseSopNode extends TypedSopNode<NoiseSopParamsConfig> {
	paramsConfig: NoiseSopParamsConfig;
	static type(): SopType;
	private _simplexBySeed;
	private _restPos;
	private _restValue2;
	private _restValue4;
	private _noiseValueV;
	private _currentAttribValueF;
	private _currentAttribValueV2;
	private _currentAttribValueV3;
	private _currentAttribValueV4;
	initializeNode(): void;
	setOperation(operation: NoiseOperation): void;
	cook(input_contents: CoreGroup[]): void;
	private _cookForFloat;
	private _cookForV2;
	private _cookForV3;
	private _cookForV4;
	private _noiseValue;
	private static _newAttribValueFromFloat;
	private static _newAttribValueFromVector2;
	private static _newAttribValueFromVector3;
	private static _newAttribValueFromVector4;
	private _amplitudeFromAttrib;
	private _fbm;
	private _getSimplex;
	private _createSimplex;
}
declare class NormalsSopParamsConfig extends NodeParamsConfig {
	/** @param toggle on if normals can be updated via expressions */
	edit: ParamTemplate<ParamType.BOOLEAN>;
	/** @param toggle on to update the x component */
	updateX: ParamTemplate<ParamType.BOOLEAN>;
	/** @param expression or value for the x component */
	x: ParamTemplate<ParamType.FLOAT>;
	/** @param toggle on to update the y component */
	updateY: ParamTemplate<ParamType.BOOLEAN>;
	/** @param expression or value for the y component */
	y: ParamTemplate<ParamType.FLOAT>;
	/** @param toggle on to update the z component */
	updateZ: ParamTemplate<ParamType.BOOLEAN>;
	/** @param expression or value for the z component */
	z: ParamTemplate<ParamType.FLOAT>;
	/** @param recompute the normals based on the position */
	recompute: ParamTemplate<ParamType.BOOLEAN>;
	/** @param invert normals */
	invert: ParamTemplate<ParamType.BOOLEAN>;
}
declare class NormalsSopNode extends TypedSopNode<NormalsSopParamsConfig> {
	paramsConfig: NormalsSopParamsConfig;
	static type(): SopType;
	initializeNode(): void;
	cook(inputCoreGroups: CoreGroup[]): Promise<void>;
	private _evalExpressionsForCoreGroup;
	private _evalExpressionsForCoreObject;
	private _invertNormals;
}
declare class NormalsHelperSopParamsConfig extends NodeParamsConfig {
	/** @param group to assign the material to */
	group: ParamTemplate<ParamType.STRING>;
	/** @param keep input */
	keepInput: ParamTemplate<ParamType.BOOLEAN>;
	/** @param size of the box */
	size: ParamTemplate<ParamType.FLOAT>;
}
declare class NormalsHelperSopNode extends TypedSopNode<NormalsHelperSopParamsConfig> {
	paramsConfig: NormalsHelperSopParamsConfig;
	static type(): SopType;
	initializeNode(): void;
	cook(inputCoreGroups: CoreGroup[]): void;
}
declare class NullSopParamsConfig extends NodeParamsConfig {
}
declare class NullSopNode extends TypedSopNode<NullSopParamsConfig> {
	paramsConfig: NullSopParamsConfig;
	static type(): string;
	initializeNode(): void;
	private _operation;
	cook(input_contents: CoreGroup[]): void;
}
interface ObjectBuilderPersistedConfigBaseJsData extends PersistedConfigBaseJsData {
	functionBody: string;
	variableNames: string[];
	variables: SerializedVariable<SerializedVariableType>[];
	functionNames: Array<keyof NamedFunctionMap>;
	serializedParamConfigs: JsParamConfigJSON<ParamType>[];
}
declare class ObjectBuilderPersistedConfig extends BasePersistedConfig {
	protected node: ObjectBuilderSopNode;
	constructor(node: ObjectBuilderSopNode);
	toData(): Promise<ObjectBuilderPersistedConfigBaseJsData | undefined>;
	load(data: ObjectBuilderPersistedConfigBaseJsData): void;
}
declare class JsAssemblerObjectBuilder extends BaseJsShaderAssembler {
	makeFunctionNodeDirtyOnChange(): boolean;
	templateShader(): {
		main: string;
	};
// @ts-ignore
	spareParamsOptions(options: SpareParamOptions): ParamOptions;
	functionData(): SingleBodyFunctionData | undefined;
	defaultObject3DVariable(): string;
	defaultObject3DMaterialVariable(): string;
	defaultPointIndexVariable(): string;
	updateFunction(): void;
	add_output_inputs(outputNode: OutputJsNode): void;
	add_globals_outputs(globals_node: GlobalsJsNode): void;
	create_shader_configs(): JsShaderConfig[];
	create_variable_configs(): VariableConfig[];
	setNodeLinesOutput(outputNode: OutputJsNode, linesController: JsLinesCollectionController): void;
	setNodeLinesGlobals(globalsNode: GlobalsJsNode, linesController: JsLinesCollectionController): void;
	setNodeLinesAttribute(attributeNode: AttributeJsNode, linesController: JsLinesCollectionController): void;
}
// @ts-ignore
interface ObjectContainer {
	Object3D: Object3D;
	objnum: number;
}
declare class ObjectBuilderSopParamsConfig extends NodeParamsConfig {
	/** @param group to assign the material to */
	group: ParamTemplate<ParamType.STRING>;
}
declare class ObjectBuilderSopNode extends TypedSopNode<ObjectBuilderSopParamsConfig> {
	paramsConfig: ObjectBuilderSopParamsConfig;
	static type(): SopType;
	readonly persisted_config: ObjectBuilderPersistedConfig;
	assemblerController(): JsAssemblerController<JsAssemblerObjectBuilder> | undefined;
	usedAssembler(): Readonly<AssemblerName.JS_OBJECT_BUILDER>;
	protected _assemblerController: JsAssemblerController<JsAssemblerObjectBuilder> | undefined;
	private _createAssemblerController;
	protected _childrenControllerContext: NodeContext;
	createNode<S extends keyof JsNodeChildrenMap>(node_class: S, options?: NodeCreateOptions): JsNodeChildrenMap[S];
	createNode<K extends valueof<JsNodeChildrenMap>>(node_class: Constructor<K>, options?: NodeCreateOptions): K;
	children(): BaseJsNodeType[];
	nodesByType<K extends keyof JsNodeChildrenMap>(type: K): JsNodeChildrenMap[K][];
	childrenAllowed(): boolean;
	sceneReadonly(): boolean;
	private _tmpParent;
	initializeNode(): void;
	cook(inputCoreGroups: CoreGroup[]): Promise<void>;
	private _getObjects;
	compileIfRequired(): void;
	private _objectContainer;
	private _paramConfigs;
	private _functionData;
	private _functionCreationArgs;
	private _functionEvalArgs;
	private _function;
	functionData(): SingleBodyFunctionData | undefined;
	compile(): void;
	updateFromFunctionData(functionData: SingleBodyFunctionData): void;
	functionEvalArgsWithParamConfigs(): (number | boolean | Function | RegisterableVariable | ObjectContainer)[];
}
declare class ObjectMergeSopParamsConfig extends NodeParamsConfig {
	/** @param which SOP node to import from */
	geometry: ParamTemplate<ParamType.NODE_PATH>;
}
declare class ObjectMergeSopNode extends TypedSopNode<ObjectMergeSopParamsConfig> {
	paramsConfig: ObjectMergeSopParamsConfig;
	static type(): string;
	cook(input_containers: CoreGroup[]): Promise<void>;
	importInput(geometry_node: BaseSopNodeType, container: GeometryContainer): void;
}
declare class ObjectPropertiesSopParamsConfig extends NodeParamsConfig {
	/** @param group to assign the material to */
	group: ParamTemplate<ParamType.STRING>;
	/** @param toggle on to set a new name */
	tname: ParamTemplate<ParamType.BOOLEAN>;
	/** @param new name */
	name: ParamTemplate<ParamType.STRING>;
	/** @param toggle on to set a new render order */
	trenderOrder: ParamTemplate<ParamType.BOOLEAN>;
	/** @param render order */
	renderOrder: ParamTemplate<ParamType.INTEGER>;
	/** @param toggle on to allow to set frustrumCulled */
	tfrustumCulled: ParamTemplate<ParamType.BOOLEAN>;
	/** @param sets frustrumCulled */
	frustumCulled: ParamTemplate<ParamType.BOOLEAN>;
	/** @param toggle on to allow to set matrixAutoUpdate */
	tmatrixAutoUpdate: ParamTemplate<ParamType.BOOLEAN>;
	/** @param sets matrixAutoUpdate */
	matrixAutoUpdate: ParamTemplate<ParamType.BOOLEAN>;
	/** @param toggle on to allow to set visible */
	tvisible: ParamTemplate<ParamType.BOOLEAN>;
	/** @param sets visible */
	visible: ParamTemplate<ParamType.BOOLEAN>;
	/** @param toggle on to allow to set castShadow */
	tcastShadow: ParamTemplate<ParamType.BOOLEAN>;
	/** @param sets castShadow */
	castShadow: ParamTemplate<ParamType.BOOLEAN>;
	/** @param toggle on to allow to set receiveShadow */
	treceiveShadow: ParamTemplate<ParamType.BOOLEAN>;
	/** @param sets receiveShadow */
	receiveShadow: ParamTemplate<ParamType.BOOLEAN>;
}
declare class ObjectPropertiesSopNode extends TypedSopNode<ObjectPropertiesSopParamsConfig> {
	paramsConfig: ObjectPropertiesSopParamsConfig;
	static type(): SopType;
	initializeNode(): void;
	private _operation;
	cook(inputCoreGroups: CoreGroup[]): Promise<void>;
	private _cookWithExpressions;
	private _cookWithExpressionsForCoreObjects;
}
declare class ObjectsLayoutSopParamConfig extends NodeParamsConfig {
	/** @param layout width */
	maxLayoutWidth: ParamTemplate<ParamType.FLOAT>;
	/** @param row height */
	rowHeight: ParamTemplate<ParamType.FLOAT>;
	/** @param padding between objects */
	padding: ParamTemplate<ParamType.VECTOR2>;
	/** @param addAttribs */
	addAttribs: ParamTemplate<ParamType.BOOLEAN>;
	/** @param add row index attribute */
	addRowAttrib: ParamTemplate<ParamType.BOOLEAN>;
	/** @param add rowWidthInner attribute */
	addRowWidthInner: ParamTemplate<ParamType.BOOLEAN>;
	/** @param add rowWidthOuter attribute */
	addRowWidthOuter: ParamTemplate<ParamType.BOOLEAN>;
}
declare class ObjectsLayoutSopNode extends TypedSopNode<ObjectsLayoutSopParamConfig> {
	paramsConfig: ObjectsLayoutSopParamConfig;
	static type(): SopType;
	initializeNode(): void;
	private _operation;
	cook(inputCoreGroups: CoreGroup[]): void;
}
declare class OceanPlaneSopParamsConfig extends NodeParamsConfig {
	main: ParamTemplate<ParamType.FOLDER>;
	/** @param reflection direction */
	direction: ParamTemplate<ParamType.VECTOR3>;
	/** @param sun direction */
	sunDirection: ParamTemplate<ParamType.VECTOR3>;
	/** @param sun color */
	sunColor: ParamTemplate<ParamType.COLOR>;
	/** @param water color */
	waterColor: ParamTemplate<ParamType.COLOR>;
	/** @param reflection color */
	reflectionColor: ParamTemplate<ParamType.COLOR>;
	/** @param reflection fresnel */
	reflectionFresnel: ParamTemplate<ParamType.FLOAT>;
	/** @param waves Height */
	wavesHeight: ParamTemplate<ParamType.FLOAT>;
	/** @param distortion scale */
	distortionScale: ParamTemplate<ParamType.FLOAT>;
	/** @param distortion speed */
	timeScale: ParamTemplate<ParamType.FLOAT>;
	/** @param size */
	size: ParamTemplate<ParamType.FLOAT>;
	advanced: ParamTemplate<ParamType.FOLDER>;
	/** @param render reflection */
	renderReflection: ParamTemplate<ParamType.BOOLEAN>;
	/** @param normal Bias - adjusts this if the reflections are too grainy */
	normalBias: ParamTemplate<ParamType.FLOAT>;
	/** @param multisamples */
	multisamples: ParamTemplate<ParamType.INTEGER>;
	/** @param reacts to fog */
	useFog: ParamTemplate<ParamType.BOOLEAN>;
}
declare class OceanPlaneSopNode extends TypedSopNode<OceanPlaneSopParamsConfig> {
	paramsConfig: OceanPlaneSopParamsConfig;
	static type(): string;
	initializeNode(): void;
	cook(inputCoreGroups: CoreGroup[]): void;
	updateObjectOnAdd(object: Object3D, parent: Object3D): void;
}
type OperationInputsMap = WeakMap<SopOperationContainer, Map<number, number>>;
declare class SopOperationContainer extends BaseOperationContainer<NodeContext.SOP> {
	protected operation: BaseSopOperation;
	protected name: string;
	protected init_params: ParamsInitData;
	constructor(operation: BaseSopOperation, name: string, init_params: ParamsInitData);
	operationType(): string;
	protected _inputs: SopOperationContainer[];
	private _currentInputIndex;
	addInput(input: SopOperationContainer): void;
	incrementInputIndex(): void;
	currentInputIndex(): number;
	private _computeResult;
	private _dirty;
	setDirty(): void;
	compute(input_contents: CoreGroup[], operation_inputs_map: OperationInputsMap): Promise<CoreGroup | undefined>;
}
declare class OperationsComposerSopParamConfig extends NodeParamsConfig {
}
interface OperationContainerInputConfig {
	operation_input_index: number;
	node_input_index: number;
}
declare class OperationsComposerSopNode extends TypedSopNode<OperationsComposerSopParamConfig> {
	paramsConfig: OperationsComposerSopParamConfig;
	static type(): string;
	initializeNode(): void;
	private _outputOperationContainer;
	private _inputConfigsByOperationContainer;
	setOutputOperationContainer(operationContainer: SopOperationContainer): void;
	outputOperationContainer(): SopOperationContainer | undefined;
	addInputConfig(operation: SopOperationContainer, inputConfig: OperationContainerInputConfig): void;
	private _operationContainersRequiringResolve;
	addOperationContainerWithPathParamResolveRequired(operationContainer: BaseOperationContainer<NodeContext.SOP>): void;
	resolveOperationContainersPathParams(): void;
	cook(inputCoreGroups: CoreGroup[]): Promise<void>;
}
declare class OrthographicCameraSopParamsConfig extends NodeParamsConfig {
	/** @param camera view size */
	size: ParamTemplate<ParamType.FLOAT>;
	/** @param camera near */
	near: ParamTemplate<ParamType.FLOAT>;
	/** @param camera far */
	far: ParamTemplate<ParamType.FLOAT>;
	/** @param camera position */
	position: ParamTemplate<ParamType.VECTOR3>;
	/** @param camera rotation */
	rotation: ParamTemplate<ParamType.VECTOR3>;
	/** @param show helper */
	showHelper: ParamTemplate<ParamType.BOOLEAN>;
	/** @param matrixAutoUpdate */
	matrixAutoUpdate: ParamTemplate<ParamType.BOOLEAN>;
	/** @param camera name */
	name: ParamTemplate<ParamType.STRING>;
	/** @param set main camera */
	updateTransformFromCamera: ParamTemplate<ParamType.BUTTON>;
}
declare class OrthographicCameraSopNode extends TypedSopNode<OrthographicCameraSopParamsConfig> {
	readonly paramsConfig: OrthographicCameraSopParamsConfig;
	static type(): CameraNodeType;
	static onRegister: OnNodeRegisterCallback;
	protected initializeNode(): void;
	private _operation;
	cook(inputCoreGroups: CoreGroup[]): void;
}
declare class PaletteSopParamsConfig extends NodeParamsConfig {
	/** @param the attribute class (geometry or object) */
	class: ParamTemplate<ParamType.INTEGER>;
	/** @param name of the palette */
	paletteName: ParamTemplate<ParamType.STRING>;
	/** @param click to set the node to the next palette */
	pickNext: ParamTemplate<ParamType.BUTTON>;
	/** @param click to set the node to the previous palette */
	pickPrevious: ParamTemplate<ParamType.BUTTON>;
	/** @param click to set the node to a random palette */
	pickRandom: ParamTemplate<ParamType.BUTTON>;
	colorsCount: ParamTemplate<ParamType.INTEGER>;
	/** @param palette color 1 */
	color1: ParamTemplate<ParamType.COLOR>;
	/** @param palette color 2 */
	color2: ParamTemplate<ParamType.COLOR>;
	/** @param palette color 3 */
	color3: ParamTemplate<ParamType.COLOR>;
	/** @param palette color 4 */
	color4: ParamTemplate<ParamType.COLOR>;
	/** @param palette color 5 */
	color5: ParamTemplate<ParamType.COLOR>;
}
declare class PaletteSopNode extends TypedSopNode<PaletteSopParamsConfig> {
	paramsConfig: PaletteSopParamsConfig;
	static type(): SopType;
	readonly paletteController: PaletteController<NodeContext.SOP>;
	initializeNode(): void;
	private _operation;
	cook(input_contents: CoreGroup[]): void;
	setAttribClass(attribClass: AttribClass): void;
	attribClass(): AttribClass;
}
declare class CoreParticlesGpuComputeController {
	private mainController;
	protected _gpuCompute: GPUComputationRenderer | undefined;
	private _variablesByName;
	private _allVariables;
	private _createdTexturesByName;
	protected _lastSimulatedFrame: number | undefined;
	private _texturesSize;
	private _persistedTextureAllocationsController;
	constructor(mainController: CoreParticlesController);
	dispose(): void;
	setPersistedTextureAllocationController(controller: TextureAllocationsController): void;
	allVariables(): GPUComputationRendererVariable[];
	init(): GPUComputationConfigRef | undefined;
	private _initPoints;
	private _initParticlesUVs;
	createGPUCompute(): GPUComputationConfigRef | undefined;
	computeSimulation(delta: number, configRef: GPUComputationConfigRef): void;
	getCurrentRenderTarget(shader_name: ShaderName): WebGLRenderTarget | undefined;
	private _textureNameForShaderName;
	materials(): ShaderMaterial[];
	private _createSimulationMaterialUniforms;
	private _assignReadonlyTextures;
	private _updateSimulationMaterialUniforms;
	createdTexturesByName(): Readonly<Map<ShaderName, DataTexture>>;
	private _fillTextures;
	reset(): void;
	private resetGpuCompute;
	private _createTextureRenderTargets;
	private _textureAllocationsController;
	private _readonlyAllocations;
}
declare class CoreParticlesRenderController {
	private mainController;
	private _renderMaterial;
	private _uniformByShaderName;
	private _texture_allocations_json;
	private _materialGlobalsHandler;
	private _matNodeAssembler;
	constructor(mainController: CoreParticlesController);
	dispose(): void;
	reset(): void;
	assignRenderMaterial(): void;
	updateRenderMaterialUniforms(): void;
	material(): Material | undefined;
	init(): Promise<void>;
}
declare class CoreParticlesController {
	readonly scene: PolyScene;
	private _node;
	readonly gpuController: CoreParticlesGpuComputeController;
	readonly renderController: CoreParticlesRenderController;
	private _shadersByName;
	private _shaderNames;
	private _uniformNames;
	protected _object: Object3D | undefined;
	protected _renderer: AbstractRenderer | undefined;
	constructor(scene: PolyScene, _node: ParticlesSystemGpuSopNode);
	object(): Object3D<Event> | undefined;
	renderer(): AbstractRenderer | undefined;
	dispose(): void;
	init(object: Object3D, renderer: AbstractRenderer): Promise<GPUComputationConfigRef | undefined>;
	stepSimulation(delta: number, configRef: GPUComputationConfigRef): void;
	reset(): Promise<GPUComputationConfigRef | undefined>;
	setError(message: string): void;
	node(): ParticlesSystemGpuSopNode;
	setShadersByName(shadersByName: Map<ShaderName, string>): void;
	shadersByName(): Map<ShaderName, string>;
	shaderNames(): ShaderName[];
	uniformNames(): string[];
	setPersistedTextureAllocationController(controller: TextureAllocationsController): void;
	private _debugCook;
	debugMessage(message: string): void;
}
interface PersistedConfigBaseParticlesData extends PersistedConfigWithShaders {
	texture_allocations: TextureAllocationsControllerData;
	param_uniform_pairs: [
		string,
		string
	][];
	uniforms_owner: object;
}
declare class ParticlesPersistedConfig extends BasePersistedConfig {
	protected node: ParticlesSystemGpuSopNode;
	private _loaded_data;
	constructor(node: ParticlesSystemGpuSopNode);
	toData(): Promise<PersistedConfigBaseParticlesData | undefined>;
	load(data: PersistedConfigBaseParticlesData): void;
	loaded_data(): PersistedConfigBaseParticlesData | undefined;
	shaders_by_name(): Map<ShaderName, string> | undefined;
	texture_allocations_controller(): TextureAllocationsController | undefined;
	uniforms(): {
		[uniform: string]: IUniform<any>;
	} | undefined;
}
declare class ShaderAssemblerParticles extends BaseGlShaderAssembler {
	private _textureAllocationsController;
	templateShader(): undefined;
	protected _template_shader_for_shader_name(shader_name: ShaderName): string;
	compile(): void;
	rootNodesByShaderName(shader_name: ShaderName, rootNodes: BaseGlNodeType[]): BaseGlNodeType[];
	setup_shader_names_and_variables(): void;
	private _updateShaders;
	add_output_inputs(output_child: OutputGlNode): void;
	add_globals_outputs(globals_node: GlobalsGlNode): void;
	allow_attribute_exports(): boolean;
	textureAllocationsController(): TextureAllocationsController;
	create_shader_configs(): ShaderConfig[];
	create_variable_configs(): never[];
	shaderNames(): ShaderName[];
	inputNamesForShaderName(root_node: BaseGlNodeType, shader_name: ShaderName): string[];
	protected insertDefineAfter(shader_name: ShaderName): string;
	protected insertBodyAfter(shader_name: ShaderName): string;
	protected linesToRemove(shader_name: ShaderName): string[];
	add_export_body_line(export_node: BaseGlNodeType, input_name: string, input: BaseGlNodeType, variable_name: string, shaders_collection_controller: ShadersCollectionController): void;
	set_node_lines_output(output_node: BaseGlNodeType, shaders_collection_controller: ShadersCollectionController): void;
	setNodeLinesAttribute(attribute_node: AttributeGlNode, shaders_collection_controller: ShadersCollectionController): void;
	set_node_lines_globals(globals_node: GlobalsGlNode, shaders_collection_controller: ShadersCollectionController): void;
	private _handle_globals_time;
	private _handle_globals_default;
}
declare class ParticlesSystemGpuSopParamsConfig extends NodeParamsConfig {
	/** @param group to assign the material to */
	group: ParamTemplate<ParamType.STRING>;
	/** @param data type used by the solver */
	dataType: ParamTemplate<ParamType.INTEGER>;
	/** @param number of frames to run before scene plays */
	preRollFramesCount: ParamTemplate<ParamType.INTEGER>;
	/** @param material used to render the particles */
	material: ParamTemplate<ParamType.NODE_PATH>;
}
declare class ParticlesSystemGpuSopNode extends TypedSopNode<ParticlesSystemGpuSopParamsConfig> {
	paramsConfig: ParticlesSystemGpuSopParamsConfig;
	static type(): SopType;
	dispose(): void;
	assemblerController(): GlAssemblerController<ShaderAssemblerParticles> | undefined;
	usedAssembler(): Readonly<AssemblerName.GL_PARTICLES>;
	protected _assemblerController: GlAssemblerController<ShaderAssemblerParticles> | undefined;
	private _createAssemblerController;
	readonly persisted_config: ParticlesPersistedConfig;
	private _particlesGlobalsHandler;
	private _shadersByName;
	shadersByName(): Map<ShaderName, string>;
	static requireWebGL2(): boolean;
	protected _childrenControllerContext: NodeContext;
	initializeNode(): void;
	createNode<S extends keyof GlNodeChildrenMap>(node_class: S, options?: NodeCreateOptions): GlNodeChildrenMap[S];
	createNode<K extends valueof<GlNodeChildrenMap>>(node_class: Constructor<K>, options?: NodeCreateOptions): K;
	children(): BaseGlNodeType[];
	nodesByType<K extends keyof GlNodeChildrenMap>(type: K): GlNodeChildrenMap[K][];
	childrenAllowed(): boolean;
	sceneReadonly(): boolean;
	private _operation;
	cook(inputCoreGroups: CoreGroup[]): Promise<void>;
	updateObjectOnAdd(object: Object3D): void;
	compileIfRequired(): void;
	run_assembler(): void;
	private _setShaderNames;
	init_with_persisted_config(): void;
	initCoreParticlesControllerFromPersistedConfig(coreParticlesController: CoreParticlesController): void;
	private _findExportNodes;
}
declare class ParticlesSystemGpuAttributesSopParamsConfig extends NodeParamsConfig {
	/** @param group to assign the material to */
	group: ParamTemplate<ParamType.STRING>;
}
declare class ParticlesSystemGpuAttributesSopNode extends TypedSopNode<ParticlesSystemGpuAttributesSopParamsConfig> {
	paramsConfig: ParticlesSystemGpuAttributesSopParamsConfig;
	static type(): SopType;
	protected initializeNode(): void;
	private _operation;
	cook(inputCoreGroups: CoreGroup[]): Promise<void>;
}
declare class ParticlesSystemGpuMaterialSopParamsConfig extends NodeParamsConfig {
	/** @param group to assign the material to */
	group: ParamTemplate<ParamType.STRING>;
	/** @param the material node */
	material: ParamTemplate<ParamType.NODE_PATH>;
}
declare class ParticlesSystemGpuMaterialSopNode extends TypedSopNode<ParticlesSystemGpuMaterialSopParamsConfig> {
	paramsConfig: ParticlesSystemGpuMaterialSopParamsConfig;
	static type(): SopType;
	protected initializeNode(): void;
	private _operation;
	cook(inputCoreGroups: CoreGroup[]): Promise<void>;
}
declare class PeakSopParamsConfig extends NodeParamsConfig {
	/** @param amount the points will be moved */
	amount: ParamTemplate<ParamType.FLOAT>;
}
declare class PeakSopNode extends TypedSopNode<PeakSopParamsConfig> {
	paramsConfig: PeakSopParamsConfig;
	static type(): string;
	initializeNode(): void;
	private _operation;
	cook(input_contents: CoreGroup[]): void;
}
declare class PerspectiveCameraSopParamsConfig extends NodeParamsConfig {
	default: ParamTemplate<ParamType.FOLDER>;
	/** @param camera fov */
	fov: ParamTemplate<ParamType.FLOAT>;
	/** @param camera near */
	near: ParamTemplate<ParamType.FLOAT>;
	/** @param camera far */
	far: ParamTemplate<ParamType.FLOAT>;
	/** @param camera position */
	position: ParamTemplate<ParamType.VECTOR3>;
	/** @param camera rotation */
	rotation: ParamTemplate<ParamType.VECTOR3>;
	/** @param show helper */
	showHelper: ParamTemplate<ParamType.BOOLEAN>;
	/** @param matrixAutoUpdate */
	matrixAutoUpdate: ParamTemplate<ParamType.BOOLEAN>;
	/** @param camera name */
	name: ParamTemplate<ParamType.STRING>;
	/** @param set main camera */
	updateTransformFromCamera: ParamTemplate<ParamType.BUTTON>;
	PBR: ParamTemplate<ParamType.FOLDER>;
	/** @param apertureBlades */
	apertureBlades: ParamTemplate<ParamType.INTEGER>;
	/** @param apertureBlades */
	fStop: ParamTemplate<ParamType.FLOAT>;
	/** @param focusDistance */
	focusDistance: ParamTemplate<ParamType.FLOAT>;
	/** @param apertureRotation */
	apertureRotation: ParamTemplate<ParamType.FLOAT>;
	/** @param anamorphicRatio */
	anamorphicRatio: ParamTemplate<ParamType.FLOAT>;
}
declare class PerspectiveCameraSopNode extends TypedSopNode<PerspectiveCameraSopParamsConfig> {
	readonly paramsConfig: PerspectiveCameraSopParamsConfig;
	static type(): CameraNodeType;
	static onRegister: OnNodeRegisterCallback;
	protected initializeNode(): void;
	private _operation;
	cook(inputCoreGroups: CoreGroup[]): void;
}
declare class PhysicsDebugSopParamsConfig extends NodeParamsConfig {
}
declare class PhysicsDebugSopNode extends TypedActorSopNode<PhysicsDebugSopParamsConfig> {
	readonly paramsConfig: PhysicsDebugSopParamsConfig;
	static type(): SopType.PHYSICS_DEBUG;
	protected initializeNode(): void;
	cook(inputCoreGroups: CoreGroup[]): Promise<void>;
	private _findActorNode;
}
declare class PhysicsGroundSopParamsConfig extends NodeParamsConfig {
	/** @param size */
	size: ParamTemplate<ParamType.VECTOR2>;
	/** @param center */
	center: ParamTemplate<ParamType.VECTOR2>;
	/** @param height */
	height: ParamTemplate<ParamType.FLOAT>;
	/** @param direction */
	direction: ParamTemplate<ParamType.VECTOR3>;
	/** @param thickness */
	thickness: ParamTemplate<ParamType.FLOAT>;
	/** @param friction */
	friction: ParamTemplate<ParamType.FLOAT>;
	/** @param restitution */
	restitution: ParamTemplate<ParamType.FLOAT>;
}
declare class PhysicsGroundSopNode extends TypedSopNode<PhysicsGroundSopParamsConfig> {
	readonly paramsConfig: PhysicsGroundSopParamsConfig;
	static type(): SopType;
	protected initializeNode(): void;
	cook(): void;
}
declare class PhysicsPlayerSopParamsConfig extends NodeParamsConfig {
	main: ParamTemplate<ParamType.FOLDER>;
	/** @param radius */
	radius: ParamTemplate<ParamType.FLOAT>;
	/** @param density */
	density: ParamTemplate<ParamType.FLOAT>;
	/** @param friction */
	friction: ParamTemplate<ParamType.FLOAT>;
	/** @param restitution */
	restitution: ParamTemplate<ParamType.FLOAT>;
	/** @param linear damping (affects velocity) */
	linearDamping: ParamTemplate<ParamType.FLOAT>;
	/** @param angular damping (affects rotations) */
	angularDamping: ParamTemplate<ParamType.FLOAT>;
	/** @param linear velocity */
	linearVelocity: ParamTemplate<ParamType.VECTOR3>;
	/** @param angular velocity */
	angularVelocity: ParamTemplate<ParamType.VECTOR3>;
	/** @param gravity Scale */
	gravityScale: ParamTemplate<ParamType.FLOAT>;
	details: ParamTemplate<ParamType.FOLDER>;
	/** @param id */
	id: ParamTemplate<ParamType.STRING>;
}
declare class PhysicsPlayerSopNode extends TypedActorSopNode<PhysicsPlayerSopParamsConfig> {
	readonly paramsConfig: PhysicsPlayerSopParamsConfig;
	static type(): SopType.PHYSICS_PLAYER;
	protected initializeNode(): void;
	cook(inputCoreGroups: CoreGroup[]): void;
	private _updatePlayerObject;
	private _createDefaultInputObjects;
	private _findActorNode;
}
declare enum PhysicsJointType {
	FIXED = "fixed",
	SPHERICAL = "spherical",
	REVOLUT = "revolute",
	PRISMATIC = "prismatic"
}
declare class PhysicsRBDJointsSopParamsConfig extends NodeParamsConfig {
	/** @param group to assign the material to */
	group: ParamTemplate<ParamType.STRING>;
	/** @param maxDistance */
	maxDistance: ParamTemplate<ParamType.FLOAT>;
	/** @param max number of joints per object */
	maxJointsCount: ParamTemplate<ParamType.INTEGER>;
	/** @param joint type */
	jointType: ParamTemplate<ParamType.INTEGER>;
	/** @param limit */
	limit: ParamTemplate<ParamType.VECTOR2>;
	/** @param up */
	up: ParamTemplate<ParamType.VECTOR3>;
	/** @param center */
	center: ParamTemplate<ParamType.FLOAT>;
	/** @param anchors at objects center */
	anchorsAtCenter: ParamTemplate<ParamType.BOOLEAN>;
	/** @param anchor position 1 */
	anchorsPos1: ParamTemplate<ParamType.VECTOR3>;
	/** @param anchor position 2 */
	anchorsPos2: ParamTemplate<ParamType.VECTOR3>;
	/** @param do not output input RBDs with joints */
	ouputsJointsOnly: ParamTemplate<ParamType.BOOLEAN>;
}
declare class PhysicsRBDJointsSopNode extends TypedSopNode<PhysicsRBDJointsSopParamsConfig> {
	readonly paramsConfig: PhysicsRBDJointsSopParamsConfig;
	static type(): SopType;
	protected initializeNode(): void;
	setJointType(RBDtype: PhysicsJointType): void;
	jointType(): PhysicsJointType;
	cook(inputCoreGroups: CoreGroup[]): void;
	private _createJoint;
}
declare enum PhysicsRBDType {
	FIXED = "fixed",
	DYNAMIC = "dynamic",
	KINEMATIC_VEL = "kinematicVelocityBased",
	KINEMATIC_POS = "kinematicPositionBased"
}
declare enum PhysicsRBDColliderType {
	CAPSULE = "capsule",
	CONE = "cone",
	CONVEX_HULL = "convex hull",
	CUBOID = "cuboid",
	CYLINDER = "cylinder",
	SPHERE = "sphere",
	TRIMESH = "trimesh",
	HEIGHT_FIELD = "heightField"
}
declare enum SizeComputationMethod {
	AUTO = "auto",
	MANUAL = "manual"
}
declare class PhysicsRBDAttributesSopParamsConfig extends NodeParamsConfig {
	main: ParamTemplate<ParamType.FOLDER>;
	/** @param Rigid body type */
	RBDType: ParamTemplate<ParamType.INTEGER>;
	/** @param collider type */
	colliderType: ParamTemplate<ParamType.INTEGER>;
	/** @param Rigid body type */
	sizeMethod: ParamTemplate<ParamType.INTEGER>;
	/** @param border radius */
	borderRadius: ParamTemplate<ParamType.FLOAT>;
	/** @param sizes */
	sizes: ParamTemplate<ParamType.VECTOR3>;
	/** @param sizes */
	size: ParamTemplate<ParamType.FLOAT>;
	/** @param radius */
	radius: ParamTemplate<ParamType.FLOAT>;
	/** @param half height */
	height: ParamTemplate<ParamType.FLOAT>;
	/** @param heightField rows */
	rows: ParamTemplate<ParamType.INTEGER>;
	/** @param heightField cols */
	cols: ParamTemplate<ParamType.INTEGER>;
	/** @param density */
	density: ParamTemplate<ParamType.FLOAT>;
	/** @param friction */
	friction: ParamTemplate<ParamType.FLOAT>;
	/** @param restitution */
	restitution: ParamTemplate<ParamType.FLOAT>;
	/** @param linear damping (affects velocity) */
	linearDamping: ParamTemplate<ParamType.FLOAT>;
	/** @param angular damping (affects rotations) */
	angularDamping: ParamTemplate<ParamType.FLOAT>;
	/** @param linear velocity */
	linearVelocity: ParamTemplate<ParamType.VECTOR3>;
	/** @param angular velocity */
	angularVelocity: ParamTemplate<ParamType.VECTOR3>;
	/** @param gravity Scale */
	gravityScale: ParamTemplate<ParamType.FLOAT>;
	/** @param can sleep */
	canSleep: ParamTemplate<ParamType.BOOLEAN>;
	details: ParamTemplate<ParamType.FOLDER>;
	/** @param add id */
	addId: ParamTemplate<ParamType.BOOLEAN>;
	/** @param id */
	id: ParamTemplate<ParamType.STRING>;
}
declare class PhysicsRBDAttributesSopNode extends TypedSopNode<PhysicsRBDAttributesSopParamsConfig> {
	readonly paramsConfig: PhysicsRBDAttributesSopParamsConfig;
	static type(): SopType;
	protected initializeNode(): void;
	setRBDType(RBDtype: PhysicsRBDType): void;
	RBDType(): PhysicsRBDType;
	setColliderType(colliderType: PhysicsRBDColliderType): void;
	colliderType(): PhysicsRBDColliderType;
	setSizeMethod(sizeMethod: SizeComputationMethod): void;
	sizeMethod(): SizeComputationMethod;
	cook(inputCoreGroups: CoreGroup[]): Promise<void>;
	protected _applyColliderType<T extends CoreObjectType>(colliderType: PhysicsRBDColliderType, sizeMethod: SizeComputationMethod, coreObjects: BaseCoreObject<T>[], //BaseCoreObject<CoreObjectType>[],
	promises: Array<Promise<void>>): void;
	protected _computeStringParam<T extends CoreObjectType>(param: StringParam, coreObjects: BaseCoreObject<T>[], applyMethod: (object: ObjectContent<CoreObjectType>, value: string) => void): Promise<void>;
	protected _computeVector3Param(vectorParam: Vector3Param, coreObjects: BaseCoreObject<CoreObjectType>[], applyMethod: (object: ObjectContent<CoreObjectType>, value: Vector3) => void): Promise<void>;
	protected _computeNumberParam(param: FloatParam | IntegerParam, coreObjects: BaseCoreObject<CoreObjectType>[], applyMethod: (object: ObjectContent<CoreObjectType>, value: number) => void): Promise<void>;
	protected _computeBooleanParam(param: BooleanParam, coreObjects: BaseCoreObject<CoreObjectType>[], applyMethod: (object: ObjectContent<CoreObjectType>, value: boolean) => void): Promise<void>;
}
declare class PhysicsWorldSopParamsConfig extends NodeParamsConfig {
	/** @param gravity */
	gravity: ParamTemplate<ParamType.VECTOR3>;
}
declare class PhysicsWorldSopNode extends TypedActorSopNode<PhysicsWorldSopParamsConfig> {
	readonly paramsConfig: PhysicsWorldSopParamsConfig;
	static type(): SopType.PHYSICS_WORLD;
	protected initializeNode(): void;
	cook(inputCoreGroups: CoreGroup[]): Promise<void>;
	updateObjectOnAdd(object: Object3D): void;
	private _findActorNode;
}
declare class PlaneSopParamsConfig extends NodeParamsConfig {
	/** @param size of the plane */
	size: ParamTemplate<ParamType.VECTOR2>;
	/** @param defines if the plane resolution is sets via the number of segments or via the step size */
	useSegmentsCount: ParamTemplate<ParamType.BOOLEAN>;
	/** @param step size */
	stepSize: ParamTemplate<ParamType.FLOAT>;
	/** @param segments count */
	segments: ParamTemplate<ParamType.VECTOR2>;
	/** @param axis perpendicular to the plane */
	direction: ParamTemplate<ParamType.VECTOR3>;
	/** @param center of the plane */
	center: ParamTemplate<ParamType.VECTOR3>;
	/** @param create lines instead of polygons */
	asLines: ParamTemplate<ParamType.BOOLEAN>;
}
declare class PlaneSopNode extends TypedSopNode<PlaneSopParamsConfig> {
	paramsConfig: PlaneSopParamsConfig;
	static type(): SopType;
	initializeNode(): void;
	private _operation;
	cook(input_contents: CoreGroup[]): void;
}
declare class PlaneHelperSopParamsConfig extends NodeParamsConfig {
	/** @param size of the plane */
	size: ParamTemplate<ParamType.FLOAT>;
	/** @param colorCenterLine */
	colorCenterLine: ParamTemplate<ParamType.COLOR>;
	/** @param colorGrid */
	colorGrid: ParamTemplate<ParamType.COLOR>;
}
declare class PlaneHelperSopNode extends TypedSopNode<PlaneHelperSopParamsConfig> {
	paramsConfig: PlaneHelperSopParamsConfig;
	static type(): string;
	initializeNode(): void;
	private _operation;
	cook(input_contents: CoreGroup[]): void;
}
declare class PointBuilderPersistedConfig extends BasePointBuilderPersistedConfig {
	protected node: PointBuilderSopNode;
	constructor(node: PointBuilderSopNode);
}
declare class PointBuilderSopParamsConfig extends BasePointBuilderSopParamsConfig {
	/** @param updateNormals */
	updateNormals: ParamTemplate<ParamType.BOOLEAN>;
}
declare class PointBuilderSopNode extends BasePointBuilderSopNode<PointBuilderSopParamsConfig> {
	paramsConfig: PointBuilderSopParamsConfig;
	static type(): SopType;
	readonly persisted_config: PointBuilderPersistedConfig;
	usedAssembler(): Readonly<AssemblerName.JS_POINT_BUILDER>;
	protected _pointContainer: PointContainer;
	protected _processObject<T extends CoreObjectType>(object: ObjectContent<T>, objnum: number, evaluator: PointBuilderEvaluator): void;
}
declare class PointSopParamsConfig extends NodeParamsConfig {
	/** @param toggle on to update the x component */
	updateX: ParamTemplate<ParamType.BOOLEAN>;
	/** @param expression the x component */
	x: ParamTemplate<ParamType.FLOAT>;
	/** @param toggle on to update the y component */
	updateY: ParamTemplate<ParamType.BOOLEAN>;
	/** @param expression the y component */
	y: ParamTemplate<ParamType.FLOAT>;
	/** @param toggle on to update the z component */
	updateZ: ParamTemplate<ParamType.BOOLEAN>;
	/** @param expression the z component */
	z: ParamTemplate<ParamType.FLOAT>;
	/** @param toggle on to update the normals */
	updateNormals: ParamTemplate<ParamType.BOOLEAN>;
}
declare class PointSopNode extends TypedSopNode<PointSopParamsConfig> {
	paramsConfig: PointSopParamsConfig;
	static type(): SopType;
	private _x_arrays_by_geometry_uuid;
	private _y_arrays_by_geometry_uuid;
	private _z_arrays_by_geometry_uuid;
	initializeNode(): void;
	cook(inputCoreGroups: CoreGroup[]): Promise<void>;
	_evalExpressionsForCoreGroup(coreGroup: CoreGroup): Promise<void>;
	_evalExpressionsForCoreObject(coreObject: ThreejsCoreObject): Promise<void>;
	private _updateFromParam;
	private _initArrayIfRequired;
	private _array_for_component;
	private _commit_tmp_values;
}
declare const PointLightSopParamsConfig_base: {
	new (...args: any[]): {
		light: ParamTemplate<ParamType.FOLDER>;
		color: ParamTemplate<ParamType.COLOR>;
		intensity: ParamTemplate<ParamType.FLOAT>;
		decay: ParamTemplate<ParamType.FLOAT>;
		distance: ParamTemplate<ParamType.FLOAT>;
		showHelper: ParamTemplate<ParamType.BOOLEAN>;
		helperSize: ParamTemplate<ParamType.FLOAT>;
		name: ParamTemplate<ParamType.STRING>;
		shadow: ParamTemplate<ParamType.FOLDER>;
		castShadow: ParamTemplate<ParamType.BOOLEAN>;
		shadowAutoUpdate: ParamTemplate<ParamType.BOOLEAN>;
		shadowUpdateOnNextRender: ParamTemplate<ParamType.BOOLEAN>;
		shadowRes: ParamTemplate<ParamType.VECTOR2>;
		shadowBias: ParamTemplate<ParamType.FLOAT>;
		shadowNear: ParamTemplate<ParamType.FLOAT>;
		shadowFar: ParamTemplate<ParamType.FLOAT>;
		raymarching: ParamTemplate<ParamType.FOLDER>;
		raymarchingPenumbra: ParamTemplate<ParamType.FLOAT>;
		raymarchingShadowBiasAngle: ParamTemplate<ParamType.FLOAT>;
		raymarchingShadowBiasDistance: ParamTemplate<ParamType.FLOAT>;
	};
} & typeof NodeParamsConfig;
declare class PointLightSopParamsConfig extends PointLightSopParamsConfig_base {
}
declare class PointLightSopNode extends TypedSopNode<PointLightSopParamsConfig> {
	paramsConfig: PointLightSopParamsConfig;
	static type(): LightType;
	initializeNode(): void;
	private _operation;
	cook(input_contents: CoreGroup[]): void;
}
declare class PolarTransformSopParamConfig extends NodeParamsConfig {
	/** @param sets if this node should transform objects or geometries */
	applyOn: ParamTemplate<ParamType.INTEGER>;
	/** @param center of the transform */
	center: ParamTemplate<ParamType.VECTOR3>;
	/** @param moves the objects along the longitude, which is equivalent to a rotation on the y axis */
	longitude: ParamTemplate<ParamType.FLOAT>;
	/** @param moves the objects along the latitude, which is equivalent to a rotation on the z or x axis */
	latitude: ParamTemplate<ParamType.FLOAT>;
	/** @param moves the point aways from the center */
	depth: ParamTemplate<ParamType.FLOAT>;
}
declare class PolarTransformSopNode extends TypedSopNode<PolarTransformSopParamConfig> {
	paramsConfig: PolarTransformSopParamConfig;
	static type(): SopType;
	initializeNode(): void;
	private _operation;
	cook(input_contents: CoreGroup[]): void;
	setApplyOn(mode: TransformTargetType): void;
}
declare class PolywireSopParamsConfig extends NodeParamsConfig {
	/** @param radius */
	radius: ParamTemplate<ParamType.FLOAT>;
	/** @param segments count on the circle used */
	segmentsRadial: ParamTemplate<ParamType.INTEGER>;
	/** @param toggle on for the geometry to close back on itself */
	closed: ParamTemplate<ParamType.BOOLEAN>;
	/** @param attributesToCopy */
	attributesToCopy: ParamTemplate<ParamType.STRING>;
}
declare class PolywireSopNode extends TypedSopNode<PolywireSopParamsConfig> {
	paramsConfig: PolywireSopParamsConfig;
	static type(): SopType;
	initializeNode(): void;
	private _operation;
	cook(inputCoreGroups: CoreGroup[]): void;
}
declare class QuadSopNode<K extends NodeParamsConfig> extends TypedSopNode<K> {
	dataType(): string;
	requiredModules(): ModuleName[];
	setQuadGeometry(geometry: QuadGeometry): void;
	setQuadGeometries(geometries: QuadGeometry[]): void;
	setQuadObjects(quadObjects: QuadObject[]): void;
	setQuadObject(quadObject: QuadObject): void;
	protected _setContainerQuadObjects(objects: QuadObject[]): void;
}
declare class QuadPlaneSopParamsConfig extends NodeParamsConfig {
	/** @param sizes */
	size: ParamTemplate<ParamType.VECTOR2>;
	/** @param defines if the plane resolution is sets via the number of segments or via the step size */
	useSegmentsCount: ParamTemplate<ParamType.BOOLEAN>;
	/** @param step size */
	stepSize: ParamTemplate<ParamType.FLOAT>;
	/** @param segments count */
	segments: ParamTemplate<ParamType.VECTOR2>;
	/** @param axis perpendicular to the plane */
	direction: ParamTemplate<ParamType.VECTOR3>;
	/** @param center of the plane */
	center: ParamTemplate<ParamType.VECTOR3>;
}
declare class QuadPlaneSopNode extends QuadSopNode<QuadPlaneSopParamsConfig> {
	paramsConfig: QuadPlaneSopParamsConfig;
	static type(): SopType;
	cook(inputCoreGroups: CoreGroup[]): void;
	private _createWithStepSize;
	private _createWithSegmentsCount;
	private _createQuadPlane;
}
declare enum QuadSmoothMode {
	SQUARIFY = "squarify",
	AVERAGE = "average"
}
declare class QuadSmoothSopParamsConfig extends NodeParamsConfig {
	/** @param mode */
	mode: ParamTemplate<ParamType.INTEGER>;
	/** @param iterations */
	iterations: ParamTemplate<ParamType.INTEGER>;
	/** @param strength */
	strength: ParamTemplate<ParamType.FLOAT>;
}
declare class QuadSmoothSopNode extends QuadSopNode<QuadSmoothSopParamsConfig> {
	paramsConfig: QuadSmoothSopParamsConfig;
	static type(): SopType;
	initializeNode(): void;
	cook(inputCoreGroups: CoreGroup[]): void;
	setMode(method: QuadSmoothMode): void;
	mode(): QuadSmoothMode;
	private _smoothQuadGeometry;
	private _smoothQuadGeometryWithAverage;
	private _smoothQuadGeometryWithSquarify;
}
declare const QuadTriangulateSopParamsConfig_base: {
	new (...args: any[]): {
		triangles: ParamTemplate<ParamType.BOOLEAN>;
		wireframe: ParamTemplate<ParamType.BOOLEAN>;
	};
} & typeof NodeParamsConfig;
declare class QuadTriangulateSopParamsConfig extends QuadTriangulateSopParamsConfig_base {
}
declare class QuadTriangulateSopNode extends QuadSopNode<QuadTriangulateSopParamsConfig> {
	readonly paramsConfig: QuadTriangulateSopParamsConfig;
	static type(): SopType;
	protected initializeNode(): void;
	cook(inputCoreGroups: CoreGroup[]): Promise<void>;
}
declare class QuadrangulateSopParamsConfig extends NodeParamsConfig {
	/** @param quadsCount */
	/** @param regular */
	regular: ParamTemplate<ParamType.BOOLEAN>;
	/** @param seed */
	seed: ParamTemplate<ParamType.INTEGER>;
}
declare class QuadrangulateSopNode extends QuadSopNode<QuadrangulateSopParamsConfig> {
	paramsConfig: QuadrangulateSopParamsConfig;
	static type(): SopType;
	initializeNode(): void;
	cook(inputCoreGroups: CoreGroup[]): void;
	private _processGeometry;
}
declare enum RaySopMode {
	PROJECT_RAY = "project rays",
	MIN_DIST = "minimum distance"
}
declare class RaySopParamsConfig extends NodeParamsConfig {
	/** @param method used to ray points onto the collision geometry */
	mode: ParamTemplate<ParamType.INTEGER>;
	/** @param toggle on to use the normals as the ray direction */
	useNormals: ParamTemplate<ParamType.BOOLEAN>;
	/** @param if the normals are not used as the ray direction, this define the direction used */
	direction: ParamTemplate<ParamType.VECTOR3>;
	/** @param moves the points or leaves them in place */
	transformPoints: ParamTemplate<ParamType.BOOLEAN>;
	/** @param copies the normals from the right geometry to the left one */
	transferFaceNormals: ParamTemplate<ParamType.BOOLEAN>;
	/** @param adds an attribute with the distance to the hit position on the target geometry */
	addDistAttribute: ParamTemplate<ParamType.BOOLEAN>;
}
declare class RaySopNode extends TypedSopNode<RaySopParamsConfig> {
	paramsConfig: RaySopParamsConfig;
	static type(): SopType;
	initializeNode(): void;
	private _operation;
	cook(inputCoreGroups: CoreGroup[]): void;
	setMode(mode: RaySopMode): void;
}
declare class ReflectorSopParamsConfig extends NodeParamsConfig {
	/** @param direction the objects reflects */
	direction: ParamTemplate<ParamType.VECTOR3>;
	/** @param direction offset */
	directionOffset: ParamTemplate<ParamType.FLOAT>;
	/** @param when active is off, the mirror is not rendered */
	active: ParamTemplate<ParamType.BOOLEAN>;
	/** @param bias to ensure the mirror does not reflect itself */
	clipBias: ParamTemplate<ParamType.FLOAT>;
	/** @param color */
	color: ParamTemplate<ParamType.COLOR>;
	/** @param useVertexColor */
	useVertexColor: ParamTemplate<ParamType.BOOLEAN>;
	/** @param reflectionBlend */
	reflectionBlend: ParamTemplate<ParamType.FLOAT>;
	/** @param pixelRatio */
	/** @param opacity */
	opacity: ParamTemplate<ParamType.FLOAT>;
	pixelRatio: ParamTemplate<ParamType.INTEGER>;
	/** @param multisamples */
	multisamples: ParamTemplate<ParamType.INTEGER>;
	/** @param toggle to activate blur */
	tblur: ParamTemplate<ParamType.BOOLEAN>;
	/** @param blur amount */
	blur: ParamTemplate<ParamType.FLOAT>;
	/** @param vertical blur multiplier */
	verticalBlurMult: ParamTemplate<ParamType.FLOAT>;
	/** @param toggle to activate a second blur, which can be useful to reduce artefacts */
	tblur2: ParamTemplate<ParamType.BOOLEAN>;
	/** @param blur2 amount */
	blur2: ParamTemplate<ParamType.FLOAT>;
	/** @param vertical blur2 multiplier */
	verticalBlur2Mult: ParamTemplate<ParamType.FLOAT>;
}
declare class ReflectorSopNode extends TypedSopNode<ReflectorSopParamsConfig> {
	paramsConfig: ReflectorSopParamsConfig;
	static type(): SopType;
	initializeNode(): void;
	cook(inputCoreGroups: CoreGroup[]): void;
	updateObjectOnAdd(object: Object3D, parent: Object3D): void;
}
declare enum SplineCurveType {
	CATMULLROM = "catmullrom",
	CENTRIPETAL = "centripetal",
	CHORDAL = "chordal"
}
declare class ResampleSopParamsConfig extends NodeParamsConfig {
	/** @param resampling method */
	method: ParamTemplate<ParamType.INTEGER>;
	/** @param type of curve this will generate */
	curveType: ParamTemplate<ParamType.INTEGER>;
	/** @param curve tension */
	tension: ParamTemplate<ParamType.FLOAT>;
	/** @param points count */
	pointsCount: ParamTemplate<ParamType.INTEGER>;
	/** @param segments length */
	segmentLength: ParamTemplate<ParamType.FLOAT>;
}
declare class ResampleSopNode extends TypedSopNode<ResampleSopParamsConfig> {
	paramsConfig: ResampleSopParamsConfig;
	static type(): string;
	initializeNode(): void;
	cook(inputCoreGroups: CoreGroup[]): void;
	setCurveType(curveType: SplineCurveType): void;
	_resample(lineSegment: LineSegments): LineSegments<BufferGeometry<NormalBufferAttributes>, Material | Material[]>;
	_create_curve_from_points(points: CorePoint[]): BufferGeometry<NormalBufferAttributes> | undefined;
	_get_points_from_curve(curve: CatmullRomCurve3): Vector3[];
}
declare class RestAttributesSopParamsConfig extends NodeParamsConfig {
	/** @param toggle on to create a rest position */
	tposition: ParamTemplate<ParamType.BOOLEAN>;
	/** @param name of the position attribute */
	position: ParamTemplate<ParamType.STRING>;
	/** @param name of the rest position attribute, on which the position will be copied on */
	restP: ParamTemplate<ParamType.STRING>;
	/** @param toggle on to create a rest normal */
	tnormal: ParamTemplate<ParamType.BOOLEAN>;
	/** @param name of the normal attribute */
	normal: ParamTemplate<ParamType.STRING>;
	/** @param name of the rest normal attribute, on which the normal will be copied on */
	restN: ParamTemplate<ParamType.STRING>;
}
declare class RestAttributesSopNode extends TypedSopNode<RestAttributesSopParamsConfig> {
	paramsConfig: RestAttributesSopParamsConfig;
	static type(): string;
	initializeNode(): void;
	private _operation;
	cook(input_contents: CoreGroup[]): void;
}
declare class RingSopParamsConfig extends NodeParamsConfig {
	/** @param inner radius of the ring */
	innerRadius: ParamTemplate<ParamType.FLOAT>;
	/** @param outer radius of the ring */
	outerRadius: ParamTemplate<ParamType.FLOAT>;
	/** @param segments count */
	thetaSegments: ParamTemplate<ParamType.INTEGER>;
	/** @param segments count */
	phiSegments: ParamTemplate<ParamType.INTEGER>;
	/** @param if set to 1, you can then set the phiStart, phi_end, thetaStart and theta_end */
	open: ParamTemplate<ParamType.BOOLEAN>;
	/** @param start of phi angle */
	angleStart: ParamTemplate<ParamType.FLOAT>;
	/** @param length of phi opening */
	angleLength: ParamTemplate<ParamType.FLOAT>;
	/** @param axis perpendicular to the plane */
	direction: ParamTemplate<ParamType.VECTOR3>;
	/** @param center of the plane */
	center: ParamTemplate<ParamType.VECTOR3>;
}
declare class RingSopNode extends TypedSopNode<RingSopParamsConfig> {
	paramsConfig: RingSopParamsConfig;
	static type(): SopType;
	initializeNode(): void;
	private _operation;
	cook(inputCoreGroups: CoreGroup[]): void;
}
declare class RoundedBoxSopParamsConfig extends NodeParamsConfig {
	/** @param size of the box */
	size: ParamTemplate<ParamType.FLOAT>;
	/** @param size of the box */
	sizes: ParamTemplate<ParamType.VECTOR3>;
	/** @param divisions count */
	divisions: ParamTemplate<ParamType.INTEGER>;
	/** @param bevel size */
	bevel: ParamTemplate<ParamType.FLOAT>;
	/** @param center of the box */
	center: ParamTemplate<ParamType.VECTOR3>;
}
declare class RoundedBoxSopNode extends TypedSopNode<RoundedBoxSopParamsConfig> {
	paramsConfig: RoundedBoxSopParamsConfig;
	static type(): SopType;
	initializeNode(): void;
	private _operation;
	cook(inputCoreGroups: CoreGroup[]): void;
}
declare class ScatterSopParamsConfig extends NodeParamsConfig {
	/** @param number of points to create */
	pointsCount: ParamTemplate<ParamType.INTEGER>;
	/** @param seed */
	seed: ParamTemplate<ParamType.INTEGER>;
	/** @param attribute which will influence the distribution of points */
	useWeightAttribute: ParamTemplate<ParamType.BOOLEAN>;
	/** @param attribute which will influence the distribution of points */
	weightAttribute: ParamTemplate<ParamType.STRING>;
	/** @param toggle on to transfer attribute from the input geometry to the created points */
	transferAttributes: ParamTemplate<ParamType.BOOLEAN>;
	/** @param names of the attributes to transfer */
	attributesToTransfer: ParamTemplate<ParamType.STRING>;
	/** @param add an id attribute, starting at 0, incrementing by 1 for each point (0,1,2,3...) */
	addIdAttribute: ParamTemplate<ParamType.BOOLEAN>;
	/** @param add an idn attribute, which is the id normalized between 0 and 1 */
	addIdnAttribute: ParamTemplate<ParamType.BOOLEAN>;
}
declare class ScatterSopNode extends TypedSopNode<ScatterSopParamsConfig> {
	paramsConfig: ScatterSopParamsConfig;
	static type(): SopType;
	initializeNode(): void;
	private _operation;
	cook(inputCoreGroups: CoreGroup[]): void;
}
declare class JsAssemblerSDF extends BaseJsShaderAssembler {
	makeFunctionNodeDirtyOnChange(): boolean;
	defaultObject3DVariable(): string;
	defaultObject3DMaterialVariable(): string;
	defaultPointIndexVariable(): string;
	templateShader(): {
		main: string;
	};
// @ts-ignore
	spareParamsOptions(options: SpareParamOptions): ParamOptions;
	functionData(): SingleBodyFunctionData | undefined;
	updateFunction(): void;
	add_output_inputs(output_child: OutputJsNode): void;
	add_globals_outputs(globals_node: GlobalsJsNode): void;
	create_shader_configs(): JsShaderConfig[];
	create_variable_configs(): VariableConfig[];
	setNodeLinesOutput(outputNode: OutputJsNode, shadersCollectionController: JsLinesCollectionController): void;
	setNodeLinesGlobals(globalsNode: GlobalsJsNode, shadersCollectionController: JsLinesCollectionController): void;
}
interface SDFPersistedConfigBaseJsData extends PersistedConfigBaseJsData {
	functionBody: string;
	variableNames: string[];
	variables: SerializedVariable<SerializedVariableType>[];
	functionNames: Array<keyof NamedFunctionMap>;
	serializedParamConfigs: JsParamConfigJSON<ParamType>[];
}
declare class SDFPersistedConfig extends BasePersistedConfig {
	protected node: SDFBuilderSopNode;
	constructor(node: SDFBuilderSopNode);
	toData(): Promise<SDFPersistedConfigBaseJsData | undefined>;
	load(data: SDFPersistedConfigBaseJsData): void;
}
declare class SDFBuilderSopParamsConfig extends NodeParamsConfig {
	/** @param stepSize */
	stepSize: ParamTemplate<ParamType.FLOAT>;
	/** @param level */
	level: ParamTemplate<ParamType.FLOAT>;
	/** @param min bound */
	min: ParamTemplate<ParamType.VECTOR3>;
	/** @param max bound */
	max: ParamTemplate<ParamType.VECTOR3>;
	/** @param linear Tolerance */
	facetAngle: ParamTemplate<ParamType.FLOAT>;
	/** @param meshes color */
	meshesColor: ParamTemplate<ParamType.COLOR>;
	/** @param wireframe */
	wireframe: ParamTemplate<ParamType.BOOLEAN>;
}
declare class SDFBuilderSopNode extends TypedSopNode<SDFBuilderSopParamsConfig> {
	paramsConfig: SDFBuilderSopParamsConfig;
	static type(): SopType;
	requiredModules(): ModuleName[];
	readonly persisted_config: SDFPersistedConfig;
	assemblerController(): JsAssemblerController<JsAssemblerSDF> | undefined;
	usedAssembler(): Readonly<AssemblerName.JS_SDF>;
	protected _assemblerController: JsAssemblerController<JsAssemblerSDF> | undefined;
	private _createAssemblerController;
	protected _childrenControllerContext: NodeContext;
	initializeNode(): void;
	createNode<S extends keyof JsNodeChildrenMap>(node_class: S, options?: NodeCreateOptions): JsNodeChildrenMap[S];
	createNode<K extends valueof<JsNodeChildrenMap>>(node_class: Constructor<K>, options?: NodeCreateOptions): K;
	children(): BaseJsNodeType[];
	nodesByType<K extends keyof JsNodeChildrenMap>(type: K): JsNodeChildrenMap[K][];
	childrenAllowed(): boolean;
	sceneReadonly(): boolean;
	cook(inputCoreGroups: CoreGroup[]): Promise<void>;
	compileIfRequired(): void;
	private _position;
	private _paramConfigs;
	private _functionData;
	private _functionCreationArgs;
	private _functionEvalArgs;
	private _function;
	functionData(): SingleBodyFunctionData | undefined;
	compile(): void;
	updateFromFunctionData(functionData: SingleBodyFunctionData): void;
	functionEvalArgsWithParamConfigs(): (number | boolean | Function | RegisterableVariable)[];
}
declare class SetChildrenSopParamsConfig extends NodeParamsConfig {
	clearExistingChildren: ParamTemplate<ParamType.BOOLEAN>;
}
declare class SetChildrenSopNode extends TypedSopNode<SetChildrenSopParamsConfig> {
	paramsConfig: SetChildrenSopParamsConfig;
	static type(): SopType;
	initializeNode(): void;
	private _operation;
	cook(inputCoreGroups: CoreGroup[]): void;
}
declare enum SetGeometryMode {
	ONE_GEO_PER_OBJECT = "One Geometry Per Object",
	FIRST_GEO_TO_EACH_OBJECT = "First Geometry To Each Object"
}
declare class SetGeometrySopParamsConfig extends NodeParamsConfig {
	mode: ParamTemplate<ParamType.INTEGER>;
}
declare class SetGeometrySopNode extends TypedSopNode<SetGeometrySopParamsConfig> {
	paramsConfig: SetGeometrySopParamsConfig;
	static type(): SopType;
	initializeNode(): void;
	setMode(mode: SetGeometryMode): void;
	private _operation;
	cook(inputCoreGroups: CoreGroup[]): void;
}
declare enum ShearMode {
	MATRIX = "matrix",
	AXIS = "axis"
}
declare class ShearSopParamConfig extends NodeParamsConfig {
	/** @param mode */
	mode: ParamTemplate<ParamType.INTEGER>;
	/** @param matrixMode XY */
	xy: ParamTemplate<ParamType.FLOAT>;
	/** @param matrixMode XZ */
	xz: ParamTemplate<ParamType.FLOAT>;
	/** @param matrixMode YX */
	yx: ParamTemplate<ParamType.FLOAT>;
	/** @param matrixMode YZ */
	yz: ParamTemplate<ParamType.FLOAT>;
	/** @param matrixMode ZX */
	zx: ParamTemplate<ParamType.FLOAT>;
	/** @param matrixMode ZY */
	zy: ParamTemplate<ParamType.FLOAT>;
	/** @param centerMode defines how the center of the shear in axis mode is computed */
	centerMode: ParamTemplate<ParamType.INTEGER>;
	/** @param centerOffset */
	centerOffset: ParamTemplate<ParamType.VECTOR3>;
	/** @param center */
	center: ParamTemplate<ParamType.VECTOR3>;
	/** @param PlaneAxis */
	planeAxis: ParamTemplate<ParamType.VECTOR3>;
	/** @param axis */
	axis: ParamTemplate<ParamType.VECTOR3>;
	/** @param axisAmount */
	axisAmount: ParamTemplate<ParamType.FLOAT>;
}
declare class ShearSopNode extends TypedSopNode<ShearSopParamConfig> {
	paramsConfig: ShearSopParamConfig;
	static type(): SopType;
	initializeNode(): void;
	setMode(mode: ShearMode): void;
	private _operation;
	cook(input_contents: CoreGroup[]): void;
}
declare class ShortestPathSopParamsConfig extends NodeParamsConfig {
	/** @param objects to find paths in */
	group: ParamTemplate<ParamType.STRING>;
	/** @param index of start point */
	pt0: ParamTemplate<ParamType.INTEGER>;
	/** @param index of end point */
	pt1: ParamTemplate<ParamType.INTEGER>;
}
declare class ShortestPathSopNode extends TypedSopNode<ShortestPathSopParamsConfig> {
	paramsConfig: ShortestPathSopParamsConfig;
	static type(): SopType;
	initializeNode(): void;
	cook(inputCoreGroups: CoreGroup[]): void;
	private _createShortestPath;
	private _buildLine;
}
declare class SkeletonHelperSopParamsConfig extends NodeParamsConfig {
}
declare class SkeletonHelperSopNode extends TypedSopNode<SkeletonHelperSopParamsConfig> {
	paramsConfig: SkeletonHelperSopParamsConfig;
	static type(): SopType;
	initializeNode(): void;
	cook(inputCoreGroups: CoreGroup[]): void;
}
declare class SkinSopParamsConfig extends NodeParamsConfig {
}
declare class SkinSopNode extends TypedSopNode<SkinSopParamsConfig> {
	paramsConfig: SkinSopParamsConfig;
	static type(): SopType;
	initializeNode(): void;
	cook(inputCoreGroups: CoreGroup[]): void;
	process_one_input(input_contents: CoreGroup[]): void;
	process_two_inputs(input_contents: CoreGroup[]): void;
	_getLineSegments(core_group: CoreGroup): Object3D<Event>[];
	_skin(geometry1: BufferGeometry, geometry0: BufferGeometry): BufferGeometry<NormalBufferAttributes>;
}
declare enum SortMode {
	RANDOM = "random",
	AXIS = "axis",
	ATTRIBUTE = "attribute"
}
type SortTargetType = AttribClass.POINT | AttribClass.OBJECT;
declare class SortSopParamsConfig extends NodeParamsConfig {
	/** @param defines if this node will sort points or objects */
	targetType: ParamTemplate<ParamType.INTEGER>;
	/** @param criteria used to sort */
	mode: ParamTemplate<ParamType.INTEGER>;
	/** @param seed used by the random mode */
	seed: ParamTemplate<ParamType.INTEGER>;
	/** @param axis along which points will be sorted */
	axis: ParamTemplate<ParamType.INTEGER>;
	/** @param attribute */
	attribute: ParamTemplate<ParamType.STRING>;
	/** @param invert the sort */
	invert: ParamTemplate<ParamType.BOOLEAN>;
}
declare class SortSopNode extends TypedSopNode<SortSopParamsConfig> {
	paramsConfig: SortSopParamsConfig;
	static type(): SopType;
	initializeNode(): void;
	private _operation;
	cook(inputCoreGroups: CoreGroup[]): void;
	setAttribClass(attribClass: SortTargetType): void;
	attribClass(): SortTargetType;
	setSortMode(mode: SortMode): void;
	setTargetType(targetType: AttribClass.POINT | AttribClass.OBJECT): void;
}
declare class SolverIterationStamp extends CoreGraphNode {
	protected _iteration: number;
	constructor(scene: PolyScene);
	reset(): void;
	setIteration(iteration: number): void;
	iteration(): number;
}
declare class SolverSopParamsConfig extends NodeParamsConfig {
	/** @param number of times the nodes inside this node will process the input */
	iterations: ParamTemplate<ParamType.INTEGER>;
	/** @param Currently, when the child nodes are updated, the solver node does not know that it should recook. Clicking this button forces it to recompute */
	reload: ParamTemplate<ParamType.BUTTON>;
}
declare class SolverSopNode extends SubnetSopNodeLike<SolverSopParamsConfig> {
	paramsConfig: SolverSopParamsConfig;
	static type(): NetworkNodeType;
	private _iterationStamp;
	readonly childrenDisplayController: SopSubnetChildrenDisplayController;
	readonly displayNodeController: DisplayNodeController;
	initializeNode(): void;
	iterationStamp(): SolverIterationStamp;
	private _createStampNode;
	private _previousFrameCoreGroup;
	previousFrameCoreGroup(): CoreGroup | undefined;
	cook(inputCoreGroups: CoreGroup[]): Promise<void>;
	private _reset;
	private _computeSolverMultipleTimes;
	private computeSolver;
	static PARAM_CALLBACK_reload(node: SolverSopNode): void;
	private param_callback_reload;
}
declare class SolverPreviousFrameSopParamsConfig extends NodeParamsConfig {
}
declare class SolverPreviousFrameSopNode extends TypedSopNode<SolverPreviousFrameSopParamsConfig> {
	paramsConfig: SolverPreviousFrameSopParamsConfig;
	static type(): string;
	cook(): void;
	private _solverNodeDependencyCreated;
	private _createSolverNodeDependencyIfRequired;
	private _solverNode;
}
declare class SphereSopParamsConfig extends NodeParamsConfig {
	/** @param type of sphere (default sphere or isocahedron) */
	type: ParamTemplate<ParamType.INTEGER>;
	/** @param radius of the sphere when the type is default */
	radius: ParamTemplate<ParamType.FLOAT>;
	/** @param resolution - number of segments in x and y */
	resolution: ParamTemplate<ParamType.VECTOR2>;
	/** @param if set to 1, you can then set the phiStart, phi_end, thetaStart and theta_end */
	open: ParamTemplate<ParamType.BOOLEAN>;
	/** @param start of phi angle */
	phiStart: ParamTemplate<ParamType.FLOAT>;
	/** @param length of phi opening */
	phiLength: ParamTemplate<ParamType.FLOAT>;
	/** @param start of theta angle */
	thetaStart: ParamTemplate<ParamType.FLOAT>;
	/** @param length of theta opening */
	thetaLength: ParamTemplate<ParamType.FLOAT>;
	/** @param resolution of the sphere when the type is isocahedron */
	detail: ParamTemplate<ParamType.INTEGER>;
	/** @param center of the sphere */
	center: ParamTemplate<ParamType.VECTOR3>;
	/** @param create lines instead of polygons */
	asLines: ParamTemplate<ParamType.BOOLEAN>;
}
declare class SphereSopNode extends TypedSopNode<SphereSopParamsConfig> {
	paramsConfig: SphereSopParamsConfig;
	static type(): SopType;
	initializeNode(): void;
	private _operation;
	cook(input_contents: CoreGroup[]): void;
}
declare class SplitSopParamsConfig extends NodeParamsConfig {
	/** @param type of attribute to use */
	attribType: ParamTemplate<ParamType.INTEGER>;
	/** @param name of the attribute */
	attribName: ParamTemplate<ParamType.STRING>;
}
declare class SplitSopNode extends TypedSopNode<SplitSopParamsConfig> {
	paramsConfig: SplitSopParamsConfig;
	static type(): SopType;
	initializeNode(): void;
	private _new_objects;
	cook(input_contents: CoreGroup[]): void;
	_split_core_group(core_group: CoreGroup): void;
	private _split_core_object;
}
declare const SpotLightSopParamsConfig_base: {
	new (...args: any[]): {
		light: ParamTemplate<ParamType.FOLDER>;
		color: ParamTemplate<ParamType.COLOR>;
		intensity: ParamTemplate<ParamType.FLOAT>;
		angle: ParamTemplate<ParamType.FLOAT>;
		penumbra: ParamTemplate<ParamType.FLOAT>;
		decay: ParamTemplate<ParamType.FLOAT>;
		distance: ParamTemplate<ParamType.FLOAT>;
		showHelper: ParamTemplate<ParamType.BOOLEAN>;
		helperSize: ParamTemplate<ParamType.FLOAT>;
		tmap: ParamTemplate<ParamType.BOOLEAN>;
		map: ParamTemplate<ParamType.NODE_PATH>;
		name: ParamTemplate<ParamType.STRING>;
		shadow: ParamTemplate<ParamType.FOLDER>;
		castShadow: ParamTemplate<ParamType.BOOLEAN>;
		shadowAutoUpdate: ParamTemplate<ParamType.BOOLEAN>;
		shadowUpdateOnNextRender: ParamTemplate<ParamType.BOOLEAN>;
		shadowRes: ParamTemplate<ParamType.VECTOR2>;
		shadowBias: ParamTemplate<ParamType.FLOAT>;
		shadowNear: ParamTemplate<ParamType.FLOAT>;
		shadowFar: ParamTemplate<ParamType.FLOAT>;
		shadowRadius: ParamTemplate<ParamType.FLOAT>;
		volumetric: ParamTemplate<ParamType.FOLDER>;
		tvolumetric: ParamTemplate<ParamType.BOOLEAN>;
		volAttenuation: ParamTemplate<ParamType.FLOAT>;
		volAnglePower: ParamTemplate<ParamType.FLOAT>;
		raymarching: ParamTemplate<ParamType.FOLDER>;
		raymarchingPenumbra: ParamTemplate<ParamType.FLOAT>;
		raymarchingShadowBiasAngle: ParamTemplate<ParamType.FLOAT>;
		raymarchingShadowBiasDistance: ParamTemplate<ParamType.FLOAT>;
	};
} & typeof NodeParamsConfig;
declare class SpotLightSopParamsConfig extends SpotLightSopParamsConfig_base {
}
declare class SpotLightSopNode extends TypedSopNode<SpotLightSopParamsConfig> {
	paramsConfig: SpotLightSopParamsConfig;
	static type(): LightType;
	initializeNode(): void;
	private _operation;
	cook(inputCoreGroups: CoreGroup[]): Promise<void>;
}
declare class SubdivideSopParamsConfig extends NodeParamsConfig {
	/** @param number of subdivisions */
	subdivisions: ParamTemplate<ParamType.INTEGER>;
	/** @param merge vertices */
	mergeVertices: ParamTemplate<ParamType.BOOLEAN>;
}
declare class SubdivideSopNode extends TypedSopNode<SubdivideSopParamsConfig> {
	paramsConfig: SubdivideSopParamsConfig;
	static type(): SopType;
	initializeNode(): void;
	private _operation;
	cook(input_contents: CoreGroup[]): void;
}
declare class SubnetSopParamsConfig extends NodeParamsConfig {
}
declare class SubnetSopNode extends SubnetSopNodeLike<SubnetSopParamsConfig> {
	paramsConfig: SubnetSopParamsConfig;
	static type(): NetworkNodeType;
	initializeNode(): void;
}
declare class SubnetInputSopParamsConfig extends NodeParamsConfig {
	/** @param sets which input of the parent subnet node is used */
	input: ParamTemplate<ParamType.INTEGER>;
}
declare class SubnetInputSopNode extends TypedSopNode<SubnetInputSopParamsConfig> {
	paramsConfig: SubnetInputSopParamsConfig;
	static type(): NetworkChildNodeType;
	private _currentParentInputGraphNode;
	initializeNode(): void;
	cook(): Promise<void>;
	static PARAM_CALLBACK_reset(node: SubnetInputSopNode): void;
	private _setParentInputDependency;
}
declare class SwitchSopParamsConfig extends NodeParamsConfig {
	/** @param sets which input is used */
	input: ParamTemplate<ParamType.INTEGER>;
	/** @param number of inputs that this node can merge geometries from */
	inputsCount: ParamTemplate<ParamType.INTEGER>;
}
declare class SwitchSopNode extends TypedSopNode<SwitchSopParamsConfig> {
	paramsConfig: SwitchSopParamsConfig;
	static type(): SopType;
	initializeNode(): void;
	cook(): Promise<void>;
	private _callbackUpdateInputsEvaluation;
	static PARAM_CALLBACK_setInputsEvaluation(node: SwitchSopNode): void;
	private _callbackUpdateInputsCount;
	static PARAM_CALLBACK_setInputsCount(node: SwitchSopNode): void;
}
declare enum TangentMode {
	MESH = "Normal Maps",
	CURVE = "Curve"
}
declare class TangentSopParamsConfig extends NodeParamsConfig {
	/** @param select which objects this applies the actor behavior to */
	group: ParamTemplate<ParamType.STRING>;
	/** @param mode */
	mode: ParamTemplate<ParamType.INTEGER>;
	/** @param closed */
	closed: ParamTemplate<ParamType.BOOLEAN>;
	/** @param tangent attribute name */
	tangentName: ParamTemplate<ParamType.STRING>;
}
declare class TangentSopNode extends TypedSopNode<TangentSopParamsConfig> {
	readonly paramsConfig: TangentSopParamsConfig;
	static type(): SopType;
	protected initializeNode(): void;
	private _operation;
	cook(inputCoreGroups: CoreGroup[]): void;
	setMode(mode: TangentMode): void;
}
declare class TangentsHelperSopParamsConfig extends NodeParamsConfig {
	/** @param group to assign the material to */
	group: ParamTemplate<ParamType.STRING>;
	/** @param keep input */
	keepInput: ParamTemplate<ParamType.BOOLEAN>;
	/** @param size of the box */
	size: ParamTemplate<ParamType.FLOAT>;
}
declare class TangentsHelperSopNode extends TypedSopNode<TangentsHelperSopParamsConfig> {
	paramsConfig: TangentsHelperSopParamsConfig;
	static type(): SopType;
	initializeNode(): void;
	cook(inputCoreGroups: CoreGroup[]): void;
}
declare class TetSopNode<K extends NodeParamsConfig> extends TypedSopNode<K> {
	dataType(): string;
	requiredModules(): ModuleName[];
	setTetGeometry(geometry: TetGeometry): void;
	setTetGeometries(geometries: TetGeometry[]): void;
	setTetObjects(tetObjects: TetObject[]): void;
	setTetObject(tetObject: TetObject): void;
	protected _setContainerTetObjects(objects: TetObject[]): void;
}
declare class TetDeleteSopParamsConfig extends NodeParamsConfig {
	byQuality: ParamTemplate<ParamType.BOOLEAN>;
	minQuality: ParamTemplate<ParamType.FLOAT>;
	byIds: ParamTemplate<ParamType.BOOLEAN>;
	ids: ParamTemplate<ParamType.STRING>;
	byIndex: ParamTemplate<ParamType.BOOLEAN>;
	index: ParamTemplate<ParamType.INTEGER>;
	byIndexRange: ParamTemplate<ParamType.BOOLEAN>;
	indexRangeStart: ParamTemplate<ParamType.INTEGER>;
	indexRangeEnd: ParamTemplate<ParamType.INTEGER>;
	byDelaunay: ParamTemplate<ParamType.BOOLEAN>;
	byBoundingObject: ParamTemplate<ParamType.BOOLEAN>;
	invert: ParamTemplate<ParamType.BOOLEAN>;
}
declare class TetDeleteSopNode extends TetSopNode<TetDeleteSopParamsConfig> {
	readonly paramsConfig: TetDeleteSopParamsConfig;
	static type(): SopType;
	protected initializeNode(): void;
	cook(inputCoreGroups: CoreGroup[]): Promise<void>;
	_deleteTets(tetObject: TetObject, inputCoreGroups: CoreGroup[]): void;
	private _findTetsByQuality;
	private _findTetsById;
	private _findTetsByIndex;
	private _findTetsByIndexRange;
	private _findTetsByDelaunay;
	private _findTetsByBoundingObject;
}
declare class TetEmbedSopParamsConfig extends NodeParamsConfig {
	/** @param highRes Skinning Lookup Spacing */
	spacing: ParamTemplate<ParamType.FLOAT>;
	/** @param highRes Skinning Lookup Padding */
	padding: ParamTemplate<ParamType.FLOAT>;
}
declare class TetEmbedSopNode extends TetSopNode<TetEmbedSopParamsConfig> {
	readonly paramsConfig: TetEmbedSopParamsConfig;
	static type(): SopType;
	protected initializeNode(): void;
	cook(inputCoreGroups: CoreGroup[]): Promise<void>;
}
interface SoftBodyPersistedConfigBaseJsData extends PersistedConfigBaseJsData {
	functionBody: VelocityColliderFunctionBody;
	variableNames: string[];
	variables: SerializedVariable<SerializedVariableType>[];
	functionNames: Array<keyof NamedFunctionMap>;
	serializedParamConfigs: JsParamConfigJSON<ParamType>[];
}
declare class SoftBodyPersistedConfig extends BasePersistedConfig {
	protected node: TetSoftBodySolverSopNode;
	constructor(node: TetSoftBodySolverSopNode);
	toData(): Promise<SoftBodyPersistedConfigBaseJsData | undefined>;
	load(data: SoftBodyPersistedConfigBaseJsData): void;
}
declare class JsAssemblerSoftBody extends BaseJsShaderAssembler {
	makeFunctionNodeDirtyOnChange(): boolean;
	defaultObject3DVariable(): string;
	defaultObject3DMaterialVariable(): string;
	defaultPointIndexVariable(): string;
	templateShader(): {
		velocity: string;
		collider: string;
	};
// @ts-ignore
	spareParamsOptions(options: SpareParamOptions): ParamOptions;
	functionData(): VelocityColliderFunctionData | undefined;
	updateFunction(): void;
	add_output_inputs(output_child: OutputJsNode): void;
	add_globals_outputs(globals_node: GlobalsJsNode): void;
	create_shader_configs(): JsShaderConfig[];
	create_variable_configs(): VariableConfig[];
	setNodeLinesOutput(outputNode: OutputJsNode, linesController: JsLinesCollectionController): void;
	setNodeLinesGlobals(globalsNode: GlobalsJsNode, shadersCollectionController: JsLinesCollectionController): void;
}
type VelocityFunction = () => Vector3;
type SDFFunction = () => number;
type FunctionArg = number | boolean | Function | RegisterableVariable;
type SoftBodyVelocityEvaluatorFunction = (...args: FunctionArg[]) => VelocityFunction;
type SoftBodyColliderEvaluatorFunction = (...args: FunctionArg[]) => SDFFunction;
interface MultiFunctionPartial {
	velocity: SoftBodyVelocityEvaluatorFunction | undefined;
	collider: SoftBodyColliderEvaluatorFunction | undefined;
}
interface EvalArgsWithParamConfigs {
	velocity: FunctionArg[];
	collider: FunctionArg[];
}
declare class TetSoftBodySolverSopParamsConfig extends NodeParamsConfig {
}
declare class TetSoftBodySolverSopNode extends TetSopNode<TetSoftBodySolverSopParamsConfig> {
	readonly paramsConfig: TetSoftBodySolverSopParamsConfig;
	static type(): SopType.TET_SOFT_BODY_SOLVER;
	private _nextId;
	private _tetEmbedByThreejsObjectEphemeralId;
	readonly persisted_config: SoftBodyPersistedConfig;
	assemblerController(): JsAssemblerController<JsAssemblerSoftBody> | undefined;
	usedAssembler(): Readonly<AssemblerName.JS_SOFT_BODY>;
	protected _assemblerController: JsAssemblerController<JsAssemblerSoftBody> | undefined;
	private _createAssemblerController;
	protected _childrenControllerContext: NodeContext;
	protected initializeNode(): void;
	createNode<S extends keyof JsNodeChildrenMap>(node_class: S, options?: NodeCreateOptions): JsNodeChildrenMap[S];
	createNode<K extends valueof<JsNodeChildrenMap>>(node_class: Constructor<K>, options?: NodeCreateOptions): K;
	children(): BaseJsNodeType[];
	nodesByType<K extends keyof JsNodeChildrenMap>(type: K): JsNodeChildrenMap[K][];
	childrenAllowed(): boolean;
	sceneReadonly(): boolean;
	cook(inputCoreGroups: CoreGroup[]): Promise<void>;
	private _highResObject;
	updateObjectOnAdd(object: Object3D, parent: Object3D): void;
	compileIfRequired(): void;
	private _evaluationGlobals;
	private _paramConfigs;
	private _functionData;
	private _functionCreationArgs;
	private _functionEvalArgs;
	private _function;
	private _functionArgsWithParams;
	updateSceneGlobals(stepsCount: number, dt: number): void;
	setPositionGlobals(position: Vector3): void;
	setPointGlobals(position: Vector3, velocity: Vector3): void;
	function(): MultiFunctionPartial;
	functionData(): VelocityColliderFunctionData | undefined;
	compile(): void;
	updateFromFunctionData(functionData: VelocityColliderFunctionData): void;
	functionEvalArgsWithParamConfigs(): EvalArgsWithParamConfigs;
}
declare const TetTriangulateSopParamsConfig_base: {
	new (...args: any[]): {
		scale: ParamTemplate<ParamType.FLOAT>;
		displayOuterMesh: ParamTemplate<ParamType.BOOLEAN>;
		displayTetMesh: ParamTemplate<ParamType.BOOLEAN>;
		displayLines: ParamTemplate<ParamType.BOOLEAN>;
		displaySharedFaces: ParamTemplate<ParamType.BOOLEAN>;
		displayPoints: ParamTemplate<ParamType.BOOLEAN>;
		displayCenter: ParamTemplate<ParamType.BOOLEAN>;
		displaySphere: ParamTemplate<ParamType.BOOLEAN>;
	};
} & typeof NodeParamsConfig;
declare class TetTriangulateSopParamsConfig extends TetTriangulateSopParamsConfig_base {
}
declare class TetTriangulateSopNode extends TetSopNode<TetTriangulateSopParamsConfig> {
	readonly paramsConfig: TetTriangulateSopParamsConfig;
	static type(): SopType;
	protected initializeNode(): void;
	cook(inputCoreGroups: CoreGroup[]): Promise<void>;
}
declare class TetrahedralizeSopParamsConfig extends NodeParamsConfig {
	fuseDist: ParamTemplate<ParamType.FLOAT>;
	jitter: ParamTemplate<ParamType.FLOAT>;
	innerPointsResolution: ParamTemplate<ParamType.INTEGER>;
	minQuality: ParamTemplate<ParamType.FLOAT>;
	stepByStep: ParamTemplate<ParamType.BOOLEAN>;
	step: ParamTemplate<ParamType.INTEGER>;
	deleteOutsideTets: ParamTemplate<ParamType.BOOLEAN>;
}
declare class TetrahedralizeSopNode extends TetSopNode<TetrahedralizeSopParamsConfig> {
	paramsConfig: TetrahedralizeSopParamsConfig;
	static type(): SopType;
	initializeNode(): void;
	cook(inputCoreGroups: CoreGroup[]): void;
}
declare class TetrahedronSopParamsConfig extends NodeParamsConfig {
	/** @param radius of the tetrahedron */
	radius: ParamTemplate<ParamType.FLOAT>;
	/** @param resolution of the tetrahedron */
	detail: ParamTemplate<ParamType.INTEGER>;
	/** @param sets to create only points */
	pointsOnly: ParamTemplate<ParamType.BOOLEAN>;
	/** @param center of the tetrahedron */
	center: ParamTemplate<ParamType.VECTOR3>;
}
declare class TetrahedronSopNode extends TypedSopNode<TetrahedronSopParamsConfig> {
	paramsConfig: TetrahedronSopParamsConfig;
	static type(): SopType;
	cook(): void;
}
declare enum TextType {
	MESH = "mesh",
	FLAT = "flat",
	LINE = "line",
	STROKE = "stroke"
}
declare class TextSopParamsConfig extends NodeParamsConfig {
	/** @param font used */
	font: ParamTemplate<ParamType.STRING>;
	/** @param text created */
	text: ParamTemplate<ParamType.STRING>;
	/** @param type of geometry created */
	type: ParamTemplate<ParamType.INTEGER>;
	/** @param font size */
	size: ParamTemplate<ParamType.FLOAT>;
	/** @param extrude depth */
	extrude: ParamTemplate<ParamType.FLOAT>;
	/** @param segments count */
	segments: ParamTemplate<ParamType.INTEGER>;
	/** @param bevelEnabled */
	bevelEnabled: ParamTemplate<ParamType.BOOLEAN>;
	/** @param bevelThickness */
	bevelThickness: ParamTemplate<ParamType.FLOAT>;
	/** @param bevelSize */
	bevelSize: ParamTemplate<ParamType.FLOAT>;
	/** @param bevelOffset */
	bevelOffset: ParamTemplate<ParamType.FLOAT>;
	/** @param bevelSegments */
	bevelSegments: ParamTemplate<ParamType.INTEGER>;
	/** @param stroke width */
	strokeWidth: ParamTemplate<ParamType.FLOAT>;
	/** @param line height */
	lineHeight: ParamTemplate<ParamType.FLOAT>;
	/** @param create one object per letter */
	splitPerLetter: ParamTemplate<ParamType.BOOLEAN>;
	/** @param when creating one object per letter, define if the characters like space create an object */
	keepEmptyGeometries: ParamTemplate<ParamType.BOOLEAN>;
	/** @param justify mode */
	justifyMode: ParamTemplate<ParamType.INTEGER>;
	/** @param open advanced options */
	tadvanced: ParamTemplate<ParamType.BOOLEAN>;
	/** @param is counter clock wise: defines the vertex order when parsing the font */
	isCCW: ParamTemplate<ParamType.BOOLEAN>;
}
declare class TextSopNode extends TypedSopNode<TextSopParamsConfig> {
	paramsConfig: TextSopParamsConfig;
	static type(): SopType;
	dispose(): void;
	setTextType(type: TextType): void;
	private _loadedFonts;
	cook(): Promise<void>;
}
declare class TextureCopySopParamsConfig extends NodeParamsConfig {
	textureName: ParamTemplate<ParamType.STRING>;
}
declare class TextureCopySopNode extends TypedSopNode<TextureCopySopParamsConfig> {
	paramsConfig: TextureCopySopParamsConfig;
	static type(): SopType;
	initializeNode(): void;
	private _operation;
	cook(input_contents: CoreGroup[]): Promise<void>;
}
declare class TexturePropertiesSopParamsConfig extends NodeParamsConfig {
	/** @param group to assign the material to */
	group: ParamTemplate<ParamType.STRING>;
	/** @param toggle on to allow updating the texture color space */
	tcolorSpace: ParamTemplate<ParamType.BOOLEAN>;
	/** @param sets the texture encoding */
	colorSpace: ParamTemplate<ParamType.STRING>;
	/** @param toggle on to allow updating the texture mapping */
	tmapping: ParamTemplate<ParamType.BOOLEAN>;
	/** @param sets the texture mapping */
	mapping: ParamTemplate<ParamType.INTEGER>;
	/** @param toggle on to allow updating the texture wrap */
	twrap: ParamTemplate<ParamType.BOOLEAN>;
	/** @param sets the texture wrapS */
	wrapS: ParamTemplate<ParamType.INTEGER>;
	/** @param sets the texture wrapT */
	wrapT: ParamTemplate<ParamType.INTEGER>;
	/** @param toggle on to update the anisotropy */
	tanisotropy: ParamTemplate<ParamType.BOOLEAN>;
	/** @param sets if the anisotropy should be set to the max capabilities of the renderer */
	useRendererMaxAnisotropy: ParamTemplate<ParamType.BOOLEAN>;
	/** @param anisotropy value */
	anisotropy: ParamTemplate<ParamType.INTEGER>;
	/** @param toggle on to update min filter */
	tminFilter: ParamTemplate<ParamType.BOOLEAN>;
	/** @param min filter value */
	minFilter: ParamTemplate<ParamType.INTEGER>;
	/** @param toggle on to update mag filter */
	tmagFilter: ParamTemplate<ParamType.BOOLEAN>;
	/** @param mag filter value */
	magFilter: ParamTemplate<ParamType.INTEGER>;
}
declare class TexturePropertiesSopNode extends TypedSopNode<TexturePropertiesSopParamsConfig> {
	paramsConfig: TexturePropertiesSopParamsConfig;
	static type(): SopType;
	initializeNode(): void;
	private _operation;
	cook(inputCoreGroups: CoreGroup[]): Promise<void>;
}
declare class TorusSopParamsConfig extends NodeParamsConfig {
	/** @param large radius */
	radius: ParamTemplate<ParamType.FLOAT>;
	/** @param radius of the tube */
	radiusTube: ParamTemplate<ParamType.FLOAT>;
	/** @param number of segments along the length of the torus */
	segmentsRadial: ParamTemplate<ParamType.INTEGER>;
	/** @param number of segments along the tube */
	segmentsTube: ParamTemplate<ParamType.INTEGER>;
	/** @param open */
	open: ParamTemplate<ParamType.BOOLEAN>;
	/** @param arc */
	arc: ParamTemplate<ParamType.FLOAT>;
	/** @param create caps */
	cap: ParamTemplate<ParamType.BOOLEAN>;
	/** @param axis perpendicular to the torus */
	direction: ParamTemplate<ParamType.VECTOR3>;
	/** @param center of the torus */
	center: ParamTemplate<ParamType.VECTOR3>;
}
declare class TorusSopNode extends TypedSopNode<TorusSopParamsConfig> {
	paramsConfig: TorusSopParamsConfig;
	static type(): SopType;
	private _operation;
	cook(input_contents: CoreGroup[]): void;
}
declare class TorusKnotSopParamsConfig extends NodeParamsConfig {
	/** @param large radius */
	radius: ParamTemplate<ParamType.FLOAT>;
	/** @param radius of the tube */
	radiusTube: ParamTemplate<ParamType.FLOAT>;
	/** @param number of segments along the length of the torus */
	segmentsRadial: ParamTemplate<ParamType.INTEGER>;
	/** @param number of segments along the tube */
	segmentsTube: ParamTemplate<ParamType.INTEGER>;
	/** @param change this to create more interesting shapes. Don't ask me what it is exactly, I don't know! */
	p: ParamTemplate<ParamType.INTEGER>;
	/** @param change this to create more interesting shapes. Don't ask me what it is exactly, I don't know! */
	q: ParamTemplate<ParamType.INTEGER>;
	/** @param center of the torus knot */
	center: ParamTemplate<ParamType.VECTOR3>;
}
declare class TorusKnotSopNode extends TypedSopNode<TorusKnotSopParamsConfig> {
	paramsConfig: TorusKnotSopParamsConfig;
	static type(): SopType;
	initializeNode(): void;
	private _operation;
	cook(input_contents: CoreGroup[]): void;
}
declare const TrackingLandmarksFaceSopParamsConfig_base: {
	new (...args: any[]): {
		selfieMode: ParamTemplate<ParamType.BOOLEAN>;
		maxNumFaces: ParamTemplate<ParamType.INTEGER>;
		refineLandmarks: ParamTemplate<ParamType.BOOLEAN>;
		minDetectionConfidence: ParamTemplate<ParamType.FLOAT>;
		minTrackingConfidence: ParamTemplate<ParamType.FLOAT>;
	};
} & typeof NodeParamsConfig;
declare class TrackingLandmarksFaceSopParamsConfig extends TrackingLandmarksFaceSopParamsConfig_base {
}
declare class TrackingLandmarksFaceSopNode extends TypedSopNode<TrackingLandmarksFaceSopParamsConfig> {
	paramsConfig: TrackingLandmarksFaceSopParamsConfig;
	static type(): string;
	private _uv;
	cook(): void;
}
declare const TrackingLandmarksFaceAttributesSopParamsConfig_base: {
	new (...args: any[]): {
		selfieMode: ParamTemplate<ParamType.BOOLEAN>;
		maxNumFaces: ParamTemplate<ParamType.INTEGER>;
		refineLandmarks: ParamTemplate<ParamType.BOOLEAN>;
		minDetectionConfidence: ParamTemplate<ParamType.FLOAT>;
		minTrackingConfidence: ParamTemplate<ParamType.FLOAT>;
	};
} & typeof NodeParamsConfig;
declare class TrackingLandmarksFaceAttributesSopParamsConfig extends TrackingLandmarksFaceAttributesSopParamsConfig_base {
}
declare class TrackingLandmarksFaceAttributesSopNode extends TypedSopNode<TrackingLandmarksFaceAttributesSopParamsConfig> {
	paramsConfig: TrackingLandmarksFaceAttributesSopParamsConfig;
	static type(): string;
	initializeNode(): void;
	cook(inputCoreGroups: CoreGroup[]): void;
}
declare const TrackingLandmarksHandSopParamsConfig_base: {
	new (...args: any[]): {
		selfieMode: ParamTemplate<ParamType.BOOLEAN>;
		maxNumHands: ParamTemplate<ParamType.INTEGER>;
		modelComplexity: ParamTemplate<ParamType.BOOLEAN>;
		minDetectionConfidence: ParamTemplate<ParamType.FLOAT>;
		minTrackingConfidence: ParamTemplate<ParamType.FLOAT>;
	};
} & typeof NodeParamsConfig;
declare class TrackingLandmarksHandSopParamsConfig extends TrackingLandmarksHandSopParamsConfig_base {
}
declare class TrackingLandmarksHandSopNode extends TypedSopNode<TrackingLandmarksHandSopParamsConfig> {
	paramsConfig: TrackingLandmarksHandSopParamsConfig;
	static type(): string;
	cook(): void;
}
declare const TrackingLandmarksHandAttributesSopParamsConfig_base: {
	new (...args: any[]): {
		selfieMode: ParamTemplate<ParamType.BOOLEAN>;
		maxNumHands: ParamTemplate<ParamType.INTEGER>;
		modelComplexity: ParamTemplate<ParamType.BOOLEAN>;
		minDetectionConfidence: ParamTemplate<ParamType.FLOAT>;
		minTrackingConfidence: ParamTemplate<ParamType.FLOAT>;
	};
} & typeof NodeParamsConfig;
declare class TrackingLandmarksHandAttributesSopParamsConfig extends TrackingLandmarksHandAttributesSopParamsConfig_base {
}
declare class TrackingLandmarksHandAttributesSopNode extends TypedSopNode<TrackingLandmarksHandAttributesSopParamsConfig> {
	paramsConfig: TrackingLandmarksHandAttributesSopParamsConfig;
	static type(): string;
	initializeNode(): void;
	cook(inputCoreGroups: CoreGroup[]): void;
}
declare class TransformSopParamConfig extends NodeParamsConfig {
	/** @param sets if this node should transform objects or geometries */
	applyOn: ParamTemplate<ParamType.INTEGER>;
	/** @param group to assign the material to */
	group: ParamTemplate<ParamType.STRING>;
	/** @param if applyOn is set to object, the transform can then be applied in 2 different ways on those objects. Either the .position, .rotation and .scale attributes are set, or the matrix is set directly. */
	objectMode: ParamTemplate<ParamType.INTEGER>;
	/** @param defines how the objects are transformed */
	objectTransformSpace: ParamTemplate<ParamType.INTEGER>;
	/** @param group to assign the material to */
	pointGroup: ParamTemplate<ParamType.STRING>;
	/** @param rotation order */
	rotationOrder: ParamTemplate<ParamType.INTEGER>;
	/** @param translate */
	t: ParamTemplate<ParamType.VECTOR3>;
	/** @param rotation */
	r: ParamTemplate<ParamType.VECTOR3>;
	/** @param scale */
	s: ParamTemplate<ParamType.VECTOR3>;
	/** @param scale (as a float) */
	scale: ParamTemplate<ParamType.FLOAT>;
	/** @param pivot */
	pivot: ParamTemplate<ParamType.VECTOR3>;
}
declare class TransformSopNode extends TypedSopNode<TransformSopParamConfig> {
	paramsConfig: TransformSopParamConfig;
	static type(): SopType;
	initializeNode(): void;
	setApplyOn(type: TransformTargetType): void;
	applyOn(): TransformTargetType;
	setObjectMode(mode: ObjectTransformMode): void;
	private _operation;
	cook(inputCoreGroups: CoreGroup[]): void;
}
declare class TransformCopySopParamConfig extends NodeParamsConfig {
	/** @param toggle on if the second input should be used */
	useSecondInput: ParamTemplate<ParamType.BOOLEAN>;
	/** @param use a reference object */
	reference: ParamTemplate<ParamType.NODE_PATH>;
}
declare class TransformCopySopNode extends TypedSopNode<TransformCopySopParamConfig> {
	paramsConfig: TransformCopySopParamConfig;
	static type(): SopType;
	initializeNode(): void;
	cook(input_contents: CoreGroup[]): void;
	private _copy_from_src_objects;
	private _copy_from_found_node;
}
declare class TransformMultiSopParamConfig extends NodeParamsConfig {
	/** @param defines if this applies to objects or geometries */
	applyOn: ParamTemplate<ParamType.INTEGER>;
	/** @param number of transformations this can apply */
	count: ParamTemplate<ParamType.INTEGER>;
	/** @param transform 0 rotation order */
	rotationOrder0: ParamTemplate<ParamType.INTEGER>;
	/** @param rotation 0 */
	r0: ParamTemplate<ParamType.VECTOR3>;
	/** @param transform 1 rotation order */
	rotationOrder1: ParamTemplate<ParamType.INTEGER>;
	/** @param rotation 1 */
	r1: ParamTemplate<ParamType.VECTOR3>;
	/** @param transform 2 rotation order */
	rotationOrder2: ParamTemplate<ParamType.INTEGER>;
	/** @param rotation 2 */
	r2: ParamTemplate<ParamType.VECTOR3>;
	/** @param transform 3 rotation order */
	rotationOrder3: ParamTemplate<ParamType.INTEGER>;
	/** @param rotation 3 */
	r3: ParamTemplate<ParamType.VECTOR3>;
	/** @param transform 4 rotation order */
	rotationOrder4: ParamTemplate<ParamType.INTEGER>;
	/** @param rotation 4 */
	r4: ParamTemplate<ParamType.VECTOR3>;
	/** @param transform 5 rotation order */
	rotationOrder5: ParamTemplate<ParamType.INTEGER>;
	/** @param rotation 5 */
	r5: ParamTemplate<ParamType.VECTOR3>;
}
declare class TransformMultiSopNode extends TypedSopNode<TransformMultiSopParamConfig> {
	paramsConfig: TransformMultiSopParamConfig;
	static type(): SopType;
	initializeNode(): void;
	private _core_transform;
	private __rotAndIndexPairs;
	private _createRotAndIndexPairs;
	private _rotAndIndexPairs;
	cook(input_contents: CoreGroup[]): void;
	private _apply_transforms;
	private _apply_matrix_to_geometries;
	private _apply_matrix_to_objects;
	private _t;
	private _s;
	private _scale;
	private _matrix;
}
declare enum TransformResetMode {
	RESET_OBJECT = "reset objects transform",
	CENTER_GEO = "center geometries",
	CENTER_GEO_RESET_OBJECT = "center geometry and reset object"
}
declare class TransformResetSopParamConfig extends NodeParamsConfig {
	/** @param mode to reset the geometry and object */
	mode: ParamTemplate<ParamType.INTEGER>;
}
declare class TransformResetSopNode extends TypedSopNode<TransformResetSopParamConfig> {
	paramsConfig: TransformResetSopParamConfig;
	static type(): SopType;
	initializeNode(): void;
	setMode(mode: TransformResetMode): void;
	private _operation;
	cook(inputCoreGroups: CoreGroup[]): void;
}
declare class TubeSopParamsConfig extends NodeParamsConfig {
	/** @param top radius */
	radiusTop: ParamTemplate<ParamType.FLOAT>;
	/** @param bottom radius */
	radiusBottom: ParamTemplate<ParamType.FLOAT>;
	/** @param tube height */
	height: ParamTemplate<ParamType.FLOAT>;
	/** @param number of segments in the radial direction */
	segmentsRadial: ParamTemplate<ParamType.INTEGER>;
	/** @param number of segments in the height direction */
	segmentsHeight: ParamTemplate<ParamType.INTEGER>;
	/** @param adds caps */
	cap: ParamTemplate<ParamType.BOOLEAN>;
	/** @param center of the tube */
	center: ParamTemplate<ParamType.VECTOR3>;
	/** @param direction of the tube */
	direction: ParamTemplate<ParamType.VECTOR3>;
	/** @param if set to 1, you can then set the phiStart, phi_end, thetaStart and theta_end */
	open: ParamTemplate<ParamType.BOOLEAN>;
	/** @param start of theta angle */
	thetaStart: ParamTemplate<ParamType.FLOAT>;
	/** @param length of theta opening */
	thetaLength: ParamTemplate<ParamType.FLOAT>;
}
declare class TubeSopNode extends TypedSopNode<TubeSopParamsConfig> {
	paramsConfig: TubeSopParamsConfig;
	static type(): SopType;
	private _operation;
	cook(input_contents: CoreGroup[]): void;
}
declare class UvProjectSopParamsConfig extends NodeParamsConfig {
	/** @param camera node to use as projection */
	camera: ParamTemplate<ParamType.NODE_PATH>;
}
declare class UvProjectSopNode extends TypedSopNode<UvProjectSopParamsConfig> {
	paramsConfig: UvProjectSopParamsConfig;
	static type(): string;
	private _cameraController;
	private _processed_core_group;
	private _camera_object;
	initializeNode(): void;
	cook(core_groups: CoreGroup[]): void;
	_updateUVsFromCamera(look_at_target: Object3D): void;
	private _vectorInCameraSpace;
}
declare class UvTransformSopParamsConfig extends NodeParamsConfig {
	/** @param attribName */
	attribName: ParamTemplate<ParamType.STRING>;
	/** @param translate */
	t: ParamTemplate<ParamType.VECTOR2>;
	/** @param scale */
	s: ParamTemplate<ParamType.VECTOR2>;
	/** @param pivot */
	pivot: ParamTemplate<ParamType.VECTOR2>;
}
declare class UvTransformSopNode extends TypedSopNode<UvTransformSopParamsConfig> {
	paramsConfig: UvTransformSopParamsConfig;
	static type(): SopType;
	initializeNode(): void;
	private _operation;
	cook(input_contents: CoreGroup[]): void;
}
declare enum UvUnwrapMethod {
	POTPACK = "potpack",
	XATLAS = "xatlas"
}
declare class UvUnwrapSopParamConfig extends NodeParamsConfig {
	/** @param method */
	method: ParamTemplate<ParamType.INTEGER>;
	/** @param attribute to unwrap */
	uv: ParamTemplate<ParamType.STRING>;
	/** @param target texture resolution */
	resolution: ParamTemplate<ParamType.INTEGER>;
	/** @param padding */
	padding: ParamTemplate<ParamType.INTEGER>;
}
declare class UvUnwrapSopNode extends TypedSopNode<UvUnwrapSopParamConfig> {
	paramsConfig: UvUnwrapSopParamConfig;
	static type(): SopType;
	initializeNode(): void;
	private _operation;
	cook(inputCoreGroups: CoreGroup[]): Promise<void>;
	setMethod(method: UvUnwrapMethod): void;
}
declare class WebXRAREstimatedLightSopParamsConfig extends NodeParamsConfig {
	/** @param default environment map */
	/** @param apply computed environment */
	applyEnv: ParamTemplate<ParamType.BOOLEAN>;
	/** @param apply computed light Probe */
	applyLightProbe: ParamTemplate<ParamType.BOOLEAN>;
	/** @param apply computed directional Light */
	applyDirectionalLight: ParamTemplate<ParamType.BOOLEAN>;
}
declare class WebXRAREstimatedLightSopNode extends TypedSopNode<WebXRAREstimatedLightSopParamsConfig> {
	paramsConfig: WebXRAREstimatedLightSopParamsConfig;
	static type(): SopType;
	initializeNode(): void;
	cook(inputCoreGroups: CoreGroup[]): void;
}
declare class WFCBuilderSopParamsConfig extends NodeParamsConfig {
	/** @param tileHeight */
	tileHeight: ParamTemplate<ParamType.FLOAT>;
}
declare class WFCBuilderSopNode extends TypedSopNode<WFCBuilderSopParamsConfig> {
	paramsConfig: WFCBuilderSopParamsConfig;
	static type(): SopType;
	initializeNode(): void;
	cook(inputCoreGroups: CoreGroup[]): void;
	private _processTileConfigs;
	private _convertTileConfig;
	private _convertTileConfigs;
	private _tileObject;
}
declare class WFCDebugSopParamsConfig extends NodeParamsConfig {
	/** @param src tile id */
	srcTileId: ParamTemplate<ParamType.STRING>;
	/** @param dest tile id */
	destTileId: ParamTemplate<ParamType.STRING>;
	/** @param side name */
	sideName: ParamTemplate<ParamType.STRING>;
}
declare class WFCDebugSopNode extends TypedSopNode<WFCDebugSopParamsConfig> {
	paramsConfig: WFCDebugSopParamsConfig;
	static type(): SopType;
	initializeNode(): void;
	cook(inputCoreGroups: CoreGroup[]): Promise<void>;
}
declare class WFCSolverSopParamsConfig extends NodeParamsConfig {
	/** @param iterations */
	stepsCount: ParamTemplate<ParamType.INTEGER>;
	/** @param max resolved quads */
	maxCount: ParamTemplate<ParamType.INTEGER>;
	/** @param quadSeed */
	quadSeed: ParamTemplate<ParamType.INTEGER>;
	/** @param configSeed */
	configSeed: ParamTemplate<ParamType.INTEGER>;
}
declare class WFCSolverSopNode extends TypedSopNode<WFCSolverSopParamsConfig> {
	paramsConfig: WFCSolverSopParamsConfig;
	static type(): SopType;
	initializeNode(): void;
	cook(inputCoreGroups: CoreGroup[]): void;
}
declare class WFCRuleFromProximitySopParamsConfig extends NodeParamsConfig {
}
declare class WFCRuleFromProximitySopNode extends TypedSopNode<WFCRuleFromProximitySopParamsConfig> {
	paramsConfig: WFCRuleFromProximitySopParamsConfig;
	static type(): SopType;
	initializeNode(): void;
	cook(inputCoreGroups: CoreGroup[]): Promise<void>;
}
declare class WFCRuleConnectionFromSideNameSopParamsConfig extends NodeParamsConfig {
	/** @param src tile id */
	srcTileId: ParamTemplate<ParamType.STRING>;
	/** @param dest tile id */
	destTileId: ParamTemplate<ParamType.STRING>;
	/** @param side name */
	sideName: ParamTemplate<ParamType.STRING>;
}
declare class WFCRuleConnectionFromSideNameSopNode extends TypedSopNode<WFCRuleConnectionFromSideNameSopParamsConfig> {
	paramsConfig: WFCRuleConnectionFromSideNameSopParamsConfig;
	static type(): SopType;
	initializeNode(): void;
	cook(inputCoreGroups: CoreGroup[]): Promise<void>;
}
declare class WFCRuleConnectionToGridBorderSopParamsConfig extends NodeParamsConfig {
	/** @param src tile id */
	tileId: ParamTemplate<ParamType.STRING>;
	/** @param side name */
	sideName: ParamTemplate<ParamType.STRING>;
}
declare class WFCRuleConnectionToGridBorderSopNode extends TypedSopNode<WFCRuleConnectionToGridBorderSopParamsConfig> {
	paramsConfig: WFCRuleConnectionToGridBorderSopParamsConfig;
	static type(): SopType;
	initializeNode(): void;
	cook(inputCoreGroups: CoreGroup[]): Promise<void>;
}
declare class WFCRuleTileWeightSopParamsConfig extends NodeParamsConfig {
	/** @param tile id */
	tileId: ParamTemplate<ParamType.STRING>;
	/** @param weight */
	weight: ParamTemplate<ParamType.FLOAT>;
}
declare class WFCRuleTileWeightSopNode extends TypedSopNode<WFCRuleTileWeightSopParamsConfig> {
	paramsConfig: WFCRuleTileWeightSopParamsConfig;
	static type(): SopType;
	initializeNode(): void;
	cook(inputCoreGroups: CoreGroup[]): Promise<void>;
}
declare class WFCTileEmptyObjectSopParamsConfig extends NodeParamsConfig {
}
declare class WFCTileEmptyObjectSopNode extends TypedSopNode<WFCTileEmptyObjectSopParamsConfig> {
	paramsConfig: WFCTileEmptyObjectSopParamsConfig;
	static type(): SopType;
	initializeNode(): void;
	cook(inputCoreGroups: CoreGroup[]): Promise<void>;
}
declare class WFCTileErrorObjectSopParamsConfig extends NodeParamsConfig {
}
declare class WFCTileErrorObjectSopNode extends TypedSopNode<WFCTileErrorObjectSopParamsConfig> {
	paramsConfig: WFCTileErrorObjectSopParamsConfig;
	static type(): SopType;
	initializeNode(): void;
	cook(inputCoreGroups: CoreGroup[]): Promise<void>;
}
declare class WFCTilePropertiesSopParamsConfig extends NodeParamsConfig {
	/** @param group to assign the material to */
	group: ParamTemplate<ParamType.STRING>;
	/** @param addId */
	addId: ParamTemplate<ParamType.BOOLEAN>;
	/** @param addId */
	id: ParamTemplate<ParamType.STRING>;
	/** @param addName */
	addName: ParamTemplate<ParamType.BOOLEAN>;
	/** @param allowedRotationY */
	allowedRotationY: ParamTemplate<ParamType.BOOLEAN>;
}
declare class WFCTilePropertiesSopNode extends TypedSopNode<WFCTilePropertiesSopParamsConfig> {
	paramsConfig: WFCTilePropertiesSopParamsConfig;
	static type(): SopType;
	initializeNode(): void;
	cook(inputCoreGroups: CoreGroup[]): Promise<void>;
	protected _computeStringParam(param: StringParam, coreObjects: BaseCoreObject<CoreObjectType>[], applyMethod: (object: ObjectContent<CoreObjectType>, value: string) => void): Promise<void>;
	protected _computeBooleanParam(param: BooleanParam, coreObjects: BaseCoreObject<CoreObjectType>[], applyMethod: (object: ObjectContent<CoreObjectType>, value: boolean) => void): Promise<void>;
}
declare class WFCTileSideNameSopParamsConfig extends NodeParamsConfig {
	/** @param group to assign the material to */
	group: ParamTemplate<ParamType.STRING>;
	sameNameForSelectedSides: ParamTemplate<ParamType.BOOLEAN>;
	/** @param south side */
	south: ParamTemplate<ParamType.BOOLEAN>;
	southName: ParamTemplate<ParamType.STRING>;
	/** @param north side */
	north: ParamTemplate<ParamType.BOOLEAN>;
	northName: ParamTemplate<ParamType.STRING>;
	/** @param west side */
	west: ParamTemplate<ParamType.BOOLEAN>;
	westName: ParamTemplate<ParamType.STRING>;
	/** @param east side */
	east: ParamTemplate<ParamType.BOOLEAN>;
	eastName: ParamTemplate<ParamType.STRING>;
	/** @param bottom side */
	bottom: ParamTemplate<ParamType.BOOLEAN>;
	bottomName: ParamTemplate<ParamType.STRING>;
	/** @param top side */
	top: ParamTemplate<ParamType.BOOLEAN>;
	topName: ParamTemplate<ParamType.STRING>;
	/** @param allowedRotationY */
	sideName: ParamTemplate<ParamType.STRING>;
	/** @param highlight */
	highlight: ParamTemplate<ParamType.BOOLEAN>;
}
declare class WFCTileSideNameSopNode extends TypedSopNode<WFCTileSideNameSopParamsConfig> {
	paramsConfig: WFCTileSideNameSopParamsConfig;
	static type(): SopType;
	initializeNode(): void;
	cook(inputCoreGroups: CoreGroup[]): Promise<void>;
	private _createHighlightPlane;
}
declare class WFCTileTransformSopParamsConfig extends NodeParamsConfig {
	/** @param south / north  */
	sn: ParamTemplate<ParamType.INTEGER>;
	/** @param west / east */
	we: ParamTemplate<ParamType.INTEGER>;
	/** @param bottom / top */
	bt: ParamTemplate<ParamType.INTEGER>;
	/** @param y rotation */
	ry: ParamTemplate<ParamType.INTEGER>;
}
declare class WFCTileTransformSopNode extends TypedSopNode<WFCTileTransformSopParamsConfig> {
	paramsConfig: WFCTileTransformSopParamsConfig;
	static type(): SopType;
	initializeNode(): void;
	cook(inputCoreGroups: CoreGroup[]): Promise<void>;
}
declare class WFCTileUnresolvedObjectSopParamsConfig extends NodeParamsConfig {
}
declare class WFCTileUnresolvedObjectSopNode extends TypedSopNode<WFCTileUnresolvedObjectSopParamsConfig> {
	paramsConfig: WFCTileUnresolvedObjectSopParamsConfig;
	static type(): SopType;
	initializeNode(): void;
	cook(inputCoreGroups: CoreGroup[]): Promise<void>;
}
declare class ParamLessNetworkSopParamsConfig extends NodeParamsConfig {
}
declare class BaseNetworkSopNode<K extends NodeParamsConfig> extends TypedNode<NodeContext.SOP, K> {
	static context(): NodeContext;
	cook(): void;
}
declare class ParamLessBaseNetworkSopNode extends BaseNetworkSopNode<ParamLessNetworkSopParamsConfig> {
}
declare class ActorsNetworkSopNode extends ParamLessBaseNetworkSopNode {
	static type(): NetworkNodeType;
	protected _childrenControllerContext: NodeContext;
	createNode<S extends keyof JsNodeChildrenMap>(node_class: S, options?: NodeCreateOptions): JsNodeChildrenMap[S];
	createNode<K extends valueof<JsNodeChildrenMap>>(node_class: Constructor<K>, options?: NodeCreateOptions): K;
	children(): BaseJsNodeType[];
	nodesByType<K extends keyof JsNodeChildrenMap>(type: K): JsNodeChildrenMap[K][];
	childrenAllowed(): boolean;
	sceneReadonly(): boolean;
	readonly persisted_config: ActorPersistedConfig;
	assemblerController(): JsAssemblerController<JsAssemblerActor> | undefined;
	usedAssembler(): Readonly<AssemblerName.JS_ACTOR>;
	protected _assemblerController: JsAssemblerController<JsAssemblerActor> | undefined;
	private _createAssemblerController;
	readonly compilationController: ActorCompilationController;
	compile(): void;
	cook(): void;
}
declare class AnimationsNetworkSopNode extends ParamLessBaseNetworkSopNode {
	static type(): NetworkNodeType;
	protected _childrenControllerContext: NodeContext;
	createNode<S extends keyof AnimNodeChildrenMap>(node_class: S, options?: NodeCreateOptions): AnimNodeChildrenMap[S];
	createNode<K extends valueof<AnimNodeChildrenMap>>(node_class: Constructor<K>, options?: NodeCreateOptions): K;
	children(): BaseAnimNodeType[];
	nodesByType<K extends keyof AnimNodeChildrenMap>(type: K): AnimNodeChildrenMap[K][];
}
declare class AudioNetworkSopNode extends ParamLessBaseNetworkSopNode {
	static type(): NetworkNodeType;
	protected _childrenControllerContext: NodeContext;
	createNode<S extends keyof AudioNodeChildrenMap>(node_class: S, options?: NodeCreateOptions): AudioNodeChildrenMap[S];
	createNode<K extends valueof<AudioNodeChildrenMap>>(node_class: Constructor<K>, options?: NodeCreateOptions): K;
	children(): BaseAnimNodeType[];
	nodesByType<K extends keyof AudioNodeChildrenMap>(type: K): AudioNodeChildrenMap[K][];
}
declare class CopNetworkSopNode extends ParamLessBaseNetworkSopNode {
	static type(): NetworkNodeType;
	protected _childrenControllerContext: NodeContext;
	createNode<S extends keyof CopNodeChildrenMap>(node_class: S, options?: NodeCreateOptions): CopNodeChildrenMap[S];
	createNode<K extends valueof<CopNodeChildrenMap>>(node_class: Constructor<K>, options?: NodeCreateOptions): K;
	children(): BaseCopNodeType[];
	nodesByType<K extends keyof CopNodeChildrenMap>(type: K): CopNodeChildrenMap[K][];
}
declare class EventsNetworkSopNode extends ParamLessBaseNetworkSopNode {
	static type(): NetworkNodeType;
	protected _childrenControllerContext: NodeContext;
	createNode<S extends keyof EventNodeChildrenMap>(node_class: S, options?: NodeCreateOptions): EventNodeChildrenMap[S];
	createNode<K extends valueof<EventNodeChildrenMap>>(node_class: Constructor<K>, options?: NodeCreateOptions): K;
	children(): BaseEventNodeType[];
	nodesByType<K extends keyof EventNodeChildrenMap>(type: K): EventNodeChildrenMap[K][];
}
declare class MaterialsNetworkSopNode extends ParamLessBaseNetworkSopNode {
	static type(): NetworkNodeType;
	protected _childrenControllerContext: NodeContext;
	createNode<S extends keyof MatNodeChildrenMap>(node_class: S, options?: NodeCreateOptions): MatNodeChildrenMap[S];
	createNode<K extends valueof<MatNodeChildrenMap>>(node_class: Constructor<K>, options?: NodeCreateOptions): K;
	children(): BaseMatNodeType[];
	nodesByType<K extends keyof MatNodeChildrenMap>(type: K): MatNodeChildrenMap[K][];
}
declare class PostProcessNetworkSopNode extends BaseNetworkSopNode<PostProcessNetworkParamsConfig> {
	paramsConfig: PostProcessNetworkParamsConfig;
	static type(): NetworkNodeType;
	readonly effectsComposerController: EffectComposerController;
	readonly displayNodeController: DisplayNodeController;
	protected _childrenControllerContext: NodeContext;
	createNode<S extends keyof PostNodeChildrenMap>(node_class: S, options?: NodeCreateOptions): PostNodeChildrenMap[S];
	createNode<K extends valueof<PostNodeChildrenMap>>(node_class: Constructor<K>, options?: NodeCreateOptions): K;
	children(): BasePostProcessNodeType[];
	nodesByType<K extends keyof PostNodeChildrenMap>(type: K): PostNodeChildrenMap[K][];
}
declare class RenderersNetworkSopNode extends ParamLessBaseNetworkSopNode {
	static type(): NetworkNodeType;
	protected _childrenControllerContext: NodeContext;
	createNode<S extends keyof RopNodeChildrenMap>(node_class: S, options?: NodeCreateOptions): RopNodeChildrenMap[S];
	createNode<K extends valueof<RopNodeChildrenMap>>(node_class: Constructor<K>, options?: NodeCreateOptions): K;
	children(): BaseRopNodeType[];
	nodesByType<K extends keyof RopNodeChildrenMap>(type: K): RopNodeChildrenMap[K][];
}
interface GeoNodeChildrenMap {
	actor: ActorSopNode;
	actorInstance: ActorInstanceSopNode;
	actorPoint: ActorPointSopNode;
	add: AddSopNode;
	adjacency: AdjacencySopNode;
	ambientLight: AmbientLightSopNode;
	animationCopy: AnimationCopySopNode;
	areaLight: AreaLightSopNode;
	attribAddMult: AttribAddMultSopNode;
	attribCast: AttribCastSopNode;
	attribCopy: AttribCopySopNode;
	attribCreate: AttribCreateSopNode;
	attribDelete: AttribDeleteSopNode;
	attribFromTexture: AttribFromTextureSopNode;
	attribId: AttribIdSopNode;
	attribNormalize: AttribNormalizeSopNode;
	attribPromote: AttribPromoteSopNode;
	attribRemap: AttribRemapSopNode;
	attribRename: AttribRenameSopNode;
	attribSetAtIndex: AttribSetAtIndexSopNode;
	attribTransfer: AttribTransferSopNode;
	audioNotes: AudioNotesSopNode;
	axesHelper: AxesHelperSopNode;
	bboxScatter: BboxScatterSopNode;
	blend: BlendSopNode;
	boolean: BooleanSopNode;
	box: BoxSopNode;
	boxLines: BoxLinesSopNode;
	BVH: BVHSopNode;
	BVHVisualizer: BVHVisualizerSopNode;
	cache: CacheSopNode;
	CADBoolean: CADBooleanSopNode;
	CADBox: CADBoxSopNode;
	CADCircle: CADCircleSopNode;
	CADCircle2D: CADCircle2DSopNode;
	CADCircle3Points: CADCircle3PointsSopNode;
	CADCone: CADConeSopNode;
	CADConvertDimension: CADConvertDimensionSopNode;
	CADCurve2DToSurface: CADCurve2DToSurfaceSopNode;
	CADCurveFromPoints: CADCurveFromPointsSopNode;
	CADCurveFromPoints2D: CADCurveFromPoints2DSopNode;
	CADCurveTrim: CADCurveTrimSopNode;
	CADEllipse: CADEllipseSopNode;
	CADEllipse2D: CADEllipse2DSopNode;
	CADExporterSTEP: CADExporterSTEPSopNode;
	CADExtrude: CADExtrudeSopNode;
	CADFileSTEP: CADFileSTEPSopNode;
	CADFillet: CADFilletSopNode;
	CADGroup: CADGroupSopNode;
	CADLoft: CADLoftSopNode;
	CADMirror: CADMirrorSopNode;
	CADPipe: CADPipeSopNode;
	CADPoint: CADPointSopNode;
	CADPoint2D: CADPoint2DSopNode;
	CADPointsFromCurve: CADPointsFromCurveSopNode;
	CADRectangle: CADRectangleSopNode;
	CADRevolution: CADRevolutionSopNode;
	CADSegment: CADSegmentSopNode;
	CADSphere: CADSphereSopNode;
	CADThickness: CADThicknessSopNode;
	CADTorus: CADTorusSopNode;
	CADTransform: CADTransformSopNode;
	CADTransform2D: CADTransform2DSopNode;
	CADTriangulate: CADTriangulateSopNode;
	CADTube: CADTubeSopNode;
	CADUnpack: CADUnpackSopNode;
	CADWedge: CADWedgeSopNode;
	cameraControls: CameraControlsSopNode;
	cameraCSSRenderer: CameraCSSRendererSopNode;
	cameraFPS: CameraFPSSopNode;
	cameraFrameMode: CameraFrameModeSopNode;
	cameraPlane: CameraPlaneSopNode;
	cameraPostProcess: CameraPostProcessSopNode;
	cameraProject: CameraProjectSopNode;
	cameraRenderer: CameraRendererSopNode;
	cameraRenderScene: CameraRenderSceneSopNode;
	cameraViewerCode: CameraViewerCodeSopNode;
	cameraViewOffset: CameraViewOffsetSopNode;
	cameraWebXRAR: CameraWebXRARSopNode;
	cameraWebXRARMarkerTracking: CameraWebXRARMarkerTrackingSopNode;
	cameraWebXRVR: CameraWebXRVRSopNode;
	capsule: CapsuleSopNode;
	center: CenterSopNode;
	circle: CircleSopNode;
	circle3Points: Circle3PointsSopNode;
	clip: ClipSopNode;
	clothPrepare: ClothPrepareSopNode;
	clothSolver: ClothSolverSopNode;
	code: CodeSopNode;
	color: ColorSopNode;
	cone: ConeSopNode;
	contactShadows: ContactShadowsSopNode;
	convexHull: ConvexHullSopNode;
	copy: CopySopNode;
	curveFromPoints: CurveFromPointsSopNode;
	curveGetPoint: CurveGetPointSopNode;
	CSGArc: CSGArcSopNode;
	CSGBoolean: CSGBooleanSopNode;
	CSGBox: CSGBoxSopNode;
	CSGCenter: CSGCenterSopNode;
	CSGCircle: CSGCircleSopNode;
	CSGDodecahedron: CSGDodecahedronSopNode;
	CSGEllipse: CSGEllipseSopNode;
	CSGEllipsoid: CSGEllipsoidSopNode;
	CSGExpand: CSGExpandSopNode;
	CSGExtrudeLinear: CSGExtrudeLinearSopNode;
	CSGExtrudeRectangular: CSGExtrudeRectangularSopNode;
	CSGExtrudeRotate: CSGExtrudeRotateSopNode;
	CSGHull: CSGHullSopNode;
	CSGLine: CSGLineSopNode;
	CSGMirror: CSGMirrorSopNode;
	CSGOffset: CSGOffsetSopNode;
	CSGPolygon: CSGPolygonSopNode;
	CSGPolyhedron: CSGPolyhedronSopNode;
	CSGProject: CSGProjectSopNode;
	CSGRectangle: CSGRectangleSopNode;
	CSGTransformReset: CSGTransformResetSopNode;
	CSGSphere: CSGSphereSopNode;
	CSGStar: CSGStarSopNode;
	CSGTorus: CSGTorusSopNode;
	CSGTransform2D: CSGTransform2DSopNode;
	CSGTriangulate: CSGTriangulateSopNode;
	CSGTriangle: CSGTriangleSopNode;
	CSGTube: CSGTubeSopNode;
	CSGTubeElliptic: CSGTubeEllipticSopNode;
	CSS2DObject: CSS2DObjectSopNode;
	CSS3DObject: CSS3DObjectSopNode;
	cubeCamera: CubeCameraSopNode;
	data: DataSopNode;
	dataUrl: DataUrlSopNode;
	decal: DecalSopNode;
	decompose: DecomposeSopNode;
	delay: DelaySopNode;
	delete: DeleteSopNode;
	deleteByName: DeleteByNameSopNode;
	directionalLight: DirectionalLightSopNode;
	drawRange: DrawRangeSopNode;
	emptyObject: EmptyObjectSopNode;
	exporterGLTF: ExporterGLTFSopNode;
	exporterOBJ: ExporterOBJSopNode;
	exporterPLY: ExporterPLYSopNode;
	exporterSTL: ExporterSTLSopNode;
	face: FaceSopNode;
	facet: FacetSopNode;
	file3DS: File3DSSopNode;
	fileDRC: FileDRCSopNode;
	fileFBX: FileFBXSopNode;
	fileGEOJSON: FileGEOJSONSopNode;
	fileGLTF: FileGLTFSopNode;
	fileIFC: FileIFCSopNode;
	fileJSON: FileJSONSopNode;
	fileMPD: FileMPDSopNode;
	fileMultiGLTF: FileMultiGLTFSopNode;
	fileMultiOBJ: FileMultiOBJSopNode;
	fileOBJ: FileOBJSopNode;
	filePDB: FilePDBSopNode;
	filePLY: FilePLYSopNode;
	fileSTL: FileSTLSopNode;
	fileSVG: FileSVGSopNode;
	fileUSDZ: FileUSDZSopNode;
	fileVOX: FileVOXSopNode;
	fuse: FuseSopNode;
	groundProjectedSkybox: GroundProjectedSkyboxSopNode;
	heightMap: HeightMapSopNode;
	hexagons: HexagonsSopNode;
	hierarchy: HierarchySopNode;
	hemisphereLight: HemisphereLightSopNode;
	icosahedron: IcosahedronSopNode;
	IFCFilterCategories: IFCFilterCategoriesSopNode;
	instance: InstanceSopNode;
	instanceBuilder: InstanceBuilderSopNode;
	instanceUpdate: InstanceUpdateSopNode;
	instancesCount: InstancesCountSopNode;
	jitter: JitterSopNode;
	lattice: LatticeSopNode;
	layer: LayerSopNode;
	lightMixer: LightMixerSopNode;
	lightProbe: LightProbeSopNode;
	line: LineSopNode;
	lod: LodSopNode;
	lookAt: LookAtSopNode;
	mapboxCamera: MapboxCameraSopNode;
	mapboxLayer: MapboxLayerSopNode;
	mapboxPlane: MapboxPlaneSopNode;
	mapboxTransform: MapboxTransformSopNode;
	material: MaterialSopNode;
	materialProperties: MaterialPropertiesSopNode;
	merge: MergeSopNode;
	metaball: MetaballSopNode;
	mirror: MirrorSopNode;
	noise: NoiseSopNode;
	normals: NormalsSopNode;
	normalsHelper: NormalsHelperSopNode;
	null: NullSopNode;
	objectBuilder: ObjectBuilderSopNode;
	objectMerge: ObjectMergeSopNode;
	objectProperties: ObjectPropertiesSopNode;
	objectsLayout: ObjectsLayoutSopNode;
	oceanPlane: OceanPlaneSopNode;
	operationsComposer: OperationsComposerSopNode;
	orthographicCamera: OrthographicCameraSopNode;
	palette: PaletteSopNode;
	particlesSystemGpu: ParticlesSystemGpuSopNode;
	particlesSystemGpuAttributes: ParticlesSystemGpuAttributesSopNode;
	particlesSystemGpuMaterial: ParticlesSystemGpuMaterialSopNode;
	peak: PeakSopNode;
	perspectiveCamera: PerspectiveCameraSopNode;
	physicsDebug: PhysicsDebugSopNode;
	physicsGround: PhysicsGroundSopNode;
	physicsPlayer: PhysicsPlayerSopNode;
	physicsRBDJoints: PhysicsRBDJointsSopNode;
	physicsRBDAttributes: PhysicsRBDAttributesSopNode;
	physicsWorld: PhysicsWorldSopNode;
	plane: PlaneSopNode;
	planeHelper: PlaneHelperSopNode;
	point: PointSopNode;
	pointLight: PointLightSopNode;
	polarTransform: PolarTransformSopNode;
	polywire: PolywireSopNode;
	pointBuilder: PointBuilderSopNode;
	quadPlane: QuadPlaneSopNode;
	quadSmooth: QuadSmoothSopNode;
	quadTriangulate: QuadTriangulateSopNode;
	quadrangulate: QuadrangulateSopNode;
	ray: RaySopNode;
	reflector: ReflectorSopNode;
	resample: ResampleSopNode;
	restAttributes: RestAttributesSopNode;
	ring: RingSopNode;
	roundedBox: RoundedBoxSopNode;
	scatter: ScatterSopNode;
	SDFBuilder: SDFBuilderSopNode;
	setChildren: SetChildrenSopNode;
	setGeometry: SetGeometrySopNode;
	shear: ShearSopNode;
	shortestPath: ShortestPathSopNode;
	skin: SkinSopNode;
	skeletonHelper: SkeletonHelperSopNode;
	solver: SolverSopNode;
	solverPreviousFrame: SolverPreviousFrameSopNode;
	sort: SortSopNode;
	sphere: SphereSopNode;
	split: SplitSopNode;
	spotLight: SpotLightSopNode;
	subdivide: SubdivideSopNode;
	subnet: SubnetSopNode;
	subnetInput: SubnetInputSopNode;
	subnetOutput: SubnetOutputSopNode;
	switch: SwitchSopNode;
	tangent: TangentSopNode;
	tangentsHelper: TangentsHelperSopNode;
	tetDelete: TetDeleteSopNode;
	tetEmbed: TetEmbedSopNode;
	tetSoftBodySolver: TetSoftBodySolverSopNode;
	tetTriangulate: TetTriangulateSopNode;
	tetrahedralize: TetrahedralizeSopNode;
	tetrahedron: TetrahedronSopNode;
	text: TextSopNode;
	textureCopy: TextureCopySopNode;
	textureProperties: TexturePropertiesSopNode;
	torus: TorusSopNode;
	torusKnot: TorusKnotSopNode;
	trackingLandmarksFace: TrackingLandmarksFaceSopNode;
	trackingLandmarksFaceAttributes: TrackingLandmarksFaceAttributesSopNode;
	trackingLandmarksHand: TrackingLandmarksHandSopNode;
	trackingLandmarksHandAttributes: TrackingLandmarksHandAttributesSopNode;
	transform: TransformSopNode;
	transformCopy: TransformCopySopNode;
	transformMulti: TransformMultiSopNode;
	transformReset: TransformResetSopNode;
	tube: TubeSopNode;
	uvLayout: UvProjectSopNode;
	uvProject: UvProjectSopNode;
	uvTransform: UvTransformSopNode;
	uvUnwrap: UvUnwrapSopNode;
	webXRAREstimatedLight: WebXRAREstimatedLightSopNode;
	WFCBuilder: WFCBuilderSopNode;
	WFCDebug: WFCDebugSopNode;
	WFCRuleFromProximity: WFCRuleFromProximitySopNode;
	WFCRuleConnectionFromSideName: WFCRuleConnectionFromSideNameSopNode;
	WFCRuleConnectionToGridBorder: WFCRuleConnectionToGridBorderSopNode;
	WFCRuleTileWeight: WFCRuleTileWeightSopNode;
	WFCSolver: WFCSolverSopNode;
	WFCTileEmptyObject: WFCTileEmptyObjectSopNode;
	WFCTileErrorObject: WFCTileErrorObjectSopNode;
	WFCTileProperties: WFCTilePropertiesSopNode;
	WFCTileSideName: WFCTileSideNameSopNode;
	WFCTileTransform: WFCTileTransformSopNode;
	WFCTileUnresolvedObject: WFCTileUnresolvedObjectSopNode;
	actorsNetwork: ActorsNetworkSopNode;
	animationsNetwork: AnimationsNetworkSopNode;
	audioNetwork: AudioNetworkSopNode;
	copNetwork: CopNetworkSopNode;
	eventsNetwork: EventsNetworkSopNode;
	materialsNetwork: MaterialsNetworkSopNode;
	postProcessNetwork: PostProcessNetworkSopNode;
	renderersNetwork: RenderersNetworkSopNode;
}
declare const TesselationParamParamsConfig_base: {
	new (...args: any[]): {
		TetScale: ParamTemplate<ParamType.FLOAT>;
		TetDisplayOuterMesh: ParamTemplate<ParamType.BOOLEAN>;
		TetDisplayTetMesh: ParamTemplate<ParamType.BOOLEAN>;
		TetDisplayLines: ParamTemplate<ParamType.BOOLEAN>;
		TetDisplaySharedFaces: ParamTemplate<ParamType.BOOLEAN>;
		TetDisplayPoints: ParamTemplate<ParamType.BOOLEAN>;
		TetDisplayCenter: ParamTemplate<ParamType.BOOLEAN>;
		TetDisplaySphere: ParamTemplate<ParamType.BOOLEAN>;
		TET: ParamTemplate<ParamType.FOLDER>;
		QUADTriangles: ParamTemplate<ParamType.BOOLEAN>;
		QUADWireframe: ParamTemplate<ParamType.BOOLEAN>;
		QUAD: ParamTemplate<ParamType.FOLDER>;
		CSGFacetAngle: ParamTemplate<ParamType.FLOAT>;
		CSGLinesColor: ParamTemplate<ParamType.COLOR>;
		CSGMeshesColor: ParamTemplate<ParamType.COLOR>;
		CSGWireframe: ParamTemplate<ParamType.BOOLEAN>;
		CSG: ParamTemplate<ParamType.FOLDER>;
		CADLinearTolerance: ParamTemplate<ParamType.FLOAT>;
		CADAngularTolerance: ParamTemplate<ParamType.FLOAT>;
		CADCurveAbscissa: ParamTemplate<ParamType.FLOAT>;
		CADCurveTolerance: ParamTemplate<ParamType.FLOAT>;
		CADDisplayEdges: ParamTemplate<ParamType.BOOLEAN>;
		CADEdgesColor: ParamTemplate<ParamType.COLOR>;
		CADDisplayMeshes: ParamTemplate<ParamType.BOOLEAN>;
		CADMeshesColor: ParamTemplate<ParamType.COLOR>;
		CADWireframe: ParamTemplate<ParamType.BOOLEAN>;
		CAD: ParamTemplate<ParamType.FOLDER>;
	};
} & typeof NodeParamsConfig;
declare class TesselationParamParamsConfig extends TesselationParamParamsConfig_base {
}
declare class TesselationParamsObjNode extends TypedObjNode<Object3D, TesselationParamParamsConfig> {
}
interface BaseObjNodeClassWithDisplayNode extends TesselationParamsObjNode {
	displayNodeController: DisplayNodeController;
}
declare class ChildrenDisplayControllerSpecialized extends ObjChildrenDisplayController {
	protected node: BaseObjNodeClassWithDisplayNode;
	constructor(node: BaseObjNodeClassWithDisplayNode);
	_addSpecializedObjects(displayNode: BaseSopNodeType, coreGroup: CoreGroup, newObjects: Object3D[]): void;
}
declare const GeoObjParamConfig_base: {
	new (...args: any[]): {
		TetScale: ParamTemplate<ParamType.FLOAT>;
		TetDisplayOuterMesh: ParamTemplate<ParamType.BOOLEAN>;
		TetDisplayTetMesh: ParamTemplate<ParamType.BOOLEAN>;
		TetDisplayLines: ParamTemplate<ParamType.BOOLEAN>;
		TetDisplaySharedFaces: ParamTemplate<ParamType.BOOLEAN>;
		TetDisplayPoints: ParamTemplate<ParamType.BOOLEAN>;
		TetDisplayCenter: ParamTemplate<ParamType.BOOLEAN>;
		TetDisplaySphere: ParamTemplate<ParamType.BOOLEAN>;
		TET: ParamTemplate<ParamType.FOLDER>;
		QUADTriangles: ParamTemplate<ParamType.BOOLEAN>;
		QUADWireframe: ParamTemplate<ParamType.BOOLEAN>;
		QUAD: ParamTemplate<ParamType.FOLDER>;
		CSGFacetAngle: ParamTemplate<ParamType.FLOAT>;
		CSGLinesColor: ParamTemplate<ParamType.COLOR>;
		CSGMeshesColor: ParamTemplate<ParamType.COLOR>;
		CSGWireframe: ParamTemplate<ParamType.BOOLEAN>;
		CSG: ParamTemplate<ParamType.FOLDER>;
		CADLinearTolerance: ParamTemplate<ParamType.FLOAT>;
		CADAngularTolerance: ParamTemplate<ParamType.FLOAT>;
		CADCurveAbscissa: ParamTemplate<ParamType.FLOAT>;
		CADCurveTolerance: ParamTemplate<ParamType.FLOAT>;
		CADDisplayEdges: ParamTemplate<ParamType.BOOLEAN>;
		CADEdgesColor: ParamTemplate<ParamType.COLOR>;
		CADDisplayMeshes: ParamTemplate<ParamType.BOOLEAN>;
		CADMeshesColor: ParamTemplate<ParamType.COLOR>;
		CADWireframe: ParamTemplate<ParamType.BOOLEAN>;
		CAD: ParamTemplate<ParamType.FOLDER>;
	};
} & {
	new (...args: any[]): {
		/** @param toggle off to hide */
		display: ParamTemplate<ParamType.BOOLEAN>;
		/** @param set render order */
		renderOrder: ParamTemplate<ParamType.INTEGER>;
	};
} & {
	new (...args: any[]): {
		transform: ParamTemplate<ParamType.FOLDER>;
		keepPosWhenParenting: ParamTemplate<ParamType.BOOLEAN>;
		rotationOrder: ParamTemplate<ParamType.INTEGER>;
		t: ParamTemplate<ParamType.VECTOR3>;
		r: ParamTemplate<ParamType.VECTOR3>;
		s: ParamTemplate<ParamType.VECTOR3>;
		scale: ParamTemplate<ParamType.FLOAT>;
		matrixAutoUpdate: ParamTemplate<ParamType.BOOLEAN>;
		updateTransformFromObject: ParamTemplate<ParamType.BUTTON>;
	};
} & typeof NodeParamsConfig;
declare class GeoObjParamConfig extends GeoObjParamConfig_base {
}
declare class GeoObjNode extends TypedObjNode<Group, GeoObjParamConfig> {
	paramsConfig: GeoObjParamConfig;
	static type(): ObjType;
	readonly hierarchyController: HierarchyController;
	readonly transformController: TransformController;
	readonly flags: FlagsControllerD;
	createObject(): Group;
	readonly childrenDisplayController: ChildrenDisplayControllerSpecialized;
	readonly displayNodeController: DisplayNodeController;
	protected _childrenControllerContext: NodeContext;
	private _onChildAddBound;
	initializeNode(): void;
	createNode<S extends keyof GeoNodeChildrenMap>(node_class: S, options?: NodeCreateOptions): GeoNodeChildrenMap[S];
	createNode<K extends valueof<GeoNodeChildrenMap>>(node_class: Constructor<K>, options?: NodeCreateOptions): K;
	children(): BaseSopNodeType[];
	nodesByType<K extends keyof GeoNodeChildrenMap>(type: K): GeoNodeChildrenMap[K][];
	private _onChildAdd;
	cook(): void;
}
declare const NullObjParamConfig_base: {
	new (...args: any[]): {
		transform: ParamTemplate<ParamType.FOLDER>;
		keepPosWhenParenting: ParamTemplate<ParamType.BOOLEAN>;
		rotationOrder: ParamTemplate<ParamType.INTEGER>;
		t: ParamTemplate<ParamType.VECTOR3>;
		r: ParamTemplate<ParamType.VECTOR3>;
		s: ParamTemplate<ParamType.VECTOR3>;
		scale: ParamTemplate<ParamType.FLOAT>;
		matrixAutoUpdate: ParamTemplate<ParamType.BOOLEAN>;
		updateTransformFromObject: ParamTemplate<ParamType.BUTTON>;
	};
} & typeof NodeParamsConfig;
declare class NullObjParamConfig extends NullObjParamConfig_base {
}
declare class NullObjNode extends TypedObjNode<Group, NullObjParamConfig> {
	paramsConfig: NullObjParamConfig;
	static type(): string;
	readonly hierarchyController: HierarchyController;
	readonly transformController: TransformController;
	readonly flags: FlagsControllerD;
	private _helper;
	createObject(): Group;
	initializeNode(): void;
	private _updateHelperHierarchy;
	cook(): void;
}
declare class PolarTransformObjParamConfig extends NodeParamsConfig {
	/** @param center of the transform */
	center: ParamTemplate<ParamType.VECTOR3>;
	/** @param moves the objects along the longitude, which is equivalent to a rotation on the y axis */
	longitude: ParamTemplate<ParamType.FLOAT>;
	/** @param moves the objects along the latitude, which is equivalent to a rotation on the z or x axis */
	latitude: ParamTemplate<ParamType.FLOAT>;
	/** @param moves the point aways from the center */
	depth: ParamTemplate<ParamType.FLOAT>;
}
declare class PolarTransformObjNode extends TypedObjNode<Group, PolarTransformObjParamConfig> {
	paramsConfig: PolarTransformObjParamConfig;
	static type(): string;
	readonly hierarchyController: HierarchyController;
	readonly flags: FlagsControllerD;
	private _helper;
	createObject(): Group;
	initializeNode(): void;
	private _updateHelperHierarchy;
	private _displayedHelper;
	private __axisHelper__;
	private _axisHelper;
	private _createAxisHelper;
	private __polarGridHelper__;
	private _polarGridHelper;
	private _createPolarGridHelper;
	private _createHelper;
	private _cook_main_without_inputs_when_dirty_bound;
	private _cook_main_without_inputs_when_dirty;
	private _centerMatrix;
	private _longitudeMatrix;
	private _latitudeMatrix;
	private _depthMatrix;
	private _fullMatrix;
	private _decomposed;
	cook(): void;
	private _updateHelper;
}
declare const PositionalAudioParamConfig_base: {
	new (...args: any[]): {
		transform: ParamTemplate<ParamType.FOLDER>;
		keepPosWhenParenting: ParamTemplate<ParamType.BOOLEAN>;
		rotationOrder: ParamTemplate<ParamType.INTEGER>;
		t: ParamTemplate<ParamType.VECTOR3>;
		r: ParamTemplate<ParamType.VECTOR3>;
		s: ParamTemplate<ParamType.VECTOR3>;
		scale: ParamTemplate<ParamType.FLOAT>; /** @param audio node */
		matrixAutoUpdate: ParamTemplate<ParamType.BOOLEAN>;
		updateTransformFromObject: ParamTemplate<ParamType.BUTTON>; /** @param rolloffFactor. See https://developer.mozilla.org/en-US/docs/Web/API/PannerNode/rolloffFactor */
	};
} & typeof NodeParamsConfig;
declare class PositionalAudioParamConfig extends PositionalAudioParamConfig_base {
	audio: ParamTemplate<ParamType.FOLDER>;
	/** @param audio node */
	audioNode: ParamTemplate<ParamType.NODE_PATH>;
	/** @param refDistance. See https://developer.mozilla.org/en-US/docs/Web/API/PannerNode/refDistance*/
	refDistance: ParamTemplate<ParamType.FLOAT>;
	/** @param rolloffFactor. See https://developer.mozilla.org/en-US/docs/Web/API/PannerNode/rolloffFactor */
	rolloffFactor: ParamTemplate<ParamType.FLOAT>;
	/** @param maxDistance. See https://developer.mozilla.org/en-US/docs/Web/API/PannerNode/maxDistance */
	maxDistance: ParamTemplate<ParamType.FLOAT>;
	/** @param distanceModel. See https://developer.mozilla.org/en-US/docs/Web/API/PannerNode/distanceModel */
	distanceModel: ParamTemplate<ParamType.INTEGER>;
	/** @param coneInnerAngle. See https://developer.mozilla.org/en-US/docs/Web/API/PannerNode */
	coneInnerAngle: ParamTemplate<ParamType.FLOAT>;
	/** @param coneOuterAngle. See https://developer.mozilla.org/en-US/docs/Web/API/PannerNode */
	coneOuterAngle: ParamTemplate<ParamType.FLOAT>;
	/** @param coneOuterGain. See https://developer.mozilla.org/en-US/docs/Web/API/PannerNode */
	coneOuterGain: ParamTemplate<ParamType.FLOAT>;
	/** @param ensures the transform of the audio listener is updated on very frame */
	listenerTransformAutoUpdate: ParamTemplate<ParamType.BOOLEAN>;
	/** @param show helper */
	showHelper: ParamTemplate<ParamType.BOOLEAN>;
	/** @param helper size */
	helperSize: ParamTemplate<ParamType.FLOAT>;
}
declare class PositionalAudioObjNode extends TypedObjNode<Group, PositionalAudioParamConfig> {
	paramsConfig: PositionalAudioParamConfig;
	static type(): ObjType;
	readonly hierarchyController: HierarchyController;
	readonly transformController: TransformController;
	readonly flags: FlagsControllerD;
	private _positionalAudio;
	private _helper;
	createObject(): Group;
	initializeNode(): void;
	private _updateToDestination;
	private _updateHelperHierarchy;
	cook(): Promise<void>;
	private _updatePositionalAudio;
	private _createHelper;
	private _resetAudioNode;
	private _connectAudioNode;
	static PARAM_CALLBACK_updatePositionalAudio(node: PositionalAudioObjNode): void;
	protected _childrenControllerContext: NodeContext;
	createNode<S extends keyof AudioNodeChildrenMap>(node_class: S, options?: NodeCreateOptions): AudioNodeChildrenMap[S];
	createNode<K extends valueof<AudioNodeChildrenMap>>(node_class: Constructor<K>, options?: NodeCreateOptions): K;
	children(): BaseAudioNodeType[];
	nodesByType<K extends keyof AudioNodeChildrenMap>(type: K): AudioNodeChildrenMap[K][];
}
declare class RivetObjParamConfig extends NodeParamsConfig {
	object: ParamTemplate<ParamType.NODE_PATH>;
	pointIndex: ParamTemplate<ParamType.INTEGER>;
	updateMode: ParamTemplate<ParamType.INTEGER>;
	update: ParamTemplate<ParamType.BUTTON>;
}
declare class RivetObjNode extends TypedObjNode<Mesh, RivetObjParamConfig> {
	paramsConfig: RivetObjParamConfig;
	static type(): Readonly<"rivet">;
	readonly hierarchyController: HierarchyController;
	readonly flags: FlagsControllerD;
	private _helper;
	private _resolvedSopGroup;
	private _found_point_post;
	createObject(): Mesh<BufferGeometry<NormalBufferAttributes>, Material | Material[]>;
	initializeNode(): void;
	private _updateHelperHierarchy;
	cook(): Promise<void>;
	private _updateRenderHook;
	private _addRenderHook;
	private _removeRenderHook;
	private _on_object_before_render_bound;
	private _update;
	static PARAM_CALLBACK_update_resolved_object(node: RivetObjNode): void;
	private _update_resolved_object;
	private _resolvedObject;
	static PARAM_CALLBACK_update_updateMode(node: RivetObjNode): void;
	static PARAM_CALLBACK_update(node: RivetObjNode): void;
}
declare class SceneAutoUpdateController {
	protected node: RootManagerNode;
	constructor(node: RootManagerNode);
	update(): Promise<void>;
	static update(node: RootManagerNode): Promise<void>;
}
declare enum BackgroundMode {
	NONE = "none",
	COLOR = "color",
	TEXTURE = "texture"
}
declare class SceneBackgroundController {
	protected node: RootManagerNode;
	constructor(node: RootManagerNode);
	addHooks(): void;
	setMode(mode: BackgroundMode): void;
	backgroundMode(): BackgroundMode;
	private _updateBound;
	update(): Promise<void>;
	private _setBackgroundNone;
	private _setBackgroundColor;
	private _setBackgroundTexture;
	static update(node: RootManagerNode): void;
}
declare class SceneEnvController {
	protected node: RootManagerNode;
	constructor(node: RootManagerNode);
	addHooks(): void;
	private _updateBound;
	update(): Promise<void>;
	static update(node: RootManagerNode): Promise<void>;
}
declare const SceneFogParamsConfig_base: {
	new (...args: any[]): {
		/** @param toggle on to use fog */
		useFog: ParamTemplate<ParamType.BOOLEAN>;
		/** @param fog type */
		fogType: ParamTemplate<ParamType.INTEGER>;
		/** @param fog color */
		fogColor: ParamTemplate<ParamType.COLOR>;
		/** @param fog near */
		fogNear: ParamTemplate<ParamType.FLOAT>;
		/** @param fog far */
		fogFar: ParamTemplate<ParamType.FLOAT>;
		/** @param fog density */
		fogDensity: ParamTemplate<ParamType.FLOAT>;
	};
} & typeof NodeParamsConfig;
declare class SceneFogParamsConfig extends SceneFogParamsConfig_base {
}
declare class SceneFogController {
	protected node: RootManagerNode;
	constructor(node: RootManagerNode);
	private _fog;
	private _fogExp2;
	update(): Promise<void>;
	fog2(pv: ParamsValueAccessorType<SceneFogParamsConfig>): Fog;
	fogExp2(pv: ParamsValueAccessorType<SceneFogParamsConfig>): FogExp2;
	static update(node: RootManagerNode): Promise<void>;
}
declare class SceneMaterialOverrideController {
	protected node: RootManagerNode;
	constructor(node: RootManagerNode);
	update(): Promise<void>;
	static update(node: RootManagerNode): Promise<void>;
}
declare const SceneObjParamConfig_base: {
	new (...args: any[]): {
		useOverrideMaterial: ParamTemplate<ParamType.BOOLEAN>;
		overrideMaterial: ParamTemplate<ParamType.NODE_PATH>;
	};
} & {
	new (...args: any[]): {
		useFog: ParamTemplate<ParamType.BOOLEAN>;
		fogType: ParamTemplate<ParamType.INTEGER>;
		fogColor: ParamTemplate<ParamType.COLOR>;
		fogNear: ParamTemplate<ParamType.FLOAT>;
		fogFar: ParamTemplate<ParamType.FLOAT>;
		fogDensity: ParamTemplate<ParamType.FLOAT>;
	};
} & {
	new (...args: any[]): {
		useEnvironment: ParamTemplate<ParamType.BOOLEAN>;
		environment: ParamTemplate<ParamType.NODE_PATH>;
	};
} & {
	new (...args: any[]): {
		backgroundMode: ParamTemplate<ParamType.INTEGER>;
		bgColor: ParamTemplate<ParamType.COLOR>;
		bgTexture: ParamTemplate<ParamType.NODE_PATH>;
		bgBlur: ParamTemplate<ParamType.FLOAT>;
		bgIntensity: ParamTemplate<ParamType.FLOAT>;
	};
} & {
	new (...args: any[]): {
		autoUpdate: ParamTemplate<ParamType.BOOLEAN>;
	};
} & typeof NodeParamsConfig;
declare class SceneObjParamConfig extends SceneObjParamConfig_base {
}
declare class SceneObjNode extends TypedObjNode<Scene, SceneObjParamConfig> {
	paramsConfig: SceneObjParamConfig;
	static type(): Readonly<ObjType.SCENE>;
	readonly hierarchyController: HierarchyController;
	createObject(): Scene;
	initializeNode(): void;
	private _cook_main_without_inputs_when_dirty_bound;
	private _cook_main_without_inputs_when_dirty;
	readonly sceneAutoUpdateController: SceneAutoUpdateController;
	readonly sceneBackgroundController: SceneBackgroundController;
	readonly sceneEnvController: SceneEnvController;
	readonly sceneFogController: SceneFogController;
	readonly sceneMaterialOverrideController: SceneMaterialOverrideController;
	cook(): void;
}
declare class LayersController {
	private node;
	constructor(node: BaseObjNodeType);
	update(): void;
}
interface RendererConfigWebGL {
	renderer: WebGLRenderer;
	rendererNode?: WebGLRendererRopNode;
}
interface RendererConfigPathtracing {
	renderer: PathTracingRendererContainer;
	rendererNode?: PathTracingRendererRopNode;
}
type AvailableRenderConfig = RendererConfigWebGL | RendererConfigPathtracing;
interface ThreejsViewerOptions<C extends Camera> extends TypedViewerOptions<C> {
}
type RenderFuncWithDelta = (delta: number) => void;
type RenderFunc = () => void;
interface ThreejsViewerSetupData<C extends Camera> {
	renderer: AbstractRenderer;
	renderScene: Scene;
	camera: C;
}
/**
 *
 *
 * threejs viewers are created by the [PerspectiveCamera](/docs/nodes/obj/perspectivecamera) and [OrthographicCamera](/docs/nodes/obj/orthographiccamera) object nodes. They inherit from [TypedViewer](/docs/api/TypedViewer).
 *
 */
declare class ThreejsViewer<C extends Camera> extends TypedViewer<C> {
	protected _requestAnimationFrameId: number | undefined;
	private _webXRConfig;
	private _markerTrackingConfig;
	protected _renderer: AbstractRenderer | undefined;
	private _rendererConfig;
	protected _renderFunc: RenderFuncWithDelta | undefined;
	protected _renderCSSFunc: RenderFunc | undefined;
	private _cssRendererConfig;
	private _codeConfig;
	private _FPSConfig;
	private _effectComposer;
	protected _errorMessage: string | undefined;
	static _canvasIdPrefix(): string;
	constructor(options: ThreejsViewerOptions<C>);
	rendererConfig(): AvailableRenderConfig | undefined;
	protected _setupFunctions(options: ThreejsViewerOptions<C>): ThreejsViewerSetupData<C> | void;
	/**
	 * mounts the viewer onto an element
	 *
	 *
	 */
	mount(element: HTMLElement, options?: BaseViewerMountOptions): void;
	_build(): void;
	/**
	 * disposes the viewer
	 *
	 *
	 */
	dispose(): void;
	private _setEvents;
	private _disposeEvents;
	private _onResizeBound;
	onResize(): void;
	private _initDisplay;
	/**
	 * setAutoRender to false will stop the rendering. This can be useful if you know that nothing has changed in the scene, or if the renderer is currently not visible.
	 *
	 *
	 */
	setAutoRender(state?: boolean): void;
	isXR(): boolean;
	private _startAnimate;
	private _cancelAnimate;
	protected _animateWebBound: () => void;
	protected _animateWeb(): void;
	private _animateWebXR;
	private _accumulatedDelta;
	protected __animateCommon__(): void;
	private _cancelAnimateCommon;
	render(delta: number): void;
	protected _preRender(delta: number): void;
	protected _postRender(delta: number): void;
	/**
	 * returns the current renderer
	 *
	 *
	 */
	renderer(): AbstractRenderer | undefined;
	effectComposer(): EffectComposer | undefined;
	preCompile(): void;
	markAsReady(): void;
}
interface OrthoOrPerspCamera extends Camera {
	near: number;
	far: number;
	updateProjectionMatrix: () => void;
	getFocalLength?: () => void;
}
declare const BaseCameraObjParamsConfig_base: {
	new (...args: any[]): {
		setMainCamera: ParamTemplate<ParamType.BUTTON>;
	};
} & typeof NodeParamsConfig;
declare class BaseCameraObjParamsConfig extends BaseCameraObjParamsConfig_base {
}
declare const BaseThreejsCameraObjParamsConfig_base: {
	new (...args: any[]): {
		doPostProcess: ParamTemplate<ParamType.BOOLEAN>;
		postProcessNode: ParamTemplate<ParamType.NODE_PATH>;
	};
} & {
	new (...args: any[]): {
		render: ParamTemplate<ParamType.FOLDER>;
		setScene: ParamTemplate<ParamType.BOOLEAN>;
		scene: ParamTemplate<ParamType.NODE_PATH>;
		setRenderer: ParamTemplate<ParamType.BOOLEAN>;
		renderer: ParamTemplate<ParamType.NODE_PATH>;
		setCSSRenderer: ParamTemplate<ParamType.BOOLEAN>;
		CSSRenderer: ParamTemplate<ParamType.NODE_PATH>;
	};
} & {
	new (...args: any[]): {
		frameMode: ParamTemplate<ParamType.INTEGER>;
		expectedAspectRatio: ParamTemplate<ParamType.FLOAT>;
	};
} & {
	new (...args: any[]): {
		transform: ParamTemplate<ParamType.FOLDER>;
		keepPosWhenParenting: ParamTemplate<ParamType.BOOLEAN>;
		rotationOrder: ParamTemplate<ParamType.INTEGER>;
		t: ParamTemplate<ParamType.VECTOR3>;
		r: ParamTemplate<ParamType.VECTOR3>;
		s: ParamTemplate<ParamType.VECTOR3>;
		scale: ParamTemplate<ParamType.FLOAT>;
		matrixAutoUpdate: ParamTemplate<ParamType.BOOLEAN>;
		updateTransformFromObject: ParamTemplate<ParamType.BUTTON>;
	};
} & {
	new (...args: any[]): {
		layer: ParamTemplate<ParamType.INTEGER>;
	};
} & {
	new (...args: any[]): {
		camera: ParamTemplate<ParamType.FOLDER>;
		/** @param controls node to allow the camera to be moved by user input */
		controls: ParamTemplate<ParamType.NODE_PATH>;
		/** @param define when the camera node transform parameters are updated after the controls have moved the internal camera object */
		updateFromControlsMode: ParamTemplate<ParamType.INTEGER>;
		/** @param near */
		near: ParamTemplate<ParamType.FLOAT>;
		/** @param far */
		far: ParamTemplate<ParamType.FLOAT>;
		/** @param display */
		display: ParamTemplate<ParamType.BOOLEAN>;
		/** @param show helper */
		showHelper: ParamTemplate<ParamType.BOOLEAN>;
	};
} & {
	new (...args: any[]): {
		setMainCamera: ParamTemplate<ParamType.BUTTON>;
	};
} & typeof NodeParamsConfig;
declare class BaseThreejsCameraObjParamsConfig extends BaseThreejsCameraObjParamsConfig_base {
}
interface BaseViewerOptions {
	element?: HTMLElement;
	updateAutoRenderOnIntersectionChange?: boolean;
}
declare abstract class TypedCameraObjNode<O extends OrthoOrPerspCamera, K extends BaseCameraObjParamsConfig> extends TypedObjNode<O, K> {
	readonly renderOrder: number;
	protected _object: O;
	protected _aspect: number;
	get object(): O;
	cook(): Promise<void>;
	camera(): O;
	updateCamera(): void;
	static PARAM_CALLBACK_setMainCamera(node: BaseCameraObjNodeType): void;
	setAsMainCamera(): void;
	setupForAspectRatio(aspect: number): void;
	update_transform_params_from_object(): void;
	abstract createViewer(options?: BaseViewerOptions | HTMLElement): Promise<BaseViewerType | undefined>;
	static PARAM_CALLBACK_update_from_param(node: BaseCameraObjNodeType, param: BaseParamType): void;
}
declare class TypedThreejsCameraObjNode<O extends OrthoOrPerspCamera, K extends BaseThreejsCameraObjParamsConfig> extends TypedCameraObjNode<O, K> {
	readonly flags: FlagsControllerD;
	readonly hierarchyController: HierarchyController;
	readonly transformController: TransformController;
	protected __layersController__: LayersController | undefined;
	private _layersController;
	readonly childrenDisplayController: ObjChildrenDisplayController;
	readonly displayNodeController: DisplayNodeController;
	protected _childrenControllerContext: NodeContext;
	initializeBaseNode(): void;
	createNode<S extends keyof GeoNodeChildrenMap>(node_class: S, options?: NodeCreateOptions): GeoNodeChildrenMap[S];
	createNode<K extends valueof<GeoNodeChildrenMap>>(node_class: Constructor<K>, options?: NodeCreateOptions): K;
	children(): BaseSopNodeType[];
	nodesByType<K extends keyof GeoNodeChildrenMap>(type: K): GeoNodeChildrenMap[K][];
	cook(): Promise<void>;
	static PARAM_CALLBACK_update_near_far_from_param(node: BaseThreejsCameraObjNodeType, param: BaseParamType): void;
	updateNearFar(): void;
	createViewer(options?: BaseViewerOptions | HTMLElement): Promise<ThreejsViewer<Camera> | undefined>;
	private _helper;
	initHelperHook(): void;
	helperVisible(): boolean;
	private _createHelper;
	_updateHelper(): void;
}
type BaseCameraObjNodeType = TypedCameraObjNode<OrthoOrPerspCamera, BaseCameraObjParamsConfig>;
type BaseThreejsCameraObjNodeType = TypedThreejsCameraObjNode<OrthoOrPerspCamera, BaseThreejsCameraObjParamsConfig>;
declare const OrthographicCameraObjParamConfig_base: {
	new (...args: any[]): {
		doPostProcess: ParamTemplate<ParamType.BOOLEAN>;
		postProcessNode: ParamTemplate<ParamType.NODE_PATH>;
	};
} & {
	new (...args: any[]): {
		render: ParamTemplate<ParamType.FOLDER>;
		setScene: ParamTemplate<ParamType.BOOLEAN>;
		scene: ParamTemplate<ParamType.NODE_PATH>;
		setRenderer: ParamTemplate<ParamType.BOOLEAN>;
		renderer: ParamTemplate<ParamType.NODE_PATH>;
		setCSSRenderer: ParamTemplate<ParamType.BOOLEAN>;
		CSSRenderer: ParamTemplate<ParamType.NODE_PATH>;
	};
} & {
	new (...args: any[]): {
		layer: ParamTemplate<ParamType.INTEGER>;
	};
} & {
	new (...args: any[]): {
		setMainCamera: ParamTemplate<ParamType.BUTTON>;
	};
} & {
	new (...args: any[]): {
		frameMode: ParamTemplate<ParamType.INTEGER>;
		expectedAspectRatio: ParamTemplate<ParamType.FLOAT>;
	};
} & {
	new (...args: any[]): {
		size: ParamTemplate<ParamType.FLOAT>;
	};
} & {
	new (...args: any[]): {
		camera: ParamTemplate<ParamType.FOLDER>;
		controls: ParamTemplate<ParamType.NODE_PATH>;
		updateFromControlsMode: ParamTemplate<ParamType.INTEGER>;
		near: ParamTemplate<ParamType.FLOAT>;
		far: ParamTemplate<ParamType.FLOAT>;
		display: ParamTemplate<ParamType.BOOLEAN>;
		showHelper: ParamTemplate<ParamType.BOOLEAN>;
	};
} & {
	new (...args: any[]): {
		transform: ParamTemplate<ParamType.FOLDER>;
		keepPosWhenParenting: ParamTemplate<ParamType.BOOLEAN>;
		rotationOrder: ParamTemplate<ParamType.INTEGER>;
		t: ParamTemplate<ParamType.VECTOR3>;
		r: ParamTemplate<ParamType.VECTOR3>;
		s: ParamTemplate<ParamType.VECTOR3>;
		scale: ParamTemplate<ParamType.FLOAT>;
		matrixAutoUpdate: ParamTemplate<ParamType.BOOLEAN>;
		updateTransformFromObject: ParamTemplate<ParamType.BUTTON>;
	};
} & typeof NodeParamsConfig;
declare class OrthographicCameraObjParamConfig extends OrthographicCameraObjParamConfig_base {
}
declare class OrthographicCameraObjNode extends TypedThreejsCameraObjNode<OrthographicCamera, OrthographicCameraObjParamConfig> {
	paramsConfig: OrthographicCameraObjParamConfig;
	static type(): Readonly<CameraNodeType.ORTHOGRAPHIC>;
	static onRegister: OnNodeRegisterCallback;
	createObject(): OrthographicCamera;
	updateCamera(): void;
}
declare const PerspectiveCameraObjParamConfig_base: {
	new (...args: any[]): {
		useWebXR: ParamTemplate<ParamType.BOOLEAN>;
		useAR: ParamTemplate<ParamType.BOOLEAN>;
		useVR: ParamTemplate<ParamType.BOOLEAN>;
	};
} & {
	new (...args: any[]): {
		doPostProcess: ParamTemplate<ParamType.BOOLEAN>;
		postProcessNode: ParamTemplate<ParamType.NODE_PATH>;
	};
} & {
	new (...args: any[]): {
		render: ParamTemplate<ParamType.FOLDER>;
		setScene: ParamTemplate<ParamType.BOOLEAN>;
		scene: ParamTemplate<ParamType.NODE_PATH>;
		setRenderer: ParamTemplate<ParamType.BOOLEAN>;
		renderer: ParamTemplate<ParamType.NODE_PATH>;
		setCSSRenderer: ParamTemplate<ParamType.BOOLEAN>;
		CSSRenderer: ParamTemplate<ParamType.NODE_PATH>;
	};
} & {
	new (...args: any[]): {
		layer: ParamTemplate<ParamType.INTEGER>;
	};
} & {
	new (...args: any[]): {
		setMainCamera: ParamTemplate<ParamType.BUTTON>;
	};
} & {
	new (...args: any[]): {
		frameMode: ParamTemplate<ParamType.INTEGER>;
		expectedAspectRatio: ParamTemplate<ParamType.FLOAT>;
	};
} & {
	new (...args: any[]): {
		fov: ParamTemplate<ParamType.FLOAT>;
	};
} & {
	new (...args: any[]): {
		camera: ParamTemplate<ParamType.FOLDER>;
		controls: ParamTemplate<ParamType.NODE_PATH>;
		updateFromControlsMode: ParamTemplate<ParamType.INTEGER>;
		near: ParamTemplate<ParamType.FLOAT>;
		far: ParamTemplate<ParamType.FLOAT>;
		display: ParamTemplate<ParamType.BOOLEAN>;
		showHelper: ParamTemplate<ParamType.BOOLEAN>;
	};
} & {
	new (...args: any[]): {
		transform: ParamTemplate<ParamType.FOLDER>;
		keepPosWhenParenting: ParamTemplate<ParamType.BOOLEAN>;
		rotationOrder: ParamTemplate<ParamType.INTEGER>;
		t: ParamTemplate<ParamType.VECTOR3>;
		r: ParamTemplate<ParamType.VECTOR3>;
		s: ParamTemplate<ParamType.VECTOR3>;
		scale: ParamTemplate<ParamType.FLOAT>;
		matrixAutoUpdate: ParamTemplate<ParamType.BOOLEAN>;
		updateTransformFromObject: ParamTemplate<ParamType.BUTTON>;
	};
} & typeof NodeParamsConfig;
declare class PerspectiveCameraObjParamConfig extends PerspectiveCameraObjParamConfig_base {
}
declare class PerspectiveCameraObjNode extends TypedThreejsCameraObjNode<PerspectiveCamera, PerspectiveCameraObjParamConfig> {
	paramsConfig: PerspectiveCameraObjParamConfig;
	static type(): Readonly<CameraNodeType.PERSPECTIVE>;
	static onRegister: OnNodeRegisterCallback;
	createObject(): PerspectiveCamera;
	updateCamera(): void;
}
declare class BaseManagerObjNode<K extends NodeParamsConfig> extends TypedObjNode<Group, K> {
	protected _attachableToHierarchy: boolean;
	createObject(): Group;
	cook(): void;
}
declare class ParamLessObjParamsConfig extends NodeParamsConfig {
}
declare class ParamLessBaseManagerObjNode extends BaseManagerObjNode<ParamLessObjParamsConfig> {
}
declare class ActorsNetworkObjNode extends ParamLessBaseManagerObjNode {
	static type(): NetworkNodeType;
	protected _childrenControllerContext: NodeContext;
	createNode<S extends keyof JsNodeChildrenMap>(node_class: S, options?: NodeCreateOptions): JsNodeChildrenMap[S];
	createNode<K extends valueof<JsNodeChildrenMap>>(node_class: Constructor<K>, options?: NodeCreateOptions): K;
	children(): BaseJsNodeType[];
	nodesByType<K extends keyof JsNodeChildrenMap>(type: K): JsNodeChildrenMap[K][];
	childrenAllowed(): boolean;
	sceneReadonly(): boolean;
	readonly persisted_config: ActorPersistedConfig;
	assemblerController(): JsAssemblerController<JsAssemblerActor> | undefined;
	usedAssembler(): Readonly<AssemblerName.JS_ACTOR>;
	protected _assemblerController: JsAssemblerController<JsAssemblerActor> | undefined;
	private _createAssemblerController;
	readonly compilationController: ActorCompilationController;
	compile(): void;
	cook(): void;
}
declare class BaseAnimationsObjNode extends ParamLessBaseManagerObjNode {
	static type(): NetworkNodeType;
	protected _childrenControllerContext: NodeContext;
	createNode<S extends keyof AnimNodeChildrenMap>(node_class: S, options?: NodeCreateOptions): AnimNodeChildrenMap[S];
	createNode<K extends valueof<AnimNodeChildrenMap>>(node_class: Constructor<K>, options?: NodeCreateOptions): K;
	children(): BaseAnimNodeType[];
	nodesByType<K extends keyof AnimNodeChildrenMap>(type: K): AnimNodeChildrenMap[K][];
}
declare class AnimationsNetworkObjNode extends BaseAnimationsObjNode {
	readonly renderOrder: number;
}
declare class BaseAudioObjNode extends ParamLessBaseManagerObjNode {
	static type(): NetworkNodeType;
	protected _childrenControllerContext: NodeContext;
	createNode<S extends keyof AudioNodeChildrenMap>(node_class: S, options?: NodeCreateOptions): AudioNodeChildrenMap[S];
	createNode<K extends valueof<AudioNodeChildrenMap>>(node_class: Constructor<K>, options?: NodeCreateOptions): K;
	children(): BaseAudioNodeType[];
	nodesByType<K extends keyof AudioNodeChildrenMap>(type: K): AudioNodeChildrenMap[K][];
}
declare class AudioNetworkObjNode extends BaseAudioObjNode {
	readonly renderOrder: number;
}
declare class CopNetworkObjNode extends ParamLessBaseManagerObjNode {
	static type(): NetworkNodeType;
	protected _childrenControllerContext: NodeContext;
	createNode<S extends keyof CopNodeChildrenMap>(node_class: S, options?: NodeCreateOptions): CopNodeChildrenMap[S];
	createNode<K extends valueof<CopNodeChildrenMap>>(node_class: Constructor<K>, options?: NodeCreateOptions): K;
	children(): BaseCopNodeType[];
	nodesByType<K extends keyof CopNodeChildrenMap>(type: K): CopNodeChildrenMap[K][];
}
declare class EventsNetworkObjNode extends ParamLessBaseManagerObjNode {
	readonly renderOrder: number;
	static type(): NetworkNodeType;
	protected _childrenControllerContext: NodeContext;
	createNode<S extends keyof EventNodeChildrenMap>(node_class: S, options?: NodeCreateOptions): EventNodeChildrenMap[S];
	createNode<K extends valueof<EventNodeChildrenMap>>(node_class: Constructor<K>, options?: NodeCreateOptions): K;
	children(): BaseEventNodeType[];
	nodesByType<K extends keyof EventNodeChildrenMap>(type: K): EventNodeChildrenMap[K][];
}
declare class MaterialsNetworkObjNode extends ParamLessBaseManagerObjNode {
	readonly renderOrder: number;
	static type(): Readonly<NetworkNodeType.MAT>;
	protected _childrenControllerContext: NodeContext;
	createNode<S extends keyof MatNodeChildrenMap>(node_class: S, options?: NodeCreateOptions): MatNodeChildrenMap[S];
	createNode<K extends valueof<MatNodeChildrenMap>>(node_class: Constructor<K>, options?: NodeCreateOptions): K;
	children(): BaseMatNodeType[];
	nodesByType<K extends keyof MatNodeChildrenMap>(type: K): MatNodeChildrenMap[K][];
}
declare class PostProcessNetworkObjNode extends BaseManagerObjNode<PostProcessNetworkParamsConfig> {
	paramsConfig: PostProcessNetworkParamsConfig;
	static type(): NetworkNodeType;
	readonly effectsComposerController: EffectComposerController;
	readonly displayNodeController: DisplayNodeController;
	protected _childrenControllerContext: NodeContext;
	createNode<S extends keyof PostNodeChildrenMap>(node_class: S, options?: NodeCreateOptions): PostNodeChildrenMap[S];
	createNode<K extends valueof<PostNodeChildrenMap>>(node_class: Constructor<K>, options?: NodeCreateOptions): K;
	children(): BasePostProcessNodeType[];
	nodesByType<K extends keyof PostNodeChildrenMap>(type: K): PostNodeChildrenMap[K][];
}
declare class RenderersNetworkObjNode extends ParamLessBaseManagerObjNode {
	readonly renderOrder: number;
	static type(): NetworkNodeType;
	protected _childrenControllerContext: NodeContext;
	createNode<S extends keyof RopNodeChildrenMap>(node_class: S, options?: NodeCreateOptions): RopNodeChildrenMap[S];
	createNode<K extends valueof<RopNodeChildrenMap>>(node_class: Constructor<K>, options?: NodeCreateOptions): K;
	children(): BaseRopNodeType[];
	nodesByType<K extends keyof RopNodeChildrenMap>(type: K): RopNodeChildrenMap[K][];
}
interface ObjNodeChildrenMap {
	ambientLight: AmbientLightObjNode;
	areaLight: AreaLightObjNode;
	audioListener: AudioListenerObjNode;
	blend: BlendObjNode;
	directionalLight: DirectionalLightObjNode;
	geo: GeoObjNode;
	hemisphereLight: HemisphereLightObjNode;
	lightProbe: LightProbeObjNode;
	null: NullObjNode;
	orthographicCamera: OrthographicCameraObjNode;
	perspectiveCamera: PerspectiveCameraObjNode;
	polarTransform: PolarTransformObjNode;
	pointLight: PointLightObjNode;
	positionalAudio: PositionalAudioObjNode;
	rivet: RivetObjNode;
	scene: SceneObjNode;
	spotLight: SpotLightObjNode;
	actorsNetwork: ActorsNetworkObjNode;
	animationsNetwork: AnimationsNetworkObjNode;
	audioNetwork: AudioNetworkObjNode;
	copNetwork: CopNetworkObjNode;
	eventsNetwork: EventsNetworkObjNode;
	materialsNetwork: MaterialsNetworkObjNode;
	postProcessNetwork: PostProcessNetworkObjNode;
	renderersNetwork: RenderersNetworkObjNode;
}
type onToggleSoundCallback = (soundOn: boolean) => void;
declare class RootAudioController {
	protected node: RootManagerNode;
	constructor(node: RootManagerNode);
	toggleSound(): Promise<void>;
	soundOn(): boolean;
	update(): void;
	audioListeners(): AudioListenerObjNode[];
	private _updateViewers;
	static update(node: RootManagerNode): void;
	private _callbacksByName;
	onToggleSound(callbackName: string, callback: onToggleSoundCallback): void;
	private _runOnToggleSoundCallbacks;
}
declare class NodeGroup {
	readonly nodes: BaseNodeType[];
	readonly totalCount: number;
	private _processed;
	private _remaining;
	constructor(nodes: BaseNodeType[]);
	markNodeAsProcessed(node: BaseNodeType): void;
	isNodeProcessed(node: BaseNodeType): boolean;
	processedCount(): number;
}
interface NodeGroups {
	toCook: NodeGroup;
	sopGroupToUpdate: NodeGroup;
}
interface OnProgressArguments {
	scene: PolyScene;
	triggerNode?: BaseNodeType;
	groups: NodeGroups;
}
type OnProgressUpdateCallback = (progressRatio: number, args: OnProgressArguments) => void;
declare class RootLoadProgressController {
	protected node: RootManagerNode;
	constructor(node: RootManagerNode);
	static PARAM_CALLBACK_printResolve(node: RootManagerNode): Promise<void>;
	resolvedNodes(): Promise<BaseNodeType[]>;
	private _loadDisplayNodes;
	private _displayNodes;
	private _objectNodesWithDisplayNodeController;
	cameraCreatorNode(): Promise<BaseNodeType | null>;
	private _nodeGroups;
	private _onProgressUpdateCallback;
	private _runCallback;
	private _updateProgressAndRunCallback;
	watchNodesProgress(callback: OnProgressUpdateCallback): Promise<void>;
	private _watchNodesToCook;
	private _watchNodesWithSopGroup;
	protected static debugActive(): boolean;
	static debug(arg0: any): void;
	static debug2(arg0: any, arg1: any): void;
	protected _debug(arg0: any): void;
	protected _debug2(arg0: any, arg1: any): void;
}
declare class RootMainCameraController {
	protected node: RootManagerNode;
	constructor(node: RootManagerNode);
	setCamera(object: Camera): void;
	setCameraPath(path: string): void;
	mainCameraPathParam(): StringParam;
	rawCameraPath(): string;
	cameraPath(): Promise<string>;
	private _cameraPathSync;
	cameraSync(): Camera | undefined;
	dummyPerspectiveCamera(): PerspectiveCamera;
	cameraSyncOrDummy(): Camera | undefined;
	camera(): Promise<Camera | undefined>;
	cameraCreatorNode(): Promise<BaseNodeType | null>;
}
declare const ObjectsManagerParamsConfig_base: {
	new (...args: any[]): {
		nodesMask: ParamTemplate<ParamType.STRING>;
		printNodes: ParamTemplate<ParamType.BUTTON>;
	};
} & {
	new (...args: any[]): {
		displayAudioIcon: ParamTemplate<ParamType.BOOLEAN>;
		audioIconColor: ParamTemplate<ParamType.COLOR>;
		audioIconStyle: ParamTemplate<ParamType.STRING>;
	};
} & {
	new (...args: any[]): {
		useOverrideMaterial: ParamTemplate<ParamType.BOOLEAN>;
		overrideMaterial: ParamTemplate<ParamType.NODE_PATH>;
	};
} & {
	new (...args: any[]): {
		useEnvironment: ParamTemplate<ParamType.BOOLEAN>;
		environment: ParamTemplate<ParamType.NODE_PATH>;
	};
} & {
	new (...args: any[]): {
		useFog: ParamTemplate<ParamType.BOOLEAN>;
		fogType: ParamTemplate<ParamType.INTEGER>;
		fogColor: ParamTemplate<ParamType.COLOR>;
		fogNear: ParamTemplate<ParamType.FLOAT>;
		fogFar: ParamTemplate<ParamType.FLOAT>;
		fogDensity: ParamTemplate<ParamType.FLOAT>;
	};
} & {
	new (...args: any[]): {
		mainCameraPath: ParamTemplate<ParamType.STRING>;
	};
} & {
	new (...args: any[]): {
		backgroundMode: ParamTemplate<ParamType.INTEGER>;
		bgColor: ParamTemplate<ParamType.COLOR>;
		bgTexture: ParamTemplate<ParamType.NODE_PATH>;
		bgBlur: ParamTemplate<ParamType.FLOAT>;
		bgIntensity: ParamTemplate<ParamType.FLOAT>;
	};
} & {
	new (...args: any[]): {
		autoUpdate: ParamTemplate<ParamType.BOOLEAN>;
	};
} & typeof NodeParamsConfig;
declare class ObjectsManagerParamsConfig extends ObjectsManagerParamsConfig_base {
}
declare class RootManagerNode extends TypedBaseManagerNode<ObjectsManagerParamsConfig> {
	paramsConfig: ObjectsManagerParamsConfig;
	static type(): string;
	protected _object: Scene;
	private _queuedNodesById;
	readonly audioController: RootAudioController;
	readonly sceneAutoUpdateController: SceneAutoUpdateController;
	readonly sceneBackgroundController: SceneBackgroundController;
	readonly sceneEnvController: SceneEnvController;
	readonly sceneFogController: SceneFogController;
	readonly loadProgress: RootLoadProgressController;
	readonly sceneMaterialOverrideController: SceneMaterialOverrideController;
	readonly mainCameraController: RootMainCameraController;
	cook(): void;
	protected _childrenControllerContext: NodeContext;
	initializeNode(): void;
	private _createScene;
	get object(): Scene;
	createNode<S extends keyof ObjNodeChildrenMap>(nodeClass: S, options?: NodeCreateOptions): ObjNodeChildrenMap[S];
	createNode<K extends valueof<ObjNodeChildrenMap>>(nodeClass: Constructor<K>, options?: NodeCreateOptions): K;
	children(): BaseObjNodeType[];
	nodesByType<K extends keyof ObjNodeChildrenMap>(type: K): ObjNodeChildrenMap[K][];
	private _updateScene;
	private _addToQueue;
	processQueue(): void;
	private _updateObject;
	getParentForNode(node: BaseObjNodeType): Scene | Group | null;
	private _addToScene;
	private _removeFromScene;
	areChildrenCooking(): boolean;
	addToParentTransform(node: HierarchyObjNode): void;
	removeFromParentTransform(node: HierarchyObjNode): void;
	private _onChildAdd;
	private _onChildRemove;
}
interface IUniforms {
	[uniform: string]: IUniform;
}
declare enum CustomMaterialName {
	DISTANCE = "customDistanceMaterial",
	DEPTH = "customDepthMaterial",
	DEPTH_DOF = "customDepthDOFMaterial"
}
interface MaterialWithCustomMaterials extends Material {
	customMaterials: {
		[key in CustomMaterialName]?: Material;
	};
}
interface ShaderMaterialWithCustomMaterials extends ShaderMaterial {
	customMaterials: {
		[key in CustomMaterialName]?: Material;
	};
}
interface MaterialData {
	color?: boolean;
	lights?: boolean;
}
interface ToJsonOptions {
	node: BaseNodeType;
	suffix: string;
}
interface DataObjectWithoutShaders {
}
interface PersistedConfigWithShaders extends DataObjectWithoutShaders {
	shaders?: PolyDictionary<string>;
	functionBody?: string | VelocityColliderFunctionBody;
}
declare abstract class BasePersistedConfig {
	protected node: BaseNodeType;
	constructor(node: BaseNodeType);
	abstract toData(): Promise<PersistedConfigWithShaders | void>;
	load(data: object): void;
	toDataWithoutShaders(): Promise<DataObjectWithoutShaders | void>;
	protected _materialToJson(material: Material, options: ToJsonOptions): object | undefined;
	private _withPreparedMaterial;
	private _withUnassignedOnBeforeCompileData;
	private _withUnassignedUniformTextures;
	private _withUnassignedBasePropertyTextures;
	protected _loadMaterial(data: MaterialData): ShaderMaterialWithCustomMaterials | undefined;
	private mat4ToMat3;
}
interface PointBuilderFunctionDataAttributeDataItem {
	attribName: string;
	attribType: JsConnectionPointType;
}
interface PointBuilderFunctionDataAttributeDataReadWrite {
	read: PointBuilderFunctionDataAttributeDataItem[];
	write: PointBuilderFunctionDataAttributeDataItem[];
}
interface PointBuilderFunctionData extends SingleBodyFunctionData {
	attributesData: PointBuilderFunctionDataAttributeDataReadWrite;
}
interface PointBuilderPersistedConfigBaseJsData extends SingleBodyPersistedConfigBaseJsData {
	functionBody: string;
	variableNames: string[];
	variables: SerializedVariable<SerializedVariableType>[];
	functionNames: Array<keyof NamedFunctionMap>;
	serializedParamConfigs: JsParamConfigJSON<ParamType>[];
	attributesData: PointBuilderFunctionDataAttributeDataReadWrite;
}
declare class BasePointBuilderPersistedConfig extends BasePersistedConfig {
	protected node: PointBuilderSopNode | InstanceBuilderSopNode;
	constructor(node: PointBuilderSopNode | InstanceBuilderSopNode);
	toData(): Promise<PointBuilderPersistedConfigBaseJsData | undefined>;
	load(data: PointBuilderPersistedConfigBaseJsData): void;
}
declare enum AttributeJsNodeInput {
	EXPORT = "export"
}
declare enum AttributeJsNodeOutput {
	VAL = "val"
}
declare class AttributeJsParamsConfig extends NodeParamsConfig {
	name: ParamTemplate<ParamType.STRING>;
	type: ParamTemplate<ParamType.INTEGER>;
	/** @param allows to export the attribute */
	exportWhenConnected: ParamTemplate<ParamType.BOOLEAN>;
}
declare class AttributeJsNode extends TypedJsNode<AttributeJsParamsConfig> {
	paramsConfig: AttributeJsParamsConfig;
	static type(): JsType;
	initializeNode(): void;
	private _expectedInputTypes;
	private _expectedOutputType;
	inputName(): AttributeJsNodeInput;
	outputName(): AttributeJsNodeOutput;
	setLines(linesController: JsLinesCollectionController): void;
	attribData(): PointBuilderFunctionDataAttributeDataItem;
	attributeName(): string;
	jsType(): JsConnectionPointType;
	setJsType(type: JsConnectionPointType): void;
	connected_input_node(): BaseJsNodeType | null;
	connected_input_connection_point(): BaseJsConnectionPoint | undefined;
	output_connection_point(): BaseJsConnectionPoint | undefined;
	isImporting(): boolean;
	isExporting(): boolean;
}
declare abstract class GlobalsJsBaseController {
	private static __next_id;
	private _id;
	constructor();
	id(): number;
	handle_globals_node(globals_node: GlobalsJsNode, output_name: string, linesController: JsLinesCollectionController): void;
	handleGlobalVar(globals_node: BaseJsNodeType, output_name: string, glType: JsConnectionPointType, linesController: JsLinesCollectionController): void;
	abstract readAttribute(node: BaseJsNodeType, gl_type: JsConnectionPointType, attrib_name: string, linesController: JsLinesCollectionController): string | undefined;
}
type StringArrayByJsFunctionName = Map<JsFunctionName, string[]>;
interface SpareParamOptions {
	type: ParamType;
}
interface BaseFunctionData {
	variableNames: string[];
	variablesByName: Record<string, RegisterableVariable>;
	functionNames: Array<keyof NamedFunctionMap>;
	functionsByName: Record<string, Function>;
	paramConfigs: JsParamConfig<ParamType>[];
}
interface VelocityColliderFunctionBody {
	velocity: string;
	collider: string;
}
interface SingleBodyFunctionData extends BaseFunctionData {
	functionBody: string;
}
interface VelocityColliderFunctionData extends BaseFunctionData {
	functionBody: VelocityColliderFunctionBody;
}
interface JsTemplateShader {
	main?: string;
	velocity?: string;
	collider?: string;
}
declare abstract class BaseJsShaderAssembler extends TypedAssembler<NodeContext.JS> {
	protected _jsParentNode: AssemblerControllerNode<BaseJsShaderAssembler>;
	protected _shaders_by_name: Map<JsFunctionName, string>;
	protected _lines: StringArrayByJsFunctionName;
	protected _codeBuilder: JsCodeBuilder | undefined;
	private _param_config_owner;
	protected _root_nodes: BaseJsNodeType[];
	protected _leaf_nodes: BaseJsNodeType[];
	protected _material: ShaderMaterial | undefined;
	private _shader_configs;
	private _variable_configs;
	private _uniformsTimeDependent;
	private _uniformsResolutionDependent;
	private _computedVarNames;
	constructor(_jsParentNode: AssemblerControllerNode<BaseJsShaderAssembler>);
	perPoint(): boolean;
	protected _overridenJsParentNode: AssemblerControllerNode<BaseJsShaderAssembler> | undefined;
	setJsParentNode(parentNode: AssemblerControllerNode<BaseJsShaderAssembler>): void;
	currentJsParentNode(): AssemblerControllerNode<BaseJsShaderAssembler>;
	abstract makeFunctionNodeDirtyOnChange(): boolean;
	addComputedVarName(varName: string): void;
	registeredAsComputed(varName: string): boolean;
	computedVariablesAllowed(): boolean;
	memberReference(varName: string): string;
// @ts-ignore
	abstract spareParamsOptions(options: SpareParamOptions): ParamOptions;
	compile(): void;
	abstract defaultObject3DVariable(): string;
	abstract defaultObject3DMaterialVariable(): string;
	abstract defaultPointIndexVariable(): string;
	protected _template_shader_for_shader_name(shaderName: JsFunctionName): string | undefined;
	globalsHandler(): GlobalsJsBaseController | undefined;
	compileAllowed(): boolean;
	shaders_by_name(): Map<JsFunctionName, string>;
	protected _buildLines(): void;
	set_root_nodes(root_nodes: BaseJsNodeType[]): void;
	protected templateShader(): JsTemplateShader | undefined;
	protected _reset(): void;
	updateFunction(): void;
	rootNodesByShaderName(shaderName: JsFunctionName, rootNodes: BaseJsNodeType[]): BaseJsNodeType[];
	setNodeLinesGlobals(globalsNode: GlobalsJsNode, linesController: JsLinesCollectionController): void;
	setNodeLinesOutput(outputNode: OutputJsNode, linesController: JsLinesCollectionController): void;
	setNodeLinesAttribute(attributeNode: AttributeJsNode, linesController: JsLinesCollectionController): void;
	codeBuilder(): JsCodeBuilder;
	private _createCodeBuilder;
	protected buildCodeFromNodes(rootNodes: BaseJsNodeType[], codeBuilderOptions?: CodeBuilderSetCodeLinesOptions): void;
	allow_new_param_configs(): void;
	disallow_new_param_configs(): void;
	builder_param_configs(): readonly JsParamConfig<ParamType>[];
	builder_lines(shader_name: JsFunctionName, line_type: LineType): string[];
	all_builder_lines(): Map<JsFunctionName, Map<LineType, string[]>>;
	param_configs(): readonly JsParamConfig<ParamType>[];
	set_param_configs_owner(param_config_owner: JsCodeBuilder): void;
	static output_input_connection_points(): JsConnectionPoint<JsConnectionPointType>[];
	add_output_inputs(output_child: OutputJsNode): void;
	static create_globals_node_output_connections(): never[];
	create_globals_node_output_connections(): never[];
	add_globals_outputs(globals_node: GlobalsJsNode): void;
	allow_attribute_exports(): boolean;
	resetConfigs(): void;
	shaderConfigs(): JsShaderConfig[];
	set_shader_configs(shader_configs: JsShaderConfig[]): void;
	shaderNames(): JsFunctionName[];
	protected _reset_shader_configs(): void;
	create_shader_configs(): JsShaderConfig[];
	shader_config(name: string): JsShaderConfig | undefined;
	variable_configs(): VariableConfig[];
	set_variable_configs(variable_configs: VariableConfig[]): void;
	variable_config(name: string): VariableConfig;
	static create_variable_configs(): VariableConfig[];
	create_variable_configs(): VariableConfig[];
	protected _reset_variable_configs(): void;
	inputNamesForShaderName(rootNode: BaseJsNodeType, shaderName: JsFunctionName): string[];
	protected _resetUniformsTimeDependency(): void;
	setUniformsTimeDependent(): void;
	uniformsTimeDependent(): boolean;
	protected _resetUniformsResolutionDependency(): void;
	setUniformsResolutionDependent(): void;
	uniformsResolutionDependent(): boolean;
	protected _raymarchingLightsWorldCoordsDependent(): boolean;
	protected insertMemberAfter(shaderName: JsFunctionName): string | undefined;
	protected insertDefineAfter(shaderName: JsFunctionName): string | undefined;
	protected insertConstructorAfter(shaderName: JsFunctionName): string | undefined;
	protected insertBodyAfter(shaderName: JsFunctionName): string | undefined;
	protected linesToRemove(shaderName: JsFunctionName): string[] | undefined;
	private _replaceTemplate;
	private _insertLines;
	private _registeredVariables;
	private _registeredVariablesCountByNode;
	addVariable(node: BaseJsNodeType, variable: RegisterableVariable, varName?: string): string;
	traverseRegisteredVariables(callback: (variable: RegisterableVariable, varName: string) => void): void;
	protected _resetRegisteredVariables(): void;
	private _registeredFunctions;
	addFunction(node: BaseJsNodeType, namedFunction: BaseNamedFunction): void;
	traverseRegisteredFunctions(callback: (variable: BaseNamedFunction) => void): void;
	protected _resetRegisteredFunctions(): void;
}
declare class BaseJsParentNode extends TypedNode<any, any> {
	createNode<S extends keyof JsNodeChildrenMap>(node_class: S, options?: NodeCreateOptions): JsNodeChildrenMap[S];
	createNode<K extends valueof<JsNodeChildrenMap>>(node_class: Constructor<K>, options?: NodeCreateOptions): K;
	children(): BaseJsNodeType[];
	nodesByType<K extends keyof JsNodeChildrenMap>(type: K): JsNodeChildrenMap[K][];
}
declare abstract class AssemblerControllerNode<A extends BaseJsShaderAssembler> extends BaseJsParentNode {
	abstract assemblerController(): JsAssemblerController<A> | undefined;
	abstract compile(): void;
}
type BaseJsShaderAssemblerConstructor<A extends BaseJsShaderAssembler> = new (...args: any[]) => A;
declare class JsAssemblerController<A extends BaseJsShaderAssembler> {
	private node;
	protected _assembler: A;
	private _spareParamsController;
	private _globalsHandler;
	private _compileRequired;
	constructor(node: AssemblerControllerNode<A>, assembler_class: BaseJsShaderAssemblerConstructor<A>);
	setAssemblerGlobalsHandler(globalsHandler: GlobalsJsBaseController): void;
	get assembler(): A;
	globalsHandler(): GlobalsJsBaseController | undefined;
	add_output_inputs(output_child: OutputJsNode): void;
	add_globals_outputs(globals_node: GlobalsJsNode): void;
	allow_attribute_exports(): boolean;
	setCompilationRequired(newState?: boolean): void;
	setCompilationRequiredAndDirty(triggerNode?: BaseJsNodeType): void;
	compileRequired(): boolean;
	post_compile(): void;
	createSpareParameters(): void;
}
declare class TypedJsNode<K extends NodeParamsConfig> extends TypedNode<NodeContext.JS, K> {
	static context(): NodeContext;
	protected _param_configs_controller: ParamConfigsController<JsParamConfig<ParamType>> | undefined;
	private _paramsEditableStatesController;
	eventData(): EvaluatorEventData | EvaluatorEventData[] | undefined;
	isTriggering(): boolean;
	initializeBaseNode(): void;
	cook(): void;
	private __setFunctionNodeToRecompileAllowed;
	protected _setFunctionNodeToRecompileAllowed(state: boolean): void;
	protected _setFunctionNodeToRecompile(): void;
	functionNode(): AssemblerControllerNode<BaseJsShaderAssembler> | undefined;
	jsVarName(name: string): string;
	inputVarName(inputName: string): string;
	static inputVarName(node: BaseJsNodeType, inputName: string): string;
	variableForInputParam(shadersCollectionController: JsLinesCollectionController, param: IntegerParam | FloatParam | Vector2Param | Vector3Param | Vector4Param | ColorParam | BooleanParam | StringParam): string;
	variableForInput(shadersCollectionController: JsLinesCollectionController, inputName: string): string;
	private _variableForInput;
	setLines(shadersCollectionController: JsLinesCollectionController): void;
	setTriggeringLines(shadersCollectionController: JsLinesCollectionController, triggeredMethods: string): void;
	setTriggerableLines(shadersCollectionController: JsLinesCollectionController): void;
	reset_code(): void;
	paramsGenerating(): boolean;
	setParamConfigs(): void;
	param_configs(): readonly JsParamConfig<ParamType>[] | undefined;
}
type BaseJsNodeType = TypedJsNode<NodeParamsConfig>;
declare class ParamlessJsParamsConfig extends NodeParamsConfig {
}
declare class ParamlessTypedJsNode extends TypedJsNode<ParamlessJsParamsConfig> {
	paramsConfig: ParamlessJsParamsConfig;
}
type BooleanByCoreGraphNodeId = Map<CoreGraphNodeId, boolean>;
type BooleanByStringByShaderName<NC extends NodeContext> = Map<ShaderNameByContextMap[NC], BooleanByCoreGraphNodeId>;
type InputNamesByShaderNameMethod<NC extends NodeContext> = (root_node: BaseNodeByContextMap[NC], shader_name: ShaderNameByContextMap[NC]) => string[];
interface NodeTraverserOptions {
	traverseChildren?: boolean;
}
declare class TypedNodeTraverser<NC extends NodeContext> {
	private _parent_node;
	private _shader_names;
	private _inputNamesForShaderNameMethod;
	private _options?;
	protected _leaves_graph_id: BooleanByStringByShaderName<NC>;
	protected _graph_ids_by_shader_name: BooleanByStringByShaderName<NC>;
	private _outputs_by_graph_id;
	private _depth_by_graph_id;
	private _graph_id_by_depth;
	protected _graph: CoreGraph;
	protected _shaderName: ShaderNameByContextMap[NC];
	constructor(_parent_node: TypedNode<NC, any>, _shader_names: ShaderNameByContextMap[NC][], _inputNamesForShaderNameMethod: InputNamesByShaderNameMethod<NC>, _options?: NodeTraverserOptions | undefined);
	private _traverseChildren;
	private reset;
	shaderNames(): ShaderNameByContextMap[NC][];
	inputNamesForShaderName(root_node: BaseNodeByContextMap[NC], shader_name: ShaderNameByContextMap[NC]): string[];
	traverse(rootNodes: BaseNodeByContextMap[NC][]): void;
	nodesForShaderName(shaderName: ShaderNameByContextMap[NC]): BaseNodeByContextMap[NC][];
	sortedNodes(): BaseNodeByContextMap[NC][];
	private _addNodesWithChildren;
	private _findLeavesFromRootNode;
	private _blockedInputNames;
	setBlockedInputNames(nodeType: string, inputNames: string[]): void;
	protected _findLeaves(node: BaseNodeByContextMap[NC]): void;
	getNodeInputs(node: BaseNodeByContextMap[NC]): (BaseObjNodeType | BaseSopNodeType | BaseAnimNodeType | BaseAudioNodeType | BaseCopNodeType | BaseEventNodeType | BaseGlNodeType | BaseJsNodeType | BaseManagerNodeType | BaseMatNodeType | BasePostProcessNodeType | BaseRopNodeType | null)[];
	private _findInputs;
	private _setNodesDepth;
	private _setNodeDepth;
}
type RootNodesForShaderMethod = (shader_name: ShaderName, rootNodes: BaseGlNodeType[]) => BaseGlNodeType[];
interface CodeBuilderSetCodeLinesOptions {
// @ts-ignore
	otherFragmentShaderCollectionController?: ShadersCollectionController;
}
declare class CodeBuilder {
	private _nodeTraverser;
	private _root_nodes_for_shader_method;
	private _assembler;
	private _param_configs_controller;
	private _param_configs_set_allowed;
	private _shadersCollectionController;
	private _lines;
	constructor(_nodeTraverser: TypedNodeTraverser<NodeContext.GL>, _root_nodes_for_shader_method: RootNodesForShaderMethod, _assembler: TypedAssembler<NodeContext.GL>);
	nodeTraverser(): TypedNodeTraverser<NodeContext.GL>;
	shaderNames(): ShaderName[];
	buildFromNodes(rootNodes: BaseGlNodeType[], paramNodes: BaseGlNodeType[], setCodeLinesOptions?: CodeBuilderSetCodeLinesOptions): void;
	shadersCollectionController(): ShadersCollectionController | undefined;
	disallow_new_param_configs(): void;
	allow_new_param_configs(): void;
	private reset;
	param_configs(): readonly GlParamConfig<ParamType>[];
	lines(shader_name: ShaderName, line_type: LineType): string[];
	all_lines(): Map<ShaderName, Map<LineType, string[]>>;
	setParamConfigs(nodes: BaseGlNodeType[]): void;
	private _setCodeLines;
	private _addCodeLines;
	private addDefinitions;
	add_code_line_for_nodes_and_line_type(nodes: BaseGlNodeType[], shader_name: ShaderName, line_type: LineType): void;
	add_code_line_for_node_and_line_type(node: BaseGlNodeType, shader_name: ShaderName, line_type: LineType, is_last: boolean): void;
}
declare abstract class GlobalsBaseController {
	private static __next_id;
	private _id;
	constructor();
	id(): number;
	handle_globals_node(globals_node: GlobalsGlNode, output_name: string, shaders_collection_controller: ShadersCollectionController): void;
	handleGlobalVar(globals_node: BaseGlNodeType, output_name: string, glType: GlConnectionPointType, shaders_collection_controller: ShadersCollectionController): void;
	abstract readAttribute(node: BaseGlNodeType, gl_type: GlConnectionPointType, attrib_name: string, shaders_collection_controller: ShadersCollectionController): string | undefined;
}
type StringArrayByShaderName = Map<ShaderName, string[]>;
interface ITemplateShader {
	vertexShader?: string;
	fragmentShader?: string;
	uniforms?: IUniforms;
}
declare class BaseGlShaderAssembler extends TypedAssembler<NodeContext.GL> {
	protected _gl_parent_node: AssemblerGlControllerNode;
	protected _shaders_by_name: Map<ShaderName, string>;
	protected _lines: StringArrayByShaderName;
	protected _codeBuilder: CodeBuilder | undefined;
	private _param_config_owner;
	protected _root_nodes: BaseGlNodeType[];
	protected _leaf_nodes: BaseGlNodeType[];
	protected _material: ShaderMaterial | undefined;
	private _shader_configs;
	private _variable_configs;
	private _uniformsTimeDependent;
	private _uniformsResolutionDependent;
	constructor(_gl_parent_node: AssemblerGlControllerNode);
	protected _overriden_gl_parent_node: AssemblerGlControllerNode | undefined;
	setGlParentNode(gl_parent_node: AssemblerGlControllerNode): void;
	currentGlParentNode(): AssemblerGlControllerNode;
	compile(): void;
	protected _template_shader_for_shader_name(shader_name: ShaderName): string | undefined;
	globalsHandler(): GlobalsBaseController | undefined;
	compileAllowed(): boolean;
	shaders_by_name(): Map<ShaderName, string>;
	protected _buildLines(): void;
	set_root_nodes(root_nodes: BaseGlNodeType[]): void;
	protected templateShader(): ITemplateShader | undefined;
	rootNodesByShaderName(shaderName: ShaderName, rootNodes: BaseGlNodeType[]): BaseGlNodeType[];
	set_node_lines_globals(globals_node: GlobalsGlNode, shaders_collection_controller: ShadersCollectionController): void;
	set_node_lines_output(output_node: OutputGlNode, shaders_collection_controller: ShadersCollectionController): void;
	setNodeLinesAttribute(attribute_node: AttributeGlNode, shaders_collection_controller: ShadersCollectionController): void;
	codeBuilder(): CodeBuilder;
	protected _resetCodeBuilder(): void;
	private _createCodeBuilder;
	protected buildCodeFromNodes(rootNodes: BaseGlNodeType[], codeBuilderOptions?: CodeBuilderSetCodeLinesOptions): void;
	allow_new_param_configs(): void;
	disallow_new_param_configs(): void;
	builder_param_configs(): readonly GlParamConfig<ParamType>[];
	builder_lines(shader_name: ShaderName, line_type: LineType): string[];
	all_builder_lines(): Map<ShaderName, Map<LineType, string[]>>;
	param_configs(): readonly GlParamConfig<ParamType>[];
	set_param_configs_owner(param_config_owner: CodeBuilder): void;
	static output_input_connection_points(): GlConnectionPoint<GlConnectionPointType>[];
	add_output_inputs(output_child: OutputGlNode): void;
	static create_globals_node_output_connections(): (GlConnectionPoint<GlConnectionPointType.VEC3> | GlConnectionPoint<GlConnectionPointType.VEC2> | GlConnectionPoint<GlConnectionPointType.VEC4> | GlConnectionPoint<GlConnectionPointType.FLOAT> | GlConnectionPoint<GlConnectionPointType.MAT4> | GlConnectionPoint<GlConnectionPointType.MAT3>)[];
	create_globals_node_output_connections(): (GlConnectionPoint<GlConnectionPointType.VEC3> | GlConnectionPoint<GlConnectionPointType.VEC2> | GlConnectionPoint<GlConnectionPointType.VEC4> | GlConnectionPoint<GlConnectionPointType.FLOAT> | GlConnectionPoint<GlConnectionPointType.MAT4> | GlConnectionPoint<GlConnectionPointType.MAT3>)[];
	add_globals_outputs(globals_node: GlobalsGlNode): void;
	allow_attribute_exports(): boolean;
	reset_configs(): void;
	shaderConfigs(): ShaderConfig[];
	set_shader_configs(shader_configs: ShaderConfig[]): void;
	shaderNames(): ShaderName[];
	protected _reset_shader_configs(): void;
	create_shader_configs(): ShaderConfig[];
	shader_config(name: string): ShaderConfig | undefined;
	variable_configs(): VariableConfig[];
	set_variable_configs(variable_configs: VariableConfig[]): void;
	variable_config(name: string): VariableConfig;
	static create_variable_configs(): VariableConfig[];
	create_variable_configs(): VariableConfig[];
	protected _reset_variable_configs(): void;
	inputNamesForShaderName(root_node: BaseGlNodeType, shader_name: ShaderName): string[];
	protected _resetUniformsTimeDependency(): void;
	setUniformsTimeDependent(): void;
	uniformsTimeDependent(): boolean;
	protected _resetUniformsResolutionDependency(): void;
	setUniformsResolutionDependent(): void;
	uniformsResolutionDependent(): boolean;
	protected _raymarchingLightsWorldCoordsDependent(): boolean;
	protected insertDefineAfter(shaderName: ShaderName): string | undefined;
	protected insertBodyAfter(shaderName: ShaderName): string | undefined;
	protected linesToRemove(shaderName: ShaderName): string[] | undefined;
	private _replaceTemplate;
	private _insertLines;
	_addFilterFragmentShaderCallback(callbackName: string, callback: (s: string) => string): void;
	_removeFilterFragmentShaderCallback(callbackName: string): void;
	getCustomMaterials(): Map<CustomMaterialName, ShaderMaterial>;
	static expandShader(shader_string: string): string;
}
declare class BaseGlParentNode extends TypedNode<any, any> {
	createNode<S extends keyof GlNodeChildrenMap>(node_class: S, options?: NodeCreateOptions): GlNodeChildrenMap[S];
	createNode<K extends valueof<GlNodeChildrenMap>>(node_class: Constructor<K>, options?: NodeCreateOptions): K;
	children(): BaseGlNodeType[];
	nodesByType<K extends keyof GlNodeChildrenMap>(type: K): GlNodeChildrenMap[K][];
}
declare abstract class AssemblerGlControllerNode extends BaseGlParentNode {
	abstract assemblerController(): GlAssemblerController<BaseGlShaderAssembler> | undefined;
}
type BaseGlShaderAssemblerConstructor<A extends BaseGlShaderAssembler> = new (...args: any[]) => A;
declare class GlAssemblerController<A extends BaseGlShaderAssembler> {
	private node;
	protected _assembler: A;
	private _spareParamsController;
	private _globalsHandler;
	private _compile_required;
	constructor(node: AssemblerGlControllerNode, assembler_class: BaseGlShaderAssemblerConstructor<A>);
	setAssemblerGlobalsHandler(globalsHandler: GlobalsBaseController): void;
	get assembler(): A;
	globalsHandler(): GlobalsBaseController | undefined;
	add_output_inputs(output_child: OutputGlNode): void;
	add_globals_outputs(globals_node: GlobalsGlNode): void;
	allow_attribute_exports(): boolean;
	setCompilationRequired(newState?: boolean): void;
	setCompilationRequiredAndDirty(triggerNode?: BaseGlNodeType): void;
	compileRequired(): boolean;
	post_compile(): void;
	createSpareParameters(): void;
	addFilterFragmentShaderCallback(callbackName: string, callback: (s: string) => string): void;
	removeFilterFragmentShaderCallback(callbackName: string): void;
}
interface AssemblersMap extends PolyDictionary<ControllerAssemblerPair> {
	[AssemblerName.GL_MESH_BASIC]: {
		controller: GlAssemblerController<ShaderAssemblerBasic>;
		assembler: typeof ShaderAssemblerBasic;
	};
	[AssemblerName.GL_CLOTH]: {
		controller: GlAssemblerController<ShaderAssemblerCloth>;
		assembler: typeof ShaderAssemblerCloth;
	};
	[AssemblerName.GL_MESH_LAMBERT]: {
		controller: GlAssemblerController<ShaderAssemblerLambert>;
		assembler: typeof ShaderAssemblerLambert;
	};
	[AssemblerName.GL_MESH_PHONG]: {
		controller: GlAssemblerController<ShaderAssemblerPhong>;
		assembler: typeof ShaderAssemblerPhong;
	};
	[AssemblerName.GL_MESH_STANDARD]: {
		controller: GlAssemblerController<ShaderAssemblerStandard>;
		assembler: typeof ShaderAssemblerStandard;
	};
	[AssemblerName.GL_MESH_PHYSICAL]: {
		controller: GlAssemblerController<ShaderAssemblerPhysical>;
		assembler: typeof ShaderAssemblerPhysical;
	};
	[AssemblerName.GL_MESH_TOON]: {
		controller: GlAssemblerController<ShaderAssemblerToon>;
		assembler: typeof ShaderAssemblerToon;
	};
	[AssemblerName.GL_MESH_DEPTH]: {
		controller: GlAssemblerController<ShaderAssemblerCustomMeshDepthForRender>;
		assembler: typeof ShaderAssemblerCustomMeshDepthForRender;
	};
	[AssemblerName.GL_MESH_DISTANCE]: {
		controller: GlAssemblerController<ShaderAssemblerCustomMeshDistanceForRender>;
		assembler: typeof ShaderAssemblerCustomMeshDistanceForRender;
	};
	[AssemblerName.GL_PARTICLES]: {
		controller: GlAssemblerController<ShaderAssemblerParticles>;
		assembler: typeof ShaderAssemblerParticles;
	};
	[AssemblerName.GL_POINTS]: {
		controller: GlAssemblerController<ShaderAssemblerPoints>;
		assembler: typeof ShaderAssemblerPoints;
	};
	[AssemblerName.GL_LINE]: {
		controller: GlAssemblerController<ShaderAssemblerLine>;
		assembler: typeof ShaderAssemblerLine;
	};
	[AssemblerName.GL_POST]: {
		controller: GlAssemblerController<ShaderAssemblerPost>;
		assembler: typeof ShaderAssemblerPost;
	};
	[AssemblerName.GL_RAYMARCHING]: {
		controller: GlAssemblerController<ShaderAssemblerRayMarching>;
		assembler: typeof ShaderAssemblerRayMarching;
	};
	[AssemblerName.GL_TEXTURE]: {
		controller: GlAssemblerController<ShaderAssemblerTexture>;
		assembler: typeof ShaderAssemblerTexture;
	};
	[AssemblerName.GL_TEXTURE_2D_ARRAY]: {
		controller: GlAssemblerController<ShaderAssemblerTexture2DArray>;
		assembler: typeof ShaderAssemblerTexture2DArray;
	};
	[AssemblerName.GL_VOLUME]: {
		controller: GlAssemblerController<ShaderAssemblerVolume>;
		assembler: typeof ShaderAssemblerVolume;
	};
	[AssemblerName.JS_ACTOR]: {
		controller: JsAssemblerController<JsAssemblerActor>;
		assembler: typeof JsAssemblerActor;
	};
	[AssemblerName.JS_INSTANCE_BUILDER]: {
		controller: JsAssemblerController<JsAssemblerInstanceBuilder>;
		assembler: typeof JsAssemblerInstanceBuilder;
	};
	[AssemblerName.JS_OBJECT_BUILDER]: {
		controller: JsAssemblerController<JsAssemblerObjectBuilder>;
		assembler: typeof JsAssemblerObjectBuilder;
	};
	[AssemblerName.JS_POINT_BUILDER]: {
		controller: JsAssemblerController<JsAssemblerPointBuilder>;
		assembler: typeof JsAssemblerPointBuilder;
	};
	[AssemblerName.JS_SDF]: {
		controller: JsAssemblerController<JsAssemblerSDF>;
		assembler: typeof JsAssemblerSDF;
	};
	[AssemblerName.JS_SOFT_BODY]: {
		controller: JsAssemblerController<JsAssemblerSoftBody>;
		assembler: typeof JsAssemblerSoftBody;
	};
}
declare class AssemblersRegister extends BaseAssemblersRegister {
	assembler<K extends keyof AssemblersMap>(node: BaseNodeType, name: K): AssemblersMap[K]["controller"] | undefined;
	unregister<K extends keyof AssemblersMap>(name: K): ControllerAssemblerPair | undefined;
}
interface NamedFunctionRegisterOptions {
	printWarnings?: boolean;
}
declare class BaseNamedFunctionRegister {
	protected _functionByName: Map<string, typeof BaseNamedFunction>;
	register(namedFunction: typeof BaseNamedFunction, options?: NamedFunctionRegisterOptions): void;
}
declare class NamedFunctionRegister extends BaseNamedFunctionRegister {
	getFunction<K extends keyof NamedFunctionMap>(functionName: K, node: BaseNodeType, shadersCollectionController?: JsLinesCollectionController): NamedFunctionMap[K];
}
declare class PolyEngine {
	readonly renderersController: RenderersController;
	readonly scenesRegister: ScenesRegister;
	readonly nodesRegister: NodesRegister;
	readonly operationsRegister: OperationsRegister;
	readonly expressionsRegister: ExpressionRegister;
	readonly assemblersRegister: AssemblersRegister;
	readonly pluginsRegister: PluginsRegister;
	readonly camerasRegister: PolyCamerasRegister;
	readonly modulesRegister: DynamicModulesRegister;
	readonly namedFunctionsRegister: NamedFunctionRegister;
	readonly blobs: BlobsController;
	readonly assetUrls: AssetUrlsController;
	readonly thirdParty: PolyThirdPartyController;
	readonly onObjectsAddRemoveHooks: PolyOnObjectsAddRemoveHooksController;
	readonly onSceneUpdatedHooks: PolyOnSceneUpdatedHooksController;
	readonly specializedChildren: PolySpecializedChildrenController;
	readonly performance: PolyPerformanceformanceController;
	scenesByUuid: PolyDictionary<PolyScene>;
	_env: string | undefined;
	private _playerMode;
	private _logger;
	static _instance_(): PolyEngine;
	private constructor();
	version(): string;
	setPlayerMode(mode: boolean): void;
	playerMode(): boolean;
	dispose(): void;
	registerNode(node: BaseNodeConstructor, tab_menu_category?: string | string[], options?: NodeRegisterOptions): void;
	registerOperation(operation: typeof BaseOperation, options?: OperationRegisterOptions): void;
	registerNamedFunction(namedFunction: typeof BaseNamedFunction, options?: NamedFunctionRegisterOptions): void;
	registerCamera<C extends Camera>(cameraClass: any, viewerCreateCallback: ViewerCreateCallback<C>): void;
	registerCameraNodeType(nodeType: string): void;
	registerPlugin(plugin: PolyPluginInterface): void;
	wrapConfigurePolygonjs(callback: WrapConfigurePolygonjsCallback): void;
	registeredNodes(parentNode: BaseNodeType): PolyDictionary<typeof BaseNodeClass>;
	registeredOperation(parent_context: NodeContext, operation_type: string): typeof BaseOperation | undefined;
	registerModule(module: BaseModule<ModuleName>, options?: ModuleRegisterOptions): void;
	inWorkerThread(): boolean;
	private _libs_controller;
	get libs(): PolyLibsController;
	setEnv(env: string): void;
	env(): string | undefined;
	setLogger(logger: BaseCoreLogger | null): void;
	logger(): BaseCoreLogger | null;
	log(message?: any, ...optionalParams: any[]): void;
	warn(message?: any, ...optionalParams: any[]): void;
	error(message?: any, ...optionalParams: any[]): void;
}
declare const Poly: PolyEngine;
declare class ViewerRaycastersController {
	protected viewer: BaseViewerType;
	pointerEventsController: PointerEventsController;
	constructor(viewer: BaseViewerType);
	setCursor0(cursor: Vector2Like): void;
	raycaster0(): {
		ray: {
			origin: {
				x: number;
				y: number;
				z: number;
				readonly isVector3: true;
				set: (x: number, y: number, z: number) => Vector3;
				setScalar: (scalar: number) => Vector3;
				setX: (x: number) => Vector3;
				setY: (y: number) => Vector3;
				setZ: (z: number) => Vector3;
				setComponent: (index: number, value: number) => Vector3;
				setFromColor: (color: Color) => Vector3;
				getComponent: (index: number) => number;
				clone: () => Vector3;
				copy: (v: Vector3) => Vector3;
				add: (v: Vector3) => Vector3;
				addScalar: (s: number) => Vector3;
				addScaledVector: (v: Vector3, s: number) => Vector3;
				addVectors: (a: Vector3, b: Vector3) => Vector3;
				sub: (a: Vector3) => Vector3;
				subScalar: (s: number) => Vector3;
				subVectors: (a: Vector3, b: Vector3) => Vector3;
				multiply: (v: Vector3) => Vector3;
				multiplyScalar: (s: number) => Vector3;
				multiplyVectors: (a: Vector3, b: Vector3) => Vector3;
				applyEuler: (euler: Euler) => Vector3;
				applyAxisAngle: (axis: Vector3, angle: number) => Vector3;
				applyMatrix3: (m: Matrix3) => Vector3;
				applyNormalMatrix: (m: Matrix3) => Vector3;
				applyMatrix4: (m: Matrix4) => Vector3;
				applyQuaternion: (q: Quaternion) => Vector3;
				project: (camera: Camera) => Vector3;
				unproject: (camera: Camera) => Vector3;
				transformDirection: (m: Matrix4) => Vector3;
				divide: (v: Vector3) => Vector3;
				divideScalar: (s: number) => Vector3;
				min: (v: Vector3) => Vector3;
				max: (v: Vector3) => Vector3;
				clamp: (min: Vector3, max: Vector3) => Vector3;
				clampScalar: (min: number, max: number) => Vector3;
				clampLength: (min: number, max: number) => Vector3;
				floor: () => Vector3;
				ceil: () => Vector3;
				round: () => Vector3;
				roundToZero: () => Vector3;
				negate: () => Vector3;
				dot: (v: Vector3) => number;
				lengthSq: () => number;
				length: () => number;
				lengthManhattan: () => number;
				manhattanLength: () => number;
				manhattanDistanceTo: (v: Vector3) => number;
				normalize: () => Vector3;
				setLength: (l: number) => Vector3;
				lerp: (v: Vector3, alpha: number) => Vector3;
				lerpVectors: (v1: Vector3, v2: Vector3, alpha: number) => Vector3;
				cross: (a: Vector3) => Vector3;
				crossVectors: (a: Vector3, b: Vector3) => Vector3;
				projectOnVector: (v: Vector3) => Vector3;
				projectOnPlane: (planeNormal: Vector3) => Vector3;
				reflect: (vector: Vector3) => Vector3;
				angleTo: (v: Vector3) => number;
				distanceTo: (v: Vector3) => number;
				distanceToSquared: (v: Vector3) => number;
				distanceToManhattan: (v: Vector3) => number;
				setFromSpherical: (s: Spherical) => Vector3;
				setFromSphericalCoords: (r: number, phi: number, theta: number) => Vector3;
				setFromCylindrical: (s: Cylindrical) => Vector3;
				setFromCylindricalCoords: (radius: number, theta: number, y: number) => Vector3;
				setFromMatrixPosition: (m: Matrix4) => Vector3;
				setFromMatrixScale: (m: Matrix4) => Vector3;
				setFromMatrixColumn: (matrix: Matrix4, index: number) => Vector3;
				setFromMatrix3Column: (matrix: Matrix3, index: number) => Vector3;
				setFromEuler: (e: Euler) => Vector3;
				equals: (v: Vector3) => boolean;
				fromArray: (array: number[] | ArrayLike<number>, offset?: number | undefined) => Vector3;
				toArray: {
					(array?: number[] | undefined, offset?: number | undefined): number[];
					(array?: Vector3Tuple | undefined, offset?: 0 | undefined): Vector3Tuple;
					(array: ArrayLike<number>, offset?: number | undefined): ArrayLike<number>;
				};
				fromBufferAttribute: (attribute: BufferAttribute | InterleavedBufferAttribute, index: number) => Vector3;
				random: () => Vector3;
				randomDirection: () => Vector3;
			};
			direction: {
				x: number;
				y: number;
				z: number;
				readonly isVector3: true;
				set: (x: number, y: number, z: number) => Vector3;
				setScalar: (scalar: number) => Vector3;
				setX: (x: number) => Vector3;
				setY: (y: number) => Vector3;
				setZ: (z: number) => Vector3;
				setComponent: (index: number, value: number) => Vector3;
				setFromColor: (color: Color) => Vector3;
				getComponent: (index: number) => number;
				clone: () => Vector3;
				copy: (v: Vector3) => Vector3;
				add: (v: Vector3) => Vector3;
				addScalar: (s: number) => Vector3;
				addScaledVector: (v: Vector3, s: number) => Vector3;
				addVectors: (a: Vector3, b: Vector3) => Vector3;
				sub: (a: Vector3) => Vector3;
				subScalar: (s: number) => Vector3;
				subVectors: (a: Vector3, b: Vector3) => Vector3;
				multiply: (v: Vector3) => Vector3;
				multiplyScalar: (s: number) => Vector3;
				multiplyVectors: (a: Vector3, b: Vector3) => Vector3;
				applyEuler: (euler: Euler) => Vector3;
				applyAxisAngle: (axis: Vector3, angle: number) => Vector3;
				applyMatrix3: (m: Matrix3) => Vector3;
				applyNormalMatrix: (m: Matrix3) => Vector3;
				applyMatrix4: (m: Matrix4) => Vector3;
				applyQuaternion: (q: Quaternion) => Vector3;
				project: (camera: Camera) => Vector3;
				unproject: (camera: Camera) => Vector3;
				transformDirection: (m: Matrix4) => Vector3;
				divide: (v: Vector3) => Vector3;
				divideScalar: (s: number) => Vector3;
				min: (v: Vector3) => Vector3;
				max: (v: Vector3) => Vector3;
				clamp: (min: Vector3, max: Vector3) => Vector3;
				clampScalar: (min: number, max: number) => Vector3;
				clampLength: (min: number, max: number) => Vector3;
				floor: () => Vector3;
				ceil: () => Vector3;
				round: () => Vector3;
				roundToZero: () => Vector3;
				negate: () => Vector3;
				dot: (v: Vector3) => number;
				lengthSq: () => number;
				length: () => number;
				lengthManhattan: () => number;
				manhattanLength: () => number;
				manhattanDistanceTo: (v: Vector3) => number;
				normalize: () => Vector3;
				setLength: (l: number) => Vector3;
				lerp: (v: Vector3, alpha: number) => Vector3;
				lerpVectors: (v1: Vector3, v2: Vector3, alpha: number) => Vector3;
				cross: (a: Vector3) => Vector3;
				crossVectors: (a: Vector3, b: Vector3) => Vector3;
				projectOnVector: (v: Vector3) => Vector3;
				projectOnPlane: (planeNormal: Vector3) => Vector3;
				reflect: (vector: Vector3) => Vector3;
				angleTo: (v: Vector3) => number;
				distanceTo: (v: Vector3) => number;
				distanceToSquared: (v: Vector3) => number;
				distanceToManhattan: (v: Vector3) => number;
				setFromSpherical: (s: Spherical) => Vector3;
				setFromSphericalCoords: (r: number, phi: number, theta: number) => Vector3;
				setFromCylindrical: (s: Cylindrical) => Vector3;
				setFromCylindricalCoords: (radius: number, theta: number, y: number) => Vector3;
				setFromMatrixPosition: (m: Matrix4) => Vector3;
				setFromMatrixScale: (m: Matrix4) => Vector3;
				setFromMatrixColumn: (matrix: Matrix4, index: number) => Vector3;
				setFromMatrix3Column: (matrix: Matrix3, index: number) => Vector3;
				setFromEuler: (e: Euler) => Vector3;
				equals: (v: Vector3) => boolean;
				fromArray: (array: number[] | ArrayLike<number>, offset?: number | undefined) => Vector3;
				toArray: {
					(array?: number[] | undefined, offset?: number | undefined): number[];
					(array?: Vector3Tuple | undefined, offset?: 0 | undefined): Vector3Tuple;
					(array: ArrayLike<number>, offset?: number | undefined): ArrayLike<number>;
				};
				fromBufferAttribute: (attribute: BufferAttribute | InterleavedBufferAttribute, index: number) => Vector3;
				random: () => Vector3;
				randomDirection: () => Vector3;
			};
			set: (origin: Vector3, direction: Vector3) => Ray;
			clone: () => Ray;
			copy: (ray: Ray) => Ray;
			at: (t: number, target: Vector3) => Vector3;
			lookAt: (v: Vector3) => Ray;
			recast: (t: number) => Ray;
			closestPointToPoint: (point: Vector3, target: Vector3) => Vector3;
			distanceToPoint: (point: Vector3) => number;
			distanceSqToPoint: (point: Vector3) => number;
			distanceSqToSegment: (v0: Vector3, v1: Vector3, optionalPointOnRay?: Vector3 | undefined, optionalPointOnSegment?: Vector3 | undefined) => number;
			intersectSphere: (sphere: Sphere, target: Vector3) => Vector3 | null;
			intersectsSphere: (sphere: Sphere) => boolean;
			distanceToPlane: (plane: Plane) => number;
			intersectPlane: (plane: Plane, target: Vector3) => Vector3 | null;
			intersectsPlane: (plane: Plane) => boolean;
			intersectBox: (box: Box3, target: Vector3) => Vector3 | null;
			intersectsBox: (box: Box3) => boolean;
			intersectTriangle: (a: Vector3, b: Vector3, c: Vector3, backfaceCulling: boolean, target: Vector3) => Vector3 | null;
			applyMatrix4: (matrix4: Matrix4) => Ray;
			equals: (ray: Ray) => boolean;
			isIntersectionBox: (b: any) => any;
			isIntersectionPlane: (p: any) => any;
			isIntersectionSphere: (s: any) => any;
		};
		near: number;
		far: number;
		camera: {
			readonly isCamera: true;
			readonly type: string;
			layers: {
				mask: number;
				set: (layer: number) => void;
				enable: (layer: number) => void;
				enableAll: () => void;
				toggle: (layer: number) => void;
				disable: (layer: number) => void;
				disableAll: () => void;
				test: (layers: Layers) => boolean;
				isEnabled: (layer: number) => boolean;
			};
			matrixWorldInverse: {
				elements: number[];
				set: (n11: number, n12: number, n13: number, n14: number, n21: number, n22: number, n23: number, n24: number, n31: number, n32: number, n33: number, n34: number, n41: number, n42: number, n43: number, n44: number) => Matrix4;
				identity: () => Matrix4;
				clone: () => Matrix4;
				copy: (m: Matrix4) => Matrix4;
				copyPosition: (m: Matrix4) => Matrix4;
				extractBasis: (xAxis: Vector3, yAxis: Vector3, zAxis: Vector3) => Matrix4;
				makeBasis: (xAxis: Vector3, yAxis: Vector3, zAxis: Vector3) => Matrix4;
				extractRotation: (m: Matrix4) => Matrix4;
				makeRotationFromEuler: (euler: Euler) => Matrix4;
				makeRotationFromQuaternion: (q: Quaternion) => Matrix4;
				lookAt: (eye: Vector3, target: Vector3, up: Vector3) => Matrix4;
				multiply: (m: Matrix4) => Matrix4;
				premultiply: (m: Matrix4) => Matrix4;
				multiplyMatrices: (a: Matrix4, b: Matrix4) => Matrix4;
				multiplyToArray: (a: Matrix4, b: Matrix4, r: number[]) => Matrix4;
				multiplyScalar: (s: number) => Matrix4;
				determinant: () => number;
				transpose: () => Matrix4;
				setPosition: (v: number | Vector3, y?: number | undefined, z?: number | undefined) => Matrix4;
				invert: () => Matrix4;
				scale: (v: Vector3) => Matrix4;
				getMaxScaleOnAxis: () => number;
				makeTranslation: (x: number, y: number, z: number) => Matrix4;
				makeRotationX: (theta: number) => Matrix4;
				makeRotationY: (theta: number) => Matrix4;
				makeRotationZ: (theta: number) => Matrix4;
				makeRotationAxis: (axis: Vector3, angle: number) => Matrix4;
				makeScale: (x: number, y: number, z: number) => Matrix4;
				makeShear: (xy: number, xz: number, yx: number, yz: number, zx: number, zy: number) => Matrix4;
				compose: (translation: Vector3, rotation: Quaternion, scale: Vector3) => Matrix4;
				decompose: (translation: Vector3, rotation: Quaternion, scale: Vector3) => Matrix4;
				makePerspective: {
					(left: number, right: number, bottom: number, top: number, near: number, far: number): Matrix4;
					(fov: number, aspect: number, near: number, far: number): Matrix4;
				};
				makeOrthographic: (left: number, right: number, top: number, bottom: number, near: number, far: number) => Matrix4;
				equals: (matrix: Matrix4) => boolean;
				fromArray: (array: number[] | ArrayLike<number>, offset?: number | undefined) => Matrix4;
				toArray: {
					(array?: number[] | undefined, offset?: number | undefined): number[];
					(array?: Matrix4Tuple | undefined, offset?: 0 | undefined): Matrix4Tuple;
					(array?: ArrayLike<number> | undefined, offset?: number | undefined): ArrayLike<number>;
				};
				setFromMatrix3: (m: Matrix3) => Matrix4;
				extractPosition: (m: Matrix4) => Matrix4;
				setRotationFromQuaternion: (q: Quaternion) => Matrix4;
				multiplyVector3: (v: any) => any;
				multiplyVector4: (v: any) => any;
				multiplyVector3Array: (array: number[]) => number[];
				rotateAxis: (v: any) => void;
				crossVector: (v: any) => void;
				flattenToArrayOffset: (array: number[], offset: number) => number[];
				getInverse: (matrix: Matrix) => Matrix;
			};
			projectionMatrix: {
				elements: number[];
				set: (n11: number, n12: number, n13: number, n14: number, n21: number, n22: number, n23: number, n24: number, n31: number, n32: number, n33: number, n34: number, n41: number, n42: number, n43: number, n44: number) => Matrix4;
				identity: () => Matrix4;
				clone: () => Matrix4;
				copy: (m: Matrix4) => Matrix4;
				copyPosition: (m: Matrix4) => Matrix4;
				extractBasis: (xAxis: Vector3, yAxis: Vector3, zAxis: Vector3) => Matrix4;
				makeBasis: (xAxis: Vector3, yAxis: Vector3, zAxis: Vector3) => Matrix4;
				extractRotation: (m: Matrix4) => Matrix4;
				makeRotationFromEuler: (euler: Euler) => Matrix4;
				makeRotationFromQuaternion: (q: Quaternion) => Matrix4;
				lookAt: (eye: Vector3, target: Vector3, up: Vector3) => Matrix4;
				multiply: (m: Matrix4) => Matrix4;
				premultiply: (m: Matrix4) => Matrix4;
				multiplyMatrices: (a: Matrix4, b: Matrix4) => Matrix4;
				multiplyToArray: (a: Matrix4, b: Matrix4, r: number[]) => Matrix4;
				multiplyScalar: (s: number) => Matrix4;
				determinant: () => number;
				transpose: () => Matrix4;
				setPosition: (v: number | Vector3, y?: number | undefined, z?: number | undefined) => Matrix4;
				invert: () => Matrix4;
				scale: (v: Vector3) => Matrix4;
				getMaxScaleOnAxis: () => number;
				makeTranslation: (x: number, y: number, z: number) => Matrix4;
				makeRotationX: (theta: number) => Matrix4;
				makeRotationY: (theta: number) => Matrix4;
				makeRotationZ: (theta: number) => Matrix4;
				makeRotationAxis: (axis: Vector3, angle: number) => Matrix4;
				makeScale: (x: number, y: number, z: number) => Matrix4;
				makeShear: (xy: number, xz: number, yx: number, yz: number, zx: number, zy: number) => Matrix4;
				compose: (translation: Vector3, rotation: Quaternion, scale: Vector3) => Matrix4;
				decompose: (translation: Vector3, rotation: Quaternion, scale: Vector3) => Matrix4;
				makePerspective: {
					(left: number, right: number, bottom: number, top: number, near: number, far: number): Matrix4;
					(fov: number, aspect: number, near: number, far: number): Matrix4;
				};
				makeOrthographic: (left: number, right: number, top: number, bottom: number, near: number, far: number) => Matrix4;
				equals: (matrix: Matrix4) => boolean;
				fromArray: (array: number[] | ArrayLike<number>, offset?: number | undefined) => Matrix4;
				toArray: {
					(array?: number[] | undefined, offset?: number | undefined): number[];
					(array?: Matrix4Tuple | undefined, offset?: 0 | undefined): Matrix4Tuple;
					(array?: ArrayLike<number> | undefined, offset?: number | undefined): ArrayLike<number>;
				};
				setFromMatrix3: (m: Matrix3) => Matrix4;
				extractPosition: (m: Matrix4) => Matrix4;
				setRotationFromQuaternion: (q: Quaternion) => Matrix4;
				multiplyVector3: (v: any) => any;
				multiplyVector4: (v: any) => any;
				multiplyVector3Array: (array: number[]) => number[];
				rotateAxis: (v: any) => void;
				crossVector: (v: any) => void;
				flattenToArrayOffset: (array: number[], offset: number) => number[];
				getInverse: (matrix: Matrix) => Matrix;
			};
			projectionMatrixInverse: {
				elements: number[];
				set: (n11: number, n12: number, n13: number, n14: number, n21: number, n22: number, n23: number, n24: number, n31: number, n32: number, n33: number, n34: number, n41: number, n42: number, n43: number, n44: number) => Matrix4;
				identity: () => Matrix4;
				clone: () => Matrix4;
				copy: (m: Matrix4) => Matrix4;
				copyPosition: (m: Matrix4) => Matrix4;
				extractBasis: (xAxis: Vector3, yAxis: Vector3, zAxis: Vector3) => Matrix4;
				makeBasis: (xAxis: Vector3, yAxis: Vector3, zAxis: Vector3) => Matrix4;
				extractRotation: (m: Matrix4) => Matrix4;
				makeRotationFromEuler: (euler: Euler) => Matrix4;
				makeRotationFromQuaternion: (q: Quaternion) => Matrix4;
				lookAt: (eye: Vector3, target: Vector3, up: Vector3) => Matrix4;
				multiply: (m: Matrix4) => Matrix4;
				premultiply: (m: Matrix4) => Matrix4;
				multiplyMatrices: (a: Matrix4, b: Matrix4) => Matrix4;
				multiplyToArray: (a: Matrix4, b: Matrix4, r: number[]) => Matrix4;
				multiplyScalar: (s: number) => Matrix4;
				determinant: () => number;
				transpose: () => Matrix4;
				setPosition: (v: number | Vector3, y?: number | undefined, z?: number | undefined) => Matrix4;
				invert: () => Matrix4;
				scale: (v: Vector3) => Matrix4;
				getMaxScaleOnAxis: () => number;
				makeTranslation: (x: number, y: number, z: number) => Matrix4;
				makeRotationX: (theta: number) => Matrix4;
				makeRotationY: (theta: number) => Matrix4;
				makeRotationZ: (theta: number) => Matrix4;
				makeRotationAxis: (axis: Vector3, angle: number) => Matrix4;
				makeScale: (x: number, y: number, z: number) => Matrix4;
				makeShear: (xy: number, xz: number, yx: number, yz: number, zx: number, zy: number) => Matrix4;
				compose: (translation: Vector3, rotation: Quaternion, scale: Vector3) => Matrix4;
				decompose: (translation: Vector3, rotation: Quaternion, scale: Vector3) => Matrix4;
				makePerspective: {
					(left: number, right: number, bottom: number, top: number, near: number, far: number): Matrix4;
					(fov: number, aspect: number, near: number, far: number): Matrix4;
				};
				makeOrthographic: (left: number, right: number, top: number, bottom: number, near: number, far: number) => Matrix4;
				equals: (matrix: Matrix4) => boolean;
				fromArray: (array: number[] | ArrayLike<number>, offset?: number | undefined) => Matrix4;
				toArray: {
					(array?: number[] | undefined, offset?: number | undefined): number[];
					(array?: Matrix4Tuple | undefined, offset?: 0 | undefined): Matrix4Tuple;
					(array?: ArrayLike<number> | undefined, offset?: number | undefined): ArrayLike<number>;
				};
				setFromMatrix3: (m: Matrix3) => Matrix4;
				extractPosition: (m: Matrix4) => Matrix4;
				setRotationFromQuaternion: (q: Quaternion) => Matrix4;
				multiplyVector3: (v: any) => any;
				multiplyVector4: (v: any) => any;
				multiplyVector3Array: (array: number[]) => number[];
				rotateAxis: (v: any) => void;
				crossVector: (v: any) => void;
				flattenToArrayOffset: (array: number[], offset: number) => number[];
				getInverse: (matrix: Matrix) => Matrix;
			};
			getWorldDirection: (target: Vector3) => Vector3;
			readonly isObject3D: true;
			readonly id: number;
			uuid: string;
			name: string;
			parent: {
				readonly isObject3D: true;
				readonly id: number;
				uuid: string;
				name: string;
				readonly type: string;
				parent: any | null;
				children: any[];
				up: {
					x: number;
					y: number;
					z: number;
					readonly isVector3: true;
					set: (x: number, y: number, z: number) => Vector3;
					setScalar: (scalar: number) => Vector3;
					setX: (x: number) => Vector3;
					setY: (y: number) => Vector3;
					setZ: (z: number) => Vector3;
					setComponent: (index: number, value: number) => Vector3;
					setFromColor: (color: Color) => Vector3;
					getComponent: (index: number) => number;
					clone: () => Vector3;
					copy: (v: Vector3) => Vector3;
					add: (v: Vector3) => Vector3;
					addScalar: (s: number) => Vector3;
					addScaledVector: (v: Vector3, s: number) => Vector3;
					addVectors: (a: Vector3, b: Vector3) => Vector3;
					sub: (a: Vector3) => Vector3;
					subScalar: (s: number) => Vector3;
					subVectors: (a: Vector3, b: Vector3) => Vector3;
					multiply: (v: Vector3) => Vector3;
					multiplyScalar: (s: number) => Vector3;
					multiplyVectors: (a: Vector3, b: Vector3) => Vector3;
					applyEuler: (euler: Euler) => Vector3;
					applyAxisAngle: (axis: Vector3, angle: number) => Vector3;
					applyMatrix3: (m: Matrix3) => Vector3;
					applyNormalMatrix: (m: Matrix3) => Vector3;
					applyMatrix4: (m: Matrix4) => Vector3;
					applyQuaternion: (q: Quaternion) => Vector3;
					project: (camera: Camera) => Vector3;
					unproject: (camera: Camera) => Vector3;
					transformDirection: (m: Matrix4) => Vector3;
					divide: (v: Vector3) => Vector3;
					divideScalar: (s: number) => Vector3;
					min: (v: Vector3) => Vector3;
					max: (v: Vector3) => Vector3;
					clamp: (min: Vector3, max: Vector3) => Vector3;
					clampScalar: (min: number, max: number) => Vector3;
					clampLength: (min: number, max: number) => Vector3;
					floor: () => Vector3;
					ceil: () => Vector3;
					round: () => Vector3;
					roundToZero: () => Vector3;
					negate: () => Vector3;
					dot: (v: Vector3) => number;
					lengthSq: () => number;
					length: () => number;
					lengthManhattan: () => number;
					manhattanLength: () => number;
					manhattanDistanceTo: (v: Vector3) => number;
					normalize: () => Vector3;
					setLength: (l: number) => Vector3;
					lerp: (v: Vector3, alpha: number) => Vector3;
					lerpVectors: (v1: Vector3, v2: Vector3, alpha: number) => Vector3;
					cross: (a: Vector3) => Vector3;
					crossVectors: (a: Vector3, b: Vector3) => Vector3;
					projectOnVector: (v: Vector3) => Vector3;
					projectOnPlane: (planeNormal: Vector3) => Vector3;
					reflect: (vector: Vector3) => Vector3;
					angleTo: (v: Vector3) => number;
					distanceTo: (v: Vector3) => number;
					distanceToSquared: (v: Vector3) => number;
					distanceToManhattan: (v: Vector3) => number;
					setFromSpherical: (s: Spherical) => Vector3;
					setFromSphericalCoords: (r: number, phi: number, theta: number) => Vector3;
					setFromCylindrical: (s: Cylindrical) => Vector3;
					setFromCylindricalCoords: (radius: number, theta: number, y: number) => Vector3;
					setFromMatrixPosition: (m: Matrix4) => Vector3;
					setFromMatrixScale: (m: Matrix4) => Vector3;
					setFromMatrixColumn: (matrix: Matrix4, index: number) => Vector3;
					setFromMatrix3Column: (matrix: Matrix3, index: number) => Vector3;
					setFromEuler: (e: Euler) => Vector3;
					equals: (v: Vector3) => boolean;
					fromArray: (array: number[] | ArrayLike<number>, offset?: number | undefined) => Vector3;
					toArray: {
						(array?: number[] | undefined, offset?: number | undefined): number[];
						(array?: Vector3Tuple | undefined, offset?: 0 | undefined): Vector3Tuple;
						(array: ArrayLike<number>, offset?: number | undefined): ArrayLike<number>;
					};
					fromBufferAttribute: (attribute: BufferAttribute | InterleavedBufferAttribute, index: number) => Vector3;
					random: () => Vector3;
					randomDirection: () => Vector3;
				};
				readonly position: {
					x: number;
					y: number;
					z: number;
					readonly isVector3: true;
					set: (x: number, y: number, z: number) => Vector3;
					setScalar: (scalar: number) => Vector3;
					setX: (x: number) => Vector3;
					setY: (y: number) => Vector3;
					setZ: (z: number) => Vector3;
					setComponent: (index: number, value: number) => Vector3;
					setFromColor: (color: Color) => Vector3;
					getComponent: (index: number) => number;
					clone: () => Vector3;
					copy: (v: Vector3) => Vector3;
					add: (v: Vector3) => Vector3;
					addScalar: (s: number) => Vector3;
					addScaledVector: (v: Vector3, s: number) => Vector3;
					addVectors: (a: Vector3, b: Vector3) => Vector3;
					sub: (a: Vector3) => Vector3;
					subScalar: (s: number) => Vector3;
					subVectors: (a: Vector3, b: Vector3) => Vector3;
					multiply: (v: Vector3) => Vector3;
					multiplyScalar: (s: number) => Vector3;
					multiplyVectors: (a: Vector3, b: Vector3) => Vector3;
					applyEuler: (euler: Euler) => Vector3;
					applyAxisAngle: (axis: Vector3, angle: number) => Vector3;
					applyMatrix3: (m: Matrix3) => Vector3;
					applyNormalMatrix: (m: Matrix3) => Vector3;
					applyMatrix4: (m: Matrix4) => Vector3;
					applyQuaternion: (q: Quaternion) => Vector3;
					project: (camera: Camera) => Vector3;
					unproject: (camera: Camera) => Vector3;
					transformDirection: (m: Matrix4) => Vector3;
					divide: (v: Vector3) => Vector3;
					divideScalar: (s: number) => Vector3;
					min: (v: Vector3) => Vector3;
					max: (v: Vector3) => Vector3;
					clamp: (min: Vector3, max: Vector3) => Vector3;
					clampScalar: (min: number, max: number) => Vector3;
					clampLength: (min: number, max: number) => Vector3;
					floor: () => Vector3;
					ceil: () => Vector3;
					round: () => Vector3;
					roundToZero: () => Vector3;
					negate: () => Vector3;
					dot: (v: Vector3) => number;
					lengthSq: () => number;
					length: () => number;
					lengthManhattan: () => number;
					manhattanLength: () => number;
					manhattanDistanceTo: (v: Vector3) => number;
					normalize: () => Vector3;
					setLength: (l: number) => Vector3;
					lerp: (v: Vector3, alpha: number) => Vector3;
					lerpVectors: (v1: Vector3, v2: Vector3, alpha: number) => Vector3;
					cross: (a: Vector3) => Vector3;
					crossVectors: (a: Vector3, b: Vector3) => Vector3;
					projectOnVector: (v: Vector3) => Vector3;
					projectOnPlane: (planeNormal: Vector3) => Vector3;
					reflect: (vector: Vector3) => Vector3;
					angleTo: (v: Vector3) => number;
					distanceTo: (v: Vector3) => number;
					distanceToSquared: (v: Vector3) => number;
					distanceToManhattan: (v: Vector3) => number;
					setFromSpherical: (s: Spherical) => Vector3;
					setFromSphericalCoords: (r: number, phi: number, theta: number) => Vector3;
					setFromCylindrical: (s: Cylindrical) => Vector3;
					setFromCylindricalCoords: (radius: number, theta: number, y: number) => Vector3;
					setFromMatrixPosition: (m: Matrix4) => Vector3;
					setFromMatrixScale: (m: Matrix4) => Vector3;
					setFromMatrixColumn: (matrix: Matrix4, index: number) => Vector3;
					setFromMatrix3Column: (matrix: Matrix3, index: number) => Vector3;
					setFromEuler: (e: Euler) => Vector3;
					equals: (v: Vector3) => boolean;
					fromArray: (array: number[] | ArrayLike<number>, offset?: number | undefined) => Vector3;
					toArray: {
						(array?: number[] | undefined, offset?: number | undefined): number[];
						(array?: Vector3Tuple | undefined, offset?: 0 | undefined): Vector3Tuple;
						(array: ArrayLike<number>, offset?: number | undefined): ArrayLike<number>;
					};
					fromBufferAttribute: (attribute: BufferAttribute | InterleavedBufferAttribute, index: number) => Vector3;
					random: () => Vector3;
					randomDirection: () => Vector3;
				};
				readonly rotation: {
					x: number;
					y: number;
					z: number;
					order: EulerOrder;
					readonly isEuler: true;
					_onChangeCallback: () => void;
					set: (x: number, y: number, z: number, order?: EulerOrder | undefined) => Euler;
					clone: () => Euler;
					copy: (euler: Euler) => Euler;
					setFromRotationMatrix: (m: Matrix4, order?: EulerOrder | undefined, update?: boolean | undefined) => Euler;
					setFromQuaternion: (q: Quaternion, order?: EulerOrder | undefined, update?: boolean | undefined) => Euler;
					setFromVector3: (v: Vector3, order?: EulerOrder | undefined) => Euler;
					reorder: (newOrder: EulerOrder) => Euler;
					equals: (euler: Euler) => boolean;
					fromArray: (xyzo: [
						number,
						number,
						number,
						(EulerOrder | undefined)?,
						...any[]
					]) => Euler;
					toArray: (array?: (string | number | undefined)[] | undefined, offset?: number | undefined) => (string | number | undefined)[];
					_onChange: (callback: () => void) => Euler;
					[Symbol.iterator]: () => Generator<string | number, void, unknown>;
				};
				readonly quaternion: {
					x: number;
					y: number;
					z: number;
					w: number;
					readonly isQuaternion: true;
					set: (x: number, y: number, z: number, w: number) => Quaternion;
					clone: () => Quaternion;
					copy: (q: Quaternion) => Quaternion;
					setFromEuler: (euler: Euler, update?: boolean | undefined) => Quaternion;
					setFromAxisAngle: (axis: Vector3, angle: number) => Quaternion;
					setFromRotationMatrix: (m: Matrix4) => Quaternion;
					setFromUnitVectors: (vFrom: Vector3, vTo: Vector3) => Quaternion;
					angleTo: (q: Quaternion) => number;
					rotateTowards: (q: Quaternion, step: number) => Quaternion;
					identity: () => Quaternion;
					invert: () => Quaternion;
					conjugate: () => Quaternion;
					dot: (v: Quaternion) => number;
					lengthSq: () => number;
					length: () => number;
					normalize: () => Quaternion;
					multiply: (q: Quaternion) => Quaternion;
					premultiply: (q: Quaternion) => Quaternion;
					multiplyQuaternions: (a: Quaternion, b: Quaternion) => Quaternion;
					slerp: (qb: Quaternion, t: number) => Quaternion;
					slerpQuaternions: (qa: Quaternion, qb: Quaternion, t: number) => Quaternion;
					equals: (v: Quaternion) => boolean;
					fromArray: (array: number[] | ArrayLike<number>, offset?: number | undefined) => Quaternion;
					toArray: {
						(array?: number[] | undefined, offset?: number | undefined): number[];
						(array: ArrayLike<number>, offset?: number | undefined): ArrayLike<number>;
					};
					toJSON: () => [
						number,
						number,
						number,
						number
					];
					fromBufferAttribute: (attribute: BufferAttribute | InterleavedBufferAttribute, index: number) => Quaternion;
					_onChange: (callback: () => void) => Quaternion;
					_onChangeCallback: () => void;
					multiplyVector3: (v: any) => any;
					random: () => Quaternion;
					[Symbol.iterator]: () => Generator<number, void, unknown>;
				};
				readonly scale: {
					x: number;
					y: number;
					z: number;
					readonly isVector3: true;
					set: (x: number, y: number, z: number) => Vector3;
					setScalar: (scalar: number) => Vector3;
					setX: (x: number) => Vector3;
					setY: (y: number) => Vector3;
					setZ: (z: number) => Vector3;
					setComponent: (index: number, value: number) => Vector3;
					setFromColor: (color: Color) => Vector3;
					getComponent: (index: number) => number;
					clone: () => Vector3;
					copy: (v: Vector3) => Vector3;
					add: (v: Vector3) => Vector3;
					addScalar: (s: number) => Vector3;
					addScaledVector: (v: Vector3, s: number) => Vector3;
					addVectors: (a: Vector3, b: Vector3) => Vector3;
					sub: (a: Vector3) => Vector3;
					subScalar: (s: number) => Vector3;
					subVectors: (a: Vector3, b: Vector3) => Vector3;
					multiply: (v: Vector3) => Vector3;
					multiplyScalar: (s: number) => Vector3;
					multiplyVectors: (a: Vector3, b: Vector3) => Vector3;
					applyEuler: (euler: Euler) => Vector3;
					applyAxisAngle: (axis: Vector3, angle: number) => Vector3;
					applyMatrix3: (m: Matrix3) => Vector3;
					applyNormalMatrix: (m: Matrix3) => Vector3;
					applyMatrix4: (m: Matrix4) => Vector3;
					applyQuaternion: (q: Quaternion) => Vector3;
					project: (camera: Camera) => Vector3;
					unproject: (camera: Camera) => Vector3;
					transformDirection: (m: Matrix4) => Vector3;
					divide: (v: Vector3) => Vector3;
					divideScalar: (s: number) => Vector3;
					min: (v: Vector3) => Vector3;
					max: (v: Vector3) => Vector3;
					clamp: (min: Vector3, max: Vector3) => Vector3;
					clampScalar: (min: number, max: number) => Vector3;
					clampLength: (min: number, max: number) => Vector3;
					floor: () => Vector3;
					ceil: () => Vector3;
					round: () => Vector3;
					roundToZero: () => Vector3;
					negate: () => Vector3;
					dot: (v: Vector3) => number;
					lengthSq: () => number;
					length: () => number;
					lengthManhattan: () => number;
					manhattanLength: () => number;
					manhattanDistanceTo: (v: Vector3) => number;
					normalize: () => Vector3;
					setLength: (l: number) => Vector3;
					lerp: (v: Vector3, alpha: number) => Vector3;
					lerpVectors: (v1: Vector3, v2: Vector3, alpha: number) => Vector3;
					cross: (a: Vector3) => Vector3;
					crossVectors: (a: Vector3, b: Vector3) => Vector3;
					projectOnVector: (v: Vector3) => Vector3;
					projectOnPlane: (planeNormal: Vector3) => Vector3;
					reflect: (vector: Vector3) => Vector3;
					angleTo: (v: Vector3) => number;
					distanceTo: (v: Vector3) => number;
					distanceToSquared: (v: Vector3) => number;
					distanceToManhattan: (v: Vector3) => number;
					setFromSpherical: (s: Spherical) => Vector3;
					setFromSphericalCoords: (r: number, phi: number, theta: number) => Vector3;
					setFromCylindrical: (s: Cylindrical) => Vector3;
					setFromCylindricalCoords: (radius: number, theta: number, y: number) => Vector3;
					setFromMatrixPosition: (m: Matrix4) => Vector3;
					setFromMatrixScale: (m: Matrix4) => Vector3;
					setFromMatrixColumn: (matrix: Matrix4, index: number) => Vector3;
					setFromMatrix3Column: (matrix: Matrix3, index: number) => Vector3;
					setFromEuler: (e: Euler) => Vector3;
					equals: (v: Vector3) => boolean;
					fromArray: (array: number[] | ArrayLike<number>, offset?: number | undefined) => Vector3;
					toArray: {
						(array?: number[] | undefined, offset?: number | undefined): number[];
						(array?: Vector3Tuple | undefined, offset?: 0 | undefined): Vector3Tuple;
						(array: ArrayLike<number>, offset?: number | undefined): ArrayLike<number>;
					};
					fromBufferAttribute: (attribute: BufferAttribute | InterleavedBufferAttribute, index: number) => Vector3;
					random: () => Vector3;
					randomDirection: () => Vector3;
				};
				readonly modelViewMatrix: {
					elements: number[];
					set: (n11: number, n12: number, n13: number, n14: number, n21: number, n22: number, n23: number, n24: number, n31: number, n32: number, n33: number, n34: number, n41: number, n42: number, n43: number, n44: number) => Matrix4;
					identity: () => Matrix4;
					clone: () => Matrix4;
					copy: (m: Matrix4) => Matrix4;
					copyPosition: (m: Matrix4) => Matrix4;
					extractBasis: (xAxis: Vector3, yAxis: Vector3, zAxis: Vector3) => Matrix4;
					makeBasis: (xAxis: Vector3, yAxis: Vector3, zAxis: Vector3) => Matrix4;
					extractRotation: (m: Matrix4) => Matrix4;
					makeRotationFromEuler: (euler: Euler) => Matrix4;
					makeRotationFromQuaternion: (q: Quaternion) => Matrix4;
					lookAt: (eye: Vector3, target: Vector3, up: Vector3) => Matrix4;
					multiply: (m: Matrix4) => Matrix4;
					premultiply: (m: Matrix4) => Matrix4;
					multiplyMatrices: (a: Matrix4, b: Matrix4) => Matrix4;
					multiplyToArray: (a: Matrix4, b: Matrix4, r: number[]) => Matrix4;
					multiplyScalar: (s: number) => Matrix4;
					determinant: () => number;
					transpose: () => Matrix4;
					setPosition: (v: number | Vector3, y?: number | undefined, z?: number | undefined) => Matrix4;
					invert: () => Matrix4;
					scale: (v: Vector3) => Matrix4;
					getMaxScaleOnAxis: () => number;
					makeTranslation: (x: number, y: number, z: number) => Matrix4;
					makeRotationX: (theta: number) => Matrix4;
					makeRotationY: (theta: number) => Matrix4;
					makeRotationZ: (theta: number) => Matrix4;
					makeRotationAxis: (axis: Vector3, angle: number) => Matrix4;
					makeScale: (x: number, y: number, z: number) => Matrix4;
					makeShear: (xy: number, xz: number, yx: number, yz: number, zx: number, zy: number) => Matrix4;
					compose: (translation: Vector3, rotation: Quaternion, scale: Vector3) => Matrix4;
					decompose: (translation: Vector3, rotation: Quaternion, scale: Vector3) => Matrix4;
					makePerspective: {
						(left: number, right: number, bottom: number, top: number, near: number, far: number): Matrix4;
						(fov: number, aspect: number, near: number, far: number): Matrix4;
					};
					makeOrthographic: (left: number, right: number, top: number, bottom: number, near: number, far: number) => Matrix4;
					equals: (matrix: Matrix4) => boolean;
					fromArray: (array: number[] | ArrayLike<number>, offset?: number | undefined) => Matrix4;
					toArray: {
						(array?: number[] | undefined, offset?: number | undefined): number[];
						(array?: Matrix4Tuple | undefined, offset?: 0 | undefined): Matrix4Tuple;
						(array?: ArrayLike<number> | undefined, offset?: number | undefined): ArrayLike<number>;
					};
					setFromMatrix3: (m: Matrix3) => Matrix4;
					extractPosition: (m: Matrix4) => Matrix4;
					setRotationFromQuaternion: (q: Quaternion) => Matrix4;
					multiplyVector3: (v: any) => any;
					multiplyVector4: (v: any) => any;
					multiplyVector3Array: (array: number[]) => number[];
					rotateAxis: (v: any) => void;
					crossVector: (v: any) => void;
					flattenToArrayOffset: (array: number[], offset: number) => number[];
					getInverse: (matrix: Matrix) => Matrix;
				};
				readonly normalMatrix: {
					elements: number[];
					set: (n11: number, n12: number, n13: number, n21: number, n22: number, n23: number, n31: number, n32: number, n33: number) => Matrix3;
					identity: () => Matrix3;
					clone: () => Matrix3;
					copy: (m: Matrix3) => Matrix3;
					extractBasis: (xAxis: Vector3, yAxis: Vector3, zAxis: Vector3) => Matrix3;
					setFromMatrix4: (m: Matrix4) => Matrix3;
					multiplyScalar: (s: number) => Matrix3;
					determinant: () => number;
					invert: () => Matrix3;
					transpose: () => Matrix3;
					getNormalMatrix: (matrix4: Matrix4) => Matrix3;
					transposeIntoArray: (r: number[]) => Matrix3;
					setUvTransform: (tx: number, ty: number, sx: number, sy: number, rotation: number, cx: number, cy: number) => Matrix3;
					scale: (sx: number, sy: number) => Matrix3;
					makeTranslation: {
						(x: number, y: number): Matrix3;
						(x: number, y: number): Matrix3;
					};
					makeRotation: {
						(theta: number): Matrix3;
						(theta: number): Matrix3;
					};
					makeScale: {
						(x: number, y: number): Matrix3;
						(x: number, y: number): Matrix3;
					};
					rotate: (theta: number) => Matrix3;
					translate: (tx: number, ty: number) => Matrix3;
					equals: (matrix: Matrix3) => boolean;
					fromArray: (array: number[] | ArrayLike<number>, offset?: number | undefined) => Matrix3;
					toArray: {
						(array?: number[] | undefined, offset?: number | undefined): number[];
						(array?: Matrix3Tuple | undefined, offset?: 0 | undefined): Matrix3Tuple;
						(array?: ArrayLike<number> | undefined, offset?: number | undefined): ArrayLike<number>;
					};
					multiply: (m: Matrix3) => Matrix3;
					premultiply: (m: Matrix3) => Matrix3;
					multiplyMatrices: (a: Matrix3, b: Matrix3) => Matrix3;
					multiplyVector3: (vector: Vector3) => any;
					multiplyVector3Array: (a: any) => any;
					getInverse: {
						(matrix: Matrix4, throwOnDegenerate?: boolean | undefined): Matrix3;
						(matrix: Matrix): Matrix;
					};
					flattenToArrayOffset: (array: number[], offset: number) => number[];
				};
				matrix: {
					elements: number[];
					set: (n11: number, n12: number, n13: number, n14: number, n21: number, n22: number, n23: number, n24: number, n31: number, n32: number, n33: number, n34: number, n41: number, n42: number, n43: number, n44: number) => Matrix4;
					identity: () => Matrix4;
					clone: () => Matrix4;
					copy: (m: Matrix4) => Matrix4;
					copyPosition: (m: Matrix4) => Matrix4;
					extractBasis: (xAxis: Vector3, yAxis: Vector3, zAxis: Vector3) => Matrix4;
					makeBasis: (xAxis: Vector3, yAxis: Vector3, zAxis: Vector3) => Matrix4;
					extractRotation: (m: Matrix4) => Matrix4;
					makeRotationFromEuler: (euler: Euler) => Matrix4;
					makeRotationFromQuaternion: (q: Quaternion) => Matrix4;
					lookAt: (eye: Vector3, target: Vector3, up: Vector3) => Matrix4;
					multiply: (m: Matrix4) => Matrix4;
					premultiply: (m: Matrix4) => Matrix4;
					multiplyMatrices: (a: Matrix4, b: Matrix4) => Matrix4;
					multiplyToArray: (a: Matrix4, b: Matrix4, r: number[]) => Matrix4;
					multiplyScalar: (s: number) => Matrix4;
					determinant: () => number;
					transpose: () => Matrix4;
					setPosition: (v: number | Vector3, y?: number | undefined, z?: number | undefined) => Matrix4;
					invert: () => Matrix4;
					scale: (v: Vector3) => Matrix4;
					getMaxScaleOnAxis: () => number;
					makeTranslation: (x: number, y: number, z: number) => Matrix4;
					makeRotationX: (theta: number) => Matrix4;
					makeRotationY: (theta: number) => Matrix4;
					makeRotationZ: (theta: number) => Matrix4;
					makeRotationAxis: (axis: Vector3, angle: number) => Matrix4;
					makeScale: (x: number, y: number, z: number) => Matrix4;
					makeShear: (xy: number, xz: number, yx: number, yz: number, zx: number, zy: number) => Matrix4;
					compose: (translation: Vector3, rotation: Quaternion, scale: Vector3) => Matrix4;
					decompose: (translation: Vector3, rotation: Quaternion, scale: Vector3) => Matrix4;
					makePerspective: {
						(left: number, right: number, bottom: number, top: number, near: number, far: number): Matrix4;
						(fov: number, aspect: number, near: number, far: number): Matrix4;
					};
					makeOrthographic: (left: number, right: number, top: number, bottom: number, near: number, far: number) => Matrix4;
					equals: (matrix: Matrix4) => boolean;
					fromArray: (array: number[] | ArrayLike<number>, offset?: number | undefined) => Matrix4;
					toArray: {
						(array?: number[] | undefined, offset?: number | undefined): number[];
						(array?: Matrix4Tuple | undefined, offset?: 0 | undefined): Matrix4Tuple;
						(array?: ArrayLike<number> | undefined, offset?: number | undefined): ArrayLike<number>;
					};
					setFromMatrix3: (m: Matrix3) => Matrix4;
					extractPosition: (m: Matrix4) => Matrix4;
					setRotationFromQuaternion: (q: Quaternion) => Matrix4;
					multiplyVector3: (v: any) => any;
					multiplyVector4: (v: any) => any;
					multiplyVector3Array: (array: number[]) => number[];
					rotateAxis: (v: any) => void;
					crossVector: (v: any) => void;
					flattenToArrayOffset: (array: number[], offset: number) => number[];
					getInverse: (matrix: Matrix) => Matrix;
				};
				matrixWorld: {
					elements: number[];
					set: (n11: number, n12: number, n13: number, n14: number, n21: number, n22: number, n23: number, n24: number, n31: number, n32: number, n33: number, n34: number, n41: number, n42: number, n43: number, n44: number) => Matrix4;
					identity: () => Matrix4;
					clone: () => Matrix4;
					copy: (m: Matrix4) => Matrix4;
					copyPosition: (m: Matrix4) => Matrix4;
					extractBasis: (xAxis: Vector3, yAxis: Vector3, zAxis: Vector3) => Matrix4;
					makeBasis: (xAxis: Vector3, yAxis: Vector3, zAxis: Vector3) => Matrix4;
					extractRotation: (m: Matrix4) => Matrix4;
					makeRotationFromEuler: (euler: Euler) => Matrix4;
					makeRotationFromQuaternion: (q: Quaternion) => Matrix4;
					lookAt: (eye: Vector3, target: Vector3, up: Vector3) => Matrix4;
					multiply: (m: Matrix4) => Matrix4;
					premultiply: (m: Matrix4) => Matrix4;
					multiplyMatrices: (a: Matrix4, b: Matrix4) => Matrix4;
					multiplyToArray: (a: Matrix4, b: Matrix4, r: number[]) => Matrix4;
					multiplyScalar: (s: number) => Matrix4;
					determinant: () => number;
					transpose: () => Matrix4;
					setPosition: (v: number | Vector3, y?: number | undefined, z?: number | undefined) => Matrix4;
					invert: () => Matrix4;
					scale: (v: Vector3) => Matrix4;
					getMaxScaleOnAxis: () => number;
					makeTranslation: (x: number, y: number, z: number) => Matrix4;
					makeRotationX: (theta: number) => Matrix4;
					makeRotationY: (theta: number) => Matrix4;
					makeRotationZ: (theta: number) => Matrix4;
					makeRotationAxis: (axis: Vector3, angle: number) => Matrix4;
					makeScale: (x: number, y: number, z: number) => Matrix4;
					makeShear: (xy: number, xz: number, yx: number, yz: number, zx: number, zy: number) => Matrix4;
					compose: (translation: Vector3, rotation: Quaternion, scale: Vector3) => Matrix4;
					decompose: (translation: Vector3, rotation: Quaternion, scale: Vector3) => Matrix4;
					makePerspective: {
						(left: number, right: number, bottom: number, top: number, near: number, far: number): Matrix4;
						(fov: number, aspect: number, near: number, far: number): Matrix4;
					};
					makeOrthographic: (left: number, right: number, top: number, bottom: number, near: number, far: number) => Matrix4;
					equals: (matrix: Matrix4) => boolean;
					fromArray: (array: number[] | ArrayLike<number>, offset?: number | undefined) => Matrix4;
					toArray: {
						(array?: number[] | undefined, offset?: number | undefined): number[];
						(array?: Matrix4Tuple | undefined, offset?: 0 | undefined): Matrix4Tuple;
						(array?: ArrayLike<number> | undefined, offset?: number | undefined): ArrayLike<number>;
					};
					setFromMatrix3: (m: Matrix3) => Matrix4;
					extractPosition: (m: Matrix4) => Matrix4;
					setRotationFromQuaternion: (q: Quaternion) => Matrix4;
					multiplyVector3: (v: any) => any;
					multiplyVector4: (v: any) => any;
					multiplyVector3Array: (array: number[]) => number[];
					rotateAxis: (v: any) => void;
					crossVector: (v: any) => void;
					flattenToArrayOffset: (array: number[], offset: number) => number[];
					getInverse: (matrix: Matrix) => Matrix;
				};
				matrixAutoUpdate: boolean;
				matrixWorldAutoUpdate: boolean;
				matrixWorldNeedsUpdate: boolean;
				layers: {
					mask: number;
					set: (layer: number) => void;
					enable: (layer: number) => void;
					enableAll: () => void;
					toggle: (layer: number) => void;
					disable: (layer: number) => void;
					disableAll: () => void;
					test: (layers: Layers) => boolean;
					isEnabled: (layer: number) => boolean;
				};
				visible: boolean;
				castShadow: boolean;
				receiveShadow: boolean;
				frustumCulled: boolean;
				renderOrder: number;
				animations: {
					name: string;
					tracks: {
						name: string;
						times: {
							[x: number]: number;
							readonly BYTES_PER_ELEMENT: number;
							readonly buffer: {
								readonly byteLength: number;
								slice: (begin: number, end?: number | undefined) => ArrayBuffer;
								readonly [Symbol.toStringTag]: string;
							} | {
								readonly byteLength: number;
								slice: (begin: number, end?: number | undefined) => SharedArrayBuffer;
								readonly [Symbol.species]: SharedArrayBuffer;
								readonly [Symbol.toStringTag]: "SharedArrayBuffer";
							};
							readonly byteLength: number;
							readonly byteOffset: number;
							copyWithin: (target: number, start: number, end?: number | undefined) => Float32Array;
							every: (predicate: (value: number, index: number, array: Float32Array) => unknown, thisArg?: any) => boolean;
							fill: (value: number, start?: number | undefined, end?: number | undefined) => Float32Array;
							filter: (predicate: (value: number, index: number, array: Float32Array) => any, thisArg?: any) => Float32Array;
							find: (predicate: (value: number, index: number, obj: Float32Array) => boolean, thisArg?: any) => number | undefined;
							findIndex: (predicate: (value: number, index: number, obj: Float32Array) => boolean, thisArg?: any) => number;
							forEach: (callbackfn: (value: number, index: number, array: Float32Array) => void, thisArg?: any) => void;
							indexOf: (searchElement: number, fromIndex?: number | undefined) => number;
							join: (separator?: string | undefined) => string;
							lastIndexOf: (searchElement: number, fromIndex?: number | undefined) => number;
							readonly length: number;
							map: (callbackfn: (value: number, index: number, array: Float32Array) => number, thisArg?: any) => Float32Array;
							reduce: {
								(callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number): number;
								(callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number, initialValue: number): number;
								<U>(callbackfn: (previousValue: U, currentValue: number, currentIndex: number, array: Float32Array) => U, initialValue: U): U;
							};
							reduceRight: {
								(callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number): number;
								(callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number, initialValue: number): number;
								<U_1>(callbackfn: (previousValue: U_1, currentValue: number, currentIndex: number, array: Float32Array) => U_1, initialValue: U_1): U_1;
							};
							reverse: () => Float32Array;
							set: (array: ArrayLike<number>, offset?: number | undefined) => void;
							slice: (start?: number | undefined, end?: number | undefined) => Float32Array;
							some: (predicate: (value: number, index: number, array: Float32Array) => unknown, thisArg?: any) => boolean;
							sort: (compareFn?: ((a: number, b: number) => number) | undefined) => Float32Array;
							subarray: (begin?: number | undefined, end?: number | undefined) => Float32Array;
							toLocaleString: () => string;
							toString: () => string;
							valueOf: () => Float32Array;
							entries: () => IterableIterator<[
								number,
								number
							]>;
							keys: () => IterableIterator<number>;
							values: () => IterableIterator<number>;
							includes: (searchElement: number, fromIndex?: number | undefined) => boolean;
							[Symbol.iterator]: () => IterableIterator<number>;
							readonly [Symbol.toStringTag]: "Float32Array";
							at: (index: number) => number | undefined;
						};
						values: {
							[x: number]: number;
							readonly BYTES_PER_ELEMENT: number;
							readonly buffer: {
								readonly byteLength: number;
								slice: (begin: number, end?: number | undefined) => ArrayBuffer;
								readonly [Symbol.toStringTag]: string;
							} | {
								readonly byteLength: number;
								slice: (begin: number, end?: number | undefined) => SharedArrayBuffer;
								readonly [Symbol.species]: SharedArrayBuffer;
								readonly [Symbol.toStringTag]: "SharedArrayBuffer";
							};
							readonly byteLength: number;
							readonly byteOffset: number;
							copyWithin: (target: number, start: number, end?: number | undefined) => Float32Array;
							every: (predicate: (value: number, index: number, array: Float32Array) => unknown, thisArg?: any) => boolean;
							fill: (value: number, start?: number | undefined, end?: number | undefined) => Float32Array;
							filter: (predicate: (value: number, index: number, array: Float32Array) => any, thisArg?: any) => Float32Array;
							find: (predicate: (value: number, index: number, obj: Float32Array) => boolean, thisArg?: any) => number | undefined;
							findIndex: (predicate: (value: number, index: number, obj: Float32Array) => boolean, thisArg?: any) => number;
							forEach: (callbackfn: (value: number, index: number, array: Float32Array) => void, thisArg?: any) => void;
							indexOf: (searchElement: number, fromIndex?: number | undefined) => number;
							join: (separator?: string | undefined) => string;
							lastIndexOf: (searchElement: number, fromIndex?: number | undefined) => number;
							readonly length: number;
							map: (callbackfn: (value: number, index: number, array: Float32Array) => number, thisArg?: any) => Float32Array;
							reduce: {
								(callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number): number;
								(callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number, initialValue: number): number;
								<U>(callbackfn: (previousValue: U, currentValue: number, currentIndex: number, array: Float32Array) => U, initialValue: U): U;
							};
							reduceRight: {
								(callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number): number;
								(callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number, initialValue: number): number;
								<U_1>(callbackfn: (previousValue: U_1, currentValue: number, currentIndex: number, array: Float32Array) => U_1, initialValue: U_1): U_1;
							};
							reverse: () => Float32Array;
							set: (array: ArrayLike<number>, offset?: number | undefined) => void;
							slice: (start?: number | undefined, end?: number | undefined) => Float32Array;
							some: (predicate: (value: number, index: number, array: Float32Array) => unknown, thisArg?: any) => boolean;
							sort: (compareFn?: ((a: number, b: number) => number) | undefined) => Float32Array;
							subarray: (begin?: number | undefined, end?: number | undefined) => Float32Array;
							toLocaleString: () => string;
							toString: () => string;
							valueOf: () => Float32Array;
							entries: () => IterableIterator<[
								number,
								number
							]>;
							keys: () => IterableIterator<number>;
							values: () => IterableIterator<number>;
							includes: (searchElement: number, fromIndex?: number | undefined) => boolean;
							[Symbol.iterator]: () => IterableIterator<number>;
							readonly [Symbol.toStringTag]: "Float32Array";
							at: (index: number) => number | undefined;
						};
						ValueTypeName: string;
						TimeBufferType: {
							[x: number]: number;
							readonly BYTES_PER_ELEMENT: number;
							readonly buffer: {
								readonly byteLength: number;
								slice: (begin: number, end?: number | undefined) => ArrayBuffer;
								readonly [Symbol.toStringTag]: string;
							} | {
								readonly byteLength: number;
								slice: (begin: number, end?: number | undefined) => SharedArrayBuffer;
								readonly [Symbol.species]: SharedArrayBuffer;
								readonly [Symbol.toStringTag]: "SharedArrayBuffer";
							};
							readonly byteLength: number;
							readonly byteOffset: number;
							copyWithin: (target: number, start: number, end?: number | undefined) => Float32Array;
							every: (predicate: (value: number, index: number, array: Float32Array) => unknown, thisArg?: any) => boolean;
							fill: (value: number, start?: number | undefined, end?: number | undefined) => Float32Array;
							filter: (predicate: (value: number, index: number, array: Float32Array) => any, thisArg?: any) => Float32Array;
							find: (predicate: (value: number, index: number, obj: Float32Array) => boolean, thisArg?: any) => number | undefined;
							findIndex: (predicate: (value: number, index: number, obj: Float32Array) => boolean, thisArg?: any) => number;
							forEach: (callbackfn: (value: number, index: number, array: Float32Array) => void, thisArg?: any) => void;
							indexOf: (searchElement: number, fromIndex?: number | undefined) => number;
							join: (separator?: string | undefined) => string;
							lastIndexOf: (searchElement: number, fromIndex?: number | undefined) => number;
							readonly length: number;
							map: (callbackfn: (value: number, index: number, array: Float32Array) => number, thisArg?: any) => Float32Array;
							reduce: {
								(callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number): number;
								(callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number, initialValue: number): number;
								<U>(callbackfn: (previousValue: U, currentValue: number, currentIndex: number, array: Float32Array) => U, initialValue: U): U;
							};
							reduceRight: {
								(callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number): number;
								(callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number, initialValue: number): number;
								<U_1>(callbackfn: (previousValue: U_1, currentValue: number, currentIndex: number, array: Float32Array) => U_1, initialValue: U_1): U_1;
							};
							reverse: () => Float32Array;
							set: (array: ArrayLike<number>, offset?: number | undefined) => void;
							slice: (start?: number | undefined, end?: number | undefined) => Float32Array;
							some: (predicate: (value: number, index: number, array: Float32Array) => unknown, thisArg?: any) => boolean;
							sort: (compareFn?: ((a: number, b: number) => number) | undefined) => Float32Array;
							subarray: (begin?: number | undefined, end?: number | undefined) => Float32Array;
							toLocaleString: () => string;
							toString: () => string;
							valueOf: () => Float32Array;
							entries: () => IterableIterator<[
								number,
								number
							]>;
							keys: () => IterableIterator<number>;
							values: () => IterableIterator<number>;
							includes: (searchElement: number, fromIndex?: number | undefined) => boolean;
							[Symbol.iterator]: () => IterableIterator<number>;
							readonly [Symbol.toStringTag]: "Float32Array";
							at: (index: number) => number | undefined;
						};
						ValueBufferType: {
							[x: number]: number;
							readonly BYTES_PER_ELEMENT: number;
							readonly buffer: {
								readonly byteLength: number;
								slice: (begin: number, end?: number | undefined) => ArrayBuffer;
								readonly [Symbol.toStringTag]: string;
							} | {
								readonly byteLength: number;
								slice: (begin: number, end?: number | undefined) => SharedArrayBuffer;
								readonly [Symbol.species]: SharedArrayBuffer;
								readonly [Symbol.toStringTag]: "SharedArrayBuffer";
							};
							readonly byteLength: number;
							readonly byteOffset: number;
							copyWithin: (target: number, start: number, end?: number | undefined) => Float32Array;
							every: (predicate: (value: number, index: number, array: Float32Array) => unknown, thisArg?: any) => boolean;
							fill: (value: number, start?: number | undefined, end?: number | undefined) => Float32Array;
							filter: (predicate: (value: number, index: number, array: Float32Array) => any, thisArg?: any) => Float32Array;
							find: (predicate: (value: number, index: number, obj: Float32Array) => boolean, thisArg?: any) => number | undefined;
							findIndex: (predicate: (value: number, index: number, obj: Float32Array) => boolean, thisArg?: any) => number;
							forEach: (callbackfn: (value: number, index: number, array: Float32Array) => void, thisArg?: any) => void;
							indexOf: (searchElement: number, fromIndex?: number | undefined) => number;
							join: (separator?: string | undefined) => string;
							lastIndexOf: (searchElement: number, fromIndex?: number | undefined) => number;
							readonly length: number;
							map: (callbackfn: (value: number, index: number, array: Float32Array) => number, thisArg?: any) => Float32Array;
							reduce: {
								(callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number): number;
								(callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number, initialValue: number): number;
								<U>(callbackfn: (previousValue: U, currentValue: number, currentIndex: number, array: Float32Array) => U, initialValue: U): U;
							};
							reduceRight: {
								(callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number): number;
								(callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number, initialValue: number): number;
								<U_1>(callbackfn: (previousValue: U_1, currentValue: number, currentIndex: number, array: Float32Array) => U_1, initialValue: U_1): U_1;
							};
							reverse: () => Float32Array;
							set: (array: ArrayLike<number>, offset?: number | undefined) => void;
							slice: (start?: number | undefined, end?: number | undefined) => Float32Array;
							some: (predicate: (value: number, index: number, array: Float32Array) => unknown, thisArg?: any) => boolean;
							sort: (compareFn?: ((a: number, b: number) => number) | undefined) => Float32Array;
							subarray: (begin?: number | undefined, end?: number | undefined) => Float32Array;
							toLocaleString: () => string;
							toString: () => string;
							valueOf: () => Float32Array;
							entries: () => IterableIterator<[
								number,
								number
							]>;
							keys: () => IterableIterator<number>;
							values: () => IterableIterator<number>;
							includes: (searchElement: number, fromIndex?: number | undefined) => boolean;
							[Symbol.iterator]: () => IterableIterator<number>;
							readonly [Symbol.toStringTag]: "Float32Array";
							at: (index: number) => number | undefined;
						};
						DefaultInterpolation: InterpolationModes;
						InterpolantFactoryMethodDiscrete: (result: any) => DiscreteInterpolant;
						InterpolantFactoryMethodLinear: (result: any) => LinearInterpolant;
						InterpolantFactoryMethodSmooth: (result: any) => CubicInterpolant;
						setInterpolation: (interpolation: InterpolationModes) => KeyframeTrack;
						getInterpolation: () => InterpolationModes;
						createInterpolant: () => Interpolant;
						getValueSize: () => number;
						shift: (timeOffset: number) => KeyframeTrack;
						scale: (timeScale: number) => KeyframeTrack;
						trim: (startTime: number, endTime: number) => KeyframeTrack;
						validate: () => boolean;
						optimize: () => KeyframeTrack;
						clone: () => KeyframeTrack;
					}[];
					blendMode: AnimationBlendMode;
					duration: number;
					uuid: string;
					results: any[];
					resetDuration: () => AnimationClip;
					trim: () => AnimationClip;
					validate: () => boolean;
					optimize: () => AnimationClip;
					clone: () => AnimationClip;
					toJSON: (clip: AnimationClip) => any;
				}[];
				userData: {
					[key: string]: any;
				};
				customDepthMaterial?: {
					alphaTest: number;
					alphaToCoverage: boolean;
					blendDst: BlendingDstFactor;
					blendDstAlpha: number | null;
					blendEquation: BlendingEquation;
					blendEquationAlpha: number | null;
					blending: Blending;
					blendSrc: 210 | BlendingDstFactor;
					blendSrcAlpha: number | null;
					clipIntersection: boolean;
					clippingPlanes: any;
					clipShadows: boolean;
					colorWrite: boolean;
					defines: {
						[key: string]: any;
					} | undefined;
					depthFunc: DepthModes;
					depthTest: boolean;
					depthWrite: boolean;
					id: number;
					stencilWrite: boolean;
					stencilFunc: StencilFunc;
					stencilRef: number;
					stencilWriteMask: number;
					stencilFuncMask: number;
					stencilFail: StencilOp;
					stencilZFail: StencilOp;
					stencilZPass: StencilOp;
					readonly isMaterial: true;
					name: string;
					needsUpdate: boolean;
					opacity: number;
					polygonOffset: boolean;
					polygonOffsetFactor: number;
					polygonOffsetUnits: number;
					precision: "highp" | "mediump" | "lowp" | null;
					premultipliedAlpha: boolean;
					forceSinglePass: boolean;
					dithering: boolean;
					side: Side;
					shadowSide: Side | null;
					toneMapped: boolean;
					transparent: boolean;
					type: string;
					uuid: string;
					vertexColors: boolean;
					visible: boolean;
					userData: any;
					version: number;
					clone: () => Material;
					copy: (material: Material) => Material;
					dispose: () => void;
					onBeforeCompile: (shader: Shader, renderer: WebGLRenderer) => void;
					customProgramCacheKey: () => string;
					setValues: (values: MaterialParameters) => void;
					toJSON: (meta?: any) => any;
					addEventListener: <T extends string>(type: T, listener: EventListener<Event, T, Material>) => void;
					hasEventListener: <T_1 extends string>(type: T_1, listener: EventListener<Event, T_1, Material>) => boolean;
					removeEventListener: <T_2 extends string>(type: T_2, listener: EventListener<Event, T_2, Material>) => void;
					dispatchEvent: (event: Event) => void;
				} | undefined;
				customDistanceMaterial?: {
					alphaTest: number;
					alphaToCoverage: boolean;
					blendDst: BlendingDstFactor;
					blendDstAlpha: number | null;
					blendEquation: BlendingEquation;
					blendEquationAlpha: number | null;
					blending: Blending;
					blendSrc: 210 | BlendingDstFactor;
					blendSrcAlpha: number | null;
					clipIntersection: boolean;
					clippingPlanes: any;
					clipShadows: boolean;
					colorWrite: boolean;
					defines: {
						[key: string]: any;
					} | undefined;
					depthFunc: DepthModes;
					depthTest: boolean;
					depthWrite: boolean;
					id: number;
					stencilWrite: boolean;
					stencilFunc: StencilFunc;
					stencilRef: number;
					stencilWriteMask: number;
					stencilFuncMask: number;
					stencilFail: StencilOp;
					stencilZFail: StencilOp;
					stencilZPass: StencilOp;
					readonly isMaterial: true;
					name: string;
					needsUpdate: boolean;
					opacity: number;
					polygonOffset: boolean;
					polygonOffsetFactor: number;
					polygonOffsetUnits: number;
					precision: "highp" | "mediump" | "lowp" | null;
					premultipliedAlpha: boolean;
					forceSinglePass: boolean;
					dithering: boolean;
					side: Side;
					shadowSide: Side | null;
					toneMapped: boolean;
					transparent: boolean;
					type: string;
					uuid: string;
					vertexColors: boolean;
					visible: boolean;
					userData: any;
					version: number;
					clone: () => Material;
					copy: (material: Material) => Material;
					dispose: () => void;
					onBeforeCompile: (shader: Shader, renderer: WebGLRenderer) => void;
					customProgramCacheKey: () => string;
					setValues: (values: MaterialParameters) => void;
					toJSON: (meta?: any) => any;
					addEventListener: <T extends string>(type: T, listener: EventListener<Event, T, Material>) => void;
					hasEventListener: <T_1 extends string>(type: T_1, listener: EventListener<Event, T_1, Material>) => boolean;
					removeEventListener: <T_2 extends string>(type: T_2, listener: EventListener<Event, T_2, Material>) => void;
					dispatchEvent: (event: Event) => void;
				} | undefined;
				onBeforeRender: (renderer: WebGLRenderer, scene: Scene, camera: Camera, geometry: BufferGeometry<NormalBufferAttributes>, material: Material, group: Group) => void;
				onAfterRender: (renderer: WebGLRenderer, scene: Scene, camera: Camera, geometry: BufferGeometry<NormalBufferAttributes>, material: Material, group: Group) => void;
				applyMatrix4: (matrix: Matrix4) => void;
				applyQuaternion: (quaternion: Quaternion) => Object3D<Event>;
				setRotationFromAxisAngle: (axis: Vector3, angle: number) => void;
				setRotationFromEuler: (euler: Euler) => void;
				setRotationFromMatrix: (m: Matrix4) => void;
				setRotationFromQuaternion: (q: Quaternion) => void;
				rotateOnAxis: (axis: Vector3, angle: number) => Object3D<Event>;
				rotateOnWorldAxis: (axis: Vector3, angle: number) => Object3D<Event>;
				rotateX: (angle: number) => Object3D<Event>;
				rotateY: (angle: number) => Object3D<Event>;
				rotateZ: (angle: number) => Object3D<Event>;
				translateOnAxis: (axis: Vector3, distance: number) => Object3D<Event>;
				translateX: (distance: number) => Object3D<Event>;
				translateY: (distance: number) => Object3D<Event>;
				translateZ: (distance: number) => Object3D<Event>;
				localToWorld: (vector: Vector3) => Vector3;
				worldToLocal: (vector: Vector3) => Vector3;
				lookAt: {
					(vector: Vector3): void;
					(x: number, y: number, z: number): void;
				};
				add: (...object: Object3D<Event>[]) => Object3D<Event>;
				remove: (...object: Object3D<Event>[]) => Object3D<Event>;
				removeFromParent: () => Object3D<Event>;
				clear: () => Object3D<Event>;
				attach: (object: Object3D<Event>) => Object3D<Event>;
				getObjectById: (id: number) => Object3D<Event> | undefined;
				getObjectByName: (name: string) => Object3D<Event> | undefined;
				getObjectByProperty: (name: string, value: any) => Object3D<Event> | undefined;
				getObjectsByProperty: (name: string, value: any) => Object3D<Event>[];
				getWorldPosition: (target: Vector3) => Vector3;
				getWorldQuaternion: (target: Quaternion) => Quaternion;
				getWorldScale: (target: Vector3) => Vector3;
				getWorldDirection: (target: Vector3) => Vector3;
				raycast: (raycaster: Raycaster, intersects: Intersection<Object3D<Event>>[]) => void;
				traverse: (callback: (object: Object3D<Event>) => any) => void;
				traverseVisible: (callback: (object: Object3D<Event>) => any) => void;
				traverseAncestors: (callback: (object: Object3D<Event>) => any) => void;
				updateMatrix: () => void;
				updateMatrixWorld: (force?: boolean | undefined) => void;
				updateWorldMatrix: (updateParents: boolean, updateChildren: boolean) => void;
				toJSON: (meta?: {
					geometries: any;
					materials: any;
					textures: any;
					images: any;
				} | undefined) => any;
				clone: (recursive?: boolean | undefined) => Object3D<Event>;
				copy: (source: Object3D<Event>, recursive?: boolean | undefined) => Object3D<Event>;
				addEventListener: <T_3 extends string>(type: T_3, listener: EventListener<Event, T_3, Object3D<Event>>) => void;
				hasEventListener: <T_4 extends string>(type: T_4, listener: EventListener<Event, T_4, Object3D<Event>>) => boolean;
				removeEventListener: <T_5 extends string>(type: T_5, listener: EventListener<Event, T_5, Object3D<Event>>) => void;
				dispatchEvent: (event: Event) => void;
			} | null;
			children: {
				readonly isObject3D: true;
				readonly id: number;
				uuid: string;
				name: string;
				readonly type: string;
				parent: any | null;
				children: any[];
				up: {
					x: number;
					y: number;
					z: number;
					readonly isVector3: true;
					set: (x: number, y: number, z: number) => Vector3;
					setScalar: (scalar: number) => Vector3;
					setX: (x: number) => Vector3;
					setY: (y: number) => Vector3;
					setZ: (z: number) => Vector3;
					setComponent: (index: number, value: number) => Vector3;
					setFromColor: (color: Color) => Vector3;
					getComponent: (index: number) => number;
					clone: () => Vector3;
					copy: (v: Vector3) => Vector3;
					add: (v: Vector3) => Vector3;
					addScalar: (s: number) => Vector3;
					addScaledVector: (v: Vector3, s: number) => Vector3;
					addVectors: (a: Vector3, b: Vector3) => Vector3;
					sub: (a: Vector3) => Vector3;
					subScalar: (s: number) => Vector3;
					subVectors: (a: Vector3, b: Vector3) => Vector3;
					multiply: (v: Vector3) => Vector3;
					multiplyScalar: (s: number) => Vector3;
					multiplyVectors: (a: Vector3, b: Vector3) => Vector3;
					applyEuler: (euler: Euler) => Vector3;
					applyAxisAngle: (axis: Vector3, angle: number) => Vector3;
					applyMatrix3: (m: Matrix3) => Vector3;
					applyNormalMatrix: (m: Matrix3) => Vector3;
					applyMatrix4: (m: Matrix4) => Vector3;
					applyQuaternion: (q: Quaternion) => Vector3;
					project: (camera: Camera) => Vector3;
					unproject: (camera: Camera) => Vector3;
					transformDirection: (m: Matrix4) => Vector3;
					divide: (v: Vector3) => Vector3;
					divideScalar: (s: number) => Vector3;
					min: (v: Vector3) => Vector3;
					max: (v: Vector3) => Vector3;
					clamp: (min: Vector3, max: Vector3) => Vector3;
					clampScalar: (min: number, max: number) => Vector3;
					clampLength: (min: number, max: number) => Vector3;
					floor: () => Vector3;
					ceil: () => Vector3;
					round: () => Vector3;
					roundToZero: () => Vector3;
					negate: () => Vector3;
					dot: (v: Vector3) => number;
					lengthSq: () => number;
					length: () => number;
					lengthManhattan: () => number;
					manhattanLength: () => number;
					manhattanDistanceTo: (v: Vector3) => number;
					normalize: () => Vector3;
					setLength: (l: number) => Vector3;
					lerp: (v: Vector3, alpha: number) => Vector3;
					lerpVectors: (v1: Vector3, v2: Vector3, alpha: number) => Vector3;
					cross: (a: Vector3) => Vector3;
					crossVectors: (a: Vector3, b: Vector3) => Vector3;
					projectOnVector: (v: Vector3) => Vector3;
					projectOnPlane: (planeNormal: Vector3) => Vector3;
					reflect: (vector: Vector3) => Vector3;
					angleTo: (v: Vector3) => number;
					distanceTo: (v: Vector3) => number;
					distanceToSquared: (v: Vector3) => number;
					distanceToManhattan: (v: Vector3) => number;
					setFromSpherical: (s: Spherical) => Vector3;
					setFromSphericalCoords: (r: number, phi: number, theta: number) => Vector3;
					setFromCylindrical: (s: Cylindrical) => Vector3;
					setFromCylindricalCoords: (radius: number, theta: number, y: number) => Vector3;
					setFromMatrixPosition: (m: Matrix4) => Vector3;
					setFromMatrixScale: (m: Matrix4) => Vector3;
					setFromMatrixColumn: (matrix: Matrix4, index: number) => Vector3;
					setFromMatrix3Column: (matrix: Matrix3, index: number) => Vector3;
					setFromEuler: (e: Euler) => Vector3;
					equals: (v: Vector3) => boolean;
					fromArray: (array: number[] | ArrayLike<number>, offset?: number | undefined) => Vector3;
					toArray: {
						(array?: number[] | undefined, offset?: number | undefined): number[];
						(array?: Vector3Tuple | undefined, offset?: 0 | undefined): Vector3Tuple;
						(array: ArrayLike<number>, offset?: number | undefined): ArrayLike<number>;
					};
					fromBufferAttribute: (attribute: BufferAttribute | InterleavedBufferAttribute, index: number) => Vector3;
					random: () => Vector3;
					randomDirection: () => Vector3;
				};
				readonly position: {
					x: number;
					y: number;
					z: number;
					readonly isVector3: true;
					set: (x: number, y: number, z: number) => Vector3;
					setScalar: (scalar: number) => Vector3;
					setX: (x: number) => Vector3;
					setY: (y: number) => Vector3;
					setZ: (z: number) => Vector3;
					setComponent: (index: number, value: number) => Vector3;
					setFromColor: (color: Color) => Vector3;
					getComponent: (index: number) => number;
					clone: () => Vector3;
					copy: (v: Vector3) => Vector3;
					add: (v: Vector3) => Vector3;
					addScalar: (s: number) => Vector3;
					addScaledVector: (v: Vector3, s: number) => Vector3;
					addVectors: (a: Vector3, b: Vector3) => Vector3;
					sub: (a: Vector3) => Vector3;
					subScalar: (s: number) => Vector3;
					subVectors: (a: Vector3, b: Vector3) => Vector3;
					multiply: (v: Vector3) => Vector3;
					multiplyScalar: (s: number) => Vector3;
					multiplyVectors: (a: Vector3, b: Vector3) => Vector3;
					applyEuler: (euler: Euler) => Vector3;
					applyAxisAngle: (axis: Vector3, angle: number) => Vector3;
					applyMatrix3: (m: Matrix3) => Vector3;
					applyNormalMatrix: (m: Matrix3) => Vector3;
					applyMatrix4: (m: Matrix4) => Vector3;
					applyQuaternion: (q: Quaternion) => Vector3;
					project: (camera: Camera) => Vector3;
					unproject: (camera: Camera) => Vector3;
					transformDirection: (m: Matrix4) => Vector3;
					divide: (v: Vector3) => Vector3;
					divideScalar: (s: number) => Vector3;
					min: (v: Vector3) => Vector3;
					max: (v: Vector3) => Vector3;
					clamp: (min: Vector3, max: Vector3) => Vector3;
					clampScalar: (min: number, max: number) => Vector3;
					clampLength: (min: number, max: number) => Vector3;
					floor: () => Vector3;
					ceil: () => Vector3;
					round: () => Vector3;
					roundToZero: () => Vector3;
					negate: () => Vector3;
					dot: (v: Vector3) => number;
					lengthSq: () => number;
					length: () => number;
					lengthManhattan: () => number;
					manhattanLength: () => number;
					manhattanDistanceTo: (v: Vector3) => number;
					normalize: () => Vector3;
					setLength: (l: number) => Vector3;
					lerp: (v: Vector3, alpha: number) => Vector3;
					lerpVectors: (v1: Vector3, v2: Vector3, alpha: number) => Vector3;
					cross: (a: Vector3) => Vector3;
					crossVectors: (a: Vector3, b: Vector3) => Vector3;
					projectOnVector: (v: Vector3) => Vector3;
					projectOnPlane: (planeNormal: Vector3) => Vector3;
					reflect: (vector: Vector3) => Vector3;
					angleTo: (v: Vector3) => number;
					distanceTo: (v: Vector3) => number;
					distanceToSquared: (v: Vector3) => number;
					distanceToManhattan: (v: Vector3) => number;
					setFromSpherical: (s: Spherical) => Vector3;
					setFromSphericalCoords: (r: number, phi: number, theta: number) => Vector3;
					setFromCylindrical: (s: Cylindrical) => Vector3;
					setFromCylindricalCoords: (radius: number, theta: number, y: number) => Vector3;
					setFromMatrixPosition: (m: Matrix4) => Vector3;
					setFromMatrixScale: (m: Matrix4) => Vector3;
					setFromMatrixColumn: (matrix: Matrix4, index: number) => Vector3;
					setFromMatrix3Column: (matrix: Matrix3, index: number) => Vector3;
					setFromEuler: (e: Euler) => Vector3;
					equals: (v: Vector3) => boolean;
					fromArray: (array: number[] | ArrayLike<number>, offset?: number | undefined) => Vector3;
					toArray: {
						(array?: number[] | undefined, offset?: number | undefined): number[];
						(array?: Vector3Tuple | undefined, offset?: 0 | undefined): Vector3Tuple;
						(array: ArrayLike<number>, offset?: number | undefined): ArrayLike<number>;
					};
					fromBufferAttribute: (attribute: BufferAttribute | InterleavedBufferAttribute, index: number) => Vector3;
					random: () => Vector3;
					randomDirection: () => Vector3;
				};
				readonly rotation: {
					x: number;
					y: number;
					z: number;
					order: EulerOrder;
					readonly isEuler: true;
					_onChangeCallback: () => void;
					set: (x: number, y: number, z: number, order?: EulerOrder | undefined) => Euler;
					clone: () => Euler;
					copy: (euler: Euler) => Euler;
					setFromRotationMatrix: (m: Matrix4, order?: EulerOrder | undefined, update?: boolean | undefined) => Euler;
					setFromQuaternion: (q: Quaternion, order?: EulerOrder | undefined, update?: boolean | undefined) => Euler;
					setFromVector3: (v: Vector3, order?: EulerOrder | undefined) => Euler;
					reorder: (newOrder: EulerOrder) => Euler;
					equals: (euler: Euler) => boolean;
					fromArray: (xyzo: [
						number,
						number,
						number,
						(EulerOrder | undefined)?,
						...any[]
					]) => Euler;
					toArray: (array?: (string | number | undefined)[] | undefined, offset?: number | undefined) => (string | number | undefined)[];
					_onChange: (callback: () => void) => Euler;
					[Symbol.iterator]: () => Generator<string | number, void, unknown>;
				};
				readonly quaternion: {
					x: number;
					y: number;
					z: number;
					w: number;
					readonly isQuaternion: true;
					set: (x: number, y: number, z: number, w: number) => Quaternion;
					clone: () => Quaternion;
					copy: (q: Quaternion) => Quaternion;
					setFromEuler: (euler: Euler, update?: boolean | undefined) => Quaternion;
					setFromAxisAngle: (axis: Vector3, angle: number) => Quaternion;
					setFromRotationMatrix: (m: Matrix4) => Quaternion;
					setFromUnitVectors: (vFrom: Vector3, vTo: Vector3) => Quaternion;
					angleTo: (q: Quaternion) => number;
					rotateTowards: (q: Quaternion, step: number) => Quaternion;
					identity: () => Quaternion;
					invert: () => Quaternion;
					conjugate: () => Quaternion;
					dot: (v: Quaternion) => number;
					lengthSq: () => number;
					length: () => number;
					normalize: () => Quaternion;
					multiply: (q: Quaternion) => Quaternion;
					premultiply: (q: Quaternion) => Quaternion;
					multiplyQuaternions: (a: Quaternion, b: Quaternion) => Quaternion;
					slerp: (qb: Quaternion, t: number) => Quaternion;
					slerpQuaternions: (qa: Quaternion, qb: Quaternion, t: number) => Quaternion;
					equals: (v: Quaternion) => boolean;
					fromArray: (array: number[] | ArrayLike<number>, offset?: number | undefined) => Quaternion;
					toArray: {
						(array?: number[] | undefined, offset?: number | undefined): number[];
						(array: ArrayLike<number>, offset?: number | undefined): ArrayLike<number>;
					};
					toJSON: () => [
						number,
						number,
						number,
						number
					];
					fromBufferAttribute: (attribute: BufferAttribute | InterleavedBufferAttribute, index: number) => Quaternion;
					_onChange: (callback: () => void) => Quaternion;
					_onChangeCallback: () => void;
					multiplyVector3: (v: any) => any;
					random: () => Quaternion;
					[Symbol.iterator]: () => Generator<number, void, unknown>;
				};
				readonly scale: {
					x: number;
					y: number;
					z: number;
					readonly isVector3: true;
					set: (x: number, y: number, z: number) => Vector3;
					setScalar: (scalar: number) => Vector3;
					setX: (x: number) => Vector3;
					setY: (y: number) => Vector3;
					setZ: (z: number) => Vector3;
					setComponent: (index: number, value: number) => Vector3;
					setFromColor: (color: Color) => Vector3;
					getComponent: (index: number) => number;
					clone: () => Vector3;
					copy: (v: Vector3) => Vector3;
					add: (v: Vector3) => Vector3;
					addScalar: (s: number) => Vector3;
					addScaledVector: (v: Vector3, s: number) => Vector3;
					addVectors: (a: Vector3, b: Vector3) => Vector3;
					sub: (a: Vector3) => Vector3;
					subScalar: (s: number) => Vector3;
					subVectors: (a: Vector3, b: Vector3) => Vector3;
					multiply: (v: Vector3) => Vector3;
					multiplyScalar: (s: number) => Vector3;
					multiplyVectors: (a: Vector3, b: Vector3) => Vector3;
					applyEuler: (euler: Euler) => Vector3;
					applyAxisAngle: (axis: Vector3, angle: number) => Vector3;
					applyMatrix3: (m: Matrix3) => Vector3;
					applyNormalMatrix: (m: Matrix3) => Vector3;
					applyMatrix4: (m: Matrix4) => Vector3;
					applyQuaternion: (q: Quaternion) => Vector3;
					project: (camera: Camera) => Vector3;
					unproject: (camera: Camera) => Vector3;
					transformDirection: (m: Matrix4) => Vector3;
					divide: (v: Vector3) => Vector3;
					divideScalar: (s: number) => Vector3;
					min: (v: Vector3) => Vector3;
					max: (v: Vector3) => Vector3;
					clamp: (min: Vector3, max: Vector3) => Vector3;
					clampScalar: (min: number, max: number) => Vector3;
					clampLength: (min: number, max: number) => Vector3;
					floor: () => Vector3;
					ceil: () => Vector3;
					round: () => Vector3;
					roundToZero: () => Vector3;
					negate: () => Vector3;
					dot: (v: Vector3) => number;
					lengthSq: () => number;
					length: () => number;
					lengthManhattan: () => number;
					manhattanLength: () => number;
					manhattanDistanceTo: (v: Vector3) => number;
					normalize: () => Vector3;
					setLength: (l: number) => Vector3;
					lerp: (v: Vector3, alpha: number) => Vector3;
					lerpVectors: (v1: Vector3, v2: Vector3, alpha: number) => Vector3;
					cross: (a: Vector3) => Vector3;
					crossVectors: (a: Vector3, b: Vector3) => Vector3;
					projectOnVector: (v: Vector3) => Vector3;
					projectOnPlane: (planeNormal: Vector3) => Vector3;
					reflect: (vector: Vector3) => Vector3;
					angleTo: (v: Vector3) => number;
					distanceTo: (v: Vector3) => number;
					distanceToSquared: (v: Vector3) => number;
					distanceToManhattan: (v: Vector3) => number;
					setFromSpherical: (s: Spherical) => Vector3;
					setFromSphericalCoords: (r: number, phi: number, theta: number) => Vector3;
					setFromCylindrical: (s: Cylindrical) => Vector3;
					setFromCylindricalCoords: (radius: number, theta: number, y: number) => Vector3;
					setFromMatrixPosition: (m: Matrix4) => Vector3;
					setFromMatrixScale: (m: Matrix4) => Vector3;
					setFromMatrixColumn: (matrix: Matrix4, index: number) => Vector3;
					setFromMatrix3Column: (matrix: Matrix3, index: number) => Vector3;
					setFromEuler: (e: Euler) => Vector3;
					equals: (v: Vector3) => boolean;
					fromArray: (array: number[] | ArrayLike<number>, offset?: number | undefined) => Vector3;
					toArray: {
						(array?: number[] | undefined, offset?: number | undefined): number[];
						(array?: Vector3Tuple | undefined, offset?: 0 | undefined): Vector3Tuple;
						(array: ArrayLike<number>, offset?: number | undefined): ArrayLike<number>;
					};
					fromBufferAttribute: (attribute: BufferAttribute | InterleavedBufferAttribute, index: number) => Vector3;
					random: () => Vector3;
					randomDirection: () => Vector3;
				};
				readonly modelViewMatrix: {
					elements: number[];
					set: (n11: number, n12: number, n13: number, n14: number, n21: number, n22: number, n23: number, n24: number, n31: number, n32: number, n33: number, n34: number, n41: number, n42: number, n43: number, n44: number) => Matrix4;
					identity: () => Matrix4;
					clone: () => Matrix4;
					copy: (m: Matrix4) => Matrix4;
					copyPosition: (m: Matrix4) => Matrix4;
					extractBasis: (xAxis: Vector3, yAxis: Vector3, zAxis: Vector3) => Matrix4;
					makeBasis: (xAxis: Vector3, yAxis: Vector3, zAxis: Vector3) => Matrix4;
					extractRotation: (m: Matrix4) => Matrix4;
					makeRotationFromEuler: (euler: Euler) => Matrix4;
					makeRotationFromQuaternion: (q: Quaternion) => Matrix4;
					lookAt: (eye: Vector3, target: Vector3, up: Vector3) => Matrix4;
					multiply: (m: Matrix4) => Matrix4;
					premultiply: (m: Matrix4) => Matrix4;
					multiplyMatrices: (a: Matrix4, b: Matrix4) => Matrix4;
					multiplyToArray: (a: Matrix4, b: Matrix4, r: number[]) => Matrix4;
					multiplyScalar: (s: number) => Matrix4;
					determinant: () => number;
					transpose: () => Matrix4;
					setPosition: (v: number | Vector3, y?: number | undefined, z?: number | undefined) => Matrix4;
					invert: () => Matrix4;
					scale: (v: Vector3) => Matrix4;
					getMaxScaleOnAxis: () => number;
					makeTranslation: (x: number, y: number, z: number) => Matrix4;
					makeRotationX: (theta: number) => Matrix4;
					makeRotationY: (theta: number) => Matrix4;
					makeRotationZ: (theta: number) => Matrix4;
					makeRotationAxis: (axis: Vector3, angle: number) => Matrix4;
					makeScale: (x: number, y: number, z: number) => Matrix4;
					makeShear: (xy: number, xz: number, yx: number, yz: number, zx: number, zy: number) => Matrix4;
					compose: (translation: Vector3, rotation: Quaternion, scale: Vector3) => Matrix4;
					decompose: (translation: Vector3, rotation: Quaternion, scale: Vector3) => Matrix4;
					makePerspective: {
						(left: number, right: number, bottom: number, top: number, near: number, far: number): Matrix4;
						(fov: number, aspect: number, near: number, far: number): Matrix4;
					};
					makeOrthographic: (left: number, right: number, top: number, bottom: number, near: number, far: number) => Matrix4;
					equals: (matrix: Matrix4) => boolean;
					fromArray: (array: number[] | ArrayLike<number>, offset?: number | undefined) => Matrix4;
					toArray: {
						(array?: number[] | undefined, offset?: number | undefined): number[];
						(array?: Matrix4Tuple | undefined, offset?: 0 | undefined): Matrix4Tuple;
						(array?: ArrayLike<number> | undefined, offset?: number | undefined): ArrayLike<number>;
					};
					setFromMatrix3: (m: Matrix3) => Matrix4;
					extractPosition: (m: Matrix4) => Matrix4;
					setRotationFromQuaternion: (q: Quaternion) => Matrix4;
					multiplyVector3: (v: any) => any;
					multiplyVector4: (v: any) => any;
					multiplyVector3Array: (array: number[]) => number[];
					rotateAxis: (v: any) => void;
					crossVector: (v: any) => void;
					flattenToArrayOffset: (array: number[], offset: number) => number[];
					getInverse: (matrix: Matrix) => Matrix;
				};
				readonly normalMatrix: {
					elements: number[];
					set: (n11: number, n12: number, n13: number, n21: number, n22: number, n23: number, n31: number, n32: number, n33: number) => Matrix3;
					identity: () => Matrix3;
					clone: () => Matrix3;
					copy: (m: Matrix3) => Matrix3;
					extractBasis: (xAxis: Vector3, yAxis: Vector3, zAxis: Vector3) => Matrix3;
					setFromMatrix4: (m: Matrix4) => Matrix3;
					multiplyScalar: (s: number) => Matrix3;
					determinant: () => number;
					invert: () => Matrix3;
					transpose: () => Matrix3;
					getNormalMatrix: (matrix4: Matrix4) => Matrix3;
					transposeIntoArray: (r: number[]) => Matrix3;
					setUvTransform: (tx: number, ty: number, sx: number, sy: number, rotation: number, cx: number, cy: number) => Matrix3;
					scale: (sx: number, sy: number) => Matrix3;
					makeTranslation: {
						(x: number, y: number): Matrix3;
						(x: number, y: number): Matrix3;
					};
					makeRotation: {
						(theta: number): Matrix3;
						(theta: number): Matrix3;
					};
					makeScale: {
						(x: number, y: number): Matrix3;
						(x: number, y: number): Matrix3;
					};
					rotate: (theta: number) => Matrix3;
					translate: (tx: number, ty: number) => Matrix3;
					equals: (matrix: Matrix3) => boolean;
					fromArray: (array: number[] | ArrayLike<number>, offset?: number | undefined) => Matrix3;
					toArray: {
						(array?: number[] | undefined, offset?: number | undefined): number[];
						(array?: Matrix3Tuple | undefined, offset?: 0 | undefined): Matrix3Tuple;
						(array?: ArrayLike<number> | undefined, offset?: number | undefined): ArrayLike<number>;
					};
					multiply: (m: Matrix3) => Matrix3;
					premultiply: (m: Matrix3) => Matrix3;
					multiplyMatrices: (a: Matrix3, b: Matrix3) => Matrix3;
					multiplyVector3: (vector: Vector3) => any;
					multiplyVector3Array: (a: any) => any;
					getInverse: {
						(matrix: Matrix4, throwOnDegenerate?: boolean | undefined): Matrix3;
						(matrix: Matrix): Matrix;
					};
					flattenToArrayOffset: (array: number[], offset: number) => number[];
				};
				matrix: {
					elements: number[];
					set: (n11: number, n12: number, n13: number, n14: number, n21: number, n22: number, n23: number, n24: number, n31: number, n32: number, n33: number, n34: number, n41: number, n42: number, n43: number, n44: number) => Matrix4;
					identity: () => Matrix4;
					clone: () => Matrix4;
					copy: (m: Matrix4) => Matrix4;
					copyPosition: (m: Matrix4) => Matrix4;
					extractBasis: (xAxis: Vector3, yAxis: Vector3, zAxis: Vector3) => Matrix4;
					makeBasis: (xAxis: Vector3, yAxis: Vector3, zAxis: Vector3) => Matrix4;
					extractRotation: (m: Matrix4) => Matrix4;
					makeRotationFromEuler: (euler: Euler) => Matrix4;
					makeRotationFromQuaternion: (q: Quaternion) => Matrix4;
					lookAt: (eye: Vector3, target: Vector3, up: Vector3) => Matrix4;
					multiply: (m: Matrix4) => Matrix4;
					premultiply: (m: Matrix4) => Matrix4;
					multiplyMatrices: (a: Matrix4, b: Matrix4) => Matrix4;
					multiplyToArray: (a: Matrix4, b: Matrix4, r: number[]) => Matrix4;
					multiplyScalar: (s: number) => Matrix4;
					determinant: () => number;
					transpose: () => Matrix4;
					setPosition: (v: number | Vector3, y?: number | undefined, z?: number | undefined) => Matrix4;
					invert: () => Matrix4;
					scale: (v: Vector3) => Matrix4;
					getMaxScaleOnAxis: () => number;
					makeTranslation: (x: number, y: number, z: number) => Matrix4;
					makeRotationX: (theta: number) => Matrix4;
					makeRotationY: (theta: number) => Matrix4;
					makeRotationZ: (theta: number) => Matrix4;
					makeRotationAxis: (axis: Vector3, angle: number) => Matrix4;
					makeScale: (x: number, y: number, z: number) => Matrix4;
					makeShear: (xy: number, xz: number, yx: number, yz: number, zx: number, zy: number) => Matrix4;
					compose: (translation: Vector3, rotation: Quaternion, scale: Vector3) => Matrix4;
					decompose: (translation: Vector3, rotation: Quaternion, scale: Vector3) => Matrix4;
					makePerspective: {
						(left: number, right: number, bottom: number, top: number, near: number, far: number): Matrix4;
						(fov: number, aspect: number, near: number, far: number): Matrix4;
					};
					makeOrthographic: (left: number, right: number, top: number, bottom: number, near: number, far: number) => Matrix4;
					equals: (matrix: Matrix4) => boolean;
					fromArray: (array: number[] | ArrayLike<number>, offset?: number | undefined) => Matrix4;
					toArray: {
						(array?: number[] | undefined, offset?: number | undefined): number[];
						(array?: Matrix4Tuple | undefined, offset?: 0 | undefined): Matrix4Tuple;
						(array?: ArrayLike<number> | undefined, offset?: number | undefined): ArrayLike<number>;
					};
					setFromMatrix3: (m: Matrix3) => Matrix4;
					extractPosition: (m: Matrix4) => Matrix4;
					setRotationFromQuaternion: (q: Quaternion) => Matrix4;
					multiplyVector3: (v: any) => any;
					multiplyVector4: (v: any) => any;
					multiplyVector3Array: (array: number[]) => number[];
					rotateAxis: (v: any) => void;
					crossVector: (v: any) => void;
					flattenToArrayOffset: (array: number[], offset: number) => number[];
					getInverse: (matrix: Matrix) => Matrix;
				};
				matrixWorld: {
					elements: number[];
					set: (n11: number, n12: number, n13: number, n14: number, n21: number, n22: number, n23: number, n24: number, n31: number, n32: number, n33: number, n34: number, n41: number, n42: number, n43: number, n44: number) => Matrix4;
					identity: () => Matrix4;
					clone: () => Matrix4;
					copy: (m: Matrix4) => Matrix4;
					copyPosition: (m: Matrix4) => Matrix4;
					extractBasis: (xAxis: Vector3, yAxis: Vector3, zAxis: Vector3) => Matrix4;
					makeBasis: (xAxis: Vector3, yAxis: Vector3, zAxis: Vector3) => Matrix4;
					extractRotation: (m: Matrix4) => Matrix4;
					makeRotationFromEuler: (euler: Euler) => Matrix4;
					makeRotationFromQuaternion: (q: Quaternion) => Matrix4;
					lookAt: (eye: Vector3, target: Vector3, up: Vector3) => Matrix4;
					multiply: (m: Matrix4) => Matrix4;
					premultiply: (m: Matrix4) => Matrix4;
					multiplyMatrices: (a: Matrix4, b: Matrix4) => Matrix4;
					multiplyToArray: (a: Matrix4, b: Matrix4, r: number[]) => Matrix4;
					multiplyScalar: (s: number) => Matrix4;
					determinant: () => number;
					transpose: () => Matrix4;
					setPosition: (v: number | Vector3, y?: number | undefined, z?: number | undefined) => Matrix4;
					invert: () => Matrix4;
					scale: (v: Vector3) => Matrix4;
					getMaxScaleOnAxis: () => number;
					makeTranslation: (x: number, y: number, z: number) => Matrix4;
					makeRotationX: (theta: number) => Matrix4;
					makeRotationY: (theta: number) => Matrix4;
					makeRotationZ: (theta: number) => Matrix4;
					makeRotationAxis: (axis: Vector3, angle: number) => Matrix4;
					makeScale: (x: number, y: number, z: number) => Matrix4;
					makeShear: (xy: number, xz: number, yx: number, yz: number, zx: number, zy: number) => Matrix4;
					compose: (translation: Vector3, rotation: Quaternion, scale: Vector3) => Matrix4;
					decompose: (translation: Vector3, rotation: Quaternion, scale: Vector3) => Matrix4;
					makePerspective: {
						(left: number, right: number, bottom: number, top: number, near: number, far: number): Matrix4;
						(fov: number, aspect: number, near: number, far: number): Matrix4;
					};
					makeOrthographic: (left: number, right: number, top: number, bottom: number, near: number, far: number) => Matrix4;
					equals: (matrix: Matrix4) => boolean;
					fromArray: (array: number[] | ArrayLike<number>, offset?: number | undefined) => Matrix4;
					toArray: {
						(array?: number[] | undefined, offset?: number | undefined): number[];
						(array?: Matrix4Tuple | undefined, offset?: 0 | undefined): Matrix4Tuple;
						(array?: ArrayLike<number> | undefined, offset?: number | undefined): ArrayLike<number>;
					};
					setFromMatrix3: (m: Matrix3) => Matrix4;
					extractPosition: (m: Matrix4) => Matrix4;
					setRotationFromQuaternion: (q: Quaternion) => Matrix4;
					multiplyVector3: (v: any) => any;
					multiplyVector4: (v: any) => any;
					multiplyVector3Array: (array: number[]) => number[];
					rotateAxis: (v: any) => void;
					crossVector: (v: any) => void;
					flattenToArrayOffset: (array: number[], offset: number) => number[];
					getInverse: (matrix: Matrix) => Matrix;
				};
				matrixAutoUpdate: boolean;
				matrixWorldAutoUpdate: boolean;
				matrixWorldNeedsUpdate: boolean;
				layers: {
					mask: number;
					set: (layer: number) => void;
					enable: (layer: number) => void;
					enableAll: () => void;
					toggle: (layer: number) => void;
					disable: (layer: number) => void;
					disableAll: () => void;
					test: (layers: Layers) => boolean;
					isEnabled: (layer: number) => boolean;
				};
				visible: boolean;
				castShadow: boolean;
				receiveShadow: boolean;
				frustumCulled: boolean;
				renderOrder: number;
				animations: {
					name: string;
					tracks: {
						name: string;
						times: {
							[x: number]: number;
							readonly BYTES_PER_ELEMENT: number;
							readonly buffer: {
								readonly byteLength: number;
								slice: (begin: number, end?: number | undefined) => ArrayBuffer;
								readonly [Symbol.toStringTag]: string;
							} | {
								readonly byteLength: number;
								slice: (begin: number, end?: number | undefined) => SharedArrayBuffer;
								readonly [Symbol.species]: SharedArrayBuffer;
								readonly [Symbol.toStringTag]: "SharedArrayBuffer";
							};
							readonly byteLength: number;
							readonly byteOffset: number;
							copyWithin: (target: number, start: number, end?: number | undefined) => Float32Array;
							every: (predicate: (value: number, index: number, array: Float32Array) => unknown, thisArg?: any) => boolean;
							fill: (value: number, start?: number | undefined, end?: number | undefined) => Float32Array;
							filter: (predicate: (value: number, index: number, array: Float32Array) => any, thisArg?: any) => Float32Array;
							find: (predicate: (value: number, index: number, obj: Float32Array) => boolean, thisArg?: any) => number | undefined;
							findIndex: (predicate: (value: number, index: number, obj: Float32Array) => boolean, thisArg?: any) => number;
							forEach: (callbackfn: (value: number, index: number, array: Float32Array) => void, thisArg?: any) => void;
							indexOf: (searchElement: number, fromIndex?: number | undefined) => number;
							join: (separator?: string | undefined) => string;
							lastIndexOf: (searchElement: number, fromIndex?: number | undefined) => number;
							readonly length: number;
							map: (callbackfn: (value: number, index: number, array: Float32Array) => number, thisArg?: any) => Float32Array;
							reduce: {
								(callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number): number;
								(callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number, initialValue: number): number;
								<U>(callbackfn: (previousValue: U, currentValue: number, currentIndex: number, array: Float32Array) => U, initialValue: U): U;
							};
							reduceRight: {
								(callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number): number;
								(callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number, initialValue: number): number;
								<U_1>(callbackfn: (previousValue: U_1, currentValue: number, currentIndex: number, array: Float32Array) => U_1, initialValue: U_1): U_1;
							};
							reverse: () => Float32Array;
							set: (array: ArrayLike<number>, offset?: number | undefined) => void;
							slice: (start?: number | undefined, end?: number | undefined) => Float32Array;
							some: (predicate: (value: number, index: number, array: Float32Array) => unknown, thisArg?: any) => boolean;
							sort: (compareFn?: ((a: number, b: number) => number) | undefined) => Float32Array;
							subarray: (begin?: number | undefined, end?: number | undefined) => Float32Array;
							toLocaleString: () => string;
							toString: () => string;
							valueOf: () => Float32Array;
							entries: () => IterableIterator<[
								number,
								number
							]>;
							keys: () => IterableIterator<number>;
							values: () => IterableIterator<number>;
							includes: (searchElement: number, fromIndex?: number | undefined) => boolean;
							[Symbol.iterator]: () => IterableIterator<number>;
							readonly [Symbol.toStringTag]: "Float32Array";
							at: (index: number) => number | undefined;
						};
						values: {
							[x: number]: number;
							readonly BYTES_PER_ELEMENT: number;
							readonly buffer: {
								readonly byteLength: number;
								slice: (begin: number, end?: number | undefined) => ArrayBuffer;
								readonly [Symbol.toStringTag]: string;
							} | {
								readonly byteLength: number;
								slice: (begin: number, end?: number | undefined) => SharedArrayBuffer;
								readonly [Symbol.species]: SharedArrayBuffer;
								readonly [Symbol.toStringTag]: "SharedArrayBuffer";
							};
							readonly byteLength: number;
							readonly byteOffset: number;
							copyWithin: (target: number, start: number, end?: number | undefined) => Float32Array;
							every: (predicate: (value: number, index: number, array: Float32Array) => unknown, thisArg?: any) => boolean;
							fill: (value: number, start?: number | undefined, end?: number | undefined) => Float32Array;
							filter: (predicate: (value: number, index: number, array: Float32Array) => any, thisArg?: any) => Float32Array;
							find: (predicate: (value: number, index: number, obj: Float32Array) => boolean, thisArg?: any) => number | undefined;
							findIndex: (predicate: (value: number, index: number, obj: Float32Array) => boolean, thisArg?: any) => number;
							forEach: (callbackfn: (value: number, index: number, array: Float32Array) => void, thisArg?: any) => void;
							indexOf: (searchElement: number, fromIndex?: number | undefined) => number;
							join: (separator?: string | undefined) => string;
							lastIndexOf: (searchElement: number, fromIndex?: number | undefined) => number;
							readonly length: number;
							map: (callbackfn: (value: number, index: number, array: Float32Array) => number, thisArg?: any) => Float32Array;
							reduce: {
								(callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number): number;
								(callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number, initialValue: number): number;
								<U>(callbackfn: (previousValue: U, currentValue: number, currentIndex: number, array: Float32Array) => U, initialValue: U): U;
							};
							reduceRight: {
								(callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number): number;
								(callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number, initialValue: number): number;
								<U_1>(callbackfn: (previousValue: U_1, currentValue: number, currentIndex: number, array: Float32Array) => U_1, initialValue: U_1): U_1;
							};
							reverse: () => Float32Array;
							set: (array: ArrayLike<number>, offset?: number | undefined) => void;
							slice: (start?: number | undefined, end?: number | undefined) => Float32Array;
							some: (predicate: (value: number, index: number, array: Float32Array) => unknown, thisArg?: any) => boolean;
							sort: (compareFn?: ((a: number, b: number) => number) | undefined) => Float32Array;
							subarray: (begin?: number | undefined, end?: number | undefined) => Float32Array;
							toLocaleString: () => string;
							toString: () => string;
							valueOf: () => Float32Array;
							entries: () => IterableIterator<[
								number,
								number
							]>;
							keys: () => IterableIterator<number>;
							values: () => IterableIterator<number>;
							includes: (searchElement: number, fromIndex?: number | undefined) => boolean;
							[Symbol.iterator]: () => IterableIterator<number>;
							readonly [Symbol.toStringTag]: "Float32Array";
							at: (index: number) => number | undefined;
						};
						ValueTypeName: string;
						TimeBufferType: {
							[x: number]: number;
							readonly BYTES_PER_ELEMENT: number;
							readonly buffer: {
								readonly byteLength: number;
								slice: (begin: number, end?: number | undefined) => ArrayBuffer;
								readonly [Symbol.toStringTag]: string;
							} | {
								readonly byteLength: number;
								slice: (begin: number, end?: number | undefined) => SharedArrayBuffer;
								readonly [Symbol.species]: SharedArrayBuffer;
								readonly [Symbol.toStringTag]: "SharedArrayBuffer";
							};
							readonly byteLength: number;
							readonly byteOffset: number;
							copyWithin: (target: number, start: number, end?: number | undefined) => Float32Array;
							every: (predicate: (value: number, index: number, array: Float32Array) => unknown, thisArg?: any) => boolean;
							fill: (value: number, start?: number | undefined, end?: number | undefined) => Float32Array;
							filter: (predicate: (value: number, index: number, array: Float32Array) => any, thisArg?: any) => Float32Array;
							find: (predicate: (value: number, index: number, obj: Float32Array) => boolean, thisArg?: any) => number | undefined;
							findIndex: (predicate: (value: number, index: number, obj: Float32Array) => boolean, thisArg?: any) => number;
							forEach: (callbackfn: (value: number, index: number, array: Float32Array) => void, thisArg?: any) => void;
							indexOf: (searchElement: number, fromIndex?: number | undefined) => number;
							join: (separator?: string | undefined) => string;
							lastIndexOf: (searchElement: number, fromIndex?: number | undefined) => number;
							readonly length: number;
							map: (callbackfn: (value: number, index: number, array: Float32Array) => number, thisArg?: any) => Float32Array;
							reduce: {
								(callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number): number;
								(callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number, initialValue: number): number;
								<U>(callbackfn: (previousValue: U, currentValue: number, currentIndex: number, array: Float32Array) => U, initialValue: U): U;
							};
							reduceRight: {
								(callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number): number;
								(callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number, initialValue: number): number;
								<U_1>(callbackfn: (previousValue: U_1, currentValue: number, currentIndex: number, array: Float32Array) => U_1, initialValue: U_1): U_1;
							};
							reverse: () => Float32Array;
							set: (array: ArrayLike<number>, offset?: number | undefined) => void;
							slice: (start?: number | undefined, end?: number | undefined) => Float32Array;
							some: (predicate: (value: number, index: number, array: Float32Array) => unknown, thisArg?: any) => boolean;
							sort: (compareFn?: ((a: number, b: number) => number) | undefined) => Float32Array;
							subarray: (begin?: number | undefined, end?: number | undefined) => Float32Array;
							toLocaleString: () => string;
							toString: () => string;
							valueOf: () => Float32Array;
							entries: () => IterableIterator<[
								number,
								number
							]>;
							keys: () => IterableIterator<number>;
							values: () => IterableIterator<number>;
							includes: (searchElement: number, fromIndex?: number | undefined) => boolean;
							[Symbol.iterator]: () => IterableIterator<number>;
							readonly [Symbol.toStringTag]: "Float32Array";
							at: (index: number) => number | undefined;
						};
						ValueBufferType: {
							[x: number]: number;
							readonly BYTES_PER_ELEMENT: number;
							readonly buffer: {
								readonly byteLength: number;
								slice: (begin: number, end?: number | undefined) => ArrayBuffer;
								readonly [Symbol.toStringTag]: string;
							} | {
								readonly byteLength: number;
								slice: (begin: number, end?: number | undefined) => SharedArrayBuffer;
								readonly [Symbol.species]: SharedArrayBuffer;
								readonly [Symbol.toStringTag]: "SharedArrayBuffer";
							};
							readonly byteLength: number;
							readonly byteOffset: number;
							copyWithin: (target: number, start: number, end?: number | undefined) => Float32Array;
							every: (predicate: (value: number, index: number, array: Float32Array) => unknown, thisArg?: any) => boolean;
							fill: (value: number, start?: number | undefined, end?: number | undefined) => Float32Array;
							filter: (predicate: (value: number, index: number, array: Float32Array) => any, thisArg?: any) => Float32Array;
							find: (predicate: (value: number, index: number, obj: Float32Array) => boolean, thisArg?: any) => number | undefined;
							findIndex: (predicate: (value: number, index: number, obj: Float32Array) => boolean, thisArg?: any) => number;
							forEach: (callbackfn: (value: number, index: number, array: Float32Array) => void, thisArg?: any) => void;
							indexOf: (searchElement: number, fromIndex?: number | undefined) => number;
							join: (separator?: string | undefined) => string;
							lastIndexOf: (searchElement: number, fromIndex?: number | undefined) => number;
							readonly length: number;
							map: (callbackfn: (value: number, index: number, array: Float32Array) => number, thisArg?: any) => Float32Array;
							reduce: {
								(callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number): number;
								(callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number, initialValue: number): number;
								<U>(callbackfn: (previousValue: U, currentValue: number, currentIndex: number, array: Float32Array) => U, initialValue: U): U;
							};
							reduceRight: {
								(callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number): number;
								(callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number, initialValue: number): number;
								<U_1>(callbackfn: (previousValue: U_1, currentValue: number, currentIndex: number, array: Float32Array) => U_1, initialValue: U_1): U_1;
							};
							reverse: () => Float32Array;
							set: (array: ArrayLike<number>, offset?: number | undefined) => void;
							slice: (start?: number | undefined, end?: number | undefined) => Float32Array;
							some: (predicate: (value: number, index: number, array: Float32Array) => unknown, thisArg?: any) => boolean;
							sort: (compareFn?: ((a: number, b: number) => number) | undefined) => Float32Array;
							subarray: (begin?: number | undefined, end?: number | undefined) => Float32Array;
							toLocaleString: () => string;
							toString: () => string;
							valueOf: () => Float32Array;
							entries: () => IterableIterator<[
								number,
								number
							]>;
							keys: () => IterableIterator<number>;
							values: () => IterableIterator<number>;
							includes: (searchElement: number, fromIndex?: number | undefined) => boolean;
							[Symbol.iterator]: () => IterableIterator<number>;
							readonly [Symbol.toStringTag]: "Float32Array";
							at: (index: number) => number | undefined;
						};
						DefaultInterpolation: InterpolationModes;
						InterpolantFactoryMethodDiscrete: (result: any) => DiscreteInterpolant;
						InterpolantFactoryMethodLinear: (result: any) => LinearInterpolant;
						InterpolantFactoryMethodSmooth: (result: any) => CubicInterpolant;
						setInterpolation: (interpolation: InterpolationModes) => KeyframeTrack;
						getInterpolation: () => InterpolationModes;
						createInterpolant: () => Interpolant;
						getValueSize: () => number;
						shift: (timeOffset: number) => KeyframeTrack;
						scale: (timeScale: number) => KeyframeTrack;
						trim: (startTime: number, endTime: number) => KeyframeTrack;
						validate: () => boolean;
						optimize: () => KeyframeTrack;
						clone: () => KeyframeTrack;
					}[];
					blendMode: AnimationBlendMode;
					duration: number;
					uuid: string;
					results: any[];
					resetDuration: () => AnimationClip;
					trim: () => AnimationClip;
					validate: () => boolean;
					optimize: () => AnimationClip;
					clone: () => AnimationClip;
					toJSON: (clip: AnimationClip) => any;
				}[];
				userData: {
					[key: string]: any;
				};
				customDepthMaterial?: {
					alphaTest: number;
					alphaToCoverage: boolean;
					blendDst: BlendingDstFactor;
					blendDstAlpha: number | null;
					blendEquation: BlendingEquation;
					blendEquationAlpha: number | null;
					blending: Blending;
					blendSrc: 210 | BlendingDstFactor;
					blendSrcAlpha: number | null;
					clipIntersection: boolean;
					clippingPlanes: any;
					clipShadows: boolean;
					colorWrite: boolean;
					defines: {
						[key: string]: any;
					} | undefined;
					depthFunc: DepthModes;
					depthTest: boolean;
					depthWrite: boolean;
					id: number;
					stencilWrite: boolean;
					stencilFunc: StencilFunc;
					stencilRef: number;
					stencilWriteMask: number;
					stencilFuncMask: number;
					stencilFail: StencilOp;
					stencilZFail: StencilOp;
					stencilZPass: StencilOp;
					readonly isMaterial: true;
					name: string;
					needsUpdate: boolean;
					opacity: number;
					polygonOffset: boolean;
					polygonOffsetFactor: number;
					polygonOffsetUnits: number;
					precision: "highp" | "mediump" | "lowp" | null;
					premultipliedAlpha: boolean;
					forceSinglePass: boolean;
					dithering: boolean;
					side: Side;
					shadowSide: Side | null;
					toneMapped: boolean;
					transparent: boolean;
					type: string;
					uuid: string;
					vertexColors: boolean;
					visible: boolean;
					userData: any;
					version: number;
					clone: () => Material;
					copy: (material: Material) => Material;
					dispose: () => void;
					onBeforeCompile: (shader: Shader, renderer: WebGLRenderer) => void;
					customProgramCacheKey: () => string;
					setValues: (values: MaterialParameters) => void;
					toJSON: (meta?: any) => any;
					addEventListener: <T extends string>(type: T, listener: EventListener<Event, T, Material>) => void;
					hasEventListener: <T_1 extends string>(type: T_1, listener: EventListener<Event, T_1, Material>) => boolean;
					removeEventListener: <T_2 extends string>(type: T_2, listener: EventListener<Event, T_2, Material>) => void;
					dispatchEvent: (event: Event) => void;
				} | undefined;
				customDistanceMaterial?: {
					alphaTest: number;
					alphaToCoverage: boolean;
					blendDst: BlendingDstFactor;
					blendDstAlpha: number | null;
					blendEquation: BlendingEquation;
					blendEquationAlpha: number | null;
					blending: Blending;
					blendSrc: 210 | BlendingDstFactor;
					blendSrcAlpha: number | null;
					clipIntersection: boolean;
					clippingPlanes: any;
					clipShadows: boolean;
					colorWrite: boolean;
					defines: {
						[key: string]: any;
					} | undefined;
					depthFunc: DepthModes;
					depthTest: boolean;
					depthWrite: boolean;
					id: number;
					stencilWrite: boolean;
					stencilFunc: StencilFunc;
					stencilRef: number;
					stencilWriteMask: number;
					stencilFuncMask: number;
					stencilFail: StencilOp;
					stencilZFail: StencilOp;
					stencilZPass: StencilOp;
					readonly isMaterial: true;
					name: string;
					needsUpdate: boolean;
					opacity: number;
					polygonOffset: boolean;
					polygonOffsetFactor: number;
					polygonOffsetUnits: number;
					precision: "highp" | "mediump" | "lowp" | null;
					premultipliedAlpha: boolean;
					forceSinglePass: boolean;
					dithering: boolean;
					side: Side;
					shadowSide: Side | null;
					toneMapped: boolean;
					transparent: boolean;
					type: string;
					uuid: string;
					vertexColors: boolean;
					visible: boolean;
					userData: any;
					version: number;
					clone: () => Material;
					copy: (material: Material) => Material;
					dispose: () => void;
					onBeforeCompile: (shader: Shader, renderer: WebGLRenderer) => void;
					customProgramCacheKey: () => string;
					setValues: (values: MaterialParameters) => void;
					toJSON: (meta?: any) => any;
					addEventListener: <T extends string>(type: T, listener: EventListener<Event, T, Material>) => void;
					hasEventListener: <T_1 extends string>(type: T_1, listener: EventListener<Event, T_1, Material>) => boolean;
					removeEventListener: <T_2 extends string>(type: T_2, listener: EventListener<Event, T_2, Material>) => void;
					dispatchEvent: (event: Event) => void;
				} | undefined;
				onBeforeRender: (renderer: WebGLRenderer, scene: Scene, camera: Camera, geometry: BufferGeometry<NormalBufferAttributes>, material: Material, group: Group) => void;
				onAfterRender: (renderer: WebGLRenderer, scene: Scene, camera: Camera, geometry: BufferGeometry<NormalBufferAttributes>, material: Material, group: Group) => void;
				applyMatrix4: (matrix: Matrix4) => void;
				applyQuaternion: (quaternion: Quaternion) => Object3D<Event>;
				setRotationFromAxisAngle: (axis: Vector3, angle: number) => void;
				setRotationFromEuler: (euler: Euler) => void;
				setRotationFromMatrix: (m: Matrix4) => void;
				setRotationFromQuaternion: (q: Quaternion) => void;
				rotateOnAxis: (axis: Vector3, angle: number) => Object3D<Event>;
				rotateOnWorldAxis: (axis: Vector3, angle: number) => Object3D<Event>;
				rotateX: (angle: number) => Object3D<Event>;
				rotateY: (angle: number) => Object3D<Event>;
				rotateZ: (angle: number) => Object3D<Event>;
				translateOnAxis: (axis: Vector3, distance: number) => Object3D<Event>;
				translateX: (distance: number) => Object3D<Event>;
				translateY: (distance: number) => Object3D<Event>;
				translateZ: (distance: number) => Object3D<Event>;
				localToWorld: (vector: Vector3) => Vector3;
				worldToLocal: (vector: Vector3) => Vector3;
				lookAt: {
					(vector: Vector3): void;
					(x: number, y: number, z: number): void;
				};
				add: (...object: Object3D<Event>[]) => Object3D<Event>;
				remove: (...object: Object3D<Event>[]) => Object3D<Event>;
				removeFromParent: () => Object3D<Event>;
				clear: () => Object3D<Event>;
				attach: (object: Object3D<Event>) => Object3D<Event>;
				getObjectById: (id: number) => Object3D<Event> | undefined;
				getObjectByName: (name: string) => Object3D<Event> | undefined;
				getObjectByProperty: (name: string, value: any) => Object3D<Event> | undefined;
				getObjectsByProperty: (name: string, value: any) => Object3D<Event>[];
				getWorldPosition: (target: Vector3) => Vector3;
				getWorldQuaternion: (target: Quaternion) => Quaternion;
				getWorldScale: (target: Vector3) => Vector3;
				getWorldDirection: (target: Vector3) => Vector3;
				raycast: (raycaster: Raycaster, intersects: Intersection<Object3D<Event>>[]) => void;
				traverse: (callback: (object: Object3D<Event>) => any) => void;
				traverseVisible: (callback: (object: Object3D<Event>) => any) => void;
				traverseAncestors: (callback: (object: Object3D<Event>) => any) => void;
				updateMatrix: () => void;
				updateMatrixWorld: (force?: boolean | undefined) => void;
				updateWorldMatrix: (updateParents: boolean, updateChildren: boolean) => void;
				toJSON: (meta?: {
					geometries: any;
					materials: any;
					textures: any;
					images: any;
				} | undefined) => any;
				clone: (recursive?: boolean | undefined) => Object3D<Event>;
				copy: (source: Object3D<Event>, recursive?: boolean | undefined) => Object3D<Event>;
				addEventListener: <T_3 extends string>(type: T_3, listener: EventListener<Event, T_3, Object3D<Event>>) => void;
				hasEventListener: <T_4 extends string>(type: T_4, listener: EventListener<Event, T_4, Object3D<Event>>) => boolean;
				removeEventListener: <T_5 extends string>(type: T_5, listener: EventListener<Event, T_5, Object3D<Event>>) => void;
				dispatchEvent: (event: Event) => void;
			}[];
			up: {
				x: number;
				y: number;
				z: number;
				readonly isVector3: true;
				set: (x: number, y: number, z: number) => Vector3;
				setScalar: (scalar: number) => Vector3;
				setX: (x: number) => Vector3;
				setY: (y: number) => Vector3;
				setZ: (z: number) => Vector3;
				setComponent: (index: number, value: number) => Vector3;
				setFromColor: (color: Color) => Vector3;
				getComponent: (index: number) => number;
				clone: () => Vector3;
				copy: (v: Vector3) => Vector3;
				add: (v: Vector3) => Vector3;
				addScalar: (s: number) => Vector3;
				addScaledVector: (v: Vector3, s: number) => Vector3;
				addVectors: (a: Vector3, b: Vector3) => Vector3;
				sub: (a: Vector3) => Vector3;
				subScalar: (s: number) => Vector3;
				subVectors: (a: Vector3, b: Vector3) => Vector3;
				multiply: (v: Vector3) => Vector3;
				multiplyScalar: (s: number) => Vector3;
				multiplyVectors: (a: Vector3, b: Vector3) => Vector3;
				applyEuler: (euler: Euler) => Vector3;
				applyAxisAngle: (axis: Vector3, angle: number) => Vector3;
				applyMatrix3: (m: Matrix3) => Vector3;
				applyNormalMatrix: (m: Matrix3) => Vector3;
				applyMatrix4: (m: Matrix4) => Vector3;
				applyQuaternion: (q: Quaternion) => Vector3;
				project: (camera: Camera) => Vector3;
				unproject: (camera: Camera) => Vector3;
				transformDirection: (m: Matrix4) => Vector3;
				divide: (v: Vector3) => Vector3;
				divideScalar: (s: number) => Vector3;
				min: (v: Vector3) => Vector3;
				max: (v: Vector3) => Vector3;
				clamp: (min: Vector3, max: Vector3) => Vector3;
				clampScalar: (min: number, max: number) => Vector3;
				clampLength: (min: number, max: number) => Vector3;
				floor: () => Vector3;
				ceil: () => Vector3;
				round: () => Vector3;
				roundToZero: () => Vector3;
				negate: () => Vector3;
				dot: (v: Vector3) => number;
				lengthSq: () => number;
				length: () => number;
				lengthManhattan: () => number;
				manhattanLength: () => number;
				manhattanDistanceTo: (v: Vector3) => number;
				normalize: () => Vector3;
				setLength: (l: number) => Vector3;
				lerp: (v: Vector3, alpha: number) => Vector3;
				lerpVectors: (v1: Vector3, v2: Vector3, alpha: number) => Vector3;
				cross: (a: Vector3) => Vector3;
				crossVectors: (a: Vector3, b: Vector3) => Vector3;
				projectOnVector: (v: Vector3) => Vector3;
				projectOnPlane: (planeNormal: Vector3) => Vector3;
				reflect: (vector: Vector3) => Vector3;
				angleTo: (v: Vector3) => number;
				distanceTo: (v: Vector3) => number;
				distanceToSquared: (v: Vector3) => number;
				distanceToManhattan: (v: Vector3) => number;
				setFromSpherical: (s: Spherical) => Vector3;
				setFromSphericalCoords: (r: number, phi: number, theta: number) => Vector3;
				setFromCylindrical: (s: Cylindrical) => Vector3;
				setFromCylindricalCoords: (radius: number, theta: number, y: number) => Vector3;
				setFromMatrixPosition: (m: Matrix4) => Vector3;
				setFromMatrixScale: (m: Matrix4) => Vector3;
				setFromMatrixColumn: (matrix: Matrix4, index: number) => Vector3;
				setFromMatrix3Column: (matrix: Matrix3, index: number) => Vector3;
				setFromEuler: (e: Euler) => Vector3;
				equals: (v: Vector3) => boolean;
				fromArray: (array: number[] | ArrayLike<number>, offset?: number | undefined) => Vector3;
				toArray: {
					(array?: number[] | undefined, offset?: number | undefined): number[];
					(array?: Vector3Tuple | undefined, offset?: 0 | undefined): Vector3Tuple;
					(array: ArrayLike<number>, offset?: number | undefined): ArrayLike<number>;
				};
				fromBufferAttribute: (attribute: BufferAttribute | InterleavedBufferAttribute, index: number) => Vector3;
				random: () => Vector3;
				randomDirection: () => Vector3;
			};
			readonly position: {
				x: number;
				y: number;
				z: number;
				readonly isVector3: true;
				set: (x: number, y: number, z: number) => Vector3;
				setScalar: (scalar: number) => Vector3;
				setX: (x: number) => Vector3;
				setY: (y: number) => Vector3;
				setZ: (z: number) => Vector3;
				setComponent: (index: number, value: number) => Vector3;
				setFromColor: (color: Color) => Vector3;
				getComponent: (index: number) => number;
				clone: () => Vector3;
				copy: (v: Vector3) => Vector3;
				add: (v: Vector3) => Vector3;
				addScalar: (s: number) => Vector3;
				addScaledVector: (v: Vector3, s: number) => Vector3;
				addVectors: (a: Vector3, b: Vector3) => Vector3;
				sub: (a: Vector3) => Vector3;
				subScalar: (s: number) => Vector3;
				subVectors: (a: Vector3, b: Vector3) => Vector3;
				multiply: (v: Vector3) => Vector3;
				multiplyScalar: (s: number) => Vector3;
				multiplyVectors: (a: Vector3, b: Vector3) => Vector3;
				applyEuler: (euler: Euler) => Vector3;
				applyAxisAngle: (axis: Vector3, angle: number) => Vector3;
				applyMatrix3: (m: Matrix3) => Vector3;
				applyNormalMatrix: (m: Matrix3) => Vector3;
				applyMatrix4: (m: Matrix4) => Vector3;
				applyQuaternion: (q: Quaternion) => Vector3;
				project: (camera: Camera) => Vector3;
				unproject: (camera: Camera) => Vector3;
				transformDirection: (m: Matrix4) => Vector3;
				divide: (v: Vector3) => Vector3;
				divideScalar: (s: number) => Vector3;
				min: (v: Vector3) => Vector3;
				max: (v: Vector3) => Vector3;
				clamp: (min: Vector3, max: Vector3) => Vector3;
				clampScalar: (min: number, max: number) => Vector3;
				clampLength: (min: number, max: number) => Vector3;
				floor: () => Vector3;
				ceil: () => Vector3;
				round: () => Vector3;
				roundToZero: () => Vector3;
				negate: () => Vector3;
				dot: (v: Vector3) => number;
				lengthSq: () => number;
				length: () => number;
				lengthManhattan: () => number;
				manhattanLength: () => number;
				manhattanDistanceTo: (v: Vector3) => number;
				normalize: () => Vector3;
				setLength: (l: number) => Vector3;
				lerp: (v: Vector3, alpha: number) => Vector3;
				lerpVectors: (v1: Vector3, v2: Vector3, alpha: number) => Vector3;
				cross: (a: Vector3) => Vector3;
				crossVectors: (a: Vector3, b: Vector3) => Vector3;
				projectOnVector: (v: Vector3) => Vector3;
				projectOnPlane: (planeNormal: Vector3) => Vector3;
				reflect: (vector: Vector3) => Vector3;
				angleTo: (v: Vector3) => number;
				distanceTo: (v: Vector3) => number;
				distanceToSquared: (v: Vector3) => number;
				distanceToManhattan: (v: Vector3) => number;
				setFromSpherical: (s: Spherical) => Vector3;
				setFromSphericalCoords: (r: number, phi: number, theta: number) => Vector3;
				setFromCylindrical: (s: Cylindrical) => Vector3;
				setFromCylindricalCoords: (radius: number, theta: number, y: number) => Vector3;
				setFromMatrixPosition: (m: Matrix4) => Vector3;
				setFromMatrixScale: (m: Matrix4) => Vector3;
				setFromMatrixColumn: (matrix: Matrix4, index: number) => Vector3;
				setFromMatrix3Column: (matrix: Matrix3, index: number) => Vector3;
				setFromEuler: (e: Euler) => Vector3;
				equals: (v: Vector3) => boolean;
				fromArray: (array: number[] | ArrayLike<number>, offset?: number | undefined) => Vector3;
				toArray: {
					(array?: number[] | undefined, offset?: number | undefined): number[];
					(array?: Vector3Tuple | undefined, offset?: 0 | undefined): Vector3Tuple;
					(array: ArrayLike<number>, offset?: number | undefined): ArrayLike<number>;
				};
				fromBufferAttribute: (attribute: BufferAttribute | InterleavedBufferAttribute, index: number) => Vector3;
				random: () => Vector3;
				randomDirection: () => Vector3;
			};
			readonly rotation: {
				x: number;
				y: number;
				z: number;
				order: EulerOrder;
				readonly isEuler: true;
				_onChangeCallback: () => void;
				set: (x: number, y: number, z: number, order?: EulerOrder | undefined) => Euler;
				clone: () => Euler;
				copy: (euler: Euler) => Euler;
				setFromRotationMatrix: (m: Matrix4, order?: EulerOrder | undefined, update?: boolean | undefined) => Euler;
				setFromQuaternion: (q: Quaternion, order?: EulerOrder | undefined, update?: boolean | undefined) => Euler;
				setFromVector3: (v: Vector3, order?: EulerOrder | undefined) => Euler;
				reorder: (newOrder: EulerOrder) => Euler;
				equals: (euler: Euler) => boolean;
				fromArray: (xyzo: [
					number,
					number,
					number,
					(EulerOrder | undefined)?,
					...any[]
				]) => Euler;
				toArray: (array?: (string | number | undefined)[] | undefined, offset?: number | undefined) => (string | number | undefined)[];
				_onChange: (callback: () => void) => Euler;
				[Symbol.iterator]: () => Generator<string | number, void, unknown>;
			};
			readonly quaternion: {
				x: number;
				y: number;
				z: number;
				w: number;
				readonly isQuaternion: true;
				set: (x: number, y: number, z: number, w: number) => Quaternion;
				clone: () => Quaternion;
				copy: (q: Quaternion) => Quaternion;
				setFromEuler: (euler: Euler, update?: boolean | undefined) => Quaternion;
				setFromAxisAngle: (axis: Vector3, angle: number) => Quaternion;
				setFromRotationMatrix: (m: Matrix4) => Quaternion;
				setFromUnitVectors: (vFrom: Vector3, vTo: Vector3) => Quaternion;
				angleTo: (q: Quaternion) => number;
				rotateTowards: (q: Quaternion, step: number) => Quaternion;
				identity: () => Quaternion;
				invert: () => Quaternion;
				conjugate: () => Quaternion;
				dot: (v: Quaternion) => number;
				lengthSq: () => number;
				length: () => number;
				normalize: () => Quaternion;
				multiply: (q: Quaternion) => Quaternion;
				premultiply: (q: Quaternion) => Quaternion;
				multiplyQuaternions: (a: Quaternion, b: Quaternion) => Quaternion;
				slerp: (qb: Quaternion, t: number) => Quaternion;
				slerpQuaternions: (qa: Quaternion, qb: Quaternion, t: number) => Quaternion;
				equals: (v: Quaternion) => boolean;
				fromArray: (array: number[] | ArrayLike<number>, offset?: number | undefined) => Quaternion;
				toArray: {
					(array?: number[] | undefined, offset?: number | undefined): number[];
					(array: ArrayLike<number>, offset?: number | undefined): ArrayLike<number>;
				};
				toJSON: () => [
					number,
					number,
					number,
					number
				];
				fromBufferAttribute: (attribute: BufferAttribute | InterleavedBufferAttribute, index: number) => Quaternion;
				_onChange: (callback: () => void) => Quaternion;
				_onChangeCallback: () => void;
				multiplyVector3: (v: any) => any;
				random: () => Quaternion;
				[Symbol.iterator]: () => Generator<number, void, unknown>;
			};
			readonly scale: {
				x: number;
				y: number;
				z: number;
				readonly isVector3: true;
				set: (x: number, y: number, z: number) => Vector3;
				setScalar: (scalar: number) => Vector3;
				setX: (x: number) => Vector3;
				setY: (y: number) => Vector3;
				setZ: (z: number) => Vector3;
				setComponent: (index: number, value: number) => Vector3;
				setFromColor: (color: Color) => Vector3;
				getComponent: (index: number) => number;
				clone: () => Vector3;
				copy: (v: Vector3) => Vector3;
				add: (v: Vector3) => Vector3;
				addScalar: (s: number) => Vector3;
				addScaledVector: (v: Vector3, s: number) => Vector3;
				addVectors: (a: Vector3, b: Vector3) => Vector3;
				sub: (a: Vector3) => Vector3;
				subScalar: (s: number) => Vector3;
				subVectors: (a: Vector3, b: Vector3) => Vector3;
				multiply: (v: Vector3) => Vector3;
				multiplyScalar: (s: number) => Vector3;
				multiplyVectors: (a: Vector3, b: Vector3) => Vector3;
				applyEuler: (euler: Euler) => Vector3;
				applyAxisAngle: (axis: Vector3, angle: number) => Vector3;
				applyMatrix3: (m: Matrix3) => Vector3;
				applyNormalMatrix: (m: Matrix3) => Vector3;
				applyMatrix4: (m: Matrix4) => Vector3;
				applyQuaternion: (q: Quaternion) => Vector3;
				project: (camera: Camera) => Vector3;
				unproject: (camera: Camera) => Vector3;
				transformDirection: (m: Matrix4) => Vector3;
				divide: (v: Vector3) => Vector3;
				divideScalar: (s: number) => Vector3;
				min: (v: Vector3) => Vector3;
				max: (v: Vector3) => Vector3;
				clamp: (min: Vector3, max: Vector3) => Vector3;
				clampScalar: (min: number, max: number) => Vector3;
				clampLength: (min: number, max: number) => Vector3;
				floor: () => Vector3;
				ceil: () => Vector3;
				round: () => Vector3;
				roundToZero: () => Vector3;
				negate: () => Vector3;
				dot: (v: Vector3) => number;
				lengthSq: () => number;
				length: () => number;
				lengthManhattan: () => number;
				manhattanLength: () => number;
				manhattanDistanceTo: (v: Vector3) => number;
				normalize: () => Vector3;
				setLength: (l: number) => Vector3;
				lerp: (v: Vector3, alpha: number) => Vector3;
				lerpVectors: (v1: Vector3, v2: Vector3, alpha: number) => Vector3;
				cross: (a: Vector3) => Vector3;
				crossVectors: (a: Vector3, b: Vector3) => Vector3;
				projectOnVector: (v: Vector3) => Vector3;
				projectOnPlane: (planeNormal: Vector3) => Vector3;
				reflect: (vector: Vector3) => Vector3;
				angleTo: (v: Vector3) => number;
				distanceTo: (v: Vector3) => number;
				distanceToSquared: (v: Vector3) => number;
				distanceToManhattan: (v: Vector3) => number;
				setFromSpherical: (s: Spherical) => Vector3;
				setFromSphericalCoords: (r: number, phi: number, theta: number) => Vector3;
				setFromCylindrical: (s: Cylindrical) => Vector3;
				setFromCylindricalCoords: (radius: number, theta: number, y: number) => Vector3;
				setFromMatrixPosition: (m: Matrix4) => Vector3;
				setFromMatrixScale: (m: Matrix4) => Vector3;
				setFromMatrixColumn: (matrix: Matrix4, index: number) => Vector3;
				setFromMatrix3Column: (matrix: Matrix3, index: number) => Vector3;
				setFromEuler: (e: Euler) => Vector3;
				equals: (v: Vector3) => boolean;
				fromArray: (array: number[] | ArrayLike<number>, offset?: number | undefined) => Vector3;
				toArray: {
					(array?: number[] | undefined, offset?: number | undefined): number[];
					(array?: Vector3Tuple | undefined, offset?: 0 | undefined): Vector3Tuple;
					(array: ArrayLike<number>, offset?: number | undefined): ArrayLike<number>;
				};
				fromBufferAttribute: (attribute: BufferAttribute | InterleavedBufferAttribute, index: number) => Vector3;
				random: () => Vector3;
				randomDirection: () => Vector3;
			};
			readonly modelViewMatrix: {
				elements: number[];
				set: (n11: number, n12: number, n13: number, n14: number, n21: number, n22: number, n23: number, n24: number, n31: number, n32: number, n33: number, n34: number, n41: number, n42: number, n43: number, n44: number) => Matrix4;
				identity: () => Matrix4;
				clone: () => Matrix4;
				copy: (m: Matrix4) => Matrix4;
				copyPosition: (m: Matrix4) => Matrix4;
				extractBasis: (xAxis: Vector3, yAxis: Vector3, zAxis: Vector3) => Matrix4;
				makeBasis: (xAxis: Vector3, yAxis: Vector3, zAxis: Vector3) => Matrix4;
				extractRotation: (m: Matrix4) => Matrix4;
				makeRotationFromEuler: (euler: Euler) => Matrix4;
				makeRotationFromQuaternion: (q: Quaternion) => Matrix4;
				lookAt: (eye: Vector3, target: Vector3, up: Vector3) => Matrix4;
				multiply: (m: Matrix4) => Matrix4;
				premultiply: (m: Matrix4) => Matrix4;
				multiplyMatrices: (a: Matrix4, b: Matrix4) => Matrix4;
				multiplyToArray: (a: Matrix4, b: Matrix4, r: number[]) => Matrix4;
				multiplyScalar: (s: number) => Matrix4;
				determinant: () => number;
				transpose: () => Matrix4;
				setPosition: (v: number | Vector3, y?: number | undefined, z?: number | undefined) => Matrix4;
				invert: () => Matrix4;
				scale: (v: Vector3) => Matrix4;
				getMaxScaleOnAxis: () => number;
				makeTranslation: (x: number, y: number, z: number) => Matrix4;
				makeRotationX: (theta: number) => Matrix4;
				makeRotationY: (theta: number) => Matrix4;
				makeRotationZ: (theta: number) => Matrix4;
				makeRotationAxis: (axis: Vector3, angle: number) => Matrix4;
				makeScale: (x: number, y: number, z: number) => Matrix4;
				makeShear: (xy: number, xz: number, yx: number, yz: number, zx: number, zy: number) => Matrix4;
				compose: (translation: Vector3, rotation: Quaternion, scale: Vector3) => Matrix4;
				decompose: (translation: Vector3, rotation: Quaternion, scale: Vector3) => Matrix4;
				makePerspective: {
					(left: number, right: number, bottom: number, top: number, near: number, far: number): Matrix4;
					(fov: number, aspect: number, near: number, far: number): Matrix4;
				};
				makeOrthographic: (left: number, right: number, top: number, bottom: number, near: number, far: number) => Matrix4;
				equals: (matrix: Matrix4) => boolean;
				fromArray: (array: number[] | ArrayLike<number>, offset?: number | undefined) => Matrix4;
				toArray: {
					(array?: number[] | undefined, offset?: number | undefined): number[];
					(array?: Matrix4Tuple | undefined, offset?: 0 | undefined): Matrix4Tuple;
					(array?: ArrayLike<number> | undefined, offset?: number | undefined): ArrayLike<number>;
				};
				setFromMatrix3: (m: Matrix3) => Matrix4;
				extractPosition: (m: Matrix4) => Matrix4;
				setRotationFromQuaternion: (q: Quaternion) => Matrix4;
				multiplyVector3: (v: any) => any;
				multiplyVector4: (v: any) => any;
				multiplyVector3Array: (array: number[]) => number[];
				rotateAxis: (v: any) => void;
				crossVector: (v: any) => void;
				flattenToArrayOffset: (array: number[], offset: number) => number[];
				getInverse: (matrix: Matrix) => Matrix;
			};
			readonly normalMatrix: {
				elements: number[];
				set: (n11: number, n12: number, n13: number, n21: number, n22: number, n23: number, n31: number, n32: number, n33: number) => Matrix3;
				identity: () => Matrix3;
				clone: () => Matrix3;
				copy: (m: Matrix3) => Matrix3;
				extractBasis: (xAxis: Vector3, yAxis: Vector3, zAxis: Vector3) => Matrix3;
				setFromMatrix4: (m: Matrix4) => Matrix3;
				multiplyScalar: (s: number) => Matrix3;
				determinant: () => number;
				invert: () => Matrix3;
				transpose: () => Matrix3;
				getNormalMatrix: (matrix4: Matrix4) => Matrix3;
				transposeIntoArray: (r: number[]) => Matrix3;
				setUvTransform: (tx: number, ty: number, sx: number, sy: number, rotation: number, cx: number, cy: number) => Matrix3;
				scale: (sx: number, sy: number) => Matrix3;
				makeTranslation: {
					(x: number, y: number): Matrix3;
					(x: number, y: number): Matrix3;
				};
				makeRotation: {
					(theta: number): Matrix3;
					(theta: number): Matrix3;
				};
				makeScale: {
					(x: number, y: number): Matrix3;
					(x: number, y: number): Matrix3;
				};
				rotate: (theta: number) => Matrix3;
				translate: (tx: number, ty: number) => Matrix3;
				equals: (matrix: Matrix3) => boolean;
				fromArray: (array: number[] | ArrayLike<number>, offset?: number | undefined) => Matrix3;
				toArray: {
					(array?: number[] | undefined, offset?: number | undefined): number[];
					(array?: Matrix3Tuple | undefined, offset?: 0 | undefined): Matrix3Tuple;
					(array?: ArrayLike<number> | undefined, offset?: number | undefined): ArrayLike<number>;
				};
				multiply: (m: Matrix3) => Matrix3;
				premultiply: (m: Matrix3) => Matrix3;
				multiplyMatrices: (a: Matrix3, b: Matrix3) => Matrix3;
				multiplyVector3: (vector: Vector3) => any;
				multiplyVector3Array: (a: any) => any;
				getInverse: {
					(matrix: Matrix4, throwOnDegenerate?: boolean | undefined): Matrix3;
					(matrix: Matrix): Matrix;
				};
				flattenToArrayOffset: (array: number[], offset: number) => number[];
			};
			matrix: {
				elements: number[];
				set: (n11: number, n12: number, n13: number, n14: number, n21: number, n22: number, n23: number, n24: number, n31: number, n32: number, n33: number, n34: number, n41: number, n42: number, n43: number, n44: number) => Matrix4;
				identity: () => Matrix4;
				clone: () => Matrix4;
				copy: (m: Matrix4) => Matrix4;
				copyPosition: (m: Matrix4) => Matrix4;
				extractBasis: (xAxis: Vector3, yAxis: Vector3, zAxis: Vector3) => Matrix4;
				makeBasis: (xAxis: Vector3, yAxis: Vector3, zAxis: Vector3) => Matrix4;
				extractRotation: (m: Matrix4) => Matrix4;
				makeRotationFromEuler: (euler: Euler) => Matrix4;
				makeRotationFromQuaternion: (q: Quaternion) => Matrix4;
				lookAt: (eye: Vector3, target: Vector3, up: Vector3) => Matrix4;
				multiply: (m: Matrix4) => Matrix4;
				premultiply: (m: Matrix4) => Matrix4;
				multiplyMatrices: (a: Matrix4, b: Matrix4) => Matrix4;
				multiplyToArray: (a: Matrix4, b: Matrix4, r: number[]) => Matrix4;
				multiplyScalar: (s: number) => Matrix4;
				determinant: () => number;
				transpose: () => Matrix4;
				setPosition: (v: number | Vector3, y?: number | undefined, z?: number | undefined) => Matrix4;
				invert: () => Matrix4;
				scale: (v: Vector3) => Matrix4;
				getMaxScaleOnAxis: () => number;
				makeTranslation: (x: number, y: number, z: number) => Matrix4;
				makeRotationX: (theta: number) => Matrix4;
				makeRotationY: (theta: number) => Matrix4;
				makeRotationZ: (theta: number) => Matrix4;
				makeRotationAxis: (axis: Vector3, angle: number) => Matrix4;
				makeScale: (x: number, y: number, z: number) => Matrix4;
				makeShear: (xy: number, xz: number, yx: number, yz: number, zx: number, zy: number) => Matrix4;
				compose: (translation: Vector3, rotation: Quaternion, scale: Vector3) => Matrix4;
				decompose: (translation: Vector3, rotation: Quaternion, scale: Vector3) => Matrix4;
				makePerspective: {
					(left: number, right: number, bottom: number, top: number, near: number, far: number): Matrix4;
					(fov: number, aspect: number, near: number, far: number): Matrix4;
				};
				makeOrthographic: (left: number, right: number, top: number, bottom: number, near: number, far: number) => Matrix4;
				equals: (matrix: Matrix4) => boolean;
				fromArray: (array: number[] | ArrayLike<number>, offset?: number | undefined) => Matrix4;
				toArray: {
					(array?: number[] | undefined, offset?: number | undefined): number[];
					(array?: Matrix4Tuple | undefined, offset?: 0 | undefined): Matrix4Tuple;
					(array?: ArrayLike<number> | undefined, offset?: number | undefined): ArrayLike<number>;
				};
				setFromMatrix3: (m: Matrix3) => Matrix4;
				extractPosition: (m: Matrix4) => Matrix4;
				setRotationFromQuaternion: (q: Quaternion) => Matrix4;
				multiplyVector3: (v: any) => any;
				multiplyVector4: (v: any) => any;
				multiplyVector3Array: (array: number[]) => number[];
				rotateAxis: (v: any) => void;
				crossVector: (v: any) => void;
				flattenToArrayOffset: (array: number[], offset: number) => number[];
				getInverse: (matrix: Matrix) => Matrix;
			};
			matrixWorld: {
				elements: number[];
				set: (n11: number, n12: number, n13: number, n14: number, n21: number, n22: number, n23: number, n24: number, n31: number, n32: number, n33: number, n34: number, n41: number, n42: number, n43: number, n44: number) => Matrix4;
				identity: () => Matrix4;
				clone: () => Matrix4;
				copy: (m: Matrix4) => Matrix4;
				copyPosition: (m: Matrix4) => Matrix4;
				extractBasis: (xAxis: Vector3, yAxis: Vector3, zAxis: Vector3) => Matrix4;
				makeBasis: (xAxis: Vector3, yAxis: Vector3, zAxis: Vector3) => Matrix4;
				extractRotation: (m: Matrix4) => Matrix4;
				makeRotationFromEuler: (euler: Euler) => Matrix4;
				makeRotationFromQuaternion: (q: Quaternion) => Matrix4;
				lookAt: (eye: Vector3, target: Vector3, up: Vector3) => Matrix4;
				multiply: (m: Matrix4) => Matrix4;
				premultiply: (m: Matrix4) => Matrix4;
				multiplyMatrices: (a: Matrix4, b: Matrix4) => Matrix4;
				multiplyToArray: (a: Matrix4, b: Matrix4, r: number[]) => Matrix4;
				multiplyScalar: (s: number) => Matrix4;
				determinant: () => number;
				transpose: () => Matrix4;
				setPosition: (v: number | Vector3, y?: number | undefined, z?: number | undefined) => Matrix4;
				invert: () => Matrix4;
				scale: (v: Vector3) => Matrix4;
				getMaxScaleOnAxis: () => number;
				makeTranslation: (x: number, y: number, z: number) => Matrix4;
				makeRotationX: (theta: number) => Matrix4;
				makeRotationY: (theta: number) => Matrix4;
				makeRotationZ: (theta: number) => Matrix4;
				makeRotationAxis: (axis: Vector3, angle: number) => Matrix4;
				makeScale: (x: number, y: number, z: number) => Matrix4;
				makeShear: (xy: number, xz: number, yx: number, yz: number, zx: number, zy: number) => Matrix4;
				compose: (translation: Vector3, rotation: Quaternion, scale: Vector3) => Matrix4;
				decompose: (translation: Vector3, rotation: Quaternion, scale: Vector3) => Matrix4;
				makePerspective: {
					(left: number, right: number, bottom: number, top: number, near: number, far: number): Matrix4;
					(fov: number, aspect: number, near: number, far: number): Matrix4;
				};
				makeOrthographic: (left: number, right: number, top: number, bottom: number, near: number, far: number) => Matrix4;
				equals: (matrix: Matrix4) => boolean;
				fromArray: (array: number[] | ArrayLike<number>, offset?: number | undefined) => Matrix4;
				toArray: {
					(array?: number[] | undefined, offset?: number | undefined): number[];
					(array?: Matrix4Tuple | undefined, offset?: 0 | undefined): Matrix4Tuple;
					(array?: ArrayLike<number> | undefined, offset?: number | undefined): ArrayLike<number>;
				};
				setFromMatrix3: (m: Matrix3) => Matrix4;
				extractPosition: (m: Matrix4) => Matrix4;
				setRotationFromQuaternion: (q: Quaternion) => Matrix4;
				multiplyVector3: (v: any) => any;
				multiplyVector4: (v: any) => any;
				multiplyVector3Array: (array: number[]) => number[];
				rotateAxis: (v: any) => void;
				crossVector: (v: any) => void;
				flattenToArrayOffset: (array: number[], offset: number) => number[];
				getInverse: (matrix: Matrix) => Matrix;
			};
			matrixAutoUpdate: boolean;
			matrixWorldAutoUpdate: boolean;
			matrixWorldNeedsUpdate: boolean;
			visible: boolean;
			castShadow: boolean;
			receiveShadow: boolean;
			frustumCulled: boolean;
			renderOrder: number;
			animations: {
				name: string;
				tracks: {
					name: string;
					times: {
						[x: number]: number;
						readonly BYTES_PER_ELEMENT: number;
						readonly buffer: {
							readonly byteLength: number;
							slice: (begin: number, end?: number | undefined) => ArrayBuffer;
							readonly [Symbol.toStringTag]: string;
						} | {
							readonly byteLength: number;
							slice: (begin: number, end?: number | undefined) => SharedArrayBuffer;
							readonly [Symbol.species]: SharedArrayBuffer;
							readonly [Symbol.toStringTag]: "SharedArrayBuffer";
						};
						readonly byteLength: number;
						readonly byteOffset: number;
						copyWithin: (target: number, start: number, end?: number | undefined) => Float32Array;
						every: (predicate: (value: number, index: number, array: Float32Array) => unknown, thisArg?: any) => boolean;
						fill: (value: number, start?: number | undefined, end?: number | undefined) => Float32Array;
						filter: (predicate: (value: number, index: number, array: Float32Array) => any, thisArg?: any) => Float32Array;
						find: (predicate: (value: number, index: number, obj: Float32Array) => boolean, thisArg?: any) => number | undefined;
						findIndex: (predicate: (value: number, index: number, obj: Float32Array) => boolean, thisArg?: any) => number;
						forEach: (callbackfn: (value: number, index: number, array: Float32Array) => void, thisArg?: any) => void;
						indexOf: (searchElement: number, fromIndex?: number | undefined) => number;
						join: (separator?: string | undefined) => string;
						lastIndexOf: (searchElement: number, fromIndex?: number | undefined) => number;
						readonly length: number;
						map: (callbackfn: (value: number, index: number, array: Float32Array) => number, thisArg?: any) => Float32Array;
						reduce: {
							(callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number): number;
							(callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number, initialValue: number): number;
							<U>(callbackfn: (previousValue: U, currentValue: number, currentIndex: number, array: Float32Array) => U, initialValue: U): U;
						};
						reduceRight: {
							(callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number): number;
							(callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number, initialValue: number): number;
							<U_1>(callbackfn: (previousValue: U_1, currentValue: number, currentIndex: number, array: Float32Array) => U_1, initialValue: U_1): U_1;
						};
						reverse: () => Float32Array;
						set: (array: ArrayLike<number>, offset?: number | undefined) => void;
						slice: (start?: number | undefined, end?: number | undefined) => Float32Array;
						some: (predicate: (value: number, index: number, array: Float32Array) => unknown, thisArg?: any) => boolean;
						sort: (compareFn?: ((a: number, b: number) => number) | undefined) => Float32Array;
						subarray: (begin?: number | undefined, end?: number | undefined) => Float32Array;
						toLocaleString: () => string;
						toString: () => string;
						valueOf: () => Float32Array;
						entries: () => IterableIterator<[
							number,
							number
						]>;
						keys: () => IterableIterator<number>;
						values: () => IterableIterator<number>;
						includes: (searchElement: number, fromIndex?: number | undefined) => boolean;
						[Symbol.iterator]: () => IterableIterator<number>;
						readonly [Symbol.toStringTag]: "Float32Array";
						at: (index: number) => number | undefined;
					};
					values: {
						[x: number]: number;
						readonly BYTES_PER_ELEMENT: number;
						readonly buffer: {
							readonly byteLength: number;
							slice: (begin: number, end?: number | undefined) => ArrayBuffer;
							readonly [Symbol.toStringTag]: string;
						} | {
							readonly byteLength: number;
							slice: (begin: number, end?: number | undefined) => SharedArrayBuffer;
							readonly [Symbol.species]: SharedArrayBuffer;
							readonly [Symbol.toStringTag]: "SharedArrayBuffer";
						};
						readonly byteLength: number;
						readonly byteOffset: number;
						copyWithin: (target: number, start: number, end?: number | undefined) => Float32Array;
						every: (predicate: (value: number, index: number, array: Float32Array) => unknown, thisArg?: any) => boolean;
						fill: (value: number, start?: number | undefined, end?: number | undefined) => Float32Array;
						filter: (predicate: (value: number, index: number, array: Float32Array) => any, thisArg?: any) => Float32Array;
						find: (predicate: (value: number, index: number, obj: Float32Array) => boolean, thisArg?: any) => number | undefined;
						findIndex: (predicate: (value: number, index: number, obj: Float32Array) => boolean, thisArg?: any) => number;
						forEach: (callbackfn: (value: number, index: number, array: Float32Array) => void, thisArg?: any) => void;
						indexOf: (searchElement: number, fromIndex?: number | undefined) => number;
						join: (separator?: string | undefined) => string;
						lastIndexOf: (searchElement: number, fromIndex?: number | undefined) => number;
						readonly length: number;
						map: (callbackfn: (value: number, index: number, array: Float32Array) => number, thisArg?: any) => Float32Array;
						reduce: {
							(callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number): number;
							(callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number, initialValue: number): number;
							<U>(callbackfn: (previousValue: U, currentValue: number, currentIndex: number, array: Float32Array) => U, initialValue: U): U;
						};
						reduceRight: {
							(callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number): number;
							(callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number, initialValue: number): number;
							<U_1>(callbackfn: (previousValue: U_1, currentValue: number, currentIndex: number, array: Float32Array) => U_1, initialValue: U_1): U_1;
						};
						reverse: () => Float32Array;
						set: (array: ArrayLike<number>, offset?: number | undefined) => void;
						slice: (start?: number | undefined, end?: number | undefined) => Float32Array;
						some: (predicate: (value: number, index: number, array: Float32Array) => unknown, thisArg?: any) => boolean;
						sort: (compareFn?: ((a: number, b: number) => number) | undefined) => Float32Array;
						subarray: (begin?: number | undefined, end?: number | undefined) => Float32Array;
						toLocaleString: () => string;
						toString: () => string;
						valueOf: () => Float32Array;
						entries: () => IterableIterator<[
							number,
							number
						]>;
						keys: () => IterableIterator<number>;
						values: () => IterableIterator<number>;
						includes: (searchElement: number, fromIndex?: number | undefined) => boolean;
						[Symbol.iterator]: () => IterableIterator<number>;
						readonly [Symbol.toStringTag]: "Float32Array";
						at: (index: number) => number | undefined;
					};
					ValueTypeName: string;
					TimeBufferType: {
						[x: number]: number;
						readonly BYTES_PER_ELEMENT: number;
						readonly buffer: {
							readonly byteLength: number;
							slice: (begin: number, end?: number | undefined) => ArrayBuffer;
							readonly [Symbol.toStringTag]: string;
						} | {
							readonly byteLength: number;
							slice: (begin: number, end?: number | undefined) => SharedArrayBuffer;
							readonly [Symbol.species]: SharedArrayBuffer;
							readonly [Symbol.toStringTag]: "SharedArrayBuffer";
						};
						readonly byteLength: number;
						readonly byteOffset: number;
						copyWithin: (target: number, start: number, end?: number | undefined) => Float32Array;
						every: (predicate: (value: number, index: number, array: Float32Array) => unknown, thisArg?: any) => boolean;
						fill: (value: number, start?: number | undefined, end?: number | undefined) => Float32Array;
						filter: (predicate: (value: number, index: number, array: Float32Array) => any, thisArg?: any) => Float32Array;
						find: (predicate: (value: number, index: number, obj: Float32Array) => boolean, thisArg?: any) => number | undefined;
						findIndex: (predicate: (value: number, index: number, obj: Float32Array) => boolean, thisArg?: any) => number;
						forEach: (callbackfn: (value: number, index: number, array: Float32Array) => void, thisArg?: any) => void;
						indexOf: (searchElement: number, fromIndex?: number | undefined) => number;
						join: (separator?: string | undefined) => string;
						lastIndexOf: (searchElement: number, fromIndex?: number | undefined) => number;
						readonly length: number;
						map: (callbackfn: (value: number, index: number, array: Float32Array) => number, thisArg?: any) => Float32Array;
						reduce: {
							(callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number): number;
							(callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number, initialValue: number): number;
							<U>(callbackfn: (previousValue: U, currentValue: number, currentIndex: number, array: Float32Array) => U, initialValue: U): U;
						};
						reduceRight: {
							(callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number): number;
							(callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number, initialValue: number): number;
							<U_1>(callbackfn: (previousValue: U_1, currentValue: number, currentIndex: number, array: Float32Array) => U_1, initialValue: U_1): U_1;
						};
						reverse: () => Float32Array;
						set: (array: ArrayLike<number>, offset?: number | undefined) => void;
						slice: (start?: number | undefined, end?: number | undefined) => Float32Array;
						some: (predicate: (value: number, index: number, array: Float32Array) => unknown, thisArg?: any) => boolean;
						sort: (compareFn?: ((a: number, b: number) => number) | undefined) => Float32Array;
						subarray: (begin?: number | undefined, end?: number | undefined) => Float32Array;
						toLocaleString: () => string;
						toString: () => string;
						valueOf: () => Float32Array;
						entries: () => IterableIterator<[
							number,
							number
						]>;
						keys: () => IterableIterator<number>;
						values: () => IterableIterator<number>;
						includes: (searchElement: number, fromIndex?: number | undefined) => boolean;
						[Symbol.iterator]: () => IterableIterator<number>;
						readonly [Symbol.toStringTag]: "Float32Array";
						at: (index: number) => number | undefined;
					};
					ValueBufferType: {
						[x: number]: number;
						readonly BYTES_PER_ELEMENT: number;
						readonly buffer: {
							readonly byteLength: number;
							slice: (begin: number, end?: number | undefined) => ArrayBuffer;
							readonly [Symbol.toStringTag]: string;
						} | {
							readonly byteLength: number;
							slice: (begin: number, end?: number | undefined) => SharedArrayBuffer;
							readonly [Symbol.species]: SharedArrayBuffer;
							readonly [Symbol.toStringTag]: "SharedArrayBuffer";
						};
						readonly byteLength: number;
						readonly byteOffset: number;
						copyWithin: (target: number, start: number, end?: number | undefined) => Float32Array;
						every: (predicate: (value: number, index: number, array: Float32Array) => unknown, thisArg?: any) => boolean;
						fill: (value: number, start?: number | undefined, end?: number | undefined) => Float32Array;
						filter: (predicate: (value: number, index: number, array: Float32Array) => any, thisArg?: any) => Float32Array;
						find: (predicate: (value: number, index: number, obj: Float32Array) => boolean, thisArg?: any) => number | undefined;
						findIndex: (predicate: (value: number, index: number, obj: Float32Array) => boolean, thisArg?: any) => number;
						forEach: (callbackfn: (value: number, index: number, array: Float32Array) => void, thisArg?: any) => void;
						indexOf: (searchElement: number, fromIndex?: number | undefined) => number;
						join: (separator?: string | undefined) => string;
						lastIndexOf: (searchElement: number, fromIndex?: number | undefined) => number;
						readonly length: number;
						map: (callbackfn: (value: number, index: number, array: Float32Array) => number, thisArg?: any) => Float32Array;
						reduce: {
							(callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number): number;
							(callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number, initialValue: number): number;
							<U>(callbackfn: (previousValue: U, currentValue: number, currentIndex: number, array: Float32Array) => U, initialValue: U): U;
						};
						reduceRight: {
							(callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number): number;
							(callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number, initialValue: number): number;
							<U_1>(callbackfn: (previousValue: U_1, currentValue: number, currentIndex: number, array: Float32Array) => U_1, initialValue: U_1): U_1;
						};
						reverse: () => Float32Array;
						set: (array: ArrayLike<number>, offset?: number | undefined) => void;
						slice: (start?: number | undefined, end?: number | undefined) => Float32Array;
						some: (predicate: (value: number, index: number, array: Float32Array) => unknown, thisArg?: any) => boolean;
						sort: (compareFn?: ((a: number, b: number) => number) | undefined) => Float32Array;
						subarray: (begin?: number | undefined, end?: number | undefined) => Float32Array;
						toLocaleString: () => string;
						toString: () => string;
						valueOf: () => Float32Array;
						entries: () => IterableIterator<[
							number,
							number
						]>;
						keys: () => IterableIterator<number>;
						values: () => IterableIterator<number>;
						includes: (searchElement: number, fromIndex?: number | undefined) => boolean;
						[Symbol.iterator]: () => IterableIterator<number>;
						readonly [Symbol.toStringTag]: "Float32Array";
						at: (index: number) => number | undefined;
					};
					DefaultInterpolation: InterpolationModes;
					InterpolantFactoryMethodDiscrete: (result: any) => DiscreteInterpolant;
					InterpolantFactoryMethodLinear: (result: any) => LinearInterpolant;
					InterpolantFactoryMethodSmooth: (result: any) => CubicInterpolant;
					setInterpolation: (interpolation: InterpolationModes) => KeyframeTrack;
					getInterpolation: () => InterpolationModes;
					createInterpolant: () => Interpolant;
					getValueSize: () => number;
					shift: (timeOffset: number) => KeyframeTrack;
					scale: (timeScale: number) => KeyframeTrack;
					trim: (startTime: number, endTime: number) => KeyframeTrack;
					validate: () => boolean;
					optimize: () => KeyframeTrack;
					clone: () => KeyframeTrack;
				}[];
				blendMode: AnimationBlendMode;
				duration: number;
				uuid: string;
				results: any[];
				resetDuration: () => AnimationClip;
				trim: () => AnimationClip;
				validate: () => boolean;
				optimize: () => AnimationClip;
				clone: () => AnimationClip;
				toJSON: (clip: AnimationClip) => any;
			}[];
			userData: {
				[key: string]: any;
			};
			customDepthMaterial?: {
				alphaTest: number;
				alphaToCoverage: boolean;
				blendDst: BlendingDstFactor;
				blendDstAlpha: number | null;
				blendEquation: BlendingEquation;
				blendEquationAlpha: number | null;
				blending: Blending;
				blendSrc: 210 | BlendingDstFactor;
				blendSrcAlpha: number | null;
				clipIntersection: boolean;
				clippingPlanes: any;
				clipShadows: boolean;
				colorWrite: boolean;
				defines: {
					[key: string]: any;
				} | undefined;
				depthFunc: DepthModes;
				depthTest: boolean;
				depthWrite: boolean;
				id: number;
				stencilWrite: boolean;
				stencilFunc: StencilFunc;
				stencilRef: number;
				stencilWriteMask: number;
				stencilFuncMask: number;
				stencilFail: StencilOp;
				stencilZFail: StencilOp;
				stencilZPass: StencilOp;
				readonly isMaterial: true;
				name: string;
				needsUpdate: boolean;
				opacity: number;
				polygonOffset: boolean;
				polygonOffsetFactor: number;
				polygonOffsetUnits: number;
				precision: "highp" | "mediump" | "lowp" | null;
				premultipliedAlpha: boolean;
				forceSinglePass: boolean;
				dithering: boolean;
				side: Side;
				shadowSide: Side | null;
				toneMapped: boolean;
				transparent: boolean;
				type: string;
				uuid: string;
				vertexColors: boolean;
				visible: boolean;
				userData: any;
				version: number;
				clone: () => Material;
				copy: (material: Material) => Material;
				dispose: () => void;
				onBeforeCompile: (shader: Shader, renderer: WebGLRenderer) => void;
				customProgramCacheKey: () => string;
				setValues: (values: MaterialParameters) => void;
				toJSON: (meta?: any) => any;
				addEventListener: <T extends string>(type: T, listener: EventListener<Event, T, Material>) => void;
				hasEventListener: <T_1 extends string>(type: T_1, listener: EventListener<Event, T_1, Material>) => boolean;
				removeEventListener: <T_2 extends string>(type: T_2, listener: EventListener<Event, T_2, Material>) => void;
				dispatchEvent: (event: Event) => void;
			} | undefined;
			customDistanceMaterial?: {
				alphaTest: number;
				alphaToCoverage: boolean;
				blendDst: BlendingDstFactor;
				blendDstAlpha: number | null;
				blendEquation: BlendingEquation;
				blendEquationAlpha: number | null;
				blending: Blending;
				blendSrc: 210 | BlendingDstFactor;
				blendSrcAlpha: number | null;
				clipIntersection: boolean;
				clippingPlanes: any;
				clipShadows: boolean;
				colorWrite: boolean;
				defines: {
					[key: string]: any;
				} | undefined;
				depthFunc: DepthModes;
				depthTest: boolean;
				depthWrite: boolean;
				id: number;
				stencilWrite: boolean;
				stencilFunc: StencilFunc;
				stencilRef: number;
				stencilWriteMask: number;
				stencilFuncMask: number;
				stencilFail: StencilOp;
				stencilZFail: StencilOp;
				stencilZPass: StencilOp;
				readonly isMaterial: true;
				name: string;
				needsUpdate: boolean;
				opacity: number;
				polygonOffset: boolean;
				polygonOffsetFactor: number;
				polygonOffsetUnits: number;
				precision: "highp" | "mediump" | "lowp" | null;
				premultipliedAlpha: boolean;
				forceSinglePass: boolean;
				dithering: boolean;
				side: Side;
				shadowSide: Side | null;
				toneMapped: boolean;
				transparent: boolean;
				type: string;
				uuid: string;
				vertexColors: boolean;
				visible: boolean;
				userData: any;
				version: number;
				clone: () => Material;
				copy: (material: Material) => Material;
				dispose: () => void;
				onBeforeCompile: (shader: Shader, renderer: WebGLRenderer) => void;
				customProgramCacheKey: () => string;
				setValues: (values: MaterialParameters) => void;
				toJSON: (meta?: any) => any;
				addEventListener: <T extends string>(type: T, listener: EventListener<Event, T, Material>) => void;
				hasEventListener: <T_1 extends string>(type: T_1, listener: EventListener<Event, T_1, Material>) => boolean;
				removeEventListener: <T_2 extends string>(type: T_2, listener: EventListener<Event, T_2, Material>) => void;
				dispatchEvent: (event: Event) => void;
			} | undefined;
			onBeforeRender: (renderer: WebGLRenderer, scene: Scene, camera: Camera, geometry: BufferGeometry<NormalBufferAttributes>, material: Material, group: Group) => void;
			onAfterRender: (renderer: WebGLRenderer, scene: Scene, camera: Camera, geometry: BufferGeometry<NormalBufferAttributes>, material: Material, group: Group) => void;
			applyMatrix4: (matrix: Matrix4) => void;
			applyQuaternion: (quaternion: Quaternion) => Camera;
			setRotationFromAxisAngle: (axis: Vector3, angle: number) => void;
			setRotationFromEuler: (euler: Euler) => void;
			setRotationFromMatrix: (m: Matrix4) => void;
			setRotationFromQuaternion: (q: Quaternion) => void;
			rotateOnAxis: (axis: Vector3, angle: number) => Camera;
			rotateOnWorldAxis: (axis: Vector3, angle: number) => Camera;
			rotateX: (angle: number) => Camera;
			rotateY: (angle: number) => Camera;
			rotateZ: (angle: number) => Camera;
			translateOnAxis: (axis: Vector3, distance: number) => Camera;
			translateX: (distance: number) => Camera;
			translateY: (distance: number) => Camera;
			translateZ: (distance: number) => Camera;
			localToWorld: (vector: Vector3) => Vector3;
			worldToLocal: (vector: Vector3) => Vector3;
			lookAt: {
				(vector: Vector3): void;
				(x: number, y: number, z: number): void;
			};
			add: (...object: Object3D<Event>[]) => Camera;
			remove: (...object: Object3D<Event>[]) => Camera;
			removeFromParent: () => Camera;
			clear: () => Camera;
			attach: (object: Object3D<Event>) => Camera;
			getObjectById: (id: number) => Object3D<Event> | undefined;
			getObjectByName: (name: string) => Object3D<Event> | undefined;
			getObjectByProperty: (name: string, value: any) => Object3D<Event> | undefined;
			getObjectsByProperty: (name: string, value: any) => Object3D<Event>[];
			getWorldPosition: (target: Vector3) => Vector3;
			getWorldQuaternion: (target: Quaternion) => Quaternion;
			getWorldScale: (target: Vector3) => Vector3;
			raycast: (raycaster: Raycaster, intersects: Intersection<Object3D<Event>>[]) => void;
			traverse: (callback: (object: Object3D<Event>) => any) => void;
			traverseVisible: (callback: (object: Object3D<Event>) => any) => void;
			traverseAncestors: (callback: (object: Object3D<Event>) => any) => void;
			updateMatrix: () => void;
			updateMatrixWorld: (force?: boolean | undefined) => void;
			updateWorldMatrix: (updateParents: boolean, updateChildren: boolean) => void;
			toJSON: (meta?: {
				geometries: any;
				materials: any;
				textures: any;
				images: any;
			} | undefined) => any;
			clone: (recursive?: boolean | undefined) => Camera;
			copy: (source: Camera, recursive?: boolean | undefined) => Camera;
			addEventListener: <T_6 extends string>(type: T_6, listener: EventListener<Event, T_6, Camera>) => void;
			hasEventListener: <T_7 extends string>(type: T_7, listener: EventListener<Event, T_7, Camera>) => boolean;
			removeEventListener: <T_8 extends string>(type: T_8, listener: EventListener<Event, T_8, Camera>) => void;
			dispatchEvent: (event: Event) => void;
		};
		layers: {
			mask: number;
			set: (layer: number) => void;
			enable: (layer: number) => void;
			enableAll: () => void;
			toggle: (layer: number) => void;
			disable: (layer: number) => void;
			disableAll: () => void;
			test: (layers: Layers) => boolean;
			isEnabled: (layer: number) => boolean;
		};
		params: {
			Mesh?: any;
			Line?: {
				threshold: number;
			} | undefined;
			Line2?: {
				threshold: number;
			} | undefined;
			LOD?: any;
			Points?: {
				threshold: number;
			} | undefined;
			Sprite?: any;
		};
		set: (origin: Vector3, direction: Vector3) => void;
		setFromCamera: (coords: Vector2, camera: Camera) => void;
		intersectObject: <TIntersected extends Object3D<Event>>(object: Object3D<Event>, recursive?: boolean | undefined, optionalTarget?: Intersection<TIntersected>[] | undefined) => Intersection<TIntersected>[];
		intersectObjects: <TIntersected_1 extends Object3D<Event>>(objects: Object3D<Event>[], recursive?: boolean | undefined, optionalTarget?: Intersection<TIntersected_1>[] | undefined) => Intersection<TIntersected_1>[];
		firstHitOnly?: boolean | undefined;
	};
	updateRaycasters(): void;
}
declare class ViewerPerformanceMonitor {
	protected viewer: BaseViewerType;
	constructor(viewer: BaseViewerType);
	protected _accumulatedDelta: number;
	protected _framesCount: number;
	protected _lastRoundedPerf: number;
	measurePerformance(delta: number): void;
}
type ViewerTickCallback = (delta: number) => void;
type ViewerRenderCallback = (delta: number, renderer: AbstractRenderer) => void;
interface BaseViewerCallbackOptions {
	persistent?: boolean;
}
interface HTMLElementWithViewer<C extends Camera> extends HTMLElement {
	scene: PolyScene;
	viewer: TypedViewer<C>;
	Poly: PolyEngine;
}
type UpdateCameraAspectCallback = (aspect: number, resolution: Vector2) => void;
interface CreateViewerOptions {
	canvas?: HTMLCanvasElement;
	autoRender?: boolean;
	renderer?: AbstractRenderer;
	cameraMaskOverride?: string;
}
interface TypedViewerOptions<C extends Camera> extends CreateViewerOptions {
	camera: C;
	scene: PolyScene;
	updateCameraAspect: UpdateCameraAspectCallback;
}
interface TypedViewerInterectionObserverChangeOptions {
	root?: HTMLElement;
	rootMargin?: string;
	threshold?: number;
	playPauseScene?: boolean;
	onChange?: (isIntersecting: boolean) => void;
}
interface BaseViewerMountOptions {
	updateAutoRenderOnIntersectionChange?: boolean;
}
declare abstract class TypedViewer<C extends Camera> {
	protected _domElement: HTMLElementWithViewer<C> | undefined;
	protected _active: boolean;
	private static _nextViewerId;
	private _id;
	protected _renderObjectOverride: Object3D | undefined;
	protected _canvas: HTMLCanvasElement | undefined;
	protected _camera: C;
	protected _scene: PolyScene;
	readonly updateCameraAspect: UpdateCameraAspectCallback;
	protected _doRender: boolean;
	protected _controlsNode: ApplicableControlsNode | undefined;
	constructor(options: TypedViewerOptions<C>);
	private static _nextId;
	createRaycaster(): Raycaster;
	abstract renderer(): AbstractRenderer | undefined;
	abstract rendererConfig(): AvailableRenderConfig | undefined;
	protected _mounted: boolean;
	/**
	 * mounts the viewer onto an element
	 *
	 *
	 */
	mount(element: HTMLElement, options?: BaseViewerMountOptions): void;
	/**
	 * unmounts the viewer
	 *
	 *
	 */
	unmount(): void;
	static _canvasIdPrefix(): string;
	static createCanvas(id?: string): HTMLCanvasElement;
	controlsNode(): ApplicableControlsNode | undefined;
	/**
	 * return the canvas and create one if none yet
	 *
	 *
	 */
	canvas(): HTMLCanvasElement;
	render(delta: number): void;
	setRenderObjectOverride(object?: Object3D | null): void;
	active(): boolean;
	activate(): void;
	deactivate(): void;
	protected _camerasController: ViewerCamerasController | undefined;
	camerasController(): ViewerCamerasController;
	protected _controlsController: ViewerControlsController<C>;
	controlsController(): ViewerControlsController<C>;
	protected _eventsController: ViewerEventsController | undefined;
	eventsController(): ViewerEventsController;
	protected _webGLController: ViewerWebGLController | undefined;
	webglController(): ViewerWebGLController;
	private _audioController;
	audioController(): ViewerAudioController;
	readonly raycastersController: ViewerRaycastersController;
	readonly performanceMonitor: ViewerPerformanceMonitor;
	domElement(): HTMLElementWithViewer<C> | undefined;
	scene(): PolyScene;
	/**
	 * return the camera the viewer was created with
	 *
	 *
	 */
	camera(): C;
	id(): string;
	/**
	 * disposes the viewer
	 *
	 *
	 */
	dispose(): void;
	resetContainerClass(): void;
	setContainerClassHovered(): void;
	markAsReady(): void;
	/**
	 * sets auto render state. If falls, the viewer will not render.
	 *
	 *
	 */
	setAutoRender(state?: boolean): void;
	autoRenderState(): boolean;
	private _observer;
	/**
	 * This sets the viewer to detect if it is visible, and to pause/unpause itself when its visibility changes.
	 * This can be very useful to improve performance.
	 *
	 */
	updateAutoRenderOnIntersectionChange(_options: TypedViewerInterectionObserverChangeOptions): void;
	/**
	 * Cancels the listening of the viewer's visibility.
	 *
	 */
	disableUpdateAutoRenderOnIntersectionChange(): void;
	private _onBeforeTickCallbacksMap;
	private _onAfterTickCallbacksMap;
	protected _onBeforeTickCallbacks: Array<ViewerTickCallback>;
	protected _onAfterTickCallbacks: Array<ViewerTickCallback>;
	private _onBeforeRenderCallbacksMap;
	private _onAfterRenderCallbacksMap;
	protected _onBeforeRenderCallbacks: Array<ViewerRenderCallback>;
	protected _onAfterRenderCallbacks: Array<ViewerRenderCallback>;
	/**
	 * registers a BeforeTick callback. BeforeTick callbacks are run before updating the frame (and therefore before any time dependent node has changed)
	 *
	 */
	registerOnBeforeTick(callbackName: string, callback: ViewerTickCallback, options?: BaseViewerCallbackOptions): void;
	/**
	 * unregisters BeforeTick callback
	 *
	 */
	unRegisterOnBeforeTick(callbackName: string): void;
	/**
	 * Returns the list registered BeforeTick callback names
	 *
	 */
	registeredBeforeTickCallbacks(): Map<any, any>;
	/**
	 * registers AfterTick callback. AfterTick callbacks are run after updating the frame (and therefore after any time dependent node has changed)
	 *
	 */
	registerOnAfterTick(callbackName: string, callback: ViewerTickCallback, options?: BaseViewerCallbackOptions): void;
	/**
	 * unregisters AfterTick callback
	 *
	 */
	unRegisterOnAfterTick(callbackName: string): void;
	/**
	 * Returns the list registered AfterTick callback names
	 *
	 */
	registeredAfterTickCallbacks(): Map<any, any>;
	/**
	 * registers a BeforeRender callback. BeforeRender callbacks are run before the frame is rendered
	 *
	 */
	registerOnBeforeRender(callbackName: string, callback: ViewerRenderCallback, options?: BaseViewerCallbackOptions): void;
	/**
	 * unregisters BeforeRender callback
	 *
	 */
	unRegisterOnBeforeRender(callbackName: string): void;
	/**
	 * Returns the list registered BeforeRender callback names
	 *
	 */
	registeredBeforeRenderCallbacks(): Map<any, any>;
	/**
	 * registers a AfterRender callback. AfterRender callbacks are run after the frame is rendered
	 *
	 */ registerOnAfterRender(callbackName: string, callback: ViewerRenderCallback, options?: BaseViewerCallbackOptions): void;
	/**
	 * unregisters AfterRender callback
	 *
	 */
	unRegisterOnAfterRender(callbackName: string): void;
	/**
	 * Returns the list AfterRender BeforeRender callback names
	 *
	 */
	registeredAfterRenderCallbacks(): Map<any, any>;
	private _registerCallback;
	private _unregisterCallback;
	private _updateCallbacks;
	private _runTickCallbacks;
	private _runRenderCallbacks;
	protected _runOnBeforeTickCallbacks(delta: number): void;
	protected _runOnAfterTickCallbacks(delta: number): void;
	protected _runOnBeforeRenderCallbacks(delta: number, renderer: AbstractRenderer): void;
	protected _runOnAfterRenderCallbacks(delta: number, renderer: AbstractRenderer): void;
}
type BaseViewerType = TypedViewer<Camera>;
interface EventContextValue {
	node?: BaseNodeType;
	intersect?: Intersection;
}
interface EventContext<E extends Event> {
	viewer?: Readonly<BaseViewerType>;
	event?: Readonly<E>;
	emitter?: CoreEventEmitter;
	value?: EventContextValue;
}
declare abstract class BaseSceneEventsController<E extends Event, T extends BaseInputEventNodeType> {
	protected dispatcher: SceneEventsDispatcher;
	private _activeEventDatas;
	private _activeEventDataTypes;
	protected _eventNodes: Set<T>;
	protected _requireCanvasEventListeners: boolean;
	protected _actorEvaluators: Set<ActorEvaluatorGenerator>;
	protected _actorEvaluatorsByEventNames: Map<string, Map<CoreEventEmitter, Set<ActorEvaluatorGenerator>>>;
	constructor(dispatcher: SceneEventsDispatcher);
	registerEventNode(node: T): void;
	unregisterEventNode(node: T): void;
	registerEvaluatorGenerator(evaluator: ActorEvaluatorGenerator): void;
	unregisterEvaluatorGenerator(evaluator: ActorEvaluatorGenerator): void;
	private _updateActorEvaluatorCache;
	abstract type(): string;
	abstract acceptedEventTypes(): Set<string>;
	processEvent(eventContext: EventContext<E>): void;
	updateViewerEventListeners(): void;
	activeEventDatas(): EventData[];
	private _updateActiveEventTypes;
}
type BaseSceneEventsControllerType = BaseSceneEventsController<Event, BaseInputEventNodeType>;
type DispatchHook = (event_context: EventContext<Event>) => void;
declare class TypedEventNode<K extends NodeParamsConfig> extends TypedNode<NodeContext.EVENT, K> {
	static context(): NodeContext;
	initializeBaseNode(): void;
	private _cookWithoutInputsBound;
	_cookWithoutInputs(): void;
	cook(): void;
	processEventViaConnectionPoint(eventContext: EventContext<Event>, connectionPoint: BaseEventConnectionPoint): void;
	processEvent(event_context: EventContext<Event>): void;
	protected dispatchEventToOutput(output_name: string, event_context: EventContext<Event>): Promise<void>;
	private _on_dispatch_hooks_by_output_name;
	/**
	 * onDispatch is called when an output triggers an event.
	 *
	 * Here is an example usage to listen to events:
	 *
	 * ``` ts
	 *let _currentState = false;
	 *function setHit( newState ){
	 *  if( _currentState != newState ){
	 *    if( newState ){
	 *      playSound();
	 *    }
	 *    _currentState = newState;
	 *  }
	 *}
	 *
	 *const raycastNode = scene.node('<path to the node>');
	 *raycastNode.onDispatch('hit', ()=>setHit(true) );
	 *raycastNode.onDispatch('miss', ()=>setHit(false) );
	 * ```
	 *
	 * Alternatively, you can also have the following arguments from the callback
	 *
	 * - viewer: the [viewer](https://polygonjs.com/docs/api/TypedViewer) displaying the scene.
	 * - event: the mouse/pointer/keyboard event that originally triggered the event
	 * - emitter: the domElement the event was triggered from (either the canvas or the document)
	 * - value: an optional value linked to the event.
	 *
	 * ``` ts
	 *raycastNode.onDispatch('hit',(eventContext)=>{
	 *  const {viewer, event, emitter, value} = eventContext;
	 *});
	 * ```
	 *
	 */
	onDispatch(outputName: string, callback: DispatchHook): void;
	private run_on_dispatch_hook;
}
type BaseEventNodeType = TypedEventNode<any>;
declare enum NodeContext {
	ANIM = "anim",
	AUDIO = "audio",
	COP = "cop",
	EVENT = "event",
	GL = "gl",
	JS = "js",
	MANAGER = "manager",
	MAT = "mat",
	OBJ = "obj",
	POST = "post",
	ROP = "rop",
	SOP = "sop"
}
declare enum NetworkNodeType {
	ACTOR = "actorsNetwork",
	ANIM = "animationsNetwork",
	AUDIO = "audioNetwork",
	COP = "copNetwork",
	CSG = "csgNetwork",
	EVENT = "eventsNetwork",
	MAT = "materialsNetwork",
	POST = "postProcessNetwork",
	ROP = "renderersNetwork",
	SOLVER = "solver",
	SUBNET = "subnet",
	DECOMPOSE = "decompose"
}
declare enum NetworkChildNodeType {
	INPUT = "subnetInput",
	OUTPUT = "subnetOutput"
}
declare enum CameraNodeType {
	CUBE = "cubeCamera",
	MAPBOX = "mapboxCamera",
	ORTHOGRAPHIC = "orthographicCamera",
	PERSPECTIVE = "perspectiveCamera"
}
declare enum CameraSopNodeType {
	CONTROLS = "cameraControls",
	CSS_RENDERER = "cameraCSSRenderer",
	FPS = "cameraFPS",
	FRAME_MODE = "cameraFrameMode",
	POST_PROCESS = "cameraPostProcess",
	RENDER_SCENE = "cameraRenderScene",
	RENDERER = "cameraRenderer",
	VIEWER_CODE = "cameraViewerCode",
	VIEW_OFFSET = "cameraViewOffset",
	WEBXR_AR = "cameraWebXRAR",
	WEBXR_VR = "cameraWebXRVR",
	WEBXR_AR_MARKER_TRACKING = "cameraWebXRARMarkerTracking"
}
declare enum CameraControlsNodeType {
	MAP = "cameraMapControls",
	ORBIT = "cameraOrbitControls",
	FIRST_PERSON = "firstPersonControls",
	PLAYER = "playerControls",
	MOBILE_JOYSTICK = "mobileJoystickControls"
}
declare enum AudioNodeAnalyserType {
	FFT = "FFT",
	METER = "meter",
	WAVEFORM = "waveform"
}
type NodeTypeMapGeneric = {
	[key in NodeContext]: TypedNode<key, any>;
};
interface BaseNodeByContextMap extends NodeTypeMapGeneric {
	[NodeContext.ANIM]: BaseAnimNodeType;
	[NodeContext.AUDIO]: BaseAudioNodeType;
	[NodeContext.COP]: BaseCopNodeType;
	[NodeContext.EVENT]: BaseEventNodeType;
	[NodeContext.GL]: BaseGlNodeType;
	[NodeContext.JS]: BaseJsNodeType;
	[NodeContext.MANAGER]: BaseManagerNodeType;
	[NodeContext.MAT]: BaseMatNodeType;
	[NodeContext.OBJ]: BaseObjNodeType;
	[NodeContext.POST]: BasePostProcessNodeType;
	[NodeContext.SOP]: BaseSopNodeType;
	[NodeContext.ROP]: BaseRopNodeType;
}
declare class NodeTimeDependentState<NC extends NodeContext> extends NodeBaseState<NC> {
	active(): boolean;
	paramsTimeDependent(): boolean;
	inputsTimeDependent(): boolean;
	forceTimeDependent(): void;
	unforceTimeDependent(): void;
}
declare class NodeStatesController {
	protected node: BaseNodeType;
	timeDependent: NodeTimeDependentState<any>;
	error: NodeErrorState<any>;
	constructor(node: BaseNodeType);
}
declare class HierarchyParentController {
	protected node: BaseNodeType;
	private _parent;
	private _on_set_parent_hooks;
	constructor(node: BaseNodeType);
	parent(): BaseNodeType | null;
	setParent(parent: BaseNodeType | null): void;
	firstAncestorWithContext<N extends NodeContext>(context: N): BaseNodeByContextMap[N] | null;
	findParent(callback: (parent: BaseNodeType) => boolean): BaseNodeType | null;
	path(relativeToParent?: BaseNodeType): string;
	onSetParent(): void;
	findNode(path: string | null): BaseNodeType | null;
}
type NodeLifeCycleControllerCallback = () => void;
type NodeLifeCycleControllerCallbackWithChildNode = (childNode: BaseNodeType) => void;
declare class NodeLifeCycleController {
	protected node: BaseNodeType;
	protected _creationCompleted: boolean;
	protected _onChildAddCallbacks: NodeLifeCycleControllerCallbackWithChildNode[] | undefined;
	private _onChildRemoveCallbacks;
	private _onAfterCreatedCallbacks;
	private _onAfterAddedCallbacks;
	private _onBeforeDeletedCallbacks;
	private _onAfterDeletedCallbacks;
	constructor(node: BaseNodeType);
	dispose(): void;
	setCreationCompleted(): void;
	creationCompleted(): boolean;
	onChildAdd(callback: NodeLifeCycleControllerCallbackWithChildNode): void;
	runOnChildAddCallbacks(node: BaseNodeType): void;
	onChildRemove(callback: NodeLifeCycleControllerCallbackWithChildNode): void;
	runOnChildRemoveCallbacks(node: BaseNodeType): void;
	onAfterCreated(callback: NodeLifeCycleControllerCallback): void;
	runOnAfterCreatedCallbacks(): void;
	onAfterAdded(callback: NodeLifeCycleControllerCallback): void;
	runOnAfterAddedCallbacks(): void;
	onBeforeDeleted(callback: NodeLifeCycleControllerCallback): void;
	runOnBeforeDeleteCallbacks(): void;
	onAfterDeleted(callback: NodeLifeCycleControllerCallback): void;
	runOnDeleteCallbacks(): void;
	protected _runCallbacks(hooks: NodeLifeCycleControllerCallback[] | undefined): void;
	protected _runCallbacksWithChildNode(hooks: NodeLifeCycleControllerCallbackWithChildNode[] | undefined, childNode: BaseNodeType): void;
}
declare class TypedContainerController<NC extends NodeContext> {
	protected node: TypedNode<NC, any>;
	private _callbacks;
	private _callbacksTmp;
	protected _container: ContainerMap[NC];
	constructor(node: TypedNode<NC, any>);
	container(): ContainerMap[NC];
	private _createContainer;
	private _createContainerWithContent;
	firstNonBypassedNode(): TypedNode<NC, any>;
	containerUnlessBypassed(): ContainerMap[NC] | undefined;
	compute(): Promise<ContainerMap[NC]>;
	requestInputContainer(inputIndex: number): Promise<ContainerMap[NC] | null>;
	notifyRequesters(container?: ContainerMap[NC]): void;
}
type OnCookCompleteHook = () => void;
declare class NodeCookController<NC extends NodeContext> {
	private node;
	private _corePerformance;
	private _cooking;
	private _cookingDirtyTimestamp;
	private _performanceController;
	private _inputContainers;
	private _inputContents;
	private _EMPTY_ARRAY;
	constructor(node: BaseNodeType);
	performanceRecordStarted(): boolean;
	dispose(): void;
	private _inputsEvaluationRequired;
	disallowInputsEvaluation(): void;
	isCooking(): boolean;
	private _startCookIfNoErrors;
	cookMain(): Promise<void>;
	private _onError;
	cookMainWithoutInputs(): Promise<void>;
	endCook(): void;
	private _initCookingState;
	private _terminateCookProcess;
	private _evaluateInputs;
	private _evaluateParams;
	cooksCount(): number;
	cookTime(): number;
	private _finalizeCookPerformance;
	private _onCookCompleteHookNames;
	private _onCookCompleteHooks;
	registerOnCookEnd(callbackName: string, callback: OnCookCompleteHook): void;
	private _clearHooks;
	deregisterOnCookEnd(callbackName: string): void;
	private _runOnCookCompleteHooks;
	onCookEndCallbackNames(): string[] | undefined;
}
type NameControllerCallback = () => void;
declare class NameController {
	protected node: BaseNodeType;
	private _graphNode;
	private _onSetNameHooks;
	private _onSetFullPathHooks;
	constructor(node: BaseNodeType);
	dispose(): void;
	graphNode(): CoreGraphNode;
	static baseName(node: BaseNodeType | typeof BaseNodeClass): string;
	requestNameToParent(newName: string): void;
	setName(newName: string): void;
	updateNameFromParent(new_name: string): void;
	add_post_set_name_hook(hook: NameControllerCallback): void;
	add_post_set_fullPath_hook(hook: NameControllerCallback): void;
	private _postSetName;
	runPostSetFullPathHooks(): void;
}
declare enum NodeEvent {
	CREATED = "node_created",
	DELETED = "node_deleted",
	NAME_UPDATED = "node_name_update",
	OVERRIDE_CLONABLE_STATE_UPDATE = "node_override_clonable_state_update",
	NAMED_OUTPUTS_UPDATED = "node_named_outputs_updated",
	NAMED_INPUTS_UPDATED = "node_named_inputs_updated",
	INPUTS_UPDATED = "node_inputs_updated",
	PARAMS_UPDATED = "node_params_updated",
	UI_DATA_POSITION_UPDATED = "node_ui_data_position_updated",
	UI_DATA_COMMENT_UPDATED = "node_ui_data_comment_updated",
	ERROR_UPDATED = "node_error_updated",
	FLAG_BYPASS_UPDATED = "bypass_flag_updated",
	FLAG_DISPLAY_UPDATED = "display_flag_updated",
	FLAG_OPTIMIZE_UPDATED = "optimize_flag_updated",
	SELECTION_UPDATED = "selection_updated",
	POLY_NODE_LOCK_STATE_UPDATED = "lock_state_updated"
}
type PolyNodeClassByContextMapGeneric = {
	[key in NodeContext]: any;
};
interface PolyNodeClassByContext extends PolyNodeClassByContextMapGeneric {
	[NodeContext.ANIM]: undefined;
	[NodeContext.AUDIO]: undefined;
	[NodeContext.COP]: undefined;
	[NodeContext.EVENT]: undefined;
	[NodeContext.GL]: undefined;
	[NodeContext.JS]: undefined;
	[NodeContext.MANAGER]: undefined;
	[NodeContext.MAT]: undefined;
	[NodeContext.OBJ]: undefined;
	[NodeContext.ROP]: undefined;
	[NodeContext.SOP]: undefined;
}
interface PolyNodeDataRegister<NC extends NodeContext> {
	node_context: NC;
	node_type: string;
	data: PolyNodeDefinition;
}
type CreatePolyNodeFunction = (nodeType: string, definition: PolyNodeDefinition, polyNodeControllerClass: typeof PolyNodeController) => any;
declare class PolyNodeController {
	private node;
	private _definition;
	private static _createPolyNodeFunctionByContext;
	static registerCreatePolyNodeFunctionForContext(context: NodeContext, createPolyNodeFunction: CreatePolyNodeFunction): void;
	private static _definitionRegister;
	private _locked;
	constructor(node: BaseNodeType, _definition: PolyNodeDefinition);
	initializeNode(): void;
	locked(): boolean;
	setLockedState(state: boolean): void;
	private _initInputs;
	static setupParamsConfig(paramsConfig: NodeParamsConfig, data: PolyNodeDefinition): void;
	createChildNodesFromDefinition(): void;
	static inputsData(node: BaseNodeType): PolyNodesInputsData;
	static polyNodeData(node: BaseNodeType, inputsData?: PolyNodesInputsData): Promise<PolyNodeDefinition>;
	static _createNodeClass<NC extends NodeContext>(nodeContext: NC, nodeType: string, data: PolyNodeDefinition): PolyNodeClassByContext[NC] | undefined;
	static createNodeClassAndRegister<NC extends NodeContext>(dataRegister: PolyNodeDataRegister<NC>): void;
	static definition<NC extends NodeContext>(context: NC, type: string): PolyNodeDefinition | undefined;
	static register(): Map<NodeContext, Map<string, PolyNodeDefinition>>;
}
interface NodeDeletedEmitData {
	parent_id: CoreGraphNodeId;
}
interface NodeCreatedEmitData {
	child_node_json: NodeSerializerData;
}
type EmitDataByNodeEventMapGeneric = {
	[key in NodeEvent]: any;
};
interface EmitDataByNodeEventMap extends EmitDataByNodeEventMapGeneric {
	[NodeEvent.CREATED]: NodeCreatedEmitData;
	[NodeEvent.DELETED]: NodeDeletedEmitData;
	[NodeEvent.ERROR_UPDATED]: undefined;
}
interface IntegrationData {
	name: string;
	data: PolyDictionary<string>;
}
interface BaseNodeEvent extends BaseEvent {
	target?: BaseNodeType;
}
type NodeEventListener = EventListener<BaseNodeEvent, string, EventDispatcher<BaseNodeEvent>>;
declare class TypedNode<NC extends NodeContext, K extends NodeParamsConfig> extends CoreGraphNode {
	createOptions?: NodeCreateOptions | undefined;
	containerController: TypedContainerController<NC>;
	private _parentController;
	private _uiData;
	private _states;
	private _lifecycle;
	private _serializer;
	private _cookController;
	readonly flags: FlagsController | undefined;
	readonly displayNodeController: DisplayNodeController | undefined;
	readonly persisted_config: BasePersistedConfig | undefined;
	private _paramsController;
	readonly paramsConfig: K | undefined;
	readonly pv: ParamsValueAccessorType<K>;
	readonly p: ParamsAccessorType<K>;
	copy_param_values(node: TypedNode<NC, K>): void;
	dataType(): string;
	private _nameController;
	get parentController(): HierarchyParentController;
	static displayedInputNames(): string[] | undefined;
	displayedInputNames(): string[] | undefined;
	private _childrenController;
	protected _childrenControllerContext: NodeContext | undefined;
	childrenControllerContext(): NodeContext | undefined;
	private _create_childrenController;
	get childrenController(): HierarchyChildrenController | undefined;
	childrenAllowed(): boolean;
	sceneReadonly(): boolean;
	get uiData(): UIData;
	get states(): NodeStatesController<NC>;
	get lifecycle(): NodeLifeCycleController;
	get serializer(): CoreNodeSerializer | undefined;
	get cookController(): NodeCookController<NC>;
	protected _io: IOController<NC> | undefined;
	get io(): IOController<NC>;
	get nameController(): NameController;
	/**
	 * sets the name of a node. Note that if a sibling node already has that name, it will be updated to be unique.
	 *
	 */
	setName(name: string): void;
	_setCoreName(name: string): void;
	get params(): ParamsController;
	constructor(scene: PolyScene, nodeName?: string, createOptions?: NodeCreateOptions | undefined);
	private _initialized;
	initializeBaseAndNode(): void;
	protected initializeBaseNode(): void;
	protected initializeNode(): void;
	static type(): string;
	static onRegister: OnNodeRegisterCallback | undefined;
	/**
	 * returns the type of the node.
	 *
	 */
	type(): string;
	static context(): NodeContext;
	/**
	 * returns the context.
	 *
	 */
	context(): NodeContext;
	static requireWebGL2(): boolean;
	requireWebGL2(): boolean;
	setParent(parent: BaseNodeType | null): void;
	/**
	 * returns the parent.
	 *
	 */
	parent(): BaseNodeType | null;
	insideALockedParent(): boolean;
	lockedOrInsideALockedParent(): boolean;
	selfOrLockedParent(): BaseNodeType | null;
	lockedParent(): BaseNodeType | null;
	firstAncestorWithContext<N extends NodeContext>(context: N): BaseNodeByContextMap[N] | null;
	root(): RootManagerNode;
	/**
	 * returns the path.
	 *
	 */
	path(relative_to_parent?: BaseNodeType): string;
	createParams(): void;
// @ts-ignore
	addParam<T extends ParamType>(type: T, name: string, default_value: ParamInitValuesTypeMap[T], options?: ParamOptions): ParamConstructorMap[T] | undefined;
	paramDefaultValue(name: string): ParamInitValueSerialized;
	cook(inputContents: any[]): any;
	/**
	 * registers a callback that will be run every time the node finishes cooking.
	 *
	 */
	onCookEnd(callbackName: string, callback: OnCookCompleteHook): void;
	/**
	 * returns a promise that will be resolved when the node finishes cooking.
	 *
	 */
	compute(): Promise<ContainerMap[NC]>;
	_setContainer(content: ContainableMap[NC]): void;
	/**
	 * create a node.
	 *
	 */
	createNode(nodeClass: any, options?: NodeCreateOptions): BaseNodeType | undefined;
	createOperationContainer(type: string, operation_container_name: string, options?: NodeCreateOptions): BaseOperationContainer<any> | undefined;
	/**
	 * removes a child node
	 *
	 */
	removeNode(node: BaseNodeType): void;
	dispose(): void;
	/**
	 * returns the list of children
	 *
	 */
	children(): Readonly<BaseNodeType[]>;
	/**
	 * returns a child node
	 *
	 */
	node(path: string): BaseNodeType | null;
	/**
	 * returns a sibling node
	 *
	 */
	nodeSibling(name: string): BaseNodeByContextMap[NC] | null;
	/**
	 * returns the children matching the type
	 *
	 */
	nodesByType(type: string): BaseNodeType[];
	/**
	 * sets a node as input
	 *
	 */
	setInput(inputIndexOrName: number | string, node: BaseNodeByContextMap[NC] | null, outputIndexOrName?: number | string, options?: SetInputsOptions): void;
	emit(event_name: NodeEvent.CREATED, data: EmitDataByNodeEventMap[NodeEvent.CREATED]): void;
	emit(event_name: NodeEvent.DELETED, data: EmitDataByNodeEventMap[NodeEvent.DELETED]): void;
	emit(event_name: NodeEvent.NAME_UPDATED): void;
	emit(event_name: NodeEvent.OVERRIDE_CLONABLE_STATE_UPDATE): void;
	emit(event_name: NodeEvent.NAMED_INPUTS_UPDATED): void;
	emit(event_name: NodeEvent.NAMED_OUTPUTS_UPDATED): void;
	emit(event_name: NodeEvent.INPUTS_UPDATED): void;
	emit(event_name: NodeEvent.PARAMS_UPDATED): void;
	emit(event_name: NodeEvent.UI_DATA_POSITION_UPDATED): void;
	emit(event_name: NodeEvent.UI_DATA_COMMENT_UPDATED): void;
	emit(event_name: NodeEvent.ERROR_UPDATED): void;
	emit(event_name: NodeEvent.FLAG_BYPASS_UPDATED): void;
	emit(event_name: NodeEvent.FLAG_DISPLAY_UPDATED): void;
	emit(event_name: NodeEvent.FLAG_OPTIMIZE_UPDATED): void;
	emit(event_name: NodeEvent.SELECTION_UPDATED): void;
	emit(event_name: NodeEvent.POLY_NODE_LOCK_STATE_UPDATED): void;
	private __eventsDispatcher;
	private _eventsDispatcher;
	dispatchEvent(event: {
		type: string;
	}): void;
	addEventListener(type: string, listener: NodeEventListener): void;
	removeEventListener(type: string, listener: NodeEventListener): void;
	toJSON(includeParamComponents?: boolean): NodeSerializerData | undefined;
	requiredModules(): ModuleName[] | void;
	usedAssembler(): AssemblerName | void;
	integrationData(): IntegrationData | void;
	readonly polyNodeController: PolyNodeController | undefined;
	processError(e: unknown): unknown;
	updateObjectOnAdd(object: ObjectContent<CoreObjectType>, parent: ObjectContent<CoreObjectType>): void;
	updateObjectOnRemove(object: ObjectContent<CoreObjectType>, parent: ObjectContent<CoreObjectType>): void;
}
type BaseNodeType = TypedNode<any, any>;
declare class BaseNodeClass extends TypedNode<any, any> {
}
declare class BaseNodeClassWithDisplayFlag extends TypedNode<any, any> {
	readonly flags: FlagsControllerD;
}
// @ts-ignore
type OnDisposeCallback = () => void;
declare class BaseEvaluator {
	readonly node: BaseNodeType;
	protected scene: PolyScene;
	protected timeController: TimeController;
	protected _watchStopHandles: WatchStopHandle[];
	constructor(node: BaseNodeType);
	_onDisposeCallbacks?: OnDisposeCallback[];
	onDispose(callback: OnDisposeCallback): void;
	dispose(): void;
}
type TriggerCallback = () => void;
type EvaluatorKeyboardMethod = JsType.ON_KEY | JsType.ON_KEYDOWN | JsType.ON_KEYPRESS | JsType.ON_KEYUP;
type EvaluatorPointerMethod = "onClick" | "onPointermove" | JsType.ON_POINTERDOWN | JsType.ON_POINTERUP;
type EvaluatorMethodName = JsType.ON_KEY | JsType.ON_KEYDOWN | JsType.ON_KEYPRESS | JsType.ON_KEYUP | JsType.ON_MAPBOX_CAMERA_MOVE | JsType.ON_MAPBOX_CAMERA_MOVE_START | JsType.ON_MAPBOX_CAMERA_MOVE_END | JsType.ON_OBJECT_ATTRIBUTE_UPDATE | "onClick" | JsType.ON_OBJECT_DISPATCH_EVENT | JsType.ON_PERFORMANCE_CHANGE | JsType.ON_POINTERDOWN | "onPointermove" | JsType.ON_POINTERUP | JsType.ON_SCENE_PAUSE | JsType.ON_SCENE_PLAY | JsType.ON_SCENE_RESET | JsType.ON_TICK | JsType.ON_VIDEO_EVENT | JsType.ON_WEBXR_CONTROLLER_EVENT;
interface EvaluatorEventData extends EventData {
	jsType: JsType;
}
declare class ActorEvaluator extends BaseEvaluator {
	readonly node: ActorBuilderNode;
	readonly object3D: ObjectContent<CoreObjectType>;
	constructor(node: ActorBuilderNode, object3D: ObjectContent<CoreObjectType>);
	onKey?: TriggerCallback;
	onKeydown?: TriggerCallback;
	onKeypress?: TriggerCallback;
	onKeyup?: TriggerCallback;
	onPlayerEvent?: TriggerCallback;
	onMapboxCameraMove?: TriggerCallback;
	onMapboxCameraMoveStart?: TriggerCallback;
	onMapboxCameraMoveEnd?: TriggerCallback;
	onObjectAttributeUpdate?: TriggerCallback;
	onObjectClick?: TriggerCallback;
	onObjectDispatchEvent?: TriggerCallback;
	onObjectHover?: TriggerCallback;
	onObjectPointerdown?: TriggerCallback;
	onObjectPointerup?: TriggerCallback;
	onPerformanceChange?: TriggerCallback;
	onPointerdown?: TriggerCallback;
	onPointerup?: TriggerCallback;
	onScenePause?: TriggerCallback;
	onScenePlay?: TriggerCallback;
	onSceneReset?: TriggerCallback;
	onTick?: TriggerCallback;
	onVideoEvent?: TriggerCallback;
	onWebXRControllerEvent?: TriggerCallback;
}
type GeneratorFunction = (object: ObjectContent<CoreObjectType>) => ActorEvaluator;
type EvaluatorCallback = (evaluator: ActorEvaluator) => void;
declare class ActorEvaluatorGenerator {
	private _func;
	private _expectedEvaluatorMethodNames;
	constructor(_func: GeneratorFunction);
	private _evaluatorByObject;
	eventDatas?: Set<EvaluatorEventData>;
	private _createEvaluator;
	setExpectedEvaluatorMethodNames(dummyEvaluator: ActorEvaluator): void;
	hasExpectedEvaluatorMethodName(methodName: EvaluatorMethodName): boolean;
	size(): number;
	disposeEvaluator(object: ObjectContent<CoreObjectType>): void;
	findOrCreateEvaluator(object: ObjectContent<CoreObjectType>): ActorEvaluator;
	traverseEvaluator(callback: EvaluatorCallback): void;
	clearObjects(): void;
}
declare class ActorKeyboardEventsController {
	protected actorsManager: ActorsManager;
	protected _scene: PolyScene;
	private _triggeredEvaluatorGeneratorsByMethodName;
	constructor(actorsManager: ActorsManager);
	addTriggeredEvaluators(evaluatorGenerators: Set<ActorEvaluatorGenerator>, methodName: EvaluatorKeyboardMethod): void;
	runTriggers(): void;
}
declare class ActorPointerEventsController {
	protected actorsManager: ActorsManager;
	protected _scene: PolyScene;
	private _triggeredEvaluatorGeneratorsByMethodName;
	constructor(actorsManager: ActorsManager);
	addTriggeredEvaluators(evaluatorGenerators: Set<ActorEvaluatorGenerator>, methodName: EvaluatorPointerMethod): void;
	runTriggers(): void;
}
declare abstract class ActorBuilderNode extends AssemblerControllerNode<JsAssemblerActor> {
	abstract readonly compilationController: ActorCompilationController;
}
declare class ActorsManager {
	readonly scene: PolyScene;
	private _keyboardEventsController;
	private _manualTriggerController;
	private _pointerEventsController;
	constructor(scene: PolyScene);
	registerEvaluatorGenerator(evaluatorGenerator: ActorEvaluatorGenerator): void;
	unregisterEvaluatorGenerator(evaluatorGenerator: ActorEvaluatorGenerator): void;
	assignActorBuilder(object: ObjectContent<CoreObjectType>, node: ActorBuilderNode): void;
	objectActorNodeIds(object: ObjectContent<CoreObjectType>): number[] | undefined;
	get keyboardEventsController(): ActorKeyboardEventsController;
	get manualTriggerController(): ActorManualTriggersController;
	get pointerEventsController(): ActorPointerEventsController;
	tick(): void;
	runOnEventSceneReset(): void;
	runOnEventScenePlay(): void;
	runOnEventScenePause(): void;
	runOnEventPerformanceChange(): void;
	private _onEventTickBound;
	private _onEventTick;
	private _onEventSceneResetBound;
	private _onEventSceneReset;
	private _onEventSceneResetTraverse;
	private _onEventScenePlayBound;
	private _onEventScenePlay;
	private _onEventScenePlayTraverse;
	private _onEventScenePauseBound;
	private _onEventScenePause;
	private _onEventScenePauseTraverse;
	private _onEventPerformanceChangeBound;
	private _onEventPerformanceChange;
	private _onEventPerformanceChangeTraverse;
	triggerEventNodes(object: Object3D, methodName: EvaluatorMethodName): void;
	triggerEventNode(node: ActorBuilderNode, object: Object3D, methodName: EvaluatorMethodName): void;
	private _triggerEvaluatorGenerator;
}
type OnCameraObjectsUpdated = () => void;
interface MainCameraOptions {
	cameraMaskOverride?: string;
	findAnyCamera?: boolean;
	printCameraNotFoundError?: boolean;
}
declare class SceneCamerasController {
	private scene;
	private _coreGraphNode;
	constructor(scene: PolyScene);
	coreGraphNode(): CoreGraphNode;
	dispose(): void;
	private _cameraObjectsRecentlyUpdated;
	updateFromChangeInObject(object: Object3D): void;
	cameraObjects(target: Array<Camera>): Camera[];
	private _cameraObjects;
	cameraObjectsRecentlyUpdated(): Camera[];
	setMainCamera(camera: Camera): void;
	setMainCameraPath(path: string): void;
	mainCameraPath(): string;
	private _errorMessageDisplayed;
	mainCamera(options?: MainCameraOptions): Promise<Camera | null>;
	private _findAnyCameraObject;
	createMainViewer(options?: CreateViewerOptions): Promise<TypedViewer<Camera> | undefined>;
	private _onCameraObjectsUpdated;
	onCameraObjectsUpdated(callback: OnCameraObjectsUpdated | undefined): void;
}
declare class Cooker {
	private _scene;
	constructor(_scene: PolyScene);
	private _queue;
	private _nodeIdsInFlushingQueue;
	private _blockLevel;
	block(): void;
	unblock(): void;
	blocked(): boolean;
	enqueue(node: CoreGraphNode, originalTriggerGraphNode?: CoreGraphNode): void;
	private _processQueue;
	private _processItem;
}
declare class SceneCookController {
	private _cookingNodesById;
	private _nodeIdsHavingCookedAtLeastOnce;
	private _nodeIdsCookingMoreThanOnce;
	private _resolves;
	constructor();
	addNode(node: BaseNodeType): void;
	removeNode(node: BaseNodeType): void;
	cookingNodes(target?: BaseNodeType[]): BaseNodeType[];
	allNodesHaveCookedAtLeastOnce(): boolean;
	private flush;
	waitForCooksCompleted(): Promise<void>;
}
interface NodePerformanceData {
	inputsTime: number;
	paramsTime: number;
	cookTime: number;
}
interface PerformancePrintObject {
	fullPath: string;
	cooks_count: number;
	total_time: number;
	total_cook_time: number;
	cook_time_per_iteration: number;
	inputs_time_per_iteration: number;
	params_time_per_iteration: number;
}
declare class PerformanceNode {
	private _node;
	_cooks_count: number;
	_total_cook_time: number;
	_total_inputs_time: number;
	_total_params_time: number;
	constructor(_node: BaseNodeType);
	update_cook_data(performance_data: NodePerformanceData): void;
	total_time(): number;
	total_cook_time(): number;
	cook_time_per_iteration(): number;
	total_inputs_time(): number;
	inputs_time_per_iteration(): number;
	total_params_time2(): number;
	params_time_per_iteration2(): number;
	cooks_count(): number;
	print_object(): PerformancePrintObject;
}
declare class CorePerformance {
	private _started;
	_start_time: number | null;
	_previous_timestamp: number;
	_nodes_cook_data: PolyDictionary<PerformanceNode>;
	_durations_by_name: PolyDictionary<number>;
	_durations_count_by_name: PolyDictionary<number>;
	profile(name: string, method: (args?: any) => any): void;
	start(): void;
	stop(): void;
	reset(): void;
	started(): boolean;
	recordNodeCookData(node: BaseNodeType, performance_data: NodePerformanceData): void;
	record(name: string): number;
	print(): void;
	print_node_cook_data(): PerformancePrintObject[];
	print_recordings(): {
		duration: number;
		name: string;
		count: number;
		duration_per_iteration: number;
	}[];
}
declare enum SceneEvent {
	MAX_FRAME_UPDATED = "scene_maxFrameUpdated",
	REALTIME_STATUS_UPDATED = "scene_realtime_status_updated",
	FRAME_UPDATED = "scene_frame_updated",
	PLAY_STATE_UPDATED = "scene_play_state_updated"
}
interface DebugLinesContainer {
	nodePath: string;
	debugLines: DebugLine[];
}
interface EventsListener {
	processEvents: (emitter: CoreGraphNode, event: SceneEvent | NodeEvent | ParamEvent, data?: any) => void;
	processActorEvaluator(evaluator: ActorEvaluator): ActorEvaluator;
	actorEvaluatorDebug(options: DebugLinesContainer): void;
}
type OnAddListenerCallback = () => void;
declare class DispatchController {
	private scene;
	private _onAddListenerCallbacks;
	constructor(scene: PolyScene);
	private _eventsListener;
	setListener(eventsListener: EventsListener): void;
	onAddListener(callback: OnAddListenerCallback): void;
	private _runOnAddListenerCallbacks;
	dispatch(emitter: CoreGraphNode, event: SceneEvent | NodeEvent | ParamEvent, data?: any): void;
	emitAllowed(): boolean;
	processActorEvaluator(evaluator: ActorEvaluator): ActorEvaluator | undefined;
	actorEvaluatorDebug(options: DebugLinesContainer): void | undefined;
}
declare class SceneExpressionsController {
	private _paramsById;
	constructor();
	registerParam(param: BaseParamType): void;
	deregisterParam(param: BaseParamType): void;
	regenerateReferringExpressions(node: BaseNodeType): void;
}
declare class SceneLifeCycleController {
	private scene;
	constructor(scene: PolyScene);
	private _lifecycleOnAfterCreatedAllowed;
	onAfterCreatedCallbackAllowed(): boolean;
	onAfterCreatedPrevent(callback: () => void): void;
}
declare class LoadingController {
	private scene;
	constructor(scene: PolyScene);
	private _loadingState;
	private _autoUpdating;
	markAsLoading(): void;
	markAsLoaded(): void;
	dispatchReadyEvent(): void;
	private _triggerLoadedEvent;
	private _setLoadingState;
	isLoading(): boolean;
	loaded(): boolean;
	autoUpdating(): boolean;
	setAutoUpdate(newState: boolean): void;
}
declare class MissingReference {
	private param;
	readonly path: string;
	constructor(param: BaseParamType, path: string);
	absolutePath(): string | null | undefined;
	matchesPath(path: string): boolean;
	resolveMissingDependencies(): void;
}
declare class MissingReferencesController {
	private scene;
	private references;
	private _toIgnore;
	constructor(scene: PolyScene);
	register(param: BaseParamType, path: string, jsepNode?: Expression): MissingReference | undefined;
	deregisterParam(param: BaseParamType): void;
	registerToIgnore(jsepNode: Expression): void;
	resolveMissingReferences(): void;
	private _isReferenceResolvable;
	checkForMissingNodeReferences(node: BaseNodeType): void;
	checkForMissingParamReferences(param: BaseParamType): void;
	private _checkForMissingReferencesForNode;
	private _checkForMissingReferencesForParam;
}
declare class GraphNodesController {
	protected scene: PolyScene;
	private _graphNodeIdByPath;
	private _pathByGraphNodeId;
	constructor(scene: PolyScene);
	notifyNodePathChanged(node: BaseNodeType): void;
	notifyParamPathChanged(param: BaseParamType): void;
	private _notifyGraphNodePathChanged;
	pathRef(path: string): Ref<number | null>;
	private _findOrCreateRef;
}
interface NodeChildrenMapByContext {
	[NodeContext.ANIM]: AnimNodeChildrenMap;
	[NodeContext.AUDIO]: AudioNodeChildrenMap;
	[NodeContext.COP]: CopNodeChildrenMap;
	[NodeContext.EVENT]: EventNodeChildrenMap;
	[NodeContext.GL]: GlNodeChildrenMap;
	[NodeContext.JS]: JsNodeChildrenMap;
	[NodeContext.MANAGER]: {};
	[NodeContext.MAT]: MatNodeChildrenMap;
	[NodeContext.OBJ]: ObjNodeChildrenMap;
	[NodeContext.POST]: PostNodeChildrenMap;
	[NodeContext.ROP]: RopNodeChildrenMap;
	[NodeContext.SOP]: GeoNodeChildrenMap;
}
type NodeByNodeId = Map<CoreGraphNodeId, BaseNodeType>;
type NodeMapByType<NC extends NodeContext> = Map<keyof NodeChildrenMapByContext[NC], NodeByNodeId>;
declare class NodesController {
	private scene;
	constructor(scene: PolyScene);
	_root: RootManagerNode;
	_nodeContextSignatures: PolyDictionary<boolean>;
	_instanciatedNodesByContextAndType: Map<NodeContext, NodeMapByType<NodeContext>>;
	createRoot(options?: NodeCreateOptions): void;
	root(): RootManagerNode;
	private _traverseNode;
	traverseNodes(callback: (node: BaseNodeType) => void): void;
	clear(): void;
	node(path: string): BaseNodeType | RootManagerNode | null;
	allNodes(): BaseNodeType[];
	nodesFromMask(mask: string): BaseNodeType[];
	resetNodeContextSignatures(): void;
	registerNodeContextSignature(node: BaseNodeType): void;
	nodeContextSignatures(): string[];
	addToInstanciatedNode(node: BaseNodeType): void;
	removeFromInstanciatedNode(node: BaseNodeType): void;
	nodesByType(type: string): BaseNodeType[];
	nodesByContextAndType<T extends keyof NodeChildrenMapByContext[NodeContext.ANIM]>(context: NodeContext.ANIM, node_type: T): NodeChildrenMapByContext[NodeContext.ANIM][T][];
	nodesByContextAndType<T extends keyof NodeChildrenMapByContext[NodeContext.AUDIO]>(context: NodeContext.AUDIO, node_type: T): NodeChildrenMapByContext[NodeContext.AUDIO][T][];
	nodesByContextAndType<T extends keyof NodeChildrenMapByContext[NodeContext.COP]>(context: NodeContext.COP, node_type: T): NodeChildrenMapByContext[NodeContext.COP][T][];
	nodesByContextAndType<T extends keyof NodeChildrenMapByContext[NodeContext.EVENT]>(context: NodeContext.EVENT, node_type: T): NodeChildrenMapByContext[NodeContext.EVENT][T][];
	nodesByContextAndType<T extends keyof NodeChildrenMapByContext[NodeContext.GL]>(context: NodeContext.GL, node_type: T): NodeChildrenMapByContext[NodeContext.GL][T][];
	nodesByContextAndType<T extends keyof NodeChildrenMapByContext[NodeContext.JS]>(context: NodeContext.JS, node_type: T): NodeChildrenMapByContext[NodeContext.JS][T][];
	nodesByContextAndType<T extends keyof NodeChildrenMapByContext[NodeContext.MAT]>(context: NodeContext.MAT, node_type: T): NodeChildrenMapByContext[NodeContext.MAT][T][];
	nodesByContextAndType<T extends keyof NodeChildrenMapByContext[NodeContext.OBJ]>(context: NodeContext.OBJ, node_type: T): NodeChildrenMapByContext[NodeContext.OBJ][T][];
	nodesByContextAndType<T extends keyof NodeChildrenMapByContext[NodeContext.POST]>(context: NodeContext.POST, node_type: T): NodeChildrenMapByContext[NodeContext.POST][T][];
	nodesByContextAndType<T extends keyof NodeChildrenMapByContext[NodeContext.ROP]>(context: NodeContext.ROP, node_type: T): NodeChildrenMapByContext[NodeContext.ROP][T][];
	nodesByContextAndType<T extends keyof NodeChildrenMapByContext[NodeContext.SOP]>(context: NodeContext.SOP, node_type: T): NodeChildrenMapByContext[NodeContext.SOP][T][];
	hasNodesByContextAndType<NC extends NodeContext>(context: NC, nodeType: string): boolean;
}
type CorePathObjCallback<T extends CoreObjectType> = (obj: ObjectContent<T>) => void;
declare class ObjectsController {
	private scene;
	constructor(scene: PolyScene);
	findObjectByMask<T extends CoreObjectType>(mask: string): ObjectContent<T> | undefined;
	objectsByMask<T extends CoreObjectType>(mask: string, parent?: ObjectContent<T>): ObjectContent<T>[];
	traverseObjectsWithMask<T extends CoreObjectType>(mask: string, callback: CorePathObjCallback<T>, object: Object3D | undefined, invertMask?: boolean): void;
}
declare class ScenePerformanceMonitor {
	protected scene: PolyScene;
	private _performanceRef;
	constructor(scene: PolyScene);
	ref(): import("@vue/reactivity").Ref<number>;
	onPerformanceChange(perf: number): void;
}
type BasePathParam = TypedPathParam<any>;
declare class ReferencesController {
	protected scene: PolyScene;
	private _referenced_nodes_by_src_param_id;
	private _referencing_params_by_referenced_node_id;
	private _referencing_params_by_all_named_node_ids;
	constructor(scene: PolyScene);
	setReferenceFromParam(src_param: BasePathParam, referencedGraphNode: BaseNodeType | BaseParamType): void;
	setNamedNodesFromParam(src_param: BasePathParam): void;
	resetReferenceFromParam(src_param: BasePathParam): void;
	referencing_params(node: BaseNodeType): BasePathParam[] | undefined;
	referencingNodes(node: BaseNodeType, target: BaseNodeType[]): BaseNodeType[];
	nodesReferencedBy(node: BaseNodeType, target: BaseNodeType[]): BaseNodeType[];
	private _check_param;
	notifyNameUpdated(node: BaseNodeType): void;
	notifyParamsUpdated(node: BaseNodeType): void;
}
interface GetViewerOptions {
	camera: Camera;
	canvas?: HTMLCanvasElement;
}
declare class ViewersRegister {
	protected scene: PolyScene;
	private _viewersById;
	private _firstViewer;
	private _lastRenderedViewer;
	constructor(scene: PolyScene);
	registerViewer(viewer: BaseViewerType): void;
	unregisterViewer(viewer: BaseViewerType): void;
	traverseViewers(callback: (viewer: BaseViewerType) => void): void;
	viewer(options: GetViewerOptions): TypedViewer<Camera> | undefined;
	firstViewer(): BaseViewerType | undefined;
	markViewerAsRendered(viewer: BaseViewerType): void;
	lastRenderedViewer(): BaseViewerType | undefined;
	private _updateCache;
}
declare class SceneWebGLController {
	constructor();
	_requireWebGL2: boolean;
	requireWebGL2(): boolean;
	setRequireWebGL2(): void;
}
declare class WindowController {
	private _scene;
	private _coreGraphNode;
	constructor(_scene: PolyScene);
	graphNode(): CoreGraphNode;
	private _createGraphNode;
	private _onWindowResizeBound;
	private _onWindowResize;
	dispose(): void;
}
declare class SceneAssetsController {
	private _params_by_id;
	register_param(param: StringParam): void;
	deregister_param(param: StringParam): void;
	traverse_params(callback: (param: StringParam) => void): void;
	private _assetsRoot;
	root(): string | null;
	setRoot(url: string | null): void;
}
declare class SceneTraverserController {
	protected scene: PolyScene;
	private _spotLightsRayMarching;
	private _directionalLightsRayMarching;
	private _pointLightsRayMarching;
	private _updateUniformsFunctionByLight;
	private _uniformsByLight;
	constructor(scene: PolyScene);
	traverseScene(scene?: Scene): void;
	private _onObjectTraverseBound;
	private _onObjectTraverse;
	private _updateUniformsForLight;
	addLightsRayMarchingUniform(uniforms: IUniforms): void;
	removeLightsRayMarchingUniform(uniforms: IUniforms): void;
}
interface RegisterRendererOptions {
	assignId: boolean;
}
declare class SceneRenderersRegister {
	protected scene: PolyScene;
	private _renderersById;
	private _registerTimeByRenderer;
	private _lastRegisteredRenderer;
	private _resolves;
	constructor(scene: PolyScene);
	registerRenderer(renderer: AbstractRenderer, options?: RegisterRendererOptions): void;
	dispose(): void;
	deregisterRenderer(renderer: AbstractRenderer): void;
	lastRegisteredRenderer(): AbstractRenderer | undefined;
	renderers(target: AbstractRenderer[]): AbstractRenderer[];
	private _updateCache;
	private _flushCallbacksWithRenderer;
	waitForAbstractRenderer(): Promise<AbstractRenderer>;
	waitForRenderer(): Promise<WebGLRenderer | undefined>;
}
interface CoreWebXRControllerOptions {
	overrideReferenceSpaceType: boolean;
	referenceSpaceType?: XRReferenceSpaceType;
}
declare enum WebXRARFeature {
	HIT_TEST = "hit-test",
	LIGHT_ESTIMATION = "light-estimation"
}
interface CoreWebXRARControllerOptions extends CoreWebXRControllerOptions {
	optionalFeatures: WebXRARFeature[];
	requiredFeatures: WebXRARFeature[];
}
declare enum WebXRVRFeature {
	LOCAL_FLOOR = "local-floor",
	BOUNDED_FLOOR = "bounded-floor",
	HAND_TRACKING = "hand-tracking",
	LAYERS = "layers"
}
interface CoreWebXRVRControllerOptions extends CoreWebXRControllerOptions {
	requiredFeatures: WebXRVRFeature[];
	optionalFeatures: WebXRVRFeature[];
}
interface BaseCoreXRControllerEvent extends BaseEvent {
	controllerContainer: CoreWebXRControllerContainer;
}
declare class CoreWebXRControllerContainer extends EventDispatcher<BaseCoreXRControllerEvent> {
	readonly scene: PolyScene;
	readonly renderer: WebGLRenderer;
	readonly index: number;
	readonly ray: Ray;
	readonly controller: XRTargetRaySpace;
	constructor(scene: PolyScene, renderer: WebGLRenderer, index: number);
	initialize(camera: Camera | null): void;
}
type OnWebXRSessionStartedCallback = (session: XRSession) => Promise<void>;
declare abstract class BaseCoreWebXRController {
	protected scene: PolyScene;
	protected renderer: WebGLRenderer;
	protected camera: Camera;
	private canvas;
	protected options: CoreWebXRControllerOptions;
	protected controllerContainers: CoreWebXRControllerContainer[];
	constructor(scene: PolyScene, renderer: WebGLRenderer, camera: Camera, canvas: HTMLCanvasElement, options: CoreWebXRControllerOptions);
	getController(controllerIndex: number): CoreWebXRControllerContainer;
	mount(): void;
	unmount(): void;
	requestSession(sessionInit: XRSessionInit, callback: OnWebXRSessionStartedCallback): void;
	private _addStartEndEvents;
	private _removedStartEndEvents;
	private _createController;
	protected _addControllerEvents(controllerContainer: CoreWebXRControllerContainer, controllerIndex: number): void;
	process(frame?: XRFrame): void;
	private _onSessionStartBound;
	private _onSessionEndBound;
	protected _onSessionStart(): void;
	protected _onSessionEnd(): void;
	/**
	 *
	 * BUTTONS
	 *
	 */
	private _buttonByCanvasId;
	abstract createButton(): HTMLElement;
	private _mountButton;
	abstract attachButton(parentElement: HTMLElement, buttonElement: HTMLElement): void;
	private _unmountButton;
}
declare class CoreWebXRARController extends BaseCoreWebXRController {
	protected options: CoreWebXRARControllerOptions;
	private hitTestSource;
	private hitTestSourceRequested;
	private _hitDetected;
	private _hitMatrix;
	private _hitPosition;
	private _hitQuaternion;
	constructor(scene: PolyScene, renderer: WebGLRenderer, camera: Camera, canvas: HTMLCanvasElement, options: CoreWebXRARControllerOptions);
	createButton(): HTMLElement;
	attachButton(parentElement: HTMLElement, buttonElement: HTMLElement): void;
	requestSession(sessionInit: XRSessionInit, onSessionStarted: OnWebXRSessionStartedCallback): Promise<void | undefined>;
	private _estimatedLightController;
	private _previousSceneBackground;
	protected _onSessionStart(): void;
	protected _onSessionEnd(): void;
	hitMatrix(target: Matrix4): void;
	hitPosition(target: Vector3): void;
	hitQuaternion(target: Quaternion): void;
	hitDetected(): boolean;
	process(frame?: XRFrame): void;
	private _resolveHit;
}
declare class CoreWebXRVRController extends BaseCoreWebXRController {
	protected options: CoreWebXRVRControllerOptions;
	private _baseReferenceSpace;
	constructor(scene: PolyScene, renderer: WebGLRenderer, camera: Camera, canvas: HTMLCanvasElement, options: CoreWebXRVRControllerOptions);
	mount(): void;
	requestSession(sessionInit: XRSessionInit, onSessionStarted: OnWebXRSessionStartedCallback): Promise<void | undefined>;
	protected _onSessionStart(): void;
	protected _onSessionEnd(): void;
	baseReferenceSpace(): XRReferenceSpace | null;
	setReferenceSpace(referenceSpace: XRReferenceSpace): void;
	protected _addControllerEvents(controllerContainer: CoreWebXRControllerContainer, controllerIndex: number): void;
	createButton(): HTMLAnchorElement | HTMLButtonElement;
	attachButton(parentElement: HTMLElement, buttonElement: HTMLElement): void;
}
type ARControllerCreateFunction = (renderer: WebGLRenderer, camera: Camera, canvas: HTMLCanvasElement, options: CoreWebXRARControllerOptions) => CoreWebXRARController;
type VRControllerCreateFunction = (renderer: WebGLRenderer, camera: Camera, canvas: HTMLCanvasElement, options: CoreWebXRVRControllerOptions) => CoreWebXRVRController;
declare class SceneWebXRController {
	protected scene: PolyScene;
	constructor(scene: PolyScene);
	/**
	 *
	 * WebXR
	 *
	 */
	private _activeXRController;
	private _setActiveXRController;
	activeXRController(): BaseCoreWebXRController | null;
	/**
	 *
	 * WebXR AR
	 *
	 */
	private _ARControllerCreateFunction;
	private _activeARController;
	setARControllerCreationFunction(func: ARControllerCreateFunction): void;
	ARControllerCreateFunction(): ARControllerCreateFunction | undefined;
	setActiveARController(ARController: CoreWebXRARController | null): void;
	activeARController(): CoreWebXRARController | null;
	/**
	 *
	 * WebXR VR
	 *
	 */
	private _VRControllerCreateFunction;
	private _activeVRController;
	setVRControllerCreationFunction(func: VRControllerCreateFunction): void;
	VRControllerCreateFunction(): VRControllerCreateFunction | undefined;
	setActiveVRController(VRController: CoreWebXRVRController | null): void;
	activeVRController(): CoreWebXRVRController | null;
}
interface PolySceneCreateOptions {
	root: NodeCreateOptions;
	paramsSerializerClass?: typeof CoreParamSerializer<ParamType>;
}
type SceneBatchUpdateCallback = () => void | Promise<void>;
interface UpdateState {
	scene: Scene;
}
/**
 *
 *
 * PolyScene contains all nodes within a scene.
 *
 */
declare class PolyScene {
	/**
	 * Returns the Scene.
	 *
	 * @remarks
	 *
	 * Read more about how to use a Scene on [THREE's documentation](https://threejs.org/docs/?q=scene#api/en/scenes/Scene)
	 *
	 */
	threejsScene(): Scene;
	private _uuid;
	setUuid(uuid: string): string;
	get uuid(): string;
	private _name;
	setName(newName: string): string;
	static sanitizeName(newName: string): string;
	name(): string | undefined;
	protected _camerasController: SceneCamerasController | undefined;
	get camerasController(): SceneCamerasController;
	/**
	 * Returns the camera object that has been set as main
	 *
	 */
	mainCamera(): Promise<Camera | null>;
	private _cooker;
	get cooker(): Cooker;
	private _actorsManager;
	get actorsManager(): ActorsManager;
	private _assetsController;
	get assets(): SceneAssetsController;
	readonly cookController: SceneCookController;
	/**
	 * Returns a promise to wait for all nodes to have cooked when loading a scene.
	 *
	 */
	waitForCooksCompleted(): Promise<void>;
	private _dispatchController;
	get dispatchController(): DispatchController;
	private _eventsDispatcher;
	get eventsDispatcher(): SceneEventsDispatcher;
	private _webXRController;
	get webXR(): SceneWebXRController;
	/**
	 * When using Polygonjs viewers, a raycaster is created to use mouse events and detect if there are any object under the cursor.
	 * But if no viewer is created, such as when [importing a scene in react three fiber](/docs/integrations/react_three_fiber),
	 * It is then useful to give a raycaster.
	 *
	 */
	setRaycaster(raycaster: Raycaster): void;
	private _graph;
	get graph(): CoreGraph;
	readonly lifecycleController: SceneLifeCycleController;
	readonly loadingController: LoadingController;
	readonly missingExpressionReferencesController: MissingReferencesController;
	readonly expressionsController: SceneExpressionsController;
	readonly nodesController: NodesController;
	readonly graphNodesController: GraphNodesController;
	readonly renderersRegister: SceneRenderersRegister;
	/**
	 * Creates a new node.
	 *
	 * nodeClass can be either a string or a node class. Both examples below work:
	 *
	 * - polyScene.createNode('box'): returns a BoxSopNode
	 * - polyScene.createNode(boxSopNode): returns a BoxSopNode
	 *
	 */
	createNode<S extends keyof ObjNodeChildrenMap>(nodeClass: S, options?: NodeCreateOptions): ObjNodeChildrenMap[S];
	createNode<K extends valueof<ObjNodeChildrenMap>>(nodeClass: Constructor<K>, options?: NodeCreateOptions): K;
	/**
	 * returns all nodes with a given type
	 *
	 * - polyScene.nodesByType('box'): returns all BoxSopNodes
	 */
	nodesByType(type: string): BaseNodeType[];
	protected _objectsController: ObjectsController;
	get objectsController(): ObjectsController;
	/**
	 * returns a Object3D whose name matches the mask
	 *
	 */
	findObjectByMask<T extends CoreObjectType>(mask: string): ObjectContent<T> | undefined;
	/**
	 * returns a list Object3Ds whose names matche the mask
	 *
	 */
	objectsByMask<T extends CoreObjectType>(mask: string, parent?: ObjectContent<T>): ObjectContent<T>[];
	protected _referencesController: ReferencesController;
	get referencesController(): ReferencesController;
	protected _performance: CorePerformance | undefined;
	get performance(): CorePerformance;
	readonly perfMonitor: ScenePerformanceMonitor;
	protected _viewersRegister: ViewersRegister | undefined;
	get viewersRegister(): ViewersRegister;
	readonly sceneTraverser: SceneTraverserController;
	/**
	 * updates Polygonjs scene internals. This is called automatically when using Polygonjs viewers,
	 * but you would need to call it yourself in the render loop when adding your scene to threejs or react-three-fiber.
	 * See [https://polygonjs.com/docs/integrations](https://polygonjs.com/docs/integrations)
	 *
	 */
	update(delta: number, state?: UpdateState): void;
	readonly timeController: TimeController;
	/**
	 * sets the current frame
	 *
	 */
	setFrame(frame: number): void;
	setFrameToStart(): void;
	/**
	 * returns the current frame
	 *
	 */
	frame(): number;
	/**
	 * returns the current time
	 *
	 */
	time(): number;
	maxFrame(): number;
	/**
	 * starts playing the scene
	 *
	 */
	play(): void;
	/**
	 * pauses the scene
	 *
	 */
	pause(): void;
	/**
	 * increments the time
	 *
	 */
	incrementTime(options?: TimeControllerUpdateTimeOptions): void;
	/**
	 * increments the time if the scene is playing()
	 *
	 */
	incrementTimeIfPlaying(options?: TimeControllerUpdateTimeOptions): void;
	/**
	 * registers a renderer
	 *
	 */
	registerRenderer(renderer: WebGLRenderer, options?: RegisterRendererOptions): void;
	private _uniformsController;
	get uniformsController(): UniformsController;
	private _webglController;
	get webglController(): SceneWebGLController;
	private _windowController;
	get windowController(): WindowController;
	constructor(options?: PolySceneCreateOptions);
	private _disposed;
	dispose(): void;
	disposed(): boolean;
	private _paramSerializerClass;
	paramSerializerClass(): typeof CoreParamSerializer<ParamType> | undefined;
	/**
	 * batchUpdates can be useful to set multiple parameter values without triggering a recook for each update.
	 *
	 */
	batchUpdates(callback: SceneBatchUpdateCallback): Promise<void>;
	/**
	 * returns a node based on its path
	 *
	 * - polyScene.node('/geo1')
	 *
	 */
	node(path: string): BaseNodeType | RootManagerNode | null;
	/**
	 * returns the root node
	 *
	 */
	root(): RootManagerNode;
	/**
	 * traverse all nodes and runs a callback for each
	 *
	 */
	traverseNodes(callback: (node: BaseNodeType) => void): void;
	/**
	 * registers a BeforeTick callback. BeforeTick callbacks are run before updating the frame (and therefore before any time dependent node has changed)
	 *
	 */
	registerOnBeforeTick(callbackName: string, callback: onTimeTickHook): void;
	/**
	 * unregisters BeforeTick callback
	 *
	 */
	unRegisterOnBeforeTick(callbackName: string): void;
	/**
	 * Returns the list registered BeforeTick callback names
	 *
	 */
	registeredBeforeTickCallbacks(): Map<string, onTimeTickHook>;
	/**
	 * return true if a callback is registered with that name
	 *
	 */
	hasBeforeTickCallback(callbackName: string): boolean;
	/**
	 * registers AfterTick callback. AfterTick callbacks are run after updating the frame (and therefore after any time dependent node has changed)
	 *
	 */
	registerOnAfterTick(callbackName: string, callback: onTimeTickHook): void;
	/**
	 * unregisters AfterTick callback
	 *
	 */
	unRegisterOnAfterTick(callbackName: string): void;
	/**
	 * Returns the list registered AfterTick callback names
	 *
	 */
	registeredAfterTickCallbacks(): Map<string, onTimeTickHook>;
	/**
	 * return true if a callback is registered with that name
	 *
	 */
	hasAfterTickCallback(callbackName: string): boolean;
}
declare class AllRegister {
	private static _started;
	static registerAll(): Promise<void>;
}
interface Versions {
	polygonjs: string;
}
interface SceneJsonExporterDataProperties {
	frame: number;
	maxFrame: number;
	maxFrameLocked: boolean;
	realtimeState: boolean;
	mainCameraPath?: string | null;
	mainCameraNodePath?: string | null;
	versions?: Versions;
}
interface SceneJsonExporterData {
	properties?: SceneJsonExporterDataProperties;
	root?: NodeJsonExporterData;
	ui?: NodeJsonExporterUIData;
	shaders?: NodeJSONShadersData;
	jsFunctionBodies?: NodeJSONFunctionBodiesData;
	embeddedPolyNodes?: PolyDictionary<PolyNodeDefinition>;
}
declare class ImportReport {
	private _warnings;
	private _readonly;
	private _loadedWithoutAssemblers;
	constructor(_sceneImporter: SceneJsonImporter);
	warnings(): string[];
	readonly(): boolean;
	loadedWithoutAssemblers(): boolean;
	reset(): void;
	markAsLoadedWithoutAssemblers(): void;
	addWarning(message: string): void;
}
type ConfigureSceneCallback = (scene: PolyScene) => void;
type NodeCookWatchCallback = (scene: PolyScene) => void;
interface SerializerOptions {
	nodeSerializerClass: typeof CoreNodeSerializer;
	paramsSerializerClass: typeof CoreParamSerializer<ParamType>;
}
interface SceneJSONImporterOptions {
	sceneName?: string;
	configureScene?: ConfigureSceneCallback;
	nodeCookWatcher?: NodeCookWatchCallback;
	measurePerformanceOnLoad?: boolean;
	serializers?: SerializerOptions;
}
interface MigrateHelper {
	migrateData: (data: SceneJsonExporterData) => SceneJsonExporterData;
	migrateNodeType: (parentNode: BaseNodeType, nodeData: NodeJsonExporterData) => string;
	migrateParams: (parentNode: BaseNodeType, nodeData: NodeJsonExporterData) => void;
}
declare class SceneJsonImporter {
	private _data;
	private _options?;
	readonly report: ImportReport;
	private _base_operations_composer_nodes_with_resolve_required;
	constructor(_data: SceneJsonExporterData, _options?: SceneJSONImporterOptions | undefined);
	static loadData(data: SceneJsonExporterData, options?: SceneJSONImporterOptions): Promise<PolyScene>;
	private _migrateHelper;
	setMigrateHelper(migrateHelper: MigrateHelper): void;
	migrateHelper(): MigrateHelper | undefined;
	oldPolygonjsSceneVersion(): string | undefined;
	scene(options?: SerializerOptions): PolyScene;
	shadersData(): NodeJSONShadersData | undefined;
	jsFunctionBodiesData(): NodeJSONFunctionBodiesData | undefined;
	add_operations_composer_node_with_path_param_resolve_required(operations_composer_node: OperationsComposerSopNode): void;
	private _resolve_operation_containers_with_path_param_resolve;
}
type ManifestNodesData = PolyDictionary<string>;
type NodeJSONShadersTimestampData = PolyDictionary<PolyDictionary<string>>;
type JsFunctionBodyDataTimestampData = PolyDictionary<string>;
interface ManifestContent {
	properties: string;
	root: string;
	nodes: ManifestNodesData;
	shaders: NodeJSONShadersTimestampData;
	jsFunctionBodies: JsFunctionBodyDataTimestampData;
}
type ProgressCallback = (ratio: number) => void;
interface ImportData {
	sceneName?: string;
	urlPrefix?: string;
	manifest: ManifestContent;
	editorMode?: boolean;
	onProgress?: ProgressCallback;
}
interface SceneDataElements {
	root: NodeJsonExporterData;
	properties: SceneJsonExporterDataProperties;
	ui?: NodeJsonExporterUIData;
	shaders?: NodeJSONShadersData;
	jsFunctionBodies?: NodeJSONFunctionBodiesData;
}
declare class SceneDataManifestImporter {
	static importSceneData(importData: ImportData): Promise<SceneJsonExporterData>;
	static assemble(assembleData: SceneDataElements, manifestNodes: string[], jsonByName: PolyDictionary<object>): Promise<SceneJsonExporterData>;
	private static _insertChildData;
}
interface LoadSceneOptions {
	onProgress?: OnProgressUpdateCallback;
}
interface ImportCommonOptions extends LoadSceneOptions {
	domElement?: HTMLElement | string;
	sceneName: string;
	configureScene?: ConfigureSceneCallback;
	assetUrls?: string[];
}
interface SceneDataImportOptions extends ImportCommonOptions {
	sceneData: SceneJsonExporterData;
	autoPlay?: boolean;
	createViewer?: boolean;
	renderer?: WebGLRenderer;
	cameraMaskOverride?: string;
	serializers?: SerializerOptions;
}
interface SceneLoadReturnData {
	scene: PolyScene;
	viewer: BaseViewerType | undefined;
}
declare class ScenePlayerImporter {
	private options;
	private _scene;
	private _viewer;
	private _onLoadCompleteCalled;
	private _onCameraCreatorNodeLoadedResolve;
	private _progress;
	constructor(options: SceneDataImportOptions);
	static loadSceneData(options: SceneDataImportOptions): Promise<SceneLoadReturnData>;
	private _onLoadComplete;
	private _viewerMarkedAsReady;
	private _markViewerAsReady;
	private _sceneMarkedAsReady;
	private _markSceneAsReady;
	private _onNodesCookProgress;
	private _watchNodesProgress;
	loadScene(options?: SerializerOptions): Promise<PolyScene>;
	private _domElement;
	private _dispatchEvent;
	protected _debug(arg0: any): void;
	protected _debug2(arg0: any, arg1: any): void;
	protected static _debug(arg0: any): void;
	protected static _debug2(arg0: any, arg1: any): void;
}
declare function addStatsToViewer(viewer: BaseViewerType): {
	viewerElement: HTMLElementWithViewer<Camera>;
	stats: Stats;
	removeStatsFromViewer: () => void;
} | undefined;
declare class CoreSleep {
	static sleep(time: number): Promise<void>;
}
declare class CoreUserAgent {
	private static _isChrome;
	static isChrome(): boolean;
	private static _isSafari;
	static isSafari(): boolean;
	private static _isMobile;
	static isMobile(): boolean;
	private static _isiOS;
	static isiOS(): boolean;
	private static _isAndroid;
	static isAndroid(): boolean;
	private static _isTouchDevice;
	static isTouchDevice(): boolean;
	static isPortrait(): boolean;
	static isLandscape(): boolean;
}
declare class CoreFeaturesController {
	static urlParam(paramName: string): string | null;
	static noAssemblers(): boolean;
	static debugLoadProgress(): boolean;
	protected static _urlParams: URLSearchParams;
}
type EasingFunction = (num: number) => number;
interface EasingDictionary {
	easeI2: EasingFunction;
	easeO2: EasingFunction;
	easeIO2: EasingFunction;
	easeI3: EasingFunction;
	easeO3: EasingFunction;
	easeIO3: EasingFunction;
	easeI4: EasingFunction;
	easeO4: EasingFunction;
	easeIO4: EasingFunction;
	easeSinI: EasingFunction;
	easeSinO: EasingFunction;
	easeSinIO: EasingFunction;
	easeElasticI: EasingFunction;
	easeElasticO: EasingFunction;
	easeElasticIO: EasingFunction;
}
// @ts-ignore
declare const radToDeg: typeof MathUtils.radToDeg;
// @ts-ignore
declare function clamp(val: number, min: number, max: number): number;
// @ts-ignore
declare function fit(val: number, srcMin: number, srcMax: number, destMin: number, destMax: number): number;
declare function fit01(val: number, destMin: number, destMax: number): number;
declare function fitClamp(val: number, srcMin: number, srcMax: number, destMin: number, destMax: number): number;
declare function mix(num0: number, num1: number, blend: number): number;
declare function randFloat(x: number, y?: number): number;
declare function randVec2(uv: Vector2Like): number;
declare function rand(number: number | Vector2Like): number;
declare function round(number: number, stepSize: number): number;
declare function highestEven(number: number): number;
declare function nearestPower2(num: number): number;
declare function pow2Inverse(num: number): number;
declare function lerpFloat(current: number, target: number, blend: number): number;
declare class CoreMath {
	static Easing: EasingDictionary;
// @ts-ignore
	static degToRad: typeof MathUtils.degToRad;
// @ts-ignore
	static radToDeg: typeof MathUtils.radToDeg;
	static clamp: typeof clamp;
// @ts-ignore
	static smoothstep: typeof MathUtils.smoothstep;
// @ts-ignore
	static smootherstep: typeof MathUtils.smootherstep;
	static fit01: typeof fit01;
	static fit: typeof fit;
	static fitClamp: typeof fitClamp;
	static mix: typeof mix;
	static fract: (number: number) => number;
	static rand: typeof rand;
	static round: typeof round;
	static highestEven: typeof highestEven;
	static nearestPower2: typeof nearestPower2;
	static pow2Inverse: typeof pow2Inverse;
	static randFloat: typeof randFloat;
	static randVec2: typeof randVec2;
	static lerpFloat: typeof lerpFloat;
}
declare function sanitizeName(word: string): string;
declare function getOrCreateObjectAttributeRef<T extends ParamConvertibleJsType>(object3D: ObjectXD, attribName: string, type: T, defaultAttribValue?: JsIConnectionPointTypeToDataTypeMap[T]): AttribRefs<T>;
declare class ConsoleLogger extends BaseCoreLogger {
	log(message?: any, ...optionalParams: any[]): void;
	warn(...args: any): void;
	error(...args: any): void;
}
declare function logBlue(message: string): void;
declare function logRedBg(message: string): void;
declare function logGreenBg(message: string): void;
declare function logBlueBg(message: string): void;
interface LogStyle {
	backgroundColor?: string;
	color?: string;
	fontWeight?: string;
	padding?: {
		x?: number;
		y?: number;
	};
}
declare function logStyled(message: string, style: LogStyle): void;


