(self["webpackChunk"] = self["webpackChunk"] || []).push([["src_engine_examples_examples_actor_TrackHand_physics_ts"],{

/***/ 99298:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "createData": function() { return /* binding */ createData; }
/* harmony export */ });
/* harmony import */ var _polygonjs_polygonjs_src_engine_poly_ParamType__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(51254);
/* harmony import */ var _polygonjs_polygonjs_src_core_geometry_Constant__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(91568);



function createData(options) {
  const { scene } = options;
  const root = scene.root();
  const scene_root_nodes = {};
  function create_perspectiveCamera1(parentNode) {
    var perspectiveCamera1 = parentNode.createNode("perspectiveCamera");
    perspectiveCamera1.setName("perspectiveCamera1");
    const perspectiveCamera1_nodes = {};
    function create_events1(perspectiveCamera12) {
      var events1 = perspectiveCamera12.createNode("eventsNetwork");
      events1.setName("events1");
      const events1_nodes = {};
      function create_cameraOrbitControls1(events12) {
        var cameraOrbitControls1 = events12.createNode("cameraOrbitControls");
        cameraOrbitControls1.setName("cameraOrbitControls1");
        const cameraOrbitControls1_nodes = {};
        cameraOrbitControls1.uiData.setPosition(150, 50);
        cameraOrbitControls1.p.target.set([0.3940237778180687, -0.018896052196665545, 0.07792116079456717]);
        cameraOrbitControls1.params.postCreateSpareParams();
        cameraOrbitControls1.params.runOnSceneLoadHooks();
        return { node: cameraOrbitControls1, children: cameraOrbitControls1_nodes };
      }
      events1_nodes["cameraOrbitControls1"] = create_cameraOrbitControls1(events1);
      if (events1.childrenController) {
        events1.childrenController.selection.set([]);
      }
      events1.uiData.setPosition(-200, 50);
      events1.params.postCreateSpareParams();
      events1.params.runOnSceneLoadHooks();
      return { node: events1, children: events1_nodes };
    }
    perspectiveCamera1_nodes["events1"] = create_events1(perspectiveCamera1);
    if (perspectiveCamera1.childrenController) {
      perspectiveCamera1.childrenController.selection.set([]);
    }
    perspectiveCamera1.uiData.setPosition(-50, 100);
    perspectiveCamera1.flags.display.set(true);
    perspectiveCamera1.p.t.set([0.13040892366175796, 0.4619705707555538, 13.616317477547202]);
    perspectiveCamera1.p.r.set([-2.9112006903440437, -0.3200291081450162, -0.016274613495027422]);
    perspectiveCamera1.p.controls.set("./events1/cameraOrbitControls1");
    perspectiveCamera1.params.postCreateSpareParams();
    perspectiveCamera1.params.runOnSceneLoadHooks();
    return { node: perspectiveCamera1, children: perspectiveCamera1_nodes };
  }
  function create_lights(parentNode) {
    var lights = parentNode.createNode("geo");
    lights.setName("lights");
    const lights_nodes = {};
    function create_areaLight1(lights2) {
      var areaLight1 = lights2.createNode("areaLight");
      areaLight1.setName("areaLight1");
      const areaLight1_nodes = {};
      areaLight1.uiData.setPosition(50, -50);
      areaLight1.p.width.set(10);
      areaLight1.p.height.set(10);
      areaLight1.p.showHelper.set(true);
      areaLight1.params.postCreateSpareParams();
      areaLight1.params.runOnSceneLoadHooks();
      return { node: areaLight1, children: areaLight1_nodes };
    }
    function create_hemisphereLight1(lights2) {
      var hemisphereLight1 = lights2.createNode("hemisphereLight");
      hemisphereLight1.setName("hemisphereLight1");
      const hemisphereLight1_nodes = {};
      hemisphereLight1.uiData.setPosition(-200, 50);
      hemisphereLight1.params.postCreateSpareParams();
      hemisphereLight1.params.runOnSceneLoadHooks();
      return { node: hemisphereLight1, children: hemisphereLight1_nodes };
    }
    function create_merge1(lights2) {
      var merge1 = lights2.createNode("merge");
      merge1.setName("merge1");
      const merge1_nodes = {};
      merge1.uiData.setPosition(-50, 300);
      merge1.flags.display.set(true);
      merge1.params.postCreateSpareParams();
      merge1.params.runOnSceneLoadHooks();
      return { node: merge1, children: merge1_nodes };
    }
    function create_polarTransform1(lights2) {
      var polarTransform1 = lights2.createNode("polarTransform");
      polarTransform1.setName("polarTransform1");
      const polarTransform1_nodes = {};
      polarTransform1.uiData.setPosition(50, 150);
      polarTransform1.p.latitude.set(-90);
      polarTransform1.p.depth.set(4.6);
      polarTransform1.params.postCreateSpareParams();
      polarTransform1.params.runOnSceneLoadHooks();
      return { node: polarTransform1, children: polarTransform1_nodes };
    }
    lights_nodes["areaLight1"] = create_areaLight1(lights);
    lights_nodes["hemisphereLight1"] = create_hemisphereLight1(lights);
    lights_nodes["merge1"] = create_merge1(lights);
    lights_nodes["polarTransform1"] = create_polarTransform1(lights);
    lights_nodes["merge1"].node.setInput(0, lights_nodes["hemisphereLight1"].node);
    lights_nodes["merge1"].node.setInput(1, lights_nodes["polarTransform1"].node);
    lights_nodes["polarTransform1"].node.setInput(0, lights_nodes["areaLight1"].node);
    if (lights.childrenController) {
      lights.childrenController.selection.set([lights_nodes["merge1"].node]);
    }
    lights.uiData.setPosition(-50, -50);
    lights.flags.display.set(true);
    lights.p.CSGWireframe.options.setOption("editable", void 0);
    lights.p.TetScale.options.setOption("editable", void 0);
    lights.p.TetDisplayLines.options.setOption("editable", void 0);
    lights.p.TetDisplaySharedFaces.options.setOption("editable", void 0);
    lights.p.TetDisplayPoints.options.setOption("editable", void 0);
    lights.p.TetDisplayCenter.options.setOption("editable", void 0);
    lights.p.TetDisplaySphere.options.setOption("editable", void 0);
    lights.params.postCreateSpareParams();
    lights.params.runOnSceneLoadHooks();
    return { node: lights, children: lights_nodes };
  }
  function create_webcam(parentNode) {
    var webcam = parentNode.createNode("geo");
    webcam.setName("webcam");
    const webcam_nodes = {};
    function create_COP(webcam2) {
      var COP = webcam2.createNode("copNetwork");
      COP.setName("COP");
      const COP_nodes = {};
      function create_webCam1(COP2) {
        var webCam1 = COP2.createNode("webCam");
        webCam1.setName("webCam1");
        const webCam1_nodes = {};
        webCam1.uiData.setPosition(-200, 150);
        webCam1.p.tflipY.set(true);
        webCam1.p.flipY.set(true);
        webCam1.params.postCreateSpareParams();
        webCam1.params.runOnSceneLoadHooks();
        return { node: webCam1, children: webCam1_nodes };
      }
      COP_nodes["webCam1"] = create_webCam1(COP);
      if (COP.childrenController) {
        COP.childrenController.selection.set([]);
      }
      COP.uiData.setPosition(-200, 500);
      COP.params.postCreateSpareParams();
      COP.params.runOnSceneLoadHooks();
      return { node: COP, children: COP_nodes };
    }
    function create_MAT(webcam2) {
      var MAT = webcam2.createNode("materialsNetwork");
      MAT.setName("MAT");
      const MAT_nodes = {};
      function create_meshBasic1(MAT2) {
        var meshBasic1 = MAT2.createNode("meshBasic");
        meshBasic1.setName("meshBasic1");
        const meshBasic1_nodes = {};
        meshBasic1.uiData.setPosition(-100, 50);
        meshBasic1.p.useMap.set(true);
        meshBasic1.p.map.set("../../COP/webCam1");
        meshBasic1.p.front.set(false);
        meshBasic1.params.postCreateSpareParams();
        meshBasic1.params.runOnSceneLoadHooks();
        return { node: meshBasic1, children: meshBasic1_nodes };
      }
      MAT_nodes["meshBasic1"] = create_meshBasic1(MAT);
      if (MAT.childrenController) {
        MAT.childrenController.selection.set([]);
      }
      MAT.uiData.setPosition(-200, 350);
      MAT.params.postCreateSpareParams();
      MAT.params.runOnSceneLoadHooks();
      return { node: MAT, children: MAT_nodes };
    }
    function create_actor1(webcam2) {
      var actor1 = webcam2.createNode("actor");
      actor1.setName("actor1");
      const actor1_nodes = {};
      function create_getParam1(actor12) {
        var getParam1 = actor12.createNode("getParam");
        getParam1.setName("getParam1");
        const getParam1_nodes = {};
        getParam1.uiData.setPosition(400, 0);
        getParam1.p.Param.set("/physics/physicsWorld1/updatedGravity");
        getParam1.params.postCreateSpareParams();
        getParam1.params.runOnSceneLoadHooks();
        return { node: getParam1, children: getParam1_nodes };
      }
      function create_getTexture1(actor12) {
        var getTexture1 = actor12.createNode("getTexture");
        getTexture1.setName("getTexture1");
        const getTexture1_nodes = {};
        getTexture1.uiData.setComment(
          "here we get the [webcam](../../COP/webCam1) to be analyzed by the next node"
        );
        getTexture1.uiData.setPosition(-250, 250);
        getTexture1.p.node.set("../../COP/webCam1");
        getTexture1.params.postCreateSpareParams();
        getTexture1.params.runOnSceneLoadHooks();
        return { node: getTexture1, children: getTexture1_nodes };
      }
      function create_getTrackedHandProperty1(actor12) {
        var getTrackedHandProperty1 = actor12.createNode("getTrackedHandProperty");
        getTrackedHandProperty1.setName("getTrackedHandProperty1");
        const getTrackedHandProperty1_nodes = {};
        getTrackedHandProperty1.uiData.setComment(
          "this node's output is what will drive the simulation gravity"
        );
        getTrackedHandProperty1.uiData.setPosition(350, 200);
        getTrackedHandProperty1.params.postCreateSpareParams();
        getTrackedHandProperty1.params.runOnSceneLoadHooks();
        return { node: getTrackedHandProperty1, children: getTrackedHandProperty1_nodes };
      }
      function create_multScalar1(actor12) {
        var multScalar1 = actor12.createNode("multScalar");
        multScalar1.setName("multScalar1");
        const multScalar1_nodes = {};
        multScalar1.uiData.setPosition(550, 200);
        multScalar1.addParam(_polygonjs_polygonjs_src_engine_poly_ParamType__WEBPACK_IMPORTED_MODULE_0__/* .ParamType.VECTOR3 */ ._.VECTOR3, "value", [1, 1, 1], { spare: true, editable: false });
        multScalar1.addParam(_polygonjs_polygonjs_src_engine_poly_ParamType__WEBPACK_IMPORTED_MODULE_0__/* .ParamType.FLOAT */ ._.FLOAT, "mult", 1, { spare: true, editable: true });
        multScalar1.params.get("mult").set(10);
        multScalar1.params.postCreateSpareParams();
        multScalar1.params.runOnSceneLoadHooks();
        return { node: multScalar1, children: multScalar1_nodes };
      }
      function create_onTick1(actor12) {
        var onTick1 = actor12.createNode("onTick");
        onTick1.setName("onTick1");
        const onTick1_nodes = {};
        onTick1.uiData.setPosition(-200, -100);
        onTick1.params.postCreateSpareParams();
        onTick1.params.runOnSceneLoadHooks();
        return { node: onTick1, children: onTick1_nodes };
      }
      function create_setParam1(actor12) {
        var setParam1 = actor12.createNode("setParam");
        setParam1.setName("setParam1");
        const setParam1_nodes = {};
        setParam1.uiData.setComment(
          "this will change the [constant](/physics/physicsWorld1/constant1) value, which affects the gravity."
        );
        setParam1.uiData.setPosition(700, -100);
        setParam1.p.type.set(6);
        setParam1.addParam(_polygonjs_polygonjs_src_engine_poly_ParamType__WEBPACK_IMPORTED_MODULE_0__/* .ParamType.PARAM_PATH */ ._.PARAM_PATH, "Param", "/physics/physicsWorld1/constant1/vector3", {
          spare: true,
          editable: false
        });
        setParam1.addParam(_polygonjs_polygonjs_src_engine_poly_ParamType__WEBPACK_IMPORTED_MODULE_0__/* .ParamType.FLOAT */ ._.FLOAT, "lerp", 1, { spare: true, editable: true });
        setParam1.addParam(_polygonjs_polygonjs_src_engine_poly_ParamType__WEBPACK_IMPORTED_MODULE_0__/* .ParamType.VECTOR3 */ ._.VECTOR3, "val", [0, 0, 0], { spare: true, editable: false });
        setParam1.params.postCreateSpareParams();
        setParam1.params.runOnSceneLoadHooks();
        return { node: setParam1, children: setParam1_nodes };
      }
      function create_trackHand1(actor12) {
        var trackHand1 = actor12.createNode("trackHand");
        trackHand1.setName("trackHand1");
        const trackHand1_nodes = {};
        trackHand1.uiData.setComment(
          "this node performs the main work of the computer vision analysis. It will extract landmarks from the hand, which can then be fed for further analysis in the next node."
        );
        trackHand1.uiData.setPosition(50, 200);
        trackHand1.params.postCreateSpareParams();
        trackHand1.params.runOnSceneLoadHooks();
        return { node: trackHand1, children: trackHand1_nodes };
      }
      actor1_nodes["getParam1"] = create_getParam1(actor1);
      actor1_nodes["getTexture1"] = create_getTexture1(actor1);
      actor1_nodes["getTrackedHandProperty1"] = create_getTrackedHandProperty1(actor1);
      actor1_nodes["multScalar1"] = create_multScalar1(actor1);
      actor1_nodes["onTick1"] = create_onTick1(actor1);
      actor1_nodes["setParam1"] = create_setParam1(actor1);
      actor1_nodes["trackHand1"] = create_trackHand1(actor1);
      actor1_nodes["getTrackedHandProperty1"].node.setInput(
        "Vector4[]",
        actor1_nodes["trackHand1"].node,
        "normalizedLandmarks"
      );
      actor1_nodes["multScalar1"].node.setInput(
        "value",
        actor1_nodes["getTrackedHandProperty1"].node,
        "indexDirection"
      );
      actor1_nodes["setParam1"].node.setInput("trigger", actor1_nodes["onTick1"].node, "trigger");
      actor1_nodes["setParam1"].node.setInput("Param", actor1_nodes["getParam1"].node, "Param");
      actor1_nodes["setParam1"].node.setInput("val", actor1_nodes["multScalar1"].node, "val");
      actor1_nodes["trackHand1"].node.setInput("trigger", actor1_nodes["onTick1"].node, "trigger");
      actor1_nodes["trackHand1"].node.setInput("Texture", actor1_nodes["getTexture1"].node, "Texture");
      if (actor1.childrenController) {
        actor1.childrenController.selection.set([]);
      }
      actor1.uiData.setComment(
        "This is where the main work of the computer vision happens. [Dive inside](.) to see how it is set up."
      );
      actor1.uiData.setPosition(350, 350);
      actor1.params.postCreateSpareParams();
      actor1.params.runOnSceneLoadHooks();
      return { node: actor1, children: actor1_nodes };
    }
    function create_emptyObject1(webcam2) {
      var emptyObject1 = webcam2.createNode("emptyObject");
      emptyObject1.setName("emptyObject1");
      const emptyObject1_nodes = {};
      emptyObject1.uiData.setPosition(350, 0);
      emptyObject1.params.postCreateSpareParams();
      emptyObject1.params.runOnSceneLoadHooks();
      return { node: emptyObject1, children: emptyObject1_nodes };
    }
    function create_material1(webcam2) {
      var material1 = webcam2.createNode("material");
      material1.setName("material1");
      const material1_nodes = {};
      material1.uiData.setComment(
        "this is a simple plane, on which we assign a material which shows the [webcam](../COP/webCam1)"
      );
      material1.uiData.setPosition(0, 350);
      material1.p.material.set("../MAT/meshBasic1");
      material1.params.postCreateSpareParams();
      material1.params.runOnSceneLoadHooks();
      return { node: material1, children: material1_nodes };
    }
    function create_merge1(webcam2) {
      var merge1 = webcam2.createNode("merge");
      merge1.setName("merge1");
      const merge1_nodes = {};
      merge1.uiData.setPosition(150, 650);
      merge1.flags.display.set(true);
      merge1.params.postCreateSpareParams();
      merge1.params.runOnSceneLoadHooks();
      return { node: merge1, children: merge1_nodes };
    }
    function create_plane1(webcam2) {
      var plane1 = webcam2.createNode("plane");
      plane1.setName("plane1");
      const plane1_nodes = {};
      plane1.uiData.setPosition(0, 0);
      plane1.p.direction.set([0, 0, 1]);
      plane1.params.postCreateSpareParams();
      plane1.params.runOnSceneLoadHooks();
      return { node: plane1, children: plane1_nodes };
    }
    function create_trackingLandmarksHandAttributes1(webcam2) {
      var trackingLandmarksHandAttributes1 = webcam2.createNode("trackingLandmarksHandAttributes");
      trackingLandmarksHandAttributes1.setName("trackingLandmarksHandAttributes1");
      const trackingLandmarksHandAttributes1_nodes = {};
      trackingLandmarksHandAttributes1.uiData.setPosition(350, 150);
      trackingLandmarksHandAttributes1.p.selfieMode.set(true);
      trackingLandmarksHandAttributes1.params.postCreateSpareParams();
      trackingLandmarksHandAttributes1.params.runOnSceneLoadHooks();
      return { node: trackingLandmarksHandAttributes1, children: trackingLandmarksHandAttributes1_nodes };
    }
    function create_transform1(webcam2) {
      var transform1 = webcam2.createNode("transform");
      transform1.setName("transform1");
      const transform1_nodes = {};
      transform1.uiData.setPosition(0, 200);
      transform1.p.t.set([0, 0, -4.306446049472191]);
      transform1.p.r.set([0, 180, 0]);
      transform1.p.scale.set(9.100000000000001);
      transform1.params.postCreateSpareParams();
      transform1.params.runOnSceneLoadHooks();
      return { node: transform1, children: transform1_nodes };
    }
    webcam_nodes["COP"] = create_COP(webcam);
    webcam_nodes["MAT"] = create_MAT(webcam);
    webcam_nodes["actor1"] = create_actor1(webcam);
    webcam_nodes["emptyObject1"] = create_emptyObject1(webcam);
    webcam_nodes["material1"] = create_material1(webcam);
    webcam_nodes["merge1"] = create_merge1(webcam);
    webcam_nodes["plane1"] = create_plane1(webcam);
    webcam_nodes["trackingLandmarksHandAttributes1"] = create_trackingLandmarksHandAttributes1(webcam);
    webcam_nodes["transform1"] = create_transform1(webcam);
    webcam_nodes["actor1"].node.setInput(0, webcam_nodes["trackingLandmarksHandAttributes1"].node);
    webcam_nodes["material1"].node.setInput(0, webcam_nodes["transform1"].node);
    webcam_nodes["merge1"].node.setInput(0, webcam_nodes["material1"].node);
    webcam_nodes["merge1"].node.setInput(1, webcam_nodes["actor1"].node);
    webcam_nodes["trackingLandmarksHandAttributes1"].node.setInput(0, webcam_nodes["emptyObject1"].node);
    webcam_nodes["transform1"].node.setInput(0, webcam_nodes["plane1"].node);
    if (webcam.childrenController) {
      webcam.childrenController.selection.set([]);
    }
    webcam.uiData.setComment("Dive inside [this node](.) to see how the computer vision is set up");
    webcam.uiData.setPosition(-50, -350);
    webcam.flags.display.set(true);
    webcam.params.postCreateSpareParams();
    webcam.params.runOnSceneLoadHooks();
    return { node: webcam, children: webcam_nodes };
  }
  function create_physics(parentNode) {
    var physics = parentNode.createNode("geo");
    physics.setName("physics");
    const physics_nodes = {};
    function create_copy1(physics2) {
      var copy1 = physics2.createNode("copy");
      copy1.setName("copy1");
      const copy1_nodes = {};
      copy1.uiData.setComment("this copies the 1st input (the sphere) onto the points of the 2nd input");
      copy1.uiData.setPosition(-100, -250);
      copy1.params.postCreateSpareParams();
      copy1.params.runOnSceneLoadHooks();
      return { node: copy1, children: copy1_nodes };
    }
    function create_copy3(physics2) {
      var copy3 = physics2.createNode("copy");
      copy3.setName("copy3");
      const copy3_nodes = {};
      copy3.uiData.setPosition(-900, 800);
      copy3.p.count.set(4);
      copy3.p.r.set([0, 0, 90]);
      copy3.params.postCreateSpareParams();
      copy3.params.runOnSceneLoadHooks();
      return { node: copy3, children: copy3_nodes };
    }
    function create_copy4(physics2) {
      var copy4 = physics2.createNode("copy");
      copy4.setName("copy4");
      const copy4_nodes = {};
      copy4.uiData.setPosition(200, -600);
      copy4.p.count.set(4);
      copy4.p.t.set([0, 1, 0]);
      copy4.params.postCreateSpareParams();
      copy4.params.runOnSceneLoadHooks();
      return { node: copy4, children: copy4_nodes };
    }
    function create_hexagons1(physics2) {
      var hexagons1 = physics2.createNode("hexagons");
      hexagons1.setName("hexagons1");
      const hexagons1_nodes = {};
      hexagons1.uiData.setPosition(200, -750);
      hexagons1.p.size.set([6, 6]);
      hexagons1.p.hexagonRadius.set(1);
      hexagons1.p.pointsOnly.set(true);
      hexagons1.params.postCreateSpareParams();
      hexagons1.params.runOnSceneLoadHooks();
      return { node: hexagons1, children: hexagons1_nodes };
    }
    function create_jitter1(physics2) {
      var jitter1 = physics2.createNode("jitter");
      jitter1.setName("jitter1");
      const jitter1_nodes = {};
      jitter1.uiData.setComment("those nodes above create points on which we will copy spheres");
      jitter1.uiData.setPosition(200, -350);
      jitter1.p.amount.set(0.18);
      jitter1.params.postCreateSpareParams();
      jitter1.params.runOnSceneLoadHooks();
      return { node: jitter1, children: jitter1_nodes };
    }
    function create_merge1(physics2) {
      var merge1 = physics2.createNode("merge");
      merge1.setName("merge1");
      const merge1_nodes = {};
      merge1.uiData.setPosition(-100, 1500);
      merge1.params.postCreateSpareParams();
      merge1.params.runOnSceneLoadHooks();
      return { node: merge1, children: merge1_nodes };
    }
    function create_merge2(physics2) {
      var merge2 = physics2.createNode("merge");
      merge2.setName("merge2");
      const merge2_nodes = {};
      merge2.uiData.setComment(
        "This creates the colliders on the walls, as well as floor and ceiling. We simply start with the `physicsGround` node and rotate it. We also set the `visibility` of the front and back wall to `OFF` so that we can see through, and so that we can see the web cam. "
      );
      merge2.uiData.setPosition(-900, 1200);
      merge2.params.postCreateSpareParams();
      merge2.params.runOnSceneLoadHooks();
      return { node: merge2, children: merge2_nodes };
    }
    function create_merge3(physics2) {
      var merge3 = physics2.createNode("merge");
      merge3.setName("merge3");
      const merge3_nodes = {};
      merge3.uiData.setPosition(200, -450);
      merge3.p.compact.set(true);
      merge3.params.postCreateSpareParams();
      merge3.params.runOnSceneLoadHooks();
      return { node: merge3, children: merge3_nodes };
    }
    function create_merge4(physics2) {
      var merge4 = physics2.createNode("merge");
      merge4.setName("merge4");
      const merge4_nodes = {};
      merge4.uiData.setPosition(-600, 950);
      merge4.params.postCreateSpareParams();
      merge4.params.runOnSceneLoadHooks();
      return { node: merge4, children: merge4_nodes };
    }
    function create_objectProperties1(physics2) {
      var objectProperties1 = physics2.createNode("objectProperties");
      objectProperties1.setName("objectProperties1");
      const objectProperties1_nodes = {};
      objectProperties1.uiData.setPosition(-600, 1050);
      objectProperties1.p.tvisible.set(true);
      objectProperties1.p.visible.set(false);
      objectProperties1.params.postCreateSpareParams();
      objectProperties1.params.runOnSceneLoadHooks();
      return { node: objectProperties1, children: objectProperties1_nodes };
    }
    function create_physicsGround1(physics2) {
      var physicsGround1 = physics2.createNode("physicsGround");
      physicsGround1.setName("physicsGround1");
      const physicsGround1_nodes = {};
      physicsGround1.uiData.setPosition(-900, 550);
      physicsGround1.params.postCreateSpareParams();
      physicsGround1.params.runOnSceneLoadHooks();
      return { node: physicsGround1, children: physicsGround1_nodes };
    }
    function create_physicsRBDAttributes1(physics2) {
      var physicsRBDAttributes1 = physics2.createNode("physicsRBDAttributes");
      physicsRBDAttributes1.setName("physicsRBDAttributes1");
      const physicsRBDAttributes1_nodes = {};
      physicsRBDAttributes1.uiData.setComment("this adds attributes on the spheres for the physics simulation");
      physicsRBDAttributes1.uiData.setPosition(-100, 350);
      physicsRBDAttributes1.p.colliderType.set(1);
      physicsRBDAttributes1.p.radius.set('ch("../sphere1/radius")');
      physicsRBDAttributes1.params.postCreateSpareParams();
      physicsRBDAttributes1.params.runOnSceneLoadHooks();
      return { node: physicsRBDAttributes1, children: physicsRBDAttributes1_nodes };
    }
    function create_physicsWorld1(physics2) {
      var physicsWorld1 = physics2.createNode("physicsWorld");
      physicsWorld1.setName("physicsWorld1");
      const physicsWorld1_nodes = {};
      function create_onScenePause1(physicsWorld12) {
        var onScenePause1 = physicsWorld12.createNode("onScenePause");
        onScenePause1.setName("onScenePause1");
        const onScenePause1_nodes = {};
        onScenePause1.uiData.setPosition(-100, -100);
        onScenePause1.params.postCreateSpareParams();
        onScenePause1.params.runOnSceneLoadHooks();
        return { node: onScenePause1, children: onScenePause1_nodes };
      }
      function create_onTick1(physicsWorld12) {
        var onTick1 = physicsWorld12.createNode("onTick");
        onTick1.setName("onTick1");
        const onTick1_nodes = {};
        onTick1.uiData.setPosition(-100, 100);
        onTick1.params.postCreateSpareParams();
        onTick1.params.runOnSceneLoadHooks();
        return { node: onTick1, children: onTick1_nodes };
      }
      function create_param_GRAVITY(physicsWorld12) {
        var param_GRAVITY = physicsWorld12.createNode("param");
        param_GRAVITY.setName("param_GRAVITY");
        const param_GRAVITY_nodes = {};
        param_GRAVITY.uiData.setPosition(-150, 500);
        param_GRAVITY.p.name.set("updatedGravity");
        param_GRAVITY.p.type.set(6);
        param_GRAVITY.params.postCreateSpareParams();
        param_GRAVITY.params.runOnSceneLoadHooks();
        return { node: param_GRAVITY, children: param_GRAVITY_nodes };
      }
      function create_physicsWorldReset1(physicsWorld12) {
        var physicsWorldReset1 = physicsWorld12.createNode("physicsWorldReset");
        physicsWorldReset1.setName("physicsWorldReset1");
        const physicsWorldReset1_nodes = {};
        physicsWorldReset1.uiData.setPosition(100, -100);
        physicsWorldReset1.params.postCreateSpareParams();
        physicsWorldReset1.params.runOnSceneLoadHooks();
        return { node: physicsWorldReset1, children: physicsWorldReset1_nodes };
      }
      function create_physicsWorldStepSimulation1(physicsWorld12) {
        var physicsWorldStepSimulation1 = physicsWorld12.createNode("physicsWorldStepSimulation");
        physicsWorldStepSimulation1.setName("physicsWorldStepSimulation1");
        const physicsWorldStepSimulation1_nodes = {};
        physicsWorldStepSimulation1.uiData.setPosition(100, 100);
        physicsWorldStepSimulation1.params.postCreateSpareParams();
        physicsWorldStepSimulation1.params.runOnSceneLoadHooks();
        return { node: physicsWorldStepSimulation1, children: physicsWorldStepSimulation1_nodes };
      }
      function create_setPhysicsWorldGravity1(physicsWorld12) {
        var setPhysicsWorldGravity1 = physicsWorld12.createNode("setPhysicsWorldGravity");
        setPhysicsWorldGravity1.setName("setPhysicsWorldGravity1");
        const setPhysicsWorldGravity1_nodes = {};
        setPhysicsWorldGravity1.uiData.setPosition(100, 400);
        setPhysicsWorldGravity1.params.postCreateSpareParams();
        setPhysicsWorldGravity1.params.runOnSceneLoadHooks();
        return { node: setPhysicsWorldGravity1, children: setPhysicsWorldGravity1_nodes };
      }
      physicsWorld1_nodes["onScenePause1"] = create_onScenePause1(physicsWorld1);
      physicsWorld1_nodes["onTick1"] = create_onTick1(physicsWorld1);
      physicsWorld1_nodes["param_GRAVITY"] = create_param_GRAVITY(physicsWorld1);
      physicsWorld1_nodes["physicsWorldReset1"] = create_physicsWorldReset1(physicsWorld1);
      physicsWorld1_nodes["physicsWorldStepSimulation1"] = create_physicsWorldStepSimulation1(physicsWorld1);
      physicsWorld1_nodes["setPhysicsWorldGravity1"] = create_setPhysicsWorldGravity1(physicsWorld1);
      physicsWorld1_nodes["physicsWorldReset1"].node.setInput(
        "trigger",
        physicsWorld1_nodes["onScenePause1"].node,
        "trigger"
      );
      physicsWorld1_nodes["physicsWorldStepSimulation1"].node.setInput(
        "trigger",
        physicsWorld1_nodes["onTick1"].node,
        "trigger"
      );
      physicsWorld1_nodes["setPhysicsWorldGravity1"].node.setInput(
        "trigger",
        physicsWorld1_nodes["onTick1"].node,
        "trigger"
      );
      physicsWorld1_nodes["setPhysicsWorldGravity1"].node.setInput(
        "gravity",
        physicsWorld1_nodes["param_GRAVITY"].node,
        "val"
      );
      if (physicsWorld1.childrenController) {
        physicsWorld1.childrenController.selection.set([]);
      }
      physicsWorld1.uiData.setComment(
        "we merge all rigid bodies together, and the `physicsWorld` node will compute the simulation when the scene plays.\n\nIf you [dive inside](.), you can see how the gravity is updated every frame by the [setPhysicsWorldGravity1](./setPhysicsWorldGravity1) node, which in turn is controlled by a [constant node](./constant1). The value of that constant is then controlled by the result of the [computer vision](/webcam/actor1/getTrackedHandProperty1), which looks at the angle of the index finger."
      );
      physicsWorld1.uiData.setPosition(-100, 1700);
      physicsWorld1.flags.display.set(true);
      physicsWorld1.p.gravity.options.setOption("editable", void 0);
      physicsWorld1.addParam(_polygonjs_polygonjs_src_engine_poly_ParamType__WEBPACK_IMPORTED_MODULE_0__/* .ParamType.VECTOR3 */ ._.VECTOR3, "updatedGravity", [0, 0, 0], {
        spare: true,
        computeOnDirty: true,
        cook: false
      });
      physicsWorld1.params.get("updatedGravity").set([-8.994049545832986, 2.5777165801717343, -3.5302195398316494]);
      physicsWorld1.params.get("updatedGravity").options.setOption("editable", void 0);
      physicsWorld1.params.get("updatedGravityx").options.setOption("editable", void 0);
      physicsWorld1.params.get("updatedGravityy").options.setOption("editable", void 0);
      physicsWorld1.params.get("updatedGravityz").options.setOption("editable", void 0);
      physicsWorld1.params.postCreateSpareParams();
      physicsWorld1.params.runOnSceneLoadHooks();
      return { node: physicsWorld1, children: physicsWorld1_nodes };
    }
    function create_sphere1(physics2) {
      var sphere1 = physics2.createNode("sphere");
      sphere1.setName("sphere1");
      const sphere1_nodes = {};
      sphere1.uiData.setPosition(-200, -500);
      sphere1.p.radius.set(0.36);
      sphere1.params.postCreateSpareParams();
      sphere1.params.runOnSceneLoadHooks();
      return { node: sphere1, children: sphere1_nodes };
    }
    function create_subnet_color(physics2) {
      var subnet_color = physics2.createNode("subnet");
      subnet_color.setName("subnet_color");
      const subnet_color_nodes = {};
      function create_MAT(subnet_color2) {
        var MAT = subnet_color2.createNode("materialsNetwork");
        MAT.setName("MAT");
        const MAT_nodes = {};
        function create_meshStandard1(MAT2) {
          var meshStandard1 = MAT2.createNode("meshStandard");
          meshStandard1.setName("meshStandard1");
          const meshStandard1_nodes = {};
          meshStandard1.uiData.setPosition(0, 0);
          meshStandard1.p.useVertexColors.set(true);
          meshStandard1.params.postCreateSpareParams();
          meshStandard1.params.runOnSceneLoadHooks();
          return { node: meshStandard1, children: meshStandard1_nodes };
        }
        MAT_nodes["meshStandard1"] = create_meshStandard1(MAT);
        if (MAT.childrenController) {
          MAT.childrenController.selection.set([MAT_nodes["meshStandard1"].node]);
        }
        MAT.uiData.setPosition(-500, 700);
        MAT.params.postCreateSpareParams();
        MAT.params.runOnSceneLoadHooks();
        return { node: MAT, children: MAT_nodes };
      }
      function create_attribPromote1(subnet_color2) {
        var attribPromote1 = subnet_color2.createNode("attribPromote");
        attribPromote1.setName("attribPromote1");
        const attribPromote1_nodes = {};
        attribPromote1.uiData.setPosition(-250, 950);
        attribPromote1.setAttribClassFrom(_polygonjs_polygonjs_src_core_geometry_Constant__WEBPACK_IMPORTED_MODULE_1__/* .AttribClass.OBJECT */ .io.OBJECT);
        attribPromote1.setAttribClassTo(_polygonjs_polygonjs_src_core_geometry_Constant__WEBPACK_IMPORTED_MODULE_1__/* .AttribClass.POINT */ .io.POINT);
        attribPromote1.p.name.set("color");
        attribPromote1.params.postCreateSpareParams();
        attribPromote1.params.runOnSceneLoadHooks();
        return { node: attribPromote1, children: attribPromote1_nodes };
      }
      function create_color1(subnet_color2) {
        var color1 = subnet_color2.createNode("color");
        color1.setName("color1");
        const color1_nodes = {};
        color1.uiData.setPosition(-250, 800);
        color1.params.postCreateSpareParams();
        color1.params.runOnSceneLoadHooks();
        return { node: color1, children: color1_nodes };
      }
      function create_material1(subnet_color2) {
        var material1 = subnet_color2.createNode("material");
        material1.setName("material1");
        const material1_nodes = {};
        material1.uiData.setPosition(-250, 1150);
        material1.flags.display.set(true);
        material1.p.material.set("../MAT/meshStandard1");
        material1.params.postCreateSpareParams();
        material1.params.runOnSceneLoadHooks();
        return { node: material1, children: material1_nodes };
      }
      function create_palette1(subnet_color2) {
        var palette1 = subnet_color2.createNode("palette");
        palette1.setName("palette1");
        const palette1_nodes = {};
        palette1.uiData.setPosition(-100, 650);
        palette1.setAttribClass(_polygonjs_polygonjs_src_core_geometry_Constant__WEBPACK_IMPORTED_MODULE_1__/* .AttribClass.OBJECT */ .io.OBJECT);
        palette1.p.paletteName.set("butterfly");
        palette1.p.colorsCount.set(4);
        palette1.p.color1.set([0.9568627450980393, 0.00392156862745098, 0.01568627450980392]);
        palette1.p.color2.set([0.9647058823529412, 0.7529411764705882, 0.7019607843137254]);
        palette1.p.color3.set([0.6, 0.403921568627451, 0.22745098039215686]);
        palette1.p.color4.set([0.9411764705882353, 0.9450980392156862, 0.9568627450980393]);
        palette1.p.color5.set([0.8862745098039215, 0.4627450980392157, 0.6862745098039216]);
        palette1.params.postCreateSpareParams();
        palette1.params.runOnSceneLoadHooks();
        return { node: palette1, children: palette1_nodes };
      }
      function create_subnetInput1(subnet_color2) {
        var subnetInput1 = subnet_color2.createNode("subnetInput");
        subnetInput1.setName("subnetInput1");
        const subnetInput1_nodes = {};
        subnetInput1.uiData.setPosition(-100, 400);
        subnetInput1.params.postCreateSpareParams();
        subnetInput1.params.runOnSceneLoadHooks();
        return { node: subnetInput1, children: subnetInput1_nodes };
      }
      function create_subnetOutput1(subnet_color2) {
        var subnetOutput1 = subnet_color2.createNode("subnetOutput");
        subnetOutput1.setName("subnetOutput1");
        const subnetOutput1_nodes = {};
        subnetOutput1.uiData.setPosition(-250, 1300);
        subnetOutput1.params.postCreateSpareParams();
        subnetOutput1.params.runOnSceneLoadHooks();
        return { node: subnetOutput1, children: subnetOutput1_nodes };
      }
      subnet_color_nodes["MAT"] = create_MAT(subnet_color);
      subnet_color_nodes["attribPromote1"] = create_attribPromote1(subnet_color);
      subnet_color_nodes["color1"] = create_color1(subnet_color);
      subnet_color_nodes["material1"] = create_material1(subnet_color);
      subnet_color_nodes["palette1"] = create_palette1(subnet_color);
      subnet_color_nodes["subnetInput1"] = create_subnetInput1(subnet_color);
      subnet_color_nodes["subnetOutput1"] = create_subnetOutput1(subnet_color);
      subnet_color_nodes["attribPromote1"].node.setInput(0, subnet_color_nodes["color1"].node);
      subnet_color_nodes["color1"].node.setInput(0, subnet_color_nodes["palette1"].node);
      subnet_color_nodes["material1"].node.setInput(0, subnet_color_nodes["attribPromote1"].node);
      subnet_color_nodes["palette1"].node.setInput(0, subnet_color_nodes["subnetInput1"].node);
      subnet_color_nodes["subnetOutput1"].node.setInput(0, subnet_color_nodes["material1"].node);
      if (subnet_color.childrenController) {
        subnet_color.childrenController.selection.set([subnet_color_nodes["palette1"].node]);
      }
      subnet_color.uiData.setComment(
        "this adds colors to the spheres. You can dive inside to see how it is set up."
      );
      subnet_color.uiData.setPosition(-100, 750);
      subnet_color.params.postCreateSpareParams();
      subnet_color.params.runOnSceneLoadHooks();
      return { node: subnet_color, children: subnet_color_nodes };
    }
    function create_transform1(physics2) {
      var transform1 = physics2.createNode("transform");
      transform1.setName("transform1");
      const transform1_nodes = {};
      transform1.uiData.setComment(
        "we move the spheres up and rotate them, so that the simulation is a bit more interesting"
      );
      transform1.uiData.setPosition(-100, 50);
      transform1.p.applyOn.set(1);
      transform1.p.objectMode.set(1);
      transform1.p.t.set([0, -0.456493802109712, -0.42488007716330856]);
      transform1.p.r.set([20.78407826090229, -25.35661701820676, 0]);
      transform1.params.postCreateSpareParams();
      transform1.params.runOnSceneLoadHooks();
      return { node: transform1, children: transform1_nodes };
    }
    function create_transform3(physics2) {
      var transform3 = physics2.createNode("transform");
      transform3.setName("transform3");
      const transform3_nodes = {};
      transform3.uiData.setPosition(-900, 650);
      transform3.p.applyOn.set(1);
      transform3.p.t.set([0, -5.2, 0]);
      transform3.params.postCreateSpareParams();
      transform3.params.runOnSceneLoadHooks();
      return { node: transform3, children: transform3_nodes };
    }
    function create_transform4(physics2) {
      var transform4 = physics2.createNode("transform");
      transform4.setName("transform4");
      const transform4_nodes = {};
      transform4.uiData.setPosition(-700, 800);
      transform4.p.applyOn.set(1);
      transform4.p.objectMode.set(1);
      transform4.p.r.set([90, 0, 0]);
      transform4.params.postCreateSpareParams();
      transform4.params.runOnSceneLoadHooks();
      return { node: transform4, children: transform4_nodes };
    }
    function create_transform5(physics2) {
      var transform5 = physics2.createNode("transform");
      transform5.setName("transform5");
      const transform5_nodes = {};
      transform5.uiData.setPosition(-500, 800);
      transform5.p.applyOn.set(1);
      transform5.p.objectMode.set(1);
      transform5.p.r.set([-90, 0, 0]);
      transform5.params.postCreateSpareParams();
      transform5.params.runOnSceneLoadHooks();
      return { node: transform5, children: transform5_nodes };
    }
    physics_nodes["copy1"] = create_copy1(physics);
    physics_nodes["copy3"] = create_copy3(physics);
    physics_nodes["copy4"] = create_copy4(physics);
    physics_nodes["hexagons1"] = create_hexagons1(physics);
    physics_nodes["jitter1"] = create_jitter1(physics);
    physics_nodes["merge1"] = create_merge1(physics);
    physics_nodes["merge2"] = create_merge2(physics);
    physics_nodes["merge3"] = create_merge3(physics);
    physics_nodes["merge4"] = create_merge4(physics);
    physics_nodes["objectProperties1"] = create_objectProperties1(physics);
    physics_nodes["physicsGround1"] = create_physicsGround1(physics);
    physics_nodes["physicsRBDAttributes1"] = create_physicsRBDAttributes1(physics);
    physics_nodes["physicsWorld1"] = create_physicsWorld1(physics);
    physics_nodes["sphere1"] = create_sphere1(physics);
    physics_nodes["subnet_color"] = create_subnet_color(physics);
    physics_nodes["transform1"] = create_transform1(physics);
    physics_nodes["transform3"] = create_transform3(physics);
    physics_nodes["transform4"] = create_transform4(physics);
    physics_nodes["transform5"] = create_transform5(physics);
    physics_nodes["copy1"].node.setInput(0, physics_nodes["sphere1"].node);
    physics_nodes["copy1"].node.setInput(1, physics_nodes["jitter1"].node);
    physics_nodes["copy3"].node.setInput(0, physics_nodes["transform3"].node);
    physics_nodes["copy4"].node.setInput(0, physics_nodes["hexagons1"].node);
    physics_nodes["jitter1"].node.setInput(0, physics_nodes["merge3"].node);
    physics_nodes["merge1"].node.setInput(0, physics_nodes["merge2"].node);
    physics_nodes["merge1"].node.setInput(1, physics_nodes["subnet_color"].node);
    physics_nodes["merge2"].node.setInput(0, physics_nodes["copy3"].node);
    physics_nodes["merge2"].node.setInput(2, physics_nodes["objectProperties1"].node);
    physics_nodes["merge3"].node.setInput(0, physics_nodes["copy4"].node);
    physics_nodes["merge4"].node.setInput(0, physics_nodes["transform4"].node);
    physics_nodes["merge4"].node.setInput(1, physics_nodes["transform5"].node);
    physics_nodes["objectProperties1"].node.setInput(0, physics_nodes["merge4"].node);
    physics_nodes["physicsRBDAttributes1"].node.setInput(0, physics_nodes["transform1"].node);
    physics_nodes["physicsWorld1"].node.setInput(0, physics_nodes["merge1"].node);
    physics_nodes["subnet_color"].node.setInput(0, physics_nodes["physicsRBDAttributes1"].node);
    physics_nodes["transform1"].node.setInput(0, physics_nodes["copy1"].node);
    physics_nodes["transform3"].node.setInput(0, physics_nodes["physicsGround1"].node);
    physics_nodes["transform4"].node.setInput(0, physics_nodes["transform3"].node);
    physics_nodes["transform5"].node.setInput(0, physics_nodes["transform3"].node);
    if (physics.childrenController) {
      physics.childrenController.selection.set([physics_nodes["physicsWorld1"].node]);
    }
    physics.uiData.setComment("Dive inside [this node](.) to see how the physics is set up");
    physics.uiData.setPosition(-50, -200);
    physics.flags.display.set(true);
    physics.params.postCreateSpareParams();
    physics.params.runOnSceneLoadHooks();
    return { node: physics, children: physics_nodes };
  }
  scene_root_nodes["perspectiveCamera1"] = create_perspectiveCamera1(root);
  scene_root_nodes["lights"] = create_lights(root);
  scene_root_nodes["webcam"] = create_webcam(root);
  scene_root_nodes["physics"] = create_physics(root);
  scene.setFrame(0);
  scene.play();
  return {
    scene,
    cameraPath: scene_root_nodes["perspectiveCamera1"].node.path(),
    focusedNodes: scene_root_nodes["webcam"].children["actor1"].node.children(),
    autoLayout: false
  };
}


/***/ })

}])
//# sourceMappingURL=src_engine_examples_examples_actor_TrackHand_physics_ts.22bed741f77f9590f3da.js.map