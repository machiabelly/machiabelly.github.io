{"version":3,"file":"_polygonjs_polygonjs_src_engine_nodes_mat_RayMarchingBuilder_ts.bfcb20d625d084be0012.js","mappings":"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","sources":["webpack:///../@polygonjs/polygonjs/src/engine/nodes/gl/gl/raymarching/uniforms.ts","webpack:///../@polygonjs/polygonjs/src/engine/nodes/mat/utils/customMaterials/CustomMaterialRayMarching.ts","webpack:///../@polygonjs/polygonjs/src/engine/nodes/mat/utils/RayMarchingController.ts","webpack:///../@polygonjs/polygonjs/src/engine/nodes/mat/RayMarchingBuilder.ts","webpack:///../@polygonjs/polygonjs/src/engine/nodes/gl/code/assemblers/materials/MaterialPersistedConfig.ts","webpack:///../@polygonjs/polygonjs/src/engine/nodes/mat/_BaseBuilder.ts","webpack:///../@polygonjs/polygonjs/src/engine/nodes/mat/utils/DefaultFolder.ts","webpack:///../@polygonjs/polygonjs/src/engine/nodes/mat/utils/TexturesFolder.ts","webpack:///../@polygonjs/polygonjs/src/engine/nodes/mat/utils/UniformsFogController.ts","webpack:///../@polygonjs/polygonjs/src/engine/nodes/mat/utils/customMaterials/_CustomMaterialBase.ts"],"sourcesContent":["import {IUniformN} from '../../../utils/code/gl/Uniforms';\n\nexport interface RayMarchingUniforms {\n\tMAX_STEPS: IUniformN;\n\tMAX_DIST: IUniformN;\n\tSURF_DIST: IUniformN;\n\tNORMALS_BIAS: IUniformN;\n\tSHADOW_BIAS: IUniformN;\n\tdebugMinSteps: IUniformN;\n\tdebugMaxSteps: IUniformN;\n\tdebugMinDepth: IUniformN;\n\tdebugMaxDepth: IUniformN;\n\tshadowDistanceMin: IUniformN;\n\tshadowDistanceMax: IUniformN;\n\tshadowDepthMin: IUniformN;\n\tshadowDepthMax: IUniformN;\n\tenvMapRotationY: IUniformN;\n\t// spotLightsRayMarching: IUniformV3Array;\n}\n\nexport const RAYMARCHING_UNIFORMS: RayMarchingUniforms = {\n\tMAX_STEPS: {\n\t\tvalue: 100,\n\t},\n\tMAX_DIST: {\n\t\tvalue: 100,\n\t},\n\tSURF_DIST: {\n\t\tvalue: 0.001,\n\t},\n\tNORMALS_BIAS: {\n\t\tvalue: 0.01,\n\t},\n\tSHADOW_BIAS: {\n\t\tvalue: 0,\n\t},\n\tdebugMinSteps: {\n\t\tvalue: 0,\n\t},\n\tdebugMaxSteps: {\n\t\tvalue: 128,\n\t},\n\tdebugMinDepth: {\n\t\tvalue: 0,\n\t},\n\tdebugMaxDepth: {\n\t\tvalue: 128,\n\t},\n\tshadowDistanceMin: {\n\t\tvalue: 0,\n\t},\n\tshadowDistanceMax: {\n\t\tvalue: 100,\n\t},\n\tshadowDepthMin: {\n\t\tvalue: 0,\n\t},\n\tshadowDepthMax: {\n\t\tvalue: 100,\n\t},\n\tenvMapRotationY: {\n\t\tvalue: 0,\n\t},\n};\n","import {RAYMARCHING_UNIFORMS} from './../../../gl/gl/raymarching/uniforms';\nimport {Material} from 'three';\nimport {TypeAssert} from '../../../../poly/Assert';\nimport {NodeParamsConfig} from '../../../utils/params/ParamsConfig';\nimport {CustomMaterialName} from '../../../../../core/geometry/Material';\nimport {Constructor} from '../../../../../types/GlobalTypes';\nimport {ParamConfig} from '../../../utils/params/ParamsConfig';\nimport {BaseBuilderParamConfig} from '../../_BaseBuilder';\nimport {TypedMatNode} from '../../_Base';\nimport {isBooleanTrue} from '../../../../../core/Type';\nimport {CUSTOM_MAT_PARAM_OPTIONS} from './_CustomMaterialBase';\n\nexport function CustomMaterialRayMarchingParamConfig<TBase extends Constructor>(Base: TBase) {\n\treturn class Mixin extends Base {\n\t\t/** @param toggle on to choose which customMaterials will be generated */\n\t\toverrideCustomMaterials = ParamConfig.BOOLEAN(0, {\n\t\t\t...CUSTOM_MAT_PARAM_OPTIONS,\n\t\t\tseparatorBefore: true,\n\t\t\tseparatorAfter: true,\n\t\t});\n\t\t/** @param creates a shadow material for point lights */\n\t\tcreateCustomMatDistance = ParamConfig.BOOLEAN(1, {\n\t\t\tvisibleIf: {overrideCustomMaterials: 1},\n\t\t\t...CUSTOM_MAT_PARAM_OPTIONS,\n\t\t});\n\t\t/** @param min shadow depth for point lights */\n\t\tshadowDistanceMin = ParamConfig.FLOAT(RAYMARCHING_UNIFORMS.shadowDistanceMin.value, {\n\t\t\trange: [0, 100],\n\t\t\trangeLocked: [true, false],\n\t\t\tstep: 1,\n\t\t\tvisibleIf: [{overrideCustomMaterials: 0}, {overrideCustomMaterials: 1, createCustomMatDistance: 1}],\n\t\t});\n\t\t/** @param max shadow depth for point lights */\n\t\tshadowDistanceMax = ParamConfig.FLOAT(RAYMARCHING_UNIFORMS.shadowDistanceMax.value, {\n\t\t\trange: [0, 100],\n\t\t\trangeLocked: [true, false],\n\t\t\tstep: 1,\n\t\t\tvisibleIf: [{overrideCustomMaterials: 0}, {overrideCustomMaterials: 1, createCustomMatDistance: 1}],\n\t\t});\n\t\t/** @param creates a shadow material for spot lights and directional lights */\n\t\tcreateCustomMatDepth = ParamConfig.BOOLEAN(1, {\n\t\t\tvisibleIf: {overrideCustomMaterials: 1},\n\t\t\t...CUSTOM_MAT_PARAM_OPTIONS,\n\t\t});\n\t\t/** @param min shadow depth for spot lights and directional lights */\n\t\tshadowDepthMin = ParamConfig.FLOAT(RAYMARCHING_UNIFORMS.shadowDepthMin.value, {\n\t\t\trange: [0, 100],\n\t\t\trangeLocked: [true, false],\n\t\t\tstep: 1,\n\t\t\tvisibleIf: [{overrideCustomMaterials: 0}, {overrideCustomMaterials: 1, createCustomMatDepth: 1}],\n\t\t});\n\t\t/** @param max shadow depth for spot lights and directional lights */\n\t\tshadowDepthMax = ParamConfig.FLOAT(RAYMARCHING_UNIFORMS.shadowDepthMax.value, {\n\t\t\trange: [0, 100],\n\t\t\trangeLocked: [true, false],\n\t\t\tstep: 1,\n\t\t\tvisibleIf: [{overrideCustomMaterials: 0}, {overrideCustomMaterials: 1, createCustomMatDepth: 1}],\n\t\t});\n\t};\n}\nclass CustomMaterialRayMarchingParamsConfig extends CustomMaterialRayMarchingParamConfig(\n\tBaseBuilderParamConfig(NodeParamsConfig)\n) {}\n\nabstract class CustomMaterialMatNode<M extends Material> extends TypedMatNode<\n\tM,\n\tCustomMaterialRayMarchingParamsConfig\n> {}\n\nexport function materialRayMarchingAssemblerCustomMaterialRequested(\n\tnode: CustomMaterialMatNode<any>,\n\tcustomName: CustomMaterialName\n): boolean {\n\tconst param = node.p.overrideCustomMaterials;\n\tif (!param) {\n\t\tconsole.warn(`param overrideCustomMaterials not found on ${node.path()}, creating all customMaterials`);\n\t\treturn true;\n\t}\n\tif (!isBooleanTrue(node.pv.overrideCustomMaterials)) {\n\t\treturn true;\n\t}\n\tswitch (customName) {\n\t\tcase CustomMaterialName.DISTANCE: {\n\t\t\treturn isBooleanTrue(node.pv.createCustomMatDistance);\n\t\t}\n\t\tcase CustomMaterialName.DEPTH: {\n\t\t\treturn isBooleanTrue(node.pv.createCustomMatDepth);\n\t\t}\n\t\tcase CustomMaterialName.DEPTH_DOF: {\n\t\t\treturn false; // isBooleanTrue(node.pv.createCustomMatDepthDOF);\n\t\t}\n\t}\n\tTypeAssert.unreachable(customName);\n}\n","import {BaseNodeType} from './../../_Base';\nimport {NodeContext} from './../../../poly/NodeContext';\nimport {TypeAssert} from './../../../poly/Assert';\nimport {RayMarchingUniforms, RAYMARCHING_UNIFORMS} from './../../gl/gl/raymarching/uniforms';\nimport {Constructor} from '../../../../types/GlobalTypes';\nimport {NodeParamsConfig, ParamConfig} from '../../utils/params/ParamsConfig';\nimport {PrimitiveMatNode} from '../_Base';\nimport {Material, Texture} from 'three';\nimport {ShaderMaterialWithCustomMaterials} from '../../../../core/geometry/Material';\nimport {isBooleanTrue} from '../../../../core/Type';\nimport {CustomMaterialRayMarchingParamConfig} from './customMaterials/CustomMaterialRayMarching';\nimport {ThreeToGl} from '../../../../core/ThreeToGl';\n\nenum RayMarchingDebugMode {\n\tSTEPS_COUNT = 'Steps Count',\n\tDEPTH = 'Depth',\n}\nconst RAYMARCHING_DEBUG_MODES: RayMarchingDebugMode[] = [RayMarchingDebugMode.STEPS_COUNT, RayMarchingDebugMode.DEPTH];\nconst DEBUG_STEPS_COUNT = RAYMARCHING_DEBUG_MODES.indexOf(RayMarchingDebugMode.STEPS_COUNT);\n// const DEBUG_DEPTH = RAYMARCHING_DEBUG_MODES.indexOf(RayMarchingDebugMode.DEPTH);\n\ninterface EnvMapParams {\n\tenvMapCubeUVHeight: number;\n}\ninterface EnvMapData {\n\ttexelWidth: number;\n\ttexelHeight: number;\n\tmaxMip: number;\n}\ninterface EnvMapDataWithRotation extends EnvMapData {\n\ttEnvMapRotate: boolean;\n}\n// from three.js WebGLProgram.js\nfunction generateCubeUVSize(parameters: EnvMapParams): EnvMapData | null {\n\tconst imageHeight = parameters.envMapCubeUVHeight;\n\n\tif (imageHeight === null) return null;\n\n\tconst maxMip = Math.log2(imageHeight) - 2;\n\n\tconst texelHeight = 1.0 / imageHeight;\n\n\tconst texelWidth = 1.0 / (3 * Math.max(Math.pow(2, maxMip), 7 * 16));\n\n\treturn {texelWidth, texelHeight, maxMip};\n}\nfunction setDefines(shaderMaterial: ShaderMaterialWithCustomMaterials, props?: EnvMapDataWithRotation | null) {\n\tshaderMaterial.defines['ENVMAP_TYPE_CUBE_UV'] = props ? 1 : 0;\n\tshaderMaterial.defines['CUBEUV_TEXEL_WIDTH'] = props ? props.texelWidth : ThreeToGl.float(0.1);\n\tshaderMaterial.defines['CUBEUV_TEXEL_HEIGHT'] = props ? props.texelHeight : ThreeToGl.float(0.1);\n\tshaderMaterial.defines['CUBEUV_MAX_MIP'] = props ? ThreeToGl.float(props.maxMip) : ThreeToGl.float(1);\n\tshaderMaterial.defines['ROTATE_ENV_MAP_Y'] = props ? props.tEnvMapRotate : 0;\n}\n\nexport function RayMarchingMainParamConfig<TBase extends Constructor>(Base: TBase) {\n\treturn class Mixin extends Base {\n\t\t/** @param maximum number of steps the raymarcher will run */\n\t\tmaxSteps = ParamConfig.INTEGER(RAYMARCHING_UNIFORMS.MAX_STEPS.value, {\n\t\t\trange: [1, 128],\n\t\t\trangeLocked: [true, false],\n\t\t});\n\t\t/** @param maximum distance the raymarcher will step through */\n\t\tmaxDist = ParamConfig.FLOAT(RAYMARCHING_UNIFORMS.MAX_DIST.value, {\n\t\t\trange: [1, 100],\n\t\t\trangeLocked: [true, false],\n\t\t});\n\t\t/** @param when the ray reaches this distance from a surface it will stop marching. You can lower this value to increase the precision of the raymarcher */\n\t\tsurfDist = ParamConfig.FLOAT(RAYMARCHING_UNIFORMS.SURF_DIST.value, {\n\t\t\trange: [0, 0.1],\n\t\t\trangeLocked: [true, false],\n\t\t\tstep: 0.0000001,\n\t\t});\n\t\t/** @param precision for normals computation */\n\t\tnormalsBias = ParamConfig.FLOAT(RAYMARCHING_UNIFORMS.NORMALS_BIAS.value, {\n\t\t\trange: [0, 0.1],\n\t\t\trangeLocked: [true, false],\n\t\t\tstep: 0.0000001,\n\t\t});\n\t\t/** @param precision for shadows computation */\n\t\tshadowBias = ParamConfig.FLOAT(RAYMARCHING_UNIFORMS.SHADOW_BIAS.value, {\n\t\t\trange: [-0.1, 0.1],\n\t\t\trangeLocked: [false, false],\n\t\t\tstep: 0.0000001,\n\t\t});\n\t};\n}\n\nexport function RayMarchingEnvMapParamConfig<TBase extends Constructor>(Base: TBase) {\n\treturn class Mixin extends Base {\n\t\t/** @param toggle if you want to use an environment map */\n\t\tuseEnvMap = ParamConfig.BOOLEAN(0, {\n\t\t\tseparatorBefore: true,\n\t\t\t// ...BooleanParamOptions(TextureEnvMapController),\n\t\t});\n\t\t/** @param specify the environment map COP node */\n\t\tenvMap = ParamConfig.NODE_PATH('', {\n\t\t\tvisibleIf: {useEnvMap: 1},\n\t\t\tnodeSelection: {context: NodeContext.COP},\n\t\t});\n\t\t/** @param environment intensity */\n\t\tenvMapIntensity = ParamConfig.FLOAT(1, {\n\t\t\tvisibleIf: {useEnvMap: 1},\n\t\t\tcook: false,\n\t\t\tcallback: (node: BaseNodeType) =>\n\t\t\t\tRayMarchingController.updateUniformEnvMapIntensity(node as RayMarchingMatNode),\n\t\t});\n\t\t/** @param environment roughness */\n\t\tenvMapRoughness = ParamConfig.FLOAT(1, {\n\t\t\tvisibleIf: {useEnvMap: 1},\n\t\t\tcook: false,\n\t\t\tcallback: (node: BaseNodeType) =>\n\t\t\t\tRayMarchingController.updateUniformEnvMapRoughness(node as RayMarchingMatNode),\n\t\t});\n\t\t/** @param allow env map rotation */\n\t\ttEnvMapRotate = ParamConfig.BOOLEAN(0, {\n\t\t\tvisibleIf: {useEnvMap: 1},\n\t\t});\n\t\t/** @param env map rotation */\n\t\tenvMapRotation = ParamConfig.FLOAT(0, {\n\t\t\trange: [-Math.PI, Math.PI],\n\t\t\trangeLocked: [false, false],\n\t\t\tstep: 0.0001,\n\t\t\tvisibleIf: {useEnvMap: 1, tEnvMapRotate: 1},\n\t\t\tcook: false,\n\t\t\tcallback: (node: BaseNodeType) =>\n\t\t\t\tRayMarchingController.updateUniformEnvMapRotate(node as RayMarchingMatNode),\n\t\t});\n\t};\n}\nexport function RayMarchingDebugParamConfig<TBase extends Constructor>(Base: TBase) {\n\treturn class Mixin extends Base {\n\t\t/** @param debug mode */\n\t\tdebug = ParamConfig.BOOLEAN(0, {\n\t\t\tseparatorBefore: true,\n\t\t});\n\t\t/** @param outputs color showing the number of steps required to solve the raymarching */\n\t\tdebugMode = ParamConfig.INTEGER(DEBUG_STEPS_COUNT, {\n\t\t\tmenu: {entries: RAYMARCHING_DEBUG_MODES.map((name, value) => ({name, value}))},\n\t\t\tvisibleIf: {debug: true},\n\t\t});\n\t\t/** @param min steps count */\n\t\tdebugMinSteps = ParamConfig.INTEGER(RAYMARCHING_UNIFORMS.debugMinSteps.value, {\n\t\t\trange: [0, 128],\n\t\t\trangeLocked: [true, false],\n\t\t\tstep: 1,\n\t\t\t// visibleIf: {debug: true, debugMode: DEBUG_STEPS_COUNT},\n\t\t});\n\t\t/** @param max steps count */\n\t\tdebugMaxSteps = ParamConfig.INTEGER(RAYMARCHING_UNIFORMS.debugMaxSteps.value, {\n\t\t\trange: [0, 128],\n\t\t\trangeLocked: [true, false],\n\t\t\tstep: 1,\n\t\t\t// visibleIf: {debug: true, debugMode: DEBUG_STEPS_COUNT},\n\t\t});\n\t\t/** @param min depth */\n\t\tdebugMinDepth = ParamConfig.FLOAT(RAYMARCHING_UNIFORMS.debugMinDepth.value, {\n\t\t\trange: [0, 128],\n\t\t\trangeLocked: [true, false],\n\t\t\tstep: 1,\n\t\t\t// visibleIf: {debug: true, debugMode: DEBUG_DEPTH},\n\t\t});\n\t\t/** @param max depth */\n\t\tdebugMaxDepth = ParamConfig.FLOAT(RAYMARCHING_UNIFORMS.debugMaxDepth.value, {\n\t\t\trange: [0, 128],\n\t\t\trangeLocked: [true, false],\n\t\t\tstep: 1,\n\t\t\t// visibleIf: {debug: true, debugMode: DEBUG_DEPTH},\n\t\t});\n\t};\n}\nclass RayMarchingMaterial extends Material {}\nclass RayMarchingParamsConfig extends CustomMaterialRayMarchingParamConfig(\n\tRayMarchingDebugParamConfig(RayMarchingEnvMapParamConfig(RayMarchingMainParamConfig(NodeParamsConfig)))\n) {}\n\nabstract class RayMarchingMatNode extends PrimitiveMatNode<RayMarchingMaterial, RayMarchingParamsConfig> {}\n\n// const worldPos = new Vector3();\n\nexport class RayMarchingController {\n\tconstructor(protected node: RayMarchingMatNode) {}\n\n\tasync updateUniformsFromParams(shaderMaterial: ShaderMaterialWithCustomMaterials) {\n\t\tconst uniforms = shaderMaterial.uniforms as unknown as RayMarchingUniforms | undefined;\n\t\tif (!uniforms) {\n\t\t\treturn;\n\t\t}\n\t\tconst pv = this.node.pv;\n\n\t\tuniforms.MAX_STEPS.value = pv.maxSteps;\n\t\tuniforms.MAX_DIST.value = pv.maxDist;\n\t\tuniforms.SURF_DIST.value = pv.surfDist;\n\t\tuniforms.NORMALS_BIAS.value = pv.normalsBias;\n\t\tuniforms.SHADOW_BIAS.value = pv.shadowBias;\n\n\t\tuniforms.shadowDepthMin.value = pv.shadowDepthMin;\n\t\tuniforms.shadowDepthMax.value = pv.shadowDepthMax;\n\t\tuniforms.shadowDistanceMin.value = pv.shadowDistanceMin;\n\t\tuniforms.shadowDistanceMax.value = pv.shadowDistanceMax;\n\n\t\tthis._updateUniforms(shaderMaterial);\n\t\tthis._updateDebug(shaderMaterial, uniforms);\n\t\tawait this._updateEnvMap(shaderMaterial, uniforms);\n\t}\n\n\tprivate _updateDebug(shaderMaterial: ShaderMaterialWithCustomMaterials, uniforms: RayMarchingUniforms) {\n\t\tconst pv = this.node.pv;\n\t\tif (isBooleanTrue(pv.debug)) {\n\t\t\tfunction updateDebugMode(uniforms: RayMarchingUniforms) {\n\t\t\t\tconst debugMode = RAYMARCHING_DEBUG_MODES[pv.debugMode];\n\t\t\t\tswitch (debugMode) {\n\t\t\t\t\tcase RayMarchingDebugMode.STEPS_COUNT: {\n\t\t\t\t\t\tuniforms.debugMinSteps.value = pv.debugMinSteps;\n\t\t\t\t\t\tuniforms.debugMaxSteps.value = pv.debugMaxSteps;\n\t\t\t\t\t\tshaderMaterial.defines['DEBUG_STEPS_COUNT'] = 1;\n\t\t\t\t\t\tdelete shaderMaterial.defines['DEBUG_DEPTH'];\n\t\t\t\t\t\tshaderMaterial.needsUpdate = true;\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tcase RayMarchingDebugMode.DEPTH: {\n\t\t\t\t\t\tuniforms.debugMinDepth.value = pv.debugMinDepth;\n\t\t\t\t\t\tuniforms.debugMaxDepth.value = pv.debugMaxDepth;\n\t\t\t\t\t\tshaderMaterial.defines['DEBUG_DEPTH'] = 1;\n\t\t\t\t\t\tdelete shaderMaterial.defines['DEBUG_STEPS_COUNT'];\n\t\t\t\t\t\tshaderMaterial.needsUpdate = true;\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tTypeAssert.unreachable(debugMode);\n\t\t\t}\n\t\t\tupdateDebugMode(uniforms);\n\t\t} else {\n\t\t\tif (shaderMaterial.defines['DEBUG_STEPS_COUNT'] != null) {\n\t\t\t\tdelete shaderMaterial.defines['DEBUG_STEPS_COUNT'];\n\t\t\t\tshaderMaterial.needsUpdate = true;\n\t\t\t}\n\t\t\tif (shaderMaterial.defines['DEBUG_DEPTH'] != null) {\n\t\t\t\tdelete shaderMaterial.defines['DEBUG_DEPTH'];\n\t\t\t\tshaderMaterial.needsUpdate = true;\n\t\t\t}\n\t\t}\n\t}\n\tprivate async _updateEnvMap(shaderMaterial: ShaderMaterialWithCustomMaterials, uniforms: RayMarchingUniforms) {\n\t\tconst pv = this.node.pv;\n\t\tsetDefines(shaderMaterial, null);\n\t\tconst currentDefine = shaderMaterial.defines['ENVMAP_TYPE_CUBE_UV'];\n\n\t\tconst _fetchTexture = async () => {\n\t\t\tconst pathParam = this.node.p.envMap;\n\t\t\tif (pathParam.isDirty()) {\n\t\t\t\tawait pathParam.compute();\n\t\t\t}\n\t\t\tconst textureNode = pathParam.value.nodeWithContext(NodeContext.COP);\n\t\t\tif (textureNode) {\n\t\t\t\tconst container = await textureNode.compute();\n\t\t\t\tconst texture = container.texture();\n\t\t\t\treturn texture;\n\t\t\t}\n\t\t};\n\t\tconst _applyTexture = (texture: Texture) => {\n\t\t\t(uniforms as any)['envMap'].value = texture;\n\n\t\t\tconst props = generateCubeUVSize({envMapCubeUVHeight: texture.image.height});\n\t\t\tsetDefines(shaderMaterial, props ? {...props, tEnvMapRotate: pv.tEnvMapRotate} : null);\n\t\t};\n\t\tconst _removeTexture = () => {\n\t\t\t(uniforms as any)['envMap'].value = null;\n\t\t\tsetDefines(shaderMaterial, null);\n\t\t};\n\t\tconst _updateNeedsUpdateIfRequired = () => {\n\t\t\tif (currentDefine != shaderMaterial.defines['ENVMAP_TYPE_CUBE_UV']) {\n\t\t\t\tshaderMaterial.needsUpdate = true;\n\t\t\t}\n\t\t};\n\n\t\tif (isBooleanTrue(pv.useEnvMap)) {\n\t\t\tconst texture = await _fetchTexture();\n\t\t\tif (texture) {\n\t\t\t\t_applyTexture(texture);\n\t\t\t} else {\n\t\t\t\t_removeTexture();\n\t\t\t}\n\t\t} else {\n\t\t\t_removeTexture();\n\t\t}\n\t\t_updateNeedsUpdateIfRequired();\n\t}\n\t/**\n\t *\n\t * uniforms\n\t *\n\t */\n\tprivate _updateUniforms(shaderMaterial: ShaderMaterialWithCustomMaterials) {\n\t\tRayMarchingController._updateUniforms(this.node, shaderMaterial);\n\t}\n\tprivate static _updateUniforms(node: RayMarchingMatNode, shaderMaterial: ShaderMaterialWithCustomMaterials) {\n\t\tthis._updateUniformEnvMapIntensity(node, shaderMaterial);\n\t\tthis._updateUniformEnvMapRoughness(node, shaderMaterial);\n\t\tthis._updateUniformEnvMapRotate(node, shaderMaterial);\n\t}\n\tstatic async updateUniformEnvMapIntensity(node: RayMarchingMatNode) {\n\t\tthis._updateUniformEnvMapIntensity(node, (await node.material()) as ShaderMaterialWithCustomMaterials);\n\t}\n\tstatic _updateUniformEnvMapIntensity(node: RayMarchingMatNode, shaderMaterial: ShaderMaterialWithCustomMaterials) {\n\t\t// const shaderMaterial = node.materialSync() as ShaderMaterialWithCustomMaterials;\n\t\tconst uniforms = shaderMaterial.uniforms as unknown as RayMarchingUniforms | undefined;\n\t\tif (!uniforms) {\n\t\t\treturn;\n\t\t}\n\t\t(uniforms as any)['envMapIntensity'].value = node.pv.envMapIntensity;\n\t}\n\tstatic async updateUniformEnvMapRoughness(node: RayMarchingMatNode) {\n\t\tthis._updateUniformEnvMapRoughness(node, (await node.material()) as ShaderMaterialWithCustomMaterials);\n\t}\n\tstatic _updateUniformEnvMapRoughness(node: RayMarchingMatNode, shaderMaterial: ShaderMaterialWithCustomMaterials) {\n\t\t// const shaderMaterial = node.materialSync() as ShaderMaterialWithCustomMaterials;\n\t\tconst uniforms = shaderMaterial.uniforms as unknown as RayMarchingUniforms | undefined;\n\t\tif (!uniforms) {\n\t\t\treturn;\n\t\t}\n\t\t(uniforms as any)['roughness'].value = node.pv.envMapRoughness;\n\t}\n\tstatic async updateUniformEnvMapRotate(node: RayMarchingMatNode) {\n\t\tthis._updateUniformEnvMapRotate(node, (await node.material()) as ShaderMaterialWithCustomMaterials);\n\t}\n\tstatic _updateUniformEnvMapRotate(node: RayMarchingMatNode, shaderMaterial: ShaderMaterialWithCustomMaterials) {\n\t\t// const shaderMaterial = node.materialSync() as ShaderMaterialWithCustomMaterials;\n\t\tconst uniforms = shaderMaterial.uniforms as unknown as RayMarchingUniforms | undefined;\n\t\tif (!uniforms) {\n\t\t\treturn;\n\t\t}\n\t\t(uniforms as any)['envMapRotationY'].value = node.pv.envMapRotation;\n\t}\n}\n","/**\n * Creates a RayMarching, which can be extended with GL nodes.\n *\n *\n */\nimport {BaseBuilderParamConfig, TypedBuilderMatNode} from './_BaseBuilder';\nimport {ShaderAssemblerRayMarching} from '../gl/code/assemblers/materials/RayMarching';\n\nimport {NodeParamsConfig, ParamConfig} from '../utils/params/ParamsConfig';\nimport {\n\tRayMarchingController,\n\tRayMarchingMainParamConfig,\n\tRayMarchingEnvMapParamConfig,\n\tRayMarchingDebugParamConfig,\n} from './utils/RayMarchingController';\nimport {AssemblerName} from '../../poly/registers/assemblers/_BaseRegister';\nimport {Poly} from '../../Poly';\nimport {CustomMaterialName, ShaderMaterialWithCustomMaterials} from '../../../core/geometry/Material';\nimport {DefaultFolderParamConfig} from './utils/DefaultFolder';\nimport {TexturesFolderParamConfig} from './utils/TexturesFolder';\nimport {AdvancedFolderParamConfig} from './utils/AdvancedFolder';\nimport {Constructor} from '../../../types/GlobalTypes';\nimport {updateMaterialSide} from './utils/helpers/MaterialSideHelper';\nimport {FogParamConfig, UniformFogController, UniformFogControllers} from './utils/UniformsFogController';\nimport {\n\tCustomMaterialRayMarchingParamConfig,\n\tmaterialRayMarchingAssemblerCustomMaterialRequested,\n} from './utils/customMaterials/CustomMaterialRayMarching';\nimport {MatType} from '../../poly/registers/nodes/types/Mat';\n\nexport function AdvancedCommonParamConfig<TBase extends Constructor>(Base: TBase) {\n\treturn class Mixin extends Base {\n\t\t/** @param defines if the material is double sided or not */\n\t\tdoubleSided = ParamConfig.BOOLEAN(0, {\n\t\t\tseparatorBefore: true,\n\t\t});\n\t\t/** @param if the material is not double sided, it can be front sided, or back sided */\n\t\tfront = ParamConfig.BOOLEAN(0, {\n\t\t\tvisibleIf: {doubleSided: false},\n\t\t});\n\t};\n}\nclass RayMarchingBuilderMatParamsConfig extends RayMarchingDebugParamConfig(\n\tCustomMaterialRayMarchingParamConfig(\n\t\tFogParamConfig(\n\t\t\tAdvancedCommonParamConfig(\n\t\t\t\tBaseBuilderParamConfig(\n\t\t\t\t\tAdvancedFolderParamConfig(\n\t\t\t\t\t\tRayMarchingEnvMapParamConfig(\n\t\t\t\t\t\t\tTexturesFolderParamConfig(\n\t\t\t\t\t\t\t\tRayMarchingMainParamConfig(DefaultFolderParamConfig(NodeParamsConfig))\n\t\t\t\t\t\t\t)\n\t\t\t\t\t\t)\n\t\t\t\t\t)\n\t\t\t\t)\n\t\t\t)\n\t\t)\n\t)\n) {}\nconst ParamsConfig = new RayMarchingBuilderMatParamsConfig();\n\nexport class RayMarchingBuilderMatNode extends TypedBuilderMatNode<\n\tShaderMaterialWithCustomMaterials,\n\tShaderAssemblerRayMarching,\n\tRayMarchingBuilderMatParamsConfig\n> {\n\toverride paramsConfig = ParamsConfig;\n\tstatic override type() {\n\t\treturn MatType.RAY_MARCHING_BUILDER;\n\t}\n\tpublic override usedAssembler(): Readonly<AssemblerName.GL_RAYMARCHING> {\n\t\treturn AssemblerName.GL_RAYMARCHING;\n\t}\n\tprotected _createAssemblerController() {\n\t\treturn Poly.assemblersRegister.assembler(this, this.usedAssembler());\n\t}\n\tpublic override customMaterialRequested(customName: CustomMaterialName): boolean {\n\t\treturn materialRayMarchingAssemblerCustomMaterialRequested(this, customName);\n\t}\n\n\tprivate _rayMarchingController = new RayMarchingController(this);\n\n\toverride initializeNode() {}\n\tpublic controllers: UniformFogControllers = {\n\t\tuniformFog: new UniformFogController(this),\n\t};\n\toverride async cook() {\n\t\tthis._material = this._material || this.createMaterial();\n\t\tthis._rayMarchingController.updateUniformsFromParams(this._material);\n\n\t\tthis.compileIfRequired(this._material);\n\n\t\tUniformFogController.update(this);\n\n\t\tupdateMaterialSide(this._material, this.pv);\n\t\tthis.setMaterial(this._material);\n\t}\n}\n","import {BasePersistedConfig, PersistedConfigWithShaders} from '../../../../utils/BasePersistedConfig';\nimport {BaseBuilderMatNodeType} from '../../../../mat/_BaseBuilder';\nimport {\n\tShaderMaterialWithCustomMaterials,\n\tMaterialWithCustomMaterials,\n\tCustomMaterialName,\n} from '../../../../../../core/geometry/Material';\nimport {PolyDictionary} from '../../../../../../types/GlobalTypes';\nimport {ShaderMaterial} from 'three';\nimport {\n\tassignOnBeforeCompileDataAndFunction,\n\tOnBeforeCompileDataConverter,\n\tOnBeforeCompileDataJSON,\n} from './OnBeforeCompile';\n\n// from https://www.typescriptlang.org/docs/handbook/2/mapped-types.html\ntype RemoveShaders<Type> = {\n\t[Property in keyof Type as Exclude<Property, 'fragmentShader' | 'vertexShader'>]: Type[Property];\n};\n\nexport interface OnBeforeCompileDataJSONWithoutShaders extends RemoveShaders<OnBeforeCompileDataJSON> {}\n\nexport interface PersistedConfigBaseMaterialData {\n\tmaterial: object;\n\t// param_uniform_pairs: [string, string][];\n\t// uniforms_time_dependent?: boolean;\n\t// uniforms_resolution_dependent?: boolean;\n\tonBeforeCompileDataJSONWithoutShaders: OnBeforeCompileDataJSONWithoutShaders;\n\tcustomMaterials?: PolyDictionary<PersistedConfigBaseMaterialData>;\n}\n\nexport interface PersistedConfigBaseMaterialDataWithShaders\n\textends PersistedConfigBaseMaterialData,\n\t\tPersistedConfigWithShaders {}\nfunction _removeShaders(data: OnBeforeCompileDataJSON): OnBeforeCompileDataJSONWithoutShaders {\n\tconst onBeforeCompileDataJSONWithoutShaders: OnBeforeCompileDataJSONWithoutShaders = {\n\t\tparamConfigs: data.paramConfigs,\n\t\ttimeDependent: data.timeDependent,\n\t\tresolutionDependent: data.resolutionDependent,\n\t\traymarchingLightsWorldCoordsDependent: data.raymarchingLightsWorldCoordsDependent,\n\t};\n\treturn onBeforeCompileDataJSONWithoutShaders;\n}\ninterface Options {\n\tvertex: string;\n\tfragment: string;\n}\nfunction _addShaders(data: OnBeforeCompileDataJSONWithoutShaders, options: Options): OnBeforeCompileDataJSON {\n\tconst onBeforeCompileDataJSON: OnBeforeCompileDataJSON = {\n\t\tparamConfigs: data.paramConfigs,\n\t\ttimeDependent: data.timeDependent,\n\t\tresolutionDependent: data.resolutionDependent,\n\t\traymarchingLightsWorldCoordsDependent: data.raymarchingLightsWorldCoordsDependent,\n\t\tfragmentShader: options.fragment,\n\t\tvertexShader: options.vertex,\n\t};\n\treturn onBeforeCompileDataJSON;\n}\nfunction _shaderKey(shaderType: 'vertex' | 'fragment', customMaterialName?: string) {\n\treturn customMaterialName ? `${customMaterialName}.${shaderType}` : shaderType;\n}\n\n// potential bug with Material Loader\n// - 1. a uniform with a mat3, such as uvTransform, will be reloaded with a mat4\n// - 2. the boolean lights property is not saved\n// - 3. if a color property is added on the material itself, it should not be saved\n// - 4. for the volume shader, a uniform with an array of vector can be saved, but not loaded again as a vector (but only as an {x,y,z} object)\nexport class MaterialPersistedConfig extends BasePersistedConfig {\n\tprivate _material: ShaderMaterialWithCustomMaterials | undefined;\n\tconstructor(protected override node: BaseBuilderMatNodeType) {\n\t\tsuper(node);\n\t}\n\n\toverride async toData(): Promise<PersistedConfigBaseMaterialDataWithShaders | undefined> {\n\t\tconst assemblerController = this.node.assemblerController();\n\t\tif (!assemblerController) {\n\t\t\treturn;\n\t\t}\n\t\tconst assembler = assemblerController.assembler;\n\t\tconst onBeforeCompileData = assembler.onBeforeCompileData();\n\t\tif (!onBeforeCompileData) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst onBeforeCompileDataJSON = OnBeforeCompileDataConverter.toJSON(onBeforeCompileData);\n\t\tconst onBeforeCompileDataJSONWithoutShaders = _removeShaders(onBeforeCompileDataJSON);\n\t\tconst shaders: PolyDictionary<string> = {\n\t\t\t[_shaderKey('vertex')]: onBeforeCompileDataJSON.vertexShader,\n\t\t\t[_shaderKey('fragment')]: onBeforeCompileDataJSON.fragmentShader,\n\t\t};\n\n\t\t// custom materials\n\t\tconst customMaterialsData: PolyDictionary<PersistedConfigBaseMaterialData> = {};\n\t\tconst material = await this.node.material();\n\t\tif (!material) {\n\t\t\treturn;\n\t\t}\n\t\tconst customMaterials = material.customMaterials;\n\t\tif (customMaterials) {\n\t\t\tassembler.traverseCustomAssemblers((customAssembler, customMaterialName) => {\n\t\t\t\tconst customOnBeforeCompileData = customAssembler.onBeforeCompileData();\n\t\t\t\tif (customOnBeforeCompileData) {\n\t\t\t\t\tconst customMaterial = customMaterials[customMaterialName] as ShaderMaterial;\n\t\t\t\t\tif (customMaterial) {\n\t\t\t\t\t\tconst customMaterialData = this._materialToJson(customMaterial, {\n\t\t\t\t\t\t\tnode: this.node,\n\t\t\t\t\t\t\tsuffix: customMaterialName,\n\t\t\t\t\t\t});\n\t\t\t\t\t\tif (customMaterialData) {\n\t\t\t\t\t\t\tconst data = OnBeforeCompileDataConverter.toJSON(customOnBeforeCompileData);\n\t\t\t\t\t\t\tconst dataWithoutShaders = _removeShaders(data);\n\t\t\t\t\t\t\tcustomMaterialsData[customMaterialName] = {\n\t\t\t\t\t\t\t\tmaterial: customMaterialData,\n\t\t\t\t\t\t\t\tonBeforeCompileDataJSONWithoutShaders: dataWithoutShaders,\n\t\t\t\t\t\t\t};\n\n\t\t\t\t\t\t\tshaders[_shaderKey('vertex', customMaterialName)] = data.vertexShader;\n\t\t\t\t\t\t\tshaders[_shaderKey('fragment', customMaterialName)] = data.fragmentShader;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\n\t\t\t// const customMaterialNames: CustomMaterialName[] = Object.keys(customMaterials) as CustomMaterialName[];\n\t\t\t// for (let customMaterialName of customMaterialNames) {\n\n\t\t\t// }\n\t\t}\n\n\t\t// params updating uniforms\n\t\t// const param_uniform_pairs: [string, string][] = [];\n\t\t// const param_configs = assemblerController.assembler.param_configs();\n\t\t// for (let param_config of param_configs) {\n\t\t// \tparam_uniform_pairs.push([param_config.name(), param_config.uniformName()]);\n\t\t// }\n\n\t\tconst materialData = this._materialToJson(material as ShaderMaterialWithCustomMaterials, {\n\t\t\tnode: this.node,\n\t\t\tsuffix: 'main',\n\t\t});\n\n\t\tif (!materialData) {\n\t\t\tconsole.warn('failed to save material from node', this.node.path());\n\t\t}\n\n\t\tconst data: PersistedConfigBaseMaterialDataWithShaders = {\n\t\t\tmaterial: materialData || {},\n\t\t\tonBeforeCompileDataJSONWithoutShaders,\n\t\t\t// uniforms_time_dependent: assemblerController.assembler.uniformsTimeDependent(),\n\t\t\t// uniforms_resolution_dependent: assemblerController.assembler.uniformsResolutionDependent(),\n\t\t\t// param_uniform_pairs: param_uniform_pairs,\n\t\t\tcustomMaterials: customMaterialsData,\n\t\t\tshaders,\n\t\t};\n\n\t\treturn data;\n\t}\n\toverride load(data: PersistedConfigBaseMaterialDataWithShaders) {\n\t\tconst assemblerController = this.node.assemblerController();\n\t\tif (assemblerController) {\n\t\t\treturn;\n\t\t}\n\t\tthis._material = this._loadMaterial(data.material);\n\t\tif (!this._material) {\n\t\t\treturn;\n\t\t}\n\t\tconst shaders = data.shaders;\n\t\tif (!shaders) {\n\t\t\tconsole.warn(`${this.node.path()}: persisted config has no shaders`);\n\t\t\treturn;\n\t\t}\n\n\t\t// const shaderMaterial = this._material as ShaderMaterial;\n\t\tconst onBeforeCompileDataJSON: OnBeforeCompileDataJSON = _addShaders(\n\t\t\tdata.onBeforeCompileDataJSONWithoutShaders,\n\t\t\t{\n\t\t\t\tvertex: shaders[_shaderKey('vertex')],\n\t\t\t\tfragment: shaders[_shaderKey('fragment')],\n\t\t\t}\n\t\t);\n\n\t\tconst onBeforeCompileData = OnBeforeCompileDataConverter.fromJSON(onBeforeCompileDataJSON);\n\t\tconst material = this._material;\n\t\tassignOnBeforeCompileDataAndFunction(this.node.scene(), material, onBeforeCompileData);\n\n\t\tfor (let paramConfig of onBeforeCompileData.paramConfigs) {\n\t\t\tparamConfig.applyToNode(this.node);\n\t\t}\n\n\t\t// material.onBeforeCompile = (shader: Shader) => {\n\t\t// \tonBeforeCompile(shader);\n\n\t\t// \tif (data.onBeforeCompileDataJSON.paramConfigs) {\n\t\t// \t\tfor (let paramConfigJSON of data.onBeforeCompileDataJSON.paramConfigs) {\n\t\t// \t\t\tconst paramName = paramConfigJSON.name;\n\t\t// \t\t\tconst uniformName = paramConfigJSON.uniformName;\n\t\t// \t\t\tconst param = this.node.params.get(paramName);\n\t\t// \t\t\tconst uniform = shader.uniforms[uniformName];\n\n\t\t// \t\t\tconst customMatNames: CustomMaterialName[] = Object.keys(\n\t\t// \t\t\t\tmaterial.customMaterials\n\t\t// \t\t\t) as CustomMaterialName[];\n\t\t// \t\t\tlet customUniforms: IUniform[] | undefined;\n\t\t// \t\t\tfor (let customMatName of customMatNames) {\n\t\t// \t\t\t\tconst customMat = material.customMaterials[customMatName] as ShaderMaterial;\n\t\t// \t\t\t\tconst customUniform = customMat?.uniforms[uniformName];\n\t\t// \t\t\t\tif (customUniform) {\n\t\t// \t\t\t\t\tcustomUniforms = customUniforms || [];\n\t\t// \t\t\t\t\tcustomUniforms.push(customUniform);\n\t\t// \t\t\t\t}\n\t\t// \t\t\t}\n\t\t// \t\t\tif (param && (uniform || customUniforms)) {\n\t\t// \t\t\t\tconst callback = () => {\n\t\t// \t\t\t\t\tif (uniform) {\n\t\t// \t\t\t\t\t\tGlParamConfig.callback(param, uniform);\n\t\t// \t\t\t\t\t}\n\t\t// \t\t\t\t\tif (customUniforms) {\n\t\t// \t\t\t\t\t\tfor (let customUniform of customUniforms) {\n\t\t// \t\t\t\t\t\t\tGlParamConfig.callback(param, customUniform);\n\t\t// \t\t\t\t\t\t}\n\t\t// \t\t\t\t\t}\n\t\t// \t\t\t\t};\n\t\t// \t\t\t\tparam.options.setOption('callback', callback);\n\t\t// \t\t\t\t// it's best to execute the callback directly\n\t\t// \t\t\t\t// as it may otherwise be prevented if the scene is loading for instance\n\t\t// \t\t\t\t// and this is currently necessary for ramp params, when no assembler is loaded\n\t\t// \t\t\t\tcallback();\n\t\t// \t\t\t\t// param.options.executeCallback();\n\t\t// \t\t\t}\n\t\t// \t\t}\n\t\t// \t}\n\t\t// };\n\n\t\t// load custom materials\n\t\tthis._material.customMaterials = this._material.customMaterials || {};\n\t\tif (data.customMaterials) {\n\t\t\tconst customMatNames: CustomMaterialName[] = Object.keys(data.customMaterials) as CustomMaterialName[];\n\t\t\tfor (const customMatName of customMatNames) {\n\t\t\t\tconst customMatData = data.customMaterials[customMatName];\n\t\t\t\tconst customMat = this._loadMaterial(customMatData.material);\n\t\t\t\tif (customMat) {\n\t\t\t\t\tconst onBeforeCompileDataJSON: OnBeforeCompileDataJSON = _addShaders(\n\t\t\t\t\t\tcustomMatData.onBeforeCompileDataJSONWithoutShaders,\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tvertex: shaders[_shaderKey('vertex', customMatName)],\n\t\t\t\t\t\t\tfragment: shaders[_shaderKey('fragment', customMatName)],\n\t\t\t\t\t\t}\n\t\t\t\t\t);\n\t\t\t\t\tconst customOnBeforeCompileData = OnBeforeCompileDataConverter.fromJSON(onBeforeCompileDataJSON);\n\n\t\t\t\t\tcustomOnBeforeCompileData.paramConfigs = onBeforeCompileData.paramConfigs;\n\n\t\t\t\t\tassignOnBeforeCompileDataAndFunction(this.node.scene(), customMat, customOnBeforeCompileData);\n\t\t\t\t\tthis._material.customMaterials[customMatName] = customMat;\n\n\t\t\t\t\t// console.log('=============', customMatName);\n\t\t\t\t\t// We could link the customMaterial's uniform here\n\t\t\t\t\t// and get them in sync,\n\t\t\t\t\t// but this seems to have unexpected side-effects\n\t\t\t\t\t// and some assigned textures do not get assigned as expected.\n\t\t\t\t\t// Therefore, the syncing is done later in this method,\n\t\t\t\t\t// when setting the param callback\n\t\t\t\t\t// const uniformNames = Object.keys(this._material.uniforms);\n\t\t\t\t\t// for (let uniformName of uniformNames) {\n\t\t\t\t\t// \tconst customMatUniform = custom_mat.uniforms[uniformName];\n\t\t\t\t\t// \tif (customMatUniform) {\n\t\t\t\t\t// \t\tconsole.log(\n\t\t\t\t\t// \t\t\tuniformName,\n\t\t\t\t\t// \t\t\tcustom_mat.uniforms[uniformName].value,\n\t\t\t\t\t// \t\t\tthis._material.uniforms[uniformName].value\n\t\t\t\t\t// \t\t);\n\t\t\t\t\t// \t\t// if the uniform exists in the customMat, replace it completely (not just its value)\n\t\t\t\t\t// \t\t// so that it is garantied to be in sync with the parent material\n\t\t\t\t\t// \t\t// custom_mat.uniforms[uniformName] = this._material.uniforms[uniformName];\n\t\t\t\t\t// \t}\n\t\t\t\t\t// }\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// if (shaderMaterial.uniforms) {\n\t\t// \tif (data.uniforms_time_dependent) {\n\t\t// \t\tthis.node\n\t\t// \t\t\t.scene()\n\t\t// \t\t\t.uniformsController.addTimeDependentUniformOwner(\n\t\t// \t\t\t\tthis._material.uuid,\n\t\t// \t\t\t\tthis._material.uniforms as IUniformsWithTime\n\t\t// \t\t\t);\n\t\t// \t}\n\t\t// \tif (data.uniforms_resolution_dependent) {\n\t\t// \t\tthis.node\n\t\t// \t\t\t.scene()\n\t\t// \t\t\t.uniformsController.addResolutionDependentUniformOwner(\n\t\t// \t\t\t\tthis._material.uuid,\n\t\t// \t\t\t\tthis._material.uniforms as IUniformsWithResolution\n\t\t// \t\t\t);\n\t\t// \t}\n\t}\n\n\tmaterial(): MaterialWithCustomMaterials | undefined {\n\t\t// do not check playerMode, but if the node has an assembler instead\n\t\t// if (Poly.playerMode()) {\n\t\treturn this._material;\n\t\t// }\n\t}\n}\n","import {CustomMaterialName} from './../../../core/geometry/Material';\nimport {Constructor, valueof} from '../../../types/GlobalTypes';\nimport {PrimitiveMatNode} from './_Base';\nimport {GlAssemblerController} from '../gl/code/Controller';\nimport {NodeParamsConfig, ParamConfig} from '../utils/params/ParamsConfig';\nimport {ShaderAssemblerMaterial} from '../gl/code/assemblers/materials/_BaseMaterial';\nimport {MaterialPersistedConfig} from '../gl/code/assemblers/materials/MaterialPersistedConfig';\nimport {GlNodeChildrenMap} from '../../poly/registers/nodes/Gl';\nimport {BaseGlNodeType} from '../gl/_Base';\nimport {MaterialWithCustomMaterials} from '../../../core/geometry/Material';\nimport {NodeContext} from '../../poly/NodeContext';\nimport {isBooleanTrue} from '../../../core/BooleanValue';\nimport {BaseNodeType} from '../_Base';\nimport {NodeCreateOptions} from '../utils/hierarchy/ChildrenController';\n\nexport function BaseBuilderParamConfig<TBase extends Constructor>(Base: TBase) {\n\treturn class Mixin extends Base {\n\t\t/** @param if toggled on, the shader will be built from the gl nodes of another material. This can be useful to have multiple materials use the same gl network, but still set the uniforms differently */\n\t\tsetBuilderNode = ParamConfig.BOOLEAN(0, {\n\t\t\tcallback: (node: BaseNodeType) => {\n\t\t\t\tTypedBuilderMatNode.PARAM_CALLBACK_setCompileRequired(node as BaseBuilderMatNodeType);\n\t\t\t},\n\t\t});\n\t\t/** @param builder node */\n\t\tbuilderNode = ParamConfig.NODE_PATH('', {\n\t\t\tvisibleIf: {setBuilderNode: true},\n\t\t\tcallback: (node: BaseNodeType) => {\n\t\t\t\tTypedBuilderMatNode.PARAM_CALLBACK_setCompileRequired(node as BaseBuilderMatNodeType);\n\t\t\t},\n\t\t});\n\t};\n}\n\nclass MatBuilderParamsConfig extends BaseBuilderParamConfig(NodeParamsConfig) {}\n\nexport abstract class TypedBuilderMatNode<\n\tM extends MaterialWithCustomMaterials,\n\tA extends ShaderAssemblerMaterial,\n\tK extends MatBuilderParamsConfig\n> extends PrimitiveMatNode<M, K> {\n\tprotected _assemblerController: GlAssemblerController<A> | undefined;\n\tprotected override _childrenControllerContext = NodeContext.GL;\n\toverride readonly persisted_config: MaterialPersistedConfig = new MaterialPersistedConfig(this);\n\n\t//\n\t//\n\t// MATERIAL\n\t//\n\t//\n\tcreateMaterial() {\n\t\tlet material: M | undefined;\n\t\tif (this.persisted_config) {\n\t\t\tmaterial = this.persisted_config.material() as M;\n\t\t}\n\t\tif (!material) {\n\t\t\tmaterial = this.assemblerController()?.assembler.createMaterial() as M;\n\t\t}\n\t\treturn material;\n\t}\n\t//\n\t//\n\t// ASSEMBLER\n\t//\n\t//\n\tassemblerController() {\n\t\treturn (this._assemblerController = this._assemblerController || this._createAssemblerController());\n\t}\n\tprotected abstract _createAssemblerController(): GlAssemblerController<A> | undefined;\n\tcustomMaterialRequested(customName: CustomMaterialName): boolean {\n\t\treturn true;\n\t}\n\n\toverride createNode<S extends keyof GlNodeChildrenMap>(\n\t\tnode_class: S,\n\t\toptions?: NodeCreateOptions\n\t): GlNodeChildrenMap[S];\n\toverride createNode<K extends valueof<GlNodeChildrenMap>>(\n\t\tnode_class: Constructor<K>,\n\t\toptions?: NodeCreateOptions\n\t): K;\n\toverride createNode<K extends valueof<GlNodeChildrenMap>>(\n\t\tnode_class: Constructor<K>,\n\t\toptions?: NodeCreateOptions\n\t): K {\n\t\treturn super.createNode(node_class, options) as K;\n\t}\n\toverride children() {\n\t\treturn super.children() as BaseGlNodeType[];\n\t}\n\toverride nodesByType<K extends keyof GlNodeChildrenMap>(type: K): GlNodeChildrenMap[K][] {\n\t\treturn super.nodesByType(type) as GlNodeChildrenMap[K][];\n\t}\n\toverride childrenAllowed() {\n\t\tif (this.assemblerController()) {\n\t\t\treturn super.childrenAllowed();\n\t\t}\n\t\treturn false;\n\t}\n\toverride sceneReadonly() {\n\t\treturn this.assemblerController() == null;\n\t}\n\n\t//\n\t//\n\t// COMPILATION\n\t//\n\t//\n\tcompileIfRequired(material: M) {\n\t\t/* if we recompile while in player mode, there will not be any children gl node created.\n\t\tSo any recompilation will be flawed. A quick way to realise this is with a time dependent material.\n\t\tAnd while a scene export would not have an assembler and therefore not recompile,\n\t\ta temporary display of a scene will the whole engine player will have an assembler and will therefore recompile.\n\t\tUPDATE: the creation of children is not tied to the player mode anymore, only to the presence of the assembler.\n\t\t*/\n\t\t// if (Poly.playerMode()) {\n\t\t// \treturn;\n\t\t// }\n\t\tif (this.assemblerController()?.compileRequired()) {\n\t\t\ttry {\n\t\t\t\tthis._compile(material);\n\t\t\t} catch (err) {\n\t\t\t\tconst message = (err as any).message || 'failed to compile';\n\t\t\t\tthis.states.error.set(message);\n\t\t\t}\n\t\t}\n\t}\n\tprotected _compile(material: M) {\n\t\tconst assemblerController = this.assemblerController();\n\t\t// const material = this.materialSync();\n\t\tif (material && assemblerController) {\n\t\t\tassemblerController.assembler.setGlParentNode(this);\n\t\t\tthis._setAssemblerGlParentNode(assemblerController);\n\t\t\tassemblerController.assembler.compileMaterial(material);\n\t\t\tassemblerController.post_compile();\n\t\t}\n\t}\n\tprivate _setAssemblerGlParentNode(assemblerController: GlAssemblerController<A>) {\n\t\tif (!isBooleanTrue(this.pv.setBuilderNode)) {\n\t\t\treturn;\n\t\t}\n\t\tconst resolvedNode = this.pv.builderNode.nodeWithContext(NodeContext.MAT);\n\t\tif (!resolvedNode) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst resolvedBuilderNode = resolvedNode as BaseBuilderMatNodeType;\n\t\tif (!resolvedBuilderNode.assemblerController()) {\n\t\t\tthis.states.error.set(`resolved node '${resolvedNode.path()}' is not a builder node`);\n\t\t\treturn;\n\t\t}\n\t\tif (resolvedBuilderNode.type() != this.type()) {\n\t\t\tthis.states.error.set(\n\t\t\t\t`resolved node '${resolvedNode.path()}' does not have the same type '${resolvedNode.type()}' as current node '${this.type()}'`\n\t\t\t);\n\t\t\treturn;\n\t\t}\n\n\t\tassemblerController.assembler.setGlParentNode(resolvedBuilderNode);\n\t}\n\n\tstatic PARAM_CALLBACK_setCompileRequired(node: BaseBuilderMatNodeType) {\n\t\tnode.PARAM_CALLBACK_setCompileRequired();\n\t}\n\tprivate PARAM_CALLBACK_setCompileRequired() {\n\t\tthis.assemblerController()?.setCompilationRequired(true);\n\t}\n}\n\nexport type BaseBuilderMatNodeType = TypedBuilderMatNode<\n\tMaterialWithCustomMaterials,\n\tShaderAssemblerMaterial,\n\tMatBuilderParamsConfig\n>;\n","import {Constructor} from '../../../../types/GlobalTypes';\nimport {ParamConfig} from '../../utils/params/ParamsConfig';\nexport function DefaultFolderParamConfig<TBase extends Constructor>(Base: TBase) {\n\treturn class Mixin extends Base {\n\t\tdefault = ParamConfig.FOLDER(null);\n\t};\n}\n","import {Constructor} from '../../../../types/GlobalTypes';\nimport {ParamConfig} from '../../utils/params/ParamsConfig';\nexport function TexturesFolderParamConfig<TBase extends Constructor>(Base: TBase) {\n\treturn class Mixin extends Base {\n\t\ttextures = ParamConfig.FOLDER(null);\n\t};\n}\n","import {Constructor} from '../../../../types/GlobalTypes';\nimport {BaseController, MaterialTexturesRecord, SetParamsTextureNodesRecord} from './_BaseController';\nimport {TypedMatNode} from '../_Base';\nimport type {\n\tPointsMaterial,\n\tShaderMaterial,\n\tMeshStandardMaterial,\n\tMeshPhysicalMaterial,\n\tMeshPhongMaterial,\n\tMeshLambertMaterial,\n\tMeshBasicMaterial,\n\tMeshToonMaterial,\n\tMaterial,\n} from 'three';\nimport {NodeParamsConfig, ParamConfig} from '../../utils/params/ParamsConfig';\nimport {isBooleanTrue} from '../../../../core/BooleanValue';\n\nexport interface UniformFogControllers {\n\tuniformFog: UniformFogController;\n}\nexport function FogParamConfig<TBase extends Constructor>(Base: TBase) {\n\treturn class Mixin extends Base {\n\t\t/** @param toggle on if you have a fog in the scene and the material should be affected by it */\n\t\tuseFog = ParamConfig.BOOLEAN(0);\n\t};\n}\n\nclass FogUniformsParamsConfig extends FogParamConfig(NodeParamsConfig) {}\ntype FoggableUniformsMaterial =\n\t| ShaderMaterial\n\t| PointsMaterial\n\t| MeshStandardMaterial\n\t| MeshPhysicalMaterial\n\t| MeshPhongMaterial\n\t| MeshLambertMaterial\n\t| MeshBasicMaterial\n\t| MeshToonMaterial;\nfunction isValidFogMaterial(material?: Material): material is FoggableUniformsMaterial {\n\tif (!material) {\n\t\treturn false;\n\t}\n\treturn (material as PointsMaterial).fog != null;\n}\n\nabstract class FogUniformsMatNode extends TypedMatNode<FoggableUniformsMaterial, FogUniformsParamsConfig> {\n\t// createMaterial() {\n\t// \treturn new Material();\n\t// }\n\tcontrollers!: UniformFogControllers;\n}\n\nexport class UniformFogController extends BaseController {\n\tconstructor(protected override node: FogUniformsMatNode) {\n\t\tsuper(node);\n\t}\n\tstatic async update(node: FogUniformsMatNode) {\n\t\tconst material = await node.material();\n\t\tif (!isValidFogMaterial(material)) {\n\t\t\treturn;\n\t\t}\n\t\tnode.controllers.uniformFog.updateMaterial(material);\n\t}\n\toverride updateMaterial(material: FoggableUniformsMaterial) {\n\t\tconst pv = this.node.pv;\n\t\tmaterial.fog = isBooleanTrue(pv.useFog);\n\t}\n\toverride getTextures(material: FoggableUniformsMaterial, record: MaterialTexturesRecord) {}\n\toverride setParamsFromMaterial(material: FoggableUniformsMaterial, record: SetParamsTextureNodesRecord) {\n\t\tthis.node.p.useFog.set(material.fog);\n\t}\n}\n","import {AssemblerGlControllerNode} from '../../../gl/code/Controller';\nimport {BaseNodeType} from '../../../_Base';\n\nfunction customMaterialBaseSetRecompileRequired(node: AssemblerGlControllerNode) {\n\tnode.assemblerController()?.setCompilationRequired();\n}\nexport const CUSTOM_MAT_PARAM_OPTIONS = {\n\tcallback: (node: BaseNodeType) => customMaterialBaseSetRecompileRequired(node as AssemblerGlControllerNode),\n};\n"],"names":["RayMarchingDebugMode","updateDebugMode","uniforms","data","onBeforeCompileDataJSON"],"sourceRoot":""}