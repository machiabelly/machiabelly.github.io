{"version":3,"file":"_polygonjs_polygonjs_src_core_player_PlayerCommon_ts-_polygonjs_polygonjs_src_engine_function-264718.41d9f36199f3ed0150b5.js","mappings":"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","sources":["webpack:///../@polygonjs/polygonjs/src/core/PolarTransform.ts","webpack:///../@polygonjs/polygonjs/src/core/animation/Position.ts","webpack:///../@polygonjs/polygonjs/src/core/animation/PropertyTarget.ts","webpack:///../@polygonjs/polygonjs/src/core/audio/AudioController.ts","webpack:///../@polygonjs/polygonjs/src/core/audio/NotesBuilder.ts","webpack:///../@polygonjs/polygonjs/src/core/camera/CoreCubeCamera.ts","webpack:///../@polygonjs/polygonjs/src/core/code/PrettierController.ts","webpack:///../@polygonjs/polygonjs/src/core/color/chromotomeWrapper.ts","webpack:///../@polygonjs/polygonjs/src/core/geometry/builders/SphereBuilder.ts","webpack:///../@polygonjs/polygonjs/src/core/geometry/modules/cad/CadMath.ts","webpack:///../@polygonjs/polygonjs/src/core/geometry/modules/csg/CsgConstant.ts","webpack:///../@polygonjs/polygonjs/src/core/geometry/modules/csg/toObject3D/CsgPath2ToObject3D.ts","webpack:///../@polygonjs/polygonjs/src/core/geometry/modules/csg/toObject3D/CsgGeom2ToObject3D.ts","webpack:///../@polygonjs/polygonjs/src/core/geometry/modules/csg/toObject3D/CsgGeom3ToObject3D.ts","webpack:///../@polygonjs/polygonjs/src/core/geometry/modules/csg/math/CsgBoundingBox.ts","webpack:///../@polygonjs/polygonjs/src/core/geometry/modules/csg/CsgObject.ts","webpack:///../@polygonjs/polygonjs/src/core/geometry/modules/csg/math/CsgMat4.ts","webpack:///../@polygonjs/polygonjs/src/core/geometry/modules/tet/TetCommon.ts","webpack:///../@polygonjs/polygonjs/src/core/geometry/modules/tet/utils/findNonDelaunayTets.ts","webpack:///../@polygonjs/polygonjs/src/core/geometry/modules/tet/utils/tetCenter.ts","webpack:///../@polygonjs/polygonjs/src/core/geometry/modules/tet/utils/tetInsideMesh.ts","webpack:///../@polygonjs/polygonjs/src/core/geometry/modules/tet/utils/tetQuality.ts","webpack:///../@polygonjs/polygonjs/src/core/geometry/modules/tet/utils/tetRemoveUnusedPoints.ts","webpack:///../@polygonjs/polygonjs/src/core/geometry/modules/tet/utils/tetSortPoints.ts","webpack:///../@polygonjs/polygonjs/src/core/geometry/modules/tet/utils/tetSphere.ts","webpack:///../@polygonjs/polygonjs/src/core/geometry/operation/Adjacency.ts","webpack:///../@polygonjs/polygonjs/src/core/geometry/operation/Circle3Points.ts","webpack:///../@polygonjs/polygonjs/src/core/geometry/operation/Fuse.ts","webpack:///../@polygonjs/polygonjs/src/core/geometry/operation/Jitter.ts","webpack:///../@polygonjs/polygonjs/src/core/geometry/operation/Polyhedron.ts","webpack:///../@polygonjs/polygonjs/src/core/libs/Potpack.ts","webpack:///../@polygonjs/polygonjs/src/core/lights/AmbientLight.ts","webpack:///../@polygonjs/polygonjs/src/core/lights/AreaLight.ts","webpack:///../@polygonjs/polygonjs/src/core/lights/HemisphereLight.ts","webpack:///../@polygonjs/polygonjs/src/core/lights/LightProbe.ts","webpack:///../@polygonjs/polygonjs/src/core/lights/_Base.ts","webpack:///../@polygonjs/polygonjs/src/core/lights/PointLight.ts","webpack:///../@polygonjs/polygonjs/src/core/physics/CorePhysics.ts","webpack:///../@polygonjs/polygonjs/src/core/physics/PhysicsAttribute.ts","webpack:///../@polygonjs/polygonjs/src/core/physics/PhysicsDebug.ts","webpack:///../@polygonjs/polygonjs/src/core/physics/PhysicsJoint.ts","webpack:///../@polygonjs/polygonjs/src/core/physics/shapes/RBDTrimesh.ts","webpack:///../@polygonjs/polygonjs/src/core/physics/shapes/ConvexHull.ts","webpack:///../@polygonjs/polygonjs/src/core/physics/shapes/HeightField.ts","webpack:///../@polygonjs/polygonjs/src/core/physics/PhysicsRBD.ts","webpack:///../@polygonjs/polygonjs/src/core/physics/PhysicsWorld.ts","webpack:///../@polygonjs/polygonjs/src/core/physics/player/CharacterController.ts","webpack:///../@polygonjs/polygonjs/src/core/physics/player/CorePlayerPhysics.ts","webpack:///../@polygonjs/polygonjs/src/core/physics/player/PhysicsPlayer.ts","webpack:///../@polygonjs/polygonjs/src/core/physics/shapes/RBDCapsule.ts","webpack:///../@polygonjs/polygonjs/src/core/physics/shapes/RBDCone.ts","webpack:///../@polygonjs/polygonjs/src/core/physics/shapes/RBDCuboid.ts","webpack:///../@polygonjs/polygonjs/src/core/physics/shapes/RBDCylinder.ts","webpack:///../@polygonjs/polygonjs/src/core/physics/shapes/RBDSphere.ts","webpack:///../@polygonjs/polygonjs/src/core/physics/shapes/_CommonHeightRadius.ts","webpack:///../@polygonjs/polygonjs/src/core/player/Player.ts","webpack:///../@polygonjs/polygonjs/src/core/player/PlayerCommon.ts","webpack:///../@polygonjs/polygonjs/src/core/post/BlendFunction.ts","webpack:///../@polygonjs/polygonjs/src/core/post/KernelSize.ts","webpack:///../@polygonjs/polygonjs/src/core/reactivity/ObjectPropertyReactivity.ts","webpack:///../@polygonjs/polygonjs/src/core/reactivity/RBDPropertyReactivity.ts","webpack:///../@polygonjs/polygonjs/src/core/wfc/WFCRegister.ts","webpack:///../@polygonjs/polygonjs/src/engine/functions/_AnimationMixer.ts","webpack:///../@polygonjs/polygonjs/src/engine/functions/_MathGeneric.ts","webpack:///../@polygonjs/polygonjs/src/engine/functions/_VectorUtils.ts","webpack:///../@polygonjs/polygonjs/src/engine/nodes/anim/Delay.ts","webpack:///../@polygonjs/polygonjs/src/engine/nodes/anim/Duration.ts","webpack:///../@polygonjs/polygonjs/src/engine/nodes/anim/Easing.ts","webpack:///../@polygonjs/polygonjs/src/engine/nodes/anim/Merge.ts","webpack:///../@polygonjs/polygonjs/src/engine/nodes/anim/Operation.ts","webpack:///../@polygonjs/polygonjs/src/engine/nodes/anim/Position.ts","webpack:///../@polygonjs/polygonjs/src/engine/nodes/anim/PostProcessNetwork.ts","webpack:///../@polygonjs/polygonjs/src/engine/nodes/anim/PropertyValue.ts","webpack:///../@polygonjs/polygonjs/src/engine/nodes/anim/Repeat.ts","webpack:///../@polygonjs/polygonjs/src/core/animation/UpdateCallback.ts","webpack:///../@polygonjs/polygonjs/src/engine/nodes/anim/Target.ts","webpack:///../@polygonjs/polygonjs/src/engine/nodes/anim/_BaseManager.ts","webpack:///../@polygonjs/polygonjs/src/engine/nodes/audio/Volume.ts","webpack:///../@polygonjs/polygonjs/src/engine/nodes/audio/utils/EffectsController.ts","webpack:///../@polygonjs/polygonjs/src/engine/nodes/cop/Builder.ts","webpack:///../@polygonjs/polygonjs/src/engine/nodes/cop/Builder2DArray.ts","webpack:///../@polygonjs/polygonjs/src/engine/nodes/cop/Color.ts","webpack:///../@polygonjs/polygonjs/src/engine/nodes/cop/CubeCamera.ts","webpack:///../@polygonjs/polygonjs/src/engine/nodes/cop/Gif.ts","webpack:///../@polygonjs/polygonjs/src/core/loader/texture/HDR.ts","webpack:///../@polygonjs/polygonjs/src/engine/nodes/cop/ImageHDR.ts","webpack:///../@polygonjs/polygonjs/src/engine/nodes/cop/ImageKTX2.ts","webpack:///../@polygonjs/polygonjs/src/engine/nodes/cop/utils/lightMap/Common.ts","webpack:///../@polygonjs/polygonjs/src/engine/nodes/cop/utils/lightMap/BlurMaterial.ts","webpack:///../@polygonjs/polygonjs/src/engine/nodes/cop/utils/lightMap/BlurPlane.ts","webpack:///../@polygonjs/polygonjs/src/engine/nodes/cop/utils/lightMap/RenderTargetsCombineMaterial.ts","webpack:///../@polygonjs/polygonjs/src/engine/nodes/cop/utils/lightMap/RenderTargetsCombinePlane.ts","webpack:///../@polygonjs/polygonjs/src/engine/nodes/cop/utils/lightMap/LightMapUtils.ts","webpack:///../@polygonjs/polygonjs/src/engine/nodes/cop/utils/lightMap/RenderTargetPair.ts","webpack:///../@polygonjs/polygonjs/src/engine/nodes/cop/utils/LightMapController.ts","webpack:///../@polygonjs/polygonjs/src/engine/nodes/cop/LightMap.ts","webpack:///../@polygonjs/polygonjs/src/engine/nodes/cop/PostProcessNetwork.ts","webpack:///../@polygonjs/polygonjs/src/engine/nodes/cop/Render.ts","webpack:///../@polygonjs/polygonjs/src/engine/nodes/cop/SDFFromObject.ts","webpack:///../@polygonjs/polygonjs/src/engine/nodes/cop/WebCam.ts","webpack:///../@polygonjs/polygonjs/src/engine/nodes/cop/_BaseManager.ts","webpack:///../@polygonjs/polygonjs/src/engine/nodes/cop/utils/BuilderUtils.ts","webpack:///../@polygonjs/polygonjs/src/engine/nodes/cop/utils/DataTextureController.ts","webpack:///../@polygonjs/polygonjs/src/engine/nodes/event/Animation.ts","webpack:///../@polygonjs/polygonjs/src/engine/nodes/event/Block.ts","webpack:///../@polygonjs/polygonjs/src/modules/core/controls/MapControls.js","webpack:///../@polygonjs/polygonjs/src/engine/nodes/event/CameraMapControls.ts","webpack:///../@polygonjs/polygonjs/src/engine/nodes/event/Drag.ts","webpack:///../@polygonjs/polygonjs/src/core/player/KeyEvents.ts","webpack:///../@polygonjs/polygonjs/src/modules/core/controls/PointerLockControls.ts","webpack:///../@polygonjs/polygonjs/src/engine/nodes/event/FirstPersonControls.ts","webpack:///../@polygonjs/polygonjs/src/engine/nodes/event/Keyboard.ts","webpack:///../@polygonjs/polygonjs/src/modules/three/examples/jsm/math/Capsule.js","webpack:///../@polygonjs/polygonjs/src/modules/three/examples/jsm/math/Octree.js","webpack:///../@polygonjs/polygonjs/src/modules/core/controls/collisions/PlayerCollisionsController.ts","webpack:///../@polygonjs/polygonjs/src/modules/core/controls/BaseCollisionHandler.ts","webpack:///../@polygonjs/polygonjs/src/modules/core/controls/MobileJoystickControls.ts","webpack:///../@polygonjs/polygonjs/src/engine/nodes/event/MobileJoystickControls.ts","webpack:///../@polygonjs/polygonjs/src/engine/nodes/event/Mouse.ts","webpack:///../@polygonjs/polygonjs/src/engine/nodes/event/Param.ts","webpack:///../@polygonjs/polygonjs/src/engine/nodes/event/Pointer.ts","webpack:///../@polygonjs/polygonjs/src/engine/nodes/event/PostProcessNetwork.ts","webpack:///../@polygonjs/polygonjs/src/engine/nodes/event/Scene.ts","webpack:///../@polygonjs/polygonjs/src/engine/nodes/event/ScrollTrigger.ts","webpack:///../@polygonjs/polygonjs/src/engine/nodes/event/SetParam.ts","webpack:///../@polygonjs/polygonjs/src/engine/nodes/event/Touch.ts","webpack:///../@polygonjs/polygonjs/src/engine/nodes/event/Window.ts","webpack:///../@polygonjs/polygonjs/src/engine/nodes/event/_BaseInput.ts","webpack:///../@polygonjs/polygonjs/src/engine/nodes/event/_BaseManager.ts","webpack:///../@polygonjs/polygonjs/src/engine/nodes/event/collision/CollisionController.ts","webpack:///../@polygonjs/polygonjs/src/engine/nodes/gl/ColorCorrect.ts","webpack:///../@polygonjs/polygonjs/src/engine/nodes/gl/Compare.ts","webpack:///../@polygonjs/polygonjs/src/engine/nodes/gl/ComputeNormals.ts","webpack:///../@polygonjs/polygonjs/src/engine/nodes/gl/Constant.ts","webpack:///../@polygonjs/polygonjs/src/engine/nodes/gl/SDFRepeat.ts","webpack:///../@polygonjs/polygonjs/src/engine/nodes/gl/VaryingRead.ts","webpack:///../@polygonjs/polygonjs/src/engine/nodes/gl/code/assemblers/textures/TexturePersistedConfig.ts","webpack:///../@polygonjs/polygonjs/src/engine/nodes/js/AnimationAction.ts","webpack:///../@polygonjs/polygonjs/src/engine/nodes/js/ClothSolverStepSimulation.ts","webpack:///../@polygonjs/polygonjs/src/engine/nodes/js/Compare.ts","webpack:///../@polygonjs/polygonjs/src/engine/nodes/js/Constant.ts","webpack:///../@polygonjs/polygonjs/src/engine/nodes/js/Cursor.ts","webpack:///../@polygonjs/polygonjs/src/engine/nodes/js/Easing.ts","webpack:///../@polygonjs/polygonjs/src/engine/nodes/js/GetGeometryNodeObjects.ts","webpack:///../@polygonjs/polygonjs/src/engine/nodes/js/GetMaterial.ts","webpack:///../@polygonjs/polygonjs/src/engine/nodes/js/GetNode.ts","webpack:///../@polygonjs/polygonjs/src/engine/nodes/js/GetObject.ts","webpack:///../@polygonjs/polygonjs/src/engine/nodes/js/GetObjectChild.ts","webpack:///../@polygonjs/polygonjs/src/engine/nodes/js/GetParam.ts","webpack:///../@polygonjs/polygonjs/src/engine/nodes/js/GetTexture.ts","webpack:///../@polygonjs/polygonjs/src/engine/nodes/js/GetVideoProperty.ts","webpack:///../@polygonjs/polygonjs/src/engine/nodes/js/ImportAttribute.ts","webpack:///../@polygonjs/polygonjs/src/engine/nodes/js/OnKeydown.ts","webpack:///../@polygonjs/polygonjs/src/engine/nodes/js/OnKeypress.ts","webpack:///../@polygonjs/polygonjs/src/engine/nodes/js/OnKeyup.ts","webpack:///../@polygonjs/polygonjs/src/engine/nodes/js/OnObjectClick.ts","webpack:///../@polygonjs/polygonjs/src/engine/nodes/js/OnObjectDispatchEvent.ts","webpack:///../@polygonjs/polygonjs/src/engine/nodes/js/OnObjectPointerdown.ts","webpack:///../@polygonjs/polygonjs/src/engine/nodes/js/OnObjectPointerup.ts","webpack:///../@polygonjs/polygonjs/src/engine/nodes/js/OnPointerdown.ts","webpack:///../@polygonjs/polygonjs/src/engine/nodes/js/OnPointerup.ts","webpack:///../@polygonjs/polygonjs/src/engine/nodes/js/OnTick.ts","webpack:///../@polygonjs/polygonjs/src/engine/nodes/js/OnVideoEvent.ts","webpack:///../@polygonjs/polygonjs/src/engine/nodes/js/Param.ts","webpack:///../@polygonjs/polygonjs/src/engine/nodes/js/PauseAudioSource.ts","webpack:///../@polygonjs/polygonjs/src/engine/nodes/js/PlayAnimation.ts","webpack:///../@polygonjs/polygonjs/src/engine/nodes/js/PlayAudioSource.ts","webpack:///../@polygonjs/polygonjs/src/engine/nodes/js/PlayInstrumentNote.ts","webpack:///../@polygonjs/polygonjs/src/engine/nodes/js/RayFromCursor.ts","webpack:///../@polygonjs/polygonjs/src/engine/nodes/js/SetObjectAttribute.ts","webpack:///../@polygonjs/polygonjs/src/engine/nodes/js/SetObjectLookAt.ts","webpack:///../@polygonjs/polygonjs/src/engine/nodes/js/SetObjectPolarTransform.ts","webpack:///../@polygonjs/polygonjs/src/engine/nodes/js/SetObjectPosition.ts","webpack:///../@polygonjs/polygonjs/src/engine/nodes/js/SetObjectRotation.ts","webpack:///../@polygonjs/polygonjs/src/engine/nodes/js/SetObjectScale.ts","webpack:///../@polygonjs/polygonjs/src/engine/nodes/js/SetParam.ts","webpack:///../@polygonjs/polygonjs/src/engine/nodes/js/_BaseAudioSource.ts","webpack:///../@polygonjs/polygonjs/src/engine/nodes/js/_BaseTriggerAndObject.ts","webpack:///../@polygonjs/polygonjs/src/engine/nodes/js/code/assemblers/_Base.ts","webpack:///../@polygonjs/polygonjs/src/engine/nodes/js/code/assemblers/actor/ActorPersistedConfig.ts","webpack:///../@polygonjs/polygonjs/src/engine/nodes/js/code/assemblers/entityBuilder/EntityBuilderAssemblerCommon.ts","webpack:///../@polygonjs/polygonjs/src/engine/nodes/js/code/assemblers/instanceBuilder/InstanceBuilderAssemblerCommon.ts","webpack:///../@polygonjs/polygonjs/src/engine/nodes/js/code/assemblers/objectBuilder/ObjectBuilderAssemblerCommon.ts","webpack:///../@polygonjs/polygonjs/src/engine/nodes/js/code/assemblers/pointBuilder/PointBuilderAssemblerCommon.ts","webpack:///../@polygonjs/polygonjs/src/engine/nodes/js/code/assemblers/softBody/SoftBodyAssembler.ts","webpack:///../@polygonjs/polygonjs/src/engine/nodes/js/code/configs/ShaderConfig.ts","webpack:///../@polygonjs/polygonjs/src/engine/nodes/js/code/configs/VariableConfig.ts","webpack:///../@polygonjs/polygonjs/src/engine/nodes/mat/MeshPhysicalBuilder.ts","webpack:///../@polygonjs/polygonjs/src/engine/nodes/mat/MeshStandardBuilder.ts","webpack:///../@polygonjs/polygonjs/src/engine/nodes/mat/PostProcessNetwork.ts","webpack:///../@polygonjs/polygonjs/src/engine/nodes/mat/_BaseManager.ts","webpack:///../@polygonjs/polygonjs/src/engine/nodes/mat/utils/shadows/pcss/glsl/PCSS.glsl","webpack:///../@polygonjs/polygonjs/src/engine/nodes/mat/utils/shadows/pcss/glsl/PCSSGetShadow.glsl","webpack:///../@polygonjs/polygonjs/src/engine/nodes/mat/utils/PCSSController.ts","webpack:///../@polygonjs/polygonjs/src/engine/nodes/mat/utils/customMaterials/CustomMaterialMesh.ts","webpack:///../@polygonjs/polygonjs/src/engine/nodes/obj/AmbientLight.ts","webpack:///../@polygonjs/polygonjs/src/engine/nodes/obj/AreaLight.ts","webpack:///../@polygonjs/polygonjs/src/core/audio/AudioListener.ts","webpack:///../@polygonjs/polygonjs/src/engine/nodes/obj/AudioListener.ts","webpack:///../@polygonjs/polygonjs/src/engine/nodes/obj/DirectionalLight.ts","webpack:///../@polygonjs/polygonjs/src/engine/nodes/obj/HemisphereLight.ts","webpack:///../@polygonjs/polygonjs/src/engine/nodes/obj/utils/helpers/_BaseLightHelper.ts","webpack:///../@polygonjs/polygonjs/src/engine/nodes/obj/utils/helpers/PointLightHelper.ts","webpack:///../@polygonjs/polygonjs/src/engine/nodes/obj/utils/HelperController.ts","webpack:///../@polygonjs/polygonjs/src/engine/nodes/obj/PointLight.ts","webpack:///../@polygonjs/polygonjs/src/engine/nodes/obj/PostProcessNetwork.ts","webpack:///../@polygonjs/polygonjs/src/engine/nodes/obj/Scene.ts","webpack:///../@polygonjs/polygonjs/src/engine/nodes/obj/SpotLight.ts","webpack:///../@polygonjs/polygonjs/src/engine/nodes/obj/_BaseLight.ts","webpack:///../@polygonjs/polygonjs/src/engine/nodes/obj/_BaseLightTransformed.ts","webpack:///../@polygonjs/polygonjs/src/engine/nodes/obj/_BaseManager.ts","webpack:///../@polygonjs/polygonjs/src/engine/nodes/post/Bloom.ts","webpack:///../@polygonjs/polygonjs/src/engine/nodes/post/Outline.ts","webpack:///../@polygonjs/polygonjs/src/engine/nodes/post/PostProcessNetwork.ts","webpack:///../@polygonjs/polygonjs/src/engine/nodes/post/Render.ts","webpack:///../@polygonjs/polygonjs/src/engine/nodes/post/ToneMapping.ts","webpack:///../@polygonjs/polygonjs/src/engine/nodes/post/utils/effects/UpdateScenePass.ts","webpack:///../@polygonjs/polygonjs/src/engine/nodes/post/UpdateScene.ts","webpack:///../@polygonjs/polygonjs/src/engine/nodes/post/_BaseManager.ts","webpack:///../@polygonjs/polygonjs/src/engine/nodes/post/utils/SelectionController.ts","webpack:///../@polygonjs/polygonjs/src/engine/nodes/rop/PostProcessNetwork.ts","webpack:///../@polygonjs/polygonjs/src/engine/nodes/rop/_BaseManager.ts","webpack:///../@polygonjs/polygonjs/src/engine/nodes/sop/Actor.ts","webpack:///../@polygonjs/polygonjs/src/engine/nodes/sop/ActorInstance.ts","webpack:///../@polygonjs/polygonjs/src/engine/nodes/sop/ActorPoint.ts","webpack:///../@polygonjs/polygonjs/src/engine/nodes/sop/Add.ts","webpack:///../@polygonjs/polygonjs/src/engine/nodes/sop/AmbientLight.ts","webpack:///../@polygonjs/polygonjs/src/engine/nodes/sop/AreaLight.ts","webpack:///../@polygonjs/polygonjs/src/engine/nodes/sop/AttribAddMult.ts","webpack:///../@polygonjs/polygonjs/src/engine/nodes/sop/AttribCast.ts","webpack:///../@polygonjs/polygonjs/src/engine/nodes/sop/AttribCopy.ts","webpack:///../@polygonjs/polygonjs/src/engine/nodes/sop/AttribDelete.ts","webpack:///../@polygonjs/polygonjs/src/engine/nodes/sop/AttribFromTexture.ts","webpack:///../@polygonjs/polygonjs/src/engine/nodes/sop/AttribId.ts","webpack:///../@polygonjs/polygonjs/src/engine/nodes/sop/AttribNormalize.ts","webpack:///../@polygonjs/polygonjs/src/engine/nodes/sop/AttribRemap.ts","webpack:///../@polygonjs/polygonjs/src/engine/nodes/sop/AttribRename.ts","webpack:///../@polygonjs/polygonjs/src/engine/nodes/sop/AttribSetAtIndex.ts","webpack:///../@polygonjs/polygonjs/src/core/math/Interpolate.ts","webpack:///../@polygonjs/polygonjs/src/core/math/octree/Node.ts","webpack:///../@polygonjs/polygonjs/src/core/math/octree/Octree.ts","webpack:///../@polygonjs/polygonjs/src/core/Iterator.ts","webpack:///../@polygonjs/polygonjs/src/engine/nodes/sop/AttribTransfer.ts","webpack:///../@polygonjs/polygonjs/src/engine/nodes/sop/AudioNotes.ts","webpack:///../@polygonjs/polygonjs/src/engine/nodes/sop/BboxScatter.ts","webpack:///../@polygonjs/polygonjs/src/engine/nodes/sop/Boolean.ts","webpack:///../@polygonjs/polygonjs/src/engine/nodes/sop/Box.ts","webpack:///../@polygonjs/polygonjs/src/engine/nodes/sop/BoxLines.ts","webpack:///../@polygonjs/polygonjs/src/engine/nodes/sop/CADBoolean.ts","webpack:///../@polygonjs/polygonjs/src/engine/nodes/sop/CADConvertDimension.ts","webpack:///../@polygonjs/polygonjs/src/engine/nodes/sop/CADFillet.ts","webpack:///../@polygonjs/polygonjs/src/engine/nodes/sop/utils/group/GroupByExpressionHelper.ts","webpack:///../@polygonjs/polygonjs/src/engine/nodes/sop/utils/group/GroupByBoundingBoxHelper.ts","webpack:///../@polygonjs/polygonjs/src/engine/nodes/sop/utils/group/GroupByBoundingObjectHelper.ts","webpack:///../@polygonjs/polygonjs/src/core/geometry/modules/cad/CadCoreEdge.ts","webpack:///../@polygonjs/polygonjs/src/core/geometry/modules/cad/CadCoreFace.ts","webpack:///../@polygonjs/polygonjs/src/engine/nodes/sop/CADGroup.ts","webpack:///../@polygonjs/polygonjs/src/engine/nodes/sop/CADMirror.ts","webpack:///../@polygonjs/polygonjs/src/engine/nodes/sop/CADThickness.ts","webpack:///../@polygonjs/polygonjs/src/engine/nodes/sop/CSGBoolean.ts","webpack:///../@polygonjs/polygonjs/src/engine/nodes/sop/CameraControls.ts","webpack:///../@polygonjs/polygonjs/src/engine/nodes/sop/CameraFPS.ts","webpack:///../@polygonjs/polygonjs/src/engine/nodes/sop/CameraFrameMode.ts","webpack:///../@polygonjs/polygonjs/src/engine/nodes/sop/CameraPostProcess.ts","webpack:///../@polygonjs/polygonjs/src/engine/nodes/sop/CameraProject.ts","webpack:///../@polygonjs/polygonjs/src/engine/nodes/sop/CameraRenderScene.ts","webpack:///../@polygonjs/polygonjs/src/engine/nodes/sop/CameraViewOffset.ts","webpack:///../@polygonjs/polygonjs/src/core/camera/webXR/CoreCameraWebXRAR.ts","webpack:///../@polygonjs/polygonjs/src/engine/nodes/sop/CameraWebXRAR.ts","webpack:///../@polygonjs/polygonjs/src/core/camera/webXR/CoreCameraWebXRVR.ts","webpack:///../@polygonjs/polygonjs/src/engine/nodes/sop/CameraWebXRVR.ts","webpack:///../@polygonjs/polygonjs/src/engine/nodes/sop/Center.ts","webpack:///../@polygonjs/polygonjs/src/engine/nodes/sop/Circle3Points.ts","webpack:///../@polygonjs/polygonjs/src/engine/nodes/sop/Cone.ts","webpack:///../@polygonjs/polygonjs/src/engine/nodes/utils/BaseCopyStamp.ts","webpack:///../@polygonjs/polygonjs/src/engine/nodes/sop/utils/CopyStamp.ts","webpack:///../@polygonjs/polygonjs/src/engine/nodes/sop/Copy.ts","webpack:///../@polygonjs/polygonjs/src/engine/nodes/sop/CubeCamera.ts","webpack:///../@polygonjs/polygonjs/src/engine/nodes/sop/DeleteByName.ts","webpack:///../@polygonjs/polygonjs/src/engine/nodes/sop/EmptyObject.ts","webpack:///../@polygonjs/polygonjs/src/engine/nodes/js/code/assemblers/entityBuilder/_BaseEntityBuilderPersistedConfig.ts","webpack:///../@polygonjs/polygonjs/src/engine/nodes/js/code/assemblers/entityBuilder/EntityBuilderPersistedConfig.ts","webpack:///../@polygonjs/polygonjs/src/engine/nodes/sop/_BaseEntityBuilder.ts","webpack:///../@polygonjs/polygonjs/src/engine/nodes/sop/EntityBuilder.ts","webpack:///../@polygonjs/polygonjs/src/engine/nodes/sop/Facet.ts","webpack:///../@polygonjs/polygonjs/src/engine/nodes/sop/FileMultiOBJ.ts","webpack:///../@polygonjs/polygonjs/src/engine/nodes/sop/FileVOX.ts","webpack:///../@polygonjs/polygonjs/src/engine/nodes/sop/Fuse.ts","webpack:///../@polygonjs/polygonjs/src/engine/nodes/sop/HemisphereLight.ts","webpack:///../@polygonjs/polygonjs/src/engine/nodes/sop/Hexagons.ts","webpack:///../@polygonjs/polygonjs/src/engine/nodes/sop/Hierarchy.ts","webpack:///../@polygonjs/polygonjs/src/engine/nodes/sop/Icosahedron.ts","webpack:///../@polygonjs/polygonjs/src/engine/nodes/sop/Instance.ts","webpack:///../@polygonjs/polygonjs/src/engine/nodes/sop/Jitter.ts","webpack:///../@polygonjs/polygonjs/src/engine/nodes/sop/Layer.ts","webpack:///../@polygonjs/polygonjs/src/engine/nodes/sop/LightProbe.ts","webpack:///../@polygonjs/polygonjs/src/engine/nodes/sop/Line.ts","webpack:///../@polygonjs/polygonjs/src/engine/nodes/sop/Material.ts","webpack:///../@polygonjs/polygonjs/src/engine/nodes/sop/Noise.ts","webpack:///../@polygonjs/polygonjs/src/engine/nodes/sop/ObjectMerge.ts","webpack:///../@polygonjs/polygonjs/src/engine/nodes/sop/ObjectProperties.ts","webpack:///../@polygonjs/polygonjs/src/engine/nodes/sop/ObjectsLayout.ts","webpack:///../@polygonjs/polygonjs/src/engine/nodes/sop/OrthographicCamera.ts","webpack:///../@polygonjs/polygonjs/src/engine/nodes/sop/Palette.ts","webpack:///../@polygonjs/polygonjs/src/engine/nodes/sop/PerspectiveCamera.ts","webpack:///../@polygonjs/polygonjs/src/engine/nodes/sop/PhysicsGround.ts","webpack:///../@polygonjs/polygonjs/src/engine/nodes/sop/PhysicsPlayer.ts","webpack:///../@polygonjs/polygonjs/src/engine/nodes/sop/PhysicsRBDAttributes.ts","webpack:///../@polygonjs/polygonjs/src/engine/nodes/sop/PhysicsRBDJoints.ts","webpack:///../@polygonjs/polygonjs/src/engine/nodes/sop/PhysicsWorld.ts","webpack:///../@polygonjs/polygonjs/src/engine/nodes/sop/Plane.ts","webpack:///../@polygonjs/polygonjs/src/engine/nodes/sop/PointLight.ts","webpack:///../@polygonjs/polygonjs/src/engine/nodes/sop/PolarTransform.ts","webpack:///../@polygonjs/polygonjs/src/engine/nodes/sop/QuadSmooth.ts","webpack:///../@polygonjs/polygonjs/src/engine/nodes/sop/QuadTriangulate.ts","webpack:///../@polygonjs/polygonjs/src/core/geometry/modules/three/graph/triangle/TriangleEdge.ts","webpack:///../@polygonjs/polygonjs/src/core/geometry/modules/three/graph/triangle/TriangleNode.ts","webpack:///../@polygonjs/polygonjs/src/core/geometry/modules/three/graph/triangle/TriangleGraphCommon.ts","webpack:///../@polygonjs/polygonjs/src/core/geometry/modules/three/graph/triangle/TriangleGraph.ts","webpack:///../@polygonjs/polygonjs/src/core/geometry/modules/three/graph/triangle/TriangleGraphUtils.ts","webpack:///../@polygonjs/polygonjs/src/engine/nodes/sop/Quadrangulate.ts","webpack:///../@polygonjs/polygonjs/src/engine/nodes/sop/Ray.ts","webpack:///../@polygonjs/polygonjs/src/engine/nodes/sop/RestAttributes.ts","webpack:///../@polygonjs/polygonjs/src/engine/nodes/sop/SetChildren.ts","webpack:///../@polygonjs/polygonjs/src/engine/nodes/sop/SetGeometry.ts","webpack:///../@polygonjs/polygonjs/src/engine/nodes/sop/utils/SolverIterationStamp.ts","webpack:///../@polygonjs/polygonjs/src/engine/nodes/sop/Solver.ts","webpack:///../@polygonjs/polygonjs/src/engine/nodes/sop/Sort.ts","webpack:///../@polygonjs/polygonjs/src/engine/nodes/sop/Sphere.ts","webpack:///../@polygonjs/polygonjs/src/engine/nodes/sop/Split.ts","webpack:///../@polygonjs/polygonjs/src/engine/nodes/sop/SubnetInput.ts","webpack:///../@polygonjs/polygonjs/src/engine/nodes/sop/Tangent.ts","webpack:///../@polygonjs/polygonjs/src/core/geometry/modules/tet/utils/sortedIndices.ts","webpack:///../@polygonjs/polygonjs/src/core/geometry/modules/tet/utils/tetNeighboursHelper.ts","webpack:///../@polygonjs/polygonjs/src/core/geometry/modules/tet/utils/tetTriangle.ts","webpack:///../@polygonjs/polygonjs/src/core/geometry/modules/tet/TetGeometry.ts","webpack:///../@polygonjs/polygonjs/src/core/geometry/modules/tet/utils/findTetContainingPosition.ts","webpack:///../@polygonjs/polygonjs/src/core/geometry/modules/tet/utils/tetrahedralize.ts","webpack:///../@polygonjs/polygonjs/src/engine/nodes/sop/Tetrahedralize.ts","webpack:///../@polygonjs/polygonjs/src/core/geometry/operation/Tetrahedron.ts","webpack:///../@polygonjs/polygonjs/src/engine/nodes/sop/Tetrahedron.ts","webpack:///../@polygonjs/polygonjs/src/engine/nodes/sop/TransformMulti.ts","webpack:///../@polygonjs/polygonjs/src/engine/nodes/sop/TransformReset.ts","webpack:///../@polygonjs/polygonjs/src/engine/nodes/sop/Tube.ts","webpack:///../@polygonjs/polygonjs/src/engine/nodes/sop/UvUnwrap.ts","webpack:///../@polygonjs/polygonjs/src/core/wfc/WFCFloorGraph.ts","webpack:///../@polygonjs/polygonjs/src/core/wfc/WFCTileConfigSampler.ts","webpack:///../@polygonjs/polygonjs/src/core/wfc/WFCSolver.ts","webpack:///../@polygonjs/polygonjs/src/engine/nodes/sop/WFCSolver.ts","webpack:///../@polygonjs/polygonjs/src/engine/nodes/sop/WFCTileSideName.ts","webpack:///../@polygonjs/polygonjs/src/engine/nodes/sop/WFCTileTransform.ts","webpack:///../@polygonjs/polygonjs/src/engine/nodes/sop/_BaseActor.ts","webpack:///../@polygonjs/polygonjs/src/engine/nodes/sop/_BaseCSG.ts","webpack:///../@polygonjs/polygonjs/src/engine/nodes/sop/_BaseQuad.ts","webpack:///../@polygonjs/polygonjs/src/core/geometry/modules/tet/toObject3D/tetToOuterMesh.ts","webpack:///../@polygonjs/polygonjs/src/core/geometry/modules/tet/toObject3D/tetToTetMesh.ts","webpack:///../@polygonjs/polygonjs/src/core/geometry/modules/tet/TetMaterial.ts","webpack:///../@polygonjs/polygonjs/src/core/geometry/modules/tet/toObject3D/tetToLines.ts","webpack:///../@polygonjs/polygonjs/src/core/geometry/modules/tet/toObject3D/tetToSharedFacesToLine.ts","webpack:///../@polygonjs/polygonjs/src/core/geometry/modules/tet/toObject3D/tetToPoints.ts","webpack:///../@polygonjs/polygonjs/src/core/geometry/modules/tet/toObject3D/tetToCenter.ts","webpack:///../@polygonjs/polygonjs/src/core/geometry/modules/tet/toObject3D/tetToSphere.ts","webpack:///../@polygonjs/polygonjs/src/core/geometry/modules/tet/TetObject.ts","webpack:///../@polygonjs/polygonjs/src/engine/nodes/sop/_BaseTet.ts","webpack:///../@polygonjs/polygonjs/src/engine/nodes/sop/utils/camera/updateCameraTransformParams.ts","webpack:///../@polygonjs/polygonjs/src/engine/nodes/sop/utils/file/_BaseSopFileMulti.ts","webpack:///../@polygonjs/polygonjs/src/engine/nodes/utils/color/PaletteController.ts","webpack:///../@polygonjs/polygonjs/src/engine/operations/sop/Add.ts","webpack:///../@polygonjs/polygonjs/src/engine/operations/sop/AmbientLight.ts","webpack:///../@polygonjs/polygonjs/src/engine/operations/sop/AreaLight.ts","webpack:///../@polygonjs/polygonjs/src/engine/operations/sop/AttribAddMult.ts","webpack:///../@polygonjs/polygonjs/src/engine/operations/sop/AttribCast.ts","webpack:///../@polygonjs/polygonjs/src/engine/operations/sop/AttribCopy.ts","webpack:///../@polygonjs/polygonjs/src/engine/operations/sop/AttribDelete.ts","webpack:///../@polygonjs/polygonjs/src/core/geometry/operation/AttribFromTexture.ts","webpack:///../@polygonjs/polygonjs/src/engine/operations/sop/AttribFromTexture.ts","webpack:///../@polygonjs/polygonjs/src/engine/operations/sop/AttribId.ts","webpack:///../@polygonjs/polygonjs/src/engine/operations/sop/AttribNormalize.ts","webpack:///../@polygonjs/polygonjs/src/engine/operations/sop/AttribRename.ts","webpack:///../@polygonjs/polygonjs/src/engine/operations/sop/AttribSetAtIndex.ts","webpack:///../@polygonjs/polygonjs/src/engine/operations/sop/AudioNotes.ts","webpack:///../@polygonjs/polygonjs/src/engine/operations/sop/BboxScatter.ts","webpack:///../@polygonjs/polygonjs/src/engine/operations/sop/Boolean.ts","webpack:///../@polygonjs/polygonjs/src/engine/operations/sop/Box.ts","webpack:///../@polygonjs/polygonjs/src/engine/operations/sop/CameraProject.ts","webpack:///../@polygonjs/polygonjs/src/engine/operations/sop/CameraViewOffset.ts","webpack:///../@polygonjs/polygonjs/src/engine/operations/sop/Center.ts","webpack:///../@polygonjs/polygonjs/src/engine/operations/sop/CubeCamera.ts","webpack:///../@polygonjs/polygonjs/src/engine/operations/sop/DeleteByName.ts","webpack:///../@polygonjs/polygonjs/src/engine/operations/sop/EmptyObject.ts","webpack:///../@polygonjs/polygonjs/src/core/loader/geometry/VOX.ts","webpack:///../@polygonjs/polygonjs/src/engine/operations/sop/FileVOX.ts","webpack:///../@polygonjs/polygonjs/src/engine/operations/sop/HemisphereLight.ts","webpack:///../@polygonjs/polygonjs/src/engine/operations/sop/Hexagons.ts","webpack:///../@polygonjs/polygonjs/src/engine/operations/sop/Hierarchy.ts","webpack:///../@polygonjs/polygonjs/src/core/geometry/operation/Icosahedron.ts","webpack:///../@polygonjs/polygonjs/src/engine/operations/sop/Icosahedron.ts","webpack:///../@polygonjs/polygonjs/src/engine/operations/sop/Instance.ts","webpack:///../@polygonjs/polygonjs/src/engine/operations/sop/Jitter.ts","webpack:///../@polygonjs/polygonjs/src/engine/operations/sop/LightProbe.ts","webpack:///../@polygonjs/polygonjs/src/engine/operations/sop/Material.ts","webpack:///../@polygonjs/polygonjs/src/engine/operations/sop/ObjectProperties.ts","webpack:///../@polygonjs/polygonjs/src/engine/operations/sop/ObjectsLayout.ts","webpack:///../@polygonjs/polygonjs/src/engine/operations/sop/Palette.ts","webpack:///../@polygonjs/polygonjs/src/engine/operations/sop/PhysicsRBDAttributes.ts","webpack:///../@polygonjs/polygonjs/src/engine/operations/sop/Plane.ts","webpack:///../@polygonjs/polygonjs/src/engine/operations/sop/PointLight.ts","webpack:///../@polygonjs/polygonjs/src/engine/operations/sop/PolarTransform.ts","webpack:///../@polygonjs/polygonjs/src/engine/operations/sop/Ray.ts","webpack:///../@polygonjs/polygonjs/src/engine/operations/sop/RestAttributes.ts","webpack:///../@polygonjs/polygonjs/src/engine/operations/sop/SetChildren.ts","webpack:///../@polygonjs/polygonjs/src/engine/operations/sop/SetGeometry.ts","webpack:///../@polygonjs/polygonjs/src/engine/operations/sop/Sort.ts","webpack:///../@polygonjs/polygonjs/src/engine/operations/sop/Sphere.ts","webpack:///../@polygonjs/polygonjs/src/engine/operations/sop/Tangent.ts","webpack:///../@polygonjs/polygonjs/src/engine/operations/sop/Tube.ts","webpack:///../@polygonjs/polygonjs/src/core/loader/geometry/XAtlas.ts","webpack:///../@polygonjs/polygonjs/src/engine/operations/sop/UvUnwrap.ts","webpack:///../@polygonjs/polygonjs/src/engine/nodes/gl/code/templates/textures/Default.frag.glsl","webpack:///../@polygonjs/polygonjs/src/engine/nodes/gl/code/templates/textures/Default.vert.glsl","webpack:///../@polygonjs/polygonjs/src/engine/nodes/gl/gl/color.glsl","webpack:///../@polygonjs/polygonjs/src/engine/nodes/gl/gl/geometryAttributes/geometryAttributesLookupUv.glsl","webpack:///../@polygonjs/polygonjs/src/engine/nodes/gl/gl/raymarching/sdfRepeat.glsl"],"sourcesContent":["import {Vector3, Quaternion, Matrix4, MathUtils} from 'three';\nimport type {Object3D} from 'three';\n\nexport interface PolarTransformMatrixParams {\n\tcenter: Vector3;\n\tlongitude: number;\n\tlatitude: number;\n\tdepth: number;\n}\n\nconst POLAR_TRANSFORM_AXIS_VERTICAL = new Vector3(0, 1, 0);\nconst POLAR_TRANSFORM_AXIS_HORIZONTAL = new Vector3(-1, 0, 0);\n\nconst centerMatrix = new Matrix4();\nconst longitudeMatrix = new Matrix4();\nconst latitudeMatrix = new Matrix4();\nconst depthMatrix = new Matrix4();\nconst decomposed = {\n\tt: new Vector3(),\n\tq: new Quaternion(),\n\ts: new Vector3(),\n};\n\nexport class CorePolarTransform {\n\tstatic matrix(params: PolarTransformMatrixParams, target: Matrix4) {\n\t\tcenterMatrix.identity();\n\t\tlongitudeMatrix.identity();\n\t\tlatitudeMatrix.identity();\n\t\tdepthMatrix.identity();\n\t\tcenterMatrix.makeTranslation(params.center.x, params.center.y, params.center.z);\n\t\tlongitudeMatrix.makeRotationAxis(POLAR_TRANSFORM_AXIS_VERTICAL, MathUtils.degToRad(params.longitude));\n\t\tlatitudeMatrix.makeRotationAxis(POLAR_TRANSFORM_AXIS_HORIZONTAL, MathUtils.degToRad(params.latitude));\n\t\tdepthMatrix.makeTranslation(0, 0, params.depth);\n\t\ttarget.copy(centerMatrix).multiply(longitudeMatrix).multiply(latitudeMatrix).multiply(depthMatrix);\n\t}\n\tstatic applyMatrixToObject(object: Object3D, matrix: Matrix4) {\n\t\tmatrix.decompose(decomposed.t, decomposed.q, decomposed.s);\n\t\tobject.position.copy(decomposed.t);\n\t\tobject.quaternion.copy(decomposed.q);\n\t\tobject.scale.copy(decomposed.s);\n\t\tobject.updateMatrix();\n\t}\n}\n","import {TypeAssert} from '../../engine/poly/Assert';\n\nexport enum AnimationPositionMode {\n\tRELATIVE = 'relative',\n\tABSOLUTE = 'absolute',\n}\nexport const ANIMATION_POSITION_MODES = [AnimationPositionMode.RELATIVE, AnimationPositionMode.ABSOLUTE];\nexport enum AnimationPositionRelativeTo {\n\tSTART = 'start',\n\tEND = 'end',\n}\nexport const ANIMATION_POSITION_RELATIVE_TOS: AnimationPositionRelativeTo[] = [\n\tAnimationPositionRelativeTo.START,\n\tAnimationPositionRelativeTo.END,\n];\n\n// https://greensock.com/position-parameter/\n// https://greensock.com/docs/v3/GSAP/Timeline\nexport class AnimationPosition {\n\tprivate _mode = AnimationPositionMode.RELATIVE;\n\tprivate _relativeTo: AnimationPositionRelativeTo = AnimationPositionRelativeTo.END;\n\tprivate _offset: number = 0;\n\n\tclone() {\n\t\tconst new_position = new AnimationPosition();\n\t\tnew_position.setMode(this._mode);\n\t\tnew_position.setRelativeTo(this._relativeTo);\n\t\tnew_position.setOffset(this._offset);\n\t\treturn new_position;\n\t}\n\n\tsetMode(mode: AnimationPositionMode) {\n\t\tthis._mode = mode;\n\t}\n\tmode() {\n\t\treturn this._mode;\n\t}\n\tsetRelativeTo(relative_to: AnimationPositionRelativeTo) {\n\t\tthis._relativeTo = relative_to;\n\t}\n\trelativeTo() {\n\t\treturn this._relativeTo;\n\t}\n\tsetOffset(offset: number) {\n\t\tthis._offset = offset;\n\t}\n\toffset() {\n\t\treturn this._offset;\n\t}\n\n\ttoParameter() {\n\t\tswitch (this._mode) {\n\t\t\tcase AnimationPositionMode.RELATIVE:\n\t\t\t\treturn this._relative_position_param();\n\t\t\tcase AnimationPositionMode.ABSOLUTE:\n\t\t\t\treturn this._absolutePositionParam();\n\t\t}\n\t\tTypeAssert.unreachable(this._mode);\n\t}\n\tprivate _relative_position_param() {\n\t\tswitch (this._relativeTo) {\n\t\t\tcase AnimationPositionRelativeTo.END:\n\t\t\t\treturn this._offsetString();\n\t\t\tcase AnimationPositionRelativeTo.START:\n\t\t\t\treturn `<${this._offset}`;\n\t\t}\n\t\tTypeAssert.unreachable(this._relativeTo);\n\t}\n\tprivate _absolutePositionParam() {\n\t\treturn this._offset;\n\t}\n\tprivate _offsetString() {\n\t\tif (this._offset > 0) {\n\t\t\treturn `+=${this._offset}`;\n\t\t} else {\n\t\t\treturn `-=${Math.abs(this._offset)}`;\n\t\t}\n\t}\n}\n","import {Object3D} from 'three';\nimport {BaseNodeType} from '../../engine/nodes/_Base';\nimport {PolyScene} from '../../engine/scene/PolyScene';\n\ninterface PropertyTargetOptions {\n\tnode?: {\n\t\tpath: string;\n\t\trelativeTo: BaseNodeType;\n\t};\n\tobject?: {\n\t\tlist?: Object3D[];\n\t\tmask?: string;\n\t};\n}\nexport class AnimPropertyTarget {\n\tconstructor(private _scene: PolyScene, private _options: PropertyTargetOptions) {}\n\n\tclone() {\n\t\treturn new AnimPropertyTarget(this._scene, this._options);\n\t}\n\n\tobjects() {\n\t\tconst objectData = this._options.object;\n\t\tif (!objectData) {\n\t\t\treturn;\n\t\t}\n\t\tif (objectData.list) {\n\t\t\treturn objectData.list;\n\t\t}\n\t\tconst mask = objectData.mask;\n\t\tif (!mask) {\n\t\t\treturn;\n\t\t}\n\t\treturn this._scene.objectsByMask(mask);\n\t}\n\n\tnode() {\n\t\tif (!this._options.node) {\n\t\t\treturn;\n\t\t}\n\t\tconst options = this._options.node;\n\t\treturn options.relativeTo.node(options.path);\n\t}\n}\n","import {start} from 'tone/build/esm/core/Global';\n\nexport class AudioControllerClass {\n\tprivate static _instance: AudioControllerClass;\n\tstatic instance() {\n\t\treturn (this._instance = this._instance || new AudioControllerClass());\n\t}\n\tprivate _started = false;\n\tasync start() {\n\t\tif (this._started) {\n\t\t\treturn;\n\t\t}\n\t\tawait start();\n\t\treturn;\n\t}\n}\nexport const AudioController = AudioControllerClass.instance();\n","export interface NoteHolder {\n\toctave: number;\n\tnote: string;\n}\n\nexport class NotesBuilder {\n\tstatic ALL_NOTES = ['C', 'D', 'E', 'F', 'G', 'A', 'B'];\n\n\tstatic list(startOctave: number, endOctave: number) {\n\t\tlet noteIndex = 0;\n\t\tconst noteHolders: NoteHolder[] = [];\n\t\tfor (let octave = startOctave; octave <= endOctave; octave++) {\n\t\t\twhile (noteIndex < this.ALL_NOTES.length) {\n\t\t\t\tconst currentNote = this.ALL_NOTES[noteIndex];\n\t\t\t\tconst newNote = currentNote + octave;\n\t\t\t\tnoteHolders.push({note: newNote, octave});\n\n\t\t\t\tif (currentNote !== 'B' && currentNote !== 'E') {\n\t\t\t\t\tconst blackNote = currentNote + '#' + octave;\n\t\t\t\t\tnoteHolders.push({note: blackNote, octave});\n\t\t\t\t}\n\n\t\t\t\tif (octave === endOctave && currentNote === 'B') break;\n\n\t\t\t\tnoteIndex++;\n\t\t\t}\n\t\t\tnoteIndex = 0;\n\t\t}\n\t\treturn noteHolders;\n\t}\n}\n","import {ParamConfig} from '../../engine/nodes/utils/params/ParamsConfig';\nimport {PolyEngine} from '../../engine/Poly';\nimport {OnNodeRegisterCallback} from '../../engine/poly/registers/nodes/NodesRegister';\nimport {Constructor, Number2} from '../../types/GlobalTypes';\n// import {CameraNodeType} from '../../engine/poly/NodeContext';\n// import {ViewerCallbackOptions} from '../../engine/poly/registers/cameras/PolyCamerasRegister';\n// import {ThreejsViewer} from '../../engine/viewers/Threejs';\n// import {CoreCameraPerspectiveFrameMode} from './frameMode/CoreCameraPerspectiveFrameMode';\n// import {CubeCamera} from 'three';\n\ninterface CubeCameraDefault {\n\tresolution: number;\n\tresolutionRange: Number2;\n}\nexport const CUBE_CAMERA_DEFAULT: CubeCameraDefault = {\n\tresolution: 1024,\n\tresolutionRange: [8, 2048],\n};\n\nexport function CubeCameraParamConfigMixin<TBase extends Constructor>(Base: TBase) {\n\treturn class Mixin extends Base {\n\t\t/** @param resolution */\n\t\tresolution = ParamConfig.FLOAT(CUBE_CAMERA_DEFAULT.resolution, {range: CUBE_CAMERA_DEFAULT.resolutionRange});\n\t};\n}\n\nexport const registerCubeCamera: OnNodeRegisterCallback = (poly: PolyEngine) => {\n\t// poly.registerCameraNodeType(CameraNodeType.CUBE);\n\t// poly.registerCamera<CubeCamera>(CubeCamera, (options: ViewerCallbackOptions<CubeCamera>) => {\n\t// \tconst viewer = new ThreejsViewer<CubeCamera>({\n\t// \t\t...options,\n\t// \t\tupdateCameraAspect: (aspect) => {\n\t// \t\t\tCoreCameraPerspectiveFrameMode.updateCameraAspect(options.camera, aspect);\n\t// \t\t},\n\t// \t});\n\t// \treturn viewer;\n\t// });\n};\n","import prettier from 'prettier/standalone';\nimport parserBabel from 'prettier/parser-babel';\n\nexport class PrettierController {\n\tstatic formatJs(JSContent: string) {\n\t\ttry {\n\t\t\treturn prettier.format(JSContent, {\n\t\t\t\tparser: 'babel',\n\t\t\t\tplugins: [parserBabel],\n\t\t\t\tprintWidth: 120,\n\t\t\t\tuseTabs: true,\n\t\t\t});\n\t\t} catch (err) {\n\t\t\tconsole.log(err);\n\t\t\treturn JSContent;\n\t\t}\n\t}\n}\n","import {getAll} from 'chromotome';\nexport interface Palette {\n\tcolors: string[];\n\tname: string;\n}\nimport {VisibleIfParamOptions} from '../../engine/params/utils/OptionsController';\n\nexport const ALL_PALETTES: Palette[] = getAll();\nexport const PALETTES_BY_NAME: Map<string, Palette> = new Map();\nconst USED_PALETTES: Palette[] = [];\nexport let MAX_PALETTE_COLORS_COUNT: number = 0;\nconst minColorsAllowed = 3;\nconst maxColorsAllowed = 5;\n// let paletteWithMaxColors: Palette | undefined = undefined;\nfor (const palette of ALL_PALETTES) {\n\tconst colorsCount = palette.colors.length;\n\tif (colorsCount >= minColorsAllowed && colorsCount <= maxColorsAllowed) {\n\t\tPALETTES_BY_NAME.set(palette.name, palette);\n\t\tUSED_PALETTES.push(palette);\n\t\tif (MAX_PALETTE_COLORS_COUNT < colorsCount) {\n\t\t\tMAX_PALETTE_COLORS_COUNT = colorsCount;\n\t\t\t// paletteWithMaxColors = palette;\n\t\t}\n\t}\n}\n// const sortedPalettes = USED_PALETTES.sort((a, b) => a.colors.length - b.colors.length);\nexport const SORTED_PALETTE_NAMES: string[] = USED_PALETTES.map((p) => p.name).sort();\n\nexport function visibleIfColorsCountAtLeast(minVal: number): VisibleIfParamOptions[] {\n\tconst options: VisibleIfParamOptions[] = [];\n\tfor (let i = minVal; i <= MAX_PALETTE_COLORS_COUNT; i++) {\n\t\toptions.push({colorsCount: i});\n\t}\n\treturn options;\n}\n","import {BufferGeometry, Vector3, Float32BufferAttribute} from 'three';\n\ninterface SphereBuilderParams {\n\tradius: number;\n\twidthSegments: number;\n\theightSegments: number;\n\tphiStart?: number;\n\tphiLength?: number;\n\tthetaStart?: number;\n\tthetaLength?: number;\n\tasLines?: boolean;\n\topen?: boolean;\n}\n\nexport class SphereBuilder {\n\tstatic create(parameters: SphereBuilderParams) {\n\t\tconst geometry = new BufferGeometry();\n\t\t(geometry as any).type = 'SphereBuilder';\n\n\t\tlet {radius, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength, asLines, open} =\n\t\t\tparameters;\n\t\tif (phiStart == null) {\n\t\t\tphiStart = 0;\n\t\t}\n\t\tif (phiLength == null) {\n\t\t\tphiLength = Math.PI * 2;\n\t\t}\n\t\tif (thetaStart == null) {\n\t\t\tthetaStart = 0;\n\t\t}\n\t\tif (thetaLength == null) {\n\t\t\tthetaLength = Math.PI;\n\t\t}\n\t\tif (open == null) {\n\t\t\topen = false;\n\t\t}\n\n\t\twidthSegments = Math.max(3, Math.floor(widthSegments));\n\t\theightSegments = Math.max(2, Math.floor(heightSegments));\n\n\t\tconst thetaEnd = Math.min(thetaStart + thetaLength, Math.PI);\n\n\t\tlet index = 0;\n\t\tconst grid = [];\n\n\t\tconst vertex = new Vector3();\n\t\tconst normal = new Vector3();\n\n\t\t// buffers\n\n\t\tconst indices = [];\n\t\tconst vertices = [];\n\t\tconst normals = [];\n\t\tconst uvs = [];\n\n\t\t// generate vertices, normals and uvs\n\n\t\tfor (let iy = 0; iy <= heightSegments; iy++) {\n\t\t\tconst verticesRow = [];\n\n\t\t\tconst v = iy / heightSegments;\n\n\t\t\t// special case for the poles\n\n\t\t\tlet uOffset = 0;\n\n\t\t\tif (iy == 0 && thetaStart == 0) {\n\t\t\t\tuOffset = 0.5 / widthSegments;\n\t\t\t} else if (iy == heightSegments && thetaEnd == Math.PI) {\n\t\t\t\tuOffset = -0.5 / widthSegments;\n\t\t\t}\n\n\t\t\tfor (let ix = 0; ix <= widthSegments; ix++) {\n\t\t\t\tconst u = ix / widthSegments;\n\n\t\t\t\t// vertex\n\n\t\t\t\tvertex.x = -radius * Math.cos(phiStart + u * phiLength) * Math.sin(thetaStart + v * thetaLength);\n\t\t\t\tvertex.y = radius * Math.cos(thetaStart + v * thetaLength);\n\t\t\t\tvertex.z = radius * Math.sin(phiStart + u * phiLength) * Math.sin(thetaStart + v * thetaLength);\n\n\t\t\t\tvertices.push(vertex.x, vertex.y, vertex.z);\n\n\t\t\t\t// normal\n\n\t\t\t\tnormal.copy(vertex).normalize();\n\t\t\t\tnormals.push(normal.x, normal.y, normal.z);\n\n\t\t\t\t// uv\n\n\t\t\t\tuvs.push(u + uOffset, 1 - v);\n\n\t\t\t\tverticesRow.push(index++);\n\t\t\t}\n\n\t\t\tgrid.push(verticesRow);\n\t\t}\n\n\t\t// indices\n\n\t\tfor (let iy = 0; iy < heightSegments; iy++) {\n\t\t\tfor (let ix = 0; ix < widthSegments; ix++) {\n\t\t\t\tconst a = grid[iy][ix + 1];\n\t\t\t\tconst b = grid[iy][ix];\n\t\t\t\tconst c = grid[iy + 1][ix];\n\t\t\t\tconst d = grid[iy + 1][ix + 1];\n\n\t\t\t\tif (asLines) {\n\t\t\t\t\tif (iy !== 0 || thetaStart > 0) indices.push(a, b);\n\t\t\t\t\tindices.push(b, c);\n\t\t\t\t\tif (open) {\n\t\t\t\t\t\tif (ix < widthSegments - 1) {\n\t\t\t\t\t\t\tindices.push(c, d);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (iy < heightSegments - 1) {\n\t\t\t\t\t\t\tindices.push(a, d);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tif (iy !== 0 || thetaStart > 0) indices.push(a, b, d);\n\t\t\t\t\tif (iy !== heightSegments - 1 || thetaEnd < Math.PI) indices.push(b, c, d);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t// 2 last segments if open\n\t\tif (open) {\n\t\t\tconst a = grid[heightSegments][widthSegments - 1];\n\t\t\tconst b = grid[heightSegments][widthSegments];\n\t\t\tindices.push(a, b);\n\t\t\tconst c = grid[heightSegments - 1][widthSegments];\n\t\t\tconst d = grid[heightSegments][widthSegments];\n\t\t\tindices.push(c, d);\n\t\t}\n\n\t\t// build geometry\n\n\t\tgeometry.setIndex(indices);\n\t\tgeometry.setAttribute('position', new Float32BufferAttribute(vertices, 3));\n\t\tgeometry.setAttribute('normal', new Float32BufferAttribute(normals, 3));\n\t\tgeometry.setAttribute('uv', new Float32BufferAttribute(uvs, 2));\n\t\treturn geometry;\n\t}\n}\n","import {Vector3} from 'three';\nimport {CadLoaderSync} from './CadLoaderSync';\nexport function cadAxis(axisVector3: Vector3) {\n\t// const oc = CadLoader.oc();\n\tconst axis = CadLoaderSync.gp_Ax2;\n\tconst dir = CadLoaderSync.gp_Dir;\n\tdir.SetCoord_2(axisVector3.x, axisVector3.y, axisVector3.z);\n\taxis.SetDirection(dir);\n\treturn axis;\n}\n\nconst tmpV3 = new Vector3();\nexport function cadPlaneXY() {\n\treturn cadPlaneFromAxis(tmpV3.set(0, 0, 1));\n}\nexport function cadPlaneFromAxis(axisVector3: Vector3) {\n\t// const oc = CadLoader.oc();\n\tconst axis = CadLoaderSync.gp_Ax1;\n\tconst dir = CadLoaderSync.gp_Dir;\n\tdir.SetCoord_2(axisVector3.x, axisVector3.y, axisVector3.z);\n\taxis.SetDirection(dir);\n\n\tconst plane = CadLoaderSync.gp_Pln;\n\tplane.SetAxis(axis);\n\treturn plane;\n}\n","import {FrontSide, LineBasicMaterial, MeshStandardMaterial, Color} from 'three';\n// import {ObjectType} from '../Constant';\n// import {CsgObjectType} from './CsgToObject3D';\n\n// export interface CsgObjectData {\n// \ttype: CsgObjectType;\n// }\nexport const step = 0.000001;\n\nconst MESH_MAT = new MeshStandardMaterial({\n\tcolor: 0xffffff,\n\t// vertexColors: true,\n\tside: FrontSide,\n\tmetalness: 0.0,\n\troughness: 0.9,\n});\nconst LINES_MAT = new LineBasicMaterial({\n\tcolor: 0xffffff,\n\tlinewidth: 1,\n\t// vertexColors: true,\n});\n\nexport function csgMaterialMesh(color: Color, wireframe: boolean) {\n\tconst mat = MESH_MAT.clone();\n\tmat.wireframe = wireframe;\n\tmat.color = color;\n\treturn mat;\n}\nexport function csgMaterialLine(color: Color) {\n\tconst mat = LINES_MAT.clone();\n\tmat.color = color;\n\treturn mat;\n}\n\n// export const CSG_MATERIAL = {\n// \t[ObjectType.MESH]: ,\n// \t[ObjectType.LINE_SEGMENTS]: new LineBasicMaterial({\n// \t\tcolor: 0xffffff,\n// \t\tlinewidth: 1,\n// \t\tvertexColors: true,\n// \t}),\n// };\n","import {BufferGeometry, BufferAttribute, Matrix4, Vector3, Quaternion} from 'three';\nimport type {geometries} from '@jscad/modeling';\nimport {ObjectType} from '../../../Constant';\nimport {BaseSopOperation} from '../../../../../engine/operations/sop/_Base';\nimport {csgMaterialLine} from '../CsgConstant';\nimport {CSGTesselationParams} from '../CsgCommon';\nconst matrix = new Matrix4();\nconst t = new Vector3();\nconst q = new Quaternion();\nconst s = new Vector3();\n\nexport function path2ToObject3D(csg: geometries.path2.Path2, tesselationParams: CSGTesselationParams) {\n\tconst geometry = path2ToBufferGeometry(csg);\n\treturn BaseSopOperation.createObject(\n\t\tgeometry,\n\t\tObjectType.LINE_SEGMENTS,\n\t\tcsgMaterialLine(tesselationParams.linesColor)\n\t);\n}\n\nexport function path2ToBufferGeometry(csg: geometries.path2.Path2) {\n\tconst vertices: number[] = [];\n\t// const colors: number[] = [];\n\tconst indices: number[] = [];\n\tconst points2D = csg.points;\n\t// const color = csg.color || [1, 1, 1];\n\tlet i = 0;\n\tfor (const point of points2D) {\n\t\tvertices.push(point[0], 0, point[1]);\n\t\t// colors.push(...color);\n\t\tif (i != 0) {\n\t\t\tindices.push(i - 1);\n\t\t\tindices.push(i);\n\t\t}\n\t\ti++;\n\t}\n\n\tconst geo = new BufferGeometry();\n\tgeo.setAttribute('position', new BufferAttribute(new Float32Array(vertices), 3));\n\tgeo.setIndex(indices);\n\n\tmatrix.elements = csg.transforms;\n\t// remove the translate y of the matrix\n\tmatrix.decompose(t, q, s);\n\tt.y = 0;\n\tmatrix.compose(t, q, s);\n\tgeo.applyMatrix4(matrix);\n\n\treturn geo;\n}\n\nexport function path2Positions(csg: geometries.path2.Path2): Vector3[] {\n\tconst points = csg.points;\n\tconst vectors: Vector3[] = new Array(points.length);\n\tlet i = 0;\n\tfor (const pt of points) {\n\t\tconst vec = new Vector3();\n\t\tvec.x = pt[0];\n\t\tvec.y = 0;\n\t\tvec.z = pt[1];\n\t\tvectors[i] = vec;\n\t\ti++;\n\t}\n\treturn vectors;\n}\n","import {BufferGeometry, BufferAttribute, Matrix4, Vector3, Quaternion} from 'three';\nimport type {geometries} from '@jscad/modeling';\nimport {ObjectType} from '../../../Constant';\nimport {BaseSopOperation} from '../../../../../engine/operations/sop/_Base';\nimport {csgMaterialLine} from '../CsgConstant';\nimport {CSGTesselationParams} from '../CsgCommon';\nconst matrix = new Matrix4();\nconst t = new Vector3();\nconst q = new Quaternion();\nconst s = new Vector3();\n\nexport function geom2ToObject3D(csg: geometries.geom2.Geom2, tesselationParams: CSGTesselationParams) {\n\tconst geometry = geom2ToBufferGeometry(csg);\n\treturn BaseSopOperation.createObject(\n\t\tgeometry,\n\t\tObjectType.LINE_SEGMENTS,\n\t\tcsgMaterialLine(tesselationParams.linesColor)\n\t);\n}\n\nexport function geom2ToBufferGeometry(csg: geometries.geom2.Geom2) {\n\tconst vertices: number[] = [];\n\t// const colors: number[] = [];\n\tconst indices: number[] = [];\n\tconst sides = csg.sides;\n\t// const color = csg.color || [1, 1, 1];\n\tlet i = 0;\n\tfor (const side of sides) {\n\t\tconst point0 = side[0];\n\t\tconst point1 = side[1];\n\t\tvertices.push(point0[0], 0, point0[1]);\n\t\tvertices.push(point1[0], 0, point1[1]);\n\t\t// colors.push(...color);\n\t\t// colors.push(...color);\n\t\t// if (i != 0) {\n\t\tindices.push(i * 2);\n\t\tindices.push(i * 2 + 1);\n\t\t// }\n\t\ti++;\n\t}\n\t// add first point again\n\t// const d\n\t// const point = sides[0][0];\n\t// vertices.push(point[0], 0, point[1]);\n\t// indices.push(i - 1);\n\t// indices.push(i);\n\n\tconst geo = new BufferGeometry();\n\tgeo.setAttribute('position', new BufferAttribute(new Float32Array(vertices), 3));\n\t// geo.setAttribute('color', new BufferAttribute(new Float32Array(colors), 3));\n\tgeo.setIndex(indices);\n\n\tmatrix.elements = csg.transforms;\n\t// remove the translate y of the matrix\n\tmatrix.decompose(t, q, s);\n\tt.y = 0;\n\tmatrix.compose(t, q, s);\n\tgeo.applyMatrix4(matrix);\n\n\treturn geo;\n}\n\nexport function geom2Positions(csg: geometries.geom2.Geom2): Vector3[] {\n\tconst sides = csg.sides;\n\tconst vectors: Vector3[] = new Array(sides.length);\n\tlet i = 0;\n\tfor (const side of sides) {\n\t\tconst vec = new Vector3();\n\t\tconst pt = side[0];\n\t\tvec.x = pt[0];\n\t\tvec.y = pt[1];\n\t\tvec.z = 0;\n\t\tvectors[i] = vec;\n\t\ti++;\n\t}\n\treturn vectors;\n}\n","import {BufferGeometry, BufferAttribute, Matrix4, MathUtils} from 'three';\nimport type {maths, geometries} from '@jscad/modeling';\n// import {PolyDictionary} from '../../../../types/GlobalTypes';\nimport {ObjectType} from '../../../Constant';\nimport {BaseSopOperation} from '../../../../../engine/operations/sop/_Base';\nimport {csgMaterialMesh} from '../CsgConstant';\nimport {CSGTesselationParams} from '../CsgCommon';\nimport {toCreasedNormals} from 'three/examples/jsm/utils/BufferGeometryUtils';\n\n// interface Geom3ToObject3DOptions {\n// \tfacet?: {\n// \t\tangle: number;\n// \t};\n// }\ninterface jscadVertexWithIndex extends maths.vec3.Vec3 {\n\t// positionAsString: string;\n\tindex: number;\n}\n// interface Normal {\n// \tindex: number;\n// \tnormal: Vector3;\n// }\n\n// interface NormalAttributes {\n// \tnormals: Normal[];\n// }\n\nexport function geom3ToObject3D(csg: geometries.geom3.Geom3, options: CSGTesselationParams) {\n\tconst geometry = geom3ToBufferGeometry(csg, options);\n\treturn BaseSopOperation.createObject(\n\t\tgeometry,\n\t\tObjectType.MESH,\n\t\tcsgMaterialMesh(options.meshesColor, options.wireframe)\n\t);\n}\n\nexport function geom3ToBufferGeometry(csg: geometries.geom3.Geom3, options: CSGTesselationParams) {\n\tconst positions: number[] = [];\n\t// const colors: number[] = [];\n\tconst indices: number[] = [];\n\tconst polygons = csg.polygons;\n\tlet currentIndex = 0;\n\t// const color = csg.color;\n\tconst indexByPosition: Map<string, number> = new Map();\n\tfor (const polygon of polygons) {\n\t\tconst polygonjsCount = polygon.vertices.length;\n\t\tconst polygonVertices = polygon.vertices as jscadVertexWithIndex[];\n\t\t// console.log(polygonVertices.map((v) => v.index));\n\t\tfor (const vertex of polygonVertices) {\n\t\t\tconst positionAsString = `${vertex[0]},${vertex[1]},${vertex[2]}`;\n\t\t\tlet index = indexByPosition.get(positionAsString);\n\t\t\tif (index == null) {\n\t\t\t\tindex = currentIndex;\n\t\t\t\tindexByPosition.set(positionAsString, index);\n\t\t\t\tpositions.push(vertex[0], vertex[1], vertex[2]);\n\t\t\t\t// if (color) {\n\t\t\t\t// \tcolors.push(color[0], color[1], color[2]);\n\t\t\t\t// } else {\n\t\t\t\t// \tcolors.push(1, 1, 1);\n\t\t\t\t// }\n\t\t\t\tcurrentIndex++;\n\t\t\t}\n\t\t\tvertex.index = index;\n\t\t}\n\t\tconst first = (polygonVertices[0] as jscadVertexWithIndex).index;\n\t\tfor (let i = 2; i < polygonjsCount; i++) {\n\t\t\tconst second = (polygon.vertices[i - 1] as jscadVertexWithIndex).index;\n\t\t\tconst third = (polygon.vertices[i] as jscadVertexWithIndex).index;\n\t\t\tindices.push(first, second, third);\n\t\t}\n\t}\n\t// let idx = 0;\n\t// console.log(indexByPosition);\n\t// for (let polygon of polygons) {\n\t// \tconst polygonVertices = polygon.vertices as jscadVertexWithIndex[];\n\t// \t// console.log(polygonVertices.map((v) => v.index));\n\t// \tfor (let vertex of polygonVertices) {\n\t// \t\tconst str = `${vertex[0]},${vertex[1]},${vertex[2]}`;\n\t// \t\tif (!indexByPosition.get(str)) {\n\t// \t\t\tindexByPosition.set(str, newIndex++);\n\t// \t\t}\n\t// \t\tvertex.index = idx;\n\t// \t\tvertices.push(vertex[0], vertex[1], vertex[2]);\n\t// \t\tif (polygon.color) {\n\t// \t\t\tcolors.push(polygon.color[0], polygon.color[1], polygon.color[2]);\n\t// \t\t} else {\n\t// \t\t\tcolors.push(1, 1, 1);\n\t// \t\t}\n\t// \t\tidx++;\n\t// \t}\n\t// \tconst first = (polygonVertices[0] as jscadVertexWithIndex).index;\n\t// \tfor (let i = 2; i < polygon.vertices.length; i++) {\n\t// \t\tconst second = (polygon.vertices[i - 1] as jscadVertexWithIndex).index;\n\t// \t\tconst third = (polygon.vertices[i] as jscadVertexWithIndex).index;\n\t// \t\tindices.push(first, second, third);\n\t// \t}\n\t// }\n\n\tconst geo = new BufferGeometry();\n\tgeo.setAttribute('position', new BufferAttribute(new Float32Array(positions), 3));\n\t// geo.setAttribute('color', new BufferAttribute(new Float32Array(colors), 3));\n\tgeo.setIndex(indices);\n\tif (csg.transforms) {\n\t\tconst transforms = new Matrix4();\n\t\ttransforms.set(...csg.transforms).transpose();\n\t\tgeo.applyMatrix4(transforms);\n\t}\n\tgeo.computeVertexNormals();\n\n\t// if (options && options.facetAngle!=null) {\n\treturn toCreasedNormals(geo, MathUtils.degToRad(options.facetAngle));\n\t// } else {\n\t// return geo;\n\t// }\n\n\t// const positions: PolyDictionary<NormalAttributes> = {};\n\t// for (let i = 0; i < geo.attributes.position.count; i++) {\n\t// \tconst pArray = geo.attributes.position.array;\n\t// \tconst x = Math.round(pArray[i * 3] * 100);\n\t// \tconst y = Math.round(pArray[i * 3 + 1] * 100);\n\t// \tconst z = Math.round(pArray[i * 3 + 2] * 100);\n\t// \tconst position = `${x},${y},${z}`;\n\t// \tif (!positions[position]) {\n\t// \t\tpositions[position] = {normals: []};\n\t// \t}\n\t// \tconst nArray = geo.attributes.normal.array;\n\t// \tconst nx = nArray[i * 3];\n\t// \tconst ny = nArray[i * 3 + 1];\n\t// \tconst nz = nArray[i * 3 + 2];\n\t// \tconst normal = new Vector3(nx, ny, nz);\n\t// \tpositions[position].normals.push({index: i, normal: normal});\n\t// }\n\n\t// const toAverage: Map<number, Vector3> = new Map();\n\t// const toAverageIndices: number[] = [];\n\t// for (let p in positions) {\n\t// \tconst currentPosition = positions[p];\n\t// \tconst nl = currentPosition.normals.length;\n\t// \tfor (let i = 0; i < nl - 1; i += 1) {\n\t// \t\tfor (let j = i + 1; j < nl; j += 1) {\n\t// \t\t\tconst n1 = currentPosition.normals[i].normal;\n\t// \t\t\tconst n2 = currentPosition.normals[j].normal;\n\t// \t\t\tif (n1.angleTo(n2) < Math.PI * 0.5 && n1.angleTo(n2) !== 0) {\n\t// \t\t\t\tconst i0 = currentPosition.normals[i].index;\n\t// \t\t\t\tconst i1 = currentPosition.normals[j].index;\n\t// \t\t\t\ttoAverage.set(i0, currentPosition.normals[i].normal);\n\t// \t\t\t\ttoAverage.set(i1, currentPosition.normals[j].normal);\n\t// \t\t\t\ttoAverageIndices.push(i0, i1);\n\t// \t\t\t}\n\t// \t\t}\n\t// \t}\n\t// \tconst averageNormal = new Vector3();\n\t// \tfor (let index of toAverageIndices) {\n\t// \t\tconst normal = toAverage.get(index);\n\t// \t\tif (normal) {\n\t// \t\t\taverageNormal.add(normal);\n\t// \t\t\taverageNormal.normalize();\n\t// \t\t}\n\t// \t}\n\t// \tfor (let index of toAverageIndices) {\n\t// \t\t(geo.attributes.normal.array as number[])[index * 3] = averageNormal.x;\n\t// \t\t(geo.attributes.normal.array as number[])[index * 3 + 1] = averageNormal.y;\n\t// \t\t(geo.attributes.normal.array as number[])[index * 3 + 2] = averageNormal.z;\n\t// \t}\n\n\t// \ttoAverage.clear();\n\t// \ttoAverageIndices.splice(0, toAverageIndices.length);\n\t// }\n\n\t// geo.attributes.normal.needsUpdate = true;\n\n\t// matrix.elements = csg.transforms;\n\t// geo.applyMatrix4(matrix);\n\n\t// return geo;\n}\n\n// export function geom3Positions(csg: geometries.geom3.Geom3): Vector3[] {\n// \tconst bufferGeometry = geom3ToBufferGeometry(csg);\n// \tconst positionAttribute = bufferGeometry.getAttribute('position') as BufferAttribute;\n// \tconst positionsArray = positionAttribute.array;\n// \tconst pointsCount = positionAttribute.itemSize;\n// \tconst vectors: Vector3[] = new Array(pointsCount);\n// \tfor (let i = 0; i < pointsCount; i++) {\n// \t\tconst vec = new Vector3().fromArray(positionsArray, i * 3);\n// \t\tvectors[i] = vec;\n// \t\ti++;\n// \t}\n// \treturn vectors;\n// }\n","import {Box3, Vector3, Matrix4} from 'three';\nimport {geometries} from '@jscad/modeling';\nexport type CsgGeometry = geometries.path2.Path2 | geometries.geom2.Geom2 | geometries.geom3.Geom3;\n\nconst _min = new Vector3();\nconst _max = new Vector3();\nconst _mat4 = new Matrix4();\n\nexport function csgBoundingBoxPath2(geometry: geometries.path2.Path2, target: Box3) {\n\tconst points = geometry.points;\n\n\t// init\n\tif (points.length != 0) {\n\t\tconst firstPoint = points[0];\n\t\t_min.set(firstPoint[0], 0, firstPoint[1]);\n\t\t_max.copy(_min);\n\t}\n\n\t// compute\n\tfor (const vertex of points) {\n\t\t_min.x = Math.min(_min.x, vertex[0]);\n\t\t_min.y = Math.min(_min.z, vertex[1]);\n\t\t_max.x = Math.max(_max.x, vertex[0]);\n\t\t_max.y = Math.max(_max.z, vertex[1]);\n\t}\n\n\ttarget.min.copy(_min);\n\ttarget.max.copy(_max);\n\n\t_mat4.elements = geometry.transforms;\n\ttarget.applyMatrix4(_mat4);\n}\n\nexport function csgBoundingBoxGeom2(geometry: geometries.geom2.Geom2, target: Box3) {\n\tconst sides = geometry.sides;\n\n\t// init\n\tif (sides.length != 0) {\n\t\tconst firstSide = sides[0];\n\t\tconst firstVertex = firstSide[0];\n\t\t_min.set(firstVertex[0], 0, firstVertex[1]);\n\t\t_max.copy(_min);\n\t}\n\n\t// compute\n\tfor (const side of sides) {\n\t\tfor (const vertex of side) {\n\t\t\t_min.x = Math.min(_min.x, vertex[0]);\n\t\t\t_min.y = Math.min(_min.z, vertex[1]);\n\t\t\t_max.x = Math.max(_max.x, vertex[0]);\n\t\t\t_max.y = Math.max(_max.z, vertex[1]);\n\t\t}\n\t}\n\n\ttarget.min.copy(_min);\n\ttarget.max.copy(_max);\n\n\t_mat4.elements = geometry.transforms;\n\ttarget.applyMatrix4(_mat4);\n}\n\nexport function csgBoundingBoxGeom3(geometry: geometries.geom3.Geom3, target: Box3) {\n\tconst polygons = geometry.polygons;\n\n\t// init\n\tif (polygons.length != 0) {\n\t\tconst firstPolygon = polygons[0];\n\t\tconst vertices = firstPolygon.vertices;\n\t\tif (vertices.length != 0) {\n\t\t\tconst firstVertex = vertices[0];\n\t\t\t_min.set(firstVertex[0], firstVertex[1], firstVertex[2]);\n\t\t\t_max.copy(_min);\n\t\t}\n\t}\n\n\t// compute\n\tfor (const polygon of polygons) {\n\t\tconst vertices = polygon.vertices;\n\t\tfor (const vertex of vertices) {\n\t\t\t_min.x = Math.min(_min.x, vertex[0]);\n\t\t\t_min.y = Math.min(_min.y, vertex[1]);\n\t\t\t_min.z = Math.min(_min.z, vertex[2]);\n\t\t\t_max.x = Math.max(_max.x, vertex[0]);\n\t\t\t_max.y = Math.max(_max.y, vertex[1]);\n\t\t\t_max.z = Math.max(_max.z, vertex[2]);\n\t\t}\n\t}\n\ttarget.min.copy(_min);\n\ttarget.max.copy(_max);\n\n\t_mat4.elements = geometry.transforms;\n\ttarget.applyMatrix4(_mat4);\n}\n","import {Object3D, Material, Matrix4, Box3, Sphere, Vector3} from 'three';\nimport {CsgGeometryType, CsgTypeMap, CSGTesselationParams} from './CsgCommon';\nimport {csgGeometryTypeFromGeometry} from './CsgCoreType';\nimport {ObjectContent, CoreObjectType, ObjectGeometryMap, objectContentCopyProperties} from '../../ObjectContent';\nimport {path2ToObject3D} from './toObject3D/CsgPath2ToObject3D';\nimport {geom2ToObject3D} from './toObject3D/CsgGeom2ToObject3D';\nimport {geom3ToObject3D} from './toObject3D/CsgGeom3ToObject3D';\nimport {matrix4ToMat4} from './math/CsgMat4';\nimport {csgBoundingBoxPath2, csgBoundingBoxGeom2, csgBoundingBoxGeom3} from './math/CsgBoundingBox';\nimport {TypeAssert} from '../../../../engine/poly/Assert';\nimport {CoreType} from '../../../Type';\n\nconst _box = new Box3();\nconst _size = new Vector3();\n\nexport class CsgObject<T extends CsgGeometryType> implements ObjectContent<CoreObjectType.CSG> {\n\tpublic visible = true;\n\tget geometry() {\n\t\treturn this._geometry as ObjectGeometryMap[CoreObjectType.CSG];\n\t}\n\tget type() {\n\t\treturn this._type;\n\t}\n\tuserData = {};\n\tname = '';\n\tcastShadow = true;\n\treceiveShadow = true;\n\trenderOrder = 0;\n\tfrustumCulled = true;\n\tmatrixAutoUpdate = false;\n\tmaterial: Material | undefined;\n\tchildren: ObjectContent<CoreObjectType.CSG>[] = [];\n\tparent: ObjectContent<CoreObjectType.CSG> | null = null;\n\tprivate _type: T;\n\tconstructor(private _geometry: CsgTypeMap[T]) {\n\t\tthis._type = csgGeometryTypeFromGeometry(this._geometry);\n\t\tthis._validate();\n\t}\n\n\tsetGeometry<TE extends CsgGeometryType>(geometry: CsgTypeMap[TE]) {\n\t\tthis._geometry = geometry as CsgTypeMap[T];\n\t\tthis._validate();\n\t}\n\tprivate _validate() {\n\t\tconst type = csgGeometryTypeFromGeometry(this._geometry) as T;\n\t\tif (type) {\n\t\t\tthis._type = type;\n\t\t} else {\n\t\t\tconsole.error('no type for geometry', this._geometry);\n\t\t}\n\t}\n\tcsgGeometry() {\n\t\treturn this.geometry! as CsgTypeMap[T];\n\t}\n\tdispose() {}\n\tapplyMatrix4(matrix: Matrix4) {\n\t\tmatrix4ToMat4(matrix, this.csgGeometry().transforms);\n\t}\n\tadd(...object: ObjectContent<CoreObjectType>[]) {}\n\tremove(...object: ObjectContent<CoreObjectType>[]) {}\n\tdispatchEvent(event: {type: string}) {}\n\ttraverse(callback: (object: CsgObject<T>) => any) {\n\t\tcallback(this);\n\t}\n\n\tclone(): CsgObject<T> {\n\t\t// const geometry = cloneCsgGeometry(this.type, this.csgGeometry());\n\t\tconst geometry = JSON.parse(JSON.stringify(this.csgGeometry()));\n\t\tconst clone = new CsgObject(geometry) as CsgObject<T>;\n\n\t\tobjectContentCopyProperties(this, clone);\n\t\treturn clone;\n\t}\n\ttoObject3D(tesselationParams: CSGTesselationParams): Object3D | Object3D[] | undefined {\n\t\tconst object = CsgObject.toObject3D(this, this.type, tesselationParams);\n\t\tif (object) {\n\t\t\tif (CoreType.isArray(object)) {\n\t\t\t\tfor (const element of object) {\n\t\t\t\t\tobjectContentCopyProperties(this, element);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tobjectContentCopyProperties(this, object);\n\t\t\t}\n\t\t}\n\t\treturn object;\n\t}\n\n\tstatic toObject3D<T extends CsgGeometryType>(\n\t\tcsgObject: CsgObject<T>,\n\t\ttype: T,\n\t\ttesselationParams: CSGTesselationParams\n\t): Object3D | Object3D[] | undefined {\n\t\tswitch (type) {\n\t\t\tcase CsgGeometryType.PATH2: {\n\t\t\t\treturn path2ToObject3D(csgObject.csgGeometry() as CsgTypeMap[CsgGeometryType.PATH2], tesselationParams);\n\t\t\t}\n\t\t\tcase CsgGeometryType.GEOM2: {\n\t\t\t\treturn geom2ToObject3D(csgObject.csgGeometry() as CsgTypeMap[CsgGeometryType.GEOM2], tesselationParams);\n\t\t\t}\n\t\t\tcase CsgGeometryType.GEOM3: {\n\t\t\t\treturn geom3ToObject3D(csgObject.csgGeometry() as CsgTypeMap[CsgGeometryType.GEOM3], tesselationParams);\n\t\t\t}\n\t\t}\n\t\tTypeAssert.unreachable(type);\n\t}\n\n\tboundingBox(target: Box3): void {\n\t\t// using the measurement functions from jscad\n\t\t// modifies the geometry matrix,\n\t\t// which shouldn't happen\n\t\tconst type = this.type;\n\t\tswitch (type) {\n\t\t\tcase CsgGeometryType.PATH2: {\n\t\t\t\treturn csgBoundingBoxPath2(this.csgGeometry() as CsgTypeMap[CsgGeometryType.PATH2], target);\n\t\t\t}\n\t\t\tcase CsgGeometryType.GEOM2: {\n\t\t\t\treturn csgBoundingBoxGeom2(this.csgGeometry() as CsgTypeMap[CsgGeometryType.GEOM2], target);\n\t\t\t}\n\t\t\tcase CsgGeometryType.GEOM3: {\n\t\t\t\treturn csgBoundingBoxGeom3(this.csgGeometry() as CsgTypeMap[CsgGeometryType.GEOM3], target);\n\t\t\t}\n\t\t}\n\t\tTypeAssert.unreachable(type);\n\t}\n\tboundingSphere(target: Sphere): void {\n\t\tthis.boundingBox(_box);\n\t\t_box.getSize(_size);\n\t\t_box.getSize(target.center);\n\t\tconst diameter = Math.max(_size.x, _size.y, _size.z);\n\t\ttarget.radius = diameter * 0.5;\n\t}\n}\n","import {Matrix4, Vector3} from 'three';\nimport {CsgGeometry, CsgGeometryType} from '../CsgCommon';\nimport {csgGeometryTypeFromGeometry} from '../CsgCoreType';\nimport {maths, geometries} from '@jscad/modeling';\nimport {TypeAssert} from '../../../../../engine/poly/Assert';\nconst {mat4} = maths;\n\nconst TMP_MAT4 = new Matrix4();\nconst TMP_VEC3 = new Vector3();\n\n/*\n * from jscad source, but with typescript\n */\nconst isIdentity = (matrix: maths.mat4.Mat4) =>\n\tmatrix[0] === 1 &&\n\tmatrix[1] === 0 &&\n\tmatrix[2] === 0 &&\n\tmatrix[3] === 0 &&\n\tmatrix[4] === 0 &&\n\tmatrix[5] === 1 &&\n\tmatrix[6] === 0 &&\n\tmatrix[7] === 0 &&\n\tmatrix[8] === 0 &&\n\tmatrix[9] === 0 &&\n\tmatrix[10] === 1 &&\n\tmatrix[11] === 0 &&\n\tmatrix[12] === 0 &&\n\tmatrix[13] === 0 &&\n\tmatrix[14] === 0 &&\n\tmatrix[15] === 1;\nexport function geom3ApplyTransforms(geom: geometries.geom3.Geom3) {\n\tif (isIdentity(geom.transforms)) return;\n\n\tTMP_MAT4.elements = geom.transforms;\n\tconst polygons = geom.polygons;\n\tfor (const polygon of polygons) {\n\t\tconst vertices = polygon.vertices;\n\t\tfor (const vertex of vertices) {\n\t\t\ttransformVec3(vertex, TMP_MAT4);\n\t\t}\n\t}\n\tmat4.identity(geom.transforms);\n}\nexport function path2ApplyTransforms(geom: geometries.path2.Path2) {\n\tif (isIdentity(geom.transforms)) return;\n\n\tTMP_MAT4.elements = geom.transforms;\n\tconst points = geom.points;\n\tfor (const point of points) {\n\t\ttransformVec2(point, TMP_MAT4);\n\t}\n\tmat4.identity(geom.transforms);\n}\n\n// const vec2transform = (out, vector, matrix) => {\n// \tconst x = vector[0]\n// \tconst y = vector[1]\n// \tout[0] = matrix[0] * x + matrix[4] * y + matrix[12]\n// \tout[1] = matrix[1] * x + matrix[5] * y + matrix[13]\n// \treturn out\n//   }\n\nexport function csgApplyTransform(csg: CsgGeometry) {\n\tconst type = csgGeometryTypeFromGeometry(csg);\n\tswitch (type) {\n\t\tcase CsgGeometryType.PATH2: {\n\t\t\treturn path2ApplyTransforms(csg as geometries.path2.Path2);\n\t\t}\n\t\tcase CsgGeometryType.GEOM2: {\n\t\t\treturn geom2ApplyTransforms(csg as geometries.geom2.Geom2);\n\t\t}\n\t\tcase CsgGeometryType.GEOM3: {\n\t\t\treturn geom3ApplyTransforms(csg as geometries.geom3.Geom3);\n\t\t}\n\t}\n\tTypeAssert.unreachable(type);\n}\n\nexport function matrix4ToMat4(matrix4: Matrix4, target: maths.mat4.Mat4) {\n\tconst elements = matrix4.elements;\n\ttarget[0] = elements[0];\n\ttarget[1] = elements[1];\n\ttarget[2] = elements[2];\n\ttarget[3] = elements[3];\n\ttarget[4] = elements[4];\n\ttarget[5] = elements[5];\n\ttarget[6] = elements[6];\n\ttarget[7] = elements[7];\n\ttarget[8] = elements[8];\n\ttarget[9] = elements[9];\n\ttarget[10] = elements[10];\n\ttarget[11] = elements[11];\n\ttarget[12] = elements[12];\n\ttarget[13] = elements[13];\n\ttarget[14] = elements[14];\n\ttarget[15] = elements[15];\n}\n// export function mat4Copy(src: maths.mat4.Mat4, target: maths.mat4.Mat4) {\n// \ttarget[0] = src[0];\n// \ttarget[1] = src[1];\n// \ttarget[2] = src[2];\n// \ttarget[3] = src[3];\n// \ttarget[4] = src[4];\n// \ttarget[5] = src[5];\n// \ttarget[6] = src[6];\n// \ttarget[7] = src[7];\n// \ttarget[8] = src[8];\n// \ttarget[9] = src[9];\n// \ttarget[10] = src[10];\n// \ttarget[11] = src[11];\n// \ttarget[12] = src[12];\n// \ttarget[13] = src[13];\n// \ttarget[14] = src[14];\n// \ttarget[15] = src[15];\n// }\n\nexport function csgApplyMatrix4(csg: CsgGeometry, matrix4: Matrix4) {\n\tmatrix4ToMat4(matrix4, csg.transforms);\n\tcsgApplyTransform(csg);\n}\n\nfunction transformVec2(vec2: maths.vec2.Vec2, matrix4: Matrix4) {\n\tTMP_VEC3.x = vec2[0];\n\tTMP_VEC3.y = 0;\n\tTMP_VEC3.z = vec2[1];\n\tTMP_VEC3.applyMatrix4(matrix4);\n\tvec2[0] = TMP_VEC3.x;\n\tvec2[1] = TMP_VEC3.z;\n}\nfunction transformVec3(vec3: maths.vec3.Vec3, matrix4: Matrix4) {\n\tTMP_VEC3.x = vec3[0];\n\tTMP_VEC3.y = vec3[1];\n\tTMP_VEC3.z = vec3[2];\n\tTMP_VEC3.applyMatrix4(matrix4);\n\tvec3[0] = TMP_VEC3.x;\n\tvec3[1] = TMP_VEC3.y;\n\tvec3[2] = TMP_VEC3.z;\n}\nexport function geom2ApplyTransforms(geom: geometries.geom2.Geom2) {\n\tif (isIdentity(geom.transforms)) {\n\t\treturn;\n\t}\n\n\t// apply transforms to each side\n\tconst sides = geom.sides;\n\tTMP_MAT4.elements = geom.transforms;\n\tfor (const side of sides) {\n\t\ttransformVec2(side[0], TMP_MAT4);\n\t\ttransformVec2(side[1], TMP_MAT4);\n\t}\n\tmat4.identity(geom.transforms);\n}\n","// export type TetGeometry = any;\n\nimport {Vector3} from 'three';\nimport {Number3, Number4} from '../../../../types/GlobalTypes';\n\nexport type String3 = [string, string, string];\nexport interface TetNeighbourData {\n\tid: number;\n\tfaceIndex: number;\n}\ntype TetPointIds = Number4;\n\nexport type TetNeighbourDataOrNull = TetNeighbourData | null;\nexport type TetNeighbourDatas = [\n\tTetNeighbourDataOrNull,\n\tTetNeighbourDataOrNull,\n\tTetNeighbourDataOrNull,\n\tTetNeighbourDataOrNull\n];\nexport interface TetNeighbourDataWithSource {\n\t// faceIndex: number;\n\tpointIds: Number3;\n\t// tetPointIds: TetPointIds;\n\t// faceIndex: number;\n\t// neighbourData: TetNeighbourDataOrNull;\n}\nexport interface TetrahedronPoint {\n\tid: number;\n\tposition: Vector3;\n}\nexport interface TetrahedronSphere {\n\tcenter: Vector3;\n\tradius: number;\n}\nexport interface Tetrahedron {\n\tid: number;\n\tpointIds: TetPointIds;\n\tneighbours: TetNeighbourDatas;\n\tsphere: TetrahedronSphere;\n\tdisposed: boolean;\n}\nexport interface TetTesselationParams {\n\tscale: number;\n\tdisplayOuterMesh: boolean;\n\tdisplayTetMesh: boolean;\n\tdisplayLines: boolean;\n\tdisplaySharedFaces: boolean;\n\tdisplayPoints: boolean;\n\tdisplayCenter: boolean;\n\tdisplaySphere: boolean;\n}\nexport interface TetOBJTesselationParams {\n\tTetScale: number;\n\tTetDisplayOuterMesh: boolean;\n\tTetDisplayTetMesh: boolean;\n\tTetDisplayLines: boolean;\n\tTetDisplaySharedFaces: boolean;\n\tTetDisplayPoints: boolean;\n\tTetDisplayCenter: boolean;\n\tTetDisplaySphere: boolean;\n}\n\ntype Number3_4 = [Number3, Number3, Number3, Number3];\ntype Vector3_4 = [Vector3, Vector3, Vector3, Vector3];\nexport const TET_FACE_POINT_INDICES: Number3_4 = [\n\t[2, 1, 0],\n\t[0, 1, 3],\n\t[1, 2, 3],\n\t[2, 0, 3],\n];\nexport const TET_FACE_OPPOSITE_POINT_INDICES: Number4 = [3, 2, 0, 1];\nexport const TET_VERTICES_BASE: Number3_4 = [\n\t[1, 1, 1],\n\t[-1, -1, 1],\n\t[-1, 1, -1],\n\t[1, -1, -1],\n];\n\nexport const TET_VERTICES0: Number3_4 = [\n\t[-1, 0, -1],\n\t[1, 0, -1],\n\t[0, 1, 1],\n\t[0, -1, 1],\n];\nexport const TET_VERTICES1: Number3_4 = [\n\t[0, 0, -1],\n\t[-1, 1, 1],\n\t[-1, -1, 1],\n\t[1, 0, 1],\n];\nexport const TET_VERTICES2: Number3_4 = [\n\t[-1, 0, -1],\n\t[0, 0, 1],\n\t[1, -1, -1],\n\t[1, 1, -1],\n];\nexport const TET_VERTICES3: Number3_4 = [\n\t[0, 1, -1],\n\t[0, -1, -1],\n\t[1, 0, 1],\n\t[-1, 0, 1],\n];\nexport const TET_VERTICES4: Number3_4 = [\n\t[-1, -1, -1],\n\t[-1, 1, -1],\n\t[0, 0, 1],\n\t[1, 0, -1],\n];\nexport const TET_VERTICES5: Number3_4 = [\n\t[-1, 0, 1],\n\t[0, 0, -1],\n\t[1, 1, 1],\n\t[1, -1, 1],\n];\n// Y\nexport const TET_VERTICES6: Number3_4 = [\n\t[-1, -1, -1],\n\t[1, -1, -1],\n\t[0, 1, -1],\n\t[0, 0, 1],\n];\nexport const TET_VERTICES7: Number3_4 = [\n\t[0, -1, 1],\n\t[0, 0, -1],\n\t[-1, 1, 1],\n\t[1, 1, 1],\n];\nexport const TET_VERTICES8: Number3_4 = [\n\t[0, 0, -1],\n\t[0, 1, 1],\n\t[-1, -1, 1],\n\t[1, -1, 1],\n];\nexport const TET_VERTICES9: Number3_4 = [\n\t[0, 0, 1],\n\t[0, -1, -1],\n\t[-1, 1, -1],\n\t[1, 1, -1],\n];\n\nfunction _toVectors(a: Number3_4) {\n\treturn a.map((v) => new Vector3().fromArray(v)) as Vector3_4;\n}\nexport const TET_VERTICES_V_BASE: Vector3_4 = _toVectors(TET_VERTICES_BASE);\nexport const TET_VERTICES_V0: Vector3_4 = _toVectors(TET_VERTICES0);\nexport const TET_VERTICES_V1: Vector3_4 = _toVectors(TET_VERTICES1);\nexport const TET_VERTICES_V2: Vector3_4 = _toVectors(TET_VERTICES2);\nexport const TET_VERTICES_V3: Vector3_4 = _toVectors(TET_VERTICES3);\nexport const TET_VERTICES_V4: Vector3_4 = _toVectors(TET_VERTICES4);\nexport const TET_VERTICES_V5: Vector3_4 = _toVectors(TET_VERTICES5);\nexport const TET_VERTICES_V6: Vector3_4 = _toVectors(TET_VERTICES6);\nexport const TET_VERTICES_V7: Vector3_4 = _toVectors(TET_VERTICES7);\nexport const TET_VERTICES_V8: Vector3_4 = _toVectors(TET_VERTICES8);\nexport const TET_VERTICES_V9: Vector3_4 = _toVectors(TET_VERTICES9);\n\nexport const VERTICES_X = [\n\tTET_VERTICES_V0,\n\tTET_VERTICES_V1,\n\tTET_VERTICES_V2,\n\tTET_VERTICES_V3,\n\tTET_VERTICES_V4,\n\tTET_VERTICES_V5,\n];\nexport const VERTICES_Y = [\n\tTET_VERTICES_V0,\n\tTET_VERTICES_V6,\n\tTET_VERTICES_V7,\n\tTET_VERTICES_V3,\n\tTET_VERTICES_V8,\n\tTET_VERTICES_V9,\n];\n","import {TetGeometry} from '../TetGeometry';\nimport {Vector3} from 'three';\nimport {isPointInTetCircumSphere} from './tetSphere';\n\nconst visitedTets = new Set<number>();\nconst stack: number[] = [];\nexport function findNonDelaunayTetsFromSinglePointCheck(\n\ttetGeometry: TetGeometry,\n\tstartTetId: number,\n\taddedPoint: Vector3,\n\tinvalidTets: number[]\n) {\n\tvisitedTets.clear();\n\tinvalidTets.length = 0;\n\tstack.length = 0;\n\tstack.push(startTetId);\n\n\twhile (stack.length > 0) {\n\t\tconst tetId = stack.pop()!;\n\t\tif (visitedTets.has(tetId)) {\n\t\t\tcontinue;\n\t\t}\n\t\tvisitedTets.add(tetId);\n\t\tconst tet = tetGeometry.tetrahedrons.get(tetId);\n\n\t\tif (!tet) {\n\t\t\tthrow `findNonDelaunayTetsFromSinglePointCheck: tet not found (${tetId})`;\n\t\t\tcontinue;\n\t\t}\n\t\tinvalidTets.push(tetId);\n\n\t\tfor (const neighbourData of tet.neighbours) {\n\t\t\tif (neighbourData) {\n\t\t\t\tif (!visitedTets.has(neighbourData.id)) {\n\t\t\t\t\t// delaunay check\n\t\t\t\t\tconst neighbourTet = tetGeometry.tetrahedrons.get(neighbourData.id);\n\t\t\t\t\tif (neighbourTet?.disposed) {\n\t\t\t\t\t\tconsole.error('is disposed');\n\t\t\t\t\t\tthrow 'is disposed';\n\t\t\t\t\t}\n\t\t\t\t\tif (neighbourTet && isPointInTetCircumSphere(neighbourTet, addedPoint)) {\n\t\t\t\t\t\tstack.push(neighbourTet.id);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nconst badTetIds: Set<number> = new Set();\nexport function findNonDelaunayTetsFromMultiplePointsCheck(tetGeometry: TetGeometry, invalidTets: number[]) {\n\tbadTetIds.clear();\n\ttetGeometry.points.forEach((point, pointId) => {\n\t\ttetGeometry.tetrahedrons.forEach((tet) => {\n\t\t\tif (!badTetIds.has(tet.id) && !tet.pointIds.includes(pointId)) {\n\t\t\t\tif (isPointInTetCircumSphere(tet, point.position)) {\n\t\t\t\t\tbadTetIds.add(tet.id);\n\t\t\t\t\t// console.log('tet', tet.id, 'includes point', point.id, '. Its ids are: ', tet.pointIds.join(', '));\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t});\n\n\tinvalidTets.length = 0;\n\tbadTetIds.forEach((tetId) => {\n\t\tinvalidTets.push(tetId);\n\t});\n}\n","import {TetGeometry} from '../TetGeometry';\nimport {Vector3} from 'three';\n\nexport function tetCenter(tetGeometry: TetGeometry, tetId: number, target: Vector3) {\n\tconst points = tetGeometry.points;\n\tconst tet = tetGeometry.tetrahedrons.get(tetId);\n\tif (!tet) {\n\t\treturn;\n\t}\n\tconst id0 = tet.pointIds[0];\n\tconst id1 = tet.pointIds[1];\n\tconst id2 = tet.pointIds[2];\n\tconst id3 = tet.pointIds[3];\n\tconst pt0 = points.get(id0);\n\tconst pt1 = points.get(id1);\n\tconst pt2 = points.get(id2);\n\tconst pt3 = points.get(id3);\n\tif (!(pt0 && pt1 && pt2 && pt3)) {\n\t\treturn;\n\t}\n\ttarget.copy(pt0.position).add(pt1.position).add(pt2.position).add(pt3.position).multiplyScalar(0.25);\n}\n\nconst b = new Vector3();\nconst c = new Vector3();\nconst d = new Vector3();\nconst b2 = new Vector3();\nconst c2 = new Vector3();\nconst d2 = new Vector3();\n\nexport function getCircumCenter(p0: Vector3, p1: Vector3, p2: Vector3, p3: Vector3, target: Vector3) {\n\tb.copy(p1).sub(p0);\n\tc.copy(p2).sub(p0);\n\td.copy(p3).sub(p0);\n\n\tconst det: number =\n\t\t2.0 * (b.x * (c.y * d.z - c.z * d.y) - b.y * (c.x * d.z - c.z * d.x) + b.z * (c.x * d.y - c.y * d.x));\n\tif (det == 0.0) {\n\t\treturn target.copy(p0);\n\t} else {\n\t\tconst dotb = b.dot(b);\n\t\tconst dotc = c.dot(c);\n\t\tconst dotd = d.dot(d);\n\t\tconst cd = c2.copy(c).cross(d);\n\t\tconst db = d2.copy(d).cross(b);\n\t\tconst bc = b2.copy(b).cross(c);\n\t\tcd.multiplyScalar(dotb).add(db.multiplyScalar(dotc)).add(bc.multiplyScalar(dotd));\n\t\tcd.divideScalar(det);\n\t\treturn target.copy(p0).add(cd);\n\t}\n}\n\nexport function tetCircumCenter(tetGeometry: TetGeometry, tetId: number, target: Vector3) {\n\tconst tet = tetGeometry.tetrahedrons.get(tetId);\n\tif (!tet) {\n\t\treturn;\n\t}\n\tconst pt0 = tetGeometry.points.get(tet.pointIds[0]);\n\tconst pt1 = tetGeometry.points.get(tet.pointIds[1]);\n\tconst pt2 = tetGeometry.points.get(tet.pointIds[2]);\n\tconst pt3 = tetGeometry.points.get(tet.pointIds[3]);\n\tif (!(pt0 && pt1 && pt2 && pt3)) {\n\t\treturn;\n\t}\n\tgetCircumCenter(pt0.position, pt1.position, pt2.position, pt3.position, target);\n}\n","import {Vector3, BackSide} from 'three';\nimport {createRaycaster} from '../../../../RaycastHelper';\nimport {MeshWithBVHGeometry} from '../../../bvh/ThreeMeshBVHHelper';\n\nexport const DIRS = [\n\tnew Vector3(1.0, 0.0, 0.0),\n\tnew Vector3(-1.0, 0.0, 0.0),\n\tnew Vector3(0.0, 1.0, 0.0),\n\tnew Vector3(0.0, -1.0, 0.0),\n\tnew Vector3(0.0, 0.0, 1.0),\n\tnew Vector3(0.0, 0.0, -1.0),\n];\nconst _raycaster = createRaycaster();\n\nexport function isPositionInsideMesh(pos: Vector3, mesh: MeshWithBVHGeometry, minDist: number): boolean {\n\t// const {mesh, invMat, p, minDist} = options;\n\n\tlet numIn: number = 0;\n\tconst bvh = mesh.geometry.boundsTree;\n\t_raycaster.ray.origin.copy(pos);\n\tfor (const dir of DIRS) {\n\t\t_raycaster.ray.direction.copy(dir);\n\t\t// raycaster.ray.applyMatrix4(invMat);\n\t\tconst hit = bvh.raycastFirst(_raycaster.ray, BackSide);\n\t\tif (hit) {\n\t\t\tconst {normal, distance} = hit;\n\n\t\t\tif (normal) {\n\t\t\t\tnormal.applyMatrix4(mesh.matrixWorld);\n\t\t\t\t// we test that the normal is facing the other way as the ray,\n\t\t\t\t// since the raycast is tested with BackSide.\n\t\t\t\t// and we can't test with FrontSide as this does not return an intersection\n\t\t\t\t// nor with DoubleSide as we can't tell if the normal is negated or not\n\t\t\t\tif (normal.dot(dir) <= 0.0) {\n\t\t\t\t\tnumIn++;\n\t\t\t\t}\n\t\t\t\tif (minDist > 0.0 && distance < minDist) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn numIn > 4;\n}\n","import {Vector3} from 'three';\nimport { TetGeometry } from '../TetGeometry';\n\nconst d0 = new Vector3();\nconst d1 = new Vector3();\nconst d2 = new Vector3();\nconst d3 = new Vector3();\nconst d4 = new Vector3();\nconst d5 = new Vector3();\nexport function tetQuality(tetGeometry:TetGeometry, tetId:number):number {\n\tconst tet = tetGeometry.tetrahedrons.get(tetId);\n\tif(!tet){\n\t\treturn 0\n\t}\n\tconst pt0 = tetGeometry.points.get(tet.pointIds[0]);\n\t\t\tconst pt1 = tetGeometry.points.get(tet.pointIds[1]);\n\t\t\tconst pt2 = tetGeometry.points.get(tet.pointIds[2]);\n\t\t\tconst pt3 = tetGeometry.points.get(tet.pointIds[3]);\n\t\t\tif (!(pt0 && pt1 && pt2 && pt3)) {\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\treturn tetQualityFromPoints(pt0.position, pt1.position, pt2.position, pt3.position);\n}\n\n\nexport function tetQualityFromPoints(p0: Vector3, p1: Vector3, p2: Vector3, p3: Vector3) {\n\td0.copy(p1).sub(p0);\n\td1.copy(p2).sub(p0);\n\td2.copy(p3).sub(p0);\n\td3.copy(p2).sub(p1);\n\td4.copy(p3).sub(p2);\n\td5.copy(p1).sub(p3);\n\n\tconst s0 = d0.length();\n\tconst s1 = d1.length();\n\tconst s2 = d2.length();\n\tconst s3 = d3.length();\n\tconst s4 = d4.length();\n\tconst s5 = d5.length();\n\n\tconst ms = (s0 * s0 + s1 * s1 + s2 * s2 + s3 * s3 + s4 * s4 + s5 * s5) / 6.0;\n\tconst rms = Math.sqrt(ms);\n\n\tconst s = 12.0 / Math.sqrt(2.0);\n\n\tconst vol = d0.dot(d1.cross(d2)) / 6.0;\n\treturn (s * vol) / (rms * rms * rms);\n\t// 1.0 for regular tetrahedron\n}\n","import {TetGeometry} from '../TetGeometry';\n\nexport function tetRemoveUnusedPoints(tetGeometry: TetGeometry): TetGeometry {\n\tconst usedPointIds = new Set<number>();\n\ttetGeometry.tetrahedrons.forEach((tet) => {\n\t\ttet.pointIds.forEach((pointId) => {\n\t\t\tusedPointIds.add(pointId);\n\t\t});\n\t});\n\ttetGeometry.points.forEach((point, pointId) => {\n\t\tif (!usedPointIds.has(pointId)) {\n\t\t\ttetGeometry.removePoint(pointId);\n\t\t}\n\t});\n\treturn tetGeometry;\n}\n","import {TetGeometry} from '../TetGeometry';\n\nexport function tetSortPoints(tetGeometry: TetGeometry, pointIndexById: Map<number, number>) {\n\tpointIndexById.clear();\n\tlet index = 0;\n\ttetGeometry.points.forEach((point) => {\n\t\tif (!pointIndexById.has(point.id)) {\n\t\t\tpointIndexById.set(point.id, index);\n\t\t\tindex++;\n\t\t}\n\t});\n}\n","import {Tetrahedron, TetrahedronSphere} from '../TetCommon';\nimport {Vector3} from 'three';\nimport {TetGeometry} from '../TetGeometry';\nimport {getCircumCenter} from './tetCenter';\n\nexport function circumSphere(\n\ttetGeometry: TetGeometry,\n\tid0: number,\n\tid1: number,\n\tid2: number,\n\tid3: number,\n\ttarget: TetrahedronSphere\n) {\n\tconst p0 = tetGeometry.points.get(id0);\n\tconst p1 = tetGeometry.points.get(id1);\n\tconst p2 = tetGeometry.points.get(id2);\n\tconst p3 = tetGeometry.points.get(id3);\n\tif (!(p0 && p1 && p2 && p3)) {\n\t\treturn;\n\t}\n\tgetCircumCenter(p0.position, p1.position, p2.position, p3.position, target.center);\n\ttarget.radius = target.center.distanceTo(p0.position);\n\treturn;\n}\n\nexport function isPointInTetCircumSphere(tetrahedron: Tetrahedron, point: Vector3): boolean {\n\treturn point.distanceTo(tetrahedron.sphere.center) <= tetrahedron.sphere.radius;\n}\n","import {BufferAttribute, BufferGeometry, Object3D, Vector3, Mesh} from 'three';\nimport {setToArray} from '../../SetUtils';\nimport {Number2} from '../../../types/GlobalTypes';\nimport {ThreejsCoreObject} from '../modules/three/ThreejsCoreObject';\nimport {textureFromAttribLookupId, textureFromAttribLookupUv} from './TextureFromAttribute';\n\nexport interface Face {\n\ta: number;\n\tb: number;\n\tc: number;\n}\n\nconst v0 = new Vector3();\n\nexport enum AttribAdjacency {\n\tBASE_NAME = 'adjacency',\n\tCOUNT = 'adjacencyCount',\n}\n\nexport function adjacencyAttribName(baseAttribName: string, index: number) {\n\treturn `${baseAttribName}${index}`;\n}\n\nfunction _adjacencyVertices(geometry: BufferGeometry, vertices: Vector3[]) {\n\tconst position = geometry.attributes.position;\n\tif (!(position instanceof BufferAttribute)) {\n\t\tconsole.warn('position is not a BufferAttribute');\n\t\treturn;\n\t}\n\n\tfor (let i = 0, il = position.count; i < il; i++) {\n\t\tv0.fromBufferAttribute(position, i);\n\t\tvertices.push(v0.clone());\n\t}\n}\n\nfunction _adjacencyGroupFaces(geometry: BufferGeometry, vertices: Vector3[]) {\n\tconst index = geometry.index;\n\tif (!index) {\n\t\tconsole.warn('no index');\n\t\treturn;\n\t}\n\tconst verticesCount = vertices.length;\n\tconst indexCount = index.count / 3;\n\tconst faces: Face[][] = Array.from({length: verticesCount}, () => new Array());\n\n\t// compute all faces for set vertex\n\n\tfor (let i = 0, il = indexCount; i < il; i++) {\n\t\tconst i3 = i * 3;\n\t\tconst a = index.getX(i3 + 0);\n\t\tconst b = index.getX(i3 + 1);\n\t\tconst c = index.getX(i3 + 2);\n\n\t\tconst face: Face = {a, b, c};\n\n\t\t// console.log(i, a, b, c, indexCount, verticesCount);\n\t\tfaces[a].push(face);\n\t\tfaces[b].push(face);\n\t\tfaces[c].push(face);\n\t}\n\t// console.log(indexCount, verticesCount, faces.length);\n\t// console.log({faces});\n\treturn faces;\n}\n\n// support function - find face with winding order ( first ) -> ( next )\n// function getFace(arr: Face[], first: number, next: number) {\n// \tfor (let r = 0; r < arr.length; r++) {\n// \t\tvar n = arr[r];\n\n// \t\tif ((n.a === first && n.b === next) || (n.b === first && n.c === next) || (n.c === first && n.a === next))\n// \t\t\treturn n;\n// \t}\n\n// \tthrow new Error(\"populateAdjacency: shouldn't reach here.\");\n// }\n\n// export function _populateAdjacencyOLD(faces: Face[][], vertices: Vector3[]) {\n// \tconst adjacency: number[][] = Array.from({length: vertices.length}, () => new Array());\n\n// \t// compute sorted adjacency list for every vertex\n// \tfor (let r = 0; r < faces.length; r++) {\n// \t\tlet n = faces[r][0];\n\n// \t\t// cycle in a fan, through all faces of the vertex\n// \t\tlet i = 0;\n// \t\twhile (true) {\n// \t\t\tif (n.a == r) {\n// \t\t\t\tadjacency[r].push(n.c);\n// \t\t\t\tn = getFace(faces[r], r, n.c); // face with reverse winding order ( a ) -> ( c )\n// \t\t\t} else if (n.b == r) {\n// \t\t\t\tadjacency[r].push(n.a);\n// \t\t\t\tn = getFace(faces[r], r, n.a); // face with reverse winding order ( b ) -> ( a )\n// \t\t\t} else {\n// \t\t\t\t// n.c == r\n\n// \t\t\t\tadjacency[r].push(n.b);\n// \t\t\t\tn = getFace(faces[r], r, n.b); // face with reverse winding order ( c ) -> ( b )\n// \t\t\t}\n\n// \t\t\t// back to the start - end\n// \t\t\tif (n == faces[r][0]) break;\n\n// \t\t\ti++;\n// \t\t\tif (i == 8) {\n// \t\t\t\tbreak;\n// \t\t\t}\n// \t\t}\n// \t}\n// \treturn adjacency;\n\n// \t// console.log({adjacency});\n// \t// console.log(ArrayUtils.uniq(adjacency.map((a) => a.length)));\n// \t// const countByLength: Map<number, number> = new Map();\n// \t// for (let elem of adjacency) {\n// \t// \tconst count = elem.length;\n// \t// \tconst currentCount = countByLength.get(count);\n// \t// \tif (currentCount == null) {\n// \t// \t\tcountByLength.set(count, 1);\n// \t// \t} else {\n// \t// \t\tcountByLength.set(count, currentCount + 1);\n// \t// \t}\n// \t// }\n// \t// countByLength.forEach((count, length) => {\n// \t// \tconsole.log(`${length} -> ${count}`);\n// \t// });\n// }\nconst _indexPairByFirstIndex: Map<number, Number2> = new Map();\nconst _endIndices: Set<number> = new Set();\nfunction filterAjacency(indexPairs: Number2[]): Number2[] {\n\t_indexPairByFirstIndex.clear();\n\t_endIndices.clear();\n\tfor (const indexPair of indexPairs) {\n\t\t_indexPairByFirstIndex.set(indexPair[0], indexPair);\n\t\t_endIndices.add(indexPair[1]);\n\t}\n\tlet startIndex = 0;\n\tlet i = 0;\n\tfor (const indexPair of indexPairs) {\n\t\tif (!_endIndices.has(indexPair[0])) {\n\t\t\tstartIndex = i;\n\t\t\tbreak;\n\t\t}\n\t\ti++;\n\t}\n\n\tconst expectedCount = indexPairs.length;\n\tconst rawList: number[] = new Array(expectedCount).fill(-1);\n\tconst result: Number2[] = new Array();\n\n\tlet currentIndexPair: Number2 | undefined = indexPairs[startIndex];\n\tfor (let i = 0; i < expectedCount; i++) {\n\t\trawList[i] = currentIndexPair[0];\n\t\tcurrentIndexPair = _indexPairByFirstIndex.get(currentIndexPair[1]);\n\t\tif (!currentIndexPair) {\n\t\t\tbreak;\n\t\t}\n\t}\n\tfor (let i = 0; i < expectedCount; i += 2) {\n\t\tresult.push([rawList[i], rawList[i + 1]]);\n\t}\n\n\treturn result;\n}\n\nconst _pointSet: Set<Number2> = new Set();\nconst _pointArray: Number2[] = [];\nexport function populateAdjacency2(faces: Face[][], vertices: Vector3[]) {\n\tconst adjacency: Number2[][] = Array.from({length: vertices.length}, () => new Array());\n\n\tfor (let r = 0; r < faces.length; r++) {\n\t\tconst pointFaces = faces[r];\n\t\tif (pointFaces.length == 0) {\n\t\t\tconsole.warn(`point ${r} has no face`);\n\t\t}\n\n\t\t_pointSet.clear();\n\n\t\tfor (const pointFace of pointFaces) {\n\t\t\tswitch (r) {\n\t\t\t\tcase pointFace.a: {\n\t\t\t\t\t_pointSet.add([pointFace.b, pointFace.c]);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcase pointFace.b: {\n\t\t\t\t\t_pointSet.add([pointFace.c, pointFace.a]);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcase pointFace.c: {\n\t\t\t\t\t_pointSet.add([pointFace.a, pointFace.b]);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tsetToArray(_pointSet, _pointArray);\n\t\tadjacency[r] = filterAjacency(_pointArray);\n\t}\n\treturn adjacency;\n}\n\ninterface PopulateAdjacencyOptions {\n\tadjacencyCountName: string;\n\tadjacencyBaseName: string;\n}\nexport const POPULATE_ADJACENCY_DEFAULT: PopulateAdjacencyOptions = {\n\tadjacencyCountName: AttribAdjacency.COUNT,\n\tadjacencyBaseName: AttribAdjacency.BASE_NAME,\n};\n\nexport function populateAdjacency3(object: Object3D, params: PopulateAdjacencyOptions) {\n\tconst {adjacencyCountName, adjacencyBaseName} = params;\n\tconst geometry = (object as Mesh).geometry;\n\tif (!geometry) {\n\t\treturn;\n\t}\n\n\tconst position = geometry.attributes.position;\n\tif (!(position instanceof BufferAttribute)) {\n\t\tconsole.warn('position is not a BufferAttribute');\n\t\treturn;\n\t}\n\tconst index = geometry.index;\n\tif (!index) {\n\t\tconsole.warn('no index');\n\t\treturn;\n\t}\n\n\t// populate vertices\n\tconst vertices: Vector3[] = [];\n\t_adjacencyVertices(geometry, vertices);\n\n\t// group faces\n\n\tconst faces = _adjacencyGroupFaces(geometry, vertices);\n\tif (!faces) {\n\t\treturn;\n\t}\n\n\t// populate adjacency\n\tconst adjacency = populateAdjacency2(faces, vertices);\n\n\t// build attributes\n\tlet maxAdjacencyCount = -1;\n\tfor (const arr of adjacency) {\n\t\tif (arr.length > maxAdjacencyCount) {\n\t\t\tmaxAdjacencyCount = arr.length;\n\t\t}\n\t}\n\tconst attribSize = 2;\n\tconst attributesCount = Math.ceil(maxAdjacencyCount);\n\n\t// add object adjacency count\n\tThreejsCoreObject.addAttribute(object, adjacencyCountName, maxAdjacencyCount);\n\n\tconst pointsCount = position.count;\n\n\tconst _addAdjacencyAttributes = () => {\n\t\tfor (let attribIndex = 0; attribIndex < attributesCount; attribIndex++) {\n\t\t\tconst attribName = adjacencyAttribName(adjacencyBaseName, attribIndex);\n\n\t\t\tconst values = new Array(pointsCount * attribSize).fill(-1);\n\t\t\tfor (let pointIndex = 0; pointIndex < pointsCount; pointIndex++) {\n\t\t\t\tconst pointAdjacency = adjacency[pointIndex][attribIndex];\n\t\t\t\tif (pointAdjacency) {\n\t\t\t\t\tfor (let i = 0; i < attribSize; i++) {\n\t\t\t\t\t\tconst value = pointAdjacency[i];\n\t\t\t\t\t\tvalues[pointIndex * attribSize + i] = value != null ? value : -1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tconst valuesArray = new Float32Array(values);\n\t\t\tgeometry.setAttribute(attribName, new BufferAttribute(valuesArray, attribSize));\n\t\t}\n\t};\n\n\t_addAdjacencyAttributes();\n\ttextureFromAttribLookupUv(geometry);\n\ttextureFromAttribLookupId(geometry);\n}\nexport function unpackAdjacency3(object: Object3D, params: PopulateAdjacencyOptions): number[][] {\n\tconst {adjacencyCountName, adjacencyBaseName} = params;\n\tconst geometry = (object as Mesh).geometry;\n\tif (!geometry) {\n\t\treturn [];\n\t}\n\tconst indices = geometry.index?.array;\n\tif (!indices) {\n\t\treturn [];\n\t}\n\tconst pointsCount = indices.length;\n\tconst adjacencies: number[][] = [];\n\n\tconst adjacencyCount = ThreejsCoreObject.attribValue(object, adjacencyCountName, 0) as number;\n\tfor (let i = 0; i < pointsCount; i++) {\n\t\tconst index = indices[i];\n\t\tfor (let attribIndex = 0; attribIndex < adjacencyCount; attribIndex++) {\n\t\t\tconst attribName = adjacencyAttribName(adjacencyBaseName, attribIndex);\n\t\t\tconst attribute = geometry.getAttribute(attribName);\n\t\t\tconst array = attribute.array as Float32Array;\n\n\t\t\tlet pointAdjacency = adjacencies[index];\n\t\t\tif (!pointAdjacency) {\n\t\t\t\tpointAdjacency = [];\n\t\t\t\tadjacencies[index] = pointAdjacency;\n\t\t\t}\n\t\t\tconst i0 = array[index * 2];\n\t\t\tconst i1 = array[index * 2 + 1];\n\t\t\tif (!pointAdjacency.includes(i0)) {\n\t\t\t\tpointAdjacency.push(i0);\n\t\t\t}\n\t\t\tif (!pointAdjacency.includes(i1)) {\n\t\t\t\tpointAdjacency.push(i1);\n\t\t\t}\n\t\t}\n\t}\n\treturn adjacencies;\n}\n","import {BufferAttribute, BufferGeometry, Vector3} from 'three';\nimport {TypeAssert} from '../../../engine/poly/Assert';\n\nexport enum PointsCountMode {\n\tSEGMENTS_COUNT = 'segments count',\n\tSEGMENTS_LENGTH = 'segments length',\n}\nexport const POINTS_COUNT_MODE: PointsCountMode[] = [PointsCountMode.SEGMENTS_COUNT, PointsCountMode.SEGMENTS_LENGTH];\nexport enum JoinMode {\n\tABC = 'abc',\n\tACB = 'acb',\n\tAB = 'ab',\n\tBC = 'bc',\n\tAC = 'ac',\n}\nexport const JOIN_MODES: JoinMode[] = [JoinMode.ABC, JoinMode.ACB, JoinMode.AB, JoinMode.AC, JoinMode.BC];\n\ninterface Circle3PointsParameters {\n\tarc: boolean;\n\tcenter: boolean;\n\tpointsCountMode: PointsCountMode;\n\tsegmentsLength: number;\n\tsegmentsCount: number;\n\tfull: boolean;\n\tjoinMode: JoinMode;\n\taddIdAttribute: boolean;\n\taddIdnAttribute: boolean;\n}\ninterface CreatedGeometries {\n\tarc?: BufferGeometry;\n\tcenter?: BufferGeometry;\n}\n\nexport class Circle3Points {\n\tprivate a: Vector3 = new Vector3();\n\tprivate b: Vector3 = new Vector3();\n\tprivate c: Vector3 = new Vector3();\n\tprivate an: Vector3 = new Vector3();\n\tprivate bn: Vector3 = new Vector3();\n\tprivate cn: Vector3 = new Vector3();\n\tprivate ac: Vector3 = new Vector3();\n\tprivate ab: Vector3 = new Vector3();\n\tprivate ab_x_ac: Vector3 = new Vector3();\n\tprivate part0: Vector3 = new Vector3();\n\tprivate part1: Vector3 = new Vector3();\n\tprivate divider: number = 1;\n\tprivate a_center: Vector3 = new Vector3();\n\tprivate center: Vector3 = new Vector3();\n\tprivate normal: Vector3 = new Vector3();\n\tprivate radius: number = 1;\n\tprivate x: Vector3 = new Vector3();\n\tprivate y: Vector3 = new Vector3();\n\tprivate z: Vector3 = new Vector3();\n\tprivate angle_ab: number = 1;\n\tprivate angle_ac: number = 1;\n\tprivate angle_bc: number = 1;\n\tprivate angle: number = 2 * Math.PI;\n\tprivate x_rotated: Vector3 = new Vector3();\n\n\tprivate _created_geometries: CreatedGeometries = {};\n\n\tconstructor(private params: Circle3PointsParameters) {}\n\n\tcreated_geometries() {\n\t\treturn this._created_geometries;\n\t}\n\n\tcreate(a: Vector3, b: Vector3, c: Vector3) {\n\t\tthis.a.copy(a);\n\t\tthis.b.copy(b);\n\t\tthis.c.copy(c);\n\t\tthis._compute_axis();\n\t\tthis._create_arc();\n\t\tthis._create_center();\n\t}\n\n\tprivate _create_arc() {\n\t\tthis._compute_angle();\n\t\tconst points_count = this._points_count();\n\t\tconst positions: number[] = new Array(points_count * 3);\n\t\tconst indices: number[] = new Array(points_count);\n\n\t\tconst angle_increment = this.angle / (points_count - 1);\n\t\tthis.x_rotated.copy(this.x).multiplyScalar(this.radius);\n\t\tlet i = 0;\n\t\tfor (i = 0; i < points_count; i++) {\n\t\t\tthis.x_rotated\n\t\t\t\t.copy(this.x)\n\t\t\t\t.applyAxisAngle(this.normal, angle_increment * i)\n\t\t\t\t.multiplyScalar(this.radius)\n\t\t\t\t.add(this.center);\n\t\t\tthis.x_rotated.toArray(positions, i * 3);\n\n\t\t\tif (i > 0) {\n\t\t\t\tindices[(i - 1) * 2] = i - 1;\n\t\t\t\tindices[(i - 1) * 2 + 1] = i;\n\t\t\t}\n\t\t}\n\t\tif (this.params.full) {\n\t\t\t// also add the last segment\n\t\t\tindices.push(i - 1);\n\t\t\tindices.push(0);\n\t\t}\n\t\tconst geometry = new BufferGeometry();\n\t\tgeometry.setAttribute('position', new BufferAttribute(new Float32Array(positions), 3));\n\t\tgeometry.setIndex(indices);\n\t\tif (this.params.addIdAttribute || this.params.addIdnAttribute) {\n\t\t\tconst ids: number[] = new Array(points_count);\n\t\t\tfor (let i = 0; i < ids.length; i++) {\n\t\t\t\tids[i] = i;\n\t\t\t}\n\t\t\tif (this.params.addIdAttribute) {\n\t\t\t\tgeometry.setAttribute('id', new BufferAttribute(new Float32Array(ids), 1));\n\t\t\t}\n\t\t\tconst idns = ids.map((id) => id / (points_count - 1));\n\t\t\tif (this.params.addIdnAttribute) {\n\t\t\t\tgeometry.setAttribute('idn', new BufferAttribute(new Float32Array(idns), 1));\n\t\t\t}\n\t\t}\n\t\tthis._created_geometries.arc = geometry;\n\t}\n\tprivate _create_center() {\n\t\tif (!this.params.center) {\n\t\t\treturn;\n\t\t}\n\t\tconst geometry = new BufferGeometry();\n\t\tconst positions = [this.center.x, this.center.y, this.center.z];\n\t\tgeometry.setAttribute('position', new BufferAttribute(new Float32Array(positions), 3));\n\t\tthis._created_geometries.center = geometry;\n\t}\n\n\tprivate _compute_axis() {\n\t\tthis.ac.copy(this.c).sub(this.a);\n\t\tthis.ab.copy(this.b).sub(this.a);\n\t\tthis.ab_x_ac.copy(this.ab).cross(this.ac);\n\t\tthis.divider = 2.0 * this.ab_x_ac.lengthSq();\n\t\tthis.part0.copy(this.ab_x_ac).cross(this.ab).multiplyScalar(this.ac.lengthSq());\n\t\tthis.part1.copy(this.ac).cross(this.ab_x_ac).multiplyScalar(this.ab.lengthSq());\n\t\tthis.a_center.copy(this.part0).add(this.part1).divideScalar(this.divider);\n\t\tthis.radius = this.a_center.length();\n\t\tthis.normal.copy(this.ab_x_ac).normalize();\n\t\tthis.center.copy(this.a).add(this.a_center);\n\t}\n\tprivate _compute_angle() {\n\t\tif (!this.params.arc) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (this.params.full) {\n\t\t\tthis.x.copy(this.a).sub(this.center).normalize();\n\t\t\tthis.angle = 2 * Math.PI;\n\t\t} else {\n\t\t\tthis.an.copy(this.a).sub(this.center).normalize();\n\t\t\tthis.bn.copy(this.b).sub(this.center).normalize();\n\t\t\tthis.cn.copy(this.c).sub(this.center).normalize();\n\n\t\t\tthis._set_x_from_joinMode();\n\t\t\tthis.y.copy(this.normal);\n\t\t\tthis.z.copy(this.x).cross(this.y).normalize();\n\n\t\t\tthis.angle_ab = this.an.angleTo(this.bn);\n\t\t\tthis.angle_ac = this.an.angleTo(this.cn);\n\t\t\tthis.angle_bc = this.bn.angleTo(this.cn);\n\n\t\t\tthis._set_angle_from_joinMode();\n\t\t}\n\t}\n\n\tprivate _points_count() {\n\t\tconst mode = this.params.pointsCountMode;\n\t\tswitch (mode) {\n\t\t\tcase PointsCountMode.SEGMENTS_COUNT: {\n\t\t\t\treturn this.params.segmentsCount + 1;\n\t\t\t}\n\t\t\tcase PointsCountMode.SEGMENTS_LENGTH: {\n\t\t\t\tlet perimeter = Math.PI * this.radius * this.radius;\n\t\t\t\tif (!this.params.full) {\n\t\t\t\t\tperimeter *= Math.abs(this.angle) / (Math.PI * 2);\n\t\t\t\t}\n\t\t\t\treturn Math.ceil(perimeter / this.params.segmentsLength);\n\t\t\t}\n\t\t}\n\t\tTypeAssert.unreachable(mode);\n\t}\n\tprivate _set_x_from_joinMode() {\n\t\tconst joinMode = this.params.joinMode;\n\t\tthis.x.copy(this.a).sub(this.center).normalize();\n\t\tswitch (joinMode) {\n\t\t\tcase JoinMode.ABC: {\n\t\t\t\treturn this.x.copy(this.an);\n\t\t\t}\n\t\t\tcase JoinMode.ACB: {\n\t\t\t\treturn this.x.copy(this.an);\n\t\t\t}\n\t\t\tcase JoinMode.AB: {\n\t\t\t\treturn this.x.copy(this.an);\n\t\t\t}\n\t\t\tcase JoinMode.AC: {\n\t\t\t\treturn this.x.copy(this.an);\n\t\t\t}\n\t\t\tcase JoinMode.BC: {\n\t\t\t\treturn this.x.copy(this.bn);\n\t\t\t}\n\t\t}\n\t\tTypeAssert.unreachable(joinMode);\n\t}\n\tprivate _set_angle_from_joinMode(): void {\n\t\tconst joinMode = this.params.joinMode;\n\t\tswitch (joinMode) {\n\t\t\tcase JoinMode.ABC: {\n\t\t\t\tthis.angle = this.angle_ab + this.angle_bc;\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tcase JoinMode.ACB: {\n\t\t\t\tthis.angle = this.angle_ac + this.angle_bc;\n\t\t\t\tthis.angle *= -1;\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tcase JoinMode.AB: {\n\t\t\t\tthis.angle = this.angle_ab;\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tcase JoinMode.AC: {\n\t\t\t\tthis.angle = this.angle_ac;\n\t\t\t\tthis.angle *= -1;\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tcase JoinMode.BC: {\n\t\t\t\tthis.angle = this.angle_bc;\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tTypeAssert.unreachable(joinMode);\n\t}\n}\n","import {BufferGeometry, BufferAttribute, Vector2, Vector3, Vector4} from 'three';\nimport {MapUtils} from '../../MapUtils';\n\nconst tmpV2 = new Vector2();\nconst tmpV3 = new Vector3();\nconst tmpV4 = new Vector4();\n\nclass Position {\n\tpublic readonly originalPosition: Vector3 = new Vector3();\n\tpublic readonly snappedPosition: Vector3 = new Vector3();\n\tpublic readonly snappedKey: string;\n\tconstructor(public readonly positionAttribute: BufferAttribute, public readonly index: number, tolerance: number) {\n\t\tthis.originalPosition.fromBufferAttribute(positionAttribute, this.index);\n\t\troundedPos(positionAttribute, this.index, this.snappedPosition, tolerance);\n\t\tthis.snappedKey = `${this.snappedPosition.x}:${this.snappedPosition.y}:${this.snappedPosition.z}`;\n\t}\n\taddAttribValue(geometry: BufferGeometry, attribName: string, targetArray: number[]) {\n\t\tconst attribute = geometry.getAttribute(attribName) as BufferAttribute;\n\t\tswitch (attribute.itemSize) {\n\t\t\tcase 1: {\n\t\t\t\tconst val = attribute.getX(this.index);\n\t\t\t\ttargetArray.push(val);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase 2: {\n\t\t\t\ttmpV2.fromBufferAttribute(attribute, this.index);\n\t\t\t\ttmpV2.toArray(targetArray, targetArray.length);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase 3: {\n\t\t\t\ttmpV3.fromBufferAttribute(attribute, this.index);\n\t\t\t\ttmpV3.toArray(targetArray, targetArray.length);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase 4: {\n\t\t\t\ttmpV4.fromBufferAttribute(attribute, this.index);\n\t\t\t\ttmpV4.toArray(targetArray, targetArray.length);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n}\n\nclass Face {\n\tconstructor(public a: Position, public b: Position, public c: Position) {}\n}\n\nfunction averagePosition(positions: Set<Position>, target: Vector3) {\n\ttarget.set(0, 0, 0);\n\tpositions.forEach((position) => {\n\t\ttarget.add(position.originalPosition);\n\t});\n\ttarget.divideScalar(positions.size);\n}\n\nfunction roundedPos(position: BufferAttribute, index: number, target: Vector3, tolerance: number) {\n\ttarget.fromBufferAttribute(position, index);\n\n\tif (tolerance > 0) {\n\t\ttarget.x = Math.round(target.x / tolerance) * tolerance;\n\t\ttarget.y = Math.round(target.y / tolerance) * tolerance;\n\t\ttarget.z = Math.round(target.z / tolerance) * tolerance;\n\t}\n}\nfunction isFaceCollapsed(face: Face): boolean {\n\treturn (\n\t\tface.a.snappedKey == face.b.snappedKey ||\n\t\tface.a.snappedKey == face.c.snappedKey ||\n\t\tface.b.snappedKey == face.c.snappedKey\n\t);\n}\n\nexport function mergeFaces(geometry: BufferGeometry, tolerance: number) {\n\tconst index = geometry.getIndex();\n\tif (!index) {\n\t\treturn;\n\t}\n\tconst indexArray = index.array;\n\tconst positionAttribute = geometry.getAttribute('position') as BufferAttribute;\n\tconst positionsCount = positionAttribute.count;\n\tconst facesCount = indexArray.length / 3;\n\n\tconst positions: Position[] = new Array(positionsCount);\n\tconst faces: Face[] = new Array(facesCount);\n\tconst pointsBySnappedPos: Map<string, Set<Position>> = new Map();\n\tconst firstPointBySnappedPos: Map<string, Position> = new Map();\n\tconst averagePosBySnappedKey: Map<string, Vector3> = new Map();\n\tconst newIndexBySnappedKey: Map<string, number> = new Map();\n\tconst newPositions: number[] = [];\n\tconst newIndices: number[] = [];\n\tconst newAttributeValues: Record<string, number[]> = {};\n\tconst otherAttributeNames = Object.keys(geometry.attributes).filter((attribName) => attribName != 'position');\n\tfor (const otherAttributeName of otherAttributeNames) {\n\t\tnewAttributeValues[otherAttributeName] = [];\n\t}\n\n\tfor (let i = 0; i < positionsCount; i++) {\n\t\tconst position = new Position(positionAttribute, i, tolerance);\n\t\tpositions[i] = position;\n\n\t\tMapUtils.addToSetAtEntry(pointsBySnappedPos, position.snappedKey, position);\n\t\tif (!firstPointBySnappedPos.has(position.snappedKey)) {\n\t\t\tfirstPointBySnappedPos.set(position.snappedKey, position);\n\t\t}\n\t}\n\n\tpointsBySnappedPos.forEach((points, snappedKey) => {\n\t\tconst averageV3 = new Vector3();\n\t\taveragePosition(points, averageV3);\n\t\taveragePosBySnappedKey.set(snappedKey, averageV3);\n\t});\n\n\tfor (let i = 0; i < facesCount; i++) {\n\t\tconst a = positions[indexArray[i * 3]];\n\t\tconst b = positions[indexArray[i * 3 + 1]];\n\t\tconst c = positions[indexArray[i * 3 + 2]];\n\t\tconst face = new Face(a, b, c);\n\t\tfaces[i] = face;\n\t}\n\n\tconst remainingFaces = faces.filter((face) => !isFaceCollapsed(face));\n\n\tfor (const face of remainingFaces) {\n\t\tconst positions = [face.a, face.b, face.c];\n\t\tfor (const position of positions) {\n\t\t\tlet newIndex = newIndexBySnappedKey.get(position.snappedKey);\n\t\t\tconst averagePos = averagePosBySnappedKey.get(position.snappedKey)!;\n\t\t\tif (newIndex == null) {\n\t\t\t\tnewIndex = newPositions.length / 3;\n\t\t\t\tnewIndexBySnappedKey.set(position.snappedKey, newIndex);\n\t\t\t\taveragePos.toArray(newPositions, newPositions.length);\n\n\t\t\t\tconst firstPoint = firstPointBySnappedPos.get(position.snappedKey)!;\n\t\t\t\tfor (const otherAttribName of otherAttributeNames) {\n\t\t\t\t\tfirstPoint.addAttribValue(geometry, otherAttribName, newAttributeValues[otherAttribName]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tnewIndices.push(newIndex);\n\t\t}\n\t}\n\tgeometry.setAttribute('position', new BufferAttribute(new Float32Array(newPositions), 3));\n\tfor (const attribName of otherAttributeNames) {\n\t\tconst attribute = geometry.getAttribute(attribName) as BufferAttribute;\n\t\tconst newValues = newAttributeValues[attribName];\n\t\tgeometry.setAttribute(attribName, new BufferAttribute(new Float32Array(newValues), attribute.itemSize));\n\t}\n\n\tgeometry.setIndex(newIndices);\n}\n","import {Vector3} from 'three';\nimport {CoreGroup} from '../Group';\nimport {randFloat} from '../../math/_Module';\nimport { CorePoint } from '../entities/point/CorePoint';\nimport { CoreObjectType } from '../ObjectContent';\n\ninterface JitterOptions {\n\tamount: number;\n\tmult: Vector3;\n\tseed: number;\n}\n\nconst _offset = new Vector3();\nconst _p = new Vector3();\nconst _points: CorePoint<CoreObjectType>[] = [];\n\nexport function jitterOffset(i: number, seed: number, mult: Vector3, amount: number, target: Vector3) {\n\ttarget.set(\n\t\t2 * (randFloat(i * 75 + 764 + seed) - 0.5),\n\t\t2 * (randFloat(i * 5678 + 3653 + seed) - 0.5),\n\t\t2 * (randFloat(i * 657 + 48464 + seed) - 0.5)\n\t);\n\ttarget.normalize();\n\ttarget.multiply(mult);\n\ttarget.multiplyScalar(amount * randFloat(i * 78 + 54 + seed));\n}\n\nexport function jitterPositions(coreGroup: CoreGroup, options: JitterOptions) {\n\tconst {amount, mult, seed} = options;\n\tcoreGroup.points(_points);\n\n\tlet i = 0;\n\tfor (const point of _points) {\n\t\tjitterOffset(i, seed, mult, amount, _offset);\n\n\t\tpoint.position(_p);\n\t\t_p.add(_offset);\n\t\tpoint.setPosition(_p);\n\t\ti++;\n\t}\n}\n","import {Vector3, Float32BufferAttribute, BufferGeometry} from 'three';\n\ninterface PolyHedronBufferGeometryParameters {\n\tvertices: number[];\n\tindices: number[];\n\tradius: number;\n\tdetail: number;\n}\n\n// Angle around the Y axis, counter-clockwise when looking from above.\nfunction azimuth(vector: Vector3) {\n\treturn Math.atan2(vector.z, -vector.x);\n}\n\n// Angle above the XZ plane.\nfunction inclination(vector: Vector3) {\n\treturn Math.atan2(-vector.y, Math.sqrt(vector.x * vector.x + vector.z * vector.z));\n}\n\n// from three/src/geometries/PolyhedronGeometry\nexport class PolyhedronBufferGeometry extends BufferGeometry {\n\tparameters: PolyHedronBufferGeometryParameters;\n\tconstructor(vertices: number[], indices: number[], radius: number, detail: number, points_only: boolean) {\n\t\tsuper();\n\n\t\t(this as any).type = 'PolyhedronBufferGeometry';\n\n\t\tthis.parameters = {\n\t\t\tvertices: vertices,\n\t\t\tindices: indices,\n\t\t\tradius: radius,\n\t\t\tdetail: detail,\n\t\t};\n\n\t\tradius = radius || 1;\n\t\tdetail = detail || 0;\n\n\t\t// default buffer data\n\n\t\tconst vertexBuffer: number[] = [];\n\t\tconst uvBuffer: number[] = [];\n\t\tconst vertices_by_pos: Map<number, Map<number, Set<number>>> = new Map();\n\n\t\t// the subdivision creates the vertex buffer data\n\n\t\tsubdivide(detail);\n\n\t\t// all vertices should lie on a conceptual sphere with a given radius\n\n\t\tapplyRadius(radius);\n\n\t\t// finally, create the uv data\n\n\t\tgenerateUVs();\n\n\t\t// build non-indexed geometry\n\n\t\tthis.setAttribute('position', new Float32BufferAttribute(vertexBuffer, 3));\n\t\tthis.setAttribute('uv', new Float32BufferAttribute(uvBuffer, 2));\n\n\t\tif (!points_only) {\n\t\t\tthis.setAttribute('normal', new Float32BufferAttribute(vertexBuffer.slice(), 3));\n\t\t\tif (detail === 0) {\n\t\t\t\tthis.computeVertexNormals(); // flat normals\n\t\t\t} else {\n\t\t\t\tthis.normalizeNormals(); // smooth normals\n\t\t\t}\n\t\t}\n\t\t// helper functions\n\n\t\tfunction subdivide(detail: number) {\n\t\t\tconst a = new Vector3();\n\t\t\tconst b = new Vector3();\n\t\t\tconst c = new Vector3();\n\n\t\t\t// iterate over all faces and apply a subdivison with the given detail value\n\n\t\t\tfor (let i = 0; i < indices.length; i += 3) {\n\t\t\t\t// get the vertices of the face\n\n\t\t\t\tgetVertexByIndex(indices[i + 0], a);\n\t\t\t\tgetVertexByIndex(indices[i + 1], b);\n\t\t\t\tgetVertexByIndex(indices[i + 2], c);\n\n\t\t\t\t// perform subdivision\n\n\t\t\t\tsubdivideFace(a, b, c, detail);\n\t\t\t}\n\t\t}\n\n\t\tfunction subdivideFace(a: Vector3, b: Vector3, c: Vector3, detail: number) {\n\t\t\tconst cols = detail + 1;\n\n\t\t\t// we use this multidimensional array as a data structure for creating the subdivision\n\n\t\t\tconst v: Vector3[][] = [];\n\n\t\t\t// construct all of the vertices for this subdivision\n\n\t\t\tfor (let i = 0; i <= cols; i++) {\n\t\t\t\tv[i] = [];\n\n\t\t\t\tconst aj = a.clone().lerp(c, i / cols);\n\t\t\t\tconst bj = b.clone().lerp(c, i / cols);\n\n\t\t\t\tconst rows = cols - i;\n\n\t\t\t\tfor (let j = 0; j <= rows; j++) {\n\t\t\t\t\tif (j === 0 && i === cols) {\n\t\t\t\t\t\tv[i][j] = aj;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tv[i][j] = aj.clone().lerp(bj, j / rows);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// construct all of the faces\n\n\t\t\tfor (let i = 0; i < cols; i++) {\n\t\t\t\tfor (let j = 0; j < 2 * (cols - i) - 1; j++) {\n\t\t\t\t\tconst k = Math.floor(j / 2);\n\n\t\t\t\t\tif (j % 2 === 0) {\n\t\t\t\t\t\tpushVertex(v[i][k + 1]);\n\t\t\t\t\t\tpushVertex(v[i + 1][k]);\n\t\t\t\t\t\tpushVertex(v[i][k]);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tpushVertex(v[i][k + 1]);\n\t\t\t\t\t\tpushVertex(v[i + 1][k + 1]);\n\t\t\t\t\t\tpushVertex(v[i + 1][k]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfunction applyRadius(radius: number) {\n\t\t\tconst vertex = new Vector3();\n\n\t\t\t// iterate over the entire buffer and apply the radius to each vertex\n\n\t\t\tfor (let i = 0; i < vertexBuffer.length; i += 3) {\n\t\t\t\tvertex.x = vertexBuffer[i + 0];\n\t\t\t\tvertex.y = vertexBuffer[i + 1];\n\t\t\t\tvertex.z = vertexBuffer[i + 2];\n\n\t\t\t\tvertex.normalize().multiplyScalar(radius);\n\n\t\t\t\tvertexBuffer[i + 0] = vertex.x;\n\t\t\t\tvertexBuffer[i + 1] = vertex.y;\n\t\t\t\tvertexBuffer[i + 2] = vertex.z;\n\t\t\t}\n\t\t}\n\n\t\tfunction generateUVs() {\n\t\t\tconst vertex = new Vector3();\n\n\t\t\tfor (let i = 0; i < vertexBuffer.length; i += 3) {\n\t\t\t\tvertex.x = vertexBuffer[i + 0];\n\t\t\t\tvertex.y = vertexBuffer[i + 1];\n\t\t\t\tvertex.z = vertexBuffer[i + 2];\n\n\t\t\t\tconst u = azimuth(vertex) / 2 / Math.PI + 0.5;\n\t\t\t\tconst v = inclination(vertex) / Math.PI + 0.5;\n\t\t\t\tuvBuffer.push(u, 1 - v);\n\t\t\t}\n\n\t\t\t// correctUVs and correctSeam are currently not used\n\t\t\t// as they seem to create incorrect uvs when using points only\n\t\t\t// correctUVs();\n\t\t\t// correctSeam();\n\t\t}\n\n\t\t// function correctSeam() {\n\t\t// \t// handle case when face straddles the seam, see #3269\n\n\t\t// \tfor (let i = 0; i < uvBuffer.length; i += 6) {\n\t\t// \t\t// uv data of a single face\n\n\t\t// \t\tconst x0 = uvBuffer[i + 0];\n\t\t// \t\tconst x1 = uvBuffer[i + 2];\n\t\t// \t\tconst x2 = uvBuffer[i + 4];\n\n\t\t// \t\tconst max = Math.max(x0, x1, x2);\n\t\t// \t\tconst min = Math.min(x0, x1, x2);\n\n\t\t// \t\t// 0.9 is somewhat arbitrary\n\n\t\t// \t\tif (max > 0.9 && min < 0.1) {\n\t\t// \t\t\tif (x0 < 0.2) uvBuffer[i + 0] += 1;\n\t\t// \t\t\tif (x1 < 0.2) uvBuffer[i + 2] += 1;\n\t\t// \t\t\tif (x2 < 0.2) uvBuffer[i + 4] += 1;\n\t\t// \t\t}\n\t\t// \t}\n\t\t// }\n\n\t\tfunction pushVertex(vertex: Vector3) {\n\t\t\tif (points_only) {\n\t\t\t\tlet mx = vertices_by_pos.get(vertex.x);\n\t\t\t\tif (mx) {\n\t\t\t\t\tconst my = mx.get(vertex.y);\n\t\t\t\t\tif (my && my.has(vertex.z)) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!mx) {\n\t\t\t\t\tmx = new Map();\n\t\t\t\t\tvertices_by_pos.set(vertex.x, mx);\n\t\t\t\t}\n\t\t\t\tlet my = mx.get(vertex.y);\n\t\t\t\tif (!my) {\n\t\t\t\t\tmy = new Set();\n\t\t\t\t\tmx.set(vertex.y, my);\n\t\t\t\t}\n\t\t\t\tmy.add(vertex.z);\n\t\t\t}\n\t\t\tvertexBuffer.push(vertex.x, vertex.y, vertex.z);\n\t\t}\n\n\t\tfunction getVertexByIndex(index: number, vertex: Vector3) {\n\t\t\tconst stride = index * 3;\n\n\t\t\tvertex.x = vertices[stride + 0];\n\t\t\tvertex.y = vertices[stride + 1];\n\t\t\tvertex.z = vertices[stride + 2];\n\t\t}\n\n\t\t// function correctUVs() {\n\t\t// \tconst a = new Vector3();\n\t\t// \tconst b = new Vector3();\n\t\t// \tconst c = new Vector3();\n\n\t\t// \tconst centroid = new Vector3();\n\n\t\t// \tconst uvA = new Vector2();\n\t\t// \tconst uvB = new Vector2();\n\t\t// \tconst uvC = new Vector2();\n\n\t\t// \tfor (let i = 0, j = 0; i < vertexBuffer.length; i += 9, j += 6) {\n\t\t// \t\ta.set(vertexBuffer[i + 0], vertexBuffer[i + 1], vertexBuffer[i + 2]);\n\t\t// \t\tb.set(vertexBuffer[i + 3], vertexBuffer[i + 4], vertexBuffer[i + 5]);\n\t\t// \t\tc.set(vertexBuffer[i + 6], vertexBuffer[i + 7], vertexBuffer[i + 8]);\n\n\t\t// \t\tuvA.set(uvBuffer[j + 0], uvBuffer[j + 1]);\n\t\t// \t\tuvB.set(uvBuffer[j + 2], uvBuffer[j + 3]);\n\t\t// \t\tuvC.set(uvBuffer[j + 4], uvBuffer[j + 5]);\n\n\t\t// \t\tcentroid.copy(a).add(b).add(c).divideScalar(3);\n\n\t\t// \t\tconst azi = azimuth(centroid);\n\n\t\t// \t\tcorrectUV(uvA, j + 0, a, azi);\n\t\t// \t\tcorrectUV(uvB, j + 2, b, azi);\n\t\t// \t\tcorrectUV(uvC, j + 4, c, azi);\n\t\t// \t}\n\t\t// }\n\n\t\t// function correctUV(uv: Vector2, stride: number, vector: Vector3, azimuth: number) {\n\t\t// \tif (azimuth < 0 && uv.x === 1) {\n\t\t// \t\tuvBuffer[stride] = uv.x - 1;\n\t\t// \t}\n\n\t\t// \tif (vector.x === 0 && vector.z === 0) {\n\t\t// \t\tuvBuffer[stride] = azimuth / 2 / Math.PI + 0.5;\n\t\t// \t}\n\t\t// }\n\t}\n}\n","export interface PotPackBox {\n\tw: number;\n\th: number;\n}\nexport interface PotPackBoxResult {\n\tw: number;\n\th: number;\n\tx: number;\n\ty: number;\n}\nexport interface PotPackResult {\n\tw: number;\n\th: number;\n\tfill: number;\n}\n// @ts-ignore\nimport potpack from 'potpack';\n\nexport function Potpack(boxes: PotPackBox[]): PotPackResult {\n\treturn potpack(boxes);\n}\n","import {ParamConfig} from '../../engine/nodes/utils/params/ParamsConfig';\nimport {Constructor, Number3} from '../../types/GlobalTypes';\n// import {ColorConversion} from '../Color';\nimport {DefaultOperationParams} from '../operations/_Base';\nimport {Color} from 'three';\n\nexport interface AmbientLightParams extends DefaultOperationParams {\n\tcolor: Color;\n\tintensity: number;\n\tname: string;\n}\n\nexport const DEFAULT_AMBIENT_LIGHT_PARAMS: AmbientLightParams = {\n\tcolor: new Color(1, 1, 1),\n\tintensity: 1,\n\tname: 'ambientLight',\n};\nconst DEFAULT = DEFAULT_AMBIENT_LIGHT_PARAMS;\n\nexport function AmbientLightParamConfig<TBase extends Constructor>(Base: TBase) {\n\treturn class Mixin extends Base {\n\t\t/** @param sky color */\n\t\tcolor = ParamConfig.COLOR(DEFAULT.color.toArray() as Number3, {\n\t\t\t// conversion: ColorConversion.SRGB_TO_LINEAR,\n\t\t});\n\t\t/** @param light intensity */\n\t\tintensity = ParamConfig.FLOAT(DEFAULT.intensity, {\n\t\t\trange: [0, 2],\n\t\t\trangeLocked: [true, false],\n\t\t});\n\t\t/** @param light name */\n\t\tname = ParamConfig.STRING('`$OS`');\n\t};\n}\n","import {ParamConfig} from '../../engine/nodes/utils/params/ParamsConfig';\nimport {Constructor, Number3} from '../../types/GlobalTypes';\n// import {ColorConversion} from '../Color';\nimport {DefaultOperationParams} from '../operations/_Base';\nimport {\n\tColor,\n\tGroup,\n\tBackSide,\n\tBufferGeometry,\n\tFloat32BufferAttribute,\n\tLine,\n\tLineBasicMaterial,\n\tMesh,\n\tMeshBasicMaterial,\n\tRectAreaLight,\n} from 'three';\n\nexport interface AreaLightParams extends DefaultOperationParams {\n\tcolor: Color;\n\tintensity: number;\n\twidth: number;\n\theight: number;\n\tshowHelper: boolean;\n\tname: string;\n}\n\nexport const DEFAULT_AREA_LIGHT_PARAMS: AreaLightParams = {\n\tcolor: new Color(1, 1, 1),\n\tintensity: 1,\n\twidth: 1,\n\theight: 1,\n\tshowHelper: false,\n\tname: 'areaLight',\n};\nconst DEFAULT = DEFAULT_AREA_LIGHT_PARAMS;\n\nexport function AreaLightParamConfig<TBase extends Constructor>(Base: TBase) {\n\treturn class Mixin extends Base {\n\t\tlight = ParamConfig.FOLDER();\n\t\t/** @param light color */\n\t\tcolor = ParamConfig.COLOR(DEFAULT.color.toArray() as Number3, {\n\t\t\t// conversion: ColorConversion.SRGB_TO_LINEAR,\n\t\t});\n\t\t/** @param light intensity */\n\t\tintensity = ParamConfig.FLOAT(DEFAULT.intensity, {\n\t\t\trange: [0, 10],\n\t\t\trangeLocked: [true, false],\n\t\t});\n\t\t/** @param grid width */\n\t\twidth = ParamConfig.FLOAT(DEFAULT.width, {\n\t\t\trange: [0, 10],\n\t\t\trangeLocked: [true, false],\n\t\t});\n\t\t/** @param grid height */\n\t\theight = ParamConfig.FLOAT(DEFAULT.height, {\n\t\t\trange: [0, 10],\n\t\t\trangeLocked: [true, false],\n\t\t});\n\t\t// helper\n\t\t/** @param toggle on to show helper */\n\t\tshowHelper = ParamConfig.BOOLEAN(DEFAULT.showHelper);\n\t\t/** @param light name */\n\t\tname = ParamConfig.STRING('`$OS`');\n\t};\n}\n\n/**\n *  This helper must be added as a child of the light\n */\nfunction createLineGeo() {\n\tconst geometry = new BufferGeometry();\n\tconst positions = [1, 1, 0, -1, 1, 0, -1, -1, 0, 1, -1, 0, 1, 1, 0].map((i) => i * 0.5);\n\tgeometry.setAttribute('position', new Float32BufferAttribute(positions, 3));\n\tgeometry.computeBoundingSphere();\n\treturn geometry;\n}\n\nfunction createMeshGeo() {\n\tconst positions = [1, 1, 0, -1, 1, 0, -1, -1, 0, 1, 1, 0, -1, -1, 0, 1, -1, 0].map((i) => i * 0.5);\n\n\tconst geometry = new BufferGeometry();\n\tgeometry.setAttribute('position', new Float32BufferAttribute(positions, 3));\n\tgeometry.computeBoundingSphere();\n\treturn geometry;\n}\n\n// inherits from Group and not Line, to ensure that .copy can pass the recursive argument\nexport class CoreRectAreaLightHelper extends Group {\n\tpublic _childMesh = new Mesh(createMeshGeo(), new MeshBasicMaterial({side: BackSide, fog: false}));\n\tpublic _childLine = new Line(createLineGeo(), new LineBasicMaterial());\n\n\tconstructor(public light: RectAreaLight, public readonly nodeName: string) {\n\t\tsuper();\n\n\t\tthis.matrixAutoUpdate = false;\n\t\tthis._childMesh.matrixAutoUpdate = false;\n\t\tthis._childLine.matrixAutoUpdate = false;\n\n\t\tthis.name = `CoreRectAreaLightHelper_${this.nodeName}`;\n\t\tthis._childMesh.name = `CoreRectAreaLightHelperChildMesh_${this.nodeName}`;\n\t\tthis._childLine.name = `CoreRectAreaLightHelperChildLine_${this.nodeName}`;\n\n\t\tthis.add(this._childMesh);\n\t\tthis.add(this._childLine);\n\t}\n\n\tupdate() {\n\t\tthis.scale.set(1 * this.light.width, 1 * this.light.height, 1);\n\t\tthis.updateMatrix();\n\n\t\tthis._childLine.material.color.copy(this.light.color).multiplyScalar(this.light.intensity);\n\n\t\t// prevent hue shift\n\t\tconst c = this._childLine.material.color;\n\t\tconst max = Math.max(c.r, c.g, c.b);\n\t\tif (max > 1) c.multiplyScalar(1 / max);\n\n\t\tthis._childMesh.material.color.copy(this._childLine.material.color);\n\n\t\t// ignore world scale on light\n\t\tthis.matrixWorld.extractRotation(this.light.matrixWorld).scale(this.scale).copyPosition(this.light.matrixWorld);\n\n\t\tthis._childMesh.matrixWorld.copy(this.matrixWorld);\n\t}\n\n\toverride copy(source: this, recursive?: boolean): this {\n\t\tsuper.copy(source, false);\n\n\t\treturn this as this;\n\t}\n\n\tdispose() {\n\t\tthis._childLine.geometry.dispose();\n\t\tthis._childLine.material.dispose();\n\t\tthis._childMesh.geometry.dispose();\n\t\tthis._childMesh.material.dispose();\n\t}\n\toverride clone(recursive?: boolean): this {\n\t\tconst cloned = new CoreRectAreaLightHelper(this.light, this.nodeName) as this;\n\t\tcloned.updateMatrixWorld();\n\t\tcloned.copy(this, false);\n\t\tcloned.update();\n\t\treturn cloned;\n\t}\n}\n","import {ParamConfig} from '../../engine/nodes/utils/params/ParamsConfig';\nimport {Constructor, Number3} from '../../types/GlobalTypes';\n// import {ColorConversion} from '../Color';\nimport {Vector3, Color} from 'three';\nimport {DefaultOperationParams} from '../operations/_Base';\n\nexport interface HemisphereLightParams extends DefaultOperationParams {\n\tskyColor: Color;\n\tgroundColor: Color;\n\tintensity: number;\n\tposition: Vector3;\n\tname: string;\n}\n\nexport const DEFAULT_HEMISPHERE_LIGHT_PARAMS: HemisphereLightParams = {\n\tskyColor: new Color(1, 1, 1),\n\tgroundColor: new Color(0, 0, 0),\n\tintensity: 1,\n\tposition: new Vector3(0, 1, 0),\n\tname: 'hemisphereLight',\n};\nconst DEFAULT = DEFAULT_HEMISPHERE_LIGHT_PARAMS;\n\nexport function HemisphereLightParamConfig<TBase extends Constructor>(Base: TBase) {\n\treturn class Mixin extends Base {\n\t\t/** @param sky color */\n\t\tskyColor = ParamConfig.COLOR(DEFAULT.skyColor.toArray() as Number3, {\n\t\t\t// conversion: ColorConversion.SRGB_TO_LINEAR,\n\t\t});\n\t\t/** @param ground color */\n\t\tgroundColor = ParamConfig.COLOR(DEFAULT.groundColor.toArray() as Number3, {\n\t\t\t// conversion: ColorConversion.SRGB_TO_LINEAR,\n\t\t});\n\t\t/** @param light intensity */\n\t\tintensity = ParamConfig.FLOAT(DEFAULT.intensity, {\n\t\t\trange: [0, 2],\n\t\t\trangeLocked: [true, false],\n\t\t});\n\t\t/** @param light position */\n\t\tposition = ParamConfig.VECTOR3(DEFAULT.position.toArray() as Number3);\n\t\t/** @param light name */\n\t\tname = ParamConfig.STRING('`$OS`');\n\t};\n}\n","import {ParamConfig} from '../../engine/nodes/utils/params/ParamsConfig';\nimport {Constructor} from '../../types/GlobalTypes';\nimport {DefaultOperationParams} from '../operations/_Base';\nimport {TypedNodePathParamValue} from '../Walker';\nimport {NodeContext} from '../../engine/poly/NodeContext';\nimport {CopType} from '../../engine/poly/registers/nodes/types/Cop';\n\nexport interface LightProbeParams extends DefaultOperationParams {\n\tcubeMap: TypedNodePathParamValue;\n\tintensity: number;\n\tname: string;\n}\n\nexport const DEFAULT_LIGHT_PROBE_PARAMS: LightProbeParams = {\n\tcubeMap: new TypedNodePathParamValue(''),\n\tintensity: 1,\n\tname: 'lightProbe',\n};\nconst DEFAULT = DEFAULT_LIGHT_PROBE_PARAMS;\n\nexport function LightProbeParamConfig<TBase extends Constructor>(Base: TBase) {\n\treturn class Mixin extends Base {\n\t\t/** @param cubeMap */\n\t\tcubeMap = ParamConfig.NODE_PATH('', {\n\t\t\tnodeSelection: {\n\t\t\t\tcontext: NodeContext.COP,\n\t\t\t\ttypes: [CopType.CUBE_MAP],\n\t\t\t},\n\t\t});\n\t\t/** @param light intensity */\n\t\tintensity = ParamConfig.FLOAT(DEFAULT.intensity, {\n\t\t\trange: [0, 2],\n\t\t\trangeLocked: [true, false],\n\t\t});\n\t\t/** @param light name */\n\t\tname = ParamConfig.STRING('`$OS`');\n\t};\n}\n","import {MeshBasicMaterial} from 'three';\n\nexport const LIGHT_HELPER_MAT = new MeshBasicMaterial({wireframe: true, fog: false});\n","import {ParamConfig} from '../../engine/nodes/utils/params/ParamsConfig';\nimport {Constructor, Number2, Number3} from '../../types/GlobalTypes';\n// import {ColorConversion} from '../Color';\nimport {Vector2, Color, Mesh, Vector3, PointLight, SphereGeometry} from 'three';\nimport {LIGHT_HELPER_MAT} from './_Base';\nimport {DefaultOperationParams} from '../operations/_Base';\n\nexport interface PointLightParams extends DefaultOperationParams {\n\tcolor: Color;\n\tintensity: number;\n\tdecay: number;\n\tdistance: number;\n\tname: string;\n\t//\n\tcastShadow: boolean;\n\tshadowAutoUpdate: boolean;\n\tshadowUpdateOnNextRender: boolean;\n\tshadowRes: Vector2;\n\tshadowBias: number;\n\tshadowNear: number;\n\tshadowFar: number;\n\t// debugShadow: boolean; // removed (see spotlight for explanation)\n\t//\n\tshowHelper: boolean;\n\thelperSize: number;\n\t//\n\traymarchingPenumbra: number;\n\traymarchingShadowBiasAngle: number;\n\traymarchingShadowBiasDistance: number;\n}\n\nexport const DEFAULT_POINT_LIGHT_PARAMS: PointLightParams = {\n\tcolor: new Color(1, 1, 1),\n\tintensity: 2,\n\tdecay: 2,\n\tdistance: 100,\n\tname: 'pointLight',\n\t//\n\tcastShadow: false,\n\tshadowAutoUpdate: true,\n\tshadowUpdateOnNextRender: false,\n\tshadowRes: new Vector2(1024, 1024),\n\tshadowBias: 0.0001,\n\tshadowNear: 1,\n\tshadowFar: 100,\n\t// debugShadow: false,\n\t//\n\tshowHelper: false,\n\thelperSize: 1,\n\t//\n\traymarchingPenumbra: 0, // keep as 0 by default since it's more performant\n\traymarchingShadowBiasAngle: 0.01,\n\traymarchingShadowBiasDistance: 0.1,\n};\nconst DEFAULT = DEFAULT_POINT_LIGHT_PARAMS;\n\nexport function PointLightParamConfig<TBase extends Constructor>(Base: TBase) {\n\treturn class Mixin extends Base {\n\t\tlight = ParamConfig.FOLDER();\n\t\t/** @param light color */\n\t\tcolor = ParamConfig.COLOR(DEFAULT.color.toArray() as Number3, {\n\t\t\t// conversion: ColorConversion.SRGB_TO_LINEAR,\n\t\t});\n\t\t/** @param light intensity */\n\t\tintensity = ParamConfig.FLOAT(DEFAULT.intensity, {\n\t\t\trange: [0, 10],\n\t\t\trangeLocked: [true, false],\n\t\t});\n\t\t/** @param light decay */\n\t\tdecay = ParamConfig.FLOAT(DEFAULT.decay, {\n\t\t\trange: [0, 10],\n\t\t\trangeLocked: [true, false],\n\t\t});\n\t\t/** @param light distance */\n\t\tdistance = ParamConfig.FLOAT(DEFAULT.distance, {\n\t\t\trange: [0, 100],\n\t\t\trangeLocked: [true, false],\n\t\t});\n\t\t// helper\n\t\t/** @param toggle to show helper */\n\t\tshowHelper = ParamConfig.BOOLEAN(DEFAULT.showHelper);\n\t\t/** @param helper size */\n\t\thelperSize = ParamConfig.FLOAT(1, {visibleIf: {showHelper: 1}});\n\t\t/** @param light name */\n\t\tname = ParamConfig.STRING('`$OS`');\n\n\t\t// shadows\n\t\tshadow = ParamConfig.FOLDER();\n\t\t/** @param toggle to cast shadows */\n\t\tcastShadow = ParamConfig.BOOLEAN(DEFAULT.castShadow);\n\t\t/** @param toggle off if the shadows do not need to be regenerated */\n\t\tshadowAutoUpdate = ParamConfig.BOOLEAN(DEFAULT.shadowAutoUpdate, {\n\t\t\tvisibleIf: {castShadow: 1},\n\t\t});\n\t\t/** @param press button to update the shadows on next render */\n\t\tshadowUpdateOnNextRender = ParamConfig.BOOLEAN(DEFAULT.shadowUpdateOnNextRender, {\n\t\t\tvisibleIf: {castShadow: 1, shadowAutoUpdate: 0},\n\t\t});\n\t\t/** @param shadow res */\n\t\tshadowRes = ParamConfig.VECTOR2(DEFAULT.shadowRes.toArray() as Number2, {visibleIf: {castShadow: 1}});\n\t\t/** @param shadow bias */\n\t\tshadowBias = ParamConfig.FLOAT(DEFAULT.shadowBias, {\n\t\t\tvisibleIf: {castShadow: 1},\n\t\t\trange: [-0.01, 0.01],\n\t\t\trangeLocked: [false, false],\n\t\t});\n\t\t/** @param shadow camera near */\n\t\tshadowNear = ParamConfig.FLOAT(DEFAULT.shadowNear, {visibleIf: {castShadow: 1}});\n\t\t/** @param shadow camera far */\n\t\tshadowFar = ParamConfig.FLOAT(DEFAULT.shadowFar, {visibleIf: {castShadow: 1}});\n\t\t/** @param display shadow on a plane behind the light */\n\t\t// debugShadow = ParamConfig.BOOLEAN(DEFAULT.debugShadow, {\n\t\t// \tvisibleIf: {castShadow: 1},\n\t\t// });\n\n\t\t// raymarching\n\t\traymarching = ParamConfig.FOLDER();\n\t\t/** @param this affects the shadows cast inside raymarchingBuilder materials */\n\t\traymarchingPenumbra = ParamConfig.FLOAT(DEFAULT.raymarchingPenumbra);\n\t\t/** @param shadow bias */\n\t\traymarchingShadowBiasAngle = ParamConfig.FLOAT(DEFAULT.raymarchingShadowBiasAngle, {\n\t\t\trange: [0, 1],\n\t\t\trangeLocked: [true, false],\n\t\t});\n\t\t/** @param shadow bias */\n\t\traymarchingShadowBiasDistance = ParamConfig.FLOAT(DEFAULT.raymarchingShadowBiasDistance, {\n\t\t\trange: [0, 1],\n\t\t\trangeLocked: [true, false],\n\t\t});\n\t};\n}\n\ninterface Options {\n\thelperSize: number;\n\tlight: PointLight;\n}\n\nexport class CorePointLightHelper {\n\tprivate _material = LIGHT_HELPER_MAT.clone();\n\tcreateObject() {\n\t\treturn new Mesh();\n\t}\n\tcreateAndBuildObject(options: Options) {\n\t\tconst object = this.createObject();\n\t\tthis.buildHelper(object);\n\t\tthis.update(object, options);\n\t\treturn object;\n\t}\n\n\tbuildHelper(object: Mesh) {\n\t\tconst size = 1;\n\t\tobject.geometry = new SphereGeometry(size, 4, 2);\n\t\tobject.matrixAutoUpdate = false;\n\t\tobject.material = this._material;\n\t\treturn object;\n\t}\n\n\tprivate _matrixScale = new Vector3(1, 1, 1);\n\tupdate(object: Mesh, options: Options) {\n\t\tconst size = options.helperSize;\n\t\tthis._matrixScale.set(size, size, size);\n\t\tobject.matrix.identity();\n\t\tobject.matrix.scale(this._matrixScale);\n\n\t\tthis._material.color.copy(options.light.color);\n\t}\n}\n","import type {World, RigidBody, ColliderDesc, RigidBodyDesc, JointData} from '@dimforge/rapier3d-compat';\n// import {Object3D} from 'three';\ninterface RigidBodyType {\n\tDynamic: number;\n\tFixed: number;\n\tKinematicPositionBased: number;\n\tKinematicVelocityBased: number;\n}\nexport interface PhysicsLib {\n\tWorld: typeof World;\n\tRigidBody: typeof RigidBody;\n\tColliderDesc: typeof ColliderDesc;\n\tRigidBodyDesc: typeof RigidBodyDesc;\n\tJointData: typeof JointData;\n\tRigidBodyType: RigidBodyType;\n\tQueryFilterFlags: {\n\t\tEXCLUDE_KINEMATIC: number;\n\t};\n}\n// export type Object3DByRigidBody = WeakMap<RigidBody, Object3D>;\n// export type Object3DByRigidBodyByWorld = Map<World, Object3DByRigidBody>;\n\nlet physics: PhysicsLib | undefined;\n\nlet _importStarted = false;\ntype Resolve = (value: PhysicsLib | PromiseLike<PhysicsLib>) => void;\nlet _resolves: Resolve[] = [];\n\nexport async function CorePhysics(): Promise<PhysicsLib> {\n\tif (physics) {\n\t\treturn physics;\n\t}\n\treturn new Promise((resolve) => {\n\t\tif (_importStarted) {\n\t\t\t_resolves.push(resolve);\n\t\t\treturn;\n\t\t}\n\n\t\t_importStarted = true;\n\t\timport('@dimforge/rapier3d-compat').then((RAPIER) => {\n\t\t\tRAPIER.init().then(() => {\n\t\t\t\tphysics = RAPIER;\n\t\t\t\tresolve(physics);\n\t\t\t\tif (_resolves.length > 0) {\n\t\t\t\t\tfor (const _resolve of _resolves) {\n\t\t\t\t\t\t_resolve(physics);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\t\t});\n\t});\n}\nexport function CorePhysicsLoaded(): PhysicsLib | undefined {\n\tif (physics) {\n\t\treturn physics;\n\t}\n}\n","import {Vector3} from 'three';\nimport {PhysicsJointAttribute} from './PhysicsJoint';\nimport {CoreObjectType, ObjectContent} from '../geometry/ObjectContent';\nimport {\n\tsetObjectVector3,\n\tgetObjectVector3,\n\tsetObjectNumber,\n\tgetObjectNumber,\n\tsetObjectBoolean,\n\tgetObjectBoolean,\n\tgetObjectString,\n\tsetObjectString,\n} from '../geometry/AttributeUtils';\nimport {coreObjectClassFactory} from '../geometry/CoreObjectFactory';\n\nexport enum PhysicsIdAttribute {\n\tWORLD = 'PhysicsIdAttribute_worldId',\n\tRBD_HANDLE = 'PhysicsIdAttribute_rbdHandle',\n\tDEBUG_WORLD = 'PhysicsIdAttribute_debugWorldId',\n}\nexport enum PhysicsRBDType {\n\tFIXED = 'fixed',\n\tDYNAMIC = 'dynamic',\n\tKINEMATIC_VEL = 'kinematicVelocityBased',\n\tKINEMATIC_POS = 'kinematicPositionBased',\n}\nexport const PHYSICS_RBD_TYPES: PhysicsRBDType[] = [\n\tPhysicsRBDType.FIXED,\n\tPhysicsRBDType.DYNAMIC,\n\tPhysicsRBDType.KINEMATIC_POS,\n\tPhysicsRBDType.KINEMATIC_VEL,\n];\nexport const PHYSICS_RBD_TYPE_MENU_ENTRIES = PHYSICS_RBD_TYPES.map((name, value) => ({name, value}));\n\nexport enum PhysicsRBDColliderType {\n\tCAPSULE = 'capsule',\n\tCONE = 'cone',\n\tCONVEX_HULL = 'convex hull',\n\t// CONVEX_MESH = 'convex mesh',\n\tCUBOID = 'cuboid',\n\tCYLINDER = 'cylinder',\n\tSPHERE = 'sphere',\n\tTRIMESH = 'trimesh',\n\tHEIGHT_FIELD = 'heightField',\n}\nexport const PHYSICS_RBD_COLLIDER_TYPES: PhysicsRBDColliderType[] = [\n\tPhysicsRBDColliderType.CUBOID,\n\tPhysicsRBDColliderType.SPHERE,\n\tPhysicsRBDColliderType.CAPSULE,\n\tPhysicsRBDColliderType.CYLINDER,\n\tPhysicsRBDColliderType.CONE,\n\tPhysicsRBDColliderType.CONVEX_HULL,\n\t// PhysicsRBDColliderType.CONVEX_MESH,\n\tPhysicsRBDColliderType.TRIMESH,\n\tPhysicsRBDColliderType.HEIGHT_FIELD,\n];\nconst SORTED_ENTRIES: PhysicsRBDColliderType[] = [\n\tPhysicsRBDColliderType.CAPSULE,\n\tPhysicsRBDColliderType.CONE,\n\tPhysicsRBDColliderType.CONVEX_HULL,\n\t// PhysicsRBDColliderType.CONVEX_MESH,\n\tPhysicsRBDColliderType.CUBOID,\n\tPhysicsRBDColliderType.CYLINDER,\n\tPhysicsRBDColliderType.SPHERE,\n\tPhysicsRBDColliderType.TRIMESH,\n\tPhysicsRBDColliderType.HEIGHT_FIELD,\n];\nexport const PHYSICS_RBD_COLLIDER_TYPE_MENU_ENTRIES = SORTED_ENTRIES.map((entry) => {\n\treturn {name: entry, value: PHYSICS_RBD_COLLIDER_TYPES.indexOf(entry)};\n});\n\nexport enum PhysicsRBDCuboidAttribute {\n\tSIZES = 'sizes',\n\tSIZE = 'size',\n}\nexport enum PhysicsRBDRadiusAttribute {\n\tRADIUS = 'radius',\n}\nexport enum PhysicsRBDHeightAttribute {\n\tHEIGHT = 'height',\n}\nexport enum PhysicsRBDCylinderAttribute {\n\tHEIGHT = 'height',\n}\nexport enum PhysicsRBDHeightFieldAttribute {\n\tHEIGHT_FIELD_ROWS = 'heightFieldRows',\n\tHEIGHT_FIELD_COLS = 'heightFieldCols',\n}\n\nexport enum PhysicsCommonAttribute {\n\tRBD_ID = 'RBDId',\n\tRBD_TYPE = 'RBDType',\n\tCOLLIDER_TYPE = 'RBDColliderType',\n\t//\n\tBORDER_RADIUS = 'borderRadius',\n\tCAN_SLEEP = 'RBDCanSleep',\n\tDENSITY = 'density',\n\tRESTITUTION = 'restitution',\n\tFRICTION = 'friction',\n\tLINEAR_DAMPING = 'linearDamping',\n\tANGULAR_DAMPING = 'angularDamping',\n\tLINEAR_VELOCITY = 'linearVelocity',\n\tANGULAR_VELOCITY = 'angularVelocity',\n\tGRAVITY_SCALE = 'gravityScale',\n\t//\n\tCHARACTER_CONTROLLER_ID = 'characterControllerId',\n\tCHARACTER_CONTROLLER_OFFSET = 'characterControllerOffset',\n\tCHARACTER_CONTROLLER_APPLY_IMPULSES_TO_DYNAMIC = 'characterControllerApplyImpulsesToDynamic',\n\tCHARACTER_CONTROLLER_SNAP_TO_GROUND_DISTANCE = 'characterControllerSnapToGroundDistance',\n\tCHARACTER_CONTROLLER_AUTO_STEP_MAX_HEIGHT = 'characterControllerAutoStepMaxHeight',\n\tCHARACTER_CONTROLLER_AUTO_STEP_MIN_WIDTH = 'characterControllerAutoStepMinWidth',\n\tCHARACTER_CONTROLLER_AUTO_STEP_ON_DYNAMIC = 'characterControllerAutoStepOnDynamic',\n\tCHARACTER_CONTROLLER_MAX_SLOPE_CLIMB_ANGLE = 'characterControllerMaxSlopeClimbAngle',\n\tCHARACTER_CONTROLLER_MIN_SLOPE_CLIMB_ANGLE = 'characterControllerMinSlopeSlideAngle',\n\tCHARACTER_CONTROLLER_UP = 'characterControllerUp',\n\tCHARACTER_CONTROLLER_CAMERA_OBJECT_PATH = 'characterControllerCameraObjectPath',\n}\ntype PhysicsAttribute =\n\t| PhysicsCommonAttribute\n\t| PhysicsRBDCuboidAttribute\n\t| PhysicsRBDRadiusAttribute\n\t| PhysicsRBDHeightAttribute\n\t| PhysicsRBDHeightFieldAttribute\n\t| PhysicsJointAttribute;\n\nexport function physicsAttribNameLive(attribute: PhysicsAttribute): string {\n\t// return attribute;\n\treturn `${attribute}-live`;\n}\n\nexport class CorePhysicsAttribute {\n\tstatic setRBDHandle(object: ObjectContent<CoreObjectType>, value: number) {\n\t\tsetObjectNumber(object, PhysicsIdAttribute.RBD_HANDLE, value);\n\t}\n\tstatic getRBDHandle(object: ObjectContent<CoreObjectType>): number {\n\t\treturn getObjectNumber(object, PhysicsIdAttribute.RBD_HANDLE, -1);\n\t}\n\tstatic deleteRBDHandle(object: ObjectContent<CoreObjectType>): void {\n\t\tcoreObjectClassFactory(object).deleteAttribute(object, PhysicsIdAttribute.RBD_HANDLE);\n\t}\n\t// common\n\tstatic setRBDId(object: ObjectContent<CoreObjectType>, value: string) {\n\t\tsetObjectString(object, PhysicsCommonAttribute.RBD_ID, value);\n\t}\n\tstatic getRBDId(object: ObjectContent<CoreObjectType>): string {\n\t\treturn getObjectString(object, PhysicsCommonAttribute.RBD_ID) as string;\n\t}\n\tstatic setRBDType(object: ObjectContent<CoreObjectType>, value: PhysicsRBDType) {\n\t\tsetObjectString(object, PhysicsCommonAttribute.RBD_TYPE, value);\n\t}\n\tstatic getRBDType(object: ObjectContent<CoreObjectType>): PhysicsRBDType | undefined {\n\t\treturn getObjectString(object, PhysicsCommonAttribute.RBD_TYPE) as PhysicsRBDType | undefined;\n\t}\n\tstatic setColliderType(object: ObjectContent<CoreObjectType>, value: PhysicsRBDColliderType) {\n\t\tsetObjectString(object, PhysicsCommonAttribute.COLLIDER_TYPE, value);\n\t}\n\tstatic getColliderType(object: ObjectContent<CoreObjectType>): PhysicsRBDColliderType | undefined {\n\t\treturn getObjectString(object, PhysicsCommonAttribute.COLLIDER_TYPE) as PhysicsRBDColliderType | undefined;\n\t}\n\tstatic setCanSleep(object: ObjectContent<CoreObjectType>, value: boolean) {\n\t\tsetObjectBoolean(object, PhysicsCommonAttribute.CAN_SLEEP, value);\n\t}\n\tstatic getCanSleep(object: ObjectContent<CoreObjectType>) {\n\t\treturn getObjectBoolean(object, PhysicsCommonAttribute.CAN_SLEEP, true);\n\t}\n\tstatic setDensity(object: ObjectContent<CoreObjectType>, value: number) {\n\t\tsetObjectNumber(object, PhysicsCommonAttribute.DENSITY, value);\n\t}\n\tstatic getDensity(object: ObjectContent<CoreObjectType>) {\n\t\treturn getObjectNumber(object, PhysicsCommonAttribute.DENSITY, 1);\n\t}\n\tstatic setRestitution(object: ObjectContent<CoreObjectType>, value: number) {\n\t\tsetObjectNumber(object, PhysicsCommonAttribute.RESTITUTION, value);\n\t}\n\tstatic getRestitution(object: ObjectContent<CoreObjectType>) {\n\t\treturn getObjectNumber(object, PhysicsCommonAttribute.RESTITUTION, 0.5);\n\t}\n\tstatic setFriction(object: ObjectContent<CoreObjectType>, value: number) {\n\t\tsetObjectNumber(object, PhysicsCommonAttribute.FRICTION, value);\n\t}\n\tstatic getFriction(object: ObjectContent<CoreObjectType>) {\n\t\treturn getObjectNumber(object, PhysicsCommonAttribute.FRICTION, 0);\n\t}\n\tstatic setLinearDamping(object: ObjectContent<CoreObjectType>, value: number) {\n\t\tsetObjectNumber(object, PhysicsCommonAttribute.LINEAR_DAMPING, value);\n\t}\n\tstatic getLinearDamping(object: ObjectContent<CoreObjectType>) {\n\t\treturn getObjectNumber(object, PhysicsCommonAttribute.LINEAR_DAMPING, 0);\n\t}\n\tstatic setAngularDamping(object: ObjectContent<CoreObjectType>, value: number) {\n\t\tsetObjectNumber(object, PhysicsCommonAttribute.ANGULAR_DAMPING, value);\n\t}\n\tstatic getAngularDamping(object: ObjectContent<CoreObjectType>) {\n\t\treturn getObjectNumber(object, PhysicsCommonAttribute.ANGULAR_DAMPING, 0);\n\t}\n\tstatic setLinearVelocity(object: ObjectContent<CoreObjectType>, value: Vector3) {\n\t\tsetObjectVector3(object, PhysicsCommonAttribute.LINEAR_VELOCITY, value);\n\t}\n\tstatic getLinearVelocity(object: ObjectContent<CoreObjectType>, target: Vector3) {\n\t\treturn getObjectVector3(object, PhysicsCommonAttribute.LINEAR_VELOCITY, target);\n\t}\n\tstatic setAngularVelocity(object: ObjectContent<CoreObjectType>, value: Vector3) {\n\t\tsetObjectVector3(object, PhysicsCommonAttribute.ANGULAR_VELOCITY, value);\n\t}\n\tstatic getAngularVelocity(object: ObjectContent<CoreObjectType>, target: Vector3) {\n\t\treturn getObjectVector3(object, PhysicsCommonAttribute.ANGULAR_VELOCITY, target);\n\t}\n\tstatic setGravityScale(object: ObjectContent<CoreObjectType>, value: number) {\n\t\tsetObjectNumber(object, PhysicsCommonAttribute.GRAVITY_SCALE, value);\n\t}\n\tstatic getGravityScale(object: ObjectContent<CoreObjectType>) {\n\t\treturn getObjectNumber(object, PhysicsCommonAttribute.GRAVITY_SCALE, 0);\n\t}\n\n\t// shapes\n\tstatic setBorderRadius(object: ObjectContent<CoreObjectType>, value: number) {\n\t\tsetObjectNumber(object, PhysicsCommonAttribute.BORDER_RADIUS, value);\n\t}\n\tstatic getBorderRadius(object: ObjectContent<CoreObjectType>) {\n\t\treturn getObjectNumber(object, PhysicsCommonAttribute.BORDER_RADIUS, 0);\n\t}\n\n\t// cuboid\n\tstatic setCuboidSizes(object: ObjectContent<CoreObjectType>, value: Vector3) {\n\t\tsetObjectVector3(object, PhysicsRBDCuboidAttribute.SIZES, value);\n\t}\n\tstatic getCuboidSizes(object: ObjectContent<CoreObjectType>, value: Vector3) {\n\t\tgetObjectVector3(object, PhysicsRBDCuboidAttribute.SIZES, value);\n\t}\n\tstatic setCuboidSize(object: ObjectContent<CoreObjectType>, value: number) {\n\t\tsetObjectNumber(object, PhysicsRBDCuboidAttribute.SIZE, value);\n\t}\n\tstatic getCuboidSize(object: ObjectContent<CoreObjectType>) {\n\t\treturn getObjectNumber(object, PhysicsRBDCuboidAttribute.SIZE, 1);\n\t}\n\t// sphere + capsule + cylinder\n\tstatic setRadius(object: ObjectContent<CoreObjectType>, value: number) {\n\t\tsetObjectNumber(object, PhysicsRBDRadiusAttribute.RADIUS, value);\n\t}\n\tstatic getRadius(object: ObjectContent<CoreObjectType>) {\n\t\treturn getObjectNumber(object, PhysicsRBDRadiusAttribute.RADIUS, 1);\n\t}\n\t// capsule + cylinder\n\tstatic setHeight(object: ObjectContent<CoreObjectType>, value: number) {\n\t\tsetObjectNumber(object, PhysicsRBDHeightAttribute.HEIGHT, value);\n\t}\n\tstatic getHeight(object: ObjectContent<CoreObjectType>) {\n\t\treturn getObjectNumber(object, PhysicsRBDHeightAttribute.HEIGHT, 1);\n\t}\n\t// heightfield\n\tstatic setHeightFieldRows(object: ObjectContent<CoreObjectType>, value: number) {\n\t\tsetObjectNumber(object, PhysicsRBDHeightFieldAttribute.HEIGHT_FIELD_ROWS, value);\n\t}\n\tstatic getHeightFieldRows(object: ObjectContent<CoreObjectType>) {\n\t\treturn getObjectNumber(object, PhysicsRBDHeightFieldAttribute.HEIGHT_FIELD_ROWS, 2);\n\t}\n\tstatic setHeightFieldCols(object: ObjectContent<CoreObjectType>, value: number) {\n\t\tsetObjectNumber(object, PhysicsRBDHeightFieldAttribute.HEIGHT_FIELD_COLS, value);\n\t}\n\tstatic getHeightFieldCols(object: ObjectContent<CoreObjectType>) {\n\t\treturn getObjectNumber(object, PhysicsRBDHeightFieldAttribute.HEIGHT_FIELD_COLS, 2);\n\t}\n\t// character controller\n\tstatic setCharacterControllerId(object: ObjectContent<CoreObjectType>, value: string) {\n\t\tsetObjectString(object, PhysicsCommonAttribute.CHARACTER_CONTROLLER_ID, value);\n\t}\n\tstatic getCharacterControllerId(object: ObjectContent<CoreObjectType>): string {\n\t\treturn getObjectString(object, PhysicsCommonAttribute.CHARACTER_CONTROLLER_ID) as string;\n\t}\n\tstatic setCharacterControllerOffset(object: ObjectContent<CoreObjectType>, value: number) {\n\t\tsetObjectNumber(object, PhysicsCommonAttribute.CHARACTER_CONTROLLER_OFFSET, value);\n\t}\n\tstatic getCharacterControllerOffset(object: ObjectContent<CoreObjectType>): number {\n\t\treturn getObjectNumber(object, PhysicsCommonAttribute.CHARACTER_CONTROLLER_OFFSET, 0.01) as number;\n\t}\n\tstatic setCharacterControllerUp(object: ObjectContent<CoreObjectType>, value: Vector3) {\n\t\tsetObjectVector3(object, PhysicsCommonAttribute.CHARACTER_CONTROLLER_UP, value);\n\t}\n\tstatic getCharacterControllerUp(object: ObjectContent<CoreObjectType>, target: Vector3) {\n\t\treturn getObjectVector3(object, PhysicsCommonAttribute.CHARACTER_CONTROLLER_UP, target);\n\t}\n\tstatic setCharacterControllerMaxSlopeClimbAngle(object: ObjectContent<CoreObjectType>, value: number) {\n\t\tsetObjectNumber(object, PhysicsCommonAttribute.CHARACTER_CONTROLLER_MAX_SLOPE_CLIMB_ANGLE, value);\n\t}\n\tstatic getCharacterControllerMaxSlopeClimbAngle(object: ObjectContent<CoreObjectType>): number {\n\t\treturn getObjectNumber(object, PhysicsCommonAttribute.CHARACTER_CONTROLLER_MAX_SLOPE_CLIMB_ANGLE, 0) as number;\n\t}\n\tstatic setCharacterControllerMinSlopeSlideAngle(object: ObjectContent<CoreObjectType>, value: number) {\n\t\tsetObjectNumber(object, PhysicsCommonAttribute.CHARACTER_CONTROLLER_MIN_SLOPE_CLIMB_ANGLE, value);\n\t}\n\tstatic getCharacterControllerMinSlopeSlideAngle(object: ObjectContent<CoreObjectType>): number {\n\t\treturn getObjectNumber(object, PhysicsCommonAttribute.CHARACTER_CONTROLLER_MIN_SLOPE_CLIMB_ANGLE, 0) as number;\n\t}\n\tstatic setCharacterControllerApplyImpulsesToDynamic(object: ObjectContent<CoreObjectType>, value: boolean) {\n\t\tsetObjectBoolean(object, PhysicsCommonAttribute.CHARACTER_CONTROLLER_APPLY_IMPULSES_TO_DYNAMIC, value);\n\t}\n\tstatic getCharacterControllerApplyImpulsesToDynamic(object: ObjectContent<CoreObjectType>): boolean {\n\t\treturn getObjectBoolean(\n\t\t\tobject,\n\t\t\tPhysicsCommonAttribute.CHARACTER_CONTROLLER_APPLY_IMPULSES_TO_DYNAMIC,\n\t\t\tfalse\n\t\t) as boolean;\n\t}\n\tstatic setCharacterControllerSnapToGroundDistance(object: ObjectContent<CoreObjectType>, value: number) {\n\t\tsetObjectNumber(object, PhysicsCommonAttribute.CHARACTER_CONTROLLER_SNAP_TO_GROUND_DISTANCE, value);\n\t}\n\tstatic getCharacterControllerSnapToGroundDistance(object: ObjectContent<CoreObjectType>): number {\n\t\treturn getObjectNumber(\n\t\t\tobject,\n\t\t\tPhysicsCommonAttribute.CHARACTER_CONTROLLER_SNAP_TO_GROUND_DISTANCE,\n\t\t\t0\n\t\t) as number;\n\t}\n\t// auto step\n\tstatic setCharacterControllerAutoStepMaxHeight(object: ObjectContent<CoreObjectType>, value: number) {\n\t\tsetObjectNumber(object, PhysicsCommonAttribute.CHARACTER_CONTROLLER_AUTO_STEP_MAX_HEIGHT, value);\n\t}\n\tstatic getCharacterControllerAutoStepMaxHeight(object: ObjectContent<CoreObjectType>): number {\n\t\treturn getObjectNumber(object, PhysicsCommonAttribute.CHARACTER_CONTROLLER_AUTO_STEP_MAX_HEIGHT, 0) as number;\n\t}\n\tstatic setCharacterControllerAutoStepMinWidth(object: ObjectContent<CoreObjectType>, value: number) {\n\t\tsetObjectNumber(object, PhysicsCommonAttribute.CHARACTER_CONTROLLER_AUTO_STEP_MIN_WIDTH, value);\n\t}\n\tstatic getCharacterControllerAutoStepMinWidth(object: ObjectContent<CoreObjectType>): number {\n\t\treturn getObjectNumber(object, PhysicsCommonAttribute.CHARACTER_CONTROLLER_AUTO_STEP_MIN_WIDTH, 0) as number;\n\t}\n\tstatic setCharacterControllerAutoStepOnDynamic(object: ObjectContent<CoreObjectType>, value: boolean) {\n\t\tsetObjectBoolean(object, PhysicsCommonAttribute.CHARACTER_CONTROLLER_AUTO_STEP_ON_DYNAMIC, value);\n\t}\n\tstatic getCharacterControllerAutoStepOnDynamic(object: ObjectContent<CoreObjectType>): boolean {\n\t\treturn getObjectBoolean(\n\t\t\tobject,\n\t\t\tPhysicsCommonAttribute.CHARACTER_CONTROLLER_AUTO_STEP_ON_DYNAMIC,\n\t\t\tfalse\n\t\t) as boolean;\n\t}\n\t// camera\n\tstatic setCharacterControllerCameraPath(object: ObjectContent<CoreObjectType>, value: string) {\n\t\tsetObjectString(object, PhysicsCommonAttribute.CHARACTER_CONTROLLER_CAMERA_OBJECT_PATH, value);\n\t}\n\tstatic getCharacterControllerCameraPath(object: ObjectContent<CoreObjectType>): string {\n\t\treturn getObjectString(object, PhysicsCommonAttribute.CHARACTER_CONTROLLER_CAMERA_OBJECT_PATH) as string;\n\t}\n}\n","import {CoreGraphNodeId} from '../graph/CoreGraph';\nimport {LineBasicMaterial, BufferGeometry, LineSegments, BufferAttribute, Object3D} from 'three';\nimport {PhysicsIdAttribute} from './PhysicsAttribute';\nimport {physicsWorldFromNodeId} from './PhysicsWorld';\nimport {coreObjectClassFactory} from '../geometry/CoreObjectFactory';\n// interface PhysicsDebugPair {\n// \tobject: LineSegments;\n// \tworld: World;\n// }\n// const physicsDebugByGraphNodeId: Map<CoreGraphNodeId, PhysicsDebugPair> = new Map();\n\nexport function physicsCreateDebugObject() {\n\treturn new LineSegments(\n\t\tnew BufferGeometry(),\n\t\tnew LineBasicMaterial({\n\t\t\tcolor: 0xffffff,\n\t\t\tvertexColors: true,\n\t\t})\n\t);\n}\n// export function createOrFindPhysicsDebugObject(node: BaseNodeType, world: World) {\n// \tconst nodeId = node.graphNodeId();\n// \tlet pair = physicsDebugByGraphNodeId.get(nodeId);\n// \tif (!pair) {\n// \t\tconst debugObject = physicsCreateDebugObject();\n// \t\tpair = {object: debugObject, world};\n// \t\tphysicsDebugByGraphNodeId.set(nodeId, pair);\n// \t}\n\n// \tCoreObject.addAttribute(pair.object, PhysicsIdAttribute.DEBUG, nodeId);\n// \treturn pair;\n// }\n// export function physicsDebugPairFromDebugObject(debugObject: Object3D) {\n// \tconst nodeId = CoreObject.attribValue(debugObject, PhysicsIdAttribute.DEBUG) as CoreGraphNodeId | undefined;\n// \tif (nodeId == null) {\n// \t\treturn;\n// \t}\n// \treturn physicsDebugByGraphNodeId.get(nodeId);\n// }\n\nexport function updatePhysicsDebugObject(debugObject: Object3D) {\n\tconst nodeId = coreObjectClassFactory(debugObject).attribValue(debugObject, PhysicsIdAttribute.DEBUG_WORLD) as\n\t\t| CoreGraphNodeId\n\t\t| undefined;\n\tif (nodeId == null) {\n\t\treturn;\n\t}\n\tconst world = physicsWorldFromNodeId(nodeId);\n\tif (!world) {\n\t\treturn;\n\t}\n\tconst buffers = world.debugRender();\n\tconst geometry = (debugObject as LineSegments).geometry;\n\tgeometry.setAttribute('position', new BufferAttribute(buffers.vertices, 3));\n\tgeometry.setAttribute('color', new BufferAttribute(buffers.colors, 4));\n}\n","import type {\n\tRigidBody,\n\tWorld,\n\tImpulseJoint,\n\tFixedImpulseJoint,\n\tPrismaticImpulseJoint,\n\tSphericalImpulseJoint,\n\tRevoluteImpulseJoint,\n} from '@dimforge/rapier3d-compat';\nimport {Object3D, Vector4, Vector3, Vector2, BoxGeometry, Mesh, MeshBasicMaterial} from 'three';\nimport {CorePhysicsLoaded, PhysicsLib} from './CorePhysics';\nimport {getRBDFromId, physicsCreateRBDFromWorld, physicsWorldNodeIdFromObject} from './PhysicsWorld';\nimport {TypeAssert} from './../../engine/poly/Assert';\nimport {CoreGraphNodeId} from '../graph/CoreGraph';\nimport {\n\tgetObjectVector2,\n\tsetObjectVector2,\n\tgetObjectVector3,\n\tsetObjectVector3,\n\tgetObjectVector4,\n\tsetObjectVector4,\n\tgetObjectString,\n\tsetObjectString,\n} from '../geometry/AttributeUtils';\nimport {CorePhysicsAttribute} from './PhysicsAttribute';\nimport {_getPhysicsWorldFromRBD, _getRBDFromObject, _physicsRBDDelete} from './PhysicsRBD';\nimport {removeFromParent} from '../../engine/poly/PolyOnObjectsAddRemoveHooksController';\nimport {PolyScene} from '../../engine/scene/PolyScene';\nimport {PhysicsRBDType} from './PhysicsAttribute';\nimport {PhysicsRBDColliderType} from './PhysicsAttribute';\nimport {setFirstValue} from '../SetUtils';\nexport enum PhysicsJointType {\n\tFIXED = 'fixed',\n\tSPHERICAL = 'spherical',\n\tREVOLUT = 'revolute',\n\tPRISMATIC = 'prismatic',\n}\nexport const PHYSICS_JOINT_TYPES: PhysicsJointType[] = [\n\tPhysicsJointType.FIXED,\n\tPhysicsJointType.SPHERICAL,\n\tPhysicsJointType.REVOLUT,\n\tPhysicsJointType.PRISMATIC,\n];\nconst ALLOWED_JOIN_TYPES = [PhysicsJointType.FIXED, PhysicsJointType.SPHERICAL];\nexport const PHYSICS_JOINT_TYPE_MENU_ENTRIES = ALLOWED_JOIN_TYPES.map((name, value) => ({name, value}));\n\nexport enum PhysicsJointAttribute {\n\tJOIN_TYPE = 'jointType',\n\tRBD_ID1 = 'rbdId1',\n\tRBD_ID2 = 'rbdId2',\n\tANCHOR1 = 'anchor1',\n\tANCHOR2 = 'anchor2',\n\tLIMIT = 'limit',\n\tAXIS = 'axis',\n\tFRAME1 = 'frame1',\n\tFRAME2 = 'frame2',\n}\ninterface JointFixedData {\n\tframe1: Vector4;\n\tframe2: Vector4;\n}\ninterface JointPrismaticData {\n\taxis: Vector3;\n\tlimit: Vector2;\n}\ninterface JointRevolutData {\n\taxis: Vector3;\n\tlimit: Vector2;\n}\n\nexport interface JointData {\n\tjointType: PhysicsJointType;\n\trbdId1: string;\n\trbdId2: string;\n\tanchor1: Vector3;\n\tanchor2: Vector3;\n\tdata: {\n\t\tfixed?: JointFixedData;\n\t\tprismatic?: JointPrismaticData;\n\t\trevolut?: JointRevolutData;\n\t};\n}\n\nexport class CorePhysicsJoinAttribute {\n\t// common\n\tstatic setJoinType(object: Object3D, value: PhysicsJointType) {\n\t\tsetObjectString(object, PhysicsJointAttribute.JOIN_TYPE, value);\n\t}\n\tstatic getJoinType(object: Object3D): PhysicsJointType {\n\t\treturn getObjectString(object, PhysicsJointAttribute.JOIN_TYPE) as PhysicsJointType;\n\t}\n\tstatic setRBDId1(object: Object3D, value: string) {\n\t\tsetObjectString(object, PhysicsJointAttribute.RBD_ID1, value);\n\t}\n\tstatic getRBDId1(object: Object3D): string {\n\t\treturn getObjectString(object, PhysicsJointAttribute.RBD_ID1) as string;\n\t}\n\tstatic setRBDId2(object: Object3D, value: string) {\n\t\tsetObjectString(object, PhysicsJointAttribute.RBD_ID2, value);\n\t}\n\tstatic getRBDId2(object: Object3D): string {\n\t\treturn getObjectString(object, PhysicsJointAttribute.RBD_ID2) as string;\n\t}\n\tstatic setAnchor1(object: Object3D, value: Vector3) {\n\t\tsetObjectVector3(object, PhysicsJointAttribute.ANCHOR1, value);\n\t}\n\tstatic getAnchor1(object: Object3D, value: Vector3): void {\n\t\treturn getObjectVector3(object, PhysicsJointAttribute.ANCHOR1, value);\n\t}\n\tstatic setAnchor2(object: Object3D, value: Vector3) {\n\t\tsetObjectVector3(object, PhysicsJointAttribute.ANCHOR2, value);\n\t}\n\tstatic getAnchor2(object: Object3D, value: Vector3): void {\n\t\treturn getObjectVector3(object, PhysicsJointAttribute.ANCHOR2, value);\n\t}\n\tstatic setLimit(object: Object3D, value: Vector2) {\n\t\tsetObjectVector2(object, PhysicsJointAttribute.LIMIT, value);\n\t}\n\tstatic getLimit(object: Object3D, value: Vector2): void {\n\t\treturn getObjectVector2(object, PhysicsJointAttribute.LIMIT, value);\n\t}\n\tstatic setAxis(object: Object3D, value: Vector3) {\n\t\tsetObjectVector3(object, PhysicsJointAttribute.AXIS, value);\n\t}\n\tstatic getAxis(object: Object3D, value: Vector3): void {\n\t\treturn getObjectVector3(object, PhysicsJointAttribute.AXIS, value);\n\t}\n\tstatic setFrame1(object: Object3D, value: Vector4) {\n\t\tsetObjectVector4(object, PhysicsJointAttribute.FRAME1, value);\n\t}\n\tstatic getFrame1(object: Object3D, value: Vector4): void {\n\t\treturn getObjectVector4(object, PhysicsJointAttribute.FRAME1, value);\n\t}\n\tstatic setFrame2(object: Object3D, value: Vector4) {\n\t\tsetObjectVector4(object, PhysicsJointAttribute.FRAME2, value);\n\t}\n\tstatic getFrame2(object: Object3D, value: Vector4): void {\n\t\treturn getObjectVector4(object, PhysicsJointAttribute.FRAME2, value);\n\t}\n}\n\ntype JointDataListByWorldObject = Map<CoreGraphNodeId, JointData[]>;\nconst jointDataListByWorldObject: JointDataListByWorldObject = new Map();\n\nexport function setJointDataListForWorldObject(scene: PolyScene, worldObject: Object3D) {\n\tconst nodeId = physicsWorldNodeIdFromObject(worldObject);\n\tif (nodeId == null) {\n\t\treturn;\n\t}\n\tconst array: JointData[] = [];\n\tjointDataListByWorldObject.set(nodeId, array);\n\tconst childrenToRemove: Object3D[] = [];\n\tworldObject.traverse((child) => {\n\t\tconst jointData = createJointDataFromJoinObject(child);\n\t\tif (jointData) {\n\t\t\tchildrenToRemove.push(child);\n\t\t\tarray.push(jointData);\n\t\t}\n\t});\n\tfor (const child of childrenToRemove) {\n\t\t// child.parent?.remove(child);\n\t\tremoveFromParent(scene, child);\n\t}\n}\n\nfunction createJointDataFromJoinObject(object: Object3D): JointData | undefined {\n\tconst jointType = CorePhysicsJoinAttribute.getJoinType(object);\n\tif (!jointType) {\n\t\treturn;\n\t}\n\tconst rbdId1 = CorePhysicsJoinAttribute.getRBDId1(object);\n\tconst rbdId2 = CorePhysicsJoinAttribute.getRBDId2(object);\n\tif (rbdId1 == null || rbdId2 == null) {\n\t\treturn;\n\t}\n\tconst anchor1 = new Vector3();\n\tconst anchor2 = new Vector3();\n\tCorePhysicsJoinAttribute.getAnchor1(object, anchor1);\n\tCorePhysicsJoinAttribute.getAnchor2(object, anchor2);\n\n\tconst jointData: JointData = {\n\t\tjointType,\n\t\trbdId1,\n\t\trbdId2,\n\t\tanchor1,\n\t\tanchor2,\n\t\tdata: {},\n\t};\n\tswitch (jointType) {\n\t\tcase PhysicsJointType.FIXED: {\n\t\t\tconst frame1 = new Vector4();\n\t\t\tconst frame2 = new Vector4();\n\t\t\tCorePhysicsJoinAttribute.getFrame1(object, frame1);\n\t\t\tCorePhysicsJoinAttribute.getFrame1(object, frame1);\n\t\t\tjointData.data.fixed = {frame1, frame2};\n\t\t\treturn jointData;\n\t\t}\n\t\tcase PhysicsJointType.PRISMATIC: {\n\t\t\tconst axis = new Vector3();\n\t\t\tconst limit = new Vector2();\n\t\t\tCorePhysicsJoinAttribute.getAxis(object, axis);\n\t\t\tCorePhysicsJoinAttribute.getLimit(object, limit);\n\t\t\tjointData.data.prismatic = {axis, limit};\n\t\t\treturn jointData;\n\t\t}\n\t\tcase PhysicsJointType.REVOLUT: {\n\t\t\tconst axis = new Vector3();\n\t\t\tconst limit = new Vector2();\n\t\t\tCorePhysicsJoinAttribute.getAxis(object, axis);\n\t\t\tCorePhysicsJoinAttribute.getLimit(object, limit);\n\t\t\tjointData.data.revolut = {axis, limit};\n\t\t\treturn jointData;\n\t\t}\n\t\tcase PhysicsJointType.SPHERICAL: {\n\t\t\treturn jointData;\n\t\t}\n\t}\n\tTypeAssert.unreachable(jointType);\n}\n\nconst wakeUp = true;\n// const _limit = new Vector2();\n// const _anchor1 = new Vector3();\n// const _anchor2 = new Vector3();\n// const _axis = new Vector3();\n// const _frame1 = new Vector4();\n// const _frame2 = new Vector4();\nexport function physicsCreateJoints(PhysicsLib: PhysicsLib, world: World, worldObject: Object3D) {\n\tconst nodeId = physicsWorldNodeIdFromObject(worldObject);\n\tif (nodeId == null) {\n\t\treturn;\n\t}\n\tconst jointDataList = jointDataListByWorldObject.get(nodeId);\n\tif (!jointDataList) {\n\t\treturn;\n\t}\n\tfor (const jointData of jointDataList) {\n\t\tphysicsCreateJointFromJointData(PhysicsLib, world, jointData);\n\t}\n}\nexport function physicsCreateJointFromJointData(PhysicsLib: PhysicsLib, world: World, jointData: JointData) {\n\tconst {rbdId1, rbdId2} = jointData;\n\n\tconst rbd1 = getRBDFromId(rbdId1);\n\tconst rbd2 = getRBDFromId(rbdId2);\n\tif (!(rbd1 && rbd2)) {\n\t\treturn;\n\t}\n\n\tconst joint = _createJoint(world, PhysicsLib, jointData, rbd1, rbd2);\n\n\t// configureMotorPosition(targetPos, stiffness, damping)\n\t// configureMotorVelocity(targetVel, damping)\n\t// configureMotor(targetPos, targetVel, stiffness, damping)\n\t// configureMotorModel(model)\n\t// console.log(joint);\n\t// if ((joint as PrismaticImpulseJoint).configureMotorPosition) {\n\t// \t(joint as PrismaticImpulseJoint).configureMotorPosition(0, 1, 1);\n\t// } else {\n\t// \tconsole.warn('configureMotorPosition not available');\n\t// }\n\t// if ((joint as PrismaticImpulseJoint).configureMotorVelocity) {\n\t// \t(joint as PrismaticImpulseJoint).configureMotorVelocity(-10, 0.5);\n\t// } else {\n\t// \tconsole.warn('configureMotorVelocity not available');\n\t// }\n\t// if ((joint as PrismaticImpulseJoint).configureMotor) {\n\t// \t(joint as PrismaticImpulseJoint).configureMotor(0, 0.1, 1, 1);\n\t// } else {\n\t// \tconsole.warn('configureMotor not available');\n\t// }\n\t// console.log('create joint', jointType, joint);\n\n\t// remove object from hierarchy after joint creation,\n\t// so that it doesn't need to be parsed when traversing the scene\n\t// object.parent?.remove(object);\n\n\treturn joint;\n}\n// export function physicsCreateJointFromObject(\n// \tPhysicsLib: PhysicsLib,\n// \tworld: World,\n// \tworldObject: Object3D,\n// \tobject: Object3D,\n// \trigidBodyById: Map<string, RigidBody>\n// ) {\n// \tconst jointType = CorePhysicsJoinAttribute.getJoinType(object);\n// \tif (!jointType) {\n// \t\treturn;\n// \t}\n\n// \tconst rbdId1 = CorePhysicsJoinAttribute.getRBDId1(object);\n// \tconst rbdId2 = CorePhysicsJoinAttribute.getRBDId2(object);\n// \tconst rbd1 = rigidBodyById.get(rbdId1);\n// \tconst rbd2 = rigidBodyById.get(rbdId2);\n// \tif (!(rbd1 && rbd2)) {\n// \t\treturn;\n// \t}\n// \tCorePhysicsJoinAttribute.getAnchor1(object, _anchor1);\n// \tCorePhysicsJoinAttribute.getAnchor2(object, _anchor2);\n\n// \tconst joint = _createJoint(world, PhysicsLib, object, jointType, rbd1, rbd2, _anchor1, _anchor2);\n\n// \t// configureMotorPosition(targetPos, stiffness, damping)\n// \t// configureMotorVelocity(targetVel, damping)\n// \t// configureMotor(targetPos, targetVel, stiffness, damping)\n// \t// configureMotorModel(model)\n// \t// console.log(joint);\n// \t// if ((joint as PrismaticImpulseJoint).configureMotorPosition) {\n// \t// \t(joint as PrismaticImpulseJoint).configureMotorPosition(0, 1, 1);\n// \t// } else {\n// \t// \tconsole.warn('configureMotorPosition not available');\n// \t// }\n// \t// if ((joint as PrismaticImpulseJoint).configureMotorVelocity) {\n// \t// \t(joint as PrismaticImpulseJoint).configureMotorVelocity(-10, 0.5);\n// \t// } else {\n// \t// \tconsole.warn('configureMotorVelocity not available');\n// \t// }\n// \t// if ((joint as PrismaticImpulseJoint).configureMotor) {\n// \t// \t(joint as PrismaticImpulseJoint).configureMotor(0, 0.1, 1, 1);\n// \t// } else {\n// \t// \tconsole.warn('configureMotor not available');\n// \t// }\n// \t// console.log('create joint', jointType, joint);\n\n// \t// remove object from hierarchy after joint creation,\n// \t// so that it doesn't need to be parsed when traversing the scene\n// \tobject.parent?.remove(object);\n\n// \treturn joint;\n// }\n\nfunction _createJoint(\n\tworld: World,\n\tPhysicsLib: PhysicsLib,\n\tjointData: JointData,\n\trbd1: RigidBody,\n\trbd2: RigidBody\n): ImpulseJoint | undefined {\n\tconst {jointType, anchor1, anchor2} = jointData;\n\tswitch (jointType) {\n\t\tcase PhysicsJointType.FIXED: {\n\t\t\tconst fixedData = jointData.data.fixed;\n\t\t\tif (!fixedData) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t// const rot1 = {w: 1.0, x: 0.0, y: 0.0, z: 0.0};\n\t\t\t// const rot2 = {w: 1.0, x: 0.0, y: 0.0, z: 0.0};\n\t\t\t// console.log(_frame1.toArray());\n\t\t\t// console.log(_frame2.toArray());\n\t\t\tconst {frame1, frame2} = fixedData;\n\t\t\tconst params = PhysicsLib.JointData.fixed(anchor1, frame1, anchor2, frame2);\n\t\t\tconst joint = world.createImpulseJoint(params, rbd1, rbd2, wakeUp) as FixedImpulseJoint;\n\t\t\treturn joint;\n\t\t}\n\t\tcase PhysicsJointType.PRISMATIC: {\n\t\t\tconst prismaticfixedData = jointData.data.prismatic;\n\t\t\tif (!prismaticfixedData) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tconst {axis, limit} = prismaticfixedData;\n\t\t\t// const axis = {x: 1.0, y: 0.0, z: 0.0};\n\t\t\tconst params = PhysicsLib.JointData.prismatic(anchor1, anchor2, axis);\n\t\t\tparams.limitsEnabled = true;\n\t\t\tparams.limits = [limit.x, limit.y];\n\t\t\tconst joint = world.createImpulseJoint(params, rbd1, rbd2, wakeUp) as PrismaticImpulseJoint;\n\t\t\tjoint.setLimits(limit.x, limit.y);\n\t\t\treturn joint;\n\t\t}\n\t\tcase PhysicsJointType.REVOLUT: {\n\t\t\tconst revolutfixedData = jointData.data.revolut;\n\t\t\tif (!revolutfixedData) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tconst {axis, limit} = revolutfixedData;\n\t\t\t// const axis = {x: 0.0, y: 0.0, z: 1.0};\n\t\t\tconst params = PhysicsLib.JointData.revolute(anchor1, anchor2, axis);\n\t\t\tparams.limitsEnabled = true;\n\t\t\tparams.limits = [limit.x, limit.y];\n\t\t\tconst joint = world.createImpulseJoint(params, rbd1, rbd2, wakeUp) as RevoluteImpulseJoint;\n\t\t\tjoint.setLimits(limit.x, limit.y);\n\t\t\treturn joint;\n\t\t}\n\t\tcase PhysicsJointType.SPHERICAL: {\n\t\t\tconst params = PhysicsLib.JointData.spherical(anchor1, anchor2);\n\t\t\tconst joint = world.createImpulseJoint(params, rbd1, rbd2, wakeUp) as SphericalImpulseJoint;\n\t\t\treturn joint;\n\t\t}\n\t}\n\tTypeAssert.unreachable(jointType);\n}\n\ninterface CreateRBDForKinematicConstraintOptions {\n\tworld: World;\n\trbdId: string;\n\tanchor: Vector3;\n}\nconst anchor1 = new Vector3(0, 0, 0);\nconst anchor2 = new Vector3(0, 0, 0);\nconst _createRBDForKinematicConstraint = (options: CreateRBDForKinematicConstraintOptions) => {\n\tconst {world, rbdId, anchor} = options;\n\tconst size = 0.01;\n\tconst geometry = new BoxGeometry(size, size, size);\n\tconst object = new Mesh(geometry, new MeshBasicMaterial());\n\tobject.castShadow = false;\n\tobject.receiveShadow = false;\n\tobject.visible = false;\n\tobject.position.copy(anchor);\n\tobject.updateMatrix();\n\tobject.matrixAutoUpdate = false;\n\n\tobject.worldToLocal(anchor1.copy(anchor));\n\n\tconst RBD_ID = `kinematicConstraint-${rbdId}-${performance.now()}`;\n\tCorePhysicsAttribute.setDensity(object, 0);\n\tCorePhysicsAttribute.setRBDType(object, PhysicsRBDType.KINEMATIC_POS);\n\tCorePhysicsAttribute.setColliderType(object, PhysicsRBDColliderType.SPHERE);\n\tCorePhysicsAttribute.setRBDId(object, RBD_ID);\n\tCorePhysicsAttribute.setRadius(object, size / 2);\n\n\tconst newRBDIds = physicsCreateRBDFromWorld(world, object);\n\n\treturn {newRBDIds, object, anchor1};\n};\n\nexport function _createPhysicsRBDKinematicConstraint(rbdObject: Object3D, anchor: Vector3): string | undefined {\n\tconst PhysicsLib = CorePhysicsLoaded();\n\tif (!PhysicsLib) {\n\t\treturn;\n\t}\n\tconst rbdId1 = CorePhysicsAttribute.getRBDId(rbdObject);\n\tif (rbdId1 == null) {\n\t\treturn;\n\t}\n\tconst rbd1 = _getRBDFromObject(rbdObject);\n\tif (!rbd1) {\n\t\treturn;\n\t}\n\tconst world = _getPhysicsWorldFromRBD(rbdObject);\n\tif (!world) {\n\t\treturn;\n\t}\n\tconst result = _createRBDForKinematicConstraint({world, rbdId: rbdId1, anchor});\n\n\tconst rbdId2 = result.newRBDIds ? setFirstValue(result.newRBDIds) : undefined;\n\n\tif (!rbdId2) {\n\t\treturn;\n\t}\n\tconst jointData: JointData = {\n\t\tjointType: PhysicsJointType.SPHERICAL,\n\t\tanchor1: result.anchor1,\n\t\tanchor2,\n\t\trbdId1,\n\t\trbdId2,\n\t\tdata: {},\n\t};\n\n\tphysicsCreateJointFromJointData(PhysicsLib, world, jointData);\n\n\treturn rbdId2;\n\n\t// worldByRBD.set(rigidBody, world);\n\t// physicsRBDByRBDId.set(handle, rigidBody);\n\n\t// const rbd1 = world.getRigidBody(rbdId)\n\t// const rbdType: RigidBodyType = RigidBodyType.KinematicPositionBased;\n\t// const rigidBodyDesc = new PhysicsLib.RigidBodyDesc(rbdType);\n\t// rigidBodyDesc.setTranslation(rbdObject.position.x, rbdObject.position.y, rbdObject.position.z);\n\t// const rbd2Id = `constraint-${rbd1}-${performance.now()}`;\n\t// const rbd2 = _createRBDFromDescAndId(world, rigidBodyDesc, rbd2Id);\n\n\t// const jointData: JointData = {\n\t// \tjointType: PhysicsJointType.SPHERICAL,\n\t// \trbdId1: rbd1Id,\n\t// \trbdId2: rbd2Id,\n\t// \tanchor1: anchor,\n\t// \tanchor2: anchor,\n\t// \tdata: {},\n\t// };\n\t// _createJoint(world, PhysicsLib, jointData, rbd1, rbd2);\n\n\t// return rbd2Id;\n}\nexport function _deletePhysicsRBDKinematicConstraint(scene: PolyScene, object: Object3D) {\n\t_physicsRBDDelete(scene, object);\n}\n\nexport function _physicsRBDDeleteConstraints(rbdObject: Object3D) {\n\tconst handle = CorePhysicsAttribute.getRBDHandle(rbdObject);\n\tif (handle == null) {\n\t\treturn;\n\t}\n\tconst body = _getRBDFromObject(rbdObject);\n\tif (!body) {\n\t\treturn;\n\t}\n\tconst world = _getPhysicsWorldFromRBD(rbdObject);\n\tif (!world) {\n\t\treturn;\n\t}\n\n\tconst wakeUp = true;\n\tconst handles: number[] = [];\n\tworld.impulseJoints.forEachJointHandleAttachedToRigidBody(handle, (jointHandle) => {\n\t\thandles.push(jointHandle);\n\t\t// do not attempt to delete the joint from within forEachJointHandleAttachedToRigidBody\n\t\t// as it will not work. Instead accumulate the handles,\n\t\t// and do it right after\n\t});\n\tfor (const jointHandle of handles) {\n\t\tconst joint = world.getImpulseJoint(jointHandle);\n\t\tif (joint) {\n\t\t\tworld.removeImpulseJoint(joint, wakeUp);\n\t\t}\n\t}\n}\n","import {BufferAttribute, Mesh, Object3D} from 'three';\nimport {PhysicsLib} from '../CorePhysics';\n\nexport function createPhysicsTriMesh(PhysicsLib: PhysicsLib, object: Object3D) {\n\tconst geometry = (object as Mesh).geometry;\n\tif (!geometry) {\n\t\treturn;\n\t}\n\tconst position = geometry.getAttribute('position') as BufferAttribute;\n\tif (!position) {\n\t\treturn;\n\t}\n\tlet indexArray = geometry.getIndex()?.array;\n\tif (!indexArray) {\n\t\tconst pointsCount = position.array.length / 3;\n\t\tindexArray = new Uint32Array(pointsCount);\n\t\tfor (let i = 0; i < pointsCount; i++) {\n\t\t\tindexArray[i] = i;\n\t\t}\n\t}\n\tconst float32ArrayPosition = new Float32Array(position.array);\n\tconst uint32ArrayIndex = new Uint32Array(indexArray);\n\treturn PhysicsLib.ColliderDesc.trimesh(float32ArrayPosition, uint32ArrayIndex);\n}\n","import {BufferAttribute, Mesh, Object3D} from 'three';\nimport {PhysicsLib} from '../CorePhysics';\n\nexport function createPhysicsConvexHull(PhysicsLib: PhysicsLib, object: Object3D) {\n\tconst geometry = (object as Mesh).geometry;\n\tif (!geometry) {\n\t\treturn;\n\t}\n\tconst nonIndexedGeometry = geometry.toNonIndexed();\n\tconst position = nonIndexedGeometry.getAttribute('position') as BufferAttribute;\n\tif (!position) {\n\t\treturn;\n\t}\n\tconst float32Array = new Float32Array(position.array);\n\treturn PhysicsLib.ColliderDesc.convexHull(float32Array);\n}\n","import {Mesh, Object3D, Vector3} from 'three';\nimport {PhysicsLib} from '../CorePhysics';\nimport {ThreeMeshBVHHelper} from '../../../core/geometry/bvh/ThreeMeshBVHHelper';\nimport {CoreMath} from '../../math/_Module';\nimport {CorePhysicsAttribute} from '../PhysicsAttribute';\nimport {createRaycaster} from '../../RaycastHelper';\n\nconst bboxSize = new Vector3();\nconst bboxCenter = new Vector3();\nconst scale = new Vector3();\n\nconst raycaster = createRaycaster();\nexport function createPhysicsHeightField(PhysicsLib: PhysicsLib, object: Object3D) {\n\tconst geometry = (object as Mesh).geometry;\n\tif (!geometry) {\n\t\treturn;\n\t}\n\n\tThreeMeshBVHHelper.assignDefaultBVHIfNone(object as Mesh);\n\tgeometry.computeBoundingBox();\n\tconst boundingBox = geometry.boundingBox;\n\tif (!boundingBox) {\n\t\treturn;\n\t}\n\tboundingBox.getSize(bboxSize);\n\tboundingBox.getCenter(bboxCenter);\n\n\tconst nrows = CorePhysicsAttribute.getHeightFieldRows(object);\n\tconst ncols = CorePhysicsAttribute.getHeightFieldCols(object);\n\tconst arraySize = (nrows + 1) * (ncols + 1);\n\tconst array = new Array(arraySize);\n\traycaster.ray.direction.set(0, -1, 0);\n\traycaster.ray.origin.y = boundingBox.max.y + 1;\n\tlet i = 0;\n\tconst maxMult = 0.99;\n\tconst minMult = 1 - maxMult;\n\tfor (let col = 0; col <= ncols; col++) {\n\t\tconst coln = CoreMath.clamp(col / ncols, minMult, maxMult);\n\t\tfor (let row = 0; row <= nrows; row++) {\n\t\t\tconst rown = CoreMath.clamp(row / nrows, minMult, maxMult);\n\t\t\traycaster.ray.origin.x = boundingBox.min.x + bboxSize.x * coln;\n\t\t\traycaster.ray.origin.z = boundingBox.min.z + bboxSize.z * rown;\n\t\t\tconst intersections = raycaster.intersectObject(object);\n\t\t\tlet value = boundingBox.min.y;\n\t\t\tif (intersections) {\n\t\t\t\tconst firstIntersect = intersections[0];\n\t\t\t\tif (firstIntersect) {\n\t\t\t\t\tvalue = raycaster.ray.origin.y - firstIntersect.distance;\n\t\t\t\t}\n\t\t\t}\n\t\t\tarray[i] = value;\n\t\t\ti++;\n\t\t}\n\t}\n\tconst heights = new Float32Array(array);\n\tscale.set(bboxSize.x, 1, bboxSize.z);\n\n\tconst desc = PhysicsLib.ColliderDesc.heightfield(nrows, ncols, heights, scale);\n\tdesc.setTranslation(bboxCenter.x, 0, bboxCenter.z);\n\treturn desc;\n}\n","import {TypeAssert} from './../../engine/poly/Assert';\n// import {CorePhysicsUserData} from './PhysicsUserData';\nimport {PhysicsRBDColliderType, PhysicsRBDType, CorePhysicsAttribute} from './PhysicsAttribute';\nimport {Object3D, Vector3, Quaternion} from 'three';\nimport {World, RigidBodyType, RigidBodyDesc, RigidBody, ColliderDesc} from '@dimforge/rapier3d-compat';\nimport {CorePhysicsLoaded, PhysicsLib} from './CorePhysics';\nimport {createPhysicsSphere} from './shapes/RBDSphere';\nimport {createPhysicsCuboid} from './shapes/RBDCuboid';\nimport {createPhysicsCapsule} from './shapes/RBDCapsule';\nimport {createPhysicsCone} from './shapes/RBDCone';\nimport {createPhysicsCylinder} from './shapes/RBDCylinder';\nimport {createPhysicsTriMesh} from './shapes/RBDTrimesh';\nimport {createPhysicsConvexHull} from './shapes/ConvexHull';\nimport {createPhysicsHeightField} from './shapes/HeightField';\nimport {touchRBDProperties, touchRBDProperty} from '../reactivity/RBDPropertyReactivity';\nimport {OBJECT_TRANSFORM_PROPERTIES, touchObjectProperties} from '../reactivity/ObjectPropertyReactivity';\nimport {PolyScene} from '../../engine/scene/PolyScene';\nimport {removeFromParent} from '../../engine/poly/PolyOnObjectsAddRemoveHooksController';\nimport {getRBDFromId, object3DFromRBD} from './PhysicsWorld';\n\nexport enum RBDProperty {\n\tANGULAR_VELOCITY = 'angVel',\n\tLINEAR_VELOCITY = 'linVel',\n\tPOSITION = 'position',\n\tROTATION = 'rotation',\n\tLINEAR_DAMPING = 'linearDamping',\n\tANGULAR_DAMPING = 'angularDamping',\n\tIS_SLEEPING = 'isSleeping',\n\tIS_MOVING = 'isMoving',\n}\n\nconst tmpV3 = new Vector3();\n// const q1 = new Quaternion();\n// const q2 = new Quaternion();\nconst currentPos = new Vector3();\nconst currentLinearVelocity = new Vector3();\nconst currentAngularVelocity = new Vector3();\nconst newPos = new Vector3();\nconst newLinearVelocity = new Vector3();\nconst newAngularVelocity = new Vector3();\nconst currentQuaternion = new Quaternion();\nconst newQuaternion = new Quaternion();\nconst linearVelocity = new Vector3();\nconst angularVelocity = new Vector3();\n\ninterface CollidescObjectPair {\n\tobject: Object3D;\n\tcolliderDesc: ColliderDesc;\n}\n\nconst physicsRBDByRBDHandle: Map<number, RigidBody> = new Map();\n// const physicsRBDByRBDId: Map<string, RigidBody> = new Map();\nconst worldByRBD: WeakMap<RigidBody, World> = new WeakMap();\n\nfunction _createRBDFromDescAndId(world: World, rigidBodyDesc: RigidBodyDesc, rbdId: string) {\n\tconst rigidBody = world.createRigidBody(rigidBodyDesc);\n\tconst handle = rigidBody.handle;\n\tworldByRBD.set(rigidBody, world);\n\tphysicsRBDByRBDHandle.set(handle, rigidBody);\n\t// physicsRBDByRBDId.set(rbdId, rigidBody);\n\treturn rigidBody;\n}\nfunction _createRBDFromDescAndObject(world: World, rigidBodyDesc: RigidBodyDesc, object: Object3D) {\n\tconst rbdId = CorePhysicsAttribute.getRBDId(object);\n\tconst rigidBody = _createRBDFromDescAndId(world, rigidBodyDesc, rbdId);\n\tCorePhysicsAttribute.setRBDHandle(object, rigidBody.handle);\n\treturn rigidBody;\n}\ninterface CreateRBDFromAttributesOptions {\n\tPhysicsLib: PhysicsLib;\n\tworld: World;\n\tobject: Object3D;\n\trigidBodyById: Map<string, RigidBody>;\n\tobjectsByRBD: WeakMap<RigidBody, Object3D>;\n\tnewRBDIds: Set<string>;\n}\nfunction _createRBDFromAttributes(options: CreateRBDFromAttributesOptions): RigidBody | undefined {\n\tconst {PhysicsLib, world, object, rigidBodyById, objectsByRBD, newRBDIds} = options;\n\tconst type = CorePhysicsAttribute.getRBDType(object);\n\tif (type == null) {\n\t\treturn;\n\t}\n\tconst rbdType: RigidBodyType | undefined = PhysicsRBDTypeToRigidBodyType(type);\n\tif (rbdType == null) {\n\t\treturn;\n\t}\n\n\t// get attributes\n\tconst linearDamping = CorePhysicsAttribute.getLinearDamping(object);\n\tconst angularDamping = CorePhysicsAttribute.getAngularDamping(object);\n\tlinearVelocity.set(0, 0, 0);\n\tangularVelocity.set(0, 0, 0);\n\tCorePhysicsAttribute.getLinearVelocity(object, linearVelocity);\n\tCorePhysicsAttribute.getAngularVelocity(object, angularVelocity);\n\tconst gravityScale = CorePhysicsAttribute.getGravityScale(object);\n\tconst canSleep = CorePhysicsAttribute.getCanSleep(object);\n\n\t// create desc\n\tconst rigidBodyDesc = new PhysicsLib.RigidBodyDesc(rbdType);\n\trigidBodyDesc.setTranslation(object.position.x, object.position.y, object.position.z);\n\trigidBodyDesc.setRotation(object.quaternion);\n\trigidBodyDesc.setLinvel(linearVelocity.x, linearVelocity.y, linearVelocity.z);\n\trigidBodyDesc.setAngvel(angularVelocity);\n\tif (linearDamping != null) {\n\t\trigidBodyDesc.setLinearDamping(linearDamping);\n\t}\n\tif (angularDamping != null) {\n\t\trigidBodyDesc.setAngularDamping(angularDamping);\n\t}\n\tif (gravityScale != null) {\n\t\t// .setGravityScale seems to work when set on the rbd desc,\n\t\t// but not on the RBD itself\n\t\trigidBodyDesc.setGravityScale(gravityScale);\n\t}\n\tif (canSleep != null) {\n\t\trigidBodyDesc.setCanSleep(canSleep);\n\t}\n\n\t// create RBD\n\tconst rigidBody = _createRBDFromDescAndObject(world, rigidBodyDesc, object);\n\tobjectsByRBD.set(rigidBody, object);\n\tconst rbdId = CorePhysicsAttribute.getRBDId(object);\n\tif (rbdId) {\n\t\trigidBodyById.set(rbdId, rigidBody);\n\t\tnewRBDIds.add(rbdId);\n\t}\n\treturn rigidBody;\n}\nfunction _createColliderDesc(PhysicsLib: PhysicsLib, object: Object3D) {\n\tconst colliderType = CorePhysicsAttribute.getColliderType(object);\n\tif (!(colliderType != null)) {\n\t\treturn;\n\t}\n\tconst colliderDesc = PhysicsRBDCollider(PhysicsLib, colliderType, object);\n\tif (!colliderDesc) {\n\t\tconsole.error('no collider', object);\n\t\treturn;\n\t}\n\tconst restitution = CorePhysicsAttribute.getRestitution(object);\n\tconst friction = CorePhysicsAttribute.getFriction(object);\n\tconst density = CorePhysicsAttribute.getDensity(object);\n\tif (restitution != null) {\n\t\tcolliderDesc.setRestitution(restitution);\n\t}\n\tif (friction != null) {\n\t\tcolliderDesc.setFriction(friction);\n\t}\n\tif (density != null) {\n\t\tcolliderDesc.setDensity(density);\n\t}\n\treturn colliderDesc;\n}\nexport function _getRBDFromId(rbdId: string): Object3D | undefined {\n\tconst rigidBody = getRBDFromId(rbdId);\n\tif (!rigidBody) {\n\t\treturn;\n\t}\n\treturn object3DFromRBD(rigidBody);\n}\nexport function _getRBDFromObject(object: Object3D) {\n\tconst handle = CorePhysicsAttribute.getRBDHandle(object);\n\tif (handle == null) {\n\t\treturn;\n\t}\n\treturn physicsRBDByRBDHandle.get(handle);\n}\nexport function _getPhysicsWorldFromRBD(object: Object3D) {\n\tconst rbd = _getRBDFromObject(object);\n\tif (!rbd) {\n\t\treturn;\n\t}\n\treturn worldByRBD.get(rbd);\n}\n\nexport function _physicsRBDDelete(scene: PolyScene, object: Object3D) {\n\tconst handle = CorePhysicsAttribute.getRBDHandle(object);\n\tif (handle == null) {\n\t\treturn;\n\t}\n\tconst body = physicsRBDByRBDHandle.get(handle);\n\tif (!body) {\n\t\treturn;\n\t}\n\tconst world = worldByRBD.get(body);\n\tif (!world) {\n\t\treturn;\n\t}\n\tworld.removeRigidBody(body);\n\tworldByRBD.delete(body);\n\tphysicsRBDByRBDHandle.delete(handle);\n\tCorePhysicsAttribute.deleteRBDHandle(object);\n\tremoveFromParent(scene, object);\n}\n\ninterface PhysicsCreateRBDOptions {\n\tPhysicsLib: PhysicsLib;\n\tworld: World;\n\tobject: Object3D;\n\trigidBodyById: Map<string, RigidBody>;\n\tobjectsByRBD: WeakMap<RigidBody, Object3D>;\n\tnewRBDIds: Set<string>;\n}\nexport function _physicsCreateRBD(options: PhysicsCreateRBDOptions) {\n\tconst {PhysicsLib, world, object, rigidBodyById, objectsByRBD, newRBDIds} = options;\n\tconst rigidBody = _createRBDFromAttributes({\n\t\tPhysicsLib,\n\t\tworld,\n\t\tobject,\n\t\trigidBodyById,\n\t\tobjectsByRBD,\n\t\tnewRBDIds,\n\t});\n\tif (!rigidBody) {\n\t\t// if not rbd created, we go through the children\n\t\tfor (const child of object.children) {\n\t\t\t_physicsCreateRBD({PhysicsLib, world, rigidBodyById, objectsByRBD, object: child, newRBDIds});\n\t\t}\n\n\t\treturn;\n\t}\n\n\tlet childrenColliderDesc: CollidescObjectPair[] | undefined;\n\tif (object.children.length > 0) {\n\t\tobject.traverse((child) => {\n\t\t\tif (child != object) {\n\t\t\t\tconst childColliderDesc = _createColliderDesc(PhysicsLib, child);\n\t\t\t\tif (childColliderDesc) {\n\t\t\t\t\tchildrenColliderDesc = childrenColliderDesc || [];\n\t\t\t\t\tchildrenColliderDesc.push({object: child, colliderDesc: childColliderDesc});\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t}\n\n\tconst colliderDesc = _createColliderDesc(PhysicsLib, object);\n\tif (!(colliderDesc || childrenColliderDesc)) {\n\t\treturn;\n\t}\n\tif (colliderDesc) {\n\t\tworld.createCollider(colliderDesc, rigidBody);\n\t}\n\tif (childrenColliderDesc) {\n\t\t// we must not alterate the hierarchy here,\n\t\t// as it messes up with orders of children\n\t\t// let currentParent = object.parent;\n\t\t// currentParent?.remove(object);\n\t\t// object.getWorldQuaternion(q1);\n\t\tfor (const childCollider of childrenColliderDesc) {\n\t\t\tconst collider = world.createCollider(childCollider.colliderDesc, rigidBody);\n\n\t\t\t// t\n\t\t\ttmpV3.copy(childCollider.object.position);\n\t\t\tchildCollider.object.localToWorld(tmpV3);\n\t\t\tobject.worldToLocal(tmpV3);\n\t\t\tcollider.setTranslationWrtParent(tmpV3);\n\n\t\t\t// r\n\t\t\t// TODO: here we are only getting the quaternion of the object,\n\t\t\t// not its quaternion relative to the parent.\n\t\t\t// It works if it is a direct child, but will fail with a deeper hierarchy\n\t\t\t// let currentChildParent = childCollider.object.parent;\n\t\t\t// object.attach(childCollider.object);\n\t\t\t// object.matrix.decompose(t, q, s);\n\t\t\t// it seems that computing .getWorldQuaternion\n\t\t\t// messes up with .quaternion\n\t\t\t// object.getWorldQuaternion(q1);\n\t\t\t// childCollider.object.getWorldQuaternion(q2);\n\t\t\t// q1.invert().multiply(q2);\n\t\t\t// q2.multiply(q1.invert());\n\t\t\tcollider.setRotationWrtParent(childCollider.object.quaternion);\n\t\t\t// currentChildParent?.attach(childCollider.object);\n\t\t}\n\t\t// currentParent?.add(object);\n\t}\n}\n\nexport function physicsUpdateRBD(object: Object3D, rigidBody: RigidBody) {\n\t// physicsRBDSetInitMatrix(object);\n\tconst position = rigidBody.translation();\n\tconst rotation = rigidBody.rotation();\n\tobject.position.set(position.x, position.y, position.z);\n\tobject.quaternion.set(rotation.x, rotation.y, rotation.z, rotation.w);\n\tobject.updateMatrix();\n\tupdateRBDRefs(object);\n}\nconst SIM_PROPERTIES = [\n\tRBDProperty.ANGULAR_VELOCITY,\n\tRBDProperty.LINEAR_VELOCITY,\n\tRBDProperty.POSITION,\n\tRBDProperty.ROTATION,\n\tRBDProperty.IS_SLEEPING,\n\tRBDProperty.IS_MOVING,\n];\nfunction updateRBDRefs(object: Object3D) {\n\ttouchRBDProperties(object, SIM_PROPERTIES);\n\ttouchObjectProperties(object, OBJECT_TRANSFORM_PROPERTIES);\n}\n\n// impulse\nexport function _physicsRBDApplyImpulse(object: Object3D, impulse: Vector3) {\n\tconst body = _getRBDFromObject(object);\n\tif (!body) {\n\t\tconsole.warn('no rbd found');\n\t\treturn;\n\t}\n\tbody.applyImpulse(impulse, true);\n}\nexport function _physicsRBDApplyImpulseAtPoint(object: Object3D, impulse: Vector3, point: Vector3) {\n\tconst body = _getRBDFromObject(object);\n\tif (!body) {\n\t\tconsole.warn('no rbd found');\n\t\treturn;\n\t}\n\tbody.applyImpulseAtPoint(impulse, point, true);\n}\nexport function _physicsRBDApplyTorqueImpulse(object: Object3D, impulse: Vector3) {\n\tconst body = _getRBDFromObject(object);\n\tif (!body) {\n\t\tconsole.warn('no rbd found');\n\t\treturn;\n\t}\n\tbody.applyTorqueImpulse(impulse, true);\n}\n// add\nexport function _physicsRBDAddForce(object: Object3D, force: Vector3) {\n\tconst body = _getRBDFromObject(object);\n\tif (!body) {\n\t\tconsole.warn('no rbd found');\n\t\treturn;\n\t}\n\tbody.addForce(force, true);\n}\nexport function _physicsRBDAddForceAtPoint(object: Object3D, force: Vector3, point: Vector3) {\n\tconst body = _getRBDFromObject(object);\n\tif (!body) {\n\t\tconsole.warn('no rbd found');\n\t\treturn;\n\t}\n\tbody.addForceAtPoint(force, point, true);\n}\nexport function _physicsRBDAddTorque(object: Object3D, torque: Vector3) {\n\tconst body = _getRBDFromObject(object);\n\tif (!body) {\n\t\tconsole.warn('no rbd found');\n\t\treturn;\n\t}\n\tbody.addTorque(torque, true);\n}\n// reset\nexport function _physicsRBDResetAll(object: Object3D, wakeup: boolean) {\n\tconst body = _getRBDFromObject(object);\n\tif (!body) {\n\t\tconsole.warn('no rbd found');\n\t\treturn;\n\t}\n\tbody.resetForces(wakeup);\n\tbody.resetTorques(wakeup);\n\tbody.setLinvel({x: 0, y: 0, z: 0}, wakeup);\n\tbody.setAngvel({x: 0, y: 0, z: 0}, wakeup);\n}\nexport function _physicsRBDResetForces(object: Object3D, wakeup: boolean) {\n\tconst body = _getRBDFromObject(object);\n\tif (!body) {\n\t\tconsole.warn('no rbd found');\n\t\treturn;\n\t}\n\tbody.resetForces(wakeup);\n}\nexport function _physicsRBDResetTorques(object: Object3D, wakeup: boolean) {\n\tconst body = _getRBDFromObject(object);\n\tif (!body) {\n\t\tconsole.warn('no rbd found');\n\t\treturn;\n\t}\n\tbody.resetTorques(wakeup);\n}\n\nexport function _setPhysicsRBDPosition(object: Object3D, targetPosition: Vector3, lerp: number) {\n\tconst body = _getRBDFromObject(object);\n\tif (!body) {\n\t\tconsole.warn('no rbd found');\n\t\treturn;\n\t}\n\tconst translateFunc = body.isKinematic()\n\t\t? body.setNextKinematicTranslation.bind(body)\n\t\t: body.setTranslation.bind(body);\n\n\tif (lerp < 1) {\n\t\tconst rbdPosition = body.translation();\n\t\tcurrentPos.set(rbdPosition.x, rbdPosition.y, rbdPosition.z);\n\t\tnewPos.copy(targetPosition);\n\t\tcurrentPos.lerp(newPos, lerp);\n\t\ttranslateFunc(currentPos, true);\n\t} else {\n\t\ttranslateFunc(targetPosition, true);\n\t}\n\ttouchRBDProperty(object, RBDProperty.POSITION);\n}\nexport function _setPhysicsRBDRotation(object: Object3D, targetQuaternion: Quaternion, lerp: number) {\n\tconst body = _getRBDFromObject(object);\n\tif (!body) {\n\t\tconsole.warn('no rbd found');\n\t\treturn;\n\t}\n\tconst rotateFunc = body.isKinematic() ? body.setNextKinematicRotation.bind(body) : body.setRotation.bind(body);\n\tif (lerp < 1) {\n\t\tconst rbdRotation = body.rotation();\n\t\tcurrentQuaternion.set(rbdRotation.x, rbdRotation.y, rbdRotation.z, rbdRotation.w);\n\t\tnewQuaternion.copy(currentQuaternion);\n\t\tcurrentQuaternion.slerp(newQuaternion, lerp);\n\t\trotateFunc(currentQuaternion, true);\n\t} else {\n\t\trotateFunc(targetQuaternion, true);\n\t}\n\ttouchRBDProperty(object, RBDProperty.ROTATION);\n}\nexport function _setPhysicsRBDLinearVelocity(object: Object3D, targetVelocity: Vector3, lerp: number) {\n\tconst body = _getRBDFromObject(object);\n\tif (!body) {\n\t\tconsole.warn('no rbd found');\n\t\treturn;\n\t}\n\n\tif (lerp < 1) {\n\t\tconst rbdLinearVelocity = body.linvel();\n\t\tcurrentLinearVelocity.set(rbdLinearVelocity.x, rbdLinearVelocity.y, rbdLinearVelocity.z);\n\t\tnewLinearVelocity.copy(targetVelocity);\n\t\tcurrentLinearVelocity.lerp(newPos, lerp);\n\t\tbody.setLinvel(currentLinearVelocity, true);\n\t} else {\n\t\tbody.setLinvel(targetVelocity, true);\n\t}\n\ttouchRBDProperty(object, RBDProperty.LINEAR_VELOCITY);\n}\nexport function _setPhysicsRBDAngularVelocity(object: Object3D, targetVelocity: Vector3, lerp: number) {\n\tconst body = _getRBDFromObject(object);\n\tif (!body) {\n\t\tconsole.warn('no rbd found');\n\t\treturn;\n\t}\n\n\tif (lerp < 1) {\n\t\tconst rbdAngularVelocity = body.angvel();\n\t\tcurrentAngularVelocity.set(rbdAngularVelocity.x, rbdAngularVelocity.y, rbdAngularVelocity.z);\n\t\tnewAngularVelocity.copy(targetVelocity);\n\t\tcurrentAngularVelocity.lerp(newPos, lerp);\n\t\tbody.setAngvel(currentAngularVelocity, true);\n\t} else {\n\t\tbody.setAngvel(targetVelocity, true);\n\t}\n\ttouchRBDProperty(object, RBDProperty.ANGULAR_VELOCITY);\n}\n\nfunction PhysicsRBDTypeToRigidBodyType(type: PhysicsRBDType) {\n\tconst RigidBodyType = CorePhysicsLoaded()?.RigidBodyType;\n\tif (!RigidBodyType) {\n\t\treturn;\n\t}\n\tswitch (type) {\n\t\tcase PhysicsRBDType.FIXED: {\n\t\t\treturn RigidBodyType.Fixed;\n\t\t}\n\t\tcase PhysicsRBDType.DYNAMIC: {\n\t\t\treturn RigidBodyType.Dynamic;\n\t\t}\n\t\tcase PhysicsRBDType.KINEMATIC_POS: {\n\t\t\treturn RigidBodyType.KinematicPositionBased;\n\t\t}\n\t\tcase PhysicsRBDType.KINEMATIC_VEL: {\n\t\t\treturn RigidBodyType.KinematicVelocityBased;\n\t\t}\n\t}\n\tTypeAssert.unreachable(type);\n}\n\nfunction PhysicsRBDCollider(\n\tPhysicsLib: PhysicsLib,\n\tcolliderType: PhysicsRBDColliderType,\n\tobject: Object3D\n): ColliderDesc | null | undefined {\n\tswitch (colliderType) {\n\t\tcase PhysicsRBDColliderType.CAPSULE: {\n\t\t\treturn createPhysicsCapsule(PhysicsLib, object);\n\t\t}\n\t\tcase PhysicsRBDColliderType.CUBOID: {\n\t\t\treturn createPhysicsCuboid(PhysicsLib, object);\n\t\t}\n\t\tcase PhysicsRBDColliderType.CONE: {\n\t\t\treturn createPhysicsCone(PhysicsLib, object);\n\t\t}\n\t\tcase PhysicsRBDColliderType.CONVEX_HULL: {\n\t\t\treturn createPhysicsConvexHull(PhysicsLib, object);\n\t\t}\n\t\tcase PhysicsRBDColliderType.TRIMESH: {\n\t\t\treturn createPhysicsTriMesh(PhysicsLib, object);\n\t\t}\n\t\tcase PhysicsRBDColliderType.CYLINDER: {\n\t\t\treturn createPhysicsCylinder(PhysicsLib, object);\n\t\t}\n\t\tcase PhysicsRBDColliderType.SPHERE: {\n\t\t\treturn createPhysicsSphere(PhysicsLib, object);\n\t\t}\n\t\tcase PhysicsRBDColliderType.HEIGHT_FIELD: {\n\t\t\treturn createPhysicsHeightField(PhysicsLib, object);\n\t\t}\n\t}\n\tTypeAssert.unreachable(colliderType);\n}\n","import {PhysicsLib, CorePhysics, CorePhysicsLoaded} from './CorePhysics';\nimport {World, RigidBody, Collider, ImpulseJoint, MultibodyJoint} from '@dimforge/rapier3d-compat';\nimport {Object3D, Vector3} from 'three';\nimport {_physicsCreateRBD, physicsUpdateRBD} from './PhysicsRBD';\nimport {physicsCreateJoints} from './PhysicsJoint';\nimport {CoreGraphNodeId} from '../graph/CoreGraph';\nimport {BaseNodeType} from '../../engine/nodes/_Base';\nimport {PhysicsIdAttribute} from './PhysicsAttribute';\nimport {clearPhysicsPlayers, createOrFindPhysicsPlayer} from './player/PhysicsPlayer';\nimport {PolyScene} from '../../engine/scene/PolyScene';\nimport {coreObjectClassFactory} from '../geometry/CoreObjectFactory';\n\nexport const PHYSICS_GRAVITY_DEFAULT = new Vector3(0, -9.81, 0);\n\nconst physicsworldByGraphNodeId: Map<CoreGraphNodeId, World> = new Map();\n// const objectsByRBDByWorld: Object3DByRigidBodyByWorld = new Map();\nconst objectsByRBD: WeakMap<RigidBody, Object3D> = new WeakMap();\nconst rigidBodyById: Map<string, RigidBody> = new Map();\n//\nexport async function createOrFindPhysicsWorld(node: BaseNodeType, worldObject: Object3D, gravity: Vector3) {\n\tconst nodeId = node.graphNodeId();\n\tconst PhysicsLib = await CorePhysics();\n\tlet world = physicsworldByGraphNodeId.get(nodeId);\n\tif (!world) {\n\t\tworld = new PhysicsLib.World(gravity);\n\t\tphysicsworldByGraphNodeId.set(nodeId, world);\n\t}\n\n\treturn {world, PhysicsLib};\n}\nexport function physicsWorldNodeIdFromObject(worldObject: Object3D) {\n\tconst nodeId = coreObjectClassFactory(worldObject).attribValue(worldObject, PhysicsIdAttribute.WORLD) as\n\t\t| CoreGraphNodeId\n\t\t| undefined;\n\treturn nodeId;\n}\n\nexport function physicsWorldFromObject(worldObject: Object3D) {\n\tconst nodeId = coreObjectClassFactory(worldObject).attribValue(worldObject, PhysicsIdAttribute.WORLD) as\n\t\t| CoreGraphNodeId\n\t\t| undefined;\n\tif (nodeId == null) {\n\t\treturn;\n\t}\n\treturn physicsworldByGraphNodeId.get(nodeId);\n}\nexport function physicsWorldFromNodeId(nodeId: CoreGraphNodeId) {\n\treturn physicsworldByGraphNodeId.get(nodeId);\n}\n\nexport function initCorePhysicsWorld(PhysicsLib: PhysicsLib, worldObject: Object3D, scene: PolyScene) {\n\tconst world = physicsWorldFromObject(worldObject);\n\tif (!world) {\n\t\tconsole.warn('no physicsWorld found with this object', worldObject);\n\t\treturn;\n\t}\n\t_clearWorld(world);\n\t// const objectsByRigidBody = _objectByRBDWorld(world);\n\n\t// create RBDs\n\n\t// we keep a copy of the children here,\n\t// as they are removed/added inside physicsCreateRBD\n\t// in order to compute relative transform\n\t// (even though there surely are ways to avoid this remove/add)\n\t// We also need to keep a copy as when traversing to create the joints,\n\t// we end up removing them from the hierarchy\n\tconst children = [...worldObject.children];\n\tconst newRBDIds = new Set<string>();\n\tfor (const child of children) {\n\t\t_physicsCreateRBD({PhysicsLib, world, rigidBodyById, objectsByRBD, object: child, newRBDIds});\n\t}\n\n\t// create joints\n\t// for (let child of children) {\n\tphysicsCreateJoints(PhysicsLib, world, worldObject);\n\t// }\n\t// create character controller\n\tfor (const child of children) {\n\t\tcreateOrFindPhysicsPlayer({scene, object: child, PhysicsLib, world, worldObject});\n\t}\n}\n// function _objectByRBDWorld(world: World) {\n// \tlet objectsByRigidBody = objectsByRBDByWorld.get(world);\n// \tif (!objectsByRigidBody) {\n// \t\tobjectsByRigidBody = new WeakMap();\n// \t\tobjectsByRBDByWorld.set(world, objectsByRigidBody);\n// \t}\n// \treturn objectsByRigidBody;\n// }\n// export function object3DByRBDByWorld(worldObject: Object3D, rbd: RigidBody) {\n// \tconst objectsByRigidBody = _objectByRBDWorld(physicsWorldFromObject(worldObject) as World);\n// \treturn objectsByRigidBody.get(rbd);\n// }\nexport function object3DFromRBD(rbd: RigidBody) {\n\treturn objectsByRBD.get(rbd);\n}\nexport function physicsCreateRBDFromWorldObject(worldObject: Object3D, object: Object3D) {\n\tconst world = physicsWorldFromObject(worldObject);\n\tif (!world) {\n\t\tconsole.warn('no physicsWorld found with this object', worldObject);\n\t\treturn;\n\t}\n\treturn physicsCreateRBDFromWorld(world, object);\n}\nexport function physicsCreateRBDFromWorld(world: World, object: Object3D) {\n\tconst PhysicsLib = CorePhysicsLoaded();\n\tif (!PhysicsLib) {\n\t\treturn;\n\t}\n\t// const objectsByRigidBody = _objectByRBDWorld(world);\n\tconst newRBDIds = new Set<string>();\n\t_physicsCreateRBD({PhysicsLib, world, rigidBodyById, objectsByRBD, object, newRBDIds});\n\treturn newRBDIds;\n}\n\nexport function getRBDFromId(rbdId: string) {\n\treturn rigidBodyById.get(rbdId);\n}\n\nfunction _clearWorld(world: World) {\n\tconst bodies: RigidBody[] = [];\n\tconst colliders: Collider[] = [];\n\tconst joints: ImpulseJoint[] = [];\n\tconst multiBodyJoints: MultibodyJoint[] = [];\n\tworld.bodies.forEach((body) => {\n\t\tbodies.push(body);\n\t});\n\tworld.colliders.forEach((collider) => {\n\t\tcolliders.push(collider);\n\t});\n\tworld.impulseJoints.forEach((joint) => {\n\t\tjoints.push(joint);\n\t});\n\tworld.multibodyJoints.forEach((multiBodyJoint) => {\n\t\tmultiBodyJoints.push(multiBodyJoint);\n\t});\n\tfor (const body of bodies) {\n\t\tworld.removeRigidBody(body);\n\t}\n\tfor (const collider of colliders) {\n\t\tworld.removeCollider(collider, false);\n\t}\n\tfor (const joint of joints) {\n\t\tworld.removeImpulseJoint(joint, false);\n\t}\n\tfor (const joint of multiBodyJoints) {\n\t\tworld.removeMultibodyJoint(joint, false);\n\t}\n\n\tclearPhysicsPlayers();\n}\n\nexport function stepWorld(worldObject: Object3D) {\n\tconst world = physicsWorldFromObject(worldObject);\n\tif (!world) {\n\t\t// if it is not the world, maybe it is the debug object\n\t\t// const pair = physicsDebugPairFromDebugObject(worldObject);\n\t\t// if (!pair) {\n\t\t// \treturn;\n\t\t// }\n\t\t// updatePhysicsDebugObject(worldObject);\n\t\treturn;\n\t}\n\tworld.step();\n\n\t// const objectsByRigidBody = objectsByRBDByWorld.get(world);\n\t// if (objectsByRigidBody) {\n\tworld.bodies.forEach((body) => {\n\t\tconst object = objectsByRBD.get(body);\n\t\tif (object) {\n\t\t\tphysicsUpdateRBD(object, body);\n\t\t}\n\t});\n\t// }\n}\n\nconst currentGravity = new Vector3();\nconst newGravity = new Vector3();\nexport function setWorldGravity(worldObject: Object3D, gravity: Vector3, lerp: number) {\n\tconst world = physicsWorldFromObject(worldObject);\n\tif (!world) {\n\t\treturn;\n\t}\n\tif (lerp < 1) {\n\t\tcurrentGravity.set(world.gravity.x, world.gravity.y, world.gravity.z);\n\t\tnewGravity.copy(gravity);\n\t\tcurrentGravity.lerp(newGravity, lerp);\n\t}\n\tworld.gravity.x = gravity.x;\n\tworld.gravity.y = gravity.y;\n\tworld.gravity.z = gravity.z;\n}\n","import type {World} from '@dimforge/rapier3d-compat';\nimport {Object3D, Vector3} from 'three';\nimport {CorePhysicsAttribute} from '../PhysicsAttribute';\nconst up = new Vector3();\nexport function createCharacterController(world: World, object: Object3D) {\n\tconst offset = CorePhysicsAttribute.getCharacterControllerOffset(object);\n\n\tconst snapToGroundDistance = CorePhysicsAttribute.getCharacterControllerSnapToGroundDistance(object);\n\tconst applyImpulsesToDynamic = CorePhysicsAttribute.getCharacterControllerApplyImpulsesToDynamic(object);\n\t// autostep\n\tconst autoStepMaxHeight = CorePhysicsAttribute.getCharacterControllerAutoStepMaxHeight(object);\n\tconst autoStepMinWidth = CorePhysicsAttribute.getCharacterControllerAutoStepMinWidth(object);\n\tconst autoStepOnDynamic = CorePhysicsAttribute.getCharacterControllerAutoStepOnDynamic(object);\n\t// slopes\n\tCorePhysicsAttribute.getCharacterControllerUp(object, up);\n\tconst maxSlopeClimbAngle = CorePhysicsAttribute.getCharacterControllerMaxSlopeClimbAngle(object);\n\tconst minSlopeSlideAngle = CorePhysicsAttribute.getCharacterControllerMinSlopeSlideAngle(object);\n\tconst characterController = world.createCharacterController(offset);\n\tconsole.log(offset, characterController);\n\n\t// use attributes\n\tconsole.log({\n\t\toffset,\n\t\tup,\n\t\tapplyImpulsesToDynamic,\n\t\tsnapToGroundDistance,\n\t\tautoStepMaxHeight,\n\t\tautoStepMinWidth,\n\t\tautoStepOnDynamic,\n\t\tmaxSlopeClimbAngle,\n\t\tminSlopeSlideAngle,\n\t});\n\tcharacterController.setUp(up);\n\tcharacterController.setApplyImpulsesToDynamicBodies(applyImpulsesToDynamic);\n\tif (snapToGroundDistance) {\n\t\tcharacterController.enableSnapToGround(snapToGroundDistance);\n\t} else {\n\t\tcharacterController.disableSnapToGround();\n\t}\n\t// auto step\n\tif (autoStepMaxHeight && autoStepMinWidth) {\n\t\tcharacterController.enableAutostep(autoStepMaxHeight, autoStepMinWidth, autoStepOnDynamic);\n\t} else {\n\t\tcharacterController.disableAutostep();\n\t}\n\t// slopes\n\tcharacterController.setMaxSlopeClimbAngle((maxSlopeClimbAngle * Math.PI) / 180);\n\tcharacterController.setMinSlopeSlideAngle((minSlopeSlideAngle * Math.PI) / 180);\n\treturn characterController;\n}\n","import type {World, RigidBody, Collider, KinematicCharacterController} from '@dimforge/rapier3d-compat';\nimport {PhysicsLib} from '../CorePhysics';\nimport {Object3D, Vector3} from 'three';\nimport {PhysicsPlayerType} from './PhysicsPlayer';\nimport {createCharacterController} from './CharacterController';\nimport {_physicsRBDResetAll} from '../PhysicsRBD';\nimport {CorePhysicsAttribute} from '../PhysicsAttribute';\nimport {CorePath} from '../../geometry/CorePath';\nimport {CoreCameraControlsController, ApplicableControlsNode} from '../../camera/CoreCameraControlsController';\nimport {PolyScene} from '../../../engine/scene/PolyScene';\nimport {Camera} from 'three';\nimport {CorePlayerInput} from '../../player/PlayerCommon';\n\ntype BooleanGetter = () => boolean;\n// type SetInputData = (inputData: CorePlayerPhysicsInputData) => void;\ntype UpdateFunc = (\n\tcomputeData: CorePlayerPhysicsComputeInputData,\n\tinputData: CorePlayerPhysicsInputData,\n\tdelta: number\n) => void;\n\n// export enum CorePlayerPhysicsInput {\n// \tLEFT = 'left',\n// \tRIGHT = 'right',\n// \tBACKWARD = 'backward',\n// \tFORWARD = 'forward',\n// \tRUN = 'run',\n// \tJUMP = 'jump',\n// }\n// export const CORE_PLAYER_PHYSICS_INPUTS: CorePlayerPhysicsInput[] = [\n// \tCorePlayerPhysicsInput.LEFT,\n// \tCorePlayerPhysicsInput.RIGHT,\n// \tCorePlayerPhysicsInput.BACKWARD,\n// \tCorePlayerPhysicsInput.FORWARD,\n// \tCorePlayerPhysicsInput.RUN,\n// \tCorePlayerPhysicsInput.JUMP,\n// ];\nexport type CorePlayerPhysicsInputData = Record<CorePlayerInput, boolean>;\n\nexport interface CorePlayerPhysicsComputeInputData {\n\tspeed: number;\n\trunAllowed: boolean;\n\trunSpeedMult: number;\n\tjumpAllowed: boolean;\n\tjumpStrength: number;\n\tresetIfBelowThreshold: boolean;\n\tresetThreshold: number;\n}\n\ninterface CorePlayerPhysicsOptions {\n\tscene: PolyScene;\n\tobject: Object3D;\n\tPhysicsLib: PhysicsLib;\n\tworld: World;\n\tworldObject: Object3D;\n\tbody: RigidBody;\n\tcollider: Collider;\n\ttype: PhysicsPlayerType;\n}\ninterface CameraAndControls {\n\tcamera: Camera;\n\tcontrolsNode: ApplicableControlsNode;\n}\n\n// const gravity = new Vector3();\n// const forcesByDelta = new Vector3();\n// const desiredTranslation = new Vector3();\n// const correctedTranslation = new Vector3();\nconst torqueLR = new Vector3();\nconst torqueFB = new Vector3();\nconst up = new Vector3(0, 1, 0);\n// we need a default forwardDir,\n// in case we never give a camera to the player.\n// otherwise if it is 0,0,0, the player would never move\nconst DEFAULT_FORWARD_DIR = new Vector3(0, 0, -1);\nconst forwardDir = new Vector3().copy(DEFAULT_FORWARD_DIR);\nconst currentTarget = new Vector3();\nconst delta = new Vector3();\nconst newCameraPosition = new Vector3();\nconst newTarget = new Vector3();\nconst LERP = 0.2;\nexport class CorePlayerPhysics {\n\t// private _inputData: CorePlayerPhysicsInputData = {\n\t// \tforward: false,\n\t// \tbackward: false,\n\t// \tleft: false,\n\t// \tright: false,\n\t// \trun: false,\n\t// \tjump: false,\n\t// };\n\t// private _computeInputData: CorePlayerPhysicsComputeInputData = {\n\t// \tspeed: 1,\n\t// \trunAllowed: true,\n\t// \trunSpeedMult: 2,\n\t// \tjumpAllowed: true,\n\t// \tjumpStrength: 1,\n\t// \tresetIfBelowThreshold: true,\n\t// \tresetThreshold: -5,\n\t// };\n\t// private _mass = 1;\n\tprivate _userTorques = new Vector3(0, 0, 0);\n\tprivate _userImpulses = new Vector3(0, 0, 0);\n\t// private _userForces = new Vector3(0, 0, 0);\n\t// private _velocity = new Vector3(0, 0, 0);\n\tprivate _correctedMovement = new Vector3(0, 0, 0);\n\t// private _computedData: PlayerComputedData = {\n\t// \tvelocityFromForces: new Vector3(0, 0, 0),\n\t// \tonGround: false,\n\t// \tvelocityFromPositionDelta: new Vector3(0, 0, 0),\n\t// };\n\tprotected object: Object3D;\n\t// protected worldObject: Object3D;\n\tprotected PhysicsLib: PhysicsLib;\n\tprotected world: World;\n\tprotected body: RigidBody;\n\tprotected collider: Collider;\n\t// protected type: PhysicsPlayerType\n\tprotected characterController: KinematicCharacterController | undefined;\n\tprotected startPosition: Vector3 = new Vector3();\n\tpublic onGround: BooleanGetter;\n\t// public setInputData: SetInputData;\n\tpublic update: UpdateFunc;\n\tprivate cameraAndControls: CameraAndControls | undefined;\n\tconstructor(protected options: CorePlayerPhysicsOptions) {\n\t\tthis.object = options.object;\n\t\tthis.PhysicsLib = options.PhysicsLib;\n\t\tthis.world = options.world;\n\t\tthis.body = options.body;\n\t\tthis.collider = options.collider;\n\n\t\tthis.startPosition.copy(this.object.position);\n\t\tif (options.type == PhysicsPlayerType.CHARACTER_CONTROLLER) {\n\t\t\tthis.characterController = createCharacterController(this.world, this.object);\n\t\t\tthis.onGround = this.onGroundWithCharacterController;\n\t\t\t// this.setInputData = this.setInputDataWithCharacterController;\n\t\t\tthis.update = this.updateWithCharacterController;\n\t\t} else {\n\t\t\tthis.onGround = this.onGroundWithTorque;\n\t\t\t// this.setInputData = this.setInputDataWithTorque;\n\t\t\tthis.update = this.updateWithTorque;\n\t\t\tthis.initWithTorque(options.worldObject, options.scene);\n\t\t}\n\t}\n\n\tdispose() {\n\t\tif (this.characterController) {\n\t\t\tthis.world.removeCharacterController(this.characterController);\n\t\t}\n\t}\n\n\t// setComputeInputData(data: CorePlayerPhysicsComputeInputData) {\n\t// \tthis._computeInputData.speed = data.speed;\n\t// \tthis._computeInputData.runAllowed = data.runAllowed;\n\t// \tthis._computeInputData.runSpeedMult = data.runSpeedMult;\n\t// \tthis._computeInputData.jumpAllowed = data.jumpAllowed;\n\t// \tthis._computeInputData.jumpStrength = data.jumpStrength;\n\t// }\n\tprivate _computeForwardDirAndUpdateCamera() {\n\t\tif (!this.cameraAndControls) {\n\t\t\tforwardDir.copy(DEFAULT_FORWARD_DIR);\n\t\t\treturn;\n\t\t}\n\t\tconst {camera, controlsNode} = this.cameraAndControls;\n\t\tforwardDir.set(0, 0, -1).unproject(camera).sub(camera.position);\n\t\tforwardDir.y = 0;\n\t\tforwardDir.normalize();\n\n\t\tif (controlsNode.target && controlsNode.setTarget) {\n\t\t\tcontrolsNode.target(currentTarget);\n\t\t\tdelta.copy(this.object.position).sub(currentTarget);\n\t\t\tnewCameraPosition.copy(camera.position).add(delta);\n\t\t\tcamera.position.lerp(newCameraPosition, LERP);\n\t\t\tnewTarget.copy(currentTarget).lerp(this.object.position, LERP);\n\t\t\tcontrolsNode.setTarget(newTarget);\n\t\t}\n\t}\n\n\t/**\n\t *\n\t * torque\n\t *\n\t */\n\tinitWithTorque(worldObject: Object3D, scene: PolyScene) {\n\t\tconst cameraPath = CorePhysicsAttribute.getCharacterControllerCameraPath(this.object);\n\t\tif (cameraPath == null) {\n\t\t\treturn;\n\t\t}\n\t\tconst camera = CorePath.findObjectByMaskInObject(`*/${cameraPath}`, worldObject) as Camera;\n\t\tif (!camera) {\n\t\t\treturn;\n\t\t}\n\t\tconst controlsNode = CoreCameraControlsController.controlsNode({camera, scene});\n\t\tif (!controlsNode) {\n\t\t\treturn;\n\t\t}\n\t\tthis.cameraAndControls = {camera, controlsNode};\n\t}\n\tonGroundWithTorque(): boolean {\n\t\treturn Math.abs(this.body.linvel().y) < 0.1;\n\t}\n\t// setInputDataWithTorque(inputData: CorePlayerPhysicsInputData) {\n\t// \tthis._computeForwardDirAndUpdateCamera();\n\t// \t// this._inputData.left = inputData.left;\n\t// \t// this._inputData.right = inputData.right;\n\t// \t// this._inputData.backward = inputData.backward;\n\t// \t// this._inputData.forward = inputData.forward;\n\n\t// }\n\n\tupdateWithTorque(\n\t\tcomputeInputData: CorePlayerPhysicsComputeInputData,\n\t\tinputData: CorePlayerPhysicsInputData,\n\t\tdelta: number\n\t) {\n\t\tthis._computeForwardDirAndUpdateCamera();\n\n\t\t// reset forces\n\t\tthis._userTorques.set(0, 0, 0);\n\t\tthis._userImpulses.set(0, 0, 0);\n\n\t\tconst running = computeInputData.runAllowed && inputData.run;\n\t\t// jump\n\t\tif (computeInputData.jumpAllowed && inputData.jump && this.onGround()) {\n\t\t\tthis._userImpulses.y += computeInputData.jumpStrength * 100;\n\t\t}\n\n\t\t// torques\n\t\tconst speed = running ? computeInputData.speed * computeInputData.runSpeedMult : computeInputData.speed;\n\t\tif (inputData.left && !inputData.right) {\n\t\t\ttorqueLR.copy(forwardDir).multiplyScalar(-speed);\n\t\t\tthis._userTorques.add(torqueLR);\n\t\t} else {\n\t\t\tif (inputData.right && !inputData.left) {\n\t\t\t\ttorqueLR.copy(forwardDir).multiplyScalar(speed);\n\t\t\t\tthis._userTorques.add(torqueLR);\n\t\t\t}\n\t\t}\n\t\tif (inputData.forward && !inputData.backward) {\n\t\t\ttorqueFB.copy(forwardDir).cross(up).normalize().multiplyScalar(-speed);\n\t\t\tthis._userTorques.add(torqueFB);\n\t\t} else {\n\t\t\tif (inputData.backward && !inputData.forward) {\n\t\t\t\ttorqueFB.copy(forwardDir).cross(up).normalize().multiplyScalar(speed);\n\t\t\t\tthis._userTorques.add(torqueFB);\n\t\t\t}\n\t\t}\n\n\t\t// reset if below threshold\n\t\tif (computeInputData.resetIfBelowThreshold) {\n\t\t\tif (this.body.translation().y < computeInputData.resetThreshold) {\n\t\t\t\t_physicsRBDResetAll(this.object, true);\n\t\t\t\tthis.body.setTranslation(this.startPosition, true);\n\t\t\t}\n\t\t}\n\n\t\t//\n\t\t// update RBD\n\t\t//\n\t\tthis.body.applyTorqueImpulse(this._userTorques, true);\n\t\tthis.body.applyImpulse(this._userImpulses, true);\n\t}\n\t/**\n\t *\n\t * character controller\n\t *\n\t */\n\tonGroundWithCharacterController() {\n\t\treturn Math.abs(this._correctedMovement.y) < 0.01;\n\t}\n\n\tsetInputDataWithCharacterController(inputData: CorePlayerPhysicsInputData) {\n\t\t// this._inputData.left = inputData.left;\n\t\t// this._inputData.right = inputData.right;\n\t\t// this._inputData.backward = inputData.backward;\n\t\t// this._inputData.forward = inputData.forward;\n\t\t// this._userForces.set(0, 0, 0);\n\t\t// const damping = 0.95;\n\t\t// if (this._computeInputData.runAllowed && inputData.run) {\n\t\t// \tthis._inputData.run = true;\n\t\t// } else {\n\t\t// \tthis._inputData.run = false;\n\t\t// }\n\t\t// // console.log(this._computeInputData.jumpAllowed, inputData.jump, this.onGround(), this._correctedMovement.y);\n\t\t// if (this._computeInputData.jumpAllowed && inputData.jump && this.onGround()) {\n\t\t// \tthis._userForces.y += this._computeInputData.jumpStrength;\n\t\t// \tthis._velocity.y = 0;\n\t\t// }\n\t\t// const speed = this._inputData.run\n\t\t// \t? this._computeInputData.speed * this._computeInputData.runSpeedMult\n\t\t// \t: this._computeInputData.speed;\n\t\t// if (this._inputData.left) {\n\t\t// \tthis._userForces.x = -speed;\n\t\t// \tif (this._velocity.x > 0) {\n\t\t// \t\tthis._velocity.x = 0;\n\t\t// \t}\n\t\t// } else {\n\t\t// \tif (this._inputData.right) {\n\t\t// \t\tthis._userForces.x = speed;\n\t\t// \t\tif (this._velocity.x < 0) {\n\t\t// \t\t\tthis._velocity.x = 0;\n\t\t// \t\t}\n\t\t// \t} else {\n\t\t// \t\tthis._userForces.x = 0;\n\t\t// \t\tthis._velocity.x *= damping;\n\t\t// \t}\n\t\t// }\n\t\t// if (this._inputData.forward) {\n\t\t// \tthis._userForces.z = -speed;\n\t\t// \tif (this._velocity.z > 0) {\n\t\t// \t\tthis._velocity.z = 0;\n\t\t// \t}\n\t\t// } else {\n\t\t// \tif (this._inputData.backward) {\n\t\t// \t\tthis._userForces.z = speed;\n\t\t// \t\tif (this._velocity.z < 0) {\n\t\t// \t\t\tthis._velocity.z = 0;\n\t\t// \t\t}\n\t\t// \t} else {\n\t\t// \t\tthis._userForces.z = 0;\n\t\t// \t\tthis._velocity.z *= damping;\n\t\t// \t}\n\t\t// }\n\t}\n\tupdateWithCharacterController(\n\t\tcomputeData: CorePlayerPhysicsComputeInputData,\n\t\tinputData: CorePlayerPhysicsInputData,\n\t\tdelta: number\n\t) {\n\t\t// const characterController = this.characterController!;\n\t\t// gravity.set(this.world.gravity.x, this.world.gravity.y, this.world.gravity.z);\n\t\t// forcesByDelta.copy(this._userForces).add(gravity).multiplyScalar(delta).divideScalar(this._mass);\n\t\t// this._velocity.add(forcesByDelta);\n\t\t// desiredTranslation.copy(this._velocity).multiplyScalar(delta);\n\t\t// // console.log(desiredTranslation.x);\n\t\t// // console.log(this.PhysicsLib.QueryFilterFlags, this.PhysicsLib.QueryFilterFlags.EXCLUDE_KINEMATIC);\n\t\t// characterController.computeColliderMovement(\n\t\t// \tthis.collider,\n\t\t// \tdesiredTranslation\n\t\t// \t// undefined,\n\t\t// \t// undefined,\n\t\t// \t// (collider) => {\n\t\t// \t// \tconsole.log(collider);\n\t\t// \t// \treturn false;\n\t\t// \t// }\n\t\t// );\n\t\t// const correctedMovement = characterController.computedMovement();\n\t\t// this._correctedMovement.set(correctedMovement.x, correctedMovement.y, correctedMovement.z);\n\t\t// // console.log(correctedMovement.x, correctedMovement.y, correctedMovement.z);\n\t\t// // const y = correctedMovement.y > 0 && correctedMovement.y < 0.1 ? -0.1 : correctedMovement.y;\n\t\t// const deltaInv = 1 / delta;\n\t\t// // const fix = 12;\n\t\t// // console.log(\n\t\t// // \t'x',\n\t\t// // \tthis._velocity.x.toFixed(fix),\n\t\t// // \tdesiredTranslation.x.toFixed(fix),\n\t\t// // \tcorrectedMovement.x.toFixed(fix),\n\t\t// // \t(correctedMovement.x * deltaInv).toFixed(fix),\n\t\t// // \t'y',\n\t\t// // \tthis._velocity.y.toFixed(fix),\n\t\t// // \tdesiredTranslation.y.toFixed(fix),\n\t\t// // \tcorrectedMovement.y.toFixed(fix),\n\t\t// // \t(correctedMovement.y * deltaInv).toFixed(fix),\n\t\t// // \tMath.abs(this._velocity.x) < 0.000001 ? this.characterController.numComputedCollisions() : null\n\t\t// // );\n\t\t// this._velocity.x = correctedMovement.x * deltaInv;\n\t\t// this._velocity.y = correctedMovement.y * deltaInv;\n\t\t// this._velocity.z = correctedMovement.z * deltaInv;\n\t\t// // temporary fix for https://github.com/dimforge/rapier.js/issues/191\n\t\t// // const expectedVely = correctedMovement.y * deltaInv;\n\t\t// // this._velocity.y = Math.abs(expectedVely) < 0.1 ? this._velocity.y : expectedVely;\n\t\t// // if (expectedVely > 0 && this.characterController.numComputedCollisions() > 0) {\n\t\t// // \t// \t// but that fix breaks when doing auto step\n\t\t// // \t// console.log(this.characterController.numComputedCollisions());\n\t\t// // \tthis._velocity.y = -0.1;\n\t\t// // }\n\t\t// // this._velocity.set(correctedMovement.x, correctedMovement.y, correctedMovement.z).multiplyScalar(deltaInv);\n\t\t// // this._velocity.y = correctedTranslation.y;\n\t\t// // if (correctedMovement) {\n\t\t// // tmpPosition.set(result.correctedMovement.x, result.correctedMovement.y, result.correctedMovement.z);\n\t\t// // // tmpPosition.add(Object3D.position);\n\t\t// // console.log(tmpPosition.toArray());\n\t\t// correctedTranslation.copy(this._correctedMovement).add(this.object.position); //.divideScalar(delta);\n\t\t// this.body.setNextKinematicTranslation(correctedTranslation);\n\t\t// // Object3D.position.add(tmpOffset);\n\t\t// // }\n\t\t// // TODO: use collisions\n\t\t// // const collisionsCount = this.characterController.numComputedCollisions()\n\t\t// // for (let i = 0; i < collisionsCount; i++) {\n\t\t// // \t// const collision = this.characterController.computedCollision(i);\n\t\t// // \t// Do something with that collision information.\n\t\t// // }\n\t}\n}\n","import type {World} from '@dimforge/rapier3d-compat';\nimport {Object3D} from 'three';\nimport {CorePhysicsAttribute} from '../PhysicsAttribute';\nimport {_getRBDFromObject} from '../PhysicsRBD';\nimport {CorePlayerPhysics} from './CorePlayerPhysics';\nimport {PhysicsLib} from '../CorePhysics';\nimport {PolyScene} from '../../../engine/scene/PolyScene';\n\nconst physicsCharacterControllerByIdByObjectUuid: Map<string, Map<string, CorePlayerPhysics>> = new Map();\n\nexport enum PhysicsPlayerType {\n\tCHARACTER_CONTROLLER = 'characterController',\n\tTORQUE = 'torque',\n}\n\nexport function clearPhysicsPlayers() {\n\tphysicsCharacterControllerByIdByObjectUuid.forEach((map, id) => {\n\t\tmap.forEach((player) => {\n\t\t\tplayer.dispose();\n\t\t});\n\t\tmap.clear();\n\t});\n\n\tphysicsCharacterControllerByIdByObjectUuid.clear();\n}\ninterface CreateOrFindPhysicsPlayerOptions {\n\tscene: PolyScene;\n\tobject: Object3D;\n\tPhysicsLib: PhysicsLib;\n\tworld: World;\n\tworldObject: Object3D;\n}\n\nexport function createOrFindPhysicsPlayer(options: CreateOrFindPhysicsPlayerOptions) {\n\tconst {scene, object, PhysicsLib, world, worldObject} = options;\n\tlet player = findPhysicsPlayer(object);\n\tif (!player) {\n\t\tconst characterControllerId = CorePhysicsAttribute.getCharacterControllerId(object);\n\t\tif (!characterControllerId) {\n\t\t\treturn;\n\t\t}\n\t\tconst body = _getRBDFromObject(object);\n\t\tif (!body) {\n\t\t\treturn;\n\t\t}\n\t\tconst collider = body.collider(0);\n\t\tif (!collider) {\n\t\t\treturn;\n\t\t}\n\n\t\tplayer = new CorePlayerPhysics({\n\t\t\tscene,\n\t\t\tobject,\n\t\t\tPhysicsLib,\n\t\t\tworld,\n\t\t\tworldObject,\n\t\t\tbody,\n\t\t\tcollider,\n\t\t\ttype: PhysicsPlayerType.TORQUE,\n\t\t});\n\n\t\tlet map = physicsCharacterControllerByIdByObjectUuid.get(characterControllerId);\n\t\tif (!map) {\n\t\t\tmap = new Map();\n\t\t\tphysicsCharacterControllerByIdByObjectUuid.set(characterControllerId, map);\n\t\t}\n\t\tmap.set(object.uuid, player);\n\t}\n\t// CoreObject.addAttribute(pair.object, PhysicsIdAttribute.DEBUG, nodeId);\n\treturn player;\n}\nexport function findPhysicsPlayer(object: Object3D) {\n\tconst characterControllerId = CorePhysicsAttribute.getCharacterControllerId(object);\n\tif (!characterControllerId) {\n\t\treturn;\n\t}\n\treturn physicsCharacterControllerByIdByObjectUuid.get(characterControllerId)?.get(object.uuid);\n}\n","import type {Collider, Capsule} from '@dimforge/rapier3d-compat';\nimport {Object3D} from 'three';\nimport {\n\tCorePhysicsAttribute,\n\tPhysicsRBDColliderType,\n\tphysicsAttribNameLive,\n\tPhysicsRBDHeightAttribute,\n\tPhysicsRBDRadiusAttribute,\n} from '../PhysicsAttribute';\nimport {_getRBDFromObject} from '../PhysicsRBD';\nimport {PhysicsLib} from '../CorePhysics';\nimport {touchRBDProperty} from '../../reactivity/RBDPropertyReactivity';\nimport {coreObjectClassFactory} from '../../geometry/CoreObjectFactory';\n\nexport enum RBDCapsuleProperty {\n\tRADIUS = 'radius',\n\tHEIGHT = 'height',\n}\n\nconst EXPECTED_TYPE = PhysicsRBDColliderType.CAPSULE;\n\nexport function createPhysicsCapsule(PhysicsLib: PhysicsLib, object: Object3D) {\n\tconst halfHeight = CorePhysicsAttribute.getHeight(object) * 0.5 * object.scale.y;\n\tconst radius = CorePhysicsAttribute.getRadius(object) * object.scale.x;\n\treturn PhysicsLib.ColliderDesc.capsule(halfHeight, radius);\n}\n\nconst attributeHeightLive = physicsAttribNameLive(PhysicsRBDHeightAttribute.HEIGHT);\nconst attributeRadiusLive = physicsAttribNameLive(PhysicsRBDRadiusAttribute.RADIUS);\nexport function currentHeight(object: Object3D, collider: Collider) {\n\tconst coreObjectClass = coreObjectClassFactory(object);\n\tlet _currentHeight: number | undefined = coreObjectClass.attribValue(object, attributeHeightLive) as\n\t\t| number\n\t\t| undefined;\n\tif (_currentHeight == null) {\n\t\tconst shape = collider.shape as Capsule;\n\t\t_currentHeight = shape.halfHeight * 2;\n\t\tcoreObjectClass.setAttribute(object, attributeHeightLive, _currentHeight);\n\t}\n\treturn _currentHeight;\n}\nexport function currentRadius(object: Object3D, collider: Collider) {\n\tconst coreObjectClass = coreObjectClassFactory(object);\n\tlet _currentRadius: number | undefined = coreObjectClass.attribValue(object, attributeRadiusLive) as\n\t\t| number\n\t\t| undefined;\n\tif (_currentRadius == null) {\n\t\tconst shape = collider.shape as Capsule;\n\t\t_currentRadius = shape.radius;\n\t\tcoreObjectClass.setAttribute(object, attributeRadiusLive, _currentRadius);\n\t}\n\treturn _currentRadius;\n}\n\nexport function _getPhysicsRBDCapsuleHeight(object: Object3D): number | undefined {\n\tconst body = _getRBDFromObject(object);\n\tif (!body) {\n\t\tconsole.warn('no rbd found');\n\t\treturn;\n\t}\n\tconst colliderType = CorePhysicsAttribute.getColliderType(object);\n\tif (colliderType == null || colliderType != EXPECTED_TYPE) {\n\t\treturn;\n\t}\n\tconst collider = body.collider(0);\n\tif (!collider) {\n\t\treturn;\n\t}\n\treturn currentHeight(object, collider);\n}\nexport function _getPhysicsRBDCapsuleRadius(object: Object3D): number | undefined {\n\tconst body = _getRBDFromObject(object);\n\tif (!body) {\n\t\tconsole.warn('no rbd found');\n\t\treturn;\n\t}\n\tconst colliderType = CorePhysicsAttribute.getColliderType(object);\n\tif (colliderType == null || colliderType != EXPECTED_TYPE) {\n\t\treturn;\n\t}\n\tconst collider = body.collider(0);\n\tif (!collider) {\n\t\treturn;\n\t}\n\treturn currentRadius(object, collider);\n}\n\nexport function _setPhysicsRBDCapsuleProperty(\n\tobject: Object3D,\n\ttargetScale: number,\n\tlerp: number,\n\tupdateObjectMatrix: boolean\n) {\n\tconst body = _getRBDFromObject(object);\n\tif (!body) {\n\t\tconsole.warn('no rbd found');\n\t\treturn;\n\t}\n\tconst colliderType = CorePhysicsAttribute.getColliderType(object);\n\tif (colliderType == null || colliderType != EXPECTED_TYPE) {\n\t\treturn;\n\t}\n\tconst collidersCount = body.numColliders();\n\tconst originalHeightAttrib = CorePhysicsAttribute.getHeight(object);\n\tconst originalRadiusAttrib = CorePhysicsAttribute.getRadius(object);\n\n\tfor (let i = 0; i < collidersCount; i++) {\n\t\tconst collider = body.collider(i);\n\t\tif (!collider) {\n\t\t\treturn;\n\t\t}\n\t\t// let targetHeight = targetScale;\n\t\tlet targetRadius = targetScale;\n\n\t\tif (lerp < 1) {\n\t\t\t// targetHeight = lerp * targetHeight + (1 - lerp) * currentHeight(object, collider);\n\t\t\ttargetRadius = lerp * targetRadius + (1 - lerp) * currentRadius(object, collider);\n\t\t}\n\t\tconst radiusRatio = targetRadius / originalRadiusAttrib;\n\t\tconst targetHeight = 0.5 * radiusRatio * originalHeightAttrib;\n\t\t// update radius on shape and object\n\t\tcollider.setHalfHeight(targetHeight);\n\t\tcollider.setRadius(targetRadius);\n\t\tconst coreObjectClass = coreObjectClassFactory(object);\n\t\tcoreObjectClass.setAttribute(object, attributeHeightLive, targetHeight);\n\t\tcoreObjectClass.setAttribute(object, attributeRadiusLive, targetRadius);\n\t\ttouchRBDProperty(object, RBDCapsuleProperty.HEIGHT);\n\t\ttouchRBDProperty(object, RBDCapsuleProperty.RADIUS);\n\t\t// update scale\n\t\t// TODO: we can't apply a simple scale to a capsule\n\t\t// it could possibly work if the capsule was 3 objects (1 tube + 2 half spheres)\n\n\t\t// const heightRatio = targetHeight / originalHeightAttrib; // should be on y\n\t\tobject.scale.set(radiusRatio, radiusRatio, radiusRatio);\n\t\tif (updateObjectMatrix) {\n\t\t\tobject.updateMatrix();\n\t\t}\n\t}\n}\n","import {Object3D} from 'three';\nimport {CorePhysicsAttribute, PhysicsRBDColliderType} from '../PhysicsAttribute';\nimport {PhysicsLib} from '../CorePhysics';\nimport {getPhysicsRBDHeight, getPhysicsRBDRadius, setPhysicsRBDHeightRadiusProperty} from './_CommonHeightRadius';\n\nconst EXPECTED_TYPE = PhysicsRBDColliderType.CONE;\n\nexport function createPhysicsCone(PhysicsLib: PhysicsLib, object: Object3D) {\n\tconst halfHeight = CorePhysicsAttribute.getHeight(object) * 0.5 * object.scale.y;\n\tconst radius = CorePhysicsAttribute.getRadius(object) * object.scale.x;\n\n\tconst borderRadius = CorePhysicsAttribute.getBorderRadius(object);\n\tif (borderRadius <= 0) {\n\t\treturn PhysicsLib.ColliderDesc.cone(halfHeight, radius);\n\t} else {\n\t\tconst borderRadius2 = Math.min(borderRadius, Math.min(halfHeight, radius));\n\t\tconst halfHeight2 = halfHeight - borderRadius2;\n\t\tconst radius2 = radius - borderRadius2;\n\t\treturn PhysicsLib.ColliderDesc.roundCone(halfHeight2, radius2, borderRadius2);\n\t}\n}\n\nexport function _getPhysicsRBDConeHeight(object: Object3D): number | undefined {\n\treturn getPhysicsRBDHeight(EXPECTED_TYPE, object);\n}\nexport function _getPhysicsRBDConeRadius(object: Object3D): number | undefined {\n\treturn getPhysicsRBDRadius(EXPECTED_TYPE, object);\n}\n\nexport function _setPhysicsRBDConeProperty(\n\tobject: Object3D,\n\ttargetRadius: number,\n\ttargetHeight: number,\n\tlerp: number,\n\tupdateObjectMatrix: boolean\n) {\n\tsetPhysicsRBDHeightRadiusProperty(EXPECTED_TYPE, object, targetRadius, targetHeight, lerp, updateObjectMatrix);\n}\n","import type {Collider, Cuboid} from '@dimforge/rapier3d-compat';\nimport {Object3D, Vector3} from 'three';\nimport {\n\tCorePhysicsAttribute,\n\tPhysicsRBDColliderType,\n\tphysicsAttribNameLive,\n\tPhysicsRBDCuboidAttribute,\n} from '../PhysicsAttribute';\nimport {_getRBDFromObject} from '../PhysicsRBD';\nimport {PhysicsLib} from '../CorePhysics';\nimport {touchRBDProperty} from '../../reactivity/RBDPropertyReactivity';\nimport {coreObjectClassFactory} from '../../geometry/CoreObjectFactory';\n\nconst EXPECTED_TYPE = PhysicsRBDColliderType.CUBOID;\n\nexport enum RBDCuboidProperty {\n\tSIZES = 'sizes',\n}\n\nconst tmp = new Vector3();\nlet _currentSizes = new Vector3();\nlet _targetSizes = new Vector3();\nlet _targetHalfSizes = new Vector3();\nlet _originalSizes = new Vector3();\nconst SAFETY_OFFSET = 0.001;\n\nconst attribSizeLiveByObject: WeakMap<Object3D, Vector3> = new WeakMap();\nfunction _getAttribSizeLiveByObject(object3D: Object3D) {\n\tlet v = attribSizeLiveByObject.get(object3D);\n\tif (!v) {\n\t\tv = new Vector3();\n\t\tattribSizeLiveByObject.set(object3D, v);\n\t}\n\treturn v;\n}\n\nexport function createPhysicsCuboid(PhysicsLib: PhysicsLib, object: Object3D) {\n\tCorePhysicsAttribute.getCuboidSizes(object, tmp);\n\tconst size = CorePhysicsAttribute.getCuboidSize(object);\n\ttmp.multiplyScalar(size * 0.5);\n\ttmp.multiply(object.scale);\n\tconst borderRadius = CorePhysicsAttribute.getBorderRadius(object);\n\tif (borderRadius <= 0) {\n\t\treturn PhysicsLib.ColliderDesc.cuboid(tmp.x, tmp.y, tmp.z);\n\t} else {\n\t\t// We reduce the size by the border radius,\n\t\t// but we also need to make sure that the size will not be 0\n\t\tconst minDim = Math.min(tmp.x, tmp.y, tmp.z);\n\t\tconst borderRadiusAdjusted = Math.min(borderRadius, minDim - SAFETY_OFFSET);\n\t\ttmp.subScalar(borderRadiusAdjusted);\n\t\treturn PhysicsLib.ColliderDesc.roundCuboid(tmp.x, tmp.y, tmp.z, borderRadiusAdjusted);\n\t}\n}\n\nconst attributeSizesLive = physicsAttribNameLive(PhysicsRBDCuboidAttribute.SIZES);\nexport function currentSizes(object: Object3D, collider: Collider, target: Vector3): void {\n\tconst coreObjectClass = coreObjectClassFactory(object);\n\tlet result: Vector3 | undefined = coreObjectClass.attribValue(object, attributeSizesLive, 0, target) as\n\t\t| Vector3\n\t\t| undefined;\n\tif (result == null) {\n\t\tconst shape = collider.shape as Cuboid;\n\t\tconst v = shape.halfExtents;\n\t\ttarget.set(v.x, v.y, v.z).multiplyScalar(2);\n\t\tcoreObjectClass.setAttribute(object, attributeSizesLive, new Vector3().copy(target));\n\t}\n}\n\nexport function _getPhysicsRBDCuboidSizes(object: Object3D, target: Vector3): void {\n\tconst body = _getRBDFromObject(object);\n\tif (!body) {\n\t\tconsole.warn('no rbd found');\n\t\treturn;\n\t}\n\tconst colliderType = CorePhysicsAttribute.getColliderType(object);\n\tif (colliderType == null || colliderType != EXPECTED_TYPE) {\n\t\treturn;\n\t}\n\tconst collider = body.collider(0);\n\tif (!collider) {\n\t\treturn;\n\t}\n\tcurrentSizes(object, collider, target);\n}\n\nexport function _setPhysicsRBDCuboidProperty(\n\tobject: Object3D,\n\ttargetSizes: Vector3,\n\ttargetSize: number,\n\tlerp: number,\n\tupdateObjectMatrix: boolean\n) {\n\tconst body = _getRBDFromObject(object);\n\tif (!body) {\n\t\tconsole.warn('no rbd found');\n\t\treturn;\n\t}\n\tconst colliderType = CorePhysicsAttribute.getColliderType(object);\n\tif (colliderType == null || colliderType != EXPECTED_TYPE) {\n\t\treturn;\n\t}\n\tconst collidersCount = body.numColliders();\n\tCorePhysicsAttribute.getCuboidSizes(object, _originalSizes);\n\tconst originalSize = CorePhysicsAttribute.getCuboidSize(object);\n\t_originalSizes.multiplyScalar(originalSize);\n\n\tfor (let i = 0; i < collidersCount; i++) {\n\t\tconst collider = body.collider(i);\n\t\tif (!collider) {\n\t\t\treturn;\n\t\t}\n\t\t_targetSizes.copy(targetSizes).multiplyScalar(targetSize);\n\t\tif (lerp < 1) {\n\t\t\tcurrentSizes(object, collider, _currentSizes);\n\t\t\t_targetSizes.lerp(_currentSizes, 1 - lerp);\n\t\t}\n\t\t// update radius on shape and object\n\t\tconst v = _getAttribSizeLiveByObject(object);\n\t\tv.copy(_targetSizes);\n\t\tconst coreObjectClass = coreObjectClassFactory(object);\n\t\tcoreObjectClass.setAttribute(object, attributeSizesLive, v);\n\t\ttouchRBDProperty(object, RBDCuboidProperty.SIZES);\n\t\t// update scale\n\t\tobject.scale.copy(_targetSizes).divide(_originalSizes);\n\t\tif (updateObjectMatrix) {\n\t\t\tobject.updateMatrix();\n\t\t}\n\t\t// update rbd in the end, so that we scale size *.5 last\n\t\t_targetHalfSizes.copy(_targetSizes).multiplyScalar(0.5);\n\t\tcollider.setHalfExtents(_targetHalfSizes);\n\t}\n}\n","import {Object3D} from 'three';\nimport {CorePhysicsAttribute, PhysicsRBDColliderType} from '../PhysicsAttribute';\nimport {PhysicsLib} from '../CorePhysics';\nimport {getPhysicsRBDHeight, getPhysicsRBDRadius, setPhysicsRBDHeightRadiusProperty} from './_CommonHeightRadius';\n\nconst EXPECTED_TYPE = PhysicsRBDColliderType.CYLINDER;\nexport function createPhysicsCylinder(PhysicsLib: PhysicsLib, object: Object3D) {\n\tconst halfHeight = CorePhysicsAttribute.getHeight(object) * 0.5 * object.scale.y;\n\tconst radius = CorePhysicsAttribute.getRadius(object) * object.scale.x;\n\n\tconst borderRadius = CorePhysicsAttribute.getBorderRadius(object);\n\tif (borderRadius <= 0) {\n\t\treturn PhysicsLib.ColliderDesc.cylinder(halfHeight, radius);\n\t} else {\n\t\tconst borderRadius2 = Math.min(borderRadius, Math.min(halfHeight, radius));\n\t\tconst halfHeight2 = halfHeight - borderRadius2;\n\t\tconst radius2 = radius - borderRadius2;\n\t\treturn PhysicsLib.ColliderDesc.roundCylinder(halfHeight2, radius2, borderRadius2);\n\t}\n\treturn;\n}\n\nexport function _getPhysicsRBDCylinderHeight(object: Object3D): number | undefined {\n\treturn getPhysicsRBDHeight(EXPECTED_TYPE, object);\n}\nexport function _getPhysicsRBDCylinderRadius(object: Object3D): number | undefined {\n\treturn getPhysicsRBDRadius(EXPECTED_TYPE, object);\n}\n\nexport function _setPhysicsRBDCylinderProperty(\n\tobject: Object3D,\n\ttargetRadius: number,\n\ttargetHeight: number,\n\tlerp: number,\n\tupdateObjectMatrix: boolean\n) {\n\tsetPhysicsRBDHeightRadiusProperty(EXPECTED_TYPE, object, targetRadius, targetHeight, lerp, updateObjectMatrix);\n}\n","import type {Collider, Ball} from '@dimforge/rapier3d-compat';\nimport {Object3D} from 'three';\nimport {\n\tCorePhysicsAttribute,\n\tPhysicsRBDColliderType,\n\tphysicsAttribNameLive,\n\tPhysicsRBDRadiusAttribute,\n} from '../PhysicsAttribute';\nimport {_getRBDFromObject} from '../PhysicsRBD';\nimport {PhysicsLib} from '../CorePhysics';\nimport {getPhysicsRBDRadius, RBDCommonProperty} from './_CommonHeightRadius';\nimport {touchRBDProperty} from '../../reactivity/RBDPropertyReactivity';\nimport {coreObjectClassFactory} from '../../geometry/CoreObjectFactory';\n\nconst EXPECTED_TYPE = PhysicsRBDColliderType.SPHERE;\n\nexport function createPhysicsSphere(PhysicsLib: PhysicsLib, object: Object3D) {\n\tconst radius = CorePhysicsAttribute.getRadius(object) * object.scale.y;\n\treturn PhysicsLib.ColliderDesc.ball(radius);\n}\n\nconst attributeRadiusLive = physicsAttribNameLive(PhysicsRBDRadiusAttribute.RADIUS);\nexport function currentRadius(object: Object3D, collider: Collider) {\n\tconst coreObjectClass = coreObjectClassFactory(object);\n\tlet _currentRadius: number | undefined = coreObjectClass.attribValue(object, attributeRadiusLive) as\n\t\t| number\n\t\t| undefined;\n\tif (_currentRadius == null) {\n\t\tconst shape = collider.shape as Ball;\n\t\t_currentRadius = shape.radius;\n\t\tcoreObjectClass.setAttribute(object, attributeRadiusLive, _currentRadius);\n\t}\n\treturn _currentRadius;\n}\n\nexport function _getPhysicsRBDSphereRadius(object: Object3D): number | undefined {\n\treturn getPhysicsRBDRadius(EXPECTED_TYPE, object);\n}\n\nexport function _setPhysicsRBDSphereProperty(\n\tobject: Object3D,\n\ttargetRadius: number,\n\tlerp: number,\n\tupdateObjectMatrix: boolean\n) {\n\tconst body = _getRBDFromObject(object);\n\tif (!body) {\n\t\tconsole.warn('no rbd found');\n\t\treturn;\n\t}\n\tconst colliderType = CorePhysicsAttribute.getColliderType(object);\n\tif (colliderType == null || colliderType != EXPECTED_TYPE) {\n\t\treturn;\n\t}\n\tconst collidersCount = body.numColliders();\n\tconst originalRadiusAttrib = CorePhysicsAttribute.getRadius(object);\n\n\tfor (let i = 0; i < collidersCount; i++) {\n\t\tconst collider = body.collider(i);\n\t\tif (!collider) {\n\t\t\treturn;\n\t\t}\n\t\tif (lerp < 1) {\n\t\t\ttargetRadius = lerp * targetRadius + (1 - lerp) * currentRadius(object, collider);\n\t\t}\n\t\t// update radius on shape and object\n\t\tcollider.setRadius(targetRadius);\n\t\tconst coreObjectClass = coreObjectClassFactory(object);\n\t\tcoreObjectClass.setAttribute(object, attributeRadiusLive, targetRadius);\n\t\ttouchRBDProperty(object, RBDCommonProperty.RADIUS);\n\t\t// update scale\n\t\tconst newScale = targetRadius / originalRadiusAttrib;\n\t\tobject.scale.set(newScale, newScale, newScale);\n\t\tif (updateObjectMatrix) {\n\t\t\tobject.updateMatrix();\n\t\t}\n\t}\n}\n","import type {Collider, Cone} from '@dimforge/rapier3d-compat';\nimport {Object3D} from 'three';\nimport {\n\tCorePhysicsAttribute,\n\tPhysicsRBDColliderType,\n\tphysicsAttribNameLive,\n\tPhysicsRBDRadiusAttribute,\n\tPhysicsRBDHeightAttribute,\n} from '../PhysicsAttribute';\nimport {_getRBDFromObject} from '../PhysicsRBD';\nimport {touchRBDProperty} from '../../reactivity/RBDPropertyReactivity';\nimport {coreObjectClassFactory} from '../../geometry/CoreObjectFactory';\n\nexport enum RBDCommonProperty {\n\tRADIUS = 'radius',\n\tHEIGHT = 'height',\n}\n\nconst attributeHeightLive = physicsAttribNameLive(PhysicsRBDHeightAttribute.HEIGHT);\nconst attributeRadiusLive = physicsAttribNameLive(PhysicsRBDRadiusAttribute.RADIUS);\nexport function currentHeight(object: Object3D, collider: Collider) {\n\tconst coreObjectClass = coreObjectClassFactory(object);\n\tlet _currentHeight: number | undefined = coreObjectClass.attribValue(object, attributeHeightLive) as\n\t\t| number\n\t\t| undefined;\n\tif (_currentHeight == null) {\n\t\tconst shape = collider.shape as Cone;\n\t\t_currentHeight = shape.halfHeight * 2;\n\t\tcoreObjectClass.setAttribute(object, attributeHeightLive, _currentHeight);\n\t}\n\treturn _currentHeight;\n}\nexport function currentRadius(object: Object3D, collider: Collider) {\n\tconst coreObjectClass = coreObjectClassFactory(object);\n\tlet _currentRadius: number | undefined = coreObjectClass.attribValue(object, attributeRadiusLive) as\n\t\t| number\n\t\t| undefined;\n\tif (_currentRadius == null) {\n\t\tconst shape = collider.shape as Cone;\n\t\t_currentRadius = shape.radius;\n\t\tcoreObjectClass.setAttribute(object, attributeRadiusLive, _currentRadius);\n\t}\n\treturn _currentRadius;\n}\n\nexport function getPhysicsRBDHeight(\n\texpectedType: PhysicsRBDColliderType.CONE | PhysicsRBDColliderType.CYLINDER,\n\tobject: Object3D\n): number | undefined {\n\tconst body = _getRBDFromObject(object);\n\tif (!body) {\n\t\tconsole.warn('no rbd found');\n\t\treturn;\n\t}\n\tconst colliderType = CorePhysicsAttribute.getColliderType(object);\n\tif (colliderType == null || colliderType != expectedType) {\n\t\treturn;\n\t}\n\tconst collider = body.collider(0);\n\tif (!collider) {\n\t\treturn;\n\t}\n\treturn currentHeight(object, collider);\n}\nexport function getPhysicsRBDRadius(\n\texpectedType: PhysicsRBDColliderType.CONE | PhysicsRBDColliderType.CYLINDER | PhysicsRBDColliderType.SPHERE,\n\tobject: Object3D\n): number | undefined {\n\tconst body = _getRBDFromObject(object);\n\tif (!body) {\n\t\tconsole.warn('no rbd found');\n\t\treturn;\n\t}\n\tconst colliderType = CorePhysicsAttribute.getColliderType(object);\n\tif (colliderType == null) {\n\t\tconsole.warn('no colliderType found');\n\t\treturn;\n\t}\n\tif (colliderType != expectedType) {\n\t\tconsole.warn(`colliderType '${colliderType}' not the expected one ('${expectedType}')`);\n\t\treturn;\n\t}\n\tconst collider = body.collider(0);\n\tif (!collider) {\n\t\tconsole.warn('no collider found');\n\t\treturn;\n\t}\n\treturn currentRadius(object, collider);\n}\n\nexport function setPhysicsRBDHeightRadiusProperty(\n\texpectedType: PhysicsRBDColliderType.CONE | PhysicsRBDColliderType.CYLINDER,\n\tobject: Object3D,\n\ttargetRadius: number,\n\ttargetHeight: number,\n\tlerp: number,\n\tupdateObjectMatrix: boolean\n) {\n\tconst body = _getRBDFromObject(object);\n\tif (!body) {\n\t\tconsole.warn('no rbd found');\n\t\treturn;\n\t}\n\tconst colliderType = CorePhysicsAttribute.getColliderType(object);\n\tif (colliderType == null || colliderType != expectedType) {\n\t\treturn;\n\t}\n\tconst collidersCount = body.numColliders();\n\tconst originalHeightAttrib = CorePhysicsAttribute.getHeight(object);\n\tconst originalRadiusAttrib = CorePhysicsAttribute.getRadius(object);\n\n\tfor (let i = 0; i < collidersCount; i++) {\n\t\tconst collider = body.collider(i);\n\t\tif (!collider) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (lerp < 1) {\n\t\t\ttargetHeight = lerp * targetHeight + (1 - lerp) * currentHeight(object, collider);\n\t\t\ttargetRadius = lerp * targetRadius + (1 - lerp) * currentRadius(object, collider);\n\t\t}\n\t\t// update radius on shape and object\n\t\tcollider.setHalfHeight(targetHeight * 0.5);\n\t\tcollider.setRadius(targetRadius);\n\t\tconst coreObjectClass = coreObjectClassFactory(object);\n\t\tcoreObjectClass.setAttribute(object, attributeHeightLive, targetHeight);\n\t\tcoreObjectClass.setAttribute(object, attributeRadiusLive, targetRadius);\n\t\ttouchRBDProperty(object, RBDCommonProperty.HEIGHT);\n\t\ttouchRBDProperty(object, RBDCommonProperty.RADIUS);\n\t\t// update scale\n\t\tconst scaleXZ = targetRadius / originalRadiusAttrib;\n\t\tobject.scale.set(scaleXZ, targetHeight / originalHeightAttrib, scaleXZ);\n\t\tif (updateObjectMatrix) {\n\t\t\tobject.updateMatrix();\n\t\t}\n\t}\n}\n","import {CapsuleSopOperation} from './../../engine/operations/sop/Capsule';\nimport {Object3D} from 'three';\nimport {Vector3} from 'three';\nimport {Box3} from 'three';\nimport {Line3} from 'three';\nimport {Matrix4} from 'three';\nimport {MeshWithBVH, ExtendedTriangle} from '../../core/geometry/bvh/three-mesh-bvh';\nimport {CapsuleOptions} from './CapsuleGeometry';\nimport {MathUtils} from 'three';\nexport interface CorePlayerOptions {\n\tobject: Object3D;\n\tcollider: MeshWithBVH;\n\t// meshName?: string;\n}\n\ntype ResetRequiredCallback = () => boolean;\nconst tmpGravity = new Vector3(0, 0, 0);\nconst upVector = new Vector3(0, 1, 0);\nconst tempVector1 = new Vector3();\nconst tempVector2 = new Vector3();\nconst tempVector3 = new Vector3();\nconst tempVector4 = new Vector3();\nconst tempVector5 = new Vector3();\nconst tempBox = new Box3();\nconst tempMat = new Matrix4();\nconst tempSegment = new Line3();\nconst startRotationRadians = new Vector3();\n\nexport class CorePlayer {\n\tprivate _pressed = {\n\t\tforward: false,\n\t\tbackward: false,\n\t\tleft: false,\n\t\tright: false,\n\t};\n\tprivate _onGround = false;\n\tprivate _velocity = new Vector3();\n\tpublic readonly capsuleInfo = {\n\t\tradius: CapsuleSopOperation.DEFAULT_PARAMS.radius,\n\t\tsegment: new Line3(\n\t\t\tnew Vector3(0, 0, 0),\n\t\t\tnew Vector3(\n\t\t\t\t0,\n\t\t\t\t-(CapsuleSopOperation.DEFAULT_PARAMS.height - 2 * CapsuleSopOperation.DEFAULT_PARAMS.radius),\n\t\t\t\t0\n\t\t\t)\n\t\t),\n\t};\n\t// private _meshName: string | undefined;\n\t// private _mesh: Mesh | undefined;\n\tpublic object!: Object3D;\n\tpublic collider!: MeshWithBVH;\n\tpublic startPosition = new Vector3(0, 5, 0);\n\tpublic startRotation = new Vector3(0, 0, 0);\n\tpublic jumpAllowed = true;\n\tpublic jumpStrength = 10;\n\tpublic runAllowed = true;\n\tpublic runSpeedMult = 2;\n\tprivate _running = false;\n\tpublic speed = 10;\n\tpublic physicsSteps = 5;\n\tpublic gravity = new Vector3(0, -30, 0);\n\tprivate _azimuthalAngle = 0;\n\tprivate _resetYMax = -25;\n\tprivate _resetRequiredCallback: ResetRequiredCallback = () => {\n\t\treturn this.object.position.y < this._resetYMax;\n\t};\n\tconstructor(options: CorePlayerOptions) {\n\t\tthis.setOptions(options);\n\t}\n\tsetOptions(options: CorePlayerOptions) {\n\t\tthis._setObject(options.object);\n\t\tthis.setCollider(options.collider);\n\t}\n\tprivate _setObject(object: Object3D) {\n\t\tthis.object = object;\n\t\tthis.object.matrixAutoUpdate = true;\n\t}\n\tsetCollider(collider: MeshWithBVH) {\n\t\tthis.collider = collider;\n\t}\n\tsetCapsule(capsuleOptions: CapsuleOptions) {\n\t\tthis.capsuleInfo.radius = capsuleOptions.radius;\n\t\tthis.capsuleInfo.segment.end.y = -(capsuleOptions.height - 2 * capsuleOptions.radius);\n\t}\n\n\treset() {\n\t\tthis.stop();\n\t\tthis.object.position.copy(this.startPosition);\n\t\tstartRotationRadians.copy(this.startRotation).multiplyScalar(MathUtils.DEG2RAD);\n\t\tthis.object.rotation.setFromVector3(startRotationRadians);\n\t\tthis.object.updateMatrix();\n\t\tthis.object.updateWorldMatrix(true, true);\n\t\tthis.object.updateMatrixWorld(true);\n\t}\n\tstop() {\n\t\tthis._pressed.forward = false;\n\t\tthis._pressed.backward = false;\n\t\tthis._pressed.left = false;\n\t\tthis._pressed.right = false;\n\t\tthis._running = false;\n\t\tthis._velocity.set(0, 0, 0);\n\t}\n\tsetResetRequiredCallback(callback: ResetRequiredCallback) {\n\t\tthis._resetRequiredCallback = callback;\n\t}\n\tsetAzimuthalAngle(angle: number) {\n\t\tthis._azimuthalAngle = angle;\n\t}\n\tupdate(delta: number) {\n\t\tconst deltaBounded = Math.min(delta, 0.1);\n\t\tfor (let i = 0; i < this.physicsSteps; i++) {\n\t\t\tthis._updateStep(deltaBounded / this.physicsSteps);\n\t\t}\n\t}\n\tprivate _updateStep(delta: number) {\n\t\tif (!this._onGround) {\n\t\t\ttmpGravity.copy(this.gravity).multiplyScalar(delta);\n\t\t\tthis._velocity.add(tmpGravity);\n\t\t}\n\t\tthis.object.position.addScaledVector(this._velocity, delta);\n\n\t\t// move the player\n\t\tconst angle = this._azimuthalAngle;\n\t\tconst speed = this.speed * delta * (this._running ? this.runSpeedMult : 1);\n\t\ttempVector2.set(0, 0, 0);\n\t\tif (this._pressed.forward) {\n\t\t\ttempVector1.set(0, 0, -1).applyAxisAngle(upVector, angle);\n\t\t\ttempVector2.add(tempVector1);\n\t\t}\n\n\t\tif (this._pressed.backward) {\n\t\t\ttempVector1.set(0, 0, 1).applyAxisAngle(upVector, angle);\n\t\t\ttempVector2.add(tempVector1);\n\t\t}\n\n\t\tif (this._pressed.left) {\n\t\t\ttempVector1.set(-1, 0, 0).applyAxisAngle(upVector, angle);\n\t\t\ttempVector2.add(tempVector1);\n\t\t}\n\n\t\tif (this._pressed.right) {\n\t\t\ttempVector1.set(1, 0, 0).applyAxisAngle(upVector, angle);\n\t\t\ttempVector2.add(tempVector1);\n\t\t}\n\t\ttempVector2.normalize().multiplyScalar(speed);\n\t\tthis.object.position.add(tempVector2);\n\n\t\tthis.object.updateMatrixWorld();\n\n\t\t// adjust player position based on collisions\n\t\tconst capsuleInfo = this.capsuleInfo;\n\t\ttempBox.makeEmpty();\n\t\ttempMat.copy(this.collider.matrixWorld).invert();\n\t\ttempSegment.copy(capsuleInfo.segment);\n\n\t\t// get the position of the capsule in the local space of the collider\n\t\ttempSegment.start.applyMatrix4(this.object.matrixWorld).applyMatrix4(tempMat);\n\t\ttempSegment.end.applyMatrix4(this.object.matrixWorld).applyMatrix4(tempMat);\n\n\t\t// get the axis aligned bounding box of the capsule\n\t\ttempBox.expandByPoint(tempSegment.start);\n\t\ttempBox.expandByPoint(tempSegment.end);\n\n\t\ttempBox.min.addScalar(-capsuleInfo.radius);\n\t\ttempBox.max.addScalar(capsuleInfo.radius);\n\n\t\tconst intersectsBounds = (\n\t\t\tbox: Box3,\n\t\t\tisLeaf: boolean,\n\t\t\tscore: number | undefined,\n\t\t\tdepth: number,\n\t\t\tnodeIndex: number\n\t\t) => {\n\t\t\treturn box.intersectsBox(tempBox);\n\t\t};\n\n\t\tconst intersectsTriangle = (tri: ExtendedTriangle) => {\n\t\t\t// check if the triangle is intersecting the capsule and adjust the\n\t\t\t// capsule position if it is.\n\t\t\tconst triPoint = tempVector3;\n\t\t\tconst capsulePoint = tempVector4;\n\n\t\t\tconst distance = tri.closestPointToSegment(tempSegment, triPoint, capsulePoint) as number;\n\t\t\tif (distance < capsuleInfo.radius) {\n\t\t\t\tconst depth = capsuleInfo.radius - distance;\n\t\t\t\tconst direction = capsulePoint.sub(triPoint).normalize();\n\n\t\t\t\ttempSegment.start.addScaledVector(direction, depth);\n\t\t\t\ttempSegment.end.addScaledVector(direction, depth);\n\t\t\t}\n\t\t};\n\n\t\tthis.collider.geometry.boundsTree.shapecast({\n\t\t\tintersectsBounds,\n\n\t\t\tintersectsTriangle,\n\t\t});\n\n\t\t// get the adjusted position of the capsule collider in world space after checking\n\t\t// triangle collisions and moving it. capsuleInfo.segment.start is assumed to be\n\t\t// the origin of the player model.\n\t\tconst newPosition = tempVector5;\n\t\t// tempSegment.start.y += capsuleInfo.radius;\n\t\tnewPosition.copy(tempSegment.start);\n\t\tnewPosition.applyMatrix4(this.collider.matrixWorld);\n\n\t\t// check how much the collider was moved\n\t\tconst deltaVector = tempVector2;\n\t\tdeltaVector.subVectors(newPosition, this.object.position);\n\n\t\t// if the player was primarily adjusted vertically we assume it's on something we should consider ground\n\t\tthis._onGround = deltaVector.y > Math.abs(delta * this._velocity.y * 0.25);\n\n\t\tconst offset = Math.max(0.0, deltaVector.length() - 1e-5);\n\t\tdeltaVector.normalize().multiplyScalar(offset);\n\n\t\t// adjust the player model\n\t\tthis.object.position.add(deltaVector);\n\n\t\tif (!this._onGround) {\n\t\t\tdeltaVector.normalize();\n\t\t\tthis._velocity.addScaledVector(deltaVector, -deltaVector.dot(this._velocity));\n\t\t} else {\n\t\t\tthis._velocity.set(0, 0, 0);\n\t\t}\n\n\t\t// if the player has fallen too far below the level reset their position to the start\n\t\tif (this._resetRequiredCallback()) {\n\t\t\tthis.reset();\n\t\t}\n\t}\n\n\tsetForward(state: boolean) {\n\t\tthis._pressed.forward = state;\n\t}\n\tsetBackward(state: boolean) {\n\t\tthis._pressed.backward = state;\n\t}\n\tsetLeft(state: boolean) {\n\t\tthis._pressed.left = state;\n\t}\n\tsetRight(state: boolean) {\n\t\tthis._pressed.right = state;\n\t}\n\tjump() {\n\t\tif (this._onGround && this.jumpAllowed) {\n\t\t\tthis._velocity.y = this.jumpStrength;\n\t\t}\n\t}\n\tsetRun(state: boolean) {\n\t\tif (state) {\n\t\t\tif (this._onGround && this.runAllowed) {\n\t\t\t\tthis._running = true;\n\t\t\t}\n\t\t} else {\n\t\t\tthis._running = false;\n\t\t}\n\t}\n\trunning() {\n\t\treturn this._running;\n\t}\n}\n","export enum CorePlayerInput {\n\tLEFT = 'left',\n\tRIGHT = 'right',\n\tBACKWARD = 'backward',\n\tFORWARD = 'forward',\n\tRUN = 'run',\n\tJUMP = 'jump',\n}\nexport const CORE_PLAYER_INPUTS: CorePlayerInput[] = [\n\tCorePlayerInput.LEFT,\n\tCorePlayerInput.RIGHT,\n\tCorePlayerInput.BACKWARD,\n\tCorePlayerInput.FORWARD,\n\tCorePlayerInput.RUN,\n\tCorePlayerInput.JUMP,\n];\n","import {BlendFunction} from 'postprocessing';\nimport {MenuNumericParamOptions} from '../../engine/params/utils/OptionsController';\n\nconst BLEND_FUNCTION_BY_NAME = [\n\t{SKIP: BlendFunction.SKIP},\n\t{SET: BlendFunction.SET},\n\t{ADD: BlendFunction.ADD},\n\t{ALPHA: BlendFunction.ALPHA},\n\t{AVERAGE: BlendFunction.AVERAGE},\n\t{COLOR: BlendFunction.COLOR},\n\t{COLOR_BURN: BlendFunction.COLOR_BURN},\n\t{COLOR_DODGE: BlendFunction.COLOR_DODGE},\n\t{DARKEN: BlendFunction.DARKEN},\n\t{DIFFERENCE: BlendFunction.DIFFERENCE},\n\t{DIVIDE: BlendFunction.DIVIDE},\n\t// {DST: BlendFunction.DST}, // DST and SKIP are the same\n\t{EXCLUSION: BlendFunction.EXCLUSION},\n\t{HARD_LIGHT: BlendFunction.HARD_LIGHT},\n\t{HARD_MIX: BlendFunction.HARD_MIX},\n\t{HUE: BlendFunction.HUE},\n\t{INVERT: BlendFunction.INVERT},\n\t{INVERT_RGB: BlendFunction.INVERT_RGB},\n\t{LIGHTEN: BlendFunction.LIGHTEN},\n\t{LINEAR_BURN: BlendFunction.LINEAR_BURN},\n\t{LINEAR_DODGE: BlendFunction.LINEAR_DODGE},\n\t{LINEAR_LIGHT: BlendFunction.LINEAR_LIGHT},\n\t{LUMINOSITY: BlendFunction.LUMINOSITY},\n\t{MULTIPLY: BlendFunction.MULTIPLY},\n\t{NEGATION: BlendFunction.NEGATION},\n\t{NORMAL: BlendFunction.NORMAL},\n\t{OVERLAY: BlendFunction.OVERLAY},\n\t{PIN_LIGHT: BlendFunction.PIN_LIGHT},\n\t{SATURATION: BlendFunction.SATURATION},\n\t{REFLECT: BlendFunction.REFLECT},\n\t{SCREEN: BlendFunction.SCREEN},\n\t{SOFT_LIGHT: BlendFunction.SOFT_LIGHT},\n\t// {SRC: BlendFunction.SRC}, SET and SRC are the same\n\t{SUBTRACT: BlendFunction.SUBTRACT},\n\t{VIVID_LIGHT: BlendFunction.VIVID_LIGHT},\n];\n\nexport const BLEND_FUNCTION_MENU_OPTIONS: MenuNumericParamOptions = {\n\tmenu: {\n\t\tentries: BLEND_FUNCTION_BY_NAME.map((o, i) => {\n\t\t\treturn {\n\t\t\t\tname: Object.keys(o)[0],\n\t\t\t\tvalue: Object.values(o)[0],\n\t\t\t};\n\t\t}),\n\t},\n};\n// console.log(BLEND_FUNCTION_MENU_OPTIONS.menu?.entries);\n","import {KernelSize} from 'postprocessing';\nimport {MenuNumericParamOptions} from '../../engine/params/utils/OptionsController';\n\nexport const KERNEL_SIZES: KernelSize[] = [\n\tKernelSize.VERY_SMALL,\n\tKernelSize.SMALL,\n\tKernelSize.MEDIUM,\n\tKernelSize.LARGE,\n\tKernelSize.VERY_LARGE,\n\tKernelSize.HUGE,\n];\nconst KERNAL_NAME_BY_SIZE = {\n\t[KernelSize.VERY_SMALL]: 'VERY_SMALL',\n\t[KernelSize.SMALL]: 'SMALL',\n\t[KernelSize.MEDIUM]: 'MEDIUM',\n\t[KernelSize.LARGE]: 'LARGE',\n\t[KernelSize.VERY_LARGE]: 'VERY_LARGE',\n\t[KernelSize.HUGE]: 'HUGE',\n};\n\nexport const KERNEL_SIZE_MENU_OPTIONS: MenuNumericParamOptions = {\n\tmenu: {\n\t\tentries: KERNEL_SIZES.map((value) => {\n\t\t\treturn {\n\t\t\t\tname: KERNAL_NAME_BY_SIZE[value],\n\t\t\t\tvalue,\n\t\t\t};\n\t\t}),\n\t},\n};\n","import {Object3D, Vector3, Quaternion, Matrix4, Material, Euler} from 'three';\nimport {Ref} from '@vue/reactivity';\nimport {incrementRefSafely, ref} from '../../core/reactivity/CoreReactivity';\n\nexport enum GetObjectPropertyJsNodeInputName {\n\tposition = 'position',\n\trotation = 'rotation',\n\tquaternion = 'quaternion',\n\tscale = 'scale',\n\tmatrix = 'matrix',\n\tvisible = 'visible',\n\tcastShadow = 'castShadow',\n\treceiveShadow = 'receiveShadow',\n\tfrustumCulled = 'frustumCulled',\n\t// ptnum = 'ptnum',\n\t// id = 'id',\n\t// uuid = 'uuid',\n\t// name = 'name',\n\t// quaternion = 'quaternion',\n\t// rotation = 'rotation',\n\tup = 'up',\n\tmatrixAutoUpdate = 'matrixAutoUpdate',\n\tmaterial = 'material',\n}\nexport const OBJECT_VECTOR3_PROPERTIES = [\n\tGetObjectPropertyJsNodeInputName.position,\n\tGetObjectPropertyJsNodeInputName.scale,\n\tGetObjectPropertyJsNodeInputName.up,\n];\nexport const OBJECT_BOOLEAN_PROPERTIES = [\n\tGetObjectPropertyJsNodeInputName.visible,\n\tGetObjectPropertyJsNodeInputName.castShadow,\n\tGetObjectPropertyJsNodeInputName.receiveShadow,\n\tGetObjectPropertyJsNodeInputName.frustumCulled,\n\tGetObjectPropertyJsNodeInputName.matrixAutoUpdate,\n];\nexport const OBJECT_TRANSFORM_PROPERTIES = [\n\tGetObjectPropertyJsNodeInputName.position,\n\tGetObjectPropertyJsNodeInputName.quaternion,\n\tGetObjectPropertyJsNodeInputName.scale,\n\tGetObjectPropertyJsNodeInputName.matrix,\n];\nexport interface PropertyType {\n\tposition: Vector3;\n\trotation: Euler;\n\tquaternion: Quaternion;\n\tscale: Vector3;\n\tmatrix: Matrix4;\n\tvisible: boolean;\n\tcastShadow: boolean;\n\treceiveShadow: boolean;\n\tfrustumCulled: boolean;\n\tup: Vector3;\n\tmatrixAutoUpdate: boolean;\n\tmaterial: Material;\n}\n\nconst refByObjectUuidByPropertyName: Map<string, Map<string, Ref<number>>> = new Map();\nexport function getObjectPropertyRef<K extends keyof PropertyType>(object3D: Object3D, propertyName: K) {\n\tlet mapForObject = refByObjectUuidByPropertyName.get(object3D.uuid);\n\tif (!mapForObject) {\n\t\tmapForObject = new Map();\n\t\trefByObjectUuidByPropertyName.set(object3D.uuid, mapForObject);\n\t}\n\tlet refForProperty = mapForObject.get(propertyName);\n\tif (!refForProperty) {\n\t\trefForProperty = ref(0);\n\t\tmapForObject.set(propertyName, refForProperty);\n\t}\n\treturn refForProperty;\n}\n\nexport function touchObjectProperties(object3D: Object3D, propertyNames: Array<keyof PropertyType>) {\n\tconst map = refByObjectUuidByPropertyName.get(object3D.uuid);\n\tif (!map) {\n\t\treturn;\n\t}\n\tfor (const propertyName of propertyNames) {\n\t\tconst _ref = map.get(propertyName);\n\t\tif (_ref) {\n\t\t\tincrementRefSafely(_ref);\n\t\t}\n\t}\n}\nexport function touchObjectProperty<K extends keyof PropertyType>(object3D: Object3D, propertyName: K) {\n\tconst _ref = getObjectPropertyRef(object3D, propertyName);\n\tincrementRefSafely(_ref);\n}\n","import {Object3D} from 'three';\nimport {Ref} from '@vue/reactivity';\nimport {incrementRefSafely, ref} from '../../core/reactivity/CoreReactivity';\nimport {TimeController} from '../../engine/scene/utils/TimeController';\n\nconst refByRBDObjectUuidByPropertyName: Map<string, Map<string, Ref<number>>> = new Map();\n\nexport function getOrCreatePropertyRef(timeController: TimeController, object3D: Object3D, propertyName: string) {\n\treturn getRBDPropertyRef(timeController, object3D, propertyName) || createRBDPropertyRef(object3D, propertyName);\n}\nfunction createRBDPropertyRef(object3D: Object3D, propertyName: string) {\n\tlet mapForObject = refByRBDObjectUuidByPropertyName.get(object3D.uuid);\n\tif (!mapForObject) {\n\t\tmapForObject = new Map();\n\t\trefByRBDObjectUuidByPropertyName.set(object3D.uuid, mapForObject);\n\t}\n\tlet refForProperty = mapForObject.get(propertyName);\n\tif (!refForProperty) {\n\t\trefForProperty = ref(0);\n\t\tmapForObject.set(propertyName, refForProperty);\n\t}\n\treturn refForProperty;\n}\nfunction getRBDPropertyRef(timeController: TimeController, object3D: Object3D, propertyName: string) {\n\treturn timeController.timeUniform();\n\t// return refByRBDObjectUuidByPropertyName.get(object3D.uuid)?.get(propertyName);\n}\n\nexport function touchRBDProperties(object3D: Object3D, propertyNames: string[]) {\n\tconst map = refByRBDObjectUuidByPropertyName.get(object3D.uuid);\n\tif (!map) {\n\t\treturn;\n\t}\n\tfor (const propertyName of propertyNames) {\n\t\tconst _ref = map.get(propertyName);\n\t\tif (_ref) {\n\t\t\tincrementRefSafely(_ref);\n\t\t}\n\t}\n}\nexport function touchRBDProperty(object3D: Object3D, propertyName: string) {\n\t// const _ref = getRBDPropertyRef(object3D, propertyName);\n\t// if (!_ref) {\n\t// \treturn;\n\t// }\n\t// incrementRefSafely(_ref);\n}\n","import {CoreObjectType, ObjectContent} from '../geometry/ObjectContent';\nimport {WFCSolver} from './WFCSolver';\nimport {WFCBuilder} from './WFCBuilder';\n\nlet _nextId = 0;\nconst SOLVER_ID_KEY = '__wfcSolverId__';\nconst BUILDER_ID_KEY = '__wfcBuilderId__';\nconst WFCSolverById = new Map<number, WFCSolver>();\nconst WFCBuilderById = new Map<number, WFCBuilder>();\n\nexport function registerWFCSolver(solver: WFCSolver, object: ObjectContent<CoreObjectType>) {\n\tconst id = _nextId++;\n\tWFCSolverById.set(id, solver);\n\tobject.userData[SOLVER_ID_KEY] = id;\n}\nexport function getWFCSolver(object: ObjectContent<CoreObjectType>) {\n\tconst id = object.userData[SOLVER_ID_KEY];\n\tif (id != null) {\n\t\treturn WFCSolverById.get(id);\n\t}\n}\nexport function registerWFCBuilder(solver: WFCBuilder, object: ObjectContent<CoreObjectType>) {\n\tconst id = _nextId++;\n\tWFCBuilderById.set(id, solver);\n\tobject.userData[BUILDER_ID_KEY] = id;\n}\nexport function getWFCBuilder(object: ObjectContent<CoreObjectType>) {\n\tconst id = object.userData[BUILDER_ID_KEY];\n\tif (id != null) {\n\t\treturn WFCBuilderById.get(id);\n\t}\n}\n","import {Object3D, AnimationMixer, AnimationAction, AnimationClip, Event, EventListener} from 'three';\nimport {arraySortBy} from '../../core/ArrayUtils';\nimport {isBooleanTrue} from '../../core/Type';\nimport {\n\tNamedFunction1,\n\tNamedFunction2,\n\t// NamedFunction1,\n\t// NamedFunction2,\n\tNamedFunction3,\n\t// NamedFunction4,\n\tNamedFunction5,\n\tObjectNamedFunction0,\n} from './_Base';\n//\n//\n// MAPS\n//\n//\nconst _mixerByObject: Map<Object3D, AnimationMixer> = new Map();\nconst _actionByNameByMixer: Map<AnimationMixer, Map<string, AnimationAction>> = new Map();\n\nexport function findOrCreateAnimationMixer(object3D: Object3D) {\n\tlet animationMixer = _mixerByObject.get(object3D);\n\tif (!animationMixer) {\n\t\tanimationMixer = new AnimationMixer(object3D);\n\n\t\t_mixerByObject.set(object3D, animationMixer);\n\n\t\t// const animations = object3D.animations;\n\t\t// if (animations) {\n\t\t// \tfor (let animation of animations) {\n\t\t// \t\tfindOrCreateAnimationAction(animationMixer, animation.name, false);\n\t\t// \t}\n\t\t// }\n\t}\n\treturn animationMixer;\n}\nfunction findOrCreateAnimationAction(mixer: AnimationMixer, clipName: string, autoPlay: boolean) {\n\tlet mixerMap = _actionByNameByMixer.get(mixer);\n\tif (!mixerMap) {\n\t\tmixerMap = new Map();\n\t\t_actionByNameByMixer.set(mixer, mixerMap);\n\t}\n\tlet action = mixerMap.get(clipName);\n\tif (!action) {\n\t\tconst root = mixer.getRoot();\n\t\tconst animations = (root as Object3D).animations;\n\t\tif (!animations) {\n\t\t\tconsole.warn('no animations');\n\t\t\treturn;\n\t\t}\n\t\tconst animation = animations.find((animation) => animation.name == clipName);\n\t\tif (!animation) {\n\t\t\treturn;\n\t\t}\n\t\taction = mixer.existingAction(animation) || mixer.clipAction(animation);\n\t\tif (isBooleanTrue(autoPlay)) {\n\t\t\taction.play();\n\t\t}\n\n\t\tmixerMap.set(clipName, action);\n\t}\n\treturn action;\n}\n\n//\n//\n// FADE UTILS\n//\n//\ntype AnimationActionLoopEvent = Event & {\n\ttype: 'loop';\n} & {\n\ttarget: AnimationMixer;\n} & {\n\taction: AnimationAction;\n};\n\ntype AnimationActionEventListenerExtended = EventListener<Event, 'loop', AnimationMixer> &\n\t((e: AnimationActionLoopEvent) => void);\n\nexport function animationClipsFromAnimationMixer(animationMixer: AnimationMixer): AnimationClip[] | undefined {\n\tconst root = animationMixer.getRoot();\n\treturn (root as Object3D).animations;\n}\n\nexport function existingAnimationActionsFromAnimationMixer(animationMixer: AnimationMixer): AnimationAction[] {\n\tconst root = animationMixer.getRoot();\n\tconst animations = (root as Object3D).animations;\n\tif (!animations) {\n\t\tconsole.warn('no animations found', root);\n\t\treturn [];\n\t}\n\tconst animationActions: AnimationAction[] = [];\n\tfor (let animation of animations) {\n\t\tconst existingAnimationAction = animationMixer.existingAction(animation);\n\t\tif (existingAnimationAction) {\n\t\t\tanimationActions.push(existingAnimationAction);\n\t\t}\n\t}\n\treturn animationActions;\n}\n\nexport function getMostActiveAnimationActionFromMixer(animationMixer: AnimationMixer, except?: AnimationAction) {\n\tconst existing = existingAnimationActionsFromAnimationMixer(animationMixer);\n\tconst otherActions = existing.filter((action) => action !== except);\n\tconst actionsSortedByWeight = arraySortBy(otherActions, (action) => -action.getEffectiveWeight());\n\tconst mostActiveAnimationAction = actionsSortedByWeight[0];\n\n\treturn {\n\t\totherActions,\n\t\tmostActiveAnimationAction,\n\t};\n}\nfunction _setAnimationActionWeight(action: AnimationAction, weight: number) {\n\taction.enabled = true;\n\taction.setEffectiveTimeScale(1);\n\taction.setEffectiveWeight(weight);\n}\nfunction _crossFade(from: AnimationAction, to: AnimationAction, duration: number, warp: boolean) {\n\t_setAnimationActionWeight(to, 1);\n\t// animationActionTo.time = 0;\n\tto.syncWith(from);\n\tto.play();\n\tfrom.crossFadeTo(to, duration, warp);\n}\n\nfunction _fadeOutOtherActions(\n\tanimationActionTo: AnimationAction,\n\tduration: number,\n\twarp: boolean,\n\tstartOnFromActionEnd: boolean\n) {\n\tconst mixer = animationActionTo.getMixer();\n\tconst {otherActions, mostActiveAnimationAction} = getMostActiveAnimationActionFromMixer(mixer, animationActionTo);\n\tconst animationActionFrom = mostActiveAnimationAction;\n\tconst _fadeInCurrentAndFadeOutOtherActions = () => {\n\t\t_crossFade(animationActionFrom, animationActionTo, duration, warp);\n\n\t\tfor (let action of otherActions) {\n\t\t\taction.fadeOut(duration);\n\t\t}\n\t};\n\n\tif (otherActions.length == 0) {\n\t\t_fadeInSimple(animationActionTo, duration);\n\t} else {\n\t\tif (startOnFromActionEnd) {\n\t\t\tanimationActionTo.stop();\n\t\t\t_fadeInWhenPreviousLoopCompleted(mixer, animationActionFrom, _fadeInCurrentAndFadeOutOtherActions);\n\t\t} else {\n\t\t\t_fadeInCurrentAndFadeOutOtherActions();\n\t\t}\n\t}\n}\nfunction _fadeInSimple(animationActionTo: AnimationAction, duration: number) {\n\t_setAnimationActionWeight(animationActionTo, 1);\n\tanimationActionTo.fadeIn(duration);\n}\nfunction _fadeInWhenPreviousLoopCompleted(\n\tmixer: AnimationMixer,\n\tanimationActionFrom: AnimationAction,\n\tcallback: () => void\n) {\n\tconst onLoop: AnimationActionEventListenerExtended = ((event: AnimationActionLoopEvent) => {\n\t\tif (event.action === animationActionFrom) {\n\t\t\tmixer.removeEventListener('loop', onLoop);\n\n\t\t\tcallback();\n\t\t}\n\t}) as EventListener<Event, 'loop', AnimationMixer>;\n\tmixer.addEventListener('loop', onLoop);\n}\ntype GetAnimationAction = () => AnimationAction;\nfunction startCrossFade(actionFrom: AnimationAction, actionToGet: GetAnimationAction, duration: number, warp: boolean) {\n\t// only request animationActionTo at the last moment,\n\t// in case it is set to autoPlay,\n\t// as it would otherwise start playing before as soon as it is created,\n\t// which could be way before this function is called\n\t// const animationActionTo = this._inputValue<ActorConnectionPointType.ANIMATION_ACTION>(\n\t// \tAnimationActionCrossFadeActorNodeInputName.TO,\n\t// \tcontext\n\t// );\n\tconst actionTo = actionToGet();\n\tif (!actionTo) {\n\t\treturn;\n\t}\n\t_crossFade(actionFrom, actionTo, duration, warp);\n}\n\n//\n//\n// FUNCTIONS\n//\n//\nexport class getAnimationMixer extends ObjectNamedFunction0 {\n\tstatic override type() {\n\t\treturn 'getAnimationMixer';\n\t}\n\tfunc(object3D: Object3D): AnimationMixer {\n\t\t// TODO: we need to handle cases where a result is undefined\n\t\tconst action = findOrCreateAnimationMixer(object3D)!;\n\t\treturn action;\n\t}\n}\n\nexport class animationMixerUpdate extends ObjectNamedFunction0 {\n\tstatic override type() {\n\t\treturn 'animationMixerUpdate';\n\t}\n\tfunc(object3D: Object3D): void {\n\t\tconst mixer = _mixerByObject.get(object3D);\n\t\tif (!mixer) {\n\t\t\treturn;\n\t\t}\n\t\tconst delta = this.scene.timeController.delta();\n\t\tconst root = mixer.getRoot();\n\t\tif ((root as Object3D).traverse) {\n\t\t\t(root as Object3D).traverse((child) => {\n\t\t\t\tif (!child.matrixAutoUpdate) {\n\t\t\t\t\tchild.updateMatrix();\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t\tmixer.update(delta);\n\t}\n}\n\nexport class getAnimationAction extends NamedFunction3<[AnimationMixer, string, boolean]> {\n\tstatic override type() {\n\t\treturn 'getAnimationAction';\n\t}\n\tfunc(mixer: AnimationMixer, clipName: string, autoPlay: boolean): AnimationAction {\n\t\t// TODO: we need to handle cases where a result is undefined\n\t\tconst action = findOrCreateAnimationAction(mixer, clipName, autoPlay)!;\n\t\treturn action;\n\t}\n}\n\n//\n//\n// Play / Stop\n//\n//\nexport class animationActionPlay extends NamedFunction1<[AnimationAction]> {\n\tstatic override type() {\n\t\treturn 'animationActionPlay';\n\t}\n\tfunc(action: AnimationAction): void {\n\t\tif (!action) {\n\t\t\treturn;\n\t\t}\n\t\taction.play();\n\t}\n}\nexport class animationActionStop extends NamedFunction1<[AnimationAction]> {\n\tstatic override type() {\n\t\treturn 'animationActionStop';\n\t}\n\tfunc(action: AnimationAction): void {\n\t\tif (!action) {\n\t\t\treturn;\n\t\t}\n\t\taction.stop();\n\t}\n}\n\n//\n//\n// FadeX\n//\n//\nexport class animationActionFadeIn extends NamedFunction5<[AnimationAction, number, boolean, boolean, boolean]> {\n\tstatic override type() {\n\t\treturn 'animationActionFadeIn';\n\t}\n\tfunc(\n\t\taction: AnimationAction,\n\t\tduration: number,\n\t\tfadeOutOtherActions: boolean,\n\t\twarp: boolean,\n\t\tstartOnFromActionEnd: boolean\n\t): void {\n\t\tif (!action) {\n\t\t\tconsole.warn(`action '${action}' not found`);\n\t\t\treturn;\n\t\t}\n\t\tif (fadeOutOtherActions) {\n\t\t\t_fadeOutOtherActions(action, duration, warp, startOnFromActionEnd);\n\t\t} else {\n\t\t\t_fadeInSimple(action, duration);\n\t\t}\n\t}\n}\nexport class animationActionFadeOut extends NamedFunction2<[AnimationAction, number]> {\n\tstatic override type() {\n\t\treturn 'animationActionFadeOut';\n\t}\n\tfunc(action: AnimationAction, duration: number): void {\n\t\tif (!action) {\n\t\t\treturn;\n\t\t}\n\t\taction.fadeOut(duration);\n\t}\n}\n\nexport class animationActionCrossFade extends NamedFunction5<\n\t[AnimationAction, GetAnimationAction, number, boolean, boolean]\n> {\n\tstatic override type() {\n\t\treturn 'animationActionCrossFade';\n\t}\n\tfunc(\n\t\tactionFrom: AnimationAction,\n\t\tactionToGet: GetAnimationAction,\n\t\tduration: number,\n\t\twarp: boolean,\n\t\tstartOnFromActionEnd: boolean\n\t): void {\n\t\tif (!actionFrom) {\n\t\t\treturn;\n\t\t}\n\t\tif (startOnFromActionEnd) {\n\t\t\tconst mixer = actionFrom.getMixer();\n\t\t\tconst onLoop: AnimationActionEventListenerExtended = ((event: AnimationActionLoopEvent) => {\n\t\t\t\tif (event.action === actionFrom) {\n\t\t\t\t\tmixer.removeEventListener('loop', onLoop);\n\n\t\t\t\t\tstartCrossFade(actionFrom, actionToGet, duration, warp);\n\t\t\t\t}\n\t\t\t}) as EventListener<Event, 'loop', AnimationMixer>;\n\t\t\tmixer.addEventListener('loop', onLoop);\n\t\t} else {\n\t\t\tstartCrossFade(actionFrom, actionToGet, duration, warp);\n\t\t}\n\t}\n}\n","// import {Vector2, Vector3, Vector4} from 'three';\n// import {NamedFunction2} from './_Base';\n\nimport {Color, Vector2, Vector3, Vector4} from 'three';\nimport {_matchArrayLength} from './_ArrayUtils';\nimport {NamedFunction} from './_Base';\nimport {clamp as _clamp} from '../../core/math/_Module';\nimport {JsConnectionPointType} from '../nodes/utils/io/connections/Js';\n\nabstract class MathNamedFunction2<ARGS extends [any, any]> extends NamedFunction<ARGS, string[]> {}\nabstract class MathNamedFunction3<ARGS extends [any, any, any]> extends NamedFunction<ARGS, string[]> {}\nabstract class MathNamedFunction4<ARGS extends [any, any, any, any]> extends NamedFunction<ARGS, string[]> {}\nabstract class MathNamedFunction5<ARGS extends [any, any, any, any, any]> extends NamedFunction<ARGS, string[]> {}\nabstract class MathNamedFunction6<ARGS extends [any, any, any, any, any, any]> extends NamedFunction<ARGS, string[]> {}\nabstract class MathNamedFunction7<ARGS extends [any, any, any, any, any, any, any]> extends NamedFunction<\n\tARGS,\n\tstring[]\n> {}\nabstract class MathNamedFunction8<ARGS extends [any, any, any, any, any, any, any, any]> extends NamedFunction<\n\tARGS,\n\tstring[]\n> {}\n\ntype MathFunction1 = (x: number) => number;\ntype MathFunction2 = (x: number, arg1: number) => number;\ntype MathFunction3 = (x: number, arg1: number, arg2: number) => number;\ntype MathFunction4 = (x: number, arg1: number, arg2: number, arg3: number) => number;\ntype MathFunction5 = (x: number, arg1: number, arg2: number, arg3: number, arg4: number) => number;\n\nexport type MathVectorFunction1 = 'mathColor_1' | 'mathVector2_1' | 'mathVector3_1' | 'mathVector4_1';\nexport type MathVectorFunction2 = 'mathColor_2' | 'mathVector2_2' | 'mathVector3_2' | 'mathVector4_2';\nexport type MathVectorFunction3 = 'mathColor_3' | 'mathVector2_3' | 'mathVector3_3' | 'mathVector4_3';\nexport type MathVectorFunction3vvf = 'mathColor_3vvf' | 'mathVector2_3vvf' | 'mathVector3_3vvf' | 'mathVector4_3vvf';\nexport type MathVectorFunction4 = 'mathColor_4' | 'mathVector2_4' | 'mathVector3_4' | 'mathVector4_4';\nexport type MathVectorFunction5 = 'mathColor_5' | 'mathVector2_5' | 'mathVector3_5' | 'mathVector4_5';\nexport type MathVectorFunction =\n\t| MathVectorFunction1\n\t| MathVectorFunction2\n\t| MathVectorFunction3\n\t| MathVectorFunction3vvf\n\t| MathVectorFunction4\n\t| MathVectorFunction5;\nexport type MathFloat = 'mathFloat_1' | 'mathFloat_2' | 'mathFloat_3' | 'mathFloat_4' | 'mathFloat_5';\nexport type MathPrimArray =\n\t| 'mathPrimArray_1'\n\t| 'mathPrimArray_2'\n\t| 'mathPrimArray_3'\n\t| 'mathPrimArray_4'\n\t| 'mathPrimArray_5';\nexport type MathVectorArray =\n\t| 'mathVectorArray_1'\n\t| 'mathVectorArray_2'\n\t| 'mathVectorArray_3'\n\t| 'mathVectorArray_4'\n\t| 'mathVectorArray_5';\n\nexport type VectorFunctionName<T extends MathVectorFunction> = (inputType: JsConnectionPointType) => T | undefined;\nexport const _vectorFunctionName_1: VectorFunctionName<MathVectorFunction1> = (inputType: JsConnectionPointType) => {\n\tif (inputType == JsConnectionPointType.COLOR) {\n\t\treturn 'mathColor_1';\n\t}\n\tif (inputType == JsConnectionPointType.VECTOR2) {\n\t\treturn 'mathVector2_1';\n\t}\n\tif (inputType == JsConnectionPointType.VECTOR3) {\n\t\treturn 'mathVector3_1';\n\t}\n\tif (inputType == JsConnectionPointType.VECTOR4) {\n\t\treturn 'mathVector4_1';\n\t}\n};\nexport const _vectorFunctionName_2: VectorFunctionName<MathVectorFunction2> = (inputType: JsConnectionPointType) => {\n\tif (inputType == JsConnectionPointType.COLOR) {\n\t\treturn 'mathColor_2';\n\t}\n\tif (inputType == JsConnectionPointType.VECTOR2) {\n\t\treturn 'mathVector2_2';\n\t}\n\tif (inputType == JsConnectionPointType.VECTOR3) {\n\t\treturn 'mathVector3_2';\n\t}\n\tif (inputType == JsConnectionPointType.VECTOR4) {\n\t\treturn 'mathVector4_2';\n\t}\n};\nexport const _vectorFunctionName_3: VectorFunctionName<MathVectorFunction3> = (inputType: JsConnectionPointType) => {\n\tif (inputType == JsConnectionPointType.COLOR) {\n\t\treturn 'mathColor_3';\n\t}\n\tif (inputType == JsConnectionPointType.VECTOR2) {\n\t\treturn 'mathVector2_3';\n\t}\n\tif (inputType == JsConnectionPointType.VECTOR3) {\n\t\treturn 'mathVector3_3';\n\t}\n\tif (inputType == JsConnectionPointType.VECTOR4) {\n\t\treturn 'mathVector4_3';\n\t}\n};\nexport const _vectorFunctionName_3vvf: VectorFunctionName<MathVectorFunction3vvf> = (\n\tinputType: JsConnectionPointType\n) => {\n\tif (inputType == JsConnectionPointType.COLOR) {\n\t\treturn 'mathColor_3vvf';\n\t}\n\tif (inputType == JsConnectionPointType.VECTOR2) {\n\t\treturn 'mathVector2_3vvf';\n\t}\n\tif (inputType == JsConnectionPointType.VECTOR3) {\n\t\treturn 'mathVector3_3vvf';\n\t}\n\tif (inputType == JsConnectionPointType.VECTOR4) {\n\t\treturn 'mathVector4_3vvf';\n\t}\n};\nexport const _vectorFunctionName_4: VectorFunctionName<MathVectorFunction4> = (inputType: JsConnectionPointType) => {\n\tif (inputType == JsConnectionPointType.COLOR) {\n\t\treturn 'mathColor_4';\n\t}\n\tif (inputType == JsConnectionPointType.VECTOR2) {\n\t\treturn 'mathVector2_4';\n\t}\n\tif (inputType == JsConnectionPointType.VECTOR3) {\n\t\treturn 'mathVector3_4';\n\t}\n\tif (inputType == JsConnectionPointType.VECTOR4) {\n\t\treturn 'mathVector4_4';\n\t}\n};\nexport const _vectorFunctionName_5: VectorFunctionName<MathVectorFunction5> = (inputType: JsConnectionPointType) => {\n\tif (inputType == JsConnectionPointType.COLOR) {\n\t\treturn 'mathColor_5';\n\t}\n\tif (inputType == JsConnectionPointType.VECTOR2) {\n\t\treturn 'mathVector2_5';\n\t}\n\tif (inputType == JsConnectionPointType.VECTOR3) {\n\t\treturn 'mathVector3_5';\n\t}\n\tif (inputType == JsConnectionPointType.VECTOR4) {\n\t\treturn 'mathVector4_5';\n\t}\n};\n\nexport type MathArrayVectorElement = Color | Vector2 | Vector3 | Vector4;\ntype MathArrayVectorElementFunction1<T extends MathArrayVectorElement> = (func: MathFunction1, src: T, target: T) => T;\ntype MathArrayVectorElementFunction2<T extends MathArrayVectorElement> = (\n\tfunc: MathFunction2,\n\tsrc: T,\n\targ1: T,\n\ttarget: T\n) => T;\ntype MathArrayVectorElementFunction3<T extends MathArrayVectorElement> = (\n\tfunc: MathFunction3,\n\tsrc: T,\n\targ1: T,\n\targ2: T,\n\ttarget: T\n) => T;\ntype MathArrayVectorElementFunction3VVF<T extends MathArrayVectorElement> = (\n\tfunc: MathFunction3,\n\tsrc: T,\n\targ1: T,\n\targ2: number,\n\ttarget: T\n) => T;\ntype MathArrayVectorElementFunction4<T extends MathArrayVectorElement> = (\n\tfunc: MathFunction4,\n\tsrc: T,\n\targ1: T,\n\targ2: T,\n\targ3: T,\n\ttarget: T\n) => T;\ntype MathArrayVectorElementFunction5<T extends MathArrayVectorElement> = (\n\tfunc: MathFunction5,\n\tsrc: T,\n\targ1: T,\n\targ2: T,\n\targ3: T,\n\targ4: T,\n\ttarget: T\n) => T;\n\n// Color\nconst COLOR_FUNC_1: MathArrayVectorElementFunction1<Color> = (\n\t_func: MathFunction1,\n\tsrc: Color,\n\ttarget: Color\n): Color => {\n\ttarget.r = _func(src.r);\n\ttarget.g = _func(src.g);\n\ttarget.b = _func(src.b);\n\treturn target;\n};\nconst COLOR_FUNC_2: MathArrayVectorElementFunction2<Color> = (\n\t_func: MathFunction2,\n\tsrc: Color,\n\targ1: Color,\n\ttarget: Color\n): Color => {\n\ttarget.r = _func(src.r, arg1.r);\n\ttarget.g = _func(src.g, arg1.g);\n\ttarget.b = _func(src.b, arg1.b);\n\treturn target;\n};\nconst COLOR_FUNC_3: MathArrayVectorElementFunction3<Color> = (\n\t_func: MathFunction3,\n\tsrc: Color,\n\targ1: Color,\n\targ2: Color,\n\ttarget: Color\n): Color => {\n\ttarget.r = _func(src.r, arg1.r, arg2.r);\n\ttarget.g = _func(src.g, arg1.g, arg2.g);\n\ttarget.b = _func(src.b, arg1.b, arg2.b);\n\treturn target;\n};\nconst COLOR_FUNC_3VVF: MathArrayVectorElementFunction3VVF<Color> = (\n\t_func: MathFunction3,\n\tsrc: Color,\n\targ1: Color,\n\targ2: number,\n\ttarget: Color\n): Color => {\n\ttarget.r = _func(src.r, arg1.r, arg2);\n\ttarget.g = _func(src.g, arg1.g, arg2);\n\ttarget.b = _func(src.b, arg1.b, arg2);\n\treturn target;\n};\nconst COLOR_FUNC_4: MathArrayVectorElementFunction4<Color> = (\n\t_func: MathFunction4,\n\tsrc: Color,\n\targ1: Color,\n\targ2: Color,\n\targ3: Color,\n\ttarget: Color\n): Color => {\n\ttarget.r = _func(src.r, arg1.r, arg2.r, arg3.r);\n\ttarget.g = _func(src.g, arg1.g, arg2.g, arg3.g);\n\ttarget.b = _func(src.b, arg1.b, arg2.b, arg3.b);\n\treturn target;\n};\nconst COLOR_FUNC_5: MathArrayVectorElementFunction5<Color> = (\n\t_func: MathFunction5,\n\tsrc: Color,\n\targ1: Color,\n\targ2: Color,\n\targ3: Color,\n\targ4: Color,\n\ttarget: Color\n): Color => {\n\ttarget.r = _func(src.r, arg1.r, arg2.r, arg3.r, arg4.r);\n\ttarget.g = _func(src.g, arg1.g, arg2.g, arg3.g, arg4.g);\n\ttarget.b = _func(src.b, arg1.b, arg2.b, arg3.b, arg4.b);\n\treturn target;\n};\n// Vector2\nconst VECTOR2_FUNC_1: MathArrayVectorElementFunction1<Vector2> = (\n\t_func: MathFunction1,\n\tsrc: Vector2,\n\ttarget: Vector2\n): Vector2 => {\n\ttarget.x = _func(src.x);\n\ttarget.y = _func(src.y);\n\treturn target;\n};\nconst VECTOR2_FUNC_2: MathArrayVectorElementFunction2<Vector2> = (\n\t_func: MathFunction2,\n\tsrc: Vector2,\n\targ1: Vector2,\n\ttarget: Vector2\n): Vector2 => {\n\ttarget.x = _func(src.x, arg1.x);\n\ttarget.y = _func(src.y, arg1.y);\n\treturn target;\n};\nconst VECTOR2_FUNC_3: MathArrayVectorElementFunction3<Vector2> = (\n\t_func: MathFunction3,\n\tsrc: Vector2,\n\targ1: Vector2,\n\targ2: Vector2,\n\ttarget: Vector2\n): Vector2 => {\n\ttarget.x = _func(src.x, arg1.x, arg2.x);\n\ttarget.y = _func(src.y, arg1.y, arg2.y);\n\treturn target;\n};\nconst VECTOR2_FUNC_3VVF: MathArrayVectorElementFunction3VVF<Vector2> = (\n\t_func: MathFunction3,\n\tsrc: Vector2,\n\targ1: Vector2,\n\targ2: number,\n\ttarget: Vector2\n): Vector2 => {\n\ttarget.x = _func(src.x, arg1.x, arg2);\n\ttarget.y = _func(src.y, arg1.y, arg2);\n\treturn target;\n};\nconst VECTOR2_FUNC_4: MathArrayVectorElementFunction4<Vector2> = (\n\t_func: MathFunction4,\n\tsrc: Vector2,\n\targ1: Vector2,\n\targ2: Vector2,\n\targ3: Vector2,\n\ttarget: Vector2\n): Vector2 => {\n\ttarget.x = _func(src.x, arg1.x, arg2.x, arg3.x);\n\ttarget.y = _func(src.y, arg1.y, arg2.y, arg3.y);\n\treturn target;\n};\nconst VECTOR2_FUNC_5: MathArrayVectorElementFunction5<Vector2> = (\n\t_func: MathFunction5,\n\tsrc: Vector2,\n\targ1: Vector2,\n\targ2: Vector2,\n\targ3: Vector2,\n\targ4: Vector2,\n\ttarget: Vector2\n): Vector2 => {\n\ttarget.x = _func(src.x, arg1.x, arg2.x, arg3.x, arg4.x);\n\ttarget.y = _func(src.y, arg1.y, arg2.y, arg3.y, arg4.y);\n\treturn target;\n};\n// Vector3\nconst VECTOR3_FUNC_1: MathArrayVectorElementFunction1<Vector3> = (\n\t_func: MathFunction1,\n\tsrc: Vector3,\n\ttarget: Vector3\n): Vector3 => {\n\ttarget.x = _func(src.x);\n\ttarget.y = _func(src.y);\n\ttarget.z = _func(src.z);\n\treturn target;\n};\nconst VECTOR3_FUNC_2: MathArrayVectorElementFunction2<Vector3> = (\n\t_func: MathFunction2,\n\tsrc: Vector3,\n\targ1: Vector3,\n\ttarget: Vector3\n): Vector3 => {\n\ttarget.x = _func(src.x, arg1.x);\n\ttarget.y = _func(src.y, arg1.y);\n\ttarget.z = _func(src.z, arg1.z);\n\treturn target;\n};\nconst VECTOR3_FUNC_3: MathArrayVectorElementFunction3<Vector3> = (\n\t_func: MathFunction3,\n\tsrc: Vector3,\n\targ1: Vector3,\n\targ2: Vector3,\n\ttarget: Vector3\n): Vector3 => {\n\ttarget.x = _func(src.x, arg1.x, arg2.x);\n\ttarget.y = _func(src.y, arg1.y, arg2.y);\n\ttarget.z = _func(src.z, arg1.z, arg2.z);\n\treturn target;\n};\nconst VECTOR3_FUNC_3VVF: MathArrayVectorElementFunction3VVF<Vector3> = (\n\t_func: MathFunction3,\n\tsrc: Vector3,\n\targ1: Vector3,\n\targ2: number,\n\ttarget: Vector3\n): Vector3 => {\n\ttarget.x = _func(src.x, arg1.x, arg2);\n\ttarget.y = _func(src.y, arg1.y, arg2);\n\ttarget.z = _func(src.z, arg1.z, arg2);\n\treturn target;\n};\nconst VECTOR3_FUNC_4: MathArrayVectorElementFunction4<Vector3> = (\n\t_func: MathFunction4,\n\tsrc: Vector3,\n\targ1: Vector3,\n\targ2: Vector3,\n\targ3: Vector3,\n\ttarget: Vector3\n): Vector3 => {\n\ttarget.x = _func(src.x, arg1.x, arg2.x, arg3.x);\n\ttarget.y = _func(src.y, arg1.y, arg2.y, arg3.y);\n\ttarget.z = _func(src.z, arg1.z, arg2.z, arg3.z);\n\treturn target;\n};\nconst VECTOR3_FUNC_5: MathArrayVectorElementFunction5<Vector3> = (\n\t_func: MathFunction5,\n\tsrc: Vector3,\n\targ1: Vector3,\n\targ2: Vector3,\n\targ3: Vector3,\n\targ4: Vector3,\n\ttarget: Vector3\n): Vector3 => {\n\ttarget.x = _func(src.x, arg1.x, arg2.x, arg3.x, arg4.x);\n\ttarget.y = _func(src.y, arg1.y, arg2.y, arg3.y, arg4.y);\n\ttarget.z = _func(src.z, arg1.z, arg2.z, arg3.z, arg4.z);\n\treturn target;\n};\n// Vector4\nconst VECTOR4_FUNC_1: MathArrayVectorElementFunction1<Vector4> = (\n\t_func: MathFunction1,\n\tsrc: Vector4,\n\ttarget: Vector4\n): Vector4 => {\n\ttarget.x = _func(src.x);\n\ttarget.y = _func(src.y);\n\ttarget.z = _func(src.z);\n\ttarget.w = _func(src.w);\n\treturn target;\n};\nconst VECTOR4_FUNC_2: MathArrayVectorElementFunction2<Vector4> = (\n\t_func: MathFunction2,\n\tsrc: Vector4,\n\targ1: Vector4,\n\ttarget: Vector4\n): Vector4 => {\n\ttarget.x = _func(src.x, arg1.x);\n\ttarget.y = _func(src.y, arg1.y);\n\ttarget.z = _func(src.z, arg1.z);\n\ttarget.w = _func(src.w, arg1.w);\n\treturn target;\n};\nconst VECTOR4_FUNC_3: MathArrayVectorElementFunction3<Vector4> = (\n\t_func: MathFunction3,\n\tsrc: Vector4,\n\targ1: Vector4,\n\targ2: Vector4,\n\ttarget: Vector4\n): Vector4 => {\n\ttarget.x = _func(src.x, arg1.x, arg2.x);\n\ttarget.y = _func(src.y, arg1.y, arg2.y);\n\ttarget.z = _func(src.z, arg1.z, arg2.z);\n\ttarget.w = _func(src.w, arg1.w, arg2.w);\n\treturn target;\n};\nconst VECTOR4_FUNC_3VVF: MathArrayVectorElementFunction3VVF<Vector4> = (\n\t_func: MathFunction3,\n\tsrc: Vector4,\n\targ1: Vector4,\n\targ2: number,\n\ttarget: Vector4\n): Vector4 => {\n\ttarget.x = _func(src.x, arg1.x, arg2);\n\ttarget.y = _func(src.y, arg1.y, arg2);\n\ttarget.z = _func(src.z, arg1.z, arg2);\n\ttarget.w = _func(src.w, arg1.w, arg2);\n\treturn target;\n};\nconst VECTOR4_FUNC_4: MathArrayVectorElementFunction4<Vector4> = (\n\t_func: MathFunction4,\n\tsrc: Vector4,\n\targ1: Vector4,\n\targ2: Vector4,\n\targ3: Vector4,\n\ttarget: Vector4\n): Vector4 => {\n\ttarget.x = _func(src.x, arg1.x, arg2.x, arg3.x);\n\ttarget.y = _func(src.y, arg1.y, arg2.y, arg3.y);\n\ttarget.z = _func(src.z, arg1.z, arg2.z, arg3.z);\n\ttarget.w = _func(src.w, arg1.w, arg2.w, arg3.w);\n\treturn target;\n};\nconst VECTOR4_FUNC_5: MathArrayVectorElementFunction5<Vector4> = (\n\t_func: MathFunction5,\n\tsrc: Vector4,\n\targ1: Vector4,\n\targ2: Vector4,\n\targ3: Vector4,\n\targ4: Vector4,\n\ttarget: Vector4\n): Vector4 => {\n\ttarget.x = _func(src.x, arg1.x, arg2.x, arg3.x, arg4.x);\n\ttarget.y = _func(src.y, arg1.y, arg2.y, arg3.y, arg4.y);\n\ttarget.z = _func(src.z, arg1.z, arg2.z, arg3.z, arg4.z);\n\ttarget.w = _func(src.w, arg1.w, arg2.w, arg3.w, arg4.w);\n\treturn target;\n};\n\n// float\nexport class mathFloat_1 extends MathNamedFunction2<[MathFunction1, number]> {\n\tstatic override type() {\n\t\treturn 'mathFloat_1';\n\t}\n\tfunc(_func: MathFunction1, value: number): number {\n\t\treturn _func(value);\n\t}\n}\nexport class mathFloat_2 extends MathNamedFunction3<[MathFunction2, number, number]> {\n\tstatic override type() {\n\t\treturn 'mathFloat_2';\n\t}\n\tfunc(_func: MathFunction2, value: number, arg1: number): number {\n\t\treturn _func(value, arg1);\n\t}\n}\nexport class mathFloat_3 extends MathNamedFunction4<[MathFunction3, number, number, number]> {\n\tstatic override type() {\n\t\treturn 'mathFloat_3';\n\t}\n\tfunc(_func: MathFunction3, value: number, arg1: number, arg2: number): number {\n\t\treturn _func(value, arg1, arg2);\n\t}\n}\nexport class mathFloat_4 extends MathNamedFunction5<[MathFunction4, number, number, number, number]> {\n\tstatic override type() {\n\t\treturn 'mathFloat_4';\n\t}\n\tfunc(_func: MathFunction4, value: number, arg1: number, arg2: number, arg3: number): number {\n\t\treturn _func(value, arg1, arg2, arg3);\n\t}\n}\nexport class mathFloat_5 extends MathNamedFunction6<[MathFunction5, number, number, number, number, number]> {\n\tstatic override type() {\n\t\treturn 'mathFloat_5';\n\t}\n\tfunc(_func: MathFunction5, value: number, arg1: number, arg2: number, arg3: number, arg4: number): number {\n\t\treturn _func(value, arg1, arg2, arg3, arg4);\n\t}\n}\n// Color\nexport class mathColor_1 extends MathNamedFunction3<[MathFunction1, Color, Color]> {\n\tstatic override type() {\n\t\treturn 'mathColor_1';\n\t}\n\tfunc = COLOR_FUNC_1;\n}\nexport class mathColor_2 extends MathNamedFunction4<[MathFunction2, Color, Color, Color]> {\n\tstatic override type() {\n\t\treturn 'mathColor_2';\n\t}\n\tfunc = COLOR_FUNC_2;\n}\nexport class mathColor_3 extends MathNamedFunction5<[MathFunction2, Color, Color, Color, Color]> {\n\tstatic override type() {\n\t\treturn 'mathColor_3';\n\t}\n\tfunc = COLOR_FUNC_3;\n}\nexport class mathColor_3vvf extends MathNamedFunction5<[MathFunction2, Color, Color, number, Color]> {\n\tstatic override type() {\n\t\treturn 'mathColor_3vvf';\n\t}\n\tfunc = COLOR_FUNC_3VVF;\n}\nexport class mathColor_4 extends MathNamedFunction6<[MathFunction2, Color, Color, Color, Color, Color]> {\n\tstatic override type() {\n\t\treturn 'mathColor_4';\n\t}\n\tfunc = COLOR_FUNC_4;\n}\nexport class mathColor_5 extends MathNamedFunction7<[MathFunction2, Color, Color, Color, Color, Color, Color]> {\n\tstatic override type() {\n\t\treturn 'mathColor_5';\n\t}\n\tfunc = COLOR_FUNC_5;\n}\n// Vector2\nexport class mathVector2_1 extends MathNamedFunction3<[MathFunction1, Vector2, Vector2]> {\n\tstatic override type() {\n\t\treturn 'mathVector2_1';\n\t}\n\tfunc = VECTOR2_FUNC_1;\n}\nexport class mathVector2_2 extends MathNamedFunction4<[MathFunction1, Vector2, Vector2, Vector2]> {\n\tstatic override type() {\n\t\treturn 'mathVector2_2';\n\t}\n\tfunc = VECTOR2_FUNC_2;\n}\nexport class mathVector2_3 extends MathNamedFunction5<[MathFunction1, Vector2, Vector2, Vector2, Vector2]> {\n\tstatic override type() {\n\t\treturn 'mathVector2_3';\n\t}\n\tfunc = VECTOR2_FUNC_3;\n}\nexport class mathVector2_3vvf extends MathNamedFunction5<[MathFunction1, Vector2, Vector2, number, Vector2]> {\n\tstatic override type() {\n\t\treturn 'mathVector2_3vvf';\n\t}\n\tfunc = VECTOR2_FUNC_3VVF;\n}\nexport class mathVector2_4 extends MathNamedFunction6<[MathFunction1, Vector2, Vector2, Vector2, Vector2, Vector2]> {\n\tstatic override type() {\n\t\treturn 'mathVector2_4';\n\t}\n\tfunc = VECTOR2_FUNC_4;\n}\nexport class mathVector2_5 extends MathNamedFunction7<\n\t[MathFunction1, Vector2, Vector2, Vector2, Vector2, Vector2, Vector2]\n> {\n\tstatic override type() {\n\t\treturn 'mathVector2_5';\n\t}\n\tfunc = VECTOR2_FUNC_5;\n}\n// Vector3\nexport class mathVector3_1 extends MathNamedFunction3<[MathFunction1, Vector3, Vector3]> {\n\tstatic override type() {\n\t\treturn 'mathVector3_1';\n\t}\n\tfunc = VECTOR3_FUNC_1;\n}\nexport class mathVector3_2 extends MathNamedFunction4<[MathFunction1, Vector3, Vector3, Vector3]> {\n\tstatic override type() {\n\t\treturn 'mathVector3_2';\n\t}\n\tfunc = VECTOR3_FUNC_2;\n}\nexport class mathVector3_3 extends MathNamedFunction5<[MathFunction1, Vector3, Vector3, Vector3, Vector3]> {\n\tstatic override type() {\n\t\treturn 'mathVector3_3';\n\t}\n\tfunc = VECTOR3_FUNC_3;\n}\nexport class mathVector3_3vvf extends MathNamedFunction5<[MathFunction1, Vector3, Vector3, number, Vector3]> {\n\tstatic override type() {\n\t\treturn 'mathVector3_3vvf';\n\t}\n\tfunc = VECTOR3_FUNC_3VVF;\n}\nexport class mathVector3_4 extends MathNamedFunction6<[MathFunction1, Vector3, Vector3, Vector3, Vector3, Vector3]> {\n\tstatic override type() {\n\t\treturn 'mathVector3_4';\n\t}\n\tfunc = VECTOR3_FUNC_4;\n}\nexport class mathVector3_5 extends MathNamedFunction7<\n\t[MathFunction1, Vector3, Vector3, Vector3, Vector3, Vector3, Vector3]\n> {\n\tstatic override type() {\n\t\treturn 'mathVector3_5';\n\t}\n\tfunc = VECTOR3_FUNC_5;\n}\n// Vector4\nexport class mathVector4_1 extends MathNamedFunction3<[MathFunction1, Vector4, Vector4]> {\n\tstatic override type() {\n\t\treturn 'mathVector4_1';\n\t}\n\tfunc = VECTOR4_FUNC_1;\n}\nexport class mathVector4_2 extends MathNamedFunction4<[MathFunction1, Vector4, Vector4, Vector4]> {\n\tstatic override type() {\n\t\treturn 'mathVector4_2';\n\t}\n\tfunc = VECTOR4_FUNC_2;\n}\nexport class mathVector4_3 extends MathNamedFunction5<[MathFunction1, Vector4, Vector4, Vector4, Vector4]> {\n\tstatic override type() {\n\t\treturn 'mathVector4_3';\n\t}\n\tfunc = VECTOR4_FUNC_3;\n}\nexport class mathVector4_3vvf extends MathNamedFunction5<[MathFunction1, Vector4, Vector4, number, Vector4]> {\n\tstatic override type() {\n\t\treturn 'mathVector4_3vvf';\n\t}\n\tfunc = VECTOR4_FUNC_3VVF;\n}\nexport class mathVector4_4 extends MathNamedFunction6<[MathFunction1, Vector4, Vector4, Vector4, Vector4, Vector4]> {\n\tstatic override type() {\n\t\treturn 'mathVector4_4';\n\t}\n\tfunc = VECTOR4_FUNC_4;\n}\nexport class mathVector4_5 extends MathNamedFunction7<\n\t[MathFunction1, Vector4, Vector4, Vector4, Vector4, Vector4, Vector4]\n> {\n\tstatic override type() {\n\t\treturn 'mathVector4_5';\n\t}\n\tfunc = VECTOR4_FUNC_5;\n}\n\n// Prim Array\nexport class mathPrimArray_1 extends MathNamedFunction3<[MathFunction1, number[], number[]]> {\n\tstatic override type() {\n\t\treturn 'mathPrimArray_1';\n\t}\n\tfunc(_func: MathFunction1, srcElements: number[], targetElements: number[]): number[] {\n\t\t_matchArrayLength(srcElements, targetElements, () => srcElements[0] || 0);\n\t\tlet i = 0;\n\t\tfor (let src of srcElements) {\n\t\t\ttargetElements[i] = _func(src);\n\t\t\ti++;\n\t\t}\n\t\treturn targetElements;\n\t}\n}\nexport class mathPrimArray_2 extends MathNamedFunction4<[MathFunction2, number[], number, number[]]> {\n\tstatic override type() {\n\t\treturn 'mathPrimArray_2';\n\t}\n\tfunc(_func: MathFunction2, srcElements: number[], arg1: number, targetElements: number[]): number[] {\n\t\t_matchArrayLength(srcElements, targetElements, () => srcElements[0] || 0);\n\t\tlet i = 0;\n\t\tfor (let src of srcElements) {\n\t\t\ttargetElements[i] = _func(src, arg1);\n\t\t\ti++;\n\t\t}\n\t\treturn targetElements;\n\t}\n}\nexport class mathPrimArray_3 extends MathNamedFunction5<[MathFunction3, number[], number, number, number[]]> {\n\tstatic override type() {\n\t\treturn 'mathPrimArray_3';\n\t}\n\tfunc(_func: MathFunction3, srcElements: number[], arg1: number, arg2: number, targetElements: number[]): number[] {\n\t\t_matchArrayLength(srcElements, targetElements, () => srcElements[0] || 0);\n\t\tlet i = 0;\n\t\tfor (let src of srcElements) {\n\t\t\ttargetElements[i] = _func(src, arg1, arg2);\n\t\t\ti++;\n\t\t}\n\t\treturn targetElements;\n\t}\n}\nexport class mathPrimArray_4 extends MathNamedFunction6<[MathFunction4, number[], number, number, number, number[]]> {\n\tstatic override type() {\n\t\treturn 'mathPrimArray_4';\n\t}\n\tfunc(\n\t\t_func: MathFunction4,\n\t\tsrcElements: number[],\n\t\targ1: number,\n\t\targ2: number,\n\t\targ3: number,\n\t\ttargetElements: number[]\n\t): number[] {\n\t\t_matchArrayLength(srcElements, targetElements, () => srcElements[0] || 0);\n\t\tlet i = 0;\n\t\tfor (let src of srcElements) {\n\t\t\ttargetElements[i] = _func(src, arg1, arg2, arg3);\n\t\t\ti++;\n\t\t}\n\t\treturn targetElements;\n\t}\n}\nexport class mathPrimArray_5 extends MathNamedFunction7<\n\t[MathFunction5, number[], number, number, number, number, number[]]\n> {\n\tstatic override type() {\n\t\treturn 'mathPrimArray_5';\n\t}\n\tfunc(\n\t\t_func: MathFunction5,\n\t\tsrcElements: number[],\n\t\targ1: number,\n\t\targ2: number,\n\t\targ3: number,\n\t\targ4: number,\n\t\ttargetElements: number[]\n\t): number[] {\n\t\t_matchArrayLength(srcElements, targetElements, () => srcElements[0] || 0);\n\t\tlet i = 0;\n\t\tfor (let src of srcElements) {\n\t\t\ttargetElements[i] = _func(src, arg1, arg2, arg3, arg4);\n\t\t\ti++;\n\t\t}\n\t\treturn targetElements;\n\t}\n}\n// Vector Array\nexport class mathVectorArray_1<T extends MathArrayVectorElement> extends MathNamedFunction4<\n\t[MathFunction1, MathArrayVectorElementFunction1<T>, T[], T[]]\n> {\n\tstatic override type() {\n\t\treturn 'mathVectorArray_1';\n\t}\n\tfunc(\n\t\t_func: MathFunction1,\n\t\tvectorFunc: MathArrayVectorElementFunction1<T>,\n\t\tsrcElements: T[],\n\t\ttargetElements: T[]\n\t): T[] {\n\t\t_matchArrayLength(srcElements, targetElements, () => srcElements[0].clone());\n\t\tlet i = 0;\n\t\tfor (let src of srcElements) {\n\t\t\tconst target = targetElements[i];\n\t\t\tvectorFunc(_func, src, target);\n\t\t\ti++;\n\t\t}\n\t\treturn targetElements;\n\t}\n}\nexport class mathVectorArray_2<T extends MathArrayVectorElement> extends MathNamedFunction5<\n\t[MathFunction2, MathArrayVectorElementFunction2<T>, T[], T, T[]]\n> {\n\tstatic override type() {\n\t\treturn 'mathVectorArray_2';\n\t}\n\tfunc(\n\t\t_func: MathFunction2,\n\t\tvectorFunc: MathArrayVectorElementFunction2<T>,\n\t\tsrcElements: T[],\n\t\targ1: T,\n\t\ttargetElements: T[]\n\t): T[] {\n\t\t_matchArrayLength(srcElements, targetElements, () => srcElements[0].clone());\n\t\tlet i = 0;\n\t\tfor (let src of srcElements) {\n\t\t\tconst target = targetElements[i];\n\t\t\tvectorFunc(_func, src, arg1, target);\n\t\t\ti++;\n\t\t}\n\t\treturn targetElements;\n\t}\n}\nexport class mathVectorArray_3<T extends MathArrayVectorElement> extends MathNamedFunction6<\n\t[MathFunction3, MathArrayVectorElementFunction3<T>, T[], T, T, T[]]\n> {\n\tstatic override type() {\n\t\treturn 'mathVectorArray_3';\n\t}\n\tfunc(\n\t\t_func: MathFunction3,\n\t\tvectorFunc: MathArrayVectorElementFunction3<T>,\n\t\tsrcElements: T[],\n\t\targ1: T,\n\t\targ2: T,\n\t\ttargetElements: T[]\n\t): T[] {\n\t\t_matchArrayLength(srcElements, targetElements, () => srcElements[0].clone());\n\t\tlet i = 0;\n\t\tfor (let src of srcElements) {\n\t\t\tconst target = targetElements[i];\n\t\t\tvectorFunc(_func, src, arg1, arg2, target);\n\t\t\ti++;\n\t\t}\n\t\treturn targetElements;\n\t}\n}\nexport class mathVectorArray_4<T extends MathArrayVectorElement> extends MathNamedFunction7<\n\t[MathFunction4, MathArrayVectorElementFunction4<T>, T[], T, T, T, T[]]\n> {\n\tstatic override type() {\n\t\treturn 'mathVectorArray_4';\n\t}\n\tfunc(\n\t\t_func: MathFunction4,\n\t\tvectorFunc: MathArrayVectorElementFunction4<T>,\n\t\tsrcElements: T[],\n\t\targ1: T,\n\t\targ2: T,\n\t\targ3: T,\n\t\ttargetElements: T[]\n\t): T[] {\n\t\t_matchArrayLength(srcElements, targetElements, () => srcElements[0].clone());\n\t\tlet i = 0;\n\t\tfor (let src of srcElements) {\n\t\t\tconst target = targetElements[i];\n\t\t\tvectorFunc(_func, src, arg1, arg2, arg3, target);\n\t\t\ti++;\n\t\t}\n\t\treturn targetElements;\n\t}\n}\n\nexport class mathVectorArray_5<T extends MathArrayVectorElement> extends MathNamedFunction8<\n\t[MathFunction5, MathArrayVectorElementFunction5<T>, T[], T, T, T, T, T[]]\n> {\n\tstatic override type() {\n\t\treturn 'mathVectorArray_5';\n\t}\n\tfunc(\n\t\t_func: MathFunction5,\n\t\tvectorFunc: MathArrayVectorElementFunction5<T>,\n\t\tsrcElements: T[],\n\t\targ1: T,\n\t\targ2: T,\n\t\targ3: T,\n\t\targ4: T,\n\t\ttargetElements: T[]\n\t): T[] {\n\t\t_matchArrayLength(srcElements, targetElements, () => srcElements[0].clone());\n\t\tlet i = 0;\n\t\tfor (let src of srcElements) {\n\t\t\tconst target = targetElements[i];\n\t\t\tvectorFunc(_func, src, arg1, arg2, arg3, arg4, target);\n\t\t\ti++;\n\t\t}\n\t\treturn targetElements;\n\t}\n}\n","import {Vector2, Vector3} from 'three';\nimport {PolyDictionary} from '../../types/GlobalTypes';\nimport {JsConnectionPointType} from '../nodes/utils/io/connections/Js';\nimport {clamp as _clamp} from '../../core/math/_Module';\n\nconst RGB = ['r', 'g', 'b'];\nconst XY = ['x', 'y'];\nconst XYZ = ['x', 'y', 'z'];\nconst XYZW = ['x', 'y', 'z', 'w'];\nconst COMPONENT_BY_JS_TYPE: PolyDictionary<string[]> = {\n\t[JsConnectionPointType.COLOR]: RGB,\n\t[JsConnectionPointType.VECTOR2]: XY,\n\t[JsConnectionPointType.VECTOR3]: XYZ,\n\t[JsConnectionPointType.VECTOR4]: XYZW,\n};\nexport function componentsForType(type: JsConnectionPointType) {\n\treturn COMPONENT_BY_JS_TYPE[type] || [];\n}\n\n//\n//\n//\n//\n//\nexport function _v2Function(src: Vector2, target: Vector2, _func: (x: number) => number): Vector2 {\n\ttarget.x = _func(src.x);\n\ttarget.y = _func(src.y);\n\treturn target;\n}\nexport function _v3Function(src: Vector3, target: Vector3, _func: (x: number) => number): Vector3 {\n\ttarget.x = _func(src.x);\n\ttarget.y = _func(src.y);\n\ttarget.z = _func(src.z);\n\treturn target;\n}\nexport function absV2(src: Vector2, target: Vector2): Vector2 {\n\treturn _v2Function(src, target, Math.abs);\n}\nexport function absV3(src: Vector3, target: Vector3): Vector3 {\n\treturn _v3Function(src, target, Math.abs);\n}\nexport function maxV3Components(src: Vector3): number {\n\treturn Math.max(src.x, Math.max(src.y, src.z));\n}\nexport function vector3Clamp(src: Vector3, min: Vector3, max: Vector3, target: Vector3): Vector3 {\n\ttarget.x = _clamp(src.x, min.x, max.x);\n\ttarget.y = _clamp(src.y, min.y, max.y);\n\ttarget.z = _clamp(src.z, min.z, max.z);\n\treturn target;\n}\nexport function maxV3Component(src: Vector3, target: Vector3, value: number): Vector3 {\n\ttarget.x = Math.max(src.x, value);\n\ttarget.y = Math.max(src.y, value);\n\ttarget.z = Math.max(src.z, value);\n\treturn target;\n}\nexport function vector2MaxScalar(src: Vector2, scalar: number, target: Vector2) {\n\ttarget.x = Math.max(src.x, scalar);\n\ttarget.y = Math.max(src.y, scalar);\n\treturn target;\n}\n\nexport function vector2Dot(src: Vector2) {\n\treturn src.dot(src);\n}\n","/**\n * Adds a delay to animation properties\n *\n *\n */\nimport {TypedAnimNode} from './_Base';\nimport {TimelineBuilder} from '../../../core/animation/TimelineBuilder';\n\nimport {NodeParamsConfig, ParamConfig} from '../utils/params/ParamsConfig';\nclass DelayAnimParamsConfig extends NodeParamsConfig {\n\t/** @param delay */\n\tdelay = ParamConfig.FLOAT(1);\n}\nconst ParamsConfig = new DelayAnimParamsConfig();\n\nexport class DelayAnimNode extends TypedAnimNode<DelayAnimParamsConfig> {\n\toverride readonly paramsConfig = ParamsConfig;\n\tstatic override type() {\n\t\treturn 'delay';\n\t}\n\n\toverride initializeNode() {\n\t\tthis.io.inputs.setCount(0, 1);\n\t}\n\n\toverride cook(input_contents: TimelineBuilder[]) {\n\t\tconst timeline_builder = input_contents[0] || new TimelineBuilder();\n\n\t\ttimeline_builder.setDelay(this.pv.delay);\n\n\t\tthis.setTimelineBuilder(timeline_builder);\n\t}\n}\n","/**\n * Sets the duration of an animation\n *\n *\n */\nimport {TypedAnimNode} from './_Base';\nimport {TimelineBuilder} from '../../../core/animation/TimelineBuilder';\n\nimport {NodeParamsConfig, ParamConfig} from '../utils/params/ParamsConfig';\nclass DurationAnimParamsConfig extends NodeParamsConfig {\n\t/** @param duration */\n\tduration = ParamConfig.FLOAT(1, {\n\t\trange: [0, 10],\n\t\trangeLocked: [true, false],\n\t});\n}\nconst ParamsConfig = new DurationAnimParamsConfig();\n\nexport class DurationAnimNode extends TypedAnimNode<DurationAnimParamsConfig> {\n\toverride readonly paramsConfig = ParamsConfig;\n\tstatic override type() {\n\t\treturn 'duration';\n\t}\n\n\toverride initializeNode() {\n\t\tthis.io.inputs.setCount(0, 1);\n\t}\n\n\toverride cook(input_contents: TimelineBuilder[]) {\n\t\tconst timeline_builder = input_contents[0] || new TimelineBuilder();\n\n\t\ttimeline_builder.setDuration(this.pv.duration);\n\n\t\tthis.setTimelineBuilder(timeline_builder);\n\t}\n}\n","/**\n * Sets easing of animation property\n *\n *\n */\nimport {TypedAnimNode} from './_Base';\nimport {TimelineBuilder} from '../../../core/animation/TimelineBuilder';\nimport {AnimNodeEasing, EASINGS, InOutMode, IN_OUT_MODES} from '../../../core/animation/Constant';\n\nimport {NodeParamsConfig, ParamConfig} from '../utils/params/ParamsConfig';\nimport {AnimType} from '../../poly/registers/nodes/types/Anim';\nclass EasingAnimParamsConfig extends NodeParamsConfig {\n\t/** @param name of easing */\n\tname = ParamConfig.INTEGER(EASINGS.indexOf(AnimNodeEasing.POWER4), {\n\t\tmenu: {\n\t\t\tentries: EASINGS.map((name, value) => {\n\t\t\t\treturn {name, value};\n\t\t\t}),\n\t\t},\n\t});\n\t/** @param defines if the easing is 'in', 'out' or 'in-out' */\n\tinOut = ParamConfig.INTEGER(IN_OUT_MODES.indexOf(InOutMode.OUT), {\n\t\tmenu: {\n\t\t\tentries: IN_OUT_MODES.map((name, value) => {\n\t\t\t\treturn {name, value};\n\t\t\t}),\n\t\t},\n\t});\n}\nconst ParamsConfig = new EasingAnimParamsConfig();\n\nexport class EasingAnimNode extends TypedAnimNode<EasingAnimParamsConfig> {\n\toverride readonly paramsConfig = ParamsConfig;\n\tstatic override type() {\n\t\treturn AnimType.EASING;\n\t}\n\n\toverride initializeNode() {\n\t\tthis.io.inputs.setCount(0, 1);\n\t}\n\tsetEasing(mode: AnimNodeEasing) {\n\t\tthis.p.name.set(EASINGS.indexOf(mode));\n\t}\n\tsetInOut(inOut: InOutMode) {\n\t\tthis.p.inOut.set(IN_OUT_MODES.indexOf(inOut));\n\t}\n\n\tstatic easingFullName(node: EasingAnimNode) {\n\t\tconst easing = EASINGS[node.pv.name];\n\t\tif (easing == AnimNodeEasing.NONE) {\n\t\t\treturn easing;\n\t\t}\n\t\tconst in_out = IN_OUT_MODES[node.pv.inOut];\n\t\tconst easing_full_name = `${easing}.${in_out}`;\n\t\treturn easing_full_name;\n\t}\n\n\toverride cook(input_contents: TimelineBuilder[]) {\n\t\tconst timeline_builder = input_contents[0] || new TimelineBuilder();\n\n\t\tconst easingFullName = EasingAnimNode.easingFullName(this);\n\t\ttimeline_builder.setEasing(easingFullName);\n\n\t\tthis.setTimelineBuilder(timeline_builder);\n\t}\n}\n","/**\n * Merge animation properties\n *\n * @remarks\n * Animation properties can be set to either run at the same time, or one after the other.\n */\nimport {TypedAnimNode} from './_Base';\nimport {TimelineBuilder} from '../../../core/animation/TimelineBuilder';\nimport {TypeAssert} from '../../poly/Assert';\nimport {AnimationPosition, AnimationPositionMode, AnimationPositionRelativeTo} from '../../../core/animation/Position';\nimport {NodeParamsConfig, ParamConfig} from '../utils/params/ParamsConfig';\nimport {isBooleanTrue} from '../../../core/BooleanValue';\nimport {BaseNodeType} from '../_Base';\nimport {NodeEvent} from '../../poly/NodeEvent';\n\nenum MergeMode {\n\tALL_TOGETHER = 'play all together',\n\tONE_AT_A_TIME = 'play one at a time',\n}\nexport const EASING_ANIM_MERGE_MODES: MergeMode[] = [MergeMode.ALL_TOGETHER, MergeMode.ONE_AT_A_TIME];\nconst DEFAULT_INPUTS_COUNT = 4;\nclass MergeAnimParamsConfig extends NodeParamsConfig {\n\t/** @param mode (at the same time or one after the other) */\n\tmode = ParamConfig.INTEGER(0, {\n\t\tmenu: {\n\t\t\tentries: EASING_ANIM_MERGE_MODES.map((name, value) => {\n\t\t\t\treturn {name, value};\n\t\t\t}),\n\t\t},\n\t});\n\t/** @param offset if run one after the other */\n\toffset = ParamConfig.FLOAT(0, {\n\t\trange: [-1, 1],\n\t});\n\t/** @param override the position */\n\toverridePositions = ParamConfig.BOOLEAN(0);\n\t/** @param number of inputs that this node can merge animations from */\n\tinputsCount = ParamConfig.INTEGER(DEFAULT_INPUTS_COUNT, {\n\t\trange: [1, 32],\n\t\trangeLocked: [true, false],\n\t\tcallback: (node: BaseNodeType) => {\n\t\t\tMergeAnimNode.PARAM_CALLBACK_setInputsCount(node as MergeAnimNode);\n\t\t},\n\t});\n}\nconst ParamsConfig = new MergeAnimParamsConfig();\n\nexport class MergeAnimNode extends TypedAnimNode<MergeAnimParamsConfig> {\n\toverride readonly paramsConfig = ParamsConfig;\n\tstatic override type() {\n\t\treturn 'merge';\n\t}\n\n\toverride initializeNode() {\n\t\tthis.io.inputs.setCount(0, 4);\n\n\t\tthis.params.onParamsCreated('pdateInputsEvaluation', () => {\n\t\t\tthis._callbackUpdateInputsCount();\n\t\t});\n\t}\n\n\toverride cook(inputContents: TimelineBuilder[]) {\n\t\tconst mergedTimelineBuilder = new TimelineBuilder();\n\n\t\tlet i = 0;\n\t\tfor (const timelineBuilder of inputContents) {\n\t\t\tif (timelineBuilder) {\n\t\t\t\tif (i > 0) {\n\t\t\t\t\tthis._updateTimelineBuilder(timelineBuilder);\n\t\t\t\t}\n\n\t\t\t\tmergedTimelineBuilder.addTimelineBuilder(timelineBuilder);\n\t\t\t\ti++;\n\t\t\t}\n\t\t}\n\n\t\tthis.setTimelineBuilder(mergedTimelineBuilder);\n\t}\n\n\tprivate _updateTimelineBuilder(timelineBuilder: TimelineBuilder) {\n\t\tconst mode = EASING_ANIM_MERGE_MODES[this.pv.mode];\n\t\tswitch (mode) {\n\t\t\tcase MergeMode.ALL_TOGETHER:\n\t\t\t\treturn this._setPlayAllTogether(timelineBuilder);\n\t\t\tcase MergeMode.ONE_AT_A_TIME:\n\t\t\t\treturn this._setPlayOneAtATime(timelineBuilder);\n\t\t}\n\t\tTypeAssert.unreachable(mode);\n\t}\n\tprivate _setPlayAllTogether(timelineBuilder: TimelineBuilder) {\n\t\tlet position = timelineBuilder.position();\n\t\tif (!position || isBooleanTrue(this.pv.overridePositions)) {\n\t\t\tposition = new AnimationPosition();\n\t\t\tposition.setMode(AnimationPositionMode.RELATIVE);\n\t\t\tposition.setRelativeTo(AnimationPositionRelativeTo.START);\n\t\t\tposition.setOffset(this.pv.offset);\n\t\t\ttimelineBuilder.setPosition(position);\n\t\t}\n\t}\n\tprivate _setPlayOneAtATime(timelineBuilder: TimelineBuilder) {\n\t\tlet position = timelineBuilder.position();\n\t\tif (!position || isBooleanTrue(this.pv.overridePositions)) {\n\t\t\tposition = new AnimationPosition();\n\t\t\tposition.setMode(AnimationPositionMode.RELATIVE);\n\t\t\tposition.setRelativeTo(AnimationPositionRelativeTo.END);\n\t\t\tposition.setOffset(this.pv.offset);\n\t\t\ttimelineBuilder.setPosition(position);\n\t\t}\n\t}\n\tprivate _callbackUpdateInputsCount() {\n\t\tthis.io.inputs.setCount(1, this.pv.inputsCount);\n\t\tthis.emit(NodeEvent.INPUTS_UPDATED);\n\t}\n\tstatic PARAM_CALLBACK_setInputsCount(node: MergeAnimNode) {\n\t\tnode._callbackUpdateInputsCount();\n\t}\n}\n","/**\n * Sets how the animation is applied\n *\n * @remarks\n * The animation can be set to:\n *\n * - set: the animation override the current value\n * - add: the animation adds to the current value\n * - subtract: the animation subtracts from the current value\n *\n */\nimport {TypedAnimNode} from './_Base';\nimport {TimelineBuilder} from '../../../core/animation/TimelineBuilder';\nimport {NodeParamsConfig, ParamConfig} from '../utils/params/ParamsConfig';\nimport {OPERATIONS} from '../../../core/animation/vars/AnimBuilderTypes';\nclass OperationAnimParamsConfig extends NodeParamsConfig {\n\t/** @param sets the operation (set, add or subtract) */\n\toperation = ParamConfig.INTEGER(0, {\n\t\tmenu: {\n\t\t\tentries: OPERATIONS.map((name, value) => {\n\t\t\t\treturn {value, name};\n\t\t\t}),\n\t\t},\n\t});\n}\nconst ParamsConfig = new OperationAnimParamsConfig();\n\nexport class OperationAnimNode extends TypedAnimNode<OperationAnimParamsConfig> {\n\toverride paramsConfig = ParamsConfig;\n\tstatic override type() {\n\t\treturn 'operation';\n\t}\n\n\toverride initializeNode() {\n\t\tthis.io.inputs.setCount(0, 1);\n\t}\n\n\toverride cook(input_contents: TimelineBuilder[]) {\n\t\tconst timeline_builder = input_contents[0] || new TimelineBuilder();\n\n\t\ttimeline_builder.setOperation(OPERATIONS[this.pv.operation]);\n\n\t\tthis.setTimelineBuilder(timeline_builder);\n\t}\n}\n","/**\n * Sets how the position of an animation\n *\n *\n */\nimport {TypedAnimNode} from './_Base';\nimport {TimelineBuilder} from '../../../core/animation/TimelineBuilder';\nimport {\n\tAnimationPosition,\n\tAnimationPositionMode,\n\tAnimationPositionRelativeTo,\n\tANIMATION_POSITION_MODES,\n\tANIMATION_POSITION_RELATIVE_TOS,\n} from '../../../core/animation/Position';\n\nimport {NodeParamsConfig, ParamConfig} from '../utils/params/ParamsConfig';\nclass PositionAnimParamsConfig extends NodeParamsConfig {\n\t/** @param sets the mode of the position. It can either be relative or absolute */\n\tmode = ParamConfig.INTEGER(0, {\n\t\tmenu: {\n\t\t\tentries: ANIMATION_POSITION_MODES.map((name, value) => {\n\t\t\t\treturn {name, value};\n\t\t\t}),\n\t\t},\n\t});\n\t/** @param if sets to relative, sets if it is relative to the start or end */\n\trelativeTo = ParamConfig.INTEGER(0, {\n\t\tmenu: {\n\t\t\tentries: ANIMATION_POSITION_RELATIVE_TOS.map((name, value) => {\n\t\t\t\treturn {name, value};\n\t\t\t}),\n\t\t},\n\t});\n\t/** @param offset */\n\toffset = ParamConfig.FLOAT(0);\n}\nconst ParamsConfig = new PositionAnimParamsConfig();\n\nexport class PositionAnimNode extends TypedAnimNode<PositionAnimParamsConfig> {\n\toverride paramsConfig = ParamsConfig;\n\tstatic override type() {\n\t\treturn 'position';\n\t}\n\n\toverride initializeNode() {\n\t\tthis.io.inputs.setCount(0, 1);\n\t}\n\n\tsetMode(mode: AnimationPositionMode) {\n\t\tthis.p.mode.set(ANIMATION_POSITION_MODES.indexOf(mode));\n\t}\n\tsetRelativeTo(relativeTo: AnimationPositionRelativeTo) {\n\t\tthis.p.relativeTo.set(ANIMATION_POSITION_RELATIVE_TOS.indexOf(relativeTo));\n\t}\n\n\toverride cook(input_contents: TimelineBuilder[]) {\n\t\tconst timeline_builder = input_contents[0] || new TimelineBuilder();\n\n\t\tconst position = new AnimationPosition();\n\t\tposition.setMode(ANIMATION_POSITION_MODES[this.pv.mode]);\n\t\tposition.setRelativeTo(ANIMATION_POSITION_RELATIVE_TOS[this.pv.relativeTo]);\n\t\tposition.setOffset(this.pv.offset);\n\t\ttimeline_builder.setPosition(position);\n\n\t\tthis.setTimelineBuilder(timeline_builder);\n\t}\n}\n","/**\n * A subnet to create POST PROCESS nodes\n *\n */\nimport {Constructor, valueof} from '../../../types/GlobalTypes';\nimport {BaseNetworkAnimNode} from './_BaseManager';\nimport {NetworkNodeType, NodeContext} from '../../poly/NodeContext';\nimport {PostNodeChildrenMap} from '../../poly/registers/nodes/Post';\nimport {BasePostProcessNodeType} from '../post/_Base';\nimport {DisplayNodeController} from '../utils/DisplayNodeController';\nimport {EffectComposerController, PostProcessNetworkParamsConfig} from '../post/utils/EffectComposerController';\nimport {NodeCreateOptions} from '../utils/hierarchy/ChildrenController';\n\nexport class PostProcessNetworkAnimNode extends BaseNetworkAnimNode<PostProcessNetworkParamsConfig> {\n\toverride paramsConfig = new PostProcessNetworkParamsConfig();\n\tstatic override type() {\n\t\treturn NetworkNodeType.POST;\n\t}\n\treadonly effectsComposerController: EffectComposerController = new EffectComposerController(this);\n\tpublic override readonly displayNodeController: DisplayNodeController = new DisplayNodeController(\n\t\tthis,\n\t\tthis.effectsComposerController.displayNodeControllerCallbacks()\n\t);\n\n\tprotected override _childrenControllerContext = NodeContext.POST;\n\n\toverride createNode<S extends keyof PostNodeChildrenMap>(\n\t\tnode_class: S,\n\t\toptions?: NodeCreateOptions\n\t): PostNodeChildrenMap[S];\n\toverride createNode<K extends valueof<PostNodeChildrenMap>>(\n\t\tnode_class: Constructor<K>,\n\t\toptions?: NodeCreateOptions\n\t): K;\n\toverride createNode<K extends valueof<PostNodeChildrenMap>>(\n\t\tnode_class: Constructor<K>,\n\t\toptions?: NodeCreateOptions\n\t): K {\n\t\treturn super.createNode(node_class, options) as K;\n\t}\n\toverride children() {\n\t\treturn super.children() as BasePostProcessNodeType[];\n\t}\n\toverride nodesByType<K extends keyof PostNodeChildrenMap>(type: K): PostNodeChildrenMap[K][] {\n\t\treturn super.nodesByType(type) as PostNodeChildrenMap[K][];\n\t}\n}\n","/**\n * Value of the property the animation will be animated to\n *\n *\n */\nimport {TypedAnimNode} from './_Base';\nimport {TimelineBuilder} from '../../../core/animation/TimelineBuilder';\nimport {CoreType} from '../../../core/Type';\nimport {TypeAssert} from '../../poly/Assert';\nimport {Object3D} from 'three';\nimport {Quaternion} from 'three';\nimport {NodeParamsConfig, ParamConfig} from '../utils/params/ParamsConfig';\nimport {isBooleanTrue} from '../../../core/BooleanValue';\nimport {BaseNodeType} from '../_Base';\n\nexport enum AnimPropertyValueNodeMode {\n\tCUSTOM = 'custom',\n\tFROM_SCENE_GRAPH = 'from scene graph',\n\tFROM_NODE = 'from node',\n}\nconst PROPERTY_VALUE_MODES: AnimPropertyValueNodeMode[] = [\n\tAnimPropertyValueNodeMode.CUSTOM,\n\tAnimPropertyValueNodeMode.FROM_SCENE_GRAPH,\n\tAnimPropertyValueNodeMode.FROM_NODE,\n];\nconst PROPERTY_VALUE_MODE_CUSTOM = PROPERTY_VALUE_MODES.indexOf(AnimPropertyValueNodeMode.CUSTOM);\nconst PROPERTY_VALUE_MODE_FROM_SCENE_GRAPH = PROPERTY_VALUE_MODES.indexOf(AnimPropertyValueNodeMode.FROM_SCENE_GRAPH);\nconst PROPERTY_VALUE_MODE_FROM_NODE = PROPERTY_VALUE_MODES.indexOf(AnimPropertyValueNodeMode.FROM_NODE);\n\nclass PropertyValueAnimParamsConfig extends NodeParamsConfig {\n\t/** @param mode */\n\tmode = ParamConfig.INTEGER(PROPERTY_VALUE_MODE_CUSTOM, {\n\t\tmenu: {\n\t\t\tentries: PROPERTY_VALUE_MODES.map((name, value) => {\n\t\t\t\treturn {name, value};\n\t\t\t}),\n\t\t},\n\t});\n\t/** @param if set to a Polygonjs node, this is the node path */\n\tnodePath = ParamConfig.NODE_PATH('', {\n\t\tvisibleIf: {mode: PROPERTY_VALUE_MODE_FROM_NODE},\n\t});\n\t/** @param if set to a THREE object, this is a mask to find the objects */\n\tobjectMask = ParamConfig.STRING('*geo1', {\n\t\tvisibleIf: {mode: PROPERTY_VALUE_MODE_FROM_SCENE_GRAPH},\n\t});\n\t/** @param print the object matching the objectMask, to help debugging */\n\tprintResolve = ParamConfig.BUTTON(null, {\n\t\tvisibleIf: {mode: PROPERTY_VALUE_MODE_FROM_SCENE_GRAPH},\n\t\tcallback: (node: BaseNodeType) => {\n\t\t\tPropertyValueAnimNode.PARAM_CALLBACK_printResolve(node as PropertyValueAnimNode);\n\t\t},\n\t});\n\toverridePropertyName = ParamConfig.BOOLEAN(0, {\n\t\tvisibleIf: [{mode: PROPERTY_VALUE_MODE_FROM_SCENE_GRAPH}, {mode: PROPERTY_VALUE_MODE_FROM_NODE}],\n\t});\n\tpropertyName = ParamConfig.STRING('', {\n\t\tvisibleIf: [\n\t\t\t{overridePropertyName: true, mode: PROPERTY_VALUE_MODE_FROM_SCENE_GRAPH},\n\t\t\t{overridePropertyName: true, mode: PROPERTY_VALUE_MODE_FROM_NODE},\n\t\t],\n\t});\n\t/** @param size of the parameter to animate */\n\tsize = ParamConfig.INTEGER(3, {\n\t\trange: [1, 4],\n\t\trangeLocked: [true, true],\n\t\tvisibleIf: {mode: PROPERTY_VALUE_MODE_CUSTOM},\n\t\tseparatorAfter: true,\n\t});\n\t/** @param value for a float */\n\tvalue1 = ParamConfig.FLOAT(0, {\n\t\tvisibleIf: {mode: PROPERTY_VALUE_MODE_CUSTOM, size: 1},\n\t});\n\t/** @param value for a vector2 */\n\tvalue2 = ParamConfig.VECTOR2([0, 0], {\n\t\tvisibleIf: {mode: PROPERTY_VALUE_MODE_CUSTOM, size: 2},\n\t});\n\t/** @param value for a vector3 */\n\tvalue3 = ParamConfig.VECTOR3([0, 0, 0], {\n\t\tvisibleIf: {mode: PROPERTY_VALUE_MODE_CUSTOM, size: 3, asColor: false},\n\t});\n\t/** @param value for a vector3 as color */\n\tcolor = ParamConfig.COLOR([0, 0, 0], {\n\t\tvisibleIf: {mode: PROPERTY_VALUE_MODE_CUSTOM, size: 3, asColor: true},\n\t});\n\t/** @param value for a vector4 */\n\tvalue4 = ParamConfig.VECTOR4([0, 0, 0, 0], {\n\t\tvisibleIf: {mode: PROPERTY_VALUE_MODE_CUSTOM, size: 4},\n\t});\n\t/** @param when using vector3, use toggle on it should be a color */\n\tasColor = ParamConfig.BOOLEAN(0, {\n\t\tvisibleIf: {mode: PROPERTY_VALUE_MODE_CUSTOM, size: 3},\n\t});\n}\nconst ParamsConfig = new PropertyValueAnimParamsConfig();\n\nexport class PropertyValueAnimNode extends TypedAnimNode<PropertyValueAnimParamsConfig> {\n\toverride paramsConfig = ParamsConfig;\n\tstatic override type() {\n\t\treturn 'propertyValue';\n\t}\n\n\toverride initializeNode() {\n\t\tthis.io.inputs.setCount(0, 1);\n\t}\n\n\toverride async cook(inputContents: TimelineBuilder[]) {\n\t\tconst timelineBuilder = inputContents[0] || new TimelineBuilder();\n\n\t\tawait this._prepareTimelineBuilder(timelineBuilder);\n\t\tthis.setTimelineBuilder(timelineBuilder);\n\t}\n\tsetMode(targetType: AnimPropertyValueNodeMode) {\n\t\tthis.p.mode.set(PROPERTY_VALUE_MODES.indexOf(targetType));\n\t}\n\n\tprivate async _prepareTimelineBuilder(timelineBuilder: TimelineBuilder) {\n\t\tconst mode = PROPERTY_VALUE_MODES[this.pv.mode];\n\t\tswitch (mode) {\n\t\t\tcase AnimPropertyValueNodeMode.CUSTOM: {\n\t\t\t\treturn this._prepareTimebuilderCustom(timelineBuilder);\n\t\t\t}\n\t\t\tcase AnimPropertyValueNodeMode.FROM_SCENE_GRAPH: {\n\t\t\t\treturn this._prepareTimebuilderFromSceneGraph(timelineBuilder);\n\t\t\t}\n\t\t\tcase AnimPropertyValueNodeMode.FROM_NODE: {\n\t\t\t\treturn await this._prepareTimebuilderFromNode(timelineBuilder);\n\t\t\t}\n\t\t}\n\t\tTypeAssert.unreachable(mode);\n\t}\n\n\tprivate _prepareTimebuilderCustom(timelineBuilder: TimelineBuilder) {\n\t\tconst size = this.pv.size;\n\t\tswitch (size) {\n\t\t\tcase 1: {\n\t\t\t\treturn timelineBuilder.setPropertyValue(this.pv.value1);\n\t\t\t}\n\t\t\tcase 2: {\n\t\t\t\treturn timelineBuilder.setPropertyValue(this.pv.value2);\n\t\t\t}\n\t\t\tcase 3: {\n\t\t\t\tif (isBooleanTrue(this.pv.asColor)) {\n\t\t\t\t\treturn timelineBuilder.setPropertyValue(this.pv.color);\n\t\t\t\t} else {\n\t\t\t\t\treturn timelineBuilder.setPropertyValue(this.pv.value3);\n\t\t\t\t}\n\t\t\t}\n\t\t\tcase 4: {\n\t\t\t\treturn timelineBuilder.setPropertyValue(this.pv.value4);\n\t\t\t}\n\t\t}\n\t}\n\tprivate _prepareTimebuilderFromSceneGraph(timelineBuilder: TimelineBuilder) {\n\t\tconst propertyName = isBooleanTrue(this.pv.overridePropertyName)\n\t\t\t? this.pv.propertyName\n\t\t\t: timelineBuilder.propertyName();\n\n\t\tif (!propertyName) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst foundObject = this._foundObjectFromSceneGraph() as Object3D | undefined;\n\t\tif (foundObject) {\n\t\t\tconst value: any = foundObject[propertyName as keyof Object3D];\n\t\t\tif (value) {\n\t\t\t\tif (CoreType.isNumber(value) || CoreType.isVector(value) || value instanceof Quaternion) {\n\t\t\t\t\ttimelineBuilder.setPropertyValue(value);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate async _prepareTimebuilderFromNode(timelineBuilder: TimelineBuilder) {\n\t\tconst propertyName = isBooleanTrue(this.pv.overridePropertyName)\n\t\t\t? this.pv.propertyName\n\t\t\t: timelineBuilder.propertyName();\n\t\tif (!propertyName) {\n\t\t\treturn;\n\t\t}\n\t\tconst node = this.pv.nodePath.node();\n\t\tif (!node) {\n\t\t\treturn;\n\t\t}\n\t\tconst param = node.params.get(propertyName);\n\t\tif (!param) {\n\t\t\treturn;\n\t\t}\n\t\tif (param.isDirty()) {\n\t\t\tawait param.compute();\n\t\t}\n\t\tconst value = param.value;\n\t\tif (value) {\n\t\t\tif (CoreType.isNumber(value) || CoreType.isVector(value)) {\n\t\t\t\ttimelineBuilder.setPropertyValue(value);\n\t\t\t}\n\t\t}\n\t}\n\n\tstatic PARAM_CALLBACK_printResolve(node: PropertyValueAnimNode) {\n\t\tnode.printResolve();\n\t}\n\tprivate _foundObjectFromSceneGraph() {\n\t\treturn this.scene().findObjectByMask(this.pv.objectMask);\n\t}\n\tprivate printResolve() {\n\t\tconst foundObject = this._foundObjectFromSceneGraph();\n\t\tconsole.log(foundObject);\n\t}\n}\n","/**\n * Sets if the animation should repeat\n *\n *\n */\nimport {TypedAnimNode} from './_Base';\nimport {TimelineBuilder} from '../../../core/animation/TimelineBuilder';\n\nimport {NodeParamsConfig, ParamConfig} from '../utils/params/ParamsConfig';\nimport {isBooleanTrue} from '../../../core/BooleanValue';\nimport {AnimationRepeatParams} from '../../../core/animation/vars/AnimBuilderTypes';\nclass RepeatAnimParamsConfig extends NodeParamsConfig {\n\t/** @param sets if it should repeat indefinitely */\n\tunlimited = ParamConfig.BOOLEAN(0);\n\t/** @param number of times the animation should repeat */\n\tcount = ParamConfig.INTEGER(1, {\n\t\trange: [0, 10],\n\t\tvisibleIf: {unlimited: 0},\n\t});\n\t/** @param delay */\n\tdelay = ParamConfig.FLOAT(0);\n\t/** @param sets if the animation should go back and forth at each repeat */\n\tyoyo = ParamConfig.BOOLEAN(0);\n}\nconst ParamsConfig = new RepeatAnimParamsConfig();\n\nexport class RepeatAnimNode extends TypedAnimNode<RepeatAnimParamsConfig> {\n\toverride paramsConfig = ParamsConfig;\n\tstatic override type() {\n\t\treturn 'repeat';\n\t}\n\n\toverride initializeNode() {\n\t\tthis.io.inputs.setCount(0, 1);\n\t}\n\n\tprivate _repeat_params(): AnimationRepeatParams {\n\t\treturn {\n\t\t\tcount: isBooleanTrue(this.pv.unlimited) ? -1 : this.pv.count,\n\t\t\tdelay: this.pv.delay,\n\t\t\tyoyo: isBooleanTrue(this.pv.yoyo),\n\t\t};\n\t}\n\n\toverride cook(input_contents: TimelineBuilder[]) {\n\t\tconst timeline_builder = input_contents[0] || new TimelineBuilder();\n\n\t\ttimeline_builder.setRepeatParams(this._repeat_params());\n\n\t\tthis.setTimelineBuilder(timeline_builder);\n\t}\n}\n","export class AnimationUpdateCallback {\n\tprivate _update_matrix: boolean = false;\n\n\tclone() {\n\t\tconst new_update_callback = new AnimationUpdateCallback();\n\t\tnew_update_callback.setUpdateMatrix(this._update_matrix);\n\t\treturn new_update_callback;\n\t}\n\n\tsetUpdateMatrix(update_matrix: boolean) {\n\t\tthis._update_matrix = update_matrix;\n\t}\n\tupdateMatrix() {\n\t\treturn this._update_matrix;\n\t}\n}\n","/**\n * Target of the animation\n *\n *\n */\nimport {TypedAnimNode} from './_Base';\nimport {TimelineBuilder} from '../../../core/animation/TimelineBuilder';\n\nexport enum AnimTargetNodeTargetType {\n\tSCENE_GRAPH = 'scene graph',\n\tNODE = 'node',\n}\nexport const ANIM_TARGET_TYPES: AnimTargetNodeTargetType[] = [\n\tAnimTargetNodeTargetType.SCENE_GRAPH,\n\tAnimTargetNodeTargetType.NODE,\n];\nconst TARGET_TYPE_SCENE_GRAPH = ANIM_TARGET_TYPES.indexOf(AnimTargetNodeTargetType.SCENE_GRAPH);\nconst TARGET_TYPE_NODE = ANIM_TARGET_TYPES.indexOf(AnimTargetNodeTargetType.NODE);\n\nimport {NodeParamsConfig, ParamConfig} from '../utils/params/ParamsConfig';\nimport {TypeAssert} from '../../poly/Assert';\nimport {AnimPropertyTarget} from '../../../core/animation/PropertyTarget';\nimport {AnimationUpdateCallback} from '../../../core/animation/UpdateCallback';\nimport {BaseParamType} from '../../params/_Base';\nimport {BaseNodeType} from '../_Base';\nimport {isBooleanTrue} from '../../../core/BooleanValue';\nimport {AnimType} from '../../poly/registers/nodes/types/Anim';\nclass TargetAnimParamsConfig extends NodeParamsConfig {\n\t/** @param sets if the target is a Polygonjs node, or a THREE object */\n\ttype = ParamConfig.INTEGER(TARGET_TYPE_SCENE_GRAPH, {\n\t\tmenu: {\n\t\t\tentries: ANIM_TARGET_TYPES.map((name, value) => {\n\t\t\t\treturn {name, value};\n\t\t\t}),\n\t\t},\n\t});\n\t/** @param if set to a Polygonjs node, this is the node path */\n\tnodePath = ParamConfig.NODE_PATH('', {\n\t\tvisibleIf: {type: TARGET_TYPE_NODE},\n\t});\n\t/** @param if set to a THREE object, this is a mask to find the objects */\n\tobjectMask = ParamConfig.STRING('/geo*', {\n\t\tvisibleIf: {type: TARGET_TYPE_SCENE_GRAPH},\n\t\tobjectMask: true,\n\t});\n\t/** @param sets if the matrix should be updated as the animation progresses */\n\tupdateMatrix = ParamConfig.BOOLEAN(1, {\n\t\tvisibleIf: {type: TARGET_TYPE_SCENE_GRAPH},\n\t});\n\t/** @param prints which objects are targeted by this node, for debugging */\n\tprintResolve = ParamConfig.BUTTON(null, {\n\t\tcallback: (node: BaseNodeType, param: BaseParamType) => {\n\t\t\tTargetAnimNode.PARAM_CALLBACK_print_resolve(node as TargetAnimNode);\n\t\t},\n\t});\n}\nconst ParamsConfig = new TargetAnimParamsConfig();\n\nexport class TargetAnimNode extends TypedAnimNode<TargetAnimParamsConfig> {\n\toverride paramsConfig = ParamsConfig;\n\tstatic override type() {\n\t\treturn AnimType.TARGET;\n\t}\n\n\toverride initializeNode() {\n\t\tthis.io.inputs.setCount(0, 1);\n\t}\n\n\toverride cook(inputCoreContents: TimelineBuilder[]) {\n\t\tconst timelineBuilder = inputCoreContents[0] || new TimelineBuilder();\n\n\t\tconst target = this._create_target(timelineBuilder);\n\t\ttimelineBuilder.setTarget(target);\n\t\tthis._set_update_callback(timelineBuilder);\n\n\t\tthis.setTimelineBuilder(timelineBuilder);\n\t}\n\tsetTargetType(targetType: AnimTargetNodeTargetType) {\n\t\tthis.p.type.set(ANIM_TARGET_TYPES.indexOf(targetType));\n\t}\n\tprivate _create_target(timelineBuilder: TimelineBuilder) {\n\t\tconst type = ANIM_TARGET_TYPES[this.pv.type];\n\t\tswitch (type) {\n\t\t\tcase AnimTargetNodeTargetType.NODE: {\n\t\t\t\treturn new AnimPropertyTarget(this.scene(), {\n\t\t\t\t\tnode: {\n\t\t\t\t\t\tpath: this.pv.nodePath.path(),\n\t\t\t\t\t\trelativeTo: this,\n\t\t\t\t\t},\n\t\t\t\t});\n\t\t\t}\n\t\t\tcase AnimTargetNodeTargetType.SCENE_GRAPH: {\n\t\t\t\treturn new AnimPropertyTarget(this.scene(), {object: {mask: this.pv.objectMask}});\n\t\t\t}\n\t\t}\n\t\tTypeAssert.unreachable(type);\n\t}\n\tprivate _set_update_callback(timelineBuilder: TimelineBuilder) {\n\t\tconst type = ANIM_TARGET_TYPES[this.pv.type];\n\t\tlet update_callback = timelineBuilder.updateCallback();\n\t\tswitch (type) {\n\t\t\tcase AnimTargetNodeTargetType.NODE: {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tcase AnimTargetNodeTargetType.SCENE_GRAPH: {\n\t\t\t\tif (isBooleanTrue(this.pv.updateMatrix)) {\n\t\t\t\t\tupdate_callback = update_callback || new AnimationUpdateCallback();\n\t\t\t\t\tupdate_callback.setUpdateMatrix(this.pv.updateMatrix);\n\t\t\t\t\ttimelineBuilder.setUpdateCallback(update_callback);\n\t\t\t\t}\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tTypeAssert.unreachable(type);\n\t}\n\n\tstatic PARAM_CALLBACK_print_resolve(node: TargetAnimNode) {\n\t\tnode.print_resolve();\n\t}\n\tprivate print_resolve() {\n\t\tconst type = ANIM_TARGET_TYPES[this.pv.type];\n\t\tconst timeline_builder = new TimelineBuilder();\n\t\tconst target = this._create_target(timeline_builder);\n\t\tswitch (type) {\n\t\t\tcase AnimTargetNodeTargetType.NODE: {\n\t\t\t\treturn console.log(target.node());\n\t\t\t}\n\t\t\tcase AnimTargetNodeTargetType.SCENE_GRAPH: {\n\t\t\t\treturn console.log(target.objects());\n\t\t\t}\n\t\t}\n\t}\n}\n","import {NodeContext} from '../../poly/NodeContext';\nimport {NodeParamsConfig} from '../utils/params/ParamsConfig';\nimport {TypedNode} from '../_Base';\n\nclass ParamLessNetworkAnimParamsConfig extends NodeParamsConfig {}\nexport class BaseNetworkAnimNode<K extends NodeParamsConfig> extends TypedNode<NodeContext.ANIM, K> {\n\tstatic override context(): NodeContext {\n\t\treturn NodeContext.ANIM;\n\t}\n\toverride cook() {\n\t\tthis.cookController.endCook();\n\t}\n}\nexport class ParamLessBaseNetworkAnimNode extends BaseNetworkAnimNode<ParamLessNetworkAnimParamsConfig> {}\n","/**\n * creates a Synth\n *\n *\n */\nimport {TypedAudioNode} from './_Base';\nimport {NodeParamsConfig, ParamConfig} from '../utils/params/ParamsConfig';\nimport {AudioBuilder} from '../../../core/audio/AudioBuilder';\nimport {BaseNodeType} from '../_Base';\nimport {effectParamsOptions} from './utils/EffectsController';\nimport {Volume} from 'tone/build/esm/component/channel/Volume';\n\nconst VOLUME_DEFAULTS = {\n\tvolume: 0,\n};\n\nconst paramCallback = (node: BaseNodeType) => {\n\tVolumeAudioNode.PARAM_CALLBACK_updateEffect(node as VolumeAudioNode);\n};\n\nclass VolumeAudioParamsConfig extends NodeParamsConfig {\n\t/** @param volume */\n\tvolume = ParamConfig.FLOAT(VOLUME_DEFAULTS.volume, {\n\t\trange: [-20, 20],\n\t\trangeLocked: [false, false],\n\t\t...effectParamsOptions(paramCallback),\n\t});\n}\nconst ParamsConfig = new VolumeAudioParamsConfig();\n\nexport class VolumeAudioNode extends TypedAudioNode<VolumeAudioParamsConfig> {\n\toverride paramsConfig = ParamsConfig;\n\tstatic override type() {\n\t\treturn 'volume';\n\t}\n\n\toverride initializeNode() {\n\t\tthis.io.inputs.setCount(1);\n\t}\n\n\toverride cook(inputContents: AudioBuilder[]) {\n\t\tconst audioBuilder = inputContents[0];\n\n\t\tconst effect = this._effect();\n\n\t\tconst inputNode = audioBuilder.audioNode();\n\t\tif (inputNode) {\n\t\t\tinputNode.connect(effect);\n\t\t}\n\t\taudioBuilder.setAudioNode(effect);\n\n\t\tthis.setAudioBuilder(audioBuilder);\n\t}\n\n\tprivate __effect__: Volume | undefined;\n\tprivate _effect() {\n\t\treturn (this.__effect__ = this.__effect__ || this._createEffect());\n\t}\n\tprivate _createEffect() {\n\t\treturn new Volume({\n\t\t\tvolume: this.pv.volume,\n\t\t});\n\t}\n\tstatic PARAM_CALLBACK_updateEffect(node: VolumeAudioNode) {\n\t\tnode._updateEffect();\n\t}\n\tprivate _updateEffect() {\n\t\tconst effect = this._effect();\n\t\teffect.volume.linearRampToValueAtTime(this.pv.volume, '+1');\n\t}\n}\n","import {BaseNodeType} from '../../_Base';\n\ntype AudioEffectsControllerCallback = (node: BaseNodeType) => void;\n\nexport function effectParamsOptions(callback: AudioEffectsControllerCallback) {\n\treturn {\n\t\tcook: false,\n\t\tcallback: callback,\n\t};\n}\n","/**\n * Allows to create a shader with GLSL nodes to create the texture values.\n *\n *\n */\nimport {\n\tCamera,\n\tMesh,\n\tPlaneGeometry,\n\tWebGLRenderer,\n\tWebGLRenderTarget,\n\tShaderMaterial,\n\tScene,\n\tFloatType,\n\tHalfFloatType,\n\tRGBAFormat,\n\tClampToEdgeWrapping,\n\tLinearFilter,\n\tNearestFilter,\n\tNoToneMapping,\n\tNoColorSpace,\n\tColorSpace,\n\tToneMapping,\n\tOrthographicCamera,\n} from 'three';\nimport {Constructor, valueof, Number2} from '../../../types/GlobalTypes';\nimport {TypedCopNode} from './_Base';\nimport {GlobalsGeometryHandler} from '../gl/code/globals/Geometry';\nimport {GlNodeChildrenMap} from '../../poly/registers/nodes/Gl';\nimport {BaseGlNodeType} from '../gl/_Base';\nimport {GlNodeFinder} from '../gl/code/utils/NodeFinder';\nimport {NodeContext} from '../../poly/NodeContext';\nimport {IUniforms} from '../../../core/geometry/Material';\nimport {NodeParamsConfig, ParamConfig} from '../utils/params/ParamsConfig';\nimport {DataTextureController} from './utils/DataTextureController';\nimport {CopRendererController} from './utils/RendererController';\nimport {AssemblerName} from '../../poly/registers/assemblers/_BaseRegister';\nimport {Poly} from '../../Poly';\nimport {TexturePersistedConfig} from '../gl/code/assemblers/textures/TexturePersistedConfig';\nimport {CoreUserAgent} from '../../../core/UserAgent';\nimport {NodeCreateOptions} from '../utils/hierarchy/ChildrenController';\nimport {BaseNodeType} from '../_Base';\nimport {CopType} from '../../poly/registers/nodes/types/Cop';\nimport {TextureParamsController, TextureParamConfig} from './utils/TextureParamsController';\nimport {isBooleanTrue} from '../../../core/Type';\nimport FRAGMENT_SHADER from '../gl/code/templates/textures/Default.frag.glsl';\nimport VERTEX_SHADER from '../gl/code/templates/textures/Default.vert.glsl';\nimport {handleCopBuilderDependencies} from './utils/BuilderUtils';\nimport {GlAssemblerController} from '../gl/code/Controller';\nimport {ShaderAssemblerTexture} from '../gl/code/assemblers/textures/Texture';\n\nconst RESOLUTION_DEFAULT: Number2 = [256, 256];\n\nfunction BuilderCopParamConfig<TBase extends Constructor>(Base: TBase) {\n\treturn class Mixin extends Base {\n\t\t/** @param texture resolution */\n\t\tresolution = ParamConfig.VECTOR2(RESOLUTION_DEFAULT);\n\t\t/** @param use the main camera renderer. This can save memory, but can also lead to colors being affected by the renderer's output color space */\n\t\tuseCameraRenderer = ParamConfig.BOOLEAN(1, {\n\t\t\tcallback: (node: BaseNodeType) => {\n\t\t\t\tBuilderCopNode.PARAM_CALLBACK_render(node as BuilderCopNode);\n\t\t\t},\n\t\t});\n\t\t/** @param use a data texture instead of a render target, which can be useful when using that texture as and envMap */\n\t\tuseDataTexture = ParamConfig.BOOLEAN(0);\n\t\t/** @param force Render */\n\t\trender = ParamConfig.BUTTON(null, {\n\t\t\tcallback: (node: BaseNodeType) => {\n\t\t\t\tBuilderCopNode.PARAM_CALLBACK_render(node as BuilderCopNode);\n\t\t\t},\n\t\t});\n\t};\n}\nclass BuilderCopParamsConfig extends TextureParamConfig(BuilderCopParamConfig(NodeParamsConfig)) {}\n\nconst ParamsConfig = new BuilderCopParamsConfig();\n\nexport class BuilderCopNode extends TypedCopNode<BuilderCopParamsConfig> {\n\toverride paramsConfig = ParamsConfig;\n\tstatic override type() {\n\t\treturn CopType.BUILDER;\n\t}\n\toverride readonly persisted_config: TexturePersistedConfig = new TexturePersistedConfig(this);\n\tprotected _assemblerController = this._createAssemblerController();\n\n\tpublic override usedAssembler(): Readonly<AssemblerName.GL_TEXTURE> {\n\t\treturn AssemblerName.GL_TEXTURE;\n\t}\n\tprotected _createAssemblerController(): GlAssemblerController<ShaderAssemblerTexture> | undefined {\n\t\tconst assemblerController: GlAssemblerController<ShaderAssemblerTexture> | undefined =\n\t\t\tPoly.assemblersRegister.assembler(this, this.usedAssembler());\n\t\tif (assemblerController) {\n\t\t\tconst globalsHandler = new GlobalsGeometryHandler();\n\t\t\tassemblerController.setAssemblerGlobalsHandler(globalsHandler);\n\t\t\treturn assemblerController;\n\t\t}\n\t}\n\n\tassemblerController() {\n\t\treturn this._assemblerController;\n\t}\n\n\tprivate _textureMesh: Mesh = new Mesh(new PlaneGeometry(2, 2));\n\tprivate _fragmentShader: string | undefined;\n\tprivate _uniforms: IUniforms | undefined;\n\tpublic readonly textureMaterial: ShaderMaterial = new ShaderMaterial({\n\t\tuniforms: {},\n\t\tvertexShader: VERTEX_SHADER,\n\t\tfragmentShader: FRAGMENT_SHADER,\n\t});\n\tprivate _textureScene: Scene = new Scene();\n\tprivate _textureCamera: Camera = new OrthographicCamera();\n\tprivate _renderTarget: WebGLRenderTarget | undefined;\n\tprivate _dataTextureController: DataTextureController | undefined;\n\tprivate _rendererController: CopRendererController | undefined;\n\n\tpublic readonly textureParamsController: TextureParamsController = new TextureParamsController(this);\n\tprotected override _childrenControllerContext = NodeContext.GL;\n\toverride initializeNode() {\n\t\tthis._textureMesh.material = this.textureMaterial;\n\t\tthis._textureMesh.scale.multiplyScalar(0.25);\n\t\tthis._textureScene.add(this._textureMesh);\n\t\tthis._textureCamera.position.z = 1;\n\n\t\t// this ensures the builder recooks when its children are changed\n\t\t// and not just when a material that use it requests it\n\t\tthis.addPostDirtyHook('_cook_main_without_inputs_when_dirty', () => {\n\t\t\tsetTimeout(this._cook_main_without_inputs_when_dirty_bound, 0);\n\t\t});\n\n\t\t// this.dirtyController.addPostDirtyHook(\n\t\t// \t'_reset_if_resolution_changed',\n\t\t// \tthis._reset_if_resolution_changed.bind(this)\n\t\t// );\n\t\t// this.params.onParamsCreated('reset', () => {\n\t\t// \tthis._reset();\n\t\t// });\n\t}\n\n\toverride createNode<S extends keyof GlNodeChildrenMap>(\n\t\tnode_class: S,\n\t\toptions?: NodeCreateOptions\n\t): GlNodeChildrenMap[S];\n\toverride createNode<K extends valueof<GlNodeChildrenMap>>(\n\t\tnode_class: Constructor<K>,\n\t\toptions?: NodeCreateOptions\n\t): K;\n\toverride createNode<K extends valueof<GlNodeChildrenMap>>(\n\t\tnode_class: Constructor<K>,\n\t\toptions?: NodeCreateOptions\n\t): K {\n\t\treturn super.createNode(node_class, options) as K;\n\t}\n\toverride children() {\n\t\treturn super.children() as BaseGlNodeType[];\n\t}\n\toverride nodesByType<K extends keyof GlNodeChildrenMap>(type: K): GlNodeChildrenMap[K][] {\n\t\treturn super.nodesByType(type) as GlNodeChildrenMap[K][];\n\t}\n\toverride childrenAllowed() {\n\t\tif (this.assemblerController()) {\n\t\t\treturn super.childrenAllowed();\n\t\t}\n\t\treturn false;\n\t}\n\toverride sceneReadonly() {\n\t\treturn this.assemblerController() == null;\n\t}\n\n\tprivate _cook_main_without_inputs_when_dirty_bound = this._cook_main_without_inputs_when_dirty.bind(this);\n\tprivate async _cook_main_without_inputs_when_dirty() {\n\t\tawait this.cookController.cookMainWithoutInputs();\n\t}\n\n\t// private _reset_if_resolution_changed(trigger?: CoreGraphNode) {\n\t// \tif (trigger && trigger.graphNodeId() == this.p.resolution.graphNodeId()) {\n\t// \t\tthis._reset();\n\t// \t}\n\t// }\n\n\toverride async cook() {\n\t\tthis.compileIfRequired();\n\t\tawait this._renderOnTarget(true);\n\t}\n\n\tshaders_by_name() {\n\t\treturn {\n\t\t\tfragment: this._fragmentShader,\n\t\t};\n\t}\n\n\tcompileIfRequired() {\n\t\tif (this.assemblerController()?.compileRequired()) {\n\t\t\ttry {\n\t\t\t\tthis.compile();\n\t\t\t} catch (err) {\n\t\t\t\tconst message = (err as any).message || 'failed to compile';\n\t\t\t\tthis.states.error.set(message);\n\t\t\t}\n\t\t}\n\t}\n\tprivate compile() {\n\t\tconst assemblerController = this.assemblerController();\n\t\tif (!assemblerController) {\n\t\t\treturn;\n\t\t}\n\t\tconst outputNodes: BaseGlNodeType[] = GlNodeFinder.findOutputNodes(this);\n\t\tif (outputNodes.length == 0) {\n\t\t\tthis.states.error.set('one output node is required');\n\t\t\treturn;\n\t\t}\n\t\tif (outputNodes.length > 1) {\n\t\t\tthis.states.error.set('only one output node allowed');\n\t\t\treturn;\n\t\t}\n\t\tconst outputNode = outputNodes[0];\n\t\tif (outputNode) {\n\t\t\t//const param_nodes = GlNodeFinder.find_param_generating_nodes(this);\n\t\t\tconst rootNodes = outputNodes; //.concat(param_nodes);\n\t\t\tassemblerController.assembler.set_root_nodes(rootNodes);\n\n\t\t\t// main compilation\n\t\t\tassemblerController.assembler.updateFragmentShader();\n\n\t\t\t// receives fragment and uniforms\n\t\t\tconst fragmentShader = assemblerController.assembler.fragment_shader();\n\t\t\tconst uniforms = assemblerController.assembler.uniforms();\n\t\t\tif (fragmentShader && uniforms) {\n\t\t\t\tthis._fragmentShader = fragmentShader;\n\t\t\t\tthis._uniforms = uniforms;\n\t\t\t}\n\n\t\t\thandleCopBuilderDependencies({\n\t\t\t\tnode: this,\n\t\t\t\ttimeDependent: assemblerController.assembler.uniformsTimeDependent(),\n\t\t\t\tuniforms: undefined,\n\t\t\t});\n\t\t}\n\n\t\tif (this._fragmentShader && this._uniforms) {\n\t\t\tthis.textureMaterial.fragmentShader = this._fragmentShader;\n\t\t\tthis.textureMaterial.uniforms = this._uniforms;\n\t\t\tthis.textureMaterial.needsUpdate = true;\n\t\t\tthis.textureMaterial.uniforms.resolution = {\n\t\t\t\tvalue: this.pv.resolution,\n\t\t\t};\n\t\t}\n\t\tassemblerController.post_compile();\n\t}\n\n\tcallbackName() {\n\t\treturn `cop/builder_${this.graphNodeId()}`;\n\t}\n\t// private _uniformCallbackName() {\n\t// \treturn `cop/builder_uniforms_${this.graphNodeId()}`;\n\t// }\n\toverride dispose() {\n\t\tsuper.dispose();\n\t\tthis._renderTarget?.dispose();\n\t\tthis._renderer?.dispose();\n\t\tthis.removeCallbacks();\n\t}\n\tpublic removeCallbacks() {\n\t\tconst scene = this.scene();\n\t\t// scene.uniformsController.removeTimeUniform(uniforms);\n\t\tscene.unRegisterOnBeforeTick(this.callbackName());\n\t}\n\n\t//\n\t//\n\t// RENDER + RENDER TARGET\n\t//\n\t//\n\tpublic readonly boundRenderOnTarget = this.renderOnTargetWithoutUpdatingTextureFromParams.bind(this);\n\tasync renderOnTargetWithoutUpdatingTextureFromParams() {\n\t\tthis._renderOnTarget(false);\n\t}\n\tprivate async _renderOnTarget(updateTextureFromParams: boolean) {\n\t\tawait this.createRenderTargetIfRequired();\n\t\tawait this._createRendererIfRequired();\n\n\t\tif (this.states.error.active()) {\n\t\t\treturn;\n\t\t}\n\t\tif (!this._renderer) {\n\t\t\tconsole.warn('no renderer');\n\t\t\treturn;\n\t\t}\n\n\t\tthis._saveRendererState(this._renderer);\n\t\tthis._prepareRenderer(this._renderer);\n\t\tthis._renderer.render(this._textureScene, this._textureCamera);\n\t\tawait this._postRender(updateTextureFromParams);\n\t\tthis._restoreRendererState(this._renderer);\n\t\tPoly.onSceneUpdatedHooks.runHooks();\n\t}\n\tprivate async _postRender(updateTextureFromParams: boolean) {\n\t\tif (this._renderTarget?.texture) {\n\t\t\tif (isBooleanTrue(this.pv.useDataTexture) && this._renderTarget && this._renderer) {\n\t\t\t\tthis._dataTextureController = this._dataTextureController || new DataTextureController();\n\t\t\t\tconst texture = this._dataTextureController.fromRenderTarget(this._renderer, this._renderTarget);\n\t\t\t\tif (updateTextureFromParams) {\n\t\t\t\t\tawait this.textureParamsController.update(texture);\n\t\t\t\t}\n\t\t\t\tthis.setTexture(texture);\n\t\t\t} else {\n\t\t\t\tconst texture = this._renderTarget.texture;\n\t\t\t\tif (updateTextureFromParams) {\n\t\t\t\t\t// await this.textureParamsController.update(texture);\n\t\t\t\t}\n\t\t\t\tthis.setTexture(texture);\n\t\t\t}\n\t\t} else {\n\t\t\tthis.cookController.endCook();\n\t\t}\n\t}\n\tprivate _prevTarget: WebGLRenderTarget | null = null;\n\tprivate _prevOutputColorSpace: ColorSpace = NoColorSpace;\n\tprivate _prevToneMapping: ToneMapping = NoToneMapping;\n\tprivate _saveRendererState(renderer: WebGLRenderer) {\n\t\tthis._prevTarget = renderer.getRenderTarget();\n\t\tthis._prevOutputColorSpace = renderer.outputColorSpace;\n\t\tthis._prevToneMapping = renderer.toneMapping;\n\t}\n\tprivate _prepareRenderer(renderer: WebGLRenderer) {\n\t\tif (!this._renderTarget) {\n\t\t\tconsole.warn('no render target');\n\t\t\treturn;\n\t\t}\n\t\trenderer.setRenderTarget(this._renderTarget);\n\t\trenderer.outputColorSpace = NoColorSpace;\n\t\trenderer.toneMapping = NoToneMapping;\n\t\trenderer.clear();\n\t}\n\tprivate _restoreRendererState(renderer: WebGLRenderer) {\n\t\trenderer.setRenderTarget(this._prevTarget);\n\t\trenderer.outputColorSpace = this._prevOutputColorSpace;\n\t\trenderer.toneMapping = this._prevToneMapping;\n\t}\n\t/*\n\t *\n\t * RENDERER\n\t *\n\t */\n\tprivate _renderer: WebGLRenderer | undefined;\n\tprivate async _createRendererIfRequired() {\n\t\tif (this._renderer) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (isBooleanTrue(this.pv.useCameraRenderer)) {\n\t\t\tthis._rendererController = this._rendererController || new CopRendererController(this);\n\t\t\tconst foundRenderer = await this._rendererController.waitForRenderer();\n\t\t\tif (foundRenderer instanceof WebGLRenderer) {\n\t\t\t\tthis._renderer = foundRenderer;\n\t\t\t} else {\n\t\t\t\tconsole.warn('found renderer is not a WebGLRenderer', foundRenderer);\n\t\t\t}\n\t\t} else {\n\t\t\tthis._renderer = Poly.renderersController.linearRenderer();\n\t\t}\n\t}\n\tprivate _resetRenderer() {\n\t\tthis._renderer = undefined;\n\t}\n\trenderer() {\n\t\treturn this._renderer;\n\t}\n\t/*\n\t *\n\t * RENDER TARGET\n\t *\n\t */\n\tasync renderTarget() {\n\t\treturn (this._renderTarget =\n\t\t\tthis._renderTarget || (await this._createRenderTarget(this.pv.resolution.x, this.pv.resolution.y)));\n\t}\n\tprivate async createRenderTargetIfRequired() {\n\t\tif (!this._renderTarget || !this._renderTargetResolutionValid()) {\n\t\t\tthis._renderTarget = await this._createRenderTarget(this.pv.resolution.x, this.pv.resolution.y);\n\t\t\tthis._dataTextureController?.reset();\n\t\t}\n\t}\n\tprivate _renderTargetResolutionValid() {\n\t\tif (this._renderTarget) {\n\t\t\tconst image = this._renderTarget.texture.image;\n\t\t\tif (image.width != this.pv.resolution.x || image.height != this.pv.resolution.y) {\n\t\t\t\treturn false;\n\t\t\t} else {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t} else {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\tprivate async _createRenderTarget(width: number, height: number) {\n\t\tif (this._renderTarget) {\n\t\t\tconst image = this._renderTarget.texture.image;\n\t\t\tif (image.width == width && image.height == height) {\n\t\t\t\treturn this._renderTarget;\n\t\t\t}\n\t\t}\n\n\t\tconst wrapS = ClampToEdgeWrapping;\n\t\tconst wrapT = ClampToEdgeWrapping;\n\n\t\tconst minFilter = LinearFilter;\n\t\tconst magFilter = NearestFilter;\n\n\t\tconst renderTarget = new WebGLRenderTarget(width, height, {\n\t\t\twrapS: wrapS,\n\t\t\twrapT: wrapT,\n\t\t\tminFilter: minFilter,\n\t\t\tmagFilter: magFilter,\n\t\t\tformat: RGBAFormat,\n\t\t\ttype: CoreUserAgent.isiOS() ? HalfFloatType : FloatType,\n\t\t\tstencilBuffer: false,\n\t\t\tdepthBuffer: false,\n\t\t\t// encoding: LinearEncoding,\n\t\t});\n\t\t// await this.textureParamsController.update(renderTarget.texture);\n\t\tPoly.warn(`${this.path()}: created WebGLRenderTarget`, this.path(), width, height);\n\t\treturn renderTarget;\n\t}\n\n\t/*\n\t *\n\t * CALLBACK\n\t *\n\t */\n\tstatic PARAM_CALLBACK_render(node: BuilderCopNode) {\n\t\tnode._renderOnTarget(true);\n\t}\n\tstatic PARAM_CALLBACK_resetRenderer(node: BuilderCopNode) {\n\t\tnode._resetRenderer();\n\t}\n}\n","/**\n * Allows to create a shader with GLSL nodes to create the texture values.\n *\n *\n */\nimport {\n\tCamera,\n\tMesh,\n\tPlaneGeometry,\n\tWebGLRenderer,\n\tWebGLRenderTarget,\n\tShaderMaterial,\n\tScene,\n\tClampToEdgeWrapping,\n\tRGBAFormat,\n\tLinearFilter,\n\tNearestFilter,\n\tNoToneMapping,\n\tWebGLArrayRenderTarget,\n\tNoColorSpace,\n\tColorSpace,\n\tToneMapping,\n\tOrthographicCamera,\n} from 'three';\nimport {Number2} from '../../../types/GlobalTypes';\nimport {Constructor, valueof} from '../../../types/GlobalTypes';\nimport {TypedCopNode} from './_Base';\nimport {GlobalsGeometryHandler} from '../gl/code/globals/Geometry';\nimport {GlNodeChildrenMap} from '../../poly/registers/nodes/Gl';\nimport {BaseGlNodeType} from '../gl/_Base';\nimport {GlNodeFinder} from '../gl/code/utils/NodeFinder';\nimport {NodeContext} from '../../poly/NodeContext';\nimport {IUniforms} from '../../../core/geometry/Material';\nimport {NodeParamsConfig, ParamConfig} from '../utils/params/ParamsConfig';\nimport {DataTextureController} from './utils/DataTextureController';\nimport {CopRendererController} from './utils/RendererController';\nimport {AssemblerName} from '../../poly/registers/assemblers/_BaseRegister';\nimport {Poly} from '../../Poly';\nimport {TexturePersistedConfig} from '../gl/code/assemblers/textures/TexturePersistedConfig';\nimport {NodeCreateOptions} from '../utils/hierarchy/ChildrenController';\nimport {BaseNodeType} from '../_Base';\nimport {CopType} from '../../poly/registers/nodes/types/Cop';\nimport {TextureParamsController, TextureParamConfig} from './utils/TextureParamsController';\nimport {isBooleanTrue} from '../../../core/Type';\nimport FRAGMENT_SHADER from '../gl/code/templates/textures/Default.frag.glsl';\nimport VERTEX_SHADER from '../gl/code/templates/textures/Default.vert.glsl';\nimport {handleCopBuilderDependencies} from './utils/BuilderUtils';\nimport {GlAssemblerController} from '../gl/code/Controller';\nimport {ShaderAssemblerTexture2DArray} from '../gl/code/assemblers/textures/Texture2DArray';\n\nconst RESOLUTION_DEFAULT: Number2 = [128, 128];\n\nfunction Builder2DArrayCopParamConfig<TBase extends Constructor>(Base: TBase) {\n\treturn class Mixin extends Base {\n\t\t/** @param textures resolution */\n\t\tresolution = ParamConfig.VECTOR2(RESOLUTION_DEFAULT);\n\t\t/** @param layers */\n\t\tlayers = ParamConfig.INTEGER(4, {\n\t\t\trange: [2, 32],\n\t\t\trangeLocked: [true, false],\n\t\t});\n\t\t/** @param use the main camera renderer. This can save memory, but can also lead to colors being affected by the renderer's output color space */\n\t\tuseCameraRenderer = ParamConfig.BOOLEAN(1, {\n\t\t\tcallback: (node: BaseNodeType) => {\n\t\t\t\tBuilder2DArrayCopNode.PARAM_CALLBACK_render(node as Builder2DArrayCopNode);\n\t\t\t},\n\t\t});\n\t\t/** @param use a data texture instead of a render target, which can be useful when using that texture as and envMap */\n\t\t// useDataTexture = ParamConfig.BOOLEAN(0);\n\t\t/** @param force Render */\n\t\trender = ParamConfig.BUTTON(null, {\n\t\t\tcallback: (node: BaseNodeType) => {\n\t\t\t\tBuilder2DArrayCopNode.PARAM_CALLBACK_render(node as Builder2DArrayCopNode);\n\t\t\t},\n\t\t});\n\t};\n}\nclass Builder2DArrayCopParamsConfig extends TextureParamConfig(Builder2DArrayCopParamConfig(NodeParamsConfig)) {}\n\nconst ParamsConfig = new Builder2DArrayCopParamsConfig();\n\nexport class Builder2DArrayCopNode extends TypedCopNode<Builder2DArrayCopParamsConfig> {\n\toverride paramsConfig = ParamsConfig;\n\tstatic override type() {\n\t\treturn CopType.BUILDER_2D_ARRAY;\n\t}\n\toverride readonly persisted_config: TexturePersistedConfig = new TexturePersistedConfig(this);\n\tprotected _assemblerController = this._createAssemblerController();\n\n\tpublic override usedAssembler(): Readonly<AssemblerName.GL_TEXTURE_2D_ARRAY> {\n\t\treturn AssemblerName.GL_TEXTURE_2D_ARRAY;\n\t}\n\tprotected _createAssemblerController(): GlAssemblerController<ShaderAssemblerTexture2DArray> | undefined {\n\t\tconst assemblerController: GlAssemblerController<ShaderAssemblerTexture2DArray> | undefined =\n\t\t\tPoly.assemblersRegister.assembler(this, this.usedAssembler());\n\t\tif (assemblerController) {\n\t\t\tconst globalsHandler = new GlobalsGeometryHandler();\n\t\t\tassemblerController.setAssemblerGlobalsHandler(globalsHandler);\n\t\t\treturn assemblerController;\n\t\t}\n\t}\n\n\tassemblerController() {\n\t\treturn this._assemblerController;\n\t}\n\n\tprivate _textureMesh: Mesh = new Mesh(new PlaneGeometry(2, 2));\n\tprivate _fragmentShader: string | undefined;\n\tprivate _uniforms: IUniforms | undefined;\n\tpublic readonly textureMaterial: ShaderMaterial = new ShaderMaterial({\n\t\tuniforms: {},\n\t\tvertexShader: VERTEX_SHADER,\n\t\tfragmentShader: FRAGMENT_SHADER,\n\t});\n\tprivate _textureScene: Scene = new Scene();\n\tprivate _textureCamera: Camera = new OrthographicCamera();\n\tprivate _renderTarget: WebGLArrayRenderTarget | undefined;\n\tprivate _dataTextureController: DataTextureController | undefined;\n\tprivate _rendererController: CopRendererController | undefined;\n\n\tpublic readonly textureParamsController: TextureParamsController = new TextureParamsController(this);\n\tprotected override _childrenControllerContext = NodeContext.GL;\n\toverride initializeNode() {\n\t\tthis._textureMesh.material = this.textureMaterial;\n\t\tthis._textureMesh.scale.multiplyScalar(0.25);\n\t\tthis._textureScene.add(this._textureMesh);\n\t\tthis._textureCamera.position.z = 1;\n\n\t\t// this ensures the builder recooks when its children are changed\n\t\t// and not just when a material that use it requests it\n\t\tthis.addPostDirtyHook('_cook_main_without_inputs_when_dirty', () => {\n\t\t\tsetTimeout(this._cook_main_without_inputs_when_dirty_bound, 0);\n\t\t});\n\n\t\t// this.dirtyController.addPostDirtyHook(\n\t\t// \t'_reset_if_resolution_changed',\n\t\t// \tthis._reset_if_resolution_changed.bind(this)\n\t\t// );\n\t\t// this.params.onParamsCreated('reset', () => {\n\t\t// \tthis._reset();\n\t\t// });\n\t}\n\n\toverride createNode<S extends keyof GlNodeChildrenMap>(\n\t\tnode_class: S,\n\t\toptions?: NodeCreateOptions\n\t): GlNodeChildrenMap[S];\n\toverride createNode<K extends valueof<GlNodeChildrenMap>>(\n\t\tnode_class: Constructor<K>,\n\t\toptions?: NodeCreateOptions\n\t): K;\n\toverride createNode<K extends valueof<GlNodeChildrenMap>>(\n\t\tnode_class: Constructor<K>,\n\t\toptions?: NodeCreateOptions\n\t): K {\n\t\treturn super.createNode(node_class, options) as K;\n\t}\n\toverride children() {\n\t\treturn super.children() as BaseGlNodeType[];\n\t}\n\toverride nodesByType<K extends keyof GlNodeChildrenMap>(type: K): GlNodeChildrenMap[K][] {\n\t\treturn super.nodesByType(type) as GlNodeChildrenMap[K][];\n\t}\n\toverride childrenAllowed() {\n\t\tif (this.assemblerController()) {\n\t\t\treturn super.childrenAllowed();\n\t\t}\n\t\treturn false;\n\t}\n\toverride sceneReadonly() {\n\t\treturn this.assemblerController() == null;\n\t}\n\n\tprivate _cook_main_without_inputs_when_dirty_bound = this._cook_main_without_inputs_when_dirty.bind(this);\n\tprivate async _cook_main_without_inputs_when_dirty() {\n\t\tawait this.cookController.cookMainWithoutInputs();\n\t}\n\n\t// private _reset_if_resolution_changed(trigger?: CoreGraphNode) {\n\t// \tif (trigger && trigger.graphNodeId() == this.p.resolution.graphNodeId()) {\n\t// \t\tthis._reset();\n\t// \t}\n\t// }\n\n\toverride async cook() {\n\t\tthis.compileIfRequired();\n\t\tawait this._renderOnTarget(true);\n\t}\n\n\tshaders_by_name() {\n\t\treturn {\n\t\t\tfragment: this._fragmentShader,\n\t\t};\n\t}\n\n\tcompileIfRequired() {\n\t\tif (this.assemblerController()?.compileRequired()) {\n\t\t\ttry {\n\t\t\t\tthis.compile();\n\t\t\t} catch (err) {\n\t\t\t\tconst message = (err as any).message || 'failed to compile';\n\t\t\t\tthis.states.error.set(message);\n\t\t\t}\n\t\t}\n\t}\n\tprivate compile() {\n\t\tconst assemblerController = this.assemblerController();\n\t\tif (!assemblerController) {\n\t\t\treturn;\n\t\t}\n\t\tconst outputNodes: BaseGlNodeType[] = GlNodeFinder.findOutputNodes(this);\n\t\tif (outputNodes.length == 0) {\n\t\t\tthis.states.error.set('one output node is required');\n\t\t\treturn;\n\t\t}\n\t\tif (outputNodes.length > 1) {\n\t\t\tthis.states.error.set('only one output node allowed');\n\t\t\treturn;\n\t\t}\n\t\tconst outputNode = outputNodes[0];\n\t\tif (outputNode) {\n\t\t\t//const param_nodes = GlNodeFinder.find_param_generating_nodes(this);\n\t\t\tconst rootNodes = outputNodes; //.concat(param_nodes);\n\t\t\tassemblerController.assembler.set_root_nodes(rootNodes);\n\n\t\t\t// main compilation\n\t\t\tassemblerController.assembler.updateFragmentShader();\n\n\t\t\t// receives fragment and uniforms\n\t\t\tconst fragmentShader = assemblerController.assembler.fragment_shader();\n\t\t\tconst uniforms = assemblerController.assembler.uniforms();\n\t\t\tif (fragmentShader && uniforms) {\n\t\t\t\tthis._fragmentShader = fragmentShader;\n\t\t\t\tthis._uniforms = uniforms;\n\t\t\t}\n\n\t\t\thandleCopBuilderDependencies({\n\t\t\t\tnode: this,\n\t\t\t\ttimeDependent: assemblerController.assembler.uniformsTimeDependent(),\n\t\t\t\tuniforms: undefined,\n\t\t\t});\n\t\t}\n\t\tif (this._fragmentShader && this._uniforms) {\n\t\t\tthis.textureMaterial.fragmentShader = this._fragmentShader;\n\t\t\tthis.textureMaterial.uniforms = this._uniforms;\n\t\t\tthis.textureMaterial.needsUpdate = true;\n\t\t\tthis.textureMaterial.uniforms.resolution = {\n\t\t\t\tvalue: this.pv.resolution,\n\t\t\t};\n\t\t}\n\t\tassemblerController.post_compile();\n\t}\n\n\tcallbackName() {\n\t\treturn `cop/builder3D_${this.graphNodeId()}`;\n\t}\n\t// private _uniformCallbackName() {\n\t// \treturn `cop/builder_uniforms_${this.graphNodeId()}`;\n\t// }\n\toverride dispose() {\n\t\tsuper.dispose();\n\t\tthis._renderTarget?.dispose();\n\t\tthis._renderer?.dispose();\n\t\tthis.removeCallbacks();\n\t}\n\tpublic removeCallbacks() {\n\t\tconst scene = this.scene();\n\t\t// scene.uniformsController.removeTimeUniform(uniforms);\n\t\tscene.unRegisterOnBeforeTick(this.callbackName());\n\t}\n\n\t//\n\t//\n\t// RENDER + RENDER TARGET\n\t//\n\t//\n\tpublic readonly boundRenderOnTarget = this.renderOnTargetWithoutUpdatingTextureFromParams.bind(this);\n\tasync renderOnTargetWithoutUpdatingTextureFromParams() {\n\t\tthis._renderOnTarget(false);\n\t}\n\tprivate async _renderOnTarget(updateTextureFromParams: boolean) {\n\t\tawait this.createRenderTargetIfRequired();\n\t\tawait this._createRendererIfRequired();\n\n\t\tif (this.states.error.active()) {\n\t\t\treturn;\n\t\t}\n\t\tif (!this._renderer) {\n\t\t\tconsole.warn('no renderer');\n\t\t\treturn;\n\t\t}\n\t\tif (!this._uniforms) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis._saveRendererState(this._renderer);\n\t\tthis._prepareRenderer(this._renderer);\n\t\tconst layersCount = this.pv.layers;\n\t\tfor (let i = 0; i < layersCount; i++) {\n\t\t\tthis._uniforms.uLayer.value = i;\n\t\t\tthis._setRenderLayer(this._renderer, i);\n\t\t\tthis._renderer.render(this._textureScene, this._textureCamera);\n\t\t}\n\t\tawait this._postRender(updateTextureFromParams);\n\t\tthis._restoreRendererState(this._renderer);\n\t}\n\tprivate async _postRender(updateTextureFromParams: boolean) {\n\t\tif (this._renderTarget?.texture) {\n\t\t\t// if (isBooleanTrue(this.pv.useDataTexture) && this._renderTarget && this._renderer) {\n\t\t\t// \tthis._dataTextureController = this._dataTextureController || new DataTextureController();\n\t\t\t// \tconst texture = this._dataTextureController.fromRenderTarget(this._renderer, this._renderTarget);\n\t\t\t// \tif (updateTextureFromParams) {\n\t\t\t// \t\tawait this.textureParamsController.update(texture);\n\t\t\t// \t}\n\t\t\t// \tthis.setTexture(texture);\n\t\t\t// } else {\n\t\t\tconst texture = this._renderTarget.texture;\n\t\t\tif (updateTextureFromParams) {\n\t\t\t\t// await this.textureParamsController.update(texture);\n\t\t\t}\n\t\t\tthis.setTexture(texture);\n\t\t\t// }\n\t\t} else {\n\t\t\tthis.cookController.endCook();\n\t\t}\n\t}\n\tprivate _prevTarget: WebGLRenderTarget | null = null;\n\tprivate _prevOutputColorSpace: ColorSpace = NoColorSpace;\n\tprivate _prevToneMapping: ToneMapping = NoToneMapping;\n\tprivate _saveRendererState(renderer: WebGLRenderer) {\n\t\tthis._prevTarget = renderer.getRenderTarget();\n\t\tthis._prevOutputColorSpace = renderer.outputColorSpace;\n\t\tthis._prevToneMapping = renderer.toneMapping;\n\t}\n\tprivate _prepareRenderer(renderer: WebGLRenderer) {\n\t\tif (!this._renderTarget) {\n\t\t\tconsole.warn('no render target');\n\t\t\treturn;\n\t\t}\n\t\trenderer.outputColorSpace = NoColorSpace;\n\t\trenderer.toneMapping = NoToneMapping;\n\t}\n\tprivate _setRenderLayer(renderer: WebGLRenderer, layer: number) {\n\t\tif (!this._renderTarget) {\n\t\t\tconsole.warn('no render target');\n\t\t\treturn;\n\t\t}\n\t\trenderer.setRenderTarget(this._renderTarget, layer);\n\t\trenderer.clear();\n\t}\n\tprivate _restoreRendererState(renderer: WebGLRenderer) {\n\t\trenderer.setRenderTarget(this._prevTarget);\n\t\trenderer.outputColorSpace = this._prevOutputColorSpace;\n\t\trenderer.toneMapping = this._prevToneMapping;\n\t}\n\t/*\n\t *\n\t * RENDERER\n\t *\n\t */\n\tprivate _renderer: WebGLRenderer | undefined;\n\tprivate async _createRendererIfRequired() {\n\t\tif (this._renderer) {\n\t\t\treturn;\n\t\t}\n\t\tif (isBooleanTrue(this.pv.useCameraRenderer)) {\n\t\t\tthis._rendererController = this._rendererController || new CopRendererController(this);\n\t\t\tconst foundRenderer = await this._rendererController.waitForRenderer();\n\t\t\tif (foundRenderer instanceof WebGLRenderer) {\n\t\t\t\tthis._renderer = foundRenderer;\n\t\t\t} else {\n\t\t\t\tconsole.warn('found renderer is not a WebGLRenderer');\n\t\t\t}\n\t\t} else {\n\t\t\tthis._renderer = Poly.renderersController.linearRenderer();\n\t\t}\n\t}\n\tprivate _resetRenderer() {\n\t\tthis._renderer = undefined;\n\t}\n\trenderer() {\n\t\treturn this._renderer;\n\t}\n\t/*\n\t *\n\t * RENDER TARGET\n\t *\n\t */\n\tasync renderTarget() {\n\t\treturn (this._renderTarget =\n\t\t\tthis._renderTarget ||\n\t\t\t(await this._createRenderTarget(this.pv.resolution.x, this.pv.resolution.y, this.pv.layers)));\n\t}\n\tprivate async createRenderTargetIfRequired() {\n\t\tif (!this._renderTarget || !this._renderTargetResolutionValid()) {\n\t\t\tthis._renderTarget = await this._createRenderTarget(\n\t\t\t\tthis.pv.resolution.x,\n\t\t\t\tthis.pv.resolution.y,\n\t\t\t\tthis.pv.layers\n\t\t\t);\n\t\t\tthis._dataTextureController?.reset();\n\t\t}\n\t}\n\tprivate _renderTargetResolutionValid() {\n\t\tif (this._renderTarget) {\n\t\t\tconst image = this._renderTarget.texture.image;\n\t\t\tif (image.width != this.pv.resolution.x || image.height != this.pv.resolution.y) {\n\t\t\t\treturn false;\n\t\t\t} else {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t} else {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\tprivate async _createRenderTarget(width: number, height: number, depth: number) {\n\t\tif (this._renderTarget) {\n\t\t\tconst image = this._renderTarget.texture.image;\n\t\t\tconsole.log(image);\n\t\t\tif (image.width == width && image.height == height && image.depth == depth) {\n\t\t\t\treturn this._renderTarget;\n\t\t\t}\n\t\t}\n\n\t\tconst wrapS = ClampToEdgeWrapping;\n\t\tconst wrapT = ClampToEdgeWrapping;\n\n\t\tconst minFilter = LinearFilter;\n\t\tconst magFilter = NearestFilter;\n\n\t\tconst renderTarget = new WebGLArrayRenderTarget(width, height, depth);\n\t\trenderTarget.texture.wrapS = wrapS;\n\t\trenderTarget.texture.wrapT = wrapT;\n\t\trenderTarget.texture.minFilter = minFilter;\n\t\trenderTarget.texture.magFilter = magFilter;\n\t\trenderTarget.texture.format = RGBAFormat;\n\t\trenderTarget.stencilBuffer = false;\n\t\trenderTarget.depthBuffer = false;\n\n\t\t// await this.textureParamsController.update(renderTarget.texture);\n\t\tPoly.warn(`${this.path()}: created WebGLArrayRenderTarget`, this.path(), width, height, depth);\n\t\treturn renderTarget;\n\t}\n\n\t/*\n\t *\n\t * CALLBACK\n\t *\n\t */\n\tstatic PARAM_CALLBACK_render(node: Builder2DArrayCopNode) {\n\t\tnode._renderOnTarget(true);\n\t}\n\tstatic PARAM_CALLBACK_resetRenderer(node: Builder2DArrayCopNode) {\n\t\tnode._resetRenderer();\n\t}\n}\n","/**\n * Generates a color\n *\n *\n */\nimport {TypedCopNode} from './_Base';\nimport {DataTexture} from 'three';\nimport {NodeParamsConfig, ParamConfig} from '../utils/params/ParamsConfig';\nimport {BaseNodeType} from '../_Base';\n\nclass ColorCopParamsConfig extends NodeParamsConfig {\n\t/** @param texture resolution */\n\tresolution = ParamConfig.VECTOR2([256, 256], {\n\t\tcallback: (node: BaseNodeType) => {\n\t\t\tColorCopNode.PARAM_CALLBACK_reset(node as ColorCopNode);\n\t\t},\n\t});\n\t/** @param color to generate */\n\tcolor = ParamConfig.COLOR([1, 1, 1]);\n\t/** @param alpha */\n\talpha = ParamConfig.FLOAT(1, {\n\t\trange: [0, 1],\n\t});\n}\nconst ParamsConfig = new ColorCopParamsConfig();\n\nexport class ColorCopNode extends TypedCopNode<ColorCopParamsConfig> {\n\toverride paramsConfig = ParamsConfig;\n\tstatic override type() {\n\t\treturn 'color';\n\t}\n\tprivate _dataTexture: DataTexture | undefined;\n\n\toverride cook() {\n\t\tconst w = this.pv.resolution.x;\n\t\tconst h = this.pv.resolution.y;\n\t\tthis._dataTexture = this._dataTexture || this._createDataTexture(w, h);\n\n\t\tconst bufferSize = 4 * h * w;\n\t\tconst c = this.pv.color.toArray();\n\t\tconst r = c[0] * 255;\n\t\tconst g = c[1] * 255;\n\t\tconst b = c[2] * 255;\n\t\t// const a = 255;\n\t\tconst data = this._dataTexture.image.data;\n\t\tfor (let i = 0; i < bufferSize; i += 4) {\n\t\t\tdata[i + 0] = r;\n\t\t\tdata[i + 1] = g;\n\t\t\tdata[i + 2] = b;\n\t\t\t// data[i * 4 + 3] = a;\n\t\t}\n\t\tthis._dataTexture.needsUpdate = true;\n\n\t\tthis.setTexture(this._dataTexture);\n\t}\n\n\tprivate _createDataTexture(width: number, height: number) {\n\t\tconst pixel_buffer = this._createPixelBuffer(width, height);\n\t\treturn new DataTexture(pixel_buffer, width, height);\n\t}\n\tprivate _createPixelBuffer(width: number, height: number) {\n\t\tconst size = width * height * 4;\n\n\t\tconst buffer = new Uint8Array(size);\n\t\tbuffer.fill(this.pv.alpha * 255);\n\t\treturn buffer;\n\t}\n\n\tstatic PARAM_CALLBACK_reset(node: ColorCopNode) {\n\t\tnode._reset();\n\t}\n\tprivate _reset() {\n\t\tthis._dataTexture = undefined;\n\t}\n}\n","/**\n * Creates a Texture from a CubeCamera\n *\n *\t@remarks\n *\n * See the [COP/CubeCamera](https://polygonjs.com/docs/nodes/cop/CubeCamera) on how to use it as a texture.\n */\n\nimport {TypedCopNode} from './_Base';\nimport {NodeParamsConfig, ParamConfig} from '../utils/params/ParamsConfig';\nimport {CubeCamera, CubeReflectionMapping, CubeRefractionMapping, Texture, WebGLRenderer} from 'three';\nimport {CopType} from '../../poly/registers/nodes/types/Cop';\nimport {BaseNodeType} from '../_Base';\nimport {isBooleanTrue} from '../../../core/Type';\nimport {CopRendererController} from './utils/RendererController';\n\nenum MapMode {\n\tREFLECTION = 'reflection',\n\tREFRACTION = 'refraction',\n}\nconst MAP_MODES: MapMode[] = [MapMode.REFLECTION, MapMode.REFRACTION];\nclass CubeCameraCopParamsConfig extends NodeParamsConfig {\n\t/** @param cube camera OBJ node */\n\tcameraPath = ParamConfig.STRING('*cubeCamera*', {\n\t\tobjectMask: true,\n\t});\n\t/** @param objects to render */\n\t// objects = ParamConfig.STRING('/', {\n\t// \tobjectMask: true,\n\t// });\n\t/** @param defines if the texture is used for reflection or refraction */\n\tmode = ParamConfig.INTEGER(0, {\n\t\tmenu: {\n\t\t\tentries: MAP_MODES.map((name, value) => {\n\t\t\t\treturn {name, value};\n\t\t\t}),\n\t\t},\n\t});\n\t/** @param transparent background */\n\ttransparentBackground = ParamConfig.BOOLEAN(1);\n\t/** @param bg Color */\n\tbackgroundColor = ParamConfig.COLOR([0, 0, 0], {\n\t\tvisibleIf: {\n\t\t\ttransparentBackground: 0,\n\t\t},\n\t});\n\t/** @param autoRender */\n\tautoRender = ParamConfig.BOOLEAN(1);\n\t/** @param render button */\n\trender = ParamConfig.BUTTON(null, {\n\t\tcallback: (node: BaseNodeType) => {\n\t\t\tCubeCameraCopNode.PARAM_CALLBACK_render(node as CubeCameraCopNode);\n\t\t},\n\t});\n}\nconst ParamsConfig = new CubeCameraCopParamsConfig();\nexport class CubeCameraCopNode extends TypedCopNode<CubeCameraCopParamsConfig> {\n\toverride paramsConfig = ParamsConfig;\n\tstatic override type() {\n\t\treturn CopType.CUBE_CAMERA;\n\t}\n\n\tprivate _rendererController: CopRendererController | undefined;\n\n\toverride async cook() {\n\t\tif (isBooleanTrue(this.pv.autoRender)) {\n\t\t\tthis._addOnBeforeTickCallback();\n\t\t} else {\n\t\t\tthis._removeOnBeforeTickCallback();\n\t\t}\n\n\t\tconst texture = await this.renderOnTarget(false);\n\t\tif (texture) {\n\t\t\tconst mode = MAP_MODES[this.pv.mode];\n\t\t\tswitch (mode) {\n\t\t\t\tcase MapMode.REFLECTION:\n\t\t\t\t\ttexture.mapping = CubeReflectionMapping;\n\t\t\t\t\tbreak;\n\t\t\t\tcase MapMode.REFRACTION:\n\t\t\t\t\ttexture.mapping = CubeRefractionMapping;\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\t// not needed, as it is called inside .renderOnTarget\n\t\t\t// this.setTexture(texture);\n\t\t} else {\n\t\t\tthis.cookController.endCook();\n\t\t}\n\t}\n\t//\n\t//\n\t// AUTO RENDER\n\t//\n\t//\n\tprivate _addOnBeforeTickCallback() {\n\t\tconst callbackName = this._onBeforeRenderCallbackName();\n\t\tif (this.scene().hasBeforeTickCallback(callbackName)) {\n\t\t\treturn;\n\t\t}\n\t\tthis.scene().registerOnBeforeTick(callbackName, this._renderOnTargetBound);\n\t}\n\tprivate _removeOnBeforeTickCallback() {\n\t\tthis.scene().unRegisterOnBeforeTick(this._onBeforeRenderCallbackName());\n\t}\n\tprivate _onBeforeRenderCallbackName() {\n\t\treturn `cop/render_onBeforeTickCallback-${this.graphNodeId()}`;\n\t}\n\toverride dispose() {\n\t\tsuper.dispose();\n\t\tthis._removeOnBeforeTickCallback();\n\t}\n\n\t//\n\t//\n\t// RENDER + RENDER TARGET\n\t//\n\t//\n\tprivate _getCameraSync() {\n\t\treturn this.scene().objectsController.findObjectByMask(this.pv.cameraPath) as CubeCamera | undefined;\n\t}\n\tprivate async _getCamera(): Promise<CubeCamera | CubeCamera | undefined> {\n\t\tconst camera = this._getCameraSync();\n\t\tif (camera) {\n\t\t\treturn camera;\n\t\t}\n\t\treturn new Promise((resolve) => {\n\t\t\tthis.scene().camerasController.onCameraObjectsUpdated(async () => {\n\t\t\t\tconst camera = this._getCameraSync();\n\t\t\t\tif (camera) {\n\t\t\t\t\tresolve(camera);\n\t\t\t\t}\n\t\t\t});\n\t\t});\n\t}\n\t// private previousParentByObject: WeakMap<Object3D, Object3D | null> = new WeakMap();\n\tprivate _renderOnTargetBound = () => this.renderOnTarget(true);\n\tprivate _prevCamera: CubeCamera | undefined;\n\tprivate _prevRenderer: WebGLRenderer | undefined;\n\tasync renderOnTarget(setDirtyIfChangesDetected: boolean): Promise<Texture | undefined> {\n\t\tconst camera = await this._getCamera();\n\t\tif (!camera) {\n\t\t\tconsole.warn(`${this.path()}: no camera found`);\n\t\t\treturn;\n\t\t}\n\t\tthis._rendererController = this._rendererController || new CopRendererController(this);\n\t\tconst renderer = await this._rendererController.waitForRenderer();\n\t\tif (!renderer) {\n\t\t\treturn;\n\t\t}\n\t\t// ensure materials using this texture are updated\n\t\tif ((setDirtyIfChangesDetected == true && this._prevCamera != camera) || renderer != this._prevRenderer) {\n\t\t\tthis.setDirty();\n\t\t\tthis._prevCamera = camera;\n\t\t\tthis._prevRenderer = renderer;\n\t\t}\n\n\t\tconst scene = this.scene().threejsScene();\n\t\t// save state\n\t\tconst prevBackground = scene.background;\n\t\tscene.background = this.pv.transparentBackground ? null : this.pv.backgroundColor;\n\n\t\t// render\n\t\tcamera.update(renderer, scene);\n\n\t\t// restore state\n\t\tscene.background = prevBackground;\n\n\t\t// make sure to set the texture here,\n\t\t// otherwise it will not be replaced when the renderer changes\n\t\tconst texture = camera.renderTarget.texture;\n\t\tthis.setTexture(texture);\n\n\t\treturn texture;\n\t}\n\t// private _renderTarget: WebGLRenderTarget | undefined;\n\tasync renderTarget() {\n\t\tconst camera = await this._getCamera();\n\t\treturn camera?.renderTarget.texture;\n\t}\n\n\t//\n\t//\n\t// CALLBACK\n\t//\n\t//\n\tstatic PARAM_CALLBACK_render(node: CubeCameraCopNode) {\n\t\tnode.renderOnTarget(true);\n\t}\n}\n","/**\n * Imports a gif file.\n *\n */\nimport {ParamEvent} from './../../poly/ParamEvent';\nimport {Constructor} from '../../../types/GlobalTypes';\nimport {Texture} from 'three';\nimport {TypedCopNode} from './_Base';\nimport {CoreLoaderTexture} from '../../../core/loader/Texture';\nimport {BaseNodeType} from '../_Base';\nimport {BaseParamType} from '../../params/_Base';\nimport {NodeParamsConfig, ParamConfig} from '../utils/params/ParamsConfig';\nimport {TextureParamsController, TextureParamConfig} from './utils/TextureParamsController';\nimport {InputCloneMode} from '../../poly/InputCloneMode';\nimport {CanvasTexture} from 'three';\nimport {parseGIF, decompressFrames, ParsedFrame} from 'gifuct-js';\nimport {isBooleanTrue} from '../../../core/BooleanValue';\nimport {isUrlGif} from '../../../core/FileTypeController';\nimport {CopType} from '../../poly/registers/nodes/types/Cop';\nimport {EXTENSIONS_BY_NODE_TYPE_BY_CONTEXT} from '../../../core/loader/FileExtensionRegister';\nimport {NodeContext} from '../../poly/NodeContext';\n\nexport function GifCopParamConfig<TBase extends Constructor>(Base: TBase) {\n\treturn class Mixin extends Base {\n\t\t/** @param url to fetch the gif from */\n\t\turl = ParamConfig.STRING('', {\n\t\t\tfileBrowse: {extensions: EXTENSIONS_BY_NODE_TYPE_BY_CONTEXT[NodeContext.COP][CopType.GIF]},\n\t\t});\n\t\t/** @param reload the image */\n\t\treload = ParamConfig.BUTTON(null, {\n\t\t\tcallback: (node: BaseNodeType, param: BaseParamType) => {\n\t\t\t\tGifCopNode.PARAM_CALLBACK_reload(node as GifCopNode);\n\t\t\t},\n\t\t});\n\t\t/** @param play the gif */\n\t\tplay = ParamConfig.BOOLEAN(1, {\n\t\t\tcook: false,\n\t\t\tcallback: (node: BaseNodeType) => {\n\t\t\t\tGifCopNode.PARAM_CALLBACK_gifUpdatePlay(node as GifCopNode);\n\t\t\t},\n\t\t});\n\t\t/** @param set the gif frame */\n\t\tgifFrame = ParamConfig.INTEGER(0, {\n\t\t\tcook: false,\n\t\t\trange: [0, 100],\n\t\t\trangeLocked: [true, false],\n\t\t\tcallback: (node: BaseNodeType) => {\n\t\t\t\tGifCopNode.PARAM_CALLBACK_gifUpdateFrameIndex(node as GifCopNode);\n\t\t\t},\n\t\t});\n\t};\n}\nclass GifCopParamsConfig extends TextureParamConfig(GifCopParamConfig(NodeParamsConfig)) {}\n\nconst ParamsConfig = new GifCopParamsConfig();\n\nexport class GifCopNode extends TypedCopNode<GifCopParamsConfig> {\n\toverride paramsConfig = ParamsConfig;\n\tstatic override type() {\n\t\treturn CopType.GIF;\n\t}\n\n\tpublic readonly textureParamsController: TextureParamsController = new TextureParamsController(this);\n\n\toverride initializeNode() {\n\t\tthis.io.inputs.setCount(0, 1);\n\t\tthis.io.inputs.initInputsClonedState(InputCloneMode.NEVER);\n\t}\n\toverride async cook(input_contents: Texture[]) {\n\t\tconst url = this.pv.url;\n\t\tif (!isUrlGif(url)) {\n\t\t\tthis.states.error.set('url is not an image');\n\t\t} else {\n\t\t\tCoreLoaderTexture.incrementInProgressLoadsCount();\n\t\t\tawait CoreLoaderTexture.waitForMaxConcurrentLoadsQueueFreed();\n\n\t\t\tconst response = await fetch(url);\n\t\t\tconst buffer = await response.arrayBuffer();\n\t\t\tconst gif = await parseGIF(buffer);\n\t\t\tconst buildImagePatches = true;\n\t\t\tthis._parsedFrames = await decompressFrames(gif, buildImagePatches);\n\t\t\tconst firstFrame = this._parsedFrames[0];\n\t\t\tthis._frameDelay = firstFrame.delay;\n\t\t\tthis._frameIndex = this.pv.gifFrame - 1;\n\n\t\t\tthis._createCanvas();\n\t\t\tconst texture = this._gifCanvasElement ? new CanvasTexture(this._gifCanvasElement) : undefined;\n\t\t\tCoreLoaderTexture.decrementInProgressLoadsCount(url, texture);\n\t\t\tif (texture) {\n\t\t\t\tawait this.textureParamsController.update(texture);\n\t\t\t\tthis.setTexture(texture);\n\t\t\t} else {\n\t\t\t\tthis.states.error.set('failed to create canvas');\n\t\t\t}\n\t\t}\n\t}\n\tprivate _gifCanvasElement: HTMLCanvasElement | undefined;\n\tprivate _gifCanvasContext: CanvasRenderingContext2D | null = null;\n\tprivate _tmpCanvasElement: HTMLCanvasElement | undefined;\n\tprivate _tmpCanvasContext: CanvasRenderingContext2D | null = null;\n\tprivate _parsedFrames: ParsedFrame[] = [];\n\tprivate _frameDelay = 100;\n\tprivate _frameIndex = 0;\n\tprivate _frameImageData: ImageData | undefined;\n\tprivate _createCanvas() {\n\t\tconst gifFrame = this._parsedFrames[0];\n\t\tthis._gifCanvasElement = document.createElement('canvas');\n\t\tthis._tmpCanvasElement = document.createElement('canvas');\n\t\tthis._gifCanvasElement.width = gifFrame.dims.width;\n\t\tthis._gifCanvasElement.height = gifFrame.dims.height;\n\t\tthis._tmpCanvasElement.width = gifFrame.dims.width;\n\t\tthis._tmpCanvasElement.height = gifFrame.dims.height;\n\t\tthis._gifCanvasContext = this._gifCanvasElement.getContext('2d');\n\t\tthis._tmpCanvasContext = this._tmpCanvasElement.getContext('2d');\n\t\tthis._drawNextFrame();\n\t}\n\n\tprivate _drawOnCanvas() {\n\t\tif (!(this._gifCanvasContext && this._tmpCanvasElement && this._tmpCanvasContext)) {\n\t\t\treturn;\n\t\t}\n\t\tlet gifFrame = this._parsedFrames[this._frameIndex];\n\t\tif (!gifFrame) {\n\t\t\tconsole.warn(`no frame at index ${this._frameIndex}, using last frame`);\n\t\t\tgifFrame = this._parsedFrames[this._parsedFrames.length - 1];\n\t\t}\n\t\tif (gifFrame) {\n\t\t\tconst dims = gifFrame.dims;\n\t\t\tif (\n\t\t\t\t!this._frameImageData ||\n\t\t\t\tdims.width != this._frameImageData.width ||\n\t\t\t\tdims.height != this._frameImageData.height\n\t\t\t) {\n\t\t\t\tthis._tmpCanvasElement.width = dims.width;\n\t\t\t\tthis._tmpCanvasElement.height = dims.height;\n\t\t\t\tthis._frameImageData = this._tmpCanvasContext.createImageData(dims.width, dims.height);\n\t\t\t}\n\n\t\t\tthis._frameImageData.data.set(gifFrame.patch);\n\t\t\tthis._tmpCanvasContext.putImageData(this._frameImageData, 0, 0);\n\t\t\tthis._gifCanvasContext.drawImage(this._tmpCanvasElement, dims.left, dims.top);\n\t\t\tconst texture = this.containerController.container().texture();\n\t\t\tif (!texture) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\ttexture.needsUpdate = true;\n\t\t}\n\t}\n\tprivate _drawNextFrame() {\n\t\tthis._frameIndex++;\n\t\tif (this._frameIndex >= this._parsedFrames.length) {\n\t\t\tthis._frameIndex = 0;\n\t\t}\n\t\tthis._drawOnCanvas();\n\t\tif (isBooleanTrue(this.pv.play)) {\n\t\t\tsetTimeout(() => {\n\t\t\t\tthis._drawNextFrame();\n\t\t\t}, this._frameDelay);\n\t\t}\n\t}\n\tprivate gifUpdateFrameIndex() {\n\t\tthis._frameIndex = this.pv.gifFrame;\n\t\tthis._drawOnCanvas();\n\t}\n\n\t//\n\t//\n\t// UTILS\n\t//\n\t//\n\tstatic PARAM_CALLBACK_reload(node: GifCopNode) {\n\t\tnode.paramCallbackReload();\n\t}\n\tprivate paramCallbackReload() {\n\t\t// set the param dirty is preferable to just the successors, in case the expression result needs to be updated\n\t\t// this.p.url.set_successors_dirty();\n\t\tthis.p.url.setDirty();\n\t\tthis.p.url.emit(ParamEvent.ASSET_RELOAD_REQUEST);\n\t}\n\tstatic PARAM_CALLBACK_gifUpdatePlay(node: GifCopNode) {\n\t\tnode.gifUpdatePlay();\n\t}\n\tprivate gifUpdatePlay() {\n\t\tif (isBooleanTrue(this.pv.play)) {\n\t\t\tthis._drawNextFrame();\n\t\t}\n\t}\n\tstatic PARAM_CALLBACK_gifUpdateFrameIndex(node: GifCopNode) {\n\t\tnode.gifUpdateFrameIndex();\n\t}\n}\n","import {BaseNodeType} from '../../../engine/nodes/_Base';\nimport {ASSETS_ROOT} from './../AssetsUtils';\nimport {BaseCoreImageLoader, BaseImageLoader, TextureLoadOptions} from './_BaseImageLoader';\nimport {RGBELoader} from 'three/examples/jsm/loaders/RGBELoader';\n\nexport class HDRTextureLoader extends BaseCoreImageLoader {\n\tstatic PARAM_ENV_DEFAULT = `${ASSETS_ROOT}/textures/studio_small_09_2k.hdr`;\n\n\tconstructor(_url: string, _node: BaseNodeType) {\n\t\tsuper(_url, _node);\n\t}\n\n\tprotected async _getLoader(options: TextureLoadOptions) {\n\t\tconst loader = new RGBELoader(this.loadingManager);\n\t\tif (options.tdataType) {\n\t\t\tloader.setDataType(options.dataType);\n\t\t}\n\t\treturn loader as BaseImageLoader;\n\t}\n}\n","/**\n * Imports an HDR image file.\n *\n * @remarks\n * Performance tip: If possible, try to set min filter to LinearFilter in order to avoid the generation of mipmaps.\n * [https://discourse.threejs.org/t/threejs-app-performance-point-click-game/18491](https://discourse.threejs.org/t/threejs-app-performance-point-click-game/18491)\n */\n\nimport {copImageNodeFactoryFactory} from './utils/image/_BaseImage';\nimport {HDRTextureLoader} from '../../../core/loader/texture/HDR';\nimport {BaseNodeType} from '../_Base';\nimport {CopTypeImage} from '../../poly/registers/nodes/types/Cop';\nimport {EXTENSIONS_BY_NODE_TYPE_BY_CONTEXT} from '../../../core/loader/FileExtensionRegister';\nimport {NodeContext} from '../../poly/NodeContext';\n\nexport class ImageHDRCopNode extends copImageNodeFactoryFactory({\n\ttype: CopTypeImage.IMAGE_HDR,\n\tdefaultUrl: HDRTextureLoader.PARAM_ENV_DEFAULT,\n\textensions: EXTENSIONS_BY_NODE_TYPE_BY_CONTEXT[NodeContext.COP][CopTypeImage.IMAGE_HDR],\n\tgetLoader: (url: string, node: BaseNodeType) => new HDRTextureLoader(url, node),\n}) {}\n","/**\n * Imports a KTX2 image file.\n *\n * @remarks\n * Performance tip: If possible, try to set min filter to LinearFilter in order to avoid the generation of mipmaps.\n * [https://discourse.threejs.org/t/threejs-app-performance-point-click-game/18491](https://discourse.threejs.org/t/threejs-app-performance-point-click-game/18491)\n */\n\nimport {copImageNodeFactoryFactory} from './utils/image/_BaseImage';\nimport {KTX2TextureLoader} from '../../../core/loader/texture/KTX2';\nimport {BaseNodeType} from '../_Base';\nimport {CopTypeImage} from '../../poly/registers/nodes/types/Cop';\nimport {EXTENSIONS_BY_NODE_TYPE_BY_CONTEXT} from '../../../core/loader/FileExtensionRegister';\nimport {NodeContext} from '../../poly/NodeContext';\n\nexport class ImageKTX2CopNode extends copImageNodeFactoryFactory({\n\ttype: CopTypeImage.IMAGE_KTX2,\n\tdefaultUrl: KTX2TextureLoader.PARAM_ENV_DEFAULT,\n\textensions: EXTENSIONS_BY_NODE_TYPE_BY_CONTEXT[NodeContext.COP][CopTypeImage.IMAGE_KTX2],\n\tgetLoader: (url: string, node: BaseNodeType) => new KTX2TextureLoader(url, node),\n}) {}\n","import {Material, Object3D, Matrix4, Vector3} from 'three';\nimport {CoreUserAgent} from '../../../../../core/UserAgent';\nimport {HalfFloatType, FloatType, RGBAFormat} from 'three';\n\nexport interface ObjectState {\n\tmaterial: Material | Material[];\n\tfrustumCulled: boolean;\n\tparent: Object3D | null;\n\trenderOrder: number;\n\t// castShadow: boolean;\n\t// receiveShadow: boolean;\n\t// inverted: boolean;\n}\nexport interface LightHierarchyState {\n\tmatrixAutoUpdate: boolean;\n\tparent: Object3D | null;\n}\nexport interface LightMatrixState {\n\tmatrix: Matrix4;\n\tposition: Vector3;\n}\n\nexport interface LightMapControllerParams {\n\tresolution: number;\n\tlightRadius: number;\n\ttotalIterationsCount: number;\n\t// iterationBlend: number;\n\tblur: boolean;\n\tblurAmount: number;\n}\n// export const DEFAULT_ITERATION_BLEND = 1 / 200;\nconst isAndroidOriOS = CoreUserAgent.isAndroid() || CoreUserAgent.isiOS();\nexport const renderTargetType = isAndroidOriOS ? HalfFloatType : FloatType;\nexport const renderTargetFormat = RGBAFormat;\nexport const RENDER_TARGET_DEFAULT_SIZE = 1;\n","import {WebGLRenderTarget, MeshBasicMaterial, Texture} from 'three';\n\nexport interface BlurMaterial extends MeshBasicMaterial {\n\tuniforms: {\n\t\tpreviousLightMap: {value: Texture | null};\n\t\tpixelOffset: {value: number};\n\t\t// polygonOffset: true,\n\t\t// polygonOffsetFactor: -1,\n\t\t// polygonOffsetUnits: 3.0,\n\t};\n}\nexport interface BlurMatOptions {\n\tres: number;\n\tlightMap: WebGLRenderTarget;\n}\nexport function setBlurMaterial(mat: BlurMaterial, options: BlurMatOptions) {\n\tmat.uniforms.previousLightMap.value = options.lightMap.texture;\n\tmat.uniforms.pixelOffset.value = 1.0 / options.res;\n}\n\nexport function createBlurMaterial() {\n\tconst blurMaterial = new MeshBasicMaterial() as BlurMaterial;\n\tblurMaterial.uniforms = {\n\t\tpreviousLightMap: {value: null},\n\t\tpixelOffset: {value: 1.0},\n\t\t// TODO: make sure this is not important\n\t\t// polygonOffset: true,\n\t\t// polygonOffsetFactor: -1,\n\t\t// polygonOffsetUnits: 3.0,\n\t};\n\tblurMaterial.polygonOffset = true;\n\tblurMaterial.polygonOffsetFactor = -1;\n\tblurMaterial.polygonOffsetUnits = 3.0;\n\n\tblurMaterial.onBeforeCompile = (shader) => {\n\t\t// Vertex Shader: Set Vertex Positions to the Unwrapped UV Positions\n\t\tshader.vertexShader = `\n#define USE_UV\n${shader.vertexShader.slice(0, -2)}\n\tgl_Position = vec4((uv - 0.5) * 2.0, 1.0, 1.0);\n}\n`;\n\t\tconst bodyStart = shader.fragmentShader.indexOf('void main() {');\n\t\tshader.fragmentShader = `\n#define USE_UV\n${shader.fragmentShader.slice(0, bodyStart)}\nuniform sampler2D previousLightMap;\nuniform float pixelOffset;\n${shader.fragmentShader.slice(bodyStart - 1, -2)}\n\tgl_FragColor.rgb = (\n\t\ttexture2D(previousLightMap, vUv + vec2( pixelOffset,  0.0        )).rgb +\n\t\ttexture2D(previousLightMap, vUv + vec2( 0.0        ,  pixelOffset)).rgb +\n\t\ttexture2D(previousLightMap, vUv + vec2( 0.0        , -pixelOffset)).rgb +\n\t\ttexture2D(previousLightMap, vUv + vec2(-pixelOffset,  0.0        )).rgb +\n\t\ttexture2D(previousLightMap, vUv + vec2( pixelOffset,  pixelOffset)).rgb +\n\t\ttexture2D(previousLightMap, vUv + vec2(-pixelOffset,  pixelOffset)).rgb +\n\t\ttexture2D(previousLightMap, vUv + vec2( pixelOffset, -pixelOffset)).rgb +\n\t\ttexture2D(previousLightMap, vUv + vec2(-pixelOffset, -pixelOffset)).rgb\n\t) / 8.0;\n}`;\n\n\t\t// Set the LightMap Accumulation Buffer\n\t\t// const uniforms = {\n\t\t// \tpreviousShadowMap: {value: lightMap.texture},\n\t\t// \tpixelOffset: {value: 0.5 / res},\n\t\t// };\n\t\tshader.uniforms.previousLightMap = blurMaterial.uniforms.previousLightMap;\n\t\tshader.uniforms.pixelOffset = blurMaterial.uniforms.pixelOffset;\n\t\t// blurMaterial.uniforms.previousShadowMap = uniforms.previousShadowMap;\n\t\t// blurMaterial.uniforms.pixelOffset = uniforms.pixelOffset;\n\n\t\t// Set the new Shader to this\n\t\tblurMaterial.userData.shader = shader;\n\t};\n\treturn blurMaterial;\n}\n","import {Mesh, PlaneGeometry} from 'three';\nimport {createBlurMaterial} from './BlurMaterial';\n\nexport function createBlurPlane() {\n\tconst mat = createBlurMaterial();\n\n\tconst plane = new Mesh(new PlaneGeometry(1, 1), mat);\n\tplane.name = 'Blurring Plane';\n\tplane.frustumCulled = false;\n\tplane.renderOrder = 0;\n\tmat.depthWrite = false;\n\treturn {plane, mat};\n}\n","import {ShaderMaterial, WebGLRenderTarget, Texture} from 'three';\nexport const UV_LIGHT_MAP_FLIPPED_ATTRIB_NAME = 'uvLightmapFlipped';\n\nexport interface RenderTargetsCombineMaterial extends ShaderMaterial {\n\tuniforms: {\n\t\trt1: {value: Texture | null};\n\t\trt2: {value: Texture | null};\n\t};\n}\nexport interface RenderTargetsCombineMatOptions {\n\trt1: WebGLRenderTarget;\n\trt2: WebGLRenderTarget;\n}\nexport function setRenderTargetsCombineMaterial(\n\tmat: RenderTargetsCombineMaterial,\n\toptions: RenderTargetsCombineMatOptions\n) {\n\tmat.uniforms.rt1.value = options.rt1.texture;\n\tmat.uniforms.rt2.value = options.rt2.texture;\n}\n\nexport function createRenderTargetsCombineMaterial() {\n\tconst mat = new ShaderMaterial() as RenderTargetsCombineMaterial;\n\tmat.uniforms = {\n\t\trt1: {value: null},\n\t\trt2: {value: null},\n\t};\n\tmat.name = 'renderTargetsCombineMaterial';\n\tmat.onBeforeCompile = (shader) => {\n\t\tshader.vertexShader = `\nvarying vec2 vUv;\nvoid main(){\n\tvUv = uv;\n\tgl_Position = vec4((uv - 0.5) * 2.0, 1.0, 1.0);\n}`;\n\n\t\t// const bodyStart = shader.fragmentShader.indexOf('void main() {');\n\t\tshader.fragmentShader = `\nuniform sampler2D rt1;\nuniform sampler2D rt2;\nvarying vec2 vUv;\nvoid main(){\n\tvec3 rt1Value = texture2D(rt1, vUv).rgb;\n\tvec3 rt2Value = texture2D(rt2, vUv).rgb;\n\tgl_FragColor.rgb = rt1Value + rt2Value;\n}\n`;\n\n\t\tshader.uniforms.rt1 = mat.uniforms.rt1;\n\t\tshader.uniforms.rt2 = mat.uniforms.rt2;\n\n\t\t// Set the new Shader to this\n\t\tmat.userData.shader = shader;\n\t};\n\treturn mat;\n}\n","import {Mesh, PlaneGeometry} from 'three';\nimport {createRenderTargetsCombineMaterial} from './RenderTargetsCombineMaterial';\n\nexport function createRenderTargetsCombinePlane() {\n\tconst mat = createRenderTargetsCombineMaterial();\n\n\tconst plane = new Mesh(new PlaneGeometry(1, 1), mat);\n\tplane.name = 'RenderTargetsCombine Plane';\n\tplane.frustumCulled = false;\n\tplane.renderOrder = 0;\n\tmat.depthWrite = false;\n\treturn {plane, mat};\n}\n","import {Object3D, Mesh} from 'three';\nexport function invertNormals(object: Object3D) {\n\tconst geometry = (object as Mesh).geometry;\n\tif (!geometry) {\n\t\treturn;\n\t}\n\n\t// invert indices\n\t// const index = geometry.getIndex();\n\t// if (!index) {\n\t// \treturn;\n\t// }\n\t// const indexArray = index.array as number[];\n\t// const polyCount = indexArray.length / 3;\n\t// let tmp: number = -1;\n\t// for (let i = 0; i < polyCount; i++) {\n\t// \ttmp = indexArray[i * 3];\n\t// \tindexArray[i * 3] = indexArray[i * 3 + 2];\n\t// \tindexArray[i * 3 + 2] = tmp;\n\t// }\n\t// index.needsUpdate = true;\n\n\t// invert normals\n\tconst normalAttribute = geometry.getAttribute('normal');\n\tconst array = normalAttribute.array;\n\tconst length = array.length;\n\tfor (let i = 0; i < length; i++) {\n\t\tarray[i] *= -1;\n\t}\n\tnormalAttribute.needsUpdate = true;\n}\n","import {RENDER_TARGET_DEFAULT_SIZE, renderTargetType, renderTargetFormat} from './Common';\nimport {WebGLRenderTarget} from 'three';\nexport class RenderTargetPair {\n\tprivate pingPong = false;\n\tprivate RT1 = new WebGLRenderTarget(RENDER_TARGET_DEFAULT_SIZE, RENDER_TARGET_DEFAULT_SIZE, {\n\t\ttype: renderTargetType,\n\t\tformat: renderTargetFormat,\n\t});\n\tprivate RT2 = new WebGLRenderTarget(RENDER_TARGET_DEFAULT_SIZE, RENDER_TARGET_DEFAULT_SIZE, {\n\t\ttype: renderTargetType,\n\t\tformat: renderTargetFormat,\n\t});\n\tconstructor() {}\n\tsetSize(x: number, w: number) {\n\t\tthis.RT1.setSize(x, w);\n\t\tthis.RT2.setSize(x, w);\n\t}\n\ttoggle() {\n\t\tthis.pingPong = !this.pingPong;\n\t}\n\tprevious() {\n\t\treturn this.pingPong ? this.RT1 : this.RT2;\n\t}\n\tcurrent() {\n\t\treturn this.pingPong ? this.RT2 : this.RT1;\n\t}\n}\n","//\n// adapted from https://threejs.org/examples/?q=light#webgl_shadowmap_progressive\n//\nimport {\n\tQuaternion,\n\tVector3,\n\tLight,\n\tCamera,\n\tWebGLRenderer,\n\tObject3D,\n\tMesh,\n\tWebGLRenderTarget,\n\tScene,\n\tBackSide,\n\tFrontSide,\n\tDoubleSide,\n\t// Color,\n} from 'three';\nimport {\n\tLightMapControllerParams,\n\tObjectState,\n\tLightHierarchyState,\n\tLightMatrixState,\n\tRENDER_TARGET_DEFAULT_SIZE,\n\trenderTargetFormat,\n\trenderTargetType,\n} from './lightMap/Common';\nimport {BlurMaterial, setBlurMaterial} from './lightMap/BlurMaterial';\nimport {createBlurPlane} from './lightMap/BlurPlane';\nimport {RenderTargetsCombineMaterial, setRenderTargetsCombineMaterial} from './lightMap/RenderTargetsCombineMaterial';\nimport {createRenderTargetsCombinePlane} from './lightMap/RenderTargetsCombinePlane';\nimport {createLightMapMaterial, LightMapMaterial, setLightMapMaterial} from './lightMap/LightMapMaterial';\nimport {invertNormals} from './lightMap/LightMapUtils';\nimport {RenderTargetPair} from './lightMap/RenderTargetPair';\n\nexport class LightMapController {\n\tprivate objectTargets: Mesh[] = [];\n\tprivate lights: Light[] = [];\n\tprivate _scene = new Scene();\n\tprivate renderFlippedUvs = false;\n\tprivate nonFlippedRenderTargetPair: RenderTargetPair = new RenderTargetPair();\n\tprivate flippedRenderTargetPair: RenderTargetPair = new RenderTargetPair();\n\tprivate lightMapMaterial: LightMapMaterial;\n\tprivate blurMaterial: BlurMaterial;\n\tprivate blurPlane: Mesh;\n\tprivate renderTargetsCombineMaterial: RenderTargetsCombineMaterial;\n\tprivate renderTargetsCombinePlane: Mesh;\n\tprivate finalRenderTarget = new WebGLRenderTarget(RENDER_TARGET_DEFAULT_SIZE, RENDER_TARGET_DEFAULT_SIZE, {\n\t\ttype: renderTargetType,\n\t\tformat: renderTargetFormat,\n\t});\n\tprivate _params: LightMapControllerParams = {\n\t\tresolution: 1,\n\t\tlightRadius: 1,\n\t\ttotalIterationsCount: 1,\n\t\tblur: false,\n\t\tblurAmount: 0,\n\t};\n\tconstructor(private renderer: WebGLRenderer) {\n\t\tthis.lightMapMaterial = createLightMapMaterial();\n\n\t\tconst blurPlaneData = createBlurPlane();\n\t\tthis.blurPlane = blurPlaneData.plane;\n\t\tthis.blurMaterial = blurPlaneData.mat;\n\n\t\tconst renderTargetsCombinePlaneData = createRenderTargetsCombinePlane();\n\t\tthis.renderTargetsCombinePlane = renderTargetsCombinePlaneData.plane;\n\t\tthis.renderTargetsCombineMaterial = renderTargetsCombinePlaneData.mat;\n\t}\n\tprivate setSize(w: number, h: number) {\n\t\tthis.nonFlippedRenderTargetPair.setSize(w, h);\n\t\tthis.flippedRenderTargetPair.setSize(w, h);\n\t\tthis.finalRenderTarget.setSize(w, h);\n\t}\n\n\trenderTargetPair() {\n\t\treturn this.renderFlippedUvs ? this.flippedRenderTargetPair : this.nonFlippedRenderTargetPair;\n\t}\n\ttextureRenderTarget() {\n\t\treturn this.finalRenderTarget;\n\t}\n\n\tsetParams(params: LightMapControllerParams) {\n\t\tthis._params.resolution = params.resolution;\n\t\tthis._params.lightRadius = params.lightRadius;\n\t\tthis._params.totalIterationsCount = params.totalIterationsCount;\n\t\tthis._params.blur = params.blur;\n\t\tthis._params.blurAmount = params.blurAmount;\n\t\tthis.setSize(params.resolution, params.resolution);\n\t}\n\n\tsetState(objects: Mesh[], lights: Light[]) {\n\t\tthis._clearScene();\n\n\t\tthis._scene.add(this.blurPlane);\n\n\t\tthis._previousRenderTarget = this.renderer.getRenderTarget();\n\t\tthis._setObjects(objects);\n\t\tthis._setLights(lights);\n\t}\n\tprivate _clearScene() {\n\t\tlet child: Object3D | undefined;\n\t\twhile ((child = this._scene.children[0])) {\n\t\t\tthis._scene.remove(child);\n\t\t}\n\t}\n\tprivate _setObjects(objects: Array<Mesh>) {\n\t\tthis.objectTargets = [...objects];\n\t\tthis._saveObjectsState();\n\t}\n\tprivate _setLights(lights: Array<Light>) {\n\t\tthis.lights = lights;\n\t\tfor (const light of lights) {\n\t\t\tthis._saveLightHierarchyState(light);\n\t\t\tthis._scene.attach(light);\n\t\t\tthis._saveLightMatrixState(light);\n\t\t}\n\t}\n\n\tprivate _objectStateByObject: WeakMap<Object3D, ObjectState> = new WeakMap();\n\tprivate _previousRenderTarget: WebGLRenderTarget | null = null;\n\tprivate _lightHierarchyStateByLight: WeakMap<Light, LightHierarchyState> = new WeakMap();\n\tprivate _lightMatrixStateByLight: WeakMap<Light, LightMatrixState> = new WeakMap();\n\n\tprivate _saveLightHierarchyState(light: Light) {\n\t\tthis._lightHierarchyStateByLight.set(light, {\n\t\t\tparent: light.parent,\n\t\t\tmatrixAutoUpdate: light.matrixAutoUpdate,\n\t\t});\n\t\tlight.matrixAutoUpdate = true;\n\t}\n\tprivate _t = new Vector3();\n\tprivate _q = new Quaternion();\n\tprivate _s = new Vector3();\n\tprivate _saveLightMatrixState(light: Light) {\n\t\tlight.updateMatrix();\n\t\tlight.matrix.decompose(this._t, this._q, this._s);\n\t\tthis._lightMatrixStateByLight.set(light, {\n\t\t\tmatrix: light.matrix.clone(),\n\t\t\tposition: this._t.clone(),\n\t\t});\n\t}\n\tprivate _saveObjectsState() {\n\t\tlet i = 0;\n\t\tfor (const object of this.objectTargets) {\n\t\t\tthis._objectStateByObject.set(object, {\n\t\t\t\tfrustumCulled: object.frustumCulled,\n\t\t\t\tmaterial: object.material,\n\t\t\t\tparent: object.parent,\n\t\t\t\trenderOrder: object.renderOrder,\n\t\t\t});\n\t\t\tobject.material = this.lightMapMaterial;\n\t\t\tobject.frustumCulled = false;\n\t\t\tobject.renderOrder = 1000 + i;\n\t\t\tthis._scene.attach(object);\n\n\t\t\ti++;\n\t\t}\n\t}\n\tprivate _moveLights() {\n\t\tconst lightRadius = this._params.lightRadius;\n\t\tfor (const light of this.lights) {\n\t\t\tconst state = this._lightMatrixStateByLight.get(light);\n\t\t\tif (state) {\n\t\t\t\tconst position = state.position;\n\t\t\t\tlight.position.x = position.x + lightRadius * (Math.random() - 0.5);\n\t\t\t\tlight.position.y = position.y + lightRadius * (Math.random() - 0.5);\n\t\t\t\tlight.position.z = position.z + lightRadius * (Math.random() - 0.5);\n\t\t\t}\n\t\t}\n\t}\n\trestoreState() {\n\t\tthis._restoreObjectsState();\n\t\tthis._restoreLightsState();\n\t\tthis.renderer.setRenderTarget(this._previousRenderTarget);\n\t}\n\tprivate _invertObjects() {\n\t\tfor (const object of this.objectTargets) {\n\t\t\tinvertNormals(object);\n\t\t}\n\t}\n\tprivate _restoreObjectsState() {\n\t\tfor (const object of this.objectTargets) {\n\t\t\tconst state = this._objectStateByObject.get(object);\n\t\t\tif (state) {\n\t\t\t\tobject.frustumCulled = state.frustumCulled;\n\t\t\t\tobject.renderOrder = state.renderOrder;\n\t\t\t\tobject.material = state.material;\n\t\t\t\tconst parent = state.parent;\n\t\t\t\tif (parent) {\n\t\t\t\t\tparent.add(object);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate _restoreLightsState() {\n\t\tfor (const light of this.lights) {\n\t\t\tconst stateH = this._lightHierarchyStateByLight.get(light);\n\t\t\tconst stateM = this._lightMatrixStateByLight.get(light);\n\t\t\tif (stateH && stateM) {\n\t\t\t\tlight.matrixAutoUpdate = stateH.matrixAutoUpdate;\n\t\t\t\tlight.matrix.copy(stateM.matrix);\n\t\t\t\tlight.matrix.decompose(light.position, light.quaternion, light.scale);\n\t\t\t\tlight.updateMatrix();\n\t\t\t\tstateH.parent?.attach(light);\n\t\t\t}\n\t\t}\n\t}\n\n\trunUpdates(camera: Camera) {\n\t\tconst totalIterationsCount = this._params.totalIterationsCount;\n\n\t\t// set up blur material\n\t\tthis.blurMaterial.uniforms.pixelOffset.value = this._params.blurAmount / this._params.resolution;\n\t\tthis.blurPlane.visible = this._params.blur;\n\n\t\t// set up lightmap material\n\t\t// this.lightMapMaterial.opacity = 1 / totalIterationsCount;\n\t\tthis.lightMapMaterial.uniforms.lightMapMult.value = 1 / totalIterationsCount;\n\t\t// this.lightMapMaterial.uniforms.flipped.value = false;\n\t\tthis.lightMapMaterial.side = FrontSide;\n\t\tthis.lightMapMaterial.shadowSide = null;\n\n\t\t// capture front facing lightmap uvs\n\t\tthis.renderFlippedUvs = false;\n\t\tthis._clear(camera);\n\t\tfor (let i = 0; i < totalIterationsCount; i++) {\n\t\t\tthis._moveLights();\n\t\t\tthis._update(camera);\n\t\t}\n\t\t// if (1 + 1) {\n\t\t// \treturn;\n\t\t// }\n\n\t\t// capture back facing lightmap uvs\n\t\tthis.renderFlippedUvs = true;\n\t\tthis._clear(camera);\n\t\tthis._invertObjects();\n\t\t// this.lightMapMaterial.uniforms.flipped.value = true;\n\t\tthis.lightMapMaterial.side = [DoubleSide, BackSide][1];\n\t\tthis.lightMapMaterial.shadowSide = BackSide;\n\n\t\tfor (let i = 0; i < totalIterationsCount; i++) {\n\t\t\tthis._moveLights();\n\t\t\tthis._update(camera);\n\t\t}\n\t\tthis._invertObjects();\n\n\t\t// combine both flipped and nonFlipped render targets\n\t\tthis._clearScene();\n\t\tthis._scene.add(this.renderTargetsCombinePlane);\n\t\tsetRenderTargetsCombineMaterial(this.renderTargetsCombineMaterial, {\n\t\t\trt1: this.flippedRenderTargetPair.current(),\n\t\t\trt2: this.nonFlippedRenderTargetPair.current(),\n\t\t});\n\t\tthis.renderer.setRenderTarget(this.finalRenderTarget);\n\t\tthis.renderer.render(this._scene, camera);\n\t}\n\n\tprivate _clear(camera: Camera) {\n\t\tthis._scene.visible = false;\n\t\tthis._update(camera);\n\t\tthis._update(camera);\n\t\tthis._scene.visible = true;\n\t}\n\n\tprivate _update(camera: Camera) {\n\t\t// Ping-pong two surface buffers for reading/writing\n\t\tconst rtPair = this.renderTargetPair();\n\t\tconst activeMap = rtPair.current();\n\t\tconst inactiveMap = rtPair.previous();\n\n\t\t// Render the object's surface maps\n\t\tthis.renderer.setRenderTarget(activeMap);\n\t\t// this._scene.background = inactiveMap.texture;\n\t\t// this.lightMapMaterial.uniforms.previousLightMap.value = inactiveMap.texture;\n\t\tsetLightMapMaterial(this.lightMapMaterial, {\n\t\t\tlightMap: inactiveMap,\n\t\t\t// lightMapMult:1 / totalIterationsCount,\n\t\t});\n\t\t// this.blurMaterial.uniforms.previousShadowMap.value = inactiveMap.texture;\n\t\tsetBlurMaterial(this.blurMaterial, {\n\t\t\tres: this._params.resolution,\n\t\t\tlightMap: inactiveMap,\n\t\t});\n\t\t// this.buffer1Active = !this.buffer1Active;\n\t\trtPair.toggle();\n\t\tthis.renderer.render(this._scene, camera);\n\t}\n}\n","/**\n * Creates a light map\n *\n *\n */\n\n// https://threejs.org/examples/?q=light#webgl_shadowmap_progressive\nimport {TypedCopNode} from './_Base';\nimport {NodeParamsConfig, ParamConfig} from '../utils/params/ParamsConfig';\nimport {BaseNodeType} from '../_Base';\nimport {Object3D, WebGLRenderer} from 'three';\nimport {Light} from 'three';\nimport {LightMapController} from './utils/LightMapController';\n// import {DEFAULT_ITERATION_BLEND} from './utils/lightMap/Common';\nimport {Mesh} from 'three';\nimport {isBooleanTrue} from '../../../core/BooleanValue';\nimport {DataTextureController, DataTextureControllerBufferType} from './utils/DataTextureController';\nimport {CopRendererController} from './utils/RendererController';\nimport {CopType} from '../../poly/registers/nodes/types/Cop';\n\nclass LightMapCopParamConfig extends NodeParamsConfig {\n\t/** @param click to update shadow, when mode is manual */\n\tupdate = ParamConfig.BUTTON(null, {\n\t\tcallback: (node: BaseNodeType) => {\n\t\t\tLightMapCopNode.PARAM_CALLBACK_updateManual(node as LightMapCopNode);\n\t\t},\n\t});\n\t/** @param defines if the shader is rendered via the same camera used to render the scene */\n\tuseCameraRenderer = ParamConfig.BOOLEAN(1); // needs to be 1, as it does not work on firefox otherwise\n\t/** @param shadow resolution */\n\tlightMapRes = ParamConfig.INTEGER(1024, {range: [1, 2048], rangeLocked: [true, false]});\n\t/** @param iterations */\n\titerations = ParamConfig.INTEGER(512, {range: [1, 2048], rangeLocked: [true, false]});\n\t/** @param blendWindow */\n\t// iterationBlend = ParamConfig.FLOAT(DEFAULT_ITERATION_BLEND, {\n\t// \trange: [0, 1],\n\t// \trangeLocked: [true, true],\n\t// });\n\t/** @param blurEdges */\n\tblur = ParamConfig.BOOLEAN(1);\n\t/** @param blurAmount */\n\tblurAmount = ParamConfig.FLOAT(1, {\n\t\tvisibleIf: {blur: 1},\n\t\trange: [0, 1],\n\t\trangeLocked: [true, false],\n\t});\n\t/** @param lightPositionVariation */\n\tlightRadius = ParamConfig.FLOAT(1, {\n\t\trange: [0, 10],\n\t});\n\n\tobjectsMask = ParamConfig.STRING('', {objectMask: true});\n\tlightsMask = ParamConfig.STRING('*', {objectMask: true});\n}\nconst ParamsConfig = new LightMapCopParamConfig();\n\nexport class LightMapCopNode extends TypedCopNode<LightMapCopParamConfig> {\n\toverride paramsConfig = ParamsConfig;\n\tstatic override type(): Readonly<CopType.LIGHT_MAP> {\n\t\treturn CopType.LIGHT_MAP;\n\t}\n\tprivate lightMapController: LightMapController | undefined;\n\tprivate _includedObjects: Mesh[] = [];\n\tprivate _includedLights: Light[] = [];\n\tprivate _dataTextureController: DataTextureController | undefined;\n\tprivate _rendererController: CopRendererController | undefined;\n\n\toverride async cook() {\n\t\tawait this._render();\n\t}\n\n\tprivate async _createLightMapController() {\n\t\tconst renderer = await this.scene().renderersRegister.waitForRenderer();\n\t\tif (!renderer) {\n\t\t\tconsole.warn('no renderer found');\n\t\t\treturn;\n\t\t}\n\t\tif (!(renderer instanceof WebGLRenderer)) {\n\t\t\tthis.states.error.set('renderer found is not WebGLRenderer');\n\t\t\treturn;\n\t\t}\n\t\tconst lightMapController = new LightMapController(renderer);\n\t\treturn lightMapController;\n\t}\n\n\t//\n\t//\n\t// ACTIVE\n\t//\n\t//\n\t// static PARAM_CALLBACK_update_updateMode(node: LightMapCopNode) {\n\t// \t// node._updateRenderHook();\n\t// }\n\n\t//\n\t//\n\t// UPDATE\n\t//\n\t//\n\tprivate async _render() {\n\t\tthis.lightMapController = this.lightMapController || (await this._createLightMapController());\n\t\tif (!this.lightMapController) {\n\t\t\treturn;\n\t\t}\n\t\tconst mainCamera = await this.scene().mainCamera();\n\t\tif (!mainCamera) {\n\t\t\treturn;\n\t\t}\n\t\tthis._updateObjectsAndLightsList();\n\t\tthis.lightMapController.setState(this._includedObjects, this._includedLights);\n\n\t\t// const camera = mainCameraNode.camera();\n\t\tthis.lightMapController.setParams({\n\t\t\tresolution: this.pv.lightMapRes,\n\t\t\tlightRadius: this.pv.lightRadius,\n\t\t\ttotalIterationsCount: this.pv.iterations,\n\t\t\t// iterationBlend: this.pv.iterationBlend,\n\t\t\tblur: this.pv.blur,\n\t\t\tblurAmount: this.pv.blurAmount,\n\t\t});\n\t\tthis.lightMapController.runUpdates(mainCamera);\n\t\tthis.lightMapController.restoreState();\n\t\t// this.setTexture();\n\n\t\tconst renderTarget = this.lightMapController.textureRenderTarget();\n\t\tif (isBooleanTrue(this.pv.useCameraRenderer)) {\n\t\t\tthis.setTexture(renderTarget.texture);\n\t\t} else {\n\t\t\tthis._dataTextureController =\n\t\t\t\tthis._dataTextureController || new DataTextureController(DataTextureControllerBufferType.Float32Array);\n\t\t\tthis._rendererController = this._rendererController || new CopRendererController(this);\n\t\t\tconst renderer = await this._rendererController.waitForRenderer();\n\t\t\tif (!(renderer instanceof WebGLRenderer)) {\n\t\t\t\tthis.states.error.set('renderer found is not WebGLRenderer');\n\t\t\t\tthis.cookController.endCook();\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tconst texture = this._dataTextureController.fromRenderTarget(renderer, renderTarget);\n\t\t\tthis.setTexture(texture);\n\t\t}\n\t}\n\tstatic PARAM_CALLBACK_updateManual(node: LightMapCopNode) {\n\t\tnode.setDirty();\n\t}\n\n\t//\n\t//\n\t// UPDATE OBJECTS LIST\n\t//\n\t//\n\tprivate _updateObjectsAndLightsList() {\n\t\tlet matchedObjects: Object3D[] = [];\n\t\tlet matchedLights: Object3D[] = [];\n\t\tthis._includedLights = [];\n\t\tthis._includedObjects = [];\n\t\tconst lightsByUuid: WeakSet<Object3D> = new WeakSet();\n\t\tif (this.pv.lightsMask != '') {\n\t\t\tmatchedLights = this.scene().objectsByMask(this.pv.lightsMask) as Object3D[];\n\t\t\tfor (const matchedLight of matchedLights) {\n\t\t\t\tif (matchedLight instanceof Light) {\n\t\t\t\t\tthis._includedLights.push(matchedLight);\n\t\t\t\t\tlightsByUuid.add(matchedLight);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (this.pv.objectsMask != '') {\n\t\t\tmatchedObjects = this.scene().objectsByMask(this.pv.objectsMask) as Object3D[];\n\t\t\tfor (const matchedObject of matchedObjects) {\n\t\t\t\tif (!(matchedObject instanceof Light)) {\n\t\t\t\t\tif (!lightsByUuid.has(matchedObject) && matchedObject instanceof Mesh) {\n\t\t\t\t\t\tthis._includedObjects.push(matchedObject);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n","/**\n * A subnet to create POST PROCESS nodes\n *\n */\nimport {Constructor, valueof} from '../../../types/GlobalTypes';\nimport {BaseNetworkCopNode} from './_BaseManager';\nimport {NetworkNodeType, NodeContext} from '../../poly/NodeContext';\nimport {PostNodeChildrenMap} from '../../poly/registers/nodes/Post';\nimport {BasePostProcessNodeType} from '../post/_Base';\nimport {DisplayNodeController} from '../utils/DisplayNodeController';\nimport {EffectComposerController, PostProcessNetworkParamsConfig} from '../post/utils/EffectComposerController';\nimport {NodeCreateOptions} from '../utils/hierarchy/ChildrenController';\n\nexport class PostProcessNetworkCopNode extends BaseNetworkCopNode<PostProcessNetworkParamsConfig> {\n\toverride paramsConfig = new PostProcessNetworkParamsConfig();\n\tstatic override type() {\n\t\treturn NetworkNodeType.POST;\n\t}\n\treadonly effectsComposerController: EffectComposerController = new EffectComposerController(this);\n\tpublic override readonly displayNodeController: DisplayNodeController = new DisplayNodeController(\n\t\tthis,\n\t\tthis.effectsComposerController.displayNodeControllerCallbacks()\n\t);\n\n\tprotected override _childrenControllerContext = NodeContext.POST;\n\n\toverride createNode<S extends keyof PostNodeChildrenMap>(\n\t\tnode_class: S,\n\t\toptions?: NodeCreateOptions\n\t): PostNodeChildrenMap[S];\n\toverride createNode<K extends valueof<PostNodeChildrenMap>>(\n\t\tnode_class: Constructor<K>,\n\t\toptions?: NodeCreateOptions\n\t): K;\n\toverride createNode<K extends valueof<PostNodeChildrenMap>>(\n\t\tnode_class: Constructor<K>,\n\t\toptions?: NodeCreateOptions\n\t): K {\n\t\treturn super.createNode(node_class, options) as K;\n\t}\n\toverride children() {\n\t\treturn super.children() as BasePostProcessNodeType[];\n\t}\n\toverride nodesByType<K extends keyof PostNodeChildrenMap>(type: K): PostNodeChildrenMap[K][] {\n\t\treturn super.nodesByType(type) as PostNodeChildrenMap[K][];\n\t}\n}\n","/**\n * Creates a texture from a render\n *\n * @remarks\n * This node can be useful when you want to use what a camera sees as a texture.\n *\n */\nimport {\n\tColorSpace,\n\tWebGLRenderer,\n\tWebGLRenderTarget,\n\tOrthographicCamera,\n\tFloatType,\n\tHalfFloatType,\n\tRGBAFormat,\n\tNearestFilter,\n\tLinearFilter,\n\tClampToEdgeWrapping,\n\tPerspectiveCamera,\n\tVector2,\n} from 'three';\nimport {TypedCopNode} from './_Base';\nimport {NodeParamsConfig, ParamConfig} from '../utils/params/ParamsConfig';\nimport {BaseNodeType} from '../_Base';\nimport {CopRendererController} from './utils/RendererController';\nimport {isBooleanTrue} from '../../../core/BooleanValue';\nimport {DataTextureController, DataTextureControllerBufferType} from './utils/DataTextureController';\nimport {TextureParamsController, TextureParamConfig} from './utils/TextureParamsController';\nimport {CoreUserAgent} from '../../../core/UserAgent';\nimport {Poly} from '../../Poly';\nimport {Constructor} from '../../../types/GlobalTypes';\nimport {CoreCameraPerspectiveFrameMode} from '../../../core/camera/frameMode/CoreCameraPerspectiveFrameMode';\nimport {CoreCameraOrthographicFrameMode} from '../../../core/camera/frameMode/CoreCameraOrthographicFrameMode';\nimport {CopType} from '../../poly/registers/nodes/types/Cop';\n\nconst _v2 = new Vector2();\n\nexport function RenderCopNodeParamConfig<TBase extends Constructor>(Base: TBase) {\n\treturn class Mixin extends Base {\n\t\t/** @param path to the main camera object that will be used when the scene loads outside of the editor */\n\t\tcameraPath = ParamConfig.STRING('*perspectiveCamera*', {\n\t\t\tobjectMask: true,\n\t\t});\n\t\t/** @param transparent background */\n\t\ttransparentBackground = ParamConfig.BOOLEAN(1);\n\t\t/** @param bg Color */\n\t\tbackgroundColor = ParamConfig.COLOR([0, 0, 0], {\n\t\t\tvisibleIf: {\n\t\t\t\ttransparentBackground: 0,\n\t\t\t},\n\t\t});\n\t\t/** @param use same resolution as renderer */\n\t\tuseRendererRes = ParamConfig.BOOLEAN(1);\n\t\t/** @param render resolution */\n\t\tresolution = ParamConfig.VECTOR2([1024, 1024], {\n\t\t\tvisibleIf: {\n\t\t\t\tuseRendererRes: 0,\n\t\t\t},\n\t\t});\n\t\t/** @param use a data texture instead of a render target, which can be useful when using that texture as and envMap */\n\t\tuseDataTexture = ParamConfig.BOOLEAN(0);\n\t\t/** @param autoRender */\n\t\tautoRender = ParamConfig.BOOLEAN(1);\n\t\t/** @param render button */\n\t\trender = ParamConfig.BUTTON(null, {\n\t\t\tcallback: (node: BaseNodeType) => {\n\t\t\t\tRenderCopNode.PARAM_CALLBACK_render(node as RenderCopNode);\n\t\t\t},\n\t\t});\n\t};\n}\nclass RenderCopParamConfig extends TextureParamConfig(RenderCopNodeParamConfig(NodeParamsConfig)) {}\n\nconst ParamsConfig = new RenderCopParamConfig();\n\nexport class RenderCopNode extends TypedCopNode<RenderCopParamConfig> {\n\toverride paramsConfig = ParamsConfig;\n\tstatic override type(): Readonly<CopType.RENDER> {\n\t\treturn CopType.RENDER;\n\t}\n\tpublic readonly textureParamsController: TextureParamsController = new TextureParamsController(this);\n\n\t// private _renderTarget: WebGLRenderTarget | undefined;\n\tprivate _rendererController: CopRendererController | undefined;\n\tprivate _dataTextureController: DataTextureController | undefined;\n\tprivate _renderTargetByRenderer: WeakMap<WebGLRenderer, WebGLRenderTarget> = new WeakMap();\n\toverride async cook() {\n\t\tif (isBooleanTrue(this.pv.autoRender)) {\n\t\t\tthis._addOnBeforeTickCallback();\n\t\t} else {\n\t\t\tthis._removeOnBeforeTickCallback();\n\t\t}\n\n\t\tconst camera = await this._getCamera();\n\t\tif (camera) {\n\t\t\tawait this.renderOnTarget();\n\t\t} else {\n\t\t\tthis.cookController.endCook();\n\t\t}\n\t}\n\n\t//\n\t//\n\t// AUTO RENDER\n\t//\n\t//\n\tprivate _addOnBeforeTickCallback() {\n\t\tconst callbackName = this._onBeforeRenderCallbackName();\n\t\tif (this.scene().hasBeforeTickCallback(callbackName)) {\n\t\t\treturn;\n\t\t}\n\t\tthis.scene().registerOnBeforeTick(callbackName, this._renderOnTargetBound);\n\t}\n\tprivate _removeOnBeforeTickCallback() {\n\t\tthis.scene().unRegisterOnBeforeTick(this._onBeforeRenderCallbackName());\n\t}\n\tprivate _onBeforeRenderCallbackName() {\n\t\treturn `cop/render_onBeforeTickCallback-${this.graphNodeId()}`;\n\t}\n\toverride dispose() {\n\t\tsuper.dispose();\n\t\tthis._removeOnBeforeTickCallback();\n\t}\n\n\t//\n\t//\n\t// RENDER + RENDER TARGET\n\t//\n\t//\n\tprivate _getCameraSync() {\n\t\treturn this.scene().objectsController.findObjectByMask(this.pv.cameraPath) as\n\t\t\t| OrthographicCamera\n\t\t\t| PerspectiveCamera\n\t\t\t| undefined;\n\t}\n\tprivate async _getCamera(): Promise<PerspectiveCamera | OrthographicCamera | undefined> {\n\t\tconst camera = this._getCameraSync();\n\t\tif (camera) {\n\t\t\treturn camera;\n\t\t}\n\t\treturn new Promise((resolve) => {\n\t\t\tconst onCameraUpdated = async () => {\n\t\t\t\tconst camera = this._getCameraSync();\n\t\t\t\tthis.scene().camerasController.removeOnCameraObjectsUpdated(onCameraUpdated);\n\t\t\t\tif (camera) {\n\t\t\t\t\tresolve(camera);\n\t\t\t\t}\n\t\t\t};\n\t\t\tthis.scene().camerasController.onCameraObjectsUpdated(onCameraUpdated);\n\t\t});\n\t}\n\n\tprivate _renderOnTargetBound = this.renderOnTarget.bind(this);\n\tasync renderOnTarget() {\n\t\tconst camera = await this._getCamera();\n\t\tif (!camera) {\n\t\t\tthis.states.error.set(`no camera found`);\n\t\t\treturn;\n\t\t}\n\n\t\tthis._rendererController = this._rendererController || new CopRendererController(this);\n\t\tconst renderer = await this._rendererController.waitForRenderer();\n\t\tif (!(renderer instanceof WebGLRenderer)) {\n\t\t\tthis.states.error.set(`no renderer found`);\n\t\t\treturn;\n\t\t}\n\n\t\tconst renderTarget = await this.createRenderTargetIfRequired(renderer);\n\n\t\tthis._ensureRenderTargetResolutionValid(renderer, renderTarget);\n\t\tconst viewer = this.scene().viewersRegister.lastRenderedViewer();\n\t\tif (!viewer) {\n\t\t\tthis.states.error.set(`no viewer found`);\n\t\t\treturn;\n\t\t}\n\t\tconst viewerCamera = viewer.camera();\n\t\tif (!viewerCamera) {\n\t\t\tthis.states.error.set(`no viewer camera found`);\n\t\t\treturn;\n\t\t}\n\t\tthis._requestedResolution(renderer, _v2);\n\t\tconst aspect = _v2.x / _v2.y;\n\t\tif (camera instanceof PerspectiveCamera && viewerCamera instanceof PerspectiveCamera) {\n\t\t\tCoreCameraPerspectiveFrameMode.updateCameraAspect(camera, aspect, {cameraWithAttributes: viewerCamera});\n\t\t} else {\n\t\t\tif (camera instanceof OrthographicCamera && viewerCamera instanceof OrthographicCamera) {\n\t\t\t\tCoreCameraOrthographicFrameMode.updateCameraAspect(camera, aspect, {\n\t\t\t\t\tcameraWithAttributes: viewerCamera,\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\n\t\tconst scene = this.scene().threejsScene();\n\t\t// save state\n\t\tconst prevTarget = renderer.getRenderTarget();\n\t\tconst prevColorSpace = renderer.outputColorSpace;\n\t\tconst prevBackground = scene.background;\n\t\tscene.background = this.pv.transparentBackground ? null : this.pv.backgroundColor;\n\t\trenderer.setRenderTarget(renderTarget);\n\t\trenderer.outputColorSpace = this.pv.colorSpace as ColorSpace;\n\n\t\t// render\n\t\trenderer.clear();\n\t\trenderer.render(scene, camera);\n\n\t\t// restore state\n\t\trenderer.setRenderTarget(prevTarget);\n\t\trenderer.outputColorSpace = prevColorSpace;\n\t\tscene.background = prevBackground;\n\n\t\t// set texture\n\t\t// Note: this cannot be done just in the cook method,\n\t\t// since a window resize will require the re-creation of the renderTarget\n\t\t// and therefore of the texture.\n\t\tif (renderTarget.texture) {\n\t\t\tif (isBooleanTrue(this.pv.useDataTexture)) {\n\t\t\t\tthis._dataTextureController =\n\t\t\t\t\tthis._dataTextureController ||\n\t\t\t\t\tnew DataTextureController(DataTextureControllerBufferType.Float32Array);\n\t\t\t\tconst dataTexture = this._dataTextureController.fromRenderTarget(renderer, renderTarget);\n\t\t\t\tawait this.textureParamsController.update(dataTexture);\n\t\t\t\tthis.setTexture(dataTexture);\n\t\t\t\treturn;\n\t\t\t} else {\n\t\t\t\tthis.setTexture(renderTarget.texture);\n\t\t\t\tawait this.textureParamsController.update(renderTarget.texture);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n\n\tasync renderTarget(renderer: WebGLRenderer) {\n\t\treturn this._renderTargetByRenderer.get(renderer);\n\t}\n\tprivate async createRenderTargetIfRequired(renderer: WebGLRenderer) {\n\t\tlet renderTarget = this._renderTargetByRenderer.get(renderer);\n\t\tif (!renderTarget) {\n\t\t\trenderTarget = await this._createRenderTarget(renderer);\n\t\t\tthis._renderTargetByRenderer.set(renderer, renderTarget);\n\t\t}\n\t\treturn renderTarget;\n\t}\n\tprivate _requestedResolution(renderer: WebGLRenderer, target: Vector2) {\n\t\tif (isBooleanTrue(this.pv.useRendererRes)) {\n\t\t\trenderer.getSize(target);\n\t\t} else {\n\t\t\ttarget.copy(this.pv.resolution);\n\t\t}\n\t}\n\tprivate _ensureRenderTargetResolutionValid(renderer: WebGLRenderer, renderTarget: WebGLRenderTarget) {\n\t\tthis._requestedResolution(renderer, _v2);\n\t\tconst image = renderTarget.texture.image;\n\t\tif (image.width != _v2.x || image.height != _v2.y) {\n\t\t\trenderTarget.setSize(_v2.x, _v2.y);\n\t\t}\n\t}\n\n\tprivate async _createRenderTarget(renderer: WebGLRenderer) {\n\t\tthis._requestedResolution(renderer, _v2);\n\n\t\tconst wrapS = ClampToEdgeWrapping;\n\t\tconst wrapT = ClampToEdgeWrapping;\n\n\t\tconst minFilter = LinearFilter;\n\t\tconst magFilter = NearestFilter;\n\n\t\tconst renderTarget = new WebGLRenderTarget(_v2.x, _v2.y, {\n\t\t\twrapS,\n\t\t\twrapT,\n\t\t\tminFilter,\n\t\t\tmagFilter,\n\t\t\tformat: RGBAFormat,\n\t\t\tgenerateMipmaps: true,\n\t\t\ttype: CoreUserAgent.isiOS() ? HalfFloatType : FloatType,\n\t\t\tsamples: renderer.getPixelRatio(),\n\t\t\tstencilBuffer: true,\n\t\t\tdepthBuffer: true,\n\t\t});\n\t\tawait this.textureParamsController.update(renderTarget.texture);\n\t\tPoly.warn('created render target', this.path(), _v2.x, _v2.y);\n\t\treturn renderTarget;\n\t}\n\n\t//\n\t//\n\t// CALLBACK\n\t//\n\t//\n\tstatic PARAM_CALLBACK_render(node: RenderCopNode) {\n\t\tnode.renderOnTarget();\n\t}\n}\n","/**\n * Creates an SDF texture which can be used inside the [mat/raymarchingBuilder](/doc/nodes/mat/raymarchingBuilder)\n *\n *\n */\nimport {Matrix4, Quaternion} from 'three';\nimport {ThreeMeshBVHHelper} from './../../../core/geometry/bvh/ThreeMeshBVHHelper';\nimport {MeshWithBVH} from './../../../core/geometry/bvh/three-mesh-bvh';\nimport {Vector3, Ray, Texture, Data3DTexture, DoubleSide, Box3, Mesh} from 'three';\nimport {NodeContext} from './../../poly/NodeContext';\nimport {TypedCopNode} from './_Base';\nimport {NodeParamsConfig, ParamConfig} from '../utils/params/ParamsConfig';\nimport {HitPointInfo} from 'three-mesh-bvh';\nimport {addSDFMetadataToContainer, createSDFTexture} from '../../../core/loader/geometry/SDF';\nimport {CopType} from '../../poly/registers/nodes/types/Cop';\n\nconst _bbox = new Box3();\nconst _rayDir = new Vector3();\nconst _ray = new Ray();\nconst _bboxSize = new Vector3();\nconst _resolution = new Vector3();\nconst _voxelSizes = new Vector3();\nconst _padding = new Vector3();\nconst objectWorldMat = new Matrix4();\nconst objectWorldMatInverse = new Matrix4();\nconst t = new Vector3();\nconst q = new Quaternion();\nconst s = new Vector3();\n\ninterface FillTextureOptions {\n\tresolution: Vector3;\n\tbbox: Box3;\n\tbboxSize: Vector3;\n\tvoxelSizes: Vector3;\n}\nclass SDFFromObjectCopParamsConfig extends NodeParamsConfig {\n\t/** @param which SOP node to import from */\n\tgeometry = ParamConfig.NODE_PATH('', {\n\t\tnodeSelection: {\n\t\t\tcontext: NodeContext.SOP,\n\t\t},\n\t});\n\t/** @param voxelSize */\n\tvoxelSize = ParamConfig.FLOAT(0.1, {\n\t\trange: [0.00001, 1],\n\t\trangeLocked: [true, false],\n\t});\n\t/** @param padding */\n\tpadding = ParamConfig.INTEGER(2, {\n\t\trange: [0, 5],\n\t\trangeLocked: [true, false],\n\t});\n\t/** @param resolution */\n\tresolution = ParamConfig.VECTOR3([-1, -1, -1], {\n\t\tcook: false,\n\t\teditable: false,\n\t\tseparatorBefore: true,\n\t});\n\t/** @param boundMin */\n\tboundMin = ParamConfig.VECTOR3([-1, -1, -1], {\n\t\tcook: false,\n\t\teditable: false,\n\t});\n\t/** @param boundMax */\n\tboundMax = ParamConfig.VECTOR3([1, 1, 1], {\n\t\tcook: false,\n\t\teditable: false,\n\t});\n}\n\nconst ParamsConfig = new SDFFromObjectCopParamsConfig();\n\nexport class SDFFromObjectCopNode extends TypedCopNode<SDFFromObjectCopParamsConfig> {\n\toverride paramsConfig = ParamsConfig;\n\tstatic override type() {\n\t\treturn CopType.SDF_FROM_OBJECT;\n\t}\n\n\toverride async cook(inputContents: Texture[]) {\n\t\tconst geometryNode = this.pv.geometry.nodeWithContext(NodeContext.SOP, this.states.error);\n\t\tif (!geometryNode) {\n\t\t\tthis.states.error.set(`node not found at path '${this.pv.geometry.path()}'`);\n\t\t\treturn;\n\t\t}\n\t\tconst container = await geometryNode.compute();\n\t\tconst coreGroup = container.coreContent();\n\n\t\tconst objects = coreGroup?.threejsObjects();\n\t\tif (!(coreGroup && objects && objects.length)) {\n\t\t\tthis.states.error.set(`no objects found`);\n\t\t\treturn;\n\t\t}\n\n\t\tlet objectWithGeo: MeshWithBVH | undefined;\n\t\tfor (const object of objects) {\n\t\t\tif ((object as MeshWithBVH).geometry) {\n\t\t\t\tobjectWithGeo = objectWithGeo || (object as MeshWithBVH);\n\t\t\t}\n\t\t}\n\t\tif (!objectWithGeo) {\n\t\t\tfor (const object of objects) {\n\t\t\t\tobject.traverse((childObject) => {\n\t\t\t\t\tif ((childObject as MeshWithBVH).geometry) {\n\t\t\t\t\t\tobjectWithGeo = objectWithGeo || (childObject as MeshWithBVH);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\t\tif (!objectWithGeo) {\n\t\t\tthis.states.error.set(`no object found with a geometry`);\n\t\t\treturn;\n\t\t}\n\t\tconst geometry = (objectWithGeo as MeshWithBVH).geometry;\n\t\tif (!geometry) {\n\t\t\tthis.states.error.set(`no geometry found`);\n\t\t\treturn;\n\t\t}\n\t\tlet boundsTree = geometry.boundsTree;\n\t\tif (!boundsTree) {\n\t\t\tThreeMeshBVHHelper.assignDefaultBVHIfNone(objectWithGeo as Mesh);\n\t\t\tboundsTree = geometry.boundsTree;\n\t\t}\n\n\t\t// update boundMin and BoundMax\n\t\tcoreGroup.boundingBox(_bbox);\n\n\t\tconst _updateResolution = () => {\n\t\t\t_bbox.getSize(_bboxSize);\n\t\t\t_resolution.copy(_bboxSize).divideScalar(this.pv.voxelSize);\n\t\t\t_resolution.x = Math.ceil(_resolution.x * 0.5) * 2;\n\t\t\t_resolution.y = Math.ceil(_resolution.y * 0.5) * 2;\n\t\t\t_resolution.z = Math.ceil(_resolution.z * 0.5) * 2;\n\t\t\t_voxelSizes.copy(_bboxSize).divide(_resolution);\n\t\t};\n\t\t// compute resolution before padding\n\t\t_updateResolution();\n\n\t\t// expand the bounding box\n\t\t_padding.copy(_voxelSizes).multiplyScalar(this.pv.padding);\n\t\t_bbox.expandByVector(_padding);\n\n\t\t// recompute resolution after padding adjustment\n\t\t_updateResolution();\n\n\t\t// update params\n\t\tthis.scene().batchUpdates(() => {\n\t\t\tthis.p.boundMin.set(_bbox.min);\n\t\t\tthis.p.boundMax.set(_bbox.max);\n\t\t\tthis.p.resolution.set(_resolution);\n\t\t});\n\n\t\t// write texture data\n\t\tconst timeStart = performance.now();\n\t\tobjectWithGeo.updateMatrixWorld(true);\n\t\tobjectWorldMat.copy(objectWithGeo.matrixWorld);\n\t\tobjectWorldMatInverse.copy(objectWithGeo.matrixWorld).invert();\n\t\tobjectWorldMatInverse.decompose(t, q, s);\n\t\tthis.createTextureTargetIfRequired(_resolution);\n\t\tconst texture = this._fillTexture(objectWithGeo as MeshWithBVH, {\n\t\t\tresolution: _resolution,\n\t\t\tbbox: _bbox,\n\t\t\tbboxSize: _bboxSize,\n\t\t\tvoxelSizes: _voxelSizes,\n\t\t});\n\t\tconst totalTime = performance.now() - timeStart;\n\t\tconsole.log('SDF generation time', totalTime);\n\n\t\tif (texture) {\n\t\t\tthis.setTexture(texture);\n\t\t} else {\n\t\t\tthis.cookController.endCook();\n\t\t}\n\t}\n\n\t/*\n\t *\n\t * FILL TEXTURE\n\t *\n\t */\n\t_fillTexture(object: MeshWithBVH, options: FillTextureOptions) {\n\t\tconst {resolution, bbox, bboxSize, voxelSizes} = options;\n\t\tconst boundsTree = object.geometry.boundsTree;\n\n\t\tconst texture = this._dataTexture(resolution);\n\t\tconst data = texture.image.data;\n\t\tconst pos = new Vector3();\n\t\tconst distanceResult: HitPointInfo = {\n\t\t\tpoint: new Vector3(),\n\t\t\tdistance: -1,\n\t\t\tfaceIndex: -1,\n\t\t};\n\t\tconst resx = resolution.x;\n\t\tconst resy = resolution.y;\n\t\tconst resz = resolution.z;\n\t\tconst minx = bbox.min.x + voxelSizes.x * 0.5;\n\t\tconst miny = bbox.min.y + voxelSizes.y * 0.5;\n\t\tconst minz = bbox.min.z + voxelSizes.z * 0.5;\n\t\tconst sizex = bboxSize.x;\n\t\tconst sizey = bboxSize.y;\n\t\tconst sizez = bboxSize.z;\n\n\t\tlet i = 0;\n\t\tfor (let z = 0; z < resz; z++) {\n\t\t\tfor (let y = 0; y < resy; y++) {\n\t\t\t\tfor (let x = 0; x < resx; x++) {\n\t\t\t\t\t// fit pos\n\t\t\t\t\tpos.x = (x / resx) * sizex + minx;\n\t\t\t\t\tpos.y = (y / resy) * sizey + miny;\n\t\t\t\t\tpos.z = (z / resz) * sizez + minz;\n\n\t\t\t\t\tboundsTree.closestPointToPoint(pos, distanceResult);\n\t\t\t\t\t// check if we are inside\n\t\t\t\t\t_rayDir.copy(distanceResult.point).sub(pos);\n\t\t\t\t\t_ray.origin.copy(pos);\n\t\t\t\t\tconst res = boundsTree.raycastFirst(_ray, DoubleSide);\n\t\t\t\t\tconst inside = res && res.face && res.face.normal.dot(_ray.direction) > 0.0;\n\n\t\t\t\t\t// TODO: get distance scale by object matrix\n\t\t\t\t\t// _rayDir.applyMatrix4(objectWorldMat);\n\t\t\t\t\t// const d = _rayDir.length();\n\n\t\t\t\t\tconst d = distanceResult.distance;\n\t\t\t\t\tdata[i] = inside ? -d : d;\n\t\t\t\t\ti++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\taddSDFMetadataToContainer(texture, {\n\t\t\tboundMin: bbox.min,\n\t\t\tboundMax: bbox.max,\n\t\t\tresolution,\n\t\t});\n\t\treturn texture;\n\t}\n\n\t/*\n\t *\n\t * CREATE TEXTURE\n\t *\n\t */\n\tprivate __dataTexture: Data3DTexture | undefined;\n\tprivate _resolutionUsed: Vector3 = new Vector3(-1, -1, -1);\n\t_dataTexture(resolution: Vector3) {\n\t\treturn (this.__dataTexture = this.__dataTexture || this._createTexture(resolution));\n\t}\n\tprivate createTextureTargetIfRequired(resolution: Vector3) {\n\t\tif (!this.__dataTexture || !this._textureResolutionValid(resolution)) {\n\t\t\tthis.__dataTexture = this._createTexture(resolution);\n\t\t\tthis._resolutionUsed.copy(resolution);\n\t\t}\n\t}\n\tprivate _textureResolutionValid(resolution: Vector3) {\n\t\tif (this.__dataTexture) {\n\t\t\treturn resolution.equals(this._resolutionUsed);\n\t\t} else {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\tprivate _createTexture(resolution: Vector3) {\n\t\treturn createSDFTexture(resolution.x, resolution.y, resolution.z);\n\t}\n\n\t/*\n\t *\n\t * CALLBACK\n\t *\n\t */\n\t// static PARAM_CALLBACK_render(node: SDFFromObjectCopNode) {\n\t// \tnode.setDirty();\n\t// }\n}\n","/**\n * Imports a video from your webcam\n *\n */\nimport {Constructor} from '../../../types/GlobalTypes';\nimport {TypedCopNode} from './_Base';\nimport {VideoTexture, Texture, SRGBColorSpace} from 'three';\nimport {NodeParamsConfig, ParamConfig} from '../utils/params/ParamsConfig';\nimport {TextureParamsController, TextureParamConfig} from './utils/TextureParamsController';\nimport {InputCloneMode} from '../../poly/InputCloneMode';\nimport {CopType} from '../../poly/registers/nodes/types/Cop';\n// import {coreDebug, coreMountDebugElement} from '../../../core/DebugUtils';\n\nenum WebCamFacingMode {\n\tUSER = 'user',\n\tENVIRONMENT = 'environment',\n}\nconst WEBCAM_FACING_MODES: WebCamFacingMode[] = [WebCamFacingMode.USER, WebCamFacingMode.ENVIRONMENT];\nlet videoCount = 0;\nlet streamCount = 0;\nlet canPlayCount = 0;\ninterface StreamAcquireResult {\n\tdimensionsSwapRequired: boolean;\n}\n\nexport function WebCamCopParamConfig<TBase extends Constructor>(Base: TBase) {\n\treturn class Mixin extends Base {\n\t\t/** @param texture resolution */\n\t\tres = ParamConfig.VECTOR2([1024, 1024]);\n\t\t/** @param facingMode (on a mobile device, 'user' is the front camera, 'environment' is the back one ) */\n\t\tfacingMode = ParamConfig.INTEGER(WEBCAM_FACING_MODES.indexOf(WebCamFacingMode.USER), {\n\t\t\tmenu: {\n\t\t\t\tentries: WEBCAM_FACING_MODES.map((name, value) => ({name, value})),\n\t\t\t},\n\t\t});\n\t};\n}\nclass WebCamCopParamsConfig extends TextureParamConfig(WebCamCopParamConfig(NodeParamsConfig), {\n\ttcolorSpace: true,\n\tcolorSpace: SRGBColorSpace,\n}) {}\n\nconst ParamsConfig = new WebCamCopParamsConfig();\n\nexport class WebCamCopNode extends TypedCopNode<WebCamCopParamsConfig> {\n\toverride paramsConfig = ParamsConfig;\n\tstatic override type() {\n\t\treturn CopType.WEB_CAM;\n\t}\n\n\tprivate _video: HTMLVideoElement | undefined;\n\tHTMLVideoElement() {\n\t\treturn this._video;\n\t}\n\tpublic readonly textureParamsController: TextureParamsController = new TextureParamsController(this);\n\n\toverride initializeNode() {\n\t\t// coreMountDebugElement();\n\t\tthis.io.inputs.setCount(0, 1);\n\t\tthis.io.inputs.initInputsClonedState(InputCloneMode.NEVER);\n\t}\n\toverride dispose() {\n\t\tsuper.dispose();\n\t\tthis._cancelWebcamRequest();\n\t}\n\tsetFacingMode(facingMode: WebCamFacingMode) {\n\t\tthis.p.facingMode.set(WEBCAM_FACING_MODES.indexOf(facingMode));\n\t}\n\n\tprivate _stream: MediaStream | undefined;\n\tprivate _cancelWebcamRequest() {\n\t\ttry {\n\t\t\tif (this._stream) {\n\t\t\t\tthis._stream.getTracks().forEach((track) => track.stop());\n\t\t\t}\n\t\t} catch (err) {\n\t\t\tconsole.error(err);\n\t\t\tconsole.warn(`failed to cancel webcam request`);\n\t\t}\n\t}\n\n\tprivate _createHTMLVideoElement(width: number, height: number) {\n\t\t// if (this._video) {\n\t\t// \tdocument.body.removeChild(this._video);\n\t\t// }\n\t\tconst element = document.createElement('video');\n\t\t// element.style.display = 'none';\n\t\t// // make sure to call this during the cook method\n\t\t// // to ensure that res.x and res.y have a value\n\t\telement.width = width;\n\t\telement.height = height;\n\t\telement.autoplay = true;\n\t\telement.setAttribute('autoplay', 'true');\n\t\telement.setAttribute('muted', 'true');\n\t\telement.setAttribute('playsinline', 'true');\n\n\t\t// coreDebug({orient: screenOrientation()});\n\t\t// document.body.appendChild(element);\n\n\t\treturn element;\n\t}\n\n\toverride async cook(inputContents: Texture[]) {\n\t\tconst inputTexture = inputContents[0];\n\t\tconst result = await this._streamToTexture(inputTexture, false);\n\t\tif (result && result.dimensionsSwapRequired) {\n\t\t\tawait this._streamToTexture(inputTexture, true);\n\t\t}\n\t}\n\n\tprivate async _streamToTexture(\n\t\tinputTexture: Texture | null,\n\t\tswapDimensions: boolean\n\t): Promise<StreamAcquireResult | undefined> {\n\t\tconst x = swapDimensions ? this.pv.res.y : this.pv.res.x;\n\t\tconst y = swapDimensions ? this.pv.res.x : this.pv.res.y;\n\t\tconst width = x;\n\t\tconst height = y;\n\n\t\tif (width <= 0 || height <= 0) {\n\t\t\tthis.states.error.set(`invalid resolution ${width}x${height}`);\n\t\t\treturn;\n\t\t}\n\n\t\tconst _checkDimensionsValid = (): boolean => {\n\t\t\treturn width == x && height == y;\n\t\t};\n\t\tconst setErrorFromInvalidDimensions = () => {\n\t\t\tthis.states.error.set(`recompute needed ${width}x${height} is not ${x}x${y}`);\n\t\t};\n\n\t\tconst videoElement = this._createHTMLVideoElement(width, height);\n\t\t// coreDebug({width, height, videoCount});\n\t\tvideoCount++;\n\n\t\tconst texture = new VideoTexture(videoElement);\n\t\tif (inputTexture) {\n\t\t\tTextureParamsController.copyTextureAttributes(texture, inputTexture);\n\t\t}\n\t\tawait this.textureParamsController.update(texture);\n\n\t\tif (!_checkDimensionsValid()) {\n\t\t\tsetErrorFromInvalidDimensions();\n\t\t\treturn;\n\t\t}\n\n\t\treturn new Promise((resolve) => {\n\t\t\tif (navigator && navigator.mediaDevices && navigator.mediaDevices.getUserMedia) {\n\t\t\t\tconst facingMode = WEBCAM_FACING_MODES[this.pv.facingMode];\n\t\t\t\tconst constraints: MediaStreamConstraints = {\n\t\t\t\t\tvideo: {\n\t\t\t\t\t\twidth,\n\t\t\t\t\t\theight,\n\t\t\t\t\t\taspectRatio: width / height,\n\t\t\t\t\t\tfacingMode,\n\t\t\t\t\t},\n\t\t\t\t\taudio: false,\n\t\t\t\t};\n\n\t\t\t\tthis._cancelWebcamRequest();\n\n\t\t\t\tnavigator.mediaDevices\n\t\t\t\t\t.getUserMedia(constraints)\n\t\t\t\t\t.then((stream) => {\n\t\t\t\t\t\tif (!_checkDimensionsValid()) {\n\t\t\t\t\t\t\tsetErrorFromInvalidDimensions();\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tthis._stream = stream;\n\t\t\t\t\t\t// apply the stream to the video element used in the texture\n\t\t\t\t\t\t// video.onload = () => {\n\t\t\t\t\t\t// \tconsole.log('onLoad');\n\t\t\t\t\t\t// };\n\t\t\t\t\t\t// .setTexture is called only in .oncanplay\n\t\t\t\t\t\t// as otherwise, if it is given to actor/trackHand\n\t\t\t\t\t\t// too early\n\t\t\t\t\t\t// then the computer vision would crash\n\t\t\t\t\t\t// coreDebug({streamCount});\n\t\t\t\t\t\tstreamCount++;\n\t\t\t\t\t\tlet _onCanPlayProcessed = false;\n\t\t\t\t\t\tvideoElement.oncanplay = () => {\n\t\t\t\t\t\t\tif (_onCanPlayProcessed) {\n\t\t\t\t\t\t\t\t// make sure we only process this once\n\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t_onCanPlayProcessed = true;\n\t\t\t\t\t\t\t// coreDebug({\n\t\t\t\t\t\t\t// \tcanPlayCount,\n\t\t\t\t\t\t\t// \t[canPlayCount]: `${width}x${height}`,\n\t\t\t\t\t\t\t// });\n\t\t\t\t\t\t\tcanPlayCount++;\n\t\t\t\t\t\t\tif (!_checkDimensionsValid()) {\n\t\t\t\t\t\t\t\tsetErrorFromInvalidDimensions();\n\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t/**\n\t\t\t\t\t\t\t * we currently need to check if the resulting video\n\t\t\t\t\t\t\t * has the expected dimensions, as there are situations\n\t\t\t\t\t\t\t * on mobile where it does not.\n\t\t\t\t\t\t\t * When that is the case, we try again to get the stream\n\t\t\t\t\t\t\t * with swapped dimensions.\n\t\t\t\t\t\t\t */\n\t\t\t\t\t\t\tthis._video = videoElement;\n\t\t\t\t\t\t\tconst dimensionsMatchWithoutSwap =\n\t\t\t\t\t\t\t\tMath.round(videoElement.videoWidth) == Math.round(width) &&\n\t\t\t\t\t\t\t\tMath.round(videoElement.videoHeight) == Math.round(height);\n\n\t\t\t\t\t\t\tif (swapDimensions || dimensionsMatchWithoutSwap) {\n\t\t\t\t\t\t\t\tthis.setTexture(texture);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tresolve({dimensionsSwapRequired: true});\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t};\n\t\t\t\t\t\tvideoElement.onerror = (err) => {\n\t\t\t\t\t\t\tthis.states.error.set(`webcam video error: ${err}`);\n\t\t\t\t\t\t};\n\t\t\t\t\t\tvideoElement.srcObject = stream;\n\t\t\t\t\t\tvideoElement.play();\n\t\t\t\t\t})\n\t\t\t\t\t.catch((error) => {\n\t\t\t\t\t\tconsole.log(`error ${width}x${height}`, error, {constraints});\n\t\t\t\t\t\tthis.states.error.set('Unable to access the camera/webcam');\n\t\t\t\t\t});\n\t\t\t} else {\n\t\t\t\tconst isHttps = window.location.protocol.startsWith('https');\n\t\t\t\tif (isHttps) {\n\t\t\t\t\tthis.states.error.set(\n\t\t\t\t\t\t'MediaDevices interface not available. Please check that your connection is secure (using https)'\n\t\t\t\t\t);\n\t\t\t\t} else {\n\t\t\t\t\tthis.states.error.set('https is required to use the webcam node');\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t}\n}\n","import {NodeContext} from '../../poly/NodeContext';\nimport {NodeParamsConfig} from '../utils/params/ParamsConfig';\nimport {TypedNode} from '../_Base';\n\nclass ParamLessNetworkCopParamsConfig extends NodeParamsConfig {}\nexport class BaseNetworkCopNode<K extends NodeParamsConfig> extends TypedNode<NodeContext.COP, K> {\n\tstatic override context(): NodeContext {\n\t\treturn NodeContext.COP;\n\t}\n\toverride cook() {\n\t\tthis.cookController.endCook();\n\t}\n}\nexport class ParamLessBaseNetworkCopNode extends BaseNetworkCopNode<ParamLessNetworkCopParamsConfig> {}\n","import {Builder2DArrayCopNode} from '../Builder2DArray';\nimport {BuilderCopNode} from './../Builder';\nimport {IUniformsWithTime} from '../../../scene/utils/UniformsController';\n\ninterface HandleDependenciesOptions {\n\tnode: BuilderCopNode | Builder2DArrayCopNode;\n\ttimeDependent: boolean;\n\tuniforms?: IUniformsWithTime;\n}\n\nexport function handleCopBuilderDependencies(options: HandleDependenciesOptions) {\n\tconst {node, timeDependent, uniforms} = options;\n\tconst scene = node.scene();\n\tif (timeDependent) {\n\t\tif (uniforms) {\n\t\t\tscene.uniformsController.addTimeUniform(uniforms);\n\t\t}\n\t\tconst callbackName = node.callbackName();\n\t\tif (!scene.registeredBeforeTickCallbacks().has(callbackName)) {\n\t\t\tscene.registerOnBeforeTick(callbackName, node.boundRenderOnTarget);\n\t\t}\n\t} else {\n\t\tnode.removeCallbacks();\n\t}\n}\n","import {CoreUserAgent} from './../../../../core/UserAgent';\nimport {Mapping, PixelFormat, WebGLRenderer} from 'three';\nimport {WebGLRenderTarget} from 'three';\nimport {DataTexture} from 'three';\nimport {TypeAssert} from '../../../poly/Assert';\nimport {Texture} from 'three';\n// import {CoreImage} from '../../../../core/Image';\n\nexport enum DataTextureControllerBufferType {\n\tUint8Array = 'Uint8Array',\n\tUint8ClampedArray = 'Uint8ClampedArray',\n\tUint16Array = 'Uint16Array',\n\tFloat32Array = 'Float32Array',\n}\n\nexport class DataTextureController {\n\tprivate _dataTexture: DataTexture | undefined;\n\n\tprivate bufferType: DataTextureControllerBufferType;\n\tconstructor(bufferType?: DataTextureControllerBufferType) {\n\t\tthis.bufferType =\n\t\t\tbufferType ||\n\t\t\t(CoreUserAgent.isiOS()\n\t\t\t\t? DataTextureControllerBufferType.Uint16Array\n\t\t\t\t: DataTextureControllerBufferType.Float32Array);\n\t}\n\n\tfromRenderTarget(renderer: WebGLRenderer, renderTarget: WebGLRenderTarget) {\n\t\tif (!this._dataTexture || !this._sameDimensions(renderTarget.texture)) {\n\t\t\tthis._dataTexture = this._createDataTexture(renderTarget.texture);\n\t\t}\n\t\tthis._copyToDataTexture(renderer, renderTarget);\n\t\treturn this._dataTexture;\n\t}\n\t// fromTexture(texture: Texture): DataTexture {\n\t// \tconst src_data = CoreImage.data_from_image(texture.image);\n\n\t// \tif (!this._data_texture || !this._same_dimensions(texture)) {\n\t// \t\tthis._data_texture = this._create_data_texture(texture);\n\t// \t}\n\n\t// \tconst length = src_data.width * src_data.height;\n\t// \tconst src_tex_data = src_data.data;\n\t// \tconst dest_ext_data = this._data_texture.image.data;\n\t// \tconst stride = 4;\n\t// \tconst l4 = length * stride;\n\t// \tfor (let i = 0; i < l4; i++) {\n\t// \t\tdest_ext_data[i] = src_tex_data[i];\n\t// \t\t// dest_ext_data[i + 1] = src_tex_data[i + 1];\n\t// \t\t// dest_ext_data[i + 2] = src_tex_data[i + 2];\n\t// \t\t// dest_ext_data[i + 3] = src_tex_data[i + 3];\n\t// \t}\n\t// \treturn this._data_texture;\n\t// }\n\n\t// dataTexture() {\n\t// \treturn this._dataTexture;\n\t// }\n\n\treset() {\n\t\tthis._dataTexture = undefined;\n\t}\n\n\tprivate _copyToDataTexture(renderer: WebGLRenderer, renderTarget: WebGLRenderTarget) {\n\t\tconst image = renderTarget.texture.image;\n\t\tthis._dataTexture = this._dataTexture || this._createDataTexture(renderTarget.texture);\n\t\trenderer.readRenderTargetPixels(renderTarget, 0, 0, image.width, image.height, this._dataTexture.image.data);\n\t\tthis._dataTexture.needsUpdate = true;\n\t}\n\n\tprivate _createDataTexture(texture: Texture) {\n\t\tconst image = texture.image;\n\t\tconst pixelBuffer = this._createPixelBuffer(image.width, image.height);\n\t\tconst dataTexture = new DataTexture(\n\t\t\tpixelBuffer,\n\t\t\timage.width,\n\t\t\timage.height,\n\t\t\ttexture.format as PixelFormat,\n\t\t\ttexture.type,\n\t\t\ttexture.mapping as Mapping,\n\t\t\ttexture.wrapS,\n\t\t\ttexture.wrapT,\n\t\t\ttexture.magFilter,\n\t\t\ttexture.minFilter,\n\t\t\ttexture.anisotropy,\n\t\t\ttexture.colorSpace\n\t\t);\n\t\treturn dataTexture;\n\t}\n\n\tprivate _createPixelBuffer(width: number, height: number) {\n\t\tconst size = width * height * 4;\n\n\t\t// for env maps:\n\t\t// Uint8Array, Uint8ClampedArray\n\t\t// using Float32 array gives the following error when calling readRenderTargetPixels:\n\t\t// WebGL: INVALID_OPERATION: texImage2D: type UNSIGNED_BYTE but ArrayBufferView not Uint8Array or Uint8ClampedArray\n\n\t\tswitch (this.bufferType) {\n\t\t\tcase DataTextureControllerBufferType.Uint8Array:\n\t\t\t\treturn new Uint8Array(size);\n\t\t\tcase DataTextureControllerBufferType.Uint8ClampedArray:\n\t\t\t\treturn new Uint8ClampedArray(size);\n\t\t\tcase DataTextureControllerBufferType.Uint16Array:\n\t\t\t\treturn new Uint16Array(size);\n\t\t\tcase DataTextureControllerBufferType.Float32Array:\n\t\t\t\treturn new Float32Array(size);\n\t\t}\n\t\tTypeAssert.unreachable(this.bufferType);\n\t}\n\n\tprivate _sameDimensions(texture: Texture): boolean {\n\t\tif (this._dataTexture) {\n\t\t\tconst sameW = this._dataTexture.image.width == texture.image.width;\n\t\t\tconst sameH = this._dataTexture.image.height == texture.image.height;\n\t\t\treturn sameW && sameH;\n\t\t} else {\n\t\t\treturn true;\n\t\t}\n\t}\n}\n","/**\n * Starts and pauses animations\n *\n *\n */\nimport {TypedEventNode} from './_Base';\nimport {EventContext} from '../../scene/utils/events/_BaseEventsController';\nimport {EventConnectionPoint, EventConnectionPointType} from '../utils/io/connections/Event';\nimport {BaseNodeType} from '../_Base';\nimport {NodeContext} from '../../poly/NodeContext';\nimport {TimelineBuilder} from '../../../core/animation/TimelineBuilder';\nimport {NodeParamsConfig, ParamConfig} from '../utils/params/ParamsConfig';\nimport {isBooleanTrue} from '../../../core/Type';\nimport {GsapCoreTimeline, gsapTimeline} from '../../../core/thirdParty/gsap/gsapFactory';\nimport {ModuleName} from '../../poly/registers/modules/Common';\n\nenum AnimationEventInput {\n\tSTART = 'start',\n\tSTOP = 'stop',\n\tUPDATE = 'update',\n}\nexport enum AnimationEventOutput {\n\tSTART = 'start',\n\tCOMPLETE = 'completed',\n}\n\nclass AnimationEventParamsConfig extends NodeParamsConfig {\n\t/** @parm animation node */\n\tanimation = ParamConfig.NODE_PATH('', {\n\t\tnodeSelection: {context: NodeContext.ANIM},\n\t\tdependentOnFoundNode: false,\n\t});\n\t/** @parm presses to play the animation */\n\tplay = ParamConfig.BUTTON(null, {\n\t\tcallback: (node: BaseNodeType) => {\n\t\t\tAnimationEventNode.PARAM_CALLBACK_play(node as AnimationEventNode);\n\t\t},\n\t});\n\t/** @parm presses to pause the animation */\n\tpause = ParamConfig.BUTTON(null, {\n\t\tcallback: (node: BaseNodeType) => {\n\t\t\tAnimationEventNode.PARAM_CALLBACK_pause(node as AnimationEventNode);\n\t\t},\n\t});\n\t/** @param stops previous animations still in progress started by this node */\n\tstopsPreviousAnim = ParamConfig.BOOLEAN(1);\n}\nconst ParamsConfig = new AnimationEventParamsConfig();\n\nexport class AnimationEventNode extends TypedEventNode<AnimationEventParamsConfig> {\n\toverride paramsConfig = ParamsConfig;\n\tstatic override type() {\n\t\treturn 'animation';\n\t}\n\toverride requiredModules() {\n\t\treturn [ModuleName.GSAP];\n\t}\n\n\tprivate _timelineBuilder: TimelineBuilder | undefined;\n\tprivate _timeline: GsapCoreTimeline | undefined;\n\n\toverride initializeNode() {\n\t\tthis.io.inputs.setNamedInputConnectionPoints([\n\t\t\tnew EventConnectionPoint(AnimationEventInput.START, EventConnectionPointType.BASE, this._play.bind(this)),\n\t\t\tnew EventConnectionPoint(AnimationEventInput.STOP, EventConnectionPointType.BASE, this._pause.bind(this)),\n\t\t]);\n\n\t\tthis.io.outputs.setNamedOutputConnectionPoints([\n\t\t\tnew EventConnectionPoint(AnimationEventOutput.START, EventConnectionPointType.BASE),\n\t\t\tnew EventConnectionPoint(AnimationEventOutput.COMPLETE, EventConnectionPointType.BASE),\n\t\t]);\n\t}\n\n\toverride processEvent(event_context: EventContext<Event>) {\n\t\t// this.dispatchEventToOutput(OUTPUT_NAME, event_context);\n\t}\n\n\tstatic PARAM_CALLBACK_play(node: AnimationEventNode) {\n\t\tnode._play({});\n\t}\n\tstatic PARAM_CALLBACK_pause(node: AnimationEventNode) {\n\t\tnode._pause();\n\t}\n\n\tprivate async _play(event_context: EventContext<Event>) {\n\t\tconst param = this.p.animation;\n\t\tif (param.isDirty()) {\n\t\t\tawait param.compute();\n\t\t}\n\t\tconst node = param.value.nodeWithContext(NodeContext.ANIM);\n\t\tif (!node) {\n\t\t\treturn;\n\t\t}\n\t\tconst container = await node.compute();\n\t\tif (!container) {\n\t\t\treturn;\n\t\t}\n\t\tthis._timelineBuilder = container.coreContent();\n\t\tif (!this._timelineBuilder) {\n\t\t\treturn;\n\t\t}\n\t\tif (this._timeline && isBooleanTrue(this.pv.stopsPreviousAnim)) {\n\t\t\tthis._timeline.kill();\n\t\t}\n\t\tthis._timeline = gsapTimeline();\n\t\tif (!this._timeline) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis._timelineBuilder.populate(this._timeline, {registerproperties: true});\n\t\tthis._timeline.vars.onStart = () => {\n\t\t\tthis._triggerAnimationStarted(event_context);\n\t\t};\n\t\tthis._timeline.vars.onComplete = () => {\n\t\t\tthis._triggerAnimationCompleted(event_context);\n\t\t};\n\t}\n\tprivate _pause() {\n\t\tif (this._timeline) {\n\t\t\tthis._timeline.pause();\n\t\t}\n\t}\n\n\tprivate _triggerAnimationStarted(event_context: EventContext<Event>) {\n\t\tthis.dispatchEventToOutput(AnimationEventOutput.START, event_context);\n\t}\n\tprivate _triggerAnimationCompleted(event_context: EventContext<Event>) {\n\t\tthis.dispatchEventToOutput(AnimationEventOutput.COMPLETE, event_context);\n\t}\n}\n","/**\n * Blocks incoming envetts\n *\n * @remarks\n * This can be useful to debug events, to prevents incoming events to be propagatted further.\n *\n *\n */\nimport {TypedEventNode} from './_Base';\nimport {EventContext} from '../../scene/utils/events/_BaseEventsController';\nimport {EventConnectionPoint, EventConnectionPointType} from '../utils/io/connections/Event';\nimport {NodeParamsConfig, ParamConfig} from '../utils/params/ParamsConfig';\nimport {isBooleanTrue} from '../../../core/BooleanValue';\n\nclass BlockParamsConfig extends NodeParamsConfig {\n\t/** @param toggle on to block incoming events */\n\tblocking = ParamConfig.BOOLEAN(1);\n}\nconst ParamsConfig = new BlockParamsConfig();\n\nexport class BlockEventNode extends TypedEventNode<BlockParamsConfig> {\n\toverride paramsConfig = ParamsConfig;\n\n\tstatic override type() {\n\t\treturn 'block';\n\t}\n\tstatic readonly OUTPUT = 'output';\n\n\toverride initializeNode() {\n\t\tthis.io.inputs.setNamedInputConnectionPoints([\n\t\t\tnew EventConnectionPoint('in', EventConnectionPointType.BASE, this._process_incoming_event.bind(this)),\n\t\t]);\n\t\tthis.io.outputs.setNamedOutputConnectionPoints([\n\t\t\tnew EventConnectionPoint(BlockEventNode.OUTPUT, EventConnectionPointType.BASE),\n\t\t]);\n\t}\n\n\tprivate trigger_output(context: EventContext<MouseEvent>) {\n\t\tthis.dispatchEventToOutput(BlockEventNode.OUTPUT, context);\n\t}\n\n\tprivate _process_incoming_event(context: EventContext<MouseEvent>) {\n\t\tif (!isBooleanTrue(this.pv.blocking)) {\n\t\t\tthis.trigger_output(context);\n\t\t}\n\t}\n}\n","import {MOUSE, TOUCH} from 'three';\n\nimport {OrbitControls} from './OrbitControls.js';\n\n// MapControls performs orbiting, dollying (zooming), and panning.\n// Unlike TrackballControls, it maintains the \"up\" direction object.up (+Y by default).\n//\n//    Orbit - right mouse, or left mouse + ctrl/meta/shiftKey / touch: two-finger rotate\n//    Zoom - middle mouse, or mousewheel / touch: two-finger spread or squish\n//    Pan - left mouse, or arrow keys / touch: one-finger move\n\nclass MapControls extends OrbitControls {\n\tconstructor(object, domElement) {\n\t\tsuper(object, domElement);\n\n\t\tthis.screenSpacePanning = false; // pan orthogonal to world-space direction camera.up\n\n\t\tthis.mouseButtons = {LEFT: MOUSE.PAN, MIDDLE: MOUSE.DOLLY, RIGHT: MOUSE.ROTATE};\n\n\t\tthis.touches = {ONE: TOUCH.PAN, TWO: TOUCH.DOLLY_ROTATE};\n\t}\n}\n\nexport {MapControls};\n","/**\n * Creates a THREE MapControls\n *\n * @remarks\n * This can be linked to a camera's controls parameter\n *\n */\nimport {Camera} from 'three';\n\nimport {CameraControlsNodeType} from '../../poly/NodeContext';\nimport {CameraOrbitControlsEventNode} from './CameraOrbitControls';\n\n// see note in orbitControls\n// regarding where to import the module from\nimport {MapControls} from '../../../modules/core/controls/MapControls';\n// import {MapControls} from 'three/examples/jsm/controls/OrbitControls';\n\nexport class CameraMapControlsEventNode extends CameraOrbitControlsEventNode {\n\tstatic override type() {\n\t\treturn CameraControlsNodeType.MAP;\n\t}\n\n\tprotected override _createControls(camera: Camera, element: HTMLElement) {\n\t\treturn new MapControls(camera, element);\n\t}\n}\n","/**\n * Allows to trigger drag events.\n *\n *\n */\nimport {EventConnectionPoint, EventConnectionPointType} from '../utils/io/connections/Event';\nimport {BaseNodeType} from '../_Base';\nimport {NodeParamsConfig, ParamConfig} from '../utils/params/ParamsConfig';\nimport {TypedInputEventNode, EVENT_PARAM_OPTIONS} from './_BaseInput';\nimport {isBooleanTrue} from '../../../core/BooleanValue';\nimport {EventContext} from '../../scene/utils/events/_BaseEventsController';\nimport {EventInputType} from '../../poly/registers/nodes/types/Event';\nimport {CoreEventEmitter, EVENT_EMITTERS, EVENT_EMITTER_PARAM_MENU_OPTIONS} from '../../../core/event/CoreEventEmitter';\nimport {ACCEPTED_DRAG_EVENT_TYPES} from '../../../core/event/DragEventType';\nclass DragEventParamsConfig extends NodeParamsConfig {\n\t/** @param toggle on to allow any event to be listened to */\n\tactive = ParamConfig.BOOLEAN(true, {\n\t\tcallback: (node: BaseNodeType) => {\n\t\t\tDragEventNode.PARAM_CALLBACK_updateRegister(node as DragEventNode);\n\t\t},\n\t\tseparatorAfter: true,\n\t});\n\t/** @param set which element triggers the event */\n\telement = ParamConfig.INTEGER(EVENT_EMITTERS.indexOf(CoreEventEmitter.CANVAS), {\n\t\t...EVENT_EMITTER_PARAM_MENU_OPTIONS,\n\t\tseparatorAfter: true,\n\t});\n\t/** @param toggle on to listen to dragover events */\n\tdragover = ParamConfig.BOOLEAN(1, EVENT_PARAM_OPTIONS);\n\t/** @param requires ctrlKey */\n\tctrlKey = ParamConfig.BOOLEAN(0, {...EVENT_PARAM_OPTIONS, separatorBefore: true});\n\t/** @param requires altKey */\n\taltKey = ParamConfig.BOOLEAN(0, EVENT_PARAM_OPTIONS);\n\t/** @param requires shiftKey */\n\tshiftKey = ParamConfig.BOOLEAN(0, EVENT_PARAM_OPTIONS);\n\t/** @param requires metaKey */\n\tmetaKey = ParamConfig.BOOLEAN(0, EVENT_PARAM_OPTIONS);\n}\nconst ParamsConfig = new DragEventParamsConfig();\n\nexport class DragEventNode extends TypedInputEventNode<DragEventParamsConfig> {\n\toverride paramsConfig = ParamsConfig;\n\tstatic override type() {\n\t\treturn EventInputType.DRAG;\n\t}\n\tprotected acceptedEventTypes() {\n\t\treturn new Set([...ACCEPTED_DRAG_EVENT_TYPES]);\n\t}\n\toverride initializeNode() {\n\t\tthis.io.outputs.setNamedOutputConnectionPoints(\n\t\t\tACCEPTED_DRAG_EVENT_TYPES.map((event_type) => {\n\t\t\t\treturn new EventConnectionPoint(event_type, EventConnectionPointType.DRAG);\n\t\t\t})\n\t\t);\n\t}\n\toverride processEvent(eventContext: EventContext<DragEvent>) {\n\t\tif (!this.pv.active) {\n\t\t\treturn;\n\t\t}\n\t\tconst event = eventContext.event;\n\t\tif (!event) {\n\t\t\treturn;\n\t\t}\n\t\tif (event.ctrlKey != isBooleanTrue(this.pv.ctrlKey)) {\n\t\t\treturn;\n\t\t}\n\t\tif (event.shiftKey != isBooleanTrue(this.pv.shiftKey)) {\n\t\t\treturn;\n\t\t}\n\t\tif (event.altKey != isBooleanTrue(this.pv.altKey)) {\n\t\t\treturn;\n\t\t}\n\t\tif (event.metaKey != isBooleanTrue(this.pv.metaKey)) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis.dispatchEventToOutput(event.type, eventContext);\n\t}\n}\n","import {CorePlayer} from './Player';\n\nfunction stopEvent(e: KeyboardEvent) {\n\t// to prevent space from pausing from the editor\n\te.preventDefault();\n}\nexport class CorePlayerKeyEvents {\n\tconstructor(private player: CorePlayer) {}\n\tprivate _onKeyDown(e: KeyboardEvent) {\n\t\tif (e.ctrlKey) {\n\t\t\t// if ctrl is pressed, we do not register any event.\n\t\t\t// this is mostly to allow Ctrl+S to work without triggering a player movement\n\t\t\treturn;\n\t\t}\n\t\tswitch (e.code) {\n\t\t\tcase 'ArrowUp':\n\t\t\tcase 'KeyW':\n\t\t\t\tthis.player.setForward(true);\n\t\t\t\tstopEvent(e);\n\t\t\t\tbreak;\n\t\t\tcase 'ArrowDown':\n\t\t\tcase 'KeyS':\n\t\t\t\tthis.player.setBackward(true);\n\t\t\t\tstopEvent(e);\n\t\t\t\tbreak;\n\t\t\tcase 'ArrowRight':\n\t\t\tcase 'KeyD':\n\t\t\t\tthis.player.setRight(true);\n\t\t\t\tstopEvent(e);\n\t\t\t\tbreak;\n\t\t\tcase 'ArrowLeft':\n\t\t\tcase 'KeyA':\n\t\t\t\tthis.player.setLeft(true);\n\t\t\t\tstopEvent(e);\n\t\t\t\tbreak;\n\t\t\tcase 'Space':\n\t\t\t\tthis.player.jump();\n\t\t\t\tstopEvent(e);\n\t\t\t\tbreak;\n\t\t\tcase 'ShiftLeft':\n\t\t\tcase 'ShiftRight':\n\t\t\t\tthis.player.setRun(true);\n\t\t\t\tstopEvent(e);\n\t\t\t\tbreak;\n\t\t}\n\t}\n\tprivate _onKeyUp(e: KeyboardEvent) {\n\t\tswitch (e.code) {\n\t\t\tcase 'ArrowUp':\n\t\t\tcase 'KeyW':\n\t\t\t\tthis.player.setForward(false);\n\t\t\t\tbreak;\n\t\t\tcase 'ArrowDown':\n\t\t\tcase 'KeyS':\n\t\t\t\tthis.player.setBackward(false);\n\t\t\t\tbreak;\n\t\t\tcase 'ArrowRight':\n\t\t\tcase 'KeyD':\n\t\t\t\tthis.player.setRight(false);\n\t\t\t\tbreak;\n\t\t\tcase 'ArrowLeft':\n\t\t\tcase 'KeyA':\n\t\t\t\tthis.player.setLeft(false);\n\t\t\t\tbreak;\n\t\t\tcase 'ShiftLeft':\n\t\t\tcase 'ShiftRight':\n\t\t\t\tthis.player.setRun(false);\n\t\t\t\tstopEvent(e);\n\t\t\t\tbreak;\n\t\t}\n\t}\n\tprivate _bounds = {\n\t\tkeydown: this._onKeyDown.bind(this),\n\t\tkeyup: this._onKeyUp.bind(this),\n\t};\n\taddEvents() {\n\t\tdocument.addEventListener('keydown', this._bounds.keydown);\n\t\tdocument.addEventListener('keyup', this._bounds.keyup);\n\t}\n\tremoveEvents() {\n\t\tdocument.removeEventListener('keydown', this._bounds.keydown);\n\t\tdocument.removeEventListener('keyup', this._bounds.keyup);\n\t}\n}\n","import {BaseEvent, Euler, Camera, EventDispatcher, Vector3, Spherical} from 'three';\nimport {CorePlayer} from '../../../core/player/Player';\nimport {CorePlayerKeyEvents} from '../../../core/player/KeyEvents';\n\nconst changeEvent: BaseEvent<'change'> = {type: 'change' as 'change'};\nconst lockEvent: BaseEvent<'lock'> = {type: 'lock'};\nconst unlockEvent: BaseEvent<'unlock'> = {type: 'unlock'};\nconst PI_2 = Math.PI / 2;\nconst tmpCameraUnproject = new Vector3();\nconst spherical = new Spherical();\n\nconst LOCK_ELEMENT_DEFAULT_HTML = `\n<div style=\"\n\ttext-align:center;\n\tposition: absolute;\n\ttop: 50%;\n\tleft: 50%;\n\ttransform: translate(-50%,-50%);\n\tcursor: pointer;\n\tpadding: 5px 10px;\n\tbackground:gray;\n\tborder:white;\n\tcolor: white;\n\t\">\n\t<div style=\"font-size: 1rem\">CLICK TO START</div>\n\t<div style=\"font-size: 0.6rem\">press ESC to show your cursor</div>\n</div>\n`;\n\ninterface PointerLockControlsOptions {\n\tlockHTMLElement?: HTMLElement;\n}\n\nexport class PointerLockControls extends EventDispatcher<{change: any}> {\n\tprivate isLocked = false;\n\tpublic minPolarAngle = 0; // radians\n\tpublic maxPolarAngle = Math.PI; // radians\n\tpublic rotateSpeed = 1;\n\tprivate euler = new Euler(0, 0, 0, 'YXZ');\n\tprivate boundMethods = {\n\t\tlock: this.lock.bind(this),\n\t\tonMouseMove: this.onMouseMove.bind(this),\n\t\tonPointerlockChange: this.onPointerlockChange.bind(this),\n\t\tonPointerlockError: this.onPointerlockError.bind(this),\n\t};\n\tprivate _azimuthalAngle: number = 0;\n\tprivate _corePlayerKeyEvents: CorePlayerKeyEvents | undefined;\n\n\tconstructor(\n\t\tprivate camera: Camera,\n\t\tpublic readonly domElement: HTMLElement,\n\t\tprivate options: PointerLockControlsOptions,\n\t\tprivate player?: CorePlayer\n\t) {\n\t\tsuper();\n\t\tthis.connect();\n\t\tthis._showUnlockHTMLElement();\n\t}\n\n\tonMouseMove(event: MouseEvent) {\n\t\tif (this.isLocked === false) return;\n\n\t\tvar movementX = event.movementX || (event as any).mozMovementX || (event as any).webkitMovementX || 0;\n\t\tvar movementY = event.movementY || (event as any).mozMovementY || (event as any).webkitMovementY || 0;\n\n\t\tthis.euler.setFromQuaternion(this.camera.quaternion);\n\n\t\tthis.euler.y -= movementX * 0.002 * this.rotateSpeed;\n\t\tthis.euler.x -= movementY * 0.002 * this.rotateSpeed;\n\n\t\tthis.euler.x = Math.max(PI_2 - this.maxPolarAngle, Math.min(PI_2 - this.minPolarAngle, this.euler.x));\n\n\t\tthis.camera.quaternion.setFromEuler(this.euler);\n\t\tthis._computeAzimuthalAngle();\n\n\t\tthis.dispatchEvent(changeEvent);\n\t}\n\tprivate _computeAzimuthalAngle() {\n\t\tthis.camera.updateMatrixWorld();\n\t\ttmpCameraUnproject.set(0, 0, 1);\n\t\tthis.camera.localToWorld(tmpCameraUnproject);\n\t\ttmpCameraUnproject.sub(this.camera.position);\n\t\tspherical.setFromVector3(tmpCameraUnproject);\n\t\tthis._azimuthalAngle = spherical.theta;\n\t}\n\n\tonPointerlockChange() {\n\t\t// this.velocity.set(0, 0, 0);\n\t\tif (this.domElement.ownerDocument.pointerLockElement === this.domElement) {\n\t\t\tthis.dispatchEvent(lockEvent);\n\n\t\t\tthis.isLocked = true;\n\t\t\tthis._removeHTMLElement();\n\t\t\tif (this.player) {\n\t\t\t\tthis._corePlayerKeyEvents = this._corePlayerKeyEvents || new CorePlayerKeyEvents(this.player);\n\t\t\t\tthis._corePlayerKeyEvents.addEvents();\n\t\t\t}\n\t\t} else {\n\t\t\tthis.dispatchEvent(unlockEvent);\n\t\t\tthis.isLocked = false;\n\t\t\tthis._showUnlockHTMLElement();\n\t\t\tthis._corePlayerKeyEvents?.removeEvents();\n\t\t\tthis.player?.stop();\n\t\t}\n\t}\n\n\tonPointerlockError() {\n\t\tconsole.error(\n\t\t\t'THREE.PointerLockControls: Unable to use Pointer Lock API (Note that you need to wait for 2 seconds to lock the pointer after having just unlocked it)'\n\t\t);\n\t}\n\tconnect() {\n\t\tthis.domElement.ownerDocument.addEventListener('mousemove', this.boundMethods.onMouseMove);\n\t\tthis.domElement.ownerDocument.addEventListener('pointerlockchange', this.boundMethods.onPointerlockChange);\n\t\tthis.domElement.ownerDocument.addEventListener('pointerlockerror', this.boundMethods.onPointerlockError);\n\t}\n\n\tdisconnect() {\n\t\tthis.domElement.ownerDocument.removeEventListener('mousemove', this.boundMethods.onMouseMove);\n\t\tthis.domElement.ownerDocument.removeEventListener('pointerlockchange', this.boundMethods.onPointerlockChange);\n\t\tthis.domElement.ownerDocument.removeEventListener('pointerlockerror', this.boundMethods.onPointerlockError);\n\t}\n\n\tdispose() {\n\t\tthis.disconnect();\n\t\tthis._removeHTMLElement();\n\t}\n\n\tgetObject() {\n\t\t// retaining this method for backward compatibility\n\n\t\treturn this.camera;\n\t}\n\n\tlock() {\n\t\tthis.domElement.requestPointerLock();\n\t}\n\n\tunlock() {\n\t\tthis.domElement.ownerDocument.exitPointerLock();\n\t}\n\n\tupdate(delta: number) {\n\t\tif (this.player) {\n\t\t\tthis.player.setAzimuthalAngle(this._azimuthalAngle);\n\t\t\tthis.player.update(delta);\n\t\t}\n\t}\n\n\t//\n\t//\n\t// HTML Element\n\t//\n\t//\n\tprivate __unlockHTMLElement: HTMLElement | undefined;\n\tprivate _unlockHTMLElementParent() {\n\t\treturn this.domElement.parentElement;\n\t}\n\tprivate _unlockHTMLElement() {\n\t\treturn (this.__unlockHTMLElement = this.__unlockHTMLElement || this._getUnlockHTMLElement());\n\t}\n\tprivate _showUnlockHTMLElement() {\n\t\tconst el = this._unlockHTMLElement();\n\t\tif (!el) {\n\t\t\treturn;\n\t\t}\n\t\tthis._unlockHTMLElementParent()?.append(el);\n\t}\n\tprivate _getUnlockHTMLElement(): HTMLElement | undefined {\n\t\tconst element = this.options.lockHTMLElement || this._createUnlockHTMLElement();\n\t\telement.addEventListener('pointerdown', this.boundMethods.lock);\n\t\treturn element;\n\t}\n\tprivate _createUnlockHTMLElement(): HTMLElement {\n\t\tconst el = document.createElement('div');\n\t\tel.innerHTML = LOCK_ELEMENT_DEFAULT_HTML;\n\t\treturn el;\n\t}\n\tprivate _removeHTMLElement() {\n\t\tif (!this.__unlockHTMLElement) {\n\t\t\treturn;\n\t\t}\n\t\tthis._unlockHTMLElementParent()?.removeChild(this.__unlockHTMLElement);\n\t\tthis.__unlockHTMLElement.removeEventListener('pointerdown', this.boundMethods.lock);\n\t\tthis.__unlockHTMLElement = undefined;\n\t}\n}\n","/**\n * Creates a PointerLockControls\n *\n * @remarks\n * This allows you to create a First-Person navigation, using the WASD keys.\n *\n */\nimport {Camera} from 'three';\nimport {CapsuleSopOperation} from './../../operations/sop/Capsule';\nimport {TypedCameraControlsEventNode} from './_BaseCameraControls';\nimport {NodeParamsConfig, ParamConfig} from '../utils/params/ParamsConfig';\nimport {EventConnectionPoint, EventConnectionPointType} from '../utils/io/connections/Event';\nimport {PointerLockControls} from '../../../modules/core/controls/PointerLockControls';\nimport {CameraControlsNodeType, NodeContext} from '../../poly/NodeContext';\nimport {BaseNodeType} from '../_Base';\nimport {ParamOptions} from '../../params/utils/OptionsController';\nimport {CorePlayer, CorePlayerOptions} from '../../../core/player/Player';\nimport {isBooleanTrue} from '../../../core/BooleanValue';\nimport {CollisionController} from './collision/CollisionController';\n\nconst EVENT_LOCK = 'lock';\nconst EVENT_CHANGE = 'change';\nconst EVENT_UNLOCK = 'unlock';\n\nfunction updatePlayerParamsCallbackOption(): ParamOptions {\n\treturn {\n\t\tcook: false,\n\t\tcallback: (node: BaseNodeType) => {\n\t\t\tFirstPersonControlsEventNode.PARAM_CALLBACK_updatePlayerParams(node as FirstPersonControlsEventNode);\n\t\t},\n\t};\n}\n\ntype PointerLockControlsMap = Map<string, PointerLockControls>;\n\nclass FirstPersonEventParamsConfig extends NodeParamsConfig {\n\tmain = ParamConfig.FOLDER();\n\t/** @param collider object */\n\tcolliderObject = ParamConfig.NODE_PATH('', {\n\t\tnodeSelection: {\n\t\t\tcontext: NodeContext.SOP,\n\t\t},\n\t\t// if the node is dependent,\n\t\t// the FirstPersonControls will be re-created when this node changes\n\t\t// which we do not want, as it will act like a hard reset\n\t\t// when all we want is to update the collider\n\t\tdependentOnFoundNode: false,\n\t\tcallback: (node: BaseNodeType) => {\n\t\t\tFirstPersonControlsEventNode.PARAM_CALLBACK_updateCollider(node as FirstPersonControlsEventNode);\n\t\t},\n\t});\n\t/** @param click to lock controls */\n\tlock = ParamConfig.BUTTON(null, {\n\t\tcallback: (node: BaseNodeType) => {\n\t\t\tFirstPersonControlsEventNode.PARAM_CALLBACK_lockControls(node as FirstPersonControlsEventNode);\n\t\t},\n\t});\n\t/** @param click to unlock controls */\n\tunlock = ParamConfig.BUTTON(null, {\n\t\tcallback: (node: BaseNodeType) => {\n\t\t\tFirstPersonControlsEventNode.PARAM_CALLBACK_unlockControls(node as FirstPersonControlsEventNode);\n\t\t},\n\t});\n\t/** @param collision Capsule Radius */\n\tcapsuleRadius = ParamConfig.FLOAT(CapsuleSopOperation.DEFAULT_PARAMS.radius, {\n\t\trange: [0, 1],\n\t\trangeLocked: [true, false],\n\t\t...updatePlayerParamsCallbackOption(),\n\t});\n\t/** @param collision Capsule Height */\n\tcapsuleHeight = ParamConfig.FLOAT(CapsuleSopOperation.DEFAULT_PARAMS.height, {\n\t\trange: [0, 2],\n\t\trangeLocked: [true, false],\n\t\t...updatePlayerParamsCallbackOption(),\n\t});\n\n\tphysics = ParamConfig.FOLDER();\n\t/** @param physics Steps */\n\tphysicsSteps = ParamConfig.INTEGER(5, {\n\t\trange: [1, 10],\n\t\trangeLocked: [true, false],\n\t\t...updatePlayerParamsCallbackOption(),\n\t});\n\t/** @param gravity */\n\tgravity = ParamConfig.VECTOR3([0, -30, 0], {\n\t\t...updatePlayerParamsCallbackOption(),\n\t});\n\t/** @param translate speed */\n\ttranslateSpeed = ParamConfig.FLOAT(1, {\n\t\trange: [0, 10],\n\t\trangeLocked: [true, false],\n\t\t...updatePlayerParamsCallbackOption(),\n\t});\n\t/** @param rotate speed */\n\trotateSpeed = ParamConfig.FLOAT(1, {\n\t\trange: [0, 10],\n\t\trangeLocked: [true, false],\n\t\t// ...updatePlayerParamsCallbackOption(),\n\t});\n\t/** @param jump Allowed */\n\tjumpAllowed = ParamConfig.BOOLEAN(true, {\n\t\t...updatePlayerParamsCallbackOption(),\n\t});\n\t/** @param jump Force */\n\tjumpStrength = ParamConfig.FLOAT(10, {\n\t\trange: [0, 100],\n\t\trangeLocked: [true, false],\n\t\tvisibleIf: {jumpAllowed: 1},\n\t\t...updatePlayerParamsCallbackOption(),\n\t});\n\t/** @param run Allowed */\n\trunAllowed = ParamConfig.BOOLEAN(true, {\n\t\t...updatePlayerParamsCallbackOption(),\n\t});\n\t/** @param run speed mult */\n\trunSpeedMult = ParamConfig.FLOAT(2, {\n\t\trange: [0, 10],\n\t\trangeLocked: [true, false],\n\t\tvisibleIf: {runAllowed: 1},\n\t\t...updatePlayerParamsCallbackOption(),\n\t});\n\t/** @param recompute colliding geo */\n\tupdateCollider = ParamConfig.BUTTON(null, {\n\t\tcallback: (node: BaseNodeType) => {\n\t\t\tFirstPersonControlsEventNode.PARAM_CALLBACK_updateCollider(node as FirstPersonControlsEventNode);\n\t\t},\n\t});\n\n\tinit = ParamConfig.FOLDER();\n\t/** @param start Position */\n\tstartPosition = ParamConfig.VECTOR3([0, 2, 0], {\n\t\t...updatePlayerParamsCallbackOption(),\n\t});\n\t/** @param start Position */\n\tstartRotation = ParamConfig.VECTOR3([0, 0, 0], {\n\t\t...updatePlayerParamsCallbackOption(),\n\t});\n\t/** @param reset */\n\treset = ParamConfig.BUTTON(null, {\n\t\tcallback: (node: BaseNodeType) => {\n\t\t\tFirstPersonControlsEventNode.PARAM_CALLBACK_resetPlayer(node as FirstPersonControlsEventNode);\n\t\t},\n\t});\n\t/** @param min rotation angle */\n\tminPolarAngle = ParamConfig.FLOAT(0, {\n\t\trange: [0, Math.PI],\n\t\trangeLocked: [true, true],\n\t});\n\t/** @param max rotation angle */\n\tmaxPolarAngle = ParamConfig.FLOAT('$PI', {\n\t\trange: [0, Math.PI],\n\t\trangeLocked: [true, true],\n\t});\n\thtml = ParamConfig.FOLDER();\n\t/** @param specify a custom HTML element */\n\tcustomLockCursorElement = ParamConfig.BOOLEAN(false);\n\t/** @param jump HTML element selector */\n\tlockCursorElementSelector = ParamConfig.STRING('#lock-cursor-element', {\n\t\tvisibleIf: {\n\t\t\tcustomLockCursorElement: true,\n\t\t},\n\t});\n}\nconst ParamsConfig = new FirstPersonEventParamsConfig();\n\nexport class FirstPersonControlsEventNode extends TypedCameraControlsEventNode<FirstPersonEventParamsConfig> {\n\toverride paramsConfig = ParamsConfig;\n\tstatic override type() {\n\t\treturn CameraControlsNodeType.FIRST_PERSON;\n\t}\n\tendEventName() {\n\t\treturn 'unlock';\n\t}\n\tstatic readonly INPUT_UPDATE_COLLIDER = 'updateCollider';\n\tstatic readonly INPUT_RESET = 'reset';\n\tprivate _collisionController: CollisionController | undefined;\n\tcollisionController(): CollisionController {\n\t\treturn (this._collisionController = this._collisionController || new CollisionController(this));\n\t}\n\toverride initializeNode() {\n\t\tthis.io.inputs.setNamedInputConnectionPoints([\n\t\t\tnew EventConnectionPoint(EVENT_LOCK, EventConnectionPointType.BASE, this.lockControls.bind(this)),\n\t\t\tnew EventConnectionPoint(\n\t\t\t\tFirstPersonControlsEventNode.INPUT_UPDATE_COLLIDER,\n\t\t\t\tEventConnectionPointType.BASE,\n\t\t\t\tthis._updateCollider.bind(this)\n\t\t\t),\n\t\t\tnew EventConnectionPoint(\n\t\t\t\tFirstPersonControlsEventNode.INPUT_RESET,\n\t\t\t\tEventConnectionPointType.BASE,\n\t\t\t\tthis._resetPlayer.bind(this)\n\t\t\t),\n\t\t]);\n\t\tthis.io.outputs.setNamedOutputConnectionPoints([\n\t\t\tnew EventConnectionPoint(EVENT_LOCK, EventConnectionPointType.BASE),\n\t\t\tnew EventConnectionPoint(EVENT_CHANGE, EventConnectionPointType.BASE),\n\t\t\tnew EventConnectionPoint(EVENT_UNLOCK, EventConnectionPointType.BASE),\n\t\t]);\n\t}\n\n\tprotected _controls_by_element_id: PointerLockControlsMap = new Map();\n\tprivate _player: CorePlayer | undefined;\n\n\tasync createControlsInstance(camera: Camera, element: HTMLElement) {\n\t\tawait this._initPlayer(camera);\n\t\tconst _getLockHTMLElement = () => {\n\t\t\tif (!this.pv.customLockCursorElement) {\n\t\t\t\treturn undefined;\n\t\t\t}\n\t\t\tconst element = document.querySelector(this.pv.lockCursorElementSelector) as HTMLElement | undefined;\n\t\t\treturn element;\n\t\t};\n\t\tconst lockHTMLElement = _getLockHTMLElement();\n\t\tconst controls = new PointerLockControls(camera, element, {lockHTMLElement}, this._player);\n\n\t\tthis._controls_by_element_id.set(element.id, controls);\n\t\tthis._bind_listeners_to_controls_instance(controls);\n\n\t\treturn controls;\n\t}\n\tprivate async _initPlayer(camera: Camera) {\n\t\tconst options = await this._playerOptions(camera);\n\t\tif (!options) {\n\t\t\treturn;\n\t\t}\n\t\tthis._player = this._player || new CorePlayer(options);\n\t\t// we need to make sure the player is updated with new camera/collision when those change\n\t\tthis._player.setOptions(options);\n\t\tthis._updatePlayerParams();\n\n\t\tthis._player.reset();\n\t}\n\tprivate async _playerOptions(camera: Camera): Promise<CorePlayerOptions | undefined> {\n\t\tconst collider = await this.collisionController().getCollider();\n\t\tif (!collider) {\n\t\t\tthis.states.error.set('invalid collider');\n\t\t\treturn;\n\t\t}\n\t\treturn {object: camera, collider: collider};\n\t}\n\tplayer() {\n\t\treturn this._player;\n\t}\n\tprivate async _updatePlayerParams() {\n\t\tif (!this._player) {\n\t\t\treturn;\n\t\t}\n\t\tthis._player.startPosition.copy(this.pv.startPosition);\n\t\tthis._player.startRotation.copy(this.pv.startRotation);\n\t\tthis._player.physicsSteps = this.pv.physicsSteps;\n\t\tthis._player.jumpAllowed = isBooleanTrue(this.pv.jumpAllowed);\n\t\tthis._player.jumpStrength = this.pv.jumpStrength;\n\t\tthis._player.runAllowed = isBooleanTrue(this.pv.runAllowed);\n\t\tthis._player.runSpeedMult = this.pv.runSpeedMult;\n\t\tthis._player.gravity.copy(this.pv.gravity);\n\t\tthis._player.speed = this.pv.translateSpeed;\n\t\tthis._player.setCapsule({\n\t\t\tradius: this.pv.capsuleRadius,\n\t\t\theight: this.pv.capsuleHeight,\n\t\t\tdivisions: 5,\n\t\t\tcenter: CapsuleSopOperation.DEFAULT_PARAMS.center,\n\t\t});\n\t}\n\n\tprivate _resetPlayer() {\n\t\tthis._player?.reset();\n\t}\n\n\tprivate async _updateCollider() {\n\t\tawait this.collisionController().updateCollider();\n\t}\n\tprotected _bind_listeners_to_controls_instance(controls: PointerLockControls) {\n\t\tcontrols.addEventListener(EVENT_LOCK, () => {\n\t\t\t// this._createKeysEvents(controls);\n\t\t\tthis.dispatchEventToOutput(EVENT_LOCK, {});\n\t\t});\n\t\tcontrols.addEventListener(EVENT_CHANGE, () => {\n\t\t\tthis.dispatchEventToOutput(EVENT_CHANGE, {});\n\t\t});\n\t\tcontrols.addEventListener(EVENT_UNLOCK, () => {\n\t\t\t// this._removeKeysEvents();\n\t\t\tthis.dispatchEventToOutput(EVENT_UNLOCK, {});\n\t\t});\n\t}\n\n\tupdateRequired() {\n\t\treturn true;\n\t}\n\n\tsetupControls(controls: PointerLockControls) {\n\t\tcontrols.minPolarAngle = this.pv.minPolarAngle;\n\t\tcontrols.maxPolarAngle = this.pv.maxPolarAngle;\n\t\tcontrols.rotateSpeed = this.pv.rotateSpeed;\n\t}\n\tdisposeControlsForHtmlElementId(htmlElementId: string) {\n\t\tconst controls = this._controls_by_element_id.get(htmlElementId);\n\t\tif (controls) {\n\t\t\tcontrols.dispose();\n\t\t\tthis._controls_by_element_id.delete(htmlElementId);\n\t\t}\n\t}\n\tunlockControls() {\n\t\tconst controls = this._firstControls();\n\t\tif (!controls) {\n\t\t\treturn;\n\t\t}\n\t\tcontrols.unlock();\n\t}\n\n\t//\n\t//\n\t// LOCK\n\t//\n\t//\n\tprivate lockControls() {\n\t\tconst controls = this._firstControls();\n\t\tif (!controls) {\n\t\t\treturn;\n\t\t}\n\t\tcontrols.lock();\n\t}\n\tprivate _firstControls() {\n\t\tlet firstControls: PointerLockControls | undefined;\n\t\tthis._controls_by_element_id.forEach((controls, id) => {\n\t\t\tfirstControls = firstControls || controls;\n\t\t});\n\t\treturn firstControls;\n\t}\n\n\tstatic PARAM_CALLBACK_lockControls(node: FirstPersonControlsEventNode) {\n\t\tnode.lockControls();\n\t}\n\tstatic PARAM_CALLBACK_unlockControls(node: FirstPersonControlsEventNode) {\n\t\tnode.unlockControls();\n\t}\n\tstatic PARAM_CALLBACK_updateCollider(node: FirstPersonControlsEventNode) {\n\t\tnode._updateCollider();\n\t}\n\tstatic PARAM_CALLBACK_updatePlayerParams(node: FirstPersonControlsEventNode) {\n\t\tnode._updatePlayerParams();\n\t}\n\tstatic PARAM_CALLBACK_resetPlayer(node: FirstPersonControlsEventNode) {\n\t\tnode._resetPlayer();\n\t}\n}\n","/**\n * Allows to trigger keyboard events.\n *\n *\n */\nimport {EventConnectionPoint, EventConnectionPointType} from '../utils/io/connections/Event';\nimport {BaseNodeType} from '../_Base';\nimport {BaseParamType} from '../../params/_Base';\nimport {NodeParamsConfig, ParamConfig} from '../utils/params/ParamsConfig';\nimport {TypedInputEventNode, EVENT_PARAM_OPTIONS} from './_BaseInput';\nimport {EventContext} from '../../scene/utils/events/_BaseEventsController';\nimport {isBooleanTrue} from '../../../core/BooleanValue';\nimport {stringMatchMask} from '../../../core/String';\nimport {EventInputType} from '../../poly/registers/nodes/types/Event';\nimport {CoreEventEmitter, EVENT_EMITTERS} from '../../../core/event/CoreEventEmitter';\nimport {ACCEPTED_KEYBOARD_EVENT_TYPES} from '../../../core/event/KeyboardEventType';\nclass KeyboardEventParamsConfig extends NodeParamsConfig {\n\t/** @param toggle on to allow any event to be listened to */\n\tactive = ParamConfig.BOOLEAN(true, {\n\t\tcallback: (node: BaseNodeType, param: BaseParamType) => {\n\t\t\tKeyboardEventNode.PARAM_CALLBACK_updateRegister(node as KeyboardEventNode);\n\t\t},\n\t\tseparatorAfter: true,\n\t});\n\t/** @param set which element triggers the event */\n\telement = ParamConfig.INTEGER(EVENT_EMITTERS.indexOf(CoreEventEmitter.CANVAS), {\n\t\tmenu: {\n\t\t\tentries: EVENT_EMITTERS.map((name, value) => {\n\t\t\t\treturn {name, value};\n\t\t\t}),\n\t\t},\n\t\tseparatorAfter: true,\n\t\t...EVENT_PARAM_OPTIONS,\n\t});\n\n\t/** @param toggle on to listen to keydown events */\n\tkeydown = ParamConfig.BOOLEAN(1, EVENT_PARAM_OPTIONS);\n\t/** @param toggle on to listen to keypress events */\n\tkeypress = ParamConfig.BOOLEAN(0, EVENT_PARAM_OPTIONS);\n\t/** @param toggle on to listen to keyup events */\n\tkeyup = ParamConfig.BOOLEAN(0, EVENT_PARAM_OPTIONS);\n\t/** @param space separated list of accepted key codes. If this is empty then any key is accepted. */\n\tkeyCodes = ParamConfig.STRING('Digit1 KeyE ArrowDown', EVENT_PARAM_OPTIONS);\n\t/** @param requires ctrlKey */\n\tctrlKey = ParamConfig.BOOLEAN(0, EVENT_PARAM_OPTIONS);\n\t/** @param requires altKey */\n\taltKey = ParamConfig.BOOLEAN(0, EVENT_PARAM_OPTIONS);\n\t/** @param requires shiftKey */\n\tshiftKey = ParamConfig.BOOLEAN(0, EVENT_PARAM_OPTIONS);\n\t/** @param requires metaKey */\n\tmetaKey = ParamConfig.BOOLEAN(0, EVENT_PARAM_OPTIONS);\n}\nconst ParamsConfig = new KeyboardEventParamsConfig();\n\nexport class KeyboardEventNode extends TypedInputEventNode<KeyboardEventParamsConfig> {\n\toverride paramsConfig = ParamsConfig;\n\tstatic override type() {\n\t\treturn EventInputType.KEYBOARD;\n\t}\n\tprotected acceptedEventTypes() {\n\t\treturn new Set([...ACCEPTED_KEYBOARD_EVENT_TYPES]);\n\t}\n\toverride initializeNode() {\n\t\tthis.io.outputs.setNamedOutputConnectionPoints(\n\t\t\tACCEPTED_KEYBOARD_EVENT_TYPES.map((event_type) => {\n\t\t\t\treturn new EventConnectionPoint(event_type, EventConnectionPointType.KEYBOARD);\n\t\t\t})\n\t\t);\n\t}\n\tsetElement(element: CoreEventEmitter) {\n\t\tthis.p.element.set(EVENT_EMITTERS.indexOf(element));\n\t}\n\n\toverride processEvent(eventContext: EventContext<KeyboardEvent>) {\n\t\tif (!this.pv.active) {\n\t\t\treturn;\n\t\t}\n\t\tconst event = eventContext.event;\n\t\tif (!event) {\n\t\t\treturn;\n\t\t}\n\t\tif (event.ctrlKey != isBooleanTrue(this.pv.ctrlKey)) {\n\t\t\treturn;\n\t\t}\n\t\tif (event.shiftKey != isBooleanTrue(this.pv.shiftKey)) {\n\t\t\treturn;\n\t\t}\n\t\tif (event.altKey != isBooleanTrue(this.pv.altKey)) {\n\t\t\treturn;\n\t\t}\n\t\tif (event.metaKey != isBooleanTrue(this.pv.metaKey)) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (!stringMatchMask(event.code, this.pv.keyCodes)) {\n\t\t\treturn;\n\t\t}\n\t\tthis.dispatchEventToOutput(event.type, eventContext);\n\t}\n}\n","import {\n\tVector3\n} from 'three';\n\nclass Capsule {\n\n\tconstructor( start = new Vector3( 0, 0, 0 ), end = new Vector3( 0, 1, 0 ), radius = 1 ) {\n\n\t\tthis.start = start;\n\t\tthis.end = end;\n\t\tthis.radius = radius;\n\n\t}\n\n\tclone() {\n\n\t\treturn new Capsule( this.start.clone(), this.end.clone(), this.radius );\n\n\t}\n\n\tset( start, end, radius ) {\n\n\t\tthis.start.copy( start );\n\t\tthis.end.copy( end );\n\t\tthis.radius = radius;\n\n\t}\n\n\tcopy( capsule ) {\n\n\t\tthis.start.copy( capsule.start );\n\t\tthis.end.copy( capsule.end );\n\t\tthis.radius = capsule.radius;\n\n\t}\n\n\tgetCenter( target ) {\n\n\t\treturn target.copy( this.end ).add( this.start ).multiplyScalar( 0.5 );\n\n\t}\n\n\ttranslate( v ) {\n\n\t\tthis.start.add( v );\n\t\tthis.end.add( v );\n\n\t}\n\n\tcheckAABBAxis( p1x, p1y, p2x, p2y, minx, maxx, miny, maxy, radius ) {\n\n\t\treturn (\n\t\t\t( minx - p1x < radius || minx - p2x < radius ) &&\n\t\t\t( p1x - maxx < radius || p2x - maxx < radius ) &&\n\t\t\t( miny - p1y < radius || miny - p2y < radius ) &&\n\t\t\t( p1y - maxy < radius || p2y - maxy < radius )\n\t\t);\n\n\t}\n\n\tintersectsBox( box ) {\n\n\t\treturn (\n\t\t\tthis.checkAABBAxis(\n\t\t\t\tthis.start.x, this.start.y, this.end.x, this.end.y,\n\t\t\t\tbox.min.x, box.max.x, box.min.y, box.max.y,\n\t\t\t\tthis.radius ) &&\n\t\t\tthis.checkAABBAxis(\n\t\t\t\tthis.start.x, this.start.z, this.end.x, this.end.z,\n\t\t\t\tbox.min.x, box.max.x, box.min.z, box.max.z,\n\t\t\t\tthis.radius ) &&\n\t\t\tthis.checkAABBAxis(\n\t\t\t\tthis.start.y, this.start.z, this.end.y, this.end.z,\n\t\t\t\tbox.min.y, box.max.y, box.min.z, box.max.z,\n\t\t\t\tthis.radius )\n\t\t);\n\n\t}\n\n}\n\nexport { Capsule };\n","import {\n\tBox3,\n\tLine3,\n\tPlane,\n\tSphere,\n\tTriangle,\n\tVector3\n} from 'three';\nimport { Capsule } from '../math/Capsule.js';\n\n\nconst _v1 = new Vector3();\nconst _v2 = new Vector3();\nconst _point1 = new Vector3();\nconst _point2 = new Vector3();\nconst _plane = new Plane();\nconst _line1 = new Line3();\nconst _line2 = new Line3();\nconst _sphere = new Sphere();\nconst _capsule = new Capsule();\n\nconst _temp1 = new Vector3();\nconst _temp2 = new Vector3();\nconst _temp3 = new Vector3();\nconst EPS = 1e-10;\n\nfunction lineToLineClosestPoints( line1, line2, target1 = null, target2 = null ) {\n\n\tconst r = _temp1.copy( line1.end ).sub( line1.start );\n\tconst s = _temp2.copy( line2.end ).sub( line2.start );\n\tconst w = _temp3.copy( line2.start ).sub( line1.start );\n\n\tconst a = r.dot( s ),\n\t\tb = r.dot( r ),\n\t\tc = s.dot( s ),\n\t\td = s.dot( w ),\n\t\te = r.dot( w );\n\n\tlet t1, t2;\n\tconst divisor = b * c - a * a;\n\n\tif ( Math.abs( divisor ) < EPS ) {\n\n\t\tconst d1 = - d / c;\n\t\tconst d2 = ( a - d ) / c;\n\n\t\tif ( Math.abs( d1 - 0.5 ) < Math.abs( d2 - 0.5 ) ) {\n\n\t\t\tt1 = 0;\n\t\t\tt2 = d1;\n\n\t\t} else {\n\n\t\t\tt1 = 1;\n\t\t\tt2 = d2;\n\n\t\t}\n\n\t} else {\n\n\t\tt1 = ( d * a + e * c ) / divisor;\n\t\tt2 = ( t1 * a - d ) / c;\n\n\t}\n\n\tt2 = Math.max( 0, Math.min( 1, t2 ) );\n\tt1 = Math.max( 0, Math.min( 1, t1 ) );\n\n\tif ( target1 ) {\n\n\t\ttarget1.copy( r ).multiplyScalar( t1 ).add( line1.start );\n\n\t}\n\n\tif ( target2 ) {\n\n\t\ttarget2.copy( s ).multiplyScalar( t2 ).add( line2.start );\n\n\t}\n\n}\n\nclass Octree {\n\n\tconstructor( box ) {\n\n\t\tthis.box = box;\n\t\tthis.bounds = new Box3();\n\n\t\tthis.subTrees = [];\n\t\tthis.triangles = [];\n\n\t}\n\n\taddTriangle( triangle ) {\n\n\t\tthis.bounds.min.x = Math.min( this.bounds.min.x, triangle.a.x, triangle.b.x, triangle.c.x );\n\t\tthis.bounds.min.y = Math.min( this.bounds.min.y, triangle.a.y, triangle.b.y, triangle.c.y );\n\t\tthis.bounds.min.z = Math.min( this.bounds.min.z, triangle.a.z, triangle.b.z, triangle.c.z );\n\t\tthis.bounds.max.x = Math.max( this.bounds.max.x, triangle.a.x, triangle.b.x, triangle.c.x );\n\t\tthis.bounds.max.y = Math.max( this.bounds.max.y, triangle.a.y, triangle.b.y, triangle.c.y );\n\t\tthis.bounds.max.z = Math.max( this.bounds.max.z, triangle.a.z, triangle.b.z, triangle.c.z );\n\n\t\tthis.triangles.push( triangle );\n\n\t\treturn this;\n\n\t}\n\n\tcalcBox() {\n\n\t\tthis.box = this.bounds.clone();\n\n\t\t// offset small amount to account for regular grid\n\t\tthis.box.min.x -= 0.01;\n\t\tthis.box.min.y -= 0.01;\n\t\tthis.box.min.z -= 0.01;\n\n\t\treturn this;\n\n\t}\n\n\tsplit( level ) {\n\n\t\tif ( ! this.box ) return;\n\n\t\tconst subTrees = [];\n\t\tconst halfsize = _v2.copy( this.box.max ).sub( this.box.min ).multiplyScalar( 0.5 );\n\n\t\tfor ( let x = 0; x < 2; x ++ ) {\n\n\t\t\tfor ( let y = 0; y < 2; y ++ ) {\n\n\t\t\t\tfor ( let z = 0; z < 2; z ++ ) {\n\n\t\t\t\t\tconst box = new Box3();\n\t\t\t\t\tconst v = _v1.set( x, y, z );\n\n\t\t\t\t\tbox.min.copy( this.box.min ).add( v.multiply( halfsize ) );\n\t\t\t\t\tbox.max.copy( box.min ).add( halfsize );\n\n\t\t\t\t\tsubTrees.push( new Octree( box ) );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tlet triangle;\n\n\t\twhile ( triangle = this.triangles.pop() ) {\n\n\t\t\tfor ( let i = 0; i < subTrees.length; i ++ ) {\n\n\t\t\t\tif ( subTrees[ i ].box.intersectsTriangle( triangle ) ) {\n\n\t\t\t\t\tsubTrees[ i ].triangles.push( triangle );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tfor ( let i = 0; i < subTrees.length; i ++ ) {\n\n\t\t\tconst len = subTrees[ i ].triangles.length;\n\n\t\t\tif ( len > 8 && level < 16 ) {\n\n\t\t\t\tsubTrees[ i ].split( level + 1 );\n\n\t\t\t}\n\n\t\t\tif ( len !== 0 ) {\n\n\t\t\t\tthis.subTrees.push( subTrees[ i ] );\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\tbuild() {\n\n\t\tthis.calcBox();\n\t\tthis.split( 0 );\n\n\t\treturn this;\n\n\t}\n\n\tgetRayTriangles( ray, triangles ) {\n\n\t\tfor ( let i = 0; i < this.subTrees.length; i ++ ) {\n\n\t\t\tconst subTree = this.subTrees[ i ];\n\t\t\tif ( ! ray.intersectsBox( subTree.box ) ) continue;\n\n\t\t\tif ( subTree.triangles.length > 0 ) {\n\n\t\t\t\tfor ( let j = 0; j < subTree.triangles.length; j ++ ) {\n\n\t\t\t\t\tif ( triangles.indexOf( subTree.triangles[ j ] ) === - 1 ) triangles.push( subTree.triangles[ j ] );\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tsubTree.getRayTriangles( ray, triangles );\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn triangles;\n\n\t}\n\n\ttriangleCapsuleIntersect( capsule, triangle ) {\n\n\t\ttriangle.getPlane( _plane );\n\n\t\tconst d1 = _plane.distanceToPoint( capsule.start ) - capsule.radius;\n\t\tconst d2 = _plane.distanceToPoint( capsule.end ) - capsule.radius;\n\n\t\tif ( ( d1 > 0 && d2 > 0 ) || ( d1 < - capsule.radius && d2 < - capsule.radius ) ) {\n\n\t\t\treturn false;\n\n\t\t}\n\n\t\tconst delta = Math.abs( d1 / ( Math.abs( d1 ) + Math.abs( d2 ) ) );\n\t\tconst intersectPoint = _v1.copy( capsule.start ).lerp( capsule.end, delta );\n\n\t\tif ( triangle.containsPoint( intersectPoint ) ) {\n\n\t\t\treturn { normal: _plane.normal.clone(), point: intersectPoint.clone(), depth: Math.abs( Math.min( d1, d2 ) ) };\n\n\t\t}\n\n\t\tconst r2 = capsule.radius * capsule.radius;\n\n\t\tconst line1 = _line1.set( capsule.start, capsule.end );\n\n\t\tconst lines = [\n\t\t\t[ triangle.a, triangle.b ],\n\t\t\t[ triangle.b, triangle.c ],\n\t\t\t[ triangle.c, triangle.a ]\n\t\t];\n\n\t\tfor ( let i = 0; i < lines.length; i ++ ) {\n\n\t\t\tconst line2 = _line2.set( lines[ i ][ 0 ], lines[ i ][ 1 ] );\n\n\t\t\tlineToLineClosestPoints( line1, line2, _point1, _point2 );\n\n\t\t\tif ( _point1.distanceToSquared( _point2 ) < r2 ) {\n\n\t\t\t\treturn {\n\t\t\t\t\tnormal: _point1.clone().sub( _point2 ).normalize(),\n\t\t\t\t\tpoint: _point2.clone(),\n\t\t\t\t\tdepth: capsule.radius - _point1.distanceTo( _point2 )\n\t\t\t\t};\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn false;\n\n\t}\n\n\ttriangleSphereIntersect( sphere, triangle ) {\n\n\t\ttriangle.getPlane( _plane );\n\n\t\tif ( ! sphere.intersectsPlane( _plane ) ) return false;\n\n\t\tconst depth = Math.abs( _plane.distanceToSphere( sphere ) );\n\t\tconst r2 = sphere.radius * sphere.radius - depth * depth;\n\n\t\tconst plainPoint = _plane.projectPoint( sphere.center, _v1 );\n\n\t\tif ( triangle.containsPoint( sphere.center ) ) {\n\n\t\t\treturn { normal: _plane.normal.clone(), point: plainPoint.clone(), depth: Math.abs( _plane.distanceToSphere( sphere ) ) };\n\n\t\t}\n\n\t\tconst lines = [\n\t\t\t[ triangle.a, triangle.b ],\n\t\t\t[ triangle.b, triangle.c ],\n\t\t\t[ triangle.c, triangle.a ]\n\t\t];\n\n\t\tfor ( let i = 0; i < lines.length; i ++ ) {\n\n\t\t\t_line1.set( lines[ i ][ 0 ], lines[ i ][ 1 ] );\n\t\t\t_line1.closestPointToPoint( plainPoint, true, _v2 );\n\n\t\t\tconst d = _v2.distanceToSquared( sphere.center );\n\n\t\t\tif ( d < r2 ) {\n\n\t\t\t\treturn { normal: sphere.center.clone().sub( _v2 ).normalize(), point: _v2.clone(), depth: sphere.radius - Math.sqrt( d ) };\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn false;\n\n\t}\n\n\tgetSphereTriangles( sphere, triangles ) {\n\n\t\tfor ( let i = 0; i < this.subTrees.length; i ++ ) {\n\n\t\t\tconst subTree = this.subTrees[ i ];\n\n\t\t\tif ( ! sphere.intersectsBox( subTree.box ) ) continue;\n\n\t\t\tif ( subTree.triangles.length > 0 ) {\n\n\t\t\t\tfor ( let j = 0; j < subTree.triangles.length; j ++ ) {\n\n\t\t\t\t\tif ( triangles.indexOf( subTree.triangles[ j ] ) === - 1 ) triangles.push( subTree.triangles[ j ] );\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tsubTree.getSphereTriangles( sphere, triangles );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tgetCapsuleTriangles( capsule, triangles ) {\n\n\t\tfor ( let i = 0; i < this.subTrees.length; i ++ ) {\n\n\t\t\tconst subTree = this.subTrees[ i ];\n\n\t\t\tif ( ! capsule.intersectsBox( subTree.box ) ) continue;\n\n\t\t\tif ( subTree.triangles.length > 0 ) {\n\n\t\t\t\tfor ( let j = 0; j < subTree.triangles.length; j ++ ) {\n\n\t\t\t\t\tif ( triangles.indexOf( subTree.triangles[ j ] ) === - 1 ) triangles.push( subTree.triangles[ j ] );\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tsubTree.getCapsuleTriangles( capsule, triangles );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tsphereIntersect( sphere ) {\n\n\t\t_sphere.copy( sphere );\n\n\t\tconst triangles = [];\n\t\tlet result, hit = false;\n\n\t\tthis.getSphereTriangles( sphere, triangles );\n\n\t\tfor ( let i = 0; i < triangles.length; i ++ ) {\n\n\t\t\tif ( result = this.triangleSphereIntersect( _sphere, triangles[ i ] ) ) {\n\n\t\t\t\thit = true;\n\n\t\t\t\t_sphere.center.add( result.normal.multiplyScalar( result.depth ) );\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( hit ) {\n\n\t\t\tconst collisionVector = _sphere.center.clone().sub( sphere.center );\n\t\t\tconst depth = collisionVector.length();\n\n\t\t\treturn { normal: collisionVector.normalize(), depth: depth };\n\n\t\t}\n\n\t\treturn false;\n\n\t}\n\n\tcapsuleIntersect( capsule ) {\n\n\t\t_capsule.copy( capsule );\n\n\t\tconst triangles = [];\n\t\tlet result, hit = false;\n\n\t\tthis.getCapsuleTriangles( _capsule, triangles );\n\n\t\tfor ( let i = 0; i < triangles.length; i ++ ) {\n\n\t\t\tif ( result = this.triangleCapsuleIntersect( _capsule, triangles[ i ] ) ) {\n\n\t\t\t\thit = true;\n\n\t\t\t\t_capsule.translate( result.normal.multiplyScalar( result.depth ) );\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( hit ) {\n\n\t\t\tconst collisionVector = _capsule.getCenter( new Vector3() ).sub( capsule.getCenter( _v1 ) );\n\t\t\tconst depth = collisionVector.length();\n\n\t\t\treturn { normal: collisionVector.normalize(), depth: depth };\n\n\t\t}\n\n\t\treturn false;\n\n\t}\n\n\trayIntersect( ray ) {\n\n\t\tif ( ray.direction.length() === 0 ) return;\n\n\t\tconst triangles = [];\n\t\tlet triangle, position, distance = 1e100;\n\n\t\tthis.getRayTriangles( ray, triangles );\n\n\t\tfor ( let i = 0; i < triangles.length; i ++ ) {\n\n\t\t\tconst result = ray.intersectTriangle( triangles[ i ].a, triangles[ i ].b, triangles[ i ].c, true, _v1 );\n\n\t\t\tif ( result ) {\n\n\t\t\t\tconst newdistance = result.sub( ray.origin ).length();\n\n\t\t\t\tif ( distance > newdistance ) {\n\n\t\t\t\t\tposition = result.clone().add( ray.origin );\n\t\t\t\t\tdistance = newdistance;\n\t\t\t\t\ttriangle = triangles[ i ];\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn distance < 1e100 ? { distance: distance, triangle: triangle, position: position } : false;\n\n\t}\n\n\tfromGraphNode( group ) {\n\n\t\tgroup.updateWorldMatrix( true, true );\n\n\t\tgroup.traverse( ( obj ) => {\n\n\t\t\tif ( obj.isMesh === true ) {\n\n\t\t\t\tlet geometry, isTemp = false;\n\n\t\t\t\tif ( obj.geometry.index !== null ) {\n\n\t\t\t\t\tisTemp = true;\n\t\t\t\t\tgeometry = obj.geometry.toNonIndexed();\n\n\t\t\t\t} else {\n\n\t\t\t\t\tgeometry = obj.geometry;\n\n\t\t\t\t}\n\n\t\t\t\tconst positionAttribute = geometry.getAttribute( 'position' );\n\n\t\t\t\tfor ( let i = 0; i < positionAttribute.count; i += 3 ) {\n\n\t\t\t\t\tconst v1 = new Vector3().fromBufferAttribute( positionAttribute, i );\n\t\t\t\t\tconst v2 = new Vector3().fromBufferAttribute( positionAttribute, i + 1 );\n\t\t\t\t\tconst v3 = new Vector3().fromBufferAttribute( positionAttribute, i + 2 );\n\n\t\t\t\t\tv1.applyMatrix4( obj.matrixWorld );\n\t\t\t\t\tv2.applyMatrix4( obj.matrixWorld );\n\t\t\t\t\tv3.applyMatrix4( obj.matrixWorld );\n\n\t\t\t\t\tthis.addTriangle( new Triangle( v1, v2, v3 ) );\n\n\t\t\t\t}\n\n\t\t\t\tif ( isTemp ) {\n\n\t\t\t\t\tgeometry.dispose();\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} );\n\n\t\tthis.build();\n\n\t\treturn this;\n\n\t}\n\n\tclear() {\n\n\t\tthis.box = null;\n\t\tthis.bounds.makeEmpty();\n\n\t\tthis.subTrees.length = 0;\n\t\tthis.triangles.length = 0;\n\n\t\treturn this;\n\n\t}\n\n}\n\nexport { Octree };\n","import {Octree} from '../../../three/examples/jsm/math/Octree';\nimport {Capsule} from '../../../three/examples/jsm/math/Capsule';\nimport {Vector3} from 'three';\nimport {Object3D} from 'three';\n\ninterface CapsuleCollisionResult {\n\tnormal: Vector3;\n\tpoint: Vector3;\n\tdepth: number;\n}\n\nexport class PlayerCollisionController {\n\tprivate _octree = new Octree();\n\tprivate _capsuleHeight = new Vector3(0, 1, 0);\n\tprivate _capsule = new Capsule(new Vector3(0, 0.35, 0), new Vector3(0, 1, 0), 0.6);\n\tconstructor(private _object: Object3D) {\n\t\tthis._octree.fromGraphNode(this._object);\n\t}\n\n\tsetCapsule(capsule: Capsule) {\n\t\tthis._capsule.copy(capsule);\n\t\tthis._capsuleHeight.copy(capsule.end).sub(capsule.start);\n\t}\n\n\ttestPosition(position: Vector3): CapsuleCollisionResult | false {\n\t\tthis._capsule.end.copy(position);\n\t\tthis._capsule.start.copy(position).sub(this._capsuleHeight);\n\n\t\treturn this._octree.capsuleIntersect(this._capsule);\n\t}\n}\n","import {Object3DWithGeometry} from '../../../core/geometry/Group';\nimport {PlayerCollisionController} from './collisions/PlayerCollisionsController';\nimport {Object3D} from 'three';\nimport {Mesh} from 'three';\nimport {Capsule} from 'three/examples/jsm/math/Capsule';\nimport {EventDispatcher} from 'three';\nimport {Vector3} from 'three';\n\nexport interface JumpParams {\n\tduration: number;\n\tforce: number;\n}\n\nexport class BaseCollisionHandler extends EventDispatcher<{change: any}> {\n\tprotected _playerCollisionController: PlayerCollisionController | undefined;\n\n\tsetCheckCollisions(collisionObject?: Object3D) {\n\t\tif (collisionObject) {\n\t\t\tlet objectWithGeo: Object3DWithGeometry | undefined;\n\t\t\tcollisionObject.traverse((child) => {\n\t\t\t\tif (!objectWithGeo) {\n\t\t\t\t\tconst mesh = child as Mesh;\n\t\t\t\t\tif (mesh.geometry) {\n\t\t\t\t\t\tobjectWithGeo = mesh;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\t\t\tif (objectWithGeo) {\n\t\t\t\tthis._playerCollisionController = new PlayerCollisionController(objectWithGeo);\n\t\t\t} else {\n\t\t\t\tconsole.error('no geo found in', collisionObject);\n\t\t\t}\n\t\t} else {\n\t\t\tthis._playerCollisionController = undefined;\n\t\t}\n\t}\n\tsetCollisionCapsule(capsule: Capsule) {\n\t\tthis._playerCollisionController?.setCapsule(capsule);\n\t}\n\tsetJumpParams(params: JumpParams) {}\n\tsetGravity(gravity: Vector3) {}\n\tsetPlayerMass(mass: number) {}\n}\n","import {BaseEvent, Spherical, Vector3, Vector2, Euler, Camera} from 'three';\nimport {CoreMath} from '../../../core/math/_Module';\nimport {CoreDomUtils} from '../../../core/DomUtils';\nimport {BaseCollisionHandler} from './BaseCollisionHandler';\nimport {CorePlayer} from '../../../core/player/Player';\nimport {isBooleanTrue} from '../../../core/Type';\n\ninterface TranslationData {\n\tdirection: Vector3;\n}\ninterface RotationData {\n\tdirection: {x: number; y: number};\n}\n\ninterface RotationRange {\n\tmin: number;\n\tmax: number;\n}\n\n// const VIEWER_CALLBACK_NAME = 'mobile-nav';\ninterface MobileJoystickControlsDefaultParams {\n\trotateSpeed: number;\n\trotationRange: RotationRange;\n\t// translateSpeed: number;\n}\nexport const DEFAULT_PARAMS: MobileJoystickControlsDefaultParams = {\n\trotateSpeed: 1,\n\trotationRange: {min: -Math.PI * 0.25, max: Math.PI * 0.25},\n\t// translateSpeed: 0.1,\n};\nconst EVENT_CHANGE: BaseEvent<'change'> = {type: 'change'};\nconst tmpCameraUnproject = new Vector3();\nconst spherical = new Spherical();\n\nexport interface MobileJoystickControlsOptions {\n\ttranslateDomElement?: HTMLElement;\n\tjumpDomElement?: HTMLElement;\n\trunDomElement?: HTMLElement;\n}\nexport class MobileJoystickControls extends BaseCollisionHandler {\n\tprivate translationData: TranslationData = {\n\t\tdirection: new Vector3(),\n\t};\n\tprivate rotationData: RotationData = {\n\t\tdirection: {x: 0, y: 0},\n\t};\n\tprivate _boundMethods = {\n\t\tonRotateStart: this._onRotateStart.bind(this),\n\t\tonRotateMove: this._onRotateMove.bind(this),\n\t\tonRotateEnd: this._onRotateEnd.bind(this),\n\t\tonTranslateStart: this._onTranslateStart.bind(this),\n\t\tonTranslateMove: this._onTranslateMove.bind(this),\n\t\tonTranslateEnd: this._onTranslateEnd.bind(this),\n\t\tonJump: this._onJump.bind(this),\n\t\tonRunToggle: this._onRunToggle.bind(this),\n\t};\n\n\tprivate _startCameraRotation = new Euler();\n\t// private _velocity = new Vector3();\n\t// private _element: HTMLElement;\n\t// private _translationSpeed = 4;\n\tprivate _rotationSpeed = DEFAULT_PARAMS.rotateSpeed;\n\tprivate _rotationRange: RotationRange = {\n\t\tmin: DEFAULT_PARAMS.rotationRange.min,\n\t\tmax: DEFAULT_PARAMS.rotationRange.max,\n\t};\n\t// private _translationSpeed = DEFAULT_PARAMS.translateSpeed;\n\tprivate _azimuthalAngle: number = 0;\n\tprivate _translateDomElement: HTMLElement;\n\tprivate _translateDomElementRect: DOMRect;\n\tprivate _jumpDomElement: HTMLElement;\n\tprivate _runDomElement: HTMLElement;\n\tconstructor(\n\t\tprivate _camera: Camera,\n\t\tprivate domElement: HTMLElement,\n\t\tprivate options: MobileJoystickControlsOptions,\n\t\tprivate player?: CorePlayer\n\t) {\n\t\tsuper();\n\t\t// this._element = this._viewer.domElement();\n\t\tthis._camera.rotation.order = 'ZYX';\n\n\t\t// const clock = new Clock();\n\t\t// this._viewer.registerOnBeforeRender(VIEWER_CALLBACK_NAME, () => {\n\t\t// \tconst deltaTime = Math.min(0.1, clock.getDelta());\n\t\t// \tthis.update(deltaTime);\n\t\t// });\n\t\tthis._translateDomElement = this.options.translateDomElement || this._createTranslateDomElement();\n\t\tthis._runDomElement = this.options.runDomElement || this._createRunDomElement();\n\t\tthis._jumpDomElement = this.options.jumpDomElement || this._createJumpDomElement();\n\t\tthis._translateDomElementRect = this._translateDomElement.getBoundingClientRect();\n\t\tthis._addElements();\n\t\tthis._addEvents();\n\t}\n\tdispose() {\n\t\t// this._viewer.unRegisterOnBeforeRender(VIEWER_CALLBACK_NAME);\n\t\tthis._removeEvents();\n\t\tthis._removeElements();\n\t\tthis.updateElements();\n\t}\n\n\tprivate _createTranslateDomElement() {\n\t\tconst rect = this.domElement.getBoundingClientRect();\n\t\tconst minDim = Math.min(rect.width, rect.height);\n\t\tconst size = Math.round(0.4 * minDim);\n\t\tconst margin = Math.round(0.1 * minDim);\n\t\tconst element = document.createElement('div');\n\t\telement.id = 'MobileJoystickControls-translate';\n\t\telement.style.width = `${size}px`;\n\t\telement.style.height = element.style.width;\n\t\telement.style.border = '1px solid black';\n\t\telement.style.borderRadius = `${size}px`;\n\t\telement.style.position = 'absolute';\n\t\telement.style.bottom = `${margin}px`;\n\t\telement.style.left = `${margin}px`;\n\t\treturn element;\n\t}\n\n\tprivate _jumpDomElementSize() {\n\t\tconst rect = this.domElement.getBoundingClientRect();\n\t\tconst minDim = Math.min(rect.width, rect.height);\n\t\tconst size = Math.round(0.2 * minDim);\n\t\tconst margin = Math.round(0.05 * minDim);\n\t\treturn {size, margin};\n\t}\n\tprivate _createJumpDomElement() {\n\t\tconst {size, margin} = this._jumpDomElementSize();\n\t\tconst element = document.createElement('div');\n\t\telement.id = 'MobileJoystickControls-jump';\n\t\telement.style.width = `${size}px`;\n\t\tconst height = Math.floor(size);\n\t\telement.style.height = `${height}px`;\n\t\telement.style.border = '1px solid black';\n\t\telement.style.position = 'absolute';\n\t\telement.style.bottom = `${2 * margin + parseInt(this._runDomElement.style.height)}px`;\n\t\telement.style.right = `${margin}px`;\n\t\telement.style.borderRadius = `${height}px`;\n\t\treturn element;\n\t}\n\n\tprivate _createRunDomElement() {\n\t\tconst element = document.createElement('div');\n\t\tconst rect = this.domElement.getBoundingClientRect();\n\t\tconst minDim = Math.min(rect.width, rect.height);\n\t\tconst size = Math.round(0.2 * minDim);\n\t\tconst margin = Math.round(0.05 * minDim);\n\t\telement.id = 'MobileJoystickControls-run';\n\t\telement.style.width = `${size}px`;\n\t\telement.style.height = `${Math.floor(size)}px`;\n\t\telement.style.border = '1px solid black';\n\t\telement.style.position = 'absolute';\n\t\telement.style.bottom = `${margin}px`;\n\t\telement.style.right = `${margin}px`;\n\t\t// element.style.translate = `-50%`;\n\t\treturn element;\n\t}\n\tprivate _addElements() {\n\t\tthis.domElement.parentElement?.append(this._translateDomElement);\n\t\tthis.domElement.parentElement?.append(this._jumpDomElement);\n\t\tthis.domElement.parentElement?.append(this._runDomElement);\n\t}\n\tprivate _removeElements() {\n\t\tfunction _removeElement(element: HTMLElement) {\n\t\t\telement.parentElement?.removeChild(element);\n\t\t}\n\t\tif (!this.options.translateDomElement) {\n\t\t\t_removeElement(this._translateDomElement);\n\t\t}\n\t\tif (!this.options.runDomElement) {\n\t\t\t_removeElement(this._runDomElement);\n\t\t}\n\t\tif (!this.options.jumpDomElement) {\n\t\t\t_removeElement(this._jumpDomElement);\n\t\t}\n\t}\n\tupdateElements() {\n\t\tif (!this.player) {\n\t\t\treturn;\n\t\t}\n\t\tthis._jumpDomElement.style.display = isBooleanTrue(this.player.jumpAllowed) ? 'block' : 'none';\n\t\tthis._runDomElement.style.display = isBooleanTrue(this.player.runAllowed) ? 'block' : 'none';\n\t}\n\tprivate _addEvents() {\n\t\tCoreDomUtils.disableContextMenu();\n\t\tthis.domElement.addEventListener('touchstart', this._boundMethods.onRotateStart);\n\t\tthis.domElement.addEventListener('touchmove', this._boundMethods.onRotateMove);\n\t\tthis.domElement.addEventListener('touchend', this._boundMethods.onRotateEnd);\n\t\tthis._translateDomElement.addEventListener('touchstart', this._boundMethods.onTranslateStart);\n\t\tthis._translateDomElement.addEventListener('touchmove', this._boundMethods.onTranslateMove);\n\t\tthis._translateDomElement.addEventListener('touchend', this._boundMethods.onTranslateEnd);\n\t\tthis._jumpDomElement.addEventListener('pointerdown', this._boundMethods.onJump);\n\t\tthis._runDomElement.addEventListener('pointerdown', this._boundMethods.onRunToggle);\n\t}\n\tprivate _removeEvents() {\n\t\t// TODO: ideally the viewer should know that\n\t\t// its element should have no context menu callback\n\t\t// if no mobile controls is attached. So the viewer should be in control\n\t\t// of re-establishing the event\n\t\tCoreDomUtils.reEstablishContextMenu();\n\t\tthis.domElement.removeEventListener('touchstart', this._boundMethods.onRotateStart);\n\t\tthis.domElement.removeEventListener('touchmove', this._boundMethods.onRotateMove);\n\t\tthis.domElement.removeEventListener('touchend', this._boundMethods.onRotateEnd);\n\t\tthis._translateDomElement.removeEventListener('touchstart', this._boundMethods.onTranslateStart);\n\t\tthis._translateDomElement.removeEventListener('touchmove', this._boundMethods.onTranslateMove);\n\t\tthis._translateDomElement.removeEventListener('touchend', this._boundMethods.onTranslateEnd);\n\t\tthis._jumpDomElement.removeEventListener('pointerdown', this._boundMethods.onJump);\n\t\tthis._runDomElement.removeEventListener('pointerdown', this._boundMethods.onRunToggle);\n\t}\n\n\tsetRotationSpeed(speed: number) {\n\t\tthis._rotationSpeed = speed;\n\t}\n\tsetRotationRange(range: RotationRange) {\n\t\tthis._rotationRange.min = range.min;\n\t\tthis._rotationRange.max = range.max;\n\t}\n\t// setTranslationSpeed(speed: number) {\n\t// \tthis._translationSpeed = speed;\n\t// }\n\n\t//\n\t//\n\t// ROTATE\n\t//\n\t//\n\tprivate vLeft = new Vector3();\n\tprivate vRight = new Vector3();\n\tprivate vTop = new Vector3();\n\tprivate vBottom = new Vector3();\n\tprivate angleY = 0;\n\tprivate angleX = 0;\n\tprivate _rotationStartPosition = new Vector2();\n\tprivate _rotationMovePosition = new Vector2();\n\tprivate _rotationDelta = new Vector2();\n\tprivate _onRotateStart(event: TouchEvent) {\n\t\tthis._startCameraRotation.copy(this._camera.rotation);\n\t\tconst touch = this._getTouch(event, this.domElement);\n\t\tif (!touch) {\n\t\t\treturn;\n\t\t}\n\t\tthis._rotationStartPosition.set(touch.clientX, touch.clientY);\n\n\t\t// x pan for rotation y\n\t\tthis.vLeft.set(-1, 0, 0.5);\n\t\tthis.vRight.set(1, 0, 0.5);\n\t\t[this.vLeft, this.vRight].forEach((v) => {\n\t\t\tv.unproject(this._camera);\n\n\t\t\tthis._camera.worldToLocal(v);\n\t\t});\n\t\tthis.angleY = this.vLeft.angleTo(this.vRight);\n\t\t// y pan for rotation x\n\t\tthis.vTop.set(0, 1, 0.5);\n\t\tthis.vBottom.set(0, -1, 0.5);\n\t\t[this.vTop, this.vBottom].forEach((v) => {\n\t\t\tv.unproject(this._camera);\n\n\t\t\tthis._camera.worldToLocal(v);\n\t\t});\n\t\tthis.angleX = this.vTop.angleTo(this.vBottom);\n\t}\n\tprivate _onRotateMove(event: TouchEvent) {\n\t\tconst touch = this._getTouch(event, this.domElement);\n\t\tif (!touch) {\n\t\t\treturn;\n\t\t}\n\t\tthis._rotationMovePosition.set(touch.clientX, touch.clientY);\n\t\tthis._rotationDelta.copy(this._rotationMovePosition).sub(this._rotationStartPosition);\n\t\t// delta.normalize();\n\t\tthis.rotationData.direction.x = this._rotationDelta.x / this.domElement.clientWidth;\n\t\tthis.rotationData.direction.y = this._rotationDelta.y / this.domElement.clientHeight;\n\t\t// rotateData.speed = delta.length();\n\t\tthis._rotateCamera(this.rotationData);\n\t}\n\tprivate _onRotateEnd() {\n\t\tthis.rotationData.direction.x = 0;\n\t\tthis.rotationData.direction.y = 0;\n\t}\n\tprivate _rotateCamera(rotationData: RotationData) {\n\t\tconst INVERT_Y = true;\n\t\tconst INVERT_X = INVERT_Y;\n\n\t\tlet angleY = this.angleY * rotationData.direction.x * this._rotationSpeed;\n\t\tthis._camera.rotation.y = this._startCameraRotation.y + (INVERT_Y ? -angleY : angleY);\n\t\tlet angleX = this.angleX * rotationData.direction.y * this._rotationSpeed;\n\n\t\t// apply bound\n\t\tthis._camera.rotation.x = CoreMath.clamp(\n\t\t\tthis._startCameraRotation.x + (INVERT_X ? -angleX : angleX),\n\t\t\tthis._rotationRange.min,\n\t\t\tthis._rotationRange.max\n\t\t);\n\t\tthis._computeAzimuthalAngle();\n\t\tthis.dispatchEvent(EVENT_CHANGE);\n\t}\n\tprivate _computeAzimuthalAngle() {\n\t\tthis._camera.updateMatrixWorld();\n\t\ttmpCameraUnproject.set(0, 0, 1);\n\t\tthis._camera.localToWorld(tmpCameraUnproject);\n\t\ttmpCameraUnproject.sub(this._camera.position);\n\t\tspherical.setFromVector3(tmpCameraUnproject);\n\t\tthis._azimuthalAngle = spherical.theta;\n\t}\n\t//\n\t//\n\t// TRANSLATE\n\t//\n\t//\n\tprivate _startCameraPosition = new Vector3();\n\tprivate _translationStartPosition = new Vector2();\n\tprivate _translationMovePosition = new Vector2();\n\tprivate _translationDelta = new Vector2();\n\n\tprivate _onTranslateStart(event: TouchEvent) {\n\t\tthis._startCameraPosition.copy(this._camera.position);\n\t\tconst touch = this._getTouch(event, this._translateDomElement);\n\t\tif (!touch) {\n\t\t\treturn;\n\t\t}\n\t\tthis._translateDomElementRect = this._translateDomElement.getBoundingClientRect();\n\t\tconst elementCenterX = this._translateDomElementRect.left + this._translateDomElementRect.width * 0.5;\n\t\tconst elementCenterY = this._translateDomElementRect.top + this._translateDomElementRect.height * 0.5;\n\t\t// this._translationStartPosition.set(touch.clientX, touch.clientY);\n\t\tthis._translationStartPosition.set(elementCenterX, elementCenterY);\n\t}\n\tprivate _onTranslateMove(event: TouchEvent) {\n\t\tconst touch = this._getTouch(event, this._translateDomElement);\n\t\tif (!touch) {\n\t\t\treturn;\n\t\t}\n\t\tthis._translationMovePosition.set(touch.clientX, touch.clientY);\n\t\tthis._translationDelta.copy(this._translationMovePosition).sub(this._translationStartPosition);\n\n\t\tthis.translationData.direction.x = (this._translationDelta.x / this._translateDomElementRect.width) * 0.5;\n\t\tthis.translationData.direction.z = (-this._translationDelta.y / this._translateDomElementRect.height) * 0.5;\n\t\tthis._updatePlayerTranslate();\n\t\tthis.dispatchEvent(EVENT_CHANGE);\n\t}\n\tprivate _onTranslateEnd() {\n\t\tthis.translationData.direction.x = 0;\n\t\tthis.translationData.direction.z = 0;\n\t\tthis._updatePlayerTranslate();\n\t}\n\tprivate _updatePlayerTranslate() {\n\t\tif (!this.player) {\n\t\t\treturn;\n\t\t}\n\t\tconst direction = this.translationData.direction;\n\t\tthis.player.setForward(false);\n\t\tthis.player.setBackward(false);\n\t\tthis.player.setLeft(false);\n\t\tthis.player.setRight(false);\n\n\t\tconst absx = Math.abs(direction.x);\n\t\tconst absz = Math.abs(direction.z);\n\t\tconst delta = absz - absx;\n\t\tfunction checkZ(player: CorePlayer) {\n\t\t\tif (direction.z > 0) {\n\t\t\t\tplayer.setForward(true);\n\t\t\t}\n\t\t\tif (direction.z < 0) {\n\t\t\t\tplayer.setBackward(true);\n\t\t\t}\n\t\t}\n\t\tfunction checkX(player: CorePlayer) {\n\t\t\tif (direction.x > 0) {\n\t\t\t\tplayer.setRight(true);\n\t\t\t}\n\t\t\tif (direction.x < 0) {\n\t\t\t\tplayer.setLeft(true);\n\t\t\t}\n\t\t}\n\t\tif (delta > 0) {\n\t\t\t// if delta > 0, we have dir.z > dir.x,\n\t\t\t// and we therefore move in z first\n\t\t\tcheckZ(this.player);\n\t\t\tif (delta < absz * 0.5) {\n\t\t\t\t// if dir.x and dir.z are close, we move in diagonal\n\t\t\t\tcheckX(this.player);\n\t\t\t}\n\t\t} else {\n\t\t\tcheckX(this.player);\n\t\t\tif (delta < absx * 0.5) {\n\t\t\t\t// if dir.x and dir.z are close, we move in diagonal\n\t\t\t\tcheckZ(this.player);\n\t\t\t}\n\t\t}\n\t}\n\tprivate _onJump() {\n\t\tthis.player?.jump();\n\t}\n\tprivate _onRunToggle() {\n\t\tif (!this.player) {\n\t\t\treturn;\n\t\t}\n\t\tconst runState = this.player.running();\n\t\tthis.player.setRun(!runState);\n\t\tconst borderSize = this.player.running() ? 3 : 1;\n\t\tthis._runDomElement.style.border = `${borderSize}px solid black`;\n\t}\n\n\tupdate(delta: number) {\n\t\t// this._translateCamera(this.translationData, delta);\n\t\tif (this.player) {\n\t\t\tthis.player.setAzimuthalAngle(this._azimuthalAngle);\n\t\t\tthis.player.update(delta);\n\t\t}\n\t}\n\n\t// private _camTmpPost = new Vector3();\n\t// private _camWorldDir = new Vector3();\n\t// private _up = new Vector3(0, 1, 0);\n\t// private _camSideVector = new Vector3();\n\t// private _translateCamera(data: TranslationData, deltaTime: number) {\n\t// \tthis._camera.getWorldDirection(this._camWorldDir);\n\t// \tthis._camWorldDir.y = 0;\n\t// \tthis._camWorldDir.normalize();\n\t// \tthis._camSideVector.crossVectors(this._up, this._camWorldDir);\n\t// \tthis._camSideVector.normalize();\n\t// \tthis._camSideVector.multiplyScalar(-data.direction.x);\n\t// \tthis._camWorldDir.multiplyScalar(data.direction.y);\n\n\t// \tthis._velocity.copy(this._camWorldDir);\n\t// \tthis._velocity.add(this._camSideVector);\n\t// \tconst initialHeight = this._camera.position.y;\n\t// \tthis._camTmpPost.copy(this._camera.position);\n\n\t// \tif (this._playerCollisionController) {\n\t// \t\t// damping\n\t// \t\tconst damping = 1; //Math.exp(-3 * deltaTime) - 1;\n\t// \t\tthis._velocity.addScaledVector(this._velocity, damping);\n\t// \t\tconst deltaPosition = this._velocity.clone().multiplyScalar(deltaTime);\n\t// \t\tthis._camTmpPost.add(deltaPosition);\n\n\t// \t\tconst result = this._playerCollisionController.testPosition(this._camTmpPost);\n\t// \t\tif (result) {\n\t// \t\t\t// playerCollider.translate( result.normal.multiplyScalar( result.depth ) );\n\t// \t\t\tthis._camTmpPost.add(result.normal.multiplyScalar(result.depth));\n\t// \t\t}\n\t// \t\tthis._camera.position.copy(this._camTmpPost);\n\t// \t} else {\n\t// \t\tthis._camTmpPost.add(this._camSideVector);\n\t// \t\tthis._camTmpPost.add(this._camWorldDir);\n\t// \t\tthis._camera.position.copy(this._camTmpPost);\n\t// \t}\n\t// \t// ensure that the camera never changes y.\n\t// \tthis._camera.position.y = initialHeight;\n\t// }\n\n\t//\n\t//\n\t// UTILS\n\t//\n\t//\n\tprivate _getTouch(event: TouchEvent, element: HTMLElement) {\n\t\tfor (let i = 0; i < event.touches.length; i++) {\n\t\t\tconst touch = event.touches[i];\n\t\t\tif (touch.target === element) {\n\t\t\t\treturn touch;\n\t\t\t}\n\t\t}\n\t}\n}\n","/**\n * Creates a virtual joystick for mobile first person controls\n *\n * @remarks\n * Ensure to have the following tag in your html `<head>`:\n *\n * `<meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no\" />`\n *\n * as this will prevent the screen from zooming in and out when using a finger to translate and another to rotate.\n *\n * And if you are using an iphone, you may need to also add the following css:\n * - to prevent page reload when swiping down:\n *\n * ``` css\n *body {\n *\toverscroll-behavior-y: none;\n *\tposition: fixed;\n *\toverflow: hidden;\n *}\n *```\n *\n * - and to disable page zoom from double tap or when using 2 fingers:\n *\n *``` css\n *body {\n *\ttouch-action: none;\n *}\n *```\n *\n */\nimport {Camera} from 'three';\nimport {TypedCameraControlsEventNode} from './_BaseCameraControls';\nimport {NodeParamsConfig, ParamConfig} from '../utils/params/ParamsConfig';\nimport {EventConnectionPoint, EventConnectionPointType} from '../utils/io/connections/Event';\nimport {\n\tMobileJoystickControls,\n\tMobileJoystickControlsOptions,\n\tDEFAULT_PARAMS,\n} from '../../../modules/core/controls/MobileJoystickControls';\nimport {CameraControlsNodeType, NodeContext} from '../../poly/NodeContext';\nimport {BaseNodeType} from '../_Base';\nimport {CorePlayer, CorePlayerOptions} from '../../../core/player/Player';\nimport {ParamOptions} from '../../params/utils/OptionsController';\nimport {isBooleanTrue} from '../../../core/Type';\nimport {CollisionController} from './collision/CollisionController';\nimport {CapsuleSopOperation} from '../../operations/sop/Capsule';\n\nconst EVENT_START = 'start';\nconst EVENT_CHANGE = 'change';\nconst EVENT_END = 'end';\n\nfunction updatePlayerParamsCallbackOption(): ParamOptions {\n\treturn {\n\t\tcook: false,\n\t\tcallback: (node: BaseNodeType) => {\n\t\t\tMobileJoystickControlsEventNode.PARAM_CALLBACK_updatePlayerParams(node as MobileJoystickControlsEventNode);\n\t\t},\n\t};\n}\n\ntype MobileJoystickControlsMap = Map<string, MobileJoystickControls>;\n\ninterface GetElementOptions {\n\tactionAllowed: boolean;\n\tcustomElement: boolean;\n\tselector: string;\n}\n\nclass MobileJoystickEventParamsConfig extends NodeParamsConfig {\n\tmain = ParamConfig.FOLDER();\n\t/** @param collider object */\n\tcolliderObject = ParamConfig.NODE_PATH('', {\n\t\tnodeSelection: {\n\t\t\tcontext: NodeContext.SOP,\n\t\t},\n\t\t// if the node is dependent,\n\t\t// the MobileJoystickControlsEventNode will be re-created when this node changes\n\t\t// which we do not want, as it will act like a hard reset\n\t\t// when all we want is to update the collider\n\t\tdependentOnFoundNode: false,\n\t\tcallback: (node: BaseNodeType) => {\n\t\t\tMobileJoystickControlsEventNode.PARAM_CALLBACK_updateCollider(node as MobileJoystickControlsEventNode);\n\t\t},\n\t});\n\t/** @param collision Capsule Radius */\n\tcapsuleRadius = ParamConfig.FLOAT(CapsuleSopOperation.DEFAULT_PARAMS.radius, {\n\t\trange: [0, 1],\n\t\trangeLocked: [true, false],\n\t\t...updatePlayerParamsCallbackOption(),\n\t});\n\t/** @param collision Capsule Height */\n\tcapsuleHeight = ParamConfig.FLOAT(CapsuleSopOperation.DEFAULT_PARAMS.height, {\n\t\trange: [0, 2],\n\t\trangeLocked: [true, false],\n\t\t...updatePlayerParamsCallbackOption(),\n\t});\n\tphysics = ParamConfig.FOLDER();\n\t/** @param physics Steps */\n\tphysicsSteps = ParamConfig.INTEGER(5, {\n\t\trange: [1, 10],\n\t\trangeLocked: [true, false],\n\t\t...updatePlayerParamsCallbackOption(),\n\t});\n\t/** @param gravity */\n\tgravity = ParamConfig.VECTOR3([0, -30, 0], {\n\t\t...updatePlayerParamsCallbackOption(),\n\t});\n\t/** @param translation speed */\n\ttranslateSpeed = ParamConfig.FLOAT(1);\n\t/** @param rotation speed */\n\trotateSpeed = ParamConfig.FLOAT(DEFAULT_PARAMS.rotateSpeed);\n\t/** @param specify a custom HTML element */\n\tcustomTranslateElement = ParamConfig.BOOLEAN(false, {\n\t\tseparatorBefore: true,\n\t});\n\t/** @param jump HTML element selector */\n\ttranslateElementSelector = ParamConfig.STRING('#translate-element', {\n\t\tvisibleIf: {\n\t\t\tcustomTranslateElement: true,\n\t\t},\n\t});\n\t/** @param jump Allowed */\n\tjumpAllowed = ParamConfig.BOOLEAN(true, {\n\t\tseparatorBefore: true,\n\t\t...updatePlayerParamsCallbackOption(),\n\t});\n\t/** @param jump Force */\n\tjumpStrength = ParamConfig.FLOAT(10, {\n\t\trange: [0, 100],\n\t\trangeLocked: [true, false],\n\t\t...updatePlayerParamsCallbackOption(),\n\t});\n\t/** @param specify a custom HTML element */\n\tcustomJumpElement = ParamConfig.BOOLEAN(false, {\n\t\tvisibleIf: {\n\t\t\tjumpAllowed: true,\n\t\t},\n\t});\n\t/** @param jump HTML element selector */\n\tjumpElementSelector = ParamConfig.STRING('#jump-element', {\n\t\tvisibleIf: {\n\t\t\tjumpAllowed: true,\n\t\t\tcustomJumpElement: true,\n\t\t},\n\t});\n\t/** @param run Allowed */\n\trunAllowed = ParamConfig.BOOLEAN(true, {\n\t\tseparatorBefore: true,\n\t\t...updatePlayerParamsCallbackOption(),\n\t});\n\t/** @param run speed mult */\n\trunSpeedMult = ParamConfig.FLOAT(2, {\n\t\trange: [0, 10],\n\t\trangeLocked: [true, false],\n\t\t...updatePlayerParamsCallbackOption(),\n\t});\n\t/** @param specify a custom HTML element */\n\tcustomRunElement = ParamConfig.BOOLEAN(false, {\n\t\tvisibleIf: {\n\t\t\trunAllowed: true,\n\t\t},\n\t});\n\t/** @param jump HTML element selector */\n\trunElementSelector = ParamConfig.STRING('#run-element', {\n\t\tvisibleIf: {\n\t\t\trunAllowed: true,\n\t\t\tcustomRunElement: true,\n\t\t},\n\t});\n\t/** @param recompute colliding geo */\n\tupdateCollider = ParamConfig.BUTTON(null, {\n\t\tseparatorBefore: true,\n\t\tcallback: (node: BaseNodeType) => {\n\t\t\tMobileJoystickControlsEventNode.PARAM_CALLBACK_updateCollider(node as MobileJoystickControlsEventNode);\n\t\t},\n\t});\n\tinit = ParamConfig.FOLDER();\n\t/** @param start Position */\n\tstartPosition = ParamConfig.VECTOR3([0, 2, 0], {\n\t\t...updatePlayerParamsCallbackOption(),\n\t});\n\t/** @param start Position */\n\tstartRotation = ParamConfig.VECTOR3([0, 0, 0], {\n\t\t...updatePlayerParamsCallbackOption(),\n\t});\n\t/** @param reset */\n\treset = ParamConfig.BUTTON(null, {\n\t\tcallback: (node: BaseNodeType) => {\n\t\t\tMobileJoystickControlsEventNode.PARAM_CALLBACK_resetPlayer(node as MobileJoystickControlsEventNode);\n\t\t},\n\t});\n\t/** @param min polar angle */\n\tminPolarAngle = ParamConfig.FLOAT('-$PI*0.5', {\n\t\trange: [-Math.PI, Math.PI],\n\t\trangeLocked: [true, true],\n\t});\n\t/** @param max polar angle */\n\tmaxPolarAngle = ParamConfig.FLOAT('$PI*0.5', {\n\t\trange: [-Math.PI, Math.PI],\n\t\trangeLocked: [true, true],\n\t});\n}\nconst ParamsConfig = new MobileJoystickEventParamsConfig();\n\nexport class MobileJoystickControlsEventNode extends TypedCameraControlsEventNode<MobileJoystickEventParamsConfig> {\n\toverride paramsConfig = ParamsConfig;\n\tstatic override type() {\n\t\treturn CameraControlsNodeType.MOBILE_JOYSTICK;\n\t}\n\tendEventName() {\n\t\treturn 'end';\n\t}\n\tstatic readonly INPUT_UPDATE_COLLIDER = 'updateCollider';\n\tprivate _collisionController: CollisionController | undefined;\n\tcollisionController(): CollisionController {\n\t\treturn (this._collisionController = this._collisionController || new CollisionController(this));\n\t}\n\toverride initializeNode() {\n\t\tthis.io.inputs.setNamedInputConnectionPoints([\n\t\t\tnew EventConnectionPoint(\n\t\t\t\tMobileJoystickControlsEventNode.INPUT_UPDATE_COLLIDER,\n\t\t\t\tEventConnectionPointType.BASE,\n\t\t\t\tthis._updateCollider.bind(this)\n\t\t\t),\n\t\t]);\n\t\tthis.io.outputs.setNamedOutputConnectionPoints([\n\t\t\tnew EventConnectionPoint(EVENT_START, EventConnectionPointType.BASE),\n\t\t\tnew EventConnectionPoint(EVENT_CHANGE, EventConnectionPointType.BASE),\n\t\t\tnew EventConnectionPoint(EVENT_END, EventConnectionPointType.BASE),\n\t\t]);\n\t}\n\n\tprivate _controls_by_element_id: MobileJoystickControlsMap = new Map();\n\tprivate _player: CorePlayer | undefined;\n\n\tasync createControlsInstance(camera: Camera, element: HTMLElement) {\n\t\tawait this._initPlayer(camera);\n\n\t\tfunction _getElement(options: GetElementOptions) {\n\t\t\tif (!options.actionAllowed) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (!options.customElement) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\treturn document.querySelector<HTMLElement>(options.selector) || undefined;\n\t\t}\n\t\tconst translateDomElement = _getElement({\n\t\t\tactionAllowed: true,\n\t\t\tcustomElement: this.pv.customTranslateElement,\n\t\t\tselector: this.pv.translateElementSelector,\n\t\t});\n\t\tconst runDomElement = _getElement({\n\t\t\tactionAllowed: this.pv.runAllowed,\n\t\t\tcustomElement: this.pv.customRunElement,\n\t\t\tselector: this.pv.runElementSelector,\n\t\t});\n\t\tconst jumpDomElement = _getElement({\n\t\t\tactionAllowed: this.pv.jumpAllowed,\n\t\t\tcustomElement: this.pv.customJumpElement,\n\t\t\tselector: this.pv.jumpElementSelector,\n\t\t});\n\t\tconst options: MobileJoystickControlsOptions = {\n\t\t\ttranslateDomElement,\n\t\t\trunDomElement,\n\t\t\tjumpDomElement,\n\t\t};\n\t\tconst controls = new MobileJoystickControls(camera, element, options, this._player);\n\n\t\tthis._controls_by_element_id.set(element.id, controls);\n\t\tthis._bind_listeners_to_controls_instance(controls);\n\t\treturn controls;\n\t}\n\n\tprivate async _initPlayer(camera: Camera) {\n\t\tconst options = await this._playerOptions(camera);\n\t\tif (!options) {\n\t\t\treturn;\n\t\t}\n\t\tthis._player = this._player || new CorePlayer(options);\n\t\t// we need to make sure the player is updated with new camera/collision when those change\n\t\tthis._player.setOptions(options);\n\t\tthis._updatePlayerParams();\n\t\tthis._player.reset();\n\t}\n\tprivate async _playerOptions(camera: Camera): Promise<CorePlayerOptions | undefined> {\n\t\tconst collider = await this.collisionController().getCollider();\n\t\tif (!collider) {\n\t\t\tthis.states.error.set('invalid collider');\n\t\t\treturn;\n\t\t}\n\t\treturn {object: camera, collider: collider};\n\t}\n\tplayer() {\n\t\treturn this._player;\n\t}\n\tprivate async _updatePlayerParams() {\n\t\tif (!this._player) {\n\t\t\treturn;\n\t\t}\n\t\tthis._player.startPosition.copy(this.pv.startPosition);\n\t\tthis._player.physicsSteps = this.pv.physicsSteps;\n\t\tthis._player.jumpAllowed = isBooleanTrue(this.pv.jumpAllowed);\n\t\tthis._player.jumpStrength = this.pv.jumpStrength;\n\t\tthis._player.runAllowed = isBooleanTrue(this.pv.runAllowed);\n\t\tthis._player.runSpeedMult = this.pv.runSpeedMult;\n\t\tthis._player.gravity.copy(this.pv.gravity);\n\t\tthis._player.speed = this.pv.translateSpeed;\n\t\tthis._player.setCapsule({\n\t\t\tradius: this.pv.capsuleRadius,\n\t\t\theight: this.pv.capsuleHeight,\n\t\t\tdivisions: 5,\n\t\t\tcenter: CapsuleSopOperation.DEFAULT_PARAMS.center,\n\t\t});\n\n\t\tthis._controls_by_element_id.forEach((controls) => controls.updateElements());\n\t}\n\n\tprivate _resetPlayer() {\n\t\tthis._player?.reset();\n\t}\n\n\tprivate async _updateCollider() {\n\t\tawait this.collisionController().updateCollider();\n\t}\n\n\tprotected _bind_listeners_to_controls_instance(controls: MobileJoystickControls) {\n\t\tcontrols.addEventListener(EVENT_START, () => {\n\t\t\tthis.dispatchEventToOutput(EVENT_START, {});\n\t\t});\n\t\tcontrols.addEventListener(EVENT_CHANGE, () => {\n\t\t\tthis.dispatchEventToOutput(EVENT_CHANGE, {});\n\t\t});\n\t\tcontrols.addEventListener(EVENT_END, () => {\n\t\t\tthis.dispatchEventToOutput(EVENT_END, {});\n\t\t});\n\t}\n\n\tupdateRequired() {\n\t\treturn true;\n\t}\n\n\tsetupControls(controls: MobileJoystickControls) {\n\t\tcontrols.setRotationSpeed(this.pv.rotateSpeed);\n\t\tcontrols.setRotationRange({min: this.pv.minPolarAngle, max: this.pv.maxPolarAngle});\n\t\tcontrols.updateElements();\n\t}\n\n\tdisposeControlsForHtmlElementId(html_element_id: string) {\n\t\tconst controls = this._controls_by_element_id.get(html_element_id);\n\t\tif (controls) {\n\t\t\tthis._controls_by_element_id.delete(html_element_id);\n\t\t}\n\t}\n\n\tstatic PARAM_CALLBACK_updateCollider(node: MobileJoystickControlsEventNode) {\n\t\tnode._updateCollider();\n\t}\n\tstatic PARAM_CALLBACK_updatePlayerParams(node: MobileJoystickControlsEventNode) {\n\t\tnode._updatePlayerParams();\n\t}\n\tstatic PARAM_CALLBACK_resetPlayer(node: MobileJoystickControlsEventNode) {\n\t\tnode._resetPlayer();\n\t}\n}\n","/**\n * Allows to trigger mouse events.\n *\n *\n */\nimport {EventConnectionPoint, EventConnectionPointType} from '../utils/io/connections/Event';\nimport {BaseNodeType} from '../_Base';\nimport {NodeParamsConfig, ParamConfig} from '../utils/params/ParamsConfig';\nimport {TypedInputEventNode, EVENT_PARAM_OPTIONS} from './_BaseInput';\nimport {isBooleanTrue} from '../../../core/BooleanValue';\nimport {EventContext} from '../../scene/utils/events/_BaseEventsController';\nimport {EventInputType} from '../../poly/registers/nodes/types/Event';\nimport {CoreEventEmitter, EVENT_EMITTERS, EVENT_EMITTER_PARAM_MENU_OPTIONS} from '../../../core/event/CoreEventEmitter';\nimport {ACCEPTED_MOUSE_EVENT_TYPES} from '../../../core/event/MouseEventType';\nclass MouseEventParamsConfig extends NodeParamsConfig {\n\t/** @param toggle on to allow any event to be listened to */\n\tactive = ParamConfig.BOOLEAN(true, {\n\t\tcallback: (node: BaseNodeType) => {\n\t\t\tMouseEventNode.PARAM_CALLBACK_updateRegister(node as MouseEventNode);\n\t\t},\n\t\tseparatorAfter: true,\n\t});\n\t/** @param set which element triggers the event */\n\telement = ParamConfig.INTEGER(EVENT_EMITTERS.indexOf(CoreEventEmitter.CANVAS), {\n\t\t...EVENT_EMITTER_PARAM_MENU_OPTIONS,\n\t\tseparatorAfter: true,\n\t});\n\t/** @param toggle on to listen to auxclick events */\n\tauxclick = ParamConfig.BOOLEAN(0, EVENT_PARAM_OPTIONS);\n\t/** @param toggle on to listen to click events */\n\tclick = ParamConfig.BOOLEAN(0, EVENT_PARAM_OPTIONS);\n\t/** @param toggle on to listen to contextmenu events */\n\tcontextmenu = ParamConfig.BOOLEAN(0, EVENT_PARAM_OPTIONS);\n\t/** @param toggle on to listen to dblclick events */\n\tdblclick = ParamConfig.BOOLEAN(0, EVENT_PARAM_OPTIONS);\n\t/** @param toggle on to listen to mousedown events */\n\tmousedown = ParamConfig.BOOLEAN(1, EVENT_PARAM_OPTIONS);\n\t/** @param toggle on to listen to mouseenter events */\n\tmouseenter = ParamConfig.BOOLEAN(0, EVENT_PARAM_OPTIONS);\n\t/** @param toggle on to listen to mouseleave events */\n\tmouseleave = ParamConfig.BOOLEAN(0, EVENT_PARAM_OPTIONS);\n\t/** @param toggle on to listen to mousemove events */\n\tmousemove = ParamConfig.BOOLEAN(1, EVENT_PARAM_OPTIONS);\n\t/** @param toggle on to listen to mouseover events */\n\tmouseover = ParamConfig.BOOLEAN(0, EVENT_PARAM_OPTIONS);\n\t/** @param toggle on to listen to mouseout events */\n\tmouseout = ParamConfig.BOOLEAN(0, EVENT_PARAM_OPTIONS);\n\t/** @param toggle on to listen to mouseup events */\n\tmouseup = ParamConfig.BOOLEAN(1, EVENT_PARAM_OPTIONS);\n\t/** @param toggle on to listen to pointerlockchange events */\n\tpointerlockchange = ParamConfig.BOOLEAN(0, EVENT_PARAM_OPTIONS);\n\t/** @param toggle on to listen to pointerlockerror events */\n\tpointerlockerror = ParamConfig.BOOLEAN(0, EVENT_PARAM_OPTIONS);\n\t/** @param toggle on to listen to select events */\n\tselect = ParamConfig.BOOLEAN(0, EVENT_PARAM_OPTIONS);\n\t/** @param toggle on to listen to wheel events */\n\twheel = ParamConfig.BOOLEAN(0, EVENT_PARAM_OPTIONS);\n\t/** @param requires ctrlKey */\n\tctrlKey = ParamConfig.BOOLEAN(0, {...EVENT_PARAM_OPTIONS, separatorBefore: true});\n\t/** @param requires altKey */\n\taltKey = ParamConfig.BOOLEAN(0, EVENT_PARAM_OPTIONS);\n\t/** @param requires shiftKey */\n\tshiftKey = ParamConfig.BOOLEAN(0, EVENT_PARAM_OPTIONS);\n\t/** @param requires metaKey */\n\tmetaKey = ParamConfig.BOOLEAN(0, EVENT_PARAM_OPTIONS);\n}\nconst ParamsConfig = new MouseEventParamsConfig();\n\nexport class MouseEventNode extends TypedInputEventNode<MouseEventParamsConfig> {\n\toverride paramsConfig = ParamsConfig;\n\tstatic override type() {\n\t\treturn EventInputType.MOUSE;\n\t}\n\tprotected acceptedEventTypes() {\n\t\treturn new Set([...ACCEPTED_MOUSE_EVENT_TYPES]);\n\t}\n\toverride initializeNode() {\n\t\tthis.io.outputs.setNamedOutputConnectionPoints(\n\t\t\tACCEPTED_MOUSE_EVENT_TYPES.map((event_type) => {\n\t\t\t\treturn new EventConnectionPoint(event_type, EventConnectionPointType.MOUSE);\n\t\t\t})\n\t\t);\n\t}\n\toverride processEvent(eventContext: EventContext<MouseEvent>) {\n\t\tif (!this.pv.active) {\n\t\t\treturn;\n\t\t}\n\t\tconst event = eventContext.event;\n\t\tif (!event) {\n\t\t\treturn;\n\t\t}\n\t\tif (event.ctrlKey != isBooleanTrue(this.pv.ctrlKey)) {\n\t\t\treturn;\n\t\t}\n\t\tif (event.shiftKey != isBooleanTrue(this.pv.shiftKey)) {\n\t\t\treturn;\n\t\t}\n\t\tif (event.altKey != isBooleanTrue(this.pv.altKey)) {\n\t\t\treturn;\n\t\t}\n\t\tif (event.metaKey != isBooleanTrue(this.pv.metaKey)) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis.dispatchEventToOutput(event.type, eventContext);\n\t}\n}\n","/**\n * triggers an event when a parameter has changed\n *\n *\n */\nimport {TypedEventNode} from './_Base';\nimport {EventConnectionPoint, EventConnectionPointType} from '../utils/io/connections/Event';\nimport {NodeParamsConfig, ParamConfig} from '../utils/params/ParamsConfig';\nimport {CoreGraphNode} from '../../../core/graph/CoreGraphNode';\nimport {BaseParamType} from '../../params/_Base';\nimport {RampParam} from '../../params/Ramp';\n\nfunction previousValueParamOptions() {\n\treturn {\n\t\tcook: false,\n\t\thidden: true,\n\t};\n}\n\nclass ParamEventParamsConfig extends NodeParamsConfig {\n\t/** @param set to listen or stop listening to the param */\n\tactive = ParamConfig.BOOLEAN(true);\n\t/** @param the parameter to update */\n\tparam = ParamConfig.PARAM_PATH('', {\n\t\tdependentOnFoundParam: false,\n\t\tparamSelection: true,\n\t\tcomputeOnDirty: true,\n\t});\n\tboolean = ParamConfig.BOOLEAN(0, previousValueParamOptions());\n\tinteger = ParamConfig.INTEGER(0, previousValueParamOptions());\n\tfloat = ParamConfig.FLOAT(0, previousValueParamOptions());\n\tvector2 = ParamConfig.VECTOR2([0, 0], previousValueParamOptions());\n\tvector3 = ParamConfig.VECTOR3([0, 0, 0], previousValueParamOptions());\n\tvector4 = ParamConfig.VECTOR4([0, 0, 0, 0], previousValueParamOptions());\n\tramp = ParamConfig.RAMP(RampParam.DEFAULT_VALUE, previousValueParamOptions());\n\tstring = ParamConfig.STRING('', previousValueParamOptions());\n}\nconst ParamsConfig = new ParamEventParamsConfig();\n\nexport class ParamEventNode extends TypedEventNode<ParamEventParamsConfig> {\n\toverride paramsConfig = ParamsConfig;\n\tstatic override type(): Readonly<'param'> {\n\t\treturn 'param';\n\t}\n\tstatic readonly OUTPUT_NAME = 'valueChanged';\n\n\toverride initializeNode() {\n\t\tthis.io.outputs.setNamedOutputConnectionPoints([\n\t\t\tnew EventConnectionPoint(ParamEventNode.OUTPUT_NAME, EventConnectionPointType.BASE),\n\t\t]);\n\t}\n\n\toverride async cook() {\n\t\tawait this._listenToParam();\n\t\tthis.cookController.endCook();\n\t}\n\toverride dispose() {\n\t\tsuper.dispose();\n\t\tthis._reset();\n\t}\n\tprivate _reset() {\n\t\tthis.__paramCoreGraphNode__?.graphRemove();\n\t}\n\n\tprivate _resolvedParam: BaseParamType | null = null;\n\tprivate _previousValueParam: BaseParamType | null = null;\n\tprivate async _listenToParam() {\n\t\tif (!this.p.param) {\n\t\t\t// in the current implementation,\n\t\t\t// cook is triggered a first time when the node is created (before the params are created),\n\t\t\t// and therefore _listenToParam.\n\t\t\t// So we need to check that the parameter does exist\n\t\t\treturn;\n\t\t}\n\t\tif (this._resolvedParam) {\n\t\t\tthis.__paramCoreGraphNode__?.removeGraphInput(this._resolvedParam);\n\t\t\tthis._previousValueParam = null;\n\t\t}\n\t\tif (this.p.param.isDirty()) {\n\t\t\t// TODO: investigate occasions\n\t\t\t// where the referenced param is recomputed\n\t\t\t// (such as in a material builder)\n\t\t\t// and this node refers to an old param\n\t\t\tawait this.p.param.compute();\n\t\t}\n\t\tthis._resolvedParam = this.p.param.value.param();\n\t\tif (this._resolvedParam) {\n\t\t\tconst previousValueParams = [\n\t\t\t\tthis.p.boolean,\n\t\t\t\tthis.p.integer,\n\t\t\t\tthis.p.float,\n\t\t\t\tthis.p.vector2,\n\t\t\t\tthis.p.vector3,\n\t\t\t\tthis.p.vector4,\n\t\t\t\tthis.p.ramp,\n\t\t\t\tthis.p.string,\n\t\t\t];\n\t\t\tfor (const p of previousValueParams) {\n\t\t\t\tif (p.type() == this._resolvedParam.type()) {\n\t\t\t\t\tthis._previousValueParam = p;\n\t\t\t\t\tawait this._resolvedParam.compute();\n\t\t\t\t\tthis._previousValueParam.copyValue(this._resolvedParam);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!this._previousValueParam) {\n\t\t\t\tthis.states.error.set(\n\t\t\t\t\t`param type ${this._resolvedParam.type()} is not supported, availables are: ${previousValueParams\n\t\t\t\t\t\t.map((p) => p.type())\n\t\t\t\t\t\t.join(', ')}`\n\t\t\t\t);\n\t\t\t}\n\t\t\tthis.paramGraphNode().addGraphInput(this._resolvedParam);\n\t\t}\n\t}\n\tprivate paramGraphNode() {\n\t\treturn (this.__paramCoreGraphNode__ = this.__paramCoreGraphNode__ || this._createCoreGraphNode());\n\t}\n\tprivate __paramCoreGraphNode__: CoreGraphNode | undefined;\n\tprivate _createCoreGraphNode() {\n\t\tconst node = new CoreGraphNode(this.scene(), 'event/Param');\n\t\tnode.dirtyController.addPostDirtyHook('onParamDirty', this._onParamDirtyBound);\n\t\treturn node;\n\t}\n\tprivate _onParamDirtyBound = this._onParamDirty.bind(this);\n\tprivate async _onParamDirty() {\n\t\tif (!(this._resolvedParam && this._previousValueParam)) {\n\t\t\treturn;\n\t\t}\n\t\tawait this._resolvedParam.compute();\n\t\tconst valueChanged = !this._resolvedParam.isValueEqual(this._previousValueParam.value);\n\n\t\tif (valueChanged) {\n\t\t\tthis._previousValueParam.copyValue(this._resolvedParam);\n\t\t\tthis.dispatchEventToOutput(ParamEventNode.OUTPUT_NAME, {});\n\t\t}\n\t}\n}\n","/**\n * Allows to trigger pointer events.\n *\n *\n */\nimport {EventConnectionPoint, EventConnectionPointType} from '../utils/io/connections/Event';\nimport {BaseNodeType} from '../_Base';\nimport {NodeParamsConfig, ParamConfig} from '../utils/params/ParamsConfig';\nimport {TypedInputEventNode, EVENT_PARAM_OPTIONS} from './_BaseInput';\nimport {isBooleanTrue} from '../../../core/BooleanValue';\nimport {EventContext} from '../../scene/utils/events/_BaseEventsController';\nimport {EventInputType} from '../../poly/registers/nodes/types/Event';\nimport {CoreEventEmitter, EVENT_EMITTERS} from '../../../core/event/CoreEventEmitter';\nimport {ONLY_POINTER_EVENT_TYPES} from '../../../core/event/PointerEventType';\n\nclass PointerEventParamsConfig extends NodeParamsConfig {\n\t/** @param toggle on to allow any event to be listened to */\n\tactive = ParamConfig.BOOLEAN(true, {\n\t\tcallback: (node: BaseNodeType) => {\n\t\t\tPointerEventNode.PARAM_CALLBACK_updateRegister(node as PointerEventNode);\n\t\t},\n\t\tseparatorAfter: true,\n\t});\n\t/** @param set which element triggers the event */\n\telement = ParamConfig.INTEGER(EVENT_EMITTERS.indexOf(CoreEventEmitter.CANVAS), {\n\t\tmenu: {\n\t\t\tentries: EVENT_EMITTERS.map((name, value) => {\n\t\t\t\treturn {name, value};\n\t\t\t}),\n\t\t},\n\t\tseparatorAfter: true,\n\t});\n\t/** @param toggle on to listen to click events */\n\tpointerdown = ParamConfig.BOOLEAN(1, EVENT_PARAM_OPTIONS);\n\t/** @param toggle on to listen to pointermove events */\n\tpointermove = ParamConfig.BOOLEAN(0, EVENT_PARAM_OPTIONS);\n\t/** @param toggle on to listen to pointerup events */\n\tpointerup = ParamConfig.BOOLEAN(0, EVENT_PARAM_OPTIONS);\n\t/** @param requires ctrlKey */\n\tctrlKey = ParamConfig.BOOLEAN(0, {...EVENT_PARAM_OPTIONS, separatorBefore: true});\n\t/** @param requires altKey */\n\taltKey = ParamConfig.BOOLEAN(0, EVENT_PARAM_OPTIONS);\n\t/** @param requires shiftKey */\n\tshiftKey = ParamConfig.BOOLEAN(0, EVENT_PARAM_OPTIONS);\n\t/** @param requires metaKey */\n\tmetaKey = ParamConfig.BOOLEAN(0, EVENT_PARAM_OPTIONS);\n}\nconst ParamsConfig = new PointerEventParamsConfig();\n\nexport class PointerEventNode extends TypedInputEventNode<PointerEventParamsConfig> {\n\toverride paramsConfig = ParamsConfig;\n\tstatic override type() {\n\t\treturn EventInputType.POINTER;\n\t}\n\tprotected acceptedEventTypes() {\n\t\treturn new Set([...ONLY_POINTER_EVENT_TYPES]);\n\t}\n\toverride initializeNode() {\n\t\tthis.io.outputs.setNamedOutputConnectionPoints(\n\t\t\tONLY_POINTER_EVENT_TYPES.map((event_type) => {\n\t\t\t\treturn new EventConnectionPoint(event_type, EventConnectionPointType.POINTER);\n\t\t\t})\n\t\t);\n\t}\n\toverride processEvent(eventContext: EventContext<MouseEvent>) {\n\t\tif (!this.pv.active) {\n\t\t\treturn;\n\t\t}\n\t\tconst event = eventContext.event;\n\t\tif (!event) {\n\t\t\treturn;\n\t\t}\n\t\tif (event.ctrlKey != isBooleanTrue(this.pv.ctrlKey)) {\n\t\t\treturn;\n\t\t}\n\t\tif (event.shiftKey != isBooleanTrue(this.pv.shiftKey)) {\n\t\t\treturn;\n\t\t}\n\t\tif (event.altKey != isBooleanTrue(this.pv.altKey)) {\n\t\t\treturn;\n\t\t}\n\t\tif (event.metaKey != isBooleanTrue(this.pv.metaKey)) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis.dispatchEventToOutput(event.type, eventContext);\n\t}\n}\n","/**\n * A subnet to create POST PROCESS nodes\n *\n */\nimport {Constructor, valueof} from '../../../types/GlobalTypes';\nimport {BaseNetworkEventNode} from './_BaseManager';\nimport {NetworkNodeType, NodeContext} from '../../poly/NodeContext';\nimport {PostNodeChildrenMap} from '../../poly/registers/nodes/Post';\nimport {BasePostProcessNodeType} from '../post/_Base';\nimport {DisplayNodeController} from '../utils/DisplayNodeController';\nimport {EffectComposerController, PostProcessNetworkParamsConfig} from '../post/utils/EffectComposerController';\nimport {NodeCreateOptions} from '../utils/hierarchy/ChildrenController';\n\nexport class PostProcessNetworkEventNode extends BaseNetworkEventNode<PostProcessNetworkParamsConfig> {\n\toverride paramsConfig = new PostProcessNetworkParamsConfig();\n\tstatic override type() {\n\t\treturn NetworkNodeType.POST;\n\t}\n\treadonly effectsComposerController: EffectComposerController = new EffectComposerController(this);\n\tpublic override readonly displayNodeController: DisplayNodeController = new DisplayNodeController(\n\t\tthis,\n\t\tthis.effectsComposerController.displayNodeControllerCallbacks()\n\t);\n\n\tprotected override _childrenControllerContext = NodeContext.POST;\n\n\toverride createNode<S extends keyof PostNodeChildrenMap>(\n\t\tnode_class: S,\n\t\toptions?: NodeCreateOptions\n\t): PostNodeChildrenMap[S];\n\toverride createNode<K extends valueof<PostNodeChildrenMap>>(\n\t\tnode_class: Constructor<K>,\n\t\toptions?: NodeCreateOptions\n\t): K;\n\toverride createNode<K extends valueof<PostNodeChildrenMap>>(\n\t\tnode_class: Constructor<K>,\n\t\toptions?: NodeCreateOptions\n\t): K {\n\t\treturn super.createNode(node_class, options) as K;\n\t}\n\toverride children() {\n\t\treturn super.children() as BasePostProcessNodeType[];\n\t}\n\toverride nodesByType<K extends keyof PostNodeChildrenMap>(type: K): PostNodeChildrenMap[K][] {\n\t\treturn super.nodesByType(type) as PostNodeChildrenMap[K][];\n\t}\n}\n","/**\n * Sends events related to the scene\n *\n *\n */\nimport {PolyEventName} from './../../poly/utils/PolyEventName';\nimport {BaseNodeType} from '../_Base';\nimport {BaseParamType} from '../../params/_Base';\nimport {EventConnectionPoint, EventConnectionPointType, BaseEventConnectionPoint} from '../utils/io/connections/Event';\nimport {EventContext} from '../../scene/utils/events/_BaseEventsController';\nimport {NodeParamsConfig, ParamConfig} from '../utils/params/ParamsConfig';\nimport {CoreGraphNode} from '../../../core/graph/CoreGraphNode';\nimport {TypedEventNode} from './_Base';\nimport {ParamOptions} from '../../params/utils/OptionsController';\nimport {isBooleanTrue} from '../../../core/Type';\n\nenum SceneNodeInput {\n\tSET_FRAME = 'setFrame',\n}\nenum SceneNodeOutput {\n\tTICK = 'tick',\n\tTIME_REACHED = 'timeReached',\n}\nconst UPDATE_SCENE_EVENT_PARAM_OPTIONS: ParamOptions = {\n\tvisibleIf: {active: 1},\n\tcallback: (node: BaseNodeType) => {\n\t\tSceneEventNode.PARAM_CALLBACK_updateSceneEventsController(node as SceneEventNode);\n\t},\n};\nconst UPDATE_TIME_DEPENDENCY_PARAM_OPTIONS: ParamOptions = {\n\tvisibleIf: {active: 1},\n\tcallback: (node: BaseNodeType) => {\n\t\tSceneEventNode.PARAM_CALLBACK_updateTimeDependency(node as SceneEventNode);\n\t},\n};\n\ninterface OnTickCallbackBuilderOptions {\n\ttick: boolean;\n\ttreachedTime: boolean;\n\treachedTime: number;\n}\n\nenum EventName {\n\tCREATED = 'created',\n\tREADY = 'ready',\n\tPLAY = 'play',\n\tPAUSE = 'pause',\n}\nexport const ACCEPTED_EVENT_TYPES: EventName[] = [EventName.CREATED, EventName.READY, EventName.PLAY, EventName.PAUSE];\n\nclass SceneEventParamsConfig extends NodeParamsConfig {\n\t/** @param toggle on to allow any event to be listened to */\n\tactive = ParamConfig.BOOLEAN(true, {\n\t\tcallback: (node: BaseNodeType, param: BaseParamType) => {\n\t\t\tSceneEventNode.PARAM_CALLBACK_updateActiveState(node as SceneEventNode);\n\t\t},\n\t\tseparatorAfter: true,\n\t});\n\t/** @param set which element triggers the event */\n\telement = ParamConfig.INTEGER(0, {\n\t\thidden: true,\n\t});\n\t/** @param toggle on to trigger an event when the scene has been created. This can be useful to initialize other nodes */\n\tcreated = ParamConfig.BOOLEAN(1, UPDATE_SCENE_EVENT_PARAM_OPTIONS);\n\t/** @param toggle on to trigger an event when every object in the scene has been loaded. This can be useful to initialize other nodes */\n\tready = ParamConfig.BOOLEAN(1, UPDATE_SCENE_EVENT_PARAM_OPTIONS);\n\t/** @param toggle on to trigger an event when the scene starts playing */\n\tplay = ParamConfig.BOOLEAN(1, UPDATE_SCENE_EVENT_PARAM_OPTIONS);\n\t/** @param toggle on to trigger an event when the scene pauses */\n\tpause = ParamConfig.BOOLEAN(1, UPDATE_SCENE_EVENT_PARAM_OPTIONS);\n\t/** @param toggle on to trigger an event on every tick */\n\ttick = ParamConfig.BOOLEAN(1, {\n\t\tseparatorAfter: true,\n\t\t...UPDATE_TIME_DEPENDENCY_PARAM_OPTIONS,\n\t});\n\t/** @param toggle on to trigger an event on every tick */\n\ttreachedTime = ParamConfig.BOOLEAN(0, UPDATE_TIME_DEPENDENCY_PARAM_OPTIONS);\n\t/** @param time to trigger an event */\n\treachedTime = ParamConfig.FLOAT(10, {\n\t\tvisibleIf: {treachedTime: 1},\n\t\trange: [0, 100],\n\t\tseparatorAfter: true,\n\t\t...UPDATE_TIME_DEPENDENCY_PARAM_OPTIONS,\n\t});\n\t/** @param frame to set */\n\tsetFrameValue = ParamConfig.INTEGER(1, {\n\t\trange: [0, 100],\n\t});\n\t/** @param button to set a specific frame */\n\tsetFrame = ParamConfig.BUTTON(null, {\n\t\tcallback: (node: BaseNodeType) => {\n\t\t\tSceneEventNode.PARAM_CALLBACK_setFrame(node as SceneEventNode);\n\t\t},\n\t});\n}\nconst ParamsConfig = new SceneEventParamsConfig();\n\nexport class SceneEventNode extends TypedEventNode<SceneEventParamsConfig> {\n\toverride paramsConfig = ParamsConfig;\n\tstatic override type() {\n\t\treturn 'scene';\n\t}\n\n\tprivate _graphNode: CoreGraphNode | undefined;\n\n\toverride dispose() {\n\t\tthis._graphNode?.dispose();\n\t\tsuper.dispose();\n\t}\n\n\toverride initializeNode() {\n\t\tthis.io.inputs.setNamedInputConnectionPoints([\n\t\t\tnew EventConnectionPoint(\n\t\t\t\tSceneNodeInput.SET_FRAME,\n\t\t\t\tEventConnectionPointType.BASE,\n\t\t\t\tthis._onSetFrame.bind(this)\n\t\t\t),\n\t\t\tnew EventConnectionPoint(EventName.PLAY, EventConnectionPointType.BASE, this._play.bind(this)),\n\t\t\tnew EventConnectionPoint(EventName.PAUSE, EventConnectionPointType.BASE, this._pause.bind(this)),\n\t\t]);\n\t\tconst outConnectionPoints: BaseEventConnectionPoint[] = ACCEPTED_EVENT_TYPES.map((event_type) => {\n\t\t\treturn new EventConnectionPoint(event_type, EventConnectionPointType.BASE);\n\t\t});\n\t\toutConnectionPoints.push(new EventConnectionPoint(SceneNodeOutput.TICK, EventConnectionPointType.BASE));\n\t\toutConnectionPoints.push(new EventConnectionPoint(SceneNodeOutput.TIME_REACHED, EventConnectionPointType.BASE));\n\t\tthis.io.outputs.setNamedOutputConnectionPoints(outConnectionPoints);\n\n\t\tthis.params.onParamsCreated('updateTimeDependency', () => {\n\t\t\tthis._updateTimeDependency();\n\t\t});\n\t\tthis._updateSceneEventsController();\n\n\t\t// register/unregister\n\t\tconst register = () => {\n\t\t\tthis._updateSceneEventsController();\n\t\t};\n\t\tconst unregister = () => {\n\t\t\tconst eventsController = this.scene().eventsDispatcher.sceneEventsController;\n\t\t\teventsController.removeObserverFromAllEventTypes(this);\n\t\t};\n\t\tthis.lifecycle.onAfterAdded(register);\n\t\tthis.lifecycle.onBeforeDeleted(unregister);\n\t}\n\n\toverride processEvent(eventContext: EventContext<Event>) {\n\t\tif (!this.pv.active) {\n\t\t\treturn;\n\t\t}\n\t\tif (!eventContext.event) {\n\t\t\treturn;\n\t\t}\n\t\tconst eventType = eventContext.event.type;\n\t\tswitch (eventType) {\n\t\t\tcase PolyEventName.SCENE_CREATED: {\n\t\t\t\treturn this.dispatchEventToOutput(EventName.CREATED, eventContext);\n\t\t\t}\n\t\t\tcase PolyEventName.SCENE_READY: {\n\t\t\t\treturn this.dispatchEventToOutput(EventName.READY, eventContext);\n\t\t\t}\n\t\t\tcase PolyEventName.SCENE_PLAY: {\n\t\t\t\treturn this.dispatchEventToOutput(EventName.PLAY, eventContext);\n\t\t\t}\n\t\t\tcase PolyEventName.SCENE_PAUSE: {\n\t\t\t\treturn this.dispatchEventToOutput(EventName.PAUSE, eventContext);\n\t\t\t}\n\t\t}\n\n\t\tthis.dispatchEventToOutput(eventContext.event.type, eventContext);\n\t}\n\n\tprivate _onSetFrame(eventContext: EventContext<Event>) {\n\t\tthis.scene().setFrame(this.pv.setFrameValue);\n\t}\n\tprivate _play(eventContext: EventContext<Event>) {\n\t\tthis.scene().play();\n\t}\n\tprivate _pause(eventContext: EventContext<Event>) {\n\t\tthis.scene().pause();\n\t}\n\n\tprivate _timeReached = false;\n\tprivate _onTickCheckTimeReached(time: number, reachedTime: number) {\n\t\tif (time >= this.pv.reachedTime) {\n\t\t\tif (!this._timeReached) {\n\t\t\t\tthis._timeReached = true;\n\t\t\t\tthis.dispatchEventToOutput(SceneNodeOutput.TIME_REACHED, {});\n\t\t\t}\n\t\t} else {\n\t\t\tthis._timeReached = false;\n\t\t}\n\t}\n\tprivate _onTickEvent() {\n\t\tthis.dispatchEventToOutput(SceneNodeOutput.TICK, {});\n\t}\n\n\tprivate _updateTimeDependency() {\n\t\tconst timeGraphNode = this.scene().timeController.graphNode;\n\t\tthis._graphNode?.removeGraphInput(timeGraphNode);\n\t\tif (!isBooleanTrue(this.pv.active)) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (isBooleanTrue(this.pv.treachedTime) || isBooleanTrue(this.pv.tick)) {\n\t\t\tthis._graphNode = this._graphNode || new CoreGraphNode(this.scene(), 'sceneNodeTimeGraphNode');\n\t\t\tthis._graphNode.addGraphInput(timeGraphNode);\n\n\t\t\tconst options: OnTickCallbackBuilderOptions = {\n\t\t\t\ttick: this.pv.tick,\n\t\t\t\ttreachedTime: this.pv.treachedTime,\n\t\t\t\treachedTime: this.pv.reachedTime,\n\t\t\t};\n\n\t\t\tconst callback = this._buildOnTickCallback(options)?.bind(this);\n\t\t\tif (callback) {\n\t\t\t\tconst callbackName = 'timeUpdate';\n\t\t\t\tthis._graphNode.removePostDirtyHook(callbackName);\n\t\t\t\tthis._graphNode.addPostDirtyHook(callbackName, callback);\n\t\t\t}\n\t\t}\n\t}\n\tprivate _buildOnTickCallback(options: OnTickCallbackBuilderOptions) {\n\t\tif (isBooleanTrue(options.treachedTime) && isBooleanTrue(options.tick)) {\n\t\t\treturn () => {\n\t\t\t\tconst time = this.scene().time();\n\t\t\t\tthis._onTickEvent();\n\t\t\t\tthis._onTickCheckTimeReached(time, options.reachedTime);\n\t\t\t};\n\t\t} else {\n\t\t\tif (isBooleanTrue(options.treachedTime)) {\n\t\t\t\treturn () => {\n\t\t\t\t\tconst time = this.scene().time();\n\t\t\t\t\tthis._onTickCheckTimeReached(time, options.reachedTime);\n\t\t\t\t};\n\t\t\t}\n\t\t\tif (isBooleanTrue(options.tick)) {\n\t\t\t\treturn this._onTickEvent.bind(this);\n\t\t\t}\n\t\t}\n\t}\n\n\tstatic PARAM_CALLBACK_setFrame(node: SceneEventNode) {\n\t\tnode._onSetFrame({});\n\t}\n\tstatic PARAM_CALLBACK_updateTimeDependency(node: SceneEventNode) {\n\t\tnode._updateTimeDependency();\n\t}\n\n\tstatic PARAM_CALLBACK_updateSceneEventsController(node: SceneEventNode) {\n\t\tnode._updateSceneEventsController();\n\t}\n\tstatic PARAM_CALLBACK_updateActiveState(node: SceneEventNode) {\n\t\tnode._updateTimeDependency();\n\t\tnode._updateSceneEventsController();\n\t}\n\n\tprivate _updateSceneEventsController() {\n\t\tconst eventsController = this.scene().eventsDispatcher.sceneEventsController;\n\t\teventsController.removeObserverFromAllEventTypes(this);\n\t\tif (!this.pv.active) {\n\t\t\treturn;\n\t\t}\n\t\tthis._updateTimeDependency();\n\t\t// if (isBooleanTrue(this.pv.tick)) {\n\t\t// \teventsController.addObserver(this, SceneEventType.TICK);\n\t\t// }\n\t\tif (isBooleanTrue(this.pv.created)) {\n\t\t\teventsController.addObserver(this, PolyEventName.SCENE_CREATED);\n\t\t}\n\t\tif (isBooleanTrue(this.pv.ready)) {\n\t\t\teventsController.addObserver(this, PolyEventName.SCENE_READY);\n\t\t}\n\t\tif (isBooleanTrue(this.pv.play)) {\n\t\t\teventsController.addObserver(this, PolyEventName.SCENE_PLAY);\n\t\t}\n\t\tif (isBooleanTrue(this.pv.pause)) {\n\t\t\teventsController.addObserver(this, PolyEventName.SCENE_PAUSE);\n\t\t}\n\t}\n}\n","/**\n * Triggers events based on page scroll\n *\n *\n * @remarks\n *\n * In order to test the [event/ScrollTrigger](/docs/nodes/event/ScrollTrigger) node, you can create the following setup:\n *\n * Using Polygonjs [local app](/local), add the following line to the `EditorConfig.ts` file, inside the `configureEditor` function:\n *\n * ```\n * options.api.panel.viewer.setData({viewerId: 'my-viewer', html: require('./viewer.html')})\n * ```\n *\n * and create a file `viewer.html` in the same folder as `EditorConfig.ts`, containing the following:\n *\n * ```<div id=\"main-container\" style=\"position: relative; height: 100%\">\n *\t<div id=\"my-viewer\" style=\"position: absolute; width: 100%; height: 100%\"></div>\n *\t<div id=\"scroll-container\" style=\"position: relative; height: 100%; overflow-y: scroll\">\n *\t\t<div id=\"checkpoint1\" style=\"height: 400px; color: white\">checkpoint 1</div>\n *\t\t<div id=\"checkpoint2\" style=\"height: 400px; color: red\">checkpoint 2</div>\n *\t\t<div id=\"checkpoint3\" style=\"height: 400px; color: green\">checkpoint 3</div>\n *\t\t<div id=\"checkpoint4\" style=\"height: 400px; color: lightred\">checkpoint 4</div>\n *\t</div>\n * </div>```\n *\n * Then reload the editor. You will then see the viewer with a scrollbar and other divs inside.\n *\n * Then create a [event/ScrollTrigger](/docs/nodes/event/ScrollTrigger) node, and set its parameters as follow:\n *\n * - param `element` to `#checkpoint2`\n * - param `useViewport` to `false`\n * - param `scroller` to `#scroll-container`\n * - param `markers` to `true`\n *\n * You should now be able to connect other event nodes to the outputs of the scrollTrigger node,\n * and have those be triggered as you scroll.\n *\n */\nimport {EventConnectionPoint, EventConnectionPointType} from '../utils/io/connections/Event';\nimport {NodeParamsConfig, ParamConfig} from '../utils/params/ParamsConfig';\nimport {TypedEventNode} from './_Base';\nimport {EventContext} from '../../scene/utils/events/_BaseEventsController';\nimport {isBooleanTrue} from '../../../core/Type';\nimport {VisibleIfParamOptions} from '../../params/utils/OptionsController';\n\nimport ScrollTrigger from 'gsap/ScrollTrigger';\nimport {BaseNodeType} from '../_Base';\nimport {gsap} from '../../../core/thirdParty/gsap/gsap';\nimport {ModuleName} from '../../poly/registers/modules/Common';\nimport {gsapLib} from '../../../core/thirdParty/gsap/gsapFactory';\ngsap.registerPlugin(ScrollTrigger);\n\nenum ScrollTriggerNodeInput {\n\tCREATE = 'create',\n\tDISPOSE = 'dispose',\n}\nenum ScrollTriggerNodeOutput {\n\tTOGGLE = 'toggle',\n\tENTER = 'enter',\n\tLEAVE = 'leave',\n\tENTER_BACK = 'enterBack',\n\tLEAVE_BACK = 'leaveBack',\n}\n\ninterface DefaultParamOptionsOptions {\n\tvisibleIf?: VisibleIfParamOptions;\n}\n\nconst defaultParamOptions = (options?: DefaultParamOptionsOptions) => {\n\tlet visibleIf: VisibleIfParamOptions | undefined = options?.visibleIf;\n\tif (visibleIf) {\n\t\tvisibleIf.active = 1;\n\t} else {\n\t\tvisibleIf = {active: 1};\n\t}\n\n\treturn {\n\t\tvisibleIf,\n\t\tcallback: (node: BaseNodeType) => {\n\t\t\tScrollTriggerEventNode.PARAM_CALLBACK_updateScrollTrigger(node as ScrollTriggerEventNode);\n\t\t},\n\t};\n};\nconst UPDATE_SCROLL_TRIGGER_PARAM_OPTIONS = defaultParamOptions();\n\nclass ScrollTriggerParamsConfig extends NodeParamsConfig {\n\t/** @param active */\n\tactive = ParamConfig.BOOLEAN(true, {\n\t\tcallback: (node: BaseNodeType) => {\n\t\t\tScrollTriggerEventNode.PARAM_CALLBACK_updateScrollTrigger(node as ScrollTriggerEventNode);\n\t\t},\n\t});\n\t/** @param selector of the element the scroll events are detected for */\n\telement = ParamConfig.STRING('', UPDATE_SCROLL_TRIGGER_PARAM_OPTIONS);\n\t/** @param use viewport as scroller */\n\tuseViewport = ParamConfig.BOOLEAN(1, UPDATE_SCROLL_TRIGGER_PARAM_OPTIONS);\n\t/** @param override the scroller */\n\tscroller = ParamConfig.STRING('', defaultParamOptions({visibleIf: {useViewport: 0}}));\n\t/** @param add markers for debugging */\n\tmarkers = ParamConfig.BOOLEAN('!playerMode()', {\n\t\t...UPDATE_SCROLL_TRIGGER_PARAM_OPTIONS,\n\t\tseparatorAfter: true,\n\t});\n\t/** @param define if progress should be updated */\n\ttprogress = ParamConfig.BOOLEAN(0, UPDATE_SCROLL_TRIGGER_PARAM_OPTIONS);\n\t/** @param progress */\n\tprogress = ParamConfig.FLOAT(0, {\n\t\teditable: false,\n\t\tvisibleIf: {tprogress: 1},\n\t});\n\t/** @param define if the scroll is inside the element */\n\ttinsideElement = ParamConfig.BOOLEAN(0, UPDATE_SCROLL_TRIGGER_PARAM_OPTIONS);\n\t/** @param 1 if the scroll is inside the element */\n\tinsideElement = ParamConfig.BOOLEAN(0, {\n\t\teditable: false,\n\t\tvisibleIf: {tinsideElement: 1},\n\t});\n\t/** @param sends a trigger when we leaving or entering the element */\n\tonToggle = ParamConfig.BOOLEAN(1, {\n\t\t...UPDATE_SCROLL_TRIGGER_PARAM_OPTIONS,\n\t\tseparatorBefore: true,\n\t});\n\t/** @param sends a trigger when entering the element */\n\tonEnter = ParamConfig.BOOLEAN(0, UPDATE_SCROLL_TRIGGER_PARAM_OPTIONS);\n\t/** @param sends a trigger when leaving the element */\n\tonLeave = ParamConfig.BOOLEAN(0, UPDATE_SCROLL_TRIGGER_PARAM_OPTIONS);\n\t/** @param sends a trigger when entering again the element */\n\tonEnterBack = ParamConfig.BOOLEAN(0, UPDATE_SCROLL_TRIGGER_PARAM_OPTIONS);\n\t/** @param sends a trigger when leaving again the element */\n\tonLeaveBack = ParamConfig.BOOLEAN(0, UPDATE_SCROLL_TRIGGER_PARAM_OPTIONS);\n}\nconst ParamsConfig = new ScrollTriggerParamsConfig();\n\nexport class ScrollTriggerEventNode extends TypedEventNode<ScrollTriggerParamsConfig> {\n\toverride paramsConfig = ParamsConfig;\n\tpublic gsap = gsapLib(); // give access to gsap to external scripts\n\tpublic ScrollTrigger = ScrollTrigger; // give access to ScrollTrigger to external scripts\n\tstatic override type() {\n\t\treturn 'scrollTrigger';\n\t}\n\toverride requiredModules() {\n\t\treturn [ModuleName.GSAP];\n\t}\n\n\toverride dispose() {\n\t\tthis._disposeScrollTrigger();\n\t\tsuper.dispose();\n\t}\n\n\toverride initializeNode() {\n\t\tthis.io.inputs.setNamedInputConnectionPoints([\n\t\t\tnew EventConnectionPoint(\n\t\t\t\tScrollTriggerNodeInput.CREATE,\n\t\t\t\tEventConnectionPointType.BASE,\n\t\t\t\tthis._onCreateTrigger.bind(this)\n\t\t\t),\n\t\t\tnew EventConnectionPoint(\n\t\t\t\tScrollTriggerNodeInput.DISPOSE,\n\t\t\t\tEventConnectionPointType.BASE,\n\t\t\t\tthis._onDisposeTrigger.bind(this)\n\t\t\t),\n\t\t]);\n\t\tthis.io.outputs.setNamedOutputConnectionPoints([\n\t\t\tnew EventConnectionPoint(ScrollTriggerNodeOutput.TOGGLE, EventConnectionPointType.BASE),\n\t\t\tnew EventConnectionPoint(ScrollTriggerNodeOutput.ENTER, EventConnectionPointType.BASE),\n\t\t\tnew EventConnectionPoint(ScrollTriggerNodeOutput.LEAVE, EventConnectionPointType.BASE),\n\t\t\tnew EventConnectionPoint(ScrollTriggerNodeOutput.ENTER_BACK, EventConnectionPointType.BASE),\n\t\t\tnew EventConnectionPoint(ScrollTriggerNodeOutput.LEAVE_BACK, EventConnectionPointType.BASE),\n\t\t]);\n\t}\n\tprivate _scrollTrigger: globalThis.ScrollTrigger | undefined;\n\tprivate _onCreateTrigger(eventContext: EventContext<Event>) {\n\t\tthis._disposeScrollTrigger();\n\n\t\tif (!isBooleanTrue(this.pv.active)) {\n\t\t\treturn;\n\t\t}\n\t\tthis.states.error.clear();\n\n\t\tconst element = this._querySelector(this.pv.element);\n\t\tif (!element) {\n\t\t\treturn;\n\t\t}\n\n\t\t// If the scroller element is not found, this function returns undefined,\n\t\t// and then the scroll container will be assumed to be the window by gsap.\n\t\t// This can be handy in cases where we want to use a container in the editor,\n\t\t// but want to use the window once deployed\n\t\tconst _getScroller = () => {\n\t\t\tif (isBooleanTrue(this.pv.useViewport)) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tconst scrollerElement = this._querySelector(this.pv.scroller);\n\t\t\tif (!scrollerElement) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\treturn scrollerElement;\n\t\t};\n\n\t\tconst options: ScrollTrigger.StaticVars = {\n\t\t\ttrigger: element,\n\t\t\tscroller: _getScroller(),\n\t\t\tmarkers: this.pv.markers,\n\t\t\tid: this.path(),\n\t\t};\n\t\tif (isBooleanTrue(this.pv.tinsideElement) || isBooleanTrue(this.pv.onToggle)) {\n\t\t\tconst updateInside = (scrollTrigger: globalThis.ScrollTrigger) =>\n\t\t\t\tthis.p.insideElement.set(scrollTrigger.isActive);\n\t\t\tconst dispatchOnToggle = (scrollTrigger: globalThis.ScrollTrigger) =>\n\t\t\t\tthis.dispatchEventToOutput(ScrollTriggerNodeOutput.TOGGLE, {});\n\t\t\tconst functions: Array<(scrollTrigger: globalThis.ScrollTrigger) => void> = [];\n\t\t\tif (isBooleanTrue(this.pv.tinsideElement)) {\n\t\t\t\tfunctions.push(updateInside);\n\t\t\t}\n\t\t\tif (isBooleanTrue(this.pv.onToggle)) {\n\t\t\t\tfunctions.push(dispatchOnToggle);\n\t\t\t}\n\t\t\toptions.onToggle = (scrollTrigger) => {\n\t\t\t\tfor (const func of functions) {\n\t\t\t\t\tfunc(scrollTrigger);\n\t\t\t\t}\n\t\t\t};\n\t\t}\n\t\tif (isBooleanTrue(this.pv.onEnter)) {\n\t\t\toptions.onEnter = () => this.dispatchEventToOutput(ScrollTriggerNodeOutput.ENTER, {});\n\t\t}\n\t\tif (isBooleanTrue(this.pv.onLeave)) {\n\t\t\toptions.onLeave = () => this.dispatchEventToOutput(ScrollTriggerNodeOutput.LEAVE, {});\n\t\t}\n\t\tif (isBooleanTrue(this.pv.onEnterBack)) {\n\t\t\toptions.onEnterBack = () => this.dispatchEventToOutput(ScrollTriggerNodeOutput.ENTER_BACK, {});\n\t\t}\n\t\tif (isBooleanTrue(this.pv.onLeaveBack)) {\n\t\t\toptions.onLeaveBack = () => this.dispatchEventToOutput(ScrollTriggerNodeOutput.LEAVE_BACK, {});\n\t\t}\n\n\t\tif (isBooleanTrue(this.pv.tprogress)) {\n\t\t\toptions.onUpdate = (scrollTrigger) => {\n\t\t\t\tthis.p.progress.set(scrollTrigger.progress);\n\t\t\t};\n\t\t}\n\n\t\tthis._scrollTrigger = ScrollTrigger.create(options);\n\t}\n\tprivate _updateScrollTrigger() {\n\t\tif (!this._scrollTrigger) {\n\t\t\treturn;\n\t\t}\n\t\tthis._onCreateTrigger({});\n\t}\n\n\tprivate _onDisposeTrigger(eventContext: EventContext<Event>) {\n\t\tthis._disposeScrollTrigger();\n\t}\n\n\tprivate _disposeScrollTrigger() {\n\t\tif (!this._scrollTrigger) {\n\t\t\treturn;\n\t\t}\n\t\tthis._scrollTrigger.kill();\n\t}\n\tprivate _querySelector(selector: string) {\n\t\tconst element = document.querySelector(selector);\n\t\tif (!element) {\n\t\t\tthis.states.error.set(`element with selector '${selector}' not found`);\n\t\t\treturn;\n\t\t}\n\t\treturn element;\n\t}\n\n\tstatic PARAM_CALLBACK_updateScrollTrigger(node: ScrollTriggerEventNode) {\n\t\tnode._updateScrollTrigger();\n\t}\n}\n","/**\n * Updates the param of specific node\n *\n *\n *\n */\nimport {Number2, Number3, Number4} from '../../../types/GlobalTypes';\nimport {NodeParamsConfig, ParamConfig} from '../utils/params/ParamsConfig';\nimport {TypedEventNode} from './_Base';\nimport {EventContext} from '../../scene/utils/events/_BaseEventsController';\nimport {TypeAssert} from '../../poly/Assert';\nimport {BaseParamType} from '../../params/_Base';\nimport {ParamType} from '../../poly/ParamType';\nimport {FloatParam} from '../../params/Float';\nimport {Vector2Param} from '../../params/Vector2';\nimport {Vector3Param} from '../../params/Vector3';\nimport {Vector4Param} from '../../params/Vector4';\nimport {EventConnectionPoint, EventConnectionPointType} from '../utils/io/connections/Event';\nimport {BaseNodeType} from '../_Base';\nimport {Vector2} from 'three';\nimport {Vector3} from 'three';\nimport {Vector4} from 'three';\nimport {IntegerParam} from '../../params/Integer';\nimport {isBooleanTrue} from '../../../core/BooleanValue';\n\nexport enum SetParamParamType {\n\tBOOLEAN = 'boolean',\n\tBUTTON = 'button',\n\tNUMBER = 'number',\n\tVECTOR2 = 'vector2',\n\tVECTOR3 = 'vector3',\n\tVECTOR4 = 'vector4',\n\tSTRING = 'string',\n}\nconst SET_PARAM_PARAM_TYPE: Array<SetParamParamType> = [\n\tSetParamParamType.BOOLEAN,\n\tSetParamParamType.BUTTON,\n\tSetParamParamType.NUMBER,\n\tSetParamParamType.VECTOR2,\n\tSetParamParamType.VECTOR3,\n\tSetParamParamType.VECTOR4,\n\tSetParamParamType.STRING,\n];\nconst TYPE_BOOLEAN = SET_PARAM_PARAM_TYPE.indexOf(SetParamParamType.BOOLEAN);\n// const TYPE_BUTTON = SET_PARAM_PARAM_TYPE.indexOf(SetParamParamType.BUTTON);\nconst TYPE_NUMBER = SET_PARAM_PARAM_TYPE.indexOf(SetParamParamType.NUMBER);\nconst TYPE_VECTOR2 = SET_PARAM_PARAM_TYPE.indexOf(SetParamParamType.VECTOR2);\nconst TYPE_VECTOR3 = SET_PARAM_PARAM_TYPE.indexOf(SetParamParamType.VECTOR3);\nconst TYPE_VECTOR4 = SET_PARAM_PARAM_TYPE.indexOf(SetParamParamType.VECTOR4);\nconst TYPE_STRING = SET_PARAM_PARAM_TYPE.indexOf(SetParamParamType.STRING);\n\nfunction valueParamOptions() {\n\treturn {cook: false};\n}\n\nconst OUTPUT_NAME = 'output';\nclass SetParamParamsConfig extends NodeParamsConfig {\n\t/** @param the parameter to update */\n\tparam = ParamConfig.PARAM_PATH('', {\n\t\tdependentOnFoundParam: false,\n\t\tparamSelection: true,\n\t\tcomputeOnDirty: true,\n\t});\n\t// param = ParamConfig.STRING('display');\n\t/** @param type of the parameter to update */\n\ttype = ParamConfig.INTEGER(TYPE_NUMBER, {\n\t\tmenu: {\n\t\t\tentries: SET_PARAM_PARAM_TYPE.map((name, value) => {\n\t\t\t\treturn {name, value};\n\t\t\t}),\n\t\t},\n\t});\n\t/** @param for a boolean parameter, sets to toggle its value */\n\ttoggle = ParamConfig.BOOLEAN(0, {\n\t\tvisibleIf: {type: TYPE_BOOLEAN},\n\t});\n\t/** @param if toggle is set to off, this will set the value of the parameter */\n\tboolean = ParamConfig.BOOLEAN(0, {\n\t\tvisibleIf: {\n\t\t\ttype: TYPE_BOOLEAN,\n\t\t\ttoggle: 0,\n\t\t},\n\t\t...valueParamOptions(),\n\t});\n\t/** @param param value for a float parameter */\n\tnumber = ParamConfig.FLOAT(0, {\n\t\tvisibleIf: {type: TYPE_NUMBER},\n\t\t...valueParamOptions(),\n\t});\n\t/** @param param value for a vector2 parameter */\n\tvector2 = ParamConfig.VECTOR2([0, 0], {\n\t\tvisibleIf: {type: TYPE_VECTOR2},\n\t\t...valueParamOptions(),\n\t});\n\t/** @param param value for a vector3 parameter */\n\tvector3 = ParamConfig.VECTOR3([0, 0, 0], {\n\t\tvisibleIf: {type: TYPE_VECTOR3},\n\t\t...valueParamOptions(),\n\t});\n\t/** @param param value for a vector4 parameter */\n\tvector4 = ParamConfig.VECTOR4([0, 0, 0, 0], {\n\t\tvisibleIf: {type: TYPE_VECTOR4},\n\t\t...valueParamOptions(),\n\t});\n\t/** @param if on, the value will be incremented by the value, as opposed to be set to the value */\n\tincrement = ParamConfig.BOOLEAN(0, {\n\t\tvisibleIf: [{type: TYPE_NUMBER}, {type: TYPE_VECTOR2}, {type: TYPE_VECTOR3}, {type: TYPE_VECTOR4}],\n\t\t...valueParamOptions(),\n\t});\n\t/** @param param value for a string parameter */\n\tstring = ParamConfig.STRING('', {\n\t\tvisibleIf: {type: TYPE_STRING},\n\t\t...valueParamOptions(),\n\t});\n\t/** @param execute button to test the node */\n\texecute = ParamConfig.BUTTON(null, {\n\t\tcallback: (node: BaseNodeType) => {\n\t\t\tSetParamEventNode.PARAM_CALLBACK_execute(node as SetParamEventNode);\n\t\t},\n\t});\n}\nconst ParamsConfig = new SetParamParamsConfig();\n\nexport class SetParamEventNode extends TypedEventNode<SetParamParamsConfig> {\n\toverride paramsConfig = ParamsConfig;\n\tstatic override type() {\n\t\treturn 'setParam';\n\t}\n\toverride initializeNode() {\n\t\tthis.io.inputs.setNamedInputConnectionPoints([\n\t\t\tnew EventConnectionPoint('trigger', EventConnectionPointType.BASE),\n\t\t]);\n\t\tthis.io.outputs.setNamedOutputConnectionPoints([\n\t\t\tnew EventConnectionPoint(OUTPUT_NAME, EventConnectionPointType.BASE),\n\t\t]);\n\t}\n\tsetParamType(paramType: SetParamParamType) {\n\t\tconst index = SET_PARAM_PARAM_TYPE.indexOf(paramType);\n\t\tthis.p.type.set(index);\n\t}\n\n\toverride async processEvent(event_context: EventContext<Event>) {\n\t\tif (this.p.param.isDirty()) {\n\t\t\t// TODO: investigate occasions\n\t\t\t// where the referenced param is recomputed\n\t\t\t// (such as in a material builder)\n\t\t\t// and this node refers to an old param\n\t\t\tawait this.p.param.compute();\n\t\t}\n\t\tconst param = this.p.param.value.param();\n\n\t\tif (param) {\n\t\t\tconst newValue = await this._newParamValue(param);\n\t\t\tif (newValue != null) {\n\t\t\t\tparam.set(newValue);\n\t\t\t}\n\t\t} else {\n\t\t\tthis.states.error.set('target param not found');\n\t\t}\n\n\t\tthis.dispatchEventToOutput(OUTPUT_NAME, event_context);\n\t}\n\n\tprivate _tmp_vector2 = new Vector2();\n\tprivate _tmp_vector3 = new Vector3();\n\tprivate _tmp_vector4 = new Vector4();\n\tprivate _tmp_array2: Number2 = [0, 0];\n\tprivate _tmp_array3: Number3 = [0, 0, 0];\n\tprivate _tmp_array4: Number4 = [0, 0, 0, 0];\n\tprivate async _newParamValue(param: BaseParamType) {\n\t\tconst type = SET_PARAM_PARAM_TYPE[this.pv.type];\n\t\tswitch (type) {\n\t\t\tcase SetParamParamType.BOOLEAN: {\n\t\t\t\tawait this._computeParamsIfDirty([this.p.toggle]);\n\t\t\t\t// use 1 and 0, so we can also use it on integer params, such as for a switch node\n\t\t\t\tif (isBooleanTrue(this.pv.toggle)) {\n\t\t\t\t\treturn param.value ? 0 : 1;\n\t\t\t\t} else {\n\t\t\t\t\treturn isBooleanTrue(this.pv.boolean) ? 1 : 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcase SetParamParamType.BUTTON: {\n\t\t\t\treturn param.options.executeCallback();\n\t\t\t}\n\t\t\tcase SetParamParamType.NUMBER: {\n\t\t\t\tawait this._computeParamsIfDirty([this.p.increment, this.p.number]);\n\t\t\t\tif (isBooleanTrue(this.pv.increment)) {\n\t\t\t\t\tif (param.type() == ParamType.FLOAT) {\n\t\t\t\t\t\treturn (param as FloatParam).value + this.pv.number;\n\t\t\t\t\t} else {\n\t\t\t\t\t\treturn (param as IntegerParam).value;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\treturn this.pv.number;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcase SetParamParamType.VECTOR2: {\n\t\t\t\tawait this._computeParamsIfDirty([this.p.increment, this.p.vector2]);\n\t\t\t\tif (isBooleanTrue(this.pv.increment)) {\n\t\t\t\t\tif (param.type() == ParamType.VECTOR2) {\n\t\t\t\t\t\tthis._tmp_vector2.copy((param as Vector2Param).value);\n\t\t\t\t\t\tthis._tmp_vector2.add(this.pv.vector2);\n\t\t\t\t\t\tthis._tmp_vector2.toArray(this._tmp_array2);\n\t\t\t\t\t} else {\n\t\t\t\t\t\t(param as Vector2Param).value.toArray(this._tmp_array2);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tthis.pv.vector2.toArray(this._tmp_array2);\n\t\t\t\t}\n\t\t\t\treturn this._tmp_array2;\n\t\t\t}\n\t\t\tcase SetParamParamType.VECTOR3: {\n\t\t\t\tawait this._computeParamsIfDirty([this.p.increment, this.p.vector3]);\n\t\t\t\tif (isBooleanTrue(this.pv.increment)) {\n\t\t\t\t\tif (param.type() == ParamType.VECTOR3) {\n\t\t\t\t\t\tthis._tmp_vector3.copy((param as Vector3Param).value);\n\t\t\t\t\t\tthis._tmp_vector3.add(this.pv.vector3);\n\t\t\t\t\t\tthis._tmp_vector3.toArray(this._tmp_array3);\n\t\t\t\t\t} else {\n\t\t\t\t\t\t(param as Vector3Param).value.toArray(this._tmp_array3);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tthis.pv.vector3.toArray(this._tmp_array3);\n\t\t\t\t}\n\t\t\t\treturn this._tmp_array3;\n\t\t\t}\n\t\t\tcase SetParamParamType.VECTOR4: {\n\t\t\t\tawait this._computeParamsIfDirty([this.p.increment, this.p.vector4]);\n\t\t\t\tif (isBooleanTrue(this.pv.increment)) {\n\t\t\t\t\tif (param.type() == ParamType.VECTOR4) {\n\t\t\t\t\t\tthis._tmp_vector4.copy((param as Vector4Param).value);\n\t\t\t\t\t\tthis._tmp_vector4.add(this.pv.vector4);\n\t\t\t\t\t\tthis._tmp_vector4.toArray(this._tmp_array4);\n\t\t\t\t\t} else {\n\t\t\t\t\t\t(param as Vector4Param).value.toArray(this._tmp_array4);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tthis.pv.vector4.toArray(this._tmp_array4);\n\t\t\t\t}\n\t\t\t\treturn this._tmp_array4;\n\t\t\t}\n\t\t\tcase SetParamParamType.STRING: {\n\t\t\t\tawait this._computeParamsIfDirty([this.p.string]);\n\t\t\t\treturn this.pv.string;\n\t\t\t}\n\t\t}\n\t\tTypeAssert.unreachable(type);\n\t}\n\n\tstatic PARAM_CALLBACK_execute(node: SetParamEventNode) {\n\t\tnode.processEvent({});\n\t}\n\n\tprivate async _computeParamsIfDirty(params: BaseParamType[]) {\n\t\tconst dirty_params = [];\n\t\tfor (const param of params) {\n\t\t\tif (param.isDirty()) {\n\t\t\t\tdirty_params.push(param);\n\t\t\t}\n\t\t}\n\t\tconst promises: Promise<void>[] = [];\n\t\tfor (const param of dirty_params) {\n\t\t\tpromises.push(param.compute());\n\t\t}\n\t\treturn await Promise.all(promises);\n\t}\n}\n","/**\n * Allows to trigger touch events.\n *\n *\n */\nimport {EventConnectionPoint, EventConnectionPointType} from '../utils/io/connections/Event';\nimport {BaseNodeType} from '../_Base';\nimport {NodeParamsConfig, ParamConfig} from '../utils/params/ParamsConfig';\nimport {TypedInputEventNode, EVENT_PARAM_OPTIONS} from './_BaseInput';\nimport {EventContext} from '../../scene/utils/events/_BaseEventsController';\nimport {EventInputType} from '../../poly/registers/nodes/types/Event';\nimport {CoreEventEmitter, EVENT_EMITTERS, EVENT_EMITTER_PARAM_MENU_OPTIONS} from '../../../core/event/CoreEventEmitter';\nimport {ACCEPTED_TOUCH_EVENT_TYPES} from '../../../core/event/TouchEventType';\nclass TouchEventParamsConfig extends NodeParamsConfig {\n\t/** @param toggle on to allow any event to be listened to */\n\tactive = ParamConfig.BOOLEAN(true, {\n\t\tcallback: (node: BaseNodeType) => {\n\t\t\tTouchEventNode.PARAM_CALLBACK_updateRegister(node as TouchEventNode);\n\t\t},\n\t\tseparatorAfter: true,\n\t});\n\t/** @param set which element triggers the event */\n\telement = ParamConfig.INTEGER(EVENT_EMITTERS.indexOf(CoreEventEmitter.CANVAS), {\n\t\t...EVENT_EMITTER_PARAM_MENU_OPTIONS,\n\t\tseparatorAfter: true,\n\t});\n\n\t/** @param toggle on to listen to touchstart events */\n\ttouchstart = ParamConfig.BOOLEAN(1, EVENT_PARAM_OPTIONS);\n\t/** @param toggle on to listen to touchmove events */\n\ttouchmove = ParamConfig.BOOLEAN(0, EVENT_PARAM_OPTIONS);\n\t/** @param toggle on to listen to touchend events */\n\ttouchend = ParamConfig.BOOLEAN(0, EVENT_PARAM_OPTIONS);\n}\nconst ParamsConfig = new TouchEventParamsConfig();\n\nexport class TouchEventNode extends TypedInputEventNode<TouchEventParamsConfig> {\n\toverride paramsConfig = ParamsConfig;\n\tstatic override type() {\n\t\treturn EventInputType.TOUCH;\n\t}\n\tprotected acceptedEventTypes() {\n\t\treturn new Set([...ACCEPTED_TOUCH_EVENT_TYPES]);\n\t}\n\toverride initializeNode() {\n\t\tthis.io.outputs.setNamedOutputConnectionPoints(\n\t\t\tACCEPTED_TOUCH_EVENT_TYPES.map((event_type) => {\n\t\t\t\treturn new EventConnectionPoint(event_type, EventConnectionPointType.DRAG);\n\t\t\t})\n\t\t);\n\t}\n\toverride processEvent(eventContext: EventContext<TouchEvent>) {\n\t\tif (!this.pv.active) {\n\t\t\treturn;\n\t\t}\n\t\tif (!eventContext.event) {\n\t\t\treturn;\n\t\t}\n\t\tconst event = eventContext.event;\n\t\tif (!event) {\n\t\t\treturn;\n\t\t}\n\t\tthis.dispatchEventToOutput(event.type, eventContext);\n\t}\n}\n","/**\n * Allows to trigger window events.\n *\n *\n */\nimport {EventConnectionPoint, EventConnectionPointType} from '../utils/io/connections/Event';\nimport {BaseNodeType} from '../_Base';\nimport {NodeParamsConfig, ParamConfig} from '../utils/params/ParamsConfig';\nimport {TypedInputEventNode, EVENT_PARAM_OPTIONS} from './_BaseInput';\nimport {EventContext} from '../../scene/utils/events/_BaseEventsController';\nimport {EventInputType} from '../../poly/registers/nodes/types/Event';\nimport {ACCEPTED_WINDOW_EVENT_TYPES} from '../../../core/event/WindowEventType';\nclass WindowEventParamsConfig extends NodeParamsConfig {\n\t/** @param toggle on to allow any event to be listened to */\n\tactive = ParamConfig.BOOLEAN(true, {\n\t\tcallback: (node: BaseNodeType) => {\n\t\t\tWindowEventNode.PARAM_CALLBACK_updateRegister(node as WindowEventNode);\n\t\t},\n\t\tseparatorAfter: true,\n\t});\n\t/** @param set which element triggers the event */\n\telement = ParamConfig.INTEGER(0, {\n\t\thidden: true,\n\t});\n\t/** @param toggle on to listen to resize events */\n\tresize = ParamConfig.BOOLEAN(1, EVENT_PARAM_OPTIONS);\n}\nconst ParamsConfig = new WindowEventParamsConfig();\n\nexport class WindowEventNode extends TypedInputEventNode<WindowEventParamsConfig> {\n\toverride paramsConfig = ParamsConfig;\n\tstatic override type() {\n\t\treturn EventInputType.WINDOW;\n\t}\n\tprotected acceptedEventTypes() {\n\t\treturn new Set([...ACCEPTED_WINDOW_EVENT_TYPES]);\n\t}\n\toverride initializeNode() {\n\t\tthis.io.outputs.setNamedOutputConnectionPoints(\n\t\t\tACCEPTED_WINDOW_EVENT_TYPES.map((event_type) => {\n\t\t\t\treturn new EventConnectionPoint(event_type, EventConnectionPointType.POINTER);\n\t\t\t})\n\t\t);\n\t}\n\toverride processEvent(eventContext: EventContext<Event>) {\n\t\tif (!this.pv.active) {\n\t\t\treturn;\n\t\t}\n\t\tconst event = eventContext.event;\n\t\tif (!event) {\n\t\t\treturn;\n\t\t}\n\t\tthis.dispatchEventToOutput(event.type, eventContext);\n\t}\n}\n","import {TypedEventNode} from './_Base';\nimport {EventContext} from '../../scene/utils/events/_BaseEventsController';\nimport {NodeParamsConfig, ParamConfig} from '../utils/params/ParamsConfig';\nimport {ParamOptions} from '../../params/utils/OptionsController';\nimport {BaseNodeType} from '../_Base';\nimport {EVENT_EMITTERS, EVENT_EMITTER_PARAM_MENU_OPTIONS} from '../../../core/event/CoreEventEmitter';\nimport {EventData, EventType} from '../../../core/event/EventData';\n\nexport const EVENT_PARAM_OPTIONS: ParamOptions = {\n\tvisibleIf: {active: 1},\n\tcallback: (node: BaseNodeType) => {\n\t\tBaseInputEventNodeClass.PARAM_CALLBACK_updateRegister(node as BaseInputEventNodeType);\n\t},\n};\n\nexport abstract class TypedInputEventNode<K extends BaseInputEventParamsConfig> extends TypedEventNode<K> {\n\toverride initializeBaseNode() {\n\t\tsuper.initializeBaseNode();\n\n\t\tconst register = () => {\n\t\t\tthis.scene().eventsDispatcher.registerEventNode(this);\n\t\t};\n\t\tconst unregister = () => {\n\t\t\tthis.scene().eventsDispatcher.unregisterEventNode(this);\n\t\t};\n\t\tthis.lifecycle.onAfterAdded(register);\n\t\t// this.lifecycle.add_on_creation_completed_hook(register);\n\t\tthis.lifecycle.onBeforeDeleted(unregister);\n\n\t\tthis.params.onParamsCreated('update_register', () => {\n\t\t\tthis._updateRegister();\n\t\t});\n\t}\n\n\toverride processEvent(eventContext: EventContext<Event>) {\n\t\tif (!this.pv.active) {\n\t\t\treturn;\n\t\t}\n\t\tif (!eventContext.event) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis.dispatchEventToOutput(eventContext.event.type, eventContext);\n\t}\n\n\tstatic PARAM_CALLBACK_updateRegister(node: BaseInputEventNodeType) {\n\t\tnode._updateRegister();\n\t}\n\tprivate _updateRegister() {\n\t\tthis._updateActiveEventDatas();\n\t\tthis.scene().eventsDispatcher.updateViewerEventListeners(this);\n\t}\n\n\tprivate _activeEventDatas: EventData[] = [];\n\tprivate _updateActiveEventDatas() {\n\t\tthis._activeEventDatas = [];\n\t\tif (this.pv.active) {\n\t\t\tconst list = this.acceptedEventTypes();\n\t\t\tlist.forEach((name) => {\n\t\t\t\tconst param = this.params.get(name);\n\t\t\t\tif (param && param.value) {\n\t\t\t\t\tthis._activeEventDatas.push({type: name, emitter: EVENT_EMITTERS[this.pv.element]});\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t}\n\tprotected abstract acceptedEventTypes(): Set<EventType>;\n\tactiveEventDatas() {\n\t\treturn this._activeEventDatas;\n\t}\n}\n\nclass BaseInputEventParamsConfig extends NodeParamsConfig {\n\tactive = ParamConfig.BOOLEAN(true);\n\t/** @param set which element triggers the event */\n\telement = ParamConfig.INTEGER(0, {\n\t\t...EVENT_EMITTER_PARAM_MENU_OPTIONS,\n\t\tseparatorAfter: true,\n\t});\n}\n\nexport type BaseInputEventNodeType = TypedInputEventNode<BaseInputEventParamsConfig>;\nexport class BaseInputEventNodeClass extends TypedInputEventNode<BaseInputEventParamsConfig> {\n\tacceptedEventTypes() {\n\t\treturn new Set<EventType>();\n\t}\n}\n","import {NodeContext} from '../../poly/NodeContext';\nimport {NodeParamsConfig} from '../utils/params/ParamsConfig';\nimport {TypedNode} from '../_Base';\n\nclass ParamLessNetworkEventParamsConfig extends NodeParamsConfig {}\nexport class BaseNetworkEventNode<K extends NodeParamsConfig> extends TypedNode<NodeContext.EVENT, K> {\n\tstatic override context(): NodeContext {\n\t\treturn NodeContext.EVENT;\n\t}\n\toverride cook() {\n\t\tthis.cookController.endCook();\n\t}\n}\nexport class ParamLessBaseNetworkEventNode extends BaseNetworkEventNode<ParamLessNetworkEventParamsConfig> {}\n","import {Constructor} from '../../../../types/GlobalTypes';\nimport {TypedEventNode} from '../_Base';\nimport {NodeParamsConfig, ParamConfig} from '../../utils/params/ParamsConfig';\nimport {NodeContext} from '../../../poly/NodeContext';\nimport {BaseSopNodeType} from '../../sop/_Base';\nimport {CoreGraphNode} from '../../../../core/graph/CoreGraphNode';\nimport {CorePlayer} from '../../../../core/player/Player';\nimport {BaseNodeType} from '../../_Base';\nimport {MeshWithBVH} from '../../../../core/geometry/bvh/three-mesh-bvh';\n\nexport function ColliderParamConfig<TBase extends Constructor>(Base: TBase) {\n\treturn class Mixin extends Base {\n\t\tcolliderObject = ParamConfig.NODE_PATH('', {\n\t\t\tnodeSelection: {\n\t\t\t\tcontext: NodeContext.SOP,\n\t\t\t},\n\t\t\t// if the node is dependent,\n\t\t\t// the FirstPersonControls will be re-created when this node changes\n\t\t\t// which we do not want, as it will act like a hard reset\n\t\t\t// when all we want is to update the collider\n\t\t\tdependentOnFoundNode: false,\n\t\t\tcallback: (node: BaseNodeType) => {\n\t\t\t\tColliderEventNode.PARAM_CALLBACK_updateCollider(node as ColliderEventNode);\n\t\t\t},\n\t\t});\n\t};\n}\n\nclass ColliderParamsConfig extends ColliderParamConfig(NodeParamsConfig) {}\nabstract class ColliderEventNode extends TypedEventNode<ColliderParamsConfig> {\n\tabstract player(): CorePlayer | undefined;\n\tabstract collisionController(): CollisionController;\n\tstatic PARAM_CALLBACK_updateCollider(node: ColliderEventNode) {}\n}\n\nexport class CollisionController {\n\tconstructor(protected node: ColliderEventNode) {}\n\tprivate _colliderNode: BaseSopNodeType | undefined;\n\tprivate __colliderNodeGraphNode: CoreGraphNode | undefined;\n\tprivate _colliderNodeGraphNode() {\n\t\treturn (this.__colliderNodeGraphNode =\n\t\t\tthis.__colliderNodeGraphNode || new CoreGraphNode(this.node.scene(), 'colliderGraphNode'));\n\t}\n\tasync getCollider() {\n\t\tconst colliderNode = this.node.pv.colliderObject.nodeWithContext(NodeContext.SOP);\n\t\tif (!colliderNode) {\n\t\t\tthis.node.states.error.set('collider node not found');\n\t\t\treturn;\n\t\t}\n\t\tif (this._colliderNode?.graphNodeId() != colliderNode.graphNodeId()) {\n\t\t\tif (this._colliderNode) {\n\t\t\t\tthis._colliderNodeGraphNode().removeGraphInput(this._colliderNode);\n\t\t\t}\n\t\t\tthis._colliderNodeGraphNode().addGraphInput(colliderNode);\n\t\t\tthis._colliderNodeGraphNode().addPostDirtyHook('onColliderDirty', () => {\n\t\t\t\tthis.updateCollider();\n\t\t\t});\n\t\t\tthis._colliderNode = colliderNode;\n\t\t}\n\t\tconst container = await colliderNode.compute();\n\t\tconst coreGroup = container.coreContent();\n\t\tif (!coreGroup) {\n\t\t\tthis.node.states.error.set('invalid collider node');\n\t\t\treturn;\n\t\t}\n\n\t\tconst collider = coreGroup.threejsObjects()[0] as MeshWithBVH;\n\t\treturn collider;\n\t}\n\n\tasync updateCollider() {\n\t\tconst collider = await this.getCollider();\n\t\tif (!collider) {\n\t\t\tthis.node.states.error.set('invalid collider');\n\t\t\treturn;\n\t\t}\n\n\t\tthis.node.player()?.setCollider(collider);\n\t}\n}\n","/**\n * applies a color correction\n *\n *\n */\n\nimport {TypedGlNode} from './_Base';\nimport {GlConnectionPointType, GlConnectionPoint} from '../utils/io/connections/Gl';\nimport {ShadersCollectionController} from './code/utils/ShadersCollectionController';\nimport {ThreeToGl} from '../../../core/ThreeToGl';\nimport ColorGlslLib from './gl/color.glsl';\n\nexport enum ColorCorrectType {\n\tLINEAR = 'Linear',\n\tSRGB = 'sRGB',\n}\nconst TYPES: Array<ColorCorrectType> = [ColorCorrectType.LINEAR, ColorCorrectType.SRGB];\n\nimport {ParamConfig, NodeParamsConfig} from '../utils/params/ParamsConfig';\nimport {FunctionGLDefinition} from './utils/GLDefinition';\n\nclass ColorCorrectParamsConfig extends NodeParamsConfig {\n\tcolor = ParamConfig.VECTOR4([1, 1, 1, 1]);\n\tfrom = ParamConfig.INTEGER(TYPES.indexOf(ColorCorrectType.LINEAR), {\n\t\tmenu: {\n\t\t\tentries: TYPES.map((type, i) => {\n\t\t\t\treturn {name: type, value: i};\n\t\t\t}),\n\t\t},\n\t});\n\tto = ParamConfig.INTEGER(TYPES.indexOf(ColorCorrectType.SRGB), {\n\t\tmenu: {\n\t\t\tentries: TYPES.map((type, i) => {\n\t\t\t\treturn {name: type, value: i};\n\t\t\t}),\n\t\t},\n\t});\n}\n\nconst ParamsConfig = new ColorCorrectParamsConfig();\nexport class ColorCorrectGlNode extends TypedGlNode<ColorCorrectParamsConfig> {\n\toverride paramsConfig = ParamsConfig;\n\tstatic override type() {\n\t\treturn 'colorCorrect';\n\t}\n\tstatic INPUT_NAME = 'color';\n\tstatic OUTPUT_NAME = 'out';\n\toverride initializeNode() {\n\t\tthis.io.connection_points.spare_params.setInputlessParamNames(['to', 'from']);\n\t\tthis.io.outputs.setNamedOutputConnectionPoints([\n\t\t\tnew GlConnectionPoint(ColorCorrectGlNode.OUTPUT_NAME, GlConnectionPointType.VEC4),\n\t\t]);\n\t}\n\tcolorSpaces() {\n\t\treturn {\n\t\t\tfrom: TYPES[this.pv.from],\n\t\t\tto: TYPES[this.pv.to],\n\t\t};\n\t}\n\n\toverride setLines(shaders_collection_controller: ShadersCollectionController) {\n\t\tconst {from, to} = this.colorSpaces();\n\t\tconst out = this.glVarName(ColorCorrectGlNode.OUTPUT_NAME);\n\t\tconst arg_in = ThreeToGl.any(this.variableForInput(ColorCorrectGlNode.INPUT_NAME));\n\t\tconst body_lines: string[] = [];\n\t\tif (from != to) {\n\t\t\tconst method_name = `${from}To${to}`;\n\t\t\tconst args: string[] = [];\n\t\t\targs.push(arg_in);\n\n\t\t\tbody_lines.push(`vec4 ${out} = ${method_name}(${args.join(', ')})`);\n\t\t} else {\n\t\t\tbody_lines.push(`vec4 ${out} = ${arg_in}`);\n\t\t}\n\t\tshaders_collection_controller.addBodyLines(this, body_lines);\n\t\tshaders_collection_controller.addDefinitions(this, [new FunctionGLDefinition(this, ColorGlslLib)]);\n\t}\n}\n","/**\n * compares 2 input values and generates a boolean value\n *\n * @remarks\n *\n * This node is frequently used with the [gl/TwoWaySwitch](/docs/nodes/gl/TwoWaySwitch)\n *\n */\n\nimport {TypedGlNode} from './_Base';\nimport {ThreeToGl} from '../../../../src/core/ThreeToGl';\nimport {ParamConfig, NodeParamsConfig} from '../utils/params/ParamsConfig';\nimport {ShadersCollectionController} from './code/utils/ShadersCollectionController';\nimport {GlConnectionPointType, GlConnectionPointComponentsCountMap} from '../utils/io/connections/Gl';\n// import {GlConnectionsController} from './utils/GLConnectionsController';\n\nexport enum GlCompareTestName {\n\tEQUAL = 'Equal',\n\tLESS_THAN = 'Less Than',\n\tGREATER_THAN = 'Greater Than',\n\tLESS_THAN_OR_EQUAL = 'Less Than Or Equal',\n\tGREATER_THAN_OR_EQUAL = 'Greater Than Or Equal',\n\tNOT_EQUAL = 'Not Equal',\n}\nenum GlCompareTestOperation {\n\tEQUAL = '==',\n\tLESS_THAN = '<',\n\tGREATER_THAN = '>',\n\tLESS_THAN_OR_EQUAL = '<=',\n\tGREATER_THAN_OR_EQUAL = '>=',\n\tNOT_EQUAL = '!=',\n}\n\nconst TEST_NAMES: GlCompareTestName[] = [\n\tGlCompareTestName.EQUAL,\n\tGlCompareTestName.LESS_THAN,\n\tGlCompareTestName.GREATER_THAN,\n\tGlCompareTestName.LESS_THAN_OR_EQUAL,\n\tGlCompareTestName.GREATER_THAN_OR_EQUAL,\n\tGlCompareTestName.NOT_EQUAL,\n];\nconst TEST_OPERATIONS_FLOAT: GlCompareTestOperation[] = [\n\tGlCompareTestOperation.EQUAL,\n\tGlCompareTestOperation.LESS_THAN,\n\tGlCompareTestOperation.GREATER_THAN,\n\tGlCompareTestOperation.LESS_THAN_OR_EQUAL,\n\tGlCompareTestOperation.GREATER_THAN_OR_EQUAL,\n\tGlCompareTestOperation.NOT_EQUAL,\n];\nconst AND_SEPARATOR = ' && ';\n// const VECTOR_COMPARISON_METHODS = {\n// \t\"==\": 'equal',\n// \t\"<\":  'lessThan',\n// \t\">\":  'greaterThan',\n// \t\"<=\": 'lessThanEqual',\n// \t\">=\": 'greaterThanEqual',\n// \t\"!=\": 'notEqual'\n// }\n// const TEST_OPERATIONS_VECTOR = [\n// \t\"equal\",\n// \t\"lessThan\",\n// \t\"greaterThan\",\n// \t\"lessThanEqual\",\n// \t\"greaterThanEqual\",\n// \t\"notEqual\",\n// ]\n\nconst COMPONENTS = ['x', 'y', 'z', 'w'];\nconst OUTPUT_NAME = 'val';\nclass CompareGlParamsConfig extends NodeParamsConfig {\n\ttest = ParamConfig.INTEGER(1, {\n\t\tmenu: {\n\t\t\tentries: TEST_NAMES.map((name, i) => {\n\t\t\t\tconst operator = TEST_OPERATIONS_FLOAT[i];\n\t\t\t\tconst label = `${operator.padEnd(2, ' ')} (${name})`;\n\t\t\t\treturn {name: label, value: i};\n\t\t\t}),\n\t\t},\n\t});\n}\nconst ParamsConfig = new CompareGlParamsConfig();\nexport class CompareGlNode extends TypedGlNode<CompareGlParamsConfig> {\n\toverride paramsConfig = ParamsConfig;\n\tstatic override type() {\n\t\treturn 'compare';\n\t}\n\t// public readonly gl_connections_controller: GlConnectionsController = new GlConnectionsController(this);\n\toverride initializeNode() {\n\t\tsuper.initializeNode();\n\n\t\tthis.io.connection_points.spare_params.setInputlessParamNames(['test']);\n\n\t\tthis.io.connection_points.initializeNode();\n\t\tthis.io.connection_points.set_input_name_function(this._gl_input_name.bind(this));\n\t\tthis.io.connection_points.set_output_name_function((index: number) => OUTPUT_NAME);\n\t\tthis.io.connection_points.set_expected_input_types_function(this._expected_input_type.bind(this));\n\t\tthis.io.connection_points.set_expected_output_types_function(() => [GlConnectionPointType.BOOL]);\n\t}\n\tsetTestName(test: GlCompareTestName) {\n\t\tthis.p.test.set(TEST_NAMES.indexOf(test));\n\t}\n\ttestName() {\n\t\treturn TEST_NAMES[this.pv.test];\n\t}\n\toperator() {\n\t\treturn TEST_OPERATIONS_FLOAT[this.pv.test];\n\t}\n\n\tprotected _gl_input_name(index: number) {\n\t\treturn ['value0', 'value1'][index];\n\t}\n\tprotected _expected_input_type() {\n\t\tconst type = this.io.connection_points.first_input_connection_type() || GlConnectionPointType.FLOAT;\n\t\treturn [type, type];\n\t}\n\n\toverride setLines(shaders_collection_controller: ShadersCollectionController) {\n\t\tconst body_lines: string[] = [];\n\n\t\tconst value = this.glVarName(OUTPUT_NAME);\n\t\tconst operator = this.operator();\n\t\tconst value0 = ThreeToGl.any(this.variableForInput(this._gl_input_name(0)));\n\t\tconst value1 = ThreeToGl.any(this.variableForInput(this._gl_input_name(1)));\n\n\t\tconst connectionPoints = this.io.inputs.namedInputConnectionPoints();\n\t\tif (!connectionPoints) {\n\t\t\treturn;\n\t\t}\n\t\tconst first_connection = connectionPoints[0];\n\t\tlet components_count = 1;\n\t\tif (first_connection) {\n\t\t\tcomponents_count = GlConnectionPointComponentsCountMap[first_connection.type()] || 1;\n\t\t}\n\n\t\tif (components_count > 1) {\n\t\t\t// if comparing with distance, but not sure about that\n\t\t\t// body_lines.push(`bool ${value} = (distance(${value0}) ${operator} distance(${value1})`)\n\t\t\t// instead, comparing components one by one\n\t\t\tlet tmp_values: string[] = [];\n\t\t\tfor (let i = 0; i < components_count; i++) {\n\t\t\t\tconst tmp_value = this.glVarName(`tmp_value_${i}`);\n\t\t\t\tconst component = COMPONENTS[i];\n\t\t\t\ttmp_values.push(tmp_value);\n\t\t\t\tbody_lines.push(`bool ${tmp_value} = (${value0}.${component} ${operator} ${value1}.${component})`);\n\t\t\t}\n\t\t\tbody_lines.push(`bool ${value} = (${tmp_values.join(AND_SEPARATOR)})`);\n\t\t} else {\n\t\t\tbody_lines.push(`bool ${value} = (${value0} ${operator} ${value1})`);\n\t\t}\n\n\t\tshaders_collection_controller.addBodyLines(this, body_lines);\n\t}\n}\n","/**\n * computes normals after applying transformations on the current vertex as well as the adjacent ones.\n *\n *\n *\n */\n\nimport {TypedSubnetGlNode, TypedSubnetGlParamsConfigMixin, ADD_BODY_LINES_OPTIONS} from './Subnet';\nimport {NodeParamsConfig, ParamConfig} from '../utils/params/ParamsConfig';\nimport {ShadersCollectionController} from './code/utils/ShadersCollectionController';\nimport {ThreeToGl} from '../../../core/ThreeToGl';\nimport {SubnetInputGlNode} from './SubnetInput';\nimport {GlConnectionPointType} from '../utils/io/connections/Gl';\nimport {AttribAdjacency, adjacencyAttribName} from '../../../core/geometry/operation/Adjacency';\nimport {BaseGlShaderAssembler} from './code/assemblers/_Base';\nimport {TypeAssert} from '../../poly/Assert';\nimport GET_UV from './gl/geometryAttributes/geometryAttributesLookupUv.glsl';\nimport {FunctionGLDefinition} from './utils/GLDefinition';\nimport {AttribLookup} from '../../../core/geometry/operation/TextureFromAttribute';\nimport {GlType} from '../../poly/registers/nodes/types/Gl';\n// import {SubnetOutputGlNode} from './SubnetOutput';\n\nexport enum ComputeNormalsInput {\n\tP = 'P',\n\tN = 'N',\n\tTEXTURE_SIZE = 'textureSize',\n\tUV = 'adjacencyUv',\n\tID = 'adjacencyId',\n}\nenum ForLoopVar {\n\tADJACENCY_ATTRIBUTES_ARRAY = 'adjacencyAttributesArray',\n\tFACE_INDEX = 'faceIndex',\n\tVERTEX_INDEX = 'vertexIndex',\n\tCURRENT_ADJACENT_ID_FOR_FACE = 'currentAdjacentIdForFace',\n\tCURRENT_ADJACENT_ID = 'currentAdjacentId',\n\tADJACENT_POS0 = 'adjacentPos0',\n\tADJACENT_POS1 = 'adjacentPos1',\n\tCOMPUTED_NORMAL = 'computedNormal',\n}\nconst CONSTANT = {\n\tSTART: 0,\n\tSTEP: 1,\n};\nconst SUBNET_INPUT_CONNECTIONS_OFFSET = 3;\nconst CURRENT_POINT_GL_VAR_NAME_SUFFIX = 'currentPoint';\n\nenum VariablesLookupMode {\n\tCURRENT_POINT = 'currentPoint',\n\tADJACENT_POINT = 'adjacentPoint',\n}\n\nclass ComputeNormalsGlParamsConfig extends TypedSubnetGlParamsConfigMixin(NodeParamsConfig) {\n\tadjacencyCount = ParamConfig.FLOAT(6, {\n\t\trange: [0, 8],\n\t\trangeLocked: [true, false],\n\t});\n\tadjacencyBaseName = ParamConfig.STRING(AttribAdjacency.BASE_NAME);\n}\nconst ParamsConfig = new ComputeNormalsGlParamsConfig();\n\nexport class ComputeNormalsGlNode extends TypedSubnetGlNode<ComputeNormalsGlParamsConfig> {\n\toverride paramsConfig = ParamsConfig;\n\tstatic override type() {\n\t\treturn GlType.COMPUTE_NORMALS;\n\t}\n\n\tprotected override _expectedOutputTypes(): GlConnectionPointType[] {\n\t\treturn [\n\t\t\tGlConnectionPointType.VEC3,\n\t\t\tGlConnectionPointType.VEC3,\n\t\t\tGlConnectionPointType.VEC2,\n\t\t\t...super._expectedOutputTypes(),\n\t\t];\n\t}\n\n\tprotected override _expectedInputTypes(): GlConnectionPointType[] {\n\t\treturn [\n\t\t\tGlConnectionPointType.VEC3,\n\t\t\tGlConnectionPointType.VEC3,\n\t\t\tGlConnectionPointType.VEC2,\n\t\t\t...super._expectedInputTypes(),\n\t\t];\n\t}\n\tprotected override _expectedOutputName(index: number) {\n\t\treturn this._expectedInputName(index);\n\t}\n\n\tprotected override _expectedInputName(index: number) {\n\t\treturn (\n\t\t\t[ComputeNormalsInput.P, ComputeNormalsInput.N, ComputeNormalsInput.TEXTURE_SIZE][index] ||\n\t\t\tsuper._expectedInputName(index - 3)\n\t\t);\n\t}\n\toverride childExpectedInputConnectionPointTypes() {\n\t\treturn [\n\t\t\t// GlConnectionPointType.VEC3,\n\t\t\t// GlConnectionPointType.VEC3,\n\t\t\tGlConnectionPointType.VEC2,\n\t\t\tGlConnectionPointType.INT,\n\t\t\t...super._expectedInputTypes(),\n\t\t];\n\t}\n\toverride childExpectedInputConnectionPointName(index: number) {\n\t\treturn (\n\t\t\t[\n\t\t\t\t// ComputeNormalsInput.P,\n\t\t\t\t// ComputeNormalsInput.N,\n\t\t\t\tComputeNormalsInput.UV,\n\t\t\t\tComputeNormalsInput.ID,\n\t\t\t][index] || super._expectedInputName(index - 2)\n\t\t);\n\t}\n\toverride childExpectedOutputConnectionPointTypes() {\n\t\treturn [GlConnectionPointType.VEC3, ...super._expectedInputTypes()];\n\t}\n\toverride childExpectedOutputConnectionPointName(index: number) {\n\t\tswitch (index) {\n\t\t\tcase 0: {\n\t\t\t\treturn ComputeNormalsInput.P;\n\t\t\t}\n\t\t\tdefault: {\n\t\t\t\t// no normals for output, since the point of this node is to calculate them\n\t\t\t\treturn super._expectedInputName(index - 1);\n\t\t\t}\n\t\t}\n\t}\n\n\t//\n\t//\n\t// set_lines\n\t//\n\t//\n\t// _varNameSuffix: string | undefined;\n\t_variableLookupMode: VariablesLookupMode = VariablesLookupMode.CURRENT_POINT;\n\tprotected override _glVarNameBase() {\n\t\tconst varName = super._glVarNameBase();\n\t\tswitch (this._variableLookupMode) {\n\t\t\tcase VariablesLookupMode.CURRENT_POINT: {\n\t\t\t\treturn `${varName}_${CURRENT_POINT_GL_VAR_NAME_SUFFIX}`;\n\t\t\t}\n\t\t\tcase VariablesLookupMode.ADJACENT_POINT: {\n\t\t\t\treturn varName;\n\t\t\t}\n\t\t}\n\t}\n\tprivate _withCurrentPoint(callback: () => void) {\n\t\tthis._variableLookupMode = VariablesLookupMode.CURRENT_POINT;\n\t\tconst result = callback();\n\t\tthis._variableLookupMode = VariablesLookupMode.ADJACENT_POINT;\n\t\treturn result;\n\t}\n\n\tprivate _adjacencyLookupId() {\n\t\tswitch (this._variableLookupMode) {\n\t\t\tcase VariablesLookupMode.CURRENT_POINT: {\n\t\t\t\treturn AttribLookup.ID;\n\t\t\t}\n\t\t\tcase VariablesLookupMode.ADJACENT_POINT: {\n\t\t\t\treturn this.glVarName(ForLoopVar.CURRENT_ADJACENT_ID);\n\t\t\t}\n\t\t}\n\t\tTypeAssert.unreachable(this._variableLookupMode);\n\t}\n\tprivate _adjacencyLookupUv() {\n\t\tswitch (this._variableLookupMode) {\n\t\t\tcase VariablesLookupMode.CURRENT_POINT: {\n\t\t\t\treturn AttribLookup.UV;\n\t\t\t}\n\t\t\tcase VariablesLookupMode.ADJACENT_POINT: {\n\t\t\t\tconst id = this._adjacencyLookupId();\n\t\t\t\tconst textureSize = ThreeToGl.vector2(this.variableForInput(ComputeNormalsInput.TEXTURE_SIZE));\n\t\t\t\t// const textureSize = ThreeToGl.float(this.pv.textureSize);\n\t\t\t\treturn `geometryAttributesLookupUv(float(${id}), ${textureSize})`;\n\t\t\t}\n\t\t}\n\t\tTypeAssert.unreachable(this._variableLookupMode);\n\t}\n\tprotected override setLinesBlockStart(linesController: ShadersCollectionController) {\n\t\tconst start: number = CONSTANT.START;\n\t\tconst step: number = CONSTANT.STEP;\n\t\tconst glType = GlConnectionPointType.INT;\n\t\tconst convertMethod = ThreeToGl.integer;\n\t\tconst startStr = convertMethod(start);\n\t\tconst stepStr = convertMethod(step);\n\n\t\tconst bodyLines: string[] = [];\n\t\tconst varNameAttributesArray = this.glVarName(ForLoopVar.ADJACENCY_ATTRIBUTES_ARRAY);\n\t\tconst faceIndexIteratorName = this.glVarName(ForLoopVar.FACE_INDEX);\n\t\tconst vertexIndexIteratorName = this.glVarName(ForLoopVar.VERTEX_INDEX);\n\t\tconst varNameCurrentAdjacentIdForFace = this.glVarName(ForLoopVar.CURRENT_ADJACENT_ID_FOR_FACE);\n\t\tconst varNameP = this.glVarName(ComputeNormalsInput.P);\n\t\tconst varNameN = this.glVarName(ComputeNormalsInput.N);\n\t\tconst varNamesForInputs: Record<string, string> = {};\n\t\tconst traverseInputs = (\n\t\t\tcallback: (inputType: GlConnectionPointType, inputName: string, varName: string) => void\n\t\t) => {\n\t\t\tconst inputTypes = this._expectedInputTypes();\n\t\t\tconst inputsCount = inputTypes.length;\n\t\t\tfor (let i = 2; i < inputsCount; i++) {\n\t\t\t\tconst inputName = this._expectedInputName(i);\n\t\t\t\tconst inputType = inputTypes[i];\n\t\t\t\tconst varName = this.glVarName(inputName);\n\t\t\t\tcallback(inputType, inputName, varName);\n\t\t\t}\n\t\t};\n\t\ttraverseInputs((inputType, inputName, varName) => {\n\t\t\tvarNamesForInputs[inputName] = varName;\n\t\t});\n\n\t\t// const varNameUv = this.glVarName(ComputeNormalsInput.UV);\n\t\t// const varNameId = this.glVarName(ComputeNormalsInput.ID);\n\t\tthis._withCurrentPoint(() => {\n\t\t\tconst linesForCurrentPoint = this.linesBlockContent(linesController);\n\t\t\tif (linesForCurrentPoint) {\n\t\t\t\t// bodyLines.push(`${GlConnectionPointType.INT} ${this.glVarName(ForLoopVar.FACE_INDEX)} = 0;`);\n\t\t\t\tbodyLines.push(`${GlConnectionPointType.VEC3} ${this.glVarName(ComputeNormalsInput.P)} = ${varNameP};`);\n\t\t\t\tbodyLines.push(`${GlConnectionPointType.VEC3} ${this.glVarName(ComputeNormalsInput.N)} = ${varNameN};`);\n\t\t\t\tbodyLines.push(\n\t\t\t\t\t`${GlConnectionPointType.VEC2} ${this.glVarName(ComputeNormalsInput.UV)} = ${AttribLookup.UV};`\n\t\t\t\t);\n\t\t\t\tbodyLines.push(\n\t\t\t\t\t`${GlConnectionPointType.INT} ${this.glVarName(ComputeNormalsInput.ID)} = ${AttribLookup.ID};`\n\t\t\t\t);\n\t\t\t\ttraverseInputs((inputType, inputName, varName) => {\n\t\t\t\t\tbodyLines.push(`${inputType} ${this.glVarName(inputName)} = ${varNamesForInputs[inputName]};`);\n\t\t\t\t});\n\n\t\t\t\tbodyLines.push(...linesForCurrentPoint);\n\t\t\t}\n\t\t});\n\t\tconst _initAdjacentPos = () => {\n\t\t\tconst adjacentPos0 = this.glVarName(ForLoopVar.ADJACENT_POS0);\n\t\t\tconst adjacentPos1 = this.glVarName(ForLoopVar.ADJACENT_POS1);\n\t\t\tconst glType = GlConnectionPointType.VEC3;\n\t\t\treturn [`${glType} ${adjacentPos0}`, `${glType} ${adjacentPos1}`];\n\t\t};\n\t\tconst _initComputedNormal = () => {\n\t\t\tconst computedNormal = this.glVarName(ForLoopVar.COMPUTED_NORMAL);\n\t\t\tconst glType = GlConnectionPointType.VEC3;\n\t\t\t// make sure it is initialized to a value,\n\t\t\t// in case the current point has no valid adjacent points\n\t\t\treturn [`${glType} ${computedNormal} = vec3(0.)`];\n\t\t};\n\t\tconst _getAdjacencyAttributeArray = () => {\n\t\t\tconst adjacencyCount: number = this.pv.adjacencyCount;\n\t\t\tconst adjacencyBaseName: string = this.pv.adjacencyBaseName;\n\t\t\tconst adjacencyAttributeNames: string[] = [];\n\t\t\tfor (let i = 0; i < adjacencyCount; i++) {\n\t\t\t\tconst attribName = adjacencyAttribName(adjacencyBaseName, i);\n\t\t\t\tadjacencyAttributeNames.push(attribName);\n\t\t\t}\n\t\t\tconst glType = GlConnectionPointType.VEC2;\n\t\t\treturn `${glType} ${varNameAttributesArray}[${adjacencyCount}] = vec2[${adjacencyCount}](${adjacencyAttributeNames.join(\n\t\t\t\t','\n\t\t\t)})`;\n\t\t};\n\t\tconst _forLoopFaces = () => {\n\t\t\tconst max: number = this.pv.adjacencyCount;\n\t\t\tconst maxStr = convertMethod(max);\n\n\t\t\tconst bodyLine = `for(${glType} ${faceIndexIteratorName} = ${startStr}; ${faceIndexIteratorName} < ${maxStr}; ${faceIndexIteratorName}+= ${stepStr}){`;\n\t\t\treturn bodyLine;\n\t\t};\n\t\tconst _getAdjacencyAttributeForFace = () => {\n\t\t\tconst glType = GlConnectionPointType.VEC2;\n\t\t\treturn `${glType} ${varNameCurrentAdjacentIdForFace} = ${varNameAttributesArray}[${faceIndexIteratorName}]`;\n\t\t};\n\t\tconst _forLoopVertices = () => {\n\t\t\tconst max: number = 2;\n\t\t\tconst maxStr = convertMethod(max);\n\t\t\tconst bodyLine = `for(${glType} ${vertexIndexIteratorName} = ${startStr}; ${vertexIndexIteratorName} < ${maxStr}; ${vertexIndexIteratorName}+= ${stepStr}){`;\n\t\t\treturn bodyLine;\n\t\t};\n\t\tconst _getAdjacencyAttribute = () => {\n\t\t\tconst glType = GlConnectionPointType.INT;\n\t\t\tconst varName = this.glVarName(ForLoopVar.CURRENT_ADJACENT_ID);\n\t\t\treturn `${glType} ${varName} = ${vertexIndexIteratorName}==0 ? int(${varNameCurrentAdjacentIdForFace}.x) : int(${varNameCurrentAdjacentIdForFace}.y)`;\n\t\t};\n\t\tconst _ifAdjacencyIdValid = () => {\n\t\t\treturn `if(${varNameCurrentAdjacentIdForFace}.x > -0.5 && ${varNameCurrentAdjacentIdForFace}.y >= -0.5){`;\n\t\t};\n\t\tbodyLines.push(..._initAdjacentPos());\n\t\tbodyLines.push(..._initComputedNormal());\n\t\tbodyLines.push(_getAdjacencyAttributeArray());\n\t\tbodyLines.push(_forLoopFaces());\n\t\tbodyLines.push(_getAdjacencyAttributeForFace());\n\t\tbodyLines.push(_ifAdjacencyIdValid());\n\t\tbodyLines.push(_forLoopVertices());\n\t\tbodyLines.push(_getAdjacencyAttribute());\n\n\t\tlinesController.addBodyLines(this, bodyLines, undefined, ADD_BODY_LINES_OPTIONS);\n\t\tlinesController.addDefinitions(this, [new FunctionGLDefinition(this, GET_UV)]);\n\t}\n\tprotected override setLinesBlockEnd(shadersCollectionController: ShadersCollectionController) {\n\t\tconst vertexIndexIteratorName = this.glVarName(ForLoopVar.VERTEX_INDEX);\n\t\tconst adjacentPos0 = this.glVarName(ForLoopVar.ADJACENT_POS0);\n\t\tconst adjacentPos1 = this.glVarName(ForLoopVar.ADJACENT_POS1);\n\t\tconst currentPos = this.glVarName(ComputeNormalsInput.P);\n\t\tconst computedNormal = this.glVarName(ForLoopVar.COMPUTED_NORMAL);\n\t\tconst varNameP = this._withCurrentPoint(() => this.glVarName(ComputeNormalsInput.P));\n\n\t\tconst assignAdjacentPos = `if( ${vertexIndexIteratorName} == 0 ){ ${adjacentPos0}=${currentPos}; } else { ${adjacentPos1}=${currentPos}; }`;\n\t\tconst closeIf = `}`;\n\t\tconst closeFacePair = `}`;\n\t\tconst addFaceNormal = `${computedNormal} += cross( normalize(${adjacentPos0} - ${varNameP}), normalize(${adjacentPos1} - ${varNameP}) );`;\n\t\tconst closeAdjacencies = `}`;\n\t\tconst useCurrentP = `${this.glVarName(ComputeNormalsInput.P)} = ${varNameP}`;\n\t\tconst useComputedN = `${this.glVarName(ComputeNormalsInput.N)} = normalize(${computedNormal})`;\n\n\t\tshadersCollectionController.addBodyLines(this, [\n\t\t\tassignAdjacentPos,\n\t\t\tcloseIf,\n\t\t\tcloseFacePair,\n\t\t\taddFaceNormal,\n\t\t\tcloseAdjacencies,\n\t\t\tuseCurrentP,\n\t\t\tuseComputedN,\n\t\t]);\n\t}\n\toverride setSubnetInputLines(linesController: ShadersCollectionController, childNode: SubnetInputGlNode) {\n\t\t// const glType = GlConnectionPointType.INT\n\t\t// const convertMethod = ThreeToGl.integer\n\t\tconst bodyLines: string[] = [];\n\n\t\t// declare adjacency attributes\n\t\tconst assembler = linesController.assembler() as BaseGlShaderAssembler;\n\t\tconst _declareAdjacency = () => {\n\t\t\tconst adjacencyCount: number = this.pv.adjacencyCount;\n\t\t\tconst adjacencyBaseName: string = this.pv.adjacencyBaseName;\n\t\t\tfor (let i = 0; i < adjacencyCount; i++) {\n\t\t\t\tconst glType = GlConnectionPointType.VEC2;\n\t\t\t\tconst attribName = adjacencyAttribName(adjacencyBaseName, i);\n\t\t\t\t/*const newVar =*/ assembler.globalsHandler()?.readAttribute(this, glType, attribName, linesController);\n\t\t\t\t// const varName = this.glVarName(attribName);\n\t\t\t\t// bodyLines.push(`${glType} ${varName} = ${newVar}`);\n\t\t\t}\n\t\t};\n\t\tconst _declareUv = () => {\n\t\t\tconst glType = GlConnectionPointType.VEC2;\n\t\t\tconst attribName = AttribLookup.UV;\n\t\t\t/*const newVar =*/ assembler.globalsHandler()?.readAttribute(this, glType, attribName, linesController);\n\t\t\t// const varName = this.glVarName(attribName);\n\t\t\t// bodyLines.push(`${glType} ${varName} = ${newVar}`);\n\t\t};\n\t\tconst _declareId = () => {\n\t\t\tconst glType = GlConnectionPointType.INT;\n\t\t\tconst attribName = AttribLookup.ID;\n\t\t\t/*const newVar =*/ assembler.globalsHandler()?.readAttribute(this, glType, attribName, linesController);\n\t\t\t// const varName = this.glVarName(attribName);\n\t\t\t// bodyLines.push(`${glType} ${varName} = ${newVar}`);\n\t\t};\n\t\t_declareAdjacency();\n\t\t_declareUv();\n\t\t_declareId();\n\n\t\t//\n\n\t\t// i\n\t\t// const _addFaceIndex = () => {\n\t\t// \tconst iteratorName = this.glVarName(ForLoopVar.FACE_INDEX);\n\t\t// \tconst i = childNode.glVarName(ForLoopVar.FACE_INDEX);\n\t\t// \tbodyLines.push(`\t${GlConnectionPointType.INT} ${i} = ${iteratorName}`);\n\t\t// };\n\t\tconst _addAdjacencyLookupId = () => {\n\t\t\tconst adjacencyLookupId = this._adjacencyLookupId();\n\t\t\tconst id = childNode.glVarName(ComputeNormalsInput.ID);\n\t\t\tbodyLines.push(`\t${GlConnectionPointType.INT} ${id} = ${adjacencyLookupId}`);\n\t\t};\n\t\tconst _addAdjacencyLookupUv = () => {\n\t\t\tconst adjacencyLookupUv = this._adjacencyLookupUv(); //this.glVarName(ComputeNormalsInput.UV);\n\t\t\tconst uv = childNode.glVarName(ComputeNormalsInput.UV);\n\t\t\tbodyLines.push(`\t${GlConnectionPointType.VEC2} ${uv} = ${adjacencyLookupUv}`);\n\t\t};\n\t\t// _addFaceIndex();\n\t\t_addAdjacencyLookupId();\n\t\t_addAdjacencyLookupUv();\n\t\t// start\n\t\t// const start = childNode.glVarName(ComputeNormalsInput.START);\n\t\t// body_lines.push(`\t${glType} ${start} = ${convertMethod( CONSTANT.START)}`);\n\t\t// end\n\t\t// const max = childNode.glVarName(ComputeNormalsInput.MAX);\n\t\t// body_lines.push(`\t${glType} ${max} = ${convertMethod(this.pv.max)}`);\n\t\t// step\n\t\t// const step = childNode.glVarName(ComputeNormalsInput.STEP);\n\t\t// body_lines.push(`\t${glType} ${step} = ${convertMethod(this.pv.step)}`);\n\n\t\tconst connections = this.io.connections.inputConnections();\n\t\tif (connections) {\n\t\t\tfor (const connection of connections) {\n\t\t\t\tif (connection) {\n\t\t\t\t\tif (connection.inputIndex() >= SUBNET_INPUT_CONNECTIONS_OFFSET) {\n\t\t\t\t\t\tconst connection_point = connection.destConnectionPoint();\n\t\t\t\t\t\tif (connection_point) {\n\t\t\t\t\t\t\tconst in_value = this.glVarName(connection_point.name());\n\t\t\t\t\t\t\tconst gl_type = connection_point.type();\n\t\t\t\t\t\t\tconst out = childNode.glVarName(connection_point.name());\n\t\t\t\t\t\t\tconst body_line = `\t${gl_type} ${out} = ${in_value}`;\n\t\t\t\t\t\t\tbodyLines.push(body_line);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tlinesController.addBodyLines(childNode, bodyLines);\n\t}\n\t// override subnetOutputLines(childNode: SubnetOutputGlNode) {\n\t// \tconst bodyLines: string[] = super.subnetOutputLines(childNode);\n\n\t// \tconst varNameP = this._withCurrentPoint(() => this.glVarName(ComputeNormalsInput.P));\n\t// \tbodyLines.push(`\t${this.glVarName(ComputeNormalsInput.P)} = ${varNameP}`);\n\n\t// \treturn bodyLines;\n\t// }\n}\n","/**\n * Creates a constant\n *\n *\n */\nimport {TypedGlNode} from './_Base';\nimport {ThreeToGl} from '../../../core/ThreeToGl';\nimport {BaseParamType} from '../../params/_Base';\nimport {NodeParamsConfig, ParamConfig} from '../utils/params/ParamsConfig';\nimport {ShadersCollectionController} from './code/utils/ShadersCollectionController';\nimport {CoreType, isBooleanTrue} from '../../../core/Type';\nimport {PolyDictionary} from '../../../types/GlobalTypes';\nimport {GlConnectionPointType, GL_CONNECTION_POINT_TYPES_FOR_CONSTANT} from '../utils/io/connections/Gl';\nimport {GlType} from '../../poly/registers/nodes/types/Gl';\n\nfunction typedVisibleOptions(type: GlConnectionPointType, otherParamVal: PolyDictionary<number | boolean> = {}) {\n\tconst val = GL_CONNECTION_POINT_TYPES_FOR_CONSTANT.indexOf(type);\n\treturn {visibleIf: {type: val, ...otherParamVal}};\n}\n\nclass ConstantGlParamsConfig extends NodeParamsConfig {\n\ttype = ParamConfig.INTEGER(GL_CONNECTION_POINT_TYPES_FOR_CONSTANT.indexOf(GlConnectionPointType.FLOAT), {\n\t\tmenu: {\n\t\t\tentries: GL_CONNECTION_POINT_TYPES_FOR_CONSTANT.map((name, i) => {\n\t\t\t\treturn {name: name, value: i};\n\t\t\t}),\n\t\t},\n\t});\n\tbool = ParamConfig.BOOLEAN(0, typedVisibleOptions(GlConnectionPointType.BOOL));\n\tint = ParamConfig.INTEGER(0, typedVisibleOptions(GlConnectionPointType.INT));\n\tfloat = ParamConfig.FLOAT(0, typedVisibleOptions(GlConnectionPointType.FLOAT));\n\tvec2 = ParamConfig.VECTOR2([0, 0], typedVisibleOptions(GlConnectionPointType.VEC2));\n\tvec3 = ParamConfig.VECTOR3([0, 0, 0], typedVisibleOptions(GlConnectionPointType.VEC3, {asColor: false}));\n\tcolor = ParamConfig.COLOR([0, 0, 0], typedVisibleOptions(GlConnectionPointType.VEC3, {asColor: true}));\n\tvec4 = ParamConfig.VECTOR4([0, 0, 0, 0], typedVisibleOptions(GlConnectionPointType.VEC4));\n\t/** @param when using vec3, use toggle on it should be a color */\n\tasColor = ParamConfig.BOOLEAN(0, typedVisibleOptions(GlConnectionPointType.VEC3));\n}\nconst ParamsConfig = new ConstantGlParamsConfig();\nexport class ConstantGlNode extends TypedGlNode<ConstantGlParamsConfig> {\n\toverride paramsConfig = ParamsConfig;\n\tstatic override type() {\n\t\treturn GlType.CONSTANT;\n\t}\n\tstatic readonly OUTPUT_NAME = 'val';\n\toverride initializeNode() {\n\t\tthis.io.connection_points.set_output_name_function((index: number) => ConstantGlNode.OUTPUT_NAME);\n\t\tthis.io.connection_points.set_expected_input_types_function(() => []);\n\t\tthis.io.connection_points.set_expected_output_types_function(() => [this._currentConnectionType()]);\n\t}\n\n\toverride setLines(shaders_collection_controller: ShadersCollectionController) {\n\t\tconst param = this.currentParam();\n\t\tif (!param) {\n\t\t\tconsole.warn(`no param found for constant node for type '${this.pv.type}'`);\n\t\t\treturn;\n\t\t}\n\t\tconst value = this.currentValue();\n\t\tif (value == null) {\n\t\t\tconsole.warn(`no value found for constant node for type '${this.pv.type}'`);\n\t\t\treturn;\n\t\t}\n\n\t\tconst connection_type = this._currentConnectionType();\n\t\tconst var_value = this._currentVarName();\n\t\tconst body_line = `${connection_type} ${var_value} = ${value}`;\n\t\tshaders_collection_controller.addBodyLines(this, [body_line]);\n\t}\n\n\tprivate _currentConnectionType() {\n\t\tif (this.pv.type == null) {\n\t\t\tconsole.warn('constant gl node type is null', this.path());\n\t\t}\n\t\tconst connectionType = GL_CONNECTION_POINT_TYPES_FOR_CONSTANT[this.pv.type] || GlConnectionPointType.FLOAT;\n\t\tif (connectionType == null) {\n\t\t\tconsole.warn(`constant gl node type if not valid (${this.pv.type})`, this.path());\n\t\t}\n\t\treturn connectionType;\n\t}\n\n\tcurrentParam(): BaseParamType {\n\t\tconst type = GL_CONNECTION_POINT_TYPES_FOR_CONSTANT[this.pv.type];\n\t\tswitch (type) {\n\t\t\tcase GlConnectionPointType.BOOL: {\n\t\t\t\treturn this.p.bool;\n\t\t\t}\n\t\t\tcase GlConnectionPointType.INT: {\n\t\t\t\treturn this.p.int;\n\t\t\t}\n\t\t\tcase GlConnectionPointType.FLOAT: {\n\t\t\t\treturn this.p.float;\n\t\t\t}\n\t\t\tcase GlConnectionPointType.VEC2: {\n\t\t\t\treturn this.p.vec2;\n\t\t\t}\n\t\t\tcase GlConnectionPointType.VEC3: {\n\t\t\t\tif (isBooleanTrue(this.pv.asColor)) {\n\t\t\t\t\treturn this.p.color;\n\t\t\t\t} else {\n\t\t\t\t\treturn this.p.vec3;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcase GlConnectionPointType.VEC4: {\n\t\t\t\treturn this.p.vec4;\n\t\t\t}\n\t\t}\n\t\t// we should never run this\n\t\treturn this.p.bool;\n\t}\n\tprivate _currentVarName(): string {\n\t\treturn this.glVarName(ConstantGlNode.OUTPUT_NAME);\n\t}\n\tcurrentValue() {\n\t\tconst param = this.currentParam();\n\t\tif (param) {\n\t\t\tlet value = ThreeToGl.any(param.value);\n\t\t\t// ensure that it is an integer when needed\n\t\t\t// as ThreeToGl.any can only detect if this is a number for now\n\t\t\t// and therefore does not make the distinction between float and int\n\t\t\tif (param.name() == this.p.int.name() && CoreType.isNumber(param.value)) {\n\t\t\t\tvalue = ThreeToGl.integer(param.value);\n\t\t\t}\n\t\t\treturn value;\n\t\t}\n\t}\n\n\tsetGlType(type: GlConnectionPointType) {\n\t\tthis.p.type.set(GL_CONNECTION_POINT_TYPES_FOR_CONSTANT.indexOf(type));\n\t}\n}\n","/**\n * repeats an SDF, allowing fractal effects\n *\n * @remarks\n *\n * based on [https://iquilezles.org/articles/distfunctions/](https://iquilezles.org/articles/distfunctions/)\n */\n\nimport {BaseSDFGlNode} from './_BaseSDF';\nimport {ThreeToGl} from '../../../../src/core/ThreeToGl';\nimport SDFRepeatMethods from './gl/raymarching/sdfRepeat.glsl';\nimport {NodeParamsConfig, ParamConfig} from '../utils/params/ParamsConfig';\nimport {GlConnectionPointType, GlConnectionPoint} from '../utils/io/connections/Gl';\nimport {ShadersCollectionController} from './code/utils/ShadersCollectionController';\nimport {FunctionGLDefinition} from './utils/GLDefinition';\nimport {isBooleanTrue} from '../../../core/Type';\nimport {VisibleIfParamOptions} from '../../params/utils/OptionsController';\n\nconst OUTPUT_NAME = 'p';\n\nconst clampVisibility: VisibleIfParamOptions[] = [{repeatX: 1}, {repeatY: 1}, {repeatZ: 1}];\nconst clampAxisVisibility: VisibleIfParamOptions[] = clampVisibility.map((option) => ({...option, clamped: 1}));\nconst clampAxisBoundVisibilityX: VisibleIfParamOptions[] = clampAxisVisibility.map((option) => ({\n\t...option,\n\tclampedX: 1,\n}));\nconst clampAxisBoundVisibilityY: VisibleIfParamOptions[] = clampAxisVisibility.map((option) => ({\n\t...option,\n\tclampedY: 1,\n}));\nconst clampAxisBoundVisibilityZ: VisibleIfParamOptions[] = clampAxisVisibility.map((option) => ({\n\t...option,\n\tclampedZ: 1,\n}));\n\nclass SDFRepeatGlParamsConfig extends NodeParamsConfig {\n\tposition = ParamConfig.VECTOR3([0, 0, 0], {hidden: true});\n\tcenter = ParamConfig.VECTOR3([0, 0, 0]);\n\tperiod = ParamConfig.VECTOR3([1, 1, 1]);\n\trepeatX = ParamConfig.BOOLEAN(1);\n\trepeatY = ParamConfig.BOOLEAN(1);\n\trepeatZ = ParamConfig.BOOLEAN(1);\n\tclamped = ParamConfig.BOOLEAN(0, {visibleIf: clampVisibility});\n\tclampedX = ParamConfig.BOOLEAN(0, {visibleIf: clampAxisVisibility});\n\tboundX = ParamConfig.VECTOR2([-1, 1], {visibleIf: clampAxisBoundVisibilityX});\n\tclampedY = ParamConfig.BOOLEAN(0, {visibleIf: clampAxisVisibility});\n\tboundY = ParamConfig.VECTOR2([-1, 1], {visibleIf: clampAxisBoundVisibilityY});\n\tclampedZ = ParamConfig.BOOLEAN(0, {visibleIf: clampAxisVisibility});\n\tboundZ = ParamConfig.VECTOR2([-1, 1], {visibleIf: clampAxisBoundVisibilityZ});\n}\nconst ParamsConfig = new SDFRepeatGlParamsConfig();\nexport class SDFRepeatGlNode extends BaseSDFGlNode<SDFRepeatGlParamsConfig> {\n\toverride paramsConfig = ParamsConfig;\n\tstatic override type() {\n\t\treturn 'SDFRepeat';\n\t}\n\n\toverride initializeNode() {\n\t\tsuper.initializeNode();\n\t\tthis.io.connection_points.spare_params.setInputlessParamNames([\n\t\t\t'repeatX',\n\t\t\t'repeatY',\n\t\t\t'repeatZ',\n\t\t\t'clamped',\n\t\t\t'clampedX',\n\t\t\t'clampedY',\n\t\t\t'clampedZ',\n\t\t]);\n\t\tthis.io.outputs.setNamedOutputConnectionPoints([\n\t\t\tnew GlConnectionPoint(OUTPUT_NAME, GlConnectionPointType.VEC3),\n\t\t]);\n\t}\n\n\toverride setLines(shadersCollectionController: ShadersCollectionController) {\n\t\tconst position = this.position();\n\t\tconst center = ThreeToGl.vector3(this.variableForInputParam(this.p.center));\n\t\tconst period = ThreeToGl.vector3(this.variableForInputParam(this.p.period));\n\t\tconst float = this.glVarName(OUTPUT_NAME);\n\t\tconst functionName = `SDFRepeat${this._functionSuffixUnclamped()}`;\n\t\tconst bodyLines: string[] = [];\n\t\tif (this.clamped()) {\n\t\t\tconst boundMin = this.glVarName('boundMin');\n\t\t\tconst boundMax = this.glVarName('boundMax');\n\t\t\tconst boundX = ThreeToGl.vector3(this.variableForInputParam(this.p.boundX));\n\t\t\tconst boundY = ThreeToGl.vector3(this.variableForInputParam(this.p.boundY));\n\t\t\tconst boundZ = ThreeToGl.vector3(this.variableForInputParam(this.p.boundZ));\n\t\t\tconst clampedAxisesCount = this._clampedAxisesCount();\n\t\t\tswitch (clampedAxisesCount) {\n\t\t\t\tcase 1: {\n\t\t\t\t\tlet bounds = boundX;\n\t\t\t\t\tif (this.clampedX()) {\n\t\t\t\t\t\tbounds = boundX;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (this.clampedY()) {\n\t\t\t\t\t\t\tbounds = boundY;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tbounds = boundZ;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tbodyLines.push(`float ${boundMin} = ${bounds}.x`, `float ${boundMax} = ${bounds}.y`);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcase 2: {\n\t\t\t\t\tlet bounds1 = boundX;\n\t\t\t\t\tlet bounds2 = boundY;\n\t\t\t\t\tif (this.clampedX()) {\n\t\t\t\t\t\tbounds1 = boundX;\n\t\t\t\t\t\tif (this.clampedY()) {\n\t\t\t\t\t\t\tbounds2 = boundY;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tbounds2 = boundZ;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tbounds1 = boundY;\n\t\t\t\t\t\tbounds2 = boundZ;\n\t\t\t\t\t}\n\t\t\t\t\tbodyLines.push(\n\t\t\t\t\t\t`vec2 ${boundMin} = vec2(${bounds1}.x, ${bounds2}.x)`,\n\t\t\t\t\t\t`vec2 ${boundMax} = vec2(${bounds1}.y, ${bounds2}.y)`\n\t\t\t\t\t);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcase 3: {\n\t\t\t\t\tbodyLines.push(\n\t\t\t\t\t\t`vec3 ${boundMin} = vec3(${boundX}.x,${boundY}.x,${boundZ}.x)`,\n\t\t\t\t\t\t`vec3 ${boundMax} = vec3(${boundX}.y,${boundY}.y,${boundZ}.y)`\n\t\t\t\t\t);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tbodyLines.push(\n\t\t\t\t`vec3 ${float} = ${functionName}(${position} - ${center}, ${period}, ${boundMin}, ${boundMax})`\n\t\t\t);\n\t\t} else {\n\t\t\tbodyLines.push(`vec3 ${float} = ${functionName}(${position} - ${center}, ${period})`);\n\t\t}\n\n\t\tshadersCollectionController.addBodyLines(this, bodyLines);\n\t\tshadersCollectionController.addDefinitions(this, [new FunctionGLDefinition(this, SDFRepeatMethods)]);\n\t}\n\tprivate _clampedAxisesCount() {\n\t\tlet count = 0;\n\t\tif (this.clampedX()) {\n\t\t\tcount++;\n\t\t}\n\t\tif (this.clampedY()) {\n\t\t\tcount++;\n\t\t}\n\t\tif (this.clampedZ()) {\n\t\t\tcount++;\n\t\t}\n\t\treturn count;\n\t}\n\n\trepeatAll() {\n\t\tconst x = isBooleanTrue(this.pv.repeatX);\n\t\tconst y = isBooleanTrue(this.pv.repeatY);\n\t\tconst z = isBooleanTrue(this.pv.repeatZ);\n\t\treturn (x && y && z) || !(x || y || z);\n\t}\n\tclamped() {\n\t\tconst x = isBooleanTrue(this.pv.repeatX);\n\t\tconst y = isBooleanTrue(this.pv.repeatY);\n\t\tconst z = isBooleanTrue(this.pv.repeatZ);\n\t\tconst clamped = isBooleanTrue(this.pv.clamped);\n\t\tconst clampedX = isBooleanTrue(this.pv.clampedX);\n\t\tconst clampedY = isBooleanTrue(this.pv.clampedY);\n\t\tconst clampedZ = isBooleanTrue(this.pv.clampedZ);\n\t\treturn clamped && ((x && clampedX) || (y && clampedY) || (z && clampedZ));\n\t}\n\tclampedX() {\n\t\tconst x = isBooleanTrue(this.pv.repeatX);\n\t\tconst clamped = isBooleanTrue(this.pv.clamped);\n\t\tconst clampedX = isBooleanTrue(this.pv.clampedX);\n\t\treturn clamped && x && clampedX;\n\t}\n\tclampedY() {\n\t\tconst y = isBooleanTrue(this.pv.repeatY);\n\t\tconst clamped = isBooleanTrue(this.pv.clamped);\n\t\tconst clampedY = isBooleanTrue(this.pv.clampedY);\n\t\treturn clamped && y && clampedY;\n\t}\n\tclampedZ() {\n\t\tconst z = isBooleanTrue(this.pv.repeatZ);\n\t\tconst clamped = isBooleanTrue(this.pv.clamped);\n\t\tconst clampedZ = isBooleanTrue(this.pv.clampedZ);\n\t\treturn clamped && z && clampedZ;\n\t}\n\tclampedAll() {\n\t\treturn this.clampedX() && this.clampedY() && this.clampedZ();\n\t}\n\tprivate _functionSuffixUnclamped() {\n\t\tconst x = isBooleanTrue(this.pv.repeatX);\n\t\tconst y = isBooleanTrue(this.pv.repeatY);\n\t\tconst z = isBooleanTrue(this.pv.repeatZ);\n\t\tconst repeatAll = this.repeatAll();\n\t\tconst args: string[] = [];\n\t\tif (!repeatAll) {\n\t\t\tif (x) args.push('X');\n\t\t\tif (y) args.push('Y');\n\t\t\tif (z) args.push('Z');\n\t\t}\n\n\t\t// clamped\n\t\tconst clampedX = isBooleanTrue(this.pv.clampedX);\n\t\tconst clampedY = isBooleanTrue(this.pv.clampedY);\n\t\tconst clampedZ = isBooleanTrue(this.pv.clampedZ);\n\t\tif (this.clamped()) {\n\t\t\targs.push('Clamped');\n\t\t\tif (!this.clampedAll()) {\n\t\t\t\tif ((repeatAll || x) && clampedX) args.push('X');\n\t\t\t\tif ((repeatAll || y) && clampedY) args.push('Y');\n\t\t\t\tif ((repeatAll || z) && clampedZ) args.push('Z');\n\t\t\t}\n\t\t}\n\n\t\treturn args.join('');\n\t}\n}\n","/**\n * this node works alongside [gl/varyingWrite](/docs/nodes/gl/varyingWrite) and they allow a finer grained control over\n * what is computed in the vertex or the fragment shader\n *\n *\n */\n\nimport {TypedGlNode} from './_Base';\nimport {NodeParamsConfig, ParamConfig} from '../utils/params/ParamsConfig';\nimport {GlConnectionPointType} from '../utils/io/connections/Gl';\nimport {ShadersCollectionController} from './code/utils/ShadersCollectionController';\nimport {ShaderName} from '../utils/shaders/ShaderName';\nimport {VaryingGLDefinition} from './utils/GLDefinition';\nimport {GlType} from '../../poly/registers/nodes/types/Gl';\n\nconst VARYING_NODE_AVAILABLE_GL_TYPES = [\n\tGlConnectionPointType.FLOAT,\n\tGlConnectionPointType.VEC2,\n\tGlConnectionPointType.VEC3,\n\tGlConnectionPointType.VEC4,\n];\n\nclass VaryingReadGlParamsConfig extends NodeParamsConfig {\n\tname = ParamConfig.STRING('');\n\ttype = ParamConfig.INTEGER(0, {\n\t\tmenu: {\n\t\t\tentries: VARYING_NODE_AVAILABLE_GL_TYPES.map((name, i) => {\n\t\t\t\treturn {name: name, value: i};\n\t\t\t}),\n\t\t},\n\t});\n}\nconst ParamsConfig = new VaryingReadGlParamsConfig();\nexport class VaryingReadGlNode extends TypedGlNode<VaryingReadGlParamsConfig> {\n\toverride paramsConfig = ParamsConfig;\n\tstatic override type(): Readonly<GlType.VARYING_READ> {\n\t\treturn GlType.VARYING_READ;\n\t}\n\tstatic readonly OUTPUT_NAME = 'fragment';\n\n\toverride initializeNode() {\n\t\tthis.addPostDirtyHook('_setMatToRecompile', this._setMatToRecompile.bind(this));\n\t\tthis.io.connection_points.initializeNode();\n\n\t\tthis.io.connection_points.set_output_name_function(() => {\n\t\t\treturn this.outputName();\n\t\t});\n\n\t\tthis.io.connection_points.set_expected_input_types_function(() => []);\n\t\tthis.io.connection_points.set_expected_output_types_function(() => [\n\t\t\tVARYING_NODE_AVAILABLE_GL_TYPES[this.pv.type],\n\t\t]);\n\t}\n\n\toutputName() {\n\t\treturn VaryingReadGlNode.OUTPUT_NAME;\n\t}\n\n\toverride setLines(shaders_collection_controller: ShadersCollectionController) {\n\t\tif (shaders_collection_controller.currentShaderName() == ShaderName.FRAGMENT) {\n\t\t\tconst varying_name = this.pv.name;\n\t\t\tconst definition = new VaryingGLDefinition(this, this.glType(), varying_name);\n\n\t\t\t// add fragment lines\n\t\t\tconst out_value = this.glVarName(VaryingReadGlNode.OUTPUT_NAME);\n\t\t\tconst body_line = `${this.glType()} ${out_value} = ${varying_name}`;\n\t\t\tshaders_collection_controller.addDefinitions(this, [definition]);\n\t\t\tshaders_collection_controller.addBodyLines(this, [body_line]);\n\t\t}\n\t}\n\n\tattributeName(): string {\n\t\treturn this.pv.name.trim();\n\t}\n\tglType(): GlConnectionPointType {\n\t\tconst connectionPoints = this.io.outputs.namedOutputConnectionPoints();\n\t\treturn connectionPoints ? connectionPoints[0].type() : GlConnectionPointType.FLOAT;\n\t}\n\tsetGlType(type: GlConnectionPointType) {\n\t\tthis.p.type.set(VARYING_NODE_AVAILABLE_GL_TYPES.indexOf(type));\n\t}\n}\n","import {BasePersistedConfig, PersistedConfigWithShaders} from '../../../../utils/BasePersistedConfig';\nimport {BuilderCopNode} from '../../../../cop/Builder';\nimport {Builder2DArrayCopNode} from '../../../../cop/Builder2DArray';\nimport {GlParamConfig} from '../../utils/GLParamConfig';\nimport {IUniformsWithTime} from '../../../../../scene/utils/UniformsController';\nimport {IUniforms} from '../../../../../../core/geometry/Material';\nimport {handleCopBuilderDependencies} from '../../../../cop/utils/BuilderUtils';\n\nexport interface PersistedConfigBaseTextureData extends PersistedConfigWithShaders {\n\t// fragment_shader: string;\n\tuniforms: IUniforms;\n\tparam_uniform_pairs: [string, string][];\n\tuniforms_time_dependent?: boolean;\n\tuniforms_resolution_dependent?: boolean;\n}\nconst FRAGMENT_KEY = 'fragment';\nexport class TexturePersistedConfig extends BasePersistedConfig {\n\tconstructor(protected override node: BuilderCopNode | Builder2DArrayCopNode) {\n\t\tsuper(node);\n\t}\n\toverride async toData(): Promise<PersistedConfigBaseTextureData | undefined> {\n\t\tconst assemblerController = this.node.assemblerController();\n\t\tif (!assemblerController) {\n\t\t\treturn;\n\t\t}\n\n\t\t// params updating uniforms\n\t\tconst param_uniform_pairs: [string, string][] = [];\n\t\tconst param_configs = assemblerController.assembler.param_configs();\n\t\tfor (const param_config of param_configs) {\n\t\t\tparam_uniform_pairs.push([param_config.name(), param_config.uniformName()]);\n\t\t}\n\n\t\tconst data: PersistedConfigBaseTextureData = {\n\t\t\t// fragment_shader: this.node.textureMaterial.fragmentShader,\n\t\t\tuniforms: this.node.textureMaterial.uniforms,\n\t\t\tparam_uniform_pairs: param_uniform_pairs,\n\t\t\tuniforms_time_dependent: assemblerController.assembler.uniformsTimeDependent(),\n\t\t\tuniforms_resolution_dependent: assemblerController.assembler.uniformsResolutionDependent(),\n\t\t\tshaders: {\n\t\t\t\t[FRAGMENT_KEY]: this.node.textureMaterial.fragmentShader,\n\t\t\t},\n\t\t};\n\t\treturn data;\n\t}\n\toverride load(data: PersistedConfigBaseTextureData) {\n\t\tconst assemblerController = this.node.assemblerController();\n\t\tif (assemblerController) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis.node.textureMaterial.uniforms = data.uniforms;\n\t\tconst shaders = data.shaders;\n\t\tif (shaders && shaders[FRAGMENT_KEY] != null) {\n\t\t\tthis.node.textureMaterial.fragmentShader = shaders[FRAGMENT_KEY];\n\t\t} else {\n\t\t\tconsole.warn(`${this.node.path()}: persisted config has no fragment shader`);\n\t\t}\n\n\t\thandleCopBuilderDependencies({\n\t\t\tnode: this.node,\n\t\t\ttimeDependent: data.uniforms_time_dependent || false,\n\t\t\tuniforms: data.uniforms as IUniformsWithTime,\n\t\t});\n\n\t\tfor (const pair of data.param_uniform_pairs) {\n\t\t\tconst param = this.node.params.get(pair[0]);\n\t\t\tconst uniform = data.uniforms[pair[1]];\n\t\t\tif (param && uniform) {\n\t\t\t\tconst callback = () => {\n\t\t\t\t\tGlParamConfig.callback(param, uniform);\n\t\t\t\t};\n\t\t\t\tparam.options.set({\n\t\t\t\t\tcallback: callback,\n\t\t\t\t});\n\t\t\t\t// it's best to execute the callback directly\n\t\t\t\t// as it may otherwise be prevented if the scene is loading for instance\n\t\t\t\t// and this is currently necessary for ramp params, when no assembler is loaded\n\t\t\t\tcallback();\n\t\t\t\t// param.options.executeCallback();\n\t\t\t}\n\t\t}\n\t}\n}\n","/**\n * create an animation action from an animation mixer\n *\n *\n */\nimport {TypedJsNode} from './_Base';\nimport {NodeParamsConfig, ParamConfig} from '../utils/params/ParamsConfig';\nimport {JsConnectionPoint, JsConnectionPointType, JS_CONNECTION_POINT_IN_NODE_DEF} from '../utils/io/connections/Js';\nimport {Poly} from '../../Poly';\nimport {JsLinesCollectionController} from './code/utils/JsLinesCollectionController';\n\nconst CONNECTION_OPTIONS = JS_CONNECTION_POINT_IN_NODE_DEF;\n\nclass AnimationActionJsParamsConfig extends NodeParamsConfig {\n\tclipName = ParamConfig.STRING('');\n\tautoPlay = ParamConfig.BOOLEAN(1);\n}\nconst ParamsConfig = new AnimationActionJsParamsConfig();\n\nexport class AnimationActionJsNode extends TypedJsNode<AnimationActionJsParamsConfig> {\n\toverride readonly paramsConfig = ParamsConfig;\n\tstatic override type() {\n\t\treturn 'animationAction';\n\t}\n\n\tstatic readonly OUTPUT_NAME = 'val';\n\toverride initializeNode() {\n\t\tthis.io.inputs.setNamedInputConnectionPoints([\n\t\t\tnew JsConnectionPoint(\n\t\t\t\tJsConnectionPointType.ANIMATION_MIXER,\n\t\t\t\tJsConnectionPointType.ANIMATION_MIXER,\n\t\t\t\tCONNECTION_OPTIONS\n\t\t\t),\n\t\t]);\n\n\t\tthis.io.outputs.setNamedOutputConnectionPoints([\n\t\t\tnew JsConnectionPoint(JsConnectionPointType.ANIMATION_ACTION, JsConnectionPointType.ANIMATION_ACTION),\n\t\t]);\n\t}\n\toverride setLines(shadersCollectionController: JsLinesCollectionController) {\n\t\tconst mixer = this.variableForInput(shadersCollectionController, JsConnectionPointType.ANIMATION_MIXER);\n\t\tconst clipName = this.variableForInputParam(shadersCollectionController, this.p.clipName);\n\t\tconst autoPlay = this.variableForInputParam(shadersCollectionController, this.p.autoPlay);\n\t\tconst varName = this.jsVarName(JsConnectionPointType.ANIMATION_ACTION);\n\t\tconst func = Poly.namedFunctionsRegister.getFunction('getAnimationAction', this, shadersCollectionController);\n\n\t\tshadersCollectionController.addBodyOrComputed(this, [\n\t\t\t{dataType: JsConnectionPointType.VECTOR3, varName, value: func.asString(mixer, clipName, autoPlay)},\n\t\t]);\n\t}\n}\n","/**\n * Steps through a cloth simulation\n *\n *\n */\nimport {TRIGGER_CONNECTION_NAME, TypedJsNode} from './_Base';\nimport {inputObject3D, setObject3DOutputLine} from './_BaseObject3D';\nimport {JsLinesCollectionController} from './code/utils/JsLinesCollectionController';\nimport {Poly} from '../../Poly';\nimport {NodeParamsConfig, ParamConfig} from '../utils/params/ParamsConfig';\nimport {ConstantJsDefinition} from './utils/JsDefinition';\nimport {JsConnectionPoint, JsConnectionPointType, JS_CONNECTION_POINT_IN_NODE_DEF} from '../utils/io/connections/Js';\nimport {ClothMaterialUniformConfigRefString} from '../../../core/cloth/modules/ClothFBOController';\nconst CONNECTION_OPTIONS = JS_CONNECTION_POINT_IN_NODE_DEF;\n\nexport enum ClothSolverStepSimulationOutput {\n\tTEXTURE_SIZE = 'tSize',\n\tTEXTURE_POSITION0 = 'tPosition0',\n\tTEXTURE_POSITION1 = 'tPosition1',\n\tTEXTURE_NORMAL = 'tNormal',\n\t//\n\tTEXTURE_ORIGINAL_RT = 'tOriginalRT',\n\tTEXTURE_VISCOSITY_SPRING_T = 'tViscositySpringT',\n\tTEXTURE_PREVIOUS_RT0 = 'tPreviousRT0',\n\tTEXTURE_PREVIOUS_RT1 = 'tPreviousRT1',\n\tTEXTURE_TARGET_RT0 = 'targetRT0',\n\tTEXTURE_TARGET_RT1 = 'targetRT1',\n\tTEXTURE_NORMALS_RT = 'tNormalsRT',\n\tTEXTURE_POSITION_RT0 = 'tPositionRT0',\n\tTEXTURE_POSITION_RT1 = 'tPositionRT1',\n\tTEXTURE_ADJACENT_RT0 = 'tAdjacentsRT0',\n\tTEXTURE_ADJACENT_RT1 = 'tAdjacentsRT1',\n\tTEXTURE_DISTANCE_RT0 = 'tDistanceRT0',\n\tTEXTURE_DISTANCE_RT1 = 'tDistanceRT1',\n\t//\n\tMATERIAL_INTEGRATION = 'integrationMat',\n}\n// const ADDITIONAL_TEXTURE_OUTPUTS: ClothSolverStepSimulationOutput[] = [\n// \tClothSolverStepSimulationOutput.TEXTURE_ORIGINAL_RT,\n// \tClothSolverStepSimulationOutput.TEXTURE_VISCOSITY_SPRING_T,\n// \tClothSolverStepSimulationOutput.TEXTURE_PREVIOUS_RT0,\n// \tClothSolverStepSimulationOutput.TEXTURE_PREVIOUS_RT1,\n\n// \tClothSolverStepSimulationOutput.TEXTURE_TARGET_RT0,\n// \tClothSolverStepSimulationOutput.TEXTURE_TARGET_RT1,\n\n// \tClothSolverStepSimulationOutput.TEXTURE_NORMALS_RT,\n\n// \tClothSolverStepSimulationOutput.TEXTURE_POSITION_RT0,\n// \tClothSolverStepSimulationOutput.TEXTURE_POSITION_RT1,\n\n// \tClothSolverStepSimulationOutput.TEXTURE_ADJACENT_RT0,\n// \tClothSolverStepSimulationOutput.TEXTURE_ADJACENT_RT1,\n\n// \tClothSolverStepSimulationOutput.TEXTURE_DISTANCE_RT0,\n// \tClothSolverStepSimulationOutput.TEXTURE_DISTANCE_RT1,\n// ];\nclass ClothSolverStepSimulationJsParamsConfig extends NodeParamsConfig {\n\tstepsCount = ParamConfig.INTEGER(40, {\n\t\trange: [1, 100],\n\t\trangeLocked: [true, false],\n\t});\n\tconstraintInfluence = ParamConfig.FLOAT(0.1, {\n\t\trange: [0, 2],\n\t\trangeLocked: [true, false],\n\t});\n\tviscosity = ParamConfig.FLOAT(0.1, {\n\t\trange: [0, 1],\n\t\trangeLocked: [true, false],\n\t});\n\tspring = ParamConfig.FLOAT(1, {\n\t\trange: [0, 1],\n\t\trangeLocked: [true, false],\n\t});\n}\nconst ParamsConfig = new ClothSolverStepSimulationJsParamsConfig();\nexport class ClothSolverStepSimulationJsNode extends TypedJsNode<ClothSolverStepSimulationJsParamsConfig> {\n\toverride readonly paramsConfig = ParamsConfig;\n\tstatic override type() {\n\t\treturn 'clothSolverStepSimulation';\n\t}\n\n\toverride initializeNode() {\n\t\tthis.io.inputs.setNamedInputConnectionPoints([\n\t\t\tnew JsConnectionPoint(TRIGGER_CONNECTION_NAME, JsConnectionPointType.TRIGGER, CONNECTION_OPTIONS),\n\t\t\tnew JsConnectionPoint(JsConnectionPointType.OBJECT_3D, JsConnectionPointType.OBJECT_3D, CONNECTION_OPTIONS),\n\t\t]);\n\n\t\tthis.io.outputs.setNamedOutputConnectionPoints([\n\t\t\tnew JsConnectionPoint(TRIGGER_CONNECTION_NAME, JsConnectionPointType.TRIGGER),\n\t\t\tnew JsConnectionPoint(JsConnectionPointType.OBJECT_3D, JsConnectionPointType.OBJECT_3D),\n\t\t\tnew JsConnectionPoint(ClothSolverStepSimulationOutput.TEXTURE_SIZE, JsConnectionPointType.VECTOR2),\n\t\t\tnew JsConnectionPoint(ClothSolverStepSimulationOutput.TEXTURE_POSITION0, JsConnectionPointType.TEXTURE),\n\t\t\tnew JsConnectionPoint(ClothSolverStepSimulationOutput.TEXTURE_POSITION1, JsConnectionPointType.TEXTURE),\n\t\t\tnew JsConnectionPoint(ClothSolverStepSimulationOutput.TEXTURE_NORMAL, JsConnectionPointType.TEXTURE),\n\t\t\tnew JsConnectionPoint(ClothSolverStepSimulationOutput.MATERIAL_INTEGRATION, JsConnectionPointType.MATERIAL),\n\t\t\t//\n\t\t\t// ...ADDITIONAL_TEXTURE_OUTPUTS.map(\n\t\t\t// \t(outputName) => new JsConnectionPoint(outputName, JsConnectionPointType.TEXTURE)\n\t\t\t// ),\n\t\t]);\n\t}\n\n\toverride setLines(linesController: JsLinesCollectionController) {\n\t\tthis._addRefs(linesController);\n\t\tsetObject3DOutputLine(this, linesController);\n\t}\n\n\toverride setTriggerableLines(linesController: JsLinesCollectionController) {\n\t\tconst object3D = inputObject3D(this, linesController);\n\t\tconst stepsCount = this.variableForInputParam(linesController, this.p.stepsCount);\n\t\tconst constraintInfluence = this.variableForInputParam(linesController, this.p.constraintInfluence);\n\t\tconst viscosity = this.variableForInputParam(linesController, this.p.viscosity);\n\t\tconst spring = this.variableForInputParam(linesController, this.p.spring);\n\n\t\tconst configRef = this._addRefs(linesController);\n\n\t\tconst func = Poly.namedFunctionsRegister.getFunction('clothSolverStepSimulation', this, linesController);\n\n\t\tconst bodyLine = func.asString(\n\t\t\tobject3D,\n\t\t\tstepsCount,\n\t\t\tconstraintInfluence,\n\t\t\tviscosity,\n\t\t\tspring,\n\t\t\tthis._refToString(configRef)\n\t\t);\n\t\tlinesController.addTriggerableLines(this, [bodyLine]);\n\t}\n\tprivate _refToString(refs: ClothMaterialUniformConfigRefString): string {\n\t\tconst keys = Object.keys(refs);\n\t\tconst data: string[] = [];\n\t\tfor (const key of keys) {\n\t\t\tdata.push(`${key}:this.${(refs as any)[key]}`);\n\t\t}\n\t\treturn `{${data.join(',')}}`;\n\t}\n\n\tprivate _addRefs(linesController: JsLinesCollectionController): ClothMaterialUniformConfigRefString {\n\t\tconst tSize = this.jsVarName(ClothSolverStepSimulationOutput.TEXTURE_SIZE);\n\t\tconst tPosition0 = this.jsVarName(ClothSolverStepSimulationOutput.TEXTURE_POSITION0);\n\t\tconst tPosition1 = this.jsVarName(ClothSolverStepSimulationOutput.TEXTURE_POSITION1);\n\t\tconst tNormal = this.jsVarName(ClothSolverStepSimulationOutput.TEXTURE_NORMAL);\n\t\t//\n\t\tconst tOriginalRT = this.jsVarName(ClothSolverStepSimulationOutput.TEXTURE_ORIGINAL_RT);\n\t\tconst tViscositySpringT = this.jsVarName(ClothSolverStepSimulationOutput.TEXTURE_VISCOSITY_SPRING_T);\n\t\tconst tPreviousRT0 = this.jsVarName(ClothSolverStepSimulationOutput.TEXTURE_PREVIOUS_RT0);\n\t\tconst tPreviousRT1 = this.jsVarName(ClothSolverStepSimulationOutput.TEXTURE_PREVIOUS_RT1);\n\t\tconst tTargetRT0 = this.jsVarName(ClothSolverStepSimulationOutput.TEXTURE_TARGET_RT0);\n\t\tconst tTargetRT1 = this.jsVarName(ClothSolverStepSimulationOutput.TEXTURE_TARGET_RT1);\n\n\t\tconst tNormalsRT = this.jsVarName(ClothSolverStepSimulationOutput.TEXTURE_NORMALS_RT);\n\t\tconst tPositionRT0 = this.jsVarName(ClothSolverStepSimulationOutput.TEXTURE_POSITION_RT0);\n\t\tconst tPositionRT1 = this.jsVarName(ClothSolverStepSimulationOutput.TEXTURE_POSITION_RT1);\n\n\t\tconst tAdjacentsRT0 = this.jsVarName(ClothSolverStepSimulationOutput.TEXTURE_ADJACENT_RT0);\n\t\tconst tAdjacentsRT1 = this.jsVarName(ClothSolverStepSimulationOutput.TEXTURE_ADJACENT_RT1);\n\t\tconst tDistanceRT0 = this.jsVarName(ClothSolverStepSimulationOutput.TEXTURE_DISTANCE_RT0);\n\t\tconst tDistanceRT1 = this.jsVarName(ClothSolverStepSimulationOutput.TEXTURE_DISTANCE_RT1);\n\n\t\tconst integrationMat = this.jsVarName(ClothSolverStepSimulationOutput.MATERIAL_INTEGRATION);\n\n\t\t// If those are Ref<>, it seems to not update the uniforms later,\n\t\t// so we have constants for now\n\t\tlinesController.addDefinitions(this, [\n\t\t\tnew ConstantJsDefinition(this, linesController, JsConnectionPointType.VECTOR2, tSize, `null`),\n\t\t]);\n\n\t\tconst textures = [\n\t\t\ttPosition0,\n\t\t\ttPosition1,\n\t\t\ttNormal,\n\t\t\t//\n\t\t\ttOriginalRT,\n\t\t\ttViscositySpringT,\n\t\t\ttPreviousRT0,\n\t\t\ttPreviousRT1,\n\t\t\ttTargetRT0,\n\t\t\ttTargetRT1,\n\t\t\ttNormalsRT,\n\t\t\ttPositionRT0,\n\t\t\ttPositionRT1,\n\t\t\ttAdjacentsRT0,\n\t\t\ttAdjacentsRT1,\n\t\t\ttDistanceRT0,\n\t\t\ttDistanceRT1,\n\t\t];\n\t\tconst materials = [integrationMat];\n\t\tfor (const texture of textures) {\n\t\t\tlinesController.addDefinitions(this, [\n\t\t\t\tnew ConstantJsDefinition(this, linesController, JsConnectionPointType.TEXTURE, texture, `null`),\n\t\t\t]);\n\t\t}\n\n\t\tfor (const material of materials) {\n\t\t\tlinesController.addDefinitions(this, [\n\t\t\t\tnew ConstantJsDefinition(this, linesController, JsConnectionPointType.MATERIAL, material, `null`),\n\t\t\t]);\n\t\t}\n\n\t\tconst ref: ClothMaterialUniformConfigRefString = {\n\t\t\ttSize,\n\t\t\ttPosition0,\n\t\t\ttPosition1,\n\t\t\ttNormal,\n\t\t\ttOriginalRT,\n\t\t\ttViscositySpringT,\n\t\t\ttPreviousRT0,\n\t\t\ttPreviousRT1,\n\t\t\ttTargetRT0,\n\t\t\ttTargetRT1,\n\t\t\ttNormalsRT,\n\t\t\ttPositionRT0,\n\t\t\ttPositionRT1,\n\t\t\ttAdjacentsRT0,\n\t\t\ttAdjacentsRT1,\n\t\t\ttDistanceRT0,\n\t\t\ttDistanceRT1,\n\t\t\tintegrationMat,\n\t\t};\n\t\treturn ref;\n\t}\n}\n","/**\n * compares 2 input values and generates a boolean value\n *\n * @remarks\n *\n * This node is frequently used with the [js/TwoWaySwitch](/docs/nodes/js/TwoWaySwitch)\n *\n */\n\nimport {TypedJsNode} from './_Base';\nimport {ParamConfig, NodeParamsConfig} from '../utils/params/ParamsConfig';\nimport {JsConnectionPointType, JsConnectionPointTypeFromArrayTypeMap} from '../utils/io/connections/Js';\nimport {JsLinesCollectionController} from './code/utils/JsLinesCollectionController';\nimport {createVariable} from './code/assemblers/_BaseJsPersistedConfigUtils';\nimport {componentsForType} from '../../functions/_VectorUtils';\n\nconst ALLOWED_TYPES = [\n\tJsConnectionPointType.BOOLEAN,\n\tJsConnectionPointType.INT,\n\tJsConnectionPointType.COLOR,\n\tJsConnectionPointType.FLOAT,\n\tJsConnectionPointType.STRING,\n\tJsConnectionPointType.VECTOR2,\n\tJsConnectionPointType.VECTOR3,\n\tJsConnectionPointType.VECTOR4,\n];\n\nexport enum JsCompareTestName {\n\tEQUAL = 'Equal',\n\tLESS_THAN = 'Less Than',\n\tGREATER_THAN = 'Greater Than',\n\tLESS_THAN_OR_EQUAL = 'Less Than Or Equal',\n\tGREATER_THAN_OR_EQUAL = 'Greater Than Or Equal',\n\tNOT_EQUAL = 'Not Equal',\n}\nenum JsCompareTestOperation {\n\tEQUAL = '==',\n\tLESS_THAN = '<',\n\tGREATER_THAN = '>',\n\tLESS_THAN_OR_EQUAL = '<=',\n\tGREATER_THAN_OR_EQUAL = '>=',\n\tNOT_EQUAL = '!=',\n}\n\nconst TEST_NAMES: JsCompareTestName[] = [\n\tJsCompareTestName.EQUAL,\n\tJsCompareTestName.LESS_THAN,\n\tJsCompareTestName.GREATER_THAN,\n\tJsCompareTestName.LESS_THAN_OR_EQUAL,\n\tJsCompareTestName.GREATER_THAN_OR_EQUAL,\n\tJsCompareTestName.NOT_EQUAL,\n];\nconst TEST_OPERATIONS_FLOAT: JsCompareTestOperation[] = [\n\tJsCompareTestOperation.EQUAL,\n\tJsCompareTestOperation.LESS_THAN,\n\tJsCompareTestOperation.GREATER_THAN,\n\tJsCompareTestOperation.LESS_THAN_OR_EQUAL,\n\tJsCompareTestOperation.GREATER_THAN_OR_EQUAL,\n\tJsCompareTestOperation.NOT_EQUAL,\n];\nfunction singleElementComparison(value0: string, value1: string, operation: JsCompareTestOperation) {\n\treturn `${value0} ${operation} ${value1}`;\n}\n\nconst OUTPUT_NAME = 'val';\nenum CompareInputName {\n\tVALUE0 = 'value0',\n\tVALUE1 = 'value1',\n}\n// const EXPECTED_INPUT_NAMES = ['value0', 'value1'];\nclass CompareJsParamsConfig extends NodeParamsConfig {\n\ttest = ParamConfig.INTEGER(1, {\n\t\tmenu: {\n\t\t\tentries: TEST_NAMES.map((name, i) => {\n\t\t\t\tconst operator = TEST_OPERATIONS_FLOAT[i];\n\t\t\t\tconst label = `${operator.padEnd(2, ' ')} (${name})`;\n\t\t\t\treturn {name: label, value: i};\n\t\t\t}),\n\t\t},\n\t});\n}\nconst ParamsConfig = new CompareJsParamsConfig();\nexport class CompareJsNode extends TypedJsNode<CompareJsParamsConfig> {\n\toverride paramsConfig = ParamsConfig;\n\tstatic override type() {\n\t\treturn 'compare';\n\t}\n\toverride initializeNode() {\n\t\tsuper.initializeNode();\n\n\t\tthis.io.connection_points.spare_params.setInputlessParamNames(['test']);\n\n\t\tthis.io.connection_points.initializeNode();\n\t\tthis.io.connection_points.set_input_name_function(this._expectedInputName.bind(this));\n\t\tthis.io.connection_points.set_output_name_function(this._expectedOutputName.bind(this));\n\t\tthis.io.connection_points.set_expected_input_types_function(this._expectedInputTypes.bind(this));\n\t\tthis.io.connection_points.set_expected_output_types_function(this._expectedOutputTypes.bind(this));\n\t}\n\tsetTestName(test: JsCompareTestName) {\n\t\tthis.p.test.set(TEST_NAMES.indexOf(test));\n\t}\n\ttestName() {\n\t\treturn TEST_NAMES[this.pv.test];\n\t}\n\toperator() {\n\t\treturn TEST_OPERATIONS_FLOAT[this.pv.test];\n\t}\n\n\tprotected _expectedInputName(index: number) {\n\t\treturn [CompareInputName.VALUE0, CompareInputName.VALUE1][index];\n\t}\n\tprotected _expectedInputTypes() {\n\t\tlet first_input_type = this.io.connection_points.first_input_connection_type();\n\t\tconst connectionPoints = this.io.inputs.namedInputConnectionPoints();\n\t\tif (first_input_type && connectionPoints) {\n\t\t\tif (!ALLOWED_TYPES.includes(first_input_type)) {\n\t\t\t\t// if the first input type is not allowed, either leave the connection point as is,\n\t\t\t\t// or use the default if there is none\n\t\t\t\tconst first_connection = connectionPoints[0];\n\t\t\t\tif (first_connection) {\n\t\t\t\t\tfirst_input_type = first_connection.type();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tconst type = first_input_type || JsConnectionPointType.FLOAT;\n\t\tconst boundType = JsConnectionPointTypeFromArrayTypeMap[type];\n\t\treturn [type, boundType];\n\t}\n\tprivate _expectedOutputTypes() {\n\t\treturn [JsConnectionPointType.BOOLEAN];\n\t}\n\tprivate _expectedOutputName(index: number) {\n\t\treturn OUTPUT_NAME;\n\t}\n\n\toverride setLines(shadersCollectionController: JsLinesCollectionController) {\n\t\tconst varName = this.jsVarName(this._expectedOutputName(0));\n\n\t\tconst inputType = this._expectedInputTypes()[0];\n\t\tconst variable = createVariable(inputType);\n\t\tif (variable) {\n\t\t\tshadersCollectionController.addVariable(this, variable);\n\t\t}\n\n\t\tconst operation = this.operator();\n\t\tconst value0 = this.variableForInput(shadersCollectionController, CompareInputName.VALUE0);\n\t\tconst value1 = this.variableForInput(shadersCollectionController, CompareInputName.VALUE1);\n\n\t\tconst components = componentsForType(inputType);\n\t\tconst mainFunction =\n\t\t\tcomponents != null && components.length > 0\n\t\t\t\t? components\n\t\t\t\t\t\t.map((c) => singleElementComparison(`${value0}.${c}`, `${value1}.${c}`, operation))\n\t\t\t\t\t\t.join(' && ')\n\t\t\t\t: singleElementComparison(value0, value1, operation);\n\n\t\tshadersCollectionController.addBodyOrComputed(this, [{dataType: inputType, varName, value: mainFunction}]);\n\t}\n}\n","/**\n * Creates a constant\n *\n *\n */\nimport {TypedJsNode} from './_Base';\nimport {ThreeToGl} from '../../../core/ThreeToGl';\n// import {BaseParamType} from '../../params/_Base';\nimport {NodeParamsConfig, ParamConfig} from '../utils/params/ParamsConfig';\nimport {JsLinesCollectionController} from './code/utils/JsLinesCollectionController';\nimport {CoreType} from '../../../core/Type';\nimport {PolyDictionary} from '../../../types/GlobalTypes';\nimport {JsConnectionPointType, JS_CONNECTION_TYPES_FOR_CONSTANT} from '../utils/io/connections/Js';\nimport {ConstantJsDefinition} from './utils/JsDefinition';\n\nfunction typedVisibleOptions(type: JsConnectionPointType, otherParamVal: PolyDictionary<number | boolean> = {}) {\n\tconst val = JS_CONNECTION_TYPES_FOR_CONSTANT.indexOf(type);\n\treturn {visibleIf: {type: val, ...otherParamVal}};\n}\n\nclass ConstantJsParamsConfig extends NodeParamsConfig {\n\ttype = ParamConfig.INTEGER(JS_CONNECTION_TYPES_FOR_CONSTANT.indexOf(JsConnectionPointType.FLOAT), {\n\t\tmenu: {\n\t\t\tentries: JS_CONNECTION_TYPES_FOR_CONSTANT.map((name, i) => {\n\t\t\t\treturn {name: name, value: i};\n\t\t\t}),\n\t\t},\n\t});\n\tboolean = ParamConfig.BOOLEAN(0, typedVisibleOptions(JsConnectionPointType.BOOLEAN));\n\tcolor = ParamConfig.COLOR([0, 0, 0], typedVisibleOptions(JsConnectionPointType.COLOR));\n\tfloat = ParamConfig.FLOAT(0, typedVisibleOptions(JsConnectionPointType.FLOAT));\n\tint = ParamConfig.INTEGER(0, typedVisibleOptions(JsConnectionPointType.INT));\n\tstring = ParamConfig.STRING('', typedVisibleOptions(JsConnectionPointType.STRING));\n\tvector2 = ParamConfig.VECTOR2([0, 0], typedVisibleOptions(JsConnectionPointType.VECTOR2));\n\tvector3 = ParamConfig.VECTOR3([0, 0, 0], typedVisibleOptions(JsConnectionPointType.VECTOR3));\n\tvector4 = ParamConfig.VECTOR4([0, 0, 0, 0], typedVisibleOptions(JsConnectionPointType.VECTOR4));\n}\nconst ParamsConfig = new ConstantJsParamsConfig();\nexport class ConstantJsNode extends TypedJsNode<ConstantJsParamsConfig> {\n\toverride paramsConfig = ParamsConfig;\n\tstatic override type() {\n\t\treturn 'constant';\n\t}\n\tstatic readonly OUTPUT_NAME = 'val';\n\toverride initializeNode() {\n\t\tthis.io.connection_points.set_output_name_function((index: number) => ConstantJsNode.OUTPUT_NAME);\n\t\tthis.io.connection_points.set_expected_input_types_function(() => []);\n\t\tthis.io.connection_points.set_expected_output_types_function(() => [this._currentConnectionType()]);\n\t}\n\n\toverride setLines(linesController: JsLinesCollectionController) {\n\t\tconst param = this.currentParam();\n\t\tif (!param) {\n\t\t\tconsole.warn(`no param found for constant node for type '${this.pv.type}'`);\n\t\t\treturn;\n\t\t}\n\t\tconst value = this.currentValue();\n\t\tif (value == null) {\n\t\t\tconsole.warn(`no value found for constant node for type '${this.pv.type}'`);\n\t\t\treturn;\n\t\t}\n\n\t\tconst out = this.jsVarName(ConstantJsNode.OUTPUT_NAME);\n\t\tconst varName = this.variableForInputParam(linesController, param);\n\n\t\tlinesController.addDefinitions(this, [\n\t\t\tnew ConstantJsDefinition(this, linesController, this._currentConnectionType(), out, varName),\n\t\t]);\n\t}\n\n\tprivate _currentConnectionType() {\n\t\tif (this.pv.type == null) {\n\t\t\tconsole.warn('constant gl node type is null', this.path());\n\t\t}\n\t\tconst connectionType = JS_CONNECTION_TYPES_FOR_CONSTANT[this.pv.type] || JsConnectionPointType.FLOAT;\n\t\tif (connectionType == null) {\n\t\t\tconsole.warn(`constant gl node type if not valid (${this.pv.type})`, this.path());\n\t\t}\n\t\treturn connectionType;\n\t}\n\n\tcurrentParam() {\n\t\tconst type = JS_CONNECTION_TYPES_FOR_CONSTANT[this.pv.type];\n\t\tswitch (type) {\n\t\t\tcase JsConnectionPointType.BOOLEAN: {\n\t\t\t\treturn this.p.boolean;\n\t\t\t}\n\t\t\tcase JsConnectionPointType.COLOR: {\n\t\t\t\treturn this.p.color;\n\t\t\t}\n\t\t\tcase JsConnectionPointType.FLOAT: {\n\t\t\t\treturn this.p.float;\n\t\t\t}\n\t\t\tcase JsConnectionPointType.INT: {\n\t\t\t\treturn this.p.int;\n\t\t\t}\n\t\t\tcase JsConnectionPointType.STRING: {\n\t\t\t\treturn this.p.string;\n\t\t\t}\n\t\t\tcase JsConnectionPointType.VECTOR2: {\n\t\t\t\treturn this.p.vector2;\n\t\t\t}\n\t\t\tcase JsConnectionPointType.VECTOR3: {\n\t\t\t\treturn this.p.vector3;\n\t\t\t}\n\t\t\tcase JsConnectionPointType.VECTOR4: {\n\t\t\t\treturn this.p.vector4;\n\t\t\t}\n\t\t}\n\t\tconsole.warn(`constant with type '${type}' not yet implemented`);\n\t\t// we should never run this\n\t\treturn this.p.boolean;\n\t}\n\t// private _currentVarName(): string {\n\t// \treturn this.jsVarName(ConstantJsNode.OUTPUT_NAME);\n\t// }\n\tcurrentValue() {\n\t\tconst param = this.currentParam();\n\t\tif (param) {\n\t\t\tlet value = ThreeToGl.any(param.value);\n\t\t\t// ensure that it is an integer when needed\n\t\t\t// as ThreeToGl.any can only detect if this is a number for now\n\t\t\t// and therefore does not make the distinction between float and int\n\t\t\tif (param.name() == this.p.int.name() && CoreType.isNumber(param.value)) {\n\t\t\t\tvalue = ThreeToGl.integer(param.value);\n\t\t\t}\n\t\t\treturn value;\n\t\t}\n\t}\n\n\tsetJsType(type: JsConnectionPointType) {\n\t\tthis.p.type.set(JS_CONNECTION_TYPES_FOR_CONSTANT.indexOf(type));\n\t}\n}\n","/**\n * gets the 2D position of the cursor\n *\n * @remarks\n *\n *\n */\n\nimport {NodeParamsConfig, ParamConfig} from '../utils/params/ParamsConfig';\nimport {JsConnectionPoint, JsConnectionPointType} from '../utils/io/connections/Js';\nimport {JsType} from '../../poly/registers/nodes/types/Js';\nimport {BaseUserInputJsNode} from './_BaseUserInput';\nimport {CoreEventEmitter, EVENT_EMITTERS, EVENT_EMITTER_PARAM_MENU_OPTIONS} from '../../../core/event/CoreEventEmitter';\nimport {ComputedValueJsDefinition} from './utils/JsDefinition';\nimport {JsLinesCollectionController} from './code/utils/JsLinesCollectionController';\nimport {EvaluatorEventData} from './code/assemblers/actor/ActorEvaluator';\nimport {Poly} from '../../Poly';\nimport {PointerEventType} from '../../../core/event/PointerEventType';\n\nconst OUTPUT_NAME = 'cursor';\nclass CursorJsParamsConfig extends NodeParamsConfig {\n\t/** @param set which element triggers the event */\n\telement = ParamConfig.INTEGER(EVENT_EMITTERS.indexOf(CoreEventEmitter.CANVAS), {\n\t\t...EVENT_EMITTER_PARAM_MENU_OPTIONS,\n\t});\n\t/** @param cursor */\n\t// cursor = ParamConfig.VECTOR2([0, 0]);\n}\nconst ParamsConfig = new CursorJsParamsConfig();\nexport class CursorJsNode extends BaseUserInputJsNode<CursorJsParamsConfig> {\n\toverride paramsConfig = ParamsConfig;\n\tstatic override type(): JsType.CURSOR {\n\t\treturn JsType.CURSOR;\n\t}\n\t// userInputEventNames() {\n\t// \treturn ['pointermove'];\n\t// }\n\n\toverride eventData(): EvaluatorEventData | undefined {\n\t\treturn {\n\t\t\ttype: PointerEventType.pointermove,\n\t\t\temitter: this.eventEmitter(),\n\t\t\tjsType: JsType.CURSOR,\n\t\t};\n\t}\n\toverride eventEmitter() {\n\t\treturn EVENT_EMITTERS[this.pv.element];\n\t}\n\tsetEventEmitter(emitter: CoreEventEmitter) {\n\t\tthis.p.element.set(EVENT_EMITTERS.indexOf(emitter));\n\t}\n\toverride initializeNode() {\n\t\tthis.io.connection_points.spare_params.setInputlessParamNames(['element']);\n\t\tthis.io.outputs.setNamedOutputConnectionPoints([\n\t\t\tnew JsConnectionPoint(OUTPUT_NAME, JsConnectionPointType.VECTOR2),\n\t\t]);\n\t}\n\toverride setLines(shadersCollectionController: JsLinesCollectionController) {\n\t\tconst out = this.jsVarName(OUTPUT_NAME);\n\n\t\tconst _cursor = Poly.namedFunctionsRegister.getFunction('globalsCursor', this, shadersCollectionController);\n\t\tshadersCollectionController.addDefinitions(this, [\n\t\t\tnew ComputedValueJsDefinition(\n\t\t\t\tthis,\n\t\t\t\tshadersCollectionController,\n\t\t\t\tJsConnectionPointType.VECTOR2,\n\t\t\t\tout,\n\t\t\t\t_cursor.asString()\n\t\t\t),\n\t\t]);\n\t}\n}\n","/**\n * applies an easing function to the input\n *\n *\n *\n */\nimport {isJsConnectionPointPrimitive, JsConnectionPoint, JsConnectionPointType} from '../utils/io/connections/Js';\nimport {NodeParamsConfig, ParamConfig} from '../utils/params/ParamsConfig';\nimport {TypedJsNode} from './_Base';\nimport {EASING_NAMES} from '../../../core/math/Easing';\nimport {createVariable} from './code/assemblers/_BaseJsPersistedConfigUtils';\nimport {JsLinesCollectionController} from './code/utils/JsLinesCollectionController';\nimport {Poly} from '../../Poly';\nimport {_vectorFunctionName_1} from '../../functions/_MathGeneric';\n\ntype AllowedInputType =\n\t| JsConnectionPointType.FLOAT\n\t| JsConnectionPointType.VECTOR2\n\t| JsConnectionPointType.VECTOR3\n\t| JsConnectionPointType.VECTOR4;\nconst ALLOWED_INPUTS: AllowedInputType[] = [\n\tJsConnectionPointType.FLOAT,\n\tJsConnectionPointType.VECTOR2,\n\tJsConnectionPointType.VECTOR3,\n\tJsConnectionPointType.VECTOR4,\n];\n\nconst INPUT_NAME = 'in';\nconst OUTPUT_NAME = 'out';\nconst defaultEaseType = EASING_NAMES.indexOf('easeIO3');\nclass EasingJsParamsConfig extends NodeParamsConfig {\n\ttype = ParamConfig.INTEGER(defaultEaseType, {\n\t\tmenu: {\n\t\t\tentries: EASING_NAMES.map((name, i) => {\n\t\t\t\treturn {name: name, value: i};\n\t\t\t}),\n\t\t},\n\t});\n\t// input = ParamConfig.FLOAT(0);\n}\nconst ParamsConfig = new EasingJsParamsConfig();\n\nexport class EasingJsNode extends TypedJsNode<EasingJsParamsConfig> {\n\toverride readonly paramsConfig = ParamsConfig;\n\tstatic override type() {\n\t\treturn 'easing';\n\t}\n\n\toverride initializeNode() {\n\t\tsuper.initializeNode();\n\t\tthis.io.connection_points.spare_params.setInputlessParamNames(['type']);\n\t\tthis.io.connection_points.set_expected_input_types_function(this._expectedInputTypes.bind(this));\n\t\tthis.io.connection_points.set_expected_output_types_function(this._expectedOutputTypes.bind(this));\n\t\tthis.io.connection_points.set_input_name_function(this._expectedInputName.bind(this));\n\t\tthis.io.connection_points.set_output_name_function(this._expectedOutputName.bind(this));\n\n\t\tthis.io.outputs.setNamedOutputConnectionPoints([\n\t\t\tnew JsConnectionPoint(OUTPUT_NAME, JsConnectionPointType.FLOAT),\n\t\t]);\n\t}\n\n\tprivate _expectedInputTypes() {\n\t\tconst type = (this.io.connection_points.first_input_connection_type() ||\n\t\t\tJsConnectionPointType.FLOAT) as AllowedInputType;\n\t\tif (ALLOWED_INPUTS.includes(type)) {\n\t\t\treturn [type];\n\t\t} else {\n\t\t\treturn [JsConnectionPointType.FLOAT];\n\t\t}\n\t}\n\tprivate _expectedOutputTypes() {\n\t\treturn [this._expectedInputTypes()[0]];\n\t}\n\tprivate _expectedInputName(index: number): string {\n\t\treturn INPUT_NAME;\n\t}\n\tprivate _expectedOutputName(index: number): string {\n\t\treturn OUTPUT_NAME;\n\t}\n\n\toverride setLines(shadersCollectionController: JsLinesCollectionController) {\n\t\tconst varName = this.jsVarName(this._expectedOutputName(0));\n\n\t\tconst inputType = this._expectedInputTypes()[0];\n\t\tconst variable = createVariable(inputType);\n\t\tconst tmpVarName = variable ? shadersCollectionController.addVariable(this, variable) : undefined;\n\n\t\tconst inputValue = this.variableForInput(shadersCollectionController, INPUT_NAME);\n\t\tconst functionName = EASING_NAMES[this.pv.type];\n\t\tconst func = Poly.namedFunctionsRegister.getFunction(functionName, this, shadersCollectionController);\n\n\t\tconst isPrimitive = isJsConnectionPointPrimitive(inputType);\n\n\t\t// primitive\n\t\tif (isPrimitive) {\n\t\t\treturn shadersCollectionController.addBodyOrComputed(this, [\n\t\t\t\t{dataType: JsConnectionPointType.FLOAT, varName, value: func.asString(inputValue)},\n\t\t\t]);\n\t\t}\n\n\t\t// color / vector\n\t\tconst vectorFunctionName = _vectorFunctionName_1(inputType);\n\t\tif (vectorFunctionName && tmpVarName) {\n\t\t\tfunc.asString('');\n\t\t\tconst vectorFunc = Poly.namedFunctionsRegister.getFunction(\n\t\t\t\tvectorFunctionName,\n\t\t\t\tthis,\n\t\t\t\tshadersCollectionController\n\t\t\t);\n\t\t\treturn shadersCollectionController.addBodyOrComputed(this, [\n\t\t\t\t{\n\t\t\t\t\tdataType: JsConnectionPointType.FLOAT,\n\t\t\t\t\tvarName,\n\t\t\t\t\tvalue: vectorFunc.asString(...[functionName, inputValue, tmpVarName]),\n\t\t\t\t},\n\t\t\t]);\n\t\t}\n\t}\n}\n","/**\n * get objects from a geometry node\n *\n *\n */\nimport {TypedJsNode} from './_Base';\nimport {NodeParamsConfig} from '../utils/params/ParamsConfig';\nimport {JsConnectionPoint, JsConnectionPointType, JS_CONNECTION_POINT_IN_NODE_DEF} from '../utils/io/connections/Js';\nimport {Poly} from '../../Poly';\nimport {JsLinesCollectionController} from './code/utils/JsLinesCollectionController';\n// import {NodeContext} from '../../poly/NodeContext';\nimport {ConstantJsDefinition} from './utils/JsDefinition';\nimport {inputNode} from './_BaseObject3D';\n\nconst CONNECTION_OPTIONS = JS_CONNECTION_POINT_IN_NODE_DEF;\n\nclass GetGeometryNodeObjectsJsParamsConfig extends NodeParamsConfig {\n\t/** @param geometry node */\n\t// Node = ParamConfig.NODE_PATH('', {\n\t// \tnodeSelection: {\n\t// \t\tcontext: NodeContext.SOP,\n\t// \t},\n\t// \tdependentOnFoundNode: false,\n\t// \tcomputeOnDirty: true,\n\t// });\n}\nconst ParamsConfig = new GetGeometryNodeObjectsJsParamsConfig();\n\nexport class GetGeometryNodeObjectsJsNode extends TypedJsNode<GetGeometryNodeObjectsJsParamsConfig> {\n\toverride readonly paramsConfig = ParamsConfig;\n\tstatic override type() {\n\t\treturn 'getGeometryNodeObjects';\n\t}\n\n\toverride initializeNode() {\n\t\tthis.io.inputs.setNamedInputConnectionPoints([\n\t\t\tnew JsConnectionPoint(JsConnectionPointType.TRIGGER, JsConnectionPointType.TRIGGER, CONNECTION_OPTIONS),\n\t\t\tnew JsConnectionPoint(JsConnectionPointType.NODE, JsConnectionPointType.NODE, CONNECTION_OPTIONS),\n\t\t]);\n\t\tthis.io.outputs.setNamedOutputConnectionPoints([\n\t\t\tnew JsConnectionPoint(JsConnectionPointType.TRIGGER, JsConnectionPointType.TRIGGER, CONNECTION_OPTIONS),\n\t\t\tnew JsConnectionPoint(JsConnectionPointType.OBJECT_3D_ARRAY, JsConnectionPointType.OBJECT_3D_ARRAY),\n\t\t]);\n\t}\n\n\toverride setLines(linesController: JsLinesCollectionController) {\n\t\tconst usedOutputNames = this.io.outputs.used_output_names();\n\t\tif (usedOutputNames.includes(JsConnectionPointType.OBJECT_3D_ARRAY)) {\n\t\t\tthis._addObjectsRef(linesController);\n\n\t\t\tif (!usedOutputNames.includes(JsConnectionPointType.TRIGGER)) {\n\t\t\t\tthis.setTriggeringLines(linesController, '');\n\t\t\t}\n\t\t}\n\t}\n\toverride setTriggerableLines(linesController: JsLinesCollectionController): void {\n\t\tconst node = inputNode(this, linesController);\n\n\t\tconst outObjects = this._addObjectsRef(linesController);\n\n\t\tconst func = Poly.namedFunctionsRegister.getFunction('getGeometryNodeObjects', this, linesController);\n\t\tconst bodyLine = func.asString(node, `this.${outObjects}.value`);\n\t\tlinesController.addTriggerableLines(this, [bodyLine], {async: true});\n\t}\n\n\tprivate _addObjectsRef(linesController: JsLinesCollectionController) {\n\t\tconst outObjects = this.jsVarName(JsConnectionPointType.OBJECT_3D_ARRAY);\n\t\tlinesController.addDefinitions(this, [\n\t\t\t// do not use a ref, as it makes the object reactive\n\t\t\tnew ConstantJsDefinition(this, linesController, JsConnectionPointType.OBJECT_3D_ARRAY, outObjects, `[]`),\n\t\t]);\n\t\treturn outObjects;\n\t}\n}\n","/**\n * get a material\n *\n *\n */\n\nimport {TypedJsNode} from './_Base';\nimport {NodeParamsConfig, ParamConfig} from '../utils/params/ParamsConfig';\nimport {JsConnectionPoint, JsConnectionPointType} from '../utils/io/connections/Js';\nimport {NodeContext} from '../../poly/NodeContext';\nimport {JsLinesCollectionController} from './code/utils/JsLinesCollectionController';\nimport {Poly} from '../../Poly';\nclass GetMaterialJsParamsConfig extends NodeParamsConfig {\n\t/** @param the material node */\n\tnode = ParamConfig.NODE_PATH('', {\n\t\tnodeSelection: {\n\t\t\tcontext: NodeContext.MAT,\n\t\t},\n\t\tdependentOnFoundNode: false,\n\t\tcomputeOnDirty: true,\n\t});\n}\nconst ParamsConfig = new GetMaterialJsParamsConfig();\n\nexport class GetMaterialJsNode extends TypedJsNode<GetMaterialJsParamsConfig> {\n\toverride readonly paramsConfig = ParamsConfig;\n\tstatic override type() {\n\t\treturn 'getMaterial';\n\t}\n\n\toverride initializeNode() {\n\t\tthis.io.outputs.setNamedOutputConnectionPoints([\n\t\t\tnew JsConnectionPoint(JsConnectionPointType.MATERIAL, JsConnectionPointType.MATERIAL),\n\t\t]);\n\t}\n\n\toverride setLines(shadersCollectionController: JsLinesCollectionController) {\n\t\tconst node = this.pv.node.node();\n\t\tif (!(node && node.context() == NodeContext.MAT)) {\n\t\t\treturn;\n\t\t}\n\t\tconst nodePath = `'${node.path()}'`;\n\t\tconst varName = this.jsVarName(JsConnectionPointType.MATERIAL);\n\t\tconst func = Poly.namedFunctionsRegister.getFunction('getMaterial', this, shadersCollectionController);\n\t\tshadersCollectionController.addBodyOrComputed(this, [\n\t\t\t{\n\t\t\t\tdataType: JsConnectionPointType.MATERIAL,\n\t\t\t\tvarName,\n\t\t\t\tvalue: func.asString(nodePath),\n\t\t\t},\n\t\t]);\n\t}\n}\n","/**\n * Get a node\n *\n *\n */\nimport {TypedJsNode} from './_Base';\nimport {NodeParamsConfig, ParamConfig} from '../utils/params/ParamsConfig';\nimport {JsConnectionPoint, JsConnectionPointType, JS_CONNECTION_POINT_IN_NODE_DEF} from '../utils/io/connections/Js';\nimport {JsLinesCollectionController} from './code/utils/JsLinesCollectionController';\nimport {Poly} from '../../Poly';\nimport {NodePathParam} from '../../params/NodePath';\nimport {JsType} from '../../poly/registers/nodes/types/Js';\n// import {NodeContext} from '../../poly/NodeContext';\n\nconst CONNECTION_OPTIONS = JS_CONNECTION_POINT_IN_NODE_DEF;\n\nclass GetNodeJsParamsConfig extends NodeParamsConfig {\n\t/** @param parameter to get */\n\tNode = ParamConfig.NODE_PATH('', {\n\t\tdependentOnFoundNode: false,\n\t\t// nodeSelection: {\n\t\t// \tcontext: NodeContext.SOP,\n\t\t// },\n\t\tcomputeOnDirty: false,\n\t});\n}\nconst ParamsConfig = new GetNodeJsParamsConfig();\n\nexport class GetNodeJsNode extends TypedJsNode<GetNodeJsParamsConfig> {\n\toverride readonly paramsConfig = ParamsConfig;\n\tstatic override type() {\n\t\treturn JsType.GET_NODE;\n\t}\n\n\toverride initializeNode() {\n\t\tthis.io.outputs.setNamedOutputConnectionPoints([\n\t\t\tnew JsConnectionPoint(JsConnectionPointType.NODE, JsConnectionPointType.NODE, CONNECTION_OPTIONS),\n\t\t]);\n\t\tthis.io.connection_points.spare_params.setInputlessParamNames([JsConnectionPointType.NODE]);\n\t}\n\n\tsetNodePath(nodePath: string) {\n\t\tthis.p.Node.set(nodePath);\n\t}\n\toverride setLines(linesController: JsLinesCollectionController) {\n\t\tconst out = this.jsVarName(JsConnectionPointType.NODE);\n\n\t\tconst node = (this.params.get(JsConnectionPointType.NODE) as NodePathParam).value.node();\n\t\tif (!node) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst func = Poly.namedFunctionsRegister.getFunction('getNode', this, linesController);\n\t\tconst bodyLine = func.asString(`'${node.path()}'`);\n\t\tlinesController.addBodyOrComputed(this, [\n\t\t\t{dataType: JsConnectionPointType.NODE, varName: out, value: bodyLine},\n\t\t]);\n\t}\n}\n","/**\n * get an object\n *\n *\n */\nimport {TypedJsNode} from './_Base';\nimport {NodeParamsConfig, ParamConfig} from '../utils/params/ParamsConfig';\nimport {JsConnectionPoint, JsConnectionPointType, JS_CONNECTION_POINT_IN_NODE_DEF} from '../utils/io/connections/Js';\nimport {JsLinesCollectionController} from './code/utils/JsLinesCollectionController';\nimport {Poly} from '../../Poly';\nimport {inputObject3D} from './_BaseObject3D';\n\nconst CONNECTION_OPTIONS = JS_CONNECTION_POINT_IN_NODE_DEF;\n\nclass GetObjectJsParamsConfig extends NodeParamsConfig {\n\t/** @param use current object */\n\tgetCurrentObject = ParamConfig.BOOLEAN(1);\n\t/** @param object mask */\n\tmask = ParamConfig.STRING('', {\n\t\tvisibleIf: {\n\t\t\tgetCurrentObject: 0,\n\t\t},\n\t\tobjectMask: true,\n\t});\n}\nconst ParamsConfig = new GetObjectJsParamsConfig();\n\nexport class GetObjectJsNode extends TypedJsNode<GetObjectJsParamsConfig> {\n\toverride readonly paramsConfig = ParamsConfig;\n\tstatic override type() {\n\t\treturn 'getObject';\n\t}\n\n\toverride initializeNode() {\n\t\tthis.io.inputs.setNamedInputConnectionPoints([\n\t\t\tnew JsConnectionPoint('mask', JsConnectionPointType.STRING, CONNECTION_OPTIONS),\n\t\t]);\n\n\t\tthis.io.outputs.setNamedOutputConnectionPoints([\n\t\t\tnew JsConnectionPoint(JsConnectionPointType.OBJECT_3D, JsConnectionPointType.OBJECT_3D),\n\t\t]);\n\t}\n\toverride setLines(linesController: JsLinesCollectionController) {\n\t\tconst object3D = inputObject3D(this, linesController);\n\t\tconst getCurrentObject = this.variableForInputParam(linesController, this.p.getCurrentObject);\n\t\tconst mask = this.variableForInputParam(linesController, this.p.mask);\n\t\tconst out = this.jsVarName(JsConnectionPointType.OBJECT_3D);\n\n\t\tconst func = Poly.namedFunctionsRegister.getFunction('getObject', this, linesController);\n\t\tconst bodyLine = func.asString(object3D, getCurrentObject, mask);\n\t\tlinesController.addBodyOrComputed(this, [\n\t\t\t{dataType: JsConnectionPointType.PLANE, varName: out, value: bodyLine},\n\t\t]);\n\t}\n}\n","/**\n * get a child object\n *\n *\n */\nimport {TypedJsNode} from './_Base';\nimport {NodeParamsConfig, ParamConfig} from '../utils/params/ParamsConfig';\nimport {JsConnectionPoint, JsConnectionPointType, JS_CONNECTION_POINT_IN_NODE_DEF} from '../utils/io/connections/Js';\nimport {inputObject3D} from './_BaseObject3D';\nimport {Poly} from '../../Poly';\nimport {JsLinesCollectionController} from './code/utils/JsLinesCollectionController';\n\nconst CONNECTION_OPTIONS = JS_CONNECTION_POINT_IN_NODE_DEF;\n\nclass GetObjectChildJsParamsConfig extends NodeParamsConfig {\n\t/** @param child index */\n\tindex = ParamConfig.INTEGER(0, {\n\t\trange: [0, 9],\n\t\trangeLocked: [true, false],\n\t});\n}\nconst ParamsConfig = new GetObjectChildJsParamsConfig();\n\nexport class GetObjectChildJsNode extends TypedJsNode<GetObjectChildJsParamsConfig> {\n\toverride readonly paramsConfig = ParamsConfig;\n\tstatic override type() {\n\t\treturn 'getObjectChild';\n\t}\n\n\toverride initializeNode() {\n\t\tthis.io.inputs.setNamedInputConnectionPoints([\n\t\t\tnew JsConnectionPoint(JsConnectionPointType.OBJECT_3D, JsConnectionPointType.OBJECT_3D, CONNECTION_OPTIONS),\n\t\t]);\n\t\tthis.io.outputs.setNamedOutputConnectionPoints([\n\t\t\tnew JsConnectionPoint(JsConnectionPointType.OBJECT_3D, JsConnectionPointType.OBJECT_3D),\n\t\t]);\n\t}\n\n\toverride setLines(shadersCollectionController: JsLinesCollectionController) {\n\t\tconst object3D = inputObject3D(this, shadersCollectionController);\n\t\tconst index = this.variableForInputParam(shadersCollectionController, this.p.index);\n\t\tconst varName = this.jsVarName(JsConnectionPointType.OBJECT_3D);\n\n\t\tconst func = Poly.namedFunctionsRegister.getFunction('getObjectChild', this, shadersCollectionController);\n\t\tconst bodyLine = func.asString(object3D, index);\n\t\tshadersCollectionController.addBodyOrComputed(this, [\n\t\t\t{dataType: JsConnectionPointType.PLANE, varName, value: bodyLine},\n\t\t]);\n\t}\n}\n","/**\n * Get a param of specific node\n *\n *\n */\nimport {TypedJsNode} from './_Base';\nimport {NodeParamsConfig, ParamConfig} from '../utils/params/ParamsConfig';\nimport {JsConnectionPoint, JsConnectionPointType, JS_CONNECTION_POINT_IN_NODE_DEF} from '../utils/io/connections/Js';\nimport {JsLinesCollectionController} from './code/utils/JsLinesCollectionController';\nimport {Poly} from '../../Poly';\nimport {ParamPathParam} from '../../params/ParamPath';\nimport {JsType} from '../../poly/registers/nodes/types/Js';\n\nconst CONNECTION_OPTIONS = JS_CONNECTION_POINT_IN_NODE_DEF;\n\nclass GetParamJsParamsConfig extends NodeParamsConfig {\n\t/** @param parameter to get */\n\tParam = ParamConfig.PARAM_PATH('', {\n\t\tdependentOnFoundParam: false,\n\t\tparamSelection: true,\n\t\tcomputeOnDirty: false,\n\t});\n}\nconst ParamsConfig = new GetParamJsParamsConfig();\n\nexport class GetParamJsNode extends TypedJsNode<GetParamJsParamsConfig> {\n\toverride readonly paramsConfig = ParamsConfig;\n\tstatic override type() {\n\t\treturn JsType.GET_PARAM;\n\t}\n\n\toverride initializeNode() {\n\t\tthis.io.outputs.setNamedOutputConnectionPoints([\n\t\t\tnew JsConnectionPoint(JsConnectionPointType.PARAM, JsConnectionPointType.PARAM, CONNECTION_OPTIONS),\n\t\t]);\n\t\tthis.io.connection_points.spare_params.setInputlessParamNames([JsConnectionPointType.PARAM]);\n\t}\n\n\tsetParamPath(paramPath: string) {\n\t\tthis.p.Param.set(paramPath);\n\t}\n\toverride setLines(linesController: JsLinesCollectionController) {\n\t\tconst out = this.jsVarName(JsConnectionPointType.PARAM);\n\n\t\tconst param = (this.params.get(JsConnectionPointType.PARAM) as ParamPathParam).value.param();\n\t\tif (!param) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst func = Poly.namedFunctionsRegister.getFunction('getParam', this, linesController);\n\t\tconst bodyLine = func.asString(`'${param.path()}'`);\n\t\tlinesController.addBodyOrComputed(this, [\n\t\t\t{dataType: JsConnectionPointType.PARAM, varName: out, value: bodyLine},\n\t\t]);\n\t}\n}\n","/**\n * get a texture\n *\n *\n */\n\nimport {TypedJsNode} from './_Base';\nimport {NodeParamsConfig, ParamConfig} from '../utils/params/ParamsConfig';\nimport {\n\tJsConnectionPoint,\n\tJsConnectionPointType,\n\t// ReturnValueTypeByJsConnectionPointType,\n} from '../utils/io/connections/Js';\nimport {NodeContext} from '../../poly/NodeContext';\nimport {Poly} from '../../Poly';\nimport {JsLinesCollectionController} from './code/utils/JsLinesCollectionController';\nclass GetTextureJsParamsConfig extends NodeParamsConfig {\n\t/** @param the texture node */\n\tnode = ParamConfig.NODE_PATH('', {\n\t\tnodeSelection: {\n\t\t\tcontext: NodeContext.COP,\n\t\t},\n\t\tdependentOnFoundNode: false,\n\t\tcomputeOnDirty: true,\n\t});\n}\nconst ParamsConfig = new GetTextureJsParamsConfig();\n\nexport class GetTextureJsNode extends TypedJsNode<GetTextureJsParamsConfig> {\n\toverride readonly paramsConfig = ParamsConfig;\n\tstatic override type() {\n\t\treturn 'getTexture';\n\t}\n\n\toverride initializeNode() {\n\t\tthis.io.outputs.setNamedOutputConnectionPoints([\n\t\t\tnew JsConnectionPoint(JsConnectionPointType.TEXTURE, JsConnectionPointType.TEXTURE),\n\t\t]);\n\t}\n\n\toverride setLines(shadersCollectionController: JsLinesCollectionController) {\n\t\tconst node = this.pv.node.node();\n\t\tif (!(node && node.context() == NodeContext.COP)) {\n\t\t\treturn;\n\t\t}\n\t\tconst nodePath = `'${node.path()}'`;\n\t\tconst varName = this.jsVarName(JsConnectionPointType.TEXTURE);\n\t\tconst func = Poly.namedFunctionsRegister.getFunction('getTexture', this, shadersCollectionController);\n\t\tshadersCollectionController.addBodyOrComputed(this, [\n\t\t\t{\n\t\t\t\tdataType: JsConnectionPointType.TEXTURE,\n\t\t\t\tvarName,\n\t\t\t\tvalue: func.asString(nodePath),\n\t\t\t},\n\t\t]);\n\t}\n}\n","/**\n * get a video property\n *\n *\n */\n\nimport {TypedJsNode} from './_Base';\nimport {JsConnectionPoint, JsConnectionPointType, JS_CONNECTION_POINT_IN_NODE_DEF} from '../utils/io/connections/Js';\nimport {NodeParamsConfig, ParamConfig} from '../utils/params/ParamsConfig';\nimport {NodeContext} from '../../poly/NodeContext';\nimport {CopType} from '../../poly/registers/nodes/types/Cop';\nimport {JsLinesCollectionController} from './code/utils/JsLinesCollectionController';\nimport {Poly} from '../../Poly';\n\nconst CONNECTION_OPTIONS = JS_CONNECTION_POINT_IN_NODE_DEF;\n\nexport enum GetVideoPropertyJsNodeOutputName {\n\tcurrentTime = 'currentTime',\n\tduration = 'duration',\n\tplaying = 'playing',\n\tmuted = 'muted',\n}\nclass GetVideoPropertyJsParamsConfig extends NodeParamsConfig {\n\tnode = ParamConfig.NODE_PATH('', {\n\t\tnodeSelection: {\n\t\t\tcontext: NodeContext.COP,\n\t\t\ttypes: [CopType.VIDEO],\n\t\t},\n\t\tcomputeOnDirty: true,\n\t});\n}\nconst ParamsConfig = new GetVideoPropertyJsParamsConfig();\n\nexport class GetVideoPropertyJsNode extends TypedJsNode<GetVideoPropertyJsParamsConfig> {\n\toverride paramsConfig = ParamsConfig;\n\tstatic override type() {\n\t\treturn 'getVideoProperty';\n\t}\n\n\toverride initializeNode() {\n\t\tthis.io.inputs.setNamedInputConnectionPoints([\n\t\t\tnew JsConnectionPoint(JsConnectionPointType.OBJECT_3D, JsConnectionPointType.OBJECT_3D, CONNECTION_OPTIONS),\n\t\t]);\n\n\t\tthis.io.outputs.setNamedOutputConnectionPoints([\n\t\t\tnew JsConnectionPoint(GetVideoPropertyJsNodeOutputName.currentTime, JsConnectionPointType.FLOAT),\n\t\t\tnew JsConnectionPoint(GetVideoPropertyJsNodeOutputName.duration, JsConnectionPointType.FLOAT),\n\t\t\tnew JsConnectionPoint(GetVideoPropertyJsNodeOutputName.playing, JsConnectionPointType.BOOLEAN),\n\t\t\tnew JsConnectionPoint(GetVideoPropertyJsNodeOutputName.muted, JsConnectionPointType.BOOLEAN),\n\t\t]);\n\t}\n\toverride setLines(shadersCollectionController: JsLinesCollectionController) {\n\t\tconst usedOutputNames = this.io.outputs.used_output_names();\n\n\t\tconst node = this.pv.node.node();\n\t\tif (!(node && node.context() == NodeContext.COP)) {\n\t\t\treturn;\n\t\t}\n\t\tconst nodePath = `'${node.path()}'`;\n\n\t\tconst _f = (\n\t\t\tpropertyName: GetVideoPropertyJsNodeOutputName,\n\t\t\tfunctionName:\n\t\t\t\t| 'getVideoPropertyCurrentTime'\n\t\t\t\t| 'getVideoPropertyDuration'\n\t\t\t\t| 'getVideoPropertyPlaying'\n\t\t\t\t| 'getVideoPropertyMuted',\n\t\t\ttype: JsConnectionPointType\n\t\t) => {\n\t\t\tif (!usedOutputNames.includes(propertyName)) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tconst func = Poly.namedFunctionsRegister.getFunction(functionName, this, shadersCollectionController);\n\t\t\tshadersCollectionController.addBodyOrComputed(this, [\n\t\t\t\t{\n\t\t\t\t\tdataType: type,\n\t\t\t\t\tvarName: this.jsVarName(propertyName),\n\t\t\t\t\tvalue: func.asString(nodePath),\n\t\t\t\t},\n\t\t\t]);\n\t\t};\n\n\t\t_f(GetVideoPropertyJsNodeOutputName.currentTime, 'getVideoPropertyCurrentTime', JsConnectionPointType.FLOAT);\n\t\t_f(GetVideoPropertyJsNodeOutputName.duration, 'getVideoPropertyDuration', JsConnectionPointType.FLOAT);\n\t\t_f(GetVideoPropertyJsNodeOutputName.playing, 'getVideoPropertyPlaying', JsConnectionPointType.BOOLEAN);\n\t\t_f(GetVideoPropertyJsNodeOutputName.muted, 'getVideoPropertyMuted', JsConnectionPointType.BOOLEAN);\n\t}\n}\n","/**\n * reads an entity attribute for a given index\n *\n *\n */\nimport {TypedJsNode} from './_Base';\nimport {JsLinesCollectionController} from './code/utils/JsLinesCollectionController';\nimport {JsConnectionPointType} from '../utils/io/connections/Js';\nimport {JsType} from '../../poly/registers/nodes/types/Js';\nimport {NodeParamsConfig, ParamConfig} from '../utils/params/ParamsConfig';\nimport {PointBuilderFunctionDataAttributeDataItem} from './code/assemblers/pointBuilder/_BasePointBuilderPersistedConfig';\nimport {Poly} from '../../Poly';\nimport {defaultObject} from './_BaseObject3D';\n\nexport const ATTRIBUTE_NODE_AVAILABLE_JS_TYPES = [\n\tJsConnectionPointType.COLOR,\n\tJsConnectionPointType.FLOAT,\n\tJsConnectionPointType.INT,\n\tJsConnectionPointType.VECTOR2,\n\tJsConnectionPointType.VECTOR3,\n\tJsConnectionPointType.VECTOR4,\n];\nexport enum ImportAttributeJsNodeInput {\n\tINDEX = 'index',\n}\nexport enum ImportAttributeJsNodeOutput {\n\tVAL = 'val',\n}\n\nclass ImportAttributeJsParamsConfig extends NodeParamsConfig {\n\tname = ParamConfig.STRING('');\n\ttype = ParamConfig.INTEGER(0, {\n\t\tmenu: {\n\t\t\tentries: ATTRIBUTE_NODE_AVAILABLE_JS_TYPES.map((name, i) => {\n\t\t\t\treturn {name: name, value: i};\n\t\t\t}),\n\t\t},\n\t});\n\t/** @param entity index */\n\tindex = ParamConfig.INTEGER(0);\n}\nconst ParamsConfig = new ImportAttributeJsParamsConfig();\n\nexport class ImportAttributeJsNode extends TypedJsNode<ImportAttributeJsParamsConfig> {\n\toverride paramsConfig = ParamsConfig;\n\tstatic override type() {\n\t\treturn JsType.IMPORT_ATTRIBUTE;\n\t}\n\n\toverride initializeNode() {\n\t\tthis.io.connection_points.initializeNode();\n\n\t\tthis.io.connection_points.set_expected_input_types_function(() => this._expectedInputTypes());\n\t\tthis.io.connection_points.set_input_name_function((index: number) => this.inputName());\n\t\tthis.io.connection_points.set_expected_output_types_function(() => [this._expectedOutputType()]);\n\t}\n\n\tprivate _expectedInputTypes() {\n\t\treturn [JsConnectionPointType.INT];\n\t}\n\tprivate _expectedOutputType() {\n\t\treturn ATTRIBUTE_NODE_AVAILABLE_JS_TYPES[this.pv.type];\n\t}\n\n\tinputName() {\n\t\treturn ImportAttributeJsNodeInput.INDEX;\n\t}\n\toutputName() {\n\t\treturn ImportAttributeJsNodeOutput.VAL;\n\t}\n\n\tattribData(): PointBuilderFunctionDataAttributeDataItem {\n\t\treturn {\n\t\t\tattribName: this.attributeName(),\n\t\t\tattribType: this.jsType(),\n\t\t};\n\t}\n\tattributeName(): string {\n\t\treturn this.pv.name.trim();\n\t}\n\tjsType() {\n\t\tconst connectionPoints = this.io.outputs.namedOutputConnectionPoints();\n\t\tif (!connectionPoints) {\n\t\t\treturn JsConnectionPointType.FLOAT;\n\t\t}\n\t\treturn connectionPoints[0].type();\n\t}\n\tsetJsType(type: JsConnectionPointType) {\n\t\tthis.p.type.set(ATTRIBUTE_NODE_AVAILABLE_JS_TYPES.indexOf(type));\n\t}\n\n\toverride setLines(linesController: JsLinesCollectionController) {\n\t\tconst primitiveGraph = defaultObject(linesController);\n\t\tconst index = this.variableForInputParam(linesController, this.p.index);\n\t\tconst attribName = this.variableForInputParam(linesController, this.p.name);\n\t\tconst out = this.jsVarName(ImportAttributeJsNodeOutput.VAL);\n\n\t\tconst func = Poly.namedFunctionsRegister.getFunction('importPrimitiveAttributeNumber', this, linesController);\n\t\tconst bodyLine = func.asString(primitiveGraph, attribName, index);\n\t\tlinesController.addBodyOrComputed(this, [{dataType: JsConnectionPointType.INT, varName: out, value: bodyLine}]);\n\t}\n}\n","/**\n * sends a trigger when a keyboard key is pressed down\n *\n *\n */\n\nimport {JsType} from '../../poly/registers/nodes/types/Js';\nimport {BaseOnKeyEventJsNode} from './_BaseOnKeyEvent';\nimport {EvaluatorEventData} from './code/assemblers/actor/ActorEvaluator';\nimport {KeyboardEventType} from '../../../core/event/KeyboardEventType';\n\nexport class OnKeydownJsNode extends BaseOnKeyEventJsNode {\n\tstatic override type() {\n\t\treturn JsType.ON_KEYDOWN;\n\t}\n\toverride eventData(): EvaluatorEventData | undefined {\n\t\treturn {\n\t\t\ttype: KeyboardEventType.keydown,\n\t\t\temitter: this.eventEmitter(),\n\t\t\tjsType: JsType.ON_KEYDOWN,\n\t\t};\n\t}\n}\n","/**\n * sends a trigger when a keyboard key is pressed\n *\n *\n */\n\nimport {JsType} from '../../poly/registers/nodes/types/Js';\nimport {KeyboardEventType} from '../../../core/event/KeyboardEventType';\nimport {BaseOnKeyEventJsNode} from './_BaseOnKeyEvent';\nimport {EvaluatorEventData} from './code/assemblers/actor/ActorEvaluator';\n\nexport class OnKeypressJsNode extends BaseOnKeyEventJsNode {\n\tstatic override type() {\n\t\treturn JsType.ON_KEYPRESS;\n\t}\n\toverride eventData(): EvaluatorEventData | undefined {\n\t\treturn {\n\t\t\ttype: KeyboardEventType.keypress,\n\t\t\temitter: this.eventEmitter(),\n\t\t\tjsType: JsType.ON_KEYPRESS,\n\t\t};\n\t}\n}\n","/**\n * sends a trigger when a keyboard key is released\n *\n *\n */\n\nimport {JsType} from '../../poly/registers/nodes/types/Js';\nimport {EvaluatorEventData} from './code/assemblers/actor/ActorEvaluator';\nimport {KeyboardEventType} from '../../../core/event/KeyboardEventType';\nimport {BaseOnKeyEventJsNode} from './_BaseOnKeyEvent';\n\nexport class OnKeyupJsNode extends BaseOnKeyEventJsNode {\n\tstatic override type() {\n\t\treturn JsType.ON_KEYUP;\n\t}\n\toverride eventData(): EvaluatorEventData | undefined {\n\t\treturn {\n\t\t\ttype: KeyboardEventType.keyup,\n\t\t\temitter: this.eventEmitter(),\n\t\t\tjsType: JsType.ON_KEYUP,\n\t\t};\n\t}\n}\n","/**\n * sends a trigger when an object is clicked\n *\n *\n */\n\nimport {TRIGGER_CONNECTION_NAME} from './_Base';\nimport {JsConnectionPoint, JsConnectionPointType, JS_CONNECTION_POINT_IN_NODE_DEF} from '../utils/io/connections/Js';\nimport {JsType} from '../../poly/registers/nodes/types/Js';\nimport {EvaluatorEventData} from './code/assemblers/actor/ActorEvaluator';\nimport {\n\tExtendableOnObjectPointerEventJsNode,\n\tCPUOnObjectPointerEventJsParamsConfig,\n\tPointerEventConfigParamConfig,\n\tpointerButtonConfig,\n} from './_BaseOnObjectPointerEvent';\nimport {JsLinesCollectionController} from './code/utils/JsLinesCollectionController';\nimport {PointerEventType} from '../../../core/event/PointerEventType';\nimport {inputObject3D} from './_BaseObject3D';\nimport {Poly} from '../../Poly';\nimport {InitFunctionJsDefinition, RefJsDefinition} from './utils/JsDefinition';\nimport {nodeMethodName} from './code/assemblers/actor/ActorAssemblerUtils';\nimport {\n\tObjectToClickOptionsAsString,\n\tClickParamConfig,\n} from '../../scene/utils/actors/rayObjectIntersection/RayObjectIntersectionsClickController';\n\nconst CONNECTION_OPTIONS = JS_CONNECTION_POINT_IN_NODE_DEF;\n\nexport class OnObjectClickJsParamsConfig extends PointerEventConfigParamConfig(\n\tClickParamConfig(CPUOnObjectPointerEventJsParamsConfig)\n) {}\nconst ParamsConfig = new OnObjectClickJsParamsConfig();\n\nexport class OnObjectClickJsNode extends ExtendableOnObjectPointerEventJsNode<OnObjectClickJsParamsConfig> {\n\toverride readonly paramsConfig = ParamsConfig;\n\tstatic override type() {\n\t\treturn JsType.ON_OBJECT_CLICK;\n\t}\n\toverride isTriggering() {\n\t\treturn true;\n\t}\n\n\toverride eventData(): EvaluatorEventData[] | undefined {\n\t\t// we need both pointerdown and pointerup events,\n\t\t// to ensure that the raycaster gets its cursor updated\n\t\t// on each event\n\t\treturn [\n\t\t\t{\n\t\t\t\ttype: PointerEventType.pointerdown,\n\t\t\t\temitter: this.eventEmitter(),\n\t\t\t\tjsType: JsType.ON_POINTERDOWN,\n\t\t\t},\n\t\t\t{\n\t\t\t\ttype: PointerEventType.pointerup,\n\t\t\t\temitter: this.eventEmitter(),\n\t\t\t\tjsType: JsType.ON_OBJECT_POINTERUP,\n\t\t\t},\n\t\t];\n\t}\n\toverride initializeNode() {\n\t\tsuper.initializeNode();\n\t\tthis.io.inputs.setNamedInputConnectionPoints([\n\t\t\tnew JsConnectionPoint(JsConnectionPointType.OBJECT_3D, JsConnectionPointType.OBJECT_3D, CONNECTION_OPTIONS),\n\t\t]);\n\t\tthis.io.outputs.setNamedOutputConnectionPoints([\n\t\t\tnew JsConnectionPoint(TRIGGER_CONNECTION_NAME, JsConnectionPointType.TRIGGER, CONNECTION_OPTIONS),\n\t\t\tnew JsConnectionPoint(\n\t\t\t\tJsConnectionPointType.INTERSECTION,\n\t\t\t\tJsConnectionPointType.INTERSECTION,\n\t\t\t\tCONNECTION_OPTIONS\n\t\t\t),\n\t\t]);\n\t}\n\n\toverride setLines(linesController: JsLinesCollectionController) {\n\t\tconst usedOutputNames = this.io.outputs.used_output_names();\n\t\tif (usedOutputNames.includes(JsConnectionPointType.INTERSECTION)) {\n\t\t\tthis._addIntersectionRef(linesController);\n\t\t}\n\t}\n\n\toverride setTriggeringLines(linesController: JsLinesCollectionController, triggeredMethods: string) {\n\t\tconst object3D = inputObject3D(this, linesController);\n\t\tconst blockObjectsBehind = this.variableForInputParam(linesController, this.p.blockObjectsBehind);\n\t\tconst skipIfObjectsInFront = this.variableForInputParam(linesController, this.p.skipIfObjectsInFront);\n\t\tconst traverseChildren = this.variableForInputParam(linesController, this.p.traverseChildren);\n\t\tconst lineThreshold = this.variableForInputParam(linesController, this.p.lineThreshold);\n\t\tconst pointsThreshold = this.variableForInputParam(linesController, this.p.pointsThreshold);\n\t\tconst maxCursorMoveDistance = this.variableForInputParam(linesController, this.p.maxCursorMoveDistance);\n\t\tconst maxDuration = this.variableForInputParam(linesController, this.p.maxDuration);\n\t\tconst intersectionRef = this._addIntersectionRef(linesController);\n\n\t\tconst func = Poly.namedFunctionsRegister.getFunction('addObjectToObjectClickCheck', this, linesController);\n\t\tconst options: ObjectToClickOptionsAsString = {\n\t\t\tpriority: {\n\t\t\t\tblockObjectsBehind,\n\t\t\t\tskipIfObjectsInFront,\n\t\t\t},\n\t\t\tcpu: {\n\t\t\t\ttraverseChildren,\n\t\t\t\tpointsThreshold,\n\t\t\t\tlineThreshold,\n\t\t\t\tintersectionRef: `this.${intersectionRef}`,\n\t\t\t},\n\t\t\tclick: {\n\t\t\t\tmaxCursorMoveDistance,\n\t\t\t\tmaxDuration,\n\t\t\t\tcallback: `this.${nodeMethodName(this)}.bind(this)`,\n\t\t\t},\n\t\t\tconfig: pointerButtonConfig(this, linesController),\n\t\t};\n\t\tconst jsonOptions = JSON.stringify(options).replace(/\"/g, '');\n\t\tconst bodyLine = func.asString(object3D, `this`, jsonOptions);\n\t\tlinesController.addDefinitions(this, [\n\t\t\tnew InitFunctionJsDefinition(this, linesController, JsConnectionPointType.OBJECT_3D, this.path(), bodyLine),\n\t\t]);\n\n\t\tlinesController.addTriggeringLines(this, [triggeredMethods], {gatherable: true});\n\t}\n\n\tprivate _addIntersectionRef(linesController: JsLinesCollectionController) {\n\t\tconst outIntersection = this.jsVarName(JsConnectionPointType.INTERSECTION);\n\t\tlinesController.addDefinitions(this, [\n\t\t\tnew RefJsDefinition(this, linesController, JsConnectionPointType.INTERSECTION, outIntersection, `null`),\n\t\t]);\n\t\treturn outIntersection;\n\t}\n}\n","/**\n * sends a trigger when the listened object dispatches an event\n *\n *\n */\nimport {TRIGGER_CONNECTION_NAME, TypedJsNode} from './_Base';\nimport {NodeParamsConfig, ParamConfig} from '../utils/params/ParamsConfig';\nimport {JsConnectionPoint, JsConnectionPointType, JS_CONNECTION_POINT_IN_NODE_DEF} from '../utils/io/connections/Js';\nimport {JsType} from '../../poly/registers/nodes/types/Js';\nimport {inputObject3D} from './_BaseObject3D';\nimport {JsLinesCollectionController} from './code/utils/JsLinesCollectionController';\nimport {Poly} from '../../Poly';\nimport {InitFunctionJsDefinition} from './utils/JsDefinition';\nimport {nodeMethodName} from './code/assemblers/actor/ActorAssemblerUtils';\n\nenum OnObjectDispatchEventJsNodeInputName {\n\teventName = 'eventName',\n}\n\nconst CONNECTION_OPTIONS = JS_CONNECTION_POINT_IN_NODE_DEF;\nclass OnObjectDispatchEventJsParamsConfig extends NodeParamsConfig {\n\t/** @param event names (space separated) */\n\teventNames = ParamConfig.STRING('my-eventA my-eventB');\n}\nconst ParamsConfig = new OnObjectDispatchEventJsParamsConfig();\n\nexport class OnObjectDispatchEventJsNode extends TypedJsNode<OnObjectDispatchEventJsParamsConfig> {\n\toverride readonly paramsConfig = ParamsConfig;\n\tstatic override type(): JsType.ON_OBJECT_DISPATCH_EVENT {\n\t\treturn JsType.ON_OBJECT_DISPATCH_EVENT;\n\t}\n\toverride isTriggering() {\n\t\treturn true;\n\t}\n\toverride initializeNode() {\n\t\tsuper.initializeNode();\n\t\tthis.io.connection_points.spare_params.setInputlessParamNames(['eventNames']);\n\t\tthis.io.inputs.setNamedInputConnectionPoints([]);\n\t\tthis.io.outputs.setNamedOutputConnectionPoints([\n\t\t\tnew JsConnectionPoint(TRIGGER_CONNECTION_NAME, JsConnectionPointType.TRIGGER, CONNECTION_OPTIONS),\n\t\t\tnew JsConnectionPoint(\n\t\t\t\tOnObjectDispatchEventJsNodeInputName.eventName,\n\t\t\t\tJsConnectionPointType.STRING,\n\t\t\t\tCONNECTION_OPTIONS\n\t\t\t),\n\t\t]);\n\t}\n\n\toverride setTriggeringLines(shadersCollectionController: JsLinesCollectionController, triggeredMethods: string) {\n\t\tconst object3D = inputObject3D(this, shadersCollectionController);\n\t\tconst eventNames = this.variableForInputParam(shadersCollectionController, this.p.eventNames);\n\t\tconst func = Poly.namedFunctionsRegister.getFunction(\n\t\t\t'objectAddEventListeners',\n\t\t\tthis,\n\t\t\tshadersCollectionController\n\t\t);\n\t\tconst bodyLine = func.asString(object3D, eventNames, `this`, `this.${nodeMethodName(this)}.bind(this)`);\n\t\tshadersCollectionController.addDefinitions(this, [\n\t\t\tnew InitFunctionJsDefinition(\n\t\t\t\tthis,\n\t\t\t\tshadersCollectionController,\n\t\t\t\tJsConnectionPointType.OBJECT_3D,\n\t\t\t\tthis.path(),\n\t\t\t\tbodyLine\n\t\t\t),\n\t\t]);\n\n\t\tshadersCollectionController.addTriggeringLines(this, [triggeredMethods], {gatherable: false});\n\t}\n}\n","/**\n * sends a trigger when the viewer taps or clicks on an object\n *\n *\n */\n\nimport {TRIGGER_CONNECTION_NAME} from './_Base';\nimport {JsConnectionPoint, JsConnectionPointType, JS_CONNECTION_POINT_IN_NODE_DEF} from '../utils/io/connections/Js';\nimport {JsType} from '../../poly/registers/nodes/types/Js';\nimport {JsLinesCollectionController} from './code/utils/JsLinesCollectionController';\nimport {EvaluatorEventData} from './code/assemblers/actor/ActorEvaluator';\nimport {\n\tExtendableOnObjectPointerEventJsNode,\n\tPointerEventConfigParamConfig,\n\tCPUOnObjectPointerEventJsParamsConfig,\n\tpointerButtonConfig,\n} from './_BaseOnObjectPointerEvent';\nimport {PointerEventType} from '../../../core/event/PointerEventType';\nimport {inputObject3D} from './_BaseObject3D';\nimport {Poly} from '../../Poly';\nimport {InitFunctionJsDefinition, RefJsDefinition} from './utils/JsDefinition';\nimport {ObjectToObjectPointerdownOptionsAsString} from '../../scene/utils/actors/rayObjectIntersection/RayObjectIntersectionsPointerdownController';\nimport {nodeMethodName} from './code/assemblers/actor/ActorAssemblerUtils';\n\nconst CONNECTION_OPTIONS = JS_CONNECTION_POINT_IN_NODE_DEF;\n\nexport class OnObjectPointerdownJsParamsConfig extends PointerEventConfigParamConfig(\n\tCPUOnObjectPointerEventJsParamsConfig\n) {}\nconst ParamsConfig = new OnObjectPointerdownJsParamsConfig();\n\nexport class OnObjectPointerdownJsNode extends ExtendableOnObjectPointerEventJsNode<OnObjectPointerdownJsParamsConfig> {\n\toverride readonly paramsConfig = ParamsConfig;\n\tstatic override type() {\n\t\treturn JsType.ON_OBJECT_POINTERDOWN;\n\t}\n\n\toverride eventData(): EvaluatorEventData | undefined {\n\t\treturn {\n\t\t\ttype: PointerEventType.pointerdown,\n\t\t\temitter: this.eventEmitter(),\n\t\t\tjsType: JsType.ON_OBJECT_POINTERDOWN,\n\t\t};\n\t}\n\n\toverride initializeNode() {\n\t\tsuper.initializeNode();\n\t\tthis.io.outputs.setNamedOutputConnectionPoints([\n\t\t\tnew JsConnectionPoint(TRIGGER_CONNECTION_NAME, JsConnectionPointType.TRIGGER, CONNECTION_OPTIONS),\n\t\t\tnew JsConnectionPoint(\n\t\t\t\tJsConnectionPointType.INTERSECTION,\n\t\t\t\tJsConnectionPointType.INTERSECTION,\n\t\t\t\tCONNECTION_OPTIONS\n\t\t\t),\n\t\t]);\n\t\tthis.io.connection_points.spare_params.setInputlessParamNames(['pointsThreshold', 'lineThreshold', 'element']);\n\t}\n\n\toverride setLines(linesController: JsLinesCollectionController) {\n\t\tconst usedOutputNames = this.io.outputs.used_output_names();\n\t\tif (usedOutputNames.includes(JsConnectionPointType.INTERSECTION)) {\n\t\t\tthis._addIntersectionRef(linesController);\n\t\t}\n\t}\n\n\toverride setTriggeringLines(linesController: JsLinesCollectionController, triggeredMethods: string) {\n\t\tconst object3D = inputObject3D(this, linesController);\n\t\tconst blockObjectsBehind = this.variableForInputParam(linesController, this.p.blockObjectsBehind);\n\t\tconst skipIfObjectsInFront = this.variableForInputParam(linesController, this.p.skipIfObjectsInFront);\n\t\tconst traverseChildren = this.variableForInputParam(linesController, this.p.traverseChildren);\n\t\tconst lineThreshold = this.variableForInputParam(linesController, this.p.lineThreshold);\n\t\tconst pointsThreshold = this.variableForInputParam(linesController, this.p.pointsThreshold);\n\t\tconst intersectionRef = this._addIntersectionRef(linesController);\n\n\t\tconst func = Poly.namedFunctionsRegister.getFunction(\n\t\t\t'addObjectToObjectPointerdownCheck',\n\t\t\tthis,\n\t\t\tlinesController\n\t\t);\n\t\tconst options: ObjectToObjectPointerdownOptionsAsString = {\n\t\t\tpriority: {\n\t\t\t\tblockObjectsBehind,\n\t\t\t\tskipIfObjectsInFront,\n\t\t\t},\n\t\t\tcpu: {\n\t\t\t\ttraverseChildren,\n\t\t\t\tpointsThreshold,\n\t\t\t\tlineThreshold,\n\t\t\t\tintersectionRef: `this.${intersectionRef}`,\n\t\t\t},\n\t\t\tpointerdown: {\n\t\t\t\tcallback: `this.${nodeMethodName(this)}.bind(this)`,\n\t\t\t},\n\t\t\tconfig: pointerButtonConfig(this, linesController),\n\t\t};\n\t\tconst jsonOptions = JSON.stringify(options).replace(/\"/g, '');\n\t\tconst bodyLine = func.asString(object3D, `this`, jsonOptions);\n\t\tlinesController.addDefinitions(this, [\n\t\t\tnew InitFunctionJsDefinition(this, linesController, JsConnectionPointType.OBJECT_3D, this.path(), bodyLine),\n\t\t]);\n\n\t\tlinesController.addTriggeringLines(this, [triggeredMethods], {gatherable: true});\n\t}\n\n\tprivate _addIntersectionRef(linesController: JsLinesCollectionController) {\n\t\tconst outIntersection = this.jsVarName(JsConnectionPointType.INTERSECTION);\n\t\tlinesController.addDefinitions(this, [\n\t\t\tnew RefJsDefinition(this, linesController, JsConnectionPointType.INTERSECTION, outIntersection, `null`),\n\t\t]);\n\t\treturn outIntersection;\n\t}\n}\n","/**\n * sends a trigger when the viewer taps or clicks on an object\n *\n *\n */\n\nimport {TRIGGER_CONNECTION_NAME} from './_Base';\nimport {JsConnectionPoint, JsConnectionPointType, JS_CONNECTION_POINT_IN_NODE_DEF} from '../utils/io/connections/Js';\nimport {JsType} from '../../poly/registers/nodes/types/Js';\nimport {EvaluatorEventData} from './code/assemblers/actor/ActorEvaluator';\nimport {JsLinesCollectionController} from './code/utils/JsLinesCollectionController';\nimport {\n\tPointerEventConfigParamConfig,\n\tCPUOnObjectPointerEventJsParamsConfig,\n\tExtendableOnObjectPointerEventJsNode,\n\tpointerButtonConfig,\n} from './_BaseOnObjectPointerEvent';\nimport {PointerEventType} from '../../../core/event/PointerEventType';\nimport {inputObject3D} from './_BaseObject3D';\nimport {Poly} from '../../Poly';\nimport {InitFunctionJsDefinition, RefJsDefinition} from './utils/JsDefinition';\nimport {ObjectToObjectPointerupOptionsAsString} from '../../scene/utils/actors/rayObjectIntersection/RayObjectIntersectionsPointerupController';\nimport {nodeMethodName} from './code/assemblers/actor/ActorAssemblerUtils';\nimport {TouchEventType} from '../../../core/event/TouchEventType';\nimport {isTouchDevice} from '../../../core/UserAgent';\n\nconst CONNECTION_OPTIONS = JS_CONNECTION_POINT_IN_NODE_DEF;\n\nexport class OnObjectPointerupJsParamsConfig extends PointerEventConfigParamConfig(\n\tCPUOnObjectPointerEventJsParamsConfig\n) {}\nconst ParamsConfig = new OnObjectPointerupJsParamsConfig();\n\nexport class OnObjectPointerupJsNode extends ExtendableOnObjectPointerEventJsNode<OnObjectPointerupJsParamsConfig> {\n\toverride readonly paramsConfig = ParamsConfig;\n\tstatic override type() {\n\t\treturn JsType.ON_OBJECT_POINTERUP;\n\t}\n\n\toverride eventData(): EvaluatorEventData | undefined {\n\t\t// we also need touchend, since pointerup is not triggered on touch devices\n\t\t// after the cursor has moved.\n\t\t// But we can only have one or the other, as the event would be triggered twice if we had both.\n\t\tif (isTouchDevice()) {\n\t\t\treturn {\n\t\t\t\ttype: TouchEventType.touchend,\n\t\t\t\temitter: this.eventEmitter(),\n\t\t\t\tjsType: JsType.ON_OBJECT_POINTERUP,\n\t\t\t};\n\t\t} else {\n\t\t\treturn {\n\t\t\t\ttype: PointerEventType.pointerup,\n\t\t\t\temitter: this.eventEmitter(),\n\t\t\t\tjsType: JsType.ON_OBJECT_POINTERUP,\n\t\t\t};\n\t\t}\n\t}\n\n\toverride initializeNode() {\n\t\tsuper.initializeNode();\n\t\tthis.io.outputs.setNamedOutputConnectionPoints([\n\t\t\tnew JsConnectionPoint(TRIGGER_CONNECTION_NAME, JsConnectionPointType.TRIGGER, CONNECTION_OPTIONS),\n\t\t\tnew JsConnectionPoint(\n\t\t\t\tJsConnectionPointType.INTERSECTION,\n\t\t\t\tJsConnectionPointType.INTERSECTION,\n\t\t\t\tCONNECTION_OPTIONS\n\t\t\t),\n\t\t]);\n\t\tthis.io.connection_points.spare_params.setInputlessParamNames(['pointsThreshold', 'lineThreshold', 'element']);\n\t}\n\n\toverride setLines(linesController: JsLinesCollectionController) {\n\t\tconst usedOutputNames = this.io.outputs.used_output_names();\n\t\tif (usedOutputNames.includes(JsConnectionPointType.INTERSECTION)) {\n\t\t\tthis._addIntersectionRef(linesController);\n\t\t}\n\t}\n\toverride setTriggeringLines(linesController: JsLinesCollectionController, triggeredMethods: string) {\n\t\tconst object3D = inputObject3D(this, linesController);\n\t\tconst blockObjectsBehind = this.variableForInputParam(linesController, this.p.blockObjectsBehind);\n\t\tconst skipIfObjectsInFront = this.variableForInputParam(linesController, this.p.skipIfObjectsInFront);\n\t\tconst traverseChildren = this.variableForInputParam(linesController, this.p.traverseChildren);\n\t\tconst lineThreshold = this.variableForInputParam(linesController, this.p.lineThreshold);\n\t\tconst pointsThreshold = this.variableForInputParam(linesController, this.p.pointsThreshold);\n\t\tconst intersectionRef = this._addIntersectionRef(linesController);\n\n\t\tconst func = Poly.namedFunctionsRegister.getFunction('addObjectToObjectPointerupCheck', this, linesController);\n\t\tconst options: ObjectToObjectPointerupOptionsAsString = {\n\t\t\tpriority: {\n\t\t\t\tblockObjectsBehind,\n\t\t\t\tskipIfObjectsInFront,\n\t\t\t},\n\t\t\tcpu: {\n\t\t\t\ttraverseChildren,\n\t\t\t\tpointsThreshold,\n\t\t\t\tlineThreshold,\n\t\t\t\tintersectionRef: `this.${intersectionRef}`,\n\t\t\t},\n\t\t\tpointerup: {\n\t\t\t\tcallback: `this.${nodeMethodName(this)}.bind(this)`,\n\t\t\t},\n\t\t\tconfig: pointerButtonConfig(this, linesController),\n\t\t};\n\t\tconst jsonOptions = JSON.stringify(options).replace(/\"/g, '');\n\t\tconst bodyLine = func.asString(object3D, `this`, jsonOptions);\n\t\tlinesController.addDefinitions(this, [\n\t\t\tnew InitFunctionJsDefinition(this, linesController, JsConnectionPointType.OBJECT_3D, this.path(), bodyLine),\n\t\t]);\n\n\t\tlinesController.addTriggeringLines(this, [triggeredMethods], {gatherable: true});\n\t}\n\n\tprivate _addIntersectionRef(linesController: JsLinesCollectionController) {\n\t\tconst outIntersection = this.jsVarName(JsConnectionPointType.INTERSECTION);\n\t\tlinesController.addDefinitions(this, [\n\t\t\tnew RefJsDefinition(this, linesController, JsConnectionPointType.INTERSECTION, outIntersection, `null`),\n\t\t]);\n\t\treturn outIntersection;\n\t}\n}\n","/**\n * sends a trigger when the viewer taps or clicks anywhere\n *\n *\n */\n\nimport {TRIGGER_CONNECTION_NAME} from './_Base';\nimport {NodeParamsConfig, ParamConfig} from '../utils/params/ParamsConfig';\nimport {JsConnectionPoint, JsConnectionPointType, JS_CONNECTION_POINT_IN_NODE_DEF} from '../utils/io/connections/Js';\nimport {JsType} from '../../poly/registers/nodes/types/Js';\nimport {BaseUserInputJsNode} from './_BaseUserInput';\nimport {CoreEventEmitter, EVENT_EMITTERS, EVENT_EMITTER_PARAM_MENU_OPTIONS} from '../../../core/event/CoreEventEmitter';\nimport {EvaluatorEventData} from './code/assemblers/actor/ActorEvaluator';\nimport {PointerEventType} from '../../../core/event/PointerEventType';\nimport {JsLinesCollectionController} from './code/utils/JsLinesCollectionController';\nimport {TouchEventType} from '../../../core/event/TouchEventType';\nimport {isTouchDevice} from '../../../core/UserAgent';\nimport {inputObject3D} from './_BaseObject3D';\nimport {Poly} from '../../Poly';\nimport {ObjectToPointerdownOptionsAsString} from '../../scene/utils/actors/rayObjectIntersection/PointerdownController';\nimport {InitFunctionJsDefinition} from './utils/JsDefinition';\nimport {nodeMethodName} from './code/assemblers/actor/ActorAssemblerUtils';\n\nconst CONNECTION_OPTIONS = JS_CONNECTION_POINT_IN_NODE_DEF;\nclass OnPointerdownJsParamsConfig extends NodeParamsConfig {\n\t/** @param set which element triggers the event */\n\telement = ParamConfig.INTEGER(EVENT_EMITTERS.indexOf(CoreEventEmitter.CANVAS), {\n\t\t...EVENT_EMITTER_PARAM_MENU_OPTIONS,\n\t\tseparatorAfter: true,\n\t});\n}\nconst ParamsConfig = new OnPointerdownJsParamsConfig();\n\nexport class OnPointerdownJsNode extends BaseUserInputJsNode<OnPointerdownJsParamsConfig> {\n\toverride readonly paramsConfig = ParamsConfig;\n\tstatic override type() {\n\t\treturn JsType.ON_POINTERDOWN;\n\t}\n\toverride eventData(): EvaluatorEventData | undefined {\n\t\tif (isTouchDevice()) {\n\t\t\treturn {\n\t\t\t\ttype: TouchEventType.touchstart,\n\t\t\t\temitter: this.eventEmitter(),\n\t\t\t\tjsType: JsType.ON_POINTERDOWN,\n\t\t\t};\n\t\t} else {\n\t\t\treturn {\n\t\t\t\ttype: PointerEventType.pointerdown,\n\t\t\t\temitter: this.eventEmitter(),\n\t\t\t\tjsType: JsType.ON_POINTERDOWN,\n\t\t\t};\n\t\t}\n\t}\n\toverride eventEmitter() {\n\t\treturn EVENT_EMITTERS[this.pv.element];\n\t}\n\tsetEventEmitter(emitter: CoreEventEmitter) {\n\t\tthis.p.element.set(EVENT_EMITTERS.indexOf(emitter));\n\t}\n\n\toverride initializeNode() {\n\t\tsuper.initializeNode();\n\t\tthis.io.outputs.setNamedOutputConnectionPoints([\n\t\t\tnew JsConnectionPoint(TRIGGER_CONNECTION_NAME, JsConnectionPointType.TRIGGER, CONNECTION_OPTIONS),\n\t\t]);\n\t}\n\toverride setTriggeringLines(linesController: JsLinesCollectionController, triggeredMethods: string) {\n\t\tconst object3D = inputObject3D(this, linesController);\n\n\t\tconst func = Poly.namedFunctionsRegister.getFunction('addObjectToPointerdownCheck', this, linesController);\n\t\tconst options: ObjectToPointerdownOptionsAsString = {\n\t\t\tpointerdown: {\n\t\t\t\tcallback: `this.${nodeMethodName(this)}.bind(this)`,\n\t\t\t},\n\t\t};\n\t\tconst jsonOptions = JSON.stringify(options).replace(/\"/g, '');\n\t\tconst bodyLine = func.asString(object3D, `this`, jsonOptions);\n\t\tlinesController.addDefinitions(this, [\n\t\t\tnew InitFunctionJsDefinition(this, linesController, JsConnectionPointType.OBJECT_3D, this.path(), bodyLine),\n\t\t]);\n\n\t\tlinesController.addTriggeringLines(this, [triggeredMethods], {gatherable: true});\n\t}\n}\n","/**\n * sends a trigger when the viewer taps or clicks anywhere\n *\n *\n */\n\nimport {TRIGGER_CONNECTION_NAME} from './_Base';\nimport {NodeParamsConfig, ParamConfig} from '../utils/params/ParamsConfig';\nimport {JsConnectionPoint, JsConnectionPointType, JS_CONNECTION_POINT_IN_NODE_DEF} from '../utils/io/connections/Js';\nimport {JsType} from '../../poly/registers/nodes/types/Js';\nimport {BaseUserInputJsNode} from './_BaseUserInput';\nimport {CoreEventEmitter, EVENT_EMITTERS, EVENT_EMITTER_PARAM_MENU_OPTIONS} from '../../../core/event/CoreEventEmitter';\nimport {PointerEventType} from '../../../core/event/PointerEventType';\nimport {EvaluatorEventData} from './code/assemblers/actor/ActorEvaluator';\nimport {JsLinesCollectionController} from './code/utils/JsLinesCollectionController';\nimport {TouchEventType} from '../../../core/event/TouchEventType';\nimport {isTouchDevice} from '../../../core/UserAgent';\nimport {inputObject3D} from './_BaseObject3D';\nimport {Poly} from '../../Poly';\nimport {ObjectToPointerupOptionsAsString} from '../../scene/utils/actors/rayObjectIntersection/PointerupController';\nimport {InitFunctionJsDefinition} from './utils/JsDefinition';\nimport {nodeMethodName} from './code/assemblers/actor/ActorAssemblerUtils';\n\nconst CONNECTION_OPTIONS = JS_CONNECTION_POINT_IN_NODE_DEF;\nclass OnPointerupJsParamsConfig extends NodeParamsConfig {\n\t/** @param set which element triggers the event */\n\telement = ParamConfig.INTEGER(EVENT_EMITTERS.indexOf(CoreEventEmitter.CANVAS), {\n\t\t...EVENT_EMITTER_PARAM_MENU_OPTIONS,\n\t\tseparatorAfter: true,\n\t});\n}\nconst ParamsConfig = new OnPointerupJsParamsConfig();\n\nexport class OnPointerupJsNode extends BaseUserInputJsNode<OnPointerupJsParamsConfig> {\n\toverride readonly paramsConfig = ParamsConfig;\n\tstatic override type() {\n\t\treturn JsType.ON_POINTERUP;\n\t}\n\toverride isTriggering() {\n\t\treturn true;\n\t}\n\toverride eventData(): EvaluatorEventData | undefined {\n\t\tif (isTouchDevice()) {\n\t\t\treturn {\n\t\t\t\ttype: TouchEventType.touchend,\n\t\t\t\temitter: this.eventEmitter(),\n\t\t\t\tjsType: JsType.ON_POINTERUP,\n\t\t\t};\n\t\t} else {\n\t\t\treturn {\n\t\t\t\ttype: PointerEventType.pointerup,\n\t\t\t\temitter: this.eventEmitter(),\n\t\t\t\tjsType: JsType.ON_POINTERUP,\n\t\t\t};\n\t\t}\n\t}\n\toverride eventEmitter() {\n\t\treturn EVENT_EMITTERS[this.pv.element];\n\t}\n\tsetEventEmitter(emitter: CoreEventEmitter) {\n\t\tthis.p.element.set(EVENT_EMITTERS.indexOf(emitter));\n\t}\n\n\toverride initializeNode() {\n\t\tsuper.initializeNode();\n\t\tthis.io.outputs.setNamedOutputConnectionPoints([\n\t\t\tnew JsConnectionPoint(TRIGGER_CONNECTION_NAME, JsConnectionPointType.TRIGGER, CONNECTION_OPTIONS),\n\t\t]);\n\t}\n\toverride setTriggeringLines(linesController: JsLinesCollectionController, triggeredMethods: string) {\n\t\tconst object3D = inputObject3D(this, linesController);\n\n\t\tconst func = Poly.namedFunctionsRegister.getFunction('addObjectToPointerupCheck', this, linesController);\n\t\tconst options: ObjectToPointerupOptionsAsString = {\n\t\t\tpointerup: {\n\t\t\t\tcallback: `this.${nodeMethodName(this)}.bind(this)`,\n\t\t\t},\n\t\t};\n\t\tconst jsonOptions = JSON.stringify(options).replace(/\"/g, '');\n\t\tconst bodyLine = func.asString(object3D, `this`, jsonOptions);\n\t\tlinesController.addDefinitions(this, [\n\t\t\tnew InitFunctionJsDefinition(this, linesController, JsConnectionPointType.OBJECT_3D, this.path(), bodyLine),\n\t\t]);\n\n\t\tlinesController.addTriggeringLines(this, [triggeredMethods], {gatherable: true});\n\t}\n}\n","/**\n * sends a trigger on every frame\n *\n *\n */\n\nimport {TRIGGER_CONNECTION_NAME, TypedJsNode} from './_Base';\nimport {NodeParamsConfig} from '../utils/params/ParamsConfig';\nimport {JsConnectionPoint, JsConnectionPointType} from '../utils/io/connections/Js';\nimport {JsType} from '../../poly/registers/nodes/types/Js';\nimport {JsLinesCollectionController} from './code/utils/JsLinesCollectionController';\nimport {ComputedValueJsDefinition} from './utils/JsDefinition';\nimport {Poly} from '../../Poly';\n\nexport enum OnTickJsNodeOuput {\n\tTIME = 'time',\n\tDELTA = 'delta',\n}\n\nclass OnTickJsParamsConfig extends NodeParamsConfig {}\nconst ParamsConfig = new OnTickJsParamsConfig();\n\nexport class OnTickJsNode extends TypedJsNode<OnTickJsParamsConfig> {\n\toverride readonly paramsConfig = ParamsConfig;\n\tstatic override type() {\n\t\treturn JsType.ON_TICK;\n\t}\n\toverride isTriggering() {\n\t\treturn true;\n\t}\n\toverride initializeNode() {\n\t\tthis.io.outputs.setNamedOutputConnectionPoints([\n\t\t\tnew JsConnectionPoint(TRIGGER_CONNECTION_NAME, JsConnectionPointType.TRIGGER),\n\t\t\tnew JsConnectionPoint(OnTickJsNodeOuput.TIME, JsConnectionPointType.FLOAT),\n\t\t\tnew JsConnectionPoint(OnTickJsNodeOuput.DELTA, JsConnectionPointType.FLOAT),\n\t\t]);\n\t}\n\n\toverride setTriggeringLines(linesController: JsLinesCollectionController, triggeredMethods: string): void {\n\t\tlinesController.addTriggeringLines(this, [triggeredMethods], {gatherable: true});\n\t}\n\toverride setLines(linesController: JsLinesCollectionController) {\n\t\tconst timeVarName = this.jsVarName(OnTickJsNodeOuput.TIME);\n\t\tconst deltaVarName = this.jsVarName(OnTickJsNodeOuput.DELTA);\n\n\t\tconst _time = Poly.namedFunctionsRegister.getFunction('globalsTime', this, linesController);\n\t\tconst _delta = Poly.namedFunctionsRegister.getFunction('globalsTimeDelta', this, linesController);\n\t\tlinesController.addDefinitions(this, [\n\t\t\tnew ComputedValueJsDefinition(\n\t\t\t\tthis,\n\t\t\t\tlinesController,\n\t\t\t\tJsConnectionPointType.FLOAT,\n\t\t\t\ttimeVarName,\n\t\t\t\t_time.asString()\n\t\t\t),\n\t\t]);\n\t\tlinesController.addDefinitions(this, [\n\t\t\tnew ComputedValueJsDefinition(\n\t\t\t\tthis,\n\t\t\t\tlinesController,\n\t\t\t\tJsConnectionPointType.FLOAT,\n\t\t\t\tdeltaVarName,\n\t\t\t\t_delta.asString()\n\t\t\t),\n\t\t]);\n\t}\n}\n","/**\n * sends a trigger when a video emits an event\n *\n *\n */\n\nimport {BaseJsNodeType, TypedJsNode} from './_Base';\nimport {NodeParamsConfig, ParamConfig} from '../utils/params/ParamsConfig';\nimport {JsConnectionPoint, JsConnectionPointType} from '../utils/io/connections/Js';\nimport {NodeContext} from '../../poly/NodeContext';\nimport {CopType} from '../../poly/registers/nodes/types/Cop';\n// import {VideoCopNode} from '../cop/Video';\nimport {JsType} from '../../poly/registers/nodes/types/Js';\n// import {objectsForJsNode} from '../../scene/utils/actors/JssManagerUtils';\n// import {Object3D} from 'three';\nimport {\n\tVideoEvent,\n\t// VideoEvent,\n\tVIDEO_EVENTS,\n\t//   VIDEO_EVENT_INDICES\n} from '../../../core/VideoEvent';\nimport {JsLinesCollectionController} from './code/utils/JsLinesCollectionController';\nimport {\n\tgetConnectedOutputNodes,\n\tgetOutputIndices,\n\tnodeMethodName,\n\ttriggerInputIndex,\n} from './code/assemblers/actor/ActorAssemblerUtils';\nimport {setToArray} from '../../../core/SetUtils';\nimport {Poly} from '../../Poly';\nimport {InitFunctionJsDefinition, TriggeringJsDefinition} from './utils/JsDefinition';\nimport {EvaluatorMethodName} from './code/assemblers/actor/ActorEvaluator';\n\n// type Listener = () => void;\n// type Listeners = Record<VideoEvent, Listener>;\n\nclass OnVideoEventJsParamsConfig extends NodeParamsConfig {\n\t/** @param video node */\n\tnode = ParamConfig.NODE_PATH('', {\n\t\tnodeSelection: {\n\t\t\tcontext: NodeContext.COP,\n\t\t\ttypes: [CopType.VIDEO],\n\t\t},\n\t\tcomputeOnDirty: true,\n\t});\n}\nconst ParamsConfig = new OnVideoEventJsParamsConfig();\n\nexport class OnVideoEventJsNode extends TypedJsNode<OnVideoEventJsParamsConfig> {\n\toverride readonly paramsConfig = ParamsConfig;\n\tstatic override type(): JsType.ON_VIDEO_EVENT {\n\t\treturn JsType.ON_VIDEO_EVENT;\n\t}\n\toverride isTriggering() {\n\t\treturn true;\n\t}\n\n\toverride initializeNode() {\n\t\tthis.io.outputs.setNamedOutputConnectionPoints(\n\t\t\tVIDEO_EVENTS.map((triggerName) => new JsConnectionPoint(triggerName, JsConnectionPointType.TRIGGER))\n\t\t);\n\t}\n\toverride setTriggeringLines(\n\t\tshadersCollectionController: JsLinesCollectionController,\n\t\ttriggeredMethods: string\n\t): void {\n\t\tconst node = this.pv.node.node();\n\t\tif (!(node && node.context() == NodeContext.COP)) {\n\t\t\treturn;\n\t\t}\n\t\tconst nodePath = `'${node.path()}'`;\n\t\tconst listeners: Record<VideoEvent, string> = {\n\t\t\t[VideoEvent.PAUSE]: '',\n\t\t\t[VideoEvent.PLAY]: '',\n\t\t\t[VideoEvent.TIME_UPDATE]: '',\n\t\t\t[VideoEvent.VOLUME_CHANGE]: '',\n\t\t};\n\t\tVIDEO_EVENTS.forEach((videoEvent) => {\n\t\t\tconst triggeredMethods = triggerMethod(this, videoEvent);\n\n\t\t\tconst _nodeMethodName = nodeMethodName(this, videoEvent);\n\t\t\tlisteners[videoEvent] = `this.${_nodeMethodName}.bind(this)`;\n\n\t\t\t// const gatherable = options?.gatherable != null ? options.gatherable : false;\n\t\t\t// const triggeringMethodName =\n\t\t\t// \toptions?.triggeringMethodName != null ? options.triggeringMethodName : (node.type() as EvaluatorMethodName);\n\n\t\t\tconst value = triggeredMethods; //triggeringLines.join('\\n');//\n\t\t\t// const varName = videoEvent; //nodeMethodName(node); //.wrappedBodyLinesMethodName();\n\t\t\tconst dataType = JsConnectionPointType.BOOLEAN; // unused\n\t\t\t// if (!EVALUATOR_METHOD_NAMES.includes(triggeringMethodName as EvaluatorMethodName)) {\n\t\t\t// \tconsole.warn(`method '${triggeringMethodName}' is not included`);\n\t\t\t// }\n\t\t\tshadersCollectionController.addDefinitions(this, [\n\t\t\t\tnew TriggeringJsDefinition(this, shadersCollectionController, dataType, _nodeMethodName, value, {\n\t\t\t\t\ttriggeringMethodName: videoEvent as any as EvaluatorMethodName,\n\t\t\t\t\tgatherable: false,\n\t\t\t\t\tnodeMethodName: _nodeMethodName,\n\t\t\t\t}),\n\t\t\t]);\n\t\t});\n\n\t\tconst func = Poly.namedFunctionsRegister.getFunction(\n\t\t\t'addVideoEventListener',\n\t\t\tthis,\n\t\t\tshadersCollectionController\n\t\t);\n\t\tconst bodyLine = func.asString(nodePath, JSON.stringify(listeners).replace(/\\\"/g, ''), `this`);\n\t\tshadersCollectionController.addDefinitions(this, [\n\t\t\tnew InitFunctionJsDefinition(\n\t\t\t\tthis,\n\t\t\t\tshadersCollectionController,\n\t\t\t\tJsConnectionPointType.OBJECT_3D,\n\t\t\t\tthis.path(),\n\t\t\t\tbodyLine\n\t\t\t),\n\t\t]);\n\n\t\t// shadersCollectionController.addTriggeringLines(this, [triggeredMethods], {gatherable: false});\n\t}\n}\n\nfunction triggerMethod(node: OnVideoEventJsNode, outputName: string): string {\n\tconst outputIndex = getOutputIndices(node, (c) => c.name() == outputName)[0];\n\tconst triggerableNodes = new Set<BaseJsNodeType>();\n\tgetConnectedOutputNodes({\n\t\tnode,\n\t\ttriggerOutputIndices: [outputIndex],\n\t\ttriggerableNodes,\n\t\trecursive: false,\n\t});\n\tconst triggerableMethodNames = setToArray(triggerableNodes, []).map((triggerableNode) => {\n\t\tconst argIndex = triggerInputIndex(node, triggerableNode);\n\t\tconst m = nodeMethodName(triggerableNode);\n\t\treturn `this.${m}(${argIndex})`;\n\t});\n\treturn `${triggerableMethodNames.join(';')}`;\n}\n","/**\n * Creates a param on the container node, which allows to control the js function without recompiling it\n *\n *\n */\nimport {TypedJsNode} from './_Base';\nimport {\n\tPARAM_CONVERTIBLE_JS_CONNECTION_POINT_TYPES,\n\t// GlConnectionPoint,\n\tJsConnectionPointType,\n\tJsConnectionPointInitValueMap,\n\tJsConnectionPointTypeToParamTypeMap,\n\tParamConvertibleJsType,\n} from '../utils/io/connections/Js';\n\nimport {NodeParamsConfig, ParamConfig} from '../utils/params/ParamsConfig';\n// import {ParamType} from '../../poly/ParamType';\n// import {UniformJsDefinition} from './utils/JsDefinition';\nimport {ParamConfigsController} from '../utils/code/controllers/ParamConfigsController';\nimport {JsLinesCollectionController} from './code/utils/JsLinesCollectionController';\nimport {JsParamConfig} from './code/utils/JsParamConfig';\nimport {Poly} from '../../Poly';\n// import {ComputedValueJsDefinition} from './utils/JsDefinition';\n// import {CoreType} from '../../../core/Type';\n// import {isBooleanTrue} from '../../../core/BooleanValue';\nclass ParamJsParamsConfig extends NodeParamsConfig {\n\tname = ParamConfig.STRING('');\n\ttype = ParamConfig.INTEGER(PARAM_CONVERTIBLE_JS_CONNECTION_POINT_TYPES.indexOf(JsConnectionPointType.FLOAT), {\n\t\tmenu: {\n\t\t\tentries: PARAM_CONVERTIBLE_JS_CONNECTION_POINT_TYPES.map((name, i) => {\n\t\t\t\treturn {name: name, value: i};\n\t\t\t}),\n\t\t},\n\t});\n}\nconst ParamsConfig = new ParamJsParamsConfig();\n\nexport class ParamJsNode extends TypedJsNode<ParamJsParamsConfig> {\n\toverride paramsConfig = ParamsConfig;\n\tstatic override type() {\n\t\treturn 'param';\n\t}\n\t// protected _allow_inputs_created_from_params: boolean = false;\n\t// static readonly UNIFORM_NAME = 'paramVal';\n\tstatic readonly OUTPUT_NAME = 'val';\n\toverride initializeNode() {\n\t\tthis.addPostDirtyHook('_setFunctionNodeToRecompile', this._setFunctionNodeToRecompile.bind(this));\n\t\tthis.io.connection_points.initializeNode();\n\n\t\tthis.io.connection_points.set_output_name_function((index: number) => ParamJsNode.OUTPUT_NAME);\n\t\tthis.io.connection_points.set_expected_input_types_function(() => []);\n\t\tthis.io.connection_points.set_expected_output_types_function(() => [\n\t\t\tPARAM_CONVERTIBLE_JS_CONNECTION_POINT_TYPES[this.pv.type],\n\t\t]);\n\t}\n\n\toverride setLines(shadersCollectionController: JsLinesCollectionController) {\n\t\tconst out = this.jsVarName(ParamJsNode.OUTPUT_NAME);\n\n\t\tconst _func = Poly.namedFunctionsRegister.getFunction(\n\t\t\t'getActorNodeParamValue',\n\t\t\tthis,\n\t\t\tshadersCollectionController\n\t\t);\n\t\t// shadersCollectionController.addDefinitions(this, [\n\t\t// \tnew ComputedValueJsDefinition(\n\t\t// \t\tthis,\n\t\t// \t\tshadersCollectionController,\n\t\t// \t\tJsConnectionPointType.RAY,\n\t\t// \t\tout,\n\t\t// \t\t_func.asString(`'${this.pv.name}'`)\n\t\t// \t),\n\t\t// ]);\n\n\t\tshadersCollectionController.addBodyOrComputed(this, [\n\t\t\t{\n\t\t\t\tdataType: PARAM_CONVERTIBLE_JS_CONNECTION_POINT_TYPES[this.pv.type],\n\t\t\t\tvarName: out,\n\t\t\t\tvalue: _func.asString(`'${this.pv.name}'`),\n\t\t\t},\n\t\t]);\n\n\t\t// const definitions = [];\n\t\t// const bodyLines: string[] = [];\n\t\t// const type = JS_CONNECTION_POINT_TYPES[this.pv.type];\n\t\t// const varName = this.uniformName();\n\t\t// const out = this.jsVarName(ParamJsNode.OUTPUT_NAME);\n\t\t// // definitions.push(new UniformJsDefinition(this, type, varName));\n\t\t// // lines_controller.addDefinitions(this, definitions);\n\t\t// if (\n\t\t// \t[\n\t\t// \t\tJsConnectionPointType.COLOR,\n\t\t// \t\tJsConnectionPointType.VEC2,\n\t\t// \t\tJsConnectionPointType.VEC3,\n\t\t// \t\tJsConnectionPointType.VEC4,\n\t\t// \t].includes(type)\n\t\t// ) {\n\t\t// } else {\n\t\t// \t// if (param.components) {\n\t\t// \t// \t// bodyLines.push(varName);\n\t\t// \t// \tif (variableFromParamRequired(param)) {\n\t\t// \t// \t\tshadersCollectionController.addVariable(this, out, createVariableFromParam(param));\n\t\t// \t// \t}\n\t\t// \t// \tbodyLines.push(`${out}.copy(${varName})`);\n\t\t// \t// } else {\n\t\t// \t// shadersCollectionController.addVariable(this, out, createVariableFromParam(param));\n\t\t// \tbodyLines.push(`const ${out} = ${varName}`);\n\t\t// \t// }\n\t\t// }\n\t\t// shadersCollectionController.addBodyLines(this, bodyLines);\n\t}\n\toverride setParamConfigs() {\n\t\tconst type = PARAM_CONVERTIBLE_JS_CONNECTION_POINT_TYPES[this.pv.type];\n\t\tconst defaultValue = JsConnectionPointInitValueMap[type];\n\t\tconst paramType = JsConnectionPointTypeToParamTypeMap[type];\n\n\t\tthis._param_configs_controller = this._param_configs_controller || new ParamConfigsController();\n\t\tthis._param_configs_controller.reset();\n\n\t\t// if (\n\t\t// \tparam_type == ParamType.VECTOR3 &&\n\t\t// \tisBooleanTrue(this.p.asColor.value) &&\n\t\t// \tCoreType.isArray(default_value) &&\n\t\t// \tdefault_value.length == 3\n\t\t// ) {\n\t\t// \tconst param_config = new JsParamConfig(ParamType.COLOR, this.pv.name, default_value, this.uniformName());\n\t\t// \tthis._param_configs_controller.push(param_config);\n\t\t// } else {\n\t\tconst param_config = new JsParamConfig(paramType, this.pv.name, defaultValue, this.uniformName());\n\t\tthis._param_configs_controller.push(param_config);\n\t\t// }\n\t}\n\tuniformName() {\n\t\treturn this.jsVarName(ParamJsNode.OUTPUT_NAME);\n\t\t// const output_connection_point = this.io.outputs.namedOutputConnectionPoints()[0];\n\t\t// const varName = this.jsVarName(output_connection_point.name());\n\t\t// return varName;\n\t}\n\tsetJsType(type: ParamConvertibleJsType) {\n\t\tconst index = PARAM_CONVERTIBLE_JS_CONNECTION_POINT_TYPES.indexOf(type);\n\t\tthis.p.type.set(index);\n\t}\n\toverride paramsGenerating() {\n\t\treturn true;\n\t}\n}\n","/**\n * Pause an audio source\n *\n *\n */\nimport {Poly} from '../../Poly';\nimport {JsLinesCollectionController} from './code/utils/JsLinesCollectionController';\nimport {BaseAudioSourceJsNode} from './_BaseAudioSource';\nimport {inputObject3D} from './_BaseObject3D';\n\nexport class PauseAudioSourceJsNode extends BaseAudioSourceJsNode {\n\tstatic override type() {\n\t\treturn 'pauseAudioSource';\n\t}\n\toverride setTriggerableLines(shadersCollectionController: JsLinesCollectionController) {\n\t\tconst object3D = inputObject3D(this, shadersCollectionController);\n\n\t\tconst node = this.pv.node.node();\n\t\tif (!node) {\n\t\t\treturn;\n\t\t}\n\t\tconst nodePath = `'${node.path()}'`;\n\n\t\tconst func = Poly.namedFunctionsRegister.getFunction('pauseAudioSource', this, shadersCollectionController);\n\t\tconst bodyLine = func.asString(object3D, nodePath);\n\t\tshadersCollectionController.addTriggerableLines(this, [bodyLine]);\n\t}\n\toverride setTriggeringLines(\n\t\tshadersCollectionController: JsLinesCollectionController,\n\t\ttriggeredMethods: string\n\t): void {\n\t\tshadersCollectionController.addTriggeringLines(this, [triggeredMethods], {gatherable: false});\n\t}\n}\n","/**\n * starts an animation\n *\n *\n */\n\nimport {TRIGGER_CONNECTION_NAME, TypedJsNode} from './_Base';\nimport {NodeParamsConfig, ParamConfig} from '../utils/params/ParamsConfig';\nimport {JsConnectionPoint, JsConnectionPointType, JS_CONNECTION_POINT_IN_NODE_DEF} from '../utils/io/connections/Js';\nimport {NodeContext} from '../../poly/NodeContext';\nimport {JsLinesCollectionController} from './code/utils/JsLinesCollectionController';\nimport {inputObject3D} from './_BaseObject3D';\nimport {Poly} from '../../Poly';\nimport {ModuleName} from '../../poly/registers/modules/Common';\n\nconst CONNECTION_OPTIONS = JS_CONNECTION_POINT_IN_NODE_DEF;\nexport enum AnimationJsOutput {\n\tSTART = 'start',\n\tCOMPLETE = 'completed',\n}\n\nclass PlayAnimationJsParamsConfig extends NodeParamsConfig {\n\t/** @param include children */\n\tnode = ParamConfig.NODE_PATH('', {\n\t\tnodeSelection: {context: NodeContext.ANIM},\n\t\tdependentOnFoundNode: false,\n\t});\n}\nconst ParamsConfig = new PlayAnimationJsParamsConfig();\n\nexport class PlayAnimationJsNode extends TypedJsNode<PlayAnimationJsParamsConfig> {\n\toverride readonly paramsConfig = ParamsConfig;\n\tstatic override type() {\n\t\treturn 'playAnimation';\n\t}\n\toverride requiredModules() {\n\t\treturn [ModuleName.GSAP];\n\t}\n\n\toverride initializeNode() {\n\t\tthis.io.inputs.setNamedInputConnectionPoints([\n\t\t\tnew JsConnectionPoint(TRIGGER_CONNECTION_NAME, JsConnectionPointType.TRIGGER, CONNECTION_OPTIONS),\n\t\t\tnew JsConnectionPoint(JsConnectionPointType.OBJECT_3D, JsConnectionPointType.OBJECT_3D, CONNECTION_OPTIONS),\n\t\t]);\n\t\tthis.io.outputs.setNamedOutputConnectionPoints([\n\t\t\tnew JsConnectionPoint(AnimationJsOutput.START, JsConnectionPointType.TRIGGER),\n\t\t\tnew JsConnectionPoint(AnimationJsOutput.COMPLETE, JsConnectionPointType.TRIGGER),\n\t\t]);\n\t}\n\n\toverride setTriggerableLines(shadersCollectionController: JsLinesCollectionController) {\n\t\tconst object3D = inputObject3D(this, shadersCollectionController);\n\n\t\tconst node = this.pv.node.node();\n\t\tif (!node) {\n\t\t\treturn;\n\t\t}\n\t\tconst nodePath = `'${node.path()}'`;\n\n\t\tconst func = Poly.namedFunctionsRegister.getFunction('playAnimation', this, shadersCollectionController);\n\t\tconst bodyLine = func.asString(object3D, nodePath);\n\t\tshadersCollectionController.addTriggerableLines(this, [bodyLine]);\n\t}\n}\n","/**\n * Play an audio source\n *\n *\n */\n\nimport {Poly} from '../../Poly';\nimport {JsConnectionPointType} from '../utils/io/connections/Js';\nimport {nodeMethodName, triggerableMethodCalls} from './code/assemblers/actor/ActorAssemblerUtils';\nimport {JsLinesCollectionController} from './code/utils/JsLinesCollectionController';\nimport {InitFunctionJsDefinition, TriggerableJsDefinition} from './utils/JsDefinition';\nimport {BaseAudioSourceJsNode} from './_BaseAudioSource';\nimport {inputObject3D} from './_BaseObject3D';\nexport class PlayAudioSourceJsNode extends BaseAudioSourceJsNode {\n\tstatic override type() {\n\t\treturn 'playAudioSource';\n\t}\n\tprivate _targetNodePath() {\n\t\tconst node = this.pv.node.node();\n\t\tif (!node) {\n\t\t\treturn;\n\t\t}\n\t\tconst nodePath = `'${node.path()}'`;\n\t\treturn nodePath;\n\t}\n\toverride setTriggerableLines(shadersCollectionController: JsLinesCollectionController) {\n\t\tconst nodePath = this._targetNodePath();\n\t\tif (!nodePath) {\n\t\t\treturn;\n\t\t}\n\t\tconst _addPlay = () => {\n\t\t\tconst object3D = inputObject3D(this, shadersCollectionController);\n\n\t\t\tconst func = Poly.namedFunctionsRegister.getFunction('playAudioSource', this, shadersCollectionController);\n\t\t\tconst bodyLine = func.asString(object3D, nodePath);\n\t\t\tshadersCollectionController.addTriggerableLines(this, [bodyLine], {addTriggeredLines: false});\n\t\t};\n\n\t\tconst _addOnStop = () => {\n\t\t\tconst usedOutputNames = this.io.outputs.used_output_names();\n\t\t\tif (!usedOutputNames.includes(JsConnectionPointType.TRIGGER)) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tconst func = Poly.namedFunctionsRegister.getFunction(\n\t\t\t\t'addAudioStopEventListener',\n\t\t\t\tthis,\n\t\t\t\tshadersCollectionController\n\t\t\t);\n\t\t\tconst onStopMethodName = nodeMethodName(this, 'onStop');\n\t\t\tconst bodyLine = func.asString(nodePath, `this.${onStopMethodName}.bind(this)`, `this`);\n\t\t\tshadersCollectionController.addDefinitions(this, [\n\t\t\t\tnew InitFunctionJsDefinition(\n\t\t\t\t\tthis,\n\t\t\t\t\tshadersCollectionController,\n\t\t\t\t\tJsConnectionPointType.OBJECT_3D,\n\t\t\t\t\tthis.path(),\n\t\t\t\t\tbodyLine\n\t\t\t\t),\n\t\t\t]);\n\n\t\t\tconst triggerableLines = triggerableMethodCalls(this);\n\n\t\t\tconst value = triggerableLines;\n\t\t\tconst varName = onStopMethodName;\n\t\t\tconst dataType = JsConnectionPointType.BOOLEAN; // unused\n\t\t\tshadersCollectionController.addDefinitions(this, [\n\t\t\t\tnew TriggerableJsDefinition(this, shadersCollectionController, dataType, varName, value, {\n\t\t\t\t\tmethodName: onStopMethodName,\n\t\t\t\t}),\n\t\t\t]);\n\t\t};\n\t\t_addPlay();\n\t\t_addOnStop();\n\t}\n}\n","/**\n * Play a note\n *\n *\n */\n\nimport {TRIGGER_CONNECTION_NAME, TypedJsNode} from './_Base';\nimport {NodeParamsConfig, ParamConfig} from '../utils/params/ParamsConfig';\nimport {JsConnectionPoint, JsConnectionPointType, JS_CONNECTION_POINT_IN_NODE_DEF} from '../utils/io/connections/Js';\nimport {NodeContext} from '../../poly/NodeContext';\nimport {ALL_NOTES, DEFAULT_NOTE} from '../../../core/audio/Notes';\nimport {inputObject3D} from './_BaseObject3D';\nimport {JsLinesCollectionController} from './code/utils/JsLinesCollectionController';\nimport {Poly} from '../../Poly';\n\nconst CONNECTION_OPTIONS = JS_CONNECTION_POINT_IN_NODE_DEF;\n\nclass PlayInstrumentNoteJsParamsConfig extends NodeParamsConfig {\n\t/** @param audio node */\n\tnode = ParamConfig.NODE_PATH('', {\n\t\tnodeSelection: {\n\t\t\tcontext: NodeContext.AUDIO,\n\t\t},\n\t\t// dependentOnFoundNode: false,\n\t});\n\t/** @param note */\n\tnote = ParamConfig.STRING(DEFAULT_NOTE, {\n\t\tmenuString: {\n\t\t\tentries: ALL_NOTES.sort().map((note) => {\n\t\t\t\treturn {value: note, name: note};\n\t\t\t}),\n\t\t},\n\t\tcook: false,\n\t});\n\t/** @param duration */\n\tduration = ParamConfig.FLOAT(0.125, {\n\t\trange: [0, 1],\n\t\trangeLocked: [true, false],\n\t\tcook: false,\n\t});\n}\nconst ParamsConfig = new PlayInstrumentNoteJsParamsConfig();\n\nexport class PlayInstrumentNoteJsNode extends TypedJsNode<PlayInstrumentNoteJsParamsConfig> {\n\toverride readonly paramsConfig = ParamsConfig;\n\tstatic override type() {\n\t\treturn 'playInstrumentNote';\n\t}\n\n\toverride initializeNode() {\n\t\tthis.io.inputs.setNamedInputConnectionPoints([\n\t\t\tnew JsConnectionPoint(TRIGGER_CONNECTION_NAME, JsConnectionPointType.TRIGGER, CONNECTION_OPTIONS),\n\t\t\tnew JsConnectionPoint(JsConnectionPointType.OBJECT_3D, JsConnectionPointType.OBJECT_3D, CONNECTION_OPTIONS),\n\t\t]);\n\t}\n\n\toverride setTriggerableLines(shadersCollectionController: JsLinesCollectionController) {\n\t\tconst object3D = inputObject3D(this, shadersCollectionController);\n\t\tconst note = this.variableForInputParam(shadersCollectionController, this.p.note);\n\t\tconst duration = this.variableForInputParam(shadersCollectionController, this.p.duration);\n\n\t\tconst node = this.pv.node.node();\n\t\tif (!node) {\n\t\t\treturn;\n\t\t}\n\t\tconst nodePath = `'${node.path()}'`;\n\n\t\tconst func = Poly.namedFunctionsRegister.getFunction('playInstrumentNote', this, shadersCollectionController);\n\t\tconst bodyLine = func.asString(object3D, nodePath, note, duration);\n\t\tshadersCollectionController.addTriggerableLines(this, [bodyLine]);\n\t}\n}\n","/**\n * gets the ray from the cursor\n *\n * @remarks\n *\n *\n */\n\nimport {NodeParamsConfig, ParamConfig} from '../utils/params/ParamsConfig';\nimport {JsConnectionPoint, JsConnectionPointType} from '../utils/io/connections/Js';\nimport {JsType} from '../../poly/registers/nodes/types/Js';\nimport {BaseUserInputJsNode} from './_BaseUserInput';\nimport {CoreEventEmitter, EVENT_EMITTERS, EVENT_EMITTER_PARAM_MENU_OPTIONS} from '../../../core/event/CoreEventEmitter';\nimport {JsLinesCollectionController} from './code/utils/JsLinesCollectionController';\nimport {ComputedValueJsDefinition} from './utils/JsDefinition';\nimport {EvaluatorEventData} from './code/assemblers/actor/ActorEvaluator';\nimport {Poly} from '../../Poly';\nimport {PointerEventType} from '../../../core/event/PointerEventType';\n\nconst OUTPUT_NAME = JsConnectionPointType.RAY;\nclass RayFromCursorJsParamsConfig extends NodeParamsConfig {\n\t/** @param set which element triggers the event */\n\telement = ParamConfig.INTEGER(EVENT_EMITTERS.indexOf(CoreEventEmitter.CANVAS), {\n\t\t...EVENT_EMITTER_PARAM_MENU_OPTIONS,\n\t});\n}\nconst ParamsConfig = new RayFromCursorJsParamsConfig();\nexport class RayFromCursorJsNode extends BaseUserInputJsNode<RayFromCursorJsParamsConfig> {\n\toverride paramsConfig = ParamsConfig;\n\tstatic override type() {\n\t\treturn JsType.RAY_FROM_CURSOR;\n\t}\n\t// userInputEventNames() {\n\t// \treturn ['pointermove'];\n\t// }\n\toverride eventData(): EvaluatorEventData[] | undefined {\n\t\treturn [\n\t\t\t{\n\t\t\t\ttype: PointerEventType.pointermove,\n\t\t\t\temitter: this.eventEmitter(),\n\t\t\t\tjsType: JsType.RAY_FROM_CURSOR,\n\t\t\t},\n\t\t\t{\n\t\t\t\ttype: PointerEventType.touchmove,\n\t\t\t\temitter: this.eventEmitter(),\n\t\t\t\tjsType: JsType.RAY_FROM_CURSOR,\n\t\t\t},\n\t\t];\n\t}\n\toverride eventEmitter() {\n\t\treturn EVENT_EMITTERS[this.pv.element];\n\t}\n\tsetEventEmitter(emitter: CoreEventEmitter) {\n\t\tthis.p.element.set(EVENT_EMITTERS.indexOf(emitter));\n\t}\n\toverride initializeNode() {\n\t\tthis.io.connection_points.spare_params.setInputlessParamNames(['element']);\n\t\tthis.io.outputs.setNamedOutputConnectionPoints([new JsConnectionPoint(OUTPUT_NAME, JsConnectionPointType.RAY)]);\n\t}\n\toverride setLines(shadersCollectionController: JsLinesCollectionController) {\n\t\tconst out = this.jsVarName(OUTPUT_NAME);\n\n\t\tconst _ray = Poly.namedFunctionsRegister.getFunction('globalsRayFromCursor', this, shadersCollectionController);\n\t\tshadersCollectionController.addDefinitions(this, [\n\t\t\tnew ComputedValueJsDefinition(\n\t\t\t\tthis,\n\t\t\t\tshadersCollectionController,\n\t\t\t\tJsConnectionPointType.VECTOR2,\n\t\t\t\tout,\n\t\t\t\t_ray.asString()\n\t\t\t),\n\t\t]);\n\t}\n}\n","/**\n * Update the object attribute\n *\n *\n */\n\nimport {TRIGGER_CONNECTION_NAME, TypedJsNode} from './_Base';\nimport {\n\tJsConnectionPoint,\n\tJsConnectionPointType,\n\tJS_CONNECTION_POINT_IN_NODE_DEF,\n\tParamConvertibleJsType,\n\tPARAM_CONVERTIBLE_JS_CONNECTION_POINT_TYPES,\n} from '../utils/io/connections/Js';\nimport {NodeParamsConfig, ParamConfig} from '../utils/params/ParamsConfig';\nimport {inputObject3D, setObject3DOutputLine} from './_BaseObject3D';\nimport {JsLinesCollectionController} from './code/utils/JsLinesCollectionController';\nimport {Poly} from '../../Poly';\nimport {StringParam} from '../../params/String';\nimport {JsType} from '../../poly/registers/nodes/types/Js';\nexport enum SetObjectAttributeInputName {\n\tattribName = 'attribName',\n\tlerp = 'lerp',\n\tval = 'val',\n}\n\nconst CONNECTION_OPTIONS = JS_CONNECTION_POINT_IN_NODE_DEF;\nclass SetObjectAttributeJsParamsConfig extends NodeParamsConfig {\n\t/** @param attribute type */\n\ttype = ParamConfig.INTEGER(PARAM_CONVERTIBLE_JS_CONNECTION_POINT_TYPES.indexOf(JsConnectionPointType.FLOAT), {\n\t\tmenu: {\n\t\t\tentries: PARAM_CONVERTIBLE_JS_CONNECTION_POINT_TYPES.map((name, i) => {\n\t\t\t\treturn {name: name, value: i};\n\t\t\t}),\n\t\t},\n\t});\n}\nconst ParamsConfig = new SetObjectAttributeJsParamsConfig();\n\nexport class SetObjectAttributeJsNode extends TypedJsNode<SetObjectAttributeJsParamsConfig> {\n\toverride readonly paramsConfig = ParamsConfig;\n\tstatic override type() {\n\t\treturn JsType.SET_OBJECT_ATTRIBUTE;\n\t}\n\n\toverride initializeNode() {\n\t\tthis.io.inputs.setNamedInputConnectionPoints([\n\t\t\tnew JsConnectionPoint(TRIGGER_CONNECTION_NAME, JsConnectionPointType.TRIGGER, CONNECTION_OPTIONS),\n\t\t\tnew JsConnectionPoint(JsConnectionPointType.OBJECT_3D, JsConnectionPointType.OBJECT_3D, CONNECTION_OPTIONS),\n\t\t\tnew JsConnectionPoint(\n\t\t\t\tSetObjectAttributeInputName.attribName,\n\t\t\t\tJsConnectionPointType.STRING,\n\t\t\t\tCONNECTION_OPTIONS\n\t\t\t),\n\t\t\tnew JsConnectionPoint<JsConnectionPointType.FLOAT>('lerp', JsConnectionPointType.FLOAT, {\n\t\t\t\t...CONNECTION_OPTIONS,\n\t\t\t\tinit_value: 1,\n\t\t\t}),\n\t\t]);\n\n\t\tthis.io.connection_points.set_input_name_function(() => SetObjectAttributeInputName.val);\n\t\tthis.io.connection_points.set_expected_input_types_function(() => [this._currentConnectionType()]);\n\t\tthis.io.connection_points.set_output_name_function(\n\t\t\t(i) => [TRIGGER_CONNECTION_NAME, JsConnectionPointType.OBJECT_3D][i]\n\t\t);\n\t\tthis.io.connection_points.set_expected_output_types_function(() => [\n\t\t\tJsConnectionPointType.TRIGGER,\n\t\t\tJsConnectionPointType.OBJECT_3D,\n\t\t]);\n\t}\n\tprivate _currentConnectionType() {\n\t\tif (this.pv.type == null) {\n\t\t\tconsole.warn(`${this.type()} js node type not valid`);\n\t\t}\n\t\tconst connectionType = PARAM_CONVERTIBLE_JS_CONNECTION_POINT_TYPES[this.pv.type];\n\t\tif (connectionType == null) {\n\t\t\tconsole.warn(`${this.type()} js node type not valid`);\n\t\t}\n\t\treturn connectionType || JsConnectionPointType.FLOAT;\n\t}\n\n\tprivate _nextAttribName: string = '';\n\toverride paramDefaultValue(name: SetObjectAttributeInputName) {\n\t\treturn {\n\t\t\t[SetObjectAttributeInputName.attribName]: this._nextAttribName,\n\t\t\t[SetObjectAttributeInputName.lerp]: 1,\n\t\t\t[SetObjectAttributeInputName.val]: 0,\n\t\t}[name];\n\t}\n\tsetAttribType(type: ParamConvertibleJsType) {\n\t\tthis.p.type.set(PARAM_CONVERTIBLE_JS_CONNECTION_POINT_TYPES.indexOf(type));\n\t}\n\tsetAttribName(attribName: string) {\n\t\tconst param = this.params.get(SetObjectAttributeInputName.attribName) as StringParam | undefined;\n\t\tif (param) {\n\t\t\tparam.set(attribName);\n\t\t} else {\n\t\t\tthis._nextAttribName = attribName;\n\t\t}\n\t}\n\toverride setLines(linesController: JsLinesCollectionController) {\n\t\tsetObject3DOutputLine(this, linesController);\n\t}\n\toverride setTriggerableLines(shadersCollectionController: JsLinesCollectionController) {\n\t\tconst object3D = inputObject3D(this, shadersCollectionController);\n\t\tconst attribName = this.variableForInput(shadersCollectionController, SetObjectAttributeInputName.attribName);\n\t\tconst lerp = this.variableForInput(shadersCollectionController, SetObjectAttributeInputName.lerp);\n\t\tconst newValue = this.variableForInput(shadersCollectionController, SetObjectAttributeInputName.val);\n\n\t\tconst func = Poly.namedFunctionsRegister.getFunction('setObjectAttribute', this, shadersCollectionController);\n\t\tconst bodyLine = func.asString(object3D, attribName, lerp, newValue, `'${this._currentConnectionType()}'`);\n\t\tshadersCollectionController.addTriggerableLines(this, [bodyLine]);\n\t}\n}\n","/**\n * Make object look at a position\n *\n *\n */\n\nimport {TRIGGER_CONNECTION_NAME, TypedJsNode} from './_Base';\nimport {NodeParamsConfig, ParamConfig} from '../utils/params/ParamsConfig';\nimport {JsConnectionPoint, JsConnectionPointType, JS_CONNECTION_POINT_IN_NODE_DEF} from '../utils/io/connections/Js';\nimport {JsType} from '../../poly/registers/nodes/types/Js';\nimport {JsLinesCollectionController} from './code/utils/JsLinesCollectionController';\nimport {Poly} from '../../Poly';\nimport {inputObject3D, setObject3DOutputLine} from './_BaseObject3D';\n\nconst CONNECTION_OPTIONS = JS_CONNECTION_POINT_IN_NODE_DEF;\n\nclass SetObjectLookAtJsParamsConfig extends NodeParamsConfig {\n\t/** @param targetPosition */\n\ttargetPosition = ParamConfig.VECTOR3([0, 0, 0]);\n\t/** @param up */\n\tup = ParamConfig.VECTOR3([0, 1, 0]);\n\t/** @param lerp factor */\n\tlerp = ParamConfig.FLOAT(1);\n\t/** @param invertDirection */\n\tinvertDirection = ParamConfig.BOOLEAN(0);\n\t/** @param sets if the matrix should be updated as the animation progresses */\n\tupdateMatrix = ParamConfig.BOOLEAN(1);\n}\nconst ParamsConfig = new SetObjectLookAtJsParamsConfig();\n\nexport class SetObjectLookAtJsNode extends TypedJsNode<SetObjectLookAtJsParamsConfig> {\n\toverride readonly paramsConfig = ParamsConfig;\n\tstatic override type() {\n\t\treturn JsType.SET_OBJECT_LOOK_AT;\n\t}\n\n\toverride initializeNode() {\n\t\tthis.io.inputs.setNamedInputConnectionPoints([\n\t\t\tnew JsConnectionPoint(TRIGGER_CONNECTION_NAME, JsConnectionPointType.TRIGGER, CONNECTION_OPTIONS),\n\t\t\tnew JsConnectionPoint(JsConnectionPointType.OBJECT_3D, JsConnectionPointType.OBJECT_3D, CONNECTION_OPTIONS),\n\t\t]);\n\n\t\tthis.io.outputs.setNamedOutputConnectionPoints([\n\t\t\tnew JsConnectionPoint(TRIGGER_CONNECTION_NAME, JsConnectionPointType.TRIGGER),\n\t\t\tnew JsConnectionPoint(JsConnectionPointType.OBJECT_3D, JsConnectionPointType.OBJECT_3D),\n\t\t]);\n\t}\n\toverride setLines(linesController: JsLinesCollectionController) {\n\t\tsetObject3DOutputLine(this, linesController);\n\t}\n\toverride setTriggerableLines(linesController: JsLinesCollectionController) {\n\t\tconst object3D = inputObject3D(this, linesController);\n\t\tconst targetPosition = this.variableForInputParam(linesController, this.p.targetPosition);\n\t\tconst up = this.variableForInputParam(linesController, this.p.up);\n\t\tconst lerp = this.variableForInputParam(linesController, this.p.lerp);\n\t\tconst invertDirection = this.variableForInputParam(linesController, this.p.invertDirection);\n\t\tconst updateMatrix = this.variableForInputParam(linesController, this.p.updateMatrix);\n\n\t\tconst func = Poly.namedFunctionsRegister.getFunction('setObjectLookAt', this, linesController);\n\t\tconst bodyLine = func.asString(object3D, targetPosition, up, lerp, invertDirection, updateMatrix);\n\t\tlinesController.addTriggerableLines(this, [bodyLine]);\n\t}\n}\n","/**\n * applies a polar transform to the object\n *\n *\n */\nimport {TRIGGER_CONNECTION_NAME, TypedJsNode} from './_Base';\nimport {NodeParamsConfig, ParamConfig} from '../utils/params/ParamsConfig';\nimport {JsConnectionPoint, JsConnectionPointType, JS_CONNECTION_POINT_IN_NODE_DEF} from '../utils/io/connections/Js';\nimport {inputObject3D, setObject3DOutputLine} from './_BaseObject3D';\nimport {JsLinesCollectionController} from './code/utils/JsLinesCollectionController';\nimport {Poly} from '../../Poly';\n\nconst CONNECTION_OPTIONS = JS_CONNECTION_POINT_IN_NODE_DEF;\n\nclass SetObjectPolarTransformJsParamsConfig extends NodeParamsConfig {\n\t/** @param center of the transform */\n\tcenter = ParamConfig.VECTOR3([0, 0, 0]);\n\t/** @param moves the objects along the longitude, which is equivalent to a rotation on the y axis */\n\tlongitude = ParamConfig.FLOAT(0, {\n\t\trange: [-360, 360],\n\t});\n\t/** @param moves the objects along the latitude, which is equivalent to a rotation on the z or x axis */\n\tlatitude = ParamConfig.FLOAT(0, {\n\t\trange: [-180, 180],\n\t});\n\t/** @param moves the point aways from the center */\n\tdepth = ParamConfig.FLOAT(1, {\n\t\trange: [0, 10],\n\t});\n\t/** @param lerp factor */\n\t// lerp = ParamConfig.FLOAT(1);\n\t/** @param sets if the matrix should be updated as the animation progresses */\n\t// updateMatrix = ParamConfig.BOOLEAN(1);\n}\nconst ParamsConfig = new SetObjectPolarTransformJsParamsConfig();\n\nexport class SetObjectPolarTransformJsNode extends TypedJsNode<SetObjectPolarTransformJsParamsConfig> {\n\toverride readonly paramsConfig = ParamsConfig;\n\tstatic override type() {\n\t\treturn 'setObjectPolarTransform';\n\t}\n\n\toverride initializeNode() {\n\t\tthis.io.inputs.setNamedInputConnectionPoints([\n\t\t\tnew JsConnectionPoint(TRIGGER_CONNECTION_NAME, JsConnectionPointType.TRIGGER, CONNECTION_OPTIONS),\n\t\t\tnew JsConnectionPoint(JsConnectionPointType.OBJECT_3D, JsConnectionPointType.OBJECT_3D, CONNECTION_OPTIONS),\n\t\t]);\n\n\t\tthis.io.outputs.setNamedOutputConnectionPoints([\n\t\t\tnew JsConnectionPoint(TRIGGER_CONNECTION_NAME, JsConnectionPointType.TRIGGER),\n\t\t\tnew JsConnectionPoint(JsConnectionPointType.OBJECT_3D, JsConnectionPointType.OBJECT_3D, CONNECTION_OPTIONS),\n\t\t]);\n\t}\n\toverride setLines(linesController: JsLinesCollectionController) {\n\t\tsetObject3DOutputLine(this, linesController);\n\t}\n\toverride setTriggerableLines(linesController: JsLinesCollectionController) {\n\t\tconst object3D = inputObject3D(this, linesController);\n\t\tconst center = this.variableForInputParam(linesController, this.p.center);\n\t\tconst longitude = this.variableForInputParam(linesController, this.p.longitude);\n\t\tconst latitude = this.variableForInputParam(linesController, this.p.latitude);\n\t\tconst depth = this.variableForInputParam(linesController, this.p.depth);\n\n\t\tconst func = Poly.namedFunctionsRegister.getFunction('setObjectPolarTransform', this, linesController);\n\t\tconst bodyLine = func.asString(object3D, center, longitude, latitude, depth);\n\t\tlinesController.addTriggerableLines(this, [bodyLine]);\n\t}\n}\n","/**\n * Update the object position\n *\n *\n */\n\nimport {NodeParamsConfig, ParamConfig} from '../utils/params/ParamsConfig';\nimport {JsLinesCollectionController} from './code/utils/JsLinesCollectionController';\nimport {JsType} from '../../poly/registers/nodes/types/Js';\nimport {Poly} from '../../Poly';\nimport {inputObject3D, vector3OutputFromParam, floatOutputFromParam, booleanOutputFromParam} from './_BaseObject3D';\nimport {BaseTriggerAndObjectJsNode} from './_BaseTriggerAndObject';\nimport {JS_CONNECTION_POINT_IN_NODE_DEF, JsConnectionPoint, JsConnectionPointType} from '../utils/io/connections/Js';\n\nconst CONNECTION_OPTIONS = JS_CONNECTION_POINT_IN_NODE_DEF;\nclass SetObjectPositionJsParamsConfig extends NodeParamsConfig {\n\t/** @param target position */\n\tposition = ParamConfig.VECTOR3([0, 0, 0]);\n\t/** @param lerp factor */\n\tlerp = ParamConfig.FLOAT(1);\n\t/** @param sets if the matrix should be updated as the animation progresses */\n\tupdateMatrix = ParamConfig.BOOLEAN(1);\n}\nconst ParamsConfig = new SetObjectPositionJsParamsConfig();\n\nexport class SetObjectPositionJsNode extends BaseTriggerAndObjectJsNode<SetObjectPositionJsParamsConfig> {\n\toverride readonly paramsConfig = ParamsConfig;\n\tstatic override type() {\n\t\treturn JsType.SET_OBJECT_POSITION;\n\t}\n\n\tprotected override _additionalOutputs(): JsConnectionPoint<JsConnectionPointType>[] {\n\t\treturn [\n\t\t\tnew JsConnectionPoint('position', JsConnectionPointType.VECTOR3, CONNECTION_OPTIONS),\n\t\t\tnew JsConnectionPoint('lerp', JsConnectionPointType.FLOAT, CONNECTION_OPTIONS),\n\t\t\tnew JsConnectionPoint('updateMatrix', JsConnectionPointType.BOOLEAN, CONNECTION_OPTIONS),\n\t\t];\n\t}\n\n\toverride setLines(linesController: JsLinesCollectionController) {\n\t\tsuper.setLines(linesController);\n\n\t\tvector3OutputFromParam(this, this.p.position, linesController);\n\t\tfloatOutputFromParam(this, this.p.lerp, linesController);\n\t\tbooleanOutputFromParam(this, this.p.updateMatrix, linesController);\n\t}\n\n\toverride setTriggerableLines(linesController: JsLinesCollectionController) {\n\t\tconst object3D = inputObject3D(this, linesController);\n\t\tconst position = this.variableForInputParam(linesController, this.p.position);\n\t\tconst lerp = this.variableForInputParam(linesController, this.p.lerp);\n\t\tconst updateMatrix = this.variableForInputParam(linesController, this.p.updateMatrix);\n\n\t\tconst func = Poly.namedFunctionsRegister.getFunction('setObjectPosition', this, linesController);\n\t\tconst bodyLine = func.asString(object3D, position, lerp, updateMatrix);\n\t\tlinesController.addTriggerableLines(this, [bodyLine]);\n\t}\n}\n","/**\n * Update the object rotation\n *\n *\n */\n\nimport {TRIGGER_CONNECTION_NAME, TypedJsNode} from './_Base';\nimport {NodeParamsConfig, ParamConfig} from '../utils/params/ParamsConfig';\nimport {JsConnectionPoint, JsConnectionPointType, JS_CONNECTION_POINT_IN_NODE_DEF} from '../utils/io/connections/Js';\nimport {inputObject3D, setObject3DOutputLine} from './_BaseObject3D';\nimport {JsLinesCollectionController} from './code/utils/JsLinesCollectionController';\nimport {Poly} from '../../Poly';\n\nconst CONNECTION_OPTIONS = JS_CONNECTION_POINT_IN_NODE_DEF;\n\nclass SetObjectRotationJsParamsConfig extends NodeParamsConfig {\n\t/** @param lerp factor */\n\tlerp = ParamConfig.FLOAT(1);\n\t/** @param sets if the matrix should be updated as the animation progresses */\n\tupdateMatrix = ParamConfig.BOOLEAN(1);\n}\nconst ParamsConfig = new SetObjectRotationJsParamsConfig();\n\nexport class SetObjectRotationJsNode extends TypedJsNode<SetObjectRotationJsParamsConfig> {\n\toverride readonly paramsConfig = ParamsConfig;\n\tstatic override type() {\n\t\treturn 'setObjectRotation';\n\t}\n\n\toverride initializeNode() {\n\t\tthis.io.connection_points.spare_params.setInputlessParamNames(['rotationOrder']);\n\t\tthis.io.inputs.setNamedInputConnectionPoints([\n\t\t\tnew JsConnectionPoint(TRIGGER_CONNECTION_NAME, JsConnectionPointType.TRIGGER, CONNECTION_OPTIONS),\n\t\t\tnew JsConnectionPoint(JsConnectionPointType.OBJECT_3D, JsConnectionPointType.OBJECT_3D, CONNECTION_OPTIONS),\n\t\t\tnew JsConnectionPoint(JsConnectionPointType.EULER, JsConnectionPointType.EULER, CONNECTION_OPTIONS),\n\t\t]);\n\n\t\tthis.io.outputs.setNamedOutputConnectionPoints([\n\t\t\tnew JsConnectionPoint(TRIGGER_CONNECTION_NAME, JsConnectionPointType.TRIGGER),\n\t\t\tnew JsConnectionPoint(JsConnectionPointType.OBJECT_3D, JsConnectionPointType.OBJECT_3D, CONNECTION_OPTIONS),\n\t\t]);\n\t}\n\toverride setLines(linesController: JsLinesCollectionController) {\n\t\tsetObject3DOutputLine(this, linesController);\n\t}\n\toverride setTriggerableLines(shadersCollectionController: JsLinesCollectionController) {\n\t\tconst object3D = inputObject3D(this, shadersCollectionController);\n\t\tconst euler = this.variableForInput(shadersCollectionController, JsConnectionPointType.EULER);\n\t\tconst lerp = this.variableForInputParam(shadersCollectionController, this.p.lerp);\n\t\tconst updateMatrix = this.variableForInputParam(shadersCollectionController, this.p.updateMatrix);\n\n\t\tconst func = Poly.namedFunctionsRegister.getFunction('setObjectRotation', this, shadersCollectionController);\n\t\tconst bodyLine = func.asString(object3D, euler, lerp, updateMatrix);\n\t\tshadersCollectionController.addTriggerableLines(this, [bodyLine]);\n\t}\n}\n","/**\n * Update the object scale\n *\n *\n */\n\nimport {NodeParamsConfig, ParamConfig} from '../utils/params/ParamsConfig';\nimport {JsConnectionPoint, JsConnectionPointType, JS_CONNECTION_POINT_IN_NODE_DEF} from '../utils/io/connections/Js';\nimport {JsLinesCollectionController} from './code/utils/JsLinesCollectionController';\nimport {Poly} from '../../Poly';\nimport {booleanOutputFromParam, floatOutputFromParam, inputObject3D, vector3OutputFromParam} from './_BaseObject3D';\nimport {BaseTriggerAndObjectJsNode} from './_BaseTriggerAndObject';\nimport {JsType} from '../../poly/registers/nodes/types/Js';\n\nconst CONNECTION_OPTIONS = JS_CONNECTION_POINT_IN_NODE_DEF;\n\nclass SetObjectScaleJsParamsConfig extends NodeParamsConfig {\n\t/** @param target scale */\n\tscale = ParamConfig.VECTOR3([1, 1, 1]);\n\t/** @param target scale */\n\tmult = ParamConfig.FLOAT(1, {\n\t\trange: [0, 2],\n\t\trangeLocked: [false, false],\n\t});\n\t/** @param lerp factor */\n\tlerp = ParamConfig.FLOAT(1);\n\t/** @param sets if the matrix should be updated as the animation progresses */\n\tupdateMatrix = ParamConfig.BOOLEAN(1);\n}\nconst ParamsConfig = new SetObjectScaleJsParamsConfig();\n\nexport class SetObjectScaleJsNode extends BaseTriggerAndObjectJsNode<SetObjectScaleJsParamsConfig> {\n\toverride readonly paramsConfig = ParamsConfig;\n\tstatic override type() {\n\t\treturn JsType.SET_OBJECT_SCALE;\n\t}\n\n\tprotected override _additionalOutputs(): JsConnectionPoint<JsConnectionPointType>[] {\n\t\treturn [\n\t\t\tnew JsConnectionPoint('scale', JsConnectionPointType.VECTOR3, CONNECTION_OPTIONS),\n\t\t\tnew JsConnectionPoint('mult', JsConnectionPointType.FLOAT, CONNECTION_OPTIONS),\n\t\t\tnew JsConnectionPoint('lerp', JsConnectionPointType.FLOAT, CONNECTION_OPTIONS),\n\t\t\tnew JsConnectionPoint('updateMatrix', JsConnectionPointType.BOOLEAN, CONNECTION_OPTIONS),\n\t\t];\n\t}\n\n\toverride setLines(linesController: JsLinesCollectionController) {\n\t\tsuper.setLines(linesController);\n\n\t\tvector3OutputFromParam(this, this.p.scale, linesController);\n\t\tfloatOutputFromParam(this, this.p.mult, linesController);\n\t\tfloatOutputFromParam(this, this.p.lerp, linesController);\n\t\tbooleanOutputFromParam(this, this.p.updateMatrix, linesController);\n\t}\n\toverride setTriggerableLines(linesController: JsLinesCollectionController) {\n\t\tconst object3D = inputObject3D(this, linesController);\n\t\tconst scale = this.variableForInputParam(linesController, this.p.scale);\n\t\tconst mult = this.variableForInputParam(linesController, this.p.mult);\n\t\tconst lerp = this.variableForInputParam(linesController, this.p.lerp);\n\t\tconst updateMatrix = this.variableForInputParam(linesController, this.p.updateMatrix);\n\n\t\tconst func = Poly.namedFunctionsRegister.getFunction('setObjectScale', this, linesController);\n\t\tconst bodyLine = func.asString(object3D, scale, mult, lerp, updateMatrix);\n\t\tlinesController.addTriggerableLines(this, [bodyLine]);\n\t}\n}\n","/**\n * Updates the param of specific node\n *\n *\n */\nimport {TRIGGER_CONNECTION_NAME, TypedJsNode} from './_Base';\nimport {NodeParamsConfig, ParamConfig} from '../utils/params/ParamsConfig';\nimport {\n\tJsConnectionPoint,\n\tJsConnectionPointType,\n\tJS_CONNECTION_POINT_IN_NODE_DEF,\n\tParamConvertibleJsType,\n\tPARAM_CONVERTIBLE_JS_CONNECTION_POINT_TYPES,\n} from '../utils/io/connections/Js';\nimport {JsLinesCollectionController} from './code/utils/JsLinesCollectionController';\nimport {Poly} from '../../Poly';\nimport {TypeAssert} from '../../poly/Assert';\nimport {ParamPathParam} from '../../params/ParamPath';\nimport {JsType} from '../../poly/registers/nodes/types/Js';\nimport {inputParam} from './_BaseObject3D';\nimport {BaseParamType} from '../../params/_Base';\n\nconst CONNECTION_OPTIONS = JS_CONNECTION_POINT_IN_NODE_DEF;\n\nexport enum SetParamJsNodeInputName {\n\tlerp = 'lerp',\n\tval = 'val',\n}\n\ninterface SetParamOptions {\n\tcontroller: JsLinesCollectionController;\n\tparam: string;\n\t// paramName: string;\n\tparamValue: string;\n\tlerp: string;\n}\n\nclass SetParamJsParamsConfig extends NodeParamsConfig {\n\t/** @param type of the parameter to update */\n\ttype = ParamConfig.INTEGER(PARAM_CONVERTIBLE_JS_CONNECTION_POINT_TYPES.indexOf(JsConnectionPointType.FLOAT), {\n\t\tmenu: {\n\t\t\tentries: PARAM_CONVERTIBLE_JS_CONNECTION_POINT_TYPES.map((name, value) => {\n\t\t\t\treturn {name, value};\n\t\t\t}),\n\t\t},\n\t});\n}\nconst ParamsConfig = new SetParamJsParamsConfig();\n\nexport class SetParamJsNode extends TypedJsNode<SetParamJsParamsConfig> {\n\toverride readonly paramsConfig = ParamsConfig;\n\tstatic override type() {\n\t\treturn JsType.SET_PARAM;\n\t}\n\n\toverride initializeNode() {\n\t\tthis.io.inputs.setNamedInputConnectionPoints([\n\t\t\tnew JsConnectionPoint(JsConnectionPointType.TRIGGER, JsConnectionPointType.TRIGGER, CONNECTION_OPTIONS),\n\t\t\tnew JsConnectionPoint(JsConnectionPointType.PARAM, JsConnectionPointType.PARAM, CONNECTION_OPTIONS),\n\t\t\tnew JsConnectionPoint<JsConnectionPointType.FLOAT>(\n\t\t\t\tSetParamJsNodeInputName.lerp,\n\t\t\t\tJsConnectionPointType.FLOAT,\n\t\t\t\t{\n\t\t\t\t\t...CONNECTION_OPTIONS,\n\t\t\t\t\tinit_value: 1,\n\t\t\t\t}\n\t\t\t),\n\t\t]);\n\n\t\tthis.io.connection_points.set_input_name_function(() => SetParamJsNodeInputName.val);\n\t\tthis.io.connection_points.set_expected_input_types_function(() => [this._currentConnectionType()]);\n\t\tthis.io.connection_points.set_output_name_function(() => TRIGGER_CONNECTION_NAME);\n\t\tthis.io.connection_points.set_expected_output_types_function(() => [JsConnectionPointType.TRIGGER]);\n\t}\n\tprivate _currentConnectionType() {\n\t\tif (this.pv.type == null) {\n\t\t\tconsole.warn(`${this.type()} type not valid`);\n\t\t}\n\t\tconst connectionType = PARAM_CONVERTIBLE_JS_CONNECTION_POINT_TYPES[this.pv.type];\n\t\tif (connectionType == null) {\n\t\t\tconsole.warn(`${this.type()} type not valid`);\n\t\t}\n\t\treturn connectionType || JsConnectionPointType.FLOAT;\n\t}\n\tsetParamType(paramType: ParamConvertibleJsType) {\n\t\tconst index = PARAM_CONVERTIBLE_JS_CONNECTION_POINT_TYPES.indexOf(paramType);\n\t\tif (index < 0) {\n\t\t\tconsole.warn(\n\t\t\t\t`only the following types are accepted: ${PARAM_CONVERTIBLE_JS_CONNECTION_POINT_TYPES.join(', ')}`\n\t\t\t);\n\t\t\treturn;\n\t\t}\n\t\tthis.p.type.set(index);\n\t}\n\tsetParamPath(paramPath: string) {\n\t\t(this.params.get(JsConnectionPointType.PARAM) as ParamPathParam).set(paramPath);\n\t}\n\tsetParamParam(param: BaseParamType) {\n\t\t(this.params.get(JsConnectionPointType.PARAM) as ParamPathParam).setParam(param);\n\t}\n\toverride setTriggerableLines(controller: JsLinesCollectionController) {\n\t\tconst param = inputParam(this, controller);\n\t\tconst paramValue = this.variableForInput(controller, SetParamJsNodeInputName.val);\n\t\tconst lerp = this.variableForInput(controller, SetParamJsNodeInputName.lerp);\n\n\t\tconst bodyLine = this._bodyLine({\n\t\t\tcontroller,\n\t\t\tparam,\n\t\t\tparamValue,\n\t\t\tlerp,\n\t\t});\n\t\tif (!bodyLine) {\n\t\t\treturn;\n\t\t}\n\n\t\tcontroller.addTriggerableLines(this, [bodyLine]);\n\t}\n\tprivate _bodyLine(options: SetParamOptions): string | undefined {\n\t\tconst type = PARAM_CONVERTIBLE_JS_CONNECTION_POINT_TYPES[this.pv.type];\n\t\tswitch (type) {\n\t\t\tcase JsConnectionPointType.BOOLEAN: {\n\t\t\t\treturn this._setBoolean(options);\n\t\t\t}\n\t\t\tcase JsConnectionPointType.COLOR: {\n\t\t\t\treturn this._setColor(options);\n\t\t\t}\n\t\t\tcase JsConnectionPointType.FLOAT: {\n\t\t\t\treturn this._setFloat(options);\n\t\t\t}\n\t\t\tcase JsConnectionPointType.INT: {\n\t\t\t\treturn this._setInt(options);\n\t\t\t}\n\t\t\tcase JsConnectionPointType.STRING: {\n\t\t\t\treturn this._setString(options);\n\t\t\t}\n\t\t\tcase JsConnectionPointType.VECTOR2: {\n\t\t\t\treturn this._setVector2(options);\n\t\t\t}\n\t\t\tcase JsConnectionPointType.VECTOR3: {\n\t\t\t\treturn this._setVector3(options);\n\t\t\t}\n\t\t\tcase JsConnectionPointType.VECTOR4: {\n\t\t\t\treturn this._setVector4(options);\n\t\t\t}\n\t\t}\n\t\tTypeAssert.unreachable(type);\n\t}\n\tprivate _setBoolean(options: SetParamOptions): string {\n\t\tconst {controller, param, paramValue} = options;\n\t\tconst func = Poly.namedFunctionsRegister.getFunction('setParamBoolean', this, controller);\n\t\treturn func.asString(param, paramValue);\n\t}\n\tprivate _setColor(options: SetParamOptions): string {\n\t\tconst {controller, param, paramValue, lerp} = options;\n\t\tconst func = Poly.namedFunctionsRegister.getFunction('setParamColor', this, controller);\n\t\treturn func.asString(param, paramValue, lerp);\n\t}\n\tprivate _setFloat(options: SetParamOptions): string {\n\t\tconst {controller, param, paramValue, lerp} = options;\n\t\tconst func = Poly.namedFunctionsRegister.getFunction('setParamFloat', this, controller);\n\t\treturn func.asString(param, paramValue, lerp);\n\t}\n\tprivate _setInt(options: SetParamOptions): string {\n\t\tconst {controller, param, paramValue, lerp} = options;\n\t\tconst func = Poly.namedFunctionsRegister.getFunction('setParamInteger', this, controller);\n\t\treturn func.asString(param, paramValue, lerp);\n\t}\n\tprivate _setString(options: SetParamOptions): string {\n\t\tconst {controller, param, paramValue} = options;\n\t\tconst func = Poly.namedFunctionsRegister.getFunction('setParamString', this, controller);\n\t\treturn func.asString(param, paramValue);\n\t}\n\tprivate _setVector2(options: SetParamOptions): string {\n\t\tconst {controller, param, paramValue, lerp} = options;\n\t\tconst func = Poly.namedFunctionsRegister.getFunction('setParamVector2', this, controller);\n\t\treturn func.asString(param, paramValue, lerp);\n\t}\n\tprivate _setVector3(options: SetParamOptions): string {\n\t\tconst {controller, param, paramValue, lerp} = options;\n\t\tconst func = Poly.namedFunctionsRegister.getFunction('setParamVector3', this, controller);\n\t\treturn func.asString(param, paramValue, lerp);\n\t}\n\tprivate _setVector4(options: SetParamOptions): string {\n\t\tconst {controller, param, paramValue, lerp} = options;\n\t\tconst func = Poly.namedFunctionsRegister.getFunction('setParamVector4', this, controller);\n\t\treturn func.asString(param, paramValue, lerp);\n\t}\n}\n","import {TRIGGER_CONNECTION_NAME, TypedJsNode} from './_Base';\nimport {NodeParamsConfig, ParamConfig} from '../utils/params/ParamsConfig';\nimport {JsConnectionPoint, JsConnectionPointType, JS_CONNECTION_POINT_IN_NODE_DEF} from '../utils/io/connections/Js';\nimport {NodeContext} from '../../poly/NodeContext';\n\nconst CONNECTION_OPTIONS = JS_CONNECTION_POINT_IN_NODE_DEF;\n\nclass PauseAudioSourceJsParamsConfig extends NodeParamsConfig {\n\t/** @param audio node */\n\tnode = ParamConfig.NODE_PATH('', {\n\t\tnodeSelection: {\n\t\t\tcontext: NodeContext.AUDIO,\n\t\t},\n\t\t// dependentOnFoundNode: false,\n\t});\n}\nconst ParamsConfig = new PauseAudioSourceJsParamsConfig();\n\nexport abstract class BaseAudioSourceJsNode extends TypedJsNode<PauseAudioSourceJsParamsConfig> {\n\toverride readonly paramsConfig = ParamsConfig;\n\n\toverride initializeNode() {\n\t\tthis.io.inputs.setNamedInputConnectionPoints([\n\t\t\tnew JsConnectionPoint(TRIGGER_CONNECTION_NAME, JsConnectionPointType.TRIGGER, CONNECTION_OPTIONS),\n\t\t]);\n\t\tthis.io.outputs.setNamedOutputConnectionPoints([\n\t\t\tnew JsConnectionPoint(TRIGGER_CONNECTION_NAME, JsConnectionPointType.TRIGGER),\n\t\t]);\n\t}\n}\n","import {TRIGGER_CONNECTION_NAME, TypedJsNode} from './_Base';\nimport {NodeParamsConfig} from '../utils/params/ParamsConfig';\nimport {JsConnectionPoint, JsConnectionPointType, JS_CONNECTION_POINT_IN_NODE_DEF} from '../utils/io/connections/Js';\nimport {setObject3DOutputLine} from './_BaseObject3D';\nimport {JsLinesCollectionController} from './code/utils/JsLinesCollectionController';\nconst CONNECTION_OPTIONS = JS_CONNECTION_POINT_IN_NODE_DEF;\n\nexport abstract class BaseTriggerAndObjectJsNode<K extends NodeParamsConfig> extends TypedJsNode<K> {\n\toverride initializeNode() {\n\t\tthis.io.inputs.setNamedInputConnectionPoints([\n\t\t\tnew JsConnectionPoint(TRIGGER_CONNECTION_NAME, JsConnectionPointType.TRIGGER, CONNECTION_OPTIONS),\n\t\t\tnew JsConnectionPoint(JsConnectionPointType.OBJECT_3D, JsConnectionPointType.OBJECT_3D, CONNECTION_OPTIONS),\n\t\t\t...this._additionalInputs(),\n\t\t]);\n\n\t\tthis.io.outputs.setNamedOutputConnectionPoints([\n\t\t\tnew JsConnectionPoint(TRIGGER_CONNECTION_NAME, JsConnectionPointType.TRIGGER),\n\t\t\tnew JsConnectionPoint(JsConnectionPointType.OBJECT_3D, JsConnectionPointType.OBJECT_3D),\n\t\t\t...this._additionalOutputs(),\n\t\t]);\n\t}\n\n\toverride setLines(linesController: JsLinesCollectionController) {\n\t\tsetObject3DOutputLine(this, linesController);\n\t}\n\tprotected _additionalInputs(): JsConnectionPoint<JsConnectionPointType>[] {\n\t\treturn [];\n\t}\n\tprotected _additionalOutputs(): JsConnectionPoint<JsConnectionPointType>[] {\n\t\treturn [];\n\t}\n}\nclass BaseTriggerAndObjectJsParamsConfig extends NodeParamsConfig {}\nconst ParamsConfig = new BaseTriggerAndObjectJsParamsConfig();\nexport abstract class ParamlessBaseTriggerAndObjectJsNode extends BaseTriggerAndObjectJsNode<BaseTriggerAndObjectJsParamsConfig> {\n\toverride readonly paramsConfig = ParamsConfig;\n}\n","import {ShaderMaterial} from 'three';\nimport {LineType} from '../utils/LineType';\nimport {VariableConfig} from '../configs/VariableConfig';\nimport {JsCodeBuilder, CodeBuilderSetCodeLinesOptions} from '../utils/CodeBuilder';\nimport {BaseJsNodeType, TypedJsNode} from '../../_Base';\nimport {JsShaderConfig} from '../configs/ShaderConfig';\nimport {TypedAssembler} from '../../../utils/shaders/BaseAssembler';\nimport {JsFunctionName} from '../../../utils/shaders/ShaderName';\nimport {OutputJsNode} from '../../Output';\nimport {JsConnectionPoint, JsConnectionPointType} from '../../../utils/io/connections/Js';\nimport {GlobalsJsNode} from '../../Globals';\nimport {AttributeJsNode} from '../../Attribute';\nimport {AssemblerControllerNode} from '../Controller';\nimport {GlobalsJsBaseController} from '../globals/_Base';\nimport {JsLinesCollectionController} from '../utils/JsLinesCollectionController';\nimport {NodeContext} from '../../../../poly/NodeContext';\nimport {TypedNodeTraverser} from '../../../utils/shaders/NodeTraverser';\nimport {JsNodeFinder} from '../utils/NodeFinder';\nimport {JsType} from '../../../../poly/registers/nodes/types/Js';\nimport {BaseNamedFunction} from '../../../../functions/_Base';\nimport {RegisterableVariable} from './_BaseJsPersistedConfigUtils';\nimport {NamedFunctionMap} from '../../../../poly/registers/functions/All';\nimport {JsParamConfig} from '../utils/JsParamConfig';\nimport {ParamType} from '../../../../poly/ParamType';\nimport {ParamOptions} from '../../../../params/utils/OptionsController';\nimport {SopType} from '../../../../poly/registers/nodes/types/Sop';\n\ntype StringArrayByJsFunctionName = Map<JsFunctionName, string[]>;\nexport interface SpareParamOptions {\n\ttype: ParamType;\n}\n\nexport interface BaseFunctionData {\n\tvariableNames: string[];\n\tvariablesByName: Record<string, RegisterableVariable>;\n\tfunctionNames: Array<keyof NamedFunctionMap>;\n\tfunctionsByName: Record<string, Function>;\n\tparamConfigs: JsParamConfig<ParamType>[];\n}\n\nexport interface VelocityColliderFunctionBody {\n\tvelocity: string;\n\tcollider: string;\n}\nexport interface SingleBodyFunctionData extends BaseFunctionData {\n\tfunctionBody: string;\n}\nexport interface VelocityColliderFunctionData extends BaseFunctionData {\n\tfunctionBody: VelocityColliderFunctionBody;\n}\ninterface JsTemplateShader {\n\tmain?: string;\n\tvelocity?: string;\n\tcollider?: string;\n\t// uniforms?: IUniforms;\n}\nexport const INSERT_MEMBERS_AFTER = '// insert members';\nexport const INSERT_DEFINE_AFTER = '// insert defines';\nexport const INSERT_CONSTRUCTOR_AFTER = '// insert after constructor';\nexport const INSERT_BODY_AFTER = '// insert body';\n// export const INSERT_TRIGGER_AFTER = '// insert trigger';\n// export const INSERT_TRIGGERABLE_AFTER = '// insert triggerable';\n\nconst INSERT_MEMBER_AFTER_MAP: Map<JsFunctionName, string> = new Map([\n\t// [ShaderName.VERTEX, '#include <common>'],\n\t[JsFunctionName.MAIN, INSERT_MEMBERS_AFTER],\n\t[JsFunctionName.VELOCITY, INSERT_MEMBERS_AFTER],\n\t[JsFunctionName.COLLIDER, INSERT_MEMBERS_AFTER],\n]);\nconst INSERT_DEFINE_AFTER_MAP: Map<JsFunctionName, string> = new Map([\n\t// [ShaderName.VERTEX, '#include <common>'],\n\t[JsFunctionName.MAIN, INSERT_DEFINE_AFTER],\n\t[JsFunctionName.VELOCITY, INSERT_DEFINE_AFTER],\n\t[JsFunctionName.COLLIDER, INSERT_DEFINE_AFTER],\n]);\nconst INSERT_CONSTRUCTOR_AFTER_MAP: Map<JsFunctionName, string> = new Map([\n\t// [ShaderName.VERTEX, '#include <common>'],\n\t[JsFunctionName.MAIN, INSERT_CONSTRUCTOR_AFTER],\n\t[JsFunctionName.VELOCITY, INSERT_CONSTRUCTOR_AFTER],\n\t[JsFunctionName.COLLIDER, INSERT_CONSTRUCTOR_AFTER],\n]);\nconst INSERT_BODY_AFTER_MAP: Map<JsFunctionName, string> = new Map([\n\t// [ShaderName.VERTEX, '#include <color_vertex>'],\n\t[JsFunctionName.MAIN, INSERT_BODY_AFTER],\n\t[JsFunctionName.VELOCITY, INSERT_BODY_AFTER],\n\t[JsFunctionName.COLLIDER, INSERT_BODY_AFTER],\n]);\n// const INSERT_TRIGGER_AFTER_MAP: Map<ShaderName, string> = new Map([\n// \t// [ShaderName.VERTEX, '#include <color_vertex>'],\n// \t[ShaderName.FRAGMENT, INSERT_TRIGGER_AFTER],\n// ]);\n// const INSERT_TRIGGERABLE_AFTER_MAP: Map<ShaderName, string> = new Map([\n// \t// [ShaderName.VERTEX, '#include <color_vertex>'],\n// \t[ShaderName.FRAGMENT, INSERT_TRIGGERABLE_AFTER],\n// ]);\nconst LINES_TO_REMOVE_MAP: Map<JsFunctionName, string[]> = new Map([\n\t// [ShaderName.VERTEX, ['#include <begin_vertex>', '#include <beginnormal_vertex>']],\n\t[JsFunctionName.MAIN, []],\n\t[JsFunctionName.VELOCITY, []],\n\t[JsFunctionName.COLLIDER, []],\n]);\n\nconst SPACED_LINES = 3;\nconst PER_POINT_PARENT_TYPES: Set<string> = new Set([SopType.ACTOR_INSTANCE, SopType.ACTOR_POINT]);\nexport abstract class BaseJsShaderAssembler extends TypedAssembler<NodeContext.JS> {\n\tprotected _shaders_by_name: Map<JsFunctionName, string> = new Map();\n\tprotected _lines: StringArrayByJsFunctionName = new Map();\n\tprotected _codeBuilder: JsCodeBuilder | undefined;\n\tprivate _param_config_owner: JsCodeBuilder | undefined;\n\tprotected _root_nodes: BaseJsNodeType[] = [];\n\tprotected _leaf_nodes: BaseJsNodeType[] = [];\n\tprotected _material: ShaderMaterial | undefined;\n\n\tprivate _shader_configs: JsShaderConfig[] | undefined;\n\tprivate _variable_configs: VariableConfig[] | undefined;\n\n\tprivate _uniformsTimeDependent: boolean = false;\n\tprivate _uniformsResolutionDependent: boolean = false;\n\tprivate _computedVarNames: Set<string> = new Set();\n\n\tconstructor(protected _jsParentNode: AssemblerControllerNode<BaseJsShaderAssembler>) {\n\t\tsuper();\n\t}\n\n\tperPoint() {\n\t\treturn PER_POINT_PARENT_TYPES.has(this._jsParentNode.type());\n\t}\n\n\tprotected _overridenJsParentNode: AssemblerControllerNode<BaseJsShaderAssembler> | undefined;\n\tsetJsParentNode(parentNode: AssemblerControllerNode<BaseJsShaderAssembler>) {\n\t\tthis._overridenJsParentNode = parentNode;\n\t}\n\tcurrentJsParentNode() {\n\t\treturn this._overridenJsParentNode || this._jsParentNode;\n\t}\n\tabstract makeFunctionNodeDirtyOnChange(): boolean;\n\taddComputedVarName(varName: string) {\n\t\tif (!this.computedVariablesAllowed()) {\n\t\t\treturn;\n\t\t}\n\t\tthis._computedVarNames.add(varName);\n\t}\n\tregisteredAsComputed(varName: string): boolean {\n\t\tif (varName.trim().length == 0) {\n\t\t\tconsole.warn(`attempt to read an empty variable ('${varName}')`);\n\t\t}\n\t\treturn this._computedVarNames.has(varName);\n\t}\n\tcomputedVariablesAllowed(): boolean {\n\t\treturn false;\n\t}\n\tmemberReference(varName: string): string {\n\t\tif (this.computedVariablesAllowed()) {\n\t\t\treturn `this.${varName}.value`;\n\t\t} else {\n\t\t\treturn `this.${varName}`;\n\t\t}\n\t}\n\n\tabstract spareParamsOptions(options: SpareParamOptions): ParamOptions;\n\n\tcompile() {}\n\n\tabstract defaultObjectVariable(): string;\n\tabstract defaultObject3DMaterialVariable(): string;\n\tabstract defaultPrimitiveGraph(): string;\n\t// abstract defaultEntityIndexVariable(): string;\n\n\t// private get material() {\n\t// \treturn (this._material = this._material || this._createMaterial());\n\t// }\n\t// async get_material(/*master_assembler?: BaseGlShaderAssembler*/) {\n\t// \tthis._material = this._material || this._createMaterial();\n\n\t// \tawait this._update_material(/*master_assembler*/);\n\t// \treturn this._material;\n\t// }\n\tprotected _template_shader_for_shader_name(shaderName: JsFunctionName): string | undefined {\n\t\tswitch (shaderName) {\n\t\t\tcase JsFunctionName.MAIN:\n\t\t\t\treturn this.templateShader()?.main;\n\t\t\tcase JsFunctionName.VELOCITY:\n\t\t\t\treturn this.templateShader()?.velocity;\n\t\t\tcase JsFunctionName.COLLIDER:\n\t\t\t\treturn this.templateShader()?.collider;\n\t\t}\n\t}\n\n\tglobalsHandler(): GlobalsJsBaseController | undefined {\n\t\treturn this.currentJsParentNode().assemblerController()?.globalsHandler();\n\t}\n\tcompileAllowed(): boolean {\n\t\treturn this.currentJsParentNode().assemblerController()?.globalsHandler() != null;\n\t}\n\tshaders_by_name() {\n\t\treturn this._shaders_by_name;\n\t}\n\n\t// protected createMaterial(): ShaderMaterial | undefined {\n\t// \treturn undefined;\n\t// }\n\tprotected _buildLines() {\n\t\tfor (const shaderName of this.shaderNames()) {\n\t\t\tconst template = this._template_shader_for_shader_name(shaderName);\n\t\t\tif (template) {\n\t\t\t\tthis._replaceTemplate(template, shaderName);\n\t\t\t}\n\t\t}\n\t}\n\n\t// protected _build_lines_for_shader_name(shader_name: ShaderName){\n\t// \tconst template = this._template_shader()\n\t// \tthis._replace_template(template[`${shader_name}Shader`], shader_name)\n\t// }\n\n\tset_root_nodes(root_nodes: BaseJsNodeType[]) {\n\t\tthis._root_nodes = root_nodes;\n\t}\n\tprotected templateShader(): JsTemplateShader | undefined {\n\t\treturn undefined;\n\t}\n\tprotected _reset() {\n\t\tthis._resetRegisteredFunctions();\n\t\tthis._resetRegisteredVariables();\n\t\tthis._computedVarNames.clear();\n\t}\n\n\tupdateFunction() {\n\t\tthis._reset();\n\t}\n\n\t// protected addUniforms(uniforms: IUniforms) {\n\n\t// \tfor (let param_config of this.param_configs()) {\n\t// \t\tuniforms[param_config.uniformName()] = param_config.uniform();\n\t// \t}\n\n\t// \tif (this.uniformsTimeDependent()) {\n\t// \t\tuniforms[UniformName.TIME] = uniforms[UniformName.TIME] || {\n\t// \t\t\t// type: '1f',\n\t// \t\t\tvalue: this.currentGlParentNode().scene().time(),\n\t// \t\t};\n\t// \t}\n\t// \tif (this.uniformsResolutionDependent()) {\n\t// \t\tuniforms[UniformName.RESOLUTION] = uniforms[UniformName.RESOLUTION] || {\n\t// \t\t\tvalue: new Vector2(1000, 1000),\n\t// \t\t};\n\t// \t}\n\t// }\n\n\t//\n\t//\n\t// ROOT NODES AND SHADER NAMES\n\t//\n\t//\n\trootNodesByShaderName(shaderName: JsFunctionName, rootNodes: BaseJsNodeType[]): BaseJsNodeType[] {\n\t\t// return this._root_nodes\n\t\tconst list = [];\n\t\tfor (const node of rootNodes) {\n\t\t\tswitch (node.type()) {\n\t\t\t\t// case VaryingWriteGlNode.type():\n\t\t\t\t// case ParamGlNode.type():\n\t\t\t\tcase JsType.PARAM:\n\t\t\t\t// case SubnetOutputGlNode.type():\n\t\t\t\tcase JsType.OUTPUT: {\n\t\t\t\t\tlist.push(node);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcase JsType.OUTPUT_AMBIENT_LIGHT:\n\t\t\t\tcase JsType.OUTPUT_AREA_LIGHT:\n\t\t\t\tcase JsType.OUTPUT_DIRECTIONAL_LIGHT:\n\t\t\t\tcase JsType.OUTPUT_HEMISPHERE_LIGHT:\n\t\t\t\tcase JsType.OUTPUT_POINT_LIGHT:\n\t\t\t\tcase JsType.OUTPUT_SPOT_LIGHT: {\n\t\t\t\t\tlist.push(node);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t// case SubnetOutputGlNode.type(): {\n\t\t\t\t// \tlist.push(node);\n\t\t\t\t// \tbreak;\n\t\t\t\t// }\n\t\t\t\t// case ParamGlNode.type(): {\n\t\t\t\t// \tlist.push(node);\n\t\t\t\t// \tbreak;\n\t\t\t\t// }\n\t\t\t\tcase JsType.ATTRIBUTE: {\n\t\t\t\t\tlist.push(node);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t// case VaryingWriteGlNode.type(): {\n\t\t\t\t// \tlist.push(node);\n\t\t\t\t// \tbreak;\n\t\t\t\t// }\n\t\t\t}\n\t\t}\n\t\treturn list;\n\t}\n\t// leafNodesByShaderName(shaderName: ShaderName): BaseGlNodeType[] {\n\t// \tconst list = [];\n\t// \tfor (let node of this._leaf_nodes) {\n\t// \t\tswitch (node.type()) {\n\t// \t\t\tcase GlobalsGlNode.type(): {\n\t// \t\t\t\tlist.push(node);\n\t// \t\t\t\tbreak;\n\t// \t\t\t}\n\t// \t\t\tcase AttributeGlNode.type(): {\n\t// \t\t\t\tbreak;\n\t// \t\t\t}\n\t// \t\t}\n\t// \t}\n\t// \treturn list;\n\t// }\n\tsetNodeLinesGlobals(globalsNode: GlobalsJsNode, linesController: JsLinesCollectionController) {}\n\tsetNodeLinesOutput(outputNode: OutputJsNode, linesController: JsLinesCollectionController) {}\n\tsetNodeLinesAttribute(attributeNode: AttributeJsNode, linesController: JsLinesCollectionController) {}\n\n\t//\n\t//\n\t// CHILDREN NODES PARAMS\n\t//\n\t//\n\tcodeBuilder() {\n\t\treturn (this._codeBuilder = this._codeBuilder || this._createCodeBuilder());\n\t}\n\n\tprivate _createCodeBuilder() {\n\t\tconst computedVariablesAllowed = this._jsParentNode\n\t\t\t.assemblerController()\n\t\t\t?.assembler?.computedVariablesAllowed();\n\n\t\tconst nodeTraverser = new TypedNodeTraverser<NodeContext.JS>(\n\t\t\tthis.currentJsParentNode(),\n\t\t\tthis.shaderNames(),\n\t\t\t(rootNode, shaderName) => {\n\t\t\t\treturn this.inputNamesForShaderName(rootNode, shaderName);\n\t\t\t},\n\t\t\t{\n\t\t\t\t// we do traverse children if computed(()=>{}) is used.\n\t\t\t\t// If not, we don't need to traverse children,\n\t\t\t\t// and the code is handled by the subnet internal code builder\n\t\t\t\ttraverseChildren: computedVariablesAllowed == true ? true : false,\n\t\t\t}\n\t\t);\n\t\treturn new JsCodeBuilder(\n\t\t\tnodeTraverser,\n\t\t\t(shaderName, rootNodes) => {\n\t\t\t\treturn this.rootNodesByShaderName(shaderName, rootNodes);\n\t\t\t},\n\t\t\tthis\n\t\t);\n\t}\n\tprotected buildCodeFromNodes(rootNodes: BaseJsNodeType[], codeBuilderOptions?: CodeBuilderSetCodeLinesOptions) {\n\t\tconst paramNodes = JsNodeFinder.findParamGeneratingNodes(this.currentJsParentNode());\n\t\tthis.codeBuilder().buildFromNodes(rootNodes, paramNodes, codeBuilderOptions);\n\t}\n\tallow_new_param_configs() {\n\t\tthis.codeBuilder().allow_new_param_configs();\n\t}\n\tdisallow_new_param_configs() {\n\t\tthis.codeBuilder().disallow_new_param_configs();\n\t}\n\tbuilder_param_configs() {\n\t\treturn this.codeBuilder().param_configs();\n\t}\n\tbuilder_lines(shader_name: JsFunctionName, line_type: LineType) {\n\t\treturn this.codeBuilder().lines(shader_name, line_type);\n\t}\n\tall_builder_lines() {\n\t\treturn this.codeBuilder().all_lines();\n\t}\n\tparam_configs() {\n\t\tconst code_builder = this._param_config_owner || this.codeBuilder();\n\t\treturn code_builder.param_configs();\n\t}\n\tset_param_configs_owner(param_config_owner: JsCodeBuilder) {\n\t\tthis._param_config_owner = param_config_owner;\n\t\tif (this._param_config_owner) {\n\t\t\tthis.codeBuilder().disallow_new_param_configs();\n\t\t} else {\n\t\t\tthis.codeBuilder().allow_new_param_configs();\n\t\t}\n\t}\n\n\t//\n\t//\n\t// CHILDREN NODES PARAMS\n\t//\n\t//\n\tstatic output_input_connection_points(): JsConnectionPoint<JsConnectionPointType>[] {\n\t\treturn [\n\t\t\t// new JsConnectionPoint('position', JsConnectionPointType.VEC3),\n\t\t\t// new JsConnectionPoint('normal', JsConnectionPointType.VEC3),\n\t\t\t// new JsConnectionPoint('color', JsConnectionPointType.VEC3),\n\t\t\t// new JsConnectionPoint('alpha', JsConnectionPointType.FLOAT),\n\t\t\t// new JsConnectionPoint('uv', JsConnectionPointType.VEC2),\n\t\t];\n\t}\n\tadd_output_inputs(output_child: OutputJsNode) {\n\t\toutput_child.io.inputs.setNamedInputConnectionPoints(BaseJsShaderAssembler.output_input_connection_points());\n\t}\n\tstatic create_globals_node_output_connections() {\n\t\t// TODO: move this in material only, to use the enum GlobalsOutput\n\t\treturn [\n\t\t\t// new JsConnectionPoint('position', JsConnectionPointType.VEC3),\n\t\t\t// new JsConnectionPoint('normal', JsConnectionPointType.VEC3),\n\t\t\t// new JsConnectionPoint('color', JsConnectionPointType.VEC3),\n\t\t\t// new JsConnectionPoint('uv', JsConnectionPointType.VEC2),\n\t\t\t// new JsConnectionPoint(GlobalsOutput.MV_POSITION, JsConnectionPointType.VEC4),\n\t\t\t// // Maybe I should not add worldPosition, worldNormal, I just now\n\t\t\t// // as those could add computation overhead when always present in the shader.\n\t\t\t// // But hopefully in the soon future, they will only be added when the code builder\n\t\t\t// // adds lines based on connections, as opposed to the whole node\n\t\t\t// new JsConnectionPoint('worldPosition', JsConnectionPointType.VEC4), // vec4 worldPosition = modelMatrix * vec4( position, 1.0 );\n\t\t\t// new JsConnectionPoint('worldNormal', JsConnectionPointType.VEC3), // vec3 worldNormal = normalize( mat3( modelMatrix[0].xyz, modelMatrix[1].xyz, modelMatrix[2].xyz ) * normal );\n\t\t\t// // new GlConnectionPoint('I', GlConnectionPointType.VEC3), // vec3 I = worldPosition.xyz - cameraPosition;\n\t\t\t// new JsConnectionPoint(GlobalsOutput.GL_POSITION, JsConnectionPointType.VEC4),\n\t\t\t// new JsConnectionPoint(GlobalsOutput.GL_FRAGCOORD, JsConnectionPointType.VEC4),\n\t\t\t// new JsConnectionPoint('cameraPosition', JsConnectionPointType.VEC3),\n\t\t\t// new JsConnectionPoint(GlobalsOutput.RESOLUTION, JsConnectionPointType.VEC2),\n\t\t\t// new JsConnectionPoint(GlobalsOutput.TIME, JsConnectionPointType.FLOAT),\n\t\t];\n\t}\n\tcreate_globals_node_output_connections() {\n\t\treturn BaseJsShaderAssembler.create_globals_node_output_connections();\n\t}\n\tadd_globals_outputs(globals_node: GlobalsJsNode) {\n\t\tglobals_node.io.outputs.setNamedOutputConnectionPoints(this.create_globals_node_output_connections());\n\t}\n\tallow_attribute_exports() {\n\t\treturn false;\n\t}\n\n\t//\n\t//\n\t// CONFIGS\n\t//\n\t//\n\tresetConfigs() {\n\t\tthis._reset_shader_configs();\n\t\tthis._reset_variable_configs();\n\t\tthis._resetUniformsTimeDependency();\n\t\tthis._resetUniformsResolutionDependency();\n\t}\n\tshaderConfigs() {\n\t\treturn (this._shader_configs = this._shader_configs || this.create_shader_configs());\n\t}\n\tset_shader_configs(shader_configs: JsShaderConfig[]) {\n\t\tthis._shader_configs = shader_configs;\n\t}\n\tshaderNames(): JsFunctionName[] {\n\t\treturn this.shaderConfigs()?.map((sc) => sc.name()) || [];\n\t}\n\tprotected _reset_shader_configs() {\n\t\tthis._shader_configs = undefined;\n\t}\n\tcreate_shader_configs(): JsShaderConfig[] {\n\t\treturn [\n\t\t\t// new ShaderConfig(ShaderName.VERTEX, ['position', 'normal', 'uv', VaryingWriteGlNode.INPUT_NAME], []),\n\t\t\tnew JsShaderConfig(JsFunctionName.MAIN, ['color', 'alpha'], []),\n\t\t];\n\t}\n\tshader_config(name: string): JsShaderConfig | undefined {\n\t\treturn this.shaderConfigs()?.filter((sc) => {\n\t\t\treturn sc.name() == name;\n\t\t})[0];\n\t}\n\tvariable_configs() {\n\t\treturn (this._variable_configs = this._variable_configs || this.create_variable_configs());\n\t}\n\tset_variable_configs(variable_configs: VariableConfig[]) {\n\t\tthis._variable_configs = variable_configs;\n\t}\n\tvariable_config(name: string) {\n\t\treturn this.variable_configs().filter((vc) => {\n\t\t\treturn vc.name() == name;\n\t\t})[0];\n\t}\n\tstatic create_variable_configs() {\n\t\treturn [\n\t\t\tnew VariableConfig('d', {\n\t\t\t\t// default_from_attribute: true,\n\t\t\t\t// default: this.globalsHandler().variable_config_default('position'),\n\t\t\t\t// required_definitions: this.globalsHandler().variable_config_required_definitions('position'),\n\t\t\t\tprefix: 'return ',\n\t\t\t}),\n\t\t\t// new VariableConfig('normal', {\n\t\t\t// \tdefault_from_attribute: true,\n\t\t\t// \tprefix: 'vec3 objectNormal = ',\n\t\t\t// \tpostLines: ['#ifdef USE_TANGENT', '\tvec3 objectTangent = vec3( tangent.xyz );', '#endif'],\n\t\t\t// }),\n\t\t\t// new VariableConfig('color', {\n\t\t\t// \tprefix: 'diffuseColor.xyz = ',\n\t\t\t// }),\n\t\t\t// new VariableConfig('alpha', {\n\t\t\t// \tprefix: 'diffuseColor.a = ',\n\t\t\t// }),\n\t\t\t// new VariableConfig('uv', {\n\t\t\t// \t// default_from_attribute: true,\n\t\t\t// \tprefix: 'vUv = ',\n\t\t\t// \t// if: GlobalsGeometryHandler.IF_RULE.uv,\n\t\t\t// }),\n\t\t];\n\t}\n\tcreate_variable_configs(): VariableConfig[] {\n\t\treturn BaseJsShaderAssembler.create_variable_configs();\n\t}\n\tprotected _reset_variable_configs() {\n\t\tthis._variable_configs = undefined;\n\t\tthis.variable_configs();\n\t}\n\tinputNamesForShaderName(rootNode: BaseJsNodeType, shaderName: JsFunctionName) {\n\t\t// for simplicity,\n\t\t// and to make it work with objectBuilder,\n\t\t// without having to specify each output node's input names (especially for the light outputs)\n\t\t// we just return all the input names\n\t\t// if we are in JsFunctionName.MAIN\n\t\tif (shaderName == JsFunctionName.MAIN) {\n\t\t\treturn (rootNode.io.inputs.namedInputConnectionPoints() || []).map((c) => c.name()); //this.shader_config(shader_name)?.input_names() || [];\n\t\t} else {\n\t\t\treturn this.shader_config(shaderName)?.input_names() || [];\n\t\t}\n\t}\n\n\t// time dependency\n\tprotected _resetUniformsTimeDependency() {\n\t\tthis._uniformsTimeDependent = false;\n\t}\n\tsetUniformsTimeDependent() {\n\t\tthis._uniformsTimeDependent = true;\n\t}\n\tuniformsTimeDependent(): boolean {\n\t\treturn this._uniformsTimeDependent;\n\t}\n\t// resolution dependency\n\tprotected _resetUniformsResolutionDependency() {\n\t\tthis._uniformsResolutionDependent = false;\n\t}\n\tsetUniformsResolutionDependent() {\n\t\tthis._uniformsResolutionDependent = true;\n\t}\n\tuniformsResolutionDependent(): boolean {\n\t\treturn this._uniformsResolutionDependent;\n\t}\n\tprotected _raymarchingLightsWorldCoordsDependent() {\n\t\treturn false;\n\t}\n\t//\n\t//\n\t// TEMPLATE HOOKS\n\t//\n\t//\n\tprotected insertMemberAfter(shaderName: JsFunctionName): string | undefined {\n\t\treturn INSERT_MEMBER_AFTER_MAP.get(shaderName);\n\t}\n\tprotected insertDefineAfter(shaderName: JsFunctionName): string | undefined {\n\t\treturn INSERT_DEFINE_AFTER_MAP.get(shaderName);\n\t}\n\tprotected insertConstructorAfter(shaderName: JsFunctionName): string | undefined {\n\t\treturn INSERT_CONSTRUCTOR_AFTER_MAP.get(shaderName);\n\t}\n\tprotected insertBodyAfter(shaderName: JsFunctionName): string | undefined {\n\t\treturn INSERT_BODY_AFTER_MAP.get(shaderName);\n\t}\n\t// protected insertTriggerAfter(shaderName: ShaderName): string | undefined {\n\t// \treturn INSERT_TRIGGER_AFTER_MAP.get(shaderName);\n\t// }\n\t// protected insertTriggerableAfter(shaderName: ShaderName): string | undefined {\n\t// \treturn INSERT_TRIGGERABLE_AFTER_MAP.get(shaderName);\n\t// }\n\tprotected linesToRemove(shaderName: JsFunctionName): string[] | undefined {\n\t\treturn LINES_TO_REMOVE_MAP.get(shaderName);\n\t}\n\n\t//\n\t//\n\t// TEMPLATE CODE REPLACEMENT\n\t//\n\t//\n\n\tprivate _replaceTemplate(template: string, shaderName: JsFunctionName) {\n\t\tconst memberLines = this.builder_lines(shaderName, LineType.MEMBER);\n\t\tconst constructorLines = this.builder_lines(shaderName, LineType.CONSTRUCTOR);\n\t\t// const triggerLines = this.builder_lines(shaderName, LineType.TRIGGER);\n\t\t// const triggerableLines = this.builder_lines(shaderName, LineType.TRIGGERABLE);\n\t\tconst defineLines = this.builder_lines(shaderName, LineType.DEFINE);\n\t\t// const define = this.builder_lines(shaderName, LineType.DEFINE);\n\t\t// let all_define = function_declaration.concat(define);\n\t\tconst body = this.builder_lines(shaderName, LineType.BODY);\n\n\t\tlet templateLines = template.split('\\n');\n\t\t// const scene = this.currentGlParentNode().scene;\n\t\tconst newLines: string[] = [\n\t\t\t// `#define FPS ${ThreeToGl.float(scene.time_controller.fps)}`,\n\t\t\t// `#define TIME_INCREMENT (1.0/${ThreeToGl.float(scene.time_controller.fps)})`,\n\t\t\t// `#define FRAME_RANGE_START ${ThreeToGl.float(scene.time_controller.frame_range[0])}`,\n\t\t\t// `#define FRAME_RANGE_END ${ThreeToGl.float(scene.time_controller.frame_range[1])}`,\n\t\t];\n\n\t\tconst lineBeforeMember = this.insertMemberAfter(shaderName);\n\t\tconst lineBeforeDefine = this.insertDefineAfter(shaderName);\n\t\tconst lineBeforeConstructor = this.insertConstructorAfter(shaderName);\n\t\tconst lineBeforeBody = this.insertBodyAfter(shaderName);\n\t\t// const lineBeforeTrigger = this.insertTriggerAfter(shaderName);\n\t\t// const lineBeforeTriggerable = this.insertTriggerableAfter(shaderName);\n\t\tconst linesToRemove = this.linesToRemove(shaderName);\n\t\tlet lineBeforeMemberFound = false;\n\t\tlet lineBeforeDefineFound = false;\n\t\tlet lineBeforeConstructorFound = false;\n\t\t// let lineBeforeTriggerFound = false;\n\t\t// let lineBeforeTriggerableFound = false;\n\t\tlet lineBeforeBodyFoundOnPreviousLine = false;\n\t\tlet lineBeforeBodyFound = false;\n\n\t\tfor (const templateLine of templateLines) {\n\t\t\tif (lineBeforeMemberFound == true) {\n\t\t\t\tif (memberLines) {\n\t\t\t\t\tthis._insertLines(newLines, memberLines);\n\t\t\t\t}\n\t\t\t\tlineBeforeMemberFound = false;\n\t\t\t}\n\t\t\tif (lineBeforeDefineFound == true) {\n\t\t\t\tif (defineLines) {\n\t\t\t\t\tthis._insertLines(newLines, defineLines);\n\t\t\t\t}\n\t\t\t\tlineBeforeDefineFound = false;\n\t\t\t}\n\t\t\tif (lineBeforeConstructorFound == true) {\n\t\t\t\tif (constructorLines) {\n\t\t\t\t\tthis._insertLines(newLines, constructorLines);\n\t\t\t\t}\n\t\t\t\tlineBeforeConstructorFound = false;\n\t\t\t}\n\t\t\t// if (lineBeforeTriggerFound == true) {\n\t\t\t// \tif (triggerLines) {\n\t\t\t// \t\tthis._insertLines(newLines, triggerLines);\n\t\t\t// \t}\n\t\t\t// \tlineBeforeTriggerFound = false;\n\t\t\t// }\n\t\t\t// if (lineBeforeTriggerableFound == true) {\n\t\t\t// \tif (triggerableLines) {\n\t\t\t// \t\tthis._insertLines(newLines, triggerableLines);\n\t\t\t// \t}\n\t\t\t// \tlineBeforeTriggerableFound = false;\n\t\t\t// }\n\t\t\tif (lineBeforeBodyFoundOnPreviousLine == true) {\n\t\t\t\t// this._insert_default_body_declarations(new_lines, shaderName)\n\t\t\t\tif (body) {\n\t\t\t\t\tthis._insertLines(newLines, body);\n\t\t\t\t}\n\t\t\t\tlineBeforeBodyFoundOnPreviousLine = false;\n\t\t\t}\n\n\t\t\tlet line_remove_required = false;\n\n\t\t\tif (linesToRemove) {\n\t\t\t\tfor (const line_to_remove of linesToRemove) {\n\t\t\t\t\tif (templateLine.indexOf(line_to_remove) >= 0) {\n\t\t\t\t\t\tline_remove_required = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!line_remove_required) {\n\t\t\t\tnewLines.push(templateLine);\n\t\t\t} else {\n\t\t\t\tnewLines.push('// removed:');\n\t\t\t\tnewLines.push(`//${templateLine}`);\n\t\t\t}\n\n\t\t\tif (lineBeforeDefine && templateLine.indexOf(lineBeforeDefine) >= 0) {\n\t\t\t\tlineBeforeDefineFound = true;\n\t\t\t}\n\t\t\tif (lineBeforeConstructor && templateLine.indexOf(lineBeforeConstructor) >= 0) {\n\t\t\t\tlineBeforeConstructorFound = true;\n\t\t\t}\n\t\t\t// if (lineBeforeTrigger && templateLine.indexOf(lineBeforeTrigger) >= 0) {\n\t\t\t// \tlineBeforeTriggerFound = true;\n\t\t\t// }\n\t\t\t// if (lineBeforeTriggerable && templateLine.indexOf(lineBeforeTriggerable) >= 0) {\n\t\t\t// \tlineBeforeTriggerableFound = true;\n\t\t\t// }\n\t\t\tif (lineBeforeMember && templateLine.indexOf(lineBeforeMember) >= 0) {\n\t\t\t\tlineBeforeMemberFound = true;\n\t\t\t}\n\t\t\tif (lineBeforeBody && templateLine.indexOf(lineBeforeBody) >= 0) {\n\t\t\t\tlineBeforeBodyFoundOnPreviousLine = true;\n\t\t\t\tlineBeforeBodyFound = true;\n\t\t\t}\n\n\t\t\t// if(template_line.indexOf('// INSERT DEFINE') >= 0){\n\t\t\t// } else {\n\t\t\t// \tif(template_line.indexOf('// INSERT BODY') >= 0){\n\t\t\t// \t\tif(body.length > 0){\n\t\t\t// \t\t\tlodash_times(3, ()=>new_lines.push('\t'))\n\t\t\t// \t\t\tbody.forEach(body_line=>{\n\t\t\t// \t\t\t\tnew_lines.push(body_line)\n\t\t\t// \t\t\t})\n\t\t\t// \t\t\tlodash_times(3, ()=>new_lines.push('\t'))\n\t\t\t// \t\t}\n\t\t\t// \t} else {\n\t\t\t// \t\tif(template_line.indexOf('// TO REMOVE') < 0){\n\t\t\t// \t\t\tnew_lines.push(template_line)\n\t\t\t// \t\t}\n\t\t\t// \t}\n\t\t\t// }\n\t\t}\n\t\tif (lineBeforeBody) {\n\t\t\tif (!lineBeforeBodyFound) {\n\t\t\t\tconsole.warn(`line '${lineBeforeBody}' was not found in shader '${shaderName}'`, template, this);\n\t\t\t} else {\n\t\t\t\t// console.log(`OK: line '${line_before_body}' was found in shader '${shader_name}'`, template, this);\n\t\t\t}\n\t\t}\n\n\t\tthis._lines.set(shaderName, newLines);\n\t}\n\n\tprivate _insertLines(newLines: string[], linesToAdd: string[]) {\n\t\tif (linesToAdd.length == 0) {\n\t\t\treturn;\n\t\t}\n\t\tfor (let i = 0; i < SPACED_LINES; i++) {\n\t\t\tnewLines.push('');\n\t\t}\n\t\tfor (const lineToAdd of linesToAdd) {\n\t\t\tnewLines.push(lineToAdd);\n\t\t}\n\t\tfor (let i = 0; i < SPACED_LINES; i++) {\n\t\t\tnewLines.push('');\n\t\t}\n\t}\n\n\t//\n\t//\n\t// REGISTERED VARIABLES\n\t//\n\t//\n\tprivate _registeredVariables: Map<string, RegisterableVariable> = new Map();\n\tprivate _registeredVariablesCountByNode: Map<BaseJsNodeType, number> = new Map();\n\taddVariable(node: BaseJsNodeType, variable: RegisterableVariable, varName?: string): string {\n\t\t// const nodeSanitizedPath = CoreString.sanitizeName(node.path());\n\t\t// const varFullName = `${nodeSanitizedPath}_${varName}`;\n\t\tconst count = this._registeredVariablesCountByNode.get(node) || 0;\n\t\tthis._registeredVariablesCountByNode.set(node, count + 1);\n\t\tconst varFullName = varName ? varName : 'VAR_' + TypedJsNode.inputVarName(node, count == 0 ? '' : `_${count}`);\n\t\tthis._registeredVariables.set(varFullName, variable);\n\t\treturn varFullName;\n\t}\n\ttraverseRegisteredVariables(callback: (variable: RegisterableVariable, varName: string) => void) {\n\t\tthis._registeredVariables.forEach(callback);\n\t}\n\tprotected _resetRegisteredVariables() {\n\t\tthis._registeredVariables.clear();\n\t\tthis._registeredVariablesCountByNode.clear();\n\t}\n\t//\n\t//\n\t// REGISTERED FUNCTIONS\n\t//\n\t//\n\tprivate _registeredFunctions: Map<string, BaseNamedFunction> = new Map();\n\taddFunction(node: BaseJsNodeType, namedFunction: BaseNamedFunction) {\n\t\tconst existingFunctionName = this._registeredFunctions.get(namedFunction.type());\n\t\tif (existingFunctionName) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis._registeredFunctions.set(namedFunction.type(), namedFunction);\n\n\t\t// let i=0\n\t\t// for(let _func of functions){\n\t\t// \tconst functionName= this._nameByFunctions.get(_func)\n\t\t// \tif(!functionName){\n\n\t\t// \t}\n\t\t// }\n\n\t\t// const functionDefinitions = functions.map((f,i)=>{\n\t\t// \tconst functionName=`${node.name()})_${i}`\n\t\t// \treturn new FunctionJsDefinition(node, functionName, f)\n\t\t// })\n\t\t// this.addDefinitions(node, functionDefinitions);\n\t}\n\ttraverseRegisteredFunctions(callback: (variable: BaseNamedFunction) => void) {\n\t\tthis._registeredFunctions.forEach(callback);\n\t}\n\tprotected _resetRegisteredFunctions() {\n\t\tthis._registeredFunctions.clear();\n\t\t// this._nameByFunctions.clear();\n\t}\n}\n","import {BasePersistedConfig} from '../../../../utils/BasePersistedConfig';\nimport {SingleBodyFunctionData} from '../_Base';\nimport {SerializedVariable, SerializedVariableType} from '../_BaseJsPersistedConfigUtils';\nimport {NamedFunctionMap} from '../../../../../poly/registers/functions/All';\nimport {JsParamConfig, JsParamConfigJSON} from '../../utils/JsParamConfig';\nimport {ParamType} from '../../../../../poly/ParamType';\nimport {EvaluatorEventData} from './ActorEvaluator';\nimport {ActorBuilderNode} from '../../../../../scene/utils/ActorsManager';\nimport {\n\tPersistedConfigBaseJsData,\n\tserializedVariablesFromFunctionData,\n\tvariablesByNameFromPersistedConfigData,\n\tfunctionsByNameFromPersistedConfigData,\n} from '../_BaseJsPersistedConfig';\nexport interface ActorFunctionData extends SingleBodyFunctionData {\n\teventDatas: EvaluatorEventData[];\n}\n\nexport interface ActorPersistedConfigBaseJsData extends PersistedConfigBaseJsData {\n\tfunctionBody: string;\n\tvariableNames: string[];\n\tvariables: SerializedVariable<SerializedVariableType>[];\n\tfunctionNames: Array<keyof NamedFunctionMap>;\n\tserializedParamConfigs: JsParamConfigJSON<ParamType>[];\n\teventDatas: EvaluatorEventData[];\n}\n\nexport class ActorPersistedConfig extends BasePersistedConfig {\n\tconstructor(protected override node: ActorBuilderNode) {\n\t\tsuper(node);\n\t}\n\toverride async toData(): Promise<ActorPersistedConfigBaseJsData | undefined> {\n\t\t// we need to compute the node here it case it hasn't yet,\n\t\t// otherwise the .functionData() will be empty\n\t\tawait this.node.compilationController.compileIfRequired();\n\t\t//\n\t\tconst assemblerController = this.node.assemblerController();\n\t\tif (!assemblerController) {\n\t\t\treturn;\n\t\t}\n\t\tconst functionData = this.node.compilationController.functionData();\n\t\tif (!functionData) {\n\t\t\treturn;\n\t\t}\n\t\tconst {functionBody, variableNames, functionNames, paramConfigs, eventDatas} = functionData;\n\n\t\tconst data: ActorPersistedConfigBaseJsData = {\n\t\t\tfunctionBody,\n\t\t\tvariableNames,\n\t\t\tvariables: serializedVariablesFromFunctionData(functionData),\n\t\t\tfunctionNames,\n\t\t\tserializedParamConfigs: paramConfigs.map((p) => p.toJSON()),\n\t\t\teventDatas,\n\t\t};\n\t\treturn data;\n\t}\n\toverride load(data: ActorPersistedConfigBaseJsData) {\n\t\tconst assemblerController = this.node.assemblerController();\n\t\tif (assemblerController) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst {functionBody, variableNames, functionNames, serializedParamConfigs, eventDatas} = data;\n\n\t\tconst functionData: ActorFunctionData = {\n\t\t\tfunctionBody: functionBody,\n\t\t\tvariableNames,\n\t\t\tvariablesByName: variablesByNameFromPersistedConfigData(data),\n\t\t\tfunctionNames,\n\t\t\tfunctionsByName: functionsByNameFromPersistedConfigData(data, this.node),\n\t\t\tparamConfigs: serializedParamConfigs.map((json) => JsParamConfig.fromJSON(json)),\n\t\t\teventDatas,\n\t\t};\n\t\tthis.node.compilationController.updateFromFunctionData(functionData);\n\t}\n}\n","import type {Vector3} from 'three';\nimport type {ObjectContent, CoreObjectType} from '../../../../../../core/geometry/ObjectContent';\nimport type {PrimitiveGraph} from '../../../../../../core/geometry/entities/primitive/PrimitiveGraph';\n\nexport enum EntityBuilderAssemblerConstant {\n\tOBJECT = 'entityContainer.object',\n\tENTITY_CONTAINER = 'entityContainer',\n\tPOSITION = 'entityContainer.position',\n\tNORMAL = 'entityContainer.normal',\n\tINDEX = 'entityContainer.index',\n\tOBJNUM = 'entityContainer.objnum',\n\tNORMALS_UPDATED = 'entityContainer.normalsUpdated',\n\tPRIMITIVE_GRAPH = 'entityContainer.primitiveGraph',\n\tATTRIBUTES_DICT = 'attributesDict',\n\tMATERIAL = 'null', // not available in this assembler\n}\nexport interface EntityContainer {\n\tobject: ObjectContent<CoreObjectType>;\n\tposition: Vector3;\n\tnormal: Vector3;\n\tindex: number;\n\tobjnum: number;\n\tnormalsUpdated: boolean;\n\tprimitiveGraph?: PrimitiveGraph;\n}\n\nexport enum EntityVariable {\n\tPOSITION = 'position',\n\tNORMAL = 'normal',\n\tINDEX = 'index',\n\tOBJNUM = 'objnum',\n}\n","import {Vector3, Quaternion} from 'three';\n\nexport enum InstanceBuilderAssemblerConstant {\n\tPOINT_CONTAINER = 'pointContainer',\n\tINSTANCE_POSITION = 'pointContainer.instancePosition',\n\tINSTANCE_QUATERNION = 'pointContainer.instanceQuaternion',\n\tINSTANCE_SCALE = 'pointContainer.instanceScale',\n\t// UV = 'pointContainer.instanceUv',\n\tPTNUM = 'pointContainer.ptnum',\n\tOBJNUM = 'pointContainer.objnum',\n\tATTRIBUTES_DICT = 'attributesDict',\n\tOBJECT_3D = 'null', // not available in this assembler\n\tMATERIAL = 'null', // not available in this assembler\n}\nexport interface InstanceContainer {\n\tinstancePosition: Vector3;\n\tinstanceQuaternion: Quaternion;\n\tinstanceScale: Vector3;\n\t// instanceUv: Vector2;\n\tptnum: number;\n\tobjnum: number;\n}\n\nexport enum InstanceVariable {\n\tINSTANCE_POSITION = 'instancePosition',\n\tINSTANCE_QUATERNION = 'instanceQuaternion',\n\tINSTANCE_SCALE = 'instanceScale',\n\t// INSTANCE_UV = 'instanceUv',\n\tPTNUM = 'ptnum',\n\tOBJNUM = 'objnum',\n}\n","import type {Object3D} from 'three';\n\nexport enum ObjectBuilderAssemblerConstant {\n\tOBJECT_CONTAINER = 'objectContainer',\n\tOBJECT_3D = 'objectContainer.Object3D',\n\tOBJ_NUM = 'objectContainer.objnum',\n\tMATERIAL = 'objectContainer.Object3D.material',\n\tPTNUM = 'null', // not available in this assembler\n\tPRIMITIVE_GRAPH = 'null',\n}\n\nexport interface ObjectContainer {\n\tObject3D: Object3D;\n\tobjnum: number;\n}\n\nexport enum ObjectVariable {\n\tOBJECT_3D = 'Object3D',\n\tPOSITION = 'position',\n\tROTATION = 'rotation',\n\tQUATERNION = 'quaternion',\n\tSCALE = 'scale',\n\tMATRIX = 'matrix',\n\tVISIBLE = 'visible',\n\tMATRIX_AUTO_UPDATE = 'matrixAutoUpdate',\n\tCAST_SHADOW = 'castShadow',\n\tRECEIVE_SHADOW = 'receiveShadow',\n\tFRUSTUM_CULLED = 'frustumCulled',\n\tOBJ_NUM = 'objnum',\n}\n","import type {Vector3} from 'three';\n\nexport enum PointBuilderAssemblerConstant {\n\tPOINT_CONTAINER = 'pointContainer',\n\tPOSITION = 'pointContainer.position',\n\tNORMAL = 'pointContainer.normal',\n\tPTNUM = 'pointContainer.ptnum',\n\tOBJNUM = 'pointContainer.objnum',\n\tNORMALS_UPDATED = 'pointContainer.normalsUpdated',\n\tATTRIBUTES_DICT = 'attributesDict',\n\tOBJECT_3D = 'null', // not available in this assembler\n\tMATERIAL = 'null', // not available in this assembler\n\tPRIMITIVE_GRAPH='null'\n}\nexport interface PointContainer {\n\tposition: Vector3;\n\tnormal: Vector3;\n\tptnum: number;\n\tobjnum: number;\n\tnormalsUpdated: boolean;\n}\n\nexport enum PointVariable {\n\tPOSITION = 'position',\n\tNORMAL = 'normal',\n\tPTNUM = 'ptnum',\n\tOBJNUM = 'objnum',\n}\n","import {\n\tBaseJsShaderAssembler,\n\tINSERT_DEFINE_AFTER,\n\tINSERT_BODY_AFTER,\n\tINSERT_MEMBERS_AFTER,\n\tINSERT_CONSTRUCTOR_AFTER,\n\tVelocityColliderFunctionData,\n\tSpareParamOptions,\n} from '../_Base';\nimport {RegisterableVariable} from '../_BaseJsPersistedConfigUtils';\nimport {ThreeToGl} from '../../../../../../core/ThreeToGl';\nimport {JsShaderConfig} from '../../configs/ShaderConfig';\nimport {VariableConfig} from '../../configs/VariableConfig';\nimport {JsFunctionName} from '../../../../utils/shaders/ShaderName';\nimport {OutputJsNode} from '../../../Output';\nimport {GlobalsJsNode} from '../../../Globals';\nimport {JsConnectionPointType, JsConnectionPoint} from '../../../../utils/io/connections/Js';\nimport {JsLinesCollectionController} from '../../utils/JsLinesCollectionController';\nimport {Vector3} from 'three';\nimport {NamedFunctionMap} from '../../../../../poly/registers/functions/All';\nimport {ParamOptions} from '../../../../../params/utils/OptionsController';\nimport {PrettierController} from '../../../../../../core/code/PrettierController';\n\nexport enum SoftBodyVariable {\n\tP = 'position',\n\tV = 'velocity',\n\tCOLLISION_SDF = 'collisionSDF',\n\t//\n\tTIME = 'time',\n\tDELTA = 'delta',\n}\n\nconst TEMPLATE_VELOCITY = `\n${INSERT_DEFINE_AFTER}\n${INSERT_MEMBERS_AFTER}\n${INSERT_CONSTRUCTOR_AFTER}\nconst SoftBodyVelocity = function(){\n\t${INSERT_BODY_AFTER}\n`;\nconst CLOSE_CLASS_DEFINITION_VELOCITY = `};\nreturn SoftBodyVelocity;`;\n\nconst TEMPLATE_COLLIDER = `\n${INSERT_DEFINE_AFTER}\n${INSERT_MEMBERS_AFTER}\n${INSERT_CONSTRUCTOR_AFTER}\nconst SoftBodyCollider = function(){\n\t${INSERT_BODY_AFTER}\n`;\nconst CLOSE_CLASS_DEFINITION_COLLIDER = `};\nreturn SoftBodyCollider;`;\n\nexport class JsAssemblerSoftBody extends BaseJsShaderAssembler {\n\tmakeFunctionNodeDirtyOnChange() {\n\t\treturn true;\n\t}\n\tdefaultObjectVariable(): string {\n\t\treturn 'null';\n\t}\n\tdefaultObject3DMaterialVariable(): string {\n\t\treturn 'null';\n\t}\n\tdefaultPrimitiveGraph(): string {\n\t\treturn 'null';\n\t}\n\n\toverride templateShader() {\n\t\treturn {\n\t\t\tvelocity: TEMPLATE_VELOCITY,\n\t\t\tcollider: TEMPLATE_COLLIDER,\n\t\t};\n\t}\n\n\toverride spareParamsOptions(options: SpareParamOptions) {\n\t\tconst _options: ParamOptions = {\n\t\t\tspare: true,\n\t\t\t// computeOnDirty: true, // not needed if cook option is not set\n\t\t\tcook: false, // for Softbody, the node must not recook\n\t\t\t// important for texture nodes\n\t\t\t// that compute after being found by the nodepath param\n\t\t\tdependentOnFoundNode: true,\n\t\t};\n\t\treturn _options;\n\t}\n\n\tfunctionData(): VelocityColliderFunctionData | undefined {\n\t\tconst _buildFunctionBody = (functionName: JsFunctionName, closeDef: string) => {\n\t\t\tconst bodyLines = this._shaders_by_name.get(functionName) || TEMPLATE_VELOCITY;\n\t\t\tconst functionBodyElements = [\n\t\t\t\tbodyLines,\n\t\t\t\t// triggerableFunctionLines.join('\\n'),\n\t\t\t\t// triggerFunctionLines.join('\\n'),\n\t\t\t\tcloseDef,\n\t\t\t];\n\t\t\tconst functionBody = PrettierController.formatJs(functionBodyElements.join('\\n'));\n\t\t\treturn functionBody;\n\t\t};\n\n\t\tconst functionBodyVelocity = _buildFunctionBody(JsFunctionName.VELOCITY, CLOSE_CLASS_DEFINITION_VELOCITY);\n\t\tconst functionBodyCollider = _buildFunctionBody(JsFunctionName.COLLIDER, CLOSE_CLASS_DEFINITION_COLLIDER);\n\t\tif (!(functionBodyVelocity && functionBodyCollider)) {\n\t\t\treturn;\n\t\t}\n\t\tconst variableNames: string[] = [];\n\t\tconst functionNames: Array<keyof NamedFunctionMap> = [];\n\t\tconst variablesByName: Record<string, RegisterableVariable> = {};\n\t\tconst functionsByName: Record<string, Function> = {};\n\t\tthis.traverseRegisteredVariables((variable, varName) => {\n\t\t\tvariableNames.push(varName);\n\t\t\tvariablesByName[varName] = variable;\n\t\t});\n\t\tthis.traverseRegisteredFunctions((namedFunction) => {\n\t\t\tfunctionNames.push(namedFunction.type() as keyof NamedFunctionMap);\n\t\t\tfunctionsByName[namedFunction.type()] = namedFunction.func.bind(namedFunction);\n\t\t});\n\t\tconst paramConfigs = this.param_configs();\n\t\treturn {\n\t\t\tfunctionBody: {\n\t\t\t\tvelocity: functionBodyVelocity,\n\t\t\t\tcollider: functionBodyCollider,\n\t\t\t},\n\t\t\tvariableNames,\n\t\t\tvariablesByName,\n\t\t\tfunctionNames,\n\t\t\tfunctionsByName,\n\t\t\tparamConfigs: [...paramConfigs],\n\t\t};\n\t}\n\n\toverride updateFunction() {\n\t\tsuper.updateFunction();\n\t\tthis._lines = new Map();\n\t\tthis._shaders_by_name = new Map();\n\t\tconst shaderNames = this.shaderNames();\n\n\t\tif (this._root_nodes.length > 0) {\n\t\t\tthis.buildCodeFromNodes(this._root_nodes);\n\t\t\tthis._buildLines();\n\t\t}\n\n\t\tfor (const shaderName of shaderNames) {\n\t\t\tconst lines = this._lines.get(shaderName);\n\t\t\tif (lines) {\n\t\t\t\tthis._shaders_by_name.set(shaderName, lines.join('\\n'));\n\t\t\t}\n\t\t}\n\t}\n\n\t//\n\t//\n\t// CHILDREN NODES PARAMS\n\t//\n\t//\n\toverride add_output_inputs(output_child: OutputJsNode) {\n\t\toutput_child.io.inputs.setNamedInputConnectionPoints([\n\t\t\tnew JsConnectionPoint(SoftBodyVariable.V, JsConnectionPointType.VECTOR3),\n\t\t\tnew JsConnectionPoint(SoftBodyVariable.COLLISION_SDF, JsConnectionPointType.FLOAT),\n\t\t]);\n\t}\n\toverride add_globals_outputs(globals_node: GlobalsJsNode) {\n\t\tglobals_node.io.outputs.setNamedOutputConnectionPoints([\n\t\t\tnew JsConnectionPoint(SoftBodyVariable.P, JsConnectionPointType.VECTOR3),\n\t\t\tnew JsConnectionPoint(SoftBodyVariable.V, JsConnectionPointType.VECTOR3),\n\t\t\tnew JsConnectionPoint(SoftBodyVariable.TIME, JsConnectionPointType.FLOAT),\n\t\t\tnew JsConnectionPoint(SoftBodyVariable.DELTA, JsConnectionPointType.FLOAT),\n\t\t]);\n\t}\n\n\t//\n\t//\n\t// CONFIGS\n\t//\n\t//\n\toverride create_shader_configs() {\n\t\treturn [\n\t\t\tnew JsShaderConfig(JsFunctionName.VELOCITY, [SoftBodyVariable.V], []),\n\t\t\tnew JsShaderConfig(JsFunctionName.COLLIDER, [SoftBodyVariable.COLLISION_SDF], []),\n\t\t];\n\t}\n\toverride create_variable_configs() {\n\t\treturn [\n\t\t\tnew VariableConfig(SoftBodyVariable.V, {\n\t\t\t\tprefix: 'return ',\n\t\t\t}),\n\t\t\tnew VariableConfig(SoftBodyVariable.COLLISION_SDF, {\n\t\t\t\tprefix: 'return ',\n\t\t\t}),\n\t\t];\n\t}\n\n\toverride setNodeLinesOutput(outputNode: OutputJsNode, linesController: JsLinesCollectionController) {\n\t\tconst inputNames = this.inputNamesForShaderName(\n\t\t\toutputNode,\n\t\t\tlinesController.currentShaderName()\n\t\t) as SoftBodyVariable[];\n\t\tif (inputNames) {\n\t\t\tfor (const inputName of inputNames) {\n\t\t\t\tconst input = outputNode.io.inputs.named_input(inputName);\n\t\t\t\tconst glVar = outputNode.variableForInput(linesController, inputName);\n\t\t\t\tswitch (inputName) {\n\t\t\t\t\tcase SoftBodyVariable.V: {\n\t\t\t\t\t\tconst _defaultVar = () => {\n\t\t\t\t\t\t\tconst tmpVarName = linesController.addVariable(outputNode, new Vector3(0, 0.1, 0));\n\t\t\t\t\t\t\treturn `return ${tmpVarName}`;\n\t\t\t\t\t\t};\n\t\t\t\t\t\tconst bodyLine = input ? `return ${ThreeToGl.any(glVar)}` : _defaultVar();\n\t\t\t\t\t\tlinesController._addBodyLines(outputNode, [bodyLine]);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tcase SoftBodyVariable.COLLISION_SDF: {\n\t\t\t\t\t\tconst bodyLine = input ? `return ${ThreeToGl.any(glVar)}` : `return 100`;\n\t\t\t\t\t\tlinesController._addBodyLines(outputNode, [bodyLine]);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\toverride setNodeLinesGlobals(globalsNode: GlobalsJsNode, shadersCollectionController: JsLinesCollectionController) {\n\t\tconst shaderName = shadersCollectionController.currentShaderName();\n\t\tconst shaderConfig = this.shader_config(shaderName);\n\t\tif (!shaderConfig) {\n\t\t\treturn;\n\t\t}\n\t\tconst bodyLines: string[] = [];\n\n\t\tconst usedOutputNames = globalsNode.io.outputs.used_output_names();\n\t\tfor (const outputName of usedOutputNames) {\n\t\t\tconst varName = globalsNode.jsVarName(outputName);\n\n\t\t\tswitch (outputName) {\n\t\t\t\tcase 'position': {\n\t\t\t\t\tshadersCollectionController.addVariable(globalsNode, new Vector3(), varName);\n\t\t\t\t\tbodyLines.push(`${varName}.copy(${outputName})`);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcase SoftBodyVariable.V: {\n\t\t\t\t\tshadersCollectionController.addVariable(globalsNode, new Vector3(), varName);\n\t\t\t\t\tbodyLines.push(`${varName}.copy(${outputName})`);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcase SoftBodyVariable.TIME: {\n\t\t\t\t\tbodyLines.push(`const ${varName} = ${SoftBodyVariable.TIME}`);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcase SoftBodyVariable.DELTA: {\n\t\t\t\t\tbodyLines.push(`const ${varName} = ${SoftBodyVariable.DELTA}`);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tshadersCollectionController._addBodyLines(globalsNode, bodyLines);\n\t}\n}\n","import {JsFunctionName} from '../../../utils/shaders/ShaderName';\n\nexport class JsShaderConfig {\n\tconstructor(private _name: JsFunctionName, private _input_names: string[], private _dependencies: JsFunctionName[]) {}\n\n\tname() {\n\t\treturn this._name;\n\t}\n\tinput_names() {\n\t\treturn this._input_names;\n\t}\n\tdependencies() {\n\t\treturn this._dependencies;\n\t}\n}\n","interface VariableConfigOptions {\n\t// asset refererences\n\tdefault_from_attribute?: boolean;\n\tdefault?: string;\n\tif?: string;\n\tprefix?: string;\n\tsuffix?: string;\n\tpostLines?: string[];\n}\n\nexport class VariableConfig {\n\tconstructor(private _name: string, private _options: VariableConfigOptions = {}) {}\n\n\tname() {\n\t\treturn this._name;\n\t}\n\tdefault_from_attribute() {\n\t\treturn this._options['default_from_attribute'] || false;\n\t}\n\tdefault() {\n\t\treturn this._options['default'];\n\t}\n\tif_condition() {\n\t\treturn this._options['if'];\n\t}\n\t// required_definitions(){\n\t// \treturn this._options['required_definitions']\n\t// }\n\tprefix() {\n\t\treturn this._options['prefix'] || '';\n\t}\n\tsuffix() {\n\t\treturn this._options['suffix'] || '';\n\t}\n\tpostLines() {\n\t\treturn this._options.postLines;\n\t}\n}\n","/**\n * Creates a Mesh Physical Material, which can be extended with GL nodes.\n *\n * @remarks\n * This node can create children, which will be GL nodes. The GLSL code generated by the nodes will extend the Material.\n *\n * Note that when overriding some properties like metalness and roughness from the output node, the values will be mutliplied with the material top level parameters. You may therefore want to set those to 1 to have predictable results.\n *\n */\nimport {NodeParamsConfig} from '../utils/params/ParamsConfig';\nimport {\n\tUniformsTransparencyParamConfig,\n\tUniformsTransparencyController,\n\tUniformsTransparencyControllers,\n} from './utils/UniformsTransparencyController';\nimport {\n\tAdvancedCommonController,\n\tAdvancedCommonControllers,\n\tAdvancedCommonParamConfig,\n} from './utils/AdvancedCommonController';\nimport {MapParamConfig, TextureMapController, TextureMapControllers} from './utils/TextureMapController';\nimport {\n\tAlphaMapParamConfig,\n\tTextureAlphaMapController,\n\tTextureAlphaMapControllers,\n} from './utils/TextureAlphaMapController';\nimport {\n\tTextureBumpMapController,\n\tBumpMapParamConfig,\n\tTextureBumpMapControllers,\n} from './utils/TextureBumpMapController';\nimport {\n\tTextureEmissiveMapController,\n\tEmissiveMapParamConfig,\n\tTextureEmissiveMapControllers,\n} from './utils/TextureEmissiveMapController';\nimport {TextureEnvMapController, EnvMapParamConfig, TextureEnvMapControllers} from './utils/TextureEnvMapController';\nimport {TextureAOMapController, AOMapParamConfig, TextureAOMapControllers} from './utils/TextureAOMapController';\nimport {\n\tTextureNormalMapController,\n\tNormalMapParamConfig,\n\tTextureNormalMapControllers,\n} from './utils/TextureNormalMapController';\nimport {\n\tTextureMetalnessRoughnessMapController,\n\tMetalnessRoughnessMapParamConfig,\n\tTextureMetalnessRoughnessMapControllers,\n} from './utils/TextureMetalnessRoughnessMapController';\nimport {\n\tTextureLightMapController,\n\tLightMapParamConfig,\n\tTextureLightMapControllers,\n} from './utils/TextureLightMapController';\nimport {MeshPhysicalController, MeshPhysicalControllers, MeshPhysicalParamConfig} from './utils/MeshPhysicalController';\nimport {\n\tTextureDisplacementMapController,\n\tDisplacementMapParamConfig,\n\tTextureDisplacementMapControllers,\n} from './utils/TextureDisplacementMapController';\nimport {BaseBuilderParamConfig, TypedBuilderMatNode} from './_BaseBuilder';\nimport {ShaderAssemblerPhysical} from '../gl/code/assemblers/materials/Physical';\nimport {AssemblerName} from '../../poly/registers/assemblers/_BaseRegister';\nimport {Poly} from '../../Poly';\nimport {FogParamConfig, UniformFogController, UniformFogControllers} from './utils/UniformsFogController';\nimport {\n\tWireframeShaderMaterialController,\n\tWireframeShaderMaterialControllers,\n\tWireframeShaderMaterialParamsConfig,\n} from './utils/WireframeShaderMaterialController';\nimport {DefaultFolderParamConfig} from './utils/DefaultFolder';\nimport {TexturesFolderParamConfig} from './utils/TexturesFolder';\nimport {AdvancedFolderParamConfig} from './utils/AdvancedFolder';\nimport {PCSSController, PCSSControllers, PCSSParamConfig} from './utils/PCSSController';\nimport {Constructor} from '../../../types/GlobalTypes';\nimport {Material} from 'three';\nimport {MeshPhysicalMaterial} from 'three';\nimport {CustomMaterialName, IUniforms} from '../../../core/geometry/Material';\nimport {\n\tCustomMaterialMeshParamConfig,\n\tmaterialMeshAssemblerCustomMaterialRequested,\n} from './utils/customMaterials/CustomMaterialMesh';\nimport {MatType} from '../../poly/registers/nodes/types/Mat';\n\ninterface MeshPhysicalBuilderMaterial extends MeshPhysicalMaterial {\n\tvertexShader: string;\n\tfragmentShader: string;\n\tuniforms: IUniforms;\n\tcustomMaterials: {\n\t\t[key in CustomMaterialName]?: Material;\n\t};\n}\ninterface MeshPhysicalBuilderControllers\n\textends AdvancedCommonControllers,\n\t\tPCSSControllers,\n\t\tTextureAlphaMapControllers,\n\t\tTextureAOMapControllers,\n\t\tTextureBumpMapControllers,\n\t\tTextureDisplacementMapControllers,\n\t\tTextureEmissiveMapControllers,\n\t\tTextureEnvMapControllers,\n\t\tTextureLightMapControllers,\n\t\tTextureMapControllers,\n\t\tTextureMetalnessRoughnessMapControllers,\n\t\tTextureNormalMapControllers,\n\t\tMeshPhysicalControllers,\n\t\tUniformFogControllers,\n\t\tUniformsTransparencyControllers,\n\t\tWireframeShaderMaterialControllers {}\n\nfunction AdvancedMeshPhysicalParamConfig<TBase extends Constructor>(Base: TBase) {\n\treturn class Mixin extends PCSSParamConfig(\n\t\tFogParamConfig(WireframeShaderMaterialParamsConfig(AdvancedCommonParamConfig(BaseBuilderParamConfig(Base))))\n\t) {};\n}\nclass MeshPhysicalBuilderMatParamsConfig extends CustomMaterialMeshParamConfig(\n\tAdvancedMeshPhysicalParamConfig(\n\t\t/* advanced */\n\t\tAdvancedFolderParamConfig(\n\t\t\tMeshPhysicalParamConfig(\n\t\t\t\tMetalnessRoughnessMapParamConfig(\n\t\t\t\t\tNormalMapParamConfig(\n\t\t\t\t\t\tLightMapParamConfig(\n\t\t\t\t\t\t\tEnvMapParamConfig(\n\t\t\t\t\t\t\t\tEmissiveMapParamConfig(\n\t\t\t\t\t\t\t\t\tDisplacementMapParamConfig(\n\t\t\t\t\t\t\t\t\t\tBumpMapParamConfig(\n\t\t\t\t\t\t\t\t\t\t\tAOMapParamConfig(\n\t\t\t\t\t\t\t\t\t\t\t\tAlphaMapParamConfig(\n\t\t\t\t\t\t\t\t\t\t\t\t\tMapParamConfig(\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t/* textures */\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tTexturesFolderParamConfig(\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tUniformsTransparencyParamConfig(\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tDefaultFolderParamConfig(NodeParamsConfig)\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t)\n\t\t\t\t\t\t)\n\t\t\t\t\t)\n\t\t\t\t)\n\t\t\t)\n\t\t)\n\t)\n) {}\nconst ParamsConfig = new MeshPhysicalBuilderMatParamsConfig();\n\nexport class MeshPhysicalBuilderMatNode extends TypedBuilderMatNode<\n\tMeshPhysicalBuilderMaterial,\n\tShaderAssemblerPhysical,\n\tMeshPhysicalBuilderMatParamsConfig\n> {\n\toverride paramsConfig = ParamsConfig;\n\tstatic override type() {\n\t\treturn MatType.MESH_PHYSICAL_BUILDER;\n\t}\n\tpublic override usedAssembler(): Readonly<AssemblerName.GL_MESH_PHYSICAL> {\n\t\treturn AssemblerName.GL_MESH_PHYSICAL;\n\t}\n\tprotected _createAssemblerController() {\n\t\treturn Poly.assemblersRegister.assembler(this, this.usedAssembler());\n\t}\n\tpublic override customMaterialRequested(customName: CustomMaterialName): boolean {\n\t\treturn materialMeshAssemblerCustomMaterialRequested(this, customName);\n\t}\n\treadonly controllers: MeshPhysicalBuilderControllers = {\n\t\tadvancedCommon: new AdvancedCommonController(this),\n\t\talphaMap: new TextureAlphaMapController(this),\n\t\taoMap: new TextureAOMapController(this),\n\t\tbumpMap: new TextureBumpMapController(this),\n\t\tdisplacementMap: new TextureDisplacementMapController(this),\n\t\temissiveMap: new TextureEmissiveMapController(this),\n\t\tenvMap: new TextureEnvMapController(this),\n\t\tuniformFog: new UniformFogController(this),\n\t\tlightMap: new TextureLightMapController(this),\n\t\tmap: new TextureMapController(this),\n\t\tmetalnessRoughnessMap: new TextureMetalnessRoughnessMapController(this),\n\t\tnormalMap: new TextureNormalMapController(this),\n\t\tphysical: new MeshPhysicalController(this),\n\t\tPCSS: new PCSSController(this),\n\t\tuniformTransparency: new UniformsTransparencyController(this),\n\t\twireframeShader: new WireframeShaderMaterialController(this),\n\t};\n\tprotected override controllersList = Object.values(this.controllers);\n\n\toverride createMaterial() {\n\t\tconst material = super.createMaterial();\n\t\t(material as any).isMeshStandardMaterial = true;\n\t\t(material as any).isMeshPhysicalMaterial = true;\n\t\treturn material;\n\t}\n\n\toverride async cook() {\n\t\tthis._material = this._material || this.createMaterial();\n\t\tawait Promise.all(this.controllersPromises(this._material));\n\n\t\tthis.compileIfRequired(this._material);\n\n\t\tthis.setMaterial(this._material);\n\t}\n}\n","/**\n * Creates a Mesh Standard Material, which can be extended with GL nodes.\n *\n * @remarks\n * This node can create children, which will be GL nodes. The GLSL code generated by the nodes will extend the Material.\n *\n * Note that when overriding some properties like metalness and roughness from the output node, the values will be mutliplied with the material top level parameters. You may therefore want to set those to 1 to have predictable results.\n *\n */\nimport {NodeParamsConfig} from '../utils/params/ParamsConfig';\nimport {\n\tUniformsTransparencyParamConfig,\n\tUniformsTransparencyController,\n\tUniformsTransparencyControllers,\n} from './utils/UniformsTransparencyController';\nimport {\n\tAdvancedCommonController,\n\tAdvancedCommonControllers,\n\tAdvancedCommonParamConfig,\n} from './utils/AdvancedCommonController';\nimport {MapParamConfig, TextureMapController, TextureMapControllers} from './utils/TextureMapController';\nimport {\n\tAlphaMapParamConfig,\n\tTextureAlphaMapController,\n\tTextureAlphaMapControllers,\n} from './utils/TextureAlphaMapController';\nimport {\n\tTextureBumpMapController,\n\tBumpMapParamConfig,\n\tTextureBumpMapControllers,\n} from './utils/TextureBumpMapController';\nimport {\n\tTextureEmissiveMapController,\n\tEmissiveMapParamConfig,\n\tTextureEmissiveMapControllers,\n} from './utils/TextureEmissiveMapController';\nimport {TextureEnvMapController, EnvMapParamConfig, TextureEnvMapControllers} from './utils/TextureEnvMapController';\nimport {TextureAOMapController, AOMapParamConfig, TextureAOMapControllers} from './utils/TextureAOMapController';\nimport {\n\tTextureNormalMapController,\n\tNormalMapParamConfig,\n\tTextureNormalMapControllers,\n} from './utils/TextureNormalMapController';\nimport {\n\tTextureMetalnessRoughnessMapController,\n\tMetalnessRoughnessMapParamConfig,\n\tTextureMetalnessRoughnessMapControllers,\n} from './utils/TextureMetalnessRoughnessMapController';\nimport {\n\tTextureLightMapController,\n\tLightMapParamConfig,\n\tTextureLightMapControllers,\n} from './utils/TextureLightMapController';\nimport {\n\tTextureDisplacementMapController,\n\tDisplacementMapParamConfig,\n\tTextureDisplacementMapControllers,\n} from './utils/TextureDisplacementMapController';\nimport {BaseBuilderParamConfig, TypedBuilderMatNode} from './_BaseBuilder';\nimport {ShaderAssemblerStandard} from '../gl/code/assemblers/materials/Standard';\nimport {AssemblerName} from '../../poly/registers/assemblers/_BaseRegister';\nimport {Poly} from '../../Poly';\nimport {FogParamConfig, UniformFogController, UniformFogControllers} from './utils/UniformsFogController';\nimport {\n\tWireframeShaderMaterialController,\n\tWireframeShaderMaterialControllers,\n\tWireframeShaderMaterialParamsConfig,\n} from './utils/WireframeShaderMaterialController';\nimport {DefaultFolderParamConfig} from './utils/DefaultFolder';\nimport {TexturesFolderParamConfig} from './utils/TexturesFolder';\nimport {AdvancedFolderParamConfig} from './utils/AdvancedFolder';\nimport {PCSSController, PCSSControllers, PCSSParamConfig} from './utils/PCSSController';\nimport {Material} from 'three';\nimport {MeshStandardMaterial} from 'three';\nimport {CustomMaterialName, IUniforms} from '../../../core/geometry/Material';\nimport {\n\tCustomMaterialMeshParamConfig,\n\tmaterialMeshAssemblerCustomMaterialRequested,\n} from './utils/customMaterials/CustomMaterialMesh';\nimport {MatType} from '../../poly/registers/nodes/types/Mat';\ninterface MeshStandardBuilderControllers\n\textends AdvancedCommonControllers,\n\t\tPCSSControllers,\n\t\tTextureAlphaMapControllers,\n\t\tTextureAOMapControllers,\n\t\tTextureBumpMapControllers,\n\t\tTextureDisplacementMapControllers,\n\t\tTextureEmissiveMapControllers,\n\t\tTextureEnvMapControllers,\n\t\tTextureLightMapControllers,\n\t\tTextureMapControllers,\n\t\tTextureMetalnessRoughnessMapControllers,\n\t\tTextureNormalMapControllers,\n\t\tUniformFogControllers,\n\t\tUniformsTransparencyControllers,\n\t\tWireframeShaderMaterialControllers {}\ninterface MeshStandardBuilderMaterial extends MeshStandardMaterial {\n\tvertexShader: string;\n\tfragmentShader: string;\n\tuniforms: IUniforms;\n\tcustomMaterials: {\n\t\t[key in CustomMaterialName]?: Material;\n\t};\n}\nclass MeshStandardBuilderMatParamsConfig extends CustomMaterialMeshParamConfig(\n\tPCSSParamConfig(\n\t\tFogParamConfig(\n\t\t\tWireframeShaderMaterialParamsConfig(\n\t\t\t\tAdvancedCommonParamConfig(\n\t\t\t\t\tBaseBuilderParamConfig(\n\t\t\t\t\t\t/* advanced */\n\t\t\t\t\t\tAdvancedFolderParamConfig(\n\t\t\t\t\t\t\tMetalnessRoughnessMapParamConfig(\n\t\t\t\t\t\t\t\tNormalMapParamConfig(\n\t\t\t\t\t\t\t\t\tLightMapParamConfig(\n\t\t\t\t\t\t\t\t\t\tEnvMapParamConfig(\n\t\t\t\t\t\t\t\t\t\t\tEmissiveMapParamConfig(\n\t\t\t\t\t\t\t\t\t\t\t\tDisplacementMapParamConfig(\n\t\t\t\t\t\t\t\t\t\t\t\t\tBumpMapParamConfig(\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tAOMapParamConfig(\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tAlphaMapParamConfig(\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tMapParamConfig(\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t/* textures */\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tTexturesFolderParamConfig(\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tUniformsTransparencyParamConfig(\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tDefaultFolderParamConfig(NodeParamsConfig)\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t)\n\t\t\t\t\t\t)\n\t\t\t\t\t)\n\t\t\t\t)\n\t\t\t)\n\t\t)\n\t)\n) {}\nconst ParamsConfig = new MeshStandardBuilderMatParamsConfig();\n\nexport class MeshStandardBuilderMatNode extends TypedBuilderMatNode<\n\tMeshStandardBuilderMaterial,\n\tShaderAssemblerStandard,\n\tMeshStandardBuilderMatParamsConfig\n> {\n\toverride paramsConfig = ParamsConfig;\n\tstatic override type() {\n\t\treturn MatType.MESH_STANDARD_BUILDER;\n\t}\n\tpublic override usedAssembler(): Readonly<AssemblerName.GL_MESH_STANDARD> {\n\t\treturn AssemblerName.GL_MESH_STANDARD;\n\t}\n\tprotected _createAssemblerController() {\n\t\treturn Poly.assemblersRegister.assembler(this, this.usedAssembler());\n\t}\n\tpublic override customMaterialRequested(customName: CustomMaterialName): boolean {\n\t\treturn materialMeshAssemblerCustomMaterialRequested(this, customName);\n\t}\n\treadonly controllers: MeshStandardBuilderControllers = {\n\t\tadvancedCommon: new AdvancedCommonController(this),\n\t\talphaMap: new TextureAlphaMapController(this),\n\t\taoMap: new TextureAOMapController(this),\n\t\tbumpMap: new TextureBumpMapController(this),\n\t\tdisplacementMap: new TextureDisplacementMapController(this),\n\t\temissiveMap: new TextureEmissiveMapController(this),\n\t\tenvMap: new TextureEnvMapController(this),\n\t\tlightMap: new TextureLightMapController(this),\n\t\tmap: new TextureMapController(this),\n\t\tmetalnessRoughnessMap: new TextureMetalnessRoughnessMapController(this),\n\t\tnormalMap: new TextureNormalMapController(this),\n\t\tPCSS: new PCSSController(this),\n\t\tuniformFog: new UniformFogController(this),\n\t\tuniformTransparency: new UniformsTransparencyController(this),\n\t\twireframeShader: new WireframeShaderMaterialController(this),\n\t};\n\tprotected override controllersList = Object.values(this.controllers);\n\n\toverride async cook() {\n\t\tthis._material = this._material || this.createMaterial();\n\t\tawait Promise.all(this.controllersPromises(this._material));\n\n\t\tthis.compileIfRequired(this._material);\n\n\t\tthis.setMaterial(this._material);\n\t}\n}\n","/**\n * A subnet to create POST PROCESS nodes\n *\n */\nimport {Constructor, valueof} from '../../../types/GlobalTypes';\nimport {BaseNetworkMatNode} from './_BaseManager';\nimport {NetworkNodeType, NodeContext} from '../../poly/NodeContext';\nimport {PostNodeChildrenMap} from '../../poly/registers/nodes/Post';\nimport {BasePostProcessNodeType} from '../post/_Base';\nimport {DisplayNodeController} from '../utils/DisplayNodeController';\nimport {EffectComposerController, PostProcessNetworkParamsConfig} from '../post/utils/EffectComposerController';\nimport {NodeCreateOptions} from '../utils/hierarchy/ChildrenController';\n\nexport class PostProcessNetworkMatNode extends BaseNetworkMatNode<PostProcessNetworkParamsConfig> {\n\toverride paramsConfig = new PostProcessNetworkParamsConfig();\n\tstatic override type() {\n\t\treturn NetworkNodeType.POST;\n\t}\n\treadonly effectsComposerController: EffectComposerController = new EffectComposerController(this);\n\tpublic override readonly displayNodeController: DisplayNodeController = new DisplayNodeController(\n\t\tthis,\n\t\tthis.effectsComposerController.displayNodeControllerCallbacks()\n\t);\n\n\tprotected override _childrenControllerContext = NodeContext.POST;\n\n\toverride createNode<S extends keyof PostNodeChildrenMap>(\n\t\tnode_class: S,\n\t\toptions?: NodeCreateOptions\n\t): PostNodeChildrenMap[S];\n\toverride createNode<K extends valueof<PostNodeChildrenMap>>(\n\t\tnode_class: Constructor<K>,\n\t\toptions?: NodeCreateOptions\n\t): K;\n\toverride createNode<K extends valueof<PostNodeChildrenMap>>(\n\t\tnode_class: Constructor<K>,\n\t\toptions?: NodeCreateOptions\n\t): K {\n\t\treturn super.createNode(node_class, options) as K;\n\t}\n\toverride children() {\n\t\treturn super.children() as BasePostProcessNodeType[];\n\t}\n\toverride nodesByType<K extends keyof PostNodeChildrenMap>(type: K): PostNodeChildrenMap[K][] {\n\t\treturn super.nodesByType(type) as PostNodeChildrenMap[K][];\n\t}\n}\n","import {NodeContext} from '../../poly/NodeContext';\nimport {NodeParamsConfig} from '../utils/params/ParamsConfig';\nimport {TypedNode} from '../_Base';\n\nclass ParamLessNetworkMatParamsConfig extends NodeParamsConfig {}\nexport class BaseNetworkMatNode<K extends NodeParamsConfig> extends TypedNode<NodeContext.MAT, K> {\n\tstatic override context(): NodeContext {\n\t\treturn NodeContext.MAT;\n\t}\n\toverride cook() {\n\t\tthis.cookController.endCook();\n\t}\n}\nexport class ParamLessBaseNetworkMatNode extends BaseNetworkMatNode<ParamLessNetworkMatParamsConfig> {}\n","export default \"#define LIGHT_WORLD_SIZE 0.005\\n// #define LIGHT_FRUSTUM_WIDTH 1.0\\n// #define PCSS_FILTER_SIZE 1.0\\n#define LIGHT_SIZE_UV (PCSS_FILTER_SIZE * LIGHT_WORLD_SIZE)\\n#define NEAR_PLANE 9.5\\n\\n#define NUM_SAMPLES 17\\n#define NUM_RINGS 11\\n#define BLOCKER_SEARCH_NUM_SAMPLES NUM_SAMPLES\\n\\nvec2 poissonDisk[NUM_SAMPLES];\\n\\nvoid initPoissonSamples( const in vec2 randomSeed ) {\\n\\tfloat ANGLE_STEP = PI2 * float( NUM_RINGS ) / float( NUM_SAMPLES );\\n\\tfloat INV_NUM_SAMPLES = 1.0 / float( NUM_SAMPLES );\\n\\n\\t// jsfiddle that shows sample pattern: https://jsfiddle.net/a16ff1p7/\\n\\tfloat angle = rand( randomSeed ) * PI2;\\n\\tfloat radius = INV_NUM_SAMPLES;\\n\\tfloat radiusStep = radius;\\n\\n\\tfor( int i = 0; i < NUM_SAMPLES; i ++ ) {\\n\\t\\tpoissonDisk[i] = vec2( cos( angle ), sin( angle ) ) * pow( radius, 0.75 );\\n\\t\\tradius += radiusStep;\\n\\t\\tangle += ANGLE_STEP;\\n\\t}\\n}\\n\\nfloat penumbraSize( const in float zReceiver, const in float zBlocker ) { // Parallel plane estimation\\n\\treturn (zReceiver - zBlocker) / zBlocker;\\n}\\n\\nfloat findBlocker( sampler2D shadowMap, const in vec2 uv, const in float zReceiver ) {\\n\\t// This uses similar triangles to compute what\\n\\t// area of the shadow map we should search\\n\\tfloat searchRadius = LIGHT_SIZE_UV * ( zReceiver - NEAR_PLANE ) / zReceiver;\\n\\tfloat blockerDepthSum = 0.0;\\n\\tint numBlockers = 0;\\n\\n\\tfor( int i = 0; i < BLOCKER_SEARCH_NUM_SAMPLES; i++ ) {\\n\\t\\tfloat shadowMapDepth = unpackRGBAToDepth(texture2D(shadowMap, uv + poissonDisk[i] * searchRadius));\\n\\t\\tif ( shadowMapDepth < zReceiver ) {\\n\\t\\t\\tblockerDepthSum += shadowMapDepth;\\n\\t\\t\\tnumBlockers ++;\\n\\t\\t}\\n\\t}\\n\\n\\tif( numBlockers == 0 ) return -1.0;\\n\\n\\treturn blockerDepthSum / float( numBlockers );\\n}\\n\\nfloat PCF_Filter(sampler2D shadowMap, vec2 uv, float zReceiver, float filterRadius ) {\\n\\tfloat sum = 0.0;\\n\\tfloat depth;\\n\\t#pragma unroll_loop_start\\n\\tfor( int i = 0; i < 17; i ++ ) {\\n\\t\\tdepth = unpackRGBAToDepth( texture2D( shadowMap, uv + poissonDisk[ i ] * filterRadius ) );\\n\\t\\tif( zReceiver <= depth ) sum += 1.0;\\n\\t}\\n\\t#pragma unroll_loop_end\\n\\t#pragma unroll_loop_start\\n\\tfor( int i = 0; i < 17; i ++ ) {\\n\\t\\tdepth = unpackRGBAToDepth( texture2D( shadowMap, uv + -poissonDisk[ i ].yx * filterRadius ) );\\n\\t\\tif( zReceiver <= depth ) sum += 1.0;\\n\\t}\\n\\t#pragma unroll_loop_end\\n\\treturn sum / ( 2.0 * float( 17 ) );\\n}\\n\\nfloat PCSS ( sampler2D shadowMap, vec4 coords ) {\\n\\tvec2 uv = coords.xy;\\n\\tfloat zReceiver = coords.z; // Assumed to be eye-space z in this code\\n\\n\\tinitPoissonSamples( uv );\\n\\t// STEP 1: blocker search\\n\\tfloat avgBlockerDepth = findBlocker( shadowMap, uv, zReceiver );\\n\\n\\t//There are no occluders so early out (this saves filtering)\\n\\tif( avgBlockerDepth == -1.0 ) return 1.0;\\n\\n\\t// STEP 2: penumbra size\\n\\tfloat penumbraRatio = penumbraSize( zReceiver, avgBlockerDepth );\\n\\tfloat filterRadius = penumbraRatio * LIGHT_SIZE_UV * NEAR_PLANE / zReceiver;\\n\\n\\t// STEP 3: filtering\\n\\t//return avgBlockerDepth;\\n\\treturn PCF_Filter( shadowMap, uv, zReceiver, filterRadius );\\n}\"","export default \"return PCSS( shadowMap, shadowCoord );\"","import {Constructor} from '../../../../types/GlobalTypes';\nimport {Material} from 'three';\nimport {TypedMatNode} from '../_Base';\nimport {BaseController} from './_BaseController';\nimport {NodeParamsConfig, ParamConfig} from '../../utils/params/ParamsConfig';\nimport {BaseNodeType} from '../../_Base';\nimport {isBooleanTrue} from '../../../../core/BooleanValue';\nimport {BaseBuilderMatNodeType} from '../_BaseBuilder';\nimport PCSS from './shadows/pcss/glsl/PCSS.glsl';\nimport PCSSGetShadow from './shadows/pcss/glsl/PCSSGetShadow.glsl';\nimport SHADOW_MAP_PARS_FRAGMENT from 'three/src/renderers/shaders/ShaderChunk/shadowmap_pars_fragment.glsl';\nimport {ThreeToGl} from '../../../../core/ThreeToGl';\n\nexport function PCSSParamConfig<TBase extends Constructor>(Base: TBase) {\n\treturn class Mixin extends Base {\n\t\t/** @param if on, the material will blur shadows cast on this object. Note that you should adjust the near parameter of the light shadow to get the result visible */\n\t\tshadowPCSS = ParamConfig.BOOLEAN(0, {\n\t\t\tcallback: (node: BaseNodeType) => {\n\t\t\t\tPCSSController.PARAM_CALLBACK_setRecompileRequired(node as PCSSMapMatNode);\n\t\t\t},\n\t\t\tseparatorBefore: true,\n\t\t});\n\t\t/** @param shadowPCSSFilterSize PCSS Shadow filter size */\n\t\tshadowPCSSFilterSize = ParamConfig.FLOAT(1, {\n\t\t\tvisibleIf: {shadowPCSS: 1},\n\t\t\trange: [0, 10],\n\t\t\trangeLocked: [true, false],\n\t\t});\n\t};\n}\n\nclass PCSSParamsConfig extends PCSSParamConfig(NodeParamsConfig) {}\nfunction isValidMaterial(material?: Material): material is Material {\n\tif (!material) {\n\t\treturn false;\n\t}\n\treturn true;\n}\nexport interface PCSSControllers {\n\tPCSS: PCSSController;\n}\nabstract class PCSSMapMatNode extends TypedMatNode<Material, PCSSParamsConfig> {\n\tcontrollers!: PCSSControllers;\n\tasync material() {\n\t\tconst container = await this.compute();\n\t\treturn container.material() as Material | undefined;\n\t}\n}\n\nexport class PCSSController extends BaseController {\n\tconstructor(protected override node: PCSSMapMatNode) {\n\t\tsuper(node);\n\t}\n\n\tstatic filterFragmentShader(node: PCSSMapMatNode, fragmentShader: string) {\n\t\t// removed since PCSS refactor in GLSL\n\t\t// #define NUM_SAMPLES ${ThreeToGl.integer(node.pv.shadowPCSSSamplesCount)}\n\t\tconst PCSSWithDefines = `\n#define PCSS_FILTER_SIZE ${ThreeToGl.float(node.pv.shadowPCSSFilterSize)}\n${PCSS}\n`;\n\n\t\tlet shadowParsFragmentModified = SHADOW_MAP_PARS_FRAGMENT;\n\t\tshadowParsFragmentModified = shadowParsFragmentModified.replace(\n\t\t\t'#ifdef USE_SHADOWMAP',\n\t\t\t`#ifdef USE_SHADOWMAP\n${PCSSWithDefines}\n\t\t\t\t`\n\t\t);\n\n\t\tshadowParsFragmentModified = shadowParsFragmentModified.replace(\n\t\t\t'#if defined( SHADOWMAP_TYPE_PCF )',\n\t\t\t`\n\t\t\t\t${PCSSGetShadow}\n\t\t\t\t#if defined( SHADOWMAP_TYPE_PCF )`\n\t\t);\n\n\t\tfragmentShader = fragmentShader.replace('#include <shadowmap_pars_fragment>', shadowParsFragmentModified);\n\n\t\treturn fragmentShader;\n\t}\n\tstatic async update(node: PCSSMapMatNode) {\n\t\tconst material = await node.material();\n\t\tif (!isValidMaterial(material)) {\n\t\t\treturn;\n\t\t}\n\t\tnode.controllers.PCSS.updateMaterial(material);\n\t}\n\tasync update() {\n\t\tPCSSController.update(this.node);\n\t}\n\n\toverride updateMaterial(material: Material) {\n\t\tconst matNode = (<unknown>this.node) as BaseBuilderMatNodeType;\n\t\tif (!matNode.assemblerController) {\n\t\t\treturn;\n\t\t}\n\t\tconst callbackName = 'PCSS';\n\t\tif (isBooleanTrue(this.node.pv.shadowPCSS)) {\n\t\t\tmatNode\n\t\t\t\t.assemblerController()\n\t\t\t\t?.addFilterFragmentShaderCallback(callbackName, (fragmentShader: string) =>\n\t\t\t\t\tPCSSController.filterFragmentShader(this.node, fragmentShader)\n\t\t\t\t);\n\t\t} else {\n\t\t\tmatNode.assemblerController()?.removeFilterFragmentShaderCallback(callbackName);\n\t\t}\n\t}\n\n\t// static async update(node: PCSSMapMatNode) {\n\t// \tnode.controllers.PCSS.update();\n\t// }\n\tstatic PARAM_CALLBACK_setRecompileRequired(node: PCSSMapMatNode) {\n\t\tnode.controllers.PCSS.update();\n\t}\n}\n","import {Material} from 'three';\nimport {TypeAssert} from '../../../../poly/Assert';\nimport {NodeParamsConfig} from '../../../utils/params/ParamsConfig';\nimport {CustomMaterialName} from '../../../../../core/geometry/Material';\nimport {Constructor} from '../../../../../types/GlobalTypes';\nimport {ParamConfig} from '../../../utils/params/ParamsConfig';\nimport {BaseBuilderParamConfig} from '../../_BaseBuilder';\nimport {isBooleanTrue} from '../../../../../core/Type';\nimport {TypedMatNode} from '../../_Base';\nimport {CUSTOM_MAT_PARAM_OPTIONS} from './_CustomMaterialBase';\n\nexport function CustomMaterialMeshParamConfig<TBase extends Constructor>(Base: TBase) {\n\treturn class Mixin extends Base {\n\t\t/** @param toggle on to choose which customMaterials will be generated */\n\t\toverrideCustomMaterials = ParamConfig.BOOLEAN(0, {\n\t\t\t...CUSTOM_MAT_PARAM_OPTIONS,\n\t\t\tseparatorBefore: true,\n\t\t\tseparatorAfter: true,\n\t\t});\n\t\t/** @param distance material used for shadows from points lights */\n\t\tcreateCustomMatDistance = ParamConfig.BOOLEAN(1, {\n\t\t\tvisibleIf: {overrideCustomMaterials: 1},\n\t\t\t...CUSTOM_MAT_PARAM_OPTIONS,\n\t\t});\n\t\t/** @param depth material used for shadows from spot lights and directional lights */\n\t\tcreateCustomMatDepth = ParamConfig.BOOLEAN(1, {\n\t\t\tvisibleIf: {overrideCustomMaterials: 1},\n\t\t\t...CUSTOM_MAT_PARAM_OPTIONS,\n\t\t});\n\t\t/** @param depth DOF */\n\t\tcreateCustomMatDepthDOF = ParamConfig.BOOLEAN(1, {\n\t\t\tvisibleIf: {overrideCustomMaterials: 1},\n\t\t\t...CUSTOM_MAT_PARAM_OPTIONS,\n\t\t\tseparatorAfter: true,\n\t\t});\n\t};\n}\nclass CustomMaterialMeshParamsConfig extends CustomMaterialMeshParamConfig(BaseBuilderParamConfig(NodeParamsConfig)) {}\n\nabstract class CustomMaterialMatNode<M extends Material> extends TypedMatNode<M, CustomMaterialMeshParamsConfig> {}\n\nexport function materialMeshAssemblerCustomMaterialRequested(\n\tnode: CustomMaterialMatNode<any>,\n\tcustomName: CustomMaterialName\n): boolean {\n\tconst param = node.p.overrideCustomMaterials;\n\tif (!param) {\n\t\tconsole.warn(`param overrideCustomMaterials not found on ${node.path()}, creating all customMaterials`);\n\t\treturn true;\n\t}\n\tif (!isBooleanTrue(node.pv.overrideCustomMaterials)) {\n\t\treturn true;\n\t}\n\tswitch (customName) {\n\t\tcase CustomMaterialName.DISTANCE: {\n\t\t\treturn isBooleanTrue(node.pv.createCustomMatDistance);\n\t\t}\n\t\tcase CustomMaterialName.DEPTH: {\n\t\t\treturn isBooleanTrue(node.pv.createCustomMatDepth);\n\t\t}\n\t\tcase CustomMaterialName.DEPTH_DOF: {\n\t\t\treturn isBooleanTrue(node.pv.createCustomMatDepthDOF);\n\t\t}\n\t}\n\tTypeAssert.unreachable(customName);\n}\n","/**\n * Creates an ambient light.\n *\n * @remarks\n * An ambient light will add a uniform light to every object. This can be useful to elevate the shadows slightly.\n *\n */\nimport {AmbientLight} from 'three';\nimport {TypedLightObjNode} from './_BaseLight';\n\nimport {NodeParamsConfig} from '../utils/params/ParamsConfig';\nimport {AmbientLightParamConfig} from '../../../core/lights/AmbientLight';\nimport {AmbientLightSopOperation} from '../../operations/sop/AmbientLight';\nclass AmbientLightObjParamsConfig extends AmbientLightParamConfig(NodeParamsConfig) {}\nconst ParamsConfig = new AmbientLightObjParamsConfig();\n\nexport class AmbientLightObjNode extends TypedLightObjNode<AmbientLight, AmbientLightObjParamsConfig> {\n\toverride paramsConfig = ParamsConfig;\n\n\tstatic override type() {\n\t\treturn 'ambientLight';\n\t}\n\toverride initializeNode() {\n\t\tthis.io.inputs.setCount(0, 1);\n\t}\n\n\tprivate __operation__: AmbientLightSopOperation | undefined;\n\tprivate _operation() {\n\t\treturn (this.__operation__ =\n\t\t\tthis.__operation__ || new AmbientLightSopOperation(this._scene, this.states, this));\n\t}\n\tcreateLight() {\n\t\treturn this._operation().createLight();\n\t}\n\n\tprotected override updateLightParams() {\n\t\tthis._operation().updateLightParams(this.light, this.pv);\n\t}\n}\n","/**\n * Creates an area light.\n *\n * @remarks\n * An area light can be expensive to compute but can give a good result.\n *\n */\nimport {RectAreaLight} from 'three';\nimport {BaseLightTransformedObjNode} from './_BaseLightTransformed';\nimport {TransformedParamConfig} from './utils/TransformController';\nimport {NodeParamsConfig} from '../utils/params/ParamsConfig';\nimport {AreaLightParamConfig, CoreRectAreaLightHelper} from '../../../core/lights/AreaLight';\nimport {AreaLightSopOperation} from '../../operations/sop/AreaLight';\nimport {isBooleanTrue} from '../../../core/Type';\nimport {LightType} from '../../poly/registers/nodes/types/Light';\n\nclass AreaLightObjParamsConfig extends AreaLightParamConfig(TransformedParamConfig(NodeParamsConfig)) {}\nconst ParamsConfig = new AreaLightObjParamsConfig();\n\nexport class AreaLightObjNode extends BaseLightTransformedObjNode<RectAreaLight, AreaLightObjParamsConfig> {\n\toverride paramsConfig = ParamsConfig;\n\tstatic override type() {\n\t\treturn LightType.AREA;\n\t}\n\n\tprivate __operation__: AreaLightSopOperation | undefined;\n\tprivate _operation() {\n\t\treturn (this.__operation__ = this.__operation__ || new AreaLightSopOperation(this._scene, this.states, this));\n\t}\n\tcreateLight() {\n\t\treturn this._operation().createLight();\n\t}\n\n\tprotected override updateLightParams() {\n\t\tthis._operation().updateLightParams(this.light, this.pv);\n\n\t\tif (isBooleanTrue(this.pv.showHelper)) {\n\t\t\tthis._helper = this._helper || new CoreRectAreaLightHelper(this.light, this.name());\n\t\t\tthis.light.add(this._helper);\n\t\t\tthis._helper.update();\n\t\t} else {\n\t\t\tif (this._helper) {\n\t\t\t\tthis.light.remove(this._helper);\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate _helper: CoreRectAreaLightHelper | undefined;\n}\n","import {Vector3} from 'three';\nimport {Quaternion} from 'three';\nimport {Clock} from 'three';\nimport {Object3D} from 'three';\nimport {Listener} from 'tone/build/esm/core/context/Listener';\nimport {AnyAudioContext} from 'tone/build/esm/core/context/AudioContext';\nimport {Gain} from 'tone/build/esm/core/context/Gain';\nimport {CorePositionalAudio} from './PositionalAudio';\n\nconst _position = new Vector3();\nconst _quaternion = new Quaternion();\nconst _scale = new Vector3();\nconst _orientation = new Vector3();\n\nexport class CoreAudioListener extends Object3D {\n\tprivate context: AnyAudioContext;\n\tprivate timeDelta = 0;\n\tprivate _clock = new Clock();\n\tprivate gain: Gain;\n\tpublic listenerTransformAutoUpdate: boolean = true;\n\n\tconstructor() {\n\t\tsuper();\n\n\t\tconst listener = new Listener();\n\t\tthis.context = listener.context.rawContext;\n\t\tthis.gain = new Gain();\n\t\t// this.gain.connect(listener);\n\n\t\t// this.gain = this.context.createGain();\n\t\tthis.gain.connect(this.context.destination);\n\t}\n\n\tasync addInput(positionalAudioNode: CorePositionalAudio) {\n\t\tpositionalAudioNode.connect(this.gain);\n\t}\n\tdispose() {\n\t\tthis.setMasterVolume(0);\n\t\tthis.gain.disconnect();\n\t}\n\n\t// removeFilter() {\n\t// \tif (this.filter !== null) {\n\t// \t\tthis.gain.disconnect(this.filter);\n\t// \t\tthis.filter.disconnect(this.context.destination);\n\t// \t\tthis.gain.connect(this.context.destination);\n\t// \t\tthis.filter = null;\n\t// \t}\n\n\t// \treturn this;\n\t// }\n\n\t// getFilter() {\n\t// \treturn this.filter;\n\t// }\n\n\t// setFilter(value) {\n\t// \tif (this.filter !== null) {\n\t// \t\tthis.gain.disconnect(this.filter);\n\t// \t\tthis.filter.disconnect(this.context.destination);\n\t// \t} else {\n\t// \t\tthis.gain.disconnect(this.context.destination);\n\t// \t}\n\n\t// \tthis.filter = value;\n\t// \tthis.gain.connect(this.filter);\n\t// \tthis.filter.connect(this.context.destination);\n\n\t// \treturn this;\n\t// }\n\n\t// getMasterVolume() {\n\t// \treturn this.gain.gain.value;\n\t// }\n\n\tsetMasterVolume(value: number) {\n\t\tthis.gain.gain.setTargetAtTime(value, this.context.currentTime, 0.01);\n\t\t// this.volume.volume.setTargetAtTime(value, this.context.currentTime, 0.01);\n\n\t\treturn this;\n\t}\n\tmasterVolume() {\n\t\treturn this.gain.gain.value;\n\t}\n\n\toverride updateMatrixWorld(force: boolean) {\n\t\tsuper.updateMatrixWorld(force);\n\t\tif (!this.listenerTransformAutoUpdate) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst listener = this.context.listener;\n\t\tconst up = this.up;\n\n\t\tthis.timeDelta = this._clock.getDelta();\n\n\t\tthis.matrixWorld.decompose(_position, _quaternion, _scale);\n\n\t\t_orientation.set(0, 0, -1).applyQuaternion(_quaternion);\n\n\t\tif (listener.positionX) {\n\t\t\t// code path for Chrome (see #14393)\n\n\t\t\tconst endTime = this.context.currentTime + this.timeDelta;\n\n\t\t\tlistener.positionX.linearRampToValueAtTime(_position.x, endTime);\n\t\t\tlistener.positionY.linearRampToValueAtTime(_position.y, endTime);\n\t\t\tlistener.positionZ.linearRampToValueAtTime(_position.z, endTime);\n\t\t\tlistener.forwardX.linearRampToValueAtTime(_orientation.x, endTime);\n\t\t\tlistener.forwardY.linearRampToValueAtTime(_orientation.y, endTime);\n\t\t\tlistener.forwardZ.linearRampToValueAtTime(_orientation.z, endTime);\n\t\t\tlistener.upX.linearRampToValueAtTime(up.x, endTime);\n\t\t\tlistener.upY.linearRampToValueAtTime(up.y, endTime);\n\t\t\tlistener.upZ.linearRampToValueAtTime(up.z, endTime);\n\t\t} else {\n\t\t\tlistener.setPosition(_position.x, _position.y, _position.z);\n\t\t\tlistener.setOrientation(_orientation.x, _orientation.y, _orientation.z, up.x, up.y, up.z);\n\t\t}\n\t}\n}\n","/**\n * Creates an audio listener.\n *\n * @remarks\n * You typically want to parent this under the camera.\n *\n */\nimport {TypedObjNode} from './_Base';\nimport {TransformedParamConfig, TransformController} from './utils/TransformController';\nimport {FlagsControllerD} from '../utils/FlagsController';\nimport {NodeParamsConfig, ParamConfig} from '../utils/params/ParamsConfig';\nimport {HierarchyController} from './utils/HierarchyController';\nimport {ObjType} from '../../poly/registers/nodes/types/Obj';\nimport {isBooleanTrue} from '../../../core/Type';\nimport {CoreAudioListener} from '../../../core/audio/AudioListener';\nimport {BaseNodeType} from '../_Base';\nimport {AudioController} from '../../../core/audio/AudioController';\nclass AudioListenerParamConfig extends TransformedParamConfig(NodeParamsConfig) {\n\taudio = ParamConfig.FOLDER();\n\t/** @param soundOn */\n\tsoundOn = ParamConfig.BOOLEAN(1, {\n\t\tcook: false,\n\t\tcallback: (node: BaseNodeType) => {\n\t\t\tAudioListenerObjNode.PARAM_CALLBACK_update(node as AudioListenerObjNode);\n\t\t},\n\t});\n\t/** @param volume */\n\tmasterVolume = ParamConfig.FLOAT(1, {\n\t\trange: [0, 1],\n\t\trangeLocked: [true, false],\n\t});\n\t/** @param ensures the transform of the audio listener is updated on very frame */\n\tlistenerTransformAutoUpdate = ParamConfig.BOOLEAN(1);\n}\nconst ParamsConfig = new AudioListenerParamConfig();\n\nexport class AudioListenerObjNode extends TypedObjNode<CoreAudioListener, AudioListenerParamConfig> {\n\toverride paramsConfig = ParamsConfig;\n\tstatic override type() {\n\t\treturn ObjType.AUDIO_LISTENER;\n\t}\n\toverride readonly hierarchyController: HierarchyController = new HierarchyController(this);\n\toverride readonly transformController: TransformController = new TransformController(this);\n\tpublic override readonly flags: FlagsControllerD = new FlagsControllerD(this);\n\n\toverride createObject() {\n\t\t// const group = new AudioListener();\n\t\tconst object = new CoreAudioListener();\n\t\tobject.matrixAutoUpdate = false;\n\n\t\t// const listener = new Listener();\n\t\t// console.log(listener.get());\n\t\t// console.log(listener.context);\n\t\t// (window as any).context2 = listener.context;\n\t\t// (window as any).context3 = listener.context.rawContext.listener;\n\t\t// (window as any).context4 = AudioContext.getContext();\n\n\t\treturn object;\n\t}\n\toverride initializeNode() {\n\t\tthis.hierarchyController.initializeNode();\n\t\tthis.transformController.initializeNode();\n\n\t\tthis.lifecycle.onAfterAdded(() => {\n\t\t\tthis._setPositionalAudioNodesDirty();\n\t\t\tthis.addAudioActivationEvents();\n\t\t\tthis.root().audioController.update();\n\t\t});\n\t}\n\toverride dispose() {\n\t\tsuper.dispose();\n\t\tthis.object.dispose();\n\t\tthis._setPositionalAudioNodesDirty();\n\t\tthis.root().audioController.update();\n\t}\n\ttoggleSound() {\n\t\tthis.p.soundOn.set(!isBooleanTrue(this.pv.soundOn));\n\t}\n\tprivate _setPositionalAudioNodesDirty() {\n\t\t// set the positionalAudio dirty\n\t\t// so that they can raise an error if no other listener is found\n\t\tthis.root()\n\t\t\t.nodesByType('positionalAudio')\n\t\t\t.forEach((n) => n.setDirty());\n\t}\n\n\toverride cook() {\n\t\tthis.transformController.update();\n\t\tthis._validateUniq();\n\t\tthis._updateListenerAndViewers();\n\t\tthis.cookController.endCook();\n\t}\n\tprivate _validateUniq() {\n\t\tconst existingListeners = this.root().audioController.audioListeners();\n\t\tif (existingListeners.length > 1) {\n\t\t\tthis.states.error.set('only 1 audioListener can exist in a scene');\n\t\t}\n\t}\n\n\tprivate _updateAudioListener() {\n\t\tconst volume = isBooleanTrue(this.pv.soundOn) ? this.pv.masterVolume : 0;\n\t\tthis.object.setMasterVolume(volume);\n\t\tthis.object.listenerTransformAutoUpdate = isBooleanTrue(this.pv.listenerTransformAutoUpdate);\n\t}\n\n\tprivate _updateViewers() {\n\t\tthis.root().audioController.update();\n\t}\n\tprivate _updateListenerAndViewers() {\n\t\tthis._updateAudioListener();\n\t\tthis._updateViewers();\n\t}\n\n\tstatic PARAM_CALLBACK_update(node: AudioListenerObjNode) {\n\t\tnode._updateListenerAndViewers();\n\t}\n\n\t/*\n\n\tEVENTS TO ACTIVATE SOUND\n\n\t*/\n\tprivate static _eventsAdded = false;\n\tprivate static _audioActivated = false;\n\tprivate async _onpointerdown(event: PointerEvent) {\n\t\tawait this.activateSound();\n\t}\n\tprivate async _onkeypress(event: KeyboardEvent) {\n\t\tawait this.activateSound();\n\t}\n\tstatic soundActivated(): boolean {\n\t\treturn this._audioActivated;\n\t}\n\tsoundActivated(): boolean {\n\t\treturn AudioListenerObjNode.soundActivated();\n\t}\n\tasync activateSound() {\n\t\tif (!this.soundActivated()) {\n\t\t\tawait AudioController.start();\n\t\t\tAudioListenerObjNode._audioActivated = true;\n\t\t}\n\t\t// remove events as they are not needed\n\t\t// once the audio has been activated via user event\n\t\tthis._removeAudioActivationEvents();\n\t}\n\tprivate _boundEvents = {\n\t\tpointerdown: this._onpointerdown.bind(this),\n\t\tkeypress: this._onkeypress.bind(this),\n\t};\n\taddAudioActivationEvents() {\n\t\tif (this.soundActivated()) {\n\t\t\treturn;\n\t\t}\n\t\tif (AudioListenerObjNode._eventsAdded) {\n\t\t\treturn;\n\t\t}\n\t\tAudioListenerObjNode._eventsAdded = true;\n\t\tdocument.body.addEventListener('pointerdown', this._boundEvents.pointerdown);\n\t\tdocument.body.addEventListener('keypress', this._boundEvents.keypress);\n\t}\n\tprivate _removeAudioActivationEvents() {\n\t\tdocument.body.removeEventListener('pointerdown', this._boundEvents.pointerdown);\n\t\tdocument.body.removeEventListener('keypress', this._boundEvents.keypress);\n\t}\n}\n","/**\n * Creates a directional light.\n *\n *\n */\nimport {NodeParamsConfig} from '../utils/params/ParamsConfig';\nimport {BaseLightTransformedObjNode} from './_BaseLightTransformed';\nimport {TransformedParamConfig} from './utils/TransformController';\nimport {LightType} from '../../poly/registers/nodes/types/Light';\nimport {DirectionalLightParamConfig, DirectionalLightContainer} from '../../../core/lights/DirectionalLight';\nimport {DirectionalLightSopOperation} from '../../operations/sop/DirectionalLight';\n\nclass DirectionalLightObjParamsConfig extends DirectionalLightParamConfig(TransformedParamConfig(NodeParamsConfig)) {}\nconst ParamsConfig = new DirectionalLightObjParamsConfig();\n\nexport class DirectionalLightObjNode extends BaseLightTransformedObjNode<\n\tDirectionalLightContainer,\n\tDirectionalLightObjParamsConfig\n> {\n\toverride paramsConfig = ParamsConfig;\n\tstatic override type() {\n\t\treturn LightType.DIRECTIONAL;\n\t}\n\n\tprivate __operation__: DirectionalLightSopOperation | undefined;\n\tprivate _operation() {\n\t\treturn (this.__operation__ =\n\t\t\tthis.__operation__ || new DirectionalLightSopOperation(this._scene, this.states, this));\n\t}\n\toverride createLight() {\n\t\treturn this._operation().createLight({showHelper: this.pv.showHelper});\n\t}\n\n\tprotected override updateLightParams() {\n\t\tthis._operation().updateLightParams(this.light, this.pv);\n\t}\n\tprotected override updateShadowParams() {\n\t\tthis.light.showHelper = this.pv.showHelper;\n\t\tthis._operation().updateShadowParams(this.light, this.pv);\n\t}\n}\n","/**\n * Creates a hemisphere light.\n *\n *\n */\nimport {HemisphereLight} from 'three';\nimport {TypedLightObjNode} from './_BaseLight';\nimport {NodeParamsConfig} from '../utils/params/ParamsConfig';\nimport {LightType} from '../../poly/registers/nodes/types/Light';\nimport {HemisphereLightParamConfig} from '../../../core/lights/HemisphereLight';\nimport {HemisphereLightSopOperation} from '../../operations/sop/HemisphereLight';\n\nclass HemisphereLightObjParamsConfig extends HemisphereLightParamConfig(NodeParamsConfig) {}\nconst ParamsConfig = new HemisphereLightObjParamsConfig();\n\nexport class HemisphereLightObjNode extends TypedLightObjNode<HemisphereLight, HemisphereLightObjParamsConfig> {\n\toverride paramsConfig = ParamsConfig;\n\tstatic override type() {\n\t\treturn LightType.HEMISPHERE;\n\t}\n\n\tprivate __operation__: HemisphereLightSopOperation | undefined;\n\tprivate _operation() {\n\t\treturn (this.__operation__ =\n\t\t\tthis.__operation__ || new HemisphereLightSopOperation(this._scene, this.states, this));\n\t}\n\toverride createLight() {\n\t\treturn this._operation().createLight();\n\t}\n\n\tprotected override updateLightParams() {\n\t\tthis._operation().updateLightParams(this.light, this.pv);\n\t}\n}\n","import {Constructor} from '../../../../../types/GlobalTypes';\nimport {MeshBasicMaterial} from 'three';\nimport {NodeParamsConfig, ParamConfig} from '../../../utils/params/ParamsConfig';\nimport {TypedObjNode} from '../../_Base';\nimport {Group} from 'three';\nimport {Object3D} from 'three';\nimport {FlagsControllerD} from '../../../utils/FlagsController';\nexport function BaseLightHelperParamConfig<TBase extends Constructor>(Base: TBase) {\n\treturn class Mixin extends Base {\n\t\tshowHelper = ParamConfig.BOOLEAN(0);\n\t};\n}\nclass BaseLightHelperParamsConfig extends BaseLightHelperParamConfig(NodeParamsConfig) {}\nexport abstract class BaseLightHelperObjNode<L extends Object3D> extends TypedObjNode<\n\tGroup,\n\tBaseLightHelperParamsConfig\n> {\n\tpublic override readonly flags: FlagsControllerD = new FlagsControllerD(this);\n\n\t// public readonly helper: BaseLightHelper<L> | undefined;\n\tabstract get light(): L;\n}\n\nexport abstract class BaseLightHelper<O extends Object3D, L extends Object3D, N extends BaseLightHelperObjNode<L>> {\n\tprotected _object: O = this.createObject();\n\tprotected _material = new MeshBasicMaterial({wireframe: true, fog: false});\n\tconstructor(protected node: N, private _name: string) {}\n\n\tbuild() {\n\t\tthis._object.matrixAutoUpdate = false;\n\t\tthis._object.name = this._name;\n\t\tthis.buildHelper();\n\t}\n\n\tprotected abstract createObject(): O;\n\tprotected abstract buildHelper(): void;\n\tget object() {\n\t\treturn this._object;\n\t}\n\n\tabstract update(): void;\n}\n","import {PointLightObjNode} from '../../PointLight';\nimport {BaseLightHelper} from './_BaseLightHelper';\nimport {PointLight} from 'three';\nimport {Mesh} from 'three';\nimport {CorePointLightHelper} from '../../../../../core/lights/PointLight';\n\nexport class PointLightHelper extends BaseLightHelper<Mesh, PointLight, PointLightObjNode> {\n\tcreateObject() {\n\t\treturn new Mesh();\n\t}\n\tprivate _coreHelper = new CorePointLightHelper();\n\tprotected buildHelper() {\n\t\tthis._coreHelper.buildHelper(this._object);\n\t}\n\n\tupdate() {\n\t\tthis._coreHelper.update(this._object, {helperSize: this.node.pv.helperSize, light: this.node.light});\n\t}\n}\n","import {Object3D} from 'three';\nimport {BaseLightHelper, BaseLightHelperObjNode} from './helpers/_BaseLightHelper';\n\n// interface Helper<L extends Light> extends BaseLightHelper<L> {\n// \tdispose: () => void;\n// \tupdate: () => void;\n// }\nexport interface HelperConstructor<O extends Object3D, L extends Object3D> {\n\tnew (node: BaseLightHelperObjNode<L>, name: string): BaseLightHelper<O, L, BaseLightHelperObjNode<L>>;\n}\n\nexport class HelperController<O extends Object3D, L extends Object3D> {\n\tprivate _helper: BaseLightHelper<O, L, BaseLightHelperObjNode<L>> | undefined;\n\tconstructor(\n\t\tprivate node: BaseLightHelperObjNode<L>,\n\t\tprivate _helperConstructor: HelperConstructor<O, L>,\n\t\tprivate _name: string\n\t) {}\n\n\tinitializeNode() {\n\t\tthis.node.flags.display.onUpdate(() => {\n\t\t\tthis.update();\n\t\t});\n\t}\n\n\tvisible() {\n\t\treturn this.node.flags.display.active() && this.node.pv.showHelper;\n\t}\n\n\tprivate _createHelper(): BaseLightHelper<O, L, BaseLightHelperObjNode<L>> {\n\t\tconst helper = new this._helperConstructor(this.node, this._name);\n\t\thelper.build();\n\t\treturn helper;\n\t}\n\n\tupdate() {\n\t\tif (this.visible()) {\n\t\t\tif (!this._helper) {\n\t\t\t\tthis._helper = this._createHelper();\n\t\t\t}\n\t\t\tif (this._helper) {\n\t\t\t\tthis.node.light.add(this._helper.object);\n\t\t\t\tthis._helper.update();\n\t\t\t}\n\t\t} else {\n\t\t\tif (this._helper) {\n\t\t\t\tthis.node.light.remove(this._helper.object);\n\t\t\t}\n\t\t}\n\t}\n}\n","/**\n * Creates a point light.\n *\n *\n */\nimport {PointLight} from 'three';\nimport {PointLightHelper} from './utils/helpers/PointLightHelper';\nimport {BaseLightTransformedObjNode} from './_BaseLightTransformed';\nimport {TransformedParamConfig} from './utils/TransformController';\nimport {NodeParamsConfig} from '../utils/params/ParamsConfig';\nimport {HelperController, HelperConstructor} from './utils/HelperController';\nimport {Mesh} from 'three';\nimport {LightType} from '../../poly/registers/nodes/types/Light';\nimport {PointLightSopOperation} from '../../operations/sop/PointLight';\nimport {PointLightParamConfig} from '../../../core/lights/PointLight';\n\nclass PointLightObjParamsConfig extends PointLightParamConfig(TransformedParamConfig(NodeParamsConfig)) {}\nconst ParamsConfig = new PointLightObjParamsConfig();\n\nexport class PointLightObjNode extends BaseLightTransformedObjNode<PointLight, PointLightObjParamsConfig> {\n\toverride paramsConfig = ParamsConfig;\n\tstatic override type() {\n\t\treturn LightType.POINT;\n\t}\n\tprivate _helperController = new HelperController<Mesh, PointLight>(\n\t\tthis,\n\t\t(<unknown>PointLightHelper) as HelperConstructor<Mesh, PointLight>,\n\t\t'PointLightHelper'\n\t);\n\toverride initializeNode() {\n\t\tthis._helperController.initializeNode();\n\t}\n\n\tprivate __operation__: PointLightSopOperation | undefined;\n\tprivate _operation() {\n\t\treturn (this.__operation__ = this.__operation__ || new PointLightSopOperation(this._scene, this.states, this));\n\t}\n\tcreateLight() {\n\t\treturn this._operation().createLight();\n\t}\n\n\tprotected override updateLightParams() {\n\t\tthis._operation().updateLightParams(this.light, this.pv);\n\n\t\tthis._helperController.update();\n\t}\n\tprotected override updateShadowParams() {\n\t\tthis._operation().updateShadowParams(this.light, this.pv);\n\t}\n}\n","/**\n * Parent for Post processing nodes\n *\n *\n */\nimport {Constructor, valueof} from '../../../types/GlobalTypes';\nimport {BaseManagerObjNode} from './_BaseManager';\nimport {NetworkNodeType, NodeContext} from '../../poly/NodeContext';\nimport {PostNodeChildrenMap} from '../../poly/registers/nodes/Post';\nimport {BasePostProcessNodeType} from '../post/_Base';\nimport {DisplayNodeController} from '../utils/DisplayNodeController';\nimport {EffectComposerController, PostProcessNetworkParamsConfig} from '../post/utils/EffectComposerController';\nimport {NodeCreateOptions} from '../utils/hierarchy/ChildrenController';\n\nexport class PostProcessNetworkObjNode extends BaseManagerObjNode<PostProcessNetworkParamsConfig> {\n\toverride paramsConfig = new PostProcessNetworkParamsConfig();\n\tstatic override type() {\n\t\treturn NetworkNodeType.POST;\n\t}\n\treadonly effectsComposerController: EffectComposerController = new EffectComposerController(this);\n\n\tpublic override readonly displayNodeController: DisplayNodeController = new DisplayNodeController(\n\t\tthis,\n\t\tthis.effectsComposerController.displayNodeControllerCallbacks()\n\t);\n\n\tprotected override _childrenControllerContext = NodeContext.POST;\n\n\toverride createNode<S extends keyof PostNodeChildrenMap>(\n\t\tnode_class: S,\n\t\toptions?: NodeCreateOptions\n\t): PostNodeChildrenMap[S];\n\toverride createNode<K extends valueof<PostNodeChildrenMap>>(\n\t\tnode_class: Constructor<K>,\n\t\toptions?: NodeCreateOptions\n\t): K;\n\toverride createNode<K extends valueof<PostNodeChildrenMap>>(\n\t\tnode_class: Constructor<K>,\n\t\toptions?: NodeCreateOptions\n\t): K {\n\t\treturn super.createNode(node_class, options) as K;\n\t}\n\toverride children() {\n\t\treturn super.children() as BasePostProcessNodeType[];\n\t}\n\toverride nodesByType<K extends keyof PostNodeChildrenMap>(type: K): PostNodeChildrenMap[K][] {\n\t\treturn super.nodesByType(type) as PostNodeChildrenMap[K][];\n\t}\n}\n","/**\n * Creates a THREE.Scene.\n *\n * @remarks\n * By default, all objects created will be added under the same master scene. This is enough in most cases, but there might be times where you want to use a custom one. For instance:\n *\n * - you would like to change the background color or the environment.\n * - you would like to have a fog.\n * - You may also use multiple scenes, if you want to switch from one to the other.\n *\n * For those situtation, you can parent the objects under a scene node, and set your camera scene parameter to point to it. The camera will then render this scene instead of the master one.\n *\n *\n */\nimport {TypedObjNode} from './_Base';\nimport {Scene} from 'three';\nimport {HierarchyController} from './utils/HierarchyController';\nimport {NodeParamsConfig} from '../utils/params/ParamsConfig';\nimport {SceneAutoUpdateParamConfig, SceneAutoUpdateController} from '../manager/utils/Scene/AutoUpdate';\nimport {SceneBackgroundParamConfig, SceneBackgroundController} from '../manager/utils/Scene/Background';\nimport {SceneEnvParamConfig, SceneEnvController} from '../manager/utils/Scene/Env';\nimport {SceneFogParamConfig, SceneFogController} from '../manager/utils/Scene/Fog';\nimport {\n\tSceneMaterialOverrideParamConfig,\n\tSceneMaterialOverrideController,\n} from '../manager/utils/Scene/MaterialOverride';\nimport {ObjType} from '../../poly/registers/nodes/types/Obj';\nclass SceneObjParamConfig extends SceneMaterialOverrideParamConfig(\n\tSceneFogParamConfig(SceneEnvParamConfig(SceneBackgroundParamConfig(SceneAutoUpdateParamConfig(NodeParamsConfig))))\n) {}\nconst ParamsConfig = new SceneObjParamConfig();\n\nexport class SceneObjNode extends TypedObjNode<Scene, SceneObjParamConfig> {\n\toverride paramsConfig = ParamsConfig;\n\tstatic override type(): Readonly<ObjType.SCENE> {\n\t\treturn ObjType.SCENE;\n\t}\n\toverride readonly hierarchyController: HierarchyController = new HierarchyController(this);\n\n\toverride createObject() {\n\t\tconst scene = new Scene();\n\t\tscene.matrixAutoUpdate = false;\n\t\treturn scene;\n\t}\n\n\toverride initializeNode() {\n\t\tthis.hierarchyController.initializeNode();\n\n\t\tthis.dirtyController.addPostDirtyHook(\n\t\t\t'cookMainWithoutInputsOnDirty',\n\t\t\tthis._cook_main_without_inputs_when_dirty_bound\n\t\t);\n\t}\n\tprivate _cook_main_without_inputs_when_dirty_bound = this._cook_main_without_inputs_when_dirty.bind(this);\n\tprivate async _cook_main_without_inputs_when_dirty() {\n\t\tawait this.cookController.cookMainWithoutInputs();\n\t}\n\n\treadonly sceneAutoUpdateController: SceneAutoUpdateController = new SceneAutoUpdateController(this as any);\n\treadonly sceneBackgroundController: SceneBackgroundController = new SceneBackgroundController(this as any);\n\treadonly sceneEnvController: SceneEnvController = new SceneEnvController(this as any);\n\treadonly sceneFogController: SceneFogController = new SceneFogController(this as any);\n\treadonly sceneMaterialOverrideController: SceneMaterialOverrideController = new SceneMaterialOverrideController(\n\t\tthis as any\n\t);\n\n\toverride cook() {\n\t\tthis.sceneAutoUpdateController.update();\n\t\tthis.sceneBackgroundController.update();\n\t\tthis.sceneEnvController.update();\n\t\tthis.sceneFogController.update();\n\t\tthis.sceneMaterialOverrideController.update();\n\n\t\tthis.cookController.endCook();\n\t}\n}\n","/**\n * Creates a spot light.\n *\n *\n */\nimport {BaseLightTransformedObjNode} from './_BaseLightTransformed';\nimport {TransformedParamConfig} from './utils/TransformController';\nimport {NodeParamsConfig} from '../utils/params/ParamsConfig';\nimport {LightType} from '../../poly/registers/nodes/types/Light';\nimport {SpotLightContainer, SpotLightParamConfig} from '../../../core/lights/SpotLight';\nimport {SpotLightSopOperation} from '../../operations/sop/SpotLight';\nclass SpotLightObjParamsConfig extends SpotLightParamConfig(TransformedParamConfig(NodeParamsConfig)) {}\nconst ParamsConfig = new SpotLightObjParamsConfig();\n\nexport class SpotLightObjNode extends BaseLightTransformedObjNode<SpotLightContainer, SpotLightObjParamsConfig> {\n\toverride paramsConfig = ParamsConfig;\n\tstatic override type() {\n\t\treturn LightType.SPOT;\n\t}\n\tprivate __operation__: SpotLightSopOperation | undefined;\n\tprivate _operation() {\n\t\treturn (this.__operation__ = this.__operation__ || new SpotLightSopOperation(this._scene, this.states, this));\n\t}\n\tcreateLight() {\n\t\treturn this._operation().createLight(this.pv);\n\t}\n\n\tprotected override async updateLightParams() {\n\t\tawait this._operation().updateLightParams(this.light, this.pv);\n\t}\n\tprotected override updateShadowParams() {\n\t\tthis.light.updateParams(this.pv);\n\t\tthis.light.updateHelper();\n\t\tthis.light.updateVolumetric();\n\n\t\tthis._operation().updateShadowParams(this.light, this.pv);\n\t}\n}\n","import {TypedObjNode, ObjNodeRenderOrder} from './_Base';\nimport {Object3D, Group} from 'three';\nimport {NodeParamsConfig} from '../utils/params/ParamsConfig';\nimport {FlagsControllerD} from '../utils/FlagsController';\nimport {isPromise} from '../../../core/Type';\n\nexport abstract class TypedLightObjNode<L extends Object3D, K extends NodeParamsConfig> extends TypedObjNode<Group, K> {\n\tpublic override readonly flags: FlagsControllerD = new FlagsControllerD(this);\n\tpublic override readonly renderOrder: number = ObjNodeRenderOrder.LIGHT;\n\tprotected _light!: L;\n\tget light() {\n\t\treturn this._light;\n\t}\n\tprotected abstract createLight(): L;\n\tprotected override _usedInScene: boolean = true;\n\toverride initializeBaseNode() {\n\t\tsuper.initializeBaseNode();\n\n\t\tthis._light = this.createLight();\n\t\tthis.object.add(this._light);\n\t\tthis.flags.display.onUpdate(() => {\n\t\t\tthis._updateLightAttachment();\n\t\t});\n\t\tthis.dirtyController.addPostDirtyHook(\n\t\t\t'_cook_main_without_inputs_when_dirty',\n\t\t\tthis._cook_main_without_inputs_when_dirty_bound\n\t\t);\n\t}\n\t// TODO: I may be able to swap those methods to param callbacks for most params\n\tprivate _cook_main_without_inputs_when_dirty_bound = this._cook_main_without_inputs_when_dirty.bind(this);\n\tprivate async _cook_main_without_inputs_when_dirty() {\n\t\t// if (this.used_in_scene) {\n\t\tawait this.cookController.cookMainWithoutInputs();\n\t\t// }\n\t}\n\n\tprotected override set_object_name() {\n\t\tsuper.set_object_name();\n\t\tif (this._light) {\n\t\t\tthis._light.name = `${this.path()}:light`;\n\t\t}\n\t}\n\n\tprivate _updateLightAttachment() {\n\t\tif (this.flags.display.active()) {\n\t\t\tthis.object.add(this.light);\n\t\t\tthis._cook_main_without_inputs_when_dirty();\n\t\t} else {\n\t\t\tthis.object.remove(this.light);\n\t\t}\n\t}\n\n\toverride async cook() {\n\t\tthis.updateShadowParams();\n\t\tconst result = this.updateLightParams();\n\t\tif (isPromise(result)) {\n\t\t\tawait result;\n\t\t}\n\t\tthis.cookController.endCook();\n\t}\n\n\tprotected updateLightParams(): void | Promise<void> {}\n\tprotected updateShadowParams(): void {}\n}\n\nexport type BaseLightObjNodeType = TypedLightObjNode<Object3D, NodeParamsConfig>;\n// export class BaseLightObjNodeClass extends TypedLightObjNode<Light, NodeParamsConfig> {}\n","import {TypedLightObjNode} from './_BaseLight';\nimport {Object3D} from 'three';\n// import {CoreTransform} from '../../../core/Transform';\nimport {NodeParamsConfig} from '../utils/params/ParamsConfig';\nimport {TransformController, TransformedParamConfig} from './utils/TransformController';\nimport {FlagsControllerD} from '../utils/FlagsController';\nimport {HierarchyController} from './utils/HierarchyController';\nimport {isPromise} from '../../../core/Type';\n\n// import {Transformed} from './Concerns/Transformed';\nclass TransformedObjParamConfig extends TransformedParamConfig(NodeParamsConfig) {}\n\nexport abstract class BaseLightTransformedObjNode<\n\tL extends Object3D,\n\tK extends TransformedObjParamConfig\n> extends TypedLightObjNode<L, K> {\n\tpublic override readonly flags: FlagsControllerD = new FlagsControllerD(this);\n\toverride readonly hierarchyController: HierarchyController = new HierarchyController(this);\n\toverride readonly transformController: TransformController = new TransformController(this);\n\n\toverride initializeBaseNode() {\n\t\tsuper.initializeBaseNode();\n\t\tthis.hierarchyController.initializeNode();\n\t\tthis.transformController.initializeNode();\n\t}\n\n\toverride async cook() {\n\t\tthis.transformController.update();\n\t\tthis.updateShadowParams();\n\t\tconst result = this.updateLightParams();\n\t\tif (isPromise(result)) {\n\t\t\tawait result;\n\t\t}\n\t\tthis.cookController.endCook();\n\t}\n}\n","import {TypedObjNode} from './_Base';\nimport {Group} from 'three';\n\nimport {NodeParamsConfig} from '../utils/params/ParamsConfig';\nexport class BaseManagerObjNode<K extends NodeParamsConfig> extends TypedObjNode<Group, K> {\n\tprotected override _attachableToHierarchy: boolean = false;\n\n\toverride createObject() {\n\t\tconst group = new Group();\n\t\tgroup.matrixAutoUpdate = false;\n\t\treturn group;\n\t}\n\n\toverride cook() {\n\t\tthis.cookController.endCook();\n\t}\n}\n\nclass ParamLessObjParamsConfig extends NodeParamsConfig {}\nexport class ParamLessBaseManagerObjNode extends BaseManagerObjNode<ParamLessObjParamsConfig> {}\n","/**\n * Adds an Unreal Bloom effect.\n *\n *\n */\nimport {SelectionController} from './utils/SelectionController';\nimport {Vector2} from 'three';\nimport {TypedPostNode, TypedPostNodeContext, PostParamOptions} from './_Base';\nimport {NodeParamsConfig, ParamConfig} from '../utils/params/ParamsConfig';\nimport {\n\tBlendFunction,\n\tSelectiveBloomEffect,\n\tBloomEffect,\n\tEffectPass,\n\tKernelSize,\n\tBloomEffectOptions,\n} from 'postprocessing';\nimport {KERNEL_SIZES, KERNEL_SIZE_MENU_OPTIONS} from '../../../core/post/KernelSize';\nimport {BLEND_FUNCTION_MENU_OPTIONS} from './../../../core/post/BlendFunction';\nimport {isBooleanTrue} from '../../../core/Type';\nclass BloomPostParamsConfig extends NodeParamsConfig {\n\t/** @param defines if this node applies a bloom to the whole scene or just a selection. Note that for now, it is necessary to reload your scene when toggling this parameter */\n\tuseObjectMask = ParamConfig.BOOLEAN(0, {\n\t\t...PostParamOptions,\n\t});\n\t/** @param object mask of the objects that will be used for the bloom */\n\tobjectsMask = ParamConfig.STRING('*bloomed*', {\n\t\t...PostParamOptions,\n\t\tobjectMask: true,\n\t\tvisibleIf: {useObjectMask: 1},\n\t});\n\t/** @param updates the cached objects found by objectMask  */\n\trefreshObjects = ParamConfig.BUTTON(null, {\n\t\t...PostParamOptions,\n\t\tvisibleIf: {useObjectMask: 1},\n\t});\n\t/** @param effect strength */\n\tstrength = ParamConfig.FLOAT(1.5, {\n\t\trange: [0, 3],\n\t\trangeLocked: [true, false],\n\t\t...PostParamOptions,\n\t});\n\t/** @param effect threshold */\n\tthreshold = ParamConfig.FLOAT(1, {\n\t\t...PostParamOptions,\n\t});\n\t/** @param effect scale */\n\tscale = ParamConfig.FLOAT(1, {\n\t\trange: [0, 3],\n\t\trangeLocked: [true, false],\n\t\t...PostParamOptions,\n\t});\n\t/** @param effect radius */\n\t// radius = ParamConfig.FLOAT(1, {\n\t// \t...PostParamOptions,\n\t// });\n\t/** @param kernel size */\n\tkernelSize = ParamConfig.INTEGER(KernelSize.LARGE, {\n\t\t...PostParamOptions,\n\t\t...KERNEL_SIZE_MENU_OPTIONS,\n\t});\n\t/** @param effect luminance Smoothing */\n\tluminanceSmoothing = ParamConfig.FLOAT(0.1, {\n\t\t...PostParamOptions,\n\t});\n\t/** @param resolutionScale */\n\tresolutionScale = ParamConfig.FLOAT(0.5, {\n\t\t...PostParamOptions,\n\t});\n\t/** @param opacity */\n\topacity = ParamConfig.FLOAT(1, {\n\t\trange: [0, 1],\n\t\trangeLocked: [true, false],\n\t\t...PostParamOptions,\n\t});\n\t/** @param render mode */\n\tblendFunction = ParamConfig.INTEGER(BlendFunction.SCREEN, {\n\t\t...PostParamOptions,\n\t\t...BLEND_FUNCTION_MENU_OPTIONS,\n\t});\n\n\t/** @param bloom only */\n\t// bloomOnly = ParamConfig.BOOLEAN(0, {\n\t// \t...PostParamOptions,\n\t// });\n}\nconst ParamsConfig = new BloomPostParamsConfig();\nexport class BloomPostNode extends TypedPostNode<EffectPass, BloomPostParamsConfig> {\n\toverride paramsConfig = ParamsConfig;\n\tstatic override type() {\n\t\treturn 'bloom';\n\t}\n\n\tprivate _rendererSize = new Vector2();\n\toverride createPass(context: TypedPostNodeContext) {\n\t\tcontext.renderer.getSize(this._rendererSize);\n\t\tconst bloomEffectOptions: BloomEffectOptions = {\n\t\t\tblendFunction: BlendFunction.SCREEN,\n\t\t\tkernelSize: KERNEL_SIZES[this.pv.kernelSize],\n\t\t\tluminanceThreshold: this.pv.threshold,\n\t\t\tluminanceSmoothing: this.pv.luminanceSmoothing,\n\t\t\tresolutionScale: this.pv.resolutionScale,\n\t\t\t// height: 480,\n\t\t};\n\t\tconst bloomEffect = isBooleanTrue(this.pv.useObjectMask)\n\t\t\t? new SelectiveBloomEffect(context.scene, context.camera, bloomEffectOptions)\n\t\t\t: new BloomEffect(bloomEffectOptions);\n\t\tconst pass = new EffectPass(context.camera, bloomEffect);\n\t\tthis.updatePass(pass);\n\t\treturn pass;\n\t}\n\toverride updatePass(pass: EffectPass) {\n\t\tconst effect = (pass as any).effects[0] as BloomEffect;\n\t\teffect.blendMode.opacity.value = this.pv.opacity;\n\t\teffect.blendMode.blendFunction = this.pv.blendFunction;\n\n\t\teffect.intensity = this.pv.strength;\n\t\teffect.luminanceMaterial.threshold = this.pv.threshold;\n\t\teffect.luminanceMaterial.smoothing = this.pv.luminanceSmoothing;\n\t\t(effect.blurPass.blurMaterial as any).kernelSize = KERNEL_SIZES[this.pv.kernelSize];\n\t\teffect.blurPass.resolution.scale = this.pv.resolutionScale;\n\t\teffect.blurPass.scale = this.pv.scale;\n\t\tthis._setSelectedObjects(effect);\n\t}\n\tprivate __selectionController: SelectionController | undefined;\n\tprivate _selectionController() {\n\t\treturn (this.__selectionController = this.__selectionController || new SelectionController());\n\t}\n\tprivate _setSelectedObjects(effect: SelectiveBloomEffect | BloomEffect) {\n\t\tif (effect instanceof SelectiveBloomEffect && isBooleanTrue(this.pv.useObjectMask)) {\n\t\t\tthis._selectionController().updateSelection(this.scene(), this.pv.objectsMask, effect.selection);\n\t\t}\n\t}\n}\n","/**\n * Creates an outline\n *\n *\n */\nimport {SelectionController} from './utils/SelectionController';\nimport {BLEND_FUNCTION_MENU_OPTIONS} from './../../../core/post/BlendFunction';\nimport {TypedPostNode, TypedPostNodeContext, PostParamOptions} from './_Base';\nimport {NodeParamsConfig, ParamConfig} from '../utils/params/ParamsConfig';\nimport {BlendFunction, EffectPass, KernelSize, OutlineEffect} from 'postprocessing';\nimport {KERNEL_SIZE_MENU_OPTIONS} from '../../../core/post/KernelSize';\nclass OutlinePostParamsConfig extends NodeParamsConfig {\n\t/** @param object mask of the objects that will have an outline */\n\tobjectsMask = ParamConfig.STRING('*outlined*', {\n\t\t...PostParamOptions,\n\t\tobjectMask: true,\n\t});\n\t/** @param updates the cached objects found by objectMask  */\n\trefreshObjects = ParamConfig.BUTTON(null, {\n\t\t...PostParamOptions,\n\t});\n\t/** @param edgeStrenth */\n\tedgeStrength = ParamConfig.FLOAT(3, {\n\t\trange: [0, 10],\n\t\trangeLocked: [true, false],\n\t\t...PostParamOptions,\n\t});\n\t/** @param blur */\n\tblur = ParamConfig.BOOLEAN(0, {\n\t\t...PostParamOptions,\n\t});\n\tkernelSize = ParamConfig.INTEGER(KernelSize.VERY_SMALL, {\n\t\t...PostParamOptions,\n\t\t...KERNEL_SIZE_MENU_OPTIONS,\n\t\tvisibleIf: {blur: 1},\n\t});\n\n\t/** @param defines if the edges pulsate */\n\tpulseSpeed = ParamConfig.FLOAT(0, {\n\t\trange: [0, 5],\n\t\trangeLocked: [true, false],\n\t\t...PostParamOptions,\n\t});\n\t/** @param visibleEdgeColor */\n\tvisibleEdgeColor = ParamConfig.COLOR([1, 1, 1], {\n\t\t...PostParamOptions,\n\t});\n\t/** @param shows outline for hidden parts of objects */\n\txRay = ParamConfig.BOOLEAN(1, {\n\t\t...PostParamOptions,\n\t});\n\t/** @param hiddenEdgeColor */\n\thiddenEdgeColor = ParamConfig.COLOR([0.2, 0.1, 0.4], {\n\t\t...PostParamOptions,\n\t\tvisibleIf: {xRay: 1},\n\t});\n\t/** @param opacity */\n\topacity = ParamConfig.FLOAT(1, {\n\t\trange: [0, 1],\n\t\trangeLocked: [true, false],\n\t\t...PostParamOptions,\n\t});\n\t/** @param render mode */\n\tblendFunction = ParamConfig.INTEGER(BlendFunction.SCREEN, {\n\t\t...PostParamOptions,\n\t\t...BLEND_FUNCTION_MENU_OPTIONS,\n\t});\n}\nconst ParamsConfig = new OutlinePostParamsConfig();\nexport class OutlinePostNode extends TypedPostNode<EffectPass, OutlinePostParamsConfig> {\n\toverride paramsConfig = ParamsConfig;\n\tstatic override type() {\n\t\treturn 'outline';\n\t}\n\n\t// private _rendererSize = new Vector2();\n\toverride createPass(context: TypedPostNodeContext) {\n\t\tconst effect = new OutlineEffect(context.scene, context.camera, {\n\t\t\tblendFunction: BlendFunction.SCREEN,\n\t\t\tpatternScale: 40,\n\t\t\tvisibleEdgeColor: 0xffffff,\n\t\t\thiddenEdgeColor: 0x22090a,\n\t\t\theight: 480,\n\t\t\tblur: false,\n\t\t\txRay: true,\n\t\t});\n\t\teffect.selection.add(context.scene.children[0]);\n\t\t// context.renderer.getSize(this._rendererSize);\n\t\tconst pass = new EffectPass(context.camera, effect);\n\t\tthis.updatePass(pass);\n\t\treturn pass;\n\t}\n\toverride updatePass(pass: EffectPass) {\n\t\tconst effect = (pass as any).effects[0] as OutlineEffect;\n\t\teffect.blendMode.opacity.value = this.pv.opacity;\n\t\teffect.blendMode.blendFunction = this.pv.blendFunction;\n\n\t\teffect.edgeStrength = this.pv.edgeStrength;\n\t\teffect.blur = this.pv.blur;\n\t\teffect.kernelSize = this.pv.kernelSize;\n\t\teffect.xRay = this.pv.xRay;\n\t\teffect.pulseSpeed = this.pv.pulseSpeed;\n\t\teffect.visibleEdgeColor = this.pv.visibleEdgeColor;\n\t\teffect.hiddenEdgeColor = this.pv.hiddenEdgeColor;\n\t\tthis._setSelectedObjects(effect);\n\t}\n\tprivate _selectionController = new SelectionController();\n\tprivate _setSelectedObjects(effect: OutlineEffect) {\n\t\tthis._selectionController.updateSelection(this.scene(), this.pv.objectsMask, effect.selection);\n\t}\n}\n","/**\n * A subnet to create POST PROCESS nodes\n *\n */\nimport {Constructor, valueof} from '../../../types/GlobalTypes';\nimport {BaseNetworkPostNode} from './_BaseManager';\nimport {NetworkNodeType, NodeContext} from '../../poly/NodeContext';\nimport {PostNodeChildrenMap} from '../../poly/registers/nodes/Post';\nimport {BasePostProcessNodeType} from './_Base';\nimport {DisplayNodeController} from '../utils/DisplayNodeController';\nimport {EffectComposerController, PostProcessNetworkParamsConfig} from './utils/EffectComposerController';\nimport {NodeCreateOptions} from '../utils/hierarchy/ChildrenController';\n\nexport class PostProcessNetworkPostNode extends BaseNetworkPostNode<PostProcessNetworkParamsConfig> {\n\toverride paramsConfig = new PostProcessNetworkParamsConfig();\n\tstatic override type() {\n\t\treturn NetworkNodeType.POST;\n\t}\n\treadonly effectsComposerController: EffectComposerController = new EffectComposerController(this);\n\tpublic override readonly displayNodeController: DisplayNodeController = new DisplayNodeController(\n\t\tthis,\n\t\tthis.effectsComposerController.displayNodeControllerCallbacks()\n\t);\n\n\tprotected override _childrenControllerContext = NodeContext.POST;\n\n\toverride createNode<S extends keyof PostNodeChildrenMap>(\n\t\tnode_class: S,\n\t\toptions?: NodeCreateOptions\n\t): PostNodeChildrenMap[S];\n\toverride createNode<K extends valueof<PostNodeChildrenMap>>(\n\t\tnode_class: Constructor<K>,\n\t\toptions?: NodeCreateOptions\n\t): K;\n\toverride createNode<K extends valueof<PostNodeChildrenMap>>(\n\t\tnode_class: Constructor<K>,\n\t\toptions?: NodeCreateOptions\n\t): K {\n\t\treturn super.createNode(node_class, options) as K;\n\t}\n\toverride children() {\n\t\treturn super.children() as BasePostProcessNodeType[];\n\t}\n\toverride nodesByType<K extends keyof PostNodeChildrenMap>(type: K): PostNodeChildrenMap[K][] {\n\t\treturn super.nodesByType(type) as PostNodeChildrenMap[K][];\n\t}\n}\n","/**\n * creates a render pass\n *\n *\n */\nimport {TypedPostNode, TypedPostNodeContext, PostParamOptions} from './_Base';\nimport {RenderPass} from 'postprocessing';\nimport {NodeParamsConfig, ParamConfig} from '../utils/params/ParamsConfig';\nimport {NodeContext} from '../../poly/NodeContext';\nimport {SceneObjNode} from '../obj/Scene';\nimport {Scene} from 'three';\nimport {Camera} from 'three';\nimport {isBooleanTrue} from '../../../core/BooleanValue';\n\ninterface RenderPassContext {\n\tcamera: Camera;\n\tscene: Scene;\n}\nclass RenderPassWithContext extends RenderPass {\n\tpublic context: RenderPassContext;\n\tconstructor(public override scene: Scene, public override camera: Camera) {\n\t\tsuper(scene, camera);\n\t\tthis.context = {scene, camera};\n\t}\n}\nclass RenderPostParamsConfig extends NodeParamsConfig {\n\t/** @param overrideScene */\n\toverrideScene = ParamConfig.BOOLEAN(0, PostParamOptions);\n\t/** @param scene */\n\tscene = ParamConfig.NODE_PATH('', {\n\t\tvisibleIf: {overrideScene: 1},\n\t\tnodeSelection: {\n\t\t\tcontext: NodeContext.OBJ,\n\t\t\ttypes: [SceneObjNode.type()],\n\t\t},\n\t\t...PostParamOptions,\n\t});\n\t/** @param overrideCamera */\n\toverrideCamera = ParamConfig.BOOLEAN(0, PostParamOptions);\n\t/** @param camera */\n\tcamera = ParamConfig.STRING('', {\n\t\tvisibleIf: {overrideCamera: 1},\n\t\t// nodeSelection: {\n\t\t// \tcontext: NodeContext.OBJ,\n\t\t// \ttypes: CAMERA_TYPES,\n\t\t// },\n\t\t// cook: false,\n\t\t// separatorBefore: true,\n\t\tobjectMask: true,\n\t\t...PostParamOptions,\n\t});\n\t// clear_color = ParamConfig.COLOR([0, 0, 0]);\n\t// clear_alpha = ParamConfig.FLOAT(0);\n\t// clear_depth = ParamConfig.BOOLEAN(0);\n}\nconst ParamsConfig = new RenderPostParamsConfig();\nexport class RenderPostNode extends TypedPostNode<RenderPass, RenderPostParamsConfig> {\n\toverride paramsConfig = ParamsConfig;\n\tstatic override type() {\n\t\treturn 'render';\n\t}\n\n\toverride createPass(context: TypedPostNodeContext) {\n\t\tconst pass = new RenderPass(context.scene, context.camera) as RenderPassWithContext;\n\n\t\tpass.context = {\n\t\t\tcamera: context.camera,\n\t\t\tscene: context.scene,\n\t\t};\n\t\tthis.updatePass(pass);\n\t\treturn pass;\n\t}\n\n\toverride updatePass(pass: RenderPassWithContext) {\n\t\tthis._updateCamera(pass);\n\t\tthis._updateScene(pass);\n\t}\n\n\tprotected async _updateCamera(pass: RenderPassWithContext) {\n\t\tif (isBooleanTrue(this.pv.overrideCamera)) {\n\t\t\tif (this.p.camera.isDirty()) {\n\t\t\t\tawait this.p.camera.compute();\n\t\t\t}\n\t\t\tconst path = this.pv.camera;\n\t\t\tconst object = this.scene().objectsController.findObjectByMask(path) as Camera | undefined;\n\t\t\tif (object) {\n\t\t\t\tpass.camera = object;\n\t\t\t}\n\t\t} else {\n\t\t\tpass.camera = pass.context.camera;\n\t\t}\n\t}\n\n\tprotected async _updateScene(pass: RenderPassWithContext) {\n\t\tif (isBooleanTrue(this.pv.overrideScene)) {\n\t\t\tif (this.p.scene.isDirty()) {\n\t\t\t\tawait this.p.scene.compute();\n\t\t\t}\n\t\t\tconst objNode = this.pv.scene.nodeWithContext(NodeContext.OBJ);\n\t\t\tif (objNode) {\n\t\t\t\tif (objNode.type() == SceneObjNode.type()) {\n\t\t\t\t\tconst scene = (objNode as SceneObjNode).object;\n\t\t\t\t\tpass.scene = scene;\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tpass.scene = pass.context.scene;\n\t\t}\n\t}\n}\n","/**\n * Adds tonemapping.\n *\n *\n */\nimport {Vector2} from 'three';\nimport {TypedPostNode, TypedPostNodeContext, PostParamOptions} from './_Base';\nimport {NodeParamsConfig, ParamConfig} from '../utils/params/ParamsConfig';\nimport {BlendFunction, ToneMappingEffect, EffectPass, ToneMappingMode} from 'postprocessing';\n\nenum ToneMappingModeStr {\n\tREINHARD = 'REINHARD',\n\tREINHARD2 = 'REINHARD2',\n\tREINHARD2_ADAPTIVE = 'REINHARD2_ADAPTIVE',\n\tOPTIMIZED_CINEON = 'OPTIMIZED_CINEON',\n\tACES_FILMIC = 'ACES_FILMIC',\n\tUNCHARTED2 = 'UNCHARTED2',\n}\nconst TONE_MAPPING_MODES: ToneMappingModeStr[] = [\n\tToneMappingModeStr.REINHARD,\n\tToneMappingModeStr.REINHARD2,\n\tToneMappingModeStr.REINHARD2_ADAPTIVE,\n\tToneMappingModeStr.OPTIMIZED_CINEON,\n\tToneMappingModeStr.ACES_FILMIC,\n\tToneMappingModeStr.UNCHARTED2,\n];\nconst REMAPPED_TONE_MAPPING: Record<ToneMappingModeStr, ToneMappingMode> = {\n\t[ToneMappingModeStr.REINHARD]: ToneMappingMode.REINHARD,\n\t[ToneMappingModeStr.REINHARD2]: ToneMappingMode.REINHARD2,\n\t[ToneMappingModeStr.REINHARD2_ADAPTIVE]: ToneMappingMode.REINHARD2_ADAPTIVE,\n\t[ToneMappingModeStr.OPTIMIZED_CINEON]: ToneMappingMode.OPTIMIZED_CINEON,\n\t[ToneMappingModeStr.ACES_FILMIC]: ToneMappingMode.ACES_FILMIC,\n\t[ToneMappingModeStr.UNCHARTED2]: ToneMappingMode.UNCHARTED2,\n};\n\ninterface ToneMappingEffectOptions {\n\tblendFunction?: BlendFunction;\n\tadaptive?: boolean;\n\tmode?: ToneMappingMode;\n\tresolution?: number;\n\tmaxLuminance?: number;\n\twhitePoint?: number;\n\tmiddleGrey?: number;\n\tminLuminance?: number;\n\taverageLuminance?: number;\n\tadaptationRate?: number;\n}\n\nclass ToneMappingPostParamsConfig extends NodeParamsConfig {\n\t/** @param mode */\n\tmode = ParamConfig.INTEGER(TONE_MAPPING_MODES.indexOf(ToneMappingModeStr.ACES_FILMIC), {\n\t\tmenu: {\n\t\t\tentries: TONE_MAPPING_MODES.map((name, value) => ({name, value})),\n\t\t},\n\t\t...PostParamOptions,\n\t});\n\t/** @param adaptive */\n\tadaptive = ParamConfig.BOOLEAN(0, {\n\t\t...PostParamOptions,\n\t});\n}\nconst ParamsConfig = new ToneMappingPostParamsConfig();\nexport class ToneMappingPostNode extends TypedPostNode<EffectPass, ToneMappingPostParamsConfig> {\n\toverride paramsConfig = ParamsConfig;\n\tstatic override type() {\n\t\treturn 'toneMapping';\n\t}\n\n\tprivate _rendererSize = new Vector2();\n\toverride createPass(context: TypedPostNodeContext) {\n\t\tcontext.renderer.getSize(this._rendererSize);\n\t\tconst toneMappingEffectOptions: ToneMappingEffectOptions = {\n\t\t\tmode: this.toneMapping(),\n\t\t};\n\t\tconst bloomEffect = new ToneMappingEffect(toneMappingEffectOptions);\n\t\tconst pass = new EffectPass(context.camera, bloomEffect);\n\t\tthis.updatePass(pass);\n\t\treturn pass;\n\t}\n\toverride updatePass(pass: EffectPass) {\n\t\tconst effect = (pass as any).effects[0] as ToneMappingEffect;\n\n\t\teffect.mode = this.toneMapping();\n\t}\n\ttoneMapping() {\n\t\treturn REMAPPED_TONE_MAPPING[TONE_MAPPING_MODES[this.pv.mode]];\n\t}\n}\n","import {CopyPass} from 'postprocessing';\nimport {WebGLRenderer, WebGLRenderTarget} from 'three';\nimport {isBooleanTrue} from '../../../../../core/Type';\n// import FRAGMENT from '../../gl/passThrough.glsl';\nimport {UpdateScenePostNode} from '../../UpdateScene';\n\ninterface UpdateSceneEffectOptions {\n\t// scene: PolyScene;\n\treset: boolean;\n\tnode: UpdateScenePostNode;\n\tnodeToReset?: UpdateScenePostNode;\n\t// objectsMask: string;\n\t// invertMask: boolean;\n\t// setMatteMaterial: boolean;\n\t// setVisible: boolean;\n\t// visible: boolean;\n}\n\nexport class UpdateScenePass extends CopyPass {\n\t// public override needsSwap = false;\n\t// public updatesRender = false;\n\t// private _scene: PolyScene;\n\tpublic reset: boolean;\n\tpublic node: UpdateScenePostNode;\n\tpublic nodeToReset?: UpdateScenePostNode;\n\t// public objectsMask: string;\n\t// public invertMask: boolean;\n\t// public setMatteMaterial: boolean;\n\t// public setVisible: boolean;\n\t// public visible: boolean;\n\tconstructor(options: UpdateSceneEffectOptions) {\n\t\t// const applyChanges = () => options.node.applyChanges();\n\t\t// const resetChanges = () => {\n\t\t// \tif (options.nodeToReset) {\n\t\t// \t\toptions.nodeToReset.applyChanges();\n\t\t// \t} else {\n\t\t// \t\tconsole.warn('reset is true, but no passToReset is given', options.node);\n\t\t// \t}\n\t\t// };\n\t\t// const f = isBooleanTrue(options.reset) ? resetChanges : applyChanges;\n\t\tsuper();\n\t\t// this._scene = options.scene;\n\t\tthis.reset = options.reset;\n\t\tthis.node = options.node;\n\t\tthis.nodeToReset = options.nodeToReset;\n\t\t// this.objectsMask = options.objectsMask;\n\t\t// this.invertMask = options.invertMask;\n\t\t// this.setMatteMaterial = options.setMatteMaterial;\n\t\t// this.setVisible = options.setVisible;\n\t\t// this.visible = options.visible;\n\t}\n\t// private _onRenderBound = this._onRender.bind(this)\n\t// private _onRender(){\n\n\t// }\n\toverride render(\n\t\trenderer: WebGLRenderer,\n\t\tinputBuffer: WebGLRenderTarget,\n\t\toutputBuffer: WebGLRenderTarget,\n\t\tdeltaTime?: number,\n\t\tstencilTest?: boolean\n\t) {\n\t\tif (isBooleanTrue(this.reset)) {\n\t\t\tif (this.nodeToReset) {\n\t\t\t\tthis.nodeToReset.resetChanges();\n\t\t\t} else {\n\t\t\t\tconsole.warn('reset is true, but no passToReset is given');\n\t\t\t}\n\t\t} else {\n\t\t\tthis.node.applyChanges();\n\t\t}\n\t\t// console.warn(deltaTime, this);\n\t\tsuper.render(renderer, inputBuffer, outputBuffer, deltaTime, stencilTest);\n\t}\n\n\t// override update(renderer: WebGLRenderer, inputBuffer: WebGLRenderTarget, deltaTime: number) {\n\t// \tif (isBooleanTrue(this.reset)) {\n\t// \t\tif (this.nodeToReset) {\n\t// \t\t\tthis.nodeToReset.resetChanges();\n\t// \t\t} else {\n\t// \t\t\tconsole.warn('reset is true, but no passToReset is given');\n\t// \t\t}\n\t// \t} else {\n\t// \t\tthis.node.applyChanges();\n\t// \t}\n\t// \t// console.warn(deltaTime, this);\n\t// \tsuper.update(renderer, inputBuffer, deltaTime);\n\t// }\n\t// private _updateObjectBound = this._updateObject.bind(this);\n\t// private _updateObject(obj: Object3D) {\n\t// \tthis._objectsList.push(obj);\n\t// \tif (isBooleanTrue(this.setMatteMaterial)) {\n\t// \t\tconst mesh = obj as Mesh;\n\t// \t\tif (mesh.material) {\n\t// \t\t\tthis._materialByMesh.set(mesh, mesh.material);\n\t// \t\t\tmesh.material = MATTE_MATERIAL;\n\t// \t\t}\n\t// \t}\n\t// \tif (isBooleanTrue(this.setVisible)) {\n\t// \t\tif (obj.visible != this.visible) {\n\t// \t\t\tthis._visibleByObject.set(obj, obj.visible);\n\t// \t\t\tobj.visible = this.visible;\n\t// \t\t\tconsole.log(obj, obj.visible);\n\t// \t\t}\n\t// \t}\n\t// }\n}\n","/**\n * Update a scene before some passes are rendered\n *\n * @remarks\n * The node can also be provided a second input, which has to be an UpdateScene post node.\n * This node will then be able to reset the changes made by this node.\n *\n */\nimport {TypedPostNode, TypedPostNodeContext, PostParamOptions} from './_Base';\nimport {NodeParamsConfig, ParamConfig} from '../utils/params/ParamsConfig';\nimport {isBooleanTrue} from '../../../core/Type';\nimport {BaseNodeType} from '../_Base';\nimport {Mesh, Material, MeshBasicMaterial, Color} from 'three';\nimport {UpdateScenePass} from './utils/effects/UpdateScenePass';\nimport {CoreObjectType, ObjectContent} from '../../../core/geometry/ObjectContent';\nimport {PostType} from '../../poly/registers/nodes/types/Post';\n\nconst MATTE_MATERIAL = new MeshBasicMaterial({color: new Color(0, 0, 0)});\n\n// function _effectFromPass(effectPass: EffectPass): UpdateScenePass | undefined {\n// \tconst effect = (effectPass as any).effects[0];\n// \tif (effect instanceof UpdateScenePass) {\n// \t\treturn effect;\n// \t}\n// }\n\nclass UpdateScenePostParamsConfig extends NodeParamsConfig {\n\t/** @param reset */\n\treset = ParamConfig.BOOLEAN(0, {\n\t\t...PostParamOptions,\n\t});\n\t/** @param objects Mask */\n\tobjectsMask = ParamConfig.STRING('*', {\n\t\t...PostParamOptions,\n\t\tvisibleIf: {reset: 0},\n\t\tobjectMask: true,\n\t});\n\t/** @param invertMask */\n\tinvertMask = ParamConfig.BOOLEAN(0, {\n\t\t...PostParamOptions,\n\t\tvisibleIf: {reset: 0},\n\t});\n\t/** @param prints which objects are targeted by this node, for debugging */\n\t// printFoundObjectsFromMask = ParamConfig.BUTTON(null, {\n\t// \tvisibleIf: {reset: 0},\n\t// \tcallback: (node: BaseNodeType) => {\n\t// \t\tUpdateScenePostNode.PARAM_CALLBACK_printResolve(node as UpdateScenePostNode);\n\t// \t},\n\t// });\n\t/** @param update selected objects material to a matte one */\n\tsetMatteMaterial = ParamConfig.BOOLEAN(1, {\n\t\t...PostParamOptions,\n\t\tvisibleIf: {reset: 0},\n\t\tseparatorBefore: true,\n\t});\n\t/** @param set visible state  */\n\tsetVisible = ParamConfig.BOOLEAN(0, {\n\t\t...PostParamOptions,\n\t\tvisibleIf: {reset: 0},\n\t\tseparatorBefore: true,\n\t});\n\t/** @param set visible state  */\n\tvisible = ParamConfig.BOOLEAN(0, {\n\t\t...PostParamOptions,\n\t\tvisibleIf: {reset: 0, setVisible: 1},\n\t});\n\t/** @param reset */\n\tresetChanges = ParamConfig.BUTTON(null, {\n\t\tvisibleIf: {reset: 0},\n\t\tcallback: (node: BaseNodeType) => {\n\t\t\tUpdateScenePostNode.PARAM_CALLBACK_resetChanges(node as UpdateScenePostNode);\n\t\t},\n\t\tseparatorBefore: true,\n\t});\n\t/** @param material */\n\t// material = ParamConfig.NODE_PATH('', {\n\t// \t...PostParamOptions,\n\t// \tvisibleIf: {overrideMaterial: 1},\n\t// \tnodeSelection: {\n\t// \t\tcontext: NodeContext.MAT,\n\t// \t},\n\t// \tcallback: (node: BaseNodeType) => {\n\t// \t\tUpdateScenePostNode.PARAM_CALLBACK_updatePassesMaterial(node as UpdateScenePostNode);\n\t// \t},\n\t// });\n}\nconst ParamsConfig = new UpdateScenePostParamsConfig();\nexport class UpdateScenePostNode extends TypedPostNode<UpdateScenePass, UpdateScenePostParamsConfig> {\n\toverride paramsConfig = ParamsConfig;\n\tstatic override type() {\n\t\treturn PostType.UPDATE_SCENE;\n\t}\n\toverride initializeNode() {\n\t\tsuper.initializeNode();\n\t\tthis.io.inputs.setCount(0, 2);\n\t}\n\n\toverride createPass(context: TypedPostNodeContext) {\n\t\tconst pass = new UpdateScenePass({\n\t\t\t// scene: this.scene(),\n\t\t\tnode: this,\n\t\t\treset: isBooleanTrue(this.pv.reset),\n\t\t\tnodeToReset: this._nodeToReset(context),\n\t\t\t// objectsMask: this.pv.objectsMask,\n\t\t\t// invertMask: isBooleanTrue(this.pv.invertMask),\n\t\t\t// setMatteMaterial: isBooleanTrue(this.pv.setMatteMaterial),\n\t\t\t// setVisible: isBooleanTrue(this.pv.setVisible),\n\t\t\t// visible: isBooleanTrue(this.pv.visible),\n\t\t});\n\t\t// const pass = new EffectPass(context.camera, effect);\n\t\tthis.updatePass(pass);\n\n\t\treturn pass;\n\t}\n\toverride updatePass(pass: UpdateScenePass) {\n\t\t// const effect = _effectFromPass(pass);\n\t\t// if (!effect) {\n\t\t// \treturn;\n\t\t// }\n\t\t// pass.reset = isBooleanTrue(this.pv.reset);\n\t\t// effect.objectsMask = this.pv.objectsMask;\n\t\t// effect.invertMask = isBooleanTrue(this.pv.invertMask);\n\t\t// effect.setMatteMaterial = isBooleanTrue(this.pv.setMatteMaterial);\n\t\t// effect.setVisible = isBooleanTrue(this.pv.setVisible);\n\t\t// effect.visible = isBooleanTrue(this.pv.visible);\n\t}\n\tprivate _nodeToReset(context: TypedPostNodeContext): UpdateScenePostNode | undefined {\n\t\tconst input2 = this.io.inputs.input(1);\n\t\tif (!input2) {\n\t\t\treturn;\n\t\t}\n\t\tif (input2 instanceof UpdateScenePostNode) {\n\t\t\treturn input2;\n\t\t\t// const pass = context.composerController.passByNodeInBuildPassesProcess(input2) as EffectPass | undefined; //input2.passesByRequester(requester);\n\t\t\t// console.log(pass, pass ? _effectFromPass(pass) : undefined);\n\t\t\t// return pass ? _effectFromPass(pass) : undefined;\n\t\t}\n\t}\n\n\t// static PARAM_CALLBACK_printResolve(node: UpdateScenePostNode) {\n\t// \tnode._printResolve();\n\t// }\n\t// private _printResolve() {\n\t// \tlet firstPass: EffectPass | undefined;\n\t// \tthis._passesByEffectsComposer.forEach((passOrPasses) => {\n\t// \t\tconst passes = CoreType.isArray(passOrPasses) ? passOrPasses : [passOrPasses];\n\t// \t\tfirstPass = firstPass || passes[0];\n\t// \t});\n\t// \tif (firstPass) {\n\t// \t\tconst effect = _effectFromPass(firstPass);\n\t// \t\tif (effect) {\n\t// \t\t\tconsole.log(hhis.objectsList());\n\t// \t\t}\n\t// \t} else {\n\t// \t\tconsole.error(`no pass generated by this node, maybe it has not rendered yet?`);\n\t// \t}\n\t// }\n\tstatic PARAM_CALLBACK_resetChanges(node: UpdateScenePostNode) {\n\t\tnode.resetChanges();\n\t}\n\t// private _resetMat() {\n\t// \tthis._passesByEffectsComposer.forEach((passOrPasses) => {\n\t// \t\tconst passes = CoreType.isArray(passOrPasses) ? passOrPasses : [passOrPasses];\n\t// \t\tfor (let pass of passes) {\n\t// \t\t\tconst effect = _effectFromPass(pass);\n\t// \t\t\tif (effect) {\n\t// \t\t\t\teffect.resetChanges();\n\t// \t\t\t}\n\t// \t\t}\n\t// \t});\n\t// }\n\n\t// static PARAM_CALLBACK_updatePassesMaterial(node: UpdateScenePostNode) {\n\t// \tnode._updatePassesMaterial();\n\t// }\n\t// private _updatePassesMaterial() {\n\t// \tconst matNode = this.pv.material.nodeWithContext(NodeContext.MAT);\n\t// \tif (!matNode) {\n\t// \t\tthis._passes_by_requester_id.forEach((pass) => {\n\t// \t\t\tpass.material = undefined;\n\t// \t\t});\n\t// \t} else {\n\t// \t\tconst mat = matNode.material;\n\t// \t\tthis._passes_by_requester_id.forEach((pass) => {\n\t// \t\t\tpass.material = mat;\n\t// \t\t});\n\t// \t}\n\t// }\n\tprivate _objectsList: ObjectContent<CoreObjectType>[] = [];\n\tobjectsList() {\n\t\treturn this._objectsList;\n\t}\n\tprivate _materialByMesh: Map<Mesh, Material | Material[]> = new Map();\n\t// private _parentByObject: Map<Object3D, Object3D | null> = new Map();\n\tprivate _visibleByObject: Map<ObjectContent<CoreObjectType>, boolean> = new Map();\n\tapplyChanges() {\n\t\tconst changeNeeded = isBooleanTrue(this.pv.setMatteMaterial) || isBooleanTrue(this.pv.setVisible);\n\t\tif (changeNeeded) {\n\t\t\tthis._objectsList.length = 0;\n\t\t\tconst mask = this.pv.objectsMask;\n\t\t\tthis._scene.objectsController.traverseObjectsWithMask(\n\t\t\t\tmask,\n\t\t\t\tthis._updateObjectBound,\n\t\t\t\tundefined,\n\t\t\t\tthis.pv.invertMask\n\t\t\t);\n\t\t}\n\t}\n\tresetChanges() {\n\t\t// reset mat\n\t\tthis._materialByMesh.forEach((mat, mesh) => {\n\t\t\tmesh.material = mat;\n\t\t});\n\t\tthis._materialByMesh.clear();\n\t\t// reset visibility\n\t\t// this._parentByObject.forEach((parent, obj) => {\n\t\t// \tparent?.add(obj);\n\t\t// });\n\t\t// this._parentByObject.clear();\n\t\tthis._visibleByObject.forEach((visible, obj) => {\n\t\t\tobj.visible = visible;\n\t\t});\n\t\tthis._visibleByObject.clear();\n\t}\n\tprivate _updateObjectBound = this._updateObject.bind(this);\n\tprivate _updateObject(obj: ObjectContent<CoreObjectType>) {\n\t\tthis._objectsList.push(obj);\n\t\tif (isBooleanTrue(this.pv.setMatteMaterial)) {\n\t\t\tconst mesh = obj as Mesh;\n\t\t\tif (mesh.material) {\n\t\t\t\tthis._materialByMesh.set(mesh, mesh.material);\n\t\t\t\tmesh.material = MATTE_MATERIAL;\n\t\t\t}\n\t\t}\n\t\tif (isBooleanTrue(this.pv.setVisible)) {\n\t\t\tconst visible = this.pv.visible;\n\t\t\t// const parent = obj.parent;\n\t\t\t// const hasParent = parent != null;\n\t\t\tif (obj.visible != visible) {\n\t\t\t\t// this._parentByObject.set(obj, parent);\n\t\t\t\t// obj.removeFromParent();\n\t\t\t\t// obj.parent = null;\n\t\t\t\t// console.log('remove parent', obj);\n\t\t\t\tthis._visibleByObject.set(obj, obj.visible);\n\t\t\t\tobj.visible = visible;\n\t\t\t\t// console.log(obj, obj.visible);\n\t\t\t}\n\t\t}\n\t}\n}\n","import {NodeContext} from '../../poly/NodeContext';\nimport {NodeParamsConfig} from '../utils/params/ParamsConfig';\nimport {TypedNode} from '../_Base';\n\nclass ParamLessNetworkPostParamsConfig extends NodeParamsConfig {}\nexport class BaseNetworkPostNode<K extends NodeParamsConfig> extends TypedNode<NodeContext.POST, K> {\n\tstatic override context(): NodeContext {\n\t\treturn NodeContext.POST;\n\t}\n\toverride cook() {\n\t\tthis.cookController.endCook();\n\t}\n}\nexport class ParamLessBaseNetworkPostNode extends BaseNetworkPostNode<ParamLessNetworkPostParamsConfig> {}\n","import {PolyScene} from '../../../scene/PolyScene';\nimport {Selection} from 'postprocessing';\nimport {Object3D} from 'three';\n\nexport class SelectionController {\n\tprivate _map: Map<string, Object3D> = new Map();\n\tprivate _resolvedObjects: Object3D[] = [];\n\tupdateSelection(scene: PolyScene, objectsMask: string, selection: Selection) {\n\t\tconst foundObjects = scene.objectsByMask(objectsMask) as Object3D[];\n\n\t\t// Ensure that we only give the top most parents to the pass.\n\t\t// Meaning that if foundObjects contains a node A and one of its children B,\n\t\t// only A is given.\n\t\tthis._map.clear();\n\t\tfor (const object of foundObjects) {\n\t\t\tthis._map.set(object.uuid, object);\n\t\t}\n\t\tconst isAncestorNotInList = (object: Object3D) => {\n\t\t\tlet isAncestorInList = false;\n\t\t\tobject.traverseAncestors((ancestor) => {\n\t\t\t\tif (this._map.has(ancestor.uuid)) {\n\t\t\t\t\tisAncestorInList = true;\n\t\t\t\t}\n\t\t\t});\n\t\t\treturn !isAncestorInList;\n\t\t};\n\t\tthis._resolvedObjects = foundObjects.filter(isAncestorNotInList);\n\t\tselection.clear();\n\t\tfor (const object of this._resolvedObjects) {\n\t\t\tselection.add(object);\n\t\t}\n\t}\n}\n","/**\n * A subnet to create POST PROCESS nodes\n *\n */\nimport {Constructor, valueof} from '../../../types/GlobalTypes';\nimport {BaseNetworkRopNode} from './_BaseManager';\nimport {NetworkNodeType, NodeContext} from '../../poly/NodeContext';\nimport {PostNodeChildrenMap} from '../../poly/registers/nodes/Post';\nimport {BasePostProcessNodeType} from '../post/_Base';\nimport {DisplayNodeController} from '../utils/DisplayNodeController';\nimport {EffectComposerController, PostProcessNetworkParamsConfig} from '../post/utils/EffectComposerController';\nimport {NodeCreateOptions} from '../utils/hierarchy/ChildrenController';\n\nexport class PostProcessNetworkRopNode extends BaseNetworkRopNode<PostProcessNetworkParamsConfig> {\n\toverride paramsConfig = new PostProcessNetworkParamsConfig();\n\tstatic override type() {\n\t\treturn NetworkNodeType.POST;\n\t}\n\treadonly effectsComposerController: EffectComposerController = new EffectComposerController(this);\n\tpublic override readonly displayNodeController: DisplayNodeController = new DisplayNodeController(\n\t\tthis,\n\t\tthis.effectsComposerController.displayNodeControllerCallbacks()\n\t);\n\n\tprotected override _childrenControllerContext = NodeContext.POST;\n\n\toverride createNode<S extends keyof PostNodeChildrenMap>(\n\t\tnode_class: S,\n\t\toptions?: NodeCreateOptions\n\t): PostNodeChildrenMap[S];\n\toverride createNode<K extends valueof<PostNodeChildrenMap>>(\n\t\tnode_class: Constructor<K>,\n\t\toptions?: NodeCreateOptions\n\t): K;\n\toverride createNode<K extends valueof<PostNodeChildrenMap>>(\n\t\tnode_class: Constructor<K>,\n\t\toptions?: NodeCreateOptions\n\t): K {\n\t\treturn super.createNode(node_class, options) as K;\n\t}\n\toverride children() {\n\t\treturn super.children() as BasePostProcessNodeType[];\n\t}\n\toverride nodesByType<K extends keyof PostNodeChildrenMap>(type: K): PostNodeChildrenMap[K][] {\n\t\treturn super.nodesByType(type) as PostNodeChildrenMap[K][];\n\t}\n}\n","import {NodeContext} from '../../poly/NodeContext';\nimport {NodeParamsConfig} from '../utils/params/ParamsConfig';\nimport {TypedNode} from '../_Base';\n\nclass ParamLessNetworkRopParamsConfig extends NodeParamsConfig {}\nexport class BaseNetworkRopNode<K extends NodeParamsConfig> extends TypedNode<NodeContext.ROP, K> {\n\tstatic override context(): NodeContext {\n\t\treturn NodeContext.ROP;\n\t}\n\toverride cook() {\n\t\tthis.cookController.endCook();\n\t}\n}\nexport class ParamLessBaseNetworkRopNode extends BaseNetworkRopNode<ParamLessNetworkRopParamsConfig> {}\n","/**\n * Assigns actor nodes to input objects\n *\n *\n */\n\n// import {TypedSopNode} from './_Base';\nimport {CoreGroup} from '../../../core/geometry/Group';\nimport {NodeParamsConfig, ParamConfig} from '../utils/params/ParamsConfig';\nimport {NetworkNodeType} from '../../poly/NodeContext';\nimport {filterObjectsWithGroup} from '../../../core/geometry/Mask';\nimport {SopType} from '../../poly/registers/nodes/types/Sop';\nimport {TypedActorSopNode} from './_BaseActor';\nimport {isBooleanTrue} from '../../../core/Type';\nimport {ActorBuilderNode} from '../../scene/utils/ActorsManager';\nimport {InputCloneMode} from '../../poly/InputCloneMode';\nclass ActorSopParamsConfig extends NodeParamsConfig {\n\t/** @param select which objects this applies the actor behavior to */\n\tgroup = ParamConfig.STRING('', {\n\t\tobjectMask: true,\n\t});\n\t/** @param build actor from child nodes */\n\tuseThisNode = ParamConfig.BOOLEAN(1, {\n\t\tseparatorAfter: true,\n\t});\n\t/** @param actor node */\n\tnode = ParamConfig.NODE_PATH('', {\n\t\tvisibleIf: {useThisNode: 0},\n\t\tnodeSelection: {\n\t\t\ttypes: [NetworkNodeType.ACTOR],\n\t\t},\n\t\tdependentOnFoundNode: false,\n\t\tseparatorAfter: true,\n\t});\n}\nconst ParamsConfig = new ActorSopParamsConfig();\n\nexport class ActorSopNode extends TypedActorSopNode<ActorSopParamsConfig> {\n\toverride readonly paramsConfig = ParamsConfig;\n\tstatic override type() {\n\t\treturn SopType.ACTOR;\n\t}\n\n\tprotected override initializeNode() {\n\t\tthis.io.inputs.setCount(1);\n\t\tthis.io.inputs.initInputsClonedState(InputCloneMode.FROM_NODE);\n\t}\n\n\toverride async cook(inputCoreGroups: CoreGroup[]) {\n\t\t// compile\n\t\tthis.compilationController.compileIfRequired();\n\n\t\t//\n\t\tconst coreGroup = inputCoreGroups[0];\n\t\tconst objects = filterObjectsWithGroup(coreGroup, this.pv);\n\t\tconst actorNode = await this._findActorNode();\n\t\tif (actorNode) {\n\t\t\tfor (const object of objects) {\n\t\t\t\tthis.scene().actorsManager.assignActorBuilder(object, actorNode);\n\t\t\t}\n\t\t}\n\n\t\tthis.setCoreGroup(coreGroup);\n\t}\n\tprivate async _findActorNode() {\n\t\tif (isBooleanTrue(this.pv.useThisNode)) {\n\t\t\treturn this;\n\t\t} else {\n\t\t\tconst node = this.pv.node.node() as ActorBuilderNode | undefined;\n\t\t\tif (node) {\n\t\t\t\tawait node.compute();\n\t\t\t}\n\t\t\treturn node;\n\t\t}\n\t}\n}\n","/**\n * Assigns actor nodes to input objects\n *\n *\n */\n\nimport {CoreGroup} from '../../../core/geometry/Group';\nimport {NodeParamsConfig, ParamConfig} from '../utils/params/ParamsConfig';\nimport {NetworkNodeType} from '../../poly/NodeContext';\nimport {filterObjectsWithGroup} from '../../../core/geometry/Mask';\nimport {SopType} from '../../poly/registers/nodes/types/Sop';\nimport {TypedActorSopNode} from './_BaseActor';\nimport {isBooleanTrue} from '../../../core/Type';\nimport {ActorBuilderNode} from '../../scene/utils/ActorsManager';\nimport {InputCloneMode} from '../../poly/InputCloneMode';\nclass ActorInstanceSopParamsConfig extends NodeParamsConfig {\n\t/** @param select which objects this applies the actor behavior to */\n\tgroup = ParamConfig.STRING('', {\n\t\tobjectMask: true,\n\t});\n\t/** @param build actor from child nodes */\n\tuseThisNode = ParamConfig.BOOLEAN(1, {\n\t\tseparatorAfter: true,\n\t});\n\t/** @param actor node */\n\tnode = ParamConfig.NODE_PATH('', {\n\t\tvisibleIf: {useThisNode: 0},\n\t\tnodeSelection: {\n\t\t\ttypes: [NetworkNodeType.ACTOR],\n\t\t},\n\t\tdependentOnFoundNode: false,\n\t\tseparatorAfter: true,\n\t});\n}\nconst ParamsConfig = new ActorInstanceSopParamsConfig();\n\nexport class ActorInstanceSopNode extends TypedActorSopNode<ActorInstanceSopParamsConfig> {\n\toverride readonly paramsConfig = ParamsConfig;\n\tstatic override type() {\n\t\treturn SopType.ACTOR_INSTANCE;\n\t}\n\n\tprotected override initializeNode() {\n\t\tthis.io.inputs.setCount(1);\n\t\tthis.io.inputs.initInputsClonedState(InputCloneMode.FROM_NODE);\n\t}\n\n\toverride async cook(inputCoreGroups: CoreGroup[]) {\n\t\t// compile\n\t\tthis.compilationController.compileIfRequired();\n\n\t\t//\n\t\tconst coreGroup = inputCoreGroups[0];\n\t\tconst objects = filterObjectsWithGroup(coreGroup, this.pv);\n\t\tconst actorNode = await this._findActorNode();\n\t\tif (actorNode) {\n\t\t\tfor (const object of objects) {\n\t\t\t\tthis.scene().actorsManager.assignActorBuilder(object, actorNode);\n\t\t\t}\n\t\t}\n\n\t\tthis.setCoreGroup(coreGroup);\n\t}\n\tprivate async _findActorNode() {\n\t\tif (isBooleanTrue(this.pv.useThisNode)) {\n\t\t\treturn this;\n\t\t} else {\n\t\t\tconst node = this.pv.node.node() as ActorBuilderNode | undefined;\n\t\t\tif (node) {\n\t\t\t\tawait node.compute();\n\t\t\t}\n\t\t\treturn node;\n\t\t}\n\t}\n}\n","/**\n * Assigns actor nodes to input objects\n *\n *\n */\n\nimport {CoreGroup} from '../../../core/geometry/Group';\nimport {NodeParamsConfig, ParamConfig} from '../utils/params/ParamsConfig';\nimport {NetworkNodeType} from '../../poly/NodeContext';\nimport {filterObjectsWithGroup} from '../../../core/geometry/Mask';\nimport {SopType} from '../../poly/registers/nodes/types/Sop';\nimport {TypedActorSopNode} from './_BaseActor';\nimport {isBooleanTrue} from '../../../core/Type';\nimport {ActorBuilderNode} from '../../scene/utils/ActorsManager';\nimport {InputCloneMode} from '../../poly/InputCloneMode';\nclass ActorPointSopParamsConfig extends NodeParamsConfig {\n\t/** @param select which objects this applies the actor behavior to */\n\tgroup = ParamConfig.STRING('', {\n\t\tobjectMask: true,\n\t});\n\t/** @param build actor from child nodes */\n\tuseThisNode = ParamConfig.BOOLEAN(1, {\n\t\tseparatorAfter: true,\n\t});\n\t/** @param actor node */\n\tnode = ParamConfig.NODE_PATH('', {\n\t\tvisibleIf: {useThisNode: 0},\n\t\tnodeSelection: {\n\t\t\ttypes: [NetworkNodeType.ACTOR],\n\t\t},\n\t\tdependentOnFoundNode: false,\n\t\tseparatorAfter: true,\n\t});\n}\nconst ParamsConfig = new ActorPointSopParamsConfig();\n\nexport class ActorPointSopNode extends TypedActorSopNode<ActorPointSopParamsConfig> {\n\toverride readonly paramsConfig = ParamsConfig;\n\tstatic override type() {\n\t\treturn SopType.ACTOR_POINT;\n\t}\n\n\tprotected override initializeNode() {\n\t\tthis.io.inputs.setCount(1);\n\t\tthis.io.inputs.initInputsClonedState(InputCloneMode.FROM_NODE);\n\t}\n\n\toverride async cook(inputCoreGroups: CoreGroup[]) {\n\t\t// compile\n\t\tthis.compilationController.compileIfRequired();\n\n\t\t//\n\t\tconst coreGroup = inputCoreGroups[0];\n\t\tconst objects = filterObjectsWithGroup(coreGroup, this.pv);\n\t\tconst actorNode = await this._findActorNode();\n\t\tif (actorNode) {\n\t\t\t\tfor (const object of objects) {\n\t\t\t\t\tthis.scene().actorsManager.assignActorBuilder(object, actorNode);\n\t\t\t\t}\n\t\t}\n\n\t\tthis.setCoreGroup(coreGroup);\n\t}\n\tprivate async _findActorNode() {\n\t\tif (isBooleanTrue(this.pv.useThisNode)) {\n\t\t\treturn this;\n\t\t} else {\n\t\t\tconst node = this.pv.node.node() as ActorBuilderNode | undefined;\n\t\t\tif (node) {\n\t\t\t\tawait node.compute();\n\t\t\t}\n\t\t\treturn node;\n\t\t}\n\t}\n}\n","/**\n * Adds points or creates lines.\n *\n * @remarks\n * The add node can be used to add a single or multiple points.\n * If given points as input, it can also connect those points with a line.\n *\n */\n\nimport {TypedSopNode} from './_Base';\nimport {CoreGroup} from '../../../core/geometry/Group';\n\nimport {AddSopOperation} from '../../operations/sop/Add';\nimport {NodeParamsConfig, ParamConfig} from '../utils/params/ParamsConfig';\nimport {SopType} from '../../poly/registers/nodes/types/Sop';\nconst DEFAULT = AddSopOperation.DEFAULT_PARAMS;\nclass AddSopParamsConfig extends NodeParamsConfig {\n\t/** @param toggle to create points */\n\tcreatePoint = ParamConfig.BOOLEAN(DEFAULT.createPoint);\n\t/** @param define the number of points to create */\n\tpointsCount = ParamConfig.INTEGER(DEFAULT.pointsCount, {\n\t\trange: [1, 100],\n\t\trangeLocked: [true, false],\n\t\tvisibleIf: {createPoint: true},\n\t});\n\t/** @param the position of the created points */\n\tposition = ParamConfig.VECTOR3(DEFAULT.position, {visibleIf: {createPoint: true}});\n\t/** @param toggle on to connect the points from the input geometry */\n\tconnectInputPoints = ParamConfig.BOOLEAN(DEFAULT.connectInputPoints);\n\t/** @param check if the last point is connected */\n\tconnectToLastPoint = ParamConfig.BOOLEAN(DEFAULT.connectToLastPoint);\n}\nconst ParamsConfig = new AddSopParamsConfig();\n\nexport class AddSopNode extends TypedSopNode<AddSopParamsConfig> {\n\toverride paramsConfig = ParamsConfig;\n\tstatic override type() {\n\t\treturn SopType.ADD;\n\t}\n\n\toverride initializeNode() {\n\t\tthis.io.inputs.setCount(0, 1);\n\t}\n\n\tprivate _operation: AddSopOperation | undefined;\n\toverride cook(input_contents: CoreGroup[]) {\n\t\tthis._operation = this._operation || new AddSopOperation(this.scene(), this.states, this);\n\t\tconst core_group = this._operation.cook(input_contents, this.pv);\n\t\tthis.setCoreGroup(core_group);\n\t}\n}\n","/**\n * Creates an ambient light.\n *\n * @remarks\n * This is very similar to the [object level AmbientLight](https://polygonjs.com/docs/nodes/obj/AmbientLight), but can be more useful if you want to instanciate it or process it using other SOP nodes.\n *\n */\n\nimport {TypedSopNode} from './_Base';\nimport {CoreGroup} from '../../../core/geometry/Group';\n\nimport {NodeParamsConfig} from '../utils/params/ParamsConfig';\nimport {AmbientLightParamConfig} from '../../../core/lights/AmbientLight';\nimport {AmbientLightSopOperation} from '../../operations/sop/AmbientLight';\nclass AmbientLightSopParamsConfig extends AmbientLightParamConfig(NodeParamsConfig) {}\nconst ParamsConfig = new AmbientLightSopParamsConfig();\n\nexport class AmbientLightSopNode extends TypedSopNode<AmbientLightSopParamsConfig> {\n\toverride paramsConfig = ParamsConfig;\n\tstatic override type() {\n\t\treturn 'ambientLight';\n\t}\n\n\toverride initializeNode() {\n\t\tthis.io.inputs.setCount(0);\n\t}\n\n\tprivate _operation: AmbientLightSopOperation | undefined;\n\toverride cook(input_contents: CoreGroup[]) {\n\t\tthis._operation = this._operation || new AmbientLightSopOperation(this._scene, this.states, this);\n\t\tconst core_group = this._operation.cook(input_contents, this.pv);\n\t\tthis.setCoreGroup(core_group);\n\t}\n}\n","/**\n * Creates an area light.\n *\n * @remarks\n * This is very similar to the [object level AreaLight](https://polygonjs.com/docs/nodes/obj/AreaLight), but can be more useful if you want to instanciate it or process it using other SOP nodes.\n *\n */\n\nimport {TypedSopNode} from './_Base';\nimport {CoreGroup} from '../../../core/geometry/Group';\n\nimport {NodeParamsConfig} from '../utils/params/ParamsConfig';\nimport {AreaLightParamConfig} from '../../../core/lights/AreaLight';\nimport {AreaLightSopOperation} from '../../operations/sop/AreaLight';\nimport {LightType} from '../../poly/registers/nodes/types/Light';\nclass AreaLightSopParamsConfig extends AreaLightParamConfig(NodeParamsConfig) {}\nconst ParamsConfig = new AreaLightSopParamsConfig();\n\nexport class AreaLightSopNode extends TypedSopNode<AreaLightSopParamsConfig> {\n\toverride paramsConfig = ParamsConfig;\n\tstatic override type() {\n\t\treturn LightType.AREA;\n\t}\n\n\toverride initializeNode() {\n\t\tthis.io.inputs.setCount(0);\n\t}\n\n\tprivate _operation: AreaLightSopOperation | undefined;\n\toverride cook(input_contents: CoreGroup[]) {\n\t\tthis._operation = this._operation || new AreaLightSopOperation(this._scene, this.states, this);\n\t\tconst core_group = this._operation.cook(input_contents, this.pv);\n\t\tthis.setCoreGroup(core_group);\n\t}\n}\n","/**\n * Simple math operation of a numeric attribute\n *\n * @remarks\n * This allows you to quickly add and multiply a numeric attribute of the input geometry.\n *\n */\n\nimport {TypedSopNode} from './_Base';\nimport {CoreGroup} from '../../../core/geometry/Group';\n\nimport {AttribAddMultSopOperation} from '../../operations/sop/AttribAddMult';\nimport {NodeParamsConfig, ParamConfig} from '../utils/params/ParamsConfig';\nimport {SopType} from '../../poly/registers/nodes/types/Sop';\nconst DEFAULT = AttribAddMultSopOperation.DEFAULT_PARAMS;\nclass AttribAddMultSopParamsConfig extends NodeParamsConfig {\n\t/** @param attribute name */\n\tname = ParamConfig.STRING(DEFAULT.name);\n\t/** @param value to add before the multiplication */\n\tpreAdd = ParamConfig.FLOAT(DEFAULT.preAdd, {range: [-1, 1]});\n\t/** @param value to multiply */\n\tmult = ParamConfig.FLOAT(DEFAULT.mult, {range: [-1, 1]});\n\t/** @param value to add after the multiplication */\n\tpostAdd = ParamConfig.FLOAT(DEFAULT.postAdd, {range: [-1, 1]});\n}\nconst ParamsConfig = new AttribAddMultSopParamsConfig();\n\nexport class AttribAddMultSopNode extends TypedSopNode<AttribAddMultSopParamsConfig> {\n\toverride paramsConfig = ParamsConfig;\n\tstatic override type() {\n\t\treturn SopType.ATTRIB_ADD_MULT;\n\t}\n\n\toverride initializeNode() {\n\t\tthis.io.inputs.setCount(1);\n\t\tthis.io.inputs.initInputsClonedState(AttribAddMultSopOperation.INPUT_CLONED_STATE);\n\t}\n\n\tprivate _operation: AttribAddMultSopOperation | undefined;\n\toverride cook(input_contents: CoreGroup[]) {\n\t\tthis._operation = this._operation || new AttribAddMultSopOperation(this.scene(), this.states, this);\n\t\tconst core_group = this._operation.cook(input_contents, this.pv);\n\t\tthis.setCoreGroup(core_group);\n\t}\n}\n","/**\n * Cast the BufferAttribute of the index geometry property\n *\n\n */\nimport {TypedSopNode} from './_Base';\nimport {CoreGroup} from '../../../core/geometry/Group';\nimport {AttribCastSopOperation, ATTRIB_TYPES} from '../../operations/sop/AttribCast';\n\nimport {NodeParamsConfig, ParamConfig} from '../utils/params/ParamsConfig';\nconst DEFAULT = AttribCastSopOperation.DEFAULT_PARAMS;\nclass IndexCastSopParamsConfig extends NodeParamsConfig {\n\t/** @param toggle on to cast attributes */\n\tcastAttributes = ParamConfig.BOOLEAN(DEFAULT.castAttributes);\n\t/** @param attrib mask */\n\tmask = ParamConfig.STRING(DEFAULT.mask, {\n\t\tvisibleIf: {castAttributes: 1},\n\t});\n\t/** @param toggle on to cast index */\n\tcastIndex = ParamConfig.BOOLEAN(DEFAULT.castIndex);\n\t/** @param type of attribute to cast to */\n\ttype = ParamConfig.INTEGER(DEFAULT.type, {\n\t\tmenu: {\n\t\t\tentries: ATTRIB_TYPES.map((name, value) => {\n\t\t\t\treturn {\n\t\t\t\t\tname: name as string,\n\t\t\t\t\tvalue: value,\n\t\t\t\t};\n\t\t\t}),\n\t\t},\n\t});\n}\nconst ParamsConfig = new IndexCastSopParamsConfig();\n\nexport class AttribCastSopNode extends TypedSopNode<IndexCastSopParamsConfig> {\n\toverride paramsConfig = ParamsConfig;\n\tstatic override type() {\n\t\treturn 'attribCast';\n\t}\n\n\toverride initializeNode() {\n\t\tthis.io.inputs.setCount(1);\n\t\tthis.io.inputs.initInputsClonedState(AttribCastSopOperation.INPUT_CLONED_STATE);\n\t}\n\n\tprivate _operation: AttribCastSopOperation | undefined;\n\toverride cook(input_contents: CoreGroup[]) {\n\t\tthis._operation = this._operation || new AttribCastSopOperation(this.scene(), this.states, this);\n\t\tconst core_group = this._operation.cook(input_contents, this.pv);\n\t\tthis.setCoreGroup(core_group);\n\t}\n}\n","/**\n * Copies an attribute from one geometry to another.\n *\n * @remarks\n * This copies an attribute from the right input geometry to the left input geometry.\n * Note that you can copy attributes that have different sizes. For instance:\n\n * - to copy only the y component of the position to a float attribute, set it as such:\n * \t- srcOffset = 1\n * \t- destOffset = 0\n * - to copy the y component to the z component of another attribute:\n * \t- srcOffset = 1\n * \t- destOffset = 2\n * - if you copy from a float to a float:\n * \t- srcOffset = 0\n * \t- destOffset = 0\n *\n */\nimport {TypedSopNode} from './_Base';\nimport {CoreGroup} from '../../../core/geometry/Group';\nimport {AttribCopySopOperation} from '../../operations/sop/AttribCopy';\nimport {NodeParamsConfig, ParamConfig} from '../utils/params/ParamsConfig';\nimport {SopType} from '../../poly/registers/nodes/types/Sop';\nimport {ATTRIBUTE_CLASSES, AttribClass, AttribClassMenuEntries} from '../../../core/geometry/Constant';\n\nconst DEFAULT = AttribCopySopOperation.DEFAULT_PARAMS;\nclass AttribCopySopParamsConfig extends NodeParamsConfig {\n\t/** @param the attribute class (geometry or object) */\n\tclass = ParamConfig.INTEGER(DEFAULT.class, {\n\t\tmenu: {\n\t\t\tentries: AttribClassMenuEntries,\n\t\t},\n\t});\n\t/** @param name of the attribute to copy */\n\tname = ParamConfig.STRING(DEFAULT.name);\n\t/** @param toggle if you want to copy to another name */\n\ttnewName = ParamConfig.BOOLEAN(DEFAULT.tnewName);\n\t/** @param the new name of the attribute */\n\tnewName = ParamConfig.STRING(DEFAULT.newName, {visibleIf: {tnewName: 1}});\n\n\t/** @param this defines which component the copy starts from. If you want to copy the whole attribute, leave it at 0. If you want to copy only the y component, set it to 1. If you want to copy the z component, set it to 2. Note that this only makes sense if you copy from an attribute that has enough components to copy from. So setting it to 2 (for z) to copy from a vector2 attribute will raise an error. */\n\tsrcOffset = ParamConfig.INTEGER(DEFAULT.srcOffset, {\n\t\trange: [0, 3],\n\t\trangeLocked: [true, true],\n\t\tvisibleIf: {class: ATTRIBUTE_CLASSES.indexOf(AttribClass.POINT)},\n\t});\n\t/** @param this defines which component the attribute is copied to */\n\tdestOffset = ParamConfig.INTEGER(DEFAULT.destOffset, {\n\t\trange: [0, 3],\n\t\trangeLocked: [true, true],\n\t\tvisibleIf: {class: ATTRIBUTE_CLASSES.indexOf(AttribClass.POINT)},\n\t});\n}\nconst ParamsConfig = new AttribCopySopParamsConfig();\n\n// TODO: attrib copy should handle string attributes\nexport class AttribCopySopNode extends TypedSopNode<AttribCopySopParamsConfig> {\n\toverride paramsConfig = ParamsConfig;\n\tstatic override type() {\n\t\treturn SopType.ATTRIB_COPY;\n\t}\n\n\toverride initializeNode() {\n\t\tthis.io.inputs.setCount(1, 2);\n\t\tthis.io.inputs.initInputsClonedState(AttribCopySopOperation.INPUT_CLONED_STATE);\n\t}\n\n\tprivate _operation: AttribCopySopOperation | undefined;\n\toverride cook(input_contents: CoreGroup[]) {\n\t\tthis._operation = this._operation || new AttribCopySopOperation(this.scene(), this.states, this);\n\t\tconst core_group = this._operation.cook(input_contents, this.pv);\n\t\tthis.setCoreGroup(core_group);\n\t}\n\tsetAttribClass(attribClass: AttribClass) {\n\t\tthis.p.class.set(ATTRIBUTE_CLASSES.indexOf(attribClass));\n\t}\n\tattribClass() {\n\t\treturn ATTRIBUTE_CLASSES[this.pv.class];\n\t}\n}\n","/**\n * Deletes an attribute from the input\n *\n *\n */\nimport {TypedSopNode} from './_Base';\nimport {CoreGroup} from '../../../core/geometry/Group';\nimport {AttribClassMenuEntries, AttribClass, ATTRIBUTE_CLASSES} from '../../../core/geometry/Constant';\nimport {InputCloneMode} from '../../poly/InputCloneMode';\nimport {NodeParamsConfig, ParamConfig} from '../utils/params/ParamsConfig';\nimport {SopType} from '../../poly/registers/nodes/types/Sop';\nimport {AttribDeleteSopOperation} from '../../operations/sop/AttribDelete';\nconst DEFAULT = AttribDeleteSopOperation.DEFAULT_PARAMS;\nclass AttribDeleteSopParamsConfig extends NodeParamsConfig {\n\t/** @param the group this applies to */\n\tgroup = ParamConfig.STRING(DEFAULT.group);\n\t/** @param attribute class (geometry or object) */\n\tclass = ParamConfig.INTEGER(DEFAULT.class, {\n\t\tmenu: {\n\t\t\tentries: AttribClassMenuEntries,\n\t\t},\n\t});\n\t/** @param attribute name to delete */\n\tname = ParamConfig.STRING(DEFAULT.name);\n}\nconst ParamsConfig = new AttribDeleteSopParamsConfig();\n\nexport class AttribDeleteSopNode extends TypedSopNode<AttribDeleteSopParamsConfig> {\n\toverride paramsConfig = ParamsConfig;\n\tstatic override type() {\n\t\treturn SopType.ATTRIB_DELETE;\n\t}\n\n\toverride initializeNode() {\n\t\tthis.io.inputs.setCount(1);\n\t\tthis.io.inputs.initInputsClonedState(InputCloneMode.FROM_NODE);\n\t}\n\n\tsetAttribClass(attribClass: AttribClass) {\n\t\tthis.p.class.set(ATTRIBUTE_CLASSES.indexOf(attribClass));\n\t}\n\tattribClass() {\n\t\treturn ATTRIBUTE_CLASSES[this.pv.class];\n\t}\n\n\tprivate _operation: AttribDeleteSopOperation | undefined;\n\toverride cook(inputCoreGroups: CoreGroup[]) {\n\t\tthis._operation = this._operation || new AttribDeleteSopOperation(this._scene, this.states, this);\n\t\tconst coreGroup = this._operation.cook(inputCoreGroups, this.pv);\n\t\tthis.setCoreGroup(coreGroup);\n\t}\n}\n","/**\n * Reads a texture and assigns a value to an attribute.\n *\n * @remarks\n * This can be useful for heightmaps for instance.\n *\n */\nimport {TypedSopNode} from './_Base';\nimport {NodeContext} from '../../poly/NodeContext';\nimport {CoreGroup} from '../../../core/geometry/Group';\nimport {InputCloneMode} from '../../poly/InputCloneMode';\n\nimport {AttribFromTextureSopOperation} from '../../operations/sop/AttribFromTexture';\nimport {NodeParamsConfig, ParamConfig} from '../utils/params/ParamsConfig';\nconst DEFAULT = AttribFromTextureSopOperation.DEFAULT_PARAMS;\nclass AttribFromTextureSopParamsConfig extends NodeParamsConfig {\n\t/** @param texture node */\n\ttexture = ParamConfig.NODE_PATH('', {\n\t\tnodeSelection: {context: NodeContext.COP},\n\t});\n\t/** @param uv attribute */\n\tuvAttrib = ParamConfig.STRING(DEFAULT.uvAttrib);\n\t/** @param attribute to set the value to */\n\tattrib = ParamConfig.STRING(DEFAULT.attrib);\n\t/** @param target attribute size */\n\tattribSize = ParamConfig.INTEGER(DEFAULT.attribSize, {\n\t\trange: [1, 3],\n\t\trangeLocked: [true, true],\n\t});\n\t/** @param value to add to the attribute */\n\tadd = ParamConfig.FLOAT(DEFAULT.add);\n\t/** @param value to multiply the attribute with */\n\tmult = ParamConfig.FLOAT(DEFAULT.mult);\n}\nconst ParamsConfig = new AttribFromTextureSopParamsConfig();\n\nexport class AttribFromTextureSopNode extends TypedSopNode<AttribFromTextureSopParamsConfig> {\n\toverride paramsConfig = ParamsConfig;\n\tstatic override type() {\n\t\treturn 'attribFromTexture';\n\t}\n\n\toverride initializeNode() {\n\t\tthis.io.inputs.setCount(1);\n\t\tthis.io.inputs.initInputsClonedState(InputCloneMode.FROM_NODE);\n\t}\n\n\tprivate _operation: AttribFromTextureSopOperation | undefined;\n\toverride async cook(input_contents: CoreGroup[]) {\n\t\tthis._operation = this._operation || new AttribFromTextureSopOperation(this.scene(), this.states, this);\n\t\tconst core_group = await this._operation.cook(input_contents, this.pv);\n\t\tthis.setCoreGroup(core_group);\n\t}\n}\n","/**\n * Creates id and idn attributes.\n *\n * @remarks\n *\n * This is more optimized than [sop/attribCreate](/docs/nodes/sop/attribCreate) to create id and idn attributes, although the attribCreate node can create them similarly using the following expressions:\n *\n * `@ptnum` for the id attribute\n * `@ptnum / (pointsCount(0)-1)` for the idn attribute\n *\n */\nimport {ATTRIBUTE_CLASSES_WITHOUT_CORE_GROUP} from './../../../core/geometry/Constant';\nimport {TypedSopNode} from './_Base';\nimport {CoreGroup} from '../../../core/geometry/Group';\nimport {InputCloneMode} from '../../poly/InputCloneMode';\nimport {AttribClass, AttribClassMenuEntriesWithoutCoreGroup} from './../../../core/geometry/Constant';\nimport {AttribIdSopOperation} from '../../operations/sop/AttribId';\nimport {SopType} from '../../poly/registers/nodes/types/Sop';\nimport {NodeParamsConfig, ParamConfig} from '../utils/params/ParamsConfig';\nconst DEFAULT = AttribIdSopOperation.DEFAULT_PARAMS;\n\nclass AttribIdSopParamsConfig extends NodeParamsConfig {\n\t/** @param the attribute class (geometry or object) */\n\tclass = ParamConfig.INTEGER(DEFAULT.class, {\n\t\tmenu: {\n\t\t\tentries: AttribClassMenuEntriesWithoutCoreGroup,\n\t\t},\n\t});\n\t/** @param sets to true to create the id attribute */\n\tid = ParamConfig.BOOLEAN(DEFAULT.id);\n\t/** @param name of id attribute */\n\tidName = ParamConfig.STRING(DEFAULT.idName, {\n\t\tvisibleIf: {id: 1},\n\t});\n\t/** @param sets to true to create the id attribute */\n\tidn = ParamConfig.BOOLEAN(DEFAULT.idn);\n\t/** @param name of the position attribute */\n\t/** @param name of idn attribute */\n\tidnName = ParamConfig.STRING(DEFAULT.idnName, {\n\t\tvisibleIf: {idn: 1},\n\t});\n}\nconst ParamsConfig = new AttribIdSopParamsConfig();\n\nexport class AttribIdSopNode extends TypedSopNode<AttribIdSopParamsConfig> {\n\toverride paramsConfig = ParamsConfig;\n\tstatic override type() {\n\t\treturn SopType.ATTRIB_ID;\n\t}\n\n\toverride initializeNode() {\n\t\tthis.io.inputs.setCount(1);\n\t\tthis.io.inputs.initInputsClonedState([InputCloneMode.FROM_NODE]);\n\t}\n\n\tprivate _operation: AttribIdSopOperation | undefined;\n\toverride cook(inputCoreGroups: CoreGroup[]) {\n\t\tthis._operation = this._operation || new AttribIdSopOperation(this.scene(), this.states, this);\n\t\tconst coreGroup = this._operation.cook(inputCoreGroups, this.pv);\n\t\tthis.setCoreGroup(coreGroup);\n\t}\n\t//\n\t//\n\t// API UTILS\n\t//\n\t//\n\tsetAttribClass(attribClass: AttribClass) {\n\t\tif (ATTRIBUTE_CLASSES_WITHOUT_CORE_GROUP.includes(attribClass)) {\n\t\t\tthis.p.class.set(ATTRIBUTE_CLASSES_WITHOUT_CORE_GROUP.indexOf(attribClass));\n\t\t} else {\n\t\t\tconsole.warn(`${attribClass} is not possible on this node`);\n\t\t}\n\t}\n\tattribClass() {\n\t\treturn ATTRIBUTE_CLASSES_WITHOUT_CORE_GROUP[this.pv.class];\n\t}\n}\n","/**\n * Normalizes an attribute.\n *\n * @remarks\n * Finds the min and max of an attribute and normalizes its value between 0 and 1.\n * For vector attributes, it can also set them to a length of 1.\n *\n */\n\nimport {TypedSopNode} from './_Base';\nimport {CoreGroup} from '../../../core/geometry/Group';\n\nimport {AttribNormalizeSopOperation, NORMALIZE_MODES, NormalizeMode} from '../../operations/sop/AttribNormalize';\nimport {NodeParamsConfig, ParamConfig} from '../utils/params/ParamsConfig';\nconst DEFAULT = AttribNormalizeSopOperation.DEFAULT_PARAMS;\nclass AttribNormalizeSopParamsConfig extends NodeParamsConfig {\n\t/** @param defines if the value should be normalized between 0 and 1, or for vectors if the length should be 1 */\n\tmode = ParamConfig.INTEGER(DEFAULT.mode, {\n\t\tmenu: {\n\t\t\tentries: NORMALIZE_MODES.map((name, value) => {\n\t\t\t\treturn {name, value};\n\t\t\t}),\n\t\t},\n\t});\n\t/** @param attribute to normalize */\n\tname = ParamConfig.STRING(DEFAULT.name);\n\t/** @param toggle to change the name of the attribute */\n\tchangeName = ParamConfig.BOOLEAN(DEFAULT.changeName);\n\t/** @param new attribute name */\n\tnewName = ParamConfig.STRING(DEFAULT.newName, {visibleIf: {changeName: 1}});\n}\nconst ParamsConfig = new AttribNormalizeSopParamsConfig();\n\nexport class AttribNormalizeSopNode extends TypedSopNode<AttribNormalizeSopParamsConfig> {\n\toverride paramsConfig = ParamsConfig;\n\tstatic override type() {\n\t\treturn 'attribNormalize';\n\t}\n\n\toverride initializeNode() {\n\t\tthis.io.inputs.setCount(1);\n\t\tthis.io.inputs.initInputsClonedState(AttribNormalizeSopOperation.INPUT_CLONED_STATE);\n\t}\n\n\tset_mode(mode: NormalizeMode) {\n\t\tthis.p.mode.set(NORMALIZE_MODES.indexOf(mode));\n\t}\n\n\tprivate _operation: AttribNormalizeSopOperation | undefined;\n\toverride cook(input_contents: CoreGroup[]) {\n\t\tthis._operation = this._operation || new AttribNormalizeSopOperation(this.scene(), this.states, this);\n\t\tconst core_group = this._operation.cook(input_contents, this.pv);\n\t\tthis.setCoreGroup(core_group);\n\t}\n}\n","/**\n * Remaps an attribute\n *\n * @remarks\n * This is very handy when you have an attribute with values between 0 and 1, and you want to remap those values with a ramp.\n *\n */\nimport {Vector2} from 'three';\nimport {Vector3} from 'three';\nimport {Vector4} from 'three';\nimport {TypedSopNode} from './_Base';\nimport {CoreGroup} from '../../../core/geometry/Group';\nimport {AttribSize} from '../../../core/geometry/Constant';\nimport {TypeAssert} from '../../poly/Assert';\n\nimport {NodeParamsConfig, ParamConfig} from '../utils/params/ParamsConfig';\nimport {AttribValue, NumericAttribValue} from '../../../types/GlobalTypes';\nimport {isBooleanTrue} from '../../../core/BooleanValue';\nimport {CoreObjectType, ObjectContent} from '../../../core/geometry/ObjectContent';\nimport {pointsFromObject} from '../../../core/geometry/entities/point/CorePointUtils';\nimport {corePointClassFactory} from '../../../core/geometry/CoreObjectFactory';\nimport {CorePoint} from '../../../core/geometry/entities/point/CorePoint';\n\nconst _points: CorePoint<CoreObjectType>[] = [];\nclass AttribRemapSopParamsConfig extends NodeParamsConfig {\n\t/** @param name of the attribute to remap */\n\tname = ParamConfig.STRING();\n\t/** @param ramp used to remap */\n\tramp = ParamConfig.RAMP();\n\t/** @param toggle if you want to create a new attribute */\n\tchangeName = ParamConfig.BOOLEAN(0);\n\t/** @param new attribute name */\n\tnewName = ParamConfig.STRING('', {visibleIf: {changeName: 1}});\n}\nconst ParamsConfig = new AttribRemapSopParamsConfig();\n\nexport class AttribRemapSopNode extends TypedSopNode<AttribRemapSopParamsConfig> {\n\toverride paramsConfig = ParamsConfig;\n\tstatic override type() {\n\t\treturn 'attribRemap';\n\t}\n\n\toverride initializeNode() {\n\t\tthis.io.inputs.setCount(1);\n\t}\n\n\toverride cook(inputCoreGroups: CoreGroup[]) {\n\t\tconst coreGroup = inputCoreGroups[0];\n\t\tconst objects = coreGroup.allObjects();\n\t\tfor (const object of objects) {\n\t\t\tthis._remapAttribute(object);\n\t\t}\n\t\tthis.setCoreGroup(coreGroup);\n\t}\n\n\tprivate _remapAttribute<T extends CoreObjectType>(object: ObjectContent<T>) {\n\t\tpointsFromObject(object, _points);\n\t\tif (_points.length === 0) {\n\t\t\treturn;\n\t\t}\n\t\tif (this.pv.name === '') {\n\t\t\treturn;\n\t\t}\n\t\tconst corePointClass = corePointClassFactory(object);\n\n\t\tconst attribSize = corePointClass.attribSize(object, this.pv.name);\n\t\tconst values = _points.map((point) => point.attribValue(this.pv.name));\n\t\t// let min: NumericAttribValue, max: NumericAttribValue;\n\t\tconst remapedValues: NumericAttribValue[] = new Array(_points.length);\n\t\tthis._get_remaped_values(attribSize, values, remapedValues);\n\n\t\tlet targetName = this.pv.name;\n\t\tif (isBooleanTrue(this.pv.changeName)) {\n\t\t\ttargetName = this.pv.newName;\n\t\t\tif (!corePointClass.hasAttribute(object, targetName)) {\n\t\t\t\tcorePointClass.addNumericAttribute(object, targetName, attribSize, 0);\n\t\t\t}\n\t\t}\n\n\t\tlet i = 0;\n\t\tfor (const normalized_value of remapedValues) {\n\t\t\t_points[i].setAttribValue(targetName, normalized_value);\n\t\t\ti++;\n\t\t}\n\t}\n\n\tprivate _get_remaped_values(attrib_size: AttribSize, values: AttribValue[], remaped_values: NumericAttribValue[]) {\n\t\tswitch (attrib_size) {\n\t\t\tcase AttribSize.FLOAT:\n\t\t\t\treturn this._getNormalizedFloat(values, remaped_values);\n\t\t\tcase AttribSize.VECTOR2:\n\t\t\t\treturn this._getNormalizedVector2(values, remaped_values);\n\t\t\tcase AttribSize.VECTOR3:\n\t\t\t\treturn this._getNormalizedVector3(values, remaped_values);\n\t\t\tcase AttribSize.VECTOR4:\n\t\t\t\treturn this._getNormalizedVector4(values, remaped_values);\n\t\t}\n\t\tTypeAssert.unreachable(attrib_size);\n\t}\n\n\tprivate _getNormalizedFloat(values: AttribValue[], remaped_values: NumericAttribValue[]) {\n\t\tconst valuesf = values as number[];\n\n\t\tconst ramp_param = this.p.ramp;\n\n\t\tfor (let i = 0; i < valuesf.length; i++) {\n\t\t\tconst value = valuesf[i];\n\t\t\tconst remaped_value = ramp_param.valueAtPosition(value);\n\t\t\tremaped_values[i] = remaped_value;\n\t\t}\n\t}\n\tprivate _getNormalizedVector2(values: AttribValue[], remaped_values: NumericAttribValue[]) {\n\t\tconst valuesv = values as Vector2[];\n\t\tconst ramp_param = this.p.ramp;\n\t\tfor (let i = 0; i < valuesv.length; i++) {\n\t\t\tconst value = valuesv[i];\n\t\t\tconst remaped_value = new Vector2(ramp_param.valueAtPosition(value.x), ramp_param.valueAtPosition(value.y));\n\t\t\tremaped_values[i] = remaped_value;\n\t\t}\n\t}\n\tprivate _getNormalizedVector3(values: AttribValue[], remaped_values: NumericAttribValue[]) {\n\t\tconst valuesv = values as Vector3[];\n\t\tconst ramp_param = this.p.ramp;\n\t\tfor (let i = 0; i < valuesv.length; i++) {\n\t\t\tconst value = valuesv[i];\n\t\t\tconst remaped_value = new Vector3(\n\t\t\t\tramp_param.valueAtPosition(value.x),\n\t\t\t\tramp_param.valueAtPosition(value.y),\n\t\t\t\tramp_param.valueAtPosition(value.z)\n\t\t\t);\n\t\t\tremaped_values[i] = remaped_value;\n\t\t}\n\t}\n\tprivate _getNormalizedVector4(values: AttribValue[], remaped_values: NumericAttribValue[]) {\n\t\tconst valuesv = values as Vector4[];\n\t\tconst ramp_param = this.p.ramp;\n\t\tfor (let i = 0; i < valuesv.length; i++) {\n\t\t\tconst value = valuesv[i];\n\t\t\tconst remaped_value = new Vector4(\n\t\t\t\tramp_param.valueAtPosition(value.x),\n\t\t\t\tramp_param.valueAtPosition(value.y),\n\t\t\t\tramp_param.valueAtPosition(value.z),\n\t\t\t\tramp_param.valueAtPosition(value.w)\n\t\t\t);\n\t\t\tremaped_values[i] = remaped_value;\n\t\t}\n\t}\n}\n","/**\n * Rename an attribute\n *\n *\n */\nimport {TypedSopNode} from './_Base';\nimport {CoreGroup} from '../../../core/geometry/Group';\nimport {NodeParamsConfig, ParamConfig} from '../utils/params/ParamsConfig';\nimport {ATTRIBUTE_CLASSES, AttribClass, AttribClassMenuEntries} from '../../../core/geometry/Constant';\nimport {AttribRenameSopOperation} from '../../operations/sop/AttribRename';\nconst DEFAULT = AttribRenameSopOperation.DEFAULT_PARAMS;\nclass AttribRenameSopParamsConfig extends NodeParamsConfig {\n\t/** @param the group this applies to */\n\tgroup = ParamConfig.STRING(DEFAULT.group);\n\t/** @param class of the attribute to rename (object or geometry) */\n\tclass = ParamConfig.INTEGER(DEFAULT.class, {\n\t\tmenu: {\n\t\t\tentries: AttribClassMenuEntries,\n\t\t},\n\t});\n\t/** @param old attribute name */\n\toldName = ParamConfig.STRING(DEFAULT.oldName);\n\t/** @param new attribute name */\n\tnewName = ParamConfig.STRING(DEFAULT.newName);\n}\nconst ParamsConfig = new AttribRenameSopParamsConfig();\n\nexport class AttribRenameSopNode extends TypedSopNode<AttribRenameSopParamsConfig> {\n\toverride paramsConfig = ParamsConfig;\n\tstatic override type() {\n\t\treturn 'attribRename';\n\t}\n\n\toverride initializeNode() {\n\t\tthis.io.inputs.setCount(1);\n\t\tthis.io.inputs.initInputsClonedState(AttribRenameSopOperation.INPUT_CLONED_STATE);\n\t}\n\tsetAttribClass(attribClass: AttribClass) {\n\t\tthis.p.class.set(ATTRIBUTE_CLASSES.indexOf(attribClass));\n\t}\n\tattribClass() {\n\t\treturn ATTRIBUTE_CLASSES[this.pv.class];\n\t}\n\n\tprivate _operation: AttribRenameSopOperation | undefined;\n\toverride cook(inputCoreGroups: CoreGroup[]) {\n\t\tthis._operation = this._operation || new AttribRenameSopOperation(this._scene, this.states, this);\n\t\tconst coreGroup = this._operation.cook(inputCoreGroups, this.pv);\n\t\tthis.setCoreGroup(coreGroup);\n\t}\n}\n","/**\n * Sets an attribute value for a specific point or object\n *\n * @remarks\n * While the same operation is possible using the sop/attribCreate\n * and its group parameter, this node is more performant.\n * Also, unlike the sop/attribCreate, it does not accept point specific variables such as @ptnum\n * in expressions.\n *\n */\nimport {TypedSopNode} from './_Base';\nimport {\n\tAttribClassMenuEntries,\n\tAttribTypeMenuEntries,\n\tAttribClass,\n\tAttribType,\n\tATTRIBUTE_CLASSES,\n\tATTRIBUTE_TYPES,\n} from '../../../core/geometry/Constant';\nimport {CoreAttribute} from '../../../core/geometry/Attribute';\nimport {BaseCoreObject} from '../../../core/geometry/entities/object/BaseCoreObject';\nimport {CoreGroup} from '../../../core/geometry/Group';\nimport {TypeAssert} from '../../poly/Assert';\nimport {AttribSetAtIndexSopOperation} from '../../operations/sop/AttribSetAtIndex';\nimport {NodeParamsConfig, ParamConfig} from '../utils/params/ParamsConfig';\nimport {BufferAttribute} from 'three';\nimport {CoreObjectType, ObjectContent} from '../../../core/geometry/ObjectContent';\nimport {corePointClassFactory} from '../../../core/geometry/CoreObjectFactory';\nimport {pointsFromObject} from '../../../core/geometry/entities/point/CorePointUtils';\nimport {CorePoint} from '../../../core/geometry/entities/point/CorePoint';\nconst DEFAULT = AttribSetAtIndexSopOperation.DEFAULT_PARAMS;\n\nconst _allPoints: CorePoint<CoreObjectType>[] = [];\nclass AttribSetAtIndexSopParamsConfig extends NodeParamsConfig {\n\t/** @param the point or object index this applies to */\n\tindex = ParamConfig.INTEGER(DEFAULT.index, {\n\t\trange: [0, 100],\n\t\trangeLocked: [true, false],\n\t});\n\t/** @param the attribute class (geometry or object) */\n\tclass = ParamConfig.INTEGER(DEFAULT.class, {\n\t\tmenu: {\n\t\t\tentries: AttribClassMenuEntries,\n\t\t},\n\t});\n\t/** @param the attribute type (numeric or string) */\n\ttype = ParamConfig.INTEGER(DEFAULT.type, {\n\t\tmenu: {\n\t\t\tentries: AttribTypeMenuEntries,\n\t\t},\n\t});\n\t/** @param the attribute name */\n\tname = ParamConfig.STRING(DEFAULT.name);\n\t/** @param the attribute size (1 for float, 2 for vector2, 3 for vector3, 4 for vector4) */\n\tsize = ParamConfig.INTEGER(DEFAULT.size, {\n\t\trange: [1, 4],\n\t\trangeLocked: [true, true],\n\t\tvisibleIf: {type: ATTRIBUTE_TYPES.indexOf(AttribType.NUMERIC)},\n\t});\n\t/** @param the value for a float attribute */\n\tvalue1 = ParamConfig.FLOAT(DEFAULT.value1, {\n\t\tvisibleIf: {type: ATTRIBUTE_TYPES.indexOf(AttribType.NUMERIC), size: 1},\n\t});\n\t/** @param the value for a vector2 */\n\tvalue2 = ParamConfig.VECTOR2(DEFAULT.value2, {\n\t\tvisibleIf: {type: ATTRIBUTE_TYPES.indexOf(AttribType.NUMERIC), size: 2},\n\t});\n\t/** @param the value for a vector3 */\n\tvalue3 = ParamConfig.VECTOR3(DEFAULT.value3, {\n\t\tvisibleIf: {type: ATTRIBUTE_TYPES.indexOf(AttribType.NUMERIC), size: 3},\n\t});\n\t/** @param the value for a vector4 */\n\tvalue4 = ParamConfig.VECTOR4(DEFAULT.value4, {\n\t\tvisibleIf: {type: ATTRIBUTE_TYPES.indexOf(AttribType.NUMERIC), size: 4},\n\t});\n\t/** @param the value for a string attribute */\n\tstring = ParamConfig.STRING(DEFAULT.string, {\n\t\tvisibleIf: {type: ATTRIBUTE_TYPES.indexOf(AttribType.STRING)},\n\t});\n}\nconst ParamsConfig = new AttribSetAtIndexSopParamsConfig();\nexport class AttribSetAtIndexSopNode extends TypedSopNode<AttribSetAtIndexSopParamsConfig> {\n\toverride paramsConfig = ParamsConfig;\n\tstatic override type() {\n\t\treturn 'attribSetAtIndex';\n\t}\n\n\toverride initializeNode() {\n\t\tthis.io.inputs.setCount(1);\n\t\tthis.io.inputs.initInputsClonedState(AttribSetAtIndexSopOperation.INPUT_CLONED_STATE);\n\t}\n\n\tprivate _operation: AttribSetAtIndexSopOperation | undefined;\n\toverride cook(inputCoreGroups: CoreGroup[]) {\n\t\t// cannot yet convert to an operation, as expressions may be used in this node\n\t\t// but we can still use one when no expression is required\n\t\tconst attribName = this.pv.name;\n\n\t\tif (this._isUsingExpression()) {\n\t\t\tif (attribName && attribName.trim() != '') {\n\t\t\t\tthis._addAttribute(ATTRIBUTE_CLASSES[this.pv.class], inputCoreGroups[0]);\n\t\t\t} else {\n\t\t\t\tthis.states.error.set('attribute name is not valid');\n\t\t\t}\n\t\t} else {\n\t\t\tthis._operation = this._operation || new AttribSetAtIndexSopOperation(this.scene(), this.states, this);\n\t\t\tconst coreGroup = this._operation.cook(inputCoreGroups, this.pv);\n\t\t\tthis.setCoreGroup(coreGroup);\n\t\t}\n\t}\n\tprivate _addAttribute(attribClass: AttribClass, coreGroup: CoreGroup) {\n\t\tconst attribType = ATTRIBUTE_TYPES[this.pv.type];\n\t\tswitch (attribClass) {\n\t\t\tcase AttribClass.POINT:\n\t\t\t\tthis._addPointAttribute(attribType, coreGroup);\n\t\t\t\treturn this.setCoreGroup(coreGroup);\n\t\t\tcase AttribClass.VERTEX:\n\t\t\t\tthis.states.error.set('vertex attributes are not supported');\n\t\t\t\treturn this.setCoreGroup(coreGroup);\n\t\t\tcase AttribClass.PRIMITIVE:\n\t\t\t\tthis.states.error.set('primitive attributes are not supported');\n\t\t\t\treturn this.setCoreGroup(coreGroup);\n\t\t\tcase AttribClass.OBJECT:\n\t\t\t\tthis._addObjectAttribute(attribType, coreGroup);\n\t\t\t\treturn this.setCoreGroup(coreGroup);\n\t\t\tcase AttribClass.CORE_GROUP:\n\t\t\t\tthis._addCoreGroupAttribute(attribType, coreGroup);\n\t\t\t\treturn this.setCoreGroup(coreGroup);\n\t\t}\n\t\tTypeAssert.unreachable(attribClass);\n\t}\n\n\tprivate _addPointAttribute(attribType: AttribType, coreGroup: CoreGroup) {\n\t\tconst objects = coreGroup.allObjects();\n\t\tswitch (attribType) {\n\t\t\tcase AttribType.NUMERIC: {\n\t\t\t\tfor (const object of objects) {\n\t\t\t\t\tthis._addNumericAttributeToPoints(object);\n\t\t\t\t}\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tcase AttribType.STRING: {\n\t\t\t\tfor (const object of objects) {\n\t\t\t\t\tthis._addStringAttributeToPoints(object);\n\t\t\t\t}\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tTypeAssert.unreachable(attribType);\n\t}\n\tprivate _addObjectAttribute(attribType: AttribType, coreGroup: CoreGroup) {\n\t\tconst allCoreObjects = coreGroup.allCoreObjects();\n\n\t\t// add attrib if non existent\n\t\tconst attribName = this.pv.name;\n\t\tconst defaultValue = AttribSetAtIndexSopOperation.defaultAttribValue(this.pv);\n\t\tif (defaultValue != null) {\n\t\t\tfor (const coreObject of allCoreObjects) {\n\t\t\t\tif (!coreObject.hasAttribute(attribName)) {\n\t\t\t\t\tcoreObject.setAttribValue(attribName, defaultValue);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tconst coreObject = allCoreObjects[this.pv.index];\n\t\tif (!coreObject) {\n\t\t\treturn;\n\t\t}\n\n\t\tswitch (attribType) {\n\t\t\tcase AttribType.NUMERIC:\n\t\t\t\tthis._addNumericAttributeToObject(coreObject);\n\t\t\t\treturn;\n\t\t\tcase AttribType.STRING:\n\t\t\t\tthis._addStringAttributeToObject(coreObject);\n\t\t\t\treturn;\n\t\t}\n\t\tTypeAssert.unreachable(attribType);\n\t}\n\tprivate _addCoreGroupAttribute(attribType: AttribType, coreGroup: CoreGroup) {\n\t\tswitch (attribType) {\n\t\t\tcase AttribType.NUMERIC:\n\t\t\t\tthis._addNumericAttributeToCoreGroup(coreGroup);\n\t\t\t\treturn;\n\t\t\tcase AttribType.STRING:\n\t\t\t\tthis._addStringAttributeToCoreGroup(coreGroup);\n\t\t\t\treturn;\n\t\t}\n\t\tTypeAssert.unreachable(attribType);\n\t}\n\n\tprivate _addNumericAttributeToPoints<T extends CoreObjectType>(object: ObjectContent<T>) {\n\t\tconst corePointClass = corePointClassFactory(object);\n\n\t\tconst attribName = CoreAttribute.remapName(this.pv.name);\n\t\tif (!corePointClass.hasAttribute(object, attribName)) {\n\t\t\tcorePointClass.addNumericAttribute(object, attribName, this.pv.size, 0);\n\t\t}\n\t\tconst attrib = corePointClass.attribute(object, attribName) as BufferAttribute;\n\t\tconst array = attrib.array;\n\t\tconst {index, size} = this.pv;\n\t\tswitch (size) {\n\t\t\tcase 1: {\n\t\t\t\tif (index < array.length) {\n\t\t\t\t\tarray[index] = this.pv.value1;\n\t\t\t\t\tattrib.needsUpdate = true;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase 2: {\n\t\t\t\tconst i2 = index * 2;\n\t\t\t\tif (i2 < array.length) {\n\t\t\t\t\tthis.pv.value2.toArray(array, i2);\n\t\t\t\t\tattrib.needsUpdate = true;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase 3: {\n\t\t\t\tconst i3 = index * 3;\n\t\t\t\tif (i3 < array.length) {\n\t\t\t\t\tthis.pv.value3.toArray(array, i3);\n\t\t\t\t\tattrib.needsUpdate = true;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase 4: {\n\t\t\t\tconst i4 = index * 4;\n\t\t\t\tif (i4 < array.length) {\n\t\t\t\t\tthis.pv.value4.toArray(array, i4);\n\t\t\t\t\tattrib.needsUpdate = true;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\t// const point = coreObject.points()[this.pv.index];\n\n\t\t// if (!point) {\n\t\t// \treturn;\n\t\t// }\n\n\t\t// const param = [this.p.value1, this.p.value2, this.p.value3, this.p.value4][this.pv.size - 1];\n\t\t// point.setAttribValue(attribName, param.value);\n\t}\n\n\tprivate _addNumericAttributeToObject(coreObject: BaseCoreObject<CoreObjectType>) {\n\t\tconst param = [this.p.value1, this.p.value2, this.p.value3, this.p.value4][this.pv.size - 1];\n\t\tconst attribName = this.pv.name;\n\t\tcoreObject.setAttribValue(attribName, param.value);\n\t}\n\tprivate _addNumericAttributeToCoreGroup(coreGroup: CoreGroup) {\n\t\tconst param = [this.p.value1, this.p.value2, this.p.value3, this.p.value4][this.pv.size - 1];\n\t\tconst attribName = this.pv.name;\n\t\tcoreGroup.setAttribValue(attribName, param.value);\n\t}\n\n\tprivate _addStringAttributeToPoints<T extends CoreObjectType>(object: ObjectContent<T>) {\n\t\tconst corePointClass = corePointClassFactory(object);\n\n\t\tconst attribName = this.pv.name;\n\t\tif (!corePointClass.hasAttribute(object, attribName)) {\n\t\t\tconst tmpIndexData = CoreAttribute.arrayToIndexedArrays(['']);\n\t\t\tcorePointClass.setIndexedAttribute(object, attribName, tmpIndexData['values'], tmpIndexData['indices']);\n\t\t}\n\n\t\tpointsFromObject(object, _allPoints);\n\n\t\tconst param = this.p.string;\n\n\t\tconst stringValues: string[] = new Array(_allPoints.length);\n\t\tfor (const point of _allPoints) {\n\t\t\tlet currentValue = point.stringAttribValue(attribName);\n\t\t\tif (currentValue == null) {\n\t\t\t\tcurrentValue = '';\n\t\t\t}\n\t\t\tstringValues[point.index()] = currentValue;\n\t\t}\n\n\t\tconst indexPoint = _allPoints[this.pv.index];\n\t\tif (indexPoint) {\n\t\t\tstringValues[indexPoint.index()] = param.value;\n\t\t}\n\n\t\tconst indexData = CoreAttribute.arrayToIndexedArrays(stringValues);\n\t\t// const geometry = coreObject.coreGeometry();\n\t\t// if (geometry) {\n\t\tcorePointClass.setIndexedAttribute(object, attribName, indexData['values'], indexData['indices']);\n\t\t// }\n\t}\n\n\tprivate _addStringAttributeToObject(coreObject: BaseCoreObject<CoreObjectType>) {\n\t\tconst param = this.p.string;\n\t\tconst attribName = this.pv.name;\n\t\tcoreObject.setAttribValue(attribName, param.value);\n\t}\n\tprivate _addStringAttributeToCoreGroup(coreGroup: CoreGroup) {\n\t\tconst param = this.p.string;\n\t\tconst attribName = this.pv.name;\n\t\tcoreGroup.setAttribValue(attribName, param.value);\n\t}\n\n\t//\n\t//\n\t// CHECK IF EXPRESSION IS BEING USED, TO ALLOW EASY SWITCH TO OPERATION\n\t//\n\t//\n\tprivate _isUsingExpression(): boolean {\n\t\tconst attribType = ATTRIBUTE_TYPES[this.pv.type];\n\t\tswitch (attribType) {\n\t\t\tcase AttribType.NUMERIC:\n\t\t\t\tconst param = [this.p.value1, this.p.value2, this.p.value3, this.p.value4][this.pv.size - 1];\n\t\t\t\treturn param.hasExpression();\n\t\t\tcase AttribType.STRING:\n\t\t\t\treturn this.p.string.hasExpression();\n\t\t}\n\t}\n\n\t//\n\t//\n\t// API UTILS\n\t//\n\t//\n\tsetAttribClass(attribClass: AttribClass) {\n\t\tthis.p.class.set(ATTRIBUTE_CLASSES.indexOf(attribClass));\n\t}\n\tattribClass() {\n\t\treturn ATTRIBUTE_CLASSES[this.pv.class];\n\t}\n\tsetAttribType(type: AttribType) {\n\t\tthis.p.type.set(ATTRIBUTE_TYPES.indexOf(type));\n\t}\n\tattribType() {\n\t\treturn ATTRIBUTE_TYPES[this.pv.type];\n\t}\n}\n","import {Vector3} from 'three';\nimport {arraySum, arrayMax} from '../ArrayUtils';\nimport {BaseCorePoint} from '../geometry/entities/point/CorePoint';\nimport {CoreType} from '../Type';\n\nconst _positionSrc = new Vector3();\nconst _positionDest = new Vector3();\n\nexport class CoreInterpolate {\n\tstatic perform(\n\t\tpoint_dest: BaseCorePoint,\n\t\tpoints_src: BaseCorePoint[],\n\t\tattrib_name: string,\n\t\tdistance_threshold: number,\n\t\tblend_with: number\n\t): number {\n\t\tswitch (points_src.length) {\n\t\t\tcase 0:\n\t\t\t\treturn point_dest.attribValue(attrib_name) as number;\n\t\t\tcase 1:\n\t\t\t\treturn this._interpolate_with_1_point(\n\t\t\t\t\tpoint_dest,\n\t\t\t\t\tpoints_src[0],\n\t\t\t\t\tattrib_name,\n\t\t\t\t\tdistance_threshold,\n\t\t\t\t\tblend_with\n\t\t\t\t);\n\t\t\tdefault:\n\t\t\t\treturn this._interpolate_with_multiple_points(\n\t\t\t\t\tpoint_dest,\n\t\t\t\t\tpoints_src,\n\t\t\t\t\tattrib_name,\n\t\t\t\t\tdistance_threshold,\n\t\t\t\t\tblend_with\n\t\t\t\t);\n\t\t}\n\t}\n\n\tstatic _interpolate_with_1_point(\n\t\tpoint_dest: BaseCorePoint,\n\t\tpoint_src: BaseCorePoint,\n\t\tattrib_name: string,\n\t\tdistance_threshold: number,\n\t\tblend_with: number\n\t): number {\n\t\tpoint_dest.position(_positionDest);\n\t\tpoint_src.position(_positionSrc);\n\t\tconst distance = _positionDest.distanceTo(_positionSrc);\n\n\t\tconst value_src = point_src.attribValue(attrib_name);\n\t\tif (CoreType.isNumber(value_src)) {\n\t\t\treturn this._weighted_value_from_distance(\n\t\t\t\tpoint_dest,\n\t\t\t\tvalue_src,\n\t\t\t\tattrib_name,\n\t\t\t\tdistance,\n\t\t\t\tdistance_threshold,\n\t\t\t\tblend_with\n\t\t\t);\n\t\t} else {\n\t\t\tconsole.warn('value is not a number', value_src);\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tstatic _weight_from_distance(distance: number, distance_threshold: number, blend_with: number) {\n\t\treturn (distance - distance_threshold) / blend_with;\n\t}\n\n\tstatic _weighted_value_from_distance(\n\t\tpoint_dest: BaseCorePoint,\n\t\tvalue_src: number,\n\t\tattrib_name: string,\n\t\tdistance: number,\n\t\tdistance_threshold: number,\n\t\tblend_with: number\n\t): number {\n\t\tif (distance <= distance_threshold) {\n\t\t\treturn value_src;\n\t\t} else {\n\t\t\tconst value_dest = point_dest.attribValue(attrib_name);\n\t\t\tif (CoreType.isNumber(value_dest)) {\n\t\t\t\tconst blend = this._weight_from_distance(distance, distance_threshold, blend_with);\n\t\t\t\treturn blend * value_dest + (1 - blend) * value_src;\n\t\t\t} else {\n\t\t\t\tconsole.warn('value is not a number', value_dest);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t}\n\n\tstatic _interpolate_with_multiple_points(\n\t\tpoint_dest: BaseCorePoint,\n\t\tpoints_src: BaseCorePoint[],\n\t\tattrib_name: string,\n\t\tdistance_threshold: number,\n\t\tblend_with: number\n\t): number {\n\t\tconst weighted_values_src = points_src.map((point_src) => {\n\t\t\treturn this._interpolate_with_1_point(point_dest, point_src, attrib_name, distance_threshold, blend_with);\n\t\t});\n\t\treturn arrayMax(weighted_values_src) || 0;\n\t}\n\n\t// https://math.stackexchange.com/questions/1336386/weighted-average-distance-between-3-or-more-positions\n\tstatic weights(current_position: Vector3, other_positions: Vector3[]) {\n\t\tswitch (other_positions.length) {\n\t\t\tcase 1:\n\t\t\t\treturn 1;\n\t\t\tcase 2:\n\t\t\t\treturn this._weights_from_2(current_position, other_positions);\n\t\t\tdefault:\n\t\t\t\tother_positions = other_positions.slice(0, 3);\n\t\t\t\treturn this._weights_from_3(current_position, other_positions);\n\t\t}\n\t}\n\n\tstatic _weights_from_2(current_position: Vector3, other_positions: Vector3[]) {\n\t\tconst dist_to_positions = other_positions.map((other_position) => current_position.distanceTo(other_position));\n\n\t\tconst distance_total = arraySum(dist_to_positions);\n\n\t\treturn [dist_to_positions[1] / distance_total, dist_to_positions[0] / distance_total];\n\t}\n\n\tstatic _weights_from_3(current_position: Vector3, other_positions: Vector3[]) {\n\t\tconst dist_to_positions = other_positions.map((other_position) => current_position.distanceTo(other_position));\n\n\t\tconst distance_total = arraySum([\n\t\t\tdist_to_positions[0] * dist_to_positions[1],\n\t\t\tdist_to_positions[0] * dist_to_positions[2],\n\t\t\tdist_to_positions[1] * dist_to_positions[2],\n\t\t]);\n\n\t\treturn [\n\t\t\t(dist_to_positions[1] * dist_to_positions[2]) / distance_total,\n\t\t\t(dist_to_positions[0] * dist_to_positions[2]) / distance_total,\n\t\t\t(dist_to_positions[0] * dist_to_positions[1]) / distance_total,\n\t\t];\n\t}\n}\n","import {Box3, Vector3, Sphere} from 'three';\nimport {BaseCorePoint} from '../../geometry/entities/point/CorePoint';\nimport {PolyDictionary} from '../../../types/GlobalTypes';\n\nconst _position = new Vector3();\n\nexport type OctreeNodeTraverseCallback = (node: OctreeNode) => void;\n\nexport class OctreeNode {\n\tprivate _leavesByOctant: PolyDictionary<OctreeNode> = {};\n\tprivate _pointsByOctantId: PolyDictionary<BaseCorePoint[]> = {};\n\tprivate _leaves: OctreeNode[] = [];\n\tprivate _center: Vector3;\n\tprivate _boundingBoxesByOctant: PolyDictionary<Box3> = {};\n\tprivate _boundingBoxesByOctantPrepared: boolean = false;\n\n\tconstructor(private _bbox: Box3, private _level: number = 0) {\n\t\tthis._center = this._bbox.max.clone().add(this._bbox.min).multiplyScalar(0.5);\n\t}\n\n\tlevel() {\n\t\treturn this._level;\n\t}\n\n\ttraverse(callback: OctreeNodeTraverseCallback) {\n\t\tcallback(this);\n\t\tconst octants = Object.values(this._leavesByOctant);\n\t\toctants.forEach((node) => {\n\t\t\tnode.traverse(callback);\n\t\t});\n\t}\n\n\tintersectsSphere(sphere: Sphere): boolean {\n\t\tif (this._bbox) {\n\t\t\treturn this._bbox.intersectsSphere(sphere);\n\t\t}\n\t\treturn false;\n\t}\n\n\tpointsInSphere(sphere: Sphere, accumulatedPoints: BaseCorePoint[]): void {\n\t\tif (this._leaves.length == 0) {\n\t\t\tconst foundPoints = Object.values(this._pointsByOctantId).flat();\n\t\t\tconst selectedPoints = foundPoints.filter((point) => sphere.containsPoint(point.position(_position)));\n\t\t\tselectedPoints.forEach((point) => {\n\t\t\t\taccumulatedPoints.push(point);\n\t\t\t});\n\t\t} else {\n\t\t\tconst leaves_intersecting_with_sphere = this._leaves.filter((leaf) => leaf.intersectsSphere(sphere));\n\n\t\t\tleaves_intersecting_with_sphere.forEach((leaf) => leaf.pointsInSphere(sphere, accumulatedPoints));\n\t\t}\n\t}\n\n\tboundingBox(): Box3 | undefined {\n\t\treturn this._bbox;\n\t}\n\n\tsetPoints(points: BaseCorePoint[]) {\n\t\tthis._pointsByOctantId = {};\n\t\tfor (const point of points) {\n\t\t\tthis.addPoint(point);\n\t\t}\n\n\t\tconst octantIds = Object.keys(this._pointsByOctantId);\n\t\tif (octantIds.length > 1) {\n\t\t\tfor (const octantId of octantIds) {\n\t\t\t\tthis.createLeaf(octantId);\n\t\t\t}\n\t\t}\n\t}\n\n\tcreateLeaf(octantId: string) {\n\t\tconst box = this._leafBbox(octantId);\n\t\tconst leaf = new OctreeNode(box, this._level + 1);\n\t\tthis._leavesByOctant[octantId] = leaf;\n\t\tthis._leaves.push(leaf);\n\n\t\tleaf.setPoints(this._pointsByOctantId[octantId]);\n\t}\n\n\taddPoint(point: BaseCorePoint) {\n\t\tconst octantId = this._octantId(point.position(_position));\n\t\tif (this._pointsByOctantId[octantId] == null) {\n\t\t\tthis._pointsByOctantId[octantId] = [];\n\t\t}\n\t\tthis._pointsByOctantId[octantId].push(point);\n\t}\n\n\tprivate _octantId(position: Vector3): string {\n\t\tconst x_pos = position.x > this._center.x ? 1 : 0;\n\t\tconst y_pos = position.y > this._center.y ? 1 : 0;\n\t\tconst z_pos = position.z > this._center.z ? 1 : 0;\n\t\treturn `${x_pos}${y_pos}${z_pos}`;\n\t}\n\n\tprivate _leafBbox(octantId: string): Box3 {\n\t\tif (!this._boundingBoxesByOctantPrepared) {\n\t\t\tthis._prepareLeavesBboxes();\n\t\t\tthis._boundingBoxesByOctantPrepared = true;\n\t\t}\n\t\treturn this._boundingBoxesByOctant[octantId];\n\t}\n\n\tprivate _bboxCenter(x_pos: number, y_pos: number, z_pos: number, target: Vector3): void {\n\t\ttarget.copy(this._bbox.min);\n\t\tif (x_pos == 1) {\n\t\t\ttarget.x = this._bbox.max.x;\n\t\t}\n\t\tif (y_pos == 1) {\n\t\t\ttarget.y = this._bbox.max.y;\n\t\t}\n\t\tif (z_pos == 1) {\n\t\t\ttarget.z = this._bbox.max.z;\n\t\t}\n\n\t\ttarget.add(this._center).multiplyScalar(0.5);\n\t}\n\n\tprivate _prepareLeavesBboxes() {\n\t\tconst bboxCenters = [\n\t\t\tnew Vector3(),\n\t\t\tnew Vector3(),\n\t\t\tnew Vector3(),\n\t\t\tnew Vector3(),\n\t\t\tnew Vector3(),\n\t\t\tnew Vector3(),\n\t\t\tnew Vector3(),\n\t\t\tnew Vector3(),\n\t\t];\n\t\tthis._bboxCenter(0, 0, 0, bboxCenters[0]);\n\t\tthis._bboxCenter(0, 0, 1, bboxCenters[1]);\n\t\tthis._bboxCenter(0, 1, 0, bboxCenters[2]);\n\t\tthis._bboxCenter(0, 1, 1, bboxCenters[3]);\n\t\tthis._bboxCenter(1, 0, 0, bboxCenters[4]);\n\t\tthis._bboxCenter(1, 0, 1, bboxCenters[5]);\n\t\tthis._bboxCenter(1, 1, 0, bboxCenters[6]);\n\t\tthis._bboxCenter(1, 1, 1, bboxCenters[7]);\n\n\t\tconst bboxSizeQuarter = this._bbox.max.clone().sub(this._bbox.min).multiplyScalar(0.25);\n\t\tfor (const bboxCenter of bboxCenters) {\n\t\t\tconst octantId = this._octantId(bboxCenter);\n\t\t\tconst bbox = new Box3(bboxCenter.clone().sub(bboxSizeQuarter), bboxCenter.clone().add(bboxSizeQuarter));\n\t\t\tthis._boundingBoxesByOctant[octantId] = bbox;\n\t\t}\n\t}\n}\n","import {Box3, Sphere, Vector3} from 'three';\nimport {BaseCorePoint} from '../../geometry/entities/point/CorePoint';\nimport {OctreeNode, OctreeNodeTraverseCallback} from './Node';\nimport {arraySortBy} from '../../ArrayUtils';\n\nconst _position = new Vector3();\n\nexport class CoreOctree {\n\tprivate _root: OctreeNode;\n\n\tconstructor(bbox: Box3) {\n\t\tthis._root = new OctreeNode(bbox);\n\t}\n\n\tsetPoints(points: BaseCorePoint[]) {\n\t\tthis._root.setPoints(points);\n\t}\n\n\ttraverse(callback: OctreeNodeTraverseCallback) {\n\t\tthis._root.traverse(callback);\n\t}\n\n\t// TODO: I am tempted to stop going through the leaves if\n\t// the ones currently seen already have the required number of points.\n\t// but that probably doesn't work as those points may end up being further\n\t// than the ones from the following leaf\n\tfindPoints(position: Vector3, distance: number, maxPointsCount: number | null, target: BaseCorePoint[]): void {\n\t\tconst sphere = new Sphere(position, distance);\n\n\t\tif (this._root.intersectsSphere(sphere)) {\n\t\t\tthis._root.pointsInSphere(sphere, target);\n\t\t}\n\n\t\tif (maxPointsCount == null) {\n\t\t\treturn;\n\t\t} else {\n\t\t\tif (target.length > maxPointsCount) {\n\t\t\t\ttarget = arraySortBy(target, (point) => {\n\t\t\t\t\treturn point.position(_position).distanceTo(position);\n\t\t\t\t});\n\n\t\t\t\ttarget = target.slice(0, maxPointsCount);\n\t\t\t}\n\t\t}\n\t}\n}\n","import {Poly} from '../engine/Poly';\n\ntype IterateeMethod = (element: any, index?: number) => void;\ntype IterateeMethodArray = IterateeMethod; // TODO: check this, as the element may be an array\ntype IterateeMethodCount = (index: number) => void;\n\ninterface CoreIteratorOptions {\n\tmax_time_per_chunk?: number;\n\tcheck_every_interations?: number;\n}\n\nexport class CoreIterator {\n\t// array\n\tprivate _array: any[] | undefined;\n\tprivate _iteratee_method_array: IterateeMethodArray | undefined;\n\tprivate _bound_next_with_array: (() => void) | undefined;\n\tprivate _current_array_element: any;\n\tprivate _array_index: number = 0;\n\n\t// count\n\tprivate _count: number = 0;\n\tprivate _iteratee_method_count: IterateeMethodCount | undefined;\n\tprivate _bound_next_with_count: (() => void) | undefined;\n\tprivate _current_count_index: number = 0;\n\n\tprivate _max_time_per_chunk: number;\n\tprivate _check_every_interations: number;\n\n\tprivate _resolve: null | (() => void) = null;\n\n\tconstructor(options: CoreIteratorOptions = {}) {\n\t\tthis._max_time_per_chunk = options.max_time_per_chunk || 10;\n\t\tthis._check_every_interations = options.check_every_interations || 100;\n\t}\n\n\tasync startWithCount(count: number, iteratee_method: IterateeMethodCount): Promise<void> {\n\t\tthis._count = count;\n\t\tthis._current_count_index = 0;\n\t\tthis._iteratee_method_count = iteratee_method;\n\t\tthis._bound_next_with_count = this.nextWithCount.bind(this);\n\n\t\tif (this._resolve) {\n\t\t\tthrow 'an iterator cannot be started twice';\n\t\t}\n\t\treturn new Promise((resolve: () => void, reject) => {\n\t\t\tthis._resolve = resolve;\n\t\t\tthis.nextWithCount();\n\t\t});\n\t}\n\tnextWithCount() {\n\t\tconst performance = Poly.performance.performanceManager();\n\t\tconst start_time = performance.now();\n\n\t\tif (this._iteratee_method_count && this._bound_next_with_count) {\n\t\t\twhile (this._current_count_index < this._count) {\n\t\t\t\tthis._iteratee_method_count(this._current_count_index);\n\n\t\t\t\tthis._current_count_index++;\n\n\t\t\t\tif (this._current_count_index % this._check_every_interations == 0) {\n\t\t\t\t\tif (performance.now() - start_time > this._max_time_per_chunk) {\n\t\t\t\t\t\tsetTimeout(this._bound_next_with_count, 1);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (this._current_count_index >= this._count) {\n\t\t\tif (this._resolve) {\n\t\t\t\tthis._resolve();\n\t\t\t}\n\t\t}\n\t}\n\n\t//\n\t//\n\t// ARRAY\n\t//\n\t//\n\tasync startWithArray(array: any[], iteratee_method: IterateeMethod): Promise<void> {\n\t\tthis._array = array;\n\t\tthis._array_index = 0;\n\t\tthis._iteratee_method_array = iteratee_method;\n\t\tthis._bound_next_with_array = this.nextWithArray.bind(this);\n\n\t\tif (this._resolve) {\n\t\t\tthrow 'an iterator cannot be started twice';\n\t\t}\n\t\treturn new Promise((resolve: () => void, reject) => {\n\t\t\tthis._resolve = resolve;\n\t\t\tthis.nextWithArray();\n\t\t});\n\t}\n\tnextWithArray() {\n\t\tconst performance = Poly.performance.performanceManager();\n\t\tconst start_time = performance.now();\n\n\t\tif (this._iteratee_method_array && this._bound_next_with_array && this._array) {\n\t\t\twhile ((this._current_array_element = this._array[this._array_index])) {\n\t\t\t\tthis._iteratee_method_array(this._current_array_element, this._array_index);\n\n\t\t\t\tthis._array_index++;\n\n\t\t\t\tif (this._array_index % this._check_every_interations == 0) {\n\t\t\t\t\tif (performance.now() - start_time > this._max_time_per_chunk) {\n\t\t\t\t\t\tsetTimeout(this._bound_next_with_array, 1);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (this._current_array_element === undefined) {\n\t\t\tif (this._resolve) {\n\t\t\t\tthis._resolve();\n\t\t\t}\n\t\t}\n\t}\n}\n","/**\n * Transfers an attribute from right input to left input\n *\n * @remarks\n * This can be useful to create heatmap.\n *\n */\nimport {TypedSopNode} from './_Base';\nimport type {BaseCorePoint, CorePoint} from '../../../core/geometry/entities/point/CorePoint';\nimport {CoreGroup} from '../../../core/geometry/Group';\nimport {CoreInterpolate} from '../../../core/math/Interpolate';\nimport {CoreOctree} from '../../../core/math/octree/Octree';\nimport {CoreIterator} from '../../../core/Iterator';\nimport {NodeParamsConfig, ParamConfig} from '../utils/params/ParamsConfig';\nimport {InputCloneMode} from '../../poly/InputCloneMode';\nimport {Box3, Vector3} from 'three';\nimport {SopType} from '../../poly/registers/nodes/types/Sop';\nimport {corePointClassFactory} from '../../../core/geometry/CoreObjectFactory';\nimport {CoreObjectType, ObjectContent} from '../../../core/geometry/ObjectContent';\nimport {pointsFromObjectFromGroup} from '../../../core/geometry/entities/point/CorePointUtils';\n\nconst _tmpBox = new Box3();\nconst _position = new Vector3();\nconst _nearestPoints: BaseCorePoint[] = [];\nconst _pointsSrc: CorePoint<CoreObjectType>[] = [];\nclass AttribTransferSopParamsConfig extends NodeParamsConfig {\n\t/** @param source group to transfer from (right input, or input 1) */\n\tsrcGroup = ParamConfig.STRING();\n\t/** @param dest group to transfer to (left input, or input 0) */\n\tdestGroup = ParamConfig.STRING();\n\t/** @param name of the attribute to transfer */\n\tname = ParamConfig.STRING();\n\t/** @param max number of samples to use */\n\tmaxSamplesCount = ParamConfig.INTEGER(1, {\n\t\trange: [1, 10],\n\t\trangeLocked: [true, false],\n\t});\n\t/** @param max distance to search points to transfer from */\n\tdistanceThreshold = ParamConfig.FLOAT(1);\n\t/** @param blend width */\n\tblendWidth = ParamConfig.FLOAT(0);\n}\nconst ParamsConfig = new AttribTransferSopParamsConfig();\n\nexport class AttribTransferSopNode extends TypedSopNode<AttribTransferSopParamsConfig> {\n\toverride paramsConfig = ParamsConfig;\n\tstatic override type() {\n\t\treturn SopType.ATTRIB_TRANSFER;\n\t}\n\n\toverride initializeNode() {\n\t\tthis.io.inputs.setCount(2);\n\t\tthis.io.inputs.initInputsClonedState([InputCloneMode.FROM_NODE, InputCloneMode.NEVER]);\n\t}\n\n\toverride async cook(inputCoreGroups: CoreGroup[]) {\n\t\tconst coreGroupDest = inputCoreGroups[0];\n\t\tconst coreGroupSrc = inputCoreGroups[1];\n\n\t\t// build octree\n\t\tcoreGroupSrc.pointsFromGroup(this.pv.srcGroup, _pointsSrc);\n\t\tcoreGroupSrc.boundingBox(_tmpBox);\n\t\tconst octree = new CoreOctree(_tmpBox);\n\t\toctree.setPoints(_pointsSrc);\n\n\t\t// transfer\n\t\tconst destObjects = coreGroupDest.allObjects();\n\t\tconst srcObjects = coreGroupSrc.allObjects();\n\t\tlet i = 0;\n\t\tfor (const destObject of destObjects) {\n\t\t\tconst srcObject = srcObjects[i];\n\t\t\tconst corePointClass = corePointClassFactory(destObject);\n\t\t\tconst attributeNames = corePointClass.attributeNamesMatchingMask(srcObject, this.pv.name);\n\t\t\tthis._addAttributeIfRequired(destObject, srcObject, attributeNames);\n\t\t\tawait this._transferAttributes(destObject, octree, attributeNames);\n\t\t\ti++;\n\t\t}\n\t\tthis.setCoreGroup(coreGroupDest);\n\t}\n\n\tprivate async _transferAttributes<T extends CoreObjectType>(\n\t\tobject: ObjectContent<T>,\n\t\toctree: CoreOctree,\n\t\tattribNames: string[]\n\t) {\n\t\tconst callback = (destPoint: BaseCorePoint) => {\n\t\t\tthis._transferAttributesForPoint(destPoint, octree, attribNames);\n\t\t};\n\t\tconst destPoints: CorePoint<CoreObjectType>[] = [];\n\t\tpointsFromObjectFromGroup(object, this.pv.destGroup, destPoints);\n\t\tconst _iterator = new CoreIterator();\n\n\t\tawait _iterator.startWithArray(destPoints, callback);\n\t}\n\n\tprivate _addAttributeIfRequired<T extends CoreObjectType>(\n\t\tdestObject: ObjectContent<T>,\n\t\tsrcObject: ObjectContent<T>,\n\t\tattribNames: string[]\n\t) {\n\t\tfor (const attribName of attribNames) {\n\t\t\tconst corePointClass = corePointClassFactory(destObject);\n\t\t\tconst hasAttrib = corePointClass.hasAttribute(destObject, attribName);\n\t\t\tif (!hasAttrib) {\n\t\t\t\tconst attribSize = corePointClass.attribSize(srcObject, attribName);\n\t\t\t\tcorePointClass.addNumericAttribute(destObject, attribName, attribSize, 0);\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate _transferAttributesForPoint(destPoint: BaseCorePoint, octree: CoreOctree, attribNames: string[]) {\n\t\tconst totalDist = this.pv.distanceThreshold + this.pv.blendWidth;\n\t\tdestPoint.position(_position);\n\t\toctree.findPoints(_position, totalDist, this.pv.maxSamplesCount, _nearestPoints);\n\n\t\tfor (const attribName of attribNames) {\n\t\t\tthis._interpolatePoints(destPoint, _nearestPoints, attribName);\n\t\t}\n\t}\n\n\tprivate _interpolatePoints(pointDest: BaseCorePoint, srcPoints: BaseCorePoint[], attribName: string) {\n\t\tconst newValue = CoreInterpolate.perform(\n\t\t\tpointDest,\n\t\t\tsrcPoints,\n\t\t\tattribName,\n\t\t\tthis.pv.distanceThreshold,\n\t\t\tthis.pv.blendWidth\n\t\t);\n\n\t\tif (newValue != null) {\n\t\t\tpointDest.setAttribValue(attribName, newValue);\n\t\t}\n\t}\n}\n","/**\n * Adds the name of notes into a string attribute.\n *\n * @remarks\n * This node is designed to work with audio nodes, and the event/raycast\n *\n */\nimport {TypedSopNode} from './_Base';\nimport {AttribClassMenuEntries, AttribClass, ATTRIBUTE_CLASSES} from '../../../core/geometry/Constant';\nimport {CoreGroup} from '../../../core/geometry/Group';\n\nimport {NodeParamsConfig, ParamConfig} from '../utils/params/ParamsConfig';\nimport {AudioNotesSopOperation, OUT_OF_RANGE_BEHAVIOR} from '../../operations/sop/AudioNotes';\nimport {SopType} from '../../poly/registers/nodes/types/Sop';\n\nconst DEFAULT = AudioNotesSopOperation.DEFAULT_PARAMS;\n\nclass AudioNotesSopParamsConfig extends NodeParamsConfig {\n\t/** @param the attribute class (geometry or object) */\n\tclass = ParamConfig.INTEGER(DEFAULT.class, {\n\t\tmenu: {\n\t\t\tentries: AttribClassMenuEntries,\n\t\t},\n\t});\n\t/** @param attribute name */\n\tname = ParamConfig.STRING(DEFAULT.name);\n\t/** @param adds an octave attribute */\n\ttoctave = ParamConfig.BOOLEAN(0);\n\t/** @param octave attribute name */\n\toctaveName = ParamConfig.STRING(DEFAULT.octaveName, {\n\t\tvisibleIf: {toctave: 1},\n\t});\n\t/** @param octave to start iterating the notes from */\n\tstartOctave = ParamConfig.INTEGER(DEFAULT.startOctave, {range: [1, 8], rangeLocked: [true, true]});\n\t/** @param last octave up to which the nodes will be added */\n\tendOctave = ParamConfig.INTEGER(DEFAULT.endOctave, {range: [1, 8], rangeLocked: [true, true]});\n\t/** @param behavior if there are more objects than notes within the selected octave range */\n\toutOfRangeBehavior = ParamConfig.INTEGER(DEFAULT.outOfRangeBehavior, {\n\t\tmenu: {\n\t\t\tentries: OUT_OF_RANGE_BEHAVIOR.map((name, i) => {\n\t\t\t\treturn {value: i, name};\n\t\t\t}),\n\t\t},\n\t});\n}\nconst ParamsConfig = new AudioNotesSopParamsConfig();\nexport class AudioNotesSopNode extends TypedSopNode<AudioNotesSopParamsConfig> {\n\toverride paramsConfig = ParamsConfig;\n\tstatic override type() {\n\t\treturn SopType.AUDIO_NOTES;\n\t}\n\n\toverride initializeNode() {\n\t\tthis.io.inputs.setCount(1);\n\t\tthis.io.inputs.initInputsClonedState(AudioNotesSopOperation.INPUT_CLONED_STATE);\n\t}\n\n\tprivate _operation: AudioNotesSopOperation | undefined;\n\toverride cook(input_contents: CoreGroup[]) {\n\t\tthis._operation = this._operation || new AudioNotesSopOperation(this.scene(), this.states, this);\n\t\tconst core_group = this._operation.cook(input_contents, this.pv);\n\t\tthis.setCoreGroup(core_group);\n\t}\n\n\t//\n\t//\n\t// API UTILS\n\t//\n\t//\n\tsetAttribClass(attribClass: AttribClass) {\n\t\tthis.p.class.set(ATTRIBUTE_CLASSES.indexOf(attribClass));\n\t}\n\tattribClass() {\n\t\treturn ATTRIBUTE_CLASSES[this.pv.class];\n\t}\n}\n","/**\n * scatters points inside the bounding box of an object\n *\n * @remarks\n * This can be useful to quickly create points in a volume.\n *\n */\nimport {TypedSopNode} from './_Base';\nimport {NodeParamsConfig, ParamConfig} from '../utils/params/ParamsConfig';\nimport {CoreGroup} from '../../../core/geometry/Group';\nimport {InputCloneMode} from '../../poly/InputCloneMode';\nimport {BboxScatterSopOperation} from '../../operations/sop/BboxScatter';\nimport {SopType} from '../../poly/registers/nodes/types/Sop';\nclass BboxScatterSopParamsConfig extends NodeParamsConfig {\n\t/** @param the smaller the step size, the more points this will create */\n\tstepSize = ParamConfig.FLOAT(0.1);\n}\nconst ParamsConfig = new BboxScatterSopParamsConfig();\n\nexport class BboxScatterSopNode extends TypedSopNode<BboxScatterSopParamsConfig> {\n\toverride paramsConfig = ParamsConfig;\n\tstatic override type() {\n\t\treturn SopType.BBOX_SCATTER;\n\t}\n\n\toverride initializeNode() {\n\t\tthis.io.inputs.setCount(1);\n\t\tthis.io.inputs.initInputsClonedState(InputCloneMode.NEVER);\n\t}\n\n\tprivate _operation: BboxScatterSopOperation | undefined;\n\toverride cook(input_contents: CoreGroup[]) {\n\t\tthis._operation = this._operation || new BboxScatterSopOperation(this._scene, this.states, this);\n\t\tconst core_group = this._operation.cook(input_contents, this.pv);\n\t\tthis.setCoreGroup(core_group);\n\t}\n}\n","/**\n * boolean operation\n *\n */\nimport {TypedSopNode} from './_Base';\nimport {BooleanOperation, BooleanSopOperation, BOOLEAN_OPERATIONS} from '../../operations/sop/Boolean';\nimport {NodeParamsConfig, ParamConfig} from '../utils/params/ParamsConfig';\nimport {CoreGroup} from '../../../core/geometry/Group';\nconst DEFAULT = BooleanSopOperation.DEFAULT_PARAMS;\nclass BooleanSopParamsConfig extends NodeParamsConfig {\n\t/** @param url to load the geometry from */\n\toperation = ParamConfig.INTEGER(DEFAULT.operation, {\n\t\tmenu: {\n\t\t\tentries: BOOLEAN_OPERATIONS.map((name, value) => {\n\t\t\t\treturn {name, value};\n\t\t\t}),\n\t\t},\n\t\tseparatorAfter: true,\n\t});\n\t/** @param preserves the color attribute of both input */\n\tkeepVertexColor = ParamConfig.BOOLEAN(DEFAULT.keepVertexColor);\n\t/** @param add any additional attribute to be preserved */\n\tadditionalAttributes = ParamConfig.STRING(DEFAULT.additionalAttributes, {\n\t\tseparatorAfter: true,\n\t});\n\t/** @param defines if only the material from the first input is used, or if the ones from both inputs should be used */\n\tkeepMaterials = ParamConfig.BOOLEAN(DEFAULT.keepMaterials);\n\t/** @param if one of the input has multiple material for a single object, and you'd like to preserve those, toggle this on */\n\tuseInputGroups = ParamConfig.BOOLEAN(DEFAULT.useInputGroups);\n\t/** @param intersectionEdgesOnly */\n\tintersectionEdgesOnly = ParamConfig.BOOLEAN(DEFAULT.intersectionEdgesOnly);\n}\nconst ParamsConfig = new BooleanSopParamsConfig();\n\nexport class BooleanSopNode extends TypedSopNode<BooleanSopParamsConfig> {\n\toverride paramsConfig = ParamsConfig;\n\tstatic override type() {\n\t\treturn 'boolean';\n\t}\n\n\toverride initializeNode() {\n\t\tthis.io.inputs.setCount(2);\n\t\tthis.io.inputs.initInputsClonedState(BooleanSopOperation.INPUT_CLONED_STATE);\n\t}\n\tsetOperation(operation: BooleanOperation) {\n\t\tthis.p.operation.set(BOOLEAN_OPERATIONS.indexOf(operation));\n\t}\n\n\tprivate _operation: BooleanSopOperation | undefined;\n\toverride cook(inputCoreGroups: CoreGroup[]) {\n\t\tthis._operation = this._operation || new BooleanSopOperation(this.scene(), this.states, this);\n\t\tconst coreGroup = this._operation.cook(inputCoreGroups, this.pv);\n\t\tthis.setCoreGroup(coreGroup);\n\t}\n}\n","/**\n * Creates a box.\n *\n * @remarks\n * If the node has no input, you can control the radius and center of the box. If the node has an input, it will create a box that encompasses the input geometry.\n *\n */\n\nimport {TypedSopNode} from './_Base';\nimport {CoreGroup} from '../../../core/geometry/Group';\nimport {BoxSopOperation} from '../../operations/sop/Box';\n\nimport {NodeParamsConfig, ParamConfig} from '../utils/params/ParamsConfig';\nimport {SopType} from '../../poly/registers/nodes/types/Sop';\nconst DEFAULT = BoxSopOperation.DEFAULT_PARAMS;\nclass BoxSopParamsConfig extends NodeParamsConfig {\n\t/** @param size of the box */\n\tsize = ParamConfig.FLOAT(DEFAULT.size, {\n\t\trange: [0, 2],\n\t\trangeLocked: [true, false],\n\t});\n\t/** @param sizes on each axis */\n\tsizes = ParamConfig.VECTOR3(DEFAULT.sizes);\n\t/** @param number of segments on each axis */\n\tdivisions = ParamConfig.VECTOR3(DEFAULT.divisions);\n\t/** @param center of the geometry */\n\tcenter = ParamConfig.VECTOR3(DEFAULT.center);\n}\nconst ParamsConfig = new BoxSopParamsConfig();\n\nexport class BoxSopNode extends TypedSopNode<BoxSopParamsConfig> {\n\toverride readonly paramsConfig = ParamsConfig;\n\tstatic override type() {\n\t\treturn SopType.BOX;\n\t}\n\n\tprotected override initializeNode() {\n\t\tthis.io.inputs.setCount(0, 1);\n\t\tthis.io.inputs.initInputsClonedState(BoxSopOperation.INPUT_CLONED_STATE);\n\t}\n\n\tprivate _operation: BoxSopOperation | undefined;\n\toverride cook(inputCoreGroups: CoreGroup[]) {\n\t\tthis._operation = this._operation || new BoxSopOperation(this._scene, this.states, this);\n\t\tconst coreGroup = this._operation.cook(inputCoreGroups, this.pv);\n\t\tthis.setCoreGroup(coreGroup);\n\t}\n}\n","/**\n * Creates a box made of lines.\n *\n * @remarks\n * What this node creates is different than a box mesh with a wireframe material applied, in the sense that this will not create triangles.\n *\n */\n\nimport {TypedSopNode} from './_Base';\nimport {CoreGroup} from '../../../core/geometry/Group';\nimport {BoxLinesSopOperation} from '../../operations/sop/BoxLines';\n\nimport {NodeParamsConfig, ParamConfig} from '../utils/params/ParamsConfig';\nimport {SopType} from '../../poly/registers/nodes/types/Sop';\nconst DEFAULT = BoxLinesSopOperation.DEFAULT_PARAMS;\nclass BoxLinesSopParamsConfig extends NodeParamsConfig {\n\t/** @param size of the box */\n\tsize = ParamConfig.FLOAT(DEFAULT.size, {\n\t\trange: [0, 2],\n\t\trangeLocked: [true, false],\n\t});\n\t/** @param sizes on each axis */\n\tsizes = ParamConfig.VECTOR3(DEFAULT.sizes);\n\t/** @param divisions on each axis */\n\tdivisions = ParamConfig.VECTOR3(DEFAULT.divisions);\n\t/** @param center of the geometry */\n\tcenter = ParamConfig.VECTOR3(DEFAULT.center);\n}\nconst ParamsConfig = new BoxLinesSopParamsConfig();\n\nexport class BoxLinesSopNode extends TypedSopNode<BoxLinesSopParamsConfig> {\n\toverride readonly paramsConfig = ParamsConfig;\n\tstatic override type() {\n\t\treturn SopType.BOX_LINES;\n\t}\n\n\tprotected override initializeNode() {\n\t\tthis.io.inputs.setCount(0, 1);\n\t\tthis.io.inputs.initInputsClonedState(BoxLinesSopOperation.INPUT_CLONED_STATE);\n\t}\n\n\tprivate _operation: BoxLinesSopOperation | undefined;\n\toverride cook(inputCoreGroups: CoreGroup[]) {\n\t\tthis._operation = this._operation || new BoxLinesSopOperation(this._scene, this.states, this);\n\t\tconst coreGroup = this._operation.cook(inputCoreGroups, this.pv);\n\t\tthis.setCoreGroup(coreGroup);\n\t}\n}\n","/**\n * Applies a boolean operation\n *\n *\n */\nimport {CADSopNode} from './_BaseCAD';\nimport {NodeParamsConfig, ParamConfig} from '../utils/params/ParamsConfig';\n// import {CadCoreGroup} from '../../../core/geometry/modules/cad/CadCoreGroup';\nimport {\n\tOpenCascadeInstance,\n\tTopoDS_Shape,\n\tCadGeometryTypeShape,\n\tcadGeometryTypeFromShape,\n} from '../../../core/geometry/modules/cad/CadCommon';\nimport {CadGeometryType} from '../../../core/geometry/modules/cad/CadCommon';\nimport {CadObject} from '../../../core/geometry/modules/cad/CadObject';\nimport {TypeAssert} from '../../poly/Assert';\nimport {SopType} from '../../poly/registers/nodes/types/Sop';\nimport {CoreGroup} from '../../../core/geometry/Group';\nimport {CadLoaderSync} from '../../../core/geometry/modules/cad/CadLoaderSync';\n\nenum BooleanMode {\n\tALL_IN_SEQUENCE = 'process all in sequence',\n\tONE_TO_ONE = 'one to one',\n\tONE_TO_MANY = 'one to many',\n}\nconst BOOLEAN_MODES: BooleanMode[] = [BooleanMode.ALL_IN_SEQUENCE, BooleanMode.ONE_TO_ONE, BooleanMode.ONE_TO_MANY];\n\nexport enum BooleanCadOperationType {\n\tINTERSECT = 'intersect',\n\tSECTION = 'section',\n\tSUBTRACT = 'subtract',\n\tUNION = 'union',\n}\nexport const BOOLEAN_CAD_OPERATION_TYPES: BooleanCadOperationType[] = [\n\tBooleanCadOperationType.INTERSECT,\n\tBooleanCadOperationType.SUBTRACT,\n\tBooleanCadOperationType.UNION,\n\tBooleanCadOperationType.SECTION,\n];\n\nclass CADBooleanSopParamsConfig extends NodeParamsConfig {\n\t/** @param operation */\n\toperation = ParamConfig.INTEGER(BOOLEAN_CAD_OPERATION_TYPES.indexOf(BooleanCadOperationType.INTERSECT), {\n\t\tmenu: {entries: BOOLEAN_CAD_OPERATION_TYPES.map((name, value) => ({name, value}))},\n\t});\n\t/** @param mode */\n\tmode = ParamConfig.INTEGER(BOOLEAN_MODES.indexOf(BooleanMode.ONE_TO_MANY), {\n\t\tmenu: {\n\t\t\tentries: BOOLEAN_MODES.map((name, value) => ({name, value})),\n\t\t},\n\t});\n}\nconst ParamsConfig = new CADBooleanSopParamsConfig();\n\nexport class CADBooleanSopNode extends CADSopNode<CADBooleanSopParamsConfig> {\n\toverride paramsConfig = ParamsConfig;\n\tstatic override type() {\n\t\treturn SopType.CAD_BOOLEAN;\n\t}\n\tprotected override initializeNode() {\n\t\tthis.io.inputs.setCount(1, 2);\n\t}\n\tsetOperation(operation: BooleanCadOperationType) {\n\t\tthis.p.operation.set(BOOLEAN_CAD_OPERATION_TYPES.indexOf(operation));\n\t}\n\n\toverride cook(inputCoreGroups: CoreGroup[]) {\n\t\tconst oc = CadLoaderSync.oc();\n\n\t\tconst operation = BOOLEAN_CAD_OPERATION_TYPES[this.pv.operation];\n\n\t\tconst mode = BOOLEAN_MODES[this.pv.mode];\n\t\tswitch (mode) {\n\t\t\tcase BooleanMode.ALL_IN_SEQUENCE: {\n\t\t\t\treturn this._createBooleansAllInSequence(oc, operation, inputCoreGroups);\n\t\t\t}\n\t\t\tcase BooleanMode.ONE_TO_ONE: {\n\t\t\t\treturn this._createBooleansOneToOne(oc, operation, inputCoreGroups);\n\t\t\t}\n\t\t\tcase BooleanMode.ONE_TO_MANY: {\n\t\t\t\treturn this._createBooleansOneToMany(oc, operation, inputCoreGroups);\n\t\t\t}\n\t\t}\n\t\tTypeAssert.unreachable(mode);\n\t}\n\n\tprivate _createBooleansAllInSequence(\n\t\toc: OpenCascadeInstance,\n\t\toperation: BooleanCadOperationType,\n\t\tinputCoreGroups: CoreGroup[]\n\t) {\n\t\tconst newObjects: CadObject<CadGeometryType>[] = [];\n\t\tconst inputCoreGroup0 = inputCoreGroups[0];\n\t\tconst inputCoreGroup1 = inputCoreGroups[1];\n\t\tlet shapeObjects0 = inputCoreGroup0.cadObjectsWithShape();\n\t\tif (shapeObjects0) {\n\t\t\tif (inputCoreGroup1) {\n\t\t\t\tconst shapeObjects1 = inputCoreGroup1.cadObjectsWithShape();\n\t\t\t\tif (shapeObjects1) {\n\t\t\t\t\tshapeObjects0 = shapeObjects0.concat(shapeObjects1);\n\t\t\t\t}\n\t\t\t}\n\t\t\t// TODO: shapes with same types should be processed together?\n\t\t\t// Or maybe not if dealing with curves and surfaces\n\t\t\t_createBooleansAllInSequence(oc, operation, shapeObjects0, newObjects);\n\t\t}\n\t\tthis.setCADObjects(newObjects);\n\t}\n\tprivate _createBooleansOneToOne(\n\t\toc: OpenCascadeInstance,\n\t\toperation: BooleanCadOperationType,\n\t\tinputCoreGroups: CoreGroup[]\n\t) {\n\t\tconst newObjects: CadObject<CadGeometryType>[] = [];\n\t\tconst inputCoreGroup0 = inputCoreGroups[0];\n\t\tconst inputCoreGroup1 = inputCoreGroups[1];\n\n\t\tif (!inputCoreGroup1) {\n\t\t\tthis.states.error.set('input 1 required for this mode');\n\t\t\treturn;\n\t\t}\n\t\tconst shapeObjects0 = inputCoreGroup0.cadObjectsWithShape();\n\t\tconst shapeObjects1 = inputCoreGroup1.cadObjectsWithShape();\n\n\t\tif (shapeObjects0 && shapeObjects1) {\n\t\t\t_createBooleansOneToOne(oc, operation, shapeObjects0, shapeObjects1, newObjects);\n\t\t}\n\t\tthis.setCADObjects(newObjects);\n\t}\n\tprivate _createBooleansOneToMany(\n\t\toc: OpenCascadeInstance,\n\t\toperation: BooleanCadOperationType,\n\t\tinputCoreGroups: CoreGroup[]\n\t) {\n\t\tconst newObjects: CadObject<CadGeometryType>[] = [];\n\t\tconst inputCoreGroup0 = inputCoreGroups[0];\n\t\tconst inputCoreGroup1 = inputCoreGroups[1];\n\t\tif (!inputCoreGroup1) {\n\t\t\tthis.states.error.set('input 1 required for this mode');\n\t\t\treturn;\n\t\t}\n\t\tconst shapeObjects0 = inputCoreGroup0.cadObjectsWithShape();\n\t\tconst shapeObjects1 = inputCoreGroup1.cadObjectsWithShape();\n\t\tif (shapeObjects0 && shapeObjects1) {\n\t\t\t_createBooleansOneToMany(oc, operation, shapeObjects0, shapeObjects1, newObjects);\n\t\t}\n\n\t\tthis.setCADObjects(newObjects);\n\t}\n\n\t// override async cook(inputCoreGroups: CadCoreGroup[]) {\n\t// \tconst oc = await CadLoader.core();\n\t// \tconst coreGroup0 = inputCoreGroups[0];\n\t// \tconst coreGroup1 = inputCoreGroups[1];\n\n\t// \tconst object0 = coreGroup0.objects()[0];\n\t// \tconst object1 = coreGroup1.objects()[0];\n\n\t// \tconst operation = BOOLEAN_CAD_OPERATION_TYPES[this.pv.operation];\n\t// \tconst apiClass = {\n\t// \t\t[BooleanCadOperationType.INTERSECT]: oc.BRepAlgoAPI_Common_3,\n\t// \t\t[BooleanCadOperationType.SUBTRACT]: oc.BRepAlgoAPI_Cut_3,\n\t// \t\t[BooleanCadOperationType.UNION]: oc.BRepAlgoAPI_Fuse_3,\n\t// \t\t[BooleanCadOperationType.SECTION]: oc.BRepAlgoAPI_Section_3,\n\t// \t}[operation];\n\n\t// \tif (object0 && object1 && CoreCadType.isShape(object0) && CoreCadType.isShape(object1)) {\n\t// \t\tconst cut = new apiClass(object0.object(), object1.object(), new oc.Message_ProgressRange_1());\n\t// \t\tcut.Build(new oc.Message_ProgressRange_1());\n\n\t// \t\tconst shape = cut.Shape();\n\t// \t\tthis.setShell(shape);\n\t// \t} else {\n\t// \t\tthis.setCadObjects([object0]);\n\t// \t}\n\t// }\n}\nfunction _createBooleansAllInSequence(\n\toc: OpenCascadeInstance,\n\toperation: BooleanCadOperationType,\n\tshapeObjects: CadObject<CadGeometryTypeShape>[],\n\tnewObjects: CadObject<CadGeometryType>[]\n) {\n\tlet previousShape: TopoDS_Shape | undefined;\n\tfor (const shapeObject of shapeObjects) {\n\t\tif (previousShape) {\n\t\t\tconst newShape = _booleanOperation(oc, operation, previousShape, shapeObject.cadGeometry());\n\t\t\tpreviousShape = newShape;\n\t\t} else {\n\t\t\tpreviousShape = shapeObject.cadGeometry();\n\t\t}\n\t}\n\tif (previousShape) {\n\t\tconst type = cadGeometryTypeFromShape(oc, previousShape);\n\t\tif (type) {\n\t\t\tnewObjects.push(new CadObject(previousShape, type));\n\t\t} else {\n\t\t\tconsole.log('no type', previousShape);\n\t\t}\n\t}\n}\nfunction _createBooleansOneToOne(\n\toc: OpenCascadeInstance,\n\toperation: BooleanCadOperationType,\n\tshapeObjects0: CadObject<CadGeometryTypeShape>[],\n\tshapeObjects1: CadObject<CadGeometryTypeShape>[],\n\tnewObjects: CadObject<CadGeometryType>[]\n) {\n\tconst minVerticesCount = Math.min(shapeObjects0.length, shapeObjects1.length);\n\tfor (let i = 0; i < minVerticesCount; i++) {\n\t\tconst shape0 = shapeObjects0[i].cadGeometry();\n\t\tconst shape1 = shapeObjects1[i].cadGeometry();\n\t\tconst newShape = _booleanOperation(oc, operation, shape0, shape1);\n\t\tconst type = cadGeometryTypeFromShape(oc, newShape);\n\t\tif (type) {\n\t\t\tnewObjects.push(new CadObject(newShape, type));\n\t\t} else {\n\t\t\tconsole.log('no type', newShape);\n\t\t}\n\t}\n}\nfunction _createBooleansOneToMany(\n\toc: OpenCascadeInstance,\n\toperation: BooleanCadOperationType,\n\tshapeObjects0: CadObject<CadGeometryTypeShape>[],\n\tshapeObjects1: CadObject<CadGeometryTypeShape>[],\n\tnewObjects: CadObject<CadGeometryType>[]\n) {\n\tfor (const shapeObject0 of shapeObjects0) {\n\t\tlet previousBooleanShapeResult: TopoDS_Shape = shapeObject0.cadGeometry();\n\t\tfor (const shapeObject1 of shapeObjects1) {\n\t\t\tpreviousBooleanShapeResult = _booleanOperation(\n\t\t\t\toc,\n\t\t\t\toperation,\n\t\t\t\tpreviousBooleanShapeResult,\n\t\t\t\tshapeObject1.cadGeometry()\n\t\t\t);\n\t\t}\n\t\tif (previousBooleanShapeResult) {\n\t\t\tconst type = cadGeometryTypeFromShape(oc, previousBooleanShapeResult);\n\t\t\tif (type) {\n\t\t\t\tnewObjects.push(new CadObject(previousBooleanShapeResult, type));\n\t\t\t} else {\n\t\t\t\tconsole.log('no type', previousBooleanShapeResult);\n\t\t\t}\n\t\t}\n\t\t// return previousBooleanShapeResult;\n\t}\n}\n\nfunction _booleanOperation(\n\toc: OpenCascadeInstance,\n\toperation: BooleanCadOperationType,\n\tshape0: TopoDS_Shape,\n\tshape1: TopoDS_Shape\n) {\n\tswitch (operation) {\n\t\tcase BooleanCadOperationType.INTERSECT: {\n\t\t\treturn _booleanOperationIntersect(oc, shape0, shape1);\n\t\t}\n\t\tcase BooleanCadOperationType.SUBTRACT: {\n\t\t\treturn _booleanOperationSubtract(oc, shape0, shape1);\n\t\t}\n\t\tcase BooleanCadOperationType.UNION: {\n\t\t\treturn _booleanOperationUnion(oc, shape0, shape1);\n\t\t}\n\t\tcase BooleanCadOperationType.SECTION: {\n\t\t\treturn _booleanOperationSection(oc, shape0, shape1);\n\t\t}\n\t}\n\tTypeAssert.unreachable(operation);\n}\n\nfunction _booleanOperationIntersect(oc: OpenCascadeInstance, shape0: TopoDS_Shape, shape1: TopoDS_Shape) {\n\tconst operation = new oc.BRepAlgoAPI_Common_3(shape0, shape1, CadLoaderSync.Message_ProgressRange);\n\toperation.Build(CadLoaderSync.Message_ProgressRange);\n\n\tconst shape = operation.Shape();\n\toperation.delete();\n\treturn shape;\n}\nfunction _booleanOperationSubtract(oc: OpenCascadeInstance, shape0: TopoDS_Shape, shape1: TopoDS_Shape) {\n\tconst operation = new oc.BRepAlgoAPI_Cut_3(shape0, shape1, CadLoaderSync.Message_ProgressRange);\n\toperation.Build(CadLoaderSync.Message_ProgressRange);\n\n\tconst shape = operation.Shape();\n\toperation.delete();\n\treturn shape;\n}\nfunction _booleanOperationUnion(oc: OpenCascadeInstance, shape0: TopoDS_Shape, shape1: TopoDS_Shape) {\n\tconst operation = new oc.BRepAlgoAPI_Fuse_3(shape0, shape1, CadLoaderSync.Message_ProgressRange);\n\toperation.Build(CadLoaderSync.Message_ProgressRange);\n\n\tconst shape = operation.Shape();\n\toperation.delete();\n\treturn shape;\n}\nfunction _booleanOperationSection(oc: OpenCascadeInstance, shape0: TopoDS_Shape, shape1: TopoDS_Shape) {\n\tconst operation = new oc.BRepAlgoAPI_Section_3(shape0, shape1, true);\n\t// cut.Build(CadLoaderSync.Message_ProgressRange);\n\n\tconst shape = operation.Shape();\n\toperation.delete();\n\treturn shape;\n}\n","/**\n * converts points and curves from 2D to 3D and vice-versa\n *\n *\n */\nimport {CADSopNode} from './_BaseCAD';\nimport {NodeParamsConfig, ParamConfig} from '../utils/params/ParamsConfig';\nimport {CoreCadType} from '../../../core/geometry/modules/cad/CadCoreType';\nimport {cadPlaneXY} from '../../../core/geometry/modules/cad/CadMath';\nimport {OpenCascadeInstance, CadGeometryType, gp_Pln} from '../../../core/geometry/modules/cad/CadCommon';\nimport {gp_Pnt2d, Geom2d_Curve, TopoDS_Vertex, TopoDS_Edge} from '../../../core/geometry/modules/cad/CadCommon';\nimport {cadVertexCreate} from '../../../core/geometry/modules/cad/toObject3D/CadVertex';\nimport {curveDataFromEdge, cadEdgeCreate} from '../../../core/geometry/modules/cad/toObject3D/CadEdge';\nimport {Vector3} from 'three';\nimport {CoreGroup} from '../../../core/geometry/Group';\nimport {SopType} from '../../poly/registers/nodes/types/Sop';\nimport {CadObject} from '../../../core/geometry/modules/cad/CadObject';\nimport {CadLoaderSync} from '../../../core/geometry/modules/cad/CadLoaderSync';\n\nexport enum ConversionMode {\n\tTO_2D = 'to 2D',\n\tTO_3D = 'to 3D',\n}\nexport const CONVERSION_MODES: ConversionMode[] = [ConversionMode.TO_2D, ConversionMode.TO_3D];\n\nclass CADConvertDimensionSopParamsConfig extends NodeParamsConfig {\n\t/** @param mode */\n\tmode = ParamConfig.INTEGER(CONVERSION_MODES.indexOf(ConversionMode.TO_3D), {\n\t\tmenu: {\n\t\t\tentries: CONVERSION_MODES.map((name, value) => ({name, value})),\n\t\t},\n\t});\n\t/** @param axis */\n\t// axis = ParamConfig.VECTOR3([0, 0, 1]);\n}\nconst ParamsConfig = new CADConvertDimensionSopParamsConfig();\n\nexport class CADConvertDimensionSopNode extends CADSopNode<CADConvertDimensionSopParamsConfig> {\n\toverride paramsConfig = ParamsConfig;\n\tstatic override type() {\n\t\treturn SopType.CAD_CONVERT_DIMENSION;\n\t}\n\tprotected override initializeNode() {\n\t\tthis.io.inputs.setCount(1);\n\t}\n\n\tsetMode(mode: ConversionMode) {\n\t\tthis.p.mode.set(CONVERSION_MODES.indexOf(mode));\n\t}\n\n\toverride cook(inputCoreGroups: CoreGroup[]) {\n\t\tconst oc = CadLoaderSync.oc();\n\n\t\tconst mode = CONVERSION_MODES[this.pv.mode];\n\t\tconst plane = cadPlaneXY(); //cadPlaneFromAxis(this.pv.axis)\n\n\t\tconst newObjects: CadObject<CadGeometryType>[] = [];\n\t\tconst inputObjects = inputCoreGroups[0].cadObjects();\n\n\t\tif (inputObjects) {\n\t\t\tswitch (mode) {\n\t\t\t\tcase ConversionMode.TO_2D: {\n\t\t\t\t\tfor (const inputObject of inputObjects) {\n\t\t\t\t\t\tconst type = inputObject.type;\n\t\t\t\t\t\tswitch (type) {\n\t\t\t\t\t\t\tcase CadGeometryType.VERTEX: {\n\t\t\t\t\t\t\t\tif (CoreCadType.isVertex(inputObject)) {\n\t\t\t\t\t\t\t\t\tconvertVertexToPoint2D(oc, inputObject.cadGeometry(), plane, newObjects);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcase CadGeometryType.EDGE: {\n\t\t\t\t\t\t\t\tif (CoreCadType.isEdge(inputObject)) {\n\t\t\t\t\t\t\t\t\tconvertEdgeToCurve2D(oc, inputObject.cadGeometry(), plane, newObjects);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t\tnewObjects.push(inputObject);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcase ConversionMode.TO_3D: {\n\t\t\t\t\tfor (const inputObject of inputObjects) {\n\t\t\t\t\t\tconst type = inputObject.type;\n\t\t\t\t\t\tswitch (type) {\n\t\t\t\t\t\t\tcase CadGeometryType.POINT_2D: {\n\t\t\t\t\t\t\t\tif (CoreCadType.isPoint2d(inputObject)) {\n\t\t\t\t\t\t\t\t\tconvertPoint2DToVertex(oc, inputObject.cadGeometry(), plane, newObjects);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcase CadGeometryType.CURVE_2D: {\n\t\t\t\t\t\t\t\tif (CoreCadType.isGeom2dCurve(inputObject)) {\n\t\t\t\t\t\t\t\t\tconvertCurve2DToEdge(oc, inputObject.cadGeometry(), plane, newObjects);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t\tnewObjects.push(inputObject);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tthis.setCADObjects(newObjects);\n\t}\n}\n\nconst tmpV3 = new Vector3();\n\n// to 2D\nfunction convertVertexToPoint2D(\n\toc: OpenCascadeInstance,\n\tvertex: TopoDS_Vertex,\n\tplane: gp_Pln,\n\tnewObjects: CadObject<CadGeometryType>[]\n) {\n\tconst point = oc.BRep_Tool.Pnt(vertex);\n\tconst pnt2D = new oc.gp_Pnt2d_3(point.X(), point.Y());\n\tnewObjects.push(new CadObject(pnt2D, CadGeometryType.POINT_2D));\n}\nfunction convertEdgeToCurve2D(\n\toc: OpenCascadeInstance,\n\tedge: TopoDS_Edge,\n\tplane: gp_Pln,\n\tnewObjects: CadObject<CadGeometryType>[]\n) {\n\tconst handle3D = curveDataFromEdge(oc, edge).curveHandle;\n\tconst curve3D = handle3D.get();\n\tif (!curve3D) {\n\t\treturn;\n\t}\n\tconst handle2D = oc.GeomAPI.To2d(handle3D, cadPlaneXY());\n\tconst curve2D = handle2D.get();\n\tif (!curve2D) {\n\t\treturn;\n\t}\n\tnewObjects.push(new CadObject(curve2D, CadGeometryType.CURVE_2D));\n}\n\n// to 3D\nfunction convertPoint2DToVertex(\n\toc: OpenCascadeInstance,\n\tpoint2D: gp_Pnt2d,\n\tplane: gp_Pln,\n\tnewObjects: CadObject<CadGeometryType>[]\n) {\n\ttmpV3.set(point2D.X(), point2D.Y(), 0);\n\tconst vertex = cadVertexCreate(oc, tmpV3);\n\tnewObjects.push(new CadObject(vertex, CadGeometryType.VERTEX));\n}\nfunction convertCurve2DToEdge(\n\toc: OpenCascadeInstance,\n\tcurve2D: Geom2d_Curve,\n\tplane: gp_Pln,\n\tnewObjects: CadObject<CadGeometryType>[]\n) {\n\tconst handle2D = new oc.Handle_Geom2d_Curve_2(curve2D);\n\tconst handle3D = oc.GeomAPI.To3d(handle2D, cadPlaneXY());\n\tconst curve3D = handle3D.get();\n\tif (!curve3D) {\n\t\treturn;\n\t}\n\tconst edge = cadEdgeCreate(oc, curve3D);\n\thandle2D.delete();\n\tnewObjects.push(new CadObject(edge, CadGeometryType.EDGE));\n}\n","/**\n * Applies a CAD fillet operation\n *\n *\n */\nimport {CADSopNode} from './_BaseCAD';\nimport {NodeParamsConfig, ParamConfig} from '../utils/params/ParamsConfig';\nimport type {OpenCascadeInstance, TopoDS_Shape} from '../../../core/geometry/modules/cad/CadCommon';\nimport {step} from '../../../core/geometry/modules/cad/CadConstant';\nimport {CoreCadType} from '../../../core/geometry/modules/cad/CadCoreType';\nimport {traverseEdges} from '../../../core/geometry/modules/cad/CadTraverse';\nimport {CadGeometryType, cadGeometryTypeFromShape} from '../../../core/geometry/modules/cad/CadCommon';\nimport {TypeAssert} from '../../poly/Assert';\nimport {CoreGroup} from '../../../core/geometry/Group';\nimport {SopType} from '../../poly/registers/nodes/types/Sop';\nimport {CadObject} from '../../../core/geometry/modules/cad/CadObject';\nimport {CadLoaderSync} from '../../../core/geometry/modules/cad/CadLoaderSync';\n// import {CadCoreEdge} from '../../../core/geometry/modules/cad/CadCoreEdge';\n// import {CoreString} from '../../../core/String';\n// import {SetUtils} from '../../../core/SetUtils';\n// import {coreObjectInstanceFactory} from '../../../core/geometry/CoreObjectFactory';\nimport {EntityGroupType} from '../../../core/geometry/EntityGroupCollection';\nimport {CadEntityGroupCollection} from '../../../core/geometry/modules/cad/CadEntityGroupCollection';\n\nenum FilletMode {\n\tROUND = 'round',\n\tSTRAIGHT = 'straight',\n}\nconst FILLET_MODES: FilletMode[] = [FilletMode.STRAIGHT, FilletMode.ROUND];\nclass CADFilletSopParamsConfig extends NodeParamsConfig {\n\t/** @param edges group */\n\tgroup = ParamConfig.STRING('');\n\t/** @param mode */\n\tmode = ParamConfig.INTEGER(FILLET_MODES.indexOf(FilletMode.ROUND), {\n\t\tmenu: {\n\t\t\tentries: FILLET_MODES.map((name, value) => ({name, value})),\n\t\t},\n\t});\n\t/** @param radius */\n\tradius = ParamConfig.FLOAT(0.1, {\n\t\trange: [0, 1],\n\t\trangeLocked: [true, false],\n\t\tstep,\n\t});\n}\nconst ParamsConfig = new CADFilletSopParamsConfig();\n\nexport class CADFilletSopNode extends CADSopNode<CADFilletSopParamsConfig> {\n\toverride paramsConfig = ParamsConfig;\n\tstatic override type() {\n\t\treturn SopType.CAD_FILLET;\n\t}\n\tprotected override initializeNode() {\n\t\tthis.io.inputs.setCount(1);\n\t}\n\n\toverride cook(inputCoreGroups: CoreGroup[]) {\n\t\tconst oc = CadLoaderSync.oc();\n\t\tconst inputCoreGroup = inputCoreGroups[0];\n\n\t\tconst mode = FILLET_MODES[this.pv.mode];\n\t\tconst newObjects: CadObject<CadGeometryType>[] = [];\n\n\t\tconst inputObjects = inputCoreGroup.cadObjects();\n\t\tif (inputObjects) {\n\t\t\tconst groupName = this.pv.group;\n\t\t\tfor (const object of inputObjects) {\n\t\t\t\tif (CoreCadType.isShape(object)) {\n\t\t\t\t\tconst shape = object.cadGeometry();\n\t\t\t\t\tconst api = _getApi(oc, mode, shape);\n\n\t\t\t\t\tconst radius = this.pv.radius;\n\t\t\t\t\tlet edgesCount = 0;\n\n\t\t\t\t\tCadEntityGroupCollection.traverseEntitiesInGroup({\n\t\t\t\t\t\tgroupName,\n\t\t\t\t\t\tgroupType: EntityGroupType.EDGE,\n\t\t\t\t\t\tobject,\n\t\t\t\t\t\tshape,\n\t\t\t\t\t\ttraverseFunction: traverseEdges,\n\t\t\t\t\t\tonEntityTraversed: (edge, i) => {\n\t\t\t\t\t\t\tapi.Add_2(radius, edge);\n\t\t\t\t\t\t\tedgesCount++;\n\t\t\t\t\t\t},\n\t\t\t\t\t});\n\n\t\t\t\t\tif (edgesCount > 0) {\n\t\t\t\t\t\tconst newShape = api.Shape();\n\t\t\t\t\t\tapi.delete();\n\t\t\t\t\t\tconst type = cadGeometryTypeFromShape(oc, newShape);\n\t\t\t\t\t\tif (type) {\n\t\t\t\t\t\t\tnewObjects.push(new CadObject(newShape, type));\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tconsole.log('no type', newShape);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tnewObjects.push(object);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tthis.setCADObjects(newObjects);\n\t}\n}\n\nfunction _getApi(oc: OpenCascadeInstance, mode: FilletMode, shape: TopoDS_Shape) {\n\tswitch (mode) {\n\t\tcase FilletMode.ROUND: {\n\t\t\treturn new oc.BRepFilletAPI_MakeFillet(shape, oc.ChFi3d_FilletShape.ChFi3d_Rational as any);\n\t\t}\n\t\tcase FilletMode.STRAIGHT: {\n\t\t\treturn new oc.BRepFilletAPI_MakeChamfer(shape);\n\t\t}\n\t}\n\tTypeAssert.unreachable(mode);\n}\n","import {CoreEntity} from '../../../../../core/geometry/CoreEntity';\nimport {isBooleanTrue} from '../../../../../core/BooleanValue';\nimport {ExpressionController} from '../../../../params/utils/ExpressionController';\nimport {ParamType} from '../../../../poly/ParamType';\nimport {CADGroupSopNode} from '../../CADGroup';\nimport {CoreEntitySelectionState, updateSelectionState} from './GroupCommon';\n\nexport class GroupByExpressionHelper {\n\tconstructor(private node: CADGroupSopNode) {}\n\tasync evalForEntities(allEntities: CoreEntity[], selectionStates: CoreEntitySelectionState) {\n\t\tconst param = this.node.p.expression;\n\t\tif (param.hasExpression() && param.expressionController && param.expressionController.entitiesDependent()) {\n\t\t\tawait this._evalEntityDependentExpression(allEntities, selectionStates, param.expressionController);\n\t\t} else {\n\t\t\tthis._evalExpressionsWithoutEntityDependentExpression(allEntities, selectionStates);\n\t\t}\n\t}\n\n\tprivate async _evalEntityDependentExpression(\n\t\tallEntities: CoreEntity[],\n\t\tselectionStates: CoreEntitySelectionState,\n\t\texpressionController: ExpressionController<ParamType.BOOLEAN>\n\t) {\n\t\tawait expressionController.computeExpressionForEntities(allEntities, (entity, value: boolean) => {\n\t\t\tupdateSelectionState(selectionStates, entity, value);\n\t\t});\n\t}\n\tprivate _evalExpressionsWithoutEntityDependentExpression(\n\t\tallEntities: CoreEntity[],\n\t\tselectionStates: CoreEntitySelectionState\n\t) {\n\t\tconst value = isBooleanTrue(this.node.pv.expression);\n\t\tfor (const entity of allEntities) {\n\t\t\tupdateSelectionState(selectionStates, entity, value);\n\t\t}\n\t}\n}\n","import {CADGroupSopNode} from '../../CADGroup';\nimport {Box3, Vector3} from 'three';\nimport {CoreEntity} from '../../../../../core/geometry/CoreEntity';\nimport {CoreEntitySelectionState, updateSelectionState} from './GroupCommon';\n\nconst bbox = new Box3();\nconst bboxHalfSize = new Vector3();\nconst entityPosition = new Vector3();\n\nexport class GroupByBoundingBoxHelper {\n\tconstructor(private node: CADGroupSopNode) {}\n\tevalForEntities(allEntities: CoreEntity[], selectionStates: CoreEntitySelectionState) {\n\t\tbboxHalfSize.copy(this.node.pv.boundingBoxSize).multiplyScalar(0.5);\n\t\tbbox.min.copy(this.node.pv.boundingBoxCenter).sub(bboxHalfSize);\n\t\tbbox.max.copy(this.node.pv.boundingBoxCenter).add(bboxHalfSize);\n\n\t\tfor (const entity of allEntities) {\n\t\t\tentity.position(entityPosition);\n\t\t\tupdateSelectionState(selectionStates, entity, bbox.containsPoint(entityPosition));\n\t\t}\n\t}\n}\n","import {Vector3, Box3} from 'three';\nimport {CoreGroup} from '../../../../../core/geometry/Group';\nimport {CoreEntity} from '../../../../../core/geometry/CoreEntity';\nimport {CoreEntitySelectionState, updateSelectionState} from './GroupCommon';\n\nconst bbox = new Box3();\nconst tmpPosition = new Vector3();\n\nexport class GroupByBoundingObjectHelper {\n\tevalForEntities(\n\t\tallEntities: CoreEntity[],\n\t\tselectionStates: CoreEntitySelectionState,\n\t\tboundingCoreGroup: CoreGroup\n\t) {\n\t\tboundingCoreGroup.boundingBox(bbox);\n\t\tfor (const entity of allEntities) {\n\t\t\tentity.position(tmpPosition);\n\t\t\tupdateSelectionState(selectionStates, entity, bbox.containsPoint(tmpPosition));\n\t\t}\n\t}\n}\n","import {CoreEntity} from '../../CoreEntity';\nimport {TopoDS_Shape, TopoDS_Edge} from './CadCommon';\nimport {Vector2, Vector3, Vector4} from 'three';\nimport {AttribValue, NumericAttribValue} from '../../../../types/GlobalTypes';\nimport {Attribute, CoreAttribute} from '../../Attribute';\nimport {CadLoaderSync} from './CadLoaderSync';\nimport {traverseVertices} from './CadTraverse';\nimport {ObjectBuilder, CoreObjectType} from '../../ObjectContent';\nimport {AttribClass} from '../../Constant';\n\nexport class CadCoreEdge extends CoreEntity {\n\tconstructor(protected _shape: TopoDS_Shape, protected _edge: TopoDS_Edge, _index: number) {\n\t\tsuper(_shape, _index);\n\t}\n\tedge() {\n\t\treturn this._edge;\n\t}\n\tgeometry() {\n\t\treturn this._shape;\n\t}\n\tbuilder<T extends CoreObjectType>(): ObjectBuilder<T> | undefined {\n\t\treturn undefined;\n\t}\n\n\tsetAttribValue(attribName: string, attribValue: NumericAttribValue | string) {}\n\tattribValue(attribName: string, target?: Vector2 | Vector3 | Vector4): AttribValue | undefined {\n\t\tif (attribName === Attribute.POINT_INDEX) {\n\t\t\treturn this._index;\n\t\t} else {\n\t\t\tconst remapedName = CoreAttribute.remapName(attribName);\n\t\t\tif (remapedName == Attribute.POSITION && target instanceof Vector3) {\n\t\t\t\tthis.position(target);\n\t\t\t}\n\t\t\t// TODO: use vertices center for position?\n\t\t\t// this._edge.\n\t\t\treturn this._index;\n\t\t}\n\t}\n\tstringAttribValue(attribName: string): string | null {\n\t\treturn '';\n\t}\n\tposition(target: Vector3): Vector3 {\n\t\tconst oc = CadLoaderSync.oc();\n\t\tlet verticesCount = 0;\n\t\ttarget.set(0, 0, 0);\n\t\ttraverseVertices(oc, this._edge, (vertex, i) => {\n\t\t\tconst point = oc.BRep_Tool.Pnt(vertex);\n\t\t\ttarget.x += point.X();\n\t\t\ttarget.y += point.Y();\n\t\t\ttarget.z += point.Z();\n\t\t\tverticesCount++;\n\t\t});\n\t\ttarget.divideScalar(verticesCount);\n\t\treturn target;\n\t}\n\t//\n\t//\n\t// RELATED ENTITIES\n\t//\n\t//\n\trelatedEntities(attribClass: AttribClass): CoreEntity[] {\n\t\treturn [];\n\t}\n}\n","import {CoreEntity} from '../../CoreEntity';\nimport {TopoDS_Shape, TopoDS_Face} from './CadCommon';\nimport {Vector2, Vector3, Vector4} from 'three';\nimport {AttribValue, NumericAttribValue} from '../../../../types/GlobalTypes';\nimport {Attribute, CoreAttribute} from '../../Attribute';\nimport {CadLoaderSync} from './CadLoaderSync';\nimport {traverseVertices} from './CadTraverse';\nimport {ObjectBuilder, CoreObjectType} from '../../ObjectContent';\nimport {AttribClass} from '../../Constant';\n\nexport class CadCoreFace extends CoreEntity {\n\tconstructor(protected _shape: TopoDS_Shape, protected _face: TopoDS_Face, _index: number) {\n\t\tsuper(_shape, _index);\n\t}\n\tface() {\n\t\treturn this._face;\n\t}\n\tgeometry() {\n\t\treturn this._shape;\n\t}\n\tbuilder<T extends CoreObjectType>(): ObjectBuilder<T> | undefined {\n\t\treturn undefined;\n\t}\n\n\tsetAttribValue(attribName: string, attribValue: NumericAttribValue | string) {}\n\tattribValue(attribName: string, target?: Vector2 | Vector3 | Vector4): AttribValue | undefined {\n\t\tif (attribName === Attribute.POINT_INDEX) {\n\t\t\treturn this._index;\n\t\t} else {\n\t\t\tconst remapedName = CoreAttribute.remapName(attribName);\n\t\t\tif (remapedName == Attribute.POSITION && target instanceof Vector3) {\n\t\t\t\tthis.position(target);\n\t\t\t}\n\t\t\t// TODO: use vertices center for position?\n\t\t\t// this._edge.\n\t\t\treturn this._index;\n\t\t}\n\t}\n\tstringAttribValue(attribName: string): string | null {\n\t\treturn '';\n\t}\n\tposition(target: Vector3): Vector3 {\n\t\tconst oc = CadLoaderSync.oc();\n\t\tlet verticesCount = 0;\n\t\ttarget.set(0, 0, 0);\n\t\ttraverseVertices(oc, this._face, (vertex, i) => {\n\t\t\tconst point = oc.BRep_Tool.Pnt(vertex);\n\t\t\ttarget.x += point.X();\n\t\t\ttarget.y += point.Y();\n\t\t\ttarget.z += point.Z();\n\t\t\tverticesCount++;\n\t\t});\n\t\ttarget.divideScalar(verticesCount);\n\t\treturn target;\n\t}\n\t//\n\t//\n\t// RELATED ENTITIES\n\t//\n\t//\n\trelatedEntities(attribClass: AttribClass): CoreEntity[] {\n\t\treturn [];\n\t}\n}\n","/**\n * Creates group of edges\n *\n *\n */\n\nimport {CADSopNode} from './_BaseCAD';\nimport {NodeParamsConfig, ParamConfig} from '../utils/params/ParamsConfig';\nimport {SopType} from '../../poly/registers/nodes/types/Sop';\nimport {CadLoader} from '../../../core/geometry/modules/cad/CadLoader';\nimport {InputCloneMode} from '../../poly/InputCloneMode';\nimport {CoreGroup} from '../../../core/geometry/Group';\nimport {traverseEdges, traverseFaces} from '../../../core/geometry/modules/cad/CadTraverse';\nimport {CoreCadType} from '../../../core/geometry/modules/cad/CadCoreType';\nimport {GroupByExpressionHelper} from './utils/group/GroupByExpressionHelper';\nimport {GroupByBoundingBoxHelper} from './utils/group/GroupByBoundingBoxHelper';\nimport {GroupByBoundingObjectHelper} from './utils/group/GroupByBoundingObjectHelper';\nimport {CoreEntitySelectionState, updateSelectionState} from './/utils/group/GroupCommon';\nimport {isBooleanTrue} from '../../../core/Type';\nimport {CadObject} from '../../../core/geometry/modules/cad/CadObject';\nimport {OpenCascadeInstance, CadGeometryTypeShape} from '../../../core/geometry/modules/cad/CadCommon';\nimport {CadCoreEdge} from '../../../core/geometry/modules/cad/CadCoreEdge';\nimport {\n\tGroupOperation,\n\tGROUP_OPERATIONS,\n\tUpdateGroupOptions,\n\tEntityGroupType,\n} from '../../../core/geometry/EntityGroupCollection';\nimport {coreObjectInstanceFactory} from '../../../core/geometry/CoreObjectFactory';\nimport {CoreEntity} from '../../../core/geometry/CoreEntity';\nimport {CadCoreFace} from '../../../core/geometry/modules/cad/CadCoreFace';\n\nconst GROUP_TYPES: EntityGroupType[] = [EntityGroupType.EDGE, EntityGroupType.FACE];\n\nclass CADGroupSopParamsConfig extends NodeParamsConfig {\n\t/** @param group name */\n\tname = ParamConfig.STRING('');\n\t/** @param group type */\n\ttype = ParamConfig.INTEGER(GROUP_TYPES.indexOf(EntityGroupType.EDGE), {\n\t\tmenu: {\n\t\t\tentries: GROUP_TYPES.map((name, value) => ({name, value})),\n\t\t},\n\t});\n\t/** @param mode */\n\toperation = ParamConfig.INTEGER(GROUP_OPERATIONS.indexOf(GroupOperation.SET), {\n\t\tmenu: {\n\t\t\tentries: GROUP_OPERATIONS.map((name, value) => ({name, value})),\n\t\t},\n\t});\n\t// byExpression\n\t/** @param deletes objects by an expression */\n\tbyExpression = ParamConfig.BOOLEAN(0, {\n\t\tseparatorBefore: true,\n\t});\n\t/** @param sets the expression to select what should be deleted */\n\texpression = ParamConfig.BOOLEAN('@ptnum==0', {\n\t\tvisibleIf: {byExpression: true},\n\t\texpression: {forEntities: true},\n\t});\n\t// byBbox\n\t/** @param deletes objects that are inside a bounding box */\n\tbyBoundingBox = ParamConfig.BOOLEAN(0, {\n\t\tseparatorBefore: true,\n\t});\n\t/** @param the bounding box size */\n\tboundingBoxSize = ParamConfig.VECTOR3([1, 1, 1], {\n\t\tvisibleIf: {\n\t\t\tbyBoundingBox: true,\n\t\t},\n\t});\n\t/** @param the bounding box center */\n\tboundingBoxCenter = ParamConfig.VECTOR3([0, 0, 0], {\n\t\tvisibleIf: {\n\t\t\tbyBoundingBox: true,\n\t\t},\n\t});\n\n\t// byBoundingObject\n\t/** @param deletes objects that are inside an object. This uses the object from the 2nd input */\n\tbyBoundingObject = ParamConfig.BOOLEAN(0, {\n\t\tseparatorBefore: true,\n\t});\n\t/** @param invert */\n\tinvert = ParamConfig.BOOLEAN(0, {\n\t\tseparatorBefore: true,\n\t});\n}\nconst ParamsConfig = new CADGroupSopParamsConfig();\n\nexport class CADGroupSopNode extends CADSopNode<CADGroupSopParamsConfig> {\n\toverride readonly paramsConfig = ParamsConfig;\n\tstatic override type() {\n\t\treturn SopType.CAD_GROUP;\n\t}\n\n\t// public readonly entitySelectionHelper = new EntitySelectionHelper(this);\n\tpublic readonly byExpressionHelper = new GroupByExpressionHelper(this);\n\tpublic readonly byBoundingBoxHelper = new GroupByBoundingBoxHelper(this);\n\tpublic readonly byBoundingObjectHelper = new GroupByBoundingObjectHelper();\n\n\toverride initializeNode() {\n\t\tthis.io.inputs.setCount(1, 2);\n\t\tthis.io.inputs.initInputsClonedState(InputCloneMode.FROM_NODE);\n\t}\n\n\tsetGroupType(groupType: EntityGroupType) {\n\t\tthis.p.type.set(GROUP_TYPES.indexOf(groupType));\n\t}\n\tgroupType() {\n\t\treturn GROUP_TYPES[this.pv.type];\n\t}\n\tgroupName() {\n\t\treturn this.pv.name;\n\t}\n\n\toverride async cook(inputCoreGroups: CoreGroup[]) {\n\t\tconst oc = await CadLoader.core(this);\n\t\tconst coreGroup0 = inputCoreGroups[0];\n\t\tconst coreGroup1 = inputCoreGroups[1];\n\n\t\tconst inputObjects = coreGroup0.cadObjects();\n\t\tif (inputObjects) {\n\t\t\tfor (const inputObject of inputObjects) {\n\t\t\t\tif (CoreCadType.isShape(inputObject)) {\n\t\t\t\t\tawait this._evalEdges(oc, inputObject, coreGroup1);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tthis.setCADObjects(inputObjects);\n\t\t} else {\n\t\t\tthis.setCADObjects([]);\n\t\t}\n\t}\n\n\tprivate selectedStates: CoreEntitySelectionState = new Map();\n\tprivate async _evalEdges(\n\t\toc: OpenCascadeInstance,\n\t\tinputObject: CadObject<CadGeometryTypeShape>,\n\t\tboundingCoreGroup: CoreGroup\n\t) {\n\t\tconst entities: CoreEntity[] = [];\n\t\tconst shape = inputObject.cadGeometry();\n\t\tconst type = this.groupType();\n\n\t\tswitch (type) {\n\t\t\tcase EntityGroupType.EDGE: {\n\t\t\t\ttraverseEdges(oc, shape, (edge, index) => {\n\t\t\t\t\tentities.push(new CadCoreEdge(shape, edge, index));\n\t\t\t\t});\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase EntityGroupType.FACE: {\n\t\t\t\ttraverseFaces(oc, shape, (face, index) => {\n\t\t\t\t\tentities.push(new CadCoreFace(shape, face, index));\n\t\t\t\t});\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tthis.selectedStates.clear();\n\t\tconst {byExpression, byBoundingBox, byBoundingObject} = this.pv;\n\t\tif (byExpression || byBoundingBox || byBoundingObject) {\n\t\t\tif (isBooleanTrue(byExpression)) {\n\t\t\t\tawait this.byExpressionHelper.evalForEntities(entities, this.selectedStates);\n\t\t\t}\n\t\t\tif (isBooleanTrue(byBoundingBox)) {\n\t\t\t\tawait this.byBoundingBoxHelper.evalForEntities(entities, this.selectedStates);\n\t\t\t}\n\t\t\tif (isBooleanTrue(byBoundingObject)) {\n\t\t\t\tawait this.byBoundingObjectHelper.evalForEntities(entities, this.selectedStates, boundingCoreGroup);\n\t\t\t}\n\t\t} else {\n\t\t\tfor (const entity of entities) {\n\t\t\t\tupdateSelectionState(this.selectedStates, entity, false);\n\t\t\t}\n\t\t}\n\t\tconst coreObject = coreObjectInstanceFactory(inputObject);\n\t\tconst groupCollection = coreObject.groupCollection();\n\t\tconst options: UpdateGroupOptions = {\n\t\t\ttype,\n\t\t\tgroupName: this.groupName(),\n\t\t\toperation: GROUP_OPERATIONS[this.pv.operation],\n\t\t\tinvert: this.pv.invert,\n\t\t};\n\t\tgroupCollection.updateGroup(options, this.selectedStates);\n\t}\n}\n","/**\n * Mirros CAD input objects\n *\n *\n */\nimport {CADSopNode} from './_BaseCAD';\nimport {NodeParamsConfig, ParamConfig} from '../utils/params/ParamsConfig';\nimport {CadGeometryType, TopoDS_Shape, cadGeometryTypeFromShape} from '../../../core/geometry/modules/cad/CadCommon';\nimport {CoreCadType} from '../../../core/geometry/modules/cad/CadCoreType';\nimport {CoreGroup} from '../../../core/geometry/Group';\nimport {SopType} from '../../poly/registers/nodes/types/Sop';\nimport {CadLoaderSync} from '../../../core/geometry/modules/cad/CadLoaderSync';\nimport {CadObject} from '../../../core/geometry/modules/cad/CadObject';\n\n// TODO: make sure it works for 3D as well\nclass CADMirrorSopParamsConfig extends NodeParamsConfig {\n\t/** @param origin */\n\t// origin = ParamConfig.VECTOR3([0, 0, 0]);\n\t/** @param axis */\n\taxis = ParamConfig.VECTOR3([0, 1, 0]);\n}\nconst ParamsConfig = new CADMirrorSopParamsConfig();\n\nexport class CADMirrorSopNode extends CADSopNode<CADMirrorSopParamsConfig> {\n\toverride paramsConfig = ParamsConfig;\n\tstatic override type() {\n\t\treturn SopType.CAD_MIRROR;\n\t}\n\n\tprotected override initializeNode() {\n\t\tthis.io.inputs.setCount(1);\n\t}\n\n\toverride cook(inputCoreGroups: CoreGroup[]) {\n\t\tconst oc = CadLoaderSync.oc();\n\t\tconst inputCoreGroup = inputCoreGroups[0];\n\n\t\tconst axis = CadLoaderSync.gp_Ax1;\n\t\tconst dir = CadLoaderSync.gp_Dir; //new oc.gp_Dir_4(this.pv.axis.x, this.pv.axis.y, this.pv.axis.z);\n\t\tdir.SetCoord_2(this.pv.axis.x, this.pv.axis.y, this.pv.axis.z);\n\t\taxis.SetDirection(dir);\n\t\tconst transform = CadLoaderSync.gp_Trsf;\n\t\ttransform.SetMirror_2(axis);\n\t\tconst newObjects: CadObject<CadGeometryType>[] = [];\n\t\tconst inputObjects = inputCoreGroup.cadObjects();\n\t\tif (inputObjects) {\n\t\t\tfor (const object of inputObjects) {\n\t\t\t\tif (CoreCadType.isShape(object)) {\n\t\t\t\t\tconst shape = object.cadGeometry() as TopoDS_Shape;\n\t\t\t\t\tconst transformApi = new oc.BRepBuilderAPI_Transform_2(shape, transform, false);\n\t\t\t\t\tconst mirroredShape = transformApi.Shape();\n\t\t\t\t\ttransformApi.delete();\n\t\t\t\t\tconst type = cadGeometryTypeFromShape(oc, mirroredShape);\n\t\t\t\t\tif (type) {\n\t\t\t\t\t\tnewObjects.push(new CadObject(mirroredShape, type));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tthis.setCADObjects(newObjects);\n\t}\n}\n","/**\n * Adds a thickness to CAD input objects\n *\n *\n */\nimport {CADSopNode} from './_BaseCAD';\nimport {NodeParamsConfig, ParamConfig} from '../utils/params/ParamsConfig';\nimport {step} from '../../../core/geometry/modules/cad/CadConstant';\nimport {CoreCadType} from '../../../core/geometry/modules/cad/CadCoreType';\nimport {\n\tCadGeometryType,\n\tTopoDS_Shape,\n\tOpenCascadeInstance,\n\tcadGeometryTypeFromShape,\n\t// TopTools_ListOfShape,\n} from '../../../core/geometry/modules/cad/CadCommon';\nimport {traverseFaces} from '../../../core/geometry/modules/cad/CadTraverse';\n// import {withCadException} from '../../../core/geometry/modules/cad/CadExceptionHandler';\n// import {SetUtils} from '../../../core/SetUtils';\nimport {CoreGroup} from '../../../core/geometry/Group';\nimport {SopType} from '../../poly/registers/nodes/types/Sop';\nimport {CadObject} from '../../../core/geometry/modules/cad/CadObject';\nimport {CadLoaderSync} from '../../../core/geometry/modules/cad/CadLoaderSync';\n// import {CoreString} from '../../../core/String';\n// import {CadCoreFace} from '../../../core/geometry/modules/cad/CadCoreFace';\n// import {coreObjectInstanceFactory} from '../../../core/geometry/CoreObjectFactory';\nimport {EntityGroupType} from '../../../core/geometry/EntityGroupCollection';\nimport {CadEntityGroupCollection} from '../../../core/geometry/modules/cad/CadEntityGroupCollection';\n\n// TODO: find more meaningful name\nclass CADThicknessSopParamsConfig extends NodeParamsConfig {\n\t/** @param faces group */\n\tfacesGroupToDelete = ParamConfig.STRING('');\n\t/** @param offset */\n\toffset = ParamConfig.FLOAT(-0.1, {\n\t\trange: [-1, 1],\n\t\trangeLocked: [true, false],\n\t\tstep,\n\t});\n}\nconst ParamsConfig = new CADThicknessSopParamsConfig();\n\nexport class CADThicknessSopNode extends CADSopNode<CADThicknessSopParamsConfig> {\n\toverride paramsConfig = ParamsConfig;\n\tstatic override type() {\n\t\treturn SopType.CAD_THICKNESS;\n\t}\n\tprotected override initializeNode() {\n\t\tthis.io.inputs.setCount(1);\n\t}\n\n\toverride cook(inputCoreGroups: CoreGroup[]) {\n\t\tconst oc = CadLoaderSync.oc();\n\t\tconst inputCoreGroup = inputCoreGroups[0];\n\n\t\t// line.start.set(0, 0, 0);\n\t\t// normalizedAxis.copy(this.pv.facesSortAxis).normalize();\n\t\t// line.end.copy(normalizedAxis);\n\t\tconst newObjects: CadObject<CadGeometryType>[] = [];\n\n\t\tconst inputObjects = inputCoreGroup.cadObjects();\n\t\tif (inputObjects) {\n\t\t\tfor (const inputObject of inputObjects) {\n\t\t\t\tif (CoreCadType.isShape(inputObject)) {\n\t\t\t\t\tconst newShape = this._makeSolidByJoin(oc, inputObject);\n\t\t\t\t\tif (newShape) {\n\t\t\t\t\t\tconst type = cadGeometryTypeFromShape(oc, newShape);\n\t\t\t\t\t\tif (type) {\n\t\t\t\t\t\t\tnewObjects.push(new CadObject(newShape, type));\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tconsole.log('no type', newShape);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tnewObjects.push(inputObject);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tthis.setCADObjects(newObjects);\n\t}\n\n\t// private _makeSolid(oc: OpenCascadeInstance, shape: TopoDS_Shape, axis: Line3) {\n\t// \treturn this.pv.removeFaces ? this._makeSolidByJoin(oc, shape, axis) : this._makeSolidBySimple(oc, shape);\n\t// }\n\t// private _makeSolidBySimple(oc: OpenCascadeInstance, shape: TopoDS_Shape) {\n\t// \treturn withCadException(oc, () => {\n\t// \t\tconst api = new oc.BRepOffsetAPI_MakeThickSolid();\n\t// \t\tapi.MakeThickSolidBySimple(shape, this.pv.offset);\n\t// \t\tif(api.IsDone())\n\t// \t\treturn api.Shape();\n\t// \t});\n\t// }\n\tprivate _makeSolidByJoin(oc: OpenCascadeInstance, object: CadObject<CadGeometryType>) {\n\t\t// const facesToRemove = this._getFacesToRemove(oc, shape, axis);\n\t\tconst faces = new oc.TopTools_ListOfShape_1();\n\t\t// for (let face of facesToRemove) {\n\t\t// \tfaces.Append_1(face);\n\t\t// }\n\t\tconst shape = object.cadGeometry() as TopoDS_Shape;\n\t\tCadEntityGroupCollection.traverseEntitiesInGroup({\n\t\t\tgroupName: this.pv.facesGroupToDelete,\n\t\t\tgroupType: EntityGroupType.FACE,\n\t\t\tobject,\n\t\t\tshape,\n\t\t\ttraverseFunction: traverseFaces,\n\t\t\tonEntityTraversed: (face, i) => {\n\t\t\t\tfaces.Append_1(face);\n\t\t\t},\n\t\t});\n\n\t\t//\n\t\tconst api = new oc.BRepOffsetAPI_MakeThickSolid();\n\t\tapi.MakeThickSolidByJoin(\n\t\t\tshape,\n\t\t\tfaces,\n\t\t\tthis.pv.offset,\n\t\t\t1e-3,\n\t\t\toc.BRepOffset_Mode.BRepOffset_Skin as any,\n\t\t\tfalse,\n\t\t\tfalse,\n\t\t\toc.GeomAbs_JoinType.GeomAbs_Arc as any,\n\t\t\tfalse,\n\t\t\tCadLoaderSync.Message_ProgressRange\n\t\t);\n\t\tconst newShape = api.Shape();\n\t\tapi.delete();\n\t\tfaces.delete();\n\t\treturn newShape;\n\t}\n\n\t// private _getFacesToRemove(\n\t// \toc: OpenCascadeInstance,\n\t// \tobject: CadObject<CadGeometryType>,\n\t// \tshape: TopoDS_Shape,\n\t// \tfaces: TopTools_ListOfShape\n\t// ) {\n\n\t// \t// const groupName = this.pv.facesGroupToDelete;\n\t// \t// if (groupName.trim() == '') {\n\t// \t// \t// no group\n\t// \t// \ttraverseFaces(oc, shape, (face) => {\n\t// \t// \t\tfaces.Append_1(face);\n\t// \t// \t});\n\t// \t// } else {\n\t// \t// \tconst indices = CoreString.indices(groupName);\n\t// \t// \tif (indices.length != 0) {\n\t// \t// \t\t// group by indices\n\t// \t// \t\tconst indicesSet = SetUtils.fromArray(indices);\n\t// \t// \t\ttraverseFaces(oc, shape, (face, i) => {\n\t// \t// \t\t\tif (indicesSet.has(i)) {\n\t// \t// \t\t\t\tfaces.Append_1(face);\n\t// \t// \t\t\t}\n\t// \t// \t\t});\n\t// \t// \t} else {\n\t// \t// \t\t// group by name\n\t// \t// \t\tconst coreFaces: CadCoreFace[] = [];\n\t// \t// \t\ttraverseFaces(oc, shape, (face, i) => {\n\t// \t// \t\t\tcoreFaces.push(new CadCoreFace(shape, face, i));\n\t// \t// \t\t});\n\t// \t// \t\tconst coreObject = coreObjectInstanceFactory(object);\n\t// \t// \t\tconst groupCollection = coreObject.groupCollection();\n\t// \t// \t\tconst selectedCoreFaces = groupCollection.entities(EntityGroupType.FACE, groupName, coreFaces);\n\t// \t// \t\tfor (let selectedCoreFace of selectedCoreFaces) {\n\t// \t// \t\t\tfaces.Append_1(selectedCoreFace.face());\n\t// \t// \t\t}\n\t// \t// \t}\n\t// \t// }\n\n\t// \t// facesByDist.clear();\n\t// \t// faceDists.clear();\n\t// \t// traverseFaces(oc, shape, (face) => {\n\t// \t// \t// const surface = oc.BRep_Tool.Surface_2(face);\n\n\t// \t// \tconst surfaceProperties = CadLoaderSync.GProp_GProps;\n\t// \t// \toc.BRepGProp.SurfaceProperties_1(face, surfaceProperties, false, false);\n\t// \t// \tconst centerOfMass = surfaceProperties.CentreOfMass();\n\n\t// \t// \tfaceCenter.set(centerOfMass.X(), centerOfMass.Y(), centerOfMass.Z());\n\t// \t// \taxis.closestPointToPoint(faceCenter, false, projected);\n\t// \t// \tconst position = projected.dot(axis.end);\n\t// \t// \t// const currentFace = new oc.TopExp_Explorer_2(\n\t// \t// \t// \tface,\n\t// \t// \t// \toc.TopAbs_ShapeEnum.TopAbs_FACE as any,\n\t// \t// \t// \toc.TopAbs_ShapeEnum.TopAbs_SHAPE as any\n\t// \t// \t// ).Current();\n\t// \t// \tMapUtils.addToSetAtEntry(facesByDist, position, face);\n\t// \t// \tfaceDists.add(position);\n\t// \t// });\n\t// \t// const dists = SetUtils.toArray(faceDists);\n\t// \t// const sortedDists = dists.sort((a, b) => (a > b ? 1 : -1));\n\t// \t// const facesToRemove: TopoDS_Face[] = [];\n\t// \t// for (let dist of sortedDists) {\n\t// \t// \tconst faces = facesByDist.get(dist);\n\t// \t// \tif (faces) {\n\t// \t// \t\tfor (let face of faces) {\n\t// \t// \t\t\tfacesToRemove.push(face);\n\t// \t// \t\t\tif (facesToRemove.length >= this.pv.facesCount) {\n\t// \t// \t\t\t\treturn facesToRemove;\n\t// \t// \t\t\t}\n\t// \t// \t\t}\n\t// \t// \t}\n\t// \t// }\n\t// \t// return facesToRemove;\n\t// }\n}\n","/**\n * Boolean Intersect Operation\n *\n *\n */\nimport {CSGSopNode} from './_BaseCSG';\nimport {NodeParamsConfig, ParamConfig} from '../utils/params/ParamsConfig';\nimport {CoreGroup} from '../../../core/geometry/Group';\nimport {CsgGeometryType, CsgGeometry} from '../../../core/geometry/modules/csg/CsgCommon';\nimport {csgIsGeom2, csgIsGeom3} from '../../../core/geometry/modules/csg/CsgCoreType';\nimport {SopType} from '../../poly/registers/nodes/types/Sop';\nimport {csgApplyTransform} from '../../../core/geometry/modules/csg/math/CsgMat4';\nimport {booleans} from '@jscad/modeling';\nimport {CsgObject} from '../../../core/geometry/modules/csg/CsgObject';\nconst {intersect, union, subtract} = booleans;\n\nexport enum BooleanCsgOperationType {\n\tINTERSECT = 'intersect',\n\tSUBTRACT = 'subtract',\n\tUNION = 'union',\n}\nexport const BOOLEAN_CSG_OPERATION_TYPES: BooleanCsgOperationType[] = [\n\tBooleanCsgOperationType.INTERSECT,\n\tBooleanCsgOperationType.SUBTRACT,\n\tBooleanCsgOperationType.UNION,\n];\n\nclass CSGBooleanSopParamsConfig extends NodeParamsConfig {\n\t/** @param operation */\n\toperation = ParamConfig.INTEGER(BOOLEAN_CSG_OPERATION_TYPES.indexOf(BooleanCsgOperationType.INTERSECT), {\n\t\tmenu: {entries: BOOLEAN_CSG_OPERATION_TYPES.map((name, value) => ({name, value}))},\n\t});\n}\nconst ParamsConfig = new CSGBooleanSopParamsConfig();\n\nexport class CSGBooleanSopNode extends CSGSopNode<CSGBooleanSopParamsConfig> {\n\toverride paramsConfig = ParamsConfig;\n\tstatic override type() {\n\t\treturn SopType.CSG_BOOLEAN;\n\t}\n\tprotected override initializeNode() {\n\t\tthis.io.inputs.setCount(2);\n\t}\n\tsetOperation(operation: BooleanCsgOperationType) {\n\t\tthis.p.operation.set(BOOLEAN_CSG_OPERATION_TYPES.indexOf(operation));\n\t}\n\n\toverride cook(inputCoreGroups: CoreGroup[]) {\n\t\tconst objects: CsgObject<CsgGeometryType>[] = [];\n\n\t\tconst objects0 = inputCoreGroups[0].csgObjects();\n\t\tconst objects1 = inputCoreGroups[1].csgObjects();\n\t\tif (objects0 && objects1) {\n\t\t\tconst count = Math.min(objects0.length, objects1.length);\n\n\t\t\tfor (let i = 0; i < count; i++) {\n\t\t\t\tconst object0 = objects0[i];\n\t\t\t\tconst object1 = objects1[i];\n\n\t\t\t\tconst result = this._applyOperation(object0.csgGeometry(), object1.csgGeometry());\n\t\t\t\tif (result) {\n\t\t\t\t\tobjects.push(new CsgObject(result));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tthis.setCSGObjects(objects);\n\t}\n\tprivate _applyOperation(object0: CsgGeometry, object1: CsgGeometry) {\n\t\tconst method = this._method();\n\n\t\tconst bothAreGeom3 = csgIsGeom3(object0) && csgIsGeom3(object1);\n\t\tif (bothAreGeom3) {\n\t\t\treturn method(object0, object1);\n\t\t}\n\t\tconst bothAreGeom2 = csgIsGeom2(object0) && csgIsGeom2(object1);\n\t\tif (bothAreGeom2) {\n\t\t\t// the transforms are applied for geom2, as otherwise the matrix is not taken into account\n\t\t\tcsgApplyTransform(object0);\n\t\t\tcsgApplyTransform(object1);\n\t\t\treturn method(object0, object1);\n\t\t}\n\t}\n\tprivate _method() {\n\t\tconst operation = BOOLEAN_CSG_OPERATION_TYPES[this.pv.operation];\n\t\tswitch (operation) {\n\t\t\tcase BooleanCsgOperationType.INTERSECT:\n\t\t\t\treturn intersect;\n\t\t\tcase BooleanCsgOperationType.SUBTRACT:\n\t\t\t\treturn subtract;\n\t\t\tcase BooleanCsgOperationType.UNION:\n\t\t\t\treturn union;\n\t\t}\n\t}\n}\n","/**\n * sets the controls used by the camera\n *\n *\n */\n\nimport {TypedSopNode} from './_Base';\nimport {CoreGroup} from '../../../core/geometry/Group';\nimport {CameraControlsSopOperation} from '../../operations/sop/CameraControls';\nimport {HierarchyParamConfigAll, ParamConfig} from '../utils/params/ParamsConfig';\nimport {CameraSopNodeType, NodeContext} from '../../poly/NodeContext';\nimport {EventNodeChildrenMap} from '../../poly/registers/nodes/Event';\nimport {NodeCreateOptions} from '../utils/hierarchy/ChildrenController';\nimport {Constructor, valueof} from '../../../types/GlobalTypes';\nimport {BaseEventNodeType} from '../event/_Base';\nclass CameraControlsSopParamsConfig extends HierarchyParamConfigAll {\n\t/** @param renderer */\n\tnode = ParamConfig.NODE_PATH('', {\n\t\tnodeSelection: {\n\t\t\tcontext: NodeContext.EVENT,\n\t\t},\n\t\tdependentOnFoundNode: true,\n\t});\n}\nconst ParamsConfig = new CameraControlsSopParamsConfig();\n\nexport class CameraControlsSopNode extends TypedSopNode<CameraControlsSopParamsConfig> {\n\toverride readonly paramsConfig = ParamsConfig;\n\tstatic override type() {\n\t\treturn CameraSopNodeType.CONTROLS;\n\t}\n\n\tprotected override initializeNode() {\n\t\tthis.io.inputs.setCount(1);\n\t\tthis.io.inputs.initInputsClonedState(CameraControlsSopOperation.INPUT_CLONED_STATE);\n\t}\n\n\tprivate _operation: CameraControlsSopOperation | undefined;\n\toverride cook(inputCoreGroups: CoreGroup[]) {\n\t\tthis._operation = this._operation || new CameraControlsSopOperation(this._scene, this.states, this);\n\t\tconst coreGroup = this._operation.cook(inputCoreGroups, this.pv);\n\t\tthis.setCoreGroup(coreGroup);\n\t}\n\t/*\n\tchildren\n\t*/\n\tprotected override _childrenControllerContext = NodeContext.EVENT;\n\toverride createNode<S extends keyof EventNodeChildrenMap>(\n\t\tnode_class: S,\n\t\toptions?: NodeCreateOptions\n\t): EventNodeChildrenMap[S];\n\toverride createNode<K extends valueof<EventNodeChildrenMap>>(\n\t\tnode_class: Constructor<K>,\n\t\toptions?: NodeCreateOptions\n\t): K;\n\toverride createNode<K extends valueof<EventNodeChildrenMap>>(\n\t\tnode_class: Constructor<K>,\n\t\toptions?: NodeCreateOptions\n\t): K {\n\t\treturn super.createNode(node_class, options) as K;\n\t}\n\toverride children() {\n\t\treturn super.children() as BaseEventNodeType[];\n\t}\n\toverride nodesByType<K extends keyof EventNodeChildrenMap>(type: K): EventNodeChildrenMap[K][] {\n\t\treturn super.nodesByType(type) as EventNodeChildrenMap[K][];\n\t}\n}\n","/**\n * sets the FPS (frame per second) that the viewer created by this camera should use\n *\n *\n */\n\nimport {TypedSopNode} from './_Base';\nimport {CoreGroup} from '../../../core/geometry/Group';\nimport {CameraFPSSopOperation} from '../../operations/sop/CameraFPS';\nimport {HierarchyParamConfigAll} from '../utils/params/ParamsConfig';\nimport {CameraSopNodeType} from '../../poly/NodeContext';\nimport {CoreCameraFPSParamConfig} from '../../../core/camera/CoreCameraFPS';\nclass CameraFPSSopParamsConfig extends CoreCameraFPSParamConfig(HierarchyParamConfigAll) {}\nconst ParamsConfig = new CameraFPSSopParamsConfig();\n\nexport class CameraFPSSopNode extends TypedSopNode<CameraFPSSopParamsConfig> {\n\toverride readonly paramsConfig = ParamsConfig;\n\tstatic override type() {\n\t\treturn CameraSopNodeType.FPS;\n\t}\n\n\tprotected override initializeNode() {\n\t\tthis.io.inputs.setCount(1);\n\t\tthis.io.inputs.initInputsClonedState(CameraFPSSopOperation.INPUT_CLONED_STATE);\n\t}\n\n\tprivate _operation: CameraFPSSopOperation | undefined;\n\toverride cook(inputCoreGroups: CoreGroup[]) {\n\t\tthis._operation = this._operation || new CameraFPSSopOperation(this._scene, this.states, this);\n\t\tconst coreGroup = this._operation.cook(inputCoreGroups, this.pv);\n\t\tthis.setCoreGroup(coreGroup);\n\t}\n}\n","/**\n * sets the controls used by the camera\n *\n *\n */\n\nimport {TypedSopNode} from './_Base';\nimport {CoreGroup} from '../../../core/geometry/Group';\nimport {CameraFrameModeSopOperation} from '../../operations/sop/CameraFrameMode';\nimport {HierarchyParamConfigAll} from '../utils/params/ParamsConfig';\nimport {CameraSopNodeType} from '../../poly/NodeContext';\nimport {CoreCameraFrameParamConfig} from '../../../core/camera/CoreCameraFrameMode';\nclass CameraFrameModeSopParamsConfig extends CoreCameraFrameParamConfig(HierarchyParamConfigAll) {}\nconst ParamsConfig = new CameraFrameModeSopParamsConfig();\n\nexport class CameraFrameModeSopNode extends TypedSopNode<CameraFrameModeSopParamsConfig> {\n\toverride readonly paramsConfig = ParamsConfig;\n\tstatic override type() {\n\t\treturn CameraSopNodeType.FRAME_MODE;\n\t}\n\n\tprotected override initializeNode() {\n\t\tthis.io.inputs.setCount(1);\n\t\tthis.io.inputs.initInputsClonedState(CameraFrameModeSopOperation.INPUT_CLONED_STATE);\n\t}\n\n\tprivate _operation: CameraFrameModeSopOperation | undefined;\n\toverride cook(inputCoreGroups: CoreGroup[]) {\n\t\tthis._operation = this._operation || new CameraFrameModeSopOperation(this._scene, this.states, this);\n\t\tconst coreGroup = this._operation.cook(inputCoreGroups, this.pv);\n\t\tthis.setCoreGroup(coreGroup);\n\t}\n}\n","/**\n * Adds post processing effects to a camera\n *\n *\n */\n\nimport {TypedSopNode} from './_Base';\nimport {CoreGroup} from '../../../core/geometry/Group';\nimport {CameraPostProcessSopOperation} from '../../operations/sop/CameraPostProcess';\nimport {HierarchyParamConfigAll, ParamConfig} from '../utils/params/ParamsConfig';\nimport {CameraSopNodeType, NetworkNodeType, NodeContext} from '../../poly/NodeContext';\nimport {PostNodeChildrenMap} from '../../poly/registers/nodes/Post';\nimport {NodeCreateOptions} from '../utils/hierarchy/ChildrenController';\nimport {Constructor, valueof} from '../../../types/GlobalTypes';\nimport {BasePostProcessNodeType} from '../post/_Base';\nimport {\n\tEffectComposerController,\n\tPostProcessNetworkParamsConfigMixin,\n\tPostProcessingTextureType,\n} from '../post/utils/EffectComposerController';\nimport {DisplayNodeController} from '../utils/DisplayNodeController';\nconst DEFAULT = CameraPostProcessSopOperation.DEFAULT_PARAMS;\n\nexport function CameraPostProcessParamsMixin<TBase extends Constructor>(Base: TBase) {\n\treturn class Mixin extends Base {\n\t\t/** @param set to true to define the post process nodes from a different node than this one */\n\t\tuseOtherNode = ParamConfig.BOOLEAN(DEFAULT.useOtherNode);\n\t\t/** @param other parent node containing the post process nodes that will make up the passes used */\n\t\tnode = ParamConfig.NODE_PATH('', {\n\t\t\tvisibleIf: {useOtherNode: 1},\n\t\t\tnodeSelection: {\n\t\t\t\ttypes: [NetworkNodeType.POST, CameraSopNodeType.POST_PROCESS],\n\t\t\t},\n\t\t\tdependentOnFoundNode: true,\n\t\t\tseparatorAfter: true,\n\t\t});\n\t};\n}\n\nclass CameraPostProcessSopParamsConfig extends PostProcessNetworkParamsConfigMixin(\n\tCameraPostProcessParamsMixin(HierarchyParamConfigAll)\n) {}\nconst ParamsConfig = new CameraPostProcessSopParamsConfig();\n\nexport class CameraPostProcessSopNode extends TypedSopNode<CameraPostProcessSopParamsConfig> {\n\toverride readonly paramsConfig = ParamsConfig;\n\tstatic override type() {\n\t\treturn CameraSopNodeType.POST_PROCESS;\n\t}\n\n\tprotected override initializeNode() {\n\t\tthis.io.inputs.setCount(1);\n\t\tthis.io.inputs.initInputsClonedState(CameraPostProcessSopOperation.INPUT_CLONED_STATE);\n\t}\n\n\tprivate _operation: CameraPostProcessSopOperation | undefined;\n\toverride cook(inputCoreGroups: CoreGroup[]) {\n\t\tthis._operation = this._operation || new CameraPostProcessSopOperation(this._scene, this.states, this);\n\t\tconst coreGroup = this._operation.cook(inputCoreGroups, this.pv);\n\t\tthis.setCoreGroup(coreGroup);\n\t}\n\n\tsetTextureType(textureType: PostProcessingTextureType) {\n\t\tthis.p.tTextureType.set(1);\n\t\tthis.p.textureType.set(textureType);\n\t}\n\n\t/*\n\tchildren\n\t*/\n\treadonly effectsComposerController: EffectComposerController = new EffectComposerController(this);\n\tpublic override readonly displayNodeController: DisplayNodeController = new DisplayNodeController(\n\t\tthis,\n\t\tthis.effectsComposerController.displayNodeControllerCallbacks()\n\t);\n\tprotected override _childrenControllerContext = NodeContext.POST;\n\toverride createNode<S extends keyof PostNodeChildrenMap>(\n\t\tnode_class: S,\n\t\toptions?: NodeCreateOptions\n\t): PostNodeChildrenMap[S];\n\toverride createNode<K extends valueof<PostNodeChildrenMap>>(\n\t\tnode_class: Constructor<K>,\n\t\toptions?: NodeCreateOptions\n\t): K;\n\toverride createNode<K extends valueof<PostNodeChildrenMap>>(\n\t\tnode_class: Constructor<K>,\n\t\toptions?: NodeCreateOptions\n\t): K {\n\t\treturn super.createNode(node_class, options) as K;\n\t}\n\toverride children() {\n\t\treturn super.children() as BasePostProcessNodeType[];\n\t}\n\toverride nodesByType<K extends keyof PostNodeChildrenMap>(type: K): PostNodeChildrenMap[K][] {\n\t\treturn super.nodesByType(type) as PostNodeChildrenMap[K][];\n\t}\n}\n","/**\n * Projects Points in relation to a camera.\n *\n */\n\nimport {TypedSopNode} from './_Base';\nimport {CoreGroup} from '../../../core/geometry/Group';\nimport {CameraProjectSopOperation} from '../../operations/sop/CameraProject';\n\nimport {NodeParamsConfig, ParamConfig} from '../utils/params/ParamsConfig';\nimport {SopType} from '../../poly/registers/nodes/types/Sop';\nconst DEFAULT = CameraProjectSopOperation.DEFAULT_PARAMS;\nclass CameraProjectSopParamsConfig extends NodeParamsConfig {\n\t/** @param unproject */\n\tproject = ParamConfig.BOOLEAN(DEFAULT.project);\n}\nconst ParamsConfig = new CameraProjectSopParamsConfig();\n\nexport class CameraProjectSopNode extends TypedSopNode<CameraProjectSopParamsConfig> {\n\toverride paramsConfig = ParamsConfig;\n\tstatic override type() {\n\t\treturn SopType.CAMERA_PROJECT;\n\t}\n\n\toverride initializeNode() {\n\t\tthis.io.inputs.setCount(2);\n\t\tthis.io.inputs.initInputsClonedState(CameraProjectSopOperation.INPUT_CLONED_STATE);\n\t}\n\n\tprivate _operation: CameraProjectSopOperation | undefined;\n\toverride cook(input_contents: CoreGroup[]) {\n\t\tthis._operation = this._operation || new CameraProjectSopOperation(this._scene, this.states, this);\n\t\tconst coreGroup = this._operation.cook(input_contents, this.pv);\n\t\tthis.setCoreGroup(coreGroup);\n\t}\n}\n","/**\n * sets the scene that this camera will render\n *\n *\n */\n\nimport {TypedSopNode} from './_Base';\nimport {CoreGroup} from '../../../core/geometry/Group';\nimport {CameraRenderSceneSopOperation} from '../../operations/sop/CameraRenderScene';\nimport {HierarchyParamConfigAll, ParamConfig} from '../utils/params/ParamsConfig';\nimport {CameraSopNodeType, NodeContext} from '../../poly/NodeContext';\nimport {ObjType} from '../../poly/registers/nodes/types/Obj';\nclass CameraRenderSceneSopParamsConfig extends HierarchyParamConfigAll {\n\t/** @param renderer */\n\tnode = ParamConfig.NODE_PATH('', {\n\t\tnodeSelection: {\n\t\t\tcontext: NodeContext.OBJ,\n\t\t\ttypes: [ObjType.SCENE],\n\t\t},\n\t\tdependentOnFoundNode: true,\n\t});\n}\nconst ParamsConfig = new CameraRenderSceneSopParamsConfig();\n\nexport class CameraRenderSceneSopNode extends TypedSopNode<CameraRenderSceneSopParamsConfig> {\n\toverride readonly paramsConfig = ParamsConfig;\n\tstatic override type() {\n\t\treturn CameraSopNodeType.RENDER_SCENE;\n\t}\n\n\tprotected override initializeNode() {\n\t\tthis.io.inputs.setCount(1);\n\t\tthis.io.inputs.initInputsClonedState(CameraRenderSceneSopOperation.INPUT_CLONED_STATE);\n\t}\n\n\tprivate _operation: CameraRenderSceneSopOperation | undefined;\n\toverride cook(inputCoreGroups: CoreGroup[]) {\n\t\tthis._operation = this._operation || new CameraRenderSceneSopOperation(this._scene, this.states, this);\n\t\tconst core_group = this._operation.cook(inputCoreGroups, this.pv);\n\t\tthis.setCoreGroup(core_group);\n\t}\n}\n","/**\n * offsets the camera view\n *\n *\n */\n\nimport {TypedSopNode} from './_Base';\nimport {CoreGroup} from '../../../core/geometry/Group';\nimport {CameraViewOffsetSopOperation} from '../../operations/sop/CameraViewOffset';\nimport {HierarchyParamConfigAll} from '../utils/params/ParamsConfig';\nimport {CameraSopNodeType} from '../../poly/NodeContext';\nimport {CoreCameraViewOffsetParamConfig} from '../../../core/camera/CoreCameraViewOffset';\nclass CameraViewOffsetSopParamsConfig extends CoreCameraViewOffsetParamConfig(HierarchyParamConfigAll) {}\nconst ParamsConfig = new CameraViewOffsetSopParamsConfig();\n\nexport class CameraViewOffsetSopNode extends TypedSopNode<CameraViewOffsetSopParamsConfig> {\n\toverride readonly paramsConfig = ParamsConfig;\n\tstatic override type() {\n\t\treturn CameraSopNodeType.VIEW_OFFSET;\n\t}\n\n\tprotected override initializeNode() {\n\t\tthis.io.inputs.setCount(1);\n\t\tthis.io.inputs.initInputsClonedState(CameraViewOffsetSopOperation.INPUT_CLONED_STATE);\n\t}\n\n\tprivate _operation: CameraViewOffsetSopOperation | undefined;\n\toverride cook(inputCoreGroups: CoreGroup[]) {\n\t\tthis._operation = this._operation || new CameraViewOffsetSopOperation(this._scene, this.states, this);\n\t\tconst coreGroup = this._operation.cook(inputCoreGroups, this.pv);\n\t\tthis.setCoreGroup(coreGroup);\n\t}\n}\n","import {ParamConfig} from '../../../engine/nodes/utils/params/ParamsConfig';\nimport {CameraWebXRARSopOperation} from '../../../engine/operations/sop/CameraWebXRAR';\nimport {Constructor} from '../../../types/GlobalTypes';\nimport {\n\tDEFAULT_WEBXR_REFERENCE_SPACE_TYPE,\n\tWEBXR_FEATURE_PARAM_OPTIONS,\n\tWEBXR_REFERENCE_SPACE_TYPES,\n} from '../../webXR/Common';\n\nconst DEFAULT = CameraWebXRARSopOperation.DEFAULT_PARAMS;\nexport function CoreCameraWebXRARParamConfig<TBase extends Constructor>(Base: TBase) {\n\treturn class Mixin extends Base {\n\t\t/** @param loads AR session with 'hit-test' feature */\n\t\thitTest = ParamConfig.INTEGER(DEFAULT.hitTest, WEBXR_FEATURE_PARAM_OPTIONS);\n\t\t/** @param loads AR session with 'light-estimation' feature */\n\t\tlightEstimation = ParamConfig.INTEGER(DEFAULT.lightEstimation, WEBXR_FEATURE_PARAM_OPTIONS);\n\t\t/** @param loads AR session with 'camera-access' feature */\n\t\tcameraAccess = ParamConfig.INTEGER(DEFAULT.cameraAccess, WEBXR_FEATURE_PARAM_OPTIONS);\n\t\t/** @param overrides referenceSpaceType */\n\t\toverrideReferenceSpaceType = ParamConfig.BOOLEAN(0);\n\t\t/** @param set referenceSpaceType ( see doc: https://immersive-web.github.io/webxr/#xrreferencespace-interface ) */\n\t\treferenceSpaceType = ParamConfig.INTEGER(\n\t\t\tWEBXR_REFERENCE_SPACE_TYPES.indexOf(DEFAULT_WEBXR_REFERENCE_SPACE_TYPE),\n\t\t\t{\n\t\t\t\tmenu: {\n\t\t\t\t\tentries: WEBXR_REFERENCE_SPACE_TYPES.map((name, value) => ({name, value})),\n\t\t\t\t},\n\t\t\t\tvisibleIf: {\n\t\t\t\t\toverrideReferenceSpaceType: 1,\n\t\t\t\t},\n\t\t\t}\n\t\t);\n\t};\n}\n","/**\n * allows the viewer created by this camera to be accessible in WebXR for AR (augmented reality)\n *\n *\n */\n\nimport {TypedSopNode} from './_Base';\nimport {CoreGroup} from '../../../core/geometry/Group';\nimport {CameraWebXRARSopOperation} from '../../operations/sop/CameraWebXRAR';\nimport {HierarchyParamConfigAll} from '../utils/params/ParamsConfig';\nimport {CameraSopNodeType} from '../../poly/NodeContext';\nimport {CoreCameraWebXRARParamConfig} from '../../../core/camera/webXR/CoreCameraWebXRAR';\n\nclass CameraWebXRARSopParamsConfig extends CoreCameraWebXRARParamConfig(HierarchyParamConfigAll) {}\nconst ParamsConfig = new CameraWebXRARSopParamsConfig();\n\nexport class CameraWebXRARSopNode extends TypedSopNode<CameraWebXRARSopParamsConfig> {\n\toverride readonly paramsConfig = ParamsConfig;\n\tstatic override type() {\n\t\treturn CameraSopNodeType.WEBXR_AR;\n\t}\n\n\tprotected override initializeNode() {\n\t\tthis.io.inputs.setCount(1);\n\t\tthis.io.inputs.initInputsClonedState(CameraWebXRARSopOperation.INPUT_CLONED_STATE);\n\t}\n\n\tprivate _operation: CameraWebXRARSopOperation | undefined;\n\toverride cook(inputCoreGroups: CoreGroup[]) {\n\t\tthis._operation = this._operation || new CameraWebXRARSopOperation(this._scene, this.states, this);\n\t\tconst coreGroup = this._operation.cook(inputCoreGroups, this.pv);\n\t\tthis.setCoreGroup(coreGroup);\n\t}\n}\n","import {ParamConfig} from '../../../engine/nodes/utils/params/ParamsConfig';\nimport {CameraWebXRVRSopOperation} from '../../../engine/operations/sop/CameraWebXRVR';\nimport {Constructor} from '../../../types/GlobalTypes';\nimport {\n\tDEFAULT_WEBXR_REFERENCE_SPACE_TYPE,\n\tWEBXR_FEATURE_PARAM_OPTIONS,\n\tWEBXR_REFERENCE_SPACE_TYPES,\n} from '../../webXR/Common';\n\nconst DEFAULT = CameraWebXRVRSopOperation.DEFAULT_PARAMS;\nexport function CoreCameraWebXRVRParamConfig<TBase extends Constructor>(Base: TBase) {\n\treturn class Mixin extends Base {\n\t\t/** @param loads AR session with 'local-floor' feature */\n\t\tlocalFloor = ParamConfig.INTEGER(DEFAULT.localFloor, WEBXR_FEATURE_PARAM_OPTIONS);\n\t\t/** @param loads AR session with 'bounded-floor' feature */\n\t\tboundedFloor = ParamConfig.INTEGER(DEFAULT.boundedFloor, WEBXR_FEATURE_PARAM_OPTIONS);\n\t\t/** @param loads AR session with 'hand-tracking' feature */\n\t\thandTracking = ParamConfig.INTEGER(DEFAULT.handTracking, WEBXR_FEATURE_PARAM_OPTIONS);\n\t\t/** @param loads AR session with 'layers' feature */\n\t\tlayers = ParamConfig.INTEGER(DEFAULT.layers, WEBXR_FEATURE_PARAM_OPTIONS);\n\t\t/** @param overrides referenceSpaceType */\n\t\toverrideReferenceSpaceType = ParamConfig.BOOLEAN(0);\n\t\t/** @param set referenceSpaceType ( see doc: https://immersive-web.github.io/webxr/#xrreferencespace-interface ) */\n\t\treferenceSpaceType = ParamConfig.INTEGER(\n\t\t\tWEBXR_REFERENCE_SPACE_TYPES.indexOf(DEFAULT_WEBXR_REFERENCE_SPACE_TYPE),\n\t\t\t{\n\t\t\t\tmenu: {\n\t\t\t\t\tentries: WEBXR_REFERENCE_SPACE_TYPES.map((name, value) => ({name, value})),\n\t\t\t\t},\n\t\t\t\tvisibleIf: {\n\t\t\t\t\toverrideReferenceSpaceType: 1,\n\t\t\t\t},\n\t\t\t}\n\t\t);\n\t};\n}\n","/**\n * allows the viewer created by this camera to be accessible in WebXR for VR (virtual reality)\n *\n *\n */\n\nimport {TypedSopNode} from './_Base';\nimport {CoreGroup} from '../../../core/geometry/Group';\nimport {CameraWebXRVRSopOperation} from '../../operations/sop/CameraWebXRVR';\nimport {HierarchyParamConfigAll} from '../utils/params/ParamsConfig';\nimport {CameraSopNodeType} from '../../poly/NodeContext';\nimport {CoreCameraWebXRVRParamConfig} from '../../../core/camera/webXR/CoreCameraWebXRVR';\n\nclass CameraWebXRVRSopParamsConfig extends CoreCameraWebXRVRParamConfig(HierarchyParamConfigAll) {}\nconst ParamsConfig = new CameraWebXRVRSopParamsConfig();\n\nexport class CameraWebXRVRSopNode extends TypedSopNode<CameraWebXRVRSopParamsConfig> {\n\toverride readonly paramsConfig = ParamsConfig;\n\tstatic override type() {\n\t\treturn CameraSopNodeType.WEBXR_VR;\n\t}\n\n\tprotected override initializeNode() {\n\t\tthis.io.inputs.setCount(1);\n\t\tthis.io.inputs.initInputsClonedState(CameraWebXRVRSopOperation.INPUT_CLONED_STATE);\n\t}\n\n\tprivate _operation: CameraWebXRVRSopOperation | undefined;\n\toverride cook(inputCoreGroups: CoreGroup[]) {\n\t\tthis._operation = this._operation || new CameraWebXRVRSopOperation(this._scene, this.states, this);\n\t\tconst coreGroup = this._operation.cook(inputCoreGroups, this.pv);\n\t\tthis.setCoreGroup(coreGroup);\n\t}\n}\n","/**\n * Creates a point at the center of each input objects\n *\n *\n */\n\nimport {TypedSopNode} from './_Base';\nimport {CoreGroup} from '../../../core/geometry/Group';\nimport {CenterSopOperation, CENTER_MODES, CenterMode} from '../../operations/sop/Center';\nimport {NodeParamsConfig, ParamConfig} from '../utils/params/ParamsConfig';\nconst DEFAULT = CenterSopOperation.DEFAULT_PARAMS;\nclass CenterSopParamsConfig extends NodeParamsConfig {\n\tmode = ParamConfig.INTEGER(DEFAULT.mode, {\n\t\tmenu: {\n\t\t\tentries: CENTER_MODES.map((name, value) => ({name, value})),\n\t\t},\n\t});\n}\nconst ParamsConfig = new CenterSopParamsConfig();\n\nexport class CenterSopNode extends TypedSopNode<CenterSopParamsConfig> {\n\toverride paramsConfig = ParamsConfig;\n\tstatic override type() {\n\t\treturn 'center';\n\t}\n\n\toverride initializeNode() {\n\t\tthis.io.inputs.setCount(1);\n\t\tthis.io.inputs.initInputsClonedState(CenterSopOperation.INPUT_CLONED_STATE);\n\t}\n\n\tprivate _operation: CenterSopOperation | undefined;\n\toverride cook(input_contents: CoreGroup[]) {\n\t\tthis._operation = this._operation || new CenterSopOperation(this.scene(), this.states, this);\n\t\tconst core_group = this._operation.cook(input_contents, this.pv);\n\t\tthis.setCoreGroup(core_group);\n\t}\n\n\tsetMode(mode: CenterMode) {\n\t\tthis.p.mode.set(CENTER_MODES.indexOf(mode));\n\t}\n}\n","/**\n * Creates a circle from 3 points.\n *\n *\n */\nimport {TypedSopNode} from './_Base';\nimport {InputCloneMode} from '../../poly/InputCloneMode';\nimport {CoreGroup} from '../../../core/geometry/Group';\nimport {BaseCorePoint, CorePoint} from '../../../core/geometry/entities/point/CorePoint';\nimport {Vector3} from 'three';\nimport {ObjectType} from '../../../core/geometry/Constant';\nimport {Object3D} from 'three';\n\nimport {\n\tPointsCountMode,\n\tPOINTS_COUNT_MODE,\n\tJoinMode,\n\tJOIN_MODES,\n\tCircle3Points,\n} from '../../../core/geometry/operation/Circle3Points';\nimport {NodeParamsConfig, ParamConfig} from '../utils/params/ParamsConfig';\nimport {isBooleanTrue} from '../../../core/BooleanValue';\nimport {SopType} from '../../poly/registers/nodes/types/Sop';\nimport {CoreObjectType} from '../../../core/geometry/ObjectContent';\n\nconst _points: CorePoint<CoreObjectType>[] = [];\nclass Circle3PointsSopParamsConfig extends NodeParamsConfig {\n\t/** @param toggle on to create the arc */\n\tarc = ParamConfig.BOOLEAN(1);\n\t/** @param sets the mode how the points count is computed */\n\tpointsCountMode = ParamConfig.INTEGER(POINTS_COUNT_MODE.indexOf(PointsCountMode.SEGMENTS_COUNT), {\n\t\tvisibleIf: {arc: 1},\n\t\tmenu: {\n\t\t\tentries: POINTS_COUNT_MODE.map((name, value) => {\n\t\t\t\treturn {value, name};\n\t\t\t}),\n\t\t},\n\t});\n\t/** @param length of each segment */\n\tsegmentsLength = ParamConfig.FLOAT(0.1, {\n\t\tvisibleIf: {arc: 1, pointsCountMode: POINTS_COUNT_MODE.indexOf(PointsCountMode.SEGMENTS_LENGTH)},\n\t\trange: [0, 1],\n\t\trangeLocked: [true, false],\n\t});\n\t/** @param count of the number of segments */\n\tsegmentsCount = ParamConfig.INTEGER(100, {\n\t\tvisibleIf: {arc: 1, pointsCountMode: POINTS_COUNT_MODE.indexOf(PointsCountMode.SEGMENTS_COUNT)},\n\t\trange: [1, 100],\n\t\trangeLocked: [true, false],\n\t});\n\t/** @param toggle on to create a full circle */\n\tfull = ParamConfig.BOOLEAN(1, {\n\t\tvisibleIf: {arc: 1},\n\t});\n\t/** @param TBD */\n\tjoinMode = ParamConfig.INTEGER(JOIN_MODES.indexOf(JoinMode.ABC), {\n\t\tvisibleIf: {arc: 1, full: 0},\n\t\tmenu: {\n\t\t\tentries: JOIN_MODES.map((name, value) => {\n\t\t\t\treturn {value, name};\n\t\t\t}),\n\t\t},\n\t});\n\t/** @param add an id attribute for the generated points */\n\taddIdAttribute = ParamConfig.BOOLEAN(1);\n\t/** @param add an idn attribute (same as id attribute, but normalized between 0 and 1) */\n\taddIdnAttribute = ParamConfig.BOOLEAN(1);\n\t/** @param toggle on to create a point in the center */\n\tcenter = ParamConfig.BOOLEAN(0);\n}\nconst ParamsConfig = new Circle3PointsSopParamsConfig();\n\nexport class Circle3PointsSopNode extends TypedSopNode<Circle3PointsSopParamsConfig> {\n\toverride paramsConfig = ParamsConfig;\n\tstatic override type() {\n\t\treturn SopType.CIRCLE_3_POINTS;\n\t}\n\n\toverride initializeNode() {\n\t\tthis.io.inputs.setCount(1);\n\t\tthis.io.inputs.initInputsClonedState([InputCloneMode.NEVER]);\n\t}\n\n\tsetPointsCountMode(mode: PointsCountMode) {\n\t\tthis.p.pointsCountMode.set(POINTS_COUNT_MODE.indexOf(mode));\n\t}\n\tpointsCountMode() {\n\t\treturn POINTS_COUNT_MODE[this.pv.pointsCountMode];\n\t}\n\n\toverride cook(inputCoreGroups: CoreGroup[]) {\n\t\tconst coreGroup = inputCoreGroups[0];\n\t\tcoreGroup.points(_points);\n\t\tif (_points.length < 3) {\n\t\t\tthis.states.error.set(`only ${_points.length} points found, when 3 are required`);\n\t\t} else {\n\t\t\tthis._createCircle(_points);\n\t\t}\n\t}\n\n\tprivate a: Vector3 = new Vector3();\n\tprivate b: Vector3 = new Vector3();\n\tprivate c: Vector3 = new Vector3();\n\n\tprivate _createCircle(points: BaseCorePoint[]) {\n\t\tconst circle3points = new Circle3Points({\n\t\t\tarc: isBooleanTrue(this.pv.arc),\n\t\t\tcenter: isBooleanTrue(this.pv.center),\n\t\t\tpointsCountMode: POINTS_COUNT_MODE[this.pv.pointsCountMode],\n\t\t\tsegmentsLength: this.pv.segmentsLength,\n\t\t\tsegmentsCount: this.pv.segmentsCount,\n\t\t\tfull: isBooleanTrue(this.pv.full),\n\t\t\tjoinMode: JOIN_MODES[this.pv.joinMode],\n\t\t\taddIdAttribute: isBooleanTrue(this.pv.addIdAttribute),\n\t\t\taddIdnAttribute: isBooleanTrue(this.pv.addIdnAttribute),\n\t\t});\n\t\tpoints[0].position(this.a);\n\t\tpoints[1].position(this.b);\n\t\tpoints[2].position(this.c);\n\t\tcircle3points.create(this.a, this.b, this.c);\n\n\t\tconst objects: Object3D[] = [];\n\t\tconst created_geometries = circle3points.created_geometries();\n\t\tif (created_geometries.arc) {\n\t\t\tobjects.push(this.createObject(created_geometries.arc, ObjectType.LINE_SEGMENTS));\n\t\t}\n\t\tif (created_geometries.center) {\n\t\t\tobjects.push(this.createObject(created_geometries.center, ObjectType.POINTS));\n\t\t}\n\n\t\tlet i = 0;\n\t\tfor (const object of objects) {\n\t\t\tobject.name = `${this.name()}-${i}`;\n\t\t\ti++;\n\t\t}\n\n\t\tthis.setObjects(objects);\n\t}\n}\n","/**\n * Creates a cone\n *\n *\n */\nimport {ObjectType} from './../../../core/geometry/Constant';\nimport {TypedSopNode} from './_Base';\nimport {Vector3} from 'three';\nimport {ConeGeometry} from 'three';\nimport {rotateGeometry} from '../../../core/Transform';\nimport {NodeParamsConfig, ParamConfig} from '../utils/params/ParamsConfig';\nimport {isBooleanTrue} from '../../../core/BooleanValue';\nimport {BaseSopOperation} from '../../operations/sop/_Base';\nimport {SopType} from '../../poly/registers/nodes/types/Sop';\nconst DEFAULT_UP = new Vector3(0, 1, 0);\n\nclass ConeSopParamsConfig extends NodeParamsConfig {\n\t/** @param cone radius */\n\tradius = ParamConfig.FLOAT(1, {range: [0, 1]});\n\t/** @param cone height */\n\theight = ParamConfig.FLOAT(1, {range: [0, 1]});\n\t/** @param radial segments count */\n\tsegmentsRadial = ParamConfig.INTEGER(12, {range: [3, 20], rangeLocked: [true, false]});\n\t/** @param height segments count */\n\tsegmentsHeight = ParamConfig.INTEGER(1, {range: [1, 20], rangeLocked: [true, false]});\n\t/** @param adds a cap */\n\tcap = ParamConfig.BOOLEAN(1);\n\t/** @param theta start */\n\tthetaStart = ParamConfig.FLOAT(1, {range: [0, Math.PI * 2]});\n\t/** @param start length */\n\tthetaLength = ParamConfig.FLOAT('2*$PI', {range: [0, Math.PI * 2]});\n\t/** @param center */\n\tcenter = ParamConfig.VECTOR3([0, 0, 0]);\n\t/** @param direction */\n\tdirection = ParamConfig.VECTOR3([0, 1, 0]); // should point up to match RBD expectation\n}\nconst ParamsConfig = new ConeSopParamsConfig();\n\nexport class ConeSopNode extends TypedSopNode<ConeSopParamsConfig> {\n\toverride paramsConfig = ParamsConfig;\n\tstatic override type() {\n\t\treturn SopType.CONE;\n\t}\n\n\toverride cook() {\n\t\tconst geometry = new ConeGeometry(\n\t\t\tthis.pv.radius,\n\t\t\tthis.pv.height,\n\t\t\tthis.pv.segmentsRadial,\n\t\t\tthis.pv.segmentsHeight,\n\t\t\t!isBooleanTrue(this.pv.cap),\n\t\t\tthis.pv.thetaStart,\n\t\t\tthis.pv.thetaLength\n\t\t);\n\n\t\trotateGeometry(geometry, DEFAULT_UP, this.pv.direction);\n\t\tgeometry.translate(this.pv.center.x, this.pv.center.y, this.pv.center.z);\n\n\t\tconst object = BaseSopOperation.createObject(geometry, ObjectType.MESH);\n\t\tobject.name = this.name();\n\n\t\tthis.setObject(object);\n\t}\n}\n","import {AttribValue} from '../../../types/GlobalTypes';\nimport {CoreGraphNode} from '../../../core/graph/CoreGraphNode';\nimport {PolyScene} from '../../scene/PolyScene';\n\nexport class BaseCopyStamp extends CoreGraphNode {\n\tprotected _globalIndex: number | undefined;\n\n\tconstructor(scene: PolyScene) {\n\t\tsuper(scene, 'CopyStamp');\n\t}\n\n\treset() {\n\t\tthis.setGlobalIndex(0);\n\t}\n\n\tsetGlobalIndex(index: number) {\n\t\tconst oldIndex = this._globalIndex;\n\t\tthis._globalIndex = index;\n\t\tif (oldIndex != this._globalIndex) {\n\t\t\tthis.setDirty();\n\t\t\tthis.removeDirtyState();\n\t\t}\n\t}\n\n\tvalue(attribName?: string): AttribValue | undefined {\n\t\treturn this._globalIndex;\n\t}\n}\n","import {BaseCopyStamp} from '../../utils/BaseCopyStamp';\nimport {BaseCorePoint} from '../../../../core/geometry/entities/point/CorePoint';\n\nexport class SopCopyStamp extends BaseCopyStamp {\n\tprotected _point: BaseCorePoint | undefined;\n\n\toverride reset() {\n\t\tsuper.reset();\n\t\tthis.setPoint(undefined);\n\t}\n\n\tsetPoint(point?: BaseCorePoint) {\n\t\tconst oldPoint = this._point;\n\t\tthis._point = point;\n\t\tif (oldPoint != this._point) {\n\t\t\tthis.setDirty();\n\t\t\tthis.removeDirtyState();\n\t\t}\n\t}\n\n\toverride value(attribName?: string) {\n\t\tif (this._point) {\n\t\t\tif (attribName) {\n\t\t\t\treturn this._point.attribValue(attribName);\n\t\t\t} else {\n\t\t\t\treturn this._point.index();\n\t\t\t}\n\t\t} else {\n\t\t\tif (attribName == null || attribName == 'i') {\n\t\t\t\treturn this._globalIndex;\n\t\t\t}\n\t\t}\n\t}\n}\n","/**\n * Copies a geometry onto every point from the right input.\n *\n * @remarks\n * This is different than the instance SOP, as the operation here is more expensive, but allows for more flexibility.\n *\n *\n */\nimport {ObjectTransformMode, ObjectTransformSpace} from './../../../core/TransformSpace';\nimport {SopType} from './../../poly/registers/nodes/types/Sop';\nimport {TypedSopNode} from './_Base';\nimport {CoreGroup} from '../../../core/geometry/Group';\nimport {BaseCoreObject} from '../../../core/geometry/entities/object/BaseCoreObject';\nimport {CoreInstancer} from '../../../core/geometry/Instancer';\nimport {SopCopyStamp} from './utils/CopyStamp';\nimport {Matrix4} from 'three';\nimport {BaseCorePoint, CorePoint} from '../../../core/geometry/entities/point/CorePoint';\nimport {NodeParamsConfig, ParamConfig} from '../utils/params/ParamsConfig';\nimport {InputCloneMode} from '../../poly/InputCloneMode';\nimport {isBooleanTrue} from '../../../core/BooleanValue';\nimport {\n\tfilterCoreObjectsFromCoreGroup,\n\tfilterObjectsWithGroup,\n\tfilterThreejsCoreObjectsFromCoreGroup,\n} from '../../../core/geometry/Mask';\nimport {CoreTransform, RotationOrder, TRANSFORM_TARGET_TYPES, TransformTargetType} from '../../../core/Transform';\nimport {OBJECT_TRANSFORM_SPACE_MENU_ENTRIES, OBJECT_TRANSFORM_SPACES} from '../../../core/TransformSpace';\nimport {CoreObjectType, ObjectContent} from '../../../core/geometry/ObjectContent';\nimport {coreObjectClassFactory} from '../../../core/geometry/CoreObjectFactory';\nimport {pointsFromCoreObjects} from '../../../core/geometry/entities/point/CorePointUtils';\n\n// export enum TransformMode {\n// \tOBJECT = 'object',\n// \tGEOMETRY = 'geometry',\n// }\n// export const TRANSFORM_MODES: TransformMode[] = [TransformMode.OBJECT, TransformMode.GEOMETRY];\n// const TransformModeMenuEntries = [\n// \t{name: 'object', value: TRANSFORM_MODES.indexOf(TransformMode.OBJECT)},\n// \t{name: 'geometry', value: TRANSFORM_MODES.indexOf(TransformMode.GEOMETRY)},\n// ];\n\nclass CopySopParamsConfig extends NodeParamsConfig {\n\t/** @param select which objects are copied */\n\tsrcGroup = ParamConfig.STRING('', {\n\t\tobjectMask: true,\n\t});\n\t/** @param select which objects the src objects are copied onto */\n\ttemplateGroup = ParamConfig.STRING('', {\n\t\tobjectMask: {\n\t\t\tinputIndex: 1,\n\t\t},\n\t});\n\t/** @param copies count, used when the second input is not given */\n\tcount = ParamConfig.INTEGER(1, {\n\t\trange: [1, 20],\n\t\trangeLocked: [true, false],\n\t});\n\t/** @param translate each copy */\n\tt = ParamConfig.VECTOR3([0, 0, 0]);\n\t/** @param rotate each copy */\n\tr = ParamConfig.VECTOR3([0, 0, 0]);\n\t/** @param scale each copy */\n\ts = ParamConfig.VECTOR3([1, 1, 1]);\n\t/** @param scale multiplier for each copy */\n\tscale = ParamConfig.FLOAT(1);\n\t/** @param transforms every input object each on a single input point */\n\ttransformOnly = ParamConfig.BOOLEAN(0);\n\t/** @param defines if the objects or the geometries are transformed */\n\ttransformMode = ParamConfig.INTEGER(TRANSFORM_TARGET_TYPES.indexOf(TransformTargetType.OBJECT), {\n\t\tmenu: {\n\t\t\tentries: TRANSFORM_TARGET_TYPES.map((name, value) => ({name, value})),\n\t\t},\n\t});\n\t/** @param defines how the objects are transformed */\n\tobjectTransformSpace = ParamConfig.INTEGER(0, {\n\t\tvisibleIf: {transformMode: TRANSFORM_TARGET_TYPES.indexOf(TransformTargetType.OBJECT)},\n\t\tmenu: {\n\t\t\tentries: OBJECT_TRANSFORM_SPACE_MENU_ENTRIES,\n\t\t},\n\t});\n\t/** @param toggles on to copy attributes from the input points to the created objects. Note that the vertex attributes from the points become object attributes */\n\tcopyAttributes = ParamConfig.BOOLEAN(0);\n\t/** @param names of attributes to copy */\n\tattributesToCopy = ParamConfig.STRING('', {\n\t\tvisibleIf: {copyAttributes: true},\n\t});\n\t/** @param toggle on to use the `copy` expression, which allows to change how the left input is evaluated for each point */\n\tuseCopyExpr = ParamConfig.BOOLEAN(1);\n}\nconst ParamsConfig = new CopySopParamsConfig();\n\nexport class CopySopNode extends TypedSopNode<CopySopParamsConfig> {\n\toverride paramsConfig = ParamsConfig;\n\tstatic override type() {\n\t\treturn SopType.COPY;\n\t}\n\n\tprivate _attribNamesToCopy: string[] = [];\n\tprivate _objects: ObjectContent<CoreObjectType>[] = [];\n\tprivate _stampNode!: SopCopyStamp;\n\n\toverride initializeNode() {\n\t\tthis.io.inputs.setCount(1, 2);\n\t\tthis.io.inputs.initInputsClonedState([InputCloneMode.FROM_NODE, InputCloneMode.NEVER]);\n\t}\n\n\tsetTransformMode(transformMode: TransformTargetType) {\n\t\tthis.p.transformMode.set(TRANSFORM_TARGET_TYPES.indexOf(transformMode));\n\t}\n\tsetObjectTransformSpace(transformSpace: ObjectTransformSpace) {\n\t\tthis.p.objectTransformSpace.set(OBJECT_TRANSFORM_SPACES.indexOf(transformSpace));\n\t}\n\n\toverride async cook(inputCoreGroups: CoreGroup[]) {\n\t\tif (!isBooleanTrue(this.pv.useCopyExpr)) {\n\t\t\tthis.stampNode().reset();\n\t\t}\n\t\tconst coreGroup0 = inputCoreGroups[0];\n\t\tif (!this.io.inputs.hasInput(1)) {\n\t\t\tawait this.cookWithoutTemplate(coreGroup0);\n\t\t\treturn;\n\t\t}\n\n\t\tconst coreGroup1 = inputCoreGroups[1];\n\t\tif (!coreGroup1) {\n\t\t\tthis.states.error.set('second input invalid');\n\t\t\treturn;\n\t\t}\n\t\tawait this.cookWithTemplate(coreGroup0, coreGroup1);\n\t\tthis.stampNode().reset();\n\t}\n\n\tprivate _instancer = new CoreInstancer();\n\tprivate async cookWithTemplate(instanceCoreGroup: CoreGroup, templateCoreGroup: CoreGroup) {\n\t\tthis._objects = [];\n\n\t\tconst templateCoreObjects = filterThreejsCoreObjectsFromCoreGroup(templateCoreGroup, {\n\t\t\tgroup: this.pv.templateGroup,\n\t\t});\n\t\tconst templatePoints: CorePoint<CoreObjectType>[] = [];\n\t\tpointsFromCoreObjects(templateCoreObjects, templatePoints);\n\n\t\tthis._instancer.setCoreGroup(templateCoreGroup);\n\n\t\tthis._attribNamesToCopy = templateCoreGroup.pointAttribNamesMatchingMask(this.pv.attributesToCopy);\n\t\tawait this._copyMovedObjectsOnTemplatePoints(instanceCoreGroup, templatePoints);\n\t\tthis.setObjects(this._objects);\n\t}\n\n\t// https://stackoverflow.com/questions/24586110/resolve-promises-one-after-another-i-e-in-sequence\n\tprivate async _copyMovedObjectsOnTemplatePoints(instanceCoreGroup: CoreGroup, templatePoints: BaseCorePoint[]) {\n\t\tthis._initAccumulatedTransform();\n\t\tfor (let pointIndex = 0; pointIndex < templatePoints.length; pointIndex++) {\n\t\t\tawait this._copyMovedObjectOnTemplatePoint(instanceCoreGroup, templatePoints, pointIndex);\n\t\t\tthis._accumulateTransform();\n\t\t}\n\t}\n\n\tprivate _instanceMatrix = new Matrix4();\n\tprivate async _copyMovedObjectOnTemplatePoint(\n\t\tinstanceCoreGroup: CoreGroup,\n\t\ttemplatePoints: BaseCorePoint[],\n\t\tpoint_index: number\n\t) {\n\t\tthis._instancer.matrixFromPoint(templatePoints[point_index], this._instanceMatrix);\n\t\tconst templatePoint = templatePoints[point_index];\n\t\tif (isBooleanTrue(this.pv.useCopyExpr)) {\n\t\t\tthis.stampNode().setPoint(templatePoint);\n\t\t}\n\n\t\tconst movedObjects = await this._getMovedObjectsForTemplatePoint(instanceCoreGroup, point_index);\n\n\t\tfor (const movedObject of movedObjects) {\n\t\t\tif (isBooleanTrue(this.pv.copyAttributes)) {\n\t\t\t\tthis._copyAttributesGromTemplate(movedObject, templatePoint);\n\t\t\t}\n\n\t\t\t// TODO: that node is getting inconsistent...\n\t\t\t// should I always only move the object?\n\t\t\t// and have a toggle to bake back to the geo?\n\t\t\t// or just enfore the use of a merge?\n\t\t\tif (isBooleanTrue(this.pv.transformOnly)) {\n\t\t\t\tmovedObject.applyMatrix4(this._instanceMatrix);\n\t\t\t} else {\n\t\t\t\tthis._applyMatrixToObject(movedObject, this._instanceMatrix);\n\t\t\t}\n\t\t\tthis._applyAccumulatedTransform(movedObject);\n\n\t\t\tthis._objects.push(movedObject);\n\t\t}\n\t}\n\tprivate async _getMovedObjectsForTemplatePoint(\n\t\tinstanceCoreGroup: CoreGroup,\n\t\tpointIndex: number\n\t): Promise<ObjectContent<CoreObjectType>[]> {\n\t\tconst stampedInstanceCoreGroup = await this._stampInstanceGroupIfRequired(instanceCoreGroup);\n\t\tif (stampedInstanceCoreGroup) {\n\t\t\t// duplicate or select from instance children\n\t\t\tconst getObjectsForTransformOnly = () => {\n\t\t\t\tconst objects = filterObjectsWithGroup(stampedInstanceCoreGroup, {group: this.pv.srcGroup});\n\t\t\t\tconst object = objects[pointIndex];\n\t\t\t\tif (object) {\n\t\t\t\t\treturn [coreObjectClassFactory(object).clone(object)];\n\t\t\t\t} else {\n\t\t\t\t\treturn [];\n\t\t\t\t}\n\t\t\t};\n\t\t\tconst movedObjects = isBooleanTrue(this.pv.transformOnly)\n\t\t\t\t? // TODO: why is doing a transform slower than cloning the input??\n\t\t\t\t  getObjectsForTransformOnly()\n\t\t\t\t: filterObjectsWithGroup(stampedInstanceCoreGroup.clone(), {group: this.pv.srcGroup});\n\n\t\t\treturn movedObjects;\n\t\t} else {\n\t\t\treturn [];\n\t\t}\n\t}\n\n\tprivate async _stampInstanceGroupIfRequired(instanceCoreGroup: CoreGroup): Promise<CoreGroup | undefined> {\n\t\t// we do not test here for pv.useCopyExpr\n\t\t// as we use the stampNode.reset() at the beginning of the cook\n\t\t// to reupdate it if necessary,\n\t\t// which can be needed when we switch from\n\t\t// useCopyExpr=true to useCopyExpr=false\n\t\t// in which case the copy() expression should return 0.\n\t\t// If we were not doing that, it would return the last evaluated value\n\t\t// if (isBooleanTrue(this.pv.useCopyExpr)) {\n\t\tconst container0 = await this.containerController.requestInputContainer(0);\n\t\tif (container0) {\n\t\t\tconst coreGroup0 = container0.coreContent();\n\t\t\tif (coreGroup0) {\n\t\t\t\treturn coreGroup0;\n\t\t\t} else {\n\t\t\t\treturn;\n\t\t\t}\n\t\t} else {\n\t\t\tthis.states.error.set(`input failed for index ${this.stampValue()}`);\n\t\t\treturn;\n\t\t}\n\t\t// } else {\n\t\t// \treturn instanceCoreGroup;\n\t\t// }\n\t}\n\n\tprivate async _copyMovedObjectsForEachInstance(instanceCoreGroup: CoreGroup) {\n\t\tthis._initAccumulatedTransform();\n\t\tfor (let i = 0; i < this.pv.count; i++) {\n\t\t\tawait this._copyMovedObjectsForInstance(instanceCoreGroup, i);\n\t\t\tthis._accumulateTransform();\n\t\t}\n\t}\n\n\tprivate async _copyMovedObjectsForInstance(instanceCoreGroup: CoreGroup, i: number) {\n\t\tif (isBooleanTrue(this.pv.useCopyExpr)) {\n\t\t\tthis.stampNode().setGlobalIndex(i);\n\t\t}\n\n\t\tconst stamptedInstanceCoreGroup = await this._stampInstanceGroupIfRequired(instanceCoreGroup);\n\t\tif (stamptedInstanceCoreGroup) {\n\t\t\tconst srcCoreObjects = filterCoreObjectsFromCoreGroup(stamptedInstanceCoreGroup, {\n\t\t\t\tgroup: this.pv.srcGroup,\n\t\t\t});\n\t\t\tfor (const coreObject of srcCoreObjects) {\n\t\t\t\t// TODO: I should use the Core Group, to ensure that material.linewidth is properly cloned\n\t\t\t\tconst clonedObject = coreObject.clone().object();\n\t\t\t\tif (clonedObject) {\n\t\t\t\t\tthis._applyAccumulatedTransform(clonedObject);\n\t\t\t\t\tthis._objects.push(clonedObject);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// TODO: what if I combine both param_count and stamping?!\n\tprivate async cookWithoutTemplate(instanceCoreGroup: CoreGroup) {\n\t\tthis._objects = [];\n\t\tawait this._copyMovedObjectsForEachInstance(instanceCoreGroup);\n\n\t\tthis.setObjects(this._objects);\n\t}\n\n\tprivate _copyAttributesGromTemplate(object: ObjectContent<CoreObjectType>, templatePoint: BaseCorePoint) {\n\t\tthis._attribNamesToCopy.forEach((attribName, i) => {\n\t\t\tconst attribValue = templatePoint.attribValue(attribName);\n\t\t\tBaseCoreObject.addAttribute(object, attribName, attribValue);\n\t\t});\n\t}\n\n\t//\n\t//\n\t// STAMP\n\t//\n\t//\n\tstampValue(attribName?: string) {\n\t\treturn this.stampNode().value(attribName);\n\t}\n\tstampNode() {\n\t\treturn (this._stampNode = this._stampNode || this._createStampNode());\n\t}\n\tprivate _createStampNode() {\n\t\tconst stampNode = new SopCopyStamp(this.scene());\n\t\t// this.dirtyController.setForbiddenTriggerNodes([stampNode]);\n\t\tstampNode.setForbiddenTriggerNodes(this);\n\t\treturn stampNode;\n\t}\n\toverride dispose() {\n\t\tsuper.dispose();\n\t\tif (this._stampNode) {\n\t\t\tthis._stampNode.dispose();\n\t\t}\n\t}\n\n\t//\n\t//\n\t// ACCUMULATE TRANSFORM\n\t//\n\t//\n\tprivate _coreTransform = new CoreTransform();\n\tprivate _transformAccumulatedMatrix = new Matrix4();\n\tprivate _transformMatrix = new Matrix4();\n\tprivate _initAccumulatedTransform() {\n\t\tconst pv = this.pv;\n\t\tthis._transformMatrix = this._coreTransform.matrix(pv.t, pv.r, pv.s, pv.scale, RotationOrder.XYZ);\n\t\tthis._transformAccumulatedMatrix.identity();\n\t}\n\tprivate _accumulateTransform() {\n\t\tthis._transformAccumulatedMatrix.multiply(this._transformMatrix);\n\t}\n\tprivate _applyMatrixToObject(object: ObjectContent<CoreObjectType>, matrix: Matrix4) {\n\t\tcoreObjectClassFactory(object).applyMatrix(\n\t\t\tobject,\n\t\t\tmatrix,\n\t\t\tTRANSFORM_TARGET_TYPES[this.pv.transformMode],\n\t\t\tOBJECT_TRANSFORM_SPACES[this.pv.objectTransformSpace],\n\t\t\tObjectTransformMode.MULT\n\t\t);\n\t\t// if (isObject3D(object)) {\n\t\t// \tthis._applyMatrixToObjectOrGeometry(object, this._transformAccumulatedMatrix);\n\t\t// } else {\n\t\t// \tconsole.warn('transform cad accumulative not implemented');\n\t\t// }\n\t\t// object.matrix.multiply(this._transformAccumulatedMatrix);\n\t\t// object.matrix.decompose(object.position, object.quaternion, object.scale);\n\t\t// object.matrixAutoUpdate = false;\n\t}\n\tprivate _applyAccumulatedTransform(object: ObjectContent<CoreObjectType>) {\n\t\tthis._applyMatrixToObject(object, this._transformAccumulatedMatrix);\n\t\t// if (isObject3D(object)) {\n\t\t// \tthis._applyMatrixToObjectOrGeometry(object, this._transformAccumulatedMatrix);\n\t\t// } else {\n\t\t// \tconsole.warn('transform cad accumulative not implemented');\n\t\t// }\n\t\t// object.matrix.multiply(this._transformAccumulatedMatrix);\n\t\t// object.matrix.decompose(object.position, object.quaternion, object.scale);\n\t\t// object.matrixAutoUpdate = false;\n\t}\n\n\t//\n\t//\n\t// MATRIX OPERATIONS\n\t//\n\t//\n\t// private _applyMatrixToObjectOrGeometry(object: ObjectContent<CoreObjectType>, matrix: Matrix4) {\n\t// \tconst transformMode = TRANSFORM_MODES[this.pv.transformMode];\n\t// \tswitch (transformMode) {\n\t// \t\tcase TransformMode.OBJECT: {\n\t// \t\t\tthis._applyMatrixToObject(object, matrix);\n\t// \t\t\treturn;\n\t// \t\t}\n\t// \t\tcase TransformMode.GEOMETRY: {\n\t// \t\t\tconst geometry = (object as Object3DWithGeometry).geometry;\n\t// \t\t\tif (geometry) {\n\t// \t\t\t\tgeometry.applyMatrix4(matrix);\n\t// \t\t\t}\n\t// \t\t\treturn;\n\t// \t\t}\n\t// \t}\n\t// \tTypeAssert.unreachable(transformMode);\n\t// }\n\n\t// private _object_position = new Vector3();\n\t// private _applyMatrixToObject(object: ObjectContent<CoreObjectType>, matrix: Matrix4) {\n\t// \tapplyTransformWithSpaceToObject(object, matrix, OBJECT_TRANSFORM_SPACES[this.pv.objectTransformSpace]);\n\t// }\n}\n","/**\n * Creates a cube camera.\n *\n *\n */\n\nimport {TypedSopNode} from './_Base';\nimport {CoreGroup} from '../../../core/geometry/Group';\nimport {CubeCameraSopOperation} from '../../operations/sop/CubeCamera';\nimport {NodeParamsConfig, ParamConfig} from '../utils/params/ParamsConfig';\nimport {CameraNodeType} from '../../poly/NodeContext';\nimport {CUBE_CAMERA_DEFAULT, registerCubeCamera} from '../../../core/camera/CoreCubeCamera';\nimport {OnNodeRegisterCallback} from '../../poly/registers/nodes/NodesRegister';\nconst DEFAULT = CubeCameraSopOperation.DEFAULT_PARAMS;\nclass CubeCameraSopParamsConfig extends NodeParamsConfig {\n\t/** @param camera near */\n\tnear = ParamConfig.FLOAT(DEFAULT.near, {\n\t\trange: [0, 100],\n\t\trangeLocked: [true, false],\n\t});\n\t/** @param camera far */\n\tfar = ParamConfig.FLOAT(DEFAULT.far, {\n\t\trange: [0, 100],\n\t\trangeLocked: [true, false],\n\t});\n\t/** @param resolution */\n\tresolution = ParamConfig.FLOAT(CUBE_CAMERA_DEFAULT.resolution, {range: CUBE_CAMERA_DEFAULT.resolutionRange});\n\t/** @param camera position */\n\tposition = ParamConfig.VECTOR3(DEFAULT.position);\n\t/** @param camera rotation */\n\trotation = ParamConfig.VECTOR3(DEFAULT.rotation);\n\t/** @param show helper */\n\tshowHelper = ParamConfig.BOOLEAN(DEFAULT.showHelper);\n\t/** @param matrixAutoUpdate */\n\tmatrixAutoUpdate = ParamConfig.BOOLEAN(DEFAULT.matrixAutoUpdate);\n\t/** @param camera name */\n\tname = ParamConfig.STRING('`$OS`');\n}\n\nconst ParamsConfig = new CubeCameraSopParamsConfig();\n\nexport class CubeCameraSopNode extends TypedSopNode<CubeCameraSopParamsConfig> {\n\toverride readonly paramsConfig = ParamsConfig;\n\tstatic override type() {\n\t\treturn CameraNodeType.CUBE;\n\t}\n\tstatic override onRegister: OnNodeRegisterCallback = registerCubeCamera;\n\n\tprotected override initializeNode() {\n\t\tthis.io.inputs.setCount(0);\n\t}\n\n\tprivate _operation: CubeCameraSopOperation | undefined;\n\toverride cook(inputCoreGroups: CoreGroup[]) {\n\t\tthis._operation = this._operation || new CubeCameraSopOperation(this._scene, this.states, this);\n\t\tconst coreGroup = this._operation.cook(inputCoreGroups, this.pv);\n\t\tthis.setCoreGroup(coreGroup);\n\t}\n}\n","/**\n * Deletes input objects by name\n *\n *\n *\n */\nimport {TypedSopNode} from './_Base';\nimport {CoreGroup} from '../../../core/geometry/Group';\nimport {DeleteByNameSopOperation} from '../../operations/sop/DeleteByName';\nimport {NodeParamsConfig, ParamConfig} from '../utils/params/ParamsConfig';\nimport {SopType} from '../../poly/registers/nodes/types/Sop';\n\nconst DEFAULT = DeleteByNameSopOperation.DEFAULT_PARAMS;\nclass DeleteByNameSopParamConfig extends NodeParamsConfig {\n\t/** @param group to assign the material to */\n\tgroup = ParamConfig.STRING(DEFAULT.group, {\n\t\tobjectMask: true,\n\t});\n\t/** @param invert */\n\tinvert = ParamConfig.BOOLEAN(DEFAULT.invert);\n}\nconst ParamsConfig = new DeleteByNameSopParamConfig();\n\nexport class DeleteByNameSopNode extends TypedSopNode<DeleteByNameSopParamConfig> {\n\toverride paramsConfig = ParamsConfig;\n\tstatic override type() {\n\t\treturn SopType.DELETE_BY_NAME;\n\t}\n\n\toverride initializeNode() {\n\t\tthis.io.inputs.setCount(1);\n\t\tthis.io.inputs.initInputsClonedState(DeleteByNameSopOperation.INPUT_CLONED_STATE);\n\t}\n\n\tprivate _operation: DeleteByNameSopOperation | undefined;\n\toverride cook(inputCoreGroups: CoreGroup[]) {\n\t\tthis._operation = this._operation || new DeleteByNameSopOperation(this.scene(), this.states, this);\n\t\tconst coreGroup = this._operation.cook(inputCoreGroups, this.pv);\n\t\tthis.setCoreGroup(coreGroup);\n\t}\n}\n","/**\n * Creates an empty object\n *\n *\n */\n\nimport {TypedSopNode} from './_Base';\nimport {CoreGroup} from '../../../core/geometry/Group';\nimport {EmptyObjectSopOperation} from '../../operations/sop/EmptyObject';\n\nimport {NodeParamsConfig, ParamConfig} from '../utils/params/ParamsConfig';\nimport {ObjectType} from '../../../core/geometry/Constant';\n\nconst OBJECT_TYPES: ObjectType[] = [\n\tObjectType.OBJECT3D,\n\tObjectType.GROUP,\n\tObjectType.MESH,\n\tObjectType.POINTS,\n\tObjectType.LINE_SEGMENTS,\n];\n\nclass EmptyObjectSopParamsConfig extends NodeParamsConfig {\n\ttype = ParamConfig.STRING(ObjectType.GROUP, {\n\t\tmenuString: {\n\t\t\tentries: OBJECT_TYPES.map((name, value) => ({name, value: name})),\n\t\t},\n\t});\n}\nconst ParamsConfig = new EmptyObjectSopParamsConfig();\n\nexport class EmptyObjectSopNode extends TypedSopNode<EmptyObjectSopParamsConfig> {\n\toverride readonly paramsConfig = ParamsConfig;\n\tstatic override type() {\n\t\treturn 'emptyObject';\n\t}\n\n\tprotected override initializeNode() {\n\t\tthis.io.inputs.setCount(0);\n\t}\n\n\tprivate _operation: EmptyObjectSopOperation | undefined;\n\toverride cook(input_contents: CoreGroup[]) {\n\t\tthis._operation = this._operation || new EmptyObjectSopOperation(this._scene, this.states, this);\n\t\tconst type = this.pv.type as ObjectType;\n\t\tconst coreGroup = this._operation.cook(input_contents, {type});\n\t\tthis.setCoreGroup(coreGroup);\n\t}\n\tsetObjectType(objectType: ObjectType) {\n\t\tthis.p.type.set(objectType);\n\t}\n\tobjectType(): ObjectType | undefined {\n\t\tconst included = OBJECT_TYPES.includes(this.pv.type as ObjectType);\n\t\treturn included ? (this.pv.type as ObjectType) : undefined;\n\t}\n}\n","import {BasePersistedConfig} from '../../../../utils/BasePersistedConfig';\nimport {SingleBodyFunctionData} from '../_Base';\nimport {SerializedVariable, SerializedVariableType} from '../_BaseJsPersistedConfigUtils';\nimport {NamedFunctionMap} from '../../../../../poly/registers/functions/All';\nimport {JsParamConfig, JsParamConfigJSON} from '../../utils/JsParamConfig';\nimport {ParamType} from '../../../../../poly/ParamType';\nimport {\n\tSingleBodyPersistedConfigBaseJsData,\n\tserializedVariablesFromFunctionData,\n\tvariablesByNameFromPersistedConfigData,\n\tfunctionsByNameFromPersistedConfigData,\n} from '../_BaseJsPersistedConfig';\nimport {JsConnectionPointType} from '../../../../utils/io/connections/Js';\nimport type {InstanceBuilderSopNode} from '../../../../sop/InstanceBuilder';\nimport type {EntityBuilderSopNode} from '../../../../sop/EntityBuilder';\n\nexport interface EntityBuilderFunctionDataAttributeDataItem {\n\tattribName: string;\n\tattribType: JsConnectionPointType;\n}\nexport interface EntityBuilderFunctionDataAttributeDataReadWrite {\n\tread: EntityBuilderFunctionDataAttributeDataItem[];\n\twrite: EntityBuilderFunctionDataAttributeDataItem[];\n}\nexport interface EntityBuilderFunctionData extends SingleBodyFunctionData {\n\tattributesData: EntityBuilderFunctionDataAttributeDataReadWrite;\n}\n\nexport interface EntityBuilderPersistedConfigBaseJsData extends SingleBodyPersistedConfigBaseJsData {\n\tfunctionBody: string;\n\tvariableNames: string[];\n\tvariables: SerializedVariable<SerializedVariableType>[];\n\tfunctionNames: Array<keyof NamedFunctionMap>;\n\tserializedParamConfigs: JsParamConfigJSON<ParamType>[];\n\tattributesData: EntityBuilderFunctionDataAttributeDataReadWrite;\n}\n\nexport class BaseEntityBuilderPersistedConfig extends BasePersistedConfig {\n\tconstructor(protected override node: EntityBuilderSopNode | InstanceBuilderSopNode) {\n\t\tsuper(node);\n\t}\n\toverride async toData(): Promise<EntityBuilderPersistedConfigBaseJsData | undefined> {\n\t\t// we need to compute the node here it case it hasn't yet,\n\t\t// otherwise the .functionData() will be empty\n\t\tawait this.node.compile();\n\t\t//\n\t\tconst assemblerController = this.node.assemblerController();\n\t\tif (!assemblerController) {\n\t\t\treturn;\n\t\t}\n\t\tconst functionData = this.node.functionData();\n\t\tif (!functionData) {\n\t\t\treturn;\n\t\t}\n\t\tconst {functionBody, variableNames, functionNames, paramConfigs, attributesData} = functionData;\n\n\t\tconst data: EntityBuilderPersistedConfigBaseJsData = {\n\t\t\tfunctionBody,\n\t\t\tvariableNames,\n\t\t\tvariables: serializedVariablesFromFunctionData(functionData),\n\t\t\tfunctionNames,\n\t\t\tserializedParamConfigs: paramConfigs.map((p) => p.toJSON()),\n\t\t\tattributesData,\n\t\t};\n\t\treturn data;\n\t}\n\toverride load(data: EntityBuilderPersistedConfigBaseJsData) {\n\t\tconst assemblerController = this.node.assemblerController();\n\t\tif (assemblerController) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst {functionBody, variableNames, functionNames, serializedParamConfigs, attributesData} = data;\n\n\t\tconst functionData: EntityBuilderFunctionData = {\n\t\t\tfunctionBody: functionBody,\n\t\t\tvariableNames,\n\t\t\tvariablesByName: variablesByNameFromPersistedConfigData(data),\n\t\t\tfunctionNames,\n\t\t\tfunctionsByName: functionsByNameFromPersistedConfigData(data, this.node),\n\t\t\tparamConfigs: serializedParamConfigs.map((json) => JsParamConfig.fromJSON(json)),\n\t\t\tattributesData,\n\t\t};\n\t\tthis.node.updateFromFunctionData(functionData);\n\t}\n}\n","import {EntityBuilderSopNode} from '../../../../sop/EntityBuilder';\nimport {BaseEntityBuilderPersistedConfig} from './_BaseEntityBuilderPersistedConfig';\n\nexport class EntityBuilderPersistedConfig extends BaseEntityBuilderPersistedConfig {\n\tconstructor(protected override node: EntityBuilderSopNode) {\n\t\tsuper(node);\n\t}\n}\n","/**\n * Updates points with JS nodes\n *\n *\n */\nimport {TypedSopNode} from './_Base';\nimport {CoreGroup} from '../../../core/geometry/Group';\nimport {InputCloneMode} from '../../poly/InputCloneMode';\nimport {NodeParamsConfig, ParamConfig} from '../utils/params/ParamsConfig';\nimport {EntityBuilderFunctionData} from '../js/code/assemblers/entityBuilder/_BaseEntityBuilderPersistedConfig';\n\nimport {AssemblerName} from '../../poly/registers/assemblers/_BaseRegister';\nimport {JsAssemblerController} from '../js/code/Controller';\nimport type {JsAssemblerEntityBuilder} from '../js/code/assemblers/entityBuilder/EntityBuilderAssembler';\nimport {\n\tEntityContainer,\n\tEntityBuilderAssemblerConstant,\n} from '../js/code/assemblers/entityBuilder/EntityBuilderAssemblerCommon';\nimport {Poly} from '../../Poly';\nimport {NodeContext} from '../../poly/NodeContext';\nimport {JsNodeChildrenMap} from '../../poly/registers/nodes/Js';\nimport {NodeCreateOptions} from '../utils/hierarchy/ChildrenController';\nimport {Constructor, valueof} from '../../../types/GlobalTypes';\nimport {BaseJsNodeType} from '../js/_Base';\nimport {JsParamConfig} from '../js/code/utils/JsParamConfig';\nimport {ParamType} from '../../poly/ParamType';\nimport {RegisterableVariable, createVariable} from '../js/code/assemblers/_BaseJsPersistedConfigUtils';\nimport {JsNodeFinder} from '../js/code/utils/NodeFinder';\nimport {CoreType, isColor, isVector, isNumber} from '../../../core/Type';\nimport {BufferAttribute, Color, InterleavedBufferAttribute, Vector2, Vector3, Vector4} from 'three';\nimport {JsConnectionPointComponentsCountMap, JsConnectionPointType} from '../utils/io/connections/Js';\nimport {logBlue as _logBlue} from '../../../core/logger/Console';\nimport {EntityBuilderEvaluator} from '../js/code/assemblers/entityBuilder/EntityBuilderEvaluator';\nimport {primitivesCountFromObject} from '../../../core/geometry/entities/primitive/CorePrimitiveUtils';\nimport {CoreObjectType, ObjectContent} from '../../../core/geometry/ObjectContent';\nimport {\n\tcorePointClassFactory,\n\tcorePrimitiveClassFactory,\n\tcoreVertexClassFactory,\n} from '../../../core/geometry/CoreObjectFactory';\nimport {filterObjectsFromCoreGroup} from '../../../core/geometry/Mask';\nimport {AttribClass} from '../../../core/geometry/Constant';\nimport {pointsCountFromObject} from '../../../core/geometry/entities/point/CorePointUtils';\nimport {verticesCountFromObject} from '../../../core/geometry/entities/vertex/CoreVertexUtils';\nimport {BaseVertexAttribute} from '../../../core/geometry/entities/vertex/VertexAttribute';\nimport {BasePrimitiveAttribute} from '../../../core/geometry/entities/primitive/PrimitiveAttribute';\nimport {CorePoint} from '../../../core/geometry/entities/point/CorePoint';\nimport {CorePrimitive} from '../../../core/geometry/entities/primitive/CorePrimitive';\nimport {CoreVertex} from '../../../core/geometry/entities/vertex/CoreVertex';\n\ntype EntityFunction = Function; //(object:Object3D)=>Object3D\ntype AttributeItem = boolean | number | string | Color | Vector2 | Vector3 | Vector4;\ntype AttributesDict = Map<string, AttributeItem>;\n\ntype AvailableEntity = AttribClass.POINT | AttribClass.VERTEX | AttribClass.PRIMITIVE;\nexport const AVAILABLE_ENTITIES: AvailableEntity[] = [AttribClass.POINT, AttribClass.VERTEX, AttribClass.PRIMITIVE];\ntype EntityAttribute = BufferAttribute | InterleavedBufferAttribute | BaseVertexAttribute | BasePrimitiveAttribute;\n\nexport class BaseEntityBuilderSopParamsConfig extends NodeParamsConfig {\n\t/** @param group to assign the material to */\n\tgroup = ParamConfig.STRING('', {\n\t\tobjectMask: true,\n\t});\n\tentity = ParamConfig.INTEGER(AVAILABLE_ENTITIES.indexOf(AttribClass.POINT), {\n\t\tmenu: {\n\t\t\tentries: AVAILABLE_ENTITIES.map((entity, i) => {\n\t\t\t\treturn {name: entity, value: i};\n\t\t\t}),\n\t\t},\n\t});\n}\n\nexport abstract class BaseEntityBuilderSopNode<P extends BaseEntityBuilderSopParamsConfig> extends TypedSopNode<P> {\n\tassemblerController() {\n\t\treturn this._assemblerController;\n\t}\n\tpublic override usedAssembler(): Readonly<AssemblerName.JS_ENTITY_BUILDER> {\n\t\treturn AssemblerName.JS_ENTITY_BUILDER;\n\t}\n\tprotected _assemblerController = this._createAssemblerController();\n\tprivate _createAssemblerController(): JsAssemblerController<JsAssemblerEntityBuilder> | undefined {\n\t\treturn Poly.assemblersRegister.assembler(this, this.usedAssembler());\n\t}\n\n\tprotected override _childrenControllerContext = NodeContext.JS;\n\n\toverride createNode<S extends keyof JsNodeChildrenMap>(\n\t\tnode_class: S,\n\t\toptions?: NodeCreateOptions\n\t): JsNodeChildrenMap[S];\n\toverride createNode<K extends valueof<JsNodeChildrenMap>>(\n\t\tnode_class: Constructor<K>,\n\t\toptions?: NodeCreateOptions\n\t): K;\n\toverride createNode<K extends valueof<JsNodeChildrenMap>>(\n\t\tnode_class: Constructor<K>,\n\t\toptions?: NodeCreateOptions\n\t): K {\n\t\treturn super.createNode(node_class, options) as K;\n\t}\n\toverride children() {\n\t\treturn super.children() as BaseJsNodeType[];\n\t}\n\toverride nodesByType<K extends keyof JsNodeChildrenMap>(type: K): JsNodeChildrenMap[K][] {\n\t\treturn super.nodesByType(type) as JsNodeChildrenMap[K][];\n\t}\n\toverride childrenAllowed() {\n\t\tif (this.assemblerController()) {\n\t\t\treturn super.childrenAllowed();\n\t\t}\n\t\treturn false;\n\t}\n\toverride sceneReadonly() {\n\t\treturn this.assemblerController() == null;\n\t}\n\n\toverride initializeNode() {\n\t\tthis.io.inputs.setCount(1);\n\t\tthis.io.inputs.initInputsClonedState(InputCloneMode.FROM_NODE);\n\t}\n\n\toverride async cook(inputCoreGroups: CoreGroup[]) {\n\t\tconst coreGroup = inputCoreGroups[0];\n\n\t\t// compile\n\t\tthis.compileIfRequired();\n\n\t\t// eval\n\t\tconst _func = this._function;\n\t\tif (_func) {\n\t\t\tconst args = this.functionEvalArgsWithParamConfigs();\n\n\t\t\tconst evaluator = _func(...args) as EntityBuilderEvaluator;\n\n\t\t\tconst objects = filterObjectsFromCoreGroup(coreGroup, this.pv);\n\n\t\t\tlet objnum = 0;\n\t\t\tfor (const object of objects) {\n\t\t\t\tthis._processObject(object, objnum, evaluator);\n\n\t\t\t\tobjnum++;\n\t\t\t}\n\n\t\t\tthis.setObjects(objects);\n\t\t} else {\n\t\t\tthis.setObjects([]);\n\t\t}\n\t}\n\n\tprotected abstract _processObject<T extends CoreObjectType>(\n\t\tobject: ObjectContent<T>,\n\t\tobjnum: number,\n\t\tevaluator: EntityBuilderEvaluator\n\t): void;\n\n\tprotected _resetRequiredAttributes() {\n\t\tthis._attributesDict.clear();\n\t}\n\tprotected _checkRequiredReadAttributes<T extends CoreObjectType>(object: ObjectContent<T>) {\n\t\t// no need to check if there are no points in the geometry\n\t\tconst entitiesCount = this.entitiesCount(object);\n\t\tif (entitiesCount == 0) {\n\t\t\treturn;\n\t\t}\n\t\tconst entityClass = this.entityClass(object);\n\n\t\tconst readAttributesData = this._functionData?.attributesData.read;\n\t\tif (!readAttributesData) {\n\t\t\treturn;\n\t\t}\n\t\tfor (const attribData of readAttributesData) {\n\t\t\tconst attribute = entityClass.attribute(object, attribData.attribName);\n\t\t\tif (!attribute) {\n\t\t\t\tconst message = `attribute ${attribData.attribName} is missing`;\n\t\t\t\tthis.states.error.set(message);\n\t\t\t\tthrow message;\n\t\t\t\treturn;\n\t\t\t} else {\n\t\t\t\tconst expectedAttribSize = JsConnectionPointComponentsCountMap[attribData.attribType];\n\t\t\t\tif (attribute.itemSize != expectedAttribSize) {\n\t\t\t\t\tthis.states.error.set('attribute size mismatch');\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tconst attribNames: string[] = [];\n\t\tconst attributeByName = new Map<string, BufferAttribute>();\n\t\tconst attribTypeByName = new Map<string, JsConnectionPointType>();\n\t\tfor (const attribData of readAttributesData) {\n\t\t\tconst attribName = attribData.attribName;\n\t\t\tconst attribute = entityClass.attribute(object, attribName) as BufferAttribute;\n\t\t\tif (attribute) {\n\t\t\t\tattribNames.push(attribName);\n\t\t\t\tattributeByName.set(attribName, attribute);\n\t\t\t\tattribTypeByName.set(attribName, attribData.attribType);\n\t\t\t}\n\t\t}\n\t\treturn {attribNames, attributeByName, attribTypeByName};\n\t}\n\tprotected _checkRequiredWriteAttributes<T extends CoreObjectType>(object: ObjectContent<T>) {\n\t\tconst writeAttributesData = this._functionData?.attributesData.write;\n\t\tif (!writeAttributesData) {\n\t\t\treturn;\n\t\t}\n\t\tconst entityClass = this.entityClass(object);\n\t\tfor (const attribData of writeAttributesData) {\n\t\t\tlet attribute = entityClass.attribute(object, attribData.attribName);\n\t\t\tconst expectedAttribSize = JsConnectionPointComponentsCountMap[attribData.attribType];\n\t\t\tif (!attribute) {\n\t\t\t\tconst pointsCount = entityClass.entitiesCount(object);\n\t\t\t\tconst newArray: number[] = new Array(pointsCount * expectedAttribSize).fill(0);\n\t\t\t\tattribute = this._createAttribute(object, attribData.attribName, newArray, expectedAttribSize);\n\t\t\t}\n\t\t\tif (attribute.itemSize != expectedAttribSize) {\n\t\t\t\tthis.states.error.set('attribute size mismatch');\n\t\t\t}\n\t\t}\n\n\t\tconst attribNames: string[] = [];\n\t\tconst attributeByName = new Map<string, EntityAttribute>();\n\t\tconst attribTypeByName = new Map<string, JsConnectionPointType>();\n\t\tfor (const attribData of writeAttributesData) {\n\t\t\tconst attribName = attribData.attribName;\n\t\t\tconst attribute: EntityAttribute | undefined = entityClass.attribute(object, attribName);\n\t\t\tif (attribute) {\n\t\t\t\tattribNames.push(attribName);\n\t\t\t\tattributeByName.set(attribName, attribute);\n\t\t\t\tattribTypeByName.set(attribName, attribData.attribType);\n\t\t\t}\n\t\t}\n\t\treturn {attribNames, attributeByName, attribTypeByName};\n\t}\n\tprotected _readRequiredAttributes(\n\t\tindex: number,\n\t\tattribNames: string[],\n\t\tattributeByName: Map<string, BufferAttribute>,\n\t\tattribTypeByName: Map<string, JsConnectionPointType>\n\t) {\n\t\tfor (const attribName of attribNames) {\n\t\t\tconst attribute = attributeByName.get(attribName)!;\n\t\t\tconst attribType = attribTypeByName.get(attribName)!;\n\t\t\tconst variable = createVariable(attribType);\n\t\t\tif (!variable) {\n\t\t\t\tconst attribValue = attribute.array[index * attribute.itemSize];\n\t\t\t\tthis._attributesDict.set(attribName, attribValue);\n\t\t\t} else if (isVector(variable) || isColor(variable)) {\n\t\t\t\tvariable.fromBufferAttribute(attribute, index);\n\t\t\t\tthis._attributesDict.set(attribName, variable);\n\t\t\t}\n\t\t}\n\t}\n\tprotected _writeRequiredAttributes(\n\t\tindex: number,\n\t\tattribNames: string[],\n\t\tattributeByName: Map<string, BufferAttribute>\n\t) {\n\t\tfor (const attribName of attribNames) {\n\t\t\tconst attribute = attributeByName.get(attribName)!;\n\t\t\tconst variable = this._attributesDict.get(attribName);\n\t\t\tif (isVector(variable) || isColor(variable)) {\n\t\t\t\tvariable.toArray(attribute.array, index * attribute.itemSize);\n\t\t\t} else {\n\t\t\t\tif (isNumber(variable)) {\n\t\t\t\t\t(attribute.array)[index] = variable;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tcompileIfRequired() {\n\t\tif (this.assemblerController()?.compileRequired()) {\n\t\t\tthis.compile();\n\t\t}\n\t}\n\n\tprotected abstract _entityContainer: EntityContainer;\n\tprivate _paramConfigs: JsParamConfig<ParamType>[] = [];\n\tprivate _functionData: EntityBuilderFunctionData | undefined;\n\tprivate _functionCreationArgs: string[] = [];\n\tprivate _functionEvalArgs: (EntityContainer | Function | RegisterableVariable | AttributesDict)[] = [];\n\tprivate _function: EntityFunction | undefined;\n\tprivate _attributesDict: AttributesDict = new Map();\n\tfunctionData() {\n\t\treturn this._functionData;\n\t}\n\tcompile() {\n\t\tconst assemblerController = this.assemblerController();\n\t\tif (!assemblerController) {\n\t\t\treturn;\n\t\t}\n\t\tconst outputNodes: BaseJsNodeType[] = JsNodeFinder.findOutputNodes(this);\n\t\t// if (outputNodes.length == 0) {\n\t\t// \tthis.states.error.set('one output node is required');\n\t\t// \treturn;\n\t\t// }\n\t\tif (outputNodes.length > 1) {\n\t\t\tthis.states.error.set('only one output node allowed');\n\t\t\treturn;\n\t\t}\n\t\t// const outputNode = outputNodes[0];\n\t\t// if (outputNode) {\n\t\tconst paramNodes = JsNodeFinder.findParamGeneratingNodes(this);\n\t\tconst attributeExportNodes = JsNodeFinder.findAttributeExportNodes(this);\n\t\tconst rootNodes = outputNodes.concat(paramNodes).concat(attributeExportNodes);\n\t\tif (rootNodes.length == 0) {\n\t\t\tthis.states.error.set('at least one output, param or attribute node is required');\n\t\t\treturn;\n\t\t}\n\t\tassemblerController.assembler.set_root_nodes(rootNodes);\n\n\t\t// main compilation\n\t\tassemblerController.assembler.updateFunction();\n\n\t\t// get functionData\n\t\tconst functionData = assemblerController.assembler.functionData();\n\t\tif (!functionData) {\n\t\t\tthis.states.error.set('failed to compile ');\n\t\t\treturn;\n\t\t}\n\t\tthis.updateFromFunctionData(functionData);\n\t\t// }\n\n\t\tassemblerController.post_compile();\n\t}\n\tupdateFromFunctionData(functionData: EntityBuilderFunctionData) {\n\t\tthis._functionData = functionData;\n\n\t\tconst {functionBody, variableNames, variablesByName, functionNames, functionsByName, paramConfigs} =\n\t\t\tthis._functionData;\n\n\t\tconst wrappedBody = `\n\t\ttry {\n\t\t\t${functionBody}\n\t\t} catch(e) {\n\t\t\t_setErrorFromError(e)\n\t\t\treturn 0;\n\t\t}`;\n\t\tconst _setErrorFromError = (e: Error) => {\n\t\t\tthis.states.error.set(e.message);\n\t\t};\n\t\tconst variables: RegisterableVariable[] = [];\n\t\tconst functions: Function[] = [];\n\t\tfor (const variableName of variableNames) {\n\t\t\tconst variable = variablesByName[variableName];\n\t\t\tvariables.push(variable);\n\t\t}\n\t\tfor (const functionName of functionNames) {\n\t\t\tconst _func = functionsByName[functionName];\n\t\t\tfunctions.push(_func);\n\t\t}\n\t\tthis._paramConfigs = [...paramConfigs]; //[...paramConfigs];\n\t\tconst paramConfigNames: string[] = paramConfigs.map((pc) => pc.uniformName());\n\n\t\tparamConfigs.forEach((p) => p.applyToNode(this));\n\n\t\tthis._functionCreationArgs = [\n\t\t\tEntityBuilderAssemblerConstant.ENTITY_CONTAINER,\n\t\t\t'_setErrorFromError',\n\t\t\t...variableNames,\n\t\t\t...functionNames,\n\t\t\tEntityBuilderAssemblerConstant.ATTRIBUTES_DICT,\n\t\t\t...paramConfigNames,\n\t\t\twrappedBody,\n\t\t];\n\t\tthis._functionEvalArgs = [\n\t\t\tthis._entityContainer,\n\t\t\t_setErrorFromError,\n\t\t\t...variables,\n\t\t\t...functions,\n\t\t\tthis._attributesDict,\n\t\t\t// paramConfigs are added dynamically during cook\n\t\t];\n\t\ttry {\n\t\t\tthis._function = new Function(...this._functionCreationArgs) as EntityFunction;\n\t\t} catch (e) {\n\t\t\tconsole.warn(e);\n\t\t\tthis.states.error.set('failed to compile');\n\t\t}\n\t}\n\n\tfunctionEvalArgsWithParamConfigs() {\n\t\tconst list: Array<EntityContainer | Function | RegisterableVariable | number | boolean | AttributesDict> = [\n\t\t\t...this._functionEvalArgs,\n\t\t];\n\t\tfor (const paramConfig of this._paramConfigs) {\n\t\t\tconst paramName = paramConfig.name();\n\t\t\tconst spareParam = this.params.get(paramName);\n\t\t\tif (spareParam && spareParam.value != null) {\n\t\t\t\tif (\n\t\t\t\t\tCoreType.isBoolean(spareParam.value) ||\n\t\t\t\t\tCoreType.isNumberValid(spareParam.value) ||\n\t\t\t\t\tCoreType.isColor(spareParam.value) ||\n\t\t\t\t\tCoreType.isVector(spareParam.value)\n\t\t\t\t) {\n\t\t\t\t\tlist.push(spareParam.value);\n\t\t\t\t} else {\n\t\t\t\t\tconsole.warn(`spareParam not found but type not yet copied to function args:'${paramName}'`);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tconsole.warn(`spareParam not found:'${paramName}'`);\n\t\t\t}\n\t\t}\n\t\treturn list;\n\t}\n\n\tsetEntity(attribClass: AvailableEntity) {\n\t\tthis.p.entity.set(AVAILABLE_ENTITIES.indexOf(attribClass));\n\t}\n\tentity(): AvailableEntity {\n\t\treturn AVAILABLE_ENTITIES[this.pv.entity];\n\t}\n\tentitiesCount(object: ObjectContent<CoreObjectType>): number {\n\t\tconst entity = this.entity();\n\t\tswitch (entity) {\n\t\t\tcase AttribClass.POINT: {\n\t\t\t\treturn pointsCountFromObject(object);\n\t\t\t}\n\t\t\tcase AttribClass.VERTEX: {\n\t\t\t\treturn verticesCountFromObject(object);\n\t\t\t}\n\t\t\tcase AttribClass.PRIMITIVE: {\n\t\t\t\treturn primitivesCountFromObject(object);\n\t\t\t}\n\t\t}\n\t}\n\tentityClass(\n\t\tobject: ObjectContent<CoreObjectType>\n\t): typeof CorePoint<CoreObjectType> | typeof CoreVertex<CoreObjectType> | typeof CorePrimitive<CoreObjectType> {\n\t\tconst entity = this.entity();\n\t\tswitch (entity) {\n\t\t\tcase AttribClass.POINT: {\n\t\t\t\treturn corePointClassFactory(object);\n\t\t\t}\n\t\t\tcase AttribClass.VERTEX: {\n\t\t\t\treturn coreVertexClassFactory(object);\n\t\t\t}\n\t\t\tcase AttribClass.PRIMITIVE: {\n\t\t\t\treturn corePrimitiveClassFactory(object);\n\t\t\t}\n\t\t}\n\t}\n\tprivate _createAttribute(\n\t\tobject: ObjectContent<CoreObjectType>,\n\t\tattribName: string,\n\t\tvalues: number[],\n\t\tattribSize: number\n\t) {\n\t\tconst entity = this.entity();\n\t\tswitch (entity) {\n\t\t\tcase AttribClass.POINT: {\n\t\t\t\tconst attribute = new BufferAttribute(new Float32Array(values), attribSize);\n\t\t\t\tcorePointClassFactory(object).addAttribute(object, attribName, attribute);\n\t\t\t\treturn attribute;\n\t\t\t}\n\t\t\tcase AttribClass.VERTEX: {\n\t\t\t\tconst attribute: BaseVertexAttribute = {\n\t\t\t\t\tisString: false,\n\t\t\t\t\titemSize: attribSize,\n\t\t\t\t\tarray: values,\n\t\t\t\t};\n\t\t\t\tcoreVertexClassFactory(object).addAttribute(object, attribName, attribute);\n\t\t\t\treturn attribute;\n\t\t\t}\n\t\t\tcase AttribClass.PRIMITIVE: {\n\t\t\t\tconst attribute: BasePrimitiveAttribute = {\n\t\t\t\t\tisString: false,\n\t\t\t\t\titemSize: attribSize,\n\t\t\t\t\tarray: values,\n\t\t\t\t};\n\t\t\t\tcorePrimitiveClassFactory(object).addAttribute(object, attribName, attribute);\n\t\t\t\treturn attribute;\n\t\t\t}\n\t\t}\n\t}\n}\n","/**\n * Updates points/primitives with JS nodes\n *\n *\n */\n\nimport {Object3D, Vector3} from 'three';\nimport {SopType} from '../../poly/registers/nodes/types/Sop';\nimport {EntityBuilderPersistedConfig} from '../js/code/assemblers/entityBuilder/EntityBuilderPersistedConfig';\nimport {AssemblerName} from '../../poly/registers/assemblers/_BaseRegister';\nimport {BaseEntityBuilderSopNode, BaseEntityBuilderSopParamsConfig, AVAILABLE_ENTITIES} from './_BaseEntityBuilder';\nimport {EntityBuilderEvaluator} from '../js/code/assemblers/entityBuilder/EntityBuilderEvaluator';\nimport {EntityContainer} from '../js/code/assemblers/entityBuilder/EntityBuilderAssemblerCommon';\nimport {Attribute} from '../../../core/geometry/Attribute';\nimport {ParamConfig} from '../utils/params/ParamsConfig';\nimport {isBooleanTrue} from '../../../core/Type';\nimport {CoreObjectType, ObjectContent} from '../../../core/geometry/ObjectContent';\nimport {corePointClassFactory, corePrimitiveClassFactory} from '../../../core/geometry/CoreObjectFactory';\nimport {AttribClass} from '../../../core/geometry/Constant';\n\nconst _tmpObject = new Object3D();\n\nclass EntityBuilderSopParamsConfig extends BaseEntityBuilderSopParamsConfig {\n\t/** @param updateNormals */\n\tupdateNormals = ParamConfig.BOOLEAN(1, {\n\t\tvisibleIf: {\n\t\t\tentity: AVAILABLE_ENTITIES.indexOf(AttribClass.POINT),\n\t\t},\n\t});\n}\nconst ParamsConfig = new EntityBuilderSopParamsConfig();\nexport class EntityBuilderSopNode extends BaseEntityBuilderSopNode<EntityBuilderSopParamsConfig> {\n\toverride paramsConfig = ParamsConfig;\n\tstatic override type() {\n\t\treturn SopType.ENTITY_BUILDER;\n\t}\n\n\toverride readonly persisted_config: EntityBuilderPersistedConfig = new EntityBuilderPersistedConfig(this);\n\tpublic override usedAssembler(): Readonly<AssemblerName.JS_ENTITY_BUILDER> {\n\t\treturn AssemblerName.JS_ENTITY_BUILDER;\n\t}\n\n\tprotected _entityContainer: EntityContainer = {\n\t\tobject: _tmpObject,\n\t\tposition: new Vector3(),\n\t\tnormal: new Vector3(),\n\t\tindex: -1,\n\t\tobjnum: -1,\n\t\tnormalsUpdated: false,\n\t};\n\n\tprotected _processObject<T extends CoreObjectType>(\n\t\tobject: ObjectContent<T>,\n\t\tobjnum: number,\n\t\tevaluator: EntityBuilderEvaluator\n\t) {\n\t\tthis._entityContainer.object = object;\n\t\tthis._entityContainer.objnum = objnum;\n\t\tthis._entityContainer.normalsUpdated = false;\n\t\tif (this.entity() == AttribClass.PRIMITIVE) {\n\t\t\t// TODO: the graph should only be created if the js nodes require it\n\t\t\tthis._entityContainer.primitiveGraph = corePrimitiveClassFactory(object).graph(object);\n\t\t\t//\n\t\t} else {\n\t\t\tthis._entityContainer.primitiveGraph = undefined;\n\t\t}\n\t\tconst readAttributeOptions = this._checkRequiredReadAttributes(object);\n\t\tconst writeAttributeOptions = this._checkRequiredWriteAttributes(object);\n\t\tconst readAttribNames = readAttributeOptions ? readAttributeOptions.attribNames : [];\n\t\tconst readAttributeByName = readAttributeOptions ? readAttributeOptions.attributeByName : new Map();\n\t\tconst attribTypeByName = readAttributeOptions ? readAttributeOptions.attribTypeByName : new Map();\n\t\tconst writeAttribNames = writeAttributeOptions ? writeAttributeOptions.attribNames : [];\n\t\tconst writeAttributeByName = writeAttributeOptions ? writeAttributeOptions.attributeByName : new Map();\n\t\tthis._resetRequiredAttributes();\n\t\tconst entitiesCount = this.entitiesCount(object);\n\t\tconst entityClass = this.entityClass(object);\n\t\tconst positionAttrib = entityClass.attribute(object, Attribute.POSITION);\n\t\tconst normalAttrib = entityClass.attribute(object, Attribute.NORMAL);\n\t\tconst hasPosition = positionAttrib != null;\n\t\tconst hasNormal = normalAttrib != null;\n\t\tif (!hasPosition) {\n\t\t\tthis._entityContainer.position.set(0, 0, 0);\n\t\t}\n\t\tif (!hasNormal) {\n\t\t\tthis._entityContainer.normal.set(0, 1, 0);\n\t\t}\n\t\tfor (let index = 0; index < entitiesCount; index++) {\n\t\t\tthis._entityContainer.index = index;\n\t\t\t// read attributes\n\t\t\tif (hasPosition) {\n\t\t\t\tentityClass.attribValue(object, index, Attribute.POSITION, this._entityContainer.position);\n\t\t\t\t// this._entityContainer.position.fromBufferAttribute(positionAttrib, index);\n\t\t\t}\n\t\t\tif (hasNormal) {\n\t\t\t\tentityClass.attribValue(object, index, Attribute.NORMAL, this._entityContainer.normal);\n\t\t\t\t// this._entityContainer.normal.fromBufferAttribute(normalAttrib, index);\n\t\t\t}\n\t\t\tthis._readRequiredAttributes(index, readAttribNames, readAttributeByName, attribTypeByName);\n\t\t\t// eval function\n\t\t\tevaluator();\n\t\t\t// write back\n\t\t\t// if (hasPosition) {\n\t\t\t// \tpositionAttrib.setXYZ(\n\t\t\t// \t\tindex,\n\t\t\t// \t\tthis._entityContainer.position.x,\n\t\t\t// \t\tthis._entityContainer.position.y,\n\t\t\t// \t\tthis._entityContainer.position.z\n\t\t\t// \t);\n\t\t\t// }\n\t\t\t// if (hasNormal) {\n\t\t\t// \tnormalAttrib.setXYZ(\n\t\t\t// \t\tindex,\n\t\t\t// \t\tthis._entityContainer.normal.x,\n\t\t\t// \t\tthis._entityContainer.normal.y,\n\t\t\t// \t\tthis._entityContainer.normal.z\n\t\t\t// \t);\n\t\t\t// }\n\t\t\tthis._writeRequiredAttributes(index, writeAttribNames, writeAttributeByName);\n\t\t}\n\t\tif (isBooleanTrue(this.pv.updateNormals) && !this._entityContainer.normalsUpdated) {\n\t\t\tcorePointClassFactory(object).computeNormals(object);\n\t\t}\n\t}\n}\n","/**\n * Split the faces when the angle between their respective normals goes above a threshold\n *\n *\n */\nimport {TypedSopNode} from './_Base';\nimport {CoreGroup} from '../../../core/geometry/Group';\nimport {InputCloneMode} from '../../poly/InputCloneMode';\nimport {NodeParamsConfig, ParamConfig} from '../utils/params/ParamsConfig';\nimport {toCreasedNormals} from 'three/examples/jsm/utils/BufferGeometryUtils';\nimport {MathUtils} from 'three';\nimport {CoreMask} from '../../../core/geometry/Mask';\nimport {object3DHasGeometry} from '../../../core/geometry/GeometryUtils';\nimport {SopType} from '../../poly/registers/nodes/types/Sop';\nimport {CoreGeometryIndexBuilder} from '../../../core/geometry/util/IndexBuilder';\nimport {corePrimitiveClassFactory} from '../../../core/geometry/CoreObjectFactory';\nconst {degToRad} = MathUtils;\n\nclass FacetSopParamsConfig extends NodeParamsConfig {\n\t/** @param group to assign the material to */\n\tgroup = ParamConfig.STRING('', {\n\t\tobjectMask: true,\n\t});\n\t/** @param angle threshold to separate vertices */\n\tangle = ParamConfig.FLOAT(20, {\n\t\trange: [0, 90],\n\t\trangeLocked: [true, false],\n\t});\n}\nconst ParamsConfig = new FacetSopParamsConfig();\n\nexport class FacetSopNode extends TypedSopNode<FacetSopParamsConfig> {\n\toverride paramsConfig = ParamsConfig;\n\tstatic override type() {\n\t\treturn SopType.FACET;\n\t}\n\n\toverride initializeNode() {\n\t\tthis.io.inputs.setCount(1);\n\t\tthis.io.inputs.initInputsClonedState(InputCloneMode.FROM_NODE);\n\t}\n\n\toverride cook(inputCoreGroups: CoreGroup[]) {\n\t\tconst inputCoreGroup = inputCoreGroups[0];\n\n\t\tconst selectedObjects = CoreMask.filterThreejsObjects(inputCoreGroup, this.pv).filter(object3DHasGeometry);\n\t\tconst rad = degToRad(this.pv.angle);\n\t\tfor (const object of selectedObjects) {\n\t\t\t// we fetch the primitive attributes before the geometry is modified\n\t\t\tconst primitiveAttributes = corePrimitiveClassFactory(object).attributes(object);\n\t\t\tobject.geometry = toCreasedNormals(object.geometry, rad);\n\n\t\t\tCoreGeometryIndexBuilder.createIndexIfNone(object.geometry);\n\n\t\t\t// ensure primitive attributes are kept\n\t\t\tif (primitiveAttributes) {\n\t\t\t\tconst primitiveAttributeNames = Object.keys(primitiveAttributes);\n\t\t\t\tfor (const attribName of primitiveAttributeNames) {\n\t\t\t\t\tconst attrib = primitiveAttributes[attribName];\n\t\t\t\t\tcorePrimitiveClassFactory(object).addAttribute(object, attribName, attrib);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tthis.setCoreGroup(inputCoreGroup);\n\t}\n}\n","/**\n * Loads multiple geometries from a url, using attributes from the input points. This can be more convenient than the File SOP if you want to load many geometries.\n *\n * @remarks\n * Note that this node will automatically use a specific loader depending on the extension of the url.\n *\n */\nimport {BaseNodeType} from '../_Base';\nimport {Object3D} from 'three';\nimport {BaseFileMultiSopNode} from './utils/file/_BaseSopFileMulti';\nimport {SopTypeFileMulti} from '../../poly/registers/nodes/types/Sop';\nimport {OBJLoaderHandler} from '../../../core/loader/geometry/OBJ';\nimport {NodeParamsConfig, ParamConfig} from '../utils/params/ParamsConfig';\nimport {ASSETS_ROOT} from '../../../core/loader/AssetsUtils';\nimport {EXTENSIONS_BY_NODE_TYPE_BY_CONTEXT} from '../../../core/loader/FileExtensionRegister';\nimport {NodeContext} from '../../poly/NodeContext';\n// export class FileMultiOBJSopNode extends fileMultiSopNodeFactory<Object3D>({\n// \ttype: SopTypeFileMulti.FILE_OBJ,\n// \textensions: [GeometryExtension.OBJ],\n// \tdefaultUrlExpression: `${ASSETS_ROOT}/models/\\`@name\\`.obj`,\n// \tcreateLoader: (url: string, node: BaseNodeType) => new OBJLoaderHandler(url, node),\n// }) {}\nclass FileMultiOBJParamsConfig extends NodeParamsConfig {\n\t/** @param url to load the geometry from */\n\turl = ParamConfig.STRING(`${ASSETS_ROOT}/models/\\`@name\\`.obj`, {\n\t\tfileBrowse: {extensions: EXTENSIONS_BY_NODE_TYPE_BY_CONTEXT[NodeContext.SOP][SopTypeFileMulti.FILE_OBJ]},\n\t\texpression: {forEntities: true},\n\t});\n\t/** @param sets the matrixAutoUpdate attribute for the objects loaded */\n\tmatrixAutoUpdate = ParamConfig.BOOLEAN(false);\n\t/** @param reload the geometry */\n\treload = ParamConfig.BUTTON(null, {\n\t\tcallback: (node: BaseNodeType) => {\n\t\t\tBaseFileMultiSopNode.PARAM_CALLBACK_reload(node as FileMultiOBJSopNode);\n\t\t},\n\t});\n}\n\nconst ParamsConfig = new FileMultiOBJParamsConfig();\nexport class FileMultiOBJSopNode extends BaseFileMultiSopNode<Object3D, FileMultiOBJParamsConfig> {\n\toverride paramsConfig = ParamsConfig;\n\tstatic override type() {\n\t\treturn SopTypeFileMulti.FILE_OBJ;\n\t}\n\tprotected _createLoader(url: string) {\n\t\treturn new OBJLoaderHandler(url, this);\n\t}\n}\n\n// class FileMultiSopParamsConfig extends NodeParamsConfig {\n// \t/** @param url to load the geometry from */\n// \turl = ParamConfig.STRING(`${ASSETS_ROOT}/models/\\`@name\\`.obj`, {\n// \t\tfileBrowse: {extensions: [FileType.GEOMETRY]},\n// \t\texpression: {forEntities: true},\n// \t});\n// \t/** @param format */\n// \tformat = ParamConfig.STRING(GeometryFormat.AUTO, {\n// \t\tmenuString: {\n// \t\t\tentries: GEOMETRY_FORMATS.map((name) => {\n// \t\t\t\treturn {name, value: name};\n// \t\t\t}),\n// \t\t},\n// \t});\n// \t/** @param reload the geometry */\n// \treload = ParamConfig.BUTTON(null, {\n// \t\tcallback: (node: BaseNodeType) => {\n// \t\t\tFileMultiSopNode.PARAM_CALLBACK_reload(node as FileMultiSopNode);\n// \t\t},\n// \t});\n// }\n// const ParamsConfig = new FileMultiSopParamsConfig();\n\n// export class FileMultiSopNode extends TypedSopNode<FileMultiSopParamsConfig> {\n// \toverride paramsConfig = ParamsConfig;\n// \tstatic override type() {\n// \t\treturn 'fileMultiOBJ';\n// \t}\n\n// \toverride initializeNode() {\n// \t\tthis.io.inputs.setCount(1);\n// \t\tthis.io.inputs.initInputsClonedState(InputCloneMode.NEVER);\n// \t}\n\n// \tprivate _instancer = new CoreInstancer();\n// \tprivate _instanceMatrix = new Matrix4();\n// \toverride async cook(inputCoreGroups: CoreGroup[]) {\n// \t\tconst inputCoreGroup = inputCoreGroups[0];\n\n// \t\tconst points = inputCoreGroup.points();\n// \t\t// const urls: string[] = new Array(points.length);\n// \t\tconst urls: string[] = [];\n// \t\tconst urlByIndex: Map<number, string> = new Map();\n// \t\tconst loadedResultByUrl: Map<string, Object3D> = new Map();\n// \t\tconst urlUsageCount: Map<string, number> = new Map();\n// \t\tconst param = this.p.url;\n// \t\t// gather all unique urls\n// \t\tif (param.hasExpression() && param.expressionController) {\n// \t\t\tconst uniqueUrls: Set<string> = new Set();\n// \t\t\tawait param.expressionController.computeExpressionForPoints(points, (point, url) => {\n// \t\t\t\t// check that this index was not already set\n// \t\t\t\tconst index = point.index();\n// \t\t\t\tif (urlByIndex.has(index)) {\n// \t\t\t\t\tthis.states.error.set(`input points have duplicate indices. Make sure to merge inputs together.`);\n// \t\t\t\t} else {\n// \t\t\t\t\turlByIndex.set(index, url);\n// \t\t\t\t\tuniqueUrls.add(url);\n// \t\t\t\t\tFileMultiSopNode._incrementUrlUsageCount(url, urlUsageCount);\n// \t\t\t\t}\n// \t\t\t});\n// \t\t\tuniqueUrls.forEach((url) => {\n// \t\t\t\turls.push(url);\n// \t\t\t});\n// \t\t} else {\n// \t\t\tconst url = this.pv.url;\n// \t\t\turls.push(url);\n// \t\t\tFileMultiSopNode._incrementUrlUsageCount(url, urlUsageCount);\n// \t\t}\n// \t\t// load each url and place the result under a parent\n\n// \t\tconst loadedObjects: Object3D[] = [];\n// \t\tconst promises = urls.map((url) => this._loadFromUrlPromises(url, loadedResultByUrl));\n// \t\tawait Promise.all(promises);\n// \t\t// move each loaded result and transform it according to its template point\n// \t\tthis._instancer.setCoreGroup(inputCoreGroup);\n// \t\tfor (let point of points) {\n// \t\t\tconst index = point.index();\n// \t\t\tconst url = urlByIndex.get(index) || this.pv.url;\n\n// \t\t\tthis._instancer.matrixFromPoint(point, this._instanceMatrix);\n// \t\t\tconst usageCount = urlUsageCount.get(url) || 1;\n// \t\t\tlet parent = loadedResultByUrl.get(url);\n// \t\t\tif (parent) {\n// \t\t\t\t// if this url is used more than 1x, we clone the loaded result\n// \t\t\t\tif (usageCount > 1) {\n// \t\t\t\t\tparent = parent.clone();\n// \t\t\t\t}\n// \t\t\t\tparent.applyMatrix4(this._instanceMatrix);\n// \t\t\t\tloadedObjects.push(parent);\n// \t\t\t}\n// \t\t}\n\n// \t\tthis.setObjects(loadedObjects);\n// \t}\n// \tprivate static _incrementUrlUsageCount(url: string, map: Map<string, number>) {\n// \t\tconst currentUsage = map.get(url);\n// \t\tif (currentUsage != null) {\n// \t\t\tmap.set(url, currentUsage + 1);\n// \t\t} else {\n// \t\t\tmap.set(url, 1);\n// \t\t}\n// \t}\n\n// \tprivate async _loadFromUrlPromises(url: string, loadedResultByUrl: Map<string, Object3D>) {\n// \t\tconst objects = await this._loadObject(url);\n// \t\tconst parent = new Group();\n// \t\tparent.matrixAutoUpdate = false;\n// \t\tparent.name = url;\n// \t\tfor (let object of objects) {\n// \t\t\tparent.add(object);\n// \t\t}\n// \t\tloadedResultByUrl.set(url, parent);\n// \t}\n\n// \tprivate _loadObject(url: string): Promise<Object3D[]> {\n// \t\tconst loader = new CoreLoaderGeometry({url: url, format: this.pv.format as GeometryFormat}, this.scene(), this);\n\n// \t\treturn new Promise((resolve) => {\n// \t\t\tloader.load(\n// \t\t\t\t(objects: Object3D[]) => {\n// \t\t\t\t\tconst new_objects = this._onLoad(objects);\n// \t\t\t\t\tresolve(new_objects);\n// \t\t\t\t},\n// \t\t\t\t(message: string) => {\n// \t\t\t\t\tthis._onError(message, url);\n// \t\t\t\t}\n// \t\t\t);\n// \t\t});\n// \t}\n\n// \tprivate _onLoad(objects: Object3D[]) {\n// \t\tobjects = objects.flat();\n\n// \t\tfor (let object of objects) {\n// \t\t\tobject.traverse((child) => {\n// \t\t\t\tthis._ensureGeometryHasIndex(child);\n// \t\t\t\tchild.matrixAutoUpdate = false;\n// \t\t\t});\n// \t\t}\n// \t\treturn objects;\n// \t}\n// \tprivate _onError(message: string, url: string) {\n// \t\tthis.states?.error.set(`could not load geometry from ${url} (${message})`);\n// \t}\n\n// \tprivate _ensureGeometryHasIndex(object: Object3D) {\n// \t\tconst mesh = object as Mesh;\n// \t\tconst geometry = mesh.geometry;\n// \t\tif (geometry) {\n// \t\t\tCoreGeometryIndexBuilder.createIndexIfNone(geometry as BufferGeometry);\n// \t\t}\n// \t}\n\n// \tstatic PARAM_CALLBACK_reload(node: FileMultiSopNode) {\n// \t\tnode._paramCallbackReload();\n// \t}\n// \tprivate _paramCallbackReload() {\n// \t\t// set the param dirty is preferable to just the successors, in case the expression result needs to be updated\n// \t\tthis.p.url.setDirty();\n// \t\t// this.setDirty()\n// \t}\n// }\n","/**\n * Loads a VOX from a url.\n *\n *\n */\nimport {FileVOXSopOperation} from '../../operations/sop/FileVOX';\nimport {fileSopNodeFactory} from './utils/file/_BaseSopFile';\nimport {BaseFileSopOperation} from '../../operations/sop/utils/File/_BaseFileOperation';\nimport {SopTypeFile} from '../../poly/registers/nodes/types/Sop';\nimport {EXTENSIONS_BY_NODE_TYPE_BY_CONTEXT} from '../../../core/loader/FileExtensionRegister';\nimport {NodeContext} from '../../poly/NodeContext';\nexport class FileVOXSopNode extends fileSopNodeFactory({\n\ttype: SopTypeFile.FILE_VOX,\n\toperation: FileVOXSopOperation as typeof BaseFileSopOperation,\n\textensions: EXTENSIONS_BY_NODE_TYPE_BY_CONTEXT[NodeContext.SOP][SopTypeFile.FILE_VOX],\n}) {}\n","/**\n * Snaps points onto one another.\n *\n * @remarks\n * Based on a distance threshold.\n *\n */\nimport {TypedSopNode} from './_Base';\nimport {CoreGroup} from '../../../core/geometry/Group';\nimport {BufferAttribute, BufferGeometry, Object3D, Vector2, Vector3, Vector4, Mesh, Points, LineSegments} from 'three';\nimport {NodeParamsConfig, ParamConfig} from '../utils/params/ParamsConfig';\nimport {InputCloneMode} from '../../poly/InputCloneMode';\nimport {MapUtils} from '../../../core/MapUtils';\nimport {ObjectType, objectTypeFromObject} from '../../../core/geometry/Constant';\nimport {arrayUniq} from '../../../core/ArrayUtils';\nimport {mergeFaces} from '../../../core/geometry/operation/Fuse';\nimport {CoreMask} from '../../../core/geometry/Mask';\nimport {SopType} from '../../poly/registers/nodes/types/Sop';\nconst roundedPosition = new Vector3();\nconst vector2 = new Vector2();\nconst vector3 = new Vector3();\nconst vector4 = new Vector4();\n\nfunction clearAttributes(geometry: BufferGeometry) {\n\tconst attributeNames = Object.keys(geometry.attributes);\n\tfor (const attributeName of attributeNames) {\n\t\tconst attribute = geometry.getAttribute(attributeName);\n\t\tif (attribute instanceof BufferAttribute) {\n\t\t\tconst newAttribValues: number[] = [];\n\t\t\tgeometry.setAttribute(\n\t\t\t\tattributeName,\n\t\t\t\tnew BufferAttribute(new Float32Array(newAttribValues), attribute.itemSize)\n\t\t\t);\n\t\t}\n\t}\n}\n\nclass FuseSopParamsConfig extends NodeParamsConfig {\n\t/** @param group to assign the material to */\n\tgroup = ParamConfig.STRING('', {\n\t\tobjectMask: true,\n\t});\n\t/** @param distance threshold */\n\tdist = ParamConfig.FLOAT(0.001, {\n\t\trange: [0, 1],\n\t\trangeLocked: [true, false],\n\t\tstep: 0.001,\n\t});\n\t/** @param recompute normals */\n\tcomputeNormals = ParamConfig.BOOLEAN(1);\n}\nconst ParamsConfig = new FuseSopParamsConfig();\n\nexport class FuseSopNode extends TypedSopNode<FuseSopParamsConfig> {\n\toverride paramsConfig = ParamsConfig;\n\tstatic override type() {\n\t\treturn SopType.FUSE;\n\t}\n\n\toverride initializeNode() {\n\t\tthis.io.inputs.setCount(1);\n\t\tthis.io.inputs.initInputsClonedState(InputCloneMode.FROM_NODE);\n\t}\n\n\toverride cook(inputCoreGroups: CoreGroup[]) {\n\t\tconst inputCoreGroup = inputCoreGroups[0];\n\n\t\tconst selectedObjects = CoreMask.filterThreejsObjects(inputCoreGroup, this.pv);\n\n\t\tfor (const object of selectedObjects) {\n\t\t\tthis._filterObject(object);\n\t\t}\n\t\tthis.setCoreGroup(inputCoreGroup);\n\t}\n\n\tprivate _filterObject(object: Object3D) {\n\t\tconst objectType = objectTypeFromObject(object);\n\t\tswitch (objectType) {\n\t\t\tcase ObjectType.MESH: {\n\t\t\t\treturn this._filterMesh(object as Mesh);\n\t\t\t}\n\t\t\tcase ObjectType.LINE_SEGMENTS: {\n\t\t\t\tthis._fuseGeometry((object as Mesh).geometry);\n\t\t\t\treturn this._filterLineSegments(object as LineSegments);\n\t\t\t}\n\t\t\tcase ObjectType.POINTS: {\n\t\t\t\tthis._fuseGeometry((object as Mesh).geometry);\n\t\t\t\treturn this._filterPoints(object as Points);\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate _filterMesh(object: Mesh) {\n\t\tconst geometry = object.geometry;\n\t\tconst index = geometry.getIndex();\n\t\tif (!index) {\n\t\t\treturn;\n\t\t}\n\t\tmergeFaces(geometry, this.pv.dist);\n\t}\n\tprivate _filterLineSegments(object: LineSegments) {\n\t\tconst geometry = object.geometry;\n\t\tconst index = geometry.getIndex();\n\t\tif (!index) {\n\t\t\treturn;\n\t\t}\n\t\tconst newIndices: number[] = [];\n\t\tconst indexArray = index.array;\n\t\tconst segmentsCount = indexArray.length / 2;\n\t\tfor (let i = 0; i < segmentsCount; i++) {\n\t\t\tvector2.fromArray(indexArray, i * 2);\n\t\t\tconst a = vector2.x;\n\t\t\tconst b = vector2.y;\n\t\t\tconst segmentSnapped = a == b;\n\t\t\tif (!segmentSnapped) {\n\t\t\t\tvector2.toArray(newIndices, newIndices.length);\n\t\t\t}\n\t\t}\n\t\tgeometry.setIndex(newIndices);\n\t\tif (newIndices.length == 0) {\n\t\t\tclearAttributes(geometry);\n\t\t}\n\t}\n\n\tprivate _filterPoints(object: Points) {\n\t\tconst geometry = object.geometry;\n\t\tconst index = geometry.getIndex();\n\t\tif (!index) {\n\t\t\treturn;\n\t\t}\n\t\tconst indexArray = [...index.array];\n\t\tconst newIndices: number[] = [];\n\t\tarrayUniq(indexArray, newIndices);\n\t\tnewIndices.sort((a, b) => a - b);\n\t\tgeometry.setIndex(newIndices);\n\t\tif (newIndices.length == 0) {\n\t\t\tclearAttributes(geometry);\n\t\t}\n\t}\n\n\tprivate _fuseGeometry(geometry: BufferGeometry) {\n\t\tconst index = geometry.getIndex();\n\t\tif (!index) {\n\t\t\treturn;\n\t\t}\n\t\tconst indexArray = index.array;\n\t\tconst precision = this.pv.dist;\n\t\tconst position = geometry.getAttribute('position') as BufferAttribute;\n\t\tconst pointsCount = position.array.length / 3;\n\n\t\tfunction roundedPos(index: number, target: Vector3) {\n\t\t\ttarget.fromBufferAttribute(position, index);\n\n\t\t\tif (precision > 0) {\n\t\t\t\ttarget.x = Math.round(target.x / precision) * precision;\n\t\t\t\ttarget.y = Math.round(target.y / precision) * precision;\n\t\t\t\ttarget.z = Math.round(target.z / precision) * precision;\n\t\t\t}\n\t\t}\n\n\t\tconst indicesByPosKey: Map<string, Array<number>> = new Map();\n\t\tconst posKeyByIndex: Map<number, string> = new Map();\n\t\tfor (let index = 0; index < pointsCount; index++) {\n\t\t\troundedPos(index, roundedPosition);\n\t\t\tconst posKey = `${roundedPosition.x},${roundedPosition.y},${roundedPosition.z}`;\n\t\t\tMapUtils.pushOnArrayAtEntry(indicesByPosKey, posKey, index);\n\t\t\tposKeyByIndex.set(index, posKey);\n\t\t}\n\n\t\tindicesByPosKey.forEach((indices, posKey) => {\n\t\t\tindices.sort((a, b) => a - b);\n\t\t});\n\n\t\tconst newIndicesAfterGapsCreated: Map<number, number> = new Map();\n\t\tlet nextAvailableIndex = 0;\n\t\tfor (let index = 0; index < pointsCount; index++) {\n\t\t\tconst posKey = posKeyByIndex.get(index)!;\n\t\t\tconst indices = indicesByPosKey.get(posKey)!;\n\t\t\tif (indices.length <= 1 || indices[0] == index) {\n\t\t\t\tnewIndicesAfterGapsCreated.set(index, nextAvailableIndex);\n\t\t\t\tnextAvailableIndex++;\n\t\t\t}\n\t\t}\n\n\t\tconst newIndexByOldIndex: Map<number, number> = new Map();\n\t\tindicesByPosKey.forEach((indices, posKey) => {\n\t\t\tconst firstIndex = indices[0];\n\t\t\tfor (let i = 1; i < indices.length; i++) {\n\t\t\t\tconst index = indices[i];\n\t\t\t\tnewIndexByOldIndex.set(index, firstIndex);\n\t\t\t}\n\t\t});\n\n\t\tconst newIndices: number[] = [];\n\t\tconst newIndexByOldIndexAfterAssignment: Map<number, number> = new Map();\n\t\tfor (let i = 0; i < indexArray.length; i++) {\n\t\t\tconst index = indexArray[i];\n\t\t\tconst targetIndex = newIndexByOldIndex.get(index);\n\t\t\t// const offsetIndex = newIndicesAfterGapsCreated.get(index);\n\t\t\tconst targetOffset =\n\t\t\t\ttargetIndex != null\n\t\t\t\t\t? newIndicesAfterGapsCreated.get(targetIndex)\n\t\t\t\t\t: newIndicesAfterGapsCreated.get(index);\n\t\t\t// const offset2 = offsetIndex != null ? newIndexByOldIndex.get(offsetIndex) : undefined;\n\t\t\tlet newIndex = index;\n\t\t\tif (targetOffset != null) {\n\t\t\t\tnewIndex = targetOffset;\n\t\t\t} else {\n\t\t\t\tif (targetIndex != null) {\n\t\t\t\t\tnewIndex = targetIndex;\n\t\t\t\t}\n\t\t\t}\n\t\t\tnewIndices.push(newIndex);\n\t\t\tnewIndexByOldIndexAfterAssignment.set(index, newIndex);\n\t\t}\n\n\t\tconst attributeNames = Object.keys(geometry.attributes);\n\t\tfor (const attributeName of attributeNames) {\n\t\t\tconst attribute = geometry.getAttribute(attributeName);\n\t\t\tif (attribute instanceof BufferAttribute) {\n\t\t\t\tconst itemSize = attribute.itemSize;\n\t\t\t\tconst newAttribValues: number[] = [];\n\n\t\t\t\tfunction getVector() {\n\t\t\t\t\tif (itemSize == 2) {\n\t\t\t\t\t\treturn vector2;\n\t\t\t\t\t}\n\t\t\t\t\tif (itemSize == 3) {\n\t\t\t\t\t\treturn vector3;\n\t\t\t\t\t}\n\t\t\t\t\tif (itemSize == 4) {\n\t\t\t\t\t\treturn vector4;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tconst vector = getVector();\n\n\t\t\t\tfor (let i = 0; i < pointsCount; i++) {\n\t\t\t\t\tlet index = newIndexByOldIndexAfterAssignment.get(i);\n\t\t\t\t\tif (index == null) {\n\t\t\t\t\t\tindex = i;\n\t\t\t\t\t}\n\t\t\t\t\tif (vector) {\n\t\t\t\t\t\tvector.fromBufferAttribute(attribute, i);\n\t\t\t\t\t\tvector.toArray(newAttribValues, index * itemSize);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tconst currentVal = attribute.array[i];\n\t\t\t\t\t\tnewAttribValues[index] = currentVal;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tgeometry.setAttribute(attributeName, new BufferAttribute(new Float32Array(newAttribValues), itemSize));\n\t\t\t}\n\t\t}\n\t\tgeometry.setIndex(newIndices);\n\t}\n}\n","/**\n * Creates a hemisphere light.\n *\n * @remarks\n * This is very similar to the [object level HemisphereLight](https://polygonjs.com/docs/nodes/obj/HemisphereLight), but can be more useful if you want to instanciate it or process it using other SOP nodes.\n *\n */\n\nimport {TypedSopNode} from './_Base';\nimport {CoreGroup} from '../../../core/geometry/Group';\n\nimport {NodeParamsConfig} from '../utils/params/ParamsConfig';\nimport {HemisphereLightParamConfig} from '../../../core/lights/HemisphereLight';\nimport {HemisphereLightSopOperation} from '../../operations/sop/HemisphereLight';\nclass HemisphereLightSopParamsConfig extends HemisphereLightParamConfig(NodeParamsConfig) {}\nconst ParamsConfig = new HemisphereLightSopParamsConfig();\n\nexport class HemisphereLightSopNode extends TypedSopNode<HemisphereLightSopParamsConfig> {\n\toverride paramsConfig = ParamsConfig;\n\tstatic override type() {\n\t\treturn 'hemisphereLight';\n\t}\n\n\toverride initializeNode() {\n\t\tthis.io.inputs.setCount(0);\n\t}\n\n\tprivate _operation: HemisphereLightSopOperation | undefined;\n\toverride cook(inputCoreGroups: CoreGroup[]) {\n\t\tthis._operation = this._operation || new HemisphereLightSopOperation(this._scene, this.states, this);\n\t\tconst coreGroup = this._operation.cook(inputCoreGroups, this.pv);\n\t\tthis.setCoreGroup(coreGroup);\n\t}\n}\n","/**\n * Creates hexagons on a plane.\n *\n * @remarks\n * This is very similar to the plane SOP, but with hexagonal patterns, which can be more visually pleasing.\n */\nimport {CoreGroup} from './../../../core/geometry/Group';\nimport {TypedSopNode} from './_Base';\nimport {HexagonsSopOperation} from '../../operations/sop/Hexagons';\nimport {NodeParamsConfig, ParamConfig} from '../utils/params/ParamsConfig';\nconst DEFAULT = HexagonsSopOperation.DEFAULT_PARAMS;\nclass HexagonsSopParamsConfig extends NodeParamsConfig {\n\t/** @param plane size */\n\tsize = ParamConfig.VECTOR2(DEFAULT.size);\n\t/** @param hexagons size */\n\thexagonRadius = ParamConfig.FLOAT(DEFAULT.hexagonRadius, {\n\t\trange: [0.001, 1],\n\t\trangeLocked: [false, false],\n\t});\n\t/** @param axis perpendicular to the plane */\n\tdirection = ParamConfig.VECTOR3(DEFAULT.direction);\n\t/** @param do not create polygons, only points */\n\tpointsOnly = ParamConfig.BOOLEAN(DEFAULT.pointsOnly);\n\t// no need to have centers, as all points are centers anyway\n\t//this.add_param( ParamType.TOGGLE, 'centers_only', 0, {visibleIf: {pointsOnly: 1}})\n}\nconst ParamsConfig = new HexagonsSopParamsConfig();\n\nexport class HexagonsSopNode extends TypedSopNode<HexagonsSopParamsConfig> {\n\toverride paramsConfig = ParamsConfig;\n\tstatic override type() {\n\t\treturn 'hexagons';\n\t}\n\toverride initializeNode() {\n\t\tthis.io.inputs.setCount(0, 1);\n\t\tthis.io.inputs.initInputsClonedState(HexagonsSopOperation.INPUT_CLONED_STATE);\n\t}\n\n\tprivate _operation: HexagonsSopOperation | undefined;\n\toverride cook(input_contents: CoreGroup[]) {\n\t\tthis._operation = this._operation || new HexagonsSopOperation(this.scene(), this.states, this);\n\t\tconst core_group = this._operation.cook(input_contents, this.pv);\n\t\tthis.setCoreGroup(core_group);\n\t}\n}\n","/**\n * Adds or remove parents from the object hierarchy.\n *\n * @remarks\n * This can be useful after importing a geometry from a File SOP, where the part we want to manipulate is under one or several parents. This allows to extract it to make it available for other nodes.\n */\nimport {TypedSopNode} from './_Base';\nimport {CoreGroup} from '../../../core/geometry/Group';\nimport {\n\tHierarchyMode,\n\tHierarchySopOperation,\n\tHIERARCHY_MODES,\n\tADD_CHILD_MODES,\n\tAddChildMode,\n} from '../../operations/sop/Hierarchy';\nexport const MODES_WITH_LEVEL = [HierarchyMode.ADD_PARENT, HierarchyMode.REMOVE_PARENT];\nimport {NodeParamsConfig, ParamConfig} from '../utils/params/ParamsConfig';\nimport {SopType} from '../../poly/registers/nodes/types/Sop';\nconst DEFAULT = HierarchySopOperation.DEFAULT_PARAMS;\nclass HierarchySopParamsConfig extends NodeParamsConfig {\n\t/** @param defines if parent objects will be added or removed */\n\tmode = ParamConfig.INTEGER(DEFAULT.mode, {\n\t\tmenu: {\n\t\t\tentries: HIERARCHY_MODES.map((m, i) => {\n\t\t\t\treturn {name: m, value: i};\n\t\t\t}),\n\t\t},\n\t});\n\t/** @param defines how many parent objects will be added or removed */\n\tlevels = ParamConfig.INTEGER(DEFAULT.levels, {\n\t\trange: [0, 5],\n\t\tvisibleIf: [\n\t\t\t{mode: HIERARCHY_MODES.indexOf(HierarchyMode.ADD_PARENT)},\n\t\t\t{mode: HIERARCHY_MODES.indexOf(HierarchyMode.REMOVE_PARENT)},\n\t\t],\n\t});\n\t/** @param when the mode is set to add_child, the mask defines which parent the children are added to. If the mask is an empty string, the children will be added to the objects at the top of the hierarchy. Also, the children are taken from the second input. */\n\tobjectMask = ParamConfig.STRING('', {\n\t\tvisibleIf: {mode: HIERARCHY_MODES.indexOf(HierarchyMode.ADD_CHILD)},\n\t\tobjectMask: true,\n\t});\n\t/** @param defines how the children are added to the parents */\n\taddChildMode = ParamConfig.INTEGER(DEFAULT.addChildMode, {\n\t\tvisibleIf: {mode: HIERARCHY_MODES.indexOf(HierarchyMode.ADD_CHILD)},\n\t\tmenu: {\n\t\t\tentries: ADD_CHILD_MODES.map((m, i) => {\n\t\t\t\treturn {name: m, value: i};\n\t\t\t}),\n\t\t},\n\t});\n}\nconst ParamsConfig = new HierarchySopParamsConfig();\n\nexport class HierarchySopNode extends TypedSopNode<HierarchySopParamsConfig> {\n\toverride paramsConfig = ParamsConfig;\n\tstatic override type() {\n\t\treturn SopType.HIERARCHY;\n\t}\n\n\toverride initializeNode() {\n\t\tthis.io.inputs.setCount(1, 2);\n\t\tthis.io.inputs.initInputsClonedState(HierarchySopOperation.INPUT_CLONED_STATE);\n\t}\n\n\tprivate _operation: HierarchySopOperation | undefined;\n\toverride cook(inputCoreGroups: CoreGroup[]) {\n\t\tthis._operation = this._operation || new HierarchySopOperation(this._scene, this.states, this);\n\t\tconst coreGroup = this._operation.cook(inputCoreGroups, this.pv);\n\t\tthis.setCoreGroup(coreGroup);\n\t}\n\n\tsetMode(mode: HierarchyMode) {\n\t\tthis.p.mode.set(HIERARCHY_MODES.indexOf(mode));\n\t}\n\tsetAddChildMode(mode: AddChildMode) {\n\t\tthis.p.addChildMode.set(ADD_CHILD_MODES.indexOf(mode));\n\t}\n}\n","/**\n * Creates an Isocahedron\n *\n * @remarks\n * This is similar to a sphere, but with hexagonal patterns\n */\nimport {TypedSopNode} from './_Base';\nimport {IcosahedronSopOperation} from '../../operations/sop/Icosahedron';\n\nimport {NodeParamsConfig, ParamConfig} from '../utils/params/ParamsConfig';\nimport {SopType} from '../../poly/registers/nodes/types/Sop';\nconst DEFAULT = IcosahedronSopOperation.DEFAULT_PARAMS;\nclass IcosahedronSopParamsConfig extends NodeParamsConfig {\n\t/** @param radius of the icosahedron */\n\tradius = ParamConfig.FLOAT(DEFAULT.radius);\n\t/** @param resolution of the icosahedron */\n\tdetail = ParamConfig.INTEGER(DEFAULT.detail, {\n\t\trange: [0, 32],\n\t\trangeLocked: [true, false],\n\t});\n\t/** @param do not create polygons, only points. */\n\tpointsOnly = ParamConfig.BOOLEAN(DEFAULT.pointsOnly);\n\t/** @param center of the icosahedron */\n\tcenter = ParamConfig.VECTOR3(DEFAULT.center);\n}\nconst ParamsConfig = new IcosahedronSopParamsConfig();\n\nexport class IcosahedronSopNode extends TypedSopNode<IcosahedronSopParamsConfig> {\n\toverride paramsConfig = ParamsConfig;\n\tstatic override type() {\n\t\treturn SopType.ICOSAHEDRON;\n\t}\n\n\tprivate _operation: IcosahedronSopOperation | undefined;\n\toverride cook() {\n\t\tthis._operation = this._operation || new IcosahedronSopOperation(this._scene, this.states, this);\n\t\tconst core_group = this._operation.cook([], this.pv);\n\t\tthis.setCoreGroup(core_group);\n\t}\n}\n","/**\n * Copies a geometry onto every point from the right input.\n *\n * @remarks\n * Creates an instance geometry, by instancing the geometry in the left input onto every point from the right input. This is a great way to display a lot of geometries on screen with little performance penalty.\n *\n *\n */\n\nimport {TypedSopNode} from './_Base';\nimport {CoreGroup} from '../../../core/geometry/Group';\nimport {NodeContext} from '../../poly/NodeContext';\nimport {InstanceSopOperation} from '../../operations/sop/Instance';\nimport {NodeParamsConfig, ParamConfig} from '../utils/params/ParamsConfig';\nimport {SopType} from '../../poly/registers/nodes/types/Sop';\nconst DEFAULT = InstanceSopOperation.DEFAULT_PARAMS;\nclass InstanceSopParamsConfig extends NodeParamsConfig {\n\t/** @param attributes to copy to the instance */\n\tattributesToCopy = ParamConfig.STRING(DEFAULT.attributesToCopy);\n\t/** @param toggles on to apply a material. This is useful in most cases, but there may be situations where the material would be apply later, such as when you are feeding this node to a particles system */\n\tapplyMaterial = ParamConfig.BOOLEAN(DEFAULT.applyMaterial);\n\t/** @param material to apply */\n\tmaterial = ParamConfig.NODE_PATH('', {\n\t\tvisibleIf: {applyMaterial: 1},\n\t\tnodeSelection: {\n\t\t\tcontext: NodeContext.MAT,\n\t\t},\n\t\tdependentOnFoundNode: false,\n\t});\n}\nconst ParamsConfig = new InstanceSopParamsConfig();\n\nexport class InstanceSopNode extends TypedSopNode<InstanceSopParamsConfig> {\n\toverride paramsConfig = ParamsConfig;\n\tstatic override type() {\n\t\treturn SopType.INSTANCE;\n\t}\n\n\toverride initializeNode() {\n\t\tsuper.initializeNode();\n\t\tthis.io.inputs.setCount(2);\n\t\tthis.io.inputs.initInputsClonedState(InstanceSopOperation.INPUT_CLONED_STATE);\n\t}\n\n\tprivate _operation: InstanceSopOperation | undefined;\n\toverride async cook(inputCoreGroups: CoreGroup[]) {\n\t\tthis._operation = this._operation || new InstanceSopOperation(this.scene(), this.states, this);\n\t\tconst coreGroup = await this._operation.cook(inputCoreGroups, this.pv);\n\t\tthis.setCoreGroup(coreGroup);\n\t}\n}\n","/**\n * Jitter the input points\n *\n * @remarks\n * This can be useful to add amounts of disturbance in the geometry. Either to debug it, or to remove a bit of its smoothness.\n */\nimport {CoreGroup} from '../../../core/geometry/Group';\nimport {TypedSopNode} from './_Base';\nimport {JitterSopOperation} from '../../operations/sop/Jitter';\nimport {NodeParamsConfig, ParamConfig} from '../utils/params/ParamsConfig';\nimport {SopType} from '../../poly/registers/nodes/types/Sop';\n\nconst DEFAULT = JitterSopOperation.DEFAULT_PARAMS;\nclass JitterSopParamsConfig extends NodeParamsConfig {\n\t/** @param amount of jitter */\n\tamount = ParamConfig.FLOAT(DEFAULT.amount);\n\t/** @param mult of each axis */\n\tmult = ParamConfig.VECTOR3(DEFAULT.mult);\n\t/** @param seed used to set the direction each point is moved to */\n\tseed = ParamConfig.INTEGER(DEFAULT.seed, {range: [0, 100]});\n}\nconst ParamsConfig = new JitterSopParamsConfig();\n\nexport class JitterSopNode extends TypedSopNode<JitterSopParamsConfig> {\n\toverride paramsConfig = ParamsConfig;\n\tstatic override type() {\n\t\treturn SopType.JITTER;\n\t}\n\n\toverride initializeNode() {\n\t\tthis.io.inputs.setCount(1);\n\t\tthis.io.inputs.initInputsClonedState(JitterSopOperation.INPUT_CLONED_STATE);\n\t}\n\n\tprivate _operation: JitterSopOperation | undefined;\n\toverride cook(input_contents: CoreGroup[]) {\n\t\tthis._operation = this._operation || new JitterSopOperation(this.scene(), this.states, this);\n\t\tconst core_group = this._operation.cook(input_contents, this.pv);\n\t\tthis.setCoreGroup(core_group);\n\t}\n}\n","/**\n * Sets the layer of the input objects\n *\n * @remarks\n * This should be combined with the layer of a camera. This will allow some objects to be only visible via some cameras.\n */\nimport {TypedSopNode} from './_Base';\nimport {NodeParamsConfig, ParamConfig} from '../utils/params/ParamsConfig';\nimport {InputCloneMode} from '../../poly/InputCloneMode';\nimport {CoreGroup} from '../../../core/geometry/Group';\nimport {SopType} from '../../poly/registers/nodes/types/Sop';\nimport {filterThreejsObjectsWithGroup} from '../../../core/geometry/Mask';\nimport {Object3D} from 'three';\n\nexport enum LayerUpdateMode {\n\tSET = 'set',\n\tADD = 'add',\n\tREMOVE = 'remove',\n}\nexport const UPDATE_MODES: LayerUpdateMode[] = [LayerUpdateMode.SET, LayerUpdateMode.ADD, LayerUpdateMode.REMOVE];\nconst UPDATE_MODE_ENTRIES = UPDATE_MODES.map((name, value) => {\n\treturn {name, value};\n});\ntype AvailableLayerIndex = 0 | 1 | 2 | 3;\ninterface VisibleOptions {\n\tlayersCount: number;\n}\nfunction visibleOption(options: VisibleOptions) {\n\tconst computedOptions: Record<string, number>[] = [];\n\tfor (let i = 1; i <= 4; i++) {\n\t\tif (i >= options.layersCount) {\n\t\t\tcomputedOptions.push({layersCount: i});\n\t\t}\n\t}\n\treturn {\n\t\tvisibleIf: computedOptions,\n\t};\n}\n\nclass LayerSopParamsConfig extends NodeParamsConfig {\n\t/** @param group to assign the material to */\n\tgroup = ParamConfig.STRING('*', {\n\t\tobjectMask: true,\n\t});\n\tlayersCount = ParamConfig.INTEGER(1, {\n\t\trange: [1, 4],\n\t\trangeLocked: [true, true],\n\t\tseparatorAfter: true,\n\t});\n\t/** @param updateMode */\n\tupdateMode0 = ParamConfig.INTEGER(UPDATE_MODES.indexOf(LayerUpdateMode.ADD), {\n\t\tmenu: {\n\t\t\tentries: UPDATE_MODE_ENTRIES,\n\t\t},\n\t\t...visibleOption({layersCount: 1}),\n\t});\n\t/** @param layer */\n\tlayer0 = ParamConfig.INTEGER(0, {\n\t\trange: [0, 31],\n\t\trangeLocked: [true, true],\n\t\t...visibleOption({layersCount: 1}),\n\t});\n\t/** @param updateMode */\n\tupdateMode1 = ParamConfig.INTEGER(UPDATE_MODES.indexOf(LayerUpdateMode.ADD), {\n\t\tmenu: {\n\t\t\tentries: UPDATE_MODE_ENTRIES,\n\t\t},\n\t\t...visibleOption({layersCount: 2}),\n\t});\n\t/** @param layer */\n\tlayer1 = ParamConfig.INTEGER(0, {\n\t\trange: [0, 31],\n\t\trangeLocked: [true, true],\n\t\t...visibleOption({layersCount: 2}),\n\t});\n\t/** @param updateMode */\n\tupdateMode2 = ParamConfig.INTEGER(UPDATE_MODES.indexOf(LayerUpdateMode.ADD), {\n\t\tmenu: {\n\t\t\tentries: UPDATE_MODE_ENTRIES,\n\t\t},\n\t\t...visibleOption({layersCount: 3}),\n\t});\n\t/** @param layer */\n\tlayer2 = ParamConfig.INTEGER(0, {\n\t\trange: [0, 31],\n\t\trangeLocked: [true, true],\n\t\t...visibleOption({layersCount: 3}),\n\t});\n\t/** @param updateMode */\n\tupdateMode3 = ParamConfig.INTEGER(UPDATE_MODES.indexOf(LayerUpdateMode.ADD), {\n\t\tmenu: {\n\t\t\tentries: UPDATE_MODE_ENTRIES,\n\t\t},\n\t\t...visibleOption({layersCount: 4}),\n\t});\n\t/** @param layer */\n\tlayer3 = ParamConfig.INTEGER(0, {\n\t\trange: [0, 31],\n\t\trangeLocked: [true, true],\n\t\t...visibleOption({layersCount: 4}),\n\t});\n}\nconst ParamsConfig = new LayerSopParamsConfig();\n\nexport class LayerSopNode extends TypedSopNode<LayerSopParamsConfig> {\n\toverride paramsConfig = ParamsConfig;\n\tstatic override type() {\n\t\treturn SopType.LAYER;\n\t}\n\n\toverride initializeNode() {\n\t\tthis.io.inputs.setCount(1);\n\t\tthis.io.inputs.initInputsClonedState(InputCloneMode.FROM_NODE);\n\t}\n\n\toverride cook(inputCoreGroups: CoreGroup[]) {\n\t\tconst coreGroup = inputCoreGroups[0];\n\n\t\tconst objects = filterThreejsObjectsWithGroup(coreGroup, this.pv);\n\n\t\tfor (const object of objects) {\n\t\t\tthis._updateLayers(object);\n\t\t\t// object.layers.set(this.pv.layer);\n\t\t}\n\n\t\tthis.setCoreGroup(coreGroup);\n\t}\n\tprivate _updateLayers(object: Object3D) {\n\t\tthis._updateLayer(0, object, UPDATE_MODES[this.pv.updateMode0], this.pv.layer0);\n\t\tthis._updateLayer(1, object, UPDATE_MODES[this.pv.updateMode1], this.pv.layer1);\n\t\tthis._updateLayer(2, object, UPDATE_MODES[this.pv.updateMode2], this.pv.layer2);\n\t\tthis._updateLayer(3, object, UPDATE_MODES[this.pv.updateMode3], this.pv.layer3);\n\t}\n\tprivate _updateLayer(index: AvailableLayerIndex, object: Object3D, updateMode: LayerUpdateMode, layer: number) {\n\t\tif (index > this.pv.layersCount - 1) {\n\t\t\treturn;\n\t\t}\n\t\tswitch (updateMode) {\n\t\t\tcase LayerUpdateMode.SET: {\n\t\t\t\tobject.layers.set(layer);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tcase LayerUpdateMode.ADD: {\n\t\t\t\tobject.layers.enable(layer);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tcase LayerUpdateMode.REMOVE: {\n\t\t\t\tobject.layers.disable(layer);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n\t//\n\t// helper methods\n\t//\n\tsetMode(index: AvailableLayerIndex, mode: LayerUpdateMode) {\n\t\tconst param = [this.p.updateMode0, this.p.updateMode1, this.p.updateMode2, this.p.updateMode3];\n\t\tparam[index].set(UPDATE_MODES.indexOf(mode));\n\t}\n\tsetLayer(index: AvailableLayerIndex, layer: number) {\n\t\tconst param = [this.p.layer0, this.p.layer1, this.p.layer2, this.p.layer3];\n\t\tparam[index].set(layer);\n\t}\n}\n","/**\n * Creates a light probe.\n *\n * @remarks\n * This is very similar to the [object level LightProbe](https://polygonjs.com/docs/nodes/obj/LightProbe), but can be more useful if you want to instanciate it or process it using other SOP nodes.\n *\n */\n\nimport {TypedSopNode} from './_Base';\nimport {CoreGroup} from '../../../core/geometry/Group';\n\nimport {NodeParamsConfig} from '../utils/params/ParamsConfig';\nimport {LightProbeParamConfig} from '../../../core/lights/LightProbe';\nimport {LightProbeSopOperation} from '../../operations/sop/LightProbe';\nclass LightProbeSopParamsConfig extends LightProbeParamConfig(NodeParamsConfig) {}\nconst ParamsConfig = new LightProbeSopParamsConfig();\n\nexport class LightProbeSopNode extends TypedSopNode<LightProbeSopParamsConfig> {\n\toverride paramsConfig = ParamsConfig;\n\tstatic override type() {\n\t\treturn 'lightProbe';\n\t}\n\n\toverride initializeNode() {\n\t\tthis.io.inputs.setCount(0);\n\t}\n\n\tprivate _operation: LightProbeSopOperation | undefined;\n\toverride async cook(inputCoreGroups: CoreGroup[]) {\n\t\tthis._operation = this._operation || new LightProbeSopOperation(this._scene, this.states, this);\n\t\tconst coreGroup = await this._operation.cook(inputCoreGroups, this.pv);\n\t\tthis.setCoreGroup(coreGroup);\n\t}\n}\n","/**\n * Creates a line\n *\n */\nimport {Float32BufferAttribute, Vector3} from 'three';\nimport {BufferGeometry} from 'three';\nimport {TypedSopNode} from './_Base';\nimport {ObjectType} from '../../../core/geometry/Constant';\n\nimport {NodeParamsConfig, ParamConfig} from '../utils/params/ParamsConfig';\nclass LineSopParamsConfig extends NodeParamsConfig {\n\t/** @param length of the line */\n\tlength = ParamConfig.FLOAT(1, {range: [0, 10]});\n\t/** @param number of points */\n\tpointsCount = ParamConfig.INTEGER(2, {\n\t\trange: [2, 100],\n\t\trangeLocked: [true, false],\n\t});\n\t/** @param start position of the line */\n\torigin = ParamConfig.VECTOR3([0, 0, 0]);\n\t/** @param direction of the line */\n\tdirection = ParamConfig.VECTOR3([0, 1, 0]);\n}\nconst ParamsConfig = new LineSopParamsConfig();\n\nexport class LineSopNode extends TypedSopNode<LineSopParamsConfig> {\n\toverride paramsConfig = ParamsConfig;\n\tstatic override type() {\n\t\treturn 'line';\n\t}\n\n\toverride initializeNode() {}\n\n\tprivate _lastPt = new Vector3();\n\tprivate _current = new Vector3();\n\toverride cook() {\n\t\tconst pointsCount = Math.max(2, this.pv.pointsCount);\n\n\t\tconst positions: number[] = new Array(pointsCount * 3);\n\t\tconst indices: number[] = new Array(pointsCount);\n\n\t\tthis._lastPt.copy(this.pv.direction).normalize().multiplyScalar(this.pv.length);\n\n\t\tfor (let i = 0; i < pointsCount; i++) {\n\t\t\tconst i_n = i / (pointsCount - 1);\n\t\t\tthis._current.copy(this._lastPt).multiplyScalar(i_n);\n\t\t\tthis._current.add(this.pv.origin);\n\t\t\tthis._current.toArray(positions, i * 3);\n\n\t\t\tif (i > 0) {\n\t\t\t\tindices[(i - 1) * 2] = i - 1;\n\t\t\t\tindices[(i - 1) * 2 + 1] = i;\n\t\t\t}\n\t\t}\n\t\tconst geometry = new BufferGeometry();\n\t\tgeometry.setAttribute('position', new Float32BufferAttribute(positions, 3));\n\t\tgeometry.setIndex(indices);\n\t\tthis.setGeometry(geometry, ObjectType.LINE_SEGMENTS);\n\t}\n}\n","/**\n * Applies a material to objects\n *\n * @remarks\n * This can assign the material to the top level objects, but also to their children.\n *\n * This node can also be used to process input materials, without assigning a new one. This can be useful when processing a geometry imported from a File SOP. You may want to swap textures, in which case you could swap the emission texture to the color one. This would allow you to use a mesh basic material, which would be faster to render.\n */\nimport {TypedSopNode} from './_Base';\nimport {NodeContext} from '../../poly/NodeContext';\nimport {CoreGroup} from '../../../core/geometry/Group';\nimport {MaterialSopOperation} from '../../operations/sop/Material';\n\nimport {NodeParamsConfig, ParamConfig} from '../utils/params/ParamsConfig';\nimport {SopType} from '../../poly/registers/nodes/types/Sop';\nconst DEFAULT = MaterialSopOperation.DEFAULT_PARAMS;\nclass MaterialSopParamsConfig extends NodeParamsConfig {\n\t/** @param group to assign the material to */\n\tgroup = ParamConfig.STRING(DEFAULT.group, {\n\t\tobjectMask: true,\n\t});\n\t/** @param toggle on to assign the new material */\n\tassignMat = ParamConfig.BOOLEAN(DEFAULT.assignMat);\n\t/** @param the material node */\n\tmaterial = ParamConfig.NODE_PATH('', {\n\t\tnodeSelection: {\n\t\t\tcontext: NodeContext.MAT,\n\t\t},\n\t\tdependentOnFoundNode: false,\n\t\tvisibleIf: {assignMat: 1},\n\t});\n\n\t// cloneMat is mostly useful when swapping tex for multiple objects which have different textures\n\t// but can also be used when requiring a unique material per object, when using a copy SOP\n\t/** @param Cloning the material would prevent the material node to have any effect on the processed geometries. But it would allow to have multiple materials, if this was used with a Copy SOP for instance */\n\tcloneMat = ParamConfig.BOOLEAN(DEFAULT.cloneMat, {\n\t\tvisibleIf: {assignMat: 1},\n\t\tseparatorBefore: true,\n\t});\n\t/** @param while cloning the material, you may only want to change basic properties (such as depthWrite or transparent), but you would want to still use the same custom uniforms created by GL/param nodes */\n\tshareCustomUniforms = ParamConfig.BOOLEAN(DEFAULT.shareCustomUniforms, {visibleIf: {assignMat: 1, cloneMat: 1}});\n\t/** @param swap one texture with another */\n\tswapCurrentTex = ParamConfig.BOOLEAN(DEFAULT.swapCurrentTex);\n\t/** @param texture to swap */\n\ttexSrc0 = ParamConfig.STRING(DEFAULT.texSrc0, {visibleIf: {swapCurrentTex: 1}});\n\t/** @param texture to swap */\n\ttexDest0 = ParamConfig.STRING(DEFAULT.texDest0, {visibleIf: {swapCurrentTex: 1}});\n}\nconst ParamsConfig = new MaterialSopParamsConfig();\n\nexport class MaterialSopNode extends TypedSopNode<MaterialSopParamsConfig> {\n\toverride paramsConfig = ParamsConfig;\n\tstatic override type() {\n\t\treturn SopType.MATERIAL;\n\t}\n\n\tprotected override initializeNode() {\n\t\tthis.io.inputs.setCount(1);\n\t\tthis.io.inputs.initInputsClonedState(MaterialSopOperation.INPUT_CLONED_STATE);\n\t}\n\n\tprivate _operation: MaterialSopOperation | undefined;\n\toverride async cook(inputCoreGroups: CoreGroup[]) {\n\t\tthis._operation = this._operation || new MaterialSopOperation(this._scene, this.states, this);\n\t\tconst coreGroup = await this._operation.cook(inputCoreGroups, this.pv);\n\t\tthis.setCoreGroup(coreGroup);\n\t}\n}\n","/**\n * Applies a noise to the geometry\n *\n * @remarks\n * The noise can affect any attribute, not just the position.\n *\n */\nimport {Vector2, Vector3, Vector4, BufferAttribute} from 'three';\nimport {TypedSopNode} from './_Base';\nimport {CoreGroup} from '../../../core/geometry/Group';\nimport {Attribute} from '../../../core/geometry/Attribute';\nimport {CoreMath} from '../../../core/math/_Module';\nimport {InputCloneMode} from '../../poly/InputCloneMode';\nimport {TypeAssert} from '../../poly/Assert';\nimport {SimplexNoise} from 'three/examples/jsm/math/SimplexNoise';\nimport {NodeParamsConfig, ParamConfig} from '../utils/params/ParamsConfig';\nimport {BaseCorePoint, CorePoint} from '../../../core/geometry/entities/point/CorePoint';\nimport {CoreType} from '../../../core/Type';\nimport {AttribValue, NumericAttribValue} from '../../../types/GlobalTypes';\nimport {isBooleanTrue} from '../../../core/BooleanValue';\nimport {AttribType} from '../../../core/geometry/Constant';\nimport {SopType} from '../../poly/registers/nodes/types/Sop';\nimport {CoreObjectType} from '../../../core/geometry/ObjectContent';\n\nexport enum NoiseOperation {\n\tADD = 'add',\n\tSET = 'set',\n\tMULT = 'mult',\n\tSUBTRACT = 'subtract',\n\tDIVIDE = 'divide',\n}\nconst OPERATIONS: NoiseOperation[] = [\n\tNoiseOperation.ADD,\n\tNoiseOperation.SET,\n\tNoiseOperation.MULT,\n\tNoiseOperation.SUBTRACT,\n\tNoiseOperation.DIVIDE,\n];\n\ninterface FbmParams {\n\toctaves: number;\n\tampAttenuation: number;\n\tfreqIncrease: number;\n}\n\nconst position = new Vector3();\nconst normal = new Vector3();\nconst _destPoints: CorePoint<CoreObjectType>[] = [];\nconst _restPos = new Vector3();\nconst _restValue2 = new Vector2();\nconst _restValue4 = new Vector4();\nconst _noiseValueV = new Vector3();\nlet _currentAttribValueF = 0;\nconst _currentAttribValueV2 = new Vector2();\nconst _currentAttribValueV3 = new Vector3();\nconst _currentAttribValueV4 = new Vector4();\n\nclass NoiseSopParamsConfig extends NodeParamsConfig {\n\t/** @param noise amplitude */\n\tamplitude = ParamConfig.FLOAT(1);\n\t/** @param toggle on to multiply the amplitude by a vertex attribute */\n\ttamplitudeAttrib = ParamConfig.BOOLEAN(0);\n\t/** @param which vertex attribute to use */\n\tamplitudeAttrib = ParamConfig.STRING('amp', {visibleIf: {tamplitudeAttrib: true}});\n\t/** @param noise frequency */\n\tfreq = ParamConfig.VECTOR3([1, 1, 1]);\n\t/** @param noise offset */\n\toffset = ParamConfig.VECTOR3([0, 0, 0]);\n\t/** @param noise octaves */\n\toctaves = ParamConfig.INTEGER(3, {\n\t\trange: [1, 8],\n\t\trangeLocked: [true, false],\n\t});\n\t/** @param amplitude attenuation for higher octaves */\n\tampAttenuation = ParamConfig.FLOAT(0.5, {range: [0, 1]});\n\t/** @param frequency increase for higher octaves */\n\tfreqIncrease = ParamConfig.FLOAT(2, {range: [0, 10]});\n\t/** @param noise seed */\n\tseed = ParamConfig.INTEGER(0, {\n\t\trange: [0, 100],\n\t\tseparatorAfter: true,\n\t});\n\t/** @param toggle on to have the noise be multiplied by the normal */\n\tuseNormals = ParamConfig.BOOLEAN(0);\n\t/** @param set which attribute will be affected by the noise */\n\tattribName = ParamConfig.STRING('position');\n\t/** @param toggle on to use rest attributes. This can be useful when the noise is animated and this node does not clone the input geometry. Without using rest attributes, the noise would be based on an already modified position, and would therefore accumulate on itself after each cook. This may be what you are after, but for a more conventional result, using a rest attribute will ensure that the noise remains stable. Note that the rest attribute can be created by a RestAttributes node */\n\tuseRestAttributes = ParamConfig.BOOLEAN(0);\n\t/** @param name of rest position */\n\trestP = ParamConfig.STRING('restP', {visibleIf: {useRestAttributes: true}});\n\t/** @param name of rest normal */\n\trestN = ParamConfig.STRING('restN', {visibleIf: {useRestAttributes: true}});\n\t/** @param operation done when applying the noise (add, set, mult, subtract, divide) */\n\toperation = ParamConfig.INTEGER(OPERATIONS.indexOf(NoiseOperation.ADD), {\n\t\tmenu: {\n\t\t\tentries: OPERATIONS.map((operation) => {\n\t\t\t\treturn {\n\t\t\t\t\tname: operation,\n\t\t\t\t\tvalue: OPERATIONS.indexOf(operation),\n\t\t\t\t};\n\t\t\t}),\n\t\t},\n\t});\n\t/** @param toggle on to recompute normals if the position has been updated */\n\tcomputeNormals = ParamConfig.BOOLEAN(1);\n}\nconst ParamsConfig = new NoiseSopParamsConfig();\n\nexport class NoiseSopNode extends TypedSopNode<NoiseSopParamsConfig> {\n\toverride paramsConfig = ParamsConfig;\n\tstatic override type() {\n\t\treturn SopType.NOISE;\n\t}\n\n\tprivate _simplexBySeed: Map<number, SimplexNoise> = new Map();\n\n\toverride initializeNode() {\n\t\tthis.io.inputs.setCount(1);\n\t\tthis.io.inputs.initInputsClonedState([InputCloneMode.FROM_NODE]);\n\t}\n\n\tsetOperation(operation: NoiseOperation) {\n\t\tthis.p.operation.set(OPERATIONS.indexOf(operation));\n\t}\n\n\toverride cook(inputCoreGroups: CoreGroup[]) {\n\t\tconst coreGroup = inputCoreGroups[0];\n\t\tcoreGroup.points(_destPoints);\n\t\tconst destAttribName = this.pv.attribName;\n\n\t\tif (!coreGroup.hasPointAttrib(destAttribName)) {\n\t\t\tthis.states.error.set(`attribute ${destAttribName} not found`);\n\t\t\tthis.cookController.endCook();\n\t\t\treturn;\n\t\t}\n\t\tconst attribType = coreGroup.pointAttribType(destAttribName);\n\t\tif (attribType != AttribType.NUMERIC) {\n\t\t\tthis.states.error.set(`attribute ${destAttribName} is not a numeric attribute`);\n\t\t\tthis.cookController.endCook();\n\t\t\treturn;\n\t\t}\n\n\t\tconst targetAttribSize = coreGroup.pointAttribSize(this.pv.attribName);\n\n\t\tconst firstPt = _destPoints[0];\n\t\tif (!firstPt) {\n\t\t\tthis.setCoreGroup(coreGroup);\n\t\t\treturn;\n\t\t}\n\n\t\t// check the first pt attrib size\n\t\tconst currentAttribValue: AttribValue = firstPt.attribValue(destAttribName);\n\t\tif (CoreType.isString(currentAttribValue)) {\n\t\t\tthis.states.error.set('cannot add noise to a string attribute');\n\t\t\treturn;\n\t\t}\n\t\tconst fbmParams = {\n\t\t\toctaves: this.pv.octaves,\n\t\t\tampAttenuation: this.pv.ampAttenuation,\n\t\t\tfreqIncrease: this.pv.freqIncrease,\n\t\t};\n\n\t\ttry {\n\t\t\tswitch (targetAttribSize) {\n\t\t\t\tcase 1: {\n\t\t\t\t\tthis._cookForFloat(_destPoints, fbmParams);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcase 2: {\n\t\t\t\t\tthis._cookForV2(_destPoints, fbmParams);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcase 3: {\n\t\t\t\t\tthis._cookForV3(_destPoints, fbmParams);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcase 4: {\n\t\t\t\t\tthis._cookForV4(_destPoints, fbmParams);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (err) {\n\t\t\tconsole.error('sop/noise error', err);\n\t\t\tthis.states.error.set(`cook failed for (${this.path()}). make sure the required attributes are present`);\n\t\t}\n\t\tif (!this.io.inputs.cloneRequired(0)) {\n\t\t\tfor (const geometry of coreGroup.geometries()) {\n\t\t\t\t(geometry.getAttribute(destAttribName) as BufferAttribute).needsUpdate = true;\n\t\t\t}\n\t\t}\n\n\t\tif (isBooleanTrue(this.pv.computeNormals)) {\n\t\t\tconst objects = coreGroup.threejsObjectsWithGeo();\n\t\t\tfor (const object of objects) {\n\t\t\t\tobject.geometry.computeVertexNormals();\n\t\t\t}\n\t\t}\n\t\tthis.setCoreGroup(coreGroup);\n\t}\n\n\tprivate _cookForFloat(destPoints: BaseCorePoint[], fbmParams: FbmParams) {\n\t\tconst simplex = this._getSimplex();\n\t\tconst useRestAttributes = isBooleanTrue(this.pv.useRestAttributes);\n\t\tconst useNormals = isBooleanTrue(this.pv.useNormals);\n\t\tconst tamplitudeAttrib = isBooleanTrue(this.pv.tamplitudeAttrib);\n\t\tconst baseAmplitude: number = this.pv.amplitude;\n\t\tconst operation = OPERATIONS[this.pv.operation];\n\t\tconst attribName = this.pv.attribName;\n\t\tfor (const destPoint of destPoints) {\n\t\t\tif (useRestAttributes) {\n\t\t\t\tdestPoint.attribValueVector3(this.pv.restP, position);\n\t\t\t\tif (useNormals) {\n\t\t\t\t\tdestPoint.attribValueVector3(this.pv.restN, normal);\n\t\t\t\t}\n\t\t\t\t_currentAttribValueF = position.x;\n\t\t\t} else {\n\t\t\t\tdestPoint.position(position);\n\t\t\t\tif (useNormals) {\n\t\t\t\t\tdestPoint.attribValueVector3(Attribute.NORMAL, normal);\n\t\t\t\t}\n\t\t\t\t_currentAttribValueF = destPoint.attribValueNumber(attribName);\n\t\t\t}\n\n\t\t\tconst amplitude = tamplitudeAttrib ? this._amplitudeFromAttrib(destPoint, baseAmplitude) : baseAmplitude;\n\n\t\t\tconst noiseResult = this._noiseValue(useNormals, simplex, amplitude, fbmParams, position, normal);\n\t\t\tconst noiseValue = noiseResult.x; //this._makeNoiseValueCorrectSize(noiseResult, targetAttribSize);\n\n\t\t\tconst newAttribValueF = NoiseSopNode._newAttribValueFromFloat(operation, _currentAttribValueF, noiseValue);\n\t\t\tdestPoint.setAttribValueFromNumber(attribName, newAttribValueF);\n\t\t}\n\t}\n\tprivate _cookForV2(destPoints: BaseCorePoint[], fbmParams: FbmParams) {\n\t\tconst simplex = this._getSimplex();\n\t\tconst useRestAttributes = isBooleanTrue(this.pv.useRestAttributes);\n\t\tconst useNormals = isBooleanTrue(this.pv.useNormals);\n\t\tconst tamplitudeAttrib = isBooleanTrue(this.pv.tamplitudeAttrib);\n\t\tconst baseAmplitude: number = this.pv.amplitude;\n\t\tconst operation = OPERATIONS[this.pv.operation];\n\t\tconst attribName = this.pv.attribName;\n\t\tfor (const destPoint of destPoints) {\n\t\t\tif (useRestAttributes) {\n\t\t\t\tdestPoint.attribValueVector3(this.pv.restP, position);\n\t\t\t\tif (useNormals) {\n\t\t\t\t\tdestPoint.attribValueVector3(this.pv.restN, normal);\n\t\t\t\t}\n\t\t\t\t_currentAttribValueV2.set(position.x, position.y);\n\t\t\t} else {\n\t\t\t\tdestPoint.position(position);\n\t\t\t\tif (useNormals) {\n\t\t\t\t\tdestPoint.attribValueVector3(Attribute.NORMAL, normal);\n\t\t\t\t}\n\t\t\t\tdestPoint.attribValueVector2(attribName, _currentAttribValueV2);\n\t\t\t}\n\n\t\t\tconst amplitude = tamplitudeAttrib ? this._amplitudeFromAttrib(destPoint, baseAmplitude) : baseAmplitude;\n\n\t\t\tconst noiseResult = this._noiseValue(useNormals, simplex, amplitude, fbmParams, position, normal);\n\t\t\t_restValue2.set(noiseResult.x, noiseResult.y);\n\t\t\tconst noiseValue = _restValue2;\n\n\t\t\tconst newAttribValueV = NoiseSopNode._newAttribValueFromVector2(\n\t\t\t\toperation,\n\t\t\t\t_currentAttribValueV2,\n\t\t\t\tnoiseValue\n\t\t\t);\n\t\t\tdestPoint.setAttribValueFromVector2(attribName, newAttribValueV);\n\t\t}\n\t}\n\tprivate _cookForV3(destPoints: BaseCorePoint[], fbmParams: FbmParams) {\n\t\tconst simplex = this._getSimplex();\n\t\tconst useRestAttributes = isBooleanTrue(this.pv.useRestAttributes);\n\t\tconst useNormals = isBooleanTrue(this.pv.useNormals);\n\t\tconst tamplitudeAttrib = isBooleanTrue(this.pv.tamplitudeAttrib);\n\t\tconst baseAmplitude: number = this.pv.amplitude;\n\t\tconst operation = OPERATIONS[this.pv.operation];\n\t\tconst attribName = this.pv.attribName;\n\t\tfor (const destPoint of destPoints) {\n\t\t\tif (useRestAttributes) {\n\t\t\t\tdestPoint.attribValueVector3(this.pv.restP, position);\n\t\t\t\tif (useNormals) {\n\t\t\t\t\tdestPoint.attribValueVector3(this.pv.restN, normal);\n\t\t\t\t}\n\t\t\t\t_currentAttribValueV3.copy(position);\n\t\t\t} else {\n\t\t\t\tdestPoint.position(position);\n\t\t\t\tif (useNormals) {\n\t\t\t\t\tdestPoint.attribValueVector3(Attribute.NORMAL, normal);\n\t\t\t\t}\n\t\t\t\tdestPoint.attribValueVector3(attribName, _currentAttribValueV3);\n\t\t\t}\n\n\t\t\tconst amplitude = tamplitudeAttrib ? this._amplitudeFromAttrib(destPoint, baseAmplitude) : baseAmplitude;\n\n\t\t\tconst noiseResult = this._noiseValue(useNormals, simplex, amplitude, fbmParams, position, normal);\n\t\t\tconst noiseValue = noiseResult; //this._makeNoiseValueCorrectSize(noiseResult, targetAttribSize);\n\n\t\t\tconst newAttribValueV = NoiseSopNode._newAttribValueFromVector3(\n\t\t\t\toperation,\n\t\t\t\t_currentAttribValueV3,\n\t\t\t\tnoiseValue\n\t\t\t);\n\t\t\tdestPoint.setAttribValueFromVector3(attribName, newAttribValueV);\n\t\t}\n\t}\n\tprivate _cookForV4(destPoints: BaseCorePoint[], fbmParams: FbmParams) {\n\t\tconst simplex = this._getSimplex();\n\t\tconst useRestAttributes = isBooleanTrue(this.pv.useRestAttributes);\n\t\tconst useNormals = isBooleanTrue(this.pv.useNormals);\n\t\tconst tamplitudeAttrib = isBooleanTrue(this.pv.tamplitudeAttrib);\n\t\tconst baseAmplitude: number = this.pv.amplitude;\n\t\tconst operation = OPERATIONS[this.pv.operation];\n\t\tconst attribName = this.pv.attribName;\n\t\tfor (const destPoint of destPoints) {\n\t\t\tif (useRestAttributes) {\n\t\t\t\tdestPoint.attribValueVector3(this.pv.restP, position);\n\t\t\t\tif (useNormals) {\n\t\t\t\t\tdestPoint.attribValueVector3(this.pv.restN, normal);\n\t\t\t\t}\n\t\t\t\t_currentAttribValueV4.set(position.x, position.y, position.z, 0);\n\t\t\t} else {\n\t\t\t\tdestPoint.position(position);\n\t\t\t\tif (useNormals) {\n\t\t\t\t\tdestPoint.attribValueVector3(Attribute.NORMAL, normal);\n\t\t\t\t}\n\t\t\t\tdestPoint.attribValueVector4(attribName, _currentAttribValueV4);\n\t\t\t}\n\n\t\t\tconst amplitude = tamplitudeAttrib ? this._amplitudeFromAttrib(destPoint, baseAmplitude) : baseAmplitude;\n\n\t\t\tconst noiseResult = this._noiseValue(useNormals, simplex, amplitude, fbmParams, position, normal);\n\t\t\t_restValue4.set(noiseResult.x, noiseResult.y, noiseResult.z, 0);\n\t\t\tconst noiseValue = _restValue4; //this._makeNoiseValueCorrectSize(noiseResult, targetAttribSize);\n\n\t\t\tconst newAttribValueV = NoiseSopNode._newAttribValueFromVector4(\n\t\t\t\toperation,\n\t\t\t\t_currentAttribValueV4,\n\t\t\t\tnoiseValue\n\t\t\t);\n\t\t\tdestPoint.setAttribValueFromVector4(attribName, newAttribValueV);\n\t\t}\n\t}\n\n\tprivate _noiseValue(\n\t\tuseNormals: boolean,\n\t\tsimplex: SimplexNoise,\n\t\tamplitude: number,\n\t\tfmbParams: FbmParams,\n\t\tposition: Vector3,\n\t\tnormal?: Vector3\n\t) {\n\t\t_restPos.copy(position).add(this.pv.offset).multiply(this.pv.freq);\n\t\t// const pos = rest_point.position(this._rest_pos)\n\t\tif (useNormals && normal) {\n\t\t\tconst noise = amplitude * this._fbm(simplex, fmbParams, _restPos.x, _restPos.y, _restPos.z);\n\t\t\t_noiseValueV.copy(normal);\n\t\t\treturn _noiseValueV.multiplyScalar(noise);\n\t\t} else {\n\t\t\t_noiseValueV.set(\n\t\t\t\tamplitude * this._fbm(simplex, fmbParams, _restPos.x + 545, _restPos.y + 125454, _restPos.z + 2142),\n\t\t\t\tamplitude * this._fbm(simplex, fmbParams, _restPos.x - 425, _restPos.y - 25746, _restPos.z + 95242),\n\t\t\t\tamplitude * this._fbm(simplex, fmbParams, _restPos.x + 765132, _restPos.y + 21, _restPos.z - 9245)\n\t\t\t);\n\t\t\treturn _noiseValueV;\n\t\t}\n\t}\n\n\tprivate static _newAttribValueFromFloat(\n\t\toperation: NoiseOperation,\n\t\tcurrent_attrib_value: number,\n\t\tnoise_value: number\n\t): number {\n\t\tswitch (operation) {\n\t\t\tcase NoiseOperation.ADD:\n\t\t\t\treturn current_attrib_value + noise_value;\n\t\t\tcase NoiseOperation.SET:\n\t\t\t\treturn noise_value;\n\t\t\tcase NoiseOperation.MULT:\n\t\t\t\treturn current_attrib_value * noise_value;\n\t\t\tcase NoiseOperation.DIVIDE:\n\t\t\t\treturn current_attrib_value / noise_value;\n\t\t\tcase NoiseOperation.SUBTRACT:\n\t\t\t\treturn current_attrib_value - noise_value;\n\t\t}\n\t\tTypeAssert.unreachable(operation);\n\t}\n\n\tprivate static _newAttribValueFromVector2(\n\t\toperation: NoiseOperation,\n\t\tcurrent_attrib_value: Vector2,\n\t\tnoise_value: Vector2\n\t): Vector2 {\n\t\tswitch (operation) {\n\t\t\tcase NoiseOperation.ADD:\n\t\t\t\treturn current_attrib_value.add(noise_value);\n\t\t\tcase NoiseOperation.SET:\n\t\t\t\treturn noise_value;\n\t\t\tcase NoiseOperation.MULT:\n\t\t\t\treturn current_attrib_value.multiply(noise_value);\n\t\t\tcase NoiseOperation.DIVIDE:\n\t\t\t\treturn current_attrib_value.divide(noise_value);\n\t\t\tcase NoiseOperation.SUBTRACT:\n\t\t\t\treturn current_attrib_value.sub(noise_value);\n\t\t}\n\t\tTypeAssert.unreachable(operation);\n\t}\n\tprivate static _newAttribValueFromVector3(\n\t\toperation: NoiseOperation,\n\t\tcurrent_attrib_value: Vector3,\n\t\tnoise_value: Vector3\n\t): Vector3 {\n\t\tswitch (operation) {\n\t\t\tcase NoiseOperation.ADD:\n\t\t\t\treturn current_attrib_value.add(noise_value);\n\t\t\tcase NoiseOperation.SET:\n\t\t\t\treturn noise_value;\n\t\t\tcase NoiseOperation.MULT:\n\t\t\t\treturn current_attrib_value.multiply(noise_value);\n\t\t\tcase NoiseOperation.DIVIDE:\n\t\t\t\treturn current_attrib_value.divide(noise_value);\n\t\t\tcase NoiseOperation.SUBTRACT:\n\t\t\t\treturn current_attrib_value.sub(noise_value);\n\t\t}\n\t\tTypeAssert.unreachable(operation);\n\t}\n\tprivate static _newAttribValueFromVector4(\n\t\toperation: NoiseOperation,\n\t\tcurrent_attrib_value: Vector4,\n\t\tnoise_value: Vector4\n\t): Vector4 {\n\t\tswitch (operation) {\n\t\t\tcase NoiseOperation.ADD:\n\t\t\t\treturn current_attrib_value.add(noise_value);\n\t\t\tcase NoiseOperation.SET:\n\t\t\t\treturn noise_value;\n\t\t\tcase NoiseOperation.MULT:\n\t\t\t\treturn current_attrib_value.multiplyScalar(noise_value.x);\n\t\t\tcase NoiseOperation.DIVIDE:\n\t\t\t\treturn current_attrib_value.divideScalar(noise_value.x);\n\t\t\tcase NoiseOperation.SUBTRACT:\n\t\t\t\treturn current_attrib_value.sub(noise_value);\n\t\t}\n\t\tTypeAssert.unreachable(operation);\n\t}\n\n\tprivate _amplitudeFromAttrib(point: BaseCorePoint, base_amplitude: number): number {\n\t\tconst attrib_value = point.attribValue(this.pv.amplitudeAttrib) as NumericAttribValue;\n\n\t\tif (CoreType.isNumber(attrib_value)) {\n\t\t\treturn attrib_value * base_amplitude;\n\t\t} else {\n\t\t\tif (attrib_value instanceof Vector2 || attrib_value instanceof Vector3 || attrib_value instanceof Vector4) {\n\t\t\t\treturn attrib_value.x * base_amplitude;\n\t\t\t}\n\t\t}\n\t\treturn 1;\n\t}\n\n\tprivate _fbm(simplex: SimplexNoise, params: FbmParams, x: number, y: number, z: number): number {\n\t\tlet value = 0.0;\n\t\tlet amplitude = 1.0;\n\t\tfor (let i = 0; i < params.octaves; i++) {\n\t\t\tvalue += amplitude * simplex.noise3d(x, y, z);\n\t\t\tx *= params.freqIncrease;\n\t\t\ty *= params.freqIncrease;\n\t\t\tz *= params.freqIncrease;\n\t\t\tamplitude *= params.ampAttenuation;\n\t\t}\n\t\treturn value;\n\t}\n\n\tprivate _getSimplex(): SimplexNoise {\n\t\tconst simplex = this._simplexBySeed.get(this.pv.seed);\n\t\tif (simplex) {\n\t\t\treturn simplex;\n\t\t} else {\n\t\t\tconst simplex = this._createSimplex();\n\t\t\tthis._simplexBySeed.set(this.pv.seed, simplex);\n\t\t\treturn simplex;\n\t\t}\n\t}\n\tprivate _createSimplex(): SimplexNoise {\n\t\tconst seed = this.pv.seed;\n\t\tconst random_generator = {\n\t\t\trandom: function () {\n\t\t\t\treturn CoreMath.randFloat(seed);\n\t\t\t},\n\t\t};\n\t\tconst simplex = new SimplexNoise(random_generator);\n\t\tthis._simplexBySeed.delete(seed);\n\t\treturn simplex;\n\t}\n}\n","/**\n * Imports an object from another geometry OBJ node.\n *\n * @remarks\n * It can still be used to keep a copy of the input geometry, in case downstream nodes were to process it without cloning.\n *\n */\nimport {TypedSopNode, BaseSopNodeType} from './_Base';\nimport {NodeContext} from '../../poly/NodeContext';\nimport {NodeParamsConfig, ParamConfig} from '../utils/params/ParamsConfig';\nimport {CoreGroup} from '../../../core/geometry/Group';\nimport {GeometryContainer} from '../../containers/Geometry';\nclass ObjectMergeSopParamsConfig extends NodeParamsConfig {\n\t/** @param which SOP node to import from */\n\tgeometry = ParamConfig.NODE_PATH('', {\n\t\tnodeSelection: {\n\t\t\tcontext: NodeContext.SOP,\n\t\t},\n\t});\n}\nconst ParamsConfig = new ObjectMergeSopParamsConfig();\n\nexport class ObjectMergeSopNode extends TypedSopNode<ObjectMergeSopParamsConfig> {\n\toverride paramsConfig = ParamsConfig;\n\tstatic override type() {\n\t\treturn 'objectMerge';\n\t}\n\n\toverride async cook(input_containers: CoreGroup[]) {\n\t\tconst geometryNode = this.pv.geometry.nodeWithContext(NodeContext.SOP, this.states.error);\n\t\tif (!geometryNode) {\n\t\t\tthis.states.error.set(`node not found at path '${this.pv.geometry}'`);\n\t\t\treturn;\n\t\t}\n\t\tconst container = await geometryNode.compute();\n\t\tthis.importInput(geometryNode as BaseSopNodeType, container);\n\t}\n\n\timportInput(geometry_node: BaseSopNodeType, container: GeometryContainer) {\n\t\tlet core_group;\n\t\t// I unfortunately need to do a clone here,\n\t\t// because if 2 objectmerge nodes import the same geometry,\n\t\t// they would try to place it under 2 different geo nodes\n\t\t// which is not possible\n\t\tif ((core_group = container.coreContentCloned()) != null) {\n\t\t\t// cannot do that until i know how to make it recook\n\t\t\t// when the obj changes\n\t\t\t// if (this._param_apply_parent_transform){\n\t\t\t// \tconst matrix = geometry_node.parent().object().matrixWorld\n\t\t\t// \tgroup.children.forEach(child=>{\n\t\t\t// \t\tconsole.log(child)\n\t\t\t// \t\tconst geometry = child.geometry\n\t\t\t// \t\tif(geometry){\n\t\t\t// \t\t\tgeometry.applyMatrix(matrix)\n\t\t\t// \t\t}\n\t\t\t// \t})\n\t\t\t// }\n\n\t\t\tthis.setCoreGroup(core_group);\n\t\t} else {\n\t\t\tthis.states.error.set('invalid target');\n\t\t}\n\t}\n}\n","/**\n * Update properties from the THREE OBJECT3D from the input\n *\n * @remarks\n * This can update properties such as name, visible, renderOrder.\n *\n */\nimport {TypedSopNode} from './_Base';\nimport {CoreGroup} from '../../../core/geometry/Group';\nimport {ObjectPropertiesSopOperation} from '../../operations/sop/ObjectProperties';\nimport {NodeParamsConfig, ParamConfig} from '../utils/params/ParamsConfig';\nimport {isBooleanTrue} from '../../../core/Type';\nimport {StringParam} from '../../params/String';\nimport {BooleanParam} from '../../params/Boolean';\nimport {IntegerParam} from '../../params/Integer';\nimport {FloatParam} from '../../params/Float';\nimport {CoreObjectType} from '../../../core/geometry/ObjectContent';\nimport {filterCoreObjectsFromCoreGroup} from '../../../core/geometry/Mask';\nimport {BaseCoreObject} from '../../../core/geometry/entities/object/BaseCoreObject';\nimport {SopType} from '../../poly/registers/nodes/types/Sop';\nconst DEFAULT = ObjectPropertiesSopOperation.DEFAULT_PARAMS;\nclass ObjectPropertiesSopParamsConfig extends NodeParamsConfig {\n\t/** @param group to assign the material to */\n\tgroup = ParamConfig.STRING(DEFAULT.group, {\n\t\tobjectMask: true,\n\t});\n\n\t/** @param toggle on to set a new name */\n\ttname = ParamConfig.BOOLEAN(DEFAULT.tname);\n\t/** @param new name */\n\tname = ParamConfig.STRING(DEFAULT.name, {\n\t\tvisibleIf: {tname: true},\n\t\tseparatorAfter: true,\n\t\texpression: {forEntities: true},\n\t});\n\n\t/** @param toggle on to set a new render order */\n\ttrenderOrder = ParamConfig.BOOLEAN(DEFAULT.trenderOrder);\n\t/** @param render order */\n\trenderOrder = ParamConfig.INTEGER(DEFAULT.renderOrder, {\n\t\tvisibleIf: {trenderOrder: true},\n\t\trange: [0, 10],\n\t\trangeLocked: [false, false],\n\t\tseparatorAfter: true,\n\t\texpression: {forEntities: true},\n\t});\n\n\t/** @param toggle on to allow to set frustrumCulled */\n\ttfrustumCulled = ParamConfig.BOOLEAN(DEFAULT.tfrustumCulled);\n\t/** @param sets frustrumCulled */\n\tfrustumCulled = ParamConfig.BOOLEAN(DEFAULT.frustumCulled, {\n\t\tvisibleIf: {tfrustumCulled: true},\n\t\tseparatorAfter: true,\n\t\texpression: {forEntities: true},\n\t});\n\n\t/** @param toggle on to allow to set matrixAutoUpdate */\n\ttmatrixAutoUpdate = ParamConfig.BOOLEAN(DEFAULT.tmatrixAutoUpdate);\n\t/** @param sets matrixAutoUpdate */\n\tmatrixAutoUpdate = ParamConfig.BOOLEAN(DEFAULT.matrixAutoUpdate, {\n\t\tvisibleIf: {tmatrixAutoUpdate: true},\n\t\tseparatorAfter: true,\n\t\texpression: {forEntities: true},\n\t});\n\n\t/** @param toggle on to allow to set visible */\n\ttvisible = ParamConfig.BOOLEAN(DEFAULT.tvisible);\n\t/** @param sets visible */\n\tvisible = ParamConfig.BOOLEAN(DEFAULT.visible, {\n\t\tvisibleIf: {tvisible: true},\n\t\tseparatorAfter: true,\n\t\texpression: {forEntities: true},\n\t});\n\n\t/** @param toggle on to allow to set castShadow */\n\ttcastShadow = ParamConfig.BOOLEAN(DEFAULT.tcastShadow);\n\t/** @param sets castShadow */\n\tcastShadow = ParamConfig.BOOLEAN(DEFAULT.castShadow, {\n\t\tvisibleIf: {tcastShadow: true},\n\t\tseparatorAfter: true,\n\t\texpression: {forEntities: true},\n\t});\n\n\t/** @param toggle on to allow to set receiveShadow */\n\ttreceiveShadow = ParamConfig.BOOLEAN(DEFAULT.treceiveShadow);\n\t/** @param sets receiveShadow */\n\treceiveShadow = ParamConfig.BOOLEAN(DEFAULT.receiveShadow, {\n\t\tvisibleIf: {treceiveShadow: true},\n\t\texpression: {forEntities: true},\n\t});\n}\nconst ParamsConfig = new ObjectPropertiesSopParamsConfig();\n\nexport class ObjectPropertiesSopNode extends TypedSopNode<ObjectPropertiesSopParamsConfig> {\n\toverride paramsConfig = ParamsConfig;\n\tstatic override type() {\n\t\treturn SopType.OBJECT_PROPERTIES;\n\t}\n\n\toverride initializeNode() {\n\t\tthis.io.inputs.setCount(1);\n\t\tthis.io.inputs.initInputsClonedState(ObjectPropertiesSopOperation.INPUT_CLONED_STATE);\n\t}\n\n\tprivate _operation: ObjectPropertiesSopOperation | undefined;\n\toverride async cook(inputCoreGroups: CoreGroup[]) {\n\t\tthis._operation = this._operation || new ObjectPropertiesSopOperation(this.scene(), this.states, this);\n\n\t\t// first check that any param has an expression\n\t\tconst paramWithExpression = this.params.all.find((param) => param.hasExpression());\n\t\tif (paramWithExpression) {\n\t\t\tconst coreGroup = inputCoreGroups[0];\n\t\t\tawait this._cookWithExpressions(coreGroup);\n\t\t\tthis.setCoreGroup(coreGroup);\n\t\t} else {\n\t\t\tconst coreGroup = this._operation.cook(inputCoreGroups, this.pv);\n\t\t\tthis.setCoreGroup(coreGroup);\n\t\t}\n\t}\n\tprivate async _cookWithExpressions(coreGroup: CoreGroup) {\n\t\tconst selectedCoreObjects = filterCoreObjectsFromCoreGroup(coreGroup, this.pv);\n\t\tawait this._cookWithExpressionsForCoreObjects(selectedCoreObjects);\n\t}\n\tprivate async _cookWithExpressionsForCoreObjects<T extends CoreObjectType>(entities: BaseCoreObject<T>[]) {\n\t\tconst p = this.p;\n\n\t\tasync function applyStringParam(booleanParam: BooleanParam, valueParam: StringParam, property: 'name') {\n\t\t\tif (isBooleanTrue(booleanParam.value)) {\n\t\t\t\tif (valueParam.expressionController && valueParam.expressionController.entitiesDependent()) {\n\t\t\t\t\tawait valueParam.expressionController.computeExpressionForObjects(\n\t\t\t\t\t\tentities,\n\t\t\t\t\t\t(entity, value: string) => {\n\t\t\t\t\t\t\tentity.object()[property] = value;\n\t\t\t\t\t\t}\n\t\t\t\t\t);\n\t\t\t\t} else {\n\t\t\t\t\tfor (const entity of entities) {\n\t\t\t\t\t\tconst object = entity.object();\n\t\t\t\t\t\tif (object) {\n\t\t\t\t\t\t\tobject[property] = valueParam.value;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tasync function applyNumberParam(\n\t\t\tbooleanParam: BooleanParam,\n\t\t\tvalueParam: IntegerParam | FloatParam,\n\t\t\tproperty: 'renderOrder'\n\t\t) {\n\t\t\tif (isBooleanTrue(booleanParam.value)) {\n\t\t\t\tif (valueParam.expressionController && valueParam.expressionController.entitiesDependent()) {\n\t\t\t\t\tawait valueParam.expressionController.computeExpressionForObjects(\n\t\t\t\t\t\tentities,\n\t\t\t\t\t\t(entity, value: number) => {\n\t\t\t\t\t\t\tentity.object()[property] = value;\n\t\t\t\t\t\t}\n\t\t\t\t\t);\n\t\t\t\t} else {\n\t\t\t\t\tfor (const entity of entities) {\n\t\t\t\t\t\tconst object = entity.object();\n\t\t\t\t\t\tif (object) {\n\t\t\t\t\t\t\tobject[property] = valueParam.value;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tasync function applyBooleanParam(\n\t\t\tbooleanParam: BooleanParam,\n\t\t\tvalueParam: BooleanParam,\n\t\t\tproperty: 'frustumCulled' | 'matrixAutoUpdate' | 'visible' | 'castShadow' | 'receiveShadow'\n\t\t) {\n\t\t\tif (isBooleanTrue(booleanParam.value)) {\n\t\t\t\tif (valueParam.expressionController && valueParam.expressionController.entitiesDependent()) {\n\t\t\t\t\tawait valueParam.expressionController.computeExpressionForObjects(\n\t\t\t\t\t\tentities,\n\t\t\t\t\t\t(entity, value: boolean) => {\n\t\t\t\t\t\t\tentity.object()[property] = value;\n\t\t\t\t\t\t}\n\t\t\t\t\t);\n\t\t\t\t} else {\n\t\t\t\t\tfor (const entity of entities) {\n\t\t\t\t\t\tconst object = entity.object();\n\t\t\t\t\t\tif (object) {\n\t\t\t\t\t\t\tobject[property] = valueParam.value;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tawait Promise.all([\n\t\t\tapplyStringParam(p.tname, p.name, 'name'),\n\t\t\tapplyNumberParam(p.trenderOrder, p.renderOrder, 'renderOrder'),\n\t\t\tapplyBooleanParam(p.tfrustumCulled, p.frustumCulled, 'frustumCulled'),\n\t\t\tapplyBooleanParam(p.tmatrixAutoUpdate, p.matrixAutoUpdate, 'matrixAutoUpdate'),\n\t\t\tapplyBooleanParam(p.tvisible, p.visible, 'visible'),\n\t\t\tapplyBooleanParam(p.tcastShadow, p.castShadow, 'castShadow'),\n\t\t\tapplyBooleanParam(p.treceiveShadow, p.receiveShadow, 'receiveShadow'),\n\t\t]);\n\t}\n}\n","/**\n * places input objects in a grid pattern.\n *\n *\n *\n */\nimport {TypedSopNode} from './_Base';\nimport {CoreGroup} from '../../../core/geometry/Group';\nimport {ObjectsLayoutSopOperation} from '../../operations/sop/ObjectsLayout';\nimport {NodeParamsConfig, ParamConfig} from '../utils/params/ParamsConfig';\nimport {SopType} from '../../poly/registers/nodes/types/Sop';\nconst DEFAULT = ObjectsLayoutSopOperation.DEFAULT_PARAMS;\nclass ObjectsLayoutSopParamConfig extends NodeParamsConfig {\n\t/** @param layout width */\n\tmaxLayoutWidth = ParamConfig.FLOAT(DEFAULT.maxLayoutWidth, {range: [0, 10]});\n\t/** @param row height */\n\trowHeight = ParamConfig.FLOAT(DEFAULT.rowHeight, {range: [0, 10]});\n\t/** @param padding between objects */\n\tpadding = ParamConfig.VECTOR2(DEFAULT.padding.toArray());\n\n\t/** @param addAttribs */\n\taddAttribs = ParamConfig.BOOLEAN(DEFAULT.addAttribs);\n\t/** @param add row index attribute */\n\taddRowAttrib = ParamConfig.BOOLEAN(DEFAULT.addRowAttrib, {\n\t\tvisibleIf: {addAttribs: 1},\n\t});\n\t/** @param add rowWidthInner attribute */\n\taddRowWidthInner = ParamConfig.BOOLEAN(DEFAULT.addRowWidthInner, {\n\t\tvisibleIf: {addAttribs: 1},\n\t});\n\t/** @param add rowWidthOuter attribute */\n\taddRowWidthOuter = ParamConfig.BOOLEAN(DEFAULT.addRowWidthOuter, {\n\t\tvisibleIf: {addAttribs: 1},\n\t});\n}\nconst ParamsConfig = new ObjectsLayoutSopParamConfig();\n\nexport class ObjectsLayoutSopNode extends TypedSopNode<ObjectsLayoutSopParamConfig> {\n\toverride paramsConfig = ParamsConfig;\n\tstatic override type() {\n\t\treturn SopType.OBJECTS_LAYOUT;\n\t}\n\n\toverride initializeNode() {\n\t\tthis.io.inputs.setCount(1);\n\t\tthis.io.inputs.initInputsClonedState(ObjectsLayoutSopOperation.INPUT_CLONED_STATE);\n\t}\n\n\tprivate _operation: ObjectsLayoutSopOperation | undefined;\n\toverride cook(inputCoreGroups: CoreGroup[]) {\n\t\tthis._operation = this._operation || new ObjectsLayoutSopOperation(this.scene(), this.states, this);\n\t\tconst coreGroup = this._operation.cook(inputCoreGroups, this.pv);\n\t\tthis.setCoreGroup(coreGroup);\n\t}\n}\n","/**\n * Creates an orthographic camera.\n *\n *\n */\n\nimport {TypedSopNode} from './_Base';\nimport {CoreGroup} from '../../../core/geometry/Group';\nimport {OrthographicCameraSopOperation} from '../../operations/sop/OrthographicCamera';\n\nimport {NodeParamsConfig, ParamConfig} from '../utils/params/ParamsConfig';\nimport {CameraNodeType} from '../../poly/NodeContext';\nimport {registerOrthographicCamera} from '../../../core/camera/CoreOrthographicCamera';\nimport {BaseNodeType} from '../_Base';\nimport {updateCameraTransformParams} from './utils/camera/updateCameraTransformParams';\nimport {OnNodeRegisterCallback} from '../../poly/registers/nodes/NodesRegister';\nconst DEFAULT = OrthographicCameraSopOperation.DEFAULT_PARAMS;\nclass OrthographicCameraSopParamsConfig extends NodeParamsConfig {\n\t/** @param camera view size */\n\tsize = ParamConfig.FLOAT(DEFAULT.size, {\n\t\trange: [0.001, 2],\n\t\trangeLocked: [true, false],\n\t});\n\t/** @param camera near */\n\tnear = ParamConfig.FLOAT(DEFAULT.near, {\n\t\trange: [0, 100],\n\t\trangeLocked: [true, false],\n\t});\n\t/** @param camera far */\n\tfar = ParamConfig.FLOAT(DEFAULT.far, {\n\t\trange: [0, 100],\n\t\trangeLocked: [true, false],\n\t});\n\t/** @param camera position */\n\tposition = ParamConfig.VECTOR3(DEFAULT.position);\n\t/** @param camera rotation */\n\trotation = ParamConfig.VECTOR3(DEFAULT.rotation);\n\t/** @param show helper */\n\tshowHelper = ParamConfig.BOOLEAN(DEFAULT.showHelper);\n\t/** @param matrixAutoUpdate */\n\tmatrixAutoUpdate = ParamConfig.BOOLEAN(DEFAULT.matrixAutoUpdate);\n\t/** @param camera name */\n\tname = ParamConfig.STRING('`$OS`');\n\t/** @param set main camera */\n\tupdateTransformFromCamera = ParamConfig.BUTTON(null, {\n\t\tcallback: (node: BaseNodeType) => {\n\t\t\tupdateCameraTransformParams(node as OrthographicCameraSopNode);\n\t\t},\n\t});\n}\nconst ParamsConfig = new OrthographicCameraSopParamsConfig();\n\nexport class OrthographicCameraSopNode extends TypedSopNode<OrthographicCameraSopParamsConfig> {\n\toverride readonly paramsConfig = ParamsConfig;\n\tstatic override type() {\n\t\treturn CameraNodeType.ORTHOGRAPHIC;\n\t}\n\tstatic override onRegister: OnNodeRegisterCallback = registerOrthographicCamera;\n\n\tprotected override initializeNode() {\n\t\tthis.io.inputs.setCount(0);\n\t}\n\n\tprivate _operation: OrthographicCameraSopOperation | undefined;\n\toverride cook(inputCoreGroups: CoreGroup[]) {\n\t\tthis._operation = this._operation || new OrthographicCameraSopOperation(this._scene, this.states, this);\n\t\tconst coreGroup = this._operation.cook(inputCoreGroups, this.pv);\n\t\tthis.setCoreGroup(coreGroup);\n\t}\n}\n","/**\n * Loads a palette and sets the value of each input point to one of the colors.\n *\n * @remarks\n * This is using [https://github.com/kgolid/chromotome#readme](https://github.com/kgolid/chromotome#readme)\n *\n */\nimport {TypedSopNode} from './_Base';\nimport {CoreGroup} from '../../../core/geometry/Group';\nimport {PaletteSopOperation} from '../../operations/sop/Palette';\nimport {NodeParamsConfig, ParamConfig} from '../utils/params/ParamsConfig';\nimport {\n\tSORTED_PALETTE_NAMES,\n\tMAX_PALETTE_COLORS_COUNT,\n\tvisibleIfColorsCountAtLeast,\n} from '../../../core/color/chromotomeWrapper';\nimport {Number3} from '../../../types/GlobalTypes';\n// import {ColorConversion} from '../../../core/Color';\nimport {PaletteController, paletteControllerCallbackOptions} from '../utils/color/PaletteController';\nimport {NodeContext} from '../../poly/NodeContext';\nimport {\n\tAttribClass,\n\tAttribClassMenuEntriesWithoutCoreGroup,\n\tATTRIBUTE_CLASSES_WITHOUT_CORE_GROUP,\n} from '../../../core/geometry/Constant';\nimport {SopType} from '../../poly/registers/nodes/types/Sop';\n\nconst DEFAULT = PaletteSopOperation.DEFAULT_PARAMS;\n\nclass PaletteSopParamsConfig extends NodeParamsConfig {\n\t/** @param the attribute class (geometry or object) */\n\tclass = ParamConfig.INTEGER(DEFAULT.class, {\n\t\tmenu: {\n\t\t\tentries: AttribClassMenuEntriesWithoutCoreGroup,\n\t\t},\n\t});\n\t/** @param name of the palette */\n\tpaletteName = ParamConfig.STRING(DEFAULT.paletteName, {\n\t\tmenuString: {\n\t\t\tentries: SORTED_PALETTE_NAMES.map((name, value) => {\n\t\t\t\treturn {name: name, value: name};\n\t\t\t}),\n\t\t},\n\t\t...paletteControllerCallbackOptions(PaletteController.PARAM_CALLBACK_updateColors),\n\t});\n\t/** @param click to set the node to the next palette */\n\tpickNext = ParamConfig.BUTTON(null, paletteControllerCallbackOptions(PaletteController.PARAM_CALLBACK_pickNext));\n\t/** @param click to set the node to the previous palette */\n\tpickPrevious = ParamConfig.BUTTON(\n\t\tnull,\n\t\tpaletteControllerCallbackOptions(PaletteController.PARAM_CALLBACK_pickPrevious)\n\t);\n\t/** @param click to set the node to a random palette */\n\tpickRandom = ParamConfig.BUTTON(\n\t\tnull,\n\t\tpaletteControllerCallbackOptions(PaletteController.PARAM_CALLBACK_pickRandom)\n\t);\n\tcolorsCount = ParamConfig.INTEGER(DEFAULT.colorsCount, {\n\t\thidden: true,\n\t\trange: [0, MAX_PALETTE_COLORS_COUNT],\n\t\tseparatorAfter: true,\n\t});\n\t/** @param palette color 1 */\n\tcolor1 = ParamConfig.COLOR(DEFAULT.color1.toArray() as Number3, {\n\t\tvisibleIf: visibleIfColorsCountAtLeast(1),\n\t\t// conversion: ColorConversion.SRGB_TO_LINEAR,\n\t});\n\t/** @param palette color 2 */\n\tcolor2 = ParamConfig.COLOR(DEFAULT.color2.toArray() as Number3, {\n\t\tvisibleIf: visibleIfColorsCountAtLeast(2),\n\t\t// conversion: ColorConversion.SRGB_TO_LINEAR,\n\t});\n\t/** @param palette color 3 */\n\tcolor3 = ParamConfig.COLOR(DEFAULT.color3.toArray() as Number3, {\n\t\tvisibleIf: visibleIfColorsCountAtLeast(3),\n\t\t// conversion: ColorConversion.SRGB_TO_LINEAR,\n\t});\n\t/** @param palette color 4 */\n\tcolor4 = ParamConfig.COLOR(DEFAULT.color4.toArray() as Number3, {\n\t\tvisibleIf: visibleIfColorsCountAtLeast(4),\n\t\t// conversion: ColorConversion.SRGB_TO_LINEAR,\n\t});\n\t/** @param palette color 5 */\n\tcolor5 = ParamConfig.COLOR(DEFAULT.color5.toArray() as Number3, {\n\t\tvisibleIf: visibleIfColorsCountAtLeast(5),\n\t\t// conversion: ColorConversion.SRGB_TO_LINEAR,\n\t});\n}\nconst ParamsConfig = new PaletteSopParamsConfig();\n\nexport class PaletteSopNode extends TypedSopNode<PaletteSopParamsConfig> {\n\toverride paramsConfig = ParamsConfig;\n\tstatic override type() {\n\t\treturn SopType.PALETTE;\n\t}\n\tpublic readonly paletteController: PaletteController<NodeContext.SOP> = new PaletteController<NodeContext.SOP>(\n\t\tthis\n\t);\n\toverride initializeNode() {\n\t\tthis.io.inputs.setCount(1);\n\t\tthis.io.inputs.initInputsClonedState(PaletteSopOperation.INPUT_CLONED_STATE);\n\n\t\tthis.params.onParamsCreated('palette_init', () => {\n\t\t\tPaletteController.PARAM_CALLBACK_updateColors(this);\n\t\t});\n\t}\n\n\tprivate _operation: PaletteSopOperation | undefined;\n\toverride cook(input_contents: CoreGroup[]) {\n\t\tthis._operation = this._operation || new PaletteSopOperation(this._scene, this.states, this);\n\t\tconst core_group = this._operation.cook(input_contents, this.pv);\n\t\tthis.setCoreGroup(core_group);\n\t}\n\t//\n\t//\n\t// API UTILS\n\t//\n\t//\n\tsetAttribClass(attribClass: AttribClass) {\n\t\tthis.p.class.set(ATTRIBUTE_CLASSES_WITHOUT_CORE_GROUP.indexOf(attribClass));\n\t}\n\tattribClass() {\n\t\treturn ATTRIBUTE_CLASSES_WITHOUT_CORE_GROUP[this.pv.class];\n\t}\n}\n","/**\n * Creates a perspective camera.\n *\n *\n */\n\nimport {TypedSopNode} from './_Base';\nimport {CoreGroup} from '../../../core/geometry/Group';\nimport {PerspectiveCameraSopOperation} from '../../operations/sop/PerspectiveCamera';\n\nimport {NodeParamsConfig, ParamConfig} from '../utils/params/ParamsConfig';\nimport {CameraNodeType} from '../../poly/NodeContext';\nimport {PERSPECTIVE_CAMERA_DEFAULT, registerPerspectiveCamera} from '../../../core/camera/CorePerspectiveCamera';\nimport {BaseNodeType} from '../_Base';\nimport {updateCameraTransformParams} from './utils/camera/updateCameraTransformParams';\nimport {OnNodeRegisterCallback} from '../../poly/registers/nodes/NodesRegister';\nconst DEFAULT = PerspectiveCameraSopOperation.DEFAULT_PARAMS;\nclass PerspectiveCameraSopParamsConfig extends NodeParamsConfig {\n\tdefault = ParamConfig.FOLDER();\n\t/** @param camera fov */\n\tfov = ParamConfig.FLOAT(DEFAULT.fov, {\n\t\trange: PERSPECTIVE_CAMERA_DEFAULT.fovRange,\n\t\trangeLocked: [true, false],\n\t});\n\t/** @param camera near */\n\tnear = ParamConfig.FLOAT(DEFAULT.near, {\n\t\trange: [0, 100],\n\t\trangeLocked: [true, false],\n\t});\n\t/** @param camera far */\n\tfar = ParamConfig.FLOAT(DEFAULT.far, {\n\t\trange: [0, 100],\n\t\trangeLocked: [true, false],\n\t});\n\t/** @param camera position */\n\tposition = ParamConfig.VECTOR3(DEFAULT.position);\n\t/** @param camera rotation */\n\trotation = ParamConfig.VECTOR3(DEFAULT.rotation);\n\t/** @param show helper */\n\tshowHelper = ParamConfig.BOOLEAN(DEFAULT.showHelper);\n\t/** @param matrixAutoUpdate */\n\tmatrixAutoUpdate = ParamConfig.BOOLEAN(DEFAULT.matrixAutoUpdate);\n\t/** @param camera name */\n\tname = ParamConfig.STRING('`$OS`');\n\t/** @param set main camera */\n\tupdateTransformFromCamera = ParamConfig.BUTTON(null, {\n\t\tcallback: (node: BaseNodeType) => {\n\t\t\tupdateCameraTransformParams(node as PerspectiveCameraSopNode);\n\t\t},\n\t});\n\tPBR = ParamConfig.FOLDER();\n\t/** @param apertureBlades */\n\tapertureBlades = ParamConfig.INTEGER(6, {\n\t\trange: [0, 10],\n\t\trangeLocked: [true, false],\n\t});\n\t/** @param apertureBlades */\n\tfStop = ParamConfig.FLOAT(0.5, {\n\t\trange: [0.02, 20],\n\t\trangeLocked: [true, false],\n\t});\n\t/** @param focusDistance */\n\tfocusDistance = ParamConfig.FLOAT(10, {\n\t\trange: [0, 100],\n\t\trangeLocked: [true, false],\n\t});\n\t/** @param apertureRotation */\n\tapertureRotation = ParamConfig.FLOAT(0, {\n\t\trange: [0, 12.5],\n\t\trangeLocked: [true, false],\n\t});\n\t/** @param anamorphicRatio */\n\tanamorphicRatio = ParamConfig.FLOAT(1, {\n\t\trange: [0.1, 10],\n\t\trangeLocked: [true, false],\n\t});\n}\n\nconst ParamsConfig = new PerspectiveCameraSopParamsConfig();\n\nexport class PerspectiveCameraSopNode extends TypedSopNode<PerspectiveCameraSopParamsConfig> {\n\toverride readonly paramsConfig = ParamsConfig;\n\tstatic override type() {\n\t\treturn CameraNodeType.PERSPECTIVE;\n\t}\n\tstatic override onRegister: OnNodeRegisterCallback = registerPerspectiveCamera;\n\n\tprotected override initializeNode() {\n\t\tthis.io.inputs.setCount(0);\n\t}\n\n\tprivate _operation: PerspectiveCameraSopOperation | undefined;\n\toverride cook(inputCoreGroups: CoreGroup[]) {\n\t\tthis._operation = this._operation || new PerspectiveCameraSopOperation(this._scene, this.states, this);\n\t\tconst coreGroup = this._operation.cook(inputCoreGroups, this.pv);\n\t\tthis.setCoreGroup(coreGroup);\n\t}\n}\n","/**\n * Create a physics ground\n *\n *\n */\nimport {CoreTransform} from './../../../core/Transform';\nimport {ObjectType} from './../../../core/geometry/Constant';\nimport {BoxGeometry, Vector3} from 'three';\nimport {CorePhysicsAttribute, PhysicsRBDColliderType, PhysicsRBDType} from './../../../core/physics/PhysicsAttribute';\nimport {TypedSopNode} from './_Base';\nimport {NodeParamsConfig, ParamConfig} from '../utils/params/ParamsConfig';\nimport {BaseSopOperation} from '../../operations/sop/_Base';\nimport {SopType} from '../../poly/registers/nodes/types/Sop';\n\nconst DEFAULT_UP = new Vector3(0, 1, 0);\nconst tmp = new Vector3(0, 0, 0);\n\nclass PhysicsGroundSopParamsConfig extends NodeParamsConfig {\n\t/** @param size */\n\tsize = ParamConfig.VECTOR2([10, 10]);\n\t/** @param center */\n\tcenter = ParamConfig.VECTOR2([0, 0]);\n\t/** @param height */\n\theight = ParamConfig.FLOAT(0, {\n\t\trange: [-1, 1],\n\t\trangeLocked: [false, false],\n\t});\n\t/** @param direction */\n\tdirection = ParamConfig.VECTOR3([0, 1, 0]);\n\t/** @param thickness */\n\tthickness = ParamConfig.FLOAT(1, {\n\t\trange: [0, 1],\n\t\trangeLocked: [true, false],\n\t});\n\t/** @param friction */\n\tfriction = ParamConfig.FLOAT(0.5, {\n\t\tseparatorBefore: true,\n\t\trange: [0, 1],\n\t\trangeLocked: [true, false],\n\t});\n\t/** @param restitution */\n\trestitution = ParamConfig.FLOAT(0.5, {\n\t\trange: [0, 1],\n\t\trangeLocked: [true, false],\n\t});\n}\nconst ParamsConfig = new PhysicsGroundSopParamsConfig();\n\nexport class PhysicsGroundSopNode extends TypedSopNode<PhysicsGroundSopParamsConfig> {\n\toverride readonly paramsConfig = ParamsConfig;\n\tstatic override type() {\n\t\treturn SopType.PHYSICS_GROUND;\n\t}\n\n\tprotected override initializeNode() {\n\t\tthis.io.inputs.setCount(0);\n\t}\n\n\toverride cook() {\n\t\tconst thickness = this.pv.thickness;\n\t\tconst object = BaseSopOperation.createObject(\n\t\t\tnew BoxGeometry(this.pv.size.x, thickness, this.pv.size.y),\n\t\t\tObjectType.MESH\n\t\t);\n\t\t// object.matrixAutoUpdate = false;\n\t\t// object.lookAt(this.pv.direction);\n\t\t// object.updateMatrix();\n\t\tCoreTransform.rotateObject(object, DEFAULT_UP, this.pv.direction);\n\t\ttmp.copy(this.pv.direction)\n\t\t\t.normalize()\n\t\t\t.multiplyScalar(-0.5 * this.pv.thickness + this.pv.height);\n\t\tobject.position.copy(tmp);\n\t\tobject.translateX(this.pv.center.x);\n\t\tobject.translateZ(this.pv.center.y);\n\t\tobject.updateMatrix();\n\t\tobject.name = this.name();\n\n\t\tCorePhysicsAttribute.setRBDType(object, PhysicsRBDType.FIXED);\n\t\tCorePhysicsAttribute.setColliderType(object, PhysicsRBDColliderType.CUBOID);\n\t\tCorePhysicsAttribute.setDensity(object, 0);\n\t\tCorePhysicsAttribute.setFriction(object, this.pv.friction);\n\t\tCorePhysicsAttribute.setRestitution(object, this.pv.restitution);\n\t\tCorePhysicsAttribute.setCuboidSizes(object, new Vector3(this.pv.size.x, this.pv.thickness, this.pv.size.y));\n\t\tCorePhysicsAttribute.setCuboidSize(object, 1);\n\n\t\tthis.setObject(object);\n\t}\n}\n","/**\n * Create a physics player\n *\n *\n */\n\nimport {CoreGroup} from '../../../core/geometry/Group';\nimport {NodeParamsConfig, ParamConfig} from '../utils/params/ParamsConfig';\nimport {InputCloneMode} from '../../poly/InputCloneMode';\nimport {SopType} from '../../poly/registers/nodes/types/Sop';\nimport {CorePhysicsAttribute, PhysicsRBDColliderType, PhysicsRBDType} from '../../../core/physics/PhysicsAttribute';\nimport {PhysicsPlayerType} from '../../../core/physics/player/PhysicsPlayer';\nimport {SphereBuilder} from '../../../core/geometry/builders/SphereBuilder';\nimport {ObjectType} from '../../../core/geometry/Constant';\nimport {CorePath} from '../../../core/geometry/CorePath';\nimport {BaseSopOperation} from '../../operations/sop/_Base';\nimport {Vector3, Object3D} from 'three';\nimport {TypedActorSopNode} from './_BaseActor';\n\n// Note that the default used for torque player\n// are different than the ones used for PhysicsRBDAttributes\nconst DEFAULT = {\n\tradius: 0.5,\n\tdensity: 5, //1000,\n\tfriction: 1, //0.5,\n\trestitution: 0.5,\n\tlinearDamping: 0.4, //0,\n\tangularDamping: 10,\n\tlinearVelocity: new Vector3(0, 0, 0),\n\tangularVelocity: new Vector3(0, 0, 0),\n\tgravityScale: 1,\n};\nconst type = PhysicsPlayerType.TORQUE;\n\nclass PhysicsPlayerSopParamsConfig extends NodeParamsConfig {\n\tmain = ParamConfig.FOLDER();\n\t/** @param radius */\n\tradius = ParamConfig.FLOAT(0.5, {\n\t\trange: [0, 2],\n\t\trangeLocked: [true, false],\n\t});\n\n\t/** @param density */\n\tdensity = ParamConfig.FLOAT(DEFAULT.density, {\n\t\trange: [0, 100],\n\t\trangeLocked: [true, false],\n\t\tseparatorBefore: true,\n\t});\n\t/** @param friction */\n\tfriction = ParamConfig.FLOAT(DEFAULT.friction, {\n\t\trange: [0, 1],\n\t\trangeLocked: [true, false],\n\t});\n\t/** @param restitution */\n\trestitution = ParamConfig.FLOAT(DEFAULT.restitution, {\n\t\trange: [0, 2],\n\t\trangeLocked: [true, false],\n\t});\n\t/** @param linear damping (affects velocity) */\n\tlinearDamping = ParamConfig.FLOAT(DEFAULT.linearDamping, {\n\t\trange: [0, 10],\n\t\trangeLocked: [true, false],\n\t});\n\t/** @param angular damping (affects rotations) */\n\tangularDamping = ParamConfig.FLOAT(DEFAULT.angularDamping, {\n\t\trange: [0, 10],\n\t\trangeLocked: [true, false],\n\t});\n\t/** @param linear velocity */\n\tlinearVelocity = ParamConfig.VECTOR3(DEFAULT.linearVelocity);\n\t/** @param angular velocity */\n\tangularVelocity = ParamConfig.VECTOR3(DEFAULT.angularVelocity);\n\t/** @param gravity Scale */\n\tgravityScale = ParamConfig.FLOAT(DEFAULT.gravityScale, {\n\t\trange: [-10, 10],\n\t\trangeLocked: [false, false],\n\t});\n\n\tdetails = ParamConfig.FOLDER();\n\t/** @param id */\n\tid = ParamConfig.STRING('`$OS`');\n\n\t/** @param collision offset */\n\t// offset = ParamConfig.FLOAT(0.02, {\n\t// \trange: [0, 0.1],\n\t// \trangeLocked: [true, false],\n\t// });\n\t// /** @param apply impulses */\n\t// applyImpulses = ParamConfig.BOOLEAN(1);\n\t// /** @param distance below which the player will be snapped to the ground */\n\t// snapToGroundDistance = ParamConfig.FLOAT(0.5, {\n\t// \trange: [0, 1],\n\t// \trangeLocked: [true, false],\n\t// });\n\t// /** @param auto step */\n\t// autoStep = ParamConfig.BOOLEAN(1, {\n\t// \tseparatorBefore: true,\n\t// });\n\t// /** @param auto step max height */\n\t// autoStepMaxHeight = ParamConfig.FLOAT(0.5, {\n\t// \trange: [0, 1],\n\t// \trangeLocked: [true, false],\n\t// \tvisibleIf: {autoStep: 1},\n\t// });\n\t// /** @param auto step max height */\n\t// autoStepMinWidth = ParamConfig.FLOAT(0.5, {\n\t// \trange: [0, 1],\n\t// \trangeLocked: [true, false],\n\t// \tvisibleIf: {autoStep: 1},\n\t// });\n\t// /** @param auto step on dynamic objects */\n\t// autoStepOnDynamic = ParamConfig.BOOLEAN(1, {\n\t// \tvisibleIf: {autoStep: 1},\n\t// });\n\t// /** @param Dont allow climbing slopes larger than this angle */\n\t// maxSlopeClimbAngle = ParamConfig.FLOAT(45, {\n\t// \tseparatorBefore: true,\n\t// \trange: [0, 90],\n\t// \trangeLocked: [true, true],\n\t// });\n\t// /** @param Automatically slide down on slopes smaller than this angle */\n\t// minSlopeSlideAngle = ParamConfig.FLOAT(30, {\n\t// \trange: [0, 90],\n\t// \trangeLocked: [true, true],\n\t// });\n\t// /** @param up vector used in slope angle calculations */\n\t// up = ParamConfig.VECTOR3([0, 1, 0]);\n}\nconst ParamsConfig = new PhysicsPlayerSopParamsConfig();\n\nexport class PhysicsPlayerSopNode extends TypedActorSopNode<PhysicsPlayerSopParamsConfig> {\n\toverride readonly paramsConfig = ParamsConfig;\n\tstatic override type(): SopType.PHYSICS_PLAYER {\n\t\treturn SopType.PHYSICS_PLAYER;\n\t}\n\n\tprotected override initializeNode() {\n\t\tthis.io.inputs.setCount(0, 2);\n\t\tthis.io.inputs.initInputsClonedState(InputCloneMode.FROM_NODE);\n\t}\n\n\toverride cook(inputCoreGroups: CoreGroup[]) {\n\t\tthis.compilationController.compileIfRequired();\n\t\tconst coreGroup0 = inputCoreGroups[0];\n\t\tconst coreGroup1 = inputCoreGroups[1];\n\t\tconst inputObjects = coreGroup0 ? coreGroup0.threejsObjects() : this._createDefaultInputObjects();\n\t\tconst playerObject = inputObjects[0];\n\t\tthis._updatePlayerObject(playerObject);\n\t\tconst objects = [playerObject];\n\n\t\tif (coreGroup1) {\n\t\t\tconst cameraObject = coreGroup1.threejsObjects()[0];\n\t\t\tif (cameraObject) {\n\t\t\t\tobjects.push(cameraObject);\n\t\t\t\tconst cameraPath = CorePath.objectPath(cameraObject);\n\t\t\t\tCorePhysicsAttribute.setCharacterControllerCameraPath(playerObject, cameraPath);\n\t\t\t}\n\t\t}\n\n\t\tthis.setObjects(objects);\n\t}\n\tprivate _updatePlayerObject(object: Object3D) {\n\t\tconst actorNode = this._findActorNode();\n\n\t\t// for (let object of inputObjects) {\n\t\t// actor\n\t\tthis.scene().actorsManager.assignActorBuilder(object, actorNode);\n\t\t// force rbd type\n\t\tCorePhysicsAttribute.setRBDType(\n\t\t\tobject,\n\t\t\ttype == PhysicsPlayerType.TORQUE ? PhysicsRBDType.DYNAMIC : PhysicsRBDType.KINEMATIC_POS\n\t\t);\n\t\t// collider\n\t\tCorePhysicsAttribute.setColliderType(object, PhysicsRBDColliderType.SPHERE);\n\t\tCorePhysicsAttribute.setRadius(object, this.pv.radius);\n\n\t\t// id\n\t\tconst rbdId = this.pv.id;\n\t\tobject.name = rbdId;\n\t\tCorePhysicsAttribute.setRBDId(object, rbdId);\n\n\t\t// set character controller id to rbd id\n\t\t// const rbdId = CorePhysicsAttribute.getRBDId(object);\n\n\t\t//\n\t\tCorePhysicsAttribute.setCharacterControllerId(object, rbdId);\n\n\t\t//\n\t\tCorePhysicsAttribute.setDensity(object, this.pv.density);\n\t\tCorePhysicsAttribute.setFriction(object, this.pv.friction);\n\t\tCorePhysicsAttribute.setRestitution(object, this.pv.restitution);\n\t\tCorePhysicsAttribute.setLinearDamping(object, this.pv.linearDamping);\n\t\tCorePhysicsAttribute.setAngularDamping(object, this.pv.angularDamping);\n\t\tCorePhysicsAttribute.setLinearVelocity(object, this.pv.linearVelocity);\n\t\tCorePhysicsAttribute.setAngularVelocity(object, this.pv.angularVelocity);\n\t\tCorePhysicsAttribute.setGravityScale(object, this.pv.gravityScale);\n\n\t\t//\n\t\t// CorePhysicsAttribute.setCharacterControllerOffset(object, this.pv.offset);\n\t\t// CorePhysicsAttribute.setCharacterControllerApplyImpulsesToDynamic(object, this.pv.applyImpulses);\n\t\t// CorePhysicsAttribute.setCharacterControllerSnapToGroundDistance(object, this.pv.snapToGroundDistance);\n\t\t// // auto step\n\t\t// if (isBooleanTrue(this.pv.autoStep)) {\n\t\t// \tCorePhysicsAttribute.setCharacterControllerAutoStepMaxHeight(object, this.pv.autoStepMaxHeight);\n\t\t// \tCorePhysicsAttribute.setCharacterControllerAutoStepMinWidth(object, this.pv.autoStepMinWidth);\n\t\t// \tCorePhysicsAttribute.setCharacterControllerAutoStepOnDynamic(object, this.pv.autoStepOnDynamic);\n\t\t// }\n\t\t// // slopes\n\t\t// CorePhysicsAttribute.setCharacterControllerMaxSlopeClimbAngle(object, this.pv.maxSlopeClimbAngle);\n\t\t// CorePhysicsAttribute.setCharacterControllerMinSlopeSlideAngle(object, this.pv.minSlopeSlideAngle);\n\t\t// CorePhysicsAttribute.setCharacterControllerUp(object, this.pv.up);\n\t\t// }\n\t}\n\n\tprivate _createDefaultInputObjects() {\n\t\tconst geometry = SphereBuilder.create({\n\t\t\tradius: this.pv.radius,\n\t\t\twidthSegments: 30,\n\t\t\theightSegments: 30,\n\t\t\tasLines: false,\n\t\t\topen: false,\n\t\t});\n\t\tconst object = BaseSopOperation.createObject(geometry, ObjectType.MESH);\n\t\treturn [object];\n\t}\n\n\tprivate _findActorNode() {\n\t\t// if (isBooleanTrue(this.pv.useThisNode)) {\n\t\treturn this;\n\t\t// } else {\n\t\t// \treturn this.pv.node.node() as ActorBuilderNode | undefined;\n\t\t// }\n\t}\n}\n","/**\n * Creates object attributes used to create a physics object.\n\n *\n */\nimport {StringParam} from './../../params/String';\nimport {TypeAssert} from './../../poly/Assert';\nimport {FloatParam} from './../../params/Float';\nimport {IntegerParam} from './../../params/Integer';\nimport {\n\tPHYSICS_RBD_COLLIDER_TYPES,\n\tPHYSICS_RBD_TYPES,\n\tCorePhysicsAttribute,\n\tPhysicsRBDColliderType,\n\tPHYSICS_RBD_TYPE_MENU_ENTRIES,\n\tPHYSICS_RBD_COLLIDER_TYPE_MENU_ENTRIES,\n\tPhysicsRBDType,\n} from './../../../core/physics/PhysicsAttribute';\nimport {TypedSopNode} from './_Base';\nimport {CoreGroup} from '../../../core/geometry/Group';\nimport {\n\tPhysicsRBDAttributesSopOperation,\n\tSIZE_COMPUTATION_METHOD_MENU_ENTRIES,\n\tSizeComputationMethod,\n\tSIZE_COMPUTATION_METHODS,\n} from '../../operations/sop/PhysicsRBDAttributes';\nimport {NodeParamsConfig, ParamConfig} from '../utils/params/ParamsConfig';\nimport {BaseCoreObject} from '../../../core/geometry/entities/object/BaseCoreObject';\nimport {Vector3, Box3, Sphere} from 'three';\nimport {Vector3Param} from '../../params/Vector3';\nimport {isBooleanTrue} from '../../../core/Type';\nimport {BooleanParam} from '../../params/Boolean';\nimport {SopType} from '../../poly/registers/nodes/types/Sop';\nimport {CoreObjectType, ObjectContent} from '../../../core/geometry/ObjectContent';\nconst tmpBox = new Box3();\nconst tmpSphere = new Sphere();\nconst DEFAULT = PhysicsRBDAttributesSopOperation.DEFAULT_PARAMS;\n\ntype Vector3Component = 'x' | 'y' | 'z';\nconst VECTOR3_COMPONENT_NAMES: Array<Vector3Component> = ['x', 'y', 'z'];\nconst tmpV3 = new Vector3();\n\nconst SIZE_METHOD_CUSTOM = {sizeMethod: SIZE_COMPUTATION_METHODS.indexOf(SizeComputationMethod.MANUAL)};\nconst VISIBLE_OPTIONS = {\n\tCAPSULE: {\n\t\t...SIZE_METHOD_CUSTOM,\n\t\tcolliderType: PHYSICS_RBD_COLLIDER_TYPES.indexOf(PhysicsRBDColliderType.CAPSULE),\n\t},\n\tCONE: {\n\t\t...SIZE_METHOD_CUSTOM,\n\t\tcolliderType: PHYSICS_RBD_COLLIDER_TYPES.indexOf(PhysicsRBDColliderType.CONE),\n\t},\n\tCUBOID: {\n\t\t...SIZE_METHOD_CUSTOM,\n\t\tcolliderType: PHYSICS_RBD_COLLIDER_TYPES.indexOf(PhysicsRBDColliderType.CUBOID),\n\t},\n\tCYLINDER: {\n\t\t...SIZE_METHOD_CUSTOM,\n\t\tcolliderType: PHYSICS_RBD_COLLIDER_TYPES.indexOf(PhysicsRBDColliderType.CYLINDER),\n\t},\n\tSPHERE: {\n\t\t...SIZE_METHOD_CUSTOM,\n\t\tcolliderType: PHYSICS_RBD_COLLIDER_TYPES.indexOf(PhysicsRBDColliderType.SPHERE),\n\t},\n\tHEIGHT_FIELD: {\n\t\tcolliderType: PHYSICS_RBD_COLLIDER_TYPES.indexOf(PhysicsRBDColliderType.HEIGHT_FIELD),\n\t},\n};\nconst SIZE_METHOD_AVAILABLE: PhysicsRBDColliderType[] = [\n\tPhysicsRBDColliderType.CAPSULE,\n\tPhysicsRBDColliderType.CONE,\n\tPhysicsRBDColliderType.CUBOID,\n\tPhysicsRBDColliderType.CYLINDER,\n\tPhysicsRBDColliderType.SPHERE,\n];\nexport const BORDER_RADIUS_AVAILABLE: PhysicsRBDColliderType[] = [\n\tPhysicsRBDColliderType.CONE,\n\tPhysicsRBDColliderType.CUBOID,\n\tPhysicsRBDColliderType.CYLINDER,\n];\nclass PhysicsRBDAttributesSopParamsConfig extends NodeParamsConfig {\n\tmain = ParamConfig.FOLDER();\n\t/** @param Rigid body type */\n\tRBDType = ParamConfig.INTEGER(DEFAULT.RBDType, {\n\t\tmenu: {\n\t\t\tentries: PHYSICS_RBD_TYPE_MENU_ENTRIES,\n\t\t},\n\t});\n\t/** @param collider type */\n\tcolliderType = ParamConfig.INTEGER(DEFAULT.colliderType, {\n\t\tmenu: {\n\t\t\tentries: PHYSICS_RBD_COLLIDER_TYPE_MENU_ENTRIES,\n\t\t},\n\t});\n\t/** @param Rigid body type */\n\tsizeMethod = ParamConfig.INTEGER(DEFAULT.sizeMethod, {\n\t\tvisibleIf: SIZE_METHOD_AVAILABLE.map((colliderType) => ({\n\t\t\tcolliderType: PHYSICS_RBD_COLLIDER_TYPES.indexOf(colliderType),\n\t\t})),\n\t\tmenu: {\n\t\t\tentries: SIZE_COMPUTATION_METHOD_MENU_ENTRIES,\n\t\t},\n\t});\n\t/** @param border radius */\n\tborderRadius = ParamConfig.FLOAT(DEFAULT.borderRadius, {\n\t\tvisibleIf: BORDER_RADIUS_AVAILABLE.map((colliderType) => ({\n\t\t\tcolliderType: PHYSICS_RBD_COLLIDER_TYPES.indexOf(colliderType),\n\t\t})),\n\t\texpression: {forEntities: true},\n\t});\n\t/** @param sizes */\n\tsizes = ParamConfig.VECTOR3(DEFAULT.sizes.toArray(), {\n\t\tvisibleIf: VISIBLE_OPTIONS.CUBOID,\n\t\texpression: {forEntities: true},\n\t});\n\t/** @param sizes */\n\tsize = ParamConfig.FLOAT(DEFAULT.size, {\n\t\tvisibleIf: VISIBLE_OPTIONS.CUBOID,\n\t\texpression: {forEntities: true},\n\t});\n\t/** @param radius */\n\tradius = ParamConfig.FLOAT(DEFAULT.radius, {\n\t\trange: [0, 1],\n\t\trangeLocked: [true, false],\n\t\tvisibleIf: [VISIBLE_OPTIONS.CAPSULE, VISIBLE_OPTIONS.CONE, VISIBLE_OPTIONS.CYLINDER, VISIBLE_OPTIONS.SPHERE],\n\t\texpression: {forEntities: true},\n\t});\n\t/** @param half height */\n\theight = ParamConfig.FLOAT(DEFAULT.height, {\n\t\trange: [0, 1],\n\t\trangeLocked: [true, false],\n\t\tvisibleIf: [VISIBLE_OPTIONS.CAPSULE, VISIBLE_OPTIONS.CONE, VISIBLE_OPTIONS.CYLINDER],\n\t\texpression: {forEntities: true},\n\t});\n\t/** @param heightField rows */\n\trows = ParamConfig.INTEGER(DEFAULT.rows, {\n\t\trange: [1, 100],\n\t\trangeLocked: [true, false],\n\t\tvisibleIf: VISIBLE_OPTIONS.HEIGHT_FIELD,\n\t\texpression: {forEntities: true},\n\t});\n\t/** @param heightField cols */\n\tcols = ParamConfig.INTEGER(DEFAULT.cols, {\n\t\trange: [1, 100],\n\t\trangeLocked: [true, false],\n\t\tvisibleIf: VISIBLE_OPTIONS.HEIGHT_FIELD,\n\t\texpression: {forEntities: true},\n\t});\n\t/** @param density */\n\tdensity = ParamConfig.FLOAT(DEFAULT.density, {\n\t\trange: [0, 10],\n\t\trangeLocked: [true, false],\n\t\texpression: {forEntities: true},\n\t\tseparatorBefore: true,\n\t});\n\t/** @param friction */\n\tfriction = ParamConfig.FLOAT(DEFAULT.friction, {\n\t\trange: [0, 1],\n\t\trangeLocked: [true, false],\n\t\texpression: {forEntities: true},\n\t});\n\t/** @param restitution */\n\trestitution = ParamConfig.FLOAT(DEFAULT.restitution, {\n\t\trange: [0, 2],\n\t\trangeLocked: [true, false],\n\t\texpression: {forEntities: true},\n\t});\n\t/** @param linear damping (affects velocity) */\n\tlinearDamping = ParamConfig.FLOAT(DEFAULT.linearDamping, {\n\t\trange: [0, 10],\n\t\trangeLocked: [true, false],\n\t\texpression: {forEntities: true},\n\t});\n\t/** @param angular damping (affects rotations) */\n\tangularDamping = ParamConfig.FLOAT(DEFAULT.angularDamping, {\n\t\trange: [0, 10],\n\t\trangeLocked: [true, false],\n\t\texpression: {forEntities: true},\n\t});\n\t/** @param linear velocity */\n\tlinearVelocity = ParamConfig.VECTOR3(DEFAULT.linearVelocity, {\n\t\texpression: {forEntities: true},\n\t});\n\t/** @param angular velocity */\n\tangularVelocity = ParamConfig.VECTOR3(DEFAULT.angularVelocity, {\n\t\texpression: {forEntities: true},\n\t});\n\t/** @param gravity Scale */\n\tgravityScale = ParamConfig.FLOAT(DEFAULT.gravityScale, {\n\t\trange: [-10, 10],\n\t\trangeLocked: [false, false],\n\t\texpression: {forEntities: true},\n\t});\n\t/** @param can sleep */\n\tcanSleep = ParamConfig.BOOLEAN(DEFAULT.canSleep, {\n\t\texpression: {forEntities: true},\n\t});\n\tdetails = ParamConfig.FOLDER();\n\t/** @param add id */\n\taddId = ParamConfig.BOOLEAN(1);\n\t/** @param id */\n\tid = ParamConfig.STRING('`$OS`-`@objnum`', {\n\t\tvisibleIf: {addId: true},\n\t\texpression: {forEntities: true},\n\t});\n}\nconst ParamsConfig = new PhysicsRBDAttributesSopParamsConfig();\n\nexport class PhysicsRBDAttributesSopNode extends TypedSopNode<PhysicsRBDAttributesSopParamsConfig> {\n\toverride readonly paramsConfig = ParamsConfig;\n\tstatic override type() {\n\t\treturn SopType.PHYSICS_RBD_ATTRIBUTES;\n\t}\n\n\tprotected override initializeNode() {\n\t\tthis.io.inputs.setCount(0, 1);\n\t\tthis.io.inputs.initInputsClonedState(PhysicsRBDAttributesSopOperation.INPUT_CLONED_STATE);\n\t}\n\n\tsetRBDType(RBDtype: PhysicsRBDType) {\n\t\tthis.p.RBDType.set(PHYSICS_RBD_TYPES.indexOf(RBDtype));\n\t}\n\tRBDType() {\n\t\treturn PHYSICS_RBD_TYPES[this.pv.RBDType];\n\t}\n\tsetColliderType(colliderType: PhysicsRBDColliderType) {\n\t\tthis.p.colliderType.set(PHYSICS_RBD_COLLIDER_TYPES.indexOf(colliderType));\n\t}\n\tcolliderType() {\n\t\treturn PHYSICS_RBD_COLLIDER_TYPES[this.pv.colliderType];\n\t}\n\tsetSizeMethod(sizeMethod: SizeComputationMethod) {\n\t\tthis.p.sizeMethod.set(SIZE_COMPUTATION_METHODS.indexOf(sizeMethod));\n\t}\n\tsizeMethod() {\n\t\treturn SIZE_COMPUTATION_METHODS[this.pv.sizeMethod];\n\t}\n\n\toverride async cook(inputCoreGroups: CoreGroup[]) {\n\t\tconst coreGroup = inputCoreGroups[0];\n\n\t\tconst RBDType = this.RBDType();\n\t\tconst colliderType = this.colliderType();\n\t\tconst sizeMethod = this.sizeMethod();\n\t\tconst coreObjects = coreGroup.allCoreObjects();\n\t\tfor (const coreObject of coreObjects) {\n\t\t\tCorePhysicsAttribute.setRBDType(coreObject.object(), RBDType);\n\n\t\t\tCorePhysicsAttribute.setColliderType(coreObject.object(), colliderType);\n\t\t}\n\t\tconst promises: Array<Promise<void>> = [];\n\t\tthis._applyColliderType(colliderType, sizeMethod, coreObjects, promises);\n\n\t\tif (BORDER_RADIUS_AVAILABLE.includes(colliderType)) {\n\t\t\tpromises.push(\n\t\t\t\tthis._computeNumberParam(\n\t\t\t\t\tthis.p.borderRadius,\n\t\t\t\t\tcoreObjects,\n\t\t\t\t\tCorePhysicsAttribute.setBorderRadius.bind(CorePhysicsAttribute)\n\t\t\t\t)\n\t\t\t);\n\t\t}\n\n\t\tpromises.push(\n\t\t\tthis._computeNumberParam(\n\t\t\t\tthis.p.density,\n\t\t\t\tcoreObjects,\n\t\t\t\tCorePhysicsAttribute.setDensity.bind(CorePhysicsAttribute)\n\t\t\t)\n\t\t);\n\t\tpromises.push(\n\t\t\tthis._computeNumberParam(\n\t\t\t\tthis.p.friction,\n\t\t\t\tcoreObjects,\n\t\t\t\tCorePhysicsAttribute.setFriction.bind(CorePhysicsAttribute)\n\t\t\t)\n\t\t);\n\t\tpromises.push(\n\t\t\tthis._computeNumberParam(\n\t\t\t\tthis.p.linearDamping,\n\t\t\t\tcoreObjects,\n\t\t\t\tCorePhysicsAttribute.setLinearDamping.bind(CorePhysicsAttribute)\n\t\t\t)\n\t\t);\n\t\tpromises.push(\n\t\t\tthis._computeNumberParam(\n\t\t\t\tthis.p.angularDamping,\n\t\t\t\tcoreObjects,\n\t\t\t\tCorePhysicsAttribute.setAngularDamping.bind(CorePhysicsAttribute)\n\t\t\t)\n\t\t);\n\t\tpromises.push(\n\t\t\tthis._computeVector3Param(\n\t\t\t\tthis.p.linearVelocity,\n\t\t\t\tcoreObjects,\n\t\t\t\tCorePhysicsAttribute.setLinearVelocity.bind(CorePhysicsAttribute)\n\t\t\t)\n\t\t);\n\t\tpromises.push(\n\t\t\tthis._computeVector3Param(\n\t\t\t\tthis.p.angularVelocity,\n\t\t\t\tcoreObjects,\n\t\t\t\tCorePhysicsAttribute.setAngularVelocity.bind(CorePhysicsAttribute)\n\t\t\t)\n\t\t);\n\t\tpromises.push(\n\t\t\tthis._computeNumberParam(\n\t\t\t\tthis.p.gravityScale,\n\t\t\t\tcoreObjects,\n\t\t\t\tCorePhysicsAttribute.setGravityScale.bind(CorePhysicsAttribute)\n\t\t\t)\n\t\t);\n\t\tpromises.push(\n\t\t\tthis._computeNumberParam(\n\t\t\t\tthis.p.restitution,\n\t\t\t\tcoreObjects,\n\t\t\t\tCorePhysicsAttribute.setRestitution.bind(CorePhysicsAttribute)\n\t\t\t)\n\t\t);\n\t\tpromises.push(\n\t\t\tthis._computeBooleanParam(\n\t\t\t\tthis.p.canSleep,\n\t\t\t\tcoreObjects,\n\t\t\t\tCorePhysicsAttribute.setCanSleep.bind(CorePhysicsAttribute)\n\t\t\t)\n\t\t);\n\n\t\tif (isBooleanTrue(this.pv.addId)) {\n\t\t\tpromises.push(\n\t\t\t\tthis._computeStringParam(\n\t\t\t\t\tthis.p.id,\n\t\t\t\t\tcoreObjects,\n\t\t\t\t\tCorePhysicsAttribute.setRBDId.bind(CorePhysicsAttribute)\n\t\t\t\t)\n\t\t\t);\n\t\t}\n\t\tawait Promise.all(promises);\n\n\t\t// this._operation = this._operation || new PhysicsRBDAttributesSopOperation(this._scene, this.states);\n\t\t// const core_group = this._operation.cook(input_contents, this.pv);\n\t\tthis.setCoreGroup(coreGroup);\n\t}\n\tprotected _applyColliderType<T extends CoreObjectType>(\n\t\tcolliderType: PhysicsRBDColliderType,\n\t\tsizeMethod: SizeComputationMethod,\n\t\tcoreObjects: BaseCoreObject<T>[], //BaseCoreObject<CoreObjectType>[],\n\t\tpromises: Array<Promise<void>>\n\t) {\n\t\tswitch (colliderType) {\n\t\t\tcase PhysicsRBDColliderType.CUBOID: {\n\t\t\t\tswitch (sizeMethod) {\n\t\t\t\t\tcase SizeComputationMethod.AUTO: {\n\t\t\t\t\t\tfor (const coreObject of coreObjects) {\n\t\t\t\t\t\t\tcoreObject.geometryBoundingBox(tmpBox);\n\t\t\t\t\t\t\ttmpBox.getSize(tmpV3);\n\t\t\t\t\t\t\tCorePhysicsAttribute.setCuboidSizes(coreObject.object(), tmpV3);\n\t\t\t\t\t\t\tCorePhysicsAttribute.setCuboidSize(coreObject.object(), 1);\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tcase SizeComputationMethod.MANUAL: {\n\t\t\t\t\t\tpromises.push(\n\t\t\t\t\t\t\tthis._computeVector3Param(\n\t\t\t\t\t\t\t\tthis.p.sizes,\n\t\t\t\t\t\t\t\tcoreObjects,\n\t\t\t\t\t\t\t\tCorePhysicsAttribute.setCuboidSizes.bind(CorePhysicsAttribute)\n\t\t\t\t\t\t\t)\n\t\t\t\t\t\t);\n\t\t\t\t\t\tpromises.push(\n\t\t\t\t\t\t\tthis._computeNumberParam(\n\t\t\t\t\t\t\t\tthis.p.size,\n\t\t\t\t\t\t\t\tcoreObjects,\n\t\t\t\t\t\t\t\tCorePhysicsAttribute.setCuboidSize.bind(CorePhysicsAttribute)\n\t\t\t\t\t\t\t)\n\t\t\t\t\t\t);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tcase PhysicsRBDColliderType.SPHERE: {\n\t\t\t\tswitch (sizeMethod) {\n\t\t\t\t\tcase SizeComputationMethod.AUTO: {\n\t\t\t\t\t\tfor (const coreObject of coreObjects) {\n\t\t\t\t\t\t\tcoreObject.geometryBoundingSphere(tmpSphere);\n\t\t\t\t\t\t\tconst radius = tmpSphere.radius;\n\t\t\t\t\t\t\tCorePhysicsAttribute.setRadius(coreObject.object(), radius);\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tcase SizeComputationMethod.MANUAL: {\n\t\t\t\t\t\tpromises.push(\n\t\t\t\t\t\t\tthis._computeNumberParam(\n\t\t\t\t\t\t\t\tthis.p.radius,\n\t\t\t\t\t\t\t\tcoreObjects,\n\t\t\t\t\t\t\t\tCorePhysicsAttribute.setRadius.bind(CorePhysicsAttribute)\n\t\t\t\t\t\t\t)\n\t\t\t\t\t\t);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tcase PhysicsRBDColliderType.CAPSULE: {\n\t\t\t\tswitch (sizeMethod) {\n\t\t\t\t\tcase SizeComputationMethod.AUTO: {\n\t\t\t\t\t\tfor (const coreObject of coreObjects) {\n\t\t\t\t\t\t\tcoreObject.geometryBoundingBox(tmpBox);\n\t\t\t\t\t\t\ttmpBox.getSize(tmpV3);\n\t\t\t\t\t\t\tconst radius = 0.5 * tmpV3.x;\n\t\t\t\t\t\t\tconst height = tmpV3.y - 2 * radius;\n\t\t\t\t\t\t\tCorePhysicsAttribute.setHeight(coreObject.object(), height);\n\t\t\t\t\t\t\tCorePhysicsAttribute.setRadius(coreObject.object(), radius);\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tcase SizeComputationMethod.MANUAL: {\n\t\t\t\t\t\tpromises.push(\n\t\t\t\t\t\t\tthis._computeNumberParam(\n\t\t\t\t\t\t\t\tthis.p.height,\n\t\t\t\t\t\t\t\tcoreObjects,\n\t\t\t\t\t\t\t\tCorePhysicsAttribute.setHeight.bind(CorePhysicsAttribute)\n\t\t\t\t\t\t\t)\n\t\t\t\t\t\t);\n\t\t\t\t\t\tpromises.push(\n\t\t\t\t\t\t\tthis._computeNumberParam(\n\t\t\t\t\t\t\t\tthis.p.radius,\n\t\t\t\t\t\t\t\tcoreObjects,\n\t\t\t\t\t\t\t\tCorePhysicsAttribute.setRadius.bind(CorePhysicsAttribute)\n\t\t\t\t\t\t\t)\n\t\t\t\t\t\t);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tcase PhysicsRBDColliderType.CONE:\n\t\t\tcase PhysicsRBDColliderType.CYLINDER: {\n\t\t\t\tswitch (sizeMethod) {\n\t\t\t\t\tcase SizeComputationMethod.AUTO: {\n\t\t\t\t\t\tfor (const coreObject of coreObjects) {\n\t\t\t\t\t\t\tcoreObject.geometryBoundingBox(tmpBox);\n\t\t\t\t\t\t\ttmpBox.getSize(tmpV3);\n\t\t\t\t\t\t\tCorePhysicsAttribute.setHeight(coreObject.object(), tmpV3.y);\n\t\t\t\t\t\t\tCorePhysicsAttribute.setRadius(coreObject.object(), 0.5 * tmpV3.x);\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tcase SizeComputationMethod.MANUAL: {\n\t\t\t\t\t\tpromises.push(\n\t\t\t\t\t\t\tthis._computeNumberParam(\n\t\t\t\t\t\t\t\tthis.p.height,\n\t\t\t\t\t\t\t\tcoreObjects,\n\t\t\t\t\t\t\t\tCorePhysicsAttribute.setHeight.bind(CorePhysicsAttribute)\n\t\t\t\t\t\t\t)\n\t\t\t\t\t\t);\n\t\t\t\t\t\tpromises.push(\n\t\t\t\t\t\t\tthis._computeNumberParam(\n\t\t\t\t\t\t\t\tthis.p.radius,\n\t\t\t\t\t\t\t\tcoreObjects,\n\t\t\t\t\t\t\t\tCorePhysicsAttribute.setRadius.bind(CorePhysicsAttribute)\n\t\t\t\t\t\t\t)\n\t\t\t\t\t\t);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tcase PhysicsRBDColliderType.HEIGHT_FIELD: {\n\t\t\t\tpromises.push(\n\t\t\t\t\tthis._computeNumberParam(\n\t\t\t\t\t\tthis.p.rows,\n\t\t\t\t\t\tcoreObjects,\n\t\t\t\t\t\tCorePhysicsAttribute.setHeightFieldRows.bind(CorePhysicsAttribute)\n\t\t\t\t\t)\n\t\t\t\t);\n\t\t\t\tpromises.push(\n\t\t\t\t\tthis._computeNumberParam(\n\t\t\t\t\t\tthis.p.cols,\n\t\t\t\t\t\tcoreObjects,\n\t\t\t\t\t\tCorePhysicsAttribute.setHeightFieldCols.bind(CorePhysicsAttribute)\n\t\t\t\t\t)\n\t\t\t\t);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tcase PhysicsRBDColliderType.CONVEX_HULL:\n\t\t\tcase PhysicsRBDColliderType.TRIMESH: {\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tTypeAssert.unreachable(colliderType);\n\t}\n\n\tprotected async _computeStringParam<T extends CoreObjectType>(\n\t\tparam: StringParam,\n\t\tcoreObjects: BaseCoreObject<T>[],\n\t\tapplyMethod: (object: ObjectContent<CoreObjectType>, value: string) => void\n\t) {\n\t\tif (param.expressionController && param.expressionController.entitiesDependent()) {\n\t\t\tawait param.expressionController.computeExpressionForObjects(coreObjects, (coreObject, value: string) => {\n\t\t\t\tapplyMethod(coreObject.object(), value);\n\t\t\t});\n\t\t} else {\n\t\t\tfor (const coreObject of coreObjects) {\n\t\t\t\tapplyMethod(coreObject.object(), param.value);\n\t\t\t}\n\t\t}\n\t}\n\tprotected async _computeVector3Param(\n\t\tvectorParam: Vector3Param,\n\t\tcoreObjects: BaseCoreObject<CoreObjectType>[],\n\t\tapplyMethod: (object: ObjectContent<CoreObjectType>, value: Vector3) => void\n\t) {\n\t\t// if (param.expressionController && param.expressionController.entitiesDependent()) {\n\t\t// \tawait param.expressionController.computeExpressionForObjects(coreObjects, (coreObject, value) => {\n\t\t// \t\tapplyMethod(coreObject.object(), value);\n\t\t// \t});\n\t\t// } else {\n\t\t// \tfor (let coreObject of coreObjects) {\n\t\t// \t\tapplyMethod(coreObject.object(), param.value);\n\t\t// \t}\n\t\t// }\n\t\tconst components = vectorParam.components;\n\t\tconst valuesByCoreObjectIndex: Map<number, Vector3> = new Map();\n\t\t// for (let component_param of components) {\n\t\t// values.push(component_param.value);\n\t\t// }\n\t\t// const initVector = this._vectorByAttribSize(this.pv.size);\n\t\t// if (initVector) {\n\t\tfor (const coreObject of coreObjects) {\n\t\t\tvaluesByCoreObjectIndex.set(coreObject.index(), new Vector3());\n\t\t}\n\t\tfor (let componentIndex = 0; componentIndex < components.length; componentIndex++) {\n\t\t\tconst component_param = components[componentIndex];\n\t\t\tconst component_name = VECTOR3_COMPONENT_NAMES[componentIndex];\n\t\t\tif (\n\t\t\t\tcomponent_param.hasExpression() &&\n\t\t\t\tcomponent_param.expressionController &&\n\t\t\t\tcomponent_param.expressionController.entitiesDependent()\n\t\t\t) {\n\t\t\t\tawait component_param.expressionController.computeExpressionForObjects(\n\t\t\t\t\tcoreObjects,\n\t\t\t\t\t(coreObject, value) => {\n\t\t\t\t\t\tconst vector = valuesByCoreObjectIndex.get(coreObject.index());\n\t\t\t\t\t\tif (vector) {\n\t\t\t\t\t\t\tvector[component_name] = value;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t);\n\t\t\t} else {\n\t\t\t\tfor (const coreObject of coreObjects) {\n\t\t\t\t\tconst vector = valuesByCoreObjectIndex.get(coreObject.index());\n\t\t\t\t\tif (vector) {\n\t\t\t\t\t\tvector[component_name] = component_param.value;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (let i = 0; i < coreObjects.length; i++) {\n\t\t\tconst coreObject = coreObjects[i];\n\t\t\tconst value = valuesByCoreObjectIndex.get(coreObject.index());\n\t\t\tif (value != null) {\n\t\t\t\tapplyMethod(coreObject.object(), value);\n\t\t\t}\n\t\t}\n\t\t// }\n\t}\n\tprotected async _computeNumberParam(\n\t\tparam: FloatParam | IntegerParam,\n\t\tcoreObjects: BaseCoreObject<CoreObjectType>[],\n\t\tapplyMethod: (object: ObjectContent<CoreObjectType>, value: number) => void\n\t) {\n\t\tif (param.expressionController && param.expressionController.entitiesDependent()) {\n\t\t\tawait param.expressionController.computeExpressionForObjects(coreObjects, (coreObject, value) => {\n\t\t\t\tapplyMethod(coreObject.object(), value);\n\t\t\t});\n\t\t} else {\n\t\t\tfor (const coreObject of coreObjects) {\n\t\t\t\tapplyMethod(coreObject.object(), param.value);\n\t\t\t}\n\t\t}\n\t}\n\tprotected async _computeBooleanParam(\n\t\tparam: BooleanParam,\n\t\tcoreObjects: BaseCoreObject<CoreObjectType>[],\n\t\tapplyMethod: (object: ObjectContent<CoreObjectType>, value: boolean) => void\n\t) {\n\t\tif (param.expressionController && param.expressionController.entitiesDependent()) {\n\t\t\tawait param.expressionController.computeExpressionForObjects(coreObjects, (coreObject, value) => {\n\t\t\t\tapplyMethod(coreObject.object(), value);\n\t\t\t});\n\t\t} else {\n\t\t\tfor (const coreObject of coreObjects) {\n\t\t\t\tapplyMethod(coreObject.object(), param.value);\n\t\t\t}\n\t\t}\n\t}\n}\n","/**\n * Creates joints data from objects with RBD attributes\n\n *\n */\nimport {\n\tCorePhysicsJoinAttribute,\n\tPhysicsJointType,\n\tPHYSICS_JOINT_TYPE_MENU_ENTRIES,\n\tPHYSICS_JOINT_TYPES,\n} from '../../../core/physics/PhysicsJoint';\nimport {CorePhysicsAttribute} from '../../../core/physics/PhysicsAttribute';\nimport {TypedSopNode} from './_Base';\nimport {CoreGroup} from '../../../core/geometry/Group';\nimport {MapUtils} from '../../../core/MapUtils';\nimport {isBooleanTrue} from '../../../core/Type';\nimport {NodeParamsConfig, ParamConfig} from '../utils/params/ParamsConfig';\nimport {InputCloneMode} from '../../poly/InputCloneMode';\nimport {Object3D, Vector4, Vector3, Group, Box3, Matrix4, Quaternion} from 'three';\nimport {CoreMask} from '../../../core/geometry/Mask';\nimport {SopType} from '../../poly/registers/nodes/types/Sop';\n\nconst center = new Vector3();\n// const delta = new Vector3();\nconst tmpV3_1 = new Vector3();\nconst tmpV3_2 = new Vector3();\nconst tmpQuat = new Quaternion();\nconst frame1 = new Vector4();\nconst frame2 = new Vector4();\nconst axis = new Vector3();\nconst bbox = new Box3();\nconst _mat = new Matrix4();\n\nfunction quaternionToVector4(quaternion: Quaternion, target: Vector4) {\n\ttarget.x = quaternion.x;\n\ttarget.y = quaternion.y;\n\ttarget.z = quaternion.z;\n\ttarget.w = quaternion.w;\n}\nconst checkedPair: Map<number, Set<number>> = new Map();\nconst jointsCountByKey: Map<number, number> = new Map();\n\nclass PhysicsRBDJointsSopParamsConfig extends NodeParamsConfig {\n\t/** @param group to assign the material to */\n\tgroup = ParamConfig.STRING('', {\n\t\tobjectMask: true,\n\t});\n\t/** @param maxDistance */\n\tmaxDistance = ParamConfig.FLOAT(1, {\n\t\trange: [0, 10],\n\t});\n\t/** @param max number of joints per object */\n\tmaxJointsCount = ParamConfig.INTEGER(2, {\n\t\trange: [0, 10],\n\t});\n\t/** @param joint type */\n\tjointType = ParamConfig.INTEGER(PHYSICS_JOINT_TYPES.indexOf(PhysicsJointType.SPHERICAL), {\n\t\tmenu: {\n\t\t\tentries: PHYSICS_JOINT_TYPE_MENU_ENTRIES,\n\t\t},\n\t});\n\n\t/** @param limit */\n\tlimit = ParamConfig.VECTOR2([-1, 1], {\n\t\tseparatorBefore: true,\n\t\tvisibleIf: [\n\t\t\t{\n\t\t\t\tjointType: PHYSICS_JOINT_TYPES.indexOf(PhysicsJointType.REVOLUT),\n\t\t\t},\n\t\t\t{\n\t\t\t\tjointType: PHYSICS_JOINT_TYPES.indexOf(PhysicsJointType.PRISMATIC),\n\t\t\t},\n\t\t],\n\t});\n\t/** @param up */\n\tup = ParamConfig.VECTOR3([0, 1, 0], {\n\t\tvisibleIf: [\n\t\t\t{\n\t\t\t\tjointType: PHYSICS_JOINT_TYPES.indexOf(PhysicsJointType.REVOLUT),\n\t\t\t},\n\t\t],\n\t});\n\t/** @param center */\n\tcenter = ParamConfig.FLOAT(0.5, {\n\t\tseparatorBefore: true,\n\t\tvisibleIf: [\n\t\t\t{\n\t\t\t\tjointType: PHYSICS_JOINT_TYPES.indexOf(PhysicsJointType.SPHERICAL),\n\t\t\t},\n\t\t\t{\n\t\t\t\tjointType: PHYSICS_JOINT_TYPES.indexOf(PhysicsJointType.REVOLUT),\n\t\t\t},\n\t\t],\n\t});\n\t/** @param anchors at objects center */\n\tanchorsAtCenter = ParamConfig.BOOLEAN(1, {});\n\t/** @param anchor position 1 */\n\tanchorsPos1 = ParamConfig.VECTOR3([0.5, 0.5, 0.5], {\n\t\tvisibleIf: {anchorsAtCenter: 0},\n\t});\n\t/** @param anchor position 2 */\n\tanchorsPos2 = ParamConfig.VECTOR3([0.5, 0.5, 0.5], {\n\t\tvisibleIf: {anchorsAtCenter: 0},\n\t});\n\t/** @param do not output input RBDs with joints */\n\touputsJointsOnly = ParamConfig.BOOLEAN(0, {\n\t\tseparatorBefore: true,\n\t});\n}\nconst ParamsConfig = new PhysicsRBDJointsSopParamsConfig();\n\nexport class PhysicsRBDJointsSopNode extends TypedSopNode<PhysicsRBDJointsSopParamsConfig> {\n\toverride readonly paramsConfig = ParamsConfig;\n\tstatic override type() {\n\t\treturn SopType.PHYSICS_RBD_JOINTS;\n\t}\n\n\tprotected override initializeNode() {\n\t\tthis.io.inputs.setCount(1);\n\t\tthis.io.inputs.initInputsClonedState(InputCloneMode.FROM_NODE);\n\t}\n\n\tsetJointType(RBDtype: PhysicsJointType) {\n\t\tthis.p.jointType.set(PHYSICS_JOINT_TYPES.indexOf(RBDtype));\n\t}\n\tjointType() {\n\t\treturn PHYSICS_JOINT_TYPES[this.pv.jointType];\n\t}\n\n\toverride cook(inputCoreGroups: CoreGroup[]) {\n\t\tconst coreGroup = inputCoreGroups[0];\n\t\tconst inputObjects = coreGroup.allObjects();\n\t\tconst selectedObjects = CoreMask.filterThreejsObjects(coreGroup, this.pv);\n\t\tconst candidateObjects = selectedObjects.filter((object) => CorePhysicsAttribute.getRBDId(object) != null);\n\n\t\tconst joinObjects: Object3D[] = [];\n\t\tconst maxDistance = this.pv.maxDistance;\n\t\tconst maxJointsCount = this.pv.maxJointsCount;\n\t\tcheckedPair.clear();\n\t\tjointsCountByKey.clear();\n\t\tlet maxJointsCountReached = false;\n\t\tlet maxJointsCountReached1 = false;\n\t\tlet maxJointsCountReached2 = false;\n\t\tlet jointsCount1: number | undefined;\n\t\tlet jointsCount2: number | undefined;\n\t\tlet jointIndex = 0;\n\t\tlet existingSet: Set<number> | undefined;\n\t\tfor (let i1 = 0; i1 < candidateObjects.length; i1++) {\n\t\t\tconst object1 = candidateObjects[i1];\n\t\t\tfor (let i2 = 0; i2 < candidateObjects.length; i2++) {\n\t\t\t\tconst object2 = candidateObjects[i2];\n\t\t\t\tif (i1 != i2) {\n\t\t\t\t\tjointsCount1 = jointsCountByKey.get(i1);\n\t\t\t\t\tjointsCount2 = jointsCountByKey.get(i2);\n\t\t\t\t\tmaxJointsCountReached1 = jointsCount1 != null && jointsCount1 >= maxJointsCount;\n\t\t\t\t\tmaxJointsCountReached2 = jointsCount2 != null && jointsCount2 >= maxJointsCount;\n\t\t\t\t\tmaxJointsCountReached = maxJointsCountReached1 || maxJointsCountReached2;\n\t\t\t\t\tif (!maxJointsCountReached) {\n\t\t\t\t\t\tif (object1.position.distanceTo(object2.position) < maxDistance) {\n\t\t\t\t\t\t\tlet key = i1 < i2 ? i1 : i2;\n\t\t\t\t\t\t\tlet idInSet = i1 < i2 ? i2 : i1;\n\t\t\t\t\t\t\texistingSet = checkedPair.get(key);\n\t\t\t\t\t\t\tif (existingSet == null || !existingSet.has(idInSet)) {\n\t\t\t\t\t\t\t\tMapUtils.addToSetAtEntry(checkedPair, key, idInSet);\n\t\t\t\t\t\t\t\tconst jointObject = this._createJoint(object1, object2);\n\t\t\t\t\t\t\t\tjointObject.name = `${this.name()}_${jointIndex}`;\n\t\t\t\t\t\t\t\tjointIndex++;\n\t\t\t\t\t\t\t\tjoinObjects.push(jointObject);\n\t\t\t\t\t\t\t\tMapUtils.incrementAtEntry(jointsCountByKey, i1, 0);\n\t\t\t\t\t\t\t\tMapUtils.incrementAtEntry(jointsCountByKey, i2, 0);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tconst allObjects = isBooleanTrue(this.pv.ouputsJointsOnly) ? joinObjects : [...inputObjects, ...joinObjects];\n\t\tthis.setObjects(allObjects);\n\t}\n\tprivate _createJoint(object1: Object3D, object2: Object3D) {\n\t\tconst group = new Group();\n\t\tgroup.matrixAutoUpdate = false;\n\t\tCorePhysicsJoinAttribute.setRBDId1(group, CorePhysicsAttribute.getRBDId(object1));\n\t\tCorePhysicsJoinAttribute.setRBDId2(group, CorePhysicsAttribute.getRBDId(object2));\n\n\t\tconst getAnchorPos = (object: Object3D, paramValue: Vector3, target: Vector3) => {\n\t\t\tobject.updateMatrix();\n\n\t\t\tif (isBooleanTrue(this.pv.anchorsAtCenter)) {\n\t\t\t\ttarget.set(0, 0, 0);\n\t\t\t\ttarget.applyMatrix4(object.matrix);\n\t\t\t} else {\n\t\t\t\t_mat.copy(object.matrix);\n\t\t\t\tobject.matrix.identity();\n\t\t\t\tbbox.setFromObject(object);\n\t\t\t\ttarget.x = paramValue.x * bbox.max.x + (1 - paramValue.x) * bbox.min.x;\n\t\t\t\ttarget.y = paramValue.y * bbox.max.y + (1 - paramValue.y) * bbox.min.y;\n\t\t\t\ttarget.z = paramValue.z * bbox.max.z + (1 - paramValue.z) * bbox.min.z;\n\t\t\t\tobject.matrix.copy(_mat);\n\t\t\t\ttarget.applyMatrix4(object.matrix);\n\t\t\t}\n\t\t};\n\n\t\tgetAnchorPos(object1, this.pv.anchorsPos1, tmpV3_1);\n\t\tgetAnchorPos(object2, this.pv.anchorsPos2, tmpV3_2);\n\t\tcenter.copy(tmpV3_1).lerp(tmpV3_2, this.pv.center);\n\t\taxis.copy(tmpV3_2).sub(tmpV3_1).normalize();\n\n\t\tconst makeLocal = (object: Object3D, target: Vector3) => {\n\t\t\t_mat.copy(object.matrix).invert();\n\t\t\ttarget.copy(center);\n\t\t\ttarget.applyMatrix4(_mat);\n\t\t};\n\t\tmakeLocal(object1, tmpV3_1);\n\t\tmakeLocal(object2, tmpV3_2);\n\t\tCorePhysicsJoinAttribute.setAnchor1(group, tmpV3_1);\n\t\tCorePhysicsJoinAttribute.setAnchor2(group, tmpV3_2);\n\n\t\tconst jointType = this.jointType();\n\t\tCorePhysicsJoinAttribute.setJoinType(group, jointType);\n\t\tswitch (jointType) {\n\t\t\tcase PhysicsJointType.FIXED: {\n\t\t\t\ttmpQuat.copy(object1.quaternion);\n\t\t\t\ttmpQuat.slerp(object2.quaternion, 0.5);\n\t\t\t\ttmpQuat.invert();\n\t\t\t\tquaternionToVector4(tmpQuat, frame1);\n\t\t\t\ttmpQuat.copy(object2.quaternion);\n\t\t\t\ttmpQuat.slerp(object1.quaternion, 0.5);\n\t\t\t\ttmpQuat.invert();\n\t\t\t\tquaternionToVector4(tmpQuat, frame2);\n\t\t\t\tCorePhysicsJoinAttribute.setFrame1(group, frame1);\n\t\t\t\tCorePhysicsJoinAttribute.setFrame2(group, frame2);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase PhysicsJointType.PRISMATIC: {\n\t\t\t\tCorePhysicsJoinAttribute.setLimit(group, this.pv.limit);\n\t\t\t\t// axis.transformDirection(object2.matrix);\n\t\t\t\tCorePhysicsJoinAttribute.setAxis(group, axis);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase PhysicsJointType.REVOLUT: {\n\t\t\t\tCorePhysicsJoinAttribute.setLimit(group, this.pv.limit);\n\t\t\t\taxis.cross(this.pv.up).normalize();\n\t\t\t\t// axis.transformDirection(object2.matrix);\n\t\t\t\tCorePhysicsJoinAttribute.setAxis(group, axis);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\treturn group;\n\t}\n}\n","/**\n * Create a physics world\n *\n *\n */\nimport {Group, Object3D} from 'three';\nimport {\n\tinitCorePhysicsWorld,\n\tphysicsWorldNodeIdFromObject,\n\tPHYSICS_GRAVITY_DEFAULT,\n} from './../../../core/physics/PhysicsWorld';\nimport {TypedActorSopNode} from './_BaseActor';\nimport {CoreGroup} from '../../../core/geometry/Group';\nimport {NodeParamsConfig, ParamConfig} from '../utils/params/ParamsConfig';\nimport {NodeContext} from '../../poly/NodeContext';\nimport {InputCloneMode} from '../../poly/InputCloneMode';\nimport {createOrFindPhysicsWorld} from '../../../core/physics/PhysicsWorld';\nimport {updatePhysicsDebugObject} from '../../../core/physics/PhysicsDebug';\nimport {SopType} from '../../poly/registers/nodes/types/Sop';\nimport {PolyScene} from '../../scene/PolyScene';\nimport {CoreType} from '../../../core/Type';\nimport {BaseNodeType} from '../_Base';\nimport {Poly} from '../../Poly';\nimport {ThreejsCoreObject} from '../../../core/geometry/modules/three/ThreejsCoreObject';\nimport {PhysicsIdAttribute} from '../../../core/physics/PhysicsAttribute';\nimport {CorePhysics} from '../../../core/physics/CorePhysics';\nimport {setJointDataListForWorldObject} from '../../../core/physics/PhysicsJoint';\nclass PhysicsWorldSopParamsConfig extends NodeParamsConfig {\n\t/** @param gravity */\n\tgravity = ParamConfig.VECTOR3(PHYSICS_GRAVITY_DEFAULT);\n\t/** @param display debug information */\n\t// debug = ParamConfig.BOOLEAN(0);\n\t/** @param actor node */\n\t// node = ParamConfig.NODE_PATH('', {\n\t// \tvisibleIf: {useThisNode: 0},\n\t// \t// nodeSelection: {\n\t// \t// \t// context: NodeContext.ACTOR,\n\t// \t// },\n\t// \tdependentOnFoundNode: false,\n\t// });\n}\nconst ParamsConfig = new PhysicsWorldSopParamsConfig();\n\nexport class PhysicsWorldSopNode extends TypedActorSopNode<PhysicsWorldSopParamsConfig> {\n\toverride readonly paramsConfig = ParamsConfig;\n\tstatic override type(): SopType.PHYSICS_WORLD {\n\t\treturn SopType.PHYSICS_WORLD;\n\t}\n\n\tprotected override initializeNode() {\n\t\tthis.io.inputs.setCount(1);\n\t\t// set to always clone, so that we reset the world\n\t\t// by simply setting this node to dirty\n\t\tthis.io.inputs.initInputsClonedState(InputCloneMode.ALWAYS);\n\t}\n\n\toverride async cook(inputCoreGroups: CoreGroup[]) {\n\t\tthis.compilationController.compileIfRequired();\n\t\tawait CorePhysics();\n\t\tconst coreGroup = inputCoreGroups[0];\n\n\t\tconst worldObject = new Group();\n\t\tworldObject.name = this.name();\n\t\tworldObject.matrixAutoUpdate = false;\n\t\tPoly.onObjectsAddRemoveHooks.assignOnAddHookHandler(worldObject, this);\n\t\tThreejsCoreObject.addAttribute(worldObject, PhysicsIdAttribute.WORLD, this.graphNodeId());\n\n\t\tconst inputObjects = coreGroup.threejsObjects();\n\t\tfor (const inputObject of inputObjects) {\n\t\t\tworldObject.add(inputObject);\n\t\t}\n\t\tsetJointDataListForWorldObject(this.scene(), worldObject);\n\n\t\t// const {world, PhysicsLib} = await createOrFindPhysicsWorld(this, worldObject, this.pv.gravity);\n\t\t// this._PhysicsLib = PhysicsLib;\n\t\t// initCorePhysicsWorld(this._PhysicsLib, worldObject, this.scene());\n\n\t\t// if (actorNode) {\n\t\t// }\n\t\t// const objects: Object3D[] = [worldObject];\n\t\t// if (isBooleanTrue(this.pv.debug)) {\n\t\t// \t// const pair = createOrFindPhysicsDebugObject(this, world);\n\t\t// \t// updatePhysicsDebugObject(pair);\n\t\t// \tconst debugObject = physicsCreateDebugObject();\n\t\t// \tCoreObject.addAttribute(debugObject, PhysicsIdAttribute.DEBUG, this.graphNodeId());\n\t\t// \tdebugObject.name = `${this.name()}_Debug`;\n\t\t// \tobjects.push(debugObject);\n\t\t// }\n\t\tconst actorNode = this._findActorNode();\n\t\t// for (let object of objects) {\n\t\t// do not assign actor node to the debug object\n\t\tthis.scene().actorsManager.assignActorBuilder(worldObject, actorNode);\n\t\t// }\n\n\t\tthis.setObject(worldObject);\n\t}\n\tpublic override updateObjectOnAdd(object: Object3D) {\n\t\t// if (!this._PhysicsLib) {\n\t\t// \treturn;\n\t\t// }\n\t\tconst worldNodeId = ThreejsCoreObject.attribValue(object, PhysicsIdAttribute.WORLD);\n\t\tif (worldNodeId != null) {\n\t\t\tif (worldNodeId != this.graphNodeId()) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tconst worldObject = object;\n\t\t\tcreateOrFindPhysicsWorld(this, worldObject, this.pv.gravity).then(({world, PhysicsLib}) => {\n\t\t\t\tinitCorePhysicsWorld(PhysicsLib, worldObject, this.scene());\n\t\t\t\t// once world is create, try and find a sibbling that matches the debug object,\n\t\t\t\t// then updated it accordingly\n\t\t\t\tconst sibblings = worldObject.parent?.children.filter((sibbling) => sibbling.uuid != worldObject.uuid);\n\t\t\t\tif (!sibblings) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tconst debugObject = sibblings.find(\n\t\t\t\t\t(sibbling) => ThreejsCoreObject.attribValue(sibbling, PhysicsIdAttribute.DEBUG_WORLD) == worldNodeId //this.graphNodeId()\n\t\t\t\t);\n\t\t\t\tif (debugObject) {\n\t\t\t\t\tupdatePhysicsDebugObject(debugObject);\n\t\t\t\t}\n\t\t\t\t// if (isBooleanTrue(this.pv.debug)) {\n\t\t\t\t// \tconst pair = createOrFindPhysicsDebugObject(this, world);\n\t\t\t\t// \tupdatePhysicsDebugObject(pair);\n\t\t\t\t// \tobjects.push(pair.object);\n\t\t\t\t// }\n\n\t\t\t\t// for (let object of objects) {\n\t\t\t\t// \tthis.scene().actorsManager.assignActorBuilder(object, actorNode);\n\t\t\t\t// }\n\t\t\t});\n\n\t\t\t// initCorePhysicsWorld(this._PhysicsLib, object, this.scene());\n\t\t}\n\t}\n\n\tprivate _findActorNode() {\n\t\t// if (isBooleanTrue(this.pv.useThisNode)) {\n\t\treturn this;\n\t\t// } else {\n\t\t// \treturn this.pv.node.node() as ActorBuilderNode | undefined;\n\t\t// }\n\t}\n\n\t//\n\t// CHILDREN\n\t//\n\t// protected override _childrenControllerContext = NodeContext.JS;\n\t// override createNode<S extends keyof JsNodeChildrenMap>(\n\t// \tnode_class: S,\n\t// \toptions?: NodeCreateOptions\n\t// ): JsNodeChildrenMap[S];\n\t// override createNode<K extends valueof<JsNodeChildrenMap>>(\n\t// \tnode_class: Constructor<K>,\n\t// \toptions?: NodeCreateOptions\n\t// ): K;\n\t// override createNode<K extends valueof<JsNodeChildrenMap>>(\n\t// \tnode_class: Constructor<K>,\n\t// \toptions?: NodeCreateOptions\n\t// ): K {\n\t// \treturn super.createNode(node_class, options) as K;\n\t// }\n\t// override children() {\n\t// \treturn super.children() as BaseJsNodeType[];\n\t// }\n\t// override nodesByType<K extends keyof JsNodeChildrenMap>(type: K): JsNodeChildrenMap[K][] {\n\t// \treturn super.nodesByType(type) as JsNodeChildrenMap[K][];\n\t// }\n\t// override childrenAllowed() {\n\t// \treturn true;\n\t// }\n}\n\nexport function getPhysicsWorldNodeFromWorldObject(\n\tworldObject: Object3D,\n\tscene: PolyScene\n): PhysicsWorldSopNode | undefined {\n\tconst nodeId = physicsWorldNodeIdFromObject(worldObject);\n\tif (nodeId == null) {\n\t\treturn;\n\t}\n\tconst graphNode = scene.graph.nodeFromId(nodeId);\n\tif (!graphNode) {\n\t\treturn;\n\t}\n\tconst node: BaseNodeType | null = CoreType.isFunction((graphNode as BaseNodeType).context)\n\t\t? (graphNode as BaseNodeType)\n\t\t: null;\n\tif (!node) {\n\t\treturn;\n\t}\n\tif (node.context() != NodeContext.SOP) {\n\t\treturn;\n\t}\n\tif (node.type() != SopType.PHYSICS_WORLD) {\n\t\treturn;\n\t}\n\treturn node as PhysicsWorldSopNode;\n}\n","/**\n * Creates a plane.\n *\n *\n *\n */\nimport {TypedSopNode} from './_Base';\nimport {CoreGroup} from '../../../core/geometry/Group';\nimport {PlaneSopOperation} from '../../operations/sop/Plane';\nimport {NodeParamsConfig, ParamConfig} from '../utils/params/ParamsConfig';\nimport {SopType} from '../../poly/registers/nodes/types/Sop';\nconst DEFAULT = PlaneSopOperation.DEFAULT_PARAMS;\nclass PlaneSopParamsConfig extends NodeParamsConfig {\n\t/** @param size of the plane */\n\tsize = ParamConfig.VECTOR2(DEFAULT.size);\n\t/** @param defines if the plane resolution is sets via the number of segments or via the step size */\n\tuseSegmentsCount = ParamConfig.BOOLEAN(DEFAULT.useSegmentsCount);\n\t/** @param step size */\n\tstepSize = ParamConfig.FLOAT(DEFAULT.stepSize, {\n\t\trange: [0.001, 2],\n\t\trangeLocked: [false, false],\n\t\tvisibleIf: {useSegmentsCount: 0},\n\t});\n\t/** @param segments count */\n\tsegments = ParamConfig.VECTOR2(DEFAULT.segments, {visibleIf: {useSegmentsCount: 1}});\n\t/** @param axis perpendicular to the plane */\n\tdirection = ParamConfig.VECTOR3(DEFAULT.direction);\n\t/** @param center of the plane */\n\tcenter = ParamConfig.VECTOR3(DEFAULT.center);\n\t/** @param create lines instead of polygons */\n\tasLines = ParamConfig.BOOLEAN(DEFAULT.asLines);\n}\nconst ParamsConfig = new PlaneSopParamsConfig();\n\nexport class PlaneSopNode extends TypedSopNode<PlaneSopParamsConfig> {\n\toverride paramsConfig = ParamsConfig;\n\tstatic override type() {\n\t\treturn SopType.PLANE;\n\t}\n\n\toverride initializeNode() {\n\t\tthis.io.inputs.setCount(0, 1);\n\t\tthis.io.inputs.initInputsClonedState(PlaneSopOperation.INPUT_CLONED_STATE);\n\t}\n\n\tprivate _operation: PlaneSopOperation | undefined;\n\toverride cook(input_contents: CoreGroup[]) {\n\t\tthis._operation = this._operation || new PlaneSopOperation(this.scene(), this.states, this);\n\t\tconst core_group = this._operation.cook(input_contents, this.pv);\n\t\tthis.setCoreGroup(core_group);\n\t}\n}\n","/**\n * Creates a point light.\n *\n * @remarks\n * This is very similar to the [object level PointLight](https://polygonjs.com/docs/nodes/obj/PointLight), but can be more useful if you want to instanciate it or process it using other SOP nodes.\n *\n */\n\nimport {TypedSopNode} from './_Base';\nimport {CoreGroup} from '../../../core/geometry/Group';\n\nimport {NodeParamsConfig} from '../utils/params/ParamsConfig';\nimport {PointLightParamConfig} from '../../../core/lights/PointLight';\nimport {PointLightSopOperation} from '../../operations/sop/PointLight';\nimport {LightType} from '../../poly/registers/nodes/types/Light';\nclass PointLightSopParamsConfig extends PointLightParamConfig(NodeParamsConfig) {}\nconst ParamsConfig = new PointLightSopParamsConfig();\n\nexport class PointLightSopNode extends TypedSopNode<PointLightSopParamsConfig> {\n\toverride paramsConfig = ParamsConfig;\n\tstatic override type() {\n\t\treturn LightType.POINT;\n\t}\n\n\toverride initializeNode() {\n\t\tthis.io.inputs.setCount(0);\n\t}\n\n\tprivate _operation: PointLightSopOperation | undefined;\n\toverride cook(input_contents: CoreGroup[]) {\n\t\tthis._operation = this._operation || new PointLightSopOperation(this._scene, this.states, this);\n\t\tconst core_group = this._operation.cook(input_contents, this.pv);\n\t\tthis.setCoreGroup(core_group);\n\t}\n}\n","/**\n * Allows easy position of lights, or any object around another one.\n *\n * @remarks\n * This node transforms its children with latitude and longitude controls, instead of typical translate and rotate. It makes it more intuitive to position objects such as lights.\n *\n * Note that there is an equivalent node at the OBJ level\n *\n */\nimport {TypedSopNode} from './_Base';\nimport {CoreGroup} from '../../../core/geometry/Group';\nimport {PolarTransformSopOperation} from '../../operations/sop/PolarTransform';\n\nimport {NodeParamsConfig, ParamConfig} from '../utils/params/ParamsConfig';\nimport {TransformTargetType, TRANSFORM_TARGET_TYPES} from '../../../core/Transform';\nimport {SopType} from '../../poly/registers/nodes/types/Sop';\nconst DEFAULT = PolarTransformSopOperation.DEFAULT_PARAMS;\nclass PolarTransformSopParamConfig extends NodeParamsConfig {\n\t/** @param sets if this node should transform objects or geometries */\n\tapplyOn = ParamConfig.INTEGER(DEFAULT.applyOn, {\n\t\tmenu: {\n\t\t\tentries: TRANSFORM_TARGET_TYPES.map((target_type, i) => {\n\t\t\t\treturn {name: target_type, value: i};\n\t\t\t}),\n\t\t},\n\t});\n\t/** @param center of the transform */\n\tcenter = ParamConfig.VECTOR3(DEFAULT.center.toArray());\n\t/** @param moves the objects along the longitude, which is equivalent to a rotation on the y axis */\n\tlongitude = ParamConfig.FLOAT(DEFAULT.longitude, {\n\t\trange: [-360, 360],\n\t});\n\t/** @param moves the objects along the latitude, which is equivalent to a rotation on the z or x axis */\n\tlatitude = ParamConfig.FLOAT(DEFAULT.latitude, {\n\t\trange: [-180, 180],\n\t});\n\t/** @param moves the point aways from the center */\n\tdepth = ParamConfig.FLOAT(DEFAULT.depth, {\n\t\trange: [0, 10],\n\t});\n}\nconst ParamsConfig = new PolarTransformSopParamConfig();\n\nexport class PolarTransformSopNode extends TypedSopNode<PolarTransformSopParamConfig> {\n\toverride paramsConfig = ParamsConfig;\n\tstatic override type() {\n\t\treturn SopType.POLAR_TRANSFORM;\n\t}\n\n\toverride initializeNode() {\n\t\tthis.io.inputs.setCount(1);\n\t\tthis.io.inputs.initInputsClonedState(PolarTransformSopOperation.INPUT_CLONED_STATE);\n\t}\n\n\tprivate _operation: PolarTransformSopOperation | undefined;\n\toverride cook(input_contents: CoreGroup[]) {\n\t\tthis._operation = this._operation || new PolarTransformSopOperation(this.scene(), this.states, this);\n\t\tconst core_group = this._operation.cook(input_contents, this.pv);\n\t\tthis.setCoreGroup(core_group);\n\t}\n\n\tsetApplyOn(mode: TransformTargetType) {\n\t\tthis.p.applyOn.set(TRANSFORM_TARGET_TYPES.indexOf(mode));\n\t}\n}\n","/**\n * Creates a quad plane.\n *\n *\n */\nimport {Vector3, Triangle, Quaternion} from 'three';\nimport {QuadSopNode} from './_BaseQuad';\nimport {NodeParamsConfig, ParamConfig} from '../utils/params/ParamsConfig';\nimport {CoreGroup} from '../../../core/geometry/Group';\nimport {SopType} from '../../poly/registers/nodes/types/Sop';\nimport {QuadGeometry} from '../../../core/geometry/modules/quad/QuadGeometry';\nimport {Attribute} from '../../../core/geometry/Attribute';\nimport {setToArray} from '../../../core/SetUtils';\nimport {InputCloneMode} from '../../poly/InputCloneMode';\nimport {TypeAssert} from '../../poly/Assert';\nimport {typedArrayCopy} from '../../../core/ArrayUtils';\n\nconst _current = new Vector3();\nconst _neighbourAverage = new Vector3();\nconst _neighbour = new Vector3();\nconst _p0 = new Vector3();\nconst _p1 = new Vector3();\nconst _p2 = new Vector3();\nconst _p3 = new Vector3();\nconst _delta0 = new Vector3();\nconst _delta1 = new Vector3();\nconst _delta2 = new Vector3();\nconst _delta3 = new Vector3();\nconst _currentDelta0 = new Vector3();\nconst _currentDelta1 = new Vector3();\nconst _currentDelta2 = new Vector3();\nconst _currentDelta3 = new Vector3();\nconst _center = new Vector3();\nconst _triangle = new Triangle();\nconst _triangleNormal = new Vector3();\nconst _q = new Quaternion();\nconst _average = new Vector3();\nexport enum QuadSmoothMode {\n\tSQUARIFY = 'squarify',\n\tAVERAGE = 'average',\n}\nexport const QUAD_SMOOTH_MODES: QuadSmoothMode[] = [QuadSmoothMode.AVERAGE, QuadSmoothMode.SQUARIFY];\n\nclass QuadSmoothSopParamsConfig extends NodeParamsConfig {\n\t/** @param mode */\n\tmode = ParamConfig.INTEGER(QUAD_SMOOTH_MODES.indexOf(QuadSmoothMode.SQUARIFY), {\n\t\tmenu: {\n\t\t\tentries: QUAD_SMOOTH_MODES.map((name, value) => {\n\t\t\t\treturn {name, value};\n\t\t\t}),\n\t\t},\n\t});\n\t/** @param iterations */\n\titerations = ParamConfig.INTEGER(50, {\n\t\trange: [0, 100],\n\t\trangeLocked: [true, false],\n\t});\n\t/** @param strength */\n\tstrength = ParamConfig.FLOAT(1, {\n\t\trange: [0, 1],\n\t\trangeLocked: [true, true],\n\t});\n}\nconst ParamsConfig = new QuadSmoothSopParamsConfig();\n\nexport class QuadSmoothSopNode extends QuadSopNode<QuadSmoothSopParamsConfig> {\n\toverride paramsConfig = ParamsConfig;\n\tstatic override type() {\n\t\treturn SopType.QUAD_SMOOTH;\n\t}\n\n\toverride initializeNode() {\n\t\tthis.io.inputs.setCount(1);\n\t\tthis.io.inputs.initInputsClonedState(InputCloneMode.FROM_NODE);\n\t}\n\n\toverride cook(inputCoreGroups: CoreGroup[]) {\n\t\tconst coreGroup = inputCoreGroups[0];\n\t\tconst quadObjects = coreGroup.quadObjects();\n\n\t\tif (quadObjects) {\n\t\t\tfor (const object of quadObjects) {\n\t\t\t\tthis._smoothQuadGeometry(object.geometry);\n\t\t\t}\n\t\t}\n\n\t\tthis.setCoreGroup(coreGroup);\n\t}\n\tsetMode(method: QuadSmoothMode) {\n\t\tthis.p.mode.set(QUAD_SMOOTH_MODES.indexOf(method));\n\t}\n\tmode() {\n\t\treturn QUAD_SMOOTH_MODES[this.pv.mode];\n\t}\n\tprivate _smoothQuadGeometry(geometry: QuadGeometry) {\n\t\tconst mode = this.mode();\n\t\tswitch (mode) {\n\t\t\tcase QuadSmoothMode.AVERAGE:\n\t\t\t\treturn this._smoothQuadGeometryWithAverage(geometry);\n\t\t\tcase QuadSmoothMode.SQUARIFY:\n\t\t\t\treturn this._smoothQuadGeometryWithSquarify(geometry);\n\t\t}\n\t\tTypeAssert.unreachable(mode);\n\t}\n\tprivate _smoothQuadGeometryWithAverage(geometry: QuadGeometry) {\n\t\tconst position = geometry.attributes[Attribute.POSITION];\n\t\tif (!position) {\n\t\t\treturn;\n\t\t}\n\t\tconst tmpPositionArray0 = typedArrayCopy(position.array, new Float32Array(position.array.length));\n\t\tconst tmpPositionArray1 = typedArrayCopy(tmpPositionArray0, new Float32Array(position.array.length));\n\n\t\tconst index = geometry.index;\n\t\tconst quadsCount = geometry.quadsCount();\n\t\tconst adjacentIdByIndexWithSets = new Map<number, Set<number>>();\n\t\tconst quadCountByEdge = new Map<number, Map<number, Set<number>>>();\n\t\tconst _addQuadCount = (quadIndex: number, i0: number, i1: number) => {\n\t\t\tlet quadCountByEdgeEntry = quadCountByEdge.get(i0);\n\t\t\tif (!quadCountByEdgeEntry) {\n\t\t\t\tquadCountByEdgeEntry = new Map();\n\t\t\t\tquadCountByEdge.set(i0, quadCountByEdgeEntry);\n\t\t\t}\n\t\t\tlet quadIndices = quadCountByEdgeEntry.get(i1);\n\t\t\tif (!quadIndices) {\n\t\t\t\tquadIndices = new Set();\n\t\t\t}\n\t\t\tquadIndices.add(quadIndex);\n\t\t\tquadCountByEdgeEntry.set(i1, quadIndices);\n\t\t};\n\t\tconst _addAdjacency = (quadIndex: number, current: number, adjacent: number) => {\n\t\t\tlet adjacentIds = adjacentIdByIndexWithSets.get(current);\n\t\t\tif (!adjacentIds) {\n\t\t\t\tadjacentIds = new Set<number>();\n\t\t\t\tadjacentIdByIndexWithSets.set(current, adjacentIds);\n\t\t\t}\n\t\t\tadjacentIds.add(adjacent);\n\t\t\t// add quad count\n\t\t\t_addQuadCount(quadIndex, current, adjacent);\n\t\t\t_addQuadCount(quadIndex, adjacent, current);\n\t\t};\n\n\t\tfor (let i = 0; i < quadsCount; i++) {\n\t\t\tconst i4 = i * 4;\n\t\t\tconst i0 = index[i4 + 0];\n\t\t\tconst i1 = index[i4 + 1];\n\t\t\tconst i2 = index[i4 + 2];\n\t\t\tconst i3 = index[i4 + 3];\n\t\t\t// i0\n\t\t\t_addAdjacency(i, i0, i3);\n\t\t\t_addAdjacency(i, i0, i1);\n\t\t\t// i1\n\t\t\t_addAdjacency(i, i1, i0);\n\t\t\t_addAdjacency(i, i1, i2);\n\t\t\t// i2\n\t\t\t_addAdjacency(i, i2, i1);\n\t\t\t_addAdjacency(i, i2, i3);\n\t\t\t// i3\n\t\t\t_addAdjacency(i, i3, i2);\n\t\t\t_addAdjacency(i, i3, i0);\n\t\t}\n\t\tconst adjacentIdByIndex = new Map<number, number[]>();\n\t\tadjacentIdByIndexWithSets.forEach((adjacentIds, index) => {\n\t\t\tadjacentIdByIndex.set(index, setToArray(adjacentIds, []));\n\t\t});\n\t\tadjacentIdByIndexWithSets.clear();\n\n\t\t// keep track of points that are on unshared edges,\n\t\t// since we don't want to smoot those\n\t\tconst pointsOnUnsharedEdges = new Set<number>();\n\t\tadjacentIdByIndex.forEach((_, index) => {\n\t\t\tconst quadCountByEdgeEntry = quadCountByEdge.get(index);\n\t\t\tif (!quadCountByEdgeEntry) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tquadCountByEdgeEntry.forEach((quadIndices, key1) => {\n\t\t\t\tif (quadIndices.size == 1) {\n\t\t\t\t\tpointsOnUnsharedEdges.add(index);\n\t\t\t\t}\n\t\t\t});\n\t\t});\n\n\t\t// smooth\n\t\tconst iterations = this.pv.iterations;\n\t\tconst strength = this.pv.strength;\n\t\tconst lerp = 1 - strength;\n\t\tlet previousPositionArray = tmpPositionArray0;\n\t\tlet nextPositionArray = tmpPositionArray1;\n\t\tfor (let i = 0; i < iterations; i++) {\n\t\t\t// let neighboursCount=0\n\t\t\tadjacentIdByIndex.forEach((adjacentIds, index) => {\n\t\t\t\t// do not smooth if on an unshared edge\n\t\t\t\tif (pointsOnUnsharedEdges.has(index)) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\t//\n\t\t\t\t_current.fromArray(previousPositionArray, index * 3);\n\t\t\t\t// i=0\n\t\t\t\t// _sphere.center.set(_current.x, _current.y, _current.z);\n\t\t\t\t// _sphere.radius = 0;\n\t\t\t\t_neighbourAverage.set(0, 0, 0);\n\t\t\t\tfor (const adjacentId of adjacentIds) {\n\t\t\t\t\t// _neighbours[i] = _neighbours[i] || new Vector3()\n\t\t\t\t\t// const _vA = _neighbours[i]\n\t\t\t\t\t_neighbour.fromArray(previousPositionArray, adjacentId * 3);\n\t\t\t\t\t_neighbourAverage.add(_neighbour);\n\t\t\t\t\t// _sphere.expandByPoint(_neighbour);\n\t\t\t\t\t// i++\n\t\t\t\t}\n\t\t\t\t_neighbourAverage.divideScalar(adjacentIds.length);\n\t\t\t\t_neighbourAverage.lerp(_current, lerp);\n\t\t\t\t_neighbourAverage.toArray(nextPositionArray, index * 3);\n\t\t\t});\n\t\t\t// swap arrays\n\t\t\tconst tmp = nextPositionArray;\n\t\t\tnextPositionArray = previousPositionArray;\n\t\t\tpreviousPositionArray = tmp;\n\t\t}\n\n\t\t// write back to geometry\n\t\tposition.array = previousPositionArray;\n\t}\n\tprivate _smoothQuadGeometryWithSquarify(geometry: QuadGeometry) {\n\t\tconst position = geometry.attributes[Attribute.POSITION];\n\t\tif (!position) {\n\t\t\treturn;\n\t\t}\n\t\tconst iterations = this.pv.iterations;\n\t\tconst strength = this.pv.strength;\n\t\t// const lerp = 1 - strength;\n\t\tconst positionArray = position.array;\n\t\tconst pointsCount = positionArray.length / 3;\n\t\t// const tmpPositionArray0 = [...position.array];\n\t\t// const tmpPositionArray1 = [...tmpPositionArray0];\n\t\tconst deltas = new Array(positionArray.length).fill(0);\n\t\tconst deltasCount = new Array(pointsCount).fill(0);\n\n\t\t//\n\t\tconst index = geometry.index;\n\t\tconst indicesCount = index.length;\n\t\tlet previousPositionArray = positionArray; //tmpPositionArray0;\n\t\tlet nextPositionArray = positionArray; //tmpPositionArray1;\n\t\t// const quadsCount = geometry.quadsCount();\n\t\tfor (let i = 0; i < iterations; i++) {\n\t\t\tdeltas.fill(0);\n\t\t\tfor (let q = 0; q < indicesCount; q += 4) {\n\t\t\t\tconst i0 = index[q + 0];\n\t\t\t\tconst i1 = index[q + 1];\n\t\t\t\tconst i2 = index[q + 2];\n\t\t\t\tconst i3 = index[q + 3];\n\t\t\t\tconst i0_3 = i0 * 3;\n\t\t\t\tconst i1_3 = i1 * 3;\n\t\t\t\tconst i2_3 = i2 * 3;\n\t\t\t\tconst i3_3 = i3 * 3;\n\t\t\t\t_p0.fromArray(previousPositionArray, i0_3);\n\t\t\t\t_p1.fromArray(previousPositionArray, i1_3);\n\t\t\t\t_p2.fromArray(previousPositionArray, i2_3);\n\t\t\t\t_p3.fromArray(previousPositionArray, i3_3);\n\t\t\t\t_delta0.copy(_p0);\n\t\t\t\t_delta1.copy(_p1);\n\t\t\t\t_delta2.copy(_p2);\n\t\t\t\t_delta3.copy(_p3);\n\t\t\t\t_triangle.a.copy(_p0);\n\t\t\t\t_triangle.b.copy(_p1);\n\t\t\t\t_triangle.c.copy(_p2);\n\t\t\t\t_triangle.getNormal(_triangleNormal);\n\t\t\t\t_center.copy(_p0).add(_p1).add(_p2).add(_p3).multiplyScalar(0.25);\n\t\t\t\t// getCircumCenter(_p0, _p1, _p2, _p3, _center);\n\t\t\t\t// console.log('_center', _center.toArray());\n\t\t\t\t// rotate each vec\n\t\t\t\t_p0.sub(_center);\n\t\t\t\t_p1.sub(_center);\n\t\t\t\t_p2.sub(_center);\n\t\t\t\t_p3.sub(_center);\n\t\t\t\t// align all 4 vectors\n\t\t\t\t_q.setFromAxisAngle(_triangleNormal, -Math.PI * 0.5);\n\t\t\t\t_p1.applyQuaternion(_q);\n\t\t\t\t_q.setFromAxisAngle(_triangleNormal, -Math.PI * 1);\n\t\t\t\t_p2.applyQuaternion(_q);\n\t\t\t\t_q.setFromAxisAngle(_triangleNormal, -Math.PI * 1.5);\n\t\t\t\t_p3.applyQuaternion(_q);\n\t\t\t\t// get average\n\t\t\t\t_average.copy(_p0).add(_p1).add(_p2).add(_p3).multiplyScalar(0.25);\n\t\t\t\t_p0.lerp(_average, strength);\n\t\t\t\t_p1.lerp(_average, strength);\n\t\t\t\t_p2.lerp(_average, strength);\n\t\t\t\t_p3.lerp(_average, strength);\n\t\t\t\t// rotate back\n\t\t\t\t_q.setFromAxisAngle(_triangleNormal, +Math.PI * 0.5);\n\t\t\t\t_p1.applyQuaternion(_q);\n\t\t\t\t_q.setFromAxisAngle(_triangleNormal, +Math.PI * 1);\n\t\t\t\t_p2.applyQuaternion(_q);\n\t\t\t\t_q.setFromAxisAngle(_triangleNormal, +Math.PI * 1.5);\n\t\t\t\t_p3.applyQuaternion(_q);\n\t\t\t\t_p0.add(_center);\n\t\t\t\t_p1.add(_center);\n\t\t\t\t_p2.add(_center);\n\t\t\t\t_p3.add(_center);\n\n\t\t\t\t// accumulate deltas\n\t\t\t\t_delta0.sub(_p0).multiplyScalar(-1);\n\t\t\t\t_delta1.sub(_p1).multiplyScalar(-1);\n\t\t\t\t_delta2.sub(_p2).multiplyScalar(-1);\n\t\t\t\t_delta3.sub(_p3).multiplyScalar(-1);\n\t\t\t\t_currentDelta0.fromArray(deltas, i0_3);\n\t\t\t\t_currentDelta1.fromArray(deltas, i1_3);\n\t\t\t\t_currentDelta2.fromArray(deltas, i2_3);\n\t\t\t\t_currentDelta3.fromArray(deltas, i3_3);\n\t\t\t\t_delta0.add(_currentDelta0).toArray(deltas, i0_3);\n\t\t\t\t_delta1.add(_currentDelta1).toArray(deltas, i1_3);\n\t\t\t\t_delta2.add(_currentDelta2).toArray(deltas, i2_3);\n\t\t\t\t_delta3.add(_currentDelta3).toArray(deltas, i3_3);\n\t\t\t\tdeltasCount[i0]++;\n\t\t\t\tdeltasCount[i1]++;\n\t\t\t\tdeltasCount[i2]++;\n\t\t\t\tdeltasCount[i3]++;\n\n\t\t\t\t// write to array\n\t\t\t\t// _p0.toArray(nextPositionArray, index[q + 0] * 3);\n\t\t\t\t// _p1.toArray(nextPositionArray, index[q + 1] * 3);\n\t\t\t\t// _p2.toArray(nextPositionArray, index[q + 2] * 3);\n\t\t\t\t// _p3.toArray(nextPositionArray, index[q + 3] * 3);\n\t\t\t}\n\t\t\t// apply delta\n\t\t\t// console.log(deltasCount);\n\t\t\tfor (let i = 0; i < pointsCount; i++) {\n\t\t\t\tconst deltaCount = deltasCount[i];\n\t\t\t\tif (deltaCount > 0) {\n\t\t\t\t\t_current.fromArray(previousPositionArray, i * 3);\n\t\t\t\t\t_currentDelta0.fromArray(deltas, i * 3).divideScalar(deltaCount);\n\t\t\t\t\t// console.log(i, _currentDelta0.toArray());\n\t\t\t\t\t_current.add(_currentDelta0);\n\t\t\t\t\t_current.toArray(nextPositionArray, i * 3);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// swap arrays\n\t\t\t// const tmp = nextPositionArray;\n\t\t\t// nextPositionArray = previousPositionArray;\n\t\t\t// previousPositionArray = tmp;\n\t\t}\n\t\t// write back to geometry\n\t\tposition.array = previousPositionArray;\n\t}\n}\n","/**\n * Converts input QUAD objects to polygon.\n *\n *\n */\n\nimport {QuadSopNode} from './_BaseQuad';\nimport {NodeParamsConfig} from '../utils/params/ParamsConfig';\nimport {CoreGroup} from '../../../core/geometry/Group';\nimport {Object3D} from 'three';\nimport {CoreType} from '../../../core/Type';\nimport {SopType} from '../../poly/registers/nodes/types/Sop';\nimport {SOPQUADTesselationParamConfig} from '../../../core/geometry/modules/quad/utils/TesselationParamsConfig';\nimport {InputCloneMode} from '../../poly/InputCloneMode';\nclass QuadTriangulateSopParamsConfig extends SOPQUADTesselationParamConfig(NodeParamsConfig) {}\nconst ParamsConfig = new QuadTriangulateSopParamsConfig();\n\nexport class QuadTriangulateSopNode extends QuadSopNode<QuadTriangulateSopParamsConfig> {\n\toverride readonly paramsConfig = ParamsConfig;\n\tstatic override type() {\n\t\treturn SopType.QUAD_TRIANGULATE;\n\t}\n\n\tprotected override initializeNode() {\n\t\tthis.io.inputs.setCount(1);\n\t\tthis.io.inputs.initInputsClonedState(InputCloneMode.NEVER);\n\t}\n\n\toverride async cook(inputCoreGroups: CoreGroup[]) {\n\t\tconst quadObjects = inputCoreGroups[0].quadObjects();\n\t\tif (quadObjects) {\n\t\t\tconst newObjects: Object3D[] = [];\n\t\t\tfor (const quadObject of quadObjects) {\n\t\t\t\tconst objects = quadObject.toObject3D(this.pv);\n\t\t\t\tif (objects) {\n\t\t\t\t\tif (CoreType.isArray(objects)) {\n\t\t\t\t\t\tnewObjects.push(...objects);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tnewObjects.push(objects);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tthis.setObjects(newObjects);\n\t\t} else {\n\t\t\tthis.setObjects([]);\n\t\t}\n\t}\n}\n","import {PointIdPair} from './TriangleGraphCommon';\nexport class TriangleEdge {\n\tpublic triangleIds: number[] = [];\n\tconstructor(public readonly id: string, public readonly pointIdPair: PointIdPair) {}\n\taddTriangle(triangleId: number) {\n\t\tthis.triangleIds.push(triangleId);\n\t}\n}\n","import {Number3} from '../../../../../../types/GlobalTypes';\nexport class TriangleNode {\n\tconstructor(public readonly id: number, public readonly triangle: Number3) {}\n}\n","import {Number2, Number3} from '../../../../../../types/GlobalTypes';\nconst EDGES: [Number2, Number2, Number2] = [\n\t[0, 1],\n\t[1, 2],\n\t[2, 0],\n];\nexport interface PointIdPair {\n\tid0: number;\n\tid1: number;\n}\nfunction sortPointIdPair(ids: PointIdPair): PointIdPair {\n\tif (ids.id0 > ids.id1) {\n\t\tconst temp = ids.id0;\n\t\tids.id0 = ids.id1;\n\t\tids.id1 = temp;\n\t}\n\treturn ids;\n}\nexport function edgeId(ids: PointIdPair): string {\n\tsortPointIdPair(ids);\n\treturn `${ids.id0}-${ids.id1}`;\n}\nexport function triangleEdge(triangle: Number3, edgeIndex: number): PointIdPair {\n\tconst edgeIndices = EDGES[edgeIndex];\n\t// const edge: Number2 = [triangle[edgeIndices[0]], triangle[edgeIndices[1]]];\n\treturn {\n\t\tid0: triangle[edgeIndices[0]],\n\t\tid1: triangle[edgeIndices[1]],\n\t};\n}\n","import {TriangleEdge} from './TriangleEdge';\nimport {TriangleNode} from './TriangleNode';\nimport {Number3} from '../../../../../../types/GlobalTypes';\nimport {triangleEdge, edgeId} from './TriangleGraphCommon';\nimport {setToArray} from '../../../../../../core/SetUtils';\nimport {PrimitiveGraph} from '../../../../entities/primitive/PrimitiveGraph';\n\nexport class TriangleGraph extends PrimitiveGraph {\n\tprivate _nextTriangleId = -1;\n\tprivate _trianglesById: Map<number, TriangleNode> = new Map();\n\tprivate _edgesByTriangleId: Map<number, TriangleEdge[]> = new Map();\n\tprivate _edgesById: Map<string, TriangleEdge> = new Map();\n\tprivate _edgeIds: Set<string> = new Set();\n\taddTriangle(triangle: Number3): TriangleNode {\n\t\tthis._nextTriangleId++;\n\t\tconst triangleId = this._nextTriangleId;\n\t\tconst triangleNode = new TriangleNode(triangleId, triangle);\n\t\tthis._trianglesById.set(triangleId, triangleNode);\n\n\t\t// add edges\n\t\tconst edges: TriangleEdge[] = [];\n\t\tfor (let i = 0; i < 3; i++) {\n\t\t\tconst pointIdPair = triangleEdge(triangle, i);\n\t\t\tconst _edgeId = edgeId(pointIdPair);\n\t\t\tlet edge = this._edgesById.get(_edgeId);\n\t\t\tif (!edge) {\n\t\t\t\tedge = new TriangleEdge(_edgeId, pointIdPair);\n\t\t\t\tthis._edgesById.set(_edgeId, edge);\n\t\t\t}\n\t\t\tedge.addTriangle(triangleId);\n\t\t\tedges.push(edge);\n\t\t\tthis._edgeIds.add(_edgeId);\n\t\t}\n\t\tthis._edgesByTriangleId.set(triangleId, edges);\n\n\t\treturn triangleNode;\n\t}\n\tremoveTriangle(triangleId: number) {\n\t\tconst triangleNode = this._trianglesById.get(triangleId);\n\t\tif (!triangleNode) {\n\t\t\treturn;\n\t\t}\n\t\tthis._trianglesById.delete(triangleId);\n\t\tconst edges = this._edgesByTriangleId.get(triangleId);\n\t\tif (!edges) {\n\t\t\treturn;\n\t\t}\n\t\tfor (const edge of edges) {\n\t\t\tconst index = edge.triangleIds.indexOf(triangleId);\n\t\t\tif (index >= 0) {\n\t\t\t\tedge.triangleIds.splice(index, 1);\n\t\t\t}\n\t\t\tif (edge.triangleIds.length == 0) {\n\t\t\t\tthis._edgesById.delete(edge.id);\n\t\t\t\tthis._edgeIds.delete(edge.id);\n\t\t\t}\n\t\t}\n\t\tthis._edgesByTriangleId.delete(triangleId);\n\t}\n\ttraverseTriangles(callback: (triangle: TriangleNode) => void) {\n\t\tthis._trianglesById.forEach((triangle) => {\n\t\t\tcallback(triangle);\n\t\t});\n\t}\n\tedgesByTriangleId(id: number) {\n\t\treturn this._edgesByTriangleId.get(id);\n\t}\n\t// firstNeighbourId(triangleId: number): number | undefined {\n\t// \tconst edges = this._edgesByTriangleId.get(triangleId);\n\t// \tif (!edges) {\n\t// \t\treturn;\n\t// \t}\n\t// \tfor (const edge of edges) {\n\t// \t\tfor (const _triangleId of edge.triangleIds) {\n\t// \t\t\tif (_triangleId != triangleId) {\n\t// \t\t\t\treturn _triangleId;\n\t// \t\t\t}\n\t// \t\t}\n\t// \t}\n\t// }\n\ttriangle(triangleId: number) {\n\t\treturn this._trianglesById.get(triangleId);\n\t}\n\tedgeIds(target: string[]) {\n\t\treturn setToArray(this._edgeIds, target);\n\t}\n\tedge(edgeId: string) {\n\t\treturn this._edgesById.get(edgeId);\n\t}\n\toverride neighbourIndex(primitiveIndex: number, neighbourIndex: number, withSharedEdge: boolean): number {\n\t\tconsole.warn('not implemented');\n\t\treturn 0;\n\t}\n\toverride neighboursCount(primitiveIndex: number, withSharedEdge: boolean): number {\n\t\tconsole.warn('not implemented');\n\t\treturn 0;\n\t}\n}\n","import {setUnion, setToArray, setDifference} from '../../../../../SetUtils';\nimport {TriangleGraph} from './TriangleGraph';\nimport {randFloat} from '../../../../../math/_Module';\nimport {sample} from '../../../../../ArrayUtils';\n\nconst _triangleIds: Set<number> = new Set();\nconst _edgeIds0 = new Set<string>();\nconst _edgeIds1 = new Set<string>();\nconst _edgeIds2 = new Set<string>();\nconst _edgeIds3 = new Set<string>();\nconst _edgeIds10 = new Set<string>();\nconst _notVisited = new Set<string>();\nconst _edgeIdsArray: string[] = [];\n\nexport function triangleGraphExpandEdges(\n\tgraph: TriangleGraph,\n\tstartEdgeIds: Readonly<Set<string>>,\n\ttarget: Set<string>,\n\texcluded?: Readonly<Set<string>>\n) {\n\t_triangleIds.clear();\n\ttarget.clear();\n\n\tstartEdgeIds.forEach((edgeId) => {\n\t\tconst edge = graph.edge(edgeId);\n\t\tif (edge) {\n\t\t\tconst edgeTriangleIds = edge.triangleIds;\n\t\t\tfor (const triangleId of edgeTriangleIds) {\n\t\t\t\t_triangleIds.add(triangleId);\n\t\t\t}\n\t\t}\n\t});\n\n\t_triangleIds.forEach((triangleId) => {\n\t\tconst triangleEdges = graph.edgesByTriangleId(triangleId);\n\t\tif (triangleEdges) {\n\t\t\tfor (const edge of triangleEdges) {\n\t\t\t\tif (!startEdgeIds.has(edge.id) && (excluded == null || !excluded.has(edge.id))) {\n\t\t\t\t\ttarget.add(edge.id);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t});\n}\n\nexport function triangleGraphFindExpandedEdge(\n\tgraph: TriangleGraph,\n\tstartEdgeId: string,\n\tseed: number,\n\tstep: number,\n\tirregularAmount: number,\n\tvisited: Readonly<Set<string>>\n): string | undefined {\n\t_edgeIds0.clear();\n\t_edgeIds0.add(startEdgeId);\n\ttriangleGraphExpandEdges(graph, _edgeIds0, _edgeIds1);\n\ttriangleGraphExpandEdges(graph, _edgeIds1, _edgeIds2, _edgeIds0);\n\n\tconst _sampleFromEdges2 = () => {\n\t\t// console.log('2:', [...setToArray(_edgeIds2, [])].sort().join(', '));\n\t\tsetDifference(_edgeIds2, visited, _notVisited);\n\t\tsetToArray(_notVisited, _edgeIdsArray);\n\t\treturn sample(_edgeIdsArray, seed);\n\t};\n\tconst _sampleFromEdges3 = () => {\n\t\tsetUnion(_edgeIds0, _edgeIds1, _edgeIds10);\n\t\ttriangleGraphExpandEdges(graph, _edgeIds2, _edgeIds3, _edgeIds10);\n\t\t// console.log('3:', [...setToArray(_edgeIds3, [])].sort().join(', '));\n\t\tsetDifference(_edgeIds3, visited, _notVisited);\n\t\tsetToArray(_notVisited, _edgeIdsArray);\n\t\treturn sample(_edgeIdsArray, seed);\n\t};\n\n\tconst foundEdgeId = randFloat(seed + step) > irregularAmount ? _sampleFromEdges2() : _sampleFromEdges3();\n\t// if (foundEdgeId == startEdgeId) {\n\t// \tconsole.log({foundEdgeId, startEdgeId});\n\t// \tthrow 'no';\n\t// }\n\t// console.log({foundEdgeId, startEdgeId});\n\treturn foundEdgeId;\n}\n","/**\n * Creates a quad plane.\n *\n *\n */\nimport {QuadSopNode} from './_BaseQuad';\nimport {NodeParamsConfig, ParamConfig} from '../utils/params/ParamsConfig';\nimport {CoreGroup} from '../../../core/geometry/Group';\nimport {SopType} from '../../poly/registers/nodes/types/Sop';\nimport {QuadGeometry} from '../../../core/geometry/modules/quad/QuadGeometry';\nimport {Vector3, BufferGeometry, Mesh, BufferAttribute} from 'three';\nimport {Attribute} from '../../../core/geometry/Attribute';\nimport {InputCloneMode} from '../../poly/InputCloneMode';\nimport {QuadObject} from '../../../core/geometry/modules/quad/QuadObject';\nimport {Number3} from '../../../types/GlobalTypes';\nimport {sample} from '../../../core/ArrayUtils';\nimport {TriangleGraph} from '../../../core/geometry/modules/three/graph/triangle/TriangleGraph';\nimport {objectContentCopyProperties} from '../../../core/geometry/ObjectContent';\nimport {triangleGraphFindExpandedEdge} from '../../../core/geometry/modules/three/graph/triangle/TriangleGraphUtils';\n\nconst _v3 = new Vector3();\nconst _p0 = new Vector3();\nconst _p1 = new Vector3();\nconst _p2 = new Vector3();\nconst _p3 = new Vector3();\n\nclass QuadrangulateSopParamsConfig extends NodeParamsConfig {\n\t/** @param quadsCount */\n\t// quadsCount = ParamConfig.INTEGER(1, {\n\t// \trange: [0, 1000],\n\t// \trangeLocked: [true, false],\n\t// });\n\t/** @param regular */\n\tregular = ParamConfig.BOOLEAN(1);\n\t/** @param test */\n\tgranular = ParamConfig.BOOLEAN(0, {\n\t\tvisibleIf: {\n\t\t\tregular: 0,\n\t\t},\n\t});\n\t/** @param irregularAmount */\n\tirregularAmount = ParamConfig.FLOAT(1, {\n\t\trange: [0, 1],\n\t\trangeLocked: [true, true],\n\t\tvisibleIf: {\n\t\t\tgranular: 1,\n\t\t\tregular: 0,\n\t\t},\n\t});\n\t/** @param subdivide */\n\tsubdivide = ParamConfig.BOOLEAN(1, {\n\t\tvisibleIf: {\n\t\t\tregular: 0,\n\t\t},\n\t});\n\t/** @param seed */\n\tseed = ParamConfig.INTEGER(0, {\n\t\trange: [-100, 100],\n\t\trangeLocked: [false, false],\n\t\tvisibleIf: {\n\t\t\tregular: 0,\n\t\t},\n\t});\n}\nconst ParamsConfig = new QuadrangulateSopParamsConfig();\n\nexport class QuadrangulateSopNode extends QuadSopNode<QuadrangulateSopParamsConfig> {\n\toverride paramsConfig = ParamsConfig;\n\tstatic override type() {\n\t\treturn SopType.QUADRANGULATE;\n\t}\n\toverride initializeNode() {\n\t\tthis.io.inputs.setCount(1);\n\t\tthis.io.inputs.initInputsClonedState(InputCloneMode.NEVER);\n\t}\n\n\toverride cook(inputCoreGroups: CoreGroup[]) {\n\t\tconst coreGroup = inputCoreGroups[0];\n\t\tconst threejsObjects = coreGroup.threejsObjects();\n\n\t\tconst newQuadObjects: QuadObject[] = [];\n\t\t// build triangle graph\n\t\tfor (const object of threejsObjects) {\n\t\t\tconst geometry = (object as Mesh).geometry;\n\t\t\tif (geometry) {\n\t\t\t\tconst newQuadObject = this._processGeometry(geometry);\n\t\t\t\tif (newQuadObject) {\n\t\t\t\t\tobjectContentCopyProperties(object, newQuadObject);\n\t\t\t\t\tnewQuadObject.geometry.applyMatrix(object.matrix);\n\t\t\t\t\tnewQuadObjects.push(newQuadObject);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tthis.setQuadObjects(newQuadObjects);\n\t}\n\n\tprivate _processGeometry(geometry: BufferGeometry): QuadObject | undefined {\n\t\tconst index = geometry.getIndex();\n\t\tif (!index) {\n\t\t\treturn;\n\t\t}\n\t\tconst polygonsCount = index.array.length / 3;\n\t\tif (polygonsCount < 2) {\n\t\t\treturn;\n\t\t}\n\t\tconst positionAttribute = geometry.getAttribute(Attribute.POSITION);\n\t\tif (!positionAttribute) {\n\t\t\treturn;\n\t\t}\n\t\tconst {regular, granular, irregularAmount, subdivide, seed} = this.pv;\n\n\t\tconst quadGeometry = new QuadGeometry();\n\t\tconst newPositionArray = [...positionAttribute.clone().array];\n\n\t\tconst quadIndices: number[] = [];\n\n\t\tconst graph = new TriangleGraph();\n\t\tfor (let i = 0; i < polygonsCount; i++) {\n\t\t\t_v3.fromArray(index.array, i * 3);\n\t\t\tgraph.addTriangle(_v3.toArray() as Number3);\n\t\t}\n\t\tconst edgeIds: string[] = [];\n\t\tgraph.edgeIds(edgeIds);\n\t\tedgeIds.sort();\n\n\t\t//\n\t\tconst edgeCenterIndexByEdgeIndices: Map<number, Map<number, number>> = new Map();\n\t\tconst _findOrCreateEdgeCenterIndex = (i0: number, i1: number) => {\n\t\t\tconst key0 = i0 < i1 ? i0 : i1;\n\t\t\tconst key1 = i0 < i1 ? i1 : i0;\n\t\t\tlet edgeCenterIndexByEdgeIndex = edgeCenterIndexByEdgeIndices.get(key0);\n\t\t\tif (!edgeCenterIndexByEdgeIndex) {\n\t\t\t\tedgeCenterIndexByEdgeIndex = new Map();\n\t\t\t\tedgeCenterIndexByEdgeIndices.set(key0, edgeCenterIndexByEdgeIndex);\n\t\t\t}\n\t\t\tlet edgeCenterIndex = edgeCenterIndexByEdgeIndex.get(key1);\n\t\t\tif (edgeCenterIndex == null) {\n\t\t\t\t_p0.fromArray(newPositionArray, i0 * 3);\n\t\t\t\t_p1.fromArray(newPositionArray, i1 * 3);\n\t\t\t\t// add edge\n\t\t\t\t_v3.copy(_p0).add(_p1).multiplyScalar(0.5);\n\t\t\t\tedgeCenterIndex = newPositionArray.length / 3;\n\t\t\t\t_v3.toArray(newPositionArray, newPositionArray.length);\n\n\t\t\t\tedgeCenterIndexByEdgeIndex.set(key1, edgeCenterIndex);\n\t\t\t}\n\t\t\treturn edgeCenterIndex;\n\t\t};\n\n\t\tconst _completeQuadObject = () => {\n\t\t\t// if non regular, we also need to add the remaining triangles\n\t\t\tif (regular == false && subdivide) {\n\t\t\t\tgraph.traverseTriangles((triangle) => {\n\t\t\t\t\tconst i0 = triangle.triangle[0];\n\t\t\t\t\tconst i1 = triangle.triangle[1];\n\t\t\t\t\tconst i2 = triangle.triangle[2];\n\t\t\t\t\t_p0.fromArray(newPositionArray, i0 * 3);\n\t\t\t\t\t_p1.fromArray(newPositionArray, i1 * 3);\n\t\t\t\t\t_p2.fromArray(newPositionArray, i2 * 3);\n\n\t\t\t\t\t// add center\n\t\t\t\t\t_v3.copy(_p0).add(_p1).add(_p2).divideScalar(3);\n\t\t\t\t\tconst iCenter = newPositionArray.length / 3;\n\t\t\t\t\t_v3.toArray(newPositionArray, newPositionArray.length);\n\t\t\t\t\t// add edge centers\n\t\t\t\t\tconst i01 = _findOrCreateEdgeCenterIndex(i0, i1);\n\t\t\t\t\tconst i12 = _findOrCreateEdgeCenterIndex(i1, i2);\n\t\t\t\t\tconst i20 = _findOrCreateEdgeCenterIndex(i2, i0);\n\n\t\t\t\t\t// add 3 quads\n\t\t\t\t\tquadIndices.push(i0, i01, iCenter, i20);\n\t\t\t\t\tquadIndices.push(i1, i12, iCenter, i01);\n\t\t\t\t\tquadIndices.push(i2, i20, iCenter, i12);\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tconst position = new BufferAttribute(new Float32Array(newPositionArray), 3);\n\t\t\tquadGeometry.setAttribute(Attribute.POSITION, position);\n\t\t\tquadGeometry.setIndex(quadIndices);\n\t\t\tconst quadObject = new QuadObject(quadGeometry);\n\t\t\treturn quadObject;\n\t\t};\n\n\t\tconst _nextEdgeIdWithRegularMethod = () => {\n\t\t\treturn edgeIds.pop();\n\t\t};\n\t\t// let _lastRemoveTriangles: TriangeNodePair | undefined;\n\t\tlet _preparedNextEdgeId: string | undefined;\n\t\tconst visitedEdgeIds: Set<string> = new Set();\n\n\t\tconst _prepareNextEdgeId = (startEdgeId: string, step: number) => {\n\t\t\tconst foundEdgeId = triangleGraphFindExpandedEdge(\n\t\t\t\tgraph,\n\t\t\t\tstartEdgeId,\n\t\t\t\tseed,\n\t\t\t\tstep,\n\t\t\t\tirregularAmount,\n\t\t\t\tvisitedEdgeIds\n\t\t\t);\n\n\t\t\t_preparedNextEdgeId = foundEdgeId;\n\t\t};\n\t\tconst _nextEdgeIdWithIrregularMethod = (i: number) => {\n\t\t\tconst _randomSample = () => {\n\t\t\t\treturn sample(edgeIds, seed + i);\n\t\t\t};\n\t\t\tconst _sampleFromIrregularity = () => {\n\t\t\t\tif (_preparedNextEdgeId != null) {\n\t\t\t\t\treturn _preparedNextEdgeId;\n\t\t\t\t}\n\n\t\t\t\treturn _randomSample();\n\t\t\t};\n\n\t\t\tconst edgeId = granular == true ? _sampleFromIrregularity() : _randomSample();\n\t\t\tif (edgeId != null) {\n\t\t\t\tconst index = edgeIds.indexOf(edgeId);\n\n\t\t\t\tif (index < 0) {\n\t\t\t\t\tconsole.log('bad edge found', edgeId, [...edgeIds].sort().join(', '));\n\t\t\t\t\tthrow 'internal error';\n\t\t\t\t}\n\t\t\t\tedgeIds.splice(index, 1);\n\t\t\t}\n\t\t\treturn edgeId;\n\t\t};\n\n\t\tlet i = 0;\n\t\twhile (edgeIds.length > 0) {\n\t\t\ti++;\n\t\t\tconst edgeId = regular ? _nextEdgeIdWithRegularMethod() : _nextEdgeIdWithIrregularMethod(i);\n\n\t\t\tif (edgeId == null) {\n\t\t\t\treturn _completeQuadObject();\n\t\t\t}\n\n\t\t\tvisitedEdgeIds.add(edgeId);\n\n\t\t\tconst _prepareNextEdgeIdIfTest = () => {\n\t\t\t\tif (granular == true && regular == false) {\n\t\t\t\t\t_prepareNextEdgeId(edgeId, i);\n\t\t\t\t}\n\t\t\t};\n\n\t\t\tconst edge = graph.edge(edgeId);\n\t\t\tif (!edge) {\n\t\t\t\t_prepareNextEdgeIdIfTest();\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tconst triangleIds = edge.triangleIds;\n\t\t\tconst triangle0 = graph.triangle(triangleIds[0]);\n\t\t\tconst triangle1 = graph.triangle(triangleIds[1]);\n\t\t\tif (!triangle0 || !triangle1) {\n\t\t\t\t_prepareNextEdgeIdIfTest();\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t// when using irregular method,\n\t\t\t// we get the triangle neighbours now, before deleting the triangles\n\t\t\t_prepareNextEdgeIdIfTest();\n\n\t\t\t// remove triangles\n\t\t\tgraph.removeTriangle(triangle0.id);\n\t\t\tgraph.removeTriangle(triangle1.id);\n\t\t\t// create quad\n\t\t\tconst i0 = triangle0.triangle.find(\n\t\t\t\t(index) => index != edge.pointIdPair.id0 && index != edge.pointIdPair.id1\n\t\t\t)!;\n\t\t\tconst i2 = triangle1.triangle.find(\n\t\t\t\t(index) => index != edge.pointIdPair.id0 && index != edge.pointIdPair.id1\n\t\t\t)!;\n\t\t\tconst triangle0UnsharedIndexIndex = triangle0.triangle.indexOf(i0);\n\t\t\tconst triangle1UnsharedIndexIndex = triangle1.triangle.indexOf(i2);\n\t\t\tconst i1 = triangle0.triangle[(triangle0UnsharedIndexIndex + 1) % 3];\n\t\t\tconst i3 = triangle1.triangle[(triangle1UnsharedIndexIndex + 1) % 3];\n\t\t\tif (regular == true || subdivide == false) {\n\t\t\t\tquadIndices.push(i0, i1, i2, i3);\n\t\t\t} else {\n\t\t\t\t// get center and add to position\n\t\t\t\t_p0.fromArray(newPositionArray, i0 * 3);\n\t\t\t\t_p1.fromArray(newPositionArray, i1 * 3);\n\t\t\t\t_p2.fromArray(newPositionArray, i2 * 3);\n\t\t\t\t_p3.fromArray(newPositionArray, i3 * 3);\n\t\t\t\t// add center\n\t\t\t\t_v3.copy(_p0).add(_p1).add(_p2).add(_p3).multiplyScalar(0.25);\n\t\t\t\tconst iCenter = newPositionArray.length / 3;\n\t\t\t\t_v3.toArray(newPositionArray, newPositionArray.length);\n\t\t\t\t// add edge centers\n\t\t\t\tconst i01 = _findOrCreateEdgeCenterIndex(i0, i1);\n\t\t\t\tconst i12 = _findOrCreateEdgeCenterIndex(i1, i2);\n\t\t\t\tconst i23 = _findOrCreateEdgeCenterIndex(i2, i3);\n\t\t\t\tconst i30 = _findOrCreateEdgeCenterIndex(i3, i0);\n\t\t\t\t// add 4 quads\n\t\t\t\tquadIndices.push(i0, i01, iCenter, i30);\n\t\t\t\tquadIndices.push(i1, i12, iCenter, i01);\n\t\t\t\tquadIndices.push(i2, i23, iCenter, i12);\n\t\t\t\tquadIndices.push(i3, i30, iCenter, i23);\n\t\t\t}\n\t\t}\n\n\t\treturn _completeQuadObject();\n\t}\n}\n","/**\n * Projects points from the left input geometry onto the faces of the right input geometry.\n *\n */\nimport {TypedSopNode} from './_Base';\nimport {CoreGroup} from '../../../core/geometry/Group';\nimport {NodeParamsConfig, ParamConfig} from '../utils/params/ParamsConfig';\nimport {RaySopMode, RaySopOperation, RAY_SOP_MODES} from '../../operations/sop/Ray';\nimport {SopType} from '../../poly/registers/nodes/types/Sop';\nconst DEFAULT = RaySopOperation.DEFAULT_PARAMS;\n\nclass RaySopParamsConfig extends NodeParamsConfig {\n\t/** @param method used to ray points onto the collision geometry */\n\tmode = ParamConfig.INTEGER(DEFAULT.mode, {\n\t\tmenu: {\n\t\t\tentries: RAY_SOP_MODES.map((name, value) => ({name, value})),\n\t\t},\n\t});\n\t/** @param toggle on to use the normals as the ray direction */\n\tuseNormals = ParamConfig.BOOLEAN(DEFAULT.useNormals);\n\t/** @param if the normals are not used as the ray direction, this define the direction used */\n\tdirection = ParamConfig.VECTOR3(DEFAULT.direction.toArray(), {\n\t\tvisibleIf: {useNormals: 0},\n\t});\n\t/** @param moves the points or leaves them in place */\n\ttransformPoints = ParamConfig.BOOLEAN(DEFAULT.transformPoints);\n\t/** @param copies the normals from the right geometry to the left one */\n\ttransferFaceNormals = ParamConfig.BOOLEAN(DEFAULT.transferFaceNormals);\n\t/** @param adds an attribute with the distance to the hit position on the target geometry */\n\taddDistAttribute = ParamConfig.BOOLEAN(DEFAULT.addDistAttribute);\n}\nconst ParamsConfig = new RaySopParamsConfig();\n\nexport class RaySopNode extends TypedSopNode<RaySopParamsConfig> {\n\toverride paramsConfig = ParamsConfig;\n\tstatic override type() {\n\t\treturn SopType.RAY;\n\t}\n\n\toverride initializeNode() {\n\t\tthis.io.inputs.setCount(2);\n\t\tthis.io.inputs.initInputsClonedState(RaySopOperation.INPUT_CLONED_STATE);\n\t}\n\n\tprivate _operation: RaySopOperation | undefined;\n\toverride cook(inputCoreGroups: CoreGroup[]) {\n\t\tthis._operation = this._operation || new RaySopOperation(this._scene, this.states, this);\n\t\tconst coreGroup = this._operation.cook(inputCoreGroups, this.pv);\n\t\tthis.setCoreGroup(coreGroup);\n\t}\n\n\tsetMode(mode: RaySopMode) {\n\t\tthis.p.mode.set(RAY_SOP_MODES.indexOf(mode));\n\t}\n}\n","/**\n * Creates rest attributes.\n *\n */\nimport {TypedSopNode} from './_Base';\nimport {CoreGroup} from '../../../core/geometry/Group';\nimport {InputCloneMode} from '../../poly/InputCloneMode';\n\nimport {RestAttributesSopOperation} from '../../operations/sop/RestAttributes';\nimport {NodeParamsConfig, ParamConfig} from '../utils/params/ParamsConfig';\nconst DEFAULT = RestAttributesSopOperation.DEFAULT_PARAMS;\nclass RestAttributesSopParamsConfig extends NodeParamsConfig {\n\t/** @param toggle on to create a rest position */\n\ttposition = ParamConfig.BOOLEAN(DEFAULT.tposition);\n\t/** @param name of the position attribute */\n\tposition = ParamConfig.STRING(DEFAULT.position, {visibleIf: {tposition: true}});\n\t/** @param name of the rest position attribute, on which the position will be copied on */\n\trestP = ParamConfig.STRING(DEFAULT.restP, {visibleIf: {tposition: true}});\n\t/** @param toggle on to create a rest normal */\n\ttnormal = ParamConfig.BOOLEAN(DEFAULT.tnormal);\n\t/** @param name of the normal attribute */\n\tnormal = ParamConfig.STRING(DEFAULT.normal, {visibleIf: {tnormal: true}});\n\t/** @param name of the rest normal attribute, on which the normal will be copied on */\n\trestN = ParamConfig.STRING(DEFAULT.restN, {visibleIf: {tnormal: true}});\n}\nconst ParamsConfig = new RestAttributesSopParamsConfig();\n\nexport class RestAttributesSopNode extends TypedSopNode<RestAttributesSopParamsConfig> {\n\toverride paramsConfig = ParamsConfig;\n\tstatic override type() {\n\t\treturn 'restAttributes';\n\t}\n\n\toverride initializeNode() {\n\t\tthis.io.inputs.setCount(1);\n\t\tthis.io.inputs.initInputsClonedState([InputCloneMode.FROM_NODE]);\n\t}\n\n\tprivate _operation: RestAttributesSopOperation | undefined;\n\toverride cook(input_contents: CoreGroup[]) {\n\t\tthis._operation = this._operation || new RestAttributesSopOperation(this.scene(), this.states, this);\n\t\tconst core_group = this._operation.cook(input_contents, this.pv);\n\t\tthis.setCoreGroup(core_group);\n\t}\n}\n","/**\n * Sets the children\n *\n */\nimport {TypedSopNode} from './_Base';\nimport {CoreGroup} from '../../../core/geometry/Group';\nimport {SetChildrenSopOperation} from '../../operations/sop/SetChildren';\nimport {NodeParamsConfig, ParamConfig} from '../utils/params/ParamsConfig';\nimport {SopType} from '../../poly/registers/nodes/types/Sop';\nconst DEFAULT = SetChildrenSopOperation.DEFAULT_PARAMS;\nclass SetChildrenSopParamsConfig extends NodeParamsConfig {\n\tclearExistingChildren = ParamConfig.BOOLEAN(DEFAULT.clearExistingChildren);\n}\nconst ParamsConfig = new SetChildrenSopParamsConfig();\n\nexport class SetChildrenSopNode extends TypedSopNode<SetChildrenSopParamsConfig> {\n\toverride paramsConfig = ParamsConfig;\n\tstatic override type() {\n\t\treturn SopType.SET_CHILDREN;\n\t}\n\n\toverride initializeNode() {\n\t\tthis.io.inputs.setCount(2);\n\t\tthis.io.inputs.initInputsClonedState(SetChildrenSopOperation.INPUT_CLONED_STATE);\n\t}\n\n\tprivate _operation: SetChildrenSopOperation | undefined;\n\toverride cook(inputCoreGroups: CoreGroup[]) {\n\t\tthis._operation = this._operation || new SetChildrenSopOperation(this._scene, this.states, this);\n\t\tconst core_group = this._operation.cook(inputCoreGroups, this.pv);\n\t\tthis.setCoreGroup(core_group);\n\t}\n}\n","/**\n * Places the geometry of the second input into the objects of the first input.\n *\n *\n */\nimport {TypedSopNode} from './_Base';\nimport {CoreGroup} from '../../../core/geometry/Group';\nimport {SetGeometrySopOperation, SET_GEOMETRY_MODES, SetGeometryMode} from '../../operations/sop/SetGeometry';\nimport {NodeParamsConfig, ParamConfig} from '../utils/params/ParamsConfig';\nimport {SopType} from '../../poly/registers/nodes/types/Sop';\nconst DEFAULT = SetGeometrySopOperation.DEFAULT_PARAMS;\nclass SetGeometrySopParamsConfig extends NodeParamsConfig {\n\tmode = ParamConfig.INTEGER(DEFAULT.mode, {\n\t\tmenu: {\n\t\t\tentries: SET_GEOMETRY_MODES.map((name, value) => ({name, value})),\n\t\t},\n\t});\n}\nconst ParamsConfig = new SetGeometrySopParamsConfig();\n\nexport class SetGeometrySopNode extends TypedSopNode<SetGeometrySopParamsConfig> {\n\toverride paramsConfig = ParamsConfig;\n\tstatic override type() {\n\t\treturn SopType.SET_GEOMETRY;\n\t}\n\n\toverride initializeNode() {\n\t\tthis.io.inputs.setCount(2);\n\t\tthis.io.inputs.initInputsClonedState(SetGeometrySopOperation.INPUT_CLONED_STATE);\n\t}\n\tsetMode(mode: SetGeometryMode) {\n\t\tthis.p.mode.set(SET_GEOMETRY_MODES.indexOf(mode));\n\t}\n\n\tprivate _operation: SetGeometrySopOperation | undefined;\n\toverride cook(inputCoreGroups: CoreGroup[]) {\n\t\tthis._operation = this._operation || new SetGeometrySopOperation(this.scene(), this.states, this);\n\t\tconst coreGroup = this._operation.cook(inputCoreGroups, this.pv);\n\t\tthis.setCoreGroup(coreGroup);\n\t}\n}\n","import {PolyScene} from '../../../../../src/engine/scene/PolyScene';\nimport {CoreGraphNode} from './../../../../core/graph/CoreGraphNode';\n\nexport class SolverIterationStamp extends CoreGraphNode {\n\tprotected _iteration: number = 0;\n\n\tconstructor(scene: PolyScene) {\n\t\tsuper(scene, 'SolverIterationStamp');\n\t}\n\n\treset() {\n\t\tthis._iteration = 0;\n\t}\n\n\tsetIteration(iteration: number) {\n\t\tif (iteration != this._iteration) {\n\t\t\tthis._iteration = iteration;\n\t\t\tthis.setDirty();\n\t\t\tthis.removeDirtyState();\n\t\t}\n\t}\n\n\titeration() {\n\t\treturn this._iteration;\n\t}\n}\n","/**\n * A solver re-uses its output as its input on each iteration\n *\n */\nimport {BaseNodeType} from './../_Base';\nimport {SolverIterationStamp} from './utils/SolverIterationStamp';\nimport {NetworkNodeType} from './../../poly/NodeContext';\nimport {SubnetSopNodeLike, SopSubnetChildrenDisplayController} from './utils/subnet/SopSubnetChildrenDisplayController';\nimport {InputCloneMode} from '../../poly/InputCloneMode';\nimport {NodeParamsConfig, ParamConfig} from '../utils/params/ParamsConfig';\nimport {CoreGroup} from '../../../core/geometry/Group';\nimport {DisplayNodeController} from '../utils/DisplayNodeController';\n\nclass SolverSopParamsConfig extends NodeParamsConfig {\n\t/** @param number of times the nodes inside this node will process the input */\n\titerations = ParamConfig.INTEGER(2, {\n\t\trange: [0, 5],\n\t\trangeLocked: [true, false],\n\t});\n\t/** @param Currently, when the child nodes are updated, the solver node does not know that it should recook. Clicking this button forces it to recompute */\n\treload = ParamConfig.BUTTON(null, {\n\t\tcallback: (node: BaseNodeType) => {\n\t\t\tSolverSopNode.PARAM_CALLBACK_reload(node as SolverSopNode);\n\t\t},\n\t});\n}\nconst ParamsConfig = new SolverSopParamsConfig();\n\nexport class SolverSopNode extends SubnetSopNodeLike<SolverSopParamsConfig> {\n\toverride paramsConfig = ParamsConfig;\n\tstatic override type() {\n\t\treturn NetworkNodeType.SOLVER;\n\t}\n\tprivate _iterationStamp: SolverIterationStamp | undefined;\n\tpublic override readonly childrenDisplayController: SopSubnetChildrenDisplayController =\n\t\tnew SopSubnetChildrenDisplayController(this, {dependsOnDisplayNode: false});\n\tpublic override readonly displayNodeController: DisplayNodeController = new DisplayNodeController(\n\t\tthis,\n\t\t{\n\t\t\tonDisplayNodeRemove: () => {\n\t\t\t\t// this.node.setDirty();\n\t\t\t},\n\t\t\tonDisplayNodeSet: () => {\n\t\t\t\t// this.node.setDirty();\n\t\t\t},\n\t\t\tonDisplayNodeUpdate: () => {\n\t\t\t\t// this.node.setDirty();\n\t\t\t},\n\t\t},\n\t\t{dependsOnDisplayNode: false}\n\t);\n\n\toverride initializeNode() {\n\t\tthis.io.inputs.setCount(0, 4);\n\t\tthis.io.inputs.initInputsClonedState(InputCloneMode.NEVER);\n\t}\n\titerationStamp() {\n\t\treturn (this._iterationStamp = this._iterationStamp || this._createStampNode());\n\t}\n\tprivate _createStampNode() {\n\t\tconst stampNode = new SolverIterationStamp(this.scene());\n\t\t// this.dirtyController.setForbiddenTriggerNodes([stampNode]);\n\t\tstampNode.setForbiddenTriggerNodes(this);\n\t\treturn stampNode;\n\t}\n\n\tprivate _previousFrameCoreGroup: CoreGroup | undefined;\n\tpreviousFrameCoreGroup() {\n\t\treturn this._previousFrameCoreGroup;\n\t}\n\toverride async cook(inputCoreGroups: CoreGroup[]) {\n\t\tthis._reset();\n\n\t\tif (this.pv.iterations == 0) {\n\t\t\tthis.setCoreGroup(inputCoreGroups[0]);\n\t\t\treturn;\n\t\t}\n\n\t\tawait this._computeSolverMultipleTimes(this.pv.iterations);\n\t}\n\n\tprivate _reset() {\n\t\tthis._previousFrameCoreGroup = undefined;\n\n\t\tif (this.iterationStamp().iteration() == 0) {\n\t\t\tthis.iterationStamp().setIteration(-1);\n\t\t}\n\t}\n\n\tprivate async _computeSolverMultipleTimes(iterationsCount: number) {\n\t\tfor (let i = 0; i < iterationsCount; i++) {\n\t\t\tthis.iterationStamp().setIteration(i);\n\t\t\tawait this.computeSolver(i == iterationsCount - 1);\n\t\t}\n\t}\n\tprivate async computeSolver(isLastIteration: boolean) {\n\t\tconst childOutputNode = this.childrenDisplayController.outputNode();\n\t\tlet coreContent: CoreGroup | undefined;\n\t\tif (childOutputNode) {\n\t\t\tconst container = await childOutputNode.compute();\n\t\t\tcoreContent = container.coreContent();\n\t\t\tif (coreContent) {\n\t\t\t\tthis._previousFrameCoreGroup = coreContent;\n\t\t\t} else {\n\t\t\t\tif (childOutputNode.states.error.active()) {\n\t\t\t\t\tthis.states.error.set(childOutputNode.states.error.message());\n\t\t\t\t} else {\n\t\t\t\t\tthis._previousFrameCoreGroup = undefined;\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tthis.states.error.set('no output node found inside subnet');\n\t\t}\n\n\t\tif (isLastIteration) {\n\t\t\tif (coreContent) {\n\t\t\t\tthis.setCoreGroup(coreContent);\n\t\t\t} else {\n\t\t\t\tthis.setObjects([]);\n\t\t\t}\n\t\t}\n\t}\n\n\tstatic PARAM_CALLBACK_reload(node: SolverSopNode) {\n\t\tnode.param_callback_reload();\n\t}\n\tprivate param_callback_reload() {\n\t\tthis.p.iterations.setDirty();\n\t}\n}\n","/**\n * Sorts vertices\n *\n *\n */\nimport {AttribClass} from './../../../core/geometry/Constant';\nimport {TypedSopNode} from './_Base';\nimport {CoreGroup} from '../../../core/geometry/Group';\nimport {InputCloneMode} from '../../poly/InputCloneMode';\nimport {NodeParamsConfig, ParamConfig} from '../utils/params/ParamsConfig';\nimport {\n\tSortSopOperation,\n\tAXISES,\n\tSORT_MODES,\n\tSortMode,\n\tSORT_TARGET_TYPES,\n\tSortTargetType,\n} from '../../operations/sop/Sort';\nimport {SopType} from '../../poly/registers/nodes/types/Sop';\nconst DEFAULT = SortSopOperation.DEFAULT_PARAMS;\n\nclass SortSopParamsConfig extends NodeParamsConfig {\n\t/** @param defines if this node will sort points or objects */\n\ttargetType = ParamConfig.INTEGER(DEFAULT.targetType, {\n\t\tmenu: {\n\t\t\tentries: SORT_TARGET_TYPES.map((name, value) => ({name, value})),\n\t\t},\n\t});\n\t/** @param criteria used to sort */\n\tmode = ParamConfig.INTEGER(DEFAULT.mode, {\n\t\tmenu: {\n\t\t\tentries: SORT_MODES.map((name, value) => ({name, value})),\n\t\t},\n\t});\n\t/** @param seed used by the random mode */\n\tseed = ParamConfig.INTEGER(DEFAULT.seed, {\n\t\trange: [0, 100],\n\t\trangeLocked: [false, false],\n\t\tvisibleIf: {mode: SORT_MODES.indexOf(SortMode.RANDOM)},\n\t});\n\t/** @param axis along which points will be sorted */\n\taxis = ParamConfig.INTEGER(DEFAULT.axis, {\n\t\tmenu: {\n\t\t\tentries: AXISES.map((name, value) => {\n\t\t\t\treturn {name, value};\n\t\t\t}),\n\t\t},\n\t\tvisibleIf: {mode: SORT_MODES.indexOf(SortMode.AXIS)},\n\t});\n\t/** @param attribute */\n\tattribute = ParamConfig.STRING(DEFAULT.attribute, {\n\t\tvisibleIf: {mode: SORT_MODES.indexOf(SortMode.ATTRIBUTE)},\n\t});\n\t/** @param invert the sort */\n\tinvert = ParamConfig.BOOLEAN(DEFAULT.invert);\n}\nconst ParamsConfig = new SortSopParamsConfig();\n\nexport class SortSopNode extends TypedSopNode<SortSopParamsConfig> {\n\toverride paramsConfig = ParamsConfig;\n\tstatic override type() {\n\t\treturn SopType.SORT;\n\t}\n\n\toverride initializeNode() {\n\t\tthis.io.inputs.setCount(1);\n\t\tthis.io.inputs.initInputsClonedState([InputCloneMode.FROM_NODE]);\n\t}\n\n\tprivate _operation: SortSopOperation | undefined;\n\toverride cook(inputCoreGroups: CoreGroup[]) {\n\t\tthis._operation = this._operation || new SortSopOperation(this._scene, this.states, this);\n\t\tconst coreGroup = this._operation.cook(inputCoreGroups, this.pv);\n\t\tthis.setCoreGroup(coreGroup);\n\t}\n\n\tsetAttribClass(attribClass: SortTargetType) {\n\t\tif (SORT_TARGET_TYPES.includes(attribClass)) {\n\t\t\tthis.p.targetType.set(SORT_TARGET_TYPES.indexOf(attribClass));\n\t\t} else {\n\t\t\tconsole.warn(`${attribClass} is not possible on this node`);\n\t\t}\n\t}\n\tattribClass() {\n\t\treturn SORT_TARGET_TYPES[this.pv.targetType];\n\t}\n\tsetSortMode(mode: SortMode) {\n\t\tthis.p.mode.set(SORT_MODES.indexOf(mode));\n\t}\n\tsetTargetType(targetType: AttribClass.POINT | AttribClass.OBJECT) {\n\t\tthis.p.targetType.set(SORT_TARGET_TYPES.indexOf(targetType));\n\t}\n}\n","/**\n * Creates a sphere.\n *\n * @remarks\n * If the node has no input, you can control the radius and center of the sphere. If the node has an input, it will create a sphere that encompasses the input geometry.\n *\n */\n\nimport {TypedSopNode} from './_Base';\nimport {SphereSopOperation, SPHERE_TYPES, SPHERE_TYPE} from '../../operations/sop/Sphere';\nimport {CoreGroup} from '../../../core/geometry/Group';\n\nimport {NodeParamsConfig, ParamConfig} from '../utils/params/ParamsConfig';\nimport {SopType} from '../../poly/registers/nodes/types/Sop';\nconst DEFAULT = SphereSopOperation.DEFAULT_PARAMS;\nconst step = 0.00001;\nclass SphereSopParamsConfig extends NodeParamsConfig {\n\t/** @param type of sphere (default sphere or isocahedron) */\n\ttype = ParamConfig.INTEGER(DEFAULT.type, {\n\t\tmenu: {\n\t\t\tentries: SPHERE_TYPES.map((name) => {\n\t\t\t\treturn {name: name, value: SPHERE_TYPE[name]};\n\t\t\t}),\n\t\t},\n\t});\n\t/** @param radius of the sphere when the type is default */\n\tradius = ParamConfig.FLOAT(DEFAULT.radius, {\n\t\trange: [0, 2],\n\t\trangeLocked: [true, false],\n\t});\n\t/** @param resolution - number of segments in x and y */\n\tresolution = ParamConfig.VECTOR2(DEFAULT.resolution, {visibleIf: {type: SPHERE_TYPE.default}});\n\t/** @param if set to 1, you can then set the phiStart, phi_end, thetaStart and theta_end */\n\topen = ParamConfig.BOOLEAN(DEFAULT.open, {visibleIf: {type: SPHERE_TYPE.default}});\n\t/** @param start of phi angle */\n\tphiStart = ParamConfig.FLOAT(DEFAULT.phiStart, {\n\t\trange: [0, Math.PI * 2],\n\t\tvisibleIf: {type: SPHERE_TYPE.default, open: true},\n\t\tstep,\n\t});\n\t/** @param length of phi opening */\n\tphiLength = ParamConfig.FLOAT('$PI*2', {\n\t\trange: [0, Math.PI * 2],\n\t\tvisibleIf: {type: SPHERE_TYPE.default, open: true},\n\t\tstep,\n\t});\n\t/** @param start of theta angle */\n\tthetaStart = ParamConfig.FLOAT(DEFAULT.thetaStart, {\n\t\trange: [0, Math.PI],\n\t\tvisibleIf: {type: SPHERE_TYPE.default, open: true},\n\t\tstep,\n\t});\n\t/** @param length of theta opening */\n\tthetaLength = ParamConfig.FLOAT('$PI', {\n\t\trange: [0, Math.PI],\n\t\tvisibleIf: {type: SPHERE_TYPE.default, open: true},\n\t\tstep,\n\t});\n\t/** @param resolution of the sphere when the type is isocahedron */\n\tdetail = ParamConfig.INTEGER(DEFAULT.detail, {\n\t\trange: [0, 5],\n\t\trangeLocked: [true, false],\n\t\tvisibleIf: {type: SPHERE_TYPE.isocahedron},\n\t});\n\t/** @param center of the sphere */\n\tcenter = ParamConfig.VECTOR3(DEFAULT.center);\n\t/** @param create lines instead of polygons */\n\tasLines = ParamConfig.BOOLEAN(DEFAULT.asLines);\n}\nconst ParamsConfig = new SphereSopParamsConfig();\n\nexport class SphereSopNode extends TypedSopNode<SphereSopParamsConfig> {\n\toverride paramsConfig = ParamsConfig;\n\tstatic override type() {\n\t\treturn SopType.SPHERE;\n\t}\n\n\toverride initializeNode() {\n\t\tthis.io.inputs.setCount(0, 1);\n\t\tthis.io.inputs.initInputsClonedState(SphereSopOperation.INPUT_CLONED_STATE);\n\t}\n\n\tprivate _operation: SphereSopOperation | undefined;\n\toverride cook(input_contents: CoreGroup[]) {\n\t\tthis._operation = this._operation || new SphereSopOperation(this.scene(), this.states, this);\n\t\tconst core_group = this._operation.cook(input_contents, this.pv);\n\t\tthis.setCoreGroup(core_group);\n\t}\n}\n","/**\n * Splits a geometry into multiple objects\n *\n * @remarks\n * This is useful to isolate parts of a geometry that matches a specific attribute.\n *\n */\n\nimport {TypedSopNode} from './_Base';\nimport {\n\tAttribSize,\n\tATTRIBUTE_TYPES,\n\tAttribType,\n\tAttribTypeMenuEntries,\n\tobjectTypeFromObject,\n} from '../../../core/geometry/Constant';\nimport {CoreGroup} from '../../../core/geometry/Group';\nimport {Object3D} from 'three';\nimport {NodeParamsConfig, ParamConfig} from '../utils/params/ParamsConfig';\nimport {ThreejsCoreObject} from '../../../core/geometry/modules/three/ThreejsCoreObject';\nimport {BaseCorePoint, CorePoint} from '../../../core/geometry/entities/point/CorePoint';\nimport {MapUtils} from '../../../core/MapUtils';\nimport {geometryBuilder} from '../../../core/geometry/modules/three/builders/geometryBuilder';\nimport {SopType} from '../../poly/registers/nodes/types/Sop';\nimport {pointsFromObject} from '../../../core/geometry/entities/point/CorePointUtils';\nimport {CoreObjectType} from '../../../core/geometry/ObjectContent';\n\nconst _points: CorePoint<CoreObjectType>[] = [];\nclass SplitSopParamsConfig extends NodeParamsConfig {\n\t/** @param type of attribute to use */\n\tattribType = ParamConfig.INTEGER(ATTRIBUTE_TYPES.indexOf(AttribType.NUMERIC), {\n\t\tmenu: {\n\t\t\tentries: AttribTypeMenuEntries,\n\t\t},\n\t});\n\t/** @param name of the attribute */\n\tattribName = ParamConfig.STRING('');\n}\nconst ParamsConfig = new SplitSopParamsConfig();\n\nexport class SplitSopNode extends TypedSopNode<SplitSopParamsConfig> {\n\toverride paramsConfig = ParamsConfig;\n\tstatic override type() {\n\t\treturn SopType.SPLIT;\n\t}\n\n\toverride initializeNode() {\n\t\tthis.io.inputs.setCount(1);\n\t}\n\n\tprivate _newObjects: Object3D[] = [];\n\toverride cook(input_contents: CoreGroup[]) {\n\t\tconst core_group = input_contents[0];\n\n\t\tthis._newObjects.length = 0;\n\t\tif (this.pv.attribName != '') {\n\t\t\tthis._split_core_group(core_group);\n\t\t}\n\n\t\tthis.setObjects(this._newObjects);\n\t}\n\n\t_split_core_group(core_group: CoreGroup) {\n\t\tconst core_objects = core_group.threejsCoreObjects();\n\t\tfor (let core_object of core_objects) {\n\t\t\tthis._split_core_object(core_object);\n\t\t}\n\t}\n\n\tprivate _split_core_object(coreObject: ThreejsCoreObject) {\n\t\tconst object = coreObject.object();\n\t\tlet attribName: string = this.pv.attribName;\n\t\tconst pointsByValue: Map<string | number, BaseCorePoint[]> = new Map();\n\t\t// if (core_geometry) {\n\t\t// const object = core_object.object() as Object3DWithGeometry;\n\t\tpointsFromObject(object, _points);\n\t\tconst firstPoint = _points[0];\n\t\tif (firstPoint) {\n\t\t\tconst attribSize = firstPoint.attribSize(attribName);\n\t\t\tif (!(attribSize == AttribSize.FLOAT || firstPoint.isAttribIndexed(attribName))) {\n\t\t\t\tthis.states.error.set(`attrib '${attribName}' must be a float or a string`);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tlet val: string | number | null;\n\t\t\tif (firstPoint.isAttribIndexed(attribName)) {\n\t\t\t\tfor (const point of _points) {\n\t\t\t\t\tval = point.indexedAttribValue(attribName);\n\t\t\t\t\tMapUtils.pushOnArrayAtEntry(pointsByValue, val, point);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tfor (const point of _points) {\n\t\t\t\t\tval = point.attribValue(attribName) as number;\n\t\t\t\t\tMapUtils.pushOnArrayAtEntry(pointsByValue, val, point);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tconst objectType = objectTypeFromObject(object);\n\t\tif (objectType) {\n\t\t\tpointsByValue.forEach((points, value) => {\n\t\t\t\tconst builder = geometryBuilder(objectType);\n\t\t\t\tif (builder) {\n\t\t\t\t\tconst newGeometry = builder.fromPoints(object, points);\n\t\t\t\t\tif (newGeometry) {\n\t\t\t\t\t\tconst object = this.createObject(newGeometry, objectType);\n\t\t\t\t\t\tif (object) {\n\t\t\t\t\t\t\tThreejsCoreObject.addAttribute(object, attribName, value);\n\t\t\t\t\t\t\tthis._newObjects.push(object);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t\t// }\n\t}\n}\n","/**\n * Fetches the input from a parent subnet node.\n *\n * @remarks\n * Can only be created inside a subnet SOP.\n *\n */\nimport {TypedSopNode} from './_Base';\nimport {NodeParamsConfig, ParamConfig} from '../utils/params/ParamsConfig';\nimport {BaseNodeType} from '../_Base';\nimport {CoreGraphNode} from '../../../core/graph/CoreGraphNode';\nimport {NetworkChildNodeType} from '../../poly/NodeContext';\nclass SubnetInputSopParamsConfig extends NodeParamsConfig {\n\t/** @param sets which input of the parent subnet node is used */\n\tinput = ParamConfig.INTEGER(0, {\n\t\trange: [0, 3],\n\t\trangeLocked: [true, true],\n\t\tcallback: (node: BaseNodeType) => {\n\t\t\tSubnetInputSopNode.PARAM_CALLBACK_reset(node as SubnetInputSopNode);\n\t\t},\n\t});\n}\nconst ParamsConfig = new SubnetInputSopParamsConfig();\n\nexport class SubnetInputSopNode extends TypedSopNode<SubnetInputSopParamsConfig> {\n\toverride paramsConfig = ParamsConfig;\n\tstatic override type() {\n\t\treturn NetworkChildNodeType.INPUT;\n\t}\n\n\tprivate _currentParentInputGraphNode: CoreGraphNode | undefined;\n\n\toverride initializeNode() {\n\t\tthis.io.inputs.setCount(0);\n\n\t\tthis.lifecycle.onAfterAdded(() => {\n\t\t\tthis._setParentInputDependency();\n\t\t});\n\t}\n\n\toverride async cook() {\n\t\tconst inputIndex = this.pv.input;\n\t\tconst parent = this.parent();\n\t\tif (!parent) {\n\t\t\tthis.states.error.set(`subnet input has no parent`);\n\t\t\treturn this.cookController.endCook();\n\t\t}\n\t\tif (!parent.io.inputs.hasInput(inputIndex)) {\n\t\t\tthis.states.error.set(`parent has no input ${inputIndex}`);\n\t\t\treturn this.cookController.endCook();\n\t\t}\n\t\tconst container = await parent.containerController.requestInputContainer(inputIndex);\n\t\tif (!container) {\n\t\t\tthis.states.error.set(`input invalid ${inputIndex}`);\n\t\t\treturn this.cookController.endCook();\n\t\t}\n\t\tconst coreGroup = container.coreContent();\n\t\tif (!coreGroup) {\n\t\t\tthis.states.error.set(`input invalid ${inputIndex}`);\n\t\t\treturn this.cookController.endCook();\n\t\t}\n\t\tthis.setCoreGroup(coreGroup);\n\t}\n\n\tstatic PARAM_CALLBACK_reset(node: SubnetInputSopNode) {\n\t\tnode._setParentInputDependency();\n\t}\n\tprivate _setParentInputDependency() {\n\t\tif (this._currentParentInputGraphNode) {\n\t\t\tthis.removeGraphInput(this._currentParentInputGraphNode);\n\t\t}\n\n\t\tconst parent = this.parent();\n\t\tif (parent) {\n\t\t\tthis._currentParentInputGraphNode = parent.io.inputs.inputGraphNode(this.pv.input);\n\t\t\tthis.addGraphInput(this._currentParentInputGraphNode);\n\t\t}\n\t}\n}\n","/**\n * Creates tangents\n *\n */\n\nimport {TypedSopNode} from './_Base';\nimport {CoreGroup} from '../../../core/geometry/Group';\nimport {TangentSopOperation, TANGENT_MODES, TangentMode} from '../../operations/sop/Tangent';\nimport {NodeParamsConfig, ParamConfig} from '../utils/params/ParamsConfig';\nimport {SopType} from '../../poly/registers/nodes/types/Sop';\nconst DEFAULT = TangentSopOperation.DEFAULT_PARAMS;\nclass TangentSopParamsConfig extends NodeParamsConfig {\n\t/** @param select which objects this applies the actor behavior to */\n\tgroup = ParamConfig.STRING(DEFAULT.group, {\n\t\tobjectMask: true,\n\t});\n\t/** @param mode */\n\tmode = ParamConfig.INTEGER(DEFAULT.mode, {\n\t\tmenu: {\n\t\t\tentries: TANGENT_MODES.map((name, value) => ({name, value})),\n\t\t},\n\t});\n\t/** @param closed */\n\tclosed = ParamConfig.BOOLEAN(DEFAULT.closed, {\n\t\tvisibleIf: {mode: TANGENT_MODES.indexOf(TangentMode.CURVE)},\n\t});\n\t/** @param tangent attribute name */\n\ttangentName = ParamConfig.STRING(DEFAULT.tangentName, {\n\t\tvisibleIf: {mode: TANGENT_MODES.indexOf(TangentMode.CURVE)},\n\t});\n}\nconst ParamsConfig = new TangentSopParamsConfig();\n\nexport class TangentSopNode extends TypedSopNode<TangentSopParamsConfig> {\n\toverride readonly paramsConfig = ParamsConfig;\n\tstatic override type() {\n\t\treturn SopType.TANGENT;\n\t}\n\n\tprotected override initializeNode() {\n\t\tthis.io.inputs.setCount(0, 1);\n\t\tthis.io.inputs.initInputsClonedState(TangentSopOperation.INPUT_CLONED_STATE);\n\t}\n\n\tprivate _operation: TangentSopOperation | undefined;\n\toverride cook(inputCoreGroups: CoreGroup[]) {\n\t\tthis._operation = this._operation || new TangentSopOperation(this._scene, this.states, this);\n\t\tconst coreGroup = this._operation.cook(inputCoreGroups, this.pv);\n\t\tthis.setCoreGroup(coreGroup);\n\t}\n\tsetMode(mode: TangentMode) {\n\t\tthis.p.mode.set(TANGENT_MODES.indexOf(mode));\n\t}\n}\n","import {Number3} from '../../../../../types/GlobalTypes';\nimport {Tetrahedron} from '../TetCommon';\n\nexport function sortedNumber3(index0: number, index1: number, index2: number, target: Number3) {\n\tif (index0 < index1) {\n\t\tif (index1 < index2) {\n\t\t\ttarget[0] = index0;\n\t\t\ttarget[1] = index1;\n\t\t\ttarget[2] = index2;\n\t\t} else {\n\t\t\tif (index0 < index2) {\n\t\t\t\ttarget[0] = index0;\n\t\t\t\ttarget[1] = index2;\n\t\t\t\ttarget[2] = index1;\n\t\t\t} else {\n\t\t\t\ttarget[0] = index2;\n\t\t\t\ttarget[1] = index0;\n\t\t\t\ttarget[2] = index1;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tif (index0 < index2) {\n\t\t\ttarget[0] = index1;\n\t\t\ttarget[1] = index0;\n\t\t\ttarget[2] = index2;\n\t\t} else {\n\t\t\tif (index1 < index2) {\n\t\t\t\ttarget[0] = index1;\n\t\t\t\ttarget[1] = index2;\n\t\t\t\ttarget[2] = index0;\n\t\t\t} else {\n\t\t\t\ttarget[0] = index2;\n\t\t\t\ttarget[1] = index1;\n\t\t\t\ttarget[2] = index0;\n\t\t\t}\n\t\t}\n\t}\n}\n\nexport function sortedIndices(tetrahedron: Tetrahedron, facePointIndices: Number3, target: Number3) {\n\tconst index0 = tetrahedron.pointIds[facePointIndices[0]];\n\tconst index1 = tetrahedron.pointIds[facePointIndices[1]];\n\tconst index2 = tetrahedron.pointIds[facePointIndices[2]];\n\t// const tmp = [index0, index1, index2].sort((a, b) => a - b);\n\t// target[0] = tmp[0];\n\t// target[1] = tmp[1];\n\t// target[2] = tmp[2];\n\t// return;\n\tsortedNumber3(index0, index1, index2, target);\n}\n","import {TetGeometry} from '../TetGeometry';\nimport {sortedNumber3} from './sortedIndices';\nimport {TET_FACE_POINT_INDICES, Tetrahedron} from '../TetCommon';\nimport {Number3} from '../../../../../types/GlobalTypes';\n\nconst _sortedIndices: Number3 = [0, 0, 0];\nconst _sortedIndicesNeighbour: Number3 = [0, 0, 0];\n\nexport function updateTetNeighboursFromNewTet(tetGeometry: TetGeometry, tet: Tetrahedron) {\n\tfor (let id0 = 0; id0 < 4; id0++) {\n\t\tconst sharedPoint = tet.pointIds[id0];\n\t\tconst tetsSharingPoint = tetGeometry.tetrahedronsByPointId.get(sharedPoint);\n\t\tlet faceIndex = 0;\n\t\tfor (const facePointIndices of TET_FACE_POINT_INDICES) {\n\t\t\tif (!tetsSharingPoint) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tsortedNumber3(\n\t\t\t\ttet.pointIds[facePointIndices[0]],\n\t\t\t\ttet.pointIds[facePointIndices[1]],\n\t\t\t\ttet.pointIds[facePointIndices[2]],\n\t\t\t\t_sortedIndices\n\t\t\t);\n\t\t\tconst [pt0, pt1, pt2] = _sortedIndices;\n\t\t\ttetsSharingPoint.forEach((tetId) => {\n\t\t\t\tif (tetId == tet.id) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tconst tetSharingPoint = tetGeometry.tetrahedrons.get(tetId);\n\t\t\t\tif (!tetSharingPoint) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tlet faceIndexNeighbour = 0;\n\t\t\t\tfor (const facePointIndicesNeighbour of TET_FACE_POINT_INDICES) {\n\t\t\t\t\tsortedNumber3(\n\t\t\t\t\t\ttetSharingPoint.pointIds[facePointIndicesNeighbour[0]],\n\t\t\t\t\t\ttetSharingPoint.pointIds[facePointIndicesNeighbour[1]],\n\t\t\t\t\t\ttetSharingPoint.pointIds[facePointIndicesNeighbour[2]],\n\t\t\t\t\t\t_sortedIndicesNeighbour\n\t\t\t\t\t);\n\t\t\t\t\tconst [ptN0, ptN1, ptN2] = _sortedIndicesNeighbour;\n\n\t\t\t\t\tif (pt0 == ptN0 && pt1 == ptN1 && pt2 == ptN2) {\n\t\t\t\t\t\ttet.neighbours[faceIndex] = {id: tetSharingPoint.id, faceIndex: faceIndexNeighbour};\n\t\t\t\t\t\ttetSharingPoint.neighbours[faceIndexNeighbour] = {id: tet.id, faceIndex: faceIndex};\n\t\t\t\t\t}\n\n\t\t\t\t\tfaceIndexNeighbour++;\n\t\t\t\t}\n\n\t\t\t\t// if(tetSharingPoint.pointIds.includes(tet.pointIds[facePointIndices[1]]) && tetSharingPoint.pointIds.includes(tet.pointIds[facePointIndices[2]])){\n\t\t\t\t// \ttet.neighbours[faceIndex] = {tetSharingPoint.id}\n\t\t\t\t// }\n\t\t\t});\n\t\t\tfaceIndex++;\n\t\t}\n\t}\n}\n\nexport function tetNeighbour(tetGeometry: TetGeometry, tetId: number, faceIndex: number) {\n\tconst tetrahedron = tetGeometry.tetrahedrons.get(tetId);\n\tif (!tetrahedron) {\n\t\treturn;\n\t}\n\treturn tetrahedron.neighbours[faceIndex]?.id;\n}\n","import {TET_FACE_POINT_INDICES} from '../TetCommon';\nimport {TetGeometry} from '../TetGeometry';\nimport {Triangle} from 'three';\n\nexport function tetFaceTriangle(tetGeometry: TetGeometry, tetId: number, faceIndex: number, target: Triangle) {\n\tconst tetrahedron = tetGeometry.tetrahedrons.get(tetId);\n\tif (!tetrahedron) {\n\t\treturn;\n\t}\n\n\tconst facePointIndices = TET_FACE_POINT_INDICES[faceIndex];\n\tconst id0 = tetrahedron.pointIds[facePointIndices[0]];\n\tconst id1 = tetrahedron.pointIds[facePointIndices[1]];\n\tconst id2 = tetrahedron.pointIds[facePointIndices[2]];\n\tconst pt0 = tetGeometry.points.get(id0);\n\tconst pt1 = tetGeometry.points.get(id1);\n\tconst pt2 = tetGeometry.points.get(id2);\n\tif (!(pt0 && pt1 && pt2)) {\n\t\treturn;\n\t}\n\ttarget.a.copy(pt0.position);\n\ttarget.b.copy(pt1.position);\n\ttarget.c.copy(pt2.position);\n}\n","import {Number4} from '../../../../types/GlobalTypes';\nimport {mapFirstKey} from '../../../MapUtils';\nimport {\n\tTetrahedronPoint,\n\tTetrahedron,\n\tTetNeighbourData,\n\tTetNeighbourDatas,\n\tTetNeighbourDataWithSource,\n\tTET_FACE_POINT_INDICES,\n} from './TetCommon';\nimport {updateTetNeighboursFromNewTet} from './utils/tetNeighboursHelper';\nimport {Vector3, Triangle, Matrix4, Box3, Sphere} from 'three';\nimport {circumSphere} from './utils/tetSphere';\nimport {tetFaceTriangle} from './utils/tetTriangle';\nimport {logRedBg} from '../../../logger/Console';\nimport {objectCloneDeep} from '../../../ObjectUtils';\nconst _triangle = new Triangle();\nconst _triangleNormal = new Vector3();\nconst _newPointDelta = new Vector3();\n\nexport class TetGeometry {\n\tpublic readonly tetrahedrons: Map<number, Tetrahedron> = new Map();\n\tpublic readonly points: Map<number, TetrahedronPoint> = new Map();\n\tpublic readonly tetrahedronsByPointId: Map<number, Set<number>> = new Map();\n\tprivate _nextPointId = -1;\n\tprivate _nextTetId = -1;\n\tprivate _pointsCount = 0;\n\tprivate _tetsCount = 0;\n\tprivate _lastAddedTetId: number | null = null;\n\tpublic userData: {[key: string]: any} = {};\n\n\taddPoint(x: number, y: number, z: number) {\n\t\tthis._nextPointId++;\n\t\tconst id = this._nextPointId;\n\t\tconst point: TetrahedronPoint = {\n\t\t\tid,\n\t\t\tposition: new Vector3(x, y, z),\n\t\t};\n\t\tthis._pointsCount++;\n\t\tthis.points.set(point.id, point);\n\n\t\treturn id;\n\t}\n\tremovePoint(pointId: number) {\n\t\tthis.points.delete(pointId);\n\t\tthis.tetrahedronsByPointId.delete(pointId);\n\t\tthis._pointsCount--;\n\t}\n\n\tpointsCount() {\n\t\treturn this._pointsCount;\n\t}\n\ttetsCount() {\n\t\treturn this._tetsCount;\n\t}\n\n\tfirstTetId() {\n\t\treturn mapFirstKey(this.tetrahedrons);\n\t}\n\tlastAddedTetId() {\n\t\treturn this._lastAddedTetId;\n\t}\n\n\taddTetrahedron(p0: number, p1: number, p2: number, p3: number) {\n\t\tif (p0 == p1 || p0 == p2 || p0 == p3 || p1 == p2 || p1 == p3 || p2 == p3) {\n\t\t\tconsole.warn('tetrahedron has duplicate points', p0, p1, p2, p3);\n\t\t\treturn;\n\t\t}\n\t\tthis._nextTetId++;\n\t\tconst id = this._nextTetId;\n\t\tconst _circumSphere = {center: new Vector3(), radius: 0};\n\t\tcircumSphere(this, p0, p1, p2, p3, _circumSphere);\n\t\tconst tetrahedron: Tetrahedron = {\n\t\t\tid,\n\t\t\tpointIds: [p0, p1, p2, p3],\n\t\t\tneighbours: [null, null, null, null],\n\t\t\tsphere: _circumSphere,\n\t\t\tdisposed: false,\n\t\t};\n\t\tthis.tetrahedrons.set(tetrahedron.id, tetrahedron);\n\t\tthis._tetsCount++;\n\t\tthis._lastAddedTetId = tetrahedron.id;\n\n\t\t// update point keys\n\t\tfor (const p of tetrahedron.pointIds) {\n\t\t\tlet tetrahedrons = this.tetrahedronsByPointId.get(p);\n\t\t\tif (!tetrahedrons) {\n\t\t\t\ttetrahedrons = new Set();\n\t\t\t\tthis.tetrahedronsByPointId.set(p, tetrahedrons);\n\t\t\t}\n\t\t\ttetrahedrons.add(tetrahedron.id);\n\t\t}\n\t\t// update neighbours\n\t\tupdateTetNeighboursFromNewTet(this, tetrahedron);\n\t\treturn id;\n\t}\n\tremoveTets(\n\t\ttetIds: number[],\n\t\tsharedFacesNeighbourData?: Set<TetNeighbourDataWithSource>,\n\t\tnewPointPosition?: Vector3\n\t) {\n\t\tif (sharedFacesNeighbourData && newPointPosition) {\n\t\t\tsharedFacesNeighbourData.clear();\n\n\t\t\t// 1. store neighbours for future tet reconstruction\n\t\t\tfor (const tetId of tetIds) {\n\t\t\t\tconst tetrahedron = this.tetrahedrons.get(tetId);\n\t\t\t\tif (!tetrahedron) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tlet faceIndex = 0;\n\t\t\t\tfor (const neighbourData of tetrahedron.neighbours) {\n\t\t\t\t\t// if the neighbour is not one of the removed tets,\n\t\t\t\t\t// we can add it\n\t\t\t\t\tif (neighbourData == null || !tetIds.includes(neighbourData.id)) {\n\t\t\t\t\t\tlet faceAvailableOnSideOfNewPoint = true;\n\t\t\t\t\t\tif (neighbourData && neighbourData.id != null) {\n\t\t\t\t\t\t\ttetFaceTriangle(this, neighbourData.id, neighbourData.faceIndex, _triangle);\n\t\t\t\t\t\t\t_triangle.getNormal(_triangleNormal);\n\t\t\t\t\t\t\t_newPointDelta.copy(_triangle.a).sub(newPointPosition);\n\t\t\t\t\t\t\tif (_triangleNormal.dot(_newPointDelta) > 0) {\n\t\t\t\t\t\t\t\t// logRedBg(`nope:${tetId}`);\n\t\t\t\t\t\t\t\tfaceAvailableOnSideOfNewPoint = false;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (faceAvailableOnSideOfNewPoint) {\n\t\t\t\t\t\t\tconst pointIndices = TET_FACE_POINT_INDICES[faceIndex];\n\t\t\t\t\t\t\tsharedFacesNeighbourData.add({\n\t\t\t\t\t\t\t\t// faceIndex,\n\t\t\t\t\t\t\t\tpointIds: [\n\t\t\t\t\t\t\t\t\ttetrahedron.pointIds[pointIndices[0]],\n\t\t\t\t\t\t\t\t\ttetrahedron.pointIds[pointIndices[1]],\n\t\t\t\t\t\t\t\t\ttetrahedron.pointIds[pointIndices[2]],\n\t\t\t\t\t\t\t\t],\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tfaceIndex++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// 2. remove tets\n\t\tfor (const tetId of tetIds) {\n\t\t\tconst tetrahedron = this.tetrahedrons.get(tetId);\n\t\t\tif (!tetrahedron) {\n\t\t\t\tlogRedBg(`tet not found:${tetId} (${tetIds})`);\n\t\t\t\tthrow `removeTets: tet not found ${tetId}`;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t// update point keys\n\t\t\tfor (const pointId of tetrahedron.pointIds) {\n\t\t\t\tconst tetrahedrons = this.tetrahedronsByPointId.get(pointId);\n\t\t\t\tif (tetrahedrons) {\n\t\t\t\t\ttetrahedrons.delete(tetrahedron.id);\n\t\t\t\t\t// DO not remove points here,\n\t\t\t\t\t// as they are still needed later\n\t\t\t\t\t// if (tetrahedrons.size == 0) {\n\t\t\t\t\t// \tthis._removePoint(pointId);\n\t\t\t\t\t// }\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// remove neighbours\n\t\t\tfor (const neighbourData of tetrahedron.neighbours) {\n\t\t\t\tif (neighbourData != null) {\n\t\t\t\t\tconst neighbourTet = this.tetrahedrons.get(neighbourData.id);\n\t\t\t\t\tif (neighbourTet) {\n\t\t\t\t\t\tconst neighbourFaceIndex = neighbourData.faceIndex;\n\t\t\t\t\t\t// remove from neighbour\n\t\t\t\t\t\tneighbourTet.neighbours[neighbourFaceIndex] = null;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// remove\n\t\t\ttetrahedron.disposed = true;\n\t\t\tthis.tetrahedrons.delete(tetId);\n\t\t\tthis._tetsCount--;\n\t\t}\n\t}\n\n\tclone(): this {\n\t\tconst clonedGeometry = new TetGeometry();\n\n\t\tthis.points.forEach((point, id) => {\n\t\t\tclonedGeometry.points.set(id, {\n\t\t\t\tid: point.id,\n\t\t\t\tposition: point.position.clone(),\n\t\t\t});\n\t\t});\n\t\tthis.tetrahedrons.forEach((tetrahedron, id) => {\n\t\t\tclonedGeometry.tetrahedrons.set(id, {\n\t\t\t\tid: tetrahedron.id,\n\t\t\t\tpointIds: tetrahedron.pointIds.map((id) => id) as Number4,\n\t\t\t\tneighbours: tetrahedron.neighbours.map((d) => {\n\t\t\t\t\tif (!d) {\n\t\t\t\t\t\treturn null;\n\t\t\t\t\t}\n\t\t\t\t\tconst tetNeighbourData: TetNeighbourData = {\n\t\t\t\t\t\tid: d.id,\n\t\t\t\t\t\tfaceIndex: d.faceIndex,\n\t\t\t\t\t};\n\t\t\t\t\treturn tetNeighbourData;\n\t\t\t\t}) as TetNeighbourDatas,\n\t\t\t\tsphere: {\n\t\t\t\t\tcenter: tetrahedron.sphere.center.clone(),\n\t\t\t\t\tradius: tetrahedron.sphere.radius,\n\t\t\t\t},\n\t\t\t\tdisposed: tetrahedron.disposed,\n\t\t\t});\n\t\t});\n\t\tthis.tetrahedronsByPointId.forEach((tetrahedrons, id) => {\n\t\t\tclonedGeometry.tetrahedronsByPointId.set(id, new Set(tetrahedrons));\n\t\t});\n\t\tclonedGeometry._nextPointId = this._nextPointId;\n\t\tclonedGeometry._nextTetId = this._nextTetId;\n\t\tclonedGeometry._pointsCount = this._pointsCount;\n\t\tclonedGeometry._tetsCount = this._tetsCount;\n\t\tclonedGeometry._lastAddedTetId = this._lastAddedTetId;\n\n\t\tclonedGeometry.userData = objectCloneDeep(this.userData);\n\n\t\treturn clonedGeometry as this;\n\t}\n\n\tapplyMatrix4(matrix: Matrix4) {\n\t\tthis.points.forEach((point) => {\n\t\t\tpoint.position.applyMatrix4(matrix);\n\t\t});\n\t\tthis.tetrahedrons.forEach((tetrahedron) => {\n\t\t\tcircumSphere(\n\t\t\t\tthis,\n\t\t\t\ttetrahedron.pointIds[0],\n\t\t\t\ttetrahedron.pointIds[1],\n\t\t\t\ttetrahedron.pointIds[2],\n\t\t\t\ttetrahedron.pointIds[3],\n\t\t\t\ttetrahedron.sphere\n\t\t\t);\n\t\t});\n\t}\n\tboundingBox(target: Box3): void {\n\t\tthis.points.forEach((point) => {\n\t\t\ttarget.expandByPoint(point.position);\n\t\t});\n\t}\n\tboundingSphere(target: Sphere): void {\n\t\tthis.points.forEach((point) => {\n\t\t\ttarget.expandByPoint(point.position);\n\t\t});\n\t}\n}\n","import {Vector3, Ray, Triangle} from 'three';\nimport {TetGeometry} from '../TetGeometry';\nimport {tetCenter} from './tetCenter';\nimport {tetFaceTriangle} from './tetTriangle';\nimport {tetNeighbour} from './tetNeighboursHelper';\n\nconst _ray = new Ray();\nconst _triangle = new Triangle();\nconst _intersectionTarget = new Vector3();\n\nfunction findNextFaceIndex(\n\ttetGeometry: TetGeometry,\n\ttetIndex: number,\n\tray: Ray,\n\tintersectionTarget: Vector3\n): number | null {\n\tfor (let faceIndex = 0; faceIndex < 4; faceIndex++) {\n\t\ttetFaceTriangle(tetGeometry, tetIndex, faceIndex, _triangle);\n\t\tconst intersection = ray.intersectTriangle(_triangle.c, _triangle.b, _triangle.a, false, intersectionTarget);\n\t\tif (intersection != null) {\n\t\t\t// if we have an intersection, we check that the distance to it is less than the ray length\n\t\t\tif (intersection.distanceTo(ray.origin) <= ray.direction.length()) {\n\t\t\t\treturn faceIndex;\n\t\t\t}\n\t\t}\n\t}\n\treturn null;\n}\n\n// export function _findTetContainingPosition(\n// \ttetGeometry: TetGeometry,\n// \tposition: Vector3,\n// \tcurrentTetId: number = 0,\n// \trayOrigin?: Vector3\n// ): number | undefined {\n// \tconsole.log('findTetContainingPosition', {currentTetId, pos: position.toArray().join(',')});\n// \tif (!rayOrigin) {\n// \t\ttetCenter(tetGeometry, currentTetId, ray.origin);\n// \t} else {\n// \t\tray.origin.copy(rayOrigin);\n// \t}\n// \tray.direction.copy(position).sub(ray.origin);\n\n// \tconst nextFaceIndex = findNextFaceIndex(tetGeometry, currentTetId, ray);\n// \tconsole.log({currentTetId, nextFaceIndex});\n// \tif (nextFaceIndex == null) {\n// \t\treturn currentTetId;\n// \t}\n// \tconst nextTet = tetNeighbour(tetGeometry, currentTetId, nextFaceIndex);\n// \tconsole.log({nextTet});\n// \tif (nextTet != null) {\n// \t\treturn _findTetContainingPosition(tetGeometry, position, nextTet, intersectionTarget);\n// \t}\n// }\n\nfunction selectRandomUnvisitedTet(tetGeometry: TetGeometry, visitedTets: Set<number>) {\n\tlet selectedTetId: number | null = null;\n\ttetGeometry.tetrahedrons.forEach((tet, tetId) => {\n\t\tif (!visitedTets.has(tetId)) {\n\t\t\tselectedTetId = tetId;\n\t\t}\n\t});\n\treturn selectedTetId;\n}\n\n// const MAX_ITERATIONS = 100;\n// const rayOrigin = new Vector3()\nconst _stack = new Set<number>();\nexport function findTetContainingPosition(\n\ttetGeometry: TetGeometry,\n\tposition: Vector3,\n\trayOrigin: Vector3,\n\ttetIdOrigin: number\n\t// maxIterations:number\n) {\n\t_stack.clear();\n\tlet foundTetId: number = tetIdOrigin;\n\t_stack.add(foundTetId);\n\tlet i = 0;\n\t// tetCenter(tetGeometry, currentTetId, _ray.origin);\n\t_ray.origin.copy(rayOrigin);\n\t_ray.direction.copy(position).sub(_ray.origin);\n\tconst maxIterations = tetGeometry.tetsCount();\n\twhile (i < maxIterations) {\n\t\tconst nextFaceIndex = findNextFaceIndex(tetGeometry, foundTetId, _ray, _intersectionTarget);\n\t\tif (nextFaceIndex == null) {\n\t\t\t// foundTetId = currentTetId;\n\t\t\tbreak;\n\t\t}\n\n\t\tconst nextTetId = tetNeighbour(tetGeometry, foundTetId, nextFaceIndex);\n\t\tif (nextTetId == null) {\n\t\t\t// if we reach a tet that has no neighbour,\n\t\t\t// we restart from a random other tet\n\t\t\t// that has not yet been visited\n\t\t\tconst selectedTetId = selectRandomUnvisitedTet(tetGeometry, _stack);\n\t\t\tif (selectedTetId != null) {\n\t\t\t\tfoundTetId = selectedTetId;\n\t\t\t}\n\t\t} else {\n\t\t\tfoundTetId = nextTetId;\n\t\t}\n\t\t_stack.add(foundTetId);\n\n\t\t// update ray\n\t\ttetCenter(tetGeometry, foundTetId, _ray.origin);\n\t\t// _ray.origin.copy(_intersectionTarget);\n\t\t_ray.direction.copy(position).sub(_ray.origin);\n\n\t\ti++;\n\t}\n\n\t// console.log('end', {i, foundTetId});\n\treturn foundTetId;\n}\n","import {Vector3, Triangle} from 'three';\nimport {MeshWithBVHGeometry} from '../../../bvh/ThreeMeshBVHHelper';\nimport {TetGeometry} from '../TetGeometry';\nimport {TET_VERTICES_V_BASE, TetNeighbourDataWithSource} from '../TetCommon';\nimport {findTetContainingPosition} from './findTetContainingPosition';\nimport {tetCenter} from './tetCenter';\nimport {findNonDelaunayTetsFromSinglePointCheck} from './findNonDelaunayTets';\nimport {isPositionInsideMesh} from './tetInsideMesh';\nimport {setFirstValue} from '../../../../SetUtils';\nimport {tetRemoveUnusedPoints} from './tetRemoveUnusedPoints';\nimport {jitterOffset} from '../../../operation/Jitter';\nimport {setToArray} from '../../../../SetUtils';\nimport {tetQuality} from './tetQuality';\n\nconst _v = new Vector3();\nconst _jitterOffset = new Vector3();\nconst _bboxSize = new Vector3();\nconst _triangle = new Triangle();\nconst _faceNormal = new Vector3();\nconst _newPtDelta = new Vector3();\nconst _containingTetSearchRayOrigin = new Vector3();\nconst sharedFacesNeighbourData: Set<TetNeighbourDataWithSource> = new Set();\nconst invalidTets: number[] = [];\nconst jitterMult = new Vector3(1, 1, 1);\n\nexport type TetEdge = [number, number, number, number];\n\n// export enum PointsTraversalMethod {\n// \tMERGE = 'merge',\n// \tMESH_FIRST = 'mesh first',\n// \tADDITIONAL_FIRST = 'additional first',\n// }\n// export const POINTS_TRAVERSAL_METHODS: PointsTraversalMethod[] = [\n// \tPointsTraversalMethod.MERGE,\n// \tPointsTraversalMethod.MESH_FIRST,\n// \tPointsTraversalMethod.ADDITIONAL_FIRST,\n// ];\n\ninterface TetrahedralizeOptions {\n\tmesh: MeshWithBVHGeometry;\n\tjitterAmount: number;\n\tinnerPointsResolution: number;\n\tminQuality: number;\n\tstage: number | null;\n\tdeleteOutsideTets: boolean;\n}\n\nfunction addPoint(\n\ttetGeometry: TetGeometry,\n\tnewPointPosition: Vector3,\n\tsearchStartPosition: Vector3,\n\ttetIdOrigin: number,\n\tstage: number | null\n) {\n\t// 1. find tetrahedron containing the point\n\tconst tetId = findTetContainingPosition(tetGeometry, newPointPosition, searchStartPosition, tetIdOrigin);\n\tif (tetId == null) {\n\t\treturn;\n\t}\n\n\t// 2. find tetrahedrons that violate delaunay condition\n\tfindNonDelaunayTetsFromSinglePointCheck(tetGeometry, tetId, newPointPosition, invalidTets);\n\n\t// 3. remove tetrahedrons\n\ttetGeometry.removeTets(invalidTets, sharedFacesNeighbourData, newPointPosition);\n\t_stage++;\n\tif (stage != null && _stage > stage) {\n\t\treturn tetGeometry;\n\t}\n\n\t// 4. replace with new tetrahedrons\n\tconst pointId = tetGeometry.addPoint(newPointPosition.x, newPointPosition.y, newPointPosition.z);\n\n\tsharedFacesNeighbourData.forEach((sharedFacesNeighbourData) => {\n\t\t_stage++;\n\t\tif (stage != null && _stage > stage) {\n\t\t\treturn tetGeometry;\n\t\t}\n\t\tconst id0 = sharedFacesNeighbourData.pointIds[0];\n\t\tconst id1 = sharedFacesNeighbourData.pointIds[1];\n\t\tconst id2 = sharedFacesNeighbourData.pointIds[2];\n\t\tconst pt0 = tetGeometry.points.get(id0);\n\t\tconst pt1 = tetGeometry.points.get(id1);\n\t\tconst pt2 = tetGeometry.points.get(id2);\n\t\t// check that we orient the tetrahedron correctly\n\t\tif (pt0 && pt1 && pt2) {\n\t\t\t_triangle.a.copy(pt0.position);\n\t\t\t_triangle.b.copy(pt1.position);\n\t\t\t_triangle.c.copy(pt2.position);\n\t\t\t_triangle.getNormal(_faceNormal);\n\t\t\t_newPtDelta.copy(newPointPosition).sub(_triangle.a);\n\t\t\tconst dot = _newPtDelta.dot(_faceNormal);\n\t\t\tif (dot > 0) {\n\t\t\t\ttetGeometry.addTetrahedron(id0, id1, id2, pointId);\n\t\t\t} else {\n\t\t\t\ttetGeometry.addTetrahedron(pointId, id0, id1, id2);\n\t\t\t}\n\t\t}\n\t});\n\tif (stage != null && _stage > stage) {\n\t\treturn tetGeometry;\n\t}\n}\n\nconst _outsideTestPos = new Vector3();\ninterface FinalizeOptions {\n\ttetGeometry: TetGeometry;\n\tmesh: MeshWithBVHGeometry;\n\tdeleteOutsideTets: boolean;\n\tminQuality: number;\n}\nconst _tetIds: number[] = [];\n\nfunction finalize(options: FinalizeOptions): TetGeometry {\n\tconst {tetGeometry, mesh, deleteOutsideTets, minQuality} = options;\n\n\tconst idsToDelete: Set<number> = new Set();\n\tif (minQuality > 0) {\n\t\ttetGeometry.tetrahedrons.forEach((tet, tetId) => {\n\t\t\tif (tetQuality(tetGeometry, tetId) < minQuality) {\n\t\t\t\tidsToDelete.add(tetId);\n\t\t\t}\n\t\t});\n\t}\n\tif (deleteOutsideTets) {\n\t\ttetGeometry.tetrahedrons.forEach((tet, tetId) => {\n\t\t\ttetCenter(tetGeometry, tetId, _outsideTestPos);\n\t\t\tconst isInside = isPositionInsideMesh(_outsideTestPos, mesh, 0.001);\n\t\t\tif (!isInside) {\n\t\t\t\tidsToDelete.add(tetId);\n\t\t\t}\n\t\t});\n\t}\n\tsetToArray(idsToDelete, _tetIds);\n\ttetGeometry.removeTets(_tetIds);\n\treturn tetRemoveUnusedPoints(tetGeometry);\n}\n\nfunction prepareInputPoints(options: TetrahedralizeOptions): Vector3[] {\n\tconst {mesh, innerPointsResolution, jitterAmount} = options;\n\tconst {geometry} = mesh;\n\tconst inputPoints: Vector3[] = [];\n\n\tconst geoPositionAttribute = geometry.attributes.position;\n\tconst pointsCount = geoPositionAttribute.count;\n\tfor (let i = 0; i < pointsCount; i++) {\n\t\tconst newPos = new Vector3();\n\t\tnewPos.fromBufferAttribute(geoPositionAttribute, i);\n\t\tinputPoints.push(newPos);\n\t}\n\n\tgeometry.computeBoundingBox();\n\tif (!geometry.boundingBox) {\n\t\treturn inputPoints;\n\t}\n\tconst {min} = geometry.boundingBox;\n\tgeometry.boundingBox.getSize(_bboxSize);\n\n\tconst minDim = Math.min(_bboxSize.x, _bboxSize.y, _bboxSize.z);\n\tconst minStep = minDim / innerPointsResolution;\n\n\tlet i = 0;\n\tfor (let xi = 0; xi < innerPointsResolution; xi++) {\n\t\tfor (let yi = 0; yi < innerPointsResolution; yi++) {\n\t\t\tfor (let zi = 0; zi < innerPointsResolution; zi++) {\n\t\t\t\tjitterOffset(i, 11, jitterMult, jitterAmount, _jitterOffset);\n\t\t\t\t_v.set(xi, yi, zi).divideScalar(innerPointsResolution).multiply(_bboxSize).add(min).add(_jitterOffset);\n\n\t\t\t\tif (isPositionInsideMesh(_v, mesh, minStep)) {\n\t\t\t\t\tinputPoints.push(_v.clone());\n\t\t\t\t}\n\t\t\t\ti++;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn inputPoints;\n}\nfunction getNearestPoint(inputPoints: Set<Vector3>, inputPoint: Vector3) {\n\tlet nearestPoint: Vector3 | undefined;\n\tlet nearestDistance = Infinity;\n\tinputPoints.forEach((point) => {\n\t\tconst distance = point.distanceTo(inputPoint);\n\t\tif (distance < nearestDistance) {\n\t\t\tnearestDistance = distance;\n\t\t\tnearestPoint = point;\n\t\t}\n\t});\n\treturn nearestPoint;\n}\n\nlet _stage = 0;\nexport function tetrahedralize(options: TetrahedralizeOptions): TetGeometry {\n\t_stage = 0;\n\tconst {mesh, stage, deleteOutsideTets, minQuality} = options;\n\tconst {geometry} = mesh;\n\tconst tetGeometry = new TetGeometry();\n\n\tgeometry.computeBoundingSphere();\n\tconst radius = geometry.boundingSphere?.radius || 1;\n\n\t// 1. add encompassing tet\n\tconst s = 5.0 * radius;\n\t_v.copy(TET_VERTICES_V_BASE[0]).multiplyScalar(s);\n\tconst id0 = tetGeometry.addPoint(_v.x, _v.y, _v.z);\n\t_v.copy(TET_VERTICES_V_BASE[1]).multiplyScalar(s);\n\tconst id1 = tetGeometry.addPoint(_v.x, _v.y, _v.z);\n\t_v.copy(TET_VERTICES_V_BASE[2]).multiplyScalar(s);\n\tconst id2 = tetGeometry.addPoint(_v.x, _v.y, _v.z);\n\t_v.copy(TET_VERTICES_V_BASE[3]).multiplyScalar(s);\n\tconst id3 = tetGeometry.addPoint(_v.x, _v.y, _v.z);\n\tconst firstTetId = tetGeometry.addTetrahedron(id0, id1, id2, id3);\n\tif (firstTetId == null) {\n\t\treturn tetGeometry;\n\t}\n\t_stage++;\n\tif (stage != null && _stage > stage) {\n\t\treturn finalize({tetGeometry, mesh, deleteOutsideTets, minQuality});\n\t}\n\n\t// 2. sort input points\n\tconst inputPoints = new Set(prepareInputPoints(options));\n\n\t// 3. add points inside\n\ttetCenter(tetGeometry, firstTetId, _containingTetSearchRayOrigin);\n\tlet tetIdOrigin = firstTetId;\n\n\tlet inputPoint = setFirstValue(inputPoints);\n\twhile (inputPoint != null) {\n\t\taddPoint(tetGeometry, inputPoint, _containingTetSearchRayOrigin, tetIdOrigin, stage);\n\n\t\t// use center of last added tet as ray origin for next search\n\t\tconst lastAddedTetId = tetGeometry.lastAddedTetId();\n\t\tif (lastAddedTetId != null) {\n\t\t\ttetCenter(tetGeometry, lastAddedTetId, _containingTetSearchRayOrigin);\n\t\t\ttetIdOrigin = lastAddedTetId;\n\t\t}\n\n\t\t_stage++;\n\t\tif (stage != null && _stage > stage) {\n\t\t\treturn finalize({tetGeometry, mesh, deleteOutsideTets, minQuality});\n\t\t}\n\t\t// get nearest point\n\t\tinputPoints.delete(inputPoint);\n\t\tinputPoint = getNearestPoint(inputPoints, inputPoint);\n\t}\n\n\treturn finalize({tetGeometry, mesh, deleteOutsideTets, minQuality});\n}\n","/**\n * Converts an input geometry to tetrahedrons\n *\n *\n *\n */\nimport {TetSopNode} from './_BaseTet';\nimport {NodeParamsConfig, ParamConfig} from '../utils/params/ParamsConfig';\nimport {SopType} from '../../poly/registers/nodes/types/Sop';\nimport {CoreGroup} from '../../../core/geometry/Group';\nimport {tetrahedralize} from '../../../core/geometry/modules/tet/utils/tetrahedralize';\nimport {TetGeometry} from '../../../core/geometry/modules/tet/TetGeometry';\nimport {MeshWithBVHGeometry, ThreeMeshBVHHelper} from '../../../core/geometry/bvh/ThreeMeshBVHHelper';\nimport {Mesh, Vector3} from 'three';\nimport {mergeFaces} from '../../../core/geometry/operation/Fuse';\nimport {jitterPositions} from '../../../core/geometry/operation/Jitter';\n\nconst jitterMult = new Vector3(1, 1, 1);\nclass TetrahedralizeSopParamsConfig extends NodeParamsConfig {\n\tfuseDist = ParamConfig.FLOAT(0.001);\n\tjitter = ParamConfig.FLOAT(0.001);\n\tinnerPointsResolution = ParamConfig.INTEGER(5, {\n\t\trange: [0, 10],\n\t});\n\tminQuality = ParamConfig.FLOAT(0.25, {\n\t\trange: [0, 1],\n\t\trangeLocked: [true, true],\n\t});\n\tstepByStep = ParamConfig.BOOLEAN(0, {\n\t\tseparatorBefore: true,\n\t});\n\tstep = ParamConfig.INTEGER(-1, {\n\t\trange: [-1, 5000],\n\t\trangeLocked: [true, false],\n\t\tvisibleIf: {stepByStep: 1},\n\t});\n\tdeleteOutsideTets = ParamConfig.BOOLEAN(1, {\n\t\tvisibleIf: {stepByStep: 1},\n\t});\n}\nconst ParamsConfig = new TetrahedralizeSopParamsConfig();\n\nexport class TetrahedralizeSopNode extends TetSopNode<TetrahedralizeSopParamsConfig> {\n\toverride paramsConfig = ParamsConfig;\n\tstatic override type() {\n\t\treturn SopType.TETRAHEDRALIZE;\n\t}\n\n\toverride initializeNode() {\n\t\tthis.io.inputs.setCount(1);\n\t}\n\n\toverride cook(inputCoreGroups: CoreGroup[]) {\n\t\tconst coreGroup = inputCoreGroups[0];\n\t\tconst inputMeshes = coreGroup.threejsObjectsWithGeo() as Mesh[];\n\n\t\tfor (const inputMesh of inputMeshes) {\n\t\t\tmergeFaces(inputMesh.geometry, this.pv.fuseDist);\n\t\t}\n\t\tjitterPositions(coreGroup, {\n\t\t\tamount: this.pv.jitter,\n\t\t\tmult: jitterMult,\n\t\t\tseed: 0,\n\t\t});\n\n\t\tconst tetGeometries: TetGeometry[] = [];\n\t\tfor (const inputMesh of inputMeshes) {\n\t\t\tThreeMeshBVHHelper.assignDefaultBVHIfNone(inputMesh);\n\t\t\tconst tetGeometry = tetrahedralize({\n\t\t\t\tmesh: inputMesh as MeshWithBVHGeometry,\n\t\t\t\tjitterAmount: this.pv.jitter,\n\t\t\t\tinnerPointsResolution: this.pv.innerPointsResolution,\n\t\t\t\tminQuality: this.pv.minQuality,\n\t\t\t\tstage: this.pv.stepByStep ? (this.pv.step >= 0 ? this.pv.step : null) : null,\n\t\t\t\tdeleteOutsideTets: this.pv.stepByStep ? this.pv.deleteOutsideTets : true,\n\t\t\t});\n\t\t\ttetGeometries.push(tetGeometry);\n\t\t}\n\n\t\tthis.setTetGeometries(tetGeometries);\n\t}\n}\n","import {PolyhedronBufferGeometry} from './Polyhedron';\n\n// from three/src/geometries/TetrahedronGeometry\nexport class TetrahedronBufferGeometry extends PolyhedronBufferGeometry {\n\toverride parameters: any; //{radius: number, detail:number}\n\tconstructor(radius: number, detail: number, points_only: boolean) {\n\t\tconst vertices = [1, 1, 1, -1, -1, 1, -1, 1, -1, 1, -1, -1];\n\n\t\tconst indices = [2, 1, 0, 0, 3, 2, 1, 3, 0, 2, 3, 1];\n\n\t\tsuper(vertices, indices, radius, detail, points_only);\n\n\t\t(this as any).type = 'TetrahedronBufferGeometry';\n\n\t\tthis.parameters = {\n\t\t\tradius: radius,\n\t\t\tdetail: detail,\n\t\t};\n\t}\n}\n","/**\n * Creates a tetrahedron\n *\n *\n *\n */\nimport {TypedSopNode} from './_Base';\nimport {TetrahedronBufferGeometry} from '../../../core/geometry/operation/Tetrahedron';\nimport {NodeParamsConfig, ParamConfig} from '../utils/params/ParamsConfig';\nimport {ObjectType} from '../../../core/geometry/Constant';\nimport {SopType} from '../../poly/registers/nodes/types/Sop';\nclass TetrahedronSopParamsConfig extends NodeParamsConfig {\n\t/** @param radius of the tetrahedron */\n\tradius = ParamConfig.FLOAT(1);\n\t/** @param resolution of the tetrahedron */\n\tdetail = ParamConfig.INTEGER(0, {\n\t\trange: [0, 10],\n\t\trangeLocked: [true, false],\n\t});\n\t/** @param sets to create only points */\n\tpointsOnly = ParamConfig.BOOLEAN(0);\n\t/** @param center of the tetrahedron */\n\tcenter = ParamConfig.VECTOR3([0, 0, 0]);\n}\nconst ParamsConfig = new TetrahedronSopParamsConfig();\n\nexport class TetrahedronSopNode extends TypedSopNode<TetrahedronSopParamsConfig> {\n\toverride paramsConfig = ParamsConfig;\n\tstatic override type() {\n\t\treturn SopType.TETRAHEDRON;\n\t}\n\n\toverride cook() {\n\t\tconst pointsOnly = this.pv.pointsOnly;\n\t\tconst geometry = new TetrahedronBufferGeometry(this.pv.radius, this.pv.detail, pointsOnly);\n\t\tgeometry.translate(this.pv.center.x, this.pv.center.y, this.pv.center.z);\n\t\tif (pointsOnly) {\n\t\t\tconst object = this.createObject(geometry, ObjectType.POINTS);\n\t\t\tthis.setObject(object);\n\t\t} else {\n\t\t\tgeometry.computeVertexNormals();\n\t\t\tthis.setGeometry(geometry);\n\t\t}\n\t}\n}\n","/**\n * Applies multiple rotations with one node\n *\n *\n *\n */\nimport {TypedSopNode} from './_Base';\nimport {CoreGroup, Object3DWithGeometry} from '../../../core/geometry/Group';\nimport {\n\tCoreTransform,\n\tROTATION_ORDERS,\n\tRotationOrder,\n\tTransformTargetType,\n\tTRANSFORM_TARGET_TYPES,\n} from '../../../core/Transform';\nimport {InputCloneMode} from '../../poly/InputCloneMode';\nimport {Vector3} from 'three';\nimport {ParamOptions, MenuNumericParamOptions, VisibleIfParamOptions} from '../../params/utils/OptionsController';\n\nconst max_transform_count = 6;\nconst ROT_ORDER_DEFAULT = ROTATION_ORDERS.indexOf(RotationOrder.XYZ);\nconst ROT_ORDER_MENU_ENTRIES: MenuNumericParamOptions = {\n\tmenu: {\n\t\tentries: ROTATION_ORDERS.map((order, v) => {\n\t\t\treturn {name: order, value: v};\n\t\t}),\n\t},\n};\nfunction visible_for_count(count: number): ParamOptions {\n\tconst list: VisibleIfParamOptions[] = [];\n\tfor (let i = count + 1; i <= max_transform_count; i++) {\n\t\tlist.push({\n\t\t\tcount: i,\n\t\t});\n\t}\n\treturn {\n\t\tvisibleIf: list,\n\t};\n}\n\ntype VectorNumberParamPair = [Vector3Param, IntegerParam];\n\nimport {NodeParamsConfig, ParamConfig} from '../utils/params/ParamsConfig';\nimport {IntegerParam} from '../../params/Integer';\nimport {Vector3Param} from '../../params/Vector3';\nimport {TypeAssert} from '../../poly/Assert';\nimport {Object3D} from 'three';\nimport {BufferAttribute} from 'three';\nimport {CoreAttribute, Attribute} from '../../../core/geometry/Attribute';\nimport {SopType} from '../../poly/registers/nodes/types/Sop';\nclass TransformMultiSopParamConfig extends NodeParamsConfig {\n\t/** @param defines if this applies to objects or geometries */\n\tapplyOn = ParamConfig.INTEGER(TRANSFORM_TARGET_TYPES.indexOf(TransformTargetType.GEOMETRY), {\n\t\tmenu: {\n\t\t\tentries: TRANSFORM_TARGET_TYPES.map((target_type, i) => {\n\t\t\t\treturn {name: target_type, value: i};\n\t\t\t}),\n\t\t},\n\t});\n\t/** @param number of transformations this can apply */\n\tcount = ParamConfig.INTEGER(2, {\n\t\trange: [0, max_transform_count],\n\t\trangeLocked: [true, true],\n\t});\n\n\t// 0\n\t/** @param transform 0 rotation order */\n\trotationOrder0 = ParamConfig.INTEGER(ROT_ORDER_DEFAULT, {\n\t\tseparatorBefore: true,\n\t\t...ROT_ORDER_MENU_ENTRIES,\n\t\t...visible_for_count(0),\n\t});\n\t/** @param rotation 0 */\n\tr0 = ParamConfig.VECTOR3([0, 0, 0], {...visible_for_count(0)});\n\n\t// 1\n\t/** @param transform 1 rotation order */\n\trotationOrder1 = ParamConfig.INTEGER(ROT_ORDER_DEFAULT, {\n\t\tseparatorBefore: true,\n\t\t...ROT_ORDER_MENU_ENTRIES,\n\t\t...visible_for_count(1),\n\t});\n\t/** @param rotation 1 */\n\tr1 = ParamConfig.VECTOR3([0, 0, 0], {...visible_for_count(1)});\n\n\t// 2\n\t/** @param transform 2 rotation order */\n\trotationOrder2 = ParamConfig.INTEGER(ROT_ORDER_DEFAULT, {\n\t\tseparatorBefore: true,\n\t\t...ROT_ORDER_MENU_ENTRIES,\n\t\t...visible_for_count(2),\n\t});\n\t/** @param rotation 2 */\n\tr2 = ParamConfig.VECTOR3([0, 0, 0], {...visible_for_count(2)});\n\n\t// 3\n\t/** @param transform 3 rotation order */\n\trotationOrder3 = ParamConfig.INTEGER(ROT_ORDER_DEFAULT, {\n\t\tseparatorBefore: true,\n\t\t...ROT_ORDER_MENU_ENTRIES,\n\t\t...visible_for_count(3),\n\t});\n\t/** @param rotation 3 */\n\tr3 = ParamConfig.VECTOR3([0, 0, 0], {...visible_for_count(3)});\n\n\t// 4\n\t/** @param transform 4 rotation order */\n\trotationOrder4 = ParamConfig.INTEGER(ROT_ORDER_DEFAULT, {\n\t\tseparatorBefore: true,\n\t\t...ROT_ORDER_MENU_ENTRIES,\n\t\t...visible_for_count(4),\n\t});\n\t/** @param rotation 4 */\n\tr4 = ParamConfig.VECTOR3([0, 0, 0], {...visible_for_count(4)});\n\n\t// 5\n\t/** @param transform 5 rotation order */\n\trotationOrder5 = ParamConfig.INTEGER(ROT_ORDER_DEFAULT, {\n\t\tseparatorBefore: true,\n\t\t...ROT_ORDER_MENU_ENTRIES,\n\t\t...visible_for_count(5),\n\t});\n\t/** @param rotation 5 */\n\tr5 = ParamConfig.VECTOR3([0, 0, 0], {...visible_for_count(5)});\n}\nconst ParamsConfig = new TransformMultiSopParamConfig();\n\nexport class TransformMultiSopNode extends TypedSopNode<TransformMultiSopParamConfig> {\n\toverride paramsConfig = ParamsConfig;\n\tstatic override type() {\n\t\treturn SopType.TRANSFORM_MULTI;\n\t}\n\n\toverride initializeNode() {\n\t\tthis.io.inputs.setCount(1, 2);\n\t\tthis.io.inputs.initInputsClonedState([InputCloneMode.FROM_NODE, InputCloneMode.NEVER]);\n\t}\n\n\tprivate _core_transform = new CoreTransform();\n\tprivate __rotAndIndexPairs: VectorNumberParamPair[] | undefined;\n\tprivate _createRotAndIndexPairs(): VectorNumberParamPair[] {\n\t\treturn [\n\t\t\t[this.p.r0, this.p.rotationOrder0],\n\t\t\t[this.p.r1, this.p.rotationOrder1],\n\t\t\t[this.p.r2, this.p.rotationOrder2],\n\t\t\t[this.p.r3, this.p.rotationOrder3],\n\t\t\t[this.p.r4, this.p.rotationOrder4],\n\t\t\t[this.p.r5, this.p.rotationOrder5],\n\t\t];\n\t}\n\tprivate _rotAndIndexPairs() {\n\t\treturn (this.__rotAndIndexPairs = this.__rotAndIndexPairs || this._createRotAndIndexPairs());\n\t}\n\toverride cook(input_contents: CoreGroup[]) {\n\t\tconst objects = input_contents[0].threejsObjectsWithGeo();\n\t\tconst src_object = input_contents[1] ? input_contents[1].threejsObjectsWithGeo()[0] : undefined;\n\n\t\tthis._apply_transforms(objects, src_object);\n\n\t\tthis.setObjects(objects);\n\t}\n\n\tprivate _apply_transforms(objects: Object3DWithGeometry[], src_object: Object3DWithGeometry | undefined) {\n\t\tconst mode = TRANSFORM_TARGET_TYPES[this.pv.applyOn];\n\t\tswitch (mode) {\n\t\t\tcase TransformTargetType.GEOMETRY: {\n\t\t\t\treturn this._apply_matrix_to_geometries(objects, src_object);\n\t\t\t}\n\t\t\tcase TransformTargetType.OBJECT: {\n\t\t\t\treturn this._apply_matrix_to_objects(objects, src_object);\n\t\t\t}\n\t\t}\n\t\tTypeAssert.unreachable(mode);\n\t}\n\n\tprivate _apply_matrix_to_geometries(objects: Object3DWithGeometry[], src_object: Object3DWithGeometry | undefined) {\n\t\tif (src_object) {\n\t\t\tconst src_geometry = src_object.geometry;\n\t\t\tif (src_geometry) {\n\t\t\t\tconst attributes_to_copy = [Attribute.POSITION, Attribute.NORMAL, Attribute.TANGENT];\n\n\t\t\t\tfor (const attrib_name of attributes_to_copy) {\n\t\t\t\t\tconst src = src_geometry.attributes[attrib_name] as BufferAttribute | null;\n\t\t\t\t\tfor (const object of objects) {\n\t\t\t\t\t\tconst geometry = object.geometry;\n\t\t\t\t\t\tconst dest = geometry.attributes[attrib_name] as BufferAttribute | null;\n\t\t\t\t\t\tif (src && dest) {\n\t\t\t\t\t\t\tCoreAttribute.copy(src, dest);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tlet pair: VectorNumberParamPair;\n\t\tfor (let i = 0; i < this.pv.count; i++) {\n\t\t\tpair = this._rotAndIndexPairs()[i];\n\t\t\tconst matrix = this._matrix(pair[0].value, pair[1].value);\n\t\t\tfor (const object of objects) {\n\t\t\t\tobject.geometry.applyMatrix4(matrix);\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate _apply_matrix_to_objects(objects: Object3D[], src_object: Object3D | undefined) {\n\t\tif (src_object) {\n\t\t\tfor (const object of objects) {\n\t\t\t\tobject.matrix.copy(src_object.matrix);\n\t\t\t\t// TODO: This would not be required if objects generated in SOP has matrixAutoUpdate=false\n\t\t\t\tobject.matrix.decompose(object.position, object.quaternion, object.scale);\n\t\t\t}\n\t\t}\n\n\t\tlet pair: VectorNumberParamPair;\n\t\tfor (let i = 0; i < this.pv.count; i++) {\n\t\t\tpair = this._rotAndIndexPairs()[i];\n\t\t\tconst matrix = this._matrix(pair[0].value, pair[1].value);\n\t\t\tfor (const object of objects) {\n\t\t\t\tobject.applyMatrix4(matrix);\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate _t = new Vector3(0, 0, 0);\n\tprivate _s = new Vector3(1, 1, 1);\n\tprivate _scale = 1;\n\tprivate _matrix(r: Vector3, rot_order_index: number) {\n\t\treturn this._core_transform.matrix(this._t, r, this._s, this._scale, ROTATION_ORDERS[rot_order_index]);\n\t}\n}\n","/**\n * Resets the center of a geometry.\n *\n * @remarks\n * This can be useful when importing an object whose centroid is not at the center of the geometry. When using this geometry via the LOD SOP, the center of the object will be used to calculate the distance from the object to the camera. It is then necessary to ensure that the center of the object and the center of the geometry are as close to each other as possible.\n *\n * This node can operate in one of multiple modes:\n *\n * - reset_object: this will set the transform of objects to t=0,0,0, r=0,0,0 and s=0,0,0\n * - center geometry: centers the geometry on the center of its object\n * - center geometry & transform object: moves the object so that its position matches the center of the geometry, and updates the geometry position so that it stays in the same place\n *\n */\nimport {TypedSopNode} from './_Base';\nimport {CoreGroup} from '../../../core/geometry/Group';\nimport {\n\tTransformResetSopOperation,\n\tTRANSFORM_RESET_MODES,\n\tTransformResetMode,\n} from '../../operations/sop/TransformReset';\n\nimport {ParamConfig, NodeParamsConfig} from '../utils/params/ParamsConfig';\nimport {SopType} from '../../poly/registers/nodes/types/Sop';\nconst DEFAULT = TransformResetSopOperation.DEFAULT_PARAMS;\nclass TransformResetSopParamConfig extends NodeParamsConfig {\n\t/** @param mode to reset the geometry and object */\n\tmode = ParamConfig.INTEGER(DEFAULT.mode, {\n\t\tmenu: {\n\t\t\tentries: TRANSFORM_RESET_MODES.map((target_type, i) => {\n\t\t\t\treturn {name: target_type, value: i};\n\t\t\t}),\n\t\t},\n\t});\n}\nconst ParamsConfig = new TransformResetSopParamConfig();\n\nexport class TransformResetSopNode extends TypedSopNode<TransformResetSopParamConfig> {\n\toverride paramsConfig = ParamsConfig;\n\tstatic override type() {\n\t\treturn SopType.TRANSFORM_RESET;\n\t}\n\n\toverride initializeNode() {\n\t\tthis.io.inputs.setCount(1, 2);\n\t\tthis.io.inputs.initInputsClonedState(TransformResetSopOperation.INPUT_CLONED_STATE);\n\t}\n\n\tsetMode(mode: TransformResetMode) {\n\t\tthis.p.mode.set(TRANSFORM_RESET_MODES.indexOf(mode));\n\t}\n\n\tprivate _operation: TransformResetSopOperation | undefined;\n\toverride cook(inputCoreGroups: CoreGroup[]) {\n\t\tthis._operation = this._operation || new TransformResetSopOperation(this.scene(), this.states, this);\n\t\tconst coreGroup = this._operation.cook(inputCoreGroups, this.pv);\n\t\tthis.setCoreGroup(coreGroup);\n\t}\n}\n","/**\n * Creates a tube.\n *\n *\n */\nimport {TypedSopNode} from './_Base';\nimport {NodeParamsConfig, ParamConfig} from '../utils/params/ParamsConfig';\nimport {TubeSopOperation} from '../../operations/sop/Tube';\nimport {CoreGroup} from '../../../core/geometry/Group';\nimport {SopType} from '../../poly/registers/nodes/types/Sop';\nconst DEFAULT = TubeSopOperation.DEFAULT_PARAMS;\nconst step = 0.00001;\nclass TubeSopParamsConfig extends NodeParamsConfig {\n\t/** @param if true, the tube is set with a single radius. If false, it uses a top and bottom radius */\n\tsingleRadius = ParamConfig.BOOLEAN(DEFAULT.singleRadius);\n\t/** @param  radius */\n\tradius = ParamConfig.FLOAT(DEFAULT.radius, {\n\t\trange: [0, 2],\n\t\tvisibleIf: {singleRadius: 1},\n\t});\n\t/** @param top radius */\n\tradiusTop = ParamConfig.FLOAT(DEFAULT.radiusTop, {\n\t\trange: [0, 2],\n\t\tvisibleIf: {singleRadius: 0},\n\t});\n\t/** @param bottom radius */\n\tradiusBottom = ParamConfig.FLOAT(DEFAULT.radiusBottom, {\n\t\trange: [0, 2],\n\t\tvisibleIf: {singleRadius: 0},\n\t});\n\t/** @param tube height */\n\theight = ParamConfig.FLOAT(DEFAULT.height, {range: [0, 1]});\n\t/** @param number of segments in the radial direction */\n\tsegmentsRadial = ParamConfig.INTEGER(DEFAULT.segmentsRadial, {range: [3, 50], rangeLocked: [true, false]});\n\t/** @param number of segments in the height direction */\n\tsegmentsHeight = ParamConfig.INTEGER(DEFAULT.segmentsHeight, {range: [1, 20], rangeLocked: [true, false]});\n\t/** @param adds caps */\n\tcap = ParamConfig.BOOLEAN(1);\n\t/** @param center of the tube */\n\tcenter = ParamConfig.VECTOR3([0, 0, 0]);\n\t/** @param direction of the tube */\n\tdirection = ParamConfig.VECTOR3([0, 0, 1]);\n\t/** @param if set to 1, you can then set the phiStart, phi_end, thetaStart and theta_end */\n\topen = ParamConfig.BOOLEAN(DEFAULT.open);\n\t/** @param start of theta angle */\n\tthetaStart = ParamConfig.FLOAT(DEFAULT.thetaStart, {\n\t\tvisibleIf: {open: 1},\n\t\trange: [0, Math.PI * 2],\n\t\tstep,\n\t});\n\t/** @param length of theta opening */\n\tthetaLength = ParamConfig.FLOAT('$PI*2', {\n\t\tvisibleIf: {open: 1},\n\t\trange: [0, Math.PI * 2],\n\t\tstep,\n\t});\n}\nconst ParamsConfig = new TubeSopParamsConfig();\n\nexport class TubeSopNode extends TypedSopNode<TubeSopParamsConfig> {\n\toverride paramsConfig = ParamsConfig;\n\tstatic override type() {\n\t\treturn SopType.TUBE;\n\t}\n\n\tprivate _operation: TubeSopOperation | undefined;\n\toverride cook(input_contents: CoreGroup[]) {\n\t\tthis._operation = this._operation || new TubeSopOperation(this._scene, this.states, this);\n\t\tconst core_group = this._operation.cook(input_contents, this.pv);\n\t\tthis.setCoreGroup(core_group);\n\t}\n}\n","/**\n * Unwraps UVs of each input geometries one by one\n *\n * @remarks\n *\n * This node can use 2 methods to unwrap UVs:\n *\n * - potpack: this uses a very basic unwrap algorithm, and works much better preceded with a sop/Face node that will make every face separate from its neighbours\n * - xatlast: this gives better results on light geometries, but can run for a very long time on larger models.\n *\n */\nimport {TypedSopNode} from './_Base';\nimport {CoreGroup} from '../../../core/geometry/Group';\nimport {UvUnwrapSopOperation, UV_UNWRAP_METHODS, UvUnwrapMethod} from '../../operations/sop/UvUnwrap';\n\nimport {NodeParamsConfig, ParamConfig} from '../utils/params/ParamsConfig';\nimport {SopType} from '../../poly/registers/nodes/types/Sop';\nconst DEFAULT = UvUnwrapSopOperation.DEFAULT_PARAMS;\nclass UvUnwrapSopParamConfig extends NodeParamsConfig {\n\t/** @param method */\n\tmethod = ParamConfig.INTEGER(DEFAULT.method, {\n\t\tmenu: {\n\t\t\tentries: UV_UNWRAP_METHODS.map((name, value) => ({name, value})),\n\t\t},\n\t});\n\t/** @param attribute to unwrap */\n\tuv = ParamConfig.STRING(DEFAULT.uv);\n\t/** @param target texture resolution */\n\tresolution = ParamConfig.INTEGER(DEFAULT.resolution, {\n\t\trange: [16, 4096],\n\t\trangeLocked: [true, false],\n\t\tvisibleIf: {\n\t\t\tmethod: UV_UNWRAP_METHODS.indexOf(UvUnwrapMethod.XATLAS),\n\t\t},\n\t});\n\t/** @param padding */\n\tpadding = ParamConfig.INTEGER(DEFAULT.padding, {\n\t\trange: [0, 10],\n\t\trangeLocked: [true, false],\n\t\tvisibleIf: {\n\t\t\tmethod: UV_UNWRAP_METHODS.indexOf(UvUnwrapMethod.XATLAS),\n\t\t},\n\t});\n}\nconst ParamsConfig = new UvUnwrapSopParamConfig();\n\nexport class UvUnwrapSopNode extends TypedSopNode<UvUnwrapSopParamConfig> {\n\toverride paramsConfig = ParamsConfig;\n\tstatic override type() {\n\t\treturn SopType.UV_UNWRAP;\n\t}\n\n\toverride initializeNode() {\n\t\tthis.io.inputs.setCount(1);\n\t\tthis.io.inputs.initInputsClonedState(UvUnwrapSopOperation.INPUT_CLONED_STATE);\n\t}\n\n\tprivate _operation: UvUnwrapSopOperation | undefined;\n\toverride async cook(inputCoreGroups: CoreGroup[]) {\n\t\tthis._operation = this._operation || new UvUnwrapSopOperation(this.scene(), this.states, this);\n\t\tconst coreGroup = await this._operation.cook(inputCoreGroups, this.pv);\n\t\tthis.setCoreGroup(coreGroup);\n\t}\n\tsetMethod(method: UvUnwrapMethod) {\n\t\tthis.p.method.set(UV_UNWRAP_METHODS.indexOf(method));\n\t}\n}\n","import {TileConfig} from './WFCTileConfig';\nimport {WFCQuadAttribute} from './WFCAttributes';\nimport {Vector4} from 'three';\nimport {QuadGraph, NeighbourData} from '../geometry/modules/quad/graph/QuadGraph';\nimport {QuadNode} from '../geometry/modules/quad/graph/QuadNode';\nimport {Number4} from '../../types/GlobalTypes';\nimport {NeighbourIndex} from '../geometry/modules/quad/graph/QuadGraphCommon';\nimport {QuadObject} from '../geometry/modules/quad/QuadObject';\nimport {QuadPrimitive} from '../geometry/modules/quad/QuadPrimitive';\nimport {quadId} from './WFCUtils';\n\nconst _v4 = new Vector4();\nconst DEFAULT_TILE_ID = '';\nexport class WFCFloorGraph {\n\tprivate _quadGraph: QuadGraph = new QuadGraph();\n\tprivate _quadNodeByQuadId: Map<number, QuadNode> = new Map();\n\tprivate _allowedTileConfigsByQuadId: Map<number, TileConfig[]> = new Map();\n\t//\n\tconstructor(public readonly quadObject: QuadObject, public readonly floorIndex: number) {}\n\n\tsetupQuadNode(index: number, allTileConfigs: TileConfig[]) {\n\t\t// const _quadId = quadId(this.quadObject, index);\n\n\t\t// if (_quadId == null) {\n\t\t// \tthrow new Error(`attribute ${WFCQuadAttribute.QUAD_ID} not found`);\n\t\t// }\n\n\t\t// const tileId: string = QuadPrimitive.hasAttribute(this.quadObject, WFCQuadAttribute.TILE_ID)\n\t\t// \t? (QuadPrimitive.attribValue(this.quadObject, index, WFCQuadAttribute.TILE_ID) as string | undefined) ||\n\t\t// \t  DEFAULT_TILE_ID\n\t\t// \t: DEFAULT_TILE_ID;\n\n\t\t// const tileIds = tileId.trim().length > 0 ? tileId.split(' ') : [];\n\t\t// const tileIdsSet = new Set<string>(tileIds);\n\t\tconst indices = this.quadObject.geometry.index;\n\t\t_v4.fromArray(indices, index * 4);\n\t\tconst quadNode = this._quadGraph.addQuad(index, _v4.toArray() as Number4);\n\t\t// const quadTileConfigs =\n\t\t// \ttileIds.length > 0 ? allTileConfigs.filter((c) => tileIdsSet.has(c.tileId)) : [...allTileConfigs];\n\t\t// this._allowedTileConfigsByQuadId.set(index, quadTileConfigs);\n\t\t// this._quadNodeByQuadId.set(_quadId, quadNode);\n\t\tconst {quadTileConfigs} = this.resetQuadNode(quadNode, allTileConfigs);\n\t\treturn {quadNode, quadTileConfigs};\n\t}\n\tresetQuadNode(quadNode: QuadNode, allTileConfigs: TileConfig[]) {\n\t\tconst index = quadNode.id;\n\t\tconst _quadId = quadId(this.quadObject, index);\n\n\t\tif (_quadId == null) {\n\t\t\tthrow new Error(`attribute ${WFCQuadAttribute.QUAD_ID} not found`);\n\t\t}\n\n\t\tconst tileId: string = QuadPrimitive.hasAttribute(this.quadObject, WFCQuadAttribute.TILE_ID)\n\t\t\t? (QuadPrimitive.attribValue(this.quadObject, index, WFCQuadAttribute.TILE_ID) as string | undefined) ||\n\t\t\t  DEFAULT_TILE_ID\n\t\t\t: DEFAULT_TILE_ID;\n\n\t\tconst tileIds = tileId.trim().length > 0 ? tileId.split(' ') : [];\n\t\tconst tileIdsSet = new Set<string>(tileIds);\n\n\t\tconst quadTileConfigs =\n\t\t\ttileIds.length > 0 ? allTileConfigs.filter((c) => tileIdsSet.has(c.tileId)) : [...allTileConfigs];\n\t\tthis._allowedTileConfigsByQuadId.set(index, quadTileConfigs);\n\t\tthis._quadNodeByQuadId.set(_quadId, quadNode);\n\n\t\treturn {quadTileConfigs};\n\t}\n\tquadNodeFromId(quadId: number) {\n\t\treturn this._quadNodeByQuadId.get(quadId);\n\t}\n\tquadNodeFromOtherQuadNode(otherGraphQuadNode: QuadNode) {\n\t\tconst _quadId = quadId(this.quadObject, otherGraphQuadNode.id);\n\t\treturn this._quadNodeByQuadId.get(_quadId);\n\t}\n\tallowedTileConfigsForQuadNode(quadNode: QuadNode) {\n\t\treturn this._allowedTileConfigsByQuadId.get(quadNode.id);\n\t}\n\tsetAllowedTileConfigsForQuadNode(quadNode: QuadNode, tileConfigs: TileConfig[]) {\n\t\tthis._allowedTileConfigsByQuadId.set(quadNode.id, tileConfigs);\n\t}\n\tneighbourData(quadId: number, sideIndex: NeighbourIndex, target: NeighbourData): void {\n\t\tthis._quadGraph.neighbourData(quadId, sideIndex, target);\n\t}\n}\n","import {arrayCopy} from '../ArrayUtils';\nimport {randFloat} from '../math/_Module';\nimport {TileConfig} from './WFCTileConfig';\n\nexport class WFCTileConfigSampler {\n\tprivate _cumulativeWeights: number[] = [];\n\tprivate _totalWeight: number = 0;\n\tprivate _tileConfigs: TileConfig[] = [];\n\n\tsetItemsAndWeights(tileConfigs: TileConfig[], weights: number[]) {\n\t\tif (tileConfigs.length !== weights.length) {\n\t\t\tthrow new Error('there must be as many weights as tileConfigs');\n\t\t}\n\n\t\tthis._cumulativeWeights.length = 0;\n\t\tthis._totalWeight = 0;\n\n\t\tfor (const weight of weights) {\n\t\t\tthis._totalWeight += weight;\n\t\t\tthis._cumulativeWeights.push(this._totalWeight);\n\t\t}\n\t\tarrayCopy(tileConfigs, this._tileConfigs);\n\t}\n\n\tsample(seed: number): TileConfig {\n\t\tconst randomWeight = randFloat(seed) * this._totalWeight;\n\t\tlet index = 0;\n\n\t\twhile (randomWeight >= this._cumulativeWeights[index]) {\n\t\t\tindex++;\n\t\t}\n\n\t\treturn this._tileConfigs[index];\n\t}\n}\n","import {WFCTilesCollection} from './WFCTilesCollection';\nimport {configTilesStats, TileConfigStats, solidTilesStats} from './WFCCommon';\nimport {EMPTY_TILE_ID, GRID_BORDER_ID, GRID_BORDER_SIDE_NAME} from './WFCConstant';\nimport {TileConfig, tileConfigToString, ERRORED_TILE_CONFIG, tileConfigsToString} from './WFCTileConfig';\nimport {CoreWFCTileAttribute, WFCQuadAttribute} from './WFCAttributes';\nimport {Object3D,TypedArray} from 'three';\nimport {NeighbourData} from '../geometry/modules/quad/graph/QuadGraph';\nimport {QuadNode} from '../geometry/modules/quad/graph/QuadNode';\nimport {Attribute} from '../geometry/Attribute';\nimport {pushOnArrayAtEntry, popFromArrayAtEntry, addToSetAtEntry} from '../MapUtils';\nimport {arrayUniq, sample, spliceSample} from '../ArrayUtils';\nimport {setToArray} from '../SetUtils';\nimport {NeighbourIndex, CCW_HALF_EDGE_SIDES} from '../geometry/modules/quad/graph/QuadGraphCommon';\nimport {mod} from '../math/_Module';\nimport {QuadObject} from '../geometry/modules/quad/QuadObject';\nimport {WFCFloorGraph} from './WFCFloorGraph';\nimport {isQuadNodeSolveAllowed, quadPrimitiveFloorIndex} from './WFCUtils';\nimport {QuadPrimitive} from '../geometry/modules/quad/QuadPrimitive';\nimport {WFCTileConfigSampler} from './WFCTileConfigSampler';\nimport {PrimitiveStringAttribute} from '../geometry/entities/primitive/PrimitiveAttribute';\nimport {CoreObjectType, ObjectContent} from '../geometry/ObjectContent';\nimport {corePrimitiveClassFactory} from '../geometry/CoreObjectFactory';\n\nconst _neighbourData: NeighbourData = {\n\tquadNode: null,\n\tneighbourIndex: null,\n};\nconst _configStats: TileConfigStats = {\n\tsolid: 0,\n\tempty: 0,\n};\nconst _entropiesSet: Set<number> = new Set();\nconst _sortedEntropies: number[] = [];\n\ninterface WFCSolverOptions {\n\ttileAndRuleObjects: Object3D[];\n\tquadObject: QuadObject;\n\t// height: number;\n\tmaxResolvedQuadsCount: number;\n}\ninterface WFCSolverProcessOptions {\n\tstepsCount: number;\n\tquadSeed: number;\n\tconfigSeed: number;\n}\ninterface WFCSolverUpdateOptions extends WFCSolverProcessOptions {\n\tobject: ObjectContent<CoreObjectType>;\n\tfloorId: number;\n\tquadId: number;\n\ttileId: string;\n\trotation: NeighbourIndex;\n}\nconst _tileConfigSampler = new WFCTileConfigSampler();\nexport class WFCSolver {\n\tprivate _resolvedQuadsCount: number = 0;\n\tprivate _maxResolvedQuadsCount: number;\n\tprivate _stepsCount: number = 0;\n\tprivate _tilesCollection: WFCTilesCollection;\n\tprivate _quadPositionArrays: TypedArray[] = [];\n\tprivate _lowestEntropy: number = Number.POSITIVE_INFINITY;\n\tprivate _quadNodeByEntropy: Map<number, QuadNode[]> = new Map();\n\tprivate _floorGraphs: WFCFloorGraph[] = [];\n\tprivate _quadIndicesByFloorIndex: Map<number, Set<number>> = new Map();\n\tprivate _floorGraphIndexByQuadNode: Map<QuadNode, number> = new Map();\n\tprivate _samplingWithWeightRequired: boolean = false;\n\tprivate _solvedTileConfigs: string[];\n\tprivate _allTileConfigs: TileConfig[] = [];\n\t//\n\tconstructor(options: WFCSolverOptions) {\n\t\tconst {quadObject} = options;\n\t\t// this._height = options.height;\n\t\tthis._maxResolvedQuadsCount = options.maxResolvedQuadsCount;\n\t\t// get tile configs\n\t\tthis._tilesCollection = new WFCTilesCollection(options);\n\t\tconst tiles = this._tilesCollection.tiles();\n\t\t// const allTileConfigs: TileConfig[] = [];\n\t\tfor (const tile of tiles) {\n\t\t\tconst tileId = CoreWFCTileAttribute.getTileId(tile);\n\t\t\tif (tileId == EMPTY_TILE_ID) {\n\t\t\t\tthis._allTileConfigs.push({tileId, rotation: 0});\n\t\t\t} else {\n\t\t\t\tthis._allTileConfigs.push({tileId, rotation: 0});\n\t\t\t\tthis._allTileConfigs.push({tileId, rotation: 1});\n\t\t\t\tthis._allTileConfigs.push({tileId, rotation: 2});\n\t\t\t\tthis._allTileConfigs.push({tileId, rotation: 3});\n\t\t\t}\n\t\t}\n\t\t// check if the tiles have different weights\n\t\tconst weights: number[] = [];\n\t\tarrayUniq(\n\t\t\ttiles.map((tile) => CoreWFCTileAttribute.getWeight(tile)),\n\t\t\tweights\n\t\t);\n\t\tif (weights.length > 1) {\n\t\t\tthis._samplingWithWeightRequired = true;\n\t\t}\n\n\t\t// get floors count\n\t\tconst primitivesCount = QuadPrimitive.entitiesCount(quadObject);\n\t\tfor (let i = 0; i < primitivesCount; i++) {\n\t\t\tconst floorIndex = quadPrimitiveFloorIndex(quadObject, i);\n\t\t\taddToSetAtEntry(this._quadIndicesByFloorIndex, floorIndex, i);\n\t\t}\n\n\t\t// create quad object attributes\n\t\tconst solvedTileConfigs = new Array(primitivesCount).fill('');\n\t\tconst solvedTileIdsAttribute: PrimitiveStringAttribute = {\n\t\t\tisString: true,\n\t\t\tarray: solvedTileConfigs,\n\t\t\titemSize: 1,\n\t\t};\n\t\tQuadPrimitive.addAttribute(quadObject, WFCQuadAttribute.SOLVED_TILE_CONFIGS, solvedTileIdsAttribute);\n\n\t\t// create graphs\n\t\tthis._quadIndicesByFloorIndex.forEach((quadIndices, floorIndex) => {\n\t\t\tthis._quadPositionArrays[floorIndex] = quadObject.geometry.attributes[Attribute.POSITION].array;\n\t\t\tconst floorGraph = new WFCFloorGraph(quadObject, floorIndex);\n\t\t\tthis._floorGraphs.push(floorGraph);\n\t\t\tfor (const quadIndex of quadIndices) {\n\t\t\t\tthis._setupQuadNode(floorGraph, quadIndex, this._allTileConfigs);\n\t\t\t}\n\t\t});\n\t\tthis._solvedTileConfigs = this._setSolvedTileConfigs(quadObject);\n\t}\n\tprivate _setSolvedTileConfigs(object: ObjectContent<CoreObjectType>): string[] {\n\t\tconst primitiveAttributes = corePrimitiveClassFactory(object).attributes(object);\n\t\tif (!primitiveAttributes) {\n\t\t\tconsole.error('no primitive attributes found', object);\n\t\t\treturn [];\n\t\t}\n\t\tconst solvedTileConfigAttribute = primitiveAttributes[WFCQuadAttribute.SOLVED_TILE_CONFIGS];\n\t\tif (!solvedTileConfigAttribute) {\n\t\t\tconsole.error(`primitive attribute ${WFCQuadAttribute.SOLVED_TILE_CONFIGS} not found`);\n\t\t\treturn [];\n\t\t}\n\t\treturn (this._solvedTileConfigs = solvedTileConfigAttribute.array as string[]);\n\t}\n\t// objects(): Object3D[] {\n\t// \treturn this._objects;\n\t// }\n\tprivate _setupQuadNode(floorGraph: WFCFloorGraph, quadIndex: number, allTileConfigs: TileConfig[]) {\n\t\tif (!isQuadNodeSolveAllowed(floorGraph.quadObject, quadIndex)) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst {quadNode, quadTileConfigs} = floorGraph.setupQuadNode(quadIndex, allTileConfigs);\n\t\tthis._floorGraphIndexByQuadNode.set(quadNode, floorGraph.floorIndex);\n\t\tthis._initQuadNodeEntropyCache(quadNode, quadTileConfigs);\n\t}\n\tprivate _resetQuadNode(quadNode: QuadNode) {\n\t\tconst floorGraph = this._floorGraph(quadNode);\n\t\tconst {quadTileConfigs} = floorGraph.resetQuadNode(quadNode, this._allTileConfigs);\n\t\tthis._initQuadNodeEntropyCache(quadNode, quadTileConfigs);\n\t}\n\tprivate _initQuadNodeEntropyCache(quadNode: QuadNode, quadTileConfigs: TileConfig[]) {\n\t\tconst entropy = quadTileConfigs.length;\n\t\tpushOnArrayAtEntry(this._quadNodeByEntropy, entropy, quadNode);\n\t\tif (entropy < this._lowestEntropy) {\n\t\t\tthis._lowestEntropy = entropy;\n\t\t}\n\t}\n\t//\n\t//\n\t//\n\t//\n\t//\n\n\tprocess(options: WFCSolverProcessOptions, comparableQuadNodes?: Set<QuadNode>) {\n\t\tconst {stepsCount, quadSeed, configSeed} = options;\n\t\tif (stepsCount < 0) {\n\t\t\tlet result = this.step(quadSeed, configSeed, comparableQuadNodes);\n\t\t\twhile (result != false) {\n\t\t\t\tresult = this.step(quadSeed, configSeed, comparableQuadNodes);\n\t\t\t}\n\t\t} else {\n\t\t\tfor (let i = 0; i < stepsCount; i++) {\n\t\t\t\tconst result = this.step(quadSeed, configSeed, comparableQuadNodes);\n\t\t\t\tif (result == false) {\n\t\t\t\t\t// stop loop if step has no quad to continue\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tthis._commitConfigsAttributes();\n\t}\n\tprivate step(quadSeed: number, configSeed: number, comparableQuadNodes?: Set<QuadNode>): boolean | undefined {\n\t\t// const isFirstStep = this._stepsCount == 0;\n\t\tthis._stepsCount++;\n\t\tconst quadNode = this._quadNodeWithLowestEntropy(quadSeed + this._stepsCount);\n\t\tif (!quadNode) {\n\t\t\treturn false;\n\t\t}\n\t\tconst floorGraph = this._floorGraph(quadNode);\n\t\tconst allowedConfigs = floorGraph.allowedTileConfigsForQuadNode(quadNode); //this._allowedTileConfigsByQuadId.get(quadNode.id);\n\t\tif (!(allowedConfigs && allowedConfigs.length > 0)) {\n\t\t\treturn;\n\t\t}\n\t\tconst updatedEntropy = this._reduceEntropyWithCache(quadNode, allowedConfigs, comparableQuadNodes);\n\t\tif (!(allowedConfigs && allowedConfigs.length > 0)) {\n\t\t\tpopFromArrayAtEntry(this._quadNodeByEntropy, updatedEntropy, quadNode);\n\t\t\tthis._placeErrorTileObject(quadNode);\n\t\t\treturn;\n\t\t}\n\t\tconfigTilesStats(allowedConfigs, _configStats);\n\n\t\tconst config =\n\t\t\t_configStats.solid == 0\n\t\t\t\t? allowedConfigs[0]\n\t\t\t\t: this._selectConfig(allowedConfigs, configSeed + this._stepsCount);\n\t\tfloorGraph.setAllowedTileConfigsForQuadNode(quadNode, [config]); //this._allowedTileConfigsByQuadId.set(quadNode.id, [config]);\n\t\tthis._approveConfigForQuad(quadNode, config);\n\t\tthis._updateNeighboursEntropy(quadNode);\n\t}\n\taddSoftContraint(options: WFCSolverUpdateOptions) {\n\t\tconst {object, floorId, quadId, tileId, rotation} = options;\n\t\tthis._setSolvedTileConfigs(object);\n\t\tconst floorGraph = this._floorGraphs[floorId];\n\t\tconst quadNode = floorGraph.quadNodeFromId(quadId);\n\t\tif (!quadNode) {\n\t\t\treturn;\n\t\t}\n\t\tconst config: TileConfig = {\n\t\t\ttileId,\n\t\t\trotation,\n\t\t};\n\t\tfloorGraph.setAllowedTileConfigsForQuadNode(quadNode, [config]);\n\t\tthis._approveConfigForQuad(quadNode, config);\n\t\t// this._updateNeighboursEntropy(quadNode);\n\t\t//\n\t\tconst resetQuadNodeIds: Set<QuadNode> = new Set([quadNode]);\n\t\tthis._resetAndUpdateNeighboursEntropy(quadNode, resetQuadNodeIds);\n\t\t// step\n\t\tthis.process(options, resetQuadNodeIds);\n\t}\n\t//\n\t//\n\t//\n\t//\n\t//\n\tprivate _solveReachMaxCount() {\n\t\treturn this._maxResolvedQuadsCount >= 0 && this._resolvedQuadsCount >= this._maxResolvedQuadsCount;\n\t}\n\tprivate _selectConfig(allowedConfigs: TileConfig[], seed: number): TileConfig {\n\t\tif (this._samplingWithWeightRequired) {\n\t\t\t_tileConfigSampler.setItemsAndWeights(\n\t\t\t\tallowedConfigs,\n\t\t\t\tallowedConfigs.map((config) =>\n\t\t\t\t\tCoreWFCTileAttribute.getWeight(this._tilesCollection.tile(config.tileId)!)\n\t\t\t\t)\n\t\t\t);\n\t\t\treturn _tileConfigSampler.sample(seed);\n\t\t} else {\n\t\t\treturn sample(solidTilesStats(allowedConfigs), seed)!;\n\t\t}\n\t}\n\tprotected _commitConfigsAttributes() {\n\t\tthis._quadNodeByEntropy.forEach((quadNodes, entropy) => {\n\t\t\tfor (const quadNode of quadNodes) {\n\t\t\t\tconst floorGraph = this._floorGraph(quadNode);\n\t\t\t\tconst allowedConfigs = floorGraph.allowedTileConfigsForQuadNode(quadNode);\n\t\t\t\tif (allowedConfigs) {\n\t\t\t\t\tthis._commitConfigsAttributeToQuadPrimitive(quadNode, allowedConfigs);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t}\n\tprivate _placeErrorTileObject(quadNode: QuadNode) {\n\t\tthis._commitConfigAttributeToQuadPrimitive(quadNode, ERRORED_TILE_CONFIG);\n\t\tthis._resolvedQuadsCount++;\n\t}\n\tprivate _approveConfigForQuad(quadNode: QuadNode, config: TileConfig) {\n\t\tthis._commitConfigAttributeToQuadPrimitive(quadNode, config);\n\t\tthis._resolvedQuadsCount++;\n\t}\n\tprivate _commitConfigsAttributeToQuadPrimitive(quadNode: QuadNode, tileConfigs: TileConfig[]) {\n\t\tthis._solvedTileConfigs[quadNode.id] = tileConfigsToString(tileConfigs);\n\t}\n\tprivate _commitConfigAttributeToQuadPrimitive(quadNode: QuadNode, tileConfig: TileConfig) {\n\t\tthis._solvedTileConfigs[quadNode.id] = tileConfigToString(tileConfig);\n\t}\n\n\tprivate _updateNeighboursEntropy(startQuadNode: QuadNode) {\n\t\tconst stack: QuadNode[] = [startQuadNode];\n\n\t\twhile (stack.length > 0 && !this._solveReachMaxCount()) {\n\t\t\tconst currentQuad = stack.pop()!;\n\t\t\tconst floorIndex = this._floorGraphIndexByQuadNode.get(currentQuad)!;\n\t\t\tconst floorGraph = this._floorGraphs[floorIndex];\n\n\t\t\t// update horizontal neighbours\n\t\t\tfor (let i: NeighbourIndex = 0; i < 4; i++) {\n\t\t\t\tfloorGraph.neighbourData(currentQuad.id, i as NeighbourIndex, _neighbourData);\n\t\t\t\tif (\n\t\t\t\t\t_neighbourData.quadNode &&\n\t\t\t\t\tfloorGraph.allowedTileConfigsForQuadNode(_neighbourData.quadNode)!.length > 1\n\t\t\t\t) {\n\t\t\t\t\tthis._updateQuadEntropy(_neighbourData.quadNode, stack);\n\t\t\t\t}\n\t\t\t}\n\t\t\t// update above\n\t\t\tconst floorGraphAbove = this._floorGraphs[floorIndex + 1];\n\t\t\tif (floorGraphAbove) {\n\t\t\t\tconst aboveQuad = floorGraphAbove.quadNodeFromOtherQuadNode(currentQuad);\n\t\t\t\tif (aboveQuad) {\n\t\t\t\t\tif (floorGraphAbove.allowedTileConfigsForQuadNode(aboveQuad)!.length > 1) {\n\t\t\t\t\t\tthis._updateQuadEntropy(aboveQuad, stack);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t// update below\n\t\t\tconst floorGraphBelow = this._floorGraphs[floorIndex - 1];\n\t\t\tif (floorGraphBelow) {\n\t\t\t\tconst belowQuad = floorGraphBelow.quadNodeFromOtherQuadNode(currentQuad);\n\t\t\t\tif (belowQuad) {\n\t\t\t\t\tif (floorGraphBelow.allowedTileConfigsForQuadNode(belowQuad)!.length > 1) {\n\t\t\t\t\t\tthis._updateQuadEntropy(belowQuad, stack);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tprivate _resetAndUpdateNeighboursEntropy(startQuadNode: QuadNode, resetQuadNodeIds: Set<QuadNode>) {\n\t\tconst stack: QuadNode[] = [startQuadNode];\n\n\t\twhile (stack.length > 0 && !this._solveReachMaxCount()) {\n\t\t\tconst currentQuad = stack.pop()!;\n\t\t\tconst floorIndex = this._floorGraphIndexByQuadNode.get(currentQuad)!;\n\t\t\tconst floorGraph = this._floorGraphs[floorIndex];\n\t\t\t// update horizontal neighbours\n\t\t\tfor (let i: NeighbourIndex = 0; i < 4; i++) {\n\t\t\t\tfloorGraph.neighbourData(currentQuad.id, i as NeighbourIndex, _neighbourData);\n\t\t\t\tif (_neighbourData.quadNode) {\n\t\t\t\t\tthis._resetQuadNodeEntropyIfNotReset(_neighbourData.quadNode, resetQuadNodeIds);\n\t\t\t\t\tif (floorGraph.allowedTileConfigsForQuadNode(_neighbourData.quadNode)!.length > 1) {\n\t\t\t\t\t\tthis._updateQuadEntropy(_neighbourData.quadNode, stack, resetQuadNodeIds);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t// update above\n\t\t\tconst floorGraphAbove = this._floorGraphs[floorIndex + 1];\n\t\t\tif (floorGraphAbove) {\n\t\t\t\tconst aboveQuad = floorGraphAbove.quadNodeFromOtherQuadNode(currentQuad);\n\t\t\t\tif (aboveQuad) {\n\t\t\t\t\tthis._resetQuadNodeEntropyIfNotReset(aboveQuad, resetQuadNodeIds);\n\t\t\t\t\tif (floorGraphAbove.allowedTileConfigsForQuadNode(aboveQuad)!.length > 1) {\n\t\t\t\t\t\tthis._updateQuadEntropy(aboveQuad, stack, resetQuadNodeIds);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t// update below\n\t\t\tconst floorGraphBelow = this._floorGraphs[floorIndex - 1];\n\t\t\tif (floorGraphBelow) {\n\t\t\t\tconst belowQuad = floorGraphBelow.quadNodeFromOtherQuadNode(currentQuad);\n\t\t\t\tif (belowQuad) {\n\t\t\t\t\tthis._resetQuadNodeEntropyIfNotReset(belowQuad, resetQuadNodeIds);\n\t\t\t\t\tif (floorGraphBelow.allowedTileConfigsForQuadNode(belowQuad)!.length > 1) {\n\t\t\t\t\t\tthis._updateQuadEntropy(belowQuad, stack, resetQuadNodeIds);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate _updateQuadEntropy(quadNode: QuadNode, stack: QuadNode[], comparableQuadNodes?: Set<QuadNode>) {\n\t\tif (this._solveReachMaxCount()) {\n\t\t\treturn;\n\t\t}\n\t\tconst floorGraph = this._floorGraph(quadNode);\n\t\tconst allowedTileConfigs = floorGraph.allowedTileConfigsForQuadNode(quadNode)!;\n\n\t\tconst updatedEntropy = this._reduceEntropyWithCache(quadNode, allowedTileConfigs, comparableQuadNodes);\n\t\tif (updatedEntropy === undefined) {\n\t\t\treturn;\n\t\t}\n\n\t\tstack.push(quadNode);\n\t\tswitch (updatedEntropy) {\n\t\t\tcase 0: {\n\t\t\t\tpopFromArrayAtEntry(this._quadNodeByEntropy, updatedEntropy, quadNode);\n\t\t\t\tthis._placeErrorTileObject(quadNode);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tcase 1: {\n\t\t\t\tpopFromArrayAtEntry(this._quadNodeByEntropy, updatedEntropy, quadNode);\n\t\t\t\tconst config = allowedTileConfigs[0];\n\t\t\t\tthis._approveConfigForQuad(quadNode, config);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tdefault: {\n\t\t\t}\n\t\t}\n\t}\n\tprivate _reduceEntropyWithCache(\n\t\tquadNode: QuadNode,\n\t\tallowedTileConfigs: TileConfig[],\n\t\tcomparableQuadNodes?: Set<QuadNode>\n\t): number | undefined {\n\t\tconst previousEntropy: number = allowedTileConfigs.length;\n\t\tthis._reduceEntropy(quadNode, allowedTileConfigs, comparableQuadNodes);\n\t\tconst updatedEntropy: number = allowedTileConfigs.length;\n\n\t\treturn this._setQuadNodeEntropyCache(quadNode, updatedEntropy, previousEntropy);\n\t\t// if (updatedEntropy == previousEntropy) {\n\t\t// \treturn;\n\t\t// }\n\t\t// popFromArrayAtEntry(this._quadNodeByEntropy, previousEntropy, quadNode);\n\t\t// pushOnArrayAtEntry(this._quadNodeByEntropy, updatedEntropy, quadNode);\n\t\t// if (updatedEntropy <= this._lowestEntropy /*&& updatedEntropy > 1*/) {\n\t\t// \tthis._lowestEntropy = updatedEntropy;\n\t\t// }\n\n\t\t// return updatedEntropy;\n\t}\n\tprivate _setQuadNodeEntropyCache(quadNode: QuadNode, updatedEntropy: number, previousEntropy: number) {\n\t\tif (updatedEntropy == previousEntropy) {\n\t\t\treturn;\n\t\t}\n\t\tpopFromArrayAtEntry(this._quadNodeByEntropy, previousEntropy, quadNode);\n\t\tpushOnArrayAtEntry(this._quadNodeByEntropy, updatedEntropy, quadNode);\n\t\tif (updatedEntropy <= this._lowestEntropy /*&& updatedEntropy > 1*/) {\n\t\t\tthis._lowestEntropy = updatedEntropy;\n\t\t}\n\t\treturn updatedEntropy;\n\t}\n\tprivate _resetQuadNodeEntropyIfNotReset(quadNode: QuadNode, resetQuadNodeIds: Set<QuadNode>) {\n\t\tif (resetQuadNodeIds.has(quadNode)) {\n\t\t\treturn;\n\t\t}\n\t\tthis._resetQuadNode(quadNode);\n\n\t\tresetQuadNodeIds.add(quadNode);\n\t}\n\tprivate _reduceEntropy(quadNode: QuadNode, allowedTileConfigs: TileConfig[], comparableQuadNodes?: Set<QuadNode>) {\n\t\tlet i = 0;\n\t\twhile (i < allowedTileConfigs.length) {\n\t\t\tconst allowed = this._checkConfigAgainstNeighbours(quadNode, allowedTileConfigs[i], comparableQuadNodes);\n\t\t\tif (allowed) {\n\t\t\t\ti++;\n\t\t\t} else {\n\t\t\t\tallowedTileConfigs.splice(i, 1);\n\t\t\t}\n\t\t}\n\t\t// if the allowedTileConfigs contain a single solid tile and empty tiles, remove the empty tiles\n\t\tif (allowedTileConfigs.length > 1) {\n\t\t\tconfigTilesStats(allowedTileConfigs, _configStats);\n\t\t\tswitch (_configStats.solid) {\n\t\t\t\tcase 0: {\n\t\t\t\t\t// if none is solid, we keep the first empty\n\t\t\t\t\tallowedTileConfigs.splice(1, allowedTileConfigs.length - 1);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tcase 1: {\n\t\t\t\t\t// if one is solid, we keep this one\n\t\t\t\t\tconst _getIndex = () => {\n\t\t\t\t\t\tlet index = 0;\n\t\t\t\t\t\tfor (const tileConfig of allowedTileConfigs) {\n\t\t\t\t\t\t\tif (tileConfig.tileId != EMPTY_TILE_ID) {\n\t\t\t\t\t\t\t\treturn index;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tindex++;\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn index;\n\t\t\t\t\t};\n\t\t\t\t\tconst index = _getIndex();\n\t\t\t\t\tallowedTileConfigs.splice(index + 1, allowedTileConfigs.length).splice(index - 1, index);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tprivate _checkConfigAgainstNeighbours(\n\t\tquadNode: QuadNode,\n\t\ttileConfig: TileConfig,\n\t\tcomparableQuadNodes?: Set<QuadNode>\n\t): boolean {\n\t\tif (!this._isConfigAllowedWithNeighbour(quadNode, tileConfig, 0, comparableQuadNodes)) {\n\t\t\treturn false;\n\t\t}\n\t\tif (!this._isConfigAllowedWithNeighbour(quadNode, tileConfig, 1, comparableQuadNodes)) {\n\t\t\treturn false;\n\t\t}\n\t\tif (!this._isConfigAllowedWithNeighbour(quadNode, tileConfig, 2, comparableQuadNodes)) {\n\t\t\treturn false;\n\t\t}\n\t\tif (!this._isConfigAllowedWithNeighbour(quadNode, tileConfig, 3, comparableQuadNodes)) {\n\t\t\treturn false;\n\t\t}\n\t\tif (!this._isConfigAllowedWithVerticalNeighbour(quadNode, tileConfig, -1, comparableQuadNodes)) {\n\t\t\treturn false;\n\t\t}\n\t\tif (!this._isConfigAllowedWithVerticalNeighbour(quadNode, tileConfig, +1, comparableQuadNodes)) {\n\t\t\treturn false;\n\t\t}\n\t\treturn true;\n\t}\n\tprotected _isConfigAllowedWithNeighbour(\n\t\tquadNode: QuadNode,\n\t\ttileConfig: TileConfig,\n\t\tneighbourIndex: NeighbourIndex,\n\t\tcomparableQuadNodes?: Set<QuadNode>\n\t): boolean {\n\t\tconst presentedSide0 = CCW_HALF_EDGE_SIDES[mod(neighbourIndex - tileConfig.rotation, 4)];\n\n\t\tconst floorGraph = this._floorGraph(quadNode);\n\t\tfloorGraph.neighbourData(quadNode.id, neighbourIndex, _neighbourData);\n\t\tif (!_neighbourData.quadNode || _neighbourData.neighbourIndex == null) {\n\t\t\t// we are on the grid border\n\t\t\tconst isAllowed = this._tilesCollection.allowedTileConfig(\n\t\t\t\ttileConfig.tileId,\n\t\t\t\tpresentedSide0,\n\t\t\t\tGRID_BORDER_ID,\n\t\t\t\tGRID_BORDER_SIDE_NAME\n\t\t\t);\n\n\t\t\treturn isAllowed;\n\t\t}\n\t\tif (comparableQuadNodes) {\n\t\t\t// if we have a comparableQuadNodes,\n\t\t\t// we only compare if the neighbour node is included in the comparableQuadNodes\n\t\t\tif (!comparableQuadNodes.has(_neighbourData.quadNode)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\n\t\t//\n\t\tconst neighbourConfigs = floorGraph.allowedTileConfigsForQuadNode(_neighbourData.quadNode)!;\n\t\tif (neighbourConfigs.length == 0) {\n\t\t\t// if neighbour has no config, it is empty, so the config is allowed\n\t\t\treturn true;\n\t\t}\n\t\tfor (const neighbourConfig of neighbourConfigs) {\n\t\t\tconst presentedSide1 =\n\t\t\t\tCCW_HALF_EDGE_SIDES[mod(_neighbourData.neighbourIndex - neighbourConfig.rotation, 4)];\n\t\t\tconst isAllowed = this._tilesCollection.allowedTileConfig(\n\t\t\t\ttileConfig.tileId,\n\t\t\t\tpresentedSide0,\n\t\t\t\tneighbourConfig.tileId,\n\t\t\t\tpresentedSide1\n\t\t\t);\n\t\t\tif (isAllowed) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\tprotected _isConfigAllowedWithVerticalNeighbour(\n\t\tquadNode: QuadNode,\n\t\ttileConfig: TileConfig,\n\t\tfloorOffset: 1 | -1,\n\t\tcomparableQuadNodes?: Set<QuadNode>\n\t): boolean {\n\t\tconst floorIndex = this._floorGraphIndexByQuadNode.get(quadNode)!;\n\t\tconst presentedSide0 = floorOffset > 0 ? 't' : 'b';\n\t\tconst presentedSide1 = floorOffset > 0 ? 'b' : 't';\n\n\t\tconst neighbourFloorIndex = floorIndex + floorOffset;\n\t\tconst neighbourFloorGraph = this._floorGraphs[neighbourFloorIndex];\n\t\tif (!neighbourFloorGraph) {\n\t\t\t// we are on the grid border\n\t\t\tconst isAllowed = this._tilesCollection.allowedTileConfig(\n\t\t\t\ttileConfig.tileId,\n\t\t\t\tpresentedSide0,\n\t\t\t\tGRID_BORDER_ID,\n\t\t\t\tGRID_BORDER_SIDE_NAME\n\t\t\t);\n\n\t\t\treturn isAllowed;\n\t\t}\n\t\tconst neighbourQuadNode = neighbourFloorGraph.quadNodeFromOtherQuadNode(quadNode);\n\t\tif (!neighbourQuadNode) {\n\t\t\t// we are on the grid border\n\t\t\tconst isAllowed = this._tilesCollection.allowedTileConfig(\n\t\t\t\ttileConfig.tileId,\n\t\t\t\tpresentedSide0,\n\t\t\t\tGRID_BORDER_ID,\n\t\t\t\tGRID_BORDER_SIDE_NAME\n\t\t\t);\n\n\t\t\treturn isAllowed;\n\t\t}\n\t\tif (comparableQuadNodes) {\n\t\t\t// if we have a comparableQuadNodes,\n\t\t\t// we only compare if the neighbour node is included in the comparableQuadNodes\n\t\t\tif (!comparableQuadNodes.has(neighbourQuadNode)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\n\t\tconst neighbourConfigs = neighbourFloorGraph.allowedTileConfigsForQuadNode(neighbourQuadNode)!;\n\t\tif (neighbourConfigs.length == 0) {\n\t\t\t// if neighbour has no config, it is empty, so the config is allowed\n\t\t\treturn true;\n\t\t}\n\t\tfor (const neighbourConfig of neighbourConfigs) {\n\t\t\tconst isAllowed = this._tilesCollection.allowedTileConfig(\n\t\t\t\ttileConfig.tileId,\n\t\t\t\tpresentedSide0,\n\t\t\t\tneighbourConfig.tileId,\n\t\t\t\tpresentedSide1\n\t\t\t);\n\n\t\t\tif (isAllowed) {\n\t\t\t\t// if the connection is allowed, and since we are only testing vertical connection,\n\t\t\t\t// we only take a config if it has the same rotation,\n\t\t\t\t// OR if one of the tiles is the empty tile or the grid border\n\t\t\t\tconst isAllowedIfNeighbourEmptyOrSharesRotation =\n\t\t\t\t\tneighbourConfig.tileId == EMPTY_TILE_ID ||\n\t\t\t\t\ttileConfig.tileId == EMPTY_TILE_ID ||\n\t\t\t\t\tneighbourConfig.tileId == GRID_BORDER_ID ||\n\t\t\t\t\ttileConfig.tileId == GRID_BORDER_ID ||\n\t\t\t\t\tneighbourConfig.rotation == tileConfig.rotation;\n\t\t\t\tif (isAllowedIfNeighbourEmptyOrSharesRotation) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\tprivate _quadNodeWithLowestEntropy(seed: number) {\n\t\tif (this._solveReachMaxCount()) {\n\t\t\treturn;\n\t\t}\n\t\tlet quadNodes = this._quadNodeByEntropy.get(this._lowestEntropy);\n\n\t\t// update lowest entropy if needed\n\t\twhile (quadNodes == null || quadNodes.length == 0) {\n\t\t\tthis._quadNodeByEntropy.delete(this._lowestEntropy);\n\t\t\t_entropiesSet.clear();\n\t\t\tthis._quadNodeByEntropy.forEach((quadNodes, entropy) => {\n\t\t\t\t_entropiesSet.add(entropy);\n\t\t\t});\n\t\t\tsetToArray(_entropiesSet, _sortedEntropies);\n\t\t\tconst sortedEntropies = _sortedEntropies.sort((a, b) => a - b);\n\t\t\tif (sortedEntropies.length == 0) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tthis._lowestEntropy = sortedEntropies[0];\n\n\t\t\tquadNodes = this._quadNodeByEntropy.get(this._lowestEntropy);\n\t\t}\n\t\tif (!quadNodes) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst quadNode = spliceSample(quadNodes, seed);\n\t\tif (!quadNode) {\n\t\t\treturn;\n\t\t}\n\n\t\treturn quadNode;\n\t}\n\n\tprivate _floorGraph(quadNode: QuadNode): WFCFloorGraph {\n\t\tconst floorIndex = this._floorGraphIndexByQuadNode.get(quadNode)!;\n\n\t\treturn this._floorGraphs[floorIndex];\n\t}\n}\n","/**\n * solves a WFC\n *\n *\n */\nimport {TypedSopNode} from './_Base';\nimport {NodeParamsConfig, ParamConfig} from '../utils/params/ParamsConfig';\nimport {CoreGroup} from '../../../core/geometry/Group';\nimport {SopType} from '../../poly/registers/nodes/types/Sop';\nimport {InputCloneMode} from '../../poly/InputCloneMode';\nimport {WFCSolver} from '../../../core/wfc/WFCSolver';\nimport {filterTileObjects, filterRuleObjects} from '../../../core/wfc/WFCUtils';\nimport {registerWFCSolver} from '../../../core/wfc/WFCRegister';\n\nclass WFCSolverSopParamsConfig extends NodeParamsConfig {\n\t/** @param iterations */\n\tstepsCount = ParamConfig.INTEGER(-1, {\n\t\trange: [-1, 1000],\n\t\trangeLocked: [true, false],\n\t});\n\t/** @param max resolved quads */\n\tmaxCount = ParamConfig.INTEGER(-1, {\n\t\trange: [-1, 1000],\n\t\trangeLocked: [true, false],\n\t\tseparatorAfter: true,\n\t});\n\t/** @param quadSeed */\n\tquadSeed = ParamConfig.INTEGER(0, {\n\t\trange: [-100, 100],\n\t\trangeLocked: [false, false],\n\t});\n\t/** @param configSeed */\n\tconfigSeed = ParamConfig.INTEGER(0, {\n\t\trange: [-100, 100],\n\t\trangeLocked: [false, false],\n\t});\n}\nconst ParamsConfig = new WFCSolverSopParamsConfig();\n\nexport class WFCSolverSopNode extends TypedSopNode<WFCSolverSopParamsConfig> {\n\toverride paramsConfig = ParamsConfig;\n\tstatic override type() {\n\t\treturn SopType.WFC_SOLVER;\n\t}\n\n\toverride initializeNode() {\n\t\tthis.io.inputs.setCount(2);\n\t\tthis.io.inputs.initInputsClonedState([InputCloneMode.FROM_NODE, InputCloneMode.NEVER]);\n\t}\n\n\toverride cook(inputCoreGroups: CoreGroup[]) {\n\t\tconst coreGroup0 = inputCoreGroups[0];\n\t\tconst coreGroup1 = inputCoreGroups[1];\n\t\tconst quadObjects = coreGroup0.quadObjects();\n\n\t\tif (!quadObjects || quadObjects.length == 0) {\n\t\t\tthis.states.error.set('no quad objects found');\n\t\t\treturn;\n\t\t}\n\t\tconst tileAndRuleObjects = coreGroup1.threejsObjects();\n\t\tconst tileObjects = filterTileObjects(tileAndRuleObjects);\n\t\tconst ruleObjects = filterRuleObjects(tileAndRuleObjects);\n\t\tif (tileObjects.length == 0) {\n\t\t\tthis.states.error.set('no tile objects found');\n\t\t\treturn;\n\t\t}\n\t\tif (ruleObjects.length == 0) {\n\t\t\tthis.states.error.set('no rule objects found');\n\t\t\treturn;\n\t\t}\n\n\t\tconst {maxCount} = this.pv;\n\n\t\tfor (const quadObject of quadObjects) {\n\t\t\t// Poly.onObjectsAddRemoveHooks.assignOnAddHookHandler(quadObject, this);\n\t\t\tconst solver = new WFCSolver({\n\t\t\t\ttileAndRuleObjects,\n\t\t\t\tquadObject,\n\t\t\t\tmaxResolvedQuadsCount: maxCount,\n\t\t\t});\n\t\t\tregisterWFCSolver(solver, quadObject);\n\t\t\tsolver.process(this.pv);\n\t\t}\n\n\t\tthis.setObjects(quadObjects);\n\t}\n\n\t// public override updateObjectOnAdd(object: Object3D) {\n\t// \tconsole.log('updateObjectOnAdd', object);\n\t// \tconsole.log(getWFCsolver(object));\n\t// }\n}\n","/**\n * Adds properties for WFC tiles\n *\n *\n */\nimport {TypedSopNode} from './_Base';\nimport {NodeParamsConfig, ParamConfig} from '../utils/params/ParamsConfig';\nimport {CoreGroup} from '../../../core/geometry/Group';\nimport {SopType} from '../../poly/registers/nodes/types/Sop';\nimport {InputCloneMode} from '../../poly/InputCloneMode';\nimport {CoreWFCTileAttribute} from '../../../core/wfc/WFCAttributes';\nimport {filterObjectsFromCoreGroup} from '../../../core/geometry/Mask';\nimport {BufferGeometry, Vector3, Float32BufferAttribute} from 'three';\nimport {CoreGeometryBuilderMerge} from '../../../core/geometry/modules/three/builders/Merge';\nimport {ObjectType} from '../../../core/geometry/Constant';\nimport {BaseSopOperation} from '../../operations/sop/_Base';\nimport {rotateGeometry} from '../../../core/Transform';\nimport {Attribute} from '../../../core/geometry/Attribute';\n\nconst DEFAULT_UP = new Vector3(0, 1, 0);\nconst SOUTH_DIR = new Vector3(-1, 0, 0);\nconst NORTH_DIR = new Vector3(+1, 0, 0);\nconst WEST_DIR = new Vector3(0, 0, -1);\nconst EAST_DIR = new Vector3(0, 0, +1);\nconst BOTTOM_DIR = new Vector3(0, -1, 0);\nconst TOP_DIR = new Vector3(0, +1, 0);\nconst _tmp = new Vector3();\n\nclass WFCTileSideNameSopParamsConfig extends NodeParamsConfig {\n\t/** @param group to assign the material to */\n\tgroup = ParamConfig.STRING('', {\n\t\tobjectMask: true,\n\t});\n\tsameNameForSelectedSides = ParamConfig.BOOLEAN(1);\n\t/** @param south side */\n\tsouth = ParamConfig.BOOLEAN(0);\n\tsouthName = ParamConfig.STRING('', {\n\t\tvisibleIf: {sameNameForSelectedSides: 0, south: 1},\n\t});\n\t/** @param north side */\n\tnorth = ParamConfig.BOOLEAN(0);\n\tnorthName = ParamConfig.STRING('', {\n\t\tvisibleIf: {sameNameForSelectedSides: 0, north: 1},\n\t});\n\t/** @param west side */\n\twest = ParamConfig.BOOLEAN(0);\n\twestName = ParamConfig.STRING('', {\n\t\tvisibleIf: {sameNameForSelectedSides: 0, west: 1},\n\t});\n\t/** @param east side */\n\teast = ParamConfig.BOOLEAN(0);\n\teastName = ParamConfig.STRING('', {\n\t\tvisibleIf: {sameNameForSelectedSides: 0, east: 1},\n\t});\n\t/** @param bottom side */\n\tbottom = ParamConfig.BOOLEAN(0);\n\tbottomName = ParamConfig.STRING('', {\n\t\tvisibleIf: {sameNameForSelectedSides: 0, bottom: 1},\n\t});\n\t/** @param top side */\n\ttop = ParamConfig.BOOLEAN(0);\n\ttopName = ParamConfig.STRING('', {\n\t\tvisibleIf: {sameNameForSelectedSides: 0, top: 1},\n\t});\n\t/** @param allowedRotationY */\n\tsideName = ParamConfig.STRING('', {\n\t\tvisibleIf: {sameNameForSelectedSides: 1},\n\t});\n\t/** @param highlight */\n\thighlight = ParamConfig.BOOLEAN(false);\n}\nconst ParamsConfig = new WFCTileSideNameSopParamsConfig();\n\nexport class WFCTileSideNameSopNode extends TypedSopNode<WFCTileSideNameSopParamsConfig> {\n\toverride paramsConfig = ParamsConfig;\n\tstatic override type() {\n\t\treturn SopType.WFC_TILE_SIDE_NAME;\n\t}\n\n\toverride initializeNode() {\n\t\tthis.io.inputs.setCount(1);\n\t\tthis.io.inputs.initInputsClonedState(InputCloneMode.FROM_NODE);\n\t}\n\n\toverride async cook(inputCoreGroups: CoreGroup[]) {\n\t\tconst coreGroup = inputCoreGroups[0];\n\t\tconst objects = filterObjectsFromCoreGroup(coreGroup, this.pv);\n\t\t// const coreObjects = coreGroup.allCoreObjects();\n\n\t\tconst {sameNameForSelectedSides, south, north, west, east, bottom, top} = this.pv;\n\n\t\tif (sameNameForSelectedSides == true) {\n\t\t\tconst sideName = this.pv.sideName;\n\t\t\tfor (const object of objects) {\n\t\t\t\tif (south) {\n\t\t\t\t\tCoreWFCTileAttribute.setSideName(object, 's', sideName);\n\t\t\t\t}\n\t\t\t\tif (north) {\n\t\t\t\t\tCoreWFCTileAttribute.setSideName(object, 'n', sideName);\n\t\t\t\t}\n\t\t\t\tif (west) {\n\t\t\t\t\tCoreWFCTileAttribute.setSideName(object, 'w', sideName);\n\t\t\t\t}\n\t\t\t\tif (east) {\n\t\t\t\t\tCoreWFCTileAttribute.setSideName(object, 'e', sideName);\n\t\t\t\t}\n\t\t\t\tif (bottom) {\n\t\t\t\t\tCoreWFCTileAttribute.setSideName(object, 'b', sideName);\n\t\t\t\t}\n\t\t\t\tif (top) {\n\t\t\t\t\tCoreWFCTileAttribute.setSideName(object, 't', sideName);\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tfor (const object of objects) {\n\t\t\t\tif (south) {\n\t\t\t\t\tCoreWFCTileAttribute.setSideName(object, 's', this.pv.southName);\n\t\t\t\t}\n\t\t\t\tif (north) {\n\t\t\t\t\tCoreWFCTileAttribute.setSideName(object, 'n', this.pv.northName);\n\t\t\t\t}\n\t\t\t\tif (west) {\n\t\t\t\t\tCoreWFCTileAttribute.setSideName(object, 'w', this.pv.westName);\n\t\t\t\t}\n\t\t\t\tif (east) {\n\t\t\t\t\tCoreWFCTileAttribute.setSideName(object, 'e', this.pv.eastName);\n\t\t\t\t}\n\t\t\t\tif (bottom) {\n\t\t\t\t\tCoreWFCTileAttribute.setSideName(object, 'b', this.pv.bottomName);\n\t\t\t\t}\n\t\t\t\tif (top) {\n\t\t\t\t\tCoreWFCTileAttribute.setSideName(object, 't', this.pv.topName);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (this.pv.highlight) {\n\t\t\tconst geometries: BufferGeometry[] = [];\n\t\t\tif (south) {\n\t\t\t\tgeometries.push(this._createHighlightPlane(SOUTH_DIR));\n\t\t\t}\n\t\t\tif (north) {\n\t\t\t\tgeometries.push(this._createHighlightPlane(NORTH_DIR));\n\t\t\t}\n\t\t\tif (west) {\n\t\t\t\tgeometries.push(this._createHighlightPlane(WEST_DIR));\n\t\t\t}\n\t\t\tif (east) {\n\t\t\t\tgeometries.push(this._createHighlightPlane(EAST_DIR));\n\t\t\t}\n\t\t\tif (bottom) {\n\t\t\t\tgeometries.push(this._createHighlightPlane(BOTTOM_DIR));\n\t\t\t}\n\t\t\tif (top) {\n\t\t\t\tgeometries.push(this._createHighlightPlane(TOP_DIR));\n\t\t\t}\n\t\t\tconst mergedGeometry = CoreGeometryBuilderMerge.merge(geometries);\n\t\t\tif (mergedGeometry) {\n\t\t\t\tconst mergedObject = BaseSopOperation.createObject(mergedGeometry, ObjectType.LINE_SEGMENTS);\n\t\t\t\tobjects.push(mergedObject);\n\t\t\t}\n\t\t}\n\n\t\tthis.setObjects(objects);\n\t}\n\tprivate _createHighlightPlane(dir: Vector3): BufferGeometry {\n\t\tconst geometry = new BufferGeometry();\n\n\t\tconst positions: number[] = [];\n\t\tpositions.push(-0.45, 0, -0.45);\n\t\tpositions.push(0.45, 0, -0.45);\n\t\tpositions.push(0.45, 0, 0.45);\n\t\tpositions.push(-0.45, 0, 0.45);\n\t\tconst indices: number[] = [];\n\t\tindices.push(0, 1, 1, 2, 2, 3, 3, 0);\n\n\t\tgeometry.setAttribute(Attribute.POSITION, new Float32BufferAttribute(positions, 3));\n\t\tgeometry.setIndex(indices);\n\n\t\trotateGeometry(geometry, DEFAULT_UP, dir);\n\t\t_tmp.copy(dir).multiplyScalar(0.55);\n\t\tgeometry.translate(_tmp.x, _tmp.y, _tmp.z);\n\n\t\treturn geometry;\n\t}\n}\n","/**\n * Transforms a tile along the north/south, west/east and bottom/top axis.\n *\n *\n */\nimport {TypedSopNode} from './_Base';\nimport {NodeParamsConfig, ParamConfig} from '../utils/params/ParamsConfig';\nimport {CoreGroup} from '../../../core/geometry/Group';\nimport {SopType} from '../../poly/registers/nodes/types/Sop';\nimport {InputCloneMode} from '../../poly/InputCloneMode';\nimport {Matrix4, Vector3, Quaternion} from 'three';\n\nconst _m4 = new Matrix4();\nconst _t = new Vector3();\nconst _q = new Quaternion();\nconst _s = new Vector3(1, 1, 1);\nconst UP = new Vector3(0, 1, 0);\n\nclass WFCTileTransformSopParamsConfig extends NodeParamsConfig {\n\t/** @param south / north  */\n\tsn = ParamConfig.INTEGER(0, {\n\t\trange: [-2, 2],\n\t\trangeLocked: [true, true],\n\t});\n\t/** @param west / east */\n\twe = ParamConfig.INTEGER(0, {\n\t\trange: [-2, 2],\n\t\trangeLocked: [true, true],\n\t});\n\t/** @param bottom / top */\n\tbt = ParamConfig.INTEGER(0, {\n\t\trange: [-2, 2],\n\t\trangeLocked: [true, true],\n\t});\n\t/** @param y rotation */\n\try = ParamConfig.INTEGER(0, {\n\t\trange: [0, 3],\n\t\trangeLocked: [true, true],\n\t});\n}\nconst ParamsConfig = new WFCTileTransformSopParamsConfig();\n\nexport class WFCTileTransformSopNode extends TypedSopNode<WFCTileTransformSopParamsConfig> {\n\toverride paramsConfig = ParamsConfig;\n\tstatic override type() {\n\t\treturn SopType.WFC_TILE_TRANSFORM;\n\t}\n\n\toverride initializeNode() {\n\t\tthis.io.inputs.setCount(1);\n\t\tthis.io.inputs.initInputsClonedState(InputCloneMode.FROM_NODE);\n\t}\n\n\toverride async cook(inputCoreGroups: CoreGroup[]) {\n\t\tconst coreGroup = inputCoreGroups[0];\n\t\tconst objects = coreGroup.allObjects();\n\n\t\t_t.set(this.pv.sn, this.pv.bt, this.pv.we);\n\t\t_q.setFromAxisAngle(UP, Math.PI * this.pv.ry * 0.5);\n\t\t_m4.compose(_t, _q, _s);\n\t\tfor (const object of objects) {\n\t\t\tobject.applyMatrix4(_m4);\n\t\t}\n\n\t\tthis.setCoreGroup(coreGroup);\n\t}\n}\n","/**\n * Assigns actor nodes to input objects\n *\n *\n */\n\nimport {TypedSopNode} from './_Base';\nimport {NodeParamsConfig} from '../utils/params/ParamsConfig';\nimport {NodeContext} from '../../poly/NodeContext';\nimport {JsNodeChildrenMap} from '../../poly/registers/nodes/Js';\nimport {NodeCreateOptions} from '../utils/hierarchy/ChildrenController';\nimport {Constructor, valueof} from '../../../types/GlobalTypes';\nimport {BaseJsNodeType} from '../js/_Base';\nimport {AssemblerName} from '../../poly/registers/assemblers/_BaseRegister';\nimport {JsAssemblerController} from '../js/code/Controller';\nimport {JsAssemblerActor} from '../js/code/assemblers/actor/ActorAssembler';\nimport {Poly} from '../../Poly';\nimport {ActorPersistedConfig} from '../js/code/assemblers/actor/ActorPersistedConfig';\nimport {ActorCompilationController} from '../../../core/actor/ActorCompilationController';\nimport {CoreObjectType, ObjectContent} from '../../../core/geometry/ObjectContent';\n\nexport class TypedActorSopNode<K extends NodeParamsConfig> extends TypedSopNode<K> {\n\t//\n\t// CHILDREN\n\t//\n\tprotected override _childrenControllerContext = NodeContext.JS;\n\toverride createNode<S extends keyof JsNodeChildrenMap>(\n\t\tnode_class: S,\n\t\toptions?: NodeCreateOptions\n\t): JsNodeChildrenMap[S];\n\toverride createNode<K extends valueof<JsNodeChildrenMap>>(\n\t\tnode_class: Constructor<K>,\n\t\toptions?: NodeCreateOptions\n\t): K;\n\toverride createNode<K extends valueof<JsNodeChildrenMap>>(\n\t\tnode_class: Constructor<K>,\n\t\toptions?: NodeCreateOptions\n\t): K {\n\t\treturn super.createNode(node_class, options) as K;\n\t}\n\toverride children() {\n\t\treturn super.children() as BaseJsNodeType[];\n\t}\n\toverride nodesByType<K extends keyof JsNodeChildrenMap>(type: K): JsNodeChildrenMap[K][] {\n\t\treturn super.nodesByType(type) as JsNodeChildrenMap[K][];\n\t}\n\toverride childrenAllowed() {\n\t\tif (this.assemblerController()) {\n\t\t\treturn super.childrenAllowed();\n\t\t}\n\t\treturn false;\n\t}\n\toverride sceneReadonly() {\n\t\treturn this.assemblerController() == null;\n\t}\n\n\t//\n\t// ASSEMBLERS\n\t//\n\toverride readonly persisted_config: ActorPersistedConfig = new ActorPersistedConfig(this);\n\tassemblerController() {\n\t\treturn this._assemblerController;\n\t}\n\tpublic override usedAssembler(): Readonly<AssemblerName.JS_ACTOR> {\n\t\treturn AssemblerName.JS_ACTOR;\n\t}\n\tprotected _assemblerController = this._createAssemblerController();\n\tprivate _createAssemblerController(): JsAssemblerController<JsAssemblerActor> | undefined {\n\t\treturn Poly.assemblersRegister.assembler(this, this.usedAssembler());\n\t}\n\n\t//\n\t// compilation\n\t//\n\tpublic readonly compilationController: ActorCompilationController = new ActorCompilationController(this);\n\tcompile() {\n\t\tthis.compilationController.compile();\n\t}\n\tfunctionData() {\n\t\treturn this.compilationController.functionData();\n\t}\n\n\t//\n\t// clean\n\t//\n\toverride updateObjectOnRemove(object: ObjectContent<CoreObjectType>, parent: ObjectContent<CoreObjectType>) {\n\t\tthis.compilationController.evaluatorGenerator().disposeEvaluator(object);\n\t}\n}\n\nexport type BaseActorSopNodeType = TypedActorSopNode<NodeParamsConfig>;\n","import {NodeParamsConfig} from '../utils/params/ParamsConfig';\nimport {TypedSopNode} from './_Base';\nimport type {CsgGeometry, CsgGeometryType, CsgTypeMap} from '../../../core/geometry/modules/csg/CsgCommon';\nimport {CsgObject} from '../../../core/geometry/modules/csg/CsgObject';\nimport {CoreGroup} from '../../../core/geometry/Group';\nimport {CoreObjectType} from '../../../core/geometry/ObjectContent';\nimport {ModuleName} from '../../poly/registers/modules/Common';\nexport class CSGSopNode<K extends NodeParamsConfig> extends TypedSopNode<K> {\n\toverride dataType(): string {\n\t\treturn CoreObjectType.CSG;\n\t}\n\toverride requiredModules() {\n\t\treturn [ModuleName.CSG];\n\t}\n\tsetCSGGeometry<T extends CsgGeometryType>(geometry: CsgTypeMap[T]) {\n\t\tconst objects = [new CsgObject(geometry)];\n\t\tthis._setContainerCsgObjects(objects);\n\t}\n\tsetCSGGeometries(geometries: CsgGeometry[]) {\n\t\tconst objects = geometries.map((g) => new CsgObject(g));\n\t\tthis._setContainerCsgObjects(objects);\n\t}\n\tsetCSGObjects(csgObjects: CsgObject<CsgGeometryType>[]) {\n\t\tthis._setContainerCsgObjects(csgObjects);\n\t}\n\tsetCSGObject(csgObject: CsgObject<CsgGeometryType>) {\n\t\tthis._setContainerCsgObjects([csgObject]);\n\t}\n\n\tprotected _setContainerCsgObjects(objects: CsgObject<CsgGeometryType>[] /*, message: MESSAGE*/) {\n\t\tconst coreGroup = this.containerController.container().coreContent() || new CoreGroup();\n\t\tcoreGroup.setAllObjects(objects);\n\t\tthis._setContainer(coreGroup);\n\t}\n}\n\nexport type BaseCSGSopNodeType = CSGSopNode<NodeParamsConfig>;\nexport class BaseCSGSopNodeClass extends CSGSopNode<NodeParamsConfig> {}\n","import {NodeParamsConfig} from '../utils/params/ParamsConfig';\nimport {TypedSopNode} from './_Base';\nimport type {QuadGeometry} from '../../../core/geometry/modules/quad/QuadGeometry';\nimport {QuadObject} from '../../../core/geometry/modules/quad/QuadObject';\nimport {CoreGroup} from '../../../core/geometry/Group';\nimport {CoreObjectType} from '../../../core/geometry/ObjectContent';\nimport {ModuleName} from '../../poly/registers/modules/Common';\nexport class QuadSopNode<K extends NodeParamsConfig> extends TypedSopNode<K> {\n\toverride dataType(): string {\n\t\treturn CoreObjectType.QUAD;\n\t}\n\toverride requiredModules() {\n\t\treturn [ModuleName.QUAD];\n\t}\n\tsetQuadGeometry(geometry: QuadGeometry) {\n\t\tconst objects = [new QuadObject(geometry)];\n\t\tthis._setContainerQuadObjects(objects);\n\t}\n\tsetQuadGeometries(geometries: QuadGeometry[]) {\n\t\tconst objects = geometries.map((g) => new QuadObject(g));\n\t\tthis._setContainerQuadObjects(objects);\n\t}\n\tsetQuadObjects(quadObjects: QuadObject[]) {\n\t\tthis._setContainerQuadObjects(quadObjects);\n\t}\n\tsetQuadObject(quadObject: QuadObject) {\n\t\tthis._setContainerQuadObjects([quadObject]);\n\t}\n\n\tprotected _setContainerQuadObjects(objects: QuadObject[] /*, message: MESSAGE*/) {\n\t\tconst coreGroup = this.containerController.container().coreContent() || new CoreGroup();\n\t\tcoreGroup.setAllObjects(objects);\n\t\tthis._setContainer(coreGroup);\n\t}\n}\n\nexport type BaseCSGSopNodeType = QuadSopNode<NodeParamsConfig>;\nexport class BaseCSGSopNodeClass extends QuadSopNode<NodeParamsConfig> {}\n","import {Vector3, BufferGeometry, Float32BufferAttribute} from 'three';\nimport {TetGeometry} from '../TetGeometry';\nimport {BaseSopOperation} from '../../../../../engine/operations/sop/_Base';\nimport {ObjectType} from '../../../Constant';\nimport {TET_FACE_POINT_INDICES, TetTesselationParams} from '../TetCommon';\nimport {tetSortPoints} from '../utils/tetSortPoints';\nimport {Attribute} from '../../../Attribute';\n\nconst _p = new Vector3();\n\nexport function tetToOuterMesh(tetGeometry: TetGeometry, tesselationParams: TetTesselationParams) {\n\tconst {points, tetrahedrons} = tetGeometry;\n\tconst newGeometry = new BufferGeometry();\n\n\tconst pointIndexById: Map<number, number> = new Map();\n\ttetSortPoints(tetGeometry, pointIndexById);\n\n\tlet facesCount = 0;\n\ttetrahedrons.forEach((tet) => {\n\t\tfor (const neighbourData of tet.neighbours) {\n\t\t\tif (neighbourData == null) {\n\t\t\t\tfacesCount++;\n\t\t\t}\n\t\t}\n\t});\n\tconst positions: number[] = new Array(tetGeometry.pointsCount() * 3);\n\tconst ids: number[] = new Array(tetGeometry.pointsCount() * 1);\n\tconst indices: number[] = new Array(facesCount * 3);\n\n\tlet indicesCount = 0;\n\tpoints.forEach((point) => {\n\t\t_p.copy(point.position);\n\t\tconst pointIndex = pointIndexById.get(point.id);\n\t\tif (pointIndex == null) {\n\t\t\tthrow 'pointIndex is null';\n\t\t}\n\t\t_p.toArray(positions, pointIndex * 3);\n\t\tids[pointIndex] = pointIndex;\n\t});\n\n\ttetrahedrons.forEach((tet) => {\n\t\tlet faceIndex = 0;\n\t\tfor (const neighbourData of tet.neighbours) {\n\t\t\tif (neighbourData == null) {\n\t\t\t\tconst faceIndices = TET_FACE_POINT_INDICES[faceIndex];\n\t\t\t\tconst id0 = tet.pointIds[faceIndices[0]];\n\t\t\t\tconst id1 = tet.pointIds[faceIndices[1]];\n\t\t\t\tconst id2 = tet.pointIds[faceIndices[2]];\n\t\t\t\tconst index0 = pointIndexById.get(id0);\n\t\t\t\tconst index1 = pointIndexById.get(id1);\n\t\t\t\tconst index2 = pointIndexById.get(id2);\n\t\t\t\tif (index0 == null || index1 == null || index2 == null) {\n\t\t\t\t\tthrow 'index is null';\n\t\t\t\t}\n\t\t\t\tindices[indicesCount] = index0;\n\t\t\t\tindices[indicesCount + 1] = index1;\n\t\t\t\tindices[indicesCount + 2] = index2;\n\t\t\t\tindicesCount += 3;\n\t\t\t}\n\t\t\tfaceIndex++;\n\t\t}\n\t});\n\n\tnewGeometry.setAttribute(Attribute.POSITION, new Float32BufferAttribute(positions, 3));\n\tnewGeometry.setAttribute(Attribute.ID, new Float32BufferAttribute(ids, 1));\n\tnewGeometry.setIndex(indices);\n\tnewGeometry.computeVertexNormals();\n\n\treturn BaseSopOperation.createObject(newGeometry, ObjectType.MESH);\n}\n","import {Vector3, BufferGeometry, Float32BufferAttribute} from 'three';\nimport {TetGeometry} from '../TetGeometry';\nimport {BaseSopOperation} from '../../../../../engine/operations/sop/_Base';\nimport {ObjectType} from '../../../Constant';\nimport {TET_FACE_POINT_INDICES, TetTesselationParams} from '../TetCommon';\nimport {tetCenter} from '../utils/tetCenter';\n\nconst _center = new Vector3();\nconst _p = new Vector3();\n\nexport function tetToTetMesh(tetGeometry: TetGeometry, tesselationParams: TetTesselationParams) {\n\tconst {scale} = tesselationParams;\n\tconst {points, tetrahedrons} = tetGeometry;\n\tconst newGeometry = new BufferGeometry();\n\tconst positions: number[] = new Array(tetGeometry.tetsCount() * 4 * 3);\n\tconst indices: number[] = new Array(tetGeometry.tetsCount() * 4 * 3);\n\n\tlet positionsCount = 0;\n\tlet indicesCount = 0;\n\ttetrahedrons.forEach((tet) => {\n\t\t// get center\n\t\ttetCenter(tetGeometry, tet.id, _center);\n\n\t\tfor (const face of TET_FACE_POINT_INDICES) {\n\t\t\tfor (const facePointIndex of face) {\n\t\t\t\tconst pointId = tet.pointIds[facePointIndex];\n\t\t\t\tconst point = points.get(pointId);\n\t\t\t\tif (point) {\n\t\t\t\t\t_p.copy(point.position).sub(_center).multiplyScalar(scale).add(_center);\n\t\t\t\t\t_p.toArray(positions, positionsCount);\n\t\t\t\t\tpositionsCount += 3;\n\t\t\t\t}\n\t\t\t}\n\t\t\tindices[indicesCount] = indicesCount;\n\t\t\tindices[indicesCount + 1] = indicesCount + 1;\n\t\t\tindices[indicesCount + 2] = indicesCount + 2;\n\t\t\tindicesCount += 3;\n\t\t}\n\t});\n\n\tnewGeometry.setAttribute('position', new Float32BufferAttribute(positions, 3));\n\tnewGeometry.setIndex(indices);\n\tnewGeometry.computeVertexNormals();\n\n\treturn BaseSopOperation.createObject(newGeometry, ObjectType.MESH);\n}\n","import {FrontSide, LineBasicMaterial, MeshStandardMaterial, PointsMaterial} from 'three';\n\nconst MESH_MAT = new MeshStandardMaterial({\n\tcolor: 0xffffff,\n\tvertexColors: true,\n\tside: FrontSide,\n\tmetalness: 0.0,\n\troughness: 0.9,\n});\nconst LINES_MAT = new LineBasicMaterial({\n\tcolor: 0xffffff,\n\tlinewidth: 1,\n\tvertexColors: true,\n});\n\nconst POINTS_MAT = new PointsMaterial({\n\tcolor: 0xffffff,\n\tsize: 0.1,\n\tvertexColors: true,\n});\n\nexport function tetMaterialMesh() {\n\treturn MESH_MAT;\n}\nexport function tetMaterialLine() {\n\treturn LINES_MAT;\n}\nexport function tetMaterialPoint() {\n\treturn POINTS_MAT;\n}\n","import {TetGeometry} from '../TetGeometry';\nimport {TetTesselationParams} from '../TetCommon';\nimport {BufferGeometry, Color, Float32BufferAttribute, Vector3} from 'three';\nimport {ObjectType} from '../../../Constant';\nimport {BaseSopOperation} from '../../../../../engine/operations/sop/_Base';\nimport {tetCenter} from '../utils/tetCenter';\nimport {tetMaterialLine} from '../TetMaterial';\nimport {rand} from '../../../../math/_Module';\n\nconst _center = new Vector3();\nconst _p = new Vector3();\nconst _color = new Color();\n\nexport function tetToLines(tetGeometry: TetGeometry, tesselationParams: TetTesselationParams) {\n\tconst {scale} = tesselationParams;\n\tconst {points, tetrahedrons} = tetGeometry;\n\tconst lastAddedTetId = tetGeometry.lastAddedTetId();\n\n\tconst newGeometry = new BufferGeometry();\n\tconst positions: number[] = new Array(tetGeometry.tetsCount() * 4 * 3); // 4 points per tetrahedron, 3 coordinates per point\n\tconst colors: number[] = new Array(tetGeometry.tetsCount() * 4 * 3); // 4 points per tetrahedron, 3 coordinates per point\n\tconst indices: number[] = new Array(tetGeometry.tetsCount() * 6 * 2); // 6 lines per tetrahedron, 2 indices per line\n\n\tlet positionsCount = 0;\n\tlet indicesCount = 0;\n\tlet indexCount = 0;\n\ttetrahedrons.forEach((tet) => {\n\t\ttetCenter(tetGeometry, tet.id, _center);\n\t\tconst h = rand(tet.id);\n\t\t_color.setHSL(h, lastAddedTetId == tet.id ? 0.1 : 1, lastAddedTetId == tet.id ? 1 : 0.5);\n\n\t\t// line 0\n\t\tindices[indicesCount] = indexCount;\n\t\tindices[indicesCount + 1] = indexCount + 1;\n\t\t// line 1\n\t\tindices[indicesCount + 2] = indexCount;\n\t\tindices[indicesCount + 3] = indexCount + 2;\n\t\t// line 2\n\t\tindices[indicesCount + 4] = indexCount;\n\t\tindices[indicesCount + 5] = indexCount + 3;\n\t\t// line 3\n\t\tindices[indicesCount + 6] = indexCount + 1;\n\t\tindices[indicesCount + 7] = indexCount + 2;\n\t\t// line 4\n\t\tindices[indicesCount + 8] = indexCount + 1;\n\t\tindices[indicesCount + 9] = indexCount + 3;\n\t\t// line 5\n\t\tindices[indicesCount + 10] = indexCount + 2;\n\t\tindices[indicesCount + 11] = indexCount + 3;\n\n\t\tfor (let i = 0; i < 4; i++) {\n\t\t\tconst pointId = tet.pointIds[i];\n\t\t\tconst point = points.get(pointId);\n\t\t\tif (point) {\n\t\t\t\t_p.copy(point.position).sub(_center).multiplyScalar(scale).add(_center);\n\t\t\t\t_p.toArray(positions, positionsCount);\n\t\t\t\t_color.toArray(colors, positionsCount);\n\n\t\t\t\tpositionsCount += 3;\n\t\t\t}\n\t\t}\n\n\t\t//\n\t\tindicesCount += 12;\n\t\tindexCount += 4;\n\t});\n\n\tnewGeometry.setAttribute('position', new Float32BufferAttribute(positions, 3));\n\tnewGeometry.setAttribute('color', new Float32BufferAttribute(colors, 3));\n\tnewGeometry.setIndex(indices);\n\treturn BaseSopOperation.createObject(newGeometry, ObjectType.LINE_SEGMENTS, tetMaterialLine());\n}\n","import {TetGeometry} from '../TetGeometry';\nimport {TetTesselationParams} from '../TetCommon';\nimport {BufferGeometry, Float32BufferAttribute, Vector3} from 'three';\nimport {ObjectType} from '../../../Constant';\nimport {BaseSopOperation} from '../../../../../engine/operations/sop/_Base';\nimport {tetCenter} from '../utils/tetCenter';\n\nconst _center0 = new Vector3();\nconst _center1 = new Vector3();\n\nconst idPairs: Map<number, Set<number>> = new Map();\n\nexport function tetSharedFacesToLines(tetGeometry: TetGeometry, tesselationParams: TetTesselationParams) {\n\tidPairs.clear();\n\tlet facesCount = 0;\n\ttetGeometry.tetrahedrons.forEach((tet) => {\n\t\tfor (let i = 0; i < 4; i++) {\n\t\t\tconst neighbour = tet.neighbours[i];\n\t\t\tif (neighbour != null) {\n\t\t\t\tconst neighbourId = neighbour.id;\n\t\t\t\tconst neighbourTet = tetGeometry.tetrahedrons.get(neighbourId);\n\t\t\t\tif (neighbourTet) {\n\t\t\t\t\tconst key = tet.id < neighbourId ? tet.id : neighbourId;\n\t\t\t\t\tconst value = tet.id < neighbourId ? neighbourId : tet.id;\n\t\t\t\t\tlet set = idPairs.get(key);\n\t\t\t\t\tif (!set) {\n\t\t\t\t\t\tset = new Set();\n\t\t\t\t\t\tidPairs.set(key, set);\n\t\t\t\t\t}\n\t\t\t\t\tif (!set.has(value)) {\n\t\t\t\t\t\tfacesCount++;\n\t\t\t\t\t}\n\t\t\t\t\tset.add(value);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t});\n\t// tetGeometry.faces.forEach((face) => {\n\t// \tif (face[0] != null && face[1] != null) {\n\t// \t\tfacesCount++;\n\t// \t}\n\t// });\n\n\tconst newGeometry = new BufferGeometry();\n\tconst positions: number[] = new Array(facesCount * 2 * 3); // 2 points per line, 3 coordinates per point\n\tconst indices: number[] = new Array(facesCount * 1 * 2); // 1 line per face, 2 indices per line\n\n\tlet positionsCount = 0;\n\tlet indicesCount = 0;\n\tlet indexCount = 0;\n\tidPairs.forEach((neighbourIds, tetId) => {\n\t\tneighbourIds.forEach((neighbourId) => {\n\t\t\ttetCenter(tetGeometry, tetId, _center0);\n\t\t\ttetCenter(tetGeometry, neighbourId, _center1);\n\n\t\t\t// line 0\n\t\t\tindices[indicesCount] = indexCount;\n\t\t\tindices[indicesCount + 1] = indexCount + 1;\n\n\t\t\t// pt0\n\t\t\t_center0.toArray(positions, positionsCount);\n\t\t\tpositionsCount += 3;\n\n\t\t\t// pt1\n\t\t\t_center1.toArray(positions, positionsCount);\n\t\t\tpositionsCount += 3;\n\n\t\t\t//\n\t\t\tindicesCount += 2;\n\t\t\tindexCount += 2;\n\t\t});\n\t});\n\t// \tif (face[0] != null && face[1] != null) {\n\t// \t\tfacesCount++;\n\n\t// \t}\n\t// });\n\n\tnewGeometry.setAttribute('position', new Float32BufferAttribute(positions, 3));\n\tnewGeometry.setIndex(indices);\n\treturn BaseSopOperation.createObject(newGeometry, ObjectType.LINE_SEGMENTS);\n}\n","import {TetGeometry} from '../TetGeometry';\nimport {TetTesselationParams} from '../TetCommon';\nimport {BufferGeometry, Float32BufferAttribute} from 'three';\nimport {ObjectType} from '../../../Constant';\nimport {BaseSopOperation} from '../../../../../engine/operations/sop/_Base';\nimport {tetSortPoints} from '../utils/tetSortPoints';\nimport {Attribute} from '../../../Attribute';\n\nexport function tetToPoints(tetGeometry: TetGeometry, tesselationParams: TetTesselationParams) {\n\tconst {points} = tetGeometry;\n\n\tconst newGeometry = new BufferGeometry();\n\n\tconst pointIndexById: Map<number, number> = new Map();\n\ttetSortPoints(tetGeometry, pointIndexById);\n\n\tconst positions: number[] = new Array(tetGeometry.pointsCount() * 1 * 3); // 3 coordinates per point\n\tconst ids: number[] = new Array(tetGeometry.pointsCount() * 1);\n\tconst indices: number[] = new Array(tetGeometry.pointsCount() * 1); // 1 entry per point\n\n\tpoints.forEach((point) => {\n\t\tconst pointIndex = pointIndexById.get(point.id);\n\t\tif (pointIndex == null) {\n\t\t\tthrow 'pointIndex is null';\n\t\t}\n\n\t\tpoint.position.toArray(positions, pointIndex * 3);\n\t\tids[pointIndex] = pointIndex;\n\t\tindices[pointIndex] = pointIndex;\n\t});\n\n\tnewGeometry.setAttribute(Attribute.POSITION, new Float32BufferAttribute(positions, 3));\n\tnewGeometry.setAttribute(Attribute.ID, new Float32BufferAttribute(ids, 1));\n\tnewGeometry.setIndex(indices);\n\treturn BaseSopOperation.createObject(newGeometry, ObjectType.POINTS);\n}\n","import {TetGeometry} from '../TetGeometry';\nimport {TetTesselationParams} from '../TetCommon';\nimport {BufferGeometry, Float32BufferAttribute, Vector3} from 'three';\nimport {ObjectType} from '../../../Constant';\nimport {BaseSopOperation} from '../../../../../engine/operations/sop/_Base';\nimport {tetCircumCenter} from '../utils/tetCenter';\n\nconst _center = new Vector3();\nconst _p = new Vector3();\n\nexport function tetToCenter(tetGeometry: TetGeometry, tesselationParams: TetTesselationParams) {\n\tconst {tetrahedrons} = tetGeometry;\n\n\tconst newGeometry = new BufferGeometry();\n\tconst positions: number[] = new Array(tetGeometry.tetsCount() * 1 * 3); // 1 points tetrahedron, 3 coordinates per point\n\tconst indices: number[] = new Array(tetGeometry.tetsCount() * 1); // 1 entry per point\n\n\tlet positionsCount = 0;\n\tlet indicesCount = 0;\n\tlet indexCount = 0;\n\ttetrahedrons.forEach((tet) => {\n\t\ttetCircumCenter(tetGeometry, tet.id, _center);\n\n\t\t// point 0\n\t\tindices[indicesCount] = indexCount;\n\n\t\t_p.copy(_center);\n\t\t_p.toArray(positions, positionsCount);\n\t\tpositionsCount += 3;\n\n\t\t//\n\t\tindicesCount += 1;\n\t\tindexCount += 1;\n\t});\n\n\tnewGeometry.setAttribute('position', new Float32BufferAttribute(positions, 3));\n\tnewGeometry.setIndex(indices);\n\treturn BaseSopOperation.createObject(newGeometry, ObjectType.POINTS);\n}\n","import {BufferGeometry} from 'three';\nimport {TetGeometry} from '../TetGeometry';\nimport {BaseSopOperation} from '../../../../../engine/operations/sop/_Base';\nimport {ObjectType} from '../../../Constant';\nimport {TetTesselationParams} from '../TetCommon';\nimport {SphereBuilder} from '../../../builders/SphereBuilder';\nimport {CoreGeometryBuilderMerge} from '../../three/builders/Merge';\n\nexport function tetToSphere(tetGeometry: TetGeometry, tesselationParams: TetTesselationParams) {\n\tconst {tetrahedrons} = tetGeometry;\n\n\tconst geometries: BufferGeometry[] = [];\n\ttetrahedrons.forEach((tet) => {\n\t\tconst {radius, center} = tet.sphere;\n\n\t\tconst geometry = SphereBuilder.create({\n\t\t\tradius: radius,\n\t\t\twidthSegments: 32,\n\t\t\theightSegments: 32,\n\t\t\tasLines: true,\n\t\t\topen: false,\n\t\t});\n\t\tgeometry.translate(center.x, center.y, center.z);\n\t\tgeometries.push(geometry);\n\t});\n\tconst mergedGeometry = CoreGeometryBuilderMerge.merge(geometries);\n\n\tif (mergedGeometry) {\n\t\treturn BaseSopOperation.createObject(mergedGeometry, ObjectType.LINE_SEGMENTS);\n\t}\n}\n","import {Object3D, Material, Matrix4, Box3, Sphere} from 'three';\nimport {ObjectContent, CoreObjectType, ObjectGeometryMap, objectContentCopyProperties} from '../../ObjectContent';\nimport {CoreType} from '../../../Type';\nimport {TetGeometry} from './TetGeometry';\nimport {TetTesselationParams} from './TetCommon';\nimport {tetToOuterMesh} from './toObject3D/tetToOuterMesh';\nimport {tetToTetMesh} from './toObject3D/tetToTetMesh';\nimport {tetToLines} from './toObject3D/tetToLines';\nimport {tetSharedFacesToLines} from './toObject3D/tetToSharedFacesToLine';\nimport {tetToPoints} from './toObject3D/tetToPoints';\nimport {tetToCenter} from './toObject3D/tetToCenter';\nimport {tetToSphere} from './toObject3D/tetToSphere';\n\nexport class TetObject implements ObjectContent<CoreObjectType.TET> {\n\tpublic visible = true;\n\tget geometry() {\n\t\treturn this._geometry as ObjectGeometryMap[CoreObjectType.TET];\n\t}\n\tget type() {\n\t\treturn CoreObjectType.TET;\n\t}\n\tparent = null;\n\tchildren = [];\n\tuserData = {};\n\tname = '';\n\tcastShadow = true;\n\treceiveShadow = true;\n\trenderOrder = 0;\n\tfrustumCulled = true;\n\tmatrixAutoUpdate = false;\n\tmaterial: Material | undefined;\n\tconstructor(private _geometry: TetGeometry) {}\n\n\tsetGeometry(geometry: TetGeometry) {\n\t\tthis._geometry = geometry;\n\t}\n\ttetGeometry() {\n\t\treturn this.geometry! as TetGeometry;\n\t}\n\tdispose() {}\n\tapplyMatrix4(matrix: Matrix4) {\n\t\tthis.geometry.applyMatrix4(matrix);\n\t}\n\tadd(...object: ObjectContent<CoreObjectType>[]) {}\n\tremove(...object: ObjectContent<CoreObjectType>[]) {}\n\tdispatchEvent(event: {type: string}) {}\n\ttraverse(callback: (object: TetObject) => any) {\n\t\tcallback(this);\n\t}\n\n\tclone(): TetObject {\n\t\tconst geometry = this._geometry.clone();\n\t\tconst clone = new TetObject(geometry);\n\n\t\tobjectContentCopyProperties(this, clone);\n\t\treturn clone;\n\t}\n\ttoObject3D(tesselationParams: TetTesselationParams): Object3D | Object3D[] | undefined {\n\t\tconst object = TetObject.toObject3D(this, tesselationParams);\n\t\tif (object) {\n\t\t\tif (CoreType.isArray(object)) {\n\t\t\t\tfor (const element of object) {\n\t\t\t\t\tobjectContentCopyProperties(this, element);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tobjectContentCopyProperties(this, object);\n\t\t\t}\n\t\t}\n\t\treturn object;\n\t}\n\n\tstatic toObject3D(\n\t\ttetObject: TetObject,\n\t\ttesselationParams: TetTesselationParams\n\t): Object3D | Object3D[] | undefined {\n\t\tconst objects: Object3D[] = [];\n\t\tif (tesselationParams.displayOuterMesh) {\n\t\t\tobjects.push(tetToOuterMesh(tetObject.tetGeometry(), tesselationParams));\n\t\t}\n\t\tif (tesselationParams.displayTetMesh) {\n\t\t\tobjects.push(tetToTetMesh(tetObject.tetGeometry(), tesselationParams));\n\t\t}\n\t\tif (tesselationParams.displayLines) {\n\t\t\tobjects.push(tetToLines(tetObject.tetGeometry(), tesselationParams));\n\t\t}\n\t\tif (tesselationParams.displaySharedFaces) {\n\t\t\tobjects.push(tetSharedFacesToLines(tetObject.tetGeometry(), tesselationParams));\n\t\t}\n\t\tif (tesselationParams.displayPoints) {\n\t\t\tobjects.push(tetToPoints(tetObject.tetGeometry(), tesselationParams));\n\t\t}\n\t\tif (tesselationParams.displayCenter) {\n\t\t\tobjects.push(tetToCenter(tetObject.tetGeometry(), tesselationParams));\n\t\t}\n\t\tif (tesselationParams.displaySphere) {\n\t\t\tconst spheres = tetToSphere(tetObject.tetGeometry(), tesselationParams);\n\t\t\tif (spheres) {\n\t\t\t\tobjects.push(spheres);\n\t\t\t}\n\t\t}\n\t\treturn objects;\n\t}\n\n\tboundingBox(target: Box3): void {\n\t\tthis.geometry.boundingBox(target);\n\t}\n\tboundingSphere(target: Sphere): void {\n\t\tthis.geometry.boundingSphere(target);\n\t}\n}\n","import {NodeParamsConfig} from '../utils/params/ParamsConfig';\nimport {TypedSopNode} from './_Base';\nimport type {TetGeometry} from '../../../core/geometry/modules/tet/TetGeometry';\nimport {TetObject} from '../../../core/geometry/modules/tet/TetObject';\nimport {CoreGroup} from '../../../core/geometry/Group';\nimport {CoreObjectType} from '../../../core/geometry/ObjectContent';\nimport {ModuleName} from '../../poly/registers/modules/Common';\nexport class TetSopNode<K extends NodeParamsConfig> extends TypedSopNode<K> {\n\toverride dataType(): string {\n\t\treturn CoreObjectType.TET;\n\t}\n\toverride requiredModules() {\n\t\treturn [ModuleName.TET];\n\t}\n\tsetTetGeometry(geometry: TetGeometry) {\n\t\tconst objects = [new TetObject(geometry)];\n\t\tthis._setContainerTetObjects(objects);\n\t}\n\tsetTetGeometries(geometries: TetGeometry[]) {\n\t\tconst objects = geometries.map((g) => new TetObject(g));\n\t\tthis._setContainerTetObjects(objects);\n\t}\n\tsetTetObjects(tetObjects: TetObject[]) {\n\t\tthis._setContainerTetObjects(tetObjects);\n\t}\n\tsetTetObject(tetObject: TetObject) {\n\t\tthis._setContainerTetObjects([tetObject]);\n\t}\n\n\tprotected _setContainerTetObjects(objects: TetObject[] /*, message: MESSAGE*/) {\n\t\tconst coreGroup = this.containerController.container().coreContent() || new CoreGroup();\n\t\tcoreGroup.setAllObjects(objects);\n\t\tthis._setContainer(coreGroup);\n\t}\n}\n\nexport type BaseTetSopNodeType = TetSopNode<NodeParamsConfig>;\nexport class BaseTetSopNodeClass extends TetSopNode<NodeParamsConfig> {}\n","import type {PerspectiveCameraSopNode} from '../../PerspectiveCamera';\nimport type {OrthographicCameraSopNode} from '../../OrthographicCamera';\nimport {Number3} from '../../../../../types/GlobalTypes';\nimport {MathUtils, Object3D} from 'three';\nimport {CoreObjectType} from '../../../../../core/geometry/ObjectContent';\n\ntype SopCameraNode = PerspectiveCameraSopNode | OrthographicCameraSopNode;\n\nconst eulerArray: Number3 = [0, 0, 0];\nexport async function updateCameraTransformParams(node: SopCameraNode) {\n\tconst cameraName = node.p.name.value;\n\tconst mask = `*/${cameraName}`;\n\tconst object = node.scene().objectsController.findObjectByMask<CoreObjectType.THREEJS>(mask) as\n\t\t| Object3D\n\t\t| undefined;\n\tif (!object) {\n\t\treturn;\n\t}\n\tnode.p.position.set(object.position.toArray());\n\tobject.rotation.toArray(eulerArray);\n\teulerArray.forEach((e, i) => (eulerArray[i] = MathUtils.radToDeg(e)));\n\tnode.p.rotation.set(eulerArray);\n}\n","import {ParamEvent} from './../../../../poly/ParamEvent';\nimport {TypedSopNode} from './../../_Base';\nimport {BaseNodeType} from '../../../_Base';\nimport {NodeParamsConfig, ParamConfig} from '../../../utils/params/ParamsConfig';\nimport {CoreGroup} from '../../../../../core/geometry/Group';\nimport {InputCloneMode} from '../../../../poly/InputCloneMode';\nimport {Object3D} from 'three';\nimport {Group} from 'three';\nimport {CoreInstancer} from '../../../../../core/geometry/Instancer';\nimport {Matrix4} from 'three';\nimport {Poly} from '../../../../Poly';\nimport type {BaseGeoLoaderOutput} from '../../../../../core/loader/geometry/Common';\nimport {BaseObject3DLoaderHandler} from '../../../../../core/loader/geometry/_BaseLoaderHandler';\nimport {BaseCorePoint, CorePoint} from '../../../../../core/geometry/entities/point/CorePoint';\nimport {CoreObjectType} from '../../../../../core/geometry/ObjectContent';\n// import { Constructor } from 'vue/types/options';\n\n// interface FileMultSopNodeParamConfigOptions {\n// \textensions: string[];\n// \tdefaultUrlExpression: string;\n// }\n\n// interface FileMultSopNodeOptions<O extends BaseGeoLoaderOutput> {\n// \ttype: string;\n// \textensions: string[];\n// \tdefaultUrlExpression: string;\n// \tcreateLoader: (url: string, node: BaseNodeType) => BaseGeoLoaderHandler<O>;\n// }\nconst _points: CorePoint<CoreObjectType>[] = [];\n\nclass BaseFileMultiParamsConfigResult extends NodeParamsConfig {\n\turl = ParamConfig.STRING('');\n\tmatrixAutoUpdate = ParamConfig.BOOLEAN(0);\n\treload = ParamConfig.BUTTON(null);\n}\n\nexport class BaseFileMultiSopNodeFactoryResult extends TypedSopNode<BaseFileMultiParamsConfigResult> {}\n\n// export function fileMultiSopNodeParamConfigFactory(\n// \toptions: FileMultSopNodeParamConfigOptions\n// ): typeof NodeParamsConfig {\nexport class BaseFileMultiParamsConfig extends NodeParamsConfig {\n\t/** @param url to load the geometry from */\n\turl = ParamConfig.STRING('', {\n\t\tfileBrowse: {extensions: []},\n\t\texpression: {forEntities: true},\n\t});\n\t/** @param sets the matrixAutoUpdate attribute for the objects loaded */\n\tmatrixAutoUpdate = ParamConfig.BOOLEAN(false);\n\t/** @param reload the geometry */\n\treload = ParamConfig.BUTTON(null, {\n\t\tcallback: (node: BaseNodeType) => {\n\t\t\tBaseFileMultiSopNode.PARAM_CALLBACK_reload(\n\t\t\t\tnode as BaseFileMultiSopNode<BaseGeoLoaderOutput, BaseFileMultiParamsConfig>\n\t\t\t);\n\t\t},\n\t});\n}\n// return BaseFileMultiParamsConfig\n// }\n// const BaseFileMultiParamsConfig = fileMultiSopNodeParamConfigFactory({defaultUrlExpression: '', extensions:[]});\nexport abstract class BaseFileMultiSopNode<\n\tO extends BaseGeoLoaderOutput,\n\tK extends BaseFileMultiParamsConfig\n> extends TypedSopNode<K> {\n\t// override paramsConfig = ParamsConfig;\n\t// static override type() {\n\t// \treturn options.type;\n\t// }\n\tprotected abstract _createLoader(url: string): BaseObject3DLoaderHandler<O>;\n\n\toverride dispose(): void {\n\t\tsuper.dispose();\n\t\tPoly.blobs.clearBlobsForNode(this);\n\t}\n\n\toverride initializeNode() {\n\t\tthis.io.inputs.setCount(1);\n\t\tthis.io.inputs.initInputsClonedState(InputCloneMode.NEVER);\n\t}\n\n\tprivate _instancer = new CoreInstancer();\n\tprivate _instanceMatrix = new Matrix4();\n\toverride async cook(inputCoreGroups: CoreGroup[]) {\n\t\tconst inputCoreGroup = inputCoreGroups[0];\n\n\t\tinputCoreGroup.points(_points);\n\t\t// const urls: string[] = new Array(points.length);\n\t\tconst urls: string[] = [];\n\t\tconst urlByIndex: Map<number, string> = new Map();\n\t\tconst loadedResultByUrl: Map<string, Object3D> = new Map();\n\t\tconst urlUsageCount: Map<string, number> = new Map();\n\t\tconst param = this.p.url;\n\t\t// gather all unique urls\n\t\tif (param.hasExpression() && param.expressionController) {\n\t\t\tconst uniqueUrls: Set<string> = new Set();\n\t\t\tconst _applyUrlToPoint = (point: BaseCorePoint, url: string) => {\n\t\t\t\t// check that this index was not already set\n\t\t\t\tconst index = point.index();\n\t\t\t\tif (urlByIndex.has(index)) {\n\t\t\t\t\tthis.states.error.set(`input points have duplicate indices. Make sure to merge inputs together.`);\n\t\t\t\t} else {\n\t\t\t\t\turlByIndex.set(index, url);\n\t\t\t\t\tuniqueUrls.add(url);\n\t\t\t\t\tBaseFileMultiSopNode._incrementUrlUsageCount(url, urlUsageCount);\n\t\t\t\t}\n\t\t\t};\n\t\t\tif (param.expressionController.entitiesDependent()) {\n\t\t\t\tawait param.expressionController.computeExpressionForPoints(_points, _applyUrlToPoint);\n\t\t\t} else {\n\t\t\t\tfor (const point of _points) {\n\t\t\t\t\t_applyUrlToPoint(point, param.value);\n\t\t\t\t}\n\t\t\t}\n\t\t\tuniqueUrls.forEach((url) => {\n\t\t\t\turls.push(url);\n\t\t\t});\n\t\t} else {\n\t\t\tconst url = this.pv.url;\n\t\t\turls.push(url);\n\t\t\tBaseFileMultiSopNode._incrementUrlUsageCount(url, urlUsageCount);\n\t\t}\n\t\t// load each url and place the result under a parent\n\n\t\tconst loadedObjects: Object3D[] = [];\n\t\tconst promises = urls.map((url) => this._loadFromUrlPromises(url, loadedResultByUrl));\n\t\tawait Promise.all(promises);\n\t\t// move each loaded result and transform it according to its template point\n\t\tthis._instancer.setCoreGroup(inputCoreGroup);\n\t\tfor (const point of _points) {\n\t\t\tconst index = point.index();\n\t\t\tconst url = urlByIndex.get(index) || this.pv.url;\n\n\t\t\tthis._instancer.matrixFromPoint(point, this._instanceMatrix);\n\t\t\tconst usageCount = urlUsageCount.get(url) || 1;\n\t\t\tlet parent = loadedResultByUrl.get(url);\n\t\t\tif (parent) {\n\t\t\t\t// if this url is used more than 1x, we clone the loaded result\n\t\t\t\tif (usageCount > 1) {\n\t\t\t\t\tparent = parent.clone();\n\t\t\t\t}\n\t\t\t\tparent.applyMatrix4(this._instanceMatrix);\n\t\t\t\tloadedObjects.push(parent);\n\t\t\t}\n\t\t}\n\n\t\tthis.setObjects(loadedObjects);\n\t}\n\tprivate static _incrementUrlUsageCount(url: string, map: Map<string, number>) {\n\t\tconst currentUsage = map.get(url);\n\t\tif (currentUsage != null) {\n\t\t\tmap.set(url, currentUsage + 1);\n\t\t} else {\n\t\t\tmap.set(url, 1);\n\t\t}\n\t}\n\n\tprivate async _loadFromUrlPromises(url: string, loadedResultByUrl: Map<string, Object3D>) {\n\t\tconst objects = await this._loadObject(url);\n\t\tif (objects) {\n\t\t\tconst parent = new Group();\n\t\t\tparent.matrixAutoUpdate = false;\n\t\t\tparent.name = url;\n\t\t\tfor (const object of objects) {\n\t\t\t\tparent.add(object);\n\t\t\t}\n\t\t\tloadedResultByUrl.set(url, parent);\n\t\t}\n\t}\n\n\tprivate _loadObject(url: string) {\n\t\tconst loader = this._createLoader(url);\n\t\treturn this._loadWithLoader(loader);\n\t}\n\tprotected _loadWithLoader(loader: BaseObject3DLoaderHandler<O>) {\n\t\treturn loader.load({node: this});\n\t}\n\n\tstatic PARAM_CALLBACK_reload(node: BaseFileMultiSopNode<BaseGeoLoaderOutput, BaseFileMultiParamsConfig>) {\n\t\tnode._paramCallbackReload();\n\t}\n\tprivate _paramCallbackReload() {\n\t\t// set the param dirty is preferable to just the successors, in case the expression result needs to be updated\n\t\tthis.p.url.setDirty();\n\t\tthis.p.url.emit(ParamEvent.ASSET_RELOAD_REQUEST);\n\t\t// this.setDirty()\n\t}\n}\n","import {BaseNodeType, TypedNode} from '../../_Base';\nimport {NodeParamsConfig, ParamConfig} from '../../utils/params/ParamsConfig';\nimport {Color} from 'three';\nimport {Number3} from '../../../../types/GlobalTypes';\n// import {ColorConversion} from '../../../../core/Color';\nimport {NodeContext} from '../../../poly/NodeContext';\nimport {\n\tMAX_PALETTE_COLORS_COUNT,\n\tPalette,\n\tPALETTES_BY_NAME,\n\tSORTED_PALETTE_NAMES,\n\tvisibleIfColorsCountAtLeast,\n} from '../../../../core/color/chromotomeWrapper';\n\ntype PaletteControllerCallbackMethod = (node: PaletteAbstractNode<any>) => void;\n\nexport const paletteControllerCallbackOptions = (method: PaletteControllerCallbackMethod) => {\n\treturn {\n\t\tcallback: (node: BaseNodeType) => {\n\t\t\tmethod(node as PaletteAbstractNode<NodeContext>);\n\t\t},\n\t};\n};\n\nexport class PaletteController<NC extends NodeContext> {\n\tconstructor(private node: PaletteAbstractNode<NC>) {}\n\n\tstatic PARAM_CALLBACK_pickNext(node: PaletteAbstractNode<any>) {\n\t\tnode.paletteController.PARAM_CALLBACK_pickNext();\n\t}\n\tstatic PARAM_CALLBACK_pickPrevious(node: PaletteAbstractNode<any>) {\n\t\tnode.paletteController.PARAM_CALLBACK_pickPrevious();\n\t}\n\tstatic PARAM_CALLBACK_pickRandom(node: PaletteAbstractNode<any>) {\n\t\tnode.paletteController.PARAM_CALLBACK_pickRandom();\n\t}\n\tstatic PARAM_CALLBACK_updateColors(node: PaletteAbstractNode<any>) {\n\t\tnode.paletteController.PARAM_CALLBACK_updateColors();\n\t}\n\n\tPARAM_CALLBACK_pickNext() {\n\t\tconst currentIndex = SORTED_PALETTE_NAMES.indexOf(this.node.pv.paletteName);\n\t\tconst nextIndex = currentIndex < SORTED_PALETTE_NAMES.length - 1 ? currentIndex + 1 : 0;\n\t\tthis._batchUpdatesWithPalette(nextIndex);\n\t}\n\tPARAM_CALLBACK_pickPrevious() {\n\t\tconst currentIndex = SORTED_PALETTE_NAMES.indexOf(this.node.pv.paletteName);\n\t\tconst previousIndex = currentIndex == 0 ? SORTED_PALETTE_NAMES.length - 1 : currentIndex - 1;\n\t\tthis._batchUpdatesWithPalette(previousIndex);\n\t}\n\tPARAM_CALLBACK_pickRandom() {\n\t\tconst randomIndex = Math.floor(Math.random() * SORTED_PALETTE_NAMES.length);\n\t\tthis._batchUpdatesWithPalette(randomIndex);\n\t}\n\n\tprivate _batchUpdatesWithPalette(paletteIndex: number) {\n\t\tconst paletteName = SORTED_PALETTE_NAMES[paletteIndex];\n\t\tthis.node.scene().batchUpdates(() => {\n\t\t\tthis.node.p.paletteName.set(paletteName);\n\t\t\tthis._updateColors();\n\t\t});\n\t}\n\n\tPARAM_CALLBACK_updateColors() {\n\t\tthis.node.scene().batchUpdates(() => {\n\t\t\tthis._updateColors();\n\t\t});\n\t}\n\n\tprivate _updateColors() {\n\t\tconst node = this.node;\n\t\tconst name = node.pv.paletteName;\n\t\tconst palette = PALETTES_BY_NAME.get(name) as Palette;\n\t\tconst colorParams = [node.p.color1, node.p.color2, node.p.color3, node.p.color4, node.p.color5];\n\t\tnode.p.colorsCount.set(palette.colors.length);\n\t\tfor (let i = 0; i < palette.colors.length; i++) {\n\t\t\tconst color = palette.colors[i];\n\t\t\tconst param = colorParams[i];\n\t\t\tif (color && param) {\n\t\t\t\t_tmp_color.set(color);\n\t\t\t\t_tmp_color.toArray(_tmp_color_array);\n\t\t\t\tparam.set(_tmp_color_array);\n\t\t\t}\n\t\t}\n\t\tnode.p.colorsCount.set(palette.colors.length);\n\t}\n}\n\nclass PaletteAbstractNodeParamsConfig extends NodeParamsConfig {\n\t/** @param name of the palette */\n\tpaletteName = ParamConfig.STRING(\n\t\t'',\n\t\tpaletteControllerCallbackOptions(PaletteController.PARAM_CALLBACK_updateColors)\n\t);\n\t/** @param click to set the node to the next palette */\n\tpickNext = ParamConfig.BUTTON(null, paletteControllerCallbackOptions(PaletteController.PARAM_CALLBACK_pickNext));\n\t/** @param click to set the node to the previous palette */\n\tpickPrevious = ParamConfig.BUTTON(\n\t\tnull,\n\t\tpaletteControllerCallbackOptions(PaletteController.PARAM_CALLBACK_pickPrevious)\n\t);\n\t/** @param click to set the node to a random palette */\n\tpickRandom = ParamConfig.BUTTON(\n\t\tnull,\n\t\tpaletteControllerCallbackOptions(PaletteController.PARAM_CALLBACK_pickRandom)\n\t);\n\tcolorsCount = ParamConfig.INTEGER(0, {\n\t\thidden: true,\n\t\trange: [0, MAX_PALETTE_COLORS_COUNT],\n\t\tseparatorAfter: true,\n\t});\n\t/** @param palette color 1 */\n\tcolor1 = ParamConfig.COLOR([0, 0, 0], {\n\t\tvisibleIf: visibleIfColorsCountAtLeast(1),\n\t\t// conversion: ColorConversion.SRGB_TO_LINEAR,\n\t});\n\t/** @param palette color 2 */\n\tcolor2 = ParamConfig.COLOR([0, 0, 0], {\n\t\tvisibleIf: visibleIfColorsCountAtLeast(2),\n\t\t// conversion: ColorConversion.SRGB_TO_LINEAR,\n\t});\n\t/** @param palette color 3 */\n\tcolor3 = ParamConfig.COLOR([0, 0, 0], {\n\t\tvisibleIf: visibleIfColorsCountAtLeast(3),\n\t\t// conversion: ColorConversion.SRGB_TO_LINEAR,\n\t});\n\t/** @param palette color 4 */\n\tcolor4 = ParamConfig.COLOR([0, 0, 0], {\n\t\tvisibleIf: visibleIfColorsCountAtLeast(4),\n\t\t// conversion: ColorConversion.SRGB_TO_LINEAR,\n\t});\n\t/** @param palette color 5 */\n\tcolor5 = ParamConfig.COLOR([0, 0, 0], {\n\t\tvisibleIf: visibleIfColorsCountAtLeast(5),\n\t\t// conversion: ColorConversion.SRGB_TO_LINEAR,\n\t});\n}\nconst ParamsConfig = new PaletteAbstractNodeParamsConfig();\n\nexport class PaletteAbstractNode<NC extends NodeContext> extends TypedNode<NC, PaletteAbstractNodeParamsConfig> {\n\toverride paramsConfig = ParamsConfig;\n\t//  static type() {\n\t// \t return 'palette';\n\t//  }\n\n\t//  initializeNode() {\n\t// \t this.params.onParamsCreated('palette_init', () => {\n\t// \t\tPaletteController.paramCallbackUpdateColors(this);\n\t// \t });\n\t//  }\n\tpublic readonly paletteController = new PaletteController<NC>(this);\n\n\t// static PARAM_CALLBACK_pickNext(node: PaletteAbstractNode<any>) {\n\t// \tnode.paletteController.PARAM_CALLBACK_pickNext();\n\t// }\n\t// static PARAM_CALLBACK_pickPrevious(node: PaletteAbstractNode<any>) {\n\t// \tnode.paletteController.PARAM_CALLBACK_pickPrevious();\n\t// }\n\t// static PARAM_CALLBACK_pickRandom(node: PaletteAbstractNode<any>) {\n\t// \tnode.paletteController.PARAM_CALLBACK_pickRandom();\n\t// }\n\t// static PARAM_CALLBACK_updateColors(node: PaletteAbstractNode<any>) {\n\t// \tnode.paletteController.PARAM_CALLBACK_updateColors();\n\t// }\n}\nconst _tmp_color = new Color();\nconst _tmp_color_array: Number3 = [1, 1, 1];\n","import {BaseSopOperation} from './_Base';\nimport {CoreGroup} from '../../../core/geometry/Group';\nimport {Object3D, BufferGeometry, Vector3, BufferAttribute, Float32BufferAttribute} from 'three';\nimport {ObjectType} from '../../../core/geometry/Constant';\nimport {BaseCorePoint, CorePoint} from '../../../core/geometry/entities/point/CorePoint';\nimport {isBooleanTrue} from '../../../core/BooleanValue';\nimport {DefaultOperationParams} from '../../../core/operations/_Base';\nimport { CoreObjectType } from '../../../core/geometry/ObjectContent';\n\nconst _position = new Vector3();\nconst _points:CorePoint<CoreObjectType>[]=[]\ninterface AddSopParams extends DefaultOperationParams {\n\t// create point\n\tcreatePoint: boolean;\n\tpointsCount: number;\n\tposition: Vector3;\n\t// connect input points\n\tconnectInputPoints: boolean;\n\t// open: boolean; // creating a polygon when this is closed still needs work\n\tconnectToLastPoint: boolean;\n}\n\nexport class AddSopOperation extends BaseSopOperation {\n\tstatic override readonly DEFAULT_PARAMS: AddSopParams = {\n\t\tcreatePoint: true,\n\t\tpointsCount: 1,\n\t\tposition: new Vector3(0, 0, 0),\n\t\tconnectInputPoints: false,\n\t\tconnectToLastPoint: false,\n\t};\n\tstatic override type(): Readonly<'add'> {\n\t\treturn 'add';\n\t}\n\n\toverride cook(input_contents: CoreGroup[], params: AddSopParams) {\n\t\tconst objects: Object3D[] = [];\n\t\tthis._createPoint(objects, params);\n\t\tthis._createPolygon(input_contents[0], objects, params);\n\n\t\tif (this._node) {\n\t\t\tlet i = 0;\n\t\t\tfor (let object of objects) {\n\t\t\t\tobject.name = `${this._node.name()}-${i}`;\n\t\t\t\ti++;\n\t\t\t}\n\t\t}\n\n\t\treturn this.createCoreGroupFromObjects(objects);\n\t}\n\tprivate _createPoint(objects: Object3D[], params: AddSopParams) {\n\t\tif (!isBooleanTrue(params.createPoint)) {\n\t\t\treturn;\n\t\t}\n\t\tconst geometry = new BufferGeometry();\n\t\tconst positions: number[] = [];\n\t\tfor (let i = 0; i < params.pointsCount; i++) {\n\t\t\tparams.position.toArray(positions, i * 3);\n\t\t}\n\t\tgeometry.setAttribute('position', new BufferAttribute(new Float32Array(positions), 3));\n\t\tconst object = this.createObject(geometry, ObjectType.POINTS);\n\n\t\tif (objects) {\n\t\t\tobjects.push(object);\n\t\t}\n\t}\n\n\tprivate _createPolygon(coreGroup: CoreGroup, objects: Object3D[], params: AddSopParams) {\n\t\tif (!isBooleanTrue(params.connectInputPoints)) {\n\t\t\treturn;\n\t\t}\n\t\tcoreGroup.points(_points);\n\t\tif (_points.length > 0) {\n\t\t\t// const is_polygon_closed = !params.open && points.length >= 3;\n\t\t\t// if (is_polygon_closed) {\n\t\t\t// \tthis._create_polygon_closed(core_group, objects);\n\t\t\t// } else {\n\t\t\tthis._create_polygon_open(coreGroup, objects, params);\n\t\t\t// }\n\t\t}\n\t}\n\n\t// private _create_polygon_closed(core_group: CoreGroup, objects: Object3D[]) {\n\t// \tconst points = core_group.points();\n\n\t// \tconst geometry = CoreGeometryUtilShape.geometryFromPoints(points.map((p) => p.position()));\n\t// \tconst object = this.createObject(geometry, ObjectType.MESH);\n\t// \tobjects.push(object);\n\t// }\n\n\tprivate _create_polygon_open(coreGroup: CoreGroup, objects: Object3D[], params: AddSopParams) {\n\t\tcoreGroup.points(_points);\n\n\t\tlet positions: number[] = [];\n\t\tconst indices: number[] = [];\n\t\tlet point: BaseCorePoint;\n\t\tconst pointsCount = _points.length\n\t\tfor (let i = 0; i < pointsCount; i++) {\n\t\t\tpoint = _points[i];\n\t\t\tpoint.position(_position).toArray(positions, i * 3);\n\t\t\t// positions.push(point.position().toArray());\n\n\t\t\tif (i > 0) {\n\t\t\t\tindices.push(i - 1);\n\t\t\t\tindices.push(i);\n\t\t\t}\n\t\t}\n\n\t\tif (pointsCount > 2 && params.connectToLastPoint) {\n\t\t\t_points[0].position(_position).toArray(positions, positions.length);\n\t\t\tconst last_index = indices[indices.length - 1];\n\t\t\tindices.push(last_index);\n\t\t\tindices.push(0);\n\t\t}\n\t\tconst geometry = new BufferGeometry();\n\t\tgeometry.setAttribute('position', new Float32BufferAttribute(positions, 3));\n\t\tgeometry.setIndex(indices);\n\t\tconst object = this.createObject(geometry, ObjectType.LINE_SEGMENTS);\n\t\tobjects.push(object);\n\t}\n}\n","import {BaseSopOperation} from './_Base';\nimport {CoreGroup} from '../../../core/geometry/Group';\nimport {InputCloneMode} from '../../../engine/poly/InputCloneMode';\nimport {AmbientLight} from 'three';\nimport {AmbientLightParams, DEFAULT_AMBIENT_LIGHT_PARAMS} from '../../../core/lights/AmbientLight';\nimport {ObjectType, registerObjectType} from '../../../core/geometry/Constant';\n\nexport class AmbientLightSopOperation extends BaseSopOperation {\n\tstatic override readonly DEFAULT_PARAMS: AmbientLightParams = DEFAULT_AMBIENT_LIGHT_PARAMS;\n\tstatic override readonly INPUT_CLONED_STATE = InputCloneMode.NEVER;\n\tstatic override type(): Readonly<'ambientLight'> {\n\t\treturn 'ambientLight';\n\t}\n\toverride cook(_: CoreGroup[], params: AmbientLightParams) {\n\t\tconst light = this.createLight();\n\t\tlight.name = params.name;\n\n\t\tthis.updateLightParams(light, params);\n\t\treturn this.createCoreGroupFromObjects([light]);\n\t}\n\n\tcreateLight() {\n\t\tregisterObjectType({\n\t\t\ttype: ObjectType.AMBIENT_LIGHT,\n\t\t\tcheckFunc: (o) => {\n\t\t\t\tif ((o as AmbientLight).isAmbientLight) {\n\t\t\t\t\treturn ObjectType.AMBIENT_LIGHT;\n\t\t\t\t}\n\t\t\t},\n\t\t\tctor: AmbientLight,\n\t\t\thumanName: 'AmbientLight',\n\t\t});\n\t\tconst light = new AmbientLight();\n\t\tlight.matrixAutoUpdate = false;\n\t\tlight.name = `AmbientLight_${this._node?.name() || ''}`;\n\t\treturn light;\n\t}\n\tupdateLightParams(light: AmbientLight, params: AmbientLightParams) {\n\t\tlight.color.copy(params.color);\n\t\tlight.intensity = params.intensity;\n\t}\n}\n","import {BaseSopOperation} from './_Base';\nimport {CoreGroup} from '../../../core/geometry/Group';\nimport {InputCloneMode} from '../../../engine/poly/InputCloneMode';\nimport {RectAreaLightUniformsLib} from 'three/examples/jsm/lights/RectAreaLightUniformsLib';\nimport {isBooleanTrue} from '../../../core/BooleanValue';\nimport {Group, RectAreaLight} from 'three';\nimport {AreaLightParams, CoreRectAreaLightHelper, DEFAULT_AREA_LIGHT_PARAMS} from '../../../core/lights/AreaLight';\nimport {CoreSceneObjectsFactory, GeneratorName} from '../../../core/CoreSceneObjectsFactory';\n\nexport class AreaLightSopOperation extends BaseSopOperation {\n\tstatic override readonly DEFAULT_PARAMS: AreaLightParams = DEFAULT_AREA_LIGHT_PARAMS;\n\tstatic override readonly INPUT_CLONED_STATE = InputCloneMode.NEVER;\n\tstatic override type(): Readonly<'areaLight'> {\n\t\treturn 'areaLight';\n\t}\n\toverride cook(inputCoreGroups: CoreGroup[], params: AreaLightParams) {\n\t\tconst light = this.createLight();\n\t\tlight.name = params.name;\n\n\t\tthis.updateLightParams(light, params);\n\n\t\tif (isBooleanTrue(params.showHelper)) {\n\t\t\tconst group = new Group();\n\t\t\tgroup.matrixAutoUpdate = false;\n\t\t\tgroup.add(light);\n\t\t\tconst helper = this._createHelper(light);\n\t\t\tif (helper) {\n\t\t\t\tgroup.add(helper);\n\t\t\t}\n\t\t\tgroup.name = `AreaLightGroup_${light.name}`;\n\n\t\t\treturn this.createCoreGroupFromObjects([group]);\n\t\t} else {\n\t\t\treturn this.createCoreGroupFromObjects([light]);\n\t\t}\n\t}\n\n\tcreateLight() {\n\t\tconst light = CoreSceneObjectsFactory.generator(GeneratorName.AREA_LIGHT)({\n\t\t\tcolor: 0xffffff,\n\t\t\tintensity: 1,\n\t\t\twidth: 1,\n\t\t\theight: 1,\n\t\t});\n\t\tlight.matrixAutoUpdate = false;\n\t\tconst nodeName = this._node?.name();\n\t\tif (nodeName) {\n\t\t\tlight.name = `AreaLight_${nodeName}`;\n\t\t}\n\n\t\tif (!(RectAreaLightUniformsLib as any).initialized) {\n\t\t\tRectAreaLightUniformsLib.init();\n\t\t\t(RectAreaLightUniformsLib as any).initialized = true;\n\t\t}\n\n\t\treturn light;\n\t}\n\tupdateLightParams(light: RectAreaLight, params: AreaLightParams) {\n\t\tlight.color = params.color;\n\t\tlight.intensity = params.intensity;\n\t\tlight.width = params.width;\n\t\tlight.height = params.height;\n\n\t\t// this._helperController.update();\n\t}\n\n\tprivate _createHelper(light: RectAreaLight) {\n\t\tconst nodeName = this._node?.name();\n\t\tif (nodeName) {\n\t\t\tconst helper = new CoreRectAreaLightHelper(light, nodeName);\n\t\t\thelper.update();\n\t\t\treturn helper;\n\t\t}\n\t}\n}\n","import {BaseSopOperation} from './_Base';\nimport {CoreGroup} from '../../../core/geometry/Group';\nimport {InputCloneMode} from '../../../engine/poly/InputCloneMode';\nimport {BufferAttribute} from 'three';\nimport {BufferGeometry} from 'three';\nimport {DefaultOperationParams} from '../../../core/operations/_Base';\ninterface AttribAddMultSopParams extends DefaultOperationParams {\n\tname: string;\n\tpreAdd: number;\n\tmult: number;\n\tpostAdd: number;\n}\n\nexport class AttribAddMultSopOperation extends BaseSopOperation {\n\tstatic override readonly DEFAULT_PARAMS: AttribAddMultSopParams = {\n\t\tname: '',\n\t\tpreAdd: 0,\n\t\tmult: 1,\n\t\tpostAdd: 0,\n\t};\n\tstatic override readonly INPUT_CLONED_STATE = InputCloneMode.FROM_NODE;\n\tstatic override type(): Readonly<'attribAddMult'> {\n\t\treturn 'attribAddMult';\n\t}\n\n\toverride cook(inputCoreGroups: CoreGroup[], params: AttribAddMultSopParams) {\n\t\tconst coreGroup = inputCoreGroups[0];\n\t\tconst attribNames = coreGroup.pointAttribNamesMatchingMask(params.name);\n\n\t\tfor (let attribName of attribNames) {\n\t\t\tconst geometries = coreGroup.geometries();\n\t\t\tfor (let geometry of geometries) {\n\t\t\t\tthis._updateAttrib(attribName, geometry, params);\n\t\t\t}\n\t\t}\n\n\t\treturn coreGroup;\n\t}\n\tprivate _updateAttrib(attribName: string, geometry: BufferGeometry, params: AttribAddMultSopParams) {\n\t\tconst attribute = geometry.getAttribute(attribName) as BufferAttribute;\n\t\tif (attribute) {\n\t\t\tconst values = attribute.array ;\n\n\t\t\tconst preAdd = params.preAdd;\n\t\t\tconst mult = params.mult;\n\t\t\tconst postAdd = params.postAdd;\n\t\t\tfor (let i = 0; i < values.length; i++) {\n\t\t\t\tconst value = values[i];\n\t\t\t\tvalues[i] = (value + preAdd) * mult + postAdd;\n\t\t\t}\n\t\t\t// if (!this.io.inputs.clone_required(0)) {\n\t\t\tattribute.needsUpdate = true;\n\t\t\t// }\n\t\t}\n\t}\n}\n","import {BaseSopOperation} from './_Base';\nimport {CoreGroup} from '../../../core/geometry/Group';\nimport {InputCloneMode} from '../../../engine/poly/InputCloneMode';\nimport {\n\tFloat64BufferAttribute,\n\tFloat32BufferAttribute,\n\tFloat16BufferAttribute,\n\tUint32BufferAttribute,\n\tInt32BufferAttribute,\n\tUint16BufferAttribute,\n\tInt16BufferAttribute,\n\tUint8ClampedBufferAttribute,\n\tUint8BufferAttribute,\n\tInt8BufferAttribute,\n\tBufferAttribute,\n} from 'three';\nimport {isBooleanTrue} from '../../../core/BooleanValue';\nimport {DefaultOperationParams} from '../../../core/operations/_Base';\nimport {CoreObjectType, ObjectContent} from '../../../core/geometry/ObjectContent';\nimport {corePointClassFactory, coreVertexClassFactory} from '../../../core/geometry/CoreObjectFactory';\n\nexport enum AttribType {\n\tFloat64BufferAttribute = 'Float64BufferAttribute',\n\tFloat32BufferAttribute = 'Float32BufferAttribute',\n\tFloat16BufferAttribute = 'Float16BufferAttribute',\n\tUint32BufferAttribute = 'Uint32BufferAttribute',\n\tInt32BufferAttribute = 'Int32BufferAttribute',\n\tUint16BufferAttribute = 'Uint16BufferAttribute',\n\tInt16BufferAttribute = 'Int16BufferAttribute',\n\tUint8ClampedBufferAttribute = 'Uint8ClampedBufferAttribute',\n\tUint8BufferAttribute = 'Uint8BufferAttribute',\n\tInt8BufferAttribute = 'Int8BufferAttribute',\n}\n\nexport const ATTRIB_TYPES: AttribType[] = [\n\tAttribType.Float64BufferAttribute,\n\tAttribType.Float32BufferAttribute,\n\tAttribType.Float16BufferAttribute,\n\tAttribType.Uint32BufferAttribute,\n\tAttribType.Int32BufferAttribute,\n\tAttribType.Uint16BufferAttribute,\n\tAttribType.Int16BufferAttribute,\n\tAttribType.Uint8ClampedBufferAttribute,\n\tAttribType.Uint8BufferAttribute,\n\tAttribType.Int8BufferAttribute,\n];\nconst ATTRIB_CLASS_BY_TYPE = {\n\t[AttribType.Float64BufferAttribute]: Float64BufferAttribute,\n\t[AttribType.Float32BufferAttribute]: Float32BufferAttribute,\n\t[AttribType.Float16BufferAttribute]: Float16BufferAttribute,\n\t[AttribType.Uint32BufferAttribute]: Uint32BufferAttribute,\n\t[AttribType.Int32BufferAttribute]: Int32BufferAttribute,\n\t[AttribType.Uint16BufferAttribute]: Uint16BufferAttribute,\n\t[AttribType.Int16BufferAttribute]: Int16BufferAttribute,\n\t[AttribType.Uint8ClampedBufferAttribute]: Uint8ClampedBufferAttribute,\n\t[AttribType.Uint8BufferAttribute]: Uint8BufferAttribute,\n\t[AttribType.Int8BufferAttribute]: Int8BufferAttribute,\n};\nconst ARRAY_CLASS_BY_TYPE = {\n\t[AttribType.Float64BufferAttribute]: Float64Array,\n\t[AttribType.Float32BufferAttribute]: Float32Array,\n\t[AttribType.Float16BufferAttribute]: Uint16Array,\n\t[AttribType.Uint32BufferAttribute]: Uint32Array,\n\t[AttribType.Int32BufferAttribute]: Int32Array,\n\t[AttribType.Uint16BufferAttribute]: Uint16Array,\n\t[AttribType.Int16BufferAttribute]: Int16Array,\n\t[AttribType.Uint8ClampedBufferAttribute]: Uint8Array,\n\t[AttribType.Uint8BufferAttribute]: Uint8Array,\n\t[AttribType.Int8BufferAttribute]: Int8Array,\n};\n\ninterface AttribCastSopParams extends DefaultOperationParams {\n\tcastAttributes: boolean;\n\tmask: string;\n\tcastIndex: boolean;\n\ttype: number;\n}\n\nexport class AttribCastSopOperation extends BaseSopOperation {\n\tstatic override readonly DEFAULT_PARAMS: AttribCastSopParams = {\n\t\tcastAttributes: true,\n\t\tmask: '*',\n\t\tcastIndex: false,\n\t\ttype: ATTRIB_TYPES.indexOf(AttribType.Float32BufferAttribute),\n\t};\n\tstatic override readonly INPUT_CLONED_STATE = InputCloneMode.FROM_NODE;\n\tstatic override type(): Readonly<'attribCast'> {\n\t\treturn 'attribCast';\n\t}\n\n\toverride cook(inputCoreGroups: CoreGroup[], params: AttribCastSopParams) {\n\t\tconst coreGroup = inputCoreGroups[0];\n\t\tconst objects = coreGroup.allObjects();\n\t\tfor (let object of objects) {\n\t\t\tthis._castPointAttributes(object, params);\n\t\t}\n\n\t\treturn coreGroup;\n\t}\n\n\tprivate _castPointAttributes<T extends CoreObjectType>(object: ObjectContent<T>, params: AttribCastSopParams) {\n\t\tconst type = ATTRIB_TYPES[params.type];\n\t\tconst attribClass = ATTRIB_CLASS_BY_TYPE[type];\n\t\tconst arrayClass = ARRAY_CLASS_BY_TYPE[type];\n\t\tconst corePointClass = corePointClassFactory(object);\n\n\t\tif (isBooleanTrue(params.castAttributes)) {\n\t\t\tconst attribNames = corePointClass.attributeNamesMatchingMask(object, params.mask);\n\t\t\tfor (let attribName of attribNames) {\n\t\t\t\tconst attrib: BufferAttribute = corePointClass.attribute(object, attribName) as BufferAttribute;\n\t\t\t\tconst array = attrib.array;\n\t\t\t\tconst count = attrib.count;\n\t\t\t\tconst itemSize = attrib.itemSize;\n\t\t\t\tconst newArray = new arrayClass(count * itemSize);\n\t\t\t\tfor (let i = 0; i < array.length; i++) {\n\t\t\t\t\tnewArray[i] = array[i];\n\t\t\t\t}\n\t\t\t\tconst newAttribute = new attribClass(newArray, itemSize);\n\t\t\t\tcorePointClass.addAttribute(object, attribName, newAttribute);\n\t\t\t}\n\t\t}\n\n\t\t// index\n\t\tif (params.castIndex) {\n\t\t\tconst coreVertexClass = coreVertexClassFactory(object);\n\t\t\tconst index = coreVertexClass.indexAttribute(object);\n\t\t\tif (index) {\n\t\t\t\tconst array = index.array;\n\t\t\t\tconst count = index.count;\n\t\t\t\tconst itemSize = 1;\n\n\t\t\t\tconst newArray = new arrayClass(count * itemSize);\n\t\t\t\tfor (let i = 0; i < array.length; i++) {\n\t\t\t\t\tnewArray[i] = array[i];\n\t\t\t\t}\n\n\t\t\t\tconst newAttr = new attribClass(newArray, itemSize);\n\t\t\t\tcoreVertexClass.setIndexAttribute(object, newAttr);\n\t\t\t}\n\t\t}\n\t}\n}\n","import {BaseSopOperation} from './_Base';\nimport {CoreGroup} from '../../../core/geometry/Group';\nimport {BufferGeometry} from 'three';\nimport {BufferAttribute, Float32BufferAttribute} from 'three';\nimport {InputCloneMode} from '../../../engine/poly/InputCloneMode';\nimport {isBooleanTrue} from '../../../core/BooleanValue';\nimport {DefaultOperationParams} from '../../../core/operations/_Base';\nimport {stringToAttribNames} from '../../../core/String';\nimport {ATTRIBUTE_CLASSES, AttribClass} from '../../../core/geometry/Constant';\nimport {TypeAssert} from '../../../engine/poly/Assert';\nimport {coreObjectClassFactory} from '../../../core/geometry/CoreObjectFactory';\ninterface AttribCopySopParams extends DefaultOperationParams {\n\tclass: number;\n\tname: string;\n\ttnewName: boolean;\n\tnewName: string;\n\tsrcOffset: number;\n\tdestOffset: number;\n}\n\ninterface CopyArgs {\n\tparams: AttribCopySopParams;\n\tattribName: {\n\t\tsrc: string;\n\t\tdest: string;\n\t};\n}\n\ninterface CopyBetweenCoreGroupsArgs extends CopyArgs {\n\tcoreGroup: {\n\t\tsrc: CoreGroup;\n\t\tdest: CoreGroup;\n\t};\n}\ninterface CopyBetweenGeometriesArgs extends CopyArgs {\n\tgeo: {\n\t\tsrc: BufferGeometry;\n\t\tdest: BufferGeometry;\n\t};\n}\nconst _newNames:string[]=[]\nconst _attribNames:string[]=[]\nexport class AttribCopySopOperation extends BaseSopOperation {\n\tstatic override readonly DEFAULT_PARAMS: AttribCopySopParams = {\n\t\tclass: ATTRIBUTE_CLASSES.indexOf(AttribClass.POINT),\n\t\tname: '',\n\t\ttnewName: false,\n\t\tnewName: '',\n\t\tsrcOffset: 0,\n\t\tdestOffset: 0,\n\t};\n\tstatic override readonly INPUT_CLONED_STATE = [InputCloneMode.FROM_NODE, InputCloneMode.NEVER];\n\tstatic override type(): Readonly<'attribCopy'> {\n\t\treturn 'attribCopy';\n\t}\n\n\toverride cook(inputCoreGroups: CoreGroup[], params: AttribCopySopParams) {\n\t\tconst coreGroupDest = inputCoreGroups[0];\n\t\tconst coreGroupSrc = inputCoreGroups[1] || coreGroupDest;\n\t\tconst attribClass = ATTRIBUTE_CLASSES[params.class];\n\t\tstringToAttribNames(params.newName,_newNames);\n\n\t\tif (attribClass == AttribClass.POINT) {\n\t\t\t// for geometry attributes, first iterate over the existing attributes\n\t\t\tconst srcAttribNames = coreGroupSrc.pointAttribNamesMatchingMask(params.name);\n\t\t\tfor (let i = 0; i < srcAttribNames.length; i++) {\n\t\t\t\tconst srcAttribName = srcAttribNames[i];\n\t\t\t\tlet destAttribName = isBooleanTrue(params.tnewName) ? _newNames[i] : srcAttribName;\n\t\t\t\tif (!destAttribName) {\n\t\t\t\t\tthis.states?.error.set(`no matching new attribute name of ${srcAttribName}`);\n\t\t\t\t\treturn coreGroupDest;\n\t\t\t\t}\n\t\t\t\tthis._copyAttributeBetweenCoreGroups(attribClass, {\n\t\t\t\t\tattribName: {\n\t\t\t\t\t\tsrc: srcAttribName,\n\t\t\t\t\t\tdest: destAttribName,\n\t\t\t\t\t},\n\t\t\t\t\tparams,\n\t\t\t\t\tcoreGroup: {src: coreGroupSrc, dest: coreGroupDest},\n\t\t\t\t});\n\t\t\t}\n\t\t} else {\n\t\t\t// for object attributes, first iterate over the existing attributes\n\t\t\tstringToAttribNames(params.name,_attribNames);\n\t\t\tfor (let i = 0; i < _attribNames.length; i++) {\n\t\t\t\tconst destAttribName = isBooleanTrue(params.tnewName) ? _newNames[i] : _attribNames[i];\n\t\t\t\tthis._copyAttributeBetweenCoreGroups(attribClass, {\n\t\t\t\t\tattribName: {\n\t\t\t\t\t\tsrc: _attribNames[i],\n\t\t\t\t\t\tdest: destAttribName,\n\t\t\t\t\t},\n\t\t\t\t\tparams,\n\t\t\t\t\tcoreGroup: {src: coreGroupSrc, dest: coreGroupDest},\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\n\t\treturn coreGroupDest;\n\t}\n\n\tprivate _copyAttributeBetweenCoreGroups(attribClass: AttribClass, copyArgs: CopyBetweenCoreGroupsArgs) {\n\t\tswitch (attribClass) {\n\t\t\tcase AttribClass.POINT:\n\t\t\t\tthis._copyAttributesBetweenGeometries(copyArgs);\n\t\t\t\treturn;\n\t\t\tcase AttribClass.VERTEX:\n\t\t\t\tthis.states?.error.set('vertex attributes are not supported yet');\n\t\t\t\treturn;\n\t\t\tcase AttribClass.PRIMITIVE:\n\t\t\t\tthis.states?.error.set('primitive attributes are not supported yet');\n\t\t\t\treturn;\n\t\t\tcase AttribClass.OBJECT:\n\t\t\t\tthis._copyAttributesBetweenObjects(copyArgs);\n\t\t\t\treturn;\n\t\t\tcase AttribClass.CORE_GROUP:\n\t\t\t\tthis._copyAttributesBetweenCoreGroups(copyArgs);\n\t\t\t\treturn;\n\t\t}\n\t\tTypeAssert.unreachable(attribClass);\n\t}\n\tprivate _copyAttributesBetweenGeometries(copyArgs: CopyBetweenCoreGroupsArgs) {\n\t\tconst {coreGroup, attribName, params} = copyArgs;\n\t\tconst srcObjects = coreGroup.src.threejsObjectsWithGeo();\n\t\tconst destObjects = coreGroup.dest.threejsObjectsWithGeo();\n\n\t\tif (destObjects.length > srcObjects.length) {\n\t\t\tthis.states?.error.set('second input does not have enough objects to copy attributes from');\n\t\t} else {\n\t\t\tfor (let i = 0; i < destObjects.length; i++) {\n\t\t\t\tconst destGeometry = destObjects[i].geometry;\n\t\t\t\tconst srcGeometry = srcObjects[i].geometry;\n\t\t\t\tthis._copyPointAttributesBetweenGeometries({\n\t\t\t\t\tgeo: {src: srcGeometry, dest: destGeometry},\n\t\t\t\t\tattribName,\n\t\t\t\t\tparams,\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\t}\n\tprivate _copyAttributesBetweenObjects(copyArgs: CopyBetweenCoreGroupsArgs) {\n\t\tconst {coreGroup, attribName} = copyArgs;\n\t\tconst srcObjects = coreGroup.src.allObjects();\n\t\tconst destObjects = coreGroup.dest.allObjects();\n\n\t\tif (destObjects.length > srcObjects.length) {\n\t\t\tthis.states?.error.set('second input does not have enough objects to copy attributes from');\n\t\t} else {\n\t\t\tfor (let i = 0; i < destObjects.length; i++) {\n\t\t\t\tconst destObject = destObjects[i];\n\t\t\t\tconst srcObject = srcObjects[i];\n\t\t\t\tconst srcAttribValue = coreObjectClassFactory(srcObject).attribValue(srcObject, attribName.src);\n\t\t\t\tif (srcAttribValue != null) {\n\t\t\t\t\tcoreObjectClassFactory(destObject).setAttribute(destObject, attribName.dest, srcAttribValue);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tprivate _copyAttributesBetweenCoreGroups(copyArgs: CopyBetweenCoreGroupsArgs) {\n\t\tconst {coreGroup, attribName} = copyArgs;\n\t\tconst srcCoreGroup = coreGroup.src;\n\t\tconst destCoreGroup = coreGroup.dest;\n\n\t\tconst srcAttribValue = srcCoreGroup.attribValue(attribName.src);\n\t\tif (srcAttribValue != null) {\n\t\t\tdestCoreGroup.setAttribValue(attribName.dest, srcAttribValue);\n\t\t}\n\t}\n\n\tprivate _copyPointAttributesBetweenGeometries(copyArgs: CopyBetweenGeometriesArgs) {\n\t\tconst {geo, attribName, params} = copyArgs;\n\t\tconst srcAttrib = geo.src.getAttribute(attribName.src) as BufferAttribute | undefined;\n\t\tif (srcAttrib) {\n\t\t\tconst size = srcAttrib.itemSize;\n\t\t\tconst destAttrib = geo.dest.getAttribute(attribName.dest) as BufferAttribute | undefined;\n\t\t\tconst srcPointsCount = srcAttrib.array.length / srcAttrib.itemSize;\n\n\t\t\tif (destAttrib) {\n\t\t\t\tconst destPointsCount = destAttrib.array.length / destAttrib.itemSize;\n\t\t\t\tif (destPointsCount > srcPointsCount) {\n\t\t\t\t\tthis.states?.error.set(`not enough points in second input`);\n\t\t\t\t} else {\n\t\t\t\t\tthis._fillDestArray(destAttrib as BufferAttribute, srcAttrib as BufferAttribute, params);\n\t\t\t\t\t(destAttrib as BufferAttribute).needsUpdate = true;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tconst src_array = srcAttrib.array;\n\t\t\t\tconst destPointsCount = (geo.dest.getAttribute('position') as BufferAttribute).array.length / 3;\n\t\t\t\tconst dest_array = src_array.slice(0, destPointsCount * size);\n\t\t\t\tgeo.dest.setAttribute(attribName.dest, new Float32BufferAttribute(dest_array, size));\n\t\t\t}\n\t\t} else {\n\t\t\tthis.states?.error.set(`attribute '${attribName}' does not exist on second input`);\n\t\t}\n\t}\n\n\tprivate _fillDestArray(\n\t\tdest_attribute: BufferAttribute,\n\t\tsrc_attribute: BufferAttribute,\n\t\tparams: AttribCopySopParams\n\t) {\n\t\tconst dest_array = dest_attribute.array;\n\t\tconst src_array = src_attribute.array;\n\t\tconst dest_array_size = dest_array.length;\n\t\tconst dest_item_size = dest_attribute.itemSize;\n\t\tconst src_item_size = src_attribute.itemSize;\n\t\tconst srcOffset = params.srcOffset;\n\t\tconst destOffset = params.destOffset;\n\t\t// if same itemSize, we copy item by item\n\t\tif (dest_attribute.itemSize == src_attribute.itemSize) {\n\t\t\tdest_attribute.copyArray(src_attribute.array);\n\t\t\tfor (let i = 0; i < dest_array_size; i++) {\n\t\t\t\tdest_array[i] = src_array[i];\n\t\t\t}\n\t\t} else {\n\t\t\tconst pointsCount = dest_array.length / dest_item_size;\n\t\t\tif (dest_item_size < src_item_size) {\n\t\t\t\t// if dest attrib is smaller than src attrib (ie: vector -> to float)\n\t\t\t\t// we copy only the selected items from src\n\t\t\t\tfor (let i = 0; i < pointsCount; i++) {\n\t\t\t\t\tfor (let j = 0; j < dest_item_size; j++) {\n\t\t\t\t\t\tdest_array[i * dest_item_size + j + destOffset] = src_array[i * src_item_size + j + srcOffset];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// if dest attrib is larger than src attrib (ie: float -> vector )\n\t\t\t\tfor (let i = 0; i < pointsCount; i++) {\n\t\t\t\t\tfor (let j = 0; j < src_item_size; j++) {\n\t\t\t\t\t\tdest_array[i * dest_item_size + j + destOffset] = src_array[i * src_item_size + j + srcOffset];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n","import {BaseSopOperation} from './_Base';\nimport {CoreGroup} from '../../../core/geometry/Group';\nimport {InputCloneMode} from '../../../engine/poly/InputCloneMode';\nimport {DefaultOperationParams} from '../../../core/operations/_Base';\nimport {AttribClass, ATTRIBUTE_CLASSES} from '../../../core/geometry/Constant';\nimport {ENTITY_CLASS_FACTORY} from '../../../core/geometry/CoreObjectFactory';\nimport {filterObjectsFromCoreGroup} from '../../../core/geometry/Mask';\n\ninterface AttribDeleteSopParams extends DefaultOperationParams {\n\tgroup: string;\n\tclass: number;\n\tname: string;\n}\nexport class AttribDeleteSopOperation extends BaseSopOperation {\n\tstatic override readonly DEFAULT_PARAMS: AttribDeleteSopParams = {\n\t\tgroup: '',\n\t\tclass: ATTRIBUTE_CLASSES.indexOf(AttribClass.POINT),\n\t\tname: '',\n\t};\n\tstatic override readonly INPUT_CLONED_STATE = InputCloneMode.FROM_NODE;\n\tstatic override type(): Readonly<'attribDelete'> {\n\t\treturn 'attribDelete';\n\t}\n\toverride cook(inputCoreGroups: CoreGroup[], params: AttribDeleteSopParams) {\n\t\tconst coreGroup = inputCoreGroups[0];\n\t\tconst objects = filterObjectsFromCoreGroup(coreGroup, params);\n\t\tconst attribClass = ATTRIBUTE_CLASSES[params.class];\n\t\tconst factory = ENTITY_CLASS_FACTORY[attribClass];\n\t\tif (factory) {\n\t\t\tfor (const object of objects) {\n\t\t\t\tconst entityClass = factory(object);\n\t\t\t\tconst attribNames = entityClass.attributeNamesMatchingMask(object, params.name);\n\t\t\t\tfor (const attribName of attribNames) {\n\t\t\t\t\tentityClass.deleteAttribute(object, attribName);\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tconst attribNames = coreGroup.attributeNamesMatchingMask(params.name);\n\t\t\tfor (const attribName of attribNames) {\n\t\t\t\tcoreGroup.deleteAttribute(attribName);\n\t\t\t}\n\t\t}\n\t\treturn coreGroup;\n\t}\n}\n","import {DataTexture, Texture, BufferAttribute} from 'three';\nimport {CoreImage} from '../../Image';\nimport {CoreAttribute} from '../../geometry/Attribute';\nimport {clamp} from '../../math/_Module';\nimport {CoreObjectType, ObjectContent} from '../ObjectContent';\nimport {corePointClassFactory} from '../CoreObjectFactory';\n\ninterface AttribFromTextureParams<T extends CoreObjectType> {\n\tobject: ObjectContent<T>;\n\ttexture: Texture;\n\tuvAttribName: string;\n\ttargetAttribName: string;\n\ttargetAttribSize: number;\n\tadd: number;\n\tmult: number;\n}\n\nexport class AttribFromTexture {\n\t// currently assumes we read the red channel and create a 1-dimension (float) attribute\n\tsetAttribute<T extends CoreObjectType>(params: AttribFromTextureParams<T>) {\n\t\tconst {object, texture, uvAttribName, targetAttribName, targetAttribSize, add, mult} = params;\n\t\tconst corePointClass = corePointClassFactory(object);\n\t\tif (targetAttribSize < 1 || targetAttribSize > 4) {\n\t\t\treturn;\n\t\t}\n\t\tconst texture_data = this._dataFromTexture(texture);\n\t\tif (!texture_data) {\n\t\t\treturn;\n\t\t}\n\t\tconst {data, resx, resy} = texture_data;\n\t\tconst texture_component_size = data.length / (resx * resy);\n\n\t\tconst uv_attrib = corePointClass.attribute(object, uvAttribName);\n\t\tif (!uv_attrib) {\n\t\t\treturn;\n\t\t}\n\t\tconst uvs = uv_attrib.array;\n\n\t\tconst points_count = uvs.length / 2;\n\t\tconst values: number[] = new Array(points_count * targetAttribSize);\n\n\t\tlet uv_stride: number,\n\t\t\tuvx: number,\n\t\t\tuvy: number,\n\t\t\tx: number,\n\t\t\ty: number,\n\t\t\ti: number,\n\t\t\tj: number,\n\t\t\tval: number,\n\t\t\tc: number;\n\n\t\tfor (i = 0; i < points_count; i++) {\n\t\t\tuv_stride = i * 2;\n\t\t\tuvx = clamp(uvs[uv_stride], 0, 1);\n\t\t\tuvy = clamp(uvs[uv_stride + 1], 0, 1);\n\t\t\tx = Math.floor((resx - 1) * uvx);\n\t\t\ty = Math.floor((resy - 1) * (1 - uvy));\n\t\t\tj = y * resx + x;\n\n\t\t\tfor (c = 0; c < targetAttribSize; c++) {\n\t\t\t\tval = data[texture_component_size * j + c];\n\n\t\t\t\t// index = i * targetAttribSize;\n\t\t\t\tvalues[i * targetAttribSize + c] = mult * val + add;\n\t\t\t}\n\t\t}\n\n\t\tconst attribName = CoreAttribute.remapName(targetAttribName);\n\t\tconst array = new Float32Array(values);\n\t\tcorePointClass.addAttribute(object, attribName, new BufferAttribute(array, targetAttribSize));\n\t}\n\n\tprivate _dataFromTexture(texture: Texture) {\n\t\tif (texture.image) {\n\t\t\tif (texture.image.data) {\n\t\t\t\treturn this._dataFromDataTexture(texture as DataTexture);\n\t\t\t}\n\t\t\treturn this._dataFromDefaultTexture(texture);\n\t\t}\n\t}\n\tprivate _dataFromDefaultTexture(texture: Texture) {\n\t\tconst resx = texture.image.width;\n\t\tconst resy = texture.image.height;\n\t\tconst image_data = CoreImage.data_from_image(texture.image);\n\t\tconst data = image_data.data;\n\t\treturn {\n\t\t\tdata,\n\t\t\tresx,\n\t\t\tresy,\n\t\t};\n\t}\n\tprivate _dataFromDataTexture(texture: DataTexture) {\n\t\tconst data = texture.image.data;\n\t\tconst resx = texture.image.width;\n\t\tconst resy = texture.image.height;\n\t\treturn {\n\t\t\tdata,\n\t\t\tresx,\n\t\t\tresy,\n\t\t};\n\t}\n}\n","import {BaseSopOperation} from './_Base';\nimport {CoreGroup} from '../../../core/geometry/Group';\nimport {TypedNodePathParamValue, NODE_PATH_DEFAULT} from '../../../core/Walker';\nimport {NodeContext} from '../../../engine/poly/NodeContext';\nimport {AttribFromTexture} from '../../../core/geometry/operation/AttribFromTexture';\nimport {Texture} from 'three';\nimport {InputCloneMode} from '../../../engine/poly/InputCloneMode';\nimport {DefaultOperationParams} from '../../../core/operations/_Base';\nimport {CoreObjectType, ObjectContent} from '../../../core/geometry/ObjectContent';\nimport {corePointClassFactory} from '../../../core/geometry/CoreObjectFactory';\n\ninterface AttribFromTextureSopParams extends DefaultOperationParams {\n\ttexture: TypedNodePathParamValue;\n\tuvAttrib: string;\n\tattrib: string;\n\tattribSize: number;\n\tadd: number;\n\tmult: number;\n}\n\nexport class AttribFromTextureSopOperation extends BaseSopOperation {\n\tstatic override readonly DEFAULT_PARAMS: AttribFromTextureSopParams = {\n\t\ttexture: new TypedNodePathParamValue(NODE_PATH_DEFAULT.NODE.EMPTY),\n\t\tuvAttrib: 'uv',\n\t\tattrib: 'pscale',\n\t\tattribSize: 1,\n\t\tadd: 0,\n\t\tmult: 1,\n\t};\n\tstatic override readonly INPUT_CLONED_STATE = InputCloneMode.FROM_NODE;\n\tstatic override type(): Readonly<'attribFromTexture'> {\n\t\treturn 'attribFromTexture';\n\t}\n\n\toverride async cook(inputCoreGroups: CoreGroup[], params: AttribFromTextureSopParams) {\n\t\tconst coreGroup = inputCoreGroups[0];\n\n\t\tconst textureNode = params.texture.nodeWithContext(NodeContext.COP, this.states?.error);\n\t\tif (!textureNode) {\n\t\t\treturn coreGroup;\n\t\t}\n\t\tconst container = await textureNode.compute();\n\t\tconst texture = container.texture();\n\t\tconst objects = coreGroup.allObjects();\n\t\tfor (const object of objects) {\n\t\t\tthis._setPositionFromDataTexture(object, texture, params);\n\t\t}\n\n\t\treturn coreGroup;\n\t}\n\tprivate _setPositionFromDataTexture<T extends CoreObjectType>(\n\t\tobject: ObjectContent<T>,\n\t\ttexture: Texture,\n\t\tparams: AttribFromTextureSopParams\n\t) {\n\t\tconst corePointClass = corePointClassFactory(object);\n\t\tconst uvAttrib = corePointClass.attribute(object, params.uvAttrib);\n\n\t\tif (uvAttrib == null) {\n\t\t\tthis.states?.error.set(`param '${params.uvAttrib} not found'`);\n\t\t\treturn;\n\t\t}\n\t\tconst operation = new AttribFromTexture();\n\t\toperation.setAttribute({\n\t\t\tobject,\n\t\t\ttexture,\n\t\t\tuvAttribName: params.uvAttrib,\n\t\t\ttargetAttribName: params.attrib,\n\t\t\ttargetAttribSize: params.attribSize,\n\t\t\tadd: params.add,\n\t\t\tmult: params.mult,\n\t\t});\n\t}\n}\n","import {TypeAssert} from './../../poly/Assert';\nimport {AttribClass, ATTRIBUTE_CLASSES_WITHOUT_CORE_GROUP} from './../../../core/geometry/Constant';\nimport {BaseSopOperation} from './_Base';\nimport {CoreGroup} from '../../../core/geometry/Group';\n// import {Attribute} from '../../../core/geometry/Attribute';\nimport {DefaultOperationParams} from '../../../core/operations/_Base';\nimport {BufferAttribute} from 'three';\nimport {isBooleanTrue} from '../../../core/Type';\n// import {BaseCoreObject} from '../../../core/geometry/entities/object/BaseCoreObject';\nimport {CoreObjectType, ObjectContent} from '../../../core/geometry/ObjectContent';\nimport {CoreEntity} from '../../../core/geometry/CoreEntity';\nimport {\n\tcorePointClassFactory,\n\tcorePrimitiveClassFactory,\n\tcoreVertexClassFactory,\n} from '../../../core/geometry/CoreObjectFactory';\nimport {PrimitiveNumberAttribute} from '../../../core/geometry/entities/primitive/PrimitiveAttribute';\nimport {primitivesFromObject} from '../../../core/geometry/entities/primitive/CorePrimitiveUtils';\nimport {CorePoint} from '../../../core/geometry/entities/point/CorePoint';\nimport {CorePrimitive} from '../../../core/geometry/entities/primitive/CorePrimitive';\nimport {pointsFromObject} from '../../../core/geometry/entities/point/CorePointUtils';\nimport {CoreVertex} from '../../../core/geometry/entities/vertex/CoreVertex';\nimport {verticesFromObject} from '../../../core/geometry/entities/vertex/CoreVertexUtils';\nimport {VertexNumberAttribute} from '../../../core/geometry/entities/vertex/VertexAttribute';\n\ninterface AttribIdSopParams extends DefaultOperationParams {\n\tclass: number;\n\tid: boolean;\n\tidName: string;\n\tidn: boolean;\n\tidnName: string;\n}\nconst _points: CorePoint<CoreObjectType>[] = [];\nconst _vertices: CoreVertex<CoreObjectType>[] = [];\nconst _primitives: CorePrimitive<CoreObjectType>[] = [];\n\nexport class AttribIdSopOperation extends BaseSopOperation {\n\tstatic override readonly DEFAULT_PARAMS: AttribIdSopParams = {\n\t\tclass: ATTRIBUTE_CLASSES_WITHOUT_CORE_GROUP.indexOf(AttribClass.POINT),\n\t\tid: true,\n\t\tidName: 'id',\n\t\tidn: true,\n\t\tidnName: 'idn',\n\t};\n\tstatic override type(): Readonly<'attribId'> {\n\t\treturn 'attribId';\n\t}\n\n\toverride cook(inputCoreGroups: CoreGroup[], params: AttribIdSopParams) {\n\t\tconst coreGroup = inputCoreGroups[0];\n\n\t\tconst attribClass = ATTRIBUTE_CLASSES_WITHOUT_CORE_GROUP[params.class];\n\t\tthis._addAttribute(attribClass, coreGroup, params);\n\t\treturn coreGroup;\n\t}\n\tprivate async _addAttribute(attribClass: AttribClass, coreGroup: CoreGroup, params: AttribIdSopParams) {\n\t\tconst objects = coreGroup.allObjects();\n\t\tswitch (attribClass) {\n\t\t\tcase AttribClass.POINT:\n\t\t\t\treturn this._addPointAttributesToObjects(objects, params);\n\t\t\tcase AttribClass.VERTEX: {\n\t\t\t\tthis._addVertexAttributesToObjects(objects, params);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tcase AttribClass.PRIMITIVE: {\n\t\t\t\tthis._addPrimitiveAttributesToObjects(objects, params);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tcase AttribClass.OBJECT:\n\t\t\t\treturn this._addAttributesToEntities(coreGroup.allCoreObjects(), params);\n\t\t\tcase AttribClass.CORE_GROUP:\n\t\t\t\t// no effect\n\t\t\t\treturn;\n\t\t}\n\t\tTypeAssert.unreachable(attribClass);\n\t}\n\n\t// private _addObjectAttributes(coreObjects: BaseCoreObject<CoreObjectType>[], params: AttribIdSopParams) {\n\t// \tconst objectsCount = coreObjects.length;\n\t// \tif (objectsCount > 1) {\n\t// \t\tlet i = 0;\n\t// \t\tfor (const coreObject of coreObjects) {\n\t// \t\t\tif (isBooleanTrue(params.id)) {\n\t// \t\t\t\tcoreObject.addAttribute(params.idName, i);\n\t// \t\t\t}\n\t// \t\t\tif (isBooleanTrue(params.idn)) {\n\t// \t\t\t\tcoreObject.addAttribute(params.idnName, i / (objectsCount - 1));\n\t// \t\t\t}\n\n\t// \t\t\ti++;\n\t// \t\t}\n\t// \t} else {\n\t// \t\tcoreObjects[0].addAttribute(params.idName, 0);\n\t// \t\tcoreObjects[0].addAttribute(params.idnName, 0);\n\t// \t}\n\t// }\n\n\tprivate _addPointAttributesToObjects(objects: ObjectContent<CoreObjectType>[], params: AttribIdSopParams) {\n\t\tfor (const object of objects) {\n\t\t\tthis._addPointAttributesToObject(object, params);\n\t\t}\n\t}\n\tprivate _addVertexAttributesToObjects(objects: ObjectContent<CoreObjectType>[], params: AttribIdSopParams) {\n\t\tfor (const object of objects) {\n\t\t\tthis._addVertexAttributes(object, params);\n\t\t}\n\t}\n\tprivate _addPrimitiveAttributesToObjects(objects: ObjectContent<CoreObjectType>[], params: AttribIdSopParams) {\n\t\tfor (const object of objects) {\n\t\t\tthis._addPrimitiveAttributes(object, params);\n\t\t}\n\t}\n\n\tprivate _addPointAttributesToObject(object: ObjectContent<CoreObjectType>, params: AttribIdSopParams) {\n\t\tconst pointClass = corePointClassFactory(object);\n\t\tpointsFromObject(object, _points);\n\t\tconst entitiesCount = _points.length;\n\n\t\tif (isBooleanTrue(params.id)) {\n\t\t\tconst idValues = new Array(entitiesCount);\n\t\t\tfor (let i = 0; i < entitiesCount; i++) {\n\t\t\t\tidValues[i] = i;\n\t\t\t}\n\t\t\tconst idArray = new Float32Array(idValues);\n\t\t\tconst attrib = new BufferAttribute(idArray, 1);\n\t\t\tpointClass.addAttribute(object, params.idName, attrib);\n\t\t}\n\t\tif (isBooleanTrue(params.idn)) {\n\t\t\tconst idnValues = new Array(entitiesCount);\n\t\t\tconst pointsCountMinus1 = entitiesCount - 1;\n\t\t\tif (pointsCountMinus1 == 0) {\n\t\t\t\tfor (let i = 0; i < entitiesCount; i++) {\n\t\t\t\t\tidnValues[i] = 0;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tfor (let i = 0; i < entitiesCount; i++) {\n\t\t\t\t\tidnValues[i] = i / (entitiesCount - 1);\n\t\t\t\t}\n\t\t\t}\n\t\t\tconst idnArray = new Float32Array(idnValues);\n\t\t\tconst attrib = new BufferAttribute(idnArray, 1);\n\t\t\tpointClass.addAttribute(object, params.idnName, attrib);\n\t\t}\n\t}\n\tprivate _addVertexAttributes(object: ObjectContent<CoreObjectType>, params: AttribIdSopParams) {\n\t\tconst vertexClass = coreVertexClassFactory(object);\n\t\tverticesFromObject(object, _vertices);\n\t\tif (isBooleanTrue(params.id)) {\n\t\t\tconst attribute: VertexNumberAttribute = {\n\t\t\t\tisString: false,\n\t\t\t\tarray: new Array(_vertices.length),\n\t\t\t\titemSize: 1,\n\t\t\t};\n\t\t\tvertexClass.addAttribute(object, params.idName, attribute);\n\t\t}\n\t\tif (isBooleanTrue(params.idn)) {\n\t\t\tconst attribute: VertexNumberAttribute = {\n\t\t\t\tisString: false,\n\t\t\t\tarray: new Array(_vertices.length),\n\t\t\t\titemSize: 1,\n\t\t\t};\n\t\t\tvertexClass.addAttribute(object, params.idnName, attribute);\n\t\t}\n\t\tthis._addAttributesToEntities(_vertices, params);\n\t}\n\tprivate _addPrimitiveAttributes(object: ObjectContent<CoreObjectType>, params: AttribIdSopParams) {\n\t\tconst primitiveClass = corePrimitiveClassFactory(object);\n\t\tprimitivesFromObject(object, _primitives);\n\t\tif (isBooleanTrue(params.id)) {\n\t\t\tconst attribute: PrimitiveNumberAttribute = {\n\t\t\t\tisString: false,\n\t\t\t\tarray: new Array(_primitives.length),\n\t\t\t\titemSize: 1,\n\t\t\t};\n\t\t\tprimitiveClass.addAttribute(object, params.idName, attribute);\n\t\t}\n\t\tif (isBooleanTrue(params.idn)) {\n\t\t\tconst attribute: PrimitiveNumberAttribute = {\n\t\t\t\tisString: false,\n\t\t\t\tarray: new Array(_primitives.length),\n\t\t\t\titemSize: 1,\n\t\t\t};\n\t\t\tprimitiveClass.addAttribute(object, params.idnName, attribute);\n\t\t}\n\t\tthis._addAttributesToEntities(_primitives, params);\n\t}\n\n\tprivate _addAttributesToEntities(entities: CoreEntity[], params: AttribIdSopParams) {\n\t\tconst entitiesCount = entities.length;\n\t\tif (isBooleanTrue(params.id)) {\n\t\t\tlet i = 0;\n\t\t\tfor (const entity of entities) {\n\t\t\t\tentity.setAttribValue(params.idName, i);\n\t\t\t\ti++;\n\t\t\t}\n\t\t}\n\t\tif (isBooleanTrue(params.idn)) {\n\t\t\tconst pointsCountMinus1 = entitiesCount - 1;\n\t\t\tif (pointsCountMinus1 == 0) {\n\t\t\t\tlet i = 0;\n\t\t\t\tfor (const entity of entities) {\n\t\t\t\t\tentity.setAttribValue(params.idnName, 0);\n\t\t\t\t\ti++;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tlet i = 0;\n\t\t\t\tfor (const entity of entities) {\n\t\t\t\t\tentity.setAttribValue(params.idnName, i / (entitiesCount - 1));\n\t\t\t\t\ti++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n","import {BaseSopOperation} from './_Base';\nimport {CoreGroup} from '../../../core/geometry/Group';\nimport {Vector3, BufferAttribute} from 'three';\nimport {InputCloneMode} from '../../../engine/poly/InputCloneMode';\nimport {stringToAttribNames} from '../../../core/String';\nimport {isBooleanTrue} from '../../../core/BooleanValue';\nimport {DefaultOperationParams} from '../../../core/operations/_Base';\ninterface AttribNormalizeSopParams extends DefaultOperationParams {\n\tmode: number;\n\tname: string;\n\tchangeName: boolean;\n\tnewName: string;\n}\n\nexport enum NormalizeMode {\n\tMIN_MAX_TO_01 = 'min/max to 0/1',\n\tVECTOR_TO_LENGTH_1 = 'vectors to length 1',\n}\nexport const NORMALIZE_MODES: NormalizeMode[] = [NormalizeMode.MIN_MAX_TO_01, NormalizeMode.VECTOR_TO_LENGTH_1];\nconst _attribNames:string[]=[]\nexport class AttribNormalizeSopOperation extends BaseSopOperation {\n\tstatic override readonly DEFAULT_PARAMS: AttribNormalizeSopParams = {\n\t\tmode: 0,\n\t\tname: 'position',\n\t\tchangeName: false,\n\t\tnewName: '',\n\t};\n\tstatic override readonly INPUT_CLONED_STATE = InputCloneMode.FROM_NODE;\n\tstatic override type(): Readonly<'attribNormalize'> {\n\t\treturn 'attribNormalize';\n\t}\n\n\toverride cook(input_contents: CoreGroup[], params: AttribNormalizeSopParams) {\n\t\tconst core_group = input_contents[0];\n\t\tconst objects = input_contents[0].threejsObjectsWithGeo();\n\t\tstringToAttribNames(params.name,_attribNames);\n\t\tfor (const object of objects) {\n\t\t\tconst geometry = object.geometry;\n\t\t\tfor (const attribName of _attribNames) {\n\t\t\t\tconst srcAttrib = geometry.getAttribute(attribName) as BufferAttribute;\n\t\t\t\tif (srcAttrib) {\n\t\t\t\t\tlet destAttrib: BufferAttribute | undefined = srcAttrib;\n\t\t\t\t\tif (isBooleanTrue(params.changeName) && params.newName != '') {\n\t\t\t\t\t\tdestAttrib = geometry.getAttribute(params.newName) as BufferAttribute;\n\t\t\t\t\t\tif (destAttrib) {\n\t\t\t\t\t\t\tdestAttrib.needsUpdate = true;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tdestAttrib = destAttrib || srcAttrib.clone();\n\t\t\t\t\t}\n\t\t\t\t\tthis._normalize_attribute(srcAttrib, destAttrib, params);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn core_group;\n\t}\n\tprivate _normalize_attribute(\n\t\tsrc_attrib: BufferAttribute,\n\t\tdest_attrib: BufferAttribute,\n\t\tparams: AttribNormalizeSopParams\n\t) {\n\t\tconst mode = NORMALIZE_MODES[params.mode];\n\t\tswitch (mode) {\n\t\t\tcase NormalizeMode.MIN_MAX_TO_01:\n\t\t\t\treturn this._normalize_from_min_max_to_01(src_attrib, dest_attrib);\n\t\t\tcase NormalizeMode.VECTOR_TO_LENGTH_1:\n\t\t\t\treturn this._normalize_vectors(src_attrib, dest_attrib);\n\t\t}\n\t}\n\n\tprivate min3: Vector3 = new Vector3();\n\tprivate max3: Vector3 = new Vector3();\n\tprivate _normalize_from_min_max_to_01(src_attrib: BufferAttribute, dest_attrib: BufferAttribute) {\n\t\tconst attrib_size = src_attrib.itemSize;\n\t\tconst src_array = src_attrib.array;\n\t\tconst dest_array = dest_attrib.array;\n\t\t// const values = points.map((point) => point.attribValue(params.name));\n\t\tswitch (attrib_size) {\n\t\t\tcase 1: {\n\t\t\t\tconst minf = Math.min(...src_array);\n\t\t\t\tconst maxf = Math.max(...src_array);\n\t\t\t\tfor (let i = 0; i < dest_array.length; i++) {\n\t\t\t\t\tdest_array[i] = (src_array[i] - minf) / (maxf - minf);\n\t\t\t\t}\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tcase 3: {\n\t\t\t\tconst points_count = src_array.length / attrib_size;\n\t\t\t\tconst xs = new Array(points_count);\n\t\t\t\tconst ys = new Array(points_count);\n\t\t\t\tconst zs = new Array(points_count);\n\t\t\t\tlet j = 0;\n\t\t\t\tfor (let i = 0; i < points_count; i++) {\n\t\t\t\t\tj = i * attrib_size;\n\t\t\t\t\txs[i] = src_array[j + 0];\n\t\t\t\t\tys[i] = src_array[j + 1];\n\t\t\t\t\tzs[i] = src_array[j + 2];\n\t\t\t\t}\n\t\t\t\tthis.min3.set(Math.min(...xs), Math.min(...ys), Math.min(...zs));\n\t\t\t\tthis.max3.set(Math.max(...xs), Math.max(...ys), Math.max(...zs));\n\t\t\t\tfor (let i = 0; i < points_count; i++) {\n\t\t\t\t\tj = i * attrib_size;\n\t\t\t\t\tdest_array[j + 0] = (xs[i] - this.min3.x) / (this.max3.x - this.min3.x);\n\t\t\t\t\tdest_array[j + 1] = (ys[i] - this.min3.y) / (this.max3.y - this.min3.y);\n\t\t\t\t\tdest_array[j + 2] = (zs[i] - this.min3.z) / (this.max3.z - this.min3.z);\n\t\t\t\t}\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate _vec: Vector3 = new Vector3();\n\tprivate _normalize_vectors(src_attrib: BufferAttribute, dest_attrib: BufferAttribute) {\n\t\tconst src_array = src_attrib.array;\n\t\tconst dest_array = dest_attrib.array;\n\n\t\tconst elements_count = src_array.length;\n\t\tif (src_attrib.itemSize == 3) {\n\t\t\tfor (let i = 0; i < elements_count; i += 3) {\n\t\t\t\tthis._vec.fromArray(src_array, i);\n\t\t\t\tthis._vec.normalize();\n\t\t\t\tthis._vec.toArray(dest_array, i);\n\t\t\t}\n\t\t}\n\t}\n}\n","import {BaseSopOperation} from './_Base';\nimport {CoreGroup} from '../../../core/geometry/Group';\nimport {InputCloneMode} from '../../../engine/poly/InputCloneMode';\nimport {DefaultOperationParams} from '../../../core/operations/_Base';\nimport {AttribClass, ATTRIBUTE_CLASSES} from '../../../core/geometry/Constant';\nimport {ENTITY_CLASS_FACTORY} from '../../../core/geometry/CoreObjectFactory';\nimport {filterObjectsFromCoreGroup} from '../../../core/geometry/Mask';\n\ninterface AttribRenameSopParams extends DefaultOperationParams {\n\tgroup: string;\n\tclass: number;\n\toldName: string;\n\tnewName: string;\n}\nconst SPLIT_REGEX = /[ ,]+/g;\nexport class AttribRenameSopOperation extends BaseSopOperation {\n\tstatic override readonly DEFAULT_PARAMS: AttribRenameSopParams = {\n\t\tgroup: '',\n\t\tclass: ATTRIBUTE_CLASSES.indexOf(AttribClass.POINT),\n\t\toldName: '',\n\t\tnewName: '',\n\t};\n\tstatic override readonly INPUT_CLONED_STATE = InputCloneMode.FROM_NODE;\n\tstatic override type(): Readonly<'attribRename'> {\n\t\treturn 'attribRename';\n\t}\n\toverride cook(inputCoreGroups: CoreGroup[], params: AttribRenameSopParams) {\n\t\tconst coreGroup = inputCoreGroups[0];\n\t\tconst objects = filterObjectsFromCoreGroup(coreGroup, params);\n\t\tconst attribClass = ATTRIBUTE_CLASSES[params.class];\n\t\tconst factory = ENTITY_CLASS_FACTORY[attribClass];\n\t\tconst newAttribNames = params.newName.split(SPLIT_REGEX);\n\t\tif (factory) {\n\t\t\tfor (const object of objects) {\n\t\t\t\tconst entityClass = factory(object);\n\t\t\t\tconst oldAttribNames = entityClass.attributeNamesMatchingMask(object, params.oldName);\n\t\t\t\tconst minCount = Math.min(oldAttribNames.length, newAttribNames.length);\n\t\t\t\tfor (let i = 0; i < minCount; i++) {\n\t\t\t\t\tentityClass.renameAttribute(object, oldAttribNames[i], newAttribNames[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tconst oldAttribNames = coreGroup.attributeNamesMatchingMask(params.oldName);\n\t\t\tconst minCount = Math.min(oldAttribNames.length, newAttribNames.length);\n\t\t\tfor (let i = 0; i < minCount; i++) {\n\t\t\t\tcoreGroup.renameAttribute(oldAttribNames[i], newAttribNames[i]);\n\t\t\t}\n\t\t}\n\t\treturn coreGroup;\n\t}\n}\n","import {BaseSopOperation} from './_Base';\nimport {CoreGroup} from '../../../core/geometry/Group';\nimport {BufferAttribute, Vector2, Vector3, Vector4} from 'three';\nimport {ATTRIBUTE_CLASSES, AttribClass, AttribType, ATTRIBUTE_TYPES} from '../../../core/geometry/Constant';\nimport {InputCloneMode} from '../../../engine/poly/InputCloneMode';\nimport {TypeAssert} from '../../../engine/poly/Assert';\nimport {BaseCoreObject} from '../../../core/geometry/entities/object/BaseCoreObject';\nimport {CoreAttribute} from '../../../core/geometry/Attribute';\nimport {DefaultOperationParams} from '../../../core/operations/_Base';\nimport {CoreObjectType, ObjectContent} from '../../../core/geometry/ObjectContent';\nimport {corePointClassFactory} from '../../../core/geometry/CoreObjectFactory';\nimport {pointsFromObject} from '../../../core/geometry/entities/point/CorePointUtils';\nimport {CorePoint} from '../../../core/geometry/entities/point/CorePoint';\n\ninterface AttribSetAtIndexSopParams extends DefaultOperationParams {\n\tindex: number;\n\tclass: number;\n\ttype: number;\n\tname: string;\n\tsize: number;\n\tvalue1: number;\n\tvalue2: Vector2;\n\tvalue3: Vector3;\n\tvalue4: Vector4;\n\tstring: string;\n}\nconst _points: CorePoint<CoreObjectType>[] = [];\n\nexport class AttribSetAtIndexSopOperation extends BaseSopOperation {\n\tstatic override readonly DEFAULT_PARAMS: AttribSetAtIndexSopParams = {\n\t\tindex: 0,\n\t\tclass: ATTRIBUTE_CLASSES.indexOf(AttribClass.POINT),\n\t\ttype: ATTRIBUTE_TYPES.indexOf(AttribType.NUMERIC),\n\t\tname: 'new_attrib',\n\t\tsize: 1,\n\t\tvalue1: 0,\n\t\tvalue2: new Vector2(0, 0),\n\t\tvalue3: new Vector3(0, 0, 0),\n\t\tvalue4: new Vector4(0, 0, 0, 0),\n\t\tstring: '',\n\t};\n\tstatic override readonly INPUT_CLONED_STATE = InputCloneMode.FROM_NODE;\n\tstatic override type(): Readonly<'attribSetAtIndex'> {\n\t\treturn 'attribSetAtIndex';\n\t}\n\n\toverride cook(inputCoreGroups: CoreGroup[], params: AttribSetAtIndexSopParams) {\n\t\tconst coreGroup = inputCoreGroups[0];\n\t\tconst attribName = params.name;\n\t\tif (attribName && attribName.trim() != '') {\n\t\t\tthis._addAttribute(ATTRIBUTE_CLASSES[params.class], coreGroup, params);\n\t\t} else {\n\t\t\tthis.states?.error.set('attribute name is not valid');\n\t\t}\n\t\treturn coreGroup;\n\t}\n\tprivate _addAttribute(attribClass: AttribClass, coreGroup: CoreGroup, params: AttribSetAtIndexSopParams) {\n\t\tconst attribType = ATTRIBUTE_TYPES[params.type];\n\t\tswitch (attribClass) {\n\t\t\tcase AttribClass.POINT:\n\t\t\t\tthis._addPointAttribute(attribType, coreGroup, params);\n\t\t\t\treturn;\n\t\t\tcase AttribClass.VERTEX:\n\t\t\t\tthis.states?.error.set('vertex not supported yet');\n\t\t\t\treturn;\n\t\t\tcase AttribClass.PRIMITIVE:\n\t\t\t\tthis.states?.error.set('primitive not supported yet');\n\t\t\t\treturn;\n\t\t\tcase AttribClass.OBJECT:\n\t\t\t\tthis._addObjectAttribute(attribType, coreGroup, params);\n\t\t\t\treturn;\n\t\t\tcase AttribClass.CORE_GROUP:\n\t\t\t\tthis._addCoreGroupAttribute(attribType, coreGroup, params);\n\t\t\t\treturn;\n\t\t}\n\t\tTypeAssert.unreachable(attribClass);\n\t}\n\n\tprivate _addPointAttribute(attribType: AttribType, coreGroup: CoreGroup, params: AttribSetAtIndexSopParams) {\n\t\tconst objects = coreGroup.allObjects();\n\t\tswitch (attribType) {\n\t\t\tcase AttribType.NUMERIC: {\n\t\t\t\tfor (let object of objects) {\n\t\t\t\t\tthis._addNumericAttributeToPoints(object, params);\n\t\t\t\t}\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tcase AttribType.STRING: {\n\t\t\t\tfor (let object of objects) {\n\t\t\t\t\tthis._addStringAttributeToPoints(object, params);\n\t\t\t\t}\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tTypeAssert.unreachable(attribType);\n\t}\n\tprivate _addObjectAttribute(attribType: AttribType, coreGroup: CoreGroup, params: AttribSetAtIndexSopParams) {\n\t\tconst allCoreObjects = coreGroup.allCoreObjects();\n\n\t\t// add attrib if non existent\n\t\tconst attribName = params.name;\n\t\tconst defaultValue = AttribSetAtIndexSopOperation.defaultAttribValue(params);\n\t\tif (defaultValue != null) {\n\t\t\tfor (let coreObject of allCoreObjects) {\n\t\t\t\tif (!coreObject.hasAttribute(attribName)) {\n\t\t\t\t\tcoreObject.setAttribValue(attribName, defaultValue);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tconst coreObject = allCoreObjects[params.index];\n\t\tif (!coreObject) {\n\t\t\treturn;\n\t\t}\n\t\tswitch (attribType) {\n\t\t\tcase AttribType.NUMERIC:\n\t\t\t\tthis._addNumericAttributeToObject(coreObject, params);\n\t\t\t\treturn;\n\t\t\tcase AttribType.STRING:\n\t\t\t\tthis._addStringAttributeToObject(coreObject, params);\n\t\t\t\treturn;\n\t\t}\n\t\tTypeAssert.unreachable(attribType);\n\t}\n\tprivate _addCoreGroupAttribute(attribType: AttribType, coreGroup: CoreGroup, params: AttribSetAtIndexSopParams) {\n\t\tswitch (attribType) {\n\t\t\tcase AttribType.NUMERIC:\n\t\t\t\tthis._addNumericAttributeToCoreGroup(coreGroup, params);\n\t\t\t\treturn;\n\t\t\tcase AttribType.STRING:\n\t\t\t\tthis._addStringAttributeToCoreGroup(coreGroup, params);\n\t\t\t\treturn;\n\t\t}\n\t\tTypeAssert.unreachable(attribType);\n\t}\n\n\tprivate _addNumericAttributeToPoints<T extends CoreObjectType>(\n\t\tobject: ObjectContent<T>,\n\t\tparams: AttribSetAtIndexSopParams\n\t) {\n\t\tconst corePointClass = corePointClassFactory(object);\n\t\tconst attribName = CoreAttribute.remapName(params.name);\n\t\tif (!corePointClass.hasAttribute(object, attribName)) {\n\t\t\tcorePointClass.addNumericAttribute(object, attribName, params.size, 0);\n\t\t}\n\n\t\tconst attrib = corePointClass.attribute(object, attribName) as BufferAttribute;\n\t\tconst array = attrib.array;\n\t\tconst {index, size} = params;\n\t\tswitch (size) {\n\t\t\tcase 1: {\n\t\t\t\tif (index < array.length) {\n\t\t\t\t\tarray[index] = params.value1;\n\t\t\t\t\tattrib.needsUpdate = true;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase 2: {\n\t\t\t\tconst i2 = index * 2;\n\t\t\t\tif (i2 < array.length) {\n\t\t\t\t\tparams.value2.toArray(array, i2);\n\t\t\t\t\tattrib.needsUpdate = true;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase 3: {\n\t\t\t\tconst i3 = index * 3;\n\t\t\t\tif (i3 < array.length) {\n\t\t\t\t\tparams.value3.toArray(array, i3);\n\t\t\t\t\tattrib.needsUpdate = true;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase 4: {\n\t\t\t\tconst i4 = index * 4;\n\t\t\t\tif (i4 < array.length) {\n\t\t\t\t\tparams.value4.toArray(array, i4);\n\t\t\t\t\tattrib.needsUpdate = true;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate _addNumericAttributeToObject(\n\t\tcoreObject: BaseCoreObject<CoreObjectType>,\n\t\tparams: AttribSetAtIndexSopParams\n\t) {\n\t\tconst value = [params.value1, params.value2, params.value3, params.value4][params.size - 1];\n\t\tconst attribName = params.name;\n\t\tcoreObject.setAttribValue(attribName, value);\n\t}\n\tprivate _addNumericAttributeToCoreGroup(coreGroup: CoreGroup, params: AttribSetAtIndexSopParams) {\n\t\tconst value = [params.value1, params.value2, params.value3, params.value4][params.size - 1];\n\t\tconst attribName = params.name;\n\t\tcoreGroup.setAttribValue(attribName, value);\n\t}\n\n\tprivate _addStringAttributeToPoints<T extends CoreObjectType>(\n\t\tobject: ObjectContent<T>,\n\t\tparams: AttribSetAtIndexSopParams\n\t) {\n\t\tconst corePointClass = corePointClassFactory(object);\n\n\t\tconst attribName = params.name;\n\t\t// create attrib if non existent\n\t\tif (!corePointClass.hasAttribute(object, attribName)) {\n\t\t\tconst tmpIndexData = CoreAttribute.arrayToIndexedArrays(['']);\n\t\t\tcorePointClass.setIndexedAttribute(object, attribName, tmpIndexData['values'], tmpIndexData['indices']);\n\t\t}\n\n\t\tconst value = params.string;\n\n\t\tpointsFromObject(object, _points);\n\t\tconst indexPoint = _points[params.index];\n\t\tlet stringValues: string[] = new Array(_points.length);\n\n\t\t// We prefill the existing stringValues\n\t\t// const allPoints = coreObject.points();\n\t\tstringValues = stringValues.length != _points.length ? new Array(_points.length) : stringValues;\n\n\t\tfor (const point of _points) {\n\t\t\tlet currentValue = point.stringAttribValue(attribName);\n\t\t\tif (currentValue == null) {\n\t\t\t\tcurrentValue = '';\n\t\t\t}\n\t\t\tstringValues[point.index()] = currentValue;\n\t\t}\n\n\t\tif (indexPoint) {\n\t\t\tstringValues[indexPoint.index()] = value;\n\t\t}\n\n\t\tconst indexData = CoreAttribute.arrayToIndexedArrays(stringValues);\n\n\t\tcorePointClass.setIndexedAttribute(object, attribName, indexData['values'], indexData['indices']);\n\t}\n\n\tprivate _addStringAttributeToObject(coreObject: BaseCoreObject<CoreObjectType>, params: AttribSetAtIndexSopParams) {\n\t\tconst value = params.string;\n\t\tcoreObject.setAttribValue(params.name, value);\n\t}\n\tprivate _addStringAttributeToCoreGroup(coreGroup: CoreGroup, params: AttribSetAtIndexSopParams) {\n\t\tconst value = params.string;\n\t\tcoreGroup.setAttribValue(params.name, value);\n\t}\n\n\t//\n\t//\n\t// INTERNAL UTILS\n\t//\n\t//\n\tprivate static _attribType(params: AttribSetAtIndexSopParams) {\n\t\treturn ATTRIBUTE_TYPES[params.type];\n\t}\n\n\tstatic defaultAttribValue(params: AttribSetAtIndexSopParams) {\n\t\tconst attribType = this._attribType(params);\n\t\tswitch (attribType) {\n\t\t\tcase AttribType.NUMERIC: {\n\t\t\t\treturn this._defaultNumericValue(params);\n\t\t\t}\n\t\t\tcase AttribType.STRING: {\n\t\t\t\treturn this._defaultStringValue();\n\t\t\t}\n\t\t}\n\t\tTypeAssert.unreachable(attribType);\n\t}\n\tprivate static _defaultStringValue() {\n\t\treturn '';\n\t}\n\tprivate static _defaultNumericValue(params: AttribSetAtIndexSopParams) {\n\t\tconst size = params.size;\n\t\tswitch (size) {\n\t\t\tcase 1:\n\t\t\t\treturn 0;\n\t\t\tcase 2:\n\t\t\t\treturn new Vector2(0, 0);\n\t\t\tcase 3:\n\t\t\t\treturn new Vector3(0, 0, 0);\n\t\t\tcase 4:\n\t\t\t\treturn new Vector4(0, 0, 0, 0);\n\t\t}\n\t}\n}\n","import {BaseSopOperation} from './_Base';\nimport {CoreGroup} from '../../../core/geometry/Group';\nimport {InputCloneMode} from '../../poly/InputCloneMode';\nimport {AttribClass, ATTRIBUTE_CLASSES} from '../../../core/geometry/Constant';\nimport {TypeAssert} from '../../poly/Assert';\nimport {NotesBuilder, NoteHolder} from '../../../core/audio/NotesBuilder';\nimport {CoreAttribute} from '../../../core/geometry/Attribute';\nimport {CoreEntity} from '../../../core/geometry/CoreEntity';\nimport {isBooleanTrue} from '../../../core/Type';\nimport {DefaultOperationParams} from '../../../core/operations/_Base';\nimport {pointsFromObject} from '../../../core/geometry/entities/point/CorePointUtils';\nimport {corePointClassFactory} from '../../../core/geometry/CoreObjectFactory';\nimport {CorePoint} from '../../../core/geometry/entities/point/CorePoint';\nimport {CoreObjectType} from '../../../core/geometry/ObjectContent';\n\nenum OutOfRangeBehavior {\n\tRESTART = 'restart',\n\tBOUNCE = 'bounce',\n}\nexport const OUT_OF_RANGE_BEHAVIOR: OutOfRangeBehavior[] = [OutOfRangeBehavior.RESTART, OutOfRangeBehavior.BOUNCE];\nconst _points: CorePoint<CoreObjectType>[] = [];\n\ninterface AudioNotesSopParams extends DefaultOperationParams {\n\tclass: number;\n\tname: string;\n\ttoctave: boolean;\n\toctaveName: string;\n\tstartOctave: number;\n\tendOctave: number;\n\toutOfRangeBehavior: number;\n}\n\nexport class AudioNotesSopOperation extends BaseSopOperation {\n\tstatic override readonly DEFAULT_PARAMS: AudioNotesSopParams = {\n\t\tclass: ATTRIBUTE_CLASSES.indexOf(AttribClass.OBJECT),\n\t\tname: 'note',\n\t\ttoctave: false,\n\t\toctaveName: 'octave',\n\t\tstartOctave: 2,\n\t\tendOctave: 4,\n\t\toutOfRangeBehavior: OUT_OF_RANGE_BEHAVIOR.indexOf(OutOfRangeBehavior.BOUNCE),\n\t};\n\tstatic override readonly INPUT_CLONED_STATE = InputCloneMode.FROM_NODE;\n\tstatic override type(): Readonly<'AudioNotes'> {\n\t\treturn 'AudioNotes';\n\t}\n\n\toverride cook(inputCoreGroups: CoreGroup[], params: AudioNotesSopParams) {\n\t\tconst inputCoreGroup = inputCoreGroups[0];\n\n\t\tconst attribClass = ATTRIBUTE_CLASSES[params.class];\n\t\tthis._addAttribute(attribClass, inputCoreGroup, params);\n\n\t\treturn inputCoreGroup;\n\t}\n\tprivate async _addAttribute(attribClass: AttribClass, coreGroup: CoreGroup, params: AudioNotesSopParams) {\n\t\tswitch (attribClass) {\n\t\t\tcase AttribClass.POINT:\n\t\t\t\treturn this._addPointAttribute(coreGroup, params);\n\t\t\tcase AttribClass.VERTEX: {\n\t\t\t\tthis.states?.error.set('vertex not supported yet');\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tcase AttribClass.PRIMITIVE: {\n\t\t\t\tthis.states?.error.set('primitive not supported yet');\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tcase AttribClass.OBJECT:\n\t\t\t\treturn this._addObjectAttribute(coreGroup, params);\n\t\t\tcase AttribClass.CORE_GROUP:\n\t\t\t\treturn this._addCoreGroupAttribute(coreGroup, params);\n\t\t}\n\t\tTypeAssert.unreachable(attribClass);\n\t}\n\n\tprivate _addPointAttribute(coreGroup: CoreGroup, params: AudioNotesSopParams) {\n\t\tconst objects = coreGroup.allObjects();\n\n\t\tfor (let object of objects) {\n\t\t\tpointsFromObject(object, _points);\n\t\t\tconst corePointClass = corePointClassFactory(object);\n\t\t\tconst values = this._values(_points, params);\n\n\t\t\t// const coreGeometry = coreObject.coreGeometry();\n\t\t\t// if (coreGeometry) {\n\t\t\tconst notesIndexData = CoreAttribute.arrayToIndexedArrays(values.map((v) => v.note));\n\t\t\tcorePointClass.setIndexedAttribute(object, params.name, notesIndexData.values, notesIndexData.indices);\n\t\t\tif (isBooleanTrue(params.toctave)) {\n\t\t\t\tconst octavesArray = values.map((v) => v.octave);\n\t\t\t\tif (!corePointClass.hasAttribute(object, params.octaveName)) {\n\t\t\t\t\tcorePointClass.addNumericAttribute(object, params.octaveName, 1, 1);\n\t\t\t\t}\n\t\t\t\tlet i = 0;\n\t\t\t\tfor (let corePoint of _points) {\n\t\t\t\t\tcorePoint.setAttribValue(params.octaveName, octavesArray[i]);\n\t\t\t\t\ti++;\n\t\t\t\t}\n\t\t\t}\n\t\t\t// }\n\t\t}\n\t}\n\tprivate _addObjectAttribute(coreGroup: CoreGroup, params: AudioNotesSopParams) {\n\t\tconst coreObjects = coreGroup.allCoreObjects();\n\n\t\tconst values = this._values(coreObjects, params);\n\t\tfor (let i = 0; i < coreObjects.length; i++) {\n\t\t\tconst coreObject = coreObjects[i];\n\t\t\tcoreObject.addAttribute(params.name, values[i].note);\n\t\t\tif (isBooleanTrue(params.toctave)) {\n\t\t\t\tcoreObject.addAttribute(params.octaveName, values[i].octave);\n\t\t\t}\n\t\t}\n\t}\n\tprivate _addCoreGroupAttribute(coreGroup: CoreGroup, params: AudioNotesSopParams) {\n\t\tconst values = this._values([coreGroup], params);\n\t\tcoreGroup.addAttribute(params.name, values[0].note);\n\t\tif (isBooleanTrue(params.toctave)) {\n\t\t\tcoreGroup.addAttribute(params.octaveName, values[0].octave);\n\t\t}\n\t}\n\n\tprivate _values(entities: CoreEntity[], params: AudioNotesSopParams) {\n\t\tlet increment = 1;\n\t\tlet i = 0;\n\t\tconst behavior = OUT_OF_RANGE_BEHAVIOR[params.outOfRangeBehavior];\n\t\tconst noteHolders = NotesBuilder.list(params.startOctave, params.endOctave);\n\t\tconst values: NoteHolder[] = [];\n\t\tfor (let k = 0; k < entities.length; k++) {\n\t\t\tif (i >= noteHolders.length) {\n\t\t\t\tswitch (behavior) {\n\t\t\t\t\tcase OutOfRangeBehavior.BOUNCE: {\n\t\t\t\t\t\tincrement = -1;\n\t\t\t\t\t\ti = noteHolders.length - 2;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tcase OutOfRangeBehavior.RESTART: {\n\t\t\t\t\t\ti = 0;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (behavior == OutOfRangeBehavior.BOUNCE) {\n\t\t\t\tif (i == 0 && increment < 0) {\n\t\t\t\t\tincrement = +1;\n\t\t\t\t\ti = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tconst note = noteHolders[i];\n\t\t\tvalues.push(note);\n\n\t\t\ti += increment;\n\t\t}\n\t\treturn values;\n\t}\n}\n","import {BaseSopOperation} from './_Base';\nimport {CoreGroup} from '../../../core/geometry/Group';\nimport {InputCloneMode} from '../../../engine/poly/InputCloneMode';\nimport {DefaultOperationParams} from '../../../core/operations/_Base';\nimport {BufferAttribute, BufferGeometry, Box3} from 'three';\nimport {ObjectType} from '../../../core/geometry/Constant';\nconst tmpBox = new Box3();\ninterface BboxScatterSopParams extends DefaultOperationParams {\n\tstepSize: number;\n}\n\nexport class BboxScatterSopOperation extends BaseSopOperation {\n\tstatic override readonly DEFAULT_PARAMS: BboxScatterSopParams = {\n\t\tstepSize: 1,\n\t};\n\tstatic override readonly INPUT_CLONED_STATE = InputCloneMode.NEVER;\n\tstatic override type(): Readonly<'bboxScatter'> {\n\t\treturn 'bboxScatter';\n\t}\n\toverride cook(inputCoreGroups: CoreGroup[], params: BboxScatterSopParams) {\n\t\tconst inputCoreGroup = inputCoreGroups[0];\n\t\tconst stepSize = params.stepSize;\n\t\tinputCoreGroup.boundingBox(tmpBox);\n\t\tconst min = tmpBox.min;\n\t\tconst max = tmpBox.max;\n\n\t\tconst positions: number[] = [];\n\t\tfor (let x = min.x; x <= max.x; x += stepSize) {\n\t\t\tfor (let y = min.y; y <= max.y; y += stepSize) {\n\t\t\t\tfor (let z = min.z; z <= max.z; z += stepSize) {\n\t\t\t\t\tpositions.push(x);\n\t\t\t\t\tpositions.push(y);\n\t\t\t\t\tpositions.push(z);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tconst geometry = new BufferGeometry();\n\t\tgeometry.setAttribute('position', new BufferAttribute(new Float32Array(positions), 3));\n\n\t\tconst object = BaseSopOperation.createObject(geometry, ObjectType.POINTS);\n\t\tif (this._node) {\n\t\t\tobject.name = this._node.name();\n\t\t}\n\n\t\treturn this.createCoreGroupFromObjects([object]);\n\t}\n}\n","import {stringToAttribNames} from './../../../core/String';\nimport {BaseSopOperation} from './_Base';\nimport {CoreGroup} from '../../../core/geometry/Group';\nimport {InputCloneMode} from '../../poly/InputCloneMode';\nimport {Mesh, Line3, BufferGeometry, Float32BufferAttribute} from 'three';\nimport {DefaultOperationParams} from '../../../core/operations/_Base';\nimport {\n\tSUBTRACTION,\n\tADDITION,\n\tDIFFERENCE,\n\tINTERSECTION,\n\tBrush,\n\tEvaluator,\n} from '../../../core/thirdParty/three-bvh-csg';\nimport {ObjectType} from '../../../core/geometry/Constant';\nimport {CoreGeometryBuilderMerge} from '../../../core/geometry/modules/three/builders/Merge';\nimport {arrayPushItems} from '../../../core/ArrayUtils';\n\nexport enum BooleanOperation {\n\tINTERSECT = 'intersect',\n\tSUBTRACT = 'subtract',\n\tADD = 'add',\n\tDIFFERENCE = 'difference',\n}\nexport const BOOLEAN_OPERATIONS: BooleanOperation[] = [\n\tBooleanOperation.INTERSECT,\n\tBooleanOperation.SUBTRACT,\n\tBooleanOperation.ADD,\n\tBooleanOperation.DIFFERENCE,\n];\nconst evaluationIdByBooleanOperation: Record<BooleanOperation, number> = {\n\t[BooleanOperation.INTERSECT]: INTERSECTION,\n\t[BooleanOperation.SUBTRACT]: SUBTRACTION,\n\t[BooleanOperation.ADD]: ADDITION,\n\t[BooleanOperation.DIFFERENCE]: DIFFERENCE,\n};\n\ninterface BooleanSopParams extends DefaultOperationParams {\n\toperation: number;\n\t//\n\tkeepVertexColor: boolean;\n\tadditionalAttributes: string;\n\t//\n\tkeepMaterials: boolean;\n\tuseInputGroups: boolean;\n\tintersectionEdgesOnly: boolean;\n}\nconst _attribNames: string[] = [];\nexport class BooleanSopOperation extends BaseSopOperation {\n\tstatic override readonly DEFAULT_PARAMS: BooleanSopParams = {\n\t\toperation: BOOLEAN_OPERATIONS.indexOf(BooleanOperation.INTERSECT),\n\t\tkeepVertexColor: false,\n\t\tadditionalAttributes: '',\n\t\tkeepMaterials: true,\n\t\tuseInputGroups: false,\n\t\tintersectionEdgesOnly: false,\n\t};\n\tstatic override readonly INPUT_CLONED_STATE = [InputCloneMode.FROM_NODE, InputCloneMode.NEVER];\n\tstatic override type(): Readonly<'boolean'> {\n\t\treturn 'boolean';\n\t}\n\n\toverride cook(inputCoreGroups: CoreGroup[], params: BooleanSopParams): CoreGroup {\n\t\tconst meshA = inputCoreGroups[0].threejsObjectsWithGeo()[0] as Mesh | undefined;\n\t\tconst meshB = inputCoreGroups[1].threejsObjectsWithGeo()[0] as Mesh | undefined;\n\t\tif (!(meshA && meshA.geometry && meshB && meshB.geometry)) {\n\t\t\tthis.states?.error.set('input objects need to have mesh geometries at the top level');\n\t\t\treturn this.createCoreGroupFromObjects([]);\n\t\t}\n\n\t\tconst csgEvaluator = new Evaluator();\n\t\tconst brush1 = new Brush(meshA.geometry, params.keepMaterials ? meshA.material : undefined);\n\t\tconst brush2 = new Brush(meshB.geometry, params.keepMaterials ? meshB.material : undefined);\n\n\t\tconst operation = BOOLEAN_OPERATIONS[params.operation];\n\t\tconst operationId = evaluationIdByBooleanOperation[operation];\n\n\t\tconst attributes = ['position', 'normal'];\n\t\tif (params.keepVertexColor) {\n\t\t\tattributes.push('color');\n\t\t}\n\t\tif (params.additionalAttributes.trim() != '') {\n\t\t\tstringToAttribNames(params.additionalAttributes, _attribNames);\n\t\t\tarrayPushItems(_attribNames, attributes);\n\t\t}\n\t\tcsgEvaluator.attributes = attributes;\n\t\tcsgEvaluator.useGroups = params.keepMaterials || params.useInputGroups;\n\t\t// we currently need to use the returned object from .evaluate in order to\n\t\t// have a new object with a correct bounding box\n\t\t(csgEvaluator.debug as any).enabled = params.intersectionEdgesOnly;\n\t\tconst output = csgEvaluator.evaluate(brush1, brush2, operationId);\n\n\t\tif (params.intersectionEdgesOnly) {\n\t\t\tconst lines = csgEvaluator.debug.intersectionEdges as any as Line3[];\n\t\t\tif (lines.length > 0) {\n\t\t\t\tconst linesGeometry = _createLinesObject(lines);\n\t\t\t\tif (linesGeometry) {\n\t\t\t\t\tconst object = BaseSopOperation.createObject(linesGeometry, ObjectType.LINE_SEGMENTS);\n\t\t\t\t\treturn this.createCoreGroupFromObjects([object]);\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\toutput.disposeCacheData();\n\t\t\tBaseSopOperation.createIndexIfNone(output.geometry);\n\t\t\t// brush1.geometry.computeBoundingBox();\n\n\t\t\tif (!params.keepMaterials) {\n\t\t\t\toutput.material = meshA.material;\n\t\t\t}\n\n\t\t\treturn this.createCoreGroupFromObjects([output]);\n\t\t}\n\t\treturn this.createCoreGroupFromObjects([]);\n\t}\n}\n\nfunction _createLinesObject(lines: Line3[]): BufferGeometry | undefined {\n\tconst geometries = lines.map(_createLineGeometry);\n\treturn CoreGeometryBuilderMerge.merge(geometries);\n}\n\nfunction _createLineGeometry(line: Line3): BufferGeometry {\n\tconst pointsCount = 2;\n\n\tconst positions: number[] = new Array(pointsCount * 3);\n\tconst indices: number[] = new Array(pointsCount);\n\n\tconst i = 0;\n\tline.start.toArray(positions, i * 3);\n\tline.end.toArray(positions, (i + 1) * 3);\n\n\tindices[0] = 0;\n\tindices[1] = 1;\n\tconst geometry = new BufferGeometry();\n\tgeometry.setAttribute('position', new Float32BufferAttribute(positions, 3));\n\tgeometry.setIndex(indices);\n\treturn geometry;\n}\n","import {ObjectType} from './../../../core/geometry/Constant';\nimport {BaseSopOperation} from './_Base';\nimport {CoreGroup} from '../../../core/geometry/Group';\nimport {Vector3, BoxGeometry, Box3} from 'three';\nimport {CoreTransform} from '../../../core/Transform';\nimport {InputCloneMode} from '../../../engine/poly/InputCloneMode';\nimport {DefaultOperationParams} from '../../../core/operations/_Base';\nconst tmpBox = new Box3();\nconst tmpSize = new Vector3();\nconst tmpCenter = new Vector3();\ninterface BoxSopParams extends DefaultOperationParams {\n\tsizes: Vector3;\n\tsize: number;\n\tdivisions: Vector3;\n\tcenter: Vector3;\n}\nfunction _roundDivision(division: number) {\n\treturn Math.max(1, Math.floor(division));\n}\n// const _size = new Vector3();\n// const _center = new Vector3();\n\nexport class BoxSopOperation extends BaseSopOperation {\n\tstatic override readonly DEFAULT_PARAMS: BoxSopParams = {\n\t\tsizes: new Vector3(1, 1, 1),\n\t\tsize: 1,\n\t\tdivisions: new Vector3(1, 1, 1),\n\t\tcenter: new Vector3(0, 0, 0),\n\t};\n\tstatic override readonly INPUT_CLONED_STATE = InputCloneMode.NEVER;\n\tstatic override type(): Readonly<'box'> {\n\t\treturn 'box';\n\t}\n\tprivate _coreTransform = new CoreTransform();\n\toverride cook(inputCoreGroups: CoreGroup[], params: BoxSopParams) {\n\t\tconst inputCoreGroup = inputCoreGroups[0];\n\t\tconst geometry = inputCoreGroup ? this._cookWithInput(inputCoreGroup, params) : this._cookWithoutInput(params);\n\n\t\tconst object = BaseSopOperation.createObject(geometry, ObjectType.MESH);\n\t\tif (this._node) {\n\t\t\tobject.name = this._node.name();\n\t\t}\n\n\t\treturn this.createCoreGroupFromObjects([object]);\n\t}\n\tprivate _cookWithoutInput(params: BoxSopParams) {\n\t\tconst {divisions, size, sizes} = params;\n\t\tconst geometry = new BoxGeometry(\n\t\t\tsize * sizes.x,\n\t\t\tsize * sizes.y,\n\t\t\tsize * sizes.z,\n\t\t\t_roundDivision(divisions.x),\n\t\t\t_roundDivision(divisions.y),\n\t\t\t_roundDivision(divisions.z)\n\t\t);\n\t\tgeometry.translate(params.center.x, params.center.y, params.center.z);\n\t\tgeometry.computeVertexNormals();\n\t\treturn geometry;\n\t}\n\n\tprivate _cookWithInput(coreGroup: CoreGroup, params: BoxSopParams) {\n\t\tcoreGroup.boundingBox(tmpBox);\n\t\ttmpBox.getSize(tmpSize);\n\t\ttmpBox.getCenter(tmpCenter);\n\n\t\tconst divisions = params.divisions;\n\t\tconst geometry = new BoxGeometry(\n\t\t\ttmpSize.x,\n\t\t\ttmpSize.y,\n\t\t\ttmpSize.z,\n\t\t\t_roundDivision(divisions.x),\n\t\t\t_roundDivision(divisions.y),\n\t\t\t_roundDivision(divisions.z)\n\t\t);\n\t\tconst matrix = this._coreTransform.translationMatrix(tmpCenter);\n\t\tgeometry.applyMatrix4(matrix);\n\t\treturn geometry;\n\t}\n}\n","import {BaseSopOperation} from './_Base';\nimport {CoreGroup} from '../../../core/geometry/Group';\nimport {Camera, OrthographicCamera, PerspectiveCamera, Vector3} from 'three';\nimport {InputCloneMode} from '../../poly/InputCloneMode';\nimport {isBooleanTrue} from '../../../core/Type';\nimport {DefaultOperationParams} from '../../../core/operations/_Base';\nimport { CorePoint } from '../../../core/geometry/entities/point/CorePoint';\nimport { CoreObjectType } from '../../../core/geometry/ObjectContent';\n\nconst _points:CorePoint<CoreObjectType>[]=[]\ninterface CameraProjectSopParams extends DefaultOperationParams {\n\tproject: boolean;\n}\n\nexport class CameraProjectSopOperation extends BaseSopOperation {\n\tstatic override readonly DEFAULT_PARAMS: CameraProjectSopParams = {\n\t\tproject: true,\n\t};\n\tstatic override readonly INPUT_CLONED_STATE = InputCloneMode.FROM_NODE;\n\tstatic override type(): Readonly<'cameraProject'> {\n\t\treturn 'cameraProject';\n\t}\n\tprivate _pointPosition = new Vector3();\n\toverride cook(inputCoreGroups: CoreGroup[], params: CameraProjectSopParams) {\n\t\tconst inputCoreGroup = inputCoreGroups[0];\n\t\tconst cameraCoreGroup = inputCoreGroups[1];\n\n\t\tlet cameraObject: Camera | undefined;\n\t\tconst cameraCoreGroupObjects = cameraCoreGroup.threejsObjects();\n\t\tfor (let cameraCoreGroupObject of cameraCoreGroupObjects) {\n\t\t\tcameraCoreGroupObject.traverse((childObject) => {\n\t\t\t\tif (!cameraObject) {\n\t\t\t\t\tif ((childObject as Camera).isCamera) {\n\t\t\t\t\t\tcameraObject = childObject as Camera;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t\tif (!cameraObject) {\n\t\t\tthis.states?.error.set(`camera not found.`);\n\t\t\treturn inputCoreGroup;\n\t\t}\n\t\t// update cam\n\t\tcameraObject.updateMatrix();\n\t\tif (\n\t\t\t(cameraObject as PerspectiveCamera).isPerspectiveCamera ||\n\t\t\t(cameraObject as OrthographicCamera).isOrthographicCamera\n\t\t) {\n\t\t\t(cameraObject as PerspectiveCamera).updateProjectionMatrix();\n\t\t}\n\n\t\tinputCoreGroup.points(_points);\n\t\tconst project = isBooleanTrue(params.project);\n\t\tfor (const point of _points) {\n\t\t\tpoint.position(this._pointPosition);\n\t\t\tif (project) {\n\t\t\t\tthis._pointPosition.project(cameraObject);\n\t\t\t} else {\n\t\t\t\tthis._pointPosition.unproject(cameraObject);\n\t\t\t}\n\t\t\tpoint.setPosition(this._pointPosition);\n\t\t}\n\n\t\treturn inputCoreGroup;\n\t}\n}\n","import {BaseSopOperation} from './_Base';\nimport {CoreGroup} from '../../../core/geometry/Group';\nimport {InputCloneMode} from '../../../engine/poly/InputCloneMode';\nimport {DefaultOperationParams} from '../../../core/operations/_Base';\nimport {ThreejsCoreObject} from '../../../core/geometry/modules/three/ThreejsCoreObject';\nimport {CameraAttribute} from '../../../core/camera/CoreCamera';\nimport {CameraSopNodeType} from '../../poly/NodeContext';\nimport {CoreObjectType, ObjectContent} from '../../../core/geometry/ObjectContent';\nimport {CoreMask} from '../../../core/geometry/Mask';\nimport {Vector2} from 'three';\n\ninterface CameraViewOffsetSopParams extends DefaultOperationParams {\n\tgroup: string;\n\tmin: Vector2;\n\tmax: Vector2;\n}\ninterface UpdateObjectOptions {\n\tobjects: ObjectContent<CoreObjectType>[];\n\tparams: CameraViewOffsetSopParams;\n}\n\nexport class CameraViewOffsetSopOperation extends BaseSopOperation {\n\tstatic override readonly DEFAULT_PARAMS: CameraViewOffsetSopParams = {\n\t\tgroup: '',\n\t\tmin: new Vector2(0, 0),\n\t\tmax: new Vector2(1, 1),\n\t};\n\tstatic override readonly INPUT_CLONED_STATE = InputCloneMode.FROM_NODE;\n\tstatic override type(): Readonly<CameraSopNodeType.VIEW_OFFSET> {\n\t\treturn CameraSopNodeType.VIEW_OFFSET;\n\t}\n\toverride cook(inputCoreGroups: CoreGroup[], params: CameraViewOffsetSopParams) {\n\t\tconst coreGroup = inputCoreGroups[0];\n\t\tconst objects = CoreMask.filterObjects(coreGroup, {\n\t\t\tgroup: params.group,\n\t\t});\n\n\t\tif (this._node) {\n\t\t\tCameraViewOffsetSopOperation.updateObject({objects, params});\n\t\t}\n\n\t\treturn coreGroup;\n\t}\n\tstatic updateObject(options: UpdateObjectOptions) {\n\t\tconst {objects, params} = options;\n\n\t\tfor (let object of objects) {\n\t\t\tThreejsCoreObject.addAttribute(object, CameraAttribute.VIEW_OFFSET_MIN, params.min);\n\t\t\tThreejsCoreObject.addAttribute(object, CameraAttribute.VIEW_OFFSET_MAX, params.max);\n\t\t}\n\t}\n}\n","import {BaseSopOperation} from './_Base';\nimport {CoreGroup, Object3DWithGeometry} from '../../../core/geometry/Group';\nimport {Vector3, BufferAttribute, BufferGeometry} from 'three';\nimport {ObjectType} from '../../../core/geometry/Constant';\nimport {InputCloneMode} from '../../../engine/poly/InputCloneMode';\nimport {DefaultOperationParams} from '../../../core/operations/_Base';\nimport {Attribute} from '../../../core/geometry/Attribute';\nimport {TypeAssert} from '../../poly/Assert';\n\nconst _geoCenter: Vector3 = new Vector3();\n\nexport enum CenterMode {\n\tOBJECT_ORIGIN = 'object origin',\n\tGEOMETRY_CENTER = 'geometry center',\n}\nexport const CENTER_MODES: CenterMode[] = [CenterMode.OBJECT_ORIGIN, CenterMode.GEOMETRY_CENTER];\n\ninterface CenterSopParams extends DefaultOperationParams {\n\tmode: number;\n}\n\nexport class CenterSopOperation extends BaseSopOperation {\n\tstatic override readonly DEFAULT_PARAMS: CenterSopParams = {\n\t\tmode: CENTER_MODES.indexOf(CenterMode.OBJECT_ORIGIN),\n\t};\n\tstatic override readonly INPUT_CLONED_STATE = InputCloneMode.FROM_NODE;\n\tstatic override type(): Readonly<'center'> {\n\t\treturn 'center';\n\t}\n\n\toverride cook(inputCoreGroups: CoreGroup[], params: CenterSopParams) {\n\t\tconst coreGroup = inputCoreGroups[0];\n\t\tconst srcObjects = coreGroup.threejsObjectsWithGeo();\n\t\tconst mode = CENTER_MODES[params.mode];\n\n\t\tconst positions: number[] = new Array(srcObjects.length * 3);\n\t\tpositions.fill(0);\n\t\tfor (let i = 0; i < srcObjects.length; i++) {\n\t\t\tconst srcObject = srcObjects[i];\n\n\t\t\tthis._applyCenter(mode, srcObject, positions, i);\n\t\t}\n\t\tconst geometry = new BufferGeometry();\n\t\tgeometry.setAttribute(Attribute.POSITION, new BufferAttribute(new Float32Array(positions), 3));\n\t\tconst object = this.createObject(geometry, ObjectType.POINTS);\n\t\tif (this._node) {\n\t\t\tobject.name = this._node.name();\n\t\t}\n\t\treturn this.createCoreGroupFromObjects([object]);\n\t}\n\tprivate _applyCenter(mode: CenterMode, object: Object3DWithGeometry, positions: number[], i: number) {\n\t\tobject.updateMatrixWorld();\n\t\tswitch (mode) {\n\t\t\tcase CenterMode.OBJECT_ORIGIN: {\n\t\t\t\tobject.getWorldPosition(_geoCenter);\n\t\t\t\t_geoCenter.toArray(positions, i * 3);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tcase CenterMode.GEOMETRY_CENTER: {\n\t\t\t\tconst srcGeometry = object.geometry;\n\t\t\t\tsrcGeometry.computeBoundingBox();\n\t\t\t\tif (srcGeometry.boundingBox) {\n\t\t\t\t\tsrcGeometry.boundingBox?.getCenter(_geoCenter);\n\n\t\t\t\t\t_geoCenter.applyMatrix4(object.matrixWorld);\n\t\t\t\t\t_geoCenter.toArray(positions, i * 3);\n\t\t\t\t}\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tTypeAssert.unreachable(mode);\n\t}\n}\n","import {BaseSopOperation} from './_Base';\nimport {CoreGroup} from '../../../core/geometry/Group';\nimport {MathUtils, Object3D, PerspectiveCamera, Vector3, CubeCamera, WebGLCubeRenderTarget} from 'three';\nimport {InputCloneMode} from '../../../engine/poly/InputCloneMode';\nimport {DefaultOperationParams} from '../../../core/operations/_Base';\nimport {CameraNodeType} from '../../poly/NodeContext';\nimport {CameraAttribute, CORE_CAMERA_DEFAULT} from '../../../core/camera/CoreCamera';\nimport {CUBE_CAMERA_DEFAULT, registerCubeCamera} from '../../../core/camera/CoreCubeCamera';\nimport {isBooleanTrue} from '../../../core/Type';\nimport {CameraHelper} from '../../../core/helpers/CameraHelper';\nimport {ThreejsCoreObject} from '../../../core/geometry/modules/three/ThreejsCoreObject';\nimport type {BaseNodeType} from '../../nodes/_Base';\nimport {DefaultObjectContentConstructor, ObjectType, registerObjectType} from '../../../core/geometry/Constant';\ninterface CreateCubeCameraParams {\n\tnear: number;\n\tfar: number;\n\tresolution: number;\n}\ninterface UpdateCubeCameraParams {\n\tshowHelper: boolean;\n\tmatrixAutoUpdate: boolean;\n\tname: string;\n}\ninterface CubeCameraSopParams extends CreateCubeCameraParams, UpdateCubeCameraParams, DefaultOperationParams {\n\tposition: Vector3;\n\trotation: Vector3;\n}\ninterface AttributeOptions {}\n\nexport class CubeCameraExtended extends CubeCamera {\n\toverride copy(source: CubeCamera, recursive: boolean) {\n\t\tconst clonedCubeCamera = super.copy(source as this, recursive);\n\t\t// remove current children\n\t\tlet child: Object3D | undefined;\n\t\twhile ((child = clonedCubeCamera.children[0])) {\n\t\t\tclonedCubeCamera.remove(child);\n\t\t}\n\n\t\t// then re-add the source ones only (and not the ones created in the constructor)\n\t\tfor (let srcChild of source.children) {\n\t\t\tclonedCubeCamera.add(srcChild.clone());\n\t\t}\n\n\t\t// copy the renderTarget\n\t\tclonedCubeCamera.renderTarget = source.renderTarget;\n\n\t\treturn clonedCubeCamera;\n\t}\n}\n\nexport class CubeCameraSopOperation extends BaseSopOperation {\n\tstatic override readonly DEFAULT_PARAMS: CubeCameraSopParams = {\n\t\tnear: CORE_CAMERA_DEFAULT.near,\n\t\tfar: CORE_CAMERA_DEFAULT.far,\n\t\tresolution: CUBE_CAMERA_DEFAULT.resolution,\n\t\tposition: new Vector3(0, 0, 0),\n\t\trotation: new Vector3(0, 0, 0),\n\t\tshowHelper: false,\n\t\tmatrixAutoUpdate: true,\n\t\tname: CameraNodeType.CUBE,\n\t};\n\tstatic override readonly INPUT_CLONED_STATE = InputCloneMode.NEVER;\n\tstatic override type(): Readonly<CameraNodeType.CUBE> {\n\t\treturn CameraNodeType.CUBE;\n\t}\n\tstatic override onRegister = registerCubeCamera;\n\toverride cook(inputCoreGroups: CoreGroup[], params: CubeCameraSopParams) {\n\t\tconst camera = CubeCameraSopOperation.createCamera(params, this._node);\n\t\tcamera.name = params.name || CameraNodeType.CUBE;\n\n\t\tcamera.position.copy(params.position);\n\t\tcamera.rotation.set(\n\t\t\tMathUtils.degToRad(params.rotation.x),\n\t\t\tMathUtils.degToRad(params.rotation.y),\n\t\t\tMathUtils.degToRad(params.rotation.z)\n\t\t);\n\n\t\tCubeCameraSopOperation.updateCamera(camera, params);\n\n\t\tconst objects: Object3D[] = [camera];\n\t\treturn this.createCoreGroupFromObjects(objects);\n\t}\n\tstatic updateCamera(camera: CubeCamera, params: UpdateCubeCameraParams) {\n\t\t// this needs to be .updateWorldMatrix and not .updateMatrix\n\t\t// as otherwise the camera appears to behave find in most cases,\n\t\t// except when using the sop/cameraRenderScene\n\t\tcamera.updateWorldMatrix(false, true);\n\t\tconst childCameras = camera.children.filter(\n\t\t\t(c) => (c as PerspectiveCamera).isPerspectiveCamera\n\t\t) as PerspectiveCamera[];\n\t\tlet i = 0;\n\t\tfor (const childCamera of childCameras) {\n\t\t\tchildCamera.name = `${camera.name}-perspectiveCamera-${i}`;\n\t\t\tchildCamera.updateProjectionMatrix();\n\t\t\ti++;\n\t\t}\n\t\tcamera.matrixAutoUpdate = params.matrixAutoUpdate;\n\n\t\tCubeCameraSopOperation.setCameraAttributes(camera, params);\n\n\t\tif (isBooleanTrue(params.showHelper)) {\n\t\t\tthis._addHelper(childCameras);\n\t\t} else {\n\t\t\tthis._removeHelper(childCameras);\n\t\t}\n\t}\n\tprivate static _addHelper(childCameras: PerspectiveCamera[]) {\n\t\tfor (const childCamera of childCameras) {\n\t\t\tconst helper = new CameraHelper(childCamera);\n\t\t\thelper.update();\n\t\t\tchildCamera.add(helper);\n\t\t}\n\t}\n\tprivate static _removeHelper(childCameras: PerspectiveCamera[]) {\n\t\tfor (const childCamera of childCameras) {\n\t\t\tconst helpers = childCamera.children.filter((c) => c instanceof CameraHelper);\n\t\t\tfor (const helper of helpers) {\n\t\t\t\tchildCamera.remove(helper);\n\t\t\t}\n\t\t}\n\t}\n\n\tstatic createCamera(params: CreateCubeCameraParams, nodeGenerator?: BaseNodeType) {\n\t\tconst cubeRenderTarget = new WebGLCubeRenderTarget(params.resolution);\n\t\tregisterObjectType({\n\t\t\ttype: ObjectType.CUBE_CAMERA,\n\t\t\tcheckFunc: (o) => {\n\t\t\t\tif ((o as CubeCamera).renderTarget) {\n\t\t\t\t\treturn ObjectType.CUBE_CAMERA;\n\t\t\t\t}\n\t\t\t},\n\t\t\tctor: CubeCameraExtended as any as DefaultObjectContentConstructor,\n\t\t\thumanName: ObjectType.CUBE_CAMERA,\n\t\t});\n\t\tconst camera = new CubeCameraExtended(params.near, params.far, cubeRenderTarget);\n\t\tif (nodeGenerator) {\n\t\t\tThreejsCoreObject.addAttribute(camera, CameraAttribute.NODE_ID, nodeGenerator.graphNodeId());\n\t\t}\n\t\treturn camera;\n\t}\n\tstatic setCameraAttributes(camera: CubeCamera, options: AttributeOptions) {}\n}\n","import {BaseSopOperation} from './_Base';\nimport {CoreGroup} from '../../../core/geometry/Group';\nimport {InputCloneMode} from '../../../engine/poly/InputCloneMode';\nimport {DefaultOperationParams} from '../../../core/operations/_Base';\nimport {isInGroup} from '../../../core/geometry/Mask';\nimport {SopType} from '../../poly/registers/nodes/types/Sop';\nimport {ObjectContent, CoreObjectType} from '../../../core/geometry/ObjectContent';\n\ninterface DeleteByNameSopParams extends DefaultOperationParams {\n\tgroup: string;\n\tinvert: boolean;\n}\n\nexport class DeleteByNameSopOperation extends BaseSopOperation {\n\tstatic override readonly DEFAULT_PARAMS: DeleteByNameSopParams = {\n\t\tgroup: '',\n\t\tinvert: false,\n\t};\n\tstatic override readonly INPUT_CLONED_STATE = InputCloneMode.FROM_NODE;\n\tstatic override type(): Readonly<SopType.DELETE_BY_NAME> {\n\t\treturn SopType.DELETE_BY_NAME;\n\t}\n\n\toverride cook(inputCoreGroups: CoreGroup[], params: DeleteByNameSopParams) {\n\t\tconst coreGroup = inputCoreGroups[0];\n\n\t\tconst coreObjects = coreGroup.allCoreObjects();\n\t\tconst newObjects: ObjectContent<CoreObjectType>[] = [];\n\t\tconst masks = params.group.split(' ');\n\t\tfor (const coreObject of coreObjects) {\n\t\t\tlet _toDelete = false;\n\t\t\tfor (const mask of masks) {\n\t\t\t\tconst _inGroup = isInGroup(mask, coreObject);\n\t\t\t\tif ((_inGroup && !params.invert) || (!_inGroup && params.invert)) {\n\t\t\t\t\t_toDelete = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\t// if (params.invert) {\n\t\t\t// \t_inAnyGroup = !_inAnyGroup;\n\t\t\t// }\n\t\t\tif (!_toDelete) {\n\t\t\t\tconst object = coreObject.object();\n\t\t\t\tif (object) {\n\t\t\t\t\tnewObjects.push(object);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn this.createCoreGroupFromObjects(newObjects);\n\t}\n}\n","import {BaseSopOperation} from './_Base';\nimport {CoreGroup} from '../../../core/geometry/Group';\nimport {Group, LineSegments, Mesh, Object3D, Points} from 'three';\nimport {DefaultOperationParams} from '../../../core/operations/_Base';\nimport {ObjectType, DEFAULT_MATERIALS} from '../../../core/geometry/Constant';\n\ninterface EmptyObjectSopParams extends DefaultOperationParams {\n\ttype: ObjectType;\n}\n\nexport class EmptyObjectSopOperation extends BaseSopOperation {\n\tstatic override type(): Readonly<'emptyObject'> {\n\t\treturn 'emptyObject';\n\t}\n\toverride cook(inputCoreGroups: CoreGroup[], params: EmptyObjectSopParams) {\n\t\tconst object = this._createObjectFromType(params);\n\t\tconst objects: Object3D[] = [];\n\t\tif (object) {\n\t\t\tconst material = DEFAULT_MATERIALS[params.type];\n\t\t\tif (material) {\n\t\t\t\t(object as Mesh).material = material; //.clone();\n\t\t\t}\n\t\t\tBaseSopOperation.applyObjectDefault(object);\n\t\t\tobjects.push(object);\n\t\t}\n\t\treturn this.createCoreGroupFromObjects(objects);\n\t}\n\tprivate _createObjectFromType(params: EmptyObjectSopParams) {\n\t\tswitch (params.type) {\n\t\t\tcase ObjectType.GROUP: {\n\t\t\t\treturn new Group();\n\t\t\t}\n\t\t\tcase ObjectType.LINE_SEGMENTS: {\n\t\t\t\treturn new LineSegments();\n\t\t\t}\n\t\t\tcase ObjectType.MESH: {\n\t\t\t\treturn new Mesh();\n\t\t\t}\n\t\t\tcase ObjectType.OBJECT3D: {\n\t\t\t\treturn new Object3D();\n\t\t\t}\n\t\t\tcase ObjectType.POINTS: {\n\t\t\t\treturn new Points();\n\t\t\t}\n\t\t}\n\t}\n}\n","import {Mesh} from 'three';\nimport {VOXLoader, Chunk, VOXMesh} from 'three/examples/jsm/loaders/VOXLoader';\nimport {BaseObject3DLoaderHandler, BaseGeoLoader} from './_BaseLoaderHandler';\n\nexport class VOXLoaderHandler extends BaseObject3DLoaderHandler<Chunk[]> {\n\tprotected async _getLoader(): Promise<BaseGeoLoader<Chunk[]>> {\n\t\treturn (this._loader = this._loader || new VOXLoader(this.loadingManager));\n\t}\n\tprotected override _onLoadSuccess(chunks: Chunk[]): Mesh[] {\n\t\tconst meshes: Mesh[] = [];\n\t\tfor (const chunk of chunks) {\n\t\t\tconst voxMesh = new VOXMesh(chunk);\n\t\t\t// create a standard mesh, to avoid the VOXMesh.clone method\n\t\t\t// as VOXMesh takes chunks in the constructor\n\t\t\tconst mesh = new Mesh(voxMesh.geometry, voxMesh.material);\n\t\t\tmeshes.push(mesh);\n\t\t}\n\t\treturn meshes;\n\t}\n}\n","import type {Chunk} from 'three/examples/jsm/loaders/VOXLoader';\nimport {ASSETS_ROOT} from '../../../core/loader/AssetsUtils';\nimport {VOXLoaderHandler} from '../../../core/loader/geometry/VOX';\nimport {sanitizeUrl} from '../../../core/UrlHelper';\nimport {SopTypeFile} from '../../poly/registers/nodes/types/Sop';\nimport {BaseFileSopOperation, BaseFileSopParams} from './utils/File/_BaseFileOperation';\n\nexport class FileVOXSopOperation extends BaseFileSopOperation<Chunk[]> {\n\tstatic override readonly DEFAULT_PARAMS: BaseFileSopParams = {\n\t\turl: sanitizeUrl(`${ASSETS_ROOT}/models/vox/monu10.vox`),\n\t\tmatrixAutoUpdate: false,\n\t};\n\tstatic override type(): Readonly<SopTypeFile.FILE_VOX> {\n\t\treturn SopTypeFile.FILE_VOX;\n\t}\n\n\tprotected _createGeoLoaderHandler(params: BaseFileSopParams) {\n\t\treturn new VOXLoaderHandler(params.url, this._node);\n\t}\n}\n","import {BaseSopOperation} from './_Base';\nimport {CoreGroup} from '../../../core/geometry/Group';\nimport {InputCloneMode} from '../../../engine/poly/InputCloneMode';\nimport {HemisphereLight} from 'three';\nimport {HemisphereLightParams, DEFAULT_HEMISPHERE_LIGHT_PARAMS} from '../../../core/lights/HemisphereLight';\nimport {ObjectType, registerObjectType} from '../../../core/geometry/Constant';\nexport class HemisphereLightSopOperation extends BaseSopOperation {\n\tstatic override readonly DEFAULT_PARAMS: HemisphereLightParams = DEFAULT_HEMISPHERE_LIGHT_PARAMS;\n\tstatic override readonly INPUT_CLONED_STATE = InputCloneMode.NEVER;\n\tstatic override type(): Readonly<'hemisphereLight'> {\n\t\treturn 'hemisphereLight';\n\t}\n\toverride cook(inputCoreGroups: CoreGroup[], params: HemisphereLightParams) {\n\t\tconst light = this.createLight();\n\t\tlight.name = params.name;\n\n\t\tthis.updateLightParams(light, params);\n\t\treturn this.createCoreGroupFromObjects([light]);\n\t}\n\n\tcreateLight() {\n\t\tregisterObjectType({\n\t\t\ttype: ObjectType.HEMISPHERE_LIGHT,\n\t\t\tcheckFunc: (o) => {\n\t\t\t\tif ((o as HemisphereLight).isHemisphereLight) {\n\t\t\t\t\treturn ObjectType.HEMISPHERE_LIGHT;\n\t\t\t\t}\n\t\t\t},\n\t\t\tctor: HemisphereLight,\n\t\t\thumanName: 'HemisphereLight',\n\t\t});\n\t\tconst light = new HemisphereLight();\n\t\tlight.name = `HemisphereLight_${this._node?.name() || ''}`;\n\t\tlight.matrixAutoUpdate = false;\n\t\tlight.updateMatrix();\n\t\t// make sure the light is initialized with same defaults as the node parameters\n\t\tlight.color.copy(DEFAULT_HEMISPHERE_LIGHT_PARAMS.skyColor);\n\t\tlight.groundColor.copy(DEFAULT_HEMISPHERE_LIGHT_PARAMS.groundColor);\n\t\treturn light;\n\t}\n\tupdateLightParams(light: HemisphereLight, params: HemisphereLightParams) {\n\t\tlight.color.copy(params.skyColor);\n\t\tlight.groundColor.copy(params.groundColor);\n\t\tlight.intensity = params.intensity;\n\t\tlight.position.copy(params.position);\n\t\tlight.updateMatrix();\n\t}\n}\n","import {CoreGeometryOperationHexagon} from './../../../core/geometry/operation/Hexagon';\nimport {BaseSopOperation} from './_Base';\nimport {BufferGeometry, Vector2, Vector3, Quaternion, BoxGeometry, Box3} from 'three';\nimport {rotateGeometry} from '../../../core/Transform';\nimport {CoreGroup} from '../../../core/geometry/Group';\nimport {InputCloneMode} from '../../poly/InputCloneMode';\nimport {isBooleanTrue} from '../../../core/BooleanValue';\nimport {DefaultOperationParams} from '../../../core/operations/_Base';\nimport {ObjectType} from '../../../core/geometry/Constant';\nconst tmpBox = new Box3();\nconst tmpBoxPreRotation = new Box3();\nconst tmpSize = new Vector3();\nconst tmpCenter = new Vector3();\n\ninterface HexagonsSopParams extends DefaultOperationParams {\n\tsize: Vector2;\n\thexagonRadius: number;\n\tdirection: Vector3;\n\tpointsOnly: boolean;\n}\nconst DEFAULT_UP = new Vector3(0, 0, 1);\n// const ROTATE_END = new Vector3(0, 1, 0);\nconst q = new Quaternion();\n// const size = new Vector3();\n// const center = new Vector3();\n// const inputObjectCenter = new Vector3();\nexport class HexagonsSopOperation extends BaseSopOperation {\n\tstatic override readonly DEFAULT_PARAMS: HexagonsSopParams = {\n\t\tsize: new Vector2(1, 1),\n\t\thexagonRadius: 0.1,\n\t\tdirection: new Vector3(0, 1, 0),\n\t\tpointsOnly: false,\n\t};\n\tstatic override readonly INPUT_CLONED_STATE = InputCloneMode.NEVER;\n\tstatic override type(): Readonly<'hexagons'> {\n\t\treturn 'hexagons';\n\t}\n\n\toverride cook(inputCoreGroups: CoreGroup[], params: HexagonsSopParams) {\n\t\tconst coreGroup = inputCoreGroups[0];\n\t\tif (coreGroup) {\n\t\t\treturn this._cookWithInput(coreGroup, params);\n\t\t} else {\n\t\t\treturn this._cookWithoutInput(params);\n\t\t}\n\t}\n\tprivate _cookWithoutInput(params: HexagonsSopParams) {\n\t\tif (params.hexagonRadius > 0) {\n\t\t\tconst geometry = this._createHexagons(params.size, params);\n\n\t\t\trotateGeometry(geometry, DEFAULT_UP, params.direction);\n\n\t\t\treturn this.createCoreGroupFromObjects([this._createHexagonsObjects(geometry, params)]);\n\t\t} else {\n\t\t\treturn this.createCoreGroupFromObjects([]);\n\t\t}\n\t}\n\n\tprivate _cookWithInput(coreGroup: CoreGroup, params: HexagonsSopParams) {\n\t\tcoreGroup.boundingBox(tmpBoxPreRotation);\n\t\ttmpBoxPreRotation.getCenter(tmpCenter);\n\n\t\t// create box\n\t\tcoreGroup.boundingBox(tmpBox);\n\t\ttmpBox.getSize(tmpSize);\n\t\ttmpBox.getCenter(tmpCenter);\n\t\tconst boxGeometry = new BoxGeometry(tmpSize.x, tmpSize.y, tmpSize.z, 1, 1, 1);\n\n\t\t// rotate box\n\t\tfunction _applyInputQuaternion(_q: Quaternion) {\n\t\t\tboxGeometry.applyQuaternion(_q);\n\t\t\tboxGeometry.computeBoundingBox();\n\t\t}\n\t\tfunction _setInputRotation() {\n\t\t\tq.setFromUnitVectors(DEFAULT_UP, params.direction);\n\t\t\t_applyInputQuaternion(q);\n\t\t}\n\t\t// function _resetInputRotation() {\n\t\t// \tq.invert();\n\t\t// \t_applyInputQuaternion(q);\n\t\t// }\n\t\t_setInputRotation();\n\t\tconst bboxPostRotation = boxGeometry.boundingBox!; //coreGroup.boundingBox(true);\n\t\tbboxPostRotation.getSize(tmpSize);\n\t\t// bboxPreRotation.getCenter(center); // debug\n\t\t// _resetInputRotation();\n\n\t\tconst size2d = new Vector2(tmpSize.x, tmpSize.y);\n\t\tconst geometry = this._createHexagons(size2d, params);\n\n\t\trotateGeometry(geometry, DEFAULT_UP, params.direction);\n\t\tgeometry.translate(tmpCenter.x, tmpCenter.y, tmpCenter.z);\n\n\t\tconst object = this._createHexagonsObjects(geometry, params);\n\t\treturn this.createCoreGroupFromObjects([object]);\n\t}\n\n\tprivate _createHexagonsObjects(geometry: BufferGeometry, params: HexagonsSopParams) {\n\t\tif (isBooleanTrue(params.pointsOnly)) {\n\t\t\treturn this.createObject(geometry, ObjectType.POINTS);\n\t\t} else {\n\t\t\treturn this.createObject(geometry, ObjectType.MESH);\n\t\t}\n\t}\n\n\tprivate _createHexagons(size: Vector2, params: HexagonsSopParams) {\n\t\tconst operation = new CoreGeometryOperationHexagon(size, params.hexagonRadius, params.pointsOnly);\n\t\tconst geometry = operation.process();\n\t\treturn geometry;\n\t}\n}\n","import {BaseSopOperation} from './_Base';\nimport {CoreGroup} from '../../../core/geometry/Group';\nimport {Object3D} from 'three';\nimport {Group} from 'three';\nimport {InputCloneMode} from '../../../engine/poly/InputCloneMode';\nimport {TypeAssert} from '../../../engine/poly/Assert';\nimport {DefaultOperationParams} from '../../../core/operations/_Base';\nimport {NodeContext} from '../../poly/NodeContext';\nimport {NodeStatesController} from '../../nodes/utils/StatesController';\nimport {CorePath} from '../../../core/geometry/CorePath';\n\ninterface HierarchySopParams extends DefaultOperationParams {\n\tmode: number;\n\tlevels: number;\n\tobjectMask: string;\n\taddChildMode: number;\n}\n\nexport enum HierarchyMode {\n\tADD_PARENT = 'add parent',\n\tREMOVE_PARENT = 'remove parent',\n\tADD_CHILD = 'add child',\n}\nexport const HIERARCHY_MODES: Array<HierarchyMode> = [\n\tHierarchyMode.ADD_PARENT,\n\tHierarchyMode.REMOVE_PARENT,\n\tHierarchyMode.ADD_CHILD,\n];\nexport enum AddChildMode {\n\tONE_CHILD_PER_PARENT = 'one child per parent',\n\tALL_CHILDREN_UNDER_FIRST_PARENT = 'all children under first parent',\n\tALL_CHILDREN_UNDER_ALL_PARENTS = 'all children under all parents',\n}\nexport const ADD_CHILD_MODES: Array<AddChildMode> = [\n\tAddChildMode.ONE_CHILD_PER_PARENT,\n\tAddChildMode.ALL_CHILDREN_UNDER_FIRST_PARENT,\n\tAddChildMode.ALL_CHILDREN_UNDER_ALL_PARENTS,\n];\n\nexport class HierarchySopOperation extends BaseSopOperation {\n\tstatic override readonly DEFAULT_PARAMS: HierarchySopParams = {\n\t\tmode: HIERARCHY_MODES.indexOf(HierarchyMode.ADD_PARENT),\n\t\tlevels: 1,\n\t\tobjectMask: '',\n\t\taddChildMode: ADD_CHILD_MODES.indexOf(AddChildMode.ALL_CHILDREN_UNDER_FIRST_PARENT),\n\t};\n\tstatic override readonly INPUT_CLONED_STATE = InputCloneMode.FROM_NODE;\n\tstatic override type(): Readonly<'hierarchy'> {\n\t\treturn 'hierarchy';\n\t}\n\n\toverride cook(inputCoreGroups: CoreGroup[], params: HierarchySopParams) {\n\t\tconst coreGroup = inputCoreGroups[0];\n\t\tconst mode = HIERARCHY_MODES[params.mode];\n\t\tswitch (mode) {\n\t\t\tcase HierarchyMode.ADD_PARENT: {\n\t\t\t\tconst objects = addParentToCoreGroup(coreGroup, inputCoreGroups[1], params);\n\t\t\t\treturn this.createCoreGroupFromObjects(objects);\n\t\t\t}\n\t\t\tcase HierarchyMode.REMOVE_PARENT: {\n\t\t\t\tconst objects = _removeParentFromCoreGroup(coreGroup, params);\n\t\t\t\treturn this.createCoreGroupFromObjects(objects);\n\t\t\t}\n\t\t\tcase HierarchyMode.ADD_CHILD: {\n\t\t\t\tconst objects = _addChildrenToCoreGroup(coreGroup, inputCoreGroups[1], params, this, this.states);\n\t\t\t\treturn this.createCoreGroupFromObjects(objects);\n\t\t\t}\n\t\t}\n\t\tTypeAssert.unreachable(mode);\n\t}\n}\n\nfunction addParentToCoreGroup(\n\tcoreGroup: CoreGroup,\n\tparentCoreGroup: CoreGroup | undefined,\n\tparams: HierarchySopParams\n): Object3D[] {\n\tfunction _addParentToObject(objects: Object3D[]): Object3D {\n\t\tfunction _createNewParent() {\n\t\t\tconst newParent2 = new Group();\n\t\t\tnewParent2.matrixAutoUpdate = false;\n\t\t\treturn newParent2;\n\t\t}\n\n\t\tlet newParent: Object3D | undefined;\n\t\tif (parentCoreGroup) {\n\t\t\tnewParent = parentCoreGroup?.threejsObjects()[0];\n\t\t}\n\t\tnewParent = newParent || _createNewParent();\n\t\tfor (let object of objects) {\n\t\t\tnewParent.add(object);\n\t\t}\n\t\tif (params.levels > 1) {\n\t\t\tfunction _addNewParent(object: Object3D, params: HierarchySopParams): Group {\n\t\t\t\tconst newParent2 = _createNewParent();\n\t\t\t\tnewParent2.add(object);\n\t\t\t\treturn newParent2;\n\t\t\t}\n\t\t\tfor (let i = 1; i < params.levels; i++) {\n\t\t\t\tnewParent = _addNewParent(newParent, params);\n\t\t\t}\n\t\t}\n\n\t\treturn newParent;\n\t}\n\n\tif (params.levels == 0) {\n\t\treturn coreGroup.threejsObjects();\n\t} else {\n\t\tconst newObject = _addParentToObject(coreGroup.threejsObjects());\n\t\treturn [newObject];\n\t}\n}\n\nfunction _removeParentFromCoreGroup(coreGroup: CoreGroup, params: HierarchySopParams): Object3D[] {\n\tfunction _removeParentFromObject(object: Object3D, params: HierarchySopParams): Object3D[] {\n\t\tfunction _getChildrenFromObjects(objects: Object3D[]): Object3D[] {\n\t\t\tlet object;\n\t\t\tconst children: Object3D[] = [];\n\t\t\twhile ((object = objects.pop())) {\n\t\t\t\tif (object.children) {\n\t\t\t\t\tfor (let child of object.children) {\n\t\t\t\t\t\tchildren.push(child);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn children;\n\t\t}\n\n\t\tlet current_children = object.children;\n\n\t\tfor (let i = 0; i < params.levels - 1; i++) {\n\t\t\tcurrent_children = _getChildrenFromObjects(current_children);\n\t\t}\n\n\t\treturn current_children;\n\t}\n\n\tif (params.levels == 0) {\n\t\treturn coreGroup.threejsObjects();\n\t} else {\n\t\tconst newObjects: Object3D[] = [];\n\t\tconst threejsObjects = coreGroup.threejsObjects();\n\t\tfor (let object of threejsObjects) {\n\t\t\tconst newChildren = _removeParentFromObject(object, params);\n\t\t\tfor (let newChild of newChildren) {\n\t\t\t\tnewObjects.push(newChild);\n\t\t\t}\n\t\t}\n\t\treturn newObjects;\n\t}\n}\n\nfunction _addChildrenToCoreGroup(\n\tcoreGroup: CoreGroup,\n\tchildCoreGroup: CoreGroup | undefined,\n\tparams: HierarchySopParams,\n\toperation: HierarchySopOperation,\n\tstates: NodeStatesController<NodeContext.SOP> | undefined\n): Object3D[] {\n\tconst objects = coreGroup.threejsObjects();\n\n\tif (!childCoreGroup) {\n\t\tstates?.error.set('input 1 is invalid');\n\t\treturn [];\n\t}\n\n\tfunction _findObjectsByMaskFromObjects(mask: string, objects: Object3D[]) {\n\t\tconst list: Object3D[] = [];\n\t\tfor (let object of objects) {\n\t\t\tCorePath.objectsByMaskInObject(mask, object, list);\n\t\t}\n\t\treturn list;\n\t}\n\tfunction _getParentObjects() {\n\t\tconst mask = params.objectMask.trim();\n\t\tconst maskValid = mask != '';\n\n\t\tconst parentObjects = maskValid ? _findObjectsByMaskFromObjects(mask, objects) : objects;\n\t\treturn parentObjects;\n\t}\n\tconst parentObjects = _getParentObjects();\n\tconst childObjects = childCoreGroup.threejsObjects();\n\n\tfunction _addOneChildPerParent() {\n\t\tfor (let i = 0; i < parentObjects.length; i++) {\n\t\t\tconst parentObject = parentObjects[i];\n\t\t\t// if there is no mask, we use the objects directly under the coreGroup\n\t\t\tconst childObject = childObjects[i] || childObjects[0];\n\t\t\tif (!childObject) {\n\t\t\t\tstates?.error.set('no objects found in input 1');\n\t\t\t\treturn [];\n\t\t\t}\n\n\t\t\tparentObject.add(childObject);\n\t\t}\n\t\treturn objects;\n\t}\n\tfunction _addAllChildrenUnderFirstParent() {\n\t\tconst parentObject = parentObjects[0];\n\t\tfor (let childObject of childObjects) {\n\t\t\tparentObject.add(childObject);\n\t\t}\n\t\treturn objects;\n\t}\n\tfunction _addAllChildrenUnderAllParents() {\n\t\tfor (let parentObject of parentObjects) {\n\t\t\tfor (let childObject of childObjects) {\n\t\t\t\tparentObject.add(childObject.clone());\n\t\t\t}\n\t\t}\n\t\treturn objects;\n\t}\n\n\tconst addChildMode = ADD_CHILD_MODES[params.addChildMode];\n\tswitch (addChildMode) {\n\t\tcase AddChildMode.ONE_CHILD_PER_PARENT: {\n\t\t\treturn _addOneChildPerParent();\n\t\t}\n\t\tcase AddChildMode.ALL_CHILDREN_UNDER_FIRST_PARENT: {\n\t\t\treturn _addAllChildrenUnderFirstParent();\n\t\t}\n\t\tcase AddChildMode.ALL_CHILDREN_UNDER_ALL_PARENTS: {\n\t\t\treturn _addAllChildrenUnderAllParents();\n\t\t}\n\t}\n\tTypeAssert.unreachable(addChildMode);\n}\n","import {PolyhedronBufferGeometry} from './Polyhedron';\n\n// from three/src/geometries/IcosahedronGeometry\nexport class IcosahedronBufferGeometry extends PolyhedronBufferGeometry {\n\toverride parameters: any; //{radius: number, detail:number}\n\tconstructor(radius: number, detail: number, points_only: boolean) {\n\t\tconst t = (1 + Math.sqrt(5)) / 2;\n\n\t\tconst vertices = [\n\t\t\t-1,\n\t\t\tt,\n\t\t\t0,\n\t\t\t1,\n\t\t\tt,\n\t\t\t0,\n\t\t\t-1,\n\t\t\t-t,\n\t\t\t0,\n\t\t\t1,\n\t\t\t-t,\n\t\t\t0,\n\t\t\t0,\n\t\t\t-1,\n\t\t\tt,\n\t\t\t0,\n\t\t\t1,\n\t\t\tt,\n\t\t\t0,\n\t\t\t-1,\n\t\t\t-t,\n\t\t\t0,\n\t\t\t1,\n\t\t\t-t,\n\t\t\tt,\n\t\t\t0,\n\t\t\t-1,\n\t\t\tt,\n\t\t\t0,\n\t\t\t1,\n\t\t\t-t,\n\t\t\t0,\n\t\t\t-1,\n\t\t\t-t,\n\t\t\t0,\n\t\t\t1,\n\t\t];\n\n\t\tconst indices = [\n\t\t\t0, 11, 5, 0, 5, 1, 0, 1, 7, 0, 7, 10, 0, 10, 11, 1, 5, 9, 5, 11, 4, 11, 10, 2, 10, 7, 6, 7, 1, 8, 3, 9, 4,\n\t\t\t3, 4, 2, 3, 2, 6, 3, 6, 8, 3, 8, 9, 4, 9, 5, 2, 4, 11, 6, 2, 10, 8, 6, 7, 9, 8, 1,\n\t\t];\n\n\t\tsuper(vertices, indices, radius, detail, points_only);\n\n\t\t(this as any).type = 'IcosahedronBufferGeometry';\n\n\t\tthis.parameters = {\n\t\t\tradius: radius,\n\t\t\tdetail: detail,\n\t\t};\n\t}\n}\n","import {BaseSopOperation} from './_Base';\nimport {CoreGroup} from '../../../core/geometry/Group';\nimport {Vector3} from 'three';\nimport {IcosahedronBufferGeometry} from '../../../core/geometry/operation/Icosahedron';\nimport {ObjectType} from '../../../core/geometry/Constant';\nimport {isBooleanTrue} from '../../../core/BooleanValue';\nimport {DefaultOperationParams} from '../../../core/operations/_Base';\n\ninterface IcosahedronSopParams extends DefaultOperationParams {\n\tradius: number;\n\tdetail: number;\n\tpointsOnly: boolean;\n\tcenter: Vector3;\n}\n\nexport class IcosahedronSopOperation extends BaseSopOperation {\n\tstatic override readonly DEFAULT_PARAMS: IcosahedronSopParams = {\n\t\tradius: 1,\n\t\tdetail: 0,\n\t\tpointsOnly: false,\n\t\tcenter: new Vector3(0, 0, 0),\n\t};\n\tstatic override type(): Readonly<'icosahedron'> {\n\t\treturn 'icosahedron';\n\t}\n\n\toverride cook(input_contents: CoreGroup[], params: IcosahedronSopParams) {\n\t\tconst object = this._createIcosahedronObject(params);\n\t\tif (this._node) {\n\t\t\tobject.name = this._node.name();\n\t\t}\n\t\treturn this.createCoreGroupFromObjects([object]);\n\t}\n\tprivate _createIcosahedronObject(params: IcosahedronSopParams) {\n\t\tconst pointsOnly = isBooleanTrue(params.pointsOnly);\n\t\tconst geometry = new IcosahedronBufferGeometry(params.radius, params.detail, pointsOnly);\n\t\tgeometry.translate(params.center.x, params.center.y, params.center.z);\n\t\tif (pointsOnly) {\n\t\t\tconst object = this.createObject(geometry, ObjectType.POINTS);\n\t\t\treturn object;\n\t\t} else {\n\t\t\tgeometry.computeVertexNormals();\n\t\t\treturn this.createObject(geometry, ObjectType.MESH);\n\t\t}\n\t}\n}\n","import {Material, Mesh, BufferGeometry} from 'three';\nimport {BaseSopOperation} from './_Base';\nimport {CoreGroup} from '../../../core/geometry/Group';\nimport {TypedNodePathParamValue} from '../../../core/Walker';\nimport {GlobalsGeometryHandler} from '../../../engine/nodes/gl/code/globals/Geometry';\nimport {objectTypeFromObject} from '../../../core/geometry/Constant';\nimport {applyCustomMaterials} from '../../../core/geometry/Material';\nimport {NodeContext} from '../../../engine/poly/NodeContext';\nimport {CoreInstancer} from '../../../core/geometry/Instancer';\nimport {BaseBuilderMatNodeType} from '../../../engine/nodes/mat/_BaseBuilder';\nimport {InputCloneMode} from '../../../engine/poly/InputCloneMode';\nimport {isBooleanTrue} from '../../../core/BooleanValue';\nimport {DefaultOperationParams} from '../../../core/operations/_Base';\nimport {SopType} from '../../poly/registers/nodes/types/Sop';\n\ninterface InstanceSopParams extends DefaultOperationParams {\n\tattributesToCopy: string;\n\tapplyMaterial: boolean;\n\tmaterial: TypedNodePathParamValue;\n}\n\nexport class InstanceSopOperation extends BaseSopOperation {\n\tstatic override readonly DEFAULT_PARAMS: InstanceSopParams = {\n\t\tattributesToCopy: 'instance*',\n\t\tapplyMaterial: true,\n\t\tmaterial: new TypedNodePathParamValue(''),\n\t};\n\tstatic override readonly INPUT_CLONED_STATE = [InputCloneMode.NEVER, InputCloneMode.NEVER];\n\tstatic override type(): Readonly<SopType.INSTANCE> {\n\t\treturn SopType.INSTANCE;\n\t}\n\n\tprivate _globalsHandler: GlobalsGeometryHandler | undefined;\n\tprivate _geometry: BufferGeometry | undefined;\n\n\toverride async cook(inputCoreGroups: CoreGroup[], params: InstanceSopParams) {\n\t\tconst coreGroupToInstance = inputCoreGroups[0];\n\t\tthis._geometry = undefined;\n\n\t\tconst objectToInstance = coreGroupToInstance.threejsObjectsWithGeo()[0];\n\t\tif (objectToInstance) {\n\t\t\tconst geometryToInstance = objectToInstance.geometry;\n\t\t\tif (geometryToInstance) {\n\t\t\t\tconst coreGroup = inputCoreGroups[1];\n\t\t\t\tthis._createInstance(geometryToInstance, coreGroup, params);\n\t\t\t}\n\t\t}\n\n\t\tif (this._geometry) {\n\t\t\tconst type = objectTypeFromObject(objectToInstance);\n\t\t\tif (type) {\n\t\t\t\tconst object = this.createObject(this._geometry, type);\n\t\t\t\tif (object) {\n\t\t\t\t\tif (isBooleanTrue(params.applyMaterial)) {\n\t\t\t\t\t\tconst material = await this._getMaterial(params);\n\t\t\t\t\t\tif (material) {\n\t\t\t\t\t\t\tawait this._applyMaterial(object as Mesh, material);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\treturn this.createCoreGroupFromObjects([object]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn this.createCoreGroupFromObjects([]);\n\t}\n\n\tprivate async _getMaterial(params: InstanceSopParams) {\n\t\tif (isBooleanTrue(params.applyMaterial)) {\n\t\t\tconst materialNode = params.material.nodeWithContext(NodeContext.MAT, this.states?.error);\n\t\t\tif (materialNode) {\n\t\t\t\tthis._globalsHandler = this._globalsHandler || new GlobalsGeometryHandler();\n\t\t\t\tconst matBuilderNode = materialNode as BaseBuilderMatNodeType;\n\t\t\t\tconst matNodeAssemblerController = matBuilderNode.assemblerController();\n\t\t\t\tif (matNodeAssemblerController) {\n\t\t\t\t\tmatNodeAssemblerController.setAssemblerGlobalsHandler(this._globalsHandler);\n\t\t\t\t}\n\n\t\t\t\tconst container = await materialNode.compute();\n\t\t\t\tconst material = container.material();\n\t\t\t\treturn material;\n\t\t\t}\n\t\t}\n\t}\n\n\tasync _applyMaterial(object: Mesh, material: Material) {\n\t\tobject.material = material;\n\t\tapplyCustomMaterials(object, material);\n\t}\n\n\tprivate _createInstance(\n\t\tgeometryToInstance: BufferGeometry,\n\t\ttemplateCoreGroup: CoreGroup,\n\t\tparams: InstanceSopParams\n\t) {\n\t\tthis._geometry = CoreInstancer.createInstanceBufferGeometry(\n\t\t\tgeometryToInstance,\n\t\t\ttemplateCoreGroup,\n\t\t\tparams.attributesToCopy\n\t\t);\n\t}\n}\n","import {BaseSopOperation} from './_Base';\nimport {CoreGroup} from '../../../core/geometry/Group';\nimport {Vector3} from 'three';\nimport {InputCloneMode} from '../../../engine/poly/InputCloneMode';\nimport {DefaultOperationParams} from '../../../core/operations/_Base';\nimport {jitterPositions} from '../../../core/geometry/operation/Jitter';\n\ninterface JitterSopParams extends DefaultOperationParams {\n\tamount: number;\n\tmult: Vector3;\n\tseed: number;\n}\n\nexport class JitterSopOperation extends BaseSopOperation {\n\tstatic override readonly DEFAULT_PARAMS: JitterSopParams = {\n\t\tamount: 1,\n\t\tmult: new Vector3(1, 1, 1),\n\t\tseed: 1,\n\t};\n\tstatic override readonly INPUT_CLONED_STATE = InputCloneMode.FROM_NODE;\n\tstatic override type(): Readonly<'jitter'> {\n\t\treturn 'jitter';\n\t}\n\n\toverride cook(inputCoreGroups: CoreGroup[], params: JitterSopParams) {\n\t\tconst coreGroup = inputCoreGroups[0];\n\t\tjitterPositions(coreGroup, params);\n\n\t\treturn coreGroup;\n\t}\n}\n","import {BaseSopOperation} from './_Base';\nimport {CoreGroup} from '../../../core/geometry/Group';\nimport {InputCloneMode} from '../../../engine/poly/InputCloneMode';\nimport {CubeTexture, LightProbe} from 'three';\nimport {LightProbeParams, DEFAULT_LIGHT_PROBE_PARAMS} from '../../../core/lights/LightProbe';\nimport {NodeContext} from '../../poly/NodeContext';\nimport {LightProbeGenerator} from 'three/examples/jsm/lights/LightProbeGenerator';\nimport {ObjectType, registerObjectType} from '../../../core/geometry/Constant';\n// import { CopType } from '../../poly/registers/nodes/types/Cop';\n// import { CubeMapFromSceneCopNode } from '../../nodes/cop/CubeMapFromScene';\n\nexport class LightProbeSopOperation extends BaseSopOperation {\n\tstatic override readonly DEFAULT_PARAMS: LightProbeParams = DEFAULT_LIGHT_PROBE_PARAMS;\n\tstatic override readonly INPUT_CLONED_STATE = InputCloneMode.NEVER;\n\tstatic override type(): Readonly<'lightProbe'> {\n\t\treturn 'lightProbe';\n\t}\n\toverride async cook(inputCoreGroups: CoreGroup[], params: LightProbeParams) {\n\t\tconst light = this.createLight();\n\t\tlight.name = params.name;\n\n\t\tawait this.updateLightParams(light, params);\n\t\treturn this.createCoreGroupFromObjects([light]);\n\t}\n\n\tcreateLight() {\n\t\tregisterObjectType({\n\t\t\ttype: ObjectType.LIGHT_PROBE,\n\t\t\tcheckFunc: (o) => {\n\t\t\t\tif ((o as LightProbe).isLightProbe) {\n\t\t\t\t\treturn ObjectType.LIGHT_PROBE;\n\t\t\t\t}\n\t\t\t},\n\t\t\tctor: LightProbe,\n\t\t\thumanName: 'LightProbe',\n\t\t});\n\t\tconst light = new LightProbe();\n\t\tlight.name = `LightProbe_${this._node?.name() || ''}`;\n\t\tlight.matrixAutoUpdate = false;\n\t\tlight.updateMatrix();\n\n\t\treturn light;\n\t}\n\tasync updateLightParams(light: LightProbe, params: LightProbeParams) {\n\t\tconst copNode = params.cubeMap.nodeWithContext(NodeContext.COP, this.states?.error);\n\t\tif (copNode) {\n\t\t\tconst container = await copNode.compute();\n\t\t\tif (container) {\n\t\t\t\tconst texture = container.texture();\n\t\t\t\tif (texture instanceof CubeTexture) {\n\t\t\t\t\tconst lightProbe = LightProbeGenerator.fromCubeTexture(texture);\n\t\t\t\t\tlight.copy(lightProbe);\n\t\t\t\t\tlight.sh.scale(params.intensity);\n\t\t\t\t} else {\n\t\t\t\t\t// if(copNode.type() == CopType.CUBE_MAP_FROM_SCENE){\n\t\t\t\t\t// \tconst renderTarget = (copNode as CubeMapFromSceneCopNode).lastGeneratedRenderTarget()\n\t\t\t\t\t// \tconst lightProbe = LightProbeGenerator.fromCubeRenderTarget(renderTarget);\n\t\t\t\t\t// }\n\t\t\t\t\tthis.states?.error.set(`texture node is not a cubeMap`);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tthis.states?.error.set(`texture node invalid`);\n\t\t\t}\n\t\t} else {\n\t\t\tthis.states?.error.set(`no texture node found`);\n\t\t}\n\t}\n}\n","import {BaseSopOperation} from './_Base';\nimport {CoreGroup} from '../../../core/geometry/Group';\nimport {TypedNodePathParamValue} from '../../../core/Walker';\nimport {NodeContext} from '../../../engine/poly/NodeContext';\nimport {BaseBuilderMatNodeType} from '../../../engine/nodes/mat/_BaseBuilder';\nimport {applyRenderHook, applyCustomMaterials, cloneMaterial} from '../../../core/geometry/Material';\nimport {Group, Material, Object3D, Mesh, Texture, ShaderMaterial} from 'three';\nimport {GlobalsGeometryHandler} from '../../../engine/nodes/gl/code/globals/Geometry';\nimport {InputCloneMode} from '../../../engine/poly/InputCloneMode';\nimport {isBooleanTrue} from '../../../core/BooleanValue';\nimport {DefaultOperationParams} from '../../../core/operations/_Base';\nimport {CoreMask} from '../../../core/geometry/Mask';\nimport {BaseMatNodeType} from '../../nodes/mat/_Base';\nimport {MaterialSopNode} from '../../nodes/sop/Material';\n\ninterface MaterialSopParams extends DefaultOperationParams {\n\tgroup: string;\n\tassignMat: boolean;\n\tmaterial: TypedNodePathParamValue;\n\tcloneMat: boolean;\n\tshareCustomUniforms: boolean;\n\tswapCurrentTex: boolean;\n\ttexSrc0: string;\n\ttexDest0: string;\n}\n// type TraverseCallback = (coreObject: CoreObject) => void;\nlet _nextId = 0;\nexport class MaterialSopOperation extends BaseSopOperation {\n\tprivate _materialSopOperationId = _nextId++;\n\tstatic override readonly DEFAULT_PARAMS: MaterialSopParams = {\n\t\tgroup: '',\n\t\tassignMat: true,\n\t\tmaterial: new TypedNodePathParamValue(''),\n\t\tcloneMat: false,\n\t\tshareCustomUniforms: true,\n\t\tswapCurrentTex: false,\n\t\ttexSrc0: 'emissiveMap',\n\t\ttexDest0: 'map',\n\t};\n\tstatic override readonly INPUT_CLONED_STATE = InputCloneMode.FROM_NODE;\n\tstatic override type(): Readonly<'material'> {\n\t\treturn 'material';\n\t}\n\n\tprivate _globalsHandler: GlobalsGeometryHandler = new GlobalsGeometryHandler();\n\n\toverride async cook(inputCoreGroups: CoreGroup[], params: MaterialSopParams) {\n\t\tconst coreGroup = inputCoreGroups[0];\n\n\t\tthis._oldMatByOldNewId.clear();\n\t\tawait this._applyMaterials(coreGroup, params);\n\t\tthis._swapTextures(coreGroup, params);\n\t\treturn coreGroup;\n\t}\n\n\tprivate async _getMaterial(params: MaterialSopParams) {\n\t\tconst materialNode = params.material.nodeWithContext(NodeContext.MAT, this.states?.error);\n\t\tif (materialNode) {\n\t\t\tthis._watchMaterialNode(materialNode);\n\t\t\tconst material = await materialNode.material();\n\t\t\tconst baseBuilderMatNode = materialNode as BaseBuilderMatNodeType;\n\t\t\tif (baseBuilderMatNode.assemblerController) {\n\t\t\t\tbaseBuilderMatNode.assemblerController()?.setAssemblerGlobalsHandler(this._globalsHandler);\n\t\t\t}\n\n\t\t\tif (!material) {\n\t\t\t\tthis.states?.error.set(`material invalid. (error: '${materialNode.states.error.message()}')`);\n\t\t\t}\n\n\t\t\treturn material;\n\t\t} else {\n\t\t\tthis.states?.error.set(`no material node found`);\n\t\t}\n\t}\n\tprivate _watchedMaterialNode: BaseMatNodeType | undefined;\n\tprivate _watchedMaterialNodeMaterial: Material | undefined;\n\tprivate _watchMaterialNode(materialNode: BaseMatNodeType) {\n\t\tif (this._watchedMaterialNode == materialNode) {\n\t\t\treturn;\n\t\t}\n\t\tconst hookName = this._watchHookName();\n\t\tmaterialNode.addPostDirtyHook(hookName, this._onMaterialUpdateBound);\n\t\tmaterialNode.cookController.registerOnCookEnd(hookName, this._onMaterialUpdateBound);\n\t\tif (this._watchedMaterialNode) {\n\t\t\tthis._watchedMaterialNode.removePostDirtyHook(hookName);\n\t\t\tthis._watchedMaterialNode.cookController.deregisterOnCookEnd(hookName);\n\t\t}\n\t\tthis._watchedMaterialNode = materialNode;\n\t}\n\tprivate _onMaterialUpdateBound = this._onMaterialUpdate.bind(this);\n\tprivate async _onMaterialUpdate() {\n\t\tif (!this._watchedMaterialNode) {\n\t\t\treturn;\n\t\t}\n\t\tconst container = await this._watchedMaterialNode.compute();\n\t\tconst material = container.material();\n\t\tif (material != this._watchedMaterialNodeMaterial) {\n\t\t\tthis._watchedMaterialNodeMaterial = material;\n\t\t\tif (this._node) {\n\t\t\t\t(this._node as MaterialSopNode).p.material.setDirty();\n\t\t\t}\n\t\t}\n\t}\n\tprivate _watchHookName() {\n\t\treturn `MaterialSopOperationId-${this._materialSopOperationId}`;\n\t}\n\n\tprivate async _applyMaterials(coreGroup: CoreGroup, params: MaterialSopParams) {\n\t\tif (!isBooleanTrue(params.assignMat)) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst material = await this._getMaterial(params);\n\t\tif (!material) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst selectedObjects = CoreMask.filterThreejsObjects(coreGroup, params);\n\n\t\tfor (let selectedObject of selectedObjects) {\n\t\t\tthis._applyMaterial(selectedObject, material, params);\n\t\t}\n\n\t\treturn coreGroup;\n\t}\n\n\tprivate _oldMatByOldNewId: Map<string, Material> = new Map();\n\tprivate _materialByUuid: Map<string, Material> = new Map();\n\tprivate _swapTextures(coreGroup: CoreGroup, params: MaterialSopParams) {\n\t\tif (!isBooleanTrue(params.swapCurrentTex)) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis._materialByUuid.clear();\n\n\t\tconst objects = CoreMask.filterObjects(coreGroup, params, coreGroup.allCoreObjects());\n\t\tfor (let object of objects) {\n\t\t\tconst mat = (object as Mesh).material as Material;\n\t\t\tthis._materialByUuid.set(mat.uuid, mat);\n\t\t}\n\n\t\tthis._materialByUuid.forEach((mat, mat_uuid) => {\n\t\t\tthis._swapTexture(mat, params);\n\t\t});\n\t}\n\n\tprivate _applyMaterial(object: Object3D, srcMaterial: Material, params: MaterialSopParams) {\n\t\tconst usedMaterial = isBooleanTrue(params.cloneMat)\n\t\t\t? cloneMaterial(this.scene(), srcMaterial, {\n\t\t\t\t\tshareCustomUniforms: params.shareCustomUniforms,\n\t\t\t\t\taddCustomMaterials: true,\n\t\t\t  })\n\t\t\t: srcMaterial;\n\n\t\tif (srcMaterial instanceof ShaderMaterial && usedMaterial instanceof ShaderMaterial) {\n\t\t\tfor (let uniform_name in srcMaterial.uniforms) {\n\t\t\t\tusedMaterial.uniforms[uniform_name] = srcMaterial.uniforms[uniform_name];\n\t\t\t}\n\t\t}\n\n\t\tif ((object as Group).isGroup) {\n\t\t\t// do not assign material to a group, as this could cause render errors\n\t\t\treturn;\n\t\t}\n\n\t\tconst object_with_material = object as Mesh;\n\t\t// const current_mat = object_with_material.material as Material | undefined;\n\t\t// if (current_mat && params.swapCurrentTex) {\n\t\t// \tthis._swap_texture(used_material, current_mat, params);\n\t\t// }\n\t\tthis._oldMatByOldNewId.set(usedMaterial.uuid, object_with_material.material as Material);\n\t\tobject_with_material.material = usedMaterial;\n\n\t\tapplyRenderHook(object, usedMaterial);\n\t\tapplyCustomMaterials(object, usedMaterial);\n\t}\n\n\tprivate _swapTexture(target_mat: Material, params: MaterialSopParams) {\n\t\tif (params.texSrc0 == '' || params.texDest0 == '') {\n\t\t\treturn;\n\t\t}\n\t\tlet src_mat = this._oldMatByOldNewId.get(target_mat.uuid);\n\t\tsrc_mat = src_mat || target_mat;\n\n\t\tconst src_tex: Texture | null = (src_mat as any)[params.texSrc0];\n\t\tif (src_tex) {\n\t\t\t// swap mat param\n\t\t\t(target_mat as any)[params.texDest0] = src_tex;\n\t\t\t// (src_mat as any)[params.texSrc0] = null;\n\t\t\t// swap uniforms\n\t\t\tconst uniforms = (target_mat as any).uniforms;\n\t\t\tif (uniforms) {\n\t\t\t\tconst uniforms_map = uniforms[params.texDest0];\n\t\t\t\tif (uniforms_map) {\n\t\t\t\t\tuniforms[params.texDest0] = {value: src_tex};\n\t\t\t\t\t// uniforms[params.texSrc0] = {value: null};\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n","import {BaseSopOperation} from './_Base';\nimport {CoreGroup} from '../../../core/geometry/Group';\nimport {InputCloneMode} from '../../../engine/poly/InputCloneMode';\nimport {isBooleanTrue} from '../../../core/BooleanValue';\nimport {DefaultOperationParams} from '../../../core/operations/_Base';\nimport {CoreObjectType, ObjectContent} from '../../../core/geometry/ObjectContent';\nimport {CoreMask} from '../../../core/geometry/Mask';\n\ninterface ObjectPropertiesSopParams extends DefaultOperationParams {\n\tgroup: string;\n\t// name\n\ttname: boolean;\n\tname: string;\n\t// renderOrder\n\ttrenderOrder: boolean;\n\trenderOrder: number;\n\t// frustumCulled\n\ttfrustumCulled: boolean;\n\tfrustumCulled: boolean;\n\t// matrixAutoUpdate\n\ttmatrixAutoUpdate: boolean;\n\tmatrixAutoUpdate: boolean;\n\t// visible\n\ttvisible: boolean;\n\tvisible: boolean;\n\t// castShadow\n\ttcastShadow: boolean;\n\tcastShadow: boolean;\n\t// receiveShadow\n\ttreceiveShadow: boolean;\n\treceiveShadow: boolean;\n}\n\nexport class ObjectPropertiesSopOperation extends BaseSopOperation {\n\tstatic override readonly DEFAULT_PARAMS: ObjectPropertiesSopParams = {\n\t\tgroup: '',\n\t\t// name\n\t\ttname: false,\n\t\tname: '',\n\t\t// renderOrder\n\t\ttrenderOrder: false,\n\t\trenderOrder: 0,\n\t\t// frustrumCulled\n\t\ttfrustumCulled: false,\n\t\tfrustumCulled: true,\n\t\t// matrixAutoUpdate\n\t\ttmatrixAutoUpdate: false,\n\t\tmatrixAutoUpdate: false,\n\t\t// visible\n\t\ttvisible: false,\n\t\tvisible: true,\n\t\t// castShadow\n\t\ttcastShadow: false,\n\t\tcastShadow: true,\n\t\t// receiveShadow\n\t\ttreceiveShadow: false,\n\t\treceiveShadow: true,\n\t};\n\tstatic override readonly INPUT_CLONED_STATE = InputCloneMode.FROM_NODE;\n\tstatic override type(): Readonly<'objectProperties'> {\n\t\treturn 'objectProperties';\n\t}\n\n\toverride cook(inputCoreGroups: CoreGroup[], params: ObjectPropertiesSopParams) {\n\t\tconst coreGroup = inputCoreGroups[0];\n\n\t\tconst selectedObjects = CoreMask.filterObjects(coreGroup, params);\n\t\tfor (let object of selectedObjects) {\n\t\t\tthis._updateObject(object, params);\n\t\t}\n\n\t\treturn coreGroup;\n\t}\n\tprivate _updateObject<T extends CoreObjectType>(object: ObjectContent<T>, params: ObjectPropertiesSopParams) {\n\t\tif (isBooleanTrue(params.tname)) {\n\t\t\tobject.name = params.name;\n\t\t}\n\t\tif (isBooleanTrue(params.trenderOrder)) {\n\t\t\tobject.renderOrder = params.renderOrder;\n\t\t}\n\t\tif (isBooleanTrue(params.tfrustumCulled)) {\n\t\t\tobject.frustumCulled = params.frustumCulled;\n\t\t}\n\t\tif (isBooleanTrue(params.tmatrixAutoUpdate)) {\n\t\t\tobject.matrixAutoUpdate = params.matrixAutoUpdate;\n\t\t}\n\t\tif (isBooleanTrue(params.tvisible)) {\n\t\t\tobject.visible = params.visible;\n\t\t}\n\t\tif (isBooleanTrue(params.tcastShadow)) {\n\t\t\tobject.castShadow = params.castShadow;\n\t\t}\n\t\tif (isBooleanTrue(params.treceiveShadow)) {\n\t\t\tobject.receiveShadow = params.receiveShadow;\n\t\t}\n\t}\n}\n","import {MapUtils} from './../../../core/MapUtils';\nimport {Vector2, Vector3, Box3, Object3D} from 'three';\nimport {BaseSopOperation} from './_Base';\nimport {CoreGroup} from '../../../core/geometry/Group';\nimport {InputCloneMode} from '../../../engine/poly/InputCloneMode';\nimport {DefaultOperationParams} from '../../../core/operations/_Base';\nimport {isBooleanTrue} from '../../../core/Type';\nimport {coreObjectClassFactory} from '../../../core/geometry/CoreObjectFactory';\n\ninterface ObjectsLayoutSopParams extends DefaultOperationParams {\n\tmaxLayoutWidth: number;\n\trowHeight: number;\n\tpadding: Vector2;\n\taddAttribs: boolean;\n\taddRowAttrib: boolean;\n\taddRowWidthInner: boolean;\n\taddRowWidthOuter: boolean;\n}\n\nconst currentPos = new Vector2(0, 0);\nconst maxPos = new Vector2(0, 0);\nconst box = new Box3();\nconst boxSize = new Vector3(0, 0);\n\nconst objectsByRow: Map<number, Object3D[]> = new Map();\nexport class ObjectsLayoutSopOperation extends BaseSopOperation {\n\tstatic override readonly DEFAULT_PARAMS: ObjectsLayoutSopParams = {\n\t\tmaxLayoutWidth: 10,\n\t\trowHeight: 1,\n\t\tpadding: new Vector2(0, 0),\n\t\taddAttribs: false,\n\t\taddRowAttrib: false,\n\t\taddRowWidthInner: false,\n\t\taddRowWidthOuter: false,\n\t};\n\tstatic override readonly INPUT_CLONED_STATE = InputCloneMode.FROM_NODE;\n\tstatic override type(): Readonly<'objectsLayout'> {\n\t\treturn 'objectsLayout';\n\t}\n\n\toverride cook(inputCoreGroups: CoreGroup[], params: ObjectsLayoutSopParams) {\n\t\tconst objects = inputCoreGroups[0].threejsObjects();\n\t\tcurrentPos.set(0, 0);\n\t\tmaxPos.set(0, 0);\n\t\tobjectsByRow.clear();\n\t\tlet rowIndex = 0;\n\t\tconst addRowWidth = isBooleanTrue(params.addRowWidthInner) || isBooleanTrue(params.addRowWidthOuter);\n\t\tfor (let object of objects) {\n\t\t\t// get size before scale adjustment\n\t\t\tobject.updateMatrix();\n\t\t\tbox.setFromObject(object);\n\t\t\tbox.getSize(boxSize);\n\n\t\t\t// scale adjustment\n\t\t\tconst scaleFactor = params.rowHeight / boxSize.y;\n\t\t\tobject.scale.multiplyScalar(scaleFactor);\n\t\t\tobject.updateMatrix();\n\n\t\t\t// get size after scale adjustment\n\t\t\tbox.setFromObject(object);\n\t\t\tbox.getSize(boxSize);\n\n\t\t\t// apply padding\n\t\t\tboxSize.x += params.padding.x;\n\t\t\tboxSize.y += params.padding.y;\n\n\t\t\t// move\n\t\t\tcurrentPos.x += boxSize.x;\n\n\t\t\t// change row if needed\n\t\t\tif (currentPos.x > params.maxLayoutWidth) {\n\t\t\t\tcurrentPos.x = boxSize.x;\n\t\t\t\tcurrentPos.y -= boxSize.y;\n\t\t\t\trowIndex++;\n\t\t\t}\n\n\t\t\t// move current object\n\t\t\tobject.position.x = currentPos.x - boxSize.x * 0.5;\n\t\t\tobject.position.y = currentPos.y - boxSize.y * 0.5;\n\t\t\tif (isBooleanTrue(params.addAttribs)) {\n\t\t\t\tif (addRowWidth) {\n\t\t\t\t\tMapUtils.pushOnArrayAtEntry(objectsByRow, rowIndex, object);\n\t\t\t\t}\n\n\t\t\t\tif (isBooleanTrue(params.addRowAttrib)) {\n\t\t\t\t\tcoreObjectClassFactory(object).addAttribute(object, 'row', rowIndex);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tmaxPos.x = Math.max(maxPos.x, object.position.x + boxSize.x * 0.5);\n\t\t\tmaxPos.y = Math.min(maxPos.y, object.position.y - boxSize.y * 0.5);\n\t\t}\n\t\t// center all objects together\n\t\tfor (let object of objects) {\n\t\t\tobject.position.x -= maxPos.x * 0.5;\n\t\t\tobject.position.y -= maxPos.y * 0.5;\n\t\t\tobject.updateMatrix();\n\t\t}\n\t\t// add attribs\n\t\tif (isBooleanTrue(params.addAttribs)) {\n\t\t\tif (addRowWidth) {\n\t\t\t\tobjectsByRow.forEach((objects, _) => {\n\t\t\t\t\tif (isBooleanTrue(params.addRowWidthInner)) {\n\t\t\t\t\t\tconst xs = objects.map((o) => o.position.x);\n\t\t\t\t\t\tconst minX = Math.min(...xs);\n\t\t\t\t\t\tconst maxX = Math.max(...xs);\n\t\t\t\t\t\tconst width = maxX - minX;\n\t\t\t\t\t\tfor (let object of objects) {\n\t\t\t\t\t\t\tcoreObjectClassFactory(object).addAttribute(object, 'rowWidthInner', width);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (isBooleanTrue(params.addRowWidthOuter)) {\n\t\t\t\t\t\tconst minX = Math.min(\n\t\t\t\t\t\t\t...objects.map((o) => {\n\t\t\t\t\t\t\t\tbox.setFromObject(o);\n\t\t\t\t\t\t\t\tbox.getSize(boxSize);\n\t\t\t\t\t\t\t\treturn o.position.x - boxSize.x * 0.5;\n\t\t\t\t\t\t\t})\n\t\t\t\t\t\t);\n\t\t\t\t\t\tconst maxX = Math.max(\n\t\t\t\t\t\t\t...objects.map((o) => {\n\t\t\t\t\t\t\t\tbox.setFromObject(o);\n\t\t\t\t\t\t\t\tbox.getSize(boxSize);\n\t\t\t\t\t\t\t\treturn o.position.x + boxSize.x * 0.5;\n\t\t\t\t\t\t\t})\n\t\t\t\t\t\t);\n\t\t\t\t\t\tconst width = maxX - minX;\n\t\t\t\t\t\tfor (let object of objects) {\n\t\t\t\t\t\t\tcoreObjectClassFactory(object).addAttribute(object, 'rowWidthOuter', width);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\n\t\treturn this.createCoreGroupFromObjects(objects);\n\t}\n}\n","import {BaseSopOperation} from './_Base';\nimport {CoreGroup, Object3DWithGeometry} from '../../../core/geometry/Group';\nimport {InputCloneMode} from '../../poly/InputCloneMode';\nimport {BufferAttribute, Color} from 'three';\nimport {DefaultOperationParams} from '../../../core/operations/_Base';\nimport {SORTED_PALETTE_NAMES} from '../../../core/color/chromotomeWrapper';\nimport {AttribClass, ATTRIBUTE_CLASSES} from '../../../core/geometry/Constant';\nimport {TypeAssert} from '../../poly/Assert';\nimport {coreObjectClassFactory, corePointClassFactory} from '../../../core/geometry/CoreObjectFactory';\n\ninterface PaletteSopParams extends DefaultOperationParams {\n\tclass: number;\n\tpaletteName: string;\n\tcolorsCount: number;\n\tcolor1: Color;\n\tcolor2: Color;\n\tcolor3: Color;\n\tcolor4: Color;\n\tcolor5: Color;\n}\n\nexport class PaletteSopOperation extends BaseSopOperation {\n\tstatic override readonly DEFAULT_PARAMS: PaletteSopParams = {\n\t\tclass: ATTRIBUTE_CLASSES.indexOf(AttribClass.POINT),\n\t\tpaletteName: SORTED_PALETTE_NAMES[0],\n\t\tcolorsCount: 0,\n\t\tcolor1: new Color(1, 1, 1),\n\t\tcolor2: new Color(1, 1, 1),\n\t\tcolor3: new Color(1, 1, 1),\n\t\tcolor4: new Color(1, 1, 1),\n\t\tcolor5: new Color(1, 1, 1),\n\t};\n\tstatic override readonly INPUT_CLONED_STATE = InputCloneMode.FROM_NODE;\n\tstatic override type(): Readonly<'palette'> {\n\t\treturn 'palette';\n\t}\n\n\toverride cook(inputCoreGroups: CoreGroup[], params: PaletteSopParams) {\n\t\tconst coreGroup = inputCoreGroups[0];\n\n\t\tconst colors = [params.color1, params.color2, params.color3, params.color4, params.color5];\n\t\tthis._addAttribute(ATTRIBUTE_CLASSES[params.class], coreGroup, params, colors);\n\n\t\treturn coreGroup;\n\t}\n\tprivate async _addAttribute(\n\t\tattribClass: AttribClass,\n\t\tcoreGroup: CoreGroup,\n\t\tparams: PaletteSopParams,\n\t\tcolors: Color[]\n\t) {\n\t\tswitch (attribClass) {\n\t\t\tcase AttribClass.POINT:\n\t\t\t\treturn await this._setVertexColor(coreGroup, params, colors);\n\t\t\tcase AttribClass.VERTEX:\n\t\t\t\tthis.states?.error.set('vertex not supported yet');\n\t\t\t\treturn;\n\t\t\tcase AttribClass.PRIMITIVE:\n\t\t\t\tthis.states?.error.set('primitive not supported yet');\n\t\t\t\treturn;\n\t\t\tcase AttribClass.OBJECT:\n\t\t\t\treturn await this._setObjectColor(coreGroup, params, colors);\n\t\t\tcase AttribClass.CORE_GROUP:\n\t\t\t\treturn;\n\t\t}\n\t\tTypeAssert.unreachable(attribClass);\n\t}\n\n\tprivate _setObjectColor(coreGroup: CoreGroup, params: PaletteSopParams, colors: Color[]) {\n\t\tconst objects = coreGroup.allObjects();\n\t\tlet i = 0;\n\t\tfor (let object of objects) {\n\t\t\tconst color = colors[i % params.colorsCount];\n\t\t\tcoreObjectClassFactory(object).addAttribute(object, 'color', color.clone());\n\t\t\ti++;\n\t\t}\n\t\treturn coreGroup;\n\t}\n\n\tprivate _setVertexColor(coreGroup: CoreGroup, params: PaletteSopParams, colors: Color[]) {\n\t\tconst objects = coreGroup.threejsObjectsWithGeo();\n\t\tfor (let object of objects) {\n\t\t\tthis._setVertexColorToObject(object, params, colors);\n\t\t}\n\t}\n\n\tprivate _setVertexColorToObject(object: Object3DWithGeometry, params: PaletteSopParams, colors: Color[]) {\n\t\tif (params.colorsCount <= 0) {\n\t\t\treturn;\n\t\t}\n\t\tconst corePointClass = corePointClassFactory(object);\n\n\t\tconst geometry = object.geometry;\n\t\tif (!geometry) {\n\t\t\treturn;\n\t\t}\n\t\tlet colorAttrib = geometry.getAttribute('color') as BufferAttribute;\n\t\tif (!colorAttrib) {\n\t\t\tcorePointClass.addNumericAttribute(object, 'color', 3, [0, 0, 0]);\n\t\t\tcolorAttrib = geometry.getAttribute('color') as BufferAttribute;\n\t\t}\n\t\tif (!colorAttrib) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst array = colorAttrib.array;\n\t\tlet ptIndex = 0;\n\t\tfor (let i = 0; i < array.length; i += 3) {\n\t\t\tconst color = colors[ptIndex % params.colorsCount];\n\t\t\tcolor.toArray(array, i);\n\t\t\tptIndex++;\n\t\t}\n\t}\n}\n","import {\n\t// CorePhysicsAttribute,\n\tPHYSICS_RBD_COLLIDER_TYPES,\n\tPHYSICS_RBD_TYPES,\n} from './../../../core/physics/PhysicsAttribute';\nimport {BaseSopOperation} from './_Base';\n// import {CoreGroup} from '../../../core/geometry/Group';\nimport {InputCloneMode} from '../../../engine/poly/InputCloneMode';\nimport {DefaultOperationParams} from '../../../core/operations/_Base';\nimport {PhysicsRBDColliderType, PhysicsRBDType} from '../../../core/physics/PhysicsAttribute';\nimport {Vector3} from 'three';\n// import {isBooleanTrue} from '../../../core/Type';\n\nexport enum SizeComputationMethod {\n\tAUTO = 'auto',\n\tMANUAL = 'manual',\n}\nexport const SIZE_COMPUTATION_METHODS: SizeComputationMethod[] = [\n\tSizeComputationMethod.AUTO,\n\tSizeComputationMethod.MANUAL,\n];\nexport const SIZE_COMPUTATION_METHOD_MENU_ENTRIES = SIZE_COMPUTATION_METHODS.map((name, value) => ({name, value}));\ninterface PhysicsRBDAttributesSopParams extends DefaultOperationParams {\n\tRBDType: number;\n\tcolliderType: number;\n\ttaddId: boolean;\n\tid: string;\n\tsizeMethod: number;\n\tborderRadius: number;\n\t// cuboid\n\tsizes: Vector3;\n\tsize: number;\n\t// sphere\n\tradius: number;\n\t// capsule\n\theight: number;\n\t// heightField\n\trows: number;\n\tcols: number;\n\t// common\n\tdensity: number;\n\tfriction: number;\n\trestitution: number;\n\tlinearDamping: number;\n\tangularDamping: number;\n\tlinearVelocity: Vector3;\n\tangularVelocity: Vector3;\n\tgravityScale: number;\n\tcanSleep: boolean;\n}\n\nexport class PhysicsRBDAttributesSopOperation extends BaseSopOperation {\n\tstatic override readonly DEFAULT_PARAMS: PhysicsRBDAttributesSopParams = {\n\t\tRBDType: PHYSICS_RBD_TYPES.indexOf(PhysicsRBDType.DYNAMIC),\n\t\tcolliderType: PHYSICS_RBD_COLLIDER_TYPES.indexOf(PhysicsRBDColliderType.CUBOID),\n\t\ttaddId: true,\n\t\tid: '',\n\t\tsizeMethod: SIZE_COMPUTATION_METHODS.indexOf(SizeComputationMethod.AUTO),\n\t\tborderRadius: 0.1,\n\t\t// cuboid\n\t\tsizes: new Vector3(1, 1, 1),\n\t\tsize: 1,\n\t\t// sphere\n\t\tradius: 1,\n\t\t// capsule\n\t\theight: 0.5,\n\t\t// heightField\n\t\trows: 20,\n\t\tcols: 20,\n\t\t// common\n\t\tdensity: 1,\n\t\tfriction: 0.5,\n\t\trestitution: 0.5,\n\t\tlinearDamping: 0,\n\t\tangularDamping: 0,\n\t\tlinearVelocity: new Vector3(0, 0, 0),\n\t\tangularVelocity: new Vector3(0, 0, 0),\n\t\tgravityScale: 1,\n\t\tcanSleep: true,\n\t};\n\tstatic override readonly INPUT_CLONED_STATE = InputCloneMode.FROM_NODE;\n\tstatic override type(): Readonly<'physicsRBDAttributes'> {\n\t\treturn 'physicsRBDAttributes';\n\t}\n\t// override cook(inputCoreGroups: CoreGroup[], params: PhysicsRBDAttributesSopParams) {\n\t// \tconst inputCoreGroup = inputCoreGroups[0];\n\t// \tconst objects = inputCoreGroup.objects();\n\t// \tfor (let object of objects) {\n\t// \t\tconst colliderType = PHYSICS_RBD_COLLIDER_TYPES[params.colliderType];\n\t// \t\tCorePhysicsAttribute.setRBDType(object, PHYSICS_RBD_TYPES[params.RBDType]);\n\t// \t\tCorePhysicsAttribute.setColliderType(object, colliderType);\n\t// \t\tCorePhysicsAttribute.setDensity(object, params.density);\n\t// \t\tCorePhysicsAttribute.setRestitution(object, params.restitution);\n\t// \t\tCorePhysicsAttribute.setLinearDamping(object, params.linearDamping);\n\t// \t\tCorePhysicsAttribute.setAngularDamping(object, params.angularDamping);\n\t// \t\tCorePhysicsAttribute.setCanSleep(object, params.canSleep);\n\n\t// \t\tif (isBooleanTrue(params.taddId)) {\n\t// \t\t\tCorePhysicsAttribute.setRBDId(object, params.id);\n\t// \t\t}\n\n\t// \t\tswitch (colliderType) {\n\t// \t\t\tcase PhysicsRBDColliderType.CUBOID: {\n\t// \t\t\t\tCorePhysicsAttribute.setCuboidSize(object, params.size);\n\t// \t\t\t\tbreak;\n\t// \t\t\t}\n\t// \t\t\tcase PhysicsRBDColliderType.SPHERE: {\n\t// \t\t\t\tCorePhysicsAttribute.setRadius(object, params.radius);\n\t// \t\t\t\tbreak;\n\t// \t\t\t}\n\t// \t\t\tcase PhysicsRBDColliderType.CAPSULE: {\n\t// \t\t\t\tCorePhysicsAttribute.setHeight(object, params.height);\n\t// \t\t\t\tCorePhysicsAttribute.setRadius(object, params.radius);\n\t// \t\t\t\tbreak;\n\t// \t\t\t}\n\t// \t\t}\n\t// \t}\n\n\t// \treturn inputCoreGroup;\n\t// }\n}\n","import {BaseSopOperation} from './_Base';\nimport {BufferGeometry, Vector2, Vector3, PlaneGeometry, Quaternion, BoxGeometry, Box3} from 'three';\nimport {CoreTransform, rotateGeometry} from '../../../core/Transform';\nimport {CoreGroup} from '../../../core/geometry/Group';\nimport {InputCloneMode} from '../../../engine/poly/InputCloneMode';\nimport {isBooleanTrue} from '../../../core/BooleanValue';\nimport {DefaultOperationParams} from '../../../core/operations/_Base';\nimport {ObjectType} from '../../../core/geometry/Constant';\nconst tmpBox = new Box3();\nconst tmpBoxPreRotation = new Box3();\nconst tmpSize = new Vector3();\nconst tmpCenter = new Vector3();\nconst DEFAULT_UP = new Vector3(0, 0, 1);\nconst q = new Quaternion();\n// const size = new Vector3();\n// const center = new Vector3();\ninterface PlaneSopParams extends DefaultOperationParams {\n\tsize: Vector2;\n\tuseSegmentsCount: boolean;\n\tstepSize: number;\n\tsegments: Vector2;\n\tdirection: Vector3;\n\tcenter: Vector3;\n\tasLines: boolean;\n}\nexport const DEFAULT_PARAMS: PlaneSopParams = {\n\tsize: new Vector2(1, 1),\n\tuseSegmentsCount: false,\n\tstepSize: 1,\n\tsegments: new Vector2(1, 1),\n\tdirection: new Vector3(0, 1, 0),\n\tcenter: new Vector3(0, 0, 0),\n\tasLines: false,\n};\nconst _segmentsCount = new Vector2(1, 1);\nexport class PlaneSopOperation extends BaseSopOperation {\n\tstatic override readonly DEFAULT_PARAMS = DEFAULT_PARAMS;\n\tstatic override readonly INPUT_CLONED_STATE = InputCloneMode.NEVER;\n\tstatic override type(): Readonly<'plane'> {\n\t\treturn 'plane';\n\t}\n\n\tprivate _coreTransform = new CoreTransform();\n\n\toverride cook(inputCoreGroups: CoreGroup[], params: PlaneSopParams) {\n\t\tconst coreGroup = inputCoreGroups[0];\n\t\tif (coreGroup) {\n\t\t\treturn this._cookWithInput(coreGroup, params);\n\t\t} else {\n\t\t\treturn this._cookWithoutInput(params);\n\t\t}\n\t}\n\tprivate _cookWithoutInput(params: PlaneSopParams) {\n\t\tconst geometry = this._createPlane(params.size, params);\n\n\t\t// convert to buffer geo, as some render problems can occur otherwise\n\t\t// geometry = BufferGeometryUtils.mergeGeometries([geometry])\n\t\t// console.log(geometry, geometry.isBufferGeometry)\n\t\trotateGeometry(geometry, DEFAULT_UP, params.direction);\n\n\t\tconst matrix = this._coreTransform.translationMatrix(params.center);\n\t\tgeometry.applyMatrix4(matrix);\n\n\t\tconst object = this._createPlaneObject(geometry, params);\n\t\treturn this.createCoreGroupFromObjects([object]);\n\t}\n\n\tprivate _cookWithInput(coreGroup: CoreGroup, params: PlaneSopParams) {\n\t\tcoreGroup.boundingBox(tmpBoxPreRotation);\n\t\ttmpBoxPreRotation.getCenter(tmpCenter);\n\n\t\t// create box\n\t\tcoreGroup.boundingBox(tmpBox);\n\t\ttmpBox.getSize(tmpSize);\n\t\ttmpBox.getCenter(tmpCenter);\n\t\tconst boxGeometry = new BoxGeometry(tmpSize.x, tmpSize.y, tmpSize.z, 1, 1, 1);\n\n\t\t// rotate box\n\t\tfunction _applyInputQuaternion(_q: Quaternion) {\n\t\t\tboxGeometry.applyQuaternion(_q);\n\t\t\tboxGeometry.computeBoundingBox();\n\t\t}\n\t\tfunction _setInputRotation() {\n\t\t\tq.setFromUnitVectors(DEFAULT_UP, params.direction);\n\t\t\t_applyInputQuaternion(q);\n\t\t}\n\t\t// function _resetInputRotation() {\n\t\t// \tq.invert();\n\t\t// \t_applyInputQuaternion(q);\n\t\t// }\n\t\t_setInputRotation();\n\t\tconst bboxPostRotation = boxGeometry.boundingBox!; //coreGroup.boundingBox(true);\n\t\tbboxPostRotation.getSize(tmpSize);\n\t\t// bboxPreRotation.getCenter(center); // debug\n\t\t// _resetInputRotation();\n\n\t\tconst size2d = new Vector2(tmpSize.x, tmpSize.y);\n\t\tconst geometry = this._createPlane(size2d, params);\n\n\t\trotateGeometry(geometry, DEFAULT_UP, params.direction);\n\t\tgeometry.translate(tmpCenter.x, tmpCenter.y, tmpCenter.z);\n\n\t\tconst object = this._createPlaneObject(geometry, params);\n\t\treturn this.createCoreGroupFromObjects([object]);\n\t}\n\n\tprivate _createPlaneObject(geometry: BufferGeometry, params: PlaneSopParams) {\n\t\treturn BaseSopOperation.createObject(geometry, params.asLines ? ObjectType.LINE_SEGMENTS : ObjectType.MESH);\n\t}\n\n\tprivate _createPlane(size: Vector2, params: PlaneSopParams) {\n\t\tsize = size.clone();\n\t\tif (isBooleanTrue(params.useSegmentsCount)) {\n\t\t\t_segmentsCount.x = Math.floor(params.segments.x);\n\t\t\t_segmentsCount.y = Math.floor(params.segments.y);\n\t\t} else {\n\t\t\tif (params.stepSize > 0) {\n\t\t\t\tsize.x = Math.max(size.x, params.stepSize);\n\t\t\t\tsize.y = Math.max(size.y, params.stepSize);\n\t\t\t\t_segmentsCount.x = Math.floor(size.x / params.stepSize);\n\t\t\t\t_segmentsCount.y = Math.floor(size.y / params.stepSize);\n\t\t\t\tsize.x = _segmentsCount.x * params.stepSize;\n\t\t\t\tsize.y = _segmentsCount.y * params.stepSize;\n\t\t\t}\n\t\t}\n\t\tconst geometry = new PlaneGeometry(size.x, size.y, _segmentsCount.x, _segmentsCount.y);\n\t\tif (isBooleanTrue(params.asLines)) {\n\t\t\tconst gridX = Math.floor(_segmentsCount.x);\n\t\t\tconst gridY = Math.floor(_segmentsCount.y);\n\n\t\t\tconst gridX1 = gridX + 1;\n\t\t\t// const gridY1 = gridY + 1;\n\t\t\tconst indices: number[] = [];\n\t\t\tfor (let iy = 0; iy < gridY; iy++) {\n\t\t\t\tfor (let ix = 0; ix < gridX; ix++) {\n\t\t\t\t\tconst a = ix + gridX1 * iy;\n\t\t\t\t\tconst b = ix + gridX1 * (iy + 1);\n\t\t\t\t\tconst d = ix + 1 + gridX1 * iy;\n\n\t\t\t\t\tindices.push(a, b);\n\t\t\t\t\tindices.push(a, d);\n\t\t\t\t\tconst lastX = ix == gridX - 1;\n\t\t\t\t\tconst lastY = iy == gridY - 1;\n\t\t\t\t\tif (lastX || lastY) {\n\t\t\t\t\t\tconst c = ix + 1 + gridX1 * (iy + 1);\n\t\t\t\t\t\tif (lastX) {\n\t\t\t\t\t\t\tindices.push(d, c);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (lastY) {\n\t\t\t\t\t\t\tindices.push(b, c);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tgeometry.setIndex(indices);\n\t\t}\n\t\treturn geometry;\n\t}\n}\n","import {LightUserDataRaymarching} from './../../../core/lights/Common';\nimport {BaseSopOperation} from './_Base';\nimport {CoreGroup} from '../../../core/geometry/Group';\nimport {InputCloneMode} from '../../../engine/poly/InputCloneMode';\nimport {Group, PointLight} from 'three';\nimport {isBooleanTrue} from '../../../core/BooleanValue';\nimport {CorePointLightHelper, PointLightParams, DEFAULT_POINT_LIGHT_PARAMS} from '../../../core/lights/PointLight';\nimport {ObjectType, registerObjectType} from '../../../core/geometry/Constant';\n// import {Mesh, PlaneGeometry, MeshBasicMaterial, Color, DoubleSide} from 'three';\nexport class PointLightSopOperation extends BaseSopOperation {\n\tstatic override readonly DEFAULT_PARAMS: PointLightParams = DEFAULT_POINT_LIGHT_PARAMS;\n\tstatic override readonly INPUT_CLONED_STATE = InputCloneMode.NEVER;\n\tstatic override type(): Readonly<'pointLight'> {\n\t\treturn 'pointLight';\n\t}\n\toverride cook(input_contents: CoreGroup[], params: PointLightParams) {\n\t\tconst light = this.createLight();\n\t\tlight.name = params.name;\n\n\t\tthis.updateLightParams(light, params);\n\t\tthis.updateShadowParams(light, params);\n\n\t\tif (isBooleanTrue(params.showHelper)) {\n\t\t\tconst group = new Group();\n\t\t\tgroup.name = `PointLightGroup_${light.name}`;\n\t\t\tgroup.add(light);\n\t\t\tconst helper = this._createHelper(light, params);\n\t\t\tif (helper) {\n\t\t\t\tgroup.add(helper);\n\t\t\t\thelper.name = `PointLightHelper_${light.name}`;\n\t\t\t}\n\t\t\treturn this.createCoreGroupFromObjects([group]);\n\t\t} else {\n\t\t\treturn this.createCoreGroupFromObjects([light]);\n\t\t}\n\t}\n\n\tprivate _helper: CorePointLightHelper | undefined;\n\tprivate _createHelper(light: PointLight, params: PointLightParams) {\n\t\tthis._helper = this._helper || new CorePointLightHelper();\n\t\treturn this._helper.createAndBuildObject({helperSize: params.helperSize, light});\n\t}\n\n\tcreateLight() {\n\t\tregisterObjectType({\n\t\t\ttype: ObjectType.POINT_LIGHT,\n\t\t\tcheckFunc: (obj) => {\n\t\t\t\tif ((obj as PointLight as any).isPointLight) {\n\t\t\t\t\treturn ObjectType.POINT_LIGHT;\n\t\t\t\t}\n\t\t\t},\n\t\t\tctor: PointLight,\n\t\t\thumanName: 'PointLight',\n\t\t});\n\t\tconst light = new PointLight();\n\t\tconst nodeName = this._node?.name();\n\t\tif (nodeName) {\n\t\t\tlight.name = `PointLight_${nodeName}`;\n\t\t}\n\n\t\tlight.matrixAutoUpdate = false;\n\n\t\tlight.castShadow = true;\n\t\tlight.shadow.bias = -0.001;\n\t\tlight.shadow.mapSize.x = 1024;\n\t\tlight.shadow.mapSize.y = 1024;\n\t\tlight.shadow.camera.near = 0.1;\n\n\t\treturn light;\n\t}\n\tupdateLightParams(light: PointLight, params: PointLightParams) {\n\t\tlight.color = params.color;\n\t\tlight.intensity = params.intensity;\n\t\tlight.decay = params.decay;\n\t\tlight.distance = params.distance;\n\n\t\tlight.userData[LightUserDataRaymarching.PENUMBRA] = params.raymarchingPenumbra;\n\t\tlight.userData[LightUserDataRaymarching.SHADOW_BIAS_ANGLE] = params.raymarchingShadowBiasAngle;\n\t\tlight.userData[LightUserDataRaymarching.SHADOW_BIAS_DISTANCE] = params.raymarchingShadowBiasDistance;\n\t}\n\tupdateShadowParams(light: PointLight, params: PointLightParams) {\n\t\tlight.castShadow = isBooleanTrue(params.castShadow);\n\t\tlight.shadow.autoUpdate = isBooleanTrue(params.shadowAutoUpdate);\n\t\tlight.shadow.needsUpdate = light.shadow.autoUpdate || isBooleanTrue(params.shadowUpdateOnNextRender);\n\n\t\tlight.shadow.mapSize.copy(params.shadowRes);\n\t\t// const map = light.shadow.map;\n\t\t// if (map) {\n\t\t// \tif (isBooleanTrue(params.debugShadow)) {\n\t\t// \t\tlight.add(this._debugShadowMesh(light));\n\t\t// \t} else {\n\t\t// \t\tif (this.__debugShadowMesh) {\n\t\t// \t\t\tlight.remove(this.__debugShadowMesh);\n\t\t// \t\t}\n\t\t// \t}\n\t\t// }\n\n\t\tlight.shadow.camera.near = params.shadowNear;\n\t\tlight.shadow.camera.far = params.shadowFar;\n\t\tlight.shadow.bias = params.shadowBias;\n\n\t\tlight.shadow.camera.updateProjectionMatrix();\n\t}\n\t// private __debugShadowMesh: Mesh<PlaneGeometry, MeshBasicMaterial> | undefined;\n\t// private _debugShadowMesh(light: PointLight) {\n\t// \treturn (this.__debugShadowMesh = this.__debugShadowMesh || this._createDebugShadowMesh(light));\n\t// }\n\t// private _createDebugShadowMesh(light: PointLight) {\n\t// \tconst material = new MeshBasicMaterial({\n\t// \t\tcolor: new Color(1, 1, 1),\n\t// \t\tmap: light.shadow.map.texture,\n\t// \t\tside: DoubleSide,\n\t// \t});\n\t// \tconst mesh = new Mesh(new PlaneGeometry(5, 5, 2, 2), material);\n\t// \tmesh.position.z = 1;\n\t// \tmesh.castShadow = false;\n\t// \tmesh.receiveShadow = false;\n\t// \treturn mesh;\n\t// }\n}\n","import {BaseSopOperation} from './_Base';\nimport {CoreGroup, Object3DWithGeometry} from '../../../core/geometry/Group';\nimport {Vector3, Matrix4, Object3D} from 'three';\nimport {TypeAssert} from '../../../engine/poly/Assert';\nimport {TransformTargetType, TRANSFORM_TARGET_TYPES} from '../../../core/Transform';\nimport {InputCloneMode} from '../../../engine/poly/InputCloneMode';\nimport {DefaultOperationParams} from '../../../core/operations/_Base';\nimport {CorePolarTransform, PolarTransformMatrixParams} from '../../../core/PolarTransform';\n\ninterface PolarTransformSopParams extends DefaultOperationParams, PolarTransformMatrixParams {\n\tapplyOn: number;\n}\n\nexport class PolarTransformSopOperation extends BaseSopOperation {\n\tstatic override readonly DEFAULT_PARAMS: PolarTransformSopParams = {\n\t\tapplyOn: TRANSFORM_TARGET_TYPES.indexOf(TransformTargetType.OBJECT),\n\t\tcenter: new Vector3(0, 0, 0),\n\t\tlongitude: 0,\n\t\tlatitude: 0,\n\t\tdepth: 1,\n\t};\n\tstatic override readonly INPUT_CLONED_STATE = InputCloneMode.FROM_NODE;\n\tstatic override type(): Readonly<'polarTransform'> {\n\t\treturn 'polarTransform';\n\t}\n\n\toverride cook(inputCoreGroups: CoreGroup[], params: PolarTransformSopParams) {\n\t\tconst objects = inputCoreGroups[0].threejsObjects();\n\t\tCorePolarTransform.matrix(params, this._fullMatrix);\n\n\t\tthis._applyTransform(objects, params, this._fullMatrix);\n\n\t\treturn inputCoreGroups[0];\n\t}\n\tprivate _applyTransform(objects: Object3D[], params: PolarTransformSopParams, matrix: Matrix4) {\n\t\tconst mode = TRANSFORM_TARGET_TYPES[params.applyOn];\n\t\tswitch (mode) {\n\t\t\tcase TransformTargetType.GEOMETRY: {\n\t\t\t\treturn this._applyMatrixToGeometries(objects, matrix);\n\t\t\t}\n\t\t\tcase TransformTargetType.OBJECT: {\n\t\t\t\treturn this._applyMatrixToObjects(objects, matrix);\n\t\t\t}\n\t\t}\n\t\tTypeAssert.unreachable(mode);\n\t}\n\n\tprivate _applyMatrixToGeometries(objects: Object3D[], matrix: Matrix4) {\n\t\tfor (let object of objects) {\n\t\t\tconst geometry = (object as Object3DWithGeometry).geometry;\n\t\t\tif (geometry) {\n\t\t\t\tgeometry.applyMatrix4(matrix);\n\t\t\t}\n\t\t}\n\t}\n\tprivate _applyMatrixToObjects(objects: Object3D[], matrix: Matrix4) {\n\t\tfor (let object of objects) {\n\t\t\tCorePolarTransform.applyMatrixToObject(object, matrix);\n\t\t}\n\t}\n\n\tprivate _fullMatrix = new Matrix4();\n}\n","import {BaseSopOperation} from './_Base';\nimport {CoreGroup} from '../../../core/geometry/Group';\nimport {InputCloneMode} from '../../../engine/poly/InputCloneMode';\nimport {BufferAttribute, Matrix4, Mesh, Triangle, Vector3} from 'three';\nimport {Intersection} from 'three';\nimport {isBooleanTrue} from '../../../core/BooleanValue';\nimport {MatDoubleSideTmpSetter} from '../../../core/render/MatDoubleSideTmpSetter';\nimport {DefaultOperationParams} from '../../../core/operations/_Base';\nimport {TypeAssert} from '../../poly/Assert';\nimport {HitPointInfo} from 'three-mesh-bvh';\nimport {BufferGeometryWithBVH} from '../../../core/geometry/bvh/three-mesh-bvh';\nimport {ThreeMeshBVHHelper} from '../../../core/geometry/bvh/ThreeMeshBVHHelper';\nimport {createRaycaster} from '../../../core/RaycastHelper';\nimport {corePointClassFactory} from '../../../core/geometry/CoreObjectFactory';\nimport { CoreObjectType } from '../../../core/geometry/ObjectContent';\nimport { CorePoint } from '../../../core/geometry/entities/point/CorePoint';\n\nexport enum RaySopMode {\n\tPROJECT_RAY = 'project rays',\n\tMIN_DIST = 'minimum distance',\n}\nexport const RAY_SOP_MODES: RaySopMode[] = [RaySopMode.PROJECT_RAY, RaySopMode.MIN_DIST];\n\ninterface RaySopParams extends DefaultOperationParams {\n\tmode: number;\n\tuseNormals: boolean;\n\tdirection: Vector3;\n\ttransferFaceNormals: boolean;\n\ttransformPoints: boolean;\n\taddDistAttribute: boolean;\n}\n\nconst DIST_ATTRIB_NAME = 'dist';\n\nconst objectWorldMat = new Matrix4();\nconst objectWorldMatInverse = new Matrix4();\nconst _points:CorePoint<CoreObjectType>[]=[]\n\nexport class RaySopOperation extends BaseSopOperation {\n\tstatic override readonly DEFAULT_PARAMS: RaySopParams = {\n\t\tmode: RAY_SOP_MODES.indexOf(RaySopMode.PROJECT_RAY),\n\t\tuseNormals: true,\n\t\tdirection: new Vector3(0, -1, 0),\n\t\ttransformPoints: true,\n\t\ttransferFaceNormals: true,\n\t\taddDistAttribute: false,\n\t};\n\tstatic override readonly INPUT_CLONED_STATE = [InputCloneMode.FROM_NODE, InputCloneMode.NEVER];\n\tstatic override type(): Readonly<'ray'> {\n\t\treturn 'ray';\n\t}\n\n\tprivate _matDoubleSideTmpSetter = new MatDoubleSideTmpSetter();\n\tprivate _raycaster = createRaycaster();\n\n\toverride cook(inputCoreGroups: CoreGroup[], params: RaySopParams) {\n\t\tconst coreGroupToRay = inputCoreGroups[0];\n\t\tconst coreGroupToRayOnto = inputCoreGroups[1];\n\n\t\tconst coreGroup = this._ray(coreGroupToRay, coreGroupToRayOnto, params);\n\t\treturn coreGroup;\n\t}\n\n\tprivate _pointPos = new Vector3();\n\tprivate _pointNormal = new Vector3();\n\tprivate _hitPointInfo: HitPointInfo = {\n\t\tpoint: new Vector3(),\n\t\tdistance: -1,\n\t\tfaceIndex: -1,\n\t};\n\tprivate _triangle = new Triangle();\n\tprivate _faceNormal = new Vector3();\n\tprivate _ray(coreGroup: CoreGroup, coreGroupCollision: CoreGroup, params: RaySopParams) {\n\t\tconst mode = RAY_SOP_MODES[params.mode];\n\t\tswitch (mode) {\n\t\t\tcase RaySopMode.PROJECT_RAY: {\n\t\t\t\treturn this._computeWithProjectRay(coreGroup, coreGroupCollision, params);\n\t\t\t}\n\t\t\tcase RaySopMode.MIN_DIST: {\n\t\t\t\treturn this._computeWithMinDist(coreGroup, coreGroupCollision, params);\n\t\t\t}\n\t\t}\n\t\tTypeAssert.unreachable(mode);\n\t}\n\n\tprivate _computeWithProjectRay(coreGroup: CoreGroup, coreGroupCollision: CoreGroup, params: RaySopParams) {\n\t\tthis._matDoubleSideTmpSetter.setCoreGroupMaterialDoubleSided(coreGroupCollision);\n\n\t\tif (isBooleanTrue(params.addDistAttribute)) {\n\t\t\tif (!coreGroup.hasPointAttrib(DIST_ATTRIB_NAME)) {\n\t\t\t\tconst allObjects = coreGroup.allObjects();\n\t\t\t\tfor (const object of allObjects) {\n\t\t\t\t\tconst corePointClass = corePointClassFactory(object);\n\t\t\t\t\tcorePointClass.addNumericAttribute(object, DIST_ATTRIB_NAME, 1, -1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tlet direction: Vector3, firstIntersect: Intersection;\n\t\tcoreGroup.points(_points);\n\t\tfor (const point of _points) {\n\t\t\tpoint.position(this._pointPos);\n\t\t\tdirection = params.direction;\n\t\t\tif (isBooleanTrue(params.useNormals)) {\n\t\t\t\tpoint.normal(this._pointNormal);\n\t\t\t\tdirection = this._pointNormal;\n\t\t\t}\n\t\t\tthis._raycaster.set(this._pointPos, direction);\n\t\t\tfirstIntersect = this._raycaster.intersectObjects(coreGroupCollision.threejsObjects(), true)[0];\n\t\t\tif (firstIntersect) {\n\t\t\t\tif (isBooleanTrue(params.transformPoints)) {\n\t\t\t\t\tpoint.setPosition(firstIntersect.point);\n\t\t\t\t}\n\t\t\t\tif (isBooleanTrue(params.addDistAttribute)) {\n\t\t\t\t\tconst dist = this._pointPos.distanceTo(firstIntersect.point);\n\t\t\t\t\tpoint.setAttribValue(DIST_ATTRIB_NAME, dist);\n\t\t\t\t}\n\t\t\t\tif (isBooleanTrue(params.transferFaceNormals) && firstIntersect.face) {\n\t\t\t\t\tpoint.setNormal(firstIntersect.face.normal);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tthis._matDoubleSideTmpSetter.restoreMaterialSideProperty(coreGroupCollision);\n\t\treturn coreGroup;\n\t}\n\tprivate _computeWithMinDist(coreGroup: CoreGroup, coreGroupCollision: CoreGroup, params: RaySopParams) {\n\t\tconst coreGroupCollisionObject = coreGroupCollision.threejsObjectsWithGeo()[0];\n\t\tconst collisionGeometry = coreGroupCollisionObject.geometry as BufferGeometryWithBVH;\n\t\tconst indexArray = collisionGeometry.getIndex()?.array;\n\t\tif (!indexArray) {\n\t\t\tthis.states?.error.set('the collision geo requires an index');\n\t\t\treturn coreGroup;\n\t\t}\n\n\t\t// find or create bvh\n\t\tlet bvh = collisionGeometry.boundsTree;\n\t\tif (!bvh) {\n\t\t\tThreeMeshBVHHelper.assignDefaultBVHIfNone(coreGroupCollisionObject as Mesh);\n\t\t\tbvh = collisionGeometry.boundsTree;\n\t\t}\n\n\t\tcoreGroupCollisionObject.updateMatrixWorld(true);\n\t\tobjectWorldMat.copy(coreGroupCollisionObject.matrixWorld);\n\t\tobjectWorldMatInverse.copy(objectWorldMat).invert();\n\n\t\t// find closest pt\n\t\tconst position = collisionGeometry.getAttribute('position') as BufferAttribute;\n\t\tcoreGroup.points(_points);\n\t\tfor (const point of _points) {\n\t\t\tpoint.position(this._pointPos);\n\t\t\t// apply object inverse matrix\n\t\t\tthis._pointPos.applyMatrix4(objectWorldMatInverse);\n\t\t\tbvh.closestPointToPoint(this._pointPos, this._hitPointInfo);\n\t\t\tif (isBooleanTrue(params.transformPoints)) {\n\t\t\t\t// apply object matrix when setting the position\n\t\t\t\tthis._hitPointInfo.point.applyMatrix4(objectWorldMat);\n\t\t\t\tpoint.setPosition(this._hitPointInfo.point);\n\t\t\t}\n\t\t\tif (isBooleanTrue(params.addDistAttribute)) {\n\t\t\t\tpoint.setAttribValue(DIST_ATTRIB_NAME, this._hitPointInfo.distance);\n\t\t\t}\n\t\t\tif (isBooleanTrue(params.transferFaceNormals)) {\n\t\t\t\t// TODO: test if applying the object matrix is necessary (probably is)\n\t\t\t\tthis._triangle.setFromAttributeAndIndices(\n\t\t\t\t\tposition,\n\t\t\t\t\tindexArray[3 * this._hitPointInfo.faceIndex],\n\t\t\t\t\tindexArray[3 * this._hitPointInfo.faceIndex + 1],\n\t\t\t\t\tindexArray[3 * this._hitPointInfo.faceIndex + 2]\n\t\t\t\t);\n\t\t\t\tthis._triangle.getNormal(this._faceNormal);\n\t\t\t\tpoint.setNormal(this._faceNormal);\n\t\t\t}\n\t\t}\n\t\treturn coreGroup;\n\t}\n}\n","import {BaseSopOperation} from './_Base';\nimport {CoreGroup, Object3DWithGeometry} from '../../../core/geometry/Group';\nimport {isBooleanTrue} from '../../../core/BooleanValue';\nimport {DefaultOperationParams} from '../../../core/operations/_Base';\nimport {BufferAttribute} from 'three';\ninterface RestAttributesSopParams extends DefaultOperationParams {\n\ttposition: boolean;\n\tposition: string;\n\trestP: string;\n\ttnormal: boolean;\n\tnormal: string;\n\trestN: string;\n}\n\nexport class RestAttributesSopOperation extends BaseSopOperation {\n\tstatic override readonly DEFAULT_PARAMS: RestAttributesSopParams = {\n\t\ttposition: true,\n\t\tposition: 'position',\n\t\trestP: 'restP',\n\t\ttnormal: true,\n\t\tnormal: 'normal',\n\t\trestN: 'restN',\n\t};\n\tstatic override type(): Readonly<'restAttributes'> {\n\t\treturn 'restAttributes';\n\t}\n\n\toverride cook(input_contents: CoreGroup[], params: RestAttributesSopParams) {\n\t\tconst core_group = input_contents[0];\n\t\tconst objects = core_group.threejsObjectsWithGeo();\n\t\tif (isBooleanTrue(params.tposition)) {\n\t\t\tthis._create_rest_attribute(objects, params.position, params.restP);\n\t\t}\n\t\tif (isBooleanTrue(params.tnormal)) {\n\t\t\tthis._create_rest_attribute(objects, params.normal, params.restN);\n\t\t}\n\n\t\treturn this.createCoreGroupFromObjects(objects);\n\t}\n\tprivate _create_rest_attribute(objects: Object3DWithGeometry[], attrib_name: string, rest_attrib_name: string) {\n\t\tfor (let object of objects) {\n\t\t\tconst geometry = object.geometry;\n\t\t\tif (geometry) {\n\t\t\t\tconst src_attrib = geometry.getAttribute(attrib_name) as BufferAttribute | undefined;\n\t\t\t\tif (src_attrib) {\n\t\t\t\t\tgeometry.setAttribute(rest_attrib_name, src_attrib.clone());\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n","import {BaseSopOperation} from './_Base';\nimport {CoreGroup} from '../../../core/geometry/Group';\nimport {InputCloneMode} from '../../../engine/poly/InputCloneMode';\nimport {DefaultOperationParams} from '../../../core/operations/_Base';\nimport {isBooleanTrue} from '../../../core/Type';\nimport {Object3D} from 'three';\n\ninterface SetChildrenParams extends DefaultOperationParams {\n\tclearExistingChildren: boolean;\n}\n\nexport class SetChildrenSopOperation extends BaseSopOperation {\n\tstatic override readonly DEFAULT_PARAMS: SetChildrenParams = {\n\t\tclearExistingChildren: true,\n\t};\n\tstatic override readonly INPUT_CLONED_STATE = [InputCloneMode.FROM_NODE, InputCloneMode.FROM_NODE];\n\tstatic override type(): Readonly<'setChildren'> {\n\t\treturn 'setChildren';\n\t}\n\n\toverride cook(inputCoreGroups: CoreGroup[], params: SetChildrenParams) {\n\t\tconst parentCoreGroup = inputCoreGroups[0];\n\t\tconst childrenCoreGroup = inputCoreGroups[1];\n\n\t\tif (!childrenCoreGroup) {\n\t\t\tthis.states?.error.set('input 1 is invalid');\n\t\t\treturn this.createCoreGroupFromObjects([]);\n\t\t}\n\n\t\tconst parentObjects = parentCoreGroup.threejsObjects();\n\t\tconst childrenObjects = childrenCoreGroup.threejsObjects();\n\t\tlet i = 0;\n\t\tif (isBooleanTrue(params.clearExistingChildren)) {\n\t\t\tfor (const parentObject of parentObjects) {\n\t\t\t\tlet child: Object3D | undefined;\n\t\t\t\twhile ((child = parentObject.children[0])) {\n\t\t\t\t\tparentObject.remove(child);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (const childObject of childrenObjects) {\n\t\t\tconst parentObject = parentObjects[i] || parentObjects[parentObjects.length - 1];\n\n\t\t\tif (childObject) {\n\t\t\t\tparentObject.add(childObject);\n\t\t\t}\n\t\t\ti++;\n\t\t}\n\t\treturn this.createCoreGroupFromObjects(parentObjects);\n\t}\n}\n","import {TypeAssert} from './../../poly/Assert';\nimport {BaseSopOperation} from './_Base';\nimport {CoreGroup} from '../../../core/geometry/Group';\nimport {Mesh, BufferGeometry} from 'three';\nimport {InputCloneMode} from '../../../engine/poly/InputCloneMode';\nimport {DefaultOperationParams} from '../../../core/operations/_Base';\n\nexport enum SetGeometryMode {\n\tONE_GEO_PER_OBJECT = 'One Geometry Per Object',\n\tFIRST_GEO_TO_EACH_OBJECT = 'First Geometry To Each Object',\n}\nexport const SET_GEOMETRY_MODES: SetGeometryMode[] = [\n\tSetGeometryMode.ONE_GEO_PER_OBJECT,\n\tSetGeometryMode.FIRST_GEO_TO_EACH_OBJECT,\n];\n\ninterface SetGeometrySopParams extends DefaultOperationParams {\n\tmode: number;\n}\n\nexport class SetGeometrySopOperation extends BaseSopOperation {\n\tstatic override readonly DEFAULT_PARAMS: SetGeometrySopParams = {\n\t\tmode: SET_GEOMETRY_MODES.indexOf(SetGeometryMode.ONE_GEO_PER_OBJECT),\n\t};\n\tstatic override readonly INPUT_CLONED_STATE = [InputCloneMode.FROM_NODE, InputCloneMode.NEVER];\n\tstatic override type(): Readonly<'setGeometry'> {\n\t\treturn 'setGeometry';\n\t}\n\n\toverride cook(inputCoreGroups: CoreGroup[], params: SetGeometrySopParams) {\n\t\tconst coreGroupDest = inputCoreGroups[0];\n\t\tconst coreGroupSrc = inputCoreGroups[1];\n\n\t\tthis._applyMode(coreGroupDest, coreGroupSrc, params);\n\n\t\treturn coreGroupDest;\n\t}\n\n\tprivate _applyMode(coreGroupDest: CoreGroup, coreGroupSrc: CoreGroup, params: SetGeometrySopParams) {\n\t\tconst mode = SET_GEOMETRY_MODES[params.mode];\n\t\tswitch (mode) {\n\t\t\tcase SetGeometryMode.ONE_GEO_PER_OBJECT: {\n\t\t\t\treturn this._oneGeoPerObject(coreGroupDest, coreGroupSrc);\n\t\t\t}\n\t\t\tcase SetGeometryMode.FIRST_GEO_TO_EACH_OBJECT: {\n\t\t\t\treturn this._firstGeoToEachObject(coreGroupDest, coreGroupSrc);\n\t\t\t}\n\t\t}\n\t\tTypeAssert.unreachable(mode);\n\t}\n\n\tprivate _oneGeoPerObject(coreGroupDest: CoreGroup, coreGroupSrc: CoreGroup) {\n\t\tconst destObjects = coreGroupDest.threejsObjects();\n\t\tconst srcObjects = coreGroupSrc.threejsObjects();\n\t\tfor (let i = 0; i < destObjects.length; i++) {\n\t\t\tconst destObject = destObjects[i] as Mesh | undefined;\n\t\t\tconst srcObject = srcObjects[i] as Mesh | undefined;\n\n\t\t\tif (destObject) {\n\t\t\t\tdestObject.geometry = srcObject ? srcObject.geometry : SetGeometrySopOperation._emptyGeometry();\n\t\t\t}\n\t\t}\n\t}\n\tprivate _firstGeoToEachObject(coreGroupDest: CoreGroup, coreGroupSrc: CoreGroup) {\n\t\tconst destObjects = coreGroupDest.threejsObjects();\n\t\tconst srcObjects = coreGroupSrc.threejsObjects();\n\t\tlet firstGeometry: BufferGeometry | undefined;\n\t\tfor (let srcObject of srcObjects) {\n\t\t\tif ((srcObject as Mesh).geometry) {\n\t\t\t\tfirstGeometry = (srcObject as Mesh).geometry;\n\t\t\t}\n\t\t}\n\t\tfor (let i = 0; i < destObjects.length; i++) {\n\t\t\tconst destObject = destObjects[i] as Mesh | undefined;\n\n\t\t\tif (destObject) {\n\t\t\t\tdestObject.geometry = firstGeometry || SetGeometrySopOperation._emptyGeometry();\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate static __emptyGeometry: BufferGeometry | undefined;\n\tprivate static _emptyGeometry() {\n\t\treturn (this.__emptyGeometry = this.__emptyGeometry || new BufferGeometry());\n\t}\n}\n","import {CoreMath} from './../../../core/math/_Module';\nimport {BaseCoreObject} from './../../../core/geometry/entities/object/BaseCoreObject';\nimport {TypeAssert} from './../../poly/Assert';\nimport {AttribClass} from './../../../core/geometry/Constant';\nimport {BaseSopOperation} from './_Base';\nimport {CoreGroup, Object3DWithGeometry} from '../../../core/geometry/Group';\nimport {InputCloneMode} from '../../../engine/poly/InputCloneMode';\nimport {Vector3} from 'three';\nimport {MapUtils} from '../../../core/MapUtils';\nimport {BufferAttribute} from 'three';\nimport {DefaultOperationParams} from '../../../core/operations/_Base';\nimport {CoreObjectType, ObjectContent} from '../../../core/geometry/ObjectContent';\nimport {isBooleanTrue} from '../../../core/Type';\nimport {setToArray} from '../../../core/SetUtils';\nimport {isNumber} from '../../../core/Type';\nimport {pointsFromObject} from '../../../core/geometry/entities/point/CorePointUtils';\nimport {corePointClassFactory} from '../../../core/geometry/CoreObjectFactory';\nimport { CorePoint } from '../../../core/geometry/entities/point/CorePoint';\n\nconst tmpPos = new Vector3();\n\nexport enum SortMode {\n\tRANDOM = 'random',\n\tAXIS = 'axis',\n\tATTRIBUTE = 'attribute',\n}\nexport const SORT_MODES: SortMode[] = [SortMode.AXIS, SortMode.RANDOM, SortMode.ATTRIBUTE];\n\nexport type SortTargetType = AttribClass.POINT | AttribClass.OBJECT;\nexport const SORT_TARGET_TYPES: Array<SortTargetType> = [AttribClass.POINT, AttribClass.OBJECT];\n\nexport enum Axis {\n\tX = 'x',\n\tY = 'y',\n\tZ = 'z',\n}\nexport const AXISES: Axis[] = [Axis.X, Axis.Y, Axis.Z];\nconst _points:CorePoint<CoreObjectType>[]=[]\ninterface SortSopParams extends DefaultOperationParams {\n\ttargetType: number;\n\tmode: number;\n\t// random\n\tseed: number;\n\t// axis\n\taxis: number;\n\t// attribute\n\tattribute: string;\n\t// common\n\tinvert: boolean;\n}\n\nexport class SortSopOperation extends BaseSopOperation {\n\tstatic override readonly DEFAULT_PARAMS: SortSopParams = {\n\t\tmode: SORT_MODES.indexOf(SortMode.AXIS),\n\t\ttargetType: SORT_TARGET_TYPES.indexOf(AttribClass.POINT),\n\t\tseed: 0,\n\t\taxis: AXISES.indexOf(Axis.X),\n\t\tattribute: '',\n\t\tinvert: false,\n\t};\n\tstatic override readonly INPUT_CLONED_STATE = InputCloneMode.FROM_NODE;\n\tstatic override type(): Readonly<'sort'> {\n\t\treturn 'sort';\n\t}\n\n\toverride cook(inputCoreGroups: CoreGroup[], params: SortSopParams) {\n\t\tconst coreGroup = inputCoreGroups[0];\n\t\tthis._sort(coreGroup, params);\n\t\treturn coreGroup;\n\t}\n\tprivate _sort(coreGroup: CoreGroup, params: SortSopParams) {\n\t\tconst targetType = SORT_TARGET_TYPES[params.targetType];\n\t\tswitch (targetType) {\n\t\t\tcase AttribClass.POINT:\n\t\t\t\treturn this._sortPoints(coreGroup, params);\n\t\t\tcase AttribClass.OBJECT:\n\t\t\t\treturn this._sortObjects(coreGroup, params);\n\t\t}\n\t}\n\n\tprivate _sortObjects(coreGroup: CoreGroup, params: SortSopParams) {\n\t\tconst sortMode = SORT_MODES[params.mode];\n\t\tswitch (sortMode) {\n\t\t\tcase SortMode.AXIS:\n\t\t\t\treturn this._sortObjectsByAxis(coreGroup, params);\n\t\t\tcase SortMode.RANDOM:\n\t\t\t\treturn this._sortObjectsByRandom(coreGroup, params);\n\t\t\tcase SortMode.ATTRIBUTE:\n\t\t\t\treturn this._sortObjectsByAttribute(coreGroup, params);\n\t\t}\n\t\tTypeAssert.unreachable(sortMode);\n\t}\n\tprivate _sortObjectsByAxis(coreGroup: CoreGroup, params: SortSopParams) {\n\t\tconst coreObjects = coreGroup.allCoreObjects();\n\t\tconst objectsByPos: Map<number, BaseCoreObject<CoreObjectType>[]> = new Map();\n\t\tconst positions: Set<number> = new Set();\n\n\t\t// accumulate axisValue\n\t\tconst axis = AXISES[params.axis];\n\t\tlet axisValue: number = 0;\n\t\tfor (let coreObject of coreObjects) {\n\t\t\tcoreObject.position(tmpPos);\n\t\t\tswitch (axis) {\n\t\t\t\tcase Axis.X: {\n\t\t\t\t\taxisValue = tmpPos.x;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcase Axis.Y: {\n\t\t\t\t\taxisValue = tmpPos.y;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcase Axis.Z: {\n\t\t\t\t\taxisValue = tmpPos.z;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tpositions.add(axisValue);\n\t\t\tMapUtils.pushOnArrayAtEntry(objectsByPos, axisValue, coreObject);\n\t\t}\n\n\t\t// sort\n\t\tlet sortedPositions: number[] = setToArray(positions, []).sort((a, b) => a - b);\n\t\tif (isBooleanTrue(params.invert)) {\n\t\t\tsortedPositions.reverse();\n\t\t}\n\n\t\tconst sortedObjects: ObjectContent<CoreObjectType>[] = [];\n\t\tfor (let position of sortedPositions) {\n\t\t\tconst coreObjectsForPosition = objectsByPos.get(position);\n\t\t\tif (coreObjectsForPosition) {\n\t\t\t\tfor (let coreObjectForPosition of coreObjectsForPosition) {\n\t\t\t\t\tconst object = coreObjectForPosition.object();\n\t\t\t\t\tif (object) {\n\t\t\t\t\t\tsortedObjects.push(object);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcoreGroup.setAllObjects(sortedObjects);\n\t}\n\tprivate _sortObjectsByRandom(coreGroup: CoreGroup, params: SortSopParams) {\n\t\tconst coreObjects = coreGroup.allCoreObjects();\n\t\tconst objectsByPos: Map<number, BaseCoreObject<CoreObjectType>[]> = new Map();\n\t\tconst positions: number[] = [];\n\n\t\t// accumulate axisValue\n\t\tlet sortValue: number = 0;\n\t\tlet i = 0;\n\t\tfor (let coreObject of coreObjects) {\n\t\t\tsortValue = CoreMath.randFloat(params.seed, i);\n\t\t\tpositions[i] = sortValue;\n\t\t\tMapUtils.pushOnArrayAtEntry(objectsByPos, sortValue, coreObject);\n\t\t\ti++;\n\t\t}\n\n\t\t// sort\n\t\tlet sortedPositions: number[] = positions.sort((a, b) => a - b);\n\t\tif (params.invert) {\n\t\t\tsortedPositions.reverse();\n\t\t}\n\n\t\tconst sortedObjects: ObjectContent<CoreObjectType>[] = [];\n\t\tfor (let position of sortedPositions) {\n\t\t\tconst coreObjectsForPosition = objectsByPos.get(position);\n\t\t\tif (coreObjectsForPosition) {\n\t\t\t\tfor (let coreObjectForPosition of coreObjectsForPosition) {\n\t\t\t\t\tconst object = coreObjectForPosition.object();\n\t\t\t\t\tif (object) {\n\t\t\t\t\t\tsortedObjects.push(object);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcoreGroup.setAllObjects(sortedObjects);\n\t}\n\tprivate _sortObjectsByAttribute(coreGroup: CoreGroup, params: SortSopParams) {\n\t\tconst coreObjects = coreGroup.allCoreObjects();\n\t\tconst objectsByAttribValue: Map<number, BaseCoreObject<CoreObjectType>[]> = new Map();\n\t\tconst attribValues: number[] = [];\n\n\t\t// accumulate attribValue\n\t\tlet i = 0;\n\t\tfor (let coreObject of coreObjects) {\n\t\t\tconst attribValue = coreObject.attribValue(params.attribute);\n\t\t\tconst sortValue = isNumber(attribValue) ? attribValue : 0;\n\t\t\tattribValues[i] = sortValue;\n\t\t\tMapUtils.pushOnArrayAtEntry(objectsByAttribValue, sortValue, coreObject);\n\t\t\ti++;\n\t\t}\n\n\t\t// sort\n\t\tlet sortedValues: number[] = attribValues.sort((a, b) => a - b);\n\t\tif (params.invert) {\n\t\t\tsortedValues.reverse();\n\t\t}\n\n\t\tconst sortedObjects: ObjectContent<CoreObjectType>[] = [];\n\t\tfor (let sortedValue of sortedValues) {\n\t\t\tconst coreObjectsForPosition = objectsByAttribValue.get(sortedValue);\n\t\t\tif (coreObjectsForPosition) {\n\t\t\t\tfor (let coreObjectForPosition of coreObjectsForPosition) {\n\t\t\t\t\tconst object = coreObjectForPosition.object();\n\t\t\t\t\tif (object) {\n\t\t\t\t\t\tsortedObjects.push(object);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcoreGroup.setAllObjects(sortedObjects);\n\t}\n\n\tprivate _sortPoints(coreGroup: CoreGroup, params: SortSopParams) {\n\t\tconst sortMode = SORT_MODES[params.mode];\n\t\tswitch (sortMode) {\n\t\t\tcase SortMode.AXIS:\n\t\t\t\treturn this._sortPointsByAxis(coreGroup, params);\n\t\t\tcase SortMode.RANDOM:\n\t\t\t\treturn this._sortPointsByRandom(coreGroup, params);\n\t\t\tcase SortMode.ATTRIBUTE:\n\t\t\t\treturn this._sortPointsByAttribute(coreGroup, params);\n\t\t}\n\t\tTypeAssert.unreachable(sortMode);\n\t}\n\tprivate _sortPointsByAxis(coreGroup: CoreGroup, params: SortSopParams) {\n\t\tconst objects = coreGroup.threejsObjectsWithGeo();\n\t\tfor (let object of objects) {\n\t\t\tthis._sortPointsForObject(object, params);\n\t\t}\n\t}\n\tprivate _sortPointsByRandom(coreGroup: CoreGroup, params: SortSopParams) {\n\t\tthis.states?.error.set('sorting points in random mode is not yet implemented');\n\t}\n\tprivate _sortPointsByAttribute(coreGroup: CoreGroup, params: SortSopParams) {\n\t\tthis.states?.error.set('sorting points by attribute is not yet implemented');\n\t}\n\n\tprivate _pointPos = new Vector3();\n\tprivate _positions: number[] = [];\n\tprivate _indicesByPos: Map<number, number[]> = new Map();\n\tprivate _indexDest: Map<number, number> = new Map();\n\tprivate _debugActive = false;\n\tprivate _debug(a: any) {\n\t\tif (!this._debugActive) {\n\t\t\treturn;\n\t\t}\n\t}\n\tprivate _sortPointsForObject(object: Object3DWithGeometry, params: SortSopParams) {\n\t\t pointsFromObject(object,_points);\n\n\t\tconst oldIndexAttribute = object.geometry.getIndex();\n\t\tif (!oldIndexAttribute) {\n\t\t\tconsole.warn('geometry cannot be sorted since it has no index');\n\t\t\treturn;\n\t\t}\n\t\tconst oldIndices = oldIndexAttribute.array;\n\n\t\t// reset\n\t\tthis._positions = new Array(_points.length);\n\t\tthis._indicesByPos.clear();\n\t\tthis._indexDest.clear();\n\n\t\t// accumulate axisValue\n\t\tconst axis = AXISES[params.axis];\n\t\tlet axisValue: number = 0;\n\t\tlet i = 0;\n\t\tfor (let point of _points) {\n\t\t\tpoint.position(this._pointPos);\n\t\t\tswitch (axis) {\n\t\t\t\tcase Axis.X: {\n\t\t\t\t\taxisValue = this._pointPos.x;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcase Axis.Y: {\n\t\t\t\t\taxisValue = this._pointPos.y;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcase Axis.Z: {\n\t\t\t\t\taxisValue = this._pointPos.z;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tthis._positions[i] = axisValue;\n\t\t\tMapUtils.pushOnArrayAtEntry(this._indicesByPos, axisValue, point.index());\n\t\t\ti++;\n\t\t}\n\n\t\t// sort\n\t\tlet sortedPositions: number[] = this._positions.sort((a, b) => a - b);\n\t\tif (params.invert) {\n\t\t\tsortedPositions.reverse();\n\t\t}\n\n\t\t// update the index attribute\n\t\tconst newIndices: number[] = new Array(_points.length);\n\t\ti = 0;\n\t\t// const uniqSortedPositions = ArrayUtils.uniq(sortedPositions);\n\t\tfor (let position of sortedPositions) {\n\t\t\tconst indices = this._indicesByPos.get(position);\n\t\t\tif (indices) {\n\t\t\t\tthis._indicesByPos.delete(position);\n\t\t\t\tfor (let index of indices) {\n\t\t\t\t\tnewIndices[i] = index;\n\t\t\t\t\tthis._indexDest.set(index, i);\n\t\t\t\t\ti++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tconst newIndexAttrib = new Array(oldIndices.length);\n\t\tfor (let i = 0; i < oldIndices.length; i++) {\n\t\t\tconst oldIndex = oldIndices[i];\n\t\t\tconst newI = this._indexDest.get(oldIndex);\n\t\t\tnewIndexAttrib[i] = newI;\n\t\t}\n\t\tobject.geometry.setIndex(newIndexAttrib);\n\n\t\t// update every attribute\n\t\tconst corePointClass = corePointClassFactory(object);\n\n\t\tconst attributeNames = corePointClass.attributeNames(object);\n\t\tfor (let attributeName of attributeNames) {\n\t\t\tif (attributeName == 'id') {\n\t\t\t\tthis._debugActive = true;\n\t\t\t}\n\t\t\tconst attribute = object.geometry.getAttribute(attributeName);\n\t\t\tthis._updateAttribute(attribute as BufferAttribute, newIndices);\n\t\t\tthis._debugActive = false;\n\t\t}\n\t}\n\tprivate _updateAttribute(attribute: BufferAttribute, newIndices: number[]) {\n\t\tconst clonedAttribute = attribute.clone();\n\t\tconst srcArray = attribute.array;\n\t\tconst clonedArray = clonedAttribute.array;\n\t\tconst itemSize = clonedAttribute.itemSize;\n\t\tthis._debug(newIndices);\n\t\tfor (let newIndex of newIndices) {\n\t\t\tconst oldIndex = this._indexDest.get(newIndex);\n\t\t\tthis._debug(`${newIndex} -> ${oldIndex}`);\n\t\t\tif (oldIndex != null) {\n\t\t\t\tfor (let i = 0; i < itemSize; i++) {\n\t\t\t\t\tclonedArray[oldIndex * itemSize + i] = srcArray[newIndex * itemSize + i];\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tconsole.warn('no old index found');\n\t\t\t}\n\t\t}\n\t\tattribute.array = clonedArray;\n\t\tattribute.needsUpdate = true;\n\t}\n}\n","import {BaseSopOperation} from './_Base';\nimport {CoreGroup} from '../../../core/geometry/Group';\nimport {IcosahedronGeometry, BufferGeometry, Vector2, Vector3, Box3} from 'three';\nimport {InputCloneMode} from '../../../engine/poly/InputCloneMode';\nimport {isBooleanTrue} from '../../../core/BooleanValue';\nimport {DefaultOperationParams} from '../../../core/operations/_Base';\nimport {ObjectType} from '../../../core/geometry/Constant';\nimport {SphereBuilder} from '../../../core/geometry/builders/SphereBuilder';\nconst tmpBox = new Box3();\nconst tmpSize = new Vector3();\nconst tmpCenter = new Vector3();\ninterface SphereSopParams extends DefaultOperationParams {\n\ttype: number;\n\tradius: number;\n\tresolution: Vector2;\n\topen: boolean;\n\tphiStart: number;\n\tphiLength: number;\n\tthetaStart: number;\n\tthetaLength: number;\n\tdetail: number;\n\tcenter: Vector3;\n\tasLines: boolean;\n}\n\nenum SphereType {\n\tDEFAULT = 'default',\n\tISOCAHEDRON = 'isocahedron',\n}\ntype SphereTypes = {[key in SphereType]: number};\nexport const SPHERE_TYPE: SphereTypes = {\n\tdefault: 0,\n\tisocahedron: 1,\n};\nexport const SPHERE_TYPES: Array<SphereType> = [SphereType.DEFAULT, SphereType.ISOCAHEDRON];\n\nexport class SphereSopOperation extends BaseSopOperation {\n\tstatic override readonly DEFAULT_PARAMS: SphereSopParams = {\n\t\ttype: SPHERE_TYPE.default,\n\t\tradius: 1,\n\t\tresolution: new Vector2(30, 30),\n\t\topen: false,\n\t\tphiStart: 0,\n\t\tphiLength: Math.PI * 2,\n\t\tthetaStart: 0,\n\t\tthetaLength: Math.PI,\n\t\tdetail: 1,\n\t\tcenter: new Vector3(0, 0, 0),\n\t\tasLines: false,\n\t};\n\tstatic override readonly INPUT_CLONED_STATE = InputCloneMode.NEVER;\n\tstatic override type(): Readonly<'sphere'> {\n\t\treturn 'sphere';\n\t}\n\n\toverride cook(inputCoreGroups: CoreGroup[], params: SphereSopParams) {\n\t\tconst coreGroup = inputCoreGroups[0];\n\t\tconst object = coreGroup ? this._cookWithInput(coreGroup, params) : this._cookWithoutInput(params);\n\t\tif (this._node) {\n\t\t\tobject.name = this._node.name();\n\t\t}\n\t\treturn this.createCoreGroupFromObjects([object]);\n\t}\n\tprivate _cookWithoutInput(params: SphereSopParams) {\n\t\tconst geometry = this._createRequiredGeometry(params);\n\t\tgeometry.translate(params.center.x, params.center.y, params.center.z);\n\t\tconst object = this._createSphereObject(geometry, params);\n\t\treturn object;\n\t}\n\tprivate _cookWithInput(coreGroup: CoreGroup, params: SphereSopParams) {\n\t\tcoreGroup.boundingBox(tmpBox);\n\t\ttmpBox.getSize(tmpSize);\n\t\ttmpBox.getCenter(tmpCenter);\n\n\t\tconst geometry = this._createRequiredGeometry(params);\n\t\tgeometry.scale(tmpSize.x, tmpSize.y, tmpSize.z);\n\t\tgeometry.translate(params.center.x, params.center.y, params.center.z);\n\t\tgeometry.translate(tmpCenter.x, tmpCenter.y, tmpCenter.z);\n\t\tconst object = this._createSphereObject(geometry, params);\n\t\treturn object;\n\t}\n\tprivate _createSphereObject(geometry: BufferGeometry, params: SphereSopParams) {\n\t\treturn BaseSopOperation.createObject(geometry, params.asLines ? ObjectType.LINE_SEGMENTS : ObjectType.MESH);\n\t}\n\n\tprivate _createRequiredGeometry(params: SphereSopParams) {\n\t\tif (params.type == SPHERE_TYPE.default) {\n\t\t\treturn this._createDefaultSphere(params);\n\t\t} else {\n\t\t\treturn this._createDefaultIsocahedron(params);\n\t\t}\n\t}\n\n\tprivate _createDefaultSphere(params: SphereSopParams) {\n\t\tconst geometry = isBooleanTrue(params.open)\n\t\t\t? SphereBuilder.create({\n\t\t\t\t\tradius: params.radius,\n\t\t\t\t\twidthSegments: params.resolution.x,\n\t\t\t\t\theightSegments: params.resolution.y,\n\t\t\t\t\tphiStart: params.phiStart,\n\t\t\t\t\tphiLength: params.phiLength,\n\t\t\t\t\tthetaStart: params.thetaStart,\n\t\t\t\t\tthetaLength: params.thetaLength,\n\t\t\t\t\tasLines: params.asLines,\n\t\t\t\t\topen: true,\n\t\t\t  })\n\t\t\t: SphereBuilder.create({\n\t\t\t\t\tradius: params.radius,\n\t\t\t\t\twidthSegments: params.resolution.x,\n\t\t\t\t\theightSegments: params.resolution.y,\n\t\t\t\t\tasLines: params.asLines,\n\t\t\t\t\topen: false,\n\t\t\t  });\n\n\t\t// if (isBooleanTrue(params.asLines)) {\n\t\t// \t// const widthSegments = Math.max( 3, Math.floor( params.resolution.x ) );\n\t\t// \t// const heightSegments = Math.max( 2, Math.floor( params.resolution.y ) );\n\n\t\t// \tconst newIndices: number[] = [];\n\t\t// \t// for ( let iy = 0; iy < heightSegments; iy ++ ) {\n\n\t\t// \t// \tfor ( let ix = 0; ix < widthSegments; ix ++ ) {\n\n\t\t// \t// \t\tconst a = grid[ iy ][ ix + 1 ];\n\t\t// \t// \t\tconst b = grid[ iy ][ ix ];\n\t\t// \t// \t\tconst c = grid[ iy + 1 ][ ix ];\n\t\t// \t// \t\tconst d = grid[ iy + 1 ][ ix + 1 ];\n\n\t\t// \t// \t\tif ( iy !== 0 || thetaStart > 0 ) indices.push( a, b, d );\n\t\t// \t// \t\tif ( iy !== heightSegments - 1 || thetaEnd < Math.PI ) indices.push( b, c, d );\n\n\t\t// \t// \t}\n\n\t\t// \t// }\n\t\t// \t// geometry.setIndex(indices);\n\t\t// \tconst currentIndices: number[] = geometry.getIndex()!.array as number[];\n\t\t// \tconst facesCount = currentIndices.length / 3;\n\t\t// \tfor (let faceIndex = 0; faceIndex < facesCount; faceIndex += 2) {\n\t\t// \t\tconst a = currentIndices[faceIndex];\n\t\t// \t\tconst b = currentIndices[faceIndex + 1];\n\t\t// \t\t// const c = currentIndices[faceIndex+2]\n\t\t// \t\tnewIndices.push(a, b);\n\t\t// \t\t// newIndices.push(a,c)\n\t\t// \t}\n\t\t// }\n\n\t\treturn geometry;\n\t}\n\tprivate _createDefaultIsocahedron(params: SphereSopParams) {\n\t\treturn new IcosahedronGeometry(params.radius, params.detail);\n\t}\n}\n","import {BaseSopOperation} from './_Base';\nimport {CoreGroup} from '../../../core/geometry/Group';\nimport {Float32BufferAttribute, Object3D, Vector3, Mesh, BufferAttribute} from 'three';\nimport {InputCloneMode} from '../../poly/InputCloneMode';\nimport {DefaultOperationParams} from '../../../core/operations/_Base';\nimport {SopType} from '../../poly/registers/nodes/types/Sop';\nimport {Attribute} from '../../../core/geometry/Attribute';\nimport {CoreAttribute} from '../../../core/geometry/Attribute';\nimport {filterThreejsObjectsWithGroup} from '../../../core/geometry/Mask';\n\nexport enum TangentMode {\n\tMESH = 'Normal Maps',\n\tCURVE = 'Curve',\n}\nexport const TANGENT_MODES: TangentMode[] = [TangentMode.MESH, TangentMode.CURVE];\n\ninterface TangentSopParams extends DefaultOperationParams {\n\tgroup: string;\n\tmode: number;\n\tclosed: boolean;\n\ttangentName: string;\n}\nconst tangent = new Vector3();\nconst currentPosition = new Vector3();\nconst nextPosition = new Vector3();\nconst STRIDE = 3;\n\nexport class TangentSopOperation extends BaseSopOperation {\n\tstatic override readonly DEFAULT_PARAMS: TangentSopParams = {\n\t\tgroup: '*',\n\t\tmode: TANGENT_MODES.indexOf(TangentMode.MESH),\n\t\tclosed: false,\n\t\ttangentName: 'tangent',\n\t};\n\tstatic override readonly INPUT_CLONED_STATE = InputCloneMode.FROM_NODE;\n\tstatic override type(): Readonly<SopType.TANGENT> {\n\t\treturn SopType.TANGENT;\n\t}\n\toverride cook(inputCoreGroups: CoreGroup[], params: TangentSopParams) {\n\t\tconst inputCoreGroup = inputCoreGroups[0];\n\n\t\tconst objects = filterThreejsObjectsWithGroup(inputCoreGroup, params);\n\t\treturn this._process(objects, params);\n\t}\n\tprivate _process(objects: Object3D[], params: TangentSopParams) {\n\t\tconst mode = TANGENT_MODES[params.mode];\n\t\tswitch (mode) {\n\t\t\tcase TangentMode.MESH:\n\t\t\t\treturn this._processForMesh(objects, params);\n\t\t\tcase TangentMode.CURVE:\n\t\t\t\treturn this._processForCurve(objects, params);\n\t\t}\n\t}\n\tprivate _processForMesh(objects: Object3D[], params: TangentSopParams) {\n\t\tfor (const object of objects) {\n\t\t\tconst geometry = (object as Mesh).geometry;\n\t\t\tif (geometry) {\n\t\t\t\tgeometry.computeTangents();\n\t\t\t}\n\t\t}\n\t\treturn this.createCoreGroupFromObjects(objects);\n\t}\n\tprivate _processForCurve(objects: Object3D[], params: TangentSopParams) {\n\t\tconst newObjects: Object3D[] = [];\n\n\t\tfor (const object of objects) {\n\t\t\tconst objectWithTangent = this._createTangentForCurve(object, params);\n\t\t\tif (objectWithTangent) {\n\t\t\t\tnewObjects.push(objectWithTangent);\n\t\t\t}\n\t\t}\n\n\t\treturn this.createCoreGroupFromObjects(newObjects);\n\t}\n\n\tprivate _createTangentForCurve(object: Object3D, params: TangentSopParams) {\n\t\tconst {closed} = params;\n\t\tconst tangentName = CoreAttribute.remapName(params.tangentName);\n\n\t\tconst geometry = (object as Mesh).geometry;\n\t\tif (!geometry) {\n\t\t\treturn;\n\t\t}\n\t\tconst positionAttribute = geometry.getAttribute(Attribute.POSITION) as BufferAttribute | undefined;\n\t\tif (!positionAttribute) {\n\t\t\treturn;\n\t\t}\n\t\tconst positionArray = positionAttribute.array;\n\t\tconst pointsCount = positionArray.length / STRIDE;\n\n\t\t// add attribute if not present\n\t\tlet tangentAttribute = geometry.getAttribute(tangentName) as BufferAttribute;\n\t\tif (!tangentAttribute) {\n\t\t\tconst values = new Array(pointsCount * STRIDE).fill(1);\n\t\t\tgeometry.setAttribute(tangentName, new Float32BufferAttribute(values, STRIDE));\n\t\t\ttangentAttribute = geometry.getAttribute(tangentName) as BufferAttribute;\n\t\t}\n\t\tconst tangentArray = tangentAttribute.array;\n\n\t\tfor (let i = 0; i < pointsCount - 1; i++) {\n\t\t\tcurrentPosition.fromArray(positionArray, i * STRIDE);\n\t\t\tnextPosition.fromArray(positionArray, (i + 1) * STRIDE);\n\t\t\ttangent.copy(nextPosition).sub(currentPosition).normalize();\n\t\t\ttangent.toArray(tangentArray, i * STRIDE);\n\t\t}\n\t\t// handle last point separately\n\t\tconst lastIndex = pointsCount - 1;\n\t\tcurrentPosition.fromArray(positionArray, lastIndex * STRIDE);\n\t\tif (closed) {\n\t\t\tnextPosition.fromArray(positionArray, 0);\n\t\t\ttangent.copy(nextPosition).sub(currentPosition).normalize();\n\t\t} else {\n\t\t\tnextPosition.fromArray(positionArray, (lastIndex - 1) * STRIDE);\n\t\t\ttangent.copy(currentPosition).sub(nextPosition).normalize(); // note that it is inverted\n\t\t}\n\t\ttangent.toArray(tangentArray, lastIndex * STRIDE);\n\n\t\treturn object;\n\t}\n}\n","import {BaseSopOperation} from './_Base';\nimport {CoreGroup} from '../../../core/geometry/Group';\nimport {Vector3, CylinderGeometry} from 'three';\nimport {rotateGeometry} from '../../../core/Transform';\nimport {InputCloneMode} from '../../../engine/poly/InputCloneMode';\nimport {isBooleanTrue} from '../../../core/Type';\nimport {DefaultOperationParams} from '../../../core/operations/_Base';\n\nconst DEFAULT_UP = new Vector3(0, 1, 0);\n\ninterface TubeSopParams extends DefaultOperationParams {\n\tsingleRadius: boolean;\n\tradius: number;\n\tradiusTop: number;\n\tradiusBottom: number;\n\theight: number;\n\tsegmentsRadial: number;\n\tsegmentsHeight: number;\n\tcap: boolean;\n\tcenter: Vector3;\n\tdirection: Vector3;\n\topen: boolean;\n\tthetaStart: number;\n\tthetaLength: number;\n}\n\nexport class TubeSopOperation extends BaseSopOperation {\n\tstatic override readonly DEFAULT_PARAMS: TubeSopParams = {\n\t\tsingleRadius: true,\n\t\tradius: 1,\n\t\tradiusTop: 1,\n\t\tradiusBottom: 1,\n\t\theight: 1,\n\t\tsegmentsRadial: 12,\n\t\tsegmentsHeight: 1,\n\t\tcap: true,\n\t\tcenter: new Vector3(0, 0, 0),\n\t\tdirection: new Vector3(0, 0, 1),\n\t\topen: false,\n\t\tthetaStart: 0,\n\t\tthetaLength: Math.PI,\n\t};\n\tstatic override readonly INPUT_CLONED_STATE = InputCloneMode.NEVER;\n\tstatic override type(): Readonly<'tube'> {\n\t\treturn 'tube';\n\t}\n\toverride cook(inputCoreGroups: CoreGroup[], params: TubeSopParams) {\n\t\tconst radiusTop = params.singleRadius ? params.radius : params.radiusTop;\n\t\tconst radiusBottom = params.singleRadius ? params.radius : params.radiusBottom;\n\t\tconst geometry = isBooleanTrue(params.open)\n\t\t\t? new CylinderGeometry(\n\t\t\t\t\tradiusTop,\n\t\t\t\t\tradiusBottom,\n\t\t\t\t\tparams.height,\n\t\t\t\t\tparams.segmentsRadial,\n\t\t\t\t\tparams.segmentsHeight,\n\t\t\t\t\t!isBooleanTrue(params.cap),\n\t\t\t\t\tparams.thetaStart,\n\t\t\t\t\tparams.thetaLength\n\t\t\t  )\n\t\t\t: new CylinderGeometry(\n\t\t\t\t\tradiusTop,\n\t\t\t\t\tradiusBottom,\n\t\t\t\t\tparams.height,\n\t\t\t\t\tparams.segmentsRadial,\n\t\t\t\t\tparams.segmentsHeight,\n\t\t\t\t\t!isBooleanTrue(params.cap)\n\t\t\t  );\n\n\t\trotateGeometry(geometry, DEFAULT_UP, params.direction);\n\t\tgeometry.translate(params.center.x, params.center.y, params.center.z);\n\t\treturn this.createCoreGroupFromGeometry(geometry);\n\t}\n}\n","import {LIBRARY_INSTALL_HINT} from './../common';\nimport {BaseNodeType} from '../../../engine/nodes/_Base';\nimport {Poly} from '../../../engine/Poly';\nimport {CoreBaseLoader, modifyUrl} from '../_Base';\n// @ts-ignore\nimport XAtlas from 'xatlas-web';\nimport {sanitizeUrl} from '../../UrlHelper';\n\n// type MeshId = number;\n// interface MeshInfo {\n// \tpositionOffset: number;\n// \tindexOffset: number;\n// \tnormalOffset: number;\n// \tuvOffset: number;\n// \tmeshId: MeshId;\n// }\n// interface MeshData {\n// \tnewVertexCount: number;\n// \tnewIndexCount: number;\n// \tuvOffset: number;\n// \tindexOffset: number;\n// \toriginalIndexOffset: number;\n// }\n// interface ArraySetter {\n// \tset: (array: ArrayLike<number>, count: number) => void;\n// \tbuffer: ArrayBufferLike;\n// }\n\n// export interface ChartOptions {\n// \tmaxIterations?: number;\n// \tstraightnessWeight?: number;\n// \ttextureSeamWeight?: number;\n// \tuseInputMeshUvs?: boolean;\n// \tmaxChartArea?: number;\n// \tnormalDeviationWeight?: number;\n// \tmaxCost?: number;\n// \troundnessWeight?: number;\n// \tmaxBoundaryLength?: number;\n// \tnormalSeamWeight?: number;\n// \tfixWinding?: boolean;\n// }\n// export interface PackOptions {\n// \tmaxChartSize?: number;\n// \tpadding?: number;\n// \tbilinear?: boolean;\n// \tcreateImage?: boolean;\n// \trotateCharts?: boolean;\n// \trotateChartsToAxis?: boolean;\n// \tblockAlign?: boolean;\n// \tresolution?: number;\n// \tbruteForce?: boolean;\n// \ttexelsPerUnit?: number;\n// }\n\n// interface XAtlasOptions {}\n// export interface XAtlasManager {\n// \tcreateMesh: (vertexCount: number, originalIndexCount: number, test: boolean, test2: boolean) => MeshInfo;\n\n// \tcreateAtlas: () => void;\n// \tgenerateAtlas: (/*chartOptions?: ChartOptions, packOptions?: PackOptions, test?: boolean*/) => void;\n// \taddMesh: () => number;\n// \tgetMeshData: (meshId: MeshId) => MeshData;\n// \tdestroyAtlas: () => void;\n// \tHEAPU16: ArraySetter;\n// \tHEAPF32: ArraySetter;\n// \tHEAPU32: ArraySetter;\n// }\n// interface XAtlasContainer {\n// \tready: XAtlasManager;\n// }\n\n// export const AddMeshStatus = {\n// \tSuccess: 0,\n// \tError: 1,\n// \tIndexOutOfRange: 2,\n// \tInvalidIndexCount: 3,\n// };\n\nexport class XAtlasLoaderHandler extends CoreBaseLoader<string> {\n\t// private static _module: XAtlasContainer | undefined;\n\t// private static _wasmUrl: string | undefined;\n\n\t// public static async xatlas(node: BaseNodeType) {\n\t// \tif (!this._module) {\n\t// \t\tawait this._loadWasm({}, node);\n\t// \t\t// const wasmurl = new URL('./UvUnwrap/xatlas-web.wasm', import.meta.url);\n\t// \t\t// const wasmurl = new URL('../../../../node_modules/xatlas-web/dist/xatlas-web.wasm', import.meta.url);\n\t// \t\t// const wasmurl = new URL('xatlas-web/dist/xatlas-web.wasm', import.meta.url);\n\t// \t\tthis._module = XAtlas({\n\t// \t\t\tlocateFile: (path: string) => {\n\t// \t\t\t\tif (path.endsWith('.wasm')) {\n\t// \t\t\t\t\treturn this._wasmUrl;\n\t// \t\t\t\t}\n\t// \t\t\t\treturn path;\n\t// \t\t\t},\n\t// \t\t});\n\t// \t}\n\t// \treturn this._module ? this._module.ready : undefined;\n\t// }\n\n\tstatic async loadWasm(node: BaseNodeType) {\n\t\tconst root = Poly.libs.root();\n\t\tconst XATLASPath = Poly.libs.XATLASPath();\n\t\tif (root || XATLASPath) {\n\t\t\tconst decoderPath = sanitizeUrl(`${root || ''}${XATLASPath || ''}/`);\n\n\t\t\tconst fileNames: string[] = ['xatlas.wasm', 'xatlas.js'];\n\t\t\tconst fullUrls = fileNames.map((fileName) => {\n\t\t\t\treturn {\n\t\t\t\t\tfullUrl: `${decoderPath}${fileName}`,\n\t\t\t\t};\n\t\t\t});\n\t\t\tawait this._loadMultipleUrlsGlobal({\n\t\t\t\tfiles: fullUrls,\n\t\t\t\tnode,\n\t\t\t\terror: `failed to load xatlas libraries. Make sure to install them use the uvUnwrap (${LIBRARY_INSTALL_HINT})`,\n\t\t\t});\n\t\t\t// await Poly.blobs.fetchBlobForNode({\n\t\t\t// \tfullUrl,\n\t\t\t// \tnode: node,\n\t\t\t// \tmultiAssetsForNode: false,\n\t\t\t// });\n\n\t\t\t// this._wasmUrl = modifyUrl(fullUrl);\n\t\t\tconst _addOrigin = (url: string) => {\n\t\t\t\t// it seems that if we do not have the origin, the wasm file is not found\n\t\t\t\tif (!url.startsWith('http')) {\n\t\t\t\t\treturn `${window.location.origin}/${url}`;\n\t\t\t\t}\n\t\t\t\treturn url;\n\t\t\t};\n\t\t\treturn {\n\t\t\t\twasm: _addOrigin(modifyUrl(fullUrls[0].fullUrl)),\n\t\t\t\tjs: _addOrigin(modifyUrl(fullUrls[1].fullUrl)),\n\t\t\t};\n\t\t}\n\t}\n}\n","import {BaseSopOperation} from './_Base';\nimport {CoreGroup} from '../../../core/geometry/Group';\nimport {InputCloneMode} from '../../poly/InputCloneMode';\nimport {SopType} from '../../poly/registers/nodes/types/Sop';\nimport {BufferAttribute, Mesh, Float32BufferAttribute, Vector3, Line3} from 'three';\nimport {DefaultOperationParams} from '../../../core/operations/_Base';\nimport {XAtlasLoaderHandler} from '../../../core/loader/geometry/XAtlas';\nimport {TypeAssert} from '../../poly/Assert';\nimport {Potpack, PotPackBox, PotPackBoxResult} from '../../../core/libs/Potpack';\nimport {LIBRARY_INSTALL_HINT} from '../../../core/loader/common';\nimport {DEFAULT_UV_LIGHT_MAP_ATTRIB_NAME} from '../../nodes/cop/utils/lightMap/LightMapMaterial';\nimport {UVUnwrapper} from 'xatlas-three';\n// import { PolyEngine } from '../../Poly';\n// import {UV_LIGHT_MAP_FLIPPED_ATTRIB_NAME} from '../../nodes/cop/utils/lightMap/LightMapMaterial';\n\nexport enum UvUnwrapMethod {\n\tPOTPACK = 'potpack',\n\tXATLAS = 'xatlas',\n\t// XATLAS_2 = 'xatlas 2',\n}\nexport const UV_UNWRAP_METHODS: UvUnwrapMethod[] = [\n\tUvUnwrapMethod.XATLAS,\n\t// UvUnwrapMethod.XATLAS_2,\n\tUvUnwrapMethod.POTPACK,\n];\n\ninterface UvUnwrapSopParams extends DefaultOperationParams {\n\tmethod: number;\n\tuv: string;\n\tresolution: number;\n\tpadding: number;\n}\n\nconst v1 = new Vector3();\nconst v2 = new Vector3();\nconst v3 = new Vector3();\nconst vMid = new Vector3();\nconst vEnd = new Vector3();\nconst line = new Line3();\n// const _uvTriangle = new Triangle();\n// const _uvTriangleN = new Vector3();\n\nexport class UvUnwrapSopOperation extends BaseSopOperation {\n\tstatic override readonly DEFAULT_PARAMS: UvUnwrapSopParams = {\n\t\tmethod: UV_UNWRAP_METHODS.indexOf(UvUnwrapMethod.XATLAS),\n\t\tuv: DEFAULT_UV_LIGHT_MAP_ATTRIB_NAME,\n\t\tresolution: 2048,\n\t\tpadding: 4,\n\t};\n\tstatic override readonly INPUT_CLONED_STATE = InputCloneMode.FROM_NODE;\n\tstatic override type(): Readonly<SopType.UV_UNWRAP> {\n\t\treturn SopType.UV_UNWRAP;\n\t}\n\n\toverride async cook(inputCoreGroups: CoreGroup[], params: UvUnwrapSopParams) {\n\t\tconst method = UV_UNWRAP_METHODS[params.method];\n\t\tswitch (method) {\n\t\t\tcase UvUnwrapMethod.XATLAS: {\n\t\t\t\t// return await this._unwrapMeshUVsWithXAtlas(inputCoreGroups, params);\n\t\t\t\treturn await this._unwrapMeshUVsWithXAtlas2(inputCoreGroups, params);\n\t\t\t}\n\t\t\t// case UvUnwrapMethod.XATLAS_2: {\n\t\t\t// \treturn await this._unwrapMeshUVsWithXAtlas2(inputCoreGroups, params);\n\t\t\t// }\n\t\t\tcase UvUnwrapMethod.POTPACK: {\n\t\t\t\treturn this._unwrapMeshUVsWithPotpack(inputCoreGroups, params);\n\t\t\t}\n\t\t}\n\t\tTypeAssert.unreachable(method);\n\t}\n\tprivate async _unwrapMeshUVsWithXAtlas2(inputCoreGroups: CoreGroup[], params: UvUnwrapSopParams) {\n\t\tconst coreGroup = inputCoreGroups[0];\n\t\tconst unwrapper = new UVUnwrapper({BufferAttribute: BufferAttribute});\n\t\tunwrapper.chartOptions = {\n\t\t\tfixWinding: false,\n\t\t\tmaxBoundaryLength: 0,\n\t\t\tmaxChartArea: 0,\n\t\t\tmaxCost: 2,\n\t\t\tmaxIterations: 1,\n\t\t\tnormalDeviationWeight: 2,\n\t\t\tnormalSeamWeight: 4,\n\t\t\troundnessWeight: 0.009999999776482582,\n\t\t\tstraightnessWeight: 6,\n\t\t\ttextureSeamWeight: 0.5,\n\t\t\tuseInputMeshUvs: false,\n\t\t};\n\t\tunwrapper.packOptions = {\n\t\t\tbilinear: true,\n\t\t\tblockAlign: true,\n\t\t\tbruteForce: false,\n\t\t\tcreateImage: false,\n\t\t\tmaxChartSize: 0,\n\t\t\tpadding: params.padding,\n\t\t\tresolution: params.resolution,\n\t\t\trotateCharts: true,\n\t\t\trotateChartsToAxis: true,\n\t\t\ttexelsPerUnit: 0,\n\t\t};\n\t\tif (!this._node) {\n\t\t\tthis.states?.error.set('no node');\n\t\t\treturn coreGroup;\n\t\t}\n\n\t\tconst xatlasData = await XAtlasLoaderHandler.loadWasm(this._node);\n\t\tif (!xatlasData) {\n\t\t\tthis.states?.error.set(`failed to load xatlas. Make sure this is installed. ${LIBRARY_INSTALL_HINT}`);\n\t\t\treturn coreGroup;\n\t\t}\n\n\t\tawait unwrapper.loadLibrary(\n\t\t\t(mode, progress) => {\n\t\t\t\t// console.log(mode, progress);\n\t\t\t},\n\t\t\txatlasData.wasm, //'https://cdn.jsdelivr.net/npm/xatlasjs@0.1.0/dist/xatlas.wasm',\n\t\t\txatlasData.js //'https://cdn.jsdelivr.net/npm/xatlasjs@0.1.0/dist/xatlas.js'\n\t\t); // Make sure to wait for the library to load before unwrapping.\n\n\t\tconst objects = coreGroup.threejsObjectsWithGeo();\n\t\tfor (let object of objects) {\n\t\t\tconst mesh = object as Mesh;\n\t\t\tif (mesh.isMesh) {\n\t\t\t\t// unwrapper.useNormals = true;\n\t\t\t\t// const res = await unwrapper.unwrapGeometry(mesh.geometry);\n\t\t\t\t// mesh.geometry = res[0];\n\t\t\t\t// unwrapper.(mesh.geometry);\n\t\t\t\tawait unwrapper.packAtlas([mesh.geometry], params.uv as 'uv');\n\t\t\t}\n\t\t}\n\n\t\treturn coreGroup;\n\t}\n\n\t// private async _unwrapMeshUVsWithXAtlas(inputCoreGroups: CoreGroup[], params: UvUnwrapSopParams) {\n\t// \tconst coreGroup = inputCoreGroups[0];\n\t// \tif (!this._node) {\n\t// \t\treturn coreGroup;\n\t// \t}\n\t// \tconst xatlas = await XAtlasLoaderHandler.xatlas(this._node);\n\t// \tif (!xatlas) {\n\t// \t\tthis.states?.error.set(`failed to load xatlas. Make sure this is installed. ${LIBRARY_INSTALL_HINT}`);\n\t// \t\treturn coreGroup;\n\t// \t}\n\n\t// \tconst objects = coreGroup.threejsObjectsWithGeo();\n\t// \tfor (let object of objects) {\n\t// \t\tconst mesh = object as Mesh;\n\t// \t\tif (mesh.isMesh) {\n\t// \t\t\tthis._unwrapMeshUVsWithAtlas(xatlas, mesh, params);\n\t// \t\t}\n\t// \t}\n\n\t// \treturn coreGroup;\n\t// }\n\n\t// private _unwrapMeshUVsWithAtlas(xatlas: XAtlasManager, mesh: Mesh, params: UvUnwrapSopParams) {\n\t// \tconst geometry = mesh.geometry;\n\t// \tif (!geometry.index) {\n\t// \t\treturn;\n\t// \t}\n\n\t// \tconst originalVertexCount = geometry.attributes.position.count;\n\t// \tconst originalIndexCount = geometry.index.count;\n\n\t// \ttry {\n\t// \t\txatlas.createAtlas();\n\t// \t} catch (err) {\n\t// \t\tthis._node?.states.error.set('failed to create atlas');\n\t// \t\treturn;\n\t// \t}\n\n\t// \tconst meshInfo = xatlas.createMesh(originalVertexCount, originalIndexCount, true, true);\n\t// \tconst index = geometry.getIndex();\n\t// \tconst positionAttrib = geometry.getAttribute(Attribute.POSITION);\n\t// \tconst normalAttrib = geometry.getAttribute(Attribute.NORMAL);\n\t// \tconst uvAttrib = geometry.getAttribute(Attribute.UV);\n\t// \tif (!(index && positionAttrib && normalAttrib && uvAttrib)) {\n\t// \t\tthis.states?.error.set(`the geometry needs to have an index, position, normal and uv attributes`);\n\t// \t\treturn;\n\t// \t}\n\t// \txatlas.HEAPU16.set(geometry.index.array, meshInfo.indexOffset / Uint16Array.BYTES_PER_ELEMENT);\n\t// \txatlas.HEAPF32.set(\n\t// \t\t(geometry.attributes.position as BufferAttribute).array,\n\t// \t\tmeshInfo.positionOffset / Float32Array.BYTES_PER_ELEMENT\n\t// \t);\n\t// \txatlas.HEAPF32.set(\n\t// \t\t(geometry.attributes.normal as BufferAttribute).array,\n\t// \t\tmeshInfo.normalOffset / Float32Array.BYTES_PER_ELEMENT\n\t// \t);\n\t// \txatlas.HEAPF32.set(\n\t// \t\t(geometry.attributes.uv as BufferAttribute).array,\n\t// \t\tmeshInfo.uvOffset / Float32Array.BYTES_PER_ELEMENT\n\t// \t);\n\n\t// \tconst statusCode = xatlas.addMesh();\n\t// \tif (statusCode !== AddMeshStatus.Success) {\n\t// \t\tthrow new Error(`UVUnwrapper: Error adding mesh. Status code ${statusCode}`);\n\t// \t}\n\t// \t// const chartOptions: ChartOptions = {\n\t// \t// \tfixWinding: true,\n\t// \t// \tmaxBoundaryLength: 0,\n\t// \t// \tmaxChartArea: 0,\n\t// \t// \tmaxCost: 2,\n\t// \t// \tmaxIterations: 1,\n\t// \t// \tnormalDeviationWeight: 2,\n\t// \t// \tnormalSeamWeight: 4,\n\t// \t// \troundnessWeight: 0.009999999776482582,\n\t// \t// \tstraightnessWeight: 6,\n\t// \t// \ttextureSeamWeight: 0.5,\n\t// \t// \tuseInputMeshUvs: false,\n\t// \t// };\n\t// \t// const packOptions: PackOptions = {\n\t// \t// \tbilinear: true,\n\t// \t// \tblockAlign: false,\n\t// \t// \tbruteForce: false,\n\t// \t// \tcreateImage: false,\n\t// \t// \tmaxChartSize: 0,\n\t// \t// \tpadding: 0,\n\t// \t// \tresolution: 0,\n\t// \t// \trotateCharts: true,\n\t// \t// \trotateChartsToAxis: true,\n\t// \t// \ttexelsPerUnit: 0,\n\t// \t// };\n\t// \t// console.log({chartOptions, packOptions});\n\n\t// \ttry {\n\t// \t\txatlas.generateAtlas();\n\t// \t} catch (err) {\n\t// \t\tthis._node?.states.error.set('failed to generate atlas');\n\t// \t\tconsole.log(err);\n\t// \t\treturn;\n\t// \t}\n\n\t// \tconst meshData = xatlas.getMeshData(meshInfo.meshId);\n\t// \tconst oldPositionArray = (geometry.attributes.position as BufferAttribute).array;\n\t// \tconst oldNormalArray = (geometry.attributes.normal as BufferAttribute).array;\n\t// \tconst oldUvArray = (geometry.attributes.uv as BufferAttribute).array;\n\t// \tconst newPositionArray = new Float32Array(meshData.newVertexCount * 3);\n\t// \tconst newNormalArray = new Float32Array(meshData.newVertexCount * 3);\n\t// \tconst newUvArray = new Float32Array(meshData.newVertexCount * 2);\n\t// \tconst newUv2Array = new Float32Array(xatlas.HEAPF32.buffer, meshData.uvOffset, meshData.newVertexCount * 2);\n\t// \tconst newIndexArray = new Uint32Array(xatlas.HEAPU32.buffer, meshData.indexOffset, meshData.newIndexCount);\n\t// \tconst originalIndexArray = new Uint32Array(\n\t// \t\txatlas.HEAPU32.buffer,\n\t// \t\tmeshData.originalIndexOffset,\n\t// \t\tmeshData.newVertexCount\n\t// \t);\n\n\t// \tfor (let i = 0; i < meshData.newVertexCount; i++) {\n\t// \t\tconst originalIndex = originalIndexArray[i];\n\t// \t\t// P\n\t// \t\tnewPositionArray[i * 3] = oldPositionArray[originalIndex * 3];\n\t// \t\tnewPositionArray[i * 3 + 1] = oldPositionArray[originalIndex * 3 + 1];\n\t// \t\tnewPositionArray[i * 3 + 2] = oldPositionArray[originalIndex * 3 + 2];\n\t// \t\t// N\n\t// \t\tnewNormalArray[i * 3] = oldNormalArray[originalIndex * 3];\n\t// \t\tnewNormalArray[i * 3 + 1] = oldNormalArray[originalIndex * 3 + 1];\n\t// \t\tnewNormalArray[i * 3 + 2] = oldNormalArray[originalIndex * 3 + 2];\n\t// \t\t// uv\n\t// \t\tnewUvArray[i * 2] = oldUvArray[originalIndex * 2];\n\t// \t\tnewUvArray[i * 2 + 1] = oldUvArray[originalIndex * 2 + 1];\n\t// \t}\n\t// \t// check inverted uvs (which face toward -z when set onto P)\n\t// \t// const pointsCount = newPositionArray.length / 3;\n\t// \t// const polyCount = newIndexArray.length / 3;\n\t// \t// const maxI = polyCount * 3;\n\t// \t// const uvLightmapFlipped: number[] = new Array(newPositionArray.length / 3).fill(-1);\n\t// \t// for (let i = 0; i < maxI; i += 3) {\n\t// \t// \tconst i0 = newIndexArray[i];\n\t// \t// \tconst i1 = newIndexArray[i + 1];\n\t// \t// \tconst i2 = newIndexArray[i + 2];\n\t// \t// \t_uvTriangle.a.set(newUv2Array[i0 * 2], newUv2Array[i0 * 2 + 1], 0);\n\t// \t// \t_uvTriangle.b.set(newUv2Array[i1 * 2], newUv2Array[i1 * 2 + 1], 0);\n\t// \t// \t_uvTriangle.c.set(newUv2Array[i2 * 2], newUv2Array[i2 * 2 + 1], 0);\n\t// \t// \t_uvTriangle.getNormal(_uvTriangleN);\n\t// \t// \tconst flipped = _uvTriangleN.z < 0 ? 1 : 0;\n\t// \t// \t// if (flipped) {\n\t// \t// \t// \t// newIndexArray[i] = i2;\n\t// \t// \t// \t// newIndexArray[i + 2] = i0;\n\t// \t// \t// \t// newUv2Array[i0 * 2] = _uvTriangle.c.x;\n\t// \t// \t// \t// newUv2Array[i0 * 2 + 1] = _uvTriangle.c.y;\n\t// \t// \t// \t// newUv2Array[i2 * 2] = _uvTriangle.a.x;\n\t// \t// \t// \t// newUv2Array[i2 * 2 + 1] = _uvTriangle.a.y;\n\t// \t// \t// }\n\t// \t// \tuvLightmapFlipped[i0] = flipped;\n\t// \t// \tuvLightmapFlipped[i1] = flipped;\n\t// \t// \tuvLightmapFlipped[i2] = flipped;\n\t// \t// \t// if (_uvTriangleN.z < 0) {\n\t// \t// \t// \tnewNormalArray[i] *= -1;\n\t// \t// \t// \tnewNormalArray[i + 1] *= -1;\n\t// \t// \t// \tnewNormalArray[i + 2] *= -1;\n\t// \t// \t// }\n\t// \t// }\n\t// \t// for (let i = 0; i < pointsCount; i++) {\n\t// \t// \tconst flipped = uvFlip[i];\n\t// \t// \tconsole.log(i, flipped);\n\t// \t// \tnewNormalArray[i * 3] *= flipped;\n\t// \t// \tnewNormalArray[i * 3 + 1] *= flipped;\n\t// \t// \tnewNormalArray[i * 3 + 2] *= flipped;\n\t// \t// }\n\n\t// \t// create geo\n\t// \tconst newGeometry = new BufferGeometry();\n\t// \tnewGeometry.setAttribute('position', new Float32BufferAttribute(newPositionArray, 3));\n\t// \tnewGeometry.setAttribute('normal', new Float32BufferAttribute(newNormalArray, 3));\n\t// \tif (params.uv != Attribute.UV) {\n\t// \t\tnewGeometry.setAttribute('uv', new Float32BufferAttribute(newUvArray, 2));\n\t// \t}\n\t// \tnewGeometry.setAttribute(params.uv, new Float32BufferAttribute(newUv2Array, 2));\n\t// \t// newGeometry.setAttribute(UV_LIGHT_MAP_FLIPPED_ATTRIB_NAME, new Float32BufferAttribute(uvLightmapFlipped, 1));\n\t// \tnewGeometry.setIndex(new Uint32BufferAttribute(newIndexArray, 1));\n\n\t// \tmesh.geometry = newGeometry;\n\n\t// \txatlas.destroyAtlas();\n\t// }\n\n\tprivate _unwrapMeshUVsWithPotpack(inputCoreGroups: CoreGroup[], params: UvUnwrapSopParams) {\n\t\tconst coreGroup = inputCoreGroups[0];\n\n\t\tconst objects = coreGroup.threejsObjectsWithGeo();\n\t\tfor (let object of objects) {\n\t\t\tconst mesh = object as Mesh;\n\t\t\tif (mesh.isMesh) {\n\t\t\t\tthis._unwrapUVsWithPotpack(mesh, params);\n\t\t\t}\n\t\t}\n\n\t\treturn coreGroup;\n\t}\n\n\t// TODO: at the moment each polygon will fix a single box\n\t// when ideally this should find when 2 triangles form a quad or square\n\t// and could then fit in the box\n\tprivate _unwrapUVsWithPotpack(mesh: Mesh, params: UvUnwrapSopParams) {\n\t\tconst geometry = mesh.geometry;\n\t\tconst indexArray = geometry.getIndex()?.array;\n\t\tif (!indexArray) {\n\t\t\treturn;\n\t\t}\n\t\tconst positionArray = (geometry.attributes.position as BufferAttribute)?.array;\n\t\tif (!positionArray) {\n\t\t\treturn;\n\t\t}\n\t\tconst uvArray = (geometry.attributes['uv'] as BufferAttribute)?.array;\n\t\tif (!uvArray) {\n\t\t\treturn;\n\t\t}\n\t\tconst polyCount = indexArray.length / 3;\n\t\tconst boxes: PotPackBox[] = new Array(polyCount);\n\t\tfor (let i = 0; i < polyCount; i++) {\n\t\t\t// this take one edge (v1-v2) of the polygon and calculate its length (w)\n\t\t\t// then we measure the distance between the mid point of that edge (vMid)\n\t\t\t// and its projection again an edge parallel to the first edge (v1-v2), but going through v3.\n\t\t\tv1.fromArray(positionArray, 3 * indexArray[3 * i + 0]);\n\t\t\tv2.fromArray(positionArray, 3 * indexArray[3 * i + 1]);\n\t\t\tv3.fromArray(positionArray, 3 * indexArray[3 * i + 2]);\n\t\t\tlet w = v1.distanceTo(v2);\n\t\t\tvMid.copy(v1).add(v2).multiplyScalar(0.5);\n\t\t\tline.start.copy(v3);\n\t\t\tline.end.copy(v3).add(v2).sub(v1);\n\t\t\tline.closestPointToPoint(vMid, false, vEnd);\n\t\t\tlet h = vMid.distanceTo(vEnd);\n\n\t\t\t// we try and get some order to that by\n\t\t\t// always having h and sorted\n\t\t\tif (h < w) {\n\t\t\t\tconst tmp = h;\n\t\t\t\th = w;\n\t\t\t\tw = tmp;\n\t\t\t}\n\n\t\t\tboxes[i] = {w, h};\n\t\t}\n\n\t\tconst result = Potpack(boxes);\n\t\tconst newUvValues = new Array(uvArray.length);\n\t\t// function setnewValue(index: number, newValue: number) {\n\t\t// \t// if (newUvValues[index] == null) {\n\t\t// \tnewUvValues[index] = newValue;\n\t\t// \t// } else {\n\t\t// \t// \tif (newUvValues[index] <= newValue) {\n\t\t// \t// \t\tnewUvValues[index] = newValue;\n\t\t// \t// \t} else {\n\t\t// \t// \t\tconsole.log(`${index} already has ${newUvValues[index]}, cannot be set to ${newValue}`);\n\t\t// \t// \t}\n\t\t// \t// }\n\t\t// }\n\t\tfor (let i = 0; i < polyCount; i++) {\n\t\t\tconst box = boxes[i] as PotPackBoxResult;\n\t\t\tconst x = box.x / result.w;\n\t\t\tconst y = box.y / result.h;\n\t\t\tconst w = box.w / result.w;\n\t\t\tconst h = box.h / result.h;\n\t\t\tconst index0 = 2 * indexArray[i * 3 + 0];\n\t\t\tconst index1 = 2 * indexArray[i * 3 + 1];\n\t\t\tconst index2 = 2 * indexArray[i * 3 + 2];\n\n\t\t\tnewUvValues[index0] = x;\n\t\t\tnewUvValues[index0 + 1] = y;\n\t\t\tnewUvValues[index1] = x + w;\n\t\t\tnewUvValues[index1 + 1] = y;\n\t\t\tnewUvValues[index2] = x;\n\t\t\tnewUvValues[index2 + 1] = y + h;\n\t\t}\n\t\tgeometry.setAttribute(params.uv, new Float32BufferAttribute(newUvValues, 2));\n\t}\n}\n","export default \"#include <common>\\n\\nuniform vec2 resolution;\\n\\n// INSERT DEFINE\\n\\nvoid main() {\\n\\n\\tvec4 diffuseColor = vec4(0.0,0.0,0.0,1.0);\\n\\n\\n\\t// INSERT BODY\\n\\n\\tgl_FragColor = vec4( diffuseColor );\\n}\"","export default \"void main()\\t{\\n\\tgl_Position = vec4( position, 1.0 );\\n}\"","export default \"// from https://github.com/williammalo/hsluv-glsl\\n/*\\nHSLUV-GLSL v4.2\\nHSLUV is a human-friendly alternative to HSL. ( http://www.hsluv.org )\\nGLSL port by William Malo ( https://github.com/williammalo )\\nPut this code in your fragment shader.\\n*/\\n\\nvec3 hsluv_intersectLineLine(vec3 line1x, vec3 line1y, vec3 line2x, vec3 line2y) {\\n\\treturn (line1y - line2y) / (line2x - line1x);\\n}\\n\\nvec3 hsluv_distanceFromPole(vec3 pointx,vec3 pointy) {\\n\\treturn sqrt(pointx*pointx + pointy*pointy);\\n}\\n\\nvec3 hsluv_lengthOfRayUntilIntersect(float theta, vec3 x, vec3 y) {\\n\\tvec3 len = y / (sin(theta) - x * cos(theta));\\n\\tif (len.r < 0.0) {len.r=1000.0;}\\n\\tif (len.g < 0.0) {len.g=1000.0;}\\n\\tif (len.b < 0.0) {len.b=1000.0;}\\n\\treturn len;\\n}\\n\\nfloat hsluv_maxSafeChromaForL(float L){\\n\\tmat3 m2 = mat3(\\n\\t\\t 3.2409699419045214  ,-0.96924363628087983 , 0.055630079696993609,\\n\\t\\t-1.5373831775700935  , 1.8759675015077207  ,-0.20397695888897657 ,\\n\\t\\t-0.49861076029300328 , 0.041555057407175613, 1.0569715142428786  \\n\\t);\\n\\tfloat sub0 = L + 16.0;\\n\\tfloat sub1 = sub0 * sub0 * sub0 * .000000641;\\n\\tfloat sub2 = sub1 > 0.0088564516790356308 ? sub1 : L / 903.2962962962963;\\n\\n\\tvec3 top1   = (284517.0 * m2[0] - 94839.0  * m2[2]) * sub2;\\n\\tvec3 bottom = (632260.0 * m2[2] - 126452.0 * m2[1]) * sub2;\\n\\tvec3 top2   = (838422.0 * m2[2] + 769860.0 * m2[1] + 731718.0 * m2[0]) * L * sub2;\\n\\n\\tvec3 bounds0x = top1 / bottom;\\n\\tvec3 bounds0y = top2 / bottom;\\n\\n\\tvec3 bounds1x =              top1 / (bottom+126452.0);\\n\\tvec3 bounds1y = (top2-769860.0*L) / (bottom+126452.0);\\n\\n\\tvec3 xs0 = hsluv_intersectLineLine(bounds0x, bounds0y, -1.0/bounds0x, vec3(0.0) );\\n\\tvec3 xs1 = hsluv_intersectLineLine(bounds1x, bounds1y, -1.0/bounds1x, vec3(0.0) );\\n\\n\\tvec3 lengths0 = hsluv_distanceFromPole( xs0, bounds0y + xs0 * bounds0x );\\n\\tvec3 lengths1 = hsluv_distanceFromPole( xs1, bounds1y + xs1 * bounds1x );\\n\\n\\treturn  min(lengths0.r,\\n\\t\\t\\tmin(lengths1.r,\\n\\t\\t\\tmin(lengths0.g,\\n\\t\\t\\tmin(lengths1.g,\\n\\t\\t\\tmin(lengths0.b,\\n\\t\\t\\t\\tlengths1.b)))));\\n}\\n\\nfloat hsluv_maxChromaForLH(float L, float H) {\\n\\n\\tfloat hrad = radians(H);\\n\\n\\tmat3 m2 = mat3(\\n\\t\\t 3.2409699419045214  ,-0.96924363628087983 , 0.055630079696993609,\\n\\t\\t-1.5373831775700935  , 1.8759675015077207  ,-0.20397695888897657 ,\\n\\t\\t-0.49861076029300328 , 0.041555057407175613, 1.0569715142428786  \\n\\t);\\n\\tfloat sub1 = pow(L + 16.0, 3.0) / 1560896.0;\\n\\tfloat sub2 = sub1 > 0.0088564516790356308 ? sub1 : L / 903.2962962962963;\\n\\n\\tvec3 top1   = (284517.0 * m2[0] - 94839.0  * m2[2]) * sub2;\\n\\tvec3 bottom = (632260.0 * m2[2] - 126452.0 * m2[1]) * sub2;\\n\\tvec3 top2   = (838422.0 * m2[2] + 769860.0 * m2[1] + 731718.0 * m2[0]) * L * sub2;\\n\\n\\tvec3 bound0x = top1 / bottom;\\n\\tvec3 bound0y = top2 / bottom;\\n\\n\\tvec3 bound1x =              top1 / (bottom+126452.0);\\n\\tvec3 bound1y = (top2-769860.0*L) / (bottom+126452.0);\\n\\n\\tvec3 lengths0 = hsluv_lengthOfRayUntilIntersect(hrad, bound0x, bound0y );\\n\\tvec3 lengths1 = hsluv_lengthOfRayUntilIntersect(hrad, bound1x, bound1y );\\n\\n\\treturn  min(lengths0.r,\\n\\t\\t\\tmin(lengths1.r,\\n\\t\\t\\tmin(lengths0.g,\\n\\t\\t\\tmin(lengths1.g,\\n\\t\\t\\tmin(lengths0.b,\\n\\t\\t\\t\\tlengths1.b)))));\\n}\\n\\nfloat hsluv_fromLinear(float c) {\\n\\treturn c <= 0.0031308 ? 12.92 * c : 1.055 * pow(c, 1.0 / 2.4) - 0.055;\\n}\\nvec3 hsluv_fromLinear(vec3 c) {\\n\\treturn vec3( hsluv_fromLinear(c.r), hsluv_fromLinear(c.g), hsluv_fromLinear(c.b) );\\n}\\n\\nfloat hsluv_toLinear(float c) {\\n\\treturn c > 0.04045 ? pow((c + 0.055) / (1.0 + 0.055), 2.4) : c / 12.92;\\n}\\n\\nvec3 hsluv_toLinear(vec3 c) {\\n\\treturn vec3( hsluv_toLinear(c.r), hsluv_toLinear(c.g), hsluv_toLinear(c.b) );\\n}\\n\\nfloat hsluv_yToL(float Y){\\n\\treturn Y <= 0.0088564516790356308 ? Y * 903.2962962962963 : 116.0 * pow(Y, 1.0 / 3.0) - 16.0;\\n}\\n\\nfloat hsluv_lToY(float L) {\\n\\treturn L <= 8.0 ? L / 903.2962962962963 : pow((L + 16.0) / 116.0, 3.0);\\n}\\n\\nvec3 xyzToRgb(vec3 tuple) {\\n\\tconst mat3 m = mat3( \\n\\t\\t3.2409699419045214  ,-1.5373831775700935 ,-0.49861076029300328 ,\\n\\t\\t-0.96924363628087983 , 1.8759675015077207 , 0.041555057407175613,\\n\\t\\t0.055630079696993609,-0.20397695888897657, 1.0569715142428786  );\\n\\t\\n\\treturn hsluv_fromLinear(tuple*m);\\n}\\n\\nvec3 rgbToXyz(vec3 tuple) {\\n\\tconst mat3 m = mat3(\\n\\t\\t0.41239079926595948 , 0.35758433938387796, 0.18048078840183429 ,\\n\\t\\t0.21263900587151036 , 0.71516867876775593, 0.072192315360733715,\\n\\t\\t0.019330818715591851, 0.11919477979462599, 0.95053215224966058 \\n\\t);\\n\\treturn hsluv_toLinear(tuple) * m;\\n}\\n\\nvec3 xyzToLuv(vec3 tuple){\\n\\tfloat X = tuple.x;\\n\\tfloat Y = tuple.y;\\n\\tfloat Z = tuple.z;\\n\\n\\tfloat L = hsluv_yToL(Y);\\n\\t\\n\\tfloat div = 1./dot(tuple,vec3(1,15,3)); \\n\\n\\treturn vec3(\\n\\t\\t1.,\\n\\t\\t(52. * (X*div) - 2.57179),\\n\\t\\t(117.* (Y*div) - 6.08816)\\n\\t) * L;\\n}\\n\\n\\nvec3 luvToXyz(vec3 tuple) {\\n\\tfloat L = tuple.x;\\n\\n\\tfloat U = tuple.y / (13.0 * L) + 0.19783000664283681;\\n\\tfloat V = tuple.z / (13.0 * L) + 0.468319994938791;\\n\\n\\tfloat Y = hsluv_lToY(L);\\n\\tfloat X = 2.25 * U * Y / V;\\n\\tfloat Z = (3./V - 5.)*Y - (X/3.);\\n\\n\\treturn vec3(X, Y, Z);\\n}\\n\\nvec3 luvToLch(vec3 tuple) {\\n\\tfloat L = tuple.x;\\n\\tfloat U = tuple.y;\\n\\tfloat V = tuple.z;\\n\\n\\tfloat C = length(tuple.yz);\\n\\tfloat H = degrees(atan(V,U));\\n\\tif (H < 0.0) {\\n\\t\\tH = 360.0 + H;\\n\\t}\\n\\t\\n\\treturn vec3(L, C, H);\\n}\\n\\nvec3 lchToLuv(vec3 tuple) {\\n\\tfloat hrad = radians(tuple.b);\\n\\treturn vec3(\\n\\t\\ttuple.r,\\n\\t\\tcos(hrad) * tuple.g,\\n\\t\\tsin(hrad) * tuple.g\\n\\t);\\n}\\n\\nvec3 hsluvToLch(vec3 tuple) {\\n\\ttuple.g *= hsluv_maxChromaForLH(tuple.b, tuple.r) * .01;\\n\\treturn tuple.bgr;\\n}\\n\\nvec3 lchToHsluv(vec3 tuple) {\\n\\ttuple.g /= hsluv_maxChromaForLH(tuple.r, tuple.b) * .01;\\n\\treturn tuple.bgr;\\n}\\n\\nvec3 hpluvToLch(vec3 tuple) {\\n\\ttuple.g *= hsluv_maxSafeChromaForL(tuple.b) * .01;\\n\\treturn tuple.bgr;\\n}\\n\\nvec3 lchToHpluv(vec3 tuple) {\\n\\ttuple.g /= hsluv_maxSafeChromaForL(tuple.r) * .01;\\n\\treturn tuple.bgr;\\n}\\n\\nvec3 lchToRgb(vec3 tuple) {\\n\\treturn xyzToRgb(luvToXyz(lchToLuv(tuple)));\\n}\\n\\nvec3 rgbToLch(vec3 tuple) {\\n\\treturn luvToLch(xyzToLuv(rgbToXyz(tuple)));\\n}\\n\\nvec3 hsluvToRgb(vec3 tuple) {\\n\\treturn lchToRgb(hsluvToLch(tuple));\\n}\\n\\nvec3 rgbToHsluv(vec3 tuple) {\\n\\treturn lchToHsluv(rgbToLch(tuple));\\n}\\n\\nvec3 hpluvToRgb(vec3 tuple) {\\n\\treturn lchToRgb(hpluvToLch(tuple));\\n}\\n\\nvec3 rgbToHpluv(vec3 tuple) {\\n\\treturn lchToHpluv(rgbToLch(tuple));\\n}\\n\\nvec3 luvToRgb(vec3 tuple){\\n\\treturn xyzToRgb(luvToXyz(tuple));\\n}\\n\\n// allow vec4's\\nvec4   xyzToRgb(vec4 c) {return vec4(   xyzToRgb( vec3(c.x,c.y,c.z) ), c.a);}\\nvec4   rgbToXyz(vec4 c) {return vec4(   rgbToXyz( vec3(c.x,c.y,c.z) ), c.a);}\\nvec4   xyzToLuv(vec4 c) {return vec4(   xyzToLuv( vec3(c.x,c.y,c.z) ), c.a);}\\nvec4   luvToXyz(vec4 c) {return vec4(   luvToXyz( vec3(c.x,c.y,c.z) ), c.a);}\\nvec4   luvToLch(vec4 c) {return vec4(   luvToLch( vec3(c.x,c.y,c.z) ), c.a);}\\nvec4   lchToLuv(vec4 c) {return vec4(   lchToLuv( vec3(c.x,c.y,c.z) ), c.a);}\\nvec4 hsluvToLch(vec4 c) {return vec4( hsluvToLch( vec3(c.x,c.y,c.z) ), c.a);}\\nvec4 lchToHsluv(vec4 c) {return vec4( lchToHsluv( vec3(c.x,c.y,c.z) ), c.a);}\\nvec4 hpluvToLch(vec4 c) {return vec4( hpluvToLch( vec3(c.x,c.y,c.z) ), c.a);}\\nvec4 lchToHpluv(vec4 c) {return vec4( lchToHpluv( vec3(c.x,c.y,c.z) ), c.a);}\\nvec4   lchToRgb(vec4 c) {return vec4(   lchToRgb( vec3(c.x,c.y,c.z) ), c.a);}\\nvec4   rgbToLch(vec4 c) {return vec4(   rgbToLch( vec3(c.x,c.y,c.z) ), c.a);}\\nvec4 hsluvToRgb(vec4 c) {return vec4( hsluvToRgb( vec3(c.x,c.y,c.z) ), c.a);}\\nvec4 rgbToHsluv(vec4 c) {return vec4( rgbToHsluv( vec3(c.x,c.y,c.z) ), c.a);}\\nvec4 hpluvToRgb(vec4 c) {return vec4( hpluvToRgb( vec3(c.x,c.y,c.z) ), c.a);}\\nvec4 rgbToHpluv(vec4 c) {return vec4( rgbToHpluv( vec3(c.x,c.y,c.z) ), c.a);}\\nvec4   luvToRgb(vec4 c) {return vec4(   luvToRgb( vec3(c.x,c.y,c.z) ), c.a);}\\n// allow 3 floats\\nvec3   xyzToRgb(float x, float y, float z) {return   xyzToRgb( vec3(x,y,z) );}\\nvec3   rgbToXyz(float x, float y, float z) {return   rgbToXyz( vec3(x,y,z) );}\\nvec3   xyzToLuv(float x, float y, float z) {return   xyzToLuv( vec3(x,y,z) );}\\nvec3   luvToXyz(float x, float y, float z) {return   luvToXyz( vec3(x,y,z) );}\\nvec3   luvToLch(float x, float y, float z) {return   luvToLch( vec3(x,y,z) );}\\nvec3   lchToLuv(float x, float y, float z) {return   lchToLuv( vec3(x,y,z) );}\\nvec3 hsluvToLch(float x, float y, float z) {return hsluvToLch( vec3(x,y,z) );}\\nvec3 lchToHsluv(float x, float y, float z) {return lchToHsluv( vec3(x,y,z) );}\\nvec3 hpluvToLch(float x, float y, float z) {return hpluvToLch( vec3(x,y,z) );}\\nvec3 lchToHpluv(float x, float y, float z) {return lchToHpluv( vec3(x,y,z) );}\\nvec3   lchToRgb(float x, float y, float z) {return   lchToRgb( vec3(x,y,z) );}\\nvec3   rgbToLch(float x, float y, float z) {return   rgbToLch( vec3(x,y,z) );}\\nvec3 hsluvToRgb(float x, float y, float z) {return hsluvToRgb( vec3(x,y,z) );}\\nvec3 rgbToHsluv(float x, float y, float z) {return rgbToHsluv( vec3(x,y,z) );}\\nvec3 hpluvToRgb(float x, float y, float z) {return hpluvToRgb( vec3(x,y,z) );}\\nvec3 rgbToHpluv(float x, float y, float z) {return rgbToHpluv( vec3(x,y,z) );}\\nvec3   luvToRgb(float x, float y, float z) {return   luvToRgb( vec3(x,y,z) );}\\n// allow 4 floats\\nvec4   xyzToRgb(float x, float y, float z, float a) {return   xyzToRgb( vec4(x,y,z,a) );}\\nvec4   rgbToXyz(float x, float y, float z, float a) {return   rgbToXyz( vec4(x,y,z,a) );}\\nvec4   xyzToLuv(float x, float y, float z, float a) {return   xyzToLuv( vec4(x,y,z,a) );}\\nvec4   luvToXyz(float x, float y, float z, float a) {return   luvToXyz( vec4(x,y,z,a) );}\\nvec4   luvToLch(float x, float y, float z, float a) {return   luvToLch( vec4(x,y,z,a) );}\\nvec4   lchToLuv(float x, float y, float z, float a) {return   lchToLuv( vec4(x,y,z,a) );}\\nvec4 hsluvToLch(float x, float y, float z, float a) {return hsluvToLch( vec4(x,y,z,a) );}\\nvec4 lchToHsluv(float x, float y, float z, float a) {return lchToHsluv( vec4(x,y,z,a) );}\\nvec4 hpluvToLch(float x, float y, float z, float a) {return hpluvToLch( vec4(x,y,z,a) );}\\nvec4 lchToHpluv(float x, float y, float z, float a) {return lchToHpluv( vec4(x,y,z,a) );}\\nvec4   lchToRgb(float x, float y, float z, float a) {return   lchToRgb( vec4(x,y,z,a) );}\\nvec4   rgbToLch(float x, float y, float z, float a) {return   rgbToLch( vec4(x,y,z,a) );}\\nvec4 hsluvToRgb(float x, float y, float z, float a) {return hsluvToRgb( vec4(x,y,z,a) );}\\nvec4 rgbToHslul(float x, float y, float z, float a) {return rgbToHsluv( vec4(x,y,z,a) );}\\nvec4 hpluvToRgb(float x, float y, float z, float a) {return hpluvToRgb( vec4(x,y,z,a) );}\\nvec4 rgbToHpluv(float x, float y, float z, float a) {return rgbToHpluv( vec4(x,y,z,a) );}\\nvec4   luvToRgb(float x, float y, float z, float a) {return   luvToRgb( vec4(x,y,z,a) );}\\n\\n/*\\nEND HSLUV-GLSL\\n*/\\n\\n\\n// from https://gist.github.com/mattatz/44f081cac87e2f7c8980\\n// converted to glsl by gui@polygonjs.com\\n// and made function names consistent with the ones above\\n/*\\n * Conversion between RGB and LAB colorspace.\\n * Import from flowabs glsl program : https://code.google.com/p/flowabs/source/browse/glsl/?r=f36cbdcf7790a28d90f09e2cf89ec9a64911f138\\n */\\n\\n\\n\\nvec3 xyzToLab( vec3 c ) {\\n\\tvec3 n = c / vec3(95.047, 100, 108.883);\\n\\tvec3 v;\\n\\tv.x = ( n.x > 0.008856 ) ? pow( n.x, 1.0 / 3.0 ) : ( 7.787 * n.x ) + ( 16.0 / 116.0 );\\n\\tv.y = ( n.y > 0.008856 ) ? pow( n.y, 1.0 / 3.0 ) : ( 7.787 * n.y ) + ( 16.0 / 116.0 );\\n\\tv.z = ( n.z > 0.008856 ) ? pow( n.z, 1.0 / 3.0 ) : ( 7.787 * n.z ) + ( 16.0 / 116.0 );\\n\\treturn vec3(( 116.0 * v.y ) - 16.0, 500.0 * ( v.x - v.y ), 200.0 * ( v.y - v.z ));\\n}\\n\\nvec3 rgbToLab( vec3 c ) {\\n\\tvec3 lab = xyzToLab( rgbToXyz( c ) );\\n\\treturn vec3( lab.x / 100.0, 0.5 + 0.5 * ( lab.y / 127.0 ), 0.5 + 0.5 * ( lab.z / 127.0 ));\\n}\\n\\nvec3 labToXyz( vec3 c ) {\\n\\tfloat fy = ( c.x + 16.0 ) / 116.0;\\n\\tfloat fx = c.y / 500.0 + fy;\\n\\tfloat fz = fy - c.z / 200.0;\\n\\treturn vec3(\\n\\t\\t 95.047 * (( fx > 0.206897 ) ? fx * fx * fx : ( fx - 16.0 / 116.0 ) / 7.787),\\n\\t\\t100.000 * (( fy > 0.206897 ) ? fy * fy * fy : ( fy - 16.0 / 116.0 ) / 7.787),\\n\\t\\t108.883 * (( fz > 0.206897 ) ? fz * fz * fz : ( fz - 16.0 / 116.0 ) / 7.787)\\n\\t);\\n}\\n\\n\\n\\nvec3 labToRgb( vec3 c ) {\\n\\treturn xyzToRgb( labToXyz( vec3(100.0 * c.x, 2.0 * 127.0 * (c.y - 0.5), 2.0 * 127.0 * (c.z - 0.5)) ) );\\n}\\n\\n// adapted from\\n// THREEjs math/Color.js\\nfloat sRGBToLinear( float c ) {\\n\\treturn ( c < 0.04045 ) ? c * 0.0773993808 : pow( c * 0.9478672986 + 0.0521327014, 2.4 );\\n}\\nvec3 sRGBToLinear( vec3 c ) {\\n\\treturn vec3( sRGBToLinear(c.r), sRGBToLinear(c.g), sRGBToLinear(c.b) );\\n}\\nvec4 sRGBToLinear( vec4 c ) {\\n\\treturn vec4( sRGBToLinear(c.r), sRGBToLinear(c.g), sRGBToLinear(c.b), c.a );\\n}\"","export default \"// get vec2 tex coordinate from index\\nvec2 geometryAttributesLookupUv( float id, vec2 textureSize ) { \\n\\tfloat idRounded = round( id );\\n\\n\\tvec2 coords = vec2(\\n\\t\\tmod( ( idRounded ), textureSize.x ),\\n\\t\\tfloor( ( idRounded ) / textureSize.x )\\n\\t) + 0.5;\\n\\n\\n\\treturn coords / textureSize;\\n\\n}\\n\"","export default \"\\n/*\\nSDF Repeat in cartesian coordinates\\n*/\\nfloat SDFRepeat( in float p, in float c )\\n{\\n\\treturn mod(p+0.5*c,c)-0.5*c;\\n}\\nfloat SDFRepeatClamped( in float p, in float c, in float boundMin, in float boundMax )\\n{\\n\\treturn p-c*clamp(round(p/c),boundMin,boundMax);\\n}\\nvec3 SDFRepeat( in vec3 p, in vec3 c )\\n{\\n\\treturn mod(p+0.5*c,c)-0.5*c;\\n}\\nvec3 SDFRepeatClamped( in vec3 p, in vec3 c, in vec3 boundMin, in vec3 boundMax )\\n{\\n\\treturn p-c*clamp(round(p/c),boundMin,boundMax);\\n}\\nvec3 SDFRepeatClampedX( in vec3 p, in vec3 c, in float boundMin, in float boundMax )\\n{\\n\\treturn vec3(\\n\\t\\tSDFRepeatClamped(p.x, c.x, boundMin, boundMax),\\n\\t\\tSDFRepeat(p.y, c.y),\\n\\t\\tSDFRepeat(p.z, c.z)\\n\\t);\\n}\\nvec3 SDFRepeatClampedY( in vec3 p, in vec3 c, in float boundMin, in float boundMax )\\n{\\n\\treturn vec3(\\n\\t\\tSDFRepeat(p.x, c.x),\\n\\t\\tSDFRepeatClamped(p.y, c.y, boundMin, boundMax),\\n\\t\\tSDFRepeat(p.z, c.z)\\n\\t);\\n}\\nvec3 SDFRepeatClampedZ( in vec3 p, in vec3 c, in float boundMin, in float boundMax )\\n{\\n\\treturn vec3(\\n\\t\\tSDFRepeat(p.x, c.x),\\n\\t\\tSDFRepeat(p.y, c.y),\\n\\t\\tSDFRepeatClamped(p.z, c.z, boundMin, boundMax)\\n\\t);\\n}\\nvec3 SDFRepeatClampedXY( in vec3 p, in vec3 c, in vec2 boundMin, in vec2 boundMax )\\n{\\n\\treturn vec3(\\n\\t\\tSDFRepeatClamped(p.x, c.x, boundMin.x, boundMax.x),\\n\\t\\tSDFRepeatClamped(p.y, c.y, boundMin.y, boundMax.y),\\n\\t\\tSDFRepeat(p.z, c.z)\\n\\t);\\n}\\nvec3 SDFRepeatClampedXZ( in vec3 p, in vec3 c, in vec2 boundMin, in vec2 boundMax )\\n{\\n\\treturn vec3(\\n\\t\\tSDFRepeatClamped(p.x, c.x, boundMin.x, boundMax.x),\\n\\t\\tSDFRepeat(p.y, c.y),\\n\\t\\tSDFRepeatClamped(p.z, c.z, boundMin.y, boundMax.y)\\n\\t);\\n}\\nvec3 SDFRepeatClampedYZ( in vec3 p, in vec3 c, in vec2 boundMin, in vec2 boundMax )\\n{\\n\\treturn vec3(\\n\\t\\tSDFRepeat(p.x, c.x),\\n\\t\\tSDFRepeatClamped(p.y, c.y, boundMin.x, boundMax.x),\\n\\t\\tSDFRepeatClamped(p.z, c.z, boundMin.y, boundMax.y)\\n\\t);\\n}\\nvec3 SDFRepeatX( in vec3 p, in vec3 c ){\\n\\treturn vec3(\\n\\t\\tSDFRepeat(p.x, c.x),\\n\\t\\tp.yz\\n\\t);\\n}\\nvec3 SDFRepeatXClampedX( in vec3 p, in vec3 c, in float boundMin, in float boundMax ){\\n\\treturn vec3(\\n\\t\\tSDFRepeatClamped(p.x, c.x, boundMin, boundMax),\\n\\t\\tp.yz\\n\\t);\\n}\\nvec3 SDFRepeatY( in vec3 p, in vec3 c ){\\n\\treturn vec3(\\n\\t\\tp.x,\\n\\t\\tSDFRepeat(p.y, c.y),\\n\\t\\tp.z\\n\\t);\\n}\\nvec3 SDFRepeatYClampedY( in vec3 p, in vec3 c, in float boundMin, in float boundMax ){\\n\\treturn vec3(\\n\\t\\tp.x,\\n\\t\\tSDFRepeatClamped(p.y, c.y, boundMin, boundMax),\\n\\t\\tp.z\\n\\t);\\n}\\nvec3 SDFRepeatZ( in vec3 p, in vec3 c ){\\n\\treturn vec3(\\n\\t\\tp.xy,\\n\\t\\tSDFRepeat(p.z, c.z)\\n\\t);\\n}\\nvec3 SDFRepeatZClampedZ( in vec3 p, in vec3 c, in float boundMin, in float boundMax ){\\n\\treturn vec3(\\n\\t\\tp.xy,\\n\\t\\tSDFRepeatClamped(p.z, c.z, boundMin, boundMax)\\n\\t);\\n}\\nvec3 SDFRepeatXY( in vec3 p, in vec3 c ){\\n\\treturn vec3(\\n\\t\\tSDFRepeat(p.x, c.x),\\n\\t\\tSDFRepeat(p.y, c.y),\\n\\t\\tp.z\\n\\t);\\n}\\nvec3 SDFRepeatXYClampedX( in vec3 p, in vec3 c, in float boundMin, in float boundMax ){\\n\\treturn vec3(\\n\\t\\tSDFRepeatClamped(p.x, c.x, boundMin, boundMax),\\n\\t\\tSDFRepeat(p.y, c.y),\\n\\t\\tp.z\\n\\t);\\n}\\nvec3 SDFRepeatXYClampedY( in vec3 p, in vec3 c, in float boundMin, in float boundMax ){\\n\\treturn vec3(\\n\\t\\tSDFRepeat(p.x, c.x),\\n\\t\\tSDFRepeatClamped(p.y, c.y, boundMin, boundMax),\\n\\t\\tp.z\\n\\t);\\n}\\nvec3 SDFRepeatXYClampedXY( in vec3 p, in vec3 c, in vec2 boundMin, in vec2 boundMax ){\\n\\treturn vec3(\\n\\t\\tSDFRepeatClamped(p.x, c.x, boundMin.x, boundMax.x),\\n\\t\\tSDFRepeatClamped(p.y, c.y, boundMin.y, boundMax.y),\\n\\t\\tp.z\\n\\t);\\n}\\nvec3 SDFRepeatXZ( in vec3 p, in vec3 c ){\\n\\treturn vec3(\\n\\t\\tSDFRepeat(p.x, c.x),\\n\\t\\tp.y,\\n\\t\\tSDFRepeat(p.z, c.z)\\n\\t);\\n}\\nvec3 SDFRepeatXZClampedX( in vec3 p, in vec3 c, in float boundMin, in float boundMax ){\\n\\treturn vec3(\\n\\t\\tSDFRepeatClamped(p.x, c.x, boundMin, boundMax),\\n\\t\\tp.y,\\n\\t\\tSDFRepeat(p.z, c.z)\\n\\t);\\n}\\nvec3 SDFRepeatXZClampedZ( in vec3 p, in vec3 c, in float boundMin, in float boundMax ){\\n\\treturn vec3(\\n\\t\\tSDFRepeat(p.x, c.x),\\n\\t\\tp.y,\\n\\t\\tSDFRepeatClamped(p.z, c.z, boundMin, boundMax)\\n\\t);\\n}\\nvec3 SDFRepeatXZClampedXZ( in vec3 p, in vec3 c, in vec2 boundMin, in vec2 boundMax ){\\n\\treturn vec3(\\n\\t\\tSDFRepeatClamped(p.x, c.x, boundMin.x, boundMax.x),\\n\\t\\tp.y,\\n\\t\\tSDFRepeatClamped(p.z, c.z, boundMin.y, boundMax.y)\\n\\t);\\n}\\nvec3 SDFRepeatYZ( in vec3 p, in vec3 c ){\\n\\treturn vec3(\\n\\t\\tp.x,\\n\\t\\tSDFRepeat(p.y, c.y),\\n\\t\\tSDFRepeat(p.z, c.z)\\n\\t);\\n}\\nvec3 SDFRepeatYZClampedY( in vec3 p, in vec3 c, in float boundMin, in float boundMax ){\\n\\treturn vec3(\\n\\t\\tp.x,\\n\\t\\tSDFRepeatClamped(p.y, c.y, boundMin, boundMax),\\n\\t\\tSDFRepeat(p.z, c.z)\\n\\t);\\n}\\nvec3 SDFRepeatYZClampedZ( in vec3 p, in vec3 c, in float boundMin, in float boundMax ){\\n\\treturn vec3(\\n\\t\\tp.x,\\n\\t\\tSDFRepeat(p.y, c.y),\\n\\t\\tSDFRepeatClamped(p.z, c.z, boundMin, boundMax)\\n\\t);\\n}\\nvec3 SDFRepeatYZClampedYZ( in vec3 p, in vec3 c, in vec2 boundMin, in vec2 boundMax ){\\n\\treturn vec3(\\n\\t\\tp.x,\\n\\t\\tSDFRepeatClamped(p.y, c.y, boundMin.x, boundMax.x),\\n\\t\\tSDFRepeatClamped(p.z, c.z, boundMin.y, boundMax.y)\\n\\t);\\n}\\n\""],"names":["AnimationPositionMode","AnimationPositionRelativeTo","AttribAdjacency","i","PointsCountMode","JoinMode","positions","detail","radius","my","PhysicsIdAttribute","PhysicsRBDType","PhysicsRBDColliderType","PhysicsRBDCuboidAttribute","PhysicsRBDRadiusAttribute","PhysicsRBDHeightAttribute","PhysicsRBDCylinderAttribute","PhysicsRBDHeightFieldAttribute","PhysicsCommonAttribute","PhysicsJointType","PhysicsJointAttribute","anchor1","anchor2","PhysicsLib","wakeUp","RBDProperty","RigidBodyType","delta","PhysicsPlayerType","RBDCapsuleProperty","RBDCuboidProperty","RBDCommonProperty","CorePlayerInput","GetObjectPropertyJsNodeInputName","animation","MergeMode","AnimPropertyValueNodeMode","AnimTargetNodeTargetType","MapMode","camera","WebCamFacingMode","DataTextureControllerBufferType","AnimationEventInput","AnimationEventOutput","element","options","SceneNodeInput","SceneNodeOutput","EventName","ScrollTriggerNodeInput","ScrollTriggerNodeOutput","SetParamParamType","ColorCorrectType","GlCompareTestName","GlCompareTestOperation","ComputeNormalsInput","ForLoopVar","VariablesLookupMode","glType","ClothSolverStepSimulationOutput","JsCompareTestName","JsCompareTestOperation","CompareInputName","GetVideoPropertyJsNodeOutputName","ImportAttributeJsNodeInput","ImportAttributeJsNodeOutput","OnObjectDispatchEventJsNodeInputName","OnTickJsNodeOuput","triggeredMethods","AnimationJsOutput","SetObjectAttributeInputName","SetParamJsNodeInputName","EntityBuilderAssemblerConstant","EntityVariable","InstanceBuilderAssemblerConstant","InstanceVariable","ObjectBuilderAssemblerConstant","ObjectVariable","PointBuilderAssemblerConstant","PointVariable","SoftBodyVariable","ToneMappingModeStr","coreObject","BooleanMode","BooleanCadOperationType","ConversionMode","FilletMode","BooleanCsgOperationType","index","getVector","LayerUpdateMode","NoiseOperation","position","normal","simplex","QuadSmoothMode","edgeId","object","id","sharedFacesNeighbourData","quadId","quadNodes","AttribType","NormalizeMode","OutOfRangeBehavior","BooleanOperation","CenterMode","HierarchyMode","AddChildMode","_addNewParent","params","objects","parentObjects","SizeComputationMethod","RaySopMode","SetGeometryMode","SortMode","Axis","SphereType","TangentMode","UvUnwrapMethod"],"sourceRoot":""}