"use strict";
import { BaseSopOperation } from "./_Base";
import { TypedNodePathParamValue, NODE_PATH_DEFAULT } from "../../../core/Walker";
import { NodeContext } from "../../../engine/poly/NodeContext";
import { AttribFromTexture } from "../../../core/geometry/operation/AttribFromTexture";
import { InputCloneMode } from "../../../engine/poly/InputCloneMode";
import { corePointClassFactory } from "../../../core/geometry/CoreObjectFactory";
export class AttribFromTextureSopOperation extends BaseSopOperation {
  static type() {
    return "attribFromTexture";
  }
  async cook(inputCoreGroups, params) {
    var _a;
    const coreGroup = inputCoreGroups[0];
    const textureNode = params.texture.nodeWithContext(NodeContext.COP, (_a = this.states) == null ? void 0 : _a.error);
    if (!textureNode) {
      return coreGroup;
    }
    const container = await textureNode.compute();
    const texture = container.texture();
    const objects = coreGroup.allObjects();
    for (const object of objects) {
      this._setPositionFromDataTexture(object, texture, params);
    }
    return coreGroup;
  }
  _setPositionFromDataTexture(object, texture, params) {
    var _a;
    const corePointClass = corePointClassFactory(object);
    const uvAttrib = corePointClass.attribute(object, params.uvAttrib);
    if (uvAttrib == null) {
      (_a = this.states) == null ? void 0 : _a.error.set(`param '${params.uvAttrib} not found'`);
      return;
    }
    const operation = new AttribFromTexture();
    operation.setAttribute({
      object,
      texture,
      uvAttribName: params.uvAttrib,
      targetAttribName: params.attrib,
      targetAttribSize: params.attribSize,
      add: params.add,
      mult: params.mult
    });
  }
}
AttribFromTextureSopOperation.DEFAULT_PARAMS = {
  texture: new TypedNodePathParamValue(NODE_PATH_DEFAULT.NODE.EMPTY),
  uvAttrib: "uv",
  attrib: "pscale",
  attribSize: 1,
  add: 0,
  mult: 1
};
AttribFromTextureSopOperation.INPUT_CLONED_STATE = InputCloneMode.FROM_NODE;
