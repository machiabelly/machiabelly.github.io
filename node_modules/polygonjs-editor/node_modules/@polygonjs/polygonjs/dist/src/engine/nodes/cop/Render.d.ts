/**
 * Creates a texture from a render
 *
 * @remarks
 * This node can be useful when you want to use what a camera sees as a texture.
 *
 */
import { WebGLRenderer, WebGLRenderTarget } from 'three';
import { TypedCopNode } from './_Base';
import { NodeParamsConfig } from '../utils/params/ParamsConfig';
import { TextureParamsController } from './utils/TextureParamsController';
import { Constructor } from '../../../types/GlobalTypes';
import { CopType } from '../../poly/registers/nodes/types/Cop';
export declare function RenderCopNodeParamConfig<TBase extends Constructor>(Base: TBase): {
    new (...args: any[]): {
        /** @param path to the main camera object that will be used when the scene loads outside of the editor */
        cameraPath: import("../utils/params/ParamsConfig").ParamTemplate<import("../../index_all").ParamType.STRING>;
        /** @param transparent background */
        transparentBackground: import("../utils/params/ParamsConfig").ParamTemplate<import("../../index_all").ParamType.BOOLEAN>;
        /** @param bg Color */
        backgroundColor: import("../utils/params/ParamsConfig").ParamTemplate<import("../../index_all").ParamType.COLOR>;
        /** @param use same resolution as renderer */
        useRendererRes: import("../utils/params/ParamsConfig").ParamTemplate<import("../../index_all").ParamType.BOOLEAN>;
        /** @param render resolution */
        resolution: import("../utils/params/ParamsConfig").ParamTemplate<import("../../index_all").ParamType.VECTOR2>;
        /** @param use a data texture instead of a render target, which can be useful when using that texture as and envMap */
        useDataTexture: import("../utils/params/ParamsConfig").ParamTemplate<import("../../index_all").ParamType.BOOLEAN>;
        /** @param autoRender */
        autoRender: import("../utils/params/ParamsConfig").ParamTemplate<import("../../index_all").ParamType.BOOLEAN>;
        /** @param render button */
        render: import("../utils/params/ParamsConfig").ParamTemplate<import("../../index_all").ParamType.BUTTON>;
    };
} & TBase;
declare const RenderCopParamConfig_base: {
    new (...args: any[]): {
        tcolorSpace: import("../utils/params/ParamsConfig").ParamTemplate<import("../../index_all").ParamType.BOOLEAN>;
        colorSpace: import("../utils/params/ParamsConfig").ParamTemplate<import("../../index_all").ParamType.STRING>;
        tmapping: import("../utils/params/ParamsConfig").ParamTemplate<import("../../index_all").ParamType.BOOLEAN>;
        mapping: import("../utils/params/ParamsConfig").ParamTemplate<import("../../index_all").ParamType.INTEGER>;
        twrap: import("../utils/params/ParamsConfig").ParamTemplate<import("../../index_all").ParamType.BOOLEAN>;
        wrapS: import("../utils/params/ParamsConfig").ParamTemplate<import("../../index_all").ParamType.INTEGER>;
        wrapT: import("../utils/params/ParamsConfig").ParamTemplate<import("../../index_all").ParamType.INTEGER>;
        tminFilter: import("../utils/params/ParamsConfig").ParamTemplate<import("../../index_all").ParamType.BOOLEAN>;
        minFilter: import("../utils/params/ParamsConfig").ParamTemplate<import("../../index_all").ParamType.INTEGER>;
        tmagFilter: import("../utils/params/ParamsConfig").ParamTemplate<import("../../index_all").ParamType.BOOLEAN>;
        magFilter: import("../utils/params/ParamsConfig").ParamTemplate<import("../../index_all").ParamType.INTEGER>;
        tanisotropy: import("../utils/params/ParamsConfig").ParamTemplate<import("../../index_all").ParamType.BOOLEAN>;
        useRendererMaxAnisotropy: import("../utils/params/ParamsConfig").ParamTemplate<import("../../index_all").ParamType.BOOLEAN>;
        anisotropy: import("../utils/params/ParamsConfig").ParamTemplate<import("../../index_all").ParamType.INTEGER>;
        tflipY: import("../utils/params/ParamsConfig").ParamTemplate<import("../../index_all").ParamType.BOOLEAN>;
        flipY: import("../utils/params/ParamsConfig").ParamTemplate<import("../../index_all").ParamType.BOOLEAN>;
        ttransform: import("../utils/params/ParamsConfig").ParamTemplate<import("../../index_all").ParamType.BOOLEAN>;
        offset: import("../utils/params/ParamsConfig").ParamTemplate<import("../../index_all").ParamType.VECTOR2>;
        repeat: import("../utils/params/ParamsConfig").ParamTemplate<import("../../index_all").ParamType.VECTOR2>;
        rotation: import("../utils/params/ParamsConfig").ParamTemplate<import("../../index_all").ParamType.FLOAT>;
        center: import("../utils/params/ParamsConfig").ParamTemplate<import("../../index_all").ParamType.VECTOR2>;
        tadvanced: import("../utils/params/ParamsConfig").ParamTemplate<import("../../index_all").ParamType.BOOLEAN>;
        tformat: import("../utils/params/ParamsConfig").ParamTemplate<import("../../index_all").ParamType.BOOLEAN>;
        format: import("../utils/params/ParamsConfig").ParamTemplate<import("../../index_all").ParamType.INTEGER>;
        ttype: import("../utils/params/ParamsConfig").ParamTemplate<import("../../index_all").ParamType.BOOLEAN>;
        type: import("../utils/params/ParamsConfig").ParamTemplate<import("../../index_all").ParamType.INTEGER>;
    };
} & {
    new (...args: any[]): {
        /** @param path to the main camera object that will be used when the scene loads outside of the editor */
        cameraPath: import("../utils/params/ParamsConfig").ParamTemplate<import("../../index_all").ParamType.STRING>;
        /** @param transparent background */
        transparentBackground: import("../utils/params/ParamsConfig").ParamTemplate<import("../../index_all").ParamType.BOOLEAN>;
        /** @param bg Color */
        backgroundColor: import("../utils/params/ParamsConfig").ParamTemplate<import("../../index_all").ParamType.COLOR>;
        /** @param use same resolution as renderer */
        useRendererRes: import("../utils/params/ParamsConfig").ParamTemplate<import("../../index_all").ParamType.BOOLEAN>;
        /** @param render resolution */
        resolution: import("../utils/params/ParamsConfig").ParamTemplate<import("../../index_all").ParamType.VECTOR2>;
        /** @param use a data texture instead of a render target, which can be useful when using that texture as and envMap */
        useDataTexture: import("../utils/params/ParamsConfig").ParamTemplate<import("../../index_all").ParamType.BOOLEAN>;
        /** @param autoRender */
        autoRender: import("../utils/params/ParamsConfig").ParamTemplate<import("../../index_all").ParamType.BOOLEAN>;
        /** @param render button */
        render: import("../utils/params/ParamsConfig").ParamTemplate<import("../../index_all").ParamType.BUTTON>;
    };
} & typeof NodeParamsConfig;
declare class RenderCopParamConfig extends RenderCopParamConfig_base {
}
export declare class RenderCopNode extends TypedCopNode<RenderCopParamConfig> {
    paramsConfig: RenderCopParamConfig;
    static type(): Readonly<CopType.RENDER>;
    readonly textureParamsController: TextureParamsController;
    private _rendererController;
    private _dataTextureController;
    private _renderTargetByRenderer;
    cook(): Promise<void>;
    private _addOnBeforeTickCallback;
    private _removeOnBeforeTickCallback;
    private _onBeforeRenderCallbackName;
    dispose(): void;
    private _getCameraSync;
    private _getCamera;
    private _renderOnTargetBound;
    renderOnTarget(): Promise<void>;
    renderTarget(renderer: WebGLRenderer): Promise<WebGLRenderTarget<import("three").Texture> | undefined>;
    private createRenderTargetIfRequired;
    private _requestedResolution;
    private _ensureRenderTargetResolutionValid;
    private _createRenderTarget;
    static PARAM_CALLBACK_render(node: RenderCopNode): void;
}
export {};
