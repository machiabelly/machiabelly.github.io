"use strict";
import { TypedSopNode } from "./_Base";
import { TetrahedronBufferGeometry } from "../../../core/geometry/operation/Tetrahedron";
import { NodeParamsConfig, ParamConfig } from "../utils/params/ParamsConfig";
import { ObjectType } from "../../../core/geometry/Constant";
import { SopType } from "../../poly/registers/nodes/types/Sop";
class TetrahedronSopParamsConfig extends NodeParamsConfig {
  constructor() {
    super(...arguments);
    /** @param radius of the tetrahedron */
    this.radius = ParamConfig.FLOAT(1);
    /** @param resolution of the tetrahedron */
    this.detail = ParamConfig.INTEGER(0, {
      range: [0, 10],
      rangeLocked: [true, false]
    });
    /** @param sets to create only points */
    this.pointsOnly = ParamConfig.BOOLEAN(0);
    /** @param center of the tetrahedron */
    this.center = ParamConfig.VECTOR3([0, 0, 0]);
  }
}
const ParamsConfig = new TetrahedronSopParamsConfig();
export class TetrahedronSopNode extends TypedSopNode {
  constructor() {
    super(...arguments);
    this.paramsConfig = ParamsConfig;
  }
  static type() {
    return SopType.TETRAHEDRON;
  }
  cook() {
    const pointsOnly = this.pv.pointsOnly;
    const geometry = new TetrahedronBufferGeometry(this.pv.radius, this.pv.detail, pointsOnly);
    geometry.translate(this.pv.center.x, this.pv.center.y, this.pv.center.z);
    if (pointsOnly) {
      const object = this.createObject(geometry, ObjectType.POINTS);
      this.setObject(object);
    } else {
      geometry.computeVertexNormals();
      this.setGeometry(geometry);
    }
  }
}
