"use strict";
import { BufferGeometry } from "three";
import { TypedSopNode } from "./_Base";
import { CoreGeometryUtilCurve } from "../../../core/geometry/util/Curve";
import { CoreGeometryOperationSkin } from "../../../core/geometry/operation/Skin";
import { NodeParamsConfig } from "../utils/params/ParamsConfig";
import { arrayCompact, arraySortBy } from "../../../core/ArrayUtils";
import { SopType } from "../../poly/registers/nodes/types/Sop";
class SkinSopParamsConfig extends NodeParamsConfig {
}
const ParamsConfig = new SkinSopParamsConfig();
export class SkinSopNode extends TypedSopNode {
  constructor() {
    super(...arguments);
    this.paramsConfig = ParamsConfig;
  }
  static type() {
    return SopType.SKIN;
  }
  initializeNode() {
    this.io.inputs.setCount(1, 2);
  }
  cook(inputCoreGroups) {
    const inputs = this.io.inputs.inputs();
    const compactInputs = [];
    arrayCompact(inputs, compactInputs);
    const inputsCount = compactInputs.length;
    switch (inputsCount) {
      case 1:
        return this.process_one_input(inputCoreGroups);
      case 2:
        return this.process_two_inputs(inputCoreGroups);
      default:
        return this.states.error.set("inputs count not valid");
    }
  }
  process_one_input(input_contents) {
    const core_group0 = input_contents[0];
    const line_segments0 = this._getLineSegments(core_group0);
    const geometries = [];
    if (line_segments0) {
      const first_line_segment = line_segments0[0];
      if (first_line_segment) {
        const src_geometries = CoreGeometryUtilCurve.line_segment_to_geometries(first_line_segment);
        if (src_geometries) {
          src_geometries.forEach((src_geometry, i) => {
            if (i > 0) {
              const prev_src_geometry = src_geometries[i - 1];
              const geometry = this._skin(prev_src_geometry, src_geometry);
              geometries.push(geometry);
            }
          });
        }
      }
    }
    this.setGeometries(geometries);
  }
  process_two_inputs(input_contents) {
    const core_group0 = input_contents[0];
    const core_group1 = input_contents[1];
    const line_segments0 = this._getLineSegments(core_group0);
    const line_segments1 = this._getLineSegments(core_group1);
    const line_segments = arraySortBy([line_segments0, line_segments1], (array) => -array.length);
    const smallest_array = line_segments[0];
    const largest_array = line_segments[1];
    const geometries = [];
    smallest_array.forEach((line_segment, i) => {
      const other_line_segment = largest_array[i];
      if (line_segment != null && other_line_segment != null) {
        const geo = line_segment.geometry;
        const other_geo = other_line_segment.geometry;
        const geometry = this._skin(geo, other_geo);
        geometries.push(geometry);
      }
    });
    this.setGeometries(geometries);
  }
  _getLineSegments(core_group) {
    return core_group.threejsObjects().filter((child) => child.isLineSegments);
  }
  _skin(geometry1, geometry0) {
    const geometry = new BufferGeometry();
    const operation = new CoreGeometryOperationSkin(geometry, geometry1, geometry0);
    operation.process();
    return geometry;
  }
}
