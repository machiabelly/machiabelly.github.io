"use strict";
import { GlType } from "./../../../../poly/registers/nodes/types/Gl";
import { TextureVariable } from "./TextureVariable";
import { AttributeGlNode } from "../../Attribute";
export const TEXTURE_ALLOCATION_PREFIX = "texture_";
export const TEXTURE_ALLOCATION_NAMES_SEPARATOR = "_x_";
export class TextureAllocation {
  constructor() {
    this._size = 0;
  }
  addVariable(variable) {
    this._variables = this._variables || [];
    this._variables.push(variable);
    variable.setPosition(this._size);
    variable.setAllocation(this);
    this._size += variable.size();
  }
  hasSpaceForVariable(variable) {
    return this._size + variable.size() <= 4;
  }
  shaderName() {
    var _a;
    const names = ((_a = this.variables()) == null ? void 0 : _a.map((v) => v.name())) || ["no_variables_allocated"];
    return names.join(TEXTURE_ALLOCATION_NAMES_SEPARATOR);
  }
  textureName() {
    return `${TEXTURE_ALLOCATION_PREFIX}${this.shaderName()}`;
  }
  variables() {
    return this._variables;
  }
  variablesForInputNode(root_node) {
    var _a;
    return (_a = this._variables) == null ? void 0 : _a.filter((variable) => {
      var _a2;
      return ((_a2 = variable.graphNodeIds()) == null ? void 0 : _a2.has(root_node.graphNodeId())) || false;
    });
  }
  inputNamesForNode(root_node) {
    const variables = this.variablesForInputNode(root_node);
    if (variables) {
      if (root_node.type() == GlType.ATTRIBUTE) {
        return [AttributeGlNode.INPUT_NAME];
      } else {
        return variables.map((v) => v.name());
      }
    }
  }
  // find_variable_with_node(root_node: BaseNodeGl, input_name: string): TextureVariable{
  // 	return this.variables_for_input_node(root_node).filter(v=>v.name() == input_name)[0]
  // }
  // find_variable_without_node(input_name: string): TextureVariable{
  // 	return this._variables.filter(v=>v.name() == input_name)[0]
  // }
  variable(variable_name) {
    if (this._variables) {
      for (const variable of this._variables) {
        if (variable.name() == variable_name) {
          return variable;
        }
      }
    }
  }
  static fromJSON(data) {
    const texture_allocation = new TextureAllocation();
    for (const datum of data) {
      const texture_variable = TextureVariable.fromJSON(datum);
      texture_allocation.addVariable(texture_variable);
    }
    return texture_allocation;
  }
  toJSON(scene) {
    if (this._variables) {
      return this._variables.map((v) => v.toJSON(scene));
    } else {
      return [];
    }
  }
}
