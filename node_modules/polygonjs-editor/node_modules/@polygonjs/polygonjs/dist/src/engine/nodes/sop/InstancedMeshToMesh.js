"use strict";
import { InstancedMesh } from "three";
import { TypedSopNode } from "./_Base";
import { InstancedMeshToMeshSopOperation } from "../../operations/sop/InstancedMeshToMesh";
import { NodeParamsConfig, ParamConfig } from "../utils/params/ParamsConfig";
import { SopType } from "../../poly/registers/nodes/types/Sop";
import { registerObjectType, ObjectType } from "../../../core/geometry/Constant";
const DEFAULT = InstancedMeshToMeshSopOperation.DEFAULT_PARAMS;
class InstancedMeshToMeshSopParamsConfig extends NodeParamsConfig {
  constructor() {
    super(...arguments);
    this.cloneGeometry = ParamConfig.BOOLEAN(DEFAULT.cloneGeometry);
  }
}
const ParamsConfig = new InstancedMeshToMeshSopParamsConfig();
export class InstancedMeshToMeshSopNode extends TypedSopNode {
  constructor() {
    super(...arguments);
    this.paramsConfig = ParamsConfig;
  }
  static type() {
    return SopType.INSTANCED_MESH_TO_MESH;
  }
  initializeNode() {
    super.initializeNode();
    this.io.inputs.setCount(1);
    this.io.inputs.initInputsClonedState(InstancedMeshToMeshSopOperation.INPUT_CLONED_STATE);
    registerObjectType({
      type: ObjectType.INSTANCED_MESH,
      checkFunc: (o) => {
        if (o.isInstancedMesh) {
          return ObjectType.INSTANCED_MESH;
        }
      },
      ctor: InstancedMesh,
      humanName: "InstancedMesh"
    });
  }
  async cook(inputCoreGroups) {
    this._operation = this._operation || new InstancedMeshToMeshSopOperation(this.scene(), this.states, this);
    const coreGroup = await this._operation.cook(inputCoreGroups, this.pv);
    this.setCoreGroup(coreGroup);
  }
}
