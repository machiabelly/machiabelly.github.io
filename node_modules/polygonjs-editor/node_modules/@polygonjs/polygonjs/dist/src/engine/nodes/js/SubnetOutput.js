"use strict";
import { TypedJsNode } from "./_Base";
import { NodeParamsConfig } from "../utils/params/ParamsConfig";
import { NetworkChildNodeType } from "../../poly/NodeContext";
class SubnetOutputJsParamsConfig extends NodeParamsConfig {
}
const ParamsConfig = new SubnetOutputJsParamsConfig();
export class SubnetOutputJsNode extends TypedJsNode {
  constructor() {
    super(...arguments);
    this.paramsConfig = ParamsConfig;
  }
  static type() {
    return NetworkChildNodeType.OUTPUT;
  }
  initializeNode() {
    this.io.connection_points.set_input_name_function(this.expectedInputName.bind(this));
    this.io.connection_points.set_expected_output_types_function(() => []);
    this.io.connection_points.set_expected_input_types_function(this.expectedInputTypes.bind(this));
    this.io.connection_points.set_create_spare_params_from_inputs(false);
  }
  parent() {
    return super.parent();
  }
  expectedInputName(index) {
    const parent = this.parent();
    return (parent == null ? void 0 : parent.childExpectedOutputConnectionPointName(index)) || `in${index}`;
  }
  expectedInputTypes() {
    const parent = this.parent();
    return (parent == null ? void 0 : parent.childExpectedOutputConnectionPointTypes()) || [];
  }
  setLines(shadersCollectionController) {
    const parent = this.parent();
    parent == null ? void 0 : parent.setSubnetOutputLines(shadersCollectionController, this);
  }
  // public override outputValue(context: JsNodeTriggerContext, outputName: string) {
  // 	return this._inputValue<JsConnectionPointType>(outputName, context) || 0;
  // }
}
