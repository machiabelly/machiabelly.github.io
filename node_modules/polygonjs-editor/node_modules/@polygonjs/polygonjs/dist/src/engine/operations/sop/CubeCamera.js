"use strict";
import { BaseSopOperation } from "./_Base";
import { MathUtils, Vector3, CubeCamera, WebGLCubeRenderTarget } from "three";
import { InputCloneMode } from "../../../engine/poly/InputCloneMode";
import { CameraNodeType } from "../../poly/NodeContext";
import { CameraAttribute, CORE_CAMERA_DEFAULT } from "../../../core/camera/CoreCamera";
import { CUBE_CAMERA_DEFAULT, registerCubeCamera } from "../../../core/camera/CoreCubeCamera";
import { isBooleanTrue } from "../../../core/Type";
import { CameraHelper } from "../../../core/helpers/CameraHelper";
import { ThreejsCoreObject } from "../../../core/geometry/modules/three/ThreejsCoreObject";
import { ObjectType, registerObjectType } from "../../../core/geometry/Constant";
export class CubeCameraExtended extends CubeCamera {
  copy(source, recursive) {
    const clonedCubeCamera = super.copy(source, recursive);
    let child;
    while (child = clonedCubeCamera.children[0]) {
      clonedCubeCamera.remove(child);
    }
    for (let srcChild of source.children) {
      clonedCubeCamera.add(srcChild.clone());
    }
    clonedCubeCamera.renderTarget = source.renderTarget;
    return clonedCubeCamera;
  }
}
const _CubeCameraSopOperation = class extends BaseSopOperation {
  static type() {
    return CameraNodeType.CUBE;
  }
  cook(inputCoreGroups, params) {
    const camera = _CubeCameraSopOperation.createCamera(params, this._node);
    camera.name = params.name || CameraNodeType.CUBE;
    camera.position.copy(params.position);
    camera.rotation.set(
      MathUtils.degToRad(params.rotation.x),
      MathUtils.degToRad(params.rotation.y),
      MathUtils.degToRad(params.rotation.z)
    );
    _CubeCameraSopOperation.updateCamera(camera, params);
    const objects = [camera];
    return this.createCoreGroupFromObjects(objects);
  }
  static updateCamera(camera, params) {
    camera.updateWorldMatrix(false, true);
    const childCameras = camera.children.filter(
      (c) => c.isPerspectiveCamera
    );
    let i = 0;
    for (const childCamera of childCameras) {
      childCamera.name = `${camera.name}-perspectiveCamera-${i}`;
      childCamera.updateProjectionMatrix();
      i++;
    }
    camera.matrixAutoUpdate = params.matrixAutoUpdate;
    _CubeCameraSopOperation.setCameraAttributes(camera, params);
    if (isBooleanTrue(params.showHelper)) {
      this._addHelper(childCameras);
    } else {
      this._removeHelper(childCameras);
    }
  }
  static _addHelper(childCameras) {
    for (const childCamera of childCameras) {
      const helper = new CameraHelper(childCamera);
      helper.update();
      childCamera.add(helper);
    }
  }
  static _removeHelper(childCameras) {
    for (const childCamera of childCameras) {
      const helpers = childCamera.children.filter((c) => c instanceof CameraHelper);
      for (const helper of helpers) {
        childCamera.remove(helper);
      }
    }
  }
  static createCamera(params, nodeGenerator) {
    const cubeRenderTarget = new WebGLCubeRenderTarget(params.resolution);
    registerObjectType({
      type: ObjectType.CUBE_CAMERA,
      checkFunc: (o) => {
        if (o.renderTarget) {
          return ObjectType.CUBE_CAMERA;
        }
      },
      ctor: CubeCameraExtended,
      humanName: ObjectType.CUBE_CAMERA
    });
    const camera = new CubeCameraExtended(params.near, params.far, cubeRenderTarget);
    if (nodeGenerator) {
      ThreejsCoreObject.addAttribute(camera, CameraAttribute.NODE_ID, nodeGenerator.graphNodeId());
    }
    return camera;
  }
  static setCameraAttributes(camera, options) {
  }
};
export let CubeCameraSopOperation = _CubeCameraSopOperation;
CubeCameraSopOperation.DEFAULT_PARAMS = {
  near: CORE_CAMERA_DEFAULT.near,
  far: CORE_CAMERA_DEFAULT.far,
  resolution: CUBE_CAMERA_DEFAULT.resolution,
  position: new Vector3(0, 0, 0),
  rotation: new Vector3(0, 0, 0),
  showHelper: false,
  matrixAutoUpdate: true,
  name: CameraNodeType.CUBE
};
CubeCameraSopOperation.INPUT_CLONED_STATE = InputCloneMode.NEVER;
CubeCameraSopOperation.onRegister = registerCubeCamera;
