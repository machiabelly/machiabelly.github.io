"use strict";
import { ParamEvent } from "./../poly/ParamEvent";
import { DecomposedPath } from "../../core/DecomposedPath";
import { TypedStringParam } from "./_BaseString";
export class TypedPathParam extends TypedStringParam {
  constructor() {
    super(...arguments);
    this.decomposedPath = new DecomposedPath();
  }
  dispose() {
    this.scene().referencesController.resetReferenceFromParam(this);
    super.dispose();
  }
  _handleReferences(node, path) {
    if (path == "") {
      return;
    }
    this.scene().referencesController.setNamedNodesFromParam(this);
    if (node) {
      this.scene().referencesController.setReferenceFromParam(this, node);
      this.scene().missingExpressionReferencesController.deregisterParam(this);
    } else {
      this.scene().missingExpressionReferencesController.register(this, path);
    }
  }
  async processComputation() {
    var _a;
    if (((_a = this.expressionController) == null ? void 0 : _a.active()) && !this.expressionController.entitiesDependent()) {
      await super.processComputation();
    } else {
      this._findTarget();
    }
  }
  processRawInputWithoutExpression() {
    const wasErrored = this.states.error.active();
    if (this._value.path() != this._raw_input || this._expression_controller || wasErrored) {
      this._setValuePathAndFindTarget(this._raw_input, true);
      this.states.error.clear();
      this.emitController.emit(ParamEvent.VALUE_UPDATED);
      this.options.executeCallback();
      if (this._expression_controller) {
        this._expression_controller.setExpression(void 0, false);
        this._expression_controller = void 0;
        this.emitController.emit(ParamEvent.EXPRESSION_UPDATED);
      }
    }
  }
  _setValuePathAndFindTarget(path, setDirty) {
    this._value.setPath(path);
    this._findTarget();
    if (setDirty) {
      this.setDirty();
    }
    this.emitController.emit(ParamEvent.VALUE_UPDATED);
  }
}
