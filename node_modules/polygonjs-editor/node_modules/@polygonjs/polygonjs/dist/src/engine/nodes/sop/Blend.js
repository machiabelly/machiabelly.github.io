"use strict";
import { TypedSopNode } from "./_Base";
import { NodeParamsConfig, ParamConfig } from "../utils/params/ParamsConfig";
import { InputCloneMode } from "../../poly/InputCloneMode";
import { isBooleanTrue } from "../../../core/Type";
import { SopType } from "../../poly/registers/nodes/types/Sop";
class BlendSopParamsConfig extends NodeParamsConfig {
  constructor() {
    super(...arguments);
    /** @param name of the attribute to blend */
    this.attribName = ParamConfig.STRING("position");
    /** @param blend value. 0 means the result will equal the left input, 1 will equal the right input, and 0.5 will be an average of both. */
    this.blend = ParamConfig.FLOAT(0.5, {
      range: [0, 1],
      rangeLocked: [true, true]
    });
    /** @param update normals */
    this.updateNormals = ParamConfig.BOOLEAN(1);
  }
}
const ParamsConfig = new BlendSopParamsConfig();
export class BlendSopNode extends TypedSopNode {
  constructor() {
    super(...arguments);
    this.paramsConfig = ParamsConfig;
  }
  static type() {
    return SopType.BLEND;
  }
  initializeNode() {
    this.io.inputs.setCount(2);
    this.io.inputs.initInputsClonedState([InputCloneMode.FROM_NODE, InputCloneMode.NEVER]);
  }
  cook(inputCoreGroups) {
    const coreGroup0 = inputCoreGroups[0];
    const coreGroup1 = inputCoreGroups[1];
    const objects0 = coreGroup0.threejsObjects();
    const objects1 = coreGroup1.threejsObjects();
    for (let i = 0; i < objects0.length; i++) {
      this.blend(objects0[i], objects1[i], this.pv.blend);
    }
    this.setCoreGroup(coreGroup0);
  }
  blend(object0, object1, blend) {
    const geometry0 = object0.geometry;
    const geometry1 = object1.geometry;
    if (geometry0 == null || geometry1 == null) {
      return;
    }
    const attrib0 = geometry0.getAttribute(this.pv.attribName);
    const attrib1 = geometry1.getAttribute(this.pv.attribName);
    if (attrib0 == null || attrib1 == null) {
      return;
    }
    const attrib0_array = attrib0.array;
    const attrib1_array = attrib1.array;
    let c0, c1;
    for (let i = 0; i < attrib0_array.length; i++) {
      c0 = attrib0_array[i];
      c1 = attrib1_array[i];
      if (c1 != null) {
        attrib0_array[i] = (1 - blend) * c0 + blend * c1;
      }
    }
    if (isBooleanTrue(this.pv.updateNormals)) {
      geometry0.computeVertexNormals();
    }
  }
}
