"use strict";
import { TypedJsNode } from "./_Base";
import { JsConnectionPointType } from "../utils/io/connections/Js";
import { JsType } from "../../poly/registers/nodes/types/Js";
export const ATTRIBUTE_NODE_AVAILABLE_JS_TYPES = [
  JsConnectionPointType.COLOR,
  JsConnectionPointType.FLOAT,
  JsConnectionPointType.INT,
  JsConnectionPointType.VECTOR2,
  JsConnectionPointType.VECTOR3,
  JsConnectionPointType.VECTOR4
];
import { NodeParamsConfig, ParamConfig } from "../utils/params/ParamsConfig";
import { isBooleanTrue } from "../../../core/Type";
export var AttributeJsNodeInput = /* @__PURE__ */ ((AttributeJsNodeInput2) => {
  AttributeJsNodeInput2["EXPORT"] = "export";
  return AttributeJsNodeInput2;
})(AttributeJsNodeInput || {});
export var AttributeJsNodeOutput = /* @__PURE__ */ ((AttributeJsNodeOutput2) => {
  AttributeJsNodeOutput2["VAL"] = "val";
  return AttributeJsNodeOutput2;
})(AttributeJsNodeOutput || {});
class AttributeJsParamsConfig extends NodeParamsConfig {
  constructor() {
    super(...arguments);
    this.name = ParamConfig.STRING("");
    this.type = ParamConfig.INTEGER(0, {
      menu: {
        entries: ATTRIBUTE_NODE_AVAILABLE_JS_TYPES.map((name, i) => {
          return { name, value: i };
        })
      }
    });
    /** @param allows to export the attribute */
    this.exportWhenConnected = ParamConfig.BOOLEAN(0);
  }
}
const ParamsConfig = new AttributeJsParamsConfig();
export class AttributeJsNode extends TypedJsNode {
  constructor() {
    super(...arguments);
    this.paramsConfig = ParamsConfig;
  }
  static type() {
    return JsType.ATTRIBUTE;
  }
  // private _update_signature_if_required_bound = this._update_signature_if_required.bind(this);
  initializeNode() {
    this.io.connection_points.initializeNode();
    this.io.connection_points.set_expected_input_types_function(() => this._expectedInputTypes());
    this.io.connection_points.set_input_name_function((index) => this.inputName());
    this.io.connection_points.set_expected_output_types_function(() => [this._expectedOutputType()]);
  }
  // inputless_params_names(): string[] {
  // 	return ['type'];
  // }
  _expectedInputTypes() {
    return this.pv.exportWhenConnected ? [this._expectedOutputType()] : [];
  }
  _expectedOutputType() {
    return ATTRIBUTE_NODE_AVAILABLE_JS_TYPES[this.pv.type];
  }
  inputName() {
    return "export" /* EXPORT */;
  }
  outputName() {
    return "val" /* VAL */;
  }
  setLines(linesController) {
    var _a, _b;
    (_b = (_a = this.functionNode()) == null ? void 0 : _a.assemblerController()) == null ? void 0 : _b.assembler.setNodeLinesAttribute(this, linesController);
  }
  attribData() {
    return {
      attribName: this.attributeName(),
      attribType: this.jsType()
    };
  }
  attributeName() {
    return this.pv.name.trim();
  }
  jsType() {
    const connectionPoints = this.io.outputs.namedOutputConnectionPoints();
    if (!connectionPoints) {
      return JsConnectionPointType.FLOAT;
    }
    return connectionPoints[0].type();
  }
  setJsType(type) {
    this.p.type.set(ATTRIBUTE_NODE_AVAILABLE_JS_TYPES.indexOf(type));
  }
  //
  //
  // Utility methods for SOP/ParticlesSystemGPU and Assembler/Particles
  //
  //
  connected_input_node() {
    return this.io.inputs.named_input("export" /* EXPORT */);
  }
  connected_input_connection_point() {
    return this.io.inputs.named_input_connection_point("export" /* EXPORT */);
  }
  output_connection_point() {
    return this.io.outputs.namedOutputConnectionPointsByName(this.inputName());
  }
  isImporting() {
    return this.io.outputs.used_output_names().length > 0;
  }
  isExporting() {
    if (isBooleanTrue(this.pv.exportWhenConnected)) {
      const inputNode = this.io.inputs.named_input("export" /* EXPORT */);
      return inputNode != null;
    } else {
      return false;
    }
  }
  // private _set_mat_to_recompile_if_is_exporting() {
  // 	if (this.is_exporting) {
  // 		this._set_function_node_to_recompile();
  // 	}
  // }
}
