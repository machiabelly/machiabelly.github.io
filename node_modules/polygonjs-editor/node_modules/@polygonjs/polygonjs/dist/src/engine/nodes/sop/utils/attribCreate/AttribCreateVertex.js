"use strict";
import { CoreAttribute } from "../../../../../core/geometry/Attribute";
import { initArrayIfRequired } from "./Common";
import { AttribType } from "../../../../../core/geometry/Constant";
import { TypeAssert } from "../../../../poly/Assert";
import { verticesFromObjectFromGroup } from "../../../../../core/geometry/entities/vertex/CoreVertexUtils";
import { coreVertexClassFactory } from "../../../../../core/geometry/CoreObjectFactory";
const _arraysByObject = {
  X: /* @__PURE__ */ new WeakMap(),
  Y: /* @__PURE__ */ new WeakMap(),
  Z: /* @__PURE__ */ new WeakMap(),
  W: /* @__PURE__ */ new WeakMap()
};
const arraysByGeometryUuid = [_arraysByObject.X, _arraysByObject.Y, _arraysByObject.Z, _arraysByObject.W];
export async function addVertexAttribute(attribType, coreGroup, params) {
  const objects = coreGroup.allObjects();
  switch (attribType) {
    case AttribType.NUMERIC: {
      for (const object of objects) {
        await _addNumericAttributeToVertices(object, params);
      }
      return;
    }
    case AttribType.STRING: {
      for (const object of objects) {
        await _addStringAttributeToVertices(object, params);
      }
      return;
    }
  }
  TypeAssert.unreachable(attribType);
}
async function _addNumericAttributeToVertices(object, params) {
  const vertices = [];
  verticesFromObjectFromGroup(object, params.group.value, vertices);
  const attribName = CoreAttribute.remapName(params.name.value);
  const size = params.size.value;
  const param = [params.value1, params.value2, params.value3, params.value4][size - 1];
  if (param.hasExpression()) {
    const vertexClass = coreVertexClassFactory(object);
    let attribute = vertexClass.attribute(object, attribName);
    if (!attribute) {
      const verticesCount = vertexClass.entitiesCount(object);
      const values = new Array(verticesCount * size).fill(0);
      attribute = { array: values, itemSize: size, isString: false };
      vertexClass.addAttribute(object, attribName, attribute);
    }
    const array = attribute.array;
    if (size == 1) {
      const paramN = params.value1;
      if (paramN.expressionController) {
        if (paramN.expressionController.entitiesDependent()) {
          await paramN.expressionController.computeExpressionForVertices(
            vertices,
            (primitive, value) => {
              array[primitive.index() * size + 0] = value;
            }
          );
        } else {
          for (const vertex of vertices) {
            array[vertex.index() * size + 0] = paramN.value;
          }
        }
      }
    } else {
      const vparam = [params.value2, params.value3, params.value4][size - 2];
      const components = vparam.components;
      const tmpArrays = new Array(components.length);
      for (let i = 0; i < components.length; i++) {
        const componentParam = components[i];
        if (componentParam.hasExpression() && componentParam.expressionController) {
          tmpArrays[i] = initArrayIfRequired(object, arraysByGeometryUuid[i], vertices.length);
          if (componentParam.expressionController.entitiesDependent()) {
            await componentParam.expressionController.computeExpressionForVertices(
              vertices,
              (point, value) => {
                tmpArrays[i][point.index()] = value;
              }
            );
          } else {
            for (const vertex of vertices) {
              tmpArrays[i][vertex.index()] = componentParam.value;
            }
          }
        } else {
          const value = componentParam.value;
          for (const vertex of vertices) {
            array[vertex.index() * size + i] = value;
          }
        }
      }
      for (let j = 0; j < tmpArrays.length; j++) {
        const tmpArray = tmpArrays[j];
        if (tmpArray != null) {
          for (let i = 0; i < tmpArray.length; i++) {
            const newVal = tmpArray[i];
            if (newVal != null) {
              array[i * size + j] = newVal;
            }
          }
        }
      }
    }
  } else {
  }
}
async function _addStringAttributeToVertices(object, params) {
  const vertices = [];
  verticesFromObjectFromGroup(object, params.group.value, vertices);
  const param = params.string;
  const attribName = params.name.value;
  if (param.hasExpression() && param.expressionController) {
    const vertexClass = coreVertexClassFactory(object);
    const verticesCount = vertexClass.entitiesCount(object);
    const values = new Array(verticesCount).fill("");
    let attribute = vertexClass.attribute(object, attribName);
    if (!attribute) {
      attribute = { array: values, itemSize: 1, isString: true };
      vertexClass.addAttribute(object, attribName, attribute);
    }
    if (param.expressionController.entitiesDependent()) {
      await param.expressionController.computeExpressionForVertices(vertices, (vertex, value) => {
        values[vertex.index()] = value;
      });
    } else {
      for (const vertex of vertices) {
        values[vertex.index()] = param.value;
      }
    }
  } else {
  }
}
