"use strict";
import { TypedSopNode } from "./_Base";
import { InputCloneMode } from "../../poly/InputCloneMode";
import { NodeParamsConfig, ParamConfig } from "../utils/params/ParamsConfig";
import {
  SortSopOperation,
  AXISES,
  SORT_MODES,
  SortMode,
  SORT_TARGET_TYPES
} from "../../operations/sop/Sort";
import { SopType } from "../../poly/registers/nodes/types/Sop";
const DEFAULT = SortSopOperation.DEFAULT_PARAMS;
class SortSopParamsConfig extends NodeParamsConfig {
  constructor() {
    super(...arguments);
    /** @param defines if this node will sort points or objects */
    this.targetType = ParamConfig.INTEGER(DEFAULT.targetType, {
      menu: {
        entries: SORT_TARGET_TYPES.map((name, value) => ({ name, value }))
      }
    });
    /** @param criteria used to sort */
    this.mode = ParamConfig.INTEGER(DEFAULT.mode, {
      menu: {
        entries: SORT_MODES.map((name, value) => ({ name, value }))
      }
    });
    /** @param seed used by the random mode */
    this.seed = ParamConfig.INTEGER(DEFAULT.seed, {
      range: [0, 100],
      rangeLocked: [false, false],
      visibleIf: { mode: SORT_MODES.indexOf(SortMode.RANDOM) }
    });
    /** @param axis along which points will be sorted */
    this.axis = ParamConfig.INTEGER(DEFAULT.axis, {
      menu: {
        entries: AXISES.map((name, value) => {
          return { name, value };
        })
      },
      visibleIf: { mode: SORT_MODES.indexOf(SortMode.AXIS) }
    });
    /** @param attribute */
    this.attribute = ParamConfig.STRING(DEFAULT.attribute, {
      visibleIf: { mode: SORT_MODES.indexOf(SortMode.ATTRIBUTE) }
    });
    /** @param invert the sort */
    this.invert = ParamConfig.BOOLEAN(DEFAULT.invert);
  }
}
const ParamsConfig = new SortSopParamsConfig();
export class SortSopNode extends TypedSopNode {
  constructor() {
    super(...arguments);
    this.paramsConfig = ParamsConfig;
  }
  static type() {
    return SopType.SORT;
  }
  initializeNode() {
    this.io.inputs.setCount(1);
    this.io.inputs.initInputsClonedState([InputCloneMode.FROM_NODE]);
  }
  cook(inputCoreGroups) {
    this._operation = this._operation || new SortSopOperation(this._scene, this.states, this);
    const coreGroup = this._operation.cook(inputCoreGroups, this.pv);
    this.setCoreGroup(coreGroup);
  }
  setAttribClass(attribClass) {
    if (SORT_TARGET_TYPES.includes(attribClass)) {
      this.p.targetType.set(SORT_TARGET_TYPES.indexOf(attribClass));
    } else {
      console.warn(`${attribClass} is not possible on this node`);
    }
  }
  attribClass() {
    return SORT_TARGET_TYPES[this.pv.targetType];
  }
  setSortMode(mode) {
    this.p.mode.set(SORT_MODES.indexOf(mode));
  }
  setTargetType(targetType) {
    this.p.targetType.set(SORT_TARGET_TYPES.indexOf(targetType));
  }
}
