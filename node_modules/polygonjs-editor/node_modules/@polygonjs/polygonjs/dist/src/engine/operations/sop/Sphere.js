"use strict";
import { BaseSopOperation } from "./_Base";
import { IcosahedronGeometry, Vector2, Vector3, Box3 } from "three";
import { InputCloneMode } from "../../../engine/poly/InputCloneMode";
import { isBooleanTrue } from "../../../core/BooleanValue";
import { ObjectType } from "../../../core/geometry/Constant";
import { SphereBuilder } from "../../../core/geometry/builders/SphereBuilder";
const tmpBox = new Box3();
const tmpSize = new Vector3();
const tmpCenter = new Vector3();
var SphereType = /* @__PURE__ */ ((SphereType2) => {
  SphereType2["DEFAULT"] = "default";
  SphereType2["ISOCAHEDRON"] = "isocahedron";
  return SphereType2;
})(SphereType || {});
export const SPHERE_TYPE = {
  default: 0,
  isocahedron: 1
};
export const SPHERE_TYPES = ["default" /* DEFAULT */, "isocahedron" /* ISOCAHEDRON */];
export class SphereSopOperation extends BaseSopOperation {
  static type() {
    return "sphere";
  }
  cook(inputCoreGroups, params) {
    const coreGroup = inputCoreGroups[0];
    const object = coreGroup ? this._cookWithInput(coreGroup, params) : this._cookWithoutInput(params);
    if (this._node) {
      object.name = this._node.name();
    }
    return this.createCoreGroupFromObjects([object]);
  }
  _cookWithoutInput(params) {
    const geometry = this._createRequiredGeometry(params);
    geometry.translate(params.center.x, params.center.y, params.center.z);
    const object = this._createSphereObject(geometry, params);
    return object;
  }
  _cookWithInput(coreGroup, params) {
    coreGroup.boundingBox(tmpBox);
    tmpBox.getSize(tmpSize);
    tmpBox.getCenter(tmpCenter);
    const geometry = this._createRequiredGeometry(params);
    geometry.scale(tmpSize.x, tmpSize.y, tmpSize.z);
    geometry.translate(params.center.x, params.center.y, params.center.z);
    geometry.translate(tmpCenter.x, tmpCenter.y, tmpCenter.z);
    const object = this._createSphereObject(geometry, params);
    return object;
  }
  _createSphereObject(geometry, params) {
    return BaseSopOperation.createObject(geometry, params.asLines ? ObjectType.LINE_SEGMENTS : ObjectType.MESH);
  }
  _createRequiredGeometry(params) {
    if (params.type == SPHERE_TYPE.default) {
      return this._createDefaultSphere(params);
    } else {
      return this._createDefaultIsocahedron(params);
    }
  }
  _createDefaultSphere(params) {
    const geometry = isBooleanTrue(params.open) ? SphereBuilder.create({
      radius: params.radius,
      widthSegments: params.resolution.x,
      heightSegments: params.resolution.y,
      phiStart: params.phiStart,
      phiLength: params.phiLength,
      thetaStart: params.thetaStart,
      thetaLength: params.thetaLength,
      asLines: params.asLines,
      open: true
    }) : SphereBuilder.create({
      radius: params.radius,
      widthSegments: params.resolution.x,
      heightSegments: params.resolution.y,
      asLines: params.asLines,
      open: false
    });
    return geometry;
  }
  _createDefaultIsocahedron(params) {
    return new IcosahedronGeometry(params.radius, params.detail);
  }
}
SphereSopOperation.DEFAULT_PARAMS = {
  type: SPHERE_TYPE.default,
  radius: 1,
  resolution: new Vector2(30, 30),
  open: false,
  phiStart: 0,
  phiLength: Math.PI * 2,
  thetaStart: 0,
  thetaLength: Math.PI,
  detail: 1,
  center: new Vector3(0, 0, 0),
  asLines: false
};
SphereSopOperation.INPUT_CLONED_STATE = InputCloneMode.NEVER;
