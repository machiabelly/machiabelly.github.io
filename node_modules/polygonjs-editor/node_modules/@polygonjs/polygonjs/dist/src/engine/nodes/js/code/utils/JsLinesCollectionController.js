"use strict";
import {
  ComputedValueJsDefinition,
  TriggerableJsDefinition,
  TriggeringJsDefinition
} from "../../utils/JsDefinition";
import { JsLinesController } from "./LinesController";
import { JsConnectionPointType } from "../../../utils/io/connections/Js";
import { nodeMethodName, triggerableMethodCalls } from "../assemblers/actor/ActorAssemblerUtils";
export class JsLinesCollectionController {
  constructor(_shaderNames, _currentShaderName, _assembler) {
    this._shaderNames = _shaderNames;
    this._currentShaderName = _currentShaderName;
    this._assembler = _assembler;
    this._linesControllerByShaderName = /* @__PURE__ */ new Map();
    for (const shaderName of this._shaderNames) {
      this._linesControllerByShaderName.set(shaderName, new JsLinesController(shaderName));
    }
  }
  // private _allowActionLines = false;
  // withAllowActionLines(callback: () => void) {
  // 	this._allowActionLines = true;
  // 	callback();
  // 	this._allowActionLines = false;
  // }
  // mergeDefinitions(shadersCollectionController: ShadersCollectionController) {
  // 	for (let shaderName of this._shaderNames) {
  // 		// this._linesControllerByShaderName.set(shaderName, new LinesController(shaderName));
  // 		shadersCollectionController.traverseDefinitions(shaderName, (definition: BaseGLDefinition) => {
  // 			this.addDefinitions(definition.node, [definition], shaderName);
  // 			console.log('add', definition.node, definition);
  // 		});
  // 	}
  // }
  assembler() {
    return this._assembler;
  }
  linesController(shaderName) {
    return this._linesControllerByShaderName.get(shaderName);
  }
  shaderNames() {
    return this._shaderNames;
  }
  setCurrentShaderName(shaderName) {
    this._currentShaderName = shaderName;
  }
  currentShaderName() {
    return this._currentShaderName;
  }
  //
  //
  // REGISTERED VARIABLES
  //
  //
  addVariable(node, variable, varName) {
    return this.assembler().addVariable(node, variable, varName);
  }
  //
  //
  // REGISTERED FUNCTIONS
  //
  //
  addFunction(node, namedFunction) {
    return this.assembler().addFunction(node, namedFunction);
  }
  addTriggeringLines(node, triggeringLines, options) {
    const gatherable = (options == null ? void 0 : options.gatherable) != null ? options.gatherable : false;
    const triggeringMethodName = (options == null ? void 0 : options.triggeringMethodName) != null ? options.triggeringMethodName : node.type();
    const value = triggeringLines.join("\n");
    const varName = options.nodeMethodName || nodeMethodName(node);
    const dataType = JsConnectionPointType.BOOLEAN;
    this.addDefinitions(node, [
      new TriggeringJsDefinition(node, this, dataType, varName, value, {
        triggeringMethodName,
        gatherable,
        perPoint: this._assembler.perPoint(),
        nodeMethodName: options.nodeMethodName
      })
    ]);
  }
  addTriggerableLines(node, triggerableLines, options) {
    const addTriggeredLines = (options == null ? void 0 : options.addTriggeredLines) != null ? options.addTriggeredLines : true;
    if (addTriggeredLines) {
      const _triggerableMethodCalls = triggerableMethodCalls(node);
      triggerableLines.push(_triggerableMethodCalls);
    }
    const value = triggerableLines.join("\n");
    const varName = node.name();
    const dataType = JsConnectionPointType.BOOLEAN;
    this.addDefinitions(node, [new TriggerableJsDefinition(node, this, dataType, varName, value, options)]);
  }
  //
  //
  //
  //
  //
  addComputedVarName(varName) {
    this._assembler.addComputedVarName(varName);
  }
  registeredAsComputed(varName) {
    return this._assembler.registeredAsComputed(varName);
  }
  addBodyOrComputed(node, linesData, options) {
    if (this._assembler.computedVariablesAllowed()) {
      this.addComputed(node, linesData);
    } else {
      const constPrefix = (options == null ? void 0 : options.constPrefix) != null ? options.constPrefix : true;
      this._addBodyLines(
        node,
        linesData.map((lineData) => {
          const { varName, value } = lineData;
          const bodyLine = `${constPrefix ? "const" : ""} ${varName} = ${value}`;
          return bodyLine;
        })
      );
    }
  }
  addComputed(node, linesData) {
    this.addDefinitions(
      node,
      linesData.map((lineData) => {
        const { dataType, varName, value } = lineData;
        return new ComputedValueJsDefinition(node, this, dataType, varName, value);
      })
    );
  }
  addDefinitions(node, definitions, shaderName) {
    if (definitions.length == 0) {
      return;
    }
    shaderName = shaderName || this._currentShaderName;
    const linesController = this._linesControllerByShaderName.get(shaderName);
    if (linesController) {
      linesController.addDefinitions(node, definitions);
    }
  }
  definitions(shaderName, node) {
    const linesController = this._linesControllerByShaderName.get(shaderName);
    if (linesController) {
      return linesController.definitions(node);
    }
  }
  traverseDefinitions(shaderName, callback) {
    const linesController = this._linesControllerByShaderName.get(shaderName);
    if (linesController) {
      linesController.traverseDefinitions(callback);
    }
  }
  // all_definition_nodes(shader_name: ShaderName, scene: PolyScene) {
  // 	return this._lines_controller_by_shader_name.get(shader_name)?.all_definition_nodes(scene) || [];
  // }
  // addActionBodyLines(node: BaseJsNodeType, lines: string[]) {
  // 	// if (!this._allowActionLines) {
  // 	// 	return;
  // 	// }
  // 	this.addBodyLines(node, lines);
  // }
  _addBodyLines(node, lines, shaderName, options) {
    if (lines.length == 0) {
      return;
    }
    shaderName = shaderName || this._currentShaderName;
    const linesController = this._linesControllerByShaderName.get(shaderName);
    if (linesController) {
      linesController.addBodyLines(node, lines, options);
    }
  }
  bodyLines(shaderName, node) {
    const linesController = this._linesControllerByShaderName.get(shaderName);
    if (linesController) {
      return linesController.bodyLines(node);
    }
  }
  // traverseBodyLines(shaderName: ShaderName, callback: BodyLinesTraverseCallback) {
  // 	const lines_controller = this._linesControllerByShaderName.get(shaderName);
  // 	if (lines_controller) {
  // 		return lines_controller.traverseBodyLines(callback);
  // 	}
  // }
  // all_body_line_nodes(shader_name: ShaderName, scene: PolyScene) {
  // 	return this._lines_controller_by_shader_name.get(shader_name)?.all_body_line_nodes(scene) || [];
  // }
}
