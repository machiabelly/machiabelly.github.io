"use strict";
import { TypedJsNode } from "./_Base";
import { NodeParamsConfig, ParamConfig } from "../utils/params/ParamsConfig";
import { JsConnectionPointType } from "../utils/io/connections/Js";
import { Vector3 } from "three";
import { Poly } from "../../Poly";
import { PrimitiveArray, VectorArray } from "./code/assemblers/_BaseJsPersistedConfigUtils";
const ALLOWED_TYPES = [JsConnectionPointType.VECTOR4, JsConnectionPointType.VECTOR4_ARRAY];
var OutputName = /* @__PURE__ */ ((OutputName2) => {
  OutputName2["Vector3"] = "Vector3";
  OutputName2["w"] = "w";
  return OutputName2;
})(OutputName || {});
class Vec4ToVec3ParamsJsConfig extends NodeParamsConfig {
  constructor() {
    super(...arguments);
    this.Vector4 = ParamConfig.VECTOR4([0, 0, 0, 0]);
  }
}
const ParamsConfig_Vec4ToVec3 = new Vec4ToVec3ParamsJsConfig();
export class Vec4ToVec3JsNode extends TypedJsNode {
  constructor() {
    super(...arguments);
    this.paramsConfig = ParamsConfig_Vec4ToVec3;
  }
  static type() {
    return "vec4ToVec3";
  }
  // static readonly INPUT_NAME_VEC4 = 'vec4';
  // static readonly OUTPUT_NAME_VEC3 = 'vec3';
  // static readonly OUTPUT_NAME_W = 'w';
  initializeNode() {
    this.io.connection_points.set_input_name_function(this._expectedInputName.bind(this));
    this.io.connection_points.set_output_name_function(this._expectedOutputName.bind(this));
    this.io.connection_points.set_expected_input_types_function(this._expectedInputTypes.bind(this));
    this.io.connection_points.set_expected_output_types_function(this._expectedOutputTypes.bind(this));
  }
  _expectedInputName(index) {
    return this._expectedInputTypes()[0];
  }
  _expectedOutputName(index) {
    return ["Vector3" /* Vector3 */, "w" /* w */][index];
  }
  _expectedInputTypes() {
    const firstInputType = this.io.connection_points.first_input_connection_type();
    const type = firstInputType != null && ALLOWED_TYPES.includes(firstInputType) ? firstInputType : JsConnectionPointType.VECTOR4;
    return [type];
  }
  _expectedOutputTypes() {
    const firstInputTypes = this._expectedInputTypes()[0];
    switch (firstInputTypes) {
      case JsConnectionPointType.VECTOR4_ARRAY: {
        return [JsConnectionPointType.VECTOR3_ARRAY, JsConnectionPointType.FLOAT_ARRAY];
      }
      default: {
        return [JsConnectionPointType.VECTOR3, JsConnectionPointType.FLOAT];
      }
    }
  }
  setLines(shadersCollectionController) {
    const firstType = this._expectedInputTypes()[0];
    switch (firstType) {
      case JsConnectionPointType.VECTOR4: {
        return this._setLinesAsVector4(shadersCollectionController);
      }
      case JsConnectionPointType.VECTOR4_ARRAY: {
        return this._setLinesAsVector4Array(shadersCollectionController);
      }
    }
  }
  _setLinesAsVector4(shadersCollectionController) {
    const usedOutputNames = this.io.outputs.used_output_names();
    const vec4 = this.variableForInput(shadersCollectionController, this._expectedInputName(0));
    const _v3 = (propertyName, functionName, type) => {
      if (!usedOutputNames.includes(propertyName)) {
        return;
      }
      const varName = this.jsVarName(propertyName);
      const tmpVarName = shadersCollectionController.addVariable(this, new Vector3());
      const func = Poly.namedFunctionsRegister.getFunction(functionName, this, shadersCollectionController);
      shadersCollectionController.addBodyOrComputed(this, [
        {
          dataType: type,
          varName,
          value: func.asString(vec4, tmpVarName)
        }
      ]);
    };
    const _f = (propertyName, type) => {
      if (!usedOutputNames.includes(propertyName)) {
        return;
      }
      shadersCollectionController.addBodyOrComputed(this, [
        {
          dataType: type,
          varName: this.jsVarName(propertyName),
          value: `${vec4}.w`
        }
      ]);
    };
    _v3("Vector3" /* Vector3 */, "sizzleVec4XYZ", JsConnectionPointType.VECTOR3);
    _f("w" /* w */, JsConnectionPointType.FLOAT);
  }
  _setLinesAsVector4Array(shadersCollectionController) {
    const usedOutputNames = this.io.outputs.used_output_names();
    const vec4 = this.variableForInput(shadersCollectionController, this._expectedInputName(0));
    const _v3 = (propertyName, functionName, type) => {
      if (!usedOutputNames.includes(propertyName)) {
        return;
      }
      const varName = this.jsVarName(propertyName);
      const tmpVarName = shadersCollectionController.addVariable(this, new VectorArray([new Vector3()]));
      const func = Poly.namedFunctionsRegister.getFunction(functionName, this, shadersCollectionController);
      shadersCollectionController.addBodyOrComputed(this, [
        {
          dataType: type,
          varName,
          value: func.asString(vec4, tmpVarName)
        }
      ]);
    };
    const _f = (propertyName, functionName, type) => {
      if (!usedOutputNames.includes(propertyName)) {
        return;
      }
      const varName = this.jsVarName(propertyName);
      const tmpVarName = shadersCollectionController.addVariable(this, new PrimitiveArray([0]));
      const func = Poly.namedFunctionsRegister.getFunction(functionName, this, shadersCollectionController);
      shadersCollectionController.addBodyOrComputed(this, [
        {
          dataType: type,
          varName,
          value: func.asString(vec4, tmpVarName)
        }
      ]);
    };
    _v3("Vector3" /* Vector3 */, "sizzleVec4XYZArray", JsConnectionPointType.VECTOR3_ARRAY);
    _f("w" /* w */, "sizzleVec4WArray", JsConnectionPointType.FLOAT_ARRAY);
  }
}
