"use strict";
import {
  paramTypeToConnectionPointTypeMap,
  createConnectionPoint
} from "./connections/ConnectionMap";
import { ParamType } from "../../../poly/ParamType";
import { CoreType } from "../../../../core/Type";
import { objectClone } from "../../../../core/ObjectUtils";
export class ConnectionPointsSpareParamsController {
  constructor(node, _context) {
    this.node = node;
    this._context = _context;
    this._raw_input_serialized_by_param_name = /* @__PURE__ */ new Map();
    this._default_value_serialized_by_param_name = /* @__PURE__ */ new Map();
    // disallow_inputs_created_from_params() {
    // 	this._allow_inputs_created_from_params = false;
    // }
    this._initialized = false;
  }
  initializeNode() {
    if (this._initialized) {
      console.warn("already initialized", this.node);
      return;
    }
    this._initialized = true;
    this.node.params.onParamsCreated("createInputsFromParams", this._createInputsFromParams.bind(this));
  }
  initialized() {
    return this._initialized;
  }
  _createInputsFromParams() {
    const connectionTypeMap = paramTypeToConnectionPointTypeMap(this._context);
    if (!connectionTypeMap) {
      return;
    }
    const connectionPoints = [];
    for (const paramName of this.node.params.names) {
      let addInput = true;
      if (this._inputlessParamNames && this._inputlessParamNames.length > 0 && this._inputlessParamNames.includes(paramName)) {
        addInput = false;
      }
      if (addInput) {
        if (this.node.params.has(paramName)) {
          const param = this.node.params.get(paramName);
          if (param && !param.parentParam()) {
            const connectionType = connectionTypeMap[param.type()];
            if (connectionType) {
              const connectionPoint = createConnectionPoint(
                this._context,
                param.name(),
                connectionType
              );
              if (connectionPoint) {
                connectionPoints.push(connectionPoint);
              }
            }
          }
        }
      }
    }
    this.node.io.inputs.setNamedInputConnectionPoints(connectionPoints);
  }
  setInputlessParamNames(names) {
    return this._inputlessParamNames = names;
  }
  //
  // Create spare params on gl nodes
  //
  createSpareParameters() {
    if (this.node.scene().loadingController.isLoading()) {
      return;
    }
    const current_param_names = this.node.params.spare_names;
    const params_update_options = {};
    for (const param_name of current_param_names) {
      if (this.node.params.has(param_name)) {
        const param = this.node.params.get(param_name);
        if (param) {
          this._raw_input_serialized_by_param_name.set(param_name, param.rawInputSerialized());
          this._default_value_serialized_by_param_name.set(param_name, param.defaultValueSerialized());
          params_update_options.namesToDelete = params_update_options.namesToDelete || [];
          params_update_options.namesToDelete.push(param_name);
        }
      }
    }
    const inputConnectionPoints = this.node.io.inputs.namedInputConnectionPoints();
    if (inputConnectionPoints) {
      let i = 0;
      for (const connection_point of inputConnectionPoints) {
        if (connection_point) {
          const isConnected = this.node.io.inputs.input(i) != null;
          const param_name = connection_point.name();
          const paramType = connection_point.param_type;
          if (paramType) {
            let init_value = connection_point.init_value;
            const last_param_init_value = this._default_value_serialized_by_param_name.get(param_name);
            let default_value_from_name = this.node.paramDefaultValue(param_name);
            if (default_value_from_name != null) {
              init_value = default_value_from_name;
            } else {
              if (last_param_init_value != null) {
                init_value = last_param_init_value;
              } else {
                init_value = connection_point.init_value;
              }
            }
            if (CoreType.isArray(connection_point.init_value)) {
              if (CoreType.isNumber(init_value)) {
                const array = new Array(connection_point.init_value.length);
                array.fill(init_value);
                init_value = array;
              } else if (CoreType.isArray(init_value)) {
                if (init_value.length == connection_point.init_value.length) {
                  if (last_param_init_value != null) {
                    init_value = connection_point.init_value;
                  }
                }
              }
            }
            if (init_value != null && paramType != ParamType.BUTTON) {
              params_update_options.toAdd = params_update_options.toAdd || [];
              params_update_options.toAdd.push({
                name: param_name,
                type: paramType,
                // TODO: I should really treat differently init_value and raw_input here
                initValue: objectClone(init_value),
                rawInput: objectClone(init_value),
                options: {
                  spare: true,
                  editable: !isConnected,
                  // computeOnDirty should be false for PARAM_PATH
                  // so that js/setParam and js/getParam can link to a parameter
                  // without having their parent node actor being recooked
                  computeOnDirty: paramType != ParamType.PARAM_PATH,
                  // dependentOnFoundParam should be false for PARAM_PATH
                  // so that js/setParam and js/getParam can link to a parameter
                  // without having their parent node actor being recooked
                  dependentOnFoundParam: false
                  // dependentOnFoundNode: true,
                }
              });
            }
          }
        }
        i++;
      }
    }
    this.node.params.updateParams(params_update_options);
    for (const spare_param of this.node.params.spare) {
      if (!spare_param.parentParam()) {
        const raw_input = this._raw_input_serialized_by_param_name.get(spare_param.name());
        if (raw_input) {
          spare_param.set(raw_input);
        }
      }
    }
  }
}
