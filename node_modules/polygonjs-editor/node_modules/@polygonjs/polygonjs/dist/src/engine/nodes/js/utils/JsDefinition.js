"use strict";
import { TypedJsDefinitionCollection } from "./JsDefinitionCollection";
import { nodeMethodName } from "../code/assemblers/actor/ActorAssemblerUtils";
import { MapUtils } from "../../../../core/MapUtils";
import { arrayUniq } from "../../../../core/ArrayUtils";
import { ActorAssemblerConstant } from "../code/assemblers/actor/ActorAssemblerCommon";
import { Poly } from "../../../Poly";
import { inputObject3D } from "../_BaseObject3D";
import { FUNC_POINTS_COUNT_FROM_OBJECT, FUNC_CORE_PRIMITIVE_CLASS_FACTORY } from "./Common";
export var JsDefinitionType = /* @__PURE__ */ ((JsDefinitionType2) => {
  JsDefinitionType2["LOCAL_FUNCTION"] = "localFunction";
  JsDefinitionType2["COMPUTED"] = "computed";
  JsDefinitionType2["CONSTANT"] = "constant";
  JsDefinitionType2["REF"] = "ref";
  JsDefinitionType2["WATCH"] = "watch";
  JsDefinitionType2["INIT_FUNCTION"] = "initFunction";
  JsDefinitionType2["TRIGGERING"] = "triggering";
  JsDefinitionType2["TRIGGERABLE"] = "triggerable";
  return JsDefinitionType2;
})(JsDefinitionType || {});
export class TypedJsDefinition {
  constructor(_definitionType, _node, _shaderCollectionController, _dataType, _name) {
    this._definitionType = _definitionType;
    this._node = _node;
    this._shaderCollectionController = _shaderCollectionController;
    this._dataType = _dataType;
    this._name = _name;
  }
  static gather(definitions, linesForShader, lineType) {
  }
  definitionType() {
    return this._definitionType;
  }
  dataType() {
    return this._dataType;
  }
  node() {
    return this._node;
  }
  name() {
    return this._name;
  }
  collectionInstance() {
    return new TypedJsDefinitionCollection();
  }
}
export class LocalFunctionJsDefinition extends TypedJsDefinition {
  constructor(_node, _shaderCollectionController, _dataType, _name, _functionDefinition) {
    super("localFunction" /* LOCAL_FUNCTION */, _node, _shaderCollectionController, _dataType, _name);
    this._node = _node;
    this._shaderCollectionController = _shaderCollectionController;
    this._dataType = _dataType;
    this._name = _name;
    this._functionDefinition = _functionDefinition;
  }
  line() {
    return this._functionDefinition;
  }
  // functionDefinition() {
  // 	return this._functionDefinition;
  // }
}
export class ComputedValueJsDefinition extends TypedJsDefinition {
  constructor(_node, _shaderCollectionController, _dataType, _name, _value) {
    super("computed" /* COMPUTED */, _node, _shaderCollectionController, _dataType, _name);
    this._node = _node;
    this._shaderCollectionController = _shaderCollectionController;
    this._dataType = _dataType;
    this._name = _name;
    this._value = _value;
    _shaderCollectionController.addComputedVarName(this.name());
  }
  line() {
    return `	${this.name()} = computed(()=> ${this._value} )`;
  }
}
export class ConstantJsDefinition extends TypedJsDefinition {
  constructor(_node, _shaderCollectionController, _dataType, _name, _value) {
    super("constant" /* CONSTANT */, _node, _shaderCollectionController, _dataType, _name);
    this._node = _node;
    this._shaderCollectionController = _shaderCollectionController;
    this._dataType = _dataType;
    this._name = _name;
    this._value = _value;
    if (this._shaderCollectionController.assembler().computedVariablesAllowed()) {
      _shaderCollectionController.addComputedVarName(this.name());
    }
  }
  line() {
    if (this._shaderCollectionController.assembler().computedVariablesAllowed()) {
      return `	${this.name()} = {value:${this._value}}`;
    } else {
      return `	${this.name()} = ${this._value}`;
    }
  }
}
export class RefJsDefinition extends TypedJsDefinition {
  constructor(_node, _shaderCollectionController, _dataType, _name, _value) {
    super("ref" /* REF */, _node, _shaderCollectionController, _dataType, _name);
    this._node = _node;
    this._shaderCollectionController = _shaderCollectionController;
    this._dataType = _dataType;
    this._name = _name;
    this._value = _value;
    _shaderCollectionController.addComputedVarName(this.name());
  }
  line() {
    return `	${this.name()} = ref(${this._value})`;
  }
}
export class WatchedValueJsDefinition extends TypedJsDefinition {
  constructor(_node, _shaderCollectionController, _dataType, _name, _value, _options) {
    super("watch" /* WATCH */, _node, _shaderCollectionController, _dataType, _name);
    this._node = _node;
    this._shaderCollectionController = _shaderCollectionController;
    this._dataType = _dataType;
    this._name = _name;
    this._value = _value;
    this._options = _options;
    _shaderCollectionController.addComputedVarName(this.name());
  }
  line() {
    const deep = this._options.deep != null ? this._options.deep : false;
    return `
		this._watchStopHandles.push(
			watch(
				${this.name()},
				( )=> {
					${this._value}
				},
				{
					deep: ${deep}
				}
			)
		)`;
  }
}
export class InitFunctionJsDefinition extends TypedJsDefinition {
  constructor(_node, _shaderCollectionController, _dataType, _name, _value) {
    super("initFunction" /* INIT_FUNCTION */, _node, _shaderCollectionController, _dataType, _name);
    this._node = _node;
    this._shaderCollectionController = _shaderCollectionController;
    this._dataType = _dataType;
    this._name = _name;
    this._value = _value;
  }
  line() {
    return `	${this._value}`;
  }
}
export class TriggeringJsDefinition extends TypedJsDefinition {
  constructor(_node, _shaderCollectionController, _dataType, _name, _value, _options) {
    super("triggering" /* TRIGGERING */, _node, _shaderCollectionController, _dataType, _name);
    this._node = _node;
    this._shaderCollectionController = _shaderCollectionController;
    this._dataType = _dataType;
    this._name = _name;
    this._value = _value;
    this._options = _options;
  }
  name() {
    return this._options.nodeMethodName || nodeMethodName(this._node);
  }
  line() {
    const methodName = this._options.nodeMethodName || nodeMethodName(this._node);
    if (this._options.perPoint) {
      const func = Poly.namedFunctionsRegister.getFunction(
        "setPointIndex",
        this._node,
        this._shaderCollectionController
      );
      const setPointIndex = func.asString(inputObject3D(this._node, this._shaderCollectionController), "i");
      return `${methodName}(){
				const pointsCount = ${FUNC_POINTS_COUNT_FROM_OBJECT}(${ActorAssemblerConstant.OBJECT_3D});
				for( let i = 0; i < pointsCount; i++ ) {
					${setPointIndex}
					${this._value}
				}
				if( ${ActorAssemblerConstant.OBJECT_3D}.isMesh ){
					${FUNC_CORE_PRIMITIVE_CLASS_FACTORY}(${ActorAssemblerConstant.OBJECT_3D}).computeVertexNormalsIfAttributeVersionChanged(${ActorAssemblerConstant.GEOMETRY});
				}
			}`;
    } else {
      return `${methodName}(){
				${this._value}
			}`;
    }
  }
  static gather(_definitions, linesForShader, lineType) {
    const triggeringDefinitions = _definitions.filter((d) => d.definitionType() == "triggering" /* TRIGGERING */).filter((d) => d._options.gatherable == true);
    const definitionGroups = MapUtils.groupBy(
      triggeringDefinitions,
      (definition) => definition._options.triggeringMethodName
    );
    definitionGroups.forEach((definitions, triggeringMethodName) => {
      const uniqFunctionCalls = [];
      arrayUniq(
        definitions.map((d) => `this.${d.name()}()`),
        uniqFunctionCalls
      );
      const definitionMethodCalls = uniqFunctionCalls.join(";");
      const line = `${triggeringMethodName}(){
				${definitionMethodCalls}
			}`;
      MapUtils.pushOnArrayAtEntry(linesForShader, lineType, line);
    });
  }
}
export class TriggerableJsDefinition extends TypedJsDefinition {
  constructor(_node, _shaderCollectionController, _dataType, _name, _value, _options) {
    super("triggerable" /* TRIGGERABLE */, _node, _shaderCollectionController, _dataType, _name);
    this._node = _node;
    this._shaderCollectionController = _shaderCollectionController;
    this._dataType = _dataType;
    this._name = _name;
    this._value = _value;
    this._options = _options;
  }
  line() {
    var _a, _b, _c;
    const _async = ((_a = this._options) == null ? void 0 : _a.async) == true;
    const functionPrefix = _async ? "async" : "";
    const methodName = ((_b = this._options) == null ? void 0 : _b.methodName) != null ? (_c = this._options) == null ? void 0 : _c.methodName : nodeMethodName(this._node);
    return `${functionPrefix} ${methodName}(){
			${this._value}
		}`;
  }
}
export const JsDefinitionTypeMap = {
  ["localFunction" /* LOCAL_FUNCTION */]: LocalFunctionJsDefinition,
  ["computed" /* COMPUTED */]: ComputedValueJsDefinition,
  ["constant" /* CONSTANT */]: ConstantJsDefinition,
  ["ref" /* REF */]: RefJsDefinition,
  ["watch" /* WATCH */]: WatchedValueJsDefinition,
  ["initFunction" /* INIT_FUNCTION */]: InitFunctionJsDefinition,
  ["triggering" /* TRIGGERING */]: TriggeringJsDefinition,
  ["triggerable" /* TRIGGERABLE */]: TriggerableJsDefinition
};
