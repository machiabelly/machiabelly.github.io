"use strict";
import { setToArray, setIntersection, setUnion } from "../../../../core/SetUtils";
import { MapUtils } from "../../../../core/MapUtils";
import { arrayToSet } from "../../../../core/ArrayUtils";
const _tmpStrings = [];
const DEBUG = false;
function _paramMatchesParamConfig(param, paramConfig) {
  if (param.type() != paramConfig.type()) {
    if (DEBUG) {
      console.log(`${param.name()}: type is different to paramConfig's`, param.type(), paramConfig.type());
    }
    return false;
  }
  if (param.name() != paramConfig.name()) {
    if (DEBUG) {
      console.log(`${param.name()}: name is different to paramConfig's`, param.name(), paramConfig.name());
    }
    return false;
  }
  if (!param.isDefaultValueEqual(paramConfig.defaultValue())) {
    if (DEBUG) {
      console.log(
        `${param.name()}: defaultValue is different to paramConfig's`,
        param.defaultValue(),
        paramConfig.defaultValue()
      );
    }
    return false;
  }
  return true;
}
export class GlAssemblerNodeSpareParamsController {
  constructor(_controller, _node) {
    this._controller = _controller;
    this._node = _node;
    // private _deletedParamsData: Map<string, ParamJsonExporterData<ParamType>> = new Map();
    // private _createdSpareParamNames: Set<string> = new Set();
    this._raw_input_serialized_by_param_name = /* @__PURE__ */ new Map();
    this._init_value_serialized_by_param_name = /* @__PURE__ */ new Map();
  }
  get assembler() {
    return this._controller.assembler;
  }
  // private _createdSpareParams(){
  // 	return this._node.params.spare;
  // }
  createSpareParameters() {
    const paramsUpdateOptions = {};
    const paramConfigs = this.assembler.param_configs();
    const paramConfigsByName = MapUtils.groupBy(paramConfigs, (c) => c.name());
    const assembler_param_names = paramConfigs.map((c) => c.name());
    const spare_param_names_to_add = /* @__PURE__ */ new Set();
    arrayToSet(assembler_param_names, spare_param_names_to_add);
    const validation_result = this._validateNames(spare_param_names_to_add);
    if (validation_result == false) {
      return;
    }
    const currentSpareParams = this._node.params.spare;
    const spare_param_names_to_remove = /* @__PURE__ */ new Set();
    const currentSpareParamNames = /* @__PURE__ */ new Set();
    arrayToSet(
      currentSpareParams.map((p) => p.name()),
      currentSpareParamNames
    );
    setUnion(currentSpareParamNames, spare_param_names_to_add, spare_param_names_to_remove);
    for (const currentSpareParam of currentSpareParams) {
      const paramConfigsWithName = paramConfigsByName.get(currentSpareParam.name());
      if (paramConfigsWithName) {
        const firstParamConfig = paramConfigsWithName[0];
        if (firstParamConfig) {
          if (_paramMatchesParamConfig(currentSpareParam, firstParamConfig)) {
            spare_param_names_to_remove.delete(currentSpareParam.name());
            spare_param_names_to_add.delete(currentSpareParam.name());
          }
        }
      }
    }
    spare_param_names_to_remove.forEach((param_name) => {
      const param = this._node.params.get(param_name);
      if (param && !param.parentParam()) {
        this._raw_input_serialized_by_param_name.set(param.name(), param.rawInputSerialized());
        this._init_value_serialized_by_param_name.set(param.name(), param.defaultValueSerialized());
        paramsUpdateOptions.namesToDelete = paramsUpdateOptions.namesToDelete || [];
        paramsUpdateOptions.namesToDelete.push(param_name);
      }
    });
    for (const paramConfig of paramConfigs) {
      if (spare_param_names_to_add.has(paramConfig.name())) {
        const options = {
          spare: true,
          computeOnDirty: true,
          cook: false,
          // it should update the uniforms only via its callback
          // important for texture nodes
          // that compute after being found by the nodepath param
          dependentOnFoundNode: true
        };
        let init_value = this._init_value_serialized_by_param_name.get(paramConfig.name());
        if (init_value == null) {
          init_value = paramConfig.defaultValue();
        }
        let raw_input = this._raw_input_serialized_by_param_name.get(paramConfig.name());
        if (raw_input == null) {
          raw_input = paramConfig.defaultValue();
        }
        paramsUpdateOptions.toAdd = paramsUpdateOptions.toAdd || [];
        paramsUpdateOptions.toAdd.push({
          name: paramConfig.name(),
          type: paramConfig.type(),
          initValue: init_value,
          rawInput: raw_input,
          options
        });
      }
    }
    this._node.params.updateParams(paramsUpdateOptions);
    for (const paramConfig of paramConfigs) {
      paramConfig.applyToNode(this._node);
    }
  }
  _validateNames(spare_param_names_to_add) {
    const currentParamNames = /* @__PURE__ */ new Set();
    arrayToSet(this._node.params.non_spare_names, currentParamNames);
    const spareParamsWithSameNameAsParams = /* @__PURE__ */ new Set();
    setIntersection(spare_param_names_to_add, currentParamNames, spareParamsWithSameNameAsParams);
    if (spareParamsWithSameNameAsParams.size > 0) {
      const error_message = `${this._node.path()} attempts to create spare params called '${setToArray(
        spareParamsWithSameNameAsParams,
        _tmpStrings
      ).join(", ")}' with same name as params`;
      this._node.states.error.set(error_message);
      return false;
    }
    return true;
  }
}
