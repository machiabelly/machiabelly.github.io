"use strict";
import { BaseSDFGlNode } from "./_BaseSDF";
import { ThreeToGl } from "../../../../src/core/ThreeToGl";
import SDFRepeatMethods from "./gl/raymarching/sdfRepeat.glsl";
import SDFRepeatPolarMethods from "./gl/raymarching/sdfRepeatPolar.glsl";
import PolarGlslLib from "./gl/polar.glsl";
import { NodeParamsConfig, ParamConfig } from "../utils/params/ParamsConfig";
import { GlConnectionPointType, GlConnectionPoint } from "../utils/io/connections/Gl";
import { FunctionGLDefinition } from "./utils/GLDefinition";
const OUTPUT_NAME = "p";
class SDFRepeatPolarGlParamsConfig extends NodeParamsConfig {
  constructor() {
    super(...arguments);
    this.position = ParamConfig.VECTOR3([0, 0, 0], { hidden: true });
    this.center = ParamConfig.VECTOR3([0, 0, 0]);
    // repeatLon = ParamConfig.BOOLEAN(1);
    this.periodLon = ParamConfig.FLOAT(1, {
      // visibleIf: {repeatLon: true},
      range: [0, Math.PI]
    });
  }
  // repeatLat = ParamConfig.BOOLEAN(1);
  // periodLat = ParamConfig.FLOAT(1, {
  // 	visibleIf: {repeatLat: true},
  // 	range: [0, 0.5 * Math.PI],
  // });
  // repeatDepth = ParamConfig.BOOLEAN(1);
  // periodDepth = ParamConfig.FLOAT(1, {
  // 	visibleIf: {repeatDepth: true},
  // });
}
const ParamsConfig = new SDFRepeatPolarGlParamsConfig();
export class SDFRepeatPolarGlNode extends BaseSDFGlNode {
  constructor() {
    super(...arguments);
    this.paramsConfig = ParamsConfig;
  }
  static type() {
    return "SDFRepeatPolar";
  }
  initializeNode() {
    super.initializeNode();
    this.io.outputs.setNamedOutputConnectionPoints([
      new GlConnectionPoint(OUTPUT_NAME, GlConnectionPointType.VEC3)
    ]);
  }
  setLines(shadersCollectionController) {
    const position = this.position();
    const center = ThreeToGl.vector3(this.variableForInputParam(this.p.center));
    const periodLon = ThreeToGl.float(this.variableForInputParam(this.p.periodLon));
    const float = this.glVarName(OUTPUT_NAME);
    const functionName = "SDFRepeatPolarZ";
    const bodyLine = `vec3 ${float} = ${functionName}(${position} - ${center}, ${periodLon})`;
    shadersCollectionController.addBodyLines(this, [bodyLine]);
    shadersCollectionController.addDefinitions(this, [
      new FunctionGLDefinition(this, PolarGlslLib),
      new FunctionGLDefinition(this, SDFRepeatMethods),
      new FunctionGLDefinition(this, SDFRepeatPolarMethods)
    ]);
  }
  // protected _functionSuffix() {
  // 	const lon = isBooleanTrue(this.pv.repeatLon);
  // 	const lat = isBooleanTrue(this.pv.repeatLat);
  // 	const d = isBooleanTrue(this.pv.repeatDepth);
  // 	if (lon && lat && d) {
  // 		return '';
  // 	}
  // 	const args: string[] = [];
  // 	if (d) args.push('X');
  // 	if (lat) args.push('Y');
  // 	if (lon) args.push('Z');
  // 	return args.join('');
  // }
}
