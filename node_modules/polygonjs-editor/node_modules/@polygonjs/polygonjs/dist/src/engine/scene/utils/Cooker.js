"use strict";
export class Cooker {
  constructor(_scene) {
    this._scene = _scene;
    this._queue = /* @__PURE__ */ new Map();
    this._nodeIdsInFlushingQueue = /* @__PURE__ */ new Set();
    this._blockLevel = 0;
  }
  // private _processesCount: number = 0;
  block() {
    this._blockLevel += 1;
  }
  unblock() {
    this._blockLevel -= 1;
    if (this._blockLevel > 0) {
      return;
    }
    if (this._blockLevel < 0) {
      this._blockLevel = 0;
    }
    this._processQueue();
  }
  blocked() {
    return this._blockLevel > 0 || this._scene.loadingController.isLoading();
  }
  enqueue(node, originalTriggerGraphNode) {
    if (!node.dirtyController.hasPostDirtyHooks()) {
      return;
    }
    if (this._queue.has(node.graphNodeId()) || this._nodeIdsInFlushingQueue.has(node.graphNodeId())) {
      return;
    }
    this._queue.set(node.graphNodeId(), originalTriggerGraphNode);
  }
  _processQueue() {
    if (this.blocked()) {
      return;
    }
    if (this._queue.size == 0) {
      return;
    }
    const originalTriggerGraphNodes = [];
    const nodeIds = [];
    this._queue.forEach((originalTriggerGraphNode, nodeId) => {
      originalTriggerGraphNodes.push(originalTriggerGraphNode);
      nodeIds.push(nodeId);
      this._nodeIdsInFlushingQueue.add(nodeId);
    });
    this._queue.clear();
    let i = 0;
    for (const originalTriggerGraphNode of originalTriggerGraphNodes) {
      const nodeId = nodeIds[i];
      this._processItem(originalTriggerGraphNode, nodeId);
      this._nodeIdsInFlushingQueue.delete(nodeId);
      i++;
    }
  }
  _processItem(originalTriggerGraphNode, nodeId) {
    const node = this._scene.graph.nodeFromId(nodeId);
    if (node) {
      node.dirtyController.runPostDirtyHooks(originalTriggerGraphNode);
    }
  }
}
