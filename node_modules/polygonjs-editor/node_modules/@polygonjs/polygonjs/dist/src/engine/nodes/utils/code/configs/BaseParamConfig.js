"use strict";
import { ParamType } from "../../../../poly/ParamType";
import { NodeContext } from "../../../../poly/NodeContext";
export class BaseParamConfig {
  // private _texture_loader: CoreTextureLoader
  constructor(_type, _name, _defaultValue) {
    this._type = _type;
    this._name = _name;
    this._defaultValue = _defaultValue;
    if (_name == "" || _name == null) {
      throw new Error(`name must not be an empty string`);
    }
  }
  static fromParam(param) {
    return new BaseParamConfig(param.type(), param.name(), param.defaultValue());
  }
  type() {
    return this._type;
  }
  name() {
    return this._name;
  }
  defaultValue() {
    return this._defaultValue;
  }
  paramOptions() {
    const callbackBound = this._callback.bind(this);
    switch (this._type) {
      case ParamType.NODE_PATH:
        return { callback: callbackBound, nodeSelection: { context: NodeContext.COP } };
      default:
        return { callback: callbackBound };
    }
  }
  applyToNode(node) {
    if (!node.params.has(this._name)) {
      return;
    }
    const param = node.params.get(this._name);
    if (!param) {
      return;
    }
    const additionalOptions = this.paramOptions();
    const additionalOptionNames = Object.keys(additionalOptions);
    for (const optionName of additionalOptionNames) {
      param.options.setOption(optionName, additionalOptions[optionName]);
    }
    this.executeCallback(node, param);
    if (param.type() == ParamType.NODE_PATH) {
      setTimeout(async () => {
        if (param.isDirty()) {
          await param.compute();
        }
        param.options.executeCallback();
      }, 200);
    }
  }
  executeCallback(node, param) {
    this._callback(node, param);
  }
  _callback(node, param) {
  }
}
