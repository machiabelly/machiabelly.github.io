"use strict";
import { TypedAnimNode } from "./_Base";
import { TimelineBuilder } from "../../../core/animation/TimelineBuilder";
import { TypeAssert } from "../../poly/Assert";
import { AnimationPosition, AnimationPositionMode, AnimationPositionRelativeTo } from "../../../core/animation/Position";
import { NodeParamsConfig, ParamConfig } from "../utils/params/ParamsConfig";
import { isBooleanTrue } from "../../../core/BooleanValue";
import { NodeEvent } from "../../poly/NodeEvent";
var MergeMode = /* @__PURE__ */ ((MergeMode2) => {
  MergeMode2["ALL_TOGETHER"] = "play all together";
  MergeMode2["ONE_AT_A_TIME"] = "play one at a time";
  return MergeMode2;
})(MergeMode || {});
export const EASING_ANIM_MERGE_MODES = ["play all together" /* ALL_TOGETHER */, "play one at a time" /* ONE_AT_A_TIME */];
const DEFAULT_INPUTS_COUNT = 4;
class MergeAnimParamsConfig extends NodeParamsConfig {
  constructor() {
    super(...arguments);
    /** @param mode (at the same time or one after the other) */
    this.mode = ParamConfig.INTEGER(0, {
      menu: {
        entries: EASING_ANIM_MERGE_MODES.map((name, value) => {
          return { name, value };
        })
      }
    });
    /** @param offset if run one after the other */
    this.offset = ParamConfig.FLOAT(0, {
      range: [-1, 1]
    });
    /** @param override the position */
    this.overridePositions = ParamConfig.BOOLEAN(0);
    /** @param number of inputs that this node can merge animations from */
    this.inputsCount = ParamConfig.INTEGER(DEFAULT_INPUTS_COUNT, {
      range: [1, 32],
      rangeLocked: [true, false],
      callback: (node) => {
        MergeAnimNode.PARAM_CALLBACK_setInputsCount(node);
      }
    });
  }
}
const ParamsConfig = new MergeAnimParamsConfig();
export class MergeAnimNode extends TypedAnimNode {
  constructor() {
    super(...arguments);
    this.paramsConfig = ParamsConfig;
  }
  static type() {
    return "merge";
  }
  initializeNode() {
    this.io.inputs.setCount(0, 4);
    this.params.onParamsCreated("pdateInputsEvaluation", () => {
      this._callbackUpdateInputsCount();
    });
  }
  cook(inputContents) {
    const mergedTimelineBuilder = new TimelineBuilder();
    let i = 0;
    for (const timelineBuilder of inputContents) {
      if (timelineBuilder) {
        if (i > 0) {
          this._updateTimelineBuilder(timelineBuilder);
        }
        mergedTimelineBuilder.addTimelineBuilder(timelineBuilder);
        i++;
      }
    }
    this.setTimelineBuilder(mergedTimelineBuilder);
  }
  _updateTimelineBuilder(timelineBuilder) {
    const mode = EASING_ANIM_MERGE_MODES[this.pv.mode];
    switch (mode) {
      case "play all together" /* ALL_TOGETHER */:
        return this._setPlayAllTogether(timelineBuilder);
      case "play one at a time" /* ONE_AT_A_TIME */:
        return this._setPlayOneAtATime(timelineBuilder);
    }
    TypeAssert.unreachable(mode);
  }
  _setPlayAllTogether(timelineBuilder) {
    let position = timelineBuilder.position();
    if (!position || isBooleanTrue(this.pv.overridePositions)) {
      position = new AnimationPosition();
      position.setMode(AnimationPositionMode.RELATIVE);
      position.setRelativeTo(AnimationPositionRelativeTo.START);
      position.setOffset(this.pv.offset);
      timelineBuilder.setPosition(position);
    }
  }
  _setPlayOneAtATime(timelineBuilder) {
    let position = timelineBuilder.position();
    if (!position || isBooleanTrue(this.pv.overridePositions)) {
      position = new AnimationPosition();
      position.setMode(AnimationPositionMode.RELATIVE);
      position.setRelativeTo(AnimationPositionRelativeTo.END);
      position.setOffset(this.pv.offset);
      timelineBuilder.setPosition(position);
    }
  }
  _callbackUpdateInputsCount() {
    this.io.inputs.setCount(1, this.pv.inputsCount);
    this.emit(NodeEvent.INPUTS_UPDATED);
  }
  static PARAM_CALLBACK_setInputsCount(node) {
    node._callbackUpdateInputsCount();
  }
}
