"use strict";
import { getObjectMethodNames } from "../../../../../../core/ObjectUtils";
const evaluatorGeneratorByObject = /* @__PURE__ */ new WeakMap();
function registerGeneratorForObject(object, generator) {
  let set = evaluatorGeneratorByObject.get(object);
  if (!set) {
    set = /* @__PURE__ */ new Set();
    evaluatorGeneratorByObject.set(object, set);
  }
  set.add(generator);
}
function deregisterGeneratorForObject(object, generator) {
  let set = evaluatorGeneratorByObject.get(object);
  if (!set) {
    return;
  }
  set.delete(generator);
}
export function deregisterGeneratorsForObject(object) {
  let set = evaluatorGeneratorByObject.get(object);
  if (!set) {
    return;
  }
  set.forEach((evaluatorGenerator) => {
    evaluatorGenerator.disposeEvaluator(object);
  });
  evaluatorGeneratorByObject.delete(object);
}
export function generatorsForObject(object) {
  return evaluatorGeneratorByObject.get(object);
}
const NOT_STORABLE_METHOD_NAMES = /* @__PURE__ */ new Set([
  "constructor",
  "onDispose",
  "dispose",
  "__defineGetter__",
  "__defineSetter__",
  "hasOwnProperty",
  "__lookupGetter__",
  "__lookupSetter__",
  "isPrototypeOf",
  "propertyIsEnumerable",
  "toString",
  "valueOf",
  "toLocaleString"
]);
export class ActorEvaluatorGenerator {
  constructor(_func) {
    this._func = _func;
    // the possible method names are not only EvaluatorMethodName,
    // but can be any string, such as "onManualTrigger1"
    this._expectedEvaluatorMethodNames = /* @__PURE__ */ new Set();
    this._evaluatorByObject = /* @__PURE__ */ new Map();
  }
  _createEvaluator(object) {
    return this._func(object);
  }
  setExpectedEvaluatorMethodNames(dummyEvaluator) {
    this._expectedEvaluatorMethodNames.clear();
    const methodNames = getObjectMethodNames(dummyEvaluator);
    for (const methodName of methodNames) {
      if (dummyEvaluator[methodName] && !NOT_STORABLE_METHOD_NAMES.has(methodName)) {
        this._expectedEvaluatorMethodNames.add(methodName);
      }
    }
  }
  hasExpectedEvaluatorMethodName(methodName) {
    return this._expectedEvaluatorMethodNames.has(methodName);
  }
  size() {
    return this._evaluatorByObject.size;
  }
  disposeEvaluator(object) {
    const evaluator = this._evaluatorByObject.get(object);
    if (!evaluator) {
      return;
    }
    evaluator.dispose();
    this._evaluatorByObject.delete(object);
  }
  findOrCreateEvaluator(object) {
    let evaluator = this._evaluatorByObject.get(object);
    if (!evaluator) {
      evaluator = this._createEvaluator(object);
      this._evaluatorByObject.set(object, evaluator);
      registerGeneratorForObject(object, this);
    }
    return evaluator;
  }
  traverseEvaluator(callback) {
    this._evaluatorByObject.forEach(callback);
  }
  clearObjects() {
    this._evaluatorByObject.forEach((evaluator, object) => {
      evaluator.dispose();
      deregisterGeneratorForObject(object, this);
    });
    this._evaluatorByObject.clear();
  }
}
