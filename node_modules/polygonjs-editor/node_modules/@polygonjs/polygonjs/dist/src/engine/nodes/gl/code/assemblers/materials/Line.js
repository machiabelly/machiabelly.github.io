"use strict";
import { ShaderLib } from "three";
import { ShaderAssemblerMaterial } from "./_BaseMaterial";
import { ShaderConfig } from "../../configs/ShaderConfig";
import { VariableConfig } from "../../configs/VariableConfig";
import { GlobalsGeometryHandler } from "../../globals/Geometry";
import { ShaderAssemblerCustomLineDepth } from "./custom/line/CustomLineDepth";
import { ShaderAssemblerCustomLineDistance } from "./custom/line/CustomLineDistance";
import { ShaderName } from "../../../../utils/shaders/ShaderName";
import { GlConnectionPointType, GlConnectionPoint } from "../../../../utils/io/connections/Gl";
import { VaryingWriteGlNode } from "../../../VaryingWrite";
import { ShaderAssemblerCustomLineDepthDOF } from "./custom/line/CustomLineDepthDOF";
import { LineBasicMaterial } from "three";
import { CustomMaterialName } from "../../../../../../core/geometry/Material";
const ASSEMBLER_MAP = /* @__PURE__ */ new Map([]);
ASSEMBLER_MAP.set(CustomMaterialName.DISTANCE, ShaderAssemblerCustomLineDistance);
ASSEMBLER_MAP.set(CustomMaterialName.DEPTH, ShaderAssemblerCustomLineDepth);
ASSEMBLER_MAP.set(CustomMaterialName.DEPTH_DOF, ShaderAssemblerCustomLineDepthDOF);
const LINES_TO_REMOVE_MAP = /* @__PURE__ */ new Map([
  [ShaderName.VERTEX, ["#include <begin_vertex>", "#include <project_vertex>"]],
  [ShaderName.FRAGMENT, []]
]);
export class ShaderAssemblerLine extends ShaderAssemblerMaterial {
  // _color_declaration() { return 'diffuseColor' }
  templateShader() {
    const template = ShaderLib.dashed;
    return {
      vertexShader: template.vertexShader,
      //TemplateVertex,
      fragmentShader: template.fragmentShader,
      //TemplateFragment,
      uniforms: template.uniforms
    };
  }
  createMaterial() {
    const material = new LineBasicMaterial();
    this._addCustomMaterials(material);
    return material;
  }
  customAssemblerClassByCustomName() {
    return ASSEMBLER_MAP;
  }
  create_shader_configs() {
    return [
      new ShaderConfig(ShaderName.VERTEX, ["position", "uv", VaryingWriteGlNode.INPUT_NAME], []),
      new ShaderConfig(ShaderName.FRAGMENT, ["color", "alpha"], [ShaderName.VERTEX])
    ];
  }
  static output_input_connection_points() {
    return [
      new GlConnectionPoint("position", GlConnectionPointType.VEC3),
      new GlConnectionPoint("color", GlConnectionPointType.VEC3),
      new GlConnectionPoint("alpha", GlConnectionPointType.FLOAT),
      new GlConnectionPoint("uv", GlConnectionPointType.VEC2)
    ];
  }
  add_output_inputs(output_child) {
    output_child.io.inputs.setNamedInputConnectionPoints(ShaderAssemblerLine.output_input_connection_points());
  }
  static create_globals_node_output_connections() {
    return [
      new GlConnectionPoint("position", GlConnectionPointType.VEC3),
      // new Connection.Vec3('normal'),
      new GlConnectionPoint("color", GlConnectionPointType.VEC3),
      new GlConnectionPoint("uv", GlConnectionPointType.VEC2),
      new GlConnectionPoint("gl_FragCoord", GlConnectionPointType.VEC4),
      new GlConnectionPoint("resolution", GlConnectionPointType.VEC2),
      // new Connection.Vec2('gl_PointCoord'),
      // new TypedConnectionVec2('uv'),
      new GlConnectionPoint("time", GlConnectionPointType.FLOAT)
    ];
  }
  create_globals_node_output_connections() {
    return ShaderAssemblerLine.create_globals_node_output_connections();
  }
  create_variable_configs() {
    return [
      new VariableConfig("position", {
        default: "vec3( position )",
        prefix: "vec3 transformed = ",
        suffix: ";vec4 mvPosition = vec4( transformed, 1.0 ); gl_Position = projectionMatrix * modelViewMatrix * mvPosition;"
      }),
      // new VariableConfig('normal', {
      // 	prefix: 'objectNormal = '
      // }),
      new VariableConfig("color", {
        prefix: "diffuseColor.xyz = "
      }),
      new VariableConfig("alpha", {
        prefix: "diffuseColor.w = "
      }),
      new VariableConfig("uv", {
        // default_from_attribute: true,
        prefix: "vUv = ",
        if: GlobalsGeometryHandler.IF_RULE.uv
      })
    ];
  }
  linesToRemove(shader_name) {
    return LINES_TO_REMOVE_MAP.get(shader_name);
  }
}
