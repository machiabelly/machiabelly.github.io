"use strict";
import { TypedJsNode } from "./_Base";
import { JsConnectionPoint, JsConnectionPointType, JS_CONNECTION_POINT_IN_NODE_DEF } from "../utils/io/connections/Js";
import { NodeParamsConfig, ParamConfig } from "../utils/params/ParamsConfig";
import { NodeContext } from "../../poly/NodeContext";
import { CopType } from "../../poly/registers/nodes/types/Cop";
import { Poly } from "../../Poly";
const CONNECTION_OPTIONS = JS_CONNECTION_POINT_IN_NODE_DEF;
export var GetVideoPropertyJsNodeOutputName = /* @__PURE__ */ ((GetVideoPropertyJsNodeOutputName2) => {
  GetVideoPropertyJsNodeOutputName2["currentTime"] = "currentTime";
  GetVideoPropertyJsNodeOutputName2["duration"] = "duration";
  GetVideoPropertyJsNodeOutputName2["playing"] = "playing";
  GetVideoPropertyJsNodeOutputName2["muted"] = "muted";
  return GetVideoPropertyJsNodeOutputName2;
})(GetVideoPropertyJsNodeOutputName || {});
class GetVideoPropertyJsParamsConfig extends NodeParamsConfig {
  constructor() {
    super(...arguments);
    this.node = ParamConfig.NODE_PATH("", {
      nodeSelection: {
        context: NodeContext.COP,
        types: [CopType.VIDEO]
      },
      computeOnDirty: true
    });
  }
}
const ParamsConfig = new GetVideoPropertyJsParamsConfig();
export class GetVideoPropertyJsNode extends TypedJsNode {
  constructor() {
    super(...arguments);
    this.paramsConfig = ParamsConfig;
  }
  static type() {
    return "getVideoProperty";
  }
  initializeNode() {
    this.io.inputs.setNamedInputConnectionPoints([
      new JsConnectionPoint(JsConnectionPointType.OBJECT_3D, JsConnectionPointType.OBJECT_3D, CONNECTION_OPTIONS)
    ]);
    this.io.outputs.setNamedOutputConnectionPoints([
      new JsConnectionPoint("currentTime" /* currentTime */, JsConnectionPointType.FLOAT),
      new JsConnectionPoint("duration" /* duration */, JsConnectionPointType.FLOAT),
      new JsConnectionPoint("playing" /* playing */, JsConnectionPointType.BOOLEAN),
      new JsConnectionPoint("muted" /* muted */, JsConnectionPointType.BOOLEAN)
    ]);
  }
  setLines(shadersCollectionController) {
    const usedOutputNames = this.io.outputs.used_output_names();
    const node = this.pv.node.node();
    if (!(node && node.context() == NodeContext.COP)) {
      return;
    }
    const nodePath = `'${node.path()}'`;
    const _f = (propertyName, functionName, type) => {
      if (!usedOutputNames.includes(propertyName)) {
        return;
      }
      const func = Poly.namedFunctionsRegister.getFunction(functionName, this, shadersCollectionController);
      shadersCollectionController.addBodyOrComputed(this, [
        {
          dataType: type,
          varName: this.jsVarName(propertyName),
          value: func.asString(nodePath)
        }
      ]);
    };
    _f("currentTime" /* currentTime */, "getVideoPropertyCurrentTime", JsConnectionPointType.FLOAT);
    _f("duration" /* duration */, "getVideoPropertyDuration", JsConnectionPointType.FLOAT);
    _f("playing" /* playing */, "getVideoPropertyPlaying", JsConnectionPointType.BOOLEAN);
    _f("muted" /* muted */, "getVideoPropertyMuted", JsConnectionPointType.BOOLEAN);
  }
}
