"use strict";
import { TypedSopNode } from "./_Base";
import { NodeParamsConfig, ParamConfig } from "../utils/params/ParamsConfig";
import { InputCloneMode } from "../../poly/InputCloneMode";
import { Scene } from "three";
import { downloadBlob } from "../../../core/BlobUtils";
import { CoreType } from "../../../core/Type";
const previousParentByObject = /* @__PURE__ */ new WeakMap();
export class BaseExporterSopParamsConfig extends NodeParamsConfig {
  constructor() {
    super(...arguments);
    /** @param fileName */
    this.fileName = ParamConfig.STRING("`$OS`");
    /** @param export */
    this.download = ParamConfig.BUTTON(null, {
      hidden: true,
      callback: (node) => {
        ExporterSopNode.PARAM_CALLBACK_download(node);
      }
    });
  }
}
export class ExporterSopNode extends TypedSopNode {
  initializeNode() {
    this.io.inputs.setCount(1);
    this.io.inputs.initInputsClonedState(InputCloneMode.NEVER);
  }
  async cook(inputCoreGroups) {
    this.setCoreGroup(inputCoreGroups[0]);
  }
  static PARAM_CALLBACK_download(node) {
    node._paramCallbackDownload();
  }
  async fileName() {
    return await exporterSopFileName(this.p.fileName, this.fileExtension());
  }
  async _paramCallbackDownload() {
    const blob = await this.createBlob();
    const fileName = await this.fileName();
    downloadBlob(blob, fileName);
  }
  async _prepareScene() {
    return await exporterSopPrepareScene(this);
  }
  _handleResult(result, objects, resolve) {
    exporterSopHandleResult(result, objects, resolve);
  }
}
export async function exporterSopFileName(fileNameParam, fileExtension) {
  if (fileNameParam.isDirty()) {
    await fileNameParam.compute();
  }
  const fileNameShort = fileNameParam.value;
  const fileName = `${fileNameShort}.${fileExtension}`;
  return fileName;
}
export async function exporterSopPrepareScene(node) {
  const container = await node.compute();
  const coreGroup = container.coreContent();
  if (!coreGroup) {
    console.error("input invalid");
    return;
  }
  const objects = coreGroup.threejsObjects();
  for (const object of objects) {
    previousParentByObject.set(object, object.parent);
  }
  const scene = new Scene();
  for (const object of objects) {
    scene.add(object);
  }
  return { scene, objects };
}
function _createBlob(result) {
  if (result instanceof Uint8Array || result instanceof ArrayBuffer) {
    return new Blob([result], { type: "application/octet-stream" });
  }
  if (CoreType.isString(result)) {
    return new Blob([result], { type: "text/plain" });
  }
  const output = JSON.stringify(result, null, 2);
  return new Blob([output], { type: "text/plain" });
}
export function exporterSopHandleResult(result, objects, resolve) {
  const blob = _createBlob(result);
  for (const object of objects) {
    const previousParent = previousParentByObject.get(object);
    if (previousParent) {
      previousParent.add(object);
    }
  }
  resolve(blob);
}
