"use strict";
import { CoreAttribute } from "../../../../../core/geometry/Attribute";
import { AttribType } from "../../../../../core/geometry/Constant";
import { TypeAssert } from "../../../../poly/Assert";
import { hasGroupFromParamValues } from "./Common";
import { corePointClassFactory } from "../../../../../core/geometry/CoreObjectFactory";
import { pointsFromObject, pointsFromObjectFromGroup } from "../../../../../core/geometry/entities/point/CorePointUtils";
export function addPointAttribute(attribType, coreGroup, params) {
  const objects = coreGroup.allObjects();
  switch (attribType) {
    case AttribType.NUMERIC: {
      for (let object of objects) {
        _addNumericAttributeToPoints(object, params);
      }
      return;
    }
    case AttribType.STRING: {
      for (let object of objects) {
        _addStringAttributeToPoints(object, params);
      }
      return;
    }
  }
  TypeAssert.unreachable(attribType);
}
const _points = [];
const _allPoints = [];
function _addNumericAttributeToPoints(object, params) {
  const corePointClass = corePointClassFactory(object);
  const value = [params.value1, params.value2, params.value3, params.value4][params.size - 1];
  const attribName = CoreAttribute.remapName(params.name);
  if (!corePointClass.hasAttribute(object, attribName)) {
    corePointClass.addNumericAttribute(object, attribName, params.size, 0);
  } else {
    corePointClass.markAttribAsNeedsUpdate(object, attribName);
  }
  if (params.group) {
    pointsFromObjectFromGroup(object, params.group, _points);
    for (let point of _points) {
      point.setAttribValue(attribName, value);
    }
  } else {
    corePointClass.addNumericAttribute(object, attribName, params.size, value);
  }
}
function _addStringAttributeToPoints(object, params) {
  const corePointClass = corePointClassFactory(object);
  pointsFromObjectFromGroup(object, params.group, _points);
  const attribName = params.name;
  const value = params.string;
  let stringValues = new Array(_points.length);
  if (hasGroupFromParamValues(params)) {
    pointsFromObject(object, _allPoints);
    stringValues = stringValues.length != _allPoints.length ? new Array(_allPoints.length) : stringValues;
    if (!corePointClass.hasAttribute(object, attribName)) {
      const tmpIndexData = CoreAttribute.arrayToIndexedArrays([""]);
      corePointClass.setIndexedAttribute(object, attribName, tmpIndexData["values"], tmpIndexData["indices"]);
    }
    for (const point of _allPoints) {
      let currentValue = point.stringAttribValue(attribName);
      if (currentValue == null) {
        currentValue = "";
      }
      stringValues[point.index()] = currentValue;
    }
  }
  for (const point of _points) {
    stringValues[point.index()] = value;
  }
  const indexData = CoreAttribute.arrayToIndexedArrays(stringValues);
  corePointClass.setIndexedAttribute(object, attribName, indexData["values"], indexData["indices"]);
}
