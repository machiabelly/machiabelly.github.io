export default "precision highp float;\nprecision highp int;\n\n#include <common>\n\n#define DIR_LIGHTS_COUNT 1\n#define MAX_STEPS_COUNT 4096\n\nuniform vec3 u_Color;\nuniform float u_VolumeDensity;\nuniform float u_ShadowDensity;\nuniform float u_StepSize;\nuniform vec3 u_BoundingBoxMin;\nuniform vec3 u_BoundingBoxMax;\n//const int u_PointsCount = 3;\n//uniform vec3 u_Points[3];\nuniform sampler2D u_Map;\n\n//const int u_DirectionalLightsCount = 1;\nuniform vec3 u_DirectionalLightDirection; //[DIR_LIGHTS_COUNT];\n\nvarying vec3 vPw;\n// varying vec3 vN;\n// varying vec2 vUV;\n//varying vec3 vPCameraSpace;\n// varying vec4 vCd;\n\nvec3 normalize_in_bbox(vec3 point){\n\n	vec3 min = u_BoundingBoxMin;\n	vec3 max = u_BoundingBoxMax;\n\n	return vec3(\n		(point.x - min.x) / (max.x - min.x),\n		(point.y - min.y) / (max.y - min.y),\n		(point.z - min.z) / (max.z - min.z)\n	);\n}\n\nbool is_inside_bbox(vec3 Pw){\n\n	vec3 min = u_BoundingBoxMin;\n	vec3 max = u_BoundingBoxMax;\n\n	return (\n		Pw.x > min.x &&\n		Pw.y > min.y &&\n		Pw.z > min.z &&\n\n		Pw.x < max.x &&\n		Pw.y < max.y &&\n		Pw.z < max.z\n		);\n}\n\nfloat density_to_opacity(float density, float step_size){\n	float curent_density = density;\n	curent_density = max(0.0, curent_density);\n\n	float opacity = (1.0-exp(-curent_density * step_size));\n	return max(opacity,0.0);\n}\n\nfloat density_function(vec3 position_for_step){\n	float density = 1.0;\n	// start builder body code\n\n	return density;\n}\n\nvec4 raymarch_light(vec3 ray_dir, vec3 start_pos){\n\n	float step_size = u_StepSize;\n	vec3 step_vector = ray_dir * step_size;\n\n	vec3 current_pos = start_pos + step_vector*rand(start_pos.x*ray_dir.xy);\n	float opacity = 0.0;\n	for(int i=0; i<MAX_STEPS_COUNT; i++){\n		if(opacity >= 0.99){ break; }\n\n		if( is_inside_bbox(current_pos) ){\n\n			float density = density_function(current_pos) * u_ShadowDensity;\n			opacity += density_to_opacity(density, step_size);\n			current_pos += step_vector;\n\n		}else{\n			break;\n		}\n	}\n\n	vec3 light_color = vec3(1.0, 1.0, 1.0) * u_Color;\n	light_color *= (1.0-opacity);\n	return vec4(light_color, 1.0-opacity);\n}\n\nvec4 raymarch_bbox(vec3 start_pos, vec3 ray_dir){\n\n	float step_size = u_StepSize;\n	vec3 step_vector = ray_dir * step_size;\n\n	vec3 current_pos = start_pos - step_vector*rand(ray_dir.xz);\n	float opacity = 0.0;\n	vec3 color = vec3(0.0, 0.0, 0.0);\n	float steps_count = 0.0;\n	bool was_inside_bbox = false;\n	for(int i=0; i<MAX_STEPS_COUNT; i++){\n		if(opacity >= 0.99){ break; }\n\n		if( i==0 || is_inside_bbox(current_pos) ){\n			was_inside_bbox = true;\n\n			float density = density_function(current_pos) * u_VolumeDensity;\n			opacity += density_to_opacity(density, step_size);\n\n			vec4 light_color = vec4(0.0,0.0,0.0,1.0); //vec4(1.0,1.0,1.0,1.0);\n			// vec3 directional_light_direction;\n			// for ( int l = 0; l < DIR_LIGHTS_COUNT; l++ ) {\n			// directional_light_direction = u_DirectionalLightsDirection[ l ];\n			light_color += raymarch_light(-u_DirectionalLightDirection, current_pos);\n			// }\n			float blend = 1.0-opacity;\n			color = mix( color.xyz, light_color.xyz, vec3(blend, blend, blend) );\n			steps_count += 1.0;\n\n		}else{\n			if (was_inside_bbox) { break; }\n		}\n		current_pos += step_vector;\n	}\n\n	return vec4(color, opacity);\n	// steps_count = steps_count / 5.0;\n	// return vec4(vec3(steps_count, steps_count, steps_count), 1.0);\n}\n\nvoid main()	{\n\n	vec3 eye = normalize(vPw - cameraPosition);\n	// we can start from the bbox, as we are front facing\n	vec3 start_pos = vPw;\n\n	vec4 color = raymarch_bbox(start_pos, eye);\n	gl_FragColor = color;\n\n}";
