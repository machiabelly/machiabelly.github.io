/**
 * Can be triggered when nodes have cooked or to cook specific nodes.
 *
 *
 */
import { TypedEventNode } from './_Base';
import { BaseNodeType } from '../_Base';
import { NodeParamsConfig } from '../utils/params/ParamsConfig';
declare class NodeCookEventParamsConfig extends NodeParamsConfig {
    /** @param mask to select which nodes this will cook or listen to */
    mask: import("../utils/params/ParamsConfig").ParamTemplate<import("../../index_all").ParamType.STRING>;
    /** @param forces cook of nodes mentioned in the mask param */
    force: import("../utils/params/ParamsConfig").ParamTemplate<import("../../index_all").ParamType.BOOLEAN>;
    /** @param defines if the nodes should cook one after the other or in parallel */
    cookMode: import("../utils/params/ParamsConfig").ParamTemplate<import("../../index_all").ParamType.INTEGER>;
    /** @param batch size */
    batchSize: import("../utils/params/ParamsConfig").ParamTemplate<import("../../index_all").ParamType.INTEGER>;
    /** @param if on, we only trigger the first time a specific node has cooked. If false, we register every time a node cooks */
    registerOnlyFirstCooks: import("../utils/params/ParamsConfig").ParamTemplate<import("../../index_all").ParamType.BOOLEAN>;
    /** @param updates the list of nodes from the mask parameter. This can be useful if nodes are added or removed from the scene */
    updateResolve: import("../utils/params/ParamsConfig").ParamTemplate<import("../../index_all").ParamType.BUTTON>;
    /** @param prints the list of nodes the mask resolves to to the console. Useful for debugging */
    printResolve: import("../utils/params/ParamsConfig").ParamTemplate<import("../../index_all").ParamType.BUTTON>;
}
export declare class NodeCookEventNode extends TypedEventNode<NodeCookEventParamsConfig> {
    paramsConfig: NodeCookEventParamsConfig;
    static type(): Readonly<'nodeCook'>;
    static readonly INPUT_TRIGGER = "trigger";
    static readonly OUTPUT_FIRST_NODE = "first";
    static readonly OUTPUT_EACH_NODE = "each";
    static readonly OUTPUT_ALL_NODES = "all";
    private _resolvedNodes;
    initializeNode(): void;
    trigger(): void;
    cook(): void;
    dispose(): void;
    resolvedNodes(): BaseNodeType[];
    private processEventTrigger;
    private _cookNodesWithMode;
    private _cookNodesAllTogether;
    private _cookNodesInBatch;
    private _cookNodes;
    private _cookNode;
    static PARAM_CALLBACK_updateResolvedNodes(node: NodeCookEventNode): void;
    private _updateResolvedNodes;
    private _callbackNameForNode;
    private _dispatchedFirstNodeCooked;
    private _dispatchedAllNodesCooked;
    private _cookStateByNodeId;
    private _reset;
    private _allNodesHaveCooked;
    private _onNodeCookComplete;
    static PARAM_CALLBACK_updateResolve(node: NodeCookEventNode): void;
    static PARAM_CALLBACK_printResolve(node: NodeCookEventNode): void;
    private printResolve;
}
export {};
