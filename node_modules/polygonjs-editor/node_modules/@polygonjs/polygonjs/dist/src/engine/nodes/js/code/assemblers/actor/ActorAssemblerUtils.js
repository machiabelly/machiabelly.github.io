"use strict";
import { MapUtils } from "../../../../../../core/MapUtils";
import { setToArray } from "../../../../../../core/SetUtils";
import { sanitizeName } from "../../../../../../core/String";
import { NodeContext } from "../../../../../poly/NodeContext";
import { JsConnectionPointType } from "../../../../utils/io/connections/Js";
export function nodeMethodName(node, outputName) {
  const functionNode = node.functionNode();
  if (functionNode == null) {
    return node.name();
  }
  const pathWithoutParentPath = node.path().replace(functionNode.path(), "");
  const sanitizedPath = sanitizeName(pathWithoutParentPath);
  const pathWithoutForwardSlash = sanitizedPath.substring(1);
  const pathWithoutUnderscore = pathWithoutForwardSlash.replace(/_/g, "");
  const sanitized = pathWithoutUnderscore;
  if (outputName) {
    return `${sanitized}_${outputName}`;
  } else {
    return sanitized;
  }
}
export function methodNameData(methodName) {
  const elements = methodName.split("_");
  if (elements.length > 1) {
    const outputName = elements[elements.length - 1];
    const nodeName = elements[elements.length - 2];
    elements.pop();
    const methodNameWithoutOutputName = elements.join("_");
    return { outputName, nodeName, methodNameWithoutOutputName };
  } else {
    const outputName = JsConnectionPointType.TRIGGER;
    const nodeName = elements[elements.length - 2];
    const methodNameWithoutOutputName = methodName;
    return { outputName, nodeName, methodNameWithoutOutputName };
  }
}
function isTriggeringNode(node) {
  return node.isTriggering() && _hasTriggerOutputConnected(node);
}
function _hasTriggerOutputConnected(node) {
  const outputConnectionPoints = node.io.outputs.namedOutputConnectionPoints();
  let triggerOutputIndices = [];
  let i = 0;
  if (outputConnectionPoints) {
    for (const outputConnectionPoint of outputConnectionPoints) {
      if (outputConnectionPoint.type() == JsConnectionPointType.TRIGGER) {
        triggerOutputIndices.push(i);
      }
      i++;
    }
  }
  for (const triggerOutputIndex of triggerOutputIndices) {
    const triggerConnections = node.io.connections.outputConnectionsByOutputIndex(triggerOutputIndex);
    if (triggerConnections != null && triggerConnections.size > 0) {
      return true;
    }
  }
  return false;
}
function evalChildren(parent, nodes, testFunction) {
  var _a;
  nodes.clear();
  (_a = parent.childrenController) == null ? void 0 : _a.traverseChildren((child) => {
    if (child.context() == NodeContext.JS) {
      const jsChild = child;
      if (testFunction(jsChild)) {
        nodes.add(jsChild);
      }
    }
  });
}
export function findTriggeringNodes(parent) {
  const nodes = /* @__PURE__ */ new Set();
  evalChildren(parent, nodes, isTriggeringNode);
  return nodes;
}
export function groupNodesByType(nodes, nodesByType) {
  nodesByType.clear();
  nodes.forEach((node) => {
    MapUtils.addToSetAtEntry(nodesByType, node.type(), node);
  });
}
export function getOutputIndices(node, callback) {
  let triggerOutputIndices = [];
  const outputConnectionPoints = node.io.outputs.namedOutputConnectionPoints();
  if (outputConnectionPoints) {
    let i = 0;
    for (const outputConnectionPoint of outputConnectionPoints) {
      if (callback(outputConnectionPoint) == true) {
        triggerOutputIndices.push(i);
      }
      i++;
    }
  }
  return triggerOutputIndices;
}
export function getInputIndices(node, callback) {
  let triggerInputIndices = [];
  const inputConnectionPoints = node.io.inputs.namedInputConnectionPoints();
  if (inputConnectionPoints) {
    let i = 0;
    for (const inputConnectionPoint of inputConnectionPoints) {
      if (callback(inputConnectionPoint) == true) {
        triggerInputIndices.push(i);
      }
      i++;
    }
  }
  return triggerInputIndices;
}
export function getConnectedOutputNodes(options) {
  const { node, triggerOutputIndices, triggerableNodes, recursive } = options;
  for (const triggerOutputIndex of triggerOutputIndices) {
    const triggerConnections = node.io.connections.outputConnectionsByOutputIndex(triggerOutputIndex);
    if (triggerConnections) {
      triggerConnections.forEach((triggerConnection) => {
        triggerableNodes.add(triggerConnection.nodeDest());
        if (recursive) {
          connectedTriggerableNodes({
            triggeringNodes: /* @__PURE__ */ new Set([triggerConnection.nodeDest()]),
            triggerableNodes,
            recursive
          });
        }
      });
    }
  }
}
export function connectedTriggerableNodes(options) {
  const { triggeringNodes, triggerableNodes, recursive } = options;
  triggeringNodes.forEach((node) => {
    const triggerOutputIndices = getOutputIndices(node, (c) => c.type() == JsConnectionPointType.TRIGGER);
    getConnectedOutputNodes({ node, triggerOutputIndices, triggerableNodes, recursive });
  });
}
const _nonTriggerInputNodes = /* @__PURE__ */ new Set();
const _nonTriggerInputIndices = [];
function _inputNodesFromConnectionWithCallback(node, callback, target) {
  _nonTriggerInputNodes.clear();
  _nonTriggerInputIndices.length = 0;
  const inputConnectionPoints = node.io.inputs.namedInputConnectionPoints();
  if (inputConnectionPoints) {
    let i = 0;
    for (const outputConnectionPoint of inputConnectionPoints) {
      if (callback(outputConnectionPoint)) {
        _nonTriggerInputIndices.push(i);
      }
      i++;
    }
  }
  for (const nonTriggerInputIndex of _nonTriggerInputIndices) {
    const connection = node.io.connections.inputConnection(nonTriggerInputIndex);
    if (connection) {
      _nonTriggerInputNodes.add(connection.nodeSrc());
    }
  }
  return setToArray(_nonTriggerInputNodes, target);
}
export function inputNodesExceptTrigger(node, target) {
  return _inputNodesFromConnectionWithCallback(node, (c) => true, target);
}
export function triggerInputIndex(triggeringNode, triggeredNode) {
  const triggerOutputIndices = getOutputIndices(triggeringNode, (c) => c.type() == JsConnectionPointType.TRIGGER);
  let index = null;
  for (const triggerOutputIndex of triggerOutputIndices) {
    const triggerConnections = triggeringNode.io.connections.outputConnectionsByOutputIndex(triggerOutputIndex);
    if (triggerConnections) {
      triggerConnections.forEach((triggerConnection) => {
        if (triggerConnection.nodeDest() == triggeredNode) {
          index = triggerConnection.inputIndex();
        }
      });
    }
  }
  return index;
}
const _triggerableNodesSet = /* @__PURE__ */ new Set();
const _triggerableNodes = [];
export function triggerableMethodCalls(triggeringNode) {
  _triggerableNodesSet.clear();
  connectedTriggerableNodes({
    triggeringNodes: /* @__PURE__ */ new Set([triggeringNode]),
    triggerableNodes: _triggerableNodesSet,
    recursive: false
  });
  setToArray(_triggerableNodesSet, _triggerableNodes);
  const methodCalls = [];
  for (const triggerableNode of _triggerableNodes) {
    const methodName = nodeMethodName(triggerableNode);
    const argIndex = triggerInputIndex(triggeringNode, triggerableNode);
    const methodCall = `this.${methodName}(${argIndex});`;
    methodCalls.push(methodCall);
  }
  return methodCalls.join("\n");
}
