"use strict";
import { TypedCopNode } from "./_Base";
import { CanvasTexture, VideoTexture } from "three";
import { NodeParamsConfig, ParamConfig } from "../utils/params/ParamsConfig";
import { TextureParamsController } from "./utils/TextureParamsController";
import { InputCloneMode } from "../../poly/InputCloneMode";
import { CopType } from "../../poly/registers/nodes/types/Cop";
import { CoreDomUtils } from "../../../core/DomUtils";
export function SnapshotCopParamConfig(Base) {
  return class Mixin extends Base {
    constructor() {
      super(...arguments);
      /** @param capture */
      this.capture = ParamConfig.BUTTON(null, {
        callback: (node) => {
          SnapshotCopNode.PARAM_CALLBACK_snapshot(node);
        }
      });
    }
  };
}
class SnapshotCopParamsConfig extends SnapshotCopParamConfig(NodeParamsConfig) {
}
const ParamsConfig = new SnapshotCopParamsConfig();
export class SnapshotCopNode extends TypedCopNode {
  constructor() {
    super(...arguments);
    this.paramsConfig = ParamsConfig;
  }
  static type() {
    return CopType.SNAPSHOT;
  }
  initializeNode() {
    this.io.inputs.setCount(1);
    this.io.inputs.initInputsClonedState(InputCloneMode.NEVER);
  }
  async cook(inputTextures) {
    const inputTexture = inputTextures[0];
    if (inputTexture && inputTexture instanceof VideoTexture) {
      const texture = this._videoSnapshotCanvas(inputTexture);
      if (texture) {
        TextureParamsController.copyTextureAttributes(texture, inputTexture);
        this.setTexture(texture);
        return;
      }
    } else {
      this.states.error.set("input texture is not a video");
    }
    this.cookController.endCook();
  }
  static PARAM_CALLBACK_snapshot(node) {
    node.paramCallbackSnapshot();
  }
  paramCallbackSnapshot() {
    this.setDirty();
  }
  _videoSnapshotCanvas(inputTexture) {
    const videoElement = inputTexture.image;
    if (!CoreDomUtils.isHTMLVideoElementLoaded(videoElement)) {
      this.states.error.set("video not loaded");
      return;
    }
    this._canvas = this._canvas || document.createElement("canvas");
    this._canvasTexture = this._canvasTexture || new CanvasTexture(this._canvas);
    this._canvas.width = inputTexture.image.videoWidth;
    this._canvas.height = inputTexture.image.videoHeight;
    const canvasCtx = this._canvas.getContext("2d");
    canvasCtx.drawImage(inputTexture.image, 0, 0, this._canvas.width, this._canvas.height);
    this._canvasTexture.needsUpdate = true;
    return this._canvasTexture;
  }
}
