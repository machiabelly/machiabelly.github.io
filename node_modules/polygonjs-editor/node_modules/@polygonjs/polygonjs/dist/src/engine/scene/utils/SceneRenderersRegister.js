"use strict";
import { Poly } from "../../Poly";
import { WebGLRenderer } from "three";
import { arrayCopy } from "../../../core/ArrayUtils";
const _renderers = [];
export class SceneRenderersRegister {
  constructor(scene) {
    this.scene = scene;
    this._renderersById = /* @__PURE__ */ new Map();
    this._registerTimeByRenderer = /* @__PURE__ */ new Map();
    this._resolves = [];
  }
  registerRenderer(renderer, options) {
    let assignId = true;
    if ((options == null ? void 0 : options.assignId) == false) {
      assignId = false;
    }
    if (assignId) {
      Poly.renderersController.assignIdToRenderer(renderer);
    }
    const id = Poly.renderersController.rendererId(renderer);
    if (id == null) {
      return;
    }
    this._renderersById.set(id, renderer);
    this._registerTimeByRenderer.set(renderer, performance.now());
    this._updateCache();
    if (this._renderersById.size == 1) {
      this._flushCallbacksWithRenderer(renderer);
    }
  }
  dispose() {
    this.renderers(_renderers);
    for (const renderer of _renderers) {
      this.deregisterRenderer(renderer);
    }
  }
  deregisterRenderer(renderer) {
    const id = Poly.renderersController.rendererId(renderer);
    if (id == null) {
      return;
    }
    this._renderersById.delete(id);
    renderer.dispose();
    this._updateCache();
  }
  lastRegisteredRenderer() {
    return this._lastRegisteredRenderer;
  }
  renderers(target) {
    this._renderersById.forEach((renderer) => {
      target.push(renderer);
    });
    return target;
  }
  _updateCache() {
    this._lastRegisteredRenderer = void 0;
    this._registerTimeByRenderer.forEach((registerTime, renderer) => {
      if (this._lastRegisteredRenderer == void 0) {
        this._lastRegisteredRenderer = renderer;
      } else {
        const lastRegisterTime = this._registerTimeByRenderer.get(this._lastRegisteredRenderer);
        if (lastRegisterTime != null) {
          if (registerTime > lastRegisterTime) {
            this._lastRegisteredRenderer = renderer;
          }
        }
      }
    });
  }
  _flushCallbacksWithRenderer(renderer) {
    const callbacks = [];
    arrayCopy(this._resolves, callbacks);
    this._resolves.length = 0;
    for (const c of callbacks) {
      c(renderer);
    }
  }
  async waitForAbstractRenderer() {
    if (this._lastRegisteredRenderer) {
      return this._lastRegisteredRenderer;
    } else {
      return new Promise((resolve, reject) => {
        this._resolves.push(resolve);
      });
    }
  }
  async waitForRenderer() {
    let renderer = await this.waitForAbstractRenderer();
    if (renderer instanceof WebGLRenderer) {
      return renderer;
    }
    renderer = renderer.webGLRenderer;
    if (renderer && renderer instanceof WebGLRenderer) {
      return renderer;
    }
    if (renderer) {
      if (!(renderer instanceof WebGLRenderer)) {
        console.log("unexpected renderer:", { renderer });
      }
    }
  }
}
