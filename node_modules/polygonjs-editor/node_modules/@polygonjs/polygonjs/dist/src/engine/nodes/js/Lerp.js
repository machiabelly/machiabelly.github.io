"use strict";
import { _vectorFunctionName_3vvf } from "../../functions/_MathGeneric";
import { Poly } from "../../Poly";
import { JsConnectionPointType, JsConnectionPointTypeFromArrayTypeMap } from "../utils/io/connections/Js";
import { MathFunctionArg3OperationFactory, DEFAULT_ALLOWED_TYPES } from "./_Math_Arg1Operation";
var LerpInput = /* @__PURE__ */ ((LerpInput2) => {
  LerpInput2["v0"] = "v0";
  LerpInput2["v1"] = "v1";
  LerpInput2["alpha"] = "alpha";
  return LerpInput2;
})(LerpInput || {});
const DefaultValues = {
  ["v0" /* v0 */]: 0,
  ["v1" /* v1 */]: 1,
  ["alpha" /* alpha */]: 0.5
};
const FUNCTION_NAME = "mix";
export class LerpJsNode extends MathFunctionArg3OperationFactory("lerp", {
  inputPrefix: "in",
  out: "lerp"
}) {
  _coreFunction(shadersCollectionController) {
    Poly.namedFunctionsRegister.getFunction(FUNCTION_NAME, this, shadersCollectionController).asString("", "", "");
    return FUNCTION_NAME;
  }
  _functionData() {
    return {
      vectorFunctionNameFunction: _vectorFunctionName_3vvf,
      mathFloat: "mathFloat_3",
      mathPrimArray: "mathPrimArray_3",
      mathVectorArray: "mathVectorArray_3"
    };
  }
  paramDefaultValue(name) {
    return DefaultValues[name];
  }
  _expectedInputName(index) {
    return ["v0" /* v0 */, "v1" /* v1 */, "alpha" /* alpha */][index];
  }
  _expectedInputTypes() {
    let first_input_type = this.io.connection_points.first_input_connection_type();
    const connectionPoints = this.io.inputs.namedInputConnectionPoints();
    if (first_input_type && connectionPoints) {
      if (!DEFAULT_ALLOWED_TYPES.includes(first_input_type)) {
        const first_connection = connectionPoints[0];
        if (first_connection) {
          first_input_type = first_connection.type();
        }
      }
    }
    const type = first_input_type || JsConnectionPointType.FLOAT;
    const boundType = JsConnectionPointTypeFromArrayTypeMap[type];
    return [type, boundType, JsConnectionPointType.FLOAT];
  }
}
