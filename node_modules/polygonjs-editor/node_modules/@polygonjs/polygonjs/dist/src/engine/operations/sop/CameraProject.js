"use strict";
import { BaseSopOperation } from "./_Base";
import { Vector3 } from "three";
import { InputCloneMode } from "../../poly/InputCloneMode";
import { isBooleanTrue } from "../../../core/Type";
const _points = [];
export class CameraProjectSopOperation extends BaseSopOperation {
  constructor() {
    super(...arguments);
    this._pointPosition = new Vector3();
  }
  static type() {
    return "cameraProject";
  }
  cook(inputCoreGroups, params) {
    var _a;
    const inputCoreGroup = inputCoreGroups[0];
    const cameraCoreGroup = inputCoreGroups[1];
    let cameraObject;
    const cameraCoreGroupObjects = cameraCoreGroup.threejsObjects();
    for (let cameraCoreGroupObject of cameraCoreGroupObjects) {
      cameraCoreGroupObject.traverse((childObject) => {
        if (!cameraObject) {
          if (childObject.isCamera) {
            cameraObject = childObject;
          }
        }
      });
    }
    if (!cameraObject) {
      (_a = this.states) == null ? void 0 : _a.error.set(`camera not found.`);
      return inputCoreGroup;
    }
    cameraObject.updateMatrix();
    if (cameraObject.isPerspectiveCamera || cameraObject.isOrthographicCamera) {
      cameraObject.updateProjectionMatrix();
    }
    inputCoreGroup.points(_points);
    const project = isBooleanTrue(params.project);
    for (const point of _points) {
      point.position(this._pointPosition);
      if (project) {
        this._pointPosition.project(cameraObject);
      } else {
        this._pointPosition.unproject(cameraObject);
      }
      point.setPosition(this._pointPosition);
    }
    return inputCoreGroup;
  }
}
CameraProjectSopOperation.DEFAULT_PARAMS = {
  project: true
};
CameraProjectSopOperation.INPUT_CLONED_STATE = InputCloneMode.FROM_NODE;
