"use strict";
import { BaseSopOperation } from "./_Base";
import { InputCloneMode } from "../../../engine/poly/InputCloneMode";
import { ThreejsCoreObject } from "../../../core/geometry/modules/three/ThreejsCoreObject";
import { CameraAttribute } from "../../../core/camera/CoreCamera";
import { CameraSopNodeType } from "../../poly/NodeContext";
import { isBooleanTrue } from "../../../core/Type";
import { WebXRVRFeature } from "../../../core/webXR/webXRVR/CommonVR";
import { CoreWebXRVRController } from "../../../core/webXR/webXRVR/CoreWebXRVRController";
import {
  WebXRFeatureStatus,
  WEBXR_FEATURE_STATUSES,
  WEBXR_FEATURE_STATUS_OPTIONAL_INDEX,
  DEFAULT_WEBXR_REFERENCE_SPACE_TYPE,
  WEBXR_REFERENCE_SPACE_TYPES
} from "../../../core/webXR/Common";
import { TypeAssert } from "../../poly/Assert";
import { CoreMask } from "../../../core/geometry/Mask";
const _CameraWebXRVRSopOperation = class extends BaseSopOperation {
  static type() {
    return CameraSopNodeType.WEBXR_VR;
  }
  cook(inputCoreGroups, params) {
    const coreGroup = inputCoreGroups[0];
    const objects = CoreMask.filterObjects(coreGroup, {
      group: params.group
    });
    if (this._node) {
      _CameraWebXRVRSopOperation.updateObject({ scene: this._node.scene(), objects, params, active: true });
    }
    return coreGroup;
  }
  static updateObject(options) {
    const { scene, objects, params, active } = options;
    scene.webXR.setVRControllerCreationFunction(function(renderer, camera, canvas, options2) {
      return new CoreWebXRVRController(scene, renderer, camera, canvas, options2);
    });
    const optionalFeatures = [];
    const requiredFeatures = [];
    function assignFeatureByStatus(feature, featureStatusIndex) {
      const featureStatus = WEBXR_FEATURE_STATUSES[featureStatusIndex] || WebXRFeatureStatus.NOT_USED;
      switch (featureStatus) {
        case WebXRFeatureStatus.NOT_USED: {
          return;
        }
        case WebXRFeatureStatus.OPTIONAL: {
          optionalFeatures.push(feature);
          return;
        }
        case WebXRFeatureStatus.REQUIRED: {
          requiredFeatures.push(feature);
          return;
        }
      }
      TypeAssert.unreachable(featureStatus);
    }
    assignFeatureByStatus(WebXRVRFeature.LOCAL_FLOOR, params.localFloor);
    assignFeatureByStatus(WebXRVRFeature.BOUNDED_FLOOR, params.boundedFloor);
    assignFeatureByStatus(WebXRVRFeature.HAND_TRACKING, params.handTracking);
    assignFeatureByStatus(WebXRVRFeature.LAYERS, params.layers);
    const optionalFeaturesStr = optionalFeatures.join(" ");
    const requiredFeaturesStr = requiredFeatures.join(" ");
    for (let object of objects) {
      ThreejsCoreObject.addAttribute(object, CameraAttribute.WEBXR_VR, active);
      ThreejsCoreObject.addAttribute(object, CameraAttribute.WEBXR_VR_FEATURES_OPTIONAL, optionalFeaturesStr);
      ThreejsCoreObject.addAttribute(object, CameraAttribute.WEBXR_VR_FEATURES_REQUIRED, requiredFeaturesStr);
      ThreejsCoreObject.addAttribute(
        object,
        CameraAttribute.WEBXR_VR_OVERRIDE_REFERENCE_SPACE_TYPE,
        isBooleanTrue(params.overrideReferenceSpaceType)
      );
      if (isBooleanTrue(params.overrideReferenceSpaceType)) {
        ThreejsCoreObject.addAttribute(
          object,
          CameraAttribute.WEBXR_VR_REFERENCE_SPACE_TYPE,
          WEBXR_REFERENCE_SPACE_TYPES[params.referenceSpaceType]
        );
      }
    }
  }
};
export let CameraWebXRVRSopOperation = _CameraWebXRVRSopOperation;
CameraWebXRVRSopOperation.DEFAULT_PARAMS = {
  group: "",
  localFloor: WEBXR_FEATURE_STATUS_OPTIONAL_INDEX,
  boundedFloor: WEBXR_FEATURE_STATUS_OPTIONAL_INDEX,
  handTracking: WEBXR_FEATURE_STATUS_OPTIONAL_INDEX,
  layers: WEBXR_FEATURE_STATUS_OPTIONAL_INDEX,
  overrideReferenceSpaceType: false,
  referenceSpaceType: WEBXR_REFERENCE_SPACE_TYPES.indexOf(DEFAULT_WEBXR_REFERENCE_SPACE_TYPE)
};
CameraWebXRVRSopOperation.INPUT_CLONED_STATE = InputCloneMode.FROM_NODE;
