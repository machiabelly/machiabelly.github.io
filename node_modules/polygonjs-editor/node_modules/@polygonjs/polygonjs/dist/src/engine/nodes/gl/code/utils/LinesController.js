"use strict";
import { MapUtils } from "../../../../../core/MapUtils";
export class LinesController {
  constructor(_shader_name) {
    this._shader_name = _shader_name;
    this._definitionsByNodeId = /* @__PURE__ */ new Map();
    this._bodyLinesByNodeId = /* @__PURE__ */ new Map();
  }
  get shader_name() {
    return this._shader_name;
  }
  // merge(otherLinesController: LinesController) {
  // 	console.log('merge start');
  // 	otherLinesController._definitionsByNodeId.forEach((definitions, nodeId) => {
  // 		this._addDefinitionsForNodeId(nodeId, definitions);
  // 	});
  // 	otherLinesController._bodyLinesByNodeId.forEach((lines, nodeId) => {
  // 		this._addBodyLinesForNodeId(nodeId, lines);
  // 	});
  // 	console.log('merge end');
  // }
  addDefinitions(node, definitions) {
    this._addDefinitionsForNodeId(node.graphNodeId(), definitions);
  }
  _addDefinitionsForNodeId(nodeId, definitions) {
    for (const definition of definitions) {
      MapUtils.pushOnArrayAtEntry(this._definitionsByNodeId, nodeId, definition);
    }
  }
  definitions(node) {
    return this._definitionsByNodeId.get(node.graphNodeId());
  }
  traverseDefinitions(callback) {
    this._definitionsByNodeId.forEach((definitions) => {
      for (const definition of definitions) {
        callback(definition);
      }
    });
  }
  // all_definition_nodes(scene: PolyScene) {
  // 	const nodes: BaseGlNodeType[] = [];
  // 	this._definitions_by_node_id.forEach((lines, node_id) => {
  // 		const node = scene.graph.node_from_id(node_id) as BaseGlNodeType;
  // 		nodes.push(node);
  // 	});
  // 	return nodes;
  // }
  addBodyLines(node, lines, options) {
    this._addBodyLinesForNodeId(node.graphNodeId(), lines);
  }
  _addBodyLinesForNodeId(nodeId, lines, options) {
    let makeUniq = true;
    if (options && options.makeUniq != null) {
      makeUniq = options.makeUniq;
    }
    const linesToUsed = [];
    if (makeUniq) {
      const currentLines = this._bodyLinesByNodeId.get(nodeId);
      for (const line of lines) {
        if (currentLines) {
          if (!currentLines.includes(line)) {
            linesToUsed.push(line);
          }
        } else {
          linesToUsed.push(line);
        }
      }
    } else {
      for (const line of lines) {
        linesToUsed.push(line);
      }
    }
    for (const line of linesToUsed) {
      MapUtils.pushOnArrayAtEntry(this._bodyLinesByNodeId, nodeId, line);
    }
  }
  bodyLines(node) {
    return this._bodyLinesByNodeId.get(node.graphNodeId());
  }
  // traverseBodyLines(callback: BodyLinesTraverseCallback) {
  // 	this._bodyLinesByNodeId.forEach((lines) => {
  // 		callback(lines);
  // 	});
  // }
  // all_body_line_nodes(scene: PolyScene) {
  // 	const nodes: BaseGlNodeType[] = [];
  // 	this._body_lines_by_node_id.forEach((lines, node_id) => {
  // 		const node = scene.graph.node_from_id(node_id) as BaseGlNodeType;
  // 		nodes.push(node);
  // 	});
  // 	return nodes;
  // }
}
