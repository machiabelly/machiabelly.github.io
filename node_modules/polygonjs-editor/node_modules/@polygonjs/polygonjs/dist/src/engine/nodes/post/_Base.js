"use strict";
import { TypedNode } from "../_Base";
import { NodeContext } from "../../poly/NodeContext";
import { FlagsControllerDB } from "../utils/FlagsController";
import { CoreCameraPostProcessController } from "../../../core/camera/CoreCameraPostProcessController";
import { CoreType } from "../../../core/Type";
function PostParamCallback(node, param) {
  TypedPostNode.PARAM_CALLBACK_updatePasses(node);
}
export const PostParamOptions = {
  cook: false,
  callback: PostParamCallback,
  computeOnDirty: true
  // important if an expression drives a param
};
export class TypedPostNode extends TypedNode {
  constructor() {
    super(...arguments);
    this.flags = new FlagsControllerDB(this);
    this._passesByEffectsComposer = /* @__PURE__ */ new Map();
  }
  static context() {
    return NodeContext.POST;
  }
  initializeNode() {
    this.flags.display.set(false);
    this.flags.display.onUpdate(() => {
      if (!this.flags.display.active()) {
        return;
      }
      const parent = this.parent();
      if (!(parent && parent.displayNodeController)) {
        return;
      }
      parent.displayNodeController.setDisplayNode(this);
    });
    this.io.inputs.setCount(0, 1);
    this.io.outputs.setHasOneOutput();
  }
  cook() {
    this.cookController.endCook();
  }
  setupComposer(context) {
    this._addPassFromInput(0, context);
    if (!this.flags.bypass.active()) {
      this._setupComposerIfActive(context);
    }
  }
  _setupComposerIfActive(context) {
    const pass = this.createPassForContext(context);
    if (pass) {
      const array = CoreType.isArray(pass) ? pass : [pass];
      for (const p of array) {
        context.composerController.addPassByNodeInBuildPassesProcess(this, p, context.composer);
      }
    }
  }
  passesByComposer(composer) {
    return this._passesByEffectsComposer.get(composer);
  }
  _addPassFromInput(index, context) {
    const input = this.io.inputs.input(index);
    if (input) {
      input.setupComposer(context);
    }
  }
  createPassForContext(context) {
    let pass = this._passesByEffectsComposer.get(context.composer);
    if (!pass) {
      pass = this.createPass(context);
      if (pass) {
        this._passesByEffectsComposer.set(context.composer, pass);
      }
    }
    return pass;
  }
  createPass(context) {
    return void 0;
  }
  static PARAM_CALLBACK_updatePasses(node) {
    node._updatePasses();
  }
  _updatePasses() {
    this._passesByEffectsComposer.forEach((passOrPasses) => {
      const passes = CoreType.isArray(passOrPasses) ? passOrPasses : [passOrPasses];
      for (const pass of passes) {
        this.updatePass(pass);
      }
    });
  }
  updatePass(pass) {
  }
  _postProcessNetworkNode() {
    const parentNode = this.parent();
    if (CoreCameraPostProcessController.isPostProcessNetworkNode(parentNode)) {
      return parentNode;
    } else {
      console.error("parent is neither a POST NETWORK or a POST node", parentNode);
      const parentPostNode = parentNode;
      return parentPostNode._postProcessNetworkNode();
    }
  }
  // protected _createRenderTarget(renderer: WebGLRenderer, options?: RenderTargetCreateOptions) {
  // 	const parentNode = this._postProcessNetworkNode();
  // 	return parentNode.effectsComposerController.createRenderTarget(renderer);
  // }
  // protected _createEffectComposer(renderer: WebGLRenderer, renderTarget?: WebGLRenderTarget) {
  // 	return new EffectComposer(renderer, renderTarget);
  // }
}
export class BasePostProcessNodeClass extends TypedPostNode {
}
