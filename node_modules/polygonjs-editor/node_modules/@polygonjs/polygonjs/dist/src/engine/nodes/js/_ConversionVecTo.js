"use strict";
import { TypedJsNode } from "./_Base";
import { ParamType } from "../../poly/ParamType";
import { NodeParamsConfig, ParamConfig } from "../utils/params/ParamsConfig";
import { JsConnectionPointType, JsConnectionPoint } from "../utils/io/connections/Js";
import { Color, Vector2, Vector3, Vector4 } from "three";
import { Poly } from "../../Poly";
class VecToParamsJsConfig extends NodeParamsConfig {
}
const ParamsConfig = new VecToParamsJsConfig();
class BaseVecToJsNode extends TypedJsNode {
  constructor() {
    super(...arguments);
    this.paramsConfig = ParamsConfig;
  }
}
function VecToJsFactory(type, options) {
  const { components, paramType, inputName } = options;
  return class VecToJsNode extends BaseVecToJsNode {
    static type() {
      return type;
    }
    initializeNode() {
      this.io.outputs.setNamedOutputConnectionPoints(
        components.map((c) => {
          return new JsConnectionPoint(c, JsConnectionPointType.FLOAT);
        })
      );
    }
    createParams() {
      this.addParam(paramType, inputName, components.map((c) => 0));
    }
    setLines(shadersCollectionController) {
      const vec = this.variableForInput(shadersCollectionController, inputName);
      this.io.outputs.used_output_names().forEach((c) => {
        const varName = this.jsVarName(c);
        shadersCollectionController.addBodyOrComputed(this, [
          {
            dataType: JsConnectionPointType.FLOAT,
            varName,
            value: `${vec}.${c}`
          }
        ]);
      });
    }
  };
}
const components_v2 = ["x", "y"];
const components_v3 = ["x", "y", "z"];
const components_v4 = ["x", "y", "z", "w"];
export class Vec2ToFloatJsNode extends VecToJsFactory("vec2ToFloat", {
  components: components_v2,
  paramType: ParamType.VECTOR2,
  inputName: "vec2"
}) {
}
export class Vec3ToFloatJsNode extends VecToJsFactory("vec3ToFloat", {
  components: components_v3,
  paramType: ParamType.VECTOR3,
  inputName: "vec3"
}) {
}
export class Vec4ToFloatJsNode extends VecToJsFactory("vec4ToFloat", {
  components: components_v4,
  paramType: ParamType.VECTOR4,
  inputName: "vec4"
}) {
}
class Vec3ToVec2ParamsJsConfig extends NodeParamsConfig {
  constructor() {
    super(...arguments);
    this.vec3 = ParamConfig.VECTOR3([0, 0, 0]);
  }
}
const ParamsConfig_Vec3ToVec2 = new Vec3ToVec2ParamsJsConfig();
const _Vec3ToVec2JsNode = class extends TypedJsNode {
  constructor() {
    super(...arguments);
    this.paramsConfig = ParamsConfig_Vec3ToVec2;
  }
  static type() {
    return "vec3ToVec2";
  }
  initializeNode() {
    this.io.outputs.setNamedOutputConnectionPoints([
      new JsConnectionPoint(_Vec3ToVec2JsNode.OUTPUT_NAME_VEC2, JsConnectionPointType.VECTOR2),
      new JsConnectionPoint(_Vec3ToVec2JsNode.OUTPUT_NAME_Z, JsConnectionPointType.FLOAT)
    ]);
  }
  setLines(shadersCollectionController) {
    const linesData = [];
    const out_vec2 = _Vec3ToVec2JsNode.OUTPUT_NAME_VEC2;
    const out_z = _Vec3ToVec2JsNode.OUTPUT_NAME_Z;
    const vec = this.variableForInputParam(shadersCollectionController, this.p.vec3);
    const used_output_names = this.io.outputs.used_output_names();
    if (used_output_names.indexOf(out_vec2) >= 0) {
      const varName = this.jsVarName(out_vec2);
      const tmpVar = shadersCollectionController.addVariable(this, new Vector2());
      const func = Poly.namedFunctionsRegister.getFunction("sizzleVec3XY", this, shadersCollectionController);
      linesData.push({
        dataType: JsConnectionPointType.VECTOR2,
        varName,
        value: func.asString(vec, tmpVar)
      });
    }
    if (used_output_names.indexOf(out_z) >= 0) {
      const varName = this.jsVarName(out_z);
      linesData.push({
        dataType: JsConnectionPointType.FLOAT,
        varName,
        value: `${vec}.z`
      });
    }
    shadersCollectionController.addBodyOrComputed(this, linesData);
  }
};
export let Vec3ToVec2JsNode = _Vec3ToVec2JsNode;
Vec3ToVec2JsNode.OUTPUT_NAME_VEC2 = "vec2";
Vec3ToVec2JsNode.OUTPUT_NAME_Z = "z";
class Vec2ToVec3ParamsJsConfig extends NodeParamsConfig {
  constructor() {
    super(...arguments);
    this.Vector2 = ParamConfig.VECTOR2([0, 0]);
    this.z = ParamConfig.FLOAT(0);
  }
}
const ParamsConfig_Vec2ToVec3 = new Vec2ToVec3ParamsJsConfig();
const _Vec2ToVec3JsNode = class extends TypedJsNode {
  constructor() {
    super(...arguments);
    this.paramsConfig = ParamsConfig_Vec2ToVec3;
  }
  static type() {
    return "vec2ToVec3";
  }
  initializeNode() {
    this.io.outputs.setNamedOutputConnectionPoints([
      new JsConnectionPoint(_Vec2ToVec3JsNode.OUTPUT_NAME_VEC3, JsConnectionPointType.VECTOR3)
    ]);
  }
  setLines(shadersCollectionController) {
    const linesData = [];
    const out_vec3 = _Vec2ToVec3JsNode.OUTPUT_NAME_VEC3;
    const vec2 = this.variableForInputParam(shadersCollectionController, this.p.Vector2);
    const z = this.variableForInputParam(shadersCollectionController, this.p.z);
    const varName = this.jsVarName(out_vec3);
    const tmpVar = shadersCollectionController.addVariable(this, new Vector3());
    const func = Poly.namedFunctionsRegister.getFunction("vec2ToVec3", this, shadersCollectionController);
    linesData.push({
      dataType: JsConnectionPointType.VECTOR3,
      varName,
      value: func.asString(vec2, z, tmpVar)
    });
    shadersCollectionController.addBodyOrComputed(this, linesData);
  }
};
export let Vec2ToVec3JsNode = _Vec2ToVec3JsNode;
Vec2ToVec3JsNode.OUTPUT_NAME_VEC3 = "vec3";
class Vec3ToVec4ParamsJsConfig extends NodeParamsConfig {
  constructor() {
    super(...arguments);
    this.vec3 = ParamConfig.VECTOR3([0, 0, 0]);
    this.w = ParamConfig.FLOAT(0);
  }
}
const ParamsConfig_Vec3ToVec4 = new Vec3ToVec4ParamsJsConfig();
const _Vec3ToVec4JsNode = class extends TypedJsNode {
  constructor() {
    super(...arguments);
    this.paramsConfig = ParamsConfig_Vec3ToVec4;
  }
  static type() {
    return "vec3ToVec4";
  }
  initializeNode() {
    this.io.outputs.setNamedOutputConnectionPoints([
      new JsConnectionPoint(_Vec3ToVec4JsNode.OUTPUT_NAME_VEC4, JsConnectionPointType.VECTOR4)
    ]);
  }
  setLines(shadersCollectionController) {
    const linesData = [];
    const out_vec4 = _Vec3ToVec4JsNode.OUTPUT_NAME_VEC4;
    const vec3 = this.variableForInputParam(shadersCollectionController, this.p.vec3);
    const w = this.variableForInputParam(shadersCollectionController, this.p.w);
    const varName = this.jsVarName(out_vec4);
    const tmpVar = shadersCollectionController.addVariable(this, new Vector4());
    const func = Poly.namedFunctionsRegister.getFunction("vec3ToVec4", this, shadersCollectionController);
    linesData.push({
      dataType: JsConnectionPointType.VECTOR4,
      varName,
      value: func.asString(vec3, w, tmpVar)
    });
    shadersCollectionController.addBodyOrComputed(this, linesData);
  }
};
export let Vec3ToVec4JsNode = _Vec3ToVec4JsNode;
// static readonly INPUT_NAME_VEC3 = 'vec3';
// static readonly INPUT_NAME_W = 'w';
Vec3ToVec4JsNode.OUTPUT_NAME_VEC4 = "vec4";
class Vec3ToColorParamsJsConfig extends NodeParamsConfig {
  constructor() {
    super(...arguments);
    this.vec3 = ParamConfig.VECTOR3([0, 0, 0]);
  }
}
const ParamsConfig_Vec3ToColor = new Vec3ToColorParamsJsConfig();
export class Vec3ToColorJsNode extends TypedJsNode {
  constructor() {
    super(...arguments);
    this.paramsConfig = ParamsConfig_Vec3ToColor;
  }
  static type() {
    return "vec3ToColor";
  }
  initializeNode() {
    this.io.outputs.setNamedOutputConnectionPoints([
      new JsConnectionPoint(JsConnectionPointType.COLOR, JsConnectionPointType.COLOR)
    ]);
  }
  setLines(shadersCollectionController) {
    const linesData = [];
    const vec3 = this.variableForInputParam(shadersCollectionController, this.p.vec3);
    const varName = this.jsVarName(JsConnectionPointType.COLOR);
    const tmpVar = shadersCollectionController.addVariable(this, new Color());
    const func = Poly.namedFunctionsRegister.getFunction("vec3ToColor", this, shadersCollectionController);
    linesData.push({
      dataType: JsConnectionPointType.COLOR,
      varName,
      value: func.asString(vec3, tmpVar)
    });
    shadersCollectionController.addBodyOrComputed(this, linesData);
  }
}
class ColorToVec3ParamsJsConfig extends NodeParamsConfig {
  constructor() {
    super(...arguments);
    this.color = ParamConfig.COLOR([0, 0, 0]);
  }
}
const ParamsConfig_ColorToVec3 = new ColorToVec3ParamsJsConfig();
export class ColorToVec3JsNode extends TypedJsNode {
  constructor() {
    super(...arguments);
    this.paramsConfig = ParamsConfig_ColorToVec3;
  }
  static type() {
    return "colorToVec3";
  }
  initializeNode() {
    this.io.outputs.setNamedOutputConnectionPoints([
      new JsConnectionPoint(JsConnectionPointType.VECTOR3, JsConnectionPointType.VECTOR3)
    ]);
  }
  setLines(shadersCollectionController) {
    const linesData = [];
    const color = this.variableForInputParam(shadersCollectionController, this.p.color);
    const varName = this.jsVarName(JsConnectionPointType.VECTOR3);
    const tmpVar = shadersCollectionController.addVariable(this, new Vector3());
    const func = Poly.namedFunctionsRegister.getFunction("colorToVec3", this, shadersCollectionController);
    linesData.push({
      dataType: JsConnectionPointType.COLOR,
      varName,
      value: func.asString(color, tmpVar)
    });
    shadersCollectionController.addBodyOrComputed(this, linesData);
  }
}
