/**
 * blends 2 geometries together.
 *
 * @remarks
 * Note that both geometries must have the same number of points for predictable results
 *
 */
import { TypedSopNode } from './_Base';
import { NodeParamsConfig } from '../utils/params/ParamsConfig';
import { CoreGroup } from '../../../core/geometry/Group';
import { SopType } from '../../poly/registers/nodes/types/Sop';
declare class BlendSopParamsConfig extends NodeParamsConfig {
    /** @param name of the attribute to blend */
    attribName: import("../utils/params/ParamsConfig").ParamTemplate<import("../../index_all").ParamType.STRING>;
    /** @param blend value. 0 means the result will equal the left input, 1 will equal the right input, and 0.5 will be an average of both. */
    blend: import("../utils/params/ParamsConfig").ParamTemplate<import("../../index_all").ParamType.FLOAT>;
    /** @param update normals */
    updateNormals: import("../utils/params/ParamsConfig").ParamTemplate<import("../../index_all").ParamType.BOOLEAN>;
}
export declare class BlendSopNode extends TypedSopNode<BlendSopParamsConfig> {
    paramsConfig: BlendSopParamsConfig;
    static type(): SopType;
    initializeNode(): void;
    cook(inputCoreGroups: CoreGroup[]): void;
    private blend;
}
export {};
