"use strict";
import { TypedPostNode, PostParamOptions } from "./_Base";
import { NodeParamsConfig, ParamConfig } from "../utils/params/ParamsConfig";
import { isBooleanTrue } from "../../../core/Type";
import { MeshBasicMaterial, Color } from "three";
import { UpdateScenePass } from "./utils/effects/UpdateScenePass";
import { PostType } from "../../poly/registers/nodes/types/Post";
const MATTE_MATERIAL = new MeshBasicMaterial({ color: new Color(0, 0, 0) });
class UpdateScenePostParamsConfig extends NodeParamsConfig {
  constructor() {
    super(...arguments);
    /** @param reset */
    this.reset = ParamConfig.BOOLEAN(0, {
      ...PostParamOptions
    });
    /** @param objects Mask */
    this.objectsMask = ParamConfig.STRING("*", {
      ...PostParamOptions,
      visibleIf: { reset: 0 },
      objectMask: true
    });
    /** @param invertMask */
    this.invertMask = ParamConfig.BOOLEAN(0, {
      ...PostParamOptions,
      visibleIf: { reset: 0 }
    });
    /** @param prints which objects are targeted by this node, for debugging */
    // printFoundObjectsFromMask = ParamConfig.BUTTON(null, {
    // 	visibleIf: {reset: 0},
    // 	callback: (node: BaseNodeType) => {
    // 		UpdateScenePostNode.PARAM_CALLBACK_printResolve(node as UpdateScenePostNode);
    // 	},
    // });
    /** @param update selected objects material to a matte one */
    this.setMatteMaterial = ParamConfig.BOOLEAN(1, {
      ...PostParamOptions,
      visibleIf: { reset: 0 },
      separatorBefore: true
    });
    /** @param set visible state  */
    this.setVisible = ParamConfig.BOOLEAN(0, {
      ...PostParamOptions,
      visibleIf: { reset: 0 },
      separatorBefore: true
    });
    /** @param set visible state  */
    this.visible = ParamConfig.BOOLEAN(0, {
      ...PostParamOptions,
      visibleIf: { reset: 0, setVisible: 1 }
    });
    /** @param reset */
    this.resetChanges = ParamConfig.BUTTON(null, {
      visibleIf: { reset: 0 },
      callback: (node) => {
        UpdateScenePostNode.PARAM_CALLBACK_resetChanges(node);
      },
      separatorBefore: true
    });
  }
  /** @param material */
  // material = ParamConfig.NODE_PATH('', {
  // 	...PostParamOptions,
  // 	visibleIf: {overrideMaterial: 1},
  // 	nodeSelection: {
  // 		context: NodeContext.MAT,
  // 	},
  // 	callback: (node: BaseNodeType) => {
  // 		UpdateScenePostNode.PARAM_CALLBACK_updatePassesMaterial(node as UpdateScenePostNode);
  // 	},
  // });
}
const ParamsConfig = new UpdateScenePostParamsConfig();
export class UpdateScenePostNode extends TypedPostNode {
  constructor() {
    super(...arguments);
    this.paramsConfig = ParamsConfig;
    // private _resetMat() {
    // 	this._passesByEffectsComposer.forEach((passOrPasses) => {
    // 		const passes = CoreType.isArray(passOrPasses) ? passOrPasses : [passOrPasses];
    // 		for (let pass of passes) {
    // 			const effect = _effectFromPass(pass);
    // 			if (effect) {
    // 				effect.resetChanges();
    // 			}
    // 		}
    // 	});
    // }
    // static PARAM_CALLBACK_updatePassesMaterial(node: UpdateScenePostNode) {
    // 	node._updatePassesMaterial();
    // }
    // private _updatePassesMaterial() {
    // 	const matNode = this.pv.material.nodeWithContext(NodeContext.MAT);
    // 	if (!matNode) {
    // 		this._passes_by_requester_id.forEach((pass) => {
    // 			pass.material = undefined;
    // 		});
    // 	} else {
    // 		const mat = matNode.material;
    // 		this._passes_by_requester_id.forEach((pass) => {
    // 			pass.material = mat;
    // 		});
    // 	}
    // }
    this._objectsList = [];
    this._materialByMesh = /* @__PURE__ */ new Map();
    // private _parentByObject: Map<Object3D, Object3D | null> = new Map();
    this._visibleByObject = /* @__PURE__ */ new Map();
    this._updateObjectBound = this._updateObject.bind(this);
  }
  static type() {
    return PostType.UPDATE_SCENE;
  }
  initializeNode() {
    super.initializeNode();
    this.io.inputs.setCount(0, 2);
  }
  createPass(context) {
    const pass = new UpdateScenePass({
      // scene: this.scene(),
      node: this,
      reset: isBooleanTrue(this.pv.reset),
      nodeToReset: this._nodeToReset(context)
      // objectsMask: this.pv.objectsMask,
      // invertMask: isBooleanTrue(this.pv.invertMask),
      // setMatteMaterial: isBooleanTrue(this.pv.setMatteMaterial),
      // setVisible: isBooleanTrue(this.pv.setVisible),
      // visible: isBooleanTrue(this.pv.visible),
    });
    this.updatePass(pass);
    return pass;
  }
  updatePass(pass) {
  }
  _nodeToReset(context) {
    const input2 = this.io.inputs.input(1);
    if (!input2) {
      return;
    }
    if (input2 instanceof UpdateScenePostNode) {
      return input2;
    }
  }
  // static PARAM_CALLBACK_printResolve(node: UpdateScenePostNode) {
  // 	node._printResolve();
  // }
  // private _printResolve() {
  // 	let firstPass: EffectPass | undefined;
  // 	this._passesByEffectsComposer.forEach((passOrPasses) => {
  // 		const passes = CoreType.isArray(passOrPasses) ? passOrPasses : [passOrPasses];
  // 		firstPass = firstPass || passes[0];
  // 	});
  // 	if (firstPass) {
  // 		const effect = _effectFromPass(firstPass);
  // 		if (effect) {
  // 			console.log(hhis.objectsList());
  // 		}
  // 	} else {
  // 		console.error(`no pass generated by this node, maybe it has not rendered yet?`);
  // 	}
  // }
  static PARAM_CALLBACK_resetChanges(node) {
    node.resetChanges();
  }
  objectsList() {
    return this._objectsList;
  }
  applyChanges() {
    const changeNeeded = isBooleanTrue(this.pv.setMatteMaterial) || isBooleanTrue(this.pv.setVisible);
    if (changeNeeded) {
      this._objectsList.length = 0;
      const mask = this.pv.objectsMask;
      this._scene.objectsController.traverseObjectsWithMask(
        mask,
        this._updateObjectBound,
        void 0,
        this.pv.invertMask
      );
    }
  }
  resetChanges() {
    this._materialByMesh.forEach((mat, mesh) => {
      mesh.material = mat;
    });
    this._materialByMesh.clear();
    this._visibleByObject.forEach((visible, obj) => {
      obj.visible = visible;
    });
    this._visibleByObject.clear();
  }
  _updateObject(obj) {
    this._objectsList.push(obj);
    if (isBooleanTrue(this.pv.setMatteMaterial)) {
      const mesh = obj;
      if (mesh.material) {
        this._materialByMesh.set(mesh, mesh.material);
        mesh.material = MATTE_MATERIAL;
      }
    }
    if (isBooleanTrue(this.pv.setVisible)) {
      const visible = this.pv.visible;
      if (obj.visible != visible) {
        this._visibleByObject.set(obj, obj.visible);
        obj.visible = visible;
      }
    }
  }
}
