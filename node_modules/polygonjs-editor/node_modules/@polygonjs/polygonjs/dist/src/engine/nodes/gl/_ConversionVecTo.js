"use strict";
import { TypedGlNode } from "./_Base";
import { ParamType } from "../../poly/ParamType";
import { NodeParamsConfig } from "../utils/params/ParamsConfig";
import { GlConnectionPointType, GlConnectionPoint } from "../utils/io/connections/Gl";
class VecToParamsGlConfig extends NodeParamsConfig {
}
const ParamsConfig = new VecToParamsGlConfig();
class BaseVecToGlNode extends TypedGlNode {
  constructor() {
    super(...arguments);
    this.paramsConfig = ParamsConfig;
  }
}
function VecToGlFactory(type, options) {
  const components = options.components;
  const param_type = options.param_type;
  return class VecToGlNode extends BaseVecToGlNode {
    static type() {
      return type;
    }
    initializeNode() {
      this.io.outputs.setNamedOutputConnectionPoints(
        components.map((c) => {
          return new GlConnectionPoint(c, GlConnectionPointType.FLOAT);
        })
      );
    }
    createParams() {
      this.addParam(param_type, "vec", components.map((c) => 0));
    }
    setLines(shaders_collection_controller) {
      const body_lines = [];
      const vec = this.variableForInput("vec");
      this.io.outputs.used_output_names().forEach((c) => {
        const var_name = this.glVarName(c);
        body_lines.push(`float ${var_name} = ${vec}.${c}`);
      });
      shaders_collection_controller.addBodyLines(this, body_lines);
    }
  };
}
const components_v2 = ["x", "y"];
const components_v3 = ["x", "y", "z"];
const components_v4 = ["x", "y", "z", "w"];
export class Vec2ToFloatGlNode extends VecToGlFactory("vec2ToFloat", {
  components: ["x", "y"],
  param_type: ParamType.VECTOR2
}) {
}
export class Vec3ToFloatGlNode extends VecToGlFactory("vec3ToFloat", {
  components: ["x", "y", "z"],
  param_type: ParamType.VECTOR3
}) {
}
export class Vec4ToFloatGlNode extends VecToGlFactory("vec4ToFloat", {
  components: components_v4,
  param_type: ParamType.VECTOR4
}) {
}
const _Vec4ToVec3GlNode = class extends BaseVecToGlNode {
  static type() {
    return "vec4ToVec3";
  }
  initializeNode() {
    this.io.outputs.setNamedOutputConnectionPoints([
      new GlConnectionPoint(_Vec4ToVec3GlNode.OUTPUT_NAME_VEC3, GlConnectionPointType.VEC3),
      new GlConnectionPoint(_Vec4ToVec3GlNode.OUTPUT_NAME_W, GlConnectionPointType.FLOAT)
    ]);
  }
  createParams() {
    this.addParam(ParamType.VECTOR4, _Vec4ToVec3GlNode.INPUT_NAME_VEC4, components_v4.map((c) => 0));
  }
  setLines(shaders_collection_controller) {
    const body_lines = [];
    const in_vec4 = _Vec4ToVec3GlNode.INPUT_NAME_VEC4;
    const out_vec3 = _Vec4ToVec3GlNode.OUTPUT_NAME_VEC3;
    const out_w = _Vec4ToVec3GlNode.OUTPUT_NAME_W;
    const vec = this.variableForInput(in_vec4);
    const used_output_names = this.io.outputs.used_output_names();
    if (used_output_names.indexOf(out_vec3) >= 0) {
      const var_name = this.glVarName(out_vec3);
      body_lines.push(`vec3 ${var_name} = ${vec}.xyz`);
    }
    if (used_output_names.indexOf(out_w) >= 0) {
      const var_name = this.glVarName(out_w);
      body_lines.push(`float ${var_name} = ${vec}.w`);
    }
    shaders_collection_controller.addBodyLines(this, body_lines);
  }
};
export let Vec4ToVec3GlNode = _Vec4ToVec3GlNode;
Vec4ToVec3GlNode.INPUT_NAME_VEC4 = "vec4";
Vec4ToVec3GlNode.OUTPUT_NAME_VEC3 = "vec3";
Vec4ToVec3GlNode.OUTPUT_NAME_W = "w";
const _Vec3ToVec2GlNode = class extends BaseVecToGlNode {
  static type() {
    return "vec3ToVec2";
  }
  initializeNode() {
    this.io.outputs.setNamedOutputConnectionPoints([
      new GlConnectionPoint(_Vec3ToVec2GlNode.OUTPUT_NAME_VEC2, GlConnectionPointType.VEC2),
      new GlConnectionPoint(_Vec3ToVec2GlNode.OUTPUT_NAME_Z, GlConnectionPointType.FLOAT)
    ]);
  }
  createParams() {
    this.addParam(ParamType.VECTOR3, _Vec3ToVec2GlNode.INPUT_NAME_VEC3, components_v3.map((c) => 0));
  }
  setLines(shaders_collection_controller) {
    const body_lines = [];
    const in_vec3 = _Vec3ToVec2GlNode.INPUT_NAME_VEC3;
    const out_vec2 = _Vec3ToVec2GlNode.OUTPUT_NAME_VEC2;
    const out_z = _Vec3ToVec2GlNode.OUTPUT_NAME_Z;
    const vec = this.variableForInput(in_vec3);
    const used_output_names = this.io.outputs.used_output_names();
    if (used_output_names.indexOf(out_vec2) >= 0) {
      const var_name = this.glVarName(out_vec2);
      body_lines.push(`vec2 ${var_name} = ${vec}.xy`);
    }
    if (used_output_names.indexOf(out_z) >= 0) {
      const var_name = this.glVarName(out_z);
      body_lines.push(`float ${var_name} = ${vec}.z`);
    }
    shaders_collection_controller.addBodyLines(this, body_lines);
  }
};
export let Vec3ToVec2GlNode = _Vec3ToVec2GlNode;
Vec3ToVec2GlNode.INPUT_NAME_VEC3 = "vec3";
Vec3ToVec2GlNode.OUTPUT_NAME_VEC2 = "vec2";
Vec3ToVec2GlNode.OUTPUT_NAME_Z = "z";
const _Vec2ToVec3GlNode = class extends BaseVecToGlNode {
  static type() {
    return "vec2ToVec3";
  }
  initializeNode() {
    this.io.outputs.setNamedOutputConnectionPoints([
      new GlConnectionPoint(_Vec2ToVec3GlNode.OUTPUT_NAME_VEC3, GlConnectionPointType.VEC3)
    ]);
  }
  createParams() {
    this.addParam(ParamType.VECTOR2, _Vec2ToVec3GlNode.INPUT_NAME_VEC2, components_v2.map((c) => 0));
    this.addParam(ParamType.FLOAT, _Vec2ToVec3GlNode.INPUT_NAME_Z, 0);
  }
  setLines(shaders_collection_controller) {
    const body_lines = [];
    const in_vec2 = _Vec2ToVec3GlNode.INPUT_NAME_VEC2;
    const in_z = _Vec2ToVec3GlNode.INPUT_NAME_Z;
    const out_vec3 = _Vec2ToVec3GlNode.OUTPUT_NAME_VEC3;
    const vec2 = this.variableForInput(in_vec2);
    const z = this.variableForInput(in_z);
    const var_name = this.glVarName(out_vec3);
    body_lines.push(`vec3 ${var_name} = vec3(${vec2}.xy, ${z})`);
    shaders_collection_controller.addBodyLines(this, body_lines);
  }
};
export let Vec2ToVec3GlNode = _Vec2ToVec3GlNode;
Vec2ToVec3GlNode.INPUT_NAME_VEC2 = "vec2";
Vec2ToVec3GlNode.INPUT_NAME_Z = "z";
Vec2ToVec3GlNode.OUTPUT_NAME_VEC3 = "vec3";
const _Vec3ToVec4GlNode = class extends BaseVecToGlNode {
  static type() {
    return "vec3ToVec4";
  }
  initializeNode() {
    this.io.outputs.setNamedOutputConnectionPoints([
      new GlConnectionPoint(_Vec3ToVec4GlNode.OUTPUT_NAME_VEC4, GlConnectionPointType.VEC4)
    ]);
  }
  createParams() {
    this.addParam(ParamType.VECTOR3, _Vec3ToVec4GlNode.INPUT_NAME_VEC3, components_v3.map((c) => 0));
    this.addParam(ParamType.FLOAT, _Vec3ToVec4GlNode.INPUT_NAME_W, 0);
  }
  setLines(shaders_collection_controller) {
    const body_lines = [];
    const in_vec3 = _Vec3ToVec4GlNode.INPUT_NAME_VEC3;
    const in_w = _Vec3ToVec4GlNode.INPUT_NAME_W;
    const out_vec4 = _Vec3ToVec4GlNode.OUTPUT_NAME_VEC4;
    const vec3 = this.variableForInput(in_vec3);
    const w = this.variableForInput(in_w);
    const var_name = this.glVarName(out_vec4);
    body_lines.push(`vec4 ${var_name} = vec4(${vec3}.xyz, ${w})`);
    shaders_collection_controller.addBodyLines(this, body_lines);
  }
};
export let Vec3ToVec4GlNode = _Vec3ToVec4GlNode;
Vec3ToVec4GlNode.INPUT_NAME_VEC3 = "vec3";
Vec3ToVec4GlNode.INPUT_NAME_W = "w";
Vec3ToVec4GlNode.OUTPUT_NAME_VEC4 = "vec4";
