"use strict";
import { sanitizeExportedString } from "./sanitize";
import { isString } from "../../../../core/Type";
export class NodeJsonExporter {
  // = {} as NodeJsonExporterData;
  constructor(_node, dispatcher) {
    this._node = _node;
    this.dispatcher = dispatcher;
  }
  async data(options) {
    var _a, _b, _c, _d, _e, _f;
    if (!this._isRoot()) {
      this._node.scene().nodesController.registerNodeContextSignature(this._node);
    }
    this._data = {
      type: this._node.type()
    };
    if (this._node.polyNodeController) {
      this._data["polyNode"] = {
        locked: this._node.polyNodeController.locked()
      };
    }
    const nodes_data = await this.nodes_data(options);
    if (Object.keys(nodes_data).length > 0) {
      this._data["nodes"] = nodes_data;
    }
    const params_data = this.params_data();
    if (Object.keys(params_data).length > 0) {
      this._data["params"] = params_data;
    }
    if (!this._isRoot()) {
      if (this._node.io.inputs.maxInputsCountOverriden()) {
        this._data["maxInputsCount"] = this._node.io.inputs.maxInputsCount();
      }
      const inputs_data = this.inputs_data();
      if (inputs_data.length > 0) {
        this._data["inputs"] = inputs_data;
      }
      const connection_points_data = this.connection_points_data();
      if (connection_points_data) {
        this._data["connection_points"] = connection_points_data;
      }
    }
    if (this._node.flags) {
      const flags_data = {};
      if (this._node.flags.hasBypass() || this._node.flags.hasDisplay() || this._node.flags.hasOptimize()) {
        if (this._node.flags.hasBypass()) {
          if ((_a = this._node.flags.bypass) == null ? void 0 : _a.active()) {
            flags_data["bypass"] = this._node.flags.bypass.active();
          }
        }
        if (this._node.flags.hasDisplay()) {
          if (((_b = this._node.flags.display) == null ? void 0 : _b.active()) || !((_c = this._node.parent()) == null ? void 0 : _c.displayNodeController)) {
            flags_data["display"] = (_d = this._node.flags.display) == null ? void 0 : _d.active();
          }
        }
        if (this._node.flags.hasOptimize()) {
          if ((_e = this._node.flags.optimize) == null ? void 0 : _e.active()) {
            flags_data["optimize"] = (_f = this._node.flags.optimize) == null ? void 0 : _f.active();
          }
        }
      }
      if (Object.keys(flags_data).length > 0) {
        this._data["flags"] = flags_data;
      }
    }
    if (this._node.io.inputs.overrideClonedStateAllowed()) {
      const overriden = this._node.io.inputs.clonedStateOverriden();
      if (overriden) {
        this._data["cloned_state_overriden"] = overriden;
      }
    }
    const withPersistedConfig = options.withPersistedConfig == null ? true : options.withPersistedConfig;
    if (withPersistedConfig == true) {
      const persisted_config = this._node.persisted_config;
      if (persisted_config) {
        const persisted_config_data = options.showPolyNodesData ? await persisted_config.toData() : await persisted_config.toDataWithoutShaders();
        if (persisted_config_data) {
          this._data.persisted_config = persisted_config_data;
        }
      }
    }
    this.add_custom();
    return this._data;
  }
  uiData(options) {
    const data = this.ui_data_without_children();
    const children = this._node.children();
    if (children.length > 0) {
      const nodesData = {};
      for (let child of children) {
        const node_exporter = this.dispatcher.dispatchNode(child);
        nodesData[child.name()] = node_exporter.uiData(options);
      }
      data["nodes"] = nodesData;
    }
    return data;
  }
  ui_data_without_children() {
    var _a;
    const data = {};
    if (!this._isRoot()) {
      const ui_data = this._node.uiData;
      data["pos"] = ui_data.position().toArray();
      const comment = ui_data.comment();
      if (comment) {
        data["comment"] = sanitizeExportedString(comment);
      }
      if (this._node.childrenAllowed()) {
        const selection = (_a = this._node.childrenController) == null ? void 0 : _a.selection;
        if (selection && this._node.children().length > 0) {
          const selected_children = [];
          const selected_ids = {};
          const selectedNodes = [];
          selection.nodes(selectedNodes);
          for (const selected_node of selectedNodes) {
            selected_ids[selected_node.graphNodeId()] = true;
          }
          for (const child of this._node.children()) {
            if (child.graphNodeId() in selected_ids) {
              selected_children.push(child);
            }
          }
          const selection_data = selected_children.map((n) => n.name());
          if (selection_data.length > 0) {
            data["selection"] = selection_data;
          }
        }
      }
    }
    return data;
  }
  async persistedConfigData(shadersData, jsFunctionBodiesData, options) {
    const children = this._node.children();
    if (children.length > 0) {
      for (let child of children) {
        const node_exporter = this.dispatcher.dispatchNode(child);
        await node_exporter.persistedConfigData(shadersData, jsFunctionBodiesData, options);
      }
    }
    if (this._node.persisted_config) {
      const persisted_config_data = await this._node.persisted_config.toData();
      if (persisted_config_data) {
        if (persisted_config_data.shaders) {
          shadersData[this._node.path()] = persisted_config_data.shaders;
          return;
        }
        if (persisted_config_data.functionBody != null) {
          if (isString(persisted_config_data.functionBody)) {
            jsFunctionBodiesData[this._node.path()] = persisted_config_data.functionBody;
            return;
          } else {
            const dict = {};
            const keys = Object.keys(persisted_config_data.functionBody);
            for (let key of keys) {
              dict[key] = persisted_config_data.functionBody[key];
            }
            jsFunctionBodiesData[this._node.path()] = dict;
            return;
          }
        }
        console.warn(`persisted config data not handled`, persisted_config_data);
      }
    }
  }
  // async jsFunctionBodies(data: NodeJSONFunctionBodiesData, options: JSONExporterDataRequestOption = {}): Promise<void> {
  // 	const children = this._node.children();
  // 	if (children.length > 0) {
  // 		for (let child of children) {
  // 			const node_exporter = this.dispatcher.dispatchNode(child);
  // 			await node_exporter.jsFunctionBodies(data);
  // 		}
  // 	}
  // 	if (this._node.persisted_config) {
  // 		const persisted_config_data = await this._node.persisted_config.toData();
  // 		if (persisted_config_data && persisted_config_data.functionBody) {
  // 			data[this._node.path()] = persisted_config_data.functionBody
  // 		}
  // 	}
  // }
  _isRoot() {
    return this._node.parent() === null && this._node.graphNodeId() == this._node.root().graphNodeId();
  }
  inputs_data() {
    const data = [];
    this._node.io.inputs.inputs().forEach((input, input_index) => {
      var _a, _b;
      if (input) {
        const connection = this._node.io.connections.inputConnection(input_index);
        if (this._node.io.inputs.hasNamedInputs()) {
          const inputConnectionPoints = this._node.io.inputs.namedInputConnectionPoints();
          const outputConnectionPoints = input.io.outputs.namedOutputConnectionPoints();
          if (inputConnectionPoints && outputConnectionPoints) {
            const inputName = (_a = inputConnectionPoints[input_index]) == null ? void 0 : _a.name();
            const output_index = connection.outputIndex();
            const output_name = (_b = outputConnectionPoints[output_index]) == null ? void 0 : _b.name();
            if (output_name) {
              data[input_index] = {
                index: input_index,
                inputName,
                node: input.name(),
                output: output_name
              };
            }
          }
        } else {
          data[input_index] = input.name();
        }
      }
    });
    return data;
  }
  connection_points_data() {
    if (!this._node.io.has_connection_points_controller) {
      return;
    }
    if (!this._node.io.connection_points.initialized()) {
      return;
    }
    if (this._node.io.inputs.hasNamedInputs() || this._node.io.outputs.hasNamedOutputs()) {
      const data = {};
      if (this._node.io.inputs.hasNamedInputs()) {
        data["in"] = [];
        const connectionPoints = this._node.io.inputs.namedInputConnectionPoints();
        if (connectionPoints) {
          for (let cp of connectionPoints) {
            if (cp) {
              data["in"].push(cp.toJSON());
            }
          }
        }
      }
      if (this._node.io.outputs.hasNamedOutputs()) {
        data["out"] = [];
        const connectionPoints = this._node.io.outputs.namedOutputConnectionPoints();
        if (connectionPoints) {
          for (let cp of connectionPoints) {
            if (cp) {
              data["out"].push(cp.toJSON());
            }
          }
        }
      }
      return data;
    }
  }
  params_data() {
    const data = {};
    for (let param_name of this._node.params.names) {
      const param = this._node.params.get(param_name);
      if (param && !param.parentParam()) {
        const param_exporter = this.dispatcher.dispatchParam(param);
        if (param_exporter.required()) {
          const params_data = param_exporter.data();
          data[param.name()] = params_data;
        }
      }
    }
    return data;
  }
  async nodes_data(options) {
    const data = {};
    for (let child of this._node.children()) {
      const node_exporter = this.dispatcher.dispatchNode(child);
      data[child.name()] = await node_exporter.data(options);
    }
    return data;
  }
  add_custom() {
  }
}
