"use strict";
import {
  JsConnectionPointType,
  ARRAYABLE_CONNECTION_TYPES,
  JsConnectionPointTypeToArrayTypeMap
} from "../utils/io/connections/Js";
import { TypedJsNode } from "./_Base";
import { NodeParamsConfig } from "../utils/params/ParamsConfig";
import {
  createPrimitiveArray,
  createVectorArray
} from "./code/assemblers/_BaseJsPersistedConfigUtils";
import { Poly } from "../../Poly";
const ALLOWED_INPUT_TYPES = ARRAYABLE_CONNECTION_TYPES;
class ElementsToArrayJsParamsConfig extends NodeParamsConfig {
}
const ParamsConfig = new ElementsToArrayJsParamsConfig();
export class ElementsToArrayJsNode extends TypedJsNode {
  constructor() {
    super(...arguments);
    this.paramsConfig = ParamsConfig;
  }
  static type() {
    return "elementsToArray";
  }
  initializeNode() {
    super.initializeNode();
    this.io.connection_points.set_expected_input_types_function(this._expectedInputTypes.bind(this));
    this.io.connection_points.set_expected_output_types_function(this._expectedOutputTypes.bind(this));
    this.io.connection_points.set_input_name_function(this._expectedInputName.bind(this));
    this.io.connection_points.set_output_name_function(this._expectedOutputName.bind(this));
  }
  _expectedInputTypes() {
    const firstType = this.io.connection_points.first_input_connection_type();
    const type = firstType != null && ALLOWED_INPUT_TYPES.has(firstType) ? firstType : JsConnectionPointType.FLOAT;
    const currentConnections = this.io.connections.existingInputConnections();
    const expectedCount = currentConnections ? Math.max(currentConnections.length + 1, 2) : 2;
    const expectedInputTypes = [];
    for (let i = 0; i < expectedCount; i++) {
      expectedInputTypes.push(type);
    }
    return expectedInputTypes;
  }
  _expectedInputName(index) {
    return `element${index}`;
  }
  _expectedOutputName(index) {
    const type = this._expectedInputTypes()[0];
    return `${type}[]`;
  }
  _expectedOutputTypes() {
    const firstType = this._expectedInputTypes()[0];
    const outputType = JsConnectionPointTypeToArrayTypeMap[firstType] || JsConnectionPointType.FLOAT_ARRAY;
    return [outputType];
  }
  setLines(shadersCollectionController) {
    const inputValuesCount = this._expectedInputTypes().length - 1;
    const inputArgs = [];
    for (let i = 0; i < inputValuesCount; i++) {
      const element = this.variableForInput(shadersCollectionController, this._expectedInputName(i));
      inputArgs.push(element);
    }
    const inputElements = `[${inputArgs.join(",")}]`;
    const dataType = this._expectedInputTypes()[0];
    const varName = this.jsVarName(this._expectedOutputName(0));
    const options = {
      shadersCollectionController,
      inputElements,
      dataType,
      varName
    };
    const firstType = this._expectedInputTypes()[0];
    switch (firstType) {
      case JsConnectionPointType.BOOLEAN:
      case JsConnectionPointType.FLOAT:
      case JsConnectionPointType.INT:
      case JsConnectionPointType.STRING: {
        return this._setLinesAsPrimitive(options);
      }
      case JsConnectionPointType.COLOR:
      case JsConnectionPointType.MATRIX4:
      case JsConnectionPointType.QUATERNION:
      case JsConnectionPointType.VECTOR2:
      case JsConnectionPointType.VECTOR3:
      case JsConnectionPointType.VECTOR4: {
        return this._setLinesAsVector(options);
      }
      case JsConnectionPointType.INTERSECTION: {
        return this._setLinesAsIntersection(options);
      }
      case JsConnectionPointType.TEXTURE: {
        return this._setLinesAsTexture(options);
      }
    }
  }
  _setLinesAsPrimitive(options) {
    const { shadersCollectionController, varName, dataType, inputElements } = options;
    const tmpVarName = shadersCollectionController.addVariable(
      this,
      createPrimitiveArray(dataType)
    );
    const func = Poly.namedFunctionsRegister.getFunction(
      "elementsToArrayPrimitive",
      this,
      shadersCollectionController
    );
    shadersCollectionController.addBodyOrComputed(this, [
      {
        dataType,
        varName,
        value: func.asString(inputElements, tmpVarName)
      }
    ]);
  }
  _setLinesAsVector(options) {
    const { shadersCollectionController, varName, dataType, inputElements } = options;
    const tmpVarName = shadersCollectionController.addVariable(
      this,
      createVectorArray(dataType)
    );
    const func = Poly.namedFunctionsRegister.getFunction(
      "elementsToArrayPrimitive",
      this,
      shadersCollectionController
    );
    shadersCollectionController.addBodyOrComputed(this, [
      {
        dataType,
        varName,
        value: func.asString(inputElements, tmpVarName)
      }
    ]);
  }
  _setLinesAsIntersection(options) {
    console.warn("not implemented");
  }
  _setLinesAsTexture(options) {
    console.warn("not implemented");
  }
  // public override outputValue(context: JsNodeTriggerContext) {
  // 	const inputsCount = this.io.inputs.namedInputConnectionPoints().length - 1;
  // 	const array = new Array(inputsCount);
  // 	for (let i = 0; i < inputsCount; i++) {
  // 		const inputName = this._expectedInputName(i);
  // 		array[i] = this._inputValue<ArrayabeonnectionPointType>(inputName, context);
  // 	}
  // 	return array;
  // }
}
