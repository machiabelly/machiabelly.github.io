"use strict";
import { TypedEventNode } from "../_Base";
import { NodeParamsConfig, ParamConfig } from "../../utils/params/ParamsConfig";
import { NodeContext } from "../../../poly/NodeContext";
import { CoreGraphNode } from "../../../../core/graph/CoreGraphNode";
export function ColliderParamConfig(Base) {
  return class Mixin extends Base {
    constructor() {
      super(...arguments);
      this.colliderObject = ParamConfig.NODE_PATH("", {
        nodeSelection: {
          context: NodeContext.SOP
        },
        // if the node is dependent,
        // the FirstPersonControls will be re-created when this node changes
        // which we do not want, as it will act like a hard reset
        // when all we want is to update the collider
        dependentOnFoundNode: false,
        callback: (node) => {
          ColliderEventNode.PARAM_CALLBACK_updateCollider(node);
        }
      });
    }
  };
}
class ColliderParamsConfig extends ColliderParamConfig(NodeParamsConfig) {
}
class ColliderEventNode extends TypedEventNode {
  static PARAM_CALLBACK_updateCollider(node) {
  }
}
export class CollisionController {
  constructor(node) {
    this.node = node;
  }
  _colliderNodeGraphNode() {
    return this.__colliderNodeGraphNode = this.__colliderNodeGraphNode || new CoreGraphNode(this.node.scene(), "colliderGraphNode");
  }
  async getCollider() {
    var _a;
    const colliderNode = this.node.pv.colliderObject.nodeWithContext(NodeContext.SOP);
    if (!colliderNode) {
      this.node.states.error.set("collider node not found");
      return;
    }
    if (((_a = this._colliderNode) == null ? void 0 : _a.graphNodeId()) != colliderNode.graphNodeId()) {
      if (this._colliderNode) {
        this._colliderNodeGraphNode().removeGraphInput(this._colliderNode);
      }
      this._colliderNodeGraphNode().addGraphInput(colliderNode);
      this._colliderNodeGraphNode().addPostDirtyHook("onColliderDirty", () => {
        this.updateCollider();
      });
      this._colliderNode = colliderNode;
    }
    const container = await colliderNode.compute();
    const coreGroup = container.coreContent();
    if (!coreGroup) {
      this.node.states.error.set("invalid collider node");
      return;
    }
    const collider = coreGroup.threejsObjects()[0];
    return collider;
  }
  async updateCollider() {
    var _a;
    const collider = await this.getCollider();
    if (!collider) {
      this.node.states.error.set("invalid collider");
      return;
    }
    (_a = this.node.player()) == null ? void 0 : _a.setCollider(collider);
  }
}
