export default '// #version 120 // should be placed at very start of shader\n\n// Cellular noise ("Worley noise") in 2D in GLSL.\n// Copyright (c) Stefan Gustavson 2011-04-19. All rights reserved.\n// This code is released under the conditions of the MIT license.\n// See LICENSE file for details.\n// https://github.com/stegu/webgl-noise\n\n// Modulo 289 without a division (only multiplications)\nvec2 mod289(vec2 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 mod289(vec4 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\n// Modulo 7 without a division\nvec4 mod7(vec4 x) {\n  return x - floor(x * (1.0 / 7.0)) * 7.0;\n}\n\n// Permutation polynomial: (34x^2 + x) mod 289\nvec4 permute(vec4 x) {\n  return mod289((34.0 * x + 1.0) * x);\n}\n\n// Cellular noise, returning F1 and F2 in a vec2.\n// Speeded up by using 2x2 search window instead of 3x3,\n// at the expense of some strong pattern artifacts.\n// F2 is often wrong and has sharp discontinuities.\n// If you need a smooth F2, use the slower 3x3 version.\n// F1 is sometimes wrong, too, but OK for most purposes.\nvec2 cellular2x2(vec2 P) {\n#define K 0.142857142857 // 1/7\n#define K2 0.0714285714285 // K/2\n#define jitter 0.8 // jitter 1.0 makes F1 wrong more often\n	vec2 Pi = mod289(floor(P));\n 	vec2 Pf = fract(P);\n	vec4 Pfx = Pf.x + vec4(-0.5, -1.5, -0.5, -1.5);\n	vec4 Pfy = Pf.y + vec4(-0.5, -0.5, -1.5, -1.5);\n	vec4 p = permute(Pi.x + vec4(0.0, 1.0, 0.0, 1.0));\n	p = permute(p + Pi.y + vec4(0.0, 0.0, 1.0, 1.0));\n	vec4 ox = mod7(p)*K+K2;\n	vec4 oy = mod7(floor(p*K))*K+K2;\n	vec4 dx = Pfx + jitter*ox;\n	vec4 dy = Pfy + jitter*oy;\n	vec4 d = dx * dx + dy * dy; // d11, d12, d21 and d22, squared\n	// Sort out the two smallest distances\n#if 0\n	// Cheat and pick only F1\n	d.xy = min(d.xy, d.zw);\n	d.x = min(d.x, d.y);\n	return vec2(sqrt(d.x)); // F1 duplicated, F2 not computed\n#else\n	// Do it right and find both F1 and F2\n	d.xy = (d.x < d.y) ? d.xy : d.yx; // Swap if smaller\n	d.xz = (d.x < d.z) ? d.xz : d.zx;\n	d.xw = (d.x < d.w) ? d.xw : d.wx;\n	d.y = min(d.y, d.z);\n	d.y = min(d.y, d.w);\n	return sqrt(d.xy);\n#endif\n}\n';
