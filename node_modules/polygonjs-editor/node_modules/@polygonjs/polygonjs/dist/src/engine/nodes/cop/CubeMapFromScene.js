"use strict";
import { TypedCopNode } from "./_Base";
import { NodeContext } from "../../poly/NodeContext";
import { NodeParamsConfig, ParamConfig } from "../utils/params/ParamsConfig";
import { CopType } from "../../poly/registers/nodes/types/Cop";
import { DisplayNodeController } from "../utils/DisplayNodeController";
import { PMREMGenerator, Scene, WebGLRenderer } from "three";
import { CopRendererController } from "./utils/RendererController";
function CubeMapFromSceneCopParamConfig(Base) {
  return class Mixin extends Base {
    constructor() {
      super(...arguments);
      /** @param force Render */
      this.blur = ParamConfig.FLOAT(0, {
        range: [0, 0.1],
        step: 1e-4,
        rangeLocked: [true, false]
      });
      /** @param camera near */
      this.near = ParamConfig.FLOAT(0.1, {
        range: [1e-4, 1],
        step: 1e-4,
        rangeLocked: [true, false]
      });
      /** @param camera far */
      this.far = ParamConfig.FLOAT(100, {
        range: [0, 100],
        rangeLocked: [true, false]
      });
      /** @param force Render */
      this.render = ParamConfig.BUTTON(null, {
        callback: async (node) => {
          await CubeMapFromSceneCopNode.PARAM_CALLBACK_render(node);
        }
      });
    }
  };
}
class CubeMapFromSceneCopParamsConfig extends CubeMapFromSceneCopParamConfig(NodeParamsConfig) {
}
const ParamsConfig = new CubeMapFromSceneCopParamsConfig();
export class CubeMapFromSceneCopNode extends TypedCopNode {
  constructor() {
    super(...arguments);
    this.paramsConfig = ParamsConfig;
    // display_node and children_display controllers
    // private _renderCubeMapBound = this._renderCubeMap.bind(this);
    this._setDirtyBound = this._setDirty.bind(this);
    this.displayNodeController = new DisplayNodeController(this, {
      onDisplayNodeRemove: this._setDirtyBound,
      onDisplayNodeSet: this._setDirtyBound,
      onDisplayNodeUpdate: this._setDirtyBound
    });
    //
    this._childrenControllerContext = NodeContext.SOP;
    this._cookMainWithoutInputsWhenDirtyBound = this._cookMainWithoutInputsWhenDirty.bind(this);
    this._renderScene = new Scene();
  }
  static type() {
    return CopType.CUBE_MAP_FROM_SCENE;
  }
  lastGeneratedRenderTarget() {
    return this._lastGeneratedRenderTarget;
  }
  initializeNode() {
    this.addPostDirtyHook("_cook_main_without_inputs_when_dirty", () => {
      setTimeout(this._cookMainWithoutInputsWhenDirtyBound, 0);
    });
  }
  dispose() {
    var _a;
    (_a = this._pmremGenerator) == null ? void 0 : _a.dispose();
    super.dispose();
  }
  createNode(node_class, options) {
    return super.createNode(node_class, options);
  }
  children() {
    return super.children();
  }
  nodesByType(type) {
    return super.nodesByType(type);
  }
  childrenAllowed() {
    return true;
  }
  _setDirty() {
    this.setDirty();
  }
  async _cookMainWithoutInputsWhenDirty() {
    await this.cookController.cookMainWithoutInputs();
  }
  async cook() {
    await this._updateRenderScene();
    const texture = await this._renderCubeMap();
    if (!texture) {
      this.cookController.endCook();
    }
  }
  async _updateRenderScene() {
    if (!this.scene().loadingController.autoUpdating()) {
      return;
    }
    const displayNode = this.displayNodeController.displayNode();
    if (!displayNode) {
      return;
    }
    if (displayNode.context() != NodeContext.SOP) {
      return;
    }
    const sopNode = displayNode;
    const container = await sopNode.compute();
    if (!container) {
      return;
    }
    const coreGroup = container.coreContent();
    if (!coreGroup) {
      return;
    }
    const currentChildren = [...this._renderScene.children];
    for (const child of currentChildren) {
      this._renderScene.remove(child);
    }
    const objects = coreGroup.threejsObjects();
    for (const object of objects) {
      this._renderScene.add(object);
    }
  }
  async _renderCubeMap() {
    if (!this.scene().loadingController.autoUpdating()) {
      return;
    }
    this._rendererController = this._rendererController || new CopRendererController(this);
    const renderer = await this._rendererController.waitForRenderer();
    if (!renderer) {
      this.states.error.set("no renderer found to convert the texture to an env map");
      return;
    }
    if (!(renderer instanceof WebGLRenderer)) {
      this.states.error.set("found renderer is not a WebGLRenderer");
      return;
    }
    this._pmremGenerator = this._pmremGenerator || new PMREMGenerator(renderer);
    this._lastGeneratedRenderTarget = this._pmremGenerator.fromScene(
      this._renderScene,
      this.pv.blur,
      this.pv.near,
      this.pv.far
    );
    this.setTexture(this._lastGeneratedRenderTarget.texture);
    return this._lastGeneratedRenderTarget.texture;
  }
  /*
   *
   * CALLBACK
   *
   */
  static async PARAM_CALLBACK_render(node) {
    await node._renderCubeMap();
  }
}
