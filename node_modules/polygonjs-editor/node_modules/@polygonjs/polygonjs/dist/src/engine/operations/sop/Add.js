"use strict";
import { BaseSopOperation } from "./_Base";
import { BufferGeometry, Vector3, BufferAttribute, Float32BufferAttribute } from "three";
import { ObjectType } from "../../../core/geometry/Constant";
import { isBooleanTrue } from "../../../core/BooleanValue";
const _position = new Vector3();
const _points = [];
export class AddSopOperation extends BaseSopOperation {
  static type() {
    return "add";
  }
  cook(input_contents, params) {
    const objects = [];
    this._createPoint(objects, params);
    this._createPolygon(input_contents[0], objects, params);
    if (this._node) {
      let i = 0;
      for (let object of objects) {
        object.name = `${this._node.name()}-${i}`;
        i++;
      }
    }
    return this.createCoreGroupFromObjects(objects);
  }
  _createPoint(objects, params) {
    if (!isBooleanTrue(params.createPoint)) {
      return;
    }
    const geometry = new BufferGeometry();
    const positions = [];
    for (let i = 0; i < params.pointsCount; i++) {
      params.position.toArray(positions, i * 3);
    }
    geometry.setAttribute("position", new BufferAttribute(new Float32Array(positions), 3));
    const object = this.createObject(geometry, ObjectType.POINTS);
    if (objects) {
      objects.push(object);
    }
  }
  _createPolygon(coreGroup, objects, params) {
    if (!isBooleanTrue(params.connectInputPoints)) {
      return;
    }
    coreGroup.points(_points);
    if (_points.length > 0) {
      this._create_polygon_open(coreGroup, objects, params);
    }
  }
  // private _create_polygon_closed(core_group: CoreGroup, objects: Object3D[]) {
  // 	const points = core_group.points();
  // 	const geometry = CoreGeometryUtilShape.geometryFromPoints(points.map((p) => p.position()));
  // 	const object = this.createObject(geometry, ObjectType.MESH);
  // 	objects.push(object);
  // }
  _create_polygon_open(coreGroup, objects, params) {
    coreGroup.points(_points);
    let positions = [];
    const indices = [];
    let point;
    const pointsCount = _points.length;
    for (let i = 0; i < pointsCount; i++) {
      point = _points[i];
      point.position(_position).toArray(positions, i * 3);
      if (i > 0) {
        indices.push(i - 1);
        indices.push(i);
      }
    }
    if (pointsCount > 2 && params.connectToLastPoint) {
      _points[0].position(_position).toArray(positions, positions.length);
      const last_index = indices[indices.length - 1];
      indices.push(last_index);
      indices.push(0);
    }
    const geometry = new BufferGeometry();
    geometry.setAttribute("position", new Float32BufferAttribute(positions, 3));
    geometry.setIndex(indices);
    const object = this.createObject(geometry, ObjectType.LINE_SEGMENTS);
    objects.push(object);
  }
}
AddSopOperation.DEFAULT_PARAMS = {
  createPoint: true,
  pointsCount: 1,
  position: new Vector3(0, 0, 0),
  connectInputPoints: false,
  connectToLastPoint: false
};
