"use strict";
import { CSGSopNode } from "./_BaseCSG";
import { NodeParamsConfig, ParamConfig } from "../utils/params/ParamsConfig";
import { SopType } from "../../poly/registers/nodes/types/Sop";
import { csgIsPath2, csgIsGeom2 } from "../../../core/geometry/modules/csg/CsgCoreType";
import { extrusions } from "@jscad/modeling";
const { extrudeLinear } = extrusions;
class CSGExtrudeLinearSopParamsConfig extends NodeParamsConfig {
  constructor() {
    super(...arguments);
    /** @param height */
    this.height = ParamConfig.FLOAT(0.5, {
      range: [1e-8, 1],
      rangeLocked: [true, false]
    });
    /** @param twistAngle */
    this.twistAngle = ParamConfig.FLOAT(0, {
      range: [0, 2 * Math.PI],
      rangeLocked: [true, false]
    });
    /** @param twistSteps */
    this.twistSteps = ParamConfig.INTEGER(1, {
      range: [0, 10],
      rangeLocked: [true, false]
    });
  }
}
const ParamsConfig = new CSGExtrudeLinearSopParamsConfig();
export class CSGExtrudeLinearSopNode extends CSGSopNode {
  constructor() {
    super(...arguments);
    this.paramsConfig = ParamsConfig;
  }
  static type() {
    return SopType.CSG_EXTRUDE_LINEAR;
  }
  initializeNode() {
    this.io.inputs.setCount(1);
  }
  cook(inputCoreGroups) {
    const inputObjects = inputCoreGroups[0].csgObjects();
    if (inputObjects && inputObjects.length != 0) {
      const options = {
        height: this.pv.height,
        twistAngle: this.pv.twistAngle,
        twistSteps: this.pv.twistSteps
      };
      const newGeometries = [];
      for (const inputObject of inputObjects) {
        const inputGeometry = inputObject.csgGeometry();
        if (csgIsPath2(inputGeometry) || csgIsGeom2(inputGeometry)) {
          newGeometries.push(extrudeLinear(options, inputGeometry));
        } else {
          newGeometries.push(inputGeometry);
        }
      }
      this.setCSGGeometries(newGeometries);
    } else {
      this.setCSGObjects([]);
    }
  }
}
