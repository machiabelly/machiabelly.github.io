"use strict";
import { COMPONENTS_BY_GL_TYPE, ThreeToGl } from "../../../core/ThreeToGl";
import { GlConnectionPointType } from "../utils/io/connections/Gl";
import { FunctionGLDefinition } from "./utils/GLDefinition";
const IS_INF_DEFINE = "#define isInf(x) ( (x) == (x)+1. )";
const IS_NAN_DEFINE = "#define isNaN(x) ( (x) != (x)    )";
const DEFINES = [IS_INF_DEFINE, IS_NAN_DEFINE].join("\n");
const ALLOWED_INPUTS = [
  GlConnectionPointType.FLOAT,
  GlConnectionPointType.VEC2,
  GlConnectionPointType.VEC3,
  GlConnectionPointType.VEC4
];
import { NodeParamsConfig, ParamConfig } from "../utils/params/ParamsConfig";
import { TypedGlNode } from "./_Base";
import { isBooleanTrue } from "../../../core/Type";
class IsInfOrNanGlParamsConfig extends NodeParamsConfig {
  constructor() {
    super(...arguments);
    this.testIsInf = ParamConfig.BOOLEAN(1);
    this.testIsNan = ParamConfig.BOOLEAN(1);
  }
}
const ParamsConfig = new IsInfOrNanGlParamsConfig();
const _IsInfOrNanGlNode = class extends TypedGlNode {
  constructor() {
    super(...arguments);
    this.paramsConfig = ParamsConfig;
  }
  static type() {
    return "isInfOrNan";
  }
  initializeNode() {
    super.initializeNode();
    this.io.connection_points.set_input_name_function(() => _IsInfOrNanGlNode.INPUT);
    this.io.connection_points.set_output_name_function(() => _IsInfOrNanGlNode.OUTPUT);
    this.io.connection_points.set_expected_input_types_function(this._expected_input_types.bind(this));
    this.io.connection_points.set_expected_output_types_function(() => [GlConnectionPointType.BOOL]);
  }
  _expected_input_types() {
    const type = this.io.connection_points.first_input_connection_type() || GlConnectionPointType.FLOAT;
    if (ALLOWED_INPUTS.includes(type)) {
      return [type];
    } else {
      return [GlConnectionPointType.FLOAT];
    }
  }
  setLines(shadersCollectionController) {
    const glOutType = GlConnectionPointType.BOOL;
    const out = this.glVarName(this.io.connection_points.output_name(0));
    const bodyLine = `${glOutType} ${out} = ${this._functionCalls()}`;
    shadersCollectionController.addBodyLines(this, [bodyLine]);
    shadersCollectionController.addDefinitions(this, [new FunctionGLDefinition(this, DEFINES)]);
  }
  _functionCalls() {
    const inValue = ThreeToGl.any(this.variableForInput(_IsInfOrNanGlNode.INPUT));
    const connectionPoints = this.io.inputs.namedInputConnectionPoints();
    if (!connectionPoints) {
      return;
    }
    const glInType = connectionPoints[0].type();
    const testFunction = (inputVal) => {
      const functions = [];
      if (isBooleanTrue(this.pv.testIsInf)) {
        functions.push(`isInf(${inputVal})`);
      }
      if (isBooleanTrue(this.pv.testIsNan)) {
        functions.push(`isNaN(${inputVal})`);
      }
      if (functions.length > 0) {
        return functions.join(" || ");
      } else {
        return true;
      }
    };
    const testFunctionsForComponents = (components2) => {
      return components2.map((c) => testFunction(`${inValue}.${c}`)).join(" || ");
    };
    const components = COMPONENTS_BY_GL_TYPE[glInType];
    if (components) {
      return testFunctionsForComponents(components);
    } else {
      return testFunction(inValue);
    }
  }
};
export let IsInfOrNanGlNode = _IsInfOrNanGlNode;
IsInfOrNanGlNode.OUTPUT = "out";
IsInfOrNanGlNode.INPUT = "in";
