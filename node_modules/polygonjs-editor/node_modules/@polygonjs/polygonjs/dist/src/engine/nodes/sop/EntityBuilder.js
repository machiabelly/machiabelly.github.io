"use strict";
import { Object3D, Vector3 } from "three";
import { SopType } from "../../poly/registers/nodes/types/Sop";
import { EntityBuilderPersistedConfig } from "../js/code/assemblers/entityBuilder/EntityBuilderPersistedConfig";
import { AssemblerName } from "../../poly/registers/assemblers/_BaseRegister";
import { BaseEntityBuilderSopNode, BaseEntityBuilderSopParamsConfig, AVAILABLE_ENTITIES } from "./_BaseEntityBuilder";
import { Attribute } from "../../../core/geometry/Attribute";
import { ParamConfig } from "../utils/params/ParamsConfig";
import { isBooleanTrue } from "../../../core/Type";
import { corePointClassFactory, corePrimitiveClassFactory } from "../../../core/geometry/CoreObjectFactory";
import { AttribClass } from "../../../core/geometry/Constant";
const _tmpObject = new Object3D();
class EntityBuilderSopParamsConfig extends BaseEntityBuilderSopParamsConfig {
  constructor() {
    super(...arguments);
    /** @param updateNormals */
    this.updateNormals = ParamConfig.BOOLEAN(1, {
      visibleIf: {
        entity: AVAILABLE_ENTITIES.indexOf(AttribClass.POINT)
      }
    });
  }
}
const ParamsConfig = new EntityBuilderSopParamsConfig();
export class EntityBuilderSopNode extends BaseEntityBuilderSopNode {
  constructor() {
    super(...arguments);
    this.paramsConfig = ParamsConfig;
    this.persisted_config = new EntityBuilderPersistedConfig(this);
    this._entityContainer = {
      object: _tmpObject,
      position: new Vector3(),
      normal: new Vector3(),
      index: -1,
      objnum: -1,
      normalsUpdated: false
    };
  }
  static type() {
    return SopType.ENTITY_BUILDER;
  }
  usedAssembler() {
    return AssemblerName.JS_ENTITY_BUILDER;
  }
  _processObject(object, objnum, evaluator) {
    this._entityContainer.object = object;
    this._entityContainer.objnum = objnum;
    this._entityContainer.normalsUpdated = false;
    if (this.entity() == AttribClass.PRIMITIVE) {
      this._entityContainer.primitiveGraph = corePrimitiveClassFactory(object).graph(object);
    } else {
      this._entityContainer.primitiveGraph = void 0;
    }
    const readAttributeOptions = this._checkRequiredReadAttributes(object);
    const writeAttributeOptions = this._checkRequiredWriteAttributes(object);
    const readAttribNames = readAttributeOptions ? readAttributeOptions.attribNames : [];
    const readAttributeByName = readAttributeOptions ? readAttributeOptions.attributeByName : /* @__PURE__ */ new Map();
    const attribTypeByName = readAttributeOptions ? readAttributeOptions.attribTypeByName : /* @__PURE__ */ new Map();
    const writeAttribNames = writeAttributeOptions ? writeAttributeOptions.attribNames : [];
    const writeAttributeByName = writeAttributeOptions ? writeAttributeOptions.attributeByName : /* @__PURE__ */ new Map();
    this._resetRequiredAttributes();
    const entitiesCount = this.entitiesCount(object);
    const entityClass = this.entityClass(object);
    const positionAttrib = entityClass.attribute(object, Attribute.POSITION);
    const normalAttrib = entityClass.attribute(object, Attribute.NORMAL);
    const hasPosition = positionAttrib != null;
    const hasNormal = normalAttrib != null;
    if (!hasPosition) {
      this._entityContainer.position.set(0, 0, 0);
    }
    if (!hasNormal) {
      this._entityContainer.normal.set(0, 1, 0);
    }
    for (let index = 0; index < entitiesCount; index++) {
      this._entityContainer.index = index;
      if (hasPosition) {
        entityClass.attribValue(object, index, Attribute.POSITION, this._entityContainer.position);
      }
      if (hasNormal) {
        entityClass.attribValue(object, index, Attribute.NORMAL, this._entityContainer.normal);
      }
      this._readRequiredAttributes(index, readAttribNames, readAttributeByName, attribTypeByName);
      evaluator();
      this._writeRequiredAttributes(index, writeAttribNames, writeAttributeByName);
    }
    if (isBooleanTrue(this.pv.updateNormals) && !this._entityContainer.normalsUpdated) {
      corePointClassFactory(object).computeNormals(object);
    }
  }
}
