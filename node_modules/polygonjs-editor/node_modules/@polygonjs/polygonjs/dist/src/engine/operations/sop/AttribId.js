"use strict";
import { TypeAssert } from "./../../poly/Assert";
import { AttribClass, ATTRIBUTE_CLASSES_WITHOUT_CORE_GROUP } from "./../../../core/geometry/Constant";
import { BaseSopOperation } from "./_Base";
import { BufferAttribute } from "three";
import { isBooleanTrue } from "../../../core/Type";
import {
  corePointClassFactory,
  corePrimitiveClassFactory,
  coreVertexClassFactory
} from "../../../core/geometry/CoreObjectFactory";
import { primitivesFromObject } from "../../../core/geometry/entities/primitive/CorePrimitiveUtils";
import { pointsFromObject } from "../../../core/geometry/entities/point/CorePointUtils";
import { verticesFromObject } from "../../../core/geometry/entities/vertex/CoreVertexUtils";
const _points = [];
const _vertices = [];
const _primitives = [];
export class AttribIdSopOperation extends BaseSopOperation {
  static type() {
    return "attribId";
  }
  cook(inputCoreGroups, params) {
    const coreGroup = inputCoreGroups[0];
    const attribClass = ATTRIBUTE_CLASSES_WITHOUT_CORE_GROUP[params.class];
    this._addAttribute(attribClass, coreGroup, params);
    return coreGroup;
  }
  async _addAttribute(attribClass, coreGroup, params) {
    const objects = coreGroup.allObjects();
    switch (attribClass) {
      case AttribClass.POINT:
        return this._addPointAttributesToObjects(objects, params);
      case AttribClass.VERTEX: {
        this._addVertexAttributesToObjects(objects, params);
        return;
      }
      case AttribClass.PRIMITIVE: {
        this._addPrimitiveAttributesToObjects(objects, params);
        return;
      }
      case AttribClass.OBJECT:
        return this._addAttributesToEntities(coreGroup.allCoreObjects(), params);
      case AttribClass.CORE_GROUP:
        return;
    }
    TypeAssert.unreachable(attribClass);
  }
  // private _addObjectAttributes(coreObjects: BaseCoreObject<CoreObjectType>[], params: AttribIdSopParams) {
  // 	const objectsCount = coreObjects.length;
  // 	if (objectsCount > 1) {
  // 		let i = 0;
  // 		for (const coreObject of coreObjects) {
  // 			if (isBooleanTrue(params.id)) {
  // 				coreObject.addAttribute(params.idName, i);
  // 			}
  // 			if (isBooleanTrue(params.idn)) {
  // 				coreObject.addAttribute(params.idnName, i / (objectsCount - 1));
  // 			}
  // 			i++;
  // 		}
  // 	} else {
  // 		coreObjects[0].addAttribute(params.idName, 0);
  // 		coreObjects[0].addAttribute(params.idnName, 0);
  // 	}
  // }
  _addPointAttributesToObjects(objects, params) {
    for (const object of objects) {
      this._addPointAttributesToObject(object, params);
    }
  }
  _addVertexAttributesToObjects(objects, params) {
    for (const object of objects) {
      this._addVertexAttributes(object, params);
    }
  }
  _addPrimitiveAttributesToObjects(objects, params) {
    for (const object of objects) {
      this._addPrimitiveAttributes(object, params);
    }
  }
  _addPointAttributesToObject(object, params) {
    const pointClass = corePointClassFactory(object);
    pointsFromObject(object, _points);
    const entitiesCount = _points.length;
    if (isBooleanTrue(params.id)) {
      const idValues = new Array(entitiesCount);
      for (let i = 0; i < entitiesCount; i++) {
        idValues[i] = i;
      }
      const idArray = new Float32Array(idValues);
      const attrib = new BufferAttribute(idArray, 1);
      pointClass.addAttribute(object, params.idName, attrib);
    }
    if (isBooleanTrue(params.idn)) {
      const idnValues = new Array(entitiesCount);
      const pointsCountMinus1 = entitiesCount - 1;
      if (pointsCountMinus1 == 0) {
        for (let i = 0; i < entitiesCount; i++) {
          idnValues[i] = 0;
        }
      } else {
        for (let i = 0; i < entitiesCount; i++) {
          idnValues[i] = i / (entitiesCount - 1);
        }
      }
      const idnArray = new Float32Array(idnValues);
      const attrib = new BufferAttribute(idnArray, 1);
      pointClass.addAttribute(object, params.idnName, attrib);
    }
  }
  _addVertexAttributes(object, params) {
    const vertexClass = coreVertexClassFactory(object);
    verticesFromObject(object, _vertices);
    if (isBooleanTrue(params.id)) {
      const attribute = {
        isString: false,
        array: new Array(_vertices.length),
        itemSize: 1
      };
      vertexClass.addAttribute(object, params.idName, attribute);
    }
    if (isBooleanTrue(params.idn)) {
      const attribute = {
        isString: false,
        array: new Array(_vertices.length),
        itemSize: 1
      };
      vertexClass.addAttribute(object, params.idnName, attribute);
    }
    this._addAttributesToEntities(_vertices, params);
  }
  _addPrimitiveAttributes(object, params) {
    const primitiveClass = corePrimitiveClassFactory(object);
    primitivesFromObject(object, _primitives);
    if (isBooleanTrue(params.id)) {
      const attribute = {
        isString: false,
        array: new Array(_primitives.length),
        itemSize: 1
      };
      primitiveClass.addAttribute(object, params.idName, attribute);
    }
    if (isBooleanTrue(params.idn)) {
      const attribute = {
        isString: false,
        array: new Array(_primitives.length),
        itemSize: 1
      };
      primitiveClass.addAttribute(object, params.idnName, attribute);
    }
    this._addAttributesToEntities(_primitives, params);
  }
  _addAttributesToEntities(entities, params) {
    const entitiesCount = entities.length;
    if (isBooleanTrue(params.id)) {
      let i = 0;
      for (const entity of entities) {
        entity.setAttribValue(params.idName, i);
        i++;
      }
    }
    if (isBooleanTrue(params.idn)) {
      const pointsCountMinus1 = entitiesCount - 1;
      if (pointsCountMinus1 == 0) {
        let i = 0;
        for (const entity of entities) {
          entity.setAttribValue(params.idnName, 0);
          i++;
        }
      } else {
        let i = 0;
        for (const entity of entities) {
          entity.setAttribValue(params.idnName, i / (entitiesCount - 1));
          i++;
        }
      }
    }
  }
}
AttribIdSopOperation.DEFAULT_PARAMS = {
  class: ATTRIBUTE_CLASSES_WITHOUT_CORE_GROUP.indexOf(AttribClass.POINT),
  id: true,
  idName: "id",
  idn: true,
  idnName: "idn"
};
