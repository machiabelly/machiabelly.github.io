"use strict";
import { TypedEventNode } from "./_Base";
import { EventConnectionPoint, EventConnectionPointType } from "../utils/io/connections/Event";
import { NodeParamsConfig, ParamConfig } from "../utils/params/ParamsConfig";
import { isBooleanTrue } from "../../../core/BooleanValue";
class BlockParamsConfig extends NodeParamsConfig {
  constructor() {
    super(...arguments);
    /** @param toggle on to block incoming events */
    this.blocking = ParamConfig.BOOLEAN(1);
  }
}
const ParamsConfig = new BlockParamsConfig();
const _BlockEventNode = class extends TypedEventNode {
  constructor() {
    super(...arguments);
    this.paramsConfig = ParamsConfig;
  }
  static type() {
    return "block";
  }
  initializeNode() {
    this.io.inputs.setNamedInputConnectionPoints([
      new EventConnectionPoint("in", EventConnectionPointType.BASE, this._process_incoming_event.bind(this))
    ]);
    this.io.outputs.setNamedOutputConnectionPoints([
      new EventConnectionPoint(_BlockEventNode.OUTPUT, EventConnectionPointType.BASE)
    ]);
  }
  trigger_output(context) {
    this.dispatchEventToOutput(_BlockEventNode.OUTPUT, context);
  }
  _process_incoming_event(context) {
    if (!isBooleanTrue(this.pv.blocking)) {
      this.trigger_output(context);
    }
  }
};
export let BlockEventNode = _BlockEventNode;
BlockEventNode.OUTPUT = "output";
