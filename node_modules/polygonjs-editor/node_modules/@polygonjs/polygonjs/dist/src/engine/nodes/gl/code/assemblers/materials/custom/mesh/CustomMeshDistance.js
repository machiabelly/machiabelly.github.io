"use strict";
import { ShaderLib } from "three";
import { ShaderAssemblerMaterial } from "../../_BaseMaterial";
import { ShaderName } from "../../../../../../utils/shaders/ShaderName";
import TemplateFragment from "../../../../templates/custom/mesh/CustomMeshDistance.frag.glsl";
import { MeshDistanceMaterial } from "three";
import { includeSSSDeclarations } from "../../common/SSS";
import { INSERT_DEFINE_AFTER_MAPF_FOR_MESH } from "../../_BaseMesh";
const INSERT_BODY_AFTER_MAP = /* @__PURE__ */ new Map([
  [ShaderName.VERTEX, "#include <begin_vertex>"],
  [ShaderName.FRAGMENT, "#include <alphamap_fragment>"]
]);
export class ShaderAssemblerCustomMeshDistance extends ShaderAssemblerMaterial {
  constructor(_gl_parent_node) {
    super(_gl_parent_node);
    this._gl_parent_node = _gl_parent_node;
    this._addFilterFragmentShaderCallback("MeshStandardBuilderMatNode", includeSSSDeclarations);
  }
  templateShader() {
    const template = ShaderLib.distanceRGBA;
    return {
      vertexShader: template.vertexShader,
      fragmentShader: [TemplateFragment, template.fragmentShader][0],
      uniforms: template.uniforms
    };
  }
  insertDefineAfter(shaderName) {
    return INSERT_DEFINE_AFTER_MAPF_FOR_MESH.get(shaderName);
  }
  insertBodyAfter(shaderName) {
    return INSERT_BODY_AFTER_MAP.get(shaderName);
  }
  createMaterial() {
    return new MeshDistanceMaterial();
  }
}
export class ShaderAssemblerCustomMeshDistanceForRender extends ShaderAssemblerCustomMeshDistance {
}
