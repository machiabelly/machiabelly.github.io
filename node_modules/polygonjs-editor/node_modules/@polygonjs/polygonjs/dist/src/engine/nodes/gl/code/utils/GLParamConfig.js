"use strict";
import { Color, Vector2, Vector3, Vector4 } from "three";
import { ParamType } from "../../../../poly/ParamType";
import { TypeAssert } from "../../../../poly/Assert";
import { BaseParamConfig } from "../../../utils/code/configs/BaseParamConfig";
import { NodeContext } from "../../../../poly/NodeContext";
export class GlParamConfig extends BaseParamConfig {
  constructor(_type, _name, _defaultValue, _uniformName) {
    super(_type, _name, _defaultValue);
    this._uniformName = _uniformName;
  }
  toJSON() {
    return {
      type: this._type,
      name: this._name,
      defaultValue: this._defaultValue,
      uniformName: this._uniformName
    };
  }
  static fromJSON(json) {
    return new GlParamConfig(json.type, json.name, json.defaultValue, json.uniformName);
  }
  uniformName() {
    return this._uniformName;
  }
  uniform() {
    return this._uniform = this._uniform || this._createUniform();
  }
  _createUniform() {
    return GlParamConfig.uniformByType(this._type);
  }
  _callback(node, param) {
    GlParamConfig.callback(param, this.uniform());
  }
  static callback(param, uniform) {
    switch (param.type()) {
      case ParamType.RAMP:
        uniform.value = param.rampTexture();
        return;
      case ParamType.NODE_PATH:
        GlParamConfig.setUniformValueFromTextureFromNodePathParam(param, uniform);
        return;
      default:
        uniform.value = param.value;
    }
  }
  // TODO: refactor that to use the default values map?
  static uniformByType(type) {
    switch (type) {
      case ParamType.BOOLEAN:
        return { value: 0 };
      case ParamType.BUTTON:
        return { value: 0 };
      case ParamType.COLOR:
        return { value: new Color(0, 0, 0) };
      case ParamType.FLOAT:
        return { value: 0 };
      case ParamType.FOLDER:
        return { value: 0 };
      case ParamType.INTEGER:
        return { value: 0 };
      case ParamType.NODE_PATH:
        return { value: 0 };
      case ParamType.PARAM_PATH:
        return { value: 0 };
      case ParamType.RAMP:
        return { value: null };
      case ParamType.STRING:
        return { value: null };
      case ParamType.VECTOR2:
        return { value: new Vector2(0, 0) };
      case ParamType.VECTOR3:
        return { value: new Vector3(0, 0, 0) };
      case ParamType.VECTOR4:
        return { value: new Vector4(0, 0, 0, 0) };
    }
    TypeAssert.unreachable(type);
  }
  // private static set_uniform_value_from_texture(param: OperatorPathParam, uniform: IUniform) {
  // 	const found_node = param.found_node();
  // 	if (found_node) {
  // 		if (found_node.isDirty()) {
  // 			found_node.compute().then((container) => {
  // 				const texture = container.texture();
  // 				uniform.value = texture;
  // 			});
  // 		} else {
  // 			const container = found_node.containerController.container();
  // 			const texture = container.texture();
  // 			uniform.value = texture;
  // 		}
  // 	} else {
  // 		uniform.value = null;
  // 	}
  // }
  static async setUniformValueFromTextureFromNodePathParam(param, uniform) {
    if (param.isDirty()) {
      await param.compute();
    }
    const node = param.value.nodeWithContext(NodeContext.COP);
    if (node) {
      if (node.isDirty()) {
        await node.compute();
      }
      const container = node.containerController.container();
      const texture = container.texture();
      uniform.value = texture;
    } else {
      uniform.value = null;
    }
  }
}
