"use strict";
import { TypedSopNode } from "./_Base";
import { DEFAULT_PARAMS } from "../../operations/sop/Reflector";
import { Reflector } from "../../../modules/core/objects/Reflector";
import { NodeParamsConfig, ParamConfig } from "../utils/params/ParamsConfig";
import { SopType } from "../../poly/registers/nodes/types/Sop";
import { InputCloneMode } from "../../poly/InputCloneMode";
import { Poly } from "../../Poly";
import { Vector3 } from "three";
import { replaceChild } from "../../poly/PolyOnObjectsAddRemoveHooksController";
const DEFAULT = DEFAULT_PARAMS;
const _v3 = new Vector3();
class ReflectorSopParamsConfig extends NodeParamsConfig {
  constructor() {
    super(...arguments);
    /** @param direction the objects reflects */
    this.direction = ParamConfig.VECTOR3(DEFAULT.direction.toArray());
    /** @param direction offset */
    this.directionOffset = ParamConfig.FLOAT(DEFAULT.directionOffset, {
      range: [-1, 1],
      rangeLocked: [false, false]
    });
    /** @param when active is off, the mirror is not rendered */
    this.active = ParamConfig.BOOLEAN(DEFAULT.active);
    /** @param bias to ensure the mirror does not reflect itself */
    this.clipBias = ParamConfig.FLOAT(DEFAULT.clipBias);
    /** @param color */
    this.color = ParamConfig.COLOR(DEFAULT.color.toArray());
    /** @param useVertexColor */
    this.useVertexColor = ParamConfig.BOOLEAN(DEFAULT.useVertexColor);
    /** @param reflectionBlend */
    this.reflectionBlend = ParamConfig.FLOAT(DEFAULT.reflectionBlend);
    /** @param pixelRatio */
    /** @param opacity */
    this.opacity = ParamConfig.FLOAT(DEFAULT.opacity);
    this.pixelRatio = ParamConfig.INTEGER(DEFAULT.pixelRatio, {
      range: [1, 4],
      rangeLocked: [true, false]
    });
    /** @param multisamples */
    this.multisamples = ParamConfig.INTEGER(DEFAULT.multisamples, {
      range: [0, 4],
      rangeLocked: [true, false]
    });
    /** @param toggle to activate blur */
    this.tblur = ParamConfig.BOOLEAN(DEFAULT.tblur);
    /** @param blur amount */
    this.blur = ParamConfig.FLOAT(DEFAULT.blur, {
      visibleIf: { tblur: 1 }
    });
    /** @param vertical blur multiplier */
    this.verticalBlurMult = ParamConfig.FLOAT(DEFAULT.verticalBlurMult, {
      visibleIf: { tblur: 1 }
    });
    /** @param toggle to activate a second blur, which can be useful to reduce artefacts */
    this.tblur2 = ParamConfig.BOOLEAN(DEFAULT.tblur2, {
      visibleIf: { tblur: 1 }
    });
    /** @param blur2 amount */
    this.blur2 = ParamConfig.FLOAT(DEFAULT.blur2, {
      visibleIf: { tblur: 1, tblur2: 1 }
    });
    /** @param vertical blur2 multiplier */
    this.verticalBlur2Mult = ParamConfig.FLOAT(DEFAULT.verticalBlur2Mult, {
      visibleIf: { tblur: 1, tblur2: 1 }
    });
  }
}
const ParamsConfig = new ReflectorSopParamsConfig();
export class ReflectorSopNode extends TypedSopNode {
  constructor() {
    super(...arguments);
    this.paramsConfig = ParamsConfig;
  }
  static type() {
    return SopType.REFLECTOR;
  }
  initializeNode() {
    this.io.inputs.setCount(1);
    this.io.inputs.initInputsClonedState(InputCloneMode.FROM_NODE);
  }
  cook(inputCoreGroups) {
    const coreGroup = inputCoreGroups[0];
    const objects = coreGroup.threejsObjectsWithGeo();
    for (const object of objects) {
      Poly.onObjectsAddRemoveHooks.assignOnAddHookHandler(object, this);
    }
    this.setCoreGroup(coreGroup);
  }
  updateObjectOnAdd(object, parent) {
    const _geometry = object.geometry;
    if (!_geometry) {
      return;
    }
    const clonedGeometry = _geometry.clone();
    const renderer = this.scene().renderersRegister.lastRegisteredRenderer();
    _v3.copy(this.pv.direction).normalize().multiplyScalar(this.pv.directionOffset);
    clonedGeometry.translate(-_v3.x, -_v3.y, -_v3.z);
    Reflector.rotateGeometry(clonedGeometry, this.pv.direction);
    const reflector = new Reflector(clonedGeometry, {
      clipBias: this.pv.clipBias,
      renderer,
      scene: this.scene().threejsScene(),
      pixelRatio: this.pv.pixelRatio,
      multisamples: this.pv.multisamples,
      color: this.pv.color,
      opacity: this.pv.opacity,
      useVertexColor: this.pv.useVertexColor,
      reflectionBlend: this.pv.reflectionBlend,
      active: this.pv.active,
      tblur: this.pv.tblur,
      blur: this.pv.blur,
      verticalBlurMult: this.pv.verticalBlurMult,
      tblur2: this.pv.tblur2,
      blur2: this.pv.blur2,
      verticalBlur2Mult: this.pv.verticalBlur2Mult
    });
    reflector.matrixAutoUpdate = false;
    object.matrix.decompose(object.position, object.quaternion, object.scale);
    _v3.add(object.position);
    reflector.position.copy(_v3);
    reflector.rotation.copy(object.rotation);
    reflector.scale.copy(object.scale);
    reflector.updateMatrix();
    Reflector.compensateGeometryRotation(reflector, this.pv.direction);
    replaceChild(parent, object, reflector);
  }
}
