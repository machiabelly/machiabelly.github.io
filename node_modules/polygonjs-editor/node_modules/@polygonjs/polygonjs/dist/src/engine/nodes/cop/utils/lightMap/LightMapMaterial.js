"use strict";
import { MeshPhongMaterial } from "three";
export const DEFAULT_UV_LIGHT_MAP_ATTRIB_NAME = "uvLightMap";
export function setLightMapMaterial(mat, options) {
  mat.uniforms.previousLightMap.value = options.lightMap.texture;
}
export function createLightMapMaterial() {
  const mat = new MeshPhongMaterial();
  mat.uniforms = {
    previousLightMap: { value: null },
    // iterationBlend: {value: DEFAULT_ITERATION_BLEND},
    lightMapMult: { value: 1 }
    // flipped: {value: false},
  };
  mat.name = "lightMapMaterial";
  mat.onBeforeCompile = (shader) => {
    shader.vertexShader = `#define USE_LIGHTMAP
#define LIGHTMAP_UV ${DEFAULT_UV_LIGHT_MAP_ATTRIB_NAME}
attribute vec2 LIGHTMAP_UV;
varying vec2 vUvLightMap;
// varying float vUvLightMapFlipped;
${shader.vertexShader.slice(0, -2)}
	vUvLightMap = LIGHTMAP_UV;
	gl_Position = vec4((LIGHTMAP_UV - 0.5) * 2.0, 1.0, 1.0);
}`;
    const bodyStart = shader.fragmentShader.indexOf("void main() {");
    shader.fragmentShader = `#define USE_LIGHTMAP
varying vec2 vUvLightMap;
// varying float vUvLightMapFlipped;
${shader.fragmentShader.slice(0, bodyStart)}
uniform sampler2D previousLightMap;
// uniform float iterationBlend;
uniform float lightMapMult;
// uniform bool flipped;
${shader.fragmentShader.slice(bodyStart - 1, -2)}
	vec3 texelOld = texture2D(previousLightMap, vUvLightMap).rgb;
	// gl_FragColor.rgb = gl_FragColor.rgb + texelOld / totalIterationsCount;
	// gl_FragColor.a = flipped ? vUvLightMapFlipped : 1.-vUvLightMapFlipped;
	gl_FragColor.rgb = texelOld + gl_FragColor.rgb * lightMapMult;// * gl_FragColor.a;
	// gl_FragColor.a = lightMapMult;
	// gl_FragColor.rgb = mix(texelOld, gl_FragColor.rgb, iterationBlend);
	// gl_FragColor.rgb = vec3(vUvLightMap);
}
`;
    shader.uniforms.previousLightMap = mat.uniforms.previousLightMap;
    shader.uniforms.lightMapMult = mat.uniforms.lightMapMult;
    mat.userData.shader = shader;
  };
  return mat;
}
