import { TypedSopNode } from './_Base';
import { CoreGroup } from '../../../core/geometry/Group';
import { NodeParamsConfig } from '../utils/params/ParamsConfig';
import { SopType } from '../../poly/registers/nodes/types/Sop';
export declare enum NoiseOperation {
    ADD = "add",
    SET = "set",
    MULT = "mult",
    SUBTRACT = "subtract",
    DIVIDE = "divide"
}
declare class NoiseSopParamsConfig extends NodeParamsConfig {
    /** @param noise amplitude */
    amplitude: import("../utils/params/ParamsConfig").ParamTemplate<import("../../index_all").ParamType.FLOAT>;
    /** @param toggle on to multiply the amplitude by a vertex attribute */
    tamplitudeAttrib: import("../utils/params/ParamsConfig").ParamTemplate<import("../../index_all").ParamType.BOOLEAN>;
    /** @param which vertex attribute to use */
    amplitudeAttrib: import("../utils/params/ParamsConfig").ParamTemplate<import("../../index_all").ParamType.STRING>;
    /** @param noise frequency */
    freq: import("../utils/params/ParamsConfig").ParamTemplate<import("../../index_all").ParamType.VECTOR3>;
    /** @param noise offset */
    offset: import("../utils/params/ParamsConfig").ParamTemplate<import("../../index_all").ParamType.VECTOR3>;
    /** @param noise octaves */
    octaves: import("../utils/params/ParamsConfig").ParamTemplate<import("../../index_all").ParamType.INTEGER>;
    /** @param amplitude attenuation for higher octaves */
    ampAttenuation: import("../utils/params/ParamsConfig").ParamTemplate<import("../../index_all").ParamType.FLOAT>;
    /** @param frequency increase for higher octaves */
    freqIncrease: import("../utils/params/ParamsConfig").ParamTemplate<import("../../index_all").ParamType.FLOAT>;
    /** @param noise seed */
    seed: import("../utils/params/ParamsConfig").ParamTemplate<import("../../index_all").ParamType.INTEGER>;
    /** @param toggle on to have the noise be multiplied by the normal */
    useNormals: import("../utils/params/ParamsConfig").ParamTemplate<import("../../index_all").ParamType.BOOLEAN>;
    /** @param set which attribute will be affected by the noise */
    attribName: import("../utils/params/ParamsConfig").ParamTemplate<import("../../index_all").ParamType.STRING>;
    /** @param toggle on to use rest attributes. This can be useful when the noise is animated and this node does not clone the input geometry. Without using rest attributes, the noise would be based on an already modified position, and would therefore accumulate on itself after each cook. This may be what you are after, but for a more conventional result, using a rest attribute will ensure that the noise remains stable. Note that the rest attribute can be created by a RestAttributes node */
    useRestAttributes: import("../utils/params/ParamsConfig").ParamTemplate<import("../../index_all").ParamType.BOOLEAN>;
    /** @param name of rest position */
    restP: import("../utils/params/ParamsConfig").ParamTemplate<import("../../index_all").ParamType.STRING>;
    /** @param name of rest normal */
    restN: import("../utils/params/ParamsConfig").ParamTemplate<import("../../index_all").ParamType.STRING>;
    /** @param operation done when applying the noise (add, set, mult, subtract, divide) */
    operation: import("../utils/params/ParamsConfig").ParamTemplate<import("../../index_all").ParamType.INTEGER>;
    /** @param toggle on to recompute normals if the position has been updated */
    computeNormals: import("../utils/params/ParamsConfig").ParamTemplate<import("../../index_all").ParamType.BOOLEAN>;
}
export declare class NoiseSopNode extends TypedSopNode<NoiseSopParamsConfig> {
    paramsConfig: NoiseSopParamsConfig;
    static type(): SopType;
    private _simplexBySeed;
    initializeNode(): void;
    setOperation(operation: NoiseOperation): void;
    cook(inputCoreGroups: CoreGroup[]): void;
    private _cookForFloat;
    private _cookForV2;
    private _cookForV3;
    private _cookForV4;
    private _noiseValue;
    private static _newAttribValueFromFloat;
    private static _newAttribValueFromVector2;
    private static _newAttribValueFromVector3;
    private static _newAttribValueFromVector4;
    private _amplitudeFromAttrib;
    private _fbm;
    private _getSimplex;
    private _createSimplex;
}
export {};
