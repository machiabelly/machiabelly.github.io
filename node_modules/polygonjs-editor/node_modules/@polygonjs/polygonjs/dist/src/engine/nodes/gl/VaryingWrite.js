"use strict";
import { GlType } from "./../../poly/registers/nodes/types/Gl";
import { TypedGlNode } from "./_Base";
import { NodeParamsConfig, ParamConfig } from "../utils/params/ParamsConfig";
import { GlConnectionPointType } from "../utils/io/connections/Gl";
import { ShaderName } from "../utils/shaders/ShaderName";
import { VaryingGLDefinition } from "./utils/GLDefinition";
import { ThreeToGl } from "../../../core/ThreeToGl";
const VARYING_NODE_AVAILABLE_GL_TYPES = [
  GlConnectionPointType.FLOAT,
  GlConnectionPointType.VEC2,
  GlConnectionPointType.VEC3,
  GlConnectionPointType.VEC4
];
class VaryingWriteGlParamsConfig extends NodeParamsConfig {
  constructor() {
    super(...arguments);
    this.name = ParamConfig.STRING("");
    this.type = ParamConfig.INTEGER(0, {
      menu: {
        entries: VARYING_NODE_AVAILABLE_GL_TYPES.map((name, i) => {
          return { name, value: i };
        })
      }
    });
  }
}
const ParamsConfig = new VaryingWriteGlParamsConfig();
const _VaryingWriteGlNode = class extends TypedGlNode {
  constructor() {
    super(...arguments);
    this.paramsConfig = ParamsConfig;
  }
  static type() {
    return GlType.VARYING_WRITE;
  }
  initializeNode() {
    this.addPostDirtyHook("_setMatToRecompile", this._setMatToRecompile.bind(this));
    this.io.connection_points.initializeNode();
    this.io.connection_points.set_input_name_function(() => {
      return this.inputName();
    });
    this.io.connection_points.set_expected_input_types_function(() => [
      VARYING_NODE_AVAILABLE_GL_TYPES[this.pv.type]
    ]);
    this.io.connection_points.set_expected_output_types_function(() => []);
  }
  inputName() {
    return _VaryingWriteGlNode.INPUT_NAME;
  }
  setLines(shaders_collection_controller) {
    if (shaders_collection_controller.currentShaderName() == ShaderName.VERTEX) {
      const glType = this.glType();
      if (!glType) {
        return;
      }
      const varyingName = this.pv.name;
      const definition = new VaryingGLDefinition(this, glType, varyingName);
      const input = ThreeToGl.any(this.variableForInput(_VaryingWriteGlNode.INPUT_NAME));
      const vertexBodyLine = `${varyingName} = ${input}`;
      shaders_collection_controller.addDefinitions(this, [definition], ShaderName.VERTEX);
      shaders_collection_controller.addBodyLines(this, [vertexBodyLine], ShaderName.VERTEX);
    }
  }
  attributeName() {
    return this.pv.name.trim();
  }
  glType() {
    const connectionPoints = this.io.inputs.namedInputConnectionPoints();
    if (!connectionPoints) {
      return;
    }
    const connection_point = connectionPoints[0];
    if (connection_point) {
      return connection_point.type();
    }
  }
  setGlType(type) {
    this.p.type.set(VARYING_NODE_AVAILABLE_GL_TYPES.indexOf(type));
  }
};
export let VaryingWriteGlNode = _VaryingWriteGlNode;
VaryingWriteGlNode.INPUT_NAME = "vertex";
