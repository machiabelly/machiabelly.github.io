"use strict";
import { PointerEventType } from "../../../../core/event/PointerEventType";
import { CoreEventEmitter } from "../../../../core/event/CoreEventEmitter";
import { MapUtils } from "../../../../core/MapUtils";
export class BaseSceneEventsController {
  constructor(dispatcher) {
    this.dispatcher = dispatcher;
    this._activeEventDatas = [];
    this._activeEventDataTypes = /* @__PURE__ */ new Set();
    this._eventNodes = /* @__PURE__ */ new Set();
    this._requireCanvasEventListeners = false;
    this._actorEvaluators = /* @__PURE__ */ new Set();
    // protected _actorEventNames: Set<string> = new Set();
    this._actorEvaluatorsByEventNames = /* @__PURE__ */ new Map();
  }
  registerEventNode(node) {
    this._eventNodes.add(node);
    this.updateViewerEventListeners();
  }
  unregisterEventNode(node) {
    this._eventNodes.delete(node);
    this.updateViewerEventListeners();
  }
  registerEvaluatorGenerator(evaluator) {
    this._actorEvaluators.add(evaluator);
    this._updateActorEvaluatorCache();
    this.updateViewerEventListeners();
  }
  unregisterEvaluatorGenerator(evaluator) {
    this._actorEvaluators.delete(evaluator);
    this._updateActorEvaluatorCache();
    this.updateViewerEventListeners();
  }
  _updateActorEvaluatorCache() {
    this._actorEvaluatorsByEventNames.clear();
    this._actorEvaluators.forEach((evaluator) => {
      const eventDatas = evaluator.eventDatas;
      if (eventDatas) {
        eventDatas.forEach((eventData) => {
          const eventName = eventData.type;
          const emitter = eventData.emitter;
          let mapForEventName = this._actorEvaluatorsByEventNames.get(eventName);
          if (!mapForEventName) {
            mapForEventName = /* @__PURE__ */ new Map();
            this._actorEvaluatorsByEventNames.set(eventName, mapForEventName);
          }
          MapUtils.addToSetAtEntry(mapForEventName, emitter, evaluator);
        });
      }
    });
  }
  // abstract accepts_event(event: Event): boolean;
  processEvent(eventContext) {
    var _a;
    if (this._activeEventDatas.length == 0) {
      return;
    }
    const eventType = (_a = eventContext.event) == null ? void 0 : _a.type;
    if (eventType) {
      if (!this._activeEventDataTypes.has(eventType)) {
        return;
      }
    }
    this._eventNodes.forEach((node) => {
      node.processEvent(eventContext);
    });
  }
  updateViewerEventListeners() {
    this._updateActiveEventTypes();
    if (this._requireCanvasEventListeners) {
      this.dispatcher.scene.viewersRegister.traverseViewers((viewer) => {
        viewer.eventsController().updateEvents(this);
      });
    }
  }
  activeEventDatas() {
    return this._activeEventDatas;
  }
  _updateActiveEventTypes() {
    const _storeEventData = (eventData) => {
      this._activeEventDatas.push(eventData);
      this._activeEventDataTypes.add(eventData.type);
    };
    const _reset = () => {
      this._activeEventDatas.splice(0, this._activeEventDatas.length);
      this._activeEventDataTypes.clear();
    };
    const _actorEventDatas = () => {
      let eventTypeByEmitter = /* @__PURE__ */ new Map();
      this._actorEvaluatorsByEventNames.forEach((mapForEventName, eventName) => {
        mapForEventName.forEach((nodes, emitter) => {
          nodes.forEach((node) => {
            MapUtils.addToSetAtEntry(eventTypeByEmitter, emitter, eventName);
          });
        });
      });
      const eventDatas = [];
      eventTypeByEmitter.forEach((eventNames, emitter) => {
        for (const eventName of eventNames) {
          const eventData = {
            type: eventName,
            emitter
          };
          eventDatas.push(eventData);
        }
      });
      return eventDatas;
    };
    const _updateActorNodesEventData = () => {
      const actorEventDatas = _actorEventDatas();
      if (actorEventDatas) {
        for (const data of actorEventDatas) {
          _storeEventData(data);
        }
      }
    };
    const _updateEventNodesEventData = () => {
      const activeNodeEventTypesState = /* @__PURE__ */ new Set();
      this._eventNodes.forEach((node) => {
        if (node.parent()) {
          const nodeActiveEventDatas = node.activeEventDatas();
          for (const data of nodeActiveEventDatas) {
            activeNodeEventTypesState.add(data);
          }
        }
      });
      activeNodeEventTypesState.forEach((state, data) => {
        _storeEventData(data);
      });
    };
    _reset();
    _storeEventData({
      type: PointerEventType.pointermove,
      emitter: CoreEventEmitter.DOCUMENT
    });
    _storeEventData({
      type: PointerEventType.touchmove,
      emitter: CoreEventEmitter.DOCUMENT
    });
    _updateActorNodesEventData();
    _updateEventNodesEventData();
  }
}
export class BaseSceneEventsControllerClass extends BaseSceneEventsController {
  type() {
    return "";
  }
  acceptedEventTypes() {
    return /* @__PURE__ */ new Set();
  }
}
