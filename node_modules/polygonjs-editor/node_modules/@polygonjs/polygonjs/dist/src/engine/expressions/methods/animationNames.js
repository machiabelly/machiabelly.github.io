"use strict";
import { BaseMethod } from "./_Base";
export class AnimationNamesExpression extends BaseMethod {
  static requiredArguments() {
    return [
      ["string", "path to node"],
      ["number", "object index (optional)"]
    ];
  }
  findDependency(args) {
    return this.createDependencyFromIndexOrPath(args);
  }
  processArguments(args) {
    return new Promise(async (resolve, reject) => {
      if (args.length == 1 || args.length == 2) {
        const index_or_path = args[0];
        let objectIndex = parseInt(args[1]);
        if (isNaN(objectIndex) || objectIndex == null) {
          objectIndex = 0;
        }
        let container;
        try {
          container = await this.getReferencedNodeContainer(index_or_path);
        } catch (e) {
          reject(e);
          return;
        }
        if (container) {
          const coreContent = container.coreContent();
          if (coreContent) {
            const object = coreContent.threejsObjects()[objectIndex];
            if (object) {
              const animations = object.animations;
              if (!animations) {
                return [];
              }
              const animationNames = new Array(animations.length);
              let i = 0;
              for (const animation of animations) {
                animationNames[i] = animation.name;
                i++;
              }
              resolve(animationNames);
            }
          } else {
            resolve([]);
          }
        }
      } else {
        resolve([]);
      }
    });
  }
}
