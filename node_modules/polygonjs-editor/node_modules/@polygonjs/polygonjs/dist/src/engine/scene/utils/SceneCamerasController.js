"use strict";
import { Poly } from "../../Poly";
import { CoreGraphNode } from "../../../core/graph/CoreGraphNode";
const _cameras = [];
export class SceneCamerasController {
  constructor(scene) {
    this.scene = scene;
    this._cameraObjectsRecentlyUpdated = [];
    // async mainCameraObjectPath() {
    // 	return this._mainCameraObjectPath;
    // }
    this._errorMessageDisplayed = false;
    this._onCameraObjectsUpdatedCallbacks = [];
    this._coreGraphNode = new CoreGraphNode(this.scene, "SceneCamerasController");
  }
  coreGraphNode() {
    return this._coreGraphNode;
  }
  dispose() {
    this._coreGraphNode.dispose();
  }
  updateFromChangeInObject(object) {
    this._cameraObjects(object, this._cameraObjectsRecentlyUpdated);
    if (this._cameraObjectsRecentlyUpdated.length > 0) {
      this._coreGraphNode.setDirty();
    }
    for (const callback of this._onCameraObjectsUpdatedCallbacks) {
      callback();
    }
  }
  cameraObjects(target) {
    this._cameraObjects(this.scene.threejsScene(), target);
    return target;
  }
  _cameraObjects(parent, cameraObjects) {
    cameraObjects.splice(0, cameraObjects.length);
    parent.traverse((object) => {
      if (Poly.camerasRegister.objectRegistered(object)) {
        cameraObjects.push(object);
      }
    });
  }
  cameraObjectsRecentlyUpdated() {
    return this._cameraObjectsRecentlyUpdated;
  }
  // _mainCameraObjectPath: string | null = null;
  setMainCamera(camera) {
    this.scene.root().mainCameraController.setCamera(camera);
  }
  setMainCameraPath(path) {
    this.scene.root().mainCameraController.setCameraPath(path);
  }
  mainCameraPath() {
    return this.scene.root().mainCameraController.rawCameraPath();
  }
  async mainCamera(options) {
    if (this.scene.disposed()) {
      return null;
    }
    let printCameraNotFoundError = true;
    if ((options == null ? void 0 : options.printCameraNotFoundError) != null) {
      printCameraNotFoundError = options.printCameraNotFoundError;
    }
    const cameraMaskOverride = options == null ? void 0 : options.cameraMaskOverride;
    if (cameraMaskOverride != null) {
      this.scene.root().mainCameraController.setCameraPath(cameraMaskOverride);
    }
    const _printWarningMessage = (warningMessage2) => {
      if (this._errorMessageDisplayed == true) {
        return;
      }
      if (printCameraNotFoundError) {
        console.error(warningMessage2);
        this._errorMessageDisplayed = true;
      }
    };
    const camera = await this.scene.root().mainCameraController.camera();
    if (camera) {
      return camera;
    }
    let findAnyCamera = true;
    if ((options == null ? void 0 : options.findAnyCamera) != null) {
      findAnyCamera = options.findAnyCamera;
    }
    const cameraPath = await this.scene.root().mainCameraController.cameraPath();
    const warningMessage = `No camera found at path '${cameraPath}'. Make sure to set the root parameter 'mainCameraPath' to match a camera (from the top menu Windows->Root Node Params)`;
    if (findAnyCamera) {
      const firstAnyCamera = this._findAnyCameraObject();
      if (firstAnyCamera) {
        _printWarningMessage(warningMessage);
        return firstAnyCamera;
      }
    }
    _printWarningMessage(warningMessage);
    return null;
  }
  _findAnyCameraObject() {
    this.cameraObjects(_cameras);
    return _cameras[0];
  }
  async createMainViewer(options) {
    const camera = await this.mainCamera({
      cameraMaskOverride: options == null ? void 0 : options.cameraMaskOverride
    });
    if (!camera) {
      return;
    }
    return Poly.camerasRegister.createViewer({
      ...options,
      camera,
      scene: this.scene
    });
  }
  onCameraObjectsUpdated(callback) {
    const index = this._onCameraObjectsUpdatedCallbacks.indexOf(callback);
    if (index >= 0) {
      return;
    }
    this._onCameraObjectsUpdatedCallbacks.push(callback);
  }
  removeOnCameraObjectsUpdated(callback) {
    const index = this._onCameraObjectsUpdatedCallbacks.indexOf(callback);
    if (index >= 0) {
      this._onCameraObjectsUpdatedCallbacks.splice(index, 1);
    }
  }
}
