"use strict";
import { MapUtils } from "../../../../core/MapUtils";
import { NetworkChildNodeType } from "../../../poly/NodeContext";
import { arrayUniq, arrayDifference, arrayCompact } from "../../../../core/ArrayUtils";
export class TypedNodeTraverser {
  // private _subnets_by_id: BaseNodeTypeByString = new Map();
  constructor(_parent_node, _shader_names, _inputNamesForShaderNameMethod, _options) {
    this._parent_node = _parent_node;
    this._shader_names = _shader_names;
    this._inputNamesForShaderNameMethod = _inputNamesForShaderNameMethod;
    this._options = _options;
    this._leaves_graph_id = /* @__PURE__ */ new Map();
    this._graph_ids_by_shader_name = /* @__PURE__ */ new Map();
    this._outputs_by_graph_id = /* @__PURE__ */ new Map();
    this._depth_by_graph_id = /* @__PURE__ */ new Map();
    this._graph_id_by_depth = /* @__PURE__ */ new Map();
    this._graph = this._parent_node.scene().graph;
  }
  _traverseChildren() {
    var _a;
    return ((_a = this._options) == null ? void 0 : _a.traverseChildren) || false;
  }
  reset() {
    this._leaves_graph_id.clear();
    this._graph_ids_by_shader_name.clear();
    this._outputs_by_graph_id.clear();
    this._depth_by_graph_id.clear();
    this._graph_id_by_depth.clear();
    this._shader_names.forEach((shader_name) => {
      this._graph_ids_by_shader_name.set(shader_name, /* @__PURE__ */ new Map());
    });
  }
  shaderNames() {
    return this._shader_names;
  }
  inputNamesForShaderName(root_node, shader_name) {
    return this._inputNamesForShaderNameMethod(root_node, shader_name);
  }
  traverse(rootNodes) {
    this.reset();
    for (const shaderName of this.shaderNames()) {
      this._leaves_graph_id.set(shaderName, /* @__PURE__ */ new Map());
    }
    for (const shaderName of this.shaderNames()) {
      this._shaderName = shaderName;
      for (const rootNode of rootNodes) {
        this._findLeavesFromRootNode(rootNode);
        this._setNodesDepth();
      }
    }
    this._depth_by_graph_id.forEach((depth, graph_id) => {
      if (depth != null) {
        MapUtils.pushOnArrayAtEntry(this._graph_id_by_depth, depth, graph_id);
      }
    });
  }
  nodesForShaderName(shaderName) {
    const depths = [];
    this._graph_id_by_depth.forEach((value, key) => {
      depths.push(key);
    });
    depths.sort((a, b) => a - b);
    const nodes = [];
    const node_id_used_state = /* @__PURE__ */ new Map();
    depths.forEach((depth) => {
      const graph_ids_for_depth = this._graph_id_by_depth.get(depth);
      if (graph_ids_for_depth) {
        graph_ids_for_depth.forEach((graph_id) => {
          var _a;
          const is_present = (_a = this._graph_ids_by_shader_name.get(shaderName)) == null ? void 0 : _a.get(graph_id);
          if (is_present) {
            const node = this._graph.nodeFromId(graph_id);
            this._addNodesWithChildren(node, node_id_used_state, nodes);
          }
        });
      }
    });
    return nodes;
  }
  sortedNodes() {
    const depths = [];
    this._graph_id_by_depth.forEach((ids, depth) => {
      depths.push(depth);
    });
    depths.sort((a, b) => a - b);
    const nodes = [];
    const node_id_used_state = /* @__PURE__ */ new Map();
    depths.forEach((depth) => {
      const graph_ids_for_depth = this._graph_id_by_depth.get(depth);
      if (graph_ids_for_depth) {
        for (const graph_id of graph_ids_for_depth) {
          const node = this._graph.nodeFromId(graph_id);
          if (node) {
            this._addNodesWithChildren(node, node_id_used_state, nodes);
          }
        }
      }
    });
    return nodes;
  }
  _addNodesWithChildren(node, node_id_used_state, accumulated_nodes) {
    if (!node_id_used_state.get(node.graphNodeId())) {
      accumulated_nodes.push(node);
      node_id_used_state.set(node.graphNodeId(), true);
    }
  }
  // private _sortedNodesForShaderNameForParent(parent: BaseNodeType, shader_name?: ShaderName) {
  // 	const depths: number[] = [];
  // 	this._graph_id_by_depth.forEach((value: CoreGraphNodeId[], key: number) => {
  // 		depths.push(key);
  // 	});
  // 	depths.sort((a, b) => a - b);
  // 	const nodes: BaseNodeByContextMap[NC][] = [];
  // 	depths.forEach((depth) => {
  // 		const graph_ids_for_depth = this._graph_id_by_depth.get(depth);
  // 		if (graph_ids_for_depth) {
  // 			graph_ids_for_depth.forEach((graph_id: CoreGraphNodeId) => {
  // 				const is_present = shader_name
  // 					? this._graph_ids_by_shader_name.get(shader_name)?.get(graph_id)
  // 					: true;
  // 				if (is_present) {
  // 					const node = this._graph.nodeFromId(graph_id) as BaseNodeByContextMap[NC];
  // 					if (node.parent() == parent) {
  // 						nodes.push(node);
  // 					}
  // 				}
  // 			});
  // 		}
  // 	});
  // 	const first_node = nodes[0];
  // 	if (parent.context() == first_node.context()) {
  // 		nodes.push(parent as BaseNodeByContextMap[NC]);
  // 	}
  // 	return nodes;
  // }
  _findLeavesFromRootNode(rootNode) {
    var _a, _b;
    (_a = this._graph_ids_by_shader_name.get(this._shaderName)) == null ? void 0 : _a.set(rootNode.graphNodeId(), true);
    if (rootNode.childrenAllowed() && this._traverseChildren()) {
      const outputNode = (_b = rootNode.childrenController) == null ? void 0 : _b.outputNode();
      if (outputNode) {
        this._findLeavesFromRootNode(outputNode);
        return;
      }
    }
    const inputNames = this.inputNamesForShaderName(rootNode, this._shaderName);
    if (inputNames) {
      for (const inputName of inputNames) {
        const input = rootNode.io.inputs.named_input(inputName);
        if (input) {
          MapUtils.pushOnArrayAtEntry(this._outputs_by_graph_id, input.graphNodeId(), rootNode.graphNodeId());
          this._findLeaves(input);
        }
      }
    }
    this._outputs_by_graph_id.forEach((outputs, graph_id) => {
      const uniqIds = [];
      arrayUniq(outputs, uniqIds);
      this._outputs_by_graph_id.set(graph_id, uniqIds);
    });
  }
  setBlockedInputNames(nodeType, inputNames) {
    this._blockedInputNames = this._blockedInputNames || /* @__PURE__ */ new Map();
    this._blockedInputNames.set(nodeType, inputNames);
  }
  _findLeaves(node) {
    var _a;
    (_a = this._graph_ids_by_shader_name.get(this._shaderName)) == null ? void 0 : _a.set(node.graphNodeId(), true);
    const inputs = this._findInputs(node);
    const compactInputs = [];
    arrayCompact(inputs, compactInputs);
    const inputGraphIds = [];
    arrayUniq(
      compactInputs.map((n) => n.graphNodeId()),
      inputGraphIds
    );
    const uniqueInputs = inputGraphIds.map(
      (graph_id) => this._graph.nodeFromId(graph_id)
    );
    if (uniqueInputs.length > 0) {
      for (const input of uniqueInputs) {
        MapUtils.pushOnArrayAtEntry(this._outputs_by_graph_id, input.graphNodeId(), node.graphNodeId());
        this._findLeaves(input);
      }
    } else {
      this._leaves_graph_id.get(this._shaderName).set(node.graphNodeId(), true);
    }
  }
  getNodeInputs(node) {
    if (this._blockedInputNames == null || !this._blockedInputNames.has(node.type())) {
      return node.io.inputs.inputs();
    } else {
      const blockedInputNames = this._blockedInputNames.get(node.type());
      const inputConnectionPoints = node.io.inputs.namedInputConnectionPoints();
      const inputConnectionPointNames = inputConnectionPoints.map((c) => c.name());
      const allowedInputNames = [];
      arrayDifference(inputConnectionPointNames, blockedInputNames, allowedInputNames);
      const inputs = allowedInputNames.map((inputName) => {
        const inputIndex = node.io.inputs.getNamedInputIndex(inputName);
        return node.io.inputs.input(inputIndex);
      });
      return inputs;
    }
  }
  _findInputs(node) {
    var _a;
    if (this._traverseChildren()) {
      if (node.type() == NetworkChildNodeType.INPUT) {
        const parent = node.parent();
        return parent ? this.getNodeInputs(parent) : [];
      } else {
        if (node.childrenAllowed()) {
          const outputNode = (_a = node.childrenController) == null ? void 0 : _a.outputNode();
          return [outputNode];
        } else {
          return this.getNodeInputs(node);
        }
      }
    } else {
      return this.getNodeInputs(node);
    }
  }
  _setNodesDepth() {
    this._leaves_graph_id.forEach((booleans_by_graph_id, shader_name) => {
      booleans_by_graph_id.forEach((boolean, graph_id) => {
        this._setNodeDepth(graph_id);
      });
    });
  }
  _setNodeDepth(graph_id, depth = 0) {
    const current_depth = this._depth_by_graph_id.get(graph_id);
    if (current_depth != null) {
      this._depth_by_graph_id.set(graph_id, Math.max(current_depth, depth));
    } else {
      this._depth_by_graph_id.set(graph_id, depth);
    }
    const output_ids = this._outputs_by_graph_id.get(graph_id);
    if (output_ids) {
      output_ids.forEach((output_id) => {
        this._setNodeDepth(output_id, depth + 1);
      });
    }
  }
}
