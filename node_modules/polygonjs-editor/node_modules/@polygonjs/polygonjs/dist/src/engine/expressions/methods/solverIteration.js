"use strict";
import { NetworkNodeType } from "./../../poly/NodeContext";
import { BaseMethod } from "./_Base";
function isSolverNode(node) {
  return node && node.type() == NetworkNodeType.SOLVER;
}
export class SolverIterationExpression extends BaseMethod {
  static requiredArguments() {
    return [];
  }
  static optionalArguments() {
    return [["string", "path to solver node"]];
  }
  _solverNode() {
    const solverNode = this.param.node.parentController.findParent(
      (parent) => parent.type() == NetworkNodeType.SOLVER
    );
    return solverNode;
  }
  findDependency(args) {
    const { indexOrPath } = args;
    const node = indexOrPath ? this.findReferencedGraphNode(indexOrPath) : this._solverNode();
    if (isSolverNode(node)) {
      const solverStamp = node.iterationStamp();
      return this.createDependency(solverStamp, { indexOrPath, node });
    }
    return null;
  }
  async processArguments(args) {
    const nodePath = args[0] || "..";
    const foundNode = await this.getReferencedNode(nodePath);
    if (foundNode && isSolverNode(foundNode)) {
      const foundSolverNode = foundNode;
      const value = foundSolverNode.iterationStamp().iteration();
      return value;
    } else {
      return 0;
    }
  }
}
