"use strict";
import { BasePersistedConfig } from "../../../../utils/BasePersistedConfig";
import { BuilderPostNode } from "../../../../post/Builder";
import { GlParamConfig } from "../../utils/GLParamConfig";
const FRAGMENT_KEY = "fragment";
export class PostPersistedConfig extends BasePersistedConfig {
  constructor(node) {
    super(node);
    this.node = node;
  }
  async toData() {
    const assemblerController = this.node.assemblerController();
    if (!assemblerController) {
      return;
    }
    const param_uniform_pairs = [];
    const param_configs = assemblerController.assembler.param_configs();
    for (const param_config of param_configs) {
      param_uniform_pairs.push([param_config.name(), param_config.uniformName()]);
    }
    const data = {
      // fragment_shader: this.node.fragmentShader(),
      uniforms: this.node.uniforms(),
      param_uniform_pairs,
      uniforms_time_dependent: assemblerController.assembler.uniformsTimeDependent(),
      uniforms_resolution_dependent: assemblerController.assembler.uniformsResolutionDependent(),
      shaders: {
        [FRAGMENT_KEY]: this.node.fragmentShader()
      }
    };
    return data;
  }
  load(data) {
    const assemblerController = this.node.assemblerController();
    if (assemblerController) {
      return;
    }
    const shaders = data.shaders;
    if (shaders && shaders[FRAGMENT_KEY] != null) {
      this.node.setFragmentShader(shaders[FRAGMENT_KEY]);
    } else {
      console.warn(`${this.node.path()}: persisted config has no fragment shader`);
    }
    this.node.setUniforms(data.uniforms);
    BuilderPostNode.handleDependencies(
      this.node,
      data.uniforms_time_dependent || false,
      data.uniforms
    );
    for (const pair of data.param_uniform_pairs) {
      const param = this.node.params.get(pair[0]);
      const uniform = data.uniforms[pair[1]];
      if (param && uniform) {
        const callback = () => {
          GlParamConfig.callback(param, uniform);
        };
        param.options.set({
          callback
        });
        callback();
      }
    }
  }
}
