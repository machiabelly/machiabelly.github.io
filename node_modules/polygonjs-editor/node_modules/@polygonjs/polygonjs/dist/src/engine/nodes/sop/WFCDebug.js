"use strict";
import { TypedSopNode } from "./_Base";
import { NodeParamsConfig, ParamConfig } from "../utils/params/ParamsConfig";
import { SopType } from "../../poly/registers/nodes/types/Sop";
import { InputCloneMode } from "../../poly/InputCloneMode";
import { WFCTilesCollection } from "../../../core/wfc/WFCTilesCollection";
import { stringMatchMask } from "../../../core/String";
import { CoreWFCTileAttribute } from "../../../core/wfc/WFCAttributes";
import { Group } from "three";
import { ALL_HORIZONTAL_SIDES, CLOCK_WISE_TILE_SIDES } from "../../../core/wfc/WFCCommon";
import { EMPTY_TILE_ID } from "../../../core/wfc/WFCConstant";
class WFCDebugSopParamsConfig extends NodeParamsConfig {
  constructor() {
    super(...arguments);
    /** @param src tile id */
    this.srcTileId = ParamConfig.STRING("*");
    /** @param dest tile id */
    this.destTileId = ParamConfig.STRING("*");
    /** @param side name */
    this.sideName = ParamConfig.STRING("*");
  }
}
const ParamsConfig = new WFCDebugSopParamsConfig();
export class WFCDebugSopNode extends TypedSopNode {
  constructor() {
    super(...arguments);
    this.paramsConfig = ParamsConfig;
  }
  static type() {
    return SopType.WFC_DEBUG;
  }
  initializeNode() {
    this.io.inputs.setCount(1);
    this.io.inputs.initInputsClonedState(InputCloneMode.FROM_NODE);
  }
  async cook(inputCoreGroups) {
    const coreGroup = inputCoreGroups[0];
    const tileAndRuleObjects = coreGroup.threejsObjects();
    const collection = new WFCTilesCollection({ tileAndRuleObjects });
    const { srcTileId, destTileId, sideName } = this.pv;
    const srcTiles = collection.tiles().filter((tileObject) => stringMatchMask(CoreWFCTileAttribute.getTileId(tileObject), srcTileId));
    const destTiles = collection.tiles().filter((tileObject) => stringMatchMask(CoreWFCTileAttribute.getTileId(tileObject), destTileId));
    const newObjects = [];
    const visited = /* @__PURE__ */ new Set();
    let i = 0;
    for (const srcTile of srcTiles) {
      const srcTileId2 = CoreWFCTileAttribute.getTileId(srcTile);
      let j = 0;
      for (const destTile of destTiles) {
        const destTileId2 = CoreWFCTileAttribute.getTileId(destTile);
        collection.traverseRules(srcTileId2, destTileId2, (id0, id1, side0, side1) => {
          const srcSideName = CoreWFCTileAttribute.getSideName(srcTile, side0);
          const destSideName = CoreWFCTileAttribute.getSideName(destTile, side1);
          if (srcSideName && destSideName) {
            if (!(stringMatchMask(srcSideName, sideName) && stringMatchMask(destSideName, sideName))) {
              return;
            }
          }
          side0 = id0 == EMPTY_TILE_ID && ALL_HORIZONTAL_SIDES.includes(side0) ? ALL_HORIZONTAL_SIDES : side0;
          side1 = id1 == EMPTY_TILE_ID && ALL_HORIZONTAL_SIDES.includes(side1) ? ALL_HORIZONTAL_SIDES : side1;
          const id = `${id0}:${side0}-${id1}:${side1}`;
          if (visited.has(id)) {
            return;
          }
          let inverted = id0 != srcTileId2;
          visited.add(id);
          const group = new Group();
          newObjects.push(group);
          group.matrixAutoUpdate = false;
          group.position.x = 3 * i;
          group.position.z = 2 * j;
          group.updateMatrix();
          group.name = `src:${srcTileId2} dest:${destTileId2} side0:${side0} side1:${side1}`;
          const srcTileClone = inverted ? destTile.clone() : srcTile.clone();
          const destTileClone = inverted ? srcTile.clone() : destTile.clone();
          group.add(srcTileClone);
          group.add(destTileClone);
          const srcTileRotation = CLOCK_WISE_TILE_SIDES.indexOf(side0);
          const destTileRotation = CLOCK_WISE_TILE_SIDES.indexOf(side1);
          if (srcTileRotation >= 0) {
            srcTileClone.rotation.y = srcTileRotation * Math.PI / 2;
          }
          switch (side1) {
            case "b": {
              destTileClone.position.y = -1;
              break;
            }
            case "t": {
              destTileClone.position.y = 1;
              break;
            }
            default: {
              destTileClone.position.x = 1;
              destTileClone.rotation.y = (destTileRotation + 2) * Math.PI / 2;
            }
          }
          srcTileClone.updateMatrix();
          destTileClone.updateMatrix();
          j++;
        });
      }
      i++;
    }
    this.setObjects(newObjects);
  }
}
