"use strict";
import { TypedPostNode, PostParamOptions } from "./_Base";
import { EffectPass, BlendFunction, LUT3DEffect } from "postprocessing";
import { NodeParamsConfig, ParamConfig } from "../utils/params/ParamsConfig";
import { BLEND_FUNCTION_MENU_OPTIONS } from "../../../core/post/BlendFunction";
import { NodeContext } from "../../poly/NodeContext";
class LutPostParamsConfig extends NodeParamsConfig {
  constructor() {
    super(...arguments);
    /** @param texture */
    this.texture = ParamConfig.NODE_PATH("", {
      nodeSelection: {
        context: NodeContext.COP
      },
      dependentOnFoundNode: false,
      ...PostParamOptions
    });
    /** @param effect opacity */
    this.opacity = ParamConfig.FLOAT(1, {
      range: [0, 1],
      rangeLocked: [true, false],
      ...PostParamOptions
    });
    /** @param render mode */
    this.blendFunction = ParamConfig.INTEGER(BlendFunction.NORMAL, {
      ...PostParamOptions,
      ...BLEND_FUNCTION_MENU_OPTIONS
    });
  }
}
const ParamsConfig = new LutPostParamsConfig();
export class LutPostNode extends TypedPostNode {
  constructor() {
    super(...arguments);
    this.paramsConfig = ParamsConfig;
  }
  static type() {
    return "lut";
  }
  createPass(context) {
    const passes = [];
    const texture = null;
    const effect = context.renderer.capabilities.isWebGL2 ? new LUT3DEffect(texture) : new LUT3DEffect(null);
    const pass = new EffectPass(context.camera, effect);
    passes.push(pass);
    this.updatePass(pass);
    return passes;
  }
  async updatePass(pass) {
    const effect = pass.effects[0];
    if (!effect) {
      return;
    }
    effect.blendMode.opacity.value = this.pv.opacity;
    effect.blendMode.blendFunction = this.pv.blendFunction;
    const texture = await this._fetchTexture();
    if (texture) {
      effect.lut = texture;
    }
  }
  async _fetchTexture() {
    var _a;
    const textureNode = this.pv.texture.nodeWithContext(NodeContext.COP, (_a = this.states) == null ? void 0 : _a.error);
    if (textureNode) {
      const container = await textureNode.compute();
      return container.coreContent();
    }
  }
}
