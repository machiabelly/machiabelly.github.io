"use strict";
import { TypedJsNode } from "./_Base";
import { NodeParamsConfig } from "../utils/params/ParamsConfig";
import { JsConnectionPointType } from "../utils/io/connections/Js";
import { createVariable } from "./code/assemblers/_BaseJsPersistedConfigUtils";
const ALLOWED_TYPES = [
  JsConnectionPointType.BOOLEAN,
  JsConnectionPointType.INT,
  JsConnectionPointType.COLOR,
  JsConnectionPointType.FLOAT,
  JsConnectionPointType.INTERSECTION,
  JsConnectionPointType.MATERIAL,
  JsConnectionPointType.OBJECT_3D,
  JsConnectionPointType.STRING,
  JsConnectionPointType.TEXTURE,
  JsConnectionPointType.VECTOR2,
  JsConnectionPointType.VECTOR3,
  JsConnectionPointType.VECTOR4
];
const OUTPUT_NAME = "defined";
var IsDefinedInputName = /* @__PURE__ */ ((IsDefinedInputName2) => {
  IsDefinedInputName2["VALUE"] = "value";
  return IsDefinedInputName2;
})(IsDefinedInputName || {});
class IsDefinedJsParamsConfig extends NodeParamsConfig {
}
const ParamsConfig = new IsDefinedJsParamsConfig();
export class IsDefinedJsNode extends TypedJsNode {
  constructor() {
    super(...arguments);
    this.paramsConfig = ParamsConfig;
  }
  static type() {
    return "isDefined";
  }
  initializeNode() {
    super.initializeNode();
    this.io.connection_points.initializeNode();
    this.io.connection_points.set_input_name_function(this._expectedInputName.bind(this));
    this.io.connection_points.set_output_name_function(this._expectedOutputName.bind(this));
    this.io.connection_points.set_expected_input_types_function(this._expectedInputTypes.bind(this));
    this.io.connection_points.set_expected_output_types_function(this._expectedOutputTypes.bind(this));
  }
  _expectedInputName(index) {
    return ["value" /* VALUE */][index];
  }
  _expectedInputTypes() {
    let first_input_type = this.io.connection_points.first_input_connection_type();
    const connectionPoints = this.io.inputs.namedInputConnectionPoints();
    if (first_input_type && connectionPoints) {
      if (!ALLOWED_TYPES.includes(first_input_type)) {
        const first_connection = connectionPoints[0];
        if (first_connection) {
          first_input_type = first_connection.type();
        }
      }
    }
    const type = first_input_type || JsConnectionPointType.FLOAT;
    return [type];
  }
  _expectedOutputTypes() {
    return [JsConnectionPointType.BOOLEAN];
  }
  _expectedOutputName(index) {
    return OUTPUT_NAME;
  }
  setLines(linesController) {
    const varName = this.jsVarName(this._expectedOutputName(0));
    const inputType = this._expectedInputTypes()[0];
    const variable = createVariable(inputType);
    if (variable) {
      linesController.addVariable(this, variable);
    }
    const value = this.variableForInput(linesController, "value" /* VALUE */);
    const mainFunction = `${value} != null`;
    linesController.addBodyOrComputed(this, [{ dataType: inputType, varName, value: mainFunction }]);
  }
}
