"use strict";
import { BaseSopOperation } from "./_Base";
import { InputCloneMode } from "../../poly/InputCloneMode";
import { Color } from "three";
import { SORTED_PALETTE_NAMES } from "../../../core/color/chromotomeWrapper";
import { AttribClass, ATTRIBUTE_CLASSES } from "../../../core/geometry/Constant";
import { TypeAssert } from "../../poly/Assert";
import { coreObjectClassFactory, corePointClassFactory } from "../../../core/geometry/CoreObjectFactory";
export class PaletteSopOperation extends BaseSopOperation {
  static type() {
    return "palette";
  }
  cook(inputCoreGroups, params) {
    const coreGroup = inputCoreGroups[0];
    const colors = [params.color1, params.color2, params.color3, params.color4, params.color5];
    this._addAttribute(ATTRIBUTE_CLASSES[params.class], coreGroup, params, colors);
    return coreGroup;
  }
  async _addAttribute(attribClass, coreGroup, params, colors) {
    var _a, _b;
    switch (attribClass) {
      case AttribClass.POINT:
        return await this._setVertexColor(coreGroup, params, colors);
      case AttribClass.VERTEX:
        (_a = this.states) == null ? void 0 : _a.error.set("vertex not supported yet");
        return;
      case AttribClass.PRIMITIVE:
        (_b = this.states) == null ? void 0 : _b.error.set("primitive not supported yet");
        return;
      case AttribClass.OBJECT:
        return await this._setObjectColor(coreGroup, params, colors);
      case AttribClass.CORE_GROUP:
        return;
    }
    TypeAssert.unreachable(attribClass);
  }
  _setObjectColor(coreGroup, params, colors) {
    const objects = coreGroup.allObjects();
    let i = 0;
    for (let object of objects) {
      const color = colors[i % params.colorsCount];
      coreObjectClassFactory(object).addAttribute(object, "color", color.clone());
      i++;
    }
    return coreGroup;
  }
  _setVertexColor(coreGroup, params, colors) {
    const objects = coreGroup.threejsObjectsWithGeo();
    for (let object of objects) {
      this._setVertexColorToObject(object, params, colors);
    }
  }
  _setVertexColorToObject(object, params, colors) {
    if (params.colorsCount <= 0) {
      return;
    }
    const corePointClass = corePointClassFactory(object);
    const geometry = object.geometry;
    if (!geometry) {
      return;
    }
    let colorAttrib = geometry.getAttribute("color");
    if (!colorAttrib) {
      corePointClass.addNumericAttribute(object, "color", 3, [0, 0, 0]);
      colorAttrib = geometry.getAttribute("color");
    }
    if (!colorAttrib) {
      return;
    }
    const array = colorAttrib.array;
    let ptIndex = 0;
    for (let i = 0; i < array.length; i += 3) {
      const color = colors[ptIndex % params.colorsCount];
      color.toArray(array, i);
      ptIndex++;
    }
  }
}
PaletteSopOperation.DEFAULT_PARAMS = {
  class: ATTRIBUTE_CLASSES.indexOf(AttribClass.POINT),
  paletteName: SORTED_PALETTE_NAMES[0],
  colorsCount: 0,
  color1: new Color(1, 1, 1),
  color2: new Color(1, 1, 1),
  color3: new Color(1, 1, 1),
  color4: new Color(1, 1, 1),
  color5: new Color(1, 1, 1)
};
PaletteSopOperation.INPUT_CLONED_STATE = InputCloneMode.FROM_NODE;
