"use strict";
import { TypedMatNode } from "../_Base";
import { BaseTextureMapController, BooleanParamOptions, NodePathOptions } from "./_BaseTextureController";
import { NodeParamsConfig, ParamConfig } from "../../utils/params/ParamsConfig";
import { MultiplyOperation, MixOperation, AddOperation } from "three";
import { CopType } from "../../../poly/registers/nodes/types/Cop";
var CombineOperation = /* @__PURE__ */ ((CombineOperation2) => {
  CombineOperation2["MULT"] = "mult";
  CombineOperation2["ADD"] = "add";
  CombineOperation2["MIX"] = "mix";
  return CombineOperation2;
})(CombineOperation || {});
const COMBINE_OPERATIONS = ["mult" /* MULT */, "add" /* ADD */, "mix" /* MIX */];
const OperationByName = {
  ["mult" /* MULT */]: MultiplyOperation,
  ["add" /* ADD */]: AddOperation,
  ["mix" /* MIX */]: MixOperation
};
const NameByOperation = {
  [MultiplyOperation]: "mult" /* MULT */,
  [AddOperation]: "add" /* ADD */,
  [MixOperation]: "mix" /* MIX */
};
export function EnvMapSimpleParamConfig(Base) {
  return class Mixin extends Base {
    constructor() {
      super(...arguments);
      /** @param toggle if you want to use an environment map */
      this.useEnvMap = ParamConfig.BOOLEAN(0, {
        separatorBefore: true,
        ...BooleanParamOptions(TextureEnvMapSimpleController)
      });
      /** @param specify the environment map COP node. Note that this only works with CubeCamera */
      this.envMap = ParamConfig.NODE_PATH(
        "",
        NodePathOptions(TextureEnvMapSimpleController, "useEnvMap", {
          types: [CopType.CUBE_MAP, CopType.CUBE_MAP_FROM_SCENE, CopType.CUBE_CAMERA]
        })
      );
      /** @param defines how the env map is combined with the color */
      this.combine = ParamConfig.INTEGER(0, {
        visibleIf: { useEnvMap: 1 },
        menu: {
          entries: COMBINE_OPERATIONS.map((name, value) => {
            return { name, value };
          })
        }
      });
      /** @param environment intensity */
      this.reflectivity = ParamConfig.FLOAT(1, { visibleIf: { useEnvMap: 1 } });
      /** @param refraction ratio */
      this.refractionRatio = ParamConfig.FLOAT(0.98, {
        range: [-1, 1],
        rangeLocked: [false, false],
        visibleIf: { useEnvMap: 1 }
      });
    }
  };
}
function _isValidMaterial(material) {
  if (!material) {
    return false;
  }
  return material.reflectivity != null;
}
class TextureEnvMapSimpleParamsConfig extends EnvMapSimpleParamConfig(NodeParamsConfig) {
}
class TextureEnvMapSimpleMatNode extends TypedMatNode {
  async material() {
    const container = await this.compute();
    return container.material();
  }
}
export class TextureEnvMapSimpleController extends BaseTextureMapController {
  constructor(node) {
    super(node);
    this.node = node;
  }
  initializeNode() {
    this.add_hooks(this.node.p.useEnvMap, this.node.p.envMap);
  }
  static async update(node) {
    node.controllers.envMap.update();
  }
  async update() {
    const material = await this.node.material();
    if (!_isValidMaterial(material)) {
      return;
    }
    await this.updateMaterial(material);
  }
  async updateMaterial(material) {
    await this._update(material, "envMap", this.node.p.useEnvMap, this.node.p.envMap);
    const combine = OperationByName[COMBINE_OPERATIONS[this.node.pv.combine]];
    material.combine = combine;
    material.reflectivity = this.node.pv.reflectivity;
    material.refractionRatio = this.node.pv.refractionRatio;
  }
  getTextures(material, record) {
    record.set("envMap", material.envMap);
  }
  setParamsFromMaterial(material, record) {
    const mapNode = record.get("envMap");
    this.node.p.useEnvMap.set(mapNode != null);
    if (mapNode) {
      this.node.p.envMap.setNode(mapNode, { relative: true });
    }
    this.node.p.combine.set(COMBINE_OPERATIONS.indexOf(NameByOperation[material.combine]));
    this.node.p.reflectivity.set(material.reflectivity);
    this.node.p.refractionRatio.set(material.refractionRatio);
  }
}
